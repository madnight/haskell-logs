00:01:34 <EvanR> while im in here
00:01:51 <EvanR> in this kind of type signature
00:01:53 <EvanR> readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s,a #)
00:02:34 <EvanR> is this supposed to be like the innards of an IO action or something
00:02:51 <EvanR> what is s ther
00:04:41 <EvanR> the real world thing? or something like the ST thing
00:07:30 <jle`> it's similar to the ST s thing
00:08:22 <EvanR> makeStableName# :: a -> State# (RealWorld) -> (# State# (RealWorld),StableName# a #)
00:08:37 <EvanR> here s=RealWorld
00:08:47 <EvanR> whats the difference
00:10:26 <EvanR> "RealWorld is deeply magical"
00:16:04 <nshepperd> readArray# can be used in an ST action
00:16:18 <nshepperd> makeStableName# can only be used in IO
00:17:11 <nshepperd> setting s=RealWorld sort of indicates that there are uncontainable side effects, i suppose
00:18:01 <EvanR> does s=anything in particular when you use ST
00:18:08 <Cale> no
00:18:37 <EvanR> gnarly
00:18:59 <nshepperd> runST :: (forall s. ST s a) -> a
00:19:08 <nshepperd> it's always forall'd
00:19:30 <EvanR> makes sense... 
00:31:29 <mniip> 1494745805 [10:10:05] <EvanR> "RealWorld is deeply magical"
00:31:34 <mniip> but not unlifted!
00:32:55 <EvanR> its primitive but not unlifted
00:33:05 <EvanR> cargo culted to all hell
00:33:10 <Lokathor> is that part of the magic?
00:33:18 <Lokathor> i think it's part of the magic
00:33:26 <EvanR> loll
00:33:32 <nshepperd_> RealWorld is not really that magical, is it
00:33:58 <nshepperd_> It's just something to put in a phantom type variable
00:34:08 <EvanR> watch what you write in comments it might be a religion in 3011
00:36:42 <EvanR> Question: Why @RealWorld@ - won't any instance of @_ST@ do the job? [ADR]
00:36:51 <EvanR> regarding makeStablePtr#
00:37:29 <Lokathor> if you didn't make it with RealWorld, it wouldn't be valid in the real world
00:37:56 <Lokathor> powers granted to oneself in a phased dimension can only last within that dimension; basic superhero comic rules apply here
00:39:40 <EvanR> the reasons for making makeStablePtr an IO action or ST action at all seem kind of accidental
00:40:36 <Lokathor> how do you mean
00:41:27 <nshepperd_> I dunno, presumably there are reasons to not want any old pure code to be able to make StableNames of your values, in a way that might depend on evaluation order
00:42:33 <edwardk> he issue with being able to construct stablenames in pure code is that you can then detect sharing that is fabricated by compiler optimizations
00:43:12 <edwardk> its like lambdas in scheme being declared to always allocate a 'fresh' location so you can compare them as objects
00:43:39 <edwardk> it actively gets in the way of optimization if you decide to be faithful to those semantics
00:44:08 <EvanR> you still weirdly detect things with the IO version, the stable name would have been one thing, but then you `evaluate` it and its now something else
00:44:34 <EvanR> so it feels like IO
00:44:34 <dmwit> But it's in IO. ST is supposed to promise "same inputs -> same outputs". IO doesn't promise that at all.
00:44:51 <edwardk> you can often reason case by case through whether or not your application is sound in the presence of such extra sharing, and unsafePerformIO or unsafeInterleaveIO or whatever your way to glory
00:45:24 <dmwit> Wait, why are you complaining? You say it feels like IO, and its type is an IO-y one (not an ST-y one). So what's the problem?
00:45:27 <edwardk> but its placement in IO allows for it giving different answers under different optimization levels, etc. it acts as a universal sin-bin you have to explicitly ask to get out of
00:45:50 <Lokathor> "a universal sin-bin"
00:45:50 <EvanR> considering your program with extra sharing, interesting
00:46:52 <edwardk> EvanR: e.g. i use stablename based sharing for one of the reverse mode implementations in the 'ad' package. that package just gets more efficient with extra sharing, so i'm okay with it 
00:47:15 <edwardk> same with the ersatz library, it just gets smaller formulas to send to the SAT solver
00:47:31 <edwardk> but i had to reason about those two cases meticulously by hand
00:48:17 <edwardk> amusingly for 'ad' i initially said it wasn't possible
00:48:18 <edwardk> http://stackoverflow.com/a/2745560/34707
00:48:25 <edwardk> before shipping a library and replying a second time
00:48:41 <edwardk> http://stackoverflow.com/a/2842605/34707
00:49:11 <Lokathor> edwardk, you said in a lighting talk that you wrote gl to impress non-haskell people. Well I told the part where it auto-generates almost all of the code to a non-haskell friend, and he /was/ impressed with it.
00:49:28 <edwardk> =)
00:49:57 <LiaoTao> Excuse me, but what 'gl'?
00:49:58 <edwardk> its just a few modules worth of code that in aggregate produce all the docs, etc. pretty pleased with it
00:50:08 <edwardk> http://hackage.haskell.org/package/gl
00:50:15 <LiaoTao> edwardk: Thanks
00:50:32 <EvanR> i am amazed that gl and sdl2 "just work"
00:50:36 <Lokathor> Now i'm muddling my way through learning opengl using a c++ tutorial, and writing up the haskell version as i go as a guide to others
00:50:36 <edwardk> its like 4-5 modules worth of code that parse the xml specification for opengl and fetch documentation, etc.
00:50:37 <EvanR> unlike in C
00:50:51 <edwardk> EvanR: =)
00:50:52 <Lokathor> EvanR, sdl2 doesn't "just work" on windows :P
00:50:58 <EvanR> gah...
00:51:19 <EvanR> i am amazed they just work on OSX
00:51:23 <edwardk> heh
00:51:46 <Lokathor> gl does just work on windows though!
00:51:51 <edwardk> anyways OpenGLRaw borrowed back the innovations from the gl package for the most part
00:52:09 <edwardk> so it is usable, even if the OpenGL package is a dumpster fire
00:52:26 <EvanR> right what is up with that
00:52:35 <EvanR> now we have two GL packages...
00:52:59 <EvanR> how do you throw away a dumpster 
00:53:14 <edwardk> EvanR: Sven wants me to retire 'gl' in favor of his OpenGLRaw package. I'm not willing to give up some of the things I need that only 'gl' offers and he has moral objections to adding them to OpenGLRaw
00:53:23 <Lokathor> EvanR, with a bigger dumpster of course
00:53:32 <edwardk> but OpenGL itself is the dumpster fire. OpenGLRaw is fine
00:53:49 <LiaoTao> edwardk: What things?
00:53:53 <Lokathor> edwardk, what are the things from 'gl' that aren't wanted in 'OpenGLRaw'?
00:54:00 <EvanR> ok, so we have at least 3
00:55:22 <nshepperd_> Hm, i should look at this stablename stuff in ad later. I've been using some explicit monadic stuff for reverse mode ad in neural networks, but it's pretty messy
00:55:55 <edwardk> there was an issue filed on one of the two projects on github that summarized why gl should die from Sven's point of view.
00:56:42 <edwardk> it looks like he did compromise and add the top level 'dangerous' booleans for each extension
00:56:59 <edwardk> oh i seem to recall
00:57:21 <edwardk> his pattern synonyms are monomorphic, which gets in the way of using them the way they are used in the actual opengl API
00:57:47 <Lokathor> I know there's a wiki page on the OpenGLRaw pakage's github where there's a summary of how OpenGLRaw and gl can eventually merge, but every divergence brought up is resolved with "we're doing it OpenGLRaw's way"
00:57:56 <Lokathor> which strikes... not of compromise
00:58:00 <edwardk> yeah
00:58:04 <edwardk> that page is what i mean
00:58:18 <edwardk> his 'solution" was kind of a slap in the face
00:58:24 <edwardk> so I've just decided to ignore it
00:58:38 <edwardk> OpenGLRaw may well win the war of maintenance
00:58:41 <edwardk> but after that I just don't care
00:59:17 <edwardk> i didn't write gl to merge. i wrote it so that i could write non-trivial opengl code that used OpenGL newer than 3.3. It let me write quine and a few other projects
00:59:34 <Lokathor> the slap in the face is the winky eomji at the end
01:00:35 <nshepperd_> Huh, top level booleans? I thought presence of such things would be relative to particular context, like a device
01:00:41 <edwardk> anyhow, it doesn't really matter if they coexist, as you can write code using both without issues
01:01:04 <edwardk> nshepperd_: gabriel's version had an explicit opengl context you had to pass around to all calls
01:01:14 <edwardk> this would be "cleaner" semantically
01:01:20 <edwardk> but it carries its own problems
01:01:33 <edwardk> the version in 'gl' can memoize that stuff
01:01:48 <edwardk> which matters a great deal if you're branching off it all over your code in something like
01:01:56 <edwardk> foo | gl_ARB_whatever = ... 
01:02:15 <edwardk> that eventually just "becomes" the fast path after evaluation
01:02:55 <edwardk> but you also get permanent overhead in each of the calls that use the ffi wrapper
01:02:56 <Lokathor> https://lokathor.gitbooks.io/using-haskell/content/opengl/hello-triangle.html#code-so-far it draws one whole triangle, and just begs to be rewritten with alloca, Either, and ExceptT :P
01:03:08 <edwardk> gl makes no apologies for the assumption that there is one opengl context for the entire program
01:03:14 <nshepperd_> I see
01:03:52 <edwardk> there are also 'io' based boolean versions of all the combinators, but 'gl' is kinda screwed if you use it in multiple OpenGL contexts during the run of an application
01:03:59 <edwardk> as it "links" as you call
01:04:26 <Lokathor> more than one context? or more than one context version?
01:04:51 <Lokathor> like could you have two windows with the same ogl context version that each had their own context?
01:05:08 <nshepperd_> Well, that makes sense i guess
01:05:13 <edwardk> https://github.com/polarina/opengl-wrangler/tree/master/Graphics has theoretical support for multiple contexts
01:05:44 <edwardk> Lokathor: depends on if the opengl version you have gives back different addresses for each context or not. nvidia plays nice
01:05:56 <edwardk> but it'd be perfectly within its rights to screw over the gl package
01:06:07 <Lokathor> oh no!
01:06:12 <edwardk> nvidia, amd, etc. all work
01:06:37 <edwardk> but if you bind one Intel context and one Nvidia one?
01:06:41 <edwardk> who knows
01:07:32 <edwardk> Lokathor: like i said, i wrote the parts i contributed to the library for me, trying to make it at least not suck _worse_ than writing c/c++ to talk to OpenGL
01:07:38 <edwardk> that motivates the MonadIO constraints, etc.
01:07:54 <Lokathor> i do like me some MonadIO
01:07:55 <edwardk> because without them it as just a pile of liftIO noise whenever you wrote anything non-trivial
01:08:23 <edwardk> which made comparison shopping haskell vs c/c++ for graphics code put us in a very bad light
01:08:30 <edwardk> its still not great
01:08:51 <Lokathor> that bad?
01:09:44 <edwardk> i've been debating about writing a completely pure immediate mode gui to help out with some stuff, that way you can just work with (MonadState s m, HasGui s) => ...  code and spew out immediate mode button drawing/interface checks with a couple of hooks per frame
01:10:01 <Lokathor> Rust has that, actually
01:10:09 <edwardk> they have a binding to imgui
01:10:24 <edwardk> i want a proper pure one
01:10:28 <Lokathor> do you mean conrod? or a different thing?
01:10:45 <edwardk> oh maybe they have another
01:11:08 <bjz> You are both right :P
01:11:10 <edwardk> yeah that looks kinda like what i'm getting after
01:11:17 <Lokathor> conrod is 2d GUI (that looks pretty bad) built on top of piston, which is a rust graphics/game engine sort of project
01:11:23 <bjz> Conrod is pure Rust
01:11:39 <bjz> imgui is on top of a C++ lib
01:11:44 <edwardk> i'm looking for something more in the tradition of dear imgui/nuklear 
01:11:55 <bjz> <3 imgui
01:12:00 <edwardk> nuklear at least lets you specify the 'context' you are working against.
01:12:04 <edwardk> which matters to me for vr
01:12:18 <edwardk> because my desktop refreshes at a different rate than the vr dashboard panels i need to update in 3d
01:12:27 <Lokathor> Once I know enough I wanna make a tile sprite library thing, so i can make a glyph grid with it, so i can emulate a terminal sort of interface
01:12:53 <Lokathor> built on top of just gl, if possible. the moment you touch FFI your chances of working easily on Window go out the window
01:12:57 <edwardk> so i want to be able to put something on the desktop and to put widgets in 3d for virtually grabbing and manipulating next to an object, and have separate mouse events, etc.
01:13:01 <Lokathor> Windows*
01:13:02 <dmwit> The lengths we go to to emulate 80's-era hardware...
01:13:11 <edwardk> dmwit: =)
01:13:39 <Lokathor> an AR overlay over a display that's already digital?
01:13:44 <edwardk> anyways the fact that dear imgui has one global context gets in the way of my using it for a lot of vr stuff nicely
01:14:30 <edwardk> and if i go it from scratch i can play around with true 3d widgets for vr use, signed distance fields for things like grabbers, etc.
01:14:37 <EvanR> im not emulating crap with this CRT television
01:14:50 <EvanR> with actual 240p video adapter
01:15:08 <EvanR> the spirit of the 80s is still alive
01:15:27 <edwardk> dmwit: you know how annoying it is to use a c64 emulator and play a game that is trying to alternate colors to get nice blending? )
01:15:46 <edwardk> i used to do that in a bunch of little shareware games i sold back as a kid
01:16:14 <Lokathor> dmwit, 1000 cores on the GPU, all of them powering nethack
01:16:27 <edwardk> had my little bard's tale engine that would alternate colors every frame so i could draw some (to my 13 year old eye) bad ass skeletons and stuff. =)
01:17:02 <ongy> my modern hardware goes great lengths to act like there's still a terminal :) and if they weren't so expensive I'd buy 1 or 2 actual terminals
01:17:20 <edwardk> Lokathor: there is alacritty, but darn it i want to go the next step one compute shader to do the actual text processing too, so you feed the raw input stream to the gpu and just tell it to draw after you finish
01:17:39 <edwardk> ongy: i have some old vt220s and what not in my mom's attic somewhere
01:17:55 <EvanR> who needs the cpu
01:17:56 <ongy> edwardk: and do syntax highlighting on the gpu? Or what would you offload?
01:17:56 <edwardk> they aren't all they are cracked up to be =)
01:18:40 <Lokathor> edwardk, i heard about alacritty, but its critical flaw is that it's not in Haskell of course :P
01:18:46 <EvanR> i cant seem to find the implementation of primops in the ghc source code
01:19:00 <Lokathor> also i'm not sure how to use it to let me build games on windows yet, so :?
01:19:13 <edwardk> ongy: the cursor position tracking, parsing of the escape code sequences, the whole screen emulation for the terminal so that rendering the screen becomes one compute shader pass to parse the text into changes in state, and a single draw call for a triangle that encompasses the window you want to draw
01:19:57 <edwardk> EvanR: i do, for all this spmd-on-simd stuff i'm doing to emulate a shader style of computation on the cpu of course!
01:20:11 <dmwit> edwardk: Yep, I remember having trouble developing for the TI-89 with an emulator for the same reason. Four colors of gray were a luxury reserved for people with actual hardware.
01:20:16 <EvanR> edwardk: nice. where
01:20:26 <ongy> edwardk: oh so you want the terminal emulator in there, that would be cool. I was thinking vim on GPU, which would be a bit weird
01:20:36 <edwardk> github.com/ekmett/rts  the /spmd repo had some code as well
01:20:56 <edwardk> ongy: there is a shadertoy
01:21:35 <EvanR> ah rts
01:21:40 <edwardk> https://www.shadertoy.com/view/XsXcDN
01:22:30 <edwardk> EvanR: vec<int,avx2_8> or vec<T*,avx_4> etc. act as 8 wide or 4 wide vector types, varying<int,avx2_8> acts as one that uses a current mask for loads/stores
01:23:19 <edwardk> soa<int,20000,avx2_8> gives you a 'array of structures of arrays'  computation model with template expressions to fuse together nice loops
01:23:32 <edwardk> next step is more primitive trig functions, exp, gamma, etc.
01:23:41 <edwardk> until i can run the kind of bayesian modeling stuff i like
01:24:07 <edwardk> the varying<> template acts like the shader varying keyword
01:24:25 <EvanR> ok
01:24:35 <EvanR> but where is e.g. makeStableName#
01:24:43 <edwardk> with auto in place, an if_(  ) template that uses a varying<bool> argument, etc. it goes a long way
01:24:47 <edwardk> its a long way from a haskell rts =)
01:25:30 <edwardk> right now its a start for a runtime system for some graphics stuff that may eventually morph into a haskell compiler rts as it gathers more code from other related repositories i have lying around
01:25:45 <EvanR> right
01:26:00 <EvanR> haskel as in... what ghc has become? or standard haskell? or something else
01:26:06 <edwardk> i need to get my cheap fiber code integrated so i can regain coherence when branching loses it, my code for an asio thread, all the epoch stuff so this doesn't leak
01:26:11 <EvanR> "common haskell"
01:26:28 <edwardk> whatever subset of haskell i need when i get around to it? =)
01:26:39 <edwardk> likely something closer to ermine's current subset
01:26:45 <EvanR> ah 
01:27:00 <edwardk> haskell + polykinds, etc. the stuff that makes implementing haskell easier
01:27:01 <edwardk> not harder
01:27:31 <edwardk> the #thc channel current gets the build bot spam for rts
01:27:37 <edwardk> er currently
01:27:52 <edwardk> mostly because it was drowning #haskell-lens
01:27:56 <EvanR> what is that channel
01:28:11 <EvanR> 420
01:28:17 <edwardk> #thc is my toy "turbo" haskell compiler
01:28:21 <EvanR> ah
01:28:34 <edwardk> not much of anything right now
01:28:55 <EvanR> turbo haskell, common haskell, visual haskell#
01:29:18 <c_wraith> When's Haskell++ ?
01:29:32 <EvanR> (haskell++)
01:30:03 <EvanR> fix (haskell++)
01:30:15 <edwardk> c_wraith: haskell'   <- we like our math notation around here
01:30:16 <c_wraith> is it broken?
01:30:42 <edwardk> > fix ("haskell"++)
01:30:44 <c_wraith> I wasn't referring to math though..  I was referring to the wonderful abomination of Microsoft J++
01:30:44 <lambdabot>  "haskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaskellhaske...
01:30:44 <EvanR> the first derivative of haskell
01:30:50 <edwardk> ^- looks broken to me
01:30:59 <edwardk> c_wraith: =)
01:31:00 <Cale> Haskmaster 4000 Turbo
01:31:44 <edwardk> hey man, i just want a modern version of technojock's toolkit. i was a god with that back in the day
01:38:36 <EvanR> found it...
01:38:42 <EvanR> for x86 at least
01:46:55 <ongy> let me guess, compiler intrinsics?
01:51:08 * hackage staversion 0.2.0.0 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.2.0.0 (debugito)
01:57:49 <ReinH> Objective Haskell?
02:01:10 <akr[m]> Hello, can someone help me with Conduit? How can I have my application yield data to a Consumer without having to live in the Producer monad? Intuitively, I'd like to have some sort of a channel which I can write into and which then serves as the Producer
02:01:14 <geekosaur> visualage haskell >.>
02:02:51 <bonz060> Hi guys
02:03:34 <c_wraith> akr[m]: why do you want to work that way?
02:03:50 <bonz060> Just starting out with haskell. What's the best book/ resources you have used to learn haskell?
02:05:16 <c_wraith> bonz060: https://github.com/bitemyapp/learnhaskell outlines a bunch of resources
02:06:11 <Gurkenglas> akr[m], is this for letting different threads interact? https://hackage.haskell.org/package/stm-conduit-3.0.0/docs/Data-Conduit-TMChan.html
02:06:12 <akr[m]> c_wraith: I'm writing a CLI client application with Brick which communicates with the server through JSON over TCP. I thought I could run this through conduits, using stuff from conduit-extra (Attoparsec using JSON parser from Aeson, and the Network conduit)
02:07:10 <bonz060> c_wraith: Thanks a bunch!
02:07:35 <Gurkenglas> akr[m], or even https://hackage.haskell.org/package/stm-conduit-3.0.0/docs/Data-Conduit-Async.html which creates the threads for you
02:08:19 <akr[m]> Gurkenglas: okay, but I still don't see how to make it so that my entire application doesn't have to live in the Source / Producer monad
02:09:42 <c_wraith> akr[m]: if you use https://hackage.haskell.org/package/stm-conduit-3.0.0/docs/Data-Conduit-TMChan.html you can send things to the TMChan from anywhere in IO.
02:10:05 <c_wraith> akr[m]: and then a producer reads from it and sends it down the pipeline
02:11:33 <c_wraith> that looks like it was built against a really old version of conduit, though..
02:11:37 <akr[m]> I don't see what's the "API" to push stuff into the channel
02:12:08 * hackage hdaemonize 0.5.3 - Library to handle the details of writing daemons for UNIX  https://hackage.haskell.org/package/hdaemonize-0.5.3 (sickmind)
02:12:22 <c_wraith> akr[m]: it's just a TMChan or TBMChan
02:12:50 <akr[m]> ah I see
02:13:05 <akr[m]> well, it looks like it should build with the latest conduit
02:13:15 <c_wraith> it does look like it should.
02:15:18 <akr[m]> yay, it compiledd :)
02:15:41 <akr[m]> thank you everyone, hopefully I'll be able to connect it all together now
02:16:32 <EvanR> hmm ghc makes a lot of use of not String, not Text, no not ByteStrings... but two other kinds of strings: FastString and LitStr (which is basically a pointer to a C String). intrestring!
02:17:39 <torstein> does anyone know if there's hoogle integration available for (space)emacs? 
02:26:53 <EvanR> and FastStrings are built from string literals using... a primitive
02:41:23 <Gurkenglas> akr[m], just tinkering here but since Producer b is just Proxy Void () () b, you could, according to https://hackage.haskell.org/package/pipes-4.3.3/docs/src/Pipes-Internal.html#Proxy , have the topmost provider of the consumer return values of what looks like "Respond b (Producer b) | M (m (Producer b)) | Pure r"
02:42:30 <Gurkenglas> Which looks like ListT done right... *looks around* ah there https://hackage.haskell.org/package/pipes-4.3.3/docs/Pipes.html#v:every
02:43:25 <akr[m]> so the downstream from the server needs to be forwarded to a channel provided by the Brick interface
02:43:57 <Gurkenglas> Perhaps some library provides downstreams from a server as conduits?
02:44:37 <akr[m]> well yeah, conduit-extra provides TCP conduits
02:44:54 <akr[m]> nice examples here: http://www.yesodweb.com/blog/2014/03/network-conduit-async
02:45:08 <Gurkenglas> *"the topmost provider of the producer" gah
02:50:54 <Gurkenglas> akr[m], why would your whole application have to live in Producer? Are you missing "lift :: m r -> Producer b m r" from MonadTrans?
02:54:02 <akr[m]> uh I'm not sure
02:54:35 <akr[m]> I need to be able to communicate back to the server from this callback function in Brick: https://github.com/jtdaugherty/brick/blob/master/docs/guide.rst#apphandleevent-handling-events
03:08:13 <CoolerZ> anyone use haskell-mode on emacs?
03:10:43 <hvr> CoolerZ: try #haskell-emacs :-)
03:11:55 <paolino> join #haskell-cabal
03:12:44 <CoolerZ> how do you enable auto-complete?
03:26:36 <ertes> CoolerZ: if you use haskell-interactive-mode (and you probably will, because it's awesome), you will get GHCi-aided auto-completion automatically
03:27:13 <CoolerZ> ertes, i tried that it does something weird, all the text becomes read only and the syntax highlighting turns off
03:27:27 <CoolerZ> and a new line popsup at the bottom with      lambda >
03:28:07 <ertes> CoolerZ: that's a different buffer, your interaction buffer
03:28:23 <ertes> CoolerZ: it should pop up in a new (emacs) window by default
03:28:36 <CoolerZ> no its in the same buffer
03:28:58 <ertes> are you sure?  pay attention to the buffer name
03:29:01 <cocreature> you shouldn’t just enable haskell-interactive-mode. you should start the repl and then haskell-interactive-mode will be enabled in there
03:29:17 <ertes> oh, yeah
03:29:24 <ertes> don't enable the mode
03:29:33 <ertes> load your file (C-c C-l)
03:30:35 <CoolerZ> C-c C-l is electric C mode?
03:30:57 <systadmin> Emacs?
03:31:18 <ertes> CoolerZ: if you type that in a haskell buffer, it will load your file into GHCi
03:31:36 <ertes> "C-" is emacs' notation for "ctrl+"
03:31:49 <ertes> so type ctrl+c, then ctrl+l
03:32:23 <kqr> is it possible to define a function that has a type similar to "f :: Maybe a" and then for some specific types a it will return (Just Specific) and for all others Nothing?
03:32:26 <cocreature> you might need to enable interactive-haskell-mode (those names are terrible) for this to work. I don’t recall if that’s the default by now
03:32:32 <kqr> so essentially something that dispatches on return type
03:32:40 <kqr> i guess this touches on typeclasses?
03:32:46 <kqr> but i'm not confident
03:33:01 <Rembane> kqr: If you put the return type in a sum type first it is easy
03:33:17 <ertes> kqr: not with that type
03:33:17 <kqr> Rembane, if I want to avoid that, though? heh
03:33:22 <cocreature> kqr: a) Maybe a is not a function b) you can make a typeclass and then make instances but if you only want it to behave differently for some types you need OverlappingInstances and it becomes slightly messy
03:33:29 <ertes> kqr: f :: (Typeabiel a) => Maybe a
03:33:34 <Rembane> kqr: I have no idea. :D
03:33:40 <kqr> ertes, looking at typable but not sure how to use it
03:33:48 <kqr> at least not for this purpose
03:33:53 <ertes> kqr: you can use typeOf, and then compare
03:34:11 <ertes> > typeOf (Just 15 :: Maybe Int)
03:34:13 <lambdabot>  Maybe Int
03:34:38 <ertes> > typeOf (Just 15 :: Int) == typeOf (15 :: Int)
03:34:40 <lambdabot>  error:
03:34:40 <lambdabot>      • Couldn't match expected type ‘Int’
03:34:40 <lambdabot>                    with actual type ‘Maybe Integer’
03:34:46 <kqr> ertes, hm. but in this case I don't have a specific Maybe a, I want to conjure one depending on which type is expected
03:34:53 <ertes> > typeOf (15 :: Int) == typeOf (15 :: Int)
03:34:54 <kqr> ertes, i'm more and more thinking this is exactly what typeclasses do
03:34:55 <lambdabot>  True
03:35:10 <ertes> kqr: yes, but you can't have a catch-all instance
03:35:19 <kqr> ertes, ah, true
03:36:22 <ertes> kqr: what do you need this for anyway?
03:37:00 <CoolerZ> ertes, well i did C-c C-l and it told me to do C-h f haskell-mode to see how to use interactive-haskell
03:37:31 <CoolerZ> and from that i found   interactive-haskell-mode
03:37:42 <lyxia> > typeRep (Proxy :: Proxy (Maybe Int))  -- You don't need a value to get a typeRep, kqr
03:37:44 <lambdabot>  Maybe Int
03:39:25 <ertes> CoolerZ: yeah, you need to add the hook
03:39:28 <cocreature> ertes: you absolutely can with OverlappingInstances :)
03:39:48 <CoolerZ> and i enabled it, but it doesn't seem to do anything
03:40:18 <ertes> CoolerZ: hooks are buffer-local…  close and reopen the file
03:43:09 <CoolerZ> ertes, i did then what?
03:44:00 <ertes> CoolerZ: C-c C-l
03:44:25 <CoolerZ> Run ‘C-h f haskell-mode‘ for instruction how to setup a Haskell interaction mode.
03:44:41 <CoolerZ> and that opens up a help page
03:45:09 <ertes> CoolerZ: note that there is a gap between writing something into .emacs and actually making it take effect…  you might be in this gap right now =)
03:45:29 <ertes> CoolerZ: either go evaluate what you wrote, or…  at this point…  just restart emacs ;)
03:45:38 <CoolerZ> i haven't written anything to .emacs regarding haskell-mode
03:45:55 <ertes> how did you enable the hook?
03:46:10 <CoolerZ> what hook
03:46:34 <CoolerZ> oh actually i did add something
03:51:51 <CoolerZ> ertes, https://hastebin.com/domoheroke.lisp
03:52:05 <Gurkenglas> kqr, https://hackage.haskell.org/package/plugins-1.5.6.0/docs/System-Eval-Haskell.html#v:eval has something like that
03:52:14 <ertes> CoolerZ: can't see pastes on that site
03:53:03 <CoolerZ> ertes, http://lpaste.net/7212055598215462912
03:53:45 <ertes> CoolerZ: add this at the bottom: (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
03:54:14 <ertes> then position the point on that like and type: C-M-x
03:54:32 <ertes> then reopen the file and try to load it
03:58:15 <CoolerZ> ertes, what do you load it? i typed C-x C-l after reopening the .hs file
03:58:23 <CoolerZ> and it shows up downcase region
03:59:01 <ertes> CoolerZ: i'll let you figure this one out by yourself =)
04:03:47 <CoolerZ> ertes, oh its C-c C-l yeah that works, it opens up the repl in a new frame
04:03:52 <CoolerZ> new window, not frame
04:05:11 <CoolerZ> i still don't get autocomplete
04:06:23 <CoolerZ> ertes, do you get autocomplete like it shows here? http://haskell.github.io/haskell-mode/manual/latest/Completion-support.html#Completion-support
04:07:15 * dysfun overheard someone pronounce 'GADTs' as 'gadduhts', feels uncomfortable
04:08:13 <cocreature> dysfun: I think it’s the standard pronounciation. I’ve heard it used by quite a lot of people
04:08:34 <dysfun> really? i always spell out the letters
04:08:53 <dysfun> but for the longest time i'd do the same for 'SQL' too
04:08:59 <cocreature> richard eisenberg uses it and he should know :)
04:09:04 <Athas> I still do that.
04:09:10 <dysfun> it's richard eisenberg i'm watching
04:09:29 <Athas> I also feel weird pronouncing abbreviations, especially if they are not really pronouncable.
04:09:33 <mniip> huh
04:09:48 <mniip> I pronounce them just 'gedts'
04:09:51 <mniip> without the uh
04:09:52 <Athas> I guess I'm inconsistent in not spelling out NATO, but spelling out GADT.
04:10:02 <Axman6> "gads"?
04:10:10 <CoolerZ> silent T
04:10:19 <mniip> no like I can pronounce 'dt'
04:10:22 <mniip> can you not?
04:10:33 <dysfun> my tongue doesn't know how to make that sound
04:10:46 <Athas> GADT is easily pronouncible in languages with soft 'd's.  Sad that English is not among those.
04:10:49 <mniip> guess german classes have finally paid off
04:11:00 <CoolerZ> i keep thinking Gadgets
04:11:20 <Athas> mniip: you pronounce GADT to rhyme with "stadt"?
04:11:27 * dysfun tends to pronounce 'dt' as if the 'd' was almost invisible
04:11:32 <ertes> CoolerZ: i get auto-complete on M-tab
04:11:41 <mniip> Athas, kinda
04:11:41 <dysfun> stadt -> 'stat', more or less
04:11:55 <CoolerZ> ertes, does it show the drop-down menu like in that gif?
04:12:46 <mniip> dysfun, Stadtstaat
04:12:47 <CoolerZ> ertes, also alt-tab is a reserved hot key to switch windows
04:13:06 <ertes> CoolerZ: no, because that requires another extension…  never throught i really need it, so i'm going with the standard completions
04:13:18 <dysfun> mniip: no clue :P
04:13:24 <CoolerZ> ertes, which extension?
04:13:44 <ertes> CoolerZ: you can put it on a different key, but i can't give you an emacs tutorial here =)
04:15:24 <CoolerZ> it doesn't say that you need a new extension on the page
04:15:44 <CoolerZ> "haskell-mode can complete symbols, pragma directives, language extensions, and language keywords out-of-box."
04:15:54 <mniip> huh
04:16:00 <CoolerZ> false advertising
04:16:03 <mniip> what os do you use where alt-tab is intercepted by the os
04:16:17 <ertes> CoolerZ: you're expected to know that…  extensions in emacs "compose"
04:16:34 <CoolerZ> ertes, which extension though
04:16:45 <ertes> you choose your own completion extension (or go with the default one like me), and haskell-mode will automatically use it
04:17:05 <ertes> CoolerZ: again, i can't give you an emacs tutorial here…  at this point you should start learning emacs =)
04:17:10 <Myrl-saki> Should I use PVP or Semver?
04:17:17 <Myrl-saki> Just use spacemacs and be happy.
04:17:19 <CoolerZ> ertes, whats the name of the extension
04:17:28 <ertes> CoolerZ: i don't know
04:17:42 <CoolerZ> they don't say on the page
04:18:43 <CoolerZ> this is bs you can't just put gifs of something your package doesn't do in whats supposed to a manual
04:18:58 <CoolerZ> and not even mention the extension
04:19:16 <mniip> Myrl-saki, I prefer pve but that's just m
04:19:17 <mniip> e
04:20:00 <Myrl-saki> mniip: Sounds like you'd be the worst DOTA 2 teammate.
04:20:47 <ertes> CoolerZ: i found this by searching for "emacs dropdown completion": https://www.emacswiki.org/emacs/AutoComplete
04:21:28 <mniip> Myrl-saki, I don't play games for the mentally challenged
04:21:52 <Myrl-saki> mniip: I feel hurt.
04:22:03 <mniip> apply cold water
04:23:51 * Myrl-saki spills cold water on mniip
04:24:24 <CoolerZ> ertes, looking at the url for those gifs, it says company-mode http://haskell.github.io/haskell-mode/manual/latest/anim/company-mode-import-statement.gif
04:24:35 <CoolerZ> and i found this https://github.com/iquiw/company-ghc
04:24:47 <ertes> CoolerZ: something you could have done yourself instead of going: "look how nice their theme looks!  but it wasn't included in this completion package!  false advertising!!1111"
04:25:11 <CoolerZ> ertes, its not a theme
04:25:32 <ertes> CoolerZ: that's not the point, but anyway, this is no longer haskell-related
04:25:35 <CoolerZ> and its still false advertising, cause its a completely different package
04:25:47 <ertes> no, it's not
04:25:53 <ertes> … false advertising
04:26:18 <CoolerZ> and they don't even mention the name of the extension
04:27:28 <CoolerZ> its actually this one https://company-mode.github.io/
04:28:14 <bennofs> CoolerZ: company-ghc is a backend for company-mode, so you'd need both
04:28:38 <CoolerZ> yeah
04:28:45 <dysfun> company is awesome, btw
04:29:07 <dysfun> by far the best option in its category, generally
04:29:13 <bennofs> CoolerZ: hmm, "If haskell-interactive-mode is enabled and working Haskell mode provides completions for import statements taking into account currently loaded and available packages."
04:29:34 <bennofs> CoolerZ: so those haskell-mode gifs probably only work if you have a REPL started via haskell mode
04:29:50 <CoolerZ> bennofs, i have that already, but it doesn't do that
04:36:06 <bennofs> CoolerZ: works for me, after loading a buffer into the REPL with bare bones haskell mode
04:36:39 <bennofs> CoolerZ: (and then writing import Data.<Alt-Tab>)
04:38:02 <CoolerZ> bennofs, its shows a drop-down menu?
04:38:34 <bennofs> CoolerZ: it uses the default emacs completion framework
04:39:01 <bennofs> CoolerZ: if you want another completion system, install it (and haskell-mode will integrate with it)
04:39:28 <CoolerZ> bennofs, thats what i am doing
04:40:23 <bennofs> CoolerZ: just saying, it "works as advertised" 
04:40:57 * ertes has a deja-vu =)
04:41:04 <CoolerZ> bennofs, sure if you know that auto-complete is alt-tab and that it won't show a drop-down menu of suggestions
04:41:16 <CoolerZ> and that you need to install something entirely different
04:41:19 <CoolerZ> then yeah
04:41:38 <ertes> the virtues of trying to learn two things at once:  emacs and haskell-mode
04:41:43 <bennofs> CoolerZ: well, but that is how *emacs* works. it works the same way for every other language mode that provides auto completion
04:42:55 <bennofs> CoolerZ: in emacs, you can configure how auto completion works and what backends it uses. these two are separate, so demoing a backend can be done with any way to use said backend (in this example, the frontend used was company mode, but that doesn't change anything about the features of the backend which is what the example wanted to demo)
04:42:59 <CoolerZ> do i just need company-mode or do i need company-ghc?
04:43:15 <CoolerZ> compay-ghc need ghc-mod to be installed via cabal
04:43:16 <bennofs> CoolerZ: if you are happy with the haskell-mode integrated completion, you only need company-mode
04:43:51 <bennofs> CoolerZ: company-ghc is another backend for completion based on ghc-mod (so it doesn't use the REPL powered completion that haskell-mode uses)
04:44:17 <bennofs> CoolerZ: if you just want what haskell-mode shows, use company-mode with the company-capf (included with company-mode) backend
04:44:45 <bennofs> [capf just forwards to the standard completion-at-point emacs function]
04:44:58 <CoolerZ> didn't someone say something about autocompletion only working if the last load into ghci was successful?
04:45:23 <ertes> it has a fallback to TAGS-based completion
04:45:39 <ertes> that requires some setup though
04:45:40 <CoolerZ> so is ghc-mod better?
04:45:52 <CoolerZ> company-ghc i mena
04:45:55 <CoolerZ> mean*
04:47:10 <Myrl-saki> :: (a -> Bool) -> m a -> m a
04:47:17 <Myrl-saki> `until`, monadic version.
04:47:26 <Myrl-saki> Any ideas?
04:48:13 <lyxia> Myrl-saki: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html iterateUntil
04:48:42 <CoolerZ> oh this says to add a haskell-mode-hook for ghc-mod http://www.mew.org/~kazu/proj/ghc-mod/en/preparation.html
04:48:43 <Myrl-saki> lyxia: THanks.
04:48:56 <CoolerZ> but theres already a hook for haskell-mode
04:49:10 <CoolerZ> can you have multiple hooks?
04:53:33 <bennofs> CoolerZ: company-mode supports multiple backends
04:53:53 <bennofs> CoolerZ: yes you can have multiple hooks
04:54:19 <ertes> Myrl-saki: that doesn't look like 'until'
04:55:05 <Myrl-saki> ertes: lmao
04:55:18 <Myrl-saki> ertes: It's kinda `until`-ish.
04:58:55 <Myrl-saki> :t forever
04:58:57 <lambdabot> Applicative f => f a -> f b
04:59:57 <Myrl-saki> :t when
04:59:59 <lambdabot> Applicative f => Bool -> f () -> f ()
05:00:35 <Myrl-saki> No builtin for `Applicative f => Bool -> f a -> f ()`?
05:01:02 <ertes> :t void
05:01:04 <lambdabot> Functor f => f a -> f ()
05:01:06 <Myrl-saki> (I mean sur, void.)
05:01:11 <Myrl-saki> ertes: Too lazy to put void.
05:01:59 <hpc> :t guard
05:02:01 <lambdabot> Alternative f => Bool -> f ()
05:02:22 <Myrl-saki> hpc: guard is failure.
05:02:48 <ertes> good luck convincing GHC to cut you some slack for being lazy =)
05:02:51 <hpc> oh right, i was thinking of when
05:03:09 <Myrl-saki> ertes: :P
05:03:49 <ertes> :t \p c -> void (runMaybeT (guard p >> lift c))
05:03:50 <lambdabot> error:
05:03:50 <lambdabot>     Variable not in scope: runMaybeT :: t0 m b -> f a0
05:04:03 <ertes> @let import Control.Monad.Trans.Maybe
05:04:05 <lambdabot>  Defined.
05:04:06 <ertes> :t \p c -> void (runMaybeT (guard p >> lift c))
05:04:08 <lambdabot> Monad f => Bool -> f a -> f ()
05:04:21 <hpc> :t \p c -> if p then c *> pure () else pure ()
05:04:22 <lambdabot> Applicative f => Bool -> f a -> f ()
05:04:41 <hpc> :t void
05:04:43 <lambdabot> Functor f => f a -> f ()
05:04:55 <hpc> ah, if p then void c else pure ()
05:05:02 <bollu> this is #haskell-offtopic-ish: does idris have theories for linear algebra and metric spaces?
05:05:11 <bollu> I asked on #idris, no one responded
05:05:13 <ertes> :t \p c -> sequenceA [ c | p ]
05:05:15 <lambdabot> Applicative f => Bool -> f a -> f [a]
05:05:19 <ertes> :t \p c -> sequenceA_ [ c | p ]
05:05:21 <lambdabot> Applicative f => Bool -> f a -> f ()
05:05:27 <bollu> I want to encode some facts about polyhedra, so my choices as far as I can tell are Coq, isabelle, LEAN, and idris
05:08:11 <Eduard_Munteanu> bollu, don't forget Agda
05:09:14 <Eduard_Munteanu> It doesn't really have anything on linear spaces, AFAIK.
05:11:36 <bollu> ah, right
05:11:52 <bollu> Eduard_Munteanu: do there more "programming" things have linear spaces?
05:12:05 <Gurkenglas> Myrl-saki, should you be too lazy to put void? It tells the reader you're destroying information. What exactly are you discarding?
05:12:20 <bollu> Eduard_Munteanu: I need basic functional analysis: interaction between linear stuff, affine stuff, and metrics
05:13:00 <Eduard_Munteanu> bollu, you may be able to find something written in Haskell, if you don't need strict proving stuff.
05:14:59 <bollu> Eduard_Munteanu: I do, actually
05:15:13 <bollu> Eduard_Munteanu: I just want to encode proofs, because I'm reading from a book that does a lot of "this follows"
05:15:19 <bollu> Eduard_Munteanu: and I'd like to check that I understand it correctly
05:15:34 <bollu> Eduard_Munteanu: (and being able to extract a correct implementation of an algorithm that is described at the end would be sweet"
05:15:38 <bollu> Eduard_Munteanu: so, well
05:15:44 <bollu> Eduard_Munteanu: I guess Coq it is?
05:16:04 <Eduard_Munteanu> Well, yeah, there's a whole lot more stuff written for Coq.
05:16:41 <Eduard_Munteanu> But usually theorem provers are a nuisance if you just want to follow a math book. Some things may be really difficult to prove formally.
05:17:13 <bollu> Eduard_Munteanu: yeah, but I want to try as an experiment, since the "end result" of the book is an algorithm that counts lattice points in polyhedra
05:17:14 <ertes> i used agda to really understand category theory…  it was very helpful, but also an experience i wouldn't want to repeat
05:17:27 <bollu> so it would be cool to show that we have a "correct" implementation of this
05:17:40 <ertes> agda is not much of a proof *assistant* at all
05:18:42 <bollu> yeah, I understand
05:18:43 <bollu> but, well
05:18:45 <bollu> so, Coq?
05:19:36 <ertes> bollu: coq has a large library of predefined stuff, and most of the dirty work can be done via tactics
05:19:46 <bollu> I see
05:20:05 <bollu> ertes: are you familiar with isabelle?
05:20:31 <ertes> not really…  i tried it a few times, but it never worked very well
05:20:37 <bollu> I see
05:36:30 <Eduard_Munteanu> ertes, lately, Agda's got some tactics too
05:37:03 <Eduard_Munteanu> Not as good/pervasive as Coq's, but still.
05:38:52 <ertes> there are other problems with agda like the ridiculously explicit treatment of universes
05:39:06 <ertes> my definition of Functor had six level arguments
05:40:02 <ertes> this is stuff i feel could easily be inferred
05:40:59 <Eduard_Munteanu> In Coq, provey bits live in Type, which has no levels.
05:42:05 <Eduard_Munteanu> Or Prop, I forget.
05:42:37 <Eduard_Munteanu> It also helps that their levels are cumulative.
05:43:47 <Eduard_Munteanu> (something in Set k is also in Set (k+1))
05:51:08 <Myrl-saki> @pl (\a x -> f x : a)
05:51:08 <lambdabot> flip ((:) . f)
05:51:15 <Myrl-saki> That's disgusting.
05:52:14 <Taneb> Myrl-saki, the output of pl almost always is
05:52:41 <Myrl-saki> @pl (\ f g (x:xs) -> f x:g xs
05:52:41 <lambdabot> (line 1, column 26):
05:52:42 <lambdabot> unexpected end of input
05:52:42 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or ")"
05:52:44 <Myrl-saki> @pl (\ f g (x:xs) -> f x:g xs)
05:52:45 <lambdabot> flip flip tail . (ap .) . flip flip head . ((.) .) . flip . (((.) . (:)) .)
05:52:53 <Myrl-saki> Okay. I give up.
05:53:30 <pacak> Nice flipping lambdabot!
05:54:07 <Myrl-saki> pacak: I think he's flipping me off.
05:54:30 <pacak> Myrl-saki: You are asking for something strange.
05:54:37 <Eduard_Munteanu> It should be called acrobatics.
05:55:15 <pacak> > over _head (*3) [1..3]
05:55:17 <lambdabot>  [3,2,3]
05:56:33 <pacak> It's hard to tell what are you trying to do
05:59:49 <systadmin> hmm
06:00:14 <systadmin> Is there like, an alternative to getLine and readLine that asks for an integer only?
06:02:02 <Tuplanolla> :t fmap readMaybe getLine :: IO (Maybe Integer) -- Like this, systadmin?
06:02:04 <lambdabot> IO (Maybe Integer)
06:02:37 <systadmin> Tuplanolla: is it like getLine but the input must be an Int?
06:02:53 <Tuplanolla> You have the definition right there.
06:03:14 <systadmin> Oh
06:03:24 <systadmin> yeah I'm still bad at Haskell
06:11:25 <NStress> ★ NStress.info ★ Reliable DDoS Service ★ 175 Gbps guaranteed ★ https://www.nstress.info/
06:15:53 <mrkgnao> Was that a spam message right there?
06:16:19 <pacak> mrkgnao: Yes.
06:16:38 <ertes> yeah…  we could set up a crowdfunding campaign to buy DDoS traffic and point it at the provider
06:17:37 <pacak> ertes: This domain is hosted by  cloudflare.
06:17:50 <hpc> lol
06:17:50 <pacak> (not surprised)
06:18:27 <pacak> Also it's currently down.
06:18:44 <ertes> cloudflare is a problem anyway…  i wouldn't mind them disappearing =)
06:22:04 <pacak> Too bad it's down - I wanted to write an email to cloudflare abuse...
06:26:46 <CoolerZ> type doesn't create new data constructors right?
06:26:51 <CoolerZ> only new type constructors?
06:27:38 <mekeor> CoolerZ: yes
06:37:09 <cocreature> it doesn’t create type constructors. it’s just an alias for an existing constructor
06:40:47 <mniip> 1494767777 [16:16:17] <ertes> yeah…  we could set up a crowdfunding campaign to buy DDoS traffic and point it at the provider <- hahaha http://tcpst.net/pfq_.png
06:42:08 * hackage czipwith 1.0.0.0 - CZipWith class and deriving via TH  https://hackage.haskell.org/package/czipwith-1.0.0.0 (lspitzner)
06:58:22 <CoolerZ> does Data.Map have a toArr function?
06:58:35 <CoolerZ> need to iterate over the values
06:59:13 <CoolerZ> actually  type ItemTree = Map.Map String [Item]
06:59:38 <CoolerZ> need   toArr :: Map.Map String [Item]
06:59:39 <CoolerZ>  -> [Item]
07:01:34 <cocreature> :t Data.Map.elems
07:01:36 <lambdabot> M.Map k a -> [a]
07:01:55 <octarin> -quit
07:03:06 <CoolerZ> cocreature, that would give me [[Item]]
07:03:10 <CoolerZ> concat?
07:03:22 <cocreature> :t concat . Data.Map.elems
07:03:24 <lambdabot> M.Map k [a] -> [a]
07:03:44 <Myrl-saki> I think this sounds stupid.
07:04:00 <Myrl-saki> :: Integral a => a -> [b] -> [a]
07:07:32 <Myrl-saki> foo n xs = (\i -> n*i `div` length xs)<$> zipWith const [0..length xs-1] xs
07:07:38 <Myrl-saki> That seems... ugly.
07:07:54 <Myrl-saki> :t foo n xs = (\i -> n*i `div` length xs)<$> zipWith const [0..length xs-1] xs
07:07:56 <lambdabot> error:
07:07:56 <lambdabot>     parse error on input ‘=’
07:07:56 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
07:08:10 <Myrl-saki> :t \n xs -> (\i -> n*i `div` length xs) <$> zipWith const [0..length xs-1] xs
07:08:12 <lambdabot> Int -> [b] -> [Int]
07:08:26 <CoolerZ> i find it annoying that emacs can't just autocomplete stuff i have already typed
07:08:31 <Myrl-saki> @pl \n xs -> (\i -> n*i `div` length xs) <$> zipWith const [0..length xs-1] xs
07:08:31 <lambdabot> (`ap` (zipWith const =<< enumFromTo 0 . subtract 1 . length)) . ((<$>) .) . (. (flip div . length)) . (.) . (*)
07:08:43 <Myrl-saki> enumFromTo, huh.
07:08:54 <Myrl-saki> That might actually work.
07:10:10 <Myrl-saki> @pl \n xs -> map (\i -> i*length xs `div` n) . enumFromTo 0 $ length xs - 1)
07:10:10 <lambdabot> (line 1, column 72):
07:10:10 <lambdabot> unexpected ')'
07:10:10 <lambdabot> expecting digit, variable, "(", operator, "+", "-", "$", "$!", "`seq`" or end of input
07:10:24 <Myrl-saki> @pl \n xs -> map (\i -> i*length xs `div` n) . enumFromTo 0 $ length xs - 1
07:10:25 <lambdabot> (`ap` (subtract 1 . length)) . flip flip (enumFromTo 0) . (((.) . map . (*)) .) . flip (div . length)
07:12:38 <ertes> CoolerZ: see dabbrev
07:13:08 * hackage optparse-generic 1.2.0 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.2.0 (GabrielGonzalez)
07:13:21 <Philonous> CoolerZ, dabbrev-expand ?
07:13:29 <Philonous> Oh, too late :/
07:14:21 <CoolerZ> ertes, does that have a drop-down menu?
07:14:33 <CoolerZ> or do i need a extension for that
07:14:57 <CoolerZ> i would like it be on by default like auto complete
07:15:27 <Philonous> CoolerZ, You can use dabberev as a backend for  company 
07:15:45 <CoolerZ> nice
07:16:24 <ertes> i actually use dabbrev and symbol completion separately, because i know which i'll need which, so i get to the desired result quicker
07:20:18 <Myrl-saki> :t unfoldr
07:20:19 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
07:21:36 <Myrl-saki> @pl \n xs -> unfoldr (\i -> if i < (length xs) then Just (n*i `div` length xs,succ i) else Nothing) 0
07:21:37 <lambdabot> flip flip 0 . (unfoldr .) . flip flip Nothing . (flip .) . ap (ap . (if' .) . flip (<) . length) . ((Just .) .) . flip flip succ . (liftM2 (,) .) . (. (flip div . length)) . (.) . (*)
07:21:48 <Myrl-saki> This just gets worse and worse lol
07:22:16 <Myrl-saki> Oh wait.
07:22:18 <Myrl-saki> :t filterM
07:22:20 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
07:22:56 <Myrl-saki> > filterM id [Nothing, JUst 1]
07:22:59 <lambdabot>  error:
07:22:59 <lambdabot>      • Data constructor not in scope: JUst :: Integer -> Maybe Bool
07:22:59 <lambdabot>      • Perhaps you meant ‘Just’ (imported from Data.Maybe)
07:23:00 <Myrl-saki> > filterM id [Nothing, Just 1]
07:23:03 <lambdabot>  error:
07:23:03 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘1’
07:23:03 <lambdabot>      • In the first argument of ‘Just’, namely ‘1’
07:25:37 <Myrl-saki> @pl \n xs -> zipWith (\i _ -> i*n `div` length xs) [0..] xs
07:25:37 <lambdabot> join . flip flip [0..] . ((zipWith . (const .) . (*)) .) . (. length) . div
07:25:43 <Myrl-saki> I think I'll go with that lol
07:27:16 <CoolerZ> nice dabbrev for code works
07:44:48 <CoolerZ> did things change recently? on hackage it says GHC.OldList
07:45:58 <CoolerZ> in ghci it says isUpper is from GHC.List
07:46:17 <CoolerZ> oh nvm thats (!!)
07:55:08 * hackage GPipe 2.2.1 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.2.1 (TobiasBexelius)
08:00:46 <pie_> you guys know any decompilers / disassemblers written in haskell that i can look at?
08:03:31 <Axman6> I don't know of any
08:06:54 <pie_> found this so far but not much else https://github.com/gereeter/hsdecomp
08:07:45 <pie_> oh wait thats written in python
08:07:52 <pie_> well this is something https://github.com/search?utf8=%E2%9C%93&q=language%3Ahaskell+decompiler&type=
08:08:21 <mniip> for a second I thought you wanted to decompile haskell
08:08:24 <pie_> https://github.com/search?utf8=%E2%9C%93&q=language%3Ahaskell+disassembler&type=
08:08:36 <pie_> mniip, yeah that would be cool but not what im looking for right now xD
08:08:47 <pie_> in know, sorry for the link messup >P
08:08:48 <pie_> * :P
08:25:17 <chewzerita> :t any
08:25:18 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:30:35 <Gurkenglas> Myrl-saki, you'll want to have length xs outside a lambda if you want it shared: \n xs -> map (`div` length xs) $ zipWith const [0,n..] xs
08:41:48 <CoolerZ> i am getting warnings that certain record functions(getters inside record syntax) are not used
08:42:00 <CoolerZ> even though they are used later in the same file
08:42:12 <CoolerZ> there are no error
08:42:13 <CoolerZ> s
08:42:22 <hseg> Hi. I'm trying to get git-annex set up under cygwin on windows. Its dependency dns-2.0.10 doesn't build on windows, how do I tell stack to try using an older version?
08:43:03 <Gurkenglas> CoolerZ, paste?
08:43:16 <mrkgnao> hseg: have you tried changing the version in the cabal file?
08:43:37 <Myrl-saki> @pl 
08:43:37 <lambdabot> (line 1, column 1):
08:43:37 <lambdabot> unexpected end of input
08:43:37 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:43:40 <mrkgnao> try stack unpack <pkg> and edit <pkg>.cabal and see?
08:43:48 <Myrl-saki> @pl (\i _ -> (w`div`2, i `div` length xs))
08:43:48 <lambdabot> const . (,) (w `div` 2) . (`div` length xs)
08:43:55 <Myrl-saki> Well.
08:44:07 <CoolerZ> http://lpaste.net/355499
08:44:16 <Myrl-saki> @pl (\i -> (w`div`2, i `div` length xs))
08:44:16 <lambdabot> (,) (w `div` 2) . (`div` length xs)
08:44:18 <glguy> hseg: You'd put the version you want to try in your stack.yaml
08:44:26 <hpc> edit the stack.yaml file first
08:44:33 <CoolerZ> its saying item_prod and item_dot defined on line 16 are not used
08:44:54 <hpc> cabal constraints define what the package /can/ build with
08:45:02 <Gurkenglas> Myrl-saki, \n -> (\l -> map (`div` l) [0,n..n*l-1]) . length
08:45:03 <hpc> stack.yaml defines a specific build configuration
08:45:06 <hpc> within those constraints
08:45:06 <hseg> mrkgnao: glguy: Testing that
08:45:10 <CoolerZ> but they are used on lines 98 and 99 
08:45:20 <glguy> and this package passes off figuring out which versions the package can build with to you
08:45:20 <CoolerZ> and also in other places
08:47:44 <glguy> CoolerZ: Does your module have an explicit export list?
08:47:49 <mrkgnao> hpc: glguy: apologies, you're correct
08:48:00 <CoolerZ> glguy, its just that single file right now
08:48:19 <CoolerZ> theres no other files or cabal file
08:48:25 <glguy> CoolerZ: OK, then you're using the default module declaration of: module Main (main) where
08:48:34 <glguy> CoolerZ: This means that only things used by main are considered used
08:48:44 <CoolerZ> oh
08:49:11 <glguy> Or rather transitively used by main
08:50:49 <hseg> How, precisely, do I blacklist dns-2.0.10?
08:51:08 * hackage Villefort 0.1.0.3 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.3 (ChrisReuter)
08:51:20 <glguy> hseg: When you manually specify a version other than 2.0.10, 2.0.10 will be blacklisted
08:52:06 <Sh4rPEYE> Which formatter would you recommend/do you use? There are now many, and I don't know which one is considered the standart. Hindent, Stylish-Haskell, Brittany...?
08:53:21 <hpc> i personally don't use any
08:53:28 <hpc> i even :set paste in newer versions of vim
08:53:37 <Sh4rPEYE> Also, does somebody here use VSCode? I've downloaded Haskero, haskell-linter and some other small Haskell packages, but the autocompletition is still clumsy, the linter doesn't work as well as I'd like and it all seems... Weird. What are the recommended packages and settings for it to work with Haskell as nicely as possible?
08:53:42 <Liceo> ciao
08:53:45 <Liceo> !list
08:54:45 <jmcarthur> I've used hindent and stylish before, but I don't use a formatter right now. They have always produced ugly formatting, IMO.
08:54:51 <jmcarthur> Never tried brittany.
09:14:38 * hackage GPipe-GLFW 1.4.1 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.4.1 (plredmond)
09:17:19 <Ulrar> So I get a string containing a \n (two chars), is there a way to replace that by the actual newline character ?
09:18:21 <pie_> is it possible to code assertions for parsers, like the order of operations or something, to make specification bugs less likely?
09:18:27 <Ulrar> In C I'd just replace by 10, but I figure there must be something more elegant
09:18:31 <monochrom> > read "\"hello\\nhello\\n\""
09:18:33 <lambdabot>  *Exception: Prelude.read: no parse
09:18:38 <monochrom> > read "\"hello\\nhello\\n\"" :: String
09:18:40 <lambdabot>  "hello\nhello\n"
09:18:52 <monochrom> But it has other requirements.
09:19:07 <Ulrar> You mean I should just use read on my string ?
09:19:24 <glguy> Ulrar: You can use 'read' if your string syntax is exactly Haskell's
09:19:47 <Ulrar> Well it contains text coming from IRC
09:19:47 <glguy> If you have something more limited in mind you'll need to write a parser for whatever the more limited set of escapes is
09:20:13 <Ulrar> I mean, the only thing I want to support is \n, if I get more stuff out of it fine but I don't really need it
09:20:19 <Boarders> at about the 11:13 mark in this talk https://www.youtube.com/watch?v=VXl0EEd8IcU&ab_channel=YOW%21Conferences the speaker says that from a semigroup you can get a monoid by freely adjoining a unit (i.e. left adjoint to forgetful functor) which he says to do via Maybe
09:20:37 <Boarders> but an audience member loudly complains at the suggestion
09:20:45 <Boarders> does anyone know why?
09:20:50 <glguy> Ulrar: What're you making?
09:21:34 <monochrom> Text coming from IRC don't normally have backslash followed by n.
09:22:10 <glguy> I see 13 occurences of \n in #haskell in my current buffer :)
09:22:16 <glguy> Most are lambda expressions
09:23:40 <Ulrar> glguy: An IRC --> Mastodon bot
09:23:50 <Ulrar> monochrom: Well it does if someone actually types \n
09:23:52 <glguy> And what's Mastodon?
09:24:00 <Ulrar> I'm trying to figure out how to get newlines on mastodon
09:24:06 <Ulrar> glguy: Basically twitter, but open source
09:24:20 <Ulrar> I don't even use it, just making that for fun
09:24:33 <Ulrar> And I actually have users who'd like \n to work
09:25:18 <glguy> You might also be interested in #haskell-irc, then
09:26:04 <glguy> There's no standard function for replacing occurences of "\\n" with "\n", you'll just need to write one
09:27:18 <Ulrar> Well read should do it, no ?
09:27:33 <glguy> No, read will be much more picky
09:27:44 <Ulrar> Or maybe just replace "\\n" "\n" then
09:28:20 <glguy> read will expect enclosing '"'s and will expect contained '"'s to be escaped
09:28:47 <glguy> and it will expect to be other uses of '\\' in the string to be valid Haskell escapes
09:28:49 <Ulrar> Ah, yeah, won't work then
09:35:08 <Ulrar> Yep, Data.Text.replace works nicely
09:35:28 <Ulrar> A bit silly to convert from ByteString and back for that though
09:38:21 <cocreature> iirc there is some package that implements search & replacement for bytestring directly
09:38:30 <Eduard_Munteanu> I'd use attoparsec.
09:38:32 <cocreature> https://hackage.haskell.org/package/stringsearch
09:44:04 <pie_> man why is it that almost no tools have stack integration
09:45:00 <ertes> like what?
09:46:27 <monochrom> Maybe your bar of "integration" is too high.
09:47:16 <hvr> pie_: it's like asking why XY isn't available for your favorite OS
09:47:30 <pie_> :C
09:47:34 <glguy> I only run FavoriteOS
09:47:47 <pie_> why doesnt openbsd nixos :C
09:47:54 <glguy> and never seem to have as many problems with XY as everyone else
09:48:33 <pie_> why doesnt openbsd nixos qubes some_verified_compiler :C
09:48:45 * pie_ flails helplessly
09:49:04 * glguy hands pie_ some verbs
09:49:33 <monochrom> hvr! Why aren't your Ubuntu PPAs available for iOS?!  <duck>
09:49:48 <glguy> monochrom: I think you can download from hvr's PPAs with iOS
09:49:55 <hvr> monochrom: first you nede to port dpkg & debhelpers to iOS  =)
09:50:07 <hvr> monochrom: and then convince launchpad to setup iOS builders
09:50:43 <monochrom> Next time I'll try Commodore 64.
09:50:47 <glguy> hvr: Have you thought about doing anything with your multi-ghc-travis scripts for also targeting the mac build environments?
09:51:22 <hvr> glguy: I think that'd be better covered by macports or homebrew or whatever the most popular one is
09:51:23 <glguy> Also, for rare user that doesn't know about hvr's excellent scripts: https://github.com/hvr/multi-ghc-travis
09:52:02 <glguy> hvr: I don't understand how what you're saying helps building Haskell stuff on Travis.
09:52:17 <monochrom> I think there are approximately half of the mac users who hate macports and the other half who hate homebrew.
09:52:51 <monochrom> So if you have an install system that uses neither, they all like you. :)
09:53:02 <hvr> glguy: well, you'd use the macports/homebrew commands inside .travis.yml then to install ghc/cabal; but I think you were rather talking about the script generation...
09:53:14 <cocreature> monochrom: you got it the wrong way around. they all hate you in that case
09:53:22 <monochrom> hehe
09:53:40 <glguy> hvr: Yes, but your script is rather reliable. I'm looking for something of hvr quality that automatically targets those homebrew commands on travis
09:53:45 <glguy> My script is not reliable
09:59:18 <ij> ertes, morning?
10:05:17 <torstein> Anyone familiar with Intero/haskell mode in Emacs? When I press 'o' to create a new line, it's indented whether I'm in a function or not.
10:06:40 <ij> ertes, I was wondering whether you can tell me about nix+docker+stack. I haven't done enough thinking to get it set up with alpine.
10:08:39 <ertes> ij: stack is not part of the equation, and neither is alpine, so expect rather large images
10:09:06 <ij> What do you mean «not part of the equation»?
10:09:07 <ertes> something like alpine could very well be done with nixpkgs, but it would require some engineering, i think…  i don't think it has already been done
10:09:28 <ertes> ij: stack is not used…  it's a pure nix-based solution
10:10:24 <ij> Oh. That's not a problem, I guess… Does nix have like snapshots/working pkg sets?
10:10:35 <ertes> yes
10:10:42 <ij> But the images will be large…
10:11:01 <ertes> you can bring the image size down by using static linking against haskell libraries
10:11:12 <ertes> but they are still larger than alpine-based images
10:11:28 <ij> And having different build/running containers, right?
10:11:38 <ertes> what do you mean?
10:13:22 <ij> Eh, never mind — I'm ready to try out the nix-based solution(links, IRC guidance or both?). (But did you ever have any luck creating alpine-based imgs?)
10:14:15 <ertes> if you're patient i can create a small example later
10:14:19 <ertes> like in an hour or so
10:14:38 <athan> would it ever be possible to "merge" two TChans?
10:14:49 <athan> or would you just need to create a new one with their messages, forwarded
10:15:06 <ij> ertes, Sure, I've been trying to get it work the last three sundays. And I've gotten nowhere.
10:16:41 <CoolerZ> that moment when you realize theres a much simpler way and you refactor all the code you wrote for the last hour
10:17:40 <athan> maybe if I read it, then unGet it, it will be "the same"... hm...
10:17:56 <Zemyla> So I have two classes, which are analagous to Functor and Foldable:
10:18:04 <Ulrar> So I'm trying to use what's described on https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Simple.html for "Request", the example to make a POST
10:18:16 <Ulrar> But apprently `method' is not a (visible) constructor field name
10:19:06 <Zemyla> class AFunctor t where hoist :: Functor g => (forall x. f x -> g x) -> t f a -> t g a; class AFoldable t where foldApp :: Applicative g => (forall x. f x -> g x) -> t f a -> g a
10:19:19 <Zemyla> What does the Traversable analogue look like?
10:21:48 <c_wraith> Ulrar: this is why documentation that isn't machine-checked can never be trusted. :)
10:22:42 <meadowlark> can documentation ever be trusted?
10:23:01 <c_wraith> type signatures are good documentation.  They are checked.
10:23:02 <monochrom> Yes. My documentation can always be trusted. :)
10:23:04 <Sheogorath> I remember bumping into some alternative numbery class hierarchies before. Does anyone have an elegant one they could point to?
10:23:16 <Ulrar> c_wraith: So the doc is just wrong then ?
10:23:20 <Ulrar> That's nice
10:23:22 <c_wraith> Ulrar: yes
10:23:33 <c_wraith> Ulrar: to be fair, it was probably correct when it was written
10:23:35 <Ulrar> c_wraith: Any idea what the correct way to do a DELETE request is then ?
10:24:39 <lyxia> @hackage tower Sheogorath 
10:24:39 <lambdabot> http://hackage.haskell.org/package/tower Sheogorath
10:25:00 <mrkgnao> Sheogorath: well, mine is under construction :/ subhask is elegant but hasn't seen any commits in a while
10:28:06 <c_wraith> Ulrar: hmm.  Looks like the code in that example *should* be right..  
10:28:12 <c_wraith> Ulrar: that's a re-export of https://hackage.haskell.org/package/http-client-0.5.6.1/docs/Network-HTTP-Client-Internal.html#v:Request
10:28:31 <EvanR> trusted computing documentation
10:28:49 <EvanR> the vendor writes your documentation for you, for your own protection
10:29:16 <Ulrar> c_wraith: Do I need to do something specific to get method ? I'm importong Network.HTTP.Simple
10:30:41 <c_wraith> Ulrar: add an import of Network.HTTP.Conduit  It looks like the .Simple module doesn't export all the record fields for Request
10:33:49 <Ulrar> Indeed ! That works : import Network.HTTP.Conduit (Request(method))
10:33:52 <Ulrar> Thanks c_wraith 
10:40:38 <fsestini> hi! does anybody know how to specify injectivity of a type family for some (but not all) of the arguments?
10:41:43 <c_wraith> fsestini: I think you'd need to break it into pieces.  One type family to cover the injective parts, one for the rest.
10:45:26 <JelloRaptor> Does anyone have suggestions for names for a class: `Class Foo (n :: (* -> *) -> *) where; bar :: (forall v. f v -> g v) -> n f -> n g; barA :: Applicative a => (forall v. f v -> a (g v)) -> n f -> a (n g)" ? 
10:47:00 <JelloRaptor> Basically, some elements in the type are stored with some functor, and you have some morphism from that functor to another, which gives you a morphism over the larger type"
10:48:01 <JelloRaptor> So `dat (SrcLoc,) -> dat Identity` would take a dat where elements are annotated with source location and give you a dat without any annotation
10:48:41 <lyxia> FFunctor, for a functor in the category of functors?
10:50:01 <JelloRaptor> huh, `bar` is analogous to fmap? and i have no idea what barA is analogous to. 
10:50:20 <lyxia> barA looks like a traversal
10:51:08 <cocreature> JelloRaptor: maybe take a look at the functions in https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html. they’re not quite what you propose but they’re close
10:53:10 <JelloRaptor> huh that is really close, albeit a tiny bit more restrictive than I would like
10:55:34 <cocreature> JelloRaptor: you got me interested. do you have an example of what you are trying to do with your more general version?
10:55:41 <JelloRaptor> there's also a version where (with constraintKinds) I can have a constraint tied to the morphism `forall c. (forall v. c v => f v -> g v) -> n f -> n g` though I have no idea where I'd say "this datatype can use a morphism with this set of constraints, since it only contains data using that set of constraints."
10:57:04 <cocreature> bar actually seems less general than hoist. I can always add a phantom type parameter and get an instance of Hoist instead I think
10:57:34 <cocreature> barA is more general than embed but I’m not sure if Applicative is sufficient
10:57:38 <cocreature> it seems very monadic to me
10:58:08 <JelloRaptor> cocreature: In this particular case dealing with a bunch of different versions of an identical data structure "an object stored as a set of constraints over its values, the same object but with symbolic variables where the constraints are implicit in the CSP monad I'm using, and the same object but with specific concrete values as returned by the SMT solver"
10:58:58 <cocreature> JelloRaptor: I was hoping for something a bit more concrete that shows why you need it to be more general :)
11:00:30 <JelloRaptor> cocreature: I don't *need* it to be more general :P but it's a pattern that I've wished existed in a whole bunch of other places, mostly where I want to express some notion of ambiguity in an ADT.
11:00:57 <ertes> ij: working on an example now
11:02:18 <cocreature> JelloRaptor: fair enough. in any case, if you want your custom typeclasses, it’s probably a good idea to name them similarly to the ones in mmorph :)
11:02:55 <CoolerZ> is there a function for searching for an element in a list and returning that element?
11:02:56 <JelloRaptor> cocreature: there's a pretty limited set of functors I want to use in each induvidual case (`Maybe`, `(Metadata,)`, `ZipList` being pretty common) but it seems like it would save a good bit of boilerplate to have a more generic structure
11:03:27 <cocreature> :t find -- CoolerZ
11:03:29 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
11:07:56 <fsestini> c_wraith: i’m trying what you suggested on a minimal example without success. the example is here: http://lpaste.net/835057898517168128
11:08:36 <fsestini> it still cannot deduce x1 ~ A
11:08:40 <ertes> ij: you know what, i just had a fun idea…  i'm gonna make a time lapse video of my screen while developing the thing =)
11:09:18 <Profpatsch> Any takers? https://www.reddit.com/r/haskell/comments/6b2krt/can_somebody_please_document_monadbasecontrol/
11:10:17 <ij> ertes, Cool. :)
11:17:08 <CoolerZ> is there a simple way to pattern match in arbitrary places like let blocks?
11:17:36 <CoolerZ> i end up making everything into records just so i can access the fields without pattern matching
11:17:56 <glguy> CoolerZ: sure, you can use patterns with let
11:20:30 <CoolerZ> glguy, how
11:21:33 <jmcarthur> > let (a, b) = ("foo", 42) in a ++ show b   -- CoolerZ 
11:21:35 <lambdabot>  "foo42"
11:23:36 <CoolerZ> ok
11:32:25 <CoolerZ> glguy, can you pattern match and change control flow in let blocks?
11:32:34 <CoolerZ> depending on which pattern got matched
11:32:39 <bloogie> book recommendations for equational reasoning?
11:33:30 <Tuplanolla> bloogie: http://www.cis.upenn.edu/~bcpierce/sf/
11:35:52 <bloogie> Tuplanolla: thanks, although this seems to involve Coq - can you suggest something more Haskelly? Unless Haskell isn't as great for this.
11:36:19 <Tuplanolla> Nope.
11:37:25 <bloogie> what about Bird's Algebra of Programming? anyone have anything to say about that?
11:37:28 <cocreature> bloogie: “pearls of functional algorithm design” shows you how to improve the performance of Haskell algorithms using equational reasoning
11:38:09 * hackage eventful-sql-common 0.1.0, eventful-postgresql 0.1.0, eventful-memory 0.1.0, eventful-dynamodb 0.1.0, eventful-core 0.1.0, eventful-test-helpers 0.1.0, eventful-sqlite 0.1.0 (jdreaver): https://qbin.io/e0bidrx
11:38:49 <jmcarthur> CoolerZ: You can define functions using let that do that, but you can't use let like a case expression. In that case, just use case.
11:39:38 * hackage websockets-simple 0.0.6 - Simpler interface to the websockets api  https://hackage.haskell.org/package/websockets-simple-0.0.6 (athanclark)
11:43:46 <lpaste> Gurkenglas pasted “Warning: Code golf. The second times out, the first doesn't. What gives? I just defined Tree locally :I” at http://lpaste.net/355501
11:44:02 <EvanR> but you can use case like a let
11:44:41 <EvanR> case can do anything
11:46:05 <Tuplanolla> You probably want `~(N a _)` and `~(N _ a)`, Gurkenglas.
11:46:28 <Gurkenglas> Ah, makes sense.
11:46:49 <Gurkenglas> still times out
11:48:38 <Tuplanolla> It's going to be less obvious then...
11:49:08 <Tuplanolla> Does the unfolding work as intended?
11:52:01 <Gurkenglas> The new version (even without ~) works on small cases
11:53:21 <CoolerZ> this seems like it could be better http://lpaste.net/355502
11:53:38 <CoolerZ> is there a better way to right that?
11:53:58 <Gurkenglas> Actually, why would ~ be necessary? j always lazily returns an N
11:54:24 <Tuplanolla> It might not be. I didn't read it too carefully.
11:54:55 <EvanR> Gurkenglas: its cases like that where ~ is useful
11:55:14 <EvanR> since you dont need to check now that it actually is an N
11:55:41 <EvanR> the expression returning an N doesnt need to be evaluated yeet
11:56:03 <Gurkenglas> Why not evaluate it? It's going to be used anyway, and soon
11:56:27 <EvanR> i didnt look at your code, you might be right, in which case you want ! instead ;)
11:56:55 <EvanR> in other situations you *must* use ~ for any progress to be made
11:56:58 <EvanR> due to recursion
11:59:09 <Gurkenglas> The unfold looks like "j s = N (f x) $ map (j . (:s)) [0..]", what differences can ~ possibly make when folding that?
11:59:36 <EvanR> none because the pattern is just s
12:00:09 * hackage postgrest-ws 0.3.1.0 - PostgREST extension to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgrest-ws-0.3.1.0 (diogob)
12:00:35 <Gurkenglas> No, when folding. ("g [] (N a _) = a; g (x:s) (N _ a) = g s $ a !! x")
12:01:21 <EvanR> it doesnt look like any tricky recursion is going on with the N
12:01:41 <Gurkenglas> therefore ~ and ! are irrelevant, right?
12:01:58 <EvanR> ~ seems to be
12:02:26 <EvanR> whats N
12:02:31 <Gurkenglas> (By the way, how should I have done those two in order to not need a reverse to convert between arguments to f and g?)
12:02:40 <Gurkenglas> "data T a = N a [T a]"
12:06:20 <EvanR> no idea whats going on in that code
12:06:28 <ph88_> does someone know how to change process priority on stack ghci ? often it freezes my laptop
12:07:00 <EvanR> renice command?
12:07:31 <hexagoxel> ph88_: you sure you are not just running out of memory?
12:08:30 <hexagoxel> swapping makes for much nicer freezing than cpu contention ever could, in my experience.
12:09:40 <hexagoxel> (and i doubt priority has much of an effect in that case)
12:10:09 * hackage eventful-sqlite 0.1.1, eventful-sql-common 0.1.1, eventful-postgresql 0.1.1, eventful-memory 0.1.1, eventful-dynamodb 0.1.1, eventful-core 0.1.1, eventful-test-helpers 0.1.1 (jdreaver): https://qbin.io/slm0ycw
12:10:15 <[exa]> maybe forkbombs?
12:10:35 <ph88_> hexagoxel, yeah it could be that i'm running out of memory .. is there a way to limit the memory that can be used ?
12:10:48 <[exa]> ph88_: you might want to run htop in a terminal next to ghci to see how it dies
12:11:12 <EvanR> look at that beautiful hackage notification merging
12:11:14 <EvanR> ^
12:11:21 <EvanR> amazonked nomore
12:11:32 <[exa]> ph88_: anyway, ulimit -m <kilobytes>
12:11:34 <MarcelineVQ> I'd start with trying stack -j1 and see if it cuts down at all
12:12:01 <hexagoxel> ph88_: you can pass "+RTS -M1G" or some such as arg to ghci. no idea how to get that through stack.
12:13:05 <ph88_> oh ok
12:13:53 <MarcelineVQ> how are you using stack when you have the problem? are you calling it yourself or is some editor calling it for you?
12:14:21 <ph88_> self
12:15:09 <MarcelineVQ> then I'd try -j1 or --jobs=1 first
12:15:41 <hexagoxel> arguments that affect stack won't do you any good when it is the ghc(i) process eating memory.
12:16:10 <ph88_> even when i quit ghci it keeps running in the background and i have to do kill -9
12:17:35 <lpaste> Gurkenglas annotated “No title” with “CoolerZ, have some refactoring. I'd use lens and State monads.” at http://lpaste.net/355502#a355503
12:18:07 <Gurkenglas> CoolerZ, if you want, I can annotate what that code would look like using lens and state monads
12:22:07 <CoolerZ> Gurkenglas, whats the @ symbol?
12:22:22 <Myrl-saki> Is it possible to deadlock the compiler?
12:22:25 <Myrl-saki> I think I just did...
12:22:33 <Tuplanolla> Yes, Myrl-saki.
12:22:38 <Gurkenglas> CoolerZ, http://stackoverflow.com/questions/30326249/what-does-mean-in-haskell
12:22:48 <Myrl-saki> What should I do...
12:23:00 <mauke_> ^C
12:23:07 <Tuplanolla> That and get rid of your undecidable instances.
12:23:28 <Myrl-saki> I don't have UndecidableInstances in my own program.
12:23:37 <Myrl-saki> {-# LANGUAGE RankNTypes, OverloadedStrings, FlexibleContexts, GADTs, TupleSections #-}
12:26:12 <CoolerZ> Gurkenglas, won't lens and state make the code longer?
12:29:00 <CoolerZ> on line 2 is there a need for graph@ ? http://lpaste.net/355502#a355503
12:29:08 <CoolerZ> since graph is never used
12:30:56 <Gurkenglas> CoolerZ, right, it was originally passed to go and I didnt check again after eliminating go
12:32:50 <lpaste> Gurkenglas annotated “No title” with “CoolerZ, I guess there aren't many opportunities to sweeten lens in this one.” at http://lpaste.net/355502#a355504
12:33:06 <EvanR> someone explain to me the logic: why a newtype must have exactly one field and not zero ?
12:33:43 <Gurkenglas> afaik its because they're desugared out of existence, replaced by what they're wrapping
12:34:10 <EvanR> i see, they have to be based on something
12:34:27 <EvanR> they are purely a type, and not a type plus a real runtime plan
12:35:16 <Gurkenglas> They don't even add a bottom to what they wrap
12:36:15 <EvanR> if i want something like () though
12:36:30 <EvanR> (wait does that even have runtime existence)
12:36:45 <MarcelineVQ> > show ()
12:36:47 <lambdabot>  "()"
12:37:04 <EvanR> thats in the instance for Show () ...
12:37:33 <MarcelineVQ> for showing a 'value' of ()
12:37:48 <EvanR> ok so something is passed into that function
12:37:56 <hexagoxel> > show (undefined :: ())
12:37:57 <Myrl-saki> :t for
12:37:58 <lambdabot>  "*Exception: Prelude.undefined
12:37:58 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
12:38:07 <EvanR> that is funny
12:39:21 <hpc> > show (error undefined :: ())
12:39:24 <lambdabot>  "*Exception: *Exception: Prelude.undefined
12:39:36 <EvanR> this is preposterous
12:39:40 <hpc> > fix eror
12:39:42 <lambdabot>  error:
12:39:43 <lambdabot>      • Variable not in scope: eror :: a -> a
12:39:43 <lambdabot>      • Perhaps you meant ‘error’ (imported from Prelude)
12:39:43 <hpc> > fix error
12:39:45 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
12:39:51 <hexagoxel> fixed!
12:39:59 <EvanR> all the functions for () evaluate it?
12:40:17 <EvanR> to see if they crash?
12:40:22 <hexagoxel> the strict ones do..
12:40:43 <EvanR> show says "hmm... lets see if theres a (... good now checking for )" ;)
12:40:55 <hpc> i would be surprised if it's consistent, generally you don't use undefined :: () anywhere
12:41:04 <hexagoxel> > let f ~() = () in f undefined
12:41:07 <lambdabot>  ()
12:41:30 <EvanR> ah its whether they wrote () there or _
12:41:32 <EvanR> or ~()
12:46:29 * hexagoxel now wonders if it is impossible to newtype unboxed types..
12:46:57 <glguy> hexagoxel: The topic has been discussed, but it's not presently supported afaik
12:50:08 * hackage threepenny-editors 0.2.0.5 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.5 (PepeIborra)
13:00:14 <nilof> > foldr (\x y -> print x >> y) (return ()) [1,3..99]
13:00:16 <lambdabot>  <IO ()>
13:00:36 <nilof> This prints 1, 3, .. 99
13:00:41 <nilof> but this
13:00:53 <nilof> > foldr (\x y -> print x >> return () ) (return ()) [1,3..99]
13:00:56 <lambdabot>  <IO ()>
13:00:59 <nilof> just prints 1
13:01:29 <nilof> I'm confused
13:01:36 <monochrom> This is because y is unused.
13:04:30 <glguy> foldr (\x y -> print x >> return () ) (return ()) [1,3..99] ==> (\x y -> print x >> return ()) 1 (foldr (\x y -> print x >> return () ) (return ()) [3,5..99]) ==> print 1 >> return ()
13:05:31 <nilof> ah right
13:05:43 <nilof> it doesn't evaluate the second argument
13:07:17 <mekeor> i'm trying to load source code into ghci with `ghci xmonad.hs` and it fails. can i find out which package versions (of `xmonad` and `xmonad-contrib` packages) it's using?
13:07:33 <glguy> ghc-pkg list xmonad, for example
13:08:18 <mekeor> thanks
13:08:25 <glguy> ghci something.hs  doesn't load a package called something, it opens a file called something.hs, fwiw
13:09:18 <mekeor> yes, that's what i said or what i meant
13:09:24 <dmj`> nilof: in your first example you’re building up an expression, and then evaluating it (y is the ‘accumulator’ of the print expression). In your second example you’re discarding the built-up expression, printing the first number.
13:11:11 <dmj`> :t foldr (\(x :: Int) (y :: IO ()) -> undefined)
13:11:12 <lambdabot> Foldable t => IO () -> t Int -> IO ()
13:11:20 <glguy> In the case of foldr, it's less of a built-up accumulator than like in foldl
13:11:33 <glguy> the rest of the list will be completely untouched at this point
13:14:01 <dmj`> right, ‘y’ (better named ‘accum’) represents the chain of print x >> print x >> … etc.
13:16:41 <glguy> It would have evaluated to that action, but wasn't evaluated. instead it's still just a foldr...
13:18:42 <dmj`> glguy: yea, still a foldr
13:28:08 <ertes> nilof: http://ertes.eu/tutorial/foldr.html
13:37:07 <EvanR> heh... running into "the log problem"
13:37:33 <EvanR> top level TBQueue global time
13:42:16 <ckubrak> I'm getting this when I'm runninig cabal install hoogle: "hoogle-5.0.12 depends on haskell-src-exts-1.19.1 which failed to install."
13:43:06 <mekeor> ckubrak: i guess we need more logs
13:46:58 <ckubrak> mekeor: https://gist.github.com/574576443e843fcfad2cfaa008da48ea
13:47:32 <phadej> ckubrak: install happy
13:48:01 <ckubrak> ok
13:48:14 <phadej> and probably alex too
13:52:14 <ckubrak> It's installing thanks
13:55:10 <Rotaerk> is there something like OverloadedStrings but for single characters?
13:55:23 <hpc> don't think so
13:55:24 <Rotaerk> so that 'x' can be a Word8 instead of a Char
13:56:09 <hpc> ... i went to the ghc manpage to look for it and discovered i don't actually have ghc installed
13:56:12 <hpc> only stack
13:56:16 <Rotaerk> heh
13:56:44 <hpc> to the yum-mobile!
13:57:15 <hpc> "Installing  : ghc-ghc-7.10.3-51.fc25.x86_64" heh
13:57:20 <hpc> good old ghc-ghc
13:57:56 <EvanR> fix ("ghc-" ++)
13:58:44 <rightfold> > 'x' :: Int
13:58:46 <lambdabot>  error:
13:58:46 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Char’
13:58:46 <lambdabot>      • In the expression: 'x' :: Int
14:00:00 <hpc> 7.10's manpage only contains "char" in the word "discharging", so i would assume it doesn't exist
14:03:10 <rightfold> There is no IsChar constraint to discharge
14:10:38 * hackage microformats2-parser 1.0.1.7 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1.7 (myfreeweb)
14:12:04 <ertes> ij: still there?
14:12:19 <ij> ertes, Sorta, yes.
14:12:55 <ertes> video is ready…  let me see if i can upload it =)
14:13:28 <ertes> i have messed up a few parts, but it's already my second take, so i'm not gonna redo it
14:15:03 <bloogie> say I want to find the index of the first True element in a sorted list of bool, is there a way more efficient than elemIndex from Data.List?
14:15:38 <ezyang> not if it's a singly linked list 
14:15:43 <ChaiTRex> bloogie: You have to traverse the list, so probably not.
14:16:22 <bloogie> "probably"?
14:16:37 <ChaiTRex> bloogie: There might be some way that's very minimally more efficient.
14:16:44 <bloogie> ezyang: the standard Haskell [] is singly linked, right?
14:16:46 <hpc> ironically, this is one of the rare operations that's guaranteed to speed up or stay the same if the list is unsorted
14:16:47 <ChaiTRex> bloogie: For example, if you specialize it to Boolean.
14:17:13 <bloogie> hpc: speed up?
14:17:19 <bloogie> ChaiTRex: o_O
14:17:28 <bloogie> how in the world does that help?
14:17:36 <hpc> bloogie: because the first True is earlier in the list
14:17:45 <ezyang> yes 
14:17:55 <ChaiTRex> bloogie: Specializing it to Boolean?
14:17:59 <ezyang> yes, sorted list is pessimal 
14:19:19 <monochrom> Binary search takes linear time. :)
14:19:45 <hpc> does linear search take binary time? ;)
14:20:07 <monochrom> Yes! All times are binary times. :)
14:20:21 * monochrom uses base 10.
14:20:40 <ChaiTRex> Everyone uses base 10.
14:20:44 <hpc> all bases are base 10
14:20:45 <monochrom> \∩/
14:21:26 <bloogie> oh look, 10 people have now made the same joke
14:21:28 <hpc> bloogie: anyway, let this whole line of questioning be a lesson in knowing your data structures ;)
14:22:39 <hpc> as dopey as it is for every job interview ever to begin with "write quicksort and a hash table", they really are that important
14:23:05 <athan_> Which is smarter - MonadRec, or using TMVars and async threads?
14:23:25 <monochrom> What is MonadRec?
14:23:33 <athan_> er, wait
14:23:37 <athan_> MonadFix :c
14:23:38 <ezyang> recursive do? 
14:23:46 <ezyang> define "smart" 
14:23:51 <monochrom> Incomparable.
14:23:53 <athan_> gooder :v
14:24:06 <athan_> hmm, yeah I'm just thinking about this problem wrong I think
14:24:56 <athan_> basically, in a callback, I need access to a value that's returned. So, If the value is returned _before_ the callback is called, then I could stash it in a TMVar and block until it's available in my callback
14:25:55 <ij> ertes, Cool! I will take a look whenever you send it to me and when I've time.
14:25:57 <ezyang> anyone have a good example of when circular dependency is really useful 
14:26:15 <ezyang> athan_: I doubt MonadFix will work for this case 
14:26:21 <ezyang> (but I have not thought about it closely) 
14:26:21 <hpc> ezyang: nope, they're useless
14:26:49 <ezyang> let he who has never written an hs-boot file cast the first stone 
14:27:02 <hpc> he already has :D
14:27:29 <hpc> ezyang: consider modules A and B that are mutually dependent
14:27:36 <hpc> ezyang: importing A necessarily imports B
14:27:38 * hackage hexpat-lens 0.1.5 - Lenses for Hexpat.  https://hackage.haskell.org/package/hexpat-lens-0.1.5 (JosephAbrahamson)
14:27:43 <hpc> importing B necessarily imports A
14:28:16 <hpc> there's no separation of concerns, so neither A or B can really be considered modules
14:28:27 <ezyang> well, not if they're programming against interfaces 
14:29:09 <hpc> what else would you program against?
14:29:37 <ChaiTRex> hpc: Implementations.
14:29:42 <ezyang> I'm just saying that if A imports an interface of B, and B imports an interface of A, there is credible implementation hiding going on 
14:29:55 <hpc> ah, that's fair
14:30:02 <hpc> i would still hesitate to call it modularity though
14:30:27 <hpc> but maybe that's a use for mutual imports
14:31:01 <hpc> i have always approached that problem from the perspective that the interface is wrong
14:31:30 <ezyang> Yes, this is sort of why I am asking; conventional wisdom is that you can always acylicify it 
14:31:40 <ezyang> but I feel like in the real world things never end up so nice 
14:33:57 <athan> ezyang: Ahh wow okay I thought so. Have you figured out a better way to do this? Or is a TMVar probably the best bet?
14:34:22 <ezyang> athan: So, who is generating these callbacks 
14:34:39 <ezyang> the first recommendation in Haskell is to take advantage of our green threads, and use blocking calls! 
14:35:14 <ezyang> The example I am going to us is of a DB API and a logging API, where you wanted the DB to log, and the logger to log to DB 
14:38:45 <kamyar> Hello friends
14:39:34 <kamyar> I have written a project using Persistent and POstgresql
14:39:44 <kamyar> Now I want to migrate to groundhog
14:40:01 <kamyar> But I cant find a 'connection pool' sample in groundhog
14:40:13 <kamyar> for postgresql I mean
14:42:15 <hpc> ezyang: i think for that, i would factor it out by first considering that "DB" isn't an atomic concept
14:42:29 <hpc> ezyang: and that the lower layers of that concept would have logging baked in
14:42:48 <ezyang> you mean... higher levels? 
14:42:57 <hpc> then on top of some primitive db concept, you put the actual db interface which is logged
14:43:14 <hpc> and a slightly more direct interface to the low-level logging separately
14:43:23 <hpc> now you have logging and db somewhat modularized
14:43:38 * hackage Villefort 0.1.0.4 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.4 (ChrisReuter)
14:47:40 <hawara> hi guys i just wanted to thank you for helping me with my assignments last semester :-) 
14:52:00 <ertes> ij: sorry it took forever…  i didn't expect uploading to be this complicated: https://www.youtube.com/watch?v=sR9p_aQncRo
14:52:58 <ertes> ij: it's not time lapse as promised, but live speed…  feel free to speed it up
14:54:31 <bennofs1> ertes: everybody got their own little templating script :)
14:55:33 <ertes> bennofs1: mine doesn't do much more than cloning my skeleton repo and replacing a few things =)
14:58:13 <bennofs1> ertes: what's the split editor where it displays the same file twice for?
14:59:03 <ertes> bennofs1: the bottom one automatically jumps to the imports, and i can freely move around there…  when i'm done, i just "return"
14:59:29 <bennofs1> ah
14:59:33 <bennofs1> so like emacs marks?
14:59:50 <ertes> yeah, basically marks without having to memorise extra key bindings =)
15:00:16 <ertes> except one for "return", which does some extra things: sort imports and language pragmas
15:08:38 * hackage Villefort 0.1.0.5 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.5 (ChrisReuter)
15:18:15 <Lokathor> how paranoid should i be that a gl function that's supposed to return GL_TRUE or GL_FALSE might return something else?
15:19:11 <EvanR> o_O
15:19:28 <Lokathor> hey it's a fair question
15:19:32 <Tuplanolla> I'd let it crash at that point.
15:19:41 <EvanR> i would hope it would crash
15:19:47 <EvanR> which is the question
15:20:05 <Tuplanolla> I mean the C kind of crash.
15:20:15 <EvanR> if it returns a different number, it would be interprted as TRUE right
15:20:21 <EvanR> since its not FALSE
15:20:33 <EvanR> no one would ever know
15:21:02 <Lokathor> fair point
15:22:53 <ertes> Lokathor: if you have read the official docs or even the spec, you don't need to be paranoid at all
15:23:49 <Lokathor> ertes, i mean it says GL_TRUE if successful, and GL_FALSE otherwise, but the types themselves don't literally prevent another value from somehow showing up
15:23:51 <Lokathor> that's all
15:24:43 <Tuplanolla> My interpretation is that if your graphics drivers are that broken, a kernel panic would be in order.
15:24:45 <mekeor> Lokathor: maybe you could take a look at the code of the function and look up if it returns somethings else in some cases
15:24:55 <ertes> Lokathor: that's because it's a direct binding to the C API, which doesn't have the type system capabilities to support stricter return values
15:25:06 <ertes> Lokathor: C doesn't even have proper booleans
15:25:22 <ertes> that's why you need to rely on prose here
15:25:24 <Lokathor> ertes, i know that C doesn't have that, and i'm referring to the C docs that said that, not the gl docs
15:25:43 <Lokathor> mekeor, unforunately the source for opengl drivers is all closed :P
15:25:46 <Lokathor> that's the point after all
15:26:16 <ertes> Lokathor: i have found that the official OpenGL man pages are reliable…  however, don't rely on the OpenGL wiki
15:26:21 <EvanR> my open source graphics drivers are that broken and freeze the entire system after 3 minutes :(
15:26:32 * EvanR thanks Tuplanolla 
15:26:42 <Lokathor> https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glGetShaderiv.xml ertes are these ones what you mean?
15:27:21 <ertes> Lokathor: yeah
15:28:00 <ertes> Lokathor: note that there are man pages for each OpenGL version and variant…  be sure to read the ones you're actually using
15:28:13 <Lokathor> yeah i just noted that in the URL
15:28:15 <ertes> this is OpenGL 4 for instance: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTexture.xhtml
15:28:19 <Lokathor> doesn't seem to be 3.3 pages exactly..
15:28:48 <ertes> Lokathor: i have a keyword search in my browser for each variant =)
15:29:11 <ertes> when i type "gl glIsTexture" into the address bar, it takes me here: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glIsTexture.xhtml
15:30:38 <Lokathor> https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glGetShader.xhtml seems to be the same as before
15:31:09 <Lokathor> i will check for "if success == GL_TRUE" and then assume a failure otherwise, as they say
15:35:08 <Mibaz> Is FRP a fancy functional version of the observer pattern?
15:35:29 <Mibaz> or is there something more that I'm missing?
15:36:13 <ertes> Mibaz: there is more
15:36:29 <ezyang> "is React a fancy version of observer pattern" 
15:36:32 <ertes> Mibaz: FRP turns time-varying values and events into first-class pure values that you can manipulate using pure functions
15:37:39 <phadej> observer pattern < data-flow programming < frp
15:38:08 * hackage Villefort 0.1.0.6 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.6 (ChrisReuter)
15:39:44 <Mibaz> Ah, I see. So the two things aren't really comparable; FRP might use something similar to observer under the hood, I assume? 
15:39:57 <Mibaz> But the goal is more
15:42:24 <EvanR> theyre not comparable
15:42:35 <EvanR> in fact neither is very specific jargon for anything
15:44:55 <kamyar> Hello fellows
15:45:09 <mekeor> hello kamyar 
15:45:30 <kamyar> I am using groundhog
15:45:35 <kamyar> please help me fix this code
15:45:50 <kamyar> http://lpaste.net/355507
15:46:08 <kamyar> It is template Haskell and the error is not so clear
15:46:14 <kamyar> Do I need to attach it?
15:46:29 <glguy> Only attach the error if you want help with it
15:46:56 <EvanR> if and only if?
15:48:07 <kamyar> I did. plz refresh
15:48:29 <kamyar> It is just part of error! It is very long since the code is generated by TH
15:51:32 <glguy> the first line of the error suggests that this persistent package doesn't support uuids, do you know that it should?
15:53:09 * hackage crdt 0.1 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-0.1 (cblp)
15:57:13 <Lokathor> http://lpaste.net/355509 pretty cool
16:29:08 * hackage language-dockerfile 0.3.6.0 - Dockerfile linter, parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-dockerfile-0.3.6.0 (yamadapc)
17:10:04 <Rotaerk> hmm I see there exists a ContraFunctor, but no ContraApplicative or ContraAlternative
17:10:07 <Rotaerk> would such things be possible
17:11:17 <c_wraith> Rotaerk: https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Divisible.html#t:Divisible
17:11:40 <Rotaerk> ahh, thanks
17:13:05 <Rotaerk> I was just imagining what if predicates were functors, and you used <|> on them to "or" them together
17:13:19 <Rotaerk> though looks like Decidable doesn't have a <|>
17:13:33 <c_wraith> No, it kind of has to go the other direction
17:14:11 <Rotaerk> k
17:18:58 <pacak> There's also acme-cofunctor.
17:45:53 <sgronblo> Hello, could someone confirm one thing about Servant for me. While it seems to encode your types much more strongly it seems you could still easily have bugs where you accidentally swap two arguments in your handler function in the opposite order they are captured in the API type?
17:48:37 <lknows> An odd question, does haskell ever become very naturally intuitive to use? Somehow the more I learn, the more I struggle to think in a "haskell" manner. Am I getting retarded or is this par for the course or something?
17:49:53 <geekosaur> pretty much par. I think it's easier if you've been trained to think in certain mathematical ways (no, I do not mean category theory; this is more meta, a "philosophy of math" type thing)
17:52:22 <geekosaur> sgronblo: there are servant-client and servant-foreign; you *can* run servant APIs in client mode instead of server
17:52:28 <geekosaur> which is kinda "flipping the arrows"
17:53:49 <geekosaur> they could design the types to protect you from doing that when building services, but then they'd need to provide a separate "coservant" whose core is the same as servant but whose APIs are typed for the client direction
17:53:59 <geekosaur> which would be kinda ridiculously wasteful
17:58:36 <glguy> lknows: once you start building things you'll understand develop more intuition for it
18:03:15 <EvanR> lknows: learning new ways to think of old things... is fun!
18:19:12 <Lokathor> lknows, after a while you have a hard time thinking in a not-haskell way :P
18:19:50 <Lokathor> though at the moment it seems i've forgot my monad transformer basics and am struggling to chain IO (Either String a) values
18:27:16 <glguy> step one, switch to using a monad transformer
18:29:56 <Lokathor> glguy, well yeah
18:30:53 <Lokathor> i have an IO (Either String GLuint) that i need to run twice, and then use those GLuint values with a MonadIO m () dealy and some other IO stuff
18:31:05 <Lokathor> all obvious stuff
18:31:16 <Lokathor> right now there's too many other things going on around me to focus
19:05:11 <EvanR> global variables for fun and profit in haskell
19:05:29 <EvanR> dont blame me, the docs for newTChanIO, newTVarIO, etc specifically mention it
19:25:32 <orion> What exactly is "monoidal analysis", and what can you do besides count the number of layers?: https://www.stackage.org/haddock/lts-8.13/free-4.12.4/Control-Applicative-Free.html#v:runAp_
19:27:27 <glguy> orion: look in Config.Schema.Docs for an example
19:27:44 <orion> glguy: Ah, you did mention that the other day.
19:35:50 <orion> glguy: How exactly does mappend work for DocBuilder?
19:37:56 <glguy> it inherits the instance for tuples, so the elements of the tuple are combined pairwise with mappend
19:38:09 <glguy> for Map that's union
19:39:03 <orion> Oh, I see.
19:42:48 <orion> Interesting, thanks!
20:02:43 <athan> Hey all - STM alludes to "retrying" when it fails. Does that mean it busy-waits..?
20:08:06 <peddie> athan: I don't think it's a "busy-wait" in the usual sense of spinning until something becomes available.  it's transactional, so it has to re-read the TVar and try again to compute the new value and update if another thread updated it during this thread's transaction
20:10:33 <pie_> is attoparsec suitable for bit-level stuff?
20:10:56 <pie_> or is it only suitable if the primitives are bytes?
20:11:31 <peddie> @hackage binary-bits  -- pie_, I've used this package for bit-level stuff before
20:11:31 <lambdabot> http://hackage.haskell.org/package/binary-bits  -- pie_, I've used this package for bit-level stuff before
20:17:49 <pie_> peddie, the problem is i can have stuff going across byte boundaries
20:18:07 <pie_> or is that fine for this
20:18:25 <pie_> basically i might need to read 6 bits then 7 then 5 or something
20:20:02 <peddie> pie_: if I recall correctly, that's no problem at all with this package, but check the docs and see whether it looks OK?
20:20:30 <pie_> i have no idea im a noob :P but ill look
20:20:31 <peddie> I think it has a lot of operations like "read n bits into a k-bit word"
20:20:39 <peddie> so you tell it exactly what to consume
20:21:24 <pie_> oh im still not used to how th eonline help catalog works
20:21:31 <pie_> i was looking at the wrong page
20:22:35 <peddie> pie_: check out http://hackage.haskell.org/package/binary-bits-0.5/docs/Data-Binary-Bits-Get.html for example -- are you familiar with the `binary` package at all?  this package is a simple extension to that one
20:22:54 <pie_> not familiar with any of the prelude xD
20:23:03 <pie_> or stdlib or whatever
20:23:18 <peddie> pie_: that's OK, `binary` is not part of the prelude or the `base` standard library :)
20:23:20 <peddie> @hackage binary
20:23:20 <lambdabot> http://hackage.haskell.org/package/binary
20:24:01 <peddie> pie_: out of curiosity, what are you going to parse?
20:24:01 <pie_> can i use this with attoparsec
20:24:07 <peddie> pie_: no, it's separate from attoparsec
20:24:14 <pie_> peddie, http://adobe.com/www.adobe.com/content/dam/Adobe/en/devnet/swf/pdf/swf-file-format-spec.pdf xD
20:24:23 <pie_> help meeee
20:24:37 <peddie> that page is unavailable for me, but I gather you're parsing Flash files?
20:24:38 <pie_> i figured im never going to get anywhere unless i actually try
20:24:51 <pie_> never going to get anywhere with funtional languages that is
20:24:52 <pie_> yeah
20:25:16 <pie_> thats because i messed up the link https://wwwimages2.adobe.com/content/dam/Adobe/en/devnet/swf/pdf/swf-file-format-spec.pdf
20:25:38 <peddie> pie_: if you have some code you can't get working, put it on lpaste and share the link here; usually there is someone around who is willing to take a look and help
20:25:45 <pie_> it seems detailed enough to be easy to follow for someone that knows what theyre doing
20:26:08 <pie_> yeah i just didnt want to be annoying with my blatant cluelessness, but what the heck :)
20:26:08 * hackage tmapmvar 0.0.0 - A single-entity stateful Map in STM, similar to tmapchan  https://hackage.haskell.org/package/tmapmvar-0.0.0 (athanclark)
20:26:12 <pie_> ill post what i have so fa
20:27:15 <pie_> peddie, https://pastebin.com/KNJVW54U
20:27:55 <peddie> pie_: this program doesn't work?
20:28:04 <pie_> well it doesnt have enough stuff in it to do anythig
20:28:13 <pie_> im just trying to build up the types
20:28:25 <peddie> pie_: I don't totally understand why you have a bunch of fields that are `Parser <something>`.  usually I write functions that are the ways to parse data that is just `<something>`
20:28:54 <pie_> peddie, re: i have no clue what im doing. if something looks like it doesnt make sense its probably because it doesnt
20:29:37 <pie_> peddie, these are supposed to be the fields/whatever in the swf
20:30:23 <pie_> well, word8 is relatively primitive, i probablt dont need parser for that, but i need parser for multibyte stuff so i can handle endianness no?
20:32:17 <peddie> pie_: usually your data types can be defined independently of how they're parsed from the file
20:32:45 <pie_> i think im trying to specify how to parse them from the file though?
20:33:11 <peddie> you had better, but that stuff doesn't have to affect how the data is defined
20:33:13 <peddie> one sec
20:33:41 <peddie> pie_: I might start by defining the SWF integers like this: http://lpaste.net/355514
20:34:08 <pie_> also id love if theres something to decrease the verbosity when im just changing the lenght of the integer, any tricks for that?
20:34:45 <pie_> peddie, ok, how would the parsing side of that look? (just simple normal integers from bytes)
20:34:47 <peddie> how are you changing the length of the integer?  I can think of some ideas, but it might make sense to get the verbose thing working
20:35:13 <peddie> pie_: let me write an example, one sec
20:35:17 <peddie> then I have to get back to real work :)
20:35:24 <pie_> sorry i meant like, the verbosity of the source code
20:35:27 <pie_> yeah thanks xD
20:35:44 <peddie> meanwhile check out https://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary-Get.html
20:35:49 <pie_> the bit packing thing is really gonna mess with my head though
20:38:02 <pie_> peddie, looks to me like that only operates on bytes as well :I
20:38:09 <peddie> yes, true
20:38:34 <peddie> you just said "just simple normal integers from bytes" :P
20:39:25 <pie_> well google says https://wiki.haskell.org/Dealing_with_binary_data#The_BitGet_monad
20:39:37 <pie_> peddie, well yeah for the part you pasted xD
20:39:56 <pie_> (which is what you linked earlier)
20:42:38 * hackage tmapmvar 0.0.1 - A single-entity stateful Map in STM, similar to tmapchan  https://hackage.haskell.org/package/tmapmvar-0.0.1 (athanclark)
20:42:46 <pie_> peddie, for the bitjunk its basically the bottom of page 17 in the swf doc link :I
20:43:15 <EvanR> pie_: not sure about verbosity, but theres this thing, inline-c ! ;)
20:43:32 <EvanR> also some things can be made less verbose with quasi quoters
20:44:03 <pie_> EvanR, thanks ill check them out
20:44:23 <pie_> though what im talking about either amounts to dependent types or metaprogramming proooobably...
20:45:04 <EvanR> are you parsing binary?
20:45:22 <pie_> attempting to yes
20:45:23 <EvanR> theres attoparsec and Binary
20:45:27 <pie_> yeah
20:45:37 <EvanR> and Cereal
20:45:40 <pie_> mmmm
20:46:27 <peddie> pie_: maybe http://lpaste.net/355514 is a very simple example
20:46:30 <peddie> haven't tried to compile it
20:46:38 <peddie> but see if that makes some sense to you
20:47:12 <peddie> I just found some random thing in the PDF you linked
20:47:12 <pie_> peddie, this is for page 21 yeah?
20:47:18 <pie_> yeah ok ill look at it
20:47:35 <pie_> what does Binary(...) do?
20:47:59 <EvanR> import constructors for the type Binary
20:48:14 <peddie> pie_: it imports the type class name `Binary` along with all its methods (if you just wrote `Binary` without the `(...)`, it'd only import the name of the type class)
20:48:22 <pie_> ok
20:48:28 <EvanR> er, class and methods
20:48:33 <peddie> pie_: if `Binary` were a data type, it'd do what EvanR said above
20:48:49 <pie_> yeah i need to learn more haskell, the words and the structure make sense but i have no idea what the symbols do
20:49:46 <peddie> pie_: you can search for symbols on hoogle
20:49:49 <peddie> @where hoogle
20:49:49 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
20:50:17 <pie_> hm ok
20:51:10 <peddie> pie_: to parse in bit-field structures, the parser should look pretty much the same, but you can use functions like Data.Binary.Bits.Get.word16be with an argument telling it to e.g. read only 11 bits or whatever
20:51:32 <pie_> well, ok. i guess that makes sense
20:51:55 <peddie> the <$> and <*> and *> are from the Functor and Applicative type classes
20:51:59 <pie_> ah wait, does that also keep track of where it is in the input stream after reading the 11 bytes?
20:52:04 <pie_> beause that would be fine i guess
20:52:16 <pie_> also i tried but i dont see how to search for symbols yet
20:52:20 <peddie> pie_: yes, it keeps track of that kind of stuff under the hood
20:52:42 <pie_> sooo, i could do the read 7 then 4 then 6 or whatever?
20:52:54 <peddie> pie_: the symbols are just regular haskell values.  e.g. https://www.stackage.org/lts-8.13/hoogle?q=%3C*%3E&exact=on
20:52:58 <EvanR> <$> and <*> are so common and unfamiliar, probably any intro to haskell should get that overwith first
20:53:09 <pie_> huh i tried *> but it didnt work
20:53:11 <EvanR> or very soon
20:53:16 <EvanR> :t (*>)
20:53:17 <lambdabot> Applicative f => f a -> f b -> f b
20:53:30 <EvanR> :t (>>)
20:53:31 <lambdabot> Monad m => m a -> m b -> m b
20:53:52 <peddie> pie_: I agree with EvanR that if you're not familiar with some of these pretty common bits of the standard library, you might want to run through some learning materials first; it'll speed you up a lot later
20:54:04 <pie_> yeah definitely
20:54:10 <peddie> pie_: if you check out UPenn's CIS194 course materials, a running example is building a parser, which might be just the thing :)
20:54:13 <peddie> @where cis194
20:54:13 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
20:54:15 <pie_> im just tired of wanting to learn but never getting around to it :((
20:54:39 <pie_> this is what wasnt working for me xP https://www.haskell.org/hoogle/?hoogle=*%3E
20:55:09 <EvanR> you have to say
20:55:12 <peddie> pie_: not sure why, but the `haskell.org` one wants you to surround the operator in parentheses: (*>)
20:55:13 <EvanR> (*>)
20:55:26 <pie_> ah
20:55:54 <EvanR> > ord <$> "fruit"
20:55:56 <lambdabot>  [102,114,117,105,116]
20:56:03 <EvanR> > (<$>) ord "fruit"
20:56:05 <lambdabot>  [102,114,117,105,116]
20:56:13 <peddie> pie_: if you want to start just writing some code, go for it, just keep the learning materials open in a tab and see whether you're missing something basic when you have a question :)
20:56:16 <pie_> \o/ yay apply to all the things
20:56:31 <pie_> peddie, "yes i am" xD
20:56:36 <EvanR> > (<$>) ord (Just 'f')
20:56:38 <lambdabot>  Just 102
20:56:57 <EvanR> delicious
20:56:58 <pie_> ok i think i kinda get how im supposed to do things from your paste
20:57:18 <peddie> pie_: I have to run, good luck for now!  stick with it :)
20:57:21 <pie_> o/
20:57:36 <pie_> peddie, one last question xD
20:57:37 <peddie> adios
20:57:40 <peddie> go for it :)
20:57:41 <pie_> how does this relate to Parser?
20:57:53 <peddie> `Parser` is a type from the Attoparsec library
20:58:12 <peddie> the binary library has the type `Get` which roughly analogous
20:58:24 <pie_> ok so i should be using that other library then
20:58:38 <pie_> i cant mix and match can i xD
20:59:37 <pie_> ok thanks again
20:59:43 <peddie> pie_: you could write a parser with attoparsec for the same data as you can with binary.  this is one reason why it doesn't make sense to have the Parser or Get types in the data definitions for the things you want to parse.  but it would be pretty gnarly and not worth it to try to parse some pieces of the file with an attoparsec parser and others with a binary parser.
21:01:15 <EvanR> pie_: they are not made to cooperate no
21:01:33 <EvanR> but you can make a frankenstein parser if you really put your mind to it!
21:01:39 <pie_> yeah no thanks xD
21:02:00 <peddie> pie_: binary gives a fairly uniform way to read and write the same data, so it should be pretty easy to add output support for SWF stuff as well that way
21:02:07 <peddie> pie_: ok, I'm out for now, best of luck
21:02:08 <peddie> have fnu
21:02:11 <peddie> fun even
21:02:14 <pie_> o/
21:04:00 <systadmin> ola
21:07:34 <systadmin> Tryin' to make a dice roller :/
21:07:47 <EvanR> cool
21:09:36 <ReinH> excellent plan
21:10:24 <EvanR> nothing that important should be left to chance
21:21:56 <dmj`> @typ randomRIO (1,6)
21:21:58 <lambdabot> (Num a, Random a) => IO a
21:23:49 <EvanR> haha that works with Doubles
21:24:06 <EvanR> for once ;)
21:27:32 <EvanR> exceptions in IO are a given
21:27:55 <EvanR> are exceptions in STM expected? to be avoided? avoidable? 
21:31:12 <pie_> EvanR, in the case of something like this i would need to pass an argument to get somehow that specified the format of the integer yeah? i could case split on tht argument, but idk how to pass the argument
21:31:18 <pie_> forgot the link https://pastebin.com/hi1nMeEy
21:32:04 <EvanR> you want to write a parser for the SwfInt type?
21:32:23 <pie_> yeah
21:32:42 <EvanR> you would not be passing a format argument, you would be passing it binary data and you would be figuring out the format from there
21:32:48 <pie_> going off peddie"s earlier example
21:33:01 <pie_> hm
21:33:16 <EvanR> if you want to try to parse different things, you need different types, different instances of Binary
21:33:26 <pie_> youre saying it would be decided higher up and the appropriate unction would be chosen
21:33:33 <EvanR> your sum type suggests you will detect the format from the dat
21:33:35 <EvanR> data
21:34:03 <pie_> yeah i dont think you can tell where a number ends just by looking at it :/
21:34:20 <EvanR> what exactly are you trying to do, i think i missed that
21:34:52 <pie_> trying to parse SWF based on the spec https://wwwimages2.adobe.com/content/dam/Adobe/en/devnet/swf/pdf/swf-file-format-spec.pdf
21:35:16 <EvanR> which part
21:35:29 <pie_> the very beginning at the moment
21:35:33 <EvanR> this is a 243 page doc
21:35:37 <pie_> like page 14 or something
21:35:50 <pie_> it starts with defining the types and gets into the actual structure later
21:36:23 <EvanR> it seems to be yes, the format is design to let you figure out what is what from looking at bits
21:36:39 <EvanR> a parser usually doesnt need an arguments but the raw data
21:36:43 <EvanR> any*
21:37:21 <pie_> well sure i mean
21:37:37 <pie_> if you have some kind of stucture, you know what kind of fields it has
21:38:11 <EvanR> so which part are you looking at right now
21:38:12 <pie_> so i need to split this sum type into its constituents?
21:38:22 <pie_> page 14.5
21:38:46 <EvanR> 14.5
21:38:50 <EvanR> paragraph 5 ?
21:39:00 <pie_> sorry, half way through page 14 :P
21:39:07 <EvanR> not really anything here about the file format
21:39:43 <pie_> what would you like?
21:40:13 <pie_> theres a specific structure on page 54 for an example of how the basic types are used
21:40:20 <pie_> 52 sorry
21:40:26 <pie_> setbackgroundcolor
21:40:51 <EvanR> nothing. you should be able to do what youre saying without passing any params or having different top level document types
21:41:03 <EvanR> next question
21:41:12 <pie_> ok
21:49:59 <peddie> pie_: I'm not sure you need `SwfInt` for anything if the document is mostly defined in terms of things Haskell has already like `Word8` and `Int64` and so on
21:51:50 <pie_> peddie, but its not the internal representation that i have an issue with its that i need to know how much to parse..?
21:52:12 <pie_> if its int64 i need to parse 4 bytes if its int8 i need to parse 1, etc
21:52:14 <EvanR> that is the point of the format
21:52:28 <EvanR> its design to tell you what youre looking at by looking at it
21:52:34 <peddie> pie_: in the RGB example, you know you're parsing an RGB structure, so you can just `getWord8` a few times.  I didn't read enough of the document to know how the SWF format tells you what's coming up
21:52:34 <pie_> yeah
21:52:44 <pie_> but i still need to be able to call the appropriate parsing funciton...
21:52:45 <EvanR> but its your job to read the document and figure out how
21:52:59 <peddie> pie_: I didn't see any situations where you would actually have to parse a `SwfInt` from the file
21:53:09 <pie_> peddie, oh wait i see what you mean
21:53:10 <peddie> everything seems to be defined in terms of other structures
21:53:24 <EvanR> you will have many actions of type Get Whatever, you can choose which ones to call during the process using the usual monadic style
21:53:39 <EvanR> not call, but use
21:53:51 <pie_> ok, i think i see
21:54:08 <pie_> but wha tif hypothetically i did need to do this
21:54:09 <EvanR> you use a Get and check the result, then branch based on that to the next Get
21:54:17 <pie_> (whatever "this" means)
21:54:23 <pie_> EvanR, yeah makes sense
21:54:44 <EvanR> or fail because what you see makes no sense
21:55:23 <peddie> pie_: you will probably have to do something like this for arrays: maybe it says the size of the array first, then the elements follow.  so you'll have to first read the size, see if it's reasonable, then call the element-parsing function that many times.  (I don't know how arrays actually work in this format; I'm just trying to explain the general idea.)
21:55:52 <pie_> peddie, yeah definitely gonna have to do arrays
21:56:05 <pie_> ok makes sense
21:56:42 <pie_> would still be nice to have somehting in the source code for everything in the spec though IMO
21:56:55 <pie_> "its just boilerplate"?
21:57:18 <pie_> but i mean i have very little coding experience so idk
21:57:45 <peddie> I would say, for the SWF unsigned-byte type, Word8 is the corresponding thing in the source code.  you could abstract this, but I'm not sure what it would gain you
21:58:08 <glguy> Probably better to just start experimenting with parsing some small stuff before you spend to much time pondering how to parse big stuff
21:58:31 <peddie> glguy++
21:58:47 <pie_> yeah :/
22:00:24 <peddie> pie_: why :/ ?  I think the big stuff will make sense soon if you start piece-by-piece :)
22:00:48 <pie_> big is small in a lot of pieces xD
22:01:28 <pie_> id have the same basic issues with a small one though no?
22:01:35 <pie_> i mean ok its fair to say what you said
22:01:45 <pie_> in fact its right xD
22:11:08 <pie_> ok theres no native word24 type
22:11:40 <pie_> *built in
22:11:46 <EvanR> data Word24 = Word24 !Word8 !Word8 !Word8
22:12:08 <EvanR> otoh https://hackage.haskell.org/package/word24-2.0.1/docs/Data-Word-Word24.html
22:12:13 <pie_> hm
22:12:39 <EvanR> which will be more efficient
22:12:48 <pie_> is that first one really OK?
22:13:07 <glguy> Just store the value in a Word32
22:13:10 <EvanR> ok by me, though youd have to write your own small universe of instances for it
22:13:36 <pie_> glguy, oh right i can choose to parse it however i want
22:27:02 <peddie> pie_: I added an example for `CXFORM` records from page 24.  if anything there doesn't make sense, I really suggest checking out those course notes I mentioned earlier.  the assignments are largely to do with parsing and should be relevant to this.
22:27:33 <pie_> ok \o/
22:31:38 * hackage postgresql-simple 0.5.3.0 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.3.0 (LeonSmith)
22:47:38 * hackage postgresql-libpq 0.9.3.1 - low-level binding to libpq  https://hackage.haskell.org/package/postgresql-libpq-0.9.3.1 (LeonSmith)
23:06:22 <EvanR> i was looking for a newtype that swaps the role of Left and Right
23:06:41 <EvanR> return the first Right that succeeds, otherwise try the next thing
23:07:03 <EvanR> i could swap Left and Right instead... but then Left would mean success
23:07:30 <EvanR> maybe a Either a b -> Either b a is in order
23:08:12 <capisce> EvanR: what do you mean first Right that succeeds?
23:08:17 <EvanR> the first right
23:08:30 <EvanR> trying to parse a sequence of files
23:08:36 <jle`> sounds like you just want asum
23:08:37 <EvanR> the later ones are fallbacks
23:08:50 <EvanR> asum...
23:08:51 <EvanR> ok
23:09:28 <jle`> or <|> etc.
23:10:06 <EvanR> Either has no alternative instance
23:11:09 <jle`> 'Either e' does
23:11:33 <EvanR> > Right 'c' <|> Right 'c'
23:11:35 <lambdabot>  error:
23:11:35 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M146135974615...
23:11:35 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
23:11:41 <jle`> oh hey
23:11:45 <EvanR> > Right 'c' <|> Right 'c' :: Either Char Char
23:11:47 <lambdabot>  error:
23:11:47 <lambdabot>      • No instance for (Control.Monad.Trans.Error.Error Char)
23:11:47 <lambdabot>          arising from a use of ‘<|>’
23:11:57 <EvanR> well thats
23:12:36 <jle`> interestingly enough, ExceptT e Identity has an instance
23:12:37 <EvanR> and where the heck is asum
23:12:47 <MarcelineVQ> Foldable
23:12:48 <jle`> it's in Foldable i believe
23:13:21 <EvanR> not helping with Either though...
23:13:52 <jle`> yeah, i'm saying that the lack of an Alternative instance is a mistake
23:13:53 <MarcelineVQ> what about asum . map eitherToMaybe
23:14:47 <EvanR> good call
23:15:11 <EvanR> actually i need to use the error message in between tries
23:15:18 <cocreature> EvanR: I think https://hackage.haskell.org/package/errors-2.2.0/docs/Data-EitherR.html#t:EitherR is the newtype you’re looking for
23:15:35 <EvanR> haha success monad!
23:15:57 <EvanR> and it has an Alternative instance
23:16:00 <EvanR> brilliant
23:33:46 <piyush-kurur> what is the easiest way to do the following I have a type Foo in an internal module. I want to export it from the current module but not its constructors. I also want to export all the numerous helper function from the module. I can think of doing it by two imports one in which I hide Foo and another in which i have import Foo.Internal ( Foo). Is there a better way of doing this? 
23:36:51 <mrkgnao> I think you want module Module (Foo(), helper1, helper2, ...) where
23:37:23 <mrkgnao> i.e. an explicit export list in the internal module
23:38:09 <piyush-kurur> mrkgnao: if the export list is too long it is a pain to export all of them once again.
23:39:17 <piyush-kurur> mrkgnao: besides the order of the export list determines the haddock generation.
23:39:41 <mrkgnao> well, you could then do import Foo.Internal hiding Foo(..), I *think*
23:40:21 <mrkgnao> That should hide only the constructors.
23:40:50 <piyush-kurur> Is that true let me try it out.
23:41:03 <mrkgnao> no, it doesn't
23:41:29 <mrkgnao> you can explicitly only import the type, though.
23:41:36 <piyush-kurur> mrkgnao: okey, so the two step import is the only way out
23:41:39 <mrkgnao> e.g. import Data.Maybe (Maybe())
23:41:48 <mrkgnao> that hides the constructors and imports the type
23:42:08 <ongy> import Data.Maybe (Maybe) is enough
23:42:11 <piyush-kurur> it also hides the helpers and that would require a second import with out the type
23:43:03 <piyush-kurur> that is the best I could figure out. This seems to be an important pattern and it is slightly irritating to not have an easy way to do this.
23:44:14 <mrkgnao> does import Foo.Internal hiding (Tycon1, Tycon2,...) not work for you? way too many constructors, I guess?
23:44:32 <mrkgnao> You'd have to repeat that everywhere, though.
23:45:02 <piyush-kurur> mrkgnao: No particularly if the type Foo is defined as data Foo = Foo Int
23:45:28 <piyush-kurur> I mean newtype Foo = Foo Int
23:46:04 <glguy> the two mode of operation are, "I just started this module, everything is exported" and "I've been working on this module and I have an export list"
23:46:38 <glguy> so once you're ready for controlling what gets exported, omit the constructors
23:47:30 <piyush-kurur> glguy: can you clarify what you meant?
23:47:58 <piyush-kurur> I will give you the situation. I have a type newtype Angle = Angle Int64. 
23:48:33 <piyush-kurur> It is natural to have a module to capture all the angle operations and the datatypes
23:48:48 <piyush-kurur> Let us say that is Angle.Internal. 
23:49:10 <piyush-kurur> There would be other module in the package that would want to look at the internal representation so we export the Angle type.
23:49:27 <piyush-kurur> s/Angle type/Angle constructors/
23:49:48 <piyush-kurur> but we would not like to export these constructors to the outside world for type safety
23:50:37 <piyush-kurur> I would rather like to control the interface/order of haddock documentation of angle in the internal module
23:51:04 <piyush-kurur> not in the ultimate module that exposes Angle to the outside world.
23:57:00 <aussie> How can I map readMaybe over a list of Ints?
23:57:29 <ongy> aussie: what's the type of the function you want to build?
23:57:32 <aussie> Sorry, a string that is to be converted into a list of Ints
23:57:43 <aussie> readMaybe "1" :: Maybe Int works in the ghci, but I can't seem to map it over a string
23:58:00 <kadoban> aussie: What's the string formatted like? What's between the ints?
23:58:02 <aussie> Like "123" to [Just 1, Just 2, Just 3]
23:58:20 <aussie> Each int is between 0 and 9
23:58:47 <ongy> > map (readMaybe . pure) "123" -- but I'm sure there's something better
23:58:49 <lambdabot>  [Just *Exception: Prelude.read: no parse
23:59:01 <ongy> > map (readMaybe . pure) "123" :: [Int] -- but I'm sure there's something better
23:59:03 <lambdabot>  error:
23:59:03 <lambdabot>      • Couldn't match type ‘Maybe a0’ with ‘Int’
23:59:03 <lambdabot>        Expected type: [Int]
23:59:33 <kadoban> > map digitToInt "123"
23:59:35 <lambdabot>  [1,2,3]
23:59:42 <kadoban> Though it's partial, which isn't great.
