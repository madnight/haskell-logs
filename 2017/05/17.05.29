00:00:31 <p0a> Well I'd read up on them a bit but I think I'll leave it for later 
00:00:46 <p0a> because I want to solve problems and learn by doing that and use what is needed when I have to 
00:01:02 <p0a> of course I'll pick up some bad habits doing that but I don't like the dry by the book way
00:01:13 <ertes-w> p0a: no, i think your approach is fine =)
00:01:43 <p0a> thanks :) 
00:01:53 <ertes-w> learning by doing and experimentation is in fact a highly underappreciated way to learn haskell
00:02:00 <MarcelineVQ> wet books are awful
00:02:35 <ertes-w> p0a: you won't necessarily pick up bad habits, but you may run into a road block from time to time…  but when that happens, just ask here
00:03:03 <ertes-w> haskell will not allow you to develop bad habits as much as other languages do
00:03:30 <EvanR> haskell cannot allow that to happen, its for your own protection
00:03:32 <MarcelineVQ> aside fromoveruse of $
00:04:38 <thang1> I $ don't $ know $ what $ you're $ talking $ about -- TODO fiddly with some of the $ and randomly replace with . until it compiles and passes quickCheck
00:04:39 <ertes-w> it's monday…  don't make me respond to that =)
00:04:47 <MarcelineVQ> Yes it's not especially relevant sorry ignore me
00:05:07 <Cale> thang1: Usually if you can write f $ g $ h $ x then you can write f . g . h $ x
00:06:11 <Cale> I recommend this for a few reasons. One is that (.) is associative, so the latter expression behaves as if it has more subexpressions than the former
00:06:22 <ertes-w> does anyone else prefer to write (f . g . h) x?  please join the $sucks movement =)
00:06:24 <MarcelineVQ> oh no I did the thing
00:06:28 <EvanR>   w = f . g . h
00:06:35 <Cale> That is, g . h for example, is a well-typed thing on its own
00:06:35 <EvanR>   y = w x
00:06:48 <Cale> while g $ h is probably meaningless
00:07:05 <Cale> ertes-w: I don't mind *one* $
00:07:06 <thang1> Cale: nice, I'll keep that in mind
00:07:19 <thang1> ertes-w: I'm sorry, I only write lisp in lisp /s
00:07:50 <Cale> Another thing is that it's a good way to get used to writing function compositions, if you're not used to thinking that way already -- eventually in cases where you don't need the argument, it'll be more natural to think of the function composition straight away
00:08:18 <Cale> another is that $ just has the wrong damn associativity -- it should always have been left associative :P
00:08:40 <ertes-w> Cale: it's a style i adopted very recently, mainly because i can immediately see which function chains are followed by an argument…  i still use ($) when the argument is on the next line though
00:08:45 <Cale> (function application is usually left associative)
00:08:50 <EvanR> $ was really a side tangent here
00:09:10 <thang1> EvanR: never interrupt the bike shedding
00:09:17 * thang1 's favorite color is purple
00:09:35 <Cale> I just jumped in because thang1 said something indicating a bit of confusion over (.) vs. ($) :)
00:09:43 <Gurkenglas> Is there a version of Map that only requires a partial order (a -> a -> Bool)?
00:09:58 <thang1> Cale: the confusion was intentional, but I appreciate the helpful enlightenment :p
00:10:22 <ertes-w> Gurkenglas: binary searching requires a total order, as far as i can tell
00:10:26 <p0a> All this conversion between Num Integral and Int is frustrating
00:10:54 <thang1>   > mfw numeric conversion is frustrating to newbies
00:10:58 <EvanR> p0a: good idea to choose one and stick with it, only convert before and after the algorithms if necessary
00:11:00 <MarcelineVQ> hmm, what about https://hackage.haskell.org/package/unordered-containers  or is the hashing a form of total ordering? idk
00:11:00 <ertes-w> p0a: conversion only happens between types
00:11:10 <Cale> Gurkenglas: That's a *really* weak requirement. Note that (==) is a partial order.
00:11:13 <EvanR> Int or Integer (or something else)
00:11:26 <thang1> okay, EvanR, you win, I give up on my argument that numeric stuff was less confusing than string types
00:11:36 <Gurkenglas> Cale, then the map would be one deep, a degenerated forest.
00:12:13 <Cale> Gurkenglas: Ah, so you don't care about it having a terrible worst case, just making a best effort based on what the order provides. Interesting idea.
00:12:22 <p0a> for instance I have a take (fromIntegral n) [1,2..] to get an n-list. Then I want to sum it, but using sum doesn't work!
00:12:25 <ertes-w> p0a: if you feel that too much conversion is going on, paste some code, and we can help you reduce it…  in most cases conversion is not necessary or very minimal
00:12:42 <p0a> alright 
00:12:54 <ertes-w> :t \n -> sum (take (fromIntegral n) [1..])
00:12:55 <lambdabot> (Enum a, Num a, Integral a1) => a1 -> a
00:12:58 <ertes-w> p0a: works
00:13:01 <Gurkenglas> gtg but I'll read the logs later
00:13:15 <MarcelineVQ> p0a: you do a lot less of it than you'd think, it's just that beginning stuff is always about numbers for some reason :(
00:13:19 <p0a> So here's the code, http://lpaste.net/355907
00:13:40 <p0a> I'm trying to do (sum . filter') instead of just filter' but it won't work
00:13:52 <EvanR> youre trying to do everything with Integral
00:13:54 <EvanR> constraint
00:13:55 <ertes-w> ah, project euler
00:13:56 <EvanR> so use genericTake
00:14:01 <EvanR> :t genericTake
00:14:02 <lambdabot> Integral i => i -> [a] -> [a]
00:14:25 <EvanR> i would probably just use Int everywhere here
00:14:32 <p0a> okay let me try
00:14:38 <ertes-w> p0a: i suggest that you don't 'take' at all there
00:14:42 <thang1> there's a genericLength too, which is pretty neat
00:14:44 <p0a> it's just that I was inspired to use Integral from looking at :t rem 
00:14:50 <p0a> ertes-w: ?
00:15:01 <ertes-w> > filter (\x -> mod x 3 == 0 && mod x 5 == 0) [1..]
00:15:03 <lambdabot>  [15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,255,270,285,300,3...
00:15:08 <ertes-w> > filter (\x -> mod x 3 == 0 || mod x 5 == 0) [1..]
00:15:10 <lambdabot>  [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,5...
00:15:18 <p0a> ah that's pretty smart
00:15:39 <ertes-w> p0a: 'take' only the result, just before reducing the list to the answer value
00:16:24 <thang1> p0a: integral is a very generic thing. I prefer thinking of the integral constraint as defining a family of functions
00:16:35 <ertes-w> > sum (takeWhile (< 1000) (filter (\x -> mod x 3 == 0 || mod x 5 == 0) [1..]))
00:16:37 <lambdabot>  233168
00:16:48 <EvanR> Integral is specifically for doing division and remainders
00:16:58 <thang1> So (Integral a) => a -> a is the identity family of functions over all types that have an Integral instance
00:17:00 <ertes-w> p0a: 'take' is incorrect anyway =)
00:17:12 <ertes-w> you need the numbers below 1000, not the first 1000 results
00:17:39 <p0a> yeah that's a good point 
00:17:40 <ertes-w> (the way you use it is correct, but you need to adjust for offsets, if you ever start at a different value)
00:18:00 <MarcelineVQ> that's one way to give away the answer :> does someone have a good explanation for why (sum . filter') is going to be an instance related type error?
00:18:43 <thang1> :t (sum . filter)
00:18:45 <lambdabot> (Num [a], Foldable ((->) [a])) => (a -> Bool) -> [a]
00:18:51 <thang1> :t filter
00:18:52 <lambdabot> (a -> Bool) -> [a] -> [a]
00:19:04 <EvanR> Foldable ((->) [a])) ??
00:19:16 <EvanR> Num [a] ?
00:19:18 <thang1>  ¯\_(ツ)_/¯ 
00:19:55 <EvanR> FlexibleConstraints or
00:20:39 <EvanR> :t sum . filter even
00:20:40 <lambdabot> Integral c => [c] -> c
00:20:59 <p0a> ertes-w: ah takeWhile is convenient 
00:21:00 <thang1> :t (sum. filter) even
00:21:02 <lambdabot> (Num [a], Integral a, Foldable ((->) [a])) => [a]
00:21:05 <thang1> wut
00:21:14 <EvanR> different
00:21:26 <EvanR> you did sum (filter even)
00:21:39 <thang1> Well yeah, I just wasn't expecting Num [a] and Integral a
00:21:58 <EvanR> i kind of have no idea what those constraints are saying
00:22:31 <thang1> Cause to me Integral a is a stronger constraint than Num, so it should "collapse" into Integral [a]. No idea wtf the foldable ((->)) thing is for, though
00:22:40 <ertes-w> > (sum . takeWhile (< 1000)) (zipWith max ([0,3..] >>= (: replicate 2 0)) ([0,5..] >>= (: replicate 4 0)))
00:22:42 <lambdabot>  233168
00:23:02 <EvanR> Num [a] and Integral a are talking about two different types
00:23:04 <ertes-w> p0a: of course they want you to do this…  it's called sieving =)
00:23:38 <EvanR> presumably you can fill in a Num String and a Integral Char
00:23:53 <EvanR> if you had one
00:24:08 <EvanR> but neither implies the other
00:24:35 <ertes-w> p0a: explicit divisibility testing is a valid approach, too; it's just much slower =)
00:25:20 <p0a> oh wow 
00:25:57 <thang1> Don't bother understanding that, p0a, it's not exactly /super/ complicated but it's not exactly super understandable either :p
00:26:35 <ertes-w> p0a: PE problems are mostly about being smart at numerical/algorithmic stuff…  they are interesting, but not really that helpful for actual software development in haskell, because they never touch the more dirty aspects of programming like interacting with the outside world or providing sane UX
00:27:05 <EvanR> all the stuff haskell does best
00:27:07 <ertes-w> p0a: also they are rather boring on the type level
00:27:24 <ertes-w> you will mostly be dealing with integers and bit fields
00:27:42 <p0a> no I'd rather do a 2d game or somesuch 
00:28:18 <EvanR> checkout code.world/haskell
00:28:28 <ertes-w> p0a: write a small command line game first…  my favourite exercise (to give to beginners) is to write an implementation of the good old hangman game
00:28:30 <EvanR> they have graphics
00:30:59 <p0a> that hangman game is a good idea since I just realized I've no idea how to read a character from input 
00:31:16 <EvanR> :t getChar
00:31:17 <lambdabot> IO Char
00:31:57 <Lokathor> what they don't tell you about getChar is that the haskell process will not normally have any chars available until the user hits enter with their terminal
00:32:09 <Lokathor> the shell itself buffers them jealously
00:32:17 <ertes-w> p0a: use getLine instead
00:32:27 <ertes-w> if the line is empty, abort the game
00:32:31 <EvanR> thats even better
00:32:59 <ertes-w> p0a: upfront note: do not use (==) on lists
00:33:29 <Lokathor> ertes-w, assuming that they're known to be finite, why not?
00:33:36 <p0a> Hehe okay I think I need to go to bed. I really was just messing around a bit but it's getting late 
00:33:37 <ertes-w> Lokathor: because:
00:33:42 <ertes-w> :t null
00:33:43 <lambdabot> Foldable t => t a -> Bool
00:33:46 <ertes-w> :t (== [])
00:33:48 <lambdabot> Eq t => [t] -> Bool
00:34:04 <EvanR> if you are going to use the lists for something, == will probably end up forcing the whole thing
00:34:13 <p0a> Thanks for all the help every1, cu
00:34:18 <ertes-w> also (==) has the unnecessary Eq constraint
00:34:27 <EvanR> but if you just want the bool...
00:34:30 <ertes-w> p0a: good night, and have fun tomorrow =)
00:34:40 <EvanR> make sure to drop the lists so they can get gc'd
00:34:40 <p0a> will do!
00:34:41 <Lokathor> oh you mean just for == []
00:34:46 <Lokathor> sorry, missed that
00:35:53 <ertes-w> if foldr (\_ _ -> True) False line then …
00:35:54 <ertes-w> =)
00:36:16 <ertes-w> actually that's terrible
00:36:49 <ertes-w> :t getAny . foldMap (const (Any True))
00:36:50 <lambdabot> Foldable t => t b -> Bool
00:36:54 <ertes-w> much better
00:37:06 <EvanR> :t null
00:37:07 <lambdabot> Foldable t => t a -> Bool
00:37:13 <EvanR> golf'd
00:37:30 <ertes-w> is 'null' actually the same thing?
00:37:49 <Lokathor> the types are the same, they must be :3
00:38:05 <EvanR> uh
00:38:07 <ertes-w> @let data Snocs a = Nil | Snoc (Snocs a) a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
00:38:09 <lambdabot>  Defined.
00:38:10 <MarcelineVQ> null is your foldr version, with the bools the right way around
00:38:35 <ertes-w> > (getAny . foldMap (const (Any True))) (Snocs Nil ())
00:38:37 <lambdabot>  error:
00:38:38 <lambdabot>      • Data constructor not in scope: Snocs :: Snocs a0 -> () -> [b0]
00:38:38 <lambdabot>      • Perhaps you meant ‘Snoc’ (line 164)
00:38:42 <ertes-w> > (getAny . foldMap (const (Any True))) (Snoc Nil ())
00:38:44 <lambdabot>  True
00:38:49 <ertes-w> d'oh
00:39:01 <ertes-w> > (getAll . foldMap (const (All False))) (Snoc Nil ())
00:39:03 <lambdabot>  False
00:39:10 <ertes-w> > null (Snoc Nil ())
00:39:12 <lambdabot>  False
00:39:18 <ertes-w> ok, seems to be the same thing
00:39:35 <ertes-w> > foldr (\_ _ -> True) False (Snoc Nil ())
00:39:37 <lambdabot>  True
00:39:40 <ertes-w> huh?
00:39:57 <MarcelineVQ> _ _ means something is there :>
00:39:57 <ertes-w> oh, yeah, it's non-strict anyway
00:40:44 <ertes-w> > foldr (\_ _ -> True) False (fix (`Snoc` ()))
00:40:50 <lambdabot>  mueval-core: Time limit exceeded
00:40:52 <ertes-w> > null (fix (`Snoc` ()))
00:40:58 <lambdabot>  mueval-core: Time limit exceeded
00:41:11 <ertes-w> > (getAll . foldMap (const (All False))) (fix (`Snoc` ()))
00:41:13 <lambdabot>  *Exception: stack overflow
00:42:33 <ertes-w> > (getAll . getDual . foldMap (\_ -> Dual (All False))) (fix (`Snoc` ()))
00:42:35 <lambdabot>  False
00:46:00 <nilOps> Is there a total version of readFile?
00:46:36 <EvanR> total isnt the right word here, do you want a strict readFile
00:46:56 <cocreature> I think they are asking for something that doesn’t throw exceptions
00:47:02 <nilOps> Yes ^
00:47:08 <EvanR> readFile doesnt, does it
00:47:18 <nilOps> If the file does not exist it does
00:47:27 <ertes-w> nilOps: what do you want to happen instead?
00:47:42 <cocreature> nilOps: you can use "try" to catch exceptions and get an Either back
00:48:05 <nilOps> Not sure yet, just playing around
00:48:05 <EvanR> :t try readFile
00:48:06 <lambdabot> error:
00:48:07 <lambdabot>     • Couldn't match expected type ‘IO a’
00:48:07 <lambdabot>                   with actual type ‘FilePath -> IO String’
00:48:09 <cocreature> if you really want to catch all exceptions you can catch SomeException but that’s almost always not what you want
00:48:17 <cocreature> :t try . readFile
00:48:18 <lambdabot> Exception e => FilePath -> IO (Either e String)
00:48:22 <EvanR> :t try (readFile "/etc/passwd")
00:48:23 <lambdabot> Exception e => IO (Either e String)
00:48:41 <nilOps> Thanks EvanR
00:49:00 * EvanR takes cocreature's credit
00:49:15 <EvanR> cocreature++
00:49:38 <cocreature> once you’re in IO there are a million reasons for why an exception can be thrown so it’s usually better to catch the specific kind of exception that you are interested in
00:50:08 <cocreature> e.g. if someone presses ctrl+c while you are reading a file you probably don’t want to catch that exception
00:50:53 <EvanR> thats an exception?
00:51:21 <ertes-w> EvanR: yeah
00:51:31 <ertes-w> interestingly SIGTERM is not an exception by default
00:51:38 <quchen> Sure, if you have a REPL and you don’t want it to exit hard on ^C you have to catch it
00:52:09 <nilOps> Seems strange coming from languages where operations return an error code
00:52:26 <nilOps> Is it normal to let exceptions bubble up in Haskell?
00:52:29 <EvanR> just to clarify, ghc is catching SIGINT and throwing an async exception to the main thread?
00:52:38 * hackage sql-words 0.1.5.0 - SQL keywords data constructors into OverloadedString  https://hackage.haskell.org/package/sql-words-0.1.5.0 (KeiHibino)
00:52:40 <cocreature> quchen: sure there are cases when you want to catch it. what I’m saying is that catching all exceptions is often a bad idea and you should catch the ones that you can actually handle
00:53:22 <EvanR> nilOps: in most languages with exceptions this is a good idea
00:53:50 <nilOps> My language experience has mainly been with Go/C/Rust
00:53:50 <EvanR> disabling all exceptions is a good way to have your program go unresponsive
00:54:01 <cocreature> Haskell is special in that we have asynchronous exceptions meaning that other threads can throw exceptions in the current thread
00:54:09 <cocreature> so having operations return error codes doesn’t work
00:55:13 <EvanR> you do get that effect if youre waiting on a thread to complete and *it* gets an async exception, you can get that result back as an error code 
00:56:07 <EvanR> but unless youre trying to do monitoring, youd probably want to rethrow, and crash yourself then too
00:56:47 <nilOps> That mindset is going to take a while for me to get used to
00:57:21 <EvanR> file handling is a gray area, i dont know if youd call files not being there exceptional or erroneous 
00:58:13 <EvanR> youd hope the files are there as expected, so exceptions. also returns for most of the system IO would be really messy
00:59:51 <EvanR> im glad its not like C where you are constantly doing and if(ret < 0){ fprintf(stder..... .
01:01:15 <nilOps> I like how Rust handles it; I guess I'm just uncomfortable around exceptions though
01:01:51 <Itkovian> Any ideas on how to use cabal-rpm with a stack based installation of ghc? 
01:02:21 <cocreature> asynchronous exceptions are important for implementing functions like "timeout"
01:02:32 <Lokathor> :t whenM
01:02:33 <lambdabot> error:
01:02:33 <lambdabot>     • Variable not in scope: whenM
01:02:33 <lambdabot>     • Perhaps you meant ‘when’ (imported from Control.Monad.Writer)
01:03:35 <nilOps> I'll keep that in mind cocreature
01:04:24 <cocreature> nilOps: it might be worth pointing out that some people really hate exceptions even in Haskell and try to convert to some kind of Either/ExceptT type as early as possible
01:08:17 <nilOps> I'll try to get used to exception handling in Haskell before reaching for tools that are more idiomatic in other languages
01:09:01 <nilOps> Though other threads throwing exceptions is interesting; I would guess the machinery is a little more complicated than just setjmp/longjmp
01:14:21 <ertes-w> EvanR: yeah, that's how ^C is handled (by default)
01:15:07 <Lokathor> so is there some function "foo :: m Bool -> m () -> m ()" under a name that's not whenM somewhere?
01:16:29 <cocreature> EvanR: you can see the interrupt handler in runMainIO in http://hackage.haskell.org/package/base-4.9.0.0/src/GHC/TopHandler.hs
01:16:36 <halogenandtoast> This solution in Yesod seems a bit crazy: https://github.com/commercialhaskell/stack-templates/blob/master/yesod-postgres.hsfiles#L86
01:16:59 <halogenandtoast> Anyone know why a logger function not dependent on foundation could not be created?
01:17:24 <ertes-w> nilOps: example: the way you kill a thread in haskell is to throw a ThreadKilled exception at it…  if the thread never handles the exception, it just dies, but it can use the usual exception handling mechanism to do cleanup
01:18:38 * hackage liblawless 0.24.0 - Prelude based on protolude for GHC 8 and beyond.  https://hackage.haskell.org/package/liblawless-0.24.0 (misandrist)
01:19:40 <nilOps> Lokathor: Does `flip const` work?
01:20:00 <Lokathor> nilOps, uhmmm, no >_>
01:20:14 <cocreature> Lokathor: why do you want it to be not named whenM?
01:20:39 <MarcelineVQ> Lokathor: right here,  whenM p a = bool (return ()) a =<< p
01:20:53 <MarcelineVQ> now you don't need another lib
01:21:01 <Lokathor> cocreature, i looked for whenM and didn't find it
01:21:10 <cocreature> Lokathor: http://hoogle.haskell.org/?hoogle=whenm
01:21:16 <MarcelineVQ> https://hackage.haskell.org/package/extra-1.5.2/docs/Control-Monad-Extra.html#v:whenM
01:21:30 <Lokathor> aaagh!
01:21:42 <Lokathor> Control.Monad and monad-loops didn't have it
01:21:51 <Lokathor> too many monad packages
01:22:01 <cocreature> oh neat protolude has it
01:23:56 <MarcelineVQ> speaking of protolude this liblawless sounds preaty neat
01:33:31 <Lokathor> http://lpaste.net/355909 what's the one-liner form of this because using <$> directly is an error and i'm a little lost about it
01:34:03 <halogenandtoast> Lokathor: it's >>=
01:34:12 <halogenandtoast> programFromSources s1 s2 >>= either die return
01:34:57 <Lokathor> ugh, right
01:35:06 <Lokathor> i guess 230am isn't a good coding time
01:36:26 <halogenandtoast> Lokathor: I appreciate your 230am coding
01:36:36 <halogenandtoast> it's not every day I answer a question correctly on here
01:41:43 <quchen> Lokathor: do { eth <- programFromSources s1 s2; either die return eth }
01:42:54 <Lokathor> thank you quchen, for that is surely what i meant
01:43:04 <Lokathor> i was a fool for not having seen it earlier
01:51:52 <Lokathor> hackage doesn't list all of Float's typeclasses
01:51:56 <Lokathor> er, all of its instances
01:51:59 <Lokathor> how odd
01:52:07 <merijn> Lokathor: Which one doesn't it list?
01:52:43 <Lokathor> ghc says RealFrac
01:52:47 <Lokathor> but hackage doesn't have it
01:54:07 <Lokathor> ghc also lists a Fractional instance that seems to not be documented
01:56:32 <quchen> Lokathor: You’re welcome.
02:18:05 <Quickquestion> Hey, can somebody help me? When I try to define a simple Anonymous function it won't let me in GHCi, am I forgetting something? The function is: \x -> x + 1.
02:18:49 <Quickquestion> ah nvm I have to give it a name right as in q = \x -> x + 1. ?
02:21:56 <ertes-w> Quickquestion: no, you don't need to name it
02:22:01 <ertes-w> > (\x -> x + 1) 5
02:22:03 <lambdabot>  6
02:22:22 <ertes-w> Quickquestion: note that there is a shorter notation called section syntax:  (+ 1)
02:22:25 <ertes-w> > (+ 1) 5
02:22:27 <lambdabot>  6
02:23:46 <Quickquestion> how does section syntax work if I wanted ^2 would I write (^2) and then the variable?
02:24:04 <ertes-w> Quickquestion: (^2) = \x -> x^2
02:24:08 <ertes-w> > (^2) 5
02:24:10 <lambdabot>  25
02:24:14 <ertes-w> > map (^2) [1..]
02:24:16 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
02:24:41 <Quickquestion> ah thanks, didn't now about that
02:24:51 <ertes-w> Quickquestion: section syntax also works for the other argument
02:24:59 <ertes-w> > map (2^) [1..]
02:25:01 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
02:25:01 <Quickquestion> does it also work with to inputs like? x  and y?
02:25:08 <Quickquestion> if I wanted to add them
02:25:20 <ertes-w> sure, but that's not section syntax
02:25:23 <ertes-w> > (+) 3 5
02:25:26 <lambdabot>  8
02:25:34 <ertes-w> it's just the way you write infix functions in prefix form
02:25:47 <Quickquestion> what exactly is section syntax then? Anywhere I can read about it?
02:26:06 <Quickquestion> if I google it I don't find it anything specific
02:26:17 <ertes-w> Quickquestion: it's just a short-hand notation for fixing one argument of a binary function
02:26:32 <ertes-w> (# y) = \x -> x # y
02:26:41 <ertes-w> for all functions (#) and all values y
02:26:56 <ertes-w> similarly:  (y #) = \x -> y # x
02:37:13 <quickquestionlag> did I miss something, Internet is lagging
02:59:56 <reactormonk[m]> Is there a way to use reserved keywords as field names?
03:02:36 <MasseR> reactormonk[m]: prefix or suffix with something else
03:02:46 <MasseR> _class and _type are used on some libraries
03:04:19 <reactormonk[m]> MasseR: kk, sad :-/
03:16:20 <quchen> Quick interlude for the experienced Haskeller, GHC deviates from the Report in its desugaring of sections, https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
03:16:39 <quchen> In other words, (a +) is not the same as \x -> a + x.
03:44:23 <fendor> hey, i want to use HTF for testing, and it does not like to compare Either types... assertEquals (Right 8) (Right 8) does not work
03:46:22 <fendor> similar to quickcheck, prop_wahtever x = x == x does also not compile if the signature is (Arbitrary b, Arbitrary a, Eq b, Eq a) => Either b a -> Bool
03:47:41 <quchen> fendor: I like this trick, prop_whatever x = let _ = x :: Int in x == x
03:48:23 <fendor> srsly?
03:49:30 <fendor> however, does not fix the problem :(
03:50:40 * hackage diagrams-lib 1.4.1 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.4.1 (BrentYorgey)
03:55:09 <fendor> quchen, the error for the first question was, that he could not infer the Either, since tehre was no left value
03:56:17 <fendor> same for quickcheck
03:56:26 <fendor> so, Either b a is just too generic
03:56:32 <fendor> makes sense actually
03:58:49 <magthe> a possibly silly question, do I need to tell GHC 8 to use concurrency (via -threaded) or is it the default nowadays?
03:59:02 <merijn> magthe: You need -threaded, yes
03:59:11 <merijn> magthe: Note, that it's only required for executables
03:59:23 <magthe> you don't happen to know if stack adds it by default?
03:59:37 <merijn> I don't use stack, so no :)
03:59:43 <ertes-w> quchen: i kinda expected that to be standard behaviour
03:59:45 <merijn> I'm not even sure that'd be a good idea
04:00:00 <quchen> ertes-w: ..?
04:00:01 <magthe> can I see on an executable was compiled with -threaded?
04:00:13 <merijn> magthe: Inside the executable or externally?
04:00:23 <quchen> ertes-w: I think it’s the other way round with (+ a).
04:00:32 <ertes-w> quchen: yeah
04:00:36 <magthe> merijn: externally, like ldd, RTS or something
04:00:56 <merijn> magthe: I think ldd should be able to see it
04:01:14 <merijn> magthe: because -threaded simply links against a different RTS
04:01:44 <merijn> magthe: You can still use forkIO and co in the single threaded runtime, btw
04:02:20 <merijn> magthe: If you wanna check inside your code, there's Control.Concurrent.rtsSupportsBoundThreads :: Bool which is True when linked with the threaded RTS and False if not
04:02:30 <magthe> merijn: ok, thanks
04:04:39 <magthe> merijn: since I'm using sockets in my app I do believe I have something to gain by using -threaded (at least if I understand the docs in Control.Concurrent correctly)
04:05:10 <merijn> magthe: It depends on whether your sockets are busy enough to keep the CPU busy :)
04:05:50 <fendor> does someone now, if i can integrate coverage reports into travis?
04:05:59 <merijn> magthe: If you perform blocking IO (on, say, sockets) in the single threaded runtime your thread will get suspended and another one will run until the socket actually has data
04:06:06 <fendor> and or show docs?
04:06:57 <merijn> magthe: So, if your application is just copying data around from one socket to the other, you won't gain much. If you actually have enough socket IO that it's busy with that fulltime, then using the threaded runtime can improve things (since you can then have threads computing stuff while others handle sockets)
04:08:05 <LiaoTao> What kind of problems does -threaded introduce?
04:08:40 <merijn> LiaoTao: It does't introduce problems, but some operations are much slower due to the need to synchronise
04:08:53 <LiaoTao> Okay
04:09:15 <magthe> merijn: I was under the impression that the socket IO functions were blocking, and that I'd need -threaded to make foreign calls not block
04:09:37 <merijn> LiaoTao: I did a bunch of benchmarks to measure what synchronisation primitive to use, compare the following measurements for threaded and non-threaded runtime
04:09:42 <merijn> LiaoTao: http://files.inconsistent.nl/sync.txt
04:09:49 <merijn> LiaoTao: http://files.inconsistent.nl/sync-threaded.txt
04:10:07 <merijn> magthe: By default foreign calls don't block
04:10:34 <magthe> merijn: ah, OK
04:10:38 <merijn> magthe: GHC already handles running foreign calls in a different thread, even in the single-threaded runtime :)
04:10:41 <LiaoTao> merijn: I don't quite understand what it's supposed to measure
04:10:45 <LiaoTao> Pearls before swine :)
04:11:07 <LiaoTao> I only got the gist of it before: TMVar
04:11:08 <merijn> LiaoTao: 1 thread waiting for N threads to signal they're done using different primitives
04:11:08 <LiaoTao> sucks
04:11:27 <magthe> merijn: useful, but sligthly confusing naming then... I suppose all (standard) IO functions are non-blocking, unless otherwise specified then
04:12:12 <merijn> LiaoTao: So "100 threads/Async" spawns 100 threads, blocks all of them. Then times how long it takes to go from signallig "go!" to "all threads signalled they finished"
04:12:28 <LiaoTao> Right, right
04:12:49 <LiaoTao> You said something abound the thundering herd problem, I recall
04:13:06 <merijn> magthe: Where, there's 2 different notions of blocking here: 1) blocking control flow (i.e. "won't proceed to the next operation until the previous has finished) and 2) blocking a thread (i.e. nothing can run on that thread until the call finishes)
04:13:55 <merijn> magthe: GHC runs N capabilities (== threads executing haskell code) and the unthreaded runtime basically has "N == 1" (only 1 threads runs Haskell at a time), think Python GIL
04:14:59 <merijn> magthe: So if you do a foreign call in a capability, that would mean you now have "N-1" capabilities until the foreign call completes. That'd be annoying. So by default GHC does a "non-blocking" foreign call "i.e. perform the call from some other thread and block the haskell thread until the call is done". This leaves the capability free to run other haskell stuff
04:15:04 <merijn> LiaoTao: Yeah
04:16:11 <ertes-w> LiaoTao: i don't think i've ever used the single-threaded run-time in the last 5 years
04:16:22 <ertes-w> it's a safe default
04:16:32 <ertes-w> but unfortuantely it's not GHC's actual default
04:16:41 <merijn> magthe: A blocking foreign call means "the capability directly calls the foreign code and is unable to run Haskell code until the foreign call completes", whereas non-blocking foreign calls mean "the thread is suspended (i.e. control flow doesn't continue and it's "blocked" until the foreign call completes), BUT other Haskell can still run on that capability
04:16:51 <merijn> ertes-w: Well, my benchmarks indicate there's a HUGE gap for some operations
04:17:00 <LiaoTao> I seem to remember having read something about Haskell making threading easier ;)
04:17:19 <merijn> ertes-w: Like, MVar operations are two orders of magnitude slower :)
04:17:20 <LiaoTao> Didn't quite understand where it fit in when everything was still running on a single thread
04:17:47 <LiaoTao> But that's another issue, isn't it? The runtime and the actual code, I ean.
04:17:49 <LiaoTao> mean*
04:17:56 <merijn> LiaoTao: It makes things easier by decoupling "logical thread/control flow" from "actual execution"
04:18:20 <merijn> LiaoTao: In C threads are "heavy", so you can't have, e.g. "one thread per client", so you have to write complex hacks to share N clients across M threads
04:19:03 <merijn> LiaoTao: Haskell threads (i.e. forkIO) is lightweight, you can easily have 100k threads on like a regular desktop and the runtime takes care of multiplexing those 100k threads across N OS threads without you thinking about it
04:19:24 <merijn> LiaoTao: So you can write simple blocking control flow for each client, and let the runtimes sort out the thread scheduling mess
04:19:26 <ertes-w> LiaoTao: concurrency is an abstraction…  it doesn't mean that things necessarily run in parallel
04:19:28 <LiaoTao> So, it's basically implementing some sort of reactor pattern architecture?
04:19:57 <merijn> LiaoTao: The runtime is just doing a regular epoll/kqueue/whatever async loop in the end, yes
04:20:20 <LiaoTao> Oh well, that seems pretty nice
04:20:33 <LiaoTao> I always end up using boost::asio for threading in C++ anyway
04:20:37 <ertes-w> LiaoTao: it lets you handle things that are concurrent (like network connections) as separate control flows ("threads") and gives you the tools to support communication between those threads
04:20:42 <merijn> LiaoTao: Right, you end up getting the nice "reactor loop" without actually having to write it yourself :)
04:21:05 <merijn> Because writing reactor loops is ugly messy business
04:21:11 <LiaoTao> Mmm
04:21:22 <LiaoTao> Especially with mutable data and unclear ownership
04:21:38 <LiaoTao> (On top of the reactor, I mean)
04:21:42 <merijn> LiaoTao: The other thing is very limited mutable state, makes it harder to accidentally introduce data races/etc.
04:22:38 <LiaoTao> I used to think it meant that the compiler would automatically generate something akin to parallel_for because of the limited mutability
04:23:01 <ertes-w> LiaoTao: you can't have haskell's kind of concurrency in C++…  imagine that 100 clients connect, and you have 4 OS threads running (perhaps because you have 4 CPU cores)…  now imagine that 20 clients that were running on thread 1 disconnect at the same time…  GHC's RTS will migrate the clients so that you got 20 running on each
04:23:20 <ertes-w> LiaoTao: this is incredibly difficult to program with explicit OS threading
04:23:25 <LiaoTao> ertes-w: Oh, definitely
04:24:48 <merijn> LiaoTao: There's some work for auto parallelisation for "strategies" too, but honestly explicit is better
04:25:03 <LiaoTao> Probably, yes
04:25:36 <LiaoTao> Solving "stupidly parallel" problems automatically is still a valid improvement! *hint hint*
04:25:41 <merijn> I tend to just fork N workers and create a Chan where everyone reads from
04:29:21 <ertes-w> merijn: even for pure computations?
04:30:09 <merijn> ertes-w: I don't often have significant pure computation in the code I write
04:31:03 <ertes-w> ah…  but yeah, i use the worker pattern a lot, too
04:31:07 <ertes-w> usually with STM
04:32:04 <ertes-w> merijn: regarding run-times:  i think -threaded should be the default, and the single-threaded run-time should be optional for the cases when the extra overhead is really a bottleneck…  personally i've never needed it
04:32:39 <merijn> ertes-w: I'm working on a better Chan type for that kinda worker pattern
04:32:44 <merijn> Since Chan isn't closable
04:33:56 <ertes-w> merijn: you need Chan?  i.e. dupable?
04:37:07 <merijn> ertes-w: Dupable isn't necessary for that, no. Why?
04:38:20 <ertes-w> merijn: because TQueue is more efficient in exchange for not being dupable
04:38:44 <ertes-w> and TMVar . Seq would be a variant that can be closed
04:38:49 <merijn> TQuee is more efficient in a very specific set of conditions
04:39:02 <merijn> ertes-w: Actually, my benchmarks show that TMVar is utter shite :)
04:40:25 <piyush-kurur> is there any reason why bytestring (and list module) does not expose and exact version of unfoldrN. By exact version I mean it always generates the bytestring of the given length
04:41:10 <piyush-kurur> ofcourse the unfolding fucntion should have type acc -> (Word8, acc) instead of acc -> Maybe (Word8, acc)
04:41:46 <merijn> ertes-w: TQueue performs terrible under contention (as expected, tbh)
04:43:21 <merijn> Although it depends a lot on threaded vs unthreaded and exact contention pattern
04:44:06 <merijn> ertes-w: Although I haven't had time to really dive into the benchmarks and write things up
04:44:33 <merijn> I need some criterion tooling first, but don't have time right now. Hoping to sucker someone else into writing it for me :p
04:46:21 <merijn> So far no luck :p
04:52:01 <ertes-w> hehe
04:56:22 <lambdamu> How significant is the overhead of Integer vs. Int for less then 32 (or 30 if that makes a difference) bit values?
04:57:12 <merijn> hvr: As official Hackage bounds advocate and cabal expert, I have some questions for you: What kinda bounds should I put on stm? Seems it ships with GHC, so just specifying bounds on base should do, no?
04:57:18 <merijn> lambdamu: Small
04:57:38 * hackage http-client 0.5.7.0 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.7.0 (MichaelSnoyman)
04:57:50 <merijn> lambdamu: Well, depends on how many you have...but I wouldn't worry about it until profiling says it's a problem
04:58:54 <merijn> Is it even possible to install a newer STM?
04:59:02 <lambdamu> merijn: So does it makes sense to convert everything to Integer at the input boundaries and work with that internally? I'm kinda sick of using specific C*, Word* and Int* types and call fromIntegral all the time
04:59:19 <lambdamu> Is that something people do?
04:59:29 <merijn> lambdamu: It's not unreasonable, no
05:03:31 <maybefbi> can a :: i -> ComduitM i o m a be designed so that it will yield the argument i before all other i, and without using (MonadState m) => i -> ComduitM i o m a as a type constraint?
05:04:08 <maybefbi> *ConduitM
05:04:12 <maybefbi> damn typos
05:04:46 <cocreature> maybefbi: should that be "ConduitM i i m a"? I’m not sure how that’s supposed to work with different input and output types
05:05:13 <maybefbi> oops yeah you are right
05:05:50 <maybefbi> so restated it becomes can a :: i -> ConduitM i i m a be designed so that it will yield the argument i before all other i, and without using :: (MonadState m) => i -> ConduitM i i m a as a type constraint?
05:06:49 <cocreature> sure, just use >> to compose yield i and some "cat"-like conduit (not sure if that already exists or if you need to build it yourself)
05:08:11 <maybefbi> will >> do the trick even as a transformer, and not as a producer?
05:08:39 <cocreature> those are the same type. Producer is just a type synonym
05:08:42 <cocreature> so yes
05:09:34 <maybefbi> my understanding was that transformers will be "called" many times by the downstream conduits, so it will keep yielding the argument i
05:09:38 <maybefbi> anyways let me check
05:10:20 <cocreature> what exactly are you referring to by "transformer"? I can’t find a type or type synonym by that name in conduit
05:10:56 <maybefbi> cocreature, i mean this https://www.stackage.org/haddock/lts-8.15/conduit-combinators-1.1.1/Data-Conduit-Combinators.html#g:11
05:13:54 <magthe> merijn: as I said, confusing ;)
05:14:40 <merijn> magthe: The problem of mixing terminology from different levels :)
05:15:27 <magthe> merijn: indeed, but that what one gets with code solving complex problems
05:18:08 <magthe> merijn: I just have to try to sort it all out in my head some time
05:22:30 <_sras_> Is there any cases where enabling Arrows extension can create a parse error in existing previously error free code?
05:23:48 <Boomerang> Maybe if you defined your own custom (-<) operator.
05:24:01 <ertes-w> _sras_: if you used 'proc' as an identifier
05:28:30 <_sras_> ertes-w: I am getting parse errors where and identifeer naemd "rec"  is present...
05:29:00 <ertes-w> _sras_: ah, i don't know if this is a bug or not, but Arrows also brings in RecursiveDo with its 'rec' keyword
05:29:11 <ertes-w> it has done that since like forever
05:30:03 <_sras_> ertes-w: Yes. 
05:31:33 <merijn> hmmm
05:33:14 <merijn> Two dependency questions: 1) Should I put a bound on STM or does that not make sense?, 2) if benchmarks/tests/executables depend on my library, can I leave out bounds since they'll be transitively enforced by the library?
05:34:09 <lyxia> yes and yes
05:34:27 <_sras_> ertes-w: aren't arrow notations not supported by template haskell QuasiQuoter?
05:34:48 <merijn> lyxia: What bounds should I enforce on STM? AFAIK it ships with GHC and I already have bounds on base?
05:36:08 <cocreature> merijn: if in doubt just add pvp-style bounds like you do for anything else?
05:37:03 <merijn> cocreature: I have no clue how to add sane PVP bounds either :p
05:37:29 <cocreature> merijn: given that 2.4 is the latest version >= 2.4 && < 2.5 seems pretty safe
05:43:39 <merijn> Time to see if I broke anything...
05:57:27 <dihuteno> what's the right way to test that my parser combinators are handling all my edge cases?
05:58:03 <[exa]> fuzzing!
05:58:04 <dihuteno> I feel like if I try to generate arbitrary strings I'd just make the same mistakes when generating that I made when trying to parse
05:58:05 <ventonegro> test the edge cases?
05:58:05 * [exa] hides
05:59:05 <dihuteno> is just manually writing out a lot of test cases frowned upon in the haskell community?
06:00:07 <ertes-w> dihuteno: if you can generate them, you should
06:00:18 <merijn> Testing parsers is hard
06:00:34 <dihuteno> ertes-w: even if the rules to generate them are suspiciously similar to the rules to parse them?
06:00:46 <lyxia> merijn: It ships with GHC but it's quite possible to still use a different version
06:00:48 <dihuteno> I just don't trust myself to not make the same mistakes twice
06:01:32 <mfukar> dihuteno coverage-based fuzzers require no such knowledge
06:02:53 <lyxia> dihuteno: unit tests are still a good idea in Haskell
06:03:37 <ertes-w> dihuteno: think of a special case, then write a generic fuzzer that is capable of generating it
06:03:50 <ertes-w> then it's morally ok, if the generator looks very similar to the parser
06:04:00 <ertes-w> i mean it's not surprising that it does =)
06:10:48 <merijn> bleh
06:11:02 <merijn> Any advice on how to avoid defaulting warnings when using ^?
06:11:16 <merijn> Am I stuck annotating the right hand every time?
06:11:47 <cocreature> merijn: huh? I guess you are not referring to the lens operator "^?"?
06:11:51 <cocreature> oh now the question parsed
06:11:53 <cocreature> nvm
06:12:01 <merijn> No, like
06:12:03 <merijn> > 10^4
06:12:06 <lambdabot>  10000
06:12:29 <merijn> I was using 1e4 with -XNumDecimals, but that breaks my benchmarks on old GHC, since those don't have NumDecimals yet
06:13:18 <merijn> I guess I could shadow Prelude.^ but that's also not ideal...
06:16:58 <_sras_> ertes-w: Can't template haskell quotes handle arrow expression? I am getting an error that says "Expression form not (yet) handled by template haskell" ?
06:18:31 <cocreature> merijn: custom prelude ftw :)
06:18:42 * ertes-w has little TH/QQ experience
06:19:31 <merijn> cocreature: Like I said, NumDecimals works, but that's giving me issues with old GHCs. Custom prelude isn't a very good solution to benchmarks in a package with a minimal dependency footprint
06:19:35 <merijn> Relatedly
06:19:43 <merijn> How do I figure out in which GHC a flag was added?
06:19:45 <cocreature> merijn: sry I was mostly trolling :)
06:19:57 <merijn> -Wno-orphans appears to exist in GHC8.0, but not in 7.10?
06:20:08 <cocreature> although my life has become a lot better since I’ve started using custom preludes
06:20:14 * hackage hsdev 0.2.4.0 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.2.4.0 (AlexandrRuchkin)
06:26:15 <glguy> merijn: the -W flags like that are all new
06:26:57 <merijn> glguy: hmmm, so what do I use for older GHCs?
06:27:43 <glguy> merijn: it'll start with -f , I recommend using ghc --show-options | grep orphan
06:27:47 <cocreature> merijn: -fno-warn-orphans?
06:29:11 <merijn> oh, right
06:31:36 <Neeeewbie> Hello, when I try to use the isLower, toLower or simmiliar functions it won't work, do I have to load a module first?
06:32:18 <Neeeewbie> for example isLower 'a' returns me that my variable is not in scope
06:32:25 <cocreature> Neeeewbie: you need to import the module Data.Char
06:32:53 <Neeeewbie> how do I import that module? :load doesn't work
06:33:16 <Akii> :m +Data.Char
06:33:26 <Akii> (in GHCI)
06:33:28 <quchen> Neeeewbie: :module +Data.Char  adds the Data.Char module.
06:33:42 <quchen> Neeeewbie: »import Data.Char« does the same, this one works like in normal Haskell.
06:33:56 <quchen> You can also remove selected modules, :module -Data.Char, for example.
06:34:01 <Neeeewbie> aaah ok :m stands for module I assume and  +Data.Char specifys which module.
06:34:03 <quchen> :m is a shorthand for :module.
06:34:09 <Neeeewbie> Is it possible to add several modules?
06:34:18 <quchen> :m Data.Char loads only Data.Char, and drops all other modules.
06:34:28 <quchen> :m +Data.Char +Data.Ord -- Loads Char and Ord.
06:34:45 <quchen> :l (:load) loads files, :m loads installed modules.
06:35:04 <Neeeewbie> aaaah
06:35:13 <Neeeewbie> that makes sense
06:35:34 <quchen> We usually :l our own code, and :m other modules.
06:36:12 <ertes-w> Neeeewbie: also in the error message pay attention to *which* variable is not defined =)
06:36:40 <Neeeewbie> are modules code aswell( I know they technically are), or would they better be described as something else? Like additionional functions?
06:36:58 <Neeeewbie> will do! Thanks :)
06:38:04 <ertes-w> Neeeewbie: modules are name-spaces for top-level definitions
06:38:25 <ertes-w> by importing a module you can refer to things defined in that name-space
06:40:04 <ertes-w> the full(y qualified) name of 'toLower' is Data.Char.toLower
06:41:32 <Neeeewbie> ah so I can use the function without loading the module if I write it's full name
06:41:34 <quchen> Modules are pretty much »big ›where‹ blocks«.
06:42:49 <maybefbi> any chance a Data.Conduit.ConduitM can sort without using too much memory?
06:43:20 <c_wraith> sorting would seem to require holding an arbitrary amount of data in memory
06:44:06 <maybefbi> yes :(
06:45:25 <maybefbi> im thinking of having a "min heap" inside a conduit's monad, and then yielding the lowest key
06:45:47 <maybefbi> but i dont have theoretical guarantees on the size of the heap
06:46:26 <c_wraith> You can't, unless you restrict the problem further.
06:46:41 <c_wraith> Like, if you're dealing with streaming logs that might be slightly out of order, you can use a windowed sort
06:47:03 * maybefbi googles windowed sort
06:49:04 <ertes-w> maybefbi: you can sort without having everything in main memory by using disk-backed merge-sort
06:49:04 <maybefbi> ok it seems like the order is only true within the window. im trying to sort links by a score for each of them which is known by the time the sort conduit is reached in the flow
06:49:31 <hvr> merijn: stm is released independently from GHC; it doesn't come w/ GHC
06:49:31 <maybefbi> ertes-w, disk backed merge sort. not sure how to implement that. let me check
06:49:36 <ertes-w> maybefbi: sort blocks of a fixed length, write them somewhere, then at the end merge them all together
06:50:28 <ertes-w> maybefbi: merging sorted sequences only requires O(k) memory, where k is the number of blocks
06:50:51 <maybefbi> ok
06:51:13 <ertes-w> maybefbi: but you can merge pairwise, then you only ever need O(1) memory while merging
06:51:37 <maybefbi> wow
06:51:42 <quchen> You can merge k-wise, then you only ever need O(1) while merging as well ;-)
06:51:51 <quchen> For fixed k, that is.
06:53:10 <ertes-w> "17314982" -sort-> "17", "13", "49", "28" -merge-> "1137", "2489" -merge-> "11234789"
06:53:53 <maybefbi> i guess i will have to use :: (Serialize i, MonadIO m, Monad m) => ConduitM i i m () for this.
06:53:56 <merijn> hvr: Yeah, I ended up putting a bound on it since the latest version just runs with every GHC I want anyway :)
06:56:24 <maybefbi> seems like popping values out of a min heap is easier to implement although less safe, but then i will have to use MonadState m to store the heap
06:56:36 <maybefbi> inside the conduit
06:57:50 <_sras_> Is there any way to generate code that uses Arrows using template haskell?
06:58:39 <_sras_> I am getting error the error that says 'Expression form not (yet) handled by Template Haskell'..for code that uses the proc() notation
07:00:14 <lyxia> just use regular Arrow functions
07:03:56 <_sras_> lyxia: didn't get you. 
07:04:38 <merijn> _sras_: proc notation is just syntactic sugar for existing arrow functions, afaik
07:04:53 <merijn> _sras_: So even if it doesn't support proc notation you can use the functions directly
07:09:14 <_sras_> merijn: I have no idea how proc notation is desugared....
07:23:18 <tabaqui> I'm not sure, but it looks like a bug in haskell-tls
07:23:21 <tabaqui> *hs-tls
07:23:28 <tabaqui> with hostname resolution
07:23:46 <tabaqui> it skips a check if domain name cannot be resolved
07:24:04 <merijn> Well, let's see whether my 6th commit will actually fix all the old GHC issues I had >.>
07:25:13 <cocreature> merijn: I predict that in your 7th commit you’ll drop support for old GHCs
07:26:50 <merijn> cocreature: Naah, it's not hard to fix, it's just that I don't have a 7.4 locally, so I get stupid shit like: Forgot to import Control.Applicative, missing ghc-prim dependency because base doesn't reexport GHC.Generics yet, etc.
07:28:04 <cocreature> merijn: huh, 7.4. I already feel like I’m doing a good job supporting old GHCs when I’m supporting the last 3 versions :)
07:28:15 <merijn> cocreature: It's actually fairly trivial to support old GHC, since I literally have only 2 dependencies for my actual code (base and transformers, and since GHC 8 it's only base). It's my benchmarks that have more dependencies :p
07:29:26 <merijn> 8th commit, because I managed to mess up < and <= :p
07:30:48 <cocreature> merijn: I once managed to get a PR into protolude that changed sum and product to be strict but I managed to screw up the implementation of product and it actually calculated the sum :)
07:30:59 <cocreature> so messing up < and <= seems pretty harmless compared to that :)
07:32:30 <merijn> cocreature: Well, especially since it just means it doesn't build with 7.4 rather than being actually wrong
07:36:36 <jonas_> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
07:36:36 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
07:37:07 <jonas_> @undo do x [1,2,3,4]; "curry"
07:37:07 <lambdabot> x [1, 2, 3, 4] >> "curry"
07:38:09 <halogenandtoast> what is @undo?
07:38:20 <halogenandtoast> desugaring?
07:38:31 <Rotaerk> looks like
07:39:04 <jonas_> yea
07:39:33 <halogenandtoast> alright thanks, off to bed
07:40:32 <jonas_> @undo do [1,2,3,4]; "curry"
07:40:33 <lambdabot> [1, 2, 3, 4] >> "curry"
07:40:54 <merijn> And...onto fix commit 9 >.>
07:41:06 <merijn> Time to hit the gym, I guess :p
07:42:07 <_sras_> jonas_: is there an @unproc similar to @undo?
07:43:49 <_sras_> @unproc proc ()  -> do; r <- qt a -< ();restrict  -<  r ^.id .== r ^. id ; returnA -< r;
07:43:50 <lambdabot> Unknown command, try @list
07:44:19 <_sras_> @undo proc ()  -> do; r <- qt a -< ();restrict  -<  r ^.id .== r ^. id ; returnA -< r;
07:44:19 <lambdabot> <unknown>.hs:1:10:Parse error: ->
07:45:59 <lyxia> GHC has the -ddump-ds options but it can take some effort to read
07:46:47 <hanna> is there a way to make an IO () “uninterruptible?” i.e. won't be interrupt even if there's an external exception (like a SIGTERM)
07:47:00 <Athas> Signal mask, maybe?
07:47:33 <hanna> The problem: I have two IO () actions that are both atomic database updates, but I need to make sure my program doesn't somehow get killed in between the two database updates
07:47:42 <Athas> That is impossible.
07:47:46 <Athas> You cannot ignore SIGKILL.
07:47:53 <Athas> Also, the power might go off.
07:48:05 <hanna> That's true, but I'm willing to ignore both of those
07:48:06 <Athas> Use a database transaction.  Anything else is just ineffectual.
07:48:12 <hanna> They're different databases
07:48:15 <hanna> That's the problem
07:48:23 <Athas> Use https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-Signals.html to mask the signals you want to ignore.
07:48:32 <Athas> But that design is not sound and will bring misery.
07:48:55 <hanna> Honestly I'm just interested in SIGTERM
07:49:00 <hanna> So that seems like a solution
07:49:26 <hanna> The desired goal is to make it so ^C is a harmless action
07:50:17 <[exa]> hanna: anyway, afaik ^c sends SIGINT
07:50:23 <hanna> oh, right
07:51:26 <cocreature> and GHC installs a signal handler by default which converts that into an exception
07:51:30 <Athas> You could also wrap the entire thing in a 'catch'-block that looks for SIGINTs, and then roll back the first operation.
07:51:36 <[exa]> and you probably want to also catch stuff like SIGHUP, I guess closing the terminal is "just like ^c"
07:51:42 <cocreature> so just "mask" will do the job if you are only interested in C-c
07:52:16 <Athas> cocreature: out of curiosity, is there an elegant way to do synchronous signal handling in Haskell (ala signalfd())?
07:52:22 <Athas> I would never use asynchronous signals in a C program.
07:52:43 <Athas> (Although turning signals into exceptions does make them somewhat more manageable.)
07:54:32 <cocreature> Athas: not sure, I never cared about any other signal than SIGINT in haskell
07:54:56 <Athas> Also a viable solution, I suppose.
07:55:49 <ertes-w> hanna: alternatively you can keep a progress file, so if the power goes out, you can continue where you left off
07:57:10 <hanna> I don't understand how I would keep a progress file in such a way that I could figure out after the fact whether the IO () succeeded or not
07:57:56 <Athas> You cannot; you'd need to make the cleanup idempotent, the way file systems or databases implement journals.
07:58:09 <Athas> This is definitely something you want to make someone else's problem if at all possible!
07:58:37 <hanna> actually I know how
07:59:55 <ertes-w> hanna: that's quite difficult…  mdadm does something like that when you make certain --grow changes
08:00:22 <hanna> I'll just augment my state with a Maybe Intent where data Intent = list of IDs I'm about to process. Before I process them I can commit a Just intent; and after I process them I can set it to Nothing. If I start up the program and notice my intent is Just something I need to go through the list of IDs and remove them one by one if they're present
08:00:43 <ertes-w> hanna: but honestly i'd say if you really need to rely on such a thing, you should look for a better data/application design
08:00:51 <hanna> ertes-w: What would you proposE?
08:00:53 <hanna> I'm open to alternatives
08:00:58 <ertes-w> or at least try to make this operation idempotent
08:01:17 <ertes-w> hanna: i haven't read the whole backlog…  could you summarise your application?
08:02:51 <hanna> ertes-w: I process posts (given a range of IDs) and store them in a xapian database. I'm using acid-state to keep track of which IDs I've processed and which I haven't, as well as other metadata. Whenever I commit a batch of IDs, I do it like this:   1. runXapian (beginTransaction >> storeAllInXapianDatabase ids >> endTransaction);  2. Acid.update (processedIDs ids)
08:03:17 <hanna> The problem is that in practice, if my program dies in between step #1 and step #2, I will have stored those IDs in the xapian database but not recorded their “processed” status in the acid database
08:03:25 <_sras_> Can someome please desugar this code that uses arrow notation http://lpaste.net/355913 ?
08:03:37 <ertes-w> hanna: why xapian?
08:04:09 <hanna> ertes-w: xapian provides effigcient tag search that scales to millions of documents; and it's also what the front-end is using
08:04:52 <ertes-w> hanna: does xapian have transactions?
08:04:55 <hanna> xapian also does lots of other useful things, like term synonyms, spelling correction, natural language search, etc.
08:05:02 <hanna> ertes-w: yes, that's what “beginTransaction” and “endTransaction” refers to
08:05:11 <ertes-w> hanna: can it store non-textual data?
08:05:26 <hanna> It only stores documents
08:05:38 <hanna> In principle I could make my own “pseudo-document” with a fixed ID (e.g. 1) to store some metadata though
08:05:42 <ertes-w> hanna: reason i'm asking is: why don't you just use xapian itself to store progress?
08:05:47 <hanna> I'm trying to avoid relying too much on xapian
08:06:00 <hanna> Getting data in and out of xapian is difficult, certainly much more difficult than acid-state
08:06:09 <ertes-w> hanna: there is no other choice…  you can't synchronise acid-state with xapian
08:06:19 <hanna> I came up with a solution, didn't I?
08:06:42 <ertes-w> no…  what happens if your power goes out just after xapian has committed the transaction?
08:07:23 <hanna> If the power goes out after xapian commits but before I run the acid-state progress update, my `intent` would still be set to Just (list of document IDs) and I could go through and delete those IDs from xapian 
08:07:30 <hanna> to “rollback”
08:08:51 <ertes-w> ok, then what's the problem?
08:09:41 <hanna> Nothing?
08:09:55 <hanna> You're the one telling me to change my database design :D
08:11:08 * hackage safeio 0.0.1.0 - Write output to disk atomically  https://hackage.haskell.org/package/safeio-0.0.1.0 (luispedro)
08:11:59 <ertes-w> hanna: because you were hasking about a way to make sure that an operation never interrupts, which is impossible =)
08:12:03 <ertes-w> hasking?  hah!
08:12:04 <cocreature> ^ that package seems surprisingly relevant to the current discussion
08:12:53 <hanna> Well in my case both xapian and acid-state already take care of disk I/O, journaling, rollbacks, transactions etc.
08:13:01 <hanna> I'm left with the much simpler task of simply synchronizing the two
08:13:42 <ertes-w> yeah, well, if you can rollback to a consistent state before users ever see the inconsistent one, everything is fine
08:18:02 <magicman> This is great. I just changed where a bit of data resides (from an MVar to Postgres), and GHC is kicking my ass. However, at the end of the day I feel pretty good that stuff still works.
08:18:04 <fendor> someone ever tried to use coveralls.io to show coverage information in haskell
08:18:04 <fendor> ?
08:20:17 <ertes-w> no, because it would hardly ever get past 5% for me =)
08:26:49 <fendor> :(
08:27:18 <Cale> What was the question? :)
08:27:38 * hackage camfort 0.902 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.902 (madgen)
08:28:17 <jgt> if I'm using `stack runghc`, how do I enable `--pedantic`? aka: `--ghc-options="-Wall -Werror"`?
08:28:18 <fendor> Cale, the concrete question is, what configuration people have used to publish coverage resutls to coveralls.io
08:29:58 <ertes-w> is coveralls.io the new way TDD hipsters compare their dicks/boobs?
08:30:43 <Henson> hi everyone.  I'm extracting data from HTML files using HXT, and reading it into Maybes in case some data can't be read.  Then I want to work with those Maybes to build up other data, with the possibility of it being okay if some data is missing.  If I were to use a Maybe monad to work in a natural way with the data, as soon as a Nothing is encountered the entire computation will fail.  Is there..
08:31:28 <Henson> some natural way of working with Maybes where you can specify that some things are optional.  This totally reminds me of the "optional" and "required" keywords in Applicative, but that seems to be more for parsers.  Is Applicative the right direction, or is there something else I should be trying?
08:31:47 <ertes-w> Henson: the Alternative class is about alternatives
08:31:54 <ertes-w> > Just 3 <|> Just 4
08:31:56 <lambdabot>  Just 3
08:31:59 <ertes-w> > Nothing <|> Just 4
08:32:01 <lambdabot>  Just 4
08:34:48 <Henson> ertes-w: ok, I came across that stuff while reading the Applicative haddock, and that seemed to be the right thing, I just didn't know if I was missing something else that would be better suited.  Thanks for the information!
08:39:34 <fendor> ertes-w, well, actually i just wanted to try ut but thanks...
08:47:08 * hackage logging-facade 0.2.0 - Simple logging abstraction that allows multiple back-ends  https://hackage.haskell.org/package/logging-facade-0.2.0 (SimonHengel)
08:50:51 <_sras_> Can someone please desugar this code that uses proc notation http://lpaste.net/355913 ?
09:04:33 <Welkin> is there an easy way to type unicode characters into emacs such as ∀?
09:07:57 <bytesighs> Welkin: http://haskell.github.io/haskell-mode/manual/latest/Unicode-support.html
09:10:26 <Welkin> bytesighs: thanks!
09:10:34 <Welkin> do you know if purescript-mode supports the same?
09:12:43 <bytesighs> It seems so; https://github.com/dysinger/purescript-mode/blob/master/purescript-unicode-input-method.el
09:19:47 <iqubic> Anyone here, or is it too early
09:19:51 <iqubic> ??
09:20:56 <jamie_> screen
09:22:01 <Welkin> there si always someone here
09:22:09 <Welkin> we are from all around the world
09:24:26 <earthy> early? it's 18:24!
09:25:02 <Clint> no it isn't; it's may
09:25:40 <Welkin> Clint: it's high noon
09:25:47 <Welkin> and all you have is a fistful of monads
10:12:08 * hackage LambdaHack 0.6.0.0 - A game engine library for roguelike dungeon crawlers  https://hackage.haskell.org/package/LambdaHack-0.6.0.0 (MikolajKonarski)
10:13:38 * hackage sum-type-boilerplate 0.1.0 - Library for reducing the boilerplate involved with sum types  https://hackage.haskell.org/package/sum-type-boilerplate-0.1.0 (jdreaver)
10:14:08 * hackage Allure 0.6.0.0 - Near-future Sci-Fi roguelike and tactical squad game  https://hackage.haskell.org/package/Allure-0.6.0.0 (MikolajKonarski)
10:16:56 <Welkin> look, haskell games
10:22:48 <lyxia> I love playing with sum types.
10:23:15 <MarcelineVQ> it's always positive
10:23:59 <Welkin> MarcelineVQ: data Nat = Succ Nat | Z
10:24:00 <Welkin> :D
10:24:02 <Welkin> always positive
10:30:05 <juanpaucar> has somebody used simple postgres and pass an argument as for a table name?
10:30:15 <juanpaucar> I can't figure out how it should be done
10:44:05 <Cale> @tell juanpaucar There is a newtype Identifier which you should wrap the table name in for postgresql-simple to splice it in with the correct quoting.
10:44:05 <lambdabot> Consider it noted.
10:44:28 <Cale> @tell juanpaucar https://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple-Types.html#t:Identifier
10:44:28 <lambdabot> Consider it noted.
10:44:54 <Lokathor> thang1, you were saying "i don't think people use let in code" https://github.com/Lokathor/hexes/blob/master/src/Hexes/Internal/Types.hs#L224
10:56:34 <iqubic> How was that Sci-Fi Game made?
10:57:04 <iqubic> How the heck did he do output, and how did take input?/
10:58:13 <tuturto> not only a game, but a game engine too
10:58:17 <iqubic> Did he he use the LambdaHack package? Or what?
10:58:33 <tuturto> yeah, he did
10:58:48 <tuturto> (he wrote that too)
10:59:08 <iqubic> I think I'll be learning that in the near future.
10:59:24 <iqubic> Or at least disecting it to see how it works.
10:59:28 <tuturto> it's fun
10:59:41 <tuturto> I started tinkering with that a while ago: https://github.com/tuturto/space-privateers
10:59:49 <tuturto> should update to new version and continue
10:59:54 <iqubic> Would it be possible to make a Minecraft Clone in Haskell?
11:00:07 <iqubic> Is Haskell the right language for Game Dev?
11:01:33 <iqubic> Also why are all the links to the online documentation for LambdaHack gone?
11:02:18 <iqubic> None of the module names link to anything at all.
11:02:24 <Welkin> the docs didn't build
11:02:28 <Welkin> a common problem on hackage
11:02:39 <iqubic> So how do I view the docs?
11:02:43 <Welkin> so someone would need to build the docs locally and push them up
11:02:49 <iqubic> And when will this issue be fixed?
11:02:53 <Welkin> you can download the package and buld locally with hackage
11:02:57 <Welkin> build*
11:03:05 <Welkin> having local docs is better anyway
11:03:14 <iqubic> Hackage can be installed locally?
11:03:17 <Welkin> yes
11:03:18 <iqubic> How do I do that?
11:03:21 <Welkin> you can use hoogle locally too
11:03:47 <iqubic> Welkin: I do use hoogle locally.
11:03:55 <tuturto> https://lambdahack.github.io/ is neat
11:04:01 <iqubic> How do I get Hackage installed locally?
11:05:38 <EvanR> iqubic: i am doing "game dev" right now in haskell
11:05:38 <n_blownapart>  hi I have a 32bit linux machine . I don't know emacs / spacemacs *at all* and need a simple editor for haskell. suggestions please. I can use Atom and the haskell-ide fairly well but don't want that on this little machine.
11:06:19 <Welkin> iqubic: I didn't mean hackahe, I meant haddock
11:06:22 <EvanR> but im trying to make it theoretically sound, and so it may never work out, and so im either not the right person to ask or that answers your question
11:06:25 <Welkin> hackage*
11:07:07 <iqubic> EvanR: What kind of games are you making in Haskell right now?
11:07:23 <zachk> n_blownapart: vim? 
11:07:24 <michi7x7> n_blownapart: vim? *grin*
11:07:27 <kadoban> n_blownapart: Editors that I wouldn't make fun of someone for using include: vim, emacs, atom, sublime, maybe gedit, kate. I think some use nano or pico even. I don't think it matters overmuch really.
11:07:51 <Welkin> nano is great when it's all you have :P
11:07:54 <Welkin> like when isntalling arch
11:07:55 <kadoban> Usually as long as I have syntax highlighting and just open ghci in a separate window, it's all good.
11:07:57 <Welkin> installing*
11:08:23 <Welkin> iqubic asks a good question though
11:08:24 <EvanR> iqubic: arcade style
11:08:54 <Welkin> how *do* you force documentation to build with hadock for arbitrary packages?
11:08:57 <iqubic> Editors I would make fun of someone using: Libreoffice Writer, Notepad, Pencil and Paper
11:09:01 <Welkin> I think it's some kind of cabal command
11:09:15 <n_blownapart> thanks kadoban zachk michi7x7 emacs is a bear I don't understand it at all. I tried fiddling with spacemacs and just removed it
11:09:19 <iqubic> Google Docs is on the same list as those other editors
11:09:40 <Welkin> n_blownapart: emacs sucks when you first start, but if you take 30 minutes to learn the basic keybindings, it's great
11:09:44 <iqubic> I started with Vim, and learned that.
11:10:19 <iqubic> Then I heard how much better Elisp was vs VimScript and I switched to Spacemacs.
11:10:21 <n_blownapart> I don't understand why those environments are so unlike normal typing, in say, Atom
11:10:28 <iqubic> I love Spacemacs a lot
11:10:34 <Welkin> you can use vim keybindings in emacs
11:10:43 <Athas> n_blownapart: they are much older than "normal" typing.
11:10:45 <Welkin> I don't care for them 
11:10:47 <lambdamu> What is the purpose of types like CFloat, is it just the Storable instance?
11:10:56 <Athas> Emacs and vi both predate the PC.
11:11:04 <Welkin> lambdamu: it is an unboxed float as represented in C
11:11:18 <n_blownapart> thanks I need a good tutorial to use emacs. I would like to learn it but can't even load packages. I heard intero is good in spacemacs
11:11:34 <Welkin> load what packages?
11:11:42 <Welkin> if you need a quickstart, there are several
11:11:54 <iqubic> Welkin: I don't think he can load any packages.
11:11:57 <Welkin> M-x list-packages brings up the package listing where you can isntall packages
11:11:59 <n_blownapart> intero I think its called Welkin 
11:12:07 <Welkin> oh
11:12:09 <iqubic> What is intero?
11:12:16 <Welkin> that includes adding some lines to your .emacs file
11:12:30 <Welkin> it can be different for each package
11:12:43 <Welkin> you just need to read their docs (And sometimes source comments) to find out how
11:13:31 <Welkin> https://hackage.haskell.org/package/intero
11:13:35 <iqubic> Oh, yeah I use intero.
11:13:39 <n_blownapart> iqubic,  http://commercialhaskell.github.io/intero/
11:13:50 <n_blownapart> correction intero
11:14:16 <iqubic> Because Spacemacs includes that by defualt when you tell it you want a bunch of haskell related stuff
11:14:27 <Welkin> I haven't used it before
11:14:30 <lambdamu> Welkin: hackage says it is just a newtype of Float, isn't that true?
11:14:34 <Welkin> just plain emacs with haskell-mode
11:14:49 <Welkin> lambdamu: perhaps, I was just guessing
11:15:01 <Welkin> lambdamu: you can look at the source 
11:15:33 <n_blownapart> Welkin, iqubic thanks kindly. I'm trying to learn math. Scheme programming started to bug me. getting advice to learn haskell. 
11:15:41 <iqubic> Welkin: If you like your current emacs set-up, then don't switch. I don't recommend it
11:15:55 <iqubic> Why don't you like scheme?
11:16:08 * hackage ghc-exactprint 0.5.4.0 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.5.4.0 (AlanZimmerman)
11:16:10 <Welkin> scheme is cool when you don't know any languages like haskell already
11:16:15 <n_blownapart> so how to load haskell-mode ?
11:16:17 <Welkin> but I can't imagine writing apps with it
11:16:59 <Welkin> n_blownapart: just install it
11:17:03 <Welkin> and it should work
11:17:19 <et09> :t Just $ Just $ Just $ Just Nothing 
11:17:21 <lambdabot> Maybe (Maybe (Maybe (Maybe (Maybe a))))
11:17:24 <Welkin> use this to bring up the package list
11:17:28 <Welkin> M-x list-packages
11:17:40 <Welkin> then C-s haskell-mode
11:17:50 <Welkin> hit i to install
11:17:57 <Welkin> then x to execute your selections
11:18:05 <n_blownapart> thanks C-s is control s ?
11:18:08 <Welkin> yes
11:18:11 <Welkin> it is search
11:18:26 <Welkin> keep hitting C-s to go to the next search result if you need to
11:18:42 <iqubic> And then once you have it installed, just open up an .hs file and it will start up automatically
11:18:42 <n_blownapart> I see thanks will do. is spacemacs worth bothering with?
11:18:51 <iqubic> No.
11:19:02 <iqubic> Unless you already know Vim.
11:19:09 <Welkin> you can configure haskell-mode using the mode hooks too
11:19:10 <iqubic> But otherwise no.
11:19:38 <n_blownapart> there is a UC Berkeley old guard Scheme guy, a CS professor, who told me to learn emacs
11:19:44 <Welkin> lol
11:19:49 <Welkin> I have met those before
11:19:55 <Welkin> one professor at my uni was like that
11:19:55 <Welkin> haha
11:19:57 <iqubic> If you don't know the Vim keybindings, then stay away from Spacemacs
11:20:01 <n_blownapart> his name is Hilfiger
11:20:12 <n_blownapart> ok iqubic good advice thanks
11:20:15 <Welkin> I started using emacs because we used it in my c programming class
11:20:28 <Welkin> I hated it until I learned to love it
11:20:46 <n_blownapart> I'm leaving for Colombia for 2 months. at airport. gonna study emacs and mathematics with haskell.
11:21:01 <Welkin> bogota?
11:21:11 <iqubic> My Highschool CS teacher gave me extra credit for mastering Vim in just a week.
11:21:17 <n_blownapart> you guys will *be hearing from me* with mundane questions about everything
11:21:37 <iqubic> We will be answering those mundane questions and many more.
11:21:59 <n_blownapart> highschool? I'm old. We read about computers in the encyclopedia
11:22:11 <iqubic> n_blownapart: I'm 16
11:22:19 <Tuplanolla> I want to ask first how you think Emacs, math and Haskell are related, n_blownapart.
11:22:25 <iqubic> I've had Computers around me all my life
11:22:29 <n_blownapart> yeah Welkin bogota. I'm going to the Amazon
11:23:02 <iqubic> How do you think Haskell is related to Mathematics. I too, want to know that.
11:23:35 <johnw> iqubic: it's based on the lambda calculus, which was originally invented as a foundation for mathematics
11:23:42 <AWizzArd> https://wiki.haskell.org/What_a_Monad_is_not#Monads_are_not_a_replacement_for_applicative_functors says „every monad is an applicative functor (as well as a functor). It is considered good practice not to use >>= if all you need is <*>, or even fmap.”
11:23:44 <n_blownapart> I heard Haskell is a good language to work on math. Emacs just because its a learning challenge that seems to install on this 32bit machine. otherwise I'd be using Atom
11:23:45 <johnw> which means there are some very close ties
11:23:50 <AWizzArd> Why is it considered a good practice?
11:23:53 <n_blownapart> Tuplanolla, ^
11:24:34 <tsahyt> are there ghcjs builds for stackage lts-8.*?
11:24:39 <kadoban> AWizzArd: It can result in more general code, which thus can be used with a larger number of concrete types. Though a lot of the time it doesn't actually matter.
11:25:07 <n_blownapart> iqubic, I've had women around me all my life
11:25:12 <Tuplanolla> My experience has been that Haskell is neither good for symbolic algebra (like Mathematica) nor number crunching (like Fortran), n_blownapart.
11:25:26 <iqubic> n_blownapart: And why are you telling me that?
11:25:29 <n_blownapart> Fortran is another one on the radar
11:25:47 <Tuplanolla> Even Python has us beat with SymPy and NumPy.
11:25:48 <iqubic> Fortran is the oldest programming language.
11:26:12 <iqubic> Tuplanolla: What is haskell good for in your opinion?
11:26:24 <n_blownapart> iqubic, don't worry just chatter
11:26:32 <AWizzArd> kadoban: good, makes sense
11:26:34 <Tuplanolla> I can make complicated things quickly and be sure they mostly work, iqubic.
11:27:12 <Tuplanolla> This is not constrained to any particular domain.
11:28:12 <n_blownapart> a math professor told me haskell is good for "conceptualizing" math, because of how its written. I dont know haskell just a bit and a bit of scheme (first chapt. sicp almost complete)
11:30:27 <Tuplanolla> I don't disagree, n_blownapart. It definitely helps build intuition for constructive foundational math.
11:30:54 <n_blownapart> encouraging, thanks Tuplanolla 
11:33:20 <n_blownapart> Tuplanolla, in haskell, is recursion emphasized like in Scheme?
11:33:25 <sternmull> with megaparsec, what is the recommended way to skip to eof? I want to use parseMaybe and ignore the unparsed remainder.
11:33:26 <Tuplanolla> Yes.
11:34:17 <n_blownapart> when I do the sicp book Tuplanolla , I hand write out the recursion so that I can visualize what the program is doing. can you do that in haskell?
11:34:31 <Tuplanolla> Yes to all.
11:34:37 <sm> sternmull: anyChar `manyTill` eof, perhaps
11:34:55 <n_blownapart> that is helpful when I do that, your comment too
11:34:58 <Welkin> in my opinion, haskell is perfect for web development (Which can get very messy very quickly)
11:35:19 <Welkin> that is 99% of my use case for haskell, bulding web servers and web apps
11:35:31 <sternmull> sm: Thanks
11:35:42 <n_blownapart> Welkin, excellent. I think I'm going to switch to haskell. The bloody editor is a big impediment
11:36:16 <EvanR> n_blownapart: but how you write out the recursion is different from scheme
11:36:20 <EvanR> the evaluate differently
11:36:41 <n_blownapart> EvanR, are there examples somewhere of how its done?
11:37:39 <Welkin> ;)
11:37:42 <EvanR> yes
11:37:53 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1
11:37:55 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:38:21 <EvanR> i wish i had such an example to just throw out there
11:38:29 <EvanR> instead of explaining it in IRC again
11:40:30 <n_blownapart> but that is just the solution, not the substitution and use of simple primatives to go through the problem
11:40:57 <Welkin> n_blownapart: that is all of it
11:41:04 <Welkin> there is nothing special used there
11:41:51 <n_blownapart> It's odd, the scheme irc tells me not to write out the work, i.e. in tree recursion. but I don't understand a lick of it unless I write it out. 
11:41:53 <Welkin> I defined `fib` as a recursive function on itself
11:42:12 <Welkin> it constructs the list in-place
11:42:19 <n_blownapart> that's cool
11:42:44 <n_blownapart> I sort of get it. I'm in an airport squatting on the floor
11:42:53 <EvanR> n_blownapart: yes, you can write out the fib example step by step, which lambdabot did not do
11:43:29 <EvanR> the first step of evaluating that is to replace fib 0 1 with its definition, which is given in the let bindings...
11:43:36 <EvanR> let fib a b = a : fib b (a + b) in fib 0 1
11:44:27 <EvanR> 0 : (let fib a b = a : fib b (a + b) in fib 1 1)
11:44:30 <n_blownapart> let is just "lambda", right?
11:44:35 <EvanR> no
11:44:53 <EvanR> it introduces a name for an expression
11:44:55 <Welkin> `let` binds some expression to a name
11:45:05 <EvanR> lambda constructs a function
11:45:34 <n_blownapart> ok, in scheme that is like defining a anonymous lambda I think
11:45:37 <EvanR> n_blownapart: read the first step and convince yourself the substitutions were done right
11:45:45 <EvanR> scheme has lets too
11:45:51 <Welkin> the pattern is `let <name> = <expression> in <another expression that uses <name>>`
11:45:51 <EvanR> but theyre not recursive or lazy
11:46:04 <EvanR> unless you use a special form for that
11:46:36 <Tuplanolla> I think he's asking if `let y = x in z` is the same as `(\ y -> z) x`, EvanR.
11:46:46 <EvanR> sure, its not
11:47:05 <cocreature> what is some cheap IO action that I can use to benchmark ">>" for various monad transformer stacks? ghc seems to optimize "pure () >> a" to "a" so I need something that actually does some IO
11:47:23 <EvanR> threadDelay 1 ?
11:47:34 <Welkin> cocreature: print?
11:47:53 <EvanR> i guess neither of these suggestions is necessarily cheap.  heh, cheap IO
11:47:57 <cocreature> Welkin: print can be annoyingly expensive
11:48:00 <n_blownapart> EvanR, ok I really hope we can revisit this. I can't focus in the airport. many thanks Tuplanolla EvanR et al
11:48:05 <cocreature> and threadDelay is probably going to mess with benchmarks
11:48:39 <Welkin> cocreature: write an empty IOArray?
11:48:58 <cocreature> or even just an IORef
11:49:00 <cocreature> thanks
11:49:02 <cocreature> that could work
11:52:08 <iqubic> What's the best Data structure to store the state of a Tic-Tac-Toe board.
11:52:17 <iqubic> If not a list, then what?
11:52:56 <iqubic> Because lists are primarily use as control structures in Haskell, right?
11:54:28 <exio4> iqubic: you can use two IntMap(s)? IntMap (IntMap Space) with data Space = X | O | Empty or so :P 
11:54:29 <Tuplanolla> It's so small a `Map (Coord, Coord) Fill` with `|Coord| = |Fill| = 3` should do, iqubic.
11:55:24 <iqubic> exio4: I'm using data Piece = X | O | Blank
11:55:47 <Welkin> a Map or an Array would work
11:55:56 <Welkin> especially with Array's Ix interface
11:56:00 <exio4> I am guessing the best would be to inline everything, but it's much much more annoying 
11:56:30 <iqubic> Why do you think I should inline everything?
11:57:35 <exio4> iqubic: in terms of raw performance, of course, not in terms of code niceness, I'd go with Tuplanolla's solution though :P 
11:57:43 <iqubic> What does `Map (Coord, Coord) Fill` with `|Coord| = |Fill| = 3` do?
11:58:04 <Welkin> I don't know what that means either
11:58:26 <iqubic> What are you suggesting I do Tuplanolla?
11:58:40 <Welkin> but you can simply use `Map (Int, Int) Piece`
11:58:54 <Tuplanolla> The cardinality notation `|T| = N` means `T` has `N` inhabitants.
11:59:01 <Welkin> or, `Array Piece` and use the Ix interface to index with (Int, Int)
11:59:10 <iqubic> Ah, I did not know that.
11:59:13 <Welkin> same thing really
11:59:18 <EvanR> Array makes the most sense to me
11:59:19 <Tuplanolla> Examples include `Int` between `0` and `2` or your `Piece`, iqubic.
11:59:36 <iqubic> I think I'll use an Array.
12:00:44 <iqubic> How should I go about learning about the Haskell Array and Ix interface.
12:00:54 <Welkin> http://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array.html
12:01:00 <EvanR> read the docs and try stuff in GHCI
12:01:04 <Welkin> the docs are always the best place to start, unlike other languages
12:01:12 <Welkin> they often have tutorials in them
12:01:15 <iqubic> That's the same way I was told to start yesterday.
12:01:23 <Tuplanolla> It's a good way.
12:01:25 <EvanR> yes im having dejavu entirely again
12:01:36 <Welkin> http://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array.html#v:array
12:01:42 <Welkin> that in particular shows you how to use it
12:01:42 <EvanR> must be a shared hallucination
12:02:19 <Tuplanolla> It's sometimes instructive to read the source too. It tends to not be pragma porridge like for some other languages.
12:03:25 <matrium> Hi, how can I bind over the inner monad of a transformer stack? something like "StateT s m a -> (m a -> m b) -> StateT s m b"
12:03:50 <EvanR> :t lift
12:03:52 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
12:03:57 <Tuplanolla> :t hoist
12:03:59 <lambdabot> error: Variable not in scope: hoist
12:04:39 <hexagoxel> :t mapStateT
12:04:40 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
12:04:42 <Welkin> http://hackage.haskell.org/package/mmorph-1.1.0/docs/Control-Monad-Morph.html#v:hoist
12:04:44 <iqubic> Do I need to install any packages from Hackage to use Arrays and Ix?
12:04:56 <iqubic> Or is it in the base?
12:05:02 <Welkin> iqubic: Data.Array, but that should be in base
12:05:05 <Welkin> just try it out
12:05:11 <Welkin> the compiler will tell you if you are missing anything
12:10:38 <iqubic> That's what I love about Haskell, how simple the errors are to parse.
12:10:58 <cocreature> "Data.Array" is not in "base", it’s in the "array" package
12:11:06 <Welkin> ah yes
12:11:27 <Welkin> but you won't find any errors like "undefined is not a function"
12:12:06 <Tuplanolla> "main is usually a function".
12:12:19 <cocreature> isn’t there some blog by that name?
12:12:31 <Tuplanolla> @google "main is usually a function"
12:12:31 <Welkin> it's the most common error in javascript land
12:12:32 <lambdabot> http://jroweboy.github.io/c/asm/2015/01/26/when-is-main-not-a-function.html
12:12:32 <lambdabot> Title: Main is usually a function. So then when is it not?
12:13:20 <Tuplanolla> That's certainly a blog.
12:14:22 <EvanR> what in the wworld
12:19:17 <maerwald> omg xD
12:22:16 <Gurkenglas> Can we get ircbrowse out of the topic yet?
12:23:22 <Welkin> lol
12:23:33 <Welkin> that is an actual error from gcc "main is usually a function"
12:23:37 <Welkin> never seen that one
12:24:25 <pikajude> i wish GHC-built binaries didn't take 15 minutes to start up on WSL
12:24:33 <Welkin> WSL?
12:25:16 <iqubic> Is there a way to take a list and turn it into an enum?
12:25:37 <geekosaur> how would that work?
12:25:39 <Welkin> you mean create a type from a value?
12:25:42 <EvanR> what is the type of that operation
12:25:48 <iqubic> I don't know
12:25:57 <EvanR> ah
12:26:06 <iqubic> How do you create an enum in Haskell?
12:26:09 <EvanR> you can use template haskell to generate enum types
12:26:17 <Welkin> it's not an enum, but a sum type
12:26:19 <geekosaur> types are a compile time thing, "making an enum from a list" is a runtime thing
12:26:27 <Welkin> data SumType = A | B | C
12:26:33 <geekosaur> unless you are thinking TH which kinda mixes the levels with a "runtime" at compile time
12:26:34 <pikajude> WSL is linux on windows
12:26:36 <pikajude> new in w10
12:26:46 <Welkin> pikajude: oh god, that thing?
12:26:49 <geekosaur> ^ "windows services for linux"
12:26:50 <pikajude> the RTS allocates like 2TB of virtual memory
12:26:51 <Welkin> it' s trojan horse
12:27:00 <pikajude> and WSL can't gracefully deal with that
12:27:02 <pikajude> :(
12:27:04 <Welkin> I'd never trust it
12:27:07 <merijn> pikajude: Ah
12:27:07 <iqubic> I don't use that.
12:27:10 <EvanR> for a minute i thought, due to the name, it was a windows subsystem that runs on linux
12:27:14 <geekosaur> pikajude, there's some talk about providing an RTS option to fall back to the old memory allocator
12:27:28 <merijn> pikajude: The 2TB is by design, but the windows degradation probably isn't
12:27:35 <geekosaur> don't know if it will be in 8.2
12:27:47 <merijn> I recall windows has a stupid way of dealing with mmap, which is the issue
12:27:48 <pikajude> i hope they just fix it instead, to be honest
12:27:57 <iqubic> I did use WSL, but I removed it when I found out that it was a terrible thing.
12:28:03 <pikajude> what's wrong with it?
12:28:05 <merijn> pikajude: I'm not sure GHC *can* fix the issue
12:28:08 <geekosaur> but WSL doesn't support the speculative page table allocation that produces the fake 2TB "allocation"
12:28:17 <pikajude> merijn: I mean MS, not GHC
12:28:21 <Welkin> what is the reason to use WSL at all?
12:28:24 <merijn> pikajude: Oh, right, agreed :)
12:28:25 <Welkin> just run linux
12:28:38 <pikajude> Welkin: games
12:28:42 <merijn> Welkin: You can run stuff on windows using the familiar posix layout?
12:28:43 <EvanR> business
12:28:44 <Welkin> dual boot
12:29:01 <merijn> Welkin: billions use windows, people might wanna sell software/tools to those people...
12:29:05 <pikajude> not really interested in having 10 minutes of downtime every time i want to play a game
12:29:16 <pikajude> sometimes I want to play a game and also be in IRC simultaneously
12:29:24 <Welkin> use two computers
12:29:25 <Welkin> I do that o.o
12:29:32 <pikajude> how about no
12:29:33 <EvanR> is this argument really appropriate
12:29:52 <EvanR> haskell tends to suck on windows, we need to fix that
12:30:04 <pikajude> haskell is fine on linux, it's their memory manager that's the problem
12:30:08 <merijn> pikajude: Anyway, I think people are working on a workaround/solution for windows until MS fixes it, but I'm not sure what the time frame is, tbh
12:30:15 <Welkin> no one wants to fix it though because few of us use windows
12:30:24 <EvanR> which is a problem
12:30:27 <pikajude> merijn: well, ok
12:30:30 <pikajude> I'll deal with it
12:30:35 <pikajude> I wonder if this ghcjs build will be finished by tomorrow
12:30:54 <Welkin> many games already run on linux
12:31:02 <Welkin> there are only a few of the ones I play that don't
12:31:10 <pikajude> 95% of the ones I play don't
12:31:14 <Tuplanolla> The trivial solution is to stop playing games entirely, like I did.
12:31:15 <Welkin> windows becomes less and less useful every day
12:31:41 <koala_man> speaking of which, how can I build a Windows .exe on Linux? cabal builds it just fine on Windows
12:31:52 <pikajude> don't you have to have a cross compiler for that
12:32:00 <Tuplanolla> Bigger lifestyle changes have happened.
12:32:02 <sm> you can use wine
12:32:12 <merijn> Welkin: I don't see how this is at all helpful or constructive?
12:32:20 <pikajude> wine can't emulate dx3d
12:32:26 <sm> for some projects
12:32:30 <merijn> Hell, SPJ develops GHC on windows, so saying "no one cares about windows" seems disingenous
12:32:43 <merijn> koala_man: Do you want simple or painful?
12:32:56 <pikajude> that seems like a silly question
12:33:25 <crundar> What are the laws of run for a monad? How does one "check the laws" that run is implemented properly, the way one would with >>= and return? 
12:33:28 <merijn> koala_man: The simple solution is: Don't. Download VirtualBox (or the VM of your choice), install GHC+cabal on it and compile on Windows directly
12:33:40 <Welkin> crundar: you have to manually check the laws
12:33:44 <EvanR> run isnt a part of the monad laws
12:33:46 <Welkin> ghc will not check them for you
12:33:47 <merijn> koala_man: You probably *can* cross-compile, but I wouldn't wish that upon my enemies...
12:34:29 <merijn> pikajude: Well, the simple solution isn't really a solution. But sometimes the easiest way is to not solve a problem >.>
12:34:30 <koala_man> merijn: I want to do it automatically on Travis, so I'm not sure if vbox is suitable
12:34:39 <sm> koala_man, merijn: or you can use wine, in many cases
12:34:42 <merijn> koala_man: Not sure if travis can do that kinda thing
12:34:49 <crundar> Welkin: what are those aspects of the laws, then? I didn't see anything corresponding in unit/fmap/join or >>=/return formulations? 
12:34:51 <koala_man> maybe I can use wine in a docker image or something
12:35:12 <pikajude> yeah, I kinda doubt travis can do that, you might need your own build machine
12:35:31 <Welkin> crundar: check the typeclassopedoa
12:35:35 <sm> why is docker needed ? 
12:35:35 <Welkin> @where typeclassopedia
12:35:35 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:35:41 <Welkin> the laws are listed there
12:35:44 <EvanR> compile windows binaries on windows in a vm
12:35:46 <merijn> sm: I dunno, everything needs docker nowadays
12:36:08 <cocreature> if you use docker it’s webscale
12:36:18 <sm> pretty sure you'll be able to download and run wine as part of a travis script, like we do with eg stack
12:36:22 <merijn> Unrelatedly, 9th commit was the charm to actually work :p
12:36:22 <pikajude> I've not ever actually found a use for docker
12:36:47 <sm> but you can also use appveyor, which is windows
12:38:10 <crundar> EvanR: Or, I guess, why not? What does govern the "correctness" of an implementation of a run? 
12:38:18 <koala_man> sm: I'm not entirely sure how Travis works, but it seems like the kind of environment where docker would be available but wine wouldn't
12:38:19 <EvanR> nothing
12:38:27 <EvanR> run is not even part of the Monad interface
12:38:31 <pikajude> would wine really work in docker?
12:38:42 <EvanR> not all monads have something that begins with the word run
12:39:35 <Welkin> what is `run` anyway?
12:39:45 <Welkin> do you mean things like `runReader` and `runST`?
12:40:00 <Welkin> those are just record accessors that unwrap the values
12:40:17 <EvanR> they are functions specific to each monad, and only some of them
12:41:22 <EvanR> e.g. [], Maybe, Stream dont have any run thing
12:42:16 <Gurkenglas> How do I find the most specialized common generalization of two types?
12:42:36 <Welkin> lol Gurkenglas 
12:43:57 <Gurkenglas> The most general common specialization, if it exists, would be :t [undefined :: <a>, undefined :: <b>]
13:00:30 <wz1000> Gurkenglas: What would be the "most specialized common generalization" for Read a => a, Show a => a?
13:00:59 <Gurkenglas> a
13:01:48 <Welkin> (Read a, Show a) => a
13:01:48 <Welkin> :D
13:01:57 <Gurkenglas> No, that's the most general common specialization
13:02:04 <Welkin> o.o
13:02:43 <Tuplanolla> Is the answer always `a`, Gurkenglas?
13:03:05 <Welkin> forall a. a
13:03:12 <Gurkenglas> Tuplanolla, for Int -> b and String -> c, it's a -> b
13:03:24 <wz1000> why not a?
13:03:36 <Tuplanolla> Oh, I see now.
13:04:08 <Gurkenglas> Because a -> b is more special than a and more general than Int -> b and String -> c, so a cannot be the most specialized type that is more general than Int -> b and String -> c.
13:04:08 * hackage here 1.2.11 - Here docs & interpolated strings via quasiquotation  https://hackage.haskell.org/package/here-1.2.11 (TaylorHedberg)
13:04:36 <Tuplanolla> Would it work to assume all variables are free and perform unification, Gurkenglas?
13:05:40 <Gurkenglas> That's still the most general common specialization
13:05:54 <Gurkenglas> Read a and Show a do not unify to a
13:06:01 <Gurkenglas> *"=> a" ._.
13:06:48 <Tuplanolla> You'd get `c => a`, no?
13:07:38 <Gurkenglas> That's the same as a
13:09:04 <Gurkenglas> Something that gives "c => a" for any c and a can give it for c = the empty constraint, so it can be specialized to "a", and "a" can be specialized to "c => a" because "a" can be specialized to anything.
13:10:22 <Gurkenglas> What GUI framework should I use in order to let the user explore a DAG?
13:12:05 <wz1000> I like gloss. And it has a neat self balancing graph example.
13:18:15 <\u> data Bad a = Bad (Bad a -> a)   . does it have a name?
13:23:45 <Gurkenglas> For a = {Cooperate, Defect}, it looks like the type of prisoner's dillemas bots that are given a blackbox of their counterpart
13:35:54 <EvanR> question
13:36:05 <thang1> Answer
13:36:11 <EvanR> how do i use a case but only for its guards
13:36:22 <EvanR> do i nec have to do _ | asdf -> ...
13:36:43 <johnw> case () of () | blah -> ...
13:36:45 <Tuplanolla> You probably have to `case () of () | ... -> ...`, EvanR.
13:37:10 <thang1> Can you not just use guards directly? o.O
13:37:28 <hpc> guards are syntactically a part of pattern matching
13:38:03 <geekosaur> sounds like EvanR is reaching for the MultiWayIf extension to me
13:38:21 <EvanR> ok but multiway if requires you save the expr to a let first...
13:38:34 <geekosaur> huh?
13:38:38 * hackage hsdev 0.2.5.0 - Haskell development library  https://hackage.haskell.org/package/hsdev-0.2.5.0 (AlexandrRuchkin)
13:38:58 <EvanR> trying to split on a numeric result being < 0, == 0, > 0
13:39:31 <EvanR> which i see is not exactly what i was getting at
13:39:34 <Gurkenglas> case compare x 0 of
13:39:36 <geekosaur> I'd actually write that as : case compare x 0 of
13:39:51 <Tuplanolla> Today you get two answer for the price of one!
13:40:39 <EvanR> hmm.
13:40:41 <geekosaur> and what you were looking for wasn't just "only for its guards" so much as "partially applied guards" which isn't really a thing
13:47:04 <iqubic> What's a DAG?
13:47:29 <iqubic> Draggable Art Gidget?
13:47:43 <descender> directed acyclic graph?
13:47:47 <EvanR> ^
13:50:39 <geekosaur> aka a tree with no loops, more or less
13:50:42 <EvanR> ok so case compare (foo bar baz) 0 of
13:50:51 <EvanR> but then i dont have the value to use
13:50:51 <EvanR> ...
13:50:57 <geekosaur> @src Ordering
13:50:57 <lambdabot> data Ordering = LT | EQ | GT
13:51:03 <EvanR> the result of foo bar baz
13:51:22 <geekosaur> you did the comparison, you have an Ordering now.
13:51:31 <EvanR> but not the numeric value
13:51:47 <EvanR> i dont know why i thought this would have a shorter way
13:52:05 <pikajude> LT = foo, EQ = bar, GT = baz
13:52:08 <geekosaur> what are you doing now that you want the numeric value?
13:52:24 <EvanR> using it, but how i use it depends on if its positive negative or zero so
13:52:30 <EvanR> i guess ill do let then multiway if
13:52:33 <geekosaur> yes
13:52:42 <geekosaur> positive is GT, zero is EQ, negative is LE
13:52:46 <geekosaur> er LT
13:52:50 <geekosaur> > compare 5 0
13:52:52 <lambdabot>  GT
13:53:08 <Lokathor> dag, i have a (StateT ProgState IO a), and GLFW lets you set an IO callback, and I want to set it up so that you can run a callback in the StateT layer
13:53:22 <Lokathor> and these types i tell you
13:55:07 <EvanR> http://lpaste.net/355922
13:55:43 <EvanR> Lokathor: with GLFW callbacks... it pays to set up either global or partial closured TVars or MVars to share state
13:56:04 <EvanR> then run your state actions from there
13:56:33 <Lokathor> so instead of (StateT HexesState IO a) i use (StateT (TVar HexesState) IO a) ?
13:57:52 <EvanR> you use which ever you want, but you "run" it from the callback
13:57:56 <EvanR> which is IO ()
13:58:22 <EvanR> get the state out of the var, run it, put the modified state back
13:58:29 <Lokathor> hmm
13:58:42 <dmj`> TVar’s can be modified anywhere in monad with a base of IO, at that point a StateT isn’t useful (i.e. StateT (TVar HexesState) IO a)
13:58:46 <EvanR> which i see now means use the first one
13:59:19 <cozachk> couldn't you use a readerT if you are using TVars or MVars because they are refernences and you never actually mutate them
13:59:21 <EvanR> yes StateT (TVar ...) is kind of suspicious
13:59:44 <Lokathor> well the point is that the HexesState is locked away from bothering with for normal users, and they actually use various Hexes actions to affect it
13:59:46 <EvanR> cozachk: the callback is an *IO ()*, not a MonadBaseControled lifted stacked whatever you want
14:00:03 <Lokathor> yeah that's the problem
14:00:18 <Lokathor> GLFW has IO () for callbacks, but I want to be able to do the StateT version of things as the accepted callback
14:00:19 <EvanR> Lokathor: this would not be involved with users... unless i still misunderstand who your users are
14:00:40 <Lokathor> "users of the library", i should say
14:00:44 <Lokathor> people outside the module
14:01:02 <EvanR> what im saying completely lets users provide StateT Whatever actions the same as before
14:01:08 <EvanR> im explaining how you do what you said to do
14:01:32 <EvanR> whoever has access to whatever they had before, this just how you get the callbacks to run the proper monads
14:01:59 <Lokathor> hmm
14:02:50 <chewzerita> @pl (\x y -> x ^^ (round y))
14:02:51 <lambdabot> (. round) . (^^)
14:03:09 <jle`> \x -> (x ^^) . round
14:06:19 <Lokathor> http://lpaste.net/355923 so EvanR, with things setup like this so far, you're suggesting that an MVar layer be put in basically?
14:06:49 <Lokathor> and then you get the state, execute an inner State action, get the resulting state back from that inner action, and then put it back into the mvar?
14:12:08 * hackage bindings-levmar 1.1.0.4 - Low level bindings to the C levmar (Levenberg-Marquardt) library  https://hackage.haskell.org/package/bindings-levmar-1.1.0.4 (BasVanDijk)
14:15:08 * hackage levmar 1.2.1.7 - An implementation of the Levenberg-Marquardt algorithm  https://hackage.haskell.org/package/levmar-1.2.1.7 (BasVanDijk)
14:15:12 <EvanR> Lokathor: using modifyMVar_ or equivalent TVar machinery
14:16:16 <Lokathor> I'm not sure if I want MVar or TVar, but this feels more like MVar
14:17:03 <pikajude> i'm pretty sure developing in a linux VM with ghcjs will be faster than trying to use it on WSL
14:26:47 <AWizzArd> https://wiki.haskell.org/Monad#Monad_class says „Any Monad can be made a Functor” — possible that this article was written when Monads didn’t have the Functor constraint?
14:27:02 <Lokathor> old articles on the wiki? never
14:27:12 <Lokathor> :3
14:31:03 <EvanR> "However, the Functor class is not a superclass of the Monad class." <- real old
14:31:29 <pikajude> I feel like that's ripe territory for one of those "just got out of a coma" memes
14:31:30 <EvanR> the very definition of Monad is of a certain kind of functor
14:32:49 <monochrom> https://ro-che.info/ccc/21
14:33:57 <Lokathor> http://lpaste.net/355923 EvanR does this look right? I mean it compiles and all
14:37:09 * hackage soap 0.2.3.5 - SOAP client tools  https://hackage.haskell.org/package/soap-0.2.3.5 (AlexanderBondarenko)
14:37:13 <EvanR> if it compiles its good
14:37:21 <Lokathor> right, of course :P
14:37:24 <Lokathor> let's try testing this out
14:38:18 <EvanR> erm
14:38:25 <Lokathor> seems to work
14:38:32 <EvanR> the var is inside the state that youre trying to implement/
14:39:10 <Lokathor> well, the MVar is the state at the moment, yet, but really now that it's wrapped in an MVar it should be more like ReaderT
14:39:12 <EvanR> is this api like a duplicate of the GLFW api
14:39:46 <EvanR> i dont think this will work
14:39:48 <Lokathor> the part that lets you set a callback is essentially the GLFW callback minus the window being passed to you
14:40:04 <EvanR> the set callback is an action of the monad that uses the state that the action would already be using
14:40:07 <EvanR> so it should deadlock
14:40:16 <Lokathor> well it prints when i press letters in my demo
14:40:28 <EvanR> welp sounds like it makes sense to you : )
14:41:22 <Lokathor> i could try to explain to you why i think it should work, if you still think it shouldn't :?
14:41:50 <Lokathor> basically the MVar is safe to be shared at any time since it's not mutated, it's more like a pointer
14:42:03 <Lokathor> so everyone sees all the updates
14:42:21 <EvanR> if you run an action, you need the state, which is in the var. if you run another action from within the action, theres no state in the var
14:42:29 <EvanR> and youre stuck
14:42:52 <EvanR> keeping the var inside the state thats inside the var, etc just seems weird to me
14:43:08 <Lokathor> well again, it should be more like ReaderT at this point
14:44:10 <Lokathor> the MVar doesn't hold itself, if that's what you're asking
14:44:37 <Lokathor> http://lpaste.net/355925
14:47:21 <Lokathor> I'll rename it to HexesData to reduce possible confusion
14:51:23 <EvanR> i do not understand the need for StateT (MVar StateData) ...
14:52:00 <Lokathor> what if it was "newtype Hexes a = Hexes (ReaderT (MVar HexesData) IO a)" ?
14:52:40 <EvanR> is Hexes the monad you want users to use?
14:52:45 <Lokathor> yes
14:53:04 <EvanR> why do actions need the MVar
14:53:18 <Lokathor> that's where all of its own configuration data lives
14:53:26 <EvanR> what
14:53:36 <EvanR> doesnt it live in HexesData
14:53:58 <Lokathor> the MVar is holding the data, yes
14:54:00 <EvanR> or youre deciding not to use a State monad at all
14:54:32 <Lokathor> it *was* state, until i realized a bit ago that you can't at all easily mix that with the GLFW callbacks
14:54:37 <EvanR> its an extra step for the action to get the data out of the mvar every time...
14:54:38 <Lokathor> then you suggested mvar, and so i went that route
14:54:45 <EvanR> you can, which is what i was saying
14:55:13 <Lokathor> so, then, what would you do diffently with the mvar compared to what i'm doing?
14:55:59 <iqubic> Does this exist: type Bad a = Bad (Bad a -> a)
14:56:10 <EvanR> no
14:56:18 <iqubic> Why not?
14:56:20 <EvanR> newtype Bad a = Bad (Bad a -> a) does
14:56:40 <iqubic> What is that type called, Bad?
14:56:57 <pikajude> it's called Bad
14:57:03 <EvanR> you named it that didnt you
14:57:30 <iqubic> Why is it called Bad? How do you use it?
14:57:49 <EvanR> where did that come from
14:58:08 <iqubic> I saw it in chat earlier today.
14:58:16 <EvanR> im not sure how you could construct a bad
14:58:25 <EvanR> Bad <what>
14:58:52 <EvanR> newtype Bad a = Bad { unBad :: a }
14:59:03 <EvanR> hmm.
14:59:11 <EvanR> newtype Bad a = Bad { unBad :: Bad a -> a }
14:59:26 <EvanR> unBad :: Bad a -> Bad a -> a
14:59:53 <pikajude> "construct a bad"
15:00:00 <iqubic> What about: newtype Good a = Good (a -> Good a)
15:00:04 <iqubic> Is that a thing.
15:00:08 <geppettodivacin> The one iqubic mentioned was definitely mentioned about two hours ago. No one really discussed it, though.
15:00:10 <EvanR> that makes more sense
15:00:43 <iqubic> Wait, not only is that a thing, but several dozen types use that Good format
15:00:43 <geppettodivacin> I'm not really sure how I would construct Good, myself.
15:00:59 <Tuplanolla> Now we only lack `newtype Ugly a = Ugly {unUgly :: Ugly a -> Ugly a}`.
15:01:10 <pikajude> couldn't it just be Good Good
15:01:15 <EvanR> ugly makes the most sense
15:01:28 <EvanR> Ugly id :: Ugly (Ugly a)
15:01:37 <EvanR> erm
15:02:00 <EvanR> everyone put all this in the compiler now
15:02:09 <Rotaerk> Ugly UrMom
15:02:42 <Lokathor> EvanR, how did you expect the MVar to be used if not to wrap around the StateT's state value?
15:03:30 <EvanR> :t runState
15:03:31 <lambdabot> State s a -> s -> (a, s)
15:03:49 <EvanR> :t modifyMVar
15:03:50 <lambdabot> error: Variable not in scope: modifyMVar
15:04:06 <EvanR> MVar a -> (a -> IO (a, b)) -> IO b
15:04:53 <EvanR> modifyMVar_ mv (let (x, s') = runState action s in return (s', x))
15:04:58 <EvanR> er
15:05:01 <EvanR> modifyMVar mv (let (x, s') = runState action s in return (s', x))
15:05:33 <EvanR> and i forgot the IO
15:06:05 <Lokathor> so, get the state at the StateT level, use it in the modifyMVar, and then get that state back from there into the StateT level, and set it again in StateT?
15:07:09 <Lokathor> but your state within the callback would be stale, because you generally only set the callback once at the start of the program.
15:07:10 <EvanR> this is "IO level"
15:07:21 <EvanR> the state is in the MVar
15:07:32 <EvanR> it always has the latest state
15:08:18 <Lokathor> so, instead of, "newtype Hexes a = Hexes (ReaderT (MVar HexesData) IO a)", what would you write as the newtype definition? When does the state go into the MVar?
15:09:09 <EvanR> modifyMVar puts it back, so you mean, originally?
15:09:27 <Lokathor> yeah, when does it get into the mvar for you to use with modifyMVar
15:09:43 <EvanR> when you set up
15:10:09 <Lokathor> so you would use ReaderT then?
15:10:32 <EvanR> if the monad is supposed to modify the HexesData, StateT is a possibliity
15:11:02 <Lokathor> well, StateT (MVar a) and ReaderT (MVar a) are nearly identical either way
15:14:16 <andrei> Is there a way to convert a value (something that's say Typeable or Generic) to an haskell-src-exts AST from?
15:15:09 <EvanR> well if you want to put the MVar in there, great
15:15:21 <thang1> oh my god
15:15:27 <Lokathor> EvanR, how else do you pass the mvar along the computation?
15:15:32 <EvanR> you wouldnt!
15:15:42 <EvanR> the question was, why do you want to
15:16:00 <EvanR> "to get the data in it" is not the answer
15:16:10 <Lokathor> the user can call setKeyCallback at any time, so if you need the mvar to assign a key callback, you at least need the mvar during that operation
15:16:21 <thang1> Check this out: https://www.reddit.com/r/rust/comments/5penft/parallelizing_enjarify_in_go_and_rust/dcsgk7n/
15:16:22 <EvanR> ok
15:17:43 <Welkin> lol, rust
15:17:57 <thang1> The beauty is the comment chain about Go generics
15:18:20 <Lokathor> "If you look closely, those aren't angle brackets, they're characters from the Canadian Aboriginal Syllabics block"
15:18:38 <thang1> Completely slayed me
15:21:17 <thang1> So have you heard about microsoft's P language?
15:21:36 <thang1> I can't wait for someone to release a Nis framework for the language so I can learn it and put P/Nis on my resume
15:21:56 <EvanR> rimshot
15:23:04 <hpc> http://www.pnas.org/
15:23:15 <thang1> glorious
15:23:32 <thang1> Nobody has ever made a joke at the academy, I'm sure
15:24:09 <monochrom> thang1: I don't get the P/Nis joke...
15:24:25 <monochrom> Oh, now I get it. Have to pronounce it.
15:24:47 <monochrom> Do you happen to know why they named it P?
15:25:31 <monochrom> (And another childish joke: Whereas C compilers are called "cc", are they going to call P compilers "pp"?)
15:25:34 <thang1> I, honestly, have no idea
15:25:54 <thang1> Well they can't call it pc because no republican would ever program in that language /s
15:26:41 <thang1> I'm /guessing/ that since it's for async event-driven systems that P comes from shortening 'ping'
15:26:56 <Tuplanolla> Free Pascal already has `pc`.
15:31:19 <Lokathor> so if i have a flat, linear sequence of items, and i want to be able to update those items from time to time in an efficient manner and also have them accessable via a Ptr value
15:31:33 <Lokathor> I'm kinda stuck with Vector.Storable.Mutable and its anemic interface, aren't i?
15:31:43 <Lokathor> or is the overhead on Vector.Storable not so bad?
15:34:52 <Gurkenglas> Why does intero-type-at say that filtered is not in scope? https://i.gyazo.com/eaad01e2ff74a0822cf9f2ea3e055a99.mp4
15:42:25 <lpaste> saylu pasted “hoauth2 issue” at http://lpaste.net/2999345030537150464
15:42:31 <saylu> hey folks! getting a super odd issue with hoauth2
15:43:08 * hackage hnormalise 0.3.2.0 - Log message normalisation tool producing structured JSON messages  https://hackage.haskell.org/package/hnormalise-0.3.2.0 (AndyGeorges)
15:43:23 <saylu> I'm able to fetch an access token for a Google API just fine -- but when I then try to fetch a refresh token, hoauth2 thinks it's got to parse a URL when its getting a JSON response
15:43:51 <saylu> typechecks just fine, and I've referred to this example and don't see where I'm going off the rails:
15:43:51 <saylu> https://github.com/freizl/hoauth2/blob/master/example/Google/test.hs
15:43:53 <saylu> Any ideas?
15:56:20 <thang1> Line 38 looks ugly (but that's just aesthetics)
15:57:01 <thang1> Where's the actual error happening?
16:02:51 <lambdamu> is it possible to get a list of names along with there types that are in scope with template haskell, maybe even with their source module if their were imported? With reifyModule it is possible to get a list of imported modules, but can we get an import list from those names?
16:06:27 <saylu> thang1: in the 'fetchrefresh' function
16:07:17 <saylu> Line 18
16:08:35 <lpaste> saylu revised “hoauth2 issue”: “hoauth2 issue” at http://lpaste.net/2999345030537150464
16:09:16 <saylu> thang1: I added a different function that works very similarly -- it's to fetch the initial token, not to refresh the token. But the format is quite similar. Maybe that will provide some extra contex.t
16:10:03 <saylu> The main thing is in the `fetchRefreshToken` function, which gives an exception ----> *** Exception: hoauth2.HttpClient.parseResponseString/Could not decode URL: {  "access_token" : "ya29.G ........... 
16:17:27 <et09> clojure or scala, who wins in a cage match
16:17:53 <EvanR> haskell drops in from the rafters
16:18:01 <glguy> et09: No, that's not on topic for #haskell
16:18:04 <EvanR> with cheap fireworks going on
16:18:20 <cozachk> et09, try asking in #haskell-blah
16:18:37 <et09> right i forgot the ontopic/offtopic thing
16:21:07 <cozachk> et09, well blah is offtopic so you can ask in there
16:24:38 <saylu> From this:
16:24:50 <saylu> hoauth2 has two ways to parse responses:
16:25:00 <saylu> parseResponseString and parseResponseJSON
16:25:14 <saylu> currently I"m getting an exception because `fetchRefreshToken' is trying to use parseResponseString for JSON
16:25:27 <saylu> Is there any way I could force it to use parseResponseJSON instead?
16:26:27 <saylu> Oh, hmm -- it's using `doFlexiblePostRequest` under the hood to return either JSON or a string, but it's choosing the wrong one
16:26:30 <saylu> oof
16:43:24 <Squarism> saylu, dont really know what you problems is - but i can say i was able to use hoauth2 (with minor modifications to protocol version/endpoints)
16:43:30 <Squarism> ...for google and facebook
16:47:29 <saylu> Squarism: Any shot at example code I could check?
16:47:41 <Squarism> saylu, lemme check
16:47:44 <saylu> That's good to know.
16:47:59 <saylu> Had some trouble earlier because the Stackage LTS version is only 0.5.7, instead of the Hackage one at 1.2.0
16:48:11 <saylu> so I switched over to 1.2.0, but my last working version was 0.5.7. 
16:48:14 <saylu> bit of a mess
16:48:51 <MarcelineVQ> that's quite a difference
16:49:23 <MarcelineVQ> ah nightly resolver does have 1.2.0 at least
16:49:43 <saylu> Yea it's quite different haha
16:49:44 <MarcelineVQ> pretty big jump to 0.5.7 in lts 8.15 though :X
16:50:02 <saylu> But the old version is the one that works OK for me! Rough times.
16:50:16 <saylu> Probably a mistake on my end -- might need to give it a night and come back fresh
16:53:37 <Squarism> saylu, http://lpaste.net/5758756248568725504 is my current version of the google auth
16:54:18 <Squarism> saylu, afaik the example program worked pretty much out of the the box - but i have vague memories of needing to do some small changes.
16:54:20 <saylu> Squarism: Have you been able to implement token refreshing?
16:54:32 <Squarism> saylu, nope
16:54:33 <saylu> I'm able to access OK so long as I never have to refresh -- that's the step that breaks
16:54:41 <Squarism> ah ok
16:54:52 <saylu> Thanks though!
17:09:48 <Squarism> saylu, what i do remember is that hoauth2 lagged quite a bit version wise / not using the latest endpoints (and transport objects) - that was the part i needed to fix. 
17:18:38 * hackage logsink 0.2.0 - A logging framework for Haskell  https://hackage.haskell.org/package/logsink-0.2.0 (SimonHengel)
17:37:13 <koala_man> how can I install the haskell platform on windows non-interactively?
17:54:32 <bigos> hi, how do i zip over two ranges?
17:55:29 <lyxia> > zip [0 ..] [3 .. 7] -- bigos
17:55:31 <lambdabot>  [(0,3),(1,4),(2,5),(3,6),(4,7)]
17:56:30 <bigos> thanks
17:56:40 <bigos> but why this zip [0..4] [4..0] doesn't work?
17:56:49 <lyxia> > [4..0]
17:56:51 <lambdabot>  []
17:57:07 <lyxia> bigos: ranges go up
17:57:12 <lyxia> > [4,3..0]
17:57:14 <lambdabot>  [4,3,2,1,0]
17:57:33 <nisstyre> > zip [0..4] (reverse [0..4])
17:57:35 <lambdabot>  [(0,4),(1,3),(2,2),(3,1),(4,0)]
17:58:32 <bigos> I get it
17:58:38 <bigos> thank you very much
17:59:11 <unknownln> Where does stack download its GHC binaries from?
18:11:57 <ZuluKing> Hello guys! Really quick question
18:12:39 <ZuluKing> How do you execute something after a forever statement? Does forever work like a while loop or a new thread?
18:16:25 <lyxia> it's a while loop
18:18:42 <lyxia> "execute" is ill defined however, there are monads for which   forever z >> y   does not ignore y
18:18:45 <pacak> @src forever
18:18:45 <lambdabot> forever a = let a' = a >> a' in a'
18:18:58 <lyxia> > runIdentity $ forever (return 3) >> return 4
18:19:00 <lambdabot>  4
18:19:21 <lyxia> > forever Proxy
18:19:23 <lambdabot>  Proxy
18:20:04 <ZuluKing> Hmm.. I guessed so.
18:20:31 <ZuluKing> I figured out I need to use forkIO if I need to run forever like an independent/separate thread
18:20:43 <ZuluKing> Is that correct?
18:21:33 <lyxia> @check (forever (return ()) >> return True :: Gen Bool)
18:21:35 <lambdabot>  +++ OK, passed 100 tests.
18:21:41 <lyxia> ZuluKing: yes
18:23:33 <ZuluKing> lyxia ok, thanks :)
18:23:50 <lyxia> there could be some variant of IO which runs independent actions in parallel, but the standard one doesn't
18:31:22 <glguy> http://hackage.haskell.org/package/async-2.1.1.1/docs/Control-Concurrent-Async.html#t:Concurrently
18:34:13 <lyxia> how wrong would it be to make it a Monad with stm + unsafePerformIO
18:34:47 <bigos> how do i flatten a nested list of tuples so i can obtain a flat list of tuples?
18:35:02 <bigos> something like that: [[(0,-1),(1,0)],[(1,0),(0,1)],[(0,1),(-1,0)],[(-1,0),(0,-1)]]
18:35:16 <glguy> > concat [[(0,-1),(1,0)],[(1,0),(0,1)],[(0,1),(-1,0)],[(-1,0),(0,-1)]]
18:35:18 <lambdabot>  [(0,-1),(1,0),(1,0),(0,1),(0,1),(-1,0),(-1,0),(0,-1)]
18:35:25 <Koterpillar> > join [[(0,-1),(1,0)],[(1,0),(0,1)],[(0,1),(-1,0)],[(-1,0),(0,-1)]]
18:35:28 <lambdabot>  [(0,-1),(1,0),(1,0),(0,1),(0,1),(-1,0),(-1,0),(0,-1)]
18:35:59 <bigos> thanks
18:36:24 <mniip> lyxia, you mean like
18:36:36 <mniip> a race condition in 'print x >> print y' ?
18:37:20 <lyxia> mniip: that's what Concurrently does
18:37:52 <Lokathor> I've got some rather complex nested tuples
18:38:01 <Lokathor> and i need to be able to update them and get new values back
18:38:10 <Lokathor> unfortunately, this sounds like a job for lenses
18:38:19 <mniip> :t _1 . _2 . _1 . _3
18:38:21 <lambdabot> (Field3 a1 b1 a3 b3, Field1 a b a1 b1, Field1 s t a2 b2, Field2 a2 b2 a b, Functor f) => (a3 -> f b3) -> s -> f t
18:38:38 <Lokathor> yeah something like that
18:38:54 <Lokathor> they're newtyped, so i guess i need to generate lenses for those newtypes and stuff as well
18:39:01 <mniip> you could always reinvent your own mini-lens if you wanted to
18:39:29 <mniip> writing lenses requires no dependency on lens
18:39:39 <glguy> Complicated nested tuples sound like a job for something other than tuples, too
18:40:06 <Lokathor> http://lpaste.net/355926 this is, unfortunately, the exactly correct code to build up one cell grid of info
18:40:23 <Lokathor> and i need the bg, fg, and that second v2 there to all be "editable"
18:40:36 <Lokathor> I've dug my own troubles this time
18:42:42 <mnoonan> so I have this case statement that implements a T -> Int function on a sum type T with 2000 cases; ghc is warning me “Pattern match checker exceeded (2000000) iterations in a case alternative”. Is this something I should be concerned about?
18:43:29 <mniip> woah
18:43:35 <Lokathor> 2000 cases you say
18:43:37 <mnoonan> I know :|
18:43:49 <mniip> Lokathor, the checker is probably quadratic
18:43:59 <Lokathor> can you like... merge any of them?
18:44:03 <Gurkenglas> Lokathor, the lenses for bg, fg and that second v2 there would look something like "_CellTriangle . each . _CellTriangle . each . _VertexEntry . _3", "_CellTriangle . each . _CellTriangle . each . _VertexEntry . _4" and "_CellTriangle . _1 . _CellTriangle . _1 . _VertexEntry . _2"
18:44:08 <mnoonan> Unsurprisingly, it’s autogenerated from a hacky swig module and a bunch of static constants
18:44:31 <mniip> mnoonan, have you considered dataToTag# ?
18:44:51 <mnoonan> Lokathor: maybe, they fall into various groups with a common prefix to the name
18:45:07 <mnoonan> mniip: I don’t know about that, what’s the idea?
18:45:12 <Lokathor> mnoonan, but they're not like, ranges of nums where you can just have a catch all and then use guards or something?
18:45:13 <mniip> you probably want an Array of Ints
18:45:19 <mniip> which you can then index with
18:45:25 <mniip> :t GHC.Prim.dataToTag#
18:45:26 <lambdabot> a -> GHC.Prim.Int#
18:45:36 <mnoonan> Lokathor: no, they represent AST node classes in a foreign api
18:46:06 <mnoonan> mniip, interesting
18:47:25 <Lokathor> Gurkenglas, I'll keep that in mind
18:48:06 <Lokathor> I can't focus too well today it seems; jiggering callbacks into the system was harder than i thought
18:49:56 <Lokathor> in the end i opted to just stuff everything into mvar and run sub-layers of the monad during the callback
19:17:31 * glguy has been playing with layouts https://glguy.net/3a0120d51b.png
19:27:18 <Lokathor> so if you run makeLenses on a newtype, it just makes a lense of the name of the newtype's constructor?
19:54:48 <Lokathor> Gurkenglas, it works!
20:15:02 <qmm> putting the following into .ghci doesn't seem to prevent the prelude from being loaded: :m -Prelude 
20:16:22 <qmm> :set -XNoImplicitPrelude did it
20:18:15 <qmm> is there a way to start ghci with a module and all of its exposed functions without needing to qualify them?
20:19:07 <qmm> :m +Foo imports the module, but i don't seem to have access to its functions or types without first qualifying them
20:20:17 <vaibhavsagar_> qmm: what about `import Foo`?
20:20:50 <qmm> ah
20:21:02 <qmm> i didn't realize you could use import in the .ghci file :)
20:33:00 <NextHendrix> why isn't 3 `(+)` 3 allowed
20:33:20 <NextHendrix> :[
20:33:35 <c_wraith> backticks only work around an identifier, not an expression
20:33:56 <c_wraith> something to do with ambiguous nesting being possible if it worked for full identifiers.  best to just dodge that.
20:34:07 <c_wraith> uh, if it worked for full expressions
20:34:42 <NextHendrix> (`isInfixOf`) "lol" "lolol" is also not allowed
20:35:23 <glguy> `isInfixOf` isn't an operator symbol, which is what the () syntax expects
20:35:48 <NextHendrix> heh
20:36:29 <NextHendrix> so much for referential transparency
20:36:59 <glguy> That's not related
20:38:44 <NextHendrix> > a `plus` b = a + b
20:38:45 <lambdabot>  <hint>:1:12: error:
20:38:45 <lambdabot>      parse error on input ‘=’
20:38:45 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
20:39:04 <NextHendrix> > let a `plus` b = a + b
20:39:06 <lambdabot>  <no location info>: error:
20:39:06 <lambdabot>      not an expression: ‘let a `plus` b = a + b’
20:40:00 <MarcelineVQ> > let a `plus` b = a + b in plus 2 3
20:40:02 <lambdabot>  5
20:41:01 <NextHendrix> well if a = b then i should be able to swap any a for any b anywhere in the Code
20:41:15 <NextHendrix> `plus` = (+)
20:41:20 <c_wraith> by value.  not necessarily by token.
20:41:24 <NextHendrix> uh
20:41:41 <c_wraith> You can't just swap in 3 + 4 for 7 in the expression 7 * 8
20:42:02 <NextHendrix> good point
20:42:26 * NextHendrix goes back to work
20:48:03 <Koterpillar> I want to test something that uses forkProcess, getExecutablePath and executeFile to make more copies of itself. Is there any chance of passing all this through hspec?
20:53:32 <vaibhavsagar_> Koterpillar: how would you test it without hspec?
20:54:18 <vaibhavsagar_> I'm picturing a test program that creates/updates a file or a counter somewhere when it is started
20:54:44 <vaibhavsagar_> and you count the number of files or the counter
20:54:46 <Koterpillar> Yes, that's what I'm going to do
20:55:07 <Koterpillar> But executeFile will start executing hspec again
20:55:58 <vaibhavsagar_> sounds like you might want to write a separate test program that tests your main program?
20:56:36 <vaibhavsagar_> and you can limit your hspec-ing to the test program
21:01:14 <Koterpillar> If I could hook beforeAll over the whole thing, I'd be fine
21:23:19 <lpaste> saylu pasted “aeson advice” at http://lpaste.net/355927
21:23:53 <saylu> Hey folks! I've got an object I'm trying to decode with Aeson and I'm getting a bit of a headache
21:24:18 <saylu> It's an object with a ton of fields, one of which is "rows". Within that field is an array of arrays -- each containing a path and a number
21:24:30 <saylu> ie. [["path", 5], ["path2", 10]]
21:24:52 <saylu> I've got no idea how to pull a `Text` out of the first index and an Int out of the second one with an Aeson parser
21:25:03 <saylu> Any advice for this?
21:28:37 <lpaste> saylu revised “aeson advice”: “aeson advice” at http://lpaste.net/355927
21:30:42 <p0a> I'm using emacs with haskell-mode but the out of the box indentation is funny, what gives?
21:31:08 <pacak> saylu: v on line 15 is a vector.
21:31:29 <pacak> To get first/second fields in x and y you simply v ! 0 and v ! 1
21:33:05 <saylu> Oh, ok!
21:33:55 <saylu> Then I'd need to parse the primitive
21:34:13 <pacak> saylu: Try to remove lines 16-18 and put a single underscore there. ghc will tell you type it expects and types of things available.
21:34:19 <pacak> Combine it with ghcid for profit.
21:39:10 <lpaste> saylu revised “aeson advice”: “aeson advice” at http://lpaste.net/355927
21:39:19 <saylu> thanks pacak
21:39:25 <saylu> This doesn't parse, but it typechecks :p
21:39:29 <saylu> so, progress
21:41:16 <pacak> saylu: At random places of parser monad try adding 
21:41:16 <pacak> error $ "parsed " ++ show x -- add this between lines 17 and 18
21:42:05 <saylu> Never hits
21:42:08 <saylu> Interesting
21:42:43 <pacak> Add more errors
21:42:48 <saylu> on it!
21:47:19 <thang1> sweet
21:47:21 <thang1> jesus
21:47:37 <lpaste> saylu revised “aeson advice”: “aeson advice” at http://lpaste.net/355927
21:47:40 <thang1> I'm finishig up chapter 13 of haskell from first principles and I finished the hangman game
21:47:59 <saylu> Oddly enough -- I get the error 'Expected 'rows', got String'
21:48:03 <saylu> which is among none of my numerous errors
21:48:15 <thang1> I refactored the code to only count incorrect guesses when considering the lose condition and it worked the first time, I didn't even have to compile twice ;-; <3
21:48:26 <saylu> and only if I use 'parse' instead of 'parseMaybe'
21:48:34 <saylu> with 'parseMaybe' I get no errors, it goes straight to 'Nothing'
21:48:40 <EvanR> makes sense
21:48:46 <EvanR> thats what parseMaybe does
21:48:52 <saylu> reasonable
21:49:03 <thang1> EvanR: does that fun in refactoring ever get old in Haskell? :p
21:49:26 * EvanR looks at "experiment 18"
21:49:32 <EvanR> :(
21:49:40 <thang1> What's experiment 18?
21:49:49 <EvanR> the experiment after 17
21:49:59 <thang1> What's experiment 17?
21:50:03 <EvanR> you know
21:50:11 <thang1> What's experiment []?
21:50:19 <EvanR> type error
21:50:21 <glguy> obviously experiment 17 is the one before 18
21:50:50 <thang1> What's experiment 0 then :p
21:50:58 * EvanR checks
21:51:00 <glguy> who said anything about an experiment 0?
21:51:22 <EvanR> i deleted it
21:51:22 <thang1> Well if we're recursing down to zero I might as well get the base case experiment and then I can unfold it to figure out what experiment 18 is
21:51:31 <glguy> nope, we aren't
21:51:39 <thang1> ಠ_ಠ well whatever
21:51:54 <thang1> What's experiment 18 then? :p
21:51:54 <EvanR> i get to the end of a refactoring and only then realize im wrong
21:52:05 <EvanR> its getting out of hand
21:52:30 <EvanR> i probably need to figure out how to make it fun
21:52:36 <thang1> Have you tried refactoring it so you don't have to worry about hands?
21:56:17 <EvanR> experiment 18 is a new programming language
21:56:40 <EvanR> with a different syntax semantics and type system
21:56:46 <thang1> oooh
21:56:55 <EvanR> thats what this has come to
21:57:15 <thang1> What are the novel aspects of the syntax and type system?
21:57:28 <EvanR> mostly off topic
21:58:02 <EvanR> i do have a custom calculus though
21:58:04 <thang1> eh. I would love to chat about it but I have some massive stuff due in 2 hours that I decided to put off and do chapter 13 in the haskell book instead
21:58:32 <EvanR> haskell has that effect
21:58:35 <thang1> But, I'd love to chat with you about it sometime (or read some docs or whatever) because I love learning about esoteric or interesting/novel programming languages and paradigms :p
22:00:44 <pacak> thang1: Esoteric programming languages - like php or java?
22:01:59 <thang1> Nah, I mostly mean esoteric in the sense that it explores some niche concept or original idea in PL theory
22:05:35 <mac10688> Hi
22:05:36 <mac10688> http://www.yesodweb.com/blog/2012/05/keter-its-alive
22:05:46 <mac10688> I'm trying to deploy my yesod webapp with keter
22:05:49 <mac10688> it talks about a hostname
22:06:07 <mac10688> is that the url that my website is associated with or is the hostname of the server?
22:06:40 <mac10688> for example, I can ssh into the linux server and type hostname and it gives me back another name that is different than my url
22:06:51 <pacak> 2012....
22:08:30 <p0a> Hey everyone, trying to write a hangman game. Here's my code http://lpaste.net/355931 the issue is that win doesn't work
22:08:55 <p0a> What I want win to do is not(find '_' (check secret guess)) but I was trying to be slick with compositions & pointfree and that didn't work out 
22:09:16 <EvanR> :t find
22:09:17 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
22:09:25 <EvanR> '_' is a Char not a function
22:09:43 <EvanR> oh, you defined your own
22:10:04 <p0a> yeah actually that find is not available for some reason. that's why I defined my own anyhow
22:10:06 <EvanR> to get better error messages, put top level type signatures on your functions
22:10:07 <kadoban> mac10688: Sounds like it's the hostname at which your website can be visited.
22:10:16 <p0a> alright let me try 
22:10:17 <mac10688> thank you kadoban 
22:11:25 <EvanR> and the compiler error message points out something i noticed from looking at the definition of check, it takes two args, but you give it zero (leaving off 1 for composition usually makes sense)
22:11:32 <EvanR> but without a type sig not sure what win is supposed to be
22:12:16 <p0a> http://lpaste.net/355932
22:12:22 <p0a> with type signatures ^ 
22:12:39 <p0a> I want to run 'win secret guess' ==> True/False
22:12:53 <EvanR> maybe you want win secret = not . find '_' . check secret ?
22:13:09 <p0a> but why can't it be pointfree for 2 arguments?
22:13:20 <EvanR> because of the type of .
22:13:23 <p0a> oh I think I get it
22:13:34 <p0a> oh it's one of those instances where to be pointfree you need to get out of your way
22:14:02 <EvanR> (f . g . h) x y = f (g (h x)) y
22:14:05 <p0a> yeah now it makes sense. in a chain of -> -> -> basically it's a -> (rest) not (rest) -> last
22:14:33 <p0a> right. thanks
22:14:44 <EvanR> (f . g .: h) x y = f (g (h x y))
22:15:03 <EvanR> but dont do that
22:15:26 <p0a> that looks weird
22:15:35 <EvanR> it is
22:15:49 <p0a> I thought : is cons. So .: is a thing on its own 
22:15:51 <p0a> not related to cons
22:15:58 <EvanR> .: is a different operator
22:16:04 <EvanR> like + and ++
22:16:08 <p0a> yeah 
22:16:13 <p0a> no I won't do it because I won't remember it 
22:16:27 <p0a> anyhow, thanks. I'll get back to it now
22:16:36 <pacak> There's package called plumbers...
22:21:03 <p0a> :t first
22:21:04 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
22:21:11 <p0a> huh that's not what I thought
22:21:24 <EvanR> :t head
22:21:25 <lambdabot> [a] -> a
22:21:27 <EvanR> :t fst
22:21:29 <lambdabot> (a, b) -> a
22:21:36 <p0a> aha, head it is
22:21:47 <EvanR> head is usually not right
22:21:56 <pacak> p0a: It's partial function. It might explode...
22:21:58 <pacak> > head []
22:22:00 <lambdabot>  *Exception: Prelude.head: empty list
22:22:05 <pacak> like this
22:22:13 <p0a> Hm... that should be ok. I'm doing c <- getLine
22:22:23 <EvanR> since it may crash. you have to have evidence (in your mind) that the list is not empty
22:22:28 <p0a> If c is empty I end the program, if not I want to use only the first letter entered 
22:22:44 <EvanR> then you should use a case expression to switch on whether its empty or not
22:22:47 <pacak> p0a: Soo... case
22:22:52 <p0a> or perhaps I should allow the user to enter multiple letters if they wish to guess the word fully
22:23:03 <p0a> I think that's better in fact
22:23:13 <EvanR> you have the evidence, but its better to let the compiler remember it
22:23:16 <p0a> well the case was going to be there anyhow to end the program 
22:23:38 <p0a> oh there's such an issue with letting the compiler know that it is indeed the case I'm not supplying [] ?
22:23:49 <pacak> p0a: It's better to end the program with "OK, see you later" than with "Prelude.head: empty list".
22:23:55 <EvanR> case line of { [] -> endProgram; (c:cs) -> now c is what head would have been }
22:24:01 <p0a> oh right yes
22:24:14 <p0a> well hold on everyone let me write it first and then criticize hehe 
22:25:13 <p0a> :t unique
22:25:15 <lambdabot> error: Variable not in scope: unique
22:25:17 <EvanR> :t nub
22:25:19 <lambdabot> Eq a => [a] -> [a]
22:25:29 <p0a> ah don't worry I don't mind re-writing some parts of the language
22:25:43 <p0a> I was just making sure it's not defined. I guess I'll do that in my ghci
22:26:02 <EvanR> let unique = nub? :)
22:26:09 <p0a> nub isn't even available 
22:26:15 <p0a> are you saying I'm a nub? :P
22:26:16 <cocreature> note that since "nub" only requires Eq it has to be O(n^2)
22:26:21 <EvanR> you mean you forgot to import it?
22:26:25 <cocreature> there is nubOrd in some package which is usually preferrable
22:27:00 <pacak> :t Set.toList . Set.fromList
22:27:01 <lambdabot> error:
22:27:02 <lambdabot>     Not in scope: ‘Set.toList’
22:27:02 <lambdabot>     Perhaps you meant one of these:
22:27:12 <pacak> :t Data.Set.toList . Data.Set.fromList
22:27:13 <lambdabot> Ord a => [a] -> [a]
22:27:28 <pacak> p0a: unique + sort
22:27:56 <EvanR> i wonder if sort then nub is better than set, both dont let you get any results until the whole list is traversed
22:28:32 <EvanR> man keeping a list sorted really solves a lot of issues
22:28:47 <pacak> Or just use Set...
22:28:52 <cocreature> nubOrd from "extra" also keeps the resulting elements ordered by their first occurence iirc
22:28:53 <kadoban> If you want results early, probably filterM with a Set
22:28:55 <c_wraith> sort then nub does nothing.
22:28:56 <EvanR> Set cant be infinite
22:29:08 <cocreature> sort then map head . group
22:29:26 <cocreature> EvanR: you can’t sort infinite lists either
22:29:34 <kadoban> EvanR: Well, if you have an infinite list with an infinite number of different values in it, nothing can save you.
22:29:36 <EvanR> if its already sorted infinite is fine
22:29:44 <EvanR> hehe
22:30:02 <cocreature> so "sort then map head . group" is better if you don’t need to sort :)
22:30:30 <EvanR> > map head . group $ [1, 1, 1, 2, 2, 3, 3, 3, 3] ++ (repeat 4)
22:30:36 <lambdabot>  mueval-core: Time limit exceeded
22:30:56 <EvanR> > map head . group $ ([1, 1, 1, 2, 2, 3, 3, 3, 3] ++ (repeat 4))
22:31:02 <lambdabot>  mueval-core: Time limit exceeded
22:31:05 <EvanR> Y U NO
22:31:43 <cocreature> > (take 4 . map head . group) ([1,1,1,2,2,3,3,3,3] ++ repeat 4)
22:31:45 <lambdabot>  [1,2,3,4]
22:31:57 <EvanR> shouldnt it output 1 anyway
22:32:03 <EvanR> oh the bot
22:32:23 <kadoban> It probably doesn't try printing until it has all the results?
22:32:26 <cocreature> > [1..]
22:32:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:32:31 <cocreature> hm
22:32:31 <kadoban> Or at least as much as will fit in output
22:32:33 <cocreature> weird
22:32:42 <MarcelineVQ> did you try it in ghci?
22:32:44 <pacak> > group $ [1, 1, 1, 2, 2, 3, 3, 3, 3] ++ (repeat 4)
22:32:44 <cocreature> ah yeah mabye it’s waiting for how much fits in output
22:32:46 <lambdabot>  [[1,1,1],[2,2],[3,3,3,3],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
22:32:57 <EvanR> works in ghci
22:33:15 <p0a> IO is harder than I thought 
22:34:08 <pacak> p0a: Nah, it's just a burrito in a category of endofunctors.
22:34:18 <EvanR> O_o
22:34:26 <MarcelineVQ> EvanR: works as in terminates, or prints as it runs?
22:34:33 <EvanR> gets to 4 and hangs
22:34:52 <EvanR> i would question my sanity if it terminated
22:35:36 <kadoban> It'd be funny if GHC were that brilliant. Hmm, is GHC allowed to do that, or would it be illegal?
22:36:07 <EvanR> is [1,2,3,4] even the right answer
22:36:37 <EvanR> maybe provable with markovs principle
22:37:01 <c_wraith> Technically, a haskell compiler is allowed to introduce transformations that make code more defined.  But in this case, you're very sensitive to the num instance in use
22:38:19 <c_wraith> Well, and the Enum instance.
22:38:30 <EvanR> its supposed to give 1:2:3:4:⟂. youres saying its allowed to do something to cause 1:2:3:4:5:⟂ ?
22:39:39 <EvanR> ignoring the Num issue
22:40:00 <c_wraith> Well, no.  But 1:2:3:4:[] is reasonable for a lot of types a
22:40:33 <p0a> well I made it work after all. I had forgotten the $ after putStrLn
22:40:40 <EvanR> isnt that kind of like last ([0..] ++ [-3]) = -3 ?
22:41:30 <c_wraith> > last ([0..] ++ [-3]) :: Int8
22:41:32 <lambdabot>  -3
22:41:44 <EvanR> confound it all!
22:41:45 <c_wraith> the choice of instance really does matter.
22:42:26 <EvanR> last time i brought up that expression, i wish someone woulda have pointed that out ;)
22:43:54 <c_wraith> you could imagine a rewrite system targeting the combination of (++) and last such that if the right-hand argument is non-empty, it never examines the left-hand argument at all
22:44:17 <EvanR> i could, but i got a lot of flak for it last time
22:44:31 <EvanR> as if it violated some kind of law
22:45:29 <c_wraith> well it's hard to work with in a rational way.  list fusion is touchy enough.
22:45:42 <EvanR> in what sense is it really the last element
22:45:46 <c_wraith> can you imagine all those sorts of ad-hoc rules?
22:45:52 <EvanR> conceptually there isnt a last element
22:46:08 <EvanR> its just a funny metaphor to say -3 is last
22:47:43 <c_wraith> depends on how you're counting.  If you're using ordinal numbers..  sure there is.  it's at index ω + 1
22:47:47 <EvanR> yet we have the long line and its path connected
22:48:55 <p0a> Hah! Did it: http://lpaste.net/355934
22:49:02 <p0a> I present to you my Hangman text game
22:49:23 <EvanR> did you know you dont have to indent then and else
22:49:28 <EvanR> it can go below the if
22:49:36 <p0a> developed past curfew
22:49:56 <c_wraith> EvanR: that actually depends on the GHC version.  Older versions - it did have to be indented.
22:49:58 <p0a> EvanR: I hate this indentation. I'm not sure what haskell-mode is doing but I have to do a lot of manual stuff 
22:49:59 <LiaoTao> p0a: Now make it read a random word from a dictionary and you're set to make some dough
22:50:24 <EvanR> 10 25 33 too many parens
22:50:33 <EvanR> 16 eta reduce
22:50:51 <EvanR> c_wraith: ah so im not crazy. i do remember it being nec
22:51:14 <EvanR> 38 too many parens
22:51:36 <p0a> I know that I was using too many parens here and ther
22:51:46 <p0a> I just didn't want to accidentally use less than enough
22:52:04 <p0a> every compilation error costs much more than parentheses keystrokes at this time of the day
22:52:32 <EvanR> luckily this isnt lisp !
22:52:50 <p0a> lol
22:54:27 <EvanR> next exercise, make a higher order function which shows the prompt, puts the input through a function to get an output message and a new prompt, then implement hangman with it
22:54:43 <EvanR> bonus points for keeping state and exiting
22:55:24 <EvanR> when its perfect, copy it so you can use it later, and wish it was in prelude
22:57:27 <halogenandtoast> p0a: for comparison here is my Hangman game in Haskell: https://github.com/halogenandtoast/hangman-haskell
22:58:17 <halogenandtoast> everything in IO is in Main.hs everything else is in Game.hs so I could switch out the UI quite easily
22:58:50 <p0a> halogenandtoast: ah, this is interesting 
22:58:55 <p0a> I see you used states too. I like that
22:59:08 <p0a> it didn't occur to m
22:59:35 <p0a> EvanR: is this what you meant?
22:59:43 <p0a> basically what halogenandtoast did?
23:00:02 <p0a> I think I might study your code tomorrow as my "next exercise"
23:00:12 <EvanR> you dont really have any state
23:00:31 <p0a> well the two arguments to hangman are the state 
23:00:39 <EvanR> oh yes, the accumulated guess
23:00:50 <EvanR> you dont change the secret so its not really stateful
23:01:00 <EvanR> but yeah
23:01:02 <p0a> I could've captured it with a helper function
23:01:32 <p0a> idk. in FP sometimes I feel awkward trying to unthink procedurally
23:02:18 <halogenandtoast> p0a: it takes time, eventually FP takes over and it becomes harder to this procedurally (imperatively?)
23:02:26 <halogenandtoast> s/this/think/
23:03:07 <EvanR> repl :: String -> s -> (String -> (String, s)) -> IO ()
23:03:57 <EvanR> hangman secret = repl "What do you guess? " blank (guts secret)
23:04:41 <p0a> what?
23:04:43 <EvanR> i guess that wouldnt really help, because you type the prompt message twice ;)
23:04:54 <p0a> did you hack my game?
23:05:09 <EvanR> just refactored to take the main loop apart
23:05:28 <EvanR> repeatedly asking for input with a message and getting a response + new state is common enough
23:05:36 <p0a> oh I see 
23:05:43 <p0a> yeah no that code definitely can be refactored 
23:06:59 <p0a> thanks for the help 
23:10:44 <saylu> by the way -- pacak: -- parsing an array already parses everything within it as a string, apparently, so doing `fmap read $ parseJSON (vector ! 0)` handles it fine. No errors.
23:10:53 <lpaste> saylu revised “aeson advice”: “aeson advice” at http://lpaste.net/355927
23:11:01 <saylu> thanks for your help pacak
23:11:24 <pacak> > read "not an int"
23:11:27 <lambdabot>  *Exception: Prelude.read: no parse
23:11:37 <pacak> saylu: ^
23:12:04 <EvanR> > read () -- not an int
23:12:06 <lambdabot>  error:
23:12:07 <lambdabot>      • Couldn't match type ‘()’ with ‘[Char]’
23:12:07 <lambdabot>        Expected type: String
23:12:15 <EvanR> > read "()" -- not an int
23:12:17 <lambdabot>  ()
23:12:35 <pacak> > read "not an int" :: Int
23:12:37 <lambdabot>  *Exception: Prelude.read: no parse
23:12:49 <pacak> EvanR: In his code he reads into Int.
23:14:01 <pacak> > (reads :: ReadS Int) "1"
23:14:03 <lambdabot>  [(1,"")]
23:14:05 <pacak> > (reads :: ReadS Int) "not an int"
23:14:07 <lambdabot>  []
23:19:59 <EvanR> is there a slick way to clamp an Integer to the bounds of Int
23:20:08 <EvanR> instead of 
23:20:14 <EvanR> > fromInteger 100000000000000000
23:20:16 <lambdabot>  100000000000000000
23:20:18 <EvanR> > fromInteger 1000000000000000000000
23:20:20 <lambdabot>  1000000000000000000000
23:20:22 <EvanR> > fromInteger 1000000000000000000000 :: Int
23:20:24 <lambdabot>  3875820019684212736
23:23:43 <MarcelineVQ> why does that result in that particular number
23:23:54 <EvanR> wrapping
23:24:06 <EvanR> > fromInteger 100000000000000000000 :: Int
23:24:08 <lambdabot>  7766279631452241920
23:24:21 <MarcelineVQ> ah hmm, did you want wrapping?
23:24:26 <EvanR> no, clamping
23:25:41 <sternmull> if you only fear overflow when reading data then you could use an explicit clamp-function.
23:26:33 <EvanR> its a conversion from Integer to Int
23:26:48 <EvanR> rather than string to int
23:28:34 <quchen> :t max (fromIntegral (minBound :: Int)) . min (fromIntegral (maxBound :: Int))
23:28:35 <lambdabot> (Num c, Ord c) => c -> c
23:28:50 <EvanR> ah
23:28:57 <quchen> > max (fromIntegral (minBound :: Int)) . min (fromIntegral (maxBound :: Int)) $ 1000
23:28:59 <lambdabot>  1000
23:29:03 <quchen> > max (fromIntegral (minBound :: Int)) . min (fromIntegral (maxBound :: Int)) $ 2^123
23:29:05 <lambdabot>  9223372036854775807
23:29:10 <quchen> > max (fromIntegral (minBound :: Int)) . min (fromIntegral (maxBound :: Int)) $ 2^1234
23:29:12 <lambdabot>  9223372036854775807
23:29:21 <quchen> > max (fromIntegral (minBound :: Int)) . min (fromIntegral (maxBound :: Int)) $ - (2^1234)
23:29:21 <EvanR> :thumbsup:
23:29:23 <lambdabot>  -9223372036854775808
23:32:52 <quchen> Turns out () is not Num!
23:32:54 <quchen> Strange.
23:33:54 <quchen> Otherwise you could clamp an Integer to () ;-)
23:33:55 <EvanR> not much of a number
23:34:06 <quchen> () is a good number!
23:34:20 <EvanR> 1 ?
23:34:43 <quchen> Or π or whatever. There is only one number, so there’s not much to tell it apart from.
23:34:48 <quchen> () + () = ()
23:34:51 <quchen> () * () = ()
23:34:52 <EvanR> i guess you cant tell, since signum () = ()
23:34:53 <quchen> - () = ()
23:35:12 <quchen> > - (1 :: Word8)
23:35:13 <lambdabot>  255
23:35:18 <EvanR> isnt a ring axiom that 0 and 1 are not the same
23:35:34 <mniip> not...really
23:35:37 <EvanR> ok
23:35:38 <quchen> I don’t think it’s an axiom, but if you have 0=1 you get the trivial ring
23:35:41 <mniip> but if 1=0 then evrything else is =0=1
23:35:44 <EvanR> its a field axiom
23:35:53 <mniip> not necessarily either
23:35:55 <mniip> but same
23:36:01 <opqdonut> https://en.wikipedia.org/wiki/Field_with_one_element
23:36:02 <opqdonut> :)
23:36:02 <mniip> if 0=1 then there's only one element
23:36:21 <EvanR> "all fields must contain at least 2 distinct elements"
23:37:28 <opqdonut> the report doesn't say Num needs to be a field
23:37:39 <EvanR> nor a ring
23:38:07 <EvanR> but a number type where the "spirit" of the value may be 0 or 1 or pi....
23:38:14 <EvanR> and thats the only value
23:38:16 <quchen> opqdonut: That would be bad, since Double isn’t a field
23:38:32 <quchen> I’m not sure whether Double is anything from Algebra even
23:38:44 <EvanR> a commutative magma !
23:38:46 <quchen> Is it commutative? I don’t know.
23:38:49 <opqdonut> :)
23:38:57 <quchen> It’s certainly not associative, so even Monoid is out.
23:39:00 <mniip> I'm pretty sure it is commutative
23:39:18 <mniip> though
23:39:22 <mniip> that depends
23:40:01 <mniip> before sse, double wasn't even a magma
23:40:07 <mniip> + wasn't an operation per se
23:40:13 <mniip> you could have a + b != a + b
23:40:25 <quchen> A magma allows that.
23:40:35 <mniip> does it
23:40:50 <quchen> Sure, a magma is just that (+) is there without any other laws
23:40:53 <EvanR> does any of these things pay any detail to the "setoid" equivalence
23:40:59 <quchen> Well, it should be total, but that’s implicit since (+) should be a function
23:41:01 <EvanR> doesnt seem so
23:41:01 <mniip> quchen, pretty sure it requires + to be a function
23:41:31 <quchen> What else would + be?
23:41:52 <mniip> x87 + doesn't distribute with equality
23:42:02 <EvanR> if + gives random results... its a probablistic function ;)
23:42:18 <quchen> s/a probabilistic/not/
23:42:26 <EvanR> a random variable
23:43:29 <mniip> in the category of random distributions
23:43:46 <mniip> I could see 'a probabilistic function' be a good candidate for an exponential object
23:45:32 <mniip> not sure how to bind 'category of random distributions' to mathematics
23:45:38 <mniip> needs some kind of generic integral
23:49:29 <EvanR> goofy.. forall r . in an instance head so i can scoped type vars later
23:49:38 <EvanR> in the instance def
23:50:15 <EvanR> is that how you normally have to do it to use proxies
23:50:59 <johnw> proxies usually need the type var to be scoped over the definition, yes
23:56:00 <nshepperd> + and * are commutative in IEEE 754
23:56:23 <nshepperd> up to "which NaN you get" anyway
