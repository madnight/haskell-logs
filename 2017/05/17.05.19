00:00:26 <_sras_> In Servant, is there an easy  way to extract path from the type of an endpoint?
00:04:26 <Axman6> _sras_: I don't know of an existing method to do it, and it;s not completely clear what that would look like in the presence of things like captures and query params
00:04:47 <Axman6> it woiuldn't be difficult to make an appropriate type family though
00:06:22 <_sras_> Axman6: I am trying to implement a HasSwagger instance for some paths, where I want to add a description to all the endpoints in it. Is there any way this could be done with out actually getting the path from the type?
00:11:30 <Axman6> yeah that feels like the wrong way to do things, but it's been a while since I played with servant-swagger stuff. I would take a look around the package and see if the thing you're after already exists in the package asd a type class, which would allow you to modify parts of produced Swagger value
00:19:21 <ph88^> hello
00:20:59 <ph88^> i have a conduit which processes Double's .. but in order to process them i need the average between the pairs of doubles first (basically  (last double - first double) / amount of doubles)   how can i split my conduit in 2 and do this calculation first and then use the outcome to continue the conduit as normal ?
00:23:46 <cocreature> ph88^: Iâ€™m not sure I understand your question. by last and first double you mean the very first double and the very last double in your stream? what do you do with the doubles in between?
00:30:56 <halogenandtoast> Anyone familiar with the Spock framework know offhand if I can get the domain for the request?
00:31:53 <ph88^> cocreature, yes i mean the very last and very first double .. with the doubles in between i just need to know that they happened (to get the total amount of doubles)
00:32:50 <ph88^> if i have 1000 doubles in stream and first double was 2 and last was 800 then i need to calculate  (800 - 2) / 1000  to get the average time between 2 doubles
00:33:02 <cocreature> ph88^: I would write a fold that computes your expected result using https://hackage.haskell.org/package/foldl-1.2.5/docs/Control-Foldl.html and then use sinkFold https://hackage.haskell.org/package/conduit-extra-0.1.6/docs/Data-Conduit-Extra-Foldl.html to turn this into a consumer
00:33:24 <ph88^> halogenandtoast, they domain should be in the request .. maybe take a look at the request data type
00:33:47 <ph88^> thanks cocreature i will take a look at those functions
00:34:55 <cocreature> ph88^: the nice thing about the foldl library is that using the Applicative instance of Fold you can trivially compose folds to get a new fold that still only requires a single traversal
00:35:09 <cocreature> in your case you want the head, last and length fold
00:36:17 <cocreature> so you get something like liftA3 (\maybeFirst maybeLast num -> liftA2 (\first last -> (first - last) / fromIntegral num) maybeFirst maybeLast) head last length
00:36:20 <halogenandtoast> ph88^: Sounds simple, but not proving so, I have no idea how to get the request data type either.
00:36:31 <halogenandtoast> Oh well, I'll spend time reading the source until I find something.
00:39:36 <cdepillabout> halogenandtoast: https://hackage.haskell.org/package/Spock-core-0.12.0.0/docs/Web-Spock-Action.html#v:request
00:39:53 <cdepillabout> This gets you the original wai Request.
00:40:01 <ph88^> cocreature, what is that maybeFirst ?
00:40:37 <cocreature> ph88^: if you take a look at the signature of the "head" fold it gives you a Maybe a because there might not be a first element
00:40:42 <halogenandtoast> cdepillabout: thanks that will probably do it.
00:41:20 <halogenandtoast> cdepillabout: How's Arow these days?
00:41:39 <Test182738> Hi
00:43:01 <cdepillabout> halogenandtoast: Doing well.  We may start on a new project for a company here in Tokyo sometime soon, so I'm really looking forward to that.
00:43:16 <cdepillabout> Oh hey, I just googled  your name and I realized who you were :-)
00:43:35 <cdepillabout> Have you been doing much Haskell lately?
00:44:01 <halogenandtoast> cdepillabout: I've been trying, I think I finally found a "good" use for a Haskell app at my job.
00:44:16 <halogenandtoast> Or basically I found an internal tool I can force us to use Haskell with
00:44:26 <cdepillabout> Oh really?? Is that the first time that Haskell will be used at cookpad?
00:44:30 <halogenandtoast> Yeah
00:44:34 <cdepillabout> nice!
00:45:08 <halogenandtoast> Basically when we buy out other companies we need to redirect their old site to Cookpad, but we want to map recipes, users, and also we want categories to hit our search
00:45:21 <halogenandtoast> so I was thinking I could make a haskell app that just takes a "map" file
00:46:00 <halogenandtoast> We could probably use a proxy server to do this, but...
00:46:29 <cdepillabout> Sounds like a nice Haskell project.
00:46:35 <halogenandtoast> exactly :D
00:46:48 <cdepillabout> Are any of your coworkers interested in Haskell? (or even functional programming?)
00:47:04 <halogenandtoast> Yeah a few, but none of them are writing any except one.
00:47:18 <ph88> still broken :/  http://ircbrowse.net/browse/haskell
00:47:19 <halogenandtoast> Thinking of starting an after hours Haskell Hack Night internally
00:47:49 <halogenandtoast> That might get more people interested
00:48:03 <halogenandtoast> One guy on the Japan side wrote this: https://github.com/taiki45/hs-vm
00:48:06 <halogenandtoast> which is pretty awesome
00:49:30 <ph88> i'm writing a small app for work to do some DSP
00:50:09 <cdepillabout> If you opened it up to outside people (like the Tokyo Haskell meetup, or the Haskell Mokumoku-kai), I bet people would go.  I know I would try to make it out.  The cookpad office is pretty awesome.
00:51:08 <halogenandtoast> cdepillabout: I'll see what I can do and reach out if I get something running.
00:51:21 <james999> how does haskell solve that problem where you have a type that can be A or B, and functions that take in that type, and then you want to add an option C to the type?
00:51:23 <halogenandtoast> It would be awesome to have more people.
00:52:24 <halogenandtoast> james999: sounds like a Sum type, usually with pattern matching.
00:52:37 <halogenandtoast> Or specifically, I tend to solve that problem with pattern matching.
00:52:47 <cdepillabout> halogenandtoast: Awesome.  I'd definitely be interested.
00:52:48 <james999> because normally you have to update each function that takes the type with a new case for possibility of C
00:53:07 <halogenandtoast> Yes, that's what you'd do james999 
00:53:23 <halogenandtoast> Add a new pattern to match against.
00:53:52 <ab9rf> i think you might need to be a bit more concrete in explaining what you're trying to accomplish
00:54:02 <james999> oh ok. i read theres a split where in OO you can easily add new types, and in functional languages you can easily add new functions.
00:54:07 <james999> and the opposite operations are hard
00:54:21 <merijn> james999: That distinction is commonly known as "the expression problem"
00:54:27 <james999> right, that
00:55:10 <mlehmk> hi
00:55:24 <Liskni_si> james999: it's worth mentioning that if you add C, you get warnings for each and every function that needs to be adapted
00:55:31 <merijn> james999: Lots of interesting things to read on that. And yes, different things are hard in OO and FP. There's several ways of doing things, but how much time/boilerplate you're willing to invest depends on how likely it is that people will want to add things
00:56:07 <james999> sure, predicting when people would want to add things is hard
00:56:20 <james999> but i presume there are scenarios where you want to make one or the other easier
00:57:08 <merijn> james999: Well, one trick you can use to make extending easier is what I like to call "OO Haskell" where you treat records as object that implement an interface
00:57:51 <merijn> james999: I'm using that approach in some benchmarks: https://github.com/merijn/broadcast-chan/blob/master/benchmarks/Channels.hs#L47-L59
00:57:59 <james999> merijn: ah ok. the visitor pattern in OO is a way of circumventing the expression problem temporarily
00:58:39 <ab9rf> merijn: i've used that, it actually reminds me of how i used to OO in plain C way back when
00:58:40 <merijn> james999: You can see further in the file how I use those records to wrap Chan, TChan, and a bunch of others to give them a single interface I can use :)
00:59:00 <merijn> ab9rf: It works really well, especially combined with RecordWildCards :)
00:59:07 <james999> ab9rf: how, make a structure of function pointers or something?
00:59:11 <ab9rf> james999: yup
00:59:26 <ab9rf> james999: which is actually how C++ does it in ternally (vtables)
00:59:42 <ab9rf> you just have to make it explicit instead of relying on language sugar to abstract it away
01:00:49 <james999> ab9rf: yeah you have more flexibility that way too to do what you want
01:01:21 <merijn> james999: Anyway, have a look at that github link, if there's anything you don't get I can explain it :)
01:01:50 <ab9rf> james999: but the price of that flexibility is that yhour code is more complicated, has lots of boilerplate, and will break if you're not disciplined
01:02:34 <ab9rf> which is why we have so many different programming languages :)
01:02:46 <james999> merijn what is this broadcastChan about?
01:02:48 <torstein> I'm not sure how to structure sequential, related HSpec tests. For example, load contents of two directories, then check that the files in the two directories have the same file names, then check that they have the same contents. http://lpaste.net/355662
01:03:41 <merijn> james999: Well, it was a simple hack to work around a problem I had with Chan, but I'm hoping to finish up some stuff and bump the version to 1.0 as strictly better version of Chan :)
01:03:43 <torstein> The structure of the test suite above is a bit awkward, since the asserts are in comments on in "it"'s
01:05:03 <ventonegro> Can't build Idris on OS X uising Stack, I get linker errors related to iconv... Anybody seen that?
01:06:47 <quchen> Seems to be an OSX-specific problem, built it with Linux yesterday
01:07:17 <ventonegro> Yeah, I can build on Linux at work
01:08:47 <merijn> I like to call this graph "TMVar performs so shit under contentation that it is making my benchmarks useless" http://files.inconsistent.nl/TMVar.png
01:08:59 <merijn> s/contentation/contention
01:09:01 <merijn> typing is hard
01:10:16 <merijn> Can I somehow make criterion split the graph into subgroups?
01:10:33 <merijn> Or I guess I should just eliminate TMVar entirely
01:12:25 <Philonous> Oh wow, I realized STM was prone to lifelock, but that's horrifying 
01:12:40 <merijn> Philonous: Well, note that the others do much better
01:12:49 <merijn> It's specifically TMVar that's *really* awful
01:12:59 <merijn> But yeah, the thunder herd is real
01:13:23 <cocreature> why does TMVar perform so much worse than TVar?
01:13:52 <Philonous> Does TVar have to retry?
01:14:12 <merijn> Yes
01:14:27 <merijn> Code is here, if there's anything you think could make it faster, lemme know: https://github.com/merijn/broadcast-chan/blob/master/benchmarks/Sync.hs
01:14:48 <quchen> TMVar a = TVar (Maybe a)
01:14:53 <merijn> Note that those are the unthreaded implementation numbers, the threaded implementation has much more variation
01:15:20 <merijn> Unfortunately, criterion is producing some NaN's for those benchmarks, which wreck the JS plotting library, so it's not producing graphs for those :\
01:15:27 <merijn> I haven't figured out how to fix that yet
01:15:56 <merijn> If someone knows how I can feed filtered CSV from criterion back into criterion to produce graphs I can make those
01:16:44 <quchen> Criterion really ought to normalize benchmark groups
01:18:21 <angerman> cocreature: I hope I can entertain you yet another day :)
01:18:35 <cocreature> angerman: :)
01:19:25 <merijn> quchen: Well, I just got the message that my changes will be merged soon-ish, so that'll at least improve the benchmarking situation for IO :)
01:19:41 <quchen> merijn: Which changes?
01:19:44 <angerman> cocreature: that's going to be an exception though. I'll try to stick with three (Tue, Wed, Thu) though.
01:20:13 <cocreature> angerman: donâ€™t let me stop you :)
01:20:35 <angerman> cocreature: lol, no. But, I need to get some work done... you know :-)
01:21:04 <merijn> quchen: https://github.com/bos/criterion/pull/136
01:21:25 <merijn> quchen: per benchmark and per batch environment setup and the ability to do cleanup after runs
01:21:25 <angerman> I usually write the drafts over the weekend. And then do minimal polish until release. That way I can work during the week :D
01:22:25 <quchen> merijn: Neat
01:25:46 <cocreature> merijn: Iâ€™m slightly confused about the benchmarks. it seems like you are testing the performance of n threads running signal followed by wait so basically a barrier. but the syncTMVar code is weird. wait tries to take out the same mvar i times
01:26:11 <cocreature> oh wait is only run once
01:26:24 <cocreature> well Iâ€™m not particularly surprised about the mvar performance then.
01:26:32 <cocreature> eh *tmvar
01:26:51 <merijn> cocreature: I'm not saying I expected it to be any good. It's honestly only in there for completeness
01:26:58 <merijn> I just didn't expect it to be *that* terrible
01:27:30 <merijn> Async actually does really well (in the threaded runtime, anyway)
01:27:42 <merijn> At the very least it's *very* consistent
01:28:56 <merijn> With 10k threads in the threaded runtime Async is *consistently* at like 1.5-3 ms range, only AtomicCounter and IORef are remotely competitive, but they tend to produce really inconsistent and funky results
01:29:18 <merijn> i.e. ranging anywhere from a few hundred microseconds to 20 or so ms
01:29:39 <merijn> And in most of the other cases Async is like, top 3, so that's what I'm using now
01:29:46 <cocreature> Iâ€™m surprised MVar is so fast
01:30:04 <merijn> Haven't really looked at the non-threaded numbers yet
01:30:24 <cocreature> does GHC do some intelligent thread scheduling for MVars?
01:30:27 <merijn> cocreature: Well...so this graph is the non-threaded numbers. In the threaded case MVar does...pretty good
01:30:50 <merijn> Like, MVar is clearly slower than Async/AtomicCounter, but *way* better than I thought
01:31:03 <merijn> The non-threaded runtime seems to have even faster MVar operations
01:31:28 <merijn> cocreature: Yes. MVar's are fair and single-wakeup, so should be *much* better under contention than STM
01:31:45 <cocreature> ah yeah then it makes sense that it performs so much better
01:36:15 <halogenandtoast> Is there a "correct" way to conver a Char to Word8?
01:36:25 <merijn> halogenandtoast: Yes. Don't
01:36:35 <halogenandtoast> for context: I'm trying to do: getDomain = BS.takeWhile (/= ':')
01:37:44 <merijn> There's 'ord', but you better only use it on ascii, or you'll be doomed for eternity
01:38:06 <halogenandtoast> I really just want to take a ByteString in the format "foo:bar" and get back "foo"
01:38:10 <Philonous> halogenandtoast, You can use the functions from Data.ByteString.Char8 
01:38:24 <Philonous> halogenandtoast, They accept chars and convert them to ASCII
01:38:28 <merijn> I propose we ban anyone who mentions that accursed module >.<
01:38:44 <cocreature> merijn: you can take Data.ByteString.Char8 from my cold dead hands
01:39:06 <merijn> cocreature: If I have to...
01:39:07 <Philonous> halogenandtoast, The correct way to do it is to convert your ByteString into Text and then you can work with chars properly
01:39:20 <halogenandtoast> fair enough, I'll do the correct way
01:40:17 <cocreature> itâ€™s not always the correct way. if you are working with some ascii protocol then converting to Text is silly
01:40:41 <Philonous> cocreature, ASCII is a subset of UTF8, so you can use decodeUTF8
01:40:58 <cocreature> Philonous: Iâ€™m not saying it doesnâ€™t work but itâ€™s completely unnecessary overhead
01:42:03 <Philonous> Well, tbh I've been naughty and using Char8 a lot myself :>. 
01:42:16 <Philonous> But using the right abstraction doesn't sound like unecessary overhead to me.
01:42:34 <cocreature> but itâ€™s not the right abstraction if youâ€™re working with ascii
01:51:29 <halogenandtoast> If I wanted to read a value form the env with a default if it does not exists, kind of like how Yesod does it, what's the best way to handle that
01:51:38 <halogenandtoast> getEnv seems to raise if it doesn't exist
01:52:04 <merijn> cocreature: That's why I need to pick up https://hackage.haskell.org/package/validated-literals again soon :p
01:52:31 <merijn> cocreature: That way you could safely convert string literals to ByteString, rather than Char8's ridiculousness
01:52:51 <cocreature> merijn: if Char8 would throw an exception instead of truncating bytes, it would already be a lot better
01:54:56 <halogenandtoast> Is wrapping it in a try the best option?
01:55:39 <cocreature> halogenandtoast: the unix package contains getEnv that returns a Maybe
01:55:50 <cocreature> I have no idea why that is in the unix package and why the one in base does not return a Maybe
01:56:02 <cocreature> ah base has lookupEnv
01:56:09 <cocreature> yeah for consistencey â€¦
01:56:20 <halogenandtoast> ah
01:56:52 <merijn> Right
01:56:59 <merijn> For fans of benchmarks
01:57:06 <merijn> Non-threaded runtime: http://files.inconsistent.nl/sync.txt
01:57:14 <merijn> threaded runtime: http://files.inconsistent.nl/sync-threaded.txt
01:57:20 <merijn> Massive differences, surprisingly
01:57:37 <merijn> hmmm
01:57:46 <merijn> Looks like the server is fucking up the encoding
01:58:00 <cocreature> is that supposed to be microseconds?
01:58:06 <merijn> yeah
01:58:20 <merijn> It's just utf-8. not sure what the server is doing
01:58:30 <cocreature> tell your server to use utf-8 :)
01:59:08 <merijn> cocreature: It's not mine
01:59:17 <merijn> cocreature: Free webspace provided by my email host
02:01:08 <LiaoTao> merijn: lpaste? :D
02:01:15 <LiaoTao> Should work for regular texts too
02:01:47 <merijn> How do I get Chrome to show me the HTTP headers?
02:02:07 <cocreature> F12 and then find the network tab
02:02:45 <merijn> Got them, looks like they don't specify a Content-Encoding header at all
02:03:12 <merijn> So the question is: Why is Chrome defaulting to non-UTF8 for unspecified encoding?
02:03:33 <cocreature> probably that is specified somewhereâ„¢
02:03:35 <cocreature> firefox does the same
02:03:43 <cocreature> merijn: can you use htaccess files?
02:03:55 <merijn> cocreature: No idea, tbh
02:04:11 <merijn> "Chrome will do auto-encoding detection " <- not very well, apparently >.>
02:06:14 <dario`> often such auto-detection only looks at the first 2^n bytes (typically 512, 1024 or 4k), so it might have missed that
02:06:55 <merijn> I'll just open a ticket and see what they say
02:07:34 <LiaoTao> merijn: "Won't fix"
02:08:10 <merijn> LiaoTao: I'm still optimistic :p
02:08:25 <LiaoTao> That is, if you get an answer at all
02:08:58 <merijn> LiaoTao: See, the beauty of actually paying for hosting is getting a support response within 24 hours :)
02:09:09 <LiaoTao> merijn: I thought you meant Chrome
02:09:13 <LiaoTao> :D
02:13:37 <mutsig_> I'm performing some profiling of a program. In my heap profile, I have a significant portion of the heap being covered by "THUNK". Is there anything meaninful I can conclude from this, since it doesn't specify any particular funciton?
02:13:43 <merijn> Anyway, back to the data. The non-threaded runtime appears to be 2 orders of magnitude faster
02:14:39 <merijn> And async performs terible in the non-threaded case
02:15:01 <merijn> It's like bottom 3 in all cases
02:16:02 <mniip> hmm
02:16:49 <mniip> what is this property called, where a function can either be strict in certain argument, or it has to ignore it overall
02:17:27 <mniip> it's not monotonicity because 'const () :: Bool -> ()' is not monotonic wrt bottoms
02:17:46 <mniip> or is it
02:18:01 <mniip> oh it is
02:18:35 <mniip> but then this statement is stronger than monotonicity
02:33:25 <merijn> The only sad thing is that to plot partial results I need the JSON files, which I didn't produce, so I have to run the benchmarks again for like 12 hours >.>
02:41:38 <Gurkenglas> mniip, all functions you can define in Haskell are monotonic
02:41:50 <mniip> that is correct
02:41:59 <Gurkenglas> mniip, bottom maps to either a minimum or a maximum in definedness
02:42:17 <mniip> but \x -> case x of () -> True; _|_ -> False
02:42:18 <Gurkenglas> oh wait no, it might map to a nonmaximum but everything larger than it maps to that as well. hm.
02:42:19 <mniip> is monotonic
02:43:50 <Gurkenglas> Why do you think "bottom maps to bottom or everything maps to the same value" has a shorter description?
02:43:51 <Philonous> mniip, I don't think True and False are comparable
02:44:28 <Philonous> mniip, That would lead to True >= False and False >= True ==> True == False 
02:44:35 <Gurkenglas> I dont think you can pattern match on undefined. Or was your point that not all monotonic functions can be defined in Haskell?
02:44:38 <mniip> Philonous, we're talking about partial order of bottoms
02:45:00 <mniip> Gurkenglas, yes, that
02:45:01 <Philonous> mniip, Yes, and the only elements of that relation are _|_ <= T for all T 
02:45:10 <mniip> Philonous, no
02:45:19 <Gurkenglas> mniip, that function you gave isnt monotonic
02:45:33 <Gurkenglas> () >= _|_, but not True >= False
02:46:01 <mniip> True <=> False
02:46:02 <mniip> no?
02:46:04 <Gurkenglas> no
02:46:08 <Philonous> What does  <=> mean?
02:46:19 <Gurkenglas> <= in both directions, I suppose.
02:46:27 <Philonous> That would imply equality
02:46:33 <Gurkenglas> Only for some relations.
02:46:45 <mniip> yeah I avoided the = symbol
02:46:51 <Gurkenglas> (For the partial order of bottoms it would though.)
02:47:06 <mniip> Gurkenglas, maybe I'm misinterpreting the "partial order of bottoms" relation?
02:47:07 <Philonous> Gurkenglas, Yes, for example partial orderings, which by definition are antisymmetric 
02:47:42 <mniip> does it only contain _|_ <= True, _|_ <= False and reflexive stuff?
02:47:48 <Gurkenglas> Yep.
02:48:20 <mniip> and for lazy data, (_|_, y) <= (x, y), but not (_|_, z) <= (x, y) ? 
02:48:40 <Gurkenglas> But also _|_ <= [_|_] and [2,_|_] <= [2,3] and [2,_|_] </=/> [_|_,2]
02:48:41 <Philonous> Unless < <= y
02:48:45 <pgiarrusso> mniip: that depends on z and y
02:48:46 <Philonous> z <= y 
02:49:01 <mniip> right
02:49:15 <pgiarrusso> Ints and all such *flat* data types are like Bool, but functions are trickier
02:49:18 <mniip> Gurkenglas, I understand [2,_|_] </=/> [_|_,2]
02:49:23 <mniip> but I thought True <=> False
02:49:37 <mniip> because they are on the same level of "definedness"
02:49:42 <Philonous> Your <=> really is == 
02:49:46 <Gurkenglas> No that would make that function you gave that cant be defined in haskell monotonic :P
02:49:56 <mniip> alright
02:50:00 <mniip> so then,
02:50:08 <mniip> are all haskell functions monotonic?
02:50:23 <Philonous> mniip, Yes, necessarily 
02:50:30 <Gurkenglas> Ive got that statement cached but dont know how to prove it
02:50:38 <mniip> are all monotonic computable functions haskell?
02:50:49 <Gurkenglas> (Probably by induction on Haskell's syntax.)
02:51:26 <pgiarrusso> mniip: that's much trickier, let's go with "no" — the keyword to google is "full abstraction" but it's high math
02:51:49 <pgiarrusso> Gurkenglas: "all functions are monotonic" is more a definition
02:52:10 <pgiarrusso> Gurkenglas: you define a model using monotonic function spaces
02:52:36 <pgiarrusso> and then you give a semantics for Haskell functions into this model
02:52:44 <merijn> Isn't the fact that all functions are monotonic the fact that gives "Fast and Loose Reasoning is Morrally Correct" it's point?
02:52:51 <Gurkenglas> pgiarrusso, or our definedness relation was defined as an extremum among those such that "all haskell functions are monotonic" is true?
02:53:31 <mniip> pgiarrusso, I am capable of high math...
02:53:36 <pgiarrusso> merijn: I think even strict functions are monotonic... so I'm not sure
02:53:48 <Gurkenglas> Sure, strict functions are monotonic.
02:53:56 <Gurkenglas> Strict functions are just those where _|_ maps to _|_
02:53:57 <pgiarrusso> mniip: no offense, was just a warning — I'd say I'm not
02:54:26 <Gurkenglas> (For nonstrict functions, monotonicity thus forbids mapping to _|_ at all)
02:54:39 <pgiarrusso> Gurkenglas: not quite
02:55:14 <_sras_> How can I set description for parameters in a Swagger schema?
02:55:18 <pgiarrusso> I think your claim might be true on flat source and target domains
02:55:27 <ertes-w> mniip: i think there is an uncountable number of monotonic computable functions, but only a countable number of haskell functions
02:55:37 <Gurkenglas> Which part? My strictness definition or the reasoning that followed?
02:55:48 <Gurkenglas> If the second one, wanna bet?
02:56:18 <Gurkenglas> ertes-w, there are countably many computable functions, for there are countably many turing machines
02:56:24 <pgiarrusso> Gurkenglas: I meant the second one — non strict functions can be partially strict
02:56:47 <mniip> ertes-w, but
02:56:58 <mniip> turing machines are countable
02:57:05 <pgiarrusso> Gurkenglas: the lambda-calculus - Turing machines isomorphism breaks down at higher orders, so I'm not sure that claim follows
02:57:16 <ertes-w> oh, right
02:57:18 <Gurkenglas> pgiarrusso, _|_ <= x for all x. Therefore f x >= f _|_ > _|_ for all monotonic f
02:58:20 <pgiarrusso> Gurkenglas: f _|_ > _|_ does not follow from f is nonstrict — that's more like "f is const (f _|_)"
02:58:23 <Gurkenglas> (given, as we said, that f is not strict in the "_|_ maps to _|_" way I mentioned)
02:59:13 <pgiarrusso> Gurkenglas: Hm... well... you might be right in fact
02:59:21 <Gurkenglas> "<pgiarrusso> Gurkenglas: I meant the second one" <- therefore you admitted the first one, which was "strict means _|_ maps to _|_"
02:59:59 <pgiarrusso> ertes-w: I think what's uncountable is unrestricted functions, and monotonicity makes things countable
03:00:28 <Gurkenglas> there are uncountably many monotonic functions
03:02:17 <pgiarrusso> Gurkenglas: OK sorry, your statement is completely right. And a function like f xs = (0:xs) is both nonstrict and non-constant
03:02:52 <pgiarrusso> the part that confused me is that "strict functions" might map bottom to bottom but still be partially lazy if they don't examine all their input (example: tail)
03:03:41 <pgiarrusso> Gurkenglas, regarding countability: what I remember better was that the domain equation D = D -> D is unsolvable by cardinality reasons for an unrestricted function spaces
03:03:46 <mniip> tail is not strict
03:03:51 <mniip> not strict in all of the input
03:03:57 <mniip> only in the topmost spine
03:04:02 <pgiarrusso> mniip, yes but tail _|_ = _|_
03:04:09 <Gurkenglas> pgiarrusso, you're thinking of functions that map all nonmaximal values to bottom
03:04:14 <mniip> 1495188215 [13:03:35] <mniip> only in the topmost spine
03:04:32 <pgiarrusso> which is why it's at least strict according to Gurkenglas definition, which I think is the standard one
03:04:51 <pgiarrusso> IIRC, restricting D -> D fixes the cardinality problems... ah but wait
03:05:05 <pgiarrusso> you need to restrict D -> D to continuous functions, need you not?
03:05:15 <pgiarrusso> Gurkenglas: do I recall correctly?
03:05:48 <pgiarrusso> (it's years since I last looked at domain theory)
03:06:01 <Gurkenglas> For the uncountability of monotonic functions: Here's an injection of f: N -> N (uncountably many values) into [()] -> [()] (montonic): g 0 = _|_; g n = replicate (f n) () ++ g (n-1)
03:06:50 <pgiarrusso> g :: Int -> [()] right?
03:06:58 <pgiarrusso> not [()] -> [()]
03:07:05 <Gurkenglas> pgiarrusso, I don't follow. (I merely remember seeing the term D -> D somewhere for some D in that context, and what continous means)
03:07:21 <Gurkenglas> Whoops, lol
03:09:33 <Gurkenglas> Okay, that makes it simpler: There are uncountably many permutations of the natural numbers, and each can be seen as a strict monotonic function on the flat naturals.
03:13:47 <Gurkenglas> mniip, here's a monotonic function that can't be defined in Haskell: f :: [()] -> (); f (repeat ()) = True; f _ = _|_
03:13:47 <Gurkenglas> mniip, I think the property that exactly describes haskell functions is "continous", which is monotonicity and limits map to limits.
03:13:47 <pgiarrusso> Gurkenglas, is that function continuous? IIUC not
03:13:47 <Gurkenglas> pgiarrusso, monotonic doesnt imply continuous
03:13:47 <pgiarrusso> sure
03:13:47 <pgiarrusso> that is
03:13:47 <pgiarrusso> I agree that monotonic does not imply continuous
03:13:47 <mniip> Gurkenglas, is that function computable
03:13:47 <mniip> ah yes, I see, this is where the church thesis breaks down
03:13:47 <Gurkenglas> mniip, no. Haskell happens to be turing complete? :P
03:13:49 <pgiarrusso> That function is neither continuous nor computable :-)
03:13:54 <pgiarrusso> also
03:14:20 <pgiarrusso> "full abstraction" is about whether all continuous functions can be written in Haskell
03:14:44 <Gurkenglas> I think no function that's not continuous is computable, if matching on a bottom crashes the turing machine.
03:15:21 <pgiarrusso> and IIRC (and don't trust me too much) already for PCF (a much simpler language) the answer is no — some continuous functions can't be written down in the language
03:15:58 <pgiarrusso> Gurkenglas: if by "crash" you mean bottom, that sounds right
03:16:56 <pacak> bottom is not necessarily crash.
03:18:02 <pacak> > length $ fix (:1)
03:18:04 <lambdabot>  error:
03:18:05 <lambdabot>      â€¢ Occurs check: cannot construct the infinite type: a0 ~ [a0]
03:18:05 <lambdabot>        Expected type: [a0] -> [a0]
03:18:15 <quchen> 1:
03:18:18 <fizruk> _sras_: Swagger does not have descriptions for parameters
03:20:05 <_sras_> fizruk: Is there anyway I can provide description to indivdual keys of a Json request?
03:20:58 <fizruk> _sras_: yes, those are object schemas and can have descriptions
03:21:41 <fizruk> _sras_: request and response bodies (and their parts) are of type Schema which has description property
03:24:03 <_sras_> fizruk: So  I can access the name property of a schema using `(((toSchema (Proxy :: Proxy Config)) ^. properties) ^.at "Name")`. I can see the result of this is a Referenced Schema. But I am not able to access description inside it..
03:25:03 <quchen> Is Richard Eisenberg here?
03:25:25 <quchen> goldfierere?
03:26:49 <fizruk> _sras_: schema ^. properties.at "name"._Inline.description
03:27:22 <fizruk> _sras_: that's assuming that property schema is inlined, not referenced
03:27:28 <_sras_> fizruk: Yes. Where is this stuff documented? 
03:27:34 <_sras_> fizruk: Yes. It is inlined.
03:28:45 <fizruk> _sras_: Referenced is a sum type, for sum types we have prisms to peak into constructors
03:29:06 <fizruk> _sras_: prisms are conventionally named just like constructors, but with a leading underscore
03:29:20 <fizruk> _sras_: so Inline constructor becomes _Inline prism
03:29:32 <tobiasBora> Hello,
03:30:17 <fizruk> _sras_: there's Lenses and prisms section in the documentation: http://hackage.haskell.org/package/swagger2-2.1.3/docs/Data-Swagger.html#g:3
03:31:30 <tobiasBora> I'd like to know, is there a library that would allow me to perform formal computation in Haskell ? I'd like to do some matrix computation on matrix that contains exp(i \theta) angles and \sqrt(2) values, and I don't want to approximate them using floating point complex number, I really want that when I do x1 = x2, then it's true if and only if x1 and x2 represents exactly the same number.
03:31:46 <fizruk> _sras_: it could probably have an extra paragraph on prisms specifically
03:37:49 <_sras_> fizruk: Yes. Thankyou for your help since yesterday...
03:37:54 <_sras_> :)
03:49:23 <merijn> I wish I'd known I should make criterion output JSON for runs that can/are killed :\
03:55:42 <merijn> Is there any documentation on how Hackage decides what file to display as readme?
03:58:39 <fizruk> _sras_: you're welcome :)
03:59:08 <fizruk> _sras_: as are contributions such as documentation improvements or that NonEmpty instance :)
04:15:42 <lyxia> merijn: how about this https://github.com/haskell/hackage-server/blob/d2008bcc9ec887c766497c77e206e62545c64bea/Distribution/Server/Packages/Readme.hs
04:22:32 <ertes-w> tobiasBora: number fields are easy enough to encode, if that's all you need
04:23:18 <ertes-w> tobiasBora: here i'm using a number field to compute the exact fibonacci formula: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs
04:24:33 <ertes-w> tobiasBora: the reflection stuff is nice-to-have, but if you hard-code the field extension, then all you need is a simple tuple type
04:24:54 <ertes-w> data NfSqrt2 a = NfSqrt2 !a !a
04:26:16 <ertes-w> (NfSqrt2 x y) represents the number x + y * sqrt 2
04:26:55 <ertes-w> in fact Data.Complex is such a special case, where (x :+ y) represents the number x + y * sqrt (-1)
04:27:46 <ertes-w> > (1 :+ 2) * (3 :+ 4) :: Complex Integer
04:27:48 <lambdabot>  error:
04:27:48 <lambdabot>      â€¢ No instance for (RealFloat Integer) arising from a use of â€˜*â€™
04:27:48 <lambdabot>      â€¢ In the expression: (1 :+ 2) * (3 :+ 4) :: Complex Integer
04:27:56 <ertes-w> well, so much for that =)
04:28:34 <_sras_> fizruk: Yes. Haven't added it yet....
04:28:57 <ertes-w> > abs (Complex 1 1)
04:28:59 <lambdabot>  error:
04:28:59 <lambdabot>      Data constructor not in scope: Complex :: Integer -> Integer -> a
04:29:04 <ertes-w> > abs (1 :+ 1)
04:29:06 <lambdabot>  1.4142135623730951 :+ 0.0
04:29:09 <ertes-w> ah, that's why
04:56:20 <quchen> Whatâ€™s the module called again that allows reserving space for bytestrings in an executable?
04:57:04 <quchen> It allows allocating a number of bytes in an executable that can then be filled later, or something along those lines.
05:00:20 <lyxia> file-embed
05:04:31 <quchen> lyxia: Spot on, thanks!
05:16:03 <kuribas> Is there a better way to do "(\l -> if null l then Nothing else Just $ foldl1 max l) $ mapMaybe f l"?
05:16:40 <merijn> :t mapMaybe
05:16:41 <lambdabot> (a -> Maybe b) -> [a] -> [b]
05:17:36 <kuribas> perhaps listToMaybe...
05:17:38 <kuribas> :t listToMaybe
05:17:39 <lambdabot> [a] -> Maybe a
05:17:49 <phadej> kuribas: foldMap with Option and Max from Data.Semigroup
05:18:00 <kuribas> :t foldMap
05:18:01 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
05:18:11 <merijn> kuribas: Yes, monoid-extras Inf
05:19:19 <phadej> that's another option (I opted for `base` variant :)
05:20:07 <phadej> yet it might be less strict, so maybe you still want to foldl'
05:21:19 <merijn> Does anyone know what kind of markup is allowed in the Description field of a cabal file?
05:21:40 <ph88> how can i make LiftA3 with <$> and <*> ?
05:21:41 <phadej> merijn: haddock
05:21:58 <phadej> ph88: liftA3 f x y z = f <$> x <*> y <*> z
05:22:32 <ph88> oki ty
05:23:59 <ph88> cocreature, i don't understand how this code deals with the Nothing case   (\maybeFirst maybeLast num -> liftA2 (\first last -> (first - last) / fromIntegral num) maybeFirst maybeLast)
05:25:33 <cocreature> ph88: it will give you back a Maybe Double that is Nothing if first or last are not present. the inner liftA2 uses the Applicative instance of Maybe
05:27:04 <ph88> how does the applicative instance of Maybe work ?
05:27:21 <cocreature> it shortcircuits on Nothing
05:27:33 <cocreature> Nothing <$> Just True
05:27:40 <cocreature> > Nothing <*> Just True
05:27:42 <lambdabot>  Nothing
05:27:53 <cocreature> > Just (+1) <*> Nothing
05:27:55 <lambdabot>  Nothing
05:28:02 <cocreature> > Just (+1) <*> Just 41
05:28:04 <lambdabot>  Just 42
05:28:05 <ph88> but now you liftA2 with a function that takes 2 arguments
05:28:13 <ph88> ok lemme try
05:28:26 <cocreature> > liftA2 (+) Nothing (Just 1)
05:28:28 <ph88> > Just (+) <$> Just 1 <*> Just 2
05:28:28 <lambdabot>  Nothing
05:28:30 <lambdabot>  error:
05:28:30 <lambdabot>      â€¢ Couldn't match expected type â€˜Integer -> Integer -> bâ€™
05:28:30 <lambdabot>                    with actual type â€˜Maybe (Integer -> Integer -> Integer)â€™
05:28:53 <cocreature> ph88: remove the first Just
05:29:03 <ph88> > (+) <$> Just 1 <*> Just 2
05:29:05 <lambdabot>  Just 3
05:29:09 <ph88> > (+) <$> Just 1 <*> Nothing
05:29:11 <lambdabot>  Nothing
05:29:51 <ventonegro> > Just (+) <*> Just 1 <*> Just 2
05:29:53 <lambdabot>  Just 3
05:30:20 <ventonegro> > Just (+) <*> Nothing <*> Just 2
05:30:22 <lambdabot>  Nothing
05:30:27 <ph88> this avoid having to do a  case  pretty nice
05:30:36 <cocreature> ph88: thatâ€™s exactly what it is for :)
05:31:07 <ph88> but why do you have to do liftA3 and liftA2 here and you can not do it in 1 lift ?
05:31:32 <ph88> oh wait i think i know
05:31:39 <ph88> the A2 is for the maybe- context ?
05:31:43 <cocreature> ph88: the liftA3 is for the applicative instance of Fold. the liftA2 is for the applicative instance of Maybe
05:31:47 <ph88> ok
05:32:58 <phadej> i'm confused, "liftA3 is for the applicative instance of Fold" ?
05:33:30 <ph88> https://hackage.haskell.org/package/foldl-1.2.5/docs/Control-Foldl.html
05:33:34 <cocreature> I should have said Fold Double
05:34:30 <cocreature> phadej: I was referring to the use of liftA3 in an example I had shown ph88 earlier
05:34:44 <phadej> ah
05:38:19 <ph88> cocreature, i can not find Data.Conduit.Extra.Foldl in the lastest version of conduit /  conduit-extra
05:39:31 <jakub> Hi, I have: data X = A | B and data Y (x :: X) = Y and I want to write a function f :: forall x. Y x -> String such that f (y :: Y A) = "ya" and f (y :: Y B) = "yb" how would I go about it?
05:39:37 <ph88> i can also not find sinkFold on hoogle
05:41:33 <ph88> jakub, maybe use Proxy .. seems you don't make a distinction on the value level only on the type level
05:42:11 <jakub> ph88: what does proxy offer that Y itself does not?
05:42:46 <ph88> jakub, the ability to match on a dummy value depending on the type
05:44:12 <ph88> data Proxy (Y A) = Proxy    let ya = Proxy (Y :: Y A)      f (Proxy :: Y A) = "ya"    
05:44:12 <jakub> ph88 but that I can do with Y, I asked because Y looks almost as synonym to Proxy to me
05:44:58 <ph88> i don't know enough about this stuff, have to step out for a moment anyway
05:45:01 <jakub> I could do: f (Y :: Y A) = "ya"
05:45:28 <merijn> cabal's description field doesn't allow heading/bold markup?
05:45:37 <jakub> but can I really write: let f :: forall x. Y x -> String; f (Y :: Y A) = "ya"; f (Y :: Y B) = "yb" ???
05:45:38 <merijn> That's annoying...
05:46:26 <pgiarrusso> jakub, what language extension is that?
05:47:27 <mutsig_> I'm currently discovering Pipes. I have a case where I need to parse a large file, and the program will die when an error occurs somwhere during parsing. However, I will need the entire result loaded into memory if the parsing is succesfull in order to act on it in multiple ways. Is `toListM` suitable for this, or am I misunderstanding pipes in some regard, since toListM is said to not be an idiomatic 
05:47:33 <mutsig_> use of pipes?
05:47:35 <jakub> pgiarrusso: I am trying to figure that out
05:47:46 <pgiarrusso> jakub, oh, seems DataKinds
05:47:48 <jakub> pgiarrusso: currently I have DataKinds KindSignatures
05:47:52 <pgiarrusso> yeah
05:47:55 <jakub> and ScopedTypeVariables
05:47:56 <merijn> mutsig_: Well, if you need to load the entire thing into memory, why bother using pipes?
05:48:08 <jakub> but the definition of "f" is not admissible under those
05:48:22 <jakub> I cannot case-split on the type
05:48:38 <kosmikus> jakub: proxy is not enough. you need a singleton type for kind X.
05:48:56 <lambdamu_> Can the Handle type from base be converted to a Ptr type suitable to be passed as FILE* argument via FFI?
05:49:31 <jakub> kosmikus: I was afraid that was the case, however I really do not understand singletons, could you walk me through it, pretty please :)
05:49:42 <pgiarrusso> agree with kosmikus — either that or using Tapeable
05:49:53 <kosmikus> jakub: no time right now, sorry. in short: data SX :: X -> * where SA :: SX A; SB :: SX B
05:50:12 <jakub> kosmikus: thank you :)
05:50:21 <kosmikus> jakub: then have your function f take an SX value to do the distinction
05:50:46 <kosmikus> jakub: I'm sure you'll find someone else around here to give you a more detailed explanation
05:51:03 <jakub> kosmikus: the only problem is that I would have to know the type to know which of the constructors to invoke
05:51:05 <pgiarrusso> jakub: singleton means that for each x :: X, SX x has a *single* value (SA or SB), so that by matching on a value of SX x you encode a match on X
05:51:19 <kosmikus> jakub: you can also combine singletons with type classes
05:51:52 <pgiarrusso> jakub: the point is that case splitting on a type variable MUST be forbidden to preserve parametricity
05:52:12 <jakub> pgiarrusso: thanks, I was always confused with "singleton = one inhabitant... proceeds to define multiple constructors... Â¯\_(ãƒ„)_/Â¯"
05:52:33 <pgiarrusso> jakub: yes, hope I clarified that 
05:52:47 <mutsig_> merijn: Because it makes sense to first parse the file and "being able to interact with IO" along the way.
05:53:10 <pgiarrusso> so, find the closest caller which *still* knows the concrete X, and pick the right value for SX there
05:53:15 <mutsig_> merijn: And also, i want to learn pipes
05:53:21 <merijn> mutsig_: Wouldn't it be easier to just load the entire file into memory and parse it in one go?
05:53:31 <sproingie> lambdamu_: i imagine the internal representation of Handles are platform-specific, so you'd probably have to see how the Handle is made and pull it apart appropriately
05:54:02 <sproingie> lambdamu_: i dunno about FILE*, but at least on unix, there'd be at least an integer fd you could fdopen
05:54:09 <pgiarrusso> jakub, you can also encode that via type classes I think (not sure the details), but the type class mechanism would just help doing a similar transformation
05:54:14 <jakub> pgiarrusso: so my data Y cannot be used to define f right? I would need to modify Y to be parametrised with the singleton instead
05:54:29 <pgiarrusso> jakub: yes, or just replace Y with the singleton
05:54:56 <jakub> pgiarrusso: actually you are right, parametrizing Y with singleton wouldnt solve anything
05:55:22 <mutsig_> merijn: Perhaps, but I thought that using pipes might be cleaner - but since I dont' know pipes yet, I might be wrong
05:55:31 <pgiarrusso> jakub: I was confused that f (Y :: Y A) = "ya" works, but that's not doing a pattern match, it just creates an f :: Y 'A -> String
05:55:45 <pgiarrusso> rather than f :: Y x -> String
05:56:01 <jakub> pgiarrusso: yeah, exactly, that was why I did not believe it could work
05:56:08 <jakub> kosmikus, pgiarrusso: thanks a lot!
05:56:09 <merijn> mutsig_: Pipes is really designed for doing constant space streaming processing. So what you propose is possible, it's just the exact opposite of what it was designed for :)
05:56:52 <mutsig_> merijn: Ok :)
05:57:38 <lambdamu_> sproingie: I just saw the unix package can convert between file descriptor and Handle, that should be enough
05:57:59 <merijn> lambdamu_: Word of warning: converting a Handle to a file descriptor *closes* the handle
05:58:23 <sproingie> but you'd still have an open fd, right?
05:58:36 <merijn> Yes
05:58:54 <ph88> jakub, maybe if you also cover the case of   Y _   
05:58:59 <merijn> You just gotta be careful that for example "handleToFd stdout" will *close* stdout and break lots of things :p
05:58:59 <mutsig_> merijn: I allways feel like parsing is most often used in combination with IO, for me at least, since most errors should kill the process with an error message. Isn't pipes the best way to accomplish this combination of a "list-like-result" and IO?
05:59:05 <sproingie> there ya go.  don't even need a pointer then, it's just a plain old int
05:59:28 <merijn> mutsig_: Depends on the kind of parsing
05:59:33 <jakub> pgiarrusso: ok so I oversimplified my original problem :)... I actually have data X = A | B X X, I have no idea what the singleton would look like for that
05:59:50 <merijn> mutsig_: for, e.g., source code I try to parse as much as possible to report as many errors are I can in one go
06:00:34 <ph88> mutsig_, i'm also processing a large file but i use conduit, i use fromList to put it into a vector
06:00:47 <lambdamu_> merijn: good to know, thanks
06:01:15 <pgiarrusso> jakub, instead of data SX :: X -> * where SA :: SX A; SB :: SX B, you want data SX :: X -> * where SA :: SX A; SB :: SX x1 -> SX x2 -> SX (B x1 x2) I think
06:02:32 <ph88> mutsig_, i think conduit helps to make things more explicit, but you can also do lazy read without conduit
06:02:52 <mutsig_> merijn, ph88: Ok, I think I'll try out pipes for now, to see where it leads. This area is where I'm the least comfortable in haskell - lazily produce listlike parse-results and error out otherwise...
06:03:46 <sproingie> you could always slurp up the file to a list with a helper then produce from the list and not the file
06:03:51 <ph88> mutsig_, that error out otherwise was not trivial to me in conduit
06:04:20 <mutsig_> ph88: So you recommend it? Haven't used that one either. Can you compare it to pipes?
06:04:54 <mutsig_> ph88: ah *not* trivial :) Missed that one
06:05:12 <pgiarrusso> jakub: to confirm that's a singleton, you can try proving (pen-and-paper) that a function like inverseSingletonMap is injective let inverseSingletonMap :: SX x -> X ; inverseSingletonMap SA = A ; inverseSingletonMap (SB x1 x2) = B (f x1) (f x2)
06:05:12 <ph88> mutsig_, i haven't used pipes but it seems easier to use, snoyberg wrote a blog post about the tradeoffs between the two
06:05:46 <ph88> mutsig_, i just mention it since for me it was not easy to do, so maybe you will have the same problem with pipes
06:07:11 <ph88> does anyone know what is the new version for this?  https://hackage.haskell.org/package/conduit-extra-0.1.6/docs/Data-Conduit-Extra-Foldl.html
06:08:03 <mutsig_> ph88: Ok, thanks. This is quite a wonky area for haskell, isn't it? I mean, bytestrings - strings - text - lazy text... Parsec, attoparsec, condouit, pipes. Would be really nice with some kind of consensus on how parsing generally should be used.
06:08:50 <sproingie> there's no real consensus in other languages either wrt parsing
06:09:03 <ph88> mutsig_, you will find the same in C with bison, yacc, lex, lemon and so on (about parsers)
06:09:28 <ph88> mutsig_, about conduit and pipes .. they try to offer abstractions that other languages don't even have.
06:09:32 <sproingie> to say nothing of packrat parser generators now
06:10:24 <ph88> mutsig_, about data types you can stay on String most of the time .. but other types are better for performance
06:10:39 <mutsig_> ph88: Yeah, I dont mean that the solutions aren't good, and often superior to possible tools in other languages. And perhaps it's just that i'm not used to parsing yet. Just feels that there's so many holes one could drop down to.
06:10:44 <ADG_> why does "fmap chr . xor `on` ord" work but "map chr . xor `on` ord" not?
06:10:58 <ph88> mutsig_, there is also an interesting post on how to handcraft parsers in haskell that outperform attoparsec even
06:11:22 <jakub> pgiarrusso: thanks a lot really, I will try doing exactly that, do you happen to know about a good reference for all of this? is this covered in some document about dependent types? is there a good source that starts from the foundations and builds up to singletons and such?
06:11:26 <sproingie> the proliferation of string types ... well, [Char] was never a very efficient thing
06:11:33 <cocreature> ph88: I think you may just need to copy the source of those functions. it looks like there is no builtin way to use conduit with the foldl library (I use pipes myself and it integrates quite well with that). luckily itâ€™s a one liner
06:11:48 <mutsig_> sproingie: exactly
06:11:59 <ph88> mutsig_, i tried re2c/lemon in C and this was also a big hole to drop down to .. even though the quality of those libraries suppose to be excellent .. it's just me i figure
06:13:03 <mutsig_> ph88: Yeah, well I guess I just have to find the right solution. But as i mentioned, this is a bit of a grey area as of now for me...
06:13:22 <ph88> cocreature, where is that extract coming from? i don't see it in the imports
06:13:23 <bartavelle> ph88: it is not hard to outperform attoparsec if you drop features, but then you get a very bare-bones parser
06:13:41 <cocreature> ph88: itâ€™s bound by the pattern match
06:13:46 <sproingie> ph88: the fact that the C solutions require a separately parsed language that generate impenetrable code ... bleh
06:14:01 <ertes-w> mutsig_: in principle consensus could be reached in some areas, but you have the NIH effect
06:14:01 <ph88> mutsig_, i find those libraries are mainly polished on the theoritical/performance side and not so much on the practical/features side
06:14:04 <sproingie> i'm always glad to have a language expressive enough to write a proper EDSL in
06:14:19 <sproingie> (or "with")
06:14:25 <ertes-w> mutsig_: i found myself reinventing libraries that already existed for minor reasons
06:14:27 <ph88> cocreature, oops ye :/
06:14:52 <ertes-w> mutsig_: and in one instance i even reinvented a library without knowing
06:15:07 <sproingie> i accidentally a parser
06:15:13 <ph88> sproingie, i did like it that lemon was able to exploit some particular gcc feature to get even more performance out of it :P
06:15:42 <mutsig_> ertes-w: Yeah, it's like a double edged sword in haskell. You have the tools to come up with good solutions, but when you do, you realise it already exist - but you didn't know before inventing it. 
06:15:42 <ph88> i still believe that if you want max performance it's easier to do in C than haskell
06:16:05 <ph88> ertes-w, what did you reinvent? circular buffers? :P
06:16:11 <sproingie> depends.  parallel performance in C is difficult.
06:16:21 <bartavelle> ph88: if you care about how fast your program can grant RCE, yeah ;)
06:16:23 <juanpaucar> use MPI o openMP for C
06:16:28 <juanpaucar> it's a breeze 
06:16:51 <ph88> bartavelle, what's RCE ?
06:16:54 <sproingie> ph88: lemon is pretty decent, sure beats bison.  i just don't like external parser generators.  errors in the grammar tend to be baffling.
06:17:02 <bartavelle> ph88: remote code execution
06:17:20 <sproingie> juanpaucar: for problems that are easily expressed with message passing, sure
06:17:31 <bartavelle> ph88: but yeah, if you are very biased towards performance, haskell isn't a great choice
06:17:54 <pgiarrusso> jakub, I don't know good sources for this... I learned it from papers (and lots of practice with Agda)
06:18:22 <jakub> pgiarrusso: I dont
06:18:30 <jakub> pgiarrusso: I dont want to bother you
06:18:32 <pgiarrusso> jakub: maybe the papers cited in https://hackage.haskell.org/package/singletons, or their references? If you're into papers
06:18:40 <bartavelle> ph88: however I found out that I could write very fast parsers in haskell (that would beat some C ones), whereas they are just horrible to write in C for like 20% speed gain ...
06:18:42 <juanpaucar> sproingie: Yup.. but if it's forced to use C to max performance in parallelism, then at least make sure that there's a framework to help with that
06:18:45 <jakub> pgiarrusso: I actually like papers
06:19:00 <ph88> sproingie, in C it's no good to do without parser generators
06:19:12 <jakub> pgiarrusso: especially FP / Cat / TT ones
06:19:45 <sproingie> ph88: oh yah i've ripped out a lot of C code in my time that was parsing by hand with strtok (or reinventing strtok)
06:19:46 <ph88> ya parsers are nice :D
06:20:00 <ph88> sproingie, i did the same in PHP .. 
06:20:08 <jakub> pgiarrusso: not that I understood many, (functional pearl: data types ala carte, programming with bananas, ...)
06:20:12 <ph88> parsers everywhere
06:20:36 <shapr> mmm, parsers
06:20:52 <sproingie> i ended up replacing it with Spirit from boost.  awful hacky syntax, but worked like a dream
06:21:01 <sproingie> replaced about 500 LOC with five
06:22:16 <sproingie> then decided it was insane for C++ to be doing any parsing and preprocessed everything to xml instead.  yeah xml, it was a stupid time.
06:23:30 <ertes-w> ph88: heh, noâ€¦  i reinvented clay, the DSL for CSS
06:24:29 <ertes-w> ph88: and since you didn't ask further, i assumed that you no longer neededâ€¦  ok, okâ€¦  i forgot =)
06:24:53 <shapr> Hi Earl
06:28:01 <mpickering> Say I have, data T = T { field = (forall a . [a]) } then is there a way to use lenses with fields like this?
06:28:25 <mpickering> It seems that makeLenses derives a getter
06:28:41 <mpickering> I want to also allow modifications which change the order of the list
06:28:53 <tobiasBora> ertes-w: Well, I also need to be able to test equalities, and since I've sqrt, complex exponential... I need to code it very carefully to have only one possible "normal form".
06:30:34 <tobiasBora> I think it's possible to handle it manually, but I hoped that it would be possible to use something that already exists
06:32:51 <ph88> ertes-w, i don't need it anymore, but i have a feeling that it will be a super useful general concept for a lot of projects !
06:32:53 <phadej> mpickering: good question. i'm not sure you can have anything lawful
06:33:54 <mpickering> I can get around it but something I hadn't thought about
06:34:23 <phadej> maybe if you have a Setter setting the "permutation"
06:34:42 <phadej> but you cannot extract it, obviously
06:39:42 <mpickering> I can defined "(forall a . [a] -> [a]) -> T -> T" but not "Functor f => (forall a . [a] -> f [a]) -> T -> f T"
06:41:59 <foo_> Hello, am wondering about a concept in Haskell (not really a Haskell-programmer here). Just 3 creates a value of type Maybe a where a is a Num, and Nothing creates a value of type Maybe a; is it possible to create a value of e.g. type Maybe Int via the data constructor Nothing?
06:42:31 <merijn> foo_: Sure, "Maybe a" means it's type "Maybe a" for all possible types 'a'
06:42:37 <merijn> :t Nothing :: Maybe Int
06:42:39 <lambdabot> Maybe Int
06:42:41 <merijn> :t Nothing :: Maybe Bool
06:42:43 <lambdabot> Maybe Bool
06:43:31 <geekosaur> (Nothing :: Maybe Int) -- type ascription
06:43:56 <phadej> mpickering: exactly, the first one is what you need to define 'Setter', latter is the Lens (which AFAICS you cannot have)
06:44:55 <mpickering> But I can also get the value out.
06:45:09 <phadej> hmm, sorry, i completely missunderstood
06:45:18 <foo_> merijn: So one can create a Maybe with a concrete type via Nothing. Is the type parameter a a phantom type in Nothing or is that something different?
06:45:31 <phadej> I think you can write something which looks like Lens' T [Natural]
06:45:42 <merijn> foo_: Personally I dislike the term "concrete type" since no one can ever agree what it means
06:45:56 <phadej> mpickering: but the laws won't hold for get and set interactions
06:45:57 <merijn> foo_: Do you know what unification means?
06:46:00 <mnoonan> All of the ghc download pages at haskell.org (e.g. https://www.haskell.org/ghc/download_ghc_8_0_2) give an internal server error (500). does anybody know what is up?
06:46:11 <mpickering> if the laws don't hold then it's pointless
06:46:15 <merijn> mnoonan: URL got changed, Google hasn't noticed
06:46:36 <phadej> mpickering: yet forall a. [a] ~ Natural
06:46:43 <merijn> mnoonan: Goto /download.html instead of /download
06:46:46 <merijn> mnoonan: i.e. https://www.haskell.org/ghc/download.html
06:46:50 <foo_> merijn: Yes. Let's say a less-generic type then instead of concrete. :)
06:47:06 <mpickering> I don't actually have [a], I have [ALens (a, a) a]
06:47:26 <phadej> well, that have more information in it!
06:48:08 <phadej> isn't ALens (a, a) a ~ Bool ?
06:48:08 <merijn> foo_: Basically if you GHC infers "Nothing :: Maybe a" and you say "Maybe Int", GHC then tries to "unify" those types (basically it computes a bunch of equations, in this case simply "a = Int" and sees if there's a contradiction
06:48:11 <mpickering> So instead it's isomorphic to [Bool] but less convenient to have that 
06:48:21 <phadej> it is :)
06:48:33 <merijn> foo_: If the equations between type variables don't conflict, then GHC is happy since there is a legal solution
06:48:39 <phadej> but can't you have Lens' T [Bool] then?
06:49:08 <merijn> If you have "Just True :: Maybe Bool" and try to write "Just True :: Maybe Int" then GHC starts unifying, reaches "Int = Bool" and goes "nuhuh"
06:49:17 <nuub> Hello. What is the maximum size of Integer in practice? Amount of memory?
06:49:23 <mpickering> That sounds quite indirect to write
06:49:26 <mpickering> I can work around it easily
06:49:31 <merijn> nuub: basically, yes
06:49:41 <byorgey> foo_: I would not call the type parameter a phantom type.  A phantom type parameter is one that is not used in *any* of the constructors.
06:49:44 <mpickering> but I want to know why GHC rejects the obvious version
06:50:44 <phadej> mpickering: because you'd need to have exists a. Lens' T [a]
06:51:12 <foo_> merijn: I see, thanks.
06:52:28 <foo_> byorgey: I assume the compiler will always try to infer the most general unifier/type for such parameters if not given?
06:52:39 <mnoonan> merijn: ah, thanks!
06:52:51 <phadej> mpickering: I run into similar situations, where needed to have a lens to extract an existential type-variable; but I aborted that, I most likely missed somehing, but didn't get types to align
06:54:05 <foo_> byorgey: e.g. Data Foo a = Bar | Baz will always construct a Foo a (for all a).
07:03:14 <ClaudiusMaximus> nuub: i think libgmp's maximum integer is 2^((2^31-1)*64)-1  (mpz_t stores a 32bit signed count of 64bit limbs); however i think ghc's integer-gmp uses lower-level functions that might have even higher limits.  in practice, available memory is the limiting factor
07:05:29 <nuub> Thanks ClaudiusMaximus 
07:06:29 <cocreature> can I link to things in packages that I donâ€™t depend on in haddock?
07:06:41 <cocreature> and to those packages themselves
07:06:42 <sproingie> every time i run stack, i have to "stty sane" to unscrew my terminal
07:06:48 <sproingie> among other things, ^D stops working
07:07:38 <lyxia> cocreature: you can
07:08:47 <lyxia> or do you mean something other than just putting an url there
07:08:51 <quchen> sproingie: Woah cool command!
07:09:06 <quchen> I usually close and reopen the terminal
07:09:20 <cocreature> lyxia: I was more hoping for something like '' but which allows me to specify the package
07:09:53 <sproingie> i think i might still have stty-insane.com
07:13:54 <quchen> cocreature: I donâ€™t thin you can do better than using fully qualified names
07:14:01 <sproingie> looks like stack isn't resetting icanon
07:14:12 <cocreature> quchen: url links it is then
07:14:48 <sproingie> stack or possibly ghc's IO system itself, but i always invoke via stack so dunno which
07:15:37 <sproingie> being that a failed stack build triggers it, ima blame stack
07:17:34 <merijn> hmm
07:17:52 <ph88> cocreature, i have this now https://bpaste.net/show/55a9f42029e7 i don't know what to do with that (Maybe Double) i already do runConduit on it .. but now i get a type error (basically it was expecting ()  )
07:21:54 <cocreature> ph88: you need to give it a source of doubles
07:22:31 <ph88> i have a source    blabla <- runStream $ src .| (readValue tcol) .| getAverageSampleInterval
07:22:52 <ph88> readValue :: MonadIO m => Int -> Conduit BSC.ByteString m Value     where Value stands in for Double
07:24:06 <cocreature> connect your source to the sink and then call runConduit
07:42:59 <mpickering> It seems that variables bound in do notation are subject to some kind of monomorphism restriction?
07:43:15 <quchen> ..?
07:43:19 <quchen> mpickering: â€¦ continue
07:43:37 <quchen> I donâ€™t know of any DMR in do-notation
07:43:54 <glguy> the variables will have a monomorphic type
07:43:55 <merijn> mpickering: let variables?
07:44:21 <mpickering> no, not let variables
07:44:22 <quchen> Doesnâ€™t the DMR apply only at the top level?
07:45:21 <merijn> Suppose I have a type Foo, what's a good naming scheme for various folds?
07:45:43 <merijn> foldMFoo, mapMFoo, etc.?
07:45:53 <merijn> The capital M feels awakward combined with the Foo
07:46:24 <merijn> Especially if you want a mapM_ variant, then you have to pick between "mapM_Foo" or "mapMFoo_" both are awkward
07:46:38 <quchen> > [ "fold" <> replicate n '\'' | n <- [0..] ]
07:46:40 <lambdabot>  ["fold","fold'","fold''","fold'''","fold''''","fold'''''","fold''''''","fold...
07:46:45 <quchen> mapM, boo! traverseFoo
07:46:56 <quchen> traverseFoo_
07:46:59 <mpickering> Define a Traversal for it and then use the lens combinators 
07:47:01 <merijn> Alternatively, I suppose I could make a special module so people can import that qualified and then simply shadow Prelude
07:47:20 <merijn> mpickering: You can't define a Traversal for it
07:47:35 <merijn> If I could I'd just make a Foldable/Traversable instance and use the names from Prelude
07:47:51 <quchen> I think aliasing Prelude is a good idea.
07:47:53 <glguy> no, the MR is not restricted to top level, also in where
07:47:59 <mpickering> Not a Traversable instance, a Traversal 
07:48:23 <quchen> glguy: Oh, is that the key difference between where and let?
07:48:28 <merijn> mpickering: I know Traversal is not Traversable, but it's still not possible
07:48:41 <merijn> mpickering: Same way you can't make a Traversal for MVar
07:48:51 <merijn> Additionally, I'm not gonna add a lens dependency
07:49:23 <glguy> no should be in let, too
07:50:26 <ph88> cocreature, i thought was the sink because i put sinkFold in there
07:52:09 <cocreature> ph88: whatâ€™s the type of "src .| readValue tcol .| getVerageSampleInterval"?
07:53:10 <ph88> cocreature, ConduitM BSC.ByteString a (StateT AdjustSampleState (ResourceT IO)) (Maybe Double)
07:53:28 <merijn> I guess I'll just steal Tekmo's "Pipes.Prelude" idea and add Foo.Prelude that shadows the ideal names from Prelude :)
07:53:36 <ph88> runStream pipe = runResourceT $ runStateT (sourceToList pipe) startAdjustSampleState
07:57:56 <merijn> Anyone know of a JSON pretty printer?
07:58:18 <cocreature> merijn: aeson-pretty
07:58:19 <Clint> merijn: like aeson-pretty?
07:58:36 <ph88> be back later
07:58:50 <merijn> I meant more like standalone tool for debugging
07:59:02 <cocreature> merijn: aeson-pretty
07:59:03 <Clint> aeson-pretty
07:59:30 <merijn> oh, it has an executable too, neat
07:59:59 <Clint> you can also do it with jq and stuff
08:00:08 <Geekingfrog> merijn for json debugging jq is pretty neat as well (it's an executable only though)
08:00:13 <clamchowder> Hello
08:00:27 <merijn> Unrelatedly: pasting several MB of json into an online form for formatting is a good way to kick AppleSpell into 100% CPU load
08:00:54 <clamchowder> A simple question: what is the use of ()?
08:01:08 <clamchowder> For example, in Control.Monad, there is a function called guard
08:01:19 <merijn> hmmm
08:01:24 <merijn> This might be too pretty for me...
08:01:28 <byorgey> clamchowder: () is the "unit type", which has only a single value (also called () )
08:01:32 <merijn> 95k line json file
08:01:40 <clamchowder> guard :: Alternative f => Bool -> f ()
08:01:40 <clamchowder> guard True      =  pure ()
08:01:40 <clamchowder> guard False     =  empty
08:01:40 <merijn> Thanks...I guess...
08:02:00 <byorgey> clamchowder: so if you have a value of type () you have no information at all.  It's similar-ish to 'void' in Java or C
08:03:11 <byorgey> clamchowder: intuitively, something of type  f ()  is like a "computation with no output"
08:03:47 <byorgey> that is, it outputs a value of type (), but since there is only one, that tells you nothing, so it might as well have no output at all
08:04:17 <clamchowder> byorgey: OK thanks. 
08:04:55 <clamchowder> byorgey: but what does guard do with pure () output?
08:05:22 <Iceland_jack> clamchowder: Succeeds
08:05:28 <byorgey> clamchowder: pure ()  is a computation which has no effects and returns ().
08:05:48 <byorgey> clamchowder: guard produces either a computation which "does nothing and succeeds" (pure ()) or a computation that "fails" (empty)
08:05:57 <byorgey> what that specifically means depends on f, but that is the general idea
08:06:24 <byorgey> > guard (3 > 2) *> Just 6
08:06:26 <lambdabot>  Just 6
08:06:32 <byorgey> > guard (3 > 6) *> Just 6
08:06:34 <lambdabot>  Nothing
08:06:52 <Iceland_jack> > Just () *> Just 6
08:06:54 <lambdabot>  Just 6
08:06:56 <Iceland_jack> > Nothing *> Just 6
08:06:58 <lambdabot>  Nothing
08:07:43 <clamchowder> byorgey, Iceland_jack: thanks.
08:09:33 <quchen> Black magic question incoming. Suppose I have a module that exports a type, but not its constructors. How can I access them anyway?
08:09:52 <glguy> quchen: th
08:09:56 <quchen> In other words, Iâ€™d like to inspect opaque data types in the least awful way.
08:09:59 <quchen> glguy: TH?
08:10:04 <quchen> How so?
08:10:33 <byorgey> quchen: I seem to recall someone publishing a package to do exactly this.
08:10:44 <clamchowder> Hackage says (*>) disgard the value of the first argument, then how come Nothing *> Just 6 produces Nothing?
08:10:46 <quchen> So do I, but thatâ€™s all I remember.
08:11:00 <quchen> I tried unsafeCoercing to an identical type once but couldnâ€™t make it work.
08:11:09 <quchen> I ventured deep into segfault land before giving up.
08:11:13 <Iceland_jack> clamchowder: It disgards the () value
08:11:20 <byorgey> clamchowder: it disregards the *output* value.  It does not disregard the effects.
08:11:23 <Iceland_jack> > Just undefined *> Just 42
08:11:25 <lambdabot>  Just 42
08:11:40 <byorgey> clamchowder: in this case the "effect" is that Nothing means the computation has failed
08:11:49 <clamchowder> :t undefined
08:11:50 <bartavelle> quchen: I suppose it doesn't implement stuff like Generic or ToJSON ?
08:11:50 <lambdabot> a
08:11:59 <lyxia> quchen: is it an instance of Generic or Data
08:12:02 <byorgey> clamchowder: have you read about Applicative?
08:12:30 <quchen> bartavelle, lyxia: Nothing of the sort, no. Iâ€™m asking generally, but my solution should work first and foremost for the Doc type of ansi-wl-pprint.
08:12:34 <clamchowder> byorgey: not much. It seems less useful to me than functor, monoid or monad
08:13:10 <byorgey> clamchowder: well, you are going to have a hard time understanding things like guard then =)
08:13:28 <byorgey> clamchowder: also, it is incredibly useful.
08:13:40 <byorgey> if it seems less useful to you, it's probably just because you don't understand it.
08:13:41 <glguy> quchen: template hask, reify
08:14:26 <clamchowder> byorgey: Yeah I don't understand it
08:14:43 <clamchowder> byorgey: I saw the definition, but can't think of any natural examples
08:15:20 <byorgey> clamchowder: there are tons of natural examples.  For starters, every Monad is also Applicative.
08:15:28 <quchen> main = putStrLn "hello" *> putStrLn "world"
08:15:33 <Iceland_jack> clamchowder: Here is an unnatural example, wanting to add the numbers in (Just 10) and (Just 40)
08:15:40 <Iceland_jack> > liftA2 (+) (Just 10) (Just 40)
08:15:42 <lambdabot>  Just 50
08:15:56 <Iceland_jack> > liftA2 (+) [10] [40]
08:15:58 <lambdabot>  [50]
08:16:11 <Iceland_jack> > liftA2 (+) (Right 10) (Left "ERROR")
08:16:13 <lambdabot>  Left "ERROR"
08:17:43 <ab9rf> writing succinct and useful code is a lot harder without Applicative.
08:18:09 <clamchowder> byorgey: yeah every monad is also applicative, but then I may as well just use monad
08:18:19 <Iceland_jack> clamchowder: there are more Applicatives
08:18:24 <ab9rf> no, you really should not just use monad
08:18:33 <ab9rf> monads have more restrictive conditions than applicatives
08:18:40 <ab9rf> there's lots of things that are applicative that aren't monads
08:20:56 <clamchowder> Iceland_jack: I suppose. But any natural examples of non-monad applicative?
08:21:09 <Iceland_jack> You keep using this word, 'natural' :)
08:21:09 <glguy> clamchowder: I have an example of using a type that only supports an Applicative instance but not a Monad in order to generate documentation from a parser https://glguy.net/config-demo
08:21:29 <Iceland_jack> Look at http://blog.functorial.com/posts/2015-12-06-Counterexamples.html
08:21:32 <ab9rf> ziplists?
08:21:35 <quchen> glguy: reify canâ€™t be used in GHCi à² _à²  how do I debug this
08:21:46 <glguy> quchen: Yes it can
08:21:50 <Iceland_jack> "An Applicative which is not a Monad"
08:21:52 <glguy> What are you trying?
08:21:59 <Iceland_jack> ZipLists, Const m
08:22:04 <quchen> runQ (reify ''Doc)
08:22:05 <quchen> Template Haskell error: Can't do `reify' in the IO monad
08:22:06 <glguy> clamchowder: In that example "SectionSpecs" is only an Applicative
08:22:09 <quchen> in GHCi
08:22:17 <glguy> quchen: Yeah, you have to do reify in Q
08:22:21 <Iceland_jack> Validation is an Either that can't be a Monad
08:22:28 <glguy> try: $(stringE . show =<< reify ''Doc)
08:22:51 <clamchowder> Iceland_jack, glguy, ab9rf, byorgey: thanks very much guys! Sorry I have to go now... I'll read the links 
08:23:04 <Iceland_jack> good luck clamchowder
08:23:04 <quchen> glguy: Ah, I see.
08:23:22 <quchen> glguy: I tried Â»fmap showÂ« but that didnâ€™t help of course.
08:23:24 <clamchowder> Iceland_jack: thanks :)
08:23:29 <glguy> quchen: this is a nicer interface to reify : http://hackage.haskell.org/package/th-abstraction
08:23:42 <glguy> quchen: It works across lots of versions of GHC so you can save the CPP effort
08:24:22 <glguy> and it normalizes out the syntax-focused nature of reify
08:24:39 <bartavelle> glguy: wow that's a nice package!
08:25:03 <ab9rf> it occurs to me that there's probably lots of applicatives that i use that are actually monads but i just don't care that they're monads :)
08:25:46 <mniip> @where pristine
08:25:46 <lambdabot> I know nothing about pristine.
08:25:49 <mniip> @where Pristine
08:25:49 <lambdabot> I know nothing about pristine.
08:25:52 <mniip> hmm
08:26:37 <mniip> there it is http://silicon.int-e.eu/lambdabot/State/Pristine.hs
08:38:26 <Tuplanolla> I just did the Haskell "if it compiles, it works" trick on a 10 k line C project.
08:38:41 <Tuplanolla> This place has clearly taught me some good habits.
08:38:48 <quchen> glguy: Is there an API function Iâ€™m overlooking to reify values, or do I have to do the plumbing myself in order to convert one from the old type to my own format?
08:39:35 <glguy> quchen: I'm not sure what you mean, you can't reify values
08:40:08 <quchen> glguy: I want to write a function Â»Foo -> BarÂ«, where I have full control of Bar, but Fooâ€™s constructors are hidden.
08:41:04 <glguy> You'll have to use Template Haskell to generate a case statement, for example, that can consume a Foo
08:42:04 <quchen> I see. Looks like I have some TH exercise ahead of me. Thanks for the help!
08:42:04 <mrkgnao> someone tell me if wanting promoted record, uh, kinds to print in a recordish fashion in GHCi is intrinsically stupid 
08:42:49 <mrkgnao> I mean, yeah, type-level record selectors obviously won't exist, but still
08:43:50 <lyxia> no it would be quite useful for type-level programming
08:44:33 <glguy> without some cleverness it would probably result it less readable types, record syntax is rather verbose to be printing inline in a larger type signature
08:45:03 <heath> anyone care to add to this? https://gist.github.com/heath/858a321b5fc96d3011d9b6ea4fca3cb9
08:45:51 <mrkgnao> that's definitely true. I almost blew GHCi up today by calling kind! on a broken type family that didn't reduce and made the buffer grow to ~5M, hah 
08:47:44 <Tuplanolla> I was going to answer, but then I realized I've never used a good dynamically typed language, heath.
08:48:05 <sproingie> clojure's pretty good
08:48:17 <Tuplanolla> Erlang would probably be nice as well.
08:48:59 <c_wraith> Erlang is nice, but it's amazingly hard to switch between Erlang and Haskell.  They use opposite conventions for lexing patterns!
08:51:12 <heath> someone messaged me this as well: """ in general, re tacl, a system that is highly reliable tend to be _less safe_ Because errors _will happen_ and they will be more catastrophic and you will be less prepared for them. """
08:51:52 <sproingie> that ... makes no sense
08:51:56 <sbrg> yeah... 
08:52:10 <sproingie> at worst it's somewhat orthogonal
08:52:40 <maerwald> yeah, you want your program to crash on an airplane on errors?
08:53:00 <sproingie> to say nothing of the general safety of planes
08:53:50 <mrkgnao> maybe the idea is that it's good to move fast and break a couple airplanes in a while if it increases overall safety /s
08:54:01 <glguy> if people get to accustomed to not dying on airplanes they might keep using them
08:54:26 <mrkgnao> but planes are safe enough already that that's stupid even assuming suspension of disbelief
08:54:39 <sproingie> they still experiment with planes.  they generally don't stick people in them when they do.
08:54:42 <mrkgnao> glguy: "avoid success at all costs"
08:55:04 <heath> this guy started out with an ML, and i know he understands the importance of type safety. i think his point was around unexpected failure similar to what is discussed at https://arxiv.org/ftp/arxiv/papers/1703/1703.10863.pdf
08:56:26 <sproingie> not impressed by the socratic dialogue in the papers
08:57:51 <sproingie> saying Y2K wouldn't have been helped by formal proofs.  i dunno what formalisms are involved in "plug in a number > 99" but there's probably something
08:59:01 <sproingie> we just need to cut those pesky humans out of the loop
09:00:09 <heath> sproingie: i thought the same thing about ariane, but the software was built to spec. the spec was incorrect though: http://se.inf.ethz.ch/~meyer/publications/computer/ariane.pdf
09:00:29 <heath> there might be something to the study of "human factors" and "system design"
09:00:46 <tobiasBora> Hello,
09:01:29 <tobiasBora> How could I use the HDBC postgresql backend to insert array ? I'm trying to play with that but I can't find a way to insert an array, since only SqlText type exists (no SqlArray type)
09:01:46 <mrkgnao> SMH: "satisfiability modulo humans"
09:01:56 <heath> :)
09:01:58 <sproingie> yah, systems have to take human factors into account.  security's a big one for example: the most secure systems are usually the ones no one wants to use
09:02:12 <EvanR> tobiasBora: arrays arent standard sql, so i would be surprised to see HDBC support it
09:02:58 <tobiasBora> I've still an error:
09:03:10 <heath> """reliability means doing what your specs says in a consistent way. it does not means doing things that are _safe_. safety is a _system level_ property"""
09:03:16 <maerwald> sproingie: why is that
09:03:20 <tobiasBora> execute: PGRES_FATAL_ERROR: ERREUR: array literal badly formated, the array must begin with...
09:03:42 <sproingie> tobiasBora: you might be looking for executeMany if you're trying to do several rows
09:03:52 <maerwald> heath: I'd say that's rather compliance, not reliabilty
09:03:59 <EvanR> sproingie: talking about an array data type
09:04:05 <EvanR> in the database
09:04:36 <sproingie> maerwald: because the more you lock things down, the more cumbersome it is to use, and the more people will circumvent it
09:04:54 <maerwald> I don't see the connection
09:05:01 <sproingie> case in point, a password policy that forces new passwords every couple weeks.  know what happens then? people write down their passwords.
09:05:43 <maerwald> ah well, I was more thinking about the technical software level
09:05:47 <sproingie> or security doors with an elaborate protocol.  people prop them open.
09:06:12 <maerwald> as in: you have two ftp server implementations, one has a higher attack surface than the other... the end user still doesn't see any difference
09:06:25 <sproingie> sure there's plenty that can protect software against itself, and more to be done there
09:06:28 <EvanR> i proped the security door open last night when the power went out, otherwise i wouldnt be able to get back in
09:06:35 <mniip> how would I bootstrap cabal with a custom installation directory??
09:10:56 <sproingie> easiest probably would be to make a symlink
09:11:22 <mniip> what
09:11:44 <sproingie> cabal looks in /usr/local and ~/.cabal and afaik those are pretty hardwired
09:12:22 <merijn> mniip: Why wouldn't you use the ~/.cabal directory?
09:12:46 <mniip> it's a chroot of sorts
09:13:06 <merijn> mniip: You can try asking in #hackage where the cabal experts hang out
09:38:30 <robertkennedy> Does anyone know if hlint has an "only errors" flag?
09:39:21 <merijn> robertkennedy: hlint never reports errors
09:39:34 <merijn> robertkennedy: It's a style hinter, not an error checker
09:39:59 <robertkennedy> In hlint's terminology "use concatMap" is an error
09:40:38 <robertkennedy> The three severity levels it has are Suggestion/Warning/Error
09:41:13 <tosun> How do I check if a `PrimTyCon` (constructor from `TyCon` from types/TyCon.lhs) is, for example, `intPrimTyCon` or `eqPrimTyCon`? I am looking at Eisenberg's Core specification from the GHC repo.
09:41:36 <tosun> When the constructors are not exported there usually are predicates, but this is not the case primitive type constructors
10:23:27 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
10:23:27 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Wed Apr 05 12:49:54 2017]
10:23:27 --- names: list (clog Faucelme_ primal GGMethos alex__ iAmerikan Swizec rkazak SkyPatrol pylbrecht Itkovian AlphaAtom muesli4 abroz connrs quinor kritzcreek drewbert takle eklavya baldrick1 gillesmajor albertus1 psychicist__ argent0 dm3_ sellout-1 Boomerang `Guest00000 t7 robertkennedy tommd Elhamer jsgrant ozgura buttbutter TheFuzzball mizu_no_oto caumeslasal robotroll LHoT10820 fragamus ralu nick8325 anodium RegEchse zariuq marr ccomb Sonolin louispan pie_ ertes sproingie)
10:23:27 --- names: list (Cerise alx741 hackebeilchen eazar001 urodna sepp2k dcoutts_ jao dcoutts psmmr thimoteus mtg NeozbiljnOzbilja cschneid_ theelous3 fizruk Sonderblade phaji coltfred ixxie Gurkenglas pavonia alfredo uglyfigurine Kreest_ tsmish crobbins lknows sternmull HarveyPwca eacameron jacereda eschnett Punisher marvin2 dsh aarvar geekg_000 meba yellowj `^_^v ChristopherBurg quobo Mon_Ouie jathan nuub fkurkowski ChaiTRex carlomagno Noldorin eSVG rcat hydraz earldouglas)
10:23:27 --- names: list (aweinstock iomonad spacecadetbrown Yuras exarkun jwbuurlage ericsagnes obadz juanpaucar fotonzade [[[[[ExTRa]]]]] earthy danthemyth xanadu comiccobe srcerer CoderPuppy cpup RayNbow`TU sdothum kaeluka asm_ Hafydd yqt kuribas paolino_ mattyw Kestrel-029 benl23 james9999 darlan alibabzo netheranthem Wuzzy jaspervdj prophile rafaelcgs10 Someguy123 eyck Natch henriksod yogsototh mmn80 nglsr acidjnk ragepandemic ed-ilyin-lv alexbiehl lep-delete thunderrd Zachoz1)
10:23:27 --- names: list (sirreal thc202 mlehmk nshepperd Wizek_ ph88 yobohohoz sampuka dalek__ vlatkoB_ SenpaiSilver CurryWurst iross filterfish_ Hunter1 _sras_ castlelore mrkgnao thang1 Xanather kaychaks danvet jluttine revprez meandi Kuros` simukis_ JoelMcCracken micmus ortmage infinity0 conal drcode twomix felixsch_ lavalike raibutera pranitbauva1997 geekosaur Stratege hexagoxel exferenceBot barrucadu mimi_vx martinga_ hucksy dfordivam lambdamu_ mkoenig brynedwards raid cmn orion)
10:23:27 --- names: list (Supersonic112 {emptyset} dmwit_ chlong amuck_ a3Dman alveric1 nakal_ posco markus1219 zv markus1209 theDon richi238 hiratara redfish64 ixian sw1nn aer[m] bb010g seequ_ rakete alaradia[m] wonko7 hiq[m] karroffel jyp[m] bobjason[m] jascot[m] zaphar_ps[m] aspiwack[m] m0rphism anderson emmanuel_erc Deewiant xinming saurik ^bschafer1 uelen KaneTW StoneToad da-x Zoddo raatiniemi armyriad taksuyu Vorpal torstein Unode tabaqui MarcelineVQ DSM permegreen oleksiyp)
10:23:27 --- names: list (whaletechno davenpcm robertc dxtr dsfox beaky prkc beerdrop bloogie _ashbreeze_ qnikst nnplv bencryption_ sdrodge jimmyrcom_ mivael abra0 Shatnerz0 paul0 Faucelme Enigmagic afldcr Tene Orion3k Younder asthasr gargawel garphy`aw ninedotnine dolio kotangen1 lenstr Neo hamishmack kantokom1 rootnode cgfbee yepo_ araujo pfoetchen Jesin kav dustinm mxf JPohlmann cjay mero Voldenet cheater SCHAPiE Qommand0r jmiven electrostat unsymbol happy0 JoshS athan cross ski)
10:23:27 --- names: list (xplat tristanp nothingnew albel727 acfoltzer acertainkind seagreen saml DataComputist MindlessDrone kwantam1 jdt andreypopp dunecat jerbome_ gcross gspia guampa owickstrom jbalint_ sigmundv_ Gabemo bdeferme noam__ wagle lispy ChongLi slackman1 eatman verement MrWoohoo andyo Durbley otto_s_ chu m1dnight1 magicman canta Zialus dunx Bashmetim reptar_ Sgeo yrid rblaze1 atk mattp_ Moyst rbocquet rom1504 nwf Derbycat jrp6 jaj oberstein bs prefork fingerzam afcondon_)
10:23:27 --- names: list (jcp___ Scorchin tg int0x27h davean nullifidian lieven ctag mgttlinger SuperTux88 nikolah peterhil Khisanth tjbp magthe lopex slomo jtobin wedens lassulus ^jud frontendloader vimalloc mjo Bigcheese solatis miklcct vikraman hanna josh5tone LeCamarade Maxdamantus Lokathor _kit_ knapptime aib shesek troydm ryantm irco grumble theorbtwo RGamma erikd sqrt2 bsmt bsermons Monoide oleks CosmicRay numberten psmolen Nik05 monty tomjaguarpaw jdnavarro hjklhjklhjkl tctara_)
10:23:27 --- names: list (mitchty jchia_1 bluepixel tortal whiteline nesqi tumdedum LnL jophish rossberg dmiles jchia pikajude niko zeroed dsantiago liste Fubar^ mikeplus64 anhduy jimmyrcom Ralith_ dfranke burp pranz4 ofdm Hithroc i-amd3 MasseR Tesseraction bydo Shatnerz quuxman c-rog monochrom niklasb xxpor Adios bsima Zowlyfon padre_angolano henrytill_ a3f_ parsnip djanatyn1 d3lxa eyen_ nurupo Guest82871 vili reinh1 julmac jameseb j_king_ betawaffle Myrl-saki Rabbit_ baroncha1lus)
10:23:27 --- names: list (nocookie192 \u joeytwiddle implementation_ mikecaruso jrm Immune_ chrissl mbrcknl darthThorik msks ClaudiusMaximus falafel jmnoz[m] nick2000 TesX[m] Naughtmare[m] pellegrino zar[m] chrzyki hakan[m] mdarse swalladge yushyin anzuof greeny nille icedev ent Akii akermu usr defanor zennist dersquisher Cthalupa Ieuan max-m x1n4u jtcs_ ambrosia huonw_ tibbe_ stefan- japesinator_ ByronJoh1son M2tias ChewieBe1rdy jix integral_ cow-orke1 jotrk_ hyPiRion_ dilinger_ raek)
10:23:27 --- names: list (Jaak_ Vq turnage_ Randy marcel bweston92 mikedlr jfokkan__ rann codedmart thoughtpolice Rumia_ mauke inr flux abbe pikhq Raptor8m3 hvr catsup __main__ shutdown_-h_now rodlogic rntz seanparsons zaltekk Axman6 AntiSpamMeta int-e lambdabot wilornel bshelden centril tsahyt stoopkid alanxoc3 HappyEnte mulk Pilfers madknight dibblego ego OnkelTem machinedgod myfreeweb Xandaros Xnuk zaquest M-wamaral _flow_ APic litchblade SuprDewd hpd_m atomi Wamanuz Tazca runde)
10:23:27 --- names: list (Sigyn tobiasBora valkyr2e aloiscochard michi7x7_ swistak35 ph88^ kolko hackage foolswoo1 seliopou qlkzy scopedTV Philonous scav akemot ljhms opios kgadek NocnaShada Blkt jle` otulp Frans-Willem ogkloo jabbslad peteretep sbauman gridaphobe spinda rlr stig Tritlo mpickering lexi-lambda mw Klumben alem0lars Argorok u-ou redcedar wenzowski MorTal1ty solidsnack simony Guest37310 LeaChim `micro statusfailed rellen cmdv kiltzman bkonkle akl tuturto g4k dmj` xacktm)
10:23:27 --- names: list (frew xplat|work heyj richi235 cchalmers QoMe jelleke bgamari Sose NinjaTrappeur noplamodo jinblack cschneid throughnothing orcus carc Nycatelos zachary12 bd_ clamchowder noxd kfish johnw dschoepe CrazedProgrammer TallerGhostWalt ysangkok electrocat Ring0` hpc tv featherlessbiped spoonm zipper gregoire SoupEvil malthe noexcept lpaste gothos ploop Tharbakim root_____ Freundlich giraffe cjwelborn hive-mind oldsk00l `0660 Fairy mrus zomg Ke blackdog SlashLife n1)
10:23:27 --- names: list (IanKelling teto navilan solution_ Nikotiini kefin kyagrd twold Logio jzelinskie feltnerm tarcwynne_ Frankablu billstclair metalrain hansihe suppi zgrepc prizim wyvern CARAM__ ericbmerritt_ cstrahan ocharles andrew__n__ FrankZappa jmct Reisen monad_cat Saizan Ford_Prefect supki Twey adelbertc bengt_ killtheliterate ahf Ornedan dgpratt avdi georgew AlainODea bjs kipd milessabin jml {AS} herre[m] hooptw poga Bengi JSharp rizary mystfox customminer stephe avn)
10:23:27 --- names: list (Heero__ grandy___ lancetw sdemos yminsky PotatoGim capicue sclv OliPicard trig-ger tazjin JCGrant[m] Yves[m] M92854[m] gkaplan[m] drasich[m] NopeMarker[m] gentam[m] noraesae ProofTechnique[m M-kevinliao Guest91110[m] tomkerk[m] colton[m] M-krsiehl moonarch rfabbri[m] ollieh jhinkle[m] mmmrrr[m] wr3n[m] jacqueline[m] ptek[m] unknownln cbHXBY1D[m] Soif[m] goodboy[m] FederalRick[m] TylerCecil[m] M-Quora MatrixTraveler[m srenatus[m] M-schmittlauch TheWizardTower)
10:23:27 --- names: list (M-Illandan hendrik[m] davidar_ M-berdario sirius[m] Magnap sudoreboot[m] korayal[m] miviotros[m] tester668[m] m4lvin[m] rdesfo[m] herzmeister[m] elwan7[m] unclechu unlmtd roadrunner168[m] curry[m] M-BostonEnginerd turt2live tfc[m] iffsid[m] Lex[m] angelbeats[m] corintho[m] riaqn davidar NickHu reactormonk[m] closures999[m] monomon[m] isacloud Aidan[m] baamonde caw akr[m] cdornan_ NemesisD bbielsa iphy rightfold texasmynsted rjungemann Meow-J bgyss hsiktas sjl_)
10:23:27 --- names: list (pchiusano Tallenz SolitaryCypher mbeidler angerman thoradam reem dogui bigs spicydonuts lukexi amatecha sa1_ Brando753-o_O_o iliastsi sivs thallada Cir0X Riviera_ Profpatsch asjo sleblanc mudfog_ Vbitz megaTherion mniip dpn` Elsi Adluc Majiir Sornaensis TimWolla karce MitchellSalad_ Liskni_si arw__ fryguybob Quintasan kiboneu lordcirth ubsan poxar epta treehaqr pierrot medical leah2 mkloczko aaron7 irclogger_com zymurgy brennie pent Tuplanolla NextHendrix)
10:23:27 --- names: list (pacak bungoman jorj cfoch-always amosbird pita swhalen SolarAquarion bod_ urdh \malex\ eikke anishathalye Benzi-Junior bitonic vikram__________ bytesighs zpconn__________ dwarders mnoonan leothrix t00m0 Amadiro bartavelle dedgrant_ coeus Atlantic777 lynn hughrawlinson wavewave glitch_hat cansis angular_mike_ shans_ edwardk tjpeden S11001001 wizonesolutions zph mkurkov_ runeks TabAtkins e sm riatre mendez amuck mitch_ jzl WarmCookie ehubinette valdyn eagleflo)
10:23:27 --- names: list (abhixec TommyC Madars shiona qz c0dehero ycheng tsani kyren tekacs glguy watersoul_ ahihi petercommand platz ipuustin jackhill ec\_ bno1 baweaver flxw bus000 DoubleDonkey alanz jlouis hanDerPeder comboy pasukon_ Rembane scinawa1 xnyhps jrslepak Boreeas_ mathu razwelle1 jstolarek caasih dbohdan xintron GreySunshine nek0 mrmenagerie cynick atle salva CuriousErnestBro LiaoTao s4msung Fylwind delYsid mgaare mudfog clever robogoat dyreshark wamaral mantovani)
10:23:27 --- names: list (Intensity dgonyeo zerokarmaleft ephemeron Ankhers bob_twinkles Guest5781 agrif sykora Jello_Raptor nerdystreetrat vfs nbouscal brixen TonL dan64 DigitalKiwi odamn lpsmith DDR ReinH coup_de_shitlord JDevlieghere yaknyasn aegray etrepum hongminh1e ryanpcmcquen gornikm_ ajmccluskey peschkaj nkpart houli Xorlev banjiewen ecobos anoe vodkaInferno ebutleriv anachrome pmade strmpnk jaargon rjeli tharper_ enolan kian Dykam kvazau nahra gpampara lattenwald si14 paf31)
10:23:27 --- names: list (zmanian____ stasku incomprehensibly aristid amiri johtso rstone_ noctux esph Veltas irishsul1an Eliel_ samgd mceier Guest24075 hpd hiptobecubic Zemyla SegFaultAX quaestor oherrala Raynes Lord_of_Life dario` suzu Purlox naudiz wting cyberlard sanjoyd chriswk fuziontech dstockwell thi_ rodarmor paroxp Chobbes prooftechnique Laney statusbot fugyk carbolymer_ aminb _cyril_ dh MitchW_ gallais_ tmciver AustinIncognito skeuchel_ Morgawr Ch3ck__ je5finge` obiwahn)
10:23:27 --- names: list (niluje reynir aidecoe joachifm besenwesen xaimus ajp chirpsalot spion fxrs dysfun hodapp abrar baetheus drdo cheshircat alpounet asm89 emerson byorgey ezyang mou logcat Jinxit meck pringlescan jxv w4and0er96 dpower rgrinberg saylu gleber_ feepo jorendorff PatrickRobotham carter ggherdov dsm__ jonrh moop mt sveit Ulrar Adeon nathanic kriton kosmikus Guest700 folsen nyuszika7h lyxia solarus madsj Athas srhb bjobjo async_prince mehs averell cic moll Maerten bbee)
10:23:27 --- names: list (Geekingfrog dpepsilon scared RevJohnnyHealey kshannon nshepperd1 emmflo Xe lachenmayer nopf bcoppens flebron discrttm benoliver999 wjm rdococ joehillen tolt carter-znc g2 Jaxan jol maerwald sbrg mikeizbicki BytesAndCoffee flobberlet Igloo lstor cods ssedov liyang_ wto froztbyte nshepperd_ spacebug worch_ c0smo_ malt3 tdammers arand mokus adraenwan vimto uwap tomku pyrtsa Chousuke brezel lukky513 nikivi owlscientist Eagle_Erwin ijp capisce EvanR keri tctara)
10:23:27 --- names: list (pdgwien so chelfi holla phz_ heath dqd jstimpfle adarqui mavihs Ranhir tolt_ Meanirelli benzrf [exa] Cathy ab9rf Bane^ tnks Gredu dixie_ hegge Deaddy wrengr acowley_away cpape ggVGc acro Robin_Jadoul jokester tych0 sshine lstrano Sam__ myme fiddlerwoaroof koala_man juri_ mk-fg grayhatter Willis heinrich5991 twk- bendricklamar hiredman Arguggi pmn chindy joeyh tgeeky _guios SaidinWoT vin-ivar staffehn sujeet HalfEatenPie timrs2998 nak_ Saimeidae_ esmiurium_ sns)
10:23:27 --- names: list (brent80_plow luis` jamiis_ Solarion tippenein armlesshobo tessier_ codebje_ CindyLinz mutsig_ intelux_ vincenz_ ess_sing stux|RC amx kriztw nemesit|znc greymalkin lokydor AtnNn mrd opqdonut catern ongy fairfieldt brisbin gsingh93 osfameron kofdog exio4 tjt n__dles stvc threshold pleiosaur QRealm charco Deadhand Taneb Forkk jgornick flout l_zzie mearnsh fergusnoble peddie yezariaely cmr nathyong ps-auxw divVerent cbaines bbaren siddhu dxld trevorriles SAL9000)
10:23:27 --- names: list (ncl28 codebam Vivek numeo ramatevish przembot buoto _6a68 mmaruseacph2 pelegreno__ rotty cjh` XMunkki xa0 dunj3 darthdeus edran dequbed kaol Baughn bxc sdx23 andreass rootmos ftop DustyDingo spaceships QuantumLogic eL_Bart0- jmaki shapr kennyp jw358 staticfox Ninja3047 louisriesener idupree bitemyapp wayne dredozubov ircbrowse kubrat nilOps kmicu strixy mak` luigy linduxed kipras hnrk_ surtn RageD aatxe runawayfive foobars eddsteel oelewapperke Biohazard)
10:23:27 --- names: list (indiffernet_ pharaun __SiCC__ briansteffens wtw datajerk vqrs 5EXAANIJ9 yarou palo luite_ o`connor_ phadej ft arkeet adamCS relrod glowcoil qmm [swift] kini Fuuzetsu ynyounuo cocreature Hijiri tswett Kneiva marens loupgaroublond hsyl20 c_wraith CGML andjjj23 p_q bind1 kml Jonno_FTW fall_ cpu1 klugez Squarism orzo tek0 Tspoon_ masquerade RazorX minad jordanlewis wz1000 sleepynate timothyh zenzike Clint tomaw davl newsham Belgarion0 gnusosa Drezil mrlase)
10:23:27 --- names: list (michalrus srk brolin_empey PHO Ewout kloeri AWizzArd bogdanteleaga kjanosz geal @ChanServ)
10:23:29 <dredozubov> ok, we have two cases
10:23:34 <dredozubov> now add another twenty
10:23:45 <EvanR> strict access control is a bitch!
10:23:56 <dredozubov> i'm arguing there are better ways of doing that
10:24:09 <EvanR> if A B C and D are all in the global environment, then the simplest case is to put them all in one record and pass it around everywhere
10:24:32 <nshepperd> class HasA m where { askA :: m A }?
10:25:00 <EvanR> thatll work if youre buried in transformers
10:25:10 <dredozubov> we've had two solutions for that problem
10:25:12 <dredozubov> https://hackage.haskell.org/package/hreader-1.1.0/docs/Control-Monad-HReader.html first one
10:25:22 <dredozubov> https://hackage.haskell.org/package/ether second one
10:25:57 <EvanR> i dont understand "it doesnt make sense to instantiate one is one of the cases"
10:26:01 <EvanR> in one
10:26:20 <EvanR> if its in the global environment
10:26:26 <dredozubov> imagine you have two similar programs
10:26:31 <dredozubov> which share a lot of code
10:27:18 <dredozubov> let's say you have two services
10:27:27 <dredozubov> one logs errors to file on file system
10:27:50 <dredozubov> the other one logs it to an external log service(awkward example, i know)
10:28:02 <dredozubov> the rest of the configuration is shared
10:28:23 <dredozubov> it doesn't make any sense to provide a API token for a log service to the first one
10:28:43 <dredozubov> and it doesn't make any sense to provide a filename to the second one
10:29:04 <EvanR> yes so you have types Prog1Env and Prog2Env which look similar
10:29:15 <cocreature> Iâ€™m not sure that example is very good. your record can just have a field of type LoggingConfig which can be a sumtype representing the different choices
10:29:19 <nshepperd> but it makes perfect sense to provide the whole program configuration
10:29:22 <EvanR> and the two programs dont expect the same reader record
10:29:39 <cocreature> or even just a "LogMsg -> IO ()" action and you capture the config implicitely
10:29:42 <nshepperd> if the first service wants to ignore the API token, that's its business?
10:29:47 <dredozubov> sure, that's a simple difference
10:29:49 <EvanR> cocreature: that doesnt sound very good actually, because if you are given the one that doesnt make sense, you crash?
10:29:58 <dredozubov> you add a type parameter and you're good to go
10:30:00 <EvanR> LogMsg -> IO () makes more sesne
10:30:11 <dredozubov> but tomorrow you'll have another one
10:30:11 <EvanR> that is what im using
10:30:20 <dredozubov> and it'll go on
10:30:25 <cocreature> EvanR: I was assuming that the LoggingConfig field decides how you log
10:30:35 <dredozubov> it makes you refactor a whole bunch of code every time you do that
10:30:46 <EvanR> well, in this example *you* wanted to decide how to log
10:30:47 <cocreature> if you use the LogMsg -> IO () you shouldnâ€™t need to refactor anything
10:31:05 <dredozubov> imagine having a constraint based resolution instead
10:31:16 <EvanR> so yeah we solved that one, but dredozubov is saying the next problem will be different yet also solved by hreader
10:31:21 <nshepperd> dredozubov: why even bother removing the api token from the context, when the file based logger already isn't using it?
10:31:34 <dredozubov> MonadReaders '[A,B,C] m => m Foo
10:31:52 <EvanR> nshepperd: because to put it there in the first place in the other program you have to instantiate it for no reason, as an object
10:32:02 <EvanR> i guess you could put undefined...
10:32:23 <dredozubov> at some point you'll want to limit the environment
10:32:24 <cocreature> I completely agree that Reader (or rather ReaderT) can make my life easier. Iâ€™m not sure if hreader actually helps over standard reader + classy lenses
10:32:30 <dredozubov> which can be done with type families
10:32:31 <EvanR> dredozubov: in my code.. i would have written A -> B -> C -> IO Foo...
10:32:40 <EvanR> which is about as long
10:33:08 <dredozubov> now imagine having 40 arguments
10:33:22 <EvanR> and you use constraint synonyms?
10:33:25 <EvanR> or what
10:33:32 <dredozubov> cocreature: sure, there are lots of similar solutions
10:34:03 <dredozubov> it happens i don't really like "just stuff it in the record" mentality
10:34:12 <dredozubov> it leads to overconstrained code
10:34:40 <dredozubov> every function that use at least some configuration suddenly depends on a bunch of other stuff
10:34:52 <nshepperd> ok, so in one case the api token doesn't exist
10:35:25 <EvanR> 40 arguments to HReader ?
10:35:30 <nshepperd> then the LogMsg -> IO () method seems superior
10:35:36 <cocreature> EvanR: the point is with Reader you only have a long type signature but if your function just passes those 40 arguments down to other functions you donâ€™t have to specify the 40 arguments every time. if you pass arguments manually you have to do that
10:35:40 <dredozubov> EvanR: constraint synonym are ok for that matter
10:36:00 <EvanR> cocreature: so... record
10:36:27 <dredozubov> EvanR: you'll get a heterogenous structure for free
10:36:44 <cocreature> EvanR: then you canâ€™t use arbitrary subsets of this record without creating a new record for each and every one of them
10:36:52 <dredozubov> you can make subsets and stuff like that pretty easy with that approach
10:37:16 <dredozubov> cocreature: exactly
10:37:17 <EvanR> cocreature: if the subsets are small, youd just use arguments. if they are huge, just pass the whole thing
10:37:32 <EvanR> im doing both in my program right now
10:37:37 <dredozubov> > if the subsets are small
10:37:39 <lambdabot>  <hint>:1:25: error:
10:37:39 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:37:40 <EvanR> because "just dont use the stuff you dont use"
10:37:44 <dredozubov> oh lambdabot
10:37:45 <cocreature> EvanR: now you are passing more information to functions then they need which means the type signature is going to tell me less about what the function can do
10:37:55 <dredozubov> if you have 3 arguments, then it doesn't matter
10:38:00 <EvanR> yeah but i need to get the job done and stop over engineering ;)
10:38:02 <dredozubov> when you have 30, you'll feel pain
10:38:24 <EvanR> kind of skeptical about 30 argument subsets of a 900 field environment
10:38:30 <EvanR> which mix and match randomly
10:38:34 <EvanR> what in the world
10:39:01 <EvanR> types can become too much
10:39:13 <centril> dredozubov: 30 arguments to a function? how the...
10:39:43 <centril> tho... I get mad even with 1 argument and put in a Reader
10:39:51 <EvanR> :|
10:40:12 <cocreature> centril: yeah Iâ€™m just too lazy to pass things around when I can let ghc do it for me :)
10:40:34 <jle`> (?implicit :: Params) => ...
10:40:34 <centril> More so in the case of State ... manually passing state is no fun
10:40:47 <dredozubov> it's simple, you rewrite less code if you use mtl and Readers
10:40:59 <EvanR> i havent had that experience
10:41:01 <dredozubov> it's all about working in polymorphic monads
10:41:14 <EvanR> when i rewrite all my code to use a Reader, its the opposite experience
10:41:15 <cocreature> jle`: thou shalt not talk about the existence of implicit parameters
10:41:28 <dredozubov> if you pass arguments explicitly... you have a lot of free time on your hands!
10:41:31 <cocreature> different people prefer different coding styles :)
10:41:36 <EvanR> when i rewrite it back because the Reader is not helping
10:41:57 <EvanR> yes not spending time making these decisions would be nice
10:41:58 <centril> cocreature: ummh... use one Reader + Env + zoom with Lens ?
10:42:13 <centril> To tank about implicit parameters is to sin.
10:42:15 <centril> talk*
10:42:28 <EvanR> i was going to mention that, glad jle` did it for me
10:42:54 <dredozubov> centril: i like that, when i have a bunch of nested readers/states
10:42:55 <jle`> it's a legitimate coding style ;_;
10:43:05 <jle`> i've been using it for years
10:43:15 <dredozubov> you zoom to the part of the structure and run another transformer
10:43:27 <centril> yep, its neat
10:43:27 <cocreature> jle`: heretic!
10:43:36 <centril> jle`: shame on you.
10:43:43 <jle`> you just need to understand the trade-offs
10:44:09 <jle`> MonadReader/Reader/reflections/etc. all have tradeoffs
10:45:24 <hexagoxel> a data-type that'd i'd normally call "tree" really becomes a DAG due to sharing. Which term (tree vs DAG) should i prefer when describing values of such a type?
10:45:46 <cocreature> jle`: sure but obviously the tradeoffs that I choose are the right ones and everyone else is wrong
10:45:54 <centril> dredozubov: tho... when you have lenses and traversals, you really dont need to zoom, you can just use  "use / using" and your traversal/lens
10:45:57 <jle`> the curse of being right
10:46:05 <dredozubov> cocreature: that's a positive way of looking at things
10:46:10 <dredozubov> i should adopt that
10:46:15 <th0br0> Currently wondering how I'd implement frame types for a protocol, e.g. (from cpp:) `enum FrameType { F1 = 0x01, F2 = 0x08, ... }` without writing the value twice for serialising/deserialising. Any pointers as to where I might look for what is a good pattern for this? 
10:46:53 <cocreature> dredozubov: it makes life a lot simpler. the only downside is that everybody hates you
10:47:09 <dredozubov> cocreature: who cares if you're right. amirite?
10:47:15 <cocreature> :)
10:47:18 <Tuplanolla> Unleash your inner Henning.
10:47:30 <cocreature> please donâ€™t
10:47:38 <centril> cocreature: thank you for putting my thoughts into words. I've always had this sensation that everything I do is just awesome.
10:47:55 <hexagoxel> @hackage multistate
10:47:55 <lambdabot> http://hackage.haskell.org/package/multistate
10:48:13 <hexagoxel> dredozubov: i have not read the whole discussion, but ^ might be relevant
10:48:17 <sbrg> th0br0: One way would be to use `data Foo = F1 | F2 .. deriving Enum` and then you can have a Map from the type to the values. this doesn't statically guarantee that you have assigned every frame type a value, though, but that could be caught using tests, or you can have the compiler warn you if you just use a function instead of a Map.
10:48:30 <hexagoxel> or you might all have already agreed that such approach is entirely ugly :D
10:48:54 <centril> "and all kinds of GHC extensions magic"
10:48:58 <centril> nice.
10:49:28 <cocreature> hexagoxel: oh btw I recently stumbled upon your butcher library. if you are fine with GHC >= 8.0 you donâ€™t need your evil monadic interface and can just use ApplicativeDo instead
10:50:55 <cocreature> hexagoxel: and optparse-applicative had a hack even before that using Arrow to provide names https://hackage.haskell.org/package/optparse-applicative-0.13.2.0/docs/Options-Applicative-Arrows.html
10:50:57 <th0br0> sbrg: thought about that and saw an approach that would make the compiler tell me if I forgot to map an enum - was just wondering whether there exists a more native way, esp. for reverse mapping (i.e. from number to type)
10:51:26 <hexagoxel> cocreature: yeah, i am aware. I did write attempt an Applicative-base interface at some point, too. There are two reasons that i stuck to the monadic version:
10:52:15 <hexagoxel> 1) ApplicativeDo still had some strange constraints to it (return $ ..) not being supported, plus kinda-confusing error messages when you mess up, although i have not checked if latest ghc versions have improved on that;
10:52:36 <cocreature> I think it doesnâ€™t support pure. return is supported iirc
10:52:38 <centril> what is wrong with  pure $ ...
10:52:46 <cocreature> which is even weirder
10:52:47 <sbrg> th0br0: if you use a Map, it is pretty simple to reverse the map. but that still doesn't get you the compile-time guarantee. I'm sure there are ways to do it with some fancy type magic
10:52:59 <hexagoxel> ah yes, i meant `pure $ ..`
10:53:03 <mbw> Hello, is it possible to define an Applicative instance for arrays that behaves like the one for ZipLists? Specifically, would "pure" have to return an infinite array...?
10:53:45 <glguy> No, you can't allocate an infinite array
10:53:59 <hexagoxel> 2) for supporting child-commands, you'd still need two "layers" instead of the one; one to gather the flags, one to define implementation/childcommands.
10:54:23 <mbw> Yeah I know that. The question is if a "zip-like" Applicative instance is possible without violating the laws.
10:54:26 <cocreature> hexagoxel: fair enough.
10:55:21 <cocreature> mbw: pure x = ZipList [x] doesnâ€™t work because of the "pure id <*> v" law
10:55:27 <th0br0> sbrg: cheers.
10:56:23 <cocreature> mbw: if you include the length of the array at the typelevel you should be able to write an instance but now you canâ€™t combine arrays with different lengths anymore (whether you want to do that depends on your application)
10:56:31 <hexagoxel> to be fair, the two-layer solution probably would still be preferable; i spend too much time considering one-layer approaches and have not bothered to do the two-layer one yet.
10:56:39 <cocreature> eh "pure id <*> v = v". I forgot the important part
10:56:45 <hexagoxel> mistake on my part that i did not consider it sooner.
10:57:10 <hexagoxel> s/spend/spent/
10:57:32 <cocreature> hexagoxel: it just felt weird that the readme talked a lot about the naming part which is mostly solved by ApplicativeDo.
10:57:52 <mbw> cocreature: If I only write expressions like (\x y z -> ...) <$> mx <*> my <*> mz, and not pure (\x y ....) <*> mx ..., I should be able to half-ass it and leave pure undefined.
10:58:25 <nshepperd> fixed size vectors have a zippy applicative instance. they're even monads
10:58:29 <mbw> Which is not a law-abiding applicative instance
10:58:37 <cocreature> mbw: sure but then you donâ€™t really have an Applicative instance :)
10:59:03 <cocreature> mbw: you should be able to make an instance of Apply which is Applicative without pure https://hackage.haskell.org/package/semigroupoids-5.2/docs/Data-Functor-Bind.html#t:Apply
10:59:03 <mbw> It would be ideal if you could generalize Control.Monad.Zip to mzipWith3/4/... etc.
10:59:17 <mbw> Oh, that sounds interesting.
10:59:31 <cocreature> nobody really uses it afaik but it exists
11:00:53 <nshepperd> you could also extend your array type with an additional point. data ZipArray a = Pure a | Array (Vector a)
11:01:08 <nshepperd> and do the obvious thing when combining
11:01:40 <cocreature> huh, would that really be lawful?
11:01:43 <cocreature> it seems weird
11:02:15 <mbw> If I used Vector instead of Array, I don't think I would have to reinvent the wheel in the first place.
11:03:04 <mbw> It's probably best to just stick with array/accumArray, since these functions are more or less omnipotent...
11:03:11 <cocreature> hm seems like the laws hold
11:03:17 <nshepperd> cocreature: yeah, it's basically adjoining a value for each constant infinite list
11:03:19 <jle`> hm yeah
11:03:30 <nshepperd> Array or Vector, whatever
11:03:41 <jle`> for data Pure f a = Pure a | Other (f a)
11:03:51 <jle`> you have instance Apply f => Applicative (Pure f)
11:04:04 <jle`> er
11:04:15 <jle`> for data Lift f a = Pure a | Other (f a), you have Apply f => Applicative (Lift f)
11:04:29 <jle`> i suppose it's similar `Semigroup m => Monoid (Maybe m)`
11:04:31 <mbw> I need to use higher-dimensional arrays, so the difference does matter. (And a Vector of Vectors of Vectors of ... is just not the same.)
11:05:41 <jle`> interestingly enough, the Applicative instance for 'Lift' irl has an Applicative constraint since Apply isn't well used
11:05:41 <nshepperd> well, I think it works for higher dimension arrays too
11:05:54 <jle`> just like how the Monoid instance for 'Maybe' irl has a Monoid constraint since Semigroup isn't well-used
11:06:07 <mbw> Also, Haskell's Arrays are way underrated. I really came to like them :)
11:06:18 <nshepperd> except Pure represents I guess an infinite... hyper.. half-plane instead of an infinite list
11:07:03 <mbw> This might become complicated quickly.
11:07:15 <jle`> the last time i used Array was ... before I knew about Vector
11:08:53 <jle`> by the way, consider that the `f <$> xs <*> ys <*> zs` style of zipping arrays might not be as performant as just using array + indexing
11:09:06 <jle`> unless you can somehow defer the allocation of the intermediate arrays
11:09:20 <shapr> jle`: is there a blog post describing the benefits of vector over array?
11:10:12 <mbw> Yeah but seriously, I have tried my way with all the major array libraries. Sure, for the one-dimensional case, Vector's got you covered. On the other hand, Repa and Accelerate are unwieldy. And clunky. Indexing via snoc-lists, reduced type-inference, etc. This doesn't help if you want to "quickly try something out". On the other hand, if you get to know arrays, there API is not so bad. It may be helpful to 
11:10:18 <mbw> also have some experience in an imperative language, though.
11:10:53 <jle`> shapr: api is a little more fully featured/user friendly
11:10:55 <shapr> mbw: you prefer Array for multidimensional?
11:11:03 <jle`> but also i'm not sure if array has any fusion
11:11:08 <nshepperd> ofc whether this is useful to you depends on what else you intend to do with the arrays... you can implement most of the array api for ZipArray, but (\\) won't work / will be partial
11:11:21 <mbw> jle`: Btw, I have not really considered the problem with intermediaries. On the other hand, it wouldn't work for Unboxed Arrays anyway.
11:12:07 <cocreature> the fact that vector-algorithms is a thing while array-algorithms isnâ€™t, can also often be a deciding factor
11:12:10 <jle`>  i can't find any mention of stream fusion in the docs for arrays
11:12:16 <mbw> shapr: I really tried to come to like Repa/Accelerate. I really tried... Also, if you have anything not "inherently parallel", what are you gonna do?
11:12:22 <cocreature> Iâ€™m not going to implement tim sort myself
11:13:02 <EvanR> you got your Data-IVar, you got your ivar-simple, you got your data-ivar...
11:13:04 <shapr> mbw: I really want to read your blog post or whatever about this, I don't think I have all the context
11:13:06 <mbw> jle`: I don't think they have that. Looking through the source, there are some rewrite rules for the second Functor law and stuff like that, but I think that's it
11:13:21 <jle`> yeah, so that's also probably a pbd
11:13:21 <EvanR> can edk please make a "once and for all" ivar package called ivar
11:14:31 <jle`> cocreature: simple, just convert back and forth between vectors and arrays
11:14:32 <mbw> shapr: I don't have a blog. The thing that comes closest to it would be a reddit question I asked about Repa that became really long. Didn't get that much attention tho.
11:14:41 <shapr> got a link?
11:14:51 <cocreature> jle`: who needs performance anyway
11:15:01 <jle`> avoid performance at all costs
11:15:13 <Tuplanolla> What is there to blog about, shapr? Our multidimensional array situation is a mess.
11:16:31 <mbw> shapr: https://www.reddit.com/r/haskell/comments/68pc7a/equational_reasoning_with_multidimensional_arrays/
11:16:45 <mbw> But it probably isn't really what you are looking for.
11:26:13 <torstein> With Hspec, are "before_" actions run before every top level describe, or every nested describe also?
11:26:39 <torstein> How can I can I call a setup function which is only run once before some "describe"'s?
11:30:11 <LiaoTao> Is ghc smart enough to reduce two sequential maps over the same data with two different functions to a single map with the functions composed together?
11:31:07 <glguy> LiaoTao: Yes, but because the authors of 'map' write RULES for it, not because of a general purpose optimiation
11:31:29 <LiaoTao> Right
11:31:35 <LiaoTao> glguy: Thanks!
11:34:50 <mbw> LiaoTao: Depending on what kind of data structures you use, this might be something that hlint can point you to as well.
11:35:29 <LiaoTao> mbw: Haven't started using hlint yet! Maybe I should!
11:35:43 <sbrg> LiaoTao: definitely. it's really nice.
11:35:50 <sbrg> also teaches you a lot of things if you're new to haskell. 
11:35:53 <sbrg> or well, it can. 
11:36:27 <torstein> In Hspec, is a spec item a "describe" or an "it" ?
11:36:36 <sbrg> LiaoTao: depending on your editor setup, you may be able to plug it in so that you get hlint suggestions on the fly, which is even nicer.
11:36:51 <lyxia> torstein: it
11:37:44 <torstein> lyxia, is there a way to do a setup once for multiple "it"s ?
11:37:50 <LiaoTao> mbw sbrg Thanks for the recommendation
11:37:58 <LiaoTao> sbrg: I'll check out if there's vim support
11:38:07 <sbrg> LiaoTao: there is :)
11:38:14 <torstein> Like, load a database, then have different tests for checking different aspects of the database.
11:38:22 <sbrg> you can also get vim setup so that it shows you type errors on the fly as well.
11:38:59 <LiaoTao> That sounds nice
11:39:06 <torstein> Because according to the docs, a "before_" action is run before every Spec item, but I want multiple tests with a "before_" action that is only run once and that passes some parameter to the tests
11:42:17 <mbw> LiaoTao: You might want to google Stephen Diel's vim setup guide.
11:42:28 <lyxia> torstein: runIO? https://hackage.haskell.org/package/hspec-core-2.4.3/docs/Test-Hspec-Core-Spec.html#v:runIO
11:42:49 <cocreature> canâ€™t you use beforeAll for that?
11:43:26 <torstein> lyxia, thank you, that seems right
11:43:31 <lyxia> oh yes
11:43:44 <torstein> cocreature, I need the result from the IO action so beforeAll won't work
11:44:07 <cocreature> torstein: thatâ€™s what you get with beforeAll
11:44:26 <torstein> "f you do not need the result of the IO action to construct the spec tree, beforeAll may be more suitable for your use case."
11:44:40 <torstein> I don't know the difference ...
11:44:43 <cocreature> â€œconstruct the spec treeâ€ not â€œrun your testsâ€
11:45:06 <cocreature> if I understood you correctly your spec tree, i.e., the tree of tests that you want to run is static
11:45:14 <cocreature> and you only want to pass dynamic data to each of those tests
11:45:21 <torstein> Yes that's right
11:45:41 <cocreature> then beforeAll seems like what you want
11:45:55 <torstein> it does i'll give it a try thank you
12:15:48 <leshow> I'm looking at the definition for (!!) and can't quite figure it out
12:15:50 <leshow> http://lpaste.net/355682
12:16:18 <torstein> Is there any way to ignore the arguments from a beforeAll in Hspec when calling a spec? http://lpaste.net/355683
12:16:20 <leshow> how is it that foldr's lambda has 3 arguments, and foldr itself has 4
12:16:48 <Tuplanolla> :t foldr (.) id -- It's the same idea as in this, leshow.
12:16:49 <lambdabot> Foldable t => t (b -> b) -> b -> b
12:17:20 <byorgey> leshow: foldr is being used to compute a function
12:17:28 <leshow> Tuplanolla: I'm not sure I follow
12:17:41 <byorgey> leshow: every function in Haskell has only one argument.  But some return functions.
12:18:05 <leshow> with (const Nothing) as the arg for b i can see why foldr's lambda has an extra argument
12:18:11 <EvanR> data Rumsfeld a b = http://lpaste.net/355684
12:19:11 <erisco> I'll jump in and make it more confusing
12:19:35 <erisco> leshow, lambdas have exactly one argument. they don't gain extra arguments or lose arguments
12:19:49 <leshow> I understand that f x y z is actually 
12:20:00 <leshow> f = \x -> \y -> \z ->
12:20:24 <leshow> but I still am not grasping how this specific thing works
12:20:24 <EvanR> f x y z is actually ((f x) y) z
12:20:27 <byorgey> leshow: right, and do you know that the expression   g a b c   is really   ((g a) b) c  ?
12:20:45 <byorgey> leshow probably means  f x y z = ...   is    f = \x -> \y -> \z -> ...
12:21:08 <erisco> wish that was true in all languages...
12:21:09 <leshow> byorgey: yeah sorry, forgot the equals
12:21:13 <byorgey> no worries
12:21:15 <leshow> let f x y z = ...
12:21:24 <lyxia> torstein: mapSpecTree
12:21:37 <byorgey> leshow: so do you know that  g a b c  is  ((g a) b) c ?
12:21:55 <leshow> yes
12:22:00 <leshow> but how does that help
12:22:08 <byorgey> so if   g a b c  returns a function, then   g a b c d   is   (((g a) b) c) d
12:22:19 <byorgey> it applies the function returned by  g a b c  to the argument  d
12:22:25 <byorgey> leshow: in this case  g = foldr
12:22:33 <erisco> well it sort of isn't in Haskell if you have multiple clauses
12:23:06 <leshow> byorgey: oh are you saying in this case, foldr is producing a function, then n is being applied?
12:23:13 <byorgey> leshow: exactly
12:23:17 <leshow> ohhh
12:23:45 <erisco> :t id
12:23:45 <Tuplanolla> Look at the type signature again, leshow.
12:23:46 <lambdabot> a -> a
12:23:48 <erisco> :t id (+)
12:23:50 <lambdabot> Num a => a -> a -> a
12:23:54 <erisco> :t id (+) 1 2
12:23:55 <lambdabot> Num a => a
12:24:37 <erisco> :t id (+) `id` 1 `id` 2
12:24:38 <lambdabot> Num a => a
12:25:20 <leshow> it's still odd a bit to read I find
12:25:55 <erisco> specialising type variables to function types is not intuitive
12:25:58 <erisco> it takes some time to realise it
12:26:22 <leshow> at a high level I get what we're saying. the play of (const Nothing) as the "argument" for b reads weird thouhg
12:26:41 <leshow> I wouldn't come up with something like this myself
12:27:03 <EvanR> polymorphism begins simple until you take "any type" seriously
12:27:07 <Tuplanolla> You could've reinvented `ShowS` though, leshow.
12:27:37 <leshow> lol
12:27:43 <erisco> the simple way to understand foldr is just to look at how it expands
12:27:50 <erisco> > foldr f z [a,b,c]
12:27:52 <lambdabot>  f a (f b (f c z))
12:28:08 <erisco> you can literally view foldr as a builder of these expressions
12:28:16 <leshow> a regular foldr I don't find difficult, where the arguments are values
12:28:26 <leshow> when it's a partially applied function
12:28:31 <erisco> with that in mind, seeing how z might be itself a function is not as difficult
12:28:34 <Tuplanolla> > (shows 42 . (" * " ++) . shows 13) ""
12:28:36 <lambdabot>  "42 * 13"
12:28:46 <erisco> leshow, functions are values
12:29:03 <Tuplanolla> > foldr (.) id [shows 42, (" * " ++), shows 13] ""
12:29:05 <lambdabot>  "42 * 13"
12:29:28 <erisco> a big unlearning is how we're used to treating functions specially
12:30:26 <lyxia> torstein: actually, I was looking at the low level interface again. aroundWith allows you to map Specs
12:30:35 <erisco> really they are completely ordinary in useful senses. for example they are values like any other, and the function type is like any other type constructor
12:30:45 <erisco> except extensions like RankNTypes and whatever
12:31:22 <mniip> wut
12:32:06 <mniip> is it normal for cabal to spin at 100% cpu for a minute and consume 4G ram?
12:32:29 <monochrom> I think it is not normal. But I don't know.
12:32:32 <EvanR> you should not conflate forall with functions
12:32:47 <mniip> correction, 9GB
12:32:49 <Tuplanolla> If you're installing Yesod, mniip.
12:32:55 <hexagoxel> mniip: during dependency resolution?
12:32:57 <erisco> I am just saying that it has a unique feature for functions, EvanR
12:33:01 <mniip> I don't know
12:33:13 <mniip> it seems like it doesn't matter what package I install
12:33:21 <mniip> oh huh
12:33:22 <mniip> it did finish
12:33:44 <mniip> after 10 GB of ram
12:33:57 <erisco> so, data types we construct with their data constructors and we deconstruct them by pattern matching
12:34:02 <monochrom> I'm OK with 100% CPU for a little while, but 9GB is too much (considering that I only have 3GB).
12:34:21 <mniip> I have 16 and a good swap hdd, but uh
12:34:28 <erisco> functions we construct with various syntaxes the language provides us and we're not allowed to pattern match them
12:34:53 <leshow> erisco: They may be equivalent in that sense, but evaluating mentally does become more complicated, at least for me, when many partially applied functions come into play. I feel like there's more to juggle with mentally when reading
12:35:05 <erisco> but instead we have application, which still eliminates them but we don't get to look at the innards like we do data
12:35:40 <erisco> leshow, that is because when you see functions your mind goes into the mode that thinks about functions
12:36:00 <erisco> even though those details may not be relevant
12:37:06 <erisco> I know this because, as you said, if this was some other type, such as Int, you'd have an easier time with it
12:37:22 <erisco> well, the fact we're using functions doesn't actually make it any different
12:37:43 <leshow> Knowing that, at this stage, doesn't help that much though lol. I think it's just practice.
12:37:45 <erisco> how can I say that? because foldr didn't change
12:37:55 <EvanR> you can think of functions as taking arguments and holding onto an invisible context (the arguments already given, the lexical environment the lambda was in)
12:38:17 <EvanR> thats pretty much like a data structure
12:38:30 <EvanR> an object
12:39:13 <monochrom> Yes, there is much practice involved when you try to change the way you think. For most people anyway.
12:39:24 <torstein> lyxia, That worked thank you. Had to do "aroundWith (\_ -> \_ -> return ()) myFunc"
12:42:22 <byorgey> torstein: you can shorten that a bit by writing  \_ _ -> return ()
12:42:27 <erisco> leshow, it's no problem. I have the same struggle... I suspect it is to do with Haskell not being my native PL, so to speak
12:43:26 <erisco> I have to wonder if people brought up on FP have the same difficulties in this area
12:43:45 <leshow> erisco, me too. I find they tend to do FP more on the euro side in school
12:43:49 <leshow> in NA it's all OO
12:43:58 <leshow> I'm in Canada, we did Java
12:44:24 <leshow> I had no idea how much bigger the PL spectrum was until I started learning on my own.
12:44:38 <erisco> when the back of your mind is thinking "functions do things" and your procedural and imperative intuitions begin to bubble...
12:45:01 <Tuplanolla> I don't have an issue with them, but only because I've spent so much time wrangling the various instances of `(a ->)`.
12:45:04 <erisco> it becomes difficult to see the picture where you're just constructing something
12:45:23 <erisco> we don't "lists do things", we just construct them
12:45:24 <Tuplanolla> They're my favorite simple thing in Haskell.
12:45:26 <erisco> we don't think*
12:46:37 <EvanR> functions are an immutable data structure with one operation, apply. simple!
12:47:50 <leshow> Monads are just like burritos, simple!
12:47:56 <Tuplanolla> Like that thing torstein mentioned I would've written `pure (pure unit)`.
12:47:58 <erisco> and tasty
12:50:26 <erisco> leshow, I am in Canada too and though there was an intro course that used Miranda the focus in later years was Java
12:51:15 <leshow> For what program? It seemed like all the software engineering programs in Ontario did Java, then a few years later switch to Python
12:51:22 <EvanR> my uni went from C to Java
12:51:39 <erisco> the program was Computer Science ;)
12:52:25 <erisco> on one hand I understand they want to be industry relevant
12:52:35 <torstein> there's no Haskell in Norway at least. The advanced programming course used Oz; a academic mix match language with imperative, functional, procedural and dataflow variables
12:52:50 <lyxia> torstein: uh I'm not sure you're supposed to throw away the first argument
12:52:52 <erisco> on the other, if that were true, I have to wonder why half our classes weren't JavaScript and web dev
12:53:03 <EvanR> erisco: give it time
12:53:39 <erisco> by the time JavaScript is phased out, or the prevalence of web diminishes, that is when the Universities will switch over
12:53:59 <torstein> isn't JS here to stay forever?
12:54:16 <erisco> to keep up the tradition of 20 years lag time :
12:55:12 <EvanR> somebody needs to tell these chairpeople that computer science is not the same thing as "how to get a job 3.5 years ago"
12:55:12 <erisco> maybe it is unintentional revenge for the industry lagging 20 years behind research
12:55:58 <ptvirgo> Is there an HUnit equivilant to 'python -m unittest discover,' or do you have to load the ghci every time you want to run your tests?
12:57:12 <leshow> It is kind of disappointing to me that uni's churn out CS and S.Eng students, myself included, that know almost nothing about PL theory
12:57:15 <leshow> or type theory
12:57:21 <erisco> the true problem with trying to be industry focused in uni is that, well, look at who is teaching
12:57:57 <erisco> researchers, not day job programmers
12:58:16 <EvanR> im ok with that
13:01:43 <EvanR> i dont need handlebars or whatever latest js template language impressed upon me by the professor
13:01:43 <[exa]> what's wrong about day job researchers? :]
13:01:43 <leshow> If anything I'd like to see more research stuff be taught at schools, at least then you can learn the things that will be used over the next decade
13:01:43 <leshow> and not just learn things tha twill be obsolete when you graduate
13:01:43 <erisco> I just want them to teach what they're excellent at, and I'll learn the trade of programming from someone else
13:01:43 <torstein> lyxia, You're right, i think it might be "aroundWith (\a _ -> a ()) myFunc" instead
13:01:43 <EvanR> right, university CS vs trade school
13:01:43 <erisco> I dunno... I've just had embarrassingly poor "software engineering" courses
13:02:27 <Tuplanolla> The best part about programming courses at the university was pointing out errors in C programs by citing N1570.
13:02:38 <sproingie> oz is a funky little language.  did the course use CTM?
13:03:06 <DSM> Does anyone know of a library with good automated test coverage? I'm trying to figure out how I should setup and organize tests and an example would be useful
13:04:22 <torstein> sproingie, Yep. Course instructor said it was THE book on Oz, though it probably was the ONLY book
13:04:26 <sproingie> DSM: lens has a pretty good number of tests
13:05:07 <sproingie> torstein: pretty much.  i'd definitely call it a "teaching language", tho there was some attempt at an industrial-strength thing on top of oz way back
13:05:22 <erisco> leshow, I didn't take grad school because all I wanted to focus on was PL theories and the offering was too dilute
13:05:27 <sproingie> called Alice I think, more ML-ish than mozart
13:06:28 <leshow> erisco: I didn't even know that kind of thing existed, I just rushed out and got a job. Then started discovering all these wonderful languages over the last 3 or 4 years
13:06:35 <erisco> imagine it varies school by school just based on the faculty
13:07:17 <erisco> we had one prof who was deep in Haskell and as far as I could tell, or knew, the others were at most just interested in it
13:07:46 <erisco> well, not saying Haskell encompasses FP, but it is a hard language to miss
13:08:16 <leshow> it also tends to bleed into modern languages over time
13:08:19 <ggVGc> any sufficiently complete implementation of FP contains a full haskell compiler
13:08:22 <ggVGc> isn't that how the saying goes?
13:08:36 <[exa]> erisco: anyway, could you elaborate about what was embarrasingly poor on that S.Eng course? (kindof interested for I'm teaching too)
13:08:37 <EvanR> that would make ghc complete
13:08:43 <EvanR> or sufficiently complete
13:08:45 <sbrg> any FP implementation that doesn't contain a full haskell compiler is not sufficiently complete
13:08:58 <leshow> [exa]: I think he said he was in CS
13:09:24 <erisco> [exa], sure. We studied waterfall and agile methods out of a text book and were tested on what the text book said
13:09:24 <EvanR> can it be a adhoc informally specified bug ridden slow haskell compiler?
13:09:30 <leshow> sbrg: sounds like a no true scotsman lol
13:10:01 <[exa]> erisco: oh so. So nothing in common with software engineering. :D
13:10:02 <leshow> erisco: I had one of those too
13:10:30 <leshow> It's all the same, I was just correcting lol.
13:11:00 <[exa]> best course about software engineering I had was called something like "recommended practices in programming"
13:11:04 <ph88> i need some help with conduit, i have a (Maybe Double) there in my type but i don't know what to do with it   https://bpaste.net/show/9af835644e1d
13:11:14 <erisco> [exa], nadda. No practicum. Not even a group essay to write.
13:11:35 <[exa]> the course was basically about doing reasonably one assignment, and then modifying several other people's assignment result for new functionality
13:11:53 <[exa]> taught me about getting burnt
13:11:55 <erisco> haha, that's smart
13:12:12 <erisco> lets you experience the full range of coworkers you'll have in the future :P
13:12:38 <erisco> and instruct you brutally as to what kind of code you'll want to hand over to others
13:12:38 <[exa]> learning stuff from books is great for formal logic, not for agile tribesmanship
13:13:28 <[exa]> we also had a formal course about software testing
13:13:40 <[exa]> it was led by one of the smartest people from the faculty
13:14:10 <erisco> leshow, UoW? Waterloo?
13:14:27 <leshow> when I think about school I barely even remember any of the actual on topic courses, I just remember the calculus, physics, stuff like that
13:14:40 <leshow> I'm in Ottawa, Carleton
13:14:40 <[exa]> started with gÃ¶del, and rest of the course were fun examples of what tests can't expect
13:14:46 <erisco> ah ha
13:15:27 <EvanR> classic
13:16:59 <erisco> job interview... "so are you familiar with unit testing?", "yeah", "what coverage did your last project have?", "well, none, but I formally proved all the tests I couldn't write"
13:18:21 <leshow> https://aphyr.com/posts/342-typing-the-technical-interview
13:18:29 <leshow> this has to be one of my favorite blog posts
13:23:04 <erisco> I kinda like them when they're five miles over my head
13:23:15 <erisco> that one is a bit too understandable for me
13:23:27 <erisco> needs moar CT :P
13:27:17 <leshow> ah well any further and I wouldn't get the jokes
13:27:54 <erisco> you begin with a simple problem with an easily verifiable solution
13:28:27 <erisco> in the middle you insert advanced and niche theory
13:29:14 <erisco> so it works as a magic show where the audience knows the premise and result but can't figure out what made it happen
13:29:50 <erisco> and also attractive is that you can learn and peel away the mysteries, if you want to
13:33:58 <suzu> anybody have experience using snap without heist?
13:34:58 <dmj`> suzu: yea
13:36:04 <erisco> for example... the premise is user interaction with a program... the result is a GUI... I can't figure out the middle
13:37:23 <suzu> dmj` how can i use a splice without heist?
13:38:37 <dmj`> suzu: I donâ€™t think you can since type Splice n = HeistT n n Template
13:39:47 <suzu> hmm crap
13:39:53 <suzu> so using all of snap-extras is out of the question
13:40:08 <suzu> i'm currently using lucid. ive not used heist before
13:40:13 <suzu> is it worth switching everything oveR?
13:40:15 <suzu> over *
13:40:51 <dmj`> suzu: what are you trying to build?
13:41:25 <suzu> i'm building a web application
13:41:34 <suzu> i was hoping to get csrfs and recaptcha and such for free
13:42:08 <shapr> What framework are you using?
13:42:14 <suzu> snap
13:42:35 <shapr> have you checked the #snapframework channel? ( I think that's the name )
13:42:43 <suzu> nope
13:42:59 <dmj`> suzu: just snap-core and snap-server? Or snap, which re-exports both.
13:43:17 <suzu> snap, with the re-exports, so i can get snaplets
13:45:27 <dogweather> Adding modules to the cabal file: best practice?  I'm seeing that it's a lot of redundancy
13:45:45 <glguy> The best practice is to add them so that your package functions
13:46:19 <glguy> There shouldn't be any redundancy, you only need to add them once
13:46:22 <dogweather> glguy: I refactored some functions out to a new file, but didn't add it. I get a warning, but my tests still pass
13:46:28 <dmj`> suzu: it might be worth it
13:46:29 <suzu> hmm, yeah guess i need heist if i want to use splices.
13:46:53 <suzu> i was already so comfy with lucid
13:46:54 <glguy> dogweather: When you create a source tarball via 'cabal sdist', those modules will be missed
13:46:54 <suzu> :(
13:47:04 <dogweather> Ah hah!
13:47:30 <dogweather> I've been deploying by doing git clone ; stack build.
13:47:37 <dmj`> suzu: you could just use the session id as the csrf token though, if youâ€™re already using snapâ€™s auth, and embed that into the template. A little manual work.
13:48:08 <suzu> yeah so i could manually implement these things and avoid heist
13:48:24 <dmj`> suzu: right
13:48:30 <suzu> but then its a matter of which is less work: rolling my own extras, or porting heist?
13:48:46 <dmj`> suzu: how many templates do you have
13:48:52 <dogweather> This is application-level code; maybe it's not so necessary. FWIW, I'm finding that I need to add each filename (module) twice to the cabal file: `other-modules` in the executable and test-suite sections
13:48:55 <suzu> just two, so far
13:49:02 <suzu> so it might not be too much trouble
13:50:04 <dmj`> suzu: alternatively, you could try servant.
13:50:48 <suzu> hmmm
13:50:55 <suzu> servant for a full-stack web application..?
13:51:16 <suzu> i had thought it was an api framework
13:51:57 <glguy> dogweather: If you're adding modules to multiple sections, that means you've misconfigured your source directories
13:52:21 <dogweather> glguy: !! Interesting - i'll look into that
13:52:46 <glguy> dogweather: each section should have its own hs-source-dirs: 
13:52:49 <glguy> and those should be different
13:53:56 <actualHuman_462> The thing about full-stack web apps is that the stack is built from components.
13:54:34 <suzu> right
13:54:37 <dmj`> suzu: no reason why servant canâ€™t deliver html, handle sessions, auth, etc.
13:54:37 <dogweather> Huh, I have `app, src`, and `test, src` - orig. set up by Stack. https://github.com/dogweather/nv-statutes-haskell/blob/chapter-details/nv-statutes.cabal
13:54:44 <suzu> so you're saying i could just layer stuff on top of servant
13:54:51 <dogweather> I appreciate any advice!
13:54:57 <suzu> i guess that'd work
13:55:15 <suzu> but then i'd need to roll a lot more things myself than if i continue with snap without heist
13:55:29 <glguy> dogweather: the library's source directory should be separate from the executable
13:55:38 <glguy> dogweather: same for the test suite
13:55:48 <actualHuman_462> Note that rolling your own may or may not be more work depending on the scale of what you're trying to accomplish
13:56:28 <actualHuman_462> Frameworks in general tend to save you effort if and only if what you're doing hits the scale that they're targeted at
13:56:43 <dogweather> ok, I'm never really building the library. Can I ignore it and just straighten out the executable and test-suite sections?
13:56:47 <suzu> hmm
13:56:58 <suzu> i see
13:56:58 <dmj`> suzu: itâ€™s a double-edged sword, suppose you need to do something custom with your authentication, youâ€™d have to fork snapâ€™s auth package and modify it.
13:57:23 <glguy> dogweather: all of the interesting stuff should be in your library, the executable should be a shim that uses the library
13:57:29 <glguy> and the test suite should only test the library
13:58:37 <dogweather> ah hah, yeah, that'd be good architecture. Currently I don't even have the executable code; i guess i've been doing lib dev but in the executable environment
14:01:46 <glguy> OK, well if you fix that then you'll have less redundancy
14:01:51 <glguy> and fewer recompiles
14:02:43 <ph88> i would like some help with conduit, i have a (Maybe Double) there in my type but i don't know what to do with it   https://bpaste.net/show/9af835644e1d
14:03:06 <athan> Is forking a long-running process like `_ <- async $ forever $ ..` dangerous, because the thread could get GC'd?
14:03:26 <glguy> no
14:04:37 <dogweather> thanks glguy
14:04:46 <athan> hm. I read on EZYang's blog that "blocked indefinitely in an STM transaction" exceptions can be caused by threads getting collected, but I'm not exactly sure what I'm doing ._.
14:06:32 <lyxia> ph88: use runConduit instead of sourceToList
14:07:24 <lyxia> ph88: $$ would be even shorter
14:08:01 <ph88> ah ye that was it !
14:08:09 <ph88> lyxia, i thought $$ was deprecated
14:08:35 <ph88> https://github.com/snoyberg/conduit#legacy-syntax   The $$ operator is a combination of runConduit and .|
14:08:39 <ph88> that's why i stopped using it
14:09:25 <lyxia> oh, okay. Well there's still runConduit
14:10:43 <ph88> lyxia, why was i getting (Maybe Double) there actually ? shouldn't the type be something with a list since i was using sourceList ?
14:13:10 <lyxia> ph88: you didn't have a Source, as the error indicates. Source m a = ConduitM () a m ()
14:14:00 <ph88> lyxia, src was on line 13 in paste .. what do you mean ?
14:14:02 <lyxia> ph88: apart from the type, getAverageSampleInterval doesn't send anything downstream, so blabla doesn't either
14:14:34 <lyxia> ph88: sourceToList is being applied to blabla, not src.
14:14:37 <ph88> getAverageSampleInterval is suppose to be the sink
14:14:57 <ph88> ooohh right
14:15:08 <ph88> anyway it type checks now ^^
14:15:42 <vimalloc> Hey guys :) I got some help from this lovely community a week or so ago about a bridges game solver I'm building (first thing I've really done in haskell). I refactored a bunch of stuff, and it now looks like this: https://gist.github.com/vimalloc/3e3ec5f37ca5a1d60ce474996b788c26
14:15:49 <vimalloc> would anyone want to give it a quick glance through, and let me know if anything looks bad right off hand?
14:16:34 <vimalloc> (bridge game in question is this: http://www.puzzle-bridges.com/)
14:17:50 <lyxia> ((...) == False)   is   not (...)
14:18:37 <vimalloc> thx
14:19:35 <lyxia> fromJust $ ... <|> Just ' ' is fromMaybe ' ' $ ...
14:19:48 <lyxia> Overall it looks good though
14:20:00 <vimalloc> doh! I was even looking at fromMaybe in an earlier iteration. Thanks!
14:20:27 <lyxia> it's nicely indented
14:20:52 <vimalloc> The joys of coming from a python background :P
14:21:51 <dmj`> vimalloc: you can take advantage of the fact youâ€™re in the Maybe monad
14:22:26 <dmj`> and use the guard function, instead of guards, and maybe foldM, could be interesting
14:22:40 <dmj`> in bridgeAtPoint
14:23:16 <lyxia> line 125 is "asum" of something
14:23:27 <vimalloc> Ah, I just read about the guard function the other day, but didn't think about how they would apply here. I will refresh myself on that
14:24:48 <lyxia> vimalloc: you could define Point and Island as records
14:25:42 <vimalloc> That's a good idea. Would clear out some of those 'get' functions
14:26:20 <dmj`> > Just 4 >>= \x -> do { guard (x > 4); pure x; }
14:26:22 <lambdabot>  Nothing
14:29:31 <vimalloc> This community is awesome. Thanks for all the suggestions :)
14:34:45 <Boomerang> vimalloc: Why don't you make Point and Island records? This would create all the getter functions for you. data Point = Point { getX :: Int, getY :: Int } deriving ...
14:35:35 <vimalloc> lyxia said the same thing. I'm going to change it to that.
14:37:55 <Boomerang> Oh yeah, missed that. Sorry :/
14:38:03 <vimalloc> Oh, no worries at all!
14:52:05 <lambdamu_> inline-c is really nice to beat awful c apis into submission
14:52:59 <lambdamu_> code looks abominal but that was to be expected
15:14:23 <scav> Are there no feature complete JWT libraries for Haskell?
15:16:10 <sproingie> there's the JWT package.  seems to be missing RSA, otherwise seems to have everything.
15:16:21 <sproingie> s/JWT/jwt/
15:16:52 <scav> thats web.jtw?
15:17:23 <sproingie> ew, it doesn't verify exp.  easily enough done after the fact i guess.
15:17:57 <scav> yeah, it has a couple of limitations, which is why i was curious :)
15:18:14 <scav> but that should be quick to fix anyway
15:20:39 <ph88> hey guys a question about syntax https://bpaste.net/show/4ac98a1c8feb
15:22:45 <ph88> i updated my paste a little   https://bpaste.net/show/a97d9fead846
15:23:28 <reactormonk[m]> ph88: "Just tcol"
15:23:45 <ph88> where ?
15:23:50 <jle`> instead of tcol
15:24:15 <reactormonk[m]> In the function declaration. You want to extract the value.
15:24:37 <reactormonk[m]> It's not just a syntax question, it's also a semantics one - you want to prove to the compiler the value will be there.
15:24:43 <jle`> convert (Options fin fout vcol (Just tcol) (Just st) rs p swv) =
15:24:57 <ph88> but then the case where one of the two is Nothing won't be covered ..
15:25:16 <jle`> how would you want to handle that case?
15:25:18 <jle`> it's not clear
15:25:21 <reactormonk[m]> Yup.
15:25:43 <jle`> looks like an issue with your logic
15:25:49 <ph88> look at the case statement line 6 to 10
15:26:14 <ph88> :(
15:26:20 <jle`> ah, sorry, was looking at the first link
15:28:07 <threshold> recommended way of creating migrations in a sql database?
15:28:12 <ph88> here is the actual code as from my file  https://bpaste.net/show/b2f202262216
15:28:25 <threshold> postgresql is the database being used
15:28:27 <ph88> threshold, i thought there was something about that in persistent
15:28:29 <jle`> you can just handle all of it in a single case, can't you?
15:28:40 <Boomerang> ph88: If you know a state is impossible tcol and st being both Nothing, try to model your data so it is impossible for you to represent it. You could make a custom data type of use something like These https://hackage.haskell.org/package/these-0.7.3/docs/Data-These.html
15:29:00 <threshold> ph88: i will look at it. thank you
15:29:02 <Boomerang> s/of/or
15:30:21 <Boomerang> Oh wait I didn't take into account the previous line that handle Nothing and Nothing, two Maybes may be an appropraite model
15:32:34 <lpaste> jle` pasted â€œconvertâ€ at http://lpaste.net/355691
15:32:37 <lpaste> jle` pasted â€œconvertâ€ at http://lpaste.net/355692
15:32:43 <jle`> oops sorry
15:32:45 <jle`> ^ ph88 
15:33:40 <ph88> thx
15:35:12 <ph88> <|> is in maybe applicative context ?
15:35:27 <reactormonk[m]> <|> is Alternative
15:44:55 <mniip> int-e, you said it takes lambdabot a second to parse interface files?
15:45:03 <mniip> takes 8 seconds here...
15:46:19 <jle`> ph88: for <|>, it's "pick the first Just"
15:46:30 <jle`> for Maybe, i mean
16:04:11 <threshold> is there an example of how to use persistent-postgresql?
16:09:53 <nilof> The IO type has no constructor, is this compiler magic or are there more HKT's that behave like this?
16:10:44 <glguy> nilof: The IO type has a constructor, but that constructor is not exported. No magic
16:11:01 <glguy> nilof: Also you can declare "empty data types" that actually have no constructors
16:14:53 <nilof> Like for example GADT's with constructors that are specialized to specific types, so that the GADT type with some type parameters will be empty?
16:15:40 <pikajude> nilof: if you enter :i IO in ghci it'll even tell you what the constructor is called
16:23:52 <hpc> nilof: /eventually/ there is magic (and if your perspective is strictly based on the spec any IO implementation is magic)
16:24:14 <hpc> nilof: the comments around the IO type and the stuff it's made up of have a good explanation of some of it
17:51:37 <athan> What's the best way to keep GHC from sending async exceptions to blocked STM transactions?
17:53:05 <lyxia> don't let them block
17:53:09 <athan> :(
17:53:16 <mauke> let them eat cake
17:53:53 <lyxia> athan: what exceptions do you want to avoid
17:54:08 <athan> BlockedIndefinitelyOnSTM lyxia
17:54:25 <athan> but the issue is that the RTS will throw them to many different threads, main even
17:54:56 <ReinH> Yeah I recommend not blocking indefinitely.
17:54:58 <athan> I guess I better just use thunks
17:55:09 <lyxia> I thought these were thrown precisely when the runtime knows you're in a deadlock
17:55:34 <athan> lyxia: well, I did some reading, and it's only when it thinks there's only one thread blocking on a reference
17:55:58 <lyxia> and it's the only one holding onto that reference, right?
17:56:13 <athan> yeah
17:56:22 <lyxia> then throwing an exception seems perfectly justified
17:57:08 <lyxia> and the workaround is to find a way not to block or simply catch the exception and let the thread die.
18:03:20 <yuuuull> Is there a way to pattern match for one specific pattern/constructor?
18:03:49 <yuuuull> something like (Constructor1 a b) -> e1; _ -> e2; ?
18:04:21 <yuuuull> If I try using the _ pattern in case or function pattern match then it gets used every time even if its at the end
18:05:34 <lyxia> > case Just True of Just e -> e ; _ -> False
18:05:35 <lambdabot>  True
18:05:44 <geekosaur> sounds to me like you are doing something wrong
18:07:02 <yuuuull> geekosaur: oh lol
18:07:15 <yuuuull> so that does work haha
18:09:46 <yuuuull> debugging haskell not the easiest thing in the world :)
18:10:36 <hpc> just don't bug it in the first place ;)
18:11:03 <lyxia> this is sound advice
18:11:12 <hpc> a good habit to get into is if you can't tell a piece of code is correct just by looking at it
18:11:15 <hpc> change it
18:11:58 <hpc> it's not universally applicable, but you get really good at distinguishing between coding style that is error-prone and style that is not
18:12:20 <whoman> +1
18:12:21 <yuuuull> ah, good advice hpc
18:12:42 <hpc> i haven't used a debugger ever without a professor telling me to
18:13:11 <yuuuull> well I'm not using a debugger, I'm debugging with trace lol
18:14:15 <hpc> ah, that's fine :P
18:14:18 * hpc does that all the time
18:14:23 <hpc> occasionally
18:24:04 <Rotaerk> hmm if I have a Pipe String R m (), and a type data D = A String | B | C
18:24:32 <Rotaerk> is there some easy way to produce a Pipe D R m () from the Pipe String R m ()
18:24:45 <Rotaerk> i.e. where I only have to provide the additional information of how to convert B and C to R
18:25:22 <Rotaerk> and to pump only the As through the Pipe String R m ()
18:31:51 <lyxia> Rotaerk: await+yield+(>~)  ?
18:33:33 <Rotaerk> lyxia, eh?
18:34:22 <Rotaerk> hmm
18:35:32 <Rotaerk> yea, no I don't see
18:37:24 <glguy> doing the chunks to lines?
18:37:40 <lyxia> Rotaerk: your Pipe String R m () should be the second argument of (>~), what type can you expect for the first argument?
18:38:57 <Rotaerk> glguy, my input type is TCP.Event, which includes Received ByteString | Closed | Disconnected
18:39:14 <Rotaerk> it'd be nice if I could somehow ... lift a Pipe ByteString R m () into a Pipe TCP.Event R m ()
18:39:58 <Rotaerk> it's possible to do it manually, which is what I did before, but it'd be nice if I could reuse Pipes on ByteStrings
18:59:10 * hackage Villefort 0.1.0.7 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.7 (ChrisReuter)
18:59:12 * hackage aws-ec2 0.3.7 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  https://hackage.haskell.org/package/aws-ec2-0.3.7 (IanRoss)
18:59:14 * hackage HTTP 4000.3.7 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.7 (GaneshSittampalam)
18:59:15 * hackage mustache 2.2.2, mustache 2.2.1, mustache 2.2 (justus): https://qbin.io/629ru2q
18:59:18 * hackage servant-auth-token 0.4.7.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.4.7.0 (NCrashed)
18:59:20 * hackage table-layout 0.8.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.8.0.0 (muesli4)
18:59:22 * hackage sort 0.1.0.0 - A Haskell sorting toolkit  https://hackage.haskell.org/package/sort-0.1.0.0 (ChrisDornan)
18:59:24 * hackage dhall-nix 1.0.3, dhall-bash 1.0.1 (GabrielGonzalez): https://qbin.io/ueu1kpwt
18:59:26 * hackage statistics 0.14.0.2 - A library of statistical types, data, and functions  https://hackage.haskell.org/package/statistics-0.14.0.2 (AlexeyKhudyakov)
18:59:33 <glguy> mniip: ^
19:03:20 <glguy> Rotaerk: Check out +++ http://hackage.haskell.org/package/pipes-extras-1.0.9/docs/Pipes-Extras.html#v:-43--43--43-
19:04:08 <glguy> Rotaerk: You can either convert your type to an Either String BorC and use this
19:04:25 <glguy> or you can peek at how these are implemented and do something similar
19:13:51 <Rotaerk> hmm thanks glguy 
19:37:27 <barcabuona> hey guys a quick question
19:37:39 <barcabuona> why cant i do print $ readFile "hi.txt" ?
19:37:50 <barcabuona> i need to do f <- readFile "hi.txt" first
19:38:47 <dmj`> barcabuona: what is the type of print, and what is the type of readFile
19:39:04 <dmj`> :t print
19:39:06 <lambdabot> Show a => a -> IO ()
19:39:08 <dmj`> :t readFile
19:39:09 <lambdabot> FilePath -> IO String
19:39:36 <dmj`> :t \file -> putStrLn =<< readFile file
19:39:38 <lambdabot> FilePath -> IO ()
19:39:40 <clever> :t :t hashFileStrict
19:39:42 <lambdabot> error: parse error on input â€˜:â€™
19:39:44 <clever> :t hashFileStrict
19:39:46 <lambdabot> error: Variable not in scope: hashFileStrict
19:40:44 <barcabuona> dmj`: thanks!
19:51:43 <c_wraith> Ok, I'm *really* liking GHC 8.2's colorized output.  It's surprising me how much I like it.
19:53:21 <kadoban> 8.2 has colored output? That sounds fancy
19:53:31 <kadoban> Is it in RC now? I lost track
19:53:36 <MarcelineVQ> it's fairly minimal but I like it
19:54:00 <c_wraith> kadoban: rc2 is out
19:54:09 <MarcelineVQ> iirc it just colors the error type by severity, unless that's been expanded on
19:54:57 <c_wraith> errors are red, warnings are purple, line numbers are blue in the code excerpt - I like that part, too.
19:56:15 <jchia_1> In a Set or Map, can do a lookup for the ith largest or smallest item?
19:56:18 <kadoban> c_wraith: neat
19:56:40 <c_wraith> jchia_1: definitely in Set, probably in Map.
19:56:50 <c_wraith> jchia_1: (only probably because I'm not 100% certain)
19:56:52 <jchia_1> c_wraith: Is there a function? I couldn't find one
19:57:12 <jchia_1> elemAt
19:57:13 <c_wraith> findMin
19:57:41 <c_wraith> and or findMax
19:57:49 <c_wraith> that appears to be the name for both
19:58:01 <jchia_1> I couldn't find it on the haddock by manual scanning. later I did a text search for 'Int ->' and found it.
19:58:35 <c_wraith> oh, I missed 'ith".  heh.  Well, you did find what you were looking for.
19:59:03 <kadoban> Huh, I never noticed showTree in Data.Map, that looks helpful.
19:59:07 <MarcelineVQ> you can also step some minView's
20:00:24 <c_wraith> MarcelineVQ: that's a lot more work...  You can descend directly to a particular index with Map's representation
20:00:49 <MarcelineVQ> I forgot you can just ask the Set size ehe, so elemAt makes a lot more sense
20:09:26 <LordBrain> whats out there for spotting clusters in data?
20:10:11 <c_wraith> just add more dimensions.  If you add enough dimensions, all data is clustered.
20:11:06 <c_wraith> (there's a theorem to that effect somewhere - the upshot is that you shouldn't be looking for clusters in very-high-dimensional spaces)
20:33:56 <jchia_1> Question about vector-sized. What's an efficient way to write/modify one element? In the documentation I see only functions for bulk updates, not single updates. It seems that I have to use withVectorUnsafe?
20:34:36 <Welkin> just update that one element
20:34:55 <Welkin> what library are you talking about? Data.Vector?
20:35:48 <jchia_1> Welkin: vector-sized package, Data.Vector.Sized
20:37:25 <Welkin> it's not different than for vector
20:37:35 <Welkin> just use a list of one pair for the update
20:38:01 <c_wraith> if you're doing a lot of single-element updates, question whether it's the right data structure for you
20:38:24 <Welkin> there are also mutable vectors
20:38:35 <Welkin> you can `write` directly to the index
20:38:58 <jchia_1> Welkin: OK, I see Vector.Data also has no specialized single-element update function.
20:40:21 <jchia_1> Welkin: But Data.Vector has 'modify' that seems to provide some in-place efficiency. Data.Vector.Sized doesn't have 'modify'.
20:41:21 <Welkin> I'm not sure why you want to use vector-sized
20:41:27 <Welkin> what exactly does it do?
20:41:38 <jchia_1> Welkin: I know at compile-time that my vector size is fixed
20:42:04 <jchia_1> The content can change but the size is fixed
20:42:19 <Welkin> the size of your vector is always fixed
20:42:32 <Welkin> if you change the size, it's a new piece of memory
20:43:24 <jchia_1> Welkin: Fixed by the type
20:43:26 <Welkin> I don't understand the benefit
20:43:37 <Welkin> even so
20:44:17 <jchia_1> Welkin: How do you ensure that at run-time the vector doesn't 'go crazy' by becoming the wrong size?
20:44:45 <Welkin> you could also just use Array
20:46:32 <Welkin> Vector will change the size automatically by copying the data
20:46:45 <Welkin> array will not and requires explicit creation of a new array if you want to change the size
20:47:47 <jchia_1> Welkin: OK, but I think Array has no hope of in-place updates. At least it seems so from lack of something like Data.Vector.modify
20:48:23 <Welkin> http://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array-MArray.html
20:48:41 <Welkin> mutable arrays
20:48:42 <Welkin> http://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array-MArray.html#g:4
20:50:47 <Welkin> There is also STArray, of course
20:51:08 <jchia_1> Welkin: Isn't it better to avoid the 'impurity' of Monads if I can?
20:51:22 <Welkin> there is nothing impure
20:51:47 <Welkin> it is best to avoid mutation if possible, yes, even if the mutation is safe
20:51:58 <Welkin> it's more complicated to read and write
20:52:04 <EvanR> in place updates on purpose is imperative and critical to many algorithms
20:52:13 <EvanR> thats just how they are written
20:52:25 <jchia_1> I have to use it in some Monad. Since MArray requires a monad doesn't everything that uses it have to be defined in the context of a Monad? I can't just have simple functions anymore.
20:52:29 <EvanR> do youd want to use something like donotation
20:52:41 <EvanR> jchia_1: no
20:53:25 <EvanR> you can use ST actions from "simple functions" and you can use simple functions from inside the ST action
20:53:54 <Welkin> jchia_1: a list is a "monad"
20:53:59 <Welkin> almost everything is a monad
20:54:07 <c_wraith> Int is not a monad. :P
20:54:10 <EvanR> no theres only like 19 different monads
20:54:34 <EvanR> in my survey from a few days ago
20:55:06 <jchia_1> EvanR: I think you mean that in my 'simple' function, I can 'run' an ST monad where I deal with the MArray, and outside the 'simple' function, nobody needs to know that inside I'm dealing with the monad that MArray requires. Is that right?
20:55:15 <EvanR> right
20:55:28 <Welkin> ST is very powerful
20:55:33 <jchia_1> OK, I'll try that. Thanks.
20:55:34 <EvanR> you can use mutable arrays inside of the pure function and stay pure
20:56:06 <Welkin> read my favorite paper on it here: https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf
20:56:16 <kadoban> ST is really nice. I do wish array access syntax was a tad more concise, but it's a small gripe.
20:56:36 <EvanR> needs more mixfix operators ;)
20:56:49 <EvanR> x [ i ]= 3
20:56:55 <kadoban> Heh, yeah.
20:57:24 <kadoban> I find myself wishing I could just write C-ish in those blocks sometimes. But then big parts of cool haskell stuff still abound. Probably would be hard to mix.
20:57:53 <Welkin> http://hackage.haskell.org/package/inline-c
20:59:38 <jchia_1> If I want to implement a IArray Int Char -> IArray Int Char, using runST inside on an MArray Int Char, I would need freeze and thaw at some point, correct? How do I avoid making a copy of the IArray in cases where the old array is no longer needed?
21:01:00 <EvanR> well if you stay inside of the ST action, you would use them like mutable arrays
21:01:02 <jchia_1> I.e. how do I do in-place modification under-the-hood in cases where I don't care about the old IArray after getting the new IArray.
21:01:18 <EvanR> you wouldnt use IArrays
21:01:31 <MarcelineVQ> kadoban, Welkin: https://github.com/ambiata/jetski :o
21:02:15 <EvanR> to save an array for later and end the ST action, youll need to do freeze and thaw
21:02:23 <jchia_1> EvanR: Is there a way to have the efficiency of in-place modification without explicitly dealing with ST? It seems that Data.Vector.modify allows this sort of in-place modification.
21:02:31 <EvanR> sure you can use IO
21:02:42 <EvanR> with Array or Vector
21:02:43 <jchia_1> EvanR: Nor IO. Not using any monadic context.
21:03:12 <EvanR> well, how about an Applicative context ;)
21:03:31 <EvanR> exactly what is the type of the operation you want /
21:03:32 <kadoban> MarcelineVQ: Heh, that's cute. Though what I was talking about is just writing ST code like C, not it actually *being* C hopefully
21:04:08 <jchia_1> EvanR: I'm trying to implement a circular buffer without having to express operations in terms of functions that run in a Monad.
21:04:16 <glguy> jchia_1: operations like accum allow for that
21:04:57 <glguy> None of these are going to tell you start and top the operations, however
21:05:30 <jchia_1> push :: a -> CircularBuffer  a n -> (a, CircularBuffer a n)
21:05:42 <EvanR> ok
21:05:44 <jchia_1> Push a new item and the oldest item pops out.
21:05:51 <EvanR> and you promise not to use the old one
21:06:37 <jchia_1> EvanR: I could promise not to use the old circular buffer but it would be nicer if it's smart and do in-place update iff appropriate, like Vector.modify, though I don't actually know how smart it is.
21:06:43 <EvanR> you can use unsafeFreeze and unsafeThaw, but if this is library code you cant really expect the user code to "just be careful"
21:07:41 <glguy> That's a good way to create bugs for yourself, not a serious solution
21:07:57 <EvanR> yes i dont see a good way to make that safe
21:08:48 <EvanR> segfaults in haskell are even worse than in C
21:08:54 <EvanR> i say
21:09:19 <EvanR> we dont have valgrind to identify where you did something bogus
21:09:47 <EvanR> linear types can help you not use the old version, but then, that is a lot like what ST would do for you
21:10:58 <jle`> i keep on running into situations where linear types would have helped me debug code
21:11:06 <jle`> can't wait for ghc 8.4
21:11:19 <jchia_1> EvanR: I think under the hood, if I use a Vector to store the values, I can use Vector.modify and hope it does the right thing in terms of in-place update, but it doesn't enforce the vector size is fixed.
21:11:21 <EvanR> wait what will be in 8.4? o_O
21:11:51 <EvanR> jchia_1: i dont think thats going to do what you want
21:12:14 <EvanR> if you just want a hope, then hope and use a normal immutable data structure
21:12:26 <jchia_1> EvanR: Doesn't Vector.modify do in-place update when it's safe to do so?
21:12:37 <EvanR> i.e. if youre ok with bad performance of copying vectors, use a tree instead
21:12:43 <jchia_1> EvanR: Do you mean that in many normal cases, it can't figure out that it's safe?
21:12:56 <EvanR> i doubt it will actually reuse space
21:13:22 <jchia_1> "Apply a destructive operation to a vector. The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise."
21:13:27 <jchia_1> Bogus documentation?
21:13:29 <glguy> modify will only be able to avoid the copy in the extreme cases
21:13:43 <EvanR> perhaps it should say "big IF"
21:13:59 <jchia_1> I've been using Vector.modify assuming that it can figure out the safety of in-place update with reasonable accuracy.
21:14:00 <EvanR> more likely it will run that ST action and the end result will be copied back to you
21:14:30 <glguy> Only count on modify avoiding a copy when you're modifying a vector that you just created in the same function body, basically
21:14:45 <glguy> like you wrote:: modify stuff (fromList alist)
21:16:09 <EvanR> in the code, it begins by doing clone
21:16:52 <EvanR> so you arent going to be dealing with the same space that has seen any action before
21:17:27 <glguy> modify relies on fusing RULES to avoid copies, so it's only going to work if (after optimizations) the created vector is a direct argument of modify
21:18:25 <glguy> It doesn't do anything clever to check that there are no other references to an arbitrary vector and then modify it inplace
21:19:27 <EvanR> a safe ring buffer that looks immutable and pure is going to take some more engineering and thought
21:19:36 <EvanR> im not sure how it would work
21:19:53 <jchia_1> It seems that the corollary of this is that generally if I want to improve performance by doing in-place updates, I can't depend on Vector.modify and need to do all the updates in ST on some other monads on a mutable data structure.
21:20:05 <EvanR> probably IO
21:20:07 <glguy> old-timey approach https://hackage.haskell.org/package/diffarray-0.1.1/docs/Data-Array-Diff.html
21:21:00 <EvanR> also are you seeing performance issues with immutable buffers?
21:21:24 <EvanR> if so, maybe try a functional queue
21:21:54 <jchia_1> EvanR: It depends on the performance requirement. Faster is always preferable.
21:22:07 <EvanR> i mean, have you measured it against realistic workload?
21:22:13 <EvanR> or premature optimization
21:22:16 <jchia_1> But on a large buffer, copying is surely going to be a problem.
21:22:53 <jchia_1> No, I haven't, but I'm trying to get the benefit of functional programming without losing the asymptotic performance I can get from imperative.
21:23:10 <EvanR> well if its asymptotic performance... check out the functional queue structure
21:23:15 <james9999> imperative programming gives asymptotic performance?
21:23:38 <EvanR> for real performance, youll need to really test it
21:23:40 <codygman> Would anyone like to help me figure out why I can't reproduce the techempower framework benchmarks Haskell performance? I have this issue open with some details: https://github.com/TechEmpower/FrameworkBenchmarks/issues/2800
21:23:57 <jchia_1> If I have a circular buffer of size m and a total of n items to push (and pop), imperative gives me O(n) but functional with copying of array/vector gives me O(mn)
21:24:38 <jchia_1> EvanR: Yeah, I agree, the actual performance is what matters in a real project.
21:25:28 <EvanR> jchia_1: and functional queue is amortized O(1) for push or pop 1, assuming its a fixed total size
21:25:39 <EvanR> so same as imperative
21:26:29 <EvanR> the structure Queue a = Queue [a] [a]
21:26:42 <EvanR> which holds both ends of the queue in opposite directions
21:38:51 <c_wraith> though as Okasaki pointed out, it's only O(1) amortized in non-persistent use
21:39:10 <EvanR> non persistent?
21:40:30 <nshepperd> it can be O(1) persistent too, with lazily reversing the queue depending on length, or something like that
21:40:42 <jchia_1> What does it mean by 'persistent'?
21:41:01 <c_wraith> nshepperd: yes, but that's a different data structure :)
21:41:06 <EvanR> sometimes persistent means exploiting sharing
21:41:23 <c_wraith> in this case, it means being exploited by sharing. :)
21:41:31 <EvanR> ok
21:41:46 <nshepperd> 'persistent use' meaning you can modify an old version of the datastructure and still expect the bounds to hold overall
21:43:08 <c_wraith> Whereas in the trivial version, if you reach the state where the next pop will move the back to the front, that's an O(n) cost, and you'll pay it every time you do the pop.
21:43:17 <EvanR> ah
21:43:32 <EvanR> so it should work ok for jchia_1 who is expecting to only use the latest version
21:43:48 <kadoban> Yeah, it works like a champ in that case.
21:43:56 <dfeuer> There are also different levels of persistence. Partial persistence (can read old copies but not modify them), full persistence (can read and write old copies), and confluent persistence (can read, write, and combine old copies).
21:44:54 <dfeuer> Basically everything written in plain Haskell is confluently persistent, but not always efficiently so.
21:49:41 <dfeuer> I'm really not seeing how Pipes.Internal.unsafeHoist is even slightly unsafe. I understand that its MonadTrans instance is only valid under a certain equivalence, but I can't understand what the heck that has to do with hoisting.
21:56:59 <sproingie> says in the docs: "This is labeled as unsafe because you will break the monad transformer laws if you do not pass a monad morphism as the first argument"
21:59:41 <sproingie> so more "unsound" than unsafe, but convention is what it is
22:02:40 <nshepperd> the relevant equivalence is that M (pure r) ~= Pure r? that certainly doesn't seem interesting enough to call anything 'unsafe'
22:05:05 <nshepperd> err, M (pure (Pure r)) i guess
22:33:57 <jle`> man how come haskell questions on stack overflow get answered so fast
22:35:04 <MarcelineVQ> you can trade in answer points for bitcoin
22:35:37 <lucklove> Good idea
22:35:40 <MarcelineVQ> suddenly a new platform was born..
22:36:53 <mrkgnao> so I have this toplevel binding that is a Double, but if I write the type signature I get "no instance for" errors
22:37:25 <jle`> sounds like a question that can only be answered by pasting the code and the error message
22:37:40 <mrkgnao> GHC can infer the type fine, but won't let me write it. (I did have to muck with -fsolver-constraint-iterations for this, so I might be in uncharted territory here.)
22:37:46 <glguy> mrkgnao: You can put the code and error on lpaste.net
22:39:05 <EvanR> jle`: haskell, winning the talked-about-on-programming-sites to being-actually-used ratio
22:39:23 <mrkgnao> http://lpaste.net/6432103543150215168
22:39:54 <glguy> mrkgnao: The definition of Ring is missing
22:39:57 <mrkgnao> but there's a lot of code behind the Ring Add Mul r constraint
22:40:28 <mrkgnao> https://github.com/mrkgnao/noether/
22:40:41 <glguy> (RingS 'Add 'Mul Double) -- why didn't this reduce? Is RingS a type family?
22:40:55 <jle`> can you reproduce the error in a minimal self-contained file
22:40:55 <mrkgnao> https://github.com/mrkgnao/noether/blob/master/library/Noether/Algebra/Linear/Modules.hs
22:41:27 <mrkgnao> Yes, but there is an instance defined for it elsewhere. If I remove the q :: Double type signature and load it into GHCi, :t q says Double.
22:42:02 <mrkgnao> glguy: https://github.com/mrkgnao/noether/blob/master/library/Noether/Algebra/Multiple/Strategies.hs#L39 defines the type instance
22:42:36 <mrkgnao> jle`: I'm not really sure I can, the code is spread out somewhat suboptimally.
22:42:38 <mrkgnao> :(
22:42:43 <jle`> :(
22:42:58 <glguy> mrkgnao: You should be careful to ' tick your lifted data kinds
22:43:27 <mrkgnao> and I was foolish enough to put -fno-warn-unticked-promoted-constructors into my package.yaml. 
22:43:41 <glguy> and using package.yaml limits your audience
22:44:28 <mrkgnao> does it cause trouble apart from '[], in general? none of my promoted datatypes share names with constructors. I guess as a matter of good practice, though, I should put in the effort.
22:45:26 <glguy> mrkgnao: What does:   :kind! RingS Add Mul Double    show in GHCi?
22:45:40 <mrkgnao> I've removed the cabal file from the gitignore
22:46:58 <mrkgnao> glguy: it's sort of long, essentially listing how the different parts of the ring structure fit together.
22:47:00 <mrkgnao> http://lpaste.net/6432103543150215168
22:47:32 <glguy> mrkgnao: well, it needs to reduce ot Double, not that, right?
22:47:33 <glguy> p :: Ring Add Mul r => r -> r -> r
22:47:53 <glguy> OH, I'm seeing RingK and Ring
22:48:07 <mrkgnao> no, Ring Add Mul r = RingK Add Mul r (RingS Add Mul r)
22:48:28 <mrkgnao> the last parameter to RingK defines the ring structure, essentially. r is Double.
22:48:30 <mrkgnao> yep
22:49:47 <mrkgnao> I think I have some kind of cycle in my constraint types somehow that GHC ignores while solving constraints without the annotation, but if the annotation is there, it somehow solves them in the wrong order and hits a dead end
22:50:32 <mrkgnao> the -fconstraint-solver-iterations thing is a bad sign, too
23:04:07 <cocreature> jle`: related https://ro-che.info/ccc/images/icfp.png
23:12:44 <jle`> ha
23:25:53 <Myrl> Is `a -> a` not a monoid?
23:26:22 <jle`> it is
23:26:51 <jle`> but not necessarily a Monoid
23:26:56 <cocreature> Myrl: https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Monoid.html#t:Endo
23:27:07 <Myrl> jle`: Not necessarily?
23:27:13 <Myrl> cocreature: Thanks.
23:27:17 <jle`> yeah, the instance you are thinking of is not the default instance
23:27:25 <Myrl> Oh.
23:27:28 <jle`> but (a -> a) is a Monoid when a is also a Monoid instance
23:27:32 <Myrl> jle`: Monoid a => (a -> a) ?
23:27:35 <jle`> yes
23:27:40 <mrkgnao> glguy: if I change the type signature from q :: Double to q :: Ring Add Mul Double => Double, then it works
23:27:46 <aussie> Dumb question (sorry) -- what is the syntax for creating a unboxed vector of unboxed vectors?
23:27:47 <Myrl> jle`: Yeah, thanks. Was reading the instances.
23:27:47 <jle`> that is the default instance (actually Monoid a => r -> a)
23:28:03 <Myrl> jle`: Makes sense though. That's probably more useful.
23:28:16 <Myrl> jle`: I was thinking of using that instance for Writer.
23:28:26 <jle`> yeah, Writer (Endo a) is a common trick
23:28:29 <jle`> popularzed by ocharles 
23:28:32 <Myrl> :o
23:28:38 <cocreature> huh, Iâ€™ve never seen that
23:28:40 <mrkgnao> I think it's because there are multiple ways to "find" the Semigroup/Group/etc. instances for + and / by moving through the superclasses
23:28:41 <Myrl> jle`: How do they use it?
23:29:16 <aussie> I thought I could do fromList [ fromList [1..5]] but there are errors with the inferred type
23:30:06 <jle`> i suppose i can't say "common trick" then
23:30:12 <jle`> aussie: it would help to post the error
23:30:22 <jle`> Myrl: https://ocharles.org.uk/blog/posts/2013-02-12-quick-dsls-with-endo-writers.html
23:30:32 <nshepperd> (the (r -> a) instance is a special case of the more general (Monoid a, Applicative f) => Monoid (f a) which isn't an actual instance because it would overlap with everything)
23:30:39 <jle`> it's mostly used to abuse do notation
23:31:23 <glguy> https://github.com/glguy/advent2016/blob/master/asmprog-final/Main.hs
23:31:42 <Myrl> jle`: lmao. That's *exactly* what I was thinking of.
23:31:45 <glguy> I had two example of Endo and writer in that code
23:32:06 <Myrl> jle`: It's a bit like a lesser State monad.
23:32:23 <jle`> yeah, Writer is basically a restricted State
23:33:14 <cocreature> Writer is one of the first Monad instances that Iâ€™ve learned about but for some reason I never use it
23:33:15 <aussie> I get "Non type-variable argument in the constraint: V.Unbox (V.Vector a) When checking the inferred type"
23:33:16 <aussie>  when running V.fromList [V.fromList [1..5]]
23:33:58 <Myrl> cocreature: I guess it's because it's introduced as (String, a)?
23:34:03 <jle`> yeah, writer is pretty abused as well
23:34:12 <cocreature> Myrl: nah, I just have no use for it
23:34:15 <Myrl> cocreature: Which we more or less just do with `trace`
23:34:20 <Myrl> cocreature: Interesting.
23:34:24 <jle`> aussie: guess what the next line of the error message is
23:34:26 <jle`> :)
23:34:29 <cocreature> I donâ€™t even use State very often
23:34:31 <Myrl> cocreature: That's true though. 2 years into Haskell, and only now do I feel like I need to use it.
23:34:35 <jle`> (it will probably be hints to fix resolve the error)
23:34:57 <jle`> although i don't blame you, people usually don't read past the first line of error messages
23:35:05 <Myrl> cocreature: And not because *I* need to use it, but because I want to play well with the library I'm using.
23:35:06 <jle`> i wonder if there could be better UX for this
23:35:49 <cocreature> Myrl: remember that the implementation in transformers is also prone to spaceleaks. you might want to use writer-cps-transformers instead
23:36:07 <glguy> I think most of the writer abuses come from thinking of it for logging
23:36:51 <jle`> in my personal thing, Writer is abused because `Writer w ()` is just `w`
23:36:59 <jle`> and you can use mconcat instead of do notation
23:37:01 <Myrl> glguy: Mhm. THat's what I'm thinking too.
23:37:47 <jle`> if you really like do notation, better to just use `forall a. Const w a`
23:37:49 <mrkgnao> jle`: do you think Haskell will ever gain something like "extensible syntax" (i.e. do-as-a-library stuff)
23:37:55 <cocreature> for small strict monoids, i.e. Sum Int, the default Writer implementation is shitty and for larger monoids, e.g. loggin, you usually want to stream the results
23:37:57 <mrkgnao> ?
23:37:58 <nshepperd> the big three (Reader, Writer, State) are more often used as monad transformers ime
23:38:16 <nshepperd> but i've never seen WriterT used in the wild either so
23:38:17 <Myrl> nshepperd: RWST. :D
23:38:41 <EvanR> RWST IO
23:38:44 <jle`> Writer is the spiritual progenitor of a lot of kinda-monads in the wild though
23:38:46 <EvanR> all youll ever need
23:39:00 <jle`> people might not explicitly use Writer from transformers, but they implement the same monad/API
23:39:05 <Myrl> jle`: Kinda-monads?
23:39:07 <jle`> like blaze's HTML monad
23:39:23 <jle`> kinda-monads in that yes they are monads but they aren't really used as monads
23:39:25 <nshepperd> yeah, that's true
23:39:36 <cocreature> jle`: ah yeah the various HTML libraries are a good example
23:39:42 <jle`> Writer itself is a bad implementation, but the abstract Writer API is nice
23:39:47 <cocreature> yep
23:40:13 <nshepperd> and sometimes I write free monads with tell-like primitives
23:40:30 <glguy> blaze's type is pretty different in implementation from writer
23:41:14 <jle`> but now that we have Applicative-do, we can just repliace `Writer w` with `Const w`
23:41:17 <jle`> let's do this
23:41:31 <jle`> um pun not intended
23:42:59 <jle`> now we just need ConstT
23:44:34 <jle`> Writer is very rarely ever used properly, in a way that Const would do just as fine
23:44:47 <jle`> Writer w () is actually a big haskell pet peeve of mine
23:45:32 <ph88> hey jle` i was trying your code https://bpaste.net/show/bf17ad8f2e9d  can i still use <|> when i need to do IO ?
23:46:29 <nshepperd> data ConstT r m a = ConstT r  --  hope you enjoyed your m, suckers
23:46:46 <cocreature> ph88: oh btw, foldl support is now back in conduit-extra and there is a new 1.1.16 release for it
23:46:47 <ph88> m & m
23:47:01 <ph88> cocreature, sweet ! is that by your doing? :P
23:47:05 <cocreature> ph88: yep :)
23:47:08 <ph88> eheh
23:47:10 <jle`> data ConstT w m a = ConstT (m w)
23:47:19 <ph88> show me what you did
23:47:20 <jle`> ph88: it depends on the type of your thing
23:47:36 <ph88> what thing ?
23:47:44 <jle`> the thing you are using <|> with
23:48:07 <jle`> oh i see
23:48:21 <jle`> yeah, you can use traverse insead of fmap
23:48:28 <jle`> to get `IO (Maybe a)`
23:48:35 <ph88> i've a feeling sampleTime itself then also will be IO  once i start trying to make that code work
23:48:45 <jle`> which has an Alternative instance if you wrap it in MaybeT
23:48:49 <cocreature> are packages in stackage nightly automatically included in the next major stackage lts?
23:48:52 <jle`> or you can just write <|> directly i suppose
23:49:17 <glguy> jle`: Writer e () isn't always bad, it's a very reasonable final type. in the course of building a value of that type one is likely to use other non () types
23:49:24 <jle`> yes
23:49:25 <ph88> jle`, isn't that right that sampleTime itself will be wrapped in IO ?
23:49:45 <jle`> if your entire program only ever uses Writer e (), that is the specific pet peeve i have
23:50:29 <mrkgnao> TIL: apparently your own infix alias for (,) :: Constraint -> Constraint -> Constraint won't work like the real one
23:50:37 <jle`> ph88: yeah, so you can use sampleTime <- runMaybeT $ (MaybeT (return st)) <|> (MaybeT (traverse getSampleTimeAverage tcol))
23:50:38 <mrkgnao> that was the source of all my trouble. :(
23:51:08 <jle`> ph88: or if you don't like wrapping and unwrapping MaybeT, you can just write your own (<|>) :: IO (Maybe a) -> IO (Maybe a) -> IO (Maybe a)
23:56:08 <ph88> jle`, i arrived at this now https://bpaste.net/show/80b2e5ba17e2
23:57:15 <jle`> yeah, that's fine, although in this specific case, i think maybe MaybeT might be overkill
23:57:26 <jle`> you can just write sampleTimeIO :: IO (Maybe a) by hand using do notation
23:57:38 <jle`> probably the cleaner way to go
23:57:51 <ph88> ye ok but i still have an error there which i don't know why it is appearing
23:58:16 <jle`> is it a compile error or a runtime error
23:58:31 <ph88> oh it's sublime text auto complete to the wrong function name
23:58:38 <ph88> ye ok works now !
23:58:42 <jle`> :D
23:58:42 <ph88> but i will try to remove MaybeT
23:58:55 <jle`> yeah, MaybeT is more useful if you have a lot of things to MaybeT-together
23:59:07 <jle`> if it's just one or two things like in this situation it is admittedly a bit silly
