00:00:13 <kadoban> Otherwise ongy's thing seems fine. You can use (:[]) instead of 'pure' if that floats your boat.
00:00:29 <aussie> I should've stated that the string may have non-digit chars in it, so "12a4" should become [Just 1, Just 2, Nothing, Just 4]
00:00:41 <[exa]> What is the best symbol for the reversed (.) function concatenation?
00:01:20 <[exa]> like in f.g.h = \x -> h (g (f x))
00:01:41 <MarcelineVQ> reversed composition? often that's denoted as &
00:02:14 <MarcelineVQ> er
00:02:19 <MarcelineVQ> I'm an idiot, I'm thinking of $
00:02:23 <kadoban> Isn't (&) flipped ($), ya.
00:02:37 <kadoban> [exa]: I use .- for that, but it's just something I made up.   (>>>) exists and is a more polymorphic version of (flip (.)), but the precedence is not similar
00:03:07 <[exa]> .- looks cool, writes faster than &
00:03:22 <[exa]> will try all of them, gonna see. Thanks!
00:03:53 <kadoban> 'welcome. Don't get too used to it, it's a little weird for readability.
00:04:02 <kadoban> I really only use it for competitive programming
00:04:43 <[exa]> I actually struggle everytime I see . used; the order of functions isn't right. :]
00:05:08 <EvanR> heh
00:05:09 <kadoban> You get used to it. It's easy enough for me to read and write, but the actual typing is annoying and awkward.
00:05:27 <EvanR> f . g = f(g( ))
00:05:41 <EvanR> cant argue with that
00:06:25 <[exa]> maybe I should stop visualising a.b.c.d as a unix pipe
00:06:40 <EvanR> yes, unix pipes are totally backwards!
00:06:46 <[exa]> :]
00:06:49 <EvanR> or f(x) is backwards
00:07:10 <EvanR> how about everything is official backwards
00:09:19 <jle`> [exa]: even when you originally wrote it, it's clear that it's backwards, heh
00:09:27 <jle`> you wrote f . g . h = \x -> h (g (f x)))
00:09:43 <jle`> wouldn't it make more sense for f . g . h = \x -> f (g (h x))    ...?
00:09:48 <jle`> then you do'nt have to flip anything around awkwardly
00:11:07 <jle`> it was your example, not mine :)
00:16:08 <nshepperd> you can use >>> as reversed .
00:16:32 <nshepperd> from Control.Category
00:17:10 <nshepperd> oh kadoban already said that
00:20:01 <[exa]> the actual purpose is to be able to start the transformation with a value
00:20:19 <[exa]> like (dumb example:) (5.-(+1).-(*2).-(+1))
00:21:06 <[exa]> and I expected that (.- f1 .- f2 .- f3) would parse in haskell as a function with auto-added lambda variable, but it complains about fixity
00:21:41 <jle`> why didn't you ask that in the first place, heh
00:21:57 <jle`> sometimes people like doing 5 & (+1) & (*2) & (+1)
00:22:02 <jle`> but it's not quite idiomatic
00:22:53 <[exa]> I like it for filter syntax, like bunchOfStuff & removeBad & convertToMyFormat & sort & uniq
00:23:09 <[exa]> (sorry couldn't resist the sortuniq god)
00:29:22 <jle`> it can be nice, but it'll definitely make your code less readable to 95% of haskell users
00:29:36 <jle`> so if you don't care about writing idiomatic code, i can't stop you :)
00:32:09 * [exa] feeling minoritish
00:32:23 <cocreature> I think that style is becoming more popular recently
00:32:40 <cocreature> we even have & in base by now
00:33:03 <Mibaz> Does anyone know what the arrow notation keyword "proc" stands for? Also, how do you think about "proc x -> do"? I get that it starts a block of notation but where did they come up with that specific notation?
00:33:36 <kadoban> Seems weird it's only & though. You never see strings of   blah $ stuff $ whatever, yet  whatever & stuff & blah is the only nice way to write it from base that direction.
00:33:48 <Mibaz> when I say "specific notation" I mean "proc x -> do". It's a coherent thought I swear.
00:34:13 <cocreature> kadoban: you never see “blah $ stuff $ whatever”? I see that quite often
00:34:48 <kadoban> Really? I only ever see   blah . stuff $ whatever, maybe I'm just not reading enough varied haskell code.
00:35:03 <cocreature> it’s not a style I use but I definitely see it used by others
00:35:19 <cocreature> personally I’m a "(blah . stuff) whatever" kind of person
00:36:10 <kadoban> Hm, interesting. I don't see that much, but I don't mind that at all, seems to make some sense.
00:37:04 <EvanR> you can also let p = f . g . h . i . j . k . l . m . n . o
00:37:07 <EvanR> and then later p x
00:38:12 * quchen likes to do »(f . g . h) x«.
00:38:58 <quchen> But I’m a bit extreme with HLint failing when there’s a ($) in my code.
00:43:06 <cocreature> quchen: ex-lisper? :)
00:44:38 <jle`> i am a prescriptionist and i will refuse to recognize x & f & g & h and h $ g $ f $ x as ok things
00:45:17 <jle`> you gotta draw the line somewhere
00:45:22 <jle`> this is my stand
00:45:22 <quchen> cocreature: Nope, I’m using infix (.) :-)
00:45:40 <cocreature> heh good point
00:46:13 <EvanR> question, can haskell accomplish overengineering in only 60 lines of code?
00:46:18 <EvanR> yes! haskell can do that!
00:46:20 <EvanR> http://lpaste.net/355522
00:47:09 <quchen> Overengineering is a one-liner in Haskell!
00:47:25 <EvanR> it will refuse to accept an exception when saving high scores, keeping trying until healed, and keep the local cache of scores up to date
00:47:30 <quchen> What you posted is a god(awful) function.
00:47:33 <jle`> explicit mutual recursion so obviously it is underengineered
00:47:47 <EvanR> very goto
00:47:53 <quchen> Needs more Cont
00:48:15 <jle`> it is actually very accurately described as GOTO code
00:49:59 <EvanR> parallel branching goto code
00:51:47 <[exa]> my favorite so far:  treatment <- async doctor
00:52:14 <quchen> Where is this from?
00:52:39 <quchen> doctor = intro where intro = do ಠ_ಠ 
00:55:04 <EvanR> right well
00:55:23 <EvanR> got a better way to write that?
00:55:51 <EvanR> i guess a fix loop
00:56:14 <quchen> doctor = do
00:56:20 <quchen> = is transitive ;-)
00:57:00 <EvanR> theres two things in that where clause
00:58:14 <cocreature> you can still use the where for go
00:59:00 <EvanR> and it woul need to be awkwardly floating somewere south, south east of the do?
00:59:17 <EvanR> feel free to edit that lpaste
01:01:43 <cocreature> I wonder if you can shove that code in MealyT
01:02:18 <EvanR> the doctor code?
01:02:33 <ongy> what's Mealy?
01:02:40 <cocreature> no basically everything except the doctor code
01:02:47 <cocreature> it seems like you are implementing a state machine
01:02:57 <EvanR> well, two states 
01:03:16 <EvanR> with some refactoring so i dont have to duplicate parts
01:03:43 <EvanR> i would be interested to see if something like that decreased the amount of code
01:04:19 <Lokathor> http://lpaste.net/355523 this is pretty much how normal ExceptT code looks, right?
01:04:37 <cocreature> doubt it but I’mve never really used machines, so maybe I’m wrong
01:05:10 * EvanR looks up MealyT
01:05:14 <cocreature> https://hackage.haskell.org/package/machines-0.6.2/docs/Data-Machine-MealyT.html#t:MealyT
01:05:54 <cocreature> Lokathor: you probably want to define loadShader' = ExceptT . loadShader if you use that more than once (which you already do in your example)
01:05:59 <merijn> Lokathor: FWIW, if you find yourself doing this a lot I'd just write wrappers for e.g. loadShader that already wrap ExceptT
01:06:00 <cocreature> and the same goes for linkProgram
01:06:14 <merijn> cocreature: I wouldn't use the prime, just import qualified and shadow the original name
01:06:38 <merijn> i.e. "loadShader = ExceptT . Library.loadShader"
01:06:56 <cocreature> if you only use it in ExceptT then sure but I don’t know if that’s the case
01:07:20 <EvanR> cocreature: looks like at each step a Mealy or MealyT outputs a value of type b. But i never output anything
01:07:21 <Lokathor> i just defined it as, loadShader :: GLenum -> String -> IO (Either String GLuint)
01:07:27 <EvanR> just side effects
01:07:35 <merijn> As usual, cosmetic fixes always depend on context :p
01:07:38 <cocreature> EvanR: just set it to ()
01:07:59 <merijn> Lokathor: other than that it seems fine
01:08:25 <EvanR> i never return at all
01:08:36 <EvanR> just tail calls
01:08:56 <cocreature> MealyT doesn’t return either
01:10:23 <EvanR> whats the input?
01:10:31 <Lokathor> merijn, can you elaborate on what you mean by "wrappers that already wrap ExceptT"?
01:10:53 <EvanR> MealyT is supposed to give you an m (output, next mealyT)
01:10:54 <Lokathor> I'm not sure i follow, because the use of ExceptT is already hidden away it seems
01:11:10 <EvanR> so you could never get to the second sep
01:11:12 <EvanR> step
01:11:33 <EvanR> since my IO action never completes
01:13:08 * hackage ghc-typelits-natnormalise 0.5.3 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.5.3 (ChristiaanBaaij)
01:13:25 <cocreature> EvanR: output is just () and next mealyT is your recursive call
01:13:37 <cocreature> but you’re probably right that your code doesn’t fit the pattern very well
01:13:39 <merijn> Lokathor: Like I said "import qualified ShaderLibrary as Library; loadShader = ExceptT . Library.loadShader" so that you can just use "loadShader" inside the do block without the ExceptT repetition :)
01:13:54 <cocreature> because the inputs for the transitions are different
01:14:53 <EvanR> mode1 takes no input, mode2 takes treatment
01:14:55 <Lokathor> merijn, well there's no library being imported, they're all in one module
01:15:11 <merijn> Lokathor: Then I'd simplify modify loadShader directly? :)
01:15:28 <merijn> Lokathor: If you never use it without ExceptT, that is
01:15:58 <merijn> Lokathor: If you're always wrapping it with ExceptT, then there's no point in not moving that repetition into the function itself
01:16:26 <EvanR> and mode2 enters mode1 half way. this is pretty convoluted
01:16:39 <Lokathor> well the full file is this, https://lokathor.gitbooks.io/using-haskell/content/opengl/hello-triangle2.hs
01:17:03 <Lokathor> i guess at the moment i'm on the fence that i'll never want to load just one shader, rather than a whole program loaded and linked
01:17:52 <merijn> Lokathor: Right, I'd just change it to "loadShader shaderType source = ExceptT $ do"
01:17:54 <EvanR> whoa what is gitbooks
01:17:57 <merijn> (and the type accordingly)
01:19:05 <EvanR> loadShader :: String -> Either ShaderError Shader ... >_>
01:19:06 <Lokathor> merijn, I'll keep this in mind, but i'm a little wary about it simply due to lack of famililarity with ExceptT compared to the non transformed version
01:19:58 <Lokathor> EvanR, no I don't want to hide away any of what's really going on, particularly since this is part of a tutorial
01:20:01 <merijn> Lokathor: ExceptT is litterally just "bail on the first error"
01:20:49 <merijn> Wait!
01:21:05 <Lokathor> merijn, yes I know, but the instant that I make it EitherT, i'll also want to make it MonadIO, and so on, and the focus here should be on the gl library use I think
01:21:07 <merijn> GHC 8 has Fail moved out of Monad?!
01:21:22 <cocreature> merijn: no?
01:21:25 <merijn> oh, not yet
01:21:26 <EvanR> er i mean, IO (Either ...
01:21:30 <merijn> They just add MonadFail
01:21:47 <EvanR> yes you are free to use MonadFail
01:22:08 <EvanR> but probably no one will because the type sucks
01:22:33 <Lokathor> that bad?
01:23:08 <cocreature> the fact that it only allows for String errors makes it mostly useless imho
01:23:50 <Lokathor> that does sound shitty
01:23:50 <EvanR> yes
01:24:12 <EvanR> its being moved out of Monad so it can be forgotten
01:24:32 <cocreature> well, do notation will desugar to it so it can’t be forgotten completely
01:24:38 <Lokathor> if only we could move it out of Monad so that it could be improved
01:24:39 <cocreature> but you’re unlikely to use it for anything else
01:25:04 <TommyC> Query: Is there a term for a function that simply returns the value you give it? i.e. f(x) = x ?
01:25:12 <merijn> EvanR: The great thing about MonadFail is that I'll finally get warnings about partial do patterns
01:25:12 <Lokathor> identity
01:25:22 <merijn> > id True
01:25:24 <Lokathor> and the built in version is simply called "id"
01:25:25 <lambdabot>  True
01:25:38 <EvanR> @src id
01:25:38 <lambdabot> id x = x
01:28:26 <TommyC> Lokathor: Thank you.
01:29:51 <zedik> Hi everyone. Is it possible to do the next thing in Haskell? There is a txt file with a single column of numbers. The program reads the the first number from it and waits for 1 sec. After 1 sec it reads the second number and etc. If it is possible, please point out the direction to look at how it to implement.
01:31:12 <EvanR> yes! haskell can do that!
01:31:38 * hackage ghc-typelits-knownnat 0.3 - Derive KnownNat constraints from other KnownNat constraints  https://hackage.haskell.org/package/ghc-typelits-knownnat-0.3 (ChristiaanBaaij)
01:31:38 <EvanR> what is it supposed to do with the number once it is read
01:31:57 <zedik> add it into the list
01:32:06 <mauke_> zedik: openFile, hGetLine, threadDelay
01:32:36 <cocreature> and readMaybe to convert the string to an int
01:33:24 <mauke_> conversion wasn't a requirement, just reading
01:33:30 <CoolerZ> i am having trouble using Data.Map.Strict.!?
01:33:39 <CoolerZ> it says its not exported
01:33:43 <zedik> Thanks!
01:34:05 <mauke_> cocreature: or readIO
01:34:17 <CoolerZ> Module 'Data.Map.Strict' does not export '!?'
01:34:45 <CoolerZ> is that a new operator that was recently added?
01:34:50 <cocreature> yes
01:34:55 <CoolerZ> do i need to update?
01:35:09 <cocreature> looking at the changelog it’s only in containers >= 0.5.9.1
01:35:27 <CoolerZ> how do i update?
01:35:43 <kadoban> CoolerZ: What build system are you using? (cabal-install or stack perhaps?)
01:35:50 <CoolerZ> cabal
01:37:04 <CoolerZ> do i "cabal install ghc"?
01:38:11 <mauke_> ghc? o_O
01:45:39 * hackage ghc-typelits-extra 0.2.3 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.2.3 (ChristiaanBaaij)
02:05:13 <ertes-w> i need the unix command version of 'inits':  echo 1.2.3 | inits -d. = echo; echo 1; echo 1.2; echo 1.2.3
02:05:15 <ertes-w> any ideas?
02:09:44 <mauke_> ertes-w: echo 1.2.3 | perl -F'\.' -lane 'print join ".", @F[0 .. $_] for -1 .. $#F'
02:11:38 <pja> Ah, the "f*ckit, I’ll just invoke perl" approach. Always a winner.
02:11:52 <mauke_> echo 1.2.3 | perl -lne 'print substr($_, 0, pos) while /\A|(?=\.)|\z/g'
02:12:05 <pja> bonus points for using awk instead.
02:12:33 <mauke_> awk? more like awbsolete amirite
02:12:57 <ertes-w> hmm, if i'm gonna use perl, i might as well just use haskell
02:13:08 * hackage logging-facade-syslog 1 - A logging back-end to syslog(3) for the logging-facade library  https://hackage.haskell.org/package/logging-facade-syslog-1 (PeterSimons)
02:13:19 <mauke_> pretty sure haskell doesn't count as a "unix command"
02:13:54 <ertes-w> maybe i should just give in and use perl for shell scripting =)
02:14:08 <ertes-w> it's as ugly as shell, but it can actually do stuff
02:14:43 <merijn> pja: So, do I get bonus points? https://github.com/merijn/GPU-benchmarks/blob/master/numdiff.awk
02:14:48 <mauke_> my favorite feature: it has actual scoping
02:14:51 <mauke_> (like haskell)
02:14:58 <pja> I think my "quick hack" perl scripts were the things that stayed in production for the longest in my programming career :)
02:15:29 <pja> merijn: :)
02:15:36 <ertes-w> it even has real functions, right?
02:15:45 <pja> perl or awk?
02:15:47 <ertes-w> perl
02:15:51 <ertes-w> does awk?
02:16:01 <merijn> ertes-w: Yes, see my link :p
02:16:11 <pja> yes, awk does too.
02:16:26 <mauke_> ertes-w: yes
02:16:35 <mauke_> perl has a direct embedding of lambda calculus
02:16:42 <ertes-w> by "real functions" i mean first-class functions
02:16:54 <ertes-w> not just "being able to define named procedures" =)
02:17:05 <ertes-w> mauke_: that might sell it
02:17:14 <mauke_> identifier foo: $foo
02:17:27 <mauke_> application X Y: X->(Y)
02:17:50 <mauke_> abstraction \v.X: sub { my ($v) = @_; X }
02:18:06 <ertes-w> ugh!  well…  it's perl after all
02:18:40 <mauke_> (the last part can also be written as sub ($v) { X } but only if you enable the (still experimental) "signatures" feature)
02:19:08 <ertes-w> reasonable function syntax is an extension?
02:19:11 <mauke_> still, it's straightforward and doesn't require a global transformation or anything
02:19:21 <mauke_> yes
02:19:26 <ertes-w> well…  shell isn't much better, so yeah
02:19:44 <mauke_> and there are even some people who like 'my (...) = @_;' better for some reason /shrug
02:19:55 <ertes-w> f($x, $y) { … }  # the "$x, $y" syntax doesn't mean anything in shell, which is quite stupid
02:20:13 <mauke_> personally I'd prefer not having to type 'my' and '= @_' around every parameter list
02:21:27 <merijn> Is there a standard rose tree that has different types for roots and nodes somewhere?
02:22:48 <systadmin> o/
02:24:01 <dibblego> data Tree a b = Node a | Forest [Tree b] -- like this?
02:25:11 <mauke_> kind error
02:25:53 <dibblego> heh
02:25:57 <ertes-w> mauke_: any reason a functional programmer such as myself might prefer perl over other languages there?  i mean: to me PHP, perl, python and ruby all look the same from a distance
02:28:17 <mauke_> ertes-w: PHP and python have awful scoping and I haven't tried ruby
02:28:49 <mauke_> ertes-w: but this sounds more like a topic for #haskell-blah
02:28:54 <merijn> dibblego: More like "data Tree a b = Node a | Forest b [Tree a b]", except without me having to write all the instances, etc.
02:29:06 <ertes-w> mauke_: yeah, probably…  thanks for the inspiration
02:29:30 <mauke_> ertes-w: want to continue there?
02:31:08 <Grisha> Hello everyone
02:31:40 <dibblego> merijn: I don't know of it, sorry, but I have also wanted that, or something similar to that, before 
02:33:35 <Grisha> I’m trying to figure out how to make a nice type family, mapping a type `a` to a type of functions that would, depending ona, accept a different number of, say, strings and produce another string. My main difficulty (or rather an aesthetical disagreement) is that I’ll have to substitute `() -> String` for funcs accepting zero strings. Would there be a way around that ugly ()?
02:34:21 <Grisha> for funcs accepting zero strings, I’d rather like to have constants of type `String`
02:44:33 <merijn> Is there a way to derive NFData/otherwise easily create an instance for it
02:47:46 <Axman6> looks like it can be derived
02:47:48 <merijn> oh, via Generic, of course :)
02:48:03 <Axman6> https://hackage.haskell.org/package/deepseq-1.4.2.0/docs/Control-DeepSeq.html#t:NFData
02:52:22 <phz_> hey, what is the syntax to hardcode unicode points in haskell again?
02:52:31 <phz_> I thought it was \u1245
02:52:31 <merijn> phz_: What does that mean?
02:52:38 <phz_> merijn: literal unicode char
02:52:48 <phz_> '\u1234'
02:53:10 <merijn> phz_: Well, if it's a printable character you can just write it in the source file as unicode directly
02:53:13 <mauke_> '\1234' in decimal
02:53:19 <Axman6> > '\x1234'
02:53:21 <lambdabot>  '\4660'
02:53:32 <mauke_> > '€'
02:53:33 <Axman6> (hex and decimal versions)
02:53:34 <lambdabot>  '\8364'
02:53:42 <phz_> > '\x2E3B'
02:53:44 <lambdabot>  '\11835'
02:53:46 <phz_> nope
02:53:48 <mauke_> yes
02:53:53 <phz_> I want the opposite
02:53:53 <Axman6> o.O
02:53:56 <mauke_> no
02:54:01 <phz_> > '€'
02:54:02 <Axman6> what do you want?
02:54:03 <lambdabot>  '\8364'
02:54:12 <phz_> > '\x8364'
02:54:14 <lambdabot>  '\33636'
02:54:17 <mauke_> you're confused
02:54:19 <phz_> I want the '€' back
02:54:25 <phz_> via its unicode representation
02:54:27 <mauke_> that is a €
02:54:33 <Axman6> > text "\1234"
02:54:35 <lambdabot>  Ӓ
02:54:43 <mauke_> what you're seeing here is the pretty-printed representation you get from 'show'
02:54:43 <phz_> oh so the syntax is just \
02:54:48 <Axman6> what you're seeing is the Show instance for Char
02:55:02 <Axman6> it will be written as the correct character if you putStrLn etc. it
02:55:04 <phz_> > '\2E3B'
02:55:06 <lambdabot>  <hint>:1:4: error:
02:55:06 <lambdabot>      lexical error in string/character literal at character 'E'
02:55:08 <merijn> Ah, the classic print vs putStrLn error
02:55:34 <mauke_> > text "\x2E3B"
02:55:36 <lambdabot>  ⸻
02:55:47 <phz_> hm, ok, thanks
02:56:11 <mauke_> long dash is long
02:56:23 <merijn> phz_: Show produces valid haskell as result, so generally if you see things like \4660 etc in your output it's because you're calling 'show' on a String, rather than outputting it directly
02:56:50 <merijn> phz_: Also, note that ghci automatically calls show on results, so what ghci shows is not the same as what, e.g. putStrLn prints to the terminal
02:57:11 <merijn> Same goes for lambdabot, which is why you want to use text for unicode with it
02:57:11 <phz_> yeah yeah, I remember that
02:57:12 <phz_> thanks
02:57:18 <phz_> :t text
02:57:19 <lambdabot> String -> Doc
02:57:24 <merijn> > "aha \4660 blah"
02:57:26 <lambdabot>  "aha \4660 blah"
02:57:31 <merijn> > text "aha \4660 blah"
02:57:34 <lambdabot>  aha ሴ blah
02:57:57 <merijn> Also note how the quotes disappear with text (which is how, e.g. putStrLn displays stuff)
02:58:04 <mauke_> we're only using text because it produces a Doc, which has a convenient Show instance
02:58:13 <mauke_> (for use in lambdabot)
03:20:53 <CoolerX> how do i open the REPL in emacs?
03:22:28 <plll> Hey, does anyone know how to send a string to the interactive-haskell REPL? The equivalent to comint-send-string (when dealing w inferior haskell). 
03:23:14 <Grisha> I use vim-slime
03:23:18 <plll> CoolerX, C-c C-z. How do you currently have it configured? 
03:23:49 <CoolerX> in haskell mode
03:23:57 <CoolerX> interactive-haskell-mode
03:25:34 <plll> CoolerX, try C-c C-z. Or C-c C-l. 
03:26:11 <merijn> Style question: How do people linewrap long one-liners?
03:26:18 <lpaste> merijn pasted “linewrap?” at http://lpaste.net/355526
03:26:21 <merijn> Like that one
03:27:11 <lpaste> liste annotated “linewrap?” with “linewrap? (annotation)” at http://lpaste.net/355526#a355527
03:27:48 <Aruro> merijn: you call it long?
03:28:02 <merijn> Aruro: I try to stick to <80 chars
03:28:03 <CoolerX> C-c C-z works
03:28:08 <Aruro> you have 80 chars monitor? :)
03:28:22 <Aruro> no need to stick to 80, its oldfashioned.
03:28:25 <liste> 120+ lines are hard to read :<
03:28:33 <merijn> Aruro: No, but I want to be able to have 2-3 editors side by side
03:29:03 <Aruro> then you are not sticking to 80 you are fitting to your needs :)
03:29:22 <merijn> Also, research indicates reading becomes more tiring/annoying if you have to move long distances back to the start of the next line (which is why, e.g., newspapers stick to 66 chars per line)
03:29:28 <Aruro> i like reading one page, so the longer line the better
03:29:47 <Aruro> merijn: same for multipage
03:30:38 <Aruro> "research" have shows that more than 4-5 pages is hard to follow, people forget
03:30:43 <merijn> I'm not sure I like moving the = to a newline
03:31:25 <Aruro> yeah  = has to be with its function
03:31:30 <Aruro> otherwise confusing
03:31:54 <lpaste> merijn annotated “linewrap?” with “I guess this works” at http://lpaste.net/355526#a355528
03:32:08 <merijn> Fortunately short haskell lines are generally easy
03:32:25 <merijn> Linewrapping C++ is a pain...
03:33:59 <Aruro> i think last is most readable
03:34:07 <Aruro> every line is leveling down
03:38:53 <plll> Hey, how do you send a string to the interactive-haskell REPL? The equivalent to comint-send-string (when dealing w inferior haskell). 
03:39:18 <Athas> My haskell-mode with Intero is very slow.  According to the Emacs profiler, a huge amount of the time is spent on fontification.  Have any of you encountered this?
03:39:34 <Athas> The 'haskell-syntax-propertize' function, apparently.
03:57:30 <merijn> There's a union for lists, but is there a difference?
03:58:02 <Cooler> help http://lpaste.net/355529
03:58:22 <merijn> Cooler: What exactly do you need help with?
03:58:30 <Cooler> how do i find out whats wrong?
03:58:39 <merijn> Cooler: You asked for a non-existent key
03:58:53 <Cooler> i know but which key
03:58:53 <LiaoTao> merijn: Do you mean (\\) ?
03:59:04 <merijn> Cooler: You should use Map.lookup, not Map.!
03:59:21 <merijn> LiaoTao: Ah, excellent!
03:59:27 <Cooler> merijn, that won't help
03:59:47 <Cooler> i have only used ! where the key is supposed to exist
04:00:16 <merijn> Cooler: Well, turns out that's apparently a wrong assumption ;)
04:00:22 <LiaoTao> Cooler: Not to be rude, but I think the compiler is more correct than you
04:00:28 <merijn> Cooler: You should lpaste a (minimal) example of the code
04:01:22 <Cooler> merijn, thats the problem, which line
04:01:32 <Cooler> it doesn't post a callstack
04:02:03 <merijn> I think you need to use the profiling runtime to get a full callstack
04:03:19 <Cooler> the what?
04:05:50 <Cooler> guys?
04:06:44 <Cooler> did i dc again?
04:07:31 <mk-61> Cooler: no, you didn't.
04:07:49 <Cooler> ok, whats the profiling runtime
04:07:57 <Cooler> isn't there also a debugger?
04:18:49 <torstein> binding a variable to a name when pattern matching does not force it, given that it's not used, right? I.e. fun (a, _) = a ~ fun (a, b) = a
04:19:42 <Axman6> torstein: correct
04:22:01 <merijn> torstein: Note, that if you write something like "fun (Foo, _) = ...; fun (a, b) = ..." then the first match will force the first element of the tuple
04:22:22 <[exa]> Hm, is there some other reason for disallowing stuff like (+3+3) other than being a bit confusing?
04:22:40 <merijn> [exa]: You can do that, except needs different bracketing
04:22:47 <merijn> :t (+(3+3))
04:22:49 <lambdabot> Num a => a -> a
04:23:16 <merijn> [exa]: Otherwise it's ambigous which operator is sectioned which way
04:23:18 <[exa]> that's exactly what I don't want, I want the inner parent to get around the left plus
04:23:44 <torstein> What's the purpose of associated data types and associates types, and what's the difference between the two? E.g. in https://wiki.haskell.org/GHC/Type_families#An_associated_data_type_example, why not use "data GMap k v = GMap k v" at top level instead of in a class?
04:23:50 <merijn> What does "inner parent" mean here?
04:24:24 <[exa]> hm, do you have an example how it can be ambiguous? I always thought that (+x) is desugared like \v1 -> (v1+x)
04:24:39 <merijn> torstein: Associated types are just fancy syntax for "type families", as for "what are type families?", the simplest summary is "type level functions"
04:25:24 <merijn> torstein: That is, they are types which depend on other types. Data families are data types whose representation depends on other types
04:25:56 <merijn> [exa]: Well, how would (+3+3) be desugared according to you?
04:26:13 <LiaoTao> [exa]: I thought that was just curried from (a->a->a) into (a->a)
04:26:15 <[exa]> in which case (+3+3) would get desugared as \v1->((v1+3)+3)
04:27:12 <merijn> [exa]: Sections are only defined on single operators, what you seem to want is to treat multi-operator sections as composition of individual sections
04:27:35 <merijn> I don't immediately know whether there's an issue with that, but I do feel it's a rather complicated desugaring
04:27:40 <[exa]> oh so.
04:28:04 <[exa]> Well, not that complicated, I actually have it in my pet compiler here, trying to figure out something similar in haskell now
04:28:05 <merijn> torstein: Are you familiar with GADTs and/or DataKinds?
04:28:59 <merijn> [exa]: Anyway, the short answer is probably that the reason for that not being in GHC/Haskell is: 1) confusing and 2) not that commonly useful
04:29:16 <[exa]> a pretty good example is the horner's rule: foldl (*x+) 0
04:29:22 <eminhi> [exa]: (op y) is valid only if (x op y) and (x op (y)) are parsed the same way
04:29:24 <torstein> merijn, Yes, type families too, though I haven't had the need for associated data types yet (the ones declared inside class instance)
04:30:06 <eminhi> (*x+y) is invalid where as (+x*y) should be valid.
04:30:09 <merijn> torstein: ok, so if you're familiar with type families, associated types is just fancy syntax for regular type families to indicate the type family is closely related/tied to some typeclass
04:30:43 <[exa]> well, nevermind, thanks for explanations, I was only suspecting whether there isn't some rationale behind that I wouldn't know about
04:31:50 <merijn> torstein: data families exist so you can have a datatype depending on another type, the same way type families can. Consider the example in the link you pasted, the GMap class is able to use an optimised representation for "GMap Int" since the GMap datatype can change depending on the type you're instantiating the class for
04:32:42 <[exa]> anyway the thing I wanted to be expressed nicely was my struggle with flipped (.) from above; you can do stuff like (object & method1 & pipe & line) but you need to write explicit lambda instead of (& pi & pe & li & ne)
04:32:49 <[exa]> nvm. :]
04:33:00 <merijn> [exa]: There is a flipped (.), thought :)
04:33:03 <merijn> :t (>>>)
04:33:05 <lambdabot> forall k (c :: k) (a :: k) (cat :: k -> k -> *) (b :: k). Category cat => cat a b -> cat b c -> cat a c
04:33:09 <merijn> ugh
04:33:15 <merijn> That's an awful type :)
04:33:24 <merijn> :t (>>>) `asAppliedTo` even
04:33:25 <lambdabot> Integral a => (a -> Bool) -> (Bool -> c) -> a -> c
04:33:27 <[exa]> whoa. :]
04:33:42 <merijn> :t (>>>) `asAppliedTo` (undefined :: a -> b)
04:33:44 <lambdabot> (a -> b) -> (b -> c) -> a -> c
04:34:02 <merijn> [exa]: Ignore the scary poly kind nonsense, it's really secretly "flip (.)" ;)
04:34:05 <merijn> :t flip (.)
04:34:07 <lambdabot> (a -> b) -> (b -> c) -> a -> c
04:34:35 <torstein> merijn, makes sense thank you
04:35:27 <merijn> torstein: And associated datatypes are, just like associated types, fancy notation to indicate a data family is tied to a typeclass. You can define standalone data families too
04:41:37 <[exa]> :t (>>> (+3) >>> (+4))
04:41:39 <lambdabot> Num b => (a -> b) -> a -> b
04:41:49 <[exa]> well, closer.
04:47:29 <ertes-w> merijn: i wonder if there is any difference between an AT and a standalone family
04:47:47 <ertes-w> except that in the former case you can only define instances within the corresponding class instance
04:48:20 <merijn> not afaik
04:49:45 <CoolerZ> how do i use the debugger?
04:50:57 <merijn> CoolerZ: The GHC manual has a chapter on using the debugger in ghci
04:51:22 <CoolerZ> this ? https://wiki.haskell.org/Debugging
04:52:13 <merijn> No
04:52:23 <merijn> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
04:54:32 <CoolerZ> this? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger
04:57:10 <merijn> yes
05:00:32 <CoolerZ> i really want a gui debugger like chrome's developer tools
05:01:02 <merijn> I'm not sure that exists
05:01:25 <CoolerZ> ik but it would be really cool
05:02:43 <makalu> I have a line such as this at the beginning of my .hs file: "#!/usr/bin/env stack\n-- stack --resolver lts-8.13 script --package time". I get this error: "Invalid argument `script'". Has stack script interface changed?
05:06:04 <makalu> oh, I had the opposite problem. My stack version was ancient.
05:11:38 * hackage sqlcipher 1.0.1.1 - Haskell binding to sqlcipher  https://hackage.haskell.org/package/sqlcipher-1.0.1.1 (figo)
05:22:16 <CoolerZ> help
05:22:44 <CoolerZ> trying to use the GHCi debugger, i put a :break on each line that contains Map.! but its still giving an exception
05:25:48 <pie_> hi guys, i installed binary-bits but for import qualified Data.Binary.Bits.Get as Bits ( getBool, getWord8, runBitGet, getWord16be ) im getting Failed to load interface for ‘Data.Binary.Bits.Get’
05:27:08 * hackage github-release 1.0.3 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.0.3 (fozworth)
05:29:10 <eminhi> CoolerZ: paste an example
05:29:34 <CoolerZ> i set the flag -fbreak-on-exception in GHCi
05:29:47 <CoolerZ> and then ran main, its stopped at an execption
05:30:00 <CoolerZ> how do i find out which line of code it is stopped at?
05:31:26 <CoolerZ> i did :trace main
05:31:46 <pavonia> pie_: Are you sure the package is in scope (in whatever framework you're using)?
05:31:50 <CoolerZ> but doing :hist it says "empty history, perhaps you forgot to use :trace?"
05:32:05 <CoolerZ> wth
05:32:26 <eminhi> run :trace main
05:32:39 <CoolerZ> i just did
05:32:46 <pie_> pavonia, no
05:33:38 * hackage http-api-data 0.3.7.1 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.3.7.1 (NickolayKudasov)
05:35:00 <eminhi> CoolerZ: Any help will be a lot easier if you provide a minimal example of the problem
05:35:24 <CoolerZ> eminhi, i don't know which line is causing the problem
05:36:11 <CoolerZ> heres the entire source if you want http://lpaste.net/355532
05:36:39 <CoolerZ> i thought it was lines 183 and 193 which use Map.!
05:37:01 <CoolerZ> but setting breakpoints there didn't work, it still throws the exception
05:39:07 <pie_> pavonia, line 3 http://lpaste.net/3688106528952287232
05:40:26 <CoolerZ> why is it saying empty history when i do :hist, right after i did :trace main
05:40:29 <CoolerZ> ?
05:41:07 <pavonia> pie_: Are you loading that from stack?
05:43:33 <osa1> if I re-export module A in module B and import module B in module C do I get instances of A?
05:44:09 <hvr> osa1: you don't even have to reexport A... just importing it suffices
05:44:13 <merijn> osa1: I think instance *always* get propagated
05:44:15 <osa1> I have classy lenses in module A but somehow module C can't use them when I just import module B (without module A). but the types are visible.
05:44:18 <osa1> hmmm
05:45:02 <hvr> osa1: as soon as the module defining the instance becomes part of your transitive import graph, you get the instance into scope... whether you want it or now
05:45:02 <osa1> hmmm I think I found a bug then
05:46:30 <ventonegro> are there good introductory blog posts about free monads?
05:47:02 <osa1> this is annoying because I have a lot of modules that just import B without A. now they're all broken unless I switch to regular lenses + export everything (in module A)
05:47:38 <osa1> ventonegro: google for "you could have invented free monads"
05:47:46 <ventonegro> osa1: thanks!
05:47:51 <merijn> Is that the Tekmo one?
05:47:57 <merijn> Because he had a good one on free monads too
05:48:02 <osa1> merijn: yes
05:48:27 <pie_> pavonia, yes
05:48:50 <pie_> ive done stack build in the project folder for the package
05:51:08 * hackage sproxy2 1.95.0 - Secure HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy2-1.95.0 (ip1981)
05:51:35 <pavonia> pie_: Hhm, I'm not familiar with stack, though
05:53:04 <CoolerZ> when ghci prints :hist history
05:53:21 <CoolerZ> does it print it in reverse order? the indices are -1,-2,-3,etc
05:54:46 <jchia_1> Does a ghc-compiled program use a stack? If so, what gets allocated on the stack and what gets allocated on the heap?
05:55:10 <merijn> jchia_1: It doesn't use a traditional function call stack, no
05:58:03 <quchen> jchia_1: The abstract machine that executes GHC code is called as the STG, the spineless tagless G-machine. Instead of a C-like function-return-address-stack, it has a pattern match stack.
05:58:16 <quchen> Unlike in C, executing a function does not necessarily allocate a stack frame.
05:58:17 <jchia_1> So, what does it mean by "stack size" in the context of the -k RTS option?
05:58:43 <quchen> There is a stack, but pattern matching (via case) fills it.
05:59:09 <quchen> main = id (id (id (pure ()))) -- takes 0 stack frames total.
05:59:24 <quchen> In C, it would take 4: one for each id, one for pure.
05:59:27 <CoolerZ> how do you list all variables that are in scope?
05:59:31 <cinimod`> I want apply a function to a value a fixed number of times e.g. f (f (f x))
06:00:20 <cinimod`> If I do last $ take n $ iterate f a then it takes a long time with lots of GC
06:01:04 <merijn> cinimod`: 1) is your function strict? 2) why not use "iterate f a !! n"?
06:01:04 <jchia_1> I'm asking about the stack because of the technique for tracking down space leaks given on this page. Does it still work in GHC 8.0.1? http://neilmitchell.blogspot.jp/2015/09/detecting-space-leaks.html
06:01:06 <quchen> Instead of (last . take n), use (!! n). Instead of (!! n), use an algorithm that does not need to build the list in the first place ;-)
06:01:16 <cinimod`> But myIterate 0 _ a = a; myIterate n f a = myIterate (n-1) f (f a) just seems to create a big thunk which get evaluated at the end
06:01:16 <cinimod`>  
06:01:22 <jchia_1> And also I'm trying to understand how this approach works.
06:01:24 <quchen> jchia_1: Sure, that stack is here to stay
06:01:42 <quchen> cinimod`: You’re building a (f (f (…))) thunk.
06:01:46 <cinimod`> Yes
06:01:48 <cinimod`> I know
06:01:55 <cinimod`> I don't wish to
06:01:58 <lyxia> cinimod`: you might want to seq a (myIterate (n-1) ...)
06:02:00 <quchen> cinimod`: You can avoid this by making your function strict in the (f a) value, by using seq or bang patterns
06:02:30 <quchen> cinimod`: Note that you’re *not* building a thunk because of the (n-1), because the comparison with 0 forces it on each iteration. :-)
06:03:04 <cinimod`> quchen ok but it is using 2G!
06:03:23 <quchen> Lots of small thunks use lots of small memory
06:03:44 <quchen> myIterate n f x | n <= 0 = x | otherwise = myIterate (n-1) f $! f x
06:03:52 <quchen> There’s also the $! operator in the Prelude,
06:03:55 <quchen> ?src $!
06:03:55 <lambdabot> f $! x = x `seq` f x
06:04:13 <cinimod`> Why is the comparison better than pattern matching?
06:04:28 <quchen> cinimod`: myIterate (-1)
06:04:52 <LAZAR> Can someone help me with this line of code? I am trying to use a local variable relying on Random in main but <- only works with IO and if I move it to where the generator is out of scope.... http://lpaste.net/355534
06:04:58 <cinimod`> fair enough - I thought it had some performance value
06:05:15 <quchen> A crashing program has poor performance.
06:05:16 <quchen> ;-)
06:05:24 <CoolerZ> whats a good way to pretty print a [(Int, Data.Map.Strict.Map)] ?
06:05:39 <quchen> show.
06:05:45 <quchen> Oh, sorry, pretty print
06:05:59 <cocreature> quchen: you should just replace your pretty printer library by show! :)
06:06:15 <quchen> Use a prettyprinter! We have a load of them. I recommend my own one. :-þ
06:06:27 <jchia_1> CoolerZ: I've used the groom package before, but not on Map.
06:06:29 <cinimod`> I still get "2889 MB total memory in use"
06:06:46 <quchen> CoolerZ: https://quchen.github.io/ansi-wl-pprint-docdump/wl-pprint-1/Data-Text-Prettyprint-Doc.html
06:06:52 <cinimod`> Ignore that
06:06:56 <merijn> cinimod`: How are you tracking memory usage?
06:07:03 <cinimod`> +RTS -s
06:07:19 <merijn> cinimod`: Which thing is listing 2889 MB?
06:07:22 <lyxia> LAZAR: where is gen used?
06:07:24 <cinimod`> And lots of GC
06:07:46 <cinimod`> MUT is 1.9 and GC is 8.1
06:07:49 <LAZAR> lyxia: gen <- getStdGen is used in my main do
06:08:03 <LAZAR> lyxia: and thus not accessible from the where block
06:08:06 <merijn> cinimod`: Did you update quchen's suggestions?
06:08:18 <lyxia> LAZAR: I see only one occurence of gen in each block, and that is it being bound, but not used
06:08:29 <cinimod`> I have myIterate n f x | n <= 0 = x | otherwise = myIterate (n-1) f $! f x
06:08:38 <merijn> quchen: Does that mean you released it? :p
06:08:40 <lyxia> LAZAR: you can write "let nums = getRandomNumbers"
06:08:57 <quchen> merijn: It’s on Github ლ(ಠ益ಠლ)
06:09:16 <cinimod`> Maybe because I am using Linear?
06:09:40 <cocreature> cinimod`: what’s the type of f?
06:09:42 <LAZAR> lyxia: Thanks, that was pretty stupid of me
06:09:55 <cocreature> cinimod`: also are the 2889mb max residency or allocations?
06:10:08 <cinimod`> (V2 Double, V2 Double) -> (V2 Double, V2 Double)
06:10:37 <cinimod`>  1,131,991,832 bytes maximum residency
06:10:37 <cocreature> then $! won’t help. that will only force the tuple constructor but not the values in the tuple
06:10:50 <cinimod`> So it's the V2
06:10:51 <cocreature> try using V2 (V2 Double, V2 Double)
06:11:00 <cocreature> eh V2 (V2 Double) (V2 Double)
06:11:15 <cocreature> eh V2 (V2 Double)
06:11:21 <cinimod`> lol
06:11:22 <cocreature> I should start thinking before I type
06:11:42 <cinimod`> I have a working accelerate version
06:11:56 <cinimod`> I just wanted to compare it to old school Haskell
06:13:06 <Athas> cinimod`: what are you using Accelerate for?
06:13:12 <quchen> cinimod`: »seq« only does enough work to show something for it, it does not do all the work.
06:13:24 <quchen> cinimod`: So it will only do some computation until there is some result.
06:13:42 <quchen> In particular, it will compute until it finds out its argument is not an infinite loop or something.
06:13:48 <cinimod`> Athas: a symplectic integrator
06:14:17 <Athas> That looks like a typo, but apparently there is a thing by that name!
06:15:41 <pie_> pavonia, didnt have issues with other packages i needed to install :/
06:15:49 <cinimod`> That's better
06:15:56 <cinimod`> 1M rather than 2G
06:16:09 <cinimod`> Ok tuples are evil
06:16:30 <merijn> cinimod`: Not so much, it's the thunks building inside.
06:17:01 <merijn> Does Haskell/GHC have integer notation supporting thousan groupings?
06:17:23 <merijn> i.e. allowing something like 1,000,000 or 1_000_000 instead of 1000000
06:19:14 <quchen> Nope.
06:19:28 <quchen> Quasiquoter *ducks*
06:20:33 <LAZAR> What is wrong about this part? (assuming proper indentation) getLineInt = do   line <- getLine   case readMaybe line of     Just x -> case x >= 0 of                 True -> x                 False -> putStrLn "That number is too low!" >> getLineInt     Nothing -> putStrLn "Please enter a valid number!" >> getLineInt
06:21:05 <LAZAR> basically a nested case statement
06:21:06 <cinimod`> So accelerate is about 50% faster than ghc and both outperform Julia
06:21:50 <cinimod`> Thanks merijn and quchen - that probably saved me an hour of investigation
06:22:48 <CoolerZ> how do i insert a newline into a string?
06:22:53 <CoolerZ> \n doesn't work
06:23:01 <jle`> what do you mean by insert?
06:23:10 <jle`> do you have a string and want to append a newline to the end?
06:23:14 <CoolerZ> yeah
06:23:18 <LAZAR> CoolerZ: You mean mystring ++ "\n" ++ suffix?
06:23:22 <jle`> > "my string" ++ "\n"
06:23:24 <lambdabot>  "my string\n"
06:23:28 <CoolerZ> nope doesn't work
06:23:31 <jle`> why doesn't it work?
06:23:42 <CoolerZ> it just prints \n
06:23:52 <jle`> how are you using the string?
06:23:56 <LAZAR> Strange
06:24:05 <CoolerZ> putStrLn
06:24:13 <jle`> putStrLn "hello\nworld" looks fine to in my ghci
06:24:47 <jle`> what version of ghc are you using, and what operating system?
06:25:04 <CoolerZ> oh i am using another show after that, thats why
06:25:34 <LAZAR> What is wrong with my nested case statement here? http://lpaste.net/355536
06:25:56 <jle`> LAZAR: are you asking from a stylistic perspective?
06:26:08 <LAZAR> jle`: no it throws an error
06:26:17 <LAZAR> jle`: i just dont get why
06:26:18 <jle`> case blah of True -> ... etc. is probably better as if/then/else
06:26:25 <jle`> well
06:26:27 <jle`> what's the error?
06:26:29 <c_wraith> LAZAR, do you mean it doesn't compile? 
06:26:52 <jle`> if you ever want help with an error, 99% of the time it would help to post the error :)
06:26:54 <LAZAR> positive, it does not compile with     • No instance for (Read (IO Int)) arising from a use of ‘readMaybe’
06:27:18 <LAZAR>     • No instance for (Ord (IO Int)) arising from a use of ‘>=’
06:27:19 <jle`> that's definitely not a problem with the case statement
06:27:22 <jle`> that's a type error :o
06:27:30 <LAZAR>     • No instance for (Num (IO Int)) arising from the literal ‘0’
06:27:34 <LAZAR> yeah i figure
06:27:40 <LAZAR> i need to cast here?
06:27:41 <jle`> remember that each branch of a case statement must have the same type
06:27:43 <c_wraith> LAZAR, it's a weird inference report of not using return on x
06:28:00 <jle`> on line 5, you're trying to return a...Int, maybe?
06:28:03 <jle`> i'm guessing
06:28:06 <LAZAR> Yeah its basically not using return  lol
06:28:08 <jle`> (see, even I can't infer it)
06:28:11 <blackdog> one debugging technique woud be to replace one of the case arms with undefined
06:28:12 <LAZAR> im not returning anything
06:28:18 <jle`> on line 6 you're returning IO something
06:28:29 <jle`> on line 7 you're returning IO something
06:28:40 <LAZAR> yeah i guess i need to return in any case?
06:28:45 <jle`> so the line 5 case branch is returning something of a different type than line 6 and 7
06:28:45 <c_wraith> LAZAR, for what it's worth, compile errors aren't "throwing" anything. that's run time behavior. 
06:28:45 <LAZAR> sing return x fixed it
06:28:51 <blackdog> so try "True -> undefined" - if that works, that lets you know that you were doing the wrong thing in that arm
06:28:57 <greymalkin> Does anyone have any insight into why https://pastebin.com/cE5pKmmu would cause a 'Could not deduce' error in the second function, but not the first?
06:29:29 <merijn> blackdog: Probably helps to paste the error too :)
06:29:30 <c_wraith> greymalkin, as always, exact errors help a lot. preferably in the paste. 
06:30:02 <Athas> cinimod`: is that Accelerate on GPU?
06:30:06 <blackdog> merijn: well yes :) that one was a bit obvious, i'm just trying to do the "here's how you could debug it yourself" thing
06:30:13 <Athas> A 50% performance increase over GHC sounds really bad if so.
06:30:29 <merijn> quchen: Well with an extension you can do 1e6 for Integrals in GHC, but that only works nicely for round numbers
06:30:38 <greymalkin> c_wraith: Added.
06:31:20 <c_wraith> greymalkin, you left out the part that explains why the error happens. 
06:31:40 <c_wraith> greymalkin, which is what I was going to use to explain why the error was happening. 
06:32:03 <jle`> greymalkin: yeah, you pretty much did not give any more information than you did before, heh
06:32:08 <jle`> you cut out 90% of the useful information from the error message
06:32:12 <jle`> namely: the error message
06:33:09 <ij> ertes-w, Okay, that's a humoungous image! 1.7!
06:34:51 <ertes-w> ij: keep watching
06:35:16 <ertes-w> i fix it just a moment later =)
06:35:26 <merijn> hmmm, I should probably make my benchmarks less exhaustive...
06:35:35 <merijn> I fear 3.1k of them might take a while >.>
06:35:49 <greymalkin> Okay, full error message included.
06:37:09 <cinimod`> Athas: on CPU but performance is roughly the same on GPU
06:37:12 <cinimod`> I just tried
06:37:23 <cinimod`> It's not a parallel problem
06:37:36 <ertes-w> ij: ideally images wouldn't actually contain anything beside an init script, and you would simply mount the nix store as a read-only volume, but the current dockerTools doesn't support that approach
06:37:42 <cinimod`> I am surprised it is as quick as it is on GPU
06:38:04 <ertes-w> ij: it's mainly for self-contained images, so static linking is the most viable option
06:38:13 <ij> ertes-w, Do I have to be on nix for this to work?
06:38:48 <ertes-w> ij: you do need to have nix installed…  you don't need to be on NixOS
06:39:17 <c_wraith> greymalkin, so, you're getting an ambiguous type.. ghc needs to select a class instance to use, but can't figure out what type you actually mean. 
06:39:19 <ertes-w> ij: wait, you mean to run the images?  no, they are self-contained
06:39:25 <Athas> cinimod`: why use Accelerate if the problem is not parallel?
06:39:37 <Athas> I think vector is a better choice if you just want fast strict arrays.
06:40:08 <BernhardPosselt> hi, does haskell also have those contravariance, covariance issues like java?
06:40:15 <BernhardPosselt> or do HKT solve that?
06:40:25 <c_wraith> greymalkin, and this is happening because there is nothing connecting the type of the ambiguous expression to the type in the signature 
06:40:34 <merijn> BernhardPosselt: The only contravariance/covariance issue I'm aware of is wrt to subtyping
06:40:40 <c_wraith> BernhardPosselt, most of them go away when you remove subclassing and mutability. 
06:40:42 <merijn> BernhardPosselt: Haskell doesn't have subtyping, so those don't exist
06:40:48 <BernhardPosselt> ah right :)
06:40:49 <ij> ertes-w, So nothing is being built inside the container?
06:41:27 <ertes-w> ij: what do you mean?
06:41:32 <merijn> BernhardPosselt: Similar things break structural subtyping, which is why most PLT people are settling on "subtyping is evil" and work on rowtype polymorphism :)
06:41:38 <nightglare> hi. i wanna get started learning haskell.
06:41:53 <ij> ertes-w, No containers are being run during the build, yes? I saw other approaches do this.
06:41:56 <cinimod`> Athas: the CG for numerical stuff is better
06:42:07 <nightglare> but how good is it for GUI programming?
06:42:18 <ertes-w> ij: correct…  docker is not used for image building
06:42:19 <BernhardPosselt> yeah, ADT are a very neat way to avoid subtyping
06:42:33 <c_wraith> greymalkin, it's hard to pin it down further when there is no definition for jsonStringMap listed 
06:42:49 <ertes-w> nightglare: very good as a language, bad as a platform
06:42:58 <carter> cinimod`: I've been recently finishing up getting my library of math tools in shape :)
06:43:21 <ertes-w> nightglare: our toolkit bindings are a bit lacking (GTK+ is the most comprehensive…  i think it's pretty much complete)
06:43:40 <greymalkin> Oh, sorry. it's the 'getStringMap' above... cut-and-paste problem.
06:43:41 <ertes-w> nightglare: portability is often a hassle when windows support is required
06:43:45 <BernhardPosselt> btw, couldnt you say a typeclass instance is a sub type of the type class?
06:43:55 <merijn> BernhardPosselt: Not really
06:44:00 <greymalkin> So, adding `forall a.` to the type signature makes the error go away, but I would like to know why.
06:44:31 <ertes-w> nightglare: the situation is much better with media libraries like GLFW, GLUT, SDL, etc., but some of the windows issues remain
06:44:38 <BernhardPosselt> are typeclasses more related to HKT and instances to types?
06:44:46 <merijn> BernhardPosselt: For example, consider: "foo :: Bar a => [a]" that list cannot have different instances of the same typeclass inside it
06:45:11 <ertes-w> nightglare: as a language haskell is great for UI development…  we have a few very nice approaches like (real) FRP, concurrency, etc.
06:45:13 <merijn> BernhardPosselt: The typeclass is more of a predicate/constraint on type variables
06:45:18 <jle`> greymalkin: it should only make a difference if you have scoped type variables on, and refer to the 'a' type variable inside the function body
06:45:26 <greymalkin> No, nevermind. it went away when I removed the String from the tuple.
06:45:58 <nightglare> ertes-w: thanks. all i really want is Gtk+3
06:46:30 <ertes-w> nightglare: yeah, that one is very good support, and there are reasonably easy build instructions for windows as well
06:46:34 <nightglare> ertes-w: does it work well enough on linux?
06:46:34 <jle`> haskell has subtyping.  [Bool] is a subtype of (forall a. [a])
06:46:46 <ertes-w> nightglare: yes, linux is the best supported platform
06:47:13 <merijn> jle`: I wouldn't agree to call that subtyping
06:47:28 <ertes-w> nightglare: not the (best (supported platform)), but the ((best supported) platform) =)
06:47:31 <jle`> it fulfills substitutability, doesn't it?
06:47:34 <BernhardPosselt> regarding forall: is forall the same thing as in purescript?
06:47:39 <merijn> jle`: I don't think I consider a type system to have subtyping without a subsumption typing rule
06:47:59 <nightglare> ertes-w: thank you again. how do i get started?
06:48:21 <BernhardPosselt> forall a b. a -> b 
06:48:29 <merijn> jle`: Well, you can't pass [Bool] to a function expecting (forall a . [a])
06:48:32 <BernhardPosselt> placeholder for a and b
06:48:48 <BernhardPosselt> that is needed to avoid ambiguities when nesting the type variables?
06:48:56 <jle`> ah yeah, got it backwards.  you can provide a (forall a. [a]) to any function epxecint [Bool]
06:49:16 <jle`> BernhardPosselt: it means something similar here yes
06:49:25 <ertes-w> nightglare: try this: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
06:49:30 <jle`> *expecting a [Bool]
06:49:41 <ertes-w> nightglare: or perhaps this: https://www.cis.upenn.edu/~cis194/fall16/
06:49:51 <BernhardPosselt> ty
06:49:57 <wilornel> Where is `data  (->) t1 t2` defined?
06:50:05 <jle`> but we're using it for a different purpose than that one specifically
06:50:09 <wilornel> for `:info (->)`. I can't find it here: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html
06:50:27 <gnull> Hi everyone. Do you know of any haskell package that would allow to execute interactive console programs and interact with them? Maybe something similar to Tcl/expect? I'm not solving any particular problem, just curious.
06:50:28 <nightglare> ertes-w: so, on the whole, linux is badly supported by Haskell?
06:50:40 <phadej> wilornel: it's built-in
06:51:08 <ertes-w> nightglare: no, linux is very well supported
06:51:17 <erisco> annoying problem... I have some question formats (Q1 .. Qn) and answer formats (A1 .. An) in a game. A state in the game looks like  (Q1, A1 -> Game) and a review of the game looks like [forall n. (Qn, An)]
06:51:43 <merijn> wilornel: Why are you expecting it to be defined anywhere?
06:51:45 <ertes-w> nightglare: actually windows is also well supported, but the trouble starts when you need to bind to foreign libraries
06:52:02 <erisco> well, that review type doesn't really work, so I can instead define a sum of all the Q&A tuples and get [QA]
06:52:02 <ertes-w> nightglare: like in this case UI toolkits
06:52:04 <wilornel> phadej: thank you. It's confusing because when I run `:info (->)`, it says it's "Defined in 'GHC.Prim'"
06:52:08 <wilornel> merijn: ^
06:52:23 <merijn> wilornel: GHC.Prim is secret code for "magic compiler voodoo" ;)
06:52:27 <erisco> but now I have this ugliness where I have (Qn, An -> Game) types and (Qn, An) types
06:52:33 <erisco> having to be separately defined...
06:52:38 <wilornel> That's also confusing because this exists https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html
06:52:52 <wilornel> And sure :) but what about this page? ^ 
06:53:04 <merijn> wilornel: If you have a look at the actual source of that module, you'll see the things it lists don't really exist :)
06:53:22 <merijn> wilornel: To document the "magic compiler voodoo" that people can actually use :)
06:53:22 <phadej> wilornel: grep for 'data Int#'; it's kind of there; but not really
06:53:31 <jle`> the module is mostly placeholder for the satisfaction of the typechecker
06:53:47 <cinimod`> Athas: my bad - the GPU is a *lot* slower as I would have expected
06:53:47 <nightglare> ertes-w: i see
06:54:07 <wilornel> but What do you mean? `data Int#' is there, and what does Int# have to do with (->)?
06:54:08 <ertes-w> nightglare: and this problem is not exclusive to haskell…  windows is just bad as a development/build platform, unless you do everything with visual studio, as microsoft keeps telling us
06:54:12 <cinimod`> I don't have a stand-alone GPU so I can't experiment very much
06:54:18 <nightglare> ertes-w: thanks for the resources
06:54:22 <wilornel> You mean it's there but we don't get to see its definition?
06:54:26 <erisco> maybe I can get something like a dependent pair...
06:54:27 <wilornel> jle: Thanks
06:54:29 <phadej> wilornel: it's not really defined, and (->) is even more magical; so it isn't there
06:54:32 <merijn> wilornel: He's refering to Int# being defined as "data Int#" without any constructors :)
06:54:34 <wilornel> I see!
06:54:50 <wilornel> Ah that's the word I was missing , constructor. Alright, thanks phadej and merijn !
06:54:51 <phadej> also almost all function there are `let x = x in x`
06:55:08 <phadej> which is a way to say "undefined" without saying "undefined"
06:55:25 <cinimod`> carter: I look forward to trying them
06:55:34 <nightglare> ertes-w: thanks for the help and the resources. yes, i use linux.
06:55:35 <merijn> wilornel: Basically, those functions/datatypes are built into GHC, but the typechecker doesn't know that. So that module provides types + documentation for things that are builtin
06:56:01 <wilornel> What about (::) ? Is that for the compiler to understand ? I feel like there's different ways to intergret it
06:56:03 <ertes-w> nightglare: then you will have a smooth experience =)
06:56:25 <jle`> (::) is syntax
06:56:40 <wilornel> 15 :: Integer , or (+) :: Num a => a -> a -> a
06:56:52 <merijn> wilornel: How are those different according to you? :)
06:56:55 <wilornel> These :: act differently
06:57:05 <wilornel> Hmmm well in one I'm casting/resolving 15 to be an integer
06:57:14 <merijn> wilornel: No
06:57:16 <wilornel> and in the other I am defining that (+) must be a function of this shape
06:57:26 <ertes-w> wilornel: you are *claiming* that 15 is an Integer
06:57:32 <wilornel> ah sorry
06:57:35 <jle`> in both cases they are type annotations
06:57:36 <nightglare> ertes-w: :) bye. i will be back.
06:57:42 <merijn> wilornel: Oh, actually, I suppose you're slightly right
06:57:46 <wilornel> and with (+) :: Num a => a-> a-> a it's the same?
06:57:51 <wilornel> Alright, cool!
06:57:53 <jle`> well, you are right that :: can be used in a declaration, and also as a type annotation
06:57:58 <wilornel> aha!
06:57:59 <ertes-w> nightglare: great, have fun =)
06:58:00 <merijn> wilornel: :: can annotate both *names* and *expressions*
06:58:01 <wilornel> See? It's confusing
06:58:09 <wilornel> aaaah
06:58:13 <wilornel> so it's annotating
06:58:19 <merijn> wilornel: But it does the same thing for both of those. Which is, tell the compiler which type it has
06:58:32 <wilornel> that makes sense. Thank you!!
06:58:37 <ertes-w> wilornel: whenever you write "x :: A", you're saying, "this is x…  oh, and i think x is of type A"
06:58:45 <jle`> so i suppose it is a part of expression syntax, as well as declaration syntax
06:58:57 <ertes-w> wilornel: the compiler will then check if you're correct
06:59:02 <merijn> Well, not really "I think" but more "if 'x' is not type A, scream bloody murder" ;)
06:59:21 <jle`> in an expression context, (my expression :: T) means that you want to claim that `my expression` has type T
06:59:40 <jle`> in a declaration context, `foo :: T; foo = ...` means that you are defining foo which has type T
06:59:59 <ertes-w> wilornel: the point is that you never get to *choose* the types…  every expression already has a certain type, and the only choice you have is to go from more general types to less general ones
07:00:01 <jle`> haskell doesn't allow naked expressions at the top level so i suppose the ambiguity isn't there
07:00:14 <wilornel> makes sense! And because it's so similar (almost the same thing) it makes sense to use the same syntax
07:00:23 <ertes-w> wilornel: 15 is of type (Num a => a), but you are free to restrict it to Integer
07:00:24 <jle`> if you're at the "top level" or somehwere where haskell expects a declaration, it can assume that foo :: T is a part of a declaration
07:00:50 <CoolerZ> does \x->\y->x+y work?
07:00:51 <jle`> from a parsing standpoint
07:00:55 <jle`> CoolerZ: what happens when you try it
07:01:06 <wilornel> What about this (15 :: Integer ) + (15 :: Double) will work but (15 :: Double) + (15 :: Integer) will throw an error which says "Couldn't match expected type 'Double'"
07:01:13 <wilornel> So the Int cannot be casted to Double?
07:01:22 <jle`> um
07:01:25 <ertes-w> > (15 :: Integer) :: Double
07:01:27 <wilornel> Or the Double could not be cast to Int?
07:01:27 <lambdabot>  error:
07:01:27 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘Integer’
07:01:27 <lambdabot>      • In the expression: (15 :: Integer) :: Double
07:01:30 <jle`> (15 :: Integer) + (15 :: Double) will not work
07:01:31 <CoolerZ> yeah it works
07:01:33 <tdammers> they're not casts
07:01:37 <tdammers> they're type annotations
07:01:43 <ertes-w> wilornel: you're not *casting*, you're only *claiming*
07:01:44 <CoolerZ> you need a space after the first -> though
07:01:49 <wilornel> ah sorry, I misread the book!
07:01:49 <paolino> :: set a constraint on the type resolution of your code
07:02:01 <CoolerZ> is there a short hand for that?
07:02:04 <wilornel> yes yes so Int doesn't not claim to Double and Double does not claim to Int
07:02:16 <jle`> haskell does no implicit conversions
07:02:20 <wilornel> tdammers: Yes, sorry!
07:02:23 <CoolerZ> actually there is
07:02:24 <wilornel> I see
07:02:27 <ertes-w> wilornel: the reason your example doesn't work is:
07:02:30 <ertes-w> :t (+)
07:02:31 <lambdabot> Num a => a -> a -> a
07:02:42 <wilornel> It has to all be the same type!
07:02:45 <ertes-w> wilornel: it takes an argument of type 'a' and another argument of type 'a'
07:02:50 <jle`> CoolerZ: there's `\x y -> x + y`, or also just `(+)`
07:03:15 <ertes-w> wilornel: by your first argument you want to instantiate (a = Integer), but by the second argument you want to instantiate (a = Double)…  that's a conflict
07:03:23 <CoolerZ> yeah
07:03:46 <wilornel> thanks ertes-w 
07:04:03 <jle`> so many haskell syntax tokens are overloaded
07:04:19 <jle`> i didn't realize (::) was as well until now
07:04:32 <jle`> is there a haskell syntax token that *isn't* overloaded
07:04:46 <jle`> (answer: yes)
07:04:51 <ertes-w> jle`: infix, infixl, infixr
07:04:53 <wilornel> hahah, what is it?
07:05:10 <wilornel> . ? $ ? <*> ? 
07:05:17 <jle`> wilornel: those aren't syntax tokens
07:05:20 <paolino> (=) ?
07:05:20 <jle`> they're just normal identifiers
07:05:21 <wilornel> I remember reading about these but I forgot how they work
07:05:23 <wilornel> Ah that's right
07:05:29 <jle`> they're user-defined
07:05:38 <ertes-w> paolino: (=) is highly overloaded
07:05:40 <ertes-w> f x = x + x
07:05:43 <jle`> i was thinking 'case'/'if'/'then'/'else'
07:05:43 <ertes-w> data T = …
07:06:17 <ertes-w> with enough extensions all of those are overloaded =)
07:06:27 <jle`> oh :o
07:06:39 <erisco> hm, this could work reasonably...
07:06:47 <jle`> are there any haskell syntax tokens that are operators that aren't overloaded
07:06:51 <ertes-w> for example with -XArrows they translate into ArrowChoice combinators
07:06:52 <jle`> "operators"
07:07:05 <jle`> er, maybe i should say symbols
07:07:30 <wilornel> is overloading a good thing? In my experience it makes things confusing
07:07:44 <ertes-w> the infix* tokens are the only ones i can think of in general that aren't overloaded as far as i know
07:07:52 <ertes-w> even 'module' is overloaded
07:07:59 <carter> cinimod`: me toooo.  I've been pleased with the error messages I get even when writing the internals.  Stuff like Row and column not being equal etc :)
07:08:11 <jle`> wilornel: it's used in haskell to help with associating concepts
07:08:20 <jle`> but i agree that it can go too far in some situations
07:10:02 <wilornel> need to learn how to read the definitions of the operators you're using quickly (using haggle I suppose)
07:10:35 <ertes-w> wilornel: in haskell they are usually overloaded in a sensible way, or at least in a way that isn't ambiguous
07:10:55 <jle`> hoogle won't help with syntax
07:10:59 <jle`> only operators
07:11:04 <jle`> and other user-defined stuff
07:11:36 <jchia_1> Could someone recommend a plotting package that can draw simple 2D scatterplots on Linux that's not too complicated to program and use with Stack LTS-8.13?
07:11:47 <glguy> the haskell report will show you the syntax
07:12:08 * hackage threepenny-editors 0.2.0.6 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.6 (PepeIborra)
07:15:17 <wilornel> glguy: https://www.haskell.org/onlinereport/haskell2010/ thank you! 
07:15:24 <wilornel> thanks jle, ertes-w . Going to bed now
07:16:05 <erisco> if you have data families F and G then easily you have type (F x, G x)
07:16:07 <ski> `->' is overloaded
07:16:17 <jle`> wilornel: good night!
07:16:20 <erisco> not a bad emulation of dependent pairs
07:16:44 <ertes-w> erisco: see the dependent-sum package
07:17:42 <erisco> don't know why I need a library for this
07:19:33 <ertes-w> erisco: for the same reason you really want to have (,) in a library =)
07:19:35 <erisco> though yes they do not need be data families
07:19:43 <erisco> just any type constructor
07:20:18 <erisco> okay, well if you want a generically named thing then sure, but I don't... was just using (,) for familiarity
07:20:35 <ski> one of them would commonly be a GADT, no ?
07:20:48 <ertes-w> yeah
07:22:08 * hackage ble 0.4.0.0 - Bluetooth Low Energy (BLE) peripherals  https://hackage.haskell.org/package/ble-0.4.0.0 (jkarni)
07:23:21 <erisco> what is a package with type length lists
07:23:45 <jle`> i use type-combinators these days
07:23:47 <erisco> and not the one that makes the nested tuples... that is a bit strange
07:24:28 <jle`> are you really looking for lists, or are vectors ok too
07:24:45 <erisco> http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Vector.html ?
07:25:10 <jle`> yeah, those are inductive length-indexed lists
07:25:22 <erisco> yup, and yes that is what I am looking for
07:25:42 <erisco> there is another Vec package which makes nested tuples so you may have heterogeneous vectors
07:25:54 <erisco> this is alright but needlessly complicated for the homogeneous case
07:25:57 <jle`> type-combinators also has Prod
07:26:03 <jle`> which is the heterogeneous list
07:26:28 <jle`> but if you really want a vector, you can also used vector-sized
07:27:30 <merijn> I need, like, a CI service, but for benchmarking stuff, instead of running tests >.>
07:27:56 <erisco> meh... list is only up to 16 elements so it doesn't matter
07:28:09 <erisco> didn't know of that one either though so thanks
07:29:14 <erisco> I better double check ghcjs to make sure these extensions work there
07:31:09 <LAZAR> Someone of you likes refactoring? ;P I just wrote a ~50 lines haskell implementation of the knapsack problem, I wonder what I could improve as a beginner: http://lpaste.net/355539
07:31:19 <ertes-w> erisco: the 'linear' package has the V type, which is based on 'vector' vectors
07:31:51 <jle`> vector-sized is essentially V but with the full vector API
07:31:57 <jle`> and without a lens dependency
07:32:09 <erisco> bonus
07:33:42 <merijn> LAZAR: I'm too lazy (and have to go soon) to do the whole thing, but I'll see if I can spot some easy things
07:34:02 <LAZAR> merijn: sure, would be cool... it works so its really just style and alike
07:34:33 <merijn> LAZAR: You could rewrite line 13 as "compare = compare `on` getIndex"
07:35:14 <merijn> LAZAR: line 19, the parenthesis around fromIntegral both sides of / are redundant (function application is *always* higher precedence than operators)
07:35:35 <merijn> Same for the (Item x y) on line 25
07:35:54 <erisco> what is the scene for JavaScript compilation right now? looking at ghcjs and Haste particularly
07:36:01 <LAZAR> Syntax error on 'on'       Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
07:36:08 <LAZAR> oh wait
07:36:10 <LAZAR> my mistake
07:36:12 <merijn> LAZAR: Wrong quotes ;)
07:36:32 <merijn> LAZAR: You can simplify the case on line 30 using guards
07:36:44 <LAZAR> shouldnt "on compare getIndex" work?
07:36:55 <erisco> can get a Windows binary for Haste so that is much easier to try... years ago when ghcjs was newer it was a PITA to get going on Windows (had to run it through a VM ultimately)
07:37:24 <LAZAR> Variable not in scope:         on... does it require some import?
07:37:27 <lpaste> merijn pasted “case with guards” at http://lpaste.net/355540
07:37:32 <merijn> LAZAR: Data.Function iirc
07:37:33 <erisco> import Data.Function (on)
07:38:01 <merijn> LAZAR: And yes, "on compare getIndex" works, but the infix notation reads nicely, like "1 `elem` [1..10]"
07:38:50 <merijn> LAZAR: Why have a case inside guards on line 40? Why not just add two separate guards for that
07:38:53 <LAZAR> merijn: thats true
07:38:59 <quchen> LAZAR: http://lpaste.net/diff/355539/355541
07:39:14 <ertes-w> erisco: no idea about haste, but GHCJS is used commercially
07:39:28 <merijn> quchen: null might be justified if it's a Set or something :)
07:39:49 <blackdog> LAZAR: can pull fillKnapsack out - the only thing the case statement changes is whether the second argument is "sack" or "firstItem:sack"
07:39:58 <quchen> merijn: Yes. And?
07:40:02 <merijn> And I dislike replacing the $ with () at the end
07:40:09 <merijn> Tastes differ :p
07:40:17 <LAZAR> oh i just see i can use comparing getIndex
07:40:53 <merijn> LAZAR: oh, yeah, I always forget about comparing >.<
07:43:19 <LAZAR> merijn: but i actually reverse them in my implementation
07:43:40 <LAZAR> merijn: so both comparing and on will change the order
07:43:59 <quchen> »on« is mostly used in places where »comparing« is clearer.
07:44:07 <merijn> "flip (comparing getIndex)" :)
07:45:09 <deadalnix> Is there someone around here familiar with the phabricator continuous integration ?
07:45:24 <merijn> But yeah, you should also use try refactoring the null usage away and use pattern matches
07:45:40 <merijn> deadalnix: What's the actualy question? :)
07:46:47 <merijn> deadalnix: Also, if this is about contributing to GHC, there's #ghc where people are generally more knowledgable about that sorta thing (you may have to wait a while for a response)
07:47:23 <deadalnix> merijn, as far as I can see it's running shell script directly, which means that either I missed somethign or either it's very insecure.
07:47:45 <LAZAR> blackdog: what do you mean?
07:49:09 <deadalnix> So by asking about it, I hope that I'll either learn something, or help you guys makes things more secure.
07:50:04 <blackdog> LAZAR: the recursive call to fillKnapsack could be fillKnapsack (tail items) (case ... :sack) limit
07:50:07 <merijn> deadalnix: I'm not sure what you mean?
07:50:24 <blackdog> though you shouldn't be using tail anyway, patternmatch the two cases
07:50:37 <deadalnix> merijn, see: https://phabricator.haskell.org/harbormaster/plan/7/
07:51:05 <deadalnix> it"s checking out the source and running a script from the source tree directly. What if I submit a patch for review with something malicious on the validate script ?
07:51:22 <blackdog> but i think other people have weighed in on "not (null items)" being a bad pattern
07:51:46 <merijn> deadalnix: I would assume the validation runs in a sandboxed VM, same for services like TravisCI
07:51:59 <orion> In order for something to satisfy the Monoid laws, must the mappend operator commute?
07:52:16 <merijn> orion: Nope, just associativity
07:52:16 <deadalnix> merijn, i don't see any, so that's why i'm asking.
07:52:25 <orion> merijn: Great, thanks.
07:52:32 <juanpaucar> Hi. Does anybody knows if there's a performance impact on aeson by using C ffi? since aeson 1.2 it is not enabled by default. However, I'm not sure if pure haskell JSON parsing is as fast as C
07:52:43 <merijn> orion: In fact, just doing "flip mappend" is a cheap way to get a new monoid :)
07:52:47 <orion> ha
07:52:47 <blackdog> orion: easy counterexample - [1] <> [2] isn't [2] <> [1]
07:52:54 <orion> blackdog: Ah, indeed!
07:53:07 <merijn> orion: This is the mathematical dual of the monoid, see Dual in Data.Monoid
07:53:23 <merijn> > [1,2,3] <> [4,5,6]
07:53:26 <lambdabot>  [1,2,3,4,5,6]
07:53:30 <merijn> > Dual [1,2,3] <> Dual [4,5,6]
07:53:32 <lambdabot>  Dual {getDual = [4,5,6,1,2,3]}
07:54:16 <merijn> deadalnix: Anyway, #ghc has more people knowledgable about this :)
07:54:20 <erisco> why did my cabal install suddenly break... Warning: cannot determine version of ... gcc.exe ... I am googling it
07:54:36 <deadalnix> merijn, jumping there, thanks
07:55:08 <lyxia> juanpaucar: aeson's Haskell parser is slower
07:56:33 <LAZAR> someone has an idea how to transform this using pattern matching? http://lpaste.net/355542 I figure I would need a lot of patterns (5)
07:56:58 <lyxia> juanpaucar: https://github.com/bos/aeson/issues/535 for the discussion
07:57:05 <erisco> oh... it was the recent Windows 10 update... thanks Microsoft
07:57:26 <sproingie> fillKnapsack firstItem:restOfItems 
07:57:38 * hackage Sit 0.2017.2.26 - Prototypical type checker for Type Theory with Sized Natural Numbers  https://hackage.haskell.org/package/Sit-0.2017.2.26 (AndreasAbel)
07:57:39 <juanpaucar> lyxia: thank you very much. I didn't see that issue before. :)
07:57:53 <sproingie> LAZAR: also, you don't need a case expression on a boolean, you can simply use 'if'
07:58:23 <erisco> lol, all versions of GHC broke on Windows
07:59:08 <cocreature> erisco: there is a fix for at least 8.0.2 and I think also for 7.10.3
07:59:15 <erisco> https://github.com/Mistuke/ghc-compat
07:59:34 <sproingie> LAZAR: since you're using guard predicates, you can always take the true branch out and make it its own guard predicate, and write another declaration afterward for the false case.  they'll always be checked top to bottom
08:00:01 <erisco> hm, but they don't have a fix for 8.0.2 there? =\
08:00:25 <LAZAR> weill this is the base case: fillKnapsack [] sack _ = sack
08:01:07 <sproingie> then you don't need that otherwise case or the (null items) test
08:01:47 <sproingie> just make sure that declaration comes before the one that pattern matches on the list
08:03:57 <LAZAR> sproingie: Like this? http://lpaste.net/355542
08:05:35 <sproingie> looks good.  you don't relly need the 'otherwise' guard, since you could fall through to another declaration, but that's just nitpicky
08:05:55 <erisco> cocreature, any idea where the 8.0.2 patch could be?
08:06:36 <orion> merijn: Are you aware of any logical limits to "monoidal static analysis" on Free Applicatives? For example, if I want to statically analyze a Free Ap for validity with respect to an arbitrary set of rules, are there any limits to the complexity of said rules?
08:06:51 <cocreature> erisco: https://www.haskell.org/ghc/download_ghc_8_0_2.html#windows10-64
08:09:15 <erisco> just need the gcc.exe but if this is where I can get it then alright... thanks
08:10:18 <LAZAR> sproingie: well that would be better i guess since i could replace the guards with an if statement alltogether
08:10:21 <sproingie> stack should work on windows, right?  should plop a working install somewhere in the homedir
08:11:15 <CoolerZ> can you not do arr == [] ?
08:11:43 <CoolerZ> i get a message saying possibly incorrect indentation or missing brackets
08:11:49 <CoolerZ> mismatched*
08:12:21 <cocreature> you can do that (although usually you would use "null arr" instead). the error is from something else
08:12:57 <CoolerZ> cocreature, i get that error in ghci
08:13:04 <sproingie> LAZAR: there's a lot of different ways to write it.  i'm a fan of multiple declarations and single guards, but ultimately you want a style you're comfortable with
08:13:22 <CoolerZ>     parse error (possibly incorrect indentation or mismatched brackets)
08:13:43 <CoolerZ> all i did was  arr = [1, 2]
08:13:46 <CoolerZ> and arr == []
08:13:52 <LAZAR> sproingie: Well after the second refactoring it is way more concise indeed! http://lpaste.net/355542
08:14:23 <cocreature> CoolerZ: works just fine for me. I’m pretty sure you have something weird somewhere else
08:14:24 <byorgey> CoolerZ: when I type those lines in ghci I get 'False'.
08:14:32 <sproingie> LAZAR: that does look a lot more readable than the first version :)
08:14:50 <CoolerZ> cocreature, yeah its actually looking at the file because i have it open in sublimeREPL
08:15:01 <CoolerZ> it works fine in a terminal GHCi
08:15:13 <sproingie> CoolerZ: with those errors, the problem might be before the offending line
08:15:32 <byorgey> CoolerZ: so you have the lines  'arr = [1,2]'  and  'arr == []' by themselves in a .hs file?
08:15:34 <sproingie> in fact with that particular error it almost always is
08:16:14 <byorgey> CoolerZ: unlike at the ghci prompt, you can't have expressions standing on a line by themselves in a .hs file.  So putting    arr == []   by itself in a .hs file is a syntax error.
08:16:22 <sproingie> er except 'arr == []' isn't a top-level statement it knows what to do with
08:16:57 <sproingie> it really could use a friendlier message, it should already be aware of being at the top leve
08:17:43 <CoolerZ> byorgey, no i don't have those in a file, i was just testing those in GHCi to see if you do compare arr == []
08:17:53 <CoolerZ> the file has some other unfinished code
08:20:38 * hackage random-bytestring 0.0.1 - Efficient generation of random bytestrings  https://hackage.haskell.org/package/random-bytestring-0.0.1 (larsk)
08:25:38 * hackage Sit 0.2017.5.1 - Prototypical type checker for Type Theory with Sized Natural Numbers  https://hackage.haskell.org/package/Sit-0.2017.5.1 (AndreasAbel)
08:27:06 <erisco> ehh that's unfortunate... GHC.TypeLits (Nat) and Data.Family.Nat (N) =\
08:28:00 <jle`> yeah, they are different types
08:28:19 <erisco> and Data.Type.Vector is defined on the latter
08:28:30 <jle`> yeah, it makes more sense becuase it's a list
08:28:38 <jle`> the index matches the structure of the type
08:29:02 <jle`> and vector-sized is defined on GHC.TypeLits.Nat
08:29:05 <erisco> but my type literals
08:36:00 <cocreature> meh, looks like vector-sized still does not support unboxed vectors. I guess I need to stop being lazy and figure out how to implement them myself
08:36:34 <jackhill> pun intended?
08:36:39 <cocreature> no :)
08:36:48 <jackhill> :)
08:46:33 <fresheyeball> quick question
08:46:49 <fresheyeball> Does the Linear package export a way to divide a vector by a vector?
08:47:18 <Grisha> fresheyeball: I don’t think this operation is a standard notion in linear algebra
08:47:18 <fresheyeball> div' (V2 x y) (V2 x' y') = V2 (x `quot` x) (x'
08:47:40 <fresheyeball> Grisha: really?
08:47:51 <fresheyeball> multipication seems common
08:48:01 <Grisha> fresheyeball: there’s a scalar, vector, etc. product of two vectors
08:48:09 <Grisha> but no standard division operation
08:48:22 <fresheyeball> div' (V2 x y) (V2 x' y') = V2 (x / x') (y / y')
08:48:27 <fresheyeball> such a thing is not standard?
08:48:29 <Grisha> at least, that’s what I remember from my linear algebra classes
08:48:30 <lyxia> liftA2 (/)
08:48:52 <lyxia> The Applicative instance gives componentwise operations
08:49:08 <Grisha> for me, it has a strong taste of the R language, where you can divide matrices by vectors
08:49:21 <Grisha> and noone knows what that is supposed to mean
08:49:45 <Grisha> fresheyeball: why would you do that?
08:50:14 <fresheyeball> Grisha: I wish to scale a graphic to fit the screen size
08:50:34 <Grisha> fresheyeball: that’s multiplication by a scalar, isn’t it?
08:50:50 <ski> presumably the scaling factors in different directions are different
08:51:15 <Grisha> but the different scaling factors do not represent a vector
08:51:23 <Grisha> looks wierd to me
08:51:27 <Grisha> *weird
08:51:35 <fresheyeball> so I have a V2 with the screen size
08:51:37 * ski nods
08:51:42 <fresheyeball> and a V2 with the graphic's size
08:51:56 <fresheyeball> and I'm using gloss which has `Scale` which is relative
08:52:13 <fresheyeball> so I need the x value to multiply by to get the screen size
08:52:16 <Grisha> i’d rather write a more explicit function like scale xScale yScale v = …
08:52:46 <Grisha> or even better
08:53:00 <fresheyeball> this is my actual code
08:53:02 <fresheyeball> http://lpaste.net/355547
08:53:25 <Grisha> fresheyeball: have you touched OpenGL?
08:53:43 <Grisha> fresheyeball: they have matrices that represent the affine transforms
08:53:46 <fresheyeball> Grisha: I wrote a shader once, but it was very painful
08:53:48 <ph88^> anyone know a function to make a Conduit from stdin and stdout ?
08:54:20 <Grisha> fresheyeball: scaling things like this is an affine transform
08:54:28 <Grisha> for 2D vectors, it’s a 3x3 matrix
08:54:34 <ski> (even a linear one, in this case)
08:54:38 <fresheyeball> While I do like learning new words
08:54:49 <fresheyeball> I admit I don't understand what you mean by affine transformation
08:54:50 <Grisha> depends on the choice of origin 
08:55:05 <Grisha> x = ky is a linear one
08:55:13 <Grisha> x = ky + b is an affine one
08:55:44 <Grisha> for 1d vectors (aka scalars) `x` and `y`
08:55:44 <ski> `x' and `y' (and `b') may be vectors. `k' is then a linear transformation, or matrix
08:57:18 <ski> (in a linear/vector space, there's *the* origin. when using an affine space, there *may* be a *choice* of origin. linear and affine spaces are related, and people don't always distinguish clearly between them)
08:57:20 <Grisha> the trick is that you can rewrite x = ky + b as X = M Y for x = (X, 1), y = (Y, 1) and properly chosen 2x2 matrix M
08:57:47 <Grisha> ski: my linear algebra class was way ago, thank you for correcting
08:58:51 <ski> a very simple picture is that 1-, or 2-, or 3- dimensional space is an affine space. there's no inherent reason to prefer selecting one point in space as "origin", over any other
08:59:13 <Grisha> of course, there is
08:59:21 <Grisha> that’s the tip of my nose
08:59:31 <ski> but if we consider "directed distances" in such a space, then that's a vector space. the origin vector is the zero distance
09:00:30 <cocreature> ph88^: use sourceHandle and sinkHandle
09:00:36 <ph88^> thank you
09:00:41 <ski> altitudes can be thought as an affine space. while altitude *differences* are a vector space
09:01:15 <ski> you can add a vector to a point in space, displacing it some distance in some direction, getting a new point
09:01:38 <ski> but you can't add a point to a point. otoh, you can add a vector to a vector (getting a new vector back)
09:01:57 <Grisha> I’ve got a more haskelly question
09:02:17 <ski> similarly, you can subtract a vector from a point (or from a vector), and you can subtract a point from a point. but you can't subtract a point from a vector
09:02:20 <Grisha> a func of mine computes `maybe empty pure x` (for some x)
09:02:56 <ski> in some sense points in an affine space are "absolute", while vectors in a vector space represent "relative" differences between the former
09:03:02 <Grisha> and the constraint `Alternative f => …. -> f a` is not automatically deduced by ghc
09:03:10 <EvanR> they never introduced "points" in linear algebra class, you just used vectors for that
09:03:26 <EvanR> oh affine space
09:03:33 <ski> EvanR : unfortunately not, aye
09:04:09 <ski> @type maybe empty pure
09:04:11 <lambdabot> Alternative f => Maybe a -> f a
09:04:25 <Grisha> exactly
09:04:35 <LKoen> ski: you can't add two points, but you can take a linear combination whose coefficients sum up to 1!
09:05:01 <ski> LKoen : right. leading to barycentric coordinates :)
09:05:05 <nshepperd_> Grisha: DMR?
09:05:50 <Grisha> I put a type signature :: SomeTypeClass ep =>… -> Reader Config IO (ReturnType ep)
09:06:04 <Grisha> and ReturnType ep is not automatically Alternative, as far as I can say
09:06:28 <Grisha> nshepperd_: dmr?
09:06:56 <ski> (imho, classes in linear algebra (or at least vector spaces) ought to teach some about affine spaces as well, introducing the distinction, since people will in practice need both concepts ..)
09:06:56 <nshepperd_> Oh, it's not going to override your explicit type signature
09:07:00 <ski> @where DMR
09:07:00 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:07:02 <fresheyeball> ski: Grisha: just got back
09:07:16 <fresheyeball> is there a function for my division operation in Linear.Affine?
09:07:21 <ski> (the Dreaded Monomorphism Restriction, to be precise)
09:07:39 <Grisha> nshepperd_: ok, I’ll try to meditate over it
09:07:48 <ski> fresheyeball : not sure, haven't looked in detail at that
09:07:54 <Grisha> nshepperd_: but I don’t immediately see a connection
09:08:11 <lyxia> fresheyeball: liftA2 (/)
09:08:19 <fresheyeball> lyxia: thats what I did
09:08:21 <nshepperd_> You'll need to add Alternative to your type signature explicitly, if you have one
09:08:24 <ski> Grisha : do you have any explicit arguments on the left of `=' in your definition ?
09:08:27 <Grisha> fresheyeball: from the viewpoint of linear algebra, it’s a bit smelly
09:08:34 <ph88^> with optparse applicative how can i make it so that two options are mutually exclusive ?
09:08:41 <fresheyeball> what about this
09:08:55 <fresheyeball> f :: V2 a -> (a -> a -> a) -> a
09:09:00 <fresheyeball> is that a thing?
09:09:15 <Grisha> fresheyeball: you’re trying to make use of ad hoc methods to solve a standard problem
09:09:24 <fresheyeball> f (V2 x y) g = g x y
09:09:29 <fresheyeball> Grisha: yeah, I agree
09:09:31 <ski> even `f :: V2 a -> (a -> a -> o) -> o' should be definable
09:09:39 <lyxia> ph88^: either check after getting your record, or make a trivalued option
09:09:45 <Grisha> ski: I feel stuck with your question
09:09:56 <fresheyeball> Grisha: it doesn't feel good, which is why I'm asking for outside opinions
09:09:58 <ptek> hi everyone. What is the best practical way to do pretty printing to terminal nowadays? I am looking for a good show replacement
09:10:12 <fresheyeball> ptek: check out pPrint
09:10:17 <ski> Grisha : perhaps just show the code in question ?
09:10:27 <ph88^> lyxia, can't i just use <|> ?
09:10:27 <fresheyeball> ptek: from pretty-show package
09:10:31 <Grisha> ski: my func does some IO (http request), parses the reply with the help of Aeson and returns Maybe a
09:10:37 <Grisha> ski: a sec
09:10:47 <nshepperd_> Grisha: if you have a type signature, it's not the DMR. You just need to add Alternative to your type sig
09:10:55 <cocreature> ptek: ansi-wl-pprint is the best released version and if you’re fine with grabbing a library from github, I highly recommend quchen’s pretty printing library on github
09:10:55 <ptek> fresheyeball: thanks!
09:11:00 <lyxia> ph88^: maybe
09:11:23 <fresheyeball> Grisha: is it smelly to `V2 a -> (a -> a -> a) -> a` ?
09:11:23 <cocreature> oh I missed the show replacement, sry
09:11:39 <cocreature> those libs are for when you want to implement your own pretty printing functions
09:12:09 <cocreature> fresheyeball: looks just fine to me
09:12:32 <Grisha> ski: http://lpaste.net/355549
09:13:01 <cocreature> fresheyeball: in fact "fold1" which you get via the Foldable1 instance of V2 is pretty much that
09:13:07 <cocreature> wrapped up in a semigroup constraint
09:13:09 <Grisha> fresheyeball: the standard solution to your problem is to represent scaling (or scaling + shifting) by a linear (or by an affine) transformation
09:13:24 <ptek> cocreature, great, I'll check it out
09:13:44 <fresheyeball> Grisha: can I see that as code?
09:13:44 <cocreature> ptek: this is quchen’s library https://github.com/quchen/prettyprinter
09:14:21 <Grisha> ski: I fail to see that it typechecks without any `Alternative` restrictions
09:14:45 <ski> Grisha : do you get any type errors with that ? if so, could you annotate the paste with them ?
09:14:54 <Grisha> ski: it type checks alright
09:15:02 <Grisha> ski: that’s exactly what makes me nervous
09:15:11 <nshepperd_> Grisha: oh, that last line is using the Alternative instance of ReaderT Config IO
09:15:18 <ski> Grisha : `ReaderT Config IO' has an `Alternative' instance
09:15:25 <Grisha> oh yes
09:15:47 <Grisha> it’s not about `ReturnType` being an Alternative Instance
09:15:49 <Grisha> stupid me
09:15:50 * ski isn't really happy with the `Alternative IO' instance
09:15:54 <Grisha> thanks folks
09:16:29 <Grisha> ski, nshepperd_: but I really would like to do the parsing into eitherDecode
09:16:48 <Grisha> and can’t figure out how to lift it to to Reader Config IO context
09:17:22 * ski isn't sure what `eitherDecode' does
09:17:30 <Grisha> fresheyeball: I don’t have any code, but would start with implementing a type (or a type class) for affine/linear transformation
09:17:32 <ski> what's its type ?
09:17:42 <Grisha> it returns `Either String a`
09:17:48 <Grisha> instead of `Maybe a`
09:17:56 <Grisha> fails with a String-y description
09:18:17 <ski> @type either (const Nothing) Just
09:18:19 <lambdabot> Either b a -> Maybe a
09:18:33 <fresheyeball> Grisha: not good enough? https://hackage.haskell.org/package/linear-1.20.6/docs/Linear-Affine.html#t:Affine
09:18:56 <Grisha> fresheyeball: there are certainly packages around
09:19:10 <Grisha> ski: lemme think
09:19:20 <Grisha> ski: I would loose the String part then
09:19:36 <ski> what would you prefer ?
09:19:43 <Grisha> I don’t know yet
09:19:47 <Grisha> :-)
09:20:08 <Grisha> I guess I could bake in the Either part into the signature of fetch
09:20:23 <Grisha> but this solution seems a bit too unflexible to me
09:20:51 <Grisha> but `fetch` doesn’t do just fetching, it parses too
09:21:05 <Grisha> it’s probably not a good idea to do both things in one func
09:22:34 <Grisha> fresheyeball: I don’t know where you stand, but I would suggest you to read on how to do scaling/shfiting by applying affine transformations. Once you’ve got the idea, the code should fall into the place by itself
09:23:56 <ski> fresheyeball,Grisha : depending, it may be more straightforward to apply a linear (rather than an affine) transformation, since "heterogenous" scaling doesn't need the extra affine machinery
09:25:51 <juanpaucar> Is GHC able to apply more optimizations if I prefer the use of applicative instead of monad operations (whenever possible)
09:25:59 <juanpaucar> ?
09:27:35 <glguy> juanpaucar: Not necessarily. In some cases the results can be slower.
09:28:06 <juanpaucar> glguy: In which cases?
09:28:22 <glguy> In the cases were it's slower. There's no general rule.
09:28:50 <glguy> Using applicative operations isn't an optimization by default, it just might generate different code and that code can be slower
09:29:36 <juanpaucar> glguy: I was thinking that since monad have sequential operations but in applicatives there's no such constraint, then it could paralelize some stuff
09:29:41 <glguy> nope
09:32:03 <juanpaucar> glguy: I see, i was trying to move a parser i have to applicative syntax... but i was reaking my head since i have nothing like (>>=) for applicatives
09:32:13 <juanpaucar> *breaking
09:32:52 <ptek> cocreature, while prettyprinter looks very interesting, it looks like the pPrint from pretty-show is the easiest way to go - it knew how to render my data straight away, whereas the prettyprinter needs some additional instances
09:33:00 <ptek> cocreature, thanks for the link though
09:33:32 <ptek> cocreature, maybe I can help adding the missing instances for containers
09:33:35 <cocreature> ptek: yeah prettyprinter is for the cases where the output of pretty-show is not sufficient for your usecase
09:33:40 <EvanR> i didnt realize you could put then and else on the same column as if, even in do notation
09:33:41 <glguy> juanpaucar: What's a small example of something you didn't know how to translate? http://lpaste.net
09:33:47 <cocreature> it doesn’t make an attempt to generate automatic pretty printers
09:34:14 <ptek> cocreature, yes, it gives a lot of control to the user
09:35:04 <juanpaucar> glguy: https://github.com/juanpaucar/vcf/blob/master/src/Bio/VCF/Parser/Parser.hs#L87
09:35:30 <juanpaucar> I made that parser a while ago, and was trying to optimize it
09:37:18 <glguy> juanpaucar: using applicative operations wouldn't be an optimization here. You can write this using applicative operations but it woudl require you to move the logic on lines 107-111 into the definition of parseFormat
09:38:47 <juanpaucar> glguy: i was afraid of that. Ok, i guess it should be it. Thank you very much
09:39:16 <Grisha> thanks a lot folks and see you around
09:39:46 <Philonous> Is there a way to get rid of unused definition warnings without exporting that definition or disabling the warning alltogether? 
09:40:49 <lyxia> why do you not want to disable the warning
09:41:11 <lyxia> and why do you want to keep an unused definition
09:41:15 <Philonous> Because I want to be warned when there is a genuinely unused definition in my source file.
09:41:28 <Philonous> But I have TH splices that create definitions that I don't care about
09:41:53 <cocreature> you can move the TH splices to a separate module and disable it there
09:42:05 <CoolerZ> whats the function to find index in a arr
09:42:11 <cocreature> there is no way to enable/disable warnings below module level granularity
09:42:30 <Philonous> That would work, yes
09:43:01 <Philonous> OK thanks
09:43:16 <CoolerZ> elemIndex
09:45:18 <EvanR> if you spawn an async that should only throw if theres some sort of bug... then a strategy might be to wrap it in another async that retries N times before rethrowing. but then, what if there are bugs in the retrier? answer: get people on IRC to audit it http://lpaste.net/355551
09:46:21 <EvanR> how reliable do we think the async spawning mechanism is?
09:46:44 <EvanR> i remember someone complaining about async exceptions in some way
09:48:15 <MarcelineVQ> async or asyncronus? asyncronus exceptions aren't neccesarily related to the async package
09:48:40 <EvanR> the last async was talking about asynchronous exceptions
09:50:28 <exarkun> What do I do about "Ambiguous module name"? http://codepad.org/zQyf3iPW
09:51:06 <glguy> exarkun: Either use the PackageImports extension, or add -hide-package flags to your ghc invocations, or use cabal to load your module
09:54:44 * exarkun reads about cabal
09:55:15 <MarcelineVQ> EvanR: I'm not sure where the gotchas might be in your code but fwiw I've had to use uninterruptibleMask in the past to be able to deal with file cleanup when exceptions happen during mapConcurrently, if you find your function not working as expected you should have a look at uninterruptibleMask
09:56:02 <MarcelineVQ> this may not be neccesary at all depending how waitCatch works but I wanted to mention it
09:56:03 <EvanR> doesnt async do that already?
09:56:05 <Philonous> EvanR, Asynchronous exception thrown to the parent async will leave the worker thread dangling. 
09:56:18 <EvanR> o_O
09:56:35 <glguy> exarkun: If you haven't used it yet, the idea is you make a manifest that describes your package (like this one http://hackage.haskell.org/package/array-0.5.1.1/array.cabal ) and then you can use the cabal executable to compile your project or loada the project in GHCi
09:58:00 <glguy> Because you list your package dependencies in that file, the tool knows which packages to hide and which to make available resolving the ambiguity
09:58:14 <kamyar> آثممخ شمم
09:58:17 <kamyar> Hello all
09:58:26 <EvanR> haha
09:58:34 <kamyar> Please help em with this code
09:58:45 <EvanR> backwards arabic
09:59:09 <kamyar> http://lpaste.net/355507
09:59:17 <kamyar> It is using groundhog with TH
09:59:46 <kamyar> EvanR: Yea I am Iranian and our alphabet is very similar
09:59:53 <glguy> Is this what the arabic was supposed to look like? http://imgur.com/a/jKcBR
10:00:13 <kamyar> EvanR: I just forgotten to change keyboard language
10:00:31 <MarcelineVQ> hmm I thought glguy said the other day that the issue there was probably that UUID didn't have an instance of PersistField in Database.Persist.Class  https://hackage.haskell.org/package/persistent-2.7.0/docs/Database-Persist-Class.html#t:PersistField
10:00:41 <EvanR> Philonous: do you think this fixes it? http://lpaste.net/355552
10:00:42 <kamyar> PLease help me fix my code
10:01:05 <glguy> MarcelineVQ: That's what the error message said. I asked if the user expected that there was one
10:01:26 <exarkun> glguy: thanks
10:01:40 <Philonous> EvanR, It solves this particular problem, yes
10:02:24 <EvanR> hrm
10:02:33 <kamyar> Sorry I got DC for a second
10:02:39 <kamyar> Anyone replied me?
10:02:44 <kamyar> http://lpaste.net/355507
10:07:41 <glguy> MarcelineVQ: Look like you've got the documentation for the wrong package.
10:08:17 <MarcelineVQ> quite possibly, I just searched based on the import list of the paste, I don't actually know much about these pieces :(
10:09:11 <kamyar> Hey
10:09:14 <kamyar> I beg
10:09:16 <kamyar> please help me
10:09:25 <kamyar> I have no clue
10:09:56 <maambmb> guys, in the Binary.Get package, how the flip do you get the reamining unconsumed bytestring. Do I have to use runGetOrFailure, runGet doesn't give you the state back like runState does
10:10:18 <CoolerZ> do you guys know about FIRST and FOLLOW?
10:10:33 <CoolerZ> in the context of lr parsing?
10:11:01 <CoolerZ> having some trouble implementing these in haskell
10:11:34 <orion> glguy: I looked at your code last night. It seems like monoidal analysis is impossible to do in a stateful way.
10:12:38 <CoolerZ> how do you have a memo table?
10:12:39 <glguy> orion: If I had to guess at what you mean, I'd guess you're wrong
10:12:45 <glguy> but I'm not sure what you mean
10:12:49 <CoolerZ> do i need to use the state monad?
10:13:13 <orion> glguy: You're documenting the schema by joining Maps together.
10:13:24 <orion> That's the purpose of your analysis.
10:13:39 <glguy> Yes, that's what this particular analysis does
10:14:11 <orion> The purpose of my analysis is to walk through the program and validate that it doesn't violate a set of complex arbitrary rules.
10:14:24 <glguy> orion: OK, do that
10:14:33 <CoolerZ> this is so much easier with access to mutable global state
10:14:57 <EvanR> this doesnt sound like a job for mutable global state
10:15:37 <kamyar> Hey friends
10:15:42 <kamyar> No one can help me fix my code?
10:15:58 <EvanR> do you want to take a bunch of IORefs with you inside a hidden closure that is getting incremental tokens to parse?
10:16:05 <orion> glguy: Well, sure, but I am running into problems that I'm not sure how to solve. For example, when I've arrived at a particular instruction, I need to have some notion of State so that I can answer questions like, "Has the ABC instruction been seen yet? If it has, do x, if it hasn't do y."
10:16:19 <CoolerZ> EvanR, no
10:16:43 <EvanR> whats global about parsing
10:16:50 <glguy> orion: That's fine. You get to pick any Monoid instance you want. so pick one that allows you to do that
10:17:06 <CoolerZ> well the way i implemented first and follow in javascript is to keep a memo table to stop infinite recursion
10:17:44 <CoolerZ> a memo table of firsts and memo table of follows
10:18:08 <orion> glguy: Ah, well I started out with this: data InspectionReport = InspectionReport { hasRule7BeenViolated :: Bool }, and I defined a Monoid instance for it, where mappend is defined as a logical OR between the Bools inside the two InspectionReports.
10:18:43 <CoolerZ> because if you have something like   A -> BA then its going to recurse infinitely when it tries to find FOLLOW(A)
10:18:52 <orion> But that got out of hand quickly because the rules are complex and require me to know things about what instructions have occurred previously.
10:19:34 <kamyar> Hey For God;s sake someone plese reply me
10:20:05 <Clint> kamyar: okay
10:20:14 <EvanR> CoolerZ: right so you might do well to set up a monad to operate an this ambient memo table
10:20:24 <EvanR> not using State directly
10:20:30 <EvanR> on this*
10:21:43 <CoolerZ> a different monad like state?
10:21:47 <glguy> orion: sounds like you need to put more information into your inspection report type then
10:22:19 <EvanR> CoolerZ: like state in that there is some mutable state, but not with an api as primitive as get and put
10:22:40 <glguy> orion: You can pick an arbitrary monoid, you can pick [Instruction] where Instruction is your instruction type, the sky's the limit. You don't even have to perform the whole analysis via a Monoid instance
10:22:59 <EvanR> it would be the commands in the language of your parser algorithm
10:23:00 <CoolerZ> do you need more than get and put?
10:23:06 <EvanR> yes you definitely do
10:23:25 <EvanR> if you read imperative algorithms, they are not written in terms of get and put
10:23:41 <EvanR> to get and put a single global state
10:24:19 <CoolerZ> what imperative algos?
10:24:32 <EvanR> gonna go with LR parsing algorithms maybe?
10:24:47 <CoolerZ> yeah i wrote a lr parser
10:25:03 <CoolerZ> the first and follow is part of generating the table for the parser
10:25:34 <CoolerZ> the parser takes the productions, table and tokens and produces a AST
10:26:58 <CoolerZ> why do you need a different monad that State? you can 'get' the memo table and then 'put' it
10:27:06 <CoolerZ> after updating it
10:27:21 <EvanR> that is a lot of code
10:27:39 <EvanR> unless you do that once in one place and thats the only state action you ever do
10:27:58 <EvanR> in which case, it doesnt seem right to use State at all
10:28:42 <CoolerZ> i am more worried about what happens to the surrounding code
10:29:12 <EvanR> it just sounds like youre trying to insert a single-use mutable variable into a pure function?
10:29:48 <CoolerZ> 'single-use' well its gonna be used in the FIRST function and the FOLLOW function definitions
10:29:51 <ij> ertes, So before anything docker-related I could just build my pkg with nix?
10:30:03 <orion> glguy: I see.
10:30:21 <EvanR> CoolerZ: are you sure you dont want to just pass the table in as an argument?
10:31:09 <CoolerZ> thats probly easier than a monadic bind
10:31:18 <EvanR> probably
10:34:21 <ij> ertes, Okay, I think I can google through this on my own.
10:38:02 <kamyar> Clint: ?
10:38:11 <kamyar> Clint: PLease see my code http://lpaste.net/355507
10:38:20 <Clint> kamyar: which part of the error message don't you understand?
10:38:42 <kamyar> Clint: All of it! It is a TH error wo it is not pointing to my code but generated code
10:38:58 <kamyar> Clint: I know there is some wrong part in my model-mapping 
10:39:09 <kamyar> Clint: But dunno which part
10:40:17 <ptek> I wonder if we have any place with packages which allow to quickly write generic programs. Like the pretty-show, hourglass, wreq or req etc...
10:41:42 <ptek> When one doesn't follow all the packages, a lot of interesting code comes up that simplifies a lot of work for the others.
10:43:00 <ptek> I just realised that the pretty-show package would probably remove a lot of code we have written internally for that purpose because it is  good enough for us, but I never heard of that before today
10:47:19 <koala_man> I have a ipv6-only box with a http proxy. How do I make cabal use it? If I set it up with HTTP_PROXY, it tries using IPv4 and fails
10:47:30 <kamyar> I guess no one can help me
10:47:32 <kamyar> Alas!
10:59:23 <exarkun> I have some code like `data Foo = Foo { x :: String }` and `bar (Foo x) = ...` and ghc 8 (just upgraded from 7.10ish) complains that the binding for `x` in the latter shadows something in the former.
11:00:03 <exarkun> I don't see why this matters or is even shadowing.  I didn't even realize the `x` in the `data` statement created a binding ... does it?  To what?
11:00:45 <EvanR> the accessor x
11:00:50 <jle`> exarkun: it's record syntax
11:00:50 <EvanR> its a top level function
11:01:05 <jle`> exarkun: are you familiar with like, data Person = MkPerson { name :: String, age :: Int } ?
11:01:28 <jle`> that creates a function name :: Person -> String, and a function age :: Person -> Int
11:01:31 <exarkun> jle`: I understand that that defines a constructor `MkPerson` for a type `Person` with two fields, `name` and `age`
11:01:32 <Cale> exarkun: When you define a type like that, you're also defining a function x :: Foo -> String which extracts the field.
11:01:45 <jle`> i'm surprised that older ghc's didn't warn people for this
11:01:59 <exarkun> I didn't realize that defined accessors too, that explains it, thanks.
11:02:19 <jle`> mhm
11:02:21 <exarkun> That's a bit annoying ... the name of the field is the obvious name for the variable...
11:02:41 <jle`> there's actually some syntactical sugar that takes advantage of this
11:02:46 <EvanR> x is a bad name for a field
11:02:55 <EvanR> i mean, x is a bad name for an accessor
11:03:02 <EvanR> and we have them conflated in haskell
11:03:23 <EvanR> .x is different from x in elm, i hear
11:03:37 <jle`> bar (Foo { x }) = ... is syntactical sugar for the shadowy bar (Foo { x = x }) = ...
11:03:53 <jle`> it shadows the accessor x with the locally bound variable x 
11:04:01 <jle`> (this is RecordPuns)
11:04:29 <jle`> and also the infamous RecordWildCards, where bar (Foo{..}) is sugar for bar (Foo {x = x}) = ... (but for all the fields)
11:04:47 <jle`> but yes, typical naming conventions make situations like this rare
11:04:49 <exarkun> is RecordPuns good?  Should I use it?
11:04:58 <exarkun> Or should I have a different naming convention?
11:05:05 <jle`> people usually use "long" and very uniquey record names 
11:05:11 <jle`> and bind it to short variable names
11:05:26 <jle`> data Person = MkPerson { personName :: String, personAge :: Int }
11:05:27 <exarkun> https://github.com/LeastAuthority/s4-wormhole-convergence-agent/blob/haskell/MagicWormholeModel.hs is my actual code and has about a million billion cases of this
11:05:31 <jle`> foo (Person name age) = ...
11:05:42 <Cale> exarkun: Usually I either don't use record syntax, or I just bind the entire record to a variable and use the field accessors in the body of the function.
11:06:10 <jle`> but i do use RecordWildCards a lot, and it's endorsed by Simon Marlow so it can't be bad right
11:06:11 <Cale> It's a bit awkward to pattern match the record fields using the record syntax
11:06:47 <Cale> RecordWildCards can be neat for certain styles of programming, but it has a major downside in that it quietly binds a bunch of names which don't appear locally in the code
11:07:36 <MarcelineVQ> RecordWildCards stress me out when I'm reading something someone else wrote
11:07:42 <jle`> (note that my comment was slightly tongue in cheek, it's definitely not the case that everybody uses it)
11:07:48 <tosun> As of the latest GHC, is it possible to get External Core generated from Haskell code? I believe there used to be an -fext-core flag.
11:07:58 <Cale> MarcelineVQ: exactly!
11:08:04 <exarkun> thanks all
11:08:16 <jle`> RecordWildCards is also kind of weird because it shadows variables with things that have different types
11:08:48 <Cale> Yeah, the shadowing makes it tricky to refactor code which uses RWC
11:08:49 <jle`> it's nice when you only have "one" input of the given data type.  but if you have two, it becomes unusable and you have to switch from record wild cards style
11:10:11 <cocreature> tosun: it’s no longer possible. you can dump the core generated by GHC via -ddump-simpl but that’s only intended for debugging purposes and there is no way to feed it back into ghc to compile it
11:10:21 <zaquest> when i started with haskell i was surprised that ghc warns about it at all, it seems like a job for some linter, not a compiler, and certainly doesnt seem like a good default (arguably even for a linter) to me
11:10:27 <cocreature> also the syntax of that output is not described anywhere afaik and can break at any time
11:10:37 <jle`> warning shadowed variables?
11:10:44 <exarkun> What does the syntax for defining a function that binds the whole record look like?
11:10:44 <cocreature> zaquest: it’s not the default, it’s only in -Wall
11:10:56 <jle`> exarkun: foo b = ...
11:11:00 <exarkun> hmm
11:11:14 <exarkun> in a way that works with pattern matching?
11:11:15 <zaquest> jle`, yes
11:11:24 <exarkun> eg to fix https://github.com/LeastAuthority/s4-wormhole-convergence-agent/blob/haskell/MagicWormholeModel.hs#L83-L84
11:11:30 <jle`> exarkun: the point of this is to not pattern match and to use accessors instead
11:11:38 <zaquest> cocreature, oh, i see
11:11:41 <exarkun> jle`: ah
11:12:04 <exarkun> ok, maybe I can't do that until I fix my data structure to make more sense
11:12:24 <jle`> exarkun: for what it's worth, Message looks like an unideal candidate for a record
11:12:28 <cocreature> zaquest: but I agree that it can be annoying. it’s probably the warning I’m most split about regardless of the language. in Haskell I tend to enable it, in other languages I often don’t
11:12:42 <jle`> exarkun: since literally all of your accessors are partial
11:12:51 <exarkun> jle`: I had been starting to get that feeling
11:12:52 <jle`> so it's like, literally the least ideal candidate for a record
11:13:18 <jle`> i'm using literally as an intensifier here but it is also possibly an accurate description
11:13:24 <exarkun> Heh heh.
11:13:56 <jle`> exarkun: in your case you don't ever really use the accessors or the record names
11:13:57 <exarkun> I haven't had any inspiration about what would replace it yet
11:14:05 <jle`> so you can just get rid of the accessors
11:14:11 <exarkun> yea.  I didn't even _know_ there _were_ accessors ;)
11:14:29 <jle`> data Message = Welcome Double | Ack Double (Maybe Text) | ...
11:14:31 <tosun> cocreature: thanks. also, what exactly is the difference between `-ddump-simpl` and `-ddump-ds`? Which one should I use if I want to deal with Core?
11:14:57 <cocreature> tosun: if you actually want to process the Core you should use a GHC plugin and not use either of those flags.
11:15:01 <jle`> exarkun: for the heavy constructors like 'Letter', you can define a data type that has the fields you want
11:15:25 <jle`> data LetterContents = LC { letterSide :: Text, letterPhase :: Text ...}
11:15:35 <jle`> and then data Message = ... | Letter LetterContents | ...
11:15:43 <exarkun> makes sense
11:15:58 <cocreature> tosun: ddump-ds dumps the core after the desugarer has run while ddump-simpl applies the simplifier first so you’ll get the optimized core
11:16:17 <cocreature> tosun: that’s why if you want to figure out why you’re code is slow, you should typically use ddump-simpl
11:16:32 <MarcelineVQ> where does -ddump-prep fit into that?
11:16:58 <MarcelineVQ> is prep just before stg so it should be the most final version of the core?
11:17:45 <tosun> cocreature: I see. I am interested in the semantics of Core. I guess I should be dealing directly with the `Expr` type from `CoreSyn.hs`?
11:18:08 <cocreature> tosun: I’m the wrong person to ask for that :)
11:18:30 <tosun> cocreature: thank you anyways!
11:18:53 <cocreature> MarcelineVQ: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain claims that you’re right. not sure how large the difference is to ddump-simpl. for some reason that seems to be what everybody uses so I use it as well :)
11:25:19 <africanus> Lauren Kendall Graham
11:25:24 <africanus> golf
11:25:38 <MarcelineVQ> lkg
11:30:58 <bloogie> :t floor . floor
11:31:00 <lambdabot> error:
11:31:00 <lambdabot>     • Could not deduce (RealFrac a0) arising from a use of ‘floor’
11:31:00 <lambdabot>       from the context: (Integral c, RealFrac a)
11:31:08 <bloogie> :( why?
11:31:54 <Tuplanolla> :t floor . fromInteger . floor -- You want this, bloogie.
11:31:55 <lambdabot> (RealFrac a, Integral c) => a -> c
11:32:00 <bloogie> thank you
11:32:07 <jle`> :t floor
11:32:08 <lambdabot> (Integral b, RealFrac a) => a -> b
11:32:11 <Cale> but why?
11:32:26 <kadoban> Why would you do that anyway? Isn't that going to be at-best the same as doing floor once?
11:32:29 <jle`> bloogie: in floor . floor, it's not clear what the intermediate type is
11:32:31 <Cale> When you floor, the result has an Integral type which is going to be incapable of representing a fractional part
11:32:44 <Cale> (e.g. Integer)
11:32:53 <Cale> So doing floor again doesn't make sense
11:33:17 <jle`> floor isn't the same as it is in most other languages, where it returns something of the same type or something compatible with the original type
11:34:12 <jle`> well, it can possibly do that
11:34:24 <bloogie> kadoban: what I wanted to do was floor . sqrt . floor . log
11:34:36 <kadoban> Ah
11:34:37 <jle`> :t floor . (id :: Integer -> Integer) . floor
11:34:38 <lambdabot> error:
11:34:38 <lambdabot>     • Could not deduce (RealFrac Integer) arising from a use of ‘floor’
11:34:38 <lambdabot>       from the context: (RealFrac a, Integral c)
11:34:47 <jle`> oops
11:34:58 <jle`> bloogie: yeah, check out the type of floor
11:35:23 <bloogie> bloogie: it's confusing because I don't know the type class heirarchies :/
11:35:31 <jle`> you can always use ghci
11:35:45 <Tuplanolla> > floor (1e+309 :: Double)
11:35:47 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
11:36:26 <WarmCookie> bloogie: https://i.stack.imgur.com/TrbOX.jpg
11:36:29 <jle`> bloogie: your original thing and your second thing are actually somewhat different problems
11:36:45 <bloogie> jle`: true, but I think I have enough information to solve it now
11:36:48 <jle`> in the original case, you're flooring something to get something of another type, and then flooring that to get something of a third total type
11:37:02 <bloogie> WarmCookie: wow, thanks
11:37:02 <jle`> and haskell can't infer what the second, intermediate type is
11:37:06 <Tuplanolla> Using floating-point math there is questionable, bloogie.
11:37:14 <bloogie> oh
11:37:20 <bloogie> what do I do then?
11:37:24 <jle`> so it's unrelated to the numerical hierarchy
11:37:47 <jle`> in the second case, you have the same issue, but you also have another issue that there isn't any type that floor can give that you can also square root
11:38:05 <bloogie> ugh
11:38:07 <jle`> floor only gives Integrals, so you can pick something like Int or Integer
11:38:13 <jle`> but you can't square root those
11:38:39 <Cale> bloogie: Are you certain you want to double floor like that? What are you computing?
11:39:01 <bloogie> uh, exactly that?
11:39:07 <bloogie> @Cale^
11:39:07 <lambdabot> Unknown command, try @list
11:39:28 <jle`> what are you using this for?  there might be a better way to accomplish this, at the big-picture level
11:39:30 <Cale> I mean, that's fair enough, if you know it's the correct thing -- it just seems a little odd
11:39:39 <bloogie> hmm, okay wait
11:39:49 <jle`> for example, some people use square roots as an upper limit for searching for factors of a number
11:41:25 <jle`> > let isPrime n = any (\x -> x `mod` n == 0) (takeWhile (\x -> fromIntegral x < sqrt (fromIntegral n)) [2..] in isPrime 100
11:41:27 <lambdabot>  <hint>:1:108: error: parse error on input ‘in’
11:41:37 <bloogie> so if you feel like a fun exercise: http://lpaste.net/355553
11:41:50 <jle`> > let isPrime n = any (\x -> x `mod` n == 0) (takeWhile (\x -> fromIntegral x < sqrt (fromIntegral n)) [2..]) in isPrime 100
11:41:52 <lambdabot>  False
11:41:59 <jle`> but you don't have to do the awkward conversions
11:42:08 <jle`> > let isPrime n = any (\x -> x `mod` n == 0) (takeWhile (\x -> x * x < n) [2..]) in isPrime 100
11:42:10 <lambdabot>  False
11:42:14 <jle`> simpler :)
11:42:19 <bloogie> I'm conjecturing that the mystery function g2 is equal to something like even . floor . sqrt . floor . log
11:42:50 <ph88^> how can i make an option like --myoption=alt1|alt2 with optparse-applicative ? i would like to map that to   data MyOption = Alt1 | Alt2
11:43:37 <bloogie> Cale: so I don't really know if it's the correct thing, but yeah, I doubt you'll get much big picture optimization out of it, if I turn out to be correct.
11:44:18 <Tuplanolla> > floor (64 ** (1 / 3)) -- You risk bogus results whenever you use floating-point numbers for discrete math, bloogie.
11:44:20 <lambdabot>  3
11:45:22 <jle`> ph88^: (Alt1 <$ str "alt1") <|> (Alt2 <$ str "alt2")
11:45:23 <Tuplanolla> > 4 ^ 3 -- The correct result would obviously be `4`.
11:45:26 <lambdabot>  64
11:45:39 <bloogie> Tuplanolla: so is there something you can recommend for evaluating the same expression?
11:45:54 <bloogie> ... correctly.
11:45:58 <jle`> ph88^: er wait
11:46:10 <Tuplanolla> Use a number theory library or write your own algorithm, bloogie.
11:46:21 <kadoban> bloogie: You can do floored/ceiling log/sqrt in integrals directly. I don't think they're in base though.
11:46:23 <bloogie> really? isn't that overkill?
11:46:35 <Tuplanolla> No. It's the Right Thing.
11:46:37 <bloogie> kadoban: that sounds helpful
11:46:40 <kadoban> It depends how much it matters to you probably.
11:46:43 <jle`> ph88^: i guess you can do parseAlt "alt1" = Just Alt1; parseAlt "alt2" = Just Alt2; parseAlt _ = Nothing, and do option (maybeReader parseAlt)
11:47:13 <bloogie> Tuplanolla: is it likely that there's some equivalent formulation that I'm missing?
11:47:38 <Tuplanolla> The fact that we have floating-point `sqrt` but not integer `sqrt` in `base` is a historical mistake. One that people keep repeating when designing new languages, I might add.
11:49:03 <Tuplanolla> @let isqrt n = let f x y | y < x = f y ((y + n `quot` y) `quot` 2) | otherwise = x in f n ((n + 1) `quot` 2)
11:49:04 <lambdabot>  Defined.
11:49:20 <Tuplanolla> > fmap isqrt [0 .. 20]
11:49:23 <lambdabot>  [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4]
11:49:30 <Tuplanolla> Have this one on the house, bloogie.
11:49:50 <Cale> Tuplanolla: hey, at least we have gcd in the Prelude ;)
11:50:13 <ski> > gcd 0 0
11:50:15 <lambdabot>  0
11:50:18 <Tuplanolla> Nice. I use it so often I didn't even remember, Cale.
11:50:33 <MarcelineVQ> hmm
11:50:40 <MarcelineVQ> > map (truncate . sqrt . fromIntegral) [0..20] == map isqrt [0..20]
11:50:42 <lambdabot>  True
11:50:59 <ski> > 5 `mod` 0  -- still errors out, though :/
11:51:01 <lambdabot>  *Exception: divide by zero
11:51:04 <jle`> @check \x -> (truncate . sqrt . fromIntegral) x == isqrt x
11:51:06 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
11:51:07 <lambdabot>  -1
11:51:29 <jle`> @check \x -> (x>0) ==> ((truncate . sqrt . fromIntegral) x == isqrt x)
11:51:32 <lambdabot>  +++ OK, passed 100 tests.
11:51:34 <Cale> ski: Should it be the identity map?
11:51:49 <LAZAR> Anyone has an idea how I can incorporate the getRandomNumbers function into the generateItems? http://lpaste.net/355554
11:51:51 <ski> imho, that would be nice, yes
11:52:22 <jle`> LAZAR: how do you want to incorporate it
11:52:44 <ski> (of course `div' would still error out)
11:52:45 <LAZAR> jle`: It is basically only used there so i can as well refactor it inside
11:53:34 <jle`> i do not know how to interpret that
11:53:59 <LAZAR> jle`: I would basically need to generate individual numbers in the generateItems itself
11:54:15 <jle`> it looks like you already did it in line 79?
11:54:33 <jle`> you used them together :o
11:54:38 <Tuplanolla> I wonder if we could use lambdabot to automate floating-point math and other such rants.
11:54:47 <Cale> ski: Or it maybe could just give 0...
11:55:33 <jle`> LAZAR: generateRandomItems n = generateItems (getRandomNumbers gen n)
11:56:10 <LAZAR> jle`: yeah the point is it would be cleaner to remove the getRandomNumbers altogether... but i have no idea how to generate single Integers from a generator
11:56:27 <wolfsif> Hi all
11:56:42 <jle`> LAZAR: ah i see
11:56:48 <wolfsif> Can anyone explain why the monad instance for functions is what it is? I understand what it does, it just seems a little arbitrary
11:56:58 <jle`> wolfsif: well, it's the "only" possible instance
11:57:08 <jle`> so in a sense it is anti-arbitrary
11:57:08 * hackage crdt 0.2 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-0.2 (cblp)
11:57:09 <Cale> wolfsif: Well, let's derive it
11:57:31 <Cale> First of all return :: a -> (e -> a)
11:57:40 <jle`> LAZAR: you can use randomR
11:57:56 <wolfsif> so that must be const
11:58:00 <jle`> :t randomR
11:58:01 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
11:58:15 <Cale> We're given a value of type a, and a value of type e, and asked to produce a result of type a. The only sensible thing we can possibly do is give the first argument back
11:58:23 <Cale> return v e = v
11:58:54 <Cale> Now (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
11:58:54 <ski> Cale : well .. i tend to not like arbitrary choices :)
11:59:13 <Cale> (f >>= g) e = ...
11:59:17 <Cale> So we have f :: e -> a
11:59:21 <Cale> g :: a -> e -> b
11:59:22 <ph88^> jle`, what's maybeReader ?
11:59:24 <Cale> and e :: e
11:59:34 <jle`> ph88^: maybeReader turns a (String -> Maybe a) into a ReadM a
11:59:37 <Cale> and the right hand side has type b
11:59:41 <jle`> so it turns it into a parser of a's
11:59:51 <Cale> The only way to produce a value of type b is to apply g
11:59:52 <bloogie> Cale: isn't it easier to show this kind of stuff for join rather than bind?
12:00:13 <Tuplanolla> Isn't it easier to start from `Functor`, Cale?
12:00:16 <Cale> bloogie: Perhaps, but (>>=) is how you actually get the instance written
12:00:30 <Cale> Right now I'm just deriving the implementation from the type
12:00:36 <wolfsif> it's ok, >>= makes sense
12:00:40 <wolfsif> I see now why it's the only possible instance
12:00:51 <bloogie> huh? can't you pick one of bind and join when deriving it?
12:00:51 <jle`> i think Cale's insight can be trusted in this case
12:01:12 <jle`> no need to second-guess with alternative explanations in the middle of a perfectly good one :)
12:02:00 <Cale> bloogie: Now, if you want to approach it from a completely different direction, there are a few more intuitive explanations we could pick from...
12:02:08 * hackage namecoin-update 0.2.1.0 - Tool to keep namecoin names updated and well  https://hackage.haskell.org/package/namecoin-update-0.2.1.0 (rnhmjoj)
12:02:12 <Cale> er, wolfsif :)
12:02:53 <ph88^> jle`, that wraps my data type into a Maybe .. but what is the meaning of this Maybe ? in case that option was wrong i want to print to stderr and exit program
12:02:53 <wolfsif> Cale: sure, what are a few of those intuitive approaches?
12:03:00 <Cale> One is that to "run" a function means to apply it to the parameter of the function we're writing
12:03:05 <Cale> e.g.
12:03:26 <jle`> ph88^: the Nothing is interpreted by readMaybe/option/the library as a failed parse
12:03:27 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
12:03:29 <lambdabot>  ("hello","olleh","HELLO")
12:03:33 <jle`> so it can be handled by the library
12:03:56 <Cale> Here, x is bound to "hello", y to "olleh" and z to "HELLO"
12:04:31 <jle`> ph88^: that way the library can handle failures in the way it does
12:04:38 <Cale> So, what does x >>= f normally do when run? Well, it first runs x, then it applies f to the result of that, and runs the resulting action.
12:04:50 <ph88^> jle`, aah ok
12:04:56 <jle`> ph88^: so you'd get a nice error like "this option cannot be parsed", and you can even work with the Alternative instance
12:05:08 <Cale> So if "running" means "applying to our chosen argument"
12:05:19 <Cale> (x >>= f) e -- when we run (x >>= f)
12:05:47 <Cale> = let v = x e in ... -- we'll first run x, obtaining some result v
12:06:11 <Cale> = let v = x e in f v ... -- then we'll apply f to it in order to get another action to be run
12:06:18 <Cale> = let v = x e in f v e -- and run that
12:07:27 <Cale> and then a different perspective can also be had, by thinking of functions e -> a as being like arrays indexed by values of type e, holding values of type a
12:07:58 <Cale> This is perhaps a little easier to grasp from the Functor instance first
12:08:05 <wolfsif> Cale: hold on  a sec, need to take a minute to process what you've written so far
12:08:08 <Cale> okay :)
12:08:41 <bloogie> Cale: that was wonderful, is there a paper that deals with this?
12:09:19 <LAZAR> When i have System.Random imported, why does it complain     • Variable not in scope: gen :: StdGen
12:09:48 <ph88^> jle`, how can i make an option   --mynumber   and when the number is -1 i want Nothing and if it's 0 or greater  i want Just 0   ?
12:09:51 <exarkun> What do I do when I have a Lazy Bytestring and a function that takes a regular ByteString?
12:10:25 <Rembane> exarkun: Convert it to a regular ByteString with toStrict.
12:10:35 <Rembane> exarkun: toStrict lives in the Lazy ByteString module.
12:10:36 <ski> bloogie : have you tried the original Wadler papers on monads ?
12:10:41 <Cale> Not in exactly the way that I just treated it, but as far back as the earliest papers by Moggi and Wadler about the relationship between monads and programming, there will be talk of this particular monad
12:10:52 <exarkun> Rembane: thanks
12:10:54 <bloogie> does that go into the function monad, ski ?
12:11:04 <bloogie> this is Reader, right?
12:11:04 <ski> iirc, yes
12:11:13 <ski> but they call it "environment" or "input", i think
12:11:13 <Rembane> exarkun: np.
12:11:23 <ski> bloogie : aye, basically
12:11:32 <LAZAR> When usin randomR repeatedly, how do I make sure the generator is updated each time?
12:11:43 <ski> (they also call `Writer', "output")
12:11:55 * ski prefers the generic name "environment"
12:12:09 <EvanR> :t randomR
12:12:10 <Cale> So one thing to notice about the corresponding Functor instance:
12:12:11 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
12:12:19 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
12:12:26 <Cale> this can only be function composition
12:12:26 <EvanR> LAZAR: it returns the updated generator, each time
12:12:33 <ski> LAZAR : thread the generator through the computation .. possibly with the help of `State' or `StateT'
12:12:42 <jle`> ph88^: i don't think that's normal functionality, but you make a parser for a flag using flag 
12:12:59 <ski> LAZAR : there's also `randomRs', if you just locally need some number of random values of the same type
12:13:00 <Cale> But also, it makes sense intuitively, if you think of a function (e -> a) as a container indexed by values of type e
12:13:03 <jle`> ph88^: then you can use traverse to create bunches of different flags
12:13:07 <EvanR> or use Data.Monad.Random
12:13:23 <Cale> You're applying the function of type (a -> b) to all the "elements" of that container (e -> a)
12:13:31 <wolfsif> that makes sense
12:13:31 <jle`> but then you'd be making a flag parser for every integer heh
12:13:35 <Cale> in order to obtain a container of type (e -> b)
12:13:39 <ph88^> jle`, what do you mean parser for a flag using a flag ?
12:13:50 <jle`> the 'flag' function
12:13:57 <ph88^> oh a function
12:14:01 <wolfsif> my first thought was that the monad instance would just be composition, actually
12:14:06 <jle`> typically optparse-applicative works best when you have a finite number of flags
12:14:23 <Cale> Now from that perspective, maybe it's more natural to describe join first
12:14:33 <ph88^> i just need this logic    if val == -1 then Nothing else Just val
12:14:33 <ski> > (`evalState` mkStdGen 1234) (replicateM 5 (state (randomR (0,9))))  -- in actual practice, use `newStdGen' rather than `mkStdGen'
12:14:34 <Cale> join :: (e -> (e -> a)) -> (e -> a)
12:14:35 <lambdabot>  [7,5,1,6,1]
12:14:48 <jle`> ph88^: can you do something like --myoption 1, --myption 2, --myption 3, etc.?
12:14:55 <jle`> instead of --1, --2, --3
12:14:56 <ph88^> no
12:15:16 <ph88^> the user gives the float precision he wants
12:15:22 <shlevy> Is there any way to declare a type family injective given one of its params is fixed/known?
12:15:23 <jle`>  --precision 10
12:15:27 <Cale> it's going to take a container of containers, and somehow collapse it to a single-level container -- what does it do? Well, it extracts the ith index of the ith container
12:15:31 <ph88^> --precision=3   is default
12:15:36 <jle`> that's fine
12:15:46 <ph88^> --precision=-1  disable 
12:15:48 <Cale> join f i = f i i
12:16:41 <Cale> and then from fmap and join, you can recover bind yet again
12:16:49 <wolfsif> makes sense :)
12:16:57 <jle`> ph88^: that'd be option (mfilter (> 0) auto) (long "precision" <> short 'p'  ....)
12:17:08 <Cale> and note that  return v  is then the container that contains v at every index
12:18:50 <jle`> that error message probably wouldn't be the cleanest
12:18:51 <Cale> For any given monad in Haskell, there tend to be at least two ways to think about its values -- a computational way, and a container-ish way. Sometimes one will make more sense than the other, usually the computation-y way will win, because that's closer to how we're usually thinking, given that we're writing programs.
12:19:03 <ph88^> jle`, doesn't that just validate that the option should be bigger than 0 ?  i would like to be able to disable this precision stuff, the default should be 3
12:19:38 <jle`> ah yea,h sorry, you can have a default value
12:19:51 <Cale> Often the "containers" will get very baroque and involve a lot of the sort of imagination required to think of functions as containers.
12:19:54 <jle`> option myParser (long "precision" <> short 'p' <> value 3)
12:20:18 <ph88^> jle`, in my code i use showpFFloat from https://hackage.haskell.org/package/bytestring-show-0.3.5.6/docs/Text-Show-ByteString.html
12:20:19 <jle`> and fi you had ... <> showDefault, then it'll display the default option in the help
12:20:22 <wolfsif> the containers approach makes more sense to me for some instances -- specifically for Maybe
12:20:35 <jle`> when you do --help, it'll show that the default is 3
12:20:43 <Cale> Yeah, for Maybe and lists, it makes good sense
12:21:02 <wolfsif> Cale: thanks for the explanation, was very helpful
12:21:04 <Cale> But it's important to understand the computational side of those too
12:21:12 <wolfsif> does the monad for functions come up much in practice?
12:21:26 <Cale> wolfsif: Not directly all that often...
12:21:38 <ph88^> jle`, should i build my own parser with one of these functions?  https://hackage.haskell.org/package/optparse-applicative-0.13.2.0/docs/Options-Applicative-Builder.html#g:3
12:21:46 <Cale> But ReaderT does get used in practice.
12:21:48 <jle`> you could
12:21:54 <jle`> 'auto' is already one that just uses read
12:21:55 <ski> for lists, it means "trying all alternatives","nested looping"
12:22:05 <wolfsif> I was about to say it seems like a less general Reader hahah
12:22:15 <jle`> ph88^: auto = maybeReader readMaybe, pretty much
12:22:16 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
12:22:18 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
12:22:32 <jle`> ph88^: but if you want you can use eitherReader to give a nicer error message
12:22:42 <Cale> "Running" a list means to pick an element from it (in all possible ways)
12:22:43 <ski> now throw in a `guard' in there ..
12:22:57 <Tuplanolla> @let toFunc xs = \ i -> xs !! i -- I think this is a nice way to see functions as containers, wolfsif.
12:22:58 <lambdabot>  Defined.
12:23:05 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; guard (even (x + y + z)); return (x,y,z)
12:23:07 <lambdabot>  [(1,4,7),(1,5,6),(1,5,8),(2,4,6),(2,4,8),(2,5,7),(3,4,7),(3,5,6),(3,5,8)]
12:23:07 <ph88^> jle`, i don't think i can use readMaybe here because i need to implement this logic     if val == -1 then Nothing else Just val
12:23:13 <Tuplanolla> :t toFunc "nice"
12:23:14 <ski> if you're familiar with Prolog, then this is a bit like backtracking there
12:23:15 <lambdabot> Int -> Char
12:23:23 <shapr> mm, prolog
12:23:33 <ph88^> hi shapr 
12:23:46 <shapr> hi ph88^ ! How's code?
12:23:53 <ph88^> good :P
12:23:53 * ski nods to shapr
12:24:03 <shapr> tjena ski!
12:24:09 <ph88^> i'm making a small program to some dsp
12:24:12 <shapr> oh neat
12:24:23 <ph88^> measuring TIE
12:24:28 <jle`> ph88^: maybeReader (mfilter (> 0) . readMaybe)), or \x -> case readMaybe x of Just y | y > 0 -> Just y; _ -> Nothing
12:24:37 <jle`> if you like it with points
12:24:40 <shapr> I bought a hat and I'm trying to figure out how to power 100 watts of LEDs on the hat.
12:24:49 <ph88^> lol
12:24:51 <ph88^> thx jle` 
12:24:54 <srk> :D
12:25:04 * ski points
12:25:05 <srk> shapr: ws2812?
12:25:06 <jle`> which is just mfilter (> 0) auto
12:25:15 <shapr> srk: yes, two 144x strips
12:25:19 <srk> want a hat like that as well ^^ :D
12:25:31 <srk> with audio input and fft
12:25:32 <srk> :D
12:25:46 <Cale> shapr: What kind of hat is it?
12:25:47 <shapr> srk: yeah, exactly!
12:25:49 <jle`> but if you like error messages, you can do `auto >>= \x -> if x > 0 then return x else readerError (show x ++ " is too little")`
12:25:52 <shapr> Cale: it's a kavu chillba
12:26:11 <Cale> ah, cool!
12:26:53 <shapr> I did the area calculation to figure out how many LEDs it would hold, looks like I could fit about 250 watts of LEDs, but there's no way I could get more than 15 watts of power in the hat.
12:27:11 <ski> for safety reasons ?
12:27:29 <ph88^> jle`, that code you gave me gives me:  No instance for (Num (Maybe Int)) arising from the literal ‘0’
12:27:35 <shapr> for weight reasons! Six lipo cells is about as much weight as I can possibly consider putting on my head.
12:27:39 <jle`> ph88^: which one
12:27:44 <slack1256> diagrams isn't really for a one off diagram like tikz right?
12:27:46 <Tuplanolla> How about manpower, shapr?
12:27:48 <slack1256> it has other use cases in mind
12:27:52 <slack1256> ?
12:27:59 <shapr> I got some verilog code to drive ws2812b chips, but I'd rather rewrite it in clash-lang so Haskell would be driving my hat.
12:28:27 <shapr> Haskell on Hats! That would be awesome!
12:28:27 <Cale> I've taken to wearing top hats. There'd be a fair amount of room in there for batteries, but I'm not sure how well it'd fit with the aesthetic. :)
12:28:29 <byorgey> slack1256: sure it is
12:28:50 <byorgey> slack1256: I use it for that all the time
12:28:50 <Cale> https://www.historicalemporium.com/store/media/006616/006616_01.jpg
12:28:58 * ski imagines a unicycle with a generator powering shapr's hat
12:29:02 <shapr> Cale: If you put a hundred watts of LEDs on a top hat, I am certain you would fit in at the music festivals I attend.
12:29:07 <shapr> ESPECIALLY if it's running Haskell code!
12:29:23 <Cale> That's a lot of watts for LEDs
12:29:40 <JelloRaptor> Okay I can't figure this out :/ I've got this project (https://github.com/rohit507/sbv-synthesis-toy/blob/master/src/API.hs) where I try to derive Generic on a standard enum and i get " Illegal deriving item ‘Generic'" I've got the extension on, so I have no clue what's doing it
12:29:42 <shapr> yah, I think I may need a capacitor for bursts of color.
12:30:22 <lyxia> JelloRaptor: you might have gotten the wrong "Generics"
12:30:25 <ph88^> jle`, option (maybeReader (mfilter (> 0) . readMaybe)) ( long "precision" ..      
12:30:54 <shapr> Cale: there's plenty of space on that hat you linked for LEDs, I'd suggest the 144 neopixel strips from adafruit.
12:31:04 <Cale> haha
12:31:14 <ph88^> jle`, but this gave the same error:    option (mfilter (> 0) auto) ( long "precision" ..      
12:31:31 <shapr> Cale: have you written any clash-lang code?
12:31:42 <JelloRaptor> lyxia: is there a separate one, other than one in syb? 
12:31:44 <lyxia> JelloRaptor: Data.Generics is "Scrap your boilerplate"-generics, driven by the Data typeclass. The Generic typeclass comes from GHC.Generics.
12:31:48 <slack1256> byorgey: where do I look for just user facing api? Diagrams.Prelude?
12:31:53 <shapr> oh, I need to check on the HacBoston venue again, I want to bring Haskell on Hat to HacBoston
12:31:59 <shapr> HATBOSTON
12:32:00 <byorgey> slack1256: yes
12:32:04 <slack1256> I am more interested on the drawing that learning what TrailLike does
12:32:05 * shapr hops cheerfully
12:32:21 * ski . o O ( HaskBoston )
12:32:41 <Cale> shapr: I haven't, but one of the people who I work with at Obsidian (John Ericson) does
12:32:42 <byorgey> slack1256: and take a look at the tutorials and user manual
12:32:48 <jle`> ph88^: it seems to work for me
12:32:55 <jle`> it's a `Parser a`
12:33:02 <jle`> oh wait, do you expect it to be a `Parser (Maybe a)` instead?
12:33:08 <shapr> Cale: we could have a Haskell on Hat meetup!
12:33:28 <Cale> hahaha
12:33:35 <ski> @where Hat
12:33:36 <lambdabot> http://www.haskell.org/hat/
12:33:45 <jle`> ph88^: right now it's a `Parser a`, and if you use it with optparse-applicative, it will always return a succesful number
12:33:56 <Cale> There would be no question which tool to use to debug the programs running on our hats
12:34:13 <jle`> ph88^: oh i see.  so if you give -1, it should error, and if you give nothing, it will be 3
12:34:37 <jle`> ?
12:34:48 <lyxia> JelloRaptor: GHC.Generics is the newer approach.
12:34:56 <ph88^> jle`, i don't want it to error at -1  .. this is a valid option to disable the floating point rounding
12:35:25 <jle`> so, what should happen when you give --precision=-1 ?
12:35:45 <wolfsif> Cale: do you have any writing on Haskell online?
12:35:51 <ph88^> jle`, i would like to use this logic   if val == -1 then Nothing else Just val    and then use that for the input of the showpFFloat  https://hackage.haskell.org/package/bytestring-show-0.3.5.6/docs/Text-Show-ByteString.html
12:36:12 <ph88^> jle`, with -1 i should get Nothing, with 0 or higher i should  get  Just 0
12:36:21 <ph88^> jle`, with -2 or less i don't care what happens
12:36:23 <jle`> ah, i see
12:36:44 <jle`> and with nothing specified, you'll get 3 ?
12:36:48 <lyxia> JelloRaptor: if you just want to derive Data, you can import Data.Data (from base) rather than Data.Generics
12:36:52 <JelloRaptor> lyxia: aha, two libs I use ask for two different approaches.
12:37:08 <jle`> * Just 3
12:37:22 <Cale> wolfsif: A little here and there. For the most part, I tend to give my bits and pieces interactively via IRC :)
12:37:26 <JelloRaptor> lyxia: cool, that's a lot nicer
12:37:26 <ph88^> jle`, if the option is not on the command line, that is --precision is missing   it would be like --precision=3
12:38:06 <shapr> srk: although I suspect a band pass filter and a noise filter would work just as well as an FFT
12:38:18 <wolfsif> Cale: ok :) -- only problem with IRC is that I can't read all of it hahah
12:38:36 <srk> shapr: indeed but you need variable gain
12:38:57 <jle`> ph88^: that'd be option (\x -> (if x == (-1) then Nothing else Just x) <$> auto) (long "precision" <> value 3 <> showValue)
12:39:08 <ski> @wiki Monads as computation
12:39:08 <lambdabot> https://wiki.haskell.org/Monads_as_computation
12:39:11 <ski> @wiki Monads as containers
12:39:11 <lambdabot> https://wiki.haskell.org/Monads_as_containers
12:39:14 <jle`> ph88^: or (\x -> (if x == (-1) then Nothing else Just x)) <$> option auto (long "precision" <> value 3)
12:39:23 <shapr> @wiki Monads_as_burritos
12:39:23 <lambdabot> https://wiki.haskell.org/Monads_as_burritos
12:39:37 <jle`> oh the first one should be value (Just 3)
12:40:02 <lyxia> JelloRaptor: what libs are you using
12:40:38 <jle`> ph88^: basically you can just do `option auto (long "precision" <> value 3)` to get a Parser Int
12:40:44 <jle`> and you can fmap whatever function you want on it
12:40:51 <lyxia> JelloRaptor: oh I see sbv depends on syb.
12:41:05 <jle`> fmap :: (Int -> Maybe Int) -> Parser Int -> Parser (Maybe Int) 
12:41:22 <jle`> ph88^: that part is pretty much independent of the parsing part, it's just normal haskell sutff
12:44:23 <shapr> srk: ok, I'm convinced. and I discovered that my teensys have FFT libs, so that's likely what I'll use to drive a pile of neopixels for the moment.
12:44:25 <ph88^> aaah ok
12:44:42 <ph88^> i'm familiar with this stuff from megaparsec .. just didn't think of it this way for optparse
12:45:37 <jle`> ph88^: ah yeah.  a `Parser a` is something that can pull an option configuring a value of type 'a' from command line arguments
12:46:16 <ph88^> sweet !
12:46:17 <jle`> so `(f :: a -> b) <$> (p :: Parser a) :: Parser b` maps f over the result of the parser
12:46:21 <ph88^> no more type errors
12:46:33 <ph88^> haven't implemented the logic yet to test the actual option .. but i trust it will be ok now it type check
12:46:44 <jle`> the applicativey part is that Parsers are all run "in parallel"
12:47:05 <jle`> in that they all operate on the same command line argument list
12:47:14 <ph88^> jle`, can i also map validator function over it so that the parsing can fail ?
12:48:24 <Ulrar> Mh, trying to install twitter-conduit warns me that it's going to break a lot of packages reinstalling stuff
12:48:30 <jle`> ph88^: i don't think you can do it directly on a parser
12:48:31 <Ulrar> Is there some trick I should know about that ?
12:48:35 <jle`> failure is a part of the construction of a parser
12:49:57 <ph88^> jle`, after parsing i get a data structure of Options i could then do some further validation and make a new data structure
12:50:03 <jle`> yes
12:50:50 <jle`> but that'll be outside of the Parser system
12:50:56 <jle`> er, outside of optparse-applicative
12:52:12 <lyxia> Ulrar: using cabal?
12:52:46 <Ulrar> lyxia: Yes
12:53:14 <Ulrar> Looks like most of the listed things are : bytestring-0.10.0.2 -> 0.10.8.1
12:53:28 <lyxia> use a sandbox, or the experimental new-build
12:53:57 <Ulrar> lyxia: Well I'm developing an app, there is nothing else on that machine
12:54:18 <Ulrar> So it's conflicting with libs I actually use, looks like
12:55:55 <Ulrar> lyxia: If I use --force-reinstalls, it will at least try to re-install borken packages, right ?
12:56:01 <Ulrar> Who knows, it might work
12:57:38 <lyxia> I don't remember what it does if you still go that way.
12:58:25 <Ulrar> Guess I'll remove the .cabal and .ghc and just add twitter-conduit to my cabal file
12:58:35 <Ulrar> See if it manages to install everything together from scratch
12:59:35 <Ulrar> Looks like the resolution went fine, that's a good sign
13:01:08 * hackage hans 3.0.2 - Network Stack  https://hackage.haskell.org/package/hans-3.0.2 (TrevorElliott)
13:01:12 <lyxia> my guess is that the app is going to run fine, but you are going to run into problems if you do long term development on that machine
13:01:56 <Ulrar> Well tbh, if I just have to rm -Rf .cabal .ghc from time to time, I don't really mind
13:02:05 <Ulrar> It's a big server anyway, it'll compile all of that fast
13:02:38 * hackage split 0.2.3.2 - Combinator library for splitting lists.  https://hackage.haskell.org/package/split-0.2.3.2 (BrentYorgey)
13:02:54 <Ulrar> I just didn't realise cabal didn't like updates
13:13:05 <hvr> Ulrar: that's what's going to change w/ http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
13:13:50 <MarcelineVQ> is there a fixed sized version of Set where an insertion into a full set replaces the most similar occupant? say some size 3 set with the already inserted values [0.0,0.1,2.0]  where insert 0.3 would give you  [0.0,0.3,2.0]
13:14:25 <MarcelineVQ> *most similar/ordinally closest
13:15:11 <t7> is there a name for the thing a function returns that is not a function?
13:15:21 <t7> like the last thing
13:16:57 <Ulrar> Oh that's cool
13:17:00 <Ulrar> I like nix
13:17:37 <glguy> t7: Functions always take one argument and return one result, so there's no special concept of the "last" return.
13:17:57 <EvanR> i thought i was cool trying to show an abbreviated form of the exception by using show . typeOf
13:18:09 <EvanR> but its SomeException...
13:20:57 <kamyar> Helo fellows
13:21:16 <cheater> is stm considered lock-free?
13:22:59 <t7> i think so
13:23:11 <t7> doesnt it retry on fail?
13:23:28 <t7> i watched an spj talk years ago
13:24:02 <cheater> it does retry on fail
13:24:13 <cheater> but like, it does take locks at some point, right?
13:25:13 <kamyar> http://lpaste.net/355558
13:26:26 <fryguybob> cheater: The implementation is close to being lock-free and it is based on one that is, but it isn't quite
13:26:38 <cheater> close to, but yeah, locks at some point
13:26:54 <kamyar> I am trying to change Persistent code to Groundhog. But I have error
13:28:05 <fryguybob> cheater: There is a moment where two committing transactions can cause eachother to abort.
13:28:22 <fryguybob> cheater: So in that rare instance, progress is not made.
13:29:07 <cheater> is stm considered wait-free?
13:29:39 <cheater> fryguybob: yeah, i'm not talking about a case like that, that's degenerate and eventually will resolve itself
13:29:40 <fryguybob> cheater: No
13:29:42 <cheater> as i understand
13:29:47 <cheater> why is stm not wait-free?
13:30:20 <fryguybob> cheater: There is no guarantee that it will resolve itself
13:30:29 <cheater> oh really?
13:31:05 <fryguybob> cheater: "Really not likely in a real world execution" is different from that execution being possible.
13:31:23 <exarkun> Where do I get a SHA256 to pass to https://hackage.haskell.org/package/hkdf-0.0.1.1/docs/Crypto-HKDF.html ?
13:31:37 <fryguybob> cheater: You can craft transactions that will hit that condition repeadedly.
13:31:49 <cheater> oh
13:31:51 <cheater> interesting
13:32:13 <cheater> can you make a version of stm that adds random waits to prevent this?
13:32:16 <fryguybob> cheater: Wait-free means that every thread will always make progress.
13:32:40 <fryguybob> cheater: That would mean no thread could be impeeded by another thread.
13:32:53 <cheater> right
13:32:54 <fryguybob> cheater: You could just fix the problem directly.
13:33:18 <cheater> yea but in a complex system you can't really *predict* that this degenerate case won't happen
13:33:32 <cheater> it sounds to me like it's a situation where a system attains a non-optimal local minimum
13:33:43 <cheater> and can be kicked out of it with some heat
13:33:43 <fryguybob> It is a bit more complicated, but when two transactions are committing and they see the other transaction's lock, they synchronize on an outcome to ensure that at least one of them succeeds.
13:34:07 <cheater> do you know what i mean?
13:34:23 <fryguybob> cheater: Yes that sort of thing is often used in contention management.
13:34:37 <cheater> do you think this could reduce this issue in stm?
13:34:43 <fryguybob> Exponential backoff locks being an example
13:35:28 <fryguybob> cheater: I don't think it is something in Haskell STM that causes anyone issues.  If it is I would love to have a bug report!
13:35:39 <davean> wait-free every member will *eventually* make progress
13:35:43 <cheater> cool fryguybob
13:35:48 <cheater> are you the maintainer of stm now?
13:35:58 <cheater> davean: aha..
13:36:04 <davean> every member always making progress is closer to wait-free population oblivious?
13:36:07 <fryguybob> cheater: I'm a researcher working on implementations.
13:36:13 <cheater> cool!
13:36:34 <cheater> i tried showing someone stm recently, there's a short 16 min video of spj on youtube, but it's without slides :( so they hated it
13:36:34 <fryguybob> davean: Yes eventually being a finite number of steps.
13:36:53 <hexagoxel> MarcelineVQ: you mean something that is 3 times faster than building that function on top of Data.Set? no idea.
13:36:59 <cheater> finite but unbounded by a maximum, right?
13:37:08 <davean> fryguybob: I'm commenting because thays not how I read what you said: "fryguybob cheater: That would mean no thread could be impeeded by another thread."
13:37:43 <fryguybob> davean: :D  By impeeded I mean blocked.
13:38:00 <davean> fryguybob: ah, funny use of the term. I'd not have guessed that.
13:39:21 <fryguybob> davean: Yeah, slowed down for a bit is fine and that probably fits better with "impeeded".  Sorry for the confusion.
13:40:00 <davean> Of course. "Slowed down" is why we have the term wait-free :)
13:40:17 <davean> wait-free can be slowed down quite a lot in practice :/
13:40:43 <davean> ... still waiting for good multicore scaling
13:43:43 <MarcelineVQ> hexagoxel: mostly I'm just curious, there seems to be a lib for everything if a person can find it :>
13:45:58 <hexagoxel> MarcelineVQ: there might even be some package around provides some useful searching for hackage, but nobody has found it yet :>
13:51:26 <ph88^> when is sourceHandle going to throw an exception if the file can not be opened? https://hackage.haskell.org/package/conduit-0.2.2/docs/Data-Conduit-Binary.html
13:51:41 * hackage zip-stream 0.1.0.1 - ZIP archive streaming using conduits  https://hackage.haskell.org/package/zip-stream-0.1.0.1 (DylanSimon)
13:51:48 <ph88^> i mean sourceFile
13:53:17 <ph88^> at runResourceT ?
13:55:53 <JelloRaptor> .pf (\ i -> f (g i) i)
13:56:16 <JelloRaptor> .pointfree (\ i -> f (g i) i)
13:56:21 <JelloRaptor> .pointless (\ i -> f (g i) i)
13:56:26 <JelloRaptor> <_<'
13:56:32 <JelloRaptor> what's the bot's command again? 
13:57:14 <hexagoxel> @pl (\ i -> f (g i) i)
13:57:14 <lambdabot> f =<< g
13:57:14 <shapr> @pl \x -> x + 1
13:57:15 <lambdabot> (1 +)
13:57:50 <JelloRaptor> huh, i suppose it is a reader 
13:58:20 <jle`> @pl \x -> x `f` 1
13:58:20 <lambdabot> (`f` 1)
13:58:59 <jle`> @pl \x -> x ++ 1
13:59:00 <lambdabot> (++ 1)
13:59:07 <jle`> pl must have some really weird special case for +
14:03:16 <jabesed> so I was drafting the design for my structures (which I want modular) and a pattern started to emerge and I'm wonder if it's idiomatic 
14:06:50 <jabesed> the basic idea is to use GADT's to tag the shape of the structure with appropriate types, and then a substructure is obtained via a wrapper structure and type families
14:08:13 <glguy> jabesed: That might not be specific enough to get solid feedback
14:08:46 <jabesed> so one could have e.g.   BaseType1, BaseType2, Exp, :=>: 
14:09:25 <jabesed> this means my structures could be typed e.g.  BaseType2 :=>: Exp (Exp BaseType1) 
14:10:19 <jabesed> but now I only want substructures of the form   t ::= BaseType1 | Exp  t :=> t 
14:11:34 <jabesed> so one would define BT1, :=>>: and use a type family to assign BT1 to BaseType1 and =:> to  Exp t :=>;
14:11:36 <jabesed> ops
14:12:05 <jabesed> so one would define BT1, :=>>: and use a type family to assign BT1 to BaseType1 and t1 :=>>: t2 to  Exp t1 :=>: t2
14:12:32 <jabesed> If this is too vague to get the idea, I'll code it and come back later
14:13:27 <jabesed> the idea though is to have two GADTs using the usual approach to typing each term according to their structure
14:13:44 <jabesed> but have the first defined via calls to the second using type families
14:14:05 <jabesed> which effectively results in a subset of the shapes allowed for the original one
14:21:18 <Unode> If I wanted to fmap something like (||) over a [Bool] what should I use?
14:21:36 <thang1> :t any
14:21:38 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
14:21:50 <thang1> (I think this is the one you want)
14:22:04 <thang1> > any (||) [True, False, True, True, False, False]
14:22:06 <lambdabot>  error:
14:22:06 <lambdabot>      • Couldn't match type ‘Bool -> Bool’ with ‘Bool’
14:22:06 <lambdabot>        Expected type: Bool -> Bool
14:22:11 <Unode> thang1: thanks that's useful but I'm trying to understand the cardinality part
14:22:29 <Unode> i.e, (||) takes 2 arguments..
14:22:43 <thang1> oh right
14:22:55 <jle`> Unode: you can't really fmap (||) over a list of Bool's
14:23:00 <jle`> but you can do things like
14:23:07 <jle`> > fmap (|| True) [False, True, False]
14:23:09 <lambdabot>  [True,True,True]
14:23:17 <thang1> My brain isn't fully awake yet, what jle` said
14:23:19 <ChaiTRex> > any id [True, False, True]
14:23:21 <lambdabot>  True
14:23:22 <jle`> you can fmap (|| True) since it takes a single Bool argument and returns another one
14:23:33 <ChaiTRex> > any id [False, False, False]
14:23:34 <exio4> Unode: I think you might want a fold(r)
14:23:35 <lambdabot>  False
14:23:38 <jle`> if you wanted to fold up (||) over a list of Bools
14:23:45 <Unode> jle`: right, well what I want is more like [1,2,3,4] -> [1 || 2, 2 || 3, 3 || 4]
14:23:47 <jle`> > foldr (||) False [False,True,False]
14:23:49 <lambdabot>  True
14:23:54 <jle`> Unode: ah i see
14:23:58 <ChaiTRex> Unode: You mean like bitwise or?
14:24:03 <exio4> oh, well, that's zip (||) xs (drop 1 xs) :P
14:24:04 <Unode> jle`: yes the fold is my next step, but trying to do it stepwise.
14:24:08 <jle`> you can get a list of consecutive pairs using zip xs (drop 1 xs)
14:24:17 <exio4> zipWith}
14:24:27 <thang1> Unode: the next step? What are you trying to do overall?
14:24:28 <jle`> > zip [1,2,3,4] (drop 1 [1,2,3,4])
14:24:30 <lambdabot>  [(1,2),(2,3),(3,4)]
14:24:36 <jle`> and then yuo can do functions with them
14:24:54 <jle`> > (\xs -> zipWith (||) xs (drop 1 xs)) [True,False,True,True]
14:24:56 <lambdabot>  [True,True,True]
14:25:02 <jle`> > (\xs -> zipWith (||) xs (drop 1 xs)) [True,False,False,True]
14:25:03 <Unode> thang1: the actual thing is [FilePath] -> IO Bool
14:25:04 <lambdabot>  [True,False,True]
14:25:09 * hackage data-tree-print 0.1.0.0 - Print Data instances as a nested tree  https://hackage.haskell.org/package/data-tree-print-0.1.0.0 (lspitzner)
14:25:35 <thang1> So you're taking a list of FilePaths and you want to figure out if they're all valid?
14:26:42 <Unode> thang1: I was trying something like "(||) . doesFileExist" but that is wrong it many ways.
14:27:48 <thang1> So each FilePath in your [FilePath] is a path to a file and you want to determine if all files exist? Or do you just want to operate on all the files that do exist and silently skip empty directories?
14:28:25 <Unode> thang1: no, I actually want a summary over all files. I.e. know if all files exist, otherwise return False.
14:29:38 * hackage snap-server 1.0.2.2 - A web server for the Snap Framework  https://hackage.haskell.org/package/snap-server-1.0.2.2 (GregoryCollins)
14:29:41 <thang1> Okay, I see now. First thing that jumps out to me is that Haskell has an incredibly expressive typesystem compared to most languages and so using boolean feels wrong to me. If you want to know if all files exist or not, why wouldn't you have a type that directly reflects that?
14:29:53 <Unode> jle`: so drop 1 leaves the 1st element out and zip stops as soon as the first list is out of elements, got it. Thanks.
14:29:55 <thang1> (But that's a tangent and minor nitpick)
14:30:43 <Unode> thang1: well, I literally want a yes/no answer so bool read fine.
14:31:59 <ChaiTRex> Unode: Maybe something like: fmap (all id) . mapM doesFileExist $ xs
14:32:44 <glguy> (and = all id)
14:33:29 <c_wraith> ChaiTRex, that works, but short-circuiting might be a nice addition 
14:35:36 <Unode> c_wraith: short-circuiting?
14:36:04 <c_wraith> Unode, stopping as soon as it finds a failing case. 
14:36:17 <Unode> ah
14:36:39 <Unode> and zipWith does that?
14:37:10 <EvanR> zipWith is lazy
14:37:22 <Unode> wait, the lazyness should take care of that right? so you are saying mapM isn't lazy?
14:37:41 <hexagoxel> (monad-loops has andM)
14:38:03 <c_wraith> Unode, mapM is not lazy in IO
14:38:03 <EvanR> @src = mapM
14:38:03 <lambdabot> Source not found. :(
14:38:07 <EvanR> @src mapM
14:38:07 <lambdabot> mapM f as = sequence (map f as)
14:38:23 <EvanR> whether sequence is lazy depends on the monad
14:38:34 <Unode> c_wraith: is that also true of other maps over IO ?
14:38:54 <Unode> I haven't read that far into the IO chapter :)
14:39:29 <c_wraith> sort of.. it's true if you have to perform the IO actions to get the results 
14:39:58 <Unode> I see
14:40:14 <c_wraith> but something like fmap (map (+1)) doesn't care what it's working in.. the inner map will be lazy. 
14:41:41 <Unode> and the outer one would be a "depends"?
14:42:16 <c_wraith> yeah.
14:42:21 <EvanR> Unode: if mapM didnt work like this, for IO, then you would get a list back whose results havent been computed yet. but they depend on IO. so youd be in a position where evaluating the list nodes would cause the IO
14:42:43 <Unode> EvanR: that would sort of make sense no?
14:43:01 <EvanR> it might make sense, but only if you were expecting that
14:43:02 <c_wraith> sometimes. it's how "lazy IO" works. 
14:43:15 <c_wraith> and that has a history of immense pitfalls. 
14:43:18 <Unode> EvanR: I see where you are getting at
14:43:23 <EvanR> if you stored that list for a while, then in a few days checked it, you may be surprised to find it firing missiles
14:43:24 <hpc> the biggest pitfall is you lose purity
14:43:47 <Unode> looping over a list multiple times ends up repeating a whole bunch of IO actions. Got it.
14:43:52 <hpc> IO is tied to evaluation, which is the very single exact thing you can't have in pure code
14:44:02 <EvanR> it wouldnt, see youre confused! ;)
14:44:15 <Unode> So int this case would [FilePath] -> Bool actually be possible?
14:44:31 <Unode> in*
14:44:35 <EvanR> no IO ?
14:44:37 <hpc> depends on what you want to do with that type
14:44:39 <hpc> :t null
14:44:41 <lambdabot> Foldable t => t a -> Bool
14:44:52 <hpc> > null ["/etc/passwd"]
14:44:55 <lambdabot>  False
14:44:56 <c_wraith> if you want to check the file system, no. :) 
14:44:58 <hpc> > null []
14:45:00 <lambdabot>  True
14:46:35 <Unode> EvanR: wait, you said I'm confused. I thought you just said that evaluating list nodes would cause the IO. I know map is over structure only... but from what you said I understood that re-visiting the same element would repeat that IO.
14:47:26 <Unode> c_wraith: right, just making sure.
14:47:43 <c_wraith> Unode, if you really want to experiment with it, you can write your own lazy IO functions with unsafeInterleaveIO 
14:47:49 <hpc> Unode: you can't know for sure
14:48:05 <hpc> Unode: it depends on if reusing the element is actual reuse, or recompuation
14:48:25 <hpc> and that's not something you can reason about without going "what version of what compiler on what architecture?"
14:49:09 <Unode> c_wraith: I don't yet fully understand IO the unsafe variants make it more confusing. Actually it might be the "purity" that is still not quite there.
14:50:51 <ChaiTRex> Unode: Here's one that should short circuit: let allExist :: [FilePath] -> IO Bool; allExist [] = return True; allExist (x:xs) = do { v <- doesFileExist x; if v then allExist xs else return False }
14:51:38 <thang1> Which feels and looks pretty much like straight up imperitive coding with aslightly stronger type system, to me.
14:51:39 <c_wraith> that looks right. 
14:51:58 <Unode> thang1: yeah... the do syntax.
14:52:25 <thang1> Well you can replace do syntax with monads and binding everywhere, but that doesn't really look any better to me :p
14:52:57 <thang1> it's the "if then else" that makes it look imperitive to me. However, that's the short circuiting part, so you can't easily do away with that
14:53:03 <c_wraith> the way you make it feel more functional is separating the loop logic from the predicate. 
14:53:40 <hpc> thang1: imo i wouldn't do away with it
14:53:45 <c_wraith> then the use of it is fine. :) 
14:54:01 <hpc> haskell is probably my favorite imperative language
14:54:25 <athan> is there a `putForcefullyTMVar`?
14:54:26 <thang1> Right. I'm not saying it's a bad way to code, it's just amusing to me how much it looks like imperative code. I tend to like extremely abstract, high level, blisteringly terse styles of code.
14:54:41 <athan> `figginJustTakeTheValueDamnYaTMVar`
14:55:16 <thang1> So seeing do { if then else } tickles me funny; nothing wrong with it, it just looks odd next to maps and folds and what not.
14:55:43 <dmwit> http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:andM
14:55:49 <c_wraith> now I'm thinking about my unsafeInterleaveST terrors... http://lpaste.net/92226#a110207 
14:56:08 <thang1> ಠ_ಠ
14:56:26 <dmwit> allM doesFileExist :: [FilePath] -> IO Bool -- and short circuits correctly
14:56:37 <hpc> c_wraith: that's like defusing a bomb by putting thermite on the detonator
14:56:58 <davean> hpc: to be fair we mostly defuse bombs by blowing them up
14:57:01 <davean> hpc: so ...
14:57:25 <monochrom> There is no thermite. You computer does not catch fire.
14:57:27 <thang1> The difference between defuse and explosion is how much damage happened that we didn't want to have happen :p
14:57:29 <c_wraith> I mostly keep that code around as a demonstration that "unsafe" really means it. 
14:57:54 <thang1> c_wraith: what does it even do?
14:58:33 <c_wraith> thang1, they're supposedly "pure" functions whose results depend on the evaluation order of the results. 
14:58:34 <monochrom> But you could try this analogy: To disrupt XSS malware by ransomware.
14:59:22 <thang1> ahh, I see. Fun stuff there :p
15:05:00 <tdammers> doesn't "defuse" technically mean "removing the fuse"?
15:05:43 <ski> @wn defuse
15:05:44 <lambdabot> *** "defuse" wn "WordNet (r) 3.0 (2006)"
15:05:44 <lambdabot> defuse
15:05:44 <lambdabot>     v 1: remove the triggering device from [ant: {fuse}]
15:07:32 <monochrom> Defusing the bomb by fusing two streams.
15:07:32 <c_wraith> there are some exceptionally stable explosives. like, C4 won't explode if lit on fire. it just burns. it needs a hearty concussion to detonate. you could defuse it safely with thermite. 
15:07:48 <ski> monochrom : istr you had some `unsafeInterleaveST' terrors as well, right ?
15:08:00 <monochrom> YES!
15:09:13 <monochrom> But it's unsafeInterleaveIO.
15:09:32 <monochrom> And it is not horrow. It is bwahahahahha.
15:09:40 <monochrom> s/horrow/horror/
15:17:13 * hackage unfoldable-restricted 0.0.3 - An alternative to the Unfoldable typeclass  https://hackage.haskell.org/package/unfoldable-restricted-0.0.3 (athanclark)
15:29:31 <lpaste> fortruce pasted “ghc-mod Haste” at http://lpaste.net/355559
15:29:40 <fortruce> Is there a way to get ghc-mod to be aware of Haste? I just see the above ^
15:59:38 * hackage hopenssl 2 - FFI bindings to OpenSSL's EVP digest interface  https://hackage.haskell.org/package/hopenssl-2 (PeterSimons)
16:55:36 <LordBrain> Is there a tool to measure the exposure a haskell (cabal) project has on one of its dependencies?
16:55:55 <LordBrain> such as.. list all references to such and such library
16:56:40 <LordBrain> can ghc do it?
17:11:38 * hackage postmaster 0.3.1 - Postmaster ESMTP Server  https://hackage.haskell.org/package/postmaster-0.3.1 (PeterSimons)
17:26:30 <jle`> > (\xs -> zipWith (||) xs (drop 1 xs)) [True,False,False,True]
17:26:33 <lambdabot>  [True,False,True]
17:26:48 <jle`> oh sorry
17:43:21 <exarkun> How do I get the bytes out of a https://hackage.haskell.org/package/cryptonite-0.23/docs/Crypto-Hash.html#t:Digest :/
17:45:03 <lyxia> exarkun: https://hackage.haskell.org/package/memory-0.14.5/docs/Data-ByteArray.html#v:convert perhaps
17:46:05 <exarkun> hrm
17:46:29 <Clint> or use withByteArray, but convert is more fun
17:47:24 <lyxia> there's a prism here which is implemented using convert https://hackage.haskell.org/package/jose-0.6.0.1/docs/Crypto-JOSE-JWK.html#v:digest
17:48:22 <exarkun> I don't know about prisms yet
17:49:42 <Clint> just use Data.ByteArray.convert
17:50:19 <lyxia> it's fine, I was just pointing out that someone else had the same question as you and convert was their answer.
18:02:16 <exarkun> I can't seem to figure out how to use convert.
18:02:26 <EvanR> :t convert
18:02:28 <lambdabot> error: Variable not in scope: convert
18:02:52 <monochrom> Begin with the type.
18:03:01 <Clint> exarkun: what do you want to do with "the bytes"
18:04:07 <exarkun> Clint: Concat them with some others and then stuff the whole thing into hkdf
18:05:20 <Clint> exarkun: so if you wanted to concat into a lazy bytestring you could do something like BL.concat [BA.convert this, BA.convert that, BA.convert theOtherThing]
18:15:00 <exarkun> Clint: I get errors like No instance for (memory-0.14.3:Data.ByteArray.Types.ByteArray ByteString) arising from a use of ‘convert’
18:15:59 <Clint> exarkun: oh right, it only does strict, not lazy
18:16:52 <exarkun> I don't understand where the type error actually happens
18:17:04 <exarkun> and none of the places I've tried randomly inserting a toStrict has made any difference
18:18:29 <EvanR> why would you want a lazy bytestring output
18:18:34 <EvanR> for a digest
18:19:01 <exarkun> I don't really care if it's lazy or strict but there are two kinds of ByteString and not everyone uses the same one
18:19:20 <EvanR> you can convert between them "freely"
18:19:29 <EvanR> (one way may cost you though)
18:19:39 <exarkun> I dunno
18:19:47 <exarkun> I feel like I've spent a good couple hours today converting between them
18:19:50 <exarkun> doesn't feel free to me
18:20:00 <EvanR> and in the case of digests, always getting a strict output is good enough, since going from strict to lazy is cheap
18:20:24 <exarkun> I guess I maybe see why I had that `No instance ...` error and `toStrict` didn't fix it.
18:20:28 <EvanR> digest is consuming input to get an accumulated output. if it was generating a lot of stuff incrementally, youd want lazy
18:20:35 <anoLB> lazy is the default i think exarkun
18:20:41 <Cale> It's really annoying that both types of ByteString have the same name
18:20:43 <exarkun> I really needed a `fromStrict` so that the type would line up with the declared return value of the function
18:20:59 <Cale> Both are useful in different circumstances
18:20:59 <exarkun> now the compiler is happy because it sees convert should return a strict ByteString
18:21:06 <anoLB> you pay a very small penalty if you have a strict chunk wrapped in a lazy bytestring, so for api, i think lazy if you are undecided
18:21:48 <EvanR> undecidedness based api?
18:22:03 <Cale> Strict ByteString is much better if you're working with a lot of small files, or otherwise are in a situation where you're doing I/O with resources that you want to be careful to free.
18:22:06 <anoLB> well if either works and compatibility is hte main concern
18:22:06 <exarkun> this is where I make a monad joke right
18:22:11 <Cale> (sockets would be another example)
18:22:27 <anoLB> yeah some scenarios lazy makes no sense
18:23:00 <anoLB> but there is plenty of overlap where either would be fine, you disagree?
18:23:23 <EvanR> haha Data.ByteStringAnyByteString
18:28:40 <anoLB> probably the effort of thought in compatibilty is misplaced, and you should just use strict
18:29:03 <EvanR> its a digest, use strict
18:29:06 <anoLB> after all, who knows what is going to be convenient 
18:29:35 <anoLB> and strict makes more sense if you put asside the inconvenience of some users running fromChunks or whatever.
18:30:01 <anoLB> i guess lazy if your already using lazy for other things in the same library...
18:31:37 <EvanR> toChunks
19:16:52 <k___> hi all!
19:17:01 <k___> anyone have experience using the haskell autodiff library `ad`?
19:17:18 <k___> i've run into a strange problem using the `realToFrac` function with `ad`, documented here: http://lpaste.net/355566
19:17:47 <k___> in short, using `realToFrac` anywhere in the function that i take the gradient of, causes the evaluated gradient to be 0, even when it should be nonzero.
19:20:42 <lyxia> yes
19:20:48 <lyxia> don't use realToFrac
19:23:19 <lyxia> k___: it's not compatible with the way ad works
19:26:03 <joe9>  I have a list of values indexed by an Int. Would a Data.List still be the best method to represent it? Or, Is there a Data.Map with Int indexes?
19:26:42 <peddie> joe9: see Data.IntMap :)
19:26:43 <EvanR> Map Int a, IntMap a, or HashMap Int a
19:26:57 <EvanR> or Vector a
19:27:33 <joe9> EvanR: Thanks. Map Int a is probably the simplest approach.
19:27:45 <EvanR> the first three all have the same API pretty much
19:27:49 <peddie> EvanR: is there ever any reason to use `Map Int a` over `IntMap a`?  I thought it was the same algorithm, just specialized to use `Int`s?
19:27:57 <EvanR> its not the same algorithm
19:28:00 <peddie> ah OK
19:28:12 <EvanR> but IntMap is probably better when you specifically have Ints
19:28:16 <EvanR> however, see HashMap Int
19:28:32 <peddie> for what it's worth, the last time I used this, `IntMap` was _way_ faster than `HashMap Int` for me
19:28:42 <EvanR> how long ago was that?
19:28:51 <peddie> 9 months ago or so
19:28:55 <EvanR> hmm
19:29:38 <EvanR> we need some benchmark games 
19:29:49 <peddie> heh :)
19:30:16 <peddie> EvanR: https://github.com/haskell-perf/dictionaries
19:33:02 <Unode> in the conduit framework, is it possible to split a single source into multiple sinks where each sink receives part but not all of the data read? e.g. splitting a file into multiple of a fixed size
19:33:15 <k___> lyxia: thanks, do you have any resources on how `ad` works internally? i read the github description but it was too high-level
19:33:25 <k___> i also looked at the source for the `grad` function but didn't understand it
19:35:19 <EvanR> peddie: according to that, HashMap Int beats all on lookups... unless its not a big set
19:35:35 <EvanR> though not by much
19:36:29 <peddie> EvanR: yes, but inserting into an `IntMap` can be significantly faster, even on large sets
19:36:41 <EvanR> peddie: one interesting thing is.... whoever put the blood sweat and tears into any of them ... they were probably running such a bunch mark until they were competable with competition and then quit
19:37:13 <EvanR> the three probably dont have the same amount of performance hacks
19:37:24 <peddie> and insertion is much slower than lookups for both structures, so I would guess unless your algorithm is super lookup-heavy, the insertion time dominates
19:37:41 <EvanR> (that kind of cost matters more in like C where you rewrite all your data structures every time)
19:38:10 <peddie> EvanR: I'm not sure I understand what you mean about the blood, sweat and tears.  as far as I can tell, the commit log comes from folks who are not primarily responsible for implementing those structures
19:38:47 <EvanR> im saying, you put extra work when its not fast enough
19:38:53 <EvanR> but otherwise you probably dont
19:39:10 <EvanR> beyond the basic data structure strategy
19:39:35 <EvanR> and here im saying, "enough" is based on the other data structures there
19:39:56 <peddie> EvanR: I'm afraid I still don't understand what you're getting at, but it seems like all 3 of these have probably had some thought about performance put into them . . .
19:40:05 <lyxia> k___: if you have one hour of free time, this presentation starts from the basics https://www.youtube.com/watch?v=q1DUKEOUoxA
19:40:11 <EvanR> of course
19:40:15 <EvanR> a lot of thought
19:40:53 <EvanR> and the lookup performance there for 1000000 items isnt that different
19:41:04 <EvanR> very interesting!
19:42:21 <k___> lyxia: thank you!
19:43:12 <peddie> EvanR: it would be cool to see the `critbit` package on there
19:43:32 <EvanR> not familiar with Judy
19:43:35 <EvanR> either
19:44:24 <Rotaerk> blah >>= \case { Just x -> f x; Nothing -> return () }
19:44:29 <Rotaerk> there a simpler way to express that?
19:44:37 <Rotaerk> m (Maybe a) -> (a -> m ()) -> m ()
19:45:01 <EvanR> @hoogle m (Maybe a) -> (a -> m ()) -> m ()
19:45:01 <lambdabot> Safe scanl1May :: (a -> a -> a) -> [a] -> Maybe [a]
19:45:01 <lambdabot> Safe scanr1May :: (a -> a -> a) -> [a] -> Maybe [a]
19:45:01 <lambdabot> Agda.Utils.Maybe whenNothingM :: Monad m => m (Maybe a) -> m () -> m ()
19:45:15 <EvanR> whenJust is probably a thing
19:45:19 <peddie> EvanR: good point, I didn't look at the mutable ones.  for the program in question, I did switch to using a mutable hash table from that package, which was pretty slow, and then I switched to OCaml's mutable hash table, which was so much faster I never looked back . . .
19:45:27 <lyxia> (>>= mapM_ f)
19:45:36 <EvanR> peddie: yes, HashTable has a bad reputation these days
19:45:48 <EvanR> HashMap is another subject
19:45:51 <Rotaerk> hmm yea whenJust *is* a thing; thanks
19:46:42 <lyxia> whenJust = for_
19:47:19 <lyxia> = flip traverse = flip mapM_
19:47:34 <Rotaerk> ah
19:47:45 <Rotaerk> thanks
19:48:47 <lyxia> you're welcome!
19:59:52 <k___> lyxia: okay, i think i see the problem--`ad` is carrying the evaluated gradient information in these dual numbers (which are `Reverse s a` which are an instance of `Floating`). so, when i force a `Floating a` into a `Float`, that zeroes the dual number information
19:59:56 <k___> does that sound accurate?
20:22:14 <robertkennedy> How are you guys taking the Haskell Gap/Techempower papers?
20:23:08 * hackage sensu-run 0.0.0 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.0.0 (MitsutoshiAoe)
20:23:08 <robertkennedy> My feeling is that Haskell gives us bang for buck, and the possibility that code will be optimized behind my back to eventually fix the deficits. 
20:24:38 <robertkennedy> But it did partially shatter the believe that Haskell was already rewriting bad (aka readable) code to ninja C
20:24:45 * hackage tmapmvar 0.0.2 - A single-entity stateful Map in STM, similar to tmapchan  https://hackage.haskell.org/package/tmapmvar-0.0.2 (athanclark)
20:36:43 <dalek_> robertkennedy, does that relate to 'what goes on behind the scenes when you compile haskell' ?
20:39:04 <Rotaerk> https://github.com/Rotaerk/iircc/blob/master/src/daemon/Main.hs
20:39:12 <Rotaerk> beginnings of an IRC client \o/
20:41:25 <robertkennedy> dalek_: maybe? I feels more like the benefits of a language where we expect `f x = let y = x + 2 in y + 2` to be the same as `g x = x + 4`
20:42:11 <dalek_> " Haskell Gap/Techempower papers?"
20:42:11 <robertkennedy> Would you consider Haskell to be a declarative language? 
20:42:41 <robertkennedy> Techempower Benchmarks #14 Released with Servant, Yesod, Spock and Snap
20:42:41 <robertkennedy> https://www.reddit.com/r/haskell/comments/6b3dlt/techempower_benchmarks_14_released_with_servant/
20:43:17 <robertkennedy> "Measuring the Haskell Gap" - is that gap melted during following years? Do you think that some knowledge from newest released to public Intel HRC could be reproduced in GHC?
20:43:17 <robertkennedy> https://www.reddit.com/r/haskell/comments/65l3ff/measuring_the_haskell_gap_is_that_gap_melted/?ref=search_posts
20:52:46 <jle`> haskell is a natural fit for libraries and platforms with declarative API's
20:52:54 <jle`> i'm not sure if i would go as far as calling it a declarative language
20:53:11 <jle`> but it's one of the best languages for alloying declarative programming
20:59:11 * hackage data-forest 0.1.0.4 - A simple multi-way tree data structure.  https://hackage.haskell.org/package/data-forest-0.1.0.4 (chris_martin)
20:59:31 <glguy> Rotaerk: I've got a bunch of code for handling IRC if you're in the client business
21:04:39 <glguy> Rotaerk: Also if you keep working on this you might join #haskell-irc
21:08:48 <glguy> bye, lambda_foo
21:09:04 <lambda_foo> :-)
21:09:37 <lambda_foo> fussing about with irc web clients and then auto connecting to channels 
21:23:12 <Rotaerk> glguy, ah, cool
21:24:22 <Rotaerk> the parsing basically seems to work, but it hasn't been tested much yet, against real IRC servers
21:25:06 <glguy> I think you'll have to rip out most of your host parsing for Freenode
21:25:32 <glguy> The published grammar might be useful when composing IRC messages, but it isn't useful for consuming them
21:25:51 <Rotaerk> yea I figured I'd have to do a lot of revision once connecting to real servers
21:30:22 <glguy> The core command parsing and generation of my client is pulled out there http://hackage.haskell.org/package/irc-core
21:31:08 <glguy> https://glguy.net/~pi/c854906056e4ceb0ff61.png
21:31:54 <Rotaerk> hmm if only I'd noticed this before I built the parsers
21:32:02 <Rotaerk> the only irc library I'd run across was "irc"
21:34:08 <Rotaerk> glguy, thanks, I might use that for the parsing aspect
21:34:41 <Rotaerk> should save me effort even at this point, given the amount of tweaking I'd likely need for mine
21:39:24 <Rotaerk> ah, that explains why I didn't notice it... I tend to search on stackage, and it's not there
21:39:40 <glguy> That'd do it, you'll miss a lot that way
21:39:40 <Rotaerk> didn't realize some packages were missing on stackage
21:40:23 <suzu> anyone have experience using snap without heist?
21:40:46 <suzu> i'm using lucid instead and so far i still cant tell if this is a stupid idea or a good idea
21:42:29 <H3lloItsPersonal> hello
22:03:03 <suzu> could be both tbh
22:09:33 <athan> Is there a version of STM where you can block for an indefinite period of time?
22:09:53 <athan> something like an ST-version of yeild/await channels or something
22:11:38 <athan> do {xChan <- newYeildAwaitChanIO; forkIO (threadDelay 1 * year >> yeildChan xChan "foo"); x <- awaitChan xChan; putStrLn x}
22:12:12 <athan> s/1 * year/(1 * year)
22:14:09 * hackage extensible 0.4.2 - Extensible, efficient, optics-friendly data types and effects  https://hackage.haskell.org/package/extensible-0.4.2 (FumiakiKinoshita)
22:18:33 <athan> er, hm, I guess I'm asking this wrong
22:18:59 <athan> how does indefinite locking in STM actually /happen/?
22:36:49 <osa1> how do I specify the resolver when running commands like `stack ghci` ?
22:52:33 <ReinH> osa1: --resolver
22:52:50 <ReinH> stack --help will give you a list of options and commands
22:52:54 <glguy> You can use for_ or traverse_
22:53:02 <glguy> Oh, I was scrolled way up :)
22:53:07 <osa1> ReinH: thanks. I created a stack project just for this.
22:53:15 <osa1> ReinH: stack ghci --help doesn't list it...
22:53:25 <glguy> Rotaerk: for_ or traverse_ in case that didn't come up earlier
22:53:45 <ReinH> stack --help
22:59:03 <Rotaerk> glguy, yea thanks; mapM_ worked in this case, though I ended up eliminating that code anyway...
23:17:33 <dxtr> a/w 29
23:17:37 <dxtr> err, sorry
23:54:41 * hackage atlassian-connect-core 0.8.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  https://hackage.haskell.org/package/atlassian-connect-core-0.8.0.0 (RobertMassaioli)
