00:03:33 <wz1000> Thanks, I got it to work
00:12:55 <paolino> hi, is it possible to gereralize ModT and ModTP in one other type (http://lpaste.net/355142) ?
00:20:46 <wz1000> Why hasn't the ghc package for arch been updated? It was flagged outdated in January.
00:20:58 <cocreature> wz1000: I’ve been wondering that myself
00:21:07 <cocreature> I guess someone should email the maintainer
00:21:14 <cocreature> they probably just forgot
00:23:32 <pacak> wz1000: Probably nobody cares enough about haskell in arch.
00:23:51 <cocreature> pacak: well then they shouldn’t add a package to the repos :)
00:32:45 <Spatial> lpaste.net/355143 returns ones and zeros. Can't I return Vector Int ?
00:33:43 <cocreature> Spatial: what’s the type of step?
00:34:28 <pacak> Spatial: Why IO?
00:34:39 <cocreature> ah it’s from hmatrix
00:34:57 <cocreature> Spatial: just implement your own step function
00:36:32 <Spatial> Annotated lpaste
00:36:52 <Spatial> Using hmatrix
00:38:05 <cocreature> "cmap (\x -> if x > 0 then 1 else 0)" will do what you want I think
00:38:11 <cocreature> and pacak is right. remove IO
00:38:18 <Spatial> Need not be IO
00:58:53 <paolino> is it correct that  when promoted data "P a = P a | N" I need typintype to use "P ()" as a type ?
00:59:37 <paolino> data "P a = Q a | N" I need typintype to use "Q ()" as a type ? -- better
00:59:57 <jle`> you should only need DataKinds
01:00:10 <jle`> and PolyKinds
01:00:13 <jle`> maybe
01:00:21 <jle`> but, i know one way to find out :)
01:02:04 <paolino> well actually a use "Q a" as a type in a typefamily, don't know if it is relevant
01:02:29 <tfc[m]> hey there, anyone using the JHC compiler?
01:02:46 <tfc[m]> i would like to experiment with it because it seems to be easy to link it in lowlevel-context
01:03:49 <jle`> paolino: what does GHC tell you you need?
01:04:09 <paolino> it also compiles only with that
01:05:03 <paolino> tfc[m], what is a lowlevel-context ?
01:05:04 <tfc[m]> well the interesting thing about jhc was that i read that it doesnt use garbage collection like ghc runtimes do etc.
01:05:09 <glguy> cocreature: I updated the aforementioned toml parser to have error productions for unclosed [ and { so you get the error pointing to that character instead of the "unexpected EOF" error
01:05:15 <tfc[m]> so it's easier to get it into an OS kernel
01:05:22 <tfc[m]> kernel
01:05:39 <glguy> https://github.com/glguy/toml-parser/blob/master/src/Parser.y#L97-L98 if you're interested
01:06:26 <cocreature> glguy: great, thanks!
01:07:24 <paolino> jle' https://github.com/paolino/book-a-visit/blob/master/Status.hs#L95
01:08:29 <paolino> jle' and L31 for Presence def
01:09:16 <jle`> did you have a question?
01:09:17 <paolino> if I take off typeintype ghc says I cannot use Present constructor as a type there at 91
01:09:40 <jle`> line 91 seems empty to me
01:09:41 <cocreature> paolino: does it work if you use 'Present?
01:09:56 <paolino> sorry 95
01:10:35 <cocreature> maybe it requires TypeInType because Presence is polykinded?
01:10:55 <paolino> cocreature, no, same error
01:11:12 <paolino> cocreature, no idea
01:11:33 <paolino> I thought typeintype was something unrelated
01:11:48 <jle`> it might be something to do with kinds, yeah
01:11:55 <jle`> if you ever use a kind as a type, you need TypeInType
01:12:07 <paolino> do I ?
01:12:20 <jle`> hard to tell without explicit kind signatures
01:13:59 <jle`> try giving UnPresent a kind signature
01:14:31 <jle`> UnPresent (b :: Presence Role) (a :: ????)
01:14:44 <jle`>                :: Constraint
01:15:33 <paolino> a :: *
01:17:46 <paolino> aside that, why data Presence (a :: kr)  = Present a | Absent doesn't compile and need a GADT ?
01:18:34 <paolino> an ADT has all parameters  of kind * ?
01:22:37 <ADG> wtf is:
01:23:00 <ADG> > :t (foldl (.)) <$> (*2) $ (+3)
01:23:03 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:23:36 <paolino> :t foldl (.)
01:23:37 <lambdabot> Foldable t => (a -> c) -> t (a -> a) -> a -> c
01:23:44 <cocreature> paolino: "Present a" creates a constructor that takes a value of type "a" but your kind might not have values
01:23:47 <osa1_> :t :t foldl (.) id [(*2), (+3)]
01:23:48 <lambdabot> error: parse error on input ‘:’
01:23:49 <ADG> >:t (foldl (.)) <$> (*2) $ (+3)
01:23:58 <ADG> >:t (foldl (.)) <$> (*2) $ (+3)
01:23:58 <ADG> >:t (foldl (.)) <$> (*2) <*> (+3)
01:24:03 <osa1> :t foldl (.) id [(*2), (+3)]
01:24:04 <lambdabot> Num c => c -> c
01:24:37 <jchia> Parser question (e.g. Megaparsec): Let's say I already have a parser p that I want to use to define parser q. p consumes exactly 10 characters and q consumes 8. The result of q is the same as the result of p on the input appended with "00". How can I define q in terms of p?
01:25:01 <paolino> cocreature, that's about the typeintype ?
01:25:02 <ADG> >:t ((foldl (.)) <$> (*2) $ (+3)) $ (+7)
01:25:46 <cocreature> paolino: no about why normal ADTs don’t take non * arguments. e.g. if you set kr = Symbol that ADT can’t be used in a non-promoted way
01:26:11 <cocreature> now I don’t think there is some fundamental reason why we couldn’t remove this restriction from ADTs but it’s there for now
01:27:52 <paolino> ok, thanks. This new haskell type tools are great
01:29:40 <paolino> I mean haskell is revolutionary in the upgrades. No other  language jumps like this I guess
01:35:58 <mivael> > 3 & (&) 13 (/)  -- funny
01:36:01 <lambdabot>  4.333333333333333
01:36:38 <Axman6> what is this nonsense, forth?
01:36:40 <Axman6> :P
01:37:57 <Axman6> jchia: that looks like you should have that dependency the other way around
01:41:05 <Axman6> if it's possible to inject values into the state of the parser, I guess you could push "00" on the front of the inut, but that's a gross hack at best
01:44:20 <kamyar> Hello friends
01:44:25 <kamyar> I have a question:
01:44:50 <kamyar> Suppose I have function of type: String -> String -> Maybe String
01:44:56 <kamyar> called func1
01:45:05 <kamyar> and I have a value of type Maybe String
01:45:09 <kamyar> called x
01:45:18 <kamyar> I wanna call the function with the value without using case
01:45:31 <kamyar> func1 x "test"
01:45:40 <bartavelle> x >>= flip fun1 "foo"
01:45:44 <kamyar> but this raises error cuz x is not string but Maybe String
01:46:03 <kamyar> bartavelle: Thnx! Lets try!
01:46:31 <cocreature> or alternatively "do x' <- x; func1 x "test""
01:46:41 <cocreature> eh "do x' <- x; func1 x' "test""
01:46:54 <bartavelle> yes, do notation is much clearer than '>>= flip'
01:47:57 <kamyar> cocreature: Thnx!
02:10:24 <mivael> kamyar, or this one:   (fromJust $ func1 <$> x <*> pure "another string")
02:19:24 <mivael> kamyar, no, my version does not work if x is Nothing
02:20:13 <kamyar> mivael: Thanx anyway I fixed
02:21:13 <mivael> kamyar, what is your fixed version looks like?  (just curious)
02:31:46 <kamyar> mivael: I revered the case version since it was more clear!
02:32:05 <mivael> :)
03:05:04 <mivael> kamyar,   maybe (const Nothing) func1 :: Maybe [Char] -> [Char] -> Maybe [Char]
03:05:21 <mivael> kamyar,   maybe (const Nothing) func1 x "another string"
03:05:46 <mivael> another unclear alternative  ;)
03:14:58 <dysfun> "i know, i'll just read how aeson implements FromJSON to see how to use generics" -> "there's more than one screenful of imports"
03:19:44 <jabesed> I have caball installed singletons, but "import Data.Singletons" doesn't appear to do the trick
03:20:01 <jabesed> am I forgetting some step? 
03:24:23 <brynedwardz> jabesed: What error are you getting? Is this in a file or ghci? Did you do `ghci` or `cabal repl`?
03:24:49 <jabesed> brynedwardz: in ghci, "Could not find module ‘Data.Singletons’"
03:25:07 <brynedwardz> Try using `cabal repl` instead
03:25:08 <jabesed> brynedwardz: didn't know about cabal repl
03:25:54 <jabesed> brynedwardz: that worked, thanks
03:25:57 <brynedwardz> np
03:26:11 <jabesed> brynedwardz: how new is this? haven't been following haskell as closely as I used to
03:27:54 <brynedwardz> jabesed: Not sure. I use stack instead of cabal as a build tool, but they're similar enough
03:28:20 <jabesed> brynedwardz: I see, thanks
03:28:24 <brynedwardz> jabesed: cabal also has cabal sandboxes now, I think they're the recommended way to build projects
03:29:21 <dysfun> or stack
03:29:24 <guest_> Could someone explane this statement? "The difference between applicatives and monads is that with applicatives, you can see what those components are before you run the program."
03:29:52 <dysfun> guest_: applicatives are only able to fail in isolation, not because of a previous result
03:30:43 <guest_> dysfun: what do you mean fail?
03:31:01 <dysfun> for example, Maybe is an applicative. failing for that would be Nothing
03:32:08 <guest_> dysfun: what is failing for list?
03:34:25 <dysfun> failure is only one potential use case (useful for maybe and either, for example). for lists, the closest thing is the empty list
03:35:09 <dysfun> the core part is the isolation. whereas in a monad, we can perform different logic based upon previous values, with an applicative we can't
03:35:34 <dysfun> one of the more interesting properties of that is that we can see whether it's safe to run some things in parallel
03:37:40 <guest_> dysfun: how can we see if it's safe?
03:37:58 <dysfun> if it only uses the operators from applicative, it is not dependent on previous results, and is thus safe
03:38:42 <rightfold> In f <$> a <*> b <*> c; a, b and c cannot see each other's results, but with a >>= b >>= c they can.
03:39:39 <dysfun> monads naturally encode the moral equivalent of a let statement - the ability to see values in future computations
03:41:02 <guest_> rightfold: so parts of applicative expression is independent and monadic is dependent?
03:41:28 <rightfold> As in data dependency, yes
03:41:35 <dysfun> yes. the range of behaviour you can encode in monadic behaviour is strictly a superset
03:42:07 <rightfold> And because of lack of data dependency, you can parallelise without further coordination
03:43:12 <guest_> dysfun: But I don't undestand what this part means "you can see what those components are before you run the program."
03:43:40 <dysfun> what precedes those words?
03:44:16 <guest_> dysfun: http://elvishjerricco.github.io/2017/03/10/profunctors-arrows-and-static-analysis.html
03:44:33 <rightfold> Functions are opaque. You cannot inspect what f does in x >>= f. But the return value of <*> may not be opaque, so x <*> y may be inspectavle
03:44:41 <mivael> kamyar, another (cleaner) version:   func1 <$> x <*> Just "another_string"
03:45:17 <mivael> (seems like a job for Applicative)
03:45:38 <rightfold> >>= takes a function, and functions are black boxes. <*> does not take or return functions
03:45:38 <dysfun> oh, i think it's just bad wording
03:46:04 <dysfun> the paragraph after that reads better
03:47:00 <dysfun> they're talking from the point of view of batching instead of parallelising, but they're equivalent
03:47:16 <Ieuan> Hi, when I try to load this code https://pastebin.com/GCJt1zYk in ghci, it complains "proc4.hs:48:19: Not in scope: type variable ‘statement’"
03:47:21 <dysfun> if something is monadic, you have to issue the first query to know what to issue in the second
03:47:30 <Ieuan> Not sure what I've done wrong - I'm initialising statement on line 51
03:48:12 <rightfold> Ieuan: try Prog [Stm]
03:48:16 <dysfun> you're using statement as if it was a type
03:48:23 <rightfold> statement is a value, not a type
03:48:24 <dysfun> on line 48
03:48:29 <rightfold> The type of statements is STM
03:48:30 <guest_> rightfold: (+) <$> Just 1 <*> Just 2 how theses Justs can be inspectavle?
03:48:32 <rightfold> Stm*
03:48:35 <Ieuan> rightfold, oh derp, you're right, thanks
03:48:51 <Ieuan> And eurgh, that's given me a massive array of new errors to try and hunt down :')
03:50:41 <guest_> dysfun: Yes, but getUsername is just a function, how <*> can batch them in one query?
03:51:11 <dysfun> well, you choose how to implement <*> based on the types
03:51:30 <rightfold> But getUsername userId1 is not a function
03:51:37 <rightfold> It's a description of how to get stuff
03:51:46 <rightfold> These descriptions can be used to guide batching
03:53:09 <guest_> rightfold: So, it isn't Int -> IO String? But some sort of Int -> Query?
03:53:17 <rightfold> Yeah
03:53:28 <rightfold> IO is like function, a black box
03:54:09 <rightfold> There's nothing you can do to figure out what it looks like, other than to observe its output/effects
03:54:16 <mniip> conflating IO and functions isn't a good idea
03:54:29 <jchia> Lens question: How can I simply express a Lens that will get (1, 3) out of (1, 2, 3, 4)? This doesn't typecheck: view ((,) <$> _1 <*> _3) (1,2,3,4)
03:54:53 <guest_> I think I get it now, thanks.
03:56:26 <cocreature> jchia: the reason why that’s not so easy is that the product of a lens is not a lens because the lenses could overlap
03:57:01 <jchia> cocreature: What does it mean by 'overlap'?
03:57:23 <mniip> jchia, what would the result of setting _1 <*> _1 be
03:57:54 <cocreature> jchia: there are two solutions: 1. write the lens yourself or 2. use "lens (\s -> view _1 s &&& view _2 s) (\s (x,y) -> set _1 x (set _2 y s))
03:58:45 <phadej> http://stackoverflow.com/questions/36521208/how-to-make-the-product-of-two-lenses
03:58:52 <cocreature> eh the first part should be \s -> (view _1 s, view _2 s)
03:58:58 <cocreature> I couldn’t decide between &&& and a lambda :)
03:59:07 <jchia> Thanks. That's quite long. I think pattern matching is more readable.
03:59:39 <jchia> The \s ->(view _1 s, view _2 s) is reasonably readable, too
04:00:14 <dibblego> > (1, 2, 3, 4) ^.. (_1 <> _3) -- there is this, but it is a list
04:00:16 <lambdabot>  [1,3]
04:00:25 <cocreature> you can wrap that up in a “unsafeProduct” combinator and use it for all products where you know it’s disjoint
04:00:33 <cocreature> dibblego: and it’s not a lens ;)
04:00:41 <dibblego> what's not?
04:01:11 <cocreature> _1 <> _3
04:01:21 <jchia> Well, (,) <$> view _1 <*> view _3 seems like a good compromise
04:01:52 <dibblego> I don't think it pretends to be right?
04:02:16 <cocreature> right but jchia said they wanted a lens
04:02:24 <dibblego> ok
04:03:31 <mivael> kamyar, s/cleaner/cleaner but wrong/
04:04:06 <pacak> > (\(a, _, b, _) -> (a, b)) (1,2,3,4)
04:04:09 <lambdabot>  (1,3)
04:04:11 <pacak> magic!
04:04:24 <mivael> kamyar, func1 <$> x <*> Just "another_s" & fromMaybe Nothing
04:24:59 <NickHu> How can I do url unshortening with http-conduit's HTTP.Simple module?
04:27:37 <cocreature> NickHu: unshortening?
04:28:55 <Maxdamantus> Presumably he means reading the `Location` header.
04:29:36 <NickHu> It dumps me at the end of the chain though, where I get a 200 and no Location header is present
04:33:02 <cocreature> NickHu: you can manually use “getRedirectedRequest” but it’s not in the .Simple module
04:34:29 <NickHu> Yeah, figured it out with responseOpenHistory - thanks!
04:46:11 <jchia> Is there any way at all to use a top-level fixed-value variable in pattern matching? E.g. if I have a top-level "foo = 3 :: Int", can I use it to in a match pattern?
04:46:47 <cocreature> jchia: you can’t but what you can do is make a pattern synonym called Foo and match on that
04:47:12 <cocreature> “pattern Foo = 3”
04:48:12 <jchia> cocreature: Thanks.
04:53:37 <Athas> Does Accelerate require LLVM 4.0?
04:53:53 <geekosaur> jchia, you can also use a guard or a view pattern
04:55:44 <snoreven> hey, quick question: can i make the order in an Ord instance dependent on the parameter position. like "compare x y = LT" but "compare y x = EQ"? sounds like a bad idea but i didn't read anything about it in the docs and i'm not 100% sure so i thought i'd ask...
04:56:26 <geekosaur> that's just alpha renaming (the x in the second one has nothing to do with the x in the first, likewise for the y)
04:56:42 <snoreven> i know they are supposed to represent the same value
04:56:52 <quchen> snoreven: Ordering should be an equivalence relation, so that x=x, x=y means y=x, and if x=y and y=z then x=z.
04:56:53 <snoreven> i thought that was understandable ;)
04:57:04 <quchen> The rest is up to you.
04:58:10 <quchen> Oh, I said ordering when I meant equality.
04:59:27 <geekosaur> Athas, it looks like yes. accelerate-llvm depends on llvm-hs which appears to require llvm-4.0. I will further note that that backend works with the LLVM IR, which means hard version dependencies because LLVM IR does not guarantee either backward or forward compatibility (and this bites ghc's own llvm backend as well...)
05:00:07 <quchen> snoreven: But the problem remains: when (x=y) then (y=x). In your question, you wanted (compare x y) to be something else than (compare y x), despite (compare x y) being EQ.
05:02:06 <Athas> geekosaur: too bad - LLVM 4.0 is too recent for any of my systems.
05:02:13 <snoreven> @quchen: hmm, thx.. yeah looks like its a bad idea. i wanted to be able to compare bounds of open and closed intervals via Ord. but i can only do that when i know what's a left and what's a right bound
05:02:13 <lambdabot> Unknown command, try @list
05:02:14 <Athas> Maybe I should try out that Docker thing one of these days.
05:04:04 <snoreven> i made an error in reasoning anyway.. nevermind
05:10:05 <cocreature> Athas: which system are you own? llvm 4.0 is new but if you’re fine with building it yourself then it works even on older systems in most cases
05:10:18 <cocreature> and for some systems there are backports
05:37:07 <Athas> cocreature: sure, but it's more effort than I'm prepared to invest.
05:45:01 <cocreature> fair enough
05:47:34 <ilyanok> Hi, is it normal that the time reported in the my_prog.prof file is 100 times smaller than the actual time measured with the 'time' command? I'm using 'stack build --profile' to build my project.
05:54:25 <Cale> ilyanok: I'm not sure I'd call it "normal", but it indicates that your program isn't spending a lot of time evaluating expressions.
05:54:59 <Cale> For example, if your program was usually blocked on I/O, you would expect to see something like that.
05:55:30 <ilyanok> Cale: what about FFI? Does it count during profiling?
05:56:16 <Cale> Pretty sure it doesn't count.
05:58:47 <ilyanok> thanks for the info. So, what's the right way to profile IO/FFI? 
06:22:00 <dysfun> how does liquid haskell work? is it a preprocessor?
06:22:12 <Ieuan> What are the most common things that might cause megaparsec to hang when you run the parse function?
06:23:24 <ilyanok> Ieuan: left recursion?
06:23:35 <Ieuan> ilyanok, yeah, I think so
06:31:24 <jabesed> I'm thinking of using 'dependent' typing for an AST, still have some reading to do to get up to date with the current status quo 
06:32:10 <jabesed> however my biggest concern right now is with regards losing "access" to useful class abstractions
06:40:54 <DrMentats> is there anything that takes a function a -> b and a monad m [a] and produces m [b]? fmap . map works, but it feels a little weird
06:41:38 <piyush-kurur> DrMentats: fmap (map f) ?
06:42:28 <piyush-kurur> DrMentats: okey I did not see your message fully
06:42:31 <jchia_3> DrMentats: A monad is a functor. Why is that weird?
06:42:58 * byorgey also fails to see what is weird about this.
06:43:18 * piyush-kurur too
06:43:30 <DrMentats> no, I get it, but that's basically fmap . fmap, so I was thinking there must be something like that in the standard library already
06:43:45 <lyxia> fmap fmap fmap
06:44:06 <byorgey> DrMentats: the standard library doesn't often have names for things that can be simply assembled out of a few existing parts.
06:44:07 <piyush-kurur> DrMentats: think of it as composition of the associated functors
06:44:24 <piyush-kurur> Endo functors in this case
06:44:33 <phadej> DrMentats: there isn't, there is http://hackage.haskell.org/package/composition-extra if you want to use <$$> :)
06:44:48 <phadej> and i have seen people defining fmap2 fmap3 etc
06:45:32 <DrMentats> all right, all right, you convinced me
06:46:09 <Unode> For the hspec users in the room. Are hooks always executed regardless of success or failure of tests?
06:46:35 <piyush-kurur> DrMentats: if you are unhappy with the lack of docs of fmap . fmap , you can think of adding a where clause and give a more meaningful name
06:46:39 <byorgey> @type  \f -> getCompose . fmap f . Compose
06:46:41 <lambdabot> forall k (g :: * -> k) (f :: k -> *) a a1. Functor (Compose f g) => (a1 -> a) -> f (g a1) -> f (g a)
06:47:39 <DrMentats> piyush-kurur: I just don't wanna do things that people will look at and say "why didn't he just use that other thing instead?" lol
06:48:10 <DrMentats> but if the natural thing to do is to compose the fmaps, then I shall compose
06:48:27 <byorgey> @type  ala Compose . fmap
06:48:27 <piyush-kurur> DrMentats: I do not think so. If type aliases, function definitions make the code more readable, I am all for it
06:48:29 <lambdabot> forall k2 k3 k1 k5 (a' :: k2) (g' :: k2 -> k3) (f' :: k3 -> *) (a'1 :: k1) (g'1 :: k1 -> k5) (f'1 :: k5 -> *). (Compose f'1 g'1 a'1 -> Compose f' g' a') -> f'1 (g'1 a'1) -> f' (g' a')
06:48:42 <byorgey> DrMentats: ^^^ in that case this is what you should avoid =)
06:48:59 <DrMentats> lol got it
06:49:44 <piyush-kurur> DrMentats: also most of the time it is zero cost as compiler will optimise it out and you do not have do write actual comment
06:49:53 <byorgey> > (ala Compose . fmap) (+1) (Just [2,3,4])
06:49:55 <lambdabot>  error:
06:49:55 <lambdabot>      • Ambiguous type variable ‘a'0’ arising from a use of ‘show_M20834362309...
06:49:55 <lambdabot>        prevents the constraint ‘(Show a'0)’ from being solved.
06:51:36 <piyush-kurur> byorgey: how are you?
06:52:20 <byorgey> hi piyush-kurur, I'm good, how are you?
06:52:30 <piyush-kurur> byorgey: I am fine
06:53:02 <piyush-kurur> the semester got over here so things are less hectic
07:05:21 <mmo> Does anybody know of a way to write GUI-tests for GTK applications (written with haskell-gi) in haskell?
07:08:36 <Unode> mmo: there's probably something that wraps the native gtk testing framework https://developer.gnome.org/gtk3/stable/gtk3-Testing.html
07:08:48 <Unode> but I don't actually know.
07:13:34 <NickHu> Is there a general rule of thumb for when I'd want MaybeT IO a over IO (Maybe a)
07:14:49 <quchen> NickHu: Whatever makes your code more readable. IO (Maybe a) is usually easier to work with. If you have larger transformer stacks (»Maybe plus State plus IO plus Either plus 
07:14:52 <quchen> …
07:15:01 <quchen> then MaybeT begins to become more useful.
07:15:24 <quchen> If you use MaybeT in a too shallow stack you get implicit error handling at the cost of having to liftIO all the time.
07:15:44 <quchen> The runtime cost of both is pretty much identical (if not actually identical), since MaybeT is just a newtype.
07:16:03 <NickHu> So I shouldn't feel compelled to turn every IO (Maybe a) into a MaybeT IO a then
07:16:44 <ezyang> too bad :( 
07:18:34 <kadoban> NickHu: Definitely not
07:20:30 <NickHu> Also, which package should I be getting my monad lifts from?
07:20:51 <NickHu> Say, if I'm using vanilla monad transfomers, Control.Monad.Trans.Maybe
07:21:09 <NickHu> Control.Monad.Trans.Class?
07:21:42 <Unode> NickHu: Control.Monad works for me
07:22:58 <quchen> transformers has the transformers, mtl has the convenience classes for working with them.
07:23:18 <quchen> You should not feel compelled to abstract over transformer stacks of size one, no. :-)
07:23:28 <quchen> I don’t think that’s ever been useful to me.
07:23:37 <quchen> 2 is questionable, when you’ve got 3 stacks begin to shine.
07:23:53 <shapr> begin to shine?
07:23:55 <NickHu> Unode: Control.Monad doesn't have transformer lifts
07:24:13 <quchen> shapr: »remove a lot of pain«
07:24:52 <shapr> oh, I see "when you have a stack of three, transformer stacks start to be really useful.
07:25:06 <quchen> Yes.
07:25:30 <shapr> quchen: that missing comma lost me
07:26:02 <quchen> :set -XImplicitComma
07:26:26 <dolio> shapr: No, it was a command.
07:26:34 <dolio> When you've got 3 stacks, begin to shine.
07:26:42 <shapr> dolio: that's how I read it at first
07:31:20 * shapr shines
07:35:31 <stphrolland> Hi, in a simple program, the main task is to launch a repeated action, I use Control.Concurrent.Timer, with its useful repeatedTimer function. However the main thread does block, so my repeatedTimer function is never called, not even once. How do I block the main thread so as the timer simply gets called endlessly ?
07:41:11 <lyxia> stphrolland: can you show your code
07:41:43 <stphrolland> I think I found, forkIo should be sufficient. let me try first.
07:42:37 <stphrolland> from the package Control.Concurrent.Tread , it is mean to block
07:43:44 <lyxia> what is meant to block
07:44:24 <quchen> cocreature: Breaking change pushed (namely: annotations)
07:44:35 <quchen> cocreature: That’s the end of breakages I think. :-)
07:49:31 <NickHu> is there a builtin to curry a 6-tuple (yes, really)?
07:50:31 <dysfun> is there any way to get type equality back when you've gone existential?
07:51:56 <nshepperd_> dysfun: carry along a Typeable constraint and compare types at runtime
07:52:58 <dysfun> yeah, i thought so
07:54:39 <stphrolland> @lyxia: here's the code http://lpaste.net/355155  , I would like the time to execute, but the main thread seems to almost immidately terminate
07:54:40 <lambdabot> Unknown command, try @list
07:54:48 <stphrolland> lyxia: here's the code http://lpaste.net/355155  , I would like the time to execute, but the main thread seems to almost immidately terminate
07:55:18 <stphrolland> time = timer
07:55:20 <Cale> NickHu: What do you mean by "curry a 6-tuple"?
07:55:40 <Cale> NickHu: Are you just looking for the constructor (,,,,,)?
07:56:12 <lyxia> stphrolland: main has to explicitly wait for its children
07:56:36 <stphrolland> lyxia, but I don't know how to do that
07:56:40 <lyxia> stphrolland: the simplest is with an MVar
07:57:08 <lyxia> stphrolland: http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent.html see "Terminating the program" at the bottom
07:57:50 <stphrolland> lyxia: thanks
07:59:22 <NickHu> Cale: I meant the opposite actually, didn't express it well
07:59:46 <Cale> Pattern matching?
08:00:27 <c_wraith> :t uncurry (,)
08:00:30 <lambdabot> (a, b) -> (a, b)
08:00:34 <c_wraith> fancy id
08:05:55 <bcq> i've seen talk of porting Elm to X, specifically Erlang, and people have even tried it. is Elm on Erlang an oxymoron? don't you need IO and all of the monads Haskell gives you?
08:10:53 <shapr> Cale: want to write an article for TMR?
08:11:59 <lyxia> shapr: do you have suggestions for topics
08:12:19 <shapr> lyxia: something Haskell related, that you want to write about?
08:13:04 <shapr> lyxia: I'm writing about clash-lang, someone else is doing d3js visualization from Haskell
08:13:27 <shapr> lyxia: what would you like to write about?
08:13:37 <lyxia> that's my question :)
08:14:27 <shapr> lyxia: look at the last few projects where you've written code, pick one you want to describe?
08:15:57 <lyxia> Yeah. I'll think about it.
08:16:43 <shapr> lyxia: do you have projects up on github?
08:19:26 <lyxia> Yes indeed.
08:20:56 <fosterite> bcq: you could compile to the erlang VM (BEAM)
08:24:49 <stelleg_web> does anyone know how to access opaque c constants in haskell?
08:25:26 <byorgey> shapr: are you reviving TMR?
08:25:34 <stelleg_web> if I have a header that has something like "extern const myStructType defaultValue;", it would be great to be able to access that
08:25:59 <stelleg_web> preferrably using c2hs
08:29:42 <mnoonan> stelleg_web: this doesn't directly answer your question, but have you tried inline-c?
08:30:49 <stelleg_web> mnoonan: briefly, but it seemed a little painful to work with non-standard C types
08:32:02 <mnoonan> stelleg_web: I've been using it to wrap a C++ API, and so far (for my admittedly simple cases), I've been able to get pretty far just by adding things to the typemap in the Context.
08:32:55 <stelleg_web> mnoonan: oh cool, can you point to any resources that show how to do that?
08:35:35 <mnoonan> stelleg_web: I just went from the docs here: https://hackage.haskell.org/package/inline-c-0.5.6.1/docs/Language-C-Inline-Context.html to the source for baseCtx. Then just below it is the default C type table. You can add other Haskell types as long as you have a Storable instance.
08:36:00 <mnoonan> I don't think you can get much control over how things are marshalled beyond the Storable instance, but that might be enough for you
08:37:13 <koneida> Hello everyone. If I'm programming a game with a grid in an imperative context, and I want to, say, check the neighbors of every element, the idiom is to use a nested for loop and look at neighbors by futzing with indices. What is the equivalent haskell idiom?
08:38:22 <stelleg_web> mnoonan: thanks. I remember now I was intimidated by having to use template haskell, but maybe I should finally just take the plunge
08:39:00 <mnoonan> stelleg_web: for what it's worth, I'm very un-TH-savvy and am managing to muddle through ok :)
08:45:03 <stelleg_web> mnoonan: I guarantee I'm even more un-TH-savvy :). thanks for the help
08:45:51 <Cale> koneida: Well, probably you produce a list of the things you want to look at.
08:50:04 <koneida> Cale: Yes, of course, but are there library functions that help with this? For instance, I don't see anything like a map that operates on a list and takes a ((row,col) -> a -> b). 
08:50:20 <Cale> Well, lists aren't meant to be accessed randomly
08:50:38 <Cale> Think of a list as basically being a loop waiting to happen.
08:51:08 <Cale> If you're going to be accessing it randomly, you probably want to use a Map or Array or something for your grid.
08:51:28 <MitchellSalad> what's are people's preferred SQL solution these days?
08:51:51 <koneida> Cale: Right, I guess that's what I'm asking -- for random access, I should use Array?
08:52:46 <dysfun> MitchellSalad: esqueleto is pretty neat
08:52:48 <MitchellSalad> koneida: depends, might you be consing onto this thing? that's O(n) for an array
08:53:17 <koneida> MitchellSalad: In the case I'm working on now, it's a fixed size.
08:53:42 <MitchellSalad> ah, then yeah, Array or Vector
08:53:53 <Cale> See https://hackage.haskell.org/package/grid for useful geometric operations
08:54:12 <Cale> (Though for a square grid, maybe that's a bit of a waste)
08:56:17 <koneida> Yeah, square grid.  I was also thinking I could convert from a simple [[a]] to a graph. That way each node would know its neighbors. I was just curious if there was a more idiomatic approach.
08:57:44 <Cale> koneida: Once you have some type Grid a for a grid whose cells are labelled with values of type a, you might want to write a function Grid a -> Grid (Set a) which produces the same grid structurally, but where each cell is labelled with the values of the neighbours of that cell in the original grid
09:05:53 <Aruro> does somebody use Array?
09:06:09 <Aruro> array is like magnetic tape, relict
09:07:58 <Cale> I'd still use it sometimes.
09:09:20 <istvan> I have an embarrasingly dumb question: how do I resolve Could not find module ‘Data.Tree.Zipper’ ? I can't seem to find a package missing in cabal
09:09:31 <istvan> I can import Data.Tree just fine
09:09:48 <jle`> istvan: that depends; where does Data.Tree.Zipper exist?
09:09:51 <jle`> what package is it in?
09:09:58 <jle`> or, does it even exist at all?
09:10:16 <Cale> There appears to be a package called rosezipper that has a module with that name
09:10:29 <Cale> Data.Tree is from containers, but containers doesn't have a Data.Tree.Zipper
09:10:35 <istvan> ah, I'll give that a shot
09:10:48 <jle`> istvan: do you know how to look up documentation for a package?
09:10:53 <istvan> Is that a cannonical zipper implementation or should i write my own like most examples seem to?
09:11:10 <istvan> jle`, I am looking at https://hackage.haskell.org/package/rosezipper-0.2/docs/Data-Tree-Zipper.html -- it is now obvious its in rosezipper
09:12:35 <Cale> I almost never have a use for a tree type which isn't at least somewhat specialised to the application at hand. So usually I'd also be writing a zipper for the specific sort of tree that I was working with by hand as well.
09:13:38 <Cale> But if you're using Data.Tree, then this is an appropriate zipper for that.
09:17:40 <istvan> I'm not entirely sure yet that zipper is what I actually need, perhaps I can get advice on a better approach. I have an AST (not a Data.Tree, but rather something of my own design) where each node is an operation: multiply, add, or load (a constant). I have a CPU with an add pipe and a multiply pipe, and I want to schedule each operation. I need to ensure no node is scheduled until all of its children have completed, and I can't 
09:17:41 <istvan> schedule more than one multiply or add per cycle. Any suggestions how I might approach it?
09:19:08 <Cale> I'd probably just use a Map Integer Instruction
09:19:31 <Cale> (as the type of schedules)
09:20:10 <tobiasBora> Hello,
09:20:18 <tobiasBora> I'm using System.IO.hGetLine
09:20:29 <istvan> Cale, not sure I follow
09:20:30 <tobiasBora> when the input is a linux file no problem
09:20:52 <tobiasBora> but when the input is a DOS formated file (ending with \r\n), then I get the \r in my line
09:21:07 <tobiasBora> how could I get rid of this \r properly, ie not using a dirty regex ?
09:21:49 <istvan> Cale, to be clear, I am not trying to evaluate the instructions, I am trying to build the schedule not evaluate it. The trick is the entire left subtree might be multiplies and the entire right tree might be adds and I would like to interleave them, not evaluate one subtree then another
09:21:54 <Cale> tobiasBora: By setting the encoding on the Handle correctly
09:22:58 <Cale> istvan: Actually, you probably don't even want a tree, but a proper graph type for that bit.
09:23:21 <Cale> e.g. you might have let x = 5 + 5 in x * x
09:24:08 <Cale> istvan: and you don't want to have to evaluate x twice then.
09:24:53 <tobiasBora> Cale: I found hSetNewLineMode handle universalNewlineMode, is it that ?
09:25:02 <Cale> tobiasBora: ahh, yes
09:25:37 <tobiasBora> ok thank you!
09:26:09 <NickHu> Is there a function that goes from a string like "/some string/" to "some string"?
09:26:20 <Cale> tobiasBora: Well, possibly you also want to set outputNL appropriately.
09:26:21 <NickHu> That isn't something like drop first and drop last
09:26:54 <Cale> NickHu: Can you explain what you want the function to do?
09:27:03 <Cale> Remove all slashes?
09:27:08 <tobiasBora> Cale: I think default outputNL is ok
09:27:44 <jle`> > const "some string" "/some string/"
09:27:46 <lambdabot>  "some string"
09:28:19 <NickHu> Cale: Yeah, pretty much
09:28:30 <NickHu> I suppose I could filter it
09:28:35 <istvan> Cale, for my first Haskell project I'm not doing a full optimizing compiler, just a bare-minimum calculator for a VLIW CPU. I'm not worried about CSE at this point
09:28:39 <jle`> > filter (/= '/') "/some string/"
09:28:42 <lambdabot>  "some string"
09:28:51 <NickHu> Actually, what I want is that the function checks it's of the form "/a/" first
09:28:57 <NickHu> Basically what I'd use a regex for in another language
09:29:10 <jle`> what do you mean by 'of the form "/a/"'
09:29:15 <jle`> that it has two slashes?
09:29:20 <jle`> it is three characters long?
09:29:34 <NickHu> It's a string delimited by slashes
09:30:02 <mnoonan> istvan: Can do you it greedily? like, compute a topological order on your expresison dag, then emit the first available instruction for the correct pipe, or go to the "wrong" pipe if you have no other choice?
09:30:51 <jle`> NickHu: can you check if the first and last characters are '/' ?
09:31:50 <NickHu> I kinda wanted to do it without two conditionals, just like a regex substitution or something
09:32:17 <jle`> do you think a regex substitution would be more readable than checking the first and last characters?
09:32:38 <EvanR> head s == c || last s == c
09:32:52 <istvan> mnoonan, The most simple scheduler is greedy but I suspect a dynamic programming approach will have a substantial improvement since a doing a single add may "unlock" several multiplies whereas greedy may result in several adds in a row with no multiplies available to schedule
09:33:07 <EvanR> obviously correct code > not obviously incorrect code
09:33:10 <Cale> @let import qualified Text.ParserCombinators.ReadP as P
09:33:12 <lambdabot>  Defined.
09:33:21 <Cale> > P.readP_to_S (do P.char '/'; xs <- many (P.satisfy (/= '/')); P.char '/'; return xs) "/hello/"
09:33:22 <lambdabot>  [("hello","")]
09:33:40 <jle`> that might fail if there's a slash in the middle of the string
09:33:42 <MitchellSalad> doesn't properly escape, 0/10
09:34:19 <NickHu> jle`: Honestly yes
09:34:51 <EvanR> theres something to be said for code that is like 4 characters long vs 4 lines long
09:34:56 <Cale> Well, it's supposed to be delimited by slashes, so it's not supposed to have a slash in the middle
09:35:10 <jle`> NickHu: there's a reason regexp is called a write-only language
09:35:12 <EvanR> after training, you can appreciate the brevity
09:35:27 <EvanR> but a lot of regex is like, 4 lines long though
09:35:28 <MitchellSalad> NickHu: You could use pattern synonyms for this - 'case foo of IsRegex bar -> ...; NotRegex -> ...'
09:35:47 <Cale> MitchellSalad: huh?
09:35:48 <jle`> @let slashFirstLast s = head s == '/' && last s == '/'
09:35:49 <lambdabot>  Defined.
09:35:56 <jle`> > slashFirstLast "/hello/"
09:35:58 <lambdabot>  True
09:36:11 <EvanR> > slashFirstLast ""
09:36:13 <lambdabot>  *Exception: Prelude.head: empty list
09:36:14 <Cale> > slashFirstLast "/"
09:36:15 <EvanR> hehe
09:36:15 <lambdabot>  True
09:36:37 <MitchellSalad> Cale: huh? to your huh? :P
09:37:12 <ollieh[m]> Anyone used the Haskell Tensorflow bindings? It uses Stack, and I've managed to get it to build and run the tests, following the instructions, but I can't figure out how to add it to my existing project that uses Stack. They have an example project that you build with a docker container, but it looks like it has no stack.yml. Any ideas how that might work? The bindings are here: https://github.com/tensorflow/haskell and
09:37:13 <jle`> @undefine
09:37:13 <lambdabot> Undefined.
09:37:13 <ollieh[m]> the example project is https://github.com/tensorflow/haskell/tree/master/tensorflow-mnist
09:37:43 <jle`> @let slashFirstLast s = and [length s > 1, head s == '/', last s == '/']
09:37:45 <lambdabot>  Defined.
09:37:51 <cdornan> the regex package will do what you want, btw
09:38:25 <cemg> hello guys, this is my first haskell app, what do you think ? how can i improve the code quality or any suggestions ? https://github.com/dyrnade/smallDockerImagesTool
09:39:17 <cemg> it uses nix behind the scenes
09:40:30 <Cale> MitchellSalad: I don't understand how that gets us any closer to computing whatever function we're after. I mean... yes, you could, having written an appropriate function for this, define a pattern synonym to make it look pretty.
09:40:46 <MitchellSalad> yea, that's all I was saying :P
09:41:54 <shapr> byorgey: yes! I am reviving TMR! Want to update typeclassopedia?
09:42:31 <stelleg_web> mnoonan: so it seems like you have to add a typespecifier for every pointer type for inline-c? so for every C type T, you need a context entry for T and T*?
09:42:58 <NickHu> How do you guys typically do error handling in MonadIO? I'm looking for a way to just basically catch and ignore errors from https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Simple.html
09:43:32 <MitchellSalad> NickHu: for ignoring errors, I'd use safe-exceptions (so you don't accidentally ignore async exceptions like ThreadKilled)
09:43:56 <jle`> if you're working in generic MonadIO, you can use the functions from lifted-base instead of the typical ones from base
09:44:20 <jle`> lifted-base provided catch/handle/etc. but generalized to work on more than just IO
09:44:29 <stelleg_web> mnoonan: oh, nevermind
09:45:02 <NickHu> I've never done any error handling in Haskell - is there a quick guide somewhere
09:45:23 <jle`> oh, if you can work with specifically IO, it's even easier
09:45:54 <NickHu> can I just wrap my IO in a try and not care about it when it fails?
09:45:55 <MitchellSalad> yeah, your quick guide is jle`
09:45:56 <jle`> the documentation for Control.Exception in base is pretty clear
09:46:03 <jle`> but i liked this chapter http://chimera.labs.oreilly.com/books/1230000000929/ch08.html#sec_exceptions
09:46:13 <jle`> it's a nice summary of how exceptions work
09:47:18 <jle`> and yeah safe-exceptions is a nice way to prevent accidental bad practices from handling errors
09:47:28 <jle`> https://github.com/fpco/safe-exceptions#readme
09:47:29 <Unode> in the hspec package what exactly is the difference between before and before_ (with the underscore).
09:48:17 <qqwy> Greetings, everyone
09:48:27 <MitchellSalad> Unode: 'before' provides its result to the 'SpecWith a', 'before_' just calls the given IO action
09:48:28 <qqwy> I am trying to wrap my head around the ST monad and how to use it
09:48:52 <qqwy> :t runST
09:48:53 <lambdabot> (forall s. ST s a) -> a
09:49:07 <qqwy> I don't really understand this type. What is `s` here?
09:49:17 <jle`> the 's' there is a phantom type
09:49:28 <jle`> it's a type system trick to prevent STRefs from leaking out of runST
09:49:44 <jle`> you can sort of think of it like a hack meh
09:49:50 <Unode> MitchellSalad: so one is lazy and the other isn't? I don't really understand the implications in this scenario.
09:49:52 <MarcelineVQ> ollieh[m]: the default stack.yaml template shows a few ways to get other projects working with yours, in this case I suspect you're wanting subdirs but I'm not sure based only on what you've said there. e.g.: 
09:50:00 <lpaste> MarcelineVQ pasted “ollieh[m]” at http://lpaste.net/5015372047572795392
09:50:22 <jle`> qqwy: basically, most of your ST actions will be of the form `ST s a`, where s is a phantom polymorphic type
09:50:28 <qqwy> Can I understand 'phantom type' as 'an unboud type variable that is not actually manually bound but is a trick for the typechecker'?
09:50:36 <jle`> you should be able to ignore it for the most part
09:50:55 <jle`> yes, you do not have any values of type 's'
09:51:04 <qqwy> Is the `s` just there to ensure that the calls to runST is not memoized?
09:51:06 <qqwy> are*
09:51:18 <MitchellSalad> Unode: hmm, not laziness... before trying to answer, are you familiar with 'SpecWith'?
09:51:22 <jle`> it's to ensure that no STRefs can be "taken out of" ST
09:51:30 <jle`> STRefs are the mutable memory cells you can use in ST
09:52:10 <jle`> `(forall s. ST s a) -> a` effectively says that whatever type variable 's' is isn't allowed to "leave" the `ST s a`
09:52:14 <Unode> MitchellSalad: not really, have been trying to use hspec for a couple of hours but the docs aren't extensive. I'm also still new to haskell.
09:52:14 <MarcelineVQ> cemg: interesting, what all does it do? as in what part of your workflow does it stand in for?
09:52:22 <jle`> the result you get from runST has to not involve the 's' type variable
09:52:49 <MitchellSalad> Unode: no problem, are you trying to write a specific test, or are you just trying to understand the docs before diving in?
09:52:59 <jle`> qqwy: every STRef you create in ST also has this same phantom parameter
09:53:12 <MitchellSalad> :t newSTRef
09:53:14 <lambdabot> a -> ST s (STRef s a)
09:53:43 <qqwy> So can these 'mutable memory cells' then be considered 'variables' in the imperative sense? (as in 'a box' at which at a single time is a value and at another time suddenly something else might be stored?)
09:53:49 <qqwy> Ah
09:53:52 <jle`> yup
09:53:54 <qqwy> And there the `s` magically appears
09:54:02 <Unode> MitchellSalad: I'm trying to write a test that runs an IO operation (split a file into multiple) and I'm trying to use `before` or `around` to do this in a temporary directory. Currently looking at `withsystemTempDirectory`.
09:54:19 <Cale> You can think of the 's' as the type of the heap in which your STRefs all live.
09:54:19 <ollieh[m]> MarcelineVQ: ah thanks, I will try that out
09:54:22 <jle`> yeah, so if you tried to runST (newSTRef 10), that'd be runST :: (forall s. ST s (STRef s Int)) -> STRef s Int, which is not allowed by the type system
09:54:28 <qqwy> How does newSTRef actually fill in the `s` here? Or is the fact that this is not necessary part of the magic that makes it work?
09:54:58 <Zemyla> I kind of wish ST had MVars and forkST.
09:55:00 <jle`> the important thing for the type system is that the 's' it has is the asme as the 's' of the ST it lives in
09:55:03 <Cale> If you want, you can think of runST as actually supplying the s type
09:55:12 <Cale> :t runST
09:55:14 <lambdabot> (forall s. ST s a) -> a
09:55:18 <Zemyla> Doing parallel calculations is referentially pure, yes?
09:55:24 <drostie> Can I just say that the "zippers = derivatives" thing is awesome? I mean it takes a sec to say "`data List x = Nil + Cons x (List x)` is like L(x) = 1 + x L(x), which we can solve implicitly as L(x) = 1/(1 - x) = 1 + x + x^2 + x^3 + ...; its derivative is L'(x) = x L'(x) + L(x) which we recognize as L(x)/(1 - x) = L(x) L(x), so the zipper for [x] is ([x], [x])" ... but it's such a fun argument.
09:55:25 <Cale> You're not allowed to pick s there, runST will pick it for you.
09:55:26 <MarcelineVQ> ollieh[m]: I'm not sure if my example there is functional but when you have a stack.yaml at the top level of a project and cabal files in subdirectories you'll be wanting to use subdirs in some manner so it's a start :>
09:55:29 * MitchellSalad wants to try explaining ST but feels there are too many cooks in the kitchen
09:55:41 <jle`> Zemyla: concurrency is nondeterministic tho
09:55:46 <drostie> er, Nil | Cons x (List x)...
09:55:53 <jle`> drostie: yes you can say it
09:55:55 <jle`> it is awesome
09:56:33 <jle`> qqwy: but yeah, the documentation of STRef shows you how you can use it
09:56:36 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-STRef.html
09:56:40 <MarcelineVQ> ollieh[m]: more info scattered about here https://docs.haskellstack.org/en/stable/yaml_configuration/#project-specific-config
09:56:44 <cemg> MarcelineVQ, it just creates small docker image for you by help of nix. we needed small images at work so this came my mind to give it go and i wanted to learn Haskell
09:57:00 <Unode> MitchellSalad: the docs also mention 'bracket' on at least 2 examples but I don't get where this function is coming from.
09:57:01 <Cale> qqwy: But of course, in the actual implementation, no such type s is actually picked, it just goes ahead and really allocates memory and reads/writes it.
09:57:09 <jle`> STRefs are kind of like pointers to mutable boxes you can change the contents of over the type of your ST algorithm
09:57:10 <Cale> (and forgets about s)
09:57:47 <MarcelineVQ> cemg: pretty cool. I've not used docker but I have seen some nix confix files and they're a little imposing so a tool to do that for you seems like a good idea
09:57:55 <jle`> in practice you can ignore the s, except in situations where you do things that aren't allowed (like return an STRef out of an ST)
09:58:02 <Unode> MitchellSalad: by "the docs" I was referring to hspec: http://hspec.github.io/writing-specs.html#using-hooks (the withStubbedApi)
09:58:24 <ReinH> drostie: it's nice, isn't it
09:58:25 <qqwy> Ah, I see. The `s` is just there to ensure we don't shoot ourselves in the foot
09:58:32 <qqwy> Nice :-)
09:58:40 <MitchellSalad> Unode: ah, if you have a "resource" like a temp file, you'd want to use the 'around' family of functions
09:58:46 <ReinH> drostie: I have that feeling about all of Conor's work.
09:58:47 <cemg> MarcelineVQ, thank you
09:58:48 <jle`> i use this trick in a lot of my libraries now
09:58:52 <qqwy> I don't really understand why it works, but it's amazing
09:58:56 <cemg> I am glad to hear that
09:59:05 <ReinH> jle`: the ST trick?
09:59:07 <Cale> qqwy: Yeah, in particular, it guarantees that you'll never use an STRef from one instance of runST that was created by another.
09:59:07 <jle`> yeah, you don't have to understand exactly how it works to just use ST day to day
09:59:13 <jle`> ReinH: the phantom s trick
09:59:14 <MitchellSalad> Unode: for example, 'around (withSystemTempDirectory "blah")' would have type 'SpecWith FilePath -> Spec'
09:59:21 <ReinH> jle`: yeah, what do you find yourself using it for?
09:59:24 <Cale> qqwy: Because you'll have no way to show that s is the same type in each case.
09:59:39 <MitchellSalad> Unode: so, you'd simply pass a spec that is parameterized by 'FilePath' (for example, a function from FilePath)
09:59:56 <ReinH> Cale: btw I've been learning Agda and Idris. It's a trip.
10:00:06 <Cale> qqwy: It actually *is* possible to smuggle STRefs out in the result of a runST, but it's not possible to actually use them.
10:00:08 <MitchellSalad> jle`: care to share any libraries that you've used this trick in?
10:00:16 <Cale> ReinH: nice!
10:00:32 <qqwy> Ah, *now* it clicks! Because newSTRef and friends are only ever called in the context of runST, the `s` is filled in by the type checker (without ever regarding what is actually in there).
10:00:40 <qqwy> That was what I was missing :D
10:00:44 <jle`> ReinH, MitchellSalad: it's useful for libraries that have monads you can "allocate variables" of some type in
10:00:56 <ReinH> Cale: I get sad when my computer isn't smart enough to prove that n + S m = S (n + m) but other than that it's been fun.
10:01:10 <Cale> ReinH: Well, it requires induction
10:01:11 <jle`> like in my 'uncertain' library, there's a monad where you can sample random variables and perform operations on them, and it keeps track of correlations and covariances between different sampled points
10:01:21 <jle`> these variables are implemented internally as just keys to a Map state
10:01:21 <ReinH> Cale: yes, I want my computer to do that for me.
10:01:26 * qqwy 's mind ≡ blown
10:01:33 <ollieh[m]> MarcelineVQ: I think I got it working, I added a package like '../tensorflow-haskell/tensorflow' below the '.' and it seems to be building :)
10:01:36 <jle`> like type RandomVar = Int
10:01:47 <ReinH> right
10:01:52 <jle`> so i don't ever want a user to "run" the monad and get an actual *variable*/reference out of it
10:02:00 <jle`> since the reference itself is meaningless
10:02:15 <MarcelineVQ> neat, you'll want extra-dep: true with that or stack could be quite confused
10:02:17 <jle`> it's just an Int.  and they might use it in another invocation of Run
10:02:32 <ollieh[m]> Ok ill put that in
10:02:50 <jle`> also in my 'backprop' library, users have a monad where they can bind variables and functions on thos variables and the library performs backpropagation on the result to find the gradient
10:02:53 <MarcelineVQ> it doesn't always happen but 9/10 times an issue with building involving custom pacakges is the lack of extra-dep :>
10:03:07 <MarcelineVQ> imo it should be default
10:03:11 <Unode> MitchellSalad: I'm not sure I understand... can you provide that same example with around and around_ ? Perhaps if you know of some code that uses this pattern I can just understand that.
10:03:12 <jle`> and so again it doesn't make any sense for the variables/references themselves to leak out of the backprop monad
10:03:25 <ReinH> jle`: ooh, btw +/- is a nice constructor name
10:03:43 <MitchellSalad> Unode: yeah, one second, making coffee
10:03:44 <jle`> thank you, it's pretty cheeky admittedly :)
10:03:50 <Unode> MitchellSalad: thanks :D
10:04:04 <ReinH> jle`: I've been reading a lot of agda, it is not nearly cheeky enough.
10:04:21 <ReinH> jle`: oh this is a nice use of ad
10:04:45 <drostie> @ReinH: ahaha I googled Conor McBride to see what else he has written besides the zippers = derivatives paper.
10:04:45 <lambdabot> Unknown command, try @list
10:04:55 <drostie> oh, whoops.
10:04:59 <drostie> Forgot this is IRC.
10:05:02 <ReinH> heh
10:05:09 <ReinH> drostie: lots of very good stuff
10:05:21 <ReinH> His new ornaments stuff is nice too
10:05:25 <drostie> right, interspersed with articles about forgiving murderers. XD
10:05:31 <ReinH> wait what
10:05:37 <ollieh[m]> How do you think I might be able to google for other public projects that depend on tensorflow? I doubt I'm the first person to use it but I haven't found any
10:05:55 <jle`> ReinH: i was surprised at how simple the Corr monad was with AD
10:06:04 <ReinH> ollieh[m]: iirc there's a reverse dependency lookup somewhere
10:06:04 <jle`> it wasn't exactly pre-planned but i'll take it :)
10:06:35 <ReinH> jle`: Ed's practice of choosing the most general possible solution to everything pays off in interesting ways sometimes
10:06:46 <drostie> apparently he shares a name with a guy in the US who shot his girlfriend. (I said "murderer" but apparently she survived?)
10:06:53 <ReinH> oh, ok
10:06:59 <ReinH> I was about to say
10:07:03 <EvanR> is this like a reiserfs
10:07:10 <ReinH> haha noooo
10:08:03 <MarcelineVQ> ollieh[m]: that's a good question, if the project is on hackage (though I think it's not) you can do as ReinH is suggesting at http://packdeps.haskellers.com/reverse , possibly github has a way as well
10:08:26 <MarcelineVQ> 'the project' being tensorflow in this case
10:09:28 <qqwy> ReinH: That sounds wonderful
10:09:46 <ReinH> qqwy: which?
10:09:48 <qqwy> Too often do I see people who do not realize how they could make a slightly more general version of their algorithm, which would save them work in the long run
10:09:52 <ReinH> oh yeah
10:10:04 <ReinH> Ed's the kind of guy who implements a linear algebra library using Naperian Functors
10:10:34 <qqwy> wow
10:10:56 <drostie> oh it's one of those really strange cases. She survived the shooting on life support but after 4 days with no improvement her parents took her off life support, then he was convicted of murdering her. wtf. anyway.
10:10:57 * qqwy in some distant future, wants to become that kind of guy too
10:11:02 <ReinH> @hackage linear
10:11:02 <lambdabot> http://hackage.haskell.org/package/linear
10:11:03 <MarcelineVQ> ollieh[m]: https://github.com/search?q="tensorflow-haskell"&type=Code is possibly a start
10:11:04 <ReinH> is based on http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/aplicative.pdf
10:11:55 <qqwy> Unfortunately have to go
10:11:58 <qqwy> talk to you later this evening
10:12:00 <qqwy> Thank you!
10:12:05 <ReinH> o/
10:12:53 <EvanR> forwarded the paper to new orleans haskell group
10:13:15 <EvanR> (which contains at least one person obsessed with APL)
10:14:13 <ReinH> EvanR: :)
10:14:24 <ollieh[m]> aha I found a couple like this: https://github.com/search?l=Haskell&q=tensorflow
10:15:29 <ReinH> ollieh[m]: it's unfortunate that package dependency is out of band to github, otherwise they'd have a huge amount of info about language ecosystems
10:16:00 <ReinH> I sometimes wonder if package management could be implemented via git submodules and how terrible that would be
10:16:21 <ReinH> that's basically how ad hoc package management in agda works, I guess
10:17:16 <ollieh[m]> I mean, they've got all the data, they could pick a few languages and write something that could work it out for them
10:17:23 <ollieh[m]> that would be pretty neat
10:18:20 <ReinH> yeah
10:18:31 <ReinH> node might be the best choice tbh
10:18:51 <Cale> ReinH: git submodules :(
10:20:13 <ReinH> Cale: yes, I know.
10:20:27 <ReinH> I think it would be possible to implement a coherent system on top of them
10:20:43 <Cale> Actually my main problem with them is simply that the UI around them is annoying for no good reason
10:20:47 <ReinH> like we implement a coherent functional programming system on top of CPUs and memory.
10:20:56 <ReinH> yes, this is git in a nutshell
10:21:16 <Cale> e.g. to start with, why the heck aren't they automatically initialised and updated by default?
10:21:20 <ReinH> the underlying module is good but they've done an excellent job obscuring this through a terrible UI
10:21:25 <ReinH> s/module/model
10:21:45 <Cale> s/good/kinda okay/
10:21:58 <ReinH> Yeah, also removing them, moving them, updating them, etc, is unnecessarily complicated
10:22:11 <ReinH> Cale: Oh that's right you like darcs don't you
10:22:14 <fosterite> ollieh[m]: I think snoyman has a reverse dependency website for stackage somewhere
10:22:20 <Cale> yeah
10:22:25 <ReinH> fair enough
10:23:06 <cocreature> http://packdeps.haskellers.com/ has reverse deps for all of hackage iirc
10:23:11 <Cale> I mean, I never actually loved anything as far as version control goes, but going from darcs to git felt like a huge step backwards.
10:23:36 <cocreature> and I think that feature is also implemented in hackage itself by now. but it’s not yet deployed
10:28:47 <ReinH> Cale: I wrote a vector zipper, it's like an exercise in learning how to add all over again.
10:30:16 <Cale> ReinH: haha
10:30:27 <EvanR> vector zipper... ?
10:30:45 <ReinH> a list zipper but for length-indexed lists, a.k.a. vectors
10:30:52 <ReinH> it's a bad name but it's the one we have
10:30:54 <EvanR> oh Vect
10:30:58 <ReinH> yeah, Vect
10:31:00 <cocreature> oh I thought a zipper of Vector
10:31:00 <MitchellSalad> Unode: still there?
10:31:04 <Unode> yup
10:31:13 <ReinH> Vect is short for vector ;)
10:31:38 <EvanR> roger roger whats your vector victor
10:31:52 <fosterite> Cale: have you heard of pijul? like darcs but faster
10:34:15 <MitchellSalad> okay, let's see... you are trying to use "withSystemTempFile" in a test"
10:34:17 <MitchellSalad> ?
10:35:02 <LordBrain> one thing with that is watch out for systemd
10:35:17 <LordBrain> depending on its configurations... it makes your temporary files invisible inside of /tmp
10:35:18 <Unode> MitchellSalad: Ĩ'll probably wrap that on another function that does a few more things but the general idea is create a directory, put some files there, run the test, check the result and get rid of the folder (on success or failure)
10:35:44 <LordBrain> its a "feature"
10:40:59 <MitchellSalad> Unode: here, does this help? http://lpaste.net/355158
10:41:37 <MitchellSalad> i had to re-jigger withSystemTempFile to make it work with 'around', and then put annoying explicit type signatures on things because some parts of hspec use type families that interact badly with inference
10:41:48 <MitchellSalad> but for a real test, the compiler could figure out more of the types
10:43:16 <Unode> MitchellSalad: could you also create another paste using around_ ? This is a great help.
10:44:33 <Unode> the inside of the 'it' is quite confusing indeed. But I think I get the general idea.
10:45:47 <hiccup> trying to set up sublime-haskell.  have to install hsdev.  trying to use stack global context.  had to add haddock/hdocs to extra-deps.  but still have dependency problems for hformat, simple-log, and text-region.  do i have to download hsdev src and manually modify their .cabal?
10:49:02 <Guest50004> can anyone help me with my stack problem above?  http://lpaste.net/4235251105803534336
10:50:46 <Unode> Guest50004: seems like a resolver problem. Unless I'm reading it wrong. The applicable versions actually match.
10:52:13 <Guest50004> Unode: my read is that those matching versions are what it's looking up in hackage, but (i don't understand stack yet) afaict, stack's "approved" versions are way behind (the versions it's saying "must match")
10:54:32 <Unode> Guest50004: you might want to open an issue on stack @ github. Doesn't seem to be a problem on your end.
10:54:42 <ReinH> Unode: the actual versions being used are part of the package name, e.g., hformat-0.1.0.1 means stack is using version 0.1.0.1
10:54:50 <ReinH> It does seem to be a problem.
10:55:20 <Unode> ReinH: so where does the "must match" version come from_
10:55:21 <Unode> ?
10:55:22 <Myrl-saki> @pl \f -> (f =<<) .
10:55:22 <lambdabot> (line 1, column 16):
10:55:22 <lambdabot> unexpected end of input
10:55:22 <lambdabot> expecting white space or simple term
10:55:27 <ReinH> The version in stackage is 0.1.0.1 (see https://www.stackage.org/lts-8.13/package/hformat-0.1.0.1)
10:55:36 <Myrl-saki> @pl (\f -> ((f =<<) .))
10:55:36 <lambdabot> (.) . (=<<)
10:55:49 <Unode> ReinH: I see
10:55:50 <geekosaur> Unode, Guest50004: the resolver
10:55:53 <ReinH> but the solver has determined that it must matchh ==0.2.*, which it does not
10:56:09 <ReinH> I think you can just include a matching version as an extra-dep
10:56:38 <ReinH> you might also try the nightly, which has bumped it up to 3.0, but updating every package might cause more problems that it solves
10:56:45 <ReinH> *than
10:57:23 <Unode> ReinH: I think Guest50004 is right in that the hsdev.cabal lists == 0.2.*.
10:57:28 <ReinH> :t (.) . (=<<)
10:57:30 <lambdabot> Monad m => (a1 -> m b) -> (a -> m a1) -> a -> m b
10:57:42 <ReinH> Unode: yes, that is why it must match that
10:57:47 <Myrl-saki> @pl (\f g x -> f =<< g x)
10:57:47 <lambdabot> (.) . (=<<)
10:57:50 <ReinH> but it does not match that, because it is only 0.1.0.1
10:58:00 <Myrl-saki> Eh
10:58:23 <ReinH> :t (>=>)
10:58:26 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:58:29 <Myrl-saki> `f =<< g x` == `(f <=< g) x`, right?
10:58:38 <ReinH> one or the other
10:58:40 <Myrl-saki> Just to make sure I'm not going cray. Lol.
10:59:25 <ReinH> Unode: I'm saying the issue stack is reporting is real, not a bug in stack
10:59:26 <Guest50004> ReinH: thanks i'll try :)  it suggested that for libraries stack doesn't list...  aren't there dangers in asking it to use higher than approved versions?
10:59:30 <Myrl-saki> Is there a `:: (a -> Bool) -> a -> Maybe a`?
10:59:39 <Unode> ReinH: so this particular lts-8.9 has an invalid hsdev version? (lts-8.8 seems to suffer the same)
10:59:46 <Myrl-saki> (or `:: (a -> Bool) -> Maybe a -> Maybe a`)
10:59:49 <Myrl-saki> :t filter
10:59:51 <lambdabot> (a -> Bool) -> [a] -> [a]
10:59:53 <ReinH> Guest50004: yes, there are always dangers in upgrading packages. But the danger in not upgrading is that it doesn't work.
10:59:57 <lyxia> :t mfilter
10:59:59 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
11:00:04 <Myrl-saki> lyxia: Thanks.
11:00:26 <ReinH> Guest50004: anyway, hdev is claiming to work with that version, and to not work with 0.1.*
11:00:36 <ReinH> er, hsdev
11:01:27 <Unode> ReinH: right I think I get it. Things were bundled on an lts that aren't actually compatible. So I guess it still needs to be reported.
11:01:33 <ReinH> > mfilter even . pure $ 1
11:01:35 <lambdabot>  error:
11:01:35 <lambdabot>      • Ambiguous type variables ‘m0’, ‘a0’ arising from a use of ‘show_M53873...
11:01:35 <lambdabot>        prevents the constraint ‘(Show (m0 a0))’ from being solved.
11:02:18 <ReinH> > mfilter even . pure $ 1 :: Maybe Int
11:02:20 <lambdabot>  Nothing
11:02:28 <Unode> (I thought the purpose of lts-** was to avoid these kinds of package version incompatibilities)
11:02:44 <ReinH> Unode: *that* would be a stackage bug, yes
11:02:58 <ReinH> but hsdev is not in stackage
11:03:05 <ReinH> so it is not guaranteed to work
11:03:51 <ReinH> they have automated testing for that too iinm
11:03:51 <Unode> oh..
11:04:09 <Myrl-saki> :t fold
11:04:11 <lambdabot> (Monoid m, Foldable t) => t m -> m
11:05:16 <Guest50004> ReinH: seems to be working, thanks!  is there a better way to do this than stack's global context?  seems wrong that i have a bunch of global extra-deps for a specific need...
11:05:36 <ReinH> Guest50004: in the stack config for the project itself
11:05:54 <MitchellSalad> Unode: oops, just saw this... one moment
11:06:04 <Guest50004> ReinH: but this is for installing sublime-haskell globally -- should i do that for each project?
11:06:13 <Myrl-saki> :t foldM
11:06:15 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
11:06:23 <Unode> MitchellSalad: no worries, and thanks again.
11:06:51 <Unode> Guest50004: maybe create a project that is used by your sublime setup_
11:07:05 <Unode> if you want to avoid going global with that.
11:07:19 <ReinH> Guest50004: well, you can create a root stack config that has the rest as subdirectories
11:07:26 <Unode> I'm not a sublime user though so I don't know if that is possible.
11:07:33 <ReinH> so foo/stack.yml and foo/bar/stack.yml and foo/baz/stack.yml
11:07:39 <ReinH> and foo/stack.yml builds them all
11:08:24 <ReinH> er, stack.yaml
11:08:43 <ReinH> Guest50004: the other option would just be to build it using cabal
11:09:11 <MitchellSalad> Unode: I updated the paste and put an example using 'around_' at the bottom http://lpaste.net/355158
11:09:55 <Myrl-saki> @pl (\a m -> a >>= (\a -> fmap (++ a) m))
11:09:56 <lambdabot> liftM2 (flip (++))
11:10:01 <Myrl-saki> Oh cool.
11:10:12 <Unode> MitchellSalad: thanks a lot!
11:11:07 <Unode> MitchellSalad: hold on, the last test uses both around and around_ is that correct?
11:11:13 <Guest50004> ReinH: hrm ok i'll think about it.  tried cabal but i have no global ghc :)  is there a way to use stack's?  i've been operating under the oversimplication that "stack is the new cabal," 
11:11:21 <Myrl-saki> @pl foldr (liftM2 (++)) (Just [])
11:11:21 <lambdabot> foldr (liftM2 (++)) (Just [])
11:11:25 <Myrl-saki> :(
11:11:31 <ReinH> heh, well, I'd probably go for the parent stack.yaml then
11:11:41 <ReinH> Myrl-saki: whatcha doin?
11:11:50 <ReinH> That expression doesn't have any points in it
11:11:56 <Guest50004> ReinH: i was worried a global ghc would mess up stack...
11:12:07 <MitchellSalad> Unode: yep, you can combine them
11:12:08 <ReinH> Guest50004: you can tell stack to ignore it, iinm
11:12:24 <Myrl-saki> ReinH: ProjectEuler, one-liner.
11:12:32 <ReinH> I'm not saying that's the best plan, but presumably the author has checked that they build with cabal
11:12:39 <ReinH> Myrl-saki: which problem?
11:12:44 <Unode> MitchellSalad: ok then I still don't quite get what around_ does differently.
11:12:48 <Myrl-saki> https://projecteuler.net/problem=47
11:12:50 <glguy> Guest50004: It's fine to have GHC installed separately, stack doesn't mind
11:13:30 <ReinH> Myrl-saki: and what subproblem are you working on?
11:13:49 <MitchellSalad> Unode: It doesn't provide any argument to the inner spec (like a temp file), it just lets you run anything you want before and/or after each test
11:14:32 <Unode> oh.. so around accepts arguments from the test while around_ simply calls the function?
11:14:44 <Myrl-saki> ReinH: Right now, I'm trying to check distinctness using `groupBy` and `sort`.
11:14:54 <Myrl-saki> :t groupBy `on` fst
11:14:55 <lambdabot> error:
11:14:55 <lambdabot>     • Couldn't match type ‘[a]’ with ‘a -> a -> Bool’
11:14:55 <lambdabot>       Expected type: [a] -> [a] -> [[a]]
11:15:08 <Unode> MitchellSalad: let me play some more with these examples to see if I get it.
11:15:10 <Myrl-saki> I really forgot how lol
11:15:33 <Myrl-saki> :t groupBy ((==) `on` fst)
11:15:35 <lambdabot> Eq a => [(a, b)] -> [[(a, b)]]
11:15:39 <Myrl-saki> Ah.
11:19:48 <ADG> how to get stack working, man I am trying since hours and stack setup gets stuck on Updating package index or I get HTTPexception
11:20:49 <geekosaur> are you behind a proxy?
11:21:27 <glguy> The initial download is something like 240M, are you on a slower connection?
11:21:50 <ADG> is it true 240M ?
11:22:01 <ADG> can I atleast get a progress bar?
11:24:09 <byorgey> shapr: I already have been updating Typeclassopedia, it is on the wiki now =)
11:24:27 <ADG> probably I'll leave it overnight
11:24:40 <Myrl-saki> fold $ extend (First . mfilter (all ((== 1) . length) . groupBy ((==) `on` fst) . sort) . foldr (liftM2 (++)) (Just []) . fmap (mfilter ((== 4) . length) . Just . factorise) . NE.take 4) $ 1000 NE.:| [1001..9999]
11:24:42 <Myrl-saki> And it solves nothing.
11:24:51 <Myrl-saki> That's what I get for trying to be smart. lol
11:24:54 <byorgey> shapr: I'm not particularly interested in putting an updated version in TMR.  But perhaps I could be convinced to contribute something else.
11:26:55 <srhb> Athas: Not sure if you do Quora, but heads up: https://www.quora.com/unanswered/How-does-Futhark-compare-to-Accelerate
11:29:45 <Athas> srhb: nifty, thanks.
11:32:18 <Myrl-saki> @pl (\x -> x <$ f x)
11:32:19 <lambdabot> ap (<$) f
11:33:54 <Myrl-saki> @pl (\x -> x <$ (f . g $ x))
11:33:54 <lambdabot> ap (<$) (f . g)
11:35:07 <geekosaur> the pointfree plugin still doesn't know about Applicatives, sadly
11:35:42 <Sornaensis> @free (>>=)
11:35:42 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
11:39:13 <Myrl-saki> solve = fromJust . getFirst . fold . extend (fmap (product . map fst . take 4) . First . foldr (liftM2 (++)) (Just []) . fmap (mfilter ((== 4) . length) . Just . factorise) . NE.take 4)
11:39:23 <Myrl-saki> (PE 47)
11:39:41 <Myrl-saki> I feel so disgusted writing that. :D
11:39:50 <Myrl-saki> @pl fromJust . getFirst . fold . extend (fmap (product . map fst . take 4) . First . foldr (liftM2 (++)) (Just []) . fmap (mfilter ((== 4) . length) . Just . factorise) . NE.take 4)
11:39:50 <lambdabot> fromJust . getFirst . fold . extend (fmap (product . map fst . take 4) . First . foldr (liftM2 (++)) (Just []) . fmap (mfilter ((4 ==) . length) . Just . factorise) . NE.take 4)
11:40:24 * geekosaur sees no points to remove from that
11:40:24 <mbw> How can I query lambdabot for a free theorem, preferrably in a private session?
11:40:39 <jle`> you can use @free in a private session
11:40:46 <jle`> using /q @free
11:40:54 <geekosaur> er
11:40:56 <jle`> er
11:41:04 <jle`>  /q lambdabot [stuff]
11:41:05 <Myrl-saki> I'm... pretty sure I could have used `filter` there.
11:41:05 <geekosaur> /q lambdabot @free
11:41:55 <geekosaur> and I think for operator identifiers you have to cheat and say something like @free bind :: Monad m => m a -> (a -> m b) -> m b
11:42:28 <mbw> Can it give you more than one theorem? I need the good stuff for zipWith.
11:42:40 <Myrl-saki> Oh no. That was actually pretty correct. Lol.
11:44:55 <Myrl-saki> (For some definitions of correct.)
11:45:54 <dolio> It only gives you one theorem per type.
11:46:47 <Cale> Specifically, it gives you *the* free theorem for that type
11:48:00 <mbw> So there's only one per type (or rather, any other would follow from it)?
11:48:35 <fosterite> yes, the free theorem is usually rather general
11:50:42 <mbw> Ok thanks.
11:51:08 <Cale> There are other theorems you might want to prove regarding any given function
11:51:10 <Cale> but they're not free
11:53:00 <mbw> I don't think this will be of any practical use to me anytime soon. I don't have the theoretical background to grok the paper, and I don't even understand the output.
11:53:19 <Cale> What did you want to know?
11:54:19 <dolio> Cale: There are other theorems that could be free, I think. It makes some arbitrary decisions.
11:54:41 <Cale> Oh, interesting
11:54:42 <dolio> Like assuming every capital letter is a covariant functor.
11:56:19 <dolio> Like, there is the more general parametricity theorem in terms of relations that is 'free'.
11:56:38 <dolio> And is not always implied by the more specialized on that @free gives you.
11:57:23 <mbw> I was wondering if there are useful laws that can be stated for zipWith, zipWith3 etc. There should of course be the ones that follow from the Applicative instance from ZipList. What I'd like to know in the long run is if it can be applied in the context of multidimensional arrays, where you zipWith array slices.
11:57:54 <jle`> ah yes those aren't free theorems
11:58:12 <jle`> mbw: free theorems would be just the theorems that follow directly from the *types* of zipWith, zipWith3, etc.
11:58:18 <jle`> they don't consider the actual implementation
11:58:58 <jle`> :t zipWith
11:58:59 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:59:07 <jle`> @free (a -> b -> c) -> [a] -> [b] -> [c]
11:59:08 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
11:59:16 <mbw> I'm just looking for some useful laws, be they free or not.
11:59:16 <jle`> @free zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:59:16 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
11:59:35 <jle`> yeah, those aren't free theorems...they're just theorems :)
12:00:14 <mbw> It was a last resort to come up with something. I'll have to write quickCheck properties or work things out on paper.
12:00:26 <shapr> hedgehog properties?
12:02:11 <mbw> Well I thought fast & loose reasoning was morally correct...
12:02:37 <geekosaur> only with respect to nontermination
12:06:01 <NickHu> Is there a better/more concise way to write http://lpaste.net/3914041342233149440 ?
12:08:22 <jle`> NickHu: it's weird seeing guard in IO
12:08:29 <jle`> wouldn't you rather just throw an error?
12:09:08 <jle`> also, why isJust + fromJust?  why not just pattern match?
12:09:20 <jle`> is there any reason you're returning everything in MaybeT?
12:09:33 <jle`> you just add it on at the end so it's really no different than returning IO (Maybe FacebookReacts)
12:09:58 <cocreature> it looks like NickHu might expect guard to return Nothing
12:10:05 <cocreature> then MaybeT makes a bit more sense
12:10:26 <jle`> yes that is a suspicion i had as well;  just hoping these questions would figure that out
12:10:33 <NickHu> Yeah, I saw it here https://en.wikibooks.org/wiki/Haskell/Monad_transformers
12:10:51 <jle`> are you trying to use MaybeT to do short-circuting IO ?
12:11:03 <NickHu> I'm under the impression that if the guard sees a Nothing the whole function gives up and returns Nothing
12:11:14 <NickHu> Which is exactly what I want to happen
12:11:15 <jle`> that's the case for Maybe
12:11:19 <jle`> but you aren't in Maybe, there
12:11:21 <NickHu> Yes, I am
12:11:22 <jle`> you're in IO
12:11:24 <jle`> it's also the case for MaybeT
12:11:28 <jle`> but you're in IO there
12:11:47 <jle`> ...does this typecheck at the moment?
12:12:03 <NickHu> Yeah, it compiles
12:12:18 <james111> Please could someone help me reverse a list then take the first element out then pass other items back for recursion
12:12:24 <Myrl-saki> > MaybeT _
12:12:26 <lambdabot>  error:
12:12:27 <lambdabot>      • Data constructor not in scope: MaybeT :: t0 -> t
12:12:27 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)error:
12:12:34 <Myrl-saki> Okay..
12:12:37 <jle`> this surprises me
12:12:38 <cocreature> leaving that aside, line 7-18 seem a bit weird. why are you applying a lambda to pid instead of just using pid directly?
12:12:42 <Myrl-saki> NickHu: Look at the definition of MaybeT.
12:12:51 <cocreature> jle`: what do you expect to cause problems?
12:12:51 <jle`> M.lookup returns Maybe
12:12:56 <SolitaryCypher> reverse . drop 1?
12:12:56 <jle`> it doesn't return IO
12:12:57 <cocreature> oh right
12:12:58 <Myrl-saki> jle`: lmao. Me too.
12:13:08 <SolitaryCypher> james111: reverse . drop 1?
12:13:19 <jle`> i'd expect line 4 to be a type error
12:13:33 <jle`> what is the type of getResponseBody ?
12:13:49 <Myrl-saki> NickHu: Are you sure you saved?
12:13:51 <Tuplanolla> If you find yourself reversing a list, your design most likely went wrong at some earlier point, james111.
12:13:52 <NickHu> cocreature: You're right, I missed that while refactoring
12:14:25 <jle`> NickHu: what your'e doing in this current file is defining an IO (without the help of MaybeT) and then wrapping it all in MaybeT at the end
12:14:31 <jle`> so you don't ever actually work with any MaybeT actions
12:15:19 <NickHu> Response a -> a
12:15:32 <jle`> what about parseRequest?
12:15:33 <cocreature> to make this very explicit "MaybeT x >> MaybeT y" is not the same as "MaybeT (x >> y)"
12:15:38 <cocreature> and you’re doing the latter
12:15:39 <NickHu> Myrl-saki: What do you mean?
12:15:43 <cocreature> while it seems you expect the former
12:15:59 <Myrl-saki> runMaybeT . maybeT $ x == x
12:16:01 <jle`> NickHu: the file you gave us shouldn't compile
12:16:09 <Myrl-saki> Err. MaybeT*
12:16:22 <jle`> since M.lookup returns Maybe, and it's being <-'d in an IO do block
12:16:35 <james111> SolitaryCypher: I am new to chaining functions together. I used reverse . drop 1 xs and I get error of drop applied to too few arguments
12:16:55 <Myrl-saki> (And even then, you need to use `lift`)
12:17:02 <james111> Tuplanolla: its just for a beginner project. I will keep that in mind for the future thank you
12:17:29 <Myrl-saki> Er wait. No.
12:18:50 <lpaste> jle` annotated “No title” with “No title (annotation)” at http://lpaste.net/3914041342233149440#a3474836882737594368
12:19:18 <jle`> NickHu: i gave two potential rewrites; one using MaybeT to show how MaybeT is supposed to work, and one without it to show that it doesn't relaly make sense to use MaybeT here
12:19:38 <jle`> MaybeT is really only useful when you do multiple chained short-circuiting stuff
12:19:39 <Myrl-saki> `pid <- MaybeT.return $ M.lookup path m`
12:19:42 <Myrl-saki> let pid = ?
12:19:44 <ExpHP> How can I scrub a cabal file for unnecessary dependencies?  Cabal-1.24 is too bleeding edge for 'packunused'
12:20:08 <jle`> Myrl-saki: M.lookup returns Maybe, so <- lets you take advantage of short-circuiting MaybeT
12:20:30 <jle`> in an ideal usage of MaybeT, there would be multiple such binds
12:20:42 <Myrl-saki> That's not my point.
12:20:49 <Myrl-saki> Wait for a while.
12:20:56 <cocreature> ExpHP: I haven’t tried it myself so take it with a grain of salt but I recently stumbled upon neil’s https://github.com/ndmitchell/weeder#readme
12:21:06 <cocreature> which seems like it’s supposed to do that
12:22:19 <Myrl-saki> Prelude Control.Monad.Trans.Maybe> runMaybeT $ return Nothing >> return 1
12:22:21 <Myrl-saki> Just 1
12:22:23 <Myrl-saki> jle`: 
12:23:20 <jle`> not sure what you're trying to show? sorry :|
12:23:27 <Myrl-saki> jle`: The `return` is wrong.
12:23:32 <Myrl-saki> jle`: I think you meant to use `lift`
12:23:40 <jle`> what you wrote isn't the same as what i wrote
12:23:43 <jle`> lift would be for IO actions
12:23:48 <jle`> @let import Control.Monad.Trans.Maybe
12:23:50 <lambdabot>  Defined.
12:23:55 <Myrl-saki> Prelude Control.Monad.Trans.Maybe Control.Monad.Trans.Class> runMaybeT $ lift Nothing >> return 1
12:23:57 <jle`> > runMaybeT (MaybeT.return) Nothing >> return 1
12:23:58 <Myrl-saki> Nothing
12:23:59 <lambdabot>  error:
12:23:59 <lambdabot>      Not in scope: ‘MaybeT.return’
12:23:59 <lambdabot>      No module named ‘MaybeT’ is imported.
12:24:22 <jle`> > runMaybeT $ (MaybeT . return) Nothing >> return 1
12:24:24 <lambdabot>  error:
12:24:25 <lambdabot>      • Ambiguous type variables ‘m0’, ‘a0’ arising from a use of ‘show_M19759...
12:24:25 <lambdabot>        prevents the constraint ‘(Show (m0 (Maybe a0)))’ from being solved.
12:24:25 * NickHu sent a long message: NickHu_2017-05-03_19:24:03.txt - https://matrix.org/_matrix/media/v1/download/matrix.org/ETkznocSbhOPMVgwBHpDsRKl
12:24:39 <NickHu> whoops, didn't mean to paste that
12:25:01 <jle`> > runMaybeT $ (MaybeT . return) Nothing >> return 1 :: Identity (Maybe Int)
12:25:03 <lambdabot>  Identity Nothing
12:25:31 * NickHu sent a long message: NickHu_2017-05-03_19:25:06.txt - https://matrix.org/_matrix/media/v1/download/matrix.org/cHKtpyZqQemvGQHjqTFZjuXE
12:25:33 <ExpHP> cocreature: yep, it's perfect!
12:25:35 <Myrl-saki> You wrote `MaybeT.return`, that's what I was confused about. Sorry.
12:25:35 <jle`> lift :: IO a -> MaybeT IO a
12:25:47 <jle`> ah yeah, i meant `MaybeT . return`
12:26:12 <jle`> NickHu: what code gave this error?
12:26:37 <NickHu> jle`: Yeah, I did that
12:26:49 <ExpHP> hm, surprisingly I only have 2 dependencies out of ~50 that are unused, despite lots of frequent turnover in my codebase
12:26:56 <jle`> what code gave the error you just sent?
12:27:01 <ExpHP> I bet 75% of them are only used once
12:27:02 <NickHu> ahh, looks like it didn't need return/pure
12:27:18 <lpaste> jle` revised “No title (annotation)”: “No title (annotation)” at http://lpaste.net/3474836882737594368
12:27:56 <tsahyt> is psqueues still the fastest priority queue implementation?
12:28:27 <jle`> NickHu: anyways, yeah, MaybeT is not really very useful here because you don't do multiple short-circuiting IO Maybe chains
12:28:36 <NickHu> That did, jle`, but if you take out the . pure it's fine
12:28:36 <NickHu> (On line 4)
12:29:07 <jle`> if you only have one IO Maybe, easiest thing is to just use forM
12:29:08 <NickHu> How do you mean?
12:29:15 <jle`> what am i looking at?  what line 4?
12:29:55 <NickHu> http://lpaste.net/3474836882737594368 line 4
12:29:56 <jle`> MaybeT is only worthwhile if you sequence multiple chained short-circuiting operations
12:30:28 <jle`> otherwise you might as well just use forM like what I wrote
12:31:34 <jle`> huh that's weird.  what's the type of M.lookup ?
12:31:44 <jle`> is it not the standard M.lookup from containers?
12:31:54 <ReinH> You can always wrap a particular IO (Maybe a) with MaybeT at use sites.
12:32:16 <ReinH> Which is nicer than unwrapping MaybeT IO a imo
12:32:37 <jle`> yeah, it makes more sense to just return IO (Maybe a); MaybeT is a convenient newtype wrapper for chaining several short-circuiting IO (Maybe a)'s in a do block and other similar things
12:33:06 <jle`> also i see that M.lookup returns IO for some reason, which is why the original thing compiled
12:33:19 <ReinH> It mostly depends on context. If you mostly "live" in MaybeT IO, do that, and vice versa.
12:33:36 * geekosaur wonders if this is the ghc 6.6 lookup >.>
12:33:37 <NickHu> jle`: It's from Control.Concurrent.Map, sorry, should've said
12:34:08 <ReinH> One other advantage of IO (Maybw a) is that you can export it and users won't incur a transformers dependency to use it.
12:35:09 <lpaste> jle` annotated “No title” with “No title (annotation) (annotation)” at http://lpaste.net/3914041342233149440#a7956381835863261184
12:35:20 <jle`> NickHu: if that's the case, then the second annotation is how i would probably write it
12:37:38 <ReinH> I would extract the parseRequest to be a function that expects a pid.
12:38:06 <ReinH> Some useful way to use it should present itself.
12:58:43 <nitrix> Is it possible to disable the GC entirely or reduce the frequency of the passes?
13:04:38 <AaronFriel> nitrix: I don't believe so. You can reduce the frequency by increasing the size of the allocation area with the  -A RTS flag.
13:05:21 <AaronFriel> nitrix: An experimental feature in the next GHC, compact regions, will allow much stronger controls on what garbage collection occurs and its cost.
13:06:32 <ExpHP> so haskell can have dynamic bindings https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters
13:06:39 <ExpHP> the question is... dare I use them?
13:07:08 <AaronFriel> @ExpHP most people do not use them in favor of explicit bindings or the Reader monad, or more complicated monad stacks.
13:07:08 <lambdabot> Unknown command, try @list
13:07:20 <tdammers> I think they're mildly evil
13:08:09 <tdammers> explicit bindings are more explicit (ergo better), at the expense of being slightly more explicit (ergo more work to type and read)
13:08:35 <tdammers> it's a neat feature, but I doubt I'll ever use it
13:08:36 <ExpHP> yeah, Reader is what I figured, but I feel having to wrap types like that tends to cause tight coupling
13:09:24 <ExpHP> er, I don't mean wrapping /types/, but... rather, the way it affects function signatures
13:09:54 <AaronFriel> Apologies to the Hackage people for the uhm... upload spam, as the 4th time is the charm, I just published this simple little package: https://hackage.haskell.org/package/graphted, which I call graph-indexed monads/functors/etc.. Why graph-indexed? Because the parameter of the indexed tracks the operations performed on it (e.g.: Apply, Bind, Fmap, etc.) and
13:09:55 <AaronFriel> allows a GADT that uses such a monad to pattern match on the operations.
13:10:50 <AaronFriel> Example use here: https://github.com/AaronFriel/eff-experiments/blob/temp-wip/src/Control/Monad/Graph/Eff.hs
13:11:23 <AaronFriel> That's prior to me cleaning up and pulling out "graphted" as a dependency, and renaming things to be cohesive.
13:14:31 <AaronFriel> By nicely defining those operations, it works well (and type checks well) with the language extensions NoImplicitPrelude, RebindableSyntax, ApplicativeDo, as in this code sample: http://lpaste.net/355161
13:16:03 <james111> How can I condense these two functions into one? http://lpaste.net/355162
13:18:24 <jle`> AaronFriel: so this is like a generalized version of indexed functors/applicatives/monads ?
13:19:19 <AaronFriel> jle`: I think so? Similar to rmonad, but I think simpler and moving in a different direction. I use type families where they used constraints.
13:19:52 <jle`> i'm referring to https://hackage.haskell.org/package/indexed-0.1.3
13:20:09 <fosterite> AaronFriel: is this supposed to let me specify what control paths are legal in a more modular way?
13:20:43 <jle`> AaronFriel: basically instead of f i j a, you have f g a; you can get the original by having g being (i, j)
13:21:09 <jle`> and it lets you custom-define your type functions Bind/Fmap/etc. instead of fixing them like indexed does
13:21:10 <AaronFriel> fosterite: Yes, you could write the family such that no instance of "Bind (Apply ..) .." is permitted, which would restrict any implementation to never using sequentially dependent application after parallelizable application.
13:21:31 <jle`> so you could implement the indexed package with what you have
13:25:12 <AaronFriel> I did that, here wrapping IxMonad (https://github.com/AaronFriel/eff-experiments/blob/temp-wip/src/Control/Monad/Graph/Class/Indexed.hs) and here with a categorical approach (https://github.com/AaronFriel/eff-experiments/blob/temp-wip/src/Control/Monad/Graph/Class.hs#L147-L185) 
13:26:05 <AaronFriel> One thing that's not satisfying is with the former, (wrapping IxMonad) there's no good way to get type inference for "return", to restrict it to the domain "WrappedIx m (i, i) a"
13:27:45 <AaronFriel> I think I would need kind classes to be able to specify a "UnitElementKind" of the parameter (in this case, the kind (k, k), and UnitElementKind would be k) and a type function UnitElementKind p -> p
13:29:45 <AaronFriel> e.g.: For indexed monads, "ireturn :: a -> m i i a". I would want to define "greturn :: forall (i :: UnitElementKind p) a. a -> m i a" instead of "greturn :: forall a. a -> m (Unit m) a".
13:31:09 <AaronFriel> ^ oops, this is what I would want: "greturn :: forall (i :: UnitElementKind p) a. a -> m (Unit m i) a", which would take an arbitrary type of kind "UnitElementKind p" and turn it into a "p".
13:44:50 <tdammers> ExpHP: dynamic vars don't reduce the coupling, really; it just looks like it
13:45:05 <tdammers> ExpHP: but the dependency between the code that uses the variable and the code that sets it is still there
13:45:31 <tdammers> ExpHP: it's just that the dependency is invisible on the in-between layers in the call graph
13:58:28 <thang1> sup
14:00:01 <lpaste> asd pasted “Hello” at http://lpaste.net/4190387629776175104
14:00:51 * thang1 congratulates asd
14:11:15 <dannyxn> hello
14:11:36 <dannyxn> what is haskell used for?
14:11:46 <pharaun> everything?
14:12:25 <dannyxn> you meant it is possible to bulid web apps with haskell?
14:12:40 <Tuplanolla> It'd be easier to ask what it's not used for, dannyxn.
14:13:11 <dannyxn> so what haskell isn't used for?
14:13:45 <Tuplanolla> That'd be embedded systems and hpc.
14:13:50 <pharaun> certain sectors such as some subset of embedded system (but there's embedded system code-generators in haskell) :) and anything that might be sensitive to GC
14:14:01 <rblaze> dannyxn probably not used for first person shooters
14:14:04 <pharaun> but even games often are implemented in languages with GC so its not impossible
14:14:19 <EvanR> :t fmap (+1) (0,0)
14:14:20 <lambdabot> (Num t, Num b) => (t, b)
14:14:21 <pharaun> (see minecraft and java, kerbal space program and C#, and unity based games)
14:14:26 <EvanR> whats up with those choices of letters?
14:14:36 <pharaun> dannyxn: there's wai/yesod/snap/happstack (for web dev)
14:14:46 <EvanR> pharaun: i wish ksp/unity didnt freeze up my mac
14:14:52 <EvanR> gc or not
14:14:53 <pharaun> EvanR: me too
14:15:22 <dannyxn> is it possible to compare haskell and python?
14:15:50 <pharaun> how so?
14:15:54 <pharaun> in what regard?
14:16:00 <pharaun> there's many ways you can compare it
14:16:35 <EvanR> > compare "Haskell" "Python"
14:16:37 <lambdabot>  LT
14:16:46 <pharaun> ha
14:16:50 <EvanR> stands for leeter
14:17:23 <Aruro> > compare "Haskell" "Lisp"
14:17:25 <lambdabot>  LT
14:17:26 <dannyxn> I'd like to hear that in real time converstation
14:17:41 <tdammers> dannyxn: yes, of course... it's just that they are very different languages, so I don't know how interesting the comparison is going to be
14:17:42 <dannyxn> and discuss about it
14:18:13 <Aruro> lets all think about beatiful 50k lines of C code which went into "Haskell" runtime
14:18:15 <pharaun> did this person leave?
14:18:19 <Sonolin>  > compare "Haskell" "VimL"
14:18:28 <Sonolin> > compare "Haskell" "VimL"
14:18:30 <lambdabot>  LT
14:18:35 <Sonolin> ehhh idk about that
14:19:14 <EvanR> stackless python vs tagless gmachine
14:19:22 <Aruro> > compare "C" "C++"
14:19:24 <lambdabot>  LT
14:20:04 <tdammers> > let C = 'C' in compare C (succ C)
14:20:06 <lambdabot>  error: Not in scope: data constructor ‘C’
14:20:12 <tdammers> ah ofc
14:20:21 <tdammers> > let c = 'C' in compare c (succ c)
14:20:23 <lambdabot>  LT
14:20:58 <Aruro> > succ "C++"
14:21:01 <lambdabot>  error:
14:21:01 <lambdabot>      • No instance for (Enum [Char]) arising from a use of ‘succ’
14:21:01 <lambdabot>      • In the expression: succ "C++"
14:21:29 <EvanR> > succ 'c'
14:21:31 <lambdabot>  'd'
14:21:39 <Aruro> yeah, its char
14:21:42 <EvanR> i guess we finally answered that question
14:21:57 <EvanR> (the value of C++)
14:22:08 <Aruro> > compare "Haskell" "Cobol"
14:22:09 <lambdabot>  GT
14:22:16 <tdammers> I think it's mildly disappointing that we can't have stuff like forall a. compare a (succ a)
14:22:21 <orion> > succ 'Z'
14:22:23 <lambdabot>  '['
14:23:01 <EvanR> :k a b (c b)
14:23:03 <lambdabot> error: Not in scope: type variable ‘a’
14:23:03 <lambdabot> error: Not in scope: type variable ‘b’
14:23:03 <lambdabot> error: Not in scope: type variable ‘c’
14:25:07 <Aruro> why if u type one character in ghci command Ctr-D does not function anymore
14:26:10 <Aruro> seems like feature to prevent suddent exit?
14:26:12 <dyreshark> Aruro: see the answer here: http://stackoverflow.com/questions/20340561/why-isnt-ctrl-d-signaling-eof-with-this-program
14:26:18 <pharaun> Aruro: ipython same
14:26:33 <pharaun> i just tested it with ipython as well and it has the same behavur
14:26:58 <Aruro> to be fair bash has same :)
14:27:14 <EvanR> must be a terminal thing
14:28:28 <Aruro> why is bash still around? its so outdated ? were there attempts to design better stuff?
14:28:52 <EvanR> there are other shells, and reimplementations of bash
14:28:56 <Aruro> like rethink whole philosophy with stdin out and err
14:29:04 <EvanR> oh yeah totally
14:29:12 <EvanR> nothing fundamental about ByteString
14:29:33 <EvanR> but were stuck
14:29:42 <Aruro> like parsing output of another programm seems supid when bash could just pass it in smth like stdcomm
14:29:42 <yushyin> Aruro: like powershell?
14:30:10 <ph88_> when i yield Double in my Conduit is a a Conduit Double or a Conduit [Double]   ?
14:30:31 <Aruro> same with parsing command line, also stupid, has to be done by bash ?
14:30:56 <Aruro> millions of libs just to do this redundant task
14:31:16 <Sonolin> you know there's a #linux right?
14:31:37 <Aruro> Sonolin: has nothing to dowith haskell? i dont think so :)
14:32:02 <Aruro> majority of haskell libs do something what bash or good shell had to be doing
14:32:25 <Sonolin> I don't think bash is related to Haskell much at all
14:33:30 <Aruro> Sonolin: im saying that haskell lib ecosystem is been build around old building, which is linux shell
14:34:15 <Aruro> im sure haskellers would have created much better shell
14:34:46 <dyreshark> they have
14:34:49 <dyreshark> it's called ghci ;)
14:34:54 <Aruro> :)
14:35:03 <Tuplanolla> Lisp machines had a repl as a shell...
14:35:48 <EvanR> i cant stand "lisp repl as a shell"
14:35:55 <ReinH> So has Microsoft, actually.
14:35:58 <thang1> why not?
14:36:05 <EvanR> its not very ergonomic
14:36:22 <EvanR> you have to start every line with (, so why do you have to actually type it?
14:36:28 <EvanR> shouldnt it just be assumed
14:36:32 <ReinH> PowerShell has structured data pipelines.
14:36:40 <Aruro> ReinH: really?
14:36:45 <ReinH> Yeah.
14:36:47 <thang1> Fair. I really don't tend to like full blown turing complete languages in shells
14:36:55 <EvanR> powershell lets you pass C# objects through the pipe
14:36:59 <Aruro> ReinH: interesting
14:37:02 <thang1> BASH and other traditional shells are fine because they don't feel turing complete due to being /designed/ as shells
14:37:11 <Aruro> are there haskell libs tuned for powershell?
14:37:25 <ReinH> You can define your own typed structures. https://technet.microsoft.com/en-us/library/ff730946.aspx
14:37:37 <EvanR> does haskell even interact with .NET in any way
14:37:57 <Aruro> ah, so linux users can get calm right?
14:38:11 <thang1> The only thing I know of currently for shell stuff in haskell is Turtle
14:38:26 <Aruro> there is also shelly
14:38:37 <thang1> oh yeah, that too
14:38:40 <lambdamu> Does anyone else think the prominence of the lambda calculus is somewhat odd, given how strongly it resembles implication when implication as a logical operation is rather decidedly sumbsumed by disjunction in combination with negation in logic?
14:38:56 <ReinH> Honestly, the Linux shell and the entire file descriptor system is an archaic PITA, as anyone who has looked at pipes or conduit for process management can probably tell you.
14:39:31 <ReinH> The things you have to do to make stdout and stderr behave like nice conduits is o_O
14:39:33 <EvanR> lambdamu: implication is not disjunction+negation in intuitionistic logic
14:39:45 <EvanR> even in classical, thats really annoying
14:40:15 <EvanR> also lambda calculus is illogical
14:40:19 <Aruro> ReinH: are there any new systems on horizon? System 9 (or Project 9) ?
14:40:30 <ReinH> idk
14:40:37 <thang1> lol not in any meaningful way
14:40:47 <thang1> Windows, Linux, OSX, etc., won.
14:41:06 <Aruro> i forgot there was some system Poject 9 or Platform 9
14:41:11 <thang1> Now there are new sub-units of stuff that's coming out... Rust is looking to replace C, oilshell is an interesting new take on shell languages
14:41:12 <Aruro> from good old folks
14:41:22 <EvanR> Plan 9
14:41:25 <ph88_> can anyone give me a hint what i could do to get these parsing and conduit functions right?  https://bpaste.net/show/4d799bce2cd8
14:41:27 <thang1> and so on
14:41:31 <Aruro> EvanR: yeah that
14:42:09 <thang1> To put it thisa way, if any new OS comes out and even makes a dent in the market at this point, it's only going to happen because it completely obliterates the current market. That will only happen if somehow there's a completely new paradigm of computing/technology that's yet to be uncovered
14:42:09 <ReinH> Here's a fun discussion of the issues for pipes specifically https://groups.google.com/forum/m/#!msg/haskell-pipes/JFfyquj5HAg/Lxz7p50JOh4J
14:42:29 <thang1> (and by uncovered I mean "quite rapidly, before existing solutions can evolve")
14:43:17 <Tuplanolla> People forget these things are even possible: http://www.loper-os.org/?p=284
14:43:29 <lambdamu> EvanR: but doesn't linear logic reconcile the symmetry of the idea implication = disjunction + negation with the fact that it isn't quite accurate in constructive logic?
14:44:06 <EvanR> im still pretty neophyte with linear logic
14:44:13 <alicemaz> there's a truism that a lot of these sorts of markets that benefit greatly from network effects (desktop OS, phone OS, social network, etc) have room for 2.5 players
14:44:27 <alicemaz> often seems to be the case
14:45:18 <monochrom> And politics. :)
14:45:36 <alicemaz> heh
14:45:58 <Aruro> was linux a player?
14:46:28 <monochrom> Yes.
14:47:00 <monochrom> Or no, if you mean "iPod was a player, Creative Jukebox was a player, linux was not".
14:47:06 <alicemaz> for pc I'd call it the 0.5. it seems to be ubiquitous for us but we are very much in the minority. for servers ofc it is the leader
14:47:42 <alicemaz> but yknow "next year in linux on the desktop"
14:47:57 <monochrom> It is also wise to not take the number 2.5 too literally.
14:50:23 <EvanR> (+ x * y) looks funny but seems to work
14:51:13 <EvanR> and (* x + y) doesnt
14:51:52 <EvanR> also is (+1) or (1+) better
14:52:07 <EvanR> (+x) or (x+)
14:54:57 <DrMentats> I think ghc-mod might have a memory leak. usage goes up to a whopping 2.2 GB on my machine, then if I kill it in the process monitor, it goes back down to just under 65 MB while performing no worse than before (as far as I can see). I'm using it through Atom's haskell-ghc-mod package.
14:56:14 <MarcelineVQ> EvanR: if there's a better it's more likely to be x+  since that would become a partially applied (+) rather than perchance a lambda, idk for sure though, depends how it's desugared, what core you get, and ultimately whether a CAF matters to you
14:56:40 <MarcelineVQ> there's more here about that, though I find it a little confusing https://wiki.haskell.org/Constant_applicative_form
14:57:03 <EvanR> its a CAF ?
14:57:30 <MarcelineVQ> depends how it desugars so maybe
15:03:16 <EvanR> MarcelineVQ: that discussion is making my head spin
15:04:29 <monochrom> It is best to just read core.
15:05:44 <monochrom> I think that CAF's only significance is "GC has to honour it as one of the roots, and cannot deallocate it because it isn't even on the heap"
15:06:01 <monochrom> (although, its child or grandchild or whatever may be.)
15:06:22 <monochrom> So, a global binding.
15:07:52 <Tuplanolla> Is there a prettier formulation of hyperspherical coordinates than the one mathematicians usually use?
15:08:09 <Tuplanolla> Implementing it feels wrong on some level.
15:08:12 <Aruro> DrMentats: ghc-mod had been known to be slow, so far nothing changes, like years.
15:08:49 <Aruro> Tuplanolla: sperical coordinates in n dimensions?
15:08:55 <Aruro> h*
15:08:55 <Tuplanolla> Yes, Aruro.
15:09:28 <Aruro> just spherical then, if im not mistaken. there is hypercube though
15:09:53 <Aruro> i personally think "whatever" if meaning is correct
15:10:06 <Tuplanolla> I don't follow.
15:10:35 <Aruro> there is term hypercube hypersphere
15:10:47 <Aruro> but this suffix seems not to apply to coordinate systems names
15:10:54 <Aruro> prefix*
15:11:12 <Tuplanolla> Okay, sure. My question still stands.
15:12:07 <MarcelineVQ> what's the current notation? n-tuple for n-dimentions?
15:12:33 <MarcelineVQ> I suppose I could ask google, nvm me :>
15:12:42 <monochrom> Oh! Maybe you can do this. The gist is just to run "sin^2 + cos^2 = 1" on steroid, right?
15:13:01 <Tuplanolla> The azimuthal angle is not consistently against the highest dimensional axis in the conventional formulation, MarcelineVQ.
15:13:24 <monochrom> So when you have "a^2 + b^2 + c^2 + d^2 = 1", there are two ways to cut up the RHS to fit "sin^2 + cos^2 = 1"
15:14:17 <monochrom> One way is a^2 = sin^2 theta , b^2+c^2+d^2 = cos^2 theta and then introduce another angle to further cut up b,c,d.
15:14:22 <Tuplanolla> The polar angle is also shoved to the end of the components instead of the beginning, so taking the infinite-dimensional limit would be symmetry-breaking.
15:14:24 <ExpHP> what are we trying to do here? generate normalized vectors?
15:14:48 <monochrom> But maybe you want to do a middle cut: a^2 + b^2 = sin^2 theta, c^2 + d^2 = cos theta.
15:14:52 <stevebash> Hi, I'm having difficulty with Text.Parsec, I'd like to parse a value {1,2,3} and return the whole value including brackets
15:15:06 <stevebash> I've got this pVal :: Parser Text
15:15:08 <stevebash> pVal =  toS <$> (string "{" <*> (many (noneOf "{}")) <*> string "}")
15:15:10 <stevebash> yiii
15:15:20 <stevebash> pVal :: Parser Text
15:15:22 <stevebash> pVal =  toS <$> (string "{" <*> (many (noneOf "{}")) <*> string "}")
15:15:24 <stevebash> y
15:16:34 <stevebash> Doesn't compile, how to make it return the "{}" with the <*> operator?
15:17:12 <stevebash> pPgArray :: Parser Text
15:17:14 <stevebash> pPgArray =  toS <$> (string "{" *> (many (noneOf "{}")) <* string "}")
15:17:30 <stevebash> If I do that it does compile but doesn't include the "{}"
15:18:03 <ExpHP> stevebash I think you're close.  The thing on the left of <*> needs to be a parser of functions (e.g. Parser (String -> String -> String))
15:18:56 <monochrom> stevebash: I want you to study the following example, it is not parsec but it's still Applicative, using Maybe.
15:19:05 <lambdamu> mconcat <$> sequenceA [string "{", many (noneOf "{}"), string "}"]
15:19:10 <ExpHP> e.g. I think this would give you all but the "}": (++) <$> string "{" <*> (many (noneOf "{}"))
15:19:15 <lambdamu> wouldn't something like that work?
15:19:30 <monochrom> > (((\a b c -> a*b + c) <$> Just 2) <*> Just 3) <*> Just 4
15:19:32 <lambdabot>  Just 10
15:19:39 <monochrom> You see how I parenthesize it?
15:20:42 <stevebash> Thanks a lot ExpHP I'll see if I can make it work with your examples
15:21:22 <ExpHP> stevebash in fact I think it can be made much less magical looking with some  do notation
15:21:47 <ExpHP> do {a <- parser1; b <- parser2; c <- parser3; pure (a ++ b ++ c); }
15:23:03 <stevebash> I've not tried that yet, thanks a lot, that would be more readable
15:28:59 <stevebash> The do notation worked as you said, thanks again ExpHP
15:31:00 <Tuplanolla> I mustn't be the only one to feel that the common definition of spherical coordinates is gross and unsatisfying.
15:31:43 <monochrom> Have you tried what I said?
15:32:40 <Tuplanolla> I didn't get what you said, but I'll have to look into it, monochrom.
15:33:31 <Tuplanolla> I see how it could lead somewhere, however.
15:33:36 <ExpHP> it's like the common definition of slope. Who knows why we aren't all working in the projective plane...
15:35:01 <ExpHP> no wait, I got it
15:35:05 <ExpHP> it's like ieee-754
15:35:59 <ExpHP> where everybody has agreed upon using a standard which fails to satisfy even the property that x == x
15:36:11 <monochrom> We are working in the projective plane when talking about slope. We say "slope is infinity" all the time.
15:36:44 <ExpHP> monochrom yet if I ask matplotlib to plot a vertical line, I get a divide by zero error :V
15:36:46 <Tuplanolla> You can call it ISO 31-11 if you're feeling sassy.
15:37:48 <monochrom> Ah yeah then matplotlib is not doing homogeneous coordinates when it ought to.
15:38:29 <monochrom> I guess its author had only thought of plotting functions, "you have to pass the vertical line test".
15:38:46 <monochrom> Except it passes that test and fails the other vertical line test :)
15:38:52 <thang1> lol
15:38:53 <ExpHP> my feeling is that a whole lotta software does it wrong; most important software that does any kind of heavy lifting
15:39:45 <ExpHP> because for some reason, the beautiful side of mathematics just never  makes it into this stuff
15:40:04 <thang1> Beautiful perfection meets ugly, greasy hardware never works well
15:40:37 <monochrom> The beautiful side of mathematics doesn't make it into the programming curriculum.
15:41:05 <Tuplanolla> Often it doesn't make it into mathematical publications either.
15:41:14 <monochrom> Even if it did, it wouldn't make it into the students' heads.
15:41:17 <ExpHP> tbh I still don't get why euclidean division isn't the standard behavior of integer division/modulus in even a single language--not one (that I know of)
15:41:18 <Tuplanolla> Need more Greek letters to secure funding.
15:41:34 <Myrl-saki> lol
15:42:05 <ExpHP> python and haskell at have floored division, which is slower, more complicated to describe imo and has fewer nice properties
15:42:46 <monochrom> What does euclidean division do again? Remainder is betwen -4 and 4 (when dividing by 10)?
15:42:48 <ExpHP> whereas euclidean division is just:   0 <= a mod b < abs b.
15:42:59 <ExpHP> always-positive modulus
15:43:07 <monochrom> I see.
15:43:43 <monochrom> > (5 `mod` (negate 3), 5 `rem` (negate 3))
15:43:45 <lambdabot>  (-1,2)
15:43:52 <monochrom> One more test
15:43:57 <ExpHP> I often people say how they sometimes find the behavior of floored division useful for floats, but I've never had the fortune of actually running into one of those cases
15:44:02 <monochrom> > negate 5 `rem` 3
15:44:04 <lambdabot>  -2
15:44:05 <ExpHP> or maybe I'm just not thinking outside fo the box
15:44:11 <monochrom> Ah, darn.
15:45:37 <benzrf> haskell 2010 typeclasses could theoretically be implemented purely by monomorphizing, right? with no dictionary passing
15:45:44 <monochrom> Didn't Knuth write something in favour of euclidean division?
15:46:03 <benzrf> (no specific reason im asking - i was just thinking about why dictionaries are necessary and realized that as far as i can tell, they /technically/ aren't)
15:46:41 <Tuplanolla> Are you saying that you could specialize to all known types the way C++ does templates, benzrf?
15:46:50 <ExpHP> monochrom: no idea
15:46:51 <benzrf> i don't know how C++ does templates :>
15:46:51 <monochrom> benzrf: If I assume whole-program compilation and no polymorphic recursion, I think yes.
15:46:58 <benzrf> monochrom: polymorphic recursion?
15:47:05 <benzrf> ooh hold on
15:47:13 <ExpHP> monochrom: The first time I actually saw the phrase used was in this article: https://www.microsoft.com/en-us/research/publication/division-and-modulus-for-computer-scientists/
15:47:14 <taktoa> C++ does templates by macro expansion
15:47:15 <thang1> C++ templates are basically black magic
15:47:24 <benzrf> i don't even really know what templates are
15:47:25 <taktoa> no they're actually pretty simple.
15:47:45 <ExpHP> though at that point I was already aware of the utility of always positive moduli, and had to implement it in a couple of projects
15:47:46 <taktoa> benzrf: C++ always monomorphizes templated functions
15:47:51 <benzrf> c++ is one of the few langauges ive never tried to learn
15:48:24 <monochrom> ExpHP: I think that's the article I saw too.
15:48:53 <nh2> benzrf: it is interesting to learn, it has some real ugliness but also some really good things
15:49:07 <ExpHP> C++ templates are like macro expansion in the AST
15:49:16 <ExpHP> safer but still duck-typed
15:49:19 <taktoa> nh2: lol got really confused seeing your name in two different channels at once
15:49:36 <benzrf> ExpHP: "macro expansion in the AST" is redundant isnt it? isnt that how about half of macro systems work
15:49:41 <ExpHP> hehe
15:49:45 <benzrf> lisp macros and rust macros certainly both work in the ast, and so do haskell macros
15:49:47 <ExpHP> not C :D
15:49:48 * monochrom spreads rumour: Stroustrup says "anyone who want to do type-level numbers in Haskell should consider C++ instead" :)
15:50:22 <benzrf> ah yes, C's macros occur in the ASL
15:50:24 <benzrf> :]
15:50:37 <taktoa> C++ _can_ do polymorphic recursion btw, you just can't instantiate a function at an infinite set of types
15:50:53 <taktoa> so the polymorphic recursion you can do is really boring
15:51:42 <taktoa> (disclaimer: that statement is based on my understanding of how C++ template expansion works and could totally be inconsistent with the actual implementations)
15:52:26 <ExpHP> benzrf: To be entirely honest I do actually more or less equate c++ templates with rust macros in terms of power
15:52:42 <ExpHP> maybe that's because I write too much rust :V
15:52:43 <benzrf> so they really are just macros?
15:52:53 <taktoa> yes
15:52:56 <benzrf> ah ok
15:52:58 <benzrf> ive decided to finally maybe try learning rust for real
15:53:33 <ExpHP> rust is my baby
15:53:39 * ExpHP snuggles rust protectively
15:54:25 <ExpHP> except for the part where I abandoned it for my two latest projects to write them in haskell
15:54:25 <benzrf> im thinking maybe i will rewrite in rust this toy renderer i previously did in C
15:54:28 <benzrf> heh
15:54:53 <glguy> Alright, my screen filled up with messages about Rust and C++, so it's time to move back to the /topic
15:56:09 <Rembane> If you like to continue the off topic conversation, go to #haskell-offtopic and rock your socks off!
15:56:10 <benzrf> glguy: why do you hate fu-oh wait i almost called C++ "fun"
15:56:16 <benzrf> Rembane: why not #haskell-blah 
15:57:16 <Rembane> benzrf: Because #haskell-offtopic is mentioned in the /topic of this channel and #haskell-blah isn't.
15:57:34 <benzrf> lame
15:58:03 <Rembane> benzrf: Indeed, poke geekosaur! 
15:58:39 <ExpHP> #haskell-offtopic isn't in /list so it must not exist. (QED)
15:59:48 <Tuplanolla> That place is too offtopic though.
16:00:11 <taktoa> there's no such thing as "too offtopic" :P
16:00:12 <MarcelineVQ> it's whatever you want it to be
16:00:57 <Rembane> Does it become ontopic if it is too off topic?
16:01:07 <benzrf> h o r s e s h o e   t h e o r y
16:01:33 <ExpHP> I wonder, is this topic ontopic? what mysteries!
16:01:47 <taktoa> homotopic
16:05:01 <thang1> I really wanna learn Rust, actually
16:05:19 <geekosaur> wut?
16:05:25 <thang1> But I'm more focused on learning Haskell now atm. I'm semi-proficient in C-family languages
16:05:47 <thang1> Also I scrolled up 2 pages and forgot I was contributing to a conversation that probably happened 30 minutes ago lol
16:06:08 <ExpHP> "gee, the lag is really bad today"
16:06:24 <thang1> that damn ping
16:06:45 * thang1 says as he has a ping time of 5ms to google.com from blazing fucking fast university wifi
16:08:54 <benzrf> tfw freezing fucking slow college wifi
16:09:13 * thang1 pets benzrf's head in sympathy
16:09:49 <thang1> Hmm... currently 10 -> 2.5 MB/s download speeds
16:10:22 <thang1> The guys doing the wifi network here are actually really smart. They don't cap your internet speed for small downloads so you can install stuff like OS updates or download small videos or whatever super fucking fast
16:10:40 <thang1> But they're gonna throttle your 100TB porn downloads down to a reasonable 2.5MB or so
16:34:39 <erisco> any thoughts on a generalisation of newtype Tree a = Tree [(a, Tree a)] ?
16:35:16 <mniip> that's a weird tree
16:35:26 <erisco> say we use bifunctors instead, so newtype X f a = X (f a (X f a))
16:35:30 <mniip> are you sure that's exactly the structure you want
16:35:36 <erisco> not sure if that is anything interesting
16:35:41 <erisco> yup
16:35:50 <erisco> labeled edges
16:35:53 <mniip> ok
16:36:13 <mniip> it's a fixpoint
16:36:24 <erisco> I already have the program written but I am feeling something more general here
16:36:27 <mniip> Mu (WriterT a [])
16:36:57 <mniip> no wait
16:36:59 <mniip> wrong order
16:37:26 <mniip> no yes, that's the right order
16:41:27 <NickHu> Do I want LoggerT (MaybeT IO a) or MaybeT (LoggerT IO a)?
16:42:01 <NickHu> Or maybe (MonadIO m, MonadLogger m, MonadMaybe m) => m a
16:42:22 <erisco> mniip, isn't that a kind error? WriterT is missing an argument
16:42:42 <glguy> NickHu: That's up to you, depends if you want the log if the MaybeT layer ends in failure
16:42:49 <glguy> NickHu: also the first two were kind errors
16:43:08 <mniip> erisco, so?
16:43:14 <glguy> erisco: It's supposed to be missing that last argument so that it has kind * -> *
16:43:23 <erisco> then I have the wrong definition of Mu
16:43:30 <mniip> "missing an argument" it isn't a type family
16:43:50 <mniip> newtype Mu f = In { out :: f (Mu f) }
16:44:05 <erisco> yup the one I got was different, heh
16:44:17 <erisco> so it is just another name for Fix, then
16:46:31 <erisco> that's another possibility but I am not sure what implications we have then
16:47:31 <ZelteHonor> If I have question about parser combinator, can someone answer me?
16:47:58 <pacak> Foldable instance for (,) at haskell cafe, round 2, fight....
16:48:05 <NickHu> glguy: Just to check my intuition, the first one is the one which can log MaybeT failure right?
16:48:29 <glguy> NickHu: No
16:50:14 <erisco> O
16:50:34 <NickHu> oh right yes, more inwards is towards the bottom of the stack
16:50:35 <geekosaur> ZelteHonor, probably best just to ask it
16:50:56 <erisco> I'd be tempted to say  X m f = X (m (f (X m f)))  but then it is essentially Fix
16:51:45 <erisco> it had been a bit frustrating... there are these subtly different tree-like types and it feels like there should be a way to have all of them
16:52:35 <ZelteHonor> I am using a parser combinator library in another language (FParsec in F#). It is inspired by parsec and I feel that I might have better luck here. I am trying to convert à Lex/Yacc based parser of the lambda-calculus. The problem is, the parser use left-recursive grammar. The library does not support that. Is there anything I can do?
16:52:50 <benzrf> ZelteHonor: you could just use earley or something ;P
16:53:09 <erisco> mniip, is there anything interesting about such a fixed point? i.e. assuming a monad?
16:53:39 <erisco> ZelteHonor, yes, you factor out the left recursion
16:53:47 <Costar> Hi all
16:55:15 <benzrf> hi Costar
16:55:19 <erisco> ZelteHonor, for example  S ::= Sa | b  we first find all the prefixes S can start with
16:55:43 <erisco> ZelteHonor, which is clearly b, in this case. then we find all the things that can follow, which is a repetition of a's
16:55:47 <ZelteHonor> Would it help showing the Yacc grammar?
16:56:12 <Costar> hi benzrf
16:56:28 <ZelteHonor> http://lpaste.net/355169
16:56:36 <erisco> ZelteHonor, so we get S ::= bT; T ::= aT | ε
16:57:55 <erisco> I don't know Yacc grammars, but if you follow the method I described (admittedly vaguely) then you can figure it out
16:59:32 <erisco> oops I goofed, it should be  T ::= aT | a
16:59:41 <erisco> that's an off-by-one error for grammars I suppose :P
16:59:50 <monochrom> "S ::= Sa | b" can be rewritten as "S ::= (a*)b". You can then use "many a >> b".
17:00:15 <glguy> you mean b(a*)?
17:00:19 <erisco> you have it backwards monochrom
17:00:24 <monochrom> Oh! Oops. Yeah.
17:00:45 <monochrom> "b >> many a"
17:00:51 <erisco> a little more completely described... take all the productions which are not left-recursive
17:00:56 <erisco> these are the prefixes
17:01:07 <erisco> so make these productions into a rule
17:01:26 <erisco> then take all the left-recursive productions and reduce to just the suffixes (after the left-recursive non-terminal)
17:01:31 <erisco> make this another rule
17:01:40 <erisco> then it is the first rule followed by the second
17:02:23 <erisco> or first non-terminal followed by the second, I mean, meh
17:02:31 <ZelteHonor> The Yacc grammar is basicelly, EXP ::= APP | OtherStuff ; APP ::= APP Close | Close ; Close ::= cst | ident | S
17:02:50 <ZelteHonor> S should be EXP
17:04:56 <erisco> well... I'd prefer you try and refactor it and then let us know where you get stuck
17:05:33 <ZelteHonor> Just to be sure, I should only change the production off APP, and introduce other rule. I should not change the other?
17:06:30 <ZelteHonor> Also, thanks a lot.
17:08:32 <erisco> you have to be careful because, for example, A ::= Ba | b; B ::= A  is left-recursive also
17:10:28 <erisco> I know the last line isn't valid BNF but that is how you'd think of it http://lpaste.net/355170
17:11:22 <erisco> we reduce the mutual recursion to self recursion by substitution
17:11:27 <erisco> then it becomes clear what is going on
17:12:53 <ZelteHonor> I think I see it.
17:13:18 <erisco> now we have goofy productions like APP ::= APP
17:13:37 <erisco> I am going to assume that this is nonsense and ignored
17:14:05 <erisco> otherwise we have an ambiguous grammar
17:14:30 <ZelteHonor> Hum wait. I have mislead you I am sorry. The last production of close is actually (EXP)
17:14:44 <ZelteHonor> And not EXP directly.
17:14:52 <erisco> ah, well that makes much more sense
17:16:03 <erisco> I made an edit
17:16:58 <erisco> so we go back to step 1) what are the prefixes? i.e. what are the productions which are not left-recursive?
17:17:54 <ZelteHonor> I think there is only one. It is close in APP.
17:18:42 <erisco> I made another edit, try again
17:20:06 <ZelteHonor> The 3 last line.
17:20:48 <ZelteHonor> If I discovers a left-recursive problem in OtherStuff, but related to the EXP rule, can I solve them seperatly?
17:20:48 <erisco> well there are three. lines 15, 16, and 17
17:21:34 <erisco> if it doesn't involve APP then sure
17:21:43 <ZelteHonor> Yeah.
17:22:00 <ZelteHonor> In other stuff there is a rule bin_op
17:22:03 <ZelteHonor> And
17:22:12 <ZelteHonor> bin_op ::= EXP + EXP
17:22:47 <ZelteHonor> So back to APP.
17:24:31 <erisco> so you have all the ways an APP can begin
17:24:44 <erisco> make a rule for that, call it PREFIX, say
17:25:12 <erisco> now you need all the ways it can end
17:25:33 <erisco> these are all the left-recursive productions with the first non-terminal reduced (i.e. remove it)
17:26:00 <erisco> make that a rule and call it SUFFIX
17:26:25 <erisco> now, APP', i.e. our right-recursive refactor of APP, is just a PREFIX or a PREFIX followed by one-or-more SUFFIX
17:26:42 <ZelteHonor> So we have
17:28:19 <ZelteHonor> PREFIX ::= cst | ident | '(' (APP | OtherStuff) ')' ; SUFFIX ::= cst | ident | '(' (APP | OtherStuff) ')' :: APP' ::= PREFIX | PREFIX (one or more SUFFIX)
17:28:42 <erisco> yup
17:28:47 <erisco> something like this http://lpaste.net/355173
17:29:06 <erisco> now you can look at that result and find it is rather clunky, and we no longer have Close and EXP
17:29:22 <erisco> so we can do some re-organising at this point to clean it up and get those back
17:29:51 <erisco> you also need to substitute APP' for APP
17:30:03 <erisco> or do we say it the other way around in English? I don't know :P
17:30:30 <ZelteHonor> I don't know. I am french.
17:31:52 <erisco> the first obvious observation is that PREFIX and SUFFIX are the same
17:32:01 <erisco> because we began with APP ::= APP Close | Close
17:32:37 <ZelteHonor> I'll soon have a course at University where I'll learn that.
17:32:47 <ZelteHonor> Yes
17:34:51 <erisco> the dual of this process gives you back left-recursion, as you might guess
17:35:06 <ZelteHonor> Something like that:
17:35:07 <ZelteHonor> APP' ::= FIX SUFFIXES SUFFIXES ::= FIX SUFFIXES | FIX FIX ::= cst | ident | '(' (APP' | OtherStuff) ')'   -- NOTE that APP' is substituted for APP
17:35:17 <ZelteHonor> Oops
17:35:32 <ZelteHonor> APP' ::= FIX SUFFIXES ; SUFFIXES ::= FIX SUFFIXES | FIX ; FIX ::= cst | ident | '(' (APP' | OtherStuff) ')'   -- NOTE that APP' is substituted for APP
17:37:08 <ZelteHonor> I am not sure where to go, to put it back into the original grammar.
17:37:34 <erisco> well, APP and APP' are language equivalent, so you can just stick it right in
17:37:48 <erisco> and cross your fingers that the parser implementation can handle it
17:38:46 <ZelteHonor> Do stuff like this: APP' ::= FIX SUFFIXES SUFFIXES ::= FIX SUFFIXES | FIX FIX ::= cst | ident | '(' (APP' | OtherStuff) ')'  turn into this: APP' ::= FIX SUFFIXES SUFFIXES ::= FIX SUFFIXES | FIX FIX ::= cst | ident | '('APP' ')' | '(' OtherStuff ')' 
17:38:54 <ZelteHonor> Wait
17:39:06 <ZelteHonor> Copy paste fail
17:39:13 <erisco> if other parts of the grammar use Close, for example, well we know that Close ::= cst | ident | '(' (APP' | OtherStuff) ')'
17:39:24 <erisco> because we can just stick in APP' wherever now
17:39:29 <ZelteHonor> FIX ::= cst | ident | '(' (APP' | OtherStuff) ')' into FIX ::= cst | ident | '('APP' ')' | '(' OtherStuff ')' 
17:40:57 <ZelteHonor> Is my transformation right?
17:42:16 <erisco> yup
17:42:32 <ZelteHonor> Thanks a lot. Your help is truly valuable.
17:42:48 <erisco> I am trying to think of it algebraically and am blanking
17:43:24 <erisco> x <*> (y <|> z) distributes, so you have x <*> y <|> x <*> z
17:43:36 <erisco> right, okay
17:43:46 <erisco> and it is both left and right distributive
17:44:14 <erisco> so then you get  (x <*> y <|> x <*> z) <*> w  and thus  x <*> y <*> w <|> x <*> z <*> w
17:44:47 <erisco> I am using the Haskell notation but since you're using parser combinators I assume you're familiar
17:45:12 <Welkin> does it really work that way?
17:45:36 <Welkin> or are you using haskell syntax for convenience
17:46:22 <erisco> I am not sure what dichotomy you're getting at Welkin
17:46:34 <Welkin> 20:43 < erisco> x <*> (y <|> z) distributes, so you have x <*> y <|> x <*> z
17:46:56 <erisco> you mean to ask if that is actually an Alternative law?
17:47:40 <erisco> I haven't read of any laws which interact between Applicative and Alternative, strangely
17:48:10 <erisco> but in the case of parsers this *may* hold
17:48:26 <pacak> :t (<|>)
17:48:28 <lambdabot> Alternative f => f a -> f a -> f a
17:48:35 <erisco> if it is a general CFG parser then it does, but otherwise may not
17:48:36 <pacak> :t (<>)
17:48:37 <lambdabot> Monoid m => m -> m -> m
17:48:43 <pacak> :t mempty
17:48:45 <lambdabot> Monoid a => a
17:49:01 <pacak> :t empty
17:49:03 <lambdabot> Alternative f => f a
17:49:12 <pacak> erisco: Alternative is a monoid for Applicative
17:49:16 <erisco> for example, a parser may have no trouble with x <*> (y <|> z) but stumble with x <*> y <|> x <*> z because it takes first match over the alternative
17:50:01 <erisco> in terms of grammar though, which parser combinators are designed to mimic (in Applicative-style anyways) -- hence "executable grammar" -- they are the same grammar
17:50:26 <ZelteHonor> How would I do if I want close and EXP back?
17:50:34 <erisco> pacak, what are the laws?
17:50:42 <pacak> Same as for monoid
17:50:55 <pacak> associativity, left and right identity elements
17:50:58 <erisco> that's fine, but specifically what are the laws that interact between Applicative and Alternative?
17:51:02 <erisco> the monoid laws do not
17:51:18 <pacak> :t (<|>)
17:51:20 <lambdabot> Alternative f => f a -> f a -> f a
17:51:21 <pacak> :t (<>)
17:51:22 <lambdabot> Monoid m => m -> m -> m
17:51:25 <erisco> ZelteHonor, just replace APP with APP'
17:51:29 <pacak> They are the same
17:51:42 <ZelteHonor> Thanks
17:51:44 <erisco> pacak, you are missing my point
17:54:07 <erisco> ZelteHonor, after you do that replacement you will probably see a lot of redundancy but that is okay. You can just clean up the grammar from that point
17:54:41 <ZelteHonor> Excellent. Left-recursion is evil.
17:54:51 <Welkin> erisco: not if it's pointless
17:55:23 <erisco> ZelteHonor, it is definitely a thorn for top-down parsing!
17:56:00 <erisco> Welkin, for the purposes of just generating a parser it may well be
17:56:15 <erisco> since it is likely to make several optimisations anyways
17:58:32 <ZelteHonor> Oh damn. It work. The new grammar work.
18:01:34 <thang1> what new grammar?
18:05:32 <DrMentats> http://imgur.com/a/k23uy The best way to ensure that automatically generated variables won't clash with user defined ones.
18:06:08 <EvanR> what in the
18:06:46 <DrMentats> I'm actually thinking about leaving it like this lol
18:07:03 <EvanR> is that a special font? or special rendering system or
18:07:41 <DrMentats> it's just unicode. I went to great lengths to refactor all my code in terms of Data.Text just to achieve this.
18:08:25 <DrMentats> well, it also allows me to use the neat Forall symbol
18:08:30 <erisco> pony endofunctors
18:08:38 <EvanR> ok
18:09:25 <erisco> the crime is using -> instead of →
18:09:39 <pacak> DrMentats: Don't underestimate users :)
18:09:40 <DrMentats> erisco: ah, yes, I just noticed it
18:09:42 <Welkin> what about =>?
18:10:17 <DrMentats> the problem with the right arrows is that they have always had a weird issue with character width
18:10:32 <EvanR> right-arrow.net
18:10:59 <pacak> > let (🐎) = (+)  in 1 🐎 2
18:11:01 <lambdabot>  3
18:11:02 <erisco> I think that is just a font problem
18:11:16 <erisco> mixing and matching fonts, possibly
18:11:20 <DrMentats> EvanR: oh wow, I never knew about that website
18:11:29 <erisco> I don't know all the arcane arts of rendering glyphs
18:11:38 <EvanR> it used to come up first on google when i searched for this
18:12:18 <DrMentats> erisco: I just wonder whether or not I should add a space after it, but then people with the proper font might have too much space
18:12:32 <AaronFriel> jle`: I added a fixed WrappedIx implementation to `Graphted`: https://hackage.haskell.org/package/graphted-0.2.5.1/docs/src/Data-GWrappedIx.html#WrappedIx
18:12:48 <erisco> and thus ASCII lives on
18:13:34 <DrMentats> worst case scenario, I will replace emoji with greek letters because those seem to work fine across the board
18:13:50 <thang1> nice nice
18:14:13 <Welkin> ナイス
18:14:32 <thang1> It's a shame we can't make double width unicode
18:14:42 <Welkin> oh but you can!
18:14:54 <thang1> oh right, nvm
18:14:57 <Welkin> 》
18:15:01 <erisco> and a shame we don't have a vomit combining character
18:15:02 <DrMentats> so I'm assuming by pancak's example that 🐎 is parsed as an operator by haskell? funny
18:15:12 <thang1> That >> character is single width on my font :p
18:15:17 <Welkin> 《～～～》
18:15:23 <EvanR> erm
18:15:37 <Cale> DrMentats: yeah, it's a symbol character
18:15:46 <Welkin> o.o
18:15:47 <thang1> oh man that's ugly as fuck. It renders as single width and the font just pretends the extra empty space isn't there
18:15:48 <EvanR> whether the arrow is single or double is a rendering issue not a unicode issue
18:15:48 <Welkin> that is a horse
18:16:00 <Welkin> 🐎
18:16:02 <Welkin> LOL
18:16:11 <thang1> EvanR: yeah, my font is slightly fucky with unicode, which is funny because it's supposed to be amazing with unicode
18:16:30 <DrMentats> the horse operator
18:16:50 <thang1> This sort of thing is a huge issue with unicode in general. between that and our input issues being fucking married to the standard keyboard, it's no wonder we've never developed better ways of writing things out in programming languages 
18:17:11 <Cale> 🐌
18:17:43 <Welkin> thang1: does this render weird for you? 好像
18:17:48 <EvanR> the great thing about standard keyboards is https://en.wikipedia.org/wiki/Space-cadet_keyboard
18:17:52 <thang1> DrMentats: that's some beautiful unicode choices tho
18:18:15 <ExpHP> ah good, with emoticon operators I can now finally program comfortably on my phone
18:18:18 <DrMentats> https://en.wikipedia.org/wiki/APL_(programming_language) used unusual characters to great effect
18:18:18 <Welkin> thang1: 【《好像》（）】
18:18:22 <thang1> Welkin: http://i.imgur.com/Saxtxuz.jpg
18:18:27 <DrMentats> thang1: lol thank you
18:18:51 <thang1> Welkin: part 2: http://i.imgur.com/6fyI9uL.jpg
18:19:02 <Welkin> is that a carousel horse?
18:19:23 <Welkin> could also be a 草泥马 :D
18:19:29 <pacak> thang1: nice fonts.
18:23:49 <Costar> Why they changed the Monad restriction to Applicative?
18:24:29 <Cale> Costar: Because every Monad ought to be an instance of Applicative *anyway* and it's nice to be able to rely on that.
18:24:49 <Cale> Costar: You can always define  pure = return,  (<*>) = ap
18:24:49 <Costar> Cale: We just need Functor
18:24:55 <Cale> and  fmap = liftM
18:25:12 <Cale> and so there's no excuse to leave out an Applicative instance, really.
18:25:56 <EvanR> if polymorphic code expects an Applicative, and theres a Monad without an Applicative instance, it wont be accepted
18:26:12 <EvanR> which would be annoying because it would work
18:26:12 <Costar> Yeah
18:26:16 <Cale> Or, it wouldn't have been accepted -- but now it will be.
18:26:17 <Costar> I did not noted that
18:26:22 <Costar> since yesterday
18:26:28 <thang1> pacak: it's Pragmata Pro, pretty nice font. Way overpriced if you actually buy it
18:27:01 <thang1> https://github.com/be5invis/Iosevka <-- much better free alternative if you like the look of PP
18:27:29 <Costar> Cale: I don know if I liked that
18:27:33 <EvanR> oh nice
18:27:34 <Costar> im thinking about it
18:27:50 <Costar> im still shocked lol
18:27:52 <DrMentats> I use this one myself https://github.com/tonsky/FiraCode
18:29:02 <Cale> Costar: If you're shocked about that, wait until you find out about Foldable and Traversable being in the Prelude
18:29:08 <Cale> :t foldr
18:29:09 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:29:57 <Costar> Cale: To me, this make more sense. 
18:30:16 <thang1> quick, someone fold a tuple /s
18:30:29 <ZelteHonor> And no. It didn't work. The tool just did not regenate the grammar properly.
18:30:34 <pacak> > length (1,2)
18:30:36 <lambdabot>  1
18:30:54 <thang1> gg no re, haskell == ded language. Literally unusable
18:31:05 <Cale> I actually rather like that result.
18:31:08 <EvanR> just changed everything to iosevka...
18:31:21 <thang1> EvanR: welcome to the enlightenment
18:31:25 <EvanR> hmm
18:31:25 <thang1> how do you likey?
18:31:27 <pacak> Better than php.
18:31:39 <Cale> It's indicative of how we ought to think of pairs: as containers for a single element (the second part), having a label (the first part)
18:31:54 <Cale> > fmap (*10) (1,2)
18:31:56 <lambdabot>  (1,20)
18:31:56 <Costar> pacak: writing in a paper is better than php
18:32:21 <thang1> Is that really how you should be thinking of tuples though?
18:32:39 <Cale> All the instances are consistent with that view.
18:32:44 <Cale> (and have to be)
18:33:27 <Cale> > mapM (\x -> [10*x, 100*x]) ("hello", 1)
18:33:29 <lambdabot>  [("hello",10),("hello",100)]
18:33:36 <EvanR> thang1: i know i can see more now... i think... but my brain is going to have to get used to it
18:34:19 <Cale> This is because the functor in question is (,) e
18:34:25 <thang1> Cale: what are the brackets doing in there?
18:34:34 <Cale> Which brackets?
18:34:40 <Cale> The list?
18:34:48 <thang1> oh I'm stupid, nvm
18:35:08 <thang1> I was seeing a bunch of (,) stuff and then saw [,] and somehow my brain totally forgot that was a list
18:35:45 <EvanR> thang1: can it somehow render -> and arrows in code?
18:35:49 <EvanR> -> as arrows
18:36:24 <thang1> EvanR: it has support for ligatures. However, your editor is in charge of font display, not the font. Fonts have no "knowledge"
18:37:16 <EvanR> well the terminal is in charge of font display ;)
18:37:42 <thang1> True, but the terminal won't know to change -> to arrow unless you tell it to :p
18:37:50 <EvanR> can it be done?
18:38:02 <thang1> sure, I do it in emacs right now
18:38:04 <thang1> http://i.imgur.com/vjKvkMS.png
18:38:24 <DrMentats> if anyone is interested in the follow up, apparently some characters in unicode have "ambiguous width", including the arrows. changing the fallback from "narrow" to "wide" in the gnome-terminal fixed it, but also somehow broke greek letters. sigh.
18:38:34 <EvanR> thang1: i dont see arrows
18:39:05 <thang1> Every single type?
18:39:34 <EvanR> ->
18:39:36 <thang1> They're a single character. I picked large arrows because I don't like tiny ones (my code is normally the size of the font in my terminal)
18:39:48 <EvanR> its clearly hyphen greater than
18:40:17 <EvanR> i want double width non-broken arrows in haskell source code in the terminal!
18:40:32 <EvanR> and \ should be lambda ;)
18:40:36 <thang1> http://i.imgur.com/zw1epo0.png
18:40:46 <thang1> Perfectly possible if your terminal is inside emacs :p
18:41:06 <DrMentats> EvanR: I second the lambda thing
18:41:07 <thang1> Otherwise you'll just have to find a terminal that supports unicode text replacement or pretty printing
18:41:30 <jle`> AaronFriel: nice
18:41:34 <EvanR> i just realized i could scroll to the right of that giant image, but i still see now arrows anywhere
18:41:49 <thang1> oooh sorry, my desktop is 3200x1800 pixels lol
18:42:02 <thang1> The white background code is not mine, that is code I opened up in a web browser to show the difference
18:42:28 <thang1> My last screenshot shows every single symbol I have defined for dynamic text replacement
18:42:50 <EvanR> oh
18:43:08 <thang1> It'll show the replaced symbol when, but will revert to ascii when I place my cursor over the text. Really helpful for LaTeX when I have stuff like \lnot \land \lambda, \epsilon, \Sigma, etc
18:43:21 <AaronFriel> thang1: why not just use a font like Fira code?
18:43:33 <thang1> AaronFriel: I do use a font that supports litagures
18:43:50 <thang1> However just because your font supports something doesn't mean anything happens. You have to tell your text editor to change things for you
18:44:31 <robertkennedy> With Comonads, why does extend flip the inner arrows but not the outer arrow, and how does that generalize?
18:44:33 <thang1> otherwise why would it know to replace forall with ∀ ?
18:44:43 <EvanR> emacs is an interesting OS!
18:45:01 <thang1> EvanR: You can do the same thing in vim too. If anything, vim is even easier because it's had dynamic pretty printing for longer
18:45:15 <EvanR> well, iterm2
18:46:14 <AaronFriel> thang1: http://i.imgur.com/QUznYuL.png
18:46:42 <thang1> https://github.com/enomsg/vim-haskellConcealPlus
18:46:58 <thang1> EvanR: see? voila
18:47:33 <thang1> AaronFriel: what text editor are you using?
18:48:19 <AaronFriel> VS Code
18:48:42 <EvanR> some of that codes too far
18:48:49 <pacak> javascript. Ugh.
18:48:51 <EvanR> showing x for *
18:49:30 <thang1> AaronFriel: VS Code supports ligatures
18:49:36 <AaronFriel> thang1: http://i.imgur.com/kjlDiEW.png
18:49:45 <AaronFriel> Is that a question? yes
18:49:46 <thang1> So your VS Code is simply doing automatically what I did explicitly in my text editor
18:50:01 <EvanR> ah you can disable that
18:50:02 <AaronFriel> yes
18:50:16 <thang1> Emacs doesn't do things magically for you because you ask nicely. It does things for you if you program it into the system. I already showed how I have tons of ligitures enabled in my code :p
18:50:42 <thang1> EvanR: Yes, I can disable any of the symbols and change them however I want to. I can also enable different symbols per language
18:50:47 <MarcelineVQ> it's time like these I wish editor customization was interesting
18:51:13 <thang1> For example, if * is always used as multiplication in Haskell, but alawys used as regex in Pearl, I could customize that accordingly.
18:51:16 <MarcelineVQ> so it'd be easier to participate :>
18:52:10 <thang1> Also, AaronFriel why tf is your 'l' loopy, your 's' cursive, and your 'e' weird?
18:52:20 <AaronFriel> Different fonts
18:52:56 <thang1> ahh. idk, I'm not a fan of cursive r in typed fonts. Some of those look a little much. If it works for you then all's good :p
18:53:00 <DrMentats> I'm interested as well, the italic text seems a bit hard to read but it's pretty nice
18:53:21 <thang1> DrMentats: You can have italic text without using the Lobster font lol
18:53:23 <AaronFriel> It shows up a lot here because there are a lot of types and constructors, in other code you wouldn't see it.
18:54:04 <DrMentats> thang1: I used to enable it on comments, but I don't think I'm using italics at all at the moment. maybe should reconsider.
18:54:37 <thang1> Here's how italics look on my computer: http://i.imgur.com/zw1epo0.png (enabled in the comment "Conversion from ASCII to LaTeX logic symbols"
18:54:38 <thang1> )
18:54:51 <thang1> (way bottom right of the image)
18:55:22 <EvanR> thats the same image over again
18:55:44 <thang1> Yeah I re-linked it so nobody had to dig up the url again. It has italics in there so why not? :p
18:56:00 <EvanR> i didnt see any, this screenshot is so frustrating ;)
18:56:18 <DrMentats> It's on the very bottom, but half of it is cut off lol
18:56:30 <thang1> oh whoops
18:56:40 <thang1> I scrolled down two lines and forgot my screenshot didn't show that
18:57:08 <thang1> http://i.imgur.com/SA0erZw.png better? lol
18:59:31 <EvanR> haha oh geez the @ sign looks hilarious
19:00:42 <Welkin> thang1: lots of unicode for you https://github.com/copumpkin/categories/blob/master/Graphs/GraphMorphism.agda
19:00:44 <kadoban> Hm, that font looks familiar. Is that anonymous pro or one of those?
19:01:12 <EvanR> thats actually pretty light on unicode for agda
19:01:26 <Welkin> I tried various "code" fonts
19:01:31 <ReinH> How many levels of equals symbol are you on?
19:01:42 <Welkin> I still think inconsolata or monaco is good though
19:02:01 <cheshircat> Is there a way to view type family associated types for types in GHCI? Like, if val implements PersistEntity, can I figure out the type of Unique val (in persistent)
19:02:13 <EvanR> i was on monaco just before iosevka
19:02:29 <ReinH> emacs supports ligatures. I use Fira Code. It's great.
19:03:37 <thang1> oooh yisss
19:03:46 <thang1> Agda, I wanna get me some of that
19:04:01 <thang1> kadoban: Pragmata Pro is mine
19:04:16 <kadoban> I like inconsolata, but is very light on glyphs which is sometimes unfortunate. It barely covers like ANSI or whatever it's called.
19:04:25 <kadoban> Hmm, I'll have to cehck that out, it looks fairly nice.
19:04:31 <Welkin> yeah, inconsolata is only ascii
19:04:31 <thang1> renaming 3-bar-equal-sign to 4-bar-equal-sign lol
19:04:51 <EvanR> 1-bar equal sign
19:05:00 <EvanR> 0-bar equal sign, ultimate zen
19:05:04 <thang1> kadoban: it's way too expensive for normal people. Just use Iosevka
19:05:20 <Welkin> I forgot to write an entire program using chinese characters
19:05:52 <Welkin> too bad I still need to prefix the names with a lowercase ascii character in haskell
19:06:02 <kadoban> Ah, it's not free. Too bad. I'll look that one up too.
19:06:18 <thang1> Iosevka is a clone of Pragmata Pro :p
19:06:31 <Welkin> thang1: pragmata pro is 19 euros
19:06:44 <thang1> For all the ligatures and shiny shit it's like 200 iirc
19:06:54 <Welkin> thang1: oh, 199 euros
19:07:07 <kadoban> That looks pretty nice, iosevka
19:07:37 <EvanR> integer math question
19:07:51 <thang1> I like it a lot. I just use Pragmata Pro  because I found it on the internet tbh
19:07:56 <EvanR> when you use div or quot, you get whats effectively the floor of doing the rational division
19:08:01 <EvanR> for positive numbers
19:08:08 <Welkin> I prefer wider fonts
19:08:08 <EvanR> how do you get the ceil?
19:08:12 <Welkin> fatter, rounder ones
19:08:37 <EvanR> without going through actual ceil
19:08:50 <Welkin> dejavu sans mono is good, or whatever it's called
19:09:50 <thang1> EvanR: uhh, probably just gonna have to write your own? I don't think the haskell library has anything standard for that and I've never seen it called anything special
19:10:12 <EvanR> i am doing that... now sort of trying to figure out how
19:11:24 <jchia> I have a question about parsers, e.g. megaparsec or some other commonly-used parser packages. Do do parsers natively have the ability to recursively parse into their own string/text/bytestring results? E.g. if my parsing strategy involves first splitting a line with semicolon as a delimiter expecting a fixed number of fields, and then parsing each field (each field may parsed in a different way), can this parsing strategy be expressed directly in a Parsec so t
19:11:34 <DrMentats> wow, I just got iosevka and it really is amazing
19:11:45 <thang1> DrMentats: it's pretty great innit?
19:11:52 <EvanR> i am impressed so far
19:12:00 <EvanR> @@@ notwithstanding
19:12:42 <DrMentats> thang1: I don't even feel like writing code anymore, I just wanna look at it
19:12:44 <thang1> EvanR: can't you just do rational divison and then take the ceiling? Or are you explicitly trying to avoid taking the ceiling?
19:12:55 <EvanR> it just seemed out of the way
19:13:08 <thang1> lol. Take a look at some Agda or something that makes heavy use of unicode. So pretty
19:13:12 <EvanR> but i see now you can do a divMod check if the remainder is 0, if not add 1 to the quotient
19:13:48 <thang1> Sure. Totally much less out of the way than doing the division and taking a ceiling of either the remainder or the quotient /s
19:15:08 <DrMentats> thang1: I only wish the actual → character had double width in it, but neither iosevka nor fira code solve this problem. oh well, I guess it would look ambiguous otherwise.
19:15:27 <EvanR> the editor and renderer should do it
19:15:34 <thang1> yeah, the editor will do it nicely
19:15:38 <EvanR> we were just talking about that
19:15:47 <EvanR> and when you hover over stuff it shows the raw version
19:15:52 <DrMentats> yes, the ligature works, but I mean the actual unicode thing
19:16:13 <EvanR> iterm2 has an option "when width is ambiguous, use double width"
19:16:28 <thang1> The unicode thing is spaced identically to me in emacs... I did a tiny bit of work to do that, though
19:16:42 <DrMentats> actually, hold on
19:16:47 <thang1> You won't get the arrow the same in the terminal without messing with your terminal though
19:17:31 <DrMentats> yeah, I managed to get a good arrow on my terminal by changing the font to Monospace Regular for the time being
19:17:44 <DrMentats> I mean the unicode arrow, not the ligature of course
19:18:20 <thang1> ah got it
19:18:43 <thang1> the ligature replaces the ascii with the unicode arrow :p
19:19:12 <DrMentats> I'll try dynamically replacing the unicode thing with -> and see if the ligature takes effect then
19:19:24 <DrMentats> then it's the best of both worlds
19:19:56 <EvanR> i kinda do want ÷ for div now...
19:20:02 <EvanR> this is getting addictive
19:20:09 <DrMentats> EvanR: lol
19:20:17 <thang1> hah, rice baby rice
19:21:11 <thang1> Just replaced div :p
19:22:32 <EvanR> `div` ?
19:27:17 <Welkin> what is the best fuzzy-match extension for emacs?
19:27:46 <Welkin> for finding files
19:27:56 <thang1> Welkin: all hail the great helm, destroyer of worlds, obtainer of sex from consenting females
19:28:21 <Welkin> not ido or icicles?
19:28:25 <thang1> (helm can use tons of shit as its backend, I prefer ripgrep because it's awesome)
19:28:53 <thang1> ido is ok, it's more "pure emacs" which means nothing considering this /text editor/ comes with tetris baked in
19:29:12 <thang1> never heard of icicles => it's probably useless
19:29:57 <thang1> Yeah all icicles does is minibuffer completion and cycling
19:30:01 <thang1> helm does /everything/
19:34:00 <EvanR> :44
19:34:02 <EvanR> uhg
19:37:18 <DrMentats> thang1: is there no ligature for <> in iosevka?
19:41:58 <thang1> You can view the entire characterset here: https://be5invis.github.io/Iosevka/specimen.html
19:43:41 <DrMentats> thang1: many of those are not showing up for me at all
19:44:02 <thang1> All of the glyphs are going to be images in the web browser...
19:44:17 <thang1> if it's faint grey, he hasn't implemented it
19:44:23 <DrMentats> oh that's the actual character set, I meant as a ligature
19:44:43 <thang1> DrMentats: what's your text editor?
19:44:51 <DrMentats> thang1: Atom
19:45:14 <DrMentats> but that shouldn't be an issue, Fira Code displayed all of its ligatures properly
19:45:37 <DrMentats> I'm getting ->, ::, and not much else
19:46:11 <DrMentats> i.e. -> and :: use the ligature, >= for example doesn't
19:46:34 <thang1> https://discuss.atom.io/t/new-ligature-font-support-issue/22189 
19:46:37 <thang1> maybe look at that?
19:47:38 <DrMentats> that used to be an issue in older versions, but it should work nowadays
19:47:53 <DrMentats> tried applying that fix nonetheless and the results are the same
19:48:08 <thang1> Weird... no idea why it's not working
19:48:26 <DrMentats> maybe I downloaded the wrong version
19:49:56 <DrMentats> actually I seem to be using the wrong ligation set, no idea how to change it though
19:51:35 <thang1> Hmm, how did you install the font?
19:53:34 <thang1> You're gonna want the XV00 ligature set 
19:55:58 <DrMentats> thang1: yep! XV00 gives me \/ and some others, but I think I'm still missing some
19:57:03 <thang1> weird... Atom should be working with this
19:57:20 <thang1> https://github.com/be5invis/Iosevka/issues/56
19:59:16 <thang1> Also, it seems that <> >>= and a few others aren't done yet in the font
20:01:04 <qmm> is >> pronounced sequence?
20:04:59 <kadoban> Probably not, since 'sequence' is an actual other thing.
20:05:18 <kadoban> If I had to give it a name, it'd just be "and then", though that's not perfect.
20:05:47 <thang1> DrMentats: apparently the font does support >>= but it doesn't support >>, <<, ++, <>, >< 
20:06:40 <EvanR> wait...
20:06:44 <DrMentats> << and >> do get "tighter" here, not sure if that's considered a ligature
20:06:59 <EvanR> if i remove the signature it defaults to Integer even though im using it (in another module though) as Word8
20:07:09 <EvanR> and fails to type check
20:07:34 <thang1> EvanR: is this the compiler or the linter? :p
20:07:42 <EvanR> compiler
20:08:05 <thang1> Weird...
20:08:27 <MarcelineVQ> give it a signature :>
20:08:28 <thang1> I got nothing lol
20:09:00 <thang1> I'm guessing the compiler isn't able to dig deep enough to check that you're using something in another module as Word8
20:11:33 <geekosaur> modules can be compiled separately, so it can't check how you used it in a different module
20:12:09 <geekosaur> (values at least. things that go into the .hi file for inlining can be checked)
20:12:37 <EvanR> yeah yeah
20:12:50 <EvanR> 16 simple color definitions, turns into 32 lines of code ;)
20:12:50 <thang1> So if you inlined the other definition, would that work? hmm...
20:13:07 <EvanR> i was hoping it would be polymorphic
20:13:15 <EvanR> Num a => V3 a
20:13:57 <MarcelineVQ> hmm, you can do something like  colorA,colorB,colorC :: Num a => V3 a  I think
20:14:18 <MarcelineVQ> should save a few lines anyway
20:15:02 <Welkin> better save on character too
20:15:05 <Welkin> those are expensive
20:15:26 <thang1> just do colorA,colorB,...color16 all on one line, comment it saying "fuck polymorphism in its almost-useful ass" and hide it in the bottom of the file in shame
20:16:08 <Welkin> even better if you can pack those colors into a single 32-bit integer
20:16:15 <Welkin> think of all the savings
20:16:31 <dogbits> I've been trying to convert the following function from do notation into monads. Though i'm confused how I'm meant to pass conn into multiple monad execQuery :: String -> [Int] -> IO ()
20:16:31 <dogbits> execQuery query params = do
20:16:32 <dogbits>   conn <- getDb
20:16:32 <dogbits>   stmt <- liftIO $ prepare conn query
20:16:32 <dogbits>   do liftIO $ execute stmt $ map toSql params
20:16:33 <dogbits>   do liftIO $ commit conn
20:16:35 <dogbits>   do liftIO $ disconnect conn
20:16:37 <dogbits>   return ()
20:16:48 <Welkin> dogbits: there is no such things as "convert into monads"
20:17:13 <Welkin> you mean you are trying to desugar do-notation to use explicit bind (>>=)
20:17:15 <EvanR> Welkin: i'm intentionally not trying to optimize this program to see how fast it is
20:17:23 <EvanR> without worrying about crap like that
20:17:50 <Welkin> dogbits: also, don't paste your code in the channel like that, use lpaste instead
20:17:54 <Welkin> @lpaste
20:17:54 <lambdabot> Haskell pastebin: http://lpaste.net/
20:18:33 <Welkin> dogbits: do notation is desugared as follows:
20:18:53 <Welkin> `conn <- getDb` becomes `getDb >>= \conn -> ...`
20:19:09 <Welkin> you just wrapp subsequent lines in lambdas
20:19:54 <Welkin> so the next line becomes: `liftIO (prepare conn query) >>= \stmt -> ...`
20:19:58 <dogbits> oh so wrap the following bindings using a lamda function?
20:20:10 <EvanR> http://codepad.org/VEPQhhkN
20:20:17 <EvanR> enjoy
20:21:00 <thang1> EvanR: beautiful
20:21:18 <EvanR> yes lpaste wasnt responding
20:29:29 <thang1> still a shame we can't make that shorter
20:31:43 <EvanR> well
20:31:53 <EvanR> in the end, type signatures are good
20:32:07 <EvanR> the main gripe i had was having to type them
20:33:43 <EvanR> hehe interesting
20:33:50 <EvanR> screenW, screenH :: Int
20:33:55 <dogbits> when I desugered the function it stopped changing the database is this because of laziness. Sorry for pasting code directly in. http://lpaste.net/355174
20:33:57 <EvanR> (screenW,screenH) = (320,240)
20:34:00 <EvanR> works
20:35:22 <glguy> dogbits: Those appear to be equivalent. Also note that the 3 'do's next to liftIO were redundant in the original
20:36:40 <pacak> As well as liftIOs themselves
20:37:01 <glguy> equivalent assuming 'disconnect conn :: IO ()' which is why you'd be able to omit the 'return ()'
20:37:27 <glguy> OHH
20:37:31 <glguy> no, you have two prepares
20:37:35 <glguy> and no executes
20:38:38 <dogbits> oh shoot 
20:39:55 <qmm> given,  test :: State Int Int  ; test = do { put 3; modify (+1) ; get }  ; print $ execState test 0
20:40:00 <qmm> test returns 4
20:40:25 <qmm> i am confused what the Int Int is the type signature
20:40:33 <qmm> in the type signature
20:40:38 <geekosaur> the first Int is the state, the second is the result
20:41:01 <geekosaur> :t put
20:41:03 <lambdabot> MonadState s m => s -> m ()
20:41:24 <geekosaur> in your example, put :: Int -> State Int ()
20:42:25 <geekosaur> not all State actions have the same result type as the state type
20:43:59 <Welkin> what is the name of the `get` function for State?
20:44:09 <Welkin> it should have type State Int Int in this case
20:44:17 <geekosaur> > let test :: State Int (); test = do { put 3; modify (+1) } in execState test 0
20:44:19 <lambdabot>  4
20:44:45 <geekosaur> you're ignoring the Int result from the final `get` and getting the saved State back instead via execState
20:44:55 <geekosaur> :t get
20:44:56 <lambdabot> MonadState s m => m s
20:45:09 <Welkin> oh, it's just `get`
20:45:41 <EvanR> standard get is part of MonadState the class
20:45:47 <EvanR> which State implements
20:50:26 <thang1> systemd in haskell
20:50:27 <thang1> neat
20:50:36 <Axman6> ...
20:50:39 <EvanR> i dont believe it
20:50:42 <LiaoTao> thang1: Just no
20:50:57 <thang1> https://www.seas.upenn.edu/%7Esweirich/papers/systemd-submission.pdf
20:51:41 <thang1> of course, the d stands for dependent here.... :p
20:52:26 <thang1> But then they actually do make a System D in the paper, which is glorious
20:52:26 * LiaoTao groans
20:53:19 <thang1> They replace FC (haskell's core language) with FC, and then create a System D, which is an   implicitly typed version of DC
20:54:14 <Axman6> don't do these things to me thang1!
20:54:17 <Axman6> :)
20:55:47 <monochrom> Next April 1st, systemd will be rewritten in System D.
20:57:02 <pacak> monochrom: In powerpoint because powerpoint is turing complete.
20:59:27 <robertkennedy> Does every product type allow the sum type to be written inside it? With laziness, it seems like you could construct `P Bool (P a b)` and access it in ways that preserve the invariant. Is there any type which disallows this?
21:00:41 <EvanR> P Bool (P a b), and you use undefined for the one thats not there?
21:01:13 <EvanR> i guess thats a working implementation of the sum type
21:08:52 <EvanR> so supercombinators is a way to compile functional code into low level code
21:08:59 <EvanR> and isnt really used in GHC?
21:10:10 <thang1> lots of neat stuff isn't used in GHC lol. I'm guessing supercombinators aren't used because of type explosion?
21:10:36 <EvanR> i get the impression theres a better way
21:10:53 <Hafydd> I read "so supercomputers is a way to compile functional code into low level code", and thought it was a comment about GHC's performance.
21:11:43 <EvanR> yeah at this rate might have to contract NSA to help build hackage packages
21:13:30 <thang1> hey now, it's not /terrible/
21:13:31 <Hafydd> Contract NASA: they'll accelerate you to a high speed so that by the time you come your code will have compiled, and you will have aged relatively little.
21:14:35 <EvanR> now you have me wondering about the implications of time dilation on computer science problem complexity
21:15:09 <EvanR> using that technique you could accelerate an exponentional problem into linear!
21:15:36 <Hafydd> I'm not sure about that...
21:15:48 <Hafydd> Surely you can only apply a linear factor.
21:16:48 <EvanR> constant acceleration away from the earth, then back
21:17:41 <Hafydd> Oh, yes, maybe it isn't linear, in light (http://i.imgur.com/MDCBTVL.jpg) of that.
21:17:44 <nshepperd> you can orbit around a black hole for a bit
21:18:02 <robertkennedy> No, accelerating makes things compute/age slower.
21:18:19 <LiaoTao> So just accelerate the rest of the universe
21:18:19 <EvanR> you accelerate away and come back, to the computer sitting on the earth running normally
21:18:21 <Hafydd> We're talking about leaving the computer behind.
21:18:22 <LiaoTao> Problem solved
21:18:54 <nshepperd> the problem here is that the rest of civilization will have continued while your code was compiling, so it'll be out of date by the time you get to running it
21:19:01 <robertkennedy> Idk that there's a way to go somewhere and age faster than standing still. Sounds like the opposite of relativity 
21:19:01 <Axman6> but it will get lonely :(
21:19:27 <EvanR> robertkennedy: nothings aging faster here
21:19:39 <nshepperd> well, you can go to orbit instead of being on earth
21:19:55 <nshepperd> then you will run some parts per million faster :)
21:20:48 <thang1> What you really want to do is you want to isolate the computer inside an inverse blackhole event horizon so that it's isolated from the rest of the universe and time dialation works backwards
21:20:50 <robertkennedy> The longest spacetime distance from point a to b is the parabola from throwing it
21:20:50 <EvanR> nshepperd: i wonder if anyone from nasa has used this in a budget meeting to get more money
21:20:56 <thang1> a co-horizon, if you will :p
21:21:04 <EvanR> "space station: computers run faster up there"
21:21:40 <EvanR> robertkennedy: no thats the shortest
21:22:17 <pacak> aeson, let's simplify a bit. Suppose we have a sum type data Value = Number Int | String Str | Null. Suppose you want to write computations like "intMagic (+) a b",  that should return a sum of a and b packed into Number if both a and b are numbers and Null if that's not the case. What kind of abstraction would you use for intMagic?
21:22:20 <robertkennedy> Oh yeah thanks that makes much more sense. 
21:23:17 <EvanR> pacak: a regular function
21:23:28 <thang1> (☞ﾟヮﾟ)☞
21:23:34 <nshepperd> it's neither really. it's the extremum of the spacetime metric which doesn't correspond to proper time in any simple way iirc
21:23:44 <robertkennedy> pacak: parseJSON :: Value -> Maybe Int
21:23:52 <Welkin> thang1: lol wtf
21:24:02 <nshepperd> err
21:24:05 <thang1>  ¯\_(ツ)_/¯
21:24:06 <Welkin> the answer to everything in haskell is: use a function
21:24:22 <nshepperd> no wait it's the same as proper time
21:24:24 <robertkennedy> No nshepperd special relativity isn't voodoo
21:24:42 <EvanR> parabola = GR
21:24:50 <robertkennedy> Yeah
21:25:16 <thang1> GR is pretty standard stuff now, which is great
21:25:24 <pacak> Welkin: It gets really ugly if you want to replace a vector of numbers somewhere deep inside a value with it's sum.
21:25:43 <EvanR> pacak: then you need lenses, or something similar and simpler
21:25:55 <EvanR> and prisms
21:26:41 <pacak> robertkennedy: So basically doing computation inside a Maybe monad and dropping results back into Value... Might work.
21:26:43 <EvanR> field :: Text -> (Value -> Value) -> Object -> Object
21:26:59 <pacak> EvanR: "[{\"foo\":[1,2,3,4,5],\"bar\":2}]"
21:27:15 <pacak> replace "foo" key with 15
21:27:18 <EvanR> ok
21:27:29 <v0latil3> hello, i have an assignment to remove multiple words in a list from a string. I have a function to remove one word from a string, and I am lead to believe that I can use foldl to do this. I do not understand this though, does not foldl only do a function on two items in a list?
21:27:52 <pacak> :t foldl
21:27:53 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:27:58 <pacak> Hmm...
21:28:02 <pacak> :t List.foldl
21:28:03 <lambdabot> error:
21:28:03 <lambdabot>     Not in scope: ‘List.foldl’
21:28:03 <lambdabot>     No module named ‘List’ is imported.
21:28:11 <pacak> @import Data.List
21:28:12 <lambdabot> Unknown command, try @list
21:28:15 <pacak> O_o
21:28:20 <thang1> lol
21:28:23 <thang1> :t L.fold
21:28:25 <lambdabot> error:
21:28:25 <lambdabot>     Not in scope: ‘L.fold’
21:28:25 <lambdabot>     Perhaps you meant one of these:
21:28:27 <thang1> :t L.foldl
21:28:29 <lambdabot> error:
21:28:29 <lambdabot>     Not in scope: ‘L.foldl’
21:28:29 <lambdabot>     Perhaps you meant one of these:
21:28:32 <thang1> ಠ_ಠ
21:28:34 <pacak> Mwahahaha
21:28:44 <robertkennedy> pacak: more, just do the conversion one time. Like `magicPlusInt v1 v2 = (+) <$> parseJSON v1 <*> parseJSON v2`
21:29:12 <pacak> :t foldl :: (b -> a -> b) -> b -> [a] -> b
21:29:14 <lambdabot> (b -> a -> b) -> b -> [a] -> b
21:29:18 <pacak> Ha!
21:29:37 <v0latil3> :t Data.Foldable.foldl
21:29:39 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:29:39 <thang1> pacak: that's stupid
21:29:47 <pacak> :t Data.List.foldl
21:29:49 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:30:08 <pacak> v0latil3: Do you know what a Foldable is?
21:31:05 <v0latil3> pacak: I believe so, but maybe not too well. I don't think I could explain it well
21:31:38 <pacak> robertkennedy: I have a bigass Value and I want to operate on it without knowing what's inside  and  without actually decoding it, result should also be a Value
21:31:41 <pacak> :t filter
21:31:43 <lambdabot> (a -> Bool) -> [a] -> [a]
21:31:44 <robertkennedy> remove badwords s = unwords [word | word <- words s, not (word `elem` badwords)]
21:32:22 <thang1> v0latil3: Foldable means that you can fold over it
21:32:35 <thang1> that is, you can consume something one at a time and eat up the entire data structure
21:32:44 <pacak> :t foldl _ [1..10] [2,5]
21:32:45 <lambdabot> error:
21:32:46 <lambdabot>     • Found hole: _ :: [t] -> Integer -> [t]
21:32:46 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
21:32:46 <v0latil3> mine goes like remWord word str = unwords $ filter ((/=) word) $ words str
21:33:03 <thang1> or, (insert handwaving) it "behaves like a list" when you run fold on it
21:33:14 <pacak> :t foldl (\string badint -> filter (/= badint) string) [1..10] [2,5]
21:33:16 <lambdabot> (Enum a, Num a, Eq a) => [a]
21:33:19 <pacak> foldl (\string badint -> filter (/= badint) string) [1..10] [2,5]
21:33:28 <pacak> > foldl (\string badint -> filter (/= badint) string) [1..10] [2,5]
21:33:30 <lambdabot>  [1,3,4,6,7,8,9,10]
21:33:39 <pacak> v0latil3: Something like this
21:34:16 <robertkennedy> pacak: it's probably small enough to fit in memory, given that aeson has strict structures. Doing something like `sum <$> mapMaybe parseJSON vs` is nice with this abstraction (mapMaybe would filter non ints)
21:34:17 <pacak> (that's not terribly efficient)
21:34:22 <v0latil3> I was trying this - remWords file = foldl (\w _-> remWord w str) ws
21:34:24 <v0latil3>  36     where
21:34:25 <EvanR> pacak: check out lens-aeson
21:34:26 <v0latil3>  37       ws = words $ head $ lines file
21:34:28 <v0latil3>  38       str = unlines $ tail $ lines file
21:34:47 <v0latil3> but the function i gave is wrong for sure
21:34:55 <thang1> v0latil3: don't paste multiline stuff into the IRC. Use the lpaste
21:35:06 <v0latil3> I think I need to change that function and use the 3 parameter foldl
21:35:08 <EvanR> if lpaste is working
21:35:13 <EvanR> if its not, dont use pastebin please
21:35:18 <EvanR> find another
21:35:19 <v0latil3> thang1: sorry I thought 4 lines would be ok
21:35:57 <thang1> It's fine. It's more so you don't get triggered as a spam bot (which any super rapid line enter tends to do)
21:36:22 <thang1> (and also because pasting 4 lines of code over and over fills up the chat way too quickly)
21:36:34 <v0latil3> https://hastebin.com/orimihofep.sm
21:36:48 <robertkennedy> v0latil3: looks like your strategy passes through `words str` many times, yeah?
21:36:53 <pacak> EvanR: I did. It's not that helpful for some reason. Maybe my lens-fu is lacking.
21:37:27 <v0latil3> robertkennedy: it removes the words from the first line of the file from the rest of the file thats what is in the "where"
21:37:32 <EvanR> i havent really groked full lens yet, but the type (b -> b) -> a -> a can go a long way
21:39:28 <robertkennedy> I know it's functionality, I'm observing it's implementation. But I see your error now, I think
21:40:48 <pacak> EvanR: It totally can, but... Say there's _Array :: Prism' Value (Vector Value). How do I use it to say "replace Array with Number sum of it's numbers, replace it with Null if it's not an Array.
21:41:17 <thang1> Also, v0latil3... your remWord function removes all instances of the word from a string
21:41:19 <robertkennedy> v0latil3: your `foldl` function needs three arguments: `foldl f acc xs`. In particular, your acc input needs to be an acceptable output (in case there were no badwords)
21:42:17 <v0latil3> thang1: yeah its supposed to do that!
21:42:29 <thang1> So what's remWords doing?
21:42:46 <v0latil3> removing all the words on the first line of the file from the rest of it
21:42:53 <EvanR> pacak: i honestly dont know how, but I know theres some easy way
21:43:08 <EvanR> classical existence
21:43:09 <thang1> ahh, okay
21:43:28 <thang1> Right now your remWords is taking in one single massive string as the entire file
21:43:30 <robertkennedy> so when you choose foldl, you can fill in some pieces: `remWords file = foldl (\str' word -> _) str badwords`
21:43:43 <v0latil3> thang1: yes
21:44:27 <robertkennedy> But you see, it will loop through the entire file once for every bad word!
21:45:57 <thang1> oooh wow, I think I see what it's doing now
21:46:04 <v0latil3> assignment is to use foldl with my single remword though :/
21:47:01 <robertkennedy> Maybe do `foldr (\word -> if word `elem` badwords then id else (word :)) [] (words str)`. I still think list comprehension was made for this
21:47:39 <thang1> (word :) [] (words str)?
21:47:55 <v0latil3> yeah i dont get how this  application is "foldable"
21:47:59 <Axman6> pacak: want a hand with lens-aeson?
21:48:09 <thang1> Sure that works, but man does it look terrible
21:49:33 <Lokathor> so if a package won't build on a platform, but it cites a LLVM issue as the compile process crashes
21:49:36 <Lokathor> who do i tell
21:49:40 <pacak> Axman6: More like lens-fu in general.
21:49:53 <thang1> you need a function, the accumulation you're returning, and the data structure you're folding
21:50:09 <robertkennedy> thang1: you're missing a crucial parenthesis. The pattern is `if p x then (x:) else id`, which is just filter. 
21:50:14 <pacak> Axman6: How do I use it to say "replace Array with Number sum of it's numbers, replace it with Null if it's not an Array or elements are not numbers"?
21:50:49 <thang1> In my mind, the first thing I think of is I should be operating on a "list" where I apply the function to every thing in it and accumulate the result
21:51:21 <MarcelineVQ> Lokathor: good question, step 1 is to make sure the llvm you have is a compatable version for the ghc you have
21:51:32 <MarcelineVQ> step 2 is ???
21:51:34 <thang1> The function here is to remove the bad words (statically known) per every line. If you have 1 or less lines, return the empty list
21:51:51 <v0latil3> thang1: yeah there is 2 data structures though
21:52:14 <Lokathor> MarcelineVQ, I have GHC 8.0.2 and LLVM 3.7, which i think is the correct match
21:52:27 <Lokathor> i will have it produce the error message again, which will take a bit for it to fail
21:53:32 <robertkennedy> pacak: `toJSON $ parseJSON v >>= fmap sum . mapM parseJSON`
21:53:58 <EvanR> certain first get the Value
21:54:11 <EvanR> but you shouldnt need to continually parseJSON and rewrap it
21:54:15 <EvanR> thats the point of the lenses
21:54:43 <glguy> Lenses aren't really going to help you do this "if array then this, else that" logic
21:54:46 <thang1> ahh I see why my intuition is failing now. You can't operate line by line because remword doesn't take multiple words to remove
21:55:02 <v0latil3> yeah
21:55:11 <thang1> Does it have to accept only one word as input?
21:55:30 <v0latil3> it would be way easier to basically do remwords and filter with a function that checks each word it it is in the badwords list
21:55:53 <EvanR> you can write a lens that acts on an Array of Numbers if thats what it is, or another way if its not
21:55:55 <robertkennedy> Yeah exactly
21:56:07 <EvanR> and combine them with the standard accessors for aeson
21:56:11 <thang1>  ¯\_(ツ)_/¯ chalk it up to stupid professors
21:56:49 <EvanR> i mean, lens-aeson
21:56:59 <v0latil3> thang1: http://i.imgur.com/5EFxyZh.png
21:57:09 <thang1> I dislike programs that are designed to be coded in a weird way in order to expand your brain. Out of the millions of ways to get you to think creatively in haskell, writing a list-comprehension/filtering problem in a foldl isn't a great one :p
21:57:13 <glguy> pacak: You can do this, however: sumOf (values . _Number) :: Value -> Scientific
21:57:33 <glguy> has _Array :: Value -> Bool
21:57:35 <v0latil3> thang1: it isnt super specific with the remword but it needs to use filter and foldl
21:57:35 <v0latil3> yeah lol
21:57:37 <EvanR> foldl???
21:58:02 <thang1> yeah it has to be foldl... 
21:58:20 <thang1> "let's run a strict function on a potentially infinite data structure. What the fuck could go wrong?"
21:58:29 <pacak> http://lpaste.net/355178 - I made this
21:58:33 <EvanR> this seems the totally wrong way to do it
21:58:42 <EvanR> maybe its a challenge question
21:58:55 <thang1> I dislike stupid challenges
21:59:03 <MarcelineVQ> what's the full wording of the exercise
21:59:06 <thang1> filling a swimming pool using a teacup is a challenge, but it teaches you nothing useful
21:59:12 <thang1> http://i.imgur.com/5EFxyZh.png <-- he just posted it
21:59:24 <pacak> robertkennedy: Your version looks like it should work but throws a bunch of type errors for some reason.
21:59:58 <robertkennedy> EvanR: hmmm I can see why in the specific case of `toJSON . fmap sum $ parseJSON v >>= mapM parseJSON` looks promising. Bit every time I look up a lens I feel like that exercise is as difficult as writing the special decoded
22:01:00 <robertkennedy> pacak: sorry, I was using `parseJSON :: Value -> m Value`. You'll want to write a wrapper function, or fromJSON may look, I'll check
22:01:01 <EvanR> robertkennedy: was just saying, probably shouldnt be thinking of json as a string to solve this problem, its a trivial part of the process to separate out
22:01:05 <pacak> glguy: sumOf is nice, but sum is just an example, my goal is to use some statistical operations. Not sure if it's easy to describe them as a monoid
22:01:51 <pacak> robertkennedy: I have a rough idea how to implement it, was curious if there's a better approach.
22:02:37 <asthasr> depends on the statistical operation, right?
22:02:38 <MarcelineVQ> Huh, that's quite odd. Why foldl is even mentioned when this can be done with filter alone :(
22:02:49 <asthasr> arithmetic mean could be described as a monoid, for example
22:03:07 <robertkennedy> EvanR: that's the point of the refactor I'm aiming at: separate parsing the JSON, summing, and encoding, so you can easily change to encoding to SQL or BSON or whatever
22:03:21 <v0latil3> MarcelineVQ: yeah I'm not really sure
22:04:02 <MarcelineVQ> and it reccomends using head, this text is either quite old or misguided, not that that observation is especially helpful
22:04:28 <EvanR> robertkennedy: the point of this exercise is how to manipulate json data
22:04:39 <MarcelineVQ> v0latil3: were you able to cobble something together from the suggestions given so far?
22:04:49 <asthasr> pacak:  https://twdkz.wordpress.com/2013/05/31/data-analysis-with-monoids/
22:06:48 <pacak> asthasr: There's a nice package called statistics that does stuff I want, I just need to figure out how to apply it to parts of a huge json Value I have in memory. Post looks interesting, I'll check it out anyway.
22:07:06 <robertkennedy> :t \v -> (\r -> case r of {Result r -> Number r; Error e -> Null}) . fmap sum $ parseJSON v >>= mapM parseJSON
22:07:07 <lambdabot> error: Not in scope: data constructor ‘Result’
22:07:07 <lambdabot> error:
22:07:07 <lambdabot>     Not in scope: data constructor ‘Error’
22:07:10 <asthasr> pacak: fair enough, just thought you might find it interesting :)
22:07:34 <EvanR> i dont think parseJSON should be involved anywhere in this solution, assume you have a Value
22:08:37 <pacak> EvanR: It can be used, it can for example take Value and return Maybe (Vector Double)
22:10:24 <cocreature> parseJSON is exactly for converting Value to something else so saying that it shouldn’t be involved if you have a Value seems weird
22:10:31 <robertkennedy> Replace parseJSON with fromJSON in there and it type checks a o k
22:10:48 <EvanR> sounds like you want a Prism' Value (Vector Double)
22:11:52 <pacak> EvanR: Hmm... Right.
22:12:07 <EvanR> yeah i misinterpreted robertkennedy parsing strings, not doing json parser monad
22:13:23 <Axman6> pacak: sorry I got pulled away to some work, sounds like what you wanted is possible though
22:13:29 <Lokathor> MarcelineVQ, here we go http://lpaste.net/355179
22:14:22 <glguy> pacak: It would help to have an example of an operation you're trying to apply to the JSON file
22:15:28 <pacak> glguy: [{\"foo\":[1,2,3,4,5],\"bar\":2}]" - perform Operation of type Vector Double -> Value on [1..5]
22:17:08 <pacak> Or replace it with Null (whole result or specifically foo key if it's not a Vector Double
22:17:15 <MarcelineVQ> Lokathor: is this under 64bit windows?
22:17:28 <MarcelineVQ> well sily question I see the pi up there
22:17:32 <Lokathor> MarcelineVQ, this is under Linux on a Raspberry Pi
22:17:55 <Lokathor> "Raspbian", which is debian ARMHF with some funny drivers thrown in basically
22:18:08 <glguy> over (values . key "foo") :: (Value -> Value) -> Value -> Value, this applies a function to the Value [1..5]
22:18:48 <glguy> You'll need to build a Value -> Value next that has the behavior of either applying Vector Double -> Value  or returning Null
22:19:55 <pacak> glguy: Is there a nice way of building such a function? (anything better than http://lpaste.net/355178) ?
22:20:48 <pacak> Alternatively is there a way to compose _Foo :: Prism' Value (Vector Double) ?
22:22:15 <MarcelineVQ> Lokathor: hmm I think you're gonna want to ask in #ghc or the ghc mailing list due to arm being, afaik, a work in progress or there may be some special flag to give to the llvm optomiser on arm arch
22:22:46 <Lokathor> ah, no biggie if it won't run on the pi, that's only for the benchmark stuff anyway. the main lib is fine without aeson
22:23:16 <MarcelineVQ> well it may which is why I'd suggest askin aroundf
22:24:39 <glguy> preview (_Array . below _Number) :: Value -> Maybe (Vector Scientific)
22:24:44 <glguy> (making progress)
22:25:52 <pacak> glguy: There's _Double...
22:26:02 <pacak> _Array . below _Double
22:26:04 <pacak> this works
22:26:09 * pacak goes to read on below
22:26:54 <Axman6> :t below
22:26:55 <lambdabot> (Applicative f, Choice p, Traversable f1) => APrism' s a -> p (f1 a) (f (f1 a)) -> p (f1 s) (f (f1 s))
22:27:05 <MarcelineVQ> Lokathor: ask orion if he got arm working on his pi or if bgamari can point you at a standard build process of some kind
22:27:25 <glguy> pacak: previews (_Array . below _Double) :: (Vector Double -> a) -> Value -> Maybe a
22:27:26 <MarcelineVQ> *ghc working on his pi
22:27:58 <pacak> :t previews
22:28:00 <lambdabot> MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)
22:28:01 <pacak> :t preview
22:28:02 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
22:28:03 <MarcelineVQ> angerman could know what's up too, I think he works on cross-compiling at least
22:28:10 <EvanR> youre trying to run ghc on the pi, or cross compile somehow?
22:28:33 <angerman> wat?
22:29:04 <MarcelineVQ> mm, did I​ mix names up? :>
22:31:34 <MarcelineVQ> does TH work on arm?
22:34:06 <glguy> MarcelineVQ: seems to
22:34:49 <MarcelineVQ> guess it's not that then, seemed likely with aeson
22:34:52 <glguy> It works on my Rpi3 at least
22:36:16 <sophiag> performance question: i was going through a tutorial recently on using rules to implement fusion (i'm trying to get a better understanding for space complexity) and noticed there was no difference in performance when testing with criterion. is this because: a) GHC already does this on its own now? b) optimizations don't work in GHCi, c) it only affects memory usage and not speed, or d) ??
22:36:58 <angerman> MarcelineVQ: yes it does. You can use TH with CC for iOS and Android. Limited though.
22:37:01 <Axman6> possibly the second (actually possibly all). I would only compare performance of compiled code
22:37:12 <nshepperd_> Mostly b, i think
22:37:14 <angerman> MarcelineVQ: and to be fair not all diffs are landed yet. So you'll need to use my custom branch.
22:37:26 <nshepperd_> Isn't ghci interpreted
22:37:27 <pacak> sophiag: Are you compiling with optimizations?
22:37:46 <sophiag> pacak: it seems we've determined it's GHCi
22:37:50 <thang1> GHCI is interpreted, yes
22:38:17 * angerman would call GHCi partially interpreted.
22:38:24 <EvanR> i thought you could run optimized binary code from ghci
22:38:28 <sophiag> but this tutorial was from 2007 so i was wondering whether GHC performed fusion in some cases automagically since then
22:38:54 <angerman> EvanR: yes, -fobject-code. GHCi can load object code, which can be optimized.
22:38:55 <Axman6> yeah GHCi is a bit more compiled than fully interpreted, but doesn't fully compile things IIRC
22:39:51 <angerman> I don't think it will compile anything you provide to it via the repl. However loading modules when available as object code should work, I believe.
22:39:59 <angerman> MarcelineVQ: for whom were you asking anyway?
22:40:50 <MarcelineVQ> angerman: myself and Lokathor, though he seems to have things in a running state it's just also failing halfway through, http://lpaste.net/355179
22:42:09 <angerman> MarcelineVQ: ohh, but that doesn't look like cross compiling. That looks like an arm-ghc (e.g. a cross compiled ghc, not a cross compiling ghc (host -> target, host != target))
22:42:58 <angerman> With the former, I have no experience. All I'm doing is the latter. E.g. cross compiling from x86_64 -> armv7
22:43:23 <EvanR> and that works fine?
22:44:01 <angerman> for iOS and Android, with my patches... and GHCSlaves... I can compile lense just fine :-)
22:44:23 <EvanR> oi
22:44:34 <MarcelineVQ> aha alrighty, I thought maybe you had an idea about it due to the breadth of considerations one needs for cc. sorry to have interrupted you :>
22:44:47 <angerman> I don't have an rPi slave though... more to come on zw3rk's medium page over the next few weeks.
22:45:34 <angerman> (there was a reason, I posted the building libiconv yesterday :D)
22:47:57 <MarcelineVQ> EvanR: who are you asking?
22:48:37 <angerman> EvanR: looking at your crashlog, could it be that your rPi is out of memory during opt?
22:49:21 <EvanR> i do have a raspberry pi and am planning on running haskell programs on it, but i wasnt actually asking about that today
22:49:26 <EvanR> somebody else was
22:49:27 <MarcelineVQ> it's Lokathor's, that's a good thing to check though
22:50:11 <EvanR> i was just curious to what extent all these shenanigans are in working order right now
22:50:21 <EvanR> seems like prospects are good
22:50:56 <angerman> EvanR: https://github.com/zw3rk/ghc-build-scripts/blob/master/build-mobile-ghcs, https://github.com/angerman/ghc/tree/my-ghc
22:51:26 <angerman> EvanR: the latter repo is force-pushed periodically upon rebasing open diffs onto a recent ghc-head.
22:52:15 <angerman> EvanR: you can see the current set of diffs in https://github.com/angerman/ghc/commit/d8ee928d21fb9ca06d982de9ad161da1162b3748; I usually put the D<NNN> number into the branch names.
22:52:16 <EvanR> so thats a fork of ghc to cross compile for phones?
22:52:51 <angerman> it's ghc-head + a few open diffs applied.
22:53:18 <angerman> just for convenience. You could equally well, just pull ghc-head, and then `arc patch` all those diffs atop.
22:54:03 <EvanR> this is the recommended way to compile for pi?
22:54:15 <angerman> EvanR: it's also not just for phones. I'm just testing it on iOS and Android. Raspberry Pi should work fairly well I believe.
22:55:36 <angerman> However if you want TH support, you'd need some form of https://github.com/zw3rk/ghc-slave, which is essnetially just something like https://github.com/zw3rk/ghc-slave/blob/master/iOS/GHCSlave/GHCSlave/main.m (wrapping the iserv-slave).
22:55:40 <Lokathor> angerman, that output is a GHC on a raspberry pi trying to compile for raspberry pi
22:56:00 <angerman> Lokathor: yea, as I said, it looks like it's a cross compiled ghc, not a cross compiling ghc.
22:56:12 <Lokathor> well the GHC came from stack's auto-downloader, so i don't know where the GHC itself was compiled from, i guess
22:56:28 <angerman> Lokathor: and the error looks like opt ran out of memory.
22:56:45 <Lokathor> it also takes ages and ages and ages to error out
22:56:55 <Lokathor> like, more than 10 minutes i think
22:57:02 <EvanR> is it using SD card for swap?
22:57:07 <Lokathor> probably
22:57:11 <Lokathor> let me check
22:57:12 <EvanR> that sounds crazy
22:57:17 * angerman firmly believes that we want cross compilation for low powered and small devices.
22:57:29 <angerman> (which is why I'm trying to improve on that ;-))
22:58:05 <angerman> I consider ghc on my i7 slow already. But ymmv I guess.
22:58:15 <Lokathor> http://lpaste.net/355180
22:58:58 <angerman> if someone wants to try cross compiling to raspberry pi, with the my branch, be my guest, I'll try to help where I can. If someone wants to write a ghc-slave for rpi, I'd also be glad to help :)
22:59:23 <Lokathor> hmm, what if i pay you 35 dollars and you just buy a raspberry pi
22:59:31 <EvanR> whats a ghc-slave
22:59:45 <orion> Lokathor: It's nearly impossible to compile anything on a Raspberry Pi because of its memory constraints.
22:59:58 <thang1> Isn't that something that just automatically builds and runs on a target platform?
23:00:33 <Lokathor> orion, actually i have had only a few things that crash out from OOM in my time poking at haskell on rpi
23:01:26 <orion> Lokathor: I am unable to compile GHC on a RPi.
23:01:54 <angerman> Lokathor: I have a rpi here... not just one :)
23:02:24 <Lokathor> well, first, are you talking about rpi1 or rpi2/3? because the 2 and 3 have a WHOLE gig of ram
23:02:32 <orion> 3
23:02:38 <Lokathor> ah, hmm
23:02:44 <Lokathor> i admit that i've never tried to build GHC itself
23:02:51 <orion> Compiling GHC requires many GB of memory.
23:02:52 <Lokathor> always obtained a provided binary
23:03:07 <angerman> EvanR: ghc-slave, is essentially a wrapper around iserv. ghc can with -fexternal-interpreter compile interpreted code in a secondary process. (Similar to how ghcjs compiles TH via the Out of Process TH solution).
23:03:10 <MarcelineVQ> EvanR, thang1: it's for compiling splices and possibly running alternative rts for a process that needs them, ghci does this currently with -fexternal-interpreter I think
23:03:12 <MarcelineVQ> oop :X
23:03:24 <thang1> ahh okay, yeah that seems pretty advanced :p
23:03:41 <orion> And I can't use a cross-compiled version of GHC because TemplateHaskell is disabled in those versions, which makes GHC basically useless for any real-world projects.
23:03:42 <angerman> EvanR: so effectively you point ghc, to an iserv-proxy, which then transmits the data to a slave on the target machine.
23:03:58 <Lokathor> so, can GHC stop at the LLVM code step? and just dump all that into a file and pass it off to another machine and have the LLVM on that machine finish the compile?
23:04:02 <angerman> orion: I got you covered :p
23:04:07 <Lokathor> (assuming you use the LLVM path)
23:04:24 <angerman> Well theoretically, yes.
23:04:43 <angerman> there is -fkeep-llvm-files and -fkeep-tmp-files I believe.
23:04:56 <angerman> I'm not sure if you can feed them trivially back into ghc though.
23:05:12 <Lokathor> would that reduce the maximum memory needed at once? or does the maxmimum memory use come from LLVM itself?
23:05:23 <orion> angerman: I figured out how to build native ARM binaries on x86_64.
23:05:39 <angerman> orion: :-)
23:05:51 <Lokathor> orion, what do you need template haskell for in your projects?
23:06:14 <orion> Lokathor: I
23:06:26 <orion> Lokathor: TH is required for dependencies of my project.
23:06:37 <angerman> Lokathor: well. I don't know the constraints, but it looks like the `opt` command, which ghc invokes is at issue. And well, ghc might be taking away most of the memory already... but honestly, this is all just guess work.
23:06:55 <angerman> orion: I know there are evil splicer, zeroth appraoches. It's all nasty :)
23:07:37 <thang1> Hmm...
23:07:58 <orion> angerman: I use qemu-user-static and Docker: https://github.com/centromere/ghc-arm
23:08:00 <thang1> Can you just open up your rpi, wire in 16GB of ram temporarily, and then after compiling take the ram out?
23:08:19 <Lokathor> thang1, nope, the firmware can't address RAM above 1gb
23:08:29 <suzu> add 16 gigs of swap?
23:08:39 <angerman> orion: yea, that one works as well, on linux only though.
23:08:45 <thang1> ^ the swap idea sounds great
23:08:45 <Lokathor> the rpi is /actually/ a GPU with a CPU strapped on, rather than the other way around, so it's got a weird memory limit
23:08:58 <monochrom> :)
23:09:00 <thang1> oooh that makes sense
23:09:02 <angerman> orion: I can do: aarch64-none-linux-android-ghc Fib.hs Counter.hs -threaded -outputdir build/arm64-android -stubdir . -fexternal-interpreter -pgmi /Users/angerman/.cabal/bin/iserv-proxy -opti10.0.1.37 -opti5000 :D
23:09:20 <thang1> Either way, I'm thinking that the easiest way to compile GHC on limited hardware is to bypass the hardware limti temporarily :p
23:09:40 <angerman> orion: where Counter.hs uses TH, and Fib.hs defines functions used in splices in Counter.hs :D
23:10:53 <EvanR> cross compiling makes way more sense, sorry people who want to run ghc on an arduino ;)
23:11:59 <thang1> But... what about my pocket calculator?
23:12:22 <Lokathor> rpi does well with Rust and Erlang
23:12:23 <thang1> If I can't run GHC on my TI, how am I supposed to be productive when I procrastinate during math class?
23:12:25 <Lokathor> not haskell :/
23:12:46 <Lokathor> elixir also seems like an interesting prospect
23:13:32 <EvanR> compiling on pi right. but i imagine finished compiled haskell binaries run fine?
23:15:18 <Lokathor> as long as they don't touch the disk :P
23:15:29 <Lokathor> because "disk" is "sd card"
23:15:37 <EvanR> im fine with that
23:15:42 <Lokathor> irc bot or whatever is workable
23:15:44 <EvanR> does the linux avoid that?
23:16:04 <EvanR> id be more worried about linux distro taking liberties with disk
23:16:46 <orion> EvanR: Running a pre-built GHC on the RPi doesn't help with the memory issue.
23:16:47 <Lokathor> it's not too bad. i used it with emacs as a desktop replacement for a few days earlier this year because my main computer's drive burned out
23:17:05 <EvanR> orion: why would you? cross compile
23:17:06 <thang1> with emacs?
23:17:27 <thang1> Did that help you remember why emacs used to stand for Eight Megs And Constantly Swapping? :p
23:17:32 <orion> EvanR: Cross-compiling is useless because the resulting GHC doesn't have TemplateHaskell.
23:17:40 <EvanR> eh?
23:17:49 <EvanR> resulting GHC
23:18:00 <EvanR> cross compile the actual program
23:18:16 <EvanR> i am not interesting in developing or compiling ghc
23:18:17 <orion> You can't cross-compile and use TH at the same time.
23:18:24 <Lokathor> thang1, it wasn't too bad as a rust IDE
23:18:33 <EvanR> are you sure or are we misunderstanding again
23:19:19 <orion> EvanR: I am 100% sure that if GHC is running on x86_64 and it's trying to build an ARM binary, TemplateHaskell will absolutely not work.
23:19:46 <EvanR> thats bad
23:19:57 <cocreature> orion: I am pretty sure angerman is working on fixing that or even has fixed it already :)
23:20:03 <Lokathor> that sounds dumb
23:20:42 <angerman> orion: cocreature is right. TH *will* work via ghc-slave.
23:20:49 <Lokathor> it's all Core when it compiles down, right? the final target being here or there shouldn't affect your ability to get to the "i have a core file" step using TH
23:21:10 <angerman> orion: in fact it *does* work.
23:21:19 <EvanR> right i must be misunderstanding where TH comes into this picture
23:21:30 <EvanR> should be finished way before code gen
23:22:02 <angerman> Though, to be fair, for File IO and Process IO, only embedFile and other one way File IO (host -> target) that uses AddDependentFile through TH does work.
23:22:02 <orion> EvanR: When you use TH, you compile *and run* code during the overall compilation process.
23:22:29 <EvanR> but the running code has to be compiled ?
23:22:37 <EvanR> rather than interpreted
23:23:10 <orion> EvanR: It's explained here: https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/CrossCompilation
23:23:15 <angerman> EvanR: what happens is that you code ses TH splices. These in turn can call arbitrary haskell functions, (which in turn can call C funtions via FFI, or doe all kinds of werid stuff).
23:23:46 <angerman> EvanR: now, a cross compiler can only compile code for the target, thus if you compile the code that the TH splice uses, it ends up being the wrong format. As it can't be executed on the host.
23:24:28 <angerman> EvanR: this then leads to the dilemma where you can't have TH in cross compilers (until quite recently; and not even all patches are in upsteam ghc), so it's likely going to be ghc 8.4, that supports this first.
23:25:41 <angerman> EvanR: Anyway. GHCJS is a cross compiler by nature (compiling to javascript). And ghcjs pioneered the out of process template haskell solution. Which evaluates the splice on the target. (e.g. it ships the libraries to the target, and runs the splice there; then ships the result of the splice back).
23:26:24 <angerman> For some time now we have `-fexternal-interpreter` which allows ghc, to evaluate interpreted code though a separate process. This is called iserv, and was inspired what luite did in ghcjs.
23:27:03 <angerman> End of last year, Shea Levy lifted many of the hardcoded #ifdef GHCI elements from ghc, to allow `-fexternal-interpreter` in stage1 cross compilers.
23:27:57 <angerman> Since sometime in January, I have added linker for aarch46/mach-o, and aarch64/elf, as well as improved the armv7/elf linker. This now allows the GHC runtime to load and link object files for these architectures.
23:28:37 <angerman> That was a necessary building block for an iserv process running on say aarch64/ios, or aarch64/android or armv7/android. (e.g. that's the ghc-slave application).
23:29:07 <v0latil3> so my wifi driver broke apparently
23:29:17 <v0latil3> MarcelineVQ: I couldn't figure anything out
23:29:37 <angerman> Now to compile TH with a stage1 cross compiler (and again let me stress this: not all patches have landed in ghc master yet), you basically tell your ghc, to compile TH splices through iserv (on your target).
23:30:00 <v0latil3> MarcelineVQ: I'm the stupid foldl question guy
23:30:30 <angerman> This means that ghc is sending the compiled object code to the target, and finally a small bytecode snippet for the splice that the iserv process on the target can then execute and run; and send back that result.
23:30:53 <pacak> > foldl (\string badint -> filter (/= badint) string) [1..10] [2,5]
23:30:55 <lambdabot>  [1,3,4,6,7,8,9,10]
23:30:58 <pacak> v0latil3: ^
23:31:04 <pacak> v0latil3: Explain me this plz.
23:31:09 <angerman> And as I mentioned you naturally have issues with Process and File IO. (e.g. embed git hash by calling git...)
23:31:45 <angerman> Because your splice ends up running on the target not on the host. And unless you have git (in this case) and the same source on the target, this does not make much sense.
23:32:05 <v0latil3> pacak: oh I think you said that before I saw the numbers and wasnt paying attention so i thought it was about something else
23:32:06 <angerman> File IO is similar, because your splice is run on a completely different machine, with a different filesystem.
23:32:13 <EvanR> wow this is deep
23:32:31 <pacak> v0latil3: I totally said that before.
23:32:32 <EvanR> i have absolutely no interest in using TH in my project
23:33:06 <angerman> However anything that uses just AST generation (lens, aeson, ...) should work.
23:33:19 <v0latil3> pacak: yeah thats what i mean!
23:33:22 <dysfun>  i read that aeson's TH 'derivation' works faster than the generic one
23:33:26 <EvanR> i looked through the list for obvious libs that cant be used without TH
23:33:37 <EvanR> didnt see any i will need
23:33:45 <EvanR> but im probably not looking hard enough
23:33:49 <pacak> EvanR: lens :)
23:33:54 <EvanR> not using lens
23:34:03 <pacak> EvanR: and recursion-schemes :)
23:34:11 <EvanR> oh recursion-schemes...
23:34:18 <EvanR> single tear
23:34:30 <pacak> My TH code for it finally got in.
23:34:38 <c_wraith> I wonder if there's a no-TH flag for lens..
23:34:55 <glguy> lens doesn't use th
23:35:03 <c_wraith> lens compiles against it, though
23:35:24 <cocreature> I don’t think that matters for cross compilation
23:35:46 <Lokathor> oh hey
23:35:59 <Lokathor> orion, i can build text 1.2.2.1 on my rpi :P
23:36:37 <EvanR> and so it seems clear why people would want to have a ghc on a pi
23:36:54 <EvanR> because the engineering required and not fully done yet to get cross compilation to work
23:36:58 <Lokathor> among the commonly used packages, it's the biggest ram hog of them
23:36:59 <glguy> lens depends on the template-Haskell package but didn't need the extension
23:37:30 <angerman> glguy: makeLenses does though, no? :-)
23:37:42 <c_wraith> yeah, but who doesn't write lenses by hand? :P
23:37:53 <angerman> glguy: and what fun is using lenses without makeLenses? :-)
23:47:24 <Lokathor> i read a thing a while ago
23:47:49 <Lokathor> from a programmer of erlang for like 10 years, and he lamented that nested data structures are too hard to deal with in functional languages
23:47:50 <Guest19237> whats the best language
23:48:03 <Lokathor> Guest19237, Esperanto
23:48:09 <pacak> Guest19237: php
23:48:34 <jle`> context-free
23:48:38 <Guest19237> Lokathor: neniu
23:48:39 <EvanR> erlang and elixir still dont have lenses
23:48:54 <dysfun> algol 60
23:49:12 <Lokathor> Guest19237, jes! kial ne?
23:49:13 <EvanR> and nested data structures are easy in non functional languages?
23:50:02 <dysfun> depends what you call a "functional language"
23:50:23 <dysfun> e.g. it's very easy to manipulate nested data in erlang because pattern matching
23:50:32 <Guest19237> Lokathor: vian vizaĝon
23:50:34 <Lokathor> EvanR, hey i dunno what they think is easy or hard or what they call "functional", but they also suggested just using ETS tables whenever you need
23:50:52 <EvanR> whats ETS tables
23:50:56 <Lokathor> which is the Erlang version of keeping it all in an IORef
23:51:07 <dysfun> ETS is a memory-backed database library
23:51:18 <dysfun> shared between erlang processes
23:51:50 <Lokathor> they're fully imperative
23:52:20 <dysfun> they have immutable data and deal mostly in expressions
23:53:13 <dysfun> i find it interesting, because even though it's immutable data in erlang, you don't get to reason about it with absence of side effects
23:53:45 <Lokathor> well, the interprocess communication is always a side-effectful/imperative thing, and you communicate with your ETS table via such
23:54:47 <dysfun> yeah
23:55:05 <dysfun> but most of my recent few years has been clojure, which i dare to call functional
23:55:50 <dysfun> its idea of immutable data is more like haskell's, just without being *forced* to segregate side effectful code
23:56:26 <dysfun> so when i did some erlang recently, it surprised me to see "oh, this thing that i thought was immutable data is actually sending a message to a process to 'mutate'"
23:56:29 <Lokathor> i think that the enforcement is what gives me confidence to go with it
23:56:57 <Lokathor> rust has an STM package, but then has to say things like "be sure you don't accidentally ever write anything in an atomic block that you can't safely retry later"
23:57:41 <dysfun> clojure has a rather lossy protection in the form of the io! macro (warn if you use something that uses it outside of a transaction)
23:57:52 <dysfun> er inside
23:57:55 <Guest19237> jle`: toys
