00:00:15 <Lokathor> cocreature, only based on the restrictions that a binding would have to follow for another binding to have ended up valid
00:00:47 <Lokathor> halogenandtoast, a function? it seems more like a data to me, no -> in the type and all
00:00:54 <halogenandtoast> undefined :: forall (r :: RuntimeRep). forall (a :: TYPE r).
00:00:54 <halogenandtoast>              HasCallStack => a
00:00:55 <halogenandtoast> undefined =  error "Prelude.undefined"
00:01:05 <halogenandtoast> that's the definition
00:01:07 <cocreature> Lokathor: GHC follows the restrictions just fine. in fact it infers an even more polymorphic type than the restrictions require!
00:01:21 <Lokathor> :P
00:02:29 <halogenandtoast> so um sure, a "data" but it has to return whatever error returns
00:02:31 <halogenandtoast> which is a function
00:02:39 <halogenandtoast> error :: forall (r :: RuntimeRep). forall (a :: TYPE r).
00:02:39 <halogenandtoast>          HasCallStack => [Char] -> a
00:03:09 <Lokathor> but error has been applied to a string already? so you're saying what you get back is still a function?
00:03:46 <halogenandtoast> Lokathor: you know I'm not, I'm failing at semantics.
00:04:16 <halogenandtoast> I'm always bad at semantic jousting.
00:04:24 <Lokathor> well i don't know which it is because there's a lot of forall in there and that usually means dark magic
00:04:43 <Lokathor> for all i know data values are functions within GHC's internals somehow
00:05:17 * halogenandtoast shrugs
00:05:22 <halogenandtoast> I wouldn't know either.
00:06:04 * ski isn't sure what "data values" mean
00:06:33 <Lokathor> Well I was once taught that "values" are classified into either "data" or "functions". That "data" is the term to use for "a non-function value"
00:06:37 <halogenandtoast> ski: I assume the opposite of a thunk
00:06:52 <ski> however, `a' here *could* be instantiated to a type of general shape `... -> ...', and so `undefined' is *potentially* a function
00:07:11 <Lokathor> gha! polymorphism morphs again!
00:07:22 <ski> just like `id' can *potentially* be applied to more than one argument, curriedly
00:07:28 <halogenandtoast> :t flip id
00:07:30 <lambdabot> b -> (b -> c) -> c
00:07:32 <halogenandtoast> bam ^^
00:07:55 <Lokathor> :O
00:07:56 <halogenandtoast> :t flip undefined
00:07:57 <lambdabot> b -> a -> c
00:07:59 <ski> thunk is an implementation detail, not something at the semantic reasoning level
00:08:40 <halogenandtoast> ski: I'll avoid it's use in the context in the future.
00:08:50 <halogenandtoast> s/in the/in this/
00:09:08 <ski> Lokathor : ok, so then `undefined' is potentially a "data value", and potentially a function (but not both at the same time)
00:09:26 <Lokathor> a billion curses upon the type 'a'
00:09:31 <hasnoob> In Real world haskell chapter 3 defines binary tree like this http://lpaste.net/355857 . Chapter 3 Exercise 2 on page 60 says "Define a tree type that has only one constructor, like our Java example. Instead of the Empty constructor, use the Maybe type to refer to a node's children."
00:09:38 <halogenandtoast> Lokathor: but it's elegant and beautiful!
00:09:43 <hasnoob> So I did this
00:09:51 <hasnoob> http://lpaste.net/355856
00:10:19 <Lokathor> halogenandtoast, i'm gonna go implement two nearly-identical functions with similar names instead of being polymorphic
00:10:33 <hasnoob> But it is giving me No instance for (Show (a (Tree a) (Tree a))
00:10:34 <halogenandtoast> thats sounds ダメ
00:10:43 * ski would probably use the term "non-function (value)" rather than "data value", in case they wanted to talk about that
00:11:44 <Lokathor> well however you care to classify String and Int together into one group and putStrLn and (+) in another group is probably fine
00:11:49 <halogenandtoast> hasnoob: why not: Tree (Maybe a) (Maybe a) (Maybe a) as your constructor?
00:11:54 <halogenandtoast> err
00:11:54 <Lokathor> er, individual strings and ints, that is
00:11:59 <ski> hasnoob : you possibly meant `MkTree (Maybe (a,Tree a,Tree a))' ?
00:12:03 <halogenandtoast> Tree (Maybe a) (Tree a) (Tree a)
00:12:24 <halogenandtoast> ski: Where is MkTree coming from?
00:12:43 <ski> data constructor of `Tree', which looked like it was forgotten
00:12:49 <ski> so i just invented a name for it
00:13:18 <ski> hasnoob : you'll need to adapt the definition of `formtree' as well
00:13:30 <halogenandtoast> ski: data Tree a = Maybe( a (Tree a) (Tree a) ) is a syntax error
00:13:36 <ski> exactly
00:14:39 <halogenandtoast> data Tree a = MkTree (Maybe a) (Tree a) (Tree a) or data Tree a = Tree (Maybe a) (Tree a) (Tree a) I assume would work
00:14:44 <ski> hasnoob : what halogenandtoast suggested is another interpretation of what you might have wanted. in this case, the data constructor was named `Tree' (the first `Tree' in the suggestion. the latter two occurances are occurances of the *type* constructor that you're defining)
00:14:59 * ski prefers not naming the data constructor the same as the type constructor
00:15:10 <halogenandtoast> ski: Interesting, why not?
00:15:26 <hasnoob> If I do Tree (Maybe a ) (Maybe a ) (Maybe a) . Wgat will the formtree look like
00:15:51 <halogenandtoast> hasnoob: replace the first Maybe with Tree
00:15:54 <halogenandtoast> in formtree
00:16:07 <ski> hasnoob : yes, but that (your first of those two) is not the same as (not even in bijection to) my suggestion `data Tree a = MkTree (Maybe (a,Tree a,Tree a))'
00:16:08 <halogenandtoast> well hold on your nodes are wrong too
00:16:15 <ski> er, that was to halogenandtoast
00:16:50 <ski> halogenandtoast : why not what ?
00:16:58 <halogenandtoast> ski, true, but why use an n-tuple?
00:17:04 <halogenandtoast> ski: > prefers not naming the data constructor the same as the type constructor
00:17:13 <ski> hasnoob : we should first determine which shape of the tree you want
00:17:46 <hasnoob> Binary tree 
00:17:57 <ski> hasnoob : halogenandtoast is suggesting that you possibly meant a tree node to *maybe* contain an element, and *always* two subtrees
00:18:35 <ski> hasnoob : i was suggesting that you possibly meant a tree to to *maybe* contain : all three of an element, and two subtrees
00:18:46 <ski> these are different suggestions
00:18:51 <hasnoob> Not always two subtree. Child can be empty
00:18:57 <ski> perhaps you in fact had something else in mind ..
00:19:09 <hasnoob> but i have to use Nothing for empty child
00:19:21 <ski> if child is empty, are the two subtrees always lacking as well ?
00:19:55 <hasnoob> I am not following.
00:20:09 <james999> hey sorry to interrupt but you're talking about trees in here
00:20:19 <hasnoob> yes
00:20:24 <james999> is there a way to apply regular expressions to trees?
00:20:28 <james999> or is that not possible to do?
00:20:34 <halogenandtoast> james999: No
00:21:04 <james999> e.g. I was thinking something like an expression that says "match trees with root node "foo" and right grandchild "baz" or something
00:21:09 <halogenandtoast> I mean not with the standard definition
00:21:17 <james999> ok
00:21:17 <ski> halogenandtoast : "not naming the data constructor the same as the type constructor" -- because it tends to lead to confusions for newbies, who aren't yet clear on which syntax positions in `data' and `newtype' declarations are types and type constructors, and which are data constructors, or even aren't clear on what the difference between a data and a type constructor are, confusing the value and type level
00:21:24 <halogenandtoast> DFAs don't handle recursion well.
00:21:40 <james999> is that why you can't write a regular expression which parses a java source file for example?
00:22:07 <halogenandtoast> james999: and a reason you can't write one to parse HTML or XML
00:22:14 <ski> halogenandtoast : and because it's easier to discuss things with other people, if you don't have to insert qualifications like "the data constructor `X'" or "the type constructor `X'" (not that this is always needed)
00:22:38 <ski> james999 : not really, in Haskell
00:22:47 <Axman6> the reason is that Java isn't a "regular" language
00:23:00 <halogenandtoast> ski: I see, yeah I think I had some trouble with that when I was first learning.
00:23:00 <ski> james999 : there are something like regular expressions for trees, though
00:23:06 <james999> yeah i've heard of regular languages before
00:23:31 <Axman6> https://en.wikipedia.org/wiki/Regular_language might be interesting
00:23:53 <ski> (iirc, it was called something like hedges)
00:23:53 <halogenandtoast> hasnoob: btw ignore any of my answers from before, my type has no way to terminate.
00:24:00 <halogenandtoast> I think ski is on the right path.
00:24:09 <ski> hasnoob : sorry for the diversion
00:24:11 <james999> so if I were to do something like that I have to represent a tree myself like (a (b (c d))) and use that to match another tree?
00:24:30 <Axman6> halogenandtoast: not that that's actually a problem in Haskell :)
00:24:43 <halogenandtoast> Axman6: I had no way to construct one...
00:24:50 <Axman6> sure you did
00:24:52 * ski thinks james999 needs to be less vague, in order for people to understand the desired goal
00:25:24 <james999> well my intended use case was java source files if that's helpful
00:25:26 <halogenandtoast> Axman6: okay, I might be derping, it happens. Am I missing some haskelly goodness
00:25:32 <Axman6> mkTree n = Tree (Just n) (mkTree (2*n) (mkTree (2*n+1))
00:25:51 <Axman6> uh, MkTree as the constructor
00:26:00 <halogenandtoast> lol sure
00:26:02 <halogenandtoast> I see
00:26:09 <Lokathor> halogenandtoast, okay it turns out i was a lot closer than i thought when i said that i was going to make two funcs that were nearly identical
00:26:17 <ski> hasnoob : with my definition, a tree can either (a) be empty (`Nothing'), or (b) containing an element (`a'), a subtree (`Tree a'), and another subtree (`Tree a')
00:26:54 <halogenandtoast> james999: I wouldn't touch a java source file with a regular expression
00:27:09 <halogenandtoast> just write a recursive descent parser or something like that.
00:27:10 <Axman6> jhrcek: sounds like you want a parser...
00:27:13 <james999> so something like "verify this java file contains 1 class with 2 function definitions and the first function has 1 if statement".
00:27:21 <ski> hasnoob : it's easy to change the definition so that in the (b) case, the element can possibly be missing (`Maybe a'), without touching the two subtrees there (which might still, each of them, recursively, be the empty tree (a))
00:27:21 <Axman6> writing a parser for Java will not be a trivial exercise though
00:27:26 <hasnoob> Ski : data Tree a = Tree Maybe( a  (Tree a) (Tree a) )  deriving (Show) .  This is your definition right? 
00:27:36 <james999> yeah i just thought there'd already be a fancy gadget for that like 
00:27:40 <james999> "hedges"
00:28:00 <Axman6> hasnoob: no, tht's not really valid
00:28:09 <ski> hasnoob : no, i think halogenandtoast wrote that (and it's still a type error, need to be corrected in order to make any sense)
00:28:11 <Axman6> (well, it might actually be, but it's not what you want)
00:28:31 <halogenandtoast> ski: I didn't write that, I copied his definition and said it was an error
00:28:37 <Axman6> hasnoob: MkTree (Maybe (a, Tree a, Tree a))
00:28:49 <ski> hasnoob : my definition was `data Tree a = MkTree (Maybe (a,Tree a,Tree a)) deriving Show', which was what i was interpreting (perhaps incorrectly) you as wanting
00:28:54 <hasnoob> ok
00:29:01 <james999> Axman6: sure, i wanted to make it a small exercise. really i guess i ask how to represent the AST to be checked in a file or text
00:29:17 <ski> halogenandtoast : hasnoob didn't write the `Tree' right after the `=' there
00:29:21 <ertes-w> Axman6: for languages like C and java you would typically use a parser generator, so it's not even that bad
00:29:49 <Axman6> we have better tools than parser generators IMO
00:30:03 <hasnoob> ski: Yes i didn't wrote value constructor and that was also an error
00:30:54 <ski> halogenandtoast : or, they didn't do it before. i suppose they actually added that `Tree' in there just now. sorry for misremembering what you actually said
00:31:11 <james999> The best I can think of is to take in a skeleton, e.g. a string "class A { function B {} function C {} }" and then parse that and also the input file
00:31:23 <james999> but that seemed too simplistic, idk
00:31:27 <halogenandtoast> ski: It's okay, I just didn't want my name attached to that somewhere on the internet :p
00:31:49 <ski> no worry. i stand corrected
00:32:30 <halogenandtoast> james999: with infinite time, I would write something that generated an AST for a java program and use the visitor pattern to do my checks.
00:32:46 <halogenandtoast> but that's the OO programmer in me.
00:33:02 <james999> I can never remember how to code the visitor pattern either without looking it up
00:33:12 <halogenandtoast> Oh that's really easy
00:33:18 <Axman6> we have better tools than the visitor pattern... 
00:33:22 <halogenandtoast> pass in a generator, call the corresponding visit function
00:33:32 <ab9rf> heh
00:33:43 <james999> right. and the class you make has to have the function to take in the generator
00:33:46 <halogenandtoast> Axman6: Yeah in Haskell I'd probably use the Free monad (but I'm dumb and crazy)
00:33:56 <Axman6> the visitor pattern is a hacky way to do what we do do all the time, traverse data
00:34:28 <james999> This matching of ASTs might be simpler in haskell lol
00:34:40 <halogenandtoast> I've used it in OO a few times. Don't feel like it's that bad there.
00:34:41 <james999> really it's just checking if one AST is equal to a subtree of another
00:35:40 <halogenandtoast> james999: Axman6 keeps implying there's some great tool for this problem.
00:35:46 <halogenandtoast> I really want to know what it is :p
00:36:07 <halogenandtoast> Mechanical Turk seems like a valid tool to me.
00:36:13 <Axman6> the "tool" is functional programming :\
00:36:15 <ab9rf> the visitor pattern is how java solves the expression problem. haskell solves it in the opposite direction.
00:36:36 <james999> ab9rf: the more i think about the expression problem the less sense it makes to me
00:36:47 <halogenandtoast> ab9rf: java... and other OOP languages :p I haven't touched Java since highschool.
00:37:21 <ab9rf> halogenandtoast: yeah pretty much
00:37:29 <halogenandtoast> anyways how does one solve it in the opposite direction?
00:37:41 <halogenandtoast> I'm intersted in this.
00:37:48 <halogenandtoast> *interested
00:37:50 <Axman6> classy lenses/prisms offer some nice ways to deal with the expression problem
00:38:06 <ab9rf> halogenandtoast: http://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/ may or may not help
00:38:19 <halogenandtoast> I'm 70% of the way to understading lenses and 30% of the way to understanding Prisms.
00:38:23 <ab9rf> i still need to make more sense out of lenses
00:38:31 <halogenandtoast> So if I add those together I understand them 100%
00:39:09 <halogenandtoast> ab9rf: thanks for the link. I'll read it soon.
00:39:39 <ab9rf> halogenandtoast: the general term for this is the "expression problem" and it's not new to haskell or to java
00:40:20 <halogenandtoast> Oh when they say "expression problem" they literally just mean expression as in the language construct.
00:40:38 <halogenandtoast> I've written a lot of interpreters... never named this problem.
00:40:44 <tdammers> parser generators have a place
00:41:01 <tdammers> but in languages where they are popular, they are overused
00:41:36 <tdammers> "I need a parser" -> lex, yacc, done
00:41:45 <halogenandtoast> tdammers: that's my usual method
00:41:54 <halogenandtoast> or rexical, racc, done
00:42:04 <tdammers> problem is, lex/yacc code is hard to maintain
00:42:18 <ab9rf> tdammers: very much so, indeed
00:42:22 <ab9rf> and extremely hard to refactor
00:42:53 <tdammers> in Haskell, the all-else-being-equal approach is "I need a parser" -> {mega,atto}parsec, done
00:44:11 <tdammers> most parsers are not performance bottlenecks, but they are maintainability bottlenecks
00:44:25 <tdammers> so it makes sense to optimize parser code for readability and refactorability
00:44:35 <ab9rf> the exception being some attoparsec parsers, but the people who write those know what they're doing
00:44:49 <tdammers> and parser-combinator style recursive-descent parsers are great for that, especially in a typed language like Haskell
00:45:03 <james999> ok i'll write a rdp then
00:45:18 <james999> also completely different to this but is haskell a good lang to learn concurrency in?
00:45:27 <james999> i typed in concurrency on amazon and got java books
00:45:32 <ab9rf> concurrency is so much eaiser in haskell than most other languages
00:45:58 <james999> hmm. maybe i should rephrase that. will learning it in haskell help in learning it in other langs?
00:46:17 <tdammers> yes, no, it depends
00:46:17 <ab9rf> well, it may help you to undertsand the theoretical limits of concurrency
00:46:27 <Axman6> Haskell is one of the besty languages to learn concurrency IMO, but it eon't really help you with other languages because they don't offer as good tools
00:46:30 <tdammers> Haskell has pretty solid concurrency primitives, and good abstractions
00:46:34 <Axman6> brst*
00:46:35 <ab9rf> it won't help yhou deal with the limitations of other languages' implementations of concurrency management
00:46:49 <james999> hmm ok
00:46:54 <ab9rf> very few languages have good concurrency abstractions
00:47:05 <tdammers> many of them depend on compiler-enforced purity though, so you can't naively port these ideas to other languages as-is
00:47:08 <ab9rf> it's fairly hard to deadlock haskell, for example
00:47:14 <james999> odd considering the plethora of multi core processors that exist now
00:47:18 <tdammers> but the general approaches are good, and work elsewhere too
00:47:28 <ab9rf> you can do it, but you have to work at it
00:47:29 <james999> is Go among them ab9rf?
00:47:30 <tdammers> well, concurrency is hard
00:47:33 <Axman6> james999: http://chimera.labs.oreilly.com/books/1230000000929/index.html is available for free, and it's an excellent, short book on the subject by one of the main developers of most of the concurrency and parallelism features in Haskell
00:47:38 <ab9rf> james999: can't say, haven't used go
00:47:56 <james999> Axman6: actually that book is why i'm asking the question. :)
00:48:07 <Axman6> go read it, don't even think about it
00:48:09 <james999> since haskell and java seem the easiest (read cheapest) ways to learn it
00:48:11 <Axman6> go!
00:48:17 <ab9rf> concurrency is fundamentally hard, and while it's easier in haskell it's not easy
00:48:29 <ab9rf> java concurrency is ... punitive
00:48:34 <tdammers> java kind of pioneered concurrency / parallelism primitives built into the language
00:48:38 <ski> @let data ListVisitor a o = LV {visitNil :: o,visitCons :: a -> [a] -> o}
00:48:40 <lambdabot>  Defined.
00:48:47 <ab9rf> tdammers: are they stil buggy?
00:48:59 <ski> @let acceptList :: [a] -> ListVisitor a o -> o; acceptList [] vis = visitNil vis; acceptList (a:as) vis = visitCons vis a as
00:49:01 <lambdabot>  Defined.
00:49:11 <ab9rf> i know the first two tries at concurrency primitives in java were profoundly defective
00:49:12 <ski> @let sumVisitor :: Num n => ListVisitor n n; sumVisitor = LV {visitNil = 0,visitCons = \n ns -> n + acceptList ns sumVisitor}
00:49:13 <lambdabot>  Defined.
00:49:33 <ski> > acceptList [2,3,5,7] sumVisitor  -- Visitor Pattern in Haskell, oh my !
00:49:35 <lambdabot>  17
00:49:40 <ab9rf> heh
00:49:43 <ski> halogenandtoast,Axman6 ^
00:49:52 <sternmull> the go programming language is also nice for concurrency. Unfortunately its not very nice in general for my taste.
00:50:05 <ab9rf> the visitor pattern is, in haskell, a solution in search of a problem
00:50:58 <Lokathor> james999, I'll add that rust has a very good concurrency story, while being closer in many ways to Java. However, like with Haskell, learning Rust concurrency will mostly teach you that Java's concurrency is dangerous and unfun
00:51:08 <james999> sternmull: the entire Go wikipedia page is basically saying "We wanted to make this language nice and fix all the problems of C++" lol
00:51:30 <tdammers> doesn't Go roughly pull the same trick as JavaScript wrt concurrency? that is, run everything as coroutines on a single thread?
00:51:32 <james999> Lokathor:noted
00:52:21 <ertes-w> sternmull: is it?  go has coroutines more than proper concurrency like in erlang and haskell
00:52:28 <Axman6> james999: Go is what you get when you actively decide "I want to invent a new language, but completely ignore the last 40 years of programming language research... but add CSP"
00:52:35 <Axman6> they don't even have generics FFS
00:52:41 <Lokathor> Go 2.0 might :P
00:52:48 <Axman6> "Just use interface {}, it'll be fine"
00:53:01 <james999> the wiki article says repeatedly it will have generics. maybe. possibly. in the future
00:53:28 <ski> halogenandtoast : "implying there's some great tool for this problem" -- namely pattern-matching
00:53:30 <Lokathor> james999, Erlang (or Elixir if you like, same VM) is a top grade concurrency-capable language
00:53:45 <james999> also define research. real-world experience would be more valuable in this kind of matter i think
00:53:48 <sternmull> ertes-w: The channels in go make communication between threads very nice. Also the threads are lightweight (as in haskell). So i would say concurrency is a strength of go.
00:53:48 <Lokathor> but Erlang is, as far as I understand it, kinda mostly suited to server types of things
00:53:58 <ertes-w> sternmull: and it seems to be self-aware in that regard, because it calls its "threads" "goroutines" =)
00:54:21 <Axman6> james999: they've ignored really dumb things, there's nothing new or interesting in the language, and it barely makes any efforts to make programming any safer
00:54:44 <Axman6> what it has going for it is good libraries for specific areas, like web services
00:55:01 <james999> so in other words like java at first. not that amazing but has great libraries
00:55:02 <ertes-w> sternmull: i consider concurrency "proper", if it's bound to a form of I/O scheduler…  does go have that?  in other words: would you create one thread for every network client and use semantically blocking calls?
00:55:02 <Lokathor> ab9rf, visitor pattern in Haskell would let you make a python style print command, for one (it looks like at least)
00:55:03 <Axman6> it's just a frustrating language, which won't teach you anything interesting
00:55:18 <ertes-w> sternmull: or do you need an explicit I/O goroutine?
00:55:19 <Axman6> james999: I would take Java any day over Go TBH
00:56:31 <james999> yes Axman6 I would as well, but for the simple reason of the libraries. so not necessarily saying something inherent to the language
00:56:37 <Lokathor> ertes-w, from what i know of Go, it's more like the first thing you suggest. "one handler thread per connection"
00:56:38 <sternmull> ertes-w: In go you create one goroutine per "request" an things like that. Thats specifically what they are meant to be used for. And yes, then you use blocking calls inside of them.
00:57:16 <ertes-w> ok, i could live with that
00:57:17 <Axman6> sternmull: the problem with channels is that they are the only mechanism of communication between goroutines, which leads to convoluted hacks when you want to do something that isn't well modeled by them. 
00:57:45 <ertes-w> (or course i still can't live with most of the other language features of go, like its lack for parametric polymorphism)
00:58:25 <Axman6> ertes-w: but it does have polymorphism, including parametric polymorphism... as long as you only use the map type
00:58:30 <Axman6> (or interface {})
00:58:37 <ab9rf> heh
00:58:48 <ertes-w> you mean like C has parametric polymorphism, if you use (void *)?
00:58:54 <sternmull> Axman6: Maybe, i am no Go expert. I just tried Go for a little project to see how it fits. I liked the concurrency and missed lots of other stuff. So decided against ist.
00:58:57 <Axman6> yeah, that's the latter
00:59:04 <Lokathor> ertes-w, rust does NOT do the "thread per connection" style by default. Though you use this crazy (and somewhat immature) async IO library to (in haskell terms) build up a crazy IO action that the tokio library then manages the exection of for you.
00:59:25 <Axman6> sternmull: have you used much concurrency in Haskell? IMO it is vastly superior, in basically every way
01:00:17 <Lokathor> sternmull, when you start to mix withAsync and the STM library in Haskell you've got a delicious program in the making
01:01:50 <sternmull> Axman6: I had a look at it and played a little bit with it. It is nice and the async package is very helpful. One thing that i diskliked where that channels in Haskell are difficult to set up a 1:1 connection because they broadcast to all ends.
01:01:59 <james999> yeah ertes, I thought when I read the article that a lot of the stuff Go does you could just as well do in C
01:02:37 <Lokathor> sternmull, https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TQueue.html ?
01:02:42 <Axman6> sternmull: not sure what you mean, only one process can take a value off the front of a channel, unless you've used dupChan
01:02:44 <Lokathor> or do you mean having specific in and out sides?
01:03:41 <halogenandtoast> ski: Thanks for taking the time to write that out
01:03:49 <halogenandtoast> I will try out the visitor pattern for lols
01:04:06 <sternmull> i don't remember exactly what i used. But i wanted 1:1 communication between a producer and consumer thread. The problem was that i had to close the read-side in the producer to avoid leaks.
01:04:15 <reynir> is an 'everything monad' a common uh word?
01:04:39 <Axman6> reynir: given I have no idea what you mean, I'm going to say no :P
01:04:52 <Lokathor> sounds like 2 words
01:05:25 <Axman6> that too
01:05:48 <Lokathor> sternmull, that does sound like a problem i guess
01:06:49 <Lokathor> once the producer thread ends and drops the TChan, and the consumer ends and drops the TChan, the memory is picked up. If one side goes on without dropping their end the channel stays there, yeah
01:07:28 <Axman6> that's the nature or garbage collection though... if anything holds a reference to something it is still "live"
01:07:38 <mivael_> :t (*2)
01:07:39 <lambdabot> Num a => a -> a
01:07:43 <mivael_> > (*2)
01:07:44 <lambdabot>  <Integer -> Integer>
01:07:52 <mivael_> hmm... why Integer?
01:07:58 <Axman6> defaulting
01:08:30 <Axman6> also, the fact that that works is pretty much a hack
01:08:52 <sternmull> Lokathor: No that wasn't what i meant. It was that the produced values where echoed to the producer and is was not so obvious how to stop that.
01:09:22 <Lokathor> ah, well just don't read from the channel you're writing to?
01:09:28 <Axman6> sternmull: why was the producer reading from the channel? o.O
01:09:55 <sternmull> i think there was an example that had this problem... lets see if i can find it.
01:10:40 <reynir> Axman6: OK, I saw it on twitter
01:11:01 <ski> halogenandtoast : hopefully it should be clear how to apply to other data types. btw, `maybe' and `either' basically are `accept' implementations for `Maybe' and `Either', with the visitor unboxed (separated over multiple arguments, rather than being combined into a single thing of its own)
01:12:16 <ertes-w> i don't know much about go concurrency, but i know how advanced haskell's is…  even clojure's concurrency felt primitive to me, and that one has many of the surface features of haskell's concurrency like preemptiveness, STM, etc.
01:12:41 <ertes-w> i doubt that i would find go's concurrency very interesting
01:12:53 <sternmull> Lokathor, Axman6: This is what i was thinking about: https://wiki.haskell.org/Implement_a_chat_server#Cleanups_and_final_code
01:15:02 <sternmull> ertes-w: If you compare Go to Python, Java and C++ then its concurrency can be the better choice for some types of applications.
01:15:05 <Lokathor> sternmull, it's a little late for me to go into it, but almost none of that is how I'd do concurrency in Haskell >_<
01:15:11 <ski> halogenandtoast : btw, note that it's a small step from `data ListVisitor a o = LV {visitNil :: o,visitCons :: a -> [a] -> o}' to `data ListFrequenter a o = LF {frequentNil :: o,frequentCons :: a -> o -> o}' (i just made up the term "frequent" here), where the corresponding (recursive !) `inviteList :: [a] -> ListFrequenter a o -> o' now corresponds to a fold (/ catamorphism), in this case `foldr'
01:15:29 <Axman6> yeah that looks like pretty old code
01:15:42 <sternmull> Lokathor: Oh, ok. This was the example that i used when i had a first look at concurrency in haskell.
01:16:03 <Lokathor> sternmull, try this book (free to read on the website) http://chimera.labs.oreilly.com/books/1230000000929/index.html
01:16:26 <cocreature> that book is awesome
01:16:30 <ski> halogenandtoast : with `a -> [a] -> o -> o' instead of `a -> o -> o', it'd correspond to a paramorphism, where one has direct access both to the tail itself, and the recursive result resulting from looping/recurring over the tail
01:16:35 <Axman6> the wiki isn't exactly a very up to date resource for learning... pretty much anything to do with Haskell
01:16:57 <sternmull> Lokathor: Thank you! Will use that the next time i do parallel stuff.
01:18:22 <cocreature> sternmull: even if you don’t do parallel stuff, the sections on exceptions in Haskell are worth a read
01:19:26 <Axman6> yeah, that book should be considered essential reading for the beginner-intermediate haskeller
01:22:48 <sternmull> a completely different question: I am about to read many lines with values from a textfile using megaparsec. What is the recommended way to efficiently store that values? List would waste a lot of space and would store them in the reverse order. I see sequence and dlists as possible candidates.
01:24:37 <Lokathor> https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-IO.html probably what you want
01:24:54 <Axman6> would only reverse the order if you add them to the list as you do... see traverse parse . lines
01:26:46 <sternmull> is there no way to efficiently construct a sequence of values from megaparsec parsers?
01:27:21 <Axman6> that's what I just showed you :\
01:27:55 <Axman6> assuming you have a parser for a single line, traverse parserOfOneLine . lines will give you String -> Parser [Value]
01:28:18 <Axman6> um, maybe
01:28:19 <sternmull> Axman6: Oh! That sound nice.
01:29:40 <mbrock> with Brick, is there some way to merge adjacent borders, using ASCII art and stuff for corners and intersections?
01:33:26 <Axman6> can you set one of the borders to no border?
01:33:36 <Axman6> IIRC you had quite a lot of control over borders in Brick
01:33:43 <Geekingfrog> Is there a way to store on disk (almost) any data structure? A bit like python's pickles ?
01:34:28 <Lokathor> Geekingfrog, https://hackage.haskell.org/package/cereal-0.5.4.0/docs/Data-Serialize.html ?
01:36:11 <Axman6> also, GHC 8.2 will introduce compact regions, which will basically allow you to serialise any haskell structure, as long as it contains no mutable references anywhere inside it
01:36:13 <Geekingfrog> Looks perfect for me, thanks
01:36:26 <Geekingfrog> Data.Serialize fits the bill nicely for me
01:36:33 <Axman6> cerial/binary are quite good though
01:36:45 <Axman6> I would probably opt for binary, it has wider support IIRC
01:37:13 <Axman6> (the main difference between the two is one targets lazy bytestrings, the other strict
01:40:23 <Geekingfrog> No instance for (Serialize Text) /o\
01:41:20 <peddie> Geekingfrog: https://hackage.haskell.org/package/cereal-text
01:43:30 <Axman6> you could also encode it to UTF-8 and serialise the bytestring
01:43:38 <Axman6> (which is probably what that package does)
01:44:17 <ertes-w> sternmull: sure, but there is no reason for me to compare it ot python, java or C++
01:44:41 <ertes-w> if i use language A, which is better than B and C, why would i care if B is better than C? ;)
01:45:41 <ertes-w> sternmull: also i would probably choose C++ over go anyway, because parametric polymorphism is valuable to me
01:46:01 <sternmull> true. But when you encounter a problem where language A is no longer a good fit then you have to pick the least evil of the others. And then you start comparing them :)
01:46:09 * hackage servant-auth-client 0.2.7.1, servant-auth-server 0.2.8.0 (phadej): https://qbin.io/qd7xtc1y
01:49:01 <james999> hmm clojure also has concurrency stuff in it
01:49:19 <james999> but idk if it counts as doing java concurrency though. prob not
01:50:08 <Axman6> IIRC clojure has STM, but it suffers from the same problem STM implementations in nearly all non-Haskell languages do - no way to controlling IO inside transactions
01:52:28 <ertes-w> clojure's STM is vastly inferior to haskell's
01:52:46 <halogenandtoast> I wish I had a project to work on that needed something like STM
01:52:48 <ertes-w> all it does is give you memory atomicity
01:52:59 <halogenandtoast> I spend all day not knowing want to make in Haskell
01:53:33 <srhb> halogenandtoast: I want a very fast proxy server, so if you want to do concurrency, there's that! :-)
01:53:35 <ertes-w> in particular it does not have the 'orElse' monoid (the Alternative instance of haskell's STM)
01:54:03 <ertes-w> halogenandtoast: feel free to take inspiration from my 'progress-meter' library =)
01:54:14 <ertes-w> halogenandtoast: https://hackage.haskell.org/package/progress-meter
01:54:40 <halogenandtoast> srhb: I'd be happy to work "with" you
01:54:56 <ertes-w> halogenandtoast: even just waiting for two 'async' threads at the same time is a legitimate use case for STM
01:55:07 <halogenandtoast> ertes-w: I'll check it out.
01:55:21 <ertes-w> and ironically a use case that clojure's STM can't handle =)
01:55:21 <halogenandtoast> I basically never have any async code to write.
01:55:22 <srhb> halogenandtoast: Could be fun. I'll poke you if I ever get started. :-P
01:55:41 <halogenandtoast> srhb: awesome. I'm halogenandtoast everywhere if you ever want to track me down
01:55:44 <halogenandtoast> in case I'm not on IRC
01:55:57 <ertes-w> halogenandtoast: it's one of those abstractions that you really never miss, until you use it once
01:55:59 <james999> did that book Axman6 told me to read earlier mention STM in haskell?
01:56:27 <Axman6> yes
01:56:32 <ertes-w> james999: in detail
01:57:32 <ertes-w> james999: The Book covers a lot of ground on concurrency/parallelism in haskell…  IMO every haskell programmer should read it at some point
01:58:16 <halogenandtoast> Which book was it?
01:59:22 <ertes-w> halogenandtoast: http://chimera.labs.oreilly.com/books/1230000000929/
01:59:56 <halogenandtoast> Ah yeah, that book. I was in the process of reading it.
02:00:06 <halogenandtoast> Among a number of other Haskell books.
02:00:20 <james999> halogenandtoast: will reading multiple Haskell books make you rich?
02:00:31 <ertes-w> (and please stop linking to the table of contents!  it's disrespectful to simon, because it hides the "buy" option!)
02:00:56 <halogenandtoast> james999: no, I don't think Haskell will make me rich any time soon.
02:01:01 <halogenandtoast> So far ruby is doing a decent job.
02:01:09 * hackage fastparser 0.3.0 - A fast, but bare bones, bytestring parser combinators library.  https://hackage.haskell.org/package/fastparser-0.3.0 (SimonMarechal)
02:01:12 <james999> hah
02:01:13 <halogenandtoast> But the only Haskell opportunity Ive seen is a huge step down.
02:01:32 <halogenandtoast> There aren't a lot of opportunities here in Tokyo.
02:01:59 <vaibhavsagar> halogenandtoast: http://www.tsurucapital.com/en/jobs.html?
02:02:14 <james999> Tokyo eh? Must.. resist.. making jokes.. about.. vending machines...
02:03:10 <halogenandtoast> vaibhavsagar: Well, I haven't applied there...
02:03:15 <halogenandtoast> I looked at their test though
02:03:27 <vaibhavsagar> same here :)
02:04:12 <james999> halogenandtoast: aside from humor, it would be interesting to hear your experiences working in japan.
02:04:12 <vaibhavsagar> someone linked this a while ago: https://arow.info/index-en.html
02:04:22 <halogenandtoast> vaibhavsagar: probably me.
02:04:30 <james999> some people report different levels of culture shock
02:04:43 <vaibhavsagar> probably
02:04:49 <halogenandtoast> james999: I love it here, I didn't experience any negative culture shock.
02:04:59 <halogenandtoast> My company is perhaps a little atypical though.
02:05:03 <halogenandtoast> <- Cookpad
02:05:45 <james999> idk that sounds suspicious to me. like if someone moved to germany and reported the work place culture was no different than in slovenia
02:06:06 <halogenandtoast> james999: Hmm, most things were an improvement
02:06:16 <halogenandtoast> that's why I prefaced it with "negative"
02:06:21 <vaibhavsagar> where did you move from?
02:06:24 <halogenandtoast> America
02:06:27 <halogenandtoast> Boston
02:06:39 <james999> lol well the traffic at least would be an improvement i'll grant that
02:06:41 <vaibhavsagar> interesting
02:06:55 <halogenandtoast> james999: The subway system here is amazing.
02:07:09 <halogenandtoast> I guess my one complaint is that they still allow smoking in restaurants
02:07:20 <james999> the only thing i know about that is those ytube vids of people being stuffed into subways like sardines
02:07:31 <halogenandtoast> That happens, but that doesn't bother me.
02:07:33 <james999> in fact most of my knowledge of japan is from funny youtube videos
02:07:37 <halogenandtoast> Mainly because everyone has accepted it.
02:07:45 <halogenandtoast> There's no confrontation
02:07:45 <bartavelle> james999: same thing happens in Paris, except people don't seem as nice :)
02:07:54 <halogenandtoast> If that happened in Boston there would be fist fights
02:08:09 <halogenandtoast> I once saw two Japanese people crash their bicycles into each other.
02:08:16 <halogenandtoast> They got up, didn't say a word, and rode off.
02:08:49 <james999> that is pretty unreal
02:09:01 <halogenandtoast> It was. Especially coming from Boston.
02:09:03 <capisce> didn't even say "sumimasen"?
02:09:08 <halogenandtoast> capisce: nope.
02:09:15 <capisce> tssk tssk
02:09:16 <james999> but in line with what i've heard. there's an obsession with saving face and avoiding conflict in japanese culture
02:09:18 <capisce> youth these days
02:09:20 <halogenandtoast> They kind of gave each other a rough look, but that was it.
02:09:52 <capisce> maybe they were both recovering hikikomoris
02:10:03 <halogenandtoast> lol
02:10:10 <james999> so for example halogenandtoast one potential issue would be resolving project problems. in japan it seems like your supervisor would just look away and hope you left the room instead of solving the problem
02:10:26 <halogenandtoast> james999: my company is atypical
02:10:38 <halogenandtoast> It doesn't operate like a Japanese company at all.
02:11:06 <james999> ahh ok, makes sense. I've even heard tales of overworked and underpaid manga artists quitting and moving to china
02:11:18 <james999> b/c it's basically like being a comic book slave or something
02:11:34 <halogenandtoast> Sure overworking and underpaying happens everywhere. The overworking part is pretty typical in Japan from what I'm aware of.
02:11:45 <halogenandtoast> I work 40 hours a week.
02:11:53 <halogenandtoast> Sometimes less, but they just take that out of my pay.
02:12:00 <capisce> they even have a word "death from overwork": karoshi
02:12:16 <james999> TIte Kubo the author of "Bleach" was a drawing genius, but partly to illness and partly the overwork culture basically started phoning it in
02:12:24 <james999> capisce: that is scary
02:12:48 <capisce> https://en.wikipedia.org/wiki/Kar%C5%8Dshi
02:12:48 <halogenandtoast> Yeah, apparently 人身事故 is so common they don't even report it anymore.
02:13:02 <halogenandtoast> which might be related to overworking
02:13:05 <halogenandtoast> but not necessarily
02:13:18 <james999> but idk, i guess to avoid conflict you wouldn't leave your company for a different one? so everybody just keeps overworking
02:13:32 <halogenandtoast> james999: idk, that's changing more and more.
02:13:43 <halogenandtoast> A lot of companies are adopting a more "western" style.
02:13:53 <halogenandtoast> There are more startups popping up.
02:14:06 <james999> like denying them health care?
02:14:12 <james999> (i kid, I kid!)
02:14:20 <halogenandtoast> Well health care is a national scheme here
02:14:24 <halogenandtoast> so that would be very difficult :p
02:15:03 <james999> how did you wind up there anyway?
02:15:23 <james999> email someone and they were like Hai domo arigatou American-sama
02:16:04 <halogenandtoast> I always wanted to live in Japan. I previously worked for a consultancy and convinced them to let me open up an office here.
02:16:16 <halogenandtoast> The company was bleeding money and shut down all remote offices.
02:16:41 <halogenandtoast> So 2 months after moving here I was jobless. But I had already contacted and talked to a bunch of companies as potential clients for the consultancy
02:17:05 <halogenandtoast> so I just picked the best one and got in touch with them, asked if they were hiring and had a job lined up in 3 days time.
02:17:12 <capisce> what kind of consultancy do you do?
02:17:35 <halogenandtoast> capisce: I used to work for a "mostly" ruby on rails consultancy called thoughtbot
02:18:15 <halogenandtoast> They did some non rails sites, and also mobile applications (mostly iOS, but some Android)
02:18:28 <halogenandtoast> They even had a blog comment service written in Haskell called Carival
02:19:05 <tdammers> I guess the manga industry operates under similar pressures as the video game industry in the US
02:19:20 <capisce> halogenandtoast: how is your Japanese?
02:19:47 <james999> tdammers: that's likely true. supposedly the industry is shutting down anime studios atm
02:20:06 <halogenandtoast> capisce: bad, I *might* be N4 level.
02:20:09 <halogenandtoast> But probably not.
02:20:37 <james999> halogenandtoast: if you could go back in time and go to china or south korea would you?
02:21:19 <halogenandtoast> james999: I dreamed of moving to Japan since I was 6 years old and started doing Origami. I visited Japan 4 times in 3 years before I moved here. This is where I want to be and the only place I want to be right now in my life.
02:21:37 <halogenandtoast> I don't see that changing any time soon either.
02:22:00 <james999> ah ok, fair enough
02:22:24 <halogenandtoast> james999: If I found myself at a shitty company that would probably be different.
02:22:31 <james999> being jobless in an asian country would be like a nightmare for me though
02:22:51 <james999> i'd be like kaiji, wandering the streets trying to find a pachinko parlor to get rich off of
02:23:30 <halogenandtoast> james999: When I got let go I had several weeks and severance pay.
02:23:43 <halogenandtoast> I had a job in 3 days from finding out I was going to be let go
02:23:49 <halogenandtoast> technically I could have moved back to the US
02:24:06 <halogenandtoast> I did very little wandering, I wish you the same luck if it ever happens to you :p
02:24:06 <james999> well it sounds like your had a combo of skill and luck and are in a good position
02:24:11 <james999> i'm kinda envious. :D
02:24:50 <capisce> I wouldn't mind living in Japan although I'd worry about dealing with the bureaucracy and tax implications
02:26:28 <halogenandtoast> capisce: I'll let you know how it goes, I've only been here a year
02:26:35 <halogenandtoast> Actually 1 year, 1 day!
02:27:36 <ski> @where PCPH
02:27:36 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>
02:31:51 <halogenandtoast> Anyways james999 if you ever find the time come and checkout Tokyo yourself
02:32:04 <halogenandtoast> the vending machines are plentiful and full of soft drinks and ice cream
02:32:07 <halogenandtoast> and that's about it.
02:42:38 <sternmull> it looks like i could use runParser' of megaparsec to incrementally parse input. But how do i get the initial state? There is a Text.Megaparsec.Prim.initialState which is used inside megaparsec but is not exported.
02:43:54 <fendor> good morning, what is the best practive for command line argument parsing in haskell? getopt?
02:44:10 <brynedwards> fendor: check out optparse-applicative
02:44:29 <fendor> brynedwards, thanks!
02:59:41 <quchen> fendor: Depends on the complexity of your CLI.
02:59:52 <quchen> There is also a very crude but usable implementation in Base.
03:00:01 <quchen> System.GetOpt? Something like that.
03:00:25 <quchen> For anything more complex, optparse-applicative is the better choice.
03:02:46 <fendor> it's not that complicated, but i think, it is worth the time, since i hate to write IO stuff on my own
03:03:01 <fendor> so, i'm giving optparse a try
03:03:09 <fendor> and so far, i am happy with that
03:04:08 <brynedwards> System.Environment.getArgs would be the simple one
03:04:38 <brynedwards> Or another simple method
03:04:43 <fendor> yes, this is what i'm currently using
03:05:06 <brynedwards> I didn't know base had GetOpt
03:05:29 <fendor> i have the use case, that either two flags will be supplied or one flag, i do not want to accomplish this via pattern mathing
03:05:49 <fendor> since this is not the only option, the same applies for a second option
03:06:10 <fendor> i mean, there is some branching involved
03:16:11 <tobiasBora> Hello,
03:16:57 <tobiasBora> What is the good function to do a real modulo? Which is, I want that "a `mod2` b" is always positive
03:17:09 <tdammers> another option is to use something like parsec to write an argument parser
03:17:33 <quchen> tobiasBora: https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Fixed.html#v:mod-39-
03:17:35 <tobiasBora> because with `mod` we have strange things : -2 `mod` 10 /= 8 `mod` 10...
03:17:37 <fendor> tdammers, optparse seems to be a parser that does exactly that
03:17:57 <ahihi> tobiasBora: you want (-2) `mod` 10 
03:18:15 <tobiasBora> ahihi: ahhhhh
03:18:24 <quchen> > (-2) `mod` 10
03:18:26 <lambdabot>  8
03:18:30 <quchen> > (-2) `rem` 10
03:18:32 <lambdabot>  -2
03:18:36 <tdammers> > (-10) `mod` (-7)
03:18:38 <lambdabot>  -3
03:18:47 <tobiasBora> everything is clear now, thank you ^^
03:20:20 <tobiasBora> And by the way, I've a data where I'd like to define a (+) operation
03:20:24 <quchen> Unary minus is fairly broken, I know, but that -2 `mod` 10 is parsed as -(2 `mod` 10), that’s a new one.
03:20:31 <tobiasBora> but I don't want to define (*) because it's not defined
03:20:44 <tobiasBora> Is there a better option that Num ?
03:21:47 <tobiasBora> Or, maybe it's possible to raise an error if I multiply to instances, instead of giving a stupid result ?
03:24:28 <fendor> tobiasBora, well undefined or error should work, shouldn't it? also, if you only want addition, a monoid could make sense
03:25:22 <tobiasBora> fendor: I looked at the monoid, but it seems less confortable to use, because I don't see the (+) operation, it's "append" instead
03:25:36 <tobiasBora> fendor: and I forgot the undefined, good idea !
03:26:04 <fendor> tobiasBora, if i'm right in memory, (<>) is a shortcut for `mappened`
03:26:21 <fendor> > "Hello " <> "World"
03:26:23 <lambdabot>  "Hello World"
03:26:40 <fendor> then you can use (<>) instead of (+)
03:26:48 <fendor> depending on the usecase, i could make more sense
03:30:04 <tobiasBora> ok thank you. In my case it's really number that I want to add, so + is clearer I think, but it's good to know
03:31:39 * hackage wryte 0.1.0.0 - Pretty output for source generators  https://hackage.haskell.org/package/wryte-0.1.0.0 (TobiasDammers)
03:49:29 <ertes-w> tobiasBora: the question is not whether it's a numeric type, but whether it's the commutative ring-like structure that Num wants it to be
03:50:46 <ertes-w> tobiasBora: but for historical reasons Num is kind of a bullshit class…  it shouldn't include both the ring operations and fromInteger, and the abs/signum stuff is also misplaced
03:53:46 <fendor> ertes-w, there is a num prelude that tries to fix that, haven't really looked into that, but it might be fixed there?
03:55:57 <cocreature> ertes-w: fromInteger makes sense for rings
03:56:37 <ertes-w> cocreature: you're right
03:56:37 <cocreature> but it would be nice to have a class that only contains fromInteger and make that a superclass of Num
03:58:10 <ertes-w> well, Num used to be much worse…  it's good enough for most things these days
03:58:33 <ertes-w> but you can't have integer literals for things that aren't rings, which is unfortunate
04:00:27 <cocreature> yeah
04:00:37 <ertes-w> i came into haskell when Num had Eq and Show constraints
04:00:44 <cocreature> ertes-w: RebindableSyntax :P
04:01:24 <ertes-w> for some reason even haskell-beginner-me thought: "that's kinda stupid", but he couldn't yet tell why =)
04:01:36 <Logio> cocreature: I remember having a situation where having the fromInteger was a definite liability
04:01:58 <ertes-w> Logio: it can't be a liability…  every ring has a 1 element
04:02:20 <cocreature> and you get the rest by fromInteger (1 + … + 1) = fromInteger 1 + … + fromInteger 1
04:02:55 <ertes-w> Logio: fromInteger doesn't have to be efficient, but its existence follows from 1 and (+)
04:02:58 <Logio> ertes-w: yes, but you can map the rest of the elements in quite nonobvious ways
04:03:14 <ertes-w> Logio: then (+) is your liability, not fromInteger =)
04:03:38 <ertes-w> you can't really have a situation where (+) is easy, but fromInteger is hard
04:06:44 <Logio> It's not that it is hard, but the fact that it can make things more error-prone
04:07:26 <cocreature> how so?
04:07:40 <Logio> let me see if I find the example I'm thinking of
04:10:57 <Logio> say you have a Num instance for a Boolean ring
04:11:13 <Logio> is a + a == 2 * a ?
04:15:13 <cocreature> ah I think I get your point
04:15:35 <ertes-w> a + a = 1*a + 1*a = (1 + 1)*a = 2*a
04:15:55 <ertes-w> so yes
04:15:58 <cocreature> ofc it’s true but it’s at least slightly confusing to use integer literals in a boolean context
04:16:09 <Logio> yes, that's the problem
04:16:18 <ertes-w> why is it confusing?
04:16:26 <ertes-w> at least to me it's straightforward
04:16:42 <ertes-w> it's just a surprising law perhaps, but it's true regardless
04:17:26 <cocreature> it’s not surprising that it’s true. it’s surprising to see an integer literals when you expect to see a boolean.
04:17:56 <ertes-w> is it?  aren't booleans always introduced as 0 and 1?  as in: "programmers think in terms of zeroes and ones" =)
04:18:06 <Logio> yes, but there is no 2 :)
04:18:11 <ertes-w> Logio: there is
04:18:13 <ertes-w> 2 = 0
04:18:23 <ertes-w> think modulo 2
04:19:15 <ertes-w> it may be less surprising to me, because i have some basic crypto background, so thinking modulo n is not that alien to me
04:20:50 <Logio> I can think in modulo, my problem is that I'm not sure I should be hiding that using fromInteger
04:21:46 <ertes-w> you're not really hiding it…  fromInteger is a monoid homomorphism (or rather a group homomorphism in the case of Num) from Integers and (+) to your Num instance and (+)
04:26:17 <Logio> of course it should be 
04:27:23 <Logio> but does everyone implementing a Num instance actually check that?
04:29:50 <Logio> like for the boolean ring, there are a lot of ways to implement fromInteger that are wrong, but intuitive
04:31:53 <ertes-w> the most obvious implementation maps evens to false, odds to true
04:33:03 <Logio> that's obvious if you are used to thinking in modulo-2
04:33:55 <Logio> whereas quite a few programming folks would agree that mapping 0 to false and everything else to true would be perfectly fine
04:34:29 <Logio> which it is not, but with Num being lawless territory they might get away with
04:35:10 <Velizar> Which data type can I use to model a simulation with 100x100 cells, which changes individual cells a lot but still has okay-ish performance? e.g. I was considering IOArray and ByteString
04:35:53 <cocreature> Velizar: do you need to change individual cells or do all cells change at each frame?
04:36:28 <Velizar> cocreature: One cell at a time - the next step needs to be with that cell changed. 
04:39:41 <cocreature> Velizar: I would go for a mutable unboxed vector
04:40:05 <Logio> ertes-w: another niggle I have is that with having fromInteger, people will easily expect the ring to be commutative
04:40:56 <Logio> which really might not be true
04:41:23 <cocreature> Velizar: if unboxing does not make sense in your application or you are fine with losing a bit of performance, https://hackage.haskell.org/package/matrix-0.3.5.0/docs/Data-Matrix.html provides a nice API on top of vector for matrices
04:42:16 <ertes-w> Logio: yeah, i get your point, but of course instances like that aren't correct and require a bug-fix
04:43:07 <ertes-w> Logio: the trouble here is that "Num" is just a bad name for "Ring" =)
04:43:52 <Logio> "Commutative Ring", I would say
04:44:38 <ertes-w> Logio: why?  Num instances don't need to be commutative rings
04:45:01 <Velizar> cocreature: I'll obviously be using setElem. What is its complexity? The documentation doesn't mention that. 
04:45:32 <cocreature> Velizar: oh sorry I forgot that you want to set individual elements. in that case matrix doesn’t help
04:45:33 <Logio> ertes-w: but people expect them to be, not knowing any better
04:45:47 <cocreature> Velizar: just use an unboxed vector and write a helper for setting two dimensional indices
04:46:36 <ertes-w> Logio: that's more a statement about haskell education than about Num itself =)
04:47:28 <Logio> well, I'm trying to make the point that having fromInteger in Num is not helping Haskell education :)
04:48:51 <Logio> ... though any other way probably wouldn't be any better
04:49:24 <Logio> but the commutativity is really a hard thing to keep track of
04:50:46 <Logio> with Num not having anything to say about it, I can't rely on a library handling my non-commutative Nums correctly
04:52:09 <ertes-w> Logio: i oppose the idea to make classes "beginner-friendly"
04:53:03 <ertes-w> yes, the type of foldMap is not easy to read to a beginner, but it's very powerful…  here it's the teacher's job to introduce foldMap properly
04:54:01 <ertes-w> the "beginner-friendly foldMap" would be one that is specialised to lists, and i'm glad that's gone =)
04:55:14 <mniip> Data.OldList?
04:57:30 <Logio> ertes-w: Being strictly correct is actually my idea of beginner friendly 
04:57:56 <Logio> not letting people make mistakes is better than being easy
04:59:18 <ertes-w> Logio: what do you propose?  adding dependent types and strict termination checking to prove that fromInteger is actually a homomorphism? ;)
04:59:42 <ertes-w> and i question the beginner-friendliness of that =)
04:59:44 <Velizar> Is there a good implementation of a data structure similar to Scala's Vector - immutable and with effectively constant update time? 
05:00:08 * hackage dictionaries 0.2.0.2 - Tools to handle StarDict dictionaries.  https://hackage.haskell.org/package/dictionaries-0.2.0.2 (zohl)
05:00:14 <Logio> ertes-w: well, that would be better :P
05:01:52 <cocreature> Velizar: you don’t get better than log n for updates with immutable data structures and if you take constant factors into account it’s often even significantly worse than that
05:01:53 <ertes-w> Velizar: it's called a 'rope' data structure, and you can construct it using the 'fingertree' package
05:02:08 <Logio> ertes-w: but just having Num changed to Ring would force complete beginners to look up basic algebra before implementing anything, which probably would be helpful
05:02:16 <Velizar> logn is fine. I'll look at rope
05:12:31 <Athas> cocreature: you can get O(1) updates if you are willing to accept slower indexing.
05:12:47 <cocreature> fair enough
05:14:19 <Athas> The 'Parallel Functional Arrays' paper by Ananya Kumar, Guy Blelloch, and Robert Harper even shows how the "slower indexing" need not be so bad.
05:40:57 <ph88^> how can i make a tarball ready for binary release with stack ?
05:46:12 <jakub_> hello, I am trying to understand DT via implementing a library for handling and extending statically sorted expressions: https://github.com/jakubdaniel/expressions (beware I rewrite the commits quite a lot) and I got stuck at adding functionality such as substitution, would anybody here be willing to skim the definitions in Utils.Indexed.Functor and Expression.* and help me understand what needs to be 
05:46:18 <jakub_> changed to allow for a general substitution to be defined?
05:51:36 <jakub_> I am stuck at the fact that the substitution would have to match the Sort of the "pattern" that I am looking for with the actual Sort of a subexpression deep down in the AST, since most of that information is only static I tried different things: 1. use SingI to be able to materialize the sort whenever I need it (there I conflicted with my definition of imap and nothing I tried fixed that) 2. include the 
05:51:42 <jakub_> sort dynamically as a value which didn't really help.
05:52:53 <jakub_> most things I tried worked for some of my functors (VarF, BoolF, ...) but not others (ArrayF, EqualityF, ArithmeticF)
06:15:51 <mbrock> it's always so hard to figure out how to build a static binary
06:18:44 * mbrock tries some more random command line arguments
06:20:22 <sternmull> mbrock: Why that? External libraries or because of haskell itself?
06:29:48 <mbrock> sternmull: right now ghc is trying to do something with libncurses.so and failing. I'm in an Alpine-based GHC Docker image. Actually I didn't try building non-statically, will try that now :)
06:38:37 <Geekingfrog> What's the command in ghci to see what's been evaluated in a data structure ?
06:39:39 <cocreature> Geekingfrog: :print iirc
06:40:21 <Geekingfrog> Thanks
06:40:33 <Geekingfrog> Is there a strict (+) somewhere? like (+!) ?
06:40:52 <cocreature> (+) is strict at least for the popular instances like Int, Integer, …
06:45:08 * hackage json-feed 0.0.0 - JSON Feed  https://hackage.haskell.org/package/json-feed-0.0.0 (fozworth)
06:46:41 <tsahyt> hello! I'm working with a relatively large data transformation pipeline in which each operation transforms the data such that another invariant is ensured. some parts can be reordered. some operations must assume that one invariant or another already holds. So I was thinking of adding a phantom parameter to my type and encoding which properties are required and which hold after execution of each part. Now
06:46:43 <tsahyt> ideally I'd like my phantom parameter to be a set such that I can check membership.
06:47:00 <tsahyt> iirc extensible-effects has some machinery for that, but is there something similar that doesn't require me to pull in a completely unrelated package?
06:47:40 <c_wraith> tsahyt: will you ever need to generate one of these things dynamically?  ie, such that you don't know what its type is until runtime?
06:47:47 <tsahyt> basically I'd like to write something like transform :: Holds Invariant1 k => Foo k -> Foo (Invariant2 <| k)
06:47:49 <tsahyt> c_wraith: no
06:48:03 <tsahyt> the values start out with no property holding
06:48:17 <tsahyt> and if they do happen to hold, there's no harm in doing the operation anyway, since they're all idempotent
06:48:48 <c_wraith> tsahyt: then that means you can can work with any old type-promoted list and use a type family for checking if a type is in it.
06:49:00 <Rotaerk> hmm wonder if I should start using machines rather than pipes
06:49:23 <c_wraith> Rotaerk: machines is still considered experimental, whereas pipes is considered ready for real use.
06:49:31 <Rotaerk> ah
06:49:35 <tsahyt> c_wraith: currently I'm using promoted lists, but I was wondering whether I can get away without implementing elem on the type level myself
06:49:39 <tsahyt> not that it'd be hard
06:49:59 <tsahyt> in the spirit of the language I'm just lazy :P
06:50:31 <tsahyt> I've found some open union packages but it seems that only the implementation in extensible-effects comes with the membership check type family
06:50:41 <simendsjo> I'm having some problems grokking monad transformers. I cannot seem to find any tutorial or examples that use it at the application level. I'd like to see the combination of Reader, State, Either and possibly other monads in action thinking it might help my understanding. Does anyone know of some simple projects using this sort of stack?
06:51:02 <lyxia> tsahyt: singletons and hlist have type-level list operations defined
06:52:00 <ertes-w> tsahyt: personally i would probably just use concurrency, potentially with STM
06:53:35 <tsahyt> lyxia: hlist looks interesting. I somehow prefer not to use singletons unless I really need it. it always sends me down a rabbit hole that is just way too deep.
06:53:52 <tsahyt> ertes-w: concurrency is orthogonal here, isn't it?
06:54:11 <c_wraith> yeah, singletons are great when you need to be able to round-trip between type and value.  But if you don't, it's not necessary
06:54:20 <mheinzel> simendsjo: hython (a simple Python interpreter) uses a stack of ExceptT, ContT, StateT. About 2000 lines of code, took me 1 or 2 days to get familar with the code base and taught me a lot.
06:54:34 <mheinzel> simendsjo: https://github.com/mattgreen/hython
06:55:32 <simendsjo> mheinzel: Thanks. I'll look into it. I'm a pre-newbie, so hopefully it doesn't use too much advanced stuff.
06:55:58 <ertes-w> tsahyt: it's a processing pipeline, and you can read data only once certain invariants check
06:56:31 <ertes-w> tsahyt: meanwhile you can keep processing other items, if applicable
06:56:50 <tsahyt> ah, no. all data is available from the start and needs to be processed in full before the next step can begin
06:56:58 <ertes-w> ah, i see
06:57:07 <tsahyt> it's a rather elaborate transformation on a syntax tree
06:57:12 <mheinzel> Well, apart from monad transformers in themselves, the most complex concept used is continuation passing (ContT). It's used for control flow handling (exceptions, loops with break and continue etc.)
06:57:44 <tsahyt> normalizing, rewriting, flattening, synthesis of invariants, grounding free variables, and so on. for example the grounding and synthesis of invariants can be performed in either order
06:59:06 <ertes-w> simendsjo: think simple:  "transformer" is really just a fancy word for "function" (with some extra guarantees), in this case taking a monad and returning a monad…  for example MaybeT is such a function:  MaybeT :: (* -> *) -> (* -> *)
06:59:35 <ertes-w> simendsjo: (MaybeT m) happens to be a monad, whenever m is a monad:  instance (Monad m) => Monad (MaybeT m)
06:59:58 <ertes-w> simendsjo: and there is a way to lift m-actions to (MaybeT m)-actions
07:01:28 <simendsjo> ertes-w: I've read quite a bit about monad transformers, and while it seems to make sense at the low-level, I cannot seem to wrap my head around how to use it when stacking a lot of them. Does the order matter? How can I pass only what is needed to functions rather than the entire thing, etc.
07:01:40 <simendsjo> .. so it's obviously quite some lack of understanding :/
07:02:24 <ertes-w> simendsjo: you figure it out on a transformer-by-transformer basis, and yes, the order matters
07:02:41 <ertes-w> @unmtl StateT s (MaybeT m)
07:02:41 <lambdabot> Plugin `unmtl' failed with: `StateT s (MaybeT m)' is not applied to enough arguments, giving `/\A. s -> m (Maybe (A, s))'
07:02:43 <tobiasBora> Hello,
07:02:54 <tsahyt> the type-fun package looks like a good middle ground
07:03:00 <tsahyt> and it has type level Elem for promoted lists
07:03:01 <ertes-w> @unmtl StateT S (MaybeT M)
07:03:01 <lambdabot> Plugin `unmtl' failed with: `StateT S (MaybeT M)' is not applied to enough arguments, giving `/\A. S -> M (Maybe (A, S))'
07:03:04 <r444> https://gist.github.com/dredozubov/7b696f3eeb6688f1198c1cb8aab33fda can someone explain why i'm getting an error on line 10?
07:03:13 <tobiasBora> I'd like to do a mapping on a matrix defined from Matrix.Data
07:03:19 <tobiasBora> *Data.Matrix
07:03:32 <tobiasBora> however, I cannot find a map that work on all the matrix
07:03:46 <r444> tsahyt: what a time to join a channel, we made type-fun at work
07:04:05 <tobiasBora> do you have any solution for that?
07:04:13 <ertes-w> simendsjo: ideally you write your actions using effect classes like MonadState or MonadIO, and only when you actually run an action you should instantiate a particular stack
07:04:19 <simendsjo> ertes-w: It's just when I write `type App = StateT AppState (ReaderT AppGlobals (ExceptT AppError IO))`, my head starts spinning, and I have no idea where to go next :)
07:04:23 <mbrock> ok, got further with using stack to build static binary. next problem: stack seems to be trying to create some shared objects, which fails because of libHSghc stuff not being -fPIC. I don't want any shared objects, just a big fat static binary
07:04:33 <tsahyt> dredozubov_: I've never used it before but right now it looks like it could work perfectly for what I need
07:04:57 <dredozubov_> we just assembled some type families that were used all over the place in one package
07:05:02 <ertes-w> simendsjo: sometimes backtracking is the nicest option:  this is the monad i would use in that case:  type App = StateT AppState IO
07:05:10 <dredozubov_> the one I use most is AllSatisfy
07:05:48 <dredozubov_> tsahyt: feel free to contribute if you feel like it lacks something
07:06:12 <tobiasBora> ok I found the solution: fmap
07:06:23 <tsahyt> dredozubov_: I'll keep it in mind. right now my needs are rather minimal. this looks like a rather complete collection of working with '[] already.
07:06:58 <c_wraith> dredozubov_: that looks like a ghc shortcoming more than anything.
07:07:52 <nut> with Parsec, how to match the name part of "Dan Clark’s Profile Photo"
07:08:14 <nut> each line contains "Dan Clark’s Profile Photo"
07:08:17 <tsahyt> hmm, the error messages this generates are interesting
07:08:18 <dredozubov_> c_wraith: it feels to me that way too
07:08:19 <nut> with different names
07:08:26 <tsahyt> I suppose they are somewhat descriptive though
07:08:39 <c_wraith> dredozubov: but maybe not.. I'm a bit confused about what's going on with line 6.  do you mean to have a type family as an argument to a data constructor?  That doesn't make much sense
07:08:44 <tsahyt> I wish ghci didn't expand constraint synonyms when using :t
07:09:35 <dredozubov_> c_wraith: oh heck, there's a typo on line 6
07:09:46 <c_wraith> dredozubov_: well is that the cause then?
07:09:50 <dredozubov_> it should say Builder 
07:09:59 <c_wraith> Ah.  Ok, that should probably make it work
07:10:05 <dredozubov_> seems like it!
07:10:14 <dredozubov_> it's a relief
07:10:19 <c_wraith> dredozubov_: I spent too much time looking at the wrong line. :)
07:10:49 <dredozubov_> I was afraid I stumbled upon a cryptic ghc bug
07:11:21 <dredozubov_> it feels good when you discover you made a stupid mistake and it's not a compiler bug :)
07:11:35 <c_wraith> :)
07:12:08 * hackage dhcp-lease-parser 0.1 - Parse a DHCP lease file  https://hackage.haskell.org/package/dhcp-lease-parser-0.1 (andrewthad)
07:44:40 <pat____> hi everybody, does anybody know a good in-depth paper on haskell types?
07:45:36 <shapr> pat____: wait, you want just one?
07:45:48 <shapr> pat____: have you seen Types and Programming Languages by BC Pierce?
07:47:02 <pat____> shapr: gonna check, but I was looking for something specific to haskell
07:47:41 <shapr> oh, TaPL is more generic
07:48:05 <pat____> that'd explain function signature in details, all that stuff
07:48:08 <shapr> pat____: do you have a specific viewpoint on types in Haskell?
07:48:09 <shapr> ohh
07:48:22 <shapr> most of the Haskell books are good about that
07:48:33 <shapr> I've heard good things about Graham Hutton's Programming in Haskell book
07:48:53 <shapr> I've read the 1st edition, and the 2nd edition arrived in the mail this week
07:49:38 <pat____> I have the second edition, same it's pretty basic about data types
07:50:28 <andrei> I have a megaparsec/trifecta question. I have this simple parser. It attempts to just parse either the string "A" or "A A". p s = parse ((string "A" >> return 0) <|> (string "A" >> space >> string "A" >> return 1) >>= (\x -> eof >> pure x)) "" s
07:51:14 <andrei> But it doesn't parse "A A". It always fails. Even if I wrap every expression/subexpression in try
07:51:32 <andrei> What's going on?
07:54:54 <shapr> pat____: what sort of details do you want about type signatures? forall? skolemization?
07:58:22 <pat____> shapr: yes, forall, skolemization, not sure what it is :), but as muchas possible, to me it looks like a huge subject but there's little info about it, specially when working with all the abstract data types, monads applicative etc.
08:01:38 * hackage watchdog 0.2.3 - Simple control structure to re-try an action with exponential backoff  https://hackage.haskell.org/package/watchdog-0.2.3 (JanVornberger)
08:12:04 <lyxia> andrei: (<|>) is not backtracking because your first parser consumes at least one character
08:13:01 <lyxia> oh actually it's also because it succeeds
08:13:30 <ingars> can you recommend best vim syntax highlight plugins for haskell?
08:13:55 <glguy> vim already highlights Haskell
08:14:36 <ingars> glgyu - apparently not for me ::)
08:14:51 <ongy> ingars: :syntax on
08:14:51 <ingars> VIM - Vi IMproved 7.4 (2013 Aug 10, compiled Apr  4 2017 18:14:54) on a Mac
08:15:29 <ingars> ongy: oh, thanks. how could I miss that :/
08:15:31 <[exa]> glguy: my vimrc line for haskell: autocmd FileType haskell setlocal et ts=2 sw=2
08:15:45 <[exa]> oh sorry, ingars ^
08:15:58 <glguy> http://lpaste.net/355625 normal vim has a couple of bugs in string literal syntax
08:16:06 <[exa]> and also 'syn on' in the vimrc
08:17:26 <lyxia> andrei: basically, (x <|> y) >>= f  is not equivalent to  (x >>= f) <|> (y >>= f)
08:17:32 <ongy> isn't there a weird difference between syntax on and syntax enable? I think you want the 2nd in .vimrc
08:17:55 <glguy> [exa]: does ts=2 set the tab stops to 2?
08:18:13 <ongy> I think it's TabSize
08:18:20 <lyxia> andrei: swap the two alternatives so the longer parse comes first
08:20:10 <glguy> because if so it needs to be 8 for haskell
08:20:22 <glguy> you can use "soft" tabs as 2
09:04:08 * hackage fortran-src 0.1.0.6 - Parser and anlyses for Fortran standards 66, 77, 90.  https://hackage.haskell.org/package/fortran-src-0.1.0.6 (madgen)
09:17:51 <hanna> https://github.com/pxqr/intset seems to have been forgotten, the GHC 7.10 compatibility PR has been sitting unmerged for over a year. This is annoying since I depend on it, and GHC 7.10 users cannot simply `cabal install` my executable without applying the PR first. Is there anything I could do to move forward the process of getting this library patched, under the assumption that the maintainer has given up
09:17:53 <hanna> on it?
09:18:23 <hanna> In shorter words: Is there a way to “reclaim” ownership over a seemingly abandoned package with an unresponsive maintainer?
09:18:51 <ongy> hanna: there's a default process for that on hackage
09:19:33 <ongy> you have to contact the current maintainer in a public way (email to haskel-caffee with CC or something) and when they don't reply for some time/give permission you can take over ownership
09:19:58 <ongy> hanna: https://wiki.haskell.org/Taking_over_a_package this here explains it better
09:20:56 <hanna> Okay
09:21:04 <hanna> Honestly it seems easier to just fork it and upload my own version under a different name
09:21:09 <hanna> thanks BSD3
09:21:31 <ongy> that's easier, but going through the takeover process is technically (and morally) better IMO
09:21:33 <EvanR> its better to try to contact them first
09:21:54 <EvanR> saying there is a pull request just sitting there isnt that
09:22:39 <hanna> I tried reaching them on github about a week ago. I wouldn't mind trying to reach them via email either, but I hate mailing lists so there's that
09:23:56 <ongy> hanna: in a private message? If it's public on github you may (not sure) be able to speed things up refering to that
09:24:18 <hanna> ongy: https://github.com/pxqr/intset/pull/3#issuecomment-302980545
09:25:39 * hackage top 0.2 - Top (typed oriented protocol) API  https://hackage.haskell.org/package/top-0.2 (PasqualinoAssini)
09:26:37 <ongy> I'm no hackage trusty. Try to go the official way, refer to that and see what they say. I did it before and it really isn't that much of a hassle (just takes a bit longer than I hoped)
09:26:38 * hackage vectortiles 1.2.0.5 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.2.0.5 (fosskers)
09:42:00 <ertes-w> hanna: you could just fork it
09:42:13 <ertes-w> intset-hanna or something
09:42:38 <hanna> I guess that's better than nothing for now
09:43:29 <ertes-w> i guess it would be nice, if hackage packages were user-tagged
09:44:36 <ertes-w> and perhaps there would be some process to select a "default user" for every package
09:46:04 <EvanR> forking intset ?
09:51:37 <hanna> Hmm; I'm trying this approach: 1. reference the fixed version of the package as a `git submodule` in something like extern/intset; 2. make my .cabal build and include that package before using it as a dependency to my own
09:51:58 <hanna> Is this still possible with build-type: simple or would I need to write my own wrapper to automate the two-stage build?
09:57:02 <hanna> Hmm seems like the best way to accomplish this would be via cabal sandbox
09:57:16 <hanna> I wonder if I can create a sandbox and issue `cabal sandbox add-source` programmatically
09:57:25 <hanna> e.g. from a cabal user hook
09:58:09 * hackage soap 0.2.3.4 - SOAP client tools  https://hackage.haskell.org/package/soap-0.2.3.4 (AlexanderBondarenko)
10:02:45 <hvr> hanna: not sure what you're trying to do, but cabal sandboxes are about to go away; see http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html for the new approach
10:03:10 <orion> hvr: What about stack?
10:03:28 <hanna> Actually, a sandbox wouldn't solve my use case anyway
10:03:29 <hvr> orion: different camp/tribe :-)
10:03:34 <hanna> because then `cabal install` would go into the sandbox :D
10:03:38 <orion> Do yout think it will become obsolete?
10:04:22 <hanna> That new nix build system seems like it would be perfect though
10:04:55 <hvr> orion: fwiw, I think you can write a shim/wrapper around new-build which can emulate most of Stack
10:06:19 <hanna> Heh, turns out writing a two-line `cabal.package` solves my problem
10:06:36 <hvr> hanna: you mean, cabal.project :)
10:06:41 <hanna> Oops, yes :)
10:15:15 <Lokathor> @pl \s -> (rowCount s, colCount s)
10:15:15 <lambdabot> liftM2 (,) rowCount colCount
10:16:25 <Lokathor> :t liftM2
10:16:27 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:16:28 <Lokathor> :t liftA2
10:16:29 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:16:38 <Lokathor> hmm
10:17:33 <Taneb> Lokathor, if you like infix stuff, (,) <$> rowCount <*> colCount is an option
10:18:01 <Lokathor> well i'm already applying that to a StateT get with <$>
10:18:18 <Lokathor> so i think using liftA2 prefix-style ends up better
10:18:36 <Taneb> That's fair enough :)
10:18:51 <Lokathor> getRowColCount = Hexes $ liftA2 (,) rowCount colCount <$> get
10:18:58 <Taneb> (this is using the ((->) r) applicative functor if you're not familiar)
10:19:24 <Lokathor> i'm ever so slightly familiar with -> r being a Functor, but do not recall the applicative portion
10:19:56 <Taneb> pure :: a -> ((->) r) a ~ a -> r -> a
10:20:03 <Taneb> @djinn a -> r -> a
10:20:03 <lambdabot> f a _ = a
10:20:13 <Lokathor> i can almost read that
10:20:44 <Taneb> "pure" is of type a -> f a, right, and here f ~ ((->) r)
10:21:00 <Taneb> So we end up with pure :: a -> r -> a, and there's only one sensible option for that
10:21:03 <Lokathor> ah, but here's the other one I'm wondering if it's safe to compact down, https://pastebin.com/AYC4VuNa
10:21:10 <Lokathor> pure = const
10:21:32 <Taneb> Yes
10:21:38 <Taneb> Or equivalent
10:21:46 <shapr> Is there a recommend zero mq library for Haskell?
10:22:13 <Taneb> (<*>) :: f (a -> b) -> f a -> f b, so here it'd be (r -> a -> b) -> (r -> a) -> r -> b
10:22:21 <Lokathor> well, now I can say that i've used liftA2 /ever/
10:22:30 <Taneb> That's a tad less obvious, but even so there's only one sensible option
10:22:43 <Taneb> @djinn (r -> a -> b) -> (r -> a) -> r -> b
10:22:43 <lambdabot> f a b c = a c (b c)
10:22:51 <shapr> kanske den lib zeromq4-haskell är bättre än zeromq-haskell, men jag har ingen aning.
10:23:20 <shapr> ski: har du användat 0mq på Haskell?
10:23:23 <Taneb> Lokathor, it's an exercise for the reader to show this is a law-abiding applicative :)
10:23:51 <Lokathor> Taneb, >_< I just wanted a single lifting! that's all i came here for!
10:24:05 * Lokathor runs away back to his Storable instances
10:24:15 <Taneb> Lokathor, but learning is fun! :D
10:24:38 <Lokathor> I'm doing quite enough other learning at the moment :P
10:25:28 <Lokathor> Taneb, https://github.com/Lokathor/hexes/blob/master/src/Hexes/Internal.hs :3
10:25:38 <hanna> Aah, there's no `cabal new-install` yet :(
10:26:09 <Lokathor> whoops, left off the line number. line 186
10:27:39 <Taneb> Lokathor, I'm impressed with your code-commenting dedication
10:28:08 <Lokathor> oh I would not be able to work on this for more than one session without those comments :P
10:29:35 <Lokathor> EvanR, i used liftA2 for once!
10:33:55 <EvanR> liftA2 rocks
10:34:04 <shapr> @pl liftA2
10:34:05 <lambdabot> liftA2
10:34:18 <EvanR> liftA0 :: a -> f a
10:34:27 <EvanR> liftA1 :: (a -> b) -> f a -> f b
10:34:35 <EvanR> liftA2 :: (a -> b -> c) -> f a -> f b -> f c
10:34:39 <EvanR> "it just makes sense."
10:35:13 <ongy> Lokathor: shouldn't the constants be Num instead of Integral? :)
10:36:04 <Lokathor> ongy, /possibly/, though I've yet to need to legitimately use any of those Integral i values with a Float value
10:36:17 <Lokathor> so I'd consider it an error at the moment to try without serious thought
10:42:04 <Lokathor> EvanR, functor makes sense, applicative less so
10:46:45 <EvanR> Lokathor: you can see in the above its just a generalization
10:47:05 <EvanR> mapping a 2 arg function over 2 args
10:47:29 <EvanR> instead of 1 arg function over 1 arg
10:48:01 <Lokathor> i mean i see that
10:48:13 <Lokathor> hmm i forget which one
10:48:16 <Lokathor> :t (<*>)
10:48:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:48:26 <Lokathor> that's the spooky one
10:48:35 <Lokathor> I don't normally keep my functions inside of structures
10:48:45 <EvanR> ah
10:48:52 <EvanR> thats just a rearrangement of liftA2
10:49:04 <EvanR> to allow for A3 A4 A5 etc without special functions
10:49:39 <EvanR> another rearrangement is :: f a -> f b -> f (a,b)
10:51:22 <Tuplanolla> @let unit = pure ()
10:51:23 <Tuplanolla> @let zipA = uncurry (liftA2 (,))
10:51:24 <lambdabot>  Defined.
10:51:25 <lambdabot>  Defined.
10:51:40 <Tuplanolla> I find this formulation to be useful quite often.
10:52:34 <Lokathor> :t zipA
10:52:35 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
10:53:01 <Tuplanolla> You now have `pure x = fmap (const x) unit` and `f <*> x = fmap (uncurry ($)) (zipA (f, x))`.
10:53:25 <EvanR> this is all pretty (nicely) abstract without some examples
10:54:56 <Lokathor> I think the trouble is that I want to use Haskell to push bits around most of the time :P
10:55:14 <EvanR> or glyphs around a grid?
10:55:18 <Lokathor> yes :3
10:55:20 <EvanR> a grid of a is an applicative and a monad
10:55:30 <Lokathor> how do you figure?
10:56:06 <EvanR> applicative, (a -> b -> c) -> Grid a -> Grid b -> Grid c would apply the args are each position to the function to get the result in that position
10:56:36 <EvanR> monad Grid (Grid a) would look at the a in the grid at that position... at that position... and flatten
10:56:39 <EvanR> to get a Grid a
10:56:52 <EvanR> "diagonalization"
10:57:13 <Lokathor> but... but... the grid is a Vector.Storable.Mutable.IOVector of Word8 value
10:57:19 <EvanR> (assuming all grids are the same size)
10:57:37 <EvanR> mutable? why?
10:58:00 <EvanR> you can do better than that ;)
10:58:03 <Lokathor> because you're updating it like all the time?
10:58:25 <EvanR> you can update a Grid all the time ;)
10:59:12 <Lokathor> doing that immutably is crazytalk piggy
10:59:19 <ongy> we have a good "Grid" type for haskell?
10:59:21 <EvanR> no way
10:59:32 <EvanR> Lokathor: so 60fps ?
10:59:43 <ongy> Lokathor: have you benchmarked it? :)
10:59:56 <EvanR> > 80 * 25
10:59:58 <lambdabot>  2000
10:59:58 <Lokathor> ongy nope, not yet, the full thing doesn't turn on yet
11:00:35 <EvanR> heres a fast updating grid
11:01:16 <EvanR> data Grid a = AllAre a | Update Int Int (a -> a) (Grid a)
11:01:18 <EvanR> hehe
11:01:31 <Lokathor> woah woah pal
11:01:41 <Lokathor> you can't unsafe that into a (Ptr a), no good
11:01:56 <EvanR> maybe im not understanding the purpose of this grid
11:01:57 <Lokathor> we wanna push our data to the GPU after all :3
11:02:22 <Lokathor> EvanR, the grid is the library-side data store that holds the data in place to push it to a vertex buffer object
11:02:27 <EvanR> i thought we were talking about grid of glyphs not a framebuffer
11:03:02 <EvanR> seems like a drastic difference in data size
11:03:08 <Lokathor> if the user wishes to maintain their own grid of things, that's fine, but this is much closer to just a fancy framebuffer than an abstract dealio
11:03:21 <ongy> EvanR: something that's at least half way efficient :) But I remember that representation from my isabelle course
11:03:25 <EvanR> all youre writing is a 2d framebuffer?
11:03:42 <Lokathor> EvanR, a fancy one, yes
11:03:46 <EvanR> ongy: fast update, not memory efficient or lookup efficient
11:03:48 <EvanR> heh
11:04:08 <Lokathor> I'm honestly not sure what I'd want with a generic (Grid a) type that's a Monad
11:04:13 <Lokathor> or anything like that
11:04:20 <EvanR> i was imagining a grid of glyphs
11:04:35 <EvanR> which is much more abstract than a off screen framebuffer in the gpu
11:04:47 <Lokathor> well, more technically, it's a grid of Word8 values that index into an image which is assumed to contain glyphs :P
11:05:00 <EvanR> you could associate other data with grid positions than just glyphs so its a functor, monoid monad appl whatever
11:05:08 <Lokathor> the tile image could really contain whatever you want i guess
11:05:11 <EvanR> Lokathor: o_O
11:05:24 <ongy> EvanR: :) But I'm somewhat serious, I still don't know what's the best way to do matrices in Haskell... someone said (Map (Int, Int) a) for sparse, but dense?
11:05:44 <EvanR> ongy: im not sure. hmatrix?
11:05:48 <Lokathor> EvanR, this is "curses in open gl", not anything more abstract than that
11:06:01 <Lokathor> ongy, i'm using linear, but it's really oriented to sizes 1 to 4
11:06:22 <Tuplanolla> All array libraries for Haskell are unsatisfying.
11:06:43 <Tuplanolla> Vector and Repa are my favorites, but still...
11:06:43 <EvanR> the naperian functor paper meetup is coming up
11:07:01 <EvanR> APLicative programming
11:09:17 <ongy> but to be honest, last I tried to optimize something with vectors I ended up being slower than GHC doing magic with lists
11:09:43 <EvanR> mutable vectors?
11:09:54 <Lokathor> EvanR, :O but i thought we hated those?
11:10:13 <EvanR> im asking because mutable vectors have added gc overhead
11:10:21 <Lokathor> oh do they?
11:10:24 <EvanR> yes
11:10:36 <Lokathor> I thought they performed destructive updates and had less overhead :(
11:10:43 <EvanR> they mess up generational gc
11:10:57 <ongy> I think I tried unboxed and boxed non mutables. But maybe I just messed things up
11:10:58 <EvanR> or could
11:11:10 <EvanR> ah
11:11:29 <EvanR> Lokathor: one thing to internalize about ghc is its very fast at allocating memory
11:11:38 <EvanR> unlike malloc
11:12:09 <Lokathor> well i need my memory in big blocks that are accessable as (Ptr a)
11:12:14 <Lokathor> though perhaps it's good at that too
11:12:14 <ongy> ghc mostly does a "increase this counter" allocation kind, right? Into the nurseries or what they are called
11:13:04 <EvanR> yes
11:13:48 <ongy> into Ptr a needs some marshalling
11:13:51 <EvanR> so the performance burden is really on quickly collecting temporary values
11:14:24 <ongy> Lokathor: do you give the ptr somewhere and then live update it, or just give it once for copy out and give a new pointer each time?
11:14:48 <Lokathor> well a mutable vector is a ForeignPtr normally, and then there's an unsafe operation that lets you use the mutable vector as a Ptr
11:15:04 <ongy> unsafeCoerce *cough*
11:15:12 <Lokathor> yeah however
11:15:18 <EvanR> its not unsafeCoerce
11:15:32 <ongy> I would be surprised if it is
11:15:40 <Lokathor> anyway you use that and then call the GL func with the pointer, and GL copies all the data into the GPU's RAM at that point
11:15:56 <EvanR> *or something
11:16:00 <EvanR> gl driver magic
11:17:38 <Lokathor> the important part is that once your gl call returns, it's safe to update the data you gave the pointer for without the GPU's copy of the data being messed up
11:17:55 <Lokathor> which is all a person could ask for really
11:18:38 <Lokathor> ah, here's an example from a demo, https://github.com/Lokathor/learnopengl/blob/master/app/Lesson06.hs#L277
11:19:29 <ongy> ahh gl. i remember why I never did anything serious with it
11:20:34 <Lokathor> ?
11:21:55 <EvanR> gl was another one of those APIs which was like "huzzah, network transparent"
11:22:55 <Lokathor> didn't know you could run it usefully over a network
11:24:07 <EvanR> you probably cant
11:24:13 <ongy> really? doesn't gl rely on DMA most of the time?
11:24:13 <EvanR> like X11
11:24:34 <Lokathor> can't you forward X data from one machine to another?
11:24:39 <EvanR> sure
11:24:46 <EvanR> its terrible
11:24:58 <EvanR> and makes the API terrible
11:24:58 <ongy> you *can* run X11 over the network, the thing that make problems are extensions (which anything halfway recent uses)
11:25:12 <Lokathor> i did it once in 2006
11:25:30 <ongy> X-forward?
11:25:58 <EvanR> so its not a glyph grid, its a pixmap tile grid
11:26:09 <EvanR> not even a shader grid? ;)
11:26:38 <EvanR> send grid of shader configs to the gpu
11:26:58 <EvanR> the fastest grid in the west
11:27:38 <Lokathor> the assumption is that the 32 to 127 part of the pixmap will be glyphs
11:27:44 <Lokathor> and perhaps i'll expand it out a bit once it works at all
11:28:08 <Lokathor> but rendering text in opengl is terrible enough as it is :P
11:28:50 <Lokathor> pixelmapped glyphs mean that you can make it perform fallback work as a tile engine, which is cool
11:29:34 <EvanR> if you accept shaderism, you have the remote possibility of being abstract with opengl
11:29:41 <Lokathor> I'm not currently sure how to have the text have an optional foreground color that overrides the pixmap's color
11:29:43 <Lokathor> shaderism?
11:30:14 <EvanR> then its not only a pixmap grid, but a vector graphics grid, or grid of whatever data that can be represented within the gpu
11:30:20 <EvanR> and used gpu side
11:30:29 <int-e> ongy: OpenGL isn't what it used to be... have a look at OpenGL version 1 and it will not seem so unreasonable to send that over the network anymore.
11:30:53 <EvanR> yeah commands to manipulate matrices on the gpu side
11:30:54 <Lokathor> EvanR, I've only been working with ogl for 3 weeks!
11:31:31 <Lokathor> I want to do this thing, then i will proceed with more general ogl learning again and load models and such
11:34:33 <Lokathor> I haven't eaten in 20 hours
11:41:34 <manek> Hi! Is it possible to define somehow a closed type family which will match on given predicate depending on the kind? like type family Foo (l :: k) m :: * where Foo l m = l; Foo l (Bar l t) = t
11:41:50 <manek> not that the firt predicate should be matched when the kind of `l` is `*`
11:42:01 <manek> unfortunetally GHC rejects it currently
11:42:08 <manek> *not -> note
11:46:15 <lyxia> manek: type family Foo' k (l :: k) m where {Foo' Type l m = l ; Foo' k l (Bar l t) = t} ; type Foo (l :: k) m = Foo'  k l m
11:48:38 * hackage json-feed 0.0.1 - JSON Feed  https://hackage.haskell.org/package/json-feed-0.0.1 (fozworth)
11:49:10 <manek> lyxia: thanks a lot! Yeah, it works this way. It's a lottle bit work-around, but yeah, thank tyou!
11:49:11 <manek> :)
11:49:46 <Lokathor> EvanR, I think that "hexes is curses for haskell, but in ogl" is the best way to sum up the library's primary goals
11:51:08 <Tuplanolla> How much do you hate life now that you have spent time with modern OpenGL, Lokathor?
11:51:32 <Lokathor> no more than i did otherwise
11:52:10 <Lokathor> I know just enough to load a texture, define some verts, and maybe move a camera (i didn't understand a lot of the math therE)
11:53:05 <EvanR> old opengl vs modern opengl has the symptom of being called the same thing
11:53:21 <EvanR> its like if you think youre about to drink a soda, and find out its water
11:53:28 <Lokathor> oh no!
11:53:51 <EvanR> assuming neither are bad by themselves, your expectations may frustrate you
11:54:26 <EvanR> if i just want to load a texture, define some verts, move a camera, modern opengl is terrible
11:54:33 <Lokathor> awh 
11:55:03 <EvanR> if i want fancy "functional" shader graphics old opengl would seem pretty terrible
11:55:33 <EvanR> if you didnt know better, youd think opengl just in general terrible
11:55:40 <Tuplanolla> Well, everything is a disappointment after seeing `lens` and a few other well-designed Haskell libraries...
11:56:03 <EvanR> and vulcan doesnt seem to be helping 
11:56:17 <Lokathor> EvanR, are you happy with any other graphical system?
11:56:28 <cocreature> vulcan -- draw a triangle using only 500 loc
11:57:02 <EvanR> Lokathor: cairo-backed purely functional image DSL? ;)
11:57:02 <Lokathor> cocreature, ogl lets you draw a triangle in 243 lines! https://github.com/Lokathor/learnopengl/blob/master/app/Lesson02.hs
11:57:09 <EvanR> or do you mean, for actual real life graphics
11:57:18 <Lokathor> more like the latter :P
11:57:44 <EvanR> im using data Picture =, and SDL right now
11:58:00 <EvanR> its working for sprites
11:58:23 <Lokathor> yeah i mostly liked SDL when i tried it, but i didn't want it for this project because it means you depend on an extra DLL
11:58:46 <EvanR> you tend to static link stuff in haskell anyway
11:59:02 <Lokathor> haskell's SDL stuff seemed to still depend on SDL.dll
11:59:41 <EvanR> ye olde give windows users a zip file containing a .exe and several .dlls ;)
11:59:57 <EvanR> i think on modern windows you can still access a folder that has been unzipped somewhere
12:00:17 <EvanR> as opposed to a google search style files ystem of OSX
12:00:49 <sm> Lokathor: hexes sounds interesting, when is the release ?
12:01:19 <Lokathor> sm, whenever i manage to finish it off. I hope to have a "demo" available by the end of the weekend
12:01:27 <Lokathor> since we have a long weekend (here in the US at least)
12:01:44 <sm> cool. Using it for some project yet ?
12:01:51 <Lokathor> sm, not yet
12:02:00 <Lokathor> EvanR, you could do all that, and if i was serious about a lot of kinds of rich 2d graphical things i probably would.
12:02:24 <Lokathor> but i really prize the ability to have a single-file program, even if it's like 10 or 15 mb all packed into a huge binary
12:02:34 <Lokathor> sm, probably a roguelike :P
12:06:02 <EvanR> Lokathor: i just tested my program for exe size... 70M 
12:06:07 <EvanR> dynamic SDL
12:06:16 <Lokathor> typical haskell :P
12:06:27 <Lokathor> gotta go to work though, chat later i'm sure we will
12:06:28 <EvanR> but then i got it down to 15M with no profiling and strip
12:12:22 <turnage> I have 1GB of memory on my machine and often have trouble compiling haskell libraries I'd like to use because of that. Are there any configuration options for ghc or alternatives that work better with little memory?
12:14:03 <Tuplanolla> I've had that problem, turnage. Passing `-M512M` helps avoid the swapping a bit.
12:14:24 <c_wraith> switching the linker to gold helps, too
12:14:34 <c_wraith> it uses a lot less memory than ld
12:15:42 <ongy> so what's the best way to compile a standalone .hs file with new-build setup? put it in a package and new-build it?
12:15:46 <p0a> Hey how can I try haskell online?
12:16:00 <sm> https://tryhaskell.org
12:17:01 <p0a> I also recall fphaskell or somethign. I thought I had an account and that they provided an IDE but now it appears unavailable?
12:17:06 <p0a> (i.e. commercial not free)
12:17:22 <p0a> that's cool though and probably sufficient for me, thanks
12:17:45 <sm> turnage: as well as ghc +RTS -M512m -RTS ..., you can try building fewer packages at one time
12:18:25 <sm> p0a: yeah, FP Complete's web IDE ended
12:18:42 <turnage> thanks for the tips!
12:18:42 <sm> it's on github I think
12:18:50 <p0a> yeah but I'm not trying to host
12:18:57 <p0a> I'm trying to use from a computer that doesn't let me install things
12:19:16 <p0a> it's nice of them to put it on github though
12:19:19 <sm> there's also haskell-likes, like http://code.world
12:19:58 <p0a> too bad noone has an online ide then
12:20:06 <sm> https://code.world/#Peb8NfjUBQ9udVsYvRnRW6Q
12:21:16 <p0a> lol
12:21:20 <p0a> that's cool
12:21:22 <Tuplanolla> You know you can install GHC and stuff without root permissions, p0a.
12:21:46 <p0a> yeah but then that'd mean I'd have to configure things to point at the right paths
12:21:47 <xa0> i have an issue with ghc -c -XForeignFunctionInterface, it generates errors like the following http://i.imgur.com/M6ZpAhT.png
12:21:55 <p0a> Tuplanolla: I'll try... maybe I'm just being an idiot
12:21:57 <xa0> clearly it's not linking dependencies
12:22:00 <xa0> but i have no idea why
12:22:32 <Tuplanolla> I've done that on university's RHELs and it wasn't excruciatingly difficult, p0a.
12:22:47 <p0a> this is window s
12:23:56 <wz1000> Type families are really cool: http://lpaste.net/355861
12:24:18 <sm> https://code.world/#Pl--ZeWkC75JysFu4vNaifg
12:24:48 <Tuplanolla> I've tried that too, but not hard enough to succeed, p0a.
12:25:53 <p0a> sm: oh that's cool beans
12:26:16 <p0a> sm: My idea was to write a library/game editor for card games 
12:26:43 <p0a> so that people can make up their own card games. I was hoping that art people would get into it (i.e. you draw/paint your own cards, simple enough rules but customizable etc)
12:26:53 <p0a> but for now I'd rather just mess around with haskell a bit
12:27:04 <p0a> surprisingly I'm getting a free day because a computer broke down and I can't work
12:27:21 <EvanR> wow a logical language to define card game rules?
12:27:26 <pikajude> English??
12:27:40 <jackhill> p0a: heh. Haskell stack might be a good option for doing an isolated Haskell install.
12:28:01 <shapr> hm, I can't stack install zeromq-haskell, it fails to build with the same error on both debian and ubuntu
12:29:00 <p0a> EvanR: that sounds good. 
12:29:28 <cocreature> shapr: what’s the error?
12:29:34 <orion> "GHC 8.2 will address this by introducing indexed type representations, leveraging the type-checker to verify programs using type reflection." -- is this the same 'reflection' (conceptually) used by the 'reflection' package?
12:31:14 <shapr> cocreature: http://lpaste.net/355862 
12:31:50 <shapr> cocreature: I tried to install libzmq5-dev but it selects libzmq3-dev, perhaps my zmq.h doesn't have zmq4 specs?
12:32:50 <sm> ha ha.. 2000 on that codeworld asteroids game, beat th-AAARGH
12:33:10 <cocreature> shapr: it looks like zeromq-haskell is ancient. you might want to use zeromq4-haskell or zeromq3-haskell instead
12:33:28 <p0a> 2000?
12:33:30 * shapr checks
12:33:31 * sm was reliving the quantum asteroids in guardians of the galaxy 2
12:34:36 <shapr> cocreature: doh, somehow I thought zeromq-haskell and zeromq4-haskell were the same package, thanks for fixing my thinko!
12:34:37 <tsahyt> is there a typeclass providing a kind of monomorphic functor? e.g. class Monofunctor a where { type Element a; monomap :: (Element a -> Element a) -> a -> a }?
12:38:02 <ericdwhite> Hi I have been looking at: http://devanla.com/drafts/read-you-a-scotty.html and found an expression I had never seen before
12:38:21 <ericdwhite> addRoute' r s@AppState {routes = cr} = s {routes = r : cr}
12:38:36 <ericdwhite> data AppState = AppState { routes :: [Route] }
12:39:11 <ericdwhite> My Question is the 's' in ... = s {routes = r:cr}.  Why is it not just ... = AppState {routes = r:cr}
12:39:26 <Athas> ericdwhite: it is a record update.
12:39:42 <Athas> It means 'return the record s, but changing the value of the field "routes"'.
12:40:41 <p0a> http://imgur.com/a/21A1z
12:41:02 <wz1000> ericdwhite: I think it could be witten that way, but this version won't have to change if more fields are added to AppState
12:41:38 * hackage wallpaper 0.1.0.0 - A library and executable for creatingwallpaper, frieze, and rosette patterns.  https://hackage.haskell.org/package/wallpaper-0.1.0.0 (jeffreyrosenbluth)
12:42:45 <p0a> whoever recommended stacks, I can't get it to work
12:42:49 <ericdwhite> Thanks.  I understand now, if you just want to change one field then you can use that record update syntax, but it still returns a instance.
12:43:07 <p0a> I think I'll just use ghci and notepad++ or something... 
12:58:38 <suzumiya_> Sorry to bother. May I ask how to deal with missing cabal extra-libraries which have already been installed in /lib? I can find the lib files in the /lib dir.
13:02:30 <Batzy> Ello
13:04:30 <koala_man> I have a [[Char]]. How can I efficiently generate all combinations of picking one character from each list? I tried just  mapM_ putStrLn $ sequence list  but it explodes in space
13:05:08 <EvanR> are the lists finite
13:05:11 <koala_man> yes
13:05:17 <EvanR> ok good
13:05:46 <EvanR> so the answer isnt uncountable
13:05:47 <jle`> koala_man: are you running wiht optimizations?
13:06:12 <koala_man> jle`: -O yes
13:06:21 <jle`> how about -O2 ?
13:07:15 <spoonm> I'm trying to rewrite my xmonad config and, apart from handling all the literals(the expressions will be taken care of, don't vomit just yet), can I in any way use guards for this? http://ix.io/vaL
13:07:43 <p0a> sm: did you see my high score?
13:07:49 <koala_man> jle`: it keeps growing. I killed it at 1.5GB RES
13:08:34 <koala_man> EvanR: it's very countable, just 10B+ 
13:09:24 <mniip> EvanR, the answer would never be uncountable
13:09:50 <mniip> koala_man, try +RTS -M1G
13:09:55 <mniip> maybe it's just the heap size
13:10:56 <p0a> I think I'm giving up on windows haskell
13:11:16 <koala_man> mniip: that does seem better
13:11:18 <p0a> I just downloaded the ghci. It's in a tar. There's only 7zip available. I tried to untar and it created a folder with a new tar file in it
13:11:39 <EvanR> mniip: "every combination of characters from each list" ?
13:11:50 <p0a> i.e. from each list one character
13:11:58 <mniip> EvanR, sure
13:11:59 <p0a> i.e. [alpha, number] gives a0 to z9
13:12:25 <mniip> or hmm
13:12:38 <mniip> maybe if they're all infinite
13:12:40 <p0a> mniip: it's a map of maps
13:12:42 <mniip> then alright
13:12:48 <p0a> oh for infinite lists?
13:12:49 <Cale> p0a: Are you sure you downloaded *Windows* GHC?
13:13:11 <p0a> Cale: it says mingw... oh 
13:13:28 <p0a> Cale: should I even try learning haskell or did I prove my incompetence already
13:13:33 <Cale> Oh, I see, interesting.
13:13:53 <Cale> It used to come in another package format. 8.0.2 apparently does come in a .tar.xz anyway
13:13:58 <p0a> Cale:     ghc-8.0.2-x86_64-unknown-mingw32.tar.xz (142.2 MB, sig)
13:14:01 <p0a> yeah that's what it is
13:14:11 <p0a> but the thing is, I can't untar it for the love of god
13:14:22 <Cale> Did you open the tar?
13:14:49 <Cale> .xz is a compression format, and .tar is an archive format (basically concatenates files and adds an index)
13:14:49 <p0a> well the 7zip file manager is clunky
13:15:08 <p0a> I guess I had to 'extract' (?) twice
13:15:11 <Cale> yeah
13:15:20 <p0a> probably because of what you described
13:16:02 <p0a> ah great thanks
13:31:59 <TyOverby> Does  anyone know if the haskell compiler does typechecking before or after lowering?
13:37:59 <Tuplanolla> Lowering?
13:38:26 <int-e> desugaring? ghc typechecks before desugaring, mainly to get better type error messages, I believe.
13:40:22 <c_wraith> ghc doesn't really do lowering. 
13:40:46 <c_wraith> the simpler constructs it compiles to as an intermediate step are not the same language 
13:41:38 <dmwit> p0a: modern tar should understand .xz/.gz/.bz, e.g. `tar xf whatever.tar.xz` works fine here
13:42:20 <dmwit> (x for extract, f for from a file, because we all know that "from the tape drive" is still the correct default)
13:43:17 <c_wraith> dmwit, windows. it doesn't have a command line tar tool unless you go out of your way to install one. 
13:43:57 <dmwit> You can do Windows without cygwin?
13:44:05 <dmwit> That doesn't sound right.
13:44:08 <dmwit> ;-)
13:45:15 <p0a> windows doesn't sound right in general
13:48:37 <pikajude> there's a good reason for that
13:48:46 <pikajude> dmwit: actually, there's WSL now
13:49:04 <pikajude> which, to be fair, doesn't have the ability to run 32-bit binaries
13:50:23 <c_wraith> too bad starting ghc takes like 20 seconds on WSL
13:50:29 <pikajude> yeah
13:50:50 <pikajude> having started to use windows as a desktop OS, i can confirm that "you'll have to go out of your way to install one" is the windows motto
13:53:40 <cocreature> maybe we should lern from the ransomware people. they seem to be pretty good at making their code easy to install
13:54:38 <spoonm> is this readable in any way? lol http://ix.io/vb1
13:55:43 <p0a> the ransomware lol
13:57:12 <bbaren> spoonm: You should hindent.
13:57:22 <spoonm> bbaren: hindent?
13:57:38 <bbaren> https://github.com/commercialhaskell/hindent
13:57:41 <spoonm> ooo
13:57:48 <spoonm> thanks, I'll try that
13:58:39 * hackage wallpaper 0.1.0.1 - A library and executable for creatingwallpaper, frieze, and rosette patterns.  https://hackage.haskell.org/package/wallpaper-0.1.0.1 (jeffreyrosenbluth)
14:13:09 * hackage superconstraints 0.0.1 - Access an instance's constraints  https://hackage.haskell.org/package/superconstraints-0.0.1 (RyanTrinkle)
14:24:39 <nico__> Hey I have a simple problem that i haven't been able to figure out on my own (I'm really new to haskell).
14:25:35 <nico__> Let's say I have a function func1 :: String -> Either b c, and a function func2 :: c -> String
14:26:04 <nico__> I need to use the result of func 1 (if its of type c) in func2
14:26:21 <nico__> how should I go about this?
14:27:39 <Tuplanolla> :t fmap func2 . func1 -- Like this, nico__?
14:27:41 <lambdabot> String -> Either b String
14:30:34 <nico__> I'm not sure, what I would like to get is the Right element from the either result
14:30:55 <Tuplanolla> You can use `fmap` to operate on the `c` in `Either b c` or pattern match on it.
14:31:57 <nico__> I'll try that
14:31:58 <nico__> Thanks!
14:34:27 <suzu> in lucid, is there any method to be able to modify a built Html element?
14:38:45 <suzu> seems like not.
14:39:05 <suzu> can constraints be read as implications?
14:39:22 <suzu> for instance, there is an instance: MonadState s m => MonadState s (HtmlT m)
14:39:46 <suzu> can i read that as, "If i have a MonadState s m instance for some s and m, then i also have a MonadState s (HtmlT m) for those s and m for free"/
14:39:47 <suzu> ?
14:39:49 <suzu> *
14:40:38 * hackage servant-auth-cookie 0.5.0.4 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.5.0.4 (zohl)
14:43:02 <lyxia> suzu: yes
14:43:43 <suzu> and i can also read it in the reverse with: "you get an instance of MonadState s (HtmlT m) if there's an instance MonadState s m for those s and m"?
14:44:59 <suzu> but you CANNOT read it as: having a MonadState s (HtmlT m) means there exists a MonadState s m for those s and m
14:45:13 <suzu> because that's not necessarily true
14:45:15 <lyxia> I don't think it works the other way around
14:45:27 <suzu> hmm. really?
14:45:32 <suzu> i always read it with that reverse reading
14:45:38 <lyxia> wait, I just misread
14:45:48 <lyxia> you are correct
14:45:56 <suzu> are both those statements i made there correct?
14:46:13 <suzu> the reverse reading works and that invalid reading is actually invalid?
14:46:22 <lyxia> "X if Y" is equivalent to "if Y then X"
14:46:38 <suzu> ah kk
14:52:08 <spoonm> lyxia: is `X if Y' valid in Haskell?
14:55:08 * hackage wryte 0.1.1.0 - Pretty output for source generators  https://hackage.haskell.org/package/wryte-0.1.1.0 (TobiasDammers)
15:06:11 <suzu> no but it is valid in ruby ;)
15:06:17 <suzu> but so are a lot of blasphemous things
15:25:09 <c_wraith> I like to override #nil? in NilClass to return false. 
15:25:09 <Hanslo> I'm unsure if this is the right place to ask a cabal question, apologies in advanced, what is the best way to get cabal to automatically resolve dependencies?
15:28:11 <AerialBoundaries> "Haskell from First Principles" costs $70 (with tax) in my country. That's... a lot of money.
15:30:00 <Hanslo> I was trying to cabal install opench-meteo, I received a list of rejected packages, and a "Dependency tree exhaustively seached." message. 
15:32:19 <suzu> the best way to fix a cabal problem is to stop using cabal, really
15:32:21 <suzu> use stack if you can
15:33:02 <suzu> AerialBoundaries: you can send an email to the authors and ask for a discount
15:33:14 <suzu> i've heard they're pretty cool with that if you're a student / financial issues / etc
15:33:20 <AerialBoundaries> suzu: oh, neat
15:33:23 <AerialBoundaries> thanks
15:33:25 <suzu> np
15:39:59 <dmwit> Hanslo: Automatically resolving dependencies is the default. "Dependency tree exhaustively searched" means there were conflicting constraints. It should have some details about why.
15:40:52 <dmwit> Hanslo: The package you mentioned has pretty light dependencies, so I'm a bit surprised by this. Can you hpaste/lpaste the exact error message?
15:40:56 <dmwit> ?paste
15:40:56 <lambdabot> Haskell pastebin: http://lpaste.net/
15:42:05 <dmwit> Hanslo: At a guess: perhaps your GHC is too old, and so the hard-wired `base` version you have (which can't be changed) doesn't meet the `base >= 4.8 && < 4.10` constraint.
15:47:52 <Hanslo> Thanks I will update my ghc, and give it another go
15:56:31 <FooBar`> Is there a way to get type class methods using TemplateHaskell
16:07:02 <pikajude> what do you mean by get?
16:07:17 <pikajude> like, if they're returned in the AST?
16:10:48 <c_wraith> FooBar`, are you looking for https://hackage.haskell.org/package/template-haskell-2.11.1.0/docs/Language-Haskell-TH.html#v:reify
16:12:39 <FooBar`> Ah yeah it's contained in the ClassI constructor
16:12:44 <FooBar`> I think that's it, thanks
16:14:50 <ph88^> how can i type a 0x0d as char literal in code ?
16:14:58 <pikajude> try 0x0d
16:15:20 <pikajude> oh, as a char literal, lol
16:15:22 <pikajude> I didn't read the char part
16:15:30 <pikajude> should be '\x0d'
16:15:33 <c_wraith> > '\x0d'
16:15:35 <lambdabot>  '\r'
16:15:55 <ph88^> thx
16:24:28 <dmwit> > "\xd00d\xd\&00d"
16:24:30 <lambdabot>  "\53261\r00d"
16:24:37 <dmwit> rude
16:24:51 <dmwit> rudedudes, the sister subreddit to madlads
16:25:15 <pikajude> http://www.fileformat.info/info/unicode/char/d00d/index.htm
16:25:18 <pikajude> that's not very exciting
16:25:39 <dmwit> Man, that railroad is messed up. 6/10 would not ride again
16:26:51 <dmwit> I wonder how they square "U+D00D is not a valid Unicode character" with the wealth of information otherwise available on that page.
16:28:49 <pikajude> maybe if it was a valid unicode character, the railroad would be intact?
16:30:38 * hackage morte 1.6.7 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.7 (GabrielGonzalez)
16:31:45 <ph88^> > '\x00'
16:31:47 <lambdabot>  '\NUL'
16:32:24 <felixphew> I've just found a (seemingly undocumented) function in alex's "monad" wrapper, and I'm wondering what it does
16:32:28 <felixphew> token :: (AlexInput -> Int -> token) -> AlexAction token
16:32:28 <felixphew> token t input len = return (t input len)
16:33:34 <felixphew> it's just sitting next to skip, begin, `andBegin` etc.
16:33:38 <pikajude> @pl \ a b c -> return (a b c)
16:33:38 <lambdabot> ((return .) .)
16:33:41 <pikajude> interesting
16:33:45 <dmwit> At a guess, without being an alex expert: `AlexAction a` is a type synonym for a two-argument function, and `token` is there so that if it ever becomes a proper type rather than just a synonym not all your code breaks.
16:34:12 <felixphew> that makes sense
16:34:15 <dmwit> That is, I expect you are supposed to code under the assumption that `AlexAction` is an opaque type.
16:34:26 <felixphew> I'm having a hard time getting my head around Alex
16:34:26 <dmwit> And `token` is there to make it just slightly more transparent. =)
16:35:52 <felixphew> I really wish there was some way to use startcodes without the "monad" wrapper
16:36:15 <felixphew> because my haskell isn't good enough yet to understand how it works
16:36:55 <felixphew> but unfortunately I can't think of a way to lex this syntax-from-hell without startcodes
16:38:17 <ph88^> what's the most efficient way to read 8 bytes with attoparsec and convert it to a real ?
16:38:32 <ph88^> i guess that would be a Double
16:38:38 <ph88^> can i directly memory map that without parsing ?
16:39:08 <dmwit> http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/Data-Attoparsec-Text.html#v%3adouble ?
16:39:36 <dmwit> Oh, nope, that seems to look for actual digits like "3.14".
16:41:13 <ph88^> ye i don't actually need to "parse" something here i think .. it should be the same representation in the file as in memory .. well hope endianness is the same at least ^^
16:41:14 <dmwit> So, a minor hobby-horse: there is no platform-agnostic way to get the bytes of a double. If your architecture allows it, you aren't really guaranteed anything (by the IEEE standard, anyway) about what order you get bits in.
16:41:32 <dmwit> So "same in the file as in memory" isn't quite so clear-cut as you might think.
16:42:07 <ph88^> ye let's just try to load it .. i can verify it after i have it working
16:44:18 <ph88^> maybe i need this?  https://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary-Get.html#g:15
16:47:18 <felixphew> dmwit: woud you mind giving me an example of how I might use "token"?
16:47:54 <ph88^> by the way .. how can i know how to optimize my data structures ?
16:48:25 <dmwit> felixphew: Dunno. What does the `AlexInput` data structure have in it?
16:48:57 <felixphew> type AlexInput = (AlexPosn,     -- current position,
16:48:57 <felixphew>                   Char,         -- previous char
16:48:59 <felixphew>                   [Byte],       -- pending bytes on current char
16:48:59 <felixphew>                   String)       -- current input string
16:49:01 <dmwit> felixphew: Forget I asked. Even after I know the answer to that, I think I am inexpert enough that I would confuse you by answering.
16:49:16 <felixphew> never mind then, and thanks anywy
16:49:59 <dmwit> ph88^: http://johantibell.com/files/haskell-performance-patterns.html#%281%29 perhaps
16:50:15 <ThreeFx> ph88^ It certainly looks fast enough
16:50:15 <dmwit> ph88^: Also the "faster, smaller" section of the GHC manual for the really basic advice.
16:51:41 <dmwit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/sooner.html
17:02:03 <ph88^> how can i use this with conduit?  https://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary-Get.html#v:runGetIncremental
17:02:13 * hackage write-buffer-core 0.1.0.0, write-buffer-stm 0.1.0.0 (parsonsmatt): https://qbin.io/ys10z0h8w
17:04:47 <dmwit> ph88^: https://hackage.haskell.org/package/binary-conduit-1.2.4.1/docs/Data-Conduit-Serialization-Binary.html#v:sinkGet perhaps?
17:05:19 <ph88^> wow cool
17:05:44 <ph88^> i was also looking at take from  https://hackage.haskell.org/package/conduit-0.2.2/docs/Data-Conduit-Binary.html
17:06:14 <Myrl-saki> Is `init` O(n)?
17:06:21 <dmwit> yes
17:06:39 <Myrl-saki> Oh welp.
17:07:28 <dmwit> If you need to repeatedly push/pop from the end of a list, consider reversing it once for O(n), then repeatedly using head/tail instead of last/init for O(1) each instead of O(n) each.
17:07:39 <dmwit> If you need access to both ends, consider using Seq (which is based on finger trees).
17:08:15 <dmwit> Seq has amortized O(1) access to both ends.
17:08:25 <Myrl-saki> createInput k = reverse . drop k . reverse . map (take k) . tails
17:08:35 <Myrl-saki> I just realized that that's O(n^2)
17:09:32 <Myrl-saki> I'm thinking of using Seq to fix that by changing the loop by using the Seq version of tail and append.
17:09:54 <dmwit> `reverse . drop k . reverse = ap (zipWith (flip const)) (drop k)`
17:10:03 <dmwit> ...ish?
17:10:11 <dmwit> :t \k -> ap (zipWith (flip const)) (drop k)
17:10:13 <lambdabot> Int -> [b] -> [b]
17:10:15 <Myrl-saki> dmwit: The problem is `map (take k)`
17:10:53 <dmwit> Are you sure that's a problem?
17:11:00 <Myrl-saki> dmwit: Yes, that's O(n^2).
17:11:03 <dmwit> It's only going to do as much work as you touch elements anyway.
17:11:28 <dmwit> It's not O(n^2), it's O(k*n). And it's lazy, so you only pay O(k*n) if you're going to touch (k*n) elements, which is certainly O(k*n) anyway.
17:11:53 <Myrl-saki> Mmmm... true.
17:12:05 <Myrl-saki> The problem is large values of k then.
17:12:20 <dmwit> However, the `reverse . drop k . reverse` part *is* a problem, because it forces the whole spine into memory.
17:12:37 <dmwit> The fancy zip-y version is productive.
17:12:56 <dmwit> > ap (zipWith (flip const)) (drop 3) [1..5]
17:12:58 <lambdabot>  [4,5]
17:13:09 <dmwit> > ap (zipWith const) (drop 3) [1..]
17:13:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:13:21 <dmwit> Yikes! I've got it very wrong somehow.
17:13:31 <dmwit> > ap (zipWith const) (drop 3) [1..5] -- oh, lol
17:13:33 <lambdabot>  [1,2]
17:14:19 <dmwit> I wanted to do `[1..]` next anyway, to show that it is indeed productive, so... yay, that's already out of the way!
17:15:05 <Welkin> what was with the flip const
17:15:14 <dmwit> A mistake.
17:15:26 <dmwit> I make those sometimes. Sorry.
17:23:37 <ph88^> how can i say that b should be of type Double in this type signature?     :: (DB.Binary b, MonadThrow m) => Conduit BSC.ByteString m b
17:24:54 <geekosaur> that depends on the context: if that is a signature given to you, just add a type ascription in the right place
17:25:19 <ph88^> what's a type ascription ?
17:25:20 <geekosaur> if it is something you actually control, why are you starting from a more polymorphic form than you need?
17:25:27 <geekosaur> > (1 :: Int)
17:25:29 <lambdabot>  1
17:25:57 <geekosaur> that is, specify the type when/where you use it, don't try to change the signature
17:26:06 <ph88^> https://hackage.haskell.org/package/binary-conduit-1.2.4.1/docs/Data-Conduit-Serialization-Binary.html#v:conduitDecode
17:26:16 <geekosaur> ok?
17:27:06 <geekosaur> so just make sure when you use it that you specify the type you want out of it as Double
17:28:01 <geekosaur> since this is monadic, one way to do it is turn on ScopedTypeVariables (because it ate the extension you really want some years ago...) and say something like:
17:28:14 <geekosaur> (v :: Double) <- conduitDecode
17:29:39 <ph88^> looks delicious
17:33:33 <james999> why can't i see haskell in ubuntu software center?
17:33:33 <n_blownapart> hi if I execute from the cli stack works fine, but I get errors when I run stack ghci or ghci , please look here: http://lpaste.net/355872
17:35:09 <n_blownapart> james999: go here : https://docs.haskellstack.org/en/stable/install_and_upgrade/#ubuntu
17:35:29 <n_blownapart> there's no apt-get packages
17:35:53 <ph88^> james999, https://docs.haskellstack.org/en/stable/install_and_upgrade/#ubuntu
17:38:03 <james999> i'm really trying not to go straight to the command line
17:38:10 <james999> but if this doesn't work i'm just gonna try apt get
17:39:22 <n_blownapart> no there's no package for the compiler. the easiest way is from the command line
17:39:49 <james999> the link you gave me says there is
17:39:59 <james999> for my exact version and arch. -_-
17:40:22 <n_blownapart> good luck I couldn't find any
17:40:34 <n_blownapart> I have debian which is apt-get
17:41:04 <james999> that's what i'ma bout to try next. :D
17:41:10 <james999> debian that is
17:43:59 <n_blownapart> james999 just follow the directions on the page. the hardest part is setting the PATH in .bashrc 
17:44:22 <james999> sigh. this is why linux will never go anywhere
17:44:27 <james999> thanks n_blownapart I'll do that
17:45:07 <n_blownapart> james999: I'm having troubles too. It's fun and pretty interesting.
17:48:21 <james999> lol oh?
17:48:47 <james999> i'm just trying to get these VMs updated before I leave for food. not looking good so far
17:50:09 <james999> no luck in debian either
17:50:18 <james999> can i even install emacs? let's see
17:51:42 <dmwit> I find it very hard to believe that Ubuntu doesn't have a GHC package.
17:52:13 <ph88^> how can i run attoparsec on a conduit first and then later run another conduit ?
17:52:33 <dmwit> james999: At least on my machine (16.04) there definitely is a GHC package. Named ghc.
17:52:35 <ph88^> so first part of stream handled by a function, second part of stream handled by another function
17:53:16 <james999> dmwit: i'm also running 16.04
17:53:18 <james999> i think
17:53:22 <james999> uname didn't say
17:53:58 <dmwit> n_blownapart: Why do you have a `Lib` module in multiple packages? Don't do that. Or use package-imports to disambiguate, but it's usually much simpler to "don't do that".
17:54:31 <dmwit> james999: So... is your problem solved now?
17:55:18 <james999>  can you tell me if the ubuntu software thing
17:55:33 <james999> does it have 3 tabs saying All Installed Updates on top?
17:56:23 <dmwit> I suggest using synaptic, if you really need a GUI for your package management.
17:56:31 <dmwit> I've never liked the Ubuntu Software Center.
17:56:34 <james999> I already searched for it
17:56:36 <james999> didn't come up
17:56:41 <exio4> james999: sudo apt-get install ghc
17:56:43 <exio4> what does it say?
17:57:31 <dmwit> james999: Dunno, then. When I search for synaptic in Ubuntu Software Center the only hit is the right one. I agree that searching for ghc doesn't turn up the right stuff, though (synaptic does better here).
17:58:35 <james999> exio4: it wants to install 40MB of stuff including ghc, libbsd-dev, and libncurses5-dev
17:58:49 <dmwit> Sounds right to me.
17:59:38 <james999> alright well i gave the GUI a try
17:59:43 <james999> thanks for the help guys
18:01:08 <aijony> I could be wrong, (and I am a Haskell newb) but I think Ubuntu has stack. However it lags behind. 
18:03:25 <james999>  ok aijony you're right haskell-stack is available
18:03:36 <james999> it is less than 40 MB though. lol
18:03:44 <james999> is it not ghc?
18:04:17 <aijony> It will install it's own sandboxed GHC. I really like it.
18:04:26 <aijony> *its
18:04:42 <james999> er ok...
18:04:55 <james999> i think the book uses ghc though
18:05:53 <aijony> You do you :)
18:06:17 <aijony> But it handles GHC and everything else for you.
18:07:08 <n_blownapart> still having errors like this:  http://lpaste.net/355872
18:07:14 <n_blownapart> any help please?
18:08:18 <srk> what's the problem if stack ghci works?
18:08:24 <srk> looks like you don't have system ghci installed
18:09:27 <ph88^> if i do runConduit on a sourceFile can i then afterwards run another conduit where the previous one left off ?
18:12:35 <james999> what on earth is 'cabal'?
18:13:07 <srk> package management/build tool
18:13:28 <sm> n_blownapart: what's the file like in that directory ?
18:13:32 <sm> the cabal file
18:13:47 <n_blownapart> srk sorry could you elaborate on ghci? this is a 32bit debian system. haskell-stack with Atom haskell-ide work fine on a 64bit debian machine
18:13:53 <n_blownapart> sm one moment thanks
18:14:25 <sm> I think "stack ghci PACKAGE" will work
18:15:07 <sm> or it it EXECUTABLE. Eg "stack ghci primality"
18:18:00 <n_blownapart> sm one sec having trouble with chat client on one machine and haskell on another
18:18:17 <n_blownapart> sm please look at this - http://lpaste.net/6673003817786671104
18:18:38 <sm> success
18:20:02 <n_blownapart> sm but $ stack exec primality-exe  causes errors
18:20:27 <sm> oh ? show us
18:22:59 <n_blownapart> weird, that runs the program. but if I enter $ ghci I get command not found. If I enter $ stack ghci I get that initial error: http://lpaste.net/355872
18:23:46 <n_blownapart> on the 64bit machine $ stack ghci gives me a repl prompt
18:24:40 <sm> your package probably has multiple executables defined in the cabal file; for "stack ghci", stack doesn't know which one you want, so warns you
18:25:11 <n_blownapart> sm the cabal file for which app?
18:25:18 <suzu> :t (>=>)
18:25:19 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:25:23 <sm> I assume you have one cabal file in your current directoy
18:26:14 <suzu> :t (>>=)
18:26:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:27:42 <sm> n_blownapart: is that right ?
18:28:31 <n_blownapart> sm sorry one moment please I am emailing myself to get the pastes
18:29:52 <n_blownapart> here's the cabal file for primality app sm
18:29:55 <n_blownapart> http://lpaste.net/8249268218556841984
18:30:10 <sm> is there a cabal file in ~/haskell ?
18:30:19 <n_blownapart> checking
18:30:21 <sm> or a stack.yaml file ?
18:31:18 <n_blownapart> no neither, but a primality.hs file outside the project dir sm
18:31:32 <n_blownapart> outside the primality project dir
18:31:36 <suzu> :i (>=>)
18:32:26 <n_blownapart> is that causing a problem ?
18:32:27 <n_blownapart> sm
18:32:46 <sm> shouldn't be. I'm not sure why "stack ghci" gives you that warning.
18:33:22 <sm> if you want to try something fun, there's http://hackage.haskell.org/package/debug-me
18:33:56 <sm> but the workaround is simple - give it a package name, right
18:35:58 <clamchowder> I'm tried the following code which didn't work:
18:36:29 <clamchowder> do {s1; if s2 then return v1 else return v2}
18:36:55 <clamchowder> ghci complains "possibly missing a "do"?"
18:37:00 <n_blownapart> thanks sm I'll work on both 64 and 32bit machines side by side tonight. appreciate it.
18:37:06 <sm> good luck
18:37:11 <n_blownapart> pax
18:37:32 <clamchowder> But I have a do at the beginning so why?
18:39:09 <n_blownapart> strange still: $ ghci or $ stack ghci     does not give me the repl, but "command not found"
18:40:05 <sm> n_blownapart: "ghci" is not found because you haven't installed a ghci outside of stack - you can get that eg from your package manager or http://haskell.org/ghc
18:40:05 <clamchowder> Ah actually I just tried on ghci and it works for list... I was trying to simplify my problem but I guess the simplification is wrong, sorry.
18:40:17 <sm> "stack ghci" runs a ghci that stack manages itself
18:40:49 <n_blownapart> sm checking that thank you kindly
18:48:59 <n_blownapart> sm thanks so much YEAH I'm off to learn how to do math proofs on haskell !
18:50:27 <sm> see you
19:18:45 <halogenandtoast> So this seems odd, I have two copies of the same website, one on Keter and one without and the Keter website seems noticeably slower.
19:18:51 <halogenandtoast> Anyone have that experience
19:28:22 <halogenandtoast> Both servers are in the same region.
20:14:52 <suzu> :t (>=>)
20:14:53 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:15:00 <suzu> :t liftM3 (>=>)
20:15:01 <lambdabot> (Monad m, Monad m1) => m1 (a -> m b) -> m1 (b -> m c) -> m1 a -> m1 (m c)
20:15:19 <suzu> :t liftM2 (>=>)
20:15:21 <lambdabot> (Monad m, Monad m1) => m1 (a -> m b) -> m1 (b -> m c) -> m1 (a -> m c)
20:16:51 <c_wraith> If you ever need that, you're writing some convoluted code. :)
20:17:02 <suzu> i certainly am, lol
20:17:16 <suzu> i'm currently somewhere in the weeds of digestive-functor
20:17:23 <c_wraith> ah, that explains it
20:17:29 <suzu> have you used it before?
20:18:22 <c_wraith> no, but I remember the author going through the process of writing it - he had a bunch of design changes several times as he tried to figure out how to make things make sense
20:18:32 <suzu> lol, makes sense
20:18:41 <suzu> i'm trying to chain two validating functions together
20:18:50 <suzu> this wouldn't be so hard if those validations didn't need to run in a monad
20:19:15 <suzu> so i'm trying to figure out the right lift and right glue to stick in here to get everything to typecheck so i can move onto more fun things
20:19:17 <suzu> lol
20:24:05 <EvanR> "validations have to run in a monad" :(
20:24:35 <EvanR> are you sure you cant pass in the function or context for that one piece you think you need a monad for
20:26:13 <suzu> i.. maybe can
20:26:17 <suzu> but i think this is the right method
20:26:32 <suzu> there's a few functions provided for doing your validations in an arbitrary monad, so i think this is the right approach
20:29:07 <codygman___> I'm curious what #Haskeller's think of Jonathan Blow's Jai language: https://inductive.no/jai/
20:32:17 <Cale> codygman___: It's not something that I can really ever see myself using, but there are some interesting aspects about it.
20:46:09 * hackage fltkhs 0.5.1.9 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.1.9 (deech)
21:08:08 * hackage sbv 6.1 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-6.1 (LeventErkok)
21:09:14 <codygman___> Cale: cool, thanks
21:20:45 <Batzy> is there an escape character in Haskell? Usually you see like \ in programming languages
21:21:15 <cocreature> Batzy: yes \ :)
21:21:42 <Batzy> i guess my problem is something else thaen
21:21:45 <Batzy> then*
21:21:48 <cocreature> what are you trying to do?
21:21:53 <Batzy> cocreature, remove a directory
21:21:56 <glguy> Batzy: Character and string literals: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#dx7-20001
21:22:23 <Batzy> so i have like removeDirectory "C:\\path\\ay\\lmao"
21:22:37 <suzu> lol nice path
21:23:13 <Batzy> haskell doesnt think so
21:23:32 <Batzy> anyways it's saying variable not in scope
21:23:44 <geekosaur> that sounds like something else is wrong
21:23:49 <Batzy> yes it does.
21:24:03 <geekosaur> we don't have variable interpolation into strings like some languages do, so that error has to come from something other than the string
21:24:13 <geekosaur> unless you also have a mis-escaped double quote somewhere
21:24:18 <geekosaur> @paste actual code and full error?
21:24:19 <lambdabot> Haskell pastebin: http://lpaste.net/
21:25:08 <Batzy> https://i.gyazo.com/3a9ee4e89b14386185ee042bc69fb0a8.png
21:25:14 <Batzy> and that was the actual code
21:25:31 <Batzy> oh wait
21:25:35 <Batzy> there's a capital U in the path
21:26:14 <Batzy> oh wait it didn't have the escape characters i just added them and now the error has changed!
21:31:30 <Batzy> here's the error: https://i.gyazo.com/abbaeee92790222cb43c82437a270fbf.png
21:31:51 <cocreature> import System.Directory
21:33:29 <Batzy> :(
21:33:31 <Batzy> u were right
21:39:01 <halogenandtoast> Any ideas for a Haskell project to learn free monads?
21:39:11 <halogenandtoast> Maybe something I could complete in 3 hours or so?
21:42:10 <Welkin> halogenandtoast: write an interpreter?
21:42:28 <Welkin> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
21:43:40 <dmwit> halogenandtoast: How about a parser monad that you can interpret one way to parse a string, and another to generate a string that would successfully parse?
21:45:19 <halogenandtoast> Alright, I'll look into that.
21:45:27 <halogenandtoast> Maybe I'll write an interpreter for my crappy language.
21:45:28 <lpaste> glguy pasted “more haskell.vim fixes” at http://lpaste.net/355873
21:46:21 <glguy> So I've got hierarchical modules added, fixed \^A escapes, fixed string gaps (\   \)   allowed _ as the first character of an identifier
21:46:30 <glguy> What else do we need to fix in the Haskell syntax highlighting file?
21:49:03 <halogenandtoast> Welkin: I managed to finally deploy an app with Keter. Seems nice, but I assume I want to precompile my keter file and then just scp it up
21:49:08 <halogenandtoast> Maybe with Docker?
21:49:18 * halogenandtoast thinks we talked about Keter before
21:49:49 <Welkin> yes
21:50:10 <Welkin> all keter does it zip up your files in a tar
21:50:18 <Welkin> you could do it yourself if you want
21:50:22 <Welkin> that's how I do it
21:50:42 <Welkin> I just wrote a bash script to tar up everything, copy the correct files in, and then scp it to the server
21:50:43 <halogenandtoast> right but if I compile on my mac, it won't work on Ubuntu is my assumption
21:50:52 <Welkin> yes, that's true
21:50:55 <Rotaerk> hmm I see mention from Gabriel back in 2013 of "Edge" wrappers around Pipes that allow for an Arrow instance for push-based pipes, which allow you to make a directed acyclic graph
21:50:56 <Welkin> you need to compile on linux
21:51:04 <halogenandtoast> so use Docker to compile then scp it
21:51:13 <Rotaerk> there was also mention of him making a pipes-arrow library
21:51:21 <Rotaerk> but I don't see anything like that ... any idea why it never happened?
21:51:23 <halogenandtoast> Cool, I'll see if I can set that up
21:51:45 <halogenandtoast> I like the format Keter provides (aside from having to compile in Docker, but I'd pay that price with any compiled language I assume).
22:11:32 <mclaren> hey, i wanted to ask about the vastness of the Haskell wiki. Is it really well documented like the Arch Linux wiki or?
22:13:42 <james999> i don't think anything compares to the arch wiki
22:13:51 <james999> and i don't even use arch but i use their wiki
22:14:04 <codygman_> Anyone remember the name of that Excel like software posted in r/haskell that let you use haskell expressions for each cell?
22:14:15 <mclaren> yeah, its very expansive
22:14:25 <mclaren> but i meant, is the haskell wiki similar to it
22:14:45 <kadoban> Similar in what way?
22:14:53 <kadoban> In terms of quality you mean?
22:15:02 <mclaren> yeah
22:16:11 <kadoban> I've heard generally good things about it. I don't recall anyone expressing strong negative opinions of it. But I haven't spent a ton of time there myself. The few parts I have seemed good.
22:17:24 <mclaren> oh alright, thanks
22:22:41 <mnoonan> codygman_: I think this is the one: http://www.alphasheets.com
22:45:43 <halogenandtoast> I just used ghci and accidentally typed ":q" thanks to my vim habits
22:45:48 <halogenandtoast> found out that works...
22:47:45 <MarcelineVQ> what did you used to do? :>
22:49:37 <halogenandtoast> MarcelineVQ: Ctrl+D
22:51:05 <wz1000> Ok, so I have two types(say A and B) i want to decode from json. Both share a common field, say f :: String, and the type of the incoming json is dependent on the contents of f. How do I achieve this?
22:52:56 <halogenandtoast> wz1000: Name them differently in A and B and then specify how to decode manually
22:53:05 <halogenandtoast> Unless someone has a better answer
22:53:30 <halogenandtoast> wz1000: Here's an example where I manually decode: https://github.com/halogenandtoast/mirin/blob/master/app/Main.hs#L41
22:54:09 <wz1000> halogenandtoast: Name what differently?
22:54:10 <pacak> wz1000: You can decode things manually
22:54:39 <wz1000> But I still need to decide whether I want to decode to type A or type B
22:54:43 <halogenandtoast> wz1000: If A and B are different records in Haskell
22:54:47 <halogenandtoast> they can't share the same field name
22:55:08 <halogenandtoast> see: s
22:55:09 <pacak> takeF >>= \f -> if blah f then decodeBlah f else decodeNotBlah f
22:55:12 <halogenandtoast> https://wiki.haskell.org/Name_clashes_in_record_fields
22:55:43 <wz1000> halogenandtoast: They can because of OverloadedFields, but thats irrelevant because the JSON field has the same name
22:55:52 <halogenandtoast> you probably mean DuplicateRecordFields
22:55:57 <halogenandtoast> but sure
22:55:59 <wz1000> Yeah
22:56:05 <pacak> wz1000: Parser in aeson is a monad.
22:56:42 <pacak> Since A and B are two differnet types - put them in a sum type
22:56:45 <pacak> Either A GB
22:56:48 <pacak> Either A B
22:56:57 <pacak> And later decide what do you want to do with them.
22:57:19 <halogenandtoast> wz1000: You could also make a type that just decodes that one field and decide what to do.
22:57:39 <halogenandtoast> But I'd probably listen to pacak as he probably knows more than I do.
22:58:19 <wz1000> halogenandtoast: But then I would essentially have to decode the JSON twice, once to get the field, and once for the actual decoding
23:00:15 <halogenandtoast> Do what pacak is saying with a sum type.
23:00:23 <halogenandtoast> then your fromJSON can parse the one field
23:00:30 <halogenandtoast> err
23:00:36 <halogenandtoast> your parseJSON can parse the one field
23:00:41 <halogenandtoast> then decode the rest as needed
23:00:49 <halogenandtoast> only one call to parseJSON
23:01:04 <pacak> Or you can use Alternative / MonadPlus
23:01:10 <pacak> But again - with a sum type
23:01:51 <pacak> parseA = takeF >>= \f -> guard (f == "foo") >> Left <$> parseRestA
23:01:51 <pacak> parseB ...
23:02:01 <pacak> parseAOrB = choice [parseA, parseB, ... ]
23:03:12 <systemfault> Is there going to be a new standard? The last one is about 7 years old, right?
23:03:45 <pacak> systemfault: What would you like to see in a new standard?
23:04:37 <angerman> joeyh: Cross Compiling Yesod to Raspberry Pi - https://medium.com/@zw3rk/cross-compiling-yesod-to-raspberry-pi-f14de6fdbf06 -- Happy Birthday! (assuming Reddit is correct) :D
23:06:03 <systemfault> pacak: I'm not sure, it just seems to me that how people uses GHC today is so disconnected from the current state of Haskell... So it would make sense to me if the standard would be updated with whatever GHC extensions the community feels should become standard.
23:06:56 <systemfault> Perhaps I'm just not getting it, I'm still learning.
23:07:44 <pacak> I just pretend that Haskell == ghc.
23:07:55 <pacak> And it kind of works.
23:08:41 <systemfault> Doesn't that replicate the classic C++ problem where everyone has its own subset of the language?
23:09:09 <LiaoTao> systemfault: What do you mean by "how people uses GHC today"?
23:10:11 <pacak> systemfault: Are there any other implementations that's not ghc and alive?
23:10:14 * angerman is using GHC "today".
23:10:22 <systemfault> LiaoTao: The multiple language extensions, a few newer proposals that were "fairly recently" included (like AMP/FTP)
23:10:27 <angerman> pacak: mu?
23:11:02 <angerman> pacak: eta? Well, somewhat ghc but deviating...
23:11:45 <pacak> angerman: Hmm... Mu - is it publically available? I don't know.
23:12:05 <angerman> pacak: publically, no. I don't think so.
23:12:12 <cocreature> systemfault: people are working on a new Haskell standard
23:12:16 <angerman> but it's pretty much alive I guess.
23:12:46 <cocreature> but tbh I don’t think it will change a lot
23:12:58 <pacak> Eta - yes, but it's version 0.0.6.
23:12:58 <systemfault> Usually, when you learn a language... you learn the syntax and then you can read any code written in it, you just learn the ecosystem and libraries. Haskell is different to me in that aspect, because the syntax/language itself changes depending on pragmas.
23:13:00 <angerman> bah, getting yesod to work wasn't *that* hard... writing the post took *a lot* longer.
23:13:22 <angerman> systemfault: you've gone into lens already? ;p
23:13:29 <LiaoTao> systemfault: This is also sort of bothering me
23:13:36 <pacak> systemfault: Syntax in haskell is simple. Libraries and ideas are hard.
23:13:38 <systemfault> angerman: It's on my list :p
23:13:39 <pacak> :t confusing
23:13:40 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
23:13:43 <LiaoTao> Seems like many of these extensions should be included in the next standard
23:13:55 <pacak> ^ nothing to do with extensions :)
23:14:04 <angerman> pacak: that's some pretty spicy yoneda rigth there.
23:14:34 <cocreature> the more extensions you include in the standard the harder it becomes to write a compiler that actually implements all of the standard. and that makes the standard kind of useless
23:14:39 <angerman> LiaoTao: well, there was some informal voting on extension during last years icfp.
23:15:20 * angerman likes LambdaCase, but that didn't feel like there was a majority for it during ifcp, at least to my subjective understanding.
23:15:51 <cocreature> LambdaCase is at least easy to implement
23:16:01 * pacak likes LambdaCase as well
23:16:34 <EvanR> according to SPJ implementing anything like ghc is just too hard period
23:16:39 <EvanR> its too late
23:16:49 <systemfault> One compiler to rule them all
23:16:49 <EvanR> its too big
23:17:23 <systemfault> Anyway, Haskell is hardly the only language with a "single" compiler
23:17:25 <LiaoTao> cocreature: I don't see how it's a lot different right now
23:17:35 <angerman> I guess it's the siliar to someone trying to write the JVM from scratch.
23:17:35 <LiaoTao> We've basically got GHC that's the end-all solution
23:18:04 <cocreature> LiaoTao: right but if you want it to stay that way you don’t need a standard
23:18:22 <cocreature> which is a valid point of view and I would largely agree with that
23:18:34 <cocreature> but if you put work into a standard, the goal should be that there can be other compilers
23:18:46 <LiaoTao> Naturally
23:19:05 <EvanR> there were others... long ago
23:19:07 * angerman 'd rather see time devoted to tooling around haskell, rather than spent on standardizing though... I know... I'm selfish.
23:19:08 <LiaoTao> But a standard shouldn't necessarily be the bare minimum if anyone still just ends up using extensions to fill the gaps
23:19:21 <sullyj3> in the 2020 standard github, someone suggested `case of { P1 -> e1; P2 -> e2 }` which I prefer
23:19:23 <LiaoTao> It's not like they are mutually exclusive tasks, angerman 
23:19:39 <angerman> LiaoTao: if you have a tiny group of folks who work on things. Yes it is.
23:19:56 <LiaoTao> Fair point
23:22:53 <angerman> e.g. cabal can probably use any hand it could get.
23:26:56 <jle`> :w
23:27:07 <angerman> jle`: wrote.
23:27:25 <pacak> jle`: command not found: :w
23:27:32 <jle`> kkkjkk
23:27:33 <EvanR> local leader s
23:27:38 <EvanR> pls
23:27:47 <jle`> ah, sorry
23:28:25 <angerman> so who is interested in android cc? ;-)
23:28:43 <EvanR> rpi plz
23:29:19 <angerman> EvanR: you did see: https://medium.com/@zw3rk/cross-compiling-yesod-to-raspberry-pi-f14de6fdbf06 ?
23:29:56 <EvanR> no, reading
23:30:35 * pacak wants to run haskell in browser. Natively.
23:30:58 <angerman> If somethings unclear, or missing, or additional wishes, it's probably best to discuss that on the accompanying reddit thread: https://www.reddit.com/r/haskell/comments/6dm6j8/cross_compiling_yesod_to_raspberry_pi/
23:31:03 <systemfault> I'm also think of using a web framework... Yesod seems to have the most feature but has that template haskell stuff I'm not even close to learning. So I was thinking about Snap. Does anyone have an opinion on that?
23:31:18 <pacak> systemfault: snap = haskell. yesod = not haskell.
23:32:18 <systemfault> I also look at other alternatives but they seemed too simple
23:32:50 <systemfault> Snap has modules and that made it interesting to me.
23:33:03 <angerman> EvanR: that way (reddit) there is some public log of Q/A
23:33:38 <angerman> The choice for Yesod, was mostly due to TH, and because I knew it had some largish dependency graph.
23:34:00 <cocreature> systemfault: there is also servant which is pretty popular these days especially for APIs but it requires some fairly advanced type-level extensions
23:34:17 <systemfault> Will take a look at it
23:34:28 <angerman> there's also spock.ly
23:34:29 <Sh4rPEYE> Hey. I'm writing a simple parser for negative integers. I know how to parse integers, but I don't see a way how to check if there is a '-' before them. Something along the lines of 
23:34:30 <Sh4rPEYE> num <- ((-1 * ) <$> try char '-' >> base10Integer) <|> base10Integer
23:34:44 <angerman> err https://www.spock.li
23:35:22 <pacak> Sh4rPEYE: sign = negate <$ char '-' <|> pure id
23:35:50 <pacak> Sh4rPEYE: sign <*> base10Integer
23:36:10 <Sh4rPEYE> pacak: Thanks. Never head about "<$", will look it up
23:36:18 <pacak> :t (<$)
23:36:20 <lambdabot> Functor f => a -> f b -> f a
23:36:29 <EvanR> fmap (const negate) (char '-')
23:36:33 <EvanR> is another way to say it
23:37:00 <pacak> Yep.
23:37:21 <pacak> @src (<$)
23:37:22 <lambdabot> (<$) = (<$>) . const
23:38:09 <pacak> Sh4rPEYE: <*>, <*, *>, <$>, <$, $>
23:38:41 <pacak> Also there's such heresy as <&>
23:39:50 <EvanR> good old fashioned light side and dark side
23:40:02 <Sh4rPEYE> pacak: Pardon my ignorance, but what does it mean to fmap const over parser? It'd seem to me that it would completely discard the "thing inside the Praser structure" and replace it with negate.
23:40:18 <EvanR> it doesnt discard the parsing effect though
23:40:22 <pacak> Sh4rPEYE: Only if it matches
23:40:28 <pacak> That is it's char '-'
23:40:53 <EvanR> you dont care about '-' but you do care if it began with a '-'
23:41:11 <Sh4rPEYE> Oh yeah, so it discard just the Success result
23:41:34 <EvanR> negate if it succeeds, id if it didnt
23:42:02 <angerman> pacak: regarding native browser stuff, there is some HSOC student who wants to do a WASM LLVM backend... so we might get there...
23:43:13 <pacak> angerman: I've seen that. Just curious how long it will take to make and how big compiled project will be.
23:43:15 <cocreature> the hsoc projects look very cool this year
23:43:54 <angerman> pacak: it pretty much depends how well wasm maps to cmm (for the ghc-llvm) part.
23:44:27 <angerman> pacak: code-size wise, I would hope there could be some synergy between the mobile stuff and the native wasm stuff.
23:44:33 <pacak> I'm kind of upset by current state of javascript depelopment. Minimal sized react project is ~500Mb - that seems kind of wrong.
23:45:02 <cocreature> angerman: I’m not sure if that’s the critical part. I think porting the GHC RTS to wasm is probably more challenging
23:46:07 <angerman> pacak: yea, in general we should be able to do much better with file size I would hope. Even the yesod on rpi sample is ~56mb
23:46:20 <pacak> Especially I like the fact that it contains about 10 mostly identical copies of rifraf project, the only purpose of which is to get around the fact that rm -rf on windows is crap.
23:46:23 <EvanR> pacak: 500M of ... what?
23:46:26 <EvanR> text?
23:46:42 <Sh4rPEYE> Pacak: Thanks much for the help! Beautiful indeed
23:46:44 <angerman> cocreature: hmm that will be interesting. But at least it's "just" c :-)
23:46:44 <pacak> EvanR: javascript.
23:46:51 <EvanR> how is that even possible
23:46:59 <pacak> 500 megabytes of javascript.
23:47:01 <angerman> cocreature: and a few stupid cmm snippets, which you'd probably want to use ghc on any way :)
23:48:23 <pacak> EvanR: https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/ 
23:48:28 <pacak> That's how they do things.
23:49:17 * angerman is still unhappy about the prospect that ghcs llvm mangler is likely going to be extended ...
23:49:36 <EvanR> "unpublished source code"
23:49:41 <angerman> pacak: I try to stay away from js for a good reason :)
23:49:52 <EvanR> i guess its fitting that hackage cant do that
23:49:59 <EvanR> immutable hah
23:50:16 <angerman> hackage and immutablility... Well...
23:50:40 <EvanR> the blog post takes it for granted you can simple delete your code from the internet
23:50:44 <EvanR> simply
23:50:56 <systemfault> You cannot do that anymore
23:51:13 <pacak> EvanR: Problem is that most people decided that it's easier to depend on 10 lines of code (plus a standard size license text) than to implement it themselves.
23:51:33 <systemfault> The JS world loves dependencies.
23:51:38 <EvanR> ive rewritten left pad about 40 times
23:51:46 <EvanR> i feel stupid each time
23:52:39 <EvanR> maybe were talking about different kinds of reusable code
23:52:54 <EvanR> code for a specific very specific thing, and generally applicable code to many things
23:53:33 <EvanR> the second bit arguably doesnt come up much in js
23:53:44 <pacak> https://www.npmjs.com/package/sum.js -            16           downloads in the last month         
23:54:19 <systemfault> pacak: https://www.npmjs.com/package/node-noop
23:54:35 <cocreature> "sum(strings, 'length');" …
23:54:53 <cocreature> you clearly need a package for that
23:55:01 <EvanR> systemfault: ... wait this is not a joke
23:55:06 <systemfault> Nope.
23:55:32 <systemfault> That one is though: https://www.npmjs.com/package/meta-noop
23:55:43 <pacak> systemfault:  21888           downloads in the last month         
23:55:56 <cocreature> now I’m tempted to make a acme-noop package
23:57:18 <halogenandtoast> Any suggestions for determining if a list contains unsorted consecutive values?
23:58:05 <EvanR> cocreature: an automatic node to acme converter?
23:58:12 <angerman> ok. this is getting over my head... 
23:58:23 <angerman> I'll still be around if there are questions re TH, CC and RPi.
23:58:27 <pacak> > and (\xs -> zipWith (>) xs (drop 1 xs)) [1,2,3,2]
23:58:29 <lambdabot>  error:
23:58:29 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
23:58:29 <lambdabot>                    with actual type ‘Bool’
23:58:40 <EvanR> angerman: i just read the whole post, pretty awesome
23:58:41 <pacak> > and $ (\xs -> zipWith (>) xs (drop 1 xs)) [1,2,3,2]
23:58:43 <lambdabot>  False
23:58:59 <EvanR> manual intervention or not
23:58:59 <pacak> > and $ (\xs -> zipWith (<) xs (drop 1 xs)) [1,2,3,4]
23:59:01 <lambdabot>  True
23:59:04 <pacak> > and $ (\xs -> zipWith (<) xs (drop 1 xs)) [1,2,3,1]
23:59:06 <lambdabot>  False
23:59:23 <angerman> EvanR: well, that will hopefully only be needed for so long :-)
