00:00:00 <Maxdamantus> EvanR: if you applied two out of the four unicode normalisations to that particular string you'd end up with a single code point.
00:00:08 <EvanR> list of Text, now you have a unicode processing app, which you probably didnt want
00:00:26 <EvanR> Maxdamantus: which you wouldnt do in most cases
00:00:28 <hanna> to me a character is defined by an arbitrarily long sequence of codepoints (and a codepoint may consist of multiple bytes to begin with)
00:00:29 <Maxdamantus> Note though that that's only because there is a code point dedicated to that cluster.
00:00:36 <EvanR> right so why
00:00:48 <EvanR> hanna: it is not defined that way in unicode
00:01:01 <thang1> > length "aÃÅÃÅÃÅÃÅ"
00:01:02 <EvanR> and a codepoint does not consist of any number of bytes, its an integer
00:01:03 <lambdabot>  5
00:01:16 <thang1> Weird... I copied your 63 length thing and ended up with 5 :p
00:01:24 <thang1> > head "aÃÅÃÅÃÅÃÅ"
00:01:27 <lambdabot>  'a'
00:01:35 <thang1> > tail "aÃÅÃÅÃÅÃÅ"
00:01:35 <EvanR> i selection and copying behavior will differ among unicode programs
00:01:37 <lambdabot>  "\769\769\769\769"
00:01:52 <EvanR> i copied 77 characters out of there with iterm
00:02:00 <pharaun> > length "√°ÃÅ"
00:02:02 <lambdabot>  2
00:02:02 <hanna> To me √°ÃÅ is a single character consisting of 5 codepoints, and any number of implementation-specific bytes
00:02:07 <thang1> I used tmux  ¬Ø\_(„ÉÑ)_/¬Ø
00:02:14 <EvanR> hanna: its a grapheme cluster
00:02:17 <pharaun> tmux+irssi+urxvt here -> 2
00:02:37 <thang1> > length √°ÃÅ
00:02:40 <lambdabot>  <hint>:1:9: error: lexical error at character '\769'
00:02:45 <thang1> whoops
00:02:54 <thang1> > length "√°ÃÅ" -- brain fart
00:02:56 <lambdabot>  2
00:03:07 <EvanR> ask lambdabot enough times it becomes true
00:03:15 <thang1> hanna: here's where unicode is going to mess with you
00:03:31 <thang1> This particular one is length 2 because it's a + combining-'
00:03:41 <thang1> > length "√°"
00:03:42 <EvanR> the way its displayed has not much to do with the abstract unicode string data
00:03:43 <lambdabot>  1
00:03:53 <EvanR> theres many ways to display it
00:04:25 <EvanR> you dont even need combining characters to get to this point, see ligatures
00:04:33 <thang1> this one is 1 because I literally typed out the pure √° into the terminal and so there's no combining character. √° and your √° are different "characters" in unicode and so have different amounts of code points
00:04:39 <hanna> You may say that, but if something displays a¬¥ instead of √° I'm filing a bug report
00:05:03 <hanna> ‚ÄúUnicode spec doesn't define how to display it!‚Äù is not an excuse
00:05:08 <EvanR> hanna: sure, thats how thailand used to feel
00:05:12 <pharaun> > "√°" == "√°"
00:05:15 <lambdabot>  True
00:05:24 <EvanR> hanna: it does define how to display it, but says "you dont have to support literally everything"
00:05:35 <thang1> To me, this is where unicode really sucks, that √° and "a + accent-overlay" are completely different really feels leaky and arbritrary
00:05:35 <Maxdamantus> Even the unicode glossary gives 4 possible meanings of "character"
00:05:40 <hanna> I don't think they needed to write that into the spec for it to be true
00:05:57 <pharaun> thang1: isn't some of that historical (re han unification)
00:06:00 <hanna> They might as well have standardized that it's impossible to support literally everything
00:06:04 <EvanR> Maxdamantus: right, its not strictly defined. in programming though, its pretty common to be talking about the elements of the string type
00:06:12 <EvanR> of a particular string
00:06:42 <EvanR> > "√°ÃÅ" !! 0
00:06:44 <lambdabot>  '\225'
00:06:47 <EvanR> > "√°ÃÅ" !! 1
00:06:48 <thang1> pharaun: some of it is historical. See ¬µ the greek letter vs ¬µ the SI micro symbol
00:06:49 <lambdabot>  '\769'
00:06:56 <thang1> Some of it is cultural (eg the Han unification).
00:06:58 <Maxdamantus> Well, in Haskell I'd call those Chars
00:07:05 <Maxdamantus> and in Java and C I'd call them chars
00:07:09 <EvanR> i also call them characters
00:07:12 <pharaun> thang1: oh
00:07:29 <EvanR> one of them is literally "combining character"
00:07:50 <EvanR> let the controversy continue!
00:07:54 <thang1> Also, many japanese encodings reject the Han unification and consider the "equivalent" symbols to be different. Thus, any application which wants to be sensitive towards japanese users has to allow for a way to expose the encoding and break the abstraction so that you can use the japanese way for things
00:08:03 <thang1> Which is why Ruby (a heavily used language in Japan) does things that way
00:08:31 <halogenandtoast> Ruby isn't used that heavily in Japan, it did originate here though!
00:08:47 <thang1> If unicode would just suck it up and encode asian text the way asians wanted it encoded, we wouldn't have this problem. The whole thing reeks of "white people knowing better" syndrome
00:09:04 <EvanR> arm chair reengineering of all unicode
00:09:10 <EvanR> you know what we need, a commitee!
00:09:13 <halogenandtoast> thang1: s/white people/monolingual people/
00:09:13 <quchen> Yes! Let‚Äôs put politics into this, that‚Äôs always a good idea.
00:09:35 <Lokathor> @pl \first second -> concat $ map (\(a,b) -> [a,b]) $ zip first second
00:09:35 <lambdabot> (join .) . zipWith ((. return) . (:))
00:09:37 <thang1> halogenandtoast: I suppose it would be more accurate to say that ruby's originating in japan is the reason its unicode  representation is so "japanese friendly", thanks
00:09:59 <EvanR> ruby's unicode representation is non existent
00:10:05 <halogenandtoast> thang1: No problem. I'm an every day Rubyist working here in Tokyo.
00:10:08 <halogenandtoast> Wishing I was doing Haskell
00:10:09 <EvanR> its a byte string + encoding tag
00:10:20 <EvanR> and the encoding tag is often wrong and you need to force fix it
00:10:41 <thang1> And it's that way because of cultural reasons, because of how Japanese culturally resents the entire Han unification nonsense
00:11:06 <EvanR> its like that in many dynamic languages because "string = char array = byte array"
00:11:07 <halogenandtoast> On that note, if anyone ever runs across any good Haskell opportunities here in Tokyo, feel free to let me know.
00:11:09 * hackage random-bytestring 0.1.0 - Efficient generation of random bytestrings  https://hackage.haskell.org/package/random-bytestring-0.1.0 (larsk)
00:11:13 <thang1> (well, I'm pretty sure the Chinese culture isn't super big on it either but I haven't talked to any chinese programmers)
00:11:16 <halogenandtoast> lol @ hackage
00:11:19 <halogenandtoast> perfect timing
00:11:25 <thang1> haha, nice
00:12:07 <thang1> 3 line readme, no documentation, flawless library
00:12:09 * hackage ridley 0.3.1.1 - Quick metrics to grow you app strong.  https://hackage.haskell.org/package/ridley-0.3.1.1 (AlfredoDiNapoli)
00:12:17 <nshepperd> whether two related characters are "the same" seems like a question with no easy answer imo
00:12:21 <thang1> "make  you app grow strong for great good"
00:12:30 <halogenandtoast> thang1: If there is one thing I've learned about the Haskell community it's that documentation is not a forte.
00:12:30 <nshepperd> lotta languages have inherited alphabets from each other
00:12:36 <EvanR> russian A and latin A, totally different
00:12:37 <thang1> nshepperd: that's why we have normalization strategies!
00:12:40 <EvanR> im western, i know
00:12:42 <halogenandtoast> Either your a Haskell genius and can infer everything from the types
00:12:46 <halogenandtoast> or you don't use the library
00:12:52 <halogenandtoast> *you're
00:13:09 <nshepperd> and by the way, if you have identical looking characters that are considered to be different you get lovely security bugs too :D
00:13:22 <EvanR> yeah
00:13:27 <halogenandtoast> nshepperd: like I and l in a lot fonts.
00:13:40 <quchen> nshepperd: Doesn‚Äôt the OSX file system do something like that?
00:13:44 <EvanR> i dont envy unicode engineers and the security issues it could introduce
00:13:54 <nshepperd> halogenandtoast: yup. *shudder*
00:14:03 <thang1> Oh OSX is worse
00:14:06 <EvanR> halogenandtoast: I1l|
00:14:09 * hackage ridley-extras 0.1.0.0 - Handy metrics that doesn't belong to ridley.  https://hackage.haskell.org/package/ridley-extras-0.1.0.0 (AlfredoDiNapoli)
00:14:12 <halogenandtoast> nshepperd: granted, that could be considered a font problem
00:14:14 <thang1> OSX's file system... oh god
00:14:37 <thang1> OSX is occasionally case sensitive, occasionally case insensitive, depending on where the file/folder is
00:14:45 <halogenandtoast> Or more specifically a font face problem.
00:14:58 <thang1> It also internally uses its own type of unicode representation that is neither unicode-8 or any other unicode and it forcibly converts all text into that unicode representation
00:15:05 <cocreature> quchen: hey, have you thought about adding some support for specifying precedences and getting automatic parentheses to prettyprinter? it seems like I can‚Äôt be the only one who wants that in combination with pretty printing
00:15:05 <nshepperd> halogenandtoast: programming fonts often add prominent serifs to make the differences evident
00:15:31 <Maxdamantus> > let l–µt = l–µt in let l–µt = l–µt in l–µt
00:15:37 <lambdabot>  mueval-core: Time limit exceeded
00:15:41 <pharaun> gah osx
00:15:44 <EvanR> A–êŒëùñ†·é™·óÖ
00:15:46 <quchen> cocreature: For that to work every value would have to carry its precedence
00:15:51 <hanna> Following the advice of Cabal (which says to split your executable between a library component and a program component so you can have your tests depend on the library as well), I gave it a shot, using https://github.com/vimus/vimus/blob/master/vimus.cabal as an example
00:15:59 <halogenandtoast> nshepperd: indeed.
00:16:12 <hanna> But I'm running into the issue where the `executable` fails to build unless I copy/paste the entire `build-depends` list to it as well
00:16:14 <hanna> What is going wrong?
00:16:23 <Maxdamantus> > let l–µt = l–µt in let wh–µre where wh–µre = wh–µre
00:16:26 <lambdabot>  <hint>:1:28: error: parse error on input ‚Äòwhere‚Äô
00:16:29 <thang1> obligatory Linus rant on HFS+: https://plus.google.com/+JunioCHamano/posts/1Bpaj3e3Rru
00:16:50 <Maxdamantus> Eh, nvm
00:16:53 <quchen> cocreature: But yes, I would like to have that as well! :-)
00:16:54 <cocreature> quchen: couldn‚Äôt you have separate type that carries precedences and manages parentheses and then some sort of embed function that allows you to use that inside of Doc
00:16:58 <thang1> Gold quote: "people who think unicode equivalency comparisons are a good idea in a filesystem shouldn't be allowed to play in that space. Give them some paste, and let them sit in a corner eating it."
00:17:26 <EvanR> no more linus quotes in here plz
00:17:35 <EvanR> i heard he doesnt use haskell
00:17:47 <thang1> You have any idea how hard it was for me to find one that was PG? c'mon, let me have it this once
00:20:24 <Athas> hanna: you need to add dependencies for all the libraries that you are using directly in the .hs file for the executable.
00:20:47 <thang1> Apple uses some form of UCS2 encoding and then picks NFD normalization and forces it on all of the data on the file system. ‡≤†_‡≤†
00:21:08 <Maxdamantus> It's not UCS2 .. it's UTF-16
00:21:32 <quchen> cocreature: ¬ªinside of Doc¬´ means using it as an annotation
00:21:38 <hanna> Athas: my Main.hs only has ‚Äúimport MyLibrary‚Äù
00:21:46 <hanna> (and a few things from base)
00:22:13 <quchen> cocreature: But maybe there are a couple of convenience functions that could be used to make things very easy to use
00:22:16 <EvanR> at this point youd think UTF-16 was = unicode, all these frameworks and languages treat text UTF-16 unit array
00:22:33 <EvanR> including haskell!
00:22:36 <thang1> I think UCS2 is almost identical to UTF-16...
00:22:40 <EvanR> (but its not advertised as much)
00:22:42 <cocreature> quchen: I‚Äôll play around and see if I can come up with a nice API
00:23:02 <Maxdamantus> Well, UCS2 doesn't say anything special about units like 0xd800
00:23:05 <thang1> EvanR: which is funny, because every time I think unicode I think Utf-8 because I see Utf-8 explicitly mentioned far more often than utf-16 (which is often called unicode)
00:23:08 <EvanR> thang1: no, which will propagate the confusion
00:23:09 * hackage ridley-extras 0.1.0.1, ridley 0.3.1.2 (AlfredoDiNapoli): https://qbin.io/tmmj2wo
00:24:12 <thang1> Ahh okay got it, it is indeed UTF-16, but it is normlalized with NFD
00:24:45 <Maxdamantus> afaik NFD is something that can change across releases of unicode.
00:24:52 <EvanR> ucs-2 is an old character set which doesnt cover all of unicode
00:25:05 <EvanR> its from decades ago
00:25:07 <thang1> wait, wtf. It's normalized with a form "very nearly the same as NFD"
00:25:16 <hanna> Athas: hmm, seems like it only works if you put the library into a different subdirectory 
00:25:19 <hanna> i.e. ‚Äúsrc‚Äù
00:25:27 <thang1> EvanR: I know. I thought it had used UCS2 because HFS+ came out a long time ago
00:25:28 <hanna> that's slightly annoying
00:25:45 <thang1> It's been around since OS8.1
00:26:09 * hackage servant 0.11, servant-client 0.11, servant-server 0.11 (phadej): https://qbin.io/nhw1xy64w
00:26:14 <Maxdamantus> So what happens if someone writes codepoints that are unknown by the OS' current version of unicode?
00:26:38 <wz1000> thang1: My favourite part about that rant is terry davis showing up.
00:26:45 <EvanR> gotta ask #macosx
00:27:11 <Maxdamantus> Does it reject that filename because it doesn't know which ones might be combining code points in the future that might be part of a sequence with an NFD form?
00:27:16 <EvanR> but this question does tie into, sort of the FilePath proposal
00:27:39 * hackage servant-docs 0.10.0.1, servant-foreign 0.10.1 (phadej): https://qbin.io/y92pucyo3
00:28:40 <EvanR> abstract filepath proposal
00:29:29 <Maxdamantus> Anyway, I feel fairly strongly that these issues shouldn't be fundamentally embedded into something like an OS or filesystem.
00:29:50 <Maxdamantus> Because any solution other than "just write bytes" is one that claims to correctly solve a really hard problem.
00:30:03 <Maxdamantus> and I'm pretty sure they never solve that really hard problem.
00:30:37 <mjora7> Ok I just ran a super simple echo test with a Haskell server and a Node server and the Haskell one returns a response in 0.22 seconds and the express one in 0.60, three times as fast! Nice.
00:31:34 <EvanR> mjora7: to answer your question from earlier, you can write a function debug :: Show a => a -> a, which can be inserted into any chain, and whatever goes through it can be printed to stderr. using Debug.Trace tools
00:31:36 <quchen> ¬ªEcho¬´ is not a very practical benchmark.
00:31:48 <mjora7> quchen: Yeah not at all haha
00:31:51 <mjora7> EvanR: Thanks
00:35:47 <EvanR> Maxdamantus: ntfs, hfs engineering teams had zero chance of "not designing" something like the way it is now into the filesystem
00:36:06 <EvanR> because the hardest thing to do in corporate world is be like "problem solved, we just dont do anything"
00:36:17 <EvanR> they look at you like youre nuts
00:37:31 <Maxdamantus> Well, I suspect they probably would if they could start everything from scratch.
00:37:38 * hackage schematic 0.1.1.0 - JSON-biased spec and validation tool  https://hackage.haskell.org/package/schematic-0.1.1.0 (dredozubov)
00:37:40 <EvanR> sure
00:38:04 <thang1> The real reason HFS+ is case insensitive is apparently microsoft officecompatibility :p
00:38:36 * Maxdamantus wonders how case insensitivity works in those filesystems too.
00:38:51 <EvanR> case insensitive, case preserving
00:38:51 <merijn> I once tried to run OSX on case sensitive HFS...terrible idea...
00:38:59 <Maxdamantus> Does it remember what locale a particular filesystem is in?
00:39:12 <merijn> OSX works fine, but all the major vendors (Blizzard, Adobe, etc.) break
00:39:21 <Maxdamantus> or does it just use the locale of the user that happens to be interacting with the filesystem at the time?
00:39:27 <EvanR> whats upper and whats lower isnt locale specific
00:39:42 <Maxdamantus> Sure it is .. what's the lower-case form of 'I'?
00:39:43 <EvanR> its in unicode
00:39:49 <EvanR> i
00:39:56 <ahihi> thang1: source for that? I thought it was just inherited from HFS
00:39:59 <merijn> EvanR: Wrong
00:40:02 <Maxdamantus> Are you sure it's not 'ƒ±'?
00:40:06 <merijn> EvanR: Turkey it's undotted i
00:40:10 <EvanR> it doesnt change your case
00:40:22 <EvanR> its just considers them to be upper and lower case versions of each other
00:40:37 <merijn> We nearly had OSX with ZFS :(
00:40:49 <thang1> ahihi: admittedly my source is a user anecdote from hackernews. "I asked the people who designed the filesystem why they did this and they replied with microsoft office"
00:40:56 <Maxdamantus> So 'i' == 'I' and 'I' == 'ƒ±'?
00:41:09 <EvanR> probably
00:41:10 <Maxdamantus> Does that mean 'ƒ±' == 'i' due to transitivity?
00:41:15 <EvanR> probably not
00:41:36 <quchen> > toUpper 'ƒ±' == toUpper 'i'
00:41:38 <lambdabot>  True
00:42:02 <EvanR> brilliant
00:42:12 <EvanR> case insensitivity will make it so easy to use the computer
00:42:32 <Maxdamantus> 'ƒ±' = 'I' = 'i' = 'ƒ∞'
00:42:39 <merijn> At least they specified an encoding...
00:42:50 <quchen> UTF-15!
00:42:51 <thang1> Also, √ü.toUpper() = SS. SS.toLower() = ss. ss.toUpper() = SS
00:43:04 <merijn> Unlike the other *nix insanity of "it's all bytes, because no one wants non-ASCII!"
00:43:25 <merijn> thang1: Which is why you should use Text.toUpper instead of toUpper ;)
00:43:27 <EvanR> i prefer just bytes
00:43:31 <EvanR> on disk
00:43:32 <thang1> I particularly enjoy *nix sanity with filesystems
00:44:06 <thang1> *nix has the philosophy of "whatever string of bytes you use to name this thing, I don't care baby, just do you; I ain't gonna touch it, that's your job, I'm just the kernel making sure you don't blow stuff up"
00:44:20 <quchen> merijn: Let‚Äôs not discuss what upper-case ¬ª√ü¬´ should be or there will be blood ;-)
00:44:55 <EvanR> > toUpper '√ü'
00:44:57 <lambdabot>  '\223'
00:45:10 <thang1> merijn: my toUpper was pseudocode to get the point across :p
00:45:10 <EvanR> > text . (:[]) $ toUpper '√ü'
00:45:12 <lambdabot>  √ü
00:45:22 <thang1> ‡≤†_‡≤†
00:45:50 <Maxdamantus> > text . (:[]) $ toLower '·∫û'
00:45:52 <lambdabot>  √ü
00:45:52 <EvanR> there will √üe √ülood
00:46:10 <thang1> > toLower '√ü'
00:46:12 <lambdabot>  '\223'
00:46:19 <halogenandtoast> merijn: isn't toUpper from Data.Text?
00:46:26 <EvanR> Data.Char
00:46:29 <thang1> What is "text . (:[])" doing, anyway?
00:46:40 <EvanR> > (:[]) 4
00:46:42 <lambdabot>  [4]
00:46:44 <Maxdamantus> :t (:[])
00:46:46 <lambdabot> a -> [a]
00:46:48 <quchen> Robot monkey is pure for lists.
00:46:51 <thang1> > Text.toUpper '√ü'
00:46:53 <lambdabot>  error:
00:46:53 <lambdabot>      Not in scope: ‚ÄòText.toUpper‚Äô
00:46:53 <lambdabot>      No module named ‚ÄòText‚Äô is imported.
00:46:59 <EvanR> the globbler operator
00:47:07 <thang1> > T.toUpper '√ü'
00:47:09 <lambdabot>  error:
00:47:09 <lambdabot>      Not in scope: ‚ÄòT.toUpper‚Äô
00:47:09 <lambdabot>      No module named ‚ÄòT‚Äô is imported.
00:47:17 <thang1> I give up
00:47:22 <Maxdamantus> :t (.)
00:47:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:47:37 <thang1> EvanR: thanks, the point free was messing with my brain
00:47:53 <thang1> I'm not highly evolved enough yet
00:48:07 <EvanR> :t (text .) `asAppliedTo` (:[])
00:48:09 <lambdabot> (Char -> String) -> Char -> Doc
00:48:32 <EvanR> er no
00:48:46 <EvanR> :t (text . (:[]))
00:48:48 <lambdabot> Char -> Doc
00:49:07 <merijn> halogenandtoast: There's a toUpper from Data.Text and one from Data.Char
00:49:35 <merijn> > Data.Text.toUpper . Data.Text.pack $ "√ü"
00:49:37 <lambdabot>  error:
00:49:37 <lambdabot>      Not in scope: ‚ÄòData.Text.toUpper‚Äô
00:49:37 <lambdabot>      Perhaps you meant ‚ÄòData.Char.toUpper‚Äô (imported from Data.Char)
00:49:52 <merijn> @let import qualified Data.Text as T
00:49:53 <lambdabot>  Defined.
00:49:56 <halogenandtoast> merijn: yes, the one from Data.Text would do the wrong thing
00:50:06 <merijn> > T.toUpper . T.pack $ "√ü"
00:50:08 <lambdabot>  "SS"
00:50:13 <EvanR> neat
00:50:24 <merijn> halogenandtoast: It does the right thing for ligatures at least
00:50:31 <merijn> Unlike Data.Char.toUpper
00:50:47 <Maxdamantus> Why not "·∫û"?
00:50:50 <halogenandtoast> sure but I would assume toUpper and toLower to be, oh crap, what's the word...
00:50:58 <halogenandtoast> homoiconic?
00:50:58 <EvanR> inverses
00:51:02 <halogenandtoast> is that the term?
00:51:03 <EvanR> but theyre not
00:51:08 <EvanR> inverse functions
00:51:16 <halogenandtoast> nope not that word
00:51:17 <merijn> > Data.Char.toUpper 'Ô¨Ñ'
00:51:19 <lambdabot>  '\64260'
00:51:23 <merijn> eh
00:51:27 <EvanR> thats what youre trying to say
00:51:30 <merijn> > text . pure $ Data.Char.toUpper 'Ô¨Ñ'
00:51:32 <lambdabot>  Ô¨Ñ
00:51:33 <thang1> opposites, EvanR?
00:51:38 <EvanR> inverse functions
00:51:41 <halogenandtoast> Yeah I guess inverses
00:51:47 <merijn> > T.toUpper . T.pack $ "Ô¨Ñ"
00:51:48 <Maxdamantus> Haskell needs a `setLocale` function that changes the behaviour of `toLower`
00:51:49 <lambdabot>  "FFL"
00:51:56 <merijn> halogenandtoast: Definitely not in case of unicode
00:52:04 <merijn> halogenandtoast: toUpper and toLower cannot sanely be inverses
00:52:35 <EvanR> i.e. toUpper . toLower = id and toLower . toUpper = id, i.e. not
00:52:38 <halogenandtoast> And this is why we should get rid of all characters not in American English.
00:52:44 <merijn> Maxdamantus: I you want correctness for unicode, use text-icu
00:52:44 <halogenandtoast> ^^ I don't mean that of course
00:52:53 <thang1> Assimilate or be Exterminate
00:53:24 <merijn> I can't even write my name correctly as nickname here because of the stupid assumption of "all text is ascii"
00:53:26 <EvanR> plenty of characters in american english not in ascii
00:53:37 <Maxdamantus> merijn: yeah, I'm sure there are things that let you do something sensible, was just joking about making something that modifies the behaviour of a function.
00:53:55 <merijn> Computers in general have broken a lot of Dutch
00:54:23 <merijn> > length "Merƒ≥n" -- see, you can do it right if you want!
00:54:26 <lambdabot>  5
00:54:32 <merijn> actually, no
00:54:34 <merijn> still wrong
00:54:42 <EvanR> aaaa haha
00:54:47 <merijn> > length "ƒ≥" --hmm
00:54:48 <Maxdamantus> do{ setLocale "tr"; putStrLn $ map toUpper "i" }
00:54:49 <lambdabot>  1
00:55:03 <merijn> wait, what
00:55:33 <merijn> > length ['M', 'e', 'r', 'ƒ≥', 'n']
00:55:35 <lambdabot>  5
00:56:08 <merijn> Not sure whether that should be right or wrong, actually
00:56:14 <Itkovian> merijn http://www.fileformat.info/info/unicode/char/0133/index.htm ?
00:56:18 <thang1> looks right to me
00:56:29 <EvanR> merijn: ij is two letters, you want kerning to make them look like a ligature...
00:56:39 <EvanR> yet theres an ij character in unicode
00:56:49 <thang1> oh right, hmm.  ¬Ø\_(„ÉÑ)_/¬Ø
00:56:59 <merijn> EvanR: eh, keep your American cultural imperialism to yourself please :p
00:57:05 <thang1> > length "¬Ø\_(„ÉÑ)_/¬Ø"
00:57:07 <lambdabot>  <hint>:1:11: error:
00:57:08 <lambdabot>      lexical error in string/character literal at character '_'
00:57:14 <merijn> ij is *sometimes* two letters
00:57:16 <quchen> merijn: length is correct there.
00:57:25 <EvanR> im western threfore im an authority on westernisms
00:57:26 <thang1> ‡≤†_‡≤†
00:57:39 <merijn> quchen: Yeah, I just had a moment of stupid where I forgot the length of my name due to being tired...
00:58:08 <quchen> Length doesn‚Äôt know about names or chars. It returns the number of elements of a list (foldbale).
00:58:11 <mbrock> I want to optimize the function "read :: IntMap Word8 -> (Int, Int) -> ByteString" which reads a byte range from an IntMap memory, defaulting nonexistent keys to 0... Maybe an IntMap.split followed by repeated applications of IntMap.minViewWithKey will do the trick...
00:58:36 <phadej> quchen: that same happens with Data.Text.length too
00:58:37 <merijn> EvanR: That's the kinda stupidity that leads to phones capitalising ƒ≤sselmeer as Ijsselmeer
00:58:40 <EvanR> you need Char -> Int for size of character!
00:58:44 <thang1> anyway now that I've successfully derailed #haskell for like 4 hours, I'm gonna head to bed because I /definitely/ got no homework done and need to be productive and wake up tomorrow
00:58:52 <phadej> quchen: though someone might argue it should return the grapheme count
00:58:56 <phadej> quchen: not codepoint
00:58:57 <Itkovian> merijn: depends on the crossword puzzle you are solving ...
00:59:21 <merijn> Itkovian: Yeah, you'd think there'd be a standards union for puzzle makers to finally decide one way or the other
00:59:27 <EvanR> phadej: should be a separate incantation, sum . map graphemeCount
01:00:03 <phadej> EvanR: yeah, but that's the debate; what should be the default, codepoint or grapheme count? :)
01:00:06 <merijn> In completely unrelated news...whooo, I got my stuff merged into criterion and it looks like it might actually be released and usable by the world at large soon-ish :)
01:00:12 <EvanR> phadej: character plz
01:00:19 <merijn> EvanR: Ambiguous
01:00:23 <phadej> EvanR: what is characater?
01:00:35 <quchen> merijn: What was that again? Your cleanup benchmark runners?
01:00:37 <EvanR> the element of the string
01:00:39 <phadej> character /= codepoint, character /= grapheme
01:00:48 <thang1> character is one, character is all
01:00:56 <thang1> look inside, become one with the character inside you
01:00:59 <merijn> quchen: cleanups and the ability to have per run/per batch environments
01:01:32 <phadej> merijn: thanks for fixing the build so quickly btw
01:01:37 <merijn> quchen: Also, I quickly snuck in an executable that can generate those fancy HTML reports from the JSON output so that you can actually generate reports afterwards
01:02:12 <merijn> phadej: I was supposed to wait for Travis, check for errors and then get it merged, but then Ryan merged it before my meeting finished and I had a look :p
01:02:34 <phadej> :)
01:02:47 <quchen> *Continuous* integration
01:02:58 <quchen> Waiting for Travis is quantized integration.
01:03:06 <EvanR> needs more smooth integration
01:03:12 <merijn> Ideally I get around to extending the executable to do grouping/filtering/merging of JSON reports at some point in the future (as that's something I really need), but I think that'd take a while to implement
01:03:19 <merijn> Unless I can find a sucker to do it for me :p
01:03:32 <merijn> I should farm out my yak shaving to people in -beginners looking for projects...
01:03:54 <EvanR> #haskell-yak-shavers
01:04:55 <thang1> Find intern, hire intern for "real world experience", "resume building" and "unlimited snacks in coding room", have them write shitty and unmaintainable haskell code, bam profit
01:05:06 <phadej> continuous integration: continously waiting for travis to complete (5 pr's atm :()
01:05:32 <nshepperd> phadej: code point seems more reasonable since you can construct count of larger things by segmenting. graphemeClusters :: Text -> [Text]; cf. words and lines
01:05:48 <nshepperd> but i dunno, who even uses Text.length and for what anyway
01:05:48 <merijn> phadej: Solution: Have so many projects you can work on others while you wait for Travis to finish ;)
01:05:59 <merijn> thang1: There isn't even funding to pay for me, let alone interns...
01:06:12 <EvanR> yes, the way it is is more fundamental and you can get grapheme clusters on top of that
01:06:14 <merijn> thang1: I suppose I could s/interns/students, but they don't know Haskell
01:06:15 <thang1> That's why you pay them in free snacks and resume building
01:06:25 <EvanR> nshepperd: but the ij thing would not have been caught by this, since its a single letter
01:06:38 <EvanR> no unicode thing i know of would return 2 for that
01:06:46 <nshepperd> and also all the normal unicode algorithms are defined as iteration over a sequence of code points, i assume?
01:06:53 <EvanR> yes
01:07:04 <phadej> nshepperd: but codepoint count isn't stable under normalisation!
01:07:12 <merijn> EvanR: The problem is, that in, say US locale it should be treated as a ligature of 2 letters, but in a Dutch locale it should be treated as 1
01:07:29 <phadej> (disclaimer: I really play devil's advocate here, don't take me seriously on Unicode issues)
01:07:37 <EvanR> the complaints from earlier make it sound like they would also be ok with havin length return the number of words in a string
01:07:46 <EvanR> because you can
01:07:55 <phadej> merijn: in fact I do that already, I work on "work" and "oss" projects
01:07:58 <nshepperd> phadej: yeah but who cares
01:07:59 <EvanR> but no because thats yet more application specific functionality
01:08:17 <phadej> nshepperd: well, Finnish people (e.g. me) do
01:08:36 <nshepperd> you care that code point count changes under normalisation?
01:08:40 <merijn> phadej: Could be worse than Travis builds
01:08:41 <phadej> because we have those fancy characters, needing two codepoints
01:08:53 <phadej> /possibly/
01:09:05 <merijn> I have a library that's stuck on "finishing benchmarks so I can brag/compare", except some of these benchmarks take hours to run >.>
01:09:09 <nshepperd> if you're going to apply a normalisation function, don't you expect things to change, so where is the problem?
01:09:41 <phadej> nshepperd: the problem is that I don't want to apply normalisation function just to check length
01:09:54 <EvanR> use a different kind of length...
01:10:25 <EvanR> thats like the case insensitive INI file question from yesterday (?)
01:10:41 <phadej> and e.g. none of used libraries in Haskell have a type for say: "NFC normalised UTF16"
01:11:00 <nshepperd> I don't see why would applying a normalisation function ever help with checking length?
01:11:26 <nshepperd> if you want to count grapheme clusters, use the graphemeClusters function lol
01:12:56 <nshepperd> talking about UTF-16 seems like a type error, also
01:13:09 <nshepperd> you shouldn't care about the physical representation
01:13:25 <phadej> yes and no, it has memory implications
01:13:29 <phadej> memory usage
01:13:51 <phadej> if i don't care about physical representation String = [Char] is good enough
01:14:21 <nshepperd> well, that is reasonable concern but seems orthogonal to the api design in general
01:14:41 <nshepperd> it's a sequence of code points regardless of how you store it
01:15:05 <phadej> One could store it as a sequence of graphemes too
01:16:45 <phadej> and IMHO grapheme is more natural abstraction that codepoint (which is implementation detail)
01:17:16 <nshepperd> but all the unicode algorithms and stuff are defined in terms of code points
01:17:55 <thang1> The biggest problem with grapheme is that it includes an arbritrary length amount of CCSes (combining code things) so you can make a 100 TB sized twitter post if you counted by grapheme (if I remember the definition of grapheme correctly)
01:18:00 <EvanR> the api would be drastically different if you were holding a sequene of graphemes
01:18:17 <EvanR> a sequence of grapheme clusters
01:18:52 <EvanR> when you request an element of the sequence you get... dun dun dun, a unicode string instead
01:18:55 <EvanR> of a chracter
01:19:09 <EvanR> which is what we started with and have
01:19:55 <nshepperd> it can be viewed as a sequence of graphemes, sure, which is why you should have a 'graphemeClusters :: Text -> [Text]' function
01:20:08 <nshepperd> just like we have functions to segmenting into words and lines
01:20:53 <halogenandtoast> Does anyone have a good example of a Dockerfile for a stack application?
01:27:47 <nshepperd> EvanR: python does that, heh. it's strings all the way down
01:28:41 <nshepperd> 'a'[0][0][0][0] = 'a'
01:32:27 <nshepperd_> I don't think code points are an implementation detail either
01:32:52 <wz1000> The way haskell does it is pretty unintuitive too
01:33:04 <nshepperd_> Except for the silly surrogate pair "code points" which were a mistake and don't count :)
01:33:11 <wz1000> > mapM_ putStrLn $ subsequences "aeÃÅ"
01:33:13 <lambdabot>  <IO ()>
01:33:39 * hackage servant-cassava 0.9 - Servant CSV content-type for cassava  https://hackage.haskell.org/package/servant-cassava-0.9 (phadej)
01:33:40 <wz1000> > subsequences "aeÃÅ"
01:33:42 <lambdabot>  ["","a","e","ae","\769","a\769","e\769","ae\769"]
01:34:43 <wz1000> Only 4 of those are what I'd consider to be valid subsequences
01:35:41 <wz1000> Also, why doesn't lambdabot have a freemonad implementation for safe IO actions?
01:36:37 <merijn> wz1000: Patches welcome ;)
01:37:19 <merijn> wz1000: More seriously, lambdabot is just loading existing code, how would you automatically convert existing IO actions into a safe free-monad implementation?
01:37:33 <merijn> wz1000: i.e. how does putStrLn changes it's implementation magically?
01:37:51 <quchen> You can just alias it
01:37:55 <wz1000> Don't have the base versions of the IO actions in scope
01:37:58 <quchen> I know someone who exchanged the Prelude :-)
01:38:05 <merijn> quchen: Sure, but then someone has to write all the aliases
01:38:06 <quchen> (To make putStrLn different)
01:38:11 <_sars_> Using servant-swagger, I am trying to do this,  http://lpaste.net/355806 but it is not working. How can I get it done using lenses/prisms that swagger provides?
01:38:19 <merijn> See my initial "patches welcome" ;)
01:41:33 <phadej> _sars_: like https://github.com/GetShopTV/swagger2/blob/73c4c7775e6dbe3f88ab69142d113dd6548a6d01/examples/hackage.hs#L25-L36
01:41:48 <phadej> _sars_: your example has only one property only
01:43:59 <nshepperd_> How much would be able to do with this anyway? PutStrLn maybe, and some random number stuff? I suppose you could do the whole "fake temporary filesystem" thing for writeFile and so on
01:46:12 <merijn> Time to repeat my previous poll: Suppose I have a bunch of Folds/Traversals and I wanna dump them all in a module intended for qualified imports (i.e. shadowing Prelude), what's a good module name? Foo.Traversals? Foo.Prelude? Foo.Folds? Something else?
01:46:32 <merijn> nshepperd_: Well, that's basically how Haskell IO worked before monadic IO, so...
01:50:25 <wz1000> merijn: Wasn't it something like main :: [Request] -> [Response]
01:50:25 <cocreature> merijn: I would probably go for the Prelude approach
01:51:05 <merijn> cocreature: I was thinking of that, based on Pipes, etc. but OTOH I'm only really shadowing folds/mapM, not anything else
01:52:55 <cocreature> merijn: I don‚Äôt think naming it Traversals or Folds is really helping. especially if both would make sense I would constantly forget which one it is. Prelude on the other hand is easier to remember (for me).
01:56:14 <Philonous> Why not export them from the main module? 
01:56:22 <merijn> Philonous: Because they clash with Prelude
01:56:33 <Philonous> So? Can always be imported qualified
01:56:52 <cocreature> Philonous: but then you can not just import the things that don‚Äôt clash without explicit import lists
01:57:16 <merijn> Philonous: I dislike having to import qualified, additionally the folds are really more "neat utilities", rather than core functionality
01:57:49 <Philonous> Importing unqualified and without explicit import list is bad anyway 
01:58:08 <cocreature> you can take unqualified import lists from my cold dead hands
01:58:25 <cocreature> (please don‚Äôt)
02:00:05 <merijn> Which is not really a constructive or helpful comment, so I'm not quite sure how it's supposed to add to the conversation :)
02:01:00 <Philonous> Personally I try to import qualified anyway and I dislike having to import additional modules of which I can't remember the name in any case. 
02:01:17 <bollu> cocreature: ping
02:01:29 <merijn> Philonous: Well, that can be trivially solved by simply re-exporting the main module from the other one
02:01:41 <Philonous> merijn, I was about to suggest that.
02:01:50 <whald> hi! can s.o. suggest me a mirror for https://www.haskell.org/ghc/download ?
02:01:54 <merijn> Philonous: In fact, that's what I already do in another case
02:02:01 <merijn> whald: Google is indexing outdated urls
02:02:10 <cocreature> whald: https://downloads.haskell.org/~ghc/
02:02:15 <merijn> whald: You want https://www.haskell.org/ghc/download.html
02:02:45 <cocreature> bollu: pong but I‚Äôm sort of busy atm so leaving a comment on github is probably a better idea
02:02:55 <cocreature> unless it‚Äôs only a short question and not some discussion
02:03:00 <whald> merijn, maybe google hopes that URL comes back, otherwise a 404 instead of 500 HTTP error might help?
02:03:07 <whald> cocreature, thanks!
02:03:17 <ertes-w> wz1000: [Response] -> [Request]
02:03:37 <ertes-w> main "sends" requests and "receives" responses
02:03:38 <bollu> cocreature: what's a .td file? :)
02:03:51 <cocreature> bollu: http://llvm.org/docs/TableGen/
02:03:53 <whald> merijn, ah, thanks, too! :)
02:04:11 <bollu> cocreature: cool!
02:04:13 <bollu> cocreature: thnks
02:04:15 <bollu> thanks*
02:04:26 <merijn> Philonous: Althought the downside is that I currently have a non-throwing module and another that wraps that API to throw exceptions, so then you'd either have to Prelude module twice to mimic that or restrict people to either one or the other
02:04:27 <Philonous> merijn, That's probably the best of both worlds. 
02:04:45 <cocreature> bollu: I‚Äôm not sure if that‚Äôs cool but it‚Äôs how LLVM specifies intrinsics so we‚Äôll have to read that file
02:05:02 <bollu> cocreature: yep, will do
02:05:04 <wz1000> ertes-w: ah
02:05:17 <bollu> cocreature: I love LLVM tooling, that's what I meant by "cool" :)
02:05:55 <merijn> Philonous: So I think not re-exporting is more flexible, especially if I add more stuff later, because then you can just do "import qualified Foo as F; import qualified Foo.Prelude as F" and replace the first with "import qualified Foo.Throw as F" to use the throwing API instead
02:07:25 <merijn> Actually, while I'm polling opinions: foldFoo and foldMFoo or fooFold and fooFoldM? I dislike the capital M looking like part of the type in 'foldMFoo', but I don't really like the others
02:08:08 * hackage hnormalise 0.2.0.0 - Log message normalisation tool producing structured JSON messages  https://hackage.haskell.org/package/hnormalise-0.2.0.0 (AndyGeorges)
02:08:38 <Philonous> merijn, Do you have multiple? Otherwise why not fold and foldM ?
02:08:52 <mbrock> hmm, how do I efficiently either (1) convert a `Vector Word8' to a `ByteString', or (2) build a ByteString by allocating a zeroed buffer and then mutating some indexes?
02:09:17 <mbrock> (the Vector is Unboxed)
02:09:18 <merijn> Philonous: This is a slightly different fold, intended to be used with Tekmo's foldl package
02:09:44 <merijn> Philonous: Else I'd just use fold/foldM, yeah
02:10:05 <Philonous> merijn, OK, I prefer foldMFoo
02:10:11 <merijn> mbrock: ByteString has an unsafe Ptr Word8 interface
02:10:13 <Axman6> mbrock: hmm, I feel I've written this code before, it's painfully convoluted
02:10:30 <Axman6> merijn: I prefer foldFooM because it's consistent with the rest of the ecosystem
02:10:53 <Axman6> mbrock: if you have a Storable.Vector you would have an easier job
02:11:08 <merijn> Axman6: Is it? I don't recall seeing examples like that?
02:11:35 <cocreature> bollu: let‚Äôs see if you still love it once you get to the part in the docs for TableGen where you realize that there are no docs on how to write a backend for TableGen
02:11:37 <Axman6> hmm, I'm sure I've seen examples
02:12:02 <bollu> cocreature: xD
02:12:34 <Axman6> merijn: anyway, a M suffix is pretty common, and stands out more than hiding it in the middle of the word
02:12:38 <mbrock> Axman6: ah, yeah, just found a StackOverflow thing with Vector.Storable's `unsafeToForeignPtr' and ByteString's `packCStringLen'
02:13:00 <merijn> While I'm at it, I have another one
02:13:11 <Axman6> seeing foldFoo and foldFooM I pretty much immediately know what the relationship between them is, without seeing the types. foldFoo and foldMFoo looks like they work on different types
02:14:01 <Axman6> adding an M is similar to adding a ', it has a conventional meaning
02:16:06 <merijn> So, I have a channel type with explicit in/out types and I'm not really solidly convinced what the types should be (let's take 'Fold a b' as short hand for the actual folding functions/operations: 1) "Chan Out a -> Fold a b -> IO b", 2) "Chan In a -> Fold a b -> IO b", or 3) "Chan In a -> Fold a b -> IO (IO b)" (rationale to follow)
02:16:56 <merijn> 1) has the advantage of being straightforward to use, but, it means the "Out" point is visible to other functions, that can end up accessing it interleaved with fold, meaning some elements might get "lost" from the fold
02:18:19 <merijn> 2) Prevents this by creating a new "Out" end internally, so it's guaranteed the fold gets all elements. However, this is tricky if you wanna be threaded, since there's no way to ensure someone is listening before you start writing when you create the Out channel inside the thread running the fold
02:18:38 * hackage profiteur 0.4.3.0 - Treemap visualiser for GHC prof files  https://hackage.haskell.org/package/profiteur-0.4.3.0 (JasperVanDerJeugt)
02:19:28 <merijn> 3) Again stops elements from "leaking", but having "IO (IO b)" it clearly separates "creating the new listening channel" from the "actually executing the fold", so it's more convenient to use with other threads (simply fork the thread *after* the listener is created), but the type is more confusing
02:19:43 <_sars_> phadej: I am getting some weird result after doing that, http://lpaste.net/355807
02:20:06 <merijn> Does anyone have any opinions on what the "best" type would be?
02:20:08 <mbrock> now I'm wondering how to follow this answer but using some unsafe magic to avoid the IO monad... https://stackoverflow.com/questions/22508826/converting-vector-to-bytestring-in-haskell
02:20:36 <merijn> mbrock: Why are you trying to avoid the IO monad?
02:21:02 <mbrock> I'm optimizing a pure function
02:21:12 <Axman6> it should be a pure operation really
02:21:24 <merijn> Rather you than me ;)
02:22:05 <merijn> Alternatively, does anyone know a better place to poll for API opinions? :p
02:22:07 <mbrock> well, at least it's a profiled bottleneck :)
02:22:19 <mbrock> Axman6: I guess I'll try a simple unsafePerformIO
02:22:28 <mbrock> (famous last words, right?)
02:22:41 <Axman6> the comments about platform specificness of Int may be something you need to think about
02:22:45 <merijn> mbrock: At least it's not accursedUnutterablePerformIO :)
02:23:12 <mbrock> ah yeah, in my case it's actually a `Vector Word8' so I think it's fine
02:23:38 <Axman6> mbrock: it should be fine to use unsafePerformIO here, in face I'm kind of surprised you'd need to use IO at all, it should be an operation on values only, no IO necessary
02:24:16 <merijn> mbrock: How are you getting the Vector Word8?
02:24:52 <mbrock> merijn: via Vector.create and the Mutable API
02:25:26 <Axman6> using Data.Vector.Stroable.unsafeToForeignPtr you should be able to make a ByteString easily
02:26:02 <merijn> I was thinking you could maybe go via a GHC Array# or Addr#, but bytestring still use IO for those I see
02:27:00 <Axman6> it's annoying the constructors for ByteString aren't exposed
02:27:19 <Axman6> because a ByteString is just a wrapper around ForeignPtr
02:27:32 <Axman6> which you can easily get from Data.Vector.Stroable.unsafeToForeignPtr
02:28:01 <jophish> Axman6: there is a package which will allow you to get the constructor with TH
02:28:07 <jophish> trying to remember it now
02:28:09 <Axman6> ew
02:28:53 * Axman6 -> gone
02:30:53 <Athas> Is there an easy way to use Template Haskell to compute some arbitrary value at compile-time, and make it available at run-time?
02:31:13 <Athas> My use case is that I'm writing a compiler, and it would be useful to pre-parser/typecheck the standard library and embed it in the compiler executable.
02:31:13 <jophish> Axman6: true-name
02:31:16 <jophish> I think is the package
02:31:41 <Athas> I can embed the library source code with the file-embed package, which is OK, but it means it is parsed and type-checked whenever the compiler runs.
02:31:43 * angerman 'll be around if someone has questions re TH + CC
02:31:43 <jophish> https://github.com/liyang/true-name/blob/master/sanity.hs
02:32:04 <jophish> angerman: how are you planning on making it work?
02:32:15 <quchen> Athas: This might help a bit, https://github.com/quchen/articles/blob/master/useful_techniques.md#poor-mans-supercompiler
02:32:17 <angerman> jophish: no spoilers :)
02:32:48 <jophish> :)
02:32:49 <angerman> jophish: however, see https://www.irccloud.com/pastebin/iuaW4a2s/ :D
02:32:58 <merijn> Athas: I would say that should be easy on two conditions
02:33:40 <merijn> Athas: 1) the result of pre-checking is a data-structure and 2) the data structure has a Lift instance
02:33:56 <Athas> Where is Lift defined?
02:34:15 <Athas> It's a pretty simple structure (just a bunch of Data.Maps; no functions), so it *should* be serialisable or whatnot.
02:34:32 <merijn> Athas: Template Haskell, but, since I'm guessing this is research stuff so you don't give a shit about backwards compat: GHC 8 has a DeriveLift extension :)
02:35:01 <merijn> So you should be able to just standalone derive any missing instance for simple datatypes
02:35:18 <Athas> I do actually give a shit, since I have ~users!  But since I use stack they will just get whichever GHC I tell them to get.
02:35:27 <merijn> I should probably update validated-literals for GHC8...
02:35:31 <Athas> Hm.  And adding such instances for container-defined types won't cause issues?
02:35:56 <angerman> jophish: which reminds me, I still need to improve the post for tomorrow :)
02:35:58 <Athas> This sounds doable.  Thank you.
02:36:06 <merijn> Athas: You might need to CPP around if they get added later
02:36:38 <angerman> quchen: "You'll notice this compiles slowly, but runs very fast" ... yea! :D
02:37:17 <jophish> Athas: instead of baking the standard libray into the binary, I'd be tempted to implement some serialised IR, and just precompile the standard library once
02:37:28 <Athas> merijn: CPP?  Never!  I'll just narrow the GHC version requirements.
02:37:36 <jophish> this may not be appropriate for your language however
02:37:41 <Athas> jophish: that creates file system dependencies.
02:38:01 <Athas> I want to avoid having the user worry about installation locations and include paths, at least for the built-in standard library.
02:38:45 <Athas> This language is totally unsuitable for separate/incremental compilation anyway, so this exercise is mostly so I can have a fairly large "prelude" without paying too much in type-checking costs for small programs.
02:39:59 <sphinxo> Athas: dodgy solution: create something similar to happy or alex, that runs at the same time, that is imported
02:40:26 <sphinxo> you'd have to have a 2 stage build process, the later including the standard library
02:40:44 <reactormonk[m]> How can I tell stack build to use all my cores globally?
02:41:30 <Athas> sphinxo: I don't think cabal supports that.l
02:42:08 <sphinxo> Have 2 separate modules? probably quite innefficient
02:42:22 <sphinxo> Second is first + standard lib
02:46:33 <Athas> sphinxo: still, how would you do that with Cabal?
02:46:42 <Athas> I don't think it supports preprocessors that are part of the same package.
02:46:53 <Athas> Besides, isn't happy/alex hardwired into Cabal?
02:47:03 <merijn> Athas: No, you need to manually install them
02:47:18 <merijn> Athas: Oh, you mean as preprocessors?
02:47:27 <merijn> Athas: You can write custom ones if you switch to Custom build
02:47:38 * hackage uri-bytestring-aeson 0.1.0.1 - Aeson instances for URI Bytestring  https://hackage.haskell.org/package/uri-bytestring-aeson-0.1.0.1 (reactormonk)
02:48:03 <merijn> Athas: Did that for c2hsc at some point: https://github.com/merijn/SNet2.0/blob/master/Setup.hs
02:48:08 <reactormonk[m]> I've fixed my library mentioned in https://github.com/fpco/stackage/issues/2532 - do I need to do anything besides uploading it to hackage?
02:48:31 <Athas> Urgh.  I think I'll go with the Template Haskell approach.  It seems simpler and cleaner.
02:48:36 <Athas> (Never thought I'd say that.)
02:48:38 * hackage wave 0.1.5 - Work with WAVE and RF64 files  https://hackage.haskell.org/package/wave-0.1.5 (mrkkrp)
02:48:48 <Saizan> Athas: you can add code for handling more preprocessors in the Setup file, iirc
02:48:58 <merijn> reactormonk[m]: Comment on that issue and ask?
02:57:21 <wz1000> Is there a pretty way to build Aeson objects instead of using trillions of A.Object $ H.fromList [...]?
02:59:16 <Philonous> wz1000, object [ "key1" .= value1, "key2" .= value2 ... ] 
02:59:35 <wz1000> Ah, nice
03:02:37 <mbrock> yay, my program runs 16x faster :)
03:03:10 <mbrock> sometimes optimizing is fun...
03:03:52 <mbrock> got some big speedups just from using Map.fromAscList instead of Map.fromList
03:04:54 <quchen> angerman: TH uses something similar to GHCi, so you get similar speeds
03:05:41 <angerman> quchen: yes :-) I just liked that line :)
03:07:44 <angerman> alright. some time to chill, and then going to finish the "Cross Compiling Template Haskell" post :)
03:18:38 * hackage servant-multipart 0.10.0.1 - multipart/form-data (e.g file upload) support for servant  https://hackage.haskell.org/package/servant-multipart-0.10.0.1 (phadej)
03:20:08 * hackage servant-mock 0.8.2 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.8.2 (phadej)
03:23:02 <phadej> _sars_: you try it with `ListResult UTCTime` or something like that?
03:23:08 <phadej> _sars_: sorry, I have no idea
03:23:31 <_sars_> phadej: It works now.
03:26:08 * hackage pang-a-lambda 0.2.0.0 - A super-pang clone  https://hackage.haskell.org/package/pang-a-lambda-0.2.0.0 (keera_studios_ci)
03:29:54 <phadej> _sars_: great
03:30:03 <phadej> _sars_: what you did?
03:44:53 <AnonymousVN-TN> hello
03:46:20 <_sars_> phadej: I think it happned becuse I was using the same name (in named schema) for all the types that was using this instance, and UTCTime happend to be one of them..
03:47:14 <_sars_> phadej: I am using the swagger-ui to view the result, so when the references have same name, they seem to overlap eachother..
03:47:44 <hanna> When using the FFI, is there any easier to get the contents of a DEFINED_CONSTANT into my haskell code other than wrapping it inside a pure function that returns this value?
03:49:10 <phadej> _sars_: there is an issue about that, nobody just got to it: https://github.com/GetShopTV/swagger2/issues/94
03:49:59 <phadej> _sars_: i.e. known problem, and we have "a plan", but it doesn't cause enough pain yet
03:51:11 <_sars_> phadej: I see...
03:51:19 <hanna> ‚ÄúIn particular, there is no support for accessing pre-processor symbols from Haskell, which includes #defined constants.‚Äù aaw
03:54:10 * hackage postmaster 0.3.2 - Postmaster ESMTP Server  https://hackage.haskell.org/package/postmaster-0.3.2 (PeterSimons)
03:54:56 <sullyj3> hey everyone! Couple of questions - first a style one: given import Data.Traversable (for), which do you prefer of:
03:55:00 <sullyj3> for [1..5] $ \x -> print x >> getLine
03:55:07 <sullyj3> for [1..5] $ (>> getLine) . print
03:55:14 <sullyj3> import Control.Arrow ((>>>))
03:55:19 <sullyj3> for [1..5] $ print >>> (>> getLine)
03:55:33 <sullyj3> or is there something nicer?
03:56:11 <Philonous> for [1..5] $ \x -> print x >> getLine -- That's the only one I can read without having to stop and think what's going on
03:56:48 <bollu> Philonous++
03:56:58 <quchen> bollu++
03:57:01 <Akii> +1 from me as well
03:57:05 <cocreature> quchen++
03:57:08 <bollu> xD
03:57:14 <Akii> (c-c-c-combo breaker)
03:57:17 <sullyj3> Yeah, you're right, it's definitely clearer. I just have an ick reaction to lambdas for some reason
03:57:29 <cocreature> lambdas are great :)
03:57:30 <Xion_> print =<< getLine ?
03:57:35 <bollu> sullyj3: run your entire codebase through @pl then? :P
03:57:37 <Philonous> sullyj3, Then you might be in the wrong channel :P
03:57:49 <quchen> And lambdas are not more expensive than pointfree style.
03:58:00 <cocreature> Xion_: that‚Äôs not the same as \x -> print x >> getLine
03:58:15 <sullyj3> I know they're not more expensive, I just think they're uglier
03:58:27 <Xion_> cocreature: Oh, print x AND then get another line
03:58:38 <sullyj3> Xion_: yep
03:58:41 <Philonous> sullyj3, Btw. that line is still OK, but if it got any longer I'd use do notation instead of >> 
03:59:31 <Xion_> for [1..5] $ \x -> do { print x; line <- getLine; return line } -- *hides*
03:59:54 <sullyj3> Philonous, yeah, definitely would for anything longer
04:02:02 <lpaste> merijn pasted ‚ÄúAPI design question: folds over Channel‚Äù at http://lpaste.net/8469104504694898688
04:05:45 <hanna> sullyj3: there's also for [1..5] $ \x -> do print x; getLine
04:05:56 <hanna> oops, Xion_ already mentioned it (essentially)
04:08:14 <merijn> Any comments on my API design issue?
04:09:24 <sullyj3> second question, is there a nice, one or two standard library function replacement for the following function?
04:09:35 <sullyj3> map_part :: (a -> a) -> (a -> Bool) -> [a] -> [a]
04:09:41 <sullyj3> map_part f discrim xs = let partitioned = partition discrim xs in
04:09:47 <sullyj3>   (map f $ fst partitioned) ++ (snd partitioned)
04:10:10 <mniip> does it have to move the unmodified elements to the back?
04:10:33 <sullyj3> yep
04:10:38 * hackage servant-swagger 1.1.3 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1.3 (phadej)
04:10:42 <hanna> map (\x -> if discrim x then f x else x)
04:10:46 <mniip> then no, I'm afraid that's too specific
04:10:49 <hanna> that also preserves the order
04:11:04 <hanna> which I'm sure you can combine using if' and friends
04:11:19 <mniip> you might have some luck with hanna's code and probably sortOn @Bool
04:11:25 <cocreature> hanna: "over (filtered discrim) f" :)
04:11:40 <hanna> oh right, lenses :p
04:11:42 <sullyj3> come to think of it, preserving order is probable better
04:11:45 * hanna has actually been laying off the lenses
04:12:01 <mniip> :t sortOn
04:12:03 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
04:12:17 <sullyj3> bollu: what was that @pl thing you mentioned earlier?
04:12:17 <mniip> > sortOn even [3,7,4,1,2,6,3]
04:12:20 <lambdabot>  [3,7,1,3,4,2,6]
04:12:36 <sullyj3> mniip: ooooh
04:12:37 <hanna> also while we're on the topic of style, I would write your map_part like this
04:12:38 <bollu> @pl \f g x -> f (g (x))
04:12:38 <lambdabot> (.)
04:12:39 <sullyj3> cool
04:12:56 <bollu> @pl for [1..5] $ \x -> print x >> getLine
04:12:56 <lambdabot> for [1..5] ((>> getLine) . print)
04:12:57 <hanna> map_part f g xs = map f ys ++ ns  where (ys, ns) = partition g xs
04:12:57 <sullyj3> bollu: ooh, handy!
04:13:05 <bollu> sullyj3: :)
04:13:06 <hanna> (with the where on a separate line)
04:13:10 <mniip> just one catch
04:13:26 <mniip> depending on the implementation of Data.List.sort it might be nlogn or even quadratic
04:14:33 <sullyj3> isn't n log n the minimum for comparison sorting anyway?
04:14:47 <merijn> Yes
04:14:51 <Xion_> hanna: Yeah, I was just going for extra verbosity :)
04:15:23 <hexagoxel> merijn: is there a point in the `Chan In a` existing before running this?
04:15:37 <mniip> sullyj3, you could write a radix sort of sorts
04:15:40 <merijn> hexagoxel: "Chan In a" *always* exists first
04:15:46 <sullyj3> :t over
04:15:48 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
04:15:48 <mniip> which would be linear for Bool
04:15:54 <merijn> hexagoxel: "Chan Out a" is tied to a specific "Chan In a"
04:16:17 <hexagoxel> merijn: like, would it make sense to have it `Fold a b -> IO (Chan In a, IO b)`
04:17:03 <hexagoxel> which still has the confusing double-IO, but the semantics seem more intuitive.
04:17:25 <sullyj3> hanna: I like that one. is ys and ns a common idiom for the outcomes of a predicate?
04:17:40 <merijn> hexagoxel: Well, one of the main ideas is that you can have a "Chan In Event" where your application publishes events and users can dynamically hook into that to start listening for events
04:17:43 <hanna> I don't know, I came up with it on the fly
04:17:47 <muzzle> hi
04:17:54 <sullyj3> Very creative :)
04:17:54 <muzzle> is there a way to profile a single function only?
04:18:06 <hanna> sullyj3: but using pattern matches to deconstruct the tuples is way more idiomatic than using ‚Äòfst‚Äô and ‚Äòsnd‚Äô
04:18:07 <merijn> @hackage criterion -- muzzle
04:18:07 <lambdabot> http://hackage.haskell.org/package/criterion -- muzzle
04:18:14 <hexagoxel> merijn: ah, right. won't work with that.
04:18:18 <sullyj3> yeah, it's pretty
04:18:25 <merijn> hexagoxel: Which seems to useful to disallow
04:18:25 <hanna> it would also be more idiomatic to write something like map f (fst xs) ++ snd xs  instead of (map f $ fst xs) ++ (snd xs)
04:19:07 <merijn> hexagoxel: The 2nd one I think is simplest/most intuitive, but makes it really hard, if not impossible to implement something simple like "spawn N workers listening before writing"
04:19:59 <hexagoxel> merijn: but in that case, you have no control over when writing starts anyway?
04:20:12 <muzzle> merijn criterion allows me to do benchmarks, but that alone doesn't really help me in pinpointing, which part of some code makes my function slow?
04:20:39 <merijn> muzzle: ah...I dunno what people are currently using for that
04:20:51 <sbrg> muzzle: there is no point in profiling only a single function because that won't give you information about how it performs relative to the rest of your code, no? 
04:20:56 <hexagoxel> merijn: or: if you control when writing starts via some other means, why not pass in the `Chan In a` as a signal to start writing?
04:21:50 <merijn> hexagoxel: Well, my point is that 2) makes a usecase of "ch <- newChan; replicateM_ 10 (forkIO $ foldChan ch); startWriting ch" hard to do right, since you can't ensure the threads have created the "Chan Out" before you start writing
04:22:00 <sbrg> muzzle: however, there is the `weigh` package, which can give you some approximate memory usage, and as previously mentioned, `criterion` for benchmarking
04:22:11 <merijn> hexagoxel: That doesn't work, because you'd still have a race
04:22:24 <muzzle> sbrg, I don't really care about the rest of my code, I specifically want to know what makes one function slow. The background is that I have a fairly long and large initialization function that I don't want to pollute my profiling-report 
04:22:33 <merijn> hexagoxel: I wrote this thing to solve a space-leak with Chan, but the result means that writes before listeners exist are dropped on the floor
04:22:44 <merijn> hexagoxel: So you have to be sure listeners are created before you start writing
04:23:32 <mniip> hey edwardk
04:23:47 <merijn> hexagoxel: The problem with the "create listener and immediately fold" approach of (2) means that the listeners can't signal they've finished creating a listener
04:23:58 <merijn> hexagoxel: Because they'll already be executing the fold
04:24:02 <hexagoxel> merijn: i completely agree with the analysis of the three options that you have.
04:24:05 <edwardk> sup
04:24:06 <sbrg> muzzle: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#inserting-cost-centres-by-hand perhaps this is what you need?
04:24:27 <sullyj3> what about this related one, guys? how would you write this:
04:24:28 <sullyj3> mapWhile f pred xs = (map f . takeWhile pred) xs ++ dropWhile pred xs
04:24:39 <sullyj3> wait..
04:24:44 <mniip> edwardk, remember our earlier discussion about LR parsers in haskell
04:24:49 <mniip> the thing with unlabelled recursion
04:24:54 <sullyj3> @pl mapWhile f pred xs = (map f . takeWhile pred) xs ++ dropWhile pred xs
04:24:54 <lambdabot> mapWhile = (`ap` dropWhile) . (liftM2 (++) .) . (. takeWhile) . (.) . map
04:24:56 <edwardk> vaguely
04:24:59 <sullyj3> ew
04:25:00 <merijn> hexagoxel: (3) has all the power and flexibility, but is a bit confusingly typed. (1) has all the power and flexibility and is easy to use, but also allows messing up...(2) just seems unworkable
04:25:02 <muzzle> sbrg I don't really want to insert more cost centres
04:25:15 <muzzle> sbrg I want to have all the ones that I'm not interested in gone
04:25:41 <merijn> muzzle: Well, there's one thing you could do if you're willing to dive into a rabbit hole
04:25:42 <edwardk> was this sort of the issue with using observable sharing, vs. combinators vs. the frisbee approach of managing it with an external edsl?
04:25:44 <sbrg> muzzle: yes, I was thinking that you'd not use -fprof-auto and instead annotate the cost centers manually for only the things you are interested in
04:25:44 <mniip> edwardk, so I took a closer look at what would such an LR parser require, and how it would cope with infinite number of incomparable nonterminals
04:26:05 <sbrg> sullyj3: there's `span` that could make it prettier
04:26:11 <sullyj3> :t span
04:26:13 <sbrg> > span (< 5) [1..10]
04:26:13 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
04:26:15 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
04:26:18 <merijn> muzzle: Modern GHC should be able to generate DWARF symbols. Then you could run your code through Intel VTune Amplifier and use that profiling and DWARF to relate it back to source locations
04:26:28 <merijn> muzzle: Of course that requires a VTune license
04:27:09 <mniip> edwardk, if you have incomparable nonterminals the only way you can apply reduce rules is by tracking their locations in the "tree"
04:27:16 <sullyj3> sbrg: cool!
04:27:17 <mniip> and that
04:27:20 <mniip> is an LL parser
04:27:28 <merijn> edwardk: As expert Haskeller and general knowledgable dude, can you spare a sec to give some feedback on my API design conundrum? http://lpaste.net/8469104504694898688
04:28:16 <merijn> hexagoxel: Alternatively I was thinking of augmenting (2) by adding some sort of "done" callback, but really that just makes it's type even more confusing than (3)
04:28:34 <edwardk> mniip: you can make a monad that does the CFG style chart parsing like the Jean-Philippe Bernardy-Koen Claessen paper, and then observe under >>='s so even in the presence of an infinite context dependent grammar you can recover parsability by exploiting the finiteness of the file you are parsing and some guarantees about consumption in the parser to ensure
04:28:34 <edwardk> progress
04:28:53 <mniip> well
04:28:57 <mniip> that requires observable sharing
04:29:02 <edwardk> its similar to your note above about tracking by position in the tree, you track by position in the input
04:29:04 <mniip> i.e the nonterminals being equatable
04:29:04 <edwardk> sure
04:29:06 <mniip> of some sort
04:29:54 <mniip> and, well, yeah, there isn't much problem with an infinite amount of nonterminals as long as you can enumerate them in some fashion
04:29:58 <edwardk> ok, if you want everything incomparable then yeah, you're stuck because you can never reduce to get an LR parse
04:30:09 <mniip> (practically you'd want a tree or a Free Reader)
04:31:55 <edwardk> merijn: Chan In a -> Fold a b -> IO (IO b) feels a little like the 'subscription' model a lot of IObservable APIs offer, except batched up til the end
04:32:48 <merijn> edwardk: Well, that's quite what it's intended to allow, yes
04:32:55 <merijn> s/quite/kinda
04:32:57 <merijn> brainfart
04:33:12 <edwardk> e.g. there i usually do something like: newtype Observable a = Observable { subscribe :: Observer a -> Task Subscription }
04:33:37 <edwardk> where Observer is a contravariant functor that takes messages from your observable until you cancel :: Subscription -> Task ()
04:34:00 <edwardk> Task here being a monad for fork/join work-stealing stuff
04:34:53 <edwardk> e.g. to get exactly the Observable API from C# you'd have data Observer a = Observer { (!) :: a -> Task (), handle   :: SomeException -> Task (), complete :: Task () }
04:34:56 <mniip> edwardk, by the way, are you involved with SoH this year?
04:35:22 <merijn> Alternatively, I suppose I could expose a "safe" and "unsafe" API, one working directly on "Chan Out" with the type of (1) and a safe module working on "Chan In" directly
04:35:25 <sullyj3> what happens if I..
04:35:29 <sullyj3> > [1..]
04:35:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:35:38 <sullyj3> fair enough
04:36:06 <mniip> sullyj3, don't worry, it's been idiot-tested for years ;)
04:36:18 <sullyj3> haha I'm sure
04:36:40 <merijn> Althought that kinda split makes the API surfce kinda big, since I already have 2 versions of the API and adding other axes will just give me a combinatorial explosion...
04:36:49 <edwardk> jasper and niki are running it this year, this'll be the first year in the last decade or so when i _don't_ mentor someone for it i think. one student reached out to me
04:37:01 <edwardk> but i don't recall it coming up beyond that
04:37:39 * hackage servant-swagger-ui 0.2.3.2.2.8 - Servant swagger ui  https://hackage.haskell.org/package/servant-swagger-ui-0.2.3.2.2.8 (phadej)
04:42:21 <hexagoxel> merijn: sorry, i don't really have anything to add. every solution seems to have its tradeoffs. In FRP this would be easy, though.
04:43:04 <merijn> hexagoxel: Well, I didn't think there would be a clean solution, I was more looking for "I would personally prefer API X" so I have some idea what other people would prefer
04:43:47 * mniip prods jaspervdj then
04:44:54 <hexagoxel> i'd probably go with 3) then. some mental/documentation overhead seems better than multiple variants.
04:44:56 <LAZAR_> How would you parse a json object with arbitraty and unknown fields in Aeson like "dependencies":{"12factor-config":"^1.0.0","lodash":"^3.6.0","node-env-file":"^0.1.7" }
04:45:09 * hackage ansi-terminal 0.6.3 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.6.3 (RomanCheplyaka)
04:45:55 <merijn> hexagoxel: I'll probably just publish this as a candidate first and ask for more feedback then before settling on a final API :)
04:48:41 <amx> LAZAR_: depends on what you want to do, try one of these: https://artyom.me/aeson#unknown-field-names  https://hackage.haskell.org/package/aeson-1.2.0.0/docs/Data-Aeson.html#g:3
04:51:03 <LAZAR_> amx: thanks that will help... i did not know what to search for... tried unstructured json 
05:04:28 <WhereIsMySpoon> Hey, is there a way to write this as a list comprehension? https://gist.github.com/Jarob22/9f17abf82aa1b722a6209f25f18d06d7
05:05:47 <Cale> No, but the guards are pretty spurious
05:05:56 <Cale> isPalindrome xs = reverse xs == xs
05:06:35 <Cale> also, Ord isn't required here, only Eq
05:06:47 * angerman is still around should there be questions re TH + CC.
05:08:06 <WhereIsMySpoon> Cale: why spurious?
05:08:23 <WhereIsMySpoon> Cale: why Eq and not Ord
05:09:00 <WhereIsMySpoon> i thought arrays were ord
05:09:22 <Unode> WhereIsMySpoon: Ord implies that you need to order them somehow to compare. Eq means you can compare each entity regardless of how they order in the relation to each other.
05:09:49 <WhereIsMySpoon> i see, ok
05:10:36 <wz1000> (Ord a) signfies that you can perform comparisions on things of type a. You don't need any comparisions to write isPalindrome.
05:10:46 <WhereIsMySpoon> true
05:10:52 <angerman> WhereIsMySpoon, Cale, well we can do: f = \x -> all id [x == y | (x,y) <- zip x (reverse x)], no?
05:11:17 <Boomerang> > let pal = ((==) <*> reverse) . map toLower in pal "God saw I was dog"
05:11:19 <lambdabot>  True
05:11:44 <wz1000> and = all id
05:11:46 <wz1000> :t and
05:11:49 <lambdabot> Foldable t => t Bool -> Bool
05:12:03 <angerman> wz1000: ahh right. That's the one :)
05:13:03 <WhereIsMySpoon> angerman: ive spent less than a day doing haskell
05:13:14 <WhereIsMySpoon> i have no idea what that code you just put there means :D
05:13:33 <angerman> you asked for a list comprehension :)
05:13:59 <wz1000> isPalindrome xs = and [ x == y | (x,y) <- zip xs (reverse xs) ]
05:14:05 <wz1000> That better?
05:14:46 <wz1000> > zip [1,2,3] [3,2,1]
05:14:48 <lambdabot>  [(1,3),(2,2),(3,1)]
05:15:15 <wz1000> > zip [1,2,3,2,1] [1,2,3,2,1]
05:15:18 <lambdabot>  [(1,1),(2,2),(3,3),(2,2),(1,1)]
05:16:07 <Boomerang> You could also use zipWith (==)
05:16:46 <WhereIsMySpoon> wz1000: nope
05:17:26 <WhereIsMySpoon> angerman: I thought list comprehensions were like myFunc :: <type info>; myFunc [] = er
05:17:35 <WhereIsMySpoon> error ‚Äúempty list‚Äù;
05:17:36 <WhereIsMySpoon> and so on
05:18:31 <wz1000> No, list comprehensions are things of the form [ expr{a,b..} | a <- list1, b <- list2 ..]
05:18:56 <Xion_> > isPalindrome xs = all . zipWith (==) $ xs (reverse xs)
05:18:58 <lambdabot>  <hint>:1:17: error:
05:18:58 <lambdabot>      parse error on input ‚Äò=‚Äô
05:18:58 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:19:10 <WhereIsMySpoon> wz1000: hm, ok
05:19:20 <WhereIsMySpoon> wz1000: whats what I just put called then
05:19:24 <wz1000> > [ x + y | x <- [1,2,3], y <- [5,6,7] ]
05:19:27 <lambdabot>  [6,7,8,7,8,9,8,9,10]
05:19:33 <mniip> WhereIsMySpoon, a pattern match?
05:19:34 <mniip> on lists?
05:19:39 <mniip> list destruction?
05:19:54 <WhereIsMySpoon> I thought the one with | was pattern matching
05:20:06 <mniip> that's guards
05:20:06 <angerman> that's pattern GUARDS.
05:20:08 <wz1000> No, | is used for guards
05:20:13 <WhereIsMySpoon> ok
05:20:17 <WhereIsMySpoon> cool, thank you
05:20:19 <angerman> the naming is not that fortunate :)
05:20:33 <WhereIsMySpoon> can you generally write functions in any of those 3 ways?
05:20:33 <Cale> angerman: pattern guards are a special kind of guards
05:20:46 <angerman> hmm ok maybe better to say "it can be confusing at first".
05:21:11 <mniip> uhh
05:21:13 <angerman> Cale: true.
05:21:29 <mniip> I might be misremembering, but aren't they actually called pattern guards?
05:21:33 <mniip> because they guard patterns?
05:21:49 <mniip> func pattern | guard
05:21:55 <WhereIsMySpoon> oh and there was one other
05:22:02 <Cale> Pattern guards are things like  f m (x:xs) | Just y <- lookup x m = ...
05:22:09 <angerman> we also have them in multiWayIfs
05:22:27 * mniip gets the report
05:22:30 <WhereIsMySpoon> let ys = <somefunc> xs in; case ys of; <condition> -> result
05:22:34 <WhereIsMySpoon> whats that one called
05:23:03 <mniip> ok
05:23:07 <mniip> you are correct
05:23:11 <Cale> That's called... putting semicolons in syntactically invalid locations :)
05:23:14 <anieuwland> Hi! Compiling with haskell-gi (for gtk bindings) is very slow. Does anyone know how to speed it up?
05:23:26 <WhereIsMySpoon> imagine there‚Äôs newlines where there are semicolons :P
05:23:28 <mniip> a "guard" is either a "pattern guard" or a binding or a "boolean guard"
05:23:36 <WhereIsMySpoon> im still not up with how onelining haskell works
05:23:37 <Cale> But it's otherwise a let expression containing a case expression.
05:23:50 <WhereIsMySpoon> is there a name for that one, Cale ?
05:23:59 <mniip> 'case' expressions?
05:24:14 <mniip> and let-bindings
05:24:49 <WhereIsMySpoon> oki doki
05:25:08 <WhereIsMySpoon> is there some rules or advice when to use one of these patterns over the others?
05:25:20 <WhereIsMySpoon> just whatever reads best and is the most concise?
05:25:29 <quchen> Yup
05:25:31 <mniip> "reads best"
05:25:37 <mniip> moreso than "most concise"
05:25:38 <WhereIsMySpoon> yes im aware thats subjective
05:26:09 <WhereIsMySpoon> ok
05:26:25 <quchen> All pattern matching is desugared to ¬ªcase¬´ anyway, so you likely end up with the same code in each case
05:26:33 <mniip> fix$(0:).scanl(+)1
05:26:38 <mniip> is concise
05:26:42 <WhereIsMySpoon> o.O
05:26:43 <quchen> No, that‚Äôs short.
05:26:48 <WhereIsMySpoon> wtf is that :P
05:26:50 <quchen> Concise is not necessarily short.
05:27:02 <quchen> And short is not necessarily concise.
05:27:06 <WhereIsMySpoon> true
05:27:39 <quchen> ¬ªsum . filter even . map (^2) . enumFrom 1¬´ is concise.
05:27:42 <codedmart> Gurkenglas: Sorry I didn't respond. It actually was a stupid error. I didn't realize I installed aeson-lens and not lens-aeson.
05:28:01 <mniip> it is also nonterminating
05:28:05 <mniip> er
05:28:06 <mniip> nevermind
05:28:11 <hamishmack> anieuwland: Turning off the haskell-gi overloading feature makes a really big difference, not just to the compile time of haskell-gi but also any module that imports any haskell-gi module
05:28:15 <quchen> s/enumFrom/enumFromTo/
05:28:20 <mniip> yeah
05:28:25 <quchen> mniip: You‚Äôre right for unbounded types.
05:28:38 <quchen> Nevermind, it‚Äôs a type error in any case.
05:28:46 <hamishmack> anieuwland: If you are using cabal new-build use something like https://github.com/leksah/leksah/blob/master/cabal.project#L12
05:28:50 <quchen> > enumFromTo 1 10 -- That one.
05:28:51 <anieuwland> hamishmack: That's great! I guess you mean OverloadedLabels? How do I do that?
05:28:52 <mniip> well, alright
05:28:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:28:54 <WhereIsMySpoon> how do I rewrite my isPalindrome to use pattern matching 
05:29:19 <anieuwland> hamishmack: thanks for the link I'll look at it
05:29:21 <hamishmack> anieuwland: For stack use something like https://github.com/leksah/leksah/blob/master/stack.yaml#L40
05:29:25 <mniip> WhereIsMySpoon, I'm not sure that's the best idea
05:29:32 <anieuwland> hamishmack: Ahh great, yes I use stack
05:29:38 <WhereIsMySpoon> mniip: maybe not but id like to know if its possible and how to do it
05:29:54 <mniip> you would have to figure out how you want to do it first
05:30:05 <WhereIsMySpoon> i dont know how :P
05:30:07 <anieuwland> thanks hamishmack! 
05:30:08 <WhereIsMySpoon> tahts why im asking
05:30:11 <anieuwland> hamishmack++
05:30:13 <quchen> Your code says ¬ªif xs == reverse xs then True else False¬´, that‚Äôs the same as just writing ¬ªxs == reverse xs¬´.
05:30:41 <mniip> WhereIsMySpoon, no, you've asked "how to write it using pattern matching"
05:30:43 <mniip> that is different
05:31:03 <WhereIsMySpoon> ‚Ä¶huh
05:31:33 <mniip> hm
05:31:37 <mniip> I'm sounding confusing
05:31:57 <quchen> I don‚Äôt think you can write isPalindrome using pattern matching in a useful way.
05:32:04 <mniip> WhereIsMySpoon, you have to come up with a way to check a string for palindromeness if you're working with individual characters
05:32:14 <WhereIsMySpoon> mniip: any array
05:32:28 <WhereIsMySpoon> well..of basic types i guess
05:32:34 <mniip> no arrays
05:32:49 <WhereIsMySpoon> no, its any array of types that are of type Eq
05:33:07 <mniip> you're conflating lists and arrays
05:33:08 <WhereIsMySpoon> that no was to myself sorry
05:33:11 <mniip> ther's bad
05:33:11 <WhereIsMySpoon> er
05:33:14 <mniip> that's bad*
05:33:22 <WhereIsMySpoon> enlighten me :)
05:33:28 <mniip> lists are built from cons cells
05:33:55 <mniip> a list is either an "empty list", or an element concatenated to the rest of the list
05:34:28 <mniip> that means that in a single operation you can only split the list into its "head" and "tail" or conclude that it's empty
05:34:39 <WhereIsMySpoon> right
05:34:47 <mniip> also in a single operation you can prepend an element to a list
05:34:58 <mniip> arrays on the other hand can be freely indexed
05:35:46 <WhereIsMySpoon> so can lists?
05:35:53 <mniip> not in a single operation
05:35:57 <WhereIsMySpoon> [1,2,3]!!1 == 2
05:36:03 <mniip> !! is a recursive function
05:36:10 <WhereIsMySpoon> ah ok
05:36:12 <mniip> that takes time proportional to the index
05:36:17 <WhereIsMySpoon> true
05:36:18 <WhereIsMySpoon> ok
05:36:41 <WhereIsMySpoon> so [1,2,3] is a list
05:36:48 <mniip> yes
05:36:51 <WhereIsMySpoon> whats an array example
05:36:54 <mniip> that's syntactic sugar for
05:36:57 <mniip> 1:2:3:[]
05:37:05 <WhereIsMySpoon> right
05:37:08 <mniip> read:  1:(2:(3:[]))
05:37:25 <mniip> : is the "cons", the prepend operation
05:37:50 <mniip> arrays aren't a primitive type in haskell
05:38:11 <mniip> there's a module, Data.Array that lets you use arrays, but the datatypes in there aren't "transparent"
05:38:24 <mniip> on the contrary they are opaque
05:38:36 <mniip> :t listArray
05:38:37 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
05:39:02 <mniip> :t listArray (1, 10 :: Int) [1..10 :: Int]
05:39:04 <lambdabot> Array Int Int
05:39:19 <mniip> there, you have an array, but you can't "look inside" it other than with the provided functions
05:40:26 <WhereIsMySpoon> ok let me try and understand that function def
05:40:37 <WhereIsMySpoon> so the i‚Äôs are of type Ix
05:40:39 <mniip> you mean 'type'
05:40:54 <mniip> I think it's best you forget this for now and come back to it later
05:41:02 <WhereIsMySpoon> >,<
05:41:03 <WhereIsMySpoon> ok
05:41:10 <WhereIsMySpoon> :D
05:41:28 <mniip> as far as palindromes with pattern matching go
05:41:31 <WhereIsMySpoon> i just find it interesting that there are completely different ways to write functions that cant map to each other
05:41:40 <mniip> your best bet is to implement == and 'reverse' with pattern matching
05:41:56 <mniip> and then write isPalindrome with that
05:42:00 <Cale> WhereIsMySpoon: what do you mean?
05:42:29 <WhereIsMySpoon> mniip: well that seems like a waste of time :)
05:42:41 <mniip> implementing your own reverse is a good excercise
05:42:45 <WhereIsMySpoon> ive already done that
05:42:47 <WhereIsMySpoon> :)
05:42:56 <mniip> may I take a look
05:43:02 <WhereIsMySpoon> https://wiki.haskell.org/99_questions/1_to_10
05:43:04 <WhereIsMySpoon> doing ths
05:43:06 <WhereIsMySpoon> sure
05:43:16 <WhereIsMySpoon> reverseM :: (Ord a) => [a] -> [a]
05:43:16 <WhereIsMySpoon> reverseM [] = []
05:43:17 <WhereIsMySpoon> reverseM (x:xs) = (reverseM xs)++[x]
05:43:44 <mniip> why Ord
05:44:00 <WhereIsMySpoon> ive been using it for all my list function types
05:44:06 <mniip> you shouldn't
05:44:06 <WhereIsMySpoon> it isnt necessary i see now :)
05:44:21 <WhereIsMySpoon> Eq, right?
05:44:25 <mniip> no
05:44:27 <mniip> none
05:44:35 <WhereIsMySpoon> oh, right
05:44:38 <WhereIsMySpoon> it doesnt matter what type a is
05:45:53 <WhereIsMySpoon> hm..i dont know how to put ‚Äúany‚Äù type
05:46:06 <MasseR> Just remove the Ord constraint :)
05:46:20 <MasseR> Ord a => [a] -> [a] into [a] -> [a]
05:46:37 <WhereIsMySpoon> oh, right
05:46:58 <WhereIsMySpoon> coolio :)
05:47:04 <mniip> also, I'm not sure if it's the right time for nitpicking on your implementation
05:47:09 <WhereIsMySpoon> feel free
05:47:12 <mniip> (basically, it's terrible)
05:47:16 <WhereIsMySpoon> probably
05:47:27 <WhereIsMySpoon> performance wise you mean?
05:47:27 <mniip> good for now i gues
05:48:38 * hackage simple-text-format 0.1 - Simple text based format strings with named identifiers.  https://hackage.haskell.org/package/simple-text-format-0.1 (justus)
05:48:57 <quchen> It‚Äôs correct, but won‚Äôt perform well.
05:49:29 <quchen> Correct is good enough in the beginning I think. :-)
05:49:32 <mniip> yes
05:49:42 <WhereIsMySpoon> alrighty
05:49:47 <quchen> Reversing a singly-linked list, which lists are, has this pitfall.
05:50:18 <mniip> maybe after you learn the semantics of data, laziness, sharing, strictness, memoization, and have a good understanding of types, you can come back and we'll explain
05:50:31 <quchen> Haha that‚Äôs a mouthful ;-)
05:50:47 <WhereIsMySpoon> ive mostly worked with arraylists and not linked lists
05:50:49 <WhereIsMySpoon> im a java person :)
05:50:52 <quchen> But the issue is independent of most of these actually. Reversing a singly linked list in C this way has similar issues.
05:50:57 <WhereIsMySpoon> so im not very up on these pitfalls
05:51:07 <quchen> Java has this pitfall as well.
05:51:16 <quchen> It‚Äôs just that in Java singly linked lists are much less used.
05:51:20 <WhereIsMySpoon> plus performance of processing this stuff is not generally an issue when network latency gets in the way more often than not much more
05:51:44 <mniip> ooh java
05:51:46 <WhereIsMySpoon> quchen: thats what i meant :)
05:52:01 <mniip> there are many useful analogies
05:52:17 <WhereIsMySpoon> mniip: ive found coming back to haskell again after using java streams has highlighted a lot of things 
05:52:32 <WhereIsMySpoon> like how much the object inheritance stuff gets in the way of programming
05:52:38 <WhereIsMySpoon> and that i want currying
05:53:28 <mniip> a few months ago I've rediscovered java after years of denial
05:53:37 <mniip> the structuredness of OOP has been a relief to me...
05:55:10 <Cale> ah, it appears I was disconnected for a bit there
05:55:36 <Cale> WhereIsMySpoon: I thought I might explain how to make that implementation of reverse more efficient
05:56:04 <mniip> Cale, noooooo
05:56:14 <Cale> why not? :)
05:56:19 <mniip> we just discussed why not ;)
05:58:09 <Cale> Did you talk about how to make it linear?
05:58:12 <Cale> I missed some stuff
05:58:16 <mniip> no
05:58:18 <mniip> see logs
05:58:30 <quchen> Cale: Nothing relevant. Go ahead.
05:58:52 <Cale> WhereIsMySpoon: Okay, so xs ++ ys takes (necessarily) O(length xs) reduction steps to evaluate
05:58:56 <Cale> @src (++)
05:58:56 <lambdabot> []     ++ ys = ys
05:58:56 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:58:56 <lambdabot> -- OR
05:58:56 <lambdabot> xs ++ ys = foldr (:) ys xs
05:59:40 <Cale> You can see here that it will recursively pattern match on the left list until it reaches the end of that
06:01:24 <Cale> of course, if we repeatedly add one element to the end of a list with (++), that will result in quadratic time, as the number of reduction steps will look something like 1 + 2 + ... + n = (n (n+1))/2 where n is the length of the list.
06:01:57 <Cale> While there's no way to implement (++) any better for lists, there is a way to avoid it when we're building up a list like this
06:02:46 <Cale> WhereIsMySpoon: following this? :)
06:04:19 <Cale> anyway... the trick is that instead of constructing a list of type [a] as the result directly, we can construct a function of type [a] -> [a] which will add elements to the beginning of any list it's given
06:04:36 <WhereIsMySpoon> Cale: sorry, was chatting to coworkers
06:04:38 <WhereIsMySpoon> reading now
06:04:45 <Cale> [] will become id (the identity function, which adds no elements to the beginning of a given list)
06:05:00 <Cale> [x] will become (x:) (the function which adds x to the beginning of any list)
06:05:20 <Cale> and, most importantly, (++) will become (.) -- that is, function composition
06:05:57 <Cale> Since (f . g) x = f (g x) always reduces fully in a single step, it's constant time instead of linear, which will make the resulting reverse function linear time overall:
06:06:03 <Cale> reverse' [] = id
06:06:13 <Cale> reverse' (x:xs) = reverse' xs . (x:)
06:06:18 <WhereIsMySpoon> *system warning*
06:06:24 <WhereIsMySpoon> im sorry,  ive shut down
06:06:32 <halogenandtoast> I haven't, keep going
06:06:37 <WhereIsMySpoon> the way that a lot of haskell gets explained in these meta terms is just confusing to me
06:06:49 <WhereIsMySpoon> mostly because im not familiar with a lot of the words that are used
06:06:51 <Cale> WhereIsMySpoon: Feel free to ask questions about what I mean
06:06:55 <WhereIsMySpoon> i didnt mean that to shut you down cale :)
06:07:26 <Cale> So now, in order to recover our original reverse function, we can apply the resulting function to an empty list:
06:07:30 <Cale> reverse xs = reverse' xs []
06:08:12 <WhereIsMySpoon> whats with the ‚ÄîOR foldr
06:08:16 <WhereIsMySpoon> in the src of ++
06:08:24 <Cale> WhereIsMySpoon: That's just another possible implementation
06:08:26 <mniip> Cale, is the ShowS trick any better than 'go (x:xs) ys = go xs (x:ys)'
06:08:40 <Cale> mniip: It's totally equivalent to it.
06:08:54 <sullyj3> Why don't haskell lists just have end pointers for constant (++)?
06:08:59 <Cale> We could add a second parameter to reverse'
06:09:06 <mniip> sullyj3, data is immutable
06:09:06 <Cale> reverse' [] ys = id ys
06:09:22 <Cale> reverse' (x:xs) ys = (reverse' xs . (x:)) ys
06:09:32 <Cale> and then simplify the right hand sides:
06:09:33 <WhereIsMySpoon> adding one element to a list with ++ is O(n2)?
06:09:38 <Cale> reverse' [] ys = ys
06:09:39 * quchen likes to think of reverse as if I had a large stack of books to invert. Take the uppermost book, and put it on the other stack. Keep doing this until your original stack is empty. Your new stack is the initial stack, but reversed.
06:09:48 <Cale> reverse' (x:xs) ys = reverse' xs (x:ys)
06:09:54 <merijn> sullyj3: They're immutable so you can't append to an existing list anyway
06:09:56 <mniip> yeah
06:09:57 <sullyj3> WhereIsMySpoon: no, it's O(n) in the size of the first list
06:09:58 <Cale> WhereIsMySpoon: No, it's O(n)
06:10:05 <mniip> my/quchen's analogy is more useful than function composition
06:10:07 <WhereIsMySpoon> why did you say it was quadratic?
06:10:18 <Cale> WhereIsMySpoon: But if you do that n times, reverse is O(n^2)
06:10:38 <Cale> (the length of the list you do it to varies, but not enough to prevent it from being quadratic)
06:10:55 <WhereIsMySpoon> oh right
06:10:57 <WhereIsMySpoon> ok
06:11:12 <sullyj3> mniip, merijn yeah, but doesn't horrible impure black magic go on under the ghc hood?
06:11:23 <mniip> not that kind of
06:11:44 <WhereIsMySpoon> i dont follow the bit about the ids
06:11:44 <Cale> WhereIsMySpoon: So this trick I explained above replaces the linear time (++), with constant time (.)
06:11:46 <WhereIsMySpoon> and function composition
06:11:52 <Cale> ah, okay
06:12:04 <mniip> registerization of certain tight loops, maybe, might use registers as mutable variables for primitive types
06:12:10 <Cale> So, the idea is that instead of using lists, we're going to use functions which add elements to the start of lists
06:12:12 <mniip> but heap data is certainly not overwritten in this fashion
06:12:33 <Cale> id x = x
06:12:45 <Cale> Is a function which doesn't add any elements to the start of a list
06:12:58 <Cale> and so it's our analogue to the empty list here
06:13:19 <WhereIsMySpoon> right..
06:13:26 <Cale> (x:) is the function which adds x to the beginning of any list, and so it's our analogue for [x]
06:13:38 <sullyj3> mniip Ah. It's easy to conceptualize a black box as having magic powers
06:13:49 <quchen> Heap data is only overwritten when updating a thunk. It‚Äôs not black magic, just a very limited form of mutability.
06:14:06 <mniip> sullyj3, everything can be taken apart
06:14:19 <WhereIsMySpoon> Cale: ok
06:14:20 <mniip> ghc has an implementation that you can read an understand
06:14:32 <merijn> This sounds like a moment to bring up the STG paper :p
06:14:35 <ventonegro> Even Racket (a Scheme-ish language) is using immutable cons cells now
06:14:50 <Cale> and then if we have two functions say f and g which each add some elements to the beginning of a list, then f . g will be a function which adds all of those elements, i.e. it has the same effect as appending the lists of elements they would have added, and then adding those
06:15:20 <mniip> @where stg
06:15:21 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
06:15:26 <sullyj3> merijn: That looks interesting, ta
06:15:30 <WhereIsMySpoon> Cale: huh?
06:15:34 <WhereIsMySpoon> whats the .
06:15:37 <Cale> ah
06:15:42 <Cale> (f . g) x = f (g x)
06:15:50 <Cale> It's composition of functions
06:15:51 <mniip> Cale, I think you might be misjudging their skill
06:15:54 <ventonegro> > :t (.)
06:15:57 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
06:15:59 <Cale> :t (.)
06:16:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:16:13 <mniip> oh huh hey ventonegro
06:16:35 <WhereIsMySpoon> Cale: can i get a concrete example?
06:16:40 <Cale> sure...
06:16:44 <phadej> I understand the dlist trick as "tail recursion module cons"
06:16:45 <WhereIsMySpoon> sorry if im being slow
06:16:47 <sullyj3> Conceptually, composition feeds the output of g into the input of f
06:16:56 <Cale> > (reverse . map toUpper) "hello"
06:16:58 <lambdabot>  "OLLEH"
06:17:00 <ventonegro> mniip: Hello!
06:17:02 <phadej> e.g. you build a list (a : b : c :) but leave the "tail" hanging
06:17:09 <sullyj3> > (+1).(*4) 3
06:17:11 <lambdabot>  error:
06:17:12 <lambdabot>      ‚Ä¢ No instance for (Typeable a0)
06:17:12 <lambdabot>          arising from a use of ‚Äòshow_M686304298927314073511402‚Äô
06:17:15 <halogenandtoast> lol
06:17:17 <phadej> and et the end just say "here's the end: []"
06:17:19 <mniip> sullyj3, needs more ()
06:17:28 <halogenandtoast> or a $
06:17:32 <sullyj3> > (+1).(*4) $ 3
06:17:32 <Cale> > ((+1) . (*4)) 3
06:17:37 <lambdabot>  13
06:17:37 <lambdabot>  13
06:17:47 <WhereIsMySpoon> why do you need a . if haskell has currying?
06:18:02 <phadej> it's not the same
06:18:04 <Cale> Currying doesn't help us to compose functions
06:18:06 <halogenandtoast> because of how functions eval
06:18:12 <halogenandtoast> so for example
06:18:13 <mniip> how does currying help  you build a function
06:18:17 <halogenandtoast> > reverse map toUpper "hello"
06:18:20 <lambdabot>  error:
06:18:20 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò(Char -> Char) -> [Char] -> t‚Äô
06:18:20 <lambdabot>                    with actual type ‚Äò[a1]‚Äô
06:18:22 <sullyj3> WhereIsMySpoon: what do you mean? Try writing my function using currying.
06:18:45 <halogenandtoast> basically reverse takes a single argument, and so it read map as the argument
06:18:53 <LKoen> > reverse $ map toUpper "hello"
06:18:56 <lambdabot>  "OLLEH"
06:19:09 <halogenandtoast> so you can do what LKoen just said as a solution
06:19:11 <WhereIsMySpoon> what is this $
06:19:12 <LKoen> > reverse (map toUpper "hello")
06:19:15 <lambdabot>  "OLLEH"
06:19:15 <halogenandtoast> but it's still a little different
06:19:24 <WhereIsMySpoon> i dont think ive gotten to it yet
06:19:25 <mniip> WhereIsMySpoon, would I blow your mind with "$ is just id"
06:19:26 <halogenandtoast> WhereIsMySpoon: think of "$" as do everything to the right first
06:19:33 <Cale> WhereIsMySpoon: f $ x = f x, but $ has really low operator precedence, that is, it binds really weakly to its arguments
06:19:34 <LKoen> $ is basically syntactit sugar for "open a parenthese and don't close it until the end of the expression"
06:19:37 <WhereIsMySpoon> right
06:20:06 <merijn> LKoen: $ is just another operator, it's not syntactic sugar
06:20:10 <LKoen> okay
06:20:12 <mniip> merijn, I concur
06:20:16 <LKoen> it's equivalent to
06:20:19 <halogenandtoast> :t ($)
06:20:20 <mniip> runST $ do
06:20:21 <lambdabot> (a -> b) -> a -> b
06:20:33 <quchen> 6 people answering the same question and rising! ;-)
06:20:40 <sullyj3> merijn: Sure, but sugar is a good pretheoretic intuition
06:20:46 <halogenandtoast> quchen: HEY MAN I FINALLY KNOW SOMETHING
06:20:46 <WhereIsMySpoon> :D
06:20:51 <merijn> quchen: I'm just commenting on others, not actually getting involved :p
06:21:02 <merijn> quchen: I thought stgi was online somewhere or did I imagine that?
06:21:03 <WhereIsMySpoon> ive forgotten what we‚Äôre talking about
06:21:05 <ventonegro> #haskell is overwhelmingly helpful :D
06:21:13 <WhereIsMySpoon> i am a bit overwhelmed right now lol
06:21:15 <mniip> over-whelmingly
06:21:19 <Cale> halogenandtoast: Careful about that "first"
06:21:19 <sullyj3> That's because they're easy questions, and answering easy questions makes me feel smart
06:21:20 <halogenandtoast> Where is Cale? Come back Cale!
06:21:21 <quchen> merijn: Yes, at every search engine when you enter ¬ªquchen stgi¬´ for example.
06:21:44 <quchen> merijn: If you mean ¬ªas a webapp¬´, then no.
06:21:45 <Cale> halogenandtoast: It doesn't really have anything to do with the order of evaluation, only how the expression is parenthesized
06:21:46 <merijn> quchen: That gives me the github, I mean like as interactive webpage
06:21:57 <halogenandtoast> Cale: yes but I don't want to explain that.
06:21:57 <merijn> quchen: Ok, so just my imagination then :)
06:22:02 <quchen> merijn: Yes, sadly.
06:22:13 <WhereIsMySpoon> if (f.g)x = f(g x) why not write f(g x)
06:22:17 <WhereIsMySpoon> its like..not confusing
06:22:20 <quchen> merijn: That nonexisting website is the reason I rewrote the prettyprinter though, so at least something came from it.
06:22:23 <Cale> WhereIsMySpoon: Well, maybe we don't want to write x
06:22:35 <halogenandtoast> WhereIsMySpoon: because you can pass around functions for instance
06:22:37 <mniip> perhaps, we should move to #haskell-beginners
06:22:38 <sullyj3> WhereIsMySpoon: (.) lets you do things like f.g.h.i.j etc
06:22:40 <merijn> quchen: Join me in my quest of farming out yak shaving to beginners ;) Whenever someone says "what project should I work on?" we just tell them to do our work for us ;)
06:22:43 <Cale> WhereIsMySpoon: This is a functional programming language, we're meant to be treating functions as things unto themselves.
06:22:43 <halogenandtoast> without arguments.
06:22:52 <Cale> WhereIsMySpoon: (.) glues two functions together end to end
06:23:00 <WhereIsMySpoon> i thought let was for that
06:23:04 <sullyj3> which would be f(g(h(i(j x)))) otherwise
06:23:11 <WhereIsMySpoon> let combo = f g
06:23:13 <WhereIsMySpoon> combo x
06:23:27 <halogenandtoast> (b -> c) . (a -> b) returns a new function that is (a -> c) so to speak
06:23:30 <Cale> WhereIsMySpoon: that's not right. f g means f *applied to* g
06:23:40 <Cale> WhereIsMySpoon: i.e. g itself would be the argument to f
06:23:42 <mniip> damn, this is a mess
06:23:44 <Cale> Not g x
06:23:46 <merijn> I would cautiously recommend getting back to some more fundamental introductory literature, at this point
06:23:57 <mniip> WhereIsMySpoon, why don't we move over to #haskell-beginners for a more calm discussion
06:24:04 <WhereIsMySpoon> ok :P
06:24:07 <WhereIsMySpoon> sorry everyone 
06:24:20 <Cale> WhereIsMySpoon: You have no reason to apologise
06:24:24 <halogenandtoast> No problem, I'm going to hop in haskell-beginners as well, but not speak.
06:24:26 <sullyj3> WhereIsMySpoon: Check out learnyouahaskell.com, it's fantastic
06:24:30 <WhereIsMySpoon> im using it
06:24:37 <WhereIsMySpoon> i just sidetracked to the 99 exercises page
06:24:41 <ventonegro> WhereIsMySpoon: not your fault, 20 people answering at once is the problem here
06:24:42 <sullyj3> ah
06:24:49 <scav> i also think HaskellBook is nice
06:25:01 <WhereIsMySpoon> wanted to see how much i could do
06:25:43 <Cale> I generally recommend Graham Hutton's book and the CIS 194 course materials (especally Brent Yorgey's edition)
06:25:54 <Cale> http://www.cis.upenn.edu/~cis194/spring13/
06:26:17 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html
06:26:43 <halogenandtoast> Cale is that book Haskell98?
06:27:10 <Cale> halogenandtoast: Pretty much?
06:27:17 <mniip> halogenandtoast, it's a standard
06:27:28 <mniip> referential, not educational literature
06:27:40 <halogenandtoast> Just a question mostly. I've never used (afaik) Haskell98
06:27:45 <Tspoon_> WhereIsMySpoon: cool nick, btw!
06:27:55 <mniip> er
06:27:56 <WhereIsMySpoon> Tspoon_: :D hi, thanks
06:27:58 <Cale> halogenandtoast: There might be some use of extensions, I don't recall. Haskell 98 is essentially the same thing as Haskell 2010.
06:28:01 <halogenandtoast> So I wasn't sure if there are any fundamental differences.
06:28:04 <mniip> halogenandtoast, sorry I misunderstood
06:28:54 <halogenandtoast> mniip: I forgive you.
06:28:55 <Cale> halogenandtoast: (Haskell 2010 was really silly, the biggest thing they did was merge in a bunch of other standards which had already been published alongside H98)
06:29:22 <merijn> Cale: Well, they added PatternGuards and removed the silliness that is DatatypeContexts, so that's something!
06:29:29 <halogenandtoast> Wasn't there a big Applicative push at some point?
06:29:38 <merijn> halogenandtoast: That was really recently
06:29:42 <mniip> merijn, also NPlusK iirc?
06:29:49 <merijn> halogenandtoast: Applicative as superclass of Monad isn't even Haskell2010
06:29:55 * LKoen sets out to read "learn you a haskell", "real world haskell", "programming in haskell" and "cis 194: introduction to haskell"
06:29:55 <merijn> mniip: Those too
06:30:08 <merijn> LKoen: Better start with the latter two
06:30:37 <LKoen> thank you
06:30:39 <halogenandtoast> merijn: so... Haskell2013?
06:30:47 <mniip> I've learned haskell from lyah and lots and lots and lots of practice
06:31:06 <merijn> halogenandtoast: No, there's a new Haskell Prime committee to create a new report, but it's work in progress
06:31:27 <halogenandtoast> merijn: I was mostly kidding.
06:31:37 <ventonegro> +1 for practicing a lot
06:31:39 <halogenandtoast> These days I just look at GHC versions.
06:33:01 <halogenandtoast> I know it's not, but Haskell and GHC are synonymous for me at this point in my Haskell life.
06:33:04 <quchen> ¬ªreally recently¬´ was 2 years ago or so.
06:33:50 <halogenandtoast> quchen: Yeah I was actually around for it "kinda"
06:34:03 <halogenandtoast> I was just cutting my teeth and hating on Haskell
06:34:22 <quchen> ‚Ä¶ you‚Äôre writing Haskell out of hate?
06:34:42 <halogenandtoast> quchen: a few years ago when I was learning Haskell, I didn't get it
06:35:06 <halogenandtoast> A lot of people at work were harping about it, and I wanted to understand
06:35:17 <halogenandtoast> So I was working hard to learn it and getting angry at the usual things.
06:35:21 <Cale> I'm rather upset with all of the recent threads on the Haskell Prime list actually. We need to just get a bunch of relevant people into a room together at some point.
06:35:24 <halogenandtoast> Mostly random numbers.
06:35:38 * hackage zip 0.1.11 - Operations on zip archives  https://hackage.haskell.org/package/zip-0.1.11 (mrkkrp)
06:36:14 <Cale> Haskell 2020 is never going to happen if the best we can come up with are proposals for syntax changes which would only be appropriate if one had a time machine to send them back to 1989.
06:36:33 <merijn> Cale: Agreed
06:36:36 <halogenandtoast> Cale: I assume because of backwards compatibility
06:36:59 <Cale> halogenandtoast: Well, that and the fact that it has nothing to do with reporting on what exists, which really is what needs to happen.
06:37:02 <merijn> "Here is an absolutely minor peeve that will dramatically alter the way code gets parsed"
06:37:22 <halogenandtoast> I assume moving Semigroups to Base would be a good thing?
06:37:29 <merijn> Cale: to be fair, I think most of those aren't from committee members
06:37:37 <Cale> merijn: I know.
06:37:52 <Cale> merijn: It's just, there's no apparent movement otherwise.
06:38:10 <halogenandtoast> Maybe there's nothing wrong with Haskell at this point.
06:38:23 <quchen> If I could formulate a proper RankNTypes proposal I would.
06:38:27 <Cale> halogenandtoast: The Report doesn't tell us enough about all the stuff that GHC can do today.
06:38:52 <Cale> I don't even care about folding extensions into the main language at all.
06:39:01 <Cale> I just care about specifying what those extensions mean.
06:39:06 <mniip> if it did, haskell would be near impossible to implement
06:39:17 <halogenandtoast> Cale: I've thought about that as well, and I like having most of them as extensions
06:39:22 <mniip> if I'm not mistaking, report haskell stays within HM
06:40:00 <Cale> My dream would be if we picked some core type theory, specified a bunch of the extensions in terms of a reduction to that type theory, and then defined a denotational semantics for the core.
06:40:37 <Cale> We haven't *really* had a denotational semantics since Haskell 1.0, because nobody's ever bothered to update it
06:40:39 <merijn> Cale: I think it's just a matter of the people who are both qualified and interested being rather busy
06:40:43 <Cale> yeah
06:40:57 <merijn> Cale: I mean, I assume that's why you're not on it? :)
06:40:59 <halogenandtoast> I wish I was qualified :(
06:41:09 <merijn> halogenandtoast: Get qualified! ;)
06:41:09 <halogenandtoast> Type theory is difficult.
06:41:19 <merijn> halogenandtoast: Where have you tried to learn it from?
06:41:24 <halogenandtoast> The one book I tried to read scared me away.
06:41:34 <merijn> halogenandtoast: TaPL?
06:41:35 <Cale> merijn: Yeah, too much of my day is taken up with writing Haskell programs to really work all that much on it.
06:41:51 <halogenandtoast> Category Theory by Steve Awodey
06:42:02 <merijn> halogenandtoast: That's category theory, not type theory
06:42:04 <Cale> That's not even a book on type theory
06:42:07 <halogenandtoast> well shit
06:42:09 <merijn> halogenandtoast: Also, that book is murder for your brain
06:42:16 <halogenandtoast> merijn: It was!
06:42:19 <halogenandtoast> See what it did to me!
06:42:21 <merijn> halogenandtoast: Get a copy of Types and Programming Languages by Pierce
06:42:27 <halogenandtoast> I confused category and type theory
06:42:37 <merijn> halogenandtoast: It is, like, orders of magnitude simpler than Awodey
06:42:43 <merijn> halogenandtoast: And comes with runnable example code!
06:42:50 <Cale> I dunno, it's a pretty gentle intro to category theory as far as those go. But yeah, it might not be easy if you have not much of a mathematical background.
06:42:59 <ski> @where TaPL
06:42:59 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:43:05 <merijn> Cale: Yes, but that's only because all CT intros are murder
06:43:05 <Cale> (and you don't have someone sitting nearby to help)
06:43:25 <halogenandtoast> merijn: I'll check it out
06:44:03 <halogenandtoast> I've actually been wanting to write a simple statically typed programming language
06:44:09 <halogenandtoast> so maybe this will give me a leg up.
06:44:11 <mniip> hmm
06:44:15 <mniip> while we are on this topic
06:44:22 <merijn> halogenandtoast: It should be far more accessible for you. It starts with untyped lambda calculus and builds all sorts of type systems on top of that. There's example interpreters/type checkers included (in OCaml, but basic enough you should be able to grok it with only Haskell experience)
06:44:23 <mniip> can someone explain
06:44:25 <Cale> I think it could be fine for a bunch of beginners as a textbook, but 1) you need to read it much slower than the average book (but not slower than the average mathematics text), and 2) it's going to be really hard to self-teach if you don't already have a strong mathematics background
06:44:43 <mniip> what fills the gap between Hindley-Milner and OutsideIn
06:44:45 <merijn> halogenandtoast: You should be able to write a simple statically typed language without getting further than like halfway through TaPL
06:45:08 <halogenandtoast> merijn: great I'll actually read this
06:45:14 <merijn> halogenandtoast: 2/3rds should cover most of Hindley-Milner/extension free Haskell
06:45:16 <Cale> mniip: Perhaps stuff like System F_omega?
06:45:22 <halogenandtoast> then return as a qualified person.
06:45:30 <ski> merijn : "Conceptual Mathematics: A First Introduction to Categories" by Steve Schanuel and William Lawvere isn't that bad, i think
06:45:49 <merijn> halogenandtoast: (I say this as someone whose read most of TaPL and struggled to get past, like, chapter 2 of Awodey :p)
06:46:29 <sullyj3> @pl flip $
06:46:30 <lambdabot> (line 1, column 7):
06:46:30 <lambdabot> unexpected end of input
06:46:30 <lambdabot> expecting white space or simple term
06:46:30 <merijn> ski: My problem is that most of the CT stuff is written with a math background assumed. So all the focus/explanation doesn't relate to the stuff I wanna know
06:46:34 <halogenandtoast> merijn: I skipped out in chapter 1, I was spending too long remembering how to read math equations.
06:46:35 <sullyj3> @pl flip ($)
06:46:35 <lambdabot> flip id
06:46:49 <halogenandtoast> flip id is one of my favorite types
06:46:53 <halogenandtoast> :t flip id
06:46:54 <lambdabot> b -> (b -> c) -> c
06:47:01 <Robin> anyone at KA????????
06:47:04 <merijn> ski: Where "what I wanna know" is basically "the PL papers are starting to refer to CT, but I don't understand enough to get what they mean"
06:47:05 <halogenandtoast> by type I mean type signatures.
06:47:05 <wz1000> What is the outlook for first class ghc support for row types>
06:47:10 <ski> merijn : aye. there's not that many books written from a CS perspective. there's a few, though
06:47:16 <merijn> wz1000: Don't hold your breath ;)
06:47:20 <wz1000> Because that is what I really, really want
06:47:25 <merijn> wz1000: Same here
06:47:44 <merijn> wz1000: Be the change you want to see in the world! Hack GHC!
06:47:44 <Xion_> halogenandtoast: Wait what? Why isn't it just a -> a like id itself? o.0
06:47:44 <Cale> merijn: Yeah, also learning CT is probably somewhat of a waste of time if you have no intention of doing more than one field of mathematics -- you can just as well have someone stomp on the definitions from CT and apply them to your area, and from there just understand them not-abstractly
06:47:46 <halogenandtoast> Oh that's one thing I wanted in Haskell. Not to have name clashes on records.
06:47:58 <halogenandtoast> Xion_: ah ha
06:47:59 <sullyj3> halogenandtoast: I'm basically looking for an infix for programming in a concatenative, "data flows right" style
06:48:02 <halogenandtoast> :t flip
06:48:04 <lambdabot> (a -> b -> c) -> b -> a -> c
06:48:06 <halogenandtoast> :t id
06:48:08 <lambdabot> a -> a
06:48:19 <halogenandtoast> you have to specialize id
06:48:20 <Xion_> oooh, right
06:48:20 <wz1000> Vinyl and TH just aren't satisfying to use
06:48:27 <halogenandtoast> (a -> b) -> (a -> b) is still id
06:48:32 <Cale> merijn: But it is fairly beautiful on its own, so one of those fields of mathematics might be category theory itself.
06:48:40 <halogenandtoast> then plug in the holes
06:49:03 <merijn> Cale: My problem is, I try to read the stuff edwardk and co write and I don't get half the explanations/references without that background
06:49:41 <lpaste> av pasted ‚ÄúBinary‚Äù at http://lpaste.net/355811
06:49:43 <edwardk> category theory is for me a good way to steal results by analogy from all sorts of places
06:49:45 <av> Hi guys, I need some help, this is the problem: http://lpaste.net/355811
06:49:50 <Cale> merijn: ah, yeah
06:50:25 <edwardk> there are a ton of combinators we'd never have figured out in lens without that sort of formal basis as well
06:50:29 <merijn> Cale: Or Conal, etc. and there's no sorta "here's what you need to know" primer for that stuff
06:50:30 <av> Loading it into ghci works fine on all but one computer of mine.  Each have the same GHC, all packages locally installed with cabal, and only one of them gives me this error:
06:50:30 <ski> halogenandtoast : have you tried looking at "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> ? .. it doesn't explain in as much detail as a book, but more than the typical type system paper. might be useful to glance at
06:51:04 <lpaste> av pasted ‚ÄúBinary‚Äù at http://lpaste.net/355812
06:51:09 <edwardk> merijn: the trick is 'what you need to know' is constantly expanding as we learn how to apply more category theory
06:51:10 <wz1000> edwardk: That sounds fascinating. Have you written about it somewhere?
06:51:13 <av> What's going on here?
06:51:15 <halogenandtoast> ski: would you recommend reading it before or after TaPl
06:51:27 <merijn> edwardk: Sure, but right now I don't even understand the basics
06:51:32 <Xion_> :t flip id 42 id
06:51:33 <lambdabot> Num c => c
06:51:41 <Xion_> Silliness.
06:51:53 <halogenandtoast> av: I'm a beginner but I don't think that's a instance declaration
06:51:54 <merijn> halogenandtoast: TaPL can be read with little to no background, IMO (well, basic lambda calculus and FP knowledge helps)
06:52:06 <halogenandtoast> merijn: check
06:52:13 <edwardk> i spent a good chunk of compose talking to folks about simplicial sets and operations of that sort for instance, to reason about environment manipulation, leader election in distributed processes, etc.
06:52:13 <merijn> halogenandtoast: Since it's written to be (at least partially) suitable for undergrad students
06:52:45 <edwardk> that was barely on my radar a few years back
06:52:52 <Cale> merijn: I was going to take Ali Abrar (my coworker) through Awodey's book and see how far we get, but we haven't really scheduled things yet. Perhaps we should include some additional people :)
06:53:13 <ski> halogenandtoast : you could take a glance at the start of it right now, and see what you think. probably some of the latter sections will be mostly over your head, without some experience with what they're talking about. but i can say that i found this paper helpful, when i started reading about type systems
06:53:13 <ventonegro> I ordered TaPL for the library office but I'm going through the Idris book at the moment, wondering when I will get out at the other side...
06:53:25 <ventonegro> office library*
06:54:01 <edwardk> merijn: starting from nothing,, you might want to look at something like the lawvere and schanuel book "conceptual mathematics"
06:54:17 <edwardk> that book doesn't go very far, but it does drill the crap out of the topics it covers
06:54:27 <av> A hint: if I omit the "V3" constructor, i.e. don't mix binary with linear, the code works fine in all cases.  GHC is 8.0.1 on all machines, fyi.
06:54:28 <ski> halogenandtoast : you don't need to understand everything to have gain from it. you can skip parts, and perhaps later come back to it, or perhaps try to hunt down some paper in the references, in the hope that it'll go more into details of basics (that's a general strategy i use when reading papers)
06:55:03 <edwardk> where most category theory books just assume you are going to read at an incredibly slow methodical pace and that every nuance of every word matters
06:55:25 <halogenandtoast> edwardk: Any suggestions for a beginner outside of school to get their feet wet.
06:55:32 <halogenandtoast> Particularly ones with practical examples.
06:55:42 <ski> halogenandtoast : if you have some experience with how polymorphism (subtyping) works in an OO setting, and some with what the same term "polymorphism" means in e.g. Haskell, then possibly parts of "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> could also be helpful
06:55:53 <wz1000> I've been holding off reading too much CT until I know enough algebra
06:55:55 <halogenandtoast> ski: I do
06:56:02 <mniip> edwardk, any idea what I should read to have a better understanding of type theory papers
06:56:14 <merijn> edwardk: Well, for the forseeable future I don't have much time anyway, so I guess I'll just have to be confused for now :)
06:56:21 <edwardk> halogenandtoast: https://www.quora.com/What-is-the-best-textbook-for-Category-theory?share=1 <- gives my usual recommendations for category theory text books.
06:56:23 <merijn> mniip: Depends, what's your current knowledge level?
06:56:37 <halogenandtoast> edwardk: Thanks, I'll look into them.
06:56:44 <edwardk> bartosz milewski has a pretty accessible set of lectures on the topic, giving you an intro to category theory with a strong haskell accent
06:56:50 <edwardk> (and a slight polish one)
06:57:02 <halogenandtoast> edwardk: I've started watching some of his stuff.
06:57:06 <ski> mniip,halogenandtoast : also reading Philip Wadler papers helped me. they're often quite accessible
06:57:37 <Cale> wz1000: Yeah, it can help to see the same patterns a few times in different areas of mathematics (especially algebraic ones), before jumping into category theory. But from another perspective, category theory can be treated in a way where it's not more or less abstract than, say, group theory.
06:57:42 <edwardk> ski++ # wadler's papers on things like monads really helped cement them in my brain when i was new to haskell
06:58:17 <edwardk> av: what is going wrong with the binary instance?
06:58:43 <mniip> merijn, how do I evaluate it
06:59:10 <halogenandtoast> av: Your code compiles for me btw.
06:59:15 <merijn> mniip: Well, is it basically "I grok most haskell extensions, but have no solid foundation"?
06:59:16 <ski> halogenandtoast : i remember it also helped a lot when someone on <news:comp.lang.functional> explained that the "division line" in type system notation means "if all of the things above the inference stroke/line hold, then then thing below also holds" ;)
06:59:19 <halogenandtoast> or the small example you provided.
06:59:42 <av> av: no idea, take a look at the second paste of mine for the errors, it's on a fresh install, with the packages I need manually installed using cabal.  Again, it works on two machines, but fails on the third.
06:59:46 <halogenandtoast> ski: I'll copy that line for reference later on.
06:59:51 <wz1000> Cale: I tried learning algebra a few years ago, but didn't get very far. But then I learnt enough linear algebra to make sense of the examples
07:00:14 <mniip> merijn, I've tried reading papers, and I can understand some stuff
07:00:17 <mniip> but yes, no solid foundation
07:00:34 <ski> halogenandtoast : the first paper i mentioned is good in the way that it goes more into why we use type environments, and what they're good for, in addition to how to read typing rules
07:00:59 <merijn> mniip: Right, then I'd say TaPL for you as well :)
07:01:22 <av> edwardk: no idea, take a look at the second paste of mine for the errors, it's on a fresh install, with the packages I need manually installed using cabal.  Again, it works on two machines, but fails on the third.
07:01:38 <ski> (and probably also in some other ways i've forgotten atm)
07:01:56 <merijn> mniip: That's everything from untyped up to "how to typecheck Java style subtyping", System F, higher rank, etc.
07:02:10 <edwardk> if you use ghc-pkg list   can you see if the versions of binary or linear differ between machines?
07:02:43 <mniip> merijn, I meant more of...
07:02:47 <mniip> what's with the Gamma thing
07:03:09 <edwardk> av: can you link the errors again? i can't find it in the scrollback noise
07:03:44 <av> edwardk: http://lpaste.net/355811 and http://lpaste.net/355812
07:04:27 <merijn> mniip: Common meta variable for "environment"
07:04:35 <av> edwardk: there's a difference indeed, on the old machine it's linear-1.20.5 and binary-0.8.4.1, the new one has linear-1.20.6 and binary-0.8.5.1
07:04:59 <edwardk> which one broke?
07:05:03 <mnoonan> that's another place where TaPL is great.. scan forward until the first appearance of a symbol :)
07:05:10 <ski> mniip : ‚åúŒì‚åù is the conventional variable name for a type environment
07:05:20 <mniip> what is a "type environment"
07:05:37 <av> edwardk: the newer one: linear-1.20.6 and binary-0.8.5.1
07:05:40 <mniip> is it like a set of statements?
07:05:42 <merijn> mniip: Bindings in scope
07:07:16 <ski> mniip : ‚åúŒì ‚ä¢ e : œÑ‚åù means : Given the association of free variables to types in ‚åúŒì‚åù (which then says which variables are in scope), the expression ‚åúe‚åù has type ‚åúœÑ‚åù
07:07:19 <av> edwardk: Just downgraded to binary-0.8.4.1, same thing happens (error still there)
07:07:58 <mniip> ski, is it an atomic expression
07:08:19 <mniip> or can it be torn apart into ‚ä¢ and :
07:08:35 <ski> mniip : ‚åúŒì ‚ä¢ e : œÑ‚åù is a three-place (meta-language) relation, with parameters ‚åúŒì‚åù,‚åúe‚åù,‚åúœÑ‚åù
07:09:30 <ski> mniip : ‚åúŒì‚åù is a set (or sometimes list) of variable typings, like ‚åúx : Integer,y : Bool,z : Integer -> Bool‚åù
07:10:21 <ski> mniip : so ‚åúŒì ‚ä¢ e : œÑ‚åù can also be thought of as claiming that the expression typing ‚åúe : œÑ‚åù follows from assuming all the individual variable typings in ‚åúŒì‚åù
07:10:32 <av> edwardk: downgrading binary further to 0.8.3.0 appears to fix it!
07:12:03 <edwardk> av: that is discouraging
07:12:08 * hackage hnormalise 0.3.0.0 - Log message normalisation tool producing structured JSON messages  https://hackage.haskell.org/package/hnormalise-0.3.0.0 (AndyGeorges)
07:12:49 <ski> mniip : e.g. ‚åúx : Integer,z : Bool ‚ä¢ (z,\y. x + y) : Bool √ó (Integer ‚Üí Integer)‚åù is an example typing judgement (using the common ‚åú‚ãØ √ó ‚ãØ‚åù notation for product types (cf. cartesian product of sets), rather than the Haskell pair (tuple) type notation `(...,...)')
07:13:46 <av> edwardk: now the question is there binary is broken or I failed to stay up to date with API changes...
07:13:56 <mniip> I see
07:13:59 <av> s/there/whether/
07:14:11 <sullyj3> If you could add 5 unicode symbols to the keyboard in order to make programming with them practical, what would they be? 
07:14:14 <edwardk> good question
07:14:21 <ski> mniip : so the answer to "is it an atomic expression or can it be torn apart into ‚ä¢ and :" is .. both, whichever you please. formally/syntactically, it's usually treated as a three-place-relation, though
07:14:33 <edwardk> if you throw an issue on the linear issue tracker on github we can make sure to follow up
07:14:51 <edwardk> it seems likely to be a binary issue though
07:15:22 <av> edwardk: OK, will do when I find some time, for now it seems to work if I just downgrade binary
07:15:33 <ski> mniip : anyway, if you want to, you could take a look as well at the two papers i mentioned above for halogenandtoast ..
07:16:27 <av> edwardk: thanks for your great work, btw, but I just have to mention the hell of a time I had installing ad a few months ago: I have to go through tor on one machine to install things, and the privoxy I use to access tor blocked ad because it was -- well -- named "ad"!
07:16:29 <ventonegro> sullyj3: lambda for lambda expressions, \z -> ... sucks
07:16:30 <mniip> ski, what's up with the (X) in HM, OutsideIn
07:16:39 <sullyj3> ‚àò, Œª, ‚Üí, ‚àÖ, ‚Ü¶
07:17:16 <ertes-w> edwardk: while you're here‚Ä¶  would you be open to adding some utility functions to kan-extensions for Codensity for stuff like exception handling?  if yes, i'll send a PR instead of creating a separate package
07:17:57 <ventonegro> `Œªx -> x + x`
07:18:04 <wz1000> http://lpaste.net/355813
07:18:08 <mniip> sullyj3, the only symbol I can think of is ‚àÄ
07:18:11 <wz1000> Why does x typecheck but not y
07:18:36 <mniip> for the symbols you posted, I'm ok with their ascii renditions
07:19:27 <mniip> wz1000, welcome to RankNTypes
07:19:29 <ski> mniip : logically, the symbol ‚åú‚ä¢‚åù as in e.g. ‚åúA,B ‚ä¢ C‚åù means "from ‚åúA‚åù and ‚åúB‚åù, ‚åúC‚åù follows". it goes back to Gottlob Frege's "Begriffsschrift" (a two-dimensional notation for logical formulae. also had higher-order functions and macros) in the late 1800s
07:19:54 <mniip> wz1000, $ is special like that because for typechecking it is equal to ' '. In general RankNTypes inference is undecidable
07:20:49 <ski> mniip : iirc, that's a variable part of the type system where you can "plug in" any constraint system `X' (such as type class constraints, "record lacks" constraints, equality constraints, subtyping constraints, &c.) into the surrounding framework of the type system being presented
07:20:52 <sullyj3> ventonegro: `Œªx ‚Ü¶ x + x` :)
07:21:14 * ski approves of sullyj3's version
07:21:16 <av> edwardk: thanks again, have to leave now, see you later
07:22:29 <portnov> hi all
07:23:27 <mniip> ski, and a constraint system is?
07:23:53 <portnov> qnikst: https://github.com/portnov/libssh2-hs/issues/30 
07:24:44 <ventonegro> sullyj3: I would gladly remap some of the f-keys for that
07:24:56 <ski> mniip : do you know any Prolog (or other logic programming system) ?
07:25:03 <mniip> yes
07:25:28 <mniip> I haven't touched it in years but I have residual memory of the programming paradigm
07:26:34 <sullyj3> ventonegro: ooh, good idea
07:26:37 <ski> basic Prolog only have equality constraints (on terms/trees). the most exciting part of it is that you can alias two variables with each other, before binding/instantiating/initializing them. then, as soon as you give one of them a value, the other will automatically be given the same value as well
07:27:35 <c_wraith> spooky assignment at a distance
07:27:55 <ski> several Prolog systems add some kind of disequality constraints on top of that. so that you can claim that two variables are not equal before either having a value. if you later try to give both the same value, the constraint system will detect the inconsistency (this can be useful for modularity purposes, e.g.)
07:28:59 <ski> c_wraith : yes, aliased logic variables feel a bit like working with pointers .. only that (partly due to that you can't reassign to a logic variable) you can reason logically/declaratively more easily about code which uses them
07:29:20 <mniip> I have a good grasp on logic variables as they appear in prolog
07:29:25 <mniip> and maybe as they appear in haskell
07:29:53 <mniip> not that the two are the same
07:30:09 <ski> type variables in Haskell types behave like logic variables in logic programming
07:30:27 <mniip> ski, alright so
07:30:45 <ski> (there's some differences in parts of the systems, but the basics of that is the same)
07:31:43 <ski> mniip : anyway, there's the paradigm of constraint programming, which probably is most nicely expressed in its combination with logic programming as CLP, constraint logic programming
07:32:42 <mniip> can this be formalized?
07:33:04 <mniip> I feel like it has to be formalized before we can talk about how HM is parametric in it
07:33:18 <mniip> parameterized by it?
07:33:29 <ski> mniip : there's constraint systems like CLP(R), which allows you to express equations, inequations, and disequations between real number expressions. think of "linear programming"
07:33:42 <ski> and CLP(Q), which is similar, but for rational numbers
07:34:04 <mniip> ooooh
07:34:07 <ski> CLP(FD) is for reasoning about constraints for finite domains, which tends to mean integers in practice
07:34:15 <mniip> this starts to connect with my "theory of formal systems" course
07:34:16 <mniip> I think
07:34:34 <ski> there's CLP(BN), for Bayesian Network reasoning with probabilities
07:34:56 <mniip> ski, are you talking about a system of judgements with "real number atoms"?
07:35:03 <ski> so, there's all these different constraint solvers, for particular constraint problem domains
07:35:13 <dmiles> CLP(Set) allows for partially instantiated sets  
07:36:03 <ski> the point is that one is able to (programmatically) "post/tell" constraints between variables (which *haven't* been associated before with values, or computations which'll hopefully produce such), and the constraint solver is then expected to :
07:36:46 <ski> (a) determine whether the posted constraints, taken together, are inconsistent, without a model (iow an assignment of values to the variables which makes all the constraints hold true) or not
07:37:33 <mniip> I'm lost
07:37:47 <ski> (b) simplify the posted constraints to "solved form", possibly removing (*satisfiable*, iow not inconsistent) constraints which only involve intermediate/internal variables (as opposed to "end variables", which one is really interested in)
07:38:19 <ski> e.g. if we post `x > x + 1', our solver should alert us that this is impossible
07:38:29 <APic> Aaaah.
07:38:54 <bodisiw> MiniZinc is my favorite new language for this stuff
07:39:51 <mniip> ski, how did we get from prolog to this
07:39:58 <shapr> lambdaProlog?
07:40:19 <ski> mniip : one example of using constraints would be to automatically lay out graphical components on a screen without overlapping. or generate a schedule from given activities with a specified dependency relation and perhaps restrictions on which resources are needed for each, and which resources are available
07:40:44 <ski> mniip : several constraint solvers are integrated with Prolog systems
07:40:57 <dmiles> most prologs contain CLP libraries
07:41:04 <mniip> no like
07:41:26 <mniip> we were talking about Prolog, you said that its handling of variables is an example of a constraint system
07:42:16 <ski> mniip : anyway, in general, one can speak of `CLP(X)' as a generic model of constraint (logic) programming, where the particular constraint domain `X' can be filled in with a particular theory about how to simplify constraints, and detect inconsistency. such as a theory for how to solve linear equations and inequations in real numbers
07:42:30 <dmiles> in order to implement the constraint systems of prolog there are some rudemntary constraint parts that are genralized to control even just varaible assignments
07:42:57 * dmiles saying the same things as ski
07:43:05 <ski> mniip : yes, handling equality (implemented by unification, logic variables) in Prolog is a constraint system, granted a quite simple one
07:43:48 <mniip> so how is it formalized
07:44:10 <ski> mniip : .. if you compare with `HM(X)', then this is a specification of a general Hindley-Milner style type system, with a "pluggable component" `X', which a user of this system could specify to the type class constraints e.g.
07:45:08 <mniip> what *is* and X, and how does 'HM' use it
07:45:14 <mniip> s/and/an/
07:46:26 <ski> mniip : there's a survey paper about constraint programming by Jaffar and Maher which goes into more formal details
07:47:01 <ski> "Constraint Logic Programming: A Survey" by Joxan Jaffar,Michael J. Maher in 1994 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.8566>
07:47:12 <ski> dmiles : hi there, btw :)
07:47:51 <ski> mniip : `X' there is just a variable-name, a stand-in for some unspecified particular constraint problem domain
07:47:58 <mniip> huh is that pdf backwards
07:48:31 <ski> er, it appears to be
07:48:40 * ski always looked at the PS version
07:49:17 <mniip> ski, yes, but what is the Type of the variable
07:49:38 <mniip> your example of an X was unsatisfactory because you haven't defined exactly what the bounds of the X are
07:50:28 <ski> ok. yes, obviously the constraint system has to be presented (if possible) so as to fit a particular interface
07:50:53 <ski> i don't recall the details of how they did that for HM(X)
07:51:31 <mnoonan> ski, it's in the TaPL followup Advanced Topics in Types and Programming Languages
07:51:48 <mnoonan> I'm pretty sure that chapter is also available as a stand-alone paper
07:51:52 <ski> (<https://courses.engr.illinois.edu/cs522/sp2016/ConstraintLogicProgrammingASurvey.pdf> looks to not be backwards, though, at least here, the font looks less readable. perhaps better if printed, dunno)
07:53:45 <ski> bodisiw : i still have to look at MiniZinc
07:53:52 <dmiles> I was looking at the Haskell APT the other month and they were tryinhg to formallize prolog like varaibles and poissibly what they can be bound to.. theyt had to create tehis type of Any
07:54:08 <dmiles> APT/ATP
07:55:55 <mniip> ski, that's what I'm trying to understand
07:56:13 <ski> dmiles : Seres and Spivey has this paper about implementing logic variables in Haskell. and Koen Claessen did a follow-up on that, improving efficiency and making the logic variables typed, by using "state threads and reference cells" (`ST' and `STRef')
07:56:16 <dmiles> so i was going to say just that intial formalizaion was showing some examples i was thinking made things already hard from the getgo
07:56:26 <ski> mniip : ok
07:57:59 <dmiles> ski: that  (?) / (?)Ref is a good idea
07:59:13 <mniip> alright, I should probably finish TaPL
07:59:59 <bodisiw> ski, i like minizinc... it seems like a good abstraction over many solving backends, which i'm sure will continue improve a lot in the near future
08:00:11 <ski> dmiles : "Lazy Functional State Threads" by John Launchbury,Simon L. Peyton Jones in 1993 at <http://homepages.dcc.ufmg.br/~camarao/fp/articles/lazy-state.pdf> explains `ST',`STRef',`STArray'. Mercury also has something similar, probably borrowed
08:00:37 <bodisiw> ski, i'd also like to figure out a bit more about http://newartisans.com/2017/04/haskell-and-z3/ but too noob when it comes to haskell still
08:01:09 <ski> bodisiw : you're not in ##prolog (or #mercury) ?
08:02:13 <ski> bodisiw : looks like an interesting post
08:02:26 <bodisiw> nope, unfortunately i have to limit myself... so i can get 'actual' work done in whatever small amounts
08:02:37 * ski nods
08:03:28 <dmiles> out of the 80 channels i am on i think i have a small handfull ski is not in
08:03:56 <Axman6> oh I thought the name was familiar, I forgot MiniZinc as another Data61 project, it used to be all over the screens in the foyer at work
08:04:03 <Axman6> was*
08:05:14 <Axman6> bodisiw: I wrote a sudoku solver in Haskell using the Z3 bindings the other week, it ws much easier than writing a solver in Haskell from scratch
08:05:34 <bodisiw> nice!
08:05:37 <clamchowder> Hello
08:05:52 <zv> I wrote a SAT solver from scratch and it wasn't bad at all, Writing a SMT solver is a whole other can of worms
08:05:53 <bodisiw> using z3cat Axman6?
08:06:06 <Axman6> not sure what that is
08:06:15 <zv> Defining the Tsietin transformations is like, a can of *wyrms*
08:06:20 <bodisiw> oh, that specific package
08:06:32 <zv> Axman6: I assume he means concatenating bitvectors in QF_BV in the z3 solver
08:06:39 <Axman6> https://hackage.haskell.org/package/z3-4.1.0/docs/Z3-Monad.html
08:06:45 <bodisiw> ahh gotcha
08:07:16 <Zemyla> zv: I thought by SMT solver you meant Shin Megami Tensei. :V
08:08:07 <Axman6> I ended up representing it using 4-bit vectors for each square - tried to do something funky with 9-bit vectors and one-hot-coding, but it was a lot slower than the obvious solution
08:09:11 * Axman6 wonders if there's a non circuit design name for one-hot-coding
08:10:53 <ski> "one-hot-coding" being what demux/mux does ?
08:11:03 <ski> (or uses, rather)
08:11:06 <Axman6> possibly AKA "powers of two" :\
08:11:30 <Axman6> it's just a vector where exactly one bit is true
08:11:39 * hackage titan 0.1.0.0 - Testing Infrastructure for Temporal AbstractioNs  https://hackage.haskell.org/package/titan-0.1.0.0 (keera_studios_ci)
08:11:47 <qnikst> portnov: oh will take a closer look (I didn't receive notification for some reason)
08:11:51 <Axman6> apparently quite common in representing state machines
08:12:03 <ski> ok. which is the input of demux, and output of mux :)
08:12:19 <qnikst> portnov: I'd be happy to get rid of c2hs there, but I don't remember how much it will cost there :]
08:12:28 <Axman6> I guess so... my muxes always multiplexed more than one bit :P
08:14:47 <portnov> qnikst: as far as i see, this problem is not caused by c2hs, but by changes of libssh2 api itself. Last time when I looked into this library, i used libssh2, it was 1.2.8, now it is 1.8.0. And now documentation says we should use standard poll(2) instead of libssh2's poll* functions.
08:31:23 <athan> Given that I have some arbitrary `xs :: [(a,b)]`, how can I use that to construct a function `a -> b` which is total over `fst <$> xs`? And does this already exist in quickcheck?
08:31:45 <athan> oh wait, this is just a `fromJust . lookup` sorry :x
08:33:09 * hackage yaml 0.8.23 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.23 (MichaelSnoyman)
08:39:42 <marinelli> hi everyone
08:40:01 <shapr> hi marinelli 
08:40:04 <shapr> How's code?
08:41:22 * APic laughs magically.
08:44:36 <shapr> APic: magic code?
08:44:41 <APic> Probably.
08:44:53 <shapr> I'm enjoying doing simple stuff with Spock
08:45:05 <APic> k
08:45:21 <shapr> APic: what are you writing?
08:45:31 <APic> No Idea.
08:54:49 <Unode> hi all, if I have two stack projects living in different locla directories, 
08:55:12 <Unode> *local directories, is there any standard way to include modules from one in the other?
08:56:13 <Unode> I'm familiar with the --package syntax for external dependencies but haven't found an example of how to use this to reference local projects not available upstream
08:56:41 <dmj`> Unode: you could add the hs-source-dirs of one into the other. Has nothing to do w/ stack really. Can one pkg just depend on the other?
08:57:04 * ski suspects APic of implementing magic sets
08:57:10 <APic> Not my Dept.
08:57:33 <sm> Unode: add local dir to package list in stack.yaml
08:57:44 <Unode> dmj`: at this point is just for development purposes. This will all be under the same project at some point but to avoid rebuilding the entire project I'm keeping it independent.
08:57:49 <sm> this is it's hard to miss in the docs
09:06:27 <qnikst> portnov: lets do that
09:08:10 <portnov> qnikst: I did nearly that: https://github.com/portnov/libssh2-hs/commit/4204798b4f0cbfd7fbc596723c8584daa9eb31bb
09:08:10 <portnov> it works for me on debian and ghc8. at least does not crash and does not hang on large files. maybe you have comments on these changes in code?
09:08:40 <LAZAR> I wrote a Knapsack problem solver, anyone has an idea why it is slow for inputs > 1.000.000? The function is fillKnapsack, I just wonder if it could not be faster: https://github.com/AdHominem/CIS194/blob/master/Knapsack.hs 
09:09:39 * hackage criterion 1.2.0.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.2.0.0 (ryanglscott)
09:13:13 <ph88> LAZAR, run prof
09:13:31 <ph88> https://github.com/jaspervdj/profiteur
09:13:44 <LAZAR> You can also try the app using docker by pulling from adhominem/knapsack
09:14:24 <portnov> heh
09:14:46 <portnov> sorry if... but just...
09:14:53 <LAZAR> ph88 what is profiteur?
09:15:06 <ph88> viwer for profile files
09:15:29 <ph88> stack build --profile --fast --ghc-options="-j -auto-all +RTS -A128m -n2m -RTS"
09:15:37 <ph88> stack exec -- myProgram --help +RTS -p
09:15:41 <ph88> use this to make profile files
09:16:51 <portnov> >> I wrote a Knapsack problem solver
09:16:51 <portnov> me: WUT o_O
09:16:51 <portnov> >> anyone has an idea why it is slow for inputs > 1.000.000?
09:16:51 <portnov> me: ah, everything is ok, world did not turn upside down yet...
09:17:16 <portnov> :)
09:18:43 <LAZAR> ghc --make -auto-all -prof your-program.hs gives me some errors on compilation
09:20:46 <Cale> LAZAR: Note that xs !! n takes O(n) time
09:21:19 <Cale> That might or might not be something to worry about
09:21:54 <LAZAR> Cale: You think the most effort is the generation of items?
09:22:05 <Cale> Also, the pseudorandom generator in System.Random is notoriously slow
09:22:38 <LAZAR> Cale: I just see its not... both attributes and names are pretty short arrays and generateItems does not scale with input
09:25:25 <LAZAR> Cale: I just see I print the first 100 items and also access length items, will that be lazy evaluated?
09:27:54 <Cale> LAZAR: length has to traverse the entire list
09:37:20 <orion> I don'
09:37:36 <orion> I don't hear much about reflection. Is it me, or is it generally not that popular?
09:39:14 <wz1000> orion: You mean like Typeable and Generic?
09:40:27 <orion> https://hackage.haskell.org/package/reflection
09:41:59 <cocreature> orion: it‚Äôs definitely not superpopular
09:42:17 <portnov> probably the mention of the Oleg in the header makes everyone look to other side
09:43:06 <orion> What's wrong with Oleg?
09:43:56 <cocreature> orion: nothing but he‚Äôs known for ‚Äúadvanced haskell‚Äù
09:44:04 <portnov> probably something is wrong with everyone like us, whos type-system kung-fu is measured in milli-olegs
09:44:20 <cocreature> although reflection is funny since it replaces all of Oleg‚Äôs clever trickery by one line of GHC internals
09:44:53 <orion> Is there a personal feud between Oleg and Ed?
09:45:20 <nshepperd_> I just don't have that many opportunities to store things in types
09:45:45 <nshepperd_> I suppose if I needed to, I'd use reflection
09:47:41 <Cale> orion: That seems doubtful :)
09:52:05 <orion> Is there any technical reason to avoid reflection?
09:52:19 <uglyfigurine> https://news.ycombinator.com/item?id=14402378#14409595
09:53:14 <bollu> cocreature: ping
09:53:20 <cocreature> bollu: pong
09:57:09 <bollu> so, we just need to read the intrinsics file and generate haskell code, yeah?
09:57:14 <bollu> can you use TH for this?
09:57:49 <cocreature> bollu: no we can‚Äôt. llvm-hs-pure does not depend on the LLVM library so when we install it we can‚Äôt access the .td file
09:58:11 <bollu> cocreature: ah, I see
09:58:12 <cocreature> bollu: so we‚Äôll have to generate an actual file that we update from time to time and bundle that with llvm-hs-pure
09:58:17 <bollu> cocreature: so, some kind of pre-processing step?
09:58:29 <bollu> cocreature: yeah, we could perhaps version control the stuff that generates this
09:58:35 <cocreature> sure
09:58:41 <bollu> cocreature: hmm, how would you organise this?
09:58:42 <nbro> Hello!
09:58:46 <bollu> nbro: hey!
09:59:30 <nbro> If someone is interested in alternatives to this chat (which a very active one, so you probably don‚Äôt need alternatives, but anyway‚Ä¶) here you have a chat room on SO: http://chat.stackoverflow.com/rooms/110313/haskell
09:59:56 <Cale> :S
10:00:19 <bollu> cocreature: we can write the generator in haskell? I
10:00:22 <cocreature> bollu: I think the best solution is probably to write a C++ TableGen backend that generates the Haskell code we want
10:00:28 <bollu> cocreature: hm
10:00:36 <cocreature> bollu: I‚Äôve thought about it but I‚Äôm not sure if the effort of implementing a parser for TableGen is worth it
10:00:40 <bollu> cocreature: generating Haskell code is annoying by hand, I was hoping to write a haskell backend
10:00:41 <bollu> cocreature: I see
10:00:55 <bollu> cocreature: is it that hard a format, or is it just a "why do the work"?
10:01:30 <cocreature> bollu: I haven‚Äôt really lookedinto how difficult writing a C++ backend is (as I mentioned earlier, the docs on that are missing) and I don‚Äôt know really know the format either :)
10:02:10 <bollu> xD I see
10:02:16 <bollu> cocreature: OK, I'll give this a shor
10:02:32 <cocreature> bollu: http://llvm.org/docs/TableGen/LangRef.html doesn‚Äôt look so bad so maybe writing it in Haskell is reasonable after all
10:02:43 <cocreature> if we can avoid writing C++ code then by all means let‚Äôs do it :)
10:03:59 <cocreature> hm maybe not, it has loops and annoying stuff like that
10:04:31 <cocreature> although that seems to be the only control flow construct
10:05:41 <bollu> cocreature: which loop construct?
10:06:09 * hackage servant-auth-cookie 0.5.0.3 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.5.0.3 (zohl)
10:06:23 <cocreature> bollu: http://llvm.org/docs/TableGen/LangRef.html#foreach I got scared and thought they might have invented their own programming language including if statements and whatnot but it seems like they left it at simple loops
10:07:36 <mnoonan> is there some standard idiom that gives me this: class Container c i 
10:07:48 <mnoonan> | c -> i where items :: c -> [i]
10:09:19 <mnoonan> (or maybe I should just provide a Getter or something?)
10:11:54 <bollu> cocreature: how exactly do we use TableGen to get the intrinsics info?
10:12:21 <cocreature> bollu: take a look at include/llvm/IR/Itrinsics.td
10:12:52 <nbro> the nice thing about that chat is that messages are persistent even if you leave the chat room
10:13:31 <nbro> "nice", here, is relative, clearly
10:13:44 <bollu> cocreature: there's no foreach used in it
10:13:50 <bollu> cocreature: so technically we don't need to support it
10:13:57 <bollu> cocreature: I'm a strong believer of doing the minimal work possible :P
10:14:33 <cocreature> bollu: yeah supporting only a subset is probably reasonable
10:14:50 <bollu> cocreature: yes, I mean, we can probably extend it and make sure we're doing the right thing later
10:15:04 <bollu> cocreature: but, for practical use, I'm okay with supporting the minimal amount
10:15:11 <bollu> cocreature: do you want to write the parser in say, megaparsec?
10:15:22 <bollu> cocreature: or do you want to use a parser generator?
10:16:10 <srhb> mnoonan: No, but many container-likes have a toList
10:16:47 <cocreature> bollu: I guess a parser generator is probably easier since you can just directly translate the grammar. but admittely I‚Äôve not used alex/happy so far
10:16:59 <mnoonan> srhb: the problem is that I'm wrapping some foreign API types, many of which are containers (of other foreign types), but everything just has kind *.
10:18:38 <cocreature> mnoonan: MonoFoldable?
10:18:54 <bollu> cocreature: neither have I, I've never used Haskell parser generators.
10:20:14 <mnoonan> cocreature: ooh, that looks like the kind of thing I was after
10:20:28 <mnoonan> thanks
10:20:47 <Lokathor> Stackage Nightly 2017-05-24:	0.5.7.1
10:20:47 <Lokathor> Latest on Hackage:	0.5.10.2
10:20:50 <Lokathor> rrrraugh
10:23:49 <bollu> cocreature: so, can we come to a consensus?
10:39:42 <cocreature> bollu: so I think the best solution is to write a parser & generator in Haskell based on alex/happy
10:40:25 <Philonous> bollu, What are you people working on of you don't mind me asking?
10:40:40 <cocreature> Philonous: support for LLVM intrinsics in llvm-hs
10:40:54 <Philonous> Oh, neat!
10:40:55 <bollu> cocreature: I see, OK
10:41:10 <bollu> Philonous: yep :) I want it for this: http://github.com/bollu/simplexhc
10:41:43 <bollu> (shameless plug and all)
10:41:58 <bollu> cocreature: in the meantime, does it make sense for me to fork llvm-hs and simply setup the stuff I need?
10:42:10 <bollu> cocreature: like, I need 3 intrinsics literally :P
10:47:59 <cocreature> bollu: sure
10:49:31 <Lokathor> oh my gosh I think i've got myself in an actual MonadReader situation :/
10:58:30 <srhb> Lokathor: ?
10:59:18 <Lokathor> i've been building up a ton of local function definitions in a half-baked way because they all depend on window size and texture size data set at the top of main
11:00:14 <Lokathor> what i obviously should do is use MonadReader to make them easily accessable from more than one place and break the funcs apart more
11:00:30 <Lokathor> "let foo arg = let"
11:00:32 <Lokathor> this is a sign
11:01:13 <clamchowder> I have a question in Parsec
11:02:19 <clamchowder> say I want to parse a string to find a '*' without any preceding spaces, and return the substring preceding the '*' if succeed
11:02:38 <clamchowder> here's what I have: p = manyTill anyChar (try ((noneOf " \t\n") >> (char '*')))
11:02:42 <EvanR> Lokathor: when you have program-wide parameters like that, another way is to use the reflection trick. another way is implicit params but thats wildly unpopular
11:03:12 <Lokathor> reflection trick?
11:03:13 <EvanR> ah the word is implicit configuration
11:03:18 <srhb> clamchowder: manyTill (noneOf " \t\n) >> char '*' seems better to start with
11:03:21 <EvanR> http://okmij.org/ftp/Haskell/tr-15-04.pdf
11:03:30 <srhb> Woops, missed a quote.
11:03:38 <srhb> Err
11:03:43 <Lokathor> oh boy a paper >_<
11:03:50 <Lokathor> I think I'll just use MonadReader :P
11:03:52 <srhb> manyTill (noneOf " \t\n") (char '*')
11:03:56 <clamchowder> srhb: but that won't work for input string "  a*"
11:04:09 <srhb> clamchowder: Oh, I thought you said that was invalid.
11:04:36 <clamchowder> srhb: the character directely before * should not be a space
11:04:48 <srhb> clamchowder: Oh, oops!
11:05:00 <EvanR> Lokathor: its worth a read just to learn about what its calling "the configuration problem" which is what youre experiencing
11:05:05 <clamchowder> srhb: :)
11:05:42 <Lokathor> EvanR, i do seem to be having a config problem, yes. Specifically, I've got all these values which I need to normalize all the time
11:05:46 <clamchowder> The problem with my code is: the try ((noneOf " \t\n") >> (char '*')) part consumes the character that's right before the * when the parser succeeds
11:06:06 <EvanR> Lokathor: erm, you need to normalize all the time?
11:06:17 <clamchowder> for example, when parsing "abc*", the returned substring is "ab", rather than "abc"
11:06:23 <srhb> clamchowder: Bail out to monadic style might be easier to begin with :)
11:06:24 <EvanR> how many normalizations does it take to become normal? ;)
11:06:36 <clamchowder> How do I fix this?
11:06:40 <Lokathor> well, not repeatedly, but building up that first suite of data is the tricky part
11:07:04 <EvanR> oh the setup phase?
11:07:07 <Lokathor> yeah
11:07:09 <clamchowder> srhb: sorry what do you mean? 
11:08:04 <Lokathor> EvanR, this is for the glyph grid that I think you've mentioned wanting before. There's the row/col data in screen space, and the char data in texture space
11:08:04 <luigy> any tips on how to go about profiling/or things to look out for that make loading ~120 modules in one project take 6 times more versus another with also ~120 modules
11:08:09 <EvanR> i just have a big setup function that outputs a record of 6 finally setup things
11:08:16 <luigy> loading in ghci ****
11:09:08 <Lokathor> EvanR, yeah I'm headed that way. Just trying to slowly explore things out
11:09:41 <sm> luigy: narrow it down to individual module(s)
11:10:17 <EvanR> Lokathor: but actually... i now realize i am passing this record awkwardly to many "scenes" as they transition 
11:10:28 <sm> maybe some of them are large, have expensive declarations, or use template haskell
11:10:33 <Lokathor> ah ha, so there we go then
11:10:36 <EvanR> and i might be able to make use of this implicit configuration thing
11:10:39 <EvanR> instead of
11:10:54 <EvanR> coolScene :: System -> Fix IO
11:10:59 <EvanR> it could be
11:11:10 <luigy> sm let me get some stats on that
11:11:19 <Lokathor> mmm, Data.Vector.Storable.Mutable, what a module
11:11:53 <luigy> this is really kiling my cycles so hopefully there is something obvious in the stats :)
11:12:04 <EvanR> coolScene :: UnderSystem t => Scene t (Fix IO)
11:12:11 <EvanR> or something 
11:12:17 <Rajkumar> hi
11:12:19 <sm> also, why must you reload all 120 modules every time ?
11:12:24 <EvanR> instead of sys being a parameter to each one, sys would be a typeclass method
11:12:49 <Rajkumar> I am seeing .deb install for leksah is stopped for long time
11:12:50 <EvanR> after sys is ready, the first scene could be introduced with a wrapper withSystem sys (...)
11:12:57 <Rajkumar> is there any reason for that
11:13:00 <cocreature> EvanR: that looks very much like Reader System (Fix IO) :)
11:13:07 <Lokathor> EvanR, that seems like MonadReader r, can you still do "local" to re-define your context?
11:13:18 <EvanR> cocreature: no, because thats a monad
11:13:24 <Rajkumar> I am trying to install leksah on ubuntu 16.04
11:13:33 <cocreature> EvanR: ah fair enough
11:14:01 <EvanR> in the paper they use "what modulus am i in" for doing modular arithmetic everywhere without mentioning the modulus
11:14:11 <EvanR> or with using monadic code
11:14:23 <EvanR> as an example
11:15:06 <EvanR> in my case i could also have 6 "methods" build on the main one to talk about the 6 components without having to do asks or separate actions
11:15:43 <EvanR> but the rub is it requires a runtime creation of an instance
11:15:55 <EvanR> which oleg and then edk figured out
11:17:58 * EvanR reads the paper again
11:21:33 <Kanoxbox_> hi guys I am trying to install pidgin on linux...
11:21:38 <Kanoxbox_> getting some errors
11:22:23 <Kanoxbox_> how do I install including dependencies?
11:22:30 <kadoban> Kanoxbox_: There is a ##linux channel, along with distro-specific ones for the big ones, depending on what is approptiate. Unless this is somehow a haskell question that I'm missing.
11:22:37 <shapr> uh, I think this channel is about the Haskell programming language
11:23:00 <Kanoxbox_> ok guys...will get to ##linux
11:23:22 <Tuplanolla> Is that for the kernel or just everything?
11:23:32 <kadoban> Mostly userland I believe
11:23:54 <briansteffens> a distro-specific channel would probably be better for figuring out how to install a package with dependencies
11:23:57 <clamchowder> srhb: OK I figured it out:
11:23:58 <clamchowder> p = do 
11:23:58 <clamchowder>   x <- manyTill anyChar $ try $ lookAhead $ (noneOf " \t\n") >> (char '*')
11:23:59 <clamchowder>   y <- anyChar
11:23:59 <clamchowder>   return $ x ++ [y]
11:24:59 <srhb> Didn't you reverse the order of try and lookahead?
11:25:06 <srhb> Or... Maybe not
11:25:18 <Philonous> shapr, Why would you think that? That's absurd! I know the dude who created it, and he doesn't care about Haskell one bit! :P
11:26:26 <shapr> Philonous: he doesn't?
11:26:28 <shapr> huh
11:26:56 <Philonous> shapr, So I've heard. 
11:27:01 <shapr> wow, neat
11:27:26 <srhb> :q
11:27:28 <srhb> eep
11:27:31 <shapr> NO
11:27:41 <srhb> :-P
11:27:42 <shapr> you are not allowed to leave!
11:28:26 <Philonous> She was just trying to quit vim so she could fire up a proper editor :>
11:28:35 <srhb> Philonous: >:|
11:29:14 <shapr> Philonous: are you writing any cool code?
11:29:35 <shapr> I mean, clearly srhb is writing code
11:29:45 <Philonous> shapr, I'm tinkering with a (dependently-typed) heterogenous Map 
11:29:49 <shapr> ohh neat!
11:31:29 <shapr> I just heard about grenade: https://github.com/HuwCampbell/grenade
11:33:18 <Philonous> That does look nifty
11:33:57 <Philonous> Shame it's limited to CPU :(
11:34:39 <sternmull> can someone tell me how i bind a keyboard shortcut to the "Build Project" command of the ide-haskell plugin for the atom editor?
11:38:12 <KunoMark> hi, peeps.
11:38:18 <KunoMark> A quick lens question...
11:39:14 <KunoMark> I have the following: data A = {b :: Maybe B}, and data B = {c :: C}
11:39:31 <KunoMark> given an A, how do I get a Maybe C value, using lenses?
11:39:57 <Gurkenglas> preview (blens . _Just . clens)
11:40:00 <shapr> if you don't get an answer here, you could also try #haskell-lens
11:40:01 <KunoMark> I can do a ^. b, to get a Maybe B, but 
11:40:32 <shapr> Philonous: grenade training time sounds small even though it's CPU-only
11:40:48 <Gurkenglas> a ^? b . _Just . c
11:41:32 <KunoMark> Excellent! Thanks Gurkenglas and shapr :-D
11:41:54 <shapr> I also wonder if grenade handles multicore transparently.
11:42:03 <shapr> My xeons are too cold
11:42:10 <Philonous> shapr, I'm not a ml-person, but AFAIK 12 minutes for a mere 1.5% error rate is rather bad 
11:42:22 <Philonous> For MNIST, I mean
11:42:42 <shapr> I wouldn't know, I haven't gotten into machine learning yet.
11:43:40 <ph88^> i'm using State .. but i noticed that some state i need to access after the function is completed .. while order state can be discard .. is there any way to make a distinction between this? or should i move stuff out of state ?
11:44:52 <Tuplanolla> Define your data structures based on what changes together, ph88.
11:45:05 <Tuplanolla> The problem should solve itself.
11:46:30 <ph88^> Tuplanolla, i just have a record as state
11:47:22 <Tuplanolla> Something like `State (staysPut, changesALot) a` since you can `fmap` over `(,) staysPut`.
11:47:39 <Gurkenglas> ph88^, do you ever read the values that you need afterwards while still changing the state, or do you only ever write to them?
11:48:26 <Gurkenglas> If the latter, you could use a WriterT layer in addition to the StateT layer
11:52:47 <ph88^> Gurkenglas, i have 2 values that are R/W and two are W ..  but of those 2 R/W i want to read 1 afterwards and not the other one
11:57:13 <ecognium> Is there a way to force a compile error on non-exhaustive pattern match? I get warnings when a pattern match is redundant but not when one of the constructors is not matched.. I would prefer an actual error than a warning.. is it possible to throw an error when all constructors are not matched?  I am using ghc-options:  -Wall -O2
11:57:18 <kadoban> ph88^: Use the state function that lets you get all the state at the end, and then just have a function that narrows it to what you need, if you want?
11:57:58 <ph88^> can do :)
11:58:08 <kaychaks> am using -XTypeInType & -XGADTs, I have an ADT : data Concept a = Entity  a |  Role a | Relation a | Resource a | Sub (Concept a), I want to constrain types of another GADT with the promoted constructor types from this ADT, something like this: data Construct :: Concept * -> Concept * -> * where Has :: Concept a -> 'Resource b -> Construct (Concept a) ('Resource b). I could not figure out the types
12:03:04 <nshepperd_> Concept a isn't a member of Concept *
12:05:03 <nshepperd_> So Construct (Concept a) is a type error (kind error?)
12:05:44 <cocreature> gnah, if haddock wasn‚Äôt so slow it might be easier to convince myself to write docs
12:06:56 <nshepperd_> Maybe you wanted data Construct :: * -> (Concept *) -> * ?
12:07:09 <kaychaks> yes am getting that error. I am getting confused in the representation of the GADT. The thing I want is to have an explicit type signature for `Has` constructor of `Construct` which should take any Concept as first type (a) & a 'Resource (promoted type of Concept) as second type (b)  to construct finally a `Construct a b`
12:11:18 * mbrock extracts some code from one module to a new one and spends a bunch of time fiddling with imports
12:12:02 <EvanR> needs more IDE keycombos
12:12:26 <EvanR> or thinking ahead by importing a module that imports literally everything in every module
12:13:01 <ph88^> shapr, did you get the spock repo in shape ?
12:13:10 <EvanR> i would say smaller modules, but even those seem to have a page of imports
12:13:23 <EvanR> probably because of smaller modules
12:13:26 <mbrock> it's also a somewhat nice opportunity to rethink my imports and potentially feel bad about all my dependencies
12:13:40 <shapr> ph88^: I have it at the point where it does insert and select: https://github.com/shapr/sporkle
12:14:03 <shapr> I'm planning to bring the python equivalent up to the same functionality this evening, so I can give a lightning talk at work tomorrow
12:14:14 <ph88^> jle`, is this your blog ? https://blog.jle.im/ that's nice that you have a blog i will read a bit of it
12:14:42 <shapr> hej mikael!
12:14:43 <ph88^> shapr, can you do one url with static content plz plz plz ? :P
12:15:03 <shapr> ph88^: hopefully! the real one hour talk is in two weeks
12:15:06 <fresheyeball> Hello out here
12:15:20 <fresheyeball> I'm failing to make a Show instance for a singleton
12:15:37 <fresheyeball> Why is there no `Show a => Show (Sing a)` instance?
12:15:38 <mbrock> hej shae! :D
12:15:48 * shapr hops cheerfully
12:16:17 <mbrock> one of our cats got lost for a while and our other cat was sad but then we found him again and my program is totally working, so yay!
12:16:22 <shapr> yay!
12:16:50 <ph88^> you have a haskell program looking after cats ?
12:17:41 <mbrock> no :) but for a while when I was walking around outside searching I was thinking we might need to quickly set up a cat detection system for the night
12:18:09 <mbrock> yet another reason to get familiar with some of all this "AI" technology, I guess!
12:19:43 <sm> you category theorists and your cute jargon..
12:19:45 <nshepperd_> kaychaks: perhaps the thing to ask is what should the possible values be when you pattern match on a Construct?
12:20:55 <ph88^> mbrock, have you see that write up about the cat feeder ?
12:21:22 <mbrock> haha, yeah, the one where the guy keeps failing to keep the cat out and ends up putting more and more steel reinforcements?
12:22:03 <ph88^> i have here 3 lines of haskell code .. compared to 1 line of imperative code .. ok they are not exactly the same .. but i find the imperative code much easier to understand .. is there anything i can do to refactor the haskell code to make it shorter and more readable ?  https://bpaste.net/show/80aaa3d77b6e
12:22:13 <ph88^> mbrock, yes that one :P
12:23:22 <mbrock> :t until
12:23:24 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
12:23:58 <mbrock> > until (> 8) (* 2) 1
12:24:00 <lambdabot>  16
12:24:11 <sm> :t while
12:24:12 <lambdabot> error: Variable not in scope: while
12:24:14 <nshepperd_> ph88^: head . dropWhile (<t1) $ iterate something
12:24:29 <nshepperd_> Until, huh
12:24:55 <shapr> :t when
12:24:56 <lambdabot> Applicative f => Bool -> f () -> f ()
12:24:59 <shapr> :t until when
12:25:01 <lambdabot> error:
12:25:01 <lambdabot>     ‚Ä¢ Couldn't match type ‚Äòf0 () -> f0 ()‚Äô with ‚ÄòBool‚Äô
12:25:01 <lambdabot>       Expected type: Bool -> Bool
12:25:48 <kaychaks> nshepperd_ : ok. but am still confused in how to encode the types for the `Has` constructor of Construct
12:26:45 <sm> ph88^: looping there seems unnecessary 
12:27:26 <ph88^> until, while, head . dropWhile, when, until when .. eeeeh
12:27:30 <ph88^> what to choose xD
12:28:50 <ph88^> can't even find the right  while  on hoogle
12:30:08 <sm> let t' = if t1 > t then t + ((t1 - t) / sampleTime + 1) * sampleTime else t
12:30:22 <kadoban> ph88^: Also, probably besides the point, but you can do that with just math, specifically div
12:32:18 <ph88^> sm, i just ran your code and it gives the wrong result
12:33:35 <ph88^> https://bpaste.net/show/6a9d0a287244
12:34:23 <ph88^> kadoban, you mean a solution similar to the one of sm ?
12:35:10 <sm> I just wrote down what the voices told me.. but I'm surprised
12:35:32 <ph88^> lol
12:35:45 <kadoban> ph88^: Yes. It's in principle not hard to do, but getting all of the off-by-ones and special cases right is minorly tricky.
12:36:08 <ph88^> sm, do you think the numerical solution will be faster than  until   (at least if i get until working, i seem to be using it in the wrong way)
12:37:08 <kadoban> If the number of iterations grows, the numerical solution will eventually be infinitely faster. But if the typical/maximum number of iterations is small, it doesn't matter (the loop could even be faster)
12:39:06 <thang1> I think the main issue is not that haskell can't do the iterative loop as easily/clearly, but that in haskell I don't really think I've ever seen a reason why you would even do that in the first place
12:39:10 <ph88^> why did i get  until   wrong ?
12:39:29 <srk> thang1: :D nicely put
12:39:29 <sm> ugh, / was wrong of course. And I assumed integers. MULTIPLY ALL BY 100
12:40:01 <sm> until is pretty clear, and probably easier to figure out than the numerical one
12:40:04 <Logio> let t' = head $¬†filter (> t1) [t, t+sampletime..]
12:41:07 <sm> until (>= t1) (+ sampleTime) t
12:41:27 <Logio> oh right, that exists :)
12:42:01 <ph88^> lol i was reading "until" as "while"  -___-
12:42:17 <sm> there is a while, but it's not in base
12:43:10 <thang1> There's probably like 15 differnt while variants. 2 with documentation, 7 with "just grok the types bro", and 8 with no documentation whatsoever and that haven't been updated since 2008
12:44:37 <mbrock> there's usually a straightforward way to write such iterative loops as recursive functions, if you really want to
12:45:14 <sm> Logio: that literal list is interesting, I didn't know it could do that
12:45:41 <Logio> I remembered doing something like that once, it surprised me too
12:46:54 <thang1> It's pretty neat. Looks like you could also do something like that with a list comprehension?
12:48:43 <ph88^> why do i get a parse error here? https://bpaste.net/show/98ce8029ec7d
12:49:23 <kadoban> ph88^: Which line is that?
12:49:41 <ph88^> huh ?
12:49:46 <ph88^> line 273
12:50:42 <kadoban> Oh, I didn't see the comment
12:52:38 <ph88^> i'm using that boolean because i only need to check this once at the start of the stream .. i need to adjust some offset
12:55:32 <kadoban> ph88^: The things in if's branches have to be expressions. "let t' = t" isn't an expression, it's part of do syntax. You might want  let t' = if ...   but then the modify line doesn't fit in well. Kind of depends how you want to refactor that
12:56:01 <ph88^> i don't know what my options are
12:56:05 <ph88^> can't think of something
12:57:14 <kadoban> At the worst you could always do    t' <- if ... then return t else do {let x = ...; modify ...; return x}, but there's probably a better way
12:57:55 <ph88^> ok i found something .. but i think it's ugly because i need to check twice !   https://bpaste.net/show/981875f87cb6
12:58:15 <ph88^> oh i like your solution better than mine kadoban
13:00:27 <ph88^> ye this looks alright to me  https://bpaste.net/show/a7c1dbbac058
13:00:56 <ph88^> eh i meant  t' <-   ofc
13:02:02 <kadoban> Cool, if it works for you I don't mind the look of that. I'd probably do the indentation a little different, but I think that comes down to style.
13:03:25 <quchen> cocreature: Your ¬ªshorter text¬´ problem won‚Äôt let go of me
13:03:47 <ph88^> ¬ªtext¬´ , it's shorter
13:04:34 <cocreature> quchen: heh sorry about that. btw david christiansen has published a preprint on a prettyprinting algorithm for non-monospaced fonts :)
13:04:41 <cocreature> but I haven‚Äôt read it yet
13:05:09 <quchen> cocreature: The final prettyprinter?
13:05:13 <quchen> Yeah it sounds interesting
13:05:16 <cocreature> yep
13:05:22 <quchen> But the paper isn‚Äôt simple enough for me to read it on the fly ;-)
13:05:31 <quchen> It seems like a completely different approach though
13:09:42 <ph88^> there is also this which seems somewhat related https://github.com/google/xi-editor/tree/master/doc/rope_science
13:11:39 * hackage dirstream 1.0.3 - Easily stream directory contents in constant memory  https://hackage.haskell.org/package/dirstream-1.0.3 (GabrielGonzalez)
13:21:11 <clamchowder> Question: how do I use HUnit to test 1 + 2 = 3?
13:21:35 <codygman_____> Was teaching a beginner Haskell but couldn't come up with a good comprehensible answer to: "What is ‚Äò<-‚Äô and why isn't ‚Äòlet x = val‚Äô also used for it? ".  Any ideas?
13:23:10 <stefann> @pl \f a b c d -> f (a, b, c, d)
13:23:10 <lambdabot> (. (,,,)) . (.) . (.) . (.)
13:23:27 <EvanR> looks like a worm monster
13:23:41 <kadoban> codygman_____: I never teach, but depending on where they are in their studies, I'd either go with " <- is for running an action and assigning a name to the result" or go into what do notation desugars into.
13:23:50 <EvanR> coming at you in first person nethack view
13:23:54 <stefann> @pl \f (a, b, c) -> f a b c
13:23:54 <lambdabot> (line 1, column 11):
13:23:54 <lambdabot> unexpected "c"
13:23:54 <lambdabot> ambiguous use of a non associative operator
13:24:20 <EvanR> huh
13:24:29 <geekosaur> kinda poor error message for "I don't know how to pointfree 3-tuples"
13:24:57 <EvanR> > \f (a, (b, c)) -> f a b c
13:24:58 <clamchowder> OK I got it: t = TestCase (assertEqual "" (1 + 2) 3)
13:24:59 <lambdabot>  error:
13:24:59 <lambdabot>      ‚Ä¢ No instance for (Typeable t0)
13:24:59 <lambdabot>          arising from a use of ‚Äòshow_M894443424140670564923073‚Äô
13:25:13 <EvanR> @pl \f (a, (b, c)) -> f a b c
13:25:13 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .)
13:25:20 <clamchowder> runTestTT t
13:25:23 <Gurkenglas> kinda poor error message for "I can't show functions"
13:25:40 <codygman_____> kadoban: i think a follow up would be: how do i know when something is an action?    Which could be answered with "the type includes IO"
13:25:42 <geekosaur> also true
13:26:31 <kadoban> codygman_____: Right, if they're at the point where do notation is just something you use for IO, that sounds fine.
13:26:42 <Gurkenglas> Can we get a lawless function Show instance into lambdabot that shows the type?
13:26:48 <stefann> @pl (\f (a, b, c) -> (f a b c))
13:26:48 <lambdabot> (line 1, column 12):
13:26:48 <lambdabot> unexpected "c"
13:26:49 <lambdabot> ambiguous use of a non associative operator
13:27:52 <stefann> @pl (\f (a, b, c) -> f a b c) :: (a -> b -> c -> d) -> (a,b,c) -> d
13:27:52 <lambdabot> (line 1, column 12):
13:27:52 <lambdabot> unexpected "c"
13:27:52 <lambdabot> ambiguous use of a non associative operator
13:28:32 <codygman_____> kadoban: i think that explanation was pretty good.
13:28:58 <kadoban> I would imagine there's a better one, but I'm not sure what it is :-/
13:45:55 <EvanR> codygman_____: kadoban: if you introduce do notation and <- completely referring to IO actions... and dont reveal any polymorphism or other uses, it will be right. but we unfortunately dont have good ways of getting specialized type signature output
13:46:22 <EvanR> everything you do in IO has Monad all over it
13:46:59 <EvanR> and then you have to teach how to substitute types for variables
13:47:04 <kadoban> If I were forced to teach, I'd probably try to say that it's useful for other things, but at first just worry about IO and give them rules to replace 'm' with IO for now. But yeah it's not perfect.
13:48:53 <thang1> idk, I kinda like the idea of teaching in haskell by completely avoiding in IO as long as possible (until people are ready for it, at least)
13:51:17 <kadoban> Not sure that's feasible. Or at least that time period sounds short. You can't even run any program at all without IO. I guess you could give them a template that takes care of IO for you ...
13:52:58 <EvanR> thang1: a function like idris... repl :: String -> (String -> (String, String)) -> IO () would be nice...
13:53:04 <EvanR> :t interact
13:53:06 <lambdabot> (String -> String) -> IO ()
13:53:12 <EvanR> is kind of not that
13:53:53 <EvanR> code.world/haskell has a number of entry points that do IO for you, pretty cool, even apparently to the point of multi-user networked simulation
13:54:34 <thang1> oooh neat
13:58:39 * hackage hackport 0.5.3 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.5.3 (SergeiTrofimovich)
14:01:38 * hackage simple-log 0.9.2 - Simple log for Haskell  https://hackage.haskell.org/package/simple-log-0.9.2 (AlexandrRuchkin)
14:50:27 <nshepperd_> Gurkenglas: lambdabot already has such an instance. But it needs Typeable for the argument and result so it can print their types
14:51:19 <nshepperd_> It really needs some special magic so that it can act like :t for functions generally
14:51:40 <nshepperd_> And print their fully general type including foralls
14:52:51 <Gurkenglas> > const undefined :: (Typeable a, Typeable b, Typeable (a -> b)) => a -> b
14:52:53 <lambdabot>  error:
14:52:54 <lambdabot>      ‚Ä¢ No instance for (Typeable a0)
14:52:54 <lambdabot>          arising from a use of ‚Äòshow_M633173445441179135825665‚Äô
14:53:22 <Gurkenglas> <Gurkenglas> @more <lambdabot> Plugin `more' failed with: Prelude.init: empty list
14:53:49 <nshepperd_> > \x -> (x :: Int)
14:53:51 <lambdabot>  <Int -> Int>
14:54:08 <nshepperd_> It works when it knows which Typeable instance to use
14:54:36 <geekosaur> more specifically current Typeable is not polymorphic
14:54:42 <geekosaur> that should change with 8.2
14:55:08 <nshepperd_> Not polymorphic?
14:55:09 * EvanR wonders how that would work
14:55:40 <EvanR> can a Char -> Char be recovered if you think its a type rep for "a -> a"
14:55:48 <EvanR> if you have a type rep for
14:55:52 <geekosaur> as with your example. it can handle a function Int -> Int, but Num a => a -> a cannot  be represented
14:55:56 <nshepperd_> Impredicative Typeable instances? Typeable (forall a. a -> a) o_O
14:56:01 <geekosaur> but in 8.2 thee is type-indexed Typeable
14:56:04 <geekosaur> *there is
15:18:20 <c_wraith> I didn't realize that the new Typeable interface gives you polymorphic TypeReps
15:19:16 <geekosaur> there's a discussion in ghc trac wiki. I don't quite understand it >.> but it does claim to give you polymorphic TypeReps
15:19:31 <EvanR> polymorphic typereps... typereps of polymorphic types?
15:23:24 <c_wraith> EvanR, more like preserving a polymorphic value's type when getting a TypeRep from it. 
15:23:48 <c_wraith> instead of the current situation.. 
15:24:02 <c_wraith> > typeOf Nothing
15:24:04 <lambdabot>  error:
15:24:04 <lambdabot>      ‚Ä¢ No instance for (Typeable a0) arising from a use of ‚ÄòtypeOf‚Äô
15:24:04 <lambdabot>      ‚Ä¢ In the expression: typeOf Nothing
15:24:23 <c_wraith> you currently have to make the type concrete. 
15:24:46 <c_wraith> > typeOf (Nothing :: Maybe Int) 
15:24:49 <lambdabot>  Maybe Int
15:25:22 <EvanR> a polymorphic value
15:25:50 <EvanR> ok
15:54:52 <angerman> joeyh: let me know your use case and I might use that as an example :-)
15:58:59 <joeyh> angerman: I cross-compile to android, it's a PITA
16:00:25 <angerman> joeyh: I mean the specific TH pain :-)
16:01:35 <joeyh> oh well, nothing unusual. persistent and yesod
16:02:10 <angerman> joeyh: yesod on android? 
16:02:33 <joeyh> yes
16:03:28 <angerman> joeyh: ahh well. Yes of does a lot of file IO, not sure about process IO, but that might work with a small patch to yesod.
16:04:09 <joeyh> there's some file IO in yesod-static, mostly it's TH code generation though
16:04:12 <angerman> joeyh: I'm not sure what th persistent uses, but that could be little enough to make it a viable example.
16:05:01 <nshepperd_> Oh, the new typeOf Nothing would produce something :: Typeable a => TypeRep (Maybe a)?
16:05:22 <angerman> joeyh: code gen should work. Just file and process IO need some special handling due to the reasons laid out in the medium post.
16:06:44 <angerman> joeyh: https://www.irccloud.com/pastebin/iuaW4a2s ;-)
16:07:04 <nshepperd_> No, that wouldn't help because you still don't have the instance
16:09:32 <joeyh> angerman: I was thinking the external interpreter would need a ghc running on android, which does not exist AFAIk.
16:09:51 <joeyh> but, hmm, I suppose it could just use the build system's ghc
16:10:17 <angerman> joeyh: I'll go into detail in the post later today :/)
16:10:22 <joeyh> as long as the TH doesn't involve something architecture specific
16:11:10 <angerman> joeyh: it does work on RPi, Android and iOS :-)
16:12:04 <angerman> joeyh: the key is https://github.com/zw3rk/ghc-slave
16:12:40 <angerman> I'll push the latest changes to that repo after breakfast.
16:19:06 <thang1> that runGit function looks horrifying
16:29:59 <angerman> thang1: it's only a slight alteration of the on from the gitrev package.
16:32:09 * hackage hpio 0.8.0.9 - Monads for GPIO in Haskell  https://hackage.haskell.org/package/hpio-0.8.0.9 (dhess)
16:42:07 <mniip> when we speak of End(Hask) do we usually mean all datatypes of kind *->* or do we usually speak of exactly functors
16:44:03 <mniip> both make a category (kinda)
16:45:03 <joeyh> angerman: seems you have been slightly burying the lede ;)
16:48:08 <felixphew> hi!
16:48:36 <felixphew> if anyone remembers my annoying language from the other day, I'm having a go at using alex
16:48:52 <felixphew> but I seem to be having trouble learning the syntax
16:48:53 <felixphew> http://lpaste.net/1166517670258933760
16:48:58 <dmj`> oh shoot, Control.Monad.Trans.Select
16:49:03 <felixphew> this first hits an error at line 13
16:49:17 <felixphew> what's wrong?
16:50:23 <glguy> I'll take a look, but while I'm doing that, consider lining things up so that it isn't so crazy to look at :) https://github.com/glguy/config-value/blob/master/src/Config/Lexer.x#L56
16:50:30 <angerman> joeyh: pardon me?
16:51:19 <glguy> felixphew: You needed to escape your - and )
16:52:15 <felixphew> well that was simple
16:52:17 <felixphew> thanks!
16:53:33 <thang1> Me: "why is this not working" *stares at function for 5 minutes* oh... I guess I should recurse on the correct function, shouldn't I?
16:53:45 <thang1> Also me: "why is my brain so broke inside"
16:56:14 <mniip> hmm, does 'Free' have a ziplike interface
16:58:08 <mniip> Applicative f => Free f a -> Free f b -> Free f (a, b)
16:58:09 <mniip> or something
16:59:57 <lyxia> that doesn't seem too crazy
17:03:22 <Sonolin> mniip maybe something like
17:03:30 <Sonolin> > (,) <$> Pure 5 <*> Pure 6
17:03:32 <lambdabot>  error:
17:03:32 <lambdabot>      ‚Ä¢ Data constructor not in scope: Pure :: Integer -> f a1
17:03:32 <lambdabot>      ‚Ä¢ Perhaps you meant variable ‚Äòpure‚Äô (imported from Control.Applicative)e...
17:03:43 <mniip> no it's definitely not the Applicative instance
17:03:54 <Sonolin> oh ok
17:03:55 <angerman> joeyh: ohh. so you mean I haven't been clear enough about actually *having* a solution? And just made it sound like it's a dead end?
17:04:29 <mniip> Sonolin, actually
17:04:35 <mniip> I'm looking for a thing for FreeT
17:10:00 <mniip> hmmm
17:10:11 <mniip> doesn't look like I can get away with an Applicative
17:19:09 * hackage mellon-core 0.7.1.1 - Control physical access devices  https://hackage.haskell.org/package/mellon-core-0.7.1.1 (dhess)
17:20:09 * hackage mellon-gpio 0.7.1.1 - GPIO support for mellon  https://hackage.haskell.org/package/mellon-gpio-0.7.1.1 (dhess)
17:21:09 * hackage mellon-web 0.7.1.1 - A REST web service for Mellon controllers  https://hackage.haskell.org/package/mellon-web-0.7.1.1 (dhess)
17:23:23 <mniip> @tell edwardk why is (Functor f, Monad m) => Functor (FreeT f m), this inconveniences me slightly...
17:23:24 <lambdabot> Consider it noted.
17:23:48 <thang1> Learning about Kinds right now in Haskell From First Principles
17:23:56 <thang1> amExcite.gif
17:29:26 <lpaste> nshepperd pasted ‚Äúzippy free‚Äù at http://lpaste.net/355823
17:29:49 <nshepperd> this is for Free, not FreeT though
17:30:23 <mniip> yeah
17:30:27 <mniip> very similar to what I have here
17:32:01 <mniip> dammit
17:32:18 <mniip> MonadPlus m => Alternative (FreeT f m)
17:32:46 <thang1> lol
17:33:08 * hackage zre 0.1.0.0 - ZRE protocol implementation  https://hackage.haskell.org/package/zre-0.1.0.0 (srk)
17:33:18 <srk> ^^
17:33:27 <mniip> edwardk, did you just throw these together last second ;(
17:34:12 <lpaste> nshepperd annotated ‚Äúzippy free‚Äù with ‚Äúzippy free (annotation)‚Äù at http://lpaste.net/355823#a355824
17:34:17 <thang1> srk: how do I see the documentation in this anyway? None of the modules have links
17:34:30 <srk> thang1: no idea why hackage does not generates it automatically
17:34:47 <thang1> I think it has to wait a second to generate it and then fill everything in 
17:35:11 <srk> sometimes it doesn't appear on the page even after some time
17:35:38 <glguy> srk: Looks like you forgot all the version bounds! Also hackage can't build zeromq, so you'll need to upload the docs yourself
17:36:01 <srk> aah, ok
17:36:02 <glguy> srk:  You can use this https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
17:36:56 <srk> glguy: I spend a lot of time deleting upper bounds from upstream projects just to compile in newer stack snapshot /o\
17:37:05 <mniip> ugh
17:37:14 <srk> reminds me that I need to send few pull requests as well
17:37:15 <mniip> what was the applicative mapM in traversable
17:37:32 <mniip> oh
17:37:33 <mniip> traverse
17:37:37 <mniip> that's what it is of course
17:37:40 <glguy> srk: as long as you don't have any users it won't matter, but it passes the responsibility of figuring out how to get your project building onto them
17:38:20 <srk> glguy: well I'll try to keep it up to shape with CI, also there's stack.yaml with specific snapshot
17:38:33 <mniip> dammit
17:38:46 <mniip> the Traversable for FreeT is unnecessarily bound too
17:38:58 <glguy> srk: the stack.yaml doesn't help if you intend people to use this as a library
17:39:09 <EvanR> once again users are the problem
17:39:09 <srk> ah, ok
17:40:47 <srk> glguy: will work on that, also docs need improvement.. but I've wanted to release this already as it's quite usable even in current form
17:43:51 <glguy> if you do figure out what versions of things you intend to support, make sure you go back and update this one with the knowledge (or make it impossible to build). Otherwise when other versions conflict the solver will often attempt to just use this early release with no constraints when asked to use your package (just something that happens in general)
17:45:12 <EvanR> which way is foldables' monoid merging biased
17:45:31 <EvanR> x <> accum, accum <> x ...
17:45:38 * hackage lackey 0.4.3 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-0.4.3 (fozworth)
17:45:46 <thang1> Instinctively, I guess right because everyone tends to stick the ugly stuff and errors and such in the left
17:46:31 <EvanR> which way is right seems to depend on the monoid
17:46:50 <thang1> Whichever bias allows it to deal with infinite structures is the one I would guess :p
17:46:59 <EvanR> could be either
17:47:22 <EvanR> :t foldMap
17:47:24 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
17:47:42 <EvanR> > foldMap id [[1],[2],[3]]
17:47:44 <lambdabot>  [1,2,3]
17:48:34 <EvanR> so be it
17:56:12 <Sonolin> is there a good SQL abstraction library that doesn't use TH?
17:59:38 * hackage final-pretty-printer 0.1.0.0 - Extensible pretty printing with semantic annotations and proportional fonts  https://hackage.haskell.org/package/final-pretty-printer-0.1.0.0 (dchristiansen)
18:04:39 * hackage chronologique 0.2.1.0 - Time to manipulate time  https://hackage.haskell.org/package/chronologique-0.2.1.0 (AndrewCowie)
18:06:40 <mniip> hmmm
18:06:47 <mniip> is that even a thing
18:07:40 <thang1> look inside yourself. Find the time bender within you. Reach deep within the void... (and turn off your alarm clock)
18:08:50 <mniip> I think it is possible...
18:10:29 <thang1> mniip: in regards to the SQL question or the chronologique library?
18:10:41 <mniip> neither
18:10:55 <mniip> the Applicative m => Applicative (FreeT f m)
18:11:03 <thang1> oooh right, still stuck on that
18:11:38 <mniip> I was about to make a pull request to 'free' thinking "this is trivial to write"
18:11:40 <mniip> it was not
18:18:42 <EvanR> mniip: it does work for the Iter monad
18:18:52 <mniip> Iter = ?
18:19:12 <EvanR> IterT ~ FreeT Identity
18:19:22 <EvanR> https://hackage.haskell.org/package/free-4.12.4/docs/Control-Monad-Trans-Iter.html
18:20:10 <mniip> I don't see a reason it shouldn't
18:20:20 <EvanR> me neither
18:20:34 <mniip> for an Applicative m, IterT m sounds Applicative
18:20:45 <lamduh> is there a good beginner haskell book that has excercises. learn you a haskell doesnt have any official problems
18:21:43 <Cale> lamduh: That's generally the problem. Hutton's book has some. The various CIS 194 course materials have a bunch.
18:22:08 <EvanR> oh when m is applicative...
18:22:09 <lamduh> so cis 194 is a good place to learn?
18:22:26 <Cale> yeah, I particularly recommend Brent Yorgey's edition of the course
18:22:31 <lamduh> thanks
18:22:35 <Cale> http://www.cis.upenn.edu/~cis194/spring13/
18:23:18 <mniip> ah-ha!
18:23:23 <lamduh> thanks
18:23:30 <thang1> My favorite book is the Haskell From First Principles book, but the CIS194 course is probably the best free resource for now. It's a bit quick and I had trouble with it when I first tried it out
18:23:32 <mniip>       go (Free f) x = Free (fmap (FreeT . fmap (`go` x) . runFreeT) f)
18:23:53 <mniip> however I'm not sure that's lawful...
18:24:11 <Cale> edwardk: (Mildly offtopic) Do you know if there's any work extending stochastic lambda calculi with dependent types?
18:24:29 <Cale> (you just seem like you might know :)
18:25:29 <lpaste> mniip pasted ‚Äú(Functor f, Applicative m) => Applicative (FreeT f m)‚Äù at http://lpaste.net/355825
18:25:31 <mniip> anyone care to look?
18:26:00 <Cale> It typechecks? Ship it.
18:26:02 <thang1> Why the inline pragma?
18:26:11 <mniip> it came from the original code
18:26:19 <thang1> ah okay
18:26:30 <Cale> I can't imagine it being all that important, but who knows.
18:26:48 <Cale> I would usually expect GHC to inline something that small on its own
18:26:54 <thang1> "It typechecks? Ship it" <-- agreed :p
18:27:05 <mniip> Cale, I see at least one different implementation that typechecks
18:27:14 <mniip> it, however, does not agree with `ap`
18:27:33 <thang1> Although I am somewhat wary of random inline pragmas after I read that article about how an inline pragma actually reduced speed by a ton
18:30:00 <mniip> oh no
18:30:02 <mniip> I broke it
18:30:19 <Cale> mniip: Well, you can always swap the order of effects of the "function" and "argument"
18:30:34 <mniip> nope it's not about swapping
18:30:38 <mniip> it's about sharing
18:32:39 <mniip>  > FreeT [Free [FreeT [Pure id]]] `ap` FreeT [Pure "foo", Free [FreeT [Pure "bar"]]]
18:32:39 <mniip> FreeT [Free [FreeT [Pure "foo",Free [FreeT [Pure "bar"]]]]]
18:32:46 <mniip>  > FreeT [Free [FreeT [Pure id]]] <*> FreeT [Pure "foo", Free [FreeT [Pure "bar"]]]
18:32:46 <mniip> FreeT [Free [FreeT [Pure "foo"]],Free [FreeT [Free [FreeT [Pure "bar"]]]]]
18:34:59 <thang1> I think you broke the bot
18:45:59 <mniip> hmmm
18:48:05 <plugin> I'm trying to write some data to the audio buffer using the Audio.Jack package but my program keeps throwing "testAccSynth.hs: printf: argument list ended prematurely" when I run it.  I can't find any code locally or in Audio.Jack that calls printf, can anyone advise on how I might proceed debugging?
18:53:21 <suzu> try ./binary +RTS -xc
18:55:13 <mniip> so it seems, that 'FreeT (return (Pure id)) <*> x = x'
18:55:55 <mniip> yes 'FreeT (return (Free f)) <*> x = FreeT (return (Free ...))'
18:55:59 <mniip> yet*
18:56:52 <mniip> so it follows that I must 'bind' the contents of the first FreeT in order to determine the 'shape' of the contents of the resulting FreeT
18:57:12 <mniip> and Applicative is not enough
19:13:38 * hackage camh 0.0.3 - write image files onto 256(or 24bit) color terminals.  https://hackage.haskell.org/package/camh-0.0.3 (HironaoKomatsu)
19:14:46 <mniip> hmm
19:14:52 <mniip> curious
19:15:14 <mniip> Yoctoparsec's Parser has the same *structure* as FreeT Reader
19:15:19 <mniip> but different instances
19:16:34 <Rotaerk> hmm now to figure out how to implement (a -> Maybe b) -> Consumer b m r -> Pipe a a m r
19:19:25 <johnw> just a guess, but: \f c -> for cat (\a -> forM_ (f a) $ \b -> c b)
19:19:27 <Welkin> toctoparsec? o.o
19:19:36 <Welkin> yoctoparsec*
19:19:55 <johnw> oh, and a yield in there to pass it down the pipe too
19:20:11 <Welkin> lol mniip
19:20:14 <Welkin> it's your library
19:21:20 <mniip> Welkin, I just decided to write some nontrivial combinators for it
19:21:37 <mniip> more nontrivial than 'token' as closed under MonadPlus
19:21:53 <sproingie> chocoparsec
19:22:04 <mniip> and then everything hit me
19:22:38 <mniip> I can't even write a '(Alternative b, Eq t) => [t] -> Parser b t [t]'
19:22:48 <mniip> everything wants a Monad constraint on b
19:23:43 <Rotaerk> johnw, well you make it look easy >_>
19:25:39 <Rotaerk> I don't have an intuitive enough grasp of pipes yet to just whip out a solution
19:25:55 <johnw> that's what we're here for :)
19:26:00 <Rotaerk> heh
19:26:49 <johnw> the "for cat" thing is pretty idiomatic, and appears in the pipes libraries rather often
19:27:10 <johnw> the forM_ is just Foldable making the Maybe easier to unpack
19:27:21 <lyxia> meow
19:27:27 <johnw> oh, 'c b' probably isn't right, you might need a specific commit to submit to the consumer
19:27:47 <Rotaerk> the a should only be yielded from the pipe if it's *not* converted to a b
19:27:54 <johnw> ah, then you want a case
19:27:57 <Rotaerk> calling this partialConsume or something
19:28:01 <felixphew> how does one change state in alex?
19:28:01 <johnw> i see
19:28:13 <johnw> you want to steal things from the input
19:28:17 <felixphew> the examples aren't making it very clear
19:28:20 <Rotaerk> yep
19:28:32 <Rotaerk> my goal is to fork the stream into two consumers
19:28:42 <Rotaerk> so my strategy is to partially consume it with one, then with another
19:28:48 <Rotaerk> (and extensible to N consumers)
19:31:19 <lyxia> mniip: it looks like these Monad constraints are there for pre-AMP compatibility, at least 
19:31:44 <mniip> nope
19:32:24 <mniip> not all of them
19:32:37 <mniip> ah
19:32:38 <mniip> ahhhh
19:33:05 <mniip> I see
19:34:01 <lyxia> Actually you could also add Functor constraints everywhere
19:34:37 <zeonic98> Hi all
19:35:13 <zeonic98> How is everyone
19:35:58 <felixphew> pretty good
19:38:15 <zeonic98> I'm pretty sure I'm in the wrong channel  
19:38:48 <zeonic98> But maybe you could point me in the correct direction of that's cool
19:39:16 <MarcelineVQ> It's pretty cool here
19:39:27 <Axman6> zeonic98: what're you after?
19:40:14 <zeonic98> I wondered if there was such thing as a disabled room. 
19:40:48 <zeonic98> I'm trying to find some people that have Parkinson's
19:41:42 <zeonic98> That aside. Is there a topic here or can we talk about anything?
19:41:51 <johnw> the topic is Haskell
19:42:01 <johnw> there are other channels for more general chat
19:42:29 <Rotaerk> zeonic98, what I'm curious about is how you found this channel and didn't know what it was about
19:42:45 <zeonic98> That I can answer.
19:43:04 <zeonic98> I googled helpful freenode chat
19:43:10 <Rotaerk> hahah
19:43:16 <Rotaerk> yes, this place is quite helpful
19:43:24 <Rotaerk> just focused on a specific subject
19:43:39 <Rotaerk> also, (for cat) seems very similar to (await >>=), just slightly less general
19:43:42 <zeonic98> So it's a programming language?
19:43:46 <Rotaerk> yes
19:43:55 <kadoban> #freenode might be a decent place to start, though I'm not sure what actual big just plain chat channels there are. Freenode is focused towards kind of software projects and etc. quite a lot.
19:44:45 <zeonic98> Okay I'll try that.  
19:44:57 <mniip> freenode isn't here for general chat, so don't expect to find a good channel
19:45:30 <zeonic98> Tbh I've never used it until now for general chat
19:46:28 <zeonic98> Mostly for tech advice when I'm stuck with Linux questions or #scripts etc
19:47:51 <Rotaerk> err wait no... similar signature, but await >>= only happens once...
19:49:42 <mniip> zeonic98, ##linux is a channel that exists
19:49:45 <mniip> so is ##programming
19:50:01 <mniip> and many more
19:50:13 <Welkin> and ##freenode
19:50:21 <zeonic98> Thanks. I've used them before. Very helpful
19:50:46 <Welkin> don't forget about mniip's favorite #lua
19:51:08 <mniip> times have changed
19:57:56 <zeonic98> Nothing out there, anyone bored and fancy a chat
19:58:58 <glguy> zeonic98: This is the wrong channel for find general chat
20:00:13 <zeonic98> Yeah I know. Sorry. People are more friendly here. I'll clear off. 
20:00:47 <johnw> Rotaerk: await >>= will only get one value from the input, unless you use recursion or some kind of looping construct
20:07:56 <thang1> damnit, I was gonna reply to him but I was too late
20:08:29 <thang1> there's a #medicalschool irc on irc.snoonet.org that he might look into and there's #casualConversation on irc.snoonet.org that's entirely for, well, casual conversation
20:08:53 <glguy> No, that wouldn't be on topic
20:09:13 <thang1> Well it's about as ontopic as mentioning the existence of ##programming :p
20:20:38 * hackage yahoo-finance-api 0.2.0.2 - Read quotes from Yahoo Finance API  https://hackage.haskell.org/package/yahoo-finance-api-0.2.0.2 (cdepillabout)
20:22:56 <zeonic98> Hi all. Me again. Google is correct this is the most helpful channel 
20:23:16 <thang1> hey!
20:23:21 <zeonic98> Hi
20:23:30 <thang1> Here I'll query you so we're not clogging up the main channel 
20:25:48 <AbelianGrape> Is there any typeclass that will tell me the cardinality of a type? E.g. it should give me 2^64 for Int64 or Word64, 2^8 for Word8 or Int8, etc.
20:26:11 <dmj`> > maxBound :: Int
20:26:13 <lambdabot>  9223372036854775807
20:26:42 <AbelianGrape> dmj`: That doesn't tell me the total number of inhabitants of the type.
20:26:49 <AbelianGrape> I guess I could do maxBound - minBound
20:27:33 <thang1> https://hackage.haskell.org/package/Cardinality
20:28:05 <AbelianGrape> Wow, that's a lot more involved than I expected
20:28:19 <thang1> Don't think that's exactly what you wanted, but it's something!
20:28:20 <kadoban> > maxBound - minBound :: Int8
20:28:21 <nshepperd_> That package seems like a different thing
20:28:22 <lambdabot>  -1
20:28:29 <AfC> There's an Enum instance, you could walk all the values and count. Especially if it's cold where you are, good excuse to run the CPU to heat up the place.
20:28:33 <AbelianGrape> kadoban: You would have to translate to a larger type first
20:29:00 <kadoban> Yes
20:29:10 <AbelianGrape> > (fromIntegral (maxBound :: Int8) :: Int64) - (fromIntegral (minBound :: Int8) :: Int64)
20:29:12 <lambdabot>  255
20:29:56 <AbelianGrape> Ah, +1
20:30:14 <mniip> AbelianGrape, what would you want for Double?
20:30:26 <mniip> 2^64-1 ?
20:30:43 <kadoban> AbelianGrape: Note that that's actually off by one too.
20:30:43 <mniip> 2^64-1-2^53?
20:30:45 <AbelianGrape> mniip: Nothing. Double wouldn't make sense for this application
20:31:02 <AbelianGrape> Would only be required for integral types
20:31:08 <mniip> so you're only interested in primitive int/word types
20:31:23 <mniip> then fromIntegral maxBound/minBound is the way to go
20:31:23 <AbelianGrape> Not necessarily. data Foo = A | B | C | D would work too
20:31:44 <kadoban> Anything that's Enum and Bounded should be fairly easy I think
20:31:54 <AbelianGrape> Good thinking
20:45:09 <_sras_> Using Swagger, How can I add a description to an api endpoint? Can I do it from the endpoint's type signature itself?
20:59:36 <jle`> ph88: yes that is me :)
20:59:43 <dmj`> _sras_: servant swagger?
21:00:15 <dmj`> _sras_: iirc you can annotate api description endpoints with lenses in the main swagger type
21:01:21 <_sras_> dmj`: Yes. I see I can do something like this https://github.com/GetShopTV/swagger2/blob/73c4c7775e6dbe3f88ab69142d113dd6548a6d01/examples/hackage.hs#L65-L82
21:02:10 <_sras_> dmj`: But I have an existing schema generated from the api type. I want to add descriptions to the existing endpoint, instead of adding them from scratch, like that code seems to be doing...
21:03:45 <dmj`> _sras_: servant-swagger is meant for producing a new swagger document from a servant api description. Swagger is strictly more expressive than what we have at the type-level available to us in servant, so the lens annotations are necessary. What you‚Äôre proposing is that we generate servant type level definitions from a quasi quoter that contains the
21:03:45 <dmj`> swagger spec. There‚Äôs been talks about this, but no movement.
21:06:55 <dmj`> Your options are 1) wait a few years for dependent haskell, 2) write the library the generates haskell from a swagger spec. 3) try to remake your current swagger spec in haskell
21:07:04 <dmj`> that*
21:10:40 <thang1> dmj`: do you think dependent types can be used in a functional logic language?
21:11:04 <Axman6> _sras_: take a look at https://github.com/data61/bom-solar-webservice/blob/master/app/Main.hs#L195 to see how to add information to the automatically generated docs
21:12:53 <dmj`> _sras_: it works via tags iirc, https://gist.github.com/dmjio/d35b2254803490ebe6c07b251077d4c4
21:13:09 <dmj`> _sras_: you can‚Äôt do it inline
21:13:16 <dmj`> if that‚Äôs what you‚Äôre referring to
21:14:11 <dmj`> thang1: #idris is an example of dep. types in a functional language
21:15:11 <thang1> Idris doesn't have any logic facilities in it though
21:15:39 <thang1> I'm talking about functional logic languages such as Curry (a blending of narrowing strategies a-la Prolog combined with fp)
21:18:15 <dmiles> thang1: i came ot the same conclusion abotu Idris :(
21:18:46 <codygman> Is there a way to write this with higher order functions? My mind is stuck on something like foldMap fold
21:18:48 <codygman> http://lpaste.net/355827
21:22:00 <andromeda-galaxy> codygman: trying to get a handle on what this is doing... just out of curiosity, logically speaking, why does go add acc to the output list every time it recurses?
21:22:07 <andromeda-galaxy> and why is there a separate case for [x] vs. (x:xs)?
21:22:38 <johnw> codygman: if this gets any bigger, just use fgl
21:23:35 <andromeda-galaxy> seconded! this kind of graph is a good fit for fgl
21:23:49 <codygman> johnw: I thought fgl might be appropriate, but I had a hard time figuring out how to use it since I haven't used graphs much in general. I suppose I was trying to learn graphs (to some extent) and how to use FGL. Thanks for the recommendation.
21:24:31 <andromeda-galaxy> codygman: also afaict in no recursive call to go does acc ever get added to. So acc is always []?
21:24:56 <codygman> andromeda-galaxy: It has [x] for singleton calls and (x:xs) for when multiple items are in the list
21:25:25 <andromeda-galaxy> codygman: [x] = (x:[])
21:25:31 <andromeda-galaxy> is there a logical reason why singletons are different?
21:26:27 <johnw> codygman: I use it for lots of things
21:26:59 <codygman> andromeda-galaxy: I'm quite tired and barely managed to get this to work. I tried taking out my singleton case and only "b" was returned. I'm not sure ATM i can elaborate more on that particular point beyond "I get the right results as written, but removing that case gives the wrong one".
21:27:17 <johnw> insEdges [...] (insNodes [...] empty)
21:27:17 <codygman> johnw: Alright, I'll check out the docs again and see if they resonate with me after coming back to them
21:27:50 <johnw> then you can dfs or bfs to get the nodes in some order, and use context, or query, to look at the successors and predecessors
21:28:18 <andromeda-galaxy> codygman: okay, hmm. I'm not quite sure whether or not that code is exactly what you were hoping for though
21:28:34 <andromeda-galaxy> (q: does this work: getRevDeps = concatMap (concatMap getRevDeps . getRevDep)
21:28:38 <andromeda-galaxy> )
21:28:46 <andromeda-galaxy> codygman: ^
21:29:06 <andromeda-galaxy> (assuming the idea  is that getRevDeps "a" gives the transitive dependencies of a, where getRevDep gives the immediate ones
21:31:19 <codygman> andromeda-galaxy: Expected type: [Char] -> [b]; Actual type: [[Char]] -> [b]
21:31:28 <andromeda-galaxy> oops sorry hang on one second
21:32:47 <andromeda-galaxy> codygman: I means concatMap getRevDeps . getRevDep
21:33:30 <andromeda-galaxy> oh wait I see why that won't work
21:33:30 <andromeda-galaxy> nvm
21:33:51 <Welkin> isn't concatMap just >>=?
21:33:58 <Welkin> :t concatMap
21:33:59 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
21:34:04 <Welkin> :t (>>=)
21:34:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:34:09 <Welkin> er
21:34:12 <Welkin> :t (=<<)
21:34:13 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:34:40 <andromeda-galaxy> Welkin: it works on inputs that are traversable not monad maybe? also I usually figure if there is a well named alias for bind, might as well use it
21:34:51 <codygman> johnw: Embarassingly enough it seems my issue not understanding fgl was not remembering what edges were :S
21:35:04 <johnw> do you know now?
21:35:08 <Welkin> I'd love to use graphs more often
21:35:15 <Welkin> I never have a use case for them
21:35:22 <codygman> johnw: The links between nodes I believe
21:35:27 <EvanR> everythings a graph!
21:35:31 <johnw> nodes are just numbers, and edges are just pairs of numbers
21:35:33 <andromeda-galaxy> codygman: do you care that the output is bfs and not dfs
21:35:44 <Welkin> it's almost always Map/Set or Array/Sequence
21:35:56 <johnw> the "meaning" is that nodes [1,2] and edges [(1,2)] is a graph of two points with a directional line between them
21:36:13 <johnw> i use fgl quite a lot, but usually for analyzing programs
21:36:29 <codygman> andromeda-galaxy: Yes, I have an application that has dependencies. Basically I'm using this to find all reverse dependencies and then signal when the entire chain has completed.
21:36:30 <EvanR> theres a lot more out their the objects and arrays
21:36:35 <EvanR> than
21:36:37 <EvanR> there
21:37:03 <codygman> johnw: Thanks, that simple visualization helps quite a bit.
21:37:18 <andromeda-galaxy> codygman: ah okay. if it does work with dfs instead then the "obvious" HOF version of getRevDeps is probably concatMap (\x -> x:getRevDeps x) . getRevDep
21:37:29 <andromeda-galaxy> but that makes ["b","c","f","d","g","e"]
21:37:29 <johnw> codygman: fgl allows you to place arbitrary "labels" on both nodes and edges, which is how you associate real information with the graph elements
21:38:17 <andromeda-galaxy> (but yeah, listen to johnw, fgl is the right thing to use)
21:38:47 <codygman> andromeda-galaxy: I don't mind the order, I end up just doing: all (== Done) . map getAppStatusByName $ ["b","c","f","d","g","e"] anyway
21:39:36 <andromeda-galaxy> codygman: do you mean by that that you hardcoded the dependencies in?
21:40:41 <andromeda-galaxy> but anyway I think the snippet I tossed up a minute ago is a reasonable answer to "what's a HOF way of finding transitive revdeps given this thing"
21:40:51 <andromeda-galaxy> if you want pointfree you can use uncurry () . (id &&& getRevDeps) instead of the lambda
21:41:04 <codygman> andromeda-galaxy: No, I was meaning to imply the code used to generate the ["b","c","f","d","g","e"] is getRevDepsByName "a", so the full code would be: all (== Done) . map getAppStatusByName $ getRevDepsByName "a"
21:41:20 <andromeda-galaxy> oh I see that makes more sense
21:41:25 <andromeda-galaxy> how did you impleent getRevDepsByName?
21:41:50 <andromeda-galaxy> (it sounds like maybe the same as my getRevDeps?)
21:42:02 <codygman> andromeda-galaxy: concatMap (\x -> x: getRevDeps' x) . getRevDep -- ;)
21:42:36 <andromeda-galaxy> cool, I'm glad if my commentary could push you on the right track ;-)
21:43:24 <codygman> johnw: I almost wish the dependency chains I was dealing with were large enough to nudge me a bit more to learn/use fgl... the library looks awesome. Time is limited though :/
21:43:38 <codygman> andromeda-galaxy: Yep, that will work for me. Thanks!
21:43:44 <johnw> codygman: tell me what you want, and I'll code it for you
21:43:49 <andromeda-galaxy> np!
21:44:04 <johnw> for data input, DOT files is pretty ideal
21:44:08 <johnw> if you don't already have a format
21:44:42 <codygman> well, I have a response from chronos which is in csv format. One second I can give a sample.
21:45:04 <johnw> i'll leave the input parsing to you, just tell me the type of the analysis function you want
21:45:17 <johnw> and how its output should relate to its input
21:48:43 <halogenandtoast> Crazy question if anyone knows Spock (or Scotty, or Wai) If I want to have my server handle multiple domains which might have different TLS certs, is that possible
21:49:04 <codygman> johnw: I'm unsure how to describe it. Perhaps this is enough. The csv data I parse turns into: [("Node","app-name1"),("Node","app-name-2"),("Link", "app-name1", "app-name2")]
21:49:04 <halogenandtoast> I haven't messed with SSL at all with these and I don't want to dig a big hole if all I'm going to find is dead bodies.
21:49:21 <andromeda-galaxy> halogenandtoast: I'm 99% sure that WAI can handle SNI...
21:49:23 <johnw> codygman: ok, that works
21:49:30 <johnw> codygman: and you just want reverse dependency order
21:50:12 <codygman> johnw: In that case I would only want app-name-2, but frequently there are many links for a single node. Yes, reverse dependency order. Thanks!! :)
21:50:13 <johnw> I assume it's [("Link", ["app-name1", "app-name2"])]
21:50:29 <johnw> ok, give me a few mins
21:50:32 <codygman> johnw: Yes, you are correct. I'm sorry.
21:50:34 <halogenandtoast> andromeda-galaxy: I'm gathering that as well.
21:50:36 <halogenandtoast> hmm
21:51:46 <halogenandtoast> I suppose my question is whether or not it's possible to use multiple certs depending on the domain coming in.
21:52:33 <andromeda-galaxy> isn't that the point of SNI? On each domain, you can serve the correct cert before the HTTP part of the connection gets going
21:53:07 <Lokathor> so if I pick the Lazy StateT to start, will that somehow bite me hard later?
21:53:32 <halogenandtoast> andromeda-galaxy: sorry I read "can handle SSL"
21:54:36 <johnw> codygman: ok to use lens, or no?
21:54:53 <andromeda-galaxy> although warp-tls may not be supporting sni as well as the underlying tls library does
21:57:20 <andromeda-galaxy> halogenandtoast: keter apparently supports SNI now (https://github.com/snoyberg/keter/pull/144)so I would surmise ti is porbably possible... not sure exacty how though, sorry
21:58:12 <halogenandtoast> andromeda-galaxy: thanks for looking into it. This is at least a good start.
22:00:58 <codygman> johnw: Yes to lens
22:01:03 <johnw> nice
22:01:40 <codygman> johnw: I *think* I have a pretty good handle on lens, I use it pretty often for json parsing.
22:02:05 <codygman> and Prisms for AST's
22:02:47 <andromeda-galaxy> halogenandtoast: one other thing btw: Network.TLS supports sending Credentials based on the HostName freceived via SNI (look at ServerHooks in Network.TLS). But warp-tls doesn't support it, so you would have to use runSettingsConnection yourself and manually handle setting up the TLS
22:06:15 <halogenandtoast> andromeda-galaxy: seems complicated, but I'll have to give it a shot
22:06:55 <halogenandtoast> I wonder if I should just use a reverse proxy with nginx
22:07:00 <johnw> codygman: ok, done
22:07:21 <halogenandtoast> that way my app doesn't care.
22:07:37 <johnw> codygman: https://github.com/jwiegley/notes/blob/master/haskell/Codygman.hs
22:07:49 <johnw> probably nicer ways to do it, but that's the first approximation
22:07:52 <andromeda-galaxy> halogenandtoast: it's a ltitle bit nasty, but probably not *too* bad... you can probably copy most of runTLSSocket and runTLSSocket'
22:07:55 <Welkin> halogenandtoast: doesn't care about what?
22:08:02 <johnw> as you can see, the graph construction and deconstruction is really the least of it
22:08:10 <halogenandtoast> Welkin: doesn't care about the SSL certificate.
22:08:15 <Welkin> you could use nginx for that, but I use keter
22:08:16 <andromeda-galaxy> Welkin: halogenandtoast is writing a webapp that needs to serve on multiple domains with SNI
22:08:24 <Welkin> keter is pretty easy to set up
22:08:38 <codygman> johnw: Cool! Taking a look now
22:08:44 <halogenandtoast> Welkin: Yeah I'm looking in to Keter, I have to convince my infra team to use it though.
22:08:44 <andromeda-galaxy> nginx reverse proxies, keter now supports SNI, also the app code could set it pu itself, which is what I was pointing halogenandtoast at possibilities for
22:09:25 <andromeda-galaxy> johnw: niiiice...
22:09:32 <halogenandtoast> Oh btw Welkin I think I asked you about 301 redirects the other day...
22:09:37 <Welkin> yes
22:09:40 <halogenandtoast> I solved it
22:09:54 <Welkin> using wai or some spock builtin?
22:09:55 <halogenandtoast> https://github.com/halogenandtoast/mirin/blob/master/app/Main.hs#L77
22:10:24 <Welkin> okay
22:10:33 <Welkin> that looks like basically the same as responseLBS
22:11:03 <halogenandtoast> Yeah, I just couldn't figure out how to make responseLBS play nice.
22:11:34 <halogenandtoast> Probably similar, but I didn't find this code too troublesome
22:11:39 <halogenandtoast> Fairly easy to understand
22:12:09 <halogenandtoast> Welkin: I'm going to try keter for a personal application.
22:12:12 <Welkin> I didn't know Spock had those wrapper functions
22:12:19 <Welkin> that's similar to yesod as well
22:13:14 <halogenandtoast> Welkin: it's one of those things that made me remember why I occasionally love monads.
22:13:41 <halogenandtoast> I mean, if I knew better, I'd probably love them all the time.
22:14:01 <halogenandtoast> but I'm dumb and sometimes we fight a lot.
22:14:27 <Lokathor> @pl (\di -> return $ convertRGBA8 di)
22:14:27 <lambdabot> return . convertRGBA8
22:14:29 <Welkin> https://github.com/snoyberg/keter/blob/master/README.md
22:14:37 <Welkin> I found that helpful (along with the examples linked in there)
22:14:52 <halogenandtoast> I spent 10 minutes this morning trying to show off random numbers in ghci and I did let gen = newStdGen; print $ take 5 (randoms gen)
22:15:30 <halogenandtoast> I couldn't understand the error "No instance for (RandomGen (IO StdGen))"
22:15:33 <codygman> johnw: Oh wow, that's cool. Alright, guessing that context just gets the label?
22:15:39 <johnw> yeah
22:15:49 <johnw> and the map is because you can't lookup nodes from their label
22:15:53 <halogenandtoast> Welkin: yup I'll follow along, I have a simple Yesod app I have on digital ocean
22:15:55 <c_wraith> halogenandtoast: mostly that means you've got an extra IO in there.
22:16:08 <c_wraith> halogenandtoast: oh, you've probably figured it out now. :)
22:16:08 <halogenandtoast> c_wraith: right, I realized the problem eventually
22:16:29 <halogenandtoast> c_wraith: It was silly because I wrote the example in a hs file and ran runhaskell to show it working
22:16:32 <halogenandtoast> and blamed ghci
22:16:40 <halogenandtoast> When I wrote the hs file, I did it correctly.
22:17:27 <Welkin> I tried to write a recursive fibonacci generator in purescript before remembering that purescript is strictly evaluated, so it exhausts the stack space
22:17:39 <halogenandtoast> ha oh no
22:17:59 <halogenandtoast> I've awarded myself some points for understanding your problem.
22:18:25 <Welkin> I take laziness for granted it seems
22:18:35 <halogenandtoast> It's a wonderful thing.
22:18:42 <johnw> codygman: even better would be to use freer-effects, but I figured that would be pushing it :)
22:18:51 <johnw> that's one of my new favorite libraries
22:18:52 <halogenandtoast> Alright, time to try out Keter.
22:20:33 <Rotaerk> hmm, now instead of partial pipe transformers, like... (i -> Maybe i') -> Pipe i' o m r -> Pipe i o m r -> Pipe i o m r
22:20:52 <Rotaerk> and:  (i -> Maybe i') -> Consumer i' m r -> Pipe i o m r
22:21:46 <Rotaerk> I'm considering something more like:  (i -> DSum k Identity) -> DMap k SomePipeFrom -> Pipe i o m r
22:21:57 <Rotaerk> not really sure how that type should look exactly though
22:22:23 <Rotaerk> as in, the first function picks (via tagging) which pipe to pump it through
22:22:38 <Rotaerk> each pump can have different input, but must all produce the same output (o)
22:22:59 <Rotaerk> though maybe the partial way is better, simpler...
22:23:53 <johnw> I've heard so many sentences begin that way... ;)
22:24:14 <Rotaerk> which way
22:24:23 <johnw> maybe the partial way is better, simpler
22:24:31 <Rotaerk> oh :P
22:24:58 <Rotaerk> I think *using* the one with DMap might be nicer
22:25:13 <Rotaerk> maybe >_>
22:29:08 <Rotaerk> nah, would have to make a tag type for every use
22:29:14 <Rotaerk> even if I could get the type signature right
22:29:48 <c_wraith> you could make a single GADT tag type instead..  :P
22:33:00 <halogenandtoast> c_wraith: thanks for reminding me that I still don't know why I use the GADT extension
22:33:05 <halogenandtoast> reading https://wiki.haskell.org/GADTs_for_dummies now
22:34:15 <c_wraith> halogenandtoast: the key idea is that a GADT allows you to add more restrictions to the type of a data constructor, and recover that information when you match the constructor.
22:34:26 <johnw> One thing that GADTs allow you to do is to qualify constructors
22:34:38 <johnw> yeah, what c_wraith said
22:35:07 <nshepperd> hmm, Data.Bits has an Eq constraint
22:35:11 <johnw> like, you could have constructor that are only allowed while a system is initializing, and others that can only happen after its done initializing
22:35:21 <nshepperd> a holdover from the Eq a => Num a days?
22:35:33 <nshepperd> I can't use it in my eDSL like that :(
22:36:40 <Rotaerk> c_wraith, well, what I was thinking is that I would do something like...  split (\case { Foo x -> ToFooPipe :=> Identity x; Bar y -> ToBarPipe :=> Identity y })
22:37:19 <halogenandtoast> c_wraith: I have no idea what that means yet, but soon :tm
22:37:21 <cocreature> nshepperd: I guess you could argue that they should be equal when all Bits are equal
22:37:32 <Rotaerk> and then the next parameter would somehow be a DMap associating ToFooPipe with a Pipe expecting the type of the x, and ToBarPipe with a Pipe expecting the type of y
22:37:40 <Rotaerk> and thus routing each value to the right pipe
22:37:41 <kadoban> nshepperd: Does it have an infinite number of bits or something? Can't think what other cases Eq wouldn't make sense on
22:38:13 <cocreature> kadoban: as soon as your type does not _only_ consist of bits and includes things like functions it can‚Äôt be Eq
22:38:34 <kadoban> Oh, right
22:38:38 <nshepperd> cocreature: well, the problem is that testBit and popCount are in there really
22:39:27 <nshepperd> you can't test the bits of an expression with free variables, even though all the 'productive' bitwise operations are applicabl
22:40:40 <nshepperd> this is like the difference between Num and Integral/Real
22:41:00 <codygman> Am I missing something, or can Data.Time.Format not parse this date with it's current formatters? 2014-03-08T16:57:17.507Z
22:41:30 <glguy> it can parse that
22:41:33 <cocreature> nshepperd: yeah splitting this up would have been nice
22:42:35 <cocreature> codygman: what problems are you running into?
22:46:39 * hackage hackernews 1.1.2.0 - API for Hacker News  https://hackage.haskell.org/package/hackernews-1.1.2.0 (DavidJohnson)
22:50:15 <codygman> cocreature: Well I *think* the 507Z in 2014-03-08T16:57:17.507Z is picoseconds or the %q modifier, but I don't think it supports modifying the length and only allows 12 characters of picosecond. I could be wrong on both counts.
22:50:20 <glguy> iso8601DateFormat (Just "%T%Q%Z")
22:50:20 <glguy> "%Y-%m-%dT%T%Q%Z"
22:51:16 <cocreature> codygman: it‚Äôs %Q not %q
22:51:32 <mniip> not nano?
22:53:44 <codygman> glguy, cocreature: Yep, this worked: parseTimeM True defaultTimeLocale "%Y-%m-%dT%T%Q%Z" "2014-03-08T16:57:17.507Z" :: Maybe LocalTime
22:54:25 <codygman> or using the iso8601DateFormat function: parseTimeM True defaultTimeLocale (iso8601DateFormat (Just "%T%Q%Z")) "2014-03-08T16:57:17.507Z" :: Maybe LocalTime
22:54:27 <glguy> With the Z on the end it's meant to be a ZonedTime
22:54:57 <codygman> glguy: Oh, thanks. I didn't know. Well then here we go: parseTimeM True defaultTimeLocale (iso8601DateFormat (Just "%T%Q%Z")) "2014-03-08T16:57:17.507Z" :: Maybe ZonedTime
22:55:55 <codygman> thanks for the help everyone, good night! :)
22:55:56 <halogenandtoast> Is there a Keter plugin for Hedis?
22:59:48 <halogenandtoast> or a suggested path for adding a redis instance to my application.
23:00:54 <EvanR> does ~ ever do anything in let ~(Ctor p1 p2 p3) = expr in expr2 do anything
23:01:10 <EvanR> er minus the last two words
23:01:23 <johnw> it defers the deconstruction
23:01:32 <johnw> until you evaluate any of p1 p2 or p3
23:01:33 <EvanR> but...
23:01:43 <glguy> No, it doesn't do anything in a let binding
23:01:43 <EvanR> > let Just x = Nothing in 5
23:01:45 <lambdabot>  5
23:01:49 <EvanR> ok
23:01:52 <johnw> oh, nothing in let?
23:02:13 <EvanR> so let is always lazy
23:02:18 <EvanR> without bang
23:03:18 <c_wraith> yes.  let/where bindings are lazy.  case/lambda/function pattern bindings are strict
23:03:54 <EvanR> lambda is strict even though you dont get a choice?
23:04:10 <glguy> ~ is meaningful in let bindings when not used at the outer-most pattern
23:04:11 <glguy> > let (x,~(y,z)) = ((),undefined) in x
23:04:13 <lambdabot>  ()
23:04:15 <glguy> > let (x,(y,z)) = ((),undefined) in x
23:04:18 <lambdabot>  *Exception: Prelude.undefined
23:04:28 <EvanR> oh geez
23:04:29 <cocreature> how can I link to headings created via "-- * name" in the export list of a module?
23:04:47 <glguy> EvanR: I don't understand your question about lambda, though.
23:05:23 <EvanR> the top most pattern in a let doesnt need to be checked now, since theres only one thing it could be without being an error, you can defer it
23:05:24 <mniip> he says that since you have only one pattern it would make sense to make it irrefutable
23:05:28 <EvanR> might as well be lazy
23:06:00 <EvanR> > (\(Just x) -> 4) Nothing
23:06:02 <lambdabot>  *Exception: <interactive>:3:2-15: Non-exhaustive patterns in lambda
23:06:06 <Lokathor> i wish there was a way to derive a Show instance with any non-show data being replaced with just the fieldname
23:06:06 <EvanR> > (\~(Just x) -> 4) Nothing
23:06:08 <lambdabot>  <hint>:1:13: error: parse error on input ‚Äò->‚Äô
23:06:12 <EvanR> urg
23:06:28 <glguy> The binding of a lambda and the one in a let also differ in how they generalize
23:06:30 <mniip> > (\(~(Just x)) -> 4) Nothing
23:06:33 <lambdabot>  4
23:06:53 <glguy> > (\ ~(Just x) -> 4) Nothing
23:06:54 <MarcelineVQ> > (\ ~(Just x) -> 4) Nothing -- space
23:06:55 <lambdabot>  4
23:06:56 <lambdabot>  4
23:08:52 <mniip> oh yes
23:09:14 <mniip> > let (\~) = (+) in 1 \~ 2
23:09:16 <lambdabot>  3
23:09:24 <mniip> makes sense
23:09:34 <EvanR> you can write perl in any language!
23:09:46 <mniip> not in perl
23:10:33 <EvanR> i just noticed a situation where i looped unless i put ~ on arguments to a function which were unwrapping a newtype ctor
23:10:44 <EvanR> but thats all it unwrapped
23:11:21 <EvanR> it seems like you can be lazy for free in that situation
23:11:54 <EvanR> oops not a newtype, a record
23:11:55 <mniip> perhaps you had some more matching inside?
23:12:04 <EvanR> no just variables for the 3 fields
23:12:18 <mniip> then it's not a newtype
23:12:22 <EvanR> so not even the underhead of newtype
23:12:37 <EvanR> theres only one thing a record could be...
23:12:48 <mniip> errr no
23:12:59 <mniip> you can write newtype records
23:13:04 <mniip> and newtype gadts
23:13:19 <EvanR> a one constructor product type
23:13:29 <mniip> shame you can't write Dict as a newtype but I had a proposal for that somewhere
23:13:54 <glguy> I don't think you can have a newtype GADT
23:13:54 <EvanR> seems like a situation where "just be lazy dont worry about it"
23:14:12 <EvanR> even do it by default like the let is
23:14:32 <mniip> @let newtype G a where C :: Char -> G Int
23:14:33 <lambdabot>  .L.hs:171:9: error:
23:14:34 <lambdabot>      ‚Ä¢ A newtype constructor must have a return type of form T a1 ... an
23:14:34 <lambdabot>        C :: Char -> G Int
23:14:47 <mniip> oh right, ofc, constraints
23:15:14 <mniip> I guess you are kinda correct then, you can't write a non-regular datum as a newtype gadt
23:15:23 <glguy> right
23:15:53 <glguy> EvanR: Even though a data type might only have one constructor, that doesn't mean you don't have to allocate the value for that case, or that it might not be a thunk in need of evaluation
23:16:01 <mniip> assuming RankN and Existential though
23:16:29 <mniip> EvanR, you're using record newtypes all over the place actually
23:16:32 <mniip> Identity, Compose,
23:16:35 <mniip> most of mtl
23:16:45 <glguy> Existentials+newtype don't help with the contexts
23:16:59 <glguy> But you can newtype a polymorphic type with RankNTypes
23:17:09 <mniip> @let newtype N = N (forall a. a)
23:17:11 <lambdabot>  Defined.
23:17:21 <mniip> @let newtype N' = forall a. N' a
23:17:22 <lambdabot>  .L.hs:172:14: error:
23:17:22 <lambdabot>      ‚Ä¢ A newtype constructor cannot have existential type variables
23:17:22 <lambdabot>        N' :: forall a. a -> N'
23:17:29 <mniip> okee
23:18:15 <mniip> never studied the formal rules, I've always just kinda grokked the representation thing
23:34:51 <hanna> Style question: What's a good way to layout the definition of a record type with alternatives (multiple constructors)?
23:37:25 <hanna> Right now I'm doing this but it looks kinda wanky: https://0x0.st/EOq.txt
23:37:40 <johnw> pretty much how I'd do it
23:37:55 <kadoban> Records with multiple constructors aren't usually a good idea, as far as I understand. All of the record access functions are partial
23:37:55 <cocreature> another option is to extract the record parts in separate types
23:38:33 <cocreature> i.e., make a record type Foo and then use data FooBar = Foo Foo | ‚Ä¶
23:39:27 <cocreature> but that can be annoying
23:41:02 <hanna> kadoban: that's fair, but I'm only using them for record-style constructors and deconstructors
23:41:05 <hanna> Not access
23:47:33 <thang1> So... Got a question
23:47:51 <thang1> Is there a nice easy way to filter a bunch of things from something?
23:48:41 <cocreature> thang1: like "filter"?
23:48:44 <thang1> To be specific, it'd be really nice to be able to type something like "filter (contains vowels) "sentence" " and get the result "sntnc"
23:49:13 <thang1> Sure, I know how to use filter, but it only works for one thing. So I can filter all the 'a's out of a sentence, but then I have to chain 5 different filters to get all the vowels out
23:49:32 <cocreature> > filter (`elem` "aeiou") "sentence"
23:49:34 <lambdabot>  "eee"
23:49:40 <cocreature> eh that was the wrong way around
23:49:42 <cocreature> but you get the idea
23:49:53 <cocreature> > filter (not . (`elem` "aeiou")) "sentence"
23:49:55 <lambdabot>  "sntnc"
23:50:46 <EvanR> thang1: you can combine many conditions into one function by using Monoid
23:51:07 <EvanR> two monoids actualy
23:51:44 <EvanR> but chaining multiple filter f .'s is probably simpler
23:51:52 <thang1> ‡≤†_‡≤† I'm an idiot
23:52:05 <thang1> I was totally overcomplicating that greatly in my head lol, thanks
23:52:06 <sternmull> I would like to do "newtype Foo = forall a. Show a => Foo a". But GHC says "A newtype constructor cannot have a context in its type". It works when i replace newtype with data.
23:52:08 <cocreature> thang1: we all are from time to time :)
23:52:09 <EvanR> :t filter even . filter (< 4)
23:52:11 <lambdabot> Integral a => [a] -> [a]
23:52:27 <thang1> I was doing some stuff like filter (elem x "aeiou") and it kept being annoying
23:56:53 <sullyj3> is there a builtin version of this: interactLine f = getLine >>= (putStrLn . f)
23:57:03 <johnw> sternmull: newtype Foo = Foo (forall a. Show a => a)
23:58:17 <nshepperd_> sternmull: yeah, new type constructors have no runtime representation, so there would be nowhere to store the Show dictionary
23:58:58 <sternmull> johnw: Thanks, that works. Needs RankNTypes but thats ok for me.
23:59:59 <nshepperd_> I don't know if what johnw wrote is what you want, because that is a different thing (a universal rather than an existential)
