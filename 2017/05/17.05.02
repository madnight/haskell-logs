00:00:47 <mivael_> The question is how to write code which would run on both environments (e.g. bytestring-0.10.0.2 and bytestring-0.10.8.1)?
00:01:15 <vaibhavsagar_> {-# LANGUAGE CPP #-}
00:01:47 <mivael_> vaibhavsagar_: #ifdef ?
00:02:08 <vaibhavsagar_> yeah, that's what I was thinking
00:02:32 <vaibhavsagar_> I've never used it before, so I can't be of more help than that
00:02:36 <mivael_> vaibhavsagar_: what identifiers I could check with #ifdef?
00:02:44 <mivael_> vaibhavsagar_: ah, okay
00:03:13 <vaibhavsagar_> https://guide.aelve.com/haskell/cpp-vww0qd72#item-qxhl6vk6
00:03:36 <vaibhavsagar_> miavel_: you can check the version of bytestring you have available
00:04:19 <mivael_> vaibhavsagar_: the post you mentioned seems to be cabal-dependent
00:05:07 <vaibhavsagar_> no, you can do the #if MIN_VERSION_bytestring(<version>) check in a source file
00:05:39 <vaibhavsagar_> the post indicates that Cabal automatically generates macros for you
00:05:50 <mivael_> vaibhavsagar_: thanks, I'll try
00:06:13 <quchen> mivael_: Look for »cabal*.h«, it’s the file that defines the macros
00:06:47 <quchen> cabal_macros.h
00:07:27 <mivael_> quchen: I can not rely on assumption that my code will be built with cabal
00:07:36 <quchen> What else?
00:07:56 <mivael_> quchen: just ghc
00:08:14 <mivael_> vaibhavsagar_: It still seems to be cabal dependent: "Cabal automatically generates macros (MIN_VERSION_<library>) for all libraries your project depends upon."
00:10:23 <mivael_> quchen: like this: ghc ... -o 'hs.exec' file.hs  &&  ./hs.exec
00:14:24 <vaibhavsagar_> mivael_: how would your user make bytestring available to ghc?
00:17:12 <Lokathor> https://hackage.haskell.org/package/base-4.9.1.0/docs/System-Timeout.html
00:17:16 <Lokathor> this doesn't work with getLine
00:17:18 <Lokathor> such sadness
00:22:41 <mivael_> vaibhavsagar_: for example, by using haskell platform installed by means of an operating system
00:22:49 <cocreature> Lokathor: huh, I would have expected that getLine goes through the standard GHC IO manager so it should work
00:23:34 <vaibhavsagar_> mivael_: can you check the GHC version?
00:24:01 <mivael_> vaibhavsagar_: The Glorious Glasgow Haskell Compilation System, version 7.6.3
00:24:03 <Lokathor> cocreature, ACTUALLY, maybe it's cause i tried in ghci? which never runs in threaded mode?
00:24:10 <vaibhavsagar_> no, I mean in your script
00:24:31 <vaibhavsagar_> I think Cabal might not generate your macros
00:24:50 <vaibhavsagar_> as in, you'd have them available even if you don't use Cabal
00:25:02 <cocreature> Lokathor: I’ve just tried it outside of ghci and it works just fine
00:25:09 <mivael_> vaibhavsagar_: which script?  you mean me *.hs source code?
00:25:15 <vaibhavsagar_> yup
00:25:18 <mivael_> s/me/my/
00:25:18 <cocreature> Lokathor: but it also works in ghci for me
00:25:24 <cocreature> not sure what’s causing problems for you
00:25:26 <vaibhavsagar_> nvm, just throwing ideas out there
00:25:44 <Lokathor> cocreature, I'm sure the answer somehow boils down to "haskell on windows"
00:26:48 <cocreature> Lokathor: ah right, ghc’s io manager on windows doesn’t properly support nonblocking IO iirc. afaik Phyx is working to change that for ghc 8.4
00:27:49 <Lokathor> .4? yikes that sounds far off
00:39:42 <kadoban> 8.2 is soonish I think, so it's probably not that long.
00:46:20 <cocreature> 8.4 should be in about a year
00:59:21 <dysfun> ooh, 8.4 is when they think we'll get linear types
00:59:37 <dysfun> i have some use cases in mind for them
01:02:27 <mivael_> vaibhavsagar_: error: missing binary operator before token "("
01:02:38 <mivael_> vaibhavsagar_: error: missing binary operator before token "("
01:02:49 <mivael_> vaibhavsagar_: #if MIN_VERSION_bytestring(0,10,0)
01:03:03 <mivael_> (sorry for the duplicate)
01:04:38 <mivael_> vaibhavsagar_: seems that MIN_VERSION_* are not defined if building without cabal
01:05:04 <geekosaur> correct
01:05:05 <vaibhavsagar_> good to know, thanks mivael!
01:05:14 <vaibhavsagar_> *mivael_
01:09:50 <mivael_> geekosaur: do you happen to know a cabal independent way to write code which would work with old and new bytestring API?
01:10:52 <geekosaur> no, we're pretty dependent on cpp and the Cabal library's use of it
01:11:27 * geekosaur is ... not fond of this; the problems with cpp on OS X and *BSD are a good example of why
01:11:47 <geekosaur> and general problems with ' and # which behave differently in C, so cpp gets confused
01:12:18 <geekosaur> backpack in 8.2 would get away from the cpp, but still require the Cabal library as I understand it
01:12:56 <mivael_> backpack?
01:14:25 <geekosaur> https://github.com/ezyang/thesis/releases
01:14:39 <mivael_> geekosaur: I guess I'm not experienced enough with ghc preprocessor usage and cabal to understand most of what you said :)
01:18:54 <yushyin> still all extensions and very compiler dependent, would like to see some of this newer stuff in haskell prime.
01:20:24 <geekosaur> I'd care more if there were an alternative compiler on the horizon, instead of a trail of dead ones...
01:48:39 <jchia> How can I make a new regular Vector out of an IOVector?
01:50:18 <jchia> I think I can use create
02:04:08 <tsahyt> jchia: freeze?
02:20:13 <jchia> tsahyt: Yeah, that worked. I was confused by box-vs-unboxed and generic when looking up the docs.
02:42:13 <jchia> How can I convert an unboxed vector to a boxed vector? I need to zip a boxed vector with an unboxed vector, so it seems that I need to do the conversion first. Is there a better way than calling toList and then fromList?
02:43:28 <Taneb> jchia, there's the "convert" function
02:43:35 <Taneb> convert :: (Vector v a, Vector w a) => v a -> w a
02:43:45 <Taneb> It'll convert from an unboxed vector to a boxed vector
02:44:04 <jchia> Taneb: Thanks
02:44:09 <pacak> convert
02:46:49 <pacak> How would you go about writing an AST for transformation of json (aeson) values? Transformations similar to "in top level object under key 'foo' replace it's value which is [[Double]] with [Double] which is least of means and remove all other top levevel object keys except for 'foo' and 'bar'"?
02:50:31 <vaibhavsagar_> pacak something like jmespath: http://jmespath.org/?
02:51:56 <pacak> vaibhavsagar_: Seems interesting
02:51:59 <pacak> thanks
02:52:29 <vaibhavsagar_> there's also jq: https://stedolan.github.io/jq/
02:55:40 <pacak> vaibhavsagar_: Not quite what I want, but syntax might be interesting.
02:55:59 <pacak> I want to generate transformations from javascript and apply them in haskell
03:04:05 <vaibhavsagar_> like a virtual dom thing?
03:06:00 <pacak> Not quite. I have a bunch of data and I want to make queries on that data. Fetching in all and doing on javascript side is slow
03:13:04 <manek> Hi! I've got a structure `data A = A { _i :: Maybe Int , _b :: B}; data B = B { _val :: Map Int A }` and I want to define instance of At for B. I can write lens `at s = val . at s . non (A mempty mempty) . b`, however it does not return value in Maybe, but is close to what I want to get
03:13:10 <manek> Is it a good approach ?
03:34:26 <Giulia> Is there a specific channel for Jobs ? 
05:27:31 <Axman6> pacak: the lens-aeson package can give you a lot of useful operations for doing that sort of thing, it wouldn't be hard to build up all of the Value -> Value transformations you want
05:28:17 <Axman6> (Or is it aeson-lens... whichever was written by Ed Kmett)
05:29:36 <pacak> Hmm...
05:30:51 <pacak> My problem is not doing transformation themselves but encoding them as a string.
05:32:30 <pacak> I wonder...
05:32:57 <superlinux> hey all
05:33:07 <superlinux> how are you?
05:33:24 <pacak> o/
05:33:27 <pacak> Still alive.
05:34:02 <ph88_> davean present ?
05:34:55 <pacak> Cale: That was fun. https://github.com/tibbe/unordered-containers/issues/147 and https://ghc.haskell.org/trac/ghc/ticket/13615
05:35:13 <superlinux> I just want to tell Arabs in #haskell that there is a Facebook group for Arabs who want to learn Haskell they are already Haskellers
05:35:21 <bartavelleT> pacak: yeah, nice bug reduction !
05:35:27 <superlinux> *or they are
05:36:29 <Giulia> Hey , is there a specific channel for jobs=
05:36:31 <Giulia> ?
05:39:11 <cocreature> quchen: should I expect any blocking issues when I try to use your pretty printer or is it ready and you’re only waiting until you become a maintainer?
05:39:53 <quchen> cocreature: There are no known issues.
05:40:00 <cocreature> quchen: great, thanks!
05:40:16 <quchen> cocreature: I’ve used it multiple times in my own project, I benchmarked it, the doctest suite should be quite extensive.
05:40:22 <Rembane> Giulia: Try here. If it becomes a too long discussion it might be advisable to move to "haskell-offtopic
05:40:24 <quchen> s/project/projects/
05:40:31 <cocreature> perfect
05:40:48 <quchen> cocreature: I’m still not sure whether I want to provide an annotated Doc type or not.
05:41:31 <quchen> cocreature: So that might be the last breakage I’m putting in (compared to the version right now). I *will* maintain the compatibility modules with wl-pprint(-ansi) though, so that part won’t break.
05:41:44 <quchen> And nothing will break in a major way in either case.
05:41:59 <cocreature> some breakage is completely fine with me :)
05:42:08 <quchen> cocreature: If you’re concerned about performance, take note of the fuse function :-)
05:42:24 <cocreature> I couldn’t care less about performance :)
05:43:26 <quchen> Hm, okay. Then go ahead.
05:43:46 <quchen> cocreature: comments of any kind welcome! If the docs are unclear (or could be clearer) for exmaple
05:43:57 <quchen> Missing tests, better examples, whatever you have
05:44:30 <cocreature> quchen: the main reason I want to switch to your library is that the docs are significantly better than for the other libs :) so thanks for that :)
05:44:36 <quchen> Hmm, you can’t file issues because it’s a fork though :-(
05:44:40 <quchen> cocreature: :-)
05:44:45 <cocreature> quchen: you can enable issues on forks
05:44:51 <quchen> Oh!
05:45:08 <quchen> Cool! Done! Thanks!
05:46:13 <ph88_> i have a few functions with    (MonadResource m, MonadState StreamState m) =>    is there any way i can abstract this pattern ?
05:47:54 <pacak> ph88_: ConstraintKinds?
05:48:02 <quchen> ph88_: You can define your own constraint synonym, type Foo m = (MonadResource m, MonadState StreamState m)
05:48:03 <pacak> :kind Show
05:48:20 * pacak pokes lambdabot
05:48:32 <cocreature> quchen: can I convince you to export the semigroup version of <> instead of the monoid version?
05:48:37 <ph88_> oh that's nice :P
05:49:01 <quchen> cocreature: Oh, I missed that. Good point.
05:49:20 <quchen> cocreature: Breaks compatibility with older releases though, might require some CPP hackery, so it’s not a one-liner.
05:49:40 <quchen> I agree it’s better for newer releases though.
05:49:46 <cocreature> yeah, for now I’m just hiding it since I use a custom prelude that exports the semigroup version
05:51:23 <DrMentats> how does haskell manage to type check recursive definitions? say f uses g and g uses f, does it assume f :: a and g :: b before checking each and then do some sort of unification or what? I'm making a mini type checker and I can't find a good way to support this, and no tutorial I can find explains it
05:51:38 <DrMentats> no need for code, I just need a general algorithm
05:54:00 <piyush-kurur> DrMentats: the thing you are searching for is Hindley-Milner-Damas algorithm
05:54:08 <ph88_> why does syntax on line 1 and 2 work but line 4 fail when using the same functions?   https://bpaste.net/show/f2fa96906c6c
05:54:38 <piyush-kurur> although haskell adds some twist because of type classes and what not
05:55:13 <ph88_> quchen, do i need an extension for that? The ConstraintKinds ?
05:55:17 <quchen> DrMentats: Naive Hindley-Milner can’t typecheck recursive definitions, yes. I’ve seen papers discussing this specifically, but I can’t recall the details.
05:55:18 <DrMentats> piyush-kurur: I did implement it, but all I could do so far to chain declarations together is put them into nested Lets, like like a = ... in let b = ... in ..., but then they can't refer to previous declarations
05:55:21 <quchen> ph88_: Yes.
05:55:30 <DrMentats> s/like a/let a/
05:55:37 <quchen> DrMentats: I think maybe the Haskell Report has a section on this issue even.
05:55:46 <pacak> ph88_:  "NB: This instantiation can be caused by the monomorphism restriction."
05:56:09 <ph88_> ye i see that, but why does it work on line 1 and 2 without error
05:56:19 <piyush-kurur> DrMentats: if you have f refereing to g and g refering to f. it is like taking fixpoint of a pair
05:56:25 <pacak> ph88_: Because  on lines 1/2 it won't apply.
05:56:36 <ph88_> why the restriction doesn't apply there ?
05:57:09 <DrMentats> piyush-kurur: oh. that makes sense, actually. thanks, I'll try something on those lines.
05:57:10 <piyush-kurur> so if you work with fix point then it should be doable (Although I have not tried it yet)
05:59:08 <pacak> ph88_: Because there's a type signature for top level declaration
05:59:13 <pacak>  on line 4 - there is none.
05:59:49 <pacak> ph88_: http://img.pandawhale.com/94867-magic-gif-Shia-Imgur-MAH7.gif
06:00:02 <pacak> ph88_: Try disabling monomorphism restriction.
06:03:40 <piyush-kurur> DrMentats: no problem. Looks like the wikipedia entry has something to say about recursive type checking https://en.wikipedia.org/wiki/Hindley–Milner_type_system#Recursive_definitions
06:05:27 <quchen> cocreature: When was Monoid put into base again? 4.8.0.0?
06:06:32 <sophiag> i'm going through the wiki for the Lens library and the examples from Data.Text.Lens seem outdated. the type Text doesn't seem to be included and ^.packed throws an error. can anyone point me to what's changed with this?
06:07:21 <cocreature> quchen: are you talking about Semigroup? Monoid has been in base for ages
06:07:30 <DrMentats> piyush-kurur: beautiful. I wouldn't have thought that HM would support this out of the box like that.
06:07:36 <quchen> cocreature: Eh, in Prelude I mean
06:07:51 <cocreature> quchen: it’s not in the prelude
06:08:20 <quchen> cocreature: Yes it is, required for Foldable
06:08:25 <quchen> It’s since 4.8, looked it up
06:08:39 <cocreature> oh right, I thought you were talking about (<>)
06:08:42 <cocreature> that’s not in the Prelude
06:10:15 <quchen> Right
06:10:19 <asthasr> Anyone used the Python lenses library?
06:10:23 <osa1> it seems like `MonadCatch` is more general than `MonadBaseControl IO`, is there a reason to prefer Control.Exception.Lifted.catch (from lifted-base) to Control.Monad.Catch.catch (from exceptions) ?
06:11:15 <cocreature> osa1: I’m not sure about MonadCatch but MonadMask is _less_ general than MonadBaseControl IO as evidenced by the missing instance for ExceptT
06:14:13 <cocreature> osa1: the only MonadCatch instance I know that is not an instance of MonadBaseControl IO is Either and that’s not a particularly useful instance imho.
06:15:18 <osa1> cocreature: hmm it's interesting that there's an instance for MonadMask (Either e) but not for ExceptT
06:16:46 <cocreature> I don’t get why you would ever want the instances for Either that the exceptions package provides
06:17:57 <cocreature> the reason why there is no MonadMask instance for ExceptT is that due to the shortcircuiting behavior you can’t guarantee that the finalizer is run
06:18:36 <osa1> ahh right, `finally` can't work
06:18:40 <cocreature> I’m not even sure what it means for a finalizer of type Either a b to be run
06:20:03 <cocreature> I guess you can replace the exception
06:21:24 <osa1> btw I'm using lifted-base without any problems, I'm just curious about these two typeclasses (MonadCatch and friends vs. MonadBase and MonadBaseControl)
06:21:50 <cocreature> imho the main reason for using the “exceptions” package is that it’s easier to understand
06:23:18 <osa1> I guess if you don't need MonadMask you could keep MonadIO/IO out of your context/stack when yo uuse "exceptions"
06:25:44 <osa1> hmm that doesn't work too well though because only base instances for MonadCatch are STM, IO, Either e
06:25:46 <osa1> anyway
06:26:13 <cocreature> if you can keep IO outside of your code you should just use Either instead of exceptions :)
06:38:28 <quchen> Munich Haskell Usergroup created! Now Show Friends and Workmates! https://www.meetup.com/munich-haskell/events/239661133/
06:38:46 <shapr> yay!
06:41:53 * cocreature checks travel durations to munich
06:42:18 <cocreature> meh
06:44:27 <pacak> lens-aeson. Suppose I have "[{a:1,b:2,c:3,d:1},{a:10,b:20,c:30,d:1}", how do I get "[{a:1,b:2},{a:10,b:20}" - keep only a and b?
06:52:08 <quchen> cocreature: Where are you from?
06:52:43 <cocreature> quchen: Karlsruhe
06:53:11 <quchen> Hm, not too bad. Too far for a meetup, yeah
06:54:39 <quchen> cocreature: Zurich maybe? Or Freiburg? Or Munich, should we umm do something bigger maybe? :-)
06:54:52 <cocreature> quchen: I’ll be in zurich
06:54:58 <quchen> Cool! Me too
06:55:29 <cocreature> I think we actually met at zurihac 2015 although we didn’t talk a lot
06:55:58 <quchen> Hmm, could be. Did I know you were cocreature?
06:56:06 <cocreature> I don’t think so :)
06:56:29 <quchen> See, that’s why I write my nick on the name badge ;-)
06:56:44 <cocreature> yeah that’s probably a good idea
06:57:16 <xintron> I'm using persistent-mysql with an existing database and therefore skipping the migrations. Is there a way to still get a check that would warn (at runtime) if the internal data types differs from the database tables/columns using persistent?
07:09:00 <jchia_1> When I write a function, because of the other functions it calls, it may need certain things in its context, e.g. MonadResource m because of one function and MonadIO m because of another function. MonadIO m & MonadThrow m are prerequisites for MonadResource m. That means putting MonadResource m in the context is enough, but should I also include MonadIO m and MonadThrow m in the context for clarity?
07:11:32 <glguy> no, you don't need to include redundant constraints
07:12:26 <wz1000> Is it possible to run an IO action as a program with some stdin and stdout?
07:13:16 <MitchellSalad> yeah, main :)
07:16:24 <cocreature> wz1000: are you looking to supply stdin to some IO action and capture the stdout?
07:16:39 <m1dnight_> Hey guys, im trying to create a kind of unittest that reads in a file line by line (i.e., [String]) and then creates a unit test for each of these lines
07:16:45 <m1dnight_> but for the life of me I can't make the types check
07:17:02 <cocreature> m1dnight_: show us the source and the error :)
07:18:04 <wz1000> cocreature: Yeah
07:18:21 <quchen> cocreature: There you go, Semigroup <> https://github.com/quchen/prettyprinter/commit/02b5e7c2302bbf0c08a57c9bf5af32651e6e7275#diff-9996460ebf31daebeb1707e2777b9a33
07:18:26 <cocreature> quchen: thanks!
07:18:38 <cocreature> wz1000: for capturing stdout there is https://hackage.haskell.org/package/system-posix-redirect
07:18:40 <quchen> The change was quite small, but I had to wait for Travis :-)
07:18:48 <m1dnight_> https://hastebin.com/eholelugal.hs, cocreature 
07:19:11 <m1dnight_> So the thing is, I know that H.TestCase takes an IO action as argument
07:19:25 <m1dnight_> But I need to create one big test of tests and the IO action to read in the log file is hard to get into a test
07:19:44 <m1dnight_> so makeTests should read in the file, and then generate a test for each line in that particular log file.
07:19:56 <m1dnight_> (so I can easily spot which lines dont parse well yet, and fix that)
07:20:22 <m1dnight_> And as far as I can tell from the docs of HUnit, IO is only allowed in a TestCase
07:20:45 <m1dnight_> But since I want more than 1 assert (1 assert per line) I need to do IO outside of the H.TestCase, and in the H.TestList
07:20:52 <cocreature> m1dnight_: sounds like you need makeTests :: String -> IO H.Test
07:21:33 <shapr> m1dnight_: if you want to switch to HSpec, I have tests that read a file and use that for testing here: https://github.com/shapr/schrabble/blob/master/test/Spec.hs
07:22:04 <m1dnight_> cocreature: but then how can I turn a `IO H.Test` into a H.Test?
07:22:10 <m1dnight_> That's the particular annoyance here
07:22:45 <m1dnight_> shapr: ill give it a look. But Im going to be stubborn and try to solve this one first :D
07:23:07 <shapr> I liket that approach :-)
07:30:24 <cocreature> m1dnight_: you can’t. but you can push the IO up to a layer that can actually do IO, e.g., main
07:34:02 <EvanR> so doing a low rez sdl performance test... if i draw a 40x30 grid of sprites size 8x8 i get 30% cpu (with -O2)
07:34:34 <EvanR> if i draw the same grid by doing 20x15 16x16 sprites, i get 8% cpu
07:34:54 <EvanR> the same amount of screen space is being painted, why the 4x reduction in cpu
07:35:05 <EvanR> overhead of the copy call??
07:35:07 <ph88_> pacak, monomorphism restriction is for safety, no ?
07:35:36 <EvanR> MR is to avoid confusion, and reduce convenience
07:35:41 <EvanR> so dont use it
07:36:01 <EvanR> and dont be confused
07:36:42 <EvanR> > (30*40, 15*20)
07:36:45 <lambdabot>  (1200,300)
07:38:11 <ph88_> why do i get an illegal polymorphic type error here ?  https://bpaste.net/show/ae54a8dde379
07:39:02 <lyxia> Producer is probably a type synonym for a polymorphic type
07:39:34 <lyxia> https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#t:Producer
07:39:37 <EvanR> type Producer b = Proxy X () () b
07:39:59 <ph88_> why is that illegal ?
07:40:24 <EvanR> well... thats one argument
07:40:32 <EvanR> lets see what it expands to...
07:40:58 <EvanR> (Proxy X () () (ResourceT IO)) ByteString
07:41:07 <EvanR> shouldnt even kind check
07:41:09 <ph88_> type Producer m o = forall i. ConduitM i o m ()    no ?
07:41:19 <lyxia> EvanR: this is conduit, not pipes
07:41:21 <EvanR> oh not pipes
07:42:01 <EvanR> why are there two libraries for this :(
07:42:08 <EvanR> with the same names and point
07:42:17 <ph88_> forall i. ConduitM i BS.ByteString (ResourceT IO) ()
07:42:53 <lyxia> EvanR: quiver is a third
07:43:11 <EvanR> o_O
07:43:39 <EvanR> ph88_: so that looks like an existential type at least
07:43:40 <lyxia> there's also all the iteratee/stream libraries
07:43:58 <EvanR> ph88_: generally you get all this goodness by enabling RankNTypes or GADTs
07:44:02 <EvanR> like it says
07:44:22 <ph88_> when i disable the type signature ghci is able to infer a type
07:44:47 <EvanR> but not the same type you thought?
07:44:52 <ph88_> pipe :: (MonadIO m, MonadState StreamState m) => ConduitM a BSC.ByteString m () -> ConduitM BSC.ByteString c m r -> ConduitM a c m r
07:45:44 <EvanR> sometimes to control the signature a certain way you need to enable RankNTypes, even if a more general type would not require anything special
07:46:18 <ph88_> hmmm :/
07:47:42 <ph88_> it works with Rank2Types and RankNTypes
07:48:00 <ph88_> (and i had to make a tiny adjustment as well .. but that's beside the point)
07:48:27 <ph88_> pipe :: (MonadResource m, MonadState StreamState m) => Producer m BS.ByteString -> Consumer BS.ByteString m () -> ConduitM BSC.ByteString BSC.ByteString m ()
07:48:31 <ph88_> this works with Rank2Types
07:48:43 <ph88_> what is this Rank2Types and why do i need it ?
08:03:34 <ph88_> how can i use my conduit together with state now ?   https://bpaste.net/show/1a87726b59ab
08:05:47 <jle`> ph88_: you might need to hoist src and snk
08:06:08 <jle`> there might be a more natural way in conduit
08:06:15 <ph88_> do i have any other option beside hoist ?
08:07:12 <eschnett> i hear one can write “Type” instead of “*” when specifying a kind. what GHC extension enables this?
08:07:26 <jle`> ph88_: pipe (hoist lift src) (hoist lift snk) is how i, a non-conduiter, would naturally do it
08:07:34 <jle`> eschnett: TypeInType and importing Data.Kind
08:07:35 <EvanR> -XTypeInType at least
08:08:12 <jle`> ph88_: host lift src will turn src into a Producer (StateT s (ResourceT IO)) BS.ByteString
08:08:19 <jle`> which is indeed a MonadState instance
08:08:27 <eschnett> EvanR: no — i’m getting “Not in scope: type constructor or class ‘Type’”
08:08:42 <jle`> you need to import Data.Kind, where 'Type' is defined
08:08:57 <jle`> it's not particularly special, it's basically `type Type = *`
08:09:03 <jle`> you could even write it in your own file heh
08:09:12 <EvanR> thats not the haskell way
08:09:12 <ph88_> jle`, could i use a data constructor for State directly instead of using conveniance function hoist ?
08:09:29 <EvanR> you need to import a universe of dependencies with funny names to get the one line declaration
08:09:37 <EvanR> code reuse
08:09:45 <eschnett> EvanR: ha! thanks.
08:10:19 <jle`> ph88_: you might be able to use it instead of lift if you wanted to make it complicated
08:10:29 <jle`> but hoist manipulates the Producer/Consumer itself
08:10:49 <jle`> if you implemented it yourself you'd have to use the constructors of producer/consumer
08:10:50 <jle`> not of State
08:10:53 <ph88_> jle`, not neccesarily to make it complicated .. but to understand better what's going on under the hood
08:11:16 <jle`> hoist just changes the underlying monad
08:11:18 <ph88_> i don't really get what is happening with hoist
08:11:37 <jle`> hoist :: (forall a. m a -> n a) -> Producer m o -> Producer n o
08:11:48 <jle`> it transforms a producer over 'm' to a produer over 'n'
08:11:48 <ph88_> @src hoist
08:11:49 <lambdabot> Source not found. I am sorry.
08:12:07 <jle`> it's a typeclass method, and it's a part of the abstract interface of Producer/Consumer/etc.
08:12:07 <ph88_> can you show me how to do such a transform manually ?
08:12:12 <ph88_> with simple types
08:12:21 <jle`> you'd have to look into how Producer and Consumer are implemented
08:12:30 <jle`> internally
08:12:32 <ph88_> those are difficult
08:12:41 <ph88_> i mean just the concept of hoist
08:12:55 <jle`> hoist is a typeclass method, so every instance has its own meaning/definition
08:12:59 <ph88_> it looks to me to be some kind of fmap
08:13:04 <jle`> it is very much like an fmap
08:13:07 <ph88_> aah ok
08:13:24 <jle`> did you see the type earlier?
08:13:31 <jle`> it transforms a Producer on m into a Producer on n
08:13:39 <jle`> given a way to transform an m to an n
08:14:13 <ph88_> like    fmap (m -> n) producer
08:14:34 <jle`> mhm
08:14:43 <jle`> the typeclass hoist comes from is actually called MFunctor
08:14:57 <jle`> so your intuition isn't crazy :)
08:15:14 <ph88_> when i see Morph i have to think of power rangers
08:15:16 <jle`> fwiw conduit re-exports hoist and calls it 'transPipe' http://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#v:transPipe
08:15:39 <ph88_> https://www.youtube.com/watch?v=-jQCbqckLOs  you know what i mean ?
08:15:50 <jle`> i do :)
08:16:33 <ph88_> yes i knew about transPipe !
08:17:07 <jle`> transPipe is just a specialzed hoist with a nice name, like map vs. fmap
08:17:32 <ph88_> i just needed to know what the concept of it is .. and if this is a natural thing to use (in the haskell language & eco system) .. or if i'm hitting an exotic edge case here
08:17:40 <ph88_> have to orientate you know :P
08:18:21 <jle`> ah, yeah :)
08:18:25 <jle`> it seems like a normal thing
08:18:32 <ph88_> ye ok
08:18:49 <EvanR> :(
08:18:55 <jle`> it's a general design pattern in haskell, if you have something over 'm' but need it over 'n', find a way to map an (m a -> n a)
08:19:09 <ph88_> i was talking to davean earlier he said i had 3 options ... of which 1 was transPipe .. but i was going for another option actually .. so i'm still a bit surprised i have to use transPipe after all ..
08:19:12 <jle`> but i'm not a conduiter by trade
08:19:29 <jle`> all it is is switching out the underlying monad
08:19:55 <ph88_> i thought if i put enough typeclass constraints i could avoid the use of transPipe
08:20:12 <jle`> the problem is the type of src and snk
08:20:45 <jle`> well, actually, what is the type of sourceFile and sinkFile?
08:20:52 <jchia_1> What are typical use cases of Data.Default? When is it useful?
08:21:20 <ph88_> jle`, Producer (ResourceT IO) BS.ByteString  and   Consumer BS.ByteString (ResourceT IO) ()   ... but i think under the hood they are both ConduitM
08:21:33 <EvanR> so if you have a record, you can replace some or all the fields with a record update expression. but if you use lens, each field update is done separately, and so not as efficiently. is that right? is there a way around it?
08:21:35 <jle`> jchia_1: it's an ad-hoc typeclass so it's not super ideal from a mathematical standpoint, but they're useful for things like default arguments
08:21:52 <sphinxo> How best should I represent this with haskell datatypes:
08:21:57 <jle`> ph88_: where are you getting it from?
08:22:06 <jle`> ph88_: it might have a more general type
08:22:08 <EvanR> i dont find Data.Default useful, its like something you shouldnt use just because its there
08:22:23 <ph88_> jle`, did you see the paste ? https://bpaste.net/show/1a87726b59ab
08:22:33 <jle`> ph88_: what module is it imported from
08:22:38 <ph88_> https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#t:Producer
08:22:48 <jle`> i mean sourceFile and sinkFile
08:23:05 <ph88_> Data.Conduit.Binary
08:23:21 <ph88_> https://hackage.haskell.org/package/conduit-0.2.2/docs/Data-Conduit-Binary.html
08:23:25 <jle`> it looks like its type is MonadResource m => FilePath -> Producer m ByteString
08:23:26 <ph88_> sourceFile :: ResourceIO m => FilePath -> Source m ByteString
08:23:34 <jle`> so you can actually just use StateT as the underlying monad
08:23:39 <jchia_1> I'm considering using Data.Default for some type that I defined that lets user customize behavior of some function. Is it better to use Maybe instead (Nothing means he wants the default setting)?
08:23:53 <jle`> CB.sourceFile "sample_data.txt" :: Producer (StateT StreamState (ResourceT IO)) BS.ByteString
08:23:57 <EvanR> i would avoid Nothing for that too
08:23:57 <jle`> then you wouldn't have to hoist
08:24:08 <ph88_> jle`, how do you know that i can use StateT as the underlying monad? And how do i actually put StateT as the underlying monad ?
08:24:19 <jchia_1> EvanR: What would you typically do?
08:24:27 <jle`> ph88_: it's polymorphic over any ResourceIO m
08:24:29 <EvanR> jchia_1: a better api i think would be to have another function that provides the default argument to the more complex function, then they dont need to pass anything in at all
08:24:38 <jle`> and StateT StreamState (ResourceT IO) is an instance of ResourceIO m
08:25:24 <jle`> ph88_: it's also an instance of MonadState StreamState
08:25:41 <jle`> so it satisfies *all* of the constraints that 'pipe' needs
08:25:52 <jle`> pipe :: (MonadResource m, MonadState StreamState m) => ...
08:26:16 <jle`> StateT StreamState (ResouceT IO) is an instance of MonadIO, an instance of MonadState StreamState, and an instance of MonadResource
08:27:54 <ph88_> jle`, so it seems everything fits together .. but yet i'm getting that error .. i don't understand what is the missing step here that i have to do
08:28:04 <jle`> so this way you don't need to do any hoisting, since it's already a valid underlying monad
08:28:13 <jle`> what did you change?
08:28:24 <jle`> did you change the type of snk and src ?
08:28:35 <ph88_> eh dunno .. i can double check .. but as far as i know the code is just like this  https://bpaste.net/show/1a87726b59ab
08:28:45 <fXl> Hello guys, if i compile with ghc, my app works properly but if i use cabal build it fails, what could make this happen ?
08:28:54 <jle`> ph88_: you need to change the type of snk and src like i mentioned
08:29:01 <jle`> ph88_: you can't use `Producer (ResourceT IO) BS.ByteString`
08:29:14 <glguy> fXl: You can paste the error message to http://lpaste.net . It won't be possible to guess
08:29:19 <jle`> you could use `Producer (StateT StreamState (ResourceT IO)) BS.ByteString`
08:29:53 <ph88_> ah ye that works
08:30:00 <jle`> ph88_: your problem is that you choise (ResourceT IO) as the underlying monad, but that's not an instnace of MonadState StreamState
08:30:17 <jle`> but you can use `StateT StreamState (ResourceT IO)` as your underlying monad, and that is indeed an instance of MonadState StreamState
08:30:24 <ph88_> jle`, how come i don't have to change the value and i can just change the type like that by adding the   StateT StreamState   part ?
08:30:33 <fXl> glguy: i do yaml parsing, http://lpaste.net/355133
08:30:44 <jle`> > [read "hello" :: Int, True]
08:30:46 <lambdabot>  error:
08:30:46 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Bool’
08:30:46 <lambdabot>      • In the expression: True
08:30:58 <jle`> > [read "True" :: Bool, True]
08:31:01 <lambdabot>  [True,True]
08:31:04 <jle`> > [read "True" :: Int, True]
08:31:07 <lambdabot>  error:
08:31:07 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Bool’
08:31:07 <lambdabot>      • In the expression: True
08:31:10 <jle`> do you see why i didn't have to change the value, but only the type?
08:31:18 <jle`> it's because `read "True"` is polymorphic
08:31:44 <jle`> it's a polymorphic value that can be many types
08:31:49 <jle`> same in your case, for snk and src
08:32:07 <jle`> snk and src are polymorphic and can be have many types, but not every type is interchangeable with every other type
08:32:19 <jle`> just like how `read "True" :: Bool` can't be used everywhere that `read "True" :: Int` can be used
08:32:22 <ph88_> i was expecting some data constructor for State ..
08:32:52 <ph88_> but ok i guess it just means somewhere in my ConduitM monad i have now a state monad too
08:32:56 <jle`> src is polymorphic enough that it can be used over `StateT StreamState (ResourceT IO)`
08:33:19 <jle`> just like how `read "True"` is polymorphic enough that it can be used as a Bool, an Int, a String, etc.
08:33:54 <ph88_> ye ok maybe i was just a bit surprised that you can just keep adding monads like that and this value can be used in many monads
08:34:03 <jle`> a better example might be 'return 10'
08:34:12 <jle`> which can be Maybe Int, StateT s Int, Writer Int, [Int], etc.
08:34:21 <ph88_> ye
08:34:28 <jle`> you can have `return 10 :: State s Int`, but you never use the State constructor
08:34:54 <jle`> and, i can change `return 10 :: Maybe Int` into `return 10 :: State s Int` in my source code by just changing the type annotation
08:35:04 <jle`> i don't need to actually modify the written value `return 10`
08:35:12 <jle`> i also wouldn't call this "many monads"
08:35:19 <jle`> er i mean, "adding monads"
08:35:37 <jle`> src is polymorphic over many different individual monads
08:35:50 <ph88_> well i already had a ResourceT there .. so StateT seems like another wrapper
08:35:52 <jle`> StateT StreamState (ResourceT IO) is a specific monad it can be instantiated as
08:36:00 <ph88_> ok
08:36:06 <fXl> glguy: its clueless ? :D
08:36:14 <jle`> StateT doesn't "add a monad"
08:36:26 <glguy> fXl: There's not enough information available to help, unfortunately
08:36:38 <jchia_1> ph88_: This is typically the type of thing you need to deal with when using monad transformer stacks. It's pretty common in real-world code.
08:37:03 <ph88_> jchia_1, ya i'm just getting into monad transformers ..
08:37:04 <fXl> glguy, yes and i dont understand why this happening
08:37:12 <fXl> ghc works though
08:37:29 <ph88_> thanks jle` 
08:37:33 <jle`> ph88_: you can take this as something that works well because of haskell's typeclasses
08:37:51 <jle`> where `StateT StreamState (ResourceT IO)` is convenient an instance of all of the typeclasses that work
08:38:00 <jle`> er, all of the typeclasses that are needed
08:38:45 <spatial> matrix @@> (row,column)          Here row is x <- [0..10] and column is the elements from another Vector. How will the code be for this ?
08:39:15 <spatial> It is hmatrix.
08:39:45 <jle`> ph88_: btw, StateT StreamState (ResourceT IO) isn't necessarily the *only* instance that satisfies everything
08:40:25 <jle`> ph88_: `StateT s` is just a convenient way to imbue a monad with a free `MonadState s` instance
08:40:29 <jle`> free as in no work required
08:40:42 <ph88_> jle`, i was able to run the Conduit now .. and i get "test" as result https://bpaste.net/show/91fe2232e947  now i get my state and i try to eval it .. but now i get into problems with the ResourceT ..
08:41:07 <jle`> try evalStateT
08:41:11 <jle`> :t evalStateT
08:41:13 <lambdabot> Monad m => StateT s m a -> s -> m a
08:41:24 <ph88_> oh ok
08:41:42 <jle`> State s  is a type synonym for StateT s Identity
08:42:57 <ADG> can anyone help with functors?
08:43:13 <ADG> I don't get why Either can be defined as a functor?
08:43:19 <ADG> I mean it takes 2 args?
08:43:21 <jle`> check the type of fmap
08:43:23 <jle`> :t fmap
08:43:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:43:28 <ph88_> hurray ! finally got my conduit back to IO ()   :D
08:43:29 <jle`> could you put in 'Either' there for f?
08:43:33 <jle`> ph88_: :D
08:43:36 <byorgey> ADG: you are exactly right, it can't.
08:43:54 <jle`> ADG: `fmap :: (a -> b) -> Either a -> Either b` doesn't make any sense
08:43:54 <xa0> ADG: Either a takes one arg
08:44:11 <byorgey> ADG: however, (Either e) can be a Functor.
08:44:39 <ADG> what does that mean, Either is a container but what is `Either a`? variable ^ container?
08:44:46 <jle`> what does make sense would be `fmap :: (a -> b) -> Either e a -> Either e b`, and so `f` would be `Either e`
08:44:54 <ph88_> ADG,   i think Either is something like     data Either a = Left a | Right a    ... so both Left and Right only take 1 thing
08:45:09 <ADG> So we could only modify right by this definition
08:45:11 <byorgey> ph88_: no, that's not how Either is defined.
08:45:21 <ph88_> byorgey, correct me
08:45:22 <byorgey> ADG: correct.
08:45:30 <byorgey> ph88_: data Either a b = Left a | Right b
08:45:32 <ADG> data Either a b = Left a | Right b
08:45:52 <jle`> yup, parametricity strikes again
08:46:04 <jle`> fmap can only modify things in the Right constructor
08:46:18 <byorgey> > fmap (+1) (Left 2)
08:46:20 <lambdabot>  Left 2
08:46:23 <byorgey> > fmap (+1) (Right 2)
08:46:25 <ph88_> o_O
08:46:26 <lambdabot>  Right 3
08:46:33 <jle`> > fmap (+1) (Left "hello")
08:46:35 <lambdabot>  Left "hello"
08:46:47 <ph88_> you fmap be reimplemented so that it also effects Left ?
08:46:57 <jle`> not with the type signature it currently has
08:47:00 <ADG> not necessarily
08:47:07 <ADG> probably BiFunctor?
08:47:13 <jle`> `(a -> b) -> Either e a -> Either e b` can only omdify the Right, because of parametricity
08:47:13 <ADG> :t BiFunctor
08:47:15 <lambdabot> error: Data constructor not in scope: BiFunctor
08:47:17 <byorgey> ADG: yes, Either is a Bifunctor.
08:47:35 <jle`> ph88_: if you have a Left x, the only thing you can do with x is return it again in a Left 
08:47:46 <jle`> since you don't hae any way to modify an 'e'
08:48:10 <jle`> in fact I'm pretty sure there is only one sensible definition of mapEither :: (a -> b) -> Either e a -> Either e b that typechecks
08:48:18 <ADG> so even if we are defining fmap for Either would it be like: fmap f (Left x) = Left x and fmap f (Right x) = Right (f x) ?
08:48:40 <jle`> you don't have to ask us
08:48:44 <jle`> try checking the laws :)
08:48:49 <jle`> well, first make sure it typechecks
08:49:00 <byorgey> jle`: in fact that's true for *any* instance of Functor =)  (that there's only one definition of fmap)
08:49:16 <jle`> for some instances there is more than one typechecking implementation of (a -> b) -> f a -> f b
08:49:23 <byorgey> oh, I guess you mean even without the laws.
08:49:28 <jle`> but yes, only one Functor instance
08:49:29 <byorgey> yes, I agree.
08:49:39 <jle`> yeah, Either seems to be interesting in that only one definition actually typechecks
08:49:53 <byorgey> right, that's true for Maybe as well.
08:49:58 <jle`> not quite
08:49:58 <ph88_> ADG i think the problem is with an   f   that can do   both  f a   and   f b
08:50:09 <byorgey> oh! you're right =)
08:50:22 * byorgey should think for two more seconds before typing
08:50:30 <jle`> hm, i think it's true for `(,) w` and `(->) r`
08:50:36 <ADG> thanks
08:50:45 <jle`> so i guess it's nto as rare as i thought it was
08:51:26 <ph88_> 0.1   ... my first data out .. now onto the verification of the program
08:51:39 <jle`> there should be an anti-djinn that tries to conjure the most boring implementation possible of a type
08:51:55 <jle`> like map _ _ = []
08:51:59 <byorgey> jle`: it's true for any composition of those as well =)
08:52:49 <mniip> there might be a strict formulation
08:53:11 <byorgey> jle`: in fact I think the only time it's NOT true is when you have something of the form  T a = 1 + ...
08:53:23 <mniip> something like, whether there exists a non-identity transformation 'f a -> f a' natural in a
08:53:33 <mniip> byorgey, data P a = L a | R a
08:54:37 <byorgey> mniip: ah, but that is isomorphic to (1 + 1) * a   =)
08:54:47 <mniip> I *think* every typechecking fmap implementation factors as true fmap composed to a natural transformation
08:55:05 <byorgey> mniip: yes, that is a free theorem
08:55:16 <mniip> so the question is whether there are multiple transformations
08:55:30 <mniip> cardinality of a profunctor end
08:55:49 <byorgey> =D
08:56:26 <mniip> your description fits the idea
08:56:28 <jle`> so a type with which ther eis *only* the identity natural transformation is a type whose fmap is the only typechcking implementation
08:56:34 <mniip> if you have T a = 1 + ...
08:56:48 <mniip> then you can always build a transformation '\_ -> 1'
08:57:12 <edwardk> mniip toList . safeHead is natural in a, but not the identity naturaly transformation on [] to []
08:57:16 <byorgey> right, and I was imagining the 1 + ... being able to show up deeply nested as well
08:57:37 <byorgey> but you're right that there could be others
08:57:40 <mniip> edwardk, correct
08:57:51 <mniip> edwardk, that proves that there are multiple typechecking fmaps for lists
08:57:56 <mniip> what's the problem?
08:58:17 <jle`> ¯\_(ツ)_/¯
08:58:48 <edwardk> anyways your statement about composition of 'true fmap" wih a natural transformation should follow from a free theorem
09:00:17 <mniip> byorgey, I'm not too sure
09:02:45 <mniip> hmm
09:02:58 <mniip> I'm trying to construct something like
09:03:12 <mniip> 'forall a. f a' has to have no inhabitants and 'f ()' has to have one
09:04:30 <mniip> and then there's the imporant distinction that 'Either Int' doesn't fit the above definition, but 'Either Int' has multiple typechecking fmaps, while 'forall b. Either b' is what we're looking at here
09:06:48 <mniip> any counterexamples to the above conjecture?
09:06:55 <jle`> types that have only a single typechecking fmap that don't involve type variables?  i can only think of Identity
09:07:01 <jle`> or things isomorphic to it
09:07:05 <mniip> nono
09:07:11 <mniip> they can involve tyvars
09:07:14 <jle`> oh i'm just thinking out loud, that wasn't in response to yours
09:07:14 <Gurkenglas> "<mniip> 'forall a. f a' has to have no inhabitants and 'f ()' has to have one" I was thinking about this just yesterday iirc, it's a subclass of Each right
09:07:17 <Giu> >
09:08:43 <edwardk> is f concrete or abstract there?
09:09:26 <mniip> er?
09:09:27 <Gurkenglas> Ooh shouldn't it be exactly the Representable typeclass?
09:09:45 <mniip> Gurkenglas, is forall a. Either a representable?
09:09:57 <edwardk> mniip it is not
09:10:03 <mniip> yeah
09:10:07 <ph88_> is there a utility for ghci that takes a type and lists all the synomyms ?
09:10:12 <edwardk> well, fora
09:10:17 <edwardk> ll a
09:10:24 <Gurkenglas> Why not? It's Either Void
09:10:28 <edwardk> it becomes Void + a
09:10:32 <edwardk> which is a
09:10:35 <mniip> not impredicative polymorphism
09:10:47 <mniip> forall a. (is Either a representable)?
09:11:03 <Gurkenglas> No, but there's more than one inhabitant of Either a ()
09:11:26 <Gurkenglas> (and more than none of Either a (forall b. b)
09:11:27 <mniip> the inhabitant isn't continuous
09:12:34 <Gurkenglas> "forall a. (is Either a representable)?" <- no; "forall a. (does Either a () have exactly one inhabitant)?" <- no
09:13:01 <mniip> well
09:13:11 <mniip> the latter question is a yes
09:13:19 <mniip> in the spirit in which I asked it, anyway
09:13:34 <edwardk> are you describing something you want out of a class or a law you want in general?
09:13:44 <mniip> I don't think this is expressible in haskell, but I'll try
09:13:48 <Gurkenglas> How does the alleged spirit of your question differ from "does (forall a. Either a ()) have exactly one inhabitant?"
09:15:13 <spatial> @@> is used for matrix element access. Which module ?
09:15:21 <mniip> with a hypothetical dependent type system,
09:15:32 <spatial> Data.Packed.Matrix ?
09:15:33 <mniip> class UniqueFmap f where uninhabited :: (forall a. f a) -> Void; singular :: (a : f ()) -> (b : f ()) -> a = b
09:17:09 <mniip> you can't write an "instance" for 'Either b' but you can for 'Either Int'
09:17:55 <Gurkenglas> You can't write an instance for 'Either Int' but you can for (forall b. Either b) (the latter being Either Void)
09:20:06 <mniip> oops
09:20:08 <mniip> yes
09:20:11 <mniip> I got that backwards
09:20:22 <sm> g'day all. Anybody here interested in pair/mob-ing on hledger tasks right now ? If so you can join me for hledger cowork hour at https://join.skype.com/GYLxZE1xe87E
09:22:54 <spatial> It is `atIndex`
09:24:48 <edwardk> mniip what motivates the class/abstraction that you are looking for? for a moment i thought you were looking for an "is left adjoint" or something
09:25:01 <edwardk> now i'm less sure
09:25:48 <mniip> edwardk, trying to state 'there exists exactly one natural endotransformation' in more concrete terms
09:26:40 <Unode> hi all, I'm trying to understand in which cases would you chain multiple $ do expressions like Hspec does.
09:26:58 <Unode> Is this due to independent monads being created at each indentation level?
09:30:20 <edwardk> you might have a combinator like foo :: m a -> m a
09:30:48 <edwardk> there inside a do block you might nest a call to foo $ do
09:31:05 <edwardk> in which you could nest a call to foo $ do etc
09:31:28 <edwardk> why make a function that takes an m a argument rather than just an a
09:31:50 <edwardk> ? well not everything can be done "in" the monad
09:31:59 <edwardk> local for reader
09:32:10 <edwardk> pass/listen for writer
09:32:15 <edwardk> callCC
09:32:51 <edwardk> etc all need more info about the arg than they can get out of >>=
09:33:41 <edwardk> but generally, yes, there is some sort of scoping going on
09:44:58 <jophish> hvr: is packunused still usable?
09:55:41 <Unode> edwardk: thanks. I haven't got to reader/writer so I don't yet get those references but I'll look into it.
09:56:32 <edwardk> then in that case, suffice it to say 'yes there is a good reason' :)
09:59:36 <oish> fg
09:59:38 <mnoonan> I've been enjoying using inline-c-cpp to wrap a C++ API recently; most of the functions and methods work on POD types and everything is nice and clean. but a few return or accept std::vectors. has anybody worked with marshalling/unmarshalling these from/to Haskell? any pointers?
10:03:17 <geekosaur> template types will be a nightmare
10:04:03 <cocreature> if you know it’s always going to be a concrete vector, e.g. std::vector<int>, it shouldn’t be too hard
10:04:33 <cocreature> :t peekArray
10:04:35 <lambdabot> error: Variable not in scope: peekArray
10:04:42 <cocreature> why does lambdabot hate me so much
10:04:44 <mnoonan> geekosaur: yeah.. my only consolation is that they are relatively rare in the API, so it isn't terribly to enumerate `std::vector<ApiType1>`, `std::vector<std::vector<ApiType2>>`, etc
10:05:18 <mnoonan> should I just manage them through a ForeignPtr that calls the destructor on finalization or something?
10:15:00 <Guest36086> Hi
10:15:17 <lambdabot> Hello.
10:16:23 <shapr> lambdabot: oh HAI
10:16:54 <Guest36086> Haskell looks exciting but doesn't seem as employable as Scala for example. Is it just for recreational use?
10:17:06 <hvr> Guest36086: yes
10:17:15 <johnw> Guest36086: no
10:17:19 <glguy> maybe?
10:17:26 <hvr> Guest36086: after a long dayjob working on Scala, haskell feels like recreation :)
10:17:48 <shapr> Guest36086: recreational use of Haskell can lead to addiction, be careful
10:18:03 <johnw> some of us simply were forced to turn recreation into career
10:18:14 <hvr> johnw: like musicians?
10:18:16 <shapr> yeah, I write Haskell at work sometimes
10:18:38 <shapr> because writing parsers and other tools is just so much easier and faster in Haskell
10:18:54 <LordBrain> if you know hte library well 
10:19:00 <LordBrain> what do you use, parsec?
10:19:06 <shapr> megaparsec
10:19:34 <shapr> LordBrain: have you tried MegaParsec?
10:19:41 <shapr> Guest36086: what sort of things do you code?
10:20:01 <LordBrain> no, i havent
10:20:15 <LordBrain> what makes you like it better than vanilla parsec?
10:20:40 <Guest36086> I currently code C# during the day
10:20:48 <LordBrain> i've actually messed around in the past with alex quite a bit... 
10:21:00 <LordBrain> but of course, that is a pain
10:21:04 <shapr> Guest36086: ooh, I did that for a few years. Do you write big LINQ expressions for fun? If yes, you'll probably love Haskell.
10:21:15 <LordBrain> so tell me how you landed on megaparsec shapr 
10:21:31 <LordBrain> the hackage page says its a fork of parsec
10:21:42 <shapr> LordBrain: I read the MegaParsec docs on how it differs from parsec, and was thrilled, but I forget exactly why
10:21:49 <shapr> lemme see if I can find that page
10:21:49 <LordBrain> oh okay
10:22:23 <geekosaur> integrated with Applicative + has a bunch of bugfixes
10:22:30 <shapr> LordBrain: it was something from here: https://mrkkrp.github.io/megaparsec/tutorials/switch-from-parsec-to-megaparsec.html
10:23:09 <cocreature> megaparsec also has better docs and a few new features
10:23:15 <shapr> Guest36086: what's your domain? What sort of problems do you solve?
10:23:16 <cocreature> I think they also did some performance improvements
10:23:26 <hvr> megaparsec is more modern parsec
10:23:27 <shapr> yeah, megaparsec really does go faster
10:23:38 <hvr> more aligned w/ modern `base`
10:25:43 <Guest36086> Shapr: I am looking for a new language to write my own side projects in, so not one particular domain. For a start these will include web scraping & finance. 
10:26:07 <LordBrain> well thanks for the info on megaparsec
10:26:10 <shapr> Guest36086: I have three or four recruiters trying to hire me for Haskell jobs in any given week, but I have more like twenty trying to hire me for Python
10:26:16 <shapr> LordBrain: ok, tell me what you think!
10:27:06 <shapr> Guest36086: finance has piles of Haskell jobs, but I don't know anything about web scraping with Haskell
10:27:36 <Tuplanolla> Do we have (bindings to) a headless JavaScript engine, shapr?
10:27:50 <shapr> I don't know
10:28:16 <Tuplanolla> If not, web scraping is not going to go anywhere.
10:28:26 <LordBrain> i guess the advantage of a renamed fork is you keep the old one maintained for closer backward compatibility eh
10:28:42 <kuribas> shapr: do they ask you to relocate?
10:28:49 <shapr> Guest36086: If you have several languages in mind to try for fun projects, how about giving each of them a day or two and then deciding which one fits you best?
10:29:13 <shapr> kuribas: Not for Python, many jobs in Atlanta.. I think one or two of the Haskell jobs are remote-friendly
10:29:27 <shapr> but I, personally, am not remote friendly
10:29:39 <shapr> I am not an introvert
10:33:09 <Guest36086> Shapr: Whenever I look deeply into Python I always see speed questions due to it being high level and scripting
10:34:22 <Guest36086> Shapr: I do understand you can write those modules in C then call them directly from Python though. Seems a lot more effort though to me...
10:34:30 <shapr> Guest36086: I don't care about speed of execution as much as I care about speed of change. In my experience being able to change an algorithm or abstraction can improve my code much more than going from interpreted to compiled
10:34:41 <shapr> Guest36086: if you use Cython it's not much effort
10:34:52 <shapr> Even so, I still get more speed of change from Haskell than I do from Python
10:37:44 <shapr> I see advanced Python coders use objects to build structures as I would use ADTs in Haskell.
10:42:36 <xintron> Do people use hindent for auto-fixing code styling? I've been running it a while but can't say I agree with all the automatic formatting it does.
10:43:06 <glguy> I'm sure some people do, lots of us don't
10:44:07 <shapr> Guest36086: any specific questions about Haskell?
10:44:39 <xintron> glguy, Been developing in go for a while and their go-formatter is used almost everywhere resulting in similar syntax and code structuring everywhere. Considering if hindent is worth it for Haskell
10:44:42 <lassulus> d
10:45:44 <glguy> xintron: Yeah, having exactly one style is nice, but not worth losing the context that formatting code as appropriate for the local situation provides to the reader
10:47:39 <xintron> glguy, Agree. It does mess up comments especially in certain situations and doesn't allow for empty whitelines in functions which I don't agree with. Splitting things up (imports, functions) with blank lines do help to contextualize and help the reader in the long term
10:51:32 <drewr> I too wish for a good haskellfmt story
10:52:40 <geekosaur> .oO { haskellfmt --style=henning }
10:53:39 <cocreature> geekosaur: does that rename all your types to T and all your classes to C?
10:53:39 <nitrix> ghc --fphp main.hs
10:53:42 <LordBrain> there's a formatter called 'stylish-haskell'
10:53:51 <geekosaur> that was the reference, yes
10:53:57 <LordBrain> oh
10:54:21 <cocreature> that’s obviously the best way to write haskell code
10:54:33 <nitrix> TT if it's a type transformer.
11:10:16 <Fendor> when using repa stencil2d quasiquoter, can i also use floating point numbers instead of only integer?
11:12:07 <hexagoxel> xintron: i am continuing to work on https://github.com/lspitzner/brittany
11:13:57 <xintron> hexagoxel, Neat, will have a closer look at that later
11:14:01 <drewr> hexagoxel: <3 <3
11:19:38 <xintron> What does `:~>` mean in the type signature of a function?
11:20:18 <glguy> It doesn't have a built-in meaning, that operator symbol is defined in a library you're using
11:34:25 <dmj`> xintron: servant?
11:36:02 <nshepperd_> I don't like any of the existing haskell formatters :(
11:37:45 <dmj`> xintron: used for monad morphisms
11:39:13 <xintron> dmj`, Ah, yes. The project I'm looking at do seem to use servant. Was looking for the definition in the project though, didn't consider one of the used libraries :/
11:39:26 <xintron> Thanks
11:43:24 <lukesp> I tried connecting to #haskell-beginners, doesn't seem to work
11:46:37 <cocreature> lukesp: just ask your question here :)
11:46:49 <lukesp> ok cool :)
12:11:55 <abhiroop> Does anybody know who is igfoo https://github.com/igfoo?
12:12:23 <abhiroop> He/She is the only person who has more contributions than SPJ in GHC
12:13:02 <abhiroop> Must be someone from the Haskell committee.
12:14:04 <mivael_> abhiroop: Bryan O'Sullivan?
12:14:08 <qqwy> Hey everyone! :-)
12:14:43 <qqwy> Short question, I am looking for a function with this type signature: `(a, Maybe b) -> `Maybe (a, b)`
12:14:53 <abhiroop> mivael_: Dont think so. bos's github is pretty famous https://github.com/bos
12:15:24 <Tuplanolla> :t sequence -- This, qqwy?
12:15:26 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:15:27 <mivael_> well, okay...  misguided by this: https://github.com/igfoo/base64-bytestring
12:15:41 <abhiroop> All Haskell folks(just 2 of us!) at my office were awestruck at who could this be!
12:15:48 <qqwy> Are tuples Traversable?
12:16:31 <qqwy-afk> One moment, brb
12:16:39 <mnoonan> huh, I'm surprised hoogle didn't know `(a, Maybe b) -> Maybe (a,b)`
12:16:40 <MarcelineVQ> kinda looks like just a report-bot
12:16:44 <mivael_> abhiroop: oh, it's forked...  I see now :)
12:16:56 <geekosaur> @instances (,)
12:17:05 <byorgey> abhiroop: might be Ian Lynagh.  He used to contribute a lot and used to go by tthe IRC nick of 'Igloo'
12:17:26 <lambdabot> Couldn't find class `(,)'. Try @instances-importing
12:17:30 <byorgey> Haven't seen him in a few years, though, consistent with how the GHC commits suddenly stop around 2013/2014
12:17:33 <geekosaur> oh, right
12:17:44 <geekosaur> @instances Traversable
12:17:46 <lambdabot> Array i, Complex, Dual, First, IM.IntMap, Identity, Last, Maybe, NE.NonEmpty, Product, Proxy, Seq.Seq, Seq.ViewL, Seq.ViewR, Sum, Tree, ZipList, []
12:17:56 <MarcelineVQ> I say that because the igfoo commit log has commits made by all kinds of people when compared to  git log  on ghc source
12:18:33 <MarcelineVQ> but maybe that's just how the commit process works on phab end, idk
12:18:50 <MarcelineVQ> a subset of mergers vs a set of contributors
12:20:26 <MarcelineVQ> hmm, no, it's not that
12:20:49 <abhiroop> byorgey: Yes you are right its him! https://www.haskellers.com/user/igloo
12:21:10 <MarcelineVQ> I wonder what the git stuff is about, such a weird system :>
12:22:32 <ADG> how does functors on `->` work, I mean what does this `instance Functor ((->) r) where fmap f g = (\x -> f (g x)) ` mean?
12:23:55 <Tuplanolla> Is `instance Functor (a ->) where fmap = (.)` any clearer, ADG?
12:24:20 <ADG> People say they are quivalent but what is -> operator in first place
12:24:36 <EvanR> its a type constructor
12:24:36 <ADG> they are making random things up?
12:24:41 <EvanR> :k (->)
12:24:43 <lambdabot> * -> * -> *
12:24:46 <mnoonan> ADG: think of ((->) r) as one thing; you give it a type t, and you get back the type `r -> t`
12:25:02 <EvanR> fancy words, a type former
12:25:06 <ADG> I give it Int and I get a function r -> Int?
12:25:11 <mnoonan> yes
12:25:26 <EvanR> * -> (* -> *)
12:25:26 <ADG> -> is defined as * -> * -> what recursiveness indeed!
12:25:32 <EvanR> lol
12:25:39 <EvanR> two different ->'s
12:25:39 <mnoonan> it's a different -> with the *s :)
12:25:50 <EvanR> its -> all the way up
12:26:51 <ADG> where is it used?
12:27:06 <ADG> an example would be better?
12:27:16 <ADG> haskell bot tell me an example for ->
12:27:24 <ADG> haskell bot reply
12:27:41 <ADG> haskell bot register me as an instructor
12:27:51 <ADG> haskell bot add user ADG
12:27:58 <EvanR> :t Maybe
12:27:59 <lambdabot> error:
12:28:00 <lambdabot>     • Data constructor not in scope: Maybe
12:28:00 <lambdabot>     • Perhaps you meant one of these:
12:28:04 <EvanR> :k Maybe
12:28:06 <lambdabot> * -> *
12:28:19 <ADG> :k ->
12:28:21 <lambdabot> error: parse error on input ‘->’
12:28:29 <EvanR> :k (->)
12:28:31 <shapr> ADG: are you learning Haskell?
12:28:31 <lambdabot> * -> * -> *
12:28:33 <suzu> it's used in the reader monad ADG 
12:28:35 <ADG> yes
12:28:41 <suzu> if you're familiar with that
12:28:42 <shapr> ADG: for school or work?
12:28:45 <ADG> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
12:28:46 <suzu> in fact -> IS the reader monad
12:28:49 <ADG> out of interest
12:28:58 <shapr> oh, that's a good reason
12:29:05 <EvanR> (->) r is Reader r
12:29:17 <EvanR> which is a Monad
12:29:28 <mnoonan> one nice case is if you think about ((->) Time)
12:29:57 <mnoonan> you can think of functions of the form `Time -> X` as time-varying values of type X
12:30:14 <EvanR> in practice you probably just want to pass time in as an argument
12:30:40 <mnoonan> and as for fmap: if you have a time-varying value of type `a`, and a function of type `a -> b`, then you can get a time-varying value of type `b`.
12:30:54 <ADG> composing the functions then
12:31:29 <mnoonan> right, that's why Tuplanolla said `fmap = (.)` above
12:32:36 <ADG> now exactly what is ->, it's a type constructor, given a type it returns a function that converts from one type to the given type, is it?
12:35:18 <qqwy> I think you could view it in that way, indeed :-)
12:46:02 <ADG_> so can I say that -> is a constructor for creating function?
12:46:19 <ADG_> but then it should be * -> * -> (* -> *)
12:46:53 <cocreature> ADG_: no "Int -> Int" has kind "*" not kind * -> *
12:46:59 <cocreature> so -> has kind * -> * -> *
12:47:08 <cocreature> but you ’re right that it’s a type constructor
12:47:11 <ADG_> oh so -> is just constructore for function. I get it
12:47:28 <ADG_> so it wouldnt be wrong to say type constructor that takes two parameters and returns a Function
12:47:40 <EvanR> its like Maybe or [ ] in Maybe A or [A]. except theres two arguments
12:47:52 <EvanR> of course, its not really two arguments, its curried
12:48:03 <cocreature> it’s like Either
12:48:13 <EvanR> A `Either` B ;)
12:48:23 <ADG_> so to create a functor we say `instance functor (r->?) where fmap =(.)` ?
12:48:40 <EvanR> unfortunately (r -> ) isnt valid syntax
12:48:53 <EvanR> so you write ((->) r)
12:49:02 <cocreature> but that’s only a syntactic oddity
12:49:04 <qqwy> ((->) a b)
12:49:10 <ADG_> great!
12:49:24 <EvanR> its odd because (3 +) is valid syntax
12:49:31 <ADG_> btw are you people on web or using some client for freenode?
12:49:34 <EvanR> but you cant do it on the type level
12:49:48 <mnoonan> is there a real reason for that, or is it just an oversight?
12:50:09 <Tuplanolla> We don't have type-level lambdas, mnoonan.
12:50:22 <EvanR> this isnt lambda
12:50:36 <Tuplanolla> Symmetric sections would require them.
12:50:51 <mnoonan> I think I don't follow why.. isn't it a purely syntactic issue?
12:50:58 <EvanR> you mean, allowing (-> r) ?
12:51:03 <mnoonan> yeah
12:51:10 <ADG_> what about fmap (replicate 3) [1, 2, 3, 4], here the context is list or the replicate function?
12:51:12 <mnoonan> well, (r ->)
12:51:15 <EvanR> because the meaning of (r ->) is allowed already
12:51:29 <EvanR> (-> r) would require the equivalent of a lambda, so... both get axed
12:51:36 <byorgey> ADG_: that does not type check, I'm not sure what you are asking.
12:52:00 <ADG_> > fmap (replicate 3) [1,2,3,4]  
12:52:03 <lambdabot>  [[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
12:52:34 <byorgey> oh, sorry.  not sure what I was thinking.
12:52:59 <byorgey> ADG_: I'm still not sure what you are asking though =)
12:53:14 <ADG_> np I got it
12:53:17 <Tuplanolla> > fmap @_ (replicate 3) [1,2,3,4] -- Do we have type application holes?
12:53:20 <lambdabot>  error:
12:53:20 <lambdabot>      Pattern syntax in expression context: fmap@(_)
12:53:20 <lambdabot>      Did you mean to enable TypeApplications?
12:53:33 <MarcelineVQ> Tuplanolla: yes
12:53:56 <MarcelineVQ> well, wildcards at least
12:54:00 <seequ_> ADG_: fmap (replicate 3) (Just 5)
12:54:23 <jordan36363> i dont understand why i cant compile this code
12:54:25 <byorgey> yes, but it doesn't tell you what it inferred for the hole.
12:54:34 <Tuplanolla> That's a shame.
12:54:36 <ADG_> > fmap (replicate 3) (Just 5)
12:54:38 <lambdabot>  Just [5,5,5]
12:54:50 <byorgey> Tuplanolla: perhaps there's some flag to enable that, I'm not sure
12:55:05 <Tuplanolla> I was hoping `NoPartialTypeSignatures` would do.
12:55:20 <ADG_> oh, what about the second functor law i.e. `fmap $ f.g = fmap f . fmap g` can anyone explain?
12:55:40 <jordan36363> https://ideone.com/gQfOFN
12:55:42 <byorgey> ADG_: why don't you try explaining it first, and we'll tell you if your explanation makes sense
12:56:11 <jordan36363> "parse error on input ‘="
12:56:13 <jordan36363> idk why
12:56:27 <byorgey> jordan36363: the 'd' on line 5 needs to be lined up under the 'a' on line 4
12:56:28 <ADG_> like if we do (f . g) [1, 2 , 3] = ? . ?
12:56:39 <byorgey> similarly the n on line 6
12:57:19 <ADG_> or even fmap ((+2) . (*2)) [1,2,3] = [4,6,8]
12:57:47 <byorgey> ADG_: right, so what does the second functor law tell you that is equivalent to?
12:57:53 <ADG_> fmap (+2) . fmap (*2) [1,2,3] = fmap (+2) . [2,4,6] ?
12:58:07 <jordan36363> now it says "The IO action ‘main’ is not defined in module ‘Main’
12:58:13 <jordan36363> byorgey
12:58:19 <ADG_> the RHS doesn't makes sense
12:58:33 <Clint> ADG_: you erred
12:58:55 <ADG_> (fmap (+2) . fmap (*2)) [1,2,3]?
12:59:11 <Myrl-saki> ADG_: fmap (f.g) x = fmap f . fmap g $ x
12:59:12 <Clint> > (fmap (+2) . fmap (*2)) [1,2,3]
12:59:15 <lambdabot>  [4,6,8]
12:59:17 <byorgey> ADG_: that's it
12:59:44 <ADG_> how to evaluate n general case when law doesnt hold, what is (fmap (+2) . fmap (*2)) [1,2,3] if we ignore LHS?
12:59:44 <byorgey> jordan36363: well, you need a main.  A function definition by itself doesn't do anything.
12:59:56 <jordan36363> main = d0
12:59:57 <jordan36363> do
13:00:01 <jordan36363> is this enough
13:00:06 <Myrl-saki> Nope.
13:00:08 <byorgey> jordan36363: what are you hoping that your program will do?
13:00:16 <Myrl-saki> do eneds a `body`, IIRC.
13:00:21 <Myrl-saki> needs*
13:00:29 <EvanR> do has to end in an expression
13:00:40 <EvanR> main = do { return () } for example
13:00:43 <Myrl-saki> close enough. c:
13:00:49 <jordan36363> main = summation 0 3
13:00:51 <jordan36363> doesnt work either
13:01:09 <EvanR> in this case it has to be an expression of type IO ()
13:01:17 <jordan36363> its supposed to add numbers from x to y
13:01:17 <EvanR> main :: IO ()
13:01:20 <byorgey> jordan36363: if you want your program to print the result of summation 0 3, you can write   main = print (summation 0 3)
13:01:49 <ADG_> @EvanR then isn't it same as (f.g)x = f(g(x)), isnt that always valid?
13:01:49 <lambdabot> Unknown command, try @list
13:01:53 <jordan36363> now it works byorgey
13:01:54 <jordan36363> thanks a lot
13:01:55 <ADG_> @list
13:01:55 <lambdabot> What module?  Try @listmodules for some ideas.
13:02:09 <EvanR> ADG_: isnt what the same as that
13:02:11 <Myrl-saki> ADG_: Nope.
13:02:11 <byorgey> ADG_: yes, that is the definition of (.)
13:02:27 <byorgey> that's not the same as the second functor law though.
13:02:54 <ADG_> I suppose then it means that function application should not have any side effects ?
13:02:57 <Myrl-saki> ADG_: That like saying `f (g . h) = f g . f h` is the same as saying `(g . h) = g . h`
13:03:24 <EvanR> f (x * y) = f x * f y, the homomorphism pattern
13:03:30 <Myrl-saki> (Rather, that's exactly what you're saying.)
13:03:43 <byorgey> ADG_: (fmap (+2) . fmap (*2)) [1,2,3] = fmap (+2) (fmap (*2) [1,2,3])  by definition of (.)
13:03:55 <glguy> ADG_: that's right, function application doesn't have side effects
13:04:18 <ADG_> so why define second law then, what does it convey?
13:04:38 <Myrl-saki> (Technically nothing, the first law was enough.)
13:04:48 <EvanR> Myrl-saki: eh?
13:04:55 <Myrl-saki> fmap id = id
13:06:45 <mnoonan> ADG_: you can't actually do this in Haskell (which is kind of what Myrl-saki is alluding to), but you could imagine a naughty fmap that inspected the function you gave it and then decided what to do; in that case, fmap f . fmap g could be very different from fmap (f . g)
13:07:20 <jordan36363> https://ideone.com/vlv21U
13:07:29 <jordan36363> is this code "end recursive"?
13:07:34 <ADG_> moonan something like this here at instance Functor CMaybe where  http://learnyouahaskell.com/functors-applicative-functors-and-monoids
13:07:52 <jordan36363> or is my function only "linear recursive"?
13:08:04 <Myrl-saki> summe1 x
13:08:07 <Myrl-saki>         | x < 0 = summe1 x
13:08:10 <Myrl-saki> That won't terminate if x < 0.
13:08:42 <jordan36363> thats ok i just wanna give an example for endrecursion and linear recursion that is not endrecursive
13:08:52 <jordan36363> like 2 versions of this algorithm
13:08:56 <byorgey> jordan36363: I don't know what "end recursive" or "linear recursive" mean.
13:09:05 <byorgey> where did you hear/read about them?
13:09:20 <Myrl-saki> Same place with byorgey here.
13:09:20 <EvanR> tail recursive?
13:09:26 <jordan36363> oops end recursion in english means tail call
13:09:27 <c_wraith> jordan36363, your function is only recursive in the case where it fails entirely... 
13:09:45 <Myrl-saki> I'm guessing linear recursion means O(n)?
13:09:53 <byorgey> jordan36363: yes, your function is tail recursive.
13:09:57 <Myrl-saki> (Well, not necessarily.)
13:10:14 <jordan36363> ok awesome
13:10:22 <mnoonan> ADG_: that's close, but I was thinking more like "fmap f = if f == (+2) then .. else if f == (*2) then ... else if f == ((+2) . (*2)) then..."
13:10:24 <byorgey> Myrl-saki: but it was being contrasted with tail recursive which would make no sense.
13:10:36 <jordan36363> now what do i need to do to make it linear recursiv but not tail recursive
13:10:51 <byorgey> jordan36363: what is "linear recursive"?
13:10:51 <ADG_> moonan you can compare f == (+2) ? great
13:10:54 <Myrl-saki> jordan36363: We'd need a definition for linear recursive. :P
13:11:02 <mnoonan> ADG_: no, my point is you can't :)
13:11:06 <mnoonan> and that's a good thing
13:11:14 <jordan36363> linear recursive "there is only one recursive call of the function"
13:11:24 <EvanR> because if you could, you could solve the halting problem, and that would be a bad thing?
13:11:24 <ADG_> well prevents lots of catcstrophe I suppose
13:11:25 <Myrl-saki> Ah.
13:11:26 <byorgey> jordan36363: is this for a class?
13:11:26 <jordan36363> sry for not telling the def earlier ^
13:11:27 <mnoonan> if you could, you could come up with fake-functors that satisfied the first functor law but not the second
13:11:44 <jordan36363> its just a practice task
13:11:52 <Myrl-saki> mnoonan: unsafePerformIO
13:11:58 <Myrl-saki> c:
13:11:59 <ADG_> you all on linux?
13:12:00 <jordan36363> but i cant do it idk why
13:12:01 <mnoonan> Myrl-saki: yes, well :)
13:12:13 <Myrl-saki> ADG_: Pretty sure yeah.
13:12:39 <ADG_> do you use stack or cabal etc or did sudo-apt get install ghci or quivalent
13:12:48 <Myrl-saki> I use both.
13:12:52 <byorgey> jordan36363: it seems like a pretty useless task though.  Tail recursion is not a particularly interesting concept in Haskell.
13:13:05 <jordan36363> ADG_ I'd just like to interject for moment. What you're refering to as Linux, is in fact, GNU/Linux, or as I've recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components c
13:13:06 <jordan36363> omprising a full OS as defined by POSIX.
13:13:06 <jordan36363> Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called Linux, and many of its users are not aware that it is basically the GNU system, developed by the GNU Project.
13:13:06 <jordan36363> There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine's resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a comple
13:13:06 <jordan36363> te operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called Linux distributions are really distributions of GNU/Linux!
13:13:15 <Myrl-saki> I use stack as a build tool, and ghc{,i} for "scripts"
13:13:18 <shapr> jordan36363: whaat?
13:13:28 <Myrl-saki> shapr: Meme copy and paste fail.
13:13:37 <jordan36363> why fail? :o
13:13:37 <shapr> hrm, ok
13:13:40 <APic> *shrug*
13:13:41 <byorgey> jordan36363: uh, please don't spam the channel with multiple lines of off-topic text.
13:13:47 <shapr> yes, please don't spam
13:13:47 <Myrl-saki> jordan36363: It flooded the channel. :P
13:13:51 <jordan36363> sry it was just a joke
13:13:55 <Myrl-saki> jordan36363: It's fine. c:
13:14:12 <shapr> spamming makes me unhappy
13:14:30 <Myrl-saki> Him being unhappy makes me unhappy.
13:14:42 * Clint squints.
13:14:52 <glguy> happiness is offtopic in #haskell
13:14:59 <shapr> ha! ok then
13:15:25 <byorgey> this channel is so big that we need everyone's help to keep the signal-to-noise ratio high.
13:16:00 <shapr> ADG_: I use stack
13:16:12 <shapr> gutentag delYsid 
13:16:31 <ADG_> does much change in haskell version like python 2 to 3 or java 7 to 8 or c++98 to c++11
13:16:49 <qqwy> How do you ask lambdabot to do pointfree golfing?
13:16:54 <ADG_> because I have 7.10.3 and maybe the latest is 8.?
13:16:56 <shapr> qqwy: the pl command
13:16:56 <qqwy> I believe that was possible, right?
13:17:04 <Tuplanolla> Usually not, ADG.
13:17:08 <shapr> @pl (\x -> x + 1)
13:17:08 <lambdabot> (1 +)
13:17:26 <qqwy> @pl (\n -> n > 0 && n <= 1000)
13:17:27 <lambdabot> liftM2 (&&) (> 0) (<= 1000)
13:17:38 <MarcelineVQ> python 2 to 3 isn't really realted to something like ghc 7 to 8,  python 2 to 3 is more like haskell98 to haskell2010 possibly
13:17:53 <mnoonan> huh, that \x -> x + 1 answer was unexpected. it knows some arithmetic?
13:18:18 <Tuplanolla> @pl \ x -> x `urgh` one -- No, mnoonan.
13:18:19 <lambdabot> (`urgh` one)
13:18:35 <fosterite> @pl \ x -> (+ 1) x
13:18:35 <lambdabot> (1 +)
13:18:41 <Myrl-saki> MarcelineVQ: n+k. :D
13:18:53 <byorgey> mnoonan: apparently it knows that + is commutative.
13:18:58 <qqwy> nice!
13:19:03 <fosterite> @pl \ x -> (* 2) x
13:19:04 <lambdabot> (2 *)
13:19:14 <Tuplanolla> Ah, that much knowledge there is.
13:19:15 <qqwy> @pl \x -> x - 1
13:19:16 <lambdabot> subtract 1
13:19:19 <qqwy> :D
13:19:33 <Myrl-saki> Pffft
13:19:37 <Myrl-saki> Could have used dec.
13:19:40 <Myrl-saki> s/dec/pred/
13:19:50 <ADG_> anyways can anyone tell difference between fmap and <*> (and what do I call the latter one, hidden multiply?)
13:20:01 <Myrl-saki> :t fmap
13:20:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:20:04 <Myrl-saki> :t (<*>)
13:20:05 <qqwy> <*> is apply, right?
13:20:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:20:16 <qqwy> fmap === <$>
13:20:50 <Myrl-saki> > Nothing <*> Just 1
13:20:53 <lambdabot>  Nothing
13:21:02 <Myrl-saki> > Just (+1) <*> Just 1
13:21:05 <lambdabot>  Just 2
13:21:13 <qqwy> Basically, $ is function application to a single structure, <$> is function composition to the structures in containers (i.e. Functors)
13:21:14 <mnoonan> ADG_: <*> lets you apply a *time-varying* function to a time-varying value, going back to the previous discussion
13:21:27 <Myrl-saki> mnoonan: Why time-varying?
13:21:36 <Myrl-saki> (Is this on a DSL?)
13:21:43 <mnoonan> Myrl-saki: we were talking about ((->) Time) as an example functor earlier
13:21:45 <ADG_> oh fmap applies functions inside functors but <*> applies fucntion inside functors to functors?
13:21:51 <Myrl-saki> mnoonan: Ah. c:
13:22:07 <Myrl-saki> ADG_: Mhm.
13:22:24 <EvanR> <*> applies lifted functions to lifted arguments
13:22:44 <ADG_> great!
13:22:58 <qqwy> But you can read 'lifted function' as 'function inside functor'
13:23:01 <qqwy> Or, more accurately
13:23:02 <EvanR> fmap lifts functions
13:23:07 <EvanR> pure lifts values
13:23:08 <qqwy> 'function inside applicative functor'
13:23:22 <Myrl-saki> ADG_: Also, note that not all Functor can be Applicative.
13:23:29 <EvanR> functors arent containers, so inside is weird
13:23:41 <qqwy> functors aren't _neccesarily_ containers
13:23:43 <istvan> I am new to both Haskell and Parsec. I am trying to modify ttps://gist.github.com/m00nlight/2868363ec217f97072b4 to allow inputting variables in addition to numbers (having removed the eval component). If I add a | Var String to Exp, how do I modify the factor to parse variables appropriately?
13:23:55 <qqwy> The set of containers is a subset of the set of functors
13:24:02 <ADG_> I adopt that analogy, this is all new (functional programming')
13:24:02 <EvanR> in general theyre not, and i havent yet seen a precise explanation of what a container is
13:24:06 <Myrl-saki> qqwy: Set.
13:24:10 <Myrl-saki> Map.
13:24:23 <Myrl-saki> (Weeelll... technicallyy...)
13:24:52 <qqwy> @EvanR, @Myrl-saki, okay, okay, it indeed depends on what you call a container exactly
13:24:52 <lambdabot> Unknown command, try @list
13:24:53 <Tuplanolla> Functions are great containers!
13:25:08 <EvanR> anything is a container if you spin it right
13:25:15 <qqwy> @Tuplanolla: Ever heard of the linked-list implementation based on function application?
13:25:16 <lambdabot> Unknown command, try @list
13:25:23 <EvanR> which is where set terminology also breaks down
13:25:37 <Myrl-saki> qqwy: church encoding?
13:25:37 <Tuplanolla> Church encoding or what, qqwy?
13:25:39 <EvanR> "in the remembered set" being diluted way to say something is remembed
13:25:43 <qqwy> Yes, Church encoding
13:25:48 <qqwy> (Didn't remember the name)
13:25:51 <Younder> Functor as the name implies is a operator which takes functions as input and returns a function as output. (functional operator). Currying can make it remember half evaluations, but that des not make it a container.
13:26:09 <Myrl-saki> Younder: Not just functions.
13:26:19 <qqwy> What definition of 'operator' are you using in that statement?
13:26:56 <EvanR> Functor here is the category theory term, not C++ or odd math (perhaps you mean a functional)
13:26:58 <ADG_> does `<*>` reuqire arguments to have same functor context?
13:27:05 <Sornaensis> yes
13:27:20 <EvanR> Functors take types to types and functions between types to functions between types
13:27:26 <qqwy> (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:27:26 <qqwy>  
13:27:31 <EvanR> in a precise way weve been repeating
13:27:33 <qqwy> As you can see, the `f` needs to be the same for both operands
13:28:26 <Myrl-saki> EvanR: That's just an Endofunctor on Hask though. :P
13:29:00 <cocreature> Myrl-saki: functors that are not endofunctors on Hask are further away from containers
13:29:02 <EvanR> im glad they didnt literally call it that
13:29:14 <Myrl-saki> class EndofunctorOnHask
13:29:23 <qqwy> By the way, is there ever a reason to use `liftM2` over `liftA2` (or the monadic variant of anything for which there is also an applicative variant?)
13:29:32 <EvanR> not really
13:29:35 <EvanR> anymore at least
13:29:47 <Myrl-saki> qqwy: Every Monad is an Applicative.
13:29:50 <cocreature> qqwy: liftM2 mostly exists because until recently Applicative was not a superclass of Monad for historic reasons
13:30:04 <rightfold> After lots of head banging I realized analogies are not the right way to go about these abstract interfaces. The only thing that matters is the types + laws. This takes a lot of getting used to.
13:30:22 <qqwy> I know they should function the same, but maybe (besides historic reasons) there are efficiency concerns
13:30:28 <qqwy> which is why I asked
13:30:29 <qqwy> Thanks :-)
13:30:31 <Myrl-saki> rightfold: lmao. You're a step closer now. :D
13:30:55 <qqwy> rightfold: It took me a lot of headache to wrap my head around the taco- I mean monads
13:31:03 <EvanR> yep thats the thing about abstractions, analogies add onto the frame that is there, and then you may not be looking at that frame anymore
13:31:06 <cocreature> qqwy: if there is a difference, liftA2 should also be more efficient
13:31:16 <EvanR> the abstraction is all thats left when you lose the analogies
13:31:18 <cocreature> e.g. it could evaluate its arguments in parallel
13:31:19 <rightfold> Once you've accepted this, learning new such interfaces becomes suspiciously easy. "Oh this is the type? Ok!" "Oh this is the law? Ok!"
13:31:29 <qqwy> "just the monoid in the category of endofunctors, what's the problem", amIright? ;D
13:31:36 <Sornaensis> this is the LAW
13:31:44 <qqwy> cocreature: Thanks!
13:32:05 <Myrl-saki> rightfold: It's funny that peole say that math requires no memorization when it's the exact opposite.
13:32:28 <EvanR> qqwy: theres not a unique such monoid
13:32:29 <rightfold> You can memorize the axioms and then deduce everything every time.
13:32:49 <rightfold> Memorizing the axioms is the trick, here. It's the types + laws.
13:32:51 <qqwy> The weirdest thing in the process of learning Haskell is the moment where you realize that, while the documentation could be improved, most of the stuff you need can actually be found by just searching for the type of the function you are looking for
13:32:55 <qqwy> Types are so descriptive :-)
13:33:11 <Myrl-saki> @djinn a -> a
13:33:11 <lambdabot> f a = a
13:33:15 <qqwy> @EvanR True, true. I think I wrote the quote wrong
13:33:15 <lambdabot> Unknown command, try @list
13:33:15 <mnoonan> Myrl-saki: what is there to memorize? if you have some axioms A, you don't need to remember them.. just think about a free A and you're done :)
13:33:22 <qqwy> It should be *a* Monoid, of course
13:33:32 <rightfold> Axioms are not deductible. They are primitive. Therefore they must be memorized Myrl-saki
13:33:45 <rightfold> deducible*
13:33:48 <Myrl-saki> rightfold: Yes.
13:33:59 <EvanR> what, i just look at my notes
13:34:12 <Younder> A fork is a frk becuase you call it a fork.
13:34:24 <rightfold> EvanR: note is isomorphic to brain
13:34:40 <qqwy> That makes me think: What are you guys opinions about principled typeclasses?
13:34:50 <EvanR> principled typeclasses?
13:34:54 <Younder> Axioms are given. Theorems can be deduced from axioms..
13:35:22 <qqwy> (for who did not read this earlier: http://degoes.net/articles/principled-typeclasses)
13:35:34 <EvanR> stupid )
13:35:39 <EvanR> http://degoes.net/articles/principled-typeclasses
13:36:28 <qqwy> The tl;dr is IIRC that we should check the laws of the type classes we write at compile time, and that it makes more sense to create new type classes like SumMonoid and MultiplicationMonoid instead of using newtype wrappers
13:37:02 <rightfold> qqwy: not any different than {un,}principled data types
13:37:07 <MarcelineVQ> that requires a whole proof language ye?
13:37:25 <cocreature> SumMonoid? that sounds horrible tbh
13:37:28 <MarcelineVQ> could be a fun phd project for some poor student
13:37:39 <EvanR> qqwy: in agda and idris at least, you can use records as instances, the (dependent) type of the record is the interface and can encode the laws
13:38:08 <qqwy> I believe that the idea was to, instead of writing a proof language or use dependent typing, to use a couple of quick tests to check if, at least in the common case, the laws are not broken
13:38:11 <EvanR> and then instances can be checked by the compiler
13:38:20 <EvanR> tests? :(
13:38:45 <rightfold> qqwy: when you are writing a general function on any monoid, whether you're doing sum or multiplication only matters when you use them both together
13:38:46 <cocreature> tests, i.e. verification that’s actually used
13:38:49 <qqwy> 'QuickCheck-style property verification'
13:39:10 <rightfold> qqwy: at which point you should use Semiring, which has the proper law relating addition with multiplication
13:39:14 <qqwy> rightfold: Yes
13:39:22 <EvanR> so we have the technology to talk about this stuff, but dont really want to go fully formal after all because its too much of a pain in the ass
13:39:34 <cocreature> I don’t get it. why do you want an IntAddMonoid typeclass? at that point you can just use Num and use + instead of mappend
13:40:09 <rightfold> Type class instances stand out. They don't appear all over the place in your code. It's easy to check the laws by hand.
13:40:16 <rotaerk> hmm wonder if I should start using literate haskell by default
13:40:25 <rotaerk> starting to see the appeal
13:40:27 <qqwy> Yes, well, this was the part that I was wondering about as well
13:40:46 <qqwy> I am not really sure what the advantages/drawbacks of either approach are
13:41:06 <qqwy> which is why I am interested in the opinions/reasoning of you wonderful folks :-)
13:41:07 <rightfold> Instances also can't depend on runtime values, making it even easier
13:41:15 <rightfold> Unlike, say, the lens laws
13:41:17 <EvanR> there are different use cases for type classes
13:41:33 <EvanR> one of them is to simply use the same name for different things, i.e. +
13:41:43 <EvanR> that doesnt require laws, its just cultural
13:41:58 <EvanR> one of them is to talk about precise law abiding abstractions like Functor
13:42:08 <rightfold> Yeah, using such ad hoc classes in constraints is risky
13:42:14 <EvanR> one of them is to do type level programming, get values from types at runtime
13:42:15 <rightfold> Because you have no idea what they do
13:42:43 <cocreature> EvanR: tbf everybody kind of assumes that the ring axioms hold for + and * so it’s a bit more than just overloading symbols
13:42:45 <EvanR> with numerics, sometimes nobody knows what they do, because its number theory or numerical analysis
13:43:05 <EvanR> cocreature: uh... they do? i dont think so
13:43:25 <rightfold> Float 🤓
13:43:39 <cocreature> well Float breaks everything
13:43:40 <EvanR> + is "addition" and thats about it
13:43:52 <cocreature> I still assume that == is reflexive when I’m writing code in terms of Eq
13:44:07 <EvanR> or perhaps you can assume == is reflexive up to some other form of equality
13:44:19 <ADG_> wtf is going on in `(+) <$> (+3) <*> (*100) $ 5  `
13:44:21 <EvanR> and it doesnt matter if == is strictly doing things different when reversed
13:44:28 <ADG_> > (+) <$> (+3) <*> (*100) $ 5
13:44:30 <lambdabot>  508
13:44:34 <rightfold> ADG_: do you know Reader?
13:44:40 <qqwy> Hehe
13:44:50 <Myrl-saki> Reader is ((->) a)
13:44:52 <qqwy> Floating point arithmetic is... another thing entirely
13:44:55 <ADG_> nope sorry
13:45:02 <rightfold> ADG_: ok
13:45:04 <ADG_> <$> is fmap
13:45:06 <Myrl-saki> :t liftA2
13:45:08 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:45:09 <EvanR> == is probably a good example of something that can be given good laws
13:45:11 <ADG_> <*> is what i know
13:45:26 <qqwy> Wait, why is == not reflexive?
13:45:28 <rightfold> ADG_: (f <*> g) x = f x (g x)
13:45:39 <EvanR> its morally reflexive
13:45:46 <Myrl-saki> ADG_: Turns out that `f <$> g <*> y` == `liftA2 f g y`
13:46:10 <Myrl-saki> Err
13:46:24 <qqwy> morally reflexive? :o
13:46:24 <ADG_> so It fmap's f over g <*> y?
13:46:24 <cocreature> > let x = 1/0-1/0 in x == x -- qqwy 
13:46:25 <Myrl-saki> ADG_: Turns out that `f <$> g <*> h` == `liftA2 f g h`
13:46:25 <EvanR> but you have law violating floating point equality and undecidable equality of reals and functions and....
13:46:27 <lambdabot>  False
13:46:30 <rightfold> So when you have a <$>/<*> chain on functions, what happens is that you get a new function that applies its argument to all the functions in the chain, then combines the result
13:46:47 <eschnett> `f <$> g <*> h` == `(fmap f g) <*> h`
13:47:17 <Myrl-saki> ADG_: And `liftA2 f g h x` = `f (g x) (h x)` for Reader.
13:47:17 <qqwy> @cocreature Now you are using NaN against me
13:47:17 <lambdabot> Unknown command, try @list
13:47:26 <ADG_> oh.
13:47:31 <cocreature> qqwy: don’t blame me, blame ieee :)
13:47:38 <qqwy> True, true
13:47:52 <Myrl-saki> What gcc flag was it again?
13:47:57 <Myrl-saki> -ffast-math?
13:48:00 <EvanR> you realize @-sign is not IRC for highlighting
13:48:03 <qqwy> But rather than saying '== is not reflexive' I'd like to conclude that 'floats do not really implement Eq well'
13:48:05 <eschnett> Haskell should map `NaN` to `Maybe Double`, with an efficient implementation
13:48:21 <eschnett> “this result is not NaN” should have the same standing as “this pointer is not null"
13:48:29 <cocreature> qqwy: right that’s why I said that I assume that == is reflexive when I write code using it
13:48:41 <qqwy> :')
13:48:44 <qqwy> Life is weird
13:48:49 <EvanR> qqwy: you also cant say that particular implementation of == is reflexive
13:48:53 <cocreature> but I also assume that the ring axioms hold when I’m using Num so maybe I’m weird
13:48:55 <Sornaensis> can you force (==) to be reflexive in Idris
13:48:59 <qqwy> I remember the days where I was blissfully ignorant, and did not know that there were undecidable problems
13:49:02 <EvanR> or you cause a logical contradiction
13:49:04 <Myrl-saki> Can we like... consider NaN to be bottom?
13:49:10 <qqwy> xD
13:49:10 <EvanR> Sornaensis: sure
13:49:21 <EvanR> but they dont
13:49:28 <qqwy> @Sornaensis I believe it was a problem before, where they used the fact how NaN work to fool Idris' type checker
13:49:28 <lambdabot> Unknown command, try @list
13:49:31 <Sornaensis> well then what the fuck is the point of Idris
13:49:38 <Myrl-saki> We don't say Eq doesn't work becase `undefined =/= undefined`
13:49:49 <EvanR> Sornaensis: the goal is to make a practical language for writing real programs which can use dependent types
13:50:12 <cocreature> Myrl-saki: then you can now differentiate between different bottoms even outside of IO
13:50:14 <EvanR> no one says Eq doesnt work
13:50:15 <eschnett> NaN is more like Nothing
13:50:24 <EvanR> > Nothing == Nothing
13:50:28 <lambdabot>  True
13:50:32 <Sornaensis> the goal should be 'even more consistent than haskell or bust'
13:50:32 <EvanR> ok good
13:50:55 <EvanR> Sornaensis: if you want mathematical precision, you really need agda or something else
13:51:04 <rightfold> NaN is a bad way of encoding exceptions. But we're stuck with it
13:51:25 <Myrl-saki> Sadly.
13:51:27 <rightfold> Rust deals with it quite nicely IMO, by having a superclass of Eq called PartialEq which lacks reflexivity
13:51:29 <EvanR> you can configure the floating env to crash on NaN instead
13:51:43 <EvanR> rightfold: o_O
13:51:48 <qqwy> We should just use Data.Ratio for everything starting now
13:51:55 <Myrl-saki> qqwy: That's what I do. c:
13:51:59 <qqwy> :D
13:52:06 <rightfold> EvanR: !_!
13:52:15 <EvanR> there are a whole lot of different number types out there
13:52:20 <EvanR> theres no one best number type
13:52:27 <qqwy> I implemented the Ratio library for Elixir, as it was lacking one, based on Data.Ratio
13:52:43 <cocreature> qqwy: hf implementing sqrt for rationals
13:52:44 <qqwy> ... and then I tried doing the same for Idris, and got completely tangled up in messy proofs. I'm not ready for that yet
13:53:03 <EvanR> yeah theres no good rational for idris right now
13:53:10 <EvanR> and there may never be
13:53:16 <Myrl-saki> EvanR: Why?
13:53:22 <qqwy> cocreature: The sqrt for floats is also cheating, exactly because precision is cut off
13:53:30 <qqwy> Actually what we really need is an 'irrational' data type
13:53:30 <EvanR> because people try to encode their feelings of what rationals are into the laws
13:53:35 <qqwy> just move to symbolic math, everyone!
13:53:46 <Myrl-saki> EvanR: I see.
13:53:54 <EvanR> but theres no form of quotient type or homotopy in idris
13:54:04 <rightfold> qqwy: Is there a typed Mathematica-like language?
13:54:11 <rightfold> That would be incredibly rad
13:54:27 <Tuplanolla> There's Axiom, but it doesn't have a user interface, rightfold.
13:54:28 <qqwy> EvanR: It already starts with the fact that `gcd` is not properly proven in Idris right now
13:54:29 <EvanR> qqwy: exact real arithmetic is a thing and is much more useful than symbols
13:54:49 <EvanR> idris is not really on the road to proving all of math
13:54:51 <qqwy> rightfold: That would be amazing, but I am afraid it might not exist, or at least I don't know about it
13:54:59 <EvanR> use agda for that
13:55:01 <qqwy> Tuplanolla: Nice!
13:55:02 <rightfold> Tuplanolla: Thanks, my UI is Vim + Z shell anyway
13:55:05 <rightfold> I'll check it out
13:55:25 <qqwy> But the problem with `gcd` is then again
13:55:29 <Myrl-saki> Tuplanolla: What's that?
13:55:32 <qqwy> that people are not in agreement what `gcd 0 0` should be
13:55:35 <Tuplanolla> I mean it does not even have a working command line interface, rightfold.
13:55:50 <qqwy> That is, mathematicians do not agree
13:56:05 <EvanR> qqwy: youll find that everyone comes up with their own stdlibs in agda, because there isnt one true body of math
13:56:06 <Myrl-saki> qqwy: NaN. c:
13:56:09 <rightfold> Tuplanolla: I don't like REPLs. Does it have a compiler/interpreter? :P
13:56:15 <EvanR> its all subjective
13:56:21 <qqwy> Myrl-saky: Exactly x)
13:56:36 <rightfold> 22:55 <qqwy> that people are not in agreement what `gcd 0 0` should be
13:56:38 <rightfold> Type error
13:56:41 <Tuplanolla> Go find out, rightfold and Myrl-saki.
13:56:45 <rightfold> Tuplanolla: thanks
13:56:49 <EvanR> more seriously, what gcd 0 0 is depends on context
13:56:54 <Myrl-saki> qqwy: data Number = 0 .. | MathematiciansNotSureYet
13:57:02 <Myrl-saki> Ez.
13:57:13 <EvanR> context sensitivity comes up a lot and we have a few tools for that
13:57:30 <EvanR> like the typeclass reflection trick
13:58:12 <qqwy> 'under the divisibility order, 0 is the greatest natural number because every number divides 0' is the reason why `gcd 0 0` ought to be 0
13:58:28 <EvanR> whenever you read a book and it says "in the following pages we use the convention that 0^0 is 1" youve entered a context of convenience. we dont have a perfect answer for this in haskell right now
13:58:41 <qqwy> This is, if you assume that indeed you are looking at the partial order of divisibility
13:59:41 <EvanR> type classes are a huge step in that direction though, which gets use closer to the ubiquitous context of what + means
13:59:53 <qqwy> Yes! I wholeheartedly agree
14:00:47 <EvanR> dependent records in idris try to go farther with it, letting you mix and match implementations first class, but then its common for the checker to get confused about what you mean
14:01:51 <EvanR> if you try to do category theory, the amount of contexts kind of explodes
14:02:02 <EvanR> its amazing these books get anywhere with it!
14:04:03 <qqwy> What books are you refering to/
14:04:04 <qqwy> ?*
14:04:04 <lambdabot> Maybe you meant: v @ ? .
14:04:46 <qqwy> As for Idris: I read the Type-driven development book while it was in MEAP, and now that it is finished I definitely need to read it again since some things have changed
14:04:51 <qqwy> (but alas, no time)
14:04:54 <EvanR> math books open contexts regularly, when turn to a random page and see a symbol, the definition may not be anywhere on that page
14:05:01 <EvanR> it may not even be in the book at all
14:05:54 <qqwy> Ah, math books
14:05:57 <qqwy> Yes, I totally agree
14:07:36 <qqwy> If you ever have time on your hands, here is how you can find out the optimal matrix chain order
14:07:45 <qqwy> in O(n log n)
14:07:48 <qqwy> instead of O(n³)
14:07:51 <qqwy> http://infolab.stanford.edu/pub/cstr/reports/cs/tr/81/875/CS-TR-81-875.pdf
14:08:18 <qqwy> Because Hu and Shing have mapped the problem to triangulation on polygons
14:08:47 <EvanR> 1981 eh
14:08:51 <EvanR> way before haskell
14:09:21 <qqwy> I think this might work great with Haskell
14:10:14 <qqwy> But alas, this paper eludes my comprehension until this day
14:12:16 <Gurkenglas> I git cloned ngless from github, opened a .hs file and emacs's intero gave me http://lpaste.net/691574534490292224
14:13:20 <Gurkenglas> How do I correctly get from a page like https://github.com/luispedro/ngless/blob/master/NGLess/Utils/Conduit.hs#L58 to editing/looking at it in intero?
14:20:55 <qqwy> I have to go
14:20:56 <qqwy> talk to you later
14:21:02 <qqwy> thank you for your help, everyone! :-)
14:21:06 <qqwy> \quit
14:37:20 <mbw> Has anyone been successful with getting the new accelerate-llvm-native backend to work? I have to install llvm4.0, and the devs maintain a ppa which I added to /etc/apt/sources.list . However, I get "Depends: libllvm4.0 (>= 1:4.0-3~) but 1:4.0~svn301550-1~exp1 is to be installed"...
14:38:35 <Gurkenglas> Is there a conduit that'll let through up to n items and then monadically error if any more arrive? (Presumably as a combination of a conduit that lets through n values (take?) and a conduit that merely does a given action once)
14:39:10 <mbw> The only way I ever could get llvm3.9 to work was to build from source, which took 3h with -j4. And then I couldn't even get it to coexist with 3.8
14:50:08 <mbw> Nevermind: https://bugs.llvm.org//show_bug.cgi?id=32876, but was reported today.
14:50:13 <mbw> Just my luck.
14:50:40 <mbw> I am going to kill kittens now.
14:50:49 <mbw> *bug
14:58:25 <Gurkenglas> This one looks good https://hackage.haskell.org/package/conduit-1.2.10/docs/src/Data-Conduit-List.html#isolate is there a version of that does a specified action instead of "loop count | count <= 0 = return ()"?
15:06:32 <Gurkenglas> Man hlint should have a recommendation against reversing an accumulator
15:10:05 <Myrl-saki> Gurkenglas: What do you mean?
15:10:34 <Myrl-saki> Gurkenglas: And I was just browsing HLint recently, and HLint3 seems to have some user-defined stuff.
15:11:50 <Gurkenglas> when something says "go acc | done = reverse acc", that means you shoulda been doing a right fold instead
15:12:37 <Myrl-saki> Ahh
15:13:08 <hvr> Gurkenglas: sounds like the topic of a (small) blogpost
15:13:40 <iqubic> How does on use glirc?
15:13:49 <iqubic> Is there a guide anywhere?
15:13:59 <hvr> iqubic: yes, you need to ping the 'glguy' bot
15:14:20 <glguy> https://github.com/glguy/irc-core/wiki has the most information
15:14:28 <hvr> see, works all the time
15:16:01 <Myrl-saki> lmao
15:22:30 <iqubic> glguy: ping
15:22:41 <iqubic> Trying to ping the glguy bot.
15:22:51 * Clint squints.
15:25:04 <MarcelineVQ> iqubic: he already said <glguy> https://github.com/glguy/irc-core/wiki has the most information
15:25:17 <iqubic> I know.
15:25:25 <MarcelineVQ> alrighty just makin sure :>
15:31:48 <bas313> Hello folks
15:34:23 <bas313> very quick question: why is f :: (Monoid a) => a f = [] not valid?
15:34:34 <bas313> since [] is a monoid
15:36:15 <dolio> [] isn't every monoid.
15:37:07 <dario`> you could say f = mempty
15:40:35 <bas313> @dolio Is my understanding of generics possibly flawed? As in: I read the (Monoid a) part as: satisfieable by any monoid.
15:40:35 <lambdabot> Unknown command, try @list
15:41:42 <glguy> bas313: If 'f' has the type ' Monoid a => a ', that means *forall* types 'a' with kind * that satisfy the constraint 'Monoid a', that 'f' can have type 'a'
15:43:19 <glguy> of course [] isn't such a value that can have any type 'a' satisfying 'Monoid a', it can only have types [b]
15:43:52 <bas313> hmmm
15:44:02 <bas313> *grabs thinking hat&
15:44:19 <glguy> So the correct type signature would be:   'f :: [b]'
15:45:03 <glguy> The *user* of f gets to determine how the type variables should be instantiated
15:48:18 <dario`> it's the difference between \forall and \exists
15:52:25 <bas313> glguy, dario` I have some reading up to do, but thank you for your directions!
15:54:14 <verne> Hello world
16:24:42 <reuben364> How do I disable the persistent squigglely error lines after running haskell-process-load-file in Haskell in emacs?
16:27:23 <ExpHP> What is the relationship between Control.Exception and Control.Exception.Base?
16:28:26 <sm> reuben364: maybe M-x flycheck-mode ?
16:30:46 <mniip> hum
16:31:02 <mniip> has any research been put into generating "lazy" LR parsers for possibly infinite grammars
16:31:06 <ExpHP> oh, never mind, I thought that onException was only defined in  the .Base module for some reason
16:31:38 <ExpHP> ("for some reason" = "I really could've sworn I imported Control.Exception butididn't >_>")
16:33:25 <glguy> mniip: I'd expect you could construct such a lazy parser with Happy
16:36:08 <mniip> no like
16:36:13 <mniip> infinite amount of nonterminals
16:36:24 <mniip> just like you can do for LL
16:45:40 <thang1> LL?
16:54:31 <mniip> thang1, google "LL parser"
16:55:52 <thang1> oooh neat
17:05:31 <jordan3522> hi guys, how can i call two different functions in main?
17:05:50 <jordan3522> because when i write the second function call in a new line i get an error
17:07:22 <koala_man> jordan3522: main = f1 >> f2   you can also use do notation
17:08:35 <thang1> do notation is, ah, a bit more understandable for beginners I think
17:08:51 <koala_man> harder to type in multiple lines on irc
17:08:53 <benzrf> thang1: sure, because it hides what's really going on >:[
17:08:54 <koala_man> main = do
17:08:55 <koala_man>   f1
17:08:57 <koala_man>   f2
17:09:30 <thang1> benzrf: sure, but I'm a fan of steering people away from the idea that you need to understand category theory to write "hello" ++ "world" :p
17:09:31 <Sornaensis> koala_man: please use lpaste for multi line stuff
17:12:19 <jordan3522> koala_man ty it worked!
17:12:28 <koala_man> yay
17:45:11 <Ptival> has anyone had an issue with haskell-mode where the "Collecting type info" feature makes all warnings appear twice?
17:52:47 <lockdown> why are there two haskell websites?
17:53:45 <benzrf> ?
17:55:26 <lockdown> haskell-lang.org haskell.org
17:57:24 <Rembane> lockdown: Haskell-lang is a hm... fork of haskell.org because errr... politics.
17:57:48 <saylu> In Hspec, does anyone know how to evaluate a _list_ of expectations? Instead of having lines within an "it" block that say  "func x `shouldBe` 10", I've zipped two lists together with  "zipWith shouldBe [f x, f y] [10, 11]" to end up with a list of expectations.
17:57:57 <saylu> But now I don't quite know how to evaulate it!
18:00:36 <saylu> Type error is "Couldn't match type `Arg [Expectation]. Expected type: SpecM (). Actual type: SpecWith (Arg [Expectation])`
18:01:21 <benzrf> Rembane: wait, whuh?
18:01:24 <benzrf> i never heard of this O:
18:02:43 <c_wraith> benzrf, it had to do with whether stack got top billing or not. 
18:03:15 <Rembane> benzrf: I might've extrapolated a bit, but well, the politics part is 100% correct.
18:05:14 <lyxia> saylu: sequence (zipWith shouldBe ... ...)
18:05:37 <saylu> lyxia: that's it!
18:05:55 <saylu> geekosaur in #haskell-beginners also helped me find zipWithM_, which is basically sequence_ . zipWith
18:06:10 <saylu> The amount of times I've forgotten about `sequence` ... ugh
19:09:15 <vaibhavsagar_> saylu: zipWith_ also works
19:09:36 <iqubic> I have no idea how one is supposed to make glirc work properly
19:10:40 <tsani> iqubic: how is it not working for you?
19:11:08 <iqubic> tsani: I can't connect to any servers.
19:11:19 <iqubic> I just don't know the right commands to enter
19:13:16 <tsani> iqubic: you configure all your servers in ~/.config/glirc/config and then use `/connect <name>`
19:13:28 <iqubic> I'm going to try that.
19:13:46 <iqubic> What is tsl?
19:14:01 <tsani> iqubic: TLS? The proper name for SSL.
19:14:15 <iqubic> And how do I get the certs?
19:14:30 <tsani> iqubic: you don't need them. They come bundled with the OS.
19:14:35 <iqubic> https://github.com/glguy/irc-core/wiki/Configuration-File
19:14:42 <iqubic> See the example section there.
19:14:54 <tsani> yeah I'm looking there :)
19:14:58 <tsani> Those are client certs.
19:15:07 <tsani> Which are unnecessary for regular connections.
19:15:43 <iqubic> So do I want tls or not?
19:17:13 <tsani> iqubic: it's preferable to use TLS whenever you can, for security.
19:17:33 <iqubic> So I just set TLS to yes, and that's that?
19:18:22 <LordBrain>  no
19:18:30 <LordBrain> conect to port 6697
19:18:33 <LordBrain> instead of the usual
19:18:51 <LordBrain> i think the usual is 6667 right? but for tls, note that last six becomes a nine
19:20:08 <suzu> just want to announce
19:20:24 <suzu> Snap is quite nice
19:20:26 <suzu> really feels like im writing haskell
19:20:28 <suzu> unlike yesod
19:20:30 <suzu> where im writing yesod i feel
19:22:35 <LordBrain> ok, your preference has been filed
19:30:02 <suzu> great thanks
19:30:08 <suzu> ;D
19:42:24 <iqubic> What is Snap?
19:42:47 <iqubic> And why does Yesod feel like a completely different language?
19:43:48 <iqubic> LordBrain: According to the glirc wiki, all I have to do is tell my config that I want to use TSL and glirc takes care of that for me.
19:45:13 <LordBrain> ok
19:45:22 <LordBrain> i dont use glirc, i'm just talking in general
19:45:33 <iqubic> https://github.com/glguy/irc-core/wiki/Configuration-File
19:45:44 <iqubic> see the example section there.
19:46:14 <LordBrain> yesod uses conduit a lot i suspect, that might make it feel different, but i havent actually worked with it much
19:46:18 <byorgey> iqubic: Snap is a kind of ginger liqueur.  https://www.mouth.com/products/snap#variant=558447733
19:46:39 <EvanR> its only tuesday ppl
19:46:40 <sm> yesod provides several EDSLs to reduce boilerplate
19:46:56 <iqubic> What is an EDSL?
19:47:08 <iqubic> E Domain Specific Langauge?
19:47:08 <sm> embedded domain specific language
19:47:14 <iqubic> Ah.
19:47:16 <byorgey> iqubic: an External Difibrillation Service Language
19:47:26 <LordBrain> lol byorgey 
19:47:39 <iqubic> byorgey: LOL
19:48:12 <LordBrain> iqubic, you're kind of new to haskell arent you?
19:53:30 <Zemyla> If p is a Category and a Profunctor, then forall f. lmap f id === rmap f id, right?
19:58:19 <iqubic> LordBrain: Yeah. Been haskelling for only about 6 months now.
20:00:20 <iqubic> glguy: Why can't I connect to freenode with glirc? error Host not resolved: getAddrInfo: does not exist (Name or service not known)
20:00:50 <iqubic> I try issuing "/connect freenode" and get that error.
20:01:04 <koala_man> use irc.freenode.net probably?
20:01:32 <koala_man> freenode is indeed an invalid hostname
20:01:43 <EvanR> nah
20:01:51 <iqubic> koala_man: That worked for me.
20:02:04 <EvanR> freenode isnt the right thing, but you could put it in your hosts file
20:06:57 <iqubic> So I can enter freenode from glirc, but I can't get to the #haskell server.
20:08:18 <glguy> I know it's written in Haskell, but #haskell isn't a glirc support channel :-/
20:09:31 <iqubic> glgu, it's your irc client. Can't you help me with it?
20:10:29 <iqubic> glguy: I just want to chat while using glirc
20:10:33 <glguy> I'm killing bad guys in Nier: Automata (fun game!). All the commands and configuration are on the wiki.
20:11:11 <glguy> and also in client with /help
20:11:51 <dmwit_> Zemyla: I don't think so. It doesn't even seem like it type checks for all `f`.
20:12:18 <Zemyla> :t \f -> lmap f C.id
20:12:19 <lambdabot> (Category p, Profunctor p) => (a -> c) -> p a c
20:12:23 <Zemyla> :t \f -> rmap f C.id
20:12:25 <lambdabot> (Category p, Profunctor p) => (b -> c) -> p b c
20:13:22 <dmwit> Ah, I see. I was incorrectly choosing `id` to have the same type on the two sides of the equation.
20:15:50 <dmwit> Zemyla: I suspect that you will not be able to prove that just from the class laws.
20:16:06 <dmwit> Possibly if you add parametricity you can get it.
20:26:50 <iqubic> Hello Folks
20:26:56 <iqubic> Can anyone see this?
20:27:14 <fosterite> yes
20:27:15 <lyxia> I can't.
20:27:16 <iqubic> I want to check if my glirc connection is working as it should.
20:27:26 <fosterite> congrats, you have rtfm
20:27:42 <iqubic> glguy: Thanks for pointing out my rather dumb mistake.
20:27:49 <suzu> [iqubic] is using a secure connection
20:27:50 <suzu> gj
20:28:40 <iqubic> See, it took a while, because once I got glirc to connect to freenode, I then forgot to do "/join #haskell"
20:29:03 <iqubic> I just type "/connect #haskell" and expected that to work.
20:29:09 <iqubic> Which it didn't
20:29:18 <suzu> lol
20:30:12 <iqubic> Yeah, I feel stupid
20:30:26 <suzu> it's all good
20:30:28 <iqubic> suzu: How did you know that I was using a secure connection?
20:30:29 <suzu> common feeling for haskell devs tbh
20:30:34 <suzu> i did /whois iqubic 
20:31:33 <iqubic> How do I close a msg buffer in glirc?
20:31:37 <iqubic> Is that possible?
20:31:43 <suzu> maybe /close
20:31:44 <suzu> ?
20:31:50 <suzu> just a guess. i don't use glirc
20:32:22 <suzu> stack has been "installing" ghc 8.0.2 for like 5m now
20:32:24 <suzu> grr
20:33:50 <suzu> notify-send is a great tool btw, for those on linux
20:34:01 <qmm> is there an answer to this? https://github.com/elm-lang/projects/blob/master/notes/on-sharing-types.md
20:34:08 <suzu> do-really-long-command; notify-send "cmd complete"
20:34:15 <suzu> easy desktop notification for when your long thing is done
20:35:53 <LordBrain> qmm, well have you looked at cloud haskell?
20:39:08 <LordBrain> not sure if it is applicable or not, but i recall they had some solutions for serializing code... if your client serializes the code for the type, instead of merely the type, then maybe that addresses the issue?
21:10:31 <iqubic> How do I view scrollback in glirc?
21:11:04 <Axman6> page up
21:11:19 <Axman6> may need shift page up on some systems
21:11:33 <iqubic> I don't have a page up key on my keyboard.
21:11:47 <suzu> are you on a mac?
21:11:51 <suzu> if so, fn-up will page up
21:11:53 <Axman6> you will have some way to send a page up though
21:12:03 <suzu> or fn-shift-up
21:12:41 <iqubic> fn-up works. fn-shift-up doesn't
21:12:52 <iqubic> Here's fn-shift-up:
21:12:54 <iqubic> [5;2~
21:12:57 <suzu> lol
21:12:59 <suzu> ok
21:13:04 <suzu> well, good. use fn-up then
21:13:07 <iqubic> I wll
21:13:43 <iqubic> s/wll/will
21:27:43 <iqubic> Hello?
21:27:59 <iqubic> Is this channel just dead right now?
21:28:06 <pacak> iqubic: No.
21:32:04 <iqubic> So, I just realized that the common tail-recursive factorial function is a bit like a stateful computation
21:32:46 <iqubic> Well, it's like a computation that has been repeated over and over and over.
21:43:13 <Squarism> iqubic, yes - its alot more active at other hours. 
21:46:18 <iqubic> So what is the time zone of this place?
21:48:33 <pacak> iqubic: Depends on a person.
21:48:39 <pacak> For me it's midday-ish.
21:48:40 <Squarism> its global - but say its active from like 12:00 -> 04:00 CET
21:52:13 <mty> is there an idiomatic way to write a fn: Monad m => State s a -> StateT s m a
21:54:29 <iqubic> Funny, I'm also working on a state thing.
21:54:45 <iqubic> mty: Isn't that just lift?
21:54:48 <iqubic> :t lift
21:54:50 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
21:56:05 <mty> doesnt compile, mtl has State as an alias of StateT s Identity a
21:56:12 <iqubic> Oh.
21:56:44 <iqubic> You want a way to make it so that Identity can be any monad?
21:57:16 <mty> any would be nice, at this moment I only need it to be a Maybe
21:57:37 <iqubic> There should be a way to do that
21:59:25 <iqubic> Not getting anything useful from hoogle
22:00:42 <mty> problem i think is t m1 a -> t m2 a isn't possible for all m1 & m2
22:01:12 <mty> but t Identity a -> t m a should be possible for all m
22:01:57 <ollieh[m]> Anyone used the Haskell Tensorflow bindings? It uses Stack, and I've managed to get it to build and run the tests, following the instructions, but I can't figure out how to add it to my existing project that uses Stack. They have an example project that you build with a docker container, but it looks like it has no stack.yml. Any ideas how that might work? The bindings are here: https://github.com/tensorflow/haskell and
22:01:58 <ollieh[m]> the example project is https://github.com/tensorflow/haskell/tree/master/tensorflow-mnist
22:12:34 <mty> iqubic: answer was: mapStateT $ return . runIdentity
22:16:52 <jle`> mty: 'hoist generailize' is one common way to do this
22:17:03 <jle`> mty: but the best way to approach this is to not ever use State s a in the first place
22:17:25 <jle`> 'hoist generalize' works for other monad transformers too, in general
22:17:58 <jle`> but again, the right way to fix this is to never use State s a
22:18:03 <iqubic> What's hoist generalize?
22:18:25 <iqubic> jle`: Can you explain that to me?
22:18:28 <jle`> http://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html
22:18:44 <jle`> mty: instead of using State s a, you can use Monad m => StateT s m a
22:18:48 <jle`> which is identical to State s a
22:19:04 <jle`> get, put, modify, etc. are already polymorphic over Monad m
22:19:30 <iqubic> jle`: It's not though. State s a = StateT s Identity a
22:19:47 <jle`> it's isomorphic
22:20:00 <iqubic> Sure it is.
22:20:19 <jle`> by 'identical', i mean that it has all of the same functionality
22:20:20 <jle`> and the same API
22:20:27 <iqubic> Can you write the isomorphism to show me? I'm not sure how the two are the same?
22:20:33 <jle`> except Monad m => StateT s m a is more useful
22:20:38 <jle`> and it doesn't require an explicit hoist
22:20:53 <iqubic> What is a hoist?
22:20:59 <jle`> see the link i sent earlier
22:21:54 <jle`> i suppose they are not isomorphic, but `State s a` is a subtype of `Monad m => StateT s m a`
22:22:11 <jle`> so everything you would want to do with `State s a`, you can do with Monad m => StateT s m a instead
22:22:24 <jle`> so there's no reason to prefer State s a over Monad m => StateT s m a
22:22:38 <mty> jle`: thanks, seems so obvious now that you point it out
22:22:58 <jle`> the type synonym really only exists for pedagogical purposes i think
22:23:20 <iqubic> So StateT is just strictly better?
22:23:43 <jle`> oh, the type synonym exists to make the types for runState/evalState/execState a little nicer
22:24:23 <iqubic> Yeah, that makes sense.
22:24:56 <iqubic> Does runStateT exist? How bout execStateT
22:25:04 <jle`> i know one way to find out
22:25:14 <jle`> check out the documentation for StateT :)
22:25:59 <jle`> http://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-State-Lazy.html
22:27:52 <iqubic> Alright. That looks like it works
22:28:14 <iqubic> It makes complete sense.
22:42:04 <andrei> Is it possible to turn an IO setter and getter into a lens?
22:43:47 <cocreature> andrei: what is an IO setter?
22:44:37 <andrei> cocreature: I have an opaque strucutre with setXY :: X -> Y -> IO X and getXY :: X -> IO Y
22:45:44 <glguy> No, that won't form a Lens
22:45:47 <cocreature> andrei: you can’t make a lens out of that. a lens would give you “set” without IO in the type signature and you can’t escape IO
22:47:31 <andrei> That's sad. There's no way to deal with mutable data with lens aside from zooms?
22:47:48 <glguy> It's not "sad", it just isn't what a lens is
22:48:52 <andrei> glguy: It is. It means that lenses only work for pure structures and they break down whenever things get too complicated.
22:51:50 <kamyar> Hello guys!
22:51:58 <kamyar> PLease help me with this error: http://lpaste.net/355141
22:57:32 <dmj`> kamyar: what is the type of extractBearerAuth
22:57:51 <kamyar> dmj`: extractBearerAuth :: ByteString -> ByteString -> Maybe ByteString
22:58:49 <dmj`> kamyar: is that from wai-extra? I’m seeing "extractBearerAuth :: ByteString -> Maybe ByteString” on the haddocks
22:59:11 <kamyar> dmj`: I have modified it for my special case
22:59:23 <kamyar> dmj`: I wrote another module
23:00:52 <cocreature> change line 7 to liftIO $ do
23:00:57 <dmj`> ^ that
23:02:00 <dmj`> kamyar: also, you’re establishing a new connection to redis on every request
23:02:26 <kamyar> cocreature: Fixed! Thnx!
23:02:36 <kamyar> dmj`: Fixed! Yes I will change it later
23:02:54 <kamyar> dmj`: I will write a redis connection pool at the end
23:04:57 <kamyar> dmj`: Any suggesstion?
23:05:40 <dmj`> kamyar: suggestions on how to write a pool?
23:06:02 <kamyar> dmj`: Yes! And another question: I guess I can omit 'case' in my code. Can u help?
23:06:18 <dmj`> @package resource-pool
23:06:19 <lambdabot> http://hackage.haskell.org/package/resource-pool
23:06:26 <dmj`> is good, specifically the `createPool` function
23:07:09 <dmj`> kamyar: I would get rid of the partial functions, you have some hard pattern matches
23:07:15 <dmj`> Right c <- ….
23:07:21 <dmj`> let Just x = ….
23:08:58 <kamyar> dmj`: Yes! At first I just wanted to omit case, since the output of function is maybe so it is possible to omit case
23:09:19 <kamyar> dmj`: I guess Nothing -> return Nothing does not smell good!
23:09:57 <cocreature> you could use MaybeT
23:29:19 <wz1000> Whenever I try to use ghc-mod I get an error: GHC.PackageDb.readPackageDb: inappropriate type (not enough bytes)
23:29:59 <geekosaur> your ghc-mod is for a different version of ghc, and the binary/cached package db format changed
23:32:41 <glguy> Tonight's new project: A TOML parser using alex/happy with minimal dependencies https://github.com/glguy/toml-parser/blob/master/src/TOML.hs
23:33:35 <glguy> (Yes, I know that it's missing "comments". That's tomorrows task)
23:34:13 <cocreature> at some point I should probably learn alex/happy
23:39:31 <glguy> if you need examples I have parser of various sizes to look over
23:39:44 <glguy> the bigger example is for Lua
23:42:05 <quchen> wz1000: Are you using Cabal or Stack?
23:44:13 <cocreature> glguy: can you get somewhat decent error messages using alex/happy? ghc itself is pretty bad when it comes to parse errors
23:45:00 * paolino jumps around for uncovering type family in constraints
23:46:52 <glguy> cocreature: You can add error productions to the grammer to help with that
23:47:22 <glguy> cocreature: I have some of those in the Lua parser to help find, for example, unclosed {
23:47:34 <cocreature> glguy: thanks, I’ll take a look at that
23:56:13 <wz1000> quchen: Stack
23:57:31 <quchen> wz1000: Then run »stack build ghc-mod« to get the matching one
23:57:43 <quchen> (For your project)
