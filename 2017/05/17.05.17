00:00:10 <reliability> Ah, that's why False.. fails.
00:00:18 <kadoban> Exactly
00:00:26 <quchen> reliability: That’s (.) from the False module.
00:00:40 <quchen> You can make it work by creating that module though!
00:00:58 <quchen> Not that you’d want to.
00:01:20 <ertes-w> helo
00:02:10 <halogenandtoast> > [True ..]
00:02:12 <lambdabot>  [True]
00:16:04 <Hjulle> Are there any generalisations for unzip for other types than []?
00:17:34 <Cale> Functor alone will let you do that -- or do you mean for stuff other than pairs?
00:17:35 <kadoban> Should be able to make one for ... Traversable I guess? Not sure it already exists though, or how concisely it can be done.
00:17:52 <kadoban> Oh, right
00:17:55 <Cale> zip is more interesting
00:18:03 <opqdonut> well there's sequenceA, which will flip two functors
00:18:11 <opqdonut> err applicatives
00:18:21 <Cale> er
00:18:24 <Cale> :t sequenceA
00:18:26 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
00:18:43 <Cale> One is Applicative, the other Traversable
00:18:44 <opqdonut> that'd work if  f a = (a,a), right?
00:18:58 <opqdonut> (yeah I really botched that summary)
00:21:07 <dmwit> jgt: `as` means define an additional qualified name. `qualified` means don't define an unqualified name. They're completely orthogonal.
00:21:29 <opqdonut> > traverse (\(x,y) -> ZipList [x,y]) (ZipList [(1,2),(3,4)]) -- Hjulle?
00:21:31 <lambdabot>  ZipList {getZipList = [ZipList {getZipList = [1,3]},ZipList {getZipList = [2...
00:23:12 <dmwit> :t \xs -> (fst <$> xs, snd <$> xs)
00:23:13 <lambdabot> Functor f => f (a, b) -> (f a, f b)
00:24:52 <opqdonut> yeah but that can be less efficient, right?
00:26:19 <dmwit> Many Functors will admit a more efficient implementation.
00:27:12 <dmwit> But not, like, wildly more efficient. More GC-friendly, mostly.
00:27:28 <phadej> :t unzip
00:27:29 <lambdabot> [(a, b)] -> ([a], [b])
00:28:04 <phadej> :t munzip
00:28:05 <lambdabot> error:
00:28:05 <lambdabot>     • Variable not in scope: munzip
00:28:05 <lambdabot>     • Perhaps you meant one of these:
00:28:19 <phadej> :t Control.Monad.Zip.munzip
00:28:21 <lambdabot> Control.Monad.Zip.MonadZip m => m (a, b) -> (m a, m b)
00:28:29 <merijn> Well, if you end up strictly consuming both lists it'll be pretty significantly faster to only traverse once
00:28:37 <dmwit> good suggestion list, thanks \bot
00:30:30 <dmwit> will it really be that significant? i'm skeptical
00:31:14 <merijn> dmwit: Depends on the size of the list
00:31:35 <dmwit> why?
00:31:55 <merijn> dmwit: Traversing linked lists is slow and you produce a lot of cache churn
00:32:40 <merijn> You have 1 indirection for the value and another for each link, now by traversing it twice you double that.
00:33:11 <merijn> Plus, you keep the list alive longer, causing a larger RES set and slower GC
00:33:49 <dmwit> yes, the GC issue is clear (and I mentioned it above)
00:33:53 <merijn> Does that matter? Probably not if your lists are small. But if you care about speed a 2-3x slow down hurts a lot
00:35:10 <jle`> yes, unzip is particularly useful for lazy linked lists
00:35:21 <jle`> but...are there any other types where it would be as useful
00:36:16 <jle`> lists might be the only commonly used type that would actually benefit from a specialized unzip function
00:36:29 <jle`> instead of just fmap fst &&& fmap snd
00:36:51 <merijn> jle`: Well, tbh, you'd still half the time of most other containers by doing it in one go
00:37:01 <jle`> oh i think merijn missed the first half of the conversation
00:37:33 <jle`> merijn: do you think so?
00:38:01 <jle`> how would you write an optimized unzip for, say, Seq ?
00:38:03 <jle`> or Map k
00:38:15 <merijn> jle`: Traversing a vector twice is always slower than doing so once. It might be negligibly slower for a small vector, but for large ones
00:38:44 <merijn> jle`: I was more thinking of vectors, because everything is arrays when you gotta go fast ;)
00:39:18 <jle`> so you're saying there's a faster unzip for vectors than just \xs -> (fmap fst xs, fmap snd xs)
00:39:28 <jle`> (i'm not doubting you btw)
00:40:44 <jle`> ( but i'd be interested in seeing one :) )
00:40:53 <merijn> jle`: For pure I don't know (then it depends on when the vector is constructed. But assuming a strict unzip, i.e. "unzip :: Vector (a,b) -> (Vector a, Vector b)" where the vectors in the result are fully evaluated, then yes
00:44:05 <jle`> how would it be done?
00:45:05 <merijn> pre-allocate 2 vectors of the origin vector's size. Loop over the original, pull out content tuple, write out to the freshly allocated vectors. Repeat until done.
00:45:39 <jle`> for what it's worth, (fmap fst xs, fmap snd xs) is how the 'vector' package implements unzip for all its pure vector types
00:45:41 <jle`> http://hackage.haskell.org/package/vector-0.12.0.1/docs/src/Data-Vector-Generic.html#unzip
00:45:42 <merijn> Benefits: elements from first vector only indexed once (and sequentially, so nice for cache), similarly sequentially walking the destination vectors is nice for cache too
00:47:13 <jle`> but your method does make sense
00:48:44 <merijn> I mean, you need really big vectors (or need to unzip *a lot*) to get a noticable benefits, but I'm working with *large* arrays a lot and it's interesting how small difference like that can make stuff slow :)
00:51:01 <Mibaz> If anyone uses FRP, do you find yourself using the applicative/category interface or the arrow interface?
00:51:08 <Mibaz> One must be more convenient than the other
00:51:55 <merijn> Well, the entire Arrow has fallen out of favour. It's not quite as versatile/useful as many people hoped and all of it's functionality can be achieved by mixing several more useful classes
00:52:08 <merijn> Mibaz: Specifically: Applicative, Category, and Profunctor
00:53:40 <Mibaz> merijn: ah, that's interesting. I saw some arrow criticism around but I didn't know it was so defunct 
00:54:54 <jle`> most API's that used to be offered using Arrow is now offered using Applicative instead
00:55:07 <merijn> Mibaz: The problem is that for a lot of usecases the "arr" function which lifts an arbitrary function into it greatly restricts it's use.
00:55:20 <jle`> Applicative was introduced after Arrow, and it ended up being a much more natural and usable abstraction
00:55:23 <merijn> Mibaz: Since it requires you to be able to lift any function
00:55:51 <jle`> after Applicative became a dominant abstraction in the haskell ecosystem, Arrow really only serves niche purposes
00:56:12 <merijn> Category takes care of the composition part of Arrows, Applicative takes care of most "applying things to each other", and Profunctor captures the pipeline aspect of arrows
00:56:49 <Mibaz> Well now I feel silly for spending 2 days learning arrows XD 
00:56:57 <Mibaz> good to know anyway, I suppose.
00:57:08 <Mibaz> I need to learn Profunctor, then. Haven't covered it.
00:57:27 <merijn> You can think of a type 'p a' as a "thing that produces 'a's" which gives you a natural interpretation to "fmap :: (a -> b) -> f a -> f b" as something turning a "source of 'a'" into a "source of 'b'"
00:58:51 <merijn> Alternatively, you can take 'p a' as a "thing that consumes 'a's", which gives a natural interpretation to Contravariant's "contramap :: (a -> b) -> f b -> f a" as turning a "consumer of 'b'" into a "consumer of 'a'"
01:00:00 <merijn> Profunctor combines the two into a 'p a b' with a contravariant 'a' and a covariant 'b', so it's a "consumer of 'a', producer of 'b'" (i.e. a pipe) which you can adapt on both ends to consume/produce something else
01:00:21 <merijn> And of course if 'p' is also a Category then we can even compose our "pipes"
01:00:35 <TommyC> Do the vectors for an inner product have to have the same length and if not, how would it work if one is longer than the other?
01:00:36 <merijn> And bam, suddenly you've got most of the funcionality you wanted of arrows
01:01:52 <Mibaz> merijn: Wow, I can see how that's a better abstraction. That's really cool
01:02:23 <Mibaz> Thanks for the explanation!
01:02:28 <jle`> TommyC: are you talking about, like, the mathematical vectors
01:02:36 <Mibaz> Applicative really made an impact when it surfaced, it seems.
01:02:40 <merijn> Mibaz: And then 'lens' comes along and makes Profunctors do a crazy amount of cool/useful things
01:02:51 <TommyC> jle`: Yes.
01:02:54 <jle`> TommyC: mathematical vectors don't have a "length", per se
01:03:09 <jle`> they are members of a vector space, which have a dimensionality
01:03:36 <jle`> and a given vector space might also be imbued with an inner product, which is a closed binary operation in that vector space
01:03:59 <merijn> Mibaz: It did, newcomers seem to take for granted how everything "sensibly fits together", but you have to realise Applicatives weren't invented/discovered until 14 years after the first Haskell version
01:04:14 <jle`> TommyC: so an inner product between vectors of different spaces could be considered "ill-typed"
01:04:23 <jle`> it wouldn't be an inner product, it'd be something else
01:04:32 <TommyC> jle`: Ok I see. Thank you.
01:05:21 <jle`> no problem
01:06:24 <merijn> Mibaz: Actually, maybe longer. I coulda sworn the Applicative paper was from 2004, but wikipedia tells me it's from 2008
01:08:06 <Mibaz> merijn: Wow, it took a while. Applicative seems simple to the ignorant (me) but I'm sure there's more to it for it to have taken that long to dream up
01:08:44 <merijn> Mibaz: Well, it's simple if you have some explain it to you, but someone had to invent it from thin air/steal it from the mathematicians
01:08:57 <jle`> i mean, look how long it took for us to invent 0
01:09:07 <jle`> think 14 years is long? try 1400 years
01:09:37 <merijn> Mibaz: Interesting side note: Haskell didn't have Monads *nor* IO type at first either :p
01:09:38 <Mibaz> lol good point jle`
01:09:57 <Mibaz> and forgive me I just realized I've been spelling your tag jle' 
01:10:14 <quchen> jle`: Most languages don’t even have sums. At that pace, having zero takes another 1400 years
01:10:14 <jle`> it's ok i forgive you
01:10:31 <Mibaz> merijn: how did they... You know... Get program results?
01:10:55 <quchen> Mibaz: A Haskell program was a function String -> String.
01:11:14 <merijn> Mibaz: You had "main :: [Inputs] -> [Outputs]" and treated stdin as a lazy list of input and stdout as a lazy list of output :)
01:12:01 <merijn> The 1.2 report specifies: "type Dialogue = [Response] -> [Reques]"
01:12:33 <Mibaz> aah, got it. Enough to get the job done
01:12:37 <merijn> Where request are things like "ReadFile String" "AppendFile String String", etc.
01:13:02 <merijn> And "Response" was things like "Success" or "Str String"
01:13:40 <jle`> even Functor came after Monad, didn't it?
01:13:53 <merijn> Mibaz: The Wadler paper "Monads for Functional Progamming" was published in 1995, 5 years after the first Haskell version :)
01:14:03 <merijn> jle`: not afaik, but I don't know the exact history
01:14:41 <merijn> Functor's where in 1.3, not sure if Monad was
01:15:35 <merijn> jle`: Monadic IO was in 1.3 too, so seems they were added to the report at the same time
01:15:36 <Mibaz> Haskell without monads... As hard as they were to wrap my head around, I think I dread a world without them more
01:16:09 <merijn> The main reason Functor wasn't a superclass of Monad is because the committee thought it'd be a hassle to force people to write a functor instance if they only wanted the Monad interface...
01:16:15 <merijn> Bit of a historical booboo...
01:16:45 <Athas> They really wanted to avoid success at all costs back then.
01:17:13 <Athas> Haskell has definitely become more awkward for teaching lately, that's for sure.
01:17:28 <merijn> meh, I'm not sure I agree
01:17:32 <Mibaz> merijn: isn't the typeclass hierarchy messed up in a few different ways? Will they eventually push a breaking update?
01:17:38 <merijn> I think it's been neither better nor worse
01:18:03 <merijn> Mibaz: The Functor -> Applicative -> Monad thing was already pushed through. The rest is...no consensus
01:18:22 <Athas> It was always a little awkward for completely new programmers, due to the typeclassery.  The new generic types in the Prelude don't help.
01:18:31 <Athas> Although I only use it for teaching master's students, so they can accept the pain.
01:18:35 <merijn> People argue about classes like Pointed/Apply, but many don't like them. And the Num hierarchy...is not particularly nice, but it's unclear how to improve it
01:18:40 <Mibaz> merijn: ah, got it.
01:18:57 <Athas> merijn: have you seen SubHask or whatever it's called?
01:19:04 <merijn> Athas: Yeah, I agree the noisy types aren't great for teaching. But not something particularly hard
01:19:09 <Athas> It's a greenfield re-implementation of the type class hierarchy.
01:19:11 <merijn> Athas: No?
01:19:23 <Athas> https://github.com/mikeizbicki/subhask
01:19:44 <Athas> But I've only looked at it myself, and I find it hard to obtain a sense of usability from long reams of classes and instances.
01:20:46 <Athas> They really dial up the GHC extension meter, which I'm not unconditionally a fan of.
01:20:52 <merijn> bleh...I really wish cabal had a way to duplicate targets so I wouldn't have to duplicate a section to run tests both threaded and unthreaded
01:21:35 <Athas> merijn: use hpack!
01:21:39 <Mibaz> Thanks for the info guys
01:21:41 <Athas> It can duplicate targets, then override some fields.
01:21:46 <merijn> Athas: I don't want to learn new tools either >.>
01:22:11 <Athas> I felt the same, but I managed to convert my project from cabal to hpack in less than an hour.  It helps that stack supports it transparently.
01:22:23 <merijn> Especially not one based on YAML
01:22:52 <Athas> For this one use case it actually helps.
01:23:08 <Athas> YAML supports exactly the kinds of reference/anchor functionality that allows you to reduce duplication.
01:23:12 <merijn> Athas: Yeah, but not soo much that I feel it's worth it :)
01:23:24 <merijn> Since it's only one target
01:23:39 <ertes-w> Athas: i disagree about that: "Haskell has definitely become more awkward for teaching lately, that's for sure."
01:24:08 <ertes-w> Athas: as someone who occasionally teaches haskell to small groups
01:24:34 <ertes-w> it has not become easier either…  nothing really changed as part of AMP/FTP
01:25:25 <Athas> ertes-w: they are not confused by the more generic types?
01:25:36 <Athas> Maybe it's different for small groups.  I only have lecture/classroom experience.
01:26:09 <ertes-w> Athas: no, you just need to explain how to read the types
01:27:08 <ertes-w> Athas: these days i tend to show them the true type of (+) early on, so i can talk about it, without going too deep into what type classes *really* are:  "for now (Num a) means that we can use (+) on values of type 'a'"
01:27:54 <ertes-w> people get used to reading these types rather quickly…  it's not really that complicated anyway
01:29:19 <ertes-w> what is the canonical sendmail package?  i need to send mails via sendmail
01:29:40 <merijn> ertes-w: Can't you just call out to the commandline mail program?
01:44:06 <ertes-w> merijn: sure, i just thought that a package might help prevent formatting bugs =)
01:44:35 <ertes-w> like when sending headers
02:00:34 <merijn> How do I make Haddock add a kind signature to a newtype?
02:13:23 <[exa]> Hm guys. Is there any good article about monad/comonad combinations?
02:13:51 <merijn> Is there a way to figure out which haddock cabal is calling?
02:13:51 <[exa]> This guy writes about stuff that can be basically imagined as a changeable state http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
02:14:03 <[exa]> ...and invents the method syntax, like co-do
02:14:24 <cocreature> merijn: increase the verbose level until it tells you :)
02:15:08 <merijn> cocreature: oh, turns out I was just mistaking some feature to be sensible...
02:15:23 <[exa]> are there any good (style/syntax) examples for e.g. having a comonad as a state object StateM and modifying it easily?
02:15:37 <[exa]> like, I can hack it together, but it's ugly.
02:15:39 <merijn> cocreature: there's a OPTIONS_HADDOCK pragma, but it only lets you specify a small set of hardcoded options, rather than any commandline option
02:15:55 <merijn> Next question: can I somehow tell cabal which haddock options to use?
02:15:56 <cocreature> merijn: that seems silly
02:16:12 <cocreature> merijn: there is --haddock-options but it might suffer from the same problem?
02:17:42 <merijn> cocreature: No that works, but I dunno if I can specify those in my cabal file somewhere?
02:18:42 <cocreature> merijn: not sure if that’s possible
02:19:02 <angerman> merijn: please don't resort to build-type: Custom.
02:19:13 <merijn> ugh, the inability to selectively qualify names when linking is annoying with cabal :\
02:19:16 <cocreature> angerman: you can take build-type: Custom from my cold dead hands :P
02:19:50 <angerman> cocreature: https://medium.com/@zw3rk/the-haskell-cabal-and-cross-compilation-e9885fd5e2f
02:19:53 <angerman> cocreature: just saying...
02:20:13 * angerman wonders how the reception of that will be today.
02:20:22 <cocreature> angerman: I know why you don’t like it but I just have no idea how I would get llvm-hs working without a custom Setup.hs
02:20:47 <angerman> cocreature: what's the exact deficiency in cabal you work around?
02:21:19 <cocreature> angerman: we query llvm-config in Setup.hs to figure out which flags we need to pass to the c++ compiler and things like that
02:21:23 <angerman> cocreature: and well, yes, llvm-hs is fair game. I don't expect that package to be cross compiled any time soon :)
02:21:30 <cocreature> and which system libraries we need to link against
02:21:59 <angerman> cocreature: that sounds like you want a configure script :) Not that that's much better :)
02:22:28 <merijn> I basically have a module that's exporting the same names, but exception throwing, as alternative to the non-throwing API. So I want to link to the throwing alternative in the haddock docs, but sadly a link to "Foo.Bar.foo" in the documentation of "foo" renders the same as a link to 'foo'
02:22:54 <merijn> I figured I could use "haddock --qual=local" but that also fully qualifies things like "Prelude.Eq" which is annoying
02:23:13 <merijn> So if I want to render a fake fully qualified link I end up resorting to this horror:
02:23:28 <merijn> @"Foo.Bar".@'Foo.Bar.foo'
02:23:28 <lambdabot> Unknown command, try @list
02:25:16 <cocreature> angerman: I hate autoconf even more than Setup.hs :)
02:25:30 <merijn> Everyone hates autoconf
02:25:33 <merijn> Piece of trash
02:25:34 <angerman> cocreature: terrible all around.
02:26:16 <angerman> did I mention I'm going around and sending PRs to projects using configure scripts? Just so they update the ancient config.{guess,sub}? 
02:26:37 <merijn> ok, at least I got what I wanted in the resulting docs now, except for one thing
02:26:40 <angerman> like libffi, autoconf hasn't had an update in years. And the thread on the ML is just saddening.
02:27:02 <merijn> Still haven't figured out how to make haddock render a kind signature where I want it
02:28:41 <merijn> Right now it's rendering the type as "data BroadcastChan d a" in the docs, but that leaves it unclear that the 'd' parameter has kind Direction, rather than *
02:52:33 <ph88^> anyone know how i can get my conduit exception handler to work ?   https://bpaste.net/show/73ee15357694
02:53:22 <ph88^> i fixed the first error btw, it's about error 2 and 3
03:05:59 <Gurkenglas> ph88^, tryC (CB.sourceFile input) returns an Either e0 (), if you want to explicitly discard e0, you can use void (tryC $ CB.sourceFile input)
03:07:42 <Geekingfrog> ph88^: The third error seems to be that sinkFile requires a bytestring, but you're feeding it with your handler, which has en Either e ByteString type
03:08:40 <Gurkenglas> (Oh, the third error indicates that you want that e0 sent into the first type parameter of ConduitM? Lemme rethink then)
03:09:16 <osa1> we don't have a flag for making non-exhaustive patterns warnings errors, right?
03:11:23 <Gurkenglas> -Werror would turn all warnings into errors
03:11:25 <Geekingfrog> osa1: There is a flag to make all warnings errors, and a flag to activate the non-exhaustive pattern warnings
03:13:10 * hackage validationt 0.1.0.0 - Straightforward validation monad. Convenient solution for validating web forms and APIs.  https://hackage.haskell.org/package/validationt-0.1.0.0 (typeable)
03:13:19 <osa1> what I want is: keep warnings as warnings except non-exhaustive pattern warnings, those need to be errors
03:14:16 <Aruro> Archlinux is dropping i686 by the end of the year. Thats nice..
03:14:25 <Gurkenglas> ph88^, what you'd need is "ConduitM i o m (Either e ()) -> ConduitM i (Either e o) m ()", to apply to the left side of .|, right? (And that result type is equal to Conduit i m o)
03:15:43 <Gurkenglas> *"equal to Conduit i m (Either e o)", of course
03:18:10 * hackage validationt 0.1.0.1 - Straightforward validation monad. Convenient solution for validating web forms and APIs.  https://hackage.haskell.org/package/validationt-0.1.0.1 (typeable)
03:23:27 <ph88^> Gurkenglas left ?
03:29:04 <erisco> hrm, Ratio doesn't have a modulo operation
03:30:06 <ph88^> i updated my paste with the question to cut out some noise https://bpaste.net/show/8fe8fb0fb3a8
03:30:35 <merijn> ertes-w: What's modulo supposed to do for a Ratio?
03:30:37 <merijn> eh
03:30:41 <merijn> s/ertes-w/erisco
03:32:27 <quchen_> osa1: GHC 8.2 allows you to make specific warnings errors, -Werror-unused-do-binds for example
03:32:32 <erisco> merijn, the remainder
03:33:18 <osa1> quchen_: wow, awesome. I was considering creating a ticket for this :)
03:34:02 <merijn> erisco: How can a Ratio have a remainder?
03:34:05 <quchen_> osa1: https://downloads.haskell.org/~ghc/8.2.1-rc1/docs/html/users_guide/flags.html#warnings
03:34:09 <erisco> merijn, I suppose made a bit strange because I am using integer multiples
03:34:23 <quchen_> osa1: -Wwarn= and -Werror= syntax
03:35:08 <osa1> quchen_: thanks
03:36:29 <erisco> merijn, but not that strange if you just take intuition from repeated subtraction
03:36:38 <erisco> with a tweak for negatives
03:36:59 <erisco> since you can only subtract something an integral number of times :)
03:37:11 <merijn> erisco: Say who?
03:37:20 <merijn> What's wrong with subtracing a fractional number of times?
03:37:54 <erisco> because it makes as much sense as a list with fractional length
03:38:41 <quchen_> Sure it makes sense, but it won’t give you a useful modulo division.
03:39:02 <erisco> what?
03:39:11 <quchen_> erisco’s rational-modulo reduces to normal modulo if only whole fractions are defined.
03:39:28 <quchen_> fractional-multiples-of-fractions doesn’t even give you something well-defined.
03:39:53 <Taneb> erisco, if you need mod on a Ratio there's Data.Fixed.mod'
03:39:57 <merijn> quchen_: Honestly I find the concept of modulo on rationals to not really sensible anyway
03:40:14 <Taneb> (it's in the wrong place, but it does what I think you want here)
03:40:29 <nohTo> Yeah the modulo on Rational would always give back 0 or the first argument
03:40:50 <quchen_> Each fraction can be written as n*x + r, and to get the r out you use modulo. That’s well-defined, in particular it makes »mod 1« useful to get the fractional part of a number.
03:40:54 <erisco> no, because that is defiend on Real Taneb
03:41:12 <Taneb> erisco, Ratios are Real
03:42:00 <erisco> ehh I don't know what conversion goes on under the hood... not confident in it
03:42:14 <Taneb> None at all
03:42:33 <Taneb> Real is a typeclass, there is a Real instance for Integral a => Ratio a
03:42:45 <erisco> that doesn't rule out conversions
03:44:16 <erisco> minimal complete definition is toRational :: a -> Rational... makes no sense to me
03:46:06 <cocreature> the fact that we define Real as the things that can be converted to Rational is really weird
03:46:14 <hjulle> Why does "hoist.hoist$generalize" give an error, while "hoist$hoist$generalize" works fine? (functions from https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html)
03:46:27 <quchen_> cocreature: The error is on your side, trying to reason about the numeric hierarchy
03:46:37 <erisco> it could be the function I want but it is so strange I don't want to touch it with a 30 foot pole
03:47:03 <Taneb> > (4 % 3) `mod'` (1 % 2)
03:47:05 <lambdabot>  1 % 3
03:47:51 <ertes-w> @let gmod x n | x >= n = gmod (x - n) n | x < 0 = gmod (x + n) n | otherwise = x
03:47:52 <lambdabot>  Defined.
03:47:59 <ertes-w> merijn: ^ (semantically)
03:48:02 <erisco> I have to go through the source and make sure there isn't some conversion to Float or Double tucked in there
03:48:05 <erisco> which I don't want to do
03:48:10 * hackage panpipe 0.2.0.0 - Pandoc filter to execute code blocks  https://hackage.haskell.org/package/panpipe-0.2.0.0 (chriswarbo)
03:48:16 <erisco> way easier to just define the operation I want
03:48:18 <ertes-w> > gmod 3 (5/2) :: Rational
03:48:20 <lambdabot>  1 % 2
03:49:02 <ertes-w> merijn: modulo works for anything that is a totally ordered group
03:56:23 <Sh4rPEYE> Hey. I'm doing the "Monad challenges" from mightybyte and I have trouble setting their MCPrelude up in VSCode. The thing is - the code works (with their custom functions from MCPrelude), but VSCode keeps telling me that it 'Failed to load interface' and refuses to typecheck or autocomplete anything.
03:56:36 <Sh4rPEYE> http://mightybyte.github.io/monad-challenges/
04:02:03 <quchen_> Sh4rPEYE: Failed to load interface?
04:02:06 <quchen_> Is that the full error?
04:03:10 * hackage panhandle 0.2.0.0 - Pandoc filter to unwrap nested blocks  https://hackage.haskell.org/package/panhandle-0.2.0.0 (chriswarbo)
04:04:35 <erisco> > gmod -2 -3 :: Int
04:04:37 <lambdabot>  error:
04:04:37 <lambdabot>      • Couldn't match expected type ‘Int’
04:04:37 <lambdabot>                    with actual type ‘t0 -> t0 -> t0’
04:04:46 <erisco> > gmod (-2) (-3) :: Int
04:04:52 <lambdabot>  mueval-core: Time limit exceeded
04:05:25 <erisco> I wrote this version instead http://lpaste.net/355622
04:06:18 <hjulle> [hoist.hoist] It has the type: hoist :: (Monad m, MFunctor t) => (forall a. m a -> n a) -> t m b -> t n b. I'm guessing that the type checker has some trouble with the forall?
04:07:04 <merijn> hjulle: how so?
04:07:28 <hjulle> <hjulle> Why does "hoist.hoist$generalize" give an error, while "hoist$hoist$generalize" works fine? (functions from https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html)
04:07:45 <merijn> hjulle: oh, I missed that
04:08:05 <merijn> hjulle: Ok, so that forall uses RankN types which aren't inferrable.
04:08:18 <merijn> hjulle: So GHC can't infer the type of "hoist.hoist"
04:08:34 <merijn> hjulle: $ works because there's a hack in the typechecker specifically for RankN types so that $ works
04:09:10 <merijn> hjulle: You could make it work by writing "let foo :: ...; foo = hoist . hoist in ..." if you write an explicit type for foo
04:09:11 <hjulle> But i assume that it is impossible to make the same hack for (.)?
04:09:37 <merijn> hjulle: I'm not sure if it's impossible, but it's certainly undesirable. Even the $ is kinda undesirable, tbh
04:09:40 * hackage validationt 0.2.0.0 - Straightforward validation monad. Convenient solution for validating web forms and APIs.  https://hackage.haskell.org/package/validationt-0.2.0.0 (typeable)
04:09:41 <hjulle> (Without first making RankN types inferrible)
04:10:05 <hjulle> What bad stuff does the $ hack cause?
04:10:14 <merijn> hjulle: When I said "RankN isn't inferrable" I didn't mean "GHC can't do it", I meant "It's theoretically impossible"
04:10:34 <hjulle> Aha, oh.
04:10:55 <merijn> hjulle: The special case of Rank2 can, in theory, be inferred, but the implementation is horrifically difficult.
04:11:06 <merijn> Anything higher than Rank2 is impossible
04:11:39 <merijn> hjulle: It's not so much that it causes bad stuff for programmers, but more of a "no one really knows whether this hack somehow subtly breaks the underlying type theory"
04:12:20 <hjulle> That sounds serious
04:12:36 <phadej> also you want inference to be predicatable
04:12:41 <phadej> what can be inferred and how
04:13:00 <phadej> and higher order inference would "indistinguishable from magic"
04:14:13 <hjulle> merijn: Can I make a generic hoist2 f = hoist (hoist f) by specifying explicit generic types for the different hoists?
04:14:22 <merijn> hjulle: Yes
04:14:41 <merijn> at least, that should be possible, afaik
04:16:59 <torstein> Assume that I have two strict Maps. Is there a way to get the triple (inBoth, justA, justB) faster than doing a union and two differences? 
04:17:44 <LAZAR> How would I handle JSON fields in Aeson which can be multiple types? Like age = 1, age = "1"
04:18:33 <torstein> * i meant an intersection and two differences
04:19:19 <quchen_> LAZAR: Use the Alternative instance of the JSON parser.   age <- parseNumber <|> parseString
04:20:44 <quchen_> LAZAR: In other words, write a parser for each »form«, and then <|> them together.
04:22:36 <phadej> torstein: i don't think so. the time is probably dominated by building new spines for the resulting maps
04:22:45 <phadej> as you cannot share much there
04:23:54 <phadej> so well implemented classify :: [(k, a)] -> [(k, a)] -> ([(k, a)], [(k, a)], [(k, a)]) for ascList's might be about as fast
04:25:28 <Alex______> If you want to compare two lists, and you want to output an error message if they are not equal. And you don't care about the return value if they ARE equal. What would an appropriate return value be? Do I have to classify one?
04:26:15 <Alex______> For example: checkLists :: [a] -> [a] -> (return value?)
04:26:19 <nohTo> Alex: ()
04:26:49 <Akii> Bool? ^^
04:26:50 <ph88^> hey guys, here with conduit exception handling https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#g:7 i noticed that catchC let's it be the same result  r  but tryC changes  r   to  (Either e r)    how can i handle  r   do i need to do runConduit first ?
04:27:55 <nohTo> () has exactly two values, undefined and () which seems to be perfect for this job
04:28:19 <nohTo> But now I'm really curious why you prefer an error over False :-D
04:28:37 <ph88^> are you talking to me ?
04:28:55 <phadej> to Alex______ 
04:29:29 <muesli4> An all-quantified type is probably even better, since it only has one value: undefined.
04:30:31 <muesli4> *Correction: Generically constructible value. ;)
04:51:05 <quchen> Reminds me of GHC’s »the« function.
04:51:36 <quchen> https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Exts.html#v:the
04:55:06 <CoolerZ> is there something above a CLR parsing table?
04:56:23 <CoolerZ> CLR(1) isn't even used LALR(1) is used due to memory constraints
04:57:52 <osa1> what was the syntax to load a test-suite into stack repl?
05:05:10 * hackage ngx-export 0.3.0.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.3.0.0 (lyokha)
05:12:27 <Benzi-Junior> hey, I am working on a webpage using happstack and blaze using the happstack crashcourse as a guide but I can't figure out where in the process you are supposed to fit IO operations e.g. read in a file add a html header to it and use the result as a response
05:12:33 <quchen> angerman: Oh, you’re the author of cabal-doctest
05:12:34 <quchen> Thanks!
05:13:44 <quchen> angerman: I wonder how this translates to Stack though, have you tried to run »stack doctest«
05:13:59 <angerman> quchen: no I have not.
05:14:20 <angerman> quchen: also not, this is not new-doctest :( And it requires a recent doctest build, which hasn't been released yet :-(
05:14:53 <angerman> quchen: and as phadej correctly pointed out, it does not solve all doctest requirements projects might have, so some additional work is needed.
05:15:19 <quchen> Pity! Running doctest right now almost requires a makefile
05:15:38 <angerman> quchen: basically waiting for sol to merge https://github.com/sol/doctest/pull/159 and provide a release :(
05:18:08 <angerman> quchen: based on https://github.com/sol/doctest/issues/155#issuecomment-297595210, I hoped that the time from PR to release would be shorter. In all fairness though, my own PR was rejected on quality grounds by sol, and he took it upon himself to write the PR #159.
05:18:40 <quchen> Polish your PRs a bit more then, eh? :-s
05:20:30 <angerman> quchen: well, I'm content with his PR, it subsumes mine and improves on it substantially. I just wish, it had already been merged and a new doctest version released.
05:21:59 <angerman> quchen: and before you wonder who wrote the cross compilation on raspberry pi posts... that's also me.
05:22:29 <quchen> Yyyyouu!
05:22:48 <quchen> I gave up on the Raspi a couple of years ago, but I might come back to it eventually :-)
05:23:01 <EvanR> closely watching that
05:23:04 <angerman> quchen: let me blow you mind... cabald-dcotest AND the cross compilation posts are related....
05:23:25 <quchen> This just in, Doctest only works on ARM now
05:24:24 <angerman> lol... no :)
05:24:58 <angerman> And well, while it's rpi focused right now, I'll come around to android and ios later (writing posts).
05:25:12 <angerman> after all it's mostly the same.
05:25:21 <Alex_______> Can you not end a line with: error "adsf" ? It always gives me a parse error on the next line
05:25:50 <EvanR> lpaste your particular code
05:26:12 <Alex_______> If (a == b) then error "hello"
05:26:16 <angerman> EvanR, quchen: would you be interested in binary distributions of, say the Raspbian Jessie SDK (including arm-linux-gnueabihf-ghc)?
05:26:25 <liste> Alex_______: there's no else
05:26:40 <liste> > if 0 == 0 then error "wow!" else ()
05:26:41 <EvanR> you cant end an if without an else
05:26:42 <lambdabot>  *Exception: wow!
05:27:12 <Alex_______> Oh okay, haskell noob here. Thanks
05:27:19 <angerman> > (when (0 == 0)) error "wow!"
05:27:21 <lambdabot>  *Exception: wow!
05:27:23 <EvanR> angerman: probably. i have a 32G SD card coming in the mail right now
05:27:26 <quchen> angerman: Right now – not really. I have so many things to do, and Raspi would just be a hobby thing for dead time. And my dead time already has to be distributed between Factorio and Haskell.
05:27:37 <EvanR> and i was worried about the work necessary to get all this haskell to work
05:28:08 <EvanR> factorio, very important
05:28:22 <EvanR> i know a new version is out ;)
05:28:37 <angerman> EvanR: ha. It's just following those two posts :D I'm thinking about preparing bindists after next week. As I want to focus on TH next week, and that would need to be included in the bindist :)
05:28:38 <mschristiansen> Hey, I would appreciate a better way to get GHC on RPI
05:28:49 <mschristiansen> currently compiling with GHC 7.6
05:29:26 <mschristiansen> Tried setting up a cross-compiler, but couldn't get everything working.
05:29:35 <EvanR> angerman: will it include cabal installed everything in hackage? ;)
05:29:43 <EvanR> prior
05:29:48 <mschristiansen> A cross-compilation toolchain in a docker image would also be great!
05:30:01 <sbrg> mschristiansen: there's an article on /r/haskell about rpi cross-compilation
05:30:05 <sbrg> worth a look
05:30:13 <angerman> sbrg: yea, I wrote that :D
05:30:22 <sbrg> angerman: sweet! thanks!
05:30:23 <angerman> EvanR: no, it will not. 
05:30:28 * sbrg is also going to be running haskell on rpi
05:30:32 <sbrg> so that was some good timing :)
05:30:34 <hvr> quchen: "dead time" sounds so dark
05:30:40 <angerman> mschristiansen: why would you need a docker image?
05:30:46 <cdepillabout> I'm seeing intermittent segfaults when using doctest (being called from stack).  Has anyone else seen something like this?  I'm not sure how to go about figuring out why it is going on.
05:31:16 <quchen> hvr: Yes, it’s usually dark when I write Haskell or have robot armies build factories to scale the factory so I have more time to write Haskell.
05:31:42 <angerman> quchen: factories? java much?
05:31:56 <sbrg> FactoryFactoryFactoryProducerFactory
05:32:07 <EvanR> except in factorio, thats literally what it is
05:32:11 <quchen> angerman: I have factory factories, but no factory factory factories, so it’s not real Java.
05:32:55 <sbrg> factorio is great
05:33:00 <sbrg> spent way too many hours on that game
05:33:31 <angerman> sbrg: you are welcome (re: the rpi posts)
05:33:54 <angerman> quchen: I can tell by the lack of Abstract and Enterprise :)
05:33:58 <sbrg> :) hoping to set up some home automation stuff on rpis. it's going to be glorious!
05:34:11 <quchen> angerman: I have lots of concrete.
05:34:45 <angerman> quchen: safty helmets?
05:36:34 <hjulle> An AbstractConcreteEnterprise would theoretically produce concrete.
05:46:06 <Alex_______> Hello, I am trying to check if my graph is an acyclic graph. If someone could take a look I'd be thankful https://pastebin.com/UUFdPB2L
05:48:03 <LKoen> Alex_______: do you know how to do a depth-first search?
05:48:58 <mschristiansen> wrt docker image rpi toolchain: would be an easy way to distribute a working cross compilation toolchain
05:49:40 <Alex_______> LKoen: I haven't tried, but I read that if the toplogical sort fails. There is an acyclic graph. So I thought I could apply it to that instead of doing it in another way
05:49:53 <Sh4rPEYE> Hey. I'm doing the "Monad challenges" from mightybyte and I have trouble setting their MCPrelude up in VSCode. The thing is - the code works (with their custom functions from MCPrelude), but VSCode keeps telling me that it 'Failed to load interface' and refuses to typecheck or autocomplete anything.
05:49:53 <Sh4rPEYE> http://mightybyte.github.io/monad-challenges/
05:50:40 <mschristiansen> a dockerfile also helps making a long list of bash commands reproducible
05:53:08 <merijn> So, anyone using hdevtools + syntastic?
05:53:36 <liste> merijn: me
05:54:08 <exarkun> mschristiansen: I am jumping right in the middle here but Nix + Haskell would seem to be an interesting combination.  Nix has some tools for building Docker images (though they're fairly primitive - then again, so are Dockerfiles)
05:54:29 <merijn> liste: Ever had issues with hdevtools not working on a file (benchmark, test, etc.) if it was marked unbuildable/not configured?
05:54:31 <angerman> mschristiansen: it would basically be like the current ghc bindists or the NDKs that google provides for Android. Docker would confine it to Linux, where it can perfectly fine work on macOS and windows native. Maybe someone will turn it into a docker container, but I do not see the benefit of doing it yet.
05:56:08 <klottie> why can't we pattern match f (x:xs) (x:ys) = ... ? Or is there a workaround?
05:56:23 <opqdonut> you can
05:56:32 <liste> merijn: sorry, no.
05:56:43 <opqdonut> > let f (x:xs) (y:ys) = (x,y) in f [1,2,3] [True,False]
05:56:45 <lambdabot>  (1,True)
05:56:55 <merijn> liste: I figured out the solution already, I just need some testers :p
05:58:41 <liste> merijn: oh, I see. I mostly use stack though these days, but let's try it on a non-stack project :)
05:59:28 <merijn> liste: Basically, I extended the syntastic hdevtools checker to support specifying hdevtools flags in a file local to your project, so you can specify per project flags (such as enabling specific cabal flags in a project)
06:00:13 <miguelq> Hello?
06:00:15 <klottie> I want to match only if heads of two lists are the same.
06:00:41 <liste> klottie: you need a guard for that
06:01:00 <liste> > let f x y | x == y = "yep"; f _ _ = "nope" in f 5 5
06:01:02 <lambdabot>  "yep"
06:01:56 <klottie> allowing the code I've written would be a good language feature imo.
06:02:09 <klottie> thank you btw.
06:02:33 <mschristiansen> angerman, exarkun: A nix expression for a cross compilation toolchain would be great as well, used to run NixOS but setting that up is beyond my skills
06:02:36 <liste> klottie: there's two problems with that: it adds an Eq constraint implicitly, and doesn't make clear which value the variable refers to then
06:03:54 <mschristiansen> angerman: Where is the things you have done for RPI cross-compilation?
06:04:04 <liste> hello miguelq :)
06:04:13 <angerman> mschristiansen: https://medium.com/@zw3rk
06:04:54 <mschristiansen> angerman: great. Will have a look now
06:05:11 * hackage hpqtypes-extras 1.3.0.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.3.0.0 (MikhailGlushenkov)
06:05:59 <angerman> while I do appreciate nix, (and docker to some degree), if I can get things to work without needing either, I prefer it that way. Adding nix on top or docker, is always an option for those who need it. But I prefer not forcing tech on someone unless without absolute need. 
06:10:54 <maerwald> angerman: people always tend to recommend their favorite toys 
06:12:01 <angerman> maerwald: alrighty then, I'll make it require emacs :)
06:12:20 <maerwald> that sounds familiar :P
06:12:23 <tfc[m]> feeble emacs user!
06:12:35 <mschristiansen> certainly _NOT_ a fan of docker
06:12:38 <mschristiansen> :-)
06:13:22 <mschristiansen> ... but it's sometimes useful
06:16:35 <tabaqui> I have Context object from library tls (1.3.8 v) and want to pass it into forked haskell process
06:16:49 <tabaqui> like ctx <- TLS.handshake sock
06:16:56 <tabaqui> forkProcess (someFunction ctx)
06:17:15 <EvanR> you will need to serialize it then
06:17:30 <tabaqui> it seems so
06:18:08 <tabaqui> hmm, ghc never guarantees that forkProcess correctly shares resources, right?
06:18:13 <EvanR> if it can be placed in a compact region, then that region can be sent to another of the same ghc-compiled program, and used there
06:18:35 <EvanR> forkProcess is not going to share any mutable memory
06:18:43 <EvanR> that you can use at least
06:18:56 <tabaqui> how can I check this?
06:19:34 <EvanR> look at this https://downloads.haskell.org/~ghc/master/libraries/html/compact/Data-Compact.html
06:19:42 <EvanR> this feature is like... god
06:19:49 <tabaqui> God?
06:19:51 <EvanR> but its only in brand new ghc
06:19:56 <tabaqui> 8.0.2?
06:22:11 <EvanR> "It is GHC 8.2 only"
06:22:20 <EvanR> https://github.com/ezyang/compact
06:23:16 <EvanR> thinking about it, its probably saner to serialize it if possible and sent it normally
06:23:17 <ertes-w> exarkun: nixpkgs' dockerTools isn't that primitive…  you can do pretty much everything with it, and it's much more tolerable than docker's Dockerfile approach
06:23:59 <erisco> what is a lib that has lists with inductive length?
06:24:00 <exarkun> ertes-w: It's a lot slower and generates images that are a lot bigger
06:24:04 <tabaqui> I doubt https://hackage.haskell.org/package/tls-1.3.10/docs/src/Network-TLS-Context-Internal.html#Context
06:24:06 <exarkun> ertes-w: Apart from that I like it
06:24:33 <exarkun> ertes-w: I made some attempts to write something better but my Nix skills aren't that hot
06:24:33 <ertes-w> exarkun: you might be running an ancient version of nixpkgs, which used to create qemu images
06:24:37 <erisco> guess that'd use smart constructors too which is kinda gross
06:25:06 <exarkun> ertes-w: Oh?  Did that go away?  I didn't know that.  Yes, the version I used used qemu.
06:25:10 <ertes-w> exarkun: try again with a recent version, and you will find that it is MUCH faster than docker =)
06:26:17 <exarkun> ertes-w: That's really good news.  I have this in my CI system to build some Docker images that I still update and use so I'll definitely check out the newer version.
06:26:38 <exarkun> (I think I pinned the CI to a particular version of nixpkgs to avoid it breaking from upstream changes)
06:26:47 <mschristiansen> ertes-w: now you've also convinced me to give it another shot
06:26:49 <ertes-w> exarkun: one final off-topic note: if you use runAsRoot, it will still create a qemu image where it can execute your script…  solution: don't use runAsRoot
06:27:14 <exarkun> ertes-w: Does it come with another solution for the shadow setup stuff that seemed to be 99% of the motivation for runAsRoot?
06:27:39 <ertes-w> exarkun: /join #haskell-offtopic
06:30:28 <erisco> for the purposes of indexing a vector it'd be nice to have a conversion from n % m to Fin m
06:31:17 <erisco> because although it doesn't always make much application sense it is an easy thing to get
06:31:50 <erisco> whereas constructing the needed Fin otherwise can be... impractical
06:32:36 <ventonegro> idris?
06:33:06 <erisco> it'd be easier in Idris but still onerous
06:33:29 <ventonegro> sorry, I thought you were talking about idris
06:33:32 <erisco> yes, I don't actually want it to wrap around, but it isn't the end of the world if it does
06:33:39 <erisco> not a difficult bug to correct
06:34:42 <tabaqui> EvanR: what about Socket or Handle: can any of them be passed to forked process?
06:37:06 <erisco> I am actually not sure what to do about this
06:41:07 <erisco> I guess an Integral to N conversion and a divmod :: Nat n -> Nat m -> (Fin (S n), Fin m)
06:41:07 <ertes-w> tabaqui: sockets can be passed, if you disable the FD_CLOEXEC flag
06:41:24 <ertes-w> tabaqui: Handle is a haskell resource and shouldn't be passed…  you should always pass the underlying FD
06:41:54 <ertes-w> be sure to use hFlush appropriately before you do
06:42:02 <erisco> so annoying... =\
06:42:10 * hackage amqp 0.15.0 - Client library for AMQP servers (currently only RabbitMQ)  https://hackage.haskell.org/package/amqp-0.15.0 (HolgerReinhardt)
06:42:50 <ertes-w> tabaqui: https://hackage.haskell.org/package/unix-2.7.2.1/docs/System-Posix-IO.html#g:6
06:43:21 <tabaqui> ertes-w: so I take Socket, get underlying Handle, get underlying FD and pass FD into forked process
06:43:33 <tabaqui> then child should construct Socket back?
06:45:19 <ertes-w> tabaqui: no, a Socket is already more or less a pure FD
06:45:26 <ertes-w> :t Network.Socket.fdSocket
06:45:28 <lambdabot> network-2.6.3.1:Network.Socket.Types.Socket -> Foreign.C.Types.CInt
06:45:32 <Myrl-saki> http://lpaste.net/8824495426188083200
06:45:35 <ertes-w> tabaqui: ^
06:45:35 <Myrl-saki> Can anyone help with this mess? lmao
06:46:00 <ertes-w> tabaqui: you also need to unset the CloseOnExec flag
06:46:23 <ertes-w> otherwise the socket will be lost as soon as you exec
06:46:54 <tabaqui> ok, looks fine to me, thanks
06:47:52 <ertes-w> tabaqui: note that you can send sockets to other processes via unix sockets
06:48:09 <ertes-w> personally i try to avoid give FDs to execed processes
06:48:15 <ertes-w> *giving
06:48:58 <ertes-w> IMO ideally you don't share your FDs at all and use well-defined interfaces instead, but long-bearded unix enthusiasts might disagree =)
06:49:25 <lyxia> Myrl-saki: you don't need "go", just define three clauses for tallPos and tallSize
06:50:24 <EvanR> the whole FD thing is an interface
06:51:20 <ertes-w> EvanR: you could say that, but you quickly find yourself specifying FD numbers, and as much as i like the s6 suite, that's one of my number one complaints =)
06:51:20 <Myrl-saki> lyxia: Yeah, doing that now.
06:51:23 <Myrl-saki> lyxia: Thanks.
06:51:47 <ertes-w> EvanR: i don't like anything stringly typed, but the typical number-based non-sense of traditional unix i find even worse
06:51:58 <tabaqui> ertes-w: actually, I want to establish ssl session, check fast client private key and if all goes well, then interact with client in dedicated process
06:51:59 <Myrl-saki> lyxia: I'm also pondering with cleanliness vs precision.
06:52:01 <Myrl-saki> lyxia: (w`div`2,) . (`div` length xs) <$> zipWith const [0,h..] xs
06:52:12 <Myrl-saki> lyxia: I could write that as a single iterate, but it wouldn't be clean.
06:52:17 <Myrl-saki> s/clean/precise/
06:52:51 <tabaqui> TVar HashMap contains registered keys so I cannot forkProcess for each accepted socket
06:53:08 <tabaqui> and I cannot pass ssl session to process in ghc 8.0.2
06:55:38 <lyxia> Myrl-saki: try list comprehension
06:56:22 <lyxia> Myrl-saki: isn't    a <$ b <$ c = a <$ c
06:56:58 <erisco> I need more Nat or Fin theorems... I imagine there is a library stuffed with them somewhere
06:56:59 <Myrl-saki> lyxia: Yep, fixed now.
06:57:43 <Myrl-saki> lyxia: On second thought, list comprehension would be better.
06:57:50 <Myrl-saki> Parallel list comprehensions are <3
06:59:03 <Myrl-saki> lyxia: Which would be better. `floor` post process, or `div` everything?
06:59:08 <erisco> I don't know what is coming over me but this is frustratingly overkill
06:59:34 <erisco> but I am barred from using Vec at all because I can't index it then
06:59:37 <Myrl-saki> tallPos (_:xs) = [(w`div`2, h' `div` length xs)| _ <- xs | h' <- [0,h..]]
06:59:47 <lyxia> Myrl-saki: stick with integers if you can
07:00:22 <Myrl-saki> lyxia: Oh. Right. I forgot that repeated addition in FP is evil af. lmao.
07:00:30 <Myrl-saki> lyxia: Thanks.
07:00:47 <sshine> Myrl-saki, huh? :)
07:00:54 <Myrl-saki> :t iterate
07:00:56 <lambdabot> (a -> a) -> a -> [a]
07:01:23 <Myrl-saki> I was thinking of doing something along the lines of `iterate (+ (h/length xs)) 0`
07:01:29 <Myrl-saki> (Doesn't typecheck, I know.)
07:02:27 <glguy> lyxia: I'd expect <$ to be left associative, so that equality wouldn't hold
07:04:19 <lyxia> oh, okay. But I meant it in the context of Myrl-saki's code, where there are explicit parentheses anyway
07:04:41 <sshine> > uncurry (/) $ foldl' (\(total,n) i -> (total+i,n+1)) (0,0) [1..10]
07:04:43 <lambdabot>  5.5
07:05:27 <lyxia> It makes sense to make it left associative now that you mention it.
07:06:56 <sshine> I seem to have come into the middle of a conversation.
07:06:59 <sshine> ignore me.
07:16:33 <tabaqui> c'mon guys
07:16:38 <tabaqui> :t fdSocket
07:16:39 <lambdabot> error: Variable not in scope: fdSocket
07:16:46 <tabaqui> handleToFd :: Handle -> IO Fd
07:16:54 <tabaqui> fdSocket :: Socket -> CInt
07:19:31 <merijn> Poll: Should everything just derive Typeable on the off chance someone might need it?
07:25:33 <merijn> bleh, TravisCI doesn't have GHC 8 yet?
07:25:52 <glguy> merijn: deriving typeable is a no op
07:26:40 <merijn> glguy: Well, I need to annotate things with Typeable or use AutoDeriveTypeable, which only works on newer GHCs :)
07:27:12 <glguy> newer GHC always derive it, no extension
07:27:23 <glguy> but for old GHC sure
07:27:57 <lyxia> not deriving it will encourage people to upgrade :)
07:28:06 <glguy> I like driving Data, Typeable, and Generic for types where I imagine someone might need it later
07:31:13 <merijn> ...
07:31:17 <merijn> Travis is dumb
07:31:30 <merijn> I specify GHC 7.10 and it ends up interpreted as 7.1
07:31:46 <glguy> that is why I won't use YAML
07:31:58 <merijn> Anyone know how to fix that?
07:32:03 <glguy> use hvr's scripts to build on Travis
07:32:09 <liste> merijn: does it accept "7.10" ?
07:32:18 <merijn> liste: No clue how I would find out
07:32:19 <liste> in quotes
07:33:06 <glguy> yes you need quotes, but hvr has a script that generated a multi GHC build script for you using a PPA with all the ghc versions available
07:33:21 <merijn> glguy: What's the advantage of that?
07:34:05 <glguy> it's all advantage, what do you mean?
07:35:13 <merijn> glguy: I mean, compared to adding 2 quotes and being done with it, what do I gain by figuring out how his stuff works? :)
07:35:34 <glguy> caching and building on multiple ghcs
07:35:52 <merijn> I'll have a look tomorrow
07:35:55 <glguy> and not jacking around as much to get Travis working
07:36:01 <glguy> https://travis-ci.org/glguy/th-abstraction/builds/227211273 example
07:41:56 <merijn> glguy: But how did you set that up? :)
07:43:32 <glguy> github.com/hvr/multi-ghc-travis
07:51:56 <_sras_> When using Swagger, how can I make a ToSchema instance of a type match with the ToJSON instance of the same?
07:53:33 <fizruk> _sras_: if you derive both with corresponding options then they should match
07:54:57 <wagerlabs> Good day! What replaces configEvery and and configMaxFail in the modern QuickCheck?
07:55:10 <fizruk> _sras_: also you can test that they match with validateToJSON
07:55:31 <_sras_> Yes. But is there no way to derive it directly from a ToJSON instance. There is this function that does something simialr "sketchSchema :: ToJSON a => a -> Schema", but I am not sure how to make a `Schema` into a `Declare (Definitions Schema) NamedSchema` that the ToSchema instance required
07:59:26 <fizruk> _sras_: well, you could do  pure (Named Nothing (sketchSchema sampleValue))
07:59:53 <fizruk> _sras_: if you're going to use sketchSchema you won't need Declare effects
08:00:19 <fizruk> _sras_: but sketchSchema can't do things like recursive schemas and I think sum types
08:01:02 <sphinxo> How should I be reading binary files?
08:01:38 <liste> @hackage binary
08:01:39 <lambdabot> http://hackage.haskell.org/package/binary
08:01:41 <liste> @hackage cereal
08:01:41 <lambdabot> http://hackage.haskell.org/package/cereal
08:02:16 <liste> (why is 0.9.0.0 in grey on the first page)
08:02:36 <sphinxo> ( I'm going to be using it with harpy to do some dissassembly )
08:03:27 <liste> sphinxo: ^ those 2
08:03:33 <sphinxo> ahh ok
08:03:58 <sphinxo> I already have something to parse the binary, I'm just wondering how to open the file
08:04:45 <lyxia> wagerlabs: configMaxFail more or less corresponds to maxDiscardRatio
08:04:55 <sphinxo> Should I be using text/bytestrings/lazy bytestrings?
08:05:11 <liste> sphinxo: bytestrings
08:05:20 <liste> text is... text. not binary
08:05:23 <wagerlabs> lyxia: Thanks! Is configEvery needed anymore?
08:05:35 <sphinxo> right, that makes sense lol
08:07:00 <liste> sphinxo: maybe also use "pipes", "conduit" or "streaming" for streaming without lazy IO
08:07:37 <sphinxo> ahh interesting
08:07:40 <sphinxo> thanks
08:11:26 <lyxia> wagerlabs: it seems to produce a string to print for every test case... I think such functionality is mostly hidden now.
08:11:38 <wagerlabs> lyxia: Got it, thanks!
08:38:58 <LAZAR> What is the preferred way to parse JSON, Aeson or Parsec?
08:40:50 <lyxia> aeson
08:40:52 <exarkun> I'm using Aeson because I read somewhere online that someone said it was better
08:41:06 <exarkun> But then later I read that you shouldn't use TemplateHaskell and Aeson does
08:41:29 <shapr> I like aeson: https://github.com/shapr/tmuxmarta/blob/master/src/Lib.hs
08:41:44 <WarmCookie> Aeson uses autoparsec. If you parse JSON with parsec, you'll endup rewriting a poorer aeson library :/
08:41:47 <shapr> and I like using template haskell in there
08:41:49 <exarkun> hi shapr 
08:41:59 <shapr> oh hai exarkun! Got any more hard drives I can destroy for you?
08:42:04 <shapr> Are you still in Boston?
08:42:10 <lyxia> exarkun: aeson also has Generics support
08:42:15 <exarkun> I moved north and stopped buying hard drives
08:42:22 <shapr> SSDs now?
08:42:26 <shapr> And Canada?
08:42:33 <exarkun> _almost_ Canada but not quite
08:42:45 <exarkun> probably should have gone the extra 50 miles, would have made a big difference
08:42:47 <shapr> Like, your back yard is in Canada?
08:42:52 <shapr> oh, 50 miles
08:43:12 <sphinxo> What is a nice ( and hopefully performant ) way to go through a list [A,A,C,B,A,B,B,B] and replace [A,A] with [C,B]
08:43:14 <shapr> exarkun: Are you writing neat stuff in Haskell?
08:43:20 <exarkun> come visit sometime (after we build a house though)
08:43:24 <exarkun> shapr: Trying to!
08:43:27 <WarmCookie> exarkun: {-# LANGUAGE TemplateHaskell #-} import Data.Aeson.TH; import GHC.Generics; data Foo deriving Generics; instance ToJSON Foo
08:43:30 <shapr> exarkun: Are you coming to HacBoston in July?
08:43:36 <WarmCookie> exarkun: Saves you a lot of redundant code :)
08:43:43 <shapr> LAZAR: did you see my github link?
08:43:54 <exarkun> shapr: with questionable results, https://github.com/LeastAuthority/s4-wormhole-convergence-agent/blob/haskell/Receive.hs
08:44:16 <exarkun> shapr: I didn't know about HacBoston!  I have a trip to Maine in July though, might be tough.
08:44:18 <shapr> oh neat, magic wormhole client in Haskell?
08:44:31 <exarkun> https://wiki.haskell.org/Hac_Boston does not look useful.
08:44:33 <exarkun> shapr: yea
08:44:36 <shapr> very cool
08:44:42 <shapr> I just started using magic wormhole a month or so ago
08:45:22 <exarkun> I can't find any web presence for hacboston 2017
08:45:26 <exarkun> shapr: cool me too
08:45:34 <shapr> yeah, we need to work on a web presence.
08:45:42 <shapr> I also need to nail down the venue
08:45:48 <sphinxo> What is a nice ( and hopefully performant ) way to go through a list [A,A,C,B,A,B,B,B] and replace [A,A] with [C,B] ?
08:45:56 <tabaqui> I've opened named pipe in ReadMode and use ByteString.Lazy.hGet on it
08:45:59 <exarkun> I have an application server that's going to use magic wormhole to deliver account details as part of a signup process
08:45:59 <shapr> sphinxo: pattern matching?
08:46:14 <tabaqui> and receive exception hPutStr: illegal operation (handle is not open for writing)
08:46:25 <tabaqui> how can it even possible?
08:46:46 <sphinxo> shapr: the thing is the list might look like [B,B,B,A,A]
08:46:46 <shapr> sphinxo: have you done pattern matching on lists?
08:46:50 <sphinxo> yes
08:46:57 <shapr> sphinxo: you can match on multiple elements
08:47:01 <sphinxo> Yeah I know
08:47:08 <exarkun> WarmCookie: http://www.stephendiehl.com/posts/production.html has a section about TemplateHaskell
08:47:16 <exarkun> WarmCookie: that's really all I know about the subject
08:47:49 <shapr> exarkun: want to write an article for The Monad.Reader about lessons learned while writing a magic wormhole client?
08:47:54 <WarmCookie> exarkun: You don't need to know more than that to use Aeson's TH / Generics.
08:47:59 <sphinxo> shapr: the sequence [AA] I want to match on could be anyway through the list
08:48:03 <sphinxo> not just the first 2 elements
08:48:05 <lyxia> WarmCookie: the TemplateHaskell pragma and the Data.Aeson.TH are unused in your example
08:48:25 <WarmCookie> lyxia: Oh, strange, I remember needed both. Maybe my cases were more involved.
08:48:27 <shapr> sphinxo: right, so I'd recursively walk the list and pattern match on those two elements.
08:48:51 <exarkun> shapr: I have trouble writing about things as I'm learning them and I have trouble believing the things that I already know are interesting enough to write about
08:49:25 <WarmCookie> lyxia: Oh nevermind, I was mixing lenses in there too :P
08:49:30 <shapr> huh, I keep stream of consciousness notes and questions while I'm coding, and then later I'm able to turn those into something more structured.
08:49:34 <mivael> > [A,A,C,B,A,B,B,B]  -- sphinxo, it does not look like a valid list btw
08:49:36 <lambdabot>  error: Data constructor not in scope: Aerror: Data constructor not in scope:...
08:49:56 <shapr> exarkun: I think the second part is rarely true, but I don't know how to convince you of that.
08:50:16 <exarkun> shapr: I have a text file full of such things from the last project I worked on.  It's probably doomed to sit there until someone smashes the ssd it's sitting on.
08:50:34 <shapr> exarkun: write them up?
08:50:44 <shapr> exarkun: or you could write up something and send it to the editor of The Monad.Reader?
08:50:56 <exarkun> that project wasn't Haskell-y
08:51:06 <shapr> This magic wormhole client looks Haskell-y
08:51:09 <exarkun> so it's a lot of stuff about buggy Python libraries
08:51:17 <shapr> ha
08:51:17 <exarkun> yea, this project is pretty Haskell-y
08:51:22 <exarkun> shapr: this is my first Haskell project
08:51:28 <shapr> even better!
08:51:38 <shapr> lessons learned! challenges encountered!
08:51:59 <tabaqui> oh, damn, ImplicitParams...
08:52:52 <shapr> I need to get all the TMR websites updated so people don't send submissions to ezyang.
08:52:54 <exarkun> shapr: okay I'll start taking notes
08:53:02 <shapr> exarkun: yes please!
08:53:06 <exarkun> huh ezyang, I know that name
08:53:08 * shapr hops excitedly
08:53:22 <exarkun> I think he was a Twisted GSoC student maybe?
08:53:27 <shapr> ezyang: Turns out the most recent presenter at Atlanta Functional Programming went to high school with you.
08:53:35 <shapr> ezyang does many things
08:53:41 <exarkun> oh he's here
08:55:52 <vimalloc> Big noob here. Is it possible to have a basically opposite of the Maybe bind (>>=)? Something where if a 'Just x' exists, it just keeps passing that value through, but if it is Nothing it returns the result of a different function?
08:56:10 <geekosaur> :t fromMaybe
08:56:11 <lambdabot> a -> Maybe a -> a
08:56:37 <geekosaur> > fromMaybe 5 (Just 2)
08:56:39 <lambdabot>  2
08:56:53 <vimalloc> awesome, thx guys
08:56:54 <geekosaur> well, ok, it loses the Just, but then that would happen anyway
08:57:12 <tabaqui> I dunno, is it expected behavior with ImplicitParams
08:57:17 <tabaqui> you can do such thing
08:57:27 <tabaqui> foo :: (?a :: Type) -> b
08:57:35 <tabaqui> foo = let ?a = something in ...
08:58:06 <tabaqui> and ?a from function signature will be used in body
08:58:16 <tabaqui> (instead of compile error of course)
08:58:21 <erisco> My brain just exploded
08:58:39 <APic> kkk
08:58:45 <APic> Shall i call the Ambulance?
08:58:53 <APic> Eris ♥
08:58:57 <tabaqui> it was usual bug, I named variable with the same name and forgot about it
08:59:06 <shapr> Hail Eris!
09:03:06 <ongy> the compiler should tell you, when you shadow something
09:09:07 <tabaqui> hm, that is true..
09:09:40 * hackage zm 0.2 - Language independent, reproducible, absolute types  https://hackage.haskell.org/package/zm-0.2 (PasqualinoAssini)
09:09:41 <tabaqui> *note to use -Wall -Werror in all projects
09:11:10 * hackage dhall 1.3.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.3.0 (GabrielGonzalez)
09:13:01 <orion> ^ that's a really neat project
09:15:02 <Myrl-saki> Oh wait what.
09:15:06 <Myrl-saki> You can't curry type synonyms?
09:16:04 <glguy> Myrl-saki: That's correct. They don't introduce distinct types, so it doesn't make sense to leave them partially applied.
09:16:29 <mauke> if you have 'type Foo a = ...', then you can't have bare Foo without applying it to something
09:16:32 <glguy> so if you've got something like: type MySyn a b = SomeType a Int b
09:16:41 <mauke> but sometimes you can get away with 'type Foo = ...'
09:16:41 <glguy> Then reduce it to: type MySyn a = SomeType a Int
09:17:40 * hackage roc-cluster 0.1.0.0, roc-cluster-demo 0.1.0.0 (NCrashed): https://qbin.io/yp580ndx
09:18:18 <Geekingfrog> orion: did you use dhall for some application ?
09:20:17 <srk> I'm interested in that as well, possibly with nix integration
09:24:02 <orion> Geekingfrog: I did. I use it to configure my NFC-reading-door-unlocking program on my Raspberry Pi.
09:24:35 <ongy> orion: do you have something unclonable?
09:26:32 <orion> unclonable?
09:27:02 <ongy> something that someone that just walks 20cm past you can't copy from your key
09:27:25 <orion> Unfortunately it isn't.
09:27:48 <ongy> and you trust it with your door? :)
09:28:24 <orion> At the time the system was constructed, NFC on the Pi was in its infancy.
09:28:56 <ongy> "on the pi" that side shouldn't be to bad, the main problem is your key
09:29:15 <orion> Well, and the NFC reader.
09:29:23 <orion> It needs to support whatever protocol is being used.
09:29:49 <ongy> I'm not that familiar with NFC, can't you just treat it as byte stream?
09:32:07 <orion> No. NFC is a complicated mess of standards, and a lot of things are specified in hardware.
09:32:22 <ongy> urgh
09:32:34 <orion> https://en.wikipedia.org/wiki/ISO/IEC_14443
09:34:20 <ongy> well, I can't tinker with my door enough to do such things, but I wouldn't go with anything that can't run a proper crypto protocol...
09:34:49 <ongy> partially because I know the people at our security chair, and I wouldn't be surprised if some of those collected any and all nfc/rfid card data they can sniff
09:34:58 <WhereIsMySpoon> How do I find the source of functions like !! ?
09:35:22 <WhereIsMySpoon> bit difficult to google lol
09:35:26 <ongy> @index (!!)
09:35:26 <lambdabot> GHC.OldList, Data.List, Prelude
09:35:33 <ongy> look in Data.List
09:35:43 <WhereIsMySpoon> i got this
09:35:44 <WhereIsMySpoon> https://hackage.haskell.org/package/base-4.3.1.0/docs/src/Data-List.html
09:35:55 <WhereIsMySpoon> but genericIndex is an overloaded version?
09:35:57 <WhereIsMySpoon> so it isnt the same
09:36:23 <WhereIsMySpoon> plus im using prelude anyway..not data.list
09:36:49 <geekosaur> what?
09:36:54 <ongy> WhereIsMySpoon: https://github.com/ghc/ghc/blob/master/libraries/base/GHC/List.hs#L857 that's a bit of guesswork from where you are, it's GHC.List (which may or may not be obvious) and then search for that file
09:36:54 <MarcelineVQ> the @index thing is a command to the bot
09:38:00 <WhereIsMySpoon> ok that definition makes no sense to me :P
09:38:05 <WhereIsMySpoon> can someone walk me through it, please? :)
09:39:33 <geekosaur> if you want to track this down yourself, you start at the haddock for the library providing the function (here https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/base-4.9.1.0/Prelude.html or as appropriate for the base in your ghc version)
09:40:13 <geekosaur> and, what is confusing about this definition?
09:40:28 <WhereIsMySpoon> so the first line is fine
09:40:32 <WhereIsMySpoon> then xs     !! n | n < 0
09:40:36 <geekosaur> oh, looking again there's several metaconfusions (like, USE_REPORT_PRELUDE)
09:40:45 <WhereIsMySpoon> im just ignoring the metacode
09:41:04 <WhereIsMySpoon> so im used to doing stuff like myFunc [] = error “empty list”
09:41:09 <WhereIsMySpoon> and enumerating the conidtiions like that
09:41:26 <WhereIsMySpoon> or case xs of // [] -> error “empty”
09:41:34 <geekosaur> right. first line rejects negative indices, second rejects any index against an empty list
09:41:44 <WhereIsMySpoon> i get that it rejects them, but how
09:42:02 <WhereIsMySpoon> why is xs first ,then !!, and whats with the “n | “
09:42:13 <geekosaur> that is a guard
09:42:22 <geekosaur> patterns cannot test values, they test structure
09:42:30 <geekosaur> (specifically, which constructors are present)
09:42:50 <geekosaur> so if you want to check if you have a negative number, you must use a guard, which is a boolean condition
09:43:09 <geekosaur> so we bind the index to n and then use the guard to test if that index is negative
09:43:39 <geekosaur> the rest of it: you define functions as prefix (func foo bar = ...) and operators as infix (foo <**> bar = ...)
09:43:49 <geekosaur> because that is how you use them.
09:43:56 <Aruro> geekosaur: constructors can be values
09:44:34 <geekosaur> they can; but you can;t match a bunch of them all in one swoop, like negative numbers vs. the horrid hack that lets you pretend numbers are constructors
09:45:23 <WhereIsMySpoon> im sorry im still hung up on the “xs !! “ bit, does that mean “on the condition there’s a list given”
09:45:25 <geekosaur> WhereIsMySpoon, also, just as you can change those uses (func `foo` bar     instead of    foo func bar; (<**>) foo bar      instead of       foo <**> bar), you can do the same in definitions
09:45:38 <geekosaur> no. you are defining an infix operator called (!!)
09:45:53 <WhereIsMySpoon> i get tha
09:45:53 <WhereIsMySpoon> t
09:46:19 <WhereIsMySpoon> oh
09:46:20 <WhereIsMySpoon> i see
09:46:31 <geekosaur> you use it as an infix, so you *define* it as an infix. 'xs !! n' here is defining operator !! with parameters xs on the left and n on the right
09:46:32 <Aruro> WhereIsMySpoon: did you read some books on haskell sytax? its really very primitive and easy
09:46:45 <WhereIsMySpoon> Aruro: im trying to follow lyah and do some haskell exercises
09:46:55 <WhereIsMySpoon> and the third exercise was to make an elementAt function
09:47:24 <WhereIsMySpoon> OH
09:47:26 <WhereIsMySpoon> that |
09:47:31 <WhereIsMySpoon> i think is confusing in that place
09:47:38 <geekosaur> as I said, that is a guard
09:47:48 <WhereIsMySpoon> shouldnt it be xs !! n then on the next line the |
09:47:55 <geekosaur> you can do that but don't have to
09:47:58 <WhereIsMySpoon> or have the guard n < 0 on the next line
09:48:02 <WhereIsMySpoon> gah
09:48:06 <WhereIsMySpoon> that confused me :D
09:48:22 <Aruro> yeah its more readable too
09:48:57 <Aruro> WhereIsMySpoon: have some alternative sources like haskell report , that you dont feel trapped in lyah
09:49:11 <Aruro> everything is really defined in like 20 pages of text
09:49:32 <WhereIsMySpoon> ok so
09:49:42 <geekosaur> you can jam everything on one line      xs !! n | n < 0 = error "negative index" | n == 0 = error "too large" | ...
09:50:08 <geekosaur> and yes, that does get unreadable in the general case, but in cases like this one it generally comes down to individual tastes
09:51:32 <WhereIsMySpoon> i think this all makes sense now
09:52:01 <WhereIsMySpoon> so if you need to make a check on something that is being applied to something else in the function, you need to put a guard on it
09:52:09 <Aruro> WhereIsMySpoon: also xs !! n syntax is confusing, (!!) xs n = something might sound better
09:52:13 <WhereIsMySpoon> so you can put a condition next to it
09:52:45 <WhereIsMySpoon> Aruro: doesnt matter to me :)
09:52:47 <WhereIsMySpoon> but ok
09:58:31 <geekosaur> btw it might help to read "|" as "such that" or "where" (although the latter doesn't work well for some uses of "|", and also can be confused with the keyword "where")
09:58:59 <geekosaur> I also prefer "such that" because it better fits the formal-math slant of Haskell
09:59:14 <geekosaur> (in the sense of code-as-notation)
10:00:40 <Aruro> WhereIsMySpoon: did you read this ? :) http://learnyouahaskell.com/syntax-in-functions
10:02:43 <saml> is there EDSL for orchestrating rabbitmq jobs?
10:03:17 <saml> let's say you have 20 different rabbitmq workers.  you want to send message to worker B when worker A finishes with result
10:03:21 <saml> sounds like monad
10:05:13 <zachk> you put the rabbitmq stuff in the Process monad from cloud haskell, though I am not sure thats exactly what you want
10:05:17 <zachk> you could put
10:05:47 <saml> i guess it's more of a DAG  (Makefile)
10:06:22 <saml> tasks depend on each other.. so I write a DAG declarative way and magic happens. messages start flowing through rabbitmq and workers start receiving and emitting messages
10:06:40 <vimalloc> If I'm reading this right, it looks like mplus is defined as <|>. In my code, is there a convention to use `mplus` or `<|>` (in the maybe monad specifically, if that matters)
10:06:46 <saml> it's like shell (bash). but each command is rabbitmq worker
10:07:06 <LAZAR> Someone has an idea how to parse a json object to a abstract data type? see this snippet: http://lpaste.net/355624
10:07:31 <saml> @src mplus
10:07:31 <lambdabot> Source not found. I am sorry.
10:07:37 <saml> @type (<|>)
10:07:39 <lambdabot> Alternative f => f a -> f a -> f a
10:07:52 <vimalloc> I found it searching in here: http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#mplus
10:08:55 <saml> mplus = (<|>)  -- yup
10:09:15 <vimalloc> is one considered more readable or more common to use?
10:09:29 <saml> i tend to mix things. sometimes   function.. some times binary operator
10:09:34 <lyxia> I use <|>
10:09:51 <geekosaur> mplus is MonadPlus, <|> is Alternative which is more general but also a decade or so newer
10:10:07 <saml> if you are expressing alternative  <|> is good (I see a lot in Parsec)
10:10:24 <vimalloc> thanks :)
10:11:17 <LAZAR> someone here has experience with aeson?
10:12:31 <glguy> LAZAR: Always ask your actual question
10:12:34 <geekosaur> they did
10:12:40 <geekosaur> [17 17:06:44] <LAZAR> Someone has an idea how to parse a json object to a abstract data type? see this snippet: http://lpaste.net/355624
10:12:55 <glguy> My comment stands
10:13:36 <LAZAR> geekosaur: i just wonder if you can do stuff like this at all
10:13:44 <geekosaur> LAZAR, so what you do is give User a FromJSON instance
10:15:04 <LAZAR> geekosaur: you mean something like instance FromJSON User where   parseJSON = withObject "user" $ \o -> do     name           <- o .: "name"     mail            <- value .: "mail"
10:15:14 <geekosaur> yes
10:15:22 <LAZAR> makes sense
10:15:23 <geekosaur> and then it will be used when you ask it to handle a User
10:15:47 <geekosaur> (it is already doing this, in fact, but using the FromJSON instance for String which is trivial)
10:17:32 <LAZAR> geekosaur: but how do i call the parse then inside Entry?   
10:18:35 <geekosaur> hm, actually I think what you have there is slightly wrong... but I don't normally do this stuff :/
10:18:45 <lpaste> glguy pasted “Fixes for haskell.vim” at http://lpaste.net/355625
10:21:20 <geekosaur> LAZAR, right, you have a bug / thinko there, you want `o .:` everywhere you have `value .:`
10:22:49 <geekosaur> as for the other, you just do the .: like you were. (.:) will know that it is being asked to parse a User and look up the appropriate FromJSON instance
10:23:11 <geekosaur> just like when you ask it to parse a String value and it looks up `instance FromJSON String where`
10:25:39 <LAZAR> geekosaur: no, the JSON is actually nested, this is an example: https://pastebin.com/ERfLFmLF
10:25:55 <geekosaur> yes, it is nested, that;s why it delegates
10:26:27 <geekosaur> "oh this is a String, recurse on FromJSON String" "oh this is a User, recurse on FromJSON User" ...
10:27:25 <geekosaur> also possibly confusing youy: in most languages, the result type can't be used to pick an "overloaded method". in Haskell, the result type *can* be used to pick a typeclass instance
10:28:00 <geekosaur> so if you use (.:) to read a User, the implementation for User will be used
10:28:20 <LAZAR> geekosaur: You are right and its actually easy! npmUser         <- value .: "_npmUser" does the trick if the User has an approriate FromJSON instance
10:28:27 <geekosaur> yep
10:29:57 <tabaqui> I can pass any *simple* haskell object into forkProcess action as argument, right?
10:30:32 <tabaqui> *simple* means "is union or multiplication of any enums and *basic* haskell data"?
10:30:47 <tabaqui> *basic* means chars and ints
10:31:15 <geekosaur> I have no idea what you are asking
10:31:18 <geekosaur> :t forkProcess
10:31:19 <lambdabot> error: Variable not in scope: forkProcess
10:31:24 <geekosaur> whoops, right
10:31:30 <tabaqui> System.Posix.Process
10:31:37 <geekosaur> :t System.Posix.Process.forkProcess
10:31:38 <lambdabot> IO () -> IO System.Posix.Types.ProcessID
10:32:07 <tabaqui> I have "foo :: Int -> [Char] -> Enum -> IO ()"
10:32:08 <geekosaur> you pass it an IO action. if that is a function with parameters, you can just pass those parameters
10:32:34 <geekosaur> forkProcess clones the entire process memory; it does not serialize data and pass it around
10:33:01 <geekosaur> that is only needed if you are also replacing the process memory image (e.g. with executeFile)
10:33:26 <tabaqui> I don't call "exec"
10:33:30 <geekosaur> exactly
10:33:44 <tabaqui> but I want pass, f.e HashMap String String or smth other
10:33:46 <geekosaur> so there is no serialization needed and therefore no restriction on what data you can use in the subprocess
10:33:50 <tabaqui> maybe it contains enumerates
10:33:57 <ReinH> LAZAR: you should read this tutorial https://artyom.me/aeson
10:34:01 <tabaqui> sounds logical
10:34:02 <ReinH> It covers all of your questions.
10:34:07 <tabaqui> thx
10:34:34 <geekosaur> but this also works both ways: since it cloned the memory image, changes made in the child are not visible in the parent
10:35:16 <geekosaur> you *would* need to explicitly serialize and pass back data. there's nothing like Chan for processes; that only works for threads, which share the same memory image
10:36:01 <tabaqui> that's fine
10:40:25 <LAZAR> Ummm anyone has an idea how to parse a List using Aeson?
10:40:58 <sbrg> LAZAR: did you read the tutorial mentioned above?
10:42:06 <ReinH> It covers that question too.
10:42:42 <ReinH> in fact, decoding a list is one of the first examples.
10:42:54 <LAZAR> sbrg: ReinH It mentions that Vectors can do that
10:43:51 <ReinH> https://artyom.me/aeson#very-basic-decoding-and-encoding
10:44:30 <ReinH> It's literally the first example of decoding in the tutorial.
10:44:36 <ReinH> So please actually read the tutorial.
10:44:39 <LAZAR> ReinH: Well I mean parsing lists of abstract data types, not primitives
10:45:31 <LAZAR> ReinH: Also i cant really translate the ghci examples to FromJSON instance
10:46:23 <ReinH> decode json :: Maybe [Foo] will decode a list of Foos, where Foo is a datatype with a FromJSON instance.
10:46:56 <ReinH> Ok, what about all of the examples that aren't in ghci?
10:47:04 <ReinH> Please actually read the tutorial.
10:47:38 <WarmCookie> What could've been Haskell alternatives for ad-hoc polymorphism other than type classes? I'm interested in a general ideas that are not even necessarily seen in other popular languages.
10:48:00 <erisco> anyone using reflex on Windows for web dev?
10:48:17 <WarmCookie> Bonus points if it's not text-based :P
10:49:12 <ReinH> WarmCookie: type-directed name resolution a la Idris or Agda
10:49:26 <ReinH> records
10:49:42 <WarmCookie> For example, I've ported the idea of ADTs to a Flow-Based language as components that lets you do pattern matching and whose outputs are each of the cases in a sum or product type.
10:49:44 <ReinH> modules
10:50:45 <WarmCookie> Now I'm interesting in giving that flow based language a type system that goes beyond parametric polymorphic and introduce maybe some form of type hierarchy / ad-hoc ness.
10:51:23 <WarmCookie> ReinH: How would this translate to a flow-based system (if you're familiar with those) ?
10:51:51 <shapr> data flow language?
10:51:52 <geekosaur> LAZAR, I think you're still tripping over result type polymorphism
10:52:20 <ReinH> F# has an inlining feature that can be used for ad hoc polymorphism
10:52:34 <geekosaur> you dont need to pass a parameter to tell it what to do like in languages where only parameters can be used to select a polymorphic variant
10:52:45 <WarmCookie> shapr: Components with inputs and outputs. Components communicate via messages which is more or less your control-flow.
10:53:16 <ReinH> Maybe you want row types?
10:53:18 <ReinH> idk
10:53:41 <ReinH> I wouldn't reach for ad hoc polymorphism first if I were designing a type system.
10:53:42 <WarmCookie> ReinH: I don't know. I'll just absorb and research all the name dropping you're doing c:
10:53:44 <ReinH> It's too... ad hoc.
10:54:05 <ReinH> WarmCookie: well, you asked for examples :p
10:54:52 <ReinH> Subtyping or row polymorphism might be more to your liking
10:55:29 <ReinH> which are subtly different (explained nicely at https://cs.stackexchange.com/questions/53998/what-are-the-major-differences-between-row-polymorphism-and-subtyping)
10:57:05 <WarmCookie> So far I have this nice editor that lets you create components. These have input and output ports. Then you build an application out of such components, connecting the ports of interests. It's quite similar to Erlang so far; but there's no textual representation. I added a mechanism to define types (even parametric ones) and check types (it's not very sophisticated).
10:57:43 <WarmCookie> ReinH: So then the question was "should I start grouping types", if so, I probably want them to have common interfaces to work with values of such types...
10:57:57 <WarmCookie> And that where the visual model breaks a little.
10:58:24 <ReinH> right, you want the type of square holes for square pegs to fit in
10:59:42 <WarmCookie> That's not a bad analogy.
11:00:58 <_sras_> What is the local pragma to suppress orphan instance warnings?
11:01:41 <Tuplanolla> It's `{-# OPTIONS -fno-warn-orphans #-}`, _sras_.
11:02:01 <geekosaur> ...depending on definition of "local"...
11:02:14 <geekosaur> there is in general no way to suppress warnings per occurrence
11:02:19 <WarmCookie> ReinH: So the input of components would have constraints of what types are allowed and what aren't. And you could make arbitrary group of types.
11:02:20 <Tuplanolla> That one's translation-unit-local.
11:02:22 <geekosaur> ...yet
11:02:34 <ReinH> structural subtyping + parametric polymorphism might be an interesting point in the design space.
11:02:47 <WarmCookie> ReinH: From then on, a module could supply a user with all the components that would be needed to work with values of such types.
11:02:53 <ReinH> the structure of the output must match the structure of the input
11:03:11 <ReinH> or at least a sub-structure must, and the rest of the structure is discarded
11:03:34 <WarmCookie> Mhm. I still want to leave the job to the user to combine the right blocks to manipula such structure though.
11:03:42 <WarmCookie> Kinda like we have to wrap/unwrap newtypes in haskell.
11:03:53 <WarmCookie> It's annoying, but it's principled.
11:04:18 <ReinH> e.g., an output of Point3D { x, y, z : Double } to an input of Point2D { x, y : Double } could either drop z or be a type error.
11:04:41 <WarmCookie> Oh... that's substructural typing right?
11:04:48 <ReinH> structural subtyping
11:04:51 <WarmCookie> Or structural subtyping I think? I
11:04:54 <WarmCookie> I keep mixing both :P
11:05:09 <ReinH> Point2D is a subtype of Point3D
11:05:31 <ReinH> or do I have that backwards? All Point3Ds are also Point2Ds.
11:05:46 <WarmCookie> I get where you're going either way.
11:06:03 <ReinH> my brain can't seem to figure out which way the <= points today.
11:06:36 <WarmCookie> How limited is structural subtyping?
11:07:07 <ReinH> structural subtyping with parametric polymorphism subsumes row typing with parametric polymorphism
11:08:04 <ReinH> structural subtyping can be a bit more expensive than nominal typing
11:08:58 <ReinH> It basically incurs the equivalent of Java's interface problems, where field lookups are no longer constant time.
11:09:16 <ReinH> Haxe is an interesting language with structural subtyping http://haxe.org/
11:09:32 <WarmCookie> Will check that too.
11:10:04 <matrium> hi, I'm using attoparsec to parse a text file. What's the best practice to ensure that a sequence is consumed entirely and the last char has a certain property? E.g. the last char can not be a dot "liftA2 (<>) (pack <$> many (char '.' <|> pnChars)) (singleton <$> pnChars)"
11:10:06 <ReinH> Ocaml also has a sort of weird implementation of structural subtyping
11:10:40 <matrium> the given example will just consume one single char
11:10:43 <WarmCookie> ReinH: I have a feeling doing the implementation will bother me and make me change my mind.
11:10:49 <Tuplanolla> Use `eof`, matrium?
11:10:51 <WarmCookie> ReinH: But I'll still give it a look.
11:11:05 <shapr> exarkun: silly question, why'd you choose Haskell for this magic wormhole client?
11:11:27 <WarmCookie> ReinH: Much appreciated. Thanks for the brainstorming :)
11:11:29 <ReinH> WarmCookie: this might be interseting http://www.dtic.mil/dtic/tr/fulltext/u2/a512414.pdf
11:11:41 <matrium> Tuplanolla: its not the end of the file. it's just a chunk inbetween
11:11:48 <ReinH> I don't know the authors but CMU is usually a source of reputable research.
11:11:49 <Tuplanolla> Oh, huh.
11:12:05 <LAZAR> someone has an idea why Aesons encode espaces all "s?
11:12:14 <exarkun> shapr: because I've put off learning Haskell for too long and this was the next small, self-contained component that arose for the larger project
11:13:05 <shapr> exarkun: that makes sense, thanks
11:13:31 <shapr> exarkun: learned anything interesting? thoughts on Haskell and/or ecosystem?
11:14:51 <exarkun> shapr: Learning Haskell itself is interesting. :)  And I still have a _long_ way to go on that.
11:15:11 <exarkun> shapr: Of the ecosystem, so far, I'm a bit disappointed with the quality of library documentation.
11:15:25 <shapr> exarkun: soft docs like tutorials?
11:15:43 <shapr> or hard docs like what a bit of code actually does?
11:15:51 <exarkun> shapr: I think the hole could be filled satisfactorily in a number of ways.
11:16:20 <exarkun> shapr: A lot of libraries don't include any usage examples, nor API docs, not any form of prose laying out the big picture.
11:16:30 <exarkun> shapr: When all three of those are missing, it's kind of a sad time.
11:16:58 <shapr> so you'd like to see more big picture docs on how to use a particular library?
11:17:00 <exarkun> shapr: Maybe the situation is better in Haskell where one _can_ learn a lot of useful stuff from type signatures... but I'd still rather have some form of docs.
11:17:18 <exarkun> Sorry I meant "nor any form ..."
11:17:24 <exarkun> shapr: Any of the three would be welcome
11:17:29 <Tuplanolla> What do you call a library with complete and comprehensive documentation?
11:17:33 <sbrg> exarkun: yeah, unfortunately that's way too common. the types do help a lot, but having to dig through the entire library to find the "entry point" is still a hassle
11:17:40 <Tuplanolla> A book.
11:18:11 <exarkun> Tuplanolla: system metaphor failure
11:18:44 <geekosaur> LAZAR, becuase that's what you need to do when it's in a string. somehow I think we're now on the reverse of the original problem: you want to stitch JSON together manually by generating chunks and slamming them together, instead of using ToJSON instances
11:19:12 <shapr> Most common problem I have with Haskell libs is figuring out which ones are still actively maintained and/or recently updated.
11:20:06 <shapr> I'd like to see the hackage section list ordered by most recently updated
11:20:14 <shapr> and maybe even a sparkline of updates over the past year
11:20:24 <exarkun> it's tricky
11:20:35 <exarkun> sometimes it's old because it's done and works
11:20:42 <shapr> Yup, I use some of those.
11:20:44 <LAZAR> geekosaur: well i thought the toJSON instances would handle parsing stuff to a normal Json?
11:21:57 <geekosaur> maybe you should explain exactly what you are doing that you don't want strings to be escaped. the only thing I can think of is manually blatting stuff into JSON --- but that is what ToJSON instances do for you, and they don't generate garbage the way manually slapping stuff together can
11:22:55 <shapr> exarkun: what about reverse dependencies? count of recent updates/uploads that depend on this library?
11:23:16 <LAZAR> geekosaur: I have a Json file which I read and modify and create a new one
11:24:22 <exarkun> shapr: I don't know what the solution is.  How about API documentation coverage %, a place to put a link (or hackage-hosted?) to prose documentation, a place to put a link to a CI system?
11:24:27 <exarkun> shapr: maybe all of the above
11:25:06 <shapr> hm, those are good ideas
11:25:45 <geekosaur> right, the aeson way is you deserialize the json to haskell adts, update those, and generate new json
11:26:13 <exarkun> GitHub, DockerHub, etc let people put "stars" on projects.  I think that's _probably_ bs... but who knows.
11:26:22 <exarkun> I don't have a Hackage account so I don't know how that would work
11:26:30 <Myrl-saki> :: (a -> b) -> (a,a) -> (b,b)
11:26:30 <geekosaur> it sounds to me like you want a regex-style solution, just edit the json in place. which is nice and simple until you hit a case where it's impossible to create a regex that will change only and exactly what you want to change. which will happen specifically because json is nested
11:26:50 <geekosaur> (it's the same problem as trying to parse html with regex, in fact)
11:27:00 <Myrl-saki> I'm thinking of using `join (***)
11:27:17 <shapr> exarkun: do you want a hackage account so you can upload your mw client?
11:27:22 <Myrl-saki> @pl join (***)
11:27:22 <lambdabot> join (***)
11:27:25 <Myrl-saki> Welp.
11:27:33 <geekosaur> exarkun, shapr: hackage 2 was supposed to add stuff like this
11:27:35 <Myrl-saki> @pl (\(x,y) -> (f x, f y))
11:27:35 <lambdabot> f *** f
11:27:41 <geekosaur> I don't know where/why that is stalled
11:28:26 <geekosaur> oh, it's not, it;s there. did you see the "votes" field?
11:28:49 <exarkun> shapr: I'm sure I'll get there eventually... but I guess my point was more that the proportion of anonymous to authenticated Hackage use is probably very high compared to systems like GitHub and DockerHub
11:28:52 <geekosaur> (which leads to the next problem: a feature is useless if nobody knows about it or it otherwise isn't used)
11:29:07 <exarkun> shapr: Maybe the ability to star projects would motivate millions of Haskell users everywhere to create Hackage accounts?
11:29:21 <Myrl-saki> @pl join (***) fromIntegral . (width_ScreenSize &&& height_ScreenSize)
11:29:21 <lambdabot> join (***) fromIntegral . (width_ScreenSize &&& height_ScreenSize)
11:29:37 <james999> geekosaur: exactly. or if you google for a feature, it says the feature works on your system, then you try the feature and it's not there. 
11:29:40 <geekosaur> Myrl-saki, @pl can only remove points you declare with a lambda
11:29:44 <exarkun> geekosaur: Oh yea I do see "votes".
11:29:54 <Myrl-saki> I'm kind of stupid.
11:30:03 <Myrl-saki> That's `on` + liftM2.
11:30:09 <geekosaur> because it has no way of knowing whether width_ScreenSize there is a point or a library function
11:30:16 <Myrl-saki> Oh wait no. It's postprocessing.
11:30:30 <exarkun> geekosaur: There's a lot of 0 vote projects. :/
11:30:37 <geekosaur> yes, that was my follow-on
11:30:39 <Myrl-saki> geekosaur: Ah, thanks.
11:30:44 <geekosaur> [17 18:28:30] <geekosaur> (which leads to the next problem: a feature is useless if nobody knows about it or it otherwise isn't used)
11:30:57 <exarkun> ah, yea.
11:31:13 <geekosaur> hackage 2 kinda slipped in without much fanfare, I expect few people have noticed that field buried below the fold
11:31:19 <geekosaur> it'd work better up at the top
11:31:23 <exarkun> If there were a hackage view that sorted by vote count, that might encourage more people to vote
11:31:37 <exarkun> (but I'm certainly of mixed feelings about whether that kind of popularity contest is actually a good thing)
11:32:42 <sphinxo> I want an pointer sized, unsigned integer type, is this Word?
11:33:22 <WarmCookie> sphinxo: You want WordPtr from Foreign.Ptr.
11:33:34 <WarmCookie> >> "An unsigned integral type that can be losslessly converted to and from Ptr. This type is also compatible with the C99 type uintptr_t, and can be marshalled to and from that type safely."
11:34:02 <sphinxo> ahh ok, I don't need it to be convertable to Ptr
11:34:05 <sphinxo> just the same size
11:34:08 <Tuplanolla> Do we have a foreign type for `bool` btw?
11:34:15 <WarmCookie> sphinxo: Why the same size as a pointer then?
11:34:53 <WarmCookie> Tuplanolla: bool in C is actually a macro for _Bool is is degined to be an integer with a minimal width.
11:35:32 <WarmCookie> *which is specified
11:35:40 <vimalloc> I'm having trouble finding good data about this on google, maybe someone could link me to an article? Behind the scenes, how does haskell handle syscalls? Does it wrap glibc? Or is that stuff hard coded in the compilier? Is there an interface for performing your own syscalls?
11:35:45 <Tuplanolla> What's that then, WarmCookie?
11:35:45 <vimalloc> (asking purely out of curiosity)
11:36:36 <shapr> geekosaur: so hackage 2 is what's online now?
11:36:43 <geekosaur> yes'
11:36:50 <WarmCookie> Tuplanolla: Where I'm going is that you don't need a seperate representation. Whatever's the machine word size works.
11:37:05 <sphinxo> WarmCookie: well I've been told to generally use something pointer sized when dealing with container sizes or indexing, maybe this doesn't apply to haskell
11:37:15 <Tuplanolla> Oh, I see.
11:38:05 <shapr> vimalloc: strace a binary?
11:38:06 <geekosaur> sphinxo, in a certain sense it does not. because pretty much everything in Haskell is represented via a pointer anyway
11:38:26 <sphinxo> ahh
11:38:41 <geekosaur> vimalloc, that's the Foreign Function Interface https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
11:38:48 <vimalloc> shapr: Wouldn't strace just show that they syscall was happening? Not how it was called in haskell?
11:38:52 <Tuplanolla> Why does `sizeof (bool)` produce `1` though, WarmCookie?
11:39:01 <vimalloc> (my strace foo is not the strongest)
11:39:07 <vimalloc> geekosaur: thanks!
11:39:36 <shapr> vimalloc: A handy ghc program I have links to libc.so.6, I just ran ldd on it.
11:40:05 <geekosaur> there are a very few syscalls implemented as compiler primitives, but most things even in base are done via FFI
11:40:08 <WarmCookie> Tuplanolla: Implementation specific. One byte fits the criteria of an integer with a width >= than 1 bit.
11:40:51 <geekosaur> Tuplanolla, pretty much what WarmCookie just said. some platforms will use a machine word, others will use a (char), etc. there are arguments for and against each approach
11:41:15 <Tuplanolla> So which Haskell type corresponds to the right choice?
11:41:25 <geekosaur> (the argument against (char) is you can't trivially convert code that relies on the old K&R convention that a boolean is an (int) that is either zero or nonzero)
11:41:50 <Myrl-saki> @pl (\x -> sample sizesE >>= (\s -> foo . bar s))
11:41:51 <lambdabot> const ((foo .) . bar =<< sample sizesE)
11:42:07 <WarmCookie> Does Haskell FFI has a int_leastN_t ?
11:42:14 <Myrl-saki> @pl (\x -> sample sizesE >>= (\s -> foo . bar s $ x))
11:42:14 <lambdabot> (sample sizesE >>=) . flip ((foo .) . bar)
11:42:23 <geekosaur> which is kind of a bletcherous convention, but sadly there's a *lot* of ancient code in existing in-house codebases
11:44:01 <mauke> geekosaur: what's an example of a syscall that's built into the compiler?
11:44:22 <geekosaur> I'm thinking of STM primops
11:45:12 <geekosaur> hm, maybe not STM, at that. I think there are primops whose implementations involve OS level mutexes though
11:45:23 <mauke> wouldn't those still go through libc?
11:46:35 <geekosaur> somehow I thought when I said "... compiler primitives, but ... via ffi", I was talking about that distinction, not direct kernel call vs. libc
11:48:10 <hexagoxel> is there some prettier alternative to using "case () of" to obtain a where-block that has access to bindings from do-notation?
11:48:30 <hexagoxel> i don't like the order that using let would bring.
11:50:20 <Myrl-saki> @pl (\x -> sample sizesE >>= (\s -> pure . foo . bar s $ x))
11:50:20 <lambdabot> (sample sizesE >>=) . flip (((pure . foo) .) . bar)
11:51:44 <Myrl-saki> @pl (\x -> (\s -> foo . bar s $ x) <$> sample sizesE)
11:51:45 <lambdabot> (<$> sample sizesE) . flip ((foo .) . bar)
11:51:51 <Myrl-saki> There's still a flip. :|
11:52:28 <glguy> you're not actually supposed to put the output of @pl into source files generally
11:53:17 <Myrl-saki> glguy: I... actually do..
11:53:26 <glguy> oops!
11:53:28 <Tuplanolla> It's not too late to stop.
11:53:32 * geekosaur 's rule of thumb is, if he needs to use @pl to pointfree something, it should not be done pointfree
11:53:39 <sbrg> ^
11:53:48 <sbrg> Myrl-saki: every time you do, a kitten dies
11:53:53 <sbrg> stop killing kittens
11:54:08 <maerwald> geekosaur++
11:54:17 <WarmCookie> hexagoxel: Not really... maybe digustings fix \case ?
11:54:56 <maerwald>  @pl is just a funny toy, not an actual tool
11:55:29 <Clint> it's useful for learning things
11:55:43 <maerwald> never learned anything from it
11:56:13 <Clint> maybe you asked it the wrong questions
11:56:31 <maerwald> the output is mostly just weird and overcomplicated, because the algorithm is not very smart
11:56:57 <geekosaur> also there are very few cases where a pointfree expression can't be replaced by an appropriate lambda
11:57:09 <geekosaur> probably there are none,
11:57:13 <geekosaur> s/,//
11:57:25 <WarmCookie> hexagoxel: I actually have an idea. Is there a first-order function that tells you if a pattern is matching?
11:57:42 <Tuplanolla> There was a really good pointfree deduction involving a function and a list a few days back.
11:58:09 <Tuplanolla> Does anyone remember it or do I have to go dig it up?
11:58:18 <Clint> clearly you should dig it up
11:58:42 <WarmCookie> hexagoxel: Someone made fist-class-patterns, this might be overkill for what you want :P
11:58:56 <WarmCookie> hexagoxel: I was thinking -XMultiWayIf or something.
11:59:18 <WarmCookie> case () of is a common idiom :/
11:59:43 <kadoban> geekosaur: When I was new it would occasionally tell me sane things that I didn't know (that weren't horrors)
11:59:54 <EvanR> MultiWayIf is way better
12:00:02 <EvanR> for bools
12:00:36 <geekosaur> I did say rule of thumb, not natural law >.>
12:01:41 <kadoban> Right. I just mean that it's probably only a rule of thumb once you get past the beginning stages. Meaning I wouldn't be surprised if it's a useful tool for beginners.
12:02:06 <Tuplanolla> @pl \ f g (x, y) -> (f x, g y) -- bimap
12:02:06 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
12:02:32 <Tuplanolla> It wasn't exactly that, but it was as good.
12:03:08 <kadoban> That's impressively horrible
12:03:51 <Myrl-saki> lol
12:03:54 <hexagoxel> WarmCookie: good ideas, but i don't seem how they help. "where" on MultiWayIf does not seem to work, and LambdaCase does not actually help with the additional indentation.
12:03:54 <sbrg> no one read that incantation aloud. i'm pretty sure you'll summon some beast from the depths of hell
12:04:05 <kadoban> Hah
12:04:25 <WarmCookie> hexagoxel: Mhm. I liked the challenge but I'm not finding much that could be exploited.
12:04:26 <EvanR> oops, why didnt you say something sooner
12:06:39 <hexagoxel> WarmCookie: I'll just have to convince enough people that "where on do-statements" would make for a completely useful and warranted extension.
12:08:09 <athan> I think `where` could be useful for any expression, not just definitions, but that's just me
12:08:13 <WarmCookie> hexagoxel: I'm tempted to agree on one point: Not because of its necessity, but because I like the idea of capturing the environment and still being able to define the function elsewhere than within that do block.
12:08:21 <athan> like `\x -> x * second where second = 100000`
12:08:39 <WarmCookie> hexagoxel: But wouldn't one argue that you should just pull off that logic into it's own top-level function and pass arguments? Or improve the monad that you're working with?
12:08:43 <athan> it'd just be a flipped `let .. in`
12:14:06 <geekosaur> now half expecting someone to propose exactly that...
12:14:26 <geekosaur> (in <expr> let <bindings>, as expression syntax instead of part of declaration syntax like where)
12:14:44 <Tuplanolla> I can only imagine the parse errors.
12:14:56 <WarmCookie> Maybe the type in question could have some helper monadic function that lets you perform an arbitrary amount of actions and pass the arbitrary amount of results to another monad where these would be readily accessible.
12:16:01 <Tuplanolla> > let x = in w let w = 42 in in z let z = y
12:16:03 <lambdabot>  <hint>:1:9: error: parse error on input ‘in’
12:16:27 <Tuplanolla> Good luck with that.
12:16:44 <geekosaur> Tuplanolla, I think that would actually work. but a lot of people not used to thinking of "let" as inducing layout would be in for a surprise
12:16:54 <WarmCookie> Actually nevermind, has to be some extension, the boilerplate in my test is getting huge already.
12:17:19 <Tuplanolla> It probably would, but I'm not sure if that's a good thing, geekosaur.
12:17:21 <geekosaur> (we already have the case you are thinking about; consider let inside do, when written as a one-liner --- you need braces to disambiguate)
12:19:16 <hexagoxel> WarmCookie: i am rather opposed to the notion of lifting everything to the top-level. Locality is good, it adds structure, clears up the relation of different bindings.
12:19:16 <geekosaur> and considering how often that catches people by surprise (including me sometimes even though I know better), yes, it could get "interesting". but I think this case ends up being easier to cope with because, while there is no actual parse ambiguity in this case, there is a reduce/reduce conflict in the do+let case
12:19:34 <WarmCookie> hexagoxel: Add more modules c:
12:19:36 <geekosaur> it would certainly pose a comprehensibility roadblock though
12:19:41 <geekosaur> if abused.
12:20:03 <geekosaur> (fle flip side of that one is lots of things can be abused that way. I mean, we were just talking about pointfree :)
12:20:03 <WarmCookie> in .. do ..
12:20:13 <WarmCookie> in do { f <- foo; bar } let bar = baz f
12:20:43 <WarmCookie> in .. let ..  sorry.
12:22:05 <WarmCookie> That's just (>>=), but the idea is that you're sharing the scope now, right?
12:22:31 <WarmCookie> You'd have access to `f` and everything else.
12:23:18 * WarmCookie becomes dry.
12:23:45 <WarmCookie> The best option so far was `where` on the `do` block :P
12:29:54 <saurabhnanda> just broadcasting this here for larger circulation - https://www.reddit.com/r/haskell/comments/6bqxva/techempower_again_something_is_wrong_please_help/
12:31:19 <shapr> exarkun: well, you've convinced me to sign up for S4
12:32:48 <exarkun> shapr: haha >:)
12:33:07 <exarkun> shapr: Do you want me to tell you when the wormhole-based thing is deployed so you can appreciate that experience? :)
12:33:13 <erisco> one comment on the Interwebs that pertains to my error... no solutions https://www.reddit.com/r/haskell/comments/64r5on/realworldreflex/dg5no10/
12:33:33 <shapr> exarkun: yes please! I assume that's the magic folder new product?
12:33:48 <exarkun> shapr: It's at least highly correlated
12:37:13 <geekosaur> erisco, that's a warning, and I don't see an error from you in scrollback?
12:40:06 <erisco> yeah you're right it is just a warning
12:42:43 <geekosaur> anyway that is a complaint from the new checker and I think at this point its termination is subject to the halting problem
12:44:00 <erisco> the error is src\Gen2\Linker.hs:354:42: error: Couldn't match type `[Char]' with `ByteString'
12:44:58 <geekosaur> oh, how does that relate to what you linked?
12:45:36 <geekosaur> anyway that one looks like something changed type, *or* you need OverloadedStrings somewhere
12:45:45 <geekosaur> *or* a missing pack
12:46:19 <erisco> OverloadedStrings is on https://github.com/ghcjs/ghcjs/blob/ghc-8.0/src/Gen2/Linker.hs#L354
12:46:42 <erisco> will have to take some older revisions I guess...
12:47:25 <orion> What does the Coroutine Monad give me that Cont doesn't?
12:48:16 <hexagoxel> WarmCookie: if you can bear the horrors of my non-top-leveling, the code i was talking about is https://github.com/lspitzner/brittany/blob/dev/src/Language/Haskell/Brittany/Backend.hs#L340
12:49:47 <hexagoxel> you'd have to add like 8 arguments in total to different functions if you were to pass the four bindings manually.
12:55:46 <geekosaur> erisco, so that points to readNodeSettings and whatever it returns, which appears to be a record with a nodeProgram field. at a guess, that changed type
12:59:39 <geekosaur> orion, at a guess, an interface that is at least slightly less likely to fry your brain
13:00:37 <geekosaur> at a quick glance, assuming this is http://hackage.haskell.org/package/monad-coroutine-0.9.0.3/docs/Control-Monad-Coroutine.html#t:Coroutine, it looks closer to the Icon coroutine interface than the rather raw interface Cont gives you
13:00:57 <orion> Icon?
13:00:59 <geekosaur> also, its even simpler generator special case
13:01:20 <geekosaur> https://www2.cs.arizona.edu/icon/
13:02:02 <geekosaur> which has two coroutine interfaces: generators, which are very heavily used, and a more general interface using the @ operator to yield values to and from coroutines
13:02:31 <geekosaur> the latter gets mind-bending but not nearly as bad as using raw Cont
13:02:38 <geekosaur> for me, at least...
13:04:04 <geekosaur> I suppose it will depend on how you learned coroutines. my path went through Icon so I find those easier to work with. Cont might make folks who first encountered them in Scheme happier, or something
13:06:39 <orion> My first experience with coroutines was with monad-coroutine.
13:07:16 <orion> Do you suspect that it's possible (in a clean way) to make an MTL style transformer for Coroutine?
13:09:27 <geekosaur> not generally possible, no. take a look at the weave and merge functions, which at least hint at the problem
13:10:12 <geekosaur> hm, actually Coroutine is _already_ a monad transformer.
13:10:50 <geekosaur> you just have to use great care when two are nested
13:11:24 <erisco> sad... now ghcjs-boot fails... I hate compiling things
13:11:34 <geekosaur> mmm, bitrot
13:14:18 <erisco> it downloads a boat load of submodules and then patches them, but a patch fails
13:14:37 <orion> geekosaur: What do you mean by "already"? I would have expected to see a CoroutineT Monad.
13:15:13 <geekosaur> orion, Coroutine has an "m" and its runCoroutine gives you a result in m
13:15:41 <geekosaur> instead of a standalone Coroutine and a CoroutineT over a monad m, you get the CoroutineT but it;'s named Coroutine. and the other is Coroutine Identity
13:16:12 <orion> hm
13:16:33 <geekosaur> which is more or less the same thing mtl2 did with State becoming StateT over Identity, but making you create the over-Identity version yourself instead of providing one
13:17:20 <mojjo> anybody knows, what `#ifdef USE_REPORT_PRELUDE` means in the GHC.List source?
13:18:02 <geekosaur> the Haskell Language Report specifies implementations for a number of things. if, when building ghc, you have that defined, you get those Report-specified definitions
13:18:15 <geekosaur> if you don't define that, you get versions that are optimized for how ghc works
13:18:52 <geekosaur> also, they act as documentation for the behavior (specifically: strictness) that optimized versions must match
13:20:41 <geekosaur> (over the years, a number of optimized implementations of various functions have had to be rewritten because their strictness differed, meaning that programs that are legal per the Haskell Report diverge in ghc when that optimized version is used)
13:20:50 <orion> geekosaur: But, I can't compose it with, say, StateT, unless I have a MonadState instance for Coroutine.
13:21:19 <geekosaur> that;s not the same as not having a transformer
13:21:26 <orion> Ok, good point.
13:21:48 <geekosaur> it has a transformer, if that transformer doesn't provide MonadState, that's a hint that MonadState cannot be provided reliably
13:23:02 <orion> Is it possible that the author was just lazy?
13:23:13 <geekosaur> possible but not very likely
13:23:32 <geekosaur> I am wondering what a MonadState instance does when you perform certain operations on a Coroutine
13:24:02 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/Handshake.hs#L55
13:24:25 <geekosaur> in particular you might think about how pogoStick and bounce interact with state
13:24:55 <geekosaur> the answer there is, you need to specify the exact behavior. which is what the thing you linked to does
13:25:05 <erisco> looks like Haste is worlds easier to get installed... but there are almost no libs for it
13:25:34 <geekosaur> a different user of Coroutine might need different behavior, so it is able to specify that instead of having one rammed down its throat and no good way to get rid of it / change its behaviro
13:26:07 <geekosaur> and, in the general case, you can only specify what MonadState should do if you know what the Coroutine(s) involved do
13:26:28 <geekosaur> there are no laws to specify that it must do <x>; there can't be
13:27:53 <geekosaur> in a certain sense, this also is why MonadBaseControl exists; you can't define a law saying exceptions always must be handled <x> way, you need to define a MonadBaseControl instance saying what to do
13:28:37 <geekosaur> but as this is a simpler situation, instead of a MonadStateControl type thing, it just makes you make the MonadState yourself that does what you need
13:31:36 <orion> geekosaur: But, is the fact that I had to declare an orphan instance indicative of bad design?
13:31:50 <geekosaur> no
13:32:00 <geekosaur> in this case, it is indicative of a problem that nobody can solve for you
13:32:36 <geekosaur> if that was not clear from what I already said, then I'm not sure how to get it across that not all problems are amenable to "<x> is always the right solution to this particular situation"
13:32:46 <orion> Ok.
13:33:01 <orion> Thank you.
13:35:21 <geekosaur> note that in this case, you will always be specifying some state under your control and as long as you define your MonadState instance over that state type, the instance will not be orphan
13:35:55 <geekosaur> (because if you do not control that state type then you cannot say how to handle that state in all cases, which is precisely why there is no canned MonadState instance)
14:03:48 <eacameron> Is there a go-to library for storing hashed/salted passwords in Haskell?
14:14:30 <zomg> Wouldn't you usually store those in a database?
14:14:50 <zomg> unless I'm misunderstanding something :P
14:16:08 <eacameron> zomg: Right, but I want to hash them in Haskell before storing them in a db
14:16:36 <eacameron> I think cryptonite looks like a good option. It has convenience functions for storing passwords with BCrypt
14:17:04 <torstein> What does this error msg mean? trahs: fd:5: hGetLine: end of file
14:17:04 <torstein>  So trahs is name of module; the EOF part is all right, but "fd:5"?
14:19:31 <Tuplanolla> The format is `executable: file:line: function: message`, torstein.
14:25:49 <HKei> do I need to do anything special to get Liquid Haskell to read specifications for instances of classes with multiple parameters?
14:26:23 <HKei> I have a class Indexed c i a | c -> i, c -> a where (!) :: c -> i -> a 
14:28:09 <HKei> and {-@ instance Indexed (Vector a) Int a where (!) :: v:(Vector a) -> {i:Nat | i < vlen v} -> a @-}
14:28:28 <HKei> but I get a parse error on the "a" after Int 
15:03:40 <Gurkenglas> Requesting "ConduitM i o m (Either e ()) -> Conduit i m (Either e o)"
15:08:29 <Gurkenglas> Oh. ph88^, instead of "(tryC $ CB.sourceFile input)", try "handleC (yield . Left) (mapOutput Right $ CB.sourceFile input)"
15:30:01 <deech> Hi all, is there any way to get 'stack build' to output the same thing as 'cabal build'. I'm trying to time the compilation of one component. I've tried 'stack build -v' and 'stack build --cabal-verbose' and neither seem to work.
15:40:30 <juanpauc_> deech: `stack build mycomponent`?
16:04:06 <rightfold> Is there a flag I can set that makes GHC warn about "as" imports without "qualified"?
16:04:18 <torstein> Is this the a decent way of doing infinite read-eval loops? "handle (\(SomeException _) -> return ()) $ fix $ \loop -> do; line <- hGetLine r; case line of .."
16:04:29 <torstein> Seems a bit clumsy
16:05:39 <kadoban> rightfold: You could probably add that to hlint as a rule maybe.
16:08:04 <rightfold> Thanks.
16:08:36 <hololeap> are monoids in haskell supposed to be commutative as well?
16:09:13 <hpc> they don't need to be
16:09:37 <hpc> > "trivial " `mappend` "example"
16:09:39 <lambdabot>  "trivial example"
16:13:17 <Myrl-saki> Is there a catEithers?
16:13:49 <Myrl-saki> Oh. rights.
16:27:29 <mjora7> I've been looking up a bunch of Yesod tutorials and they all seem to mix frontend stuff in with the backend (like rendering templates). Isn't that a dated style of development? I was under the impression that completely separating the backend and frontend into almost two distinct programs was the more modern way to get (especially if you're using something like Vue, React, Angular, whatever). Am I being misled?
16:28:49 <Gurkenglas> torstein, if it's infinite you can use forever instead
16:32:18 <Sonolin> mjora7 I think they list it that way in the tutorials for simplicity's sake
16:32:30 <Sonolin> I'm sure there's a way to separate them (but that's where my knowledge ends, sorry)
16:34:08 <mjora7> Sonolin: Yeah I can see that.
16:34:13 <mjora7> Sonolin: Do you use Yesod or something else?
16:40:47 <Sonolin> I don't use any Haskell web frameworks
16:40:54 <Sonolin> except for messing around with Servant
16:41:04 <Sonolin> which is great for API-level stuff
16:43:59 <Axman6> I would be separating things like you said if I were doing any front end dev, and probably using something like servant-js to produce the API automatically
16:44:26 <Axman6> we use servant for all out web services, but none of my ones have a dedicated frontend
16:45:07 <mjora7> Ok that went a bit over my head.
16:48:39 <mbw> Could somebody please explain to me what https://www.stackage.org/haddock/lts-8.14/array-0.5.1.1/Data-Array.html#v:ixmap is supposed to be used for? I would presume it is some kind of index space transformation, but the documentation isn't clear to me. Looking at the source, it seems to be calling array. So wouldn't that just create a new array if I used unboxed arrays, which are supposed to be strict in 
16:48:45 <mbw> their elements?
16:49:43 <mbw> What I would actually like to do is safe a 4-dimensional array as a 1-dimensional one, making use of some symmetries.
17:09:44 <ReinH> ixmap (l,u) f creates a new array with bounds (l,u) by applying f to each index at i to produce the new index at j
17:11:03 <ReinH> Sorry, that's not quite right.
17:11:55 <ReinH> It producer a new array with bounds (l,u) where the i'th index holds the value at f i in the original array.
17:12:38 <ReinH> (where i ranges from l to u)
17:16:11 <ReinH> ixmap (0,10) succ arr produces an array where index 0 is arr ! succ 0 and so on up to 10,which I'd  arr ! succ 10
17:16:20 <ReinH> *is
17:16:53 <ReinH> So it shifts the indices from (1,11) to (0,10)
17:17:09 <edwardk> thats the contravariant map thing, right?
17:17:12 <ReinH> Er, shifts the bounds
17:17:19 <ReinH> Yeah contravariant index map
17:18:02 <edwardk> the corresponding construction in lens is one of 2-3 contravariant setters is the only reason why i remember it
17:18:43 <jle`> \me . o O (instance Profunctor Array where ...)
17:18:47 <ReinH> It's weird that ixmap would be contra instead of co.
17:18:58 <ReinH> edwardk: also hi
17:19:40 * jle` . o O (instance Category Array where ...)
17:19:56 <edwardk> reinh: heya, ltns. when are you coming out to boston? i missed the little davean hackahon thing they scheduled around you in january or february or whatever
17:20:17 <davean> We need to schedule another :)
17:20:23 <edwardk> jle: both -almost- work
17:20:37 <ReinH> Not sure, maybe there's a conference or a hack Boston or something I can plan around.
17:20:42 <edwardk> davean: you coming down to compose?
17:20:48 <davean> edwardk: to what? When?
17:20:54 * edwardk just landed in nyc
17:20:59 <davean> I guess no? Since I don't even know when or what that is
17:21:06 <ReinH> jle`: instance Category Matrix where
17:21:08 <edwardk> compose conference, tomorrow through sunday
17:21:13 <davean> Uh, guess not!
17:21:21 <jle`> different instance :o
17:21:24 <davean> :(
17:21:35 <davean> Would have
17:21:38 <ReinH> Heh, johnw also asked me. I'm sad I'm missing it now.
17:22:03 <davean> And I'm sailing next week, so I'll miss johnw's thing
17:22:17 <edwardk> johnw is also here
17:22:33 <edwardk> come down, crash on carter's floor or somehing
17:22:54 <edwardk> emily reihl will be talking about effects tomorrow morni
17:23:00 <davean> carter is coming up *here*
17:23:04 <davean> he's crashing on *my* floor
17:23:25 <edwardk> tell him to toss you his keys, then ditch him :)
17:23:30 <ReinH> edwardk: the categorical effects stuff? I saw that.
17:23:31 <davean> Lol
17:23:37 <ReinH> Looks nest.
17:23:40 <carter> edwardk: I'll be around Thursday
17:23:41 <davean> I'm running a cooking thing tomorrow
17:23:41 <ReinH> Neat.
17:23:45 <davean> er
17:23:47 <davean> friday
17:23:51 <davean> What day of the week is it?
17:24:10 <edwardk> the hackathin part is the weekend
17:24:15 <edwardk> thu/fri are talks
17:24:23 <ReinH> edwardk: I've been making another attempt at HoTT
17:24:38 <carter> edwardk: ... but the hack thing is in new jerseyyyy
17:24:53 <edwardk> is it? i didnt see the address
17:25:16 <carter> edwardk: it's at Jet.  In New Jersey.
17:25:21 <edwardk> that may mak getting back/forth complicated
17:25:49 <carter> Yes. Why I wasn't planning to go to the hack part
17:27:23 <edwardk> depending on how much the saturday sucks i'll decide if i can reschedule my return flight / crash on someone's couch for sunday
17:28:16 <davean> Low expectations?
17:28:46 <edwardk> realistic ones now that i know that i have to figure out transit to/from jersey
17:29:40 <davean> I need to maintain a calendar of FP conference/events and make it to more of them
17:30:40 <carter> edwardk: allegedly its easy to get to from Hoboken...  but I'm too planning to go either way
17:30:59 <ezyang> see y'all at Compose :) 
17:31:46 <carter> ezyang: you'll be theee ?
17:31:59 <ezyang> yep, NYC based I am 
17:32:31 <carter> ezyang: generally or just this week ?
17:33:47 <ezyang> generally 
17:34:16 <carter> ezyang: woah when did that happen?!
17:34:32 <edwardk> ezyang: so when are we getting you to come up to boston and give a backpack talk to boston haskell?
17:34:51 <ezyang> edwardk: Oh, clearly in the near future! 
17:35:09 <ezyang> carter: Last month. Started a cushy job... writing Python and C++ haha 
17:35:20 <edwardk> good to know. i'll bug you about it while we're both here at compose
17:35:46 <edwardk> anyways welcome back to this coast
17:35:46 <carter> ezyang: is that code for Google?
17:35:53 <ezyang> Facebook :P 
17:35:54 <carter> Also see yah around :)
17:36:04 <ezyang> yeah, I can feel the heat already 
17:38:15 <carter> I was doing some cpp and python this week and deciding python is terrible
17:39:37 <davean> Well, at least it's cushy?
17:40:43 <carter> What does cushy mean in this context ?
17:41:32 <edwardk> compared to the typical grad student lifestyle?
17:42:16 <carter> That's a low bar
17:42:30 <edwardk> ezyang: did you finish the phd first?
17:43:05 <davean> Well, I have to assume it's enough to make up for what followed?
17:45:08 <edwardk> that is my one regret. without finishing a phd folks can get away with calling me mr. ed rather than dr. ed.
17:45:11 <ezyang> weeeell 
17:45:21 <ezyang> i haven't submitted final copy of my thesis yet haha 
17:45:32 <ezyang> cushy means making way more than a PhD 
17:45:50 <blackdog> carter: python is indeed terrible! why were you writing it?
17:46:10 <blackdog> edwardk: oh thanks, i'll never get that song out of my head now.
17:46:28 <edwardk> you do realize i probably would have hired you in a cushy capacity from about any point from your sophomore year on, right? ;)
17:46:28 <pacak> ezyang: o/
17:46:33 <ezyang> pacak: hihi 
17:46:35 <davean> edwardk: there's still life left in you
17:46:50 <MarcelineVQ> dr. ed? https://s-media-cache-ak0.pinimg.com/736x/d1/ea/7a/d1ea7a1e6808865585cf3a5f4cc77d84.jpg
17:47:07 <pacak> ezyang: About !13710 - I have code that panics with -j1. Would it be useful to minimize the failure with -j1?
17:47:20 <ezyang> that definitely would help! 
17:47:27 <davean> edwardk: I'm sure if you get bored some winter, you can still become Dr. Ed
17:48:36 <edwardk> see thats my problem. no matter how many masters degrees you get people never seem to start calling you master.
17:48:39 <Axman6> it won't take him a whole winter
17:49:00 <edwardk> i was suckered
17:49:08 <EvanR> doctor doctor doctor doctor doctor </sleeper>
17:49:19 <dyreshark> edwardk: if it makes you feel better, i got a bachelor's degree and am still a bachelor.
17:51:22 <edwardk> i managed to get a double b.s. and as folks who know me can tell you, that left me with a lot of b.s. left over
17:55:29 <actualHuman_462> Random question - I have seen on Reddit and a few places, people mentioning this idea of "using records instead of sum types" to replace stuff like data AppSignal = Exit | RunCommand Text | Etc ... Does anyone have like a code example or a blog post somewhere that elaborates on this?
17:56:46 <actualHuman_462> It seems like sort of a logical non sequitur to talk about replacing a sum type with a product type, so like, obviously I am missing some kind of core concept here
17:57:25 <EvanR> maybe talking about the record of functions to simulate OOP
17:57:45 <edwardk> you can use row typing to talk about open sums as well
17:58:17 <edwardk> e.g. data types a la carte
17:58:37 <edwardk> or the CoRec type in the vinyl records stuff
17:59:01 <glguy> actualHuman_462: it would be more useful to be shown a specific Reddit comment that you didn't understand than to guess what was meant
17:59:34 <edwardk> given an open sum and a product of "handlers" you can do case analysis. given an open record a sum type acts as a field selector
18:00:08 <carter> There's a duality!
18:01:01 <edwardk> indeed.
18:01:42 <carter> blackdog: after briefly considering going along with impl in python I decided nope nope
18:01:57 <carter> _init_.py is gross
18:02:19 <carter> There's just so much terribleness if I wanted to write an ok lib blackdog
18:02:37 <pacak> carter: Try php, after php python feels nice.
18:03:42 <carter> pacak: not sure how much money I'd need to do that
18:19:50 <sordina1234> Hey Haskellers, has anyone experienced servant apps somehow setting duplicate cookies?
18:41:25 <pacak> Is it possible to to have two cabal sandboxes in the same directory?
18:42:03 <MarcelineVQ> posibly with --sandbox=DIR
18:42:12 <pacak> I'm passing --sandbox .new and --ignore-sandbox, but it says Using an existing sandbox located at
18:42:20 <pacak> for sandbox init
18:45:24 <geekosaur> I don't think you can, because cabal.sandbox.config is outside the dot-dir with the actual sandbox in it?
18:48:03 <pacak> Hmm... I think I managed to do it by messing with folders manually. It's sad that cabal seems to ignore --ignore-sandbox parameter.
18:48:21 <pacak> That moment when you go to reproduce a bug in ghc but find a bug in cabal instead.
18:49:48 <MarcelineVQ> hmm, I'm not having your issue here
18:50:44 <pacak> cabal-install 1.24.0.2, compiled using version 1.24.2.0 of the Cabal library
18:51:12 <pacak> ghc 8.0.2
18:53:40 <MarcelineVQ> 1.24.0.0 here as well, in a fresh directory  mkdir .new && cabal sandbox init && cabal sandbox init --sandbox .new  works without conflict, were you after something else and I'm misunderstanding?
18:53:51 <MarcelineVQ> *here, in
18:55:39 <MarcelineVQ> the config file might still end up being an issue as geekosaur mentions, depends how smart the --sandbox option is :X
18:55:52 <pacak> I did something similar, but in my case it detected previous sandbox and reused it. Moving it out of the way and moving back in helped.
18:58:18 <MarcelineVQ> you might end up needing to have a config for each and pass a --sandbox-config-file=FILE option for cabal commands, seems like a hassle
18:58:55 <pacak> Yea. I'm trying to compile the same code that depends on half a hackage on both ghc 8.0 and 8.2.rc2 the same time
18:59:13 <pacak> because rc2 panics
18:59:28 <pacak> https://ghc.haskell.org/trac/ghc/ticket/13710
19:02:47 <MarcelineVQ> ah, I don't know anything about boot files, that's a pretty obscure reference in the error message though
19:10:50 <erisco> at this rate I will have to port everything to a different language... but that would be miserable
19:11:01 <EvanR> o_O
19:11:20 <erisco> can't get haste working either as hplayground won't install
19:11:33 <erisco> could elect to not use it but then I have to do even more annoying UI workl
19:13:26 <erisco> I suspect Elm/PureScript don't support type families and rank-n-types and data kinds
19:14:08 <paf31> PS has rank n types and you can create custom kinds, but no type families
19:14:18 <paf31> We have fundeps though
19:18:08 <jle`> aw man, ghcjs doesn't do Data.Kind.Type yet
19:19:26 <jle`> i don't think this is a fundamental issue with ghcjs
19:20:41 <erisco> haste-install install haste-compiler Backjump limit reached
19:24:02 <erisco> haste-compiler depends on bin-package-db which is not a package
19:24:49 <erisco> they recommend just downloading the binary... but their libs depend on it anyways...
19:44:58 <_sras_> Using servant-swagger, how can I provide a description for a particular endpoint? 
20:29:21 <biotty> if i miss the dot in following i get the inverse -- (flip ($)) 1 . (/) $ 2
20:32:52 <lyxia> biotty: flip ($) 1 (/) $ 2 = ((/) $ 1) $ 2 = (/) 1 2        flip ($) 1 . (/) $ 2 = flip ($) 1 ((/) 2) = (/) 2 $ 1 = (/) 2 1
20:39:37 <ReinH> So, I mean, did you not want to use `(/) 1`?
20:39:54 <ReinH> Oh, you wanted the (.)
20:39:55 <biotty> so when no dot, this space is using (/) as argument, and when a dot, we compose with (/) and in the latter case the 2 is given to the composed function
20:40:01 <ReinH> @pl \x -> (/) x 1
20:40:01 <lambdabot> (/ 1)
20:40:19 <ReinH> sections ftw
20:40:30 <biotty> lyxia: thank you, this clarified.  i underline i am a newb experimenting with the basics
20:41:13 <ReinH> biotty: when in doubt, it's good to get in the habit of evaluating terms yourself by using their definitions
20:41:54 <ReinH> This is one of the nice things about referential transparency: you can always substitute terms with their definitions.
20:42:32 <biotty> ReinH: yes, in this case i should do that on all leaving the discussed (.) or space as long i can, so that i see why it at all compiles in both cases
20:42:52 <ReinH> this sort of thing is known as "equational reasoning" and is a very useful skill.
20:42:59 <ReinH> biotty: space?
20:43:23 <ReinH> oh, you mean the application that occurs when you don't have the .
20:43:30 <biotty> ReinH: exactly
20:43:35 <ReinH> cool
20:43:58 <ReinH> well, you don't get a choice about how long to leave the (.) or application
20:44:01 <biotty> i was just fiddling, and got surprised (scared) when both where valid
20:44:08 <ReinH> that's decided for you by Haskell's evaluation order
20:44:45 <ReinH> although you will get the same result in a lot of cases, it isn't guaranteed
20:45:25 <ReinH> (you will get the same result when your expression is total)
20:46:04 <ReinH> > const 1 undefined -- sometimes evaluation order matters though
20:46:06 <lambdabot>  1
20:46:26 <biotty> by the way, is there a synonym for flip ($) ?
20:46:40 <jle`> there's (&), but it isn't quite idiomatic in most places
20:46:45 <ReinH> Some people call it (&), but it isn't in the standard library
20:46:59 <jle`> it is actually in base
20:47:03 <ReinH> oh it is now
20:47:05 <ReinH> right
20:47:24 <jle`> it...snuck in there
20:47:27 <ReinH> heh
20:47:35 <ReinH> all my Haskell knowledge is out of date
21:04:24 <glguy> Anyone know what I'd need to do with ghcjs-dom to get the context I've typed into a textarea? getAttribute myTextArea "value" , doesn't seem to be it
21:05:01 <glguy> This is what I've tried http://lpaste.net/709854168705138688
21:06:01 <glguy> however all that ever sets the output div to is "null"
21:10:13 <hamishmack> glguy: Have you tried GHCJS.DOM.HTMLTextAreaElement.getValue ?
21:13:00 <glguy> No, but that does sound promising.
21:13:15 <glguy> That's the best place to find the haddocks for this module?
21:13:56 <hamishmack> https://hackage.haskell.org/package/jsaddle-dom-0.8.0.0/docs/JSDOM-Generated-HTMLTextAreaElement.html
21:14:39 <hamishmack> That is the underlying module that gets re-exported through ghcjs-dom-jsaddle and ghcjs-dom
21:14:44 <glguy> OK, thanks. I think because of the indirections that ghc-dom does to make it possible to run things on multiple platforms I was looking in the wrong place
21:15:10 <glguy> and using getValue works for me, thank you
21:16:06 <glguy> My goal is to learn enough GHCJS to make my config-schema library example file interactive :) I plan to replace the string literal in 'exampleFile' with a textarea https://github.com/glguy/config-schema/blob/master/README.md
21:16:41 <glguy> dmj`: Helped me to get so far as to be able to load the parser and schema libraries in ghcjs proper, so now it's UI time
21:32:26 <glguy> hamishmack: What was I doing wrong when using getAttribute? What was happening there instead of what I had in mind?
21:34:42 <dmj`> UI time :)
22:18:43 <nshepperd_> I didn't think textarea had a "value" attribute
22:19:09 <glguy> It's apparently how you get the contexts of a textarea
22:19:20 <nshepperd_> The content is a child node of the textarea, not an attribute
22:19:38 <glguy> Sure, but it's exposed via .value in the DOM
22:23:29 <nshepperd_> Is that the same thing as an "attribute" according to ghcjs.dom?
22:23:56 <Zemyla> When was RankNTypes added to GHC?
22:24:10 <edwardk> long long ago, before hugs died
22:24:29 <glguy> nshepperd_: Perhaps not, that'd explain why it didn't work
22:25:37 <edwardk> zemyla they were really old when i first joined the community 10 years ago
22:25:55 <nshepperd_> I'd assume that a function called "getAttribute" applies to only actual html attributes. But i dunno
22:29:17 <_sras_> Using servant-swagger, is there any way to give descriptions to indvidual endpoints?
22:30:58 <jle`> just saw 'type ★ = Type', haha
22:31:36 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Kind.html#t:-9733-
22:31:47 <jle`> didn't realize it was that simple
22:33:34 <LAZAR> What is wrong about this piece of code attempting to parse a JSON license either consisting of a String or an Object?
22:33:36 <LAZAR> http://lpaste.net/355637
22:34:11 <nshepperd_> jle`: all we need is more Unicode on our keyboards...
22:36:25 <nshepperd_> Although does that one actually work? It looks like haddock thinks it's an operator. It would be a bit annoying to have to write (★) in stead of (★)
22:36:40 <nshepperd_> Err, instead of ★
22:37:22 <jle`> yeah
22:37:25 <jle`> well
22:37:34 <jle`> parsing rules are already special-cased with *
22:38:04 <jle`> looks like ★ is also special-cased
22:39:03 <jle`> :k ★
22:39:04 <lambdabot> error:
22:39:04 <lambdabot>     Not in scope: type constructor or class ‘★’
22:39:04 <lambdabot> error: Operator applied to too few arguments: ★
22:39:09 <jle`> @let import Data.Kind
22:39:11 <lambdabot>  Defined.
22:39:12 <jle`> :k ★
22:39:13 <lambdabot> *
22:39:30 <jle`> :k 'Just ★
22:39:31 <lambdabot> Maybe *
22:39:40 <pacak> ☭
22:44:55 <LAZAR> Umm what kind of error happens when Aeson returns Error in $[285]: empty?
22:50:02 <eklavya> is there a way to have triple quote strings in ghci?
22:50:18 <eklavya> I don't want to escape all "s in string while pasting
22:50:35 <LAZAR> Im trying to parse JSON which could be either String or an Object, does not seem to work tho, can someone check this 7 LoC? http://lpaste.net/355638
22:51:58 <pavonia> LAZAR: What is the error?
22:52:23 <LAZAR> pavonia: Surprisingly short... Error in $[285]: empty
22:53:36 <pavonia> Could you paste a minmal but complete module?
22:53:46 <LAZAR> the module is very short, so sure
22:54:21 <LAZAR> http://lpaste.net/355639
22:55:23 <pavonia> And what's the input?
22:57:01 <LAZAR> pavonia: The input is http://lpaste.net/3681361192619606016 in input line 285
22:58:09 <LAZAR> pavonia: and this would be an example with an object license http://lpaste.net/4647840138297081856
22:58:29 <dmwit> This... is not what I would call minimal.
22:59:05 <LAZAR> dmwit: What do you mean?
22:59:22 <dmwit> Minimal is like 3-4 lines of code and 5-6 characters of input.
23:00:06 <LAZAR> dmwit: Well I originally posted 7 loc and was aked for more. my program is really short with 80 loc and almost only type declarations
23:00:34 <dmwit> I'm not saying you should show something less than your whole program.
23:00:46 <dmwit> I'm saying you should put in some work so that your whole program is tiny, and still demonstrates the problem.
23:01:04 <_sras_> In Servant, Is there anyway to get a path of an endpoint from the endpoint's type alone?
23:01:06 <dmwit> Cut out anything non-essential to demonstrating the issue.
23:01:21 <dmwit> (While verifying that it still does demonstrate the issue.)
23:01:45 <dmwit> https://stackoverflow.com/help/mcve
23:02:14 <dmwit> Indeed, most of the time just following this process makes the problem so apparent you don't even need to ask the channel. =)
23:03:02 <dmwit> eklavya: Nope, you have to escape them all.
23:03:18 <dmwit> eklavya: You could put in a placeholder and swap it out later... =P
23:03:52 <LAZAR> dmwit: okay. well it is this then http://lpaste.net/355639 I know the mistake is inside the asum block i just did not found a good documentation for this anywhere
23:03:53 <eklavya> dmwit: :D I can use multi edit I guess
23:04:04 <eklavya> there really should be a """ 
23:04:13 <eklavya> it's so convenient !
23:04:18 <dmwit> > let swap '%' = '"'; swap '"' = '%'; swap x = x in swap <$> "%This is a quote,% said the senseis, %and if you can't see that it's your problem.%"
23:04:20 <lambdabot>  "\"This is a quote,\" said the senseis, \"and if you can't see that it's you...
23:05:10 <dmwit> LAZAR: Okay. If the problem is in the `asum`, you should be able to cut out most of the code that doesn't directly impact the `asum`, then. I suggest you try that.
23:05:50 <pavonia> LAZAR: Shouldn't you treat the object as an object if it isn't string? You now seem to try to use it as a string in both cases
23:06:08 <LAZAR> dmwit: and there we are at my original post which was the exact 7 lines of asum...
23:06:34 <eklavya> dmwit: :)
23:06:34 <dmwit> LAZAR: But your 7 lines is not a complete program.
23:06:39 <LAZAR> pavonia: Yep Im just using a default string just to see if the code works
23:06:51 <dmwit> LAZAR: And doesn't have a small input that shows the problem.
23:06:57 <pavonia> LAZAR: No, I mean in the Just branch
23:07:01 <LAZAR> pavonia: eventually i will deconstruct the object and pull the license out
23:07:13 <dmwit> I know it sounds like I'm being difficult here, but I really am trying to help, not just with this problem but with your method of figuring out solutions in the long term future.
23:07:42 <pavonia> O rmaby I'm confused
23:08:41 <LAZAR> pavonia: Well eventually I want to readMaybe the license, if this succeeds it is a string and i return that, if not it must be an object. for simplicity's sake in that case i just return a default string
23:09:45 <pavonia> LAZAR: But that makes the parser fail, I think, because it tries to parse it as a string even if it is an object
23:10:32 <LAZAR> pavonia: well in that case the error would be Error in $[285].license: expected String, encountered Object
23:10:42 <LAZAR> ?
23:11:03 <pavonia> The docs say it returns empty in that case
23:11:41 <LAZAR> pavonia: yeah but why? i specified it to return (Just "Default")
23:13:09 <pavonia> readMaybe takes a string as input, so (.:) has result type Parser String
23:13:35 <pavonia> But the object cannot be parsed as string, hence the empty result
23:15:43 <LAZAR> pavonia: Strange... I did it pretty much the same way it has been done in this tutorial: https://artyom.me/aeson#more-interesting-choices
23:17:11 <pavonia> Right, but there it is a string, not an object
23:17:34 <LAZAR> pavonia: or a number i believe
23:18:30 <LAZAR> so what would be the way to distinguish object from string? i can not do pattern matching there?
23:18:33 <pavonia> Yes. Another thing I just noticed, you do "return x" which is also wrong, because you have to return a Maybe value
23:18:53 <pavonia> So now both the parser and the read fail :)
23:20:00 <pavonia> LAZAR: You need to extract the "type" field and use its value with readMaybe
23:20:42 <pavonia> Or for testing purposes at least give the compiler a hint that the result you expect is an object
23:23:51 <LAZAR> pavonia: can you give an example of how to extract this type field? Like with typeOf?
23:27:17 <pavonia> LAZAR: Something like do { license <- value .: "license"; mbType <- license .:? "type"; ... }
23:42:43 <ADG_> hello everyone, can you tell me how can I make this code more readable (without introducing syntax errors, I tried breaking lines and this exact thing happened) : https://github.com/adityagupta1089/Project-Euler-Haskell/blob/master/src/50.hs
23:43:40 <jle`> ADG_: try naming things
23:44:00 <jle`> but you should be able to break some lines
23:44:04 <ADG_> also why can't I break lines in the array declaration
23:44:11 <jle`> what exact things are oyu talking about
23:44:19 <jle`> line breaks are fine
23:44:27 <ADG_> "parse error (possibly incorrect indentation or mismatched brackets)"
23:44:28 <jle`> as long as they start after the first 's' in 'sms'
23:44:31 <mbrock> how much do y'all care about name shadowing with variables and parameters? I find myself a bit sad that the names I want to use would so often cause a shadowing warning
23:44:51 <jle`> ADG_: you're gonna have to post the code and full error message if you want us to be able to meaningfully help with that
23:45:04 <mbrock> (I guess in the Lisp world, my sadness is related to the conflict between Lisp
23:45:21 <jle`> i pretty much try to never shadow anything
23:45:25 <mbrock> ...Lisp-1 and Lisp-2, i.e. whether to have separate namespaces for functions and variables)
23:45:29 <jle`> except for special cases like with record wildcards/record puns
23:46:16 <ADG_> here : https://hastebin.com/milaxeyaga.hs
23:46:33 <jle`> ADG_: yeah, like i said, you have to put everything after the 's' in sms
23:46:39 <jle`> otherwise GHC things that you're starting a new declaration/binding
23:46:45 <mbrock> record fields (or their corresponding lenses) are probably what steal the most valuable names
23:46:58 <ADG_> hmm, I get it
23:47:02 <jle`> mbrock: well, what are you naming your record fields
23:47:17 <jle`> there are...conventions
23:47:21 <mbrock> like in a VM there will be a "bytecode" field in some record, and then I'll be naming variables "theBytecode" or "myBytecode" or whatever
23:47:49 <jle`> that's a bad name for a record field
23:48:11 <jle`> or well, at least for how haskell works
23:48:28 <jle`> it's definitely not a name that anyone would recommend you use, and not one that any library or production code would use
23:48:30 <mbrock> I'm familiar with the convention of prefixing each field with the record name, but that makes lens compositions very noisy
23:48:59 <jle`> ADG_: i'd also probably pull out the giant list you pass to 'array' and give it a name
23:49:21 <ADG_> It's recursive and it needs itself, I think so
23:49:43 <jle`> you can still refer to sms 
23:49:49 <jle`> recursion is allowed in haskell
23:50:05 <jle`> it's actually something people do pretty often :)
23:50:09 <_sras_> Using Swagger, If I have a Swagger value, how can I add a description to a particular path in it?
23:50:25 <jle`> @src map
23:50:26 <lambdabot> map _ []     = []
23:50:26 <lambdabot> map f (x:xs) = f x : map f xs
23:50:45 <jle`> ^ example of recursion
23:58:48 <osa1> sigh it's annoying that I can't document data constructor fields unless I use record syntax or invent single-use newtypes
23:59:47 <anoLB> you mean they wont show up in haddock... you can put comments tho
