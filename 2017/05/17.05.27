00:00:16 <angerman> The build-type: custom is the most annoying thing. And building setup on the build machine, and running it there, while compiling for a different host, while working feels just wrong. 
00:00:47 <EvanR> i never understood the role of Setup
00:00:51 <angerman> (e.g. it will work for anything arch independent, but also work for arch dependent stuff. It will just simply (and silently) be wrong)
00:01:05 <angerman> EvanR: it's an escape hatch, similar to unsafePerformIO :-)
00:02:12 <pacak> EvanR: packages can require strange stuff to compile. You don't need it for pure haskell packages, but there are things like gtk for example. They do strange things in Setup.
00:02:19 <angerman> stuff that cabal can not (yet) express, can be handled via build-type: custom. However I beleive it's being abused for haddock and doctest far too often. There are legit use cases that simply can't subsumed by cabal. cocreature has at least one :)
00:02:43 <EvanR> i see
00:03:02 <cocreature> angerman: I don’t quite understand the shakespeare errors. why is this only a problem when crosscompiling? it seems like it should be ambiguous regardless of that
00:03:36 <angerman> cocreature: because **I** have added those function to the Quasi class like two days ago :)
00:03:41 <cocreature> angerman: ah ok
00:03:45 <cocreature> I didn’t realize that :)
00:04:23 <cocreature> EvanR: specifically, I’m calling "llvm-config" in Setup.hs to figure out linker options and options that I need to pass to the C++ compiler
00:04:46 <angerman> cocreature: https://phabricator.haskell.org/D3608
00:05:26 <EvanR> so Setup is always there but may usually be doing nothing
00:05:33 <EvanR> unless doctest
00:05:59 <cocreature> EvanR: it doesn’t do nothing. there is a default that just builds your package without doing anything extra
00:06:04 <angerman> yes. unless doctest, or haddock, or some setup magic
00:06:04 <EvanR> oh
00:07:44 <cocreature> main = defaultMain is the standard 
00:07:47 <cocreature> Setup.hs
00:10:17 <halogenandtoast> pacak: was your code a solution to my problem?
00:10:27 <cocreature> halogenandtoast: yes
00:10:44 <cinimod> Anyone know anything about BlogLiterately?
00:10:49 <halogenandtoast> I assume that means I need to call sort on the list.
00:10:56 <pacak> halogenandtoast: It was a solution to my understanding of your problem.
00:11:08 <cocreature> halogenandtoast: huh? why do you think that
00:11:27 <halogenandtoast> > and $ (\xs -> zipWith (<) xs (drop 1 xs)) [1,4,2,3]
00:11:29 <lambdabot>  False
00:11:37 <halogenandtoast> cocreature: that's why
00:11:44 <pacak> there are - "unsorted consecutive values"
00:11:54 <pacak> > and $ (\xs -> zipWith (<) xs (drop 1 xs)) [1,2,3,4]
00:11:56 <lambdabot>  True
00:11:57 <angerman> cocreature: but do we actually compile Setup.hs if build-type: simple? 
00:12:02 <pacak> there's no "unsorted consecutive values"
00:12:14 <cocreature> > (\l -> or (zipWith (>) xs (drop 1 xs)) [1,4,2,3]
00:12:15 <lambdabot>  <hint>:1:49: error:
00:12:16 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:12:19 <halogenandtoast> pacak: I'm dealing with a card game, where the cards can be played in any order
00:12:22 <cocreature> > (\l -> or (zipWith (>) xs (drop 1 xs))) [1,4,2,3]
00:12:25 <lambdabot>  error:
00:12:25 <lambdabot>      • Variable not in scope: xs :: [()]
00:12:25 <lambdabot>      • Perhaps you meant one of these:
00:12:25 <halogenandtoast> but I need to know if they could be consecutive
00:12:33 <cocreature> > (\l -> or (zipWith (>) l (drop 1 l))) [1,4,2,3]
00:12:35 <lambdabot>  True
00:12:37 <pacak> halogenandtoast: o_O
00:12:39 <cocreature> > (\l -> or (zipWith (>) l (drop 1 l))) [1,2,3]
00:12:40 <pacak> halogenandtoast: use set then
00:12:41 <lambdabot>  False
00:13:15 <pacak> consecutive - as in "there's no holes"?
00:13:42 <halogenandtoast> pacak: yes
00:13:53 <cocreature> angerman: It is an error if the Setup.hs is not just "main = defaultMain" in that case so even if you would compile it you would know what it does
00:14:03 <cinimod> Apparently not :(
00:14:19 <cocreature> cinimod: asking questions directly always works better than “does someone know something about X”
00:14:27 <pacak> halogenandtoast: use Set, toList, zipWith (\a b -> pred a == b)
00:14:44 <pacak> (assuming there's Enum instance)
00:14:53 <halogenandtoast> There is, I have control over the data type.
00:15:00 <cinimod> Ok my python code does not get syntax hightlighting in my blog post when I render it using Blogliterately: https://gist.github.com/idontgetoutmuch/c638fd0dd2a6af8b3503a8f05c89c326
00:15:26 <halogenandtoast> pacak: I assume Set is Data.Set
00:15:32 <pacak> halogenandtoast: yep
00:15:50 <halogenandtoast> Alright, I'll check it out. Thanks for your help
00:15:56 <pacak> Enum instance needs to deal with different suits in some intelligent way.
00:16:23 <cinimod> cocreature: did I see you are *not* going to Zurihac?
00:16:33 <cocreature> cinimod: yeah I sadly can’t make it
00:16:37 <cinimod> :(
00:16:39 <cocreature> I’m really annoyed by that
00:17:24 <cinimod> I will be there :) - I may also go to the Leipzig hackathon
00:18:18 <cocreature> leizig? I didn’t see anything about that
00:18:22 <cocreature> *leipzig
00:18:40 <cocreature> oh hal
00:18:48 <cinimod> https://hal2017.softbase.org
00:19:00 <cocreature> I’m kind of hoping that quchen will do another munihac this year and was planning to go there
00:19:23 <cinimod> So many hacs
00:19:55 <cocreature> I owe quchen at least one beer so it’s important that I’ll go to a hac where he’s going too :)
00:20:20 <cinimod> Munich is nice
00:20:26 <cinimod> Leipzig is also nice
00:20:56 <cinimod> I want my blog post to be even more beautiful
00:21:09 <cinimod> I will wait for Brent to wake up
00:21:09 <cocreature> sry not sure what’s wrong with your blog post
00:21:13 <cinimod> np
00:21:30 <cinimod> But you never know if someone knows the answer
00:22:35 <EvanR> you dont known if you know what you dont know yet
00:22:46 <EvanR> until you ask
00:29:43 <jingbird> Hi all. I have a question about using hothasktags. There is convenient command to build tags file with this tool: "find . -name '*.hs' | xargs hothasktags > tags". Unfortunately it makes errors if haskell program use some extensions and not declare it with language pragmas but declare in default-extensions of cabal-file. Is there a methof to use it in such scenario?
00:30:09 <Lokathor> EvanR, I spent most of work musing over GLSL possibilities, I think I might be able to have both a tile engine and a curses engine work in a single drawing pipeline
00:31:24 <EvanR> you could send the configuration of the grid as a uniform
00:32:09 <EvanR> instead of texture data
00:32:38 * hackage gi-gsttag 1.0.12 - GStreamer Tag bindings  https://hackage.haskell.org/package/gi-gsttag-1.0.12 (inaki)
00:32:48 <Lokathor> well my current intent is that every cell has an opaque background color, alpha'd texture location, and alpha'd foreground color
00:33:08 * hackage freer-converse 0.1.0.0 - Handle effects conversely using monadic conversation  https://hackage.haskell.org/package/freer-converse-0.1.0.0 (RobertHensing)
00:33:17 <EvanR> and each color is 24-bit o_O?
00:33:29 <Lokathor> and then the fragment shader will be able to combine those carefully so that your forground color might or might not recolor the texture's color, and then that might or might not overwrite the background color (which is the default result)
00:33:35 <EvanR> what happened to 3-bit palette heh
00:33:38 * hackage gi-gstpbutils 1.0.12 - GStreamer Plugins Base Utils bindings  https://hackage.haskell.org/package/gi-gstpbutils-1.0.12 (inaki)
00:34:17 <Lokathor> background is RGB with A always as 1, texture is s,t coordinates which perform a lookup into an RGBA texture, and the foreground is RGBA
00:34:36 <EvanR> instead of st coords... just index
00:34:48 <EvanR> insead of RGB... palette index..
00:34:48 <Lokathor> can you do that in a fragment shader?
00:35:10 <Lokathor> i mean i could do a palettte index i guess
00:35:13 <EvanR> you can convert numbers to s,t inside of the shader sure
00:35:25 <cocreature> cinimod: hm that reminds me, henning asked me if I want to give a talk at hal this year so if I can come up with a nice topic, I might go there too :)
00:35:26 <Lokathor> but this lets you have all the possible colors!
00:35:59 <EvanR> something about 24-bit color terminal doesnt make sense to me
00:36:36 <cinimod> cocreature: henning was the person who told me about hal
00:37:00 <EvanR> but anyway thats yet another uniform
00:37:42 <cinimod> I will try to go - I look forward to your talk :)
00:37:51 <Lokathor> EvanR, you're free to only select 8 or 16 different colors :3
00:38:14 <Lokathor> but this way the exact same framework can also just be a tile engine framework
00:38:17 <EvanR> but im paying for 16777216
00:38:27 <Lokathor> it's open source :P
00:39:36 <Lokathor> EvanR, background color isn't a uniform, it's per cell.
00:40:10 <Lokathor> my current thoughts are that I'll have 1 texture uniform and a slightly bulky vertex data entry and that's it
00:40:15 <EvanR> the grid of configurations is a uniform
00:40:33 <EvanR> you dont need any texture
00:40:45 <EvanR> except for the texture you already loaded into a unit prior
00:40:50 <Lokathor> the texture data is the tilemap, yeah
00:41:17 <EvanR> for each frame you just need this array of config, which is one array uniform or one for each "field"
00:41:31 <EvanR> bgcolor, tileindex, etc
00:41:48 <Lokathor> ...do you mean "vertex buffer object"?
00:41:53 <EvanR> no way
00:42:12 <EvanR> youre not using more than one triangle are you ;)
00:42:22 <Lokathor> i'm totally not familiar with how a single uniform can store all the data for all the cells of the screen
00:42:30 <EvanR> its an array
00:42:30 <Lokathor> I'm using 2 triangles per cell?
00:43:23 <Lokathor> side note: http://imgur.com/a/GV8Wg hey cool font stuff!
00:44:11 <EvanR> classic
00:47:03 <Lokathor> EvanR, I don't think that I'm gonna change my short term design at this point, because i'm sticking to what I know how to do
00:47:06 <Lokathor> but, that said
00:47:14 <Lokathor> what's this about drawing it all in just 2 triangles?
00:47:26 <EvanR> really you only need 1
00:47:30 <EvanR> 2x as efficient!
00:47:44 <Lokathor> assuming, say, 80x24 cells for a standard display
00:48:00 <EvanR> right, youre not really getting any benefit from having 2 triangles per cell
00:48:15 <EvanR> its not buying you anything
00:48:22 <EvanR> the shader runs the same for all of them
00:48:36 <Lokathor> at the moment it's buying me "i can think about the problem easier"
00:48:41 <Lokathor> but there's no technical advantage, no
00:48:51 <EvanR> i cant see any difference 
00:48:54 <Lokathor> remember that i've only known anything at all about ogl for 3 weeks
00:49:40 <EvanR> thats pretty good, then you dont know anything about "the old ways"
00:49:51 <EvanR> RIP
00:50:49 <Lokathor> https://learnopengl.com/#!Getting-started/Hello-Window I have completed the "Getting Started" section (using gl and GLFW-b), and browsed the other sections and some other GLSL advice stuff
00:50:52 <Lokathor> and that's about it
00:51:25 <EvanR> also pretty cool https://open.gl/
00:51:42 <EvanR> and if you go to ##opengl tell them all about haskell
00:52:03 <Lokathor> i think they'll laugh at my silly garbage collected language :/
00:55:16 <Lokathor> Once I have Hexes in a usable state, I plan to learn much more OpenGL stuff
00:55:33 <Lokathor> however, I think that right now I gotta focus on finishing a project as much as possible, or i will not finish the project :P
01:16:32 <suppi> anyone knows why this happens? kinda looks like a compiler/library bug http://lpaste.net/9117597983175606272
01:17:14 <mauke> suppi: looks OK to me
01:17:28 <mauke> what did you expect to happen?
01:17:45 <suppi> i expected no warning since the literal is within range
01:18:14 <mauke> no, it's not
01:18:16 <Lokathor> suppi, (i think) what's happening is that it's reading the literal 2147483648 (which is outside the upper bound) and then applying the negation function to it
01:18:19 <mauke> it even tells you why
01:18:33 <mauke> "Literal 2147483648 is out of the Int32 range -2147483648..2147483647"
01:18:35 <c_wraith> suppi: there's an extension that enables negative literals.  Try that out.
01:18:49 <mauke> "If you are trying to write a large negative literal, use NegativeLiterals"
01:19:13 <suppi> oh, i see. thanks.
01:19:23 <suppi> why isn't that the default behaviour though?
01:19:33 <EvanR> > -0 :: Double
01:19:35 <lambdabot>  -0.0
01:19:42 <Lokathor> historical stuff, probably
01:19:50 <EvanR> behold the only real reason
01:20:16 <Maxdamantus> let n = 4 in -n
01:20:20 <Maxdamantus> > let n = 4 in -n
01:20:22 <lambdabot>  -4
01:20:34 <Maxdamantus> maybe there are no negative literals.
01:20:42 <suppi> -n ???
01:20:42 <EvanR> not without the extension
01:20:58 <suppi> thanks everyone
01:21:55 <Lokathor> Maxdamantus, does -4^2 equal 16 or -16? The internet will never know :P
01:22:04 <mauke> personally I'd like it better if there were negative literals, unary - didn't exist, and 'negate' were shortened to 'neg'
01:22:20 <suppi> ^
01:22:23 <EvanR> if negate 0 gives something different than -0 for Doubles, and thats the surprising consequence of just having negative integer literals.... 
01:22:39 <EvanR> seems like a no brainer, Double is the "surprising" dumpster
01:22:41 <suppi> though i rather not short negate to neg :P
01:22:47 <Lokathor> EvanR, you never said how to draw the entire grid in a single triangle
01:22:55 <EvanR> exercise for the reader
01:22:59 <Lokathor> oh no!
01:23:03 <Lokathor> :3
01:23:04 <EvanR> two stars
01:23:24 <Lokathor> doThing((**void)0);
01:23:38 <Maxdamantus> > read "-0" :: Double
01:23:39 <lambdabot>  -0.0
01:23:52 <EvanR> kind of surprising
01:23:53 <Maxdamantus> Don't see why that has to do with not having negative literals.
01:24:22 <EvanR> no idea how that read instance works
01:24:23 <mauke> > fromRational (-0) :: Double
01:24:25 <lambdabot>  0.0
01:24:27 <Maxdamantus> Doesn't seem surprising to me .. whatever handles the negation will just calculate the thing after it then negate that.
01:24:50 <Maxdamantus> It might have to do something special there for Int
01:25:22 <EvanR> with negative literals, -0 :: Double would be +0
01:25:33 <mauke> depends on how you spec it
01:25:51 <Maxdamantus> > read "-9223372036854775808" :: Int
01:25:53 <lambdabot>  -9223372036854775808
01:26:11 <Maxdamantus> > let n = read "9223372036854775808" :: Int in -n
01:26:13 <lambdabot>  -9223372036854775808
01:26:22 <Maxdamantus> O_o
01:26:25 <EvanR> lol
01:26:32 <Maxdamantus> Ah, right, that still works.
01:26:46 <EvanR> > negate 9223372036854775808
01:26:48 <lambdabot>  -9223372036854775808
01:26:59 <mauke> > minBound `div` (-1) :: Int
01:27:01 <EvanR> > negate (negate 9223372036854775808)
01:27:01 <lambdabot>  *Exception: arithmetic overflow
01:27:02 <lambdabot>  9223372036854775808
01:27:10 <EvanR> > negate (negate 9223372036854775808) :: Int
01:27:12 <lambdabot>  -9223372036854775808
01:27:15 <Maxdamantus> > let n = read "9223372036854775808" :: Int in (n, -n)
01:27:16 <lambdabot>  (-9223372036854775808,-9223372036854775808)
01:27:21 <EvanR> > negate (negate (negate 9223372036854775808)) :: Int
01:27:23 <lambdabot>  -9223372036854775808
01:27:28 <EvanR> fun
01:27:31 <Maxdamantus> Hm ..
01:27:31 <suppi> :(
01:27:40 <mauke> > negate minBound == minBound
01:27:42 <lambdabot>  error:
01:27:42 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘negate’
01:27:42 <lambdabot>        prevents the constraint ‘(Num a0)’ from being solved.
01:27:45 <EvanR> this version of negate takes its negating seriously
01:27:48 <Maxdamantus> > let n = read "9223372036854775808" :: Int in n == -n
01:27:50 <lambdabot>  True
01:27:51 <mauke> > negate minBound == (minBound :: Int)
01:27:53 <lambdabot>  True
01:27:58 <Maxdamantus> wtf
01:28:14 <suppi> this is a haskell wat talk material right there
01:28:22 <Lokathor> welcome to the magic of uneven bounds in the integral types
01:28:24 <mauke> you used to be able to crash ghci with minBound `div` (-1) :: Int
01:28:28 <mauke> suppi: no
01:28:40 <mauke> this is how two's complement works
01:28:48 <Lokathor> suppi, this is true in any language that has sized integral types
01:29:17 <Lokathor> Python, Erlang, and a few others can escape such a problem though
01:29:27 <EvanR> this is a case of haskell teaching stuff that doesnt get learned outside C
01:30:10 <EvanR> and its easier here because we dont have to constantly be lawyering over undefined behavior
01:31:34 <Lokathor> does haskell have much UB in the core language / base package itself?
01:32:02 <EvanR> unsafeFoo will do it
01:32:20 * Maxdamantus has to think more about two's complement to convince himself that `n == -n` for a non-zero `n`
01:32:24 <Lokathor> I know that System.Random declares at least one UB situation, but packages declaring UB seems somehow "fineish"
01:33:49 <mauke> Maxdamantus: take a bit patttern of 100000...0000, flip all bits, then add 1
01:34:19 <Maxdamantus> Okay, that works.
01:34:35 <EvanR> 100000000 is arbitrarily one or the other minBound or maxBound
01:34:45 <EvanR> like the other side of a loop
01:35:17 <EvanR> and negate sends you to the opposite hemisphere of the loop, and theres two poles
01:35:51 <suppi> Maxdamantus: maybe this can help? https://soupi.github.io/insect/
01:36:43 <Maxdamantus> Doesn't work on my phone.
01:36:49 <Maxdamantus> Will try in a few minutes.
01:37:31 <halogenandtoast> If I have some ADT (Foo Rank Value) and I want to write a spec that says if Rank is the same, compare Value, can I use QuickCheck to write that constraint?
01:39:20 <halogenandtoast> QuickCheck is always black magic to me, but I want to try it out if I can.
01:49:30 <halogenandtoast> Maybe that's too much work...
01:53:09 <Maxdamantus> halogenandtoast: well, you just have to express implication in your property.
01:53:37 <Maxdamantus> `rankIsSame v` implies `somethingElse v`
01:53:52 <Maxdamantus> ie, `not (rankIsSame v) || somethingElse v`
01:55:37 <halogenandtoast> hmm
01:55:54 <halogenandtoast> I think I'd need to see an example to understand, I'm attempting to write it now.
01:56:05 <halogenandtoast> Creating Arbitrary instances for my types currently.
01:56:54 <Maxdamantus> Apparently quickcheck has an actual combinator for implication.
01:57:22 <Maxdamantus> so you can avoid having tests that just end up in that `not (rankIsSame v)` branch
01:58:00 <Maxdamantus> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#v:-61--61--62-
01:59:13 <halogenandtoast> Yeah I'm reading through the manual, I've just written 0 quick check checks
01:59:21 <halogenandtoast> So here goes nothing
02:01:58 <halogenandtoast> Think I've managed to create my arbitary instances
02:02:02 <halogenandtoast> (compiled)
02:10:20 <Lokathor> EvanR, I *think* something like this is what I'm gonna use for my fragment shader http://lpaste.net/355875
02:10:36 <Lokathor> but like, with real inputs and outputs and stuff. but the mixing bit in the middle is i think how i wanna mix it
02:12:34 <halogenandtoast> I feel like I'm close, but far off. If anyone knows QuickCheck and Hspec: https://gist.github.com/halogenandtoast/2510b3384bbb130dcc8f567466e789b3
02:14:14 <halogenandtoast> Oh I probably can't use property like that for one.
02:15:51 <halogenandtoast> Update gist with attempt #2
02:16:52 <halogenandtoast> Next mistake is I should be use `===` and not `==`
02:16:57 <halogenandtoast> s/use/using/
02:17:59 <halogenandtoast> Updated with that fix now.
02:20:29 <halogenandtoast> Nailed it!
02:21:31 <halogenandtoast> for anyone interested: https://gist.github.com/halogenandtoast/2510b3384bbb130dcc8f567466e789b3
02:24:08 * hackage wryte 0.2.0.0 - Pretty output for source generators  https://hackage.haskell.org/package/wryte-0.2.0.0 (TobiasDammers)
02:29:02 <halogenandtoast> confirmed, QuickCheck is amazng.
02:29:09 <halogenandtoast> *amazing
02:40:38 * hackage list-tries 0.6.4 - Tries and Patricia tries: finite sets and maps for list keys  https://hackage.haskell.org/package/list-tries-0.6.4 (MattiNiemenmaa)
02:54:08 * hackage Glob 0.8.0 - Globbing library  https://hackage.haskell.org/package/Glob-0.8.0 (MattiNiemenmaa)
03:04:58 <jgt> hey folks
03:05:25 <jgt> what's a reasonable strategy for performing a one-time data migration for a Yesod/Postgres app?
03:05:42 <jgt> hand-write some SQL, SCP it to the machine, and just run it?
03:09:24 <srhb> jgt: As in moving the data from one database to another?
03:09:37 <srhb> jgt: Or one postgres instance to another, rather.
03:10:11 <jgt> srhb: simpler than that (I think?). Moving data from one table to another.
03:10:11 <srhb> Or are we talking schema migrations?
03:10:23 <srhb> jgt: Oh. Yeah, that sounds reasonable.
03:10:42 <jgt> Ok. Thanks :)
03:10:54 <srhb> jgt: As long as you can get persistent (if that's what you're using) to recognize the new tables :)
03:11:43 <jgt> yeah, the new table was created automatically with persistent, but the data I have exists in the old table still
03:16:44 <ph88^> if i do runConduit on a sourceFile can i then afterwards run another conduit where the previous one left off ?
04:13:24 <ph88^> this is probably the quietest moment in this channel ^^
04:14:51 <sbrg> channel is quiet all the time on my end, since  I don't see all the joins/parts
04:16:10 <ph88^> let's start making some noise sbrg 
04:16:26 <cocreature> ph88^: that doesn’t make sense. you can’t call runConduit on a sourceFile. runConduit requires that your inputs are () and your outputs are Void which boils down to having consumed all inputs and outputs
04:17:03 <ph88^> pardon my wording :P
04:17:22 <NextHendrix> hi guys, can anyone reccomend any haskell books that aren't just "learn haskell from the beginning"
04:17:27 <ph88^> i use runResourceT $ runConduit src   and friends
04:17:44 <ph88^> NextHendrix, real world haskell maybe ?
04:17:48 <cocreature> my point is that "runConduit src" doesn’t typecheck. you need to connect the source to a sink
04:18:13 <ph88^> cocreature, when i have a file as source .. can only consume some of the file as input and keep the rest of the file to run with another conduit ?
04:18:20 <ph88^> i have a sink
04:18:30 <ph88^> sourceToList is my sink
04:19:07 <cocreature> sourceToList mostly destroys the purpose of using a streaming library in the first place
04:19:24 <cocreature> also sourceToList will consume all of your file so I’m not sure what “the rest of the file” is supposed to be
04:19:58 <ph88^> how can i make it so that it doesn't consume all of my file
04:20:20 <cocreature> well where do you want it to stop?
04:20:39 <ph88^> i have a parser , if that's finished i want it to stop
04:21:02 <ph88^> the file is like "HEADER\0DATA"  i have a parser for Header ... if it succeed i know i arrived at the DATA part
04:21:33 <cocreature> I think you are going to need to make some minimal example that illustrates what you have and what you are trying to achieve. I’m having a hard time understanding your problem
04:22:39 <cocreature> maybe you are looking for the things described here https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#g:10
04:24:00 <ph88^> cocreature, this is my input file  https://bpaste.net/show/c93feb7758fd
04:24:24 <ph88^> oh connect and resume sounds good
04:26:06 <ph88^> cocreature, this is my function to parse the header https://bpaste.net/show/7eca9436ed3b
04:26:44 <ph88^> i found a function conduitParserEither to run attoparsec parsers with conduit (this i already have working for another parser)
04:27:15 <ph88^> the rest of the file i want to use conduitDecode from https://hackage.haskell.org/package/binary-conduit-1.2.4.1/docs/Data-Conduit-Serialization-Binary.html
04:28:27 <cocreature> note that ConduitM is a Monad so assuming your sinks are compatible, you can just combine them using do notation
04:29:10 <ph88^> can you give an example of that ?
04:29:21 <ph88^> all i know is that i can use  .| to connect stuff
04:32:52 <cocreature> actually I think conduitParser is not what you want. it will give you a stream of parsed tokens but you want to parse only one token
04:33:03 <ph88^> eh ok
04:33:10 <ph88^> yeah you're right
04:34:07 <cocreature> sinkParser is the right thing
04:34:29 <Sh4rPEYE> How can I read three digits with Trifecta to get an Int? I can save three digits separately na dthen join them somehow, but is there a better way?
04:34:51 <cocreature> Sh4rPEYE: I don’t think there is a better way
04:35:00 <Sh4rPEYE> Ok. 
04:35:04 <ph88^> cocreature, ok i think i can make that work with sinkParser .. but then i still don't know how to handle the data part of my file. How can i do that thing with the do notation you were talking about ?
04:36:43 <ph88^> google isn't helpful here if i type like "haskell combine sinks using do notation"
04:38:10 <cocreature> ph88^: http://lpaste.net/355880 should work I think but I’ve never used conduit so take this with a grain of salt
04:39:04 <ph88^> ok thanks cocreature i will take a look
04:39:23 <ph88^> that's it ? o_O
04:39:38 <cocreature> the magical power of do notation
04:40:00 <ph88^> how do i get the parseResult out though ?
04:40:10 <cocreature> well how do you want to get it out
04:40:30 <ph88^> well ideally i still want that information but i don't want to pass it along the entire conduit
04:40:38 <ph88^> there are more conduits along the way for the actual data part
04:41:23 <ph88^> i mean the type that you gave   ConduitM ByteString Int m ()   looks to me that this conduit should be generating Int  ?
04:41:29 <cocreature> right
04:41:46 <cocreature> you can change that to anything supported via binary
04:43:05 <cocreature> you can either make that some sumtype and use yield to output parseResult or you can put it in the result type of your conduit
04:45:00 <ph88^> i don't understand the 3 options you are giving me sorry ...  sumtype -- a tuple? where does it go?    yield? i can only yield 1 type i think      the result type of my conduit i think i will have to carry that type around to the other conduits functions which i don't want
04:45:26 <cocreature> a tuple is a product type. Either is a sumtype
04:45:37 <cocreature> why do you not want that?
04:46:07 <cocreature> I mean I guess you could write it to some IORef and escape it that way but I wouldn’t consider that to be a better solution
04:47:09 <ph88^> if you write that conduit with Either .. do you have to run it twice ?
04:47:48 <ongy> when I have an Enum (well, Sumtype used as enum) is there an easy way to create another type that has all the same elements + some more? (I'm ok with TH, but don't want to write it myself)
04:47:52 <cocreature> sorry I’m not following. I really think you should show us the complete example of what you are trying to do with comments where you are having problems
04:47:59 <ph88^> i just mean when i have   src .| parseEntireFile   (this could be of type (Header, Double)  .| handleDouble1 .| handleDouble2 ... snk
04:48:14 <ph88^> am i passing the entire header here for each double i want to process in the data ?
04:49:02 <ph88^> or i have a   Either Header Double  ?
04:49:43 <Sh4rPEYE> How can I simplify this: 
04:49:48 <Sh4rPEYE> parseAreaCode' =
04:49:48 <Sh4rPEYE>   ( try (char '+') >> anyChar >>= \c1 ->
04:49:50 <Sh4rPEYE>       anyChar >>= \c2 -> anyChar >>= \c3 -> return $ readDigits [c1, c2, c3]
04:49:50 <Sh4rPEYE>     )
04:49:52 <Sh4rPEYE>     <|> return 420
04:50:15 <Sh4rPEYE> Sorry, messed up formatting: 
04:50:16 <Sh4rPEYE> (try (char '+') >> anyChar >>= \c1 -> anyChar >>= \c2 -> anyChar >>= \c3 -> return $ readDigits [c1, c2, c3]) <|> return 420
04:51:24 <ph88^> cocreature, ok i will just try to do it with the do notation and the tuple and get back later when it works, can worry about refactoring later
04:51:53 <ph88^> Sh4rPEYE, one thing that would help me is the do notation .. can you rewrite it using do ?
04:52:45 <Sh4rPEYE> ph88^: I'm not sure how can I specify that I want to get the three chars only when the char '+' succeeds
04:52:55 * mniip prods glguy
04:53:59 <ph88^> Sh4rPEYE, the problem is that your try is only on the (char '+')  ... why don't you try do-notation then you can write this down less confusing
04:57:56 <Sh4rPEYE> ph88^: Oh, well, I had no idea I can try the whole do-notation block :-D
04:58:11 <ph88^> Sh4rPEYE, https://bpaste.net/show/282ff3046e10
04:58:38 <Sh4rPEYE> Yep, just like that. Thanks
04:58:53 <ph88^> the return type is not compatible
04:59:10 <ph88^> you return [c1, c2, c3] :: [a] or otherwise 420 :: Int
05:07:21 <ph88^> cocreature, sorry i still don't understand, how can i get parseResult out ?  https://bpaste.net/show/709a1c47ef91  this type checks but i just don't know where it goes
05:07:45 <cocreature> ph88^: it’s like any other value in do notation. if you don’t use it, it gets discarded
05:08:02 <ph88^> yeah, but i still like to use it
05:08:15 <cocreature> but where do you want to use it?
05:08:52 <cocreature> an easy solution is to change the type signature to ConduitM ByteString Double m ParseResult and add "pure parseResult" at the end of your do block
05:08:56 <ph88^> after the whole conduit thing is done
05:09:00 <cocreature> then use that
05:09:06 <ph88^> like at the end of the program i want to show some kind of summary
05:09:43 <ph88^> wow ok .. 
05:10:00 <ph88^> i can see how this can work, it's pretty obvious now that i see it o_O
05:10:09 <ph88^> didn't think of it this way
05:10:26 <ph88^> but that also means that you can write a conduit with a sink inside it, eh ok
05:10:31 <ph88^> interesting stuff  :D
05:10:31 <sullyj3> Hey all, so I want to get a line of input and read it as an int using readLn, then feed that into replicateM_ using a combinator. I want to minimize flipping and lambda-izing, so, I think (>>=) and (>=>) are out. What's the most elegant way?
05:10:38 <cocreature> ph88^: Sink is just a type synonym
05:10:52 <ph88^> i mean even conceptually ..
05:11:26 <ph88^> sullyj3, can you show the code in the not so elegant way ?
05:12:27 <cocreature> ph88^: you might want to take a look at the source for some of the standard sinks like "consume" and figure out how they are implemented in terms of "await".
05:12:45 <ph88^> ok
05:12:52 <sullyj3> ph88^:   (readLn >>= replicateM_) interactLine (stringify roundGrade))
05:12:56 <sullyj3> oops
05:12:59 <sullyj3> wrong one
05:13:04 <sullyj3> readLn >>= (\n -> replicateM_ n (putStrLn "Hello, world!"))
05:13:08 <ph88^> cocreature, this reminds me somewhat of railroad programming
05:13:23 <cocreature> I don’t know what that is although I vaguely recall having heard the term at some point
05:14:55 <ph88^> sullyj3, i think your code already looks good
05:15:41 <sullyj3> I guess I can get rid of a pair of brackets
05:15:47 <cocreature> sullyj3: do n <- readLn; replicateM_ n (putStrLn "Hello, world!") no lambdas and flips! :)
05:16:27 <sullyj3> cocreature haha, I just rewrote this from exactly that
05:16:45 <cocreature> sullyj3: why? using do notation is completely fine
05:16:54 <cocreature> so is using lambdas
05:17:01 <sullyj3> I know, I'm just fond of pipelines
05:17:29 <sullyj3> and naming functions, not data
05:19:42 <cocreature> how does "readLn >>= \n -> …" name more functions and less data than using do notation
05:19:59 <cocreature> apart from the fact that I’m not sure why you would want to avoid naming things if you have good names for them
05:20:28 <sullyj3> It names more data by introducing an n parameter
05:20:40 <cocreature> but that’s exactly the same n you have in your lambda
05:21:04 <sullyj3> I'm saying I don't like the lambda either
05:21:28 <cocreature> *shrug*
05:21:43 <sullyj3> haha. I have delicate aesthetic sensibilities
05:22:02 <sullyj3> disliking code style is the ultimate first world problem
05:27:21 <sullyj3> here's the code that was for, for the record:
05:27:31 <lpaste> sully pasted “Grading” at http://lpaste.net/355882
05:29:57 <srhb>  
05:32:42 * hackage gi-gstbase 1.0.13 - GStreamerBase bindings  https://hackage.haskell.org/package/gi-gstbase-1.0.13 (inaki)
05:33:10 <ongy> when I have an Enum (well, Sumtype used as enum) is there an easy way to create another type that has all the same elements + some more? (I'm ok with TH, but don't want to write it myself) (asking again, since I didn't see any answer and it's slower now)
05:45:53 <lyxia> data Enum2 = Enum1 MyEnum | More   ...?
05:47:22 <ongy> lyxia: I'm using it in an xmonad-esque user writes haskell config style, and I would like to avoid that
05:48:15 <lyxia> mess with TH then
05:48:16 <ongy> hmhm, I think a typeclass could actually do the trick here...
05:49:51 <ongy> so we can have (Num a => a; 5), can I recreate something like that?
05:54:25 <Sh4rPEYE> Why does this throw "expected '.'"? 
05:54:25 <Sh4rPEYE> parseOctet = try (char '.' ) >> integer
05:54:26 <Sh4rPEYE> parseString parseOctet mempty "123"
05:54:40 <Sh4rPEYE> Shouldn't it just skip over the dot if it's not there?
05:58:36 <cocreature> Sh4rPEYE: try does not affect whether a parser fails or not. it only affects how much input it consumes if it fails
05:58:57 <cocreature> Sh4rPEYE: and try around a "char" parser is a noop since that won’t consume input if it fails anyway
05:59:03 <Sh4rPEYE> Oh, so I have to use <|>
05:59:11 <cocreature> or "optional"
06:04:18 <xa0> i have an issue with ghc -c -XForeignFunctionInterface, it generates errors like the following http://i.imgur.com/M6ZpAhT.png
06:04:19 <sullyj3> I'm not understanding the error message this line gives me:
06:04:21 <sullyj3> > 1 <$> (\x -> const x "Irrelevant") <*> show
06:04:23 <lambdabot>  error:
06:04:23 <lambdabot>      • No instance for (Typeable a0)
06:04:23 <lambdabot>          arising from a use of ‘show_M416000496442651177910270’
06:04:24 <xa0> clearly it's not linking dependencies
06:04:30 <xa0> but i have no idea why
06:04:40 <sullyj3> whoa that's a different error again to the one from ghci
06:05:07 <sullyj3> wait, i get it
06:05:22 <sullyj3> > (const 1 0) <$> (\x -> const x "Irrelevant") <*> show
06:05:24 <lambdabot>  error:
06:05:24 <lambdabot>      • No instance for (Typeable a0)
06:05:24 <lambdabot>          arising from a use of ‘show_M772623535083786463710319’
06:05:27 <sullyj3> oh
06:06:58 <sullyj3> > (const 1) <$> (\x -> const x "Irrelevant") <*> show
06:07:00 <lambdabot>  error:
06:07:00 <lambdabot>      • No instance for (Typeable b0)
06:07:00 <lambdabot>          arising from a use of ‘show_M449860553341821052510396’
06:11:02 <sullyj3> > (const 1) <$> (const 100) $ 6
06:11:04 <lambdabot>  1
06:11:28 <sullyj3> > (const 1) <$> (const 100) <*> (const 1000000000) $ 6
06:11:29 <lambdabot>  error:
06:11:30 <lambdabot>      • Could not deduce (Num a0)
06:11:30 <lambdabot>        from the context: (Num (a -> t), Num a)
06:16:15 <lyxia> sullyj3: give some types to the literals
06:18:11 <lyxia> xa0: do you have the code somewhere
06:18:29 <ph88^> how can i get the result of the conduit (as [Double]) and also get the other result :: a    ?
06:18:34 <ph88^> https://bpaste.net/show/07754278a3cb
06:19:09 <sullyj3> lyxia, nah I don't think it's that
06:19:09 <xa0> lyxia: sure, http://github.com/bqv/hebi - the three relevant objects are plugin/haskell, plugin/haskell/Plugin and plugin/haskell/Message
06:19:16 <sullyj3> (flip const) 100 <$> pure <*> const 1000 $ 40
06:19:21 <sullyj3> > (flip const) 100 <$> pure <*> const 1000 $ 40
06:19:22 <lambdabot>  40
06:21:21 <lyxia> sullyj3: annotations would make the error messages more descriptive
06:22:32 <lyxia> ph88^: https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#v:fuseBoth
06:23:29 <sullyj3> > const (1::Int) <$> (const (100::Int)) <*> (const (1000000000::Int)) $ (6::Int)
06:23:31 <lambdabot>  error:
06:23:31 <lambdabot>      • Couldn't match type ‘Int’ with ‘Int -> t’
06:23:31 <lambdabot>        Expected type: Int -> Int -> t
06:24:00 <ph88^> lyxia, how can i use that ? i have now a single conduit, looks like this function is for two conduits
06:25:15 <lyxia> ph88^: you use that instead of .|
06:25:45 <sullyj3> > pure (flip const) <*> pure "meh" <*> pure "woohoo!"
06:25:46 <lambdabot>  error:
06:25:47 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M707573522813...
06:25:47 <lambdabot>        prevents the constraint ‘(Show (f0 [Char]))’ from being solved.
06:26:05 <sullyj3> > pure (flip const) <*> pure "meh" <*> pure "woohoo!" :: Maybe String
06:26:07 <lambdabot>  Just "woohoo!"
06:26:13 <lyxia> xa0: and what did you do to get the error
06:26:28 <xa0> lyxia: tried to link using make
06:26:47 <xa0> it only happens when i try and import a dependency in the FFI haskell
06:26:51 <xa0> if i don't, it works fine
06:27:10 <roylee> '
06:27:13 <hexagoxel> debugging parsers 'unexpected end of input, expecting "foo", "bar", white space or end of input'
06:27:19 <hexagoxel> parsec seems to be confused :/
06:30:50 <hexagoxel> on a related note, are there any counterarguments to moving to megaparsec?
06:33:18 <ertes> hexagoxel: not really…  perhaps historical momentum, which manifests as better library support for parsec
06:47:41 <lyxia> xa0: I'm not sure what's going wrong but I can compile it if I don't compile the haskell modules separately and just specify the hs files in the final command
06:48:21 <xa0> lyxia: ah okay, maybe I'll compile it like that then. Thanks!
06:48:21 <lyxia> xa0: it was also not failing with the ghc -c command but the last one that link everything together
06:48:36 <xa0> Yeah
06:48:42 <Sh4rPEYE> How can I "strip" the data I get from parser off the Result datatype?
06:49:02 <lyxia> xa0: by the way there are some .hi files in that repo that can be removed
06:49:27 <xa0> I saw, I've removed them locally
06:49:32 <xa0> Thanks though
06:50:39 * hackage http-pony 0.1.0.7 - A type unsafe http library  https://hackage.haskell.org/package/http-pony-0.1.0.7 (JinjingWang)
06:51:33 <lyxia> xa0: AH. actually another fix is -package text
06:52:00 <xa0> Oh fantastic, do I put that in the link command?
06:52:22 <lyxia> xa0: I think that by passing .hs it guessed from the import statements that text is a dependency, whereas with just the object files you have to make it explicit.
06:52:53 <lyxia> xa0: you can pass it in GHCOPTS
06:52:53 * angerman is going to be a round, if someone has questions regarding the yesod cross compilation
06:53:12 <halogenandtoast> angerman: I just solved yesod cross compilation
06:53:25 <lyxia> xa0: oh wait you're not using that in the link command...
06:53:25 <halogenandtoast> with Docker at least :p
06:53:42 <xa0> Yeah
06:54:02 <xa0> I didn't want the -XFFI in there for linking
06:54:09 <lyxia> xa0: well I just added it line 24 of the makefile
06:54:17 <angerman> halogenandtoast: well, with that I can't help you :p, but if there are questions regarding https://medium.com/@zw3rk/cross-compiling-yesod-to-raspberry-pi-f14de6fdbf06, I might be able to ;-)
06:54:23 <xa0> Ok, gotcha
06:54:25 <lyxia> maybe LIBRARIES is a good place for that optioon
06:54:32 <xa0> Yeah
06:54:51 <angerman> halogenandtoast: the benefit is, it doesn't restrict you to docker targets ;-) That however might not be of concern to you.
06:55:47 <sullyj3> @let readNRun f = liftM f readLn >>= print
06:55:49 <lambdabot>  Defined.
06:56:07 <sullyj3> > readNRun (++ [3,4])
06:56:09 <lambdabot>  <IO ()>
06:56:22 <sullyj3> @pl f
06:56:22 <lambdabot> f
06:56:33 <sullyj3> @pl readNRun f = liftM f readLn >>= print
06:56:33 <lambdabot> readNRun = (print =<<) . flip fmap readLn
06:57:32 <halogenandtoast> angerman: Yeah I just wanted to easily deploy my Yesod app.
06:57:43 <lyxia> readLn >>= print . f
06:57:52 <halogenandtoast> While cool, I've never even seen a raspberry po
06:58:02 <sullyj3> lyxia ta
06:58:04 <hexagoxel> my current guess is that the error is connected to me using `fail` in Parsec. (I do some semantic checking/conversion as a separate step, but still in the Parsec monad.) Any hints regarding using `fail` in such a manner?
06:58:26 <angerman> halogenandtoast: yea, I've been doing the same targetting a linux system.
06:59:20 <angerman> halogenandtoast: the Raspberry Pi, isn't really a restriction, it's just one target where cross compiling to make sense. I've the same setup for android and ios, I just only can write so many articles at once :-)
07:01:28 <ph88^> is it required to use ! together with UNPACK ?  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma
07:01:52 <ertes> Sh4rPEYE: which library?
07:02:02 <lyxia> hexagoxel: for the kind of checking you mention it might be better to raise the error at another level
07:02:08 <Sh4rPEYE> ertes: Sorry, solved already
07:02:13 <ertes> ah
07:02:35 <Sh4rPEYE> ertes: But it was Trifecta and I wrote a little maybeResult myself.
07:03:27 <sullyj3> :t print . (id::(Int->Int)) =<< readLn
07:03:29 <lambdabot> IO ()
07:04:08 * hackage weeder 0.1.4 - Detect dead code  https://hackage.haskell.org/package/weeder-0.1.4 (NeilMitchell)
07:05:07 <ph88^> what's a HOF ?
07:05:52 <lyxia> a higher-order function is a function which takes a function as an argument
07:07:30 <hexagoxel> lyxia: but my semantic errors still have SourcePos connected to them. I'd have to replicate the parser's error-print, more or less.
07:08:36 <hexagoxel> (nonetheless what you recommend will be my next step, just to make sure this is the problem.)
07:24:38 <radi> Hello folks, I'd like to ask about Pipes. How do I "flatten" pipe? I hope this type signature is helpful enough: `flatten :: Pipe (Producer a m r) a m r`
07:25:54 <Sh4rPEYE> Hey. I have a Map of values; I want to find the highest value and return its key. How can I do that?
07:28:08 * hackage case-insensitive 1.2.0.10 - Case insensitive string comparison  https://hackage.haskell.org/package/case-insensitive-1.2.0.10 (BasVanDijk)
07:28:45 <bennofs> radi: not familar with pipes at all, but perhaps something like 'forever $ do act <- await; act ' would work
07:29:13 <bennofs> (or 'forever (join await))')
07:29:20 <Sh4rPEYE> Hey. I have a Map of values; I want to find the highest value and return its key. How can I do that?
07:29:31 <Sh4rPEYE> (sorry I timed out)
07:30:07 <Rembane> Sh4rPEYE: A Data.Map Map?
07:30:11 <Sh4rPEYE> Yep
07:30:18 <lyxia> Sh4rPEYE: use toList and maximumBy
07:30:33 <halogenandtoast> ^^
07:30:35 <bennofs> Sh4rPEYE: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html#v:findMax
07:30:36 <Sh4rPEYE> Oh, sure... toList
07:30:40 <bennofs> there's a findMax function
07:30:48 <pavonia> That's for the max key only
07:30:49 <bennofs> oh sorry, you want hightest value
07:30:57 * bennofs needs to learn to read
07:31:40 <akr`_> Hello, I have recentrly come into maintaining a fairly large Haskell server. For the most part, the codebase is pretty solid and easy to navigate etc., however sometimes, randomly, a random request freezes or fails for no apparent reason. How could I investigate this further? I should perhaps mention that the server uses fastCGI and runs on GHC 6.12…
07:32:10 <radi> @Sh4rPEYE : try foldWithKey ?
07:32:10 <lambdabot> Unknown command, try @list
07:32:38 * hackage lifted-base 0.2.3.11 - lifted IO operations from the base library  https://hackage.haskell.org/package/lifted-base-0.2.3.11 (BasVanDijk)
07:33:08 <radi> bennofs: compile error ... `flatten = forever (join await)`
07:33:15 <halogenandtoast> radi: you would need some starting value right?
07:33:19 <halogenandtoast> for foldWithKey
07:33:41 <Rembane> If the values are Bound you can use the smallest value.
07:34:47 <radi> halogendandtoast : Yes, but as Rembane said you can use the smallest value ...
07:35:31 <halogenandtoast> but that would mean an empty map could return the smallest value
07:35:43 <halogenandtoast> which is a problem anyways I guess
07:35:54 <halogenandtoast> how to handle an empty Map I mean
07:37:04 <Rembane> I think an if-expression could handle that. If the map is empty, do something otherwise return the greatest value.
07:37:08 * hackage scientific 0.3.4.13 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.13 (BasVanDijk)
07:37:26 <radi> `if null map then Nothing else Just ( ... do the foldWithKey here ...)` ?
07:37:32 <lyxia> radi: you have to modify the producer before joining it. await >>= \p -> for p absurd
07:38:05 <lyxia> oh not "for"...
07:39:59 <radi> lyxia: compile error `flatten = await >>= \p -> Pipes.for p _`
07:48:38 <lyxia> radi: forever (await >>= \(p :: Producer a m r) -> every (Select (void p)))
07:48:59 <lyxia> radi: forever (await >>= every . Select . void)
07:49:53 <akr`_> sorry my connection died, let me repeat my question:
07:49:55 <akr`_> Hello, I have recentrly come into maintaining a fairly large Haskell server. For the most part, the codebase is pretty solid and easy to navigate etc., however sometimes, randomly, a random request freezes or fails for no apparent reason. How could I investigate this further? I should perhaps mention that the server uses fastCGI and runs on GHC 6.12…
07:49:56 <radi> lyxia: it compiles. thanks!
07:51:02 <bennofs> akr`_: is there any way you can reproduce the bug?
07:52:31 <bennofs> akr`_: i think you're best bet is to have fine-grained logging and hope to find the wrong part this way
07:54:05 <akr`__> bennofs: thanks, that was my initial thought as well
07:55:35 <akr`__> bennofs: I was wondering whether it could be connected to lazyness & memory usage somehow, but since the whole site never goes down, I guess not
07:55:36 <bennofs> akr`__: you may also look at GHC's eventlog system in combination with threadscope
07:55:56 <bennofs> akr`__: not sure if those work with GHC 6.12 though 
07:56:41 <bennofs> (i didn't even know haskell existed when that version was up to date :D)
07:57:19 <akr`__> bennofs: didn't know about those, thanks
07:57:24 <akr`__> looks promising at least
07:57:34 <akr`__> (apparently eventlog is available since 6.10, heh)
08:00:19 <cocreature> upgrade to a modern ghc and hope the bug goes away :)
08:00:38 * hackage paths 0.1 - Library for representing and manipulating type-safe file paths  https://hackage.haskell.org/package/paths-0.1 (HerbertValerioRiedel)
08:01:45 <cocreature> hvr: yet another filepath library? :)
08:02:12 <cocreature> hvr: the linked git repo is empty
08:03:11 <akr`__> cocreature: yeah, I'd like to, but the whole thing is using some patched libraries
08:03:15 <bennofs> hvr: so we now have 'path' and 'paths'? that feels like it might created quite some confusion
08:03:34 <akr`__> cocreature: plus things that might be hard to upgrade because, like template haskell
08:04:09 <cocreature> akr`__: those are all good points but I would be really worried that if you stick to ghc 6.12 you are going to run into some showstopper at so me point
08:04:31 <akr`__> yeah, I agree
08:04:57 <akr`__> not really enough time atm, I already spent like ~5 hours trying to move to stack the other day
08:05:06 <akr`__> didn't really make any progress
08:05:10 <cocreature> does stack even work with ghc 6.12?
08:05:28 <akr`__> well I was trying to move to 7.something as well iirc
08:10:09 * hackage config-value 0.6.3, config-schema 0.4.1.0 (EricMertens): https://qbin.io/n0didkny
08:32:48 <hvr> coltfred_: Stack doesn't even support GHC 7.6
08:32:51 <hvr> sorry,
08:32:58 <hvr> cocreature: Stack doesn't even support GHC 7.6
08:33:15 <cocreature> hvr: not even via system-ghc?
08:34:38 * hackage th-abstraction 0.1.3.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.1.3.0 (EricMertens)
08:36:24 <ongy> hm, I have a weird error with cabal, new-haddock fails with http://lpaste.net/355883
08:37:02 <hvr> cocreature: I can't find the email/issue, but afaik Stack prints a frightening warning when you use versions prior to GHC 7.8 that you're in unsupported territory and to expect problems
08:37:54 <cocreature> ongy: I think that’s a known error. I’ve seen similar errors several times
08:37:57 <hvr> ongy: what happens if you say 'cabal new-haddock all'?
08:38:16 <ongy> hvr: up to date
08:38:31 <hvr> ongy: good, now remove the dist-newstyle folder, and try again w/ new-haddock all
08:38:43 <hvr> you've hit two bugs in a row :)
08:38:52 <ongy> now it runs. Good to know
08:39:01 * hvr tries to fix the first one
08:39:12 <ongy> so I guess this is just a missing defaulting?
08:39:45 <ongy> The project I did this in is https://github.com/Ongy/monky-newbuild which I made after looking at the xmonad-testing repo for local builds with new-build
08:45:37 <ph88^> how can i use resumable source with conduit ?  https://bpaste.net/show/3d12321ca937
08:45:42 <ongy> does new-haddock have a --for-hackage equivalent?
08:46:27 <ph88^> oh i think i see a mistake here, i have to pattern match on that tuple !!
08:49:39 <ph88^> hey cocreature i got it i think ! wanna see ?
08:50:09 * hackage mailchimp 0.2.1 - Bindings for the MailChimp API  https://hackage.haskell.org/package/mailchimp-0.2.1 (jpvillaisaza)
08:51:09 <cocreature> ph88^: sure
08:51:39 <cocreature> ongy: --for-hackage was added very recently iirc but it doesn’t yet produce a tarball (there is an issue for it)
08:51:49 <ph88^> https://bpaste.net/show/f3a3c7706f1b
08:52:06 <ph88^> when i run it i get this though:  hGetBufSome: illegal operation (handle is closed)
08:52:09 <ph88^> o_O
08:52:51 <ongy> cocreature: hm, I'm pretty sure I'm on a git version from yesterday and it told me --for-hackage doesn't exist. But if there's no tarball yet, I'll probably do it the old way in an container
08:53:19 <cocreature> ongy: huh maybe I only saw the PR and it isn’t merged yet, let me check
08:54:45 <cocreature> ongy: https://github.com/haskell/cabal/pull/4490 hm, seems to be merged
08:55:27 <ongy> cocreature: it got renamed
08:55:54 <cocreature> oh right
08:56:08 <ongy> yea, works with the --haddock-for-hackage
08:56:09 <ongy> thx
08:58:25 <hvr> ongy: --haddock-for-hackage ... don't ask why
08:58:34 <hvr> nevermind
08:58:46 <ongy> thx anyways
08:58:53 <hvr> however, it doesn't tar itup
08:59:16 <ongy> but it seems to have a bug or 2. I don't get the tar AND I don't get the index.html (though cabal claims to have created it)
08:59:42 <hvr> yeah, as for the index.html, the bug here is only the message
08:59:59 <hvr> it turns out that it's correct not to generate it
09:00:13 <cocreature> hvr: any idea how hard it is to implement the tar’ing for someone not familiar with the cabal codebase? (e.g. me) that would remove 95% of the reasons that force me to still mess with sandboxes
09:00:44 <hvr> cocreature: I'd expect it to be doable :)
09:00:52 <ongy> oh why? Does hackage display the Description in the module header somewhere?
09:00:54 * hvr doesn't want to jinx it by saying "easy"
09:01:08 <hvr> ongy: hackage doens't use the index.html file
09:01:10 <cocreature> alright, I’ll take a look :)
09:01:15 <hvr> ongy: as it renders its own index
09:01:44 <ongy> also, why does it fail to link to e.g. Text? shouldn't it link to the haddock version of the documentation?
09:02:35 <hvr> ongy: that's maybe a 3rd issue/bug; in order to link to other packages, it'd need a haddock index for those; and afaik new-build doesn't yet support building that
09:03:14 <hvr> haddock meta-data is yet another artifact we need to build and store in the nix-store
09:03:17 <ongy> how would I get the local documentation built and linked up for *everything*?
09:03:27 <ph88^> how can i find out why an exception has been thrown ?
09:03:55 <hvr> ongy: I'm afraid I don't know *yet* -- i.e. I need to investigate
09:04:32 <hvr> (and possibly file a few tickets about it)
09:05:08 <ongy> :) I just noticed that I didn't look at my code in almost 9 months and well, it's split over packages and I need my documentation :D
09:06:11 <hvr> too bad our last-mile hsoc students can only start in mid-june... there's lots of stuff to do =)
09:06:40 <cocreature> ph88^: with profiling info you can use +RTs -xc
09:07:11 <ongy> oh right hsoc, when's 8.2 with cabal 2 scheduled? Like october?
09:07:25 <cocreature> ongy: huh? we already have rc2 of 8.2
09:07:38 <cocreature> if it would take until october to get the final release that would be pretty bad
09:07:46 <ongy> oh, I should keep track
09:08:17 <ph88^> cocreature, i don't see anything with those flags ... maybe i didn't build it in the right way ?    stack build --profile --fast --ghc-options="-j -auto-all +RTS -A128m -n2m -RTS"
09:08:31 <ph88^> i mean i see the usual output but that's it
09:08:48 <ongy> not sure if I will update before the arch repos either way... Have to see how the aur looks for ghc-git
09:09:02 <cocreature> arch hasn’t even updated to 8.0.2
09:09:06 <hvr> ongy: heh... I know ghc 8.2 running rather late... but it's supposed to get released in june latest
09:09:14 <ongy> yea, it's 8.0.1
09:09:48 <ongy> though ghc is currently the only thing I got from the repos
09:09:57 <cocreature> I even emailed the maintainer this week because it’s taken him so long to update to 8.0.2
09:10:22 <cocreature> ph88^: are you sure an exception is actually thrown?
09:12:24 <ph88^> in ghci an exception is thrown
09:13:23 <ph88^> brb
09:13:30 <cocreature> ftr the error was that ph88^ had used +RTs instead of +RTS
09:13:51 <ph88^> i copy paste your line :P
09:14:19 <cocreature> oh
09:14:23 <cocreature> *hides in shame*
10:02:38 * hackage monky 2.2.0.0 - A system state collecting library and application  https://hackage.haskell.org/package/monky-2.2.0.0 (ongyerth)
10:04:08 * hackage xmobar 0.24.5 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.24.5 (JoseAntonioOrtegaRuiz)
10:10:01 <p0a> Hello I'm trying to setup haskell-mode 
10:10:07 <p0a> on emacs. Is anyone familiar with it?
10:12:04 <p0a> I'm just trying to run a file, say, main = print "Hi."
10:12:16 <p0a> I have two buffers one with the file and one with the ghci session. not sure what to do
10:13:39 <p0a> Hm... I guess I get it now. I use C-c C-l and then type main in the ghci
10:13:46 <p0a> I had forgotten that 
10:21:55 <ph88^> cocreature, i have a nice trace of the exception now, https://bpaste.net/show/d47856cd5fd5   but i don't know what to do about it
10:27:15 <Gurkenglas> Is there some remaining webpage that provides hlint output now that lpaste doesn't?
10:28:46 <Lokathor> can't you just run hlint yourself?
10:40:24 <tsahyt> is there a lensy way to filter a list for all elements that do not match a prism?
10:40:40 * hpc has never been impressed with the quality of hlint's output
10:41:26 <tsahyt> e.g. [Foo, Bar, Quux] -> something something _Bar -> [Foo, Quux]
10:41:31 <kadoban> For those that don't know, hlint is configurable the "rules" it uses. Some don't seem to know that. If you find it too opinionated, or differently opinionated than you, you can fix that.
10:41:43 <hpc> oh, TIL
10:41:44 <pikajude> filter (not . has _Bar)?
10:41:49 <tsahyt> :t has
10:41:51 <lambdabot> Getting Any s a -> s -> Bool
10:41:52 <pikajude> does hasn't exist?
10:41:54 <pikajude> :t hasn't
10:41:56 <lambdabot> Getting All s a -> s -> Bool
10:41:57 <pikajude> it does
10:42:10 <tsahyt> works perfectly too! thanks :)
10:42:27 <pikajude> now, if this were scala, we could name this operator "does not have"
10:42:54 <tsahyt> hasn't is a weird function name. I'm not used to seeing ' inside of a name
10:42:56 <tsahyt> only at the end
10:43:03 <pikajude> yeah
10:43:07 <pikajude> that ed kmett is a tricky bastard
10:43:57 <EvanR> unusal for programming language to be grammatically correct
10:45:42 <tsahyt> after many years I've finally found something where lens is really worth its weight in gold. doing non-trivial rewrites and other transformations on ASTs is a breeze with lens
10:45:47 <tsahyt> Plated in particular
10:46:06 <jle`> "jquery for haskell"
10:46:31 <pikajude> jquery needs profunctors, imo
10:46:56 <Lokathor> importing Vector, Vector.Storable, and Vector.Storable.Mutable, oh boy
10:47:25 <dmj`> profunctors.js
10:47:48 <EvanR> Lokathor: C in any language!
10:47:54 <tsahyt> Lokathor: is that so unusual?
10:48:12 <tsahyt> in performance sensitive parts of the code I find myself doing this more than I care to admit
10:48:37 <Lokathor> tsahyt, all in the same module?
10:48:46 <Lokathor> hmm, i thought it was a little unusual, but perhaps not
10:48:52 <tsahyt> sometimes yeah, although I'd import them qualified
10:49:01 <Lokathor> yes, qualified indeed
10:49:02 <average> hi, how much money are you making with Haskell?
10:49:07 <average> straight up
10:49:14 <ph88^> why does this code make the handle closed ?   https://bpaste.net/show/0a8495d13144
10:49:14 <Lokathor> average, none I'm a janitor
10:49:18 <average> don't deviate from the question if you choose to answer it
10:50:00 <average> anyone else?
10:50:01 <EvanR> average
10:50:02 <monochrom> You don't own this channel. You don't tell me what I answer.
10:50:24 <average> monochrom: it's my question and I define what I feel an useful answer is for me.
10:50:48 <monochrom> But it is not your channel.
10:51:11 <tsahyt> the question has side effects, can't answer it
10:51:16 <average> never have I said this was my channel
10:51:19 <monochrom> heh
10:51:35 <EvanR> ill tell you when you need the answer
10:51:37 <monochrom> And yet you are ordering people around.
10:51:55 <average> monochrom: I'm not sure what your point is. are you trying to be a troll?
10:52:07 <lyxia> You're always asking the same question
10:52:08 <ongy> Lokathor: 4chan janitor? :)
10:52:09 <monochrom> My point is you're being bossy.
10:52:15 <Philonous> What's the best/easiest way to stay up to date wrt. papers on Haskell and Type Theory (particularly dependent types)? Is there an RSS feed for something like that?
10:52:26 <Lokathor> ongy, nope, just a normal place
10:52:49 <average> monochrom: and my point is I'm only interested if Haskell can generate income, how much, on what, and with what exact effort
10:52:55 <kadoban> Philonous: http://lambda-the-ultimate.org/ has some interesting stuff occasionally, though it's fairly low volume.
10:53:04 <kadoban> I'm sure there's better.
10:53:25 <Philonous> kadoban, Ah, nice, I forgot about that, I should subscribe to it. thanks.
10:53:34 <average> EvanR: you can tell me now for example :)
10:53:36 <ongy> haskell caffee has call for papers, which may be interesting to follow up on to see what got submitted
10:53:50 <average> yes, and how much money is made from submitting to a CfP
10:53:59 <average> about zero I suppose
10:54:00 <average> :)
10:54:08 <Lokathor> average, knowing Haskell will make you a better programmer in any language
10:54:08 <Gurkenglas> Trying to have intero have ghci write a type signature for me. intero's type shower gives http://lpaste.net/1225487184685957120 . My document doesn't have that many lines. Is there a better option here than to enable FlexibleContexts?
10:54:16 <Lokathor> the only cost is that you might hate programming in any other langauge at the same time
10:54:22 <average> Lokathor: I'm only interested in the financial/monetary aspect of Haskell
10:54:23 <bennofs> Philonous: i just found https://planet.haskell.org/, not idea how good it is
10:54:24 <average> nothing else
10:54:24 <EvanR> if you ask now then you get this ⟂ (a semantic middle finger)
10:54:41 <average> for me, if it doesn't make money, it doesn't matter
10:54:44 <Gurkenglas> Ideally, it would show the most specialized type signature that permits all its current uses.
10:55:01 <Philonous> ongy, bennofs, both look interesting, thanks
10:55:03 <Lokathor> average, if being a better programmer doesn't make you more money i'm not sure what's going on with your situation
10:55:15 <average> from my pov, being a better programmer is making more money
10:55:30 <EvanR> Lokathor: what a golden age we live in
10:55:34 <kadoban> Lokathor: The world isn't that rational or simple.
10:55:39 <monochrom> Being a manager makes you more money than being a programmer, better or worse.
10:55:40 <average> I personally don't care about monads, unless I can make tons of money with that
10:55:44 <bennofs> average: wouldn't coding in some ancient language be the best then?
10:55:53 <tsahyt> average: with that mindset it's unlikely you'll ever make much money
10:55:55 <tsahyt> just my 2c
10:55:56 <average> I genuinely and like.. from the heart don't care about the langauge itself, unless there's a lot of money to be made
10:56:02 <ongy> I hear cobol programmers make stacks of money in banks :)
10:56:07 <Lokathor> average, then you're best served by becoming a top shelf C programmer
10:56:10 <glguy> average: If your primary concern is amount of money you're going to make the you shouldfind another language
10:56:24 <tsahyt> yeah, cobol would be a good choice there tbh. you sacrifice your sanity for it though
10:56:33 <kadoban> average: I doubt haskell is worth your time if your sole desire is maximum money with minimum effort.
10:56:43 <monochrom> ongy, but are there a lot of openings?
10:56:44 <average> maximum money please, yes
10:56:47 <glguy> average: If you have a question about Haskell programs you're welcome to come back
10:56:48 <average> that's my desire
10:56:51 <kadoban> But then I kind of doubt programming is worth the time in that case either.
10:57:11 <Rotaerk> programmers make pretty good money
10:57:15 <Rotaerk> managers make more
10:57:20 <coltfred_> My searching is failing me... is there a haskell package for `Field`, as in the Field from math?
10:57:26 <ongy> monochrom: I never checked, but I would asume they open up every other month when someone burns out :)
10:57:35 <kadoban> Yeah, programmers make decent money, but you always have to be learning stuff, you can't stand still.
10:57:36 <monochrom> ha
10:57:46 <coltfred_> Part of the hierarcy, Group -> Ring -> Field, etc.
10:58:03 <tsahyt> coltfred_: there are several packages providing algebraic hierarchies
10:58:15 <ongy> especially when ekmett was bored and something new exists
10:58:30 <tsahyt> coltfred_: algebra comes to mind
10:58:32 <tsahyt> @hackage algebra
10:58:32 <lambdabot> http://hackage.haskell.org/package/algebra
10:58:41 <tsahyt> but that might also be slightly overkill
10:58:45 <Rotaerk> kadoban, I feel like there's a lot less to learn in order to suffice than people seems to think
10:58:46 <Philonous> coltfred_, https://hackage.haskell.org/package/numeric-prelude has it
10:58:51 <coltfred_> tsahyt, Thanks!
10:58:57 <monochrom> If you are great at documentation (including all of: reading, writing, using), you should become a lawyer, so much better income than programmer. And yes this is why our docs such.
10:59:03 <monochrom> s/such/suck/
10:59:05 <coltfred_> Philonous, I wasn't sure if I wanted to replace my whole prelude...
10:59:09 <Lokathor> EvanR, less "C in any language!", more "Ptr backed values at any cost!"
10:59:22 <Rotaerk> as in, it only feels like a highly volatile industry because of the bandwagons obsessed with some particular technology
10:59:23 <EvanR> yeesh
10:59:29 <Rotaerk> the technologies tend to just be re-hashes of older tech though
10:59:41 <Rotaerk> the fundamental knowledge doesn't change all that much
10:59:48 <Lokathor> EvanR, that's what gl takes, so that's what I gotta have
11:00:07 <EvanR> right
11:00:13 <ongy> that also depends on management and langauge ecosystem
11:00:18 <EvanR> at the very edge of the program
11:00:25 <ongy> I feel like js is moving pretty fast, and others (C/C++) not so much
11:00:33 <Lokathor> in this case, i'm lucky that JuicyPixels triially converts any picture to a RGBA Vector.Storable
11:00:42 <monochrom> Haskell is not going to give you money because explaining lens to people is the equivalent of doing pro-bono for your whole life.
11:00:58 <Lokathor> trivially*
11:01:06 <average> robust and long-term tech, so ways of making decent money in the long-term. if Haskell can bring that, I'm all in
11:01:25 <monochrom> Haskell cann't bring that. You're all out.
11:01:25 <average> if not, I'm definitely not looking at it as a serious skill. not for me at least. others can think what they may
11:01:53 <average> monochrom: then why bother..
11:01:59 <bennofs> average: why not
11:02:11 <ongy> average: ever learned something because you were interested in it?
11:02:22 <ongy> monochrom: which of robust and long term do you think haskell doesn't fit?
11:02:29 <monochrom> Yes, I do want to ask you why you bother.
11:02:43 <Rotaerk> average, thing is, learning a new programming language is kind of a minor investment; go learn whatever it is that you can get hired for
11:02:45 <monochrom> As for me, I am one of those you call "think what they may".
11:02:56 <average> Rotaerk: I don't need to learn anything right now
11:03:00 <Rotaerk> C#, Java, C++, C, Javascript/web-stuff
11:03:19 <hexagoxel> tsahyt: is it the lens parts that make it useful, or the plated parts? have you tried just using uniplate?
11:03:29 <Rotaerk> but if you want to improve your competence, learning *concepts* is important
11:03:44 <Rotaerk> and using quality tools, which haskell is
11:04:03 <Rotaerk> if you only care about money, and not ... actually being professional and doing a good job
11:04:09 <average> I only care about money
11:04:11 <tsahyt> hexagoxel: both actually. as a part of this AST I have a full first order logic encoding, on which I use Plated a lot for rewrites (e.g. to negation normal form etc), but accessing those FOL bits in the input and changing them is where the standard lensy bits come in
11:04:20 <ertes> average: you seem to be a very economical person from what you say…  but that doesn't quite fit with what you're doing right now…  if you want to see what haskell can buy you, invest one weekend in learning instead of rambling on IRC
11:04:21 <average> I honestly, like..genuinely only care about that
11:04:26 <monochrom> ongy: I was referring to the money part. You know what, it is a tautology that nothing guarantees money. :)
11:04:56 <bennofs> average: yes, and? have your questions not be answered? there are people that don't care only about money
11:04:59 <Lokathor> average, go found a megacorp
11:05:07 <average> ertes: I'd only really do that if there was a pre-planned way of making money at the end of said weekend by using what I learned in that weekend
11:05:18 <average> there's no point for me to ever use that weekend for learning Haskell if there's no money in it
11:05:26 <Rotaerk> there are economical reasons to use haskell, if you have the freedom to choose haskell
11:05:28 <average> does it make money or not
11:05:31 <average> that's the point
11:05:43 <pikajude> not really
11:05:46 <average> for me it is
11:05:51 <pikajude> would avoid it then
11:05:54 <Rotaerk> but if you're gonna make money by being employed by a company, you are gonna have a harder time getting hired for haskell than other languages
11:06:07 <ertes> average: sure: make an application/service you can sell…  you can do that with haskell, and it has been done before (even the most superficial search on your favourite search engine would have revealed that)
11:06:10 <monochrom> average is not economically minded. average is merely your average miser. An economically minded person would offer you cash for answering their question.
11:06:28 <tsahyt> Rotaerk: I'd say *knowing* haskell is making developers more employable. they might just not end up actually writing much haskell
11:06:30 <average> hah monochrom !
11:06:30 <Rotaerk> hur hur, "average miser"
11:06:43 <ongy> and if a weekend sounds like to much time wasted, look at this
11:06:52 <Rotaerk> tsahyt, I'd say I agree, but I don't think HR would consider it all that impressive
11:07:07 <tsahyt> and I'd say actually much more employable. it's not unheard of that companies advertise for haskell programmers and then have them maintain java or something
11:07:09 <Rotaerk> and the average programmer wouldn't either, since a lot of programmers seem to look down on haskellers as being snobs or something
11:07:32 <average> yeah Rotaerk , that's what I've noticed too
11:07:44 <average> and you know what, it's fine with me if you're a snob making tons of money
11:07:50 <average> at least then you have some bragging rights
11:07:58 <hexagoxel> tsahyt: ah, makes sense, i can imagine such use-cases.
11:08:15 <average> so is Haskell a monetizable skill or not?
11:08:33 <grizwako_> well, bragging rights suchs as "others do not have problems because of code I have written" seems fine with me
11:08:39 <bennofs> average: hasn't this been answered many times already?
11:08:41 <monochrom> I say no. As far as I know.
11:08:52 <kadoban> average: Which answer would you like? You seem to keep asking the same thing, are you waiting until you get a specific answer?
11:08:53 <Rotaerk> average, it really depends on your strategy...
11:08:58 <monochrom> But I also have a hunch that you will keep asking that for the next 365 days.
11:09:14 <average> monochrom: you seem to be very stressed by my question. why is that?
11:09:15 <monochrom> As though you're desperate for someone to say yes.
11:09:20 <Rotaerk> if your strategy is to get hired and paid a huge salary, you can do that with haskell, if you're lucky enough to find a job that will hire you
11:09:30 <grizwako_> if you are thinking about working directly with haskell, it is, but you need a lot of time invested
11:09:38 <Rotaerk> but there are better languages for that strategy
11:09:42 <grizwako_> like 1 year+
11:09:58 <ertes> average: you're not getting the point: haskell is just a language – a tool…  it doesn't matter
11:10:00 <monochrom> I don't know. I need to read your mind to find out why things seems whatever to you.
11:10:07 <average> ertes: it matters a lot to me
11:10:16 <Rotaerk> if your strategy is to write some software and sell it, then haskell would be good there, because you're not constrained by what the company accepts
11:10:27 <Rotaerk> and it has technical advantages over other languages
11:11:27 <ertes> average: do you have a business strategy that is calculated to the penny?
11:11:29 <Rotaerk> I'd love to use haskell at work, but that's just not gonna happen, because they dictate the languages we're allowed to use
11:11:29 <tsahyt> that's a good point. if you're free to pick your tech, haskell is a choice that can make money down the line by saving on maintenance costs among other things. at least in my experience, haskell makes maintenance comparatively easy
11:11:54 <tsahyt> and iirc about 3/4 of costs eventually go into maintenance, so that's a good place to optimize the process
11:11:55 <average> if someone were to make a statement like "The Haskell language and all its community and eco-system is generating a lot of poverty in IT professions and specifically among programmers"
11:12:00 <average> how would you counter that statement?
11:12:10 <tsahyt> average: I would say that statement doesn't even make sense
11:12:19 <average> tsahyt: well.. how so?
11:12:21 <monochrom> I would agree with it.
11:12:29 <average> monochrom: surprise! why?
11:12:44 <Rotaerk> monochrom just sounds like a grumpy old guy :P
11:12:54 <grizwako_> heh
11:13:02 <grizwako_> my day job is magento/php...
11:13:22 <pikajude> i'm not sure exactly what generating a lot of poverty means
11:13:24 <ertes> average: i would say that haskell is not a commodity, so the statement is non-sense…  people cause poverty by fixating on technology when their focus should be on a real business strategy
11:13:30 <Tuplanolla> How do you generate poverty? Is it like conducting cold?
11:13:30 <ongy> monochrom is a grumpy old guy :D
11:13:34 <average> grizwako_: and that's a sane decision. that's an e-commerce platform. money revolves around e-commerce platforms so you get paid, and you get paid well i assume.
11:13:44 <grizwako_> haskel / functional style overall, helps me a lot in writing code with less bugs
11:13:45 <monochrom> Automation has always driven up poverty.
11:13:55 <ongy> monochrom++
11:14:04 <grizwako_> not really well, but it pays bills..
11:14:04 <pikajude> oh, i see
11:14:08 <Rotaerk> lol, oh
11:14:17 <EvanR> by all means drive up the poverty then
11:14:24 <pikajude> by reducing the amount of effort needed to write code, presumably
11:14:37 <ertes> average: but honestly i don't think you're the kind of person you're claiming to be, because your attitude and behaviour doesn't line up with "i only care about money"
11:14:39 <ongy> EvanR: I think we first have to fix a few things about economy and capitalism, but that's going OT :)
11:14:49 <grizwako_> thing is, that I have experience with large system, that could be said to be opposite of haskell "mindset"
11:14:54 <monochrom> Not to say that it's automation's own fault. But the manager type do exploit automation to rip off human labour.
11:15:07 <average> ertes: I'm down to have a detalied debate about Haskell and money
11:15:12 <average> *detailed
11:15:27 <EvanR> do it in -offtopic ;)
11:15:36 <grizwako_> you get mutable state all around, things depend on other things, code that you do not control, breaks other code that you do not control
11:15:44 <average> ertes: I'm not a superficial debater, if that's what you were trying to say. and yes, mine was not a simple question
11:16:05 <average> it's a hard question, even the answer may be hard(to formulate and to accept)
11:16:09 <Rotaerk> I don't think that's remotely what he was saying
11:16:20 <average> Rotaerk: I know what he was saying
11:16:21 <ertes> average: now to bring it back on what is actually on topic here, do you have a technical question about haskell?
11:16:25 <grizwako_> being exposed to haskell helps me survive in that mess
11:16:30 <ph88^> how can i find out why this code makes the handle closed?  https://bpaste.net/show/0a8495d13144
11:16:58 <average> ertes: well, I believe the topic I brought up is actually a technical question
11:17:08 <average> that's how I view it
11:17:39 <grizwako_> it is not
11:17:56 <ertes> average: if your question is how haskell can make/save money through its technical features, here is an answer:  code tends to be shorter, safer and better maintainable in haskell compared to most other languages
11:18:32 <ertes> in particular haskell makes refactoring exceptionally easy, so it's very good at adapting to new market conditions
11:19:05 <Rotaerk> average, programming is marketable because it results in software that saves time and money, not to mention makes some things feasible that are otherwise not.  all the details of programming, such as the tools involved, are all focused on optimizing the cost of developing and/or supporting that software
11:19:09 <average> ertes: listen here Monad-boy, you can write oneliners in Bash too, that doesn't make the code more maintainable because it's shorter..
11:19:26 <pikajude> that's true, and also not what ertes said
11:19:34 <Rotaerk> he didn't say it was more maintainable *because* it was shorter
11:19:59 <Rotaerk> although brevity can help, to a point
11:20:05 <pikajude> i don't think you can write haskell in one line though, sadly
11:20:10 <pikajude> anything non-trivial
11:20:15 <grizwako_> python code is of similar size usually, but I would be more confident in changing haskell code than in changing python code
11:20:15 <ertes> average: shorter and more maintainable = more maintainble, because shorter
11:20:18 <ertes> ≠
11:20:19 <monochrom> I am going to crown ertes as Monad Boy Of The Day
11:20:25 <pikajude> unless substituting ; for \n also applies to top level bindings
11:20:26 <ertes> =)
11:20:43 <average> a bunch of monadists..
11:20:45 <tsahyt> pikajude: couldn't you inline everything into main?
11:20:54 <average> much <3
11:21:03 <pikajude> tsahyt: kind of
11:21:04 <ertes> … and that reveals average as the average troll
11:21:05 <ongy> with a bunch of let .... in :)
11:21:07 <grizwako_> about technical stuff, any resources for haskell + vulkan? 
11:21:11 <pikajude> i guess you really could
11:21:12 <average> ertes: not at all actually
11:21:23 <average> ertes: but, I can make a joke from time to time..
11:21:30 <monochrom> Ah don't be too literal about "line"
11:21:32 <EvanR> classic
11:21:36 <Rotaerk> I'm not sure average is actually a person who "only cares about money", so much as someone playing a *role* for the sake of trying to force haskell to defend itself on practical terms or something
11:21:52 <tsahyt> grizwako_: afaik the bindings we have are pretty much 1:1 equivalent to the C bindings, so any of the vulkan C tutorial should work when you squint enough
11:21:57 <ongy> feels like the averade day on 4chan :)
11:22:11 <ongy> I wonder if average knows Protontorpedo
11:22:51 <grizwako_> tsahyt, yeah, I get that, I know basics of functional programming, have rough idea about applicative and monads, did not write any serious amount of code yet
11:22:55 <ertes> average: oh, we have bad jokes in spades: "it's just a monoid in the category of endofunctors, what's the problem?"  took me 7 years to get the joke just to find that it wasn't that funny
11:23:02 <Rotaerk> i.e. "let's say I only care about money, what argument could you provide to convince me to use haskell?"
11:23:31 <grizwako_> and I have almost no xp at all with graphics programming
11:23:33 <Tuplanolla> If you only care about money, I recommend a life of crime.
11:23:34 <average> Rotaerk: but that's not what I said, please to reproduce faithfully when quoting..
11:23:38 <monochrom> Oh, actually I know the answer.
11:23:42 <tsahyt> grizwako_: then I'd rather start with opengl tbh. vulkan is very very low level
11:23:46 <average> monochrom: reveal it then
11:23:46 <Rotaerk> average, that wasn't a quote of you
11:23:50 <average> Rotaerk: but who
11:23:52 <grizwako_> yeah, that is why I want it
11:24:01 <grizwako_> I think vulkan fits really nice with multithreading
11:24:11 <Rotaerk> it was a fictional quote
11:24:25 <grizwako_> but I am not sure if it is too large of a bite :)
11:24:42 <tsahyt> grizwako_: I don't think the FP nature of haskell is going to matter much with vulkan, pretty much anything you do will be in IO and it'd be some very imperative code anyhow. you can of course abstract to something nicer from there
11:24:47 <average> 21:23 ( Tuplanolla) If you only care about money, I recommend a life of crime.
11:24:54 <tsahyt> I mean yeah, general monad patterns still apply of course
11:24:59 <ertes> grizwako_: have you done OpenGL?
11:25:03 <average> Tuplanolla: best answer ever
11:25:07 * average claps
11:25:09 <ertes> grizwako_: if not, i *strongly* suggest doing OpenGL first
11:25:17 <grizwako_> only a very little, I understand basic concepts
11:25:40 <ertes> grizwako_: do you have a specific application in mind?
11:26:16 <grizwako_> bullet hell top down 3d shooter
11:26:33 <ongy> top down 3d?
11:26:38 <grizwako_> yeah
11:26:54 <ertes> grizwako_: can you get a scene with lighting and shading on the screen with OpenGL?
11:27:02 <grizwako_> it is mostly for learning purposes, with my very limited knowledge it seems like good project to start with
11:27:19 <grizwako_> not on my own without looking online
11:27:23 <ertes> grizwako_: i'd also ask for visiblity stuff, but that won't matter too much in a top-down game
11:27:49 <ertes> grizwako_: then do that first…  vulkan will build on your knowledge, and so will most tutorials about vulkan
11:28:19 <grizwako_> ok, thanks
11:28:20 <Tuplanolla> Why is that the case? Isn't Vulkan supposed to deprecate OpenGL?
11:28:41 <grizwako_> well, generally people consider vulkan hard
11:28:59 <EvanR> GL is already pretty hard
11:29:00 <grizwako_> and you need to learn 2 things, graphics and gpu
11:29:00 <ertes> Tuplanolla: yes, but you still need all the knowledge you had with OpenGL
11:29:18 <ertes> consider vulkan to be level 2 in the graphics programming game =)
11:29:30 <grizwako_> with OpenGL you need only graphics, and little GPU for performance
11:29:31 <ertes> beat level 1 first
11:29:51 <ertes> what?
11:29:56 <Tuplanolla> There's a difference between mastering PHP hard and Haskell hard.
11:30:13 <grizwako_> haskell hard is easier than PHP hard imo :)
11:30:18 <Tuplanolla> The former is largely a waste of time.
11:30:49 <ertes> this is also a statement on the current vulkan ecosystem…  pretty much everything will assume that you already know how to do OpenGL
11:31:12 <grizwako_> anyway, about graphics, with opengl you need to learn about how graphics work, how to manage scene, lights
11:31:16 <ertes> in the best cases conceptually, in the worst cases in high technical detail
11:31:24 <ertes> grizwako_: no
11:31:29 <ertes> that's OpenGL < 3.0
11:31:43 <grizwako_> with vulkan, you need to get into how cpu and gpu communicate and how to do it in safe way
11:31:50 <grizwako_> ok :)
11:32:00 <ertes> starting with OpenGL 3, your focus will be on communicating with and programming the GPU
11:32:05 <ertes> most of the work is done in shaders
11:32:25 <grizwako_> sorry for talking bullshit, but if I just throw out my assumption somebody helpfull could set me straight :)
11:33:00 <tsahyt> grizwako_: this strategy is proven to be the most effective one to get an answer on the internet, according to xkcd iirc
11:33:21 <grizwako_> is it worth it to learn OpenGL via haskell, or I should just go with c++?
11:33:48 <ertes> grizwako_: haskell is fine…  use the 'gl' library, which is a direct mapping of the API
11:33:55 <EvanR> if youre going to learn low level C code, i would rather do it with haskell than C++ ;)
11:33:56 <grizwako_> my goal is only to learn, not to make something usable, maintanable
11:34:05 <EvanR> but best would be C
11:34:16 <tsahyt> EvanR: being able to C in Haskell is a surprisingly useful skill sometimes
11:34:19 <ertes> personally i'd suggest haskell anyway
11:34:39 * osfameron is shocked, shocked that #haskell is suggesting using Haskell for something
11:34:41 <ertes> if only for the pleasure of working with storable vectors instead of C arrays =)
11:34:52 <grizwako_> well, since my plan is to use vulkan from haskell later on
11:35:03 <grizwako_> that skill shoud translate from gl lib to vulkan?
11:35:24 <tsahyt> I've actually been meaning to look into vulkan with haskell too, maybe write a tiny toy engine utilizing FRP
11:35:28 <tsahyt> but I never got around to it
11:35:30 <grizwako_> so I will have one less mountain to climb over
11:35:38 <ertes> grizwako_: yeah, pretty much…  the vulkan library is using the same kind of automatic API generator
11:35:59 <ertes> grizwako_: in fact i think it's literally the same one, rewritten to work on the vulkan spec
11:37:35 <grizwako_> ertes, thanks for advice (others too!)
11:45:25 <Cale> ertes: Yeah, the "monoid in a category of endofunctors" thing... isn't necessarily even a joke.
11:46:06 <ertes> the "what's the problem?" part is the joke
11:46:29 <Cale> Yeah, or the fact that if you knew what it meant, you probably wouldn't need an explanation of what a monad is.
11:46:32 <EvanR> what other theorem statements can we make into a joke
11:47:47 <Cale> A category is just a monad in the 2-category of spans of sets.
11:48:36 <ertes> categories are monoids on steroids
11:48:49 <Cale> You could probably just pick a random page on ncatlab and find such a ridiculous characterization
11:53:13 <Tuplanolla> Can I formulate any theorem in the form "x in the category of y"?
11:53:40 <ertes> that's…  just an expression
11:56:33 <Taneb> Tuplanolla, a surprising amount of algebra definitions are like "A Lie Group is a group object in the category of differentiable manifold"
12:03:21 <Gurkenglas> Ah, replacing about 40 lines with "iterationGroup is = partsOf (traversed . indices (`elem` is)) %= reducePotentials" x)
12:04:12 <average> how is that intuitive tho
12:04:19 <average> if I looked at that I'd have no idea what it did
12:04:32 <Gurkenglas> Yea, I added a comment. That's worth the line savings.
12:04:32 <bennofs1> makes sense to me
12:05:23 <ertes> Gurkenglas: the "x)" part is a smiley, isn't it?
12:05:27 <Taneb> The brackets don't match
12:05:27 <ertes> ah, yes, it is =)
12:05:35 <Taneb> Ah, same confusion as ertes 
12:05:57 <average> Gurkenglas: so you swapped code for comments
12:05:59 <ongy> what's %=? something like map?
12:06:07 <ertes> ongy: over
12:06:09 <ertes> :t over
12:06:11 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
12:06:15 <ertes> but for StateT
12:06:16 <Taneb> ongy, very loosely, yeah
12:06:18 <average> Gurkenglas: that must be an improvement for some definition of it..
12:06:32 <average> I guess I now see why everyone loves Haskell
12:06:38 <bennofs1> average: if you're familar with lens, that code is pretty readable
12:06:42 <average> you write more english and less code?
12:06:52 <ongy> I'm not really familiar with lense and I still see why it's pretty :)
12:07:19 <ertes> ongy: there is a state variant for pretty much every lens operator
12:07:30 <ertes> like (%=) for (%~), (.=) for (.~), etc.
12:07:41 <ertes> so in StateT you would write:  blah . blubb %= f
12:07:52 <ertes> or even (like in C):  blah . blubb += 5
12:08:11 <ongy> yea, makes sense. I have a basic grasp of lens, just not indepth
12:10:27 <Gurkenglas> Though if I'm going to keep reusing the same is's, is there a way to build the traversal only once so it doesn't have to keep looking up using elem?
12:10:34 <ph88^> how can i find out why this code makes the handle closed?  https://bpaste.net/show/0a8495d13144
12:11:08 <ertes> Gurkenglas: not sure if it applies to your use case, but you can use 'zoom' with traversals
12:12:06 <ertes> > execState (zoom traverse $ do _1 += 5; _2 += 7) [(10,10), (20,20), (30,30)]
12:12:07 <Gurkenglas> Nah, doesn't, it's 27 alternately used values of is. (Guess the use case!)
12:12:08 <lambdabot>  [(15,17),(25,27),(35,37)]
12:13:03 <bennofs1> Gurkenglas: you can probably build an efficient traversal by hand, but I don't think you will be able to reuse many combinators. Does the order of the elements matter, or can you sort is?
12:14:49 <Gurkenglas> That's still going to carry around the indices when the traversal is applied, I'm hoping for something that precomputes the traversal without the function to apply over it
12:19:12 <bennofs1> Gurkenglas: not sure how to precompute it. at the end, you still have to store the info of what indicies you take out of the list somewhere
12:20:58 <Lokathor> does a "#ccall" in a bindings make a normal foreign call?
12:21:09 <Lokathor> that is, is the default to make uninterruptable or interruptable?
12:27:07 <Rotaerk> c_wraith, you said machines is experimental still; is it sufficiently mature for pet projects, if not for production systems in a business?
12:27:59 <ertes> Rotaerk: the 'machines' library?
12:28:02 <Rotaerk> yea
12:28:12 <ertes> Rotaerk: i'm using it heavily…  it has pretty much replaced pipes for me
12:28:42 <Rotaerk> ah; I was actually thinking of doing the same, because pipes is kind of limiting for branching inputs/outputs
12:29:01 <geekosaur> ph88^, which sourceFile is that using?
12:29:07 <Rotaerk> can kinda get by, but it's a bit ugly
12:29:08 * hackage here 1.2.10 - Here docs & interpolated strings via quasiquotation  https://hackage.haskell.org/package/here-1.2.10 (TaylorHedberg)
12:29:42 <Philonous> If it replaces pipes it presumably also replaces conduits?
12:30:00 <Philonous> Is there a comparison of machines/pipes/conduits?
12:30:51 <uniclown> newtype All = All { getAll :: Bool }
12:30:57 <Rotaerk> ertes, thanks; I'll try it, now that I know it's viable
12:30:58 <uniclown> why is this a common idiom in haskell
12:31:00 <c_wraith> Rotaerk: and yeah, it's fine for pet projects.
12:31:32 <c_wraith> uniclown: because it's a one-liner that declares the getter and the data type together
12:32:35 <geekosaur> uniclown, because it gives you both a type and a 'runner'/accessor for it
12:33:01 <geekosaur> usually it's used to make a runnable monad or an alternative monoid instance (in this case it's the latter)
12:33:15 <c_wraith> uniclown: that said, no one should care if you don't use it.  You just need to be able to understand what's going on if you encounter it
12:33:38 <tsahyt> geekosaur: is it an alternative monoid instance when the underlying type doesn't have one?
12:33:54 <geekosaur> when there's multiple possible instances and none stands out as the default, yes
12:33:56 <c_wraith> tsahyt: in the case of All, yes
12:33:57 <uniclown> so what's the alternative to that idiom? Is it just an algebraic variant with one constructor?
12:34:06 <geekosaur> it just means possibly several alternatives, but no default
12:34:19 <tsahyt> uniclown: newtype All = All Bool, and then some function getAll :: All -> Bool, with getAll (All x) = x
12:34:20 <c_wraith> tsahyt: but there are also things like Reverse which is a monoid that reverses application order of an underlying monoid
12:34:34 <tsahyt> uniclown: using record syntax just reduces boilerplate code
12:34:35 <geekosaur> likewise we have Sum and Product newtypes with their own Monoid instances, but no default
12:34:37 <uniclown> ok makes sense. Thank you
12:39:00 <ph88^> geekosaur, "sj300e_bin.dat"
12:40:06 <geekosaur> ... I am not sure how you got that answer from my question
12:40:45 <geekosaur> but it looks like both conduit-extras and conduit-combinators close the file automatically
12:40:59 <ph88^> geekosaur, import qualified Data.Conduit.Binary as CB
12:41:21 <ph88^> eh that's not good .. how can i work with ReusableSource this way ?
12:41:30 <ph88^> ResumableSource *
12:48:55 <ertes> Rotaerk: the reason i use it is not because of branching, but because of the separation between PlanT and MachineT
12:49:46 <ertes> Rotaerk: i can use efficient CPS for the individual stream processors and only expand to an algebraic encoding for connecting the plans
12:50:09 <ertes> pipes relies heavily on rewrite rules to make that efficient
12:53:15 <Rotaerk> ah
12:54:27 <Rotaerk> my use case is something like... having a producer of E where data E = A X | B Y | Z C
12:54:46 <average> what if you used Bash and GNU parallel for that? :)
12:54:47 <Rotaerk> and then pumping the contained values through Pipe X o, Pipe Y o, and Pipe Z o
12:55:04 <average> and the regular pipes you have in Bash :)
12:55:10 <Rotaerk> average, you wouldn't understand
12:55:24 <average> Rotaerk: I think I meant _would_
12:55:29 <average> *you meant _would_
12:55:42 <Rotaerk> nope
12:56:05 <average> Rotaerk: what are you building?
12:56:39 <Rotaerk> ertes, so something like: ePipe :: Pipe X o m r -> Pipe Y o m r -> Pipe Z o m r -> Pipe E o m r
12:56:50 <Rotaerk> I can get by with doing that in pipes, but it's kind of ugly
12:58:37 <Rotaerk> ended up doing it by making a:  branch :: Monad m => (i -> Maybe i') -> Pipe i' o m r -> Pipe i o m r -> Pipe i o m r
12:59:38 <Rotaerk> average, by the way, working in bash is painful
13:01:00 <average> Rotaerk: why? I use Bash for a lot of things. How is it painful?
13:01:23 <average> Rotaerk: the syntax is not worse than Haskell's ..
13:01:28 <average> both are Turing-complete..
13:01:55 <average> Bash has no types.. less headaches..
13:02:05 <Rotaerk> bash doesn't have a type system; that's a pain-poinnt
13:02:19 <average> it's actually not a pain-point at all..
13:02:35 <Rotaerk> well, actually, we should take this to -blah or -offtopic
13:05:25 <ertes> Rotaerk: maybe i haven't hit the use case yet, but i don't really see a lot of value in branching…  perhaps because whenever branching comes up, i tend to gravitate towards real concurrency =)
13:06:24 <Rotaerk> ertes, simple example:  I have a TCP connection object which produces TCP.Event values, which include:  Received ByteString | Closed | Disconnected
13:07:06 <Rotaerk> there are already plenty of Pipe ByteString o m r things, but you can't trivially use them in a Pipe Event o m r
13:07:34 <Rotaerk> need a way to pump a subset of the inputs through that one pipe, and the other inputs through a different one
13:07:55 <ertes> Rotaerk: yeah, to me it would be a producer that just stops
13:08:25 <ertes> Producer ByteString m 2  -- something along those lines
13:08:30 <ertes> where 2 is any binary type
13:09:06 <Rotaerk> maybe a better example is:  data IRC.Event = Received IrcMsg | InvalidMessage Text | Closed | Disconnected
13:09:31 <Rotaerk> and if I have a Pipe IrcMsg that I want to use, but only for the Received events...
13:09:57 <Rotaerk> (better example because "just ending" only eliminates the need for Closed and Disconnected)
13:10:35 <ph88^> anyone know how to use ResourceT ?
13:12:32 <ertes> Rotaerk: yeah, something like that tends to be the final producer for me…  and i tend to just feed it into an MVar or TQueue
13:12:47 <Rotaerk> ah
13:12:49 <ertes> i've never really needed branching as part of the stream pipeline
13:13:03 <Lokathor> it seems cruel that Vector.Storable has the very nice generateM and Vector.Storable.Mutable does not :(
13:13:28 <Rotaerk> maybe I *should* eliminate the Closed/Disconnect though...
13:18:02 <EvanR> something doesnt appeal to me about a Closed / Disconnect event in a pipe
13:18:22 <EvanR> because you dont expect to get anything after that point, its logically different than "the next event"
13:18:35 <Rotaerk> yea that's why I'm reconsidering, in this case
13:18:37 <ertes> Rotaerk: BTW, another useful abstraction for that kind of thing is FRP
13:18:38 <EvanR> if you treat it wrong, youll get stuck
13:18:56 <Rotaerk> although a Disconnect event IS useful for an "IRC session" object I'm gonna build
13:19:05 <Rotaerk> where disconnection just means it'll try to auto-reconnect
13:19:19 <EvanR> well the session is logically over at that point
13:19:23 <EvanR> and you need a new one
13:19:34 <ertes> the connection is over
13:19:37 <Rotaerk> no, the "Session" object abstracts the connection, and persists across disconnects
13:19:43 <EvanR> oh
13:19:44 <ertes> a "session" can be really anything
13:19:45 <Rotaerk> maybe a better word than session is warranted
13:19:59 <ertes> "session" is fine
13:20:25 <ertes> Rotaerk: but i would reconsider if there needs to be a "session object"
13:20:41 <EvanR> still, i imagine an on going connection to be a thread, and when its over, the thread dies (and you know it because youre waiting on it somewhere)
13:20:44 <Rotaerk> I think it would be valuable to have here
13:20:48 <ertes> as i said: FRP is almost a perfect fit for IRC
13:21:05 <Rotaerk> I was planning on using FRP for the GUI aspect
13:21:15 <EvanR> or if it crashes. you will get a result, and you definitely wont be getting anything more from it
13:21:23 <ertes> i'd use it for IRC itself
13:21:37 <ertes> GUIs are a surprisingly boring use case for IRC
13:21:46 <Rotaerk> for FRP * ?
13:21:51 <ertes> *for FRP
13:22:16 <EvanR> i would use async 
13:22:23 <EvanR> hardcore
13:22:32 <EvanR> more flexible
13:22:34 <Rotaerk> what I'm currently building is strictly a daemon... it will ultimately manage the state of the IRC connection and communication with the IRC server, and then it will send user-events and receive user-commands via inter-process communication of some sort
13:22:51 <Rotaerk> you still recommend FRP in that case?
13:22:56 <Rotaerk> seems really pipe-y to me
13:23:15 <EvanR> it seems asynchronous to me ;)
13:23:16 <Rotaerk> (I haven't got a remotely intuitive understanding of FRP yet, so I can't really judge that)
13:23:31 <EvanR> because the demon is both managing inputs from the server and from the user
13:23:33 <Rotaerk> well I've definitely got some asyncs going on; that's why I'm building "objects"
13:23:43 <ertes> Rotaerk: of course…  FRP has nothing to do with graphics or UIs…  it's an abstraction to model interactions
13:24:05 <Rotaerk> when I say object, I mean an agent running asyncronously, with which you can communicate only through message passing
13:24:10 <Rotaerk> (via mailboxes and pipes)
13:24:16 <EvanR> a thread!
13:24:30 <ertes> UIs are just an obvious (and boring) use case, much like servers are an obvious and boring use case for concurrency
13:24:31 <EvanR> agent is so vague :(
13:24:42 <Rotaerk> objects tend to be in their own "thread", but there's more to them than *just* a thread
13:25:04 <Rotaerk> i.e. the message-passing part
13:25:13 <EvanR> anything beyond the IO action the thread is, and whatever you gave it for communication, seems like overengineering
13:25:21 <ertes> Rotaerk: if your interactions are really basic, then FRP probably won't buy you much
13:25:41 <ertes> but if you start filtering and switching, you will quickly benefit from it
13:25:49 <Rotaerk> hmm I'm open to using FRP, but as of now, I don't have the faintest idea how it would help exactly
13:26:03 <Rotaerk> I mean, different from how pipes
13:26:24 <EvanR> this problem has nothing to do with FRP
13:26:24 <Rotaerk> since this is really just a stream of incoming data and a stream of outgoing data, with logic in the middle to decide what goes in/out
13:26:44 <EvanR> like you said, "concurrency for servers"
13:26:48 <EvanR> which this is
13:27:37 <EvanR> Rotaerk: isnt it 2 streams going in opposite directions?
13:27:45 <EvanR> 2 inputs, 2 outputs
13:28:43 <Rotaerk> EvanR, yea, IRC network -> internal processes, and internal processes -> IRC network
13:28:47 <EvanR> (which pipes seems to support in one data type)
13:29:00 <Rotaerk> though really there will be many networks and many processes simultaneously
13:29:19 <EvanR> it sounds super async
13:29:34 <Rotaerk> I'm not using bidirectional pipes, because with IRC, the in and out streams are pretty independent
13:29:43 <Rotaerk> so I'm using two unidirectional pipelines
13:30:06 <Rotaerk> the bidirectional pipes are more for like... requesting something from upstream and getting it back
13:30:16 <Rotaerk> but there's nothing like that with IRC
13:30:44 <EvanR> yes, getting nothing at all back is normal
13:35:08 <Rotaerk> anyway, ertes, thanks for the suggestion; I'll ponder how FRP would help
13:35:15 <Rotaerk> hadn't considered using it for the internals
13:36:33 <EvanR> this falls more into dataflow programming
13:36:44 <EvanR> rather than continuous time behaviors
13:37:12 <EvanR> but because of the many async processes going on that need monitoring... i wouldnt want either
13:37:36 <Rotaerk> EvanR, I am using both async and pipes for this
13:37:48 <Rotaerk> communication between the async tasks is done via mailboxes... pipes-concurrency
13:38:19 <EvanR> how does that handle threads finishing and crashing
13:39:16 <Rotaerk> e.g. my TCP connection object is represented as: { connectionTask :: Async (), fromConnection :: Producer Event (), toConnection :: Consumer Command m () }
13:39:32 <Rotaerk> though per the above suggestion, I may change that to something like...
13:40:18 <Rotaerk> { connectionTask :: Async (), fromConnection :: Producer ByteString m EndEvent, toConnection :: Consumer Command m () }
13:40:30 <Rotaerk> where EndEvent distinguishes between closing and disconnecting
13:40:55 <EvanR> ah
13:40:57 <crave> How do I express that the return type of a function is uniquely identified by its inputs?
13:41:16 <EvanR> by its input types?
13:41:27 <Rotaerk> crave, can you be more specific?
13:41:30 <EvanR> you could use an injective type family
13:41:46 <EvanR> or a type class with functional dependency
13:41:53 <crave> functional dependency! thanks
13:42:26 <EvanR> the injective type family seems more targeted
13:43:05 <EvanR> but type classes let you add more cases later
13:49:04 <ertes> Rotaerk: FRP helps with event handling…  it's very useful to have events as first class objects
13:50:10 <EvanR> if you just want to filter events, then you could use E a = a -> Bool, which compose as contrafunctors
13:51:02 <EvanR> to select events according to composable conditions
13:58:20 <jle`> jjjk
13:58:32 <EvanR> :q!
13:58:33 <jle`> huh i wonder why this keeps happening
13:58:40 <EvanR> is your IRC inside of vim? ;)
13:59:32 <jle`> i'm in vim and i try to move and i find out my ssh tunnel has died, so i force kill it with <CR>~. and log back in.  and then it sends them after
13:59:52 <jle`> my ssh opens right into weechat so maybe it queues up the commands i couldn't send before?
14:00:08 * hackage turtle 1.3.4 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.3.4 (GabrielGonzalez)
14:00:22 <cocreature> jle`: the solution is to use mosh to avoid dying ssh tunnels :)
14:01:49 <jle`> hmm thanks, this looks promising :)
14:03:45 <srk> or screen :)
14:04:45 <jle`> i use tmux on my server
14:04:55 <jle`> i just lose the connection from my computer, heh
14:05:06 <cocreature> I use mosh and tmux and it works great :)
14:05:42 <jle`> when i logon to my server, it automatically hooks onto a running tmux session and it just happens to open into the window with my irc client
14:05:50 <jle`> probably not the best thing to open into though
14:05:51 <srk> jle`: there's also KeepAlive for ssh
14:06:00 <srk> option
14:06:57 <geekosaur> KeepAlive is kinda useless actually, {Server,Client}Alive{Interval,Count} more useful
14:07:09 <Sh4rPEYE> Is there any good article (or a nice way you can describe it here) about replicateM? It seems to be widely used in various context and it is pure magic to me every time I see it. Last example: I use kmers n xs = [ x : y | x <- xs, y <- kmers (n - 1) xs ], while they simply write kmers' = replicateM
14:07:10 <geekosaur> (TCP keepalives tend to not fire often)
14:08:58 <cocreature> Sh4rPEYE: I recommend to just take a look at the source of replicateM and figure out what the Applicative operations mean for various instances
14:16:43 <Cale> Sh4rPEYE: I can explain it if you like. I would guess that you're relatively unfamiliar with Monad?
14:17:27 <Sh4rPEYE> Cale: I understand the basics, did few exercises... But yes, relatively unfamiliar
14:17:43 <Cale> Sh4rPEYE: The Monad instance for lists basically behaves a lot like list comprehensions -- "running" a list means picking an element from it, in all possible ways:
14:17:57 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
14:17:59 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
14:18:27 <Cale> So in this example, x is bound to each of [1,2,3] in turn, and so on
14:18:28 <Lokathor> Segmentation fault/access violation in generated code
14:18:29 <Lokathor> ouch
14:18:52 <Cale> Sh4rPEYE: Let's have a look at sequence, and I'll explain replicateM in terms of that
14:19:05 <Cale> sequence :: (Monad m) => [m a] -> m [a]
14:19:14 <Sh4rPEYE> Sequence somehow flips the structure, right?
14:19:18 <Cale> It's a function which takes a list of actions in some monad
14:19:27 <Cale> and combines them into a single action which will run each in turn
14:19:31 <Cale> and collect a list of the results
14:19:49 <Cale> For the list monad, this will take a list of lists, and pick an element from each one, in all possible ways
14:20:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
14:20:05 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
14:20:33 <Cale> It's written as follows:
14:20:38 <Cale> sequence [] = return []
14:20:55 <Cale> In the case that we have an empty list of actions, we produce the action which does nothing except to give an empty list as its result
14:21:06 <Cale> sequence (x:xs) = do ...
14:21:18 <Cale> In the case that we have a nonempty list of actions, whose first element is x
14:21:22 <Cale> sequence (x:xs) = do v <- x; ...
14:21:28 <Cale> we first run x, getting some result v
14:21:35 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
14:21:46 <Cale> we then run the rest of the actions in the list, getting some list of results vs
14:21:54 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:22:18 <Cale> and we produce a complete list (v:vs) as the result of our action
14:22:39 <Cale> So, in terms of this, we can write many other useful things
14:23:08 <Cale> If we can decide what each iteration of a loop should be up-front, and construct a list of the actions, sequence will stitch them together for us
14:23:23 <Cale> mapM f xs = sequence (map f xs)
14:23:43 <Cale> behaves like a sort of for-each loop, with the function taking the place of the "loop body"
14:23:58 <Cale> replicateM n x = sequence (replicate n x)
14:24:12 <Cale> takes an action, makes a list of n copies of it, and then sequences them together
14:24:31 <Cale> For the list monad, that will have the effect of picking an element of a list, n times
14:24:43 <Cale> > replicateM 3 [0,1]
14:24:45 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
14:25:56 <Cale> Sh4rPEYE: make sense?
14:26:18 <Cale> (Feel free to ask questions, this was kind of a deep dive without getting into the details of how the Monad abstraction works)
14:26:20 <tobiasBora> Hello,
14:28:35 <Sh4rPEYE> Cale: Yes it does make perfect sense. Now I also understand why it is different for each monad... Thanks, it helped a lot! :-)
14:28:59 <tobiasBora> Just a question, I cannot find how to find several occurences of a regex in regex-tdfa. I tried to look at the options in https://hackage.haskell.org/package/regex-tdfa-1.2.2/docs/Text-Regex-TDFA-Common.html, but I can't find how to do that
14:29:22 <Cale> Sh4rPEYE: No problem!
14:30:32 <Cale> tobiasBora: See AllSubmatches etc. in regex-base
14:31:14 <Cale> https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:RegexContext
14:31:44 <Cale> This regex library is needlessly confusing...
14:31:57 <geekosaur> tobiasBora, the standard regex harness is kinda yuck. iirc it uses return type polymorphism, if you request a list result then it does multiple match
14:32:07 <geekosaur> ...just a bit late
14:32:13 <Cale> But the idea is that you just attempt to get a result of type AllTextSubmatches, etc. and depending on what you pick, you get different things.
14:32:31 <geekosaur> anyway yeah, this is more or less designed to make you reconsider using regexes >.>
14:33:16 <geekosaur> that, or it's being 'clever' in the bad sense
14:33:36 <Cale> It's trying to out-perl perl
14:34:10 <tobiasBora> Cale: geekosaur : it's compatible with tdfa ? Because I need utf8 support
14:34:32 <Cale> tobiasBora: Yeah, that regex-tdfa thing is built on top of it
14:34:52 <geekosaur> regex-tdfa, regex-posix, etc. are all built on top of the standard regex framework, yes
14:37:01 <geekosaur> ...sometmes it's easier to use pcre-light and make sure your system pcre lib is built with utf8 support (beware debian and opensuse, and I have no idea how it works out on windows)
14:38:00 <tobiasBora> geekosaur: Cale : great thank you
14:41:50 <tobiasBora> Hum wait
14:41:52 <tobiasBora> I tried:
14:41:54 <tobiasBora> let Right reg = REG.compile (COM.CompOption False False True True False) (COM.ExecOption True) "[a-zA-Z0-9][-a-zA-Z0-9!.#%&é*+/=?^_`{|}~]*@[-.a-zA-Z0-9]*\\.[-a-zA-Z0-9.]*[a-zA-Z]"
14:41:59 <tobiasBora> matchAllText reg "hello coucou@gmail and rig@tedy.com :D"
14:42:17 <tobiasBora> and in the result I've just one email:
14:42:19 <tobiasBora> [array (0,0) [(0,("rig@tedy.com",(23,12)))]]
14:46:02 <geekosaur> yes?
14:46:09 <geekosaur> that's not a library problem
14:46:16 <geekosaur> it's an example of why you shouldn't try to do that with regex
14:46:34 <geekosaur> (your chosen regex demands a . on the right of the @ so the coucou@gmail will not match)
14:46:57 <erisco> pretty sure I have an email regexp around somewhere... just a minute
14:47:31 <erisco> here you go https://gist.github.com/erisco/29082201244b053285cfd48814f3859c
14:48:23 <erisco> the argument from here is that you can't expect all addresses to be compliant with RFC822, but that isn't my problem :P
14:48:44 <geekosaur> that looks needlessly obtuse (no ranges). also ... you want rfc2822 and amendments for e.g. locale specific parts
14:48:54 <geekosaur> the resulting regex is larger than the rest of your program.
14:49:43 <Eduard_Munteanu> Arguably, ranges are locale-dependent.
14:49:45 <erisco> ranges are a trivial reduction... it was just easy to list all the characters
14:50:03 <geekosaur> well, if parsing email, you want to force the locale to C anyway
14:50:18 <geekosaur> at least in the headers, you don;t even get iso8859
14:50:43 <erisco> I just wanted to demonstrate that email addresses are in fact regular as per spec
14:50:58 <erisco> which was one point I had to make clear in face of all the misconceptions
14:51:16 <geekosaur> (because headers were specced with a restricted charset that worked with ebcdic, sixbit, etc. on mainframes)
14:52:32 <erisco> parsing them out of a header is different than just showing they're regular
14:52:44 <tobiasBora> geekosaur: good point, I forgot the .com, thanks !
14:53:06 <erisco> well, no, it is just wrong to require a dot after the at
14:53:30 <tobiasBora> geekosaur: I'm not sure to understand why the header are interesting here. And how can you set up the headers?
14:53:54 <erisco> you can also take my solution to demonstrate that it is silly to try and parse emails with regular expressions
14:53:56 <erisco> I mean, look at it
14:54:17 <geekosaur> tobiasBora, mostly that was in response to the stuff about rfc822 which specifies the format of addresses in email headers, not generally
14:54:51 <geekosaur> ...but if the address is to be actually usable, it will end up in a header and be forced to comply with the spec
14:54:59 <geekosaur> s/actually usable/actually used/
14:57:08 <ski> shapr : jag har inte använt 0mq (jag fick slå upp vad det var)
14:57:38 <geekosaur> of course then you run into real world complications like many mail systems outright reject the extension to encode characters outside the RFC2822 valid charset because spammers use it to obscure hostnames on block lists, etc.
15:00:21 <geekosaur> also this is reminding me how much I don't miss running mail servers >.>
15:13:50 <Philonous> Why Swedish though
15:17:55 <Winterfearrr> trying to get this script https://expirebox.com/download/15223f19c6d73638b738fb6cbd75ce53.html to work with this https://expirebox.com/download/69007df36b86a4493cc9ca9ac1cfb1d0.html sorry this is the right one'
15:21:46 <lyxia> Winterfearrr: http://lpaste.net/
15:23:35 <Winterfearrr> lpaste is too complicated
15:25:31 <lyxia> how do you get on IRC if lpaste is too complicated
15:25:54 <hpc> my typewriter has irc built in
15:37:38 * monochrom considers pressing the button for "report this file to delete it". Now there is something not complicated. :)
15:39:41 <EvanR> is there a word for choose randomly from a list, but its always the same choice for a given list
15:40:45 <ertes> EvanR: collapse of the wave function?
15:42:00 <ertes> EvanR: i'd communicate it through the name and the type
15:42:38 <monochrom> Is it really random, or do you just mean an implementation-dependent choice?
15:42:40 <ertes> indexRandom :: (Hashable a) => [a] -> a
15:43:30 <monochrom> Because programmers generally over-abuse the word "random" for all sorts of non-random nondeterminism and implementation-defined behaviour and undefined behaviour.
15:43:58 <monochrom> (Hint: It is not random unless and until you write down the probability distribution.)
15:44:07 <EvanR> in a repeatable experiment, if you give me list xs, you always get the same result. 
15:44:28 <monochrom> See, that's implementation-defined behaviour.
15:44:32 <ertes> monochrom: the english word "random" highly overloaded
15:44:34 <EvanR> perhaps i just do head
15:44:34 <ski> EvanR : i'd say "arbitrary", except that's taken :/
15:44:48 <ertes> is
15:45:08 <EvanR> yeah, random is probably a bad word here
15:45:17 <EvanR> deterministic choice?
15:45:29 <ski> perhaps "unspecified" ?
15:45:42 <monochrom> And Haskell is great at exposing the conflation and challenging your conventional wisdom. If you have neither IO nor RandomGen, it is not random.
15:45:58 <EvanR> what if i do use a random gen
15:45:59 <ski> (me hasn't seen an answer to "do you just mean an implementation-dependent choice?" yet)
15:46:22 <ski> EvanR : what if you seed the pseudo-random gen only from the list itself ?
15:46:50 <EvanR> sure, that satisfies the "determinism" doesnt it
15:47:30 <monochrom> I am like Delphi. I make the right-on point or ask the right-on question. And nobody sees it.
15:47:43 <EvanR> i would say its obviously implementation dependent, but then that sounds bad
15:47:54 <monochrom> No, it sounds good.
15:48:16 <EvanR> since i didnt gave much more useful info about what it will choose
15:48:19 <ski> (it might be good to specify whether a user can expect to get the same choice of element for any particular list, regardless of platform the code is compiled ior running on, and regardless of internal changes to implementation that do not change specified behaviour)
15:48:40 <EvanR> yes it shouldnt depend on the computer
15:49:23 <EvanR> what is the problem with "arbitrary"
15:50:10 <ski> e.g. if they store a result that depends on this choice in a file, and later loads that into a program using the same library, but possibly a later version, or compiled ior run on another machine/platform, can they expect consistency ?
15:50:17 <ski> @type arbitrary
15:50:19 <lambdabot> Arbitrary a => Gen a
15:50:22 <ertes> :t indexRandom
15:50:24 <lambdabot> Hashable a => [a] -> a
15:50:32 <ertes> > indexRandom "Hello world"
15:50:34 <lambdabot>  'H'
15:50:38 <ertes> > indexRandom "Hello world!"
15:50:40 <lambdabot>  'w'
15:50:43 <EvanR> hahahaa
15:50:45 <ski> if you don't mind using the same term as QuickCheck, then if you want to, go ahead
15:50:47 <EvanR> nice
15:51:11 <EvanR> ertes: so what do you call that behavior? random?
15:51:24 <EvanR> arbitrary?
15:51:37 <ertes> EvanR: that one i'd call random, yes…  it's using a PRNG under the hood
15:51:47 <EvanR> how?
15:51:53 <ertes> @undef
15:51:54 <lambdabot> Undefined.
15:52:02 <ertes> @import Data.Hashable (Hashable, hash)
15:52:03 <lambdabot> Unknown command, try @list
15:52:05 <ertes> @let import Data.Hashable (Hashable, hash)
15:52:07 <lambdabot>  Defined.
15:52:10 <ski> it presumably doesn't use an externally specified PRNG or seed thereof
15:52:15 <ertes> @let indexRandom xs = let (h, l) = foldl' (\(h, l) x -> (h + hash x, l + 1)) (0, 0) xs; (i, _) = randomR (0, l - 1) (snd (next (mkStdGen h))) in xs !! i
15:52:16 <lambdabot>  Defined.
15:52:26 <ertes> EvanR: ^
15:52:27 <EvanR> by seeding an RNG and using it once, i cant see that working out
15:52:43 <EvanR> the hash itself should be good enough
15:52:56 <ertes> (the reason i'm using 'next' is that StdGen is terrible)
15:53:14 <EvanR> make sure you use "next" a random number of times?
15:53:17 <ertes> EvanR: i still need a uniformly distributed index =)
15:53:31 <ski> ok, `mkStdGen', no external randomness
15:53:31 <EvanR> yeah not sure im on board with this implementation
15:53:47 <ski> @type next
15:53:48 <lambdabot> RandomGen g => g -> (Int, g)
15:54:06 <ertes> just seed a PRNG from the list contents…  that's what i'm using Hashable for
15:54:09 <EvanR> seeding something and using it once cant be right
15:54:20 <ertes> actually i'm stupid…  i could have just hashed the list =)
15:54:25 <geekosaur> it's just a weird hash function
15:54:35 <ertes> EvanR: that's what a hash function is
15:54:48 <EvanR> thats different from a RNG
15:54:53 <geekosaur> not really
15:55:22 <geekosaur> well. suppose it depends on what level you;re thinking at. I'd actually claim we're abusing a PRNG as a hash function (hence "weird")
15:55:31 <EvanR> RNGs dont usually guarantee you that the first output given all possible seeds follows the same distribution as the iterated output with one seed
15:55:49 <ertes> EvanR: it's still called random: https://en.wikipedia.org/wiki/Pseudorandom_function_family
15:56:26 <EvanR> i recall stdgen giving False as the first output for... a lot of seeds
15:56:40 <ertes> yes, that's why i used 'next'
15:56:47 <EvanR> taking the second output seems like.... what
15:56:51 <ertes> StdGen is the worst
15:56:52 <EvanR> how are you helping
15:57:19 <EvanR> "clearly the second output is random"
15:57:25 <monochrom> I have recently switched to tf-random. You may like to try it.
15:57:46 <ertes> EvanR: no, but it doesn't have the obvious bias that the first output has
15:58:08 <EvanR> heh.
15:58:17 <EvanR> no obvious bias, obviously no bias
15:58:43 <ertes> > map (fst . random . mkStdGen) [0..] :: [Bool]
15:58:45 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
15:58:48 <EvanR> i guess ill give up on words, but i am still interested in precise descriptions of different "random" behaviors
15:58:56 <ertes> > map (fst . random . snd . next . mkStdGen) [0..] :: [Bool]
15:58:58 <lambdabot>  [True,False,True,True,False,True,False,False,True,False,True,True,False,True...
15:59:04 <ertes> EvanR: ^
15:59:08 <EvanR> so random
15:59:12 <ertes> first output vs. second output =)
15:59:27 * ski idly wonders how to render "obviously" as a modal operator
15:59:41 <monochrom> Use a circle.
16:00:06 <monochrom> You already have square and diamond. So just add a circle. It looks like the letter O. :)
16:01:42 <EvanR> so if repeatedly choose from a list of ties what action to take next, i would not normally expect to be able to repeat the process and get the same result without special case
16:01:44 <monochrom> ◇◯p  "p may be obvious" :)
16:01:45 <EvanR> special care
16:01:55 <EvanR> so im wondering what the special care would be
16:02:50 <EvanR> like priority tie, time tie
16:04:16 <EvanR> or maybe purely functional programming has this built in
16:04:18 <ski> monochrom : but what is its dual, and what is its properties ?
16:04:20 <EvanR> just use head
16:06:49 <ski> (hm, and i thought that a circle had been used for something else. apparently "next" in temporal logic, as i suspected)
16:07:33 <ski> EvanR : "list of ties" ?
16:07:58 <EvanR> list, i am ghc with a list of runnable threads
16:08:03 <EvanR> and i only have one cpu
16:08:14 <EvanR> er
16:08:15 <EvanR> like*
16:09:20 <EvanR> and which one i choose may result in one of the others becoming unrunnable so i cant just run them all 
16:16:18 <Lokathor> using trace for warning messages in pure functions
16:16:20 <Lokathor> delicious
16:16:49 <EvanR> arent you mostly using IO ?
16:17:07 <Lokathor> it's in the state maker helper, mkState :: Int -> Int -> Image PixelRGBA8 -> HexesState
16:17:24 <Lokathor> if an image doesn't divide evenly, it'll warn with a trace message
16:18:01 <Lokathor> all the fields in question are Strict, so the trace prints out right away anyway
16:18:44 <Lokathor> I tried to turn it on the first time
16:18:51 <Lokathor> and it drew nothing at all :O
16:19:00 <Lokathor> so now I'm carefully going over it again
16:19:23 <EvanR> classic black screen effect
16:20:34 <Lokathor> well it drew the glClearColor :S
16:20:42 <Lokathor> but not even one triangle
16:22:32 <ertes> (that moment when you see your first triangle on the screen)
16:22:55 <Lokathor> well there were triangles for a while
16:22:59 <Lokathor> and then i rewrote it
16:23:01 <Lokathor> and then there weren't
16:24:59 <ertes> well, the problem is obvious: it's OpenGL
16:25:24 <ertes> rage against the state machine
16:25:43 <Lokathor> yes i'm sure i forgot a state change somewhere
16:25:43 <Rotaerk> is it plugged in?
16:25:46 <Rotaerk> did you turn it on?
16:25:54 <Lokathor> Rotaerk, I even tried turning it off and on again
16:30:06 <ertes> incoming quarterly library check:
16:30:37 <ertes> *now* is there a library for relational database migrations that supports sqlite (or is sqlite-specific)?
16:31:02 <Rotaerk> "are we there yet?"
16:31:28 <ertes> i think i'm just gonna write it myself this time
16:34:56 <spoonm> I'm trying to change a module from xmonad contrib that stores minimized windows in a stack, but I want it to do it in a queue
16:35:43 <spoonm> thing is I don't really know how this works, so what I came up with was reversing the window list(if I understand this correctly it's converting a StackSet into a windows list)
16:36:16 <ertes> spoonm: lists aren't really suitable as queues…  you should use Data.Sequence
16:36:22 <spoonm> so uh, my question is I have something that is `X [Window]', and can't just `reverse' it
16:36:47 <ertes> spoonm: X is a functor:  fmap :: (a -> b) -> X a -> X b
16:37:02 <ertes> fmap reverse :: X [a] -> X [a]
16:38:42 <spoonm> ertes: thanks
16:39:21 <ertes> spoonm: you should still switch to Data.Sequence, if you want a queue, because that one you can query/manipulate at both ends
16:39:35 <spoonm> is it possible to use Data.Sequence or something with XMonad.Util.ExtensibleState(https://github.com/xmonad/xmonad-contrib/blob/master/XMonad/Util/ExtensibleState.hs)? (I know this isn't the right place to ask about this)
16:39:44 <EvanR> waahat, functional queue ftw
16:39:57 <EvanR> how many windows will you have
16:40:00 <ertes> spoonm: it's fine, it's a haskell question =)
16:40:35 <spoonm> EvanR: right now minimized windows are stored in a stack and I can restore the last minimized window
16:40:48 <spoonm> I want to be able to store them in a queue and cycle through them
16:40:58 <EvanR> right so Sequence is probably overkill
16:41:27 <spoonm> `fmap reverse (XS.gets minimizedStack)' in `withMinimized' solved it
16:41:36 <spoonm> I want to know what's a better way of doing it, though
16:41:50 <ertes> i wish people would stop using the word "overkill
16:42:10 <ertes> Data.Sequence is a perfect fit for queues…  you should use it
16:42:19 <spoonm> I already made another function in the X.A.Minimize module so I could swap the current window with the last minimized one lol
16:43:09 <spoonm> note: I'm a haskell noob, don't really understand how most of this works, I just try to make sense of what I'm reading and changing
16:43:43 <ertes> spoonm: of course the fact that you're using minimisation is an indicator that you should probably just learn to utilise workspaces properly =)
16:43:57 <ertes> spoonm: moving windows between workspaces is a very powerful tool
16:44:04 <spoonm> oh, no, I do use workspaces
16:44:24 <spoonm> and I have keybinds for creating copies of windows on other workspaces, but that gets a little messy now and then
16:44:47 <spoonm> so I was using the minimize layout to minimize a window and toggle between a different window and the last minimized one
16:44:58 <ertes> keep in mind that you can have as many workspaces as you want, and that you can create and destroy them dynamically
16:45:32 <ertes> there is no reason to have an exact workspace/key-binding correspondence
16:46:53 <spoonm> ertes: how would you go about doing this, given you already have multiple workspaces? (hang on, converting and uploading video ;-;)
16:47:39 <spoonm> http://0x0.st/EGM.webm
16:48:21 <spoonm> imagine the workspace I switched to had other windows, like gimp and whatnot
16:52:43 <ertes> spoonm: not sure i understand the video…  you're switching out the main window?
16:53:02 <spoonm> yup, I'm cycling through minimized windows
16:53:20 <ertes> ah, i do that with regular windows, so they appear to the side
16:53:27 <ertes> let me make a video
16:59:03 <spoonm> this is how I was doing it before, and when I needed more than two windows(now that I can cycle, that's not necessary), using my available workspaces and CopyWindow: http://0x0.st/EGQ.webm
17:00:39 <ertes> still trying to figure out how to pop up a bunch of colored windows…  i'm abusing 'gm display' now =)
17:05:46 <ertes> where can i upload the video without going through the youtube bullshit again?
17:06:05 <spoonm> I use 0x0.st, but you can use u.teknik.io, mixtape.moe, etc.
17:06:20 <spoonm> for 0x0.st, just `curl'
17:08:29 <ertes> cool
17:09:14 <spoonm> I like how none of those domains end with the default .com, .net, .org, tlds
17:09:45 <geekosaur> "that's so 1990s"
17:09:59 <spoonm> heh
17:11:45 <ertes> spoonm: http://0x0.st/EGj.mp4
17:13:27 <spoonm> looks pretty cool, but not exactly what I want
17:13:53 <ertes> i think it's the same thing, except that the "minimised" windows are actually visible
17:13:59 <spoonm> I don't really want the IM thing where there's a layout off to the side and another where the master pane would be, but yeah
17:14:17 <ertes> well, choose a different layout =)
17:14:25 <spoonm> ertes: can I keep the two other windows that are cyclable visible?
17:14:44 <ertes> you can program any logic you want
17:14:55 <spoonm> ertes: I was going to use sublayout, but I couldn't understand how it works or how to use it, even tried with some example configs and nay
17:15:46 <ertes> yeah, xmonad really wants you to be a haskell programmer, if you want to do anything advanced…  in fact my xmonad configuration is a fully cabalised package =)
17:16:12 <ertes> https://github.com/esoeylemez/config/tree/master/myxmonad
17:17:24 <Lokathor> EvanR, found the culprit
17:17:28 <spoonm> nice
17:17:46 <Lokathor> i was creating VAOs and then using them as VBOs without noticing
17:18:02 <spoonm> I'm trying to learn the language as I go, but I often tackle something way too far ahead of me
17:19:44 <ertes> spoonm: i never considered xmonad to be a good way to learn haskell, but a friend of mine started to learn it that way, too
17:20:05 <ertes> so perhaps it's legitimate after all
17:20:45 <spoonm> doesn't seem like a very good way, been told that in the past
17:21:48 <geekosaur> it's not the greatest way to learn haskell as such, but it does seem to make a good gateway drug >.>
17:22:01 <ertes> indeed
17:22:03 <spoonm> maybe general syntax while configuring it, but when you want to change the behavior of this and that you're presented with a bunch of functions you get 100+ lines of errors for modifying what you /thought/ was right
17:23:31 <ertes> spoonm: try not to be intimidated by the size of the error messages…  GHC is really just trying to be helpful, and once you learn how to read the error messages, you will benefit from that
17:24:21 <spoonm> yeah, I learned quite soon to ignore most lines
17:24:56 <spoonm> they're really just saying the first error that popped up caused an error on this other expression, which caused an error here too, and there, and then...
17:25:03 <geekosaur> most of the error message spam happens with layouts... and much of it would go away if we didn't keep the stackset so heavily parameterized so it can be tested in agda
17:25:51 <ertes> geekosaur: seriously?
17:26:14 <ertes> are you doing proofs in agda, or why?
17:26:39 <geekosaur> yeh, the #1 problem is it can't infer Window in the type of a layout, because it's not expressed anywhere except the type in the config record. so if you have any "dangling" layouts they all throw errors
17:27:16 <geekosaur> sjanssen 'proved' XMonad.StackSet in agda
17:27:43 <ertes> you could just take stuff like Window as a module parameter in agda
17:28:00 <ertes> or even postulate it
17:28:10 <geekosaur> but things like Window come from the X11 package so he couldn't reference them, and switched it with Int or a word type for that
17:29:39 <geekosaur> also the type of workspace tags was left a parameter, but realistically you can only use String in xmonad
17:30:11 <geekosaur> (occasionally something else would be nice, but practically you would lose the ability to use just about every contrib because they all assume the tag is String)
17:30:59 <ertes> honestly i wish the StackSet type would go away in favour of a more abstract StackSet class…  reason: i'd really like to have real workspace trees (currently i'm abusing names to represent trees), and i'd like to have window tags
17:31:41 <geekosaur> the StackSet _itself_ needs to go away, really. it's fine as a mathematical entity but the source of like 90% of our UX bugs
17:34:48 <ertes> perhaps it's time for xmonad 1.0 =)
17:35:31 <ertes> changelog: "you can now use xmonad without learning about parametric polymorphism and zippers"
17:40:09 * hackage async-extra 0.2.0.0, bluemix-sdk 0.1.1.0 (AlexanderThiemann): https://qbin.io/8zplal5
17:43:46 <ski> Philonous : they asked in swedish, so ..
17:51:08 * hackage loc 0.1.2.2 - Types representing line and column positions and ranges in text files.  https://hackage.haskell.org/package/loc-0.1.2.2 (chris_martin)
17:57:08 * hackage loc 0.1.2.3 - Types representing line and column positions and ranges in text files.  https://hackage.haskell.org/package/loc-0.1.2.3 (chris_martin)
17:57:57 <EvanR> Lokathor: you only really need one VAO i imagine
17:58:18 <EvanR> and yeah mixing up the various objects...
17:58:23 <EvanR> checking for GL errors may help
18:11:50 <spinus> hello, do you have regex matching example when using guards or patterm matching? Currently I'm trying https://stackoverflow.com/questions/31764967/using-regexp-in-haskell-function-guards but the last example with matches does not work for me
18:12:09 <Lokathor> EvanR, i've read many beginners guides, but i've still yet to understand the whole point of VAOs vs VBOs
18:12:16 <Lokathor> i'm sure it's there somewhere
18:12:34 <katesmith> i would like to learn
18:12:47 <EvanR> its two totally different things
18:13:06 <EvanR> but ultimately an adhoc way to basically do clever state caching
18:13:20 <EvanR> the VAO is
18:15:12 <srk> Lokathor: yes, you can have multiple vertex array objects and render them with the same set of shaders
18:16:11 <Lokathor> srk, yeah one of the later examples i did was drawing more than one cube, and some of them spinning, but it was all with the same VBO over and over
18:16:15 <Lokathor> i've yet to encounter more than one VAO
18:16:59 <srk> Lokathor: here you go https://git.48.io/liveplot/blob/wip/f/src/Graphics/Liveplot/Line.hs#_56
18:17:04 <EvanR> the VAO holds some of your global state, so you can switch that some out quickly and easily by switching out VAOs
18:17:06 <Lokathor> er, more technically, i guess it was draw -> update uniform (which contains a location matrix) -> loop
18:17:13 <EvanR> the fact that it only holds some of it is....
18:17:54 <saylu> http://lpaste.net/355888
18:18:02 <saylu> Hey folks -- have a quick question around csv-conduit and decoding to Haskell types
18:18:11 <saylu> Explained it in the file, but I'm missing an instance and I'm not sure what to do about it
18:18:20 <Lokathor> srk, i don't know the OpenGL package, just the gl package, so a lot of this is nonsensical unforutnately
18:18:31 <saylu> reading from csvs with headers is just fine -- its when I move from the 'NamedRecord' to just 'Record' that I run into trouble
18:18:32 <Lokathor> but i maybe kinda get what you're after
18:20:23 <srk> Lokathor: heh, I'm also using vinyl-gl and andromeda to generate shaders
18:20:38 <srk> much less boilerplate
18:20:55 <srk> inspired by this tutorial http://www.arcadianvisions.com/blog/2013/introducing-vinyl-gl.html
18:21:19 <srk> then I've tried to solve how to bundle shaders with my app and instead decided to try generating them and it worked :)
18:21:51 <EvanR> generate code from your code with more code!
18:23:36 <Lokathor> bundling shaders with your app seems easy, you can just stuff them into a string literal
18:23:46 <EvanR> yuck
18:24:05 <srk> indeed but why when you can use haskell :)
18:24:26 <srk> my shaders were very simple though
18:25:07 <Lokathor> EvanR i'm not sure what's yuck about it
18:25:20 <Lokathor> well, i mean i use a raw string quasiquoter, but still
18:25:21 <EvanR> thats like, just put HTML templates in string literals in your javascript
18:25:27 <EvanR> ah ok better
18:25:51 <Lokathor> https://github.com/Lokathor/learnopengl/blob/master/app/Lesson07.hs#L81 like this
18:26:26 <srk> boring
18:26:33 <Lokathor> hmm
18:26:40 <Lokathor> it seems you can't use withArrayLen and gl together
18:26:43 <Lokathor> :(
18:27:09 <EvanR> eh, i distinctly remember doing that
18:27:21 <Lokathor> hmm
18:27:56 <clamchowder> I have some weird problem with ghci.
18:28:46 <clamchowder> I used to be able to `ghci filename.hs` and then play with the functions in the file.
18:29:03 <Lokathor> well then i wonder why my triangle isn't showing up
18:29:23 <AndChat502> Test
18:29:32 <clamchowder> But after I changed some files and compiled the whole project using `cabal install`, and try to `ghci` the same file, and test some function I got this:
18:30:28 <clamchowder> can't load .so/.DLL for: ~/.cabal/lib/x86_64-linux-ghc-8.0.1/pandoc-2.0-IqHNcNxYMme2AImsjmcj7X/libHSpandoc-2.0-IqHNcNxYMme2AImsjmcj7X-ghc8.0.1.so (~/.cabal/lib/x86_64-linux-ghc-8.0.1/pandoc-2.0-IqHNcNxYMme2AImsjmcj7X/libHSpandoc-2.0-IqHNcNxYMme2AImsjmcj7X-ghc8.0.1.so: undefined symbol: pandoczm2zi0zmIqHNcNxYMme2AImsjmcj7X_TextziPandocziWritersziICML_writeICML_closure)
18:30:53 <clamchowder> The project is pandoc as you can tell
18:31:03 <AndChat502> Test
18:31:08 <Lokathor> thtat's sure a weird one
18:31:12 <clamchowder> Do you know what may have caused this?
18:31:13 <Lokathor> AndChat502, hey hey
18:32:11 <geekosaur> wait, literal ~ ?
18:32:17 <geekosaur> that will not work
18:32:42 <geekosaur> dunno how it got in there but ~ is only meaningful in shells and ghci is not feeding that path through a shell
18:33:41 <clamchowder> Nice spot :) I replaced the $HOME with ~
18:34:04 <clamchowder> is there a way to  revert to pre-`cabal install` state?
18:34:23 <clamchowder> nuking the .cabal directory?
18:35:32 <ertes> clamchowder: rm -rf ~/.cabal/{bin,lib,setup-exe-cache,share} ~/.ghc/*-linux-*
18:35:53 <ertes> (change the last pattern, if you're not using linux)
18:36:01 <anks> Hello, do you have any hints for me on that: https://pastebin.com/4qfUWfyb
18:36:09 <ertes> clamchowder: you should probably start using sandboxes though
18:36:23 <clamchowder> ertes: how do I do that?
18:36:40 <ertes> anks: could you paste on lpaste.net?  pastebin always fucks up the formatting
18:36:55 <ertes> clamchowder: go into a directory, type:  cabal sandbox init
18:37:31 <ertes> clamchowder: now everything you install while that directory is your working directory will be local to it
18:37:37 <anks> ertes in a moment, i've found sthing but I dont think thats that
18:38:21 <Lokathor> EvanR, I've been hoisted again
18:38:46 <clamchowder> ertes: OK with sandbox how do I revert things when it gets messed up again?
18:38:46 <Lokathor> i passed the vertex list twice, so i used my vertexes as my index data in my EBO
18:39:09 <ertes> clamchowder: delete the sandbox
18:39:26 <ertes> clamchowder: (there is a way to "uninstall", but it's very messy)
18:39:33 <clamchowder> ertes: cabal sandbox delete?
18:39:55 <ertes> clamchowder: yeah
18:40:36 <clamchowder> ertes: then cabal sandbox init again? OK thanks a lot.
18:41:42 <ertes> clamchowder: is uninstalling something you do regularly?
18:41:56 <clamchowder> ertes: no
18:47:23 <clamchowder> ertes: I think I just need to sandbox Pandoc.
18:49:22 <anks> hey, any hints on this strange error: http://lpaste.net/355890 ??
18:49:32 <anks> well
18:49:40 <anks> dont bother
18:49:58 <anks> im should go to sleep already
18:49:58 <anks> ..
18:52:14 <ertes> clamchowder: you want to install pandoc as a user?
18:56:13 <clamchowder> ertes: sorry my internet had some problem. back now.
18:56:56 <clamchowder> ertes: i used to install it as a user. But since I'm playing and changing the pandoc code I'm going to try the sandbox
18:58:30 <clamchowder> ertes: the pandoc seems to use Tasty for testing. Is it better than HUnit? I'm new to haskell, and when I searched for ways of unit testing, the top results on google are HUnit
18:59:08 <ertes> clamchowder: tasty is a test framework, and HUnit is a test library that you can use with tasty
18:59:37 <ertes> clamchowder: HUnit is mostly for writing simple assertions
18:59:41 <flashmozzg> Hello, I have a quick newbie question: it looks like my program stack overflows while creating a simple linkedlist-like structure while reading from file (about 5e5 elements). But I see no way to make it strict/recursive.
18:59:46 <flashmozzg> Basically I want something like (imperative pseudocode):for 1..n do ans = No
19:00:11 <exio4> flashmozzg: can you give some example code?
19:00:13 <HallaSurvivor> flashmozzg: can you give us a 
19:00:14 <HallaSurvivor> ^
19:00:16 <clamchowder> ertes: when I cabal install my customised pandoc (which involves HUnit for testing), it complains about not pandoc.cabal not having HUnit as a dependency.
19:00:29 <flashmozzg> for 1..n do ans = Node { value = readfunc line, next = Nil}; and.next = recursive call.
19:00:31 <clamchowder> ertes: I wonder what testing library pandoc uses.
19:00:51 <ertes> clamchowder: cabal install --only-dependencies
19:00:57 <exio4> flashmozzg: example haskell code which leads to space-leaks/stack overflow
19:01:21 <flashmozzg> the problem is that my parsing functions not only return the result but the remaining string to parse, so I can't simply use accumulators.
19:01:44 <clamchowder> ertes: I thought that installs the dependencies specified in pandoc.cabal..
19:01:54 <flashmozzg> Well, I'm pretty sure it's this code to blame:
19:01:55 <flashmozzg> getListNode :: ([String] -> (a, [String])) -> [String] -> (ListNode a, [String])
19:01:55 <flashmozzg>     getListNode f (x:xs) = getListNode' (read x::Int) xs
19:01:55 <flashmozzg>       where getListNode' 0 l = (Nil, l)
19:01:55 <flashmozzg>             getListNode' n l = (ListNode {val = v, next = nxt}, rest)
19:01:56 <flashmozzg>               where (v, ls) = f l
19:01:57 <flashmozzg>                     (nxt, rest) = getListNode' (n - 1) (ls)
19:02:03 <lyxia> @lpaste
19:02:03 <lambdabot> Haskell pastebin: http://lpaste.net/
19:02:09 <glguy> flashmozzg: It's not OK to paste that much into chat
19:02:19 <flashmozzg> ops, sorry.
19:02:34 <ertes> clamchowder: the current release version uses test-framework (tasty is a more modern replacement for that one) together with HUnit and QuickCheck
19:02:39 <HallaSurvivor> flashmozzg: use either pastebin, or git gists :)
19:02:48 <ertes> clamchowder: https://hackage.haskell.org/package/pandoc-1.19.2.1/pandoc.cabal
19:02:56 <clamchowder> Is there a function that takes a mixture of spaces and tabs, and output the length of the indentation?
19:02:59 <flashmozzg> Well, it's 6 lines, so it's not terribly big
19:03:19 <clamchowder> ertes: OK thanks, I'll have a look in that. Mine (pandoc 2.0) did not have HUnit, weird.
19:03:24 <glguy> flashmozzg: More than 2 can go to a pastebin
19:03:29 <ertes> clamchowder: none that i know of, but it's fairly easy to create
19:03:46 <flashmozzg> anyway, here it's on pastebin: http://lpaste.net/8980774266588889088 
19:03:56 <HallaSurvivor> ty <3
19:04:04 <ertes> clamchowder: oh, you should do this first:  cabal configure --enable-tests
19:04:20 <ertes> clamchowder: (after creating the sandbox)
19:04:41 <flashmozzg> The error itself obviously appears down the line, when I actually try to use parsed stracture (i.e. access it's last element).
19:04:42 <ertes> clamchowder: (you can just do it now…  no need to start from scratch)
19:04:48 <lyxia> clamchowder: 1) set your tabwidth to 1. 2) you can now use length.
19:04:55 <Lokathor> EvanR, https://www.dropbox.com/s/us7d3banox3qesq/Screenshot%202017-05-27%2020.01.23.png?dl=0
19:05:28 <EvanR> ah you drew on the sprite sheet
19:05:32 <athan> If I wanted a shared TChan across multiple processes, should I just be using a Unix domain socket?
19:05:42 <clamchowder> lyxia: that's a good solution, but what if someone else runs it..?
19:05:52 <Lokathor> that's not the sheet, that's a screenshot of the program window
19:05:56 <ertes> athan: yeah, with your favourite serialisation package
19:06:05 <Lokathor> i made it scale down the point locations to the resolution within the shader
19:06:28 <athan> hrm. thanks ertes 
19:06:29 <Lokathor> http://lpaste.net/355891
19:06:30 <EvanR> athan: if by shared you mean one side is in one process the other is in another (not more than 2 processes) and by transactional you mean not transactional, yeah
19:06:33 <ertes> athan: alternatively try one of the many message passing frameworks like ZeroMQ
19:06:42 <clamchowder> ertes: I'm already re-`cabal install` pandoc, because by rm -rf much of the .cabal directory most of the dependencies are gone..
19:06:56 <EvanR> athan: you may also be able to just use stdio
19:06:59 <exio4> flashmozzg: where do you use this function?
19:07:05 <athan> EvanR Is there hope for transactional?
19:07:06 <EvanR> if not already in use
19:07:17 <athan> ahh good idea thanks ertes 
19:07:19 <exio4> flashmozzg: it's quite a weird function
19:07:55 <clamchowder> ertes: I'm just gonna rm rf the subdirs involving pandoc in $HOME/.cabal/, and then do the sandbox thing
19:07:57 <EvanR> athan: you could guard the socket in one of the processes with STM, but that STM will not cooperate with STM in the other process
19:08:23 <ertes> clamchowder: you need to delete the corresponding files from ~/.ghc, too
19:08:28 <flashmozzg> exio4: it's a parsing function. It takes list of strings (from the file) parses it into linkedlist and returns unparsed strings as a second pair argument
19:08:35 <clamchowder> ertes: OK thanks for reminding
19:09:01 <flashmozzg> exio4: (since there are other similar function which can be combined)
19:09:02 <ertes> clamchowder: (in fact deleteing anything from ~/.cabal is optional)
19:09:03 <clamchowder> ertes: do you know if there is a function in the pandoc code calculating the length of indentation?
19:09:22 <ertes> clamchowder: sorry, i'm not familiar with pandoc's source code
19:09:29 <clamchowder> ertes: no worries.
19:09:50 <exio4> flashmozzg: do you have the structure of some f's? 
19:10:00 <exio4> flashmozzg: and how do you read the original [String]? 
19:10:06 <clamchowder> ertes: I thought things ~/.cabal was the culprit because ghci complained about some weird files in that directory...
19:10:12 <exio4> flashmozzg: FWIW, String is quite an inefficient type for having *actual* strings on memory
19:10:21 <flashmozzg> exio4: just basic readFile
19:11:11 <exio4> you might want Text (or even ByteString if you don't need actual text but can work at a byte-level)
19:11:13 <exio4> ah
19:11:25 <exio4> flashmozzg: do f's read "forward" into the string, or just the head? 
19:11:55 <clamchowder> ertes: strange, after re-installing everything without changing any pandoc code, the ghci problem vanished.. 
19:12:04 <clamchowder> ertes: thanks for the suggestions.
19:12:17 <exio4> flashmozzg: (unrelated, but it's also missing error handling, which should be a good practice as you're using `read`, which is likely to fail)
19:12:22 <flashmozzg> exio4: each f returns (result, unparsed chunk)
19:12:52 <exio4> flashmozzg: I am talking about f's strictness
19:12:52 <ertes> > (indentation "", indentation "\t", indentation "\t  ", indentation "\t  \t")
19:12:54 <lambdabot>  (0,8,10,16)
19:13:02 <ertes> clamchowder: something like that?
19:13:31 <clamchowder> ertes: I guess it depends on the tabwidth..
19:14:25 <flashmozzg> exio4: well, not sure. f can be anything (see the signature), even the getListNode itself (that way I'll parse linkedlist of linkedlists).
19:14:25 <ertes> > (indentation 4 "", indentation 4 "\t", indentation 4 "\t  ", indentation 4 "\t  \t")
19:14:27 <lambdabot>  (0,4,6,8)
19:14:31 <ertes> clamchowder: like that?
19:14:56 <EvanR> :t indentation
19:14:57 <lambdabot> (Foldable t, Integral a) => a -> t Char -> a
19:15:12 <exio4> flashmozzg: yes, I am talking about the strictness of those functions
19:15:35 <clamchowder> Ah I see identation is a built-in thing!
19:15:41 <clamchowder> OK let me see what it's about
19:15:47 <ertes> clamchowder: no, it's not =)
19:16:05 <ertes> clamchowder: i just defined it secretly, so you can take implementing it as an exercise =)
19:16:25 <flashmozzg> exio4: well I can't enforce it, so they are probably not strict. But why would that matter?
19:16:44 <clamchowder> ertes: I see... lambdabot can read lhs style code - sneaky
19:17:02 <ertes> clamchowder: you can /query it
19:17:18 <flashmozzg> exio4: i.e. example f: (\(x:xs) -> (read x :: Int, xs))
19:18:04 <exio4> flashmozzg: if they are too strict on the argument, then that'd lead to basically reading the whole file at once, and then doing other things
19:18:11 <clamchowder> ertes: ok
19:18:20 <exio4> flashmozzg: which, on strings, is really wasteful
19:19:20 <clamchowder> ertes: did you hardcode 4 as tabwidth in the indentation function?
19:20:09 * hackage makefile 1.0.0.3 - Simple Makefile parser and generator  https://hackage.haskell.org/package/makefile-1.0.0.3 (nmattia)
19:20:30 <flashmozzg> exio4: well, I NEED to read the whole file. I.e. I don't so much care about the ultimate performance rather I just don't want my program to crash.
19:21:05 <EvanR> flashmozzg: right ... when that happens a strict ByteString read of the whole file might work better
19:21:22 <exio4> flashmozzg: there's a big difference between reading the whole file at once and reading it by parts, if you want this to be performant, using String(s) naively isn't the best idea
19:21:22 <EvanR> then process that
19:21:40 <flashmozzg> exio4: if I don't do anything with my parsed linkedlist - no stack overflow happens. Btw, I can even convert it to regular list, take it's length, and it's ok. Bu trying to take the last element - stack overflow.
19:22:20 <flashmozzg> exio4: my files are 4mb at most. I want it to not crash.
19:22:35 <EvanR> yeah dont use String 
19:22:54 <exio4> flashmozzg: do you have some example code? 
19:22:55 <EvanR> as silly as that sounds
19:23:00 <exio4> like, complete code
19:23:46 <exio4> flashmozzg: also, I've worked with 4mb files with String(s) just fine, so I don't think this is the exact issue 
19:24:56 <exio4> what's your definition of ListNode?
19:25:04 <flashmozzg> exio4: that is almost complete code, you just need to apply this func to the result of readfile with 5e5 lines) And while I can past the more final code, I'm not sure I'll manage with input file
19:30:47 <exio4> flashmozzg: http://dpaste.com/2R6KW5A this code works just fine 
19:30:52 <flashmozzg> exio4: well I put together some code, the only thing that is missing is input.txt http://lpaste.net/8712522381786087424
19:32:13 <exio4> that code doesn't compile
19:32:19 <exio4> but I'll fix the mistakes and try it
19:33:16 <exio4> $ time ./test
19:33:18 <exio4> False
19:33:20 <exio4> real    0m1,547s
19:33:31 <flashmozzg> exio4: yeah, I hand typed it. The problem is when the linked list is very big (5 * 10^5).
19:33:47 <flashmozzg> (well, comparatively big)
19:34:07 <exio4> tried it with 1M elements, took 15s
19:34:12 <exio4> with 100k elements, just 1.5s
19:34:40 <exio4> (this is a 64bit laptop, 2gb ram, intel atom, the crappiest software you'll ever find)
19:35:34 <flashmozzg> exio4, hm, verry strange.
19:35:37 <exio4> that function is just fine, I think the problem is on the `f` function you pass, being way too strict, or maybe some kind of infinite loop caused by returning a list that's bigger than the input or something weird
19:38:03 <flashmozzg> exio4: well, I haven't done anything to make my func stricter, so I doubt haskell made it stricter by himself.
19:39:58 <exio4> flashmozzg: I don't think I can help further without looking at the exact code causing this issue, I don't think it's just strictness but probably some `f` returning some thunk which requires a pattern matching for the resulting list, which in turns end ups requiring more and more over time, thus leading to a stack overflow
19:40:30 <exio4> flashmozzg: which is mostly related to "pattern matching required a pattern match, which in turn required a pattern match, which required another one, ...."
19:40:42 <dash> I realize this isn't _strictly_ a haskell question, but: does anyone know of FRP-or-similar libraries for terminal UIs? Anyone done reactive-banana-ncurses or something like JavaScript's React for terminals? :)
19:43:11 <exio4> flashmozzg: (I would do note that your program is really really unproductive GC-wise (compile it with -rtsopts and check with +RTS -s
19:43:27 <flashmozzg> exio4: hm, well, the only difference I see is that I do no pass f as lamda directly rather I use parseFun f (x:xs) = (f x, xs) and pass (parseFun (read::Int), and also, there are a couple of linked lists that are parsed from file, but it only overflwos on the biggest one
19:44:52 <exio4> flashmozzg: BTW, your toList algorithm isn't really.. nice, it'd be better if you didn't it make "tail-recursive"
19:45:03 <exio4> flashmozzg: as naive tail-recursion is actually bad if you are lazy
19:45:19 <exio4> flashmozzg: (it'll build more and more thunks in the 2nd parameter, until you call it later)
19:45:34 <exio4> flashmozzg: you either make the 2nd parameter strict, which has its own issues, or write it as:
19:45:38 <exio4> toList Nil = []
19:45:45 <exio4> toList (ListNode x xs) = x : toList xs
19:46:13 <flashmozzg> exio4: yeah, I tried to write it differently but realized that it was't the problem
19:49:40 <flashmozzg> exio4, btw it overflows on a GHC 7.6.3 under Ubuntu, could this be the problem?
19:50:18 <exio4> flashmozzg: I am using GHC 8.2.0, so, maybe :)
19:51:35 <exio4> flashmozzg: in general, too, lists shouldn't be used if you actually want everything to be in memory at the same time
19:52:11 <exio4> flashmozzg: there are better data structures for that (Vector, Set, Map, ByteString, Text, ...)
19:54:44 <exio4> flashmozzg: btw, can you try adding laziness annotations?
19:55:23 <exio4> flashmozzg: I think that's the issue, ~(v,ls) instead of (v,ls) and ~(nxt,rest) instead of (nxt,rest)
19:57:03 <exio4> flashmozzg: ignore everything I said, thought where was lazy :P 
19:57:50 <flashmozzg> exio4: well, it is good enough for now. Partly the problem is that types need to be "standard" at the end point anyway. I've copied the code from the ubuntu machine to my windows desktop (it uses ghc 8.01 or 7.12, don't remember) and ti work fine there. And I've jsut reduced the number of linked list read from file...
19:59:31 <exio4> flashmozzg: http://dpaste.com/33H9B9Y this works in constant memory on my laptop, with just two changes :P 
19:59:56 <exio4> you don't need the bangpatterns, anyway
20:02:02 <flashmozzg> exio4: I can't reproduce the issue on my windows desktop ;P But it is on the ubuntu with GHC 7.6.3
20:02:42 <exio4> flashmozzg: try the laziness annotations, anyway, that'll greatly improve the performance :P
20:03:06 <flashmozzg> exio4: (btw, on that machine the stacksize is set to unlimeted, but ghc iiuc bypasses it and uses it's own size)
20:04:38 <exio4> flashmozzg: stack size on GHC is different to other programming languages, it's a pattern matching stack
20:05:22 <flashmozzg> exio4: with bang patters I get error: Parse error in pattern: getListNode'
20:05:39 * hackage grammatical-parsers 0.1, rank2classes 0.1 (MarioBlazevic): https://qbin.io/yvqolhkg
20:05:41 <exio4> flashmozzg: remove the ! in the code
20:08:49 <flashmozzg> exio4: still the same thing on ubuntu "Stack space overflow: current size 8388608 bytes." =(
20:08:59 <exio4> flashmozzg: even with ~? :/
20:09:11 <flashmozzg> exio4: yup, really strange
20:09:19 <EvanR> its indicative of buggy code unfortunately
20:09:47 <EvanR> parsing a large file as a String the wrong way will just eat ram
20:09:52 <flashmozzg> exio4: I tryied to use `seq` before and it didn't help
20:10:09 <EvanR> seq might make it worse, same as !
20:10:25 <flashmozzg> Evan4: or buggy compiler, since on my win desktop and exio4' PCs the code works fine even without any optimizations
20:10:39 <EvanR> its because one some versions of ghc the default is no stack size limit
20:10:47 <flashmozzg> And the only difference I see is newer GHC
20:11:00 <EvanR> right, the limit was removed later
20:11:11 <exio4> EvanR: my code works in constant memory :)
20:11:35 <EvanR> i assume your code is totally different?
20:11:44 <exio4> with the laziness annotation
20:12:39 <EvanR> i suspect an incongruity in these stories
20:12:42 <EvanR> besides that
20:14:44 <exio4> and indeed, I can't test the exact code flashmozzg runs because he's not giving the complete code 
20:15:41 <flashmozzg> exio4: I tested the exact code my ubnutu pc runs, on my windows machine and I couldn't reproduce it either.
20:16:07 <exio4> flashmozzg: http://dpaste.com/33H9B9Y talking about this test case
20:16:12 <flashmozzg> So it's probably just like EvanR said - newer compilers removed the limit and it works just fine after that
20:16:25 <EvanR> well, it works, not what id call just fine
20:16:28 <exio4> flashmozzg: the thing is, it shouldn't be even reaching the limit
20:16:45 <EvanR> imposing a stack limit is a good way to detect space leaks in your code
20:17:09 <flashmozzg> exio4: what's wrong with thsi test case? it work on my win pc too, but not on ubuntu.
20:17:17 <EvanR> C programs which leak space also run fine as long as they dont run too long
20:17:34 <exio4> flashmozzg: did you run the exact code I linked in ubuntu/GHC 7.6?
20:18:18 <flashmozzg> exio4, well I replaced the getListNode with your version and the result is the same.
20:18:58 <exio4> flashmozzg: the thing is, I can't know what's exactly the issue unless I have the full code, because laziness is a tricky problem which requires more than the function which caused the blowup
20:19:33 <EvanR> which is funny because "laziness is great because you can write code without worrying about how someone else will use it"
20:19:42 <EvanR> "its more modular"
20:19:59 <exio4> flashmozzg: for example, you gave me a test case, with a simple change I optimized it from a stack blowup to a constant memory algorthm
20:20:46 <flashmozzg> Evan4: well my initial question was to how to make my program better without sacrificing flexibility (i.e. ability to compose parsing function),
20:21:07 <EvanR> yeah laziness would probably help with that
20:21:35 <exio4> flashmozzg: I think, again, the issue is with some other function not doing what it should be doing :p 
20:23:11 <flashmozzg> exio4: I swear, there are no other functions xD And I run exactly the same code on different pc but with newer ghc and "it jsut works". Btw, how do you properly check the memery usage? I know how to do that in ghci, but it's not the ebst place to test.
20:24:07 <exio4> flashmozzg: you can compile your code with -rtsopts and do +RTS -s to get basic stats, if you want more info, you have to compile wth profiling (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html) 
20:24:27 <EvanR> theres ekg
20:29:21 <flashmozzg> exio4: don't really see much difference between version with ~ and not
20:35:38 <flashmozzg> exio: btw, does +RTS -Ksize -RTS work for you? I tired using it, but it looks liek it automatically sets lowest stack size possible (32KBs) and fails with that. I wanted to confirm, that If I set the stack to 8MB, when it will fail.
20:36:30 <spoonm> ... why do I get so many errors about Integral and Fractional types? all I wanted was to divide two numbers, is it so hard? :(
20:36:52 <ChaiTRex> spoonm: Use `div` for integers.
20:37:05 <ChaiTRex> spoonm: Or use fromIntegral a / fromIntegral b
20:37:21 <spoonm> ChaiTRex: I was doing fromIntegral, but for some reason I got a ton of errors still
20:37:34 <exio4> flashmozzg: how are you using -Ksize? 
20:37:34 <ChaiTRex> spoonm: Oh, can you paste your code to lpaste?
20:37:40 <ChaiTRex> @lpaste
20:37:40 <lambdabot> Haskell pastebin: http://lpaste.net/
20:37:44 <exio4> flashmozzg: -K20MB or -K20? 
20:37:51 <exio4> 20M * 
20:38:01 <flashmozzg> exio4: +RTS -K10000 -RTS
20:38:28 <exio4> flashmozzg: that's not 10 megabytes though
20:38:43 <exio4> flashmozzg: just a bit less than 10 kilobytes, which is why it's picking the lowest stack size possible
20:39:05 <flashmozzg> rxio4: I know. The problem is that it works weird
20:39:29 <spoonm> ChaiTRex: I can ix it, here: http://ix.io/viv
20:39:39 <flashmozzg> exio4: +RTS -K64 -RTS -  Stack space overflow: current size 33624 bytes.
20:39:49 <flashmozzg> exio4: out.exe +RTS -K10000000 -RTS -  Stack space overflow: current size 33624 bytes.
20:40:04 <flashmozzg> exio4: out.exe +RTS -K100000000 -RTS - no error, so don't know the stack
20:40:47 <spoonm> ChaiTRex: I'm passing a [(Double, Integer)] to them, and at first I did `fromIntegral length pairs' on `medar'
20:40:57 <spoonm> but then it complained a lot about other things
20:41:19 <ChaiTRex> spoonm: You need "medar pairs = totalSum / fromIntegral (length pairs) where"
20:41:31 <ChaiTRex> spoonm: length returns an Int, so it needs the fromIntegral treatment.
20:41:51 <ChaiTRex> spoonm: Oh, I see. You need to put parentheses around length pairs, too.
20:41:52 <spoonm> yeah, I found that out, but still dunno why it complains so much
20:42:04 <spoonm> lemme try again with your suggestion
20:42:48 <spoonm> whoa it actually worked
20:42:55 <spoonm> thanks a lot, ChaiTRex o.o
20:43:14 <ChaiTRex> spoonm: If you say "fromIntegral length pairs", it thinks that you want to convert the function length into another numeric type, which it doesn't know how to handle.
20:43:20 <ChaiTRex> spoonm: You're welcome.
20:43:55 <spoonm> is there a particular reason for Haskell to be so strict about types in arithmetic expressions?
20:44:17 <Welkin> yes, because a float is not an integer
20:44:22 <ChaiTRex> spoonm: Yeah, it's the general philosophy of Haskell, being strict about types.
20:44:32 <exio4> flashmozzg: no idea, to be honest
20:44:39 <ChaiTRex> spoonm: It helps avoid errors, though, so there's a silver lining.
20:44:55 <exio4> "being strict on types, non-strict on values" 
20:44:59 <Welkin> there are always some tradeoffs, but this one is very minor
20:45:02 <exio4> this doesn't sound well outside programming :P
20:45:04 <spoonm> even though you would normally cast integers to floating types?
20:45:08 <monochrom> Types keep me honest.
20:45:15 <exio4> spoonm: why not floating types to integers?
20:45:20 <Welkin> I don't find myself typing in long equations that mix floating point and integral values often (if ever)
20:45:39 <spoonm> exio4: involves loss of information, but also manageable, it has some applications
20:45:53 <monochrom> Also I doubt that it is casting. Conversion sounds more like it.
20:45:55 <exio4> spoonm: same goes if you convert an Integer to a floating type
20:46:17 <spoonm> exio4: fair enough
20:46:27 <exio4> spoonm: an Integer can hold a number as big as your memory allows it, Floats/Doubles can't
20:46:30 <flashmozzg> exio4: well, thanks anyway. WOuld be nice if you just tried to run your code with 8388608 bytes stack limit. But anyway, big thanks for helping me solve this weird error. I'll try to updite the ghc on my Ubuntu machine and see if it helps.
20:47:16 <exio4> flashmozzg: this code just sent my computer to hell, my laptop completely froze for 35~ seconds
20:51:46 <Lokathor> EvanR, https://www.dropbox.com/s/lgiwbn6un4k4fc4/Screenshot%202017-05-27%2021.51.22.png?dl=0
20:56:43 <exio4> flashmozzg: oh, apparently the strict patterns did do something :p
20:57:00 <exio4> flashmozzg: enable {-# LANGUAGE BangPatterns #-}
20:57:13 <exio4> flashmozzg: and add ! on l in getListNode'
20:57:24 <exio4> flashmozzg: I just tested the code without bang patterns and it's as slow as the default version
20:59:40 <exio4> flashmozzg: and the perf improvements seem to be caused by the strictness on l than the laziness annotations, my bad, twice
20:59:50 <exio4> it's way too late :)
21:04:48 <Lokathor> https://www.dropbox.com/s/6hreku5lkugcnix/Screenshot%202017-05-27%2022.03.19.png?dl=0 it worksssss
21:46:40 <flashmozzg> exio4: tahnks again! But I I said, adding ! leads to Parse error in pattern: getListNode'
21:54:38 <flashmozzg> exio4: for some reason pragma didn't activate the bangpatterns properly
21:59:14 <Sh4rPEYE> I have a bunch of signed permutations (:: [[Int]]) and I need to nicely print them one per line like this:
21:59:14 <Sh4rPEYE> [-1, -2, 1] --> -1 -2 1
21:59:42 <Sh4rPEYE> If they weren't signed, I'd use some combination of show and intersperse ' '... But what to do in this case?
22:01:05 <c_wraith> Sh4rPEYE: what does being signed change?
22:01:07 <Sh4rPEYE> *To be exact, I have [-1, -2, 1] and I want to print it like "-1 -2 1"
22:01:11 <flashmozzg> exio4: tahnks, it really did help
22:02:01 <c_wraith> Sh4rPEYE: Oh, I think I understand. intersperse is the wrong function.  you want intercalate
22:02:16 <dmwit> > unwords . map show $ [-1, -2, 1]
22:02:18 <lambdabot>  "-1 -2 1"
22:02:33 <Sh4rPEYE> c_wraith: Never heard about that one. Will check, thanks
22:02:55 <c_wraith> Sh4rPEYE: you need that for inputs with multiple digits expressed in decimal anyway
22:03:08 <c_wraith> Sh4rPEYE: or unwords, as dmwit points out
22:03:15 <Sh4rPEYE> dmwit: Cool! Just like that. Could've guessed there's un-words for words 
22:03:40 <Sh4rPEYE> I'm just learning Haskell and the library functions just go over my head a little bit
22:03:48 <Sh4rPEYE> Thank you both
22:22:17 <timbod7> Hi. What's the idiomatic way of creating a singleton Data.List.NonEmpty value?
22:25:06 <Lokathor> timbod7, i'd probably define a singleton helper function
22:25:09 <Lokathor> if i were going to do it a lot
22:25:32 <timbod7> Lokathor It's a one off.
22:25:37 <Lokathor> > 2 :| []
22:25:39 <lambdabot>  error:
22:25:39 <lambdabot>      • Data constructor not in scope: (:|) :: Integer -> [t0] -> t
22:25:39 <lambdabot>      • Perhaps you meant one of these:
22:25:47 <timbod7> (In a call to the amazonka library).
22:25:52 <Lokathor> > 2 Data.List.NonEmpty.:| []
22:25:55 <lambdabot>  error:
22:25:55 <lambdabot>      Not in scope: data constructor ‘Data.List.NonEmpty.:|’
22:25:55 <lambdabot>      No module named ‘Data.List.NonEmpty’ is imported.
22:26:00 <Lokathor> poor lambdabot
22:26:15 <Lokathor> but yeah you can just write (val :| []) and it'll be fine
22:26:39 <timbod7> I'm surprised there's not a builtin to do it, given that you need to start non empty list with a single value.
22:27:17 <EvanR> it unsually doesnt seem to have `singleton`
22:27:46 <Lokathor> (singleton a) is actually longer than (a :| []) though
22:27:57 <EvanR> though it might be in the latest version which hackage doesnt have docs for
22:28:12 <EvanR> length isnt everything, queue the joke
22:28:41 <timbod7> Lokathor But the docs suggest importing qualified, in which case you end up with something longer.
22:29:02 <timbod7> or an import especially for the ctor
22:29:04 <Lokathor> fair point
22:29:08 <EvanR> :| is ____ enough to import unqualified
22:29:27 <timbod7> Yes - but then 2 lines of imports!
22:29:40 <EvanR> right... of course you can put both lines on one line ;)
22:29:56 <Lokathor> i've had modules with more imports than code before :P
22:29:56 <timbod7> Anyway - thanks. Just wondered if I was missing something obvious.
22:30:15 <EvanR> check the latest version of the package and see if singleton is defined
22:30:28 <cocreature> you can use "pure/return" to create singletons
22:31:07 <EvanR> doh ... yeah
22:31:20 <EvanR> "obviously"
22:31:42 <cocreature> you could also use OverloadedLists and [val] instead of a :| []
22:32:02 <timbod7> yes - I guess pure is the right approach.
22:32:45 <timbod7> don't really like [val] as if you write [] instead it will fail at runtime won't it?
22:32:53 <cocreature> yep
22:33:40 <mbrock> My state has a Data.Tree to which I want to keep adding nodes. I always add them at the "rightmost" index. Should I use a zipper? I tried to figure out ekmett's "zippers" package but got confused.
22:40:40 <mbrock> Ah, I think the "zippers" package simply isn't made for dynamic levels, e.g. moving up and down an arbitrary rose tree. The "rosezipper" package seems more appropriate.
22:45:45 <c_wraith> mbrock: it has the issue that a zipper changes types whenever it changes levels.  That makes it very hard to change levels dynamically.
22:45:52 <c_wraith> mbrock: which is probably exactly what you discovered. :)
22:49:00 <mbrock> c_wraith: Yeah, I might have guessed sooner if the top example in the docs didn't involve Data.Tree...
22:50:03 <c_wraith> mbrock: yeah, it's a case where simple static examples make the library look more capable than it is, because you never have to deal with the hairy types
22:55:00 <Sh4rPEYE> Is there any list-like data type with fixed length? Something like Queues in Python
22:56:22 <ChaiTRex> Sh4rPEYE: A tuple?
23:03:11 <EvanR> Sh4rPEYE: usually called a Vect
23:03:36 <EvanR> youll need type level numbers to talk about the length
23:05:00 <geekosaur> are we sure this isn't just Array or maybe Vector?
23:05:13 <geekosaur> as opposed to a fixed-length linked list?
23:08:15 <ChaiTRex> If we're talking concurrency, there is https://hackage.haskell.org/package/BoundedChan-1.0.3.0/docs/Control-Concurrent-BoundedChan.html
23:24:28 <cocreature> Sh4rPEYE: if it’s fixed length something like a Vector is usually the best solution. you can use something like https://hackage.haskell.org/package/vector-sized-0.5.1.0/docs/Data-Vector-Sized.html to get a fixed size
23:25:56 <EvanR> did not know about this one
23:32:20 <Icarus> Hello
23:33:45 <c_wraith> hey Icarus 
23:34:29 <Icarus> What's everyone up to?
23:38:08 <c_wraith> apparently no one is up to anything of interest...  Or are so engrossed they didn't notice the question. :)
23:39:15 <EvanR> differential equations
23:46:23 <fresheyeball> whats the type operator that makes tuples?
23:47:52 <pavonia> It's a function, not an operator, I think
23:57:25 <nshepperd> (,) :: * -> * -> *
23:57:36 <nshepperd> it's a mixfix operator, i guess
23:58:02 <vaibhavsagar> Friends! When did do-notation come to Haskell?
