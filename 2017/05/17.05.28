00:03:36 <cocreature> nshepperd: now we only need a way to define our own mixfix operators :)
00:15:34 <ReinH> cocreature: I wish.
00:19:24 <cocreature> ReinH: tbh I’m not sure I do. but maybe that’s just because Coq has a particularly messy way to define custom notations.
00:19:44 <ReinH> I like Agda's
00:21:34 <EvanR> idris
00:21:55 <cocreature> I thought idris didn’t let you define mixfix operators?
00:22:12 <cocreature> maybe I’m confusing things here
00:22:24 <EvanR> it lets you introduce syntax sugar
00:22:47 <EvanR> which could expand to regular functions or operators
00:23:10 <EvanR> though agda seems to have that too
00:23:11 <ReinH> It's a bit annoying though
00:23:27 <ReinH> syntax in Agda allows for binders
00:23:35 <ReinH> otherwise you can just use mixfix
00:45:15 <LiaoTao> Hmm
00:45:27 <LiaoTao> GHC is eating all my memory when compiling store-0.3.1
00:45:45 <LiaoTao> Had a nice episode of swap thrashing just now
00:50:14 <ongy> how much memory do you have?
00:50:17 <ongy> and which GHC version?
00:50:45 <LiaoTao> 3G available with 1G of swap
00:51:21 <LiaoTao> I tried it again with everything else closed and it worked
00:51:29 <LiaoTao> Maybe there's a kernel bug in the swap management
00:51:34 <LiaoTao> Anyway!
00:52:07 <LiaoTao> Also, GHC 8.0.2
00:57:02 <ongy> shouldn't eat that much memory either way, I can compile it on my laptop with 4G total (usually ~3 Available) and no swap
00:57:19 <ongy> will runhaskell get a cabal new-build version where it can use the store for package lookup?
00:57:47 <LiaoTao> I wasn't able to check how much memory it was using at the time since the system became nigh unusable
00:57:58 <LiaoTao> Load shot up to ~18 though
00:58:21 <pacak> LiaoTao: compiling with -j1 might help
00:58:35 <LiaoTao> pacak: Noted :)
00:59:38 * hackage aeson-pretty 0.8.3 - JSON pretty-printing library and command-line tool.  https://hackage.haskell.org/package/aeson-pretty-0.8.3 (FalkoPeters)
00:59:40 <pacak> used 1.6Gb on my machine
01:00:00 <pacak> LiaoTao: OS?
01:00:41 <LiaoTao> Linux 4.11.3
01:00:45 <LiaoTao> Gentoo
01:01:22 <pacak> 32bit, 64bit?
01:01:32 <LiaoTao> 64 :)
01:01:51 <LiaoTao> Linux ### 4.11.3-gentoo #2 SMP Sat May 27 21:51:48 CST 2017 x86_64 Intel(R) Core(TM) i3-4030U CPU @ 1.90GHz GenuineIntel GNU/Linux
01:01:56 <pacak> $(reifyManyWithoutInstances ''Store [''Info] (const True) >>= mapM (\name -> return (deriveGenericInstance [] (ConT name))))
01:02:02 <pacak> ^ that's probably why.
01:02:49 <LiaoTao> Templates eating memory?
01:02:54 <pacak> Generics
01:03:01 <LiaoTao> Right
01:04:08 * hackage aeson-pretty 0.8.4 - JSON pretty-printing library and command-line tool.  https://hackage.haskell.org/package/aeson-pretty-0.8.4 (FalkoPeters)
01:07:06 <pacak> So they basically look for ALL THE THINGS without store instances and derive instances using generics.
01:07:30 <LiaoTao> pacak: That's one way to do it :D
01:07:31 <pacak> That seems like all 63 variants of tuple for example.
01:08:38 <pacak> LiaoTao: So no, it's not ghc or linux kernel fault. Store is written by idiots.
01:11:07 <LiaoTao> pacak: The kernel swap bug was only mentioned tangentially
01:11:26 <LiaoTao> Feels like the system shouldn't explode just because it used slightly more memory than was available outside of swap
01:11:57 <LiaoTao> But yeah, their approach seems a bit heavy-handed
01:12:23 <pacak> There's not much kernel can do - ghc does GC and thus touching all the things
01:13:22 <LiaoTao> It probably qualifies as a complex interaction between memory management systems then :)
01:38:20 <Lokathor> is it good or bad, would you say, that haddock doesn't point out when a type is a data or when a type is a newtype?
01:42:21 <pacak> Probably bad - they are a bit different.
01:47:59 <Lokathor> hmm
01:48:14 <Lokathor> on an unrelated subject, does anyone know if openGL does vsync automatically?
01:48:25 <Lokathor> and/or if GLFW-b does vsync automatically?
01:48:33 <cocreature> haddock only does that if you don’t export the constructor iirc
01:48:39 <cocreature> and that is pretty reasonable imho
01:48:51 <cocreature> for an abstract type, the user shouldn’t have to care if it’s data or newtype
01:48:52 <Lokathor> cocreature, good detail to know
01:49:59 <cocreature> e.g. https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Monoid.html#t:Sum shows that it’s a newtype
01:51:32 <Lokathor> i only ask about vsync because a quick use of the timer seems to show my frames taking almost exactly 16ms per frame
01:51:39 <Lokathor> which is suspiciously close to 60fps and such
01:56:41 <LiaoTao> Lokathor: vsync is highly dependent on your environment
01:57:28 <Lokathor> LiaoTao, well I'm guessing that somehow I'm having it applied to my program, because it goes from <1ms per frame when not rendering to almost exactly 16ms per frame when rendering.
01:57:34 <LiaoTao> i.e. compositors/drivers/aliens can force it
01:57:50 <LiaoTao> compositors/drivers/aliens can also break it
01:58:29 <Lokathor> yeah it doesn't work for a lot of video play stuff on this computer/GPU/monitor somehow
01:58:33 <Lokathor> tearing all the time
02:03:23 <Lokathor> neato
02:03:30 <Lokathor> pull request just went though
02:03:45 <Lokathor> you folks will all know a little more about what's going on with GLFW-b in the next release
02:25:10 <halogenandtoast> If I'm using stack with docker enable: true, what the best way to get a postgres instance for it
02:25:34 <halogenandtoast> I was trying with docker-compose but I don't see how to specify the "image" stack creates
02:40:52 <Philonous> halogenandtoast, you want stack image container, it creates a container from the built executable
02:41:30 <Philonous> docker enable just means it builds in a container, it doesn't create one from the result
02:42:49 <halogenandtoast> Philonous: do you happen to have an example of the commands I should run?
02:42:50 <Philonous> Probably you want both, though, because if you build on your own system the library paths might not match 
02:43:48 <cocreature> halogenandtoast: "stack image container" will give you a docker container that contains the executables in your project
02:44:01 <Philonous> halogenandtoast, Sure, first you want to add this to your stack.yaml: https://gist.github.com/Philonous/5209e2670cbca35d454ba29fe770b218
02:44:13 <Philonous> Then you can run stack image container to build the container 
02:45:51 <halogenandtoast> Alright I'll give it a try thanks Philonous / cocreature 
02:53:26 <halogenandtoast> it may or may not have worked, still waiting on building I guess
03:04:00 <ph88^> i'm trying to suppress an exception with this code    dataPart <- EXR.catch (f newSrc) (\_ -> return [])    however the exception need a type signature where can i put that ?
03:09:38 * hackage nonce 1.0.4 - Generate cryptographic nonces.  https://hackage.haskell.org/package/nonce-1.0.4 (ErikDeCastroLopo)
03:11:08 * hackage superbuffer 0.3.1.1 - Efficiently build a bytestring from smaller chunks  https://hackage.haskell.org/package/superbuffer-0.3.1.1 (AlexanderThiemann)
03:24:05 <cocreature> ph88^: enable ScopedTypeVariables and use \(e :: ExceptionType) -> return []
03:33:52 <ph88^> thx
03:36:02 <ph88^> first <- A.takeWhile $ \c -> c /= '=' && c /= '\NUL'    this gives me an error of Char not matching Word8  (parsing bytestrings), why does overloadedstrings not handle this?  which function do i use best here?
03:39:03 <pacak> ph88^: There are two modules - Data.Attoparsec and Data.Attoparsec.Char8
03:39:46 <ph88^> i use  Data.Attoparsec.ByteString.Lazy 
03:40:04 <pacak> ph88^: Try picking Char8 version
03:40:34 <ph88^> i use that one too
03:40:43 <ph88^> ok i will try
03:41:14 <ph88^> ah ye that type check ... but i loose lazyness :(
03:41:36 <pacak> You don't need lazyness
03:42:20 <ph88^> oki ^^
04:01:06 <halogenandtoast> Are there any haskell video series?
04:01:15 <ph88^> hi halogenandtoast 
04:01:30 <halogenandtoast> hey ph88^ 
04:02:52 <ph88^> https://www.youtube.com/results?search_query=haskell+tutorial  ??
04:03:37 <ph88^> anyone know how i could parse this file?  https://bpaste.net/show/3eeee12d6927  the problem is that i don't have a boundary between header and data
04:05:12 <halogenandtoast> ph88^: I was looking for something a little less rudimentary. Like actually building a series or real applications.
04:05:28 <halogenandtoast> If one doesn't exist, perhaps I'll try to make something myself.
04:05:42 <ph88^> there are some tutorials about some libraries
04:05:44 <ph88^> maybe yesod
04:08:00 <halogenandtoast> ph88^: Can you use something like parsec and on failure to parse, parse it as data?
04:08:05 <pacak> ph88^: What exactly is it? What is header and what is data?
04:08:35 <pacak> halogenandtoast: Nobody makes real applications in Haskell :)
04:08:49 <ph88^> pacak, data starts at second \00 on line 22
04:09:11 <ph88^> halogenandtoast, the header parser will happily parse the data as well :(
04:09:36 <ph88^> maybe i should just check if the last header starts with "REMARKS"  ?
04:10:12 <pacak> ph88^: What format is that? Is the header fixed width?
04:10:31 <halogenandtoast> pacak: I tend to make web apps, would love more examples of web apps in haskell (twitter clone, todo list, reddit clone, etc.)
04:10:36 <halogenandtoast> Things I'd normally write in rails.
04:10:59 <ph88^> don't know the official format .. just have this file, headers are not fixed width ... the format is similar to http i think
04:11:02 <halogenandtoast> I wonder if a web series making those types of apps would be well received.
04:11:14 <ph88^> halogenandtoast, https://github.com/shapr/sporkle
04:11:24 <halogenandtoast> ph88^: in http \n\n seperates headers and the body
04:11:43 <ph88^> yeah well i don't have such a separator :P
04:12:05 <halogenandtoast> ph88^: The file has to have some defined format, or it's not a format :p
04:12:23 <ph88^> :D
04:12:36 <halogenandtoast> Otherwise, garbage in, garbage out
04:13:47 <pacak> ph88^:  Щ O_o
04:13:53 <pacak> ☭
04:14:19 <halogenandtoast> I did not realize ☭ was in UTF8
04:15:02 <pacak> > let (☭) = (+) in 1 ☭ 2
04:15:04 <lambdabot>  3
04:15:40 <halogenandtoast> I don't understand that line either
04:15:47 <pacak> > let (━☆.*･｡) = (+) in 2 ━☆.*･｡ 1
04:15:48 <lambdabot>  3
04:15:50 <halogenandtoast> How does it get 3?
04:16:09 <pacak> halogenandtoast: That's what you get when you apply ☭ to 1 and 2.
04:16:18 <halogenandtoast> oh
04:16:21 <halogenandtoast> herp derp
04:16:22 <pacak> And (☭) is (+) case
04:16:25 <halogenandtoast> right
04:16:55 <pacak> Ghc is really flexible to what operator names you can use.
04:17:03 <pacak> Just don't use them.
04:17:16 <halogenandtoast> right
04:17:41 <halogenandtoast> let ((╯°□°）╯︵ ┻━┻) = (+) in 1 (╯°□°）╯︵ ┻━┻ 2
04:17:45 <halogenandtoast> > let ((╯°□°）╯︵ ┻━┻) = (+) in 1 (╯°□°）╯︵ ┻━┻ 2
04:17:47 <lambdabot>  <hint>:1:11: error: lexical error at character '\65289'
04:17:55 <halogenandtoast> (╯°□°）╯︵ ┻━┻
04:18:27 <halogenandtoast> guess the name can't have ) in it
04:18:44 <halogenandtoast> > let (ಥ,_｣ಥ) = (+) in 1 ಥ,_｣ಥ 2
04:18:45 <lambdabot>  <hint>:1:9: error: lexical error at character '\65379'
04:19:12 <halogenandtoast> alright enough of that.
04:23:30 <pacak> There are limitations. You can't use letters in operators.
04:24:34 <michi7x7> > let (¬‿¬) = (flip const) in 1 ¬‿¬ 2
04:24:36 <lambdabot>  2
04:25:55 <ph88^> halogenandtoast, http://www.haskellcast.com/
04:26:58 <halogenandtoast> ph88^: That's just a podcast though
04:27:02 <halogenandtoast> neat though
04:27:49 <ph88^> halogenandtoast, https://www.youtube.com/channel/UCQMkHY8U6B9tefTQdPkpY7A
04:29:42 <halogenandtoast> ph88^: yeah I came across that one, seems like it's the closest to what I've wanted.
04:29:51 <ph88^> so how could i check if i'm parsing that "REMARKS" part ?
04:30:30 <ph88^> this is how my parsing function looks like now   https://bpaste.net/show/46d04e9ed944
04:35:56 <halogenandtoast> ph88^: is the | significant at all
04:36:17 <ph88^> which |  ?
04:36:26 <halogenandtoast> towards the end of remarks
04:36:44 <halogenandtoast> In your example data.
04:38:02 <ph88^> it's just part of the data
04:38:09 <ph88^> it's binary
04:38:38 <Gurkenglas> ph88^, http://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:try says try is superfluous
04:39:12 <halogenandtoast> ph88^: is the start of data and # of data points significant
04:39:45 <ph88^> halogenandtoast, don't think so
04:40:08 <Gurkenglas> ph88^, hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:manyTill looks like it can condense lines 8-10
04:40:09 <ph88^> Gurkenglas, my header parser will succeed on parsing the data too :(
04:40:14 <halogenandtoast> I wonder if the remarks is actually empty and that strea is just data.
04:40:22 <halogenandtoast> *stream
04:41:14 <Gurkenglas> ph88^, try can be removed anyway, it just says "try p = p"
04:41:14 <ph88^> remarks are a few empty lines
04:41:43 <ph88^> remarks ends with a null byte, after the first null byte the data starts immediately
04:43:50 <Gurkenglas> ph88^, wouldn't sepBy in line 3 remove the \NULs?
04:44:44 <ph88^> yes the NULs that are used for separating the headers
04:45:02 <ph88^> don't think it consumes a final NUL
04:46:12 <Gurkenglas> Then perhaps consider using many on manyTill in order to consume all the \NULs in line 3
04:47:04 <et09> what's a practical example of why someone would use list monad
04:48:19 <c_wraith> et09: https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet
04:48:35 <c_wraith> et09: that's an example of stateful backtracking search
04:49:12 <c_wraith> et09: obviously it uses more pieces than just [], but it does require it.
04:49:30 <et09> oof i gotta study StateT
04:51:51 <et09> State/StateT that is
04:54:08 * hackage universum 0.4.3 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-0.4.3 (shersh)
04:57:52 <et09> oh wow.  so you could probably use this for something like DFS or A* right
04:59:06 <c_wraith> It will always be a DFS ordering.
04:59:22 <Gurkenglas> See SearchT.
05:00:06 <et09> woow.  this language
05:03:51 <vaibhavsagar> et09: list comprehensions
05:04:51 <et09> ah.. i didn't realize those were monadic
05:15:38 * hackage fltkhs 0.5.2.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.2.0 (deech)
05:22:28 <Eduard_Munteanu> et09, actually you can use comprehension syntax for all monads now
05:35:23 <osfameron> do you have to enable that?
05:36:23 <osfameron> and does the syntax look good for monads other than list?
05:36:34 <lyxia> yes MonadComprehensions https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#monad-comprehensions
05:38:11 <osfameron> the example in that for Maybe monad isn't especially compelling, but presumably it's nice in other cases?
05:39:17 <lyxia> ah, I don't know. I find do notation just fine.
05:39:49 <c_wraith> osfameron: it makes stringing together several functions that all return Maybe values a lot more pleasant.
05:48:48 <dominik_> hi, after a while I've been trying to compile a haskell snippet again (rather than interpreting it interactively in ghci). However, when running `ghc Foo.hs`, all that is created is an .o file, but no executable
05:48:55 <dominik_> anyone knows why this is?
05:49:03 <dominik_> am I maybe missing the linker?
05:51:25 <liste> dominik_: does your program have a main function?
05:51:32 <dominik_> liste: yes
05:51:53 <dominik_> basically it is organized like this: I have a Foo.hs and a Foo/ folder that includes a couple more haskell modules
05:52:02 <dominik_> and Foo.hs contains the main :: IO () function
05:52:07 <ongy> do you have any compile errors?
05:52:11 <dominik_> nope
05:52:23 <liste> is there a .hi file?
05:52:31 <dominik_> I just don't get any executable, all I get is a Foo.o and a Foo.hi
05:52:33 <dominik_> liste: yes
05:53:25 <dominik_> maybe I'm indeed missing the system linker...
05:53:55 <liste> "If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the Main module, and GHC will examine the import declarations to find the other modules that make up the program and find their source files." -- https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/using-ghc.html#idp34450864 
05:54:00 <liste> --https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/using.html#getting-started-compiling-programs
05:55:23 <liste> so Foo.hs has `main`, and imports other files in Foo/ ?
05:55:37 <dominik_> liste: yes, exactly
05:56:43 <dominik_> and the compilation then tells me: [2 of 2] Compiling Foo              ( Foo.hs, Foo.o )
05:56:47 <dominik_> without any errors
05:56:52 <dominik_> but it is not linking anything
05:57:18 <dominik_> does anyone know the package for the system linker/loader on Debian GNU/Linux, since I might be missing that one...
05:58:32 <ongy> dominik_: usually gcc but I'd bet the ghc package depends on it
05:58:58 <ongy> just check if 'ld' exists
05:59:39 <hexagoxel> dominik_: do you say "module Foo where .." in your Foo.hs?
05:59:51 <dominik_> hmm, no, binutils is installed.
06:00:08 <hanna> I'm still struggling to interface between Haskell and C++, and once again the issue is figuring out how to marshal a std::string into a haskell string. Is there any solution that doesn't involve making assumptions about the string's length?
06:00:30 <glguy> dominik_: You need a "Main" module
06:00:33 <dominik_> hexagoxel: yes
06:00:42 <dominik_> glguy: ohh, I don't have that one
06:00:44 <hexagoxel> dominik_: then what glguy says.
06:00:45 <glguy> dominik_: If Foo.hs has main defined, then change the top to "module Main where"
06:00:59 <dominik_> ohh, ok.
06:01:02 <dominik_> thanks!
06:03:16 <cocreature> hanna: I think I already told you my approach but I forgot why it doesn’t work for you so here it is again: 1. pass a char** to the c++ code. 2. make the c++ code strdup the string and write it to that pointer. 3. marshal the string on the Haskell side. 4. free the string from the Haskell code
06:03:37 <hanna> cocreature: it's in my question: “Is there any solution that doesn't involve making assumptions about the string's length?”
06:03:53 <cocreature> hanna: where do you see any assumption about the length of the string here?
06:04:12 <hanna> wait; you want me to allocate bytes in haskell and have the C++ code copy bytes to it, right?
06:04:17 <hanna> copy the string to it*
06:04:19 <cocreature> no
06:04:21 <hanna> huh
06:04:24 <cocreature> strdup does the allocation
06:04:29 <hanna> I don't understand
06:04:43 <hanna> strdup just copies from one char* to another char*?
06:04:44 <hexagoxel> cocreature: 3. does seem to involve a length, somehow.
06:05:33 <dominik_> ok, interesting, after renaming Foo.hs to Main.hs and changing it to "module Main where", ghc links the program
06:05:49 <cocreature> hanna: no it calls malloc to allocate space and then copies the string there
06:06:04 <dominik_> however, I'm wondering, is there no way to keep my main Module named Foo.hs?
06:06:21 <cocreature> hexagoxel: right, but you don’t need to assume some maximum length which I think is what hanna is asking for
06:06:22 <hanna> Oh, okay. So `free` must be called from Haskell afterwards?
06:06:30 <hanna> Makes sense, and seems like it solves my problem
06:06:37 <c_wraith> dominik_: not according to the haskell standard, but ghc provides flags to change it.
06:06:38 <cocreature> hanna: that’s step 4 :)
06:07:02 <glguy> dominik_: Yes, you can name your main module Foo.hs
06:07:12 <hexagoxel> cocreature: ah, true, i read the question differently.
06:07:15 <glguy> The filename can be Foo.hs, the module name needs to be Main
06:09:05 <osfameron> c_wraith: ah ok.  I guess it's nice to have the choice
06:10:11 <dominik_> glguy, c_wraith: ok, thanks! Let me try this.
06:11:38 * hackage fltkhs 0.5.2.1 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.2.1 (deech)
06:12:35 <hanna> cocreature: thanks, this works :)
06:12:40 <hanna> I must have misunderstood your approach the last time
06:13:53 <dominik_> hmm, interestingly compiling my main module Foo.hs with "module Main where" with `ghc Foo.hs` gives me the following linking error:
06:14:03 <cocreature> hanna: note that if you strdup .data() instead of .c_str() the string might not be null terminated so you need to return the length to your Haskell code and use that for marshalling
06:14:27 <dominik_> /usr/bin/ld: cannot open output file Foo: Is a directory
06:14:29 <dominik_> collect2: error: ld returned 1 exit status
06:14:30 <glguy> If the string isn't null-terminated, strdup would be illadvised
06:14:31 <dominik_> `gcc' failed in phase `Linker'. (Exit code: 1)
06:14:39 <cocreature> glguy: oh good point :)
06:14:47 <glguy> dominik_: GHC is trying to write the executable Foo
06:15:01 <cocreature> I guess you can always manually malloc + memcpy in that case
06:15:02 <glguy> dominik_: So you shouldn't have a directory named Foo
06:15:08 <dominik_> hehe :D
06:15:26 <dominik_> ok, good point, thanks :->
06:16:08 * hackage jose 0.6.0.2 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.6.0.2 (frasertweedale)
06:18:08 * hackage jose 0.5.0.4 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.5.0.4 (frasertweedale)
06:19:31 <hanna> cocreature: https://github.com/haasn/hsbooru/commit/16cbf19b2a6fbbe87b9b16d815cdb43c266bf071 did it like this, I suppose that's fair?
06:19:36 <hanna> seems to work
06:19:38 * hackage jose 0.4.0.4 - Javascript Object Signing and Encryption and JSON Web Token library  https://hackage.haskell.org/package/jose-0.4.0.4 (frasertweedale)
06:19:46 <cocreature> hackage: yeah looks fine
06:34:51 <Gurkenglas> A guy on stackoverflow is asking for how Ord (a, b) is implemented. Good question. I find a deriving clause at best. Is there a way to look up further desugared source online?
06:35:20 <c_wraith> you can just pass -ddump-deriv to ghc
06:35:29 <c_wraith> but the short answer is "lexicographic"
06:36:01 <c_wraith> whenever you derive Ord on a product, it uses lexicographic order in the order the fields are written in the constructor.
06:36:09 <Gurkenglas> The question isn't good because the behavior is complicated, but because one has to ask the question.
06:37:44 <Gurkenglas> I'd have trouble going from "pass -ddump-deriv to ghc" to seeing the implementation of that source. It also seems dependent on system/installation.
06:39:21 <cocreature> so is your point that using deriving makes it harder to find the source? I don’t think anybody is going to argue with that
06:40:19 <Gurkenglas> The ideal solution would be to add to that newfangled haddock links thing the feature that clicking on a deriving clause shows you the resulting code
06:40:42 <c_wraith> the thing is, the code never really exists
06:42:43 <Gurkenglas> You mean, -ddump-deriv's output isn't uniquely determined by the haddock page that shows the deriving clause?
06:43:58 <[exa]> Is there any simple example of StateM usage for doing some CPU-intensive computation?
06:44:15 <[exa]> (kindof looking for ideas)
06:45:00 <Gurkenglas> You mean StateT? something like "execState (replicateM_ (10^9) $ modify (+1)) 0"?
06:45:20 <Velizar> Is there a shorter way to write `map fst $ filter (f . snd) myTupleList`
06:46:16 <Gurkenglas> Depends on where the tuples come from
06:46:34 <Velizar> I could also shape myTupleList in a different way, e.g. [fst', snd'] instead of (fst', snd')
06:46:59 <Velizar> It comes from this expression, notice the part before | `[((i, j), cell) |  (i, row) <- zip [1..] worldList, (j, cell) <- zip [1..] row]`
06:47:40 <[exa]> Gurkenglas: not exactly, I'm more like searching for some useful/simple/standard-ish algorithm that would be a good case for being implemented using StateM
06:48:07 <Velizar> (by 'before', I mean 'to the left of')
06:48:22 <Gurkenglas> [(i, j) | (i, row) <- zip [1..] worldList, (j, cell) <- zip [1..] row, f cell]
06:49:32 <Velizar> Ahh. I forgot about that :P thanks
06:50:33 <Velizar> Ahh. I forgot about that :P thanks
06:50:35 <Velizar> oops 
07:35:08 * hackage fltkhs 0.5.2.2 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.2.2 (deech)
07:44:15 <hanna> oops: changing ghc-options and re-running `cabal build` does not implicitly `cabal clean`
08:22:38 * hackage jenkinsPlugins2nix 0.2.0.0 - Generate nix for Jenkins plugins.  https://hackage.haskell.org/package/jenkinsPlugins2nix-0.2.0.0 (MateuszKowalczyk)
08:26:38 * hackage jenkinsPlugins2nix 0.2.0.1 - Generate nix for Jenkins plugins.  https://hackage.haskell.org/package/jenkinsPlugins2nix-0.2.0.1 (MateuszKowalczyk)
08:35:24 <portnov> hi all
08:36:47 <anemecek> when i run stack install i get a message that says " No module named "Main". The 'main-is' source file should usually have a header indicating that it's a 'Main' module." 
08:36:54 <anemecek> however everything is setup correctly
08:36:54 <portnov> I have a type LogFormat = [LogItem]
08:36:54 <portnov> and an instance IsString LogFormat where...
08:36:54 <portnov> GHC 8 complains about overlapping instances: https://paste.in.ua/2763/
08:37:05 <portnov> any ideas why it thinks the first instance matches?
08:38:08 * hackage spake2 0.1.0 - Implementation of the SPAKE2 Password-Authenticated Key Exchange algorithm  https://hackage.haskell.org/package/spake2-0.1.0 (jml)
08:38:38 <cocreature> portnov: how is LogFormat defined?
08:38:43 <Gurkenglas> portnov, the part before the => is ignored when deciding whether to apply an instance
08:38:56 <portnov> cocreature: type LogFormat = [LogItem]
08:39:01 <portnov> Gurkenglas: it is sad :(
08:39:21 <cocreature> right, then Gurkenglas already told you the problem
08:39:25 <lyxia> anemecek: what is your main-is file
08:39:35 <anemecek> Main.hs
08:39:44 <Gurkenglas> cocreature, is there ever another problem?
08:39:47 <portnov> cocreature: is it considered as a bug or as a feature?
08:40:37 <cocreature> Gurkenglas: I guess not but if LogFormat was not just a type synonym for a list you wouldn’t run into this problem in the first place
08:40:44 <anemecek> so actually maybe i'm approaching it wrong. i'm using "haskell for mac" (the ide) and i'm trying to install this https://hackage.haskell.org/package/music-suite
08:40:56 <cocreature> portnov: I wouldn’t call it a feature but “it’s working as intended”
08:41:10 <Gurkenglas> portnov, afaik it gurantees that type inference terminates
08:41:25 <portnov> aha
08:41:27 <portnov> ok
08:41:44 <portnov> then what i need is probably a newtype LogFormat = LogFormat [LogItem]
08:41:54 <anemecek> but it's been a pain, i've spent maybe 3-4 hours dealing with the dependencies
08:42:11 <Gurkenglas> anemecek, have you tried stack?
08:42:15 <anemecek> i'm using stack
08:42:56 <anemecek> if i understand it correctly stack uses only "stable" packages
08:43:12 <ph88^> Gurkenglas, i made this parser now but it looks ugly, what you think ? https://bpaste.net/show/d9936925198b
08:43:24 <anemecek> or like it seems like it's supposed to be a breeze with stable packages but it seems like adding externals is still a pain
08:45:07 <anemecek> this is the current project before i added the dependencies
08:45:07 <Gurkenglas> ph88^, why not lpaste? (no need to repaste now.) 3-5 look like they can be replaced by many $ flip manyTill (A.char '\NUL') headerParser, allowing you to inline headerParser's definition
08:45:09 <lyxia> anemecek: the error you get doesn't seem to be about dependencies though
08:45:09 <anemecek> https://github.com/adamnemecek/Haskell
08:45:27 <Gurkenglas> many1, I mean
08:45:53 <anemecek> lyxia: it's a smaller problem in the context of a bigger problem
08:46:08 <anemecek> the bigger problem being me being unable to figure out how to install packages
08:46:11 <anemecek> so like
08:46:27 <anemecek> i brought it up because i don't know if this is even the problem i'm supposed to be solving
08:47:10 <ph88^> Gurkenglas, lpaste doesn't have timeout on my paste
08:48:30 <Gurkenglas> Why is that bad? This channel is publically logged anyway.
08:48:33 <lyxia> anemecek: to add external dependencies: add them in .cabal, add them in stack.yaml
08:48:44 <lyxia> anemecek: under extra-deps
08:49:00 <anemecek> i've previously done that and got stuck with the main.hs message
08:49:22 <anemecek> why do i need to add them both to cabal and stack
08:49:29 <ph88^> Gurkenglas, i don't paste for publication, just as an aid in chat
08:50:27 <hvr> anemecek: because stack doesn't use the solver
08:51:00 <hvr> anemecek: so it expects you to pin down every single dependency to a specific version compatible with the inter-package version constraints
08:51:45 <anemecek> ok. that helps. so what should i do about the main.hs message?
08:53:48 <hvr> anemecek: I don't use Stack, but I just tried w/ cabal, and it just worked 
08:54:06 <hvr> (i.e. I cloned https://github.com/adamnemecek/Haskell and ran 'cabal new-build' in it)
08:54:39 * hackage hops 0.7.1 - Handy Operations on Power Series  https://hackage.haskell.org/package/hops-0.7.1 (AndersClaesson)
08:59:06 <anemecek> hvr: ok it builds with cabal
08:59:15 <anemecek> so what's the best way of installing that package i need now?
08:59:18 <anemecek> add it to the cabal file?
08:59:42 <anemecek> when i do cabal install music-suite
08:59:47 <anemecek> it can't find the package
08:59:57 <anemecek> its using the package list lts-6.29
09:00:14 <hvr> the build-deps in the .cabal file is like an "import" statement for packages
09:00:30 <hvr> it brings them into scope, so you can access them
09:00:48 <anemecek> so i specify the location using the github url?
09:01:20 <hvr> is the hackage version good enough?
09:01:30 <hvr> if so, no need to refer to github repos
09:01:32 <anemecek> sure
09:01:45 <anemecek> oh i specify the hackage url?
09:02:03 <hvr> nope, just 'music-site == 1.9.*' or something like that
09:02:23 <hvr> which ghc version do you use?
09:02:43 <anemecek> 7.10 
09:02:50 <anemecek> it's the one that comes with "haskell for mac"
09:05:24 <Welkin> upgrade to 8.0.2
09:05:35 <hvr> Welkin: if he does,he won't be able to use music-site
09:07:25 <hvr> sorry, music-suite
09:07:33 <anemecek> hvr: cabal: At least the following dependencies are missing:
09:07:34 <anemecek> music-suite ==1.9.*
09:08:13 <hvr> anemecek: I'm trying locally if I can get it to even build; music-suite has a rather big install-plan
09:08:21 <anemecek> it does
09:08:58 <anemecek> i was able to install other things before and they somewhat worked out but ive been banging my head against this
09:09:42 <anemecek> thanks so much for helping me btw
09:13:31 <sherub> 21:11:03     sherub | hi there I was trying to use parsec, to parse strings like "name:curry", "curry", "name:\"Haskell curry\"" to some ADT and was wondering about a good way to do this. Can      ??? averell
09:13:33 <sherub>                       ???                    | anyone help me out?                                                                                                                                                            ??? Axman6
09:13:35 <sherub>                       ???21:13:18     sherub | I wan to use these with `and` `or` keywords                                                                                                                                    ??? Bane^
09:13:37 <sherub>                       ???21:14:18     sherub | but unsure how not to make  `string` parser combinator that will parse any string but will not pick up `and` `or`.                                                             ??? banseljaj
09:13:39 <sherub>                       ???21:14:40     sherub | I thought making them reserved would do the trick but that is not happening.
09:14:32 <anemecek> hvr: does "build-type: Simple" matter?
09:15:07 <sherub> hmm...Copy/paste in IRC clients is not straight forwared. apologies
09:15:08 <hvr> anemecek: yeah, you should set it
09:15:20 <hvr> anemecek: and 'simple' is usually the one you want most of the time
09:15:20 <anemecek> to what
09:15:41 <anemecek> it doesn't work with it or without it. still "at least one of the following dependencies are missing"
09:15:55 <anemecek> i dont understand why it's not seeing the package
09:16:07 <hvr> well, the problem now is trying to get 'music-suite' built
09:16:37 <hvr> and I haven't yet been able to do that locally, as I run into compile failures
09:17:15 <anemecek> so the thing that makes music-suite different is the complex build plan?
09:17:57 <hvr> mostly, yeah; 'music-suite' is actually a big framework of packages
09:18:21 <rach> dc
09:19:02 <anemecek> hvr: yeah it is. would it make a difference to include them one by one?
09:19:34 <hvr> anemecek: if you know you need only a few of those, it would increase the chance to get a working subset; right now I'm looking at why lilypond fails
09:20:02 <anemecek> thanks so much. maybe i should contact the author
09:21:16 <hvr> the last release dates back to 2015; which somewhat predates GHC 7.10.3
09:21:39 <anemecek> has much changed?
09:22:11 <hvr> the problem is that each new major GHC version breaks a couple of packages
09:22:47 <hvr> and especially from GHC 7.8 -> GHC 7.10 there were big changes
09:24:45 <anemecek> are these like source level changes?
09:24:56 <hvr> API level changes
09:25:09 <anemecek> the compiler should point these out no?
09:25:25 <hvr> yeah, it does so... by giving you a compile error :)
09:25:42 <anemecek> right so it that was the problem it should give me a compiler error no?
09:30:03 <iqubic> Hello folks.
09:30:17 <ongy> Hi
09:37:49 <anemecek> hvr: any success?
09:41:39 <ews> Hello everyone, is there any way to configure GHCI so that it would execute `main` from the loaded file automatically? So that it would work same as runhaskell but stay in the interpreter.
09:42:53 <Gurkenglas> ews, https://downloads.haskell.org/~ghc/7.2.2/docs/html/users_guide/ghci-dot-files.html
09:46:16 <Gurkenglas> Why doesn't "stack install" failing outside of a project because of missing extra-deps not recommend "stack unpack" first so "stack solver" will work?
09:48:13 <iqubic> Gurkenglas: I wish I knew.
09:48:19 <Gurkenglas> Or, stepping back: How should I get into a position to run http://hackage.haskell.org/package/SourceGraph on arbitrary projects? (found on the wiki under static analysis tools)
09:49:08 * hackage fltkhs 0.5.2.3 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.2.3 (deech)
10:11:08 * hackage jenkinsPlugins2nix 0.2.0.2 - Generate nix for Jenkins plugins.  https://hackage.haskell.org/package/jenkinsPlugins2nix-0.2.0.2 (MateuszKowalczyk)
10:14:38 * hackage crjdt-haskell 0.3.0 - A Conflict-Free Replicated JSON Datatype for Haskell  https://hackage.haskell.org/package/crjdt-haskell-0.3.0 (amarpotghan)
10:15:08 <orion> http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/ <-- "Streams are Monads, thus playing a big part in bringing functional programming to Java"
10:15:13 <orion> Is this an accurate statement?
10:16:22 <Welkin> java can never be functional
10:16:27 <Welkin> it doesn't have first class functions
10:17:08 * hackage streaming-binary 0.1.0.0 - Streaming interface to binary.  https://hackage.haskell.org/package/streaming-binary-0.1.0.0 (MathieuBoespflug)
10:17:28 <liste> Welkin: it does. they're objects, but they really do the same thing
10:17:43 <liste> and it has anonymous functions now too
10:18:21 <liste> orion: well, there's Stream.of (unit), Stream.flatMap (bind), and they seem to satisfy the jobs
10:18:38 <liste> laws*
10:18:39 <liste> not jobs
10:19:18 <Welkin> by unit you mean pure?
10:19:23 <liste> Welkin: yes
10:20:32 <orion> flatMap seems to be equivalent to concatMap.
10:20:35 <liste> yes
10:20:44 <liste> which is >>= for lists
10:20:46 <Welkin> concatMAp is bind lol
10:20:56 <Welkin> not as general bind
10:21:12 <Welkin> :t (=<<)
10:21:13 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:21:15 <Welkin> :t concatMap
10:21:16 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
10:22:22 <liste> Java lacks type classes and higher kinded types, so it's impossible to generalize a Monad type class in Java, but there can be specific types that are monads
10:22:40 <liste> it's way less useful without the generalization though
10:23:28 <Welkin> so the closest you can get is something like Elm (which sucks)
10:25:49 <liste> you can kinda make a Monoid type class though
10:26:16 <liste> but it's wieldy to use, you need to pass the dictionary around
10:26:59 <Welkin> which you can do with any language though
10:27:06 <Welkin> pass around arbitrary data
10:27:21 <Welkin> it's just a lot of boilerplate
10:27:25 <liste> yes
10:35:38 * hackage concrete-haskell 0.1.0.5 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.5 (TomLippincott)
10:40:32 <EvanR> Welkin: monoid in C...
10:40:44 <EvanR> which doesnt support closures
10:41:15 <EvanR> dictionary of functions is like a hairshirt
10:42:04 <liste> just add an extra void* parameter to each function :o)
10:42:21 <Welkin> that's a function pointer though
10:44:08 * hackage concrete-haskell 0.1.0.6 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.6 (TomLippincott)
10:46:55 <ews> Hello everyone, is there any way to configure GHCI so that it would execute `main` from the loaded file automatically? So that it would work same as runhaskell but stay in the interpreter.
10:47:10 <ews> I have the following code in the file IO of my program: https://pastebin.com/PxU98M1n . Is there any way I can simplify it (note that last 2 lines are read into a list of ints, whereas first line is read into an int).
10:47:42 <Gurkenglas> "sourcegraph: user error (The program 'ghc' version >=6.4 is required but it could not be found.)" <- How do I make stack give it access to the ghc version it wants?
10:49:38 <hexagoxel> ews: I would guess that the ghci thing is not directly possible. however, you can define a macro that reloads and runs main, in one command.
10:50:08 <hodapp> at a certain point, "can do in any language" really just means "you can use (almost) any language to implement a different language"
10:50:09 <Gurkenglas> ews, see the .ghci manual page I sent you above. You can define hReadLine :: Read a => Handle -> IO a as hReadLine handle = fmap read (hGetLine handle).
10:51:29 <Gurkenglas> hReadLn, I mean, to keep the naming Prelude establishes with readLn
10:51:34 <hexagoxel> Gurkenglas: when i put "main" into the dotfile, it does not work in the desired way though. am i missing something?
10:51:58 <Gurkenglas> Huh. I never tried it, I was just pointed at .ghci myself when I asked a similar question.
10:53:00 <geekosaur> what is "the desired thing" here?
10:53:09 <hexagoxel> Gurkenglas: ah, ok.
10:53:10 <ews> I tried putting main into .ghci but I believe .ghci is loaded before the file we're loading
10:53:28 <geekosaur> likely yes,
10:53:47 <hexagoxel> geekosaur: a behaviour resembling entering ":main\n" manually
10:54:04 <ews> As for my 2nd question: is there any way I could simplify this:     startingStates <- (hReadList handle)    acceptingStates <- (hReadList handle) ?
10:54:19 <hexagoxel> ews: the macro could look like    :def relmain \_ -> return $ ":r\n:main"
10:54:24 <geekosaur> you could put that into .ghci ... but if the source file isnt loaded yet then it won't help
10:54:32 <hexagoxel> then you can enter ":relmain" in .ghci
10:54:52 <hexagoxel> s/in .ghci/in the running ghci session/
10:54:53 <hexagoxel> sorry
10:55:24 <MarcelineVQ> ews: yes, but it'd be better if your provided more context, like where handle is coming from or other relevant things
10:55:33 <ews> Yes but it will have the same effect as running :main
10:56:23 <ews> MarcelineVQ, handle is just a handle to a file with integer the first line, then 2 lines with integer lists and remaining lines in some given format
10:58:35 <MarcelineVQ> Ah I was too vague, what I meant was it would be better to post more complete code so that people can see what can be simplified. One or two lines can only get so pretty, but someone might know a way to not need to write the lines at all when seeing the whole picture
10:58:36 <Gurkenglas> ews, it's hReadLine or hReadLn, not hReadList - one definition works for both a and [a], just like read
10:59:26 <fresheyeball> is there a type level operator for tuple and either?
10:59:36 <fresheyeball> I feel like this code would be more clean if there was
10:59:51 <fresheyeball> they don't visually look related with default notation
11:00:45 <doyougnu> fresheyeball: like this? :k (,)
11:00:59 <Welkin> can't you create your own?
11:01:26 <doyougnu> :k (,)
11:01:28 <lambdabot> * -> * -> *
11:02:11 <EvanR> type level tuple of types
11:02:18 <iqubic> :k Either
11:02:19 <lambdabot> * -> * -> *
11:02:30 <EvanR> :k 'Either
11:02:31 <lambdabot> error:
11:02:32 <lambdabot>     Not in scope: data constructor ‘Either’
11:02:32 <lambdabot>     Perhaps you meant variable ‘either’ (imported from Data.Either)
11:02:32 <iqubic> fresheyeball: What do you want?
11:03:07 <fresheyeball> I want my code to look slightly cleaner
11:03:15 <fresheyeball> so that its clear that (x,y) is a product
11:03:21 <fresheyeball> and Either x y is a sum
11:03:25 <fresheyeball> and they have this relation
11:03:30 <fresheyeball> I know I could make my own
11:03:37 <iqubic> Oh, yeah.
11:03:38 <fresheyeball> but surely this is out there already
11:04:21 <doyougnu> Why is it not clear that (a,b) is a product? Are you looking for something like: a X b?
11:04:22 <EvanR> x :×: x
11:04:29 <EvanR> clean!
11:04:33 <doyougnu> ^^
11:04:43 <EvanR> and kind of confusing
11:05:05 <EvanR> x :+: x
11:05:48 <EvanR> fresheyeball: maybe you want agda, it has nice unicode everything everywhere
11:06:26 <fresheyeball> Yeah!
11:06:32 <fresheyeball> EvanR: where are those?
11:06:43 <fresheyeball> :x: looks like it would make this code more clear
11:06:48 <fresheyeball> (ironically I know)
11:08:02 <EvanR> i wrote ×
11:08:10 <EvanR> agda is a different programming language
11:08:24 <EvanR> but you can define the above in haskell
11:12:05 <athan> If I had a Record of data in a TVar, and a large lens to mutate it, would a `modifyTVar` transaction take a longer time than an equivalent read-only record of TVars to lens into?
11:13:16 <doyougnu> fresheyeball: you'll need to use the TypeOperators extension, here's a good primer: https://ocharles.org.uk/blog/posts/2014-12-08-type-operators.html
11:13:42 <athan> `TVar (LargeRecord SomeData) & modifyTVar fooLens` vs. `LargeRecord (TVar SomeData) & modifyTVar =<< get fooLens`
11:13:51 <EvanR> athan: seems like splitting hairs... but could be measured
11:14:06 <athan> EvanR: I feel like it would help blocking
11:14:12 <athan> to use the latter
11:14:51 <athan> like a bunch of concurrent threads that access different parts of the record at the same time
11:15:36 <Cale> athan: That may be the case, if that's the situation you're in.
11:18:12 <Cale> This is the sort of question where you kind of just need to try it both ways if you really want to know. There's overhead associated with TVars as well, and the garbage collector performs a lot better with less mutable data around, usually these factors don't play a large role, but when balanced against something similarly small, it's hard to know off-hand.
11:28:57 <Gurkenglas> "sourcegraph: user error (The program 'ghc' version >=6.4 is required but it could not be found.)" <- How do I make stack give it access to the ghc version it wants?
11:30:01 <ph88^> hello
11:30:02 <kadoban> Gurkenglas: Probably add the directory in stack's guts to your path
11:30:16 <kadoban> Or maybe stack exec, I dunno if that gives you a ghc on path
11:32:15 <geekosaur> it should
11:37:08 * hackage streaming-binary 0.2.0.0 - Streaming interface to binary.  https://hackage.haskell.org/package/streaming-binary-0.2.0.0 (MathieuBoespflug)
11:38:01 <ews> I would like to aply 'any isNothing' to a list of Maybies with  varying underlying types (Int, [Int]). Is there any way to do it?
11:39:43 <Velizar> Is it possible to assign the whole thing while pattern matching? Like this: f (x, y)@xyTuple = ()
11:40:14 <Tuplanolla> Just swap around the `@`, Velizar.
11:40:18 <cocreature> Velizar: yes, use "f xyTuple@(x,y) = ()"
11:40:29 <Velizar> neat
11:40:37 <Tuplanolla> It works anywhere in a pattern.
11:41:07 <cocreature> ews: you can’t make a list of think with different types so no that’s not possible. you can however construct a list of booleans by calling isNothing when you add things to the list and then use "or" instead of "any"
11:41:33 <cocreature> ews: also note that since haskell is lazy, you are still not doing unnecessary work that way
11:46:13 <Gurkenglas> ews, if that's in order to handle malformed input, you could work in the Maybe monad instead (or even Either)
11:47:22 <Gurkenglas> foo :: (Maybe Int, Maybe [Int]) -> Maybe (Int, [Int]); foo (mx, my) = do x <- mx; y <- my; return (x, y)
11:48:11 <Gurkenglas> If you're acquiring the values through IO, you can even use MaybeT to short-circuit once something fails
11:48:58 <Gurkenglas> foo :: (IO (Maybe Int), IO (Maybe [Int])) -> IO (Maybe (Int, [Int])); foo (mx, my) = runMaybeT $ do x <- MaybeT mx; y <- MaybeT my; return (x, y)
11:49:15 <Gurkenglas> (Either would here become ExceptT)
11:54:06 <Gurkenglas> (If your do block ends up looking as trivial as my example, consider applicative style: foo (mx, my) = runMaybeT $ (,) <$> MaybeT mx <*> MaybeT my)
11:56:33 <iqubic> :t Print
11:56:35 <lambdabot> error:
11:56:35 <lambdabot>     • Data constructor not in scope: Print
11:56:35 <lambdabot>     • Perhaps you meant variable ‘print’ (imported from Prelude)
11:56:38 <iqubic> :t print
11:56:39 <lambdabot> Show a => a -> IO ()
11:57:02 <iqubic> Do Strings derive Show?
11:57:13 <Gurkenglas> :t show "asd"
11:57:14 <lambdabot> String
11:57:16 <Gurkenglas> > show "asd"
11:57:18 <lambdabot>  "\"asd\""
11:57:38 <Gurkenglas> @instances Show
11:57:40 <lambdabot> (), (Data.Fixed.Fixed a), (Seq.Seq a), (Seq.ViewL a), (Seq.ViewR a), (Shrink2 a), (a, b), (a, b, c), All, AllocationLimitExceeded, Any, ArithException, Array a b, ArrayException, AssertionFailed,
11:57:40 <lambdabot> AsyncException, BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, Bool, Char, Complex a, Const a b, Constr, ConstrRep, DataRep, DataType, Deadlock, DefName, Double, Down a, Dual a, Dynamic,
11:57:42 <lambdabot> Either a b, ErrorCall, First a, Fixity, Float, GeneralCategory, IO a, IOException, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Last a, Level i a, MaskingState, Maybe a,
11:57:44 <lambdabot> NestedAtomically, NoMethodError, NonEmptyList a, NonNegative a, NonTermination, NonZero a, OrderedList a, Ordering, PatternMatchFail, Positive a, Product a, Ratio a, RecConError, RecSelError,
11:57:46 <lambdabot> RecUpdError, Shrinking s a, Small a, Smart a, SomeAsyncException, SomeException, StdGen, Sum a, Sym a, Tree a, TyCon, TypeError, TypeRep, Word, Word16, Word32, Word64, Word8, ZipList a, [a]
11:57:52 <Tuplanolla> That's a handful.
11:58:08 <MarcelineVQ> doh ho ho, more lines than she allows for errors
11:58:14 <kadoban> Heh. Easier to list the things that aren't Show at some point xD
11:58:51 <iqubic> What are the requirements for implementing a Show instance.
11:59:06 <iqubic> :t Show
11:59:07 <lambdabot> error:
11:59:08 <lambdabot>     • Data constructor not in scope: Show
11:59:08 <lambdabot>     • Perhaps you meant one of these:
11:59:12 <Tuplanolla> Preferably `shows`, iqubic.
11:59:16 <MarcelineVQ> Gurkenglas: goodness, this package is a bit silly to compile isn't it
11:59:22 <hpc> https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Show
11:59:51 <iqubic> Tuplanolla: What do you meen by shows?
11:59:58 <MarcelineVQ> Gurkenglas: Did you get it working? I can tell you how I did if not
12:00:05 <Tuplanolla> :t shows -- This.
12:00:06 <lambdabot> Show a => a -> ShowS
12:00:25 <Gurkenglas> I got SourceGraph to compile using stack unpack into stack init --solver
12:00:38 <Gurkenglas> And then to run using stack exec to supply a ghc
12:00:58 <Gurkenglas> (Though it appears it can't read some code files.)
12:01:04 <Gurkenglas> *parse
12:01:06 <MarcelineVQ> oh interesting, was that enough? That didn't work for me, had to bump down the Cabal version in the solver's extra-deps
12:01:31 <iqubic> Is there something equivelant to Java's toString for Haskell's Show type class.
12:01:45 <Gurkenglas> (stack init --solver into stack install, of course)
12:01:51 <hpc> iqubic: look at the docs for Show that i linked
12:01:58 <rap99> Hello. Anyone here familiar with Esqueleto? I'm trying to do a "SELECT ... IN (SELECT ...);" and I'm struggling with it
12:02:38 <iqubic> rap99: I think this is the wrong channel.
12:02:50 <rap99> oh... what is the appropriate one?
12:02:55 <iqubic> :t showsPrec
12:02:57 <lambdabot> Show a => Int -> a -> ShowS
12:03:14 <Tuplanolla> This is, rap99. Ignore iqubic.
12:03:28 <koala_man> I have two Maps and I want to find keys that only exists in the first and keys that only exists in the second. Is there anything more efficient than two calls to 'difference'?
12:03:44 <Gurkenglas> iqubic, what type signature should this toString have?
12:04:02 <rap99> ok, thanks Tuplanolla :)
12:04:38 * hackage streaming-binary 0.2.1.0 - Streaming interface to binary.  https://hackage.haskell.org/package/streaming-binary-0.2.1.0 (MathieuBoespflug)
12:05:39 <iqubic> Gurkenglas: Show a => a -> String
12:05:55 <Gurkenglas> @hoogle Show a => a -> String
12:05:55 <lambdabot> Prelude show :: Show a => a -> String
12:05:55 <lambdabot> Text.Show show :: Show a => a -> String
12:05:55 <lambdabot> Test.QuickCheck.Text showErr :: Show a => a -> String
12:06:47 <Gurkenglas> koala_man, mergeWithKey perhaps?
12:07:54 <iqubic> Gurkenglas: What's the minimal complete definition of Show?
12:08:25 <hpc> iqubic: all of your questions are answered by the documentation
12:08:40 <fresheyeball> how can I get around this error?
12:08:45 <fresheyeball> Cannot use record selector ‘_area’ as a function due to escaped type 
12:08:47 <fresheyeball> variables
12:08:49 <Gurkenglas> iqubic, go to https://hackage.haskell.org/package/base-4.9.1.0/docs/Text-Show.html and Ctrl-F for "Minimal complete definition"
12:08:49 <fresheyeball>       Probable fix: use pattern-matching syntax instead
12:09:15 <fresheyeball> its a selector that pulls an existentialized type off a record
12:09:24 <iqubic> WHat's the difference between show and showsPrec?
12:09:56 <iqubic> :t showsPrec
12:09:57 <lambdabot> Show a => Int -> a -> ShowS
12:10:11 <iqubic> What the heck is the Int doing there?
12:10:17 <xa0> precedence
12:10:18 <hpc> iqubic: Gurkenglas's link spells it out quite explicitly
12:10:52 <koala_man> Gurkenglas: ah nice, thanks
12:11:07 <ph88^> i get this exception with conduitDecode from serialization, i don't understand why https://bpaste.net/show/9636d36b40b3
12:11:22 <jle`> iqubic: the documentation is pretty clear too
12:11:35 <hpc> fresheyeball: the error message suggests that you try pattern-matching on the record instead
12:12:24 <jle`> oh actually it doesn't say it in the actual documentation for showsPrec, hm
12:12:26 <jle`> interesting
12:12:30 <fresheyeball> hpc: weird
12:12:33 <Gurkenglas> iqubic, go to "https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Show.html" and Ctrl-F for "showsPrec ::"
12:12:34 <jle`> i thought it did
12:13:04 <hpc> jle`: the surrounding documentation spells it out
12:13:06 <cocreature> jle`: heh yeah I was about to say “look at the docs” but it’s actually really not that obvious
12:13:07 <jle`> mhm
12:13:20 <jle`> well it's actually not explicit
12:14:24 <hpc> If the constructor is defined to be an infix operator, then showsPrec will produce infix applications of the constructor.
12:14:27 <hpc> the representation will be enclosed in parentheses if the precedence of the top-level constructor in x is less than d (associativity is ignored). Thus, if d is 0 then the result is never surrounded in parentheses; if d is 11 it is always surrounded in parentheses, unless it is an atomic expression.
12:15:10 <c_wraith> deriving show fails to generate infix application of infix GADT constructors.
12:15:17 <cocreature> hpc: but it doesn’t say that the integer parsed to showPrec is the precedence
12:17:13 <jle`> yeah, all it says is the behavior from 0 or 11.  and the documentation for "shows" is the only place where 'precendence context' is explicitly used
12:17:28 <jle`> referring to an argument
12:17:44 <jle`> but that's soemthing you have to infer as well
12:17:44 <c_wraith> I only ever copy the example anyway
12:18:00 <c_wraith> It demonstrates how to use it without thinking
12:20:39 <ph88^> anyone experience with ?  https://hackage.haskell.org/package/binary-conduit/docs/Data-Conduit-Serialization-Binary.html
12:24:14 <jle`> ph88^: did you have a question?
12:24:46 <Gurkenglas> I have a set of things, and a way to tell whether two things can be combined into a third. Is there an established way to explore thingspace?
12:25:08 <ph88^> jle`, yes how can i get this to work ?  https://bpaste.net/show/9636d36b40b3
12:25:27 <ph88^> i also tried the same input file + 1 byte, same file + 2 byte .. till +7 bytes ... all files get exceptions
12:26:51 <mniip> is it possible to tell ghci to execute a command after every line input by user
12:31:16 <ph88^> mniip, you can put haskell code in your ghci file
12:31:33 <mniip> кшпре
12:31:35 <mniip> right*
12:31:53 <mniip> but that alone doesn't do what I want
12:33:44 <ph88^> mniip, i think you can make hooks
12:33:54 <mniip> how so
12:34:21 <ph88^> i vaguely remember reading something about it
12:34:46 <Gurkenglas> (Hah! I noticed a connection to the Alchemy game, googled Alchemy AI, and found https://alchemy.cs.washington.edu/)
12:35:48 <ph88^> mniip, ah yes i remember now
12:35:55 <ph88^> i had a ghci file that formats output
12:36:27 <ph88^> mniip, read this page http://haskell.org/haskellwiki/GHC/GHCi
12:38:33 <mniip> ph88^, haven't found anything relevant
12:42:10 <geekosaur> you'd need something like bash's $PROMPT_COMMAND but there isn't one
12:44:07 <ph88^> there is   :set -interactive-print    so you can hook into printing
12:44:12 <ph88^> maybe there are more hooks
12:45:40 <mniip> hmm
12:48:51 <ph88^> i looked .. doesn't seem so :(
12:48:55 <mniip> I suppose I could mod ghci
12:48:58 <ph88^> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html
12:48:58 <Gurkenglas> Writing a .hs outside a project using intero using emacs. How do I bring a package into scope?
12:49:07 <mniip> the usecase is fairly specific
12:49:35 <Tuplanolla> When I needed that, I used `tmux` to do it for me, mniip.
12:49:36 <Gurkenglas> https://i.gyazo.com/45c233ba6bdafd8ef88f8a418c9ce7f7.png
12:49:47 <mniip> Tuplanolla, how?
12:49:52 <ph88^> mniip, maybe you can let ghci work in another monad that does what you want
12:50:00 <mniip> nah, unlikely
12:50:30 <Tuplanolla> Just remapped Enter in the GHCi panel, mniip.
12:50:35 <mniip> nope
12:50:40 <mniip> definitely not going to work
12:50:58 <mniip> I'm running ghci in a script
12:52:10 <cocreature> Gurkenglas: you can just run "stack buld package" outside of any project and then restart intero
12:54:30 <et09> staring at articles about monads for like 4 years and finally it clicks, lol
12:55:42 <MarcelineVQ> Gurkenglas: what package is Control.Monad.Search, something you're making?
12:56:19 <et09> hey what's a good example of a practical use of applicative
12:56:27 <cocreature> et09: the trick is to stop staring at articles and just use them :)
12:56:35 <et09> yeah isnt that always the case 
12:56:47 <Tuplanolla> Context-free parsing is great, et09.
12:57:09 <Welkin> et09: yesod-form
12:57:26 <Welkin> pretty much parsing
12:57:31 <Gurkenglas> MarcelineVQ, monad-dijkstra, not me, seeing whether I can write an exference on ~an A4 page
12:57:57 <glguy> et09: https://glguy.net/config-demo is an example of something interesting that you can do with applicative (and not Monad)
12:58:26 <Gurkenglas> cocreature, https://i.gyazo.com/9512f51d4c431070ac40d990f7990d0d.mp4
12:59:30 <et09> this is for app configurations glguy ?
13:00:22 <et09> or a yaml like thing sort of ?
13:01:01 <iqubic> Can I use Haskell to write web apps?
13:01:13 <et09> iqubic: yeah,  check out Yesod and/or Snap/hAppStack 
13:01:54 <iqubic> Isn't there a framework that compiles to JavaScript? I thought there was.
13:02:07 <et09> Elm?  ghcjs?
13:02:08 <kadoban> GHCJS and reflex-dom
13:03:07 <cocreature> Gurkenglas: are you sure that the file is really outside of a project (in the sense that there is no "stack.yaml" in a parent directory) and that the directory you ran this command in is also outside of a project?
13:03:08 <iqubic> What do people recomend for web applications in Haskell?
13:03:20 <et09> iqubic: in my limited experience, Yesod 
13:03:38 <iqubic> How hard is Yesod to learn?
13:03:48 <et09> depends how much haskell you know really
13:03:51 <Gurkenglas> cocreature, it turns out "intero-restart" wasn't enough, restarting emacs worked.
13:04:02 <et09> https://www.yesodweb.com/book/json-web-service
13:04:28 <cocreature> if you want something a bit more minimal, Spock and scotty are also fairly popular
13:04:51 <cocreature> the new kid on the block which is mostly targeted at writing REST APIs is servant
13:04:54 <dmj`> iqubic: Using yesod is probably easier than understanding how it was implemented
13:05:51 <dmj`> iqubic: yesod uses quasi quotation heavily, which isn’t really programming in haskell
13:06:00 <dmj`> using a QQ that is
13:06:25 <et09> personal preference, having found out about them 2 minute ago, i'd probably stick with scotty or spock unless developing something heavy that needs a lot of support fast 
13:06:39 <et09> i tend to like microframeworks 
13:08:05 <Tuplanolla> You shouldn't use `background-color: #fff9c4 !important` without a matching `color` that's also `!important`, glguy. I can't read white on yellow.
13:08:44 <et09> best practice to never use !important unless you're really stuck overriding a library you're stuck with 
13:09:00 <Gurkenglas> Could intero acquire the capacity to generate import statements from out-of-scope identifiers?
13:11:43 <et09> :t return 5 :: Num a1 => [a1] 
13:11:45 <lambdabot> Num a1 => [a1]
13:12:11 <et09> wondering if it's every appropriate to try to force the monad used in 'return'
13:13:45 <geekosaur> rarely; usually it's inferred by context
13:16:25 <glguy> Tuplanolla: patches welcome it's on github
13:17:14 <glguy> et09: I use it for configuring lots of things
13:17:17 <Tuplanolla> It's easier to not read it.
13:17:22 <portnov> :t return 5
13:17:24 <lambdabot> (Num a, Monad m) => m a
13:17:36 <glguy> web design definitely isn't my thing
13:18:06 <Tuplanolla> It's not a thing to enjoy, for sure.
13:18:59 <dmj`> css is the real problem
13:19:09 <et09> well you got a good start using material design i guess 
13:22:40 <et09> i see what's going on here glguy, very cool
13:25:43 <Gurkenglas> http://lpaste.net/7430854593916960768 how should I go about acquiring a getType?
13:27:20 <Gurkenglas> (whoops, added "modify (f:)")
13:29:22 <Gurkenglas> (actually, I think I can delay it until after the cost :) )
13:31:00 <Cale> Hey, I learned something new about Haskell today: it's possible to foreign import from GHCi.
13:31:24 <Cale> (I learned this by just trying it, lol)
13:31:35 * et09 thought Cale invented haskell 
13:32:13 <dmj`> Cale: cool, care to share :]
13:32:15 <Cale> I wasn't quite around for that. I started in 2001, which is a little over a decade late on the initial language.
13:32:36 <Gurkenglas> (Oh hey I did something like this years ago. Neat http://lpaste.net/143790 *salvages*)
13:32:59 <Cale> dmj`: I just did   foreign import ccall "OpenSSL_add_all_digests" addAllDigests :: IO ()
13:33:08 <Cale> dmj`: At the ghci prompt, and it worked :)
13:33:36 <et09> is ghci repl like the clojure repl in that it compiles down the same path as normal ghc?
13:33:56 <Cale> (The other thing I learned is that nobody ever tried using HsOpenSSL for message digests, because if they had, they'd have noticed that this C call wasn't happening on startup, and so you can't look up any digest algorithms.
13:34:25 <kadoban> Cale: A good sign for a crypto library :-/
13:34:39 <[exa]> :]
13:34:43 <Cale> et09: For the most part it does, but there are lots of idiosyncratic things in the way of that.
13:36:23 <kadoban> Is http://www.staff.city.ac.uk/~ross/papers/FingerTree.pdf decent for understanding finger trees, or is there a better/additional resource I should look at?
13:37:00 <Cale> kadoban: I'm sort of surprised we don't have that stuff together a bit better. The pure Haskell implementations of crypto are a bit nicer to use by now, but I have no confidence that they're not vulnerable to all sorts of side-channel attacks and stuff -- it's not even clear how you'd go about implementing a side-channel-silent algorithm in pure Haskell.
13:37:59 <Cale> kadoban: That's the thing I would link. :)
13:38:00 <et09> hs-tls ? 
13:38:35 <et09> is that the one to use?
13:38:39 <[exa]> kadoban: it's pretty good
13:39:01 <Cale> et09: That's another native Haskell implementation...
13:39:14 <kadoban> Yeah, I'm pretty wary of crypto in haskell in general unfortunately, partly for that reason and partly just because it doesn't seem like any of them have seriously been looked at by enough people that know what they're doing.
13:39:19 <[exa]> kadoban: but anyway, there's a generalized approach to make finger-tree-like stuff automatically from anything, term-derivation based
13:39:36 <kadoban> Cale, [exa]: Thanks
13:39:37 <Cale> et09: I'm not saying don't use it, but if you care about stuff like side channel attacks, maybe don't use it, because I don't think anyone's taken the trouble to check.
13:40:32 <kadoban> When I was last looking at libraries, none of them seemed to go out of their way to be honest about how unexamined they were either. Like ... one person writing a crypto library and nobody looking at it isn't a healthy place to be for production crypto uses.
13:40:46 <Cale> Honestly, if you care, probably just use HsOpenSSL and fix any problems you come across.
13:40:53 <Cale> There's also a Haskell binding to Nettle.
13:41:10 <Cale> I don't know how well trusted Nettle is, but based on its documentation, it at least looks like it's trying.
13:41:54 <kadoban> [exa]: Heh, I'll try to understand the basic thing first I guess, and then look at generalized approaches :)
13:42:25 <et09> oh, i misread your comment
13:42:36 <Cale> The sad thing about FingerTree is that in order to get really good performance, you have to specialise it to a fixed monoid and measure.
13:42:43 <et09> so use an ffi to gnutls i guess
13:42:47 <[exa]> kadoban: this contains some links that might be good https://stackoverflow.com/questions/27282120/are-all-differentiable-types-monads
13:43:23 <et09> or just jam your server behind nginx hah
13:43:52 <Cale> It would be nice if GHC had some way to do template instantiation of entire modules, where some type variable gets replaced by a specified constant throughout and then various things get simplified in terms of that.
13:44:13 <[exa]> kadoban: a colleague once write a complete term-level-derivation-only derivation of fingertree structure from "normal" tree, in Agda iirc, for bachelor thesis. The connection with comonads is well interesting at least
13:44:44 <kadoban> Looks like a pretty fun rabbithole to go down
13:44:50 <Cale> So that, for instance, we could get Data.Sequence as a specialisation of Data.FingerTree
13:45:01 <Cale> as it ought to always have been
13:47:24 <hanna> if only we had some kind of library where all the common data type manipulation functions get generated based on a single universal traversal-like function
13:48:49 <[exa]> hanna: that sounds like "if only we had inliner without loopbreakers"
13:58:23 <dmj`> et09: nixos makes terminating ssl behind nginx a breeze
13:58:50 <et09> terminating?
13:59:46 <dmj`> https://www.nginx.com/resources/admin-guide/nginx-ssl-termination/
14:00:09 <et09> ah, right
14:00:25 <et09> how does nixos facilitate it
14:01:38 <et09> oh whoa, does nixos have its own network stack?
14:06:24 <dmj`> et09: it uses the linux kernel, so yes I guess.
14:06:38 <et09> i meant a custom one 
14:07:00 <et09> i guess you're talking about this configuration.nix thing though
14:07:54 <clever> nixos allows you to just set enableACME=true; and it will automaticaly enable ssl in nginx, and run #letsencrypt to auto-generate a cert
14:08:08 * hackage hamtsolo 1.0.0 - Intel AMT serial-over-lan (SOL) client  https://hackage.haskell.org/package/hamtsolo-1.0.0 (jgalowicz)
14:08:13 <et09> oh, that's handy 
14:08:58 <dmj`> et09: something like this, https://gist.github.com/dmjio/a641f223603fa5eca51e58fdfdc77188
14:09:08 * hackage superconstraints 0.0.2 - Access an instance's constraints  https://hackage.haskell.org/package/superconstraints-0.0.2 (RyanTrinkle)
14:09:16 <clever> https://gist.github.com/cleverca22/43d0576b427fa85ce0efab81e99a84a8 this example i made a month ago will enable hydra and auto-configure nginx as a reverse proxy that adds ssl
14:22:48 <hololeap> is there a good library or language extension (like TupleSections) that eases working with tuples, for instance, mapping a function to both tuples, combining all parts of multiple like a monoid, etc.
15:04:46 <Tuplanolla> Yeah, `lens`, TheFuzzball.
15:05:42 <Tuplanolla> :t Field1 -- If that's too much, you can build your own around this class.
15:05:44 <lambdabot> error: Data constructor not in scope: Field1
15:06:08 * hackage fltkhs 0.5.2.4 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.2.4 (deech)
15:06:51 <Rembane> I think Haskell is awesome, but since I run ArchLinux on the dev machine and some random LTS version of Ubuntu on the VPS where I want to run my program nothing works when I just copy the compiled program. I wanted to compile on the VPS but I haven't got enough memory. How do you do deployment?
15:07:43 <Tuplanolla> :k Field1
15:07:44 <lambdabot> * -> * -> * -> * -> Constraint
15:14:18 <ertes> Rembane: i use nix locally, and when i deploy to a machine that doesn't have nix, normally i just deploy a docker image (which nix helps me build), or i deploy a nix closure, which is the program together with *all* its dependencies down to glibc
15:15:25 <Rembane> ertes: Cool, is cabal2nix involved in this endeavour?
15:15:45 <ertes> Rembane: yeah
15:16:09 <ertes> Rembane: you generate one nix file for the haskell package, and then a separate one for the docker image
15:16:37 <ertes> or, if you go for the closure approach, you only need the package file, and you use `nix-store -qR` to extract the closure
15:17:10 <Rembane> ertes: Okay. I'll read up on this. Just using Docker for building stuff hasn't really worked out for me. Linking is hard.
15:18:41 <ertes> Rembane: the nix+docker approach surprisingly (or perhaps not that surprisingly) doesn't involve actual building or a Dockerfile…  by the time nix starts to generate the image the haskell package itself will have already been built
15:19:30 <Rembane> ertes: Ah. Good stuff.
15:36:38 * hackage shikensu 0.3.3 - A small toolset for building static websites  https://hackage.haskell.org/package/shikensu-0.3.3 (icidasset)
15:49:38 * hackage hdaemonize 0.5.4 - Library to handle the details of writing daemons for UNIX  https://hackage.haskell.org/package/hdaemonize-0.5.4 (sickmind)
15:53:08 * hackage sitepipe 0.1.1 - A simple to understand static site generator  https://hackage.haskell.org/package/sitepipe-0.1.1 (ChrisPenner)
16:01:23 <Gurkenglas> How do I stop a diverging computation in ghci in intero in emacs?
16:07:34 <Lokathor> so it's safeish to use unsafeCoerce to go between a base type and a newtype?
16:09:04 <Guest40> why does haskell use tuple syntax for list destructuring? 
16:09:19 <Guest40> i.e. (x:xs) vs [x:xs]
16:09:19 <glguy> Lokathor: you can use Data.Coerce for that
16:09:22 <Lokathor> Guest40, you mean (a:xs) ?
16:09:26 <Guest40> yes
16:09:31 <Lokathor> ( ) is just parens
16:09:34 <Lokathor> like (3+4) * 5
16:09:40 <Lokathor> the , is what makes it the tuple
16:10:05 <Guest40> I see
16:10:07 <glguy> Guest40: [x] matches a single element list naming that element x
16:10:15 <Guest40> I see
16:10:23 <Guest40> but since the type sig uses []
16:10:28 <Guest40> why not use that for destructuring?
16:10:38 <pacak> [x:xs] - not haskell
16:10:42 <Lokathor> glguy, does that work if the newtype's constructor is private? is the thing i was really wondering about
16:10:43 <Guest40> it would seem to be consistent
16:11:03 <Guest40> there must be some historical reason
16:11:04 <pacak> Lokathor: unsafeCoerce :)
16:11:08 <Rotaerk> [x:xs] would be a list containing a single element, which is a list containing at least one element, and that element is called x, while the rest is xs
16:11:20 <Lokathor> Guest40, because it's not () because it's list, it's () for any pattern, eg case foo of (Just (x,y)) -> 
16:11:26 <glguy> Guest40: the types of things rarely look just like the values
16:11:33 <Lokathor> pacak, but that's what i asked about at first :P
16:11:56 <Guest40> that makes sense
16:12:00 <monochrom> List does not mean using square brackets. So-called [1,2,3] is syntax sugar for 1:(2:(3:[])).
16:12:04 <Guest40> thank you Lokathor and glguy 
16:12:45 <Guest40> it just tripped me up b/c I had just read about tuples
16:12:50 <Guest40> and it looked similar
16:13:25 <Guest40> most helpful, thanks again
16:13:27 <pacak> Lokathor: use coerce if you can. In this case if anything changes typechecker will prevent your code from exploding. unsafeCoerce on the other hand is unsafe.
16:13:29 <Lokathor> yeah, the , part is the real magic with tuples
16:13:48 <Guest40> yeah , for tuples and : for cons (i.e. lists)
16:14:13 <Guest40> the new haskell book is good
16:15:27 <Lokathor> pacak, so it looks like newtypes automatically have the correct coercable instances?
16:15:38 <Lokathor> it's pretty good
16:15:50 <Lokathor> wish it was sans serif :3
16:29:19 <Koterpillar> > let [x:xs] = [[1,2]] in "x is " ++ show x " and xs is " ++ show xs
16:29:21 <lambdabot>  error:
16:29:21 <lambdabot>      • Couldn't match expected type ‘[Char] -> [Char]’
16:29:21 <lambdabot>                    with actual type ‘[Char]’
16:29:37 <mniip> missing ++
16:29:37 <Koterpillar> > let [x:xs] = [[1,2]] in "x is " ++ show x ++ " and xs is " ++ show xs
16:29:39 <lambdabot>  "x is 1 and xs is [2]"
18:15:36 <Koterpillar> @hoogle Monad m => ConduitM a o m [a]
18:15:36 <lambdabot> Conduit asumC :: (Alternative f, Monad m) => ConduitM (f a) o m (f a)
18:15:36 <lambdabot> Text.XML.Stream.Parse ignoreAnyTreeContent :: MonadThrow m => ConduitM Event o m (Maybe ())
18:15:36 <lambdabot> Text.XML.Stream.Parse ignoreAllTreesContent :: MonadThrow m => ConduitM Event o m (Maybe ())
18:16:14 <Koterpillar> Is there a shortcut for foldMapC (:[])?
18:23:07 <lyxia> sinkList ?
18:53:01 <Koterpillar> yes, that's it! Thanks!
18:53:14 <Koterpillar> :t sinkList
18:53:16 <lambdabot> error:
18:53:16 <lambdabot>     • Variable not in scope: sinkList
18:53:16 <lambdabot>     • Perhaps you meant ‘shrinkList’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
18:57:57 <halogenandtoast> If I were to make a tutorial video of how to make a twitter clone is Yesod, would anyone be irritated if I avoided using an auth plugin and just wrote the auth in the app itself?
18:58:52 <halogenandtoast> None of the auth plugins work in the same manner, I just wonder if it's irresponsible of me to write potentially insecure code and release a tutorial showing others how to introduce the same potentially insecure code out into the while.
18:59:07 <halogenandtoast> Granted I have some experience writing authentication for websites.
18:59:43 <halogenandtoast> s/while/wild/
19:05:42 <EvanR> it sounds like a standard problem with tutorials
19:06:11 <EvanR> who are we to stand in the way
19:11:06 <Koterpillar> consider naming it lousyAuthenticationPlugin
19:17:09 <halogenandtoast> Koterpillar: lol, I was planning on avoiding the plugin architecture entirely
19:17:16 <halogenandtoast> easier just to code it in the app itself.
19:17:23 <Koterpillar> then lousyAuthSomethingElse
19:18:18 <halogenandtoast> I just feel like all of the current auth plugins are rather rigid and don't seem to handle the very simple case of signing up with a username, email, and password without having to send a verification email.
19:18:31 <halogenandtoast> I promise I won't md5 the passwords
19:19:02 <halogenandtoast> So far this seems to be the closest: https://hackage.haskell.org/package/yesod-auth-account
19:19:07 <halogenandtoast> but again it's rather rigid
19:21:08 * hackage xmonad-vanessa 0.1.1.1 - Custom xmonad, which uses stack and sets various defaults  https://hackage.haskell.org/package/xmonad-vanessa-0.1.1.1 (vmchale)
19:22:53 <halogenandtoast> I guess I'll make the video and see what feedback I get, I'd be happy to rerecord if someone mentions something critical (or better)
19:26:06 <sophiag> so i just read up on profunctors, which always seemed complicated to me, but turns out they're just a twist on a bifunctor. the thing i'm struggling with (similar to when i first learned about bifunctors) are examples
19:26:17 <sophiag>  i can see some contrived ones on the school of haskell page, but i assumed they occurred in the actual language somewhere. it does say "The simplest and most common Profunctor is (→)," but i'm having trouble understanding how (->) outside of dimap flips the arguments of the first function
19:29:42 <halogenandtoast> sophiag: don't know if you've still blocked me, but when I asked someone, I think they pointed me at the Reader monad (which I'm not sure if a profunctor because it was a while ago and I never seem to use it directly)
19:30:04 <halogenandtoast> I'm searching now to confirm
19:30:19 <sophiag> halogenandtoast: i blocked you?
19:30:23 <sophiag> oy
19:30:26 <halogenandtoast> Maybe?
19:30:32 <sophiag> i hope not...
19:30:44 <halogenandtoast> I used some harsh language at some point.
19:30:52 <halogenandtoast> Might have been someone else
19:30:55 * halogenandtoast shrugs
19:31:13 <sophiag> welp, if such an incident occurred it seems like we're mutually over it :)
19:31:14 <halogenandtoast> If it was you, sorry for the harsh language, if not, party on
19:33:07 <mniip> wait
19:33:22 <mniip> internal lambda calculus in a category
19:33:26 <mniip> is that what Arrow is about
19:35:45 <sophiag> hmm, can't find anything about Reader being a profunctor on Google it doesn't have a profunctor instance
19:35:52 <halogenandtoast> yeah :[
19:35:57 <halogenandtoast> sorry for that rabbit hole
19:36:05 <halogenandtoast> I've forgotten the conversation I had...
19:36:15 <halogenandtoast> I wish I could remember now
19:41:41 <sophiag> halogenandtoast: i'm reading this: http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
19:41:56 <sophiag> it explains that comment about (->)
19:43:08 <halogenandtoast> sophiag: This is a neat example of a profunctor (contrived but neat) https://carlo-hamalainen.net/blog/2015/10/21/note-to-self-profunctors
19:43:51 <sophiag> i don't have much trouble understanding stuff like that. just trying to wrap my head around how type constructors are profunctors
19:44:30 <Welkin> :k (->)
19:44:31 <lambdabot> * -> * -> *
19:45:00 <halogenandtoast> sophiag: Do you understand how they are bifunctors?
19:45:19 <halogenandtoast> (not saying I do, but I suppose that's step 1)
19:45:23 <Welkin> I still don't know about profunctors yet
19:45:27 <sophiag> yes
19:45:36 <sophiag> i think...
19:45:52 <halogenandtoast> So the next step is proving they are contravariant on the first argument, and covariant on the second.
19:45:55 <sophiag> to be able to map between exponentials they need to be bifunctors
19:46:13 <sophiag> i'm not sure the above is the correct argument though
19:46:28 <sophiag> right, and really just the contravariant part
19:46:55 <halogenandtoast> so to be contravariant it can be seen as changing the fmap order right
19:47:04 <halogenandtoast> we can't do (a -> b) -> f a -> f b
19:47:16 <halogenandtoast> it is instead (b -> a) -> f a -> f b
19:47:20 <mniip> 1496025878 [05:44:38] <halogenandtoast> sophiag: Do you understand how they are bifunctors?
19:47:25 <mniip> but (->) is not a bifunctor
19:47:46 <sophiag> it's a profunctor. that's what we're trying to figure out
19:47:50 <mniip> not Hask x Hask -> Hask
19:47:57 <mniip> it's Hask^op x Hask -> Hask
19:47:59 <mniip> hence profunctor
19:48:28 <sophiag> (a -> b) -> (c -> d) -> f a b -> f c d 
19:48:35 <sophiag> ^ bifunctor version
19:48:43 <sophiag> but i don't understand how the first is flipped
19:49:09 <sophiag> mniip: would you mind explaining what Hask^op is in terms of the actual language?
19:49:27 <uniclown> bimap is (a -> b) -> (c -> d) -> f a c -> f b d
19:49:35 <mniip> newtype Op a b = Op (b -> a)
19:49:40 <halogenandtoast> mniip: sorry my understanding of profunctor, is that it's a bifuntor that is contravariant on the first argument, and covariant on the second. Is this wrong?
19:50:03 <mniip> halogenandtoast, a profunctor from C to D is a bifunctor from C^op and C to D
19:50:04 <halogenandtoast> s/bifuntor/bifunctor/
19:50:06 <mniip> that much is correct
19:50:11 <sophiag> uniclown: you're right. i was confused because the inputs on school of haskell are written oddly
19:51:00 <mniip> sophiag, Hask^op has all the same objects, but the morphisms are backwards
19:51:24 <mniip> a morphism from Int to Char is 'Op Int Char'
19:51:24 <Welkin> halogenandtoast: you mean
19:51:26 <Welkin> ^(?:(?:(?:0?[13578]|1[02])(\/|-|\.)31)\1|(?:(?:0?[13-9]|1[0-2])(\/|-|\.)(?:29|30)\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:0?2(\/|-|\.)29\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:(?:0?[1-9])|(?:1[0-2]))(\/|-|\.)(?:0?[1-9]|1\d|2[0-8])\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$
19:51:30 <mniip> a function from Char to Int
19:51:31 <Welkin> ?
19:51:41 <sophiag> that's what i figured, but i don't follow how that means (->) is contravariant on the first argument
19:51:57 <mniip> sophiag, do you know what a contravariant functor is
19:52:08 <sophiag> yes
19:52:12 <halogenandtoast> Welkin: I'm missing a large amoutnt of mental context to understand what you've just posted, except that it's a large regular expression.
19:52:20 <Welkin> halogenandtoast: exactly :P
19:52:21 <halogenandtoast> I could parse that, but I don't want to.
19:52:31 <mniip> a contravariant functor from C to D is a functor from C^op to D
19:52:41 <mniip> mentally, you could imagine it as
19:52:41 <sophiag> yup got that
19:52:52 <mniip> contramap :: Op a b -> f a -> f b
19:53:01 <mniip> for example,
19:53:08 <mniip> data Pred a = Pred (a -> Bool)
19:53:15 <mniip> Pred is not a functor from Hask to Hask
19:53:19 <mniip> hence not an instance of Functor
19:53:33 <sophiag> which Pred?
19:53:38 <mniip> the one I just defined
19:53:50 <sophiag> well you duplicated the data and type constructors
19:54:08 <mniip> which of the two do you think we call a "functor"
19:54:41 <sophiag> the type constructor
19:54:45 <mniip> right
19:54:53 <halogenandtoast> Oh good, my guess was correct as well.
19:54:57 <iqubic> What are we talking about here?
19:54:59 <halogenandtoast> halogenandtoast++
19:55:04 <sophiag> iqubic: profunctors
19:55:05 <halogenandtoast> iqubic: profunctors
19:55:10 <mniip> iqubic, profunctors
19:55:24 <iqubic> What's a profunctor?
19:55:26 <halogenandtoast> I love this channel
19:55:30 <sophiag> ha
19:55:31 <mniip> sophiag, do you see why Pred is not a Functor?
19:55:38 <mniip> iqubic, google it
19:55:58 <halogenandtoast> It's a functor that's really good at its job.
19:56:03 <halogenandtoast> hence pro functor
19:56:06 <iqubic> Pred can't be a functor. How do you map a function f over a Pred a?
19:56:08 <uniclown> mniip: I understand Hask is the category of types in haskell (basically) but why is Pred not a functor from Hask to Hask?
19:56:14 <iqubic> You can't really do that.
19:56:26 <sophiag> it's not a functor because it just takes one type variable
19:56:49 <mniip> sophiag, ???
19:56:50 <sophiag> unless i'm supposed to think of the rhs somehow
19:56:54 <halogenandtoast>  @faq Is Predicate a functor?
19:56:57 <mniip> uniclown, if it were a functor, then there would be a mapping from (a -> b) to (Pred a -> Pred b)
19:57:03 <halogenandtoast> @faq Is Predicate a functor?
19:57:03 <lambdabot> https://wiki.haskell.org/FAQ
19:57:03 <mniip> natural in a, b
19:57:12 <sophiag> ah ok
19:57:15 <mniip> there can't be such a mapping
19:57:32 <sophiag> so we need to flip (a -> Bool) when mapping over Pred
19:57:37 <mniip> if you need to know why? I'd need to check
19:57:44 <uniclown> got it. It is a contravariant functor though (I think that's the point haha)
19:58:33 <sophiag> but what if you have: data foo a b = bar (a -> b) ?
19:58:52 <mniip> uniclown, I think it follows from the free theorem somehow
19:58:55 <sophiag> then it's not immediately obvious to me that (->) needs to be contravariant
19:59:06 <mniip> the only definition you can write is fmap _ _ = const False/True
19:59:12 <mniip> which doesn't satisfy laws
19:59:20 <c_wraith> sophiag: it's contravariant in a, covariant in b
19:59:31 <c_wraith> sophiag: which is exactly what Profunctor is
19:59:47 <sophiag> aha!
19:59:49 <uniclown> that's why partially applied arrow is a functor ((->) e)
19:59:58 <mniip> sophiag, so, do you see why Pred is not a Functor?
20:00:36 <sophiag> mniip: because it sends a to Bool rather than another input?
20:00:52 <mniip> uhh
20:01:01 <mniip> no
20:01:06 <sophiag> lol ok
20:01:57 <iqubic> ?info do { foo; x <- bar; baz }
20:01:58 <lambdabot> foo >> bar >>= \ x -> baz
20:02:05 <iqubic> ?undo do { foo; x <- bar; baz }
20:02:05 <lambdabot> foo >> bar >>= \ x -> baz
20:02:24 <iqubic> Looks like info gets "corrected" into undo
20:02:25 <mniip> sophiag, remembering the definition of a functor, it is a mapping of objects (in our case from X to F X), and a mapping of morphisms from (a -> b) to (F a -> F b)
20:02:38 <mniip> if we substitute F = Pred
20:02:47 <mniip> we find that such a mapping of morphisms is impossible
20:03:02 <iqubic> I thought a functor was something that allowed for fmap.
20:03:05 <halogenandtoast> can you break that down for me?
20:03:05 <iqubic> :t fmap
20:03:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:03:15 <sophiag> (a -> Bool) -> (b -> Bool) ?
20:03:18 <mniip> iqubic, I did not say otherwise
20:03:28 <mniip> sophiag, (a -> b) -> (a -> Bool) -> (b -> bool)
20:03:38 <sophiag> right
20:03:44 <halogenandtoast> I see
20:03:46 <iqubic> But where do the Bools come from?
20:03:52 <mniip> sophiag, that function cannot be written in a lawful form
20:04:01 <iqubic> It can't? Why not?
20:04:06 <iqubic> What are the fmap laws?
20:04:16 <mniip> fmap id = id; fmap f . fmap g = fmap (f . g)
20:04:47 <vaibhavsagar> sophiag, have you seen Fun with Profunctors: https://www.youtube.com/watch?v=OJtGECfksds? I hate that it's 2 hours long but it's a useful 2 hours
20:04:53 <vaibhavsagar> also hi!
20:04:56 <iqubic> And you can't write an functor instance for Pred?
20:05:01 <sophiag> hi vaibhav!
20:05:04 <mniip> iqubic, yes
20:05:15 <iqubic> Why not?
20:05:17 <sophiag> you'd need to be able to send Bool -> Bool correct?
20:05:27 <mniip> iqubic, try it
20:05:34 <mniip> sophiag, what no
20:05:58 <iqubic> fmap f p = _
20:06:01 <uniclown> what are some of the best resources for learning lens?
20:06:02 <iqubic> I can't do it.
20:06:10 <mniip> it follows from parametrism, the free theorem
20:06:16 <mniip> the only two fmaps you can write are
20:06:21 <mniip> fmap _ _ _ = True
20:06:23 <mniip> fmap _ _ _ = False
20:06:27 <mniip> and neither of them is lawful
20:06:36 <iqubic> Why not?
20:06:43 <iqubic> Why aren't they lawful?
20:06:56 <sophiag> yeah, i'm struggling with the same question tbh
20:07:10 <mniip> fmap id /= id
20:07:17 <halogenandtoast> if Pred a is Pred (a -> Bool) if we plug that into fmap (a -> b) -> f a -> f b is a here actually (a -> Bool)?
20:07:46 <c_wraith> Due to parametricity, fmap id = id is the only lens law you need to check.
20:07:52 <halogenandtoast> and f Pred
20:08:02 <c_wraith> and surprisinly, people forget it all the time
20:08:05 <mniip> halogenandtoast, we're using Pred in place of f
20:08:08 <mniip> that's the whole point
20:08:46 <halogenandtoast> so for f to remain pred, b has to be (b -> Bool) ?
20:08:49 <mniip> sophiag, if something was not clear on the way here it's best to ask
20:08:58 <sophiag> i'm still squinting at it
20:09:13 <iqubic> If Pred is not a functor, how come State gets to be a functor. It's type signature is even more complex
20:09:19 <sophiag> through reduction, you do end up just sending Bool to Bool, yes?
20:09:21 <halogenandtoast> ((a -> Bool) -> (b -> Bool))
20:09:28 <sophiag> ^ that
20:09:42 <sophiag> it's pretty clear to me how that's not id
20:09:54 <iqubic> Yeah, alright I get it.
20:10:02 <mniip> sophiag, no?
20:10:12 <sophiag> yes
20:10:15 <Gurkenglas> sophiag, no
20:10:18 <sophiag> oh
20:10:19 <mniip> it could be an id
20:10:25 <sophiag> it *could*
20:10:33 <mniip> if we had id :: b -> a
20:10:34 <sophiag> but not necessarily, which i assumed is what we're looking for
20:10:36 <mniip> ugh
20:10:39 <mniip> this is getting confusing
20:10:55 <EvanR> id :: b -> a, somethings not right here...
20:10:58 <sophiag> no, i understand
20:11:01 <Gurkenglas> halogenandtoast, "data Pred a = Pred (a -> Bool)" means that values of type Pred a are constructed by applying the constructor Pred to a value of type (a -> Bool), not that a means (a -> Bool)
20:11:13 <iqubic> Now, here's a tangent: What's the best way to make a pretty printer for a custom data type.
20:11:15 <sophiag> it only follow the functor laws if id :: b -> a
20:11:16 <mniip> EvanR, I'm implying a constraint on a and b
20:11:24 <Gurkenglas> halogenandtoast, it does mean that you can see "Pred a" as "a -> Bool" modulo wrapping.
20:11:32 <sophiag> i'm saying that *if* is not good enough
20:11:35 <EvanR> iqubic: dont and use Generic pretty printer instaed
20:11:50 <EvanR> and certainly dont use Show
20:11:57 <Gurkenglas> halogenandtoast, f is indeed Pred, so modulo wrapping you can see fmap as "(a -> b) -> ((a -> Bool) -> (b -> Bool))"
20:12:11 <mniip> thanks Gurkenglas
20:12:20 <mniip> I was lost in trying to make sense of it
20:12:27 * halogenandtoast needs to look up module wrapping
20:12:30 <halogenandtoast> modulo
20:12:56 <sophiag> mniip: am i correct in that the necessity of the constraint id :: b -> a is what makes it not a functor?
20:13:06 <sophiag> because with that, it seems to follow the laws
20:13:06 <mniip> forget id :: b -> a
20:13:11 <mniip> I didn't express myself clearly
20:13:22 <sophiag> sure
20:13:42 <iqubic> How does one create a new stack project?
20:13:55 <halogenandtoast> iqubic: stack new projectName templateName
20:14:11 <mniip> sophiag, if we have fmap :: (a -> b) -> Pred a -> Pred b
20:14:19 <mniip> it naturally follows that we have to have
20:14:31 <mniip> fmap f (Pred p) = Pred (\x -> ...)
20:14:35 <Gurkenglas> halogenandtoast, "modulo" can be roughly translated as "up to". "You can see A as B modulo wrapping" means that you need only do wrapping/unwrapping operations to convert between A and B. In this case, those are Pred, which turns (a -> Bool) into Pred a, and its inverse, which turns Pred a into (a -> Bool).
20:14:44 <mniip> now, f :: a -> b, p :: a -> Bool  x :: b
20:14:50 <mniip> you cannot do *anything* with these
20:14:59 <mniip> so the only thing you can plug for '...'
20:15:06 <mniip> is a literal True, or False
20:15:17 <mniip> fmap f (Pred p) = Pred (\x -> False)
20:15:20 <sophiag> ah right
20:15:21 <mniip> does not make a lawful fmap
20:15:34 <mniip> fmap id != id
20:15:37 <mniip> because
20:15:53 <mniip> fmap id = \(Pred p) -> Pred (\x -> False)
20:16:18 <mniip> fmap id (Pred (\x -> True)) = Pred (\x -> False)
20:16:22 <sophiag> ah ok. hence wy you even used this example
20:16:26 <mniip> != id (Pred (\x -> True))
20:16:39 <mniip> if you didn't realize, when we say 'fmap id = id'
20:16:48 <mniip> we mean 'fmap (\x -> x) = \y -> y'
20:17:45 <mniip> anyway
20:17:50 <mniip> Pred is not a Functor
20:17:59 <mniip> that is, it's not a functor from Hask to Hask
20:18:03 <sophiag> ah, so it's not that a would have to equal b, but that just with a it would have to be literally True or False
20:18:58 <mniip> haskell's Functor (capital F) denotes a functor (mathematical) from Hask to Hask
20:19:07 <sophiag> but we can still compose it by pulling out the a, which requires a functor that's contravariant on the first argument
20:19:24 <sophiag> yup, i know functor here == endofunctor
20:19:31 <sophiag> ah, wait that does mean a lot in this case
20:19:47 <sophiag> because Hask^op -> Hask is not an endofunctor
20:20:00 <mniip> haskell's Contravariant denotes a contravariant functor from Hask to Hask
20:20:06 <halogenandtoast> What does the notation Hask^op mean?
20:20:10 <mniip> which is, by mathematical definition, a functor from Hask^op to Hask
20:20:46 <sophiag> it's starting to come together for me...
20:20:54 <mniip> halogenandtoast, C^op = C with arrows reversed
20:21:10 <halogenandtoast> Gurkenglas: Thanks for explaining modulo, I could not find such a definition online
20:21:13 <mniip> sophiag, the 'mapping function' for a functor from Hask^op to Hask
20:21:15 <mniip> would look like
20:21:23 <mniip> Op a b -> Pred a -> Pred b
20:21:29 <mniip> aka
20:21:32 <sophiag> right
20:21:34 <mniip> (b -> a) -> Pred a -> Pred b
20:21:38 <mniip> aka the type of contramap
20:21:45 <sophiag> but really the core for me is just understanding why Op a b
20:21:49 <EvanR> still not quote sure what the meaning of arrow reversal is
20:21:57 <sophiag> which i'm maybe 50% there as far it sticking tomorrow :)
20:21:58 <EvanR> beyond syntactic style
20:22:28 <mniip> EvanR, you could write a uniform Functor class for both
20:22:40 <mniip> see edwardk's Hask or mine
20:22:41 <sophiag> the best i can express it is you need Op a b just to do anything with a
20:23:03 <mniip> sophiag, it doesn't have to have a short explanation
20:23:05 <sophiag> if (a -> b) isn't a functor that is
20:23:15 <mniip> the explanation I have in my mind is,
20:23:19 <Cale> When is the Boston Haskell thing taking place this year?
20:23:20 <sophiag> i'm just trying to think of it in a way it'll stick when i wake up tomorrow...
20:23:24 <mniip> 1) you can't write a function (a -> b) -> Pred a -> Pred b
20:23:56 <halogenandtoast> Cale: which Boston Haskell thing, I'd love an excuse to go back to Boston.
20:24:00 <mniip> 2) it follows from a theorem that because 'v' appears contravariant in the definition of 'Pred v' such a function cannot be written
20:24:54 <mniip> sophiag, ((->) a) is a valid functor
20:24:58 <Cale> halogenandtoast: There's usually a very casual "hackathon"
20:24:59 <mniip> a valid Functor even
20:25:24 <sophiag> that makes sense
20:25:45 <mniip> sophiag, now, about co/contravariance of certain arguments,
20:26:05 <mniip> if you look at the pattern above with a->b vs b->a
20:26:35 <mniip> we say that 'F abc v xyz' is covariant in 'v' if you can write (v -> w) -> F abc v xyz -> F abc w xyz
20:26:53 <mniip> and contravariant in 'v' if you can write (w -> v) -> F abc v xyz -> F abc w xyz
20:26:59 <mniip> for some set of variables abcxyz
20:27:35 <iqubic> What is the right way to make a pretty printer for a data type?
20:27:48 <mniip> 'Maybe a' is covariant in 'a'
20:27:54 <mniip> 'Pred a' is contravariant in 'a'
20:28:10 <mniip> '(->) a b' is covariant in 'b' and contravariant in 'a'
20:28:31 <mniip> that's the stuff
20:28:47 <iqubic> Is there a recommended Pretty Printing library I should use, or now??
20:28:55 <iqubic> s/now/no/
20:29:47 <sophiag> mniip: i'm still not sure if it'll stick tomorrow, but makes sense now
20:30:26 <sophiag> it's quite simple once you clarified the definitions of contravariant and covariant to apply to data types rather than just functions
20:31:35 <mniip> was a bit of mindfuck for me too when I was exploring CT and saw mentions of 'transformations natural in "a"' too
20:32:24 <sophiag> right
20:32:54 <iqubic> So is there no recommended library for making pretty printers?
20:32:54 <sophiag> it's actually somewhat of an arguement for the clarity of Haskell's syntax for data types vs. MLs
20:33:25 <Aleph9> Hi, I'm new to haskell and I'm confused by some types. If I use a random librar and I get a RVar [String] type, how do I turn that into [String] again?
20:33:36 <uniclown> so I'm reading code in a haskell project and it has instance statements without a 'where' and no function definitions. What gives?
20:33:52 <iqubic> Can I see an example?
20:34:00 <c_wraith> Aleph9: there are probably some functions in the library that have exactly that type.
20:34:02 <uniclown> https://github.com/aviaviavi/legion/blob/master/app/Main.hs#L51
20:34:09 <mniip> uniclown, all function definitions are defaulted
20:34:47 <iqubic> It just takes exactly the default function definitions and nothing else.
20:34:52 <Aleph9> c_wraith: thanks, I'll look through the documentation!
20:35:03 <tfc[m]> hi there, i have the following problem with my cabal file: " conduit-combinators-1.0.8.3 must match ==1.1.* (latest applicable is 1.1.1)" which i don't understand. isn't 1.1.1 within 1.1.* ?
20:35:08 <mniip> do note that there might be 0 of them, too
20:35:08 * hackage pub 3.0.0 - Pipe stdin to a redis pub/sub channel  https://hackage.haskell.org/package/pub-3.0.0 (ParnellSpringmeyer)
20:35:14 <mniip> that constitutes "all" as well
20:35:16 <c_wraith> Aleph9: hmm.  There isn't an exact match.  You're going to want something like sampleRVar
20:36:45 <c_wraith> Aleph9: actually, that library looks like a complete pain in the butt for a beginner.  Using it will require a lot of knowledge compared to something like the random library
20:36:47 <iqubic> Why doesn't anyone want to tell me about haskell Pretty Printers?
20:37:01 <vaibhavsagar> iqubic: what would you like to know?
20:37:28 <Aleph9> c_wraith: Yeah I already noticed, which one would you recommend if I want to get random samples out of lists?
20:37:29 <vaibhavsagar> quchen made https://github.com/quchen/prettyprinter recently
20:37:38 <iqubic> Data Piece = X | O | Blank
20:38:03 <iqubic> type Board = [[Piece]]
20:38:09 <vaibhavsagar> like a tic-tac-toe board?
20:38:36 <iqubic> Yeah, I'm making a tic-tac-toe game, and I want to print that out with some pretty lines.
20:39:03 <vaibhavsagar> ahh, my understanding of pretty printers is that they are primarily for text
20:39:26 <iqubic> Oh. I guess I could write my own printing function.
20:39:27 <vaibhavsagar> e.g. source code or columns of text
20:39:50 <vaibhavsagar> have you had a look at https://hackage.haskell.org/package/brick?
20:39:53 <vaibhavsagar> it seems pretty cool
20:39:55 <c_wraith> Aleph9: hmm.  That's a good question.  Hey, as a related question, do you know how to use IO?
20:39:56 <Gurkenglas> stack doesn't suppoert ghc 7.8.3? :/ How should I build https://github.com/ekmett/hask ?
20:40:11 <iqubic> I want have the ability for the board to be whatever size n*m I'd like
20:40:43 <vaibhavsagar> are you displaying this in a terminal or do you want a GUI toolkit?
20:40:48 <iqubic> vaibhavsagar: What does Brick do exactly?
20:41:15 <Aleph9> c_wraith: roughly, I read up on the difference between impure and pure functions and side-effects, is that the problem here too?
20:41:26 <iqubic> Actually, Brick looks like it'll work quite well for me.
20:41:27 <vaibhavsagar> iqubic: it's a terminal UI library
20:42:11 <c_wraith> Aleph9: sort of.  The underlying problem is that true randomness is obviously impure, so random values must be modeled somehow.  That's what the RVar type is doing.
20:42:21 <iqubic> Oh, then I guess that's not what I want then.
20:42:50 <iqubic> What I want is just a way to print a grid once, then ask for input, then print the new grid.
20:42:55 <iqubic> It's not too fancy
20:43:29 <vaibhavsagar> brick should be able to do that
20:43:31 <Welkin> iqubic: you don't need a pretty printer
20:43:38 <Welkin> just print your grid one row at a time
20:43:54 <iqubic> Welkin: I think I'll do just that.
20:44:17 <iqubic> The thing is: Every other line should be nothing but ---------------------
20:44:20 <Welkin> it's best to start with the simplest thing that works rather than trying to pull in tons of new libraries
20:44:34 <iqubic> Yeah, I'll try that and see what I get.
20:44:37 <Welkin> iqubic: just intersperse your output with that then
20:44:43 <Welkin> :t intersperse
20:44:44 <lambdabot> a -> [a] -> [a]
20:44:52 <iqubic> Right.
20:45:39 <iqubic> Is there a way to take a list and split into sublists all with length n?
20:45:45 <iqubic> :t split
20:45:46 <lambdabot> Splitter a -> [a] -> [[a]]
20:45:54 <Welkin> :t chunk
20:45:55 <lambdabot> Int -> [e] -> [[e]]
20:46:09 <Welkin> from Data.List.Split
20:46:10 <Welkin> I think
20:46:27 <ChaiTRex> @hoogle chunk
20:46:27 <lambdabot> Data.Text.Internal.Lazy chunk :: Text -> Text -> Text
20:46:27 <lambdabot> Rainbow chunk :: a -> Chunk a
20:46:27 <lambdabot> Rainbow.Types chunk :: a -> Chunk a
20:46:29 <iqubic> And the sublists there will Int length long on average.
20:46:48 <Welkin> :t Data.List.Split.chunk
20:46:49 <lambdabot> Int -> [e] -> [[e]]
20:46:52 <Welkin> yes
20:46:58 <iqubic> Now, how do lines and unlines work?
20:47:06 <Welkin> lines and unlines are very simple
20:47:18 <Welkin> @src lines
20:47:19 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:47:19 <c_wraith> Aleph9: also, that library seems..  broken.  I can't figure out how to import half the things the documentation claim are present
20:47:41 <iqubic> :t lines
20:47:42 <lambdabot> String -> [String]
20:47:51 <iqubic> :t unlines
20:47:53 <lambdabot> [String] -> String
20:48:24 <iqubic> Wait?? lines . unlines = unlines . lines = id
20:48:34 <Welkin> you can use splitOn from http://hackage.haskell.org/package/split-0.2.3.2/docs/Data-List-Split.html
20:48:42 <iqubic> If I understand lines and unlines correctly.
20:49:12 <Aleph9> c_wraith: had that problem too, it's split between 'random-fu' and 'random-extras' for some reason
20:49:14 <Welkin> unlines it just `concat`
20:49:17 <Welkin> is*
20:49:48 <sophiag> iqubic: just a thought. you know how unix has two newlines? \n and \r? you can use \r to rewrite your tic-tac-toe lines in place to make a cool cli game
20:49:57 <Welkin> > Data.List.Split.splitOn '\n' "Hello\niqubic"
20:49:59 <lambdabot>  error:
20:49:59 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
20:49:59 <lambdabot>      • In the first argument of ‘splitOn’, namely ‘'\n'’
20:50:05 <Welkin> > Data.List.Split.splitOn "\n" "Hello\niqubic"
20:50:07 <lambdabot>  ["Hello","iqubic"]
20:50:15 <Welkin> > concat $ Data.List.Split.splitOn "\n" "Hello\niqubic"
20:50:16 <lambdabot>  "Helloiqubic"
20:50:19 <Welkin> er
20:50:42 <iqubic> What was that supposed to do?
20:50:42 <Welkin> > cancat . intersperse "\n" $ Data.List.Split.splitOn "\n" "Hello\niqubic"
20:50:44 <lambdabot>  error:
20:50:44 <lambdabot>      • Variable not in scope: cancat :: [[Char]] -> c
20:50:44 <lambdabot>      • Perhaps you meant one of these:
20:50:49 <Welkin> > concat . intersperse "\n" $ Data.List.Split.splitOn "\n" "Hello\niqubic"
20:50:50 <Welkin> oh lol
20:50:51 <lambdabot>  "Hello\niqubic"
20:50:58 <Welkin> it's `id`
20:51:15 <iqubic> sophiag: What are you suggesting?
20:51:34 <Welkin> that is equivalent to `lines` and `unlines`
20:51:42 <iqubic> With Unix having two new lines.
20:52:02 <ChaiTRex> > lines "a\n\nb"
20:52:04 <lambdabot>  ["a","","b"]
20:52:06 <c_wraith> Aleph9: still, https://hackage.haskell.org/package/random-fu-0.2.7.0/docs/Data-Random-RVar.html#t:RVar lists several methods for eliminating RVar
20:52:09 <Welkin> > concat . intersperse "\n\n" $ Data.List.Split.splitOn "\n\n" "Hello\n\niqubic"
20:52:11 <lambdabot>  "Hello\n\niqubic"
20:52:18 <Welkin> > Data.List.Split.splitOn "\n\n" "Hello\n\niqubic"
20:52:19 <lambdabot>  ["Hello","iqubic"]
20:52:31 <iqubic> Welkin: I get what you are doing there.
20:52:54 <iqubic> I don't understand why sophiag was mentioning the unix line breaks.
20:53:01 <mniip> sophiag, you'd need more advanced control sequences than \r
20:53:26 <mniip> like "up" or "clear line"
20:53:50 <iqubic> I still don't get how \n and \r help me.
20:54:05 <sophiag> mniip: true. it was an idea tho
20:54:11 <iqubic> But I think I know what I need to do.
20:54:19 <c_wraith> Aleph9: which one you use should depend on how you want to deal with randomness.  You can use an explicitly constructed PRNG with sampleState, or you can leave the construction details mysterious and use runRVar in IO - but then you need to learn to use IO
20:54:27 <sophiag> iqubic: \r is how those status bars in your package manager work
20:54:58 <sophiag> it moves the carriage back to the left side of the screen
20:55:53 <iqubic> Oh, I did not know that.
20:55:58 <Aleph9> c_wraith: okay, I'll look into both, thanks for the help!
20:56:13 <iqubic> I thought it was just another form of line break.
20:56:32 <mniip> sophiag, I would think they use more advanced escape seuqnces
20:56:53 <Welkin> line-break and carriage-return
20:56:59 <Welkin> as opposed to newline
20:57:11 <Welkin> that's only on windows though
20:57:15 <sophiag> mniip: i'm not certain
20:57:18 <iqubic> So \n only creates the new line? You need \r to actually get to the start of that new line?
20:57:24 <Welkin> *nix/bsd uses newline
20:57:41 <iqubic> I'm running Linux, so I should be fine there.
20:58:10 <sophiag> iqubic: i was saying you can use it to redraw the current line. but for your purposes it doesn't really make sense
20:58:17 <sophiag> to create a newline i'd just stick with \n
20:58:18 <mniip> ooh
20:58:26 <mniip> wget uses \r indeed
20:58:36 <sophiag> i was right about something!
20:58:38 <sophiag> lol
20:58:51 <sophiag> mniip: did you actually look up the source rn?
20:58:56 <mniip> no
20:59:02 <mniip> I hexdumped its output
20:59:05 <sophiag> ah
20:59:06 <iqubic> \r makes no sense for me, because my output will be a few lines long for each board
20:59:10 <Welkin> mniip is russian hacker
20:59:15 <sophiag> hehe
20:59:18 <Welkin> he's in your house
20:59:39 <iqubic> Now, time to try writting this priting function into my code.
20:59:48 <Welkin> he put virus on your coffee maker
21:00:12 <iqubic> But first, how does one work with 2D lists in Haskell.
21:00:21 <Welkin> iqubic: you don't really
21:00:28 <Welkin> lists are not a great data structure
21:00:30 <iqubic> What do you mean?
21:00:36 <Welkin> lists are usually only used as control structures
21:00:39 <Welkin> like a loop
21:00:50 <Welkin> for data, you probably want something else
21:00:54 <Welkin> like a Map
21:00:58 <Welkin> or an Array
21:01:19 <iqubic> If I want to store my game state as a 2D data structure, what should I do?
21:01:26 <Welkin> if you need a 2d data structure, use a 2d array or a map
21:01:52 <Welkin> you could actually also just use a flat array
21:01:56 <iqubic> data Piece = X | O | Blank
21:02:01 <Welkin> like is often done in games written in c
21:02:10 <iqubic> Welkin: How would a flat array work?
21:02:11 <Welkin> and just store the row length for processing
21:02:25 <mniip> Welkin, why if you could use a 2D array
21:02:25 <Welkin> you have an indexing function that is `mod` the row length
21:02:30 <iqubic> Welkin: That's a wonderful idea.
21:02:35 <glguy> If you're going to do something like that, then it's worth using the array package
21:02:49 <iqubic> How does the array package work?
21:02:51 <glguy> That's what it does, plus it handles using more interesting indexes, like tuples
21:03:00 <mniip> and I'm talking about Ix (,) here
21:03:57 <iqubic> How do you use a tuple as an index?
21:06:45 <iqubic> I've only ever seen natural numbers as indexes
21:07:00 <iqubic> so things in the set [0..]
21:07:41 <iqubic> well, I mean [0,1..]
21:08:28 <mniip> > range (3, 5)
21:08:30 <lambdabot>  [3,4,5]
21:08:38 <iqubic> Oh.
21:08:40 <mniip> > range ((3, 2), (5, 4))
21:08:42 <lambdabot>  [(3,2),(3,3),(3,4),(4,2),(4,3),(4,4),(5,2),(5,3),(5,4)]
21:08:51 <iqubic> :t range
21:08:53 <lambdabot> Ix a => (a, a) -> [a]
21:09:44 <iqubic> > range a z
21:09:46 <lambdabot>  error:
21:09:46 <lambdabot>      • Couldn't match expected type ‘Expr -> t’ with actual type ‘[a0]’
21:09:46 <lambdabot>      • The function ‘range’ is applied to two arguments,
21:10:03 <iqubic> > range ('a', 'z')
21:10:05 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
21:10:18 <EvanR> > ['a'..'z']
21:10:19 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
21:10:53 <iqubic> > [(3, 2).. (5, 4)]
21:10:55 <lambdabot>  error:
21:10:55 <lambdabot>      • Ambiguous type variable ‘t1’ arising from a use of ‘show_M829322929335...
21:10:55 <lambdabot>        prevents the constraint ‘(Show t1)’ from being solved.
21:11:15 <iqubic> Darn, I thought that was a short hand for range. Darn
21:11:22 <EvanR> nope
21:11:33 <EvanR> its shorthand for fromEnumTo
21:11:39 <iqubic> oh
21:11:46 <EvanR> er
21:11:48 <iqubic> :t fromEnumTo
21:11:50 <lambdabot> error:
21:11:50 <lambdabot>     • Variable not in scope: fromEnumTo
21:11:50 <lambdabot>     • Perhaps you meant ‘fromEnum’ (imported from Prelude)
21:11:58 <iqubic> :t fromEnum
21:12:00 <lambdabot> Enum a => a -> Int
21:12:03 <tromp> > range ("aa","bb")
21:12:05 <lambdabot>  error:
21:12:05 <lambdabot>      • No instance for (Ix [Char]) arising from a use of ‘range’
21:12:05 <lambdabot>      • In the expression: range ("aa", "bb")
21:12:10 <mnoonan> :t enumFromTo
21:12:11 <lambdabot> Enum a => a -> a -> [a]
21:12:38 <iqubic> tromp: Looks like there is no instance of Ix String
21:13:09 <mniip> such an instance wouldn't be useful
21:13:33 <EvanR> Ix is for types suitable for use an indexes, i.e. they could be mapped into a consecutive numeric order
21:13:39 <iqubic> Because how do you determine the next string in line?
21:13:41 <EvanR> similar to Enum actually
21:14:20 <mniip> Enum is about next/pred
21:14:28 <mniip> Ix is more about range operations
21:14:44 <mniip> 'increment by n', 'distance between', etc
21:14:58 <EvanR> not sure i see a structural diff
21:15:05 <iqubic> Even just using only the letter 'a' I can create a countable infinite number of unique strings.
21:15:26 <iqubic> There's now way to order all the possible strings.
21:15:39 <EvanR> now ... see here
21:15:57 <EvanR> Integer is countable and ordered
21:16:18 <iqubic> or now way that would let you write a suitable Ix instance for String
21:16:23 <EvanR> using only the letter 'a' and 'b', now you have a problem (if you allow infinite)
21:18:31 <mniip> but there is
21:18:41 <mniip> count in base 0x110000
21:18:51 <iqubic> Why are we talking about Ix? How does that help me represent moves on a TicTacToe board?
21:19:19 <EvanR> i know how
21:19:29 <EvanR> first represent a board position
21:19:39 <iqubic> Wait, if we use n symbols, we just need to count in base n to get all the possible strings that can be made from those characters
21:19:42 <EvanR> then two positions amounts to a move
21:20:36 <iqubic> EvanR: What I mean was "How do I represent a board position?"
21:20:45 <iqubic> I typed the wrong thing
21:20:51 <EvanR> an array
21:20:59 <iqubic> 2D or no?
21:21:04 <iqubic> And why not a list?
21:21:04 <EvanR> sure
21:21:18 <EvanR> practically dunno
21:21:29 <EvanR> theoretically its an array
21:21:45 <iqubic> I'll use an array.
21:21:50 <iqubic> :t (!!)
21:21:51 <lambdabot> [a] -> Int -> a
21:22:00 <EvanR> :t (!)
21:22:01 <lambdabot> Ix i => Array i e -> i -> e
21:22:32 <iqubic> But that let's you use things like (2, 3) as the retrieval index
21:22:39 <iqubic> How does that work.
21:22:51 <iqubic> I don't understand Haskell arrays.
21:22:59 <EvanR> pair of indexes has an Ix instance
21:23:02 <Eduard_Munteanu> Have a look at Ix.
21:23:36 <Eduard_Munteanu> @src Ix
21:23:36 <lambdabot> class (Ord a) => Ix a where
21:23:36 <lambdabot>     range     :: (a, a) -> [a]
21:23:36 <lambdabot>     index     :: (a, a) -> a -> Int
21:23:36 <lambdabot>     inRange   :: (a, a) -> a -> Bool
21:23:36 <lambdabot>     rangeSize :: (a, a) -> Int
21:23:46 <iqubic> I keep trying to relate Haskell Arrays to Java Arrays, and I can't do that. They're too different
21:24:16 <iqubic> :t range
21:24:17 <lambdabot> Ix a => (a, a) -> [a]
21:24:18 <mniip> that is correct
21:24:28 <Eduard_Munteanu> > index ((0,0), (7,7)) (2, 3)
21:24:29 <lambdabot>  error:
21:24:29 <lambdabot>      Ambiguous occurrence ‘index’
21:24:29 <lambdabot>      It could refer to either ‘Control.Lens.index’,
21:24:38 <mniip> java arrays just like C are only indexable by int
21:24:50 <Eduard_Munteanu> > Data.Array.Ix.index ((0,0), (7,7)) (2, 3)
21:24:52 <lambdabot>  error:
21:24:52 <lambdabot>      Not in scope: ‘Data.Array.Ix.index’
21:24:52 <lambdabot>      Perhaps you meant ‘Data.Array.index’ (imported from Data.Array)
21:24:58 <Eduard_Munteanu> > Data.Array.Index.index ((0,0), (7,7)) (2, 3)
21:25:00 <lambdabot>  error:
21:25:00 <lambdabot>      Not in scope: ‘Data.Array.Index.index’
21:25:00 <lambdabot>      Perhaps you meant ‘Data.Array.index’ (imported from Data.Array)
21:25:07 <Eduard_Munteanu> > Data.Array.index ((0,0), (7,7)) (2, 3)
21:25:09 <lambdabot>  19
21:25:54 <iqubic> But Haskell Arrays are indexed by anything that has an Ix instance.
21:26:00 <mniip> yes
21:26:19 <iqubic> Also Eduard_Munteanu, that example seems to have returned 0 + 0 + 7 + 7 + 2 + 3
21:26:23 <EvanR> doesnt it have to match the kind of index you made the array with
21:26:30 <Eduard_Munteanu> That's because Ix can translate to Int indexes.
21:26:37 <mniip> EvanR, yes, it's a type param
21:26:45 <iqubic> Ix is powerful.
21:26:49 <mniip> Eduard_Munteanu, no
21:26:55 <mniip> it can translate to Int offsets
21:27:32 <iqubic> Does anyone have a tutorial for Ix and Arrays, or shall I browse the Hackage documentation for a while?
21:27:42 <EvanR> try stuff in ghci
21:28:02 <EvanR> use the types
21:28:17 <iqubic> That's a good idea.
21:30:25 <Koterpillar> > Data.Array.index ((0, 0) (100, 100)) (2, 3)
21:30:27 <lambdabot>  error:
21:30:27 <lambdabot>      • Couldn't match expected type ‘(Integer, Integer)
21:30:27 <lambdabot>                                      -> ((Integer, Integer), (Integer, Intege...
21:30:42 <Koterpillar> ah, ignore me
21:33:35 <iqubic> Data.Array.index ((0, 0), (100, 100)) (2, 3)
21:33:45 <iqubic> > Data.Array.index ((0, 0), (100, 100)) (2, 3)
21:33:47 <lambdabot>  205
21:33:55 <iqubic> Missed a comma Koterpillar
21:35:16 <Koterpillar> > Data.Array.index ((0, 0), (10, 100)) (2, 3)
21:35:18 <lambdabot>  205
21:37:08 <Koterpillar> it's all an off-by-one
21:37:34 <Koterpillar> > Data.Array.index ((0, 0, 0) (99, 99, 99)) (1, 2, 3)
21:37:36 <lambdabot>  error:
21:37:36 <lambdabot>      • Couldn't match expected type ‘(Integer, Integer, Integer)
21:37:36 <lambdabot>                                      -> ((Integer, Integer, Integer), (Intege...
21:37:42 <Koterpillar> > Data.Array.index ((0, 0, 0), (99, 99, 99)) (1, 2, 3)
21:37:44 <lambdabot>  10203
21:37:52 <Koterpillar> okay, that's it, sorry for the spam
21:38:26 <iqubic> I officially have no idea what index for tuples is actually doing.
21:38:29 <EvanR> you could also do (1,1) (100,100)
21:38:35 <EvanR> and be cool like lua
21:39:45 <iqubic> Or have a pre-proccessing flag you can set to tell the compiler whether to start indexing at 0 or 1.
21:39:58 <iqubic> That's what visual basic does.
21:40:38 <mniip> or let both min and max index be variable just like pascal
21:40:41 <iqubic> Literally, in the header every VBasic file you say what number, 0 or 1, that file's arrays are index in
21:40:44 <mniip> oh wait that's what it does
21:43:24 <Koterpillar> iqubic: it's mapping them onto a continuous range that starts from 0
21:43:50 <Koterpillar> > map (Data.Array.index ((0, 0, 0), (99, 99, 99))) [(0, 0, 0), (0, 0, 1), (0, 0, 2), (99, 99, 99)]
21:43:52 <lambdabot>  [0,1,2,999999]
21:48:21 <et09> why is the kind of [] * -> *
21:48:58 <iqubic> I think [] is a bit like ()
21:49:09 <pacak> et09: It takes a type to make a type
21:49:11 <EvanR> not even close
21:49:17 <iqubic> Not sure that's the best comparison to draw
21:49:32 <et09> oh.
21:49:40 <pacak> et09: What is kind of Maybe?
21:49:47 <et09> same right
21:49:51 <pacak> Same
21:49:54 <iqubic> :k Maybe
21:49:55 <lambdabot> * -> *
21:50:00 <et09> i need to take a break after that one lol
21:50:25 <iqubic> Just a takes an a and makes a maybe
21:50:26 <pacak> :k ([])
21:50:28 <lambdabot> * -> *
21:50:31 <pacak> :k ([]) Int
21:50:32 <lambdabot> *
21:50:35 <pacak> :k Maybe
21:50:37 <lambdabot> * -> *
21:50:38 <pacak> :k Maybe In
21:50:39 <lambdabot> error:
21:50:40 <lambdabot>     • Expecting one more argument to ‘'In’
21:50:40 <lambdabot>       Expected a type, but ‘'In’ has kind ‘f0 (Mu f0) -> Mu f0’
21:50:40 <pacak> :k Maybe Int
21:50:42 <lambdabot> *
21:50:54 <iqubic> if a function expects Maybe a, and you give it Nothing, it's still happy
21:51:09 <MarcelineVQ> pacak: why the parens?
21:51:10 <iqubic> :k Nothing
21:51:11 <lambdabot> Maybe a
21:51:18 <pacak> :k [] Int
21:51:19 <lambdabot> *
21:51:44 <iqubic> :k []
21:51:46 <lambdabot> * -> *
21:52:00 <pacak> MarcelineVQ: I expected it to complain, I guess [] is a bit more magical than I expected.
21:52:28 <iqubic> et09: [a] is to Just a as [] is to Nothing
21:52:32 <MarcelineVQ> fair enough, list and tuple can be a little strange somtimes syntax-wise
21:52:50 <mniip> iqubic, completely irrelevant here
21:52:55 <pacak> iqubic: There's a difference between value level and type level.
21:52:56 <iqubic> really?
21:53:07 <iqubic> what the HECK is a value level?
21:53:13 <pacak> Kinds are things from type level.
21:53:34 <mniip> [3] is a value
21:53:38 <pacak> iqubic: 3.1415, Nothing, "hello world".
21:53:38 <mniip> [Int] is a type
21:53:41 <et09> isn't it value level, type level, kind level? (just thinking out loud)
21:53:57 <mniip> et09, fsvo haskell, yes
21:54:02 <et09> like in calculus you have the derivative and integral going up and down
21:54:11 <mniip> recently we've got type ~ kind
21:54:27 * pacak wants dependent types
21:54:27 * iqubic has never fully understood kinds in Haskell
21:54:44 <mniip> iqubic, have you understood types?
21:54:50 <iqubic> Yeah.
21:54:55 <iqubic> I understand types
21:55:01 <iqubic> And data too.
21:55:03 <MarcelineVQ> pacak: you can get pretty far with singletons currently, unwieildy as they can be
21:55:26 <EvanR> iqubic: have you ever seen a type signature like Maybe (->) -> Char
21:55:36 <pacak> MarcelineVQ: Yea, but I've been playing around with idris recently...
21:55:37 <iqubic> no. never.
21:55:44 <EvanR> because it makes no sense
21:55:46 <mniip> that's because it doesn't kindcheck
21:55:47 <EvanR> why? because kinds
21:55:51 <iqubic> not sure what that type signature even means
21:55:57 <EvanR> it means nothing, its invalid
21:56:01 <iqubic> oh.
21:56:10 <EvanR> Maybe takes a type of kind *
21:56:15 <EvanR> :k (->)
21:56:16 <MarcelineVQ> pacak: the sun is rising on dependent haskell, long may the night be
21:56:16 <lambdabot> * -> * -> *
21:56:19 <EvanR> not that
21:56:42 <mniip> dependent types aren't a remedy for everything mind
21:56:58 <mniip> say,
21:56:59 <pacak> mniip: Nothing is :)
21:57:04 <mniip> what's the type of \f g x -> f (g x)
21:58:19 <pacak> (b -> a) -> (c -> b) -> c -> a
21:58:24 <pacak> Something like this I suppose
21:58:29 <EvanR> bzz you didnt put a type signature so we dont know!
21:58:52 <mniip> pacak, I concur
21:58:56 <mniip> I think it's
21:58:57 <mniip> forall (a :: *) (b :: a -> *) (c :: forall (x :: a) -> b x -> *). pi (f :: forall (x :: a). pi (y :: b x) -> c x y) (g :: pi (x :: a) -> b x) (x :: a) -> c x (g x)
21:59:09 <EvanR> oh god
21:59:30 <mniip> you can't prove me wrong because it does typecheck
22:00:50 <mniip> in fact my type is more general than yours
22:01:48 <mniip> if you type-apply b=\_->p and c=\_ _->q
22:02:13 <mniip> you get (p -> q) -> (a -> p) -> a -> q
22:02:30 <iqubic> What the heck is a dependent type?
22:02:52 <MarcelineVQ> iqubic: when the type of something depends on a term/value
22:02:52 <mniip> iqubic, types that depend on values
22:03:01 <iqubic> How does that work?
22:03:09 <iqubic> That makes no sense
22:03:32 <pacak> iqubic: It does in idris.
22:03:48 <mniip> foo :: (x :: Bool) -> (if x then Int else Char)
22:03:52 <mniip> foo True = 3
22:03:56 <mniip> foo False = 'x'
22:04:24 <pacak> s/::/:/
22:05:01 <iqubic> I don't understand
22:05:30 <EvanR> iqubic: rather than a type "depending" on a value... think of it as a family types indexed by (the values of) some other type
22:05:53 <EvanR> so theres a Vect 0 Char, Vect 1 Char, Vect 2, Char, etc
22:06:04 <EvanR> Vect 2 Char, etc, for fixed length lists
22:06:30 <EvanR> these are all different types
22:07:33 <EvanR> the "cool" part here is (++) :: Vect m a -> Vect n a -> Vect (m + n) a
22:07:53 <EvanR> value level computation at the type leve
22:10:23 <pacak> and this + is regular + you can use for adding values, not some trickery you have to do in haskell.
22:11:44 <MarcelineVQ> pacak: that is haskell :>
22:12:07 <u-ou> so we are expressing types with values?
22:12:17 <u-ou> Integer is a family of types?
22:12:27 <EvanR> indexing types by values
22:12:32 <EvanR> Integer is a single type
22:12:39 <u-ou> ok
22:13:11 <EvanR> m and n would be some kind of natural number type
22:13:32 <EvanR> elements of such a type*
22:13:53 <EvanR> Vect :: Nat -> Type -> Type
22:14:36 <EvanR> let your mind thusly be blown
22:14:47 <u-ou> what is Type
22:14:56 <EvanR> the type of types
22:15:07 <EvanR> Char :: Type
22:15:15 <u-ou> :D
22:16:12 <EvanR> youve always seen it written * in haskell
22:16:27 <u-ou> wait, so there are types at the value level as well?
22:16:33 <EvanR> no
22:16:57 <EvanR> or yes, you can manipulate types like values
22:17:08 <EvanR> [Char, Int, Bool] is a [Type]
22:17:21 <EvanR> we already have that in haskell with datakinds
22:17:26 <u-ou> can you return Char
22:17:36 <EvanR> sure
22:17:46 <EvanR> from a [Type] -> Type
22:18:58 <EvanR> i think this last example would be on something like 3rd higher type universe...
22:19:45 <EvanR> if haskell didnt smush them all into one
22:22:27 <EvanR> u-ou: you can also get the effect of "returning Char" with type families... an existing technology
22:27:21 <iqubic> Question: Is there a funtion
22:28:00 <iqubic> Is there a function with type: [a] -> a -> [a], that acts like intersperse?
22:28:21 <iqubic> :t intersperse
22:28:22 <lambdabot> a -> [a] -> [a]
22:28:31 <EvanR> flip intersperse?
22:28:33 <MarcelineVQ> :t flip intersperse
22:28:34 <lambdabot> [a] -> a -> [a]
22:28:36 <iqubic> Yeah, that.
22:28:39 <iqubic> LOL
22:28:51 <iqubic> I though intersperse was only for strings.
22:29:14 <iqubic> Still not use to Haskell using String and [Char] interchangable.
22:29:27 <EvanR> @src String
22:29:27 <lambdabot> type String = [Char]
22:29:29 <thang1> My deep agony: I want to apply for real jobs and do all this cool stuffbut the only reason I'm in school in the first place is so that I can get a PhD in order to do what I really wanna do... *sigh*
22:29:56 <iqubic> let me guess: flip f x y = f y x 
22:30:02 <thang1> iqubic: Why isn't that sorta normal? A lot of languages treat strings as "lists"/arrays of characters
22:30:04 <Axman6> yep
22:30:05 <iqubic> Is that how that works?
22:30:14 <Axman6> @src flip
22:30:14 <lambdabot> flip f x y = f y x
22:30:42 <iqubic> thang1: I don't think Java treats Strings as an array of chars.
22:30:45 <iqubic> Not sure though
22:31:07 <thang1> technically they're separate, but you can willy nilly cast in between representations
22:31:09 <iqubic> Time to spend a few hours learning about profunctors now.
22:31:38 <thang1> myStr.toCharArray(); myChrArray.toString(); etc
22:31:47 <EvanR> what are strings really, what are arrays really
22:31:56 <iqubic> using this video: https://www.youtube.com/watch?v=OJtGECfksds
22:33:10 <MarcelineVQ> idk if profunctors is time well spent when just starting out, not that I speak from experience
22:34:01 <EvanR> to get profunctors, i think you need to get contrafunctors
22:34:40 <thang1> I'm lucky if I get what a functor is :p
22:35:08 <thang1> But yeah, idk if a 2 hour lecture  is a good use of time without a lot of background knowledge...
22:35:41 <thang1> Specifically since that particular talk assumes a knowledge and understanding of Van Laarhoven lenses
22:35:43 <piyush-kurur> hvr: ping
22:36:01 <hvr> piyush-kurur: pong
22:36:32 <piyush-kurur> hvr: do you have z3 in any of your ppa so that I can use it with travis
22:37:01 <piyush-kurur> I am trying out liquid haskell. It looks like the ubuntu image on travis does not have any of the solvers needed
22:37:38 * hackage qr-imager 1.0.1.1 - Library to generate QR codes from bytestrings and objects  https://hackage.haskell.org/package/qr-imager-1.0.1.1 (vmchale)
22:37:41 <hvr> piyush-kurur: as it happens, I have: https://launchpad.net/~hvr/+archive/ubuntu/z3
22:38:12 <piyush-kurur> hvr: you are awesome. Can I use this with travis in the sudo:false mode
22:38:49 <piyush-kurur> They (travis) seem to have a huge bureaucracy for authenticating ppas 
22:38:50 <hvr> piyush-kurur: not sure... you may have to try
22:39:12 <piyush-kurur> thanks any way
22:39:47 <Lokathor> @pl \s1 s2 -> fmap (either die return) (programFromSources s1 s2)
22:39:47 <lambdabot> (fmap (either die return) .) . programFromSources
22:40:10 <cocreature> hvr: that package is quite old, 4.5 was released sometime last year
22:40:29 <EvanR> Lokathor: .: again
22:41:21 <MarcelineVQ> I kinda like pointful but infixed  either die return <$> programFromSources s1 s2
22:41:39 <thang1> Realtalk: Does anyone find (fmap (either die return) .) . programFromSources  more readable than the other one?
22:41:48 <Lokathor> MarcelineVQ, that's actually what i just juggled it around to
22:41:54 <thang1> because that looks like incomprehensible gibberish to me
22:41:57 <Lokathor> EvanR, what?
22:42:12 <MarcelineVQ> thang1: I'm fine with  (foo .) . bar  but not a single thing more
22:42:22 <EvanR> i dont recommend the pointless here but its fmap (either die return) .: programFromSources
22:42:36 <MarcelineVQ> (foo blah .) . bar   is too much for example
22:42:41 <Lokathor> let compileOrDie = \s1 s2 -> either die return <$> programFromSources s1 s2
22:42:44 <Lokathor> i think i'll settle on that
22:43:27 <MarcelineVQ> oh hmm, might prefer functions in where so they're easy to move out when needed
22:43:30 <thang1> what does "(foo .) . bar" do anyway? I have trouble mentally parsing the ( .) part
22:43:50 <EvanR> (f .) . g is something that if not stopped will become laughing stock of people looking at haskell people in 2040. alternatively everything will think thats normal in 2040
22:44:03 <EvanR> everyone*
22:44:20 <thang1> MarcelineVQ: might as well worry about that later, I guess. Refactoring in haskell is painless compared to other languages so why worry about pulling out functions until you know what you'll need?
22:44:32 <MarcelineVQ> put as informally and awfully as possible, give bar an argument and compose the partially applied bar with foo to expect another argument
22:45:09 <Lokathor> thang1, "painless"
22:45:24 <EvanR> it lets you rewrite \x y -> f (g x y) as (f .) . g, or with cool operators f .: g
22:45:33 <MarcelineVQ> EvanR: in 2040 machines will write the haskell for you
22:45:41 <EvanR> ... right
22:45:52 <EvanR> that was supposed to be happening in 1999
22:45:59 <Lokathor> I think the Culture decided not to contact Earth in book 4, so we're gonna be stuck here a while
22:46:06 <cocreature> just replace "(f .) . g" by "fmap fmap fmap f g"
22:46:08 <Lokathor> writing all our own code
22:46:21 <thang1> cocreature: MarcelineVQ that actually helped... somehow
22:47:06 <EvanR> \x y z -> f (g x y z) can be f .:: g
22:47:18 <EvanR> let (.::) = (.) . (.) . (.)
22:47:21 <EvanR> :t (.::)
22:47:23 <lambdabot> error: Variable not in scope: .::
22:47:37 <EvanR> > let (.::) = (.) . (.) . (.)
22:47:38 <EvanR> :t (.::)
22:47:39 <lambdabot>  <no location info>: error:
22:47:39 <lambdabot>      not an expression: ‘let (.::) = (.) . (.) . (.)’
22:47:39 <lambdabot> error: Variable not in scope: .::
22:47:51 <EvanR> nevermind
22:47:55 <thang1> lol
22:47:59 <thang1> :t (.:)
22:48:01 <lambdabot> error:
22:48:01 <lambdabot>     • Variable not in scope: .:
22:48:01 <lambdabot>     • Perhaps you meant one of these:
22:48:13 <EvanR> @let (.:) = (.) . (.)
22:48:14 <MarcelineVQ> it's a mad house
22:48:14 <lambdabot>  Defined.
22:48:18 <EvanR> :t (.:)
22:48:19 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
22:48:29 <thang1> @let (.::) = (.) . (.) . (.)
22:48:31 <lambdabot>  Defined.
22:48:34 <thang1> :t (.::)
22:48:35 <lambdabot> (b -> c) -> (a2 -> a1 -> a -> b) -> a2 -> a1 -> a -> c
22:48:38 <EvanR> all is clear now
22:48:50 <thang1> ಠ_ಠ a quote about the atomic bomb comes to mind
22:49:06 <mniip> :t fmap (fmap fmap fmap) (fmap fmap fmap)
22:49:07 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f3 (f2 (f1 (f a))) -> f3 (f2 (f1 (f b)))
22:49:17 <EvanR> its functors all the way down
22:49:32 <thang1> yo dawg, I heard you like to fmap, so I wrote an fmap on your fmap so you can fmap fmap fmap fmap
22:49:51 <EvanR> fmap seems to be unable to be wrong
22:50:03 <EvanR> > fmap `fmap` fmap (fmap fmap)
22:50:04 <lambdabot>  error:
22:50:05 <lambdabot>      • No instance for (Typeable f1)
22:50:05 <lambdabot>          arising from a use of ‘show_M608337224326317572723778’
22:50:07 <EvanR> :t fmap `fmap` fmap (fmap fmap)
22:50:09 <lambdabot> (Functor f, Functor f2, Functor f1) => (a1 -> f2 (a -> b)) -> f1 a1 -> f1 (f2 (f a -> f b))
22:50:15 <thang1> lol wtf is that show instance
22:50:26 <thang1> show_M6083372.... how does it come up with that?
22:50:30 <MarcelineVQ> lambdabot doing the best it can with awful humans
22:50:36 <cocreature> I’m kind of annoyed that "fmap fmap fmap fmap fmap" is not "(.) . (.) . (.)"
22:50:50 <mniip> mueval generates some idetifiers
22:51:00 <EvanR> :t (fmap fmap) fmap (fmap fmap)
22:51:01 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => f3 (f2 (f1 (a -> b))) -> f3 (f2 (f1 (f a -> f b)))
22:51:10 <EvanR> i dont even care anymore...
22:52:01 <cocreature> :t fmap `fmap` fmap `fmap` fmap
22:52:02 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
22:52:19 <Lokathor> oh look at that
22:52:30 <Lokathor> by just using fromJust <$> i can eliminate two levels of indentation
22:52:35 <mniip> I wonder what is the most compact expression
22:52:35 <EvanR> isnt that just three fmaps?
22:52:41 <Lokathor> C in any language folks!
22:52:45 <thang1> fromJust? ಠ_ಠ
22:52:56 <EvanR> dont ask
22:53:08 <MarcelineVQ> > fromJust Nothing
22:53:08 <thang1> I know what it is, I'm just amused why he needs it :p
22:53:10 <lambdabot>  *Exception: Maybe.fromJust: Nothing
22:53:21 <EvanR> thats what i was saying
22:53:38 <Lokathor> thang1, because GLFW might fail to create a window when you ask it to. And if it does, the program is useless anyway, so might as well use fromJust <$> on that 
22:53:47 <EvanR> ;_;
22:53:51 <MarcelineVQ> :<
22:53:54 <thang1> The only legit reason I've seen to use fromJust so far is I'm going through the Haskell Book and it assumes an unsafe Head function and I'm using the total functions from the protolude
22:53:55 <cocreature> who needs fromJust if you can just use unsafeCoerce to get a function Maybe a -> a
22:54:02 <thang1> ^
22:54:20 <EvanR> thang1: you used safeFromJust ?
22:54:25 <thang1> Lokathor: you hurt my soul. Why even have a maybe in there if you don't care about the "nothing" value?
22:54:29 <mniip> @let safeFromJust = maybe Just Nothing
22:54:30 <lambdabot>  .L.hs:162:27: error:
22:54:31 <lambdabot>      • Couldn't match expected type ‘a1 -> a -> Maybe a’
22:54:31 <lambdabot>                    with actual type ‘Maybe a0’
22:54:44 <mniip> @let safeFromJust = maybe Nothing Just
22:54:45 <lambdabot>  Defined.
22:54:59 <thang1> oooh
22:55:02 <cocreature> thang1: sometimes you are using a library where you know that if you pass it certain inputs you’ll always get a Just back. in that case fromJust is fine
22:55:13 <liste> :t safeFromJust
22:55:13 <EvanR> Lokathor: probably better to print out GLFW's error message then throw an IO error
22:55:14 <lambdabot> Maybe a -> Maybe a
22:55:24 <Lokathor> thang1, it is the completely correct decision for the bindings authors to have the return type be Maybe Window
22:55:45 <Lokathor> EvanR, GLFW-b isn't setup like that. You have to assign an error callback and /that/ prints the error
22:55:53 <thang1> That's the sort of situation I was using it in. Mostly re-implementing things where the book author forces an explicit type instead of a maybe type, so Int -> Int and I used a head function which returns a Maybe Int, so then I have to unbox the maybe... that sorta thing
22:55:57 <Lokathor> thang1, so it looks like this http://lpaste.net/355904
22:56:00 <EvanR> Lokathor: ah. you should do that ;)
22:56:37 <EvanR> C coding without handling errors is asking for monkeys to fly out of your nose
22:56:37 <Lokathor> EvanR, only cause of the winky face
22:57:03 <cocreature> s/without handling errors//
22:58:03 <thang1> Should I stay up all night and fight the enormous pile of homework I've procrastinated on?
22:58:05 <Lokathor> setErrorCallback (Just $ \error msg -> print error >> putStrLn msg)
22:58:12 <EvanR> \o/
22:58:49 <EvanR> hPutStrLn stderr (show error ++ " " ++ msg); exitFailure;
22:59:02 <EvanR> Nothing -> hang -- waiting for error callback
22:59:09 <pacak> mniip: that's acme-safe
22:59:11 <thang1> 2 projects due tomorrow, 1 project and 2 giant homework assignments due tuesday. Yay!
22:59:38 <cocreature> thang1: better get some sleep and wake up early and do your homework then :)
22:59:38 <thang1> How did GLFW manage to make haskell look java ugly?
22:59:55 <EvanR> you should see the java bindings
23:00:04 <thang1> ಠ_ಠ do I want to?
23:00:07 <Lokathor> thang1, perhaps because I used a qualified import?
23:00:09 <EvanR> no
23:00:21 <thang1> I'll take your word for it :p
23:00:35 <Lokathor> thang1, my font doesn't support your eyes, they're big unicode error squares
23:00:56 <thang1> Lokathor: naah that's not it. WindowHint'OpenGLProfile is ugly in any language
23:01:21 <Lokathor> oh that part
23:01:23 <EvanR> http://i.imgur.com/TrKrVqB.png
23:01:37 <Lokathor> well I applaud any bindings engine that's as 1:1 as possible, honestly
23:01:52 <Lokathor> since you usually don't have full docs in the new version, you have to look at the C version, so 1:1 makes it easier
23:01:55 <thang1> Lokathor: You need an indic font I believe
23:02:27 <thang1> Well in this particular instance, it's probably a good choice that they made it 1:1, but the function names are still ugly to me.
23:02:35 <Lokathor> though, glfw-b accepted my pull request for more docs, so now there's more docs
23:02:45 <thang1> I prefer fnktn f s t a b b y. Much more clearer
23:02:51 <EvanR> since GLFW should be only on the very outside crunchy IO shell, shouldnt really amtter
23:02:52 <Lokathor> of course
23:03:00 <EvanR> get out of there as fast as you can and into haskell
23:03:17 <Lokathor> EvanR, my program is a 200 line IO block :P
23:03:34 <thang1> /but why/
23:04:02 <Lokathor> well, it's about using opengl, so, there's not much to do outside of IO
23:04:07 <EvanR> imagine if haskell still had old I/O
23:04:10 <Lokathor> i mean there /are/ non IO portions, but not so many
23:04:15 <thang1> old IO?
23:04:27 <EvanR> lazy list I/O
23:04:33 <thang1> oh yeah that nightmare
23:05:12 <EvanR> would be interesting to see Lokathor's 200 lines in that ;)
23:05:42 <Lokathor> it'd be interesting to see any opengl program in that :P
23:05:44 <thang1> EvanR: how did things even work with the old lazy list IO?
23:06:12 <thang1> inb4 "poorly"
23:06:13 <EvanR> you had an input stream, your program had to construct an output stream
23:07:13 <Lokathor> https://github.com/Lokathor/learnopengl/blob/master/app/Lesson07.hs here's the last working version. It accrued a lot of cruft so I'm cleaning out some of that as I move into the next arc of lessons
23:07:29 <thang1> That actually doesn't sound terrible. I mean, I'm sure it was, but I was expecting a bit more ugly :p
23:11:56 <thang1> :t foldMap
23:11:58 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
23:12:35 <et09> elof :: Int -> [a] -> Maybe a
23:12:37 <et09> x `elof` xs = let xslen = length xs in if ((abs x) > xslen) then Nothing else Just (xs !! (x `mod` xslen))
23:12:39 <thang1> hmm, so literally a fold... and a map
23:12:43 <et09> my array index function lol
23:12:49 <et09> is that bad 
23:13:34 <thang1> Well [] isn't an array, elof is a weird name, idk why you have a let in source code haskell, and the time complexity of the function is horrific
23:13:54 <MarcelineVQ> let is very common and totally fine :>
23:14:14 <EvanR> thang1: a map, then a fold...
23:14:33 <thang1> Really? I didn't even know you could use let inside source code haskell. I thought it was entirely for ghci. Shows how much I know :p
23:14:37 <MarcelineVQ> I wouldn't be surprised if most work gets done in lets :X
23:14:38 <et09> the time complexity is bad?
23:14:47 <thang1> EvanR: that's what I meant, m'bad
23:14:47 <EvanR> @src fix
23:14:47 <lambdabot> fix f = let x = f x in x
23:15:02 <EvanR> let _ = _ in _ is one of the basic formations
23:15:16 <EvanR> it lets you share answers explicitly
23:15:28 <thang1> But other than that, I suppose it's not bad since it should do what you want. I just dunno why you even want an array index function, to be honest, et09
23:15:36 <thang1> EvanR: makes sense
23:15:42 <et09> it's a common idiom
23:15:45 <EvanR> where clause desugars to let
23:16:09 <thang1> ahh that clears things up a bit. I use where often, just didn't realize it desugared to let
23:16:23 <thang1> et09: array indexing isn't a common idiom in functional programming, however :p
23:16:31 <mark___> Hi, I'm learning haskell and am having issues getting something to typecheck.  It's an exercise from "Haskell from first principles", which I've copied here https://pastebin.com/raw/X71nFWpW
23:16:34 <et09> it happens 
23:16:37 <et09> nonetheless
23:17:01 <et09> what's wrong with the time complexity ?
23:17:26 <EvanR> mark___: i see the error, but have you tried reading the compiler error
23:17:31 <EvanR> message
23:18:16 <mark___> I did, but I was confused because I thought rocks took as input [char] and I was giving it that.
23:18:39 <EvanR> what does Papu take
23:19:09 <thang1> mark___: this sort of thing tripped me up for a bit during the chapter as well
23:19:10 <EvanR> you might get a better message by giving phew and top level type signature
23:19:28 <EvanR> a signature like phew :: Papu
23:20:41 <mark___> Oh, does it have to be (Rocks "chases") (Yeah True)?
23:20:51 <thang1> Yeah
23:21:00 <MarcelineVQ> et09: a problem is that you have to traverse the whole list due to using length, which means with an infinite list your function won't terminate.
23:21:15 <et09> oh, true
23:21:18 <MarcelineVQ> instead of asking for the length consider recursively calling eleof with a smaller x each time, if you reach the end of the list before x becomes 0 then x was larger than the length of xs
23:21:27 <thang1> You're constructing a Rocks and Yeah "object" (idk what to actually call them), but you can't do that without using the constructors, mark___ 
23:21:40 <et09> i was assuming the list was predefined and non-infinite
23:21:46 <MarcelineVQ> and if you reach zero, the head of the list is the element you want, I think
23:21:56 <pacak> > let foo i xs = listToMaybe $ map snd . dropWhile ((/= i) . fst) $ zip [1..] xs in foo 3 "abcde"
23:21:57 <thang1> in Papu "chases" True, you're just passing in a String and a Bool to Papu, but Papu takes a Rocks and Yeah, not String and Bool
23:21:58 <lambdabot>  Just 'c'
23:22:02 <et09> it's surprising iterating one at a time would be faster...
23:22:12 <et09> in C you could just skip forward in memory 
23:22:22 <EvanR> lists do not have their length stored anywhere
23:22:26 <EvanR> its just a linked list
23:22:28 <MarcelineVQ> to compute the length of a list you have to visit each element because it's a single-linked-list
23:22:36 <et09> ah.  well that figures, since it's a bit like LISP 
23:22:44 <MarcelineVQ> so if you're going to visit every element you may as well try not to
23:22:46 <thang1> There's a length, a conditional, comparison, then !! (which also traverses the list), and a mod function
23:22:48 <Lokathor> EvanR, usingVertexArray :: MonadIO m => VertexArrayID -> m () -> m () -- such type safety!
23:22:55 <EvanR> and these can be infinite, so a length may not even make sense
23:22:57 <et09> but then i can't do a reverse index
23:23:05 <et09> which defeats the purpose
23:23:08 <EvanR> you can make an index
23:23:11 <pacak> et09: reverse index?
23:23:15 <EvanR> but then you might as well not use  alist
23:23:18 <thang1> Can you see why combining all of that together in a function might be a bit slower than just iteration? :p
23:23:20 <et09> yeah like [1,2,3,4][-1] = 4
23:23:36 <EvanR> youre tihnking about an entirely different data structure there
23:23:43 <pacak> et09: You can't because there might be no right end.
23:23:55 <et09> well you can, it can just fail spectacularly, lol
23:23:57 <thang1> Just because python abuses syntactic sugar to do that sort of thing doesn't mean that you can think of python lists as real lists
23:24:02 <EvanR> lists in haskell are more like control structures
23:24:16 <EvanR> to do [1,2,3,4][-1] use a Data.Sequence
23:24:46 <thang1> EvanR: would a vector work? Or are vectors for differnt things in haskell?
23:24:50 <pacak> > fix (1:)
23:24:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:25:05 <EvanR> vector works but you cant modify them as if it were a "queue"
23:25:20 <EvanR> different trade offs
23:25:45 <thang1> ahh right. I'm still used to vectors being a catch all data structure like they are in C++
23:25:55 <et09> Data.Sequence.fromList :: [a] -> Seq a
23:25:56 <et09> lol
23:26:01 <EvanR> no catch all DS in haskell, except for acme-php
23:26:40 <thang1> It's weird to have all of these different structures which are actually useful for different things, yet... haskell still has linked lists embedded /deeply/ into the syntax structure of the language and it makes every other DS out there feel like a distant cousin instead of a first class citizen
23:26:59 <EvanR> the syntax sugar is basically the only difference
23:27:02 <EvanR> @src []
23:27:02 <lambdabot> data [] a = [] | a : [a]
23:27:09 <EvanR> its just a data structure
23:27:43 <thang1> There's list comprehensions too, though. And the fact that lists took : away from type signatures
23:27:43 <p0a> Hello suppose I want to write the function f x = g x
23:27:53 <EvanR> yes
23:27:56 <EvanR> its all superficial
23:27:56 <p0a> I don't know g's type but I'd like f to have the same type. How do I do this?
23:28:11 <EvanR> list comprehensions are sugar
23:28:31 <thang1> and < and { aren't available to use for convenient notation so you can't write {a} or <a>, leaving lists with the only really convenient way to write [a]
23:28:46 <thang1> Sure, but sugar adds up and lists have buckets of sugar compared to any other data structure in haskell
23:28:53 <EvanR> how many ways do you need to write [a] ;)
23:28:56 <Lokathor> thang1, an array backed list is just as real a list as a linked list :P
23:29:02 <p0a> I guess :t is convenient. I was just wondering if there's a way to let the language know I want f to have the same type as g
23:29:12 <p0a> but I'll just use :t really
23:29:27 <MarcelineVQ> :t tells you the type it doesn't tell ghc
23:29:28 <lambdabot> error: parse error on input ‘type’
23:29:29 <EvanR> thang1: idris overloads this sugar... anything with ctors Nil and (::) use [ ] sugar... and its pretty bad :)
23:29:42 <p0a> MarcelineVQ: yeah I can tell ghc after I learn the type from :t
23:29:50 <EvanR> Lokathor: a what o_O
23:29:51 <MarcelineVQ> what you've wrote is just   f = g  and f will have the same type as g with that
23:30:05 <p0a> MarcelineVQ: oh so it's pointfree style that I'm looking for
23:30:17 <MarcelineVQ> well it's also the same as f x = g x
23:30:25 <p0a> How would you write divides' a b = (rem b a) == 0 pointfree?
23:30:33 <p0a> I'm very new
23:30:37 <thang1> I'm not suggesting we borrow idris [] sugar :p I'm just lamenting how it feels like all data structures don't have the same ability to give easy and convenient notation the same way that lists do
23:30:42 <Lokathor> EvanR, python's list type is an array backed, growable structure, like an ArrayList<T> in Java, or whatever else similarity you care to name
23:30:49 <MarcelineVQ> I'm not sure I would, it's pretty clear the way it is, allthough you can drop the parenthesis
23:30:58 <thang1> I'm not suggesting that every kinda DS out there needs access to [a,b] notation :p
23:31:06 <EvanR> thang1: well, Seq does have front and back views and pattern synonyms
23:31:10 <EvanR> er, view patterns
23:31:13 <p0a> It gives you an error if you don't give it the type divides' :: Integral a=> a-> a-> Bool
23:31:29 <p0a> Yes the parentheses may be dropped but I'd rather have them since I'm a beginner
23:31:32 <EvanR> Lokathor: im not sure either of those acts like or is like a haskell list
23:32:11 <Lokathor> EvanR, oh absolutely they're not at all. They're more like the Vector type if it had wrappers to self-resize when necessary
23:32:17 <EvanR> thang1: and all these other structures are a lot more complex...
23:32:27 <MarcelineVQ> What is the error? There shouldn't be anything amiss with that
23:32:37 <MarcelineVQ> @let divides' a b = (rem b a) == 0
23:32:39 <lambdabot>  Defined.
23:32:46 <MarcelineVQ> @let fub = divides'
23:32:47 <lambdabot>  Defined.
23:33:02 <Rotaerk> how long do these lets last in lambdabot anyway?
23:33:10 <p0a> No instance for (Integral a) arising from a use of 'rem'
23:33:17 <MarcelineVQ> not long with a few people playing about :>
23:33:32 <Lokathor> thang1, if you want more data structures as literals in your code, note that many structures support a fromList function, and so you can use that a lot of the time
23:33:33 <p0a> No instance for (Eq a) arising from a use of '==' etc
23:33:52 <MarcelineVQ> Ah is this in a source file?
23:33:56 <p0a> yes
23:34:09 <thang1> True. I suppose when I get to writing more complex haskell code I won't really notice any lacking data structure magic :p
23:34:23 <thang1> After all, I don't really notice many advanced haskell programmers complaining about it
23:34:55 <EvanR> the operations an IntMap or HashMap comes with are so extensive, its like... you dont actually use the api much ;)
23:35:04 <EvanR> a couple calls and the job is done
23:35:08 <Lokathor> thang1, you'll just need to learn the art of advanced operators :P  they get fancier, like pos ^+^ (speed *^ normalize moveVector)
23:35:35 <Lokathor> EvanR, the biggest letdown about Vector.Storable.Mutable is that it has nearly nothing for API compared to Vector.Storable
23:35:46 <EvanR> makes sense
23:36:13 <EvanR> IO gonna IO
23:36:21 <Lokathor> well, VS has both generate and generateM, and VSM couldn't sensibly have generate, but it doesn't even have generateM
23:36:42 <Lokathor> you gotta setup a goofy replicateM situation
23:36:46 <thang1> advanced operators feel like a bit of a working around for things, but at least you can use advanced operators instead of the verbose and terrible java situation where you have "standard names for methods"
23:37:31 <Lokathor> thang1, edk provides good enough documentation in the Linear package, and it's a grounded concept
23:37:38 <Lokathor> lenses... oh dear i wish i knew how to use them
23:38:02 <EvanR> i want + is be usable for vectors and for numbers
23:38:05 <Lokathor> my next "using haskell" tutorial arc will perhaps have to be a lenses
23:38:38 <p0a> What's wrong with filter' (x:xs) = (if (f x) then x else []) : filter' f xs
23:38:42 <Lokathor> EvanR, Linear puts a ^ on the side of an operator that takes a vector, so ^+^ is two vectors added, and ^* is "vector times scalar"
23:38:50 <EvanR> right but specifically adding
23:38:53 <thang1> I feel like the easiest way to get started with lenses is just writing more complex records and then going "ahhh shit I need to access this thingey" and then figuring out how to use the ^. or whatever it's called and then just going from there
23:39:00 <EvanR> its conventional to just add vectors
23:39:02 <p0a> There's two more lines; one (a -> Bool) -> [a] -> [a] and another matching filter' f [] = []
23:39:18 <EvanR> its not a different kind of operator
23:39:18 <p0a> Huh [] : [] is not [] as I thought
23:39:22 <Lokathor> p0a, remember that you can't do ([] : more) unless you're tying to make a list of lists
23:39:31 <p0a> I guess "" : [] ?
23:39:33 <thang1> Lokathor: But, like I said, it feels kinda hackisy to say ^+^ instead of just + for vectors. I know I'm adding stuff and tne type signature can figure out that I'm adding vectors, so... why the hand waving?
23:39:46 <Maxdamantus> "" is a restricted form of []
23:39:51 <EvanR> thang1: the issue is + is tied up with * in the Num class
23:39:52 <p0a> Lokathor: is there some x that I can use x : list == list ?
23:39:57 <EvanR> vectors arent numbers, you cant multiply them
23:40:05 <quchen> p0a: No.
23:40:19 <thang1> EvanR: you can't define operators in multiple places and have them be distinguishable by types?
23:40:22 <p0a> no one liner for me then
23:40:24 <Lokathor> p0a, well you need to reconsider how much of your code is being affected by the "if" part
23:40:42 <Lokathor> EvanR, GLSL says otherwise ;P
23:40:42 <Maxdamantus> thang1: you can do that with classes, sometimes.
23:40:43 <p0a> Lokathor: ?
23:41:07 <Maxdamantus> thang1: but each use of that identifier will be referring to the member of that class.
23:41:09 <EvanR> thang1: type directed name disambiguation? another thing in idris that never works right
23:41:17 <Lokathor> p0a, consdier like this, filter' (x:xs) = if (f x) then includeResult else excludeResult
23:41:24 <quchen> filter p (x:xs) = (if p x then (x:) else id) (filter f xs) -- one-liner, p0a 
23:41:37 <EvanR> and once you have to write MyCoolModule.(+) you lost
23:41:41 <thang1> EvanR: I still maintain it's a great idea when someone figures out how to make it not suck :p
23:41:42 <p0a> What's wrong with this code? problem1 doesn't work. http://lpaste.net/355905
23:41:52 <Lokathor> quchen, it seems like they're a little more of a beginner than that >_>
23:42:19 <p0a> quchen: okay that's pretty good. I had forgotten about currying!
23:42:40 <EvanR> thang1: haskell relies a lot on type inference... when it has to infer your implicit types and also what name you were trying to use... based on a type it doesnt know for sure you meant... it gets real ugly
23:43:06 <EvanR> if you never made mistakes, it would work out of course
23:43:13 <thang1> That's fair. I keep forgetting about type inference since I write my types out 99% of the time
23:43:19 <EvanR> no you dont ;)
23:43:28 <EvanR> only top level probably
23:44:09 <quchen> p0a: Remember that »:« prepends a single element to a list. There is no single element that, when prepended to anything, does not change the list – so there can not be an »x« such that »x : list = list«.
23:44:11 <thang1> hah, good point. I write top level signatures 99% of the time and every time the compiler complains about ambigious number/string literals, I fix that, but other than that...
23:44:26 <thang1> So yeah, I guess a lot more of my programs are implicitly typed than I think :p
23:44:39 <quchen> p0a: For special lists it’s possible of course, »x : repeat x = repeat x« for example.
23:44:52 <p0a> quchen: yeah I just realized that I needed to create a reversed list for that trick to work, i.e. (filter' p xs) : (if f x then x else [])
23:44:56 <EvanR> if it were like old C++, every where clause and let would be signatured
23:44:58 <p0a> quchen: that's a dirty lisp trick
23:45:18 <quchen> That will not only filter, but also reverse your input.
23:45:36 <quchen> Dirty tricks usually produce correct results.
23:46:01 <quchen> Your filter function won’t terminate on infinite inputs, for example.
23:46:07 <p0a> well you have a reverse and a helper lambda function doing the actual recursion
23:46:09 <quchen> e.g. filter isPrime [1..]
23:46:22 <thang1> :t isPrime
23:46:23 <lambdabot> error:
23:46:23 <lambdabot>     • Variable not in scope: isPrime
23:46:23 <lambdabot>     • Perhaps you meant ‘isPrint’ (imported from Data.Char)
23:46:28 <p0a> infinite inputs were not a thing in the language I was writing back when
23:46:30 * thang1 is sad this does not exist
23:46:32 <EvanR> Integer -> Bool
23:46:39 <EvanR> its in arithmoi package among others
23:46:48 <MarcelineVQ> thang1: it exists, it's just not in scope at the moment
23:46:48 <quchen> p0a: You also don’t have »filter (const True) = id«.
23:46:57 <thang1> Well I figured it existed /somewhere/ :p 
23:47:10 <thang1> Haskell nerds wouldn't stand to have a prime checking function undefined
23:47:12 <p0a> quchen: why?
23:47:25 <thang1> p0a: infinite inputs are part of the magic of lazy languages, so welcome to insanity :p
23:47:26 <quchen> p0a: Because you’re reversing the list
23:47:28 <p0a> by the way I do enjoy this discussion but its the lpaste link I'm wondering about 
23:47:52 <p0a> quchen: oh yes then add a 'reverse' in front of it and recurse afterwards
23:48:13 <quchen> p0a: Then you’re traversing the list twice, once for filter, and once again for another reverse.
23:48:34 <p0a> well you'd be surprised how often that's done in lisp
23:49:04 <EvanR> surely not on a regular linked list?
23:49:20 <EvanR> some kind of whiz bang other structure
23:49:31 <p0a> on a whatever list sometimes it is the case that you have (reverse (func list)) just because it's cute 
23:49:38 <Lokathor> Rust picked slightly less than the correct amount of type inference I think :/
23:49:41 <p0a> or perhaps it was a beginners thing 
23:50:05 <thang1> Well lisp is special, the entire everything is lists. LISP literally stands for LISt Processing
23:50:12 <quchen> ?define filterP0a _ [] = []; filterP0a p (x:xs) = filterP0a p xs ++ if p x then [x] else []
23:50:13 <lambdabot>  Defined.
23:50:17 <EvanR> lisp is special alright
23:50:17 <quchen> There’s your filter function.
23:50:45 <quchen> ?check \xs -> filterP0a (const True) xs == (xs :: [Int])
23:50:47 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 5 shrinks):
23:50:48 <lambdabot>  [3,2,-1,3]
23:50:48 <p0a> that is nice but I liked the currying one with (x:) more :P
23:51:05 <thang1> Lokathor: Rust is working on that, actually. They erred on explicit typing and now they're slowly adding inference
23:51:08 <quchen> > filterP0a even [1..]
23:51:10 <lambdabot>  *Exception: stack overflow
23:51:26 <thang1> > take 10 $ filterPOa even [1..]
23:51:28 <lambdabot>  error:
23:51:28 <lambdabot>      • Variable not in scope:
23:51:28 <lambdabot>          filterPOa :: (Integer -> Bool) -> [Integer] -> [a]
23:51:50 <quchen> filterP0a terminates on no infinite list, because it has to traverse the entire list before producing any output.
23:52:06 <thang1> I can't use someone else's lets? Interesting. Makes sense
23:52:17 <EvanR> haha
23:52:20 <quchen> Sure you can.
23:52:32 <quchen> Maybe someone has undefined it.
23:52:45 <EvanR> :t filterP0a
23:52:46 <lambdabot> (t -> Bool) -> [t] -> [t]
23:52:47 <quchen> Or maybe you misspelled the 0 for an O.
23:52:49 <MarcelineVQ> font :>
23:53:52 <p0a> So can anyone help with http://lpaste.net/355905 ?
23:53:59 <MarcelineVQ> p0a: best to also include your errors in pastes, if there are any, it narrows things down rapidly when you have questions
23:54:02 <p0a> filter' and divides' work just fine but problem1 doesn't work
23:54:04 <p0a> Oh okay
23:54:14 <quchen> ?letlpaste 355905
23:54:16 <lambdabot>  .L.hs:175:13: error:
23:54:16 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘a’
23:54:16 <lambdabot>        ‘a’ is a rigid type variable bound by
23:54:53 <MarcelineVQ> :t take
23:54:54 <lambdabot> Int -> [a] -> [a]
23:55:30 <quchen> p0a: »take« takes an Int as first argument, not an »Integral a => a«.
23:55:45 <p0a> I updated it with the errors
23:55:49 <p0a> aha 
23:55:50 <quchen> p0a: You can use »fromIntegral« to convert the two.
23:55:54 <quchen> :t fromIntegral
23:55:55 <lambdabot> (Num b, Integral a) => a -> b
23:56:09 <quchen> > fromIntegral (1 :: Integer) :: Word8
23:56:11 <lambdabot>  1
23:56:40 <p0a> If I change Integral to Int I get that "Int is being applied to too many type arguments"
23:56:50 <p0a> i.e. divides' :: Int a => a -> a -> Bool
23:57:19 <p0a> anyway I guess I'll use fromIntegral
23:57:48 <quchen> Integral is a constraint on a type (»Integral x means x has to implement the Integral class«), Int is a type.
23:57:50 <ertes-w> helo
23:57:55 <quchen> Int is an instance of Integral.
23:58:01 <quchen> Integer is an instance of Integral.
23:58:24 <quchen> Int is not an instance of Int, like in Java Serializable is not an instance of Serializable.
23:58:41 <p0a> ah I get it 
23:58:48 <p0a> should've been Int -> Int -> Bool
23:58:55 <quchen> For example, yes.
23:59:18 <quchen> You can specialize »Integral x« by replacing »x« with any instance of Integral.
23:59:22 <p0a> Yeah I had forgotten about type constraints vs types
23:59:40 <ertes-w> p0a: read "x :: C a => T" as "x is of type T, but also requires an instance (C a), as if it would take a "proof" for (C a) as an additional hidden argument
23:59:46 <quchen> Constraints are pretty much (properly done) interfaces.
