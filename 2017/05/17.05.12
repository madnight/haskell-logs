00:00:09 <Cale> We would actually need to have a type which describes all the details of making an FFI call
00:00:16 <conal> wolfsif: as I mentioned IO is very unlikely ever to have a (nontrivial) denotation, because its purpose is exactly to handle what we don't understand denotationally.
00:00:28 <Cale> and it would be incorporated into IO's algebraic data type in a similar fashion
00:00:44 <Cale> and since algebraic data types have a denotation, so would this IO type
00:01:13 <conal> wolfsif: as we develop mathematical/denotational understandings, we pull things *out* of IO.
00:01:17 <Cale> Even if it's not a denotation which would satisfy Conal's (and to be honest, anyone's) desire to understand what IO actions mean fully.
00:01:19 <conal> Cale: yes, in the same sense that C is purely functional/denotative. 
00:01:34 <Cale> conal: I think you're being a little overly dismissive of its value there though.
00:01:53 <Cale> It's a much better denotation than CPP has, for example.
00:02:09 <Cale> It explains a lot more about what's going on
00:02:11 <conal> we can always say that something means itself, but it's not useful.
00:02:16 <Cale> It leaves out a lot of important details still
00:02:34 <Cale> But for example, there are going to be functions in there, whose denotations are mathematical functions
00:02:43 <Cale> The fact that it's higher order abstract syntax does buy you a little
00:03:26 <Cale> So you can perhaps at least explain mathematically how the next primitive action to be carried out depends on the result of the previous.
00:04:08 <conal> Cale: i do agree Haskell+IO is a better Fortran than the original Fortran, but our sights used to be set much higher.
00:04:17 <conal> another old related post: http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm
00:04:22 <Cale> They still are set much higher
00:04:34 <conal> (we've been having this conversation for years.)
00:04:37 <Cale> haha
00:04:39 <Cale> yes
00:06:08 <Cale> My day job now involves FRP every day -- and it's FRP with reasonable semantics too (though it's one that assumes less about time than your FRP did)
00:06:58 <wolfsif> Thanks for the links and the explanations, I'll read through these
00:07:18 <wolfsif> Also conal, I've been going over your early papers / blog posts on FRP as I learn, they've been helpful
00:07:40 <conal> wolfsif: glad to hear it :)
00:20:08 * hackage 2 packages (gtsteel): https://qbin.io/bp8kidac0
00:21:27 <kuribas`> what's a good alternative to regexps?
00:21:58 <kuribas`> or, is haskell a good replacement for perl/ruby?
00:23:44 <Cale> kuribas`: attoparsec
00:24:10 <kuribas`> isn't that overkill?
00:24:14 <Cale> no
00:24:43 <kuribas`> ok :)
00:26:34 <kuribas`> would you use haskell instead of sed, awk?
00:26:56 <Cale> Sometimes
00:27:25 <Cale> It doesn't take much for an application of sed or awk to become an unmaintainable mess
00:27:40 <Cale> It's often better just to write it from the beginning in a sensible way
00:28:07 <johnw> and especially if you write such things often, you end up with templates that make future sensibile solutions much quicker to write
00:30:59 <mauke> haskell is not a good replacement for perl IMO
00:31:14 <kuribas`> yuck perl
00:31:18 <mauke> and I'd say attoparsec is underkill for regexes
00:31:30 <kuribas`> mauke: you mean overkill?
00:31:35 <mauke> no
00:31:56 <kuribas`> mauke: it's /less/ powerfull?
00:32:05 <mauke> yes
00:33:29 <mauke> for example, attoparsec parses bytestrings
00:33:54 <mauke> I usually use regexes on text, not binary data
00:34:01 <mauke> so that's not very useful
00:34:09 <Cale> attoparsec can also parse Text
00:34:28 <Cale> https://hackage.haskell.org/package/attoparsec
00:35:12 <[exa]> fun fact-- binary data tend to be regular more frequently than text
00:35:59 <osa1> IIRC cabal had a flag for formatting .cabal files, anyone remember it? I can't find it in --help
00:36:04 <kuribas`> [exa]: so we need a fuzzy matching library?
00:36:41 <Cale> Yeah, it's one thing if you actually need to exploit the fact that your language is regular in order to get an efficient automaton for processing your input, but I think most people who use "regexes", not to mention most regex implementations, don't seem to care much for that.
00:36:56 <[exa]> yep :]
00:38:00 <kuribas`> Also most regular expressions aren't regular.
00:38:02 <mauke> ok, so how do you do e.g. s/(\X)/[$1]/g with attoparsec?
00:38:21 <Cale> I don't know, give me 10 minutes to figure out what it means
00:38:25 <mivael> conal: Thank you for writing (and mentioning) "Notions of purity in Haskell".  It was a useful reading for me.  (And I think I share the principles you describe.)
00:38:36 <[exa]> anyway, is anyone aware of how parsec/attoparsec works internally? does it create flex/bison-style tables or is it haskellish?
00:38:45 <Athas> [exa]: no tables; Haskellish.
00:38:52 <mauke> Cale: it puts [ ] around every grapheme cluster
00:39:00 <Athas> That's the biggest limitation of the parser combinator approach.
00:39:29 <[exa]> I'm thinking about writing something that can partially evaluate to the table
00:39:54 <[exa]> probably not as rich as parsec though, but still quite powerfull imho
00:39:58 <Athas> That would be cool, but also impossible if the parser is a monad I think.
00:40:07 <Athas> Maybe you can do it for one that is merely Applicative.
00:42:01 <[exa]> good point
00:42:36 <[exa]> well, it might be interesting, adding to todo list. :]
00:43:24 <Athas> The only reason I sometimes use traditional table-driven parser generators is for debugging grammars.  They are a PITA besides.
00:44:20 <Cale> mauke: I guess I'd write a graphemeCluster parser using Data.Text.ICU or something, and then  fmap (T.concat . map (\x -> "[" <> x <> "]")) (many graphemeCluster)
00:44:22 <[exa]> Athas: extremely fast PITA though.
00:44:35 <Cale> mauke: I've never had to care about grapheme clusters :P
00:45:01 <Athas> [exa]: sometimes, but Attoparsec can be pretty fast too.
00:45:11 <mauke> Cale: that's about 5 times longer and even less readable
00:45:28 <Cale> mauke: It should be, it's a weird operation.
00:46:12 <mauke> not really; grapheme clusters came up when I had to implement message splitting for IRC
00:46:56 <Cooler> is there a javascript to haskell compiler?
00:47:03 <Cale> Cooler: hahaha
00:47:11 <mauke> AFAIK no
00:47:46 <Cooler> i am having trouble converting my javascript program to haskell
00:48:01 <Cooler> how do you make a table?
00:48:13 <Cooler> a 2d array, indexed by strings
00:48:28 <Athas> How is it 2D if it is indexed by strings?
00:48:39 <mauke> if it's indexed by strings, it's not an array
00:48:45 <osa1> maybe you index it by two strings
00:48:52 <Taneb> Cooler, why are you converting JS to Haskell? The languages are very different and you need to think about them differently to program well
00:49:30 <Cooler> well you know about lr parsing tables?
00:50:09 <mauke> no
00:50:11 <Cooler> where you have a table whos rows are indexed by state number and columns which are indexed by terminals and non-terminas
00:50:14 <[exa]> Cooler: so it is indexed by token or by char?
00:50:34 <Cooler> whose*
00:51:00 <Lokathor> Cooler, there's a Map type that's in the containers package, you could index that by whatever you want as long as it's got an Ord instance
00:51:24 <Cooler> like this https://image.slidesharecdn.com/cc-parsing-101209190947-phpapp02/95/compiler-components-and-their-generators-lr-parsing-65-638.jpg?cb=1357625270
00:52:05 <Taneb> Cooler, the way parsing is normally done in Haskell is with parser combinators, which is a rather different way to go about it to LR tables
00:52:30 <mauke> > inRange ('a', 'z') 'x'
00:52:32 <lambdabot>  True
00:52:50 <mauke> if you want to, you can index an array with Char
00:53:21 <Cooler> well no the tokens are strings, not just a single char
00:53:24 <Athas> Cooler: parser tables are indexed by pairs of states and terminals.  Usually the terminals are represented by an integer.
00:53:42 <Athas> But yeah, use a Map.
00:53:50 <Athas> Then the tokens can be whatever you want.
00:55:06 <Cooler> Athas, a Map for each row?
00:56:51 <Lokathor> Cooler, probably a Map entry per cell
00:57:09 <Athas> Cooler: no, a Map instead of the table.
00:57:10 <Lokathor> and you can index by tuples for (row,col)
00:57:27 <Athas> You want the table to have type 'Map (StateId,Token) StateId'.
01:00:06 <mauke> Cale: in fact, the IRC message splitting problem is a good one. you want to split a string into chunks, subject to several constraints. you don't want to split grapheme clusters if you can avoid it. you want to split at whitespace if possible. chunks should be neither too short nor too long, so splitting at non-whitespace is unavoidable sometimes. if (for some reason) you can't split between grapheme 
01:00:12 <mauke> clusters, fall back to codepoints. but all length constraints on chunks are in terms of bytes (when encoded as UTF-8).
01:00:41 <Athas> The issue here is that Haskell does not have a good Unicode processing library, isn't it?
01:00:58 <Athas> My impression is that many languages are without such a thing.  Swift gets it right, as I understand.
01:01:40 <merijn> Athas: Text does better than average (i.e. compared to other languages), but if you *really* want to do locale aware unicode you want to use text-icu
01:01:52 <merijn> Which are just bindings for the icu C implementation
01:02:08 <mauke> well, in perl you have "native" unicode support, which is 100% integrated with e.g. regexes
01:02:20 <Cooler> which Map btw
01:02:26 <mauke> which is why I think "just use attoparsec" doesn't cut it
01:02:34 <Athas> mauke: does it help you deal sanely with things like bidirectional text?
01:02:53 <mauke> Athas: ah, good one. I don't know because I never had to deal with that
01:03:20 <dysfun> there is 'sane' with bidi text?
01:03:24 <mauke> my current message splitting code doesn't handle directionality changes at all, e.g.
01:03:27 <Cooler> there are a lot of maps
01:03:52 <Lokathor> mauke, as i understand it, the message frames of IRC are split by \r\n byte sequences, but that sequence won't show up as part of a multi-byte character in UTF-any
01:03:55 <Lokathor> Cooler, https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map.html
01:04:22 <mauke> Lokathor: ... what does that have to do with anything?
01:04:43 <Lokathor> mauke, well you can split the message frames when you've purely got bytes, and worry about unicode or not after that
01:04:50 <Athas> dysfun: I thought the same thing after I wrote that remark...
01:04:58 <mauke> Lokathor: we're talking about outgoing messages, not incoming
01:05:00 <Cooler> Data.Map.Strict ?
01:05:05 <mauke> we're producing IRC, not consuming
01:05:10 <Athas> I'm just a poor parallel compiler researcher, and I long ago realised I'm not smart enough to handle human text.
01:05:13 <Lokathor> mauke, ahh, my mistake
01:05:22 <Athas> Cooler: yes.
01:05:37 <mauke> Lokathor: the problem is that IRC has a message size limit of 512 bytes, including the terminating CR/LF
01:05:39 <Athas> There is also Data.Map.Lazy, but you probably want Strict for a parser table (and the difference is small).
01:06:03 <mauke> Lokathor: so when you want to send something longer, you have to split it across multiple messages
01:06:17 <Lokathor> mauke, true, true. guess the answer is to only ever produce ASCII so that you can always predict your message size :P
01:06:28 <merijn> Athas: So, is NVidia's Volta stuff trying to obsolete your research too? ;)
01:06:42 <Athas> merijn: not at all!  What are they doing?
01:06:56 <Lokathor> actaully you can encode the final arg of the privmsg, check how many bytes that is... ah.. then you're kinda hosed if you went over :/
01:07:00 <Athas> Unless they managed to make nested parallelism work efficiently, I think I still have a job.
01:07:13 <merijn> Athas: I've only skimmed a few headlines. They're basically throwing out the whole "schedule things as a warp" idea
01:07:28 <merijn> Athas: And just sticking 32 independent program counters/schedulers into their SMs
01:07:54 <merijn> Athas: I'm not actually sure that's going to obsolete my research, tbh. But it'd have made a lot of my work much easier to make fast than it was so far
01:08:57 <mauke> ooh, glob matching is also fun
01:09:18 <mauke> I might actually write a haskell implementation later
01:09:24 <Athas> merijn: er, what?  It no longer executes in lockstep?
01:10:07 <merijn> Athas: I'm not sure of the details, but it is possible to execute stuff out of lockstep, yes
01:10:27 <mauke> task: decide whether a string matches a given glob pattern (where ? matches any char, * matches any amount of any char, and no escapes)
01:10:46 <eklavya> I have a small utility (converter) that I need to give to a team
01:11:11 <mauke> this is probably easier to do manually in haskell, but one possible implementation is to use a regex to convert the glob pattern into a regex :-)
01:11:23 <eklavya> what is the best way to create standalone executables for windows, mac and linux?
01:11:27 <Athas> merijn: there has to be a catch.  Tremendous amounts of CUDA code depends on free synchronisation within warps.
01:11:38 <mauke> eklavya: run ghc on the corresponding platform?
01:11:47 <eklavya> oh
01:11:52 <eklavya> I only have access to a mac
01:11:53 <eklavya> :(
01:12:23 <eklavya> mauke: anything I should be aware of or if you would like to suggest something?
01:12:32 <merijn> eklavya: Download a VM like VirtualBox and install linux/windows into the VM and built on there
01:12:35 <Lokathor> eklavya, ask a person on each other platform within the team to do the build for you and share among that platform
01:12:49 <Athas> 100 TFLOPS is crazy performance (even if it's FP16).
01:13:11 <mauke> perl implementation: $pat =~ s{(\W)}{ $1 eq '?' ? '.' : $1 eq '*' ? '(*PRUNE).*?' : '\\' . $1 }eg; $pat = qr/\A$pat\z/s;
01:13:28 <eklavya> Lokathor: that might not be a bad idea but I fear I might have to do a lot of environment debugging/handholding
01:13:52 <Lokathor> eklavya, if you're not using much FFI, stack on windows is pretty easy
01:14:32 <eklavya> let me try that
01:14:40 <merijn> Athas: Oh! I get what they're doing. It's just misleading headlines by incompetent people :)
01:14:44 <eklavya> thanks Lokathor mauke merijn :)
01:15:03 <Athas> merijn: so what's going on?
01:15:06 <merijn> Athas: So basically, before you had one PC and stack per warp, right?
01:15:34 <Athas> merijn: well, "stack".
01:15:46 <Athas> But one PC, sure.
01:15:50 <merijn> Athas: Which means that when you diverge you *have* to run both divergent computations in one single run, since you can't actually track where you are in the middle
01:16:22 <Athas> Yeah.
01:16:34 <Athas> Oh, they run them concurrently now or what?
01:16:42 <merijn> Athas: Since they're storing the PC *per thread* they can actually interleave different divergent branches
01:17:04 <Athas> You still have to synchronise after the branch, don't you?
01:17:05 <merijn> Athas: Well, suppose we head "if (threadIdx.x < 4) { A; B; } else { X; Y; }"
01:17:42 <Athas> Storing a PC per thread sounds like a waste of register space to me, but whatevs.  I don't do optimisation at this level, so this is unlikely to affect me much.
01:17:42 <merijn> Previously they'd basically run "A; B; X; Y" in a row, with just sections of the warp masked
01:18:07 <merijn> Athas: Now they can run "A; X; B; Y;" interleave == better latency hiding
01:18:30 <merijn> Athas: Since they store the state of both branches per thread, and thus remember "where" to continue
01:19:18 <Athas> How deep does this go?
01:19:23 <merijn> But you're basically still screwing up your efficiency until you reconverge
01:19:32 <Athas> You can have multiple nested branches, after all.
01:19:59 <Athas> It sounds like a minor (but useful) improvement to branch divergence cost.
01:20:31 <merijn> Yeah, I got suckered by the headlines saying "independent scheduling" while it's way more minor than that
01:20:48 <Athas> I definitely want one of these things, though.
01:21:32 <ph88^> anyone have a clue why this guys https://softwareengineering.stackexchange.com/a/173442 claims "Compared to Lisp, Haskell (for example) is a lot friendlier" ?
01:21:55 <Lokathor> compile time checks are nice, for one
01:21:57 <merijn> One of colleague was trying to convince me to write a proposal to get a GTX1080Ti for my home desktop so I could "wrok from home" >.>
01:23:13 <Athas> Hmm, NVIDIA used to send free GPUs to researchers...
01:23:16 <Athas> That's how I got my K40.
01:23:49 <merijn> I doubt they're giving me a 1080Ti for free :p
01:23:52 <Athas> ph88^: Haskell has a better standard library, in particular for functional programming and OS interaction.
01:24:16 <zomg> merijn: I just bought one of those yesterday :P
01:24:16 <merijn> Also, type system :)
01:24:31 <merijn> zomg: I'm still telling myself they're to expensive
01:24:41 <Athas> merijn: a K40 is near 3000 euros.
01:24:49 <merijn> But I'll probably cave somewhere in the coming months...I hope to last maybe one price drop
01:25:03 <zomg> well, I work from home so it's a 50% tax writeoff for me :D
01:25:13 <Athas> https://developer.nvidia.com/academic_gpu_seeding
01:25:16 <zomg> that's my justification for it anyway!
01:25:17 <zomg> lol
01:26:30 <merijn> Athas: Did you just list yourself as researcher?
01:26:41 <Athas> merijn: I got my advisor to apply.
01:27:18 <kuribas`> ph88^: not sure I agree, LISP is more imperative, so probably more familiar.  But it could be that s-exps turns people off.
01:27:24 <merijn> Athas: I'm not sure mine will, given that we already have a couple in the shared cluster :)
01:28:01 <Athas> merijn: upgrade your advisor!
01:28:50 <merijn> Athas: I suspect nearly any other advisor will be a downgrade :)
01:37:21 <merijn> One of these days I need to invent a language where converting between integer types isn't such a pain...
01:37:42 <mniip> so like C?
01:37:46 <mniip> no wait
01:37:47 <mniip> php
01:37:50 <merijn> mniip: C *is* a pain
01:38:09 <merijn> I want *safe* conversion, not "pray we don't all die" conversions
01:38:45 <merijn> replicateM_ wants Int, but I have Int64, but there's no easy functions to do anything remotely safe
01:39:46 <seequ_> I mean, the preferred conversion depends on the use case
01:40:04 <merijn> I want like
01:40:11 <seequ_> And platform, heh
01:40:50 <kuribas`> merijn: it's not a pain, because everything is an integer!
01:40:55 <kuribas`> in C
01:41:10 <merijn> "(Integral a, Integral b) => a -> (b, a)" which gives you either: 1) maxBound of 'b' and a remainder as 'a' or 2) 'a' as type 'b', with remainder of 0
01:41:16 <merijn> kuribas`: Except it's not
01:41:19 <seequ_> You can cut the bits in half, convert to MAXINT if it goes over or wrap around
01:41:42 <seequ_> Or that
01:41:53 <kuribas`> merijn: it has both types until observed.
01:41:54 <merijn> kuribas`: And I once had to fix a bug in the Haskell RTS three times, because my fixes kept being fuckups, despite 3 reviewers looking over them each time and not seeing an issue >.>
01:43:03 <seequ_> kuribas`: that is absolutely not true - C allcates exactly 4 bytes for av32-bit int
01:43:33 <merijn> What C allocates for an int is absolutely unknown and platform dependent
01:43:37 <seequ_> A 32-bit*
01:44:05 <Athas> Might not allocate anything!
01:44:14 <merijn> Aforementioned bug I fixed came from the fact that GHC uses 64bit Int on *all* 64bit platforms and there was a lacking (safe) conversion to CInt
01:44:27 <merijn> Which meant it worked fine IFF the 64bit C also used 64bit int
01:44:40 <merijn> Fun fact: OSX ABI has a 32bit in for 64bit C...
01:45:53 <cocreature> merijn: 32bit ints on 64bit systems is pretty common. clang does that as well on my system
01:45:56 <cocreature> (archlinux)
01:46:07 <Athas> Almost all operating systems behave that way.
01:46:29 <merijn> cocreature: eh...your compiler shouldn't decide that. That's based on the ABI. Afaik linux ABI uses 64bit int
01:47:19 <cocreature> merijn: I’ve never been on a system where it 64bit
01:48:11 <Cooler> how do you clear the console in ghci?
01:51:39 <Cooler> also does main not get executed when loading in ghci?
01:52:46 <Athas> Cooler: no, main does not get executed.
01:52:50 <Athas> I don't know if you can clear the console.
01:53:51 <Cooler> keep having to quit out of ghci to clear it
01:55:09 <shlevy> Would it be safe to allow type synonym family applications in instance heads when they're injective in all of the otherwise unconstrained type variables?
01:56:16 <mniip> shlevy, unlikely
01:56:32 <mniip> shlevy, wait you mean fully applied families right?
01:56:37 <shlevy> mniip: Yes
01:56:53 <shlevy> The type family is fully applied
01:56:56 <merijn> hmm
01:57:00 <mniip> do you have a simplified usecase in mind?
01:57:08 <shlevy> mniip: Lemme try to whip one one
01:57:10 <shlevy> up
01:57:36 <mniip> do you want to rewrite something like 'instance (Fam a ~ TyCon b) => Cxt (TyCon b)'
01:57:42 <mniip> with 'instance Cxt (Fam a)'
01:57:51 <merijn> How do I check where a function gets imported from? afaik replicateM_ comes from Control.Monad, but it's in scope even if I don't import it
01:58:17 <Athas> merijn: define your own, use it, and see what the error says.
01:58:31 <merijn> Athas: Well, I did define my own, but it's ignore that one and not saying why :p
01:58:32 <mniip> merijn, :info tells you where it is defined
01:58:46 <mniip> also, replicateM_ is not in Prelude
01:58:58 <merijn> mniip: I know, hence my confusion...
01:59:00 <mniip> not in scope by default
01:59:07 <mniip> are you exporting it?
01:59:15 <merijn> oh, I see my error elsewhere
02:00:07 <ertes-w> is there something simpler than optparse-applicative for very simple UIs?
02:00:27 <ertes-w> "simpler" in the sense of "i need to write less boilerplate code"
02:00:53 <shlevy> mniip: merijn: http://sprunge.us/Qfjh
02:00:54 <merijn> ertes-w: What's boilerplatey about optparse?
02:01:37 <shlevy> I need the DifferentReader in the head to avoid the spurious overlap
02:01:44 <osa1> I guess you could get a arg parser from a Generic instance
02:03:26 <Cooler> for Data.Map.Strict is there a version of lookup thats   k -> Map k a -> a?
02:04:31 <Athas> Cooler: no.  What if the key is missing?
02:04:49 <phadej> Cooler: (!)
02:04:55 <Cooler> i would prefer it just crash rather than having to deal with Maybe
02:05:27 <Athas> Oh yeah, I guess there is (!).
02:06:15 <Cooler> thx
02:06:59 <seequ_> fromJust is nice too when it can be proven the thing exists
02:08:12 <mniip> unsafeCoerce @Maybe @Identity
02:08:13 <mniip> ;)
02:08:21 <mniip> no wait Identity only has one con...
02:08:48 <phadej> and is newtype
02:08:58 <ertes-w> merijn: this: execParser (info (helper <*> pure Options) mempty)
02:09:11 <ertes-w> merijn: i have to look those things up every time i use it
02:09:12 <quchen> mniip: Identity has zero constructors
02:09:21 <quchen> Ah, phadej beat me to it.
02:09:31 <ertes-w> merijn: and remember to use 'helper', etc., which, BTW, is kinda stupid =)
02:09:49 <ertes-w> osa1: optparse-generic already exists, but it's awkward to use
02:10:18 <osa1> ah, cool. I didn't know it
02:21:59 <Cooler> show Data.Map.Strict needs better formatting
02:22:07 <Cooler> maybe put each entry on a new line
02:24:12 <mniip> don't use show
02:24:25 <merijn> Show is not for pretty printing
02:24:31 <mniip> ^
02:25:21 <Cooler> well it auto uses show when you ask for a variable in ghci
02:25:40 <merijn> You can change what ghci uses to print things
02:25:48 <phadej> Cooler: http://hackage.haskell.org/package/pretty-show-1.6.12/docs/Text-Show-Pretty.html
02:26:06 <sbrg> It's also pretty easy to just do something like: mapM_ print $ M.toList yourMap
02:26:07 <sbrg> or some such
02:27:07 <Cooler> yeah that works
02:28:47 <Cooler> sbrg, why mapM_ instead of map?
02:29:26 <sbrg> `map print` will give you a list of type [IO ()], which is a list of IO actions which haven't been performed yet.
02:29:49 <sbrg> :t map print [1..10]
02:29:51 <lambdabot> [IO ()]
02:29:59 <sbrg> :t mapM_ Print [1..10]
02:30:00 <lambdabot> error:
02:30:00 <lambdabot>     • Data constructor not in scope: Print :: Integer -> m b0
02:30:00 <lambdabot>     • Perhaps you meant variable ‘print’ (imported from Prelude)
02:30:01 <sbrg> oops
02:30:05 <sbrg> :t mapM_ print [1..10]
02:30:06 <lambdabot> IO ()
02:34:52 <kuribas`> Is there a library for doing shell scripting?  For example calling "find", and acting on each file?
02:35:16 <suppi> there's turtle and shelly
02:37:17 <kuribas`> turtle looks nice
02:40:27 <Cooler> is this fine? data Tree = Node Int [Tree]
02:41:17 <mauke> @src Tree
02:41:17 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
02:41:21 <mauke> aw
02:41:28 <kuribas`> Cooler: if you want only an infinite tree?
02:41:33 <Cooler> actually data Tree = Node String String [Tree]
02:41:47 <merijn> kuribas`: How is that infinite?
02:41:58 <kuribas`> Cooler: disregard that, you can set [Tree] to []
02:41:59 <merijn> kuribas`: List could be empty
02:42:03 <kuribas`> merijn: yeah
02:42:04 <mauke> Cooler: looks a lot like http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Tree.html
02:42:18 <mauke> Tree (String, String)
02:43:37 <Cooler> @src Data.Tree
02:43:37 <lambdabot> Source not found.
02:43:43 <Cooler> why?
02:43:51 <mauke> no one added it
02:43:57 <Taneb>  @src is something that is not as cool as it sounds
02:43:58 <Cooler> its on hackage
02:44:18 <merijn> lambdabot's @src just look inside a small text file
03:07:10 <Cooler> i get an error https://hastebin.com/wohesataba.vbs
03:07:26 <Cooler> trying to import qualified Data.Stack as Stack
03:09:33 <Cooler> do i need to install Data.Stack?
03:09:43 <Cooler> i thought it came with the haskell platform
03:10:40 <kamyar> Hello fellows
03:10:45 <Cooler> oh wow theres actually 1505 people here?
03:10:45 <sbrg> Cooler: why not just use a list?
03:10:55 <Cooler> sbrg, hmm?
03:10:57 <kamyar> Please help me with Stack guild:
03:10:59 <sbrg> for a stack
03:11:14 <kamyar> How to specify (any version) in extra-deps 
03:11:30 <Cooler> sbrg, well theres already a type in Data
03:11:38 <sbrg> I've never heard of Data.Stack before
03:11:39 <kamyar> extra-deps: [CBOR-0.1.0.1, random-strings-0.1.1.0, persistent-uuid-any] fails
03:12:02 <kamyar> extra-deps: [CBOR-0.1.0.1, random-strings-0.1.1.0, persistent-uuid] fails either
03:12:10 <Cooler> doesn't tail take O(n) time?
03:12:19 <sbrg> nope. 
03:12:25 <mniip> tail is O(1)
03:12:34 <sbrg> tail (x:xs) = xs
03:12:38 <Cooler> no not tail
03:12:47 <Cooler> uh... last?
03:12:49 <sbrg> but you don't append, you prepend. 
03:12:50 <sbrg> yes
03:12:56 <mniip> why would you use last
03:12:58 <sbrg> push x xs = x:xs
03:13:05 <sbrg> pop (x:xs) = x
03:13:19 <mniip> :t (:)
03:13:20 <lambdabot> a -> [a] -> [a]
03:13:22 <sbrg> or rather, pop (x:xs) = (x, xs)
03:13:22 <mniip> :t uncons
03:13:24 <lambdabot> [a] -> Maybe (a, [a])
03:13:36 <sbrg> yeah, that's nicer
03:13:36 <Cooler> that doesn't explain the error
03:14:43 <Boomerang> What error are you refering to Cooler? Trying to pop an empty stack?
03:14:56 <Boomerang> That's why uncons can return Nothing
03:14:59 <Cooler> https://hastebin.com/wohesataba.vbs
03:15:04 <Boomerang> Oh :o
03:15:31 <sbrg> Cooler: yes, that is because you don't have the library installed. but there is no reason to install some package for a stack since you can just use lists
03:15:36 <mauke> it's in MissingK
03:15:45 <Boomerang> Have you install the Stack package before trying to import Data.Stack?
03:15:57 <mauke> http://hackage.haskell.org/package/MissingK-0.0.1/docs/Data-Stack.html
03:15:59 <Cooler> i didn't have to install anything for Data.Map or Data.Tree
03:16:03 <mauke> Boomerang: what
03:16:03 <kamyar> Hey anyone here to reply me?
03:16:07 <sbrg> that's because data.stack is not in base
03:16:12 <sbrg> while those are
03:16:25 <mauke> it gets better: type Stack a = [a]
03:16:30 <Boomerang> Is it not this one: https://hackage.haskell.org/package/Stack-0.3.2/ ?
03:16:30 <sbrg> ^
03:16:48 <mauke> oh, could be
03:16:57 <Cooler> https://hackage.haskell.org/package/Stack-0.3.2/docs/Data-Stack.html
03:17:16 <mauke> well, then
03:17:42 <Cooler> oh there are Maybes
03:18:18 <mauke> the only thing that gives you is automatically tracking sizes
03:18:23 <mauke> over [], I mean
03:18:48 <Cooler> well also is it mutable?
03:19:03 <Cooler> instead of making a lot of lists
03:19:08 <mauke> what
03:19:31 <Cooler> when you push and pop, is it making a lot of lists?
03:19:45 <mauke> nothing makes "a lot of lists"
03:20:34 <quinor> hello, looking for advice on parser libraries; I'd like to parse into AST a programming language with syntax similar to Haskell
03:20:38 <mauke> here's the source: https://hackage.haskell.org/package/Stack-0.3.2/docs/src/Data-Stack.html#Stack
03:20:57 <quinor> which library would be the best? I'm thinking parsec but I'm novice and not sure
03:21:28 <sbrg> quinor: you could go with a parser generator. there's happy for that, and alex for lexing
03:21:46 <sbrg> they can work together pretty easily. they're very similar to bison and flex, if you're familiar with those
03:21:59 <Cooler> mauke, well is the list immutable, wouldn't push and pop make copies then?
03:22:12 <quinor> I don't like generators, prefer libraries (I'm not familiar with bison/flex yet)
03:22:34 <quinor> also, the grammar is not entirely context-free (indentations!)
03:23:40 <Boomerang> Cooler, the compiler will optimise your list "copies". Since they are immutable you can refer to them from a "new" list.
03:23:40 <mauke> Cooler: ... no?
03:24:08 <mauke> Cooler: why would you ever need to copy an immutable structure?
03:24:22 <quinor> sbrg: also, features like my own operators aren't particularly easy in parser generators
03:25:03 <sbrg> why? 
03:25:29 <Boomerang> mauke: I think Cooler is refering to pop (uncons) which returns the new stack, while you still have access to the old one. This may look like a copy, while it's not
03:25:32 <Cooler> Boomerang, i guess a linked list type of scenario going on
03:26:07 <mauke> Cooler: [] is a singly linked list
03:26:47 <Boomerang> Cooler, it is a linked list. if you change (x:xs) into (y:xs) the xs is not copied
03:27:10 <quinor> sbrg: operators defined in the source file? how would you manage that (usually grammar with precedences and associativenesses parses ops directly to AST)
03:28:06 <sbrg> quinor: sure, but defining a new operator is just like definining a new function, except the operator can use a different set of characters. pretty sure it's no biggie
03:28:22 <sbrg> caveat: I haven't implemented custom operators using a parser generator, but I don't think it would be a problem
03:29:02 <quinor> so you definitely recommend parser generators vs parsing libraries?
03:29:30 <Cooler> i hate one line documentations http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Tree.html
03:29:35 <sbrg> well, from what I've gathered, if you use something like parsec and such, you have to ensure that you don't run into infinite left recursion and such.
03:29:52 <sbrg> I'm kind of working on a compiler on and off, in Haskell, and I started using parsec and such, but ended up using happy/alex
03:30:10 <sbrg> it just felt simpler
03:30:10 <Athas> quinor: if you already know that your grammar is correct, then Parsec can be fine.
03:30:16 <mauke> I don't like parser generators
03:30:19 <Athas> But the nice thing about Happy is that it will tell you about ambiguities.
03:30:39 <quinor> sbrg that's very valuable opinion
03:30:42 <Athas> Although Happy is a total PITA in many other ways.  The errors are terrible, the UTF-8 handling is wonky, it's hard to run on top of your own monad...
03:30:46 <mauke> Cooler: what are you looking for?
03:30:48 <Athas> (Some of these are alex issues.)
03:31:01 <quinor> luckily I'm quite good with formal grammars and it's supposedly not ambiguous
03:31:06 <Athas> I've also written a compiler in Haskell for the past few years, and I use Happy/Alex.
03:31:11 <Cooler> whats the first argument to unfoldtree
03:31:13 <Cooler> ?
03:31:28 <mauke> Cooler: a builder function
03:31:32 <sbrg> Athas: yeah, the documentation for running your own monad through the whole thing is not the best. 
03:33:01 <Cooler> ohhhh
03:33:02 <Cooler> ok
03:33:17 <mauke> Cooler: it takes a "seed" value and returns values for constructing a Node
03:33:27 <Cooler> yeah
03:33:49 <quinor> hmm, are there any more fun parser libraries than parsec?
03:34:05 <quinor> have read of some but couldn't reason whether they are better
03:34:24 <quinor> ie. https://www.reddit.com/r/haskell/comments/46u45o/what_is_the_current_state_of_parser_libraries_in/
03:36:36 <sbrg> I usually use megaparsec these days
03:36:48 <sbrg> or just ReadP when it's enough, since it's in base
03:38:53 <quinor> thanks sbrg :)
03:40:41 <kuribas`> is there a better way to do this?  view $ grep (has "opencl") $ fmap (unsafeTextToLine . format fp) $ ls "/usr/src"
03:44:25 <kuribas`> it seems more verbose than "ls /usr/src | grep opencl"
03:44:55 <mauke> ls /usr/src/*opencl*
03:46:21 <kuribas`> even better
03:54:09 <ZuluKing> can someone please explain how do I use this https://hackage.haskell.org/package/iCalendar-0.4.0.3/docs/Text-ICalendar-Parser.html, I just can't figure out!
03:54:47 <Cooler> i thought you needed to do let in ghci to define variable
03:54:52 <Cooler> use*
03:55:01 <Cooler> apparently not
03:57:05 <Geekingfrog> ZuluKing: do you have anything more precise ?
03:57:21 <kamyar> Hey fellows
03:57:32 <kamyar> please help me in Stack build
03:58:33 <kuribas`> Cooler: not anymore
03:59:11 <mekeor> ZuluKing: use read the icalendar file as bytestring, then use `parseICalendar def filepath bytestring`
03:59:36 <Cooler> why did they change that
03:59:37 <Cooler> ?
03:59:38 <mekeor> ZuluKing: DecodingFunctions is an instance of the Default type class, so you can just use `def` (for utf-8, apparently)
03:59:53 <ZuluKing> mekeor how do I get the def?
04:00:09 <Geekingfrog> ZuluKing: import Data.Default (def)
04:00:09 <mekeor> ZuluKing: it's defined in that module
04:00:28 <mekeor> ... or what Geekingfrog said
04:00:30 <Geekingfrog> and then you can use `def` to supply the DecodingFunction argument
04:00:36 <ZuluKing> I have to be the biggest idiot alive
04:00:42 <ZuluKing> thanks a lot guys
04:00:51 <Geekingfrog> nah, it took me some times to understand what was this "default" thing as well
04:17:47 <Cooler> omgggg they brought ubuntu to the windows store
04:25:08 * hackage threepenny-editors 0.2.0.3 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.3 (PepeIborra)
04:25:26 <moongazer> What are some good resources to learn functional programming for a complete beginner? Any good books which teach functional programming theory(lambda calculus) as well as the language itself?
04:26:54 <hpc> @where learnhaskell
04:26:54 <lambdabot> https://github.com/bitemyapp/learnhaskell
04:27:04 <hpc> ^ this has a breakdown of a number of resources
04:27:13 <merijn> For type theory (including lambda calculus) Pierce's "Types and Programming Languages" is good, but all the code examples in it are written in OCaml, so it does assume you already know the basics of functional programming
04:27:28 <hpc> i don't know of one that specifically has both λcalc and haskell taught at the same time
04:27:44 <hpc> but you tend to pretty quickly pick up both from most haskell resources
04:28:02 <hpc> with a trip to wikipedia maybe for the names of some concepts
04:28:07 <Philonous> The examples are easy enough to understand if you know Haskell. 
04:28:21 <Philonous> (In TAPL I mean)
04:28:28 <Philonous> Ocaml isn't that different 
04:28:34 <merijn> Philonous: Sure, which is why I said you need the basics of FP, not OCaml ;)
04:29:28 <Philonous> Yes, I just wanted to clarify, because it's not obvious that you can read OCaml just because you know Haskell
04:29:30 <hpc> and yeah, TAPL isn't exactly what you asked for but it'll be good to read
04:31:29 <Philonous> If you want to get really into lambda calculus I can recommend Hindley/Seldin: "Lambda-Calculus and Combinators: An Introduction"
04:31:49 <moongazer> http://www.seas.upenn.edu/%7Ecis194/spring13/lectures/01-intro.html : This course is completely text based, right?
04:32:25 <Philonous> I've heard very good things about Barendregt "The Lambda Calculus, Its Syntax and Semantics" too, but I haven't read it
04:33:18 <opqdonut> it's pretty hard to come by
04:34:02 <moongazer> Is the course I posted completely text based or are other things available elsewhere?
04:34:10 <Philonous> libgen has both
04:41:50 <Cooler> test, did i dc?
04:50:08 * hackage http-streams 0.8.5.2 - An HTTP client using io-streams  https://hackage.haskell.org/package/http-streams-0.8.5.2 (AndrewCowie)
04:52:38 * hackage http-streams 0.8.5.3 - An HTTP client using io-streams  https://hackage.haskell.org/package/http-streams-0.8.5.3 (AndrewCowie)
04:56:08 * hackage haskeline-repl 0.4.0.0 -   https://hackage.haskell.org/package/haskeline-repl-0.4.0.0 (reinvdwoerd)
04:58:13 <kuribas`> hm, turtle isn't that convenient.
04:58:48 <kuribas`> With so much conversion: FilePath, Line, Text, String
05:02:22 <Cooler> read "99" gives an exception but read "99" :: Int works
05:02:28 <Cooler> why
05:02:33 <merijn> Cooler: in ghci?
05:02:35 <tdammers> read "99" shouldn't even compile
05:02:37 <Cooler> yeah
05:02:43 <merijn> tdammers: Extended defaulting ;)
05:02:47 <tdammers> merijn: oh right
05:02:49 <merijn> Cooler: GHCi defaults everything to ()
05:03:09 <merijn> so it's interpreting 'read "99"' as 'read "99" :: ()'
05:03:11 <tdammers> :t read
05:03:12 <lambdabot> Read a => String -> a
05:03:13 <merijn> which fails, for obvious reasons
05:03:21 <Cooler> ok
05:03:38 <Cooler> so should i use read if i know something is going to be int?
05:03:45 <tdammers> Cooler: normally, it wouldn't compile, because the type of `read` doesn't tell the compiler enough to figure out which Read instance to use
05:04:02 <merijn> Cooler: If you'd done this in a .hs file the compiler would've told you "can't figure out which type this should be"
05:04:04 <kuribas`> :t read @Int
05:04:05 <lambdabot> error:
05:04:05 <lambdabot>     Pattern syntax in expression context: read@Int
05:04:05 <lambdabot>     Did you mean to enable TypeApplications?
05:04:12 <merijn> Cooler: In generaly you should use "readMaybe" rather than read :)
05:04:16 <kuribas`> :set -XTypeApplications
05:04:21 <kuribas`> :t read @Int
05:04:22 <merijn> > readMaybe "foo" :: Maybe Int
05:04:22 <lambdabot> error:
05:04:23 <lambdabot>     Pattern syntax in expression context: read@Int
05:04:23 <lambdabot>     Did you mean to enable TypeApplications?
05:04:24 <lambdabot>  error:
05:04:24 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Int
05:04:33 <merijn> > Text.Read.readMaybe "foo" :: Maybe Int
05:04:35 <lambdabot>  error:
05:04:36 <lambdabot>      Not in scope: ‘Text.Read.readMaybe’
05:04:36 <lambdabot>      No module named ‘Text.Read’ is imported.
05:04:41 <merijn> bleh
05:04:52 <merijn> @let import Text.Read (readMaybe)
05:04:53 <lambdabot>  Defined.
05:04:58 <merijn> > readMaybe "foo" :: Maybe Int
05:05:00 <lambdabot>  Nothing
05:05:03 <bloogie> is "actually, we just took a bunch of laws we liked and grouped them and named that group <CLASS>" a valid answer to "where do <CLASS> laws come from"?
05:05:07 <merijn> > readMaybe "99" :: Maybe Int
05:05:09 <lambdabot>  Just 99
05:05:49 <tdammers> bloogie: bit tongue-in-cheek, but pretty much yes - "we liked them" means "we liked them because they turned out useful"
05:05:52 <Cooler> well it works in ghci,   i have an array arr of objects, and i wanna do    arr !! read idx
05:05:59 <Cooler> where idx is String
05:06:12 <merijn> Cooler: if you use !! then ghc infers you meant Int
05:06:16 <Cooler> not sure if it works because ghci defaulted it
05:06:18 <tdammers> Cooler: that's because type inference tells ghci that read in this case must return Int
05:06:25 <Cooler> ok
05:06:43 <tdammers> but without the extra context that determines the return type, ghci can't figure it out, and defaults to ()
05:06:54 <tdammers> (while plain ghc will instead raise a compiler error)
05:07:24 <tdammers> `read` basically says, "give me a String, and I'll give you any type you want, as long as that type has a Read instance"
05:07:39 <tdammers> but in order for that to work, you have to actually tell it what type you want
05:07:59 <tdammers> either by annotating explicitly, or by feeding the output to another function that determines the type
05:08:13 <tdammers> in this case, (!!) says that its RHS operand must be Int
05:08:25 <tdammers> which automatically establishes that what you want from `read` must also be Int
05:10:27 <ertes-w> incoming rant…
05:10:43 <ertes-w> STOP PUTTING ARBITRARY RESTRICTIONS INTO FUNCTIONS!
05:10:51 <ertes-w> > intToDigit 15
05:10:53 <lambdabot>  'f'
05:10:54 <ertes-w> > intToDigit 16
05:10:56 <lambdabot>  *Exception: Char.intToDigit: not a digit 16
05:11:22 <Cooler> shouldn't that be called intToHex?
05:11:23 <tdammers> more like, STOP NAMING YOUR FUNCTIONS INACCURATELY
05:11:34 <tdammers> intToHexDigit -- problem solved
05:11:41 <Cooler> ^
05:11:42 <ertes-w> that's bullshit
05:11:43 <Philonous> Still partial
05:11:52 <ertes-w> why limit it in the first place?
05:11:54 <tdammers> actually yes, it's still bad
05:12:15 <tdammers> because there's no hex digit of value 16
05:12:21 <tdammers> but then, why have Int as the domain
05:12:33 <tdammers> should be HexDigit
05:13:02 <Cooler> or Hex
05:13:03 <tdammers> or, alternatively, that function might take the lowest 4 bits and just ignore the rest
05:13:12 <Cooler> Hex :: Int -> [Char]
05:13:23 <ertes-w> no, why cut off at 'f'?  it's an arbitrary restriction, so now that i need a function that goes to 'z' i need to write my own
05:13:45 <tdammers> ertes-w: yes, I understand your gripe
05:14:08 <tdammers> ertes-w: just saying that it *might* make sense to have a function that only ever produces valid hex digits
05:14:58 <ertes-w> i hate PHP…  you know i do…  but there are *some* things we can learn from it =)
05:15:36 <tdammers> like what? "implement unicode strings before your language implementation becomes so messy that nobody dares touch the string code"?
05:16:03 <ertes-w> yeah, like that
05:16:54 <tdammers> "when somebody tells you that your exception handling implementation lacks a 'finally' keyword, listen to them"
05:18:14 <merijn> ertes-w: We already have on like that
05:18:58 <merijn> :t Numeric.readInt
05:19:00 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
05:19:16 <ertes-w> yes, i know
05:19:25 <ertes-w> also more liek showIntAtBase
05:19:27 <ertes-w> like
05:19:35 <merijn> oh, for show, yes
05:20:51 <merijn> > Numeric.showIntAtBase 36 ((['0'..'9']++['a'..'z'])!!) 4971947
05:20:53 <lambdabot>  <[Char] -> [Char]>
05:20:59 <merijn> > Numeric.showIntAtBase 36 ((['0'..'9']++['a'..'z'])!!) 4971947 ""
05:21:01 <lambdabot>  "2ykdn"
05:22:25 <ertes-w> merijn: yeah, exactly…
05:22:42 <ertes-w> > showIntAtBase 36 intToDigit 500 ""
05:22:44 <lambdabot>  "*Exception: Char.intToDigit: not a digit 32
05:23:15 <roconnor> I was looking for the canonical isomorphism between Bool and Maybe ().  It turns out to be guard and is Just.  Looks like isJust is useful afterall. :D
05:23:47 <ertes-w> it would fit perfectly, but no…  intToDigit thinks that programmers are stupid and need to be patronised
05:23:51 <merijn> roconnor: Why not "fromMaybe False (const True)" ?
05:24:03 <roconnor> That's fine too, but isJust is shorter.
05:24:11 <merijn> ertes-w: Not sure I agree
05:24:20 <merijn> ertes-w: Who decides what digits >9 should be
05:25:25 <ertes-w> merijn: i'm happy with the arbitrary choice of using letters
05:28:04 <kuribas`> > 3464222640803604219751913774552677603 ^. re (base 35)
05:28:06 <lambdabot>  "allyourbasearebelongtous"
05:29:27 <merijn> I don't suppose anyone's written a tool to output grouped criterion numbers sorted by performance?
05:29:56 <merijn> i.e. I have a large number of benchmarks and would like to turn them into ranking, but doing so by hand each time is annoying
05:31:52 <kuribas`> > 121241300170824412702092713388346906099 ^. re (base 35)
05:31:55 <lambdabot>  "allaboutthatbasenotrouble"
05:32:11 <merijn> *treble :p
05:34:01 <kuribas`> lol
05:45:50 <liste> what's the easiest way to count Trues in a list?
05:46:05 <liste> (or any values with Eq)
05:46:29 <lyxia> length . filter id
05:46:57 <liste> lyxia: thanks
05:58:17 <ZuluKing> hey, can anyone tell me how can I apply a filter function that takes two arguments?
05:58:27 <Clint> what would the two arguments be?
05:58:54 <ZuluKing> one is obviously the item in list and then one another generic type
05:59:08 <ZuluKing> i need to compare item to that, cannot hardcode
05:59:25 <merijn> Not sure what "another generic type" means
05:59:40 <ZuluKing> Like List.filter(a -> a.Equals(x))
05:59:58 <merijn> ZuluKing: so... just "filter (==x)"?
06:00:00 <ZuluKing> I need to pass that x to filter function as well, which is obviously not allowed
06:00:25 <merijn> > filter (/=3) [1..10]
06:00:28 <lambdabot>  [1,2,4,5,6,7,8,9,10]
06:00:34 <exarkun> Remember that all functions actually only take one argument.  Functions that look like they take more actually just take one argument and return another function.
06:00:53 <ZuluKing> merijn that was a simplification, x is a record and I need to extract some fields from it
06:00:53 <exarkun> (that takes an argument and returns ...)
06:01:07 <ZuluKing> Yeah, I know. I just want to know how to do it
06:01:09 <merijn> I still don't understand what the problem is
06:01:52 <ZuluKing> List.filter(a -> a.Blah.Blah.q.Equals(x.Blah.Blah.q))
06:02:05 <ZuluKing> Its a nested record
06:02:16 <ZuluKing> I need to extract the fields inside the filter function
06:02:17 <exarkun> So you just need a function that takes `a` and `x` and does `a.Blah.Blah.q.Equals(x.Blah.Blah.q)`
06:02:25 <ZuluKing> yes
06:02:47 <exarkun> `f x a = a.Blah.Blah.q.Equals(x.Blah.Blah.q)` (except that doesn't look like Haskell but ...)
06:03:16 <exarkun> And then `g = f some_x` gives you a function `g` that takes one argument, an `a`.  now `g` is your filter.
06:04:32 <ZuluKing> exarkun, ahh I get it, passing partial arguments to functions
06:04:33 <merijn> wow...I'm impressed, async's wait is surprisingly cheap
06:04:54 <ZuluKing> Sorry for the dumb questions, I am still learning Haskell.
06:05:50 <exarkun> ZuluKing: np!  glad I could help.
06:05:51 <merijn> Keeps up very well with my AtomicCounter/IORef spinloops, but without the ridiculous inconsistency at high contention
06:06:26 <CoolerZ> pika pika pika pi pika pika pikachu
06:06:30 * exarkun has plenty of his own dumb questions
06:07:29 <ik> hey guys, I'm trying to use mainland-pretty. I want to be able to have an overlapping instance for some lists of my data types (instance {-# OVERLAPPING #-} Pretty [MyType] where...). How do i hint GHC to favor a specific overlapping instance? Or does the (Pretty [a]) instance have to be marked explicitly as overlappable? Or am I completely misusing these pragmas and should just use foldMap on my lists to do whatever I want?
06:08:15 <CoolerZ> can you not have multiple statements in a let block?
06:09:24 <CoolerZ> getting an error on line 3
06:09:24 <CoolerZ> https://hastebin.com/minoboteki.hs
06:09:53 <mauke> CoolerZ: bad indentation
06:09:59 <mauke> remove space before 'entry'
06:10:35 <CoolerZ> what?
06:10:39 <CoolerZ> by how much?
06:10:56 <ik> CoolerZ: entry is below the second paren
06:10:59 <mauke> one space
06:11:08 <mauke> so the two definitions line up
06:11:18 <CoolerZ> its already lined up
06:11:21 <mauke> no
06:11:38 <CoolerZ> oh nvm
06:12:18 <lyxia> ik: {-# OVERLAPPING #-} should be sufficient
06:12:54 <lyxia> ik: you might need a few annotations
06:13:43 <ik> lyxia: annotations?
06:14:23 <lyxia> Type annotations, to help the type checker
06:14:44 <ik> lyxia: oh, ok. thanks
06:41:47 <Cooler> why is drawTree :: Tree String -> String http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Tree.html
06:41:49 <Cooler> ?
06:42:10 <Cooler> why not drawTree :: Show a => Tree a -> String?
06:42:48 <c_wraith> Cooler: they're just an fmap show apart...
06:43:20 <c_wraith> Cooler: and actually, that sort of is why.
06:43:24 <c_wraith> > show "hello"
06:43:27 <lambdabot>  "\"hello\""
06:43:54 <c_wraith> Cooler: I think drawTree didn't want to insert quotes that weren't already present
06:44:03 <Cooler> oh
06:44:04 <Cooler> ok
06:44:16 <Cooler> why does show do that?
06:44:31 <Cooler> Show on string can't just return string?
06:44:38 <c_wraith> because the general idea with show is to produce Haskell code.
06:44:54 <c_wraith> show on a String should produce Haskell code to generate that String
06:44:54 <Cooler> what/
06:45:20 <Cooler> i don't understand
06:46:01 <ongy> The derived show instances are valid haskell iirc. Also read . show should be id (it isn't always, but it's good if it is)
06:46:15 <lyxia> > show (Just "Hello")  -- you wouldn't want to see "Just Hello"
06:46:17 <lambdabot>  "Just \"Hello\""
06:46:40 <fsestini> Cooler: think of the “” as a constructor for String
06:46:56 <ongy> > text . show $ Just "Hello"
06:46:58 <lambdabot>  Just "Hello"
06:47:27 <c_wraith> Cooler: the output of show *generally* should be a string that if used as haskell source, is an expression that produces the value shown.
06:47:37 <ongy> lambdabot shows a 2nd time, which makes it look more confusing than it actually is
06:48:40 <ongy> > text . show $ "Hello" -- Cooler Show is actually this. And a string obviously should get "" added
06:48:41 <lambdabot>  "Hello"
06:48:49 <ongy> show "Hello" I mean
06:49:54 <ongy> what happened earlier is exactly why Tree String is better than Show a => Tree a, since it's easy enough to apply show yourself, but messes up strings
06:50:23 <Cooler> ok but why does show have to produce valid haskell code
06:50:25 <Cooler> ?
06:50:47 <c_wraith> that's what is defined as the best behavior for it.
06:50:52 <merijn> Because then you can easily copy/paste things
06:50:56 <ongy> it doesn't *have* to, but the derived instances do and it's a general good idea
06:51:03 <c_wraith> So the question is kind of like asking why 1+1 is 2.  Because that's what we've defined 2 as.
06:51:27 <ongy> well, Monads don't *have to* follow monad laws either, I guess saying it's not enforced doesn't say much about type classes
06:51:54 <ongy> I would really love that feature in haskell. Enforce some proveable properties about type classes...
06:52:30 <c_wraith> Maybe after DependentHaskell lands.  And then, of course, we'd still need TotalHaskell to land..
06:53:34 <vegai> would using QuickCheck be enough?
06:54:01 <c_wraith> There's actually a library for testing type class properties with something like quickcheck.  I can't recall the name..
06:54:24 <Cooler> is there a context free grammar for Haskell?
06:54:37 <c_wraith> Well, now.  Haskell's grammar isn't context-free.
06:54:39 <c_wraith> *no
06:54:43 <ongy> I hate doing tests, mostly because I'm never content with mine. Either I'm missing stuff or it's just way to much effort imo. But that's probably just me 
06:54:58 <merijn> ongy: Word :p
06:55:03 <Cooler> whats an example of that?
06:55:03 <c_wraith> The ability to define operators with custom fixities means that parsing haskell code depends on the result of parsing haskell code.
06:55:24 <merijn> ongy: I keep thinking I should just sucker newbies to write tests for me as "haskell practice" ;)
06:55:52 <ertes-w> i don't test with 100% coverage…  not even if you count GHCi experiments as testing
06:56:06 <c_wraith> I type-check with 100% coverage.
06:56:13 <ertes-w> "it compiles, it's probably fine"
06:56:17 <ongy> merijn: hehehe. I actually have a test-system for layer2 protocols for my work (well, we test toy implementations by our students) and this really shows how many tests are required for a full coverage
06:57:11 <ongy> most problems that escape me come up on different systems that do weird things... like antivirus removing files -.-
06:57:48 <ongy> but I don't write big projects either, I like my little things :)
06:59:10 <c_wraith> Cooler: the expression "a ^& b ^& c" will parse as "(a ^& b) ^& c", "a ^& (b ^& c)", or it won't parse at all.  Knowing *which one* it parses as requires the result of parsing any fixity declarations for ^&.
07:00:29 <c_wraith> Cooler: This is a proof that parsing haskell is context-sensitive.  Parsing it requires information resulting from parsing it.
07:02:04 <CoolerZ> so is every language that allows you to add operators context sensitive?
07:02:25 <CoolerZ> add operators as in define new ones
07:02:27 <c_wraith> Not necessarily.  The important part is that Haskell allows you to specify fixity
07:02:28 <merijn> CoolerZ: Not if the operators all have predefined fixity
07:02:38 <CoolerZ> right
07:02:49 <c_wraith> In scala, the fixity is determined by first character in the operator from a static table
07:03:02 <c_wraith> fixity/precedence, that is
07:03:49 <c_wraith> So it only depends on the text of the operator to know how to parse it.  And that means you can still make that part of the grammar context-free
07:04:28 <Axman6> is there an infix version of traverse?
07:04:45 <orion> I'm reading an article which says, "If a structure `g a` does not support the fmap operation..." What is the difference between a structure `g a` and a structure `f g a`?
07:04:55 <CoolerZ> so a lalr parser wouldn't be able to parse Haskell?
07:05:01 <orion> I'm hung up on the word "structure".
07:05:21 <byorgey> orion: don't be
07:05:26 <byorgey> orion: it seems vague at best
07:05:58 <c_wraith> CoolerZ: not by itself.  GHC actually uses a LALR parser, though.  It just...  cheats a bit.  It does a post-processing step that fixes up the parse tree for expressions involving multiple operators.
07:06:50 <CoolerZ> all of the hackiness
07:07:02 <c_wraith> It actually works well enough in practice.
07:07:08 <byorgey> orion: I would think 'structure' means something like 'value', i.e. 'data structure'.  But that doesn't make sense since values can't in and of themselves support or not support fmap.
07:07:18 <byorgey> orion: I guess it is really talking about 'g' supporting fmap or not
07:25:11 <quchen> What’s the »equality prism« to access only elements equal to something else? For example, I’d like to change all the numbers »2« in a list »xs«.
07:25:48 <quchen> myList & traverse . equal 2 .~ 5
07:25:51 <quchen> Something like that
07:26:14 <quchen> [1,2,2,3,2] & traverse . equal 2 .~ 5  ====>  [1,5,5,3,5]
07:26:57 <Philonous> I'd be surprised if you could do that
07:27:30 <mmo> Does anybody know why I can't post anything in the haskell subreddit. I am new to the community and created my account yesterday. Neither my comments nor my posts can be seen by public visitors or other members.
07:28:15 <Philonous> I'd expect there to be a law that states that xs & s .~ x & s .~ y === xs & s .~ y 
07:28:25 <mauke> sounds like you're shadowbanned
07:28:38 <mauke> or in a moderation queue
07:29:24 <quchen> Ah, filtered!
07:29:25 <quchen> > [1,2,2,3,2] & traverse . filtered (== 2) .~ 5
07:29:27 <lambdabot>  [1,5,5,3,5]
07:29:39 <Philonous> Heh
07:29:56 <lyxia> mmo: wait a day or two
07:29:58 <ZuluKing> hey, guys I am back, one more question, how do you go about implementing an infinite if condition then action else sleep loop?
07:30:15 <Philonous> I stand corrected
07:30:40 <mmo> Do I have to do some test of courage to be accepted :-D? This was really annoying, as I was giving really long advice in the comments and was wondering why nobody actually cared about it.
07:30:45 <ZuluKing> I tried forever but it doesn't execute, just keeps creating an infinite function call stack
07:31:32 <lyxia> forever (b <- getCondition ; if b then action else sleep)
07:31:45 <ZuluKing> mmo, haskell community is one of the nicest, no tests of courage required, you completed that when you tried to install stack :P
07:32:51 <mmo> ZuluKing: Haha :) I am using cabal. Currently I am attending a course by hvr in university and he is a cabal contributer 
07:33:21 <ZuluKing> lyxia, if my action happens to be a function call, it never actually executes it
07:33:41 <ZuluKing> mmo, even stack uses cabal internally, there is no haskell without cabal
07:34:35 <c_wraith> filtered is the best illegal traversal ever.
07:34:37 <lyxia> ZuluKing: can you paste your attempt
07:35:24 <c_wraith> mmo: hvr has time to teach in addition to fixing upper bounds on hackage all day?  I'm impressed. :)
07:35:52 <Axman6> he's the people's hero
07:36:27 <c_wraith> mmo: the wikis have had a *lot* of spam problems.  I'd say that one of the anti-spam measures is what has caught you, and it's probably not even something you did in particular.
07:36:29 <Philonous> c_wraith, So it's not a lawful traversal after all? Thank goodness. I was really confused
07:36:43 <ZuluKing> lyxia, okay, gimme a min
07:36:49 <c_wraith> Philonous: it's only lawful as a Fold.  But it's *so handy* as a traversal...
07:38:43 <lpaste> ZuluKing pasted “forever FooBar” at http://lpaste.net/355448
07:39:14 <ZuluKing> lyxia, can you take a look?
07:40:36 <lyxia> ZuluKing: you should be using forever specialized at IO, not at (->)
07:41:08 <ZuluKing> lyxia, I don't understand, sorry
07:41:29 <lyxia> ZuluKing: forever (reminderOrSleep (timeforReminder jstTime) jstTime)
07:42:22 <ZuluKing> lyxia, can you explain the difference, sorry I am new
07:43:17 <lyxia> forever applied to a function (reminderOrSleep :: _ -> _) will loop, as you have observed. by adding the parentheses, forever is instead applied to a value of type IO ()
07:43:33 <ZuluKing> lyxia, ahh, I get it
07:43:51 <ZuluKing> lyxia, thanks for the taking time to explain, cheers!
07:44:29 <lyxia> you're welcome
07:50:23 <quchen> I need a function »Fold' a (b,c) -> Fold' a b«. Unfortunately, \myFold -> myFold . _2 does not do the trick :-( Any tips?
07:50:38 <quchen> I’m randomly sampling combinations of lens definitions at this point
07:50:53 <quchen> s/_2/_1/
07:51:25 <c_wraith> In what way does that not do the trick?
07:52:45 <quchen> Does not typecheck
07:53:24 <quchen> Let me get the type error online
07:54:42 <quchen> http://lpaste.net/355449 c_wraith 
07:55:58 <lyxia> something composed with _2 can't be a prism
07:56:28 <quchen> Why not?
07:56:44 <quchen> Oh.
07:56:46 <quchen> Right.
07:56:56 <quchen> It’s hard to construct a 2-tuple given only one element.
08:01:12 <ertes-w> :t join (,)
08:01:13 <lambdabot> b -> (b, b)
08:02:38 * hackage bound 2 - Making de Bruijn Succ Less  https://hackage.haskell.org/package/bound-2 (ryanglscott)
08:03:38 * hackage servant-py 0.1.0.1 - Automatically derive python functions to query servant webservices.  https://hackage.haskell.org/package/servant-py-0.1.0.1 (erewok)
08:04:43 <hpd_m> is it normal that aeson needs >15GB of memory to parse a 839M json file or am I doing something wrong? (That's just decode'ing to a Value and forcing the result)
08:08:22 <Axman6> Value isn't exactly a particularly space efficient data type
08:09:33 <cocreature> I guess it depends on what makes that json file 839M big
08:09:47 <Axman6> and you may not want to force it, I've seen really good results just making good use of laziness
08:11:05 <lyxia> aeson is not lazy
08:14:38 * hackage servant-py 0.1.0.2 - Automatically derive python functions to query servant webservices.  https://hackage.haskell.org/package/servant-py-0.1.0.2 (erewok)
08:15:33 <hpd_m> the file contains many objects with short strings. So if you say value is not ideal: Does aeson always parse a Value into memory before calling parseJSON or is the conversion done on the fly?
08:16:38 * hackage servant-py 0.1.0.3 - Automatically derive python functions to query servant webservices.  https://hackage.haskell.org/package/servant-py-0.1.0.3 (erewok)
08:19:24 <Cooler> is this the datatype for graphs with cycles?
08:19:26 <Cooler> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Graph.html
08:20:47 <Cooler> directed graph
08:20:53 <Cooler> with cycles
08:27:32 <lyxia> hpd_m: it parses a while Value 
08:27:39 <lyxia> whole 
08:29:09 <lyxia> Cooler: there's also fgl. I have no idea how they compare 
08:31:10 <hpd_m> lyxia: ok, thanks
08:31:26 <cocreature> in a lot of cases an IntMap is the easiest solution for graphs
08:31:40 <cocreature> or if you don’t need to modify them vectors
08:32:05 <EvanR> with a nice inductive interface on top?
08:32:13 <cocreature> nah
08:32:19 <EvanR> T_T
08:33:06 <cocreature> I mean if those inductive interfaces help you, by all means go for it. but personally I haven’t found them particularly useful
08:41:27 <Cheaterok_> hey guys
08:41:52 <Cheaterok_> help me please, just started to learn haskell, trying to write pi function using nilakhanta series
08:42:01 <Cheaterok_> https://pastebin.com/DvLXSiPM this is the code
08:42:15 <Cheaterok_> https://pastebin.com/nwCfWD6b this is error log
08:42:46 <Cheaterok_> seems like interpreter cant print Fractional or something
08:43:32 <EvanR> thats the error message but what did you type into the interpreter
08:43:34 <Cooler> lyxia, fgl?
08:43:45 <Cheaterok_> calculate_pi 3
08:43:55 <Cheaterok_> after loading my module
08:44:23 <lyxia> Cooler: http://hackage.haskell.org/package/fgl
08:44:32 <EvanR> it may not know what Fractional a and Integral a you want
08:44:53 <EvanR> what a is, could be several things and what prints out depends on the choice
08:45:05 <Axman6> I there any type which actually instanciates both?
08:45:24 <EvanR> good point
08:45:33 <Cheaterok_> type signature is (Integral a, Fractional a) => a -> a
08:45:49 <EvanR> so whats an example a you would pick?
08:45:51 <Axman6> I'm pretty sure that doesn't make any sense except in the case where  is symbolic
08:46:03 <Cheaterok_> Fractional, i quess
08:46:09 <EvanR> thats not a type
08:46:13 <EvanR> its a class
08:46:14 <Cheaterok_> Float then
08:46:19 <EvanR> thats not Integral
08:46:28 <Cheaterok_> oh thats hard
08:46:34 <EvanR> i know right
08:47:02 <EvanR> what an algorithm
08:47:19 <Cheaterok_> https://pastebin.com/DvLXSiPM here it is
08:47:42 <Cheaterok_> i think parameter should be Int, but return value could be int and float
08:47:45 <EvanR> youre not really using Integral  methods
08:47:51 <Cheaterok_> and i dont know a type that represents both
08:48:01 <EvanR> this is a good example to show why theres no one true number type
08:48:20 <EvanR> you have to pick what aspects you want from your numbers more carefully
08:49:09 <Cheaterok_> so i cant return either int or float from function, i should choose one of them?
08:49:12 <EvanR> Cheaterok_: youre not using Integral methods
08:49:26 <javjarfer> Hi! Anyone knows which is the most idiomatic way of triggering one event, when one event stop being emitted (timeout) in FRP?
08:49:26 <EvanR> and your algorithm uses / which requires Fractional
08:50:00 <EvanR> Cheaterok_: for the depth component youre just using Num. at the point where they interact you can just convert the argument type to the result type with fromIntegral
08:50:10 <EvanR> oh uh... then youd be using Integral, but itd be ok
08:50:24 <EvanR> calculate_pi :: (Integral a, Fractional b) => a -> b
08:50:47 <Cheaterok_> EvanR: thanks)
08:50:48 <EvanR> it doesnt make sense to return an integral number if youre trying to calculate pi o_O
08:52:21 <EvanR> the interplate between Integral and Fractional really is a great brain exploding aspect of haskell. many languages muddy the numerics, cause confusion
08:53:08 <Cheaterok_> yeah, coming from python background it was quite a suprise how this all works in haskell
08:53:36 <EvanR> python has several number types too, but it autoconverts between them in surprising ways
08:54:07 <EvanR> well theyd hope its not surprising, but it is to me
08:54:26 <kamyar> Anyone here help me in Stack build?
08:55:33 <glguy> kamyar: As usual, you'll have to ask your question before you can get help with it
08:56:22 <Cheaterok_> one more thing: is there a type that can hold infinitely large float?
08:56:43 <hvr> Cheaterok_: Rational?
08:56:55 <kamyar> glguy: I asked twice hours ago no one answered!
08:56:59 <EvanR> thats not a float
08:57:13 <EvanR> theres Data.Scientific but that only works for base ten
08:57:24 <hvr> EvanR: how do you define a float?
08:57:28 <EvanR> theres bindings to MPFR which has arbitrary precision floats
08:57:32 <kamyar> I wanna add a depencendy which is not in cabal or stackage, I have downloaded and installed it. I want to use 'any' as version in extra-deps part. How it is?
08:57:50 <kamyar> extra-deps: [CBOR-0.1.0.1, random-strings-0.1.1.0, persistent-uuid-any] raises error!
08:58:05 <kamyar> it is in stak.yaml
08:58:11 <kamyar> stack.yaml
08:58:13 <glguy> kamyar: Right, you never use an "any" version. The point of the stack.yaml is to manually specify exactly which versions you're using
08:58:59 <kamyar> I have inatalled the package and checked version but it does not work
08:59:04 <EvanR> hvr: the numbers are of the form m * b^i 
08:59:04 <kamyar> extra-deps: [CBOR-0.1.0.1, random-strings-0.1.1.0, persistent-uuid-0.1.0.2]
08:59:36 <kamyar> The following package identifiers were not found in your indices: persistent-uuid-0.1.0.2
08:59:39 <glguy> kamyar: If you're using a local checkout of the source code, you can list that in your `packages` section
08:59:52 <kamyar> glguy: Ok lets try
09:00:51 <kamyar> glguy: No it is not local! I have installed it in .cabal and .stack directories
09:01:00 <EvanR> Cheaterok_: you can also check out two exact real number packages, these dont use floating point, but they arent limited to just rationals either
09:01:04 <glguy> kamyar: That's now how it works
09:01:42 <kamyar> glguy: How can I use the installed version?
09:01:50 <glguy> no
09:02:12 <kamyar> What ae .cabal and .stack meant for?
09:02:14 <Cheaterok_> EvanR, thank you
09:02:44 <kamyar> glguy: How can I check the stack indices? what is the command line?
09:03:08 <glguy> I don't know that there is one. You can look at a resolver's contents on stackage.org
09:05:03 <hvr> EvanR: ok, but then if you equate b^i to 1/d, isn't m*(b^i) and m/d effectively isomorphic to each other?
09:06:00 <hvr> (except for the d=0 anomaly)
09:08:49 <EvanR> hvr: no
09:09:14 <EvanR> 1/3 has no form m*2^i
09:09:43 <EvanR> > pi :: CReal -- Cheaterok_ 
09:09:45 <lambdabot>  3.1415926535897932384626433832795028841972
09:09:54 <EvanR> should have a ... after that
09:11:45 <Axman6> > showCReal 80 pi
09:11:47 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
09:12:21 <EvanR> now thats what im talkin about
09:25:13 <hvr> EvanR: for b=3 it does
09:25:39 <EvanR> hvr: with rational you can represent any rational
09:25:53 <EvanR> no base involved, no floating-point as such
09:26:28 <EvanR> but floating point lets you reach much more distant or close-to-zero dynamic range
09:28:08 <EvanR> hvr: you choose a fixed base, like Scientific is b=10, other libraries may be b=2
09:28:28 <EvanR> 1/3 feels neglected
09:28:47 <hvr> this only because we have an even number of fingers...
09:29:08 * hackage relational-query-HDBC 0.6.1.1 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.1.1 (KeiHibino)
09:29:23 <EvanR> one of my professors was into trinary logic hardware and arithmetic
09:36:22 <ADG> I want to do something like this `set.insert(x+y) where x<-list, y<-list` and then `print $ keyNotIn set`
09:36:38 * hackage relational-query-HDBC 0.6.2.0 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.6.2.0 (KeiHibino)
09:37:06 <EvanR> ADG: maybe you should make sets of out the lists and do unions
09:37:07 <orion> EvanR: Yesterday I asked, "Under what conditions would you use the free package, and when would you use the monad-coroutine package?" and you said, "or would you make your own based on thethe oleg freer monad tutorial". I read the tutorial but I failed to comprehend its meaning.
09:37:15 <orion> Why is that more useful than using, say, the free package?
09:38:08 * hackage structs 0.1 - Strict GC'd imperative object-oriented programming with cheap pointers.  https://hackage.haskell.org/package/structs-0.1 (ryanglscott)
09:38:10 <EvanR> orion: well, the free package depends on 12 other packages and the freer monad implementation on that page is about a page in size
09:38:26 <glguy> orion: The free package offers more than just the Free type. Are you specifically asking about the Free type?
09:38:28 <EvanR> so if you just want a dumb free monad...
09:38:52 <EvanR> the free package does provide a fancy church encoded version
09:39:04 <EvanR> and transformers
09:39:32 <orion> glguy: Yes. I have a very specific goal: suspend and resume a Free Monad-based DSL interpreter, while being able to output values upon suspend and receive values upon resume.
09:40:21 <orion> Now, I currently found success with the monad-coroutine package, but when I had lunch with Ed Kmett, he said I could use the free package instead.
09:40:39 <orion> Even though my code works, it looks awful and complicated. I feel like I need to refactor it.
09:40:47 <EvanR> i just made something like that
09:40:57 <orion> Thus, I am reevaluating my design decisions.
09:41:40 <EvanR> http://lpaste.net/355452
09:42:36 <orion> https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/NoiseState.hs#L121 <-- all of this looks nasty. It's what I'm trying to rewrite.
09:43:32 <EvanR> i wanted to write suspendable scripts, 53 lines is the DSL, 30 lines is the free monad which could go in a separate file
09:44:14 <EvanR> DSL+interpreter
09:44:25 <orion> EvanR: Wow, that's pretty neat. Do you have an example program you can share?
09:45:37 <ADG> how would I write this in haskell `int[] arr1 ... int[] arr2 ... bool[] arr = new bool[n]; for(int x: arr1){ for(int y:arr2){ arr[x+y] = true; }}`
09:46:40 <EvanR> orion: i mean, i pasted the code
09:47:04 <orion> EvanR: Oh, I meant to ask about an actual script you've written.
09:47:30 <EvanR> not beyond tests, just do notation which test drives each effect
09:47:45 <orion> Ah, I see.
09:47:52 <EvanR> and does a recursion to loop
09:48:11 <WarmCookie> edwardk: ping
09:48:13 <EvanR> so there might be some lingering space leaks or soemthing
09:48:34 <orion> "The following Freer monad is not (yet) extensible and not very optimal Either."
09:48:58 <EvanR> yeah
09:49:02 <EvanR> thats what i heard ;)
09:49:17 <orion> heh
09:49:34 <EvanR> when you want performance, you rewrite your DSL without a free monad
09:50:31 <EvanR> by implementing the effects as whatever the interpreter would have done
09:50:51 <orion> You ditch the free monad? At what cost? Type safety?
09:50:58 <EvanR> same safety
09:51:28 <EvanR> the cost is your brain doing donuts to actually write the code, and then its not as maintainable i imagine
09:51:45 <EvanR> if you wanted to change the DSL
09:52:01 <WarmCookie> edwardk: Apologies for the trouble, mniip just applied the requested cloak on `nitrix` but I've never liked the name because in the recent years, a pharmeutical company named a product the same. I went for something more permanent and I did a nick and account change just now, but I'm stuch with nitrix's cloak and have to ask you again ask them to get it renamed.
09:53:01 * EvanR graph[nitrix] = forward(WarmCookie)
09:53:22 <MarcelineVQ> nitrixinolocytocologloblin?
09:53:38 <orion> EvanR: Ah, I see. Since my DSL describes high-level cryptographic operations, I place a high value on code auditability. I suppose the actual crypto operations will be the bottleneck, not the interpreter.
09:53:39 <WarmCookie> Make it a functor! :)
09:53:53 <EvanR> orion: then good
09:53:58 <orion> Thus, it might make sense to stick with the free monad.
09:54:24 <orion> One thing still is unclear though: What does "encoding" mean in "Church encoding"?
09:54:52 <EvanR> youre writing down the same thing in some sense, but in a different way
09:55:04 <c_wraith> orion, the machine level representation of a semantic concept. 
09:55:55 <c_wraith> orion, the free monad is a concept. how it's represented in the machine is an independent issue. 
09:58:36 <orion> The Free Monad *is* the AST, right? And that would make the Church encoded version just a more efficient data structure to represent the AST?
09:59:10 <EvanR> a value of your DSL's type isnt an AST
09:59:23 <EvanR> its got closures in there, introduced by >>=
09:59:49 <EvanR> its not syntax
10:00:24 <orion> Oh, because I'm not parsing anything?
10:00:34 <EvanR> no
10:01:37 <EvanR> an AST would have concrete tokens in it representing program on the page
10:01:49 <orion> Are you saying that in the Free Monad design pattern there is no AST because you're literally creating values directly in the code?
10:01:53 <EvanR> but in a free monad, you have the top level effect followed by a function, and you dont know what the function will return
10:02:06 <EvanR> until you run it
10:03:12 <EvanR> if you had an AST you could print it out and view it
10:04:46 <orion> I suppose I could derive a Show instance for the DSL.
10:06:42 <EvanR> i think youll run into problems in most DSLs doing that
10:06:55 <EvanR> you cant follow continuations, you dont get variable names
10:07:24 <orion> Ah, good point.
10:08:12 <glguy> orion: My config-schema package is an example of using a free applicative instead of a free-monad so that I can print my program without running it
10:08:29 <EvanR> but i did see a paper where the representation let you do that... using quotation https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
10:09:04 <Sheogorath> is this a thing i can write? type TRead = forall a. (Int, TVar a)
10:09:37 <EvanR> starting on page 1010
10:09:39 <glguy> Sheogorath: You can write that with extensions, it probably doesn't mean what you want it to
10:09:43 <orion> EvanR: Thank you.
10:09:56 <orion> glguy: Interesting! What power did you lose by using a Free Applicative instead of a Free Monad?
10:10:23 <glguy> orion: The structure of your program can't depend on values produced by interpreting your program
10:10:48 <stphrolland> HI, there seem to be several package for MaybeT. They even link to this more widely used, but I can't find the package corresponding to: https://wiki.haskell.org/New_monads/MaybeT
10:10:58 <stphrolland> Wht do you use when you want MaybeT ?
10:10:59 <Sheogorath> actually could i just drop the forall? that's probably what I mean
10:11:07 <glguy> stphrolland: transformers
10:11:10 <orion> glguy: Ha, that seems obvious in retrospect.
10:11:36 <EvanR> Sheogorath: type TRead a = (Int, TVar a) would work
10:12:18 <sproingie> is there a decent Free monad tutorial out there?  i only have the vaguest idea what those puppies are.
10:12:24 <Sheogorath> My intent is to throw away the a so I can put it in a list with different "a"s
10:12:40 <EvanR> Sheogorath: i thought as much
10:12:42 <sproingie> (free monads, monads i get just fine)
10:12:59 <EvanR> how do you intend to make use of the elements of that collection if you dont know what the types are?
10:13:15 <EvanR> beware trick question
10:13:39 <orion> sproingie: I too struggle(d) with the concept, but I found this to be enlightening: http://stackoverflow.com/questions/13352205/what-are-free-monads
10:14:14 <splanch> i've been using the ideas from 'PHOAS for Free' enough that it would be more convenient in library form
10:14:44 <EvanR> P HOAS?
10:15:07 <splanch> https://www.schoolofhaskell.com/user/edwardk/phoas
10:15:22 <orion> glguy: Your config-* packages are interesting. Are you happy with them?
10:15:44 <sproingie> Sheogorath: the problem is you have no downcasting, so if you have a list of different "a"s, the only thing you can do with them is whatever constraint satisfies all a's
10:15:55 <Sheogorath> as a side note TVar isnt the builtin TVar. I don't need to know a. I just care about a timestamp in the TVar a
10:16:07 <glguy> orion: Yeah, so far so good. I use them to provide configuration to a couple different projects
10:16:10 <sproingie> which is not a problem if you write OO-style polymorphism, but it does bite you pretty hard eventually
10:16:24 <EvanR> Sheogorath: erm, then you should fmap those TVars to TVar Timestamp?
10:16:38 * hackage partial-isomorphisms 0.2.2.1 - Partial isomorphisms.  https://hackage.haskell.org/package/partial-isomorphisms-0.2.2.1 (schernichkin)
10:16:48 <Sheogorath> data TVar a = TVar Timestamp a
10:16:56 <EvanR> or wrap them so be an IO Timestamp
10:17:08 <EvanR> Timestamp doesnt change?
10:17:19 <Sheogorath> going with TVar as a name was quite the mistake
10:17:25 <EvanR> indeed
10:17:48 <EvanR> it sounds like you want a container of Timestamps not TVar a's
10:17:54 <Cooler> how do i use Data.Graph
10:17:57 <Cooler> ?
10:18:07 <orion> glguy: Do you consider it production ready?
10:18:21 <Sheogorath> but that's what im trying to make. eh, probably need an MVar in there for changing it yeah.
10:18:35 <jle`> Sheogorath: what would you expect to do with a list of different types of TVar's
10:18:36 <EvanR> or a TVar ;)
10:18:49 <jle`> Sheogorath: becuase of parametric polymorphism, you can't do anything useful with what is inside them
10:19:12 <jle`> you can store a list of Int's though
10:19:23 <splanch> https://hackage.haskell.org/package/compdata-param is somewhat similar to what i want except they don't church/yoneda, dated, the alacarte stuff is extraneous...
10:19:28 <Sheogorath> isNew (Var time _) time' = time == time'
10:19:49 <Cooler> guyeez
10:19:53 <EvanR> that function is polymorphic enough to operate on TVar of any type a
10:19:58 <Cooler> how do i use Data.Graph?
10:20:08 <EvanR> so you could indeed wrap them to hide the a and put them all in a container
10:20:09 <glguy> orion: I'm not sure what qualifieds a small configuration file parser as production ready or not, but I use it for stuff every day. I don't expect it to change very much at this point
10:20:33 <Sheogorath> but needs some change. isNew mvar time = do {time <- fmap getTime . readMVar $ mvar; return ...}
10:20:38 <sproingie> Cooler: that kind of question never gets answered.  are you having a specific problem with it?
10:20:49 <EvanR> Sheogorath: you might need to rethink what youre trying to do
10:20:56 <Cooler> do you know about LR(0) items?
10:21:18 <sproingie> orion: thanks for the link BTW, that answer explained it pretty well
10:21:21 <Sheogorath> check the current timestamp of some Vars against the time they were read
10:21:25 <orion> sproingie: You're welcome.
10:21:35 <EvanR> Sheogorath: you can do that without any crazy types
10:21:44 <orion> glguy: I see. I've never worked with Free Applicatives before. Is this one such data structure: https://github.com/glguy/config-schema/blob/master/src/Config/Schema/Spec.hs#L85 ?
10:21:50 <EvanR> but i think implicitly youre trying to put them all in a container for some reason?
10:22:27 <Cooler> i wanna make a slr parsing table, so i need to make the state graph of lr(0) items
10:22:35 <EvanR> checkTimestamp :: Timestamp -> MVar (Timestamp,a) -> IO Bool
10:22:40 <glguy> orion: Ap is a free applicative and is used here https://github.com/glguy/config-schema/blob/master/src/Config/Schema/Spec.hs#L97 The type you linked to is used with Ap
10:22:47 <Sheogorath> yeah, gather the Vars up during a transaction and then check them all atomically
10:22:53 <Cooler> but Data.Graph seems to be for storing Ints
10:23:09 <EvanR> Sheogorath: i think youd do better to gather up all the results of checking instead?
10:23:21 <sproingie> i suspect Data.Graph is very polymorphic and perhaps its examples only use Ints
10:23:26 <EvanR> you cant check a bunch of MVars atomically anyway
10:23:38 <EvanR> or its a pain in the ass... maybe you want TVars
10:23:59 <Cooler> really? cause here it says Vertex = Int https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Graph.html
10:24:10 <orion> glguy: Thanks. I'll dig deeper in to the code.
10:24:28 <Sheogorath> yes, like i said im trying to make STM though. So using them would be a bit too easy :)
10:24:46 <EvanR> o_O
10:24:52 <EvanR> making STM with MVars
10:25:12 <EvanR> i dont think Timestamps is the way to go wtih that
10:25:22 <Cooler> your making a Silly Time Machine?
10:25:36 <Sheogorath> well, logical timestamps to check if someone changed something since the read.
10:26:05 <EvanR> have you read the STM paper
10:26:05 <sproingie> Cooler: so it is.  Data.Graph looks a bit more like a proof of concept, there might be more mature libraries out there
10:27:36 <Sheogorath> some time ago yeah. cant see how that would eeever be relevant :p
10:27:58 <sproingie> hackage is s...l...o...w today
10:28:25 <EvanR> Sheogorath: you can collect a bunch of IO Bools
10:28:40 <Cooler> so do i have to make my own?
10:28:41 <EvanR> then within an mutex, run them all
10:29:11 <EvanR> you can also do something more complicated to accomplish exactly what you said
10:29:33 <Sheogorath> good point
10:34:41 <Cooler> how would you make a directed graph with cycles?
10:35:29 <EvanR> use the fgl package?
10:36:13 <EvanR> i just found this slideshow on graphs http://jelv.is/talks/inductive-graphs-at-wagon
10:36:16 <cocreature> index your vertices by ints and keep an adjaceny list/vector/intmap for each of them.
10:36:20 <splanch> cycles can be encoded with functions
10:36:41 <splanch> https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf
10:36:58 <EvanR> knot tying exists...
10:37:12 <EvanR> but that seems even worse than inductive graphs
10:37:48 <splanch> it's awkward for cross edges, but how is it bad for cycles?
10:38:44 <EvanR> you cant easily change such a graph
10:39:02 <EvanR> and to traverse it you need to remember where you have been
10:41:25 <CoolerZ> EvanR, i dced, use fgl?
10:41:40 <CoolerZ> i think i need cabal for that
10:41:45 <EvanR> you missed a whole discussion
10:42:24 <EvanR> how are you doing anything without cabal?
10:42:58 <CoolerZ> i am compiling manually through the terminal
10:43:26 <CoolerZ> actually just loading the single .hs file into ghci
10:43:54 <EvanR> have you heard any discussion of graphs today?
10:44:24 <EvanR> you can review the public logs of the channel linked in the topic
10:44:38 * hackage threepenny-editors 0.2.0.4 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.4 (PepeIborra)
10:47:35 <CoolerZ> 10:36:16 <cocreature> index your vertices by ints and keep an adjaceny list/vector/intmap for each of them.
10:48:05 <EvanR> that will allow cycles
10:48:11 <CoolerZ> you mean use Data.Graph in conjunction with Data.Map Int VertexData ?
10:48:30 <Athas> I am quite sure Data.Graph supports cycles.
10:48:35 <EvanR> cocreature's suggestion was for doing it without a library
10:48:39 <cocreature> I was more thinking of rolling your own graph representation instead of using Data.Graph
10:49:38 <CoolerZ> but that would require pikachu and pika pi of pichu
10:49:45 <cocreature> what?
10:49:50 <orion> I've read that Functors compose, but Monads do not. Do Applicatives compose?
10:49:57 <cocreature> orion: yes
10:49:59 <CoolerZ> sorry i need sleep
10:50:20 <CoolerZ> wouldn't that be slow?
10:50:21 <glguy> orion: You can look at the instances for http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Compose.html
10:50:43 <CoolerZ> to make my own adjacency list
10:50:57 <EvanR> you asked how to make a graph
10:51:52 <Philonous> Hrmpf, why can't we have "foo" :: Sing "foo" :( 
10:52:37 <cocreature> it really dependes on the operations you want to perform. if your graph doesn’t change you can just use unboxed vectors for everything and it will be quite fast
10:52:54 <CoolerZ> EvanR, i am looking at that slideshow you posted, something about inductive graphs?
10:53:21 <EvanR> thats a way to construct and deconstruct graphs in a more functional way
10:53:24 <sproingie> Philonous: {- LANGUAGE OverloadedStrings -} perhaps?
10:53:41 <CoolerZ> cocreature, well i will be creating new vertices and checking if they already exist in the graph
10:53:53 <CoolerZ> if they exist just link to that vertex instead of creating a new one
10:54:08 <CoolerZ> and that needs to be done over and over several times
10:54:11 <sproingie> or better yet, {-# LANGUAGE ...
10:54:17 <Philonous> sproingie, I don't think you can write IsString instances for Sing (a :: Symbol)
10:54:55 <kamyar> Hello friends!
10:55:02 <kamyar> please check my code and the error!
10:55:03 <kamyar> http://lpaste.net/355457
10:55:16 <kamyar> I dunno what this error is "can not deduce..."
10:55:18 <tdammers> Philonous: why not?
10:55:28 <Philonous> What would the instance look like?
10:55:47 <Philonous> You need fromString :: String -> Sing a -- for each a
10:55:47 <sproingie> Philonous: hm, not via another IsString i suppose, no
10:56:18 <tdammers> you can have IsString Symbol, and then IsString a => IsString (Sing a)
10:56:54 <tdammers> the latter would also cover Sing String and Sing Text etc.
10:57:16 <kamyar> Hey please help me
10:57:26 <tdammers> in fact, you could use GeneralizedNewtypeDeriving to not have to write that second instance yourself
10:58:19 <Philonous> What do the values of Symbol look like?
10:58:26 <CoolerZ> what is the :& operator
10:58:46 <Philonous> Is Symbol even considered a type? I thought it was only a kind
10:58:50 <CoolerZ> ([4, 5, 6], 1, []) :& graph
10:59:07 <EvanR> its an infix data constructor
10:59:22 <EvanR> > 3 :+ 1
10:59:24 <CoolerZ> you mean like :
10:59:25 <lambdabot>  3 :+ 1
10:59:27 <CoolerZ> cons
10:59:32 <EvanR> pretty much
10:59:38 <CoolerZ> ok
10:59:58 <EvanR> you can pattern match on it
10:59:58 <glguy> Yeah, any value-level operator symbol starting with a : is a constructor
10:59:59 <sproingie> Philonous: Data.Symbol.  in source, they're just another String, they just associate an int with it
10:59:59 <kamyar> Anyone talking to me?
11:00:02 <Philonous> tdammers, Even if you could do that, you'd have fromString "abc" :: Sing "def" and that can't be right
11:01:06 <cocreature> kamyar: have you tried doing what GHC suggests, i.e., adding PersistQueryRead backend to the context of validateUser?
11:01:27 <CoolerZ> thats not saying much, you can pattern match on anything
11:01:36 <EvanR> you can only pattern match on constructors
11:01:46 <kamyar> cocreature: I should not! I just need a pool! Why do I have to?
11:02:01 <Philonous> sproingie, I think that's a different Symbol, I mean the one from GHC,TypeLits 
11:02:19 <cocreature> kamyar: you don’t need to add an argument. you just need to add a typeclass constraint on the pool you can accept
11:02:25 <cocreature> kamyar: because selectFirst requires that
11:02:45 <kamyar> cocreature: I know! But I meant the constraint
11:02:49 <CoolerZ> i guess you can't pattern match into a Data.Map
11:02:59 <cocreature> kamyar: well selectFirst requires the constraint so it needs to come from somewhere
11:03:06 <EvanR> correct because the constructors are hidden
11:03:12 <sproingie> Philonous: ohhh i'm a silly bunt.  only thing i ever used from that is TypeError :)
11:03:34 <EvanR> in cases like that sometimes they provide "view" data types to pattern match on a particular view of the structure
11:03:41 <EvanR> that is whats going on in the graph slideshow
11:04:37 <CoolerZ> data Context =
11:04:37 <CoolerZ>   Context [Node] Node [Node]
11:04:37 <CoolerZ> data View =
11:04:37 <CoolerZ>   Context :& Graph
11:04:40 <CoolerZ> is this right?
11:04:54 <CoolerZ> data View = Context :& View
11:05:01 <CoolerZ> to be recursive
11:05:18 <EvanR> im not sure which one you mean
11:05:32 <CoolerZ> http://jelv.is/talks/inductive-graphs-at-wagon/#/slide-sec-8
11:05:42 <EvanR> you copy pasted then change it
11:05:45 <CoolerZ> Graph isn't even defined
11:06:03 <CoolerZ> it should be   data View = Context :& View
11:06:20 <EvanR> i dont think so
11:06:31 <CoolerZ> what is Graph
11:07:15 <EvanR> a graph is either the empty graph or the combination of a node with a context
11:07:45 <CoolerZ> its not in the slides
11:08:13 <splanch> the slides have links to papers at the end
11:08:19 <splanch> they go into more detail
11:08:22 <CoolerZ> why not   data Graph = Context :& Graph | NilGraph
11:09:26 <CoolerZ> and data Context = Context [Node] Node [Node]
11:10:07 <EvanR> that might work
11:10:23 <EvanR> look at the pictures on this page if you cant read scala http://blog.higher-order.com/blog/2016/04/02/a-comonad-of-graph-decompositions/
11:10:25 <CoolerZ> maybe replace Node with a to be polymorphic
11:10:35 <stphrolland> I try to use MaybeT from the transformers package. https://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Maybe.html#g:3. But I do not see the simple lift function. How can I lift a getLine for example ?
11:10:36 <EvanR> this is for undirected graphs though
11:12:00 <EvanR> Context a { incoming :: [Node a], outgoing :: [Node a], me :: Node a }
11:12:00 <sproingie> stphrolland: for lifting getLine in particular, you want liftIO
11:12:29 <stphrolland> but it is not present in Control.Monad.Trans.MaybeT ? 
11:12:48 <stphrolland> I saw it in MonadIO if I recall correctly
11:13:07 <EvanR> CoolerZ: one idea here is that Graph is not literally that data type, it just looks that way because of your view. the underlying structure would be something more efficient for adding contexts and splitting at nodes
11:13:39 <EvanR> an index of adjacencies
11:14:25 <stphrolland> yep, liftIO works nicely
11:14:48 <CoolerZ> EvanR, whats the point of View if its slow and useless?
11:15:21 <EvanR> sounds like a trick question
11:15:31 <Sheogorath> can someone help me not hate haskell's module hierarchies? What's Control supposed to mean? And isn't everything Data?
11:15:34 <CoolerZ> no....
11:16:08 * hackage hsyslog 5 - FFI interface to syslog(3) from POSIX.1-2001  https://hackage.haskell.org/package/hsyslog-5 (PeterSimons)
11:16:09 <EvanR> you have nice interfaces for things that are complex and efficient, but whose details dont pertain to what youre doing
11:16:12 <sproingie> Sheogorath: it's pretty vague, but more categories would make things even harder to find
11:16:17 <EvanR> so thats the opposite of slow and useless
11:16:20 <Cale> Sheogorath: I hate Control and Data in particular as well
11:16:28 <CoolerZ> whats the point of pattern matching, if doing that would be really slow
11:16:32 <Cale> Sheogorath: It's like two miscellaneous junk drawers
11:16:48 <Philonous> Sheogorath, I try to skip nonsensical prefixes like that in my packages 
11:16:54 <mauke> well, Data is like Misc and Control is like Util
11:16:56 <Sheogorath> sproingie: less is more. MVar is a fine name for a module. Control.Concurrent.MVar is not
11:16:57 <EvanR> CoolerZ: if ?
11:17:06 <Philonous> Sheogorath, Aye
11:17:19 <sproingie> Sheogorath: flat namespaces screw everyone pretty quickly
11:17:25 <Cale> Sheogorath: I started programming in Haskell just before hierarchical modules came into existence, and was pissed off by the arbitrary decisions that were made there almost immediately.
11:17:28 <cocreature> Sheogorath: I don’t think anybody really likes the current status but it’s too late to change it
11:17:34 <Sheogorath> mauke: ah yes. reminds me of the 20k util files i've been getting the pleasure to work with recently
11:17:37 <CoolerZ> EvanR, i mean you just said you would use a different data structure underneath
11:17:39 <sproingie> haskell98 doesn't even have hierarchical modules
11:17:39 <Sheogorath> 20k lines
11:17:47 <sproingie> i think that's one thing that went into haskell2010
11:17:51 <Philonous> sproingie, Package imports 
11:17:55 <c_wraith> Sheogorath, but Concurrent.MVar is better than just MVar
11:18:06 <Cale> sproingie: Literally the only thing that "hierarchical modules" changed about the spec was to say "hey, allow '.' in module identifiers"
11:18:22 <CoolerZ> EvanR, and i guess you would just use some functions that work with that data structure to do inserts and deletes
11:18:30 <sproingie> Cale: yeah i think we can all agree haskell's module system could use some love
11:18:35 <EvanR> CoolerZ: this is haskell, most of your code is written with pattern matching
11:18:36 <Cale> It *really* wasn't a big deal
11:18:38 <mauke> we could've done that with _ instead
11:18:39 <sproingie> isn't backpack supposed to deal with some of that?
11:18:48 <EvanR> if you havent seen how nice that is... try writing more haskell
11:18:48 <CoolerZ> instead of functions that operate by pattern matching on view
11:19:07 <orion> What is a concrete example of Haskell's weakness when it comes to modules, and how would that be solved?
11:19:30 <Sheogorath> guys, you didnt help. at least I feel mroe righteous in my anger tho
11:19:32 <Cale> I mean, there's one common thing which would be solved by a better module system perhaps
11:19:38 <mauke> Sheogorath: sorry :-)
11:20:02 <sproingie> i've never written anything all that big in haskell so i've little experience with getting screwed by the module system
11:20:02 <Cale> There are lots of packages which define separate versions of the same thing for lazy and strict ByteString and for lazy and strict Text
11:20:05 <EvanR> CoolerZ: as an example, the Data.Sequence structure has O(1) access to both ends, but its an abstract data type. so there are views for the left and right to decompose it
11:20:07 <Cale> (and maybe String also)
11:20:12 <CoolerZ> EvanR, it would be like Data.Map where you are provided functions in the library that deal with the implementation
11:20:19 <Cale> backpack might solve some of that
11:20:35 <CoolerZ> instead of pattern matching
11:20:58 <EvanR> you do the equivalent of pattern matching on Map when you use split
11:21:13 <CoolerZ> hmm
11:21:13 <Cale> Otherwise, it's not like we're really having much in the way of trouble with module namespace.
11:21:29 <Cale> Maybe someday we will, I don't know
11:21:42 <EvanR> splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
11:21:52 <sproingie> the odds of needing two modules with the exact same in the same program tends to be pretty low
11:21:58 <EvanR> you get the left tree, the right tree, and maybe whatever was exactly at k
11:22:07 <sproingie> at which point there's package imports anyway
11:22:48 <CoolerZ> what is this?         foo (matchAny -> ctx :& rest) = ...
11:22:53 <mauke> oh hey, the return value is a data structure you have to pattern match on
11:22:55 <CoolerZ> http://jelv.is/talks/inductive-graphs-at-wagon/#/slide-sec-14
11:23:00 <EvanR> a view pattern
11:23:02 <mauke> CoolerZ: that looks like a view pattern
11:23:10 <CoolerZ> is that new?
11:23:14 <mauke> sort of
11:23:15 <EvanR> its an extension
11:23:56 <kamyar> Can I write this better? (IsSqlBackend backend, PersistQueryRead backend) => ...
11:23:59 <sproingie> not terribly new, not often used.  it's syntax sugar for a case statement
11:24:09 <sproingie> CoolerZ: https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
11:24:14 <Cale> View patterns have been around since GHC 6.10
11:24:50 <kamyar> Can I make contraction?
11:25:00 <mauke> kamyar: I don't think so
11:31:45 <lyxia> kamyar: if you use the same constraints a lot you can make a constraint synonym
11:32:06 <kamyar> lyxia: How?
11:32:18 <Philonous> OK, so because I was tired of defining types for my servant interfaces I came up with my own HashMap-based extensible record system. But I'm not sure this is a good idea :/
11:32:49 <EvanR> is it really big enough to bring in hashmaps?
11:33:15 <sproingie> kamyar: use ConstraintKinds, then it's basically a type statement
11:33:24 <sproingie> type Stringy a = (Read a, Show a)
11:33:38 <orion> What is meant by "type alignment" in relation to "sequences"?
11:33:52 <kamyar> Thnx fellows!
11:35:04 <lyxia> kamyar: http://lpaste.net/355458
11:35:33 <kamyar> lyxia: thnx
11:37:02 <EvanR> :k (Read a, Show a)
11:37:04 <lambdabot> error: Not in scope: type variable ‘a’
11:37:04 <lambdabot> error: Not in scope: type variable ‘a’
11:37:19 <kamyar> Actually there is one! And I found it : SqlBackendCanRead
11:37:33 <sproingie> :k Show
11:37:34 <lambdabot> * -> Constraint
11:38:17 <EvanR> lambdabot: a is some type gdmmit
11:39:08 <sproingie> :k Show String
11:39:09 <lambdabot> Constraint
11:39:18 <EvanR> so (Constraint, Constraint) is a Constraint?
11:39:26 <sproingie> it's syntax for multiple constraints
11:40:11 <sproingie> :k (Show String, Read String)
11:40:12 <lambdabot> Constraint
11:40:19 <mauke> :k (Show ?a)
11:40:20 <lambdabot> error: parse error on input ‘?a’
11:40:42 <EvanR> cool
11:40:57 <EvanR> :k (Show String, (Read String, Num String))
11:40:58 <lambdabot> Constraint
11:42:02 <sproingie> can't think of any intereting kinds for constraints themselves
11:42:42 <sproingie> but i'm sure someone's done some wizardry on higher order constraints
11:44:08 * hackage sbp 2.2.1 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-2.2.1 (jgross)
11:44:31 <sproingie> :k (Show _, Read _)
11:44:33 <lambdabot> Constraint
11:44:44 <sproingie> good old underscore
11:46:01 <CoolerZ> i don't understand the example given here https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
11:46:35 <CoolerZ> what are they saying is inconvenient?
11:47:20 <sproingie> having to write all the conversion boilerplate yourself is inconvenient
11:47:35 <CoolerZ> they eliminated the case of line but added parantheses and some extra characters to each pattern
11:47:52 <Philonous> EvanR, It's not about the HashMap per se, but AFAICS, the obvious way to implement extensible records is more akin to a HList than a Map 
11:48:04 <EvanR> right
11:48:26 <CoolerZ> sproingie, what conversion boilerplate? you still need the function view even if you use view patterns
11:48:33 <sproingie> in scala you might use an implicit conversion where you'd use a view pattern in haskell
11:48:48 <Philonous> EvanR, And I wanted Record [ ("foo", Int), ("bar", Bool)] ~ Record [("bar", Bool), ("foo", Int)] or at least as close as I could get 
11:48:49 <sproingie> CoolerZ: it doesn't have to be a function named view, and it doesn't even have to be a separate function
11:49:09 <CoolerZ> no it doesn't have to be named view obviously
11:49:13 <sproingie> it can be any expression.  usually you'll have a specific view in mind though, so you'll probably already have that function anyway
11:49:57 <CoolerZ> well i guess you could define a separate expression for each pattern
11:50:11 <CoolerZ> still seems really niche
11:50:30 <EvanR> i see it used in ffi code
11:50:30 <mckeankylej> Just curious why did everyone decide that <*> = ap? All the rest of the monad and applicative laws make sense to me but I dont get why applicative must be a subclass of monad
11:50:59 <EvanR> monad is a subclass of applicative
11:51:09 <CoolerZ> ffi?
11:51:21 <EvanR> foreign function interface
11:52:27 <sproingie> the "Erlang-style parsing" example in the wiki is probably the most "real-world" application of view patterns on that page
11:52:30 <mckeankylej> EvanR: yea sorry applicative is a super class that was a typo
11:53:13 <EvanR> mckeankylej: monad used to have all the support that applicative was used for, it happens that for any monad you get an applicative for free, and now its known that plenty of things are applicative without being monads, so theres a new class for it
11:53:15 <CoolerZ> that makes this even weirder data View = Context :& Graph
11:53:15 <Philonous> mckeankylej, Every monad is also an applicative functor, that is, you can implement all the functions just using the fact that it is a monad and do so in a way that will necessarily respect the applicative laws 
11:53:26 <CoolerZ> why isn't View a function?
11:53:32 <CoolerZ> http://jelv.is/talks/inductive-graphs-at-wagon/#/slide-sec-8
11:53:56 <EvanR> so you can pattern match on its constructor
11:53:59 <CoolerZ> view :: GraphDataStructure -> Graph
11:54:12 <EvanR> thats not right
11:54:24 <Philonous> mckeankylej, Now some types allow for different ways make them Applicative, but one of them is always compatible with monad (if it can be a monad), so it makes sense to demand that they are compatible, doesn't it?
11:54:27 <EvanR> it needs to review View
11:54:29 <EvanR> return View
11:54:32 <Sheogorath> :k Read _ => Show _
11:54:34 <lambdabot> error:
11:54:34 <lambdabot>     Wildcard ‘_’ not allowed in a constraint
11:54:34 <lambdabot>       except as the last top-level constraint of a type signature
11:54:45 <CoolerZ> sure
11:54:46 <Sheogorath> :k Read a => Show a
11:54:47 <lambdabot> error: Not in scope: type variable ‘a’
11:54:47 <lambdabot> error: Not in scope: type variable ‘a’
11:54:53 <mckeankylej> Philonous: The reason I am curious about it is I can make the Validation applicative an applicative but I cant make it a monad because it would violate the <*> = ap law but the monad instance is nice sometimes
11:54:53 <CoolerZ> view :: DataStructure -> GraphView
11:54:55 <glguy> Sheogorath: You can play with lambdabot in /msg
11:55:18 <mckeankylej> what bad things would happen if I made an instance of monad for validation?
11:55:43 <Philonous> mckeankylej, I don't know that type. Are you sure the Monad instance would be lawful? 
11:55:50 <Cale> mckeankylej: Which instance were you hoping to write?
11:55:52 <Philonous> mckeankylej, Might be an oversight, then
11:56:07 <sproingie> mckeankylej: you'd be duplicating existing work, most likely.  on the other hand, you'd know inside and out how it worked.
11:56:26 <glguy> mckeankylej: Then when you made refactorings that should preserve the meaning of your program according to the laws of Applicative and Monad, the meaning of you rprogram might not be preserved
11:57:04 <mckeankylej> Philonous: data Validation e a = Failure e | Success a seen in this package: https://hackage.haskell.org/package/validation
11:57:09 <CoolerZ> EvanR, isn't the whole point that you have view functions and you pattern match on the result of those?
11:57:30 <mckeankylej> the idea behind it is the applicitive instance mappends errors together instead of short circting
11:59:02 <mckeankylej> sometimes its useful to have a function like bind which short circuits like either
12:00:08 <Philonous> mckeankylej, I don't see the mappend, tbh.
12:00:09 * hackage ersatz 0.4 - A monad for expressing SAT or QSAT problems using observable sharing.  https://hackage.haskell.org/package/ersatz-0.4 (ryanglscott)
12:00:12 <sproingie> it's kind of like WriterT Either
12:00:13 <Philonous> Looks like short-circuiting to me 
12:00:53 <bloogie> In 'Generalising monads to arrows', Hughes says "It is simply impossible to find a definition of >>= which does this", in reference to combining static parts of Swierstra and Duponcheel's LL1 parser, but then points out the solution they used, which looks exactly like an Applicative - and hesitates in departing from the monadic signature. Is this notion ill-conceived, from not having had explored Applicatives then?
12:01:00 <Philonous> mckeankylej, Do you mean AccValidation perchance?
12:01:05 <sproingie> or EitherT Writer ... the short circuiting makes it hard
12:03:50 <Philonous> mckeankylej, Well, you're right, the Monad instance would clash with the Applicative instance. However, the (===) in <*> === app is equivalence, not equality. So you can implement your monad instance as long as you're OK with ending up with equivalent values 
12:03:57 <monochrom> bloogie: Right, Applicative was not thought of back then.
12:04:16 <bloogie> monochrom: does that make Arrows redundant?
12:04:32 <monochrom> The parsing example is better off as Applicative. But later the circuit example is a good Arrow example.
12:04:50 <bloogie> oh cool, thanks
12:05:22 <ph88_> how many papers did swierstra put out ?
12:06:08 <Sheogorath> Does "if it compiles it works" apply to concurrent stuff like TVar implementations? With some unsafePerformIO for flavor.
12:07:02 <Philonous> Sheogorath, Hah, you wish. It doesn't even apply to sequential programs without unsafePerformIO (except maybe in a very narrow but boring sense)
12:08:33 <bloogie> also, can someone explain this https://twitter.com/PieCalculus/status/858634919215599616/photo/1 
12:08:52 <bloogie> does it mean anything more specific than dependent types are awesome?
12:09:05 <RSun> grep >
12:09:24 <RSun> grep -sirl test
12:09:45 <Tuplanolla> [sudo] password for rsun:
12:09:52 <RSun> lmao
12:12:25 <RSun> Tuplanolla you are funny.
12:13:31 <kreetx> hello, channel! I'm looking for a haskell tool which's announcement I remember reading, but can't remember the name of. In a git repo it allowed to leave tags (e.g "[todo]") in comments, and it would produce a summary
12:14:08 <kreetx> anyone remembers the name? it was some weird word, but for the life of me I can't find it on hackage..
12:17:48 <mauke> s/which's/whose/g
12:23:17 <moet> is there any active linear algebra library which supports physical dimension checking? dimensional-homo, dimensional-dk-linalg, DimMat, dimensional-vectors all seem deadish
12:24:05 <moet> i've been trying to use vanila `linear` with `dimensional` and found them to be pretty fundamentally incompatible.. on their own, both are great libraries!
12:27:56 <Tuplanolla> I can't find any of those on Hackage, moet.
12:28:52 <moet> Tuplanolla: yeah, i found them by going to the hackage package `dimensional` and looking at the author's github
12:29:17 <dolio> kreetx: lentil?
12:30:06 <Tuplanolla> The problem with linear algebra is that dimensions may vary within a matrix, so you can't just combine two libraries, moet.
12:31:12 <moet> Tuplanolla: yes, insofar as my project is concerned i've just said i'll keep all dimensions the same in a given vector
12:31:32 <moet> dimensional-homo also makes this assumption, but it looks reeeeal rough around the edges
12:31:59 <moet> but heterogeneous tensors seems to be the root problem.
12:32:28 <Sheogorath> EvanR: Here's STM, maybe. http://lpaste.net/101465647430500352
12:33:07 <Sheogorath> IO Bool for reads lead to an elegant retry implementation
12:33:26 <kreetx> dolio: yes!!
12:33:32 <kreetx> thanks!
12:37:16 <Sheogorath> Philonous: "if it compiles it works" was true for this large file and rigorous testing
12:39:35 <davean> Sheogorath: when I think it won't, I just get more precise with the types
12:40:22 <Sheogorath> well it was concurrency and unsafePerformIO that was most fishy, not sure how to type that.
12:40:47 <davean> well, you *don't* type unsafePerformIO, it can break anything, thats why its unsafe
12:41:12 <davean> Concurrency rarely requires extra typing
12:41:22 <davean> the type system generally protects everything relivent
12:41:36 <greymalkin> Is there a way to make a typeclass cause derivation of other typeclasses?
12:41:44 <davean> unsafePerformIO is specificly bipassing it tohugh
12:42:00 <davean> greymalkin: default implimentations?
12:42:11 <davean> greymalkin: or do you mean actually create the instances?
12:42:16 <greymalkin> Specifically, I'd like a typeclass that implements both ToJSON and FromJSON .
12:42:46 <davean> greymalkin: you can create an instance "instance AllJSON a => ToJSON a", etc
12:42:55 <davean> greymalkin: you'll run into overlapping instance issues of course
12:43:04 <greymalkin> Yes. Too many of them.
12:43:16 <davean> no, not really?
12:43:26 <davean> just don't create AllJSON for anything that already has instances
12:44:42 <cocreature> gnah, I just spend 10 minutes staring at my code trying to figure out why GHC couldn’t find a symbol only to figure out that I was using it at the typelevel and it was a value
12:45:09 <davean> cocreature: lol, welcome to our new era
12:45:49 <cocreature> davean: we need an error message that says “did you mean to use this as a value instead?” :)
12:46:00 <davean> cocreature: I've thought that before too
12:46:21 <greymalkin> davean: It prompts me about "UndecidableInstances"
12:46:40 <greymalkin> And then everything becomes an overlapping instance.
12:46:51 <davean> greymalkin: you've added something you shouldn't then
12:47:10 <davean> The rule I provided was decidable
12:47:21 <greymalkin> Ah.. No, I've chosen a name that already exists.
12:47:29 <greymalkin> And done that repeatedly.
12:47:36 <hololeap> i'm trying to solve this challenge but i can't come up with an algorithm that is efficient enough. my original idea was to use a HashSet to store the "safe" positions and then add queens, deleting any now-unsafe positions, using a recursive bind within the List monad: https://www.hackerrank.com/challenges/super-queens-on-a-chessboard
12:48:19 <greymalkin> Or not.
12:49:02 <hololeap> i have heard that you can simplify the original n queens problem by simply keeping track of the rows/columns, but the ability for the "super queen" to move like a knight complicates that.
12:50:46 <EvanR> wait, super queen
12:50:51 <EvanR> what socery is this
12:52:28 <greymalkin> davean: The constraint 'JSONString a' is no smaller than the instance head (Use UndecidableInstances to permit this)
12:52:53 <greymalkin> Based on: 
12:52:55 <greymalkin> https://pastebin.com/cE5pKmmu
12:54:41 <hololeap> i was thinking that i could have a more efficient way to delete entire rows or columns at a time, but then i realized that i was thinking in terms of mutable state
12:55:52 <hololeap> since there aren't individual delete actions, but rather it creates a new, modified set and then passes it on, i don't really know how to model the efficiency of this new method in my mind
12:56:49 <hololeap> any ideas?
12:57:08 * hackage forest 0.1.1.1 - Tree and Forest types  https://hackage.haskell.org/package/forest-0.1.1.1 (ShaneOBrien)
12:57:21 <hololeap> here is my current code, if it helps anyone understand my question: https://gist.github.com/hololeap/0e0e72d3c4b5010c5f62938090c8ed51
12:57:53 <davean> greymalkin: you're not removing a layer of wrapping, which is how the compiler proves its converging. You want a wrapper to witness you're doing the right thing.
12:59:31 <greymalkin> davean: I don't understand, is this something I can only do with specifically `newtype`ed types?
13:07:58 <greymalkin> Is it because of the Proxy?
13:08:50 <greymalkin> (which, I've just realized, isn't necessary)
13:12:24 <orion> How come hardly anyone uses extensible-effects?
13:25:23 <moet> is there any relationship between Data.Function.on and the applicative world
13:29:31 <kamyar> Hello again
13:29:40 <kamyar> please help me with this code and the error: http://lpaste.net/355460
13:31:13 <lyxia> kamyar: please paste a complete file reproducing the error
13:31:33 <glguy> kamyar: Perhaps you have a restrictive import list that doesn't include the methods of the FromJSON class
13:32:31 <kamyar> glguy: U r right! Sorry! Fixed! thnx
13:34:09 * hackage concurrent-output 1.8.0 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.8.0 (JoeyHess)
13:44:56 <Sheogorath> How does one do monad transformery things on IO and Maybe. what's the recommended techniques?
13:45:22 <tommd> `MaybeT IO`
13:46:06 <fresheyeball> :q
13:46:08 <fresheyeball> exit
13:46:10 <fresheyeball> \q
13:46:46 <Cale> Sheogorath: That's kind of vague -- what problem are you trying to solve?
13:46:50 <Sheogorath> thanks, on second thought i probably just need >>
13:47:03 <Sheogorath> so, ill just write that
13:56:28 <dgpratt> so spacemacs (and I assume emacs) has decent support for Haskell, including type "tooltips" and autocomplete; can one get similar functionality in vim?
13:57:32 <dgpratt> I was hoping to use the console version of emacs/spacemacs in WSL, but it's too wonky to be usable
13:59:54 <kamyar> Hello fellows
14:00:40 <shiona> hello
14:01:27 <kamyar> I just need to json UUID
14:01:49 <kamyar> tojson works well
14:02:06 <kamyar> but I have no clue how to implement parsejson
14:02:17 <davean> kamyar: Those are already implimented for UUID
14:02:38 <kamyar> davean:  knwo but they do not implement json nor generic
14:02:45 <davean> yes they do
14:02:57 <kamyar> davean: Which?
14:03:05 <davean> ToJSON and FromJSON
14:03:13 <kamyar> https://hackage.haskell.org/package/uuid-1.3.13/docs/Data-UUID.html
14:03:14 <davean> they've been in aeson since 1.1
14:03:18 <davean> yes
14:03:24 <davean> aeson already has instances
14:03:35 <kamyar> davean: Aeson does not support UUID
14:04:03 <kamyar> davean: wait! I am wrong
14:05:10 <kamyar> davean: I have to use uuid-types instead of uuid package
14:07:04 <kamyar> davean: But I cant! Since persistent-uuid does not use it!
14:07:09 <hexagoxel> kamyar: if you use uuid you already use the types from uuid-types. former depends on latter.
14:12:41 <jarno_> >
14:12:44 <jarno_> Hi
14:13:07 <kamyar> davean: Does not work!
14:14:03 <kamyar> davean: http://lpaste.net/355460
14:15:25 <jarno_> @help
14:15:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:15:31 <jarno_> @list
14:15:31 <lambdabot> What module?  Try @listmodules for some ideas.
14:15:34 <jarno_> @listmodules
14:15:34 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
14:15:34 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
14:18:19 <kamyar> http://lpaste.net/355460
14:18:23 <kamyar> please help
14:19:08 * hackage concurrent-output 1.9.0 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.9.0 (JoeyHess)
14:21:29 <sproingie> kamyar: you'll need to provide a ToJSON instance for UUID, like the message says
14:21:47 <kamyar> sproingie: It is provided in Aeson
14:21:47 <glguy> instance ToJSON UUID;  -- Defined in ‘aeson-1.2.0.0:Data.Aeson.Types.ToJSON’
14:22:08 <glguy> which version of aeson are you using?
14:23:04 <kamyar> glguy: 1.0.2.1
14:23:24 <glguy> OK, that one doesn't have an instance
14:23:45 <kamyar> glguy: How can I upgrade using Stack install?
14:25:06 <sproingie> put the dependency explicitly in your cabal file and run stack solver?
14:26:13 <sproingie> could maybe copy-paste the instance from the newer version, but that'll screw you when you do upgrade
14:27:05 <mojjo> hi.. hi! I'm writing a function that picks a random element from a list, since this only makes sense for non-empty lists, I'm using the Non-Empty-List pkg. My type is `randEl :: NE.NonEmpty a -> IO a` and the implementation is here http://lpaste.net/355463 
14:27:37 <mojjo> anybody knows why I'm getting this error: `randEl $ NE.fromList [1,2]` ---> *** Exception: NonEmpty.fromList: empty list
14:28:40 <glguy> mojjo: Make a file that reproduces that error
14:28:52 <glguy> and add it to your paste
14:29:18 <mojjo> alright.. wait..
14:29:29 <kamyar> PLeas ehelp me implement it! 
14:29:47 <kamyar> apparently Aeson 1.2.*.* is not Stackage compatible
14:32:51 <mojjo> glguy: dont't know what it was... restarting the repl did the job... 
14:33:06 <mojjo> glguy: so it works actually
14:33:11 <drostie> i mean, it *is* stackage-compatible, but it's not in the LTS Haskell 8.13 stackage snapshot...
14:35:10 <drostie> kamyar: this code is low-level enough that you can probably switch to a nightly if you wanted to?
14:36:50 <drostie> kamyar: see https://www.stackage.org/nightly-2017-05-12 and whether the aeson-1.1.2.0 that's there meets your needs.
14:37:23 <drostie> the FromJSON instances are in the Data.Aeson.Types class IIRC.
14:39:30 <Tuplanolla> They left, drostie.
14:40:03 <drostie> ::slowpoke_image::
15:25:58 <mojjo> it might be a too general question, anyways.. when dealing with IO, is it advisable to keep the IO wrapper to be the outermose, e.g. `IO (Maybe x)` instead of `Maybe (IO a)`?
15:27:12 <Rembane> mojjo: It depends on what you want to do.
15:27:54 <Rembane> mojjo: ...is the general and maybe useless answer.
15:28:08 <Rembane> mojjo: In any case, your types need to line up and it will usually sort itself out.
15:28:20 <Rembane> mojjo: And sequence is your friend.
15:28:22 <Rembane> :t sequence
15:28:23 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:28:33 <Rembane> :t sequenceA
15:28:34 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
15:28:55 <Rembane> mojjo: Or maybe even sequenceA depending on what things you want to inverse
15:29:57 <mojjo> alright...
15:30:08 <monochrom> IO (Maybe x) and Maybe (IO x) are so different that "it depends" is the only correct answer.
15:30:29 <EvanR> its two totally different things!
15:30:35 <EvanR> not just a choice of style
15:31:18 <monochrom> It's on the order of "which one should I use, Emacs or Minecraft?"
15:31:54 <exarkun> I'm having trouble parsing some json with an object with a list of objects using Data.Aeson
15:32:09 <hpc> specifically, IO (Maybe x) is the type of IO actions that might produce a result
15:32:23 <hpc> Maybe (IO x) is the type of "maybe you have an IO action"
15:32:44 <exarkun> https://github.com/LeastAuthority/s4-wormhole-convergence-agent/blob/haskell/MagicWormholeModel.hs#L52 is what I have now.  I mistakenly though `nameplates` would be like `["x", ...]` but it's actually `[{"id": "x"}, ...]`.
15:32:54 <exarkun> I don't see how to deal with this, though.
15:32:58 <Rembane> monochrom: Definitely emacs. Meta-x Minecraft
15:34:55 <mojjo> well, I'm writing a function that takes a value from a map (this returns a maybe) and then does some IO with this.. I figured out that it can be modeled both ways, this would be my `IO Maybe ..` version: http://lpaste.net/355464
15:35:44 <bennofs> mojjo: there is a function to go from Maybe (IO a) to IO (Maybe a) but not the other way around
15:37:20 <mojjo> that makes sense..
15:37:45 <mojjo> so actually I think now, that the other way would be more appropriate in my example..
15:38:15 <monochrom> Initially yes.
15:38:18 <lyxia> exarkun: (x .: "nameplates" >>= mapM (\np -> np .: "id"))   -- get the list, and map over it
15:38:52 <monochrom> Until you realize that somewhere in your program you will turn Nothing into a dummy IO action anyway.
15:39:35 <mojjo> ahaa. true, it must at one point...
15:40:27 <exarkun> `v .: "nameplates"` /me stares at mapM's type
15:46:08 * hackage moving-averages 0.2.0.0 - This is a library for calculating moving averages on lists of numbers.  https://hackage.haskell.org/package/moving-averages-0.2.0.0 (joshuaclayton)
16:06:48 <Profpatsch> mkMap :: forall k ik v. (Ord k, Ord ik, Enum ik, Bounded ik)
16:06:51 <Profpatsch>       => (Proxy ik) -> MKMap k v
16:06:53 <Profpatsch> mkMap _ = MKMap mempty (minBound :: ik) mempty
16:07:18 <Profpatsch> I suspect it’s not really possible to build a Monoid instance for MKMap here?
16:07:46 <Profpatsch> Unless I pin it down to a specific Bounded type that is.
16:15:52 <Sheogorath> STM is freaking cool.
16:16:14 <Rembane> Indeed! :D
16:22:02 <mojjo> I'm wondering why there's no (++) function defined in the Data.List.NonEmpty module... does anyone have an answer to this?
16:22:32 <glguy> You can use <> from Data.Semigroups
16:23:00 <glguy> so no new operator was needed
16:24:39 <hotsauce> :t <>
16:24:41 <lambdabot> error: parse error on input ‘<>’
16:24:46 <hotsauce> :t (<>)
16:24:47 <lambdabot> Monoid m => m -> m -> m
16:25:18 <mojjo> nice.. yes.. now it makes kind of sense. semigroups are monoids without an empty element, no? which are.. well non-empty-lists..
16:30:18 <mojjo> my ghci says `(<>) :: Semigroup a => a -> a -> a`
16:31:44 <kelzaa> i heard this is the best channel on freenode
16:34:09 <ReinH> mojjo: yeah, the free semigroup is (almost) the non-empty list.
16:35:38 <ReinH> it's actually the list (again, almost), you just don't know that [] is neutral
16:36:02 <ReinH> (it's actually finite lists)
16:38:23 <ReinH> formally, the free semigroup over a set A is the set of all finite sequences (often called words) of the elements of A (often called letters) with concatenation as the product. The free monoid is the free semigroup with the empty sequence as identity.
16:38:53 <ReinH> hmm, actually I think the free semigroup is non-empty finite sequences.
16:39:04 <ReinH> it's A+, while the free monoid is A*
16:39:21 <nshepperd> i don't see why the free semigroup would include []
16:39:31 <ReinH> (that's where + and * in regexp come from)
16:39:38 <ReinH> nshepperd: yeah, I corrected myself
16:39:45 <ReinH> I corrected my correction
16:40:03 <ReinH> and the free monoid adjoins the empty sequence as identity
16:40:05 <nshepperd> heh
16:41:53 <ReinH> the * is called the Kleene star, after Stephen Kleene (not to be confused with the weird bottle guy, Felix Klein)
16:42:02 <nshepperd> i still haven't quite succeeded in understanding the general definition of "the free X on the set A"
16:42:23 <nshepperd> something something adjunctions
16:42:40 <ReinH> Yeah, that's how it's presented in category theory
16:43:12 <ReinH> The free functor from A to X is left-adjoint to a forgetful functor from X -> A
16:44:21 <ReinH> There are also cofree functors, which are right-adjoint to forgetful functors
16:44:42 <ReinH> They are sometimes called fascist functors (yes, really) because mathematicians are hilarious
16:45:49 <ReinH> sorry, that's not right
16:46:22 <ReinH> the free functor from sets to the category C is from Set -> C and the forgetful functor is from C -> Set
16:47:41 <nshepperd> in this case the category C is the category of monoids? with monoid homomorphisms as the arrows?
16:47:44 <ReinH> the forgetful functor selects the carrier set
16:48:09 <nshepperd> or semigroups
16:49:09 <ReinH> The free functor that takes A to A* is from Sets to Mon, the category of monoids, yeah
16:49:21 <ReinH> nshepperd: the key thing that makes it 'free' is a universal property
16:51:42 <ReinH> which I am going to have to look up since clearly my category theory is rusty
16:58:22 <ReinH> nshepperd: oh this is good https://math.stackexchange.com/questions/58553/why-is-the-free-monoid-free
16:59:32 <EvanR> heh
16:59:41 <EvanR> i tried this
16:59:47 <EvanR> pureSleep i x = unsafePerformIO (threadDelay i) `seq` x
16:59:54 <EvanR> to try and simulate slowness of a computation
17:00:15 <EvanR> ghci is not amused
17:00:35 <pikajude> lol
17:00:39 <pikajude> good old purity
17:03:17 <EvanR> let x = pureSleep 1000000 'c' will do nothing. if you look at x but cancel the computation, now x is permanently "Interrupted"
17:03:20 <EvanR> ok
17:03:33 <ReinH> good times
17:03:42 <EvanR> but if the pure sleep is deep inside another computation, its like some internal variables become permanently interrupted
17:03:52 <EvanR> i have to exit ghci completely
17:06:58 <EvanR> ah
17:07:09 <EvanR> because it was part of a CAF
17:07:52 <EvanR> i turned the top level CAF from foo :: X to foo :: () -> X and it fixed
17:08:09 <EvanR> maybe i should move to ML
17:09:32 <Sheogorath> blasphemer
17:10:04 <nshepperd> I guess when you interrupt it, it becomes InterruptedError `seq` x, basically
17:10:10 <nshepperd> or whatever the actual exception is
17:10:15 <EvanR> right
17:10:28 <nshepperd> and that will be ⊥ no matter how many times you try to evaluate it
17:10:43 <nshepperd> good fun
17:11:07 <EvanR> since the top level thing is infinite and growing, probably better to () -> it anyway, assuming that even works in general
17:11:34 <EvanR> to make it recompute each place its used
17:12:35 <EvanR> the value is valueAtEndOfTime = NotBefore 1 (NotBefore 2 (NotBefore 4 (NotBefore 8 ( ...
17:13:22 <EvanR> with increasing pure sleeps thrown in to make it not 100% cpu if its forced inside another computation
17:15:38 <Sheogorath> EvanR: here's the STM code I was bugging you about earlier. orElse and exceptions are tricky tho. http://lpaste.net/101465647430500352
17:18:23 <EvanR> heh, Time = Int
17:18:27 <EvanR> what could go wrong
17:19:02 <Sheogorath> global variables and unsafePerformIO. isn't it wonderful?
17:19:10 <EvanR> right...
17:19:44 <EvanR> btw if youre serious, you want to do something like in the globals package to create that global
17:20:03 <EvanR> probably
17:21:08 <Sheogorath> not serious
17:25:18 <rightfold> @pl \f -> either ((stateErrors %=) . (:)) f <=< lift . unwrap
17:25:18 <lambdabot> (line 1, column 52):
17:25:18 <lambdabot> unexpected "u"
17:25:18 <lambdabot> expecting space
17:25:18 <lambdabot> ambiguous use of a right associative operator
17:25:31 <rightfold> ah, so that's why pointfree.io crashes
17:27:03 <pikajude> maybe it shouldn't crash
17:27:13 <orion> A 500 error seems like a bad plan.
17:27:55 <rightfold> maybe it's better to keep this function pointful anyway
17:53:16 <Profpatsch> I need a function Map k v -> Map v [k]
17:53:53 <Profpatsch> So it should give me back for each value a list of keys that have this value.
17:54:47 <Profpatsch> Is there something like that?
17:54:49 <EvanR> youll have to sort by and group the key value list
17:54:59 <EvanR> then build a new map from that
18:15:57 <Younder> consolidation
18:16:18 <Younder>  The internet, a common language, it is about consolidation
18:16:42 <Younder> We need to find a new place to live. That is our purpose. We are at our most fragile and altso our most powerful
18:16:43 <ChaiTRex> Profpatsch: http://lpaste.net/355466
18:17:16 <Younder> n Norway it is in the dead of night. I am just reflecting on my life and what has happened during my 50 years.
18:17:35 <Younder>  far as I can see. (admitting not that far). The only reason mankind is allowed to exist is because we have something the other animals don't. We can populate other stars.
18:17:53 <Younder> Something so valuable it is worth almost any cost.
18:18:13 <Younder> Even a 50% extinction of other animals. (For a while)
18:18:27 <Younder> For a while it was about creativity. Now it is about consolidation. Putting 'the lot' into play
18:18:41 <dmj`> Profpatsch: could probably do it with foldrWithKey
18:22:24 <dmj`> @type M.foldrWithKey
18:22:26 <lambdabot> (k -> a -> b -> b) -> b -> M.Map k a -> b
18:22:40 <dmj`> @type M.foldrWithKey (\k v m -> M.insertWith (++) v [k] m) mempty 
18:22:42 <lambdabot> Ord k => M.Map a k -> M.Map k [a]
18:24:53 <dmj`> > (M.foldrWithKey (\k v m -> M.insertWith (++) v [k] m) mempty)  (M.fromList [(1,'a'), (2,'a')] )
18:24:57 <lambdabot>  fromList [('a',[1,2])]
18:26:04 <Profpatsch> dmj`: Yes, that’s my solutino M.foldlWithKey (\m k v -> insertWith (++) v [k] m) mempty  $  M.fromList [(1::Int,2::Integer),(2,2),(3,2),(6,1)]
18:27:18 <dmj`> Profpatsch: legit
18:33:20 <Profpatsch> foldWithKey' of course
18:33:55 <Profpatsch> ChaiTRex: Thanks! I think with Map operations it’s a bit faster.
18:34:13 <dmj`> :t M.foldlWithKey'
18:34:15 <lambdabot> (a -> k -> b -> a) -> a -> M.Map k b -> a
18:34:32 <Profpatsch> It’s the strict version.
18:34:51 <Profpatsch> Is there any reason to use foldl anytimes
18:34:57 <Profpatsch> s/s/?$/?
18:35:20 <Profpatsch> It will always build up chunks, right?
18:37:20 <dmj`> yea, very chunky
18:37:28 <Profpatsch> Hm, to generalize this.
18:37:40 <lyxia> the laziness can be useful, but I don't have an example in mind
18:38:01 <Profpatsch> Now it’s List, is there a datatype that can do something like <> but also singleton?
18:38:17 <Profpatsch> like right now it’s (++) and [k]
18:38:42 <lyxia> pure + Alternative
18:38:51 <Profpatsch> Oh, right.
18:38:57 <Profpatsch> I thought (:[]) is pure
18:39:07 <Profpatsch> (<|>) and pure
18:40:19 <Profpatsch> Hm, the instances I can think about are  [] and Set
18:40:33 <Profpatsch> Foldable can’t do singleton.
18:40:41 <Profpatsch> So maybe there’s no nice abstraction.
18:43:52 <Profpatsch> Ah, but for the map implementation I need (Ord k, Ord v)
18:44:22 <Profpatsch> Ah well.
18:44:26 <Profpatsch> Not easy
18:47:38 * hackage servant-py 0.1.0.4 - Automatically derive python functions to query servant webservices.  https://hackage.haskell.org/package/servant-py-0.1.0.4 (erewok)
18:55:56 <Sgeo> https://gist.github.com/nkpart/8922083d3c18a8f777b8
18:56:04 <Sgeo> I get the joke for the most part, but what's ReadMe?
18:56:15 <Sgeo> Googling wasn't very helpful
18:56:21 <Sgeo> Oh derp
18:56:31 <Sgeo> I missed the part where it's defined right there
19:17:10 <nkpart> :)
20:19:38 * hackage haven 0.1.0.0 - Recursively retrieve maven dependencies  https://hackage.haskell.org/package/haven-0.1.0.0 (abrar)
20:25:08 * hackage Villefort 0.1.0.0 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.0 (ChrisReuter)
20:32:46 <iqubic> Hello
20:35:08 * hackage Villefort 0.1.0.2 - Villefort is a task manager and time tracker written in haskell.  https://hackage.haskell.org/package/Villefort-0.1.0.2 (ChrisReuter)
20:57:23 <iqubic> Is Hackage bot back up and running?
20:58:12 <SrPx> why the parigot encoding is typeable with positive recursion and the scott isn't? the types are almost identical... is there any obvious intuition to determine when something is and isn't positive recursion
21:00:54 <EvanR> iqubic: theres a new hackage bot
21:29:05 <iqubic> Oh. Is it better than the old one?
21:30:49 <EvanR> > compare "hackage" "hackagebot"
21:30:50 <lambdabot>  LT
21:32:43 <jle`> > sort ["hackage","hackagebot"]
21:32:45 <lambdabot>  ["hackage","hackagebot"]
21:35:57 <nshepperd> any ghc rts experts here? it looks like I've got some virtual address space issues with the RTS vs nvidia opencl drivers
21:36:33 <nshepperd> where they're both competing for the bottom of the address with the result that the driver won't load
21:37:17 <nshepperd> are there any secret flags i can tweak to change this behavior
21:38:00 <geekosaur> +RTS -xb and it's not secret
21:38:09 <geekosaur> it *does* require building with -rtsopts
21:39:11 <geekosaur> (try "ghc +RTS --help" to see the rts flags available to non-debug/profiling builds, or https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#miscellaneous-rts-options ff. for all rts options
21:40:16 <nshepperd> hm, -xb isn't listed anywhere
21:41:49 <geekosaur> hm, I see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--xm in the manual but am not seeing -xb
21:42:42 <geekosaur> but ghc (8.0.2) +RTS --help says: "ghc:   -xb<addr> Sets the address from which a suitable start for the heap memory will be searched from. This is useful if the default address clashes with some third-party library."
21:42:57 <geekosaur> either -xm or -xb might be relevant for your situation
21:43:09 <geekosaur> this does seem to be a doc bug though
21:46:19 <Sh4rPEYE> Hello. I'm trying to write a Functor (and other) instances of Constant. In the docs the type signature of fmap look like this: fmap :: (a -> b) -> Constant * a a -> Constant * a b
21:47:13 <geekosaur> uh. there's a haddock gotcha there; lclick through to the source to see a sane type signature
21:47:23 <glguy> The surprising * is due to an extension called PolyKinds.
21:47:25 <Sh4rPEYE> What does the asterisk mean there? 
21:47:31 <geekosaur> (the * tells me it expanded a kind annotation)
21:47:51 <geekosaur> haddock formats kind signatures ... oddly
21:47:51 <glguy> For the purposes of your exercise you should completely ignore it
21:48:11 <nshepperd> geekosaur: thanks
21:48:37 <nshepperd> it doesn't seem to be helping though :(
21:49:05 <iqubic> :t sort
21:49:06 <lambdabot> Ord a => [a] -> [a]
21:49:34 <iqubic> is there a way to do sorting by providing your own comparison function
21:49:41 <geekosaur> nshepperd, you might need to ask in #ghc, and provide more information about the conflict. or ask on the glasgow-haskell-users list
21:49:47 <geekosaur> :t sortBy
21:49:49 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
21:49:53 <geekosaur> :t sortOn
21:49:55 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
21:50:02 <iqubic> Cool.
21:50:10 <geekosaur> @hoogle sort
21:50:10 <lambdabot> Data.List sort :: (Ord a) => [a] -> [a]
21:50:10 <lambdabot> Data.List.NonEmpty sort :: Ord a => NonEmpty a -> NonEmpty a
21:50:10 <lambdabot> GHC.OldList sort :: (Ord a) => [a] -> [a]
21:50:21 <iqubic> Those are the methods I was looking for
21:50:22 <geekosaur> feh, of course it wastes the slots on dupes :/
21:50:27 <iqubic> LOL
21:50:43 <iqubic> Actually the NonEmpty on is not a dupe.
21:51:03 <nshepperd> unfortunately these drivers are all closed source so it's hard to get a handle on what exactly is going wrong
21:51:06 <iqubic> Is there actually a NonEmpty class in Haskell
21:51:06 <Sh4rPEYE> Ok, thanks. Well, I have some more question. If constant is data Constant a b = Constant {getConst :: a}, can I patter-match against it in functions?
21:51:25 <Sh4rPEYE> E.g. fmap f (Constant a) = f a or somethingalong those lines
21:51:26 <geekosaur> type, not class. if you;re still thinking OOP style then you will be confused
21:51:53 <geekosaur> and it's in more recent versions of base (4.9.x for ghc 8.0.x)
21:52:49 <iqubic> How can you tell if something refers to a type or a class.
21:53:03 <EvanR> read :info on it in ghci
21:53:04 <iqubic> Like with Maybe a, I know that maybe is a type.
21:53:10 <EvanR> :info Maybe
21:53:39 <iqubic> But something like NonEmpty is less readily apparent to me
21:53:53 <geekosaur> it says NonEmpty *after* a =>
21:54:01 <geekosaur> classes only appear *before* a =>
21:54:20 <iqubic> Ah, right.
21:54:26 <geekosaur> (the exception is class and instance declarations, because they are class and instance declarations)
21:54:47 <iqubic> You only have type constraints in a fucnction, not data constraints.
21:55:13 <iqubic> If you want a parameter to be of type Maybe a, instead of a, then you write Maybe a
21:55:23 <iqubic> Data constraints are pointless.
21:56:03 <iqubic> What's the point of using Newtype instead of Data?
21:56:13 <jle`> mostly performance
21:56:20 <jle`> and sometimes semantics
21:56:30 <EvanR> if you can use newtype you probably should
21:56:37 <iqubic> I get that NewType forces you to have a single constructor only. Are there any other benefits?
21:56:49 <iqubic> s/NewType/newtype
21:56:50 <jle`> i...wouldn't call that a benefit
21:56:50 <EvanR> newtypes only exist at compile time
21:57:00 <EvanR> theres no runtime overhead
21:57:05 <iqubic> Oh.
21:57:20 <jle`> so at runtime, a 'Sum Int' is just an Int
21:57:26 <jle`> an 'Any' is just a Bool
21:57:31 <iqubic> What's the difference between newtype and a type synonym?
21:57:46 <EvanR> new type makes a new type
21:57:52 <EvanR> thats not the same as the original
21:57:58 <jle`> 'Sum Int' doesn't typechekc as an Int
21:58:19 <iqubic> And type gives you another name for the same thing.
21:58:19 <jle`> newtype Foo = Foo Bool
21:58:30 <jle`> you can't use `Foo` where you would expect a `Bool`
21:58:35 <jle`> the type system will yell at you
21:58:50 <jle`> but for type Foo = Bool, you can use Bool where you expect Foo and vice versa
21:58:54 <jle`> it's basically just a lexical alias
21:58:54 <EvanR> so you can get more type safety this way
21:58:57 <iqubic> if I write type elephant = (int, int) then elephant type checks as (int, int)
21:59:00 <iqubic> Is that right?
21:59:19 <jle`> yes you can give an Elephant wherever an (Int, Int) is expected
21:59:46 <iqubic> This is the thing I was referencing.
21:59:51 <iqubic> http://stackoverflow.com/questions/43525193/how-can-i-re-assign-a-variable-in-a-function-in-haskell
22:00:22 <iqubic> He uses an elephant there. But I was refering to the accepted answer.
22:00:32 <iqubic> I love that post on SO.
22:00:37 <iqubic> It's the best
22:02:30 <iqubic> Why don't more people use Haskell, if Haskell is so great?
22:02:58 <EvanR> fear uncertainty and doubt
22:03:14 <wwizwiwiz> what is the difference between haskell and a typed lisp/clojure
22:04:04 <xormor> some guy called me a nerd for trying to learn Haskell. Haskell is difficult to learn to me.
22:04:07 <iqubic> You can write simple programs in haskell with out using lists.
22:04:25 <iqubic> Lisp requires lists for every thing.
22:04:37 <iqubic> LISP = LISt Processing
22:04:42 <wwizwiwiz> so... better memory layout?
22:05:05 <nshepperd> that seems like a pretty big question
22:05:19 <nshepperd> there are so many differences. all the differences, in fact
22:05:27 <wwizwiwiz> yeah, it's a conversation starter,... and i'm not finding a great article on the topic
22:05:43 <EvanR> and im not sure what typed lisp slash clojure is
22:05:51 <jle`> wwizwiwiz: it might be good to ask what you think the *similiarities* are
22:05:54 <EvanR> so its not that specific
22:06:07 <jle`> i can probably only name a couple of things that are similar
22:06:19 <jle`> and literally every other aspect is a difference
22:06:50 <wwizwiwiz> there are typed lisps
22:07:05 <jle`> i am sure that typed lisps exist
22:07:09 <iqubic> What are the similarities jle`? I can't thing of any.
22:07:20 <jle`> (1) they are both (presumably) programming languages
22:07:49 <iqubic> LOL
22:08:13 <wwizwiwiz> (2) they are both functional programming languages,...
22:08:39 <jle`> that also only tells you slightly little more than (1) tells you
22:08:43 <iqubic> I didn't think that Lisp was a functional language.
22:08:57 <jle`> saying that something is a functional programming language doesn't tell you too much about a language
22:09:14 <wwizwiwiz> they are both garbage collected
22:09:16 <peddie> 3) has lambdas 4) special syntactic form for linked lists 5) garbage-collected
22:09:16 <jle`> there is so much variation among functional languages and approaches to functional programming
22:09:37 <jle`> just like how there is a lot of variation among programming languages in general and approaches to programming
22:09:55 <wwizwiwiz> ok, but i don't really know enough to identify major discriminating factors
22:10:22 <jle`> do you know what functional programming is?
22:10:28 <wwizwiwiz> maybe not
22:10:34 <jle`> think of everything else, and that's what is a discriminating factor
22:10:40 <iqubic> I mean Prolog is a complete paradim shift from imperative and and functiol programming altogether.
22:11:04 <jle`> it's easier to talk about what is similar about functional programming languages...and literally everything else about them is different, heh
22:11:16 <wwizwiwiz> functional programming seeks to try to avoid mutable state and define programs in terms of pure functions which have specific inputs and outputs
22:11:22 <jle`> it's like talking about disriminating factors between animals
22:11:30 <jle`> some have, like, lets
22:11:32 <jle`> *legs
22:12:11 <jle`> wwizwiwiz: not a bad start :)
22:12:36 <iqubic> Others have fins. Some have wings. Others slither about.
22:12:40 <iqubic> Animals are weird
22:12:47 <wwizwiwiz> which is a good practice with imperative programming anyway
22:13:04 <nshepperd> 'Others have fins. Some have wings. Others slither about.' <- programming languages :)
22:14:26 <jle`> wwizwiwiz: note that i'm not really even talking about variations between different types of functional programming (of which there are many)
22:14:28 <wwizwiwiz> so then ... differences begin with "handling mutable state, io etc"?
22:14:31 <jle`> i'm just talking about variations between languages
22:14:37 <jle`> in general
22:14:41 <jle`> like, 99% of language design choices
22:15:05 <jle`> module system, syntax
22:15:13 <wwizwiwiz> syntax is superficial
22:15:17 <EvanR> syntax of comments
22:15:19 <wwizwiwiz> module system also is superficial, like build system, etc
22:15:27 <wwizwiwiz> i wouldn't really call those things properties of the language
22:15:33 <orzo> Prefered module for 'fix'?  Is it Data.Function or Control.Monad.Fix ?
22:15:40 <jle`> Data.Function
22:15:52 <orzo> how can i remember that? I'm always forgetting
22:16:02 <jle`> it...doesn't really have anything to do with monads, lol
22:16:05 <iqubic> Why do people use fix?
22:16:09 <iqubic> What's the point of that?
22:16:34 <EvanR> it does give you an anonymous loop 
22:16:42 <EvanR> sometimes you dont want to come up with a name
22:16:48 <iqubic> It does???
22:16:50 <iqubic> How??
22:16:55 <EvanR> @src fix
22:16:55 <lambdabot> fix f = let x = f x in x
22:17:00 <jle`> fix f = f (fix f)
22:17:03 <EvanR> or that
22:17:22 <jle`> iqubic: you can parameterize a recursive function by the recursive call
22:17:48 <iqubic> so how could you use fix to write a factorial function?
22:18:08 <EvanR> you should try it
22:18:09 <jle`> iqubic: so you would write a normal fatorial function like: `fac n = if n == 0 then 1 else n * fac (n - 1)`
22:18:16 <nshepperd> > fix (\loop i -> i : loop (i + 1)) 0
22:18:18 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
22:18:31 <jle`> so, you can make it "anonymous" by parameterizing it on the recursive fac call
22:18:45 <nshepperd> ^^ there, a loop that counts up using fix
22:19:08 <iqubic> jle`: Can I see that in action?
22:19:10 <jle`> fac n recursiveFacCall = if n == 0 then 1 else n * recursiveFacCall (n - 1)
22:19:24 <nshepperd> > fix (\loop acc i -> i : loop (acc * i) (i + 1)) 1
22:19:26 <lambdabot>  <Integer -> [Integer]>
22:19:31 <nshepperd> > fix (\loop acc i -> i : loop (acc * i) (i + 1)) 1 1
22:19:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:19:38 <jle`> instead of actually calling fac itself again, we can parameterize it by the thing i want to re-call
22:19:39 <nshepperd> oh wait
22:19:52 <jle`> @let fac n recursiveCall = if n == 0 then 1 else n * recursiveCall (n - 1)
22:19:54 <lambdabot>  Defined.
22:20:02 <jle`> er
22:20:04 <jle`> @undefine
22:20:04 <lambdabot> Undefined.
22:20:15 <jle`> @let fac recursiveCall n = if n == 0 then 1 else n * recursiveCall (n - 1)
22:20:16 <lambdabot>  Defined.
22:20:20 <nshepperd> > fix (\loop acc i -> acc : loop (acc * i) (i + 1)) 1 1 -- factorials
22:20:22 <jle`> fac id 3
22:20:22 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
22:20:37 <jle`> > fac id 3
22:20:39 <lambdabot>  6
22:20:57 <jle`> iqubic: now, to get the original factorial, you pass in fac back into itself
22:21:08 <iqubic> jle`: can you use fix to write that?
22:21:10 <jle`> (fac (fac (fac (fac (fac ...)))))
22:21:14 <jle`> that's what fix is
22:21:18 <jle`> fix f = f (fix f)
22:21:27 <iqubic> Oh. So when does it terminate?
22:21:28 <jle`> fix fac = fac (fix fac) = fac (fac (fix fac))
22:21:34 <jle`>  = fac (fac (fac (fix fac)))
22:21:36 <iqubic> I see.
22:21:41 <jle`>  = fac (fac (fac (fac (fix fac)))
22:21:43 <iqubic> ANd it goes on and on
22:21:43 <jle`> etc.
22:21:45 <jle`> > fix fac 10
22:21:47 <lambdabot>  3628800
22:21:58 <iqubic> Oh. So when does it terminate?
22:22:09 <jle`> whenever 'fac' doesn't use 'recursiveCall'
22:22:20 <jle`> then it will just ignore its argument
22:22:26 <EvanR> it may not terminate
22:22:33 <jle`> so `fac (fix fac) 0` will ignore its (fix fac) argument
22:22:34 <EvanR> see nshepperd's examples
22:22:39 <jle`> so (fix fac) won't ever expand
22:22:42 <jle`> fac (fix fac) 0 = 1
22:22:47 <jle`> w/o ever needing to expand fix fac
22:23:00 <iqubic> > fix fac 0
22:23:02 <lambdabot>  1
22:23:05 <iqubic> > fix fac -1
22:23:07 <lambdabot>  error:
22:23:07 <lambdabot>      • No instance for (Typeable t0)
22:23:07 <lambdabot>          arising from a use of ‘show_M617544506980072183829121’
22:23:27 <iqubic> right, that produces an endless stream of function calls.
22:23:38 <jle`> yeah, since each function call will require (fix fac)
22:23:42 <jle`> so it'll go on forever
22:24:02 <jle`> but `fix fac 0` is just `fac (fix fac) 0`, which is just 1
22:24:05 <jle`> since fac _ 0 = 1
22:24:11 <jle`> laziness to the rescue ~
22:24:25 <EvanR> iqubic: you almost always need (-1) in parentheses
22:24:54 <iqubic> > fix fac (-1)
22:24:56 <lambdabot>  *Exception: stack overflow
22:25:10 <iqubic> Right. That is to be expected.
22:25:25 <EvanR> i wasnt expecting that
22:25:43 <jle`> fix fac (-1) expands for ever, since there `fac recursiveCall n` will use recursiveCall in every case, if n is negative
22:25:43 <iqubic> I was.
22:25:57 <jle`> i'll admit that it is surprising to me as well
22:26:05 <EvanR> yeah well youd get that in a regular language
22:26:14 <EvanR> in haskell you really gotta try to get stack overflow
22:26:17 <iqubic> because it call fac of n-1 forever and ever until n = 0
22:26:34 <jle`> yes, but it shouldn't be a stack overflow
22:26:36 <EvanR> > last [1..] --see
22:26:42 <lambdabot>  mueval-core: Time limit exceeded
22:26:48 <jle`> hm i get a stack overflow on ghci too
22:26:56 <iqubic> but if you start with a negative number and continue subtracting 1, you never reach 0
22:27:03 <jle`> i expected lambdabot to timeout
22:27:11 <jle`> since the implementation of 'fix' is constant space
22:27:20 <EvanR> > minBound - 1 * maxBound :: Int
22:27:22 <lambdabot>  1
22:27:28 <ChaiTRex> lambdabot's just not fast enough to get last [1..] in time.
22:27:29 <EvanR> > minBound - 1 * maxBound - 1 :: Int
22:27:31 <lambdabot>  0
22:29:21 <jle`> EvanR: mueval imposes some restrictions to the runtime i believe
22:30:46 <Mibaz> I'd like to do IO in some random other monad, but there isn't a transformer available. Is it impossible?
22:31:20 <jle`> it depends on what you really want to do
22:31:31 <jle`> if your monad is an instance of MonadIO, then you can just use 'liftIO'
22:31:44 <jle`> MonadIO m => IO a -> m a
22:31:50 <jle`> :t liftIO
22:31:51 <lambdabot> MonadIO m => IO a -> m a
22:32:40 <Mibaz> jle': Well shoot, it is. 
22:32:46 <jle`> hooray :D
22:32:59 <jle`> usually if it's *possible* to sequence IO with a monad, the monad should offer a MonadIO instance
22:33:03 <jle`> since MonadIO is a part of base
22:33:26 <jle`> the monad itself would have to actually support this, of course
22:34:08 <Mibaz> jle' Ok awesome, that makes this easy. I knew I had to be missing something easy. Thanks
22:34:21 <jle`> no problem!
22:36:29 <supki> j
22:40:26 <SrPx> lol
22:40:36 <SrPx> the calculus of constructions is literally just the lambda calculus
22:41:08 <SrPx> with a system for applying arbitrary terms to functions on compile time
22:41:08 <EvanR> there are many lambda calculi
22:42:01 <SrPx> it is literally just that, `λ (t : *) -> λ (s: t -> t) -> λ (z : t) -> (s (s (s (s z))))` 
22:42:44 <SrPx> the first thing it does is creating a value called t and applying it to the top level lambda
22:43:00 <SrPx> λ (s: t -> t) -> λ (z : t) -> (s (s (s (s z))))
22:43:11 <SrPx> then it creates a function that receives t and returns t and applies that to it
22:43:33 <SrPx> λ (z : t) -> (λ t . t (λ t . t (λ t . t (λ t . t z))))
22:43:34 <SrPx> same again
22:43:44 <SrPx> (λ t . t (λ t . t (λ t . t (λ t . t t))))
22:43:58 <SrPx> so all functions that need a t are applied to a t so that checks
22:44:14 <SrPx> I mean my syntax got a little confusing but seriously that's all a type system does
22:44:18 <SrPx> everything else is just that
22:44:32 <SrPx> types are a lie
22:44:32 <SrPx> there is no magic
22:45:15 <MarcelineVQ> you were the magic all along
22:45:21 <EvanR> pay no attention to the man behind the currying
22:46:01 <SrPx> basically `λ (var : TYPE) -> BODY` just means "hey make a mock value TYPE at compile time, and apply to this otherwise untyped function at compile time"
22:46:32 <SrPx> and logic, what logic even is
22:46:43 <SrPx> nothing makes sense
22:49:40 <SrPx> so if types are theorems and programs are proofs
22:50:17 <SrPx> and since we just determined clearly types are just mocks
22:50:29 <SrPx> then theorems are just mocks
22:50:54 <SrPx> every single mathematical question ever is just asking: "is there a program to which we can apply this mock value to"
22:51:14 <SrPx> that was so stupid wasn't it
22:51:16 <SrPx> i'm tired
22:51:21 <glguy> OK, goodnight
22:51:36 <SrPx> ):
22:53:31 <nshepperd> the real magic was the type checking we did along the way
22:55:10 <SrPx> the type checking we did along the way?
22:58:31 <EvanR> is there a way to get threads with higher priority
23:00:39 <mrkgnao> is there a way to pattern match on the Nats from GHC.TypeLits?
23:01:07 <mrkgnao> I have my own little data N = Z | S N type that I can convert to and fro, but I'd rather not
23:04:53 <jle`> mrkgnao: you can pattern match on them already
23:05:00 <jle`> the patterns are 0, 1, 2, etc.
23:05:25 <jle`> that is their structure
23:05:56 <jle`> there structure is not inductive peano nats
23:06:01 <jle`> s/there/their
23:06:57 <jle`> you can do things like (n + 1), depending on what you want to do, though
23:07:58 <EvanR> heh you call that structure?
23:08:55 <jle`> i mean, it's like Bool
23:09:03 <jle`> except with more than two constructors
23:09:28 <EvanR> ex a primitive String type has such structure "foo", "bar", etc
23:09:41 <mrkgnao> jle`: so is that type to avoid the high efficiency usually associated with unary Nats? :)
23:09:59 <mrkgnao> s/to/meant to/
23:10:27 <jle`> it's not really meant to be a "naked" interface
23:10:33 <jle`> i think it's meant to assume as little as possible
23:10:42 <jle`> so that other libraries can take it and extend it
23:12:20 <jle`> GHC.TypeLits is sort of meant to be a low-level API that other libraries are supposed to hook onto and provide useful high-level interfaces
23:12:52 <jle`> so all it really "offers" is the literals, and the reifiers/reflectors
23:13:12 <jle`> and some basic type families
23:14:31 <mrkgnao> interestingly, I have a recursive typeclass that sort of accumulates a list in its last parameter
23:14:58 <mrkgnao> something like class Foo a b c | a b -> c
23:15:26 <mrkgnao> and I have a variable of type Foo a b c => Proxy c
23:16:32 <mrkgnao> and *every* time I try to inspect it (either with :t or by trying to print it) it takes a couple seconds, and the time taken does not change on successive attempts
23:17:30 <mrkgnao> b is a Nat, and the time grows linearishly with b :)
23:49:38 * hackage hdo 0.5 - A Digital Ocean client in Haskell  https://hackage.haskell.org/package/hdo-0.5 (abailly)
23:51:38 * hackage atlassian-connect-descriptor 0.4.5.0 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.5.0 (RobertMassaioli)
23:59:47 <mniip> interesting
