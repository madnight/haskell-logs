00:26:38 * hackage Sit 0.2017.5.2 - Prototypical type checker for Type Theory with Sized Natural Numbers  https://hackage.haskell.org/package/Sit-0.2017.5.2 (AndreasAbel)
00:44:07 <merijn> Poll: I have a library for a variation on Chan which is currently using Control.Concurrent.BroadcastChan as module prefix, but now that I want to add submodules, that seems increasingly cumbersome to import...should I just move it to BroadcastChan as top level module?
00:44:36 <jchia> Is there a hackage package for merging two already-sorted vectors? I don't want to sort their concatenation when I just need to merge them.
01:09:29 <merijn> Is ghc-core still the recommended way to investigate how GHC is optimising/compiling things?
01:10:59 <phadej> merijn: I'd say so
01:16:02 <merijn> Fun times, ghc-core is someone getting confused about iconv again :\
01:46:11 <Younder> This might seem like an odd question, but do cryptanalyst se Haskell?
01:46:18 <Younder> use
01:46:40 <haskell> hmm
01:47:29 <Younder> It seems like a tool a mathematically minded person would like.
01:48:14 <LiaoTao> Younder: Do nurses use bananas?
01:49:08 <Younder> I understand to get a job at NSA you need a PHD in math and then on top of that you have 4 years of additional education in cryptanalysis.
01:50:15 <peddie> Younder: you may be interested to read about Cryptol (http://www.cryptol.net/)
01:50:20 <Younder> LiaoTao, Yes I guess I already know the answer.
01:51:45 <Younder> :) is it short lived as Galois though (he died at 23)
01:54:08 <Younder> Haskell is after all a particularity strenuous experiment which should have died a long time ago, except it go a lot of things right
01:54:21 <Unode> in the conduit framework, is it possible to split a single source into multiple sinks where each sink receives part but not all of the data read? e.g. splitting a file into multiple of a fixed size
01:54:41 <Younder> I like serendipitous accidents
02:00:13 <kuribas`> Younder: that's true about any language...
02:00:45 <kuribas`> Younder: IMO still one of the best...
02:01:36 <kuribas`> Younder: the right blend of pragmatic and elegant.
02:06:05 <kuribas`> That's how it goes with languages, by the time they get critical mass, they are outdated.
02:10:04 <Grisha> what’s the best way to hoist `Either e a` to `Reader ConfigType (EitherT ErrorType IO) a`?
02:11:24 <Grisha> sorry
02:11:39 <Grisha> I meant `Either ErrorType a` of course
02:12:37 <opqdonut> Grisha: is that ReaderT?
02:12:46 <Grisha> yeps
02:12:51 <Grisha> sure
02:13:06 <Grisha> I’m a bit defocused
02:13:47 <Grisha> and I’ve got another wierd error message on `config <- ask`, being the first line in the function body
02:14:58 <Grisha> http://lpaste.net/4737168302638366720
02:14:59 <Grisha> here
02:15:17 <opqdonut> I think something like "lift (fmap return eithervalue)" should do that transformation
02:15:51 <ptek> Unode: I think you can combine the use of chunksOf to first partition your data into chunks of given size, and then pass it on to something like mapAccumWhile
02:15:54 <Grisha> eitherDecode :: String-like -> Either String FromJSONInstance
02:16:24 <ptek> Unode or concatMapAccum
02:16:50 <Unode> ptek: ok I'll have a look at those two and ask again if I don't get it. Thanks for the directions.
02:17:27 <ptek> Unode, I have seen an example of concatMapAccum here recently: http://stackoverflow.com/a/11066007/140623
02:18:59 <ptek> Unode, in my mind it could go like this: first create chunks of given size, then number the chunks with concatMapAccum, then pass it on into files named by the numbers
02:19:11 <Grisha> opqdonut: thanks!
02:19:14 <kuribas`> Grisha: either left return ?
02:19:40 <Unode> ptek: ok, that could work.
02:19:49 <Grisha> kuribas`: thanks! i’ll check
02:20:43 <kuribas`> Grisha: or (left . convertError)
02:21:03 <kuribas`> Grisha: if the error type isn't the same
02:21:10 <Grisha> kuribas`: thanks! do you happen to see the problem with the above code?
02:21:18 <ptek> Unode, although I've just realised that I wold not know how to decompose the tuple so it can be given to `sinkFile`
02:21:53 <Grisha> kuribas`: oh, sorry, forget that
02:22:02 <Unode> ptek: I was reading about zipSink yesterday but didn't get how it works. The explanations seem to go in the direction of every sink getting a copy of the data.
02:22:03 <Grisha> kuribas`: I was looking at a wrong line number
02:22:08 <kuribas`> np
02:22:16 <Grisha> kuribas`: thought the problem was on the line with the ask call
02:24:45 <Grisha> hm, I’m not quite sure I understand the problem
02:25:09 <Grisha> given the outer monad is `ReaderT Config (EitherT String)`
02:25:32 <Grisha> and the intermediate result is of type `Either String a`
02:25:48 <Grisha> we need to “unwrap” the `Either String` part of the intermediate result
02:25:59 <Grisha> and wrap it into `ReaderT Config (EitherT String`
02:26:06 <Grisha> is that correct?
02:26:44 <opqdonut> sounds right. the wrapping is done with lift
02:26:55 <Grisha> the problem is with threading the `String` part from Either into `Reader Config (EitherT IO String)`
02:27:44 <Grisha> (I forgot the IO monad in the above ReaderT type obviously)
02:27:49 <opqdonut> you want to go from `Either String a` to `Either String (IO a)`? that's just `fmap return`
02:28:12 <Grisha> I’ve got an `Either String a`
02:28:38 <Grisha> and it should be put into the context of `ReaderT Config (EitherT IO) a`
02:28:52 <kuribas`> :t hoistEither
02:28:53 <lambdabot> error: Variable not in scope: hoistEither
02:28:55 <ptek> Unode, it looks like an answer exists exactly for your example problem: http://stackoverflow.com/a/23184797/140623
02:29:04 <Grisha> kuribas`: I saw hoistEither already
02:29:18 <Grisha> it hoists to EitherT
02:29:29 <Grisha> part of `either` package
02:29:59 <Grisha> hoistEither :: Monad m => Either e a -> EitherT e m a
02:30:17 <Grisha> I’m wondering if what I’m trying to do here does smell a bit
02:31:18 <Unode> ptek: awesome! yeah indeed it seems exactly that. I didn't find this when googling. Thanks!
02:31:36 <kuribas`> Grisha: then just "return . hoistEither"?
02:32:08 <ptek> Unode, I am really curious how you's solve that, would you mind posting the code here when you make it work?
02:32:36 <Unode> ptek: sure. But grab a chair this will take a while :)
02:32:42 <Grisha> kuribas`: it doesn’t do
02:33:26 <kuribas`> Grisha: what transformer library are you using?
02:33:28 <opqdonut> Grisha: lift . hoistEither
02:33:29 <Grisha> kuribas`: since (return . hoistEither) (x :: a) results in `:: Reader Config (EitherT String IO) (EitherT String a)`
02:34:04 <opqdonut> Grisha: `(lift . hoistEither) :: Either e a -> ReaderT r (EitherT e IO) a` sez my ghci
02:34:22 <Grisha> kuribas`: I’m using `transformers` for ReaderT and `either` for `EitherT`
02:34:40 <Grisha> opqdonut: lemme check
02:34:46 <Grisha> `lift` coming from?
02:34:51 <opqdonut> Control.Monad.Trans
02:34:55 <opqdonut> :t lift
02:34:55 <Grisha> thanks
02:34:57 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
02:35:07 <opqdonut> that's how you wrap a thing into a monad transformer
02:35:30 <Grisha> opqdonut: is it mtl?
02:35:32 <opqdonut> yes
02:35:37 <Younder> monoids are a lot cleaner
02:35:53 <Grisha> I’ve already got 2 diff monad transformers libraries in the project ;)
02:36:04 <Younder> do it is 2 steps?
02:36:18 <opqdonut> Grisha: no sorry it's transformers
02:36:29 <opqdonut> http://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Class.html#v:lift
02:36:40 <opqdonut> I can never remember which one was which
02:36:49 <Grisha> so it’s .Class
02:37:26 <Grisha> ok, (lift . hoistEither) did compile
02:37:31 <opqdonut> hmm I got it from Control.Monad.Trans, I guess somebody re-exports it
02:38:35 <Grisha> the func did compile
02:38:37 <Grisha> however!
02:38:45 <Grisha> (that’s where the mystery continues)
02:38:56 <Grisha> it added a layer of [] on top my of my return data types
02:39:38 <Grisha> oh no, it’s stupid me again
02:39:55 <Grisha> before I assumed the result was a functor
02:51:38 * hackage hsudoku 0.1.1.0 - Sudoku game with a GTK3 interface  https://hackage.haskell.org/package/hsudoku-0.1.1.0 (mmo)
03:23:02 <Cooler> is there a way to have a static variable?
03:23:23 <Cooler> that gets modified by several functions and is different each call
03:24:45 <srhb> Cooler: You might want IORef
03:24:52 <Younder> static variable? Not sure I understand the concept
03:25:08 <srhb> Cooler: At least, if you by static mean mutable. :)
03:26:36 <Taneb> Cooler, a big part of functional programming, and Haskell especially, is the pervasive use of mutable state
03:26:53 <srhb> Taneb: Huh?
03:27:02 <Taneb> *immutable
03:27:04 <unsymbol> these last few messages have been quite... confusing ;)
03:27:06 <srhb> Ah. :-P
03:27:13 <Taneb> Brain error, sorry
03:28:32 <Cale> Cooler: Usually you'd just make that a function parameter
03:28:47 <Cale> Cooler: If the result of a function depends on something, that something should be a parameter to the function.
03:29:15 <zariuq> let f a b c = (a,b,c)
03:29:20 <zariuq> is there already a function for this?
03:29:25 <zariuq> like (,) for 3-tuples
03:29:26 <Cale> (,,)
03:29:30 <zariuq> ... T_T
03:29:36 <zariuq> damn, super simple bro
03:29:50 <zariuq> (,,,) too. Thank you Cale!
03:29:55 <Cale> no problem
03:31:08 * hackage hail 0.1.0.2 - A service for pull-based continuous deployment based on hydra.  https://hackage.haskell.org/package/hail-0.1.0.2 (shlevy)
03:31:24 <Cooler> Cale, it gets really complicated passing around the latest version of something to every function that needs it
03:33:36 <liste> Cooler: you can use scoping for that, eg. foo x = result where bar = ... do something with x ...; quux = ... do something with x ...; result = bar quux -- here you don't need to pass x everywhere
03:33:51 <Cale> Cooler: In which way is it getting complicated?
03:34:31 <Cale> and what kind of thing are we really talking about?
03:34:47 <Cale> It can be a bit tough to have this sort of conversation abstractly
03:34:59 <maambmb> guys - im going insane trying to get my environment set up. I'm using a stack new-template. Everytime I try and import Control.Monad.State is says "failed to load interface"
03:35:11 <maambmb> isn't this stuff auto included?
03:35:30 <Cale> maambmb: Do you have mtl as a dependency?
03:35:36 <liste> maambmb: Control.Monad.State is part of mtl package
03:36:24 <Cale> Cooler: anyway, there are various solutions to different kinds of problems you might run into
03:36:34 <Cooler> liste, it looks better and more sane to write different top level functions instead of scoping further and further in
03:36:49 <Cooler> especially with the indentation growing out of control
03:37:26 <Cale> Cooler: Usually I like adding parameters and just allowing things to be a bit messy until I can figure out what's going on -- which parts of the program depend on what
03:37:41 <Cooler> Cale, yeah thats what i am doing now
03:37:44 <Cale> Cooler: and then I start defining data types or building abstractions around that
03:38:19 <Cale> The first thing is when you see the same collections of parameters going to many places, probably those things deserve to be packaged together for some reason.
03:39:25 <maambmb> do I have to manually specify the version of mtl myself in the stack.yaml, or is there not an equivalent to npm install mtl --save?
03:39:37 <Cooler> Cale, yeah but then you have to deal with wrapping and unwrapping
03:39:48 <Cooler> its get really messy
03:39:51 <Cale> maambmb: I would expect you just need to add it to your .cabal
03:40:54 <Cale> Cooler: I'm not sure what you mean
03:41:26 <Cooler> Cale, packaging stuff together
03:41:56 <Cale> Cooler: Use record syntax, use the field extractor functions to unpack the bits of your config or whatever it is.
03:42:08 <Cooler> yeah
03:42:38 <maambmb> jesus
03:42:39 <maambmb> finally
03:42:40 <maambmb> it works
03:42:47 <maambmb> thank you lads!
03:43:00 <maambmb> i was about to ragequit from life
03:45:40 <Unode> when importing multiple modules under the same alias "as N" does ghc warn if there are namespace clashes?
03:46:38 * hackage hedgehog 0.2.2 - Hedgehog will eat all your bugs.  https://hackage.haskell.org/package/hedgehog-0.2.2 (JacobStanley)
03:47:09 <Cale> Cooler: So, beyond that, there's stuff like State for threading parameters along, or you can sometimes make good use of an IORef or MVar or another sort of mutable state.
03:48:46 <Cale> Cooler: Often rather than passing an IORef or MVar or whatever it is around, I will instead pass readIORef r and writeIORef r to the things which need read or write access -- often it'll be different parts of a program. Or if there's some expected access pattern to the IORef, I will make some function wrapper around that access pattern, and pass that.
03:50:11 <Cale> The flexibility which comes from doing that is very often useful later, and it's usually not much extra effort.
03:50:16 <Aruro> are there good haskell bindings to libusb and liblua?
03:50:48 <Cale> (since you still need to rig up getting the IORef where it's going anyway, it's not much different passing some function for accessing it)
03:53:58 <Cale> That gives you a convenient place to put in logging of changes to the state, possibly some kind of validation, or sometimes for instance, you'll discover that you really wanted that IORef to be a TVar or something, and it saves you from having to go all over your program making changes later.
04:04:08 * hackage sqlcipher 1.0.1.2 - Haskell binding to sqlcipher  https://hackage.haskell.org/package/sqlcipher-1.0.1.2 (figo)
04:14:30 <akegalj> hey all. I am trying to figure out how to use CA (Ceritficate authority) with warp-tls https://hackage.haskell.org/package/warp-tls-3.2.3/docs/Network-Wai-Handler-WarpTLS.html . So there is a simple way to use server-cert and server-key with tlsSettings method. tlsSettingsChain looks like something that I can provide CA as a second argument. Is this right?
04:30:50 <LAZAR> Any suggestions how to improve code style / performance on this short knapsack problem solver? http://lpaste.net/355569 Much appreciated!
04:36:08 * hackage patat 0.5.2.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.5.2.0 (JasperVanDerJeugt)
04:39:03 <opqdonut> LAZAR: could use pattern matching instead of n==0 in generateItems. otherwise looks good
04:40:07 <lyxia> Also pattern match on pairs, especially when using random generators
04:41:02 <LAZAR> opqdonut: Interestingly, someone suggested to me yesterday to use if...else if there are just two alternatives and a boolean predicate
04:41:18 <opqdonut> LAZAR: fillKnapsack could track the weight left, so decrease `limit` every time you add an item
04:41:33 <opqdonut> LAZAR: yeah if it was a generic boolean predicate, but for equality you can pattern match
04:42:18 <lyxia> LAZAR: IIRC the suggestion was to use if over case
04:42:19 <opqdonut> it's idiomatic
04:44:32 <LAZAR> And how would i pattern match a local variable? like value = randomR range generator
04:45:05 <lyxia> (value, gen') = randomR range generator
04:45:31 <LAZAR> lyxia: ah cool so basically like in python
04:46:23 <lyxia> yeah
04:46:54 <lyxia> but better since you can do this with any algebraic data type
04:57:16 <wilornel> Is there any resource that explains all Haskell errors? A lot of times they do not make sense to me
04:58:04 <wilornel> I mean, right now I think I veguely understand why there is an error ( I would not be able to explain all of the technicalities ), but the error does not make sen
04:58:08 <wilornel> se
05:04:12 <merijn> wilornel: I'm not sure, tbh. You can always just ask here
05:05:01 <Cooler> can you not have a let block in a pattern guard's result?
05:05:15 <Cooler> | otherwise = let foo = bar 2 2
05:05:51 <lyxia> what would be the meaning of that
05:06:14 <hpc> Cooler: let syntax is "let <definitions> in <expression>"
05:18:22 <LAZAR> Which kind of indentation styl do you think is better? http://lpaste.net/355573 Aligning all possible results in one line or not?
05:18:34 <LAZAR> *style
05:18:48 <ertes-w> wilornel: the most important thing is to actually read the error messages…  GHC is good at explaining the error, and if you don't understand the error message, then it means that you need to learn some new concepts
05:20:03 <ertes-w> LAZAR: i find the top one easier to read
05:20:36 <ertes-w> LAZAR: although in line 2 i would probably not use any padding
05:21:18 <ertes-w> in lines 4 and 5 i would align the "=", but write them right after the condition:  … - getWeight sack = fillKnapsack …
05:21:38 * hackage model 0.3 - Derive a model of a data type using Generics  https://hackage.haskell.org/package/model-0.3 (PasqualinoAssini)
05:23:26 <LAZAR> ertes-w: yeah thats true
05:37:31 <angerman> if anyone has questions regarding this: https://medium.com/@zw3rk/a-haskell-cross-compiler-for-raspberry-pi-ddd9d41ced94, let me know. I'll be happy to answer :)
05:39:31 <Younder> angerman, Does it use a C compiler for cross compilation?
05:39:38 * hackage servant-auth-token 0.4.6.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.4.6.0 (NCrashed)
05:40:36 <angerman> Younder: if you mean if it goes through the C backend, then no. It uses GHC's LLVM backend.
05:41:47 <Younder> angerman, ahh. So no clasp or gcc. nice to know
05:41:51 <ertes-w> let's say, you want to convert A1, A2 and A3 to B, so you might start by writing functions f1 :: A1 -> B, f2 :: A2 -> B, f3 :: A3 -> B…  the functions are just similar enough that you might think of merging them into an abstraction using a common A:  f :: (a -> A) -> a -> B
05:42:09 <angerman> Younder: however the llvm backend does stg -> cmm -> llvm ir -> assembly -> object files. And clang is used as the assembler.
05:42:47 <ertes-w> now you get A4 and A5, and also the functions f1, f2 and f3 are changing…  in order to keep the abstraction you make f more powerful and thus more complicated…  with every change f becomes more complicated, both in terms of interface and in terms of implementation
05:42:51 <angerman> Younder: or any other assembler that is found to turn assembly into object files.
05:43:00 <ertes-w> is there a name for this kind of problem?
05:43:19 <angerman> Younder: I'm not sure that this answers your question though?
05:43:38 <ertes-w> when seemingly similar functions are just different enough that abstraction is more expensive than ad-hoc
05:43:49 <lambdamu> I'm unhappy with the amount of manual work hsc, c2hs and greencard require. I wish there were a swig backend. How hard can it be to auto generate low level c bindings..
05:44:15 <ertes-w> lambdamu: a few libraries do that…  see 'gl' for example
05:44:28 <Younder> angerman, It serves my purposes for now. An ARM version of Haskell could be interesting. (Even if it has to be X-compiled.)
05:45:06 <LAZAR> What is the best way to deploy a haskell app for someone without GHC installed? I thought about Docker
05:45:07 <Younder> That is a ARM version of a haskell program.
05:45:08 <angerman> Younder: I think there will be arm binaries of the ghc release, which are native arm -> arm.
05:45:12 <Cale> Younder: If you have a sufficiently powerful ARM machine, perhaps it doesn't have to be cross compiled.
05:45:22 <lambdamu> ertes-w: do they use some homebrew solution and do they parse headers directly or some kind of spec?
05:45:37 <lambdamu> gonna take a look
05:45:43 <Younder> Cale, I have a Jetson TX1 which is fairly powerful
05:45:45 <angerman> Younder, Cale: yes the intention was to use a more powerful machine to compile to raspberry pi (a rather low power system).
05:45:55 <exio4> LAZAR: GHC compiles quite standalone apps by default 
05:45:59 <ertes-w> LAZAR: i'm using nix+docker for that, but you can also just compile a static executable
05:46:10 <exio4> LAZAR: (unless you enabled -dynamic)
05:46:17 <ertes-w> lambdamu: i don't know, sorry…  look at the source code
05:46:31 <LAZAR> exio4: It will compile elf bytecode on my machine which will not run on windows.....
05:47:09 <ertes-w> LAZAR: oh, if it's a different architecture/OS, you will need cross-compilation, or you need to use a native GHC
05:47:26 <LAZAR> ok i guess Docker is the easiest solution
05:47:28 <angerman> Younder: yes, there are arm ghc binaries. I believe Phyx- is building and providng them. See https://www.haskell.org/ghc/download_ghc_8_0_2.html#linux_armv7
05:47:35 <ertes-w> LAZAR: docker will not solve the different-OS problem
05:47:44 <ertes-w> LAZAR: if it's a linux image, it will only run on linux
05:47:50 <angerman> Younder: I believe there will be aarch64 builds eventually as well.
05:47:58 <Younder> QUEMU allows you some play here as it simulates other CPU's
05:48:09 <LAZAR> ertes-w: yeah but others can run my program inside a docker container
05:49:03 <ertes-w> LAZAR: also note that docker uses the notion of containers, with filesystems, etc…  you couldn't just "install" a docker image as a regular program
05:49:38 <ertes-w> so it's mostly useful for long-running programs like daemons
05:49:41 <anoLB> i suppose you could target xen, and run on qemu...
05:49:41 <angerman> Younder: yes, you can use the user emulation mode on linux. A quemu free cross compiliation setup, can be easier I believe.
05:49:43 <ertes-w> with a network interface
05:49:43 <Younder> angerman, arm7 is pretty ancient. You want a modern 64bit ARM
05:50:02 <angerman> Younder: which is why I said aarch64 build should be coming up soon, I believe.
05:50:03 <Cale> LAZAR: You might just want to get hold of a Windows machine, build the app there, and you'll end up with a Windows executable that way.
05:50:20 <anoLB> using HalVM ?
05:50:26 <ertes-w> LAZAR: you should find a way to produce native executables
05:51:00 <exio4> native executables which would be quite standalone
05:51:23 <angerman> Younder: for raspberry pi though, you are essentially targetting armv6, if you target raspbian, as that supports rpi1, rpi2, rpi3, rpi0. And rpi1 and rpi0 are armv6 only.
05:52:04 <Cale> heh, or depending on what kind of program it is, you might just use ghcjs to compile it to javascript and then it'll just run in the browser :D
05:52:24 <exio4> Cale: that's like.. cheating!
05:53:43 * angerman doesn't know much about cross compiling *to* windows. :(
05:54:00 <angerman> ok.. I don't know much about cross compiling *from* windows either ...
05:55:00 <Younder> angerman, yea aarch64 works on my Jetson only
05:55:46 <angerman> huh? no arm emulation? I thought they all were able to do arm... 
05:56:37 <Younder> the raspi's as you said run arm7
05:57:11 <Younder> Just did a quick uname -a
05:58:08 * hackage flat 0.3 - Principled and efficient bit-oriented binary serialization.  https://hackage.haskell.org/package/flat-0.3 (PasqualinoAssini)
05:58:44 <angerman> Younder: yea, rpi2 is armv7. However raspbian is compiled for arm-linux-gnueabihf, which is armv6, so it support rpi1 and rpi0 (which are armv6) as well.
05:58:48 <angerman> Younder: see: https://en.wikipedia.org/wiki/Raspberry_Pi
06:05:51 <stevenxl> Hi folks. New to Haskell. My program typechecks, but I get an exception when I am running my program in the repl. Is this just because of the repl?
06:05:57 <stevenxl> https://www.irccloud.com/pastebin/XbMAbObj/
06:06:20 <stevenxl> Or did I use exitSuccess incorrectly
06:09:43 <Younder> exitSucess should be unnecessary and not set to the function Palindrome at least. I recommend a function for determining if it is a palindrome, one for the printout and a main for calling and exiting
06:12:05 <ertes-w> using 'case' instead of 'if' for Bool is actually kinda charming =)
06:13:10 <Younder> compareStrings for strings
06:14:20 <Cooler> is there a way to insert a conditional breakpoint?
06:14:38 * hackage cabal-doctest 1.0.2 - A Setup.hs helper for doctests running  https://hackage.haskell.org/package/cabal-doctest-1.0.2 (phadej)
06:14:51 <Cooler> foo a b = :break (a == 2)
06:15:54 <Cooler> Cale, ?
06:17:06 <Cale> Cooler: I haven't really used ghci's debugging stuff much at all, but I don't recall there being a way
06:18:38 <Cale> Cooler: You could do something to branch on the value of a, and then set a breakpoint in the location where a is 2 or whatever.
06:19:38 <Cale> I've never found breakpoints to be very useful -- they're quite a weird notion in the presence of lazy evaluation.
06:19:59 <Cooler> how do you debug in lazy evaluation?
06:20:06 <Cooler> without breakpoints
06:20:18 <Cale> Mostly by evaluating expressions and figuring out what isn't evaluating to what you expect it to
06:20:45 <ertes-w> make code modular enough that you can test individual modules on their own
06:20:50 <c_wraith> Debug.Trace is handy, but you need to remember what it isn't.
06:21:02 <ertes-w> since lazy code is also pure code, testing is usually very easy
06:21:23 <Cale> Debug.Trace is mostly handy for getting realistic arguments to functions in cases where those wouldn't necessarily be obvious
06:22:06 <Younder> If you functions are typed they should be caught by the compiler
06:22:19 <Cale> You can write something like  foo x y z | trace (show ("foo", x, y, z)) False = undefined
06:22:39 <Cale> i.e. add that guard to the top of the definition of the function foo
06:22:45 <Younder> no
06:22:59 <c_wraith> though doing that breaks any code that depends on laziness to work. :)
06:23:06 <Cale> yes
06:23:16 <ertes-w> foo x y z = …  where !_ = traceShow ("foo", x, y, z) ()
06:23:40 <Cale> hah, bang patterns
06:23:51 <Cale> I still don't really think bang patterns should be able to do that
06:23:55 <Cale> but okay :)
06:23:59 <ertes-w> why not?
06:24:04 <ertes-w> it's super-useful
06:24:24 <Cale> Because it makes the translation a bunch less straightforward.
06:24:46 <Unode> Can someone explain the difference of having guard syntax | ... = ... versus | ... -> ... ? When does one use one or the other?
06:24:54 <Cale> and I dunno, turning let into case seems odd to me, though I guess ~ basically turns case into let, so whatever
06:24:55 <ertes-w> sure, but i'm willing to pay =)
06:24:59 <c_wraith> that also has weirdness issues with the scoping of where clauses when multiple equations and guards are involved
06:25:09 <Younder> I think for a beginner it might be more confusing than useful.
06:25:17 <c_wraith> Unode: = is for declarations, -> is for case expressions
06:25:18 <lyxia> are bang patterns defined as sugar for seq? I wonder whether it's RebindSyntax-able ...
06:25:29 <lyxia> (this is not a good idea ofc)
06:25:31 <Younder> How about just sticking to the usual debugging procedures.
06:25:40 <ertes-w> lyxia: not sure, but i'm pretty sure it's more likely translated into 'case'
06:25:42 <Unode> c_wraith: so these are different kinds of guards?
06:25:42 <Cale> Unode: Inside case expressions, use ->
06:25:57 <c_wraith> Unode: they're identical in meaning, they're just different parts of the syntax
06:25:58 <Cale> Unode: In function and pattern bindings, use =
06:25:59 <ertes-w> oh, no…
06:26:29 <Unode> ok, thanks
06:26:36 <Cale> lyxia: Yeah, the translation involves seq
06:26:39 <ertes-w> whatever, i know what it does…  not so worried about *how* it does it =)
06:27:05 <Cale> When bang patterns were first implemented, the translation was *super* simple
06:27:45 <ertes-w> Cale: i rarely use bang patterns for function arguments…  most of my uses are for 'let' and 'where'
06:27:49 <Cale> You'd just throw a seq in for each variable with a bang on the right hand side.
06:28:11 <ertes-w> for 'let' i could live without them, but the 'where' stuff is really awkward to write without bang patterns
06:28:44 <ertes-w> f x' | b = y1 | otherwise = y2  where !x = g x'
06:28:45 <Cale> But that meant that, e.g.  let !x = ... in ... would mean let x = x `seq` ... in ...
06:28:57 <ertes-w> something like that is very convenient
06:30:14 <ertes-w> f x' | x `seq` b = y1 | otherwise = y2  where x = g x'  -- awkward
06:30:22 <Cale> I don't know why, but I've never actually come across an instance where I needed a bang in a where clause like that
06:30:38 <tobiasBora> Hello,
06:30:57 <tobiasBora> I'm using the pool package https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html
06:31:04 <ertes-w> Cale: i write functions like this a lot:  f x = go where …
06:31:09 <ertes-w> Cale: where 'go' is a function
06:31:58 <ertes-w> Cale: telling GHC that a local value can be evaluated right away seems to help the strictness analyser a lot, so i get much more efficient code in return
06:32:41 <tobiasBora> in order to create a pool of connections. In my postgresql options, the maximum number of connections is 100, so I'd like to create a 60 connections to pools. However I'm not sure to understand the difference between the two parameters in the pool settings
06:32:44 <tobiasBora> I tried this:
06:32:49 <tobiasBora> Pool.createPool (PGSQL.connectPostgreSQL connString) 60 600 60
06:32:57 <Cale> ertes-w: In a case like that though, you could just use seq
06:32:59 <tobiasBora> However it creates too many connections
06:33:03 <ertes-w> Cale: then if you use it like (map (f x)), it also initialises the local values before the fold even starts
06:33:28 <tobiasBora> What do they call stripes ?
06:33:58 <tobiasBora> What is the good way to set up a maximum number of simultaneous connections of 60 ?
06:34:05 <Cale> tobiasBora: That's the second argument to createPool
06:34:09 <ertes-w> Cale: yes, but seq gets unwieldy if you have a few of those, and you also get a locality disconnect between the definition and the "evaluate immediately" intent
06:34:13 <Cale> er, third
06:34:18 <ertes-w> Cale: it's just much nicer with bang patterns
06:34:33 <Cale> (the first numerical argument)
06:34:59 <tobiasBora> hum I wrote you the wrong command, the good command is "Pool.createPool (PGSQL.connectPostgreSQL connString) (HDBC.disconnect) 60 600 60"
06:35:12 <tobiasBora> Cale: and what should be the first numerical argument ?
06:35:20 <Cale> So that's going to have 60 stripes
06:35:51 <Cale> It will leave unused connections open for 600 seconds
06:36:08 <Cale> and it'll keep at most 60 connections open per stripe
06:36:40 <tobiasBora> Cale: what is a stripe ?
06:37:14 <Cale> Independently managed sub-pools. Usually you just want 1
06:37:34 <Cale> We use   createPool openPostgresql closePostgresql 1 5 20
06:37:37 <tobiasBora> Ok thank you. Here I've 60 * 60 connection maximum right ?
06:37:45 <Cale> yeah, that's rather extreme
06:37:54 <tobiasBora> I see thank you.
06:37:56 <mutsig_> Hi. I've got a question regarding heap profiling. After around 40 in my heap profile, I get a significant increase of "trace elements". After a few googles, I couldn't find what that refers to. What are "trace elements"?
06:38:04 <tobiasBora> Why 5 is better than 600 ?
06:38:21 <tobiasBora> usually I don't want to close connection right ?
06:39:52 <Cale> I haven't really thought too much about that, but if you're sharing a database server between many running instances of the application, it might be important to clean up more promptly
06:40:59 <Cale> mutsig_: Everything which isn't listed in the legend
06:41:59 <mutsig_> Cale: Ok, thanks. 
06:42:08 <Cale> mutsig_: the term comes from chemistry
06:42:38 <mutsig_> Cale: Is there any general thing to consider if trace elements is a large portion of the heap?
06:43:03 <Cale> There's a flag to hp2ps
06:43:08 <Cale> http://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/hp2ps.html
06:43:14 <Cale> oops, that's old, but whatever
06:43:19 <Cale> -t<float>
06:43:43 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#cmdoption-hp2ps-t
06:44:15 <merijn> Poll: I have a library for channels that's currently using Control.Concurrent.BroadcastChan as namespace, but now that I want to introduce submodules to that it's becoming a rather cumbersome name for importing. Should I just switch to a top-level BroadcastChan module?
06:44:18 <Cooler> is foldr better than foldl?
06:44:34 <Cale> Cooler: For what task?
06:45:14 <Cooler> Cale, reducing an array
06:45:22 <Cale> Cooler: An *array*?
06:45:37 <Cooler> list
06:45:55 <Cale> Cooler: I mean, which functions are you supplying as arguments to the thing?
06:45:58 <Athas> Cooler: foldl' is best.
06:46:16 <Cale> Cooler: foldr and foldl are better than each other in different circumstances
06:46:19 <Athas> Use foldr if you want laziness, otherwise use foldl'.  Never use plain (non-strict) foldl.
06:46:29 <Cooler> Cale, well its a custom function
06:46:39 <Cale> (and usually when foldl is better, foldl' makes sure that you get the advantage, but GHC's optimisations are typically smart enough anyway)
06:46:51 <Cale> Cooler: *which* custom function
06:46:58 <Cale> Does it pattern match on both its arguments?
06:47:17 <Cooler> oh
06:47:44 <Cooler> right now i am using foldr and pattern matching on the first
06:48:00 <Cale> > foldr (\x xs -> if even x then x:xs else xs) [] [1..] -- can't do this with foldl, for instance
06:48:02 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
06:48:16 <Cale> (i.e. implement filter)
06:49:20 <Cale> @src foldr
06:49:20 <lambdabot> foldr f z []     = z
06:49:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:49:39 <Cale> As you can see there, foldr immediately gives control to f in the nonempty list case
06:49:48 <Cooler> Cale, its always a finite list
06:49:49 <Cale> only if f examines its second argument will the foldr continue
06:50:01 <Cale> So foldr can short-circuit
06:50:06 <Cale> @src foldl
06:50:07 <lambdabot> foldl f z []     = z
06:50:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:50:26 <Cale> foldl by contrast greedily applies itself to new arguments until it reaches the end of the list
06:50:31 <blackdog> Cooler: kinda doesn't matter - if it's a finite but large list, you need to know how it's being produced or you could end up with memory leaks
06:51:04 <Cale> Both of them work from left to right -- it's important to understand that a list can't be processed in any other order.
06:51:18 <Cooler> you can have memory leaks in haskell?
06:51:22 <Cale> Sure
06:51:51 <blackdog> it's not quite the same thing as a C memory leak, where you have stuff go missing permanently because you forgot t ofree it
06:52:01 <mutsig_> Cooler: If you build up large thunks of unevaluated function calls, you get memory leak. 
06:52:01 <blackdog> it's more like the working set is bigger than it needs to be
06:52:32 <Cale> It's where you have stuff that's not garbage, but would be, if you were to do the evaluation that you'll eventually end up having to do anyway.
06:53:22 <mutsig_> Cooler: that's what foldl might cause and foldl' might fix
06:56:39 <Cale> The difference with foldl' is that it hints to GHC that the (f z x) there which you can see in the definition of foldl will need to be evaluated, so that it can choose to do that evaluation sooner.
06:57:04 <Cooler> Cale, well the second argument in function given to foldr is the accumulator right?
06:57:07 <Cale> Compiling with -O, GHC will generally get that right on its own, but sometimes you'd rather be sure about it.
06:57:18 <Cale> I wouldn't refer to it as an accumulator
06:57:31 <Cale> It's the result when applied to an empty list
06:57:43 <Cale> It doesn't accumulate anything in foldr's case
06:57:50 <Cale> @src foldr
06:57:51 <lambdabot> foldr f z []     = z
06:57:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:57:54 <Cooler> well i am using it like an accumulator, its a Data.Map.Strict.Map that i am inserting stuff into
06:58:07 <Cale>                                 ^ we're passing the same z along
06:58:52 <Cale> Cooler: You almost certainly want foldl/foldl'
06:59:09 <Cale> Cooler: But probably even moreso, you'd rather use fromList and then union
06:59:50 <Cooler> well i am not just inserting that item
07:00:13 <Cooler> i am processing the item and inserting modifying the Map in the process
07:02:06 <wilornel> I think the biggest confusion for me with the error messages is the wordings with "expected" and "actual" 
07:02:38 <Cale> wilornel: Expected is what is expected to go in that position, actual is the type of the expression which is there.
07:02:40 <wilornel> expected means something on the right had to be like something on the left? How can I tell which token that I am looking at is the one that is expected to match something else?
07:03:00 <wilornel> how can I know which position it's refering to?
07:03:30 <Cale> It tells you which expression had the wrong type
07:03:32 <Cooler> wilornel, it gives you the line and column number
07:03:48 <Cooler> also that
07:04:29 <wilornel> ah right, thanks!
07:04:35 <wilornel> thanks Cale and Cooler 
07:05:39 <Cooler> so use foldl' ?
07:06:37 <Cooler> heres an example of foldr http://lpaste.net/355581
07:06:49 <Cale> Cooler: You shouldn't have to, there are suitable functions in Data.Map already
07:07:10 <Cale> for aggregating maps from lists of key/value pairs
07:07:39 <Cale> (fromList, fromListWith)
07:07:42 <wilornel> I think this makes sense as well: Remember: the type of 𝑎 is usually set by the le most instance of it and can’t change in the signature Eq a => a -> a -> Bool. Applying (==) to Integer will bind the 𝑎 type variable to Integer.
07:07:55 <wilornel> that's in the Haskell Programming from First Principles book
07:08:25 <Cooler> Cale, well in the paste, i am using the list as keys
07:08:44 <Cooler> or part of a key into the map
07:10:15 <merijn> So, no one has opinions on following the existing module hierarchy or not?
07:12:39 <Athas> merijn: the Haskell module namespace is a mess anyway.  You can't make it worse!
07:12:56 <glguy> now you're polling about polls?
07:12:59 <Cale> merijn: I was vaguely thinking that I might consider naming the type BChan
07:13:04 <Athas> If you just have convenience modules that re-export everything, then it doesn't matter if that convenience module has a long name.
07:14:25 <merijn> Cale: That doesn't really reduce much clutter from the import statements, tbh
07:14:39 <merijn> Cale: I already use BChan in the function name, but use a fully spelled type
07:14:54 <merijn> Cale: i.e. "writeBChan" over "writeBroadcastChan"
07:15:15 <merijn> glguy: Yes! :p
07:15:25 <Cooler> union table $ fromList $ map (\f -> ((sn, f), entry)) follows
07:15:27 <Cooler> is that beter?
07:15:30 <Cooler> better*
07:15:46 <Cale> Cooler: that looks like what I was thinking
07:15:49 <Athas> The successor to Haskell better have a good module system.
07:16:03 <Cooler> is it better than this http://lpaste.net/355581
07:16:12 <Cooler> which uses foldr
07:16:20 <Cooler> or would foldl' be better
07:16:36 <merijn> Cale: I was more trying to figure out whether people would consider BroadcastChan "valuable" namespace or whether I should just grab it :p
07:16:41 <Cale> It's similar to using foldl' though there might be some advantage to the union that you can't get by folding
07:16:54 <Cale> union will be linear time in the size of both Maps
07:17:13 <Cale> while insert is O(log n) time per element, so it ends up being O(n log n) ish
07:17:32 <Cale> But fromList is O(n log n) anyway
07:18:15 <Cale> You'd have to do more careful analysis than my current sleep schedule would allow me to do ;)
07:18:17 <wilornel> data (,) a b = (,) a b
07:18:17 <wilornel> instance (Eq a, Eq b) => Eq (a, b)
07:19:12 <wilornel> What does that mean? The data type tuple would need to define how it treats equality if it wants to be an instance of Eq
07:19:14 <Younder> wilornel, what is that supposed to mean?
07:19:34 <wilornel> I'm trying to understand what the second line tells us
07:19:36 <Cooler> wilornel, its a constraint
07:19:40 <merijn> wilornel: Forget everything you know about inheritance and instances from OO
07:20:01 <Cooler> a and b have to have instances of Eq
07:20:02 <merijn> wilornel: Whether a type is an instance of a typeclass is completely separated and unrelated to it's definition
07:20:07 <wilornel> so if a is an instance of Eq and b is an instance of Eq, then we can say that (a,b) is an instance of Eq
07:20:19 <ph88^> how can i find code that uses this function?  https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#v:tryC
07:20:54 <wilornel> so a type that is an instance of a typeclass does not need to implement the functions of the typeclass?
07:20:57 <merijn> ph88^: http://packdeps.haskellers.com/reverse
07:21:10 <Younder> would it not be clearer to use (a,b) than (,) a b
07:21:34 <wilornel> aaah wait! So in the syntax `instance A B`, we say that B is an instance of A, right?
07:21:38 <Cale> wilornel: It *really* should. If it doesn't, then unfortunately, what happens is that you get a warning and the methods get implemented with a runtime error.
07:22:01 <wilornel> And in `instance Constaint => A B` , we are saying that B is an instance of A, but only under the given constraint
07:22:02 <Cale> Yeah, the type B is an instance of the type class A.
07:22:16 <Cale> yeah
07:22:19 <wilornel> woot!
07:22:32 <wilornel> I just feel like the syntax does not communicate things clearly
07:22:34 <glguy> merijn: my opinion is that it's ok to blaze your own module trail
07:22:37 <wilornel> but this makes sense now!
07:22:37 <merijn> ugh...there's really nothing more readable than ghc-core? :(
07:22:45 <Younder> sigh, Haskell can be confusing
07:22:47 <Cale> Note that when deciding which instance applies to a given situation, the algorithm will *not* consider the constraints, only the structure of the type
07:22:48 <wilornel> but I didn't ge tmerijn's comment
07:23:03 <wilornel> principal type?
07:23:03 <Cale> Only after committing to a choice of instance will the constraints apply
07:23:15 <wilornel> It will check that the principal type fits under the constraints?
07:23:19 <merijn> wilornel: I was trying to say roughly the same thing. i.e. that instance can be declared separately from datatypes :)
07:23:26 <wilornel> merijn: cool!
07:23:31 <glguy> merijn: flags like -dsuppress-all and -dsuppress-uniques help
07:23:32 <Younder> Luckily it grows on you. In time you might even find it beautiful.
07:23:45 <wilornel> Younder: It does look very concise, which I really like!
07:23:49 <merijn> wilornel: So, if I define a new class I can make other, already existing types, instance too
07:24:13 <wilornel> ah, yes! 
07:24:39 <ph88^> merijn, there are a lot of package which used conduit .. i already search all the yesod packages
07:24:40 <merijn> glguy: ah, that looks slightly less harrowing
07:25:04 <merijn> ph88^: You could try searching github for the function name too
07:25:15 <ph88^> merijn, i did that
07:25:16 <Cale> wilornel: The instance to use will be selected based on the actual type, not just the principal type of an expression -- if you manually specify a type, it will be using that, rather than what would have been inferred.
07:26:08 <Younder> wilornel, Haskel has been (I think formally) declared a notation for math. So Haskell really is Math
07:26:19 <Cale> uhhh
07:26:20 <merijn> Younder: I would strongly disagree with that
07:26:21 <Younder> How concise is that!
07:26:26 <c_wraith> Younder: Haskell is a rather bad math. :)
07:26:36 <wilornel> what do you mean?
07:26:37 <Cale> Haskell is not a very good system for doing mathematics. As a logic, it's inconsistent.
07:26:46 <c_wraith> Younder: good look proving things usefully in haskell.
07:26:53 <c_wraith> Younder: since undefined is a proof of everything.
07:26:54 <ph88^> merijn, i only found this http://www.yesodweb.com/blog/2014/01/conduit-transformer-exception i would like an example how to write a handler
07:26:56 <Cale> But there are definitely close parallels to be drawn.
07:27:10 <Cale> (the fact that we can say that it's an inconsistent logic is something!)
07:27:14 <merijn> glguy: Do you by any chance know how I can suppress derived typeclasses too?
07:27:20 <Cale> :t fix
07:27:22 <lambdabot> (a -> a) -> a
07:27:23 <Younder> c_wraith, I use it for proving things all the time in haskabelle
07:27:42 <Cale> As a logical proposition, that doesn't make much sense: "If a implies a, then a"
07:27:45 <c_wraith> Younder: that is a different language.
07:28:33 <c_wraith> Younder: Isabelle can prove things.  But when the code you write interfaces with other haskell code, the proofs are gone again.
07:28:50 <Younder> c_wraith, For type theory to work with logic you need braided types as defied in Jacobs 'categorical types and logic'
07:28:53 <ongy> they aren't gone, they may just not mean much
07:29:03 <Cooler> how does fix work? it takes a function and gives you a value?
07:29:15 <Cale> Cooler: It gives you the least-defined fixed point of the function
07:29:19 <c_wraith> > fix $ (0:) . scanl (+) 1 -- Cooler 
07:29:21 <Cale> fix f = x where x = f x
07:29:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:29:31 <Cale> heh, nice starting example
07:29:32 <Younder> The thing is to bind a an object and its behaviour to a type 
07:29:37 <Cale> Let's start with something simpler
07:29:40 <Cale> > fix (1:)
07:29:42 <c_wraith> Cooler: it's an abstraction of general recursion
07:29:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:30:02 <Younder> You are not listening to me
07:30:03 <c_wraith> Cooler: anything that can be written with recursion can be rewritten with a non-recursive form and fix
07:30:23 <Cale> Note that undefined is not a fixed point of the function (1:), since 1:undefined is not the same as undefined
07:30:26 <Cooler> recursion to iteration?
07:30:27 <Younder> These are alll exceptions vreated by a brai damaged set system
07:30:36 <wilornel> what is going on. I wish I understood more to see what's going on
07:30:57 <Younder> This is how it is done:
07:31:01 <ongy> > fix show -- the favorite example of the person that showed me Haskell :)
07:31:03 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:31:06 <c_wraith> wilornel: I recognize that feeling.  I spent about a year feeling that way in this channel.  But I eventually picked it all up. :)
07:31:09 <Cale> by the definition, we have:
07:31:15 <Cale> fix (1:) = x where x = 1:x
07:31:32 <Younder> Yo generalize to have a class different from a set. So you avoid the russel paradox.
07:31:36 <c_wraith> well.  most of it.  I certainly don't know it *all*.
07:31:51 <Cale> So x is a list whose head is 1, and whose tail is x itself again.
07:32:07 <wilornel> yeah, is it like learnings emacs? you never finish learning it all? what did you read btw?
07:32:18 <Younder> Thaen you create a categoyical network of classed. Then you braid the classes to bind variables to their objects
07:32:41 <c_wraith> wilornel: believe it or not, I'd say I've learned about half of what I know about Haskell from here.  The other half from reading blog posts and papers linked to on the haskell subreddit
07:32:50 <Younder> Haskell is a lot more sound than you seem to think c_wraith 
07:32:53 <Cale> wilornel: You eventually will learn all of the actual language, but there's always more libraries, and in Haskell, the libraries can be like languages of their own.
07:33:06 <Cooler> Cale, how does the bot print that
07:33:10 <ongy> I should keep an eye on the subreddit then... I know most from here and "just using haskell"
07:33:11 <Cale> print what?
07:33:14 <Cooler> does it take arbitrary?
07:33:32 <Cooler> print 1:1:1:1:1:
07:33:37 <Cooler> etc
07:33:54 <wilornel> checking out the subreddit as well
07:33:54 <Cale> Cooler: It applies show and takes the first 76 characters, and sticks "..." on the end
07:34:04 <c_wraith> ongy: as with all subreddits, you need mental filtering to make it useful.  Even though it's way less required than most.
07:34:10 <Cooler> does fix f = f (f (f (f ( ...
07:34:13 <glguy> merijn: I don't know if you can
07:34:15 <Cale> Cooler: yes
07:34:27 <Cale> Cooler: another way we might try to define it is  fix f = f (fix f)
07:34:37 <Cale> That would be less efficient in this case though
07:34:50 <c_wraith> edwardk's comments in the discussion of the Burritos For the Hungry Mathematician paper were amazing.
07:34:54 <ongy> c_wraith: For some reason I never got into the reddit thing. I only ever visit that domain if linked to it
07:35:10 <Cale> With fix f = x where x = f x, since the result is bound to a variable, once it's evaluated, it remains in an evaluated state
07:35:21 <c_wraith> ongy: reddit in general is a terrifying mess.  But a few subreddits are ok.
07:35:39 <Cooler> > fix (1+)
07:35:44 <Younder> It all comes down to biggus dickus
07:35:45 <lambdabot>  mueval-core: Time limit exceeded
07:35:50 <Cale> So what ends up happening is that in memory, you end up with a *single* (:)-cell, with its tail pointed at itself
07:36:10 <merijn> glguy: Oh well, I'll improvise
07:36:17 <c_wraith> ongy: things like https://www.reddit.com/r/haskell/comments/3rh9tn/burritos_for_the_hungry_mathematician/cwp79zy/ make it worthwhile. :)
07:36:18 <Younder> Or as we like to refer to him in numbertheory Grothendiech
07:36:56 <wilornel> thanks everyone!! heading to bed. Have a good morning/day/lunch/evening/night/sleep !
07:36:59 <merijn> glguy: I can always optimise via random perturbation of the source ;)
07:37:00 <Cale> Cooler: 1 + undefined = undefined, so that's the fixed point you'll get
07:37:04 <c_wraith> Younder: I'm actually pretty comfortable relying on Haskell's type system to prevent dumb things, because any use of bottom values to circumvent proofs tends to also crash programs.  What I'm not comfortable doing is calling that rigorous math.
07:37:25 <wilornel> actually last thing is, what's the difference between divMod and quotRem?
07:37:26 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
07:37:29 <lambdabot>  3628800
07:37:32 <merijn> wilornel: The direction they round
07:37:35 <c_wraith> wilornel: their behavior on negative inputs
07:37:36 <Cale> wilornel: Sign convention
07:37:36 <Younder> wilornel, This is aan inspired discussion as I have ever seen here. Pleaso do come back!
07:37:41 <merijn> wilornel: One rounds towards 0, the other to negative infinity
07:37:54 <Cale> You almost always want divMod
07:38:03 <Cooler> Cale, which module has fix
07:38:04 <c_wraith> wilornel: quotRem corresponds to an x86 assembly instruction, so it should be faster if you *really* need it and know the inputs are positive. :)
07:38:21 <Cale> But quotRem is a bit faster, because it's what CPUs implement, because it's *slightly* cheaper in terms of the number of transistors required.
07:38:24 <c_wraith> @index fix
07:38:24 <lambdabot> Data.Function, Control.Monad.Fix
07:38:42 <wilornel> Younder: Oh! Please keep the discussion going. Show them why haskell can be used for logic. I believe it can. I'll check back later!
07:39:06 <c_wraith> Data.Function is such a sad module.  It has... 3 things in it?  Can those just be moved someplace more useful?
07:39:13 <Cooler> Cale, fix (1+) just goes into a infinite loop it doesn't give undefined
07:39:14 <wilornel> thanks tons Cale, c_wraith Younder, merijn 
07:39:16 <Younder> c_wraith, Nor should you. But with the right tool it can be made rigorous.
07:39:47 <Cale> Cooler: Well, by "undefined" I just mean any form of nontermination.
07:40:00 <Cooler> right
07:40:01 <Cale> Cooler: If you compile your program, you might actually get an exception
07:40:55 <c_wraith> Hmm.  Yeah, it seems like fix (+1) should get a "<<loop>>" if it's run compiled.  I think.
07:41:09 <Cale> (The way that expression evaluation is implemented is able to detect certain easy infinite loops, where in order to evaluate x, you must first evaluate x, and so you never make any progress)
07:41:13 <merijn> hmm, apparently the cost of pattern matching is roughly a handful of nanoseconds
07:42:19 <Cale> Ah, I think the distinction might just be threaded vs. non-threaded runtime
07:42:46 <Cale> In the threaded runtime, you get stuck in a grey hole rather than a black one. :)
07:43:00 <c_wraith> Cale: even the threaded runtime can find loops, during GC
07:43:04 <merijn> So, suppose I have a function "foo" and a small (like one extra case) around "foo", should I tell GHC to inline foo to minimise the overhead?
07:43:18 <Cale> yeah, though if you don't get to do any allocation...
07:44:00 <c_wraith> the idle GC can still run
07:44:12 <c_wraith> Unless you turned it off...
07:44:50 <c_wraith> Or unless there's some other thread that is neither idle nor allocating, I suppose. :)
07:44:54 <Cale> ah, yeah, it does find it with the threaded runtime here
07:45:01 <Cale> But not in ghci
07:45:14 <c_wraith> now add a thread that neither allocates nor is idle and try again. :)
07:45:30 <c_wraith> (blocking on a blackhole or greyhole counts as being idle)
07:46:22 <Cooler> i get an error saying show is applied to 3 arguments
07:46:23 <Cooler> main = do putStrLn $ show (fix (1+) :: Int)
07:46:26 <Cale> yeah, then it's dead
07:46:39 <Cale> Cooler: what's the next line?
07:46:48 <Cooler> return ()
07:46:57 <Cale> Cooler: How many spaces before return?
07:47:06 <merijn> Any heuristics to determine whether inlining some function is useful?
07:47:06 <ski> indented too much, presumably ?
07:47:07 <Cooler> its aligned with putStrLn
07:47:25 <Cooler> oh wait i am using tabs not spaces
07:47:26 <ski> any tabs ?
07:47:27 <Cale> Cooler: Do you have tab characters in your source?
07:47:28 <Cale> ah
07:47:31 <Cale> there you go :)
07:47:53 <Cale> Most editors have an option you can turn on to always expand tabs
07:48:01 <Cooler> yeah
07:48:15 <Cooler> Cale, compiling that its gone into a infinite loop
07:48:29 <Cooler> i mean running it after compiling
07:48:33 <ski> @src print
07:48:33 <lambdabot> print x = putStrLn (show x)
07:48:41 <Cale> Cooler: Interesting.
07:48:58 <Cale> Cooler: It should be using essentially no CPU, right?
07:49:48 <Cale> Cooler: Here I get  foo: <<loop>>  basically immediately.
07:49:59 <Cooler> Cale, actually no
07:50:01 <Cooler> test: <<loop>>
07:50:02 <Cooler> i get that
07:50:03 <Cale> right
07:50:30 <Cooler> something with running it from sublime
07:50:38 <Cooler> that goes into infinite loop
07:50:58 <Cale> Well, it's probably running ghci
07:51:17 <Cale> For whatever reason, ghci is not as good at detecting this loop.
07:51:38 <Cooler> so the compiler inserts a string in place of the code for the function?
07:51:45 <Cale> no
07:51:51 <Cale> This is detected at runtime
07:52:02 <Cale> It goes to evaluate fix (1+)
07:52:19 <ph88^> why is it if i move this code around it doesn't type check anymore?   https://bpaste.net/show/408d9e4b7955
07:52:25 <Cale> and when it evaluates x = 1+x
07:53:04 <Cale> when it starts evaluating x, the pointer to the code for it is overwritten with a pointer which points to a bit of code which will throw an exception if entered
07:54:13 <Cale> and then (+) pattern matches on its arguments, causing x to get evaluated during its own evaluation, and you get the exception
07:54:40 <Cooler> why can't ghci do that
07:55:03 <Cale> I don't honestly know. There are some fiddly things going on... with the threaded runtime, it's a little more complicated
07:55:07 <mutsig_> If I have a newtype that derives MonadRandom, how can I set (and/or get) the seed? Is it possible?
07:55:29 <Cale> In the threaded runtime, the "black hole" we replace that pointer with can't just throw an exception.
07:55:46 <Cale> Two different threads might start to evaluate a variable at the same time
07:56:47 <Cale> So, rather than a piece of code which throws an exception, the pointer is overwritten with a piece of code which waits for the thing to be evaluated (and which will throw an exception if this is the only thread which retains a reference to the variable)
07:57:20 <ski> ph88^ : try removing the binding for `snk' ?
07:57:34 <Cale> Perhaps ghci for whatever reason is retaining another reference to the thing in another thread.
07:57:47 <Cooler> livelock?
07:58:12 <Sornaensis> livelock is where threads are all doing work but none are making progress
07:58:14 <Cale> Well, it is a deadlock of sorts -- you'll notice that ghci is using 0% cpu
07:58:20 <lyxia> mutsig_: The MonadRandom type class does not have a notion of seed
07:58:27 <Cooler> right
07:58:38 <Cale> It just sits and waits for the thing to be evaluated, and it never is.
07:58:42 <ph88^> ski, what binding do you mean ?
07:58:44 <mutsig_> lyxia: Ok, thanks
07:59:00 <ski> ph88^ : the one mentioned at the very end of the error message
07:59:14 <Cale> (iirc, it adds the thread to a queue of threads to be woken up after it gets evaluated)
08:00:01 <Cooler> btw hsdev is taking up 500+ Mb of ram
08:00:04 <c_wraith> Younder: I don't think we disagree on any facts - just whether to call what you're describing "Doing math in Haskell". :)
08:00:06 <Cooler> is that normal?
08:00:25 <Cooler> i installed it via cabal install for emacs
08:00:33 <merijn> So, if I provide both a non-exception throwing and throwing API, what's a good module name for the throwing version? .Exception? .Throw? Other suggestions?
08:00:36 <Cale> I don't use hsdev, but it doesn't surprise me... depending on what it's loaded.
08:00:45 <Cooler> taking around 588 Mb
08:00:53 <ski> ph88^ : since `snk' isn't used (any longer), it doesn't know which `m' satisfying `MonadIO' to use for `snk'. and since it's a pattern binding with no explicit type signature, DMR strikes
08:00:55 <ph88^> ski, eh ye that was it .. but i though where was PER pattern match , it's not ?
08:01:50 <ski> (not sure what you mean by "PER pattern match")
08:02:33 <Unode> when using pattern matching, does the order of the clauses matter?
08:02:36 <Cooler> actually sublime haskell uses hsdev
08:02:48 <c_wraith> Unode: yes
08:02:49 <ski> Unode : yes, but only if you have overlapping defining equations
08:02:55 <Cale> Cooler: I use Sublime, but ended up just removing SublimeHaskell, since it flaked out too much on the large projects I work on for Obsidian.
08:03:14 <ph88^> ski, each line of handleInputOutput
08:03:30 <Unode> and does it stop on the first matching?
08:03:37 * ski still doesn't get it .. sorry
08:03:43 <c_wraith> Unode: they are (logically) tried top-down, left-to-right.  (the latter matters when there are multiple pattern matches on the first line)
08:03:48 <c_wraith> err, on the same line
08:04:10 <ski> Unode : yes (if there's guards, a guard need to succeed of course)
08:04:17 <c_wraith> Unode: if GHC can prove it doesn't change the meaning, it might re-order things, but the resulting code will always have the same semantics as top-down, left-to-right
08:04:28 <tsahyt> I'm implementing an algorithm that is given as imperative pseudo code and using State is pretty much the way to go. now I'm tempted to pull in lens just for this one algorithm. how bad of an idea is that?
08:04:45 <Cale> Cooler: heh, a single ghcid for this project's frontend takes 1.7G of memory... I usually have one for the frontend, one for the backend, and then ghci for the frontend and backend as well...
08:04:52 * ski often prefers to have non-overlapping cases, so that the cases can be understood in isolation
08:04:54 <tsahyt> in terms of dependencies I mean. stack is currently busy compiling 9 extra transitive dependencies for the project
08:05:15 <Cale> Cooler: It really does add up... I'm honestly not sure why it's quite *this* large.
08:05:21 <c_wraith> tsahyt: if you do that, you might as well use lens everywhere. :)
08:05:32 <Unode> ok then just to clarify things a bit more, if the first pattern is "func False False [s] = ..." and the function is first called with "func False False [...]" does this first clause always match first?
08:05:35 <tsahyt> hmm but mostly I don't want to use lens
08:06:02 <c_wraith> Unode: that last pattern is a tricky one.  it only matches exactly single-element lists
08:06:07 <tsahyt> it's just that here I have a record containing a bunch of structures (a stack, a queue, etc) as my state type
08:06:12 <ph88^> ski, i meant this https://bpaste.net/show/bc7d151d1966
08:06:18 <tsahyt> and pushing onto the stack would be really nice with lens
08:06:28 <tsahyt> using modify directly seems cumbersome in comparison
08:06:34 <tsahyt> it seems like this is exactly what lens is supposed to do
08:06:43 <Unode> there's 2 additional clauses, "func _ _ [] = []" and "func a b (s:ss)". The latter expands to a guard with 3 conditions.
08:06:54 <c_wraith> tsahyt: lens makes it trivial, yes.  especially with things like the (%=) operator
08:06:58 <Unode> c_wraith: I see
08:07:10 <tsahyt> I guess I could live with a more minimal lens library for this use case
08:07:14 <ph88^> ski, do you know how i can use exception handling on conduit ? i would like to write my own string to stderr in case the file can not be read or write   https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#g:7
08:07:23 <Younder> c_wraith, Well I was educated a physicist before I became a mathematician. Now I work with machine learning as well. Perhaps my rigors of proff are not as solid as yours.
08:07:25 <ski> ph88^ : oh, you're asking whether `where' attaches to a single defining equation, i think. the answer to that is yes
08:07:38 * ski doesn't know `conduit'
08:07:38 <tsahyt> c_wraith: it just feels like bad form to pull in lens for just one algorithm
08:08:12 <c_wraith> tsahyt: I've pulled in a library for a single algorithm before.  And if that library is vector-algorithms, it can take almost as long to compile as all the lens dependencies combined.  >_>
08:09:21 <tsahyt> how does that happen? last I checked, lens pulled in about 35 or so libraries when building it with stack on a clean install.
08:09:24 <c_wraith> Younder: I think we're not too far apart on that even.  I think I'd just call what you're describing "Doing math in Isabelle that results in Haskell code".
08:09:26 <Younder> c_wraith, We need to have a discussion on this at a later date I feel. Loved your input. It gave me lot of food for thought.
08:09:32 <tsahyt> now tbf, most of them are installed already anyway for any serious project
08:10:20 <ski> ph88^ : i might not match on the `Maybe'-arguments there in the defining equations definiendums, but rather say `src = case minput of Nothing -> CB.sourceHandle stdin; Just input -> CB.sourceFile input' (or use `maybe' if you prefer). and similarly with `snk'
08:10:26 <c_wraith> tsahyt: vector-algorithms inlines to an extent ghc has had problems with historically - there were several versions of ghc that failed to compile it because they didn't think any real code would do effectively exponential inlining the way that package does.
08:10:37 <ski> ph88^ : that factors out the code repetition
08:10:48 <tsahyt> exponential inlining sounds.. interesting
08:11:25 <ph88^> ski, oh ye that's a good idea
08:11:50 <c_wraith> tsahyt: it uses CPP to create inlined expressions.  In some cases, uses of that CPP are nested.
08:12:05 <tsahyt> okay I suppose I can live with a very basic lens package here. all I really need is over. tying in with State is optional. what are my options now? Ideally I'd like it to be compatible with the full lens library
08:12:18 <c_wraith> lens-family and microlens come to mind
08:12:34 <c_wraith> I haven't used either, so I don't have a preference. :)
08:13:08 <tsahyt> microlens looks interesting since it's split up in a bunch of packages
08:13:43 <c_wraith> microlens should give you everything except batteries-included and prisms, iirc
08:14:11 <tsahyt> is there a way to list all transitive dependencies of a package?
08:14:38 <c_wraith> well, cabal install --dry-run
08:14:49 <c_wraith> add a -v if needed
08:15:30 <tsahyt> but that only lists the packages that aren't already installed
08:15:48 <c_wraith> I know it lists all dependencies if you add enough verbose flags :)
08:15:52 <sproingie> ever sit down at your computer and briefly forget completely how to use it?
08:16:00 <c_wraith> sproingie: about once a week
08:16:14 <sproingie> sign of getting old i guess ;p
08:16:38 <c_wraith> sproingie: sometimes I just stare at my login screen with no idea what I'm supposed to be doing.
08:17:17 <tsahyt> basic-lens would provide all the machinery I actually need
08:17:22 <tsahyt> but no TH wizardry
08:17:32 <tsahyt> and it's fully compatible with lens
08:18:37 <tsahyt> I guess I'll just pull in lens and stop worrying. minimal dependency footprint is not exactly a common trait in haskell libraries to begin with
08:18:53 <orion> tsahyt: What [29~
08:18:57 <orion> sproingie: How old are you?
08:18:58 <sproingie> haskell ain't exactly "batteries included", no
08:19:04 <sproingie> orion: 44
08:19:34 <tsahyt> sproingie: actually base contains a lot of stuff. but it can't keep up with the pace at which the ecosystem expands/develops
08:19:45 <shapr> sproingie: ooh, one year younger than me!
08:19:45 <tsahyt> I mean there's even a module for parser combinators in base
08:19:56 <c_wraith> tsahyt: lens's dependencies are mostly because of the profunctor package, and edwardk's refusal to rely on orphan instances.  Which is, I think, a perfectly fine policy.  But it means profunctor needs to depend on crazy amounts of things.
08:20:13 <sproingie> it has a lot of low-level stuff, not a lot of practical libraries for, say, http or crypto or such
08:20:23 <Cale> tsahyt: Well, people have also been trying to get stuff *out* of base for a long time
08:20:33 <tsahyt> c_wraith: I thought the dependencies would be because lens itself for some reason takes the batteries included approach, providing lenses for most common data structures
08:20:51 <sproingie> but i guess lens or equivalent would be one of those lower-level things.  i'm all for a reasonably minimal base too.
08:21:28 <tsahyt> I generally have no problem with big dependency trees. it's just that this leads to unreasonable binary sizes in some cases
08:21:29 <sproingie> base should provide a rich set of common type classes, really
08:21:30 <c_wraith> tsahyt: yes, but that's not near 35 dependencies by itself.
08:21:39 <athan> Can anyone here suggest a good method to debugging STM thread blocking errors?
08:21:56 <ph88^> anyone know how i can get my conduit exception handler to work ?   https://bpaste.net/show/73ee15357694
08:22:09 <tsahyt> e.g. my pretty minimal gtk based haddock viewer/hoogle search compiles to ~55M of executable code
08:22:17 <tsahyt> with standard flags that is of course
08:22:33 <c_wraith> sproingie: Yeah, I think most people would agree Profunctor as a class probably should be in base, but no one wants to add it before a couple final design choices around supporting functions are worked out.  Once it's in base, it's hard to revise them.
08:23:27 <sproingie> i dunno, profunctors have a pretty solid definition.  the API might not be the best tho (wouldn't know, i have no idea what i'd use Profunctor for)
08:23:30 <Cooler> this is messed up
08:23:45 <c_wraith> sproingie: I think you just agreed with me. :)
08:23:49 <Cooler> hsdev is taking up 900+ Mb and i don't even have a .hs file open
08:23:53 <sproingie> oh *should*.  yeah reading comprehension before my first cuppa
08:24:50 <Cooler> i might have to uninstall sublime haskell
08:25:02 <merijn> How do I get Haddock to render kind signatures on datatypes?
08:25:11 <Cooler> its over 1160 Mb now without a single haskell file open
08:25:14 <sproingie> a profunctor is a functor paired with its own opposite, right?
08:25:35 <c_wraith> sproingie: well.  It's a functor paired with a contrafunctor
08:25:49 <merijn> I have "newtype Foo (x :: Bar) a = ..." as a definition, but the Haddock documentation doesn't list the kind of the 'd' parameter of Foo
08:25:50 <c_wraith> sproingie: in some sense, it's a generalization of things that work sort of like functions.
08:25:59 <ski> "paired"
08:26:15 <c_wraith> sproingie: in that you can modify their "input" and "output"
08:26:16 <Unode> The full pattern I'm trying to understand: http://lpaste.net/355588 . c_wraith that first pattern is making me super confused. Would it really only match on the last element of the list?
08:26:51 <c_wraith> Unode: that pattern is a special case for when both the Bools are False and the list has exactly one element
08:27:08 <sproingie> c_wraith: so it has both fmap and contramap?
08:27:13 <c_wraith> Unode: if any of those three arguments are something else, it falls through to the other patterns, which cover all other cases.
08:27:22 <c_wraith> sproingie: on different type variables.
08:27:40 <c_wraith> sproingie: thought it calls them rmap and lmap :)
08:27:43 <c_wraith> *though
08:28:46 <tsahyt> is there a named synonym for %=?
08:28:47 <c_wraith> sproingie: rmap is the same as fmap for any type that's an instance of both Functor and Profunctor
08:28:49 <sproingie> all these different names for the same thing ... map fmap . >>> 
08:29:03 <sproingie> is it all about clearer error messages these days?
08:29:38 <ski> also about specificity of code, possibly
08:29:38 <Younder> yes, they are better
08:29:52 <c_wraith> sproingie: in this case, no.  It's because you can't make rmap and fmap fit together.
08:30:12 <torstein> Network.listen takes an Int argument for the maximum number of queued connections. What does that mean, practically, e.g. for a chat server (https://wiki.haskell.org/Implement_a_chat_server)? That only two chat clients can be connected at the same time?
08:30:14 <c_wraith> sproingie: you can't make Functor a superclass of Profunctor because they have different kinds
08:30:47 <c_wraith> torstein: no, it's the length of the accept queue - how many connections can be in the accept phase.
08:30:53 <sproingie> makes sense for profunctor, sure
08:31:15 <sproingie> but my eyes really opened when i learned how map, fmap, function composition, and lift were all the same thing
08:31:25 <Unode> c_wraith: so if I get it correctly, if a line evaluates "isFirstInPair = False, isSecondInPair = False" and is not the last on the list, this line is not kept anywhere right? i.e. "func False False ["one","two"]" would not match the first rule.
08:31:32 <c_wraith> torstein: It's rare to need it more than about 5 or so.  If it needs to be higher than that, you're under some serious load - or not accepting incoming connections rapidly.
08:31:44 <orion> Microlens doesn't include the (<>=) operator :(
08:31:50 <tolt> Does anyone know what "A simple interface for streaming eventlog data from live processes" is from the most recent ghc rc? I'm not able to find any docs on it
08:31:59 <phadej> orion: that's why they are microlens!
08:32:07 <torstein> okay thank you
08:32:24 <Younder> When I was beginning I really hated lift. It seemed like a con. I guess it still does
08:32:48 <c_wraith> Younder: you mean liftM?
08:33:01 <Younder> Like a card player cheeting at a card game
08:33:16 <Younder> c_wraith, yes
08:33:28 <sproingie> er yes liftM
08:33:34 <c_wraith> Unode: I'm not sure what you mean by "kept".  But it's certainly true that it won't match the first rule.
08:33:42 <sproingie> :t lift
08:33:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
08:33:47 <phadej> c_wraith: you could require 'profunctorFunctor :: Dict (Functor (p a))` member though
08:33:48 <c_wraith> liftM is definitely historical baggage.
08:33:55 <phadej> c_wraith: but it's not nice to work with
08:34:00 <Cale> torstein: That number is the number of connections which can be waiting to be accepted. Since you usually accept connections by immediately forking a thread that will handle them and getting back to accept again, usually you won't have much of a backlog to work through.
08:34:18 <sproingie> monad transformers have changed a lot since i last read A Gentle Intro
08:35:10 <c_wraith> at least there's no liftA?
08:35:18 <c_wraith> Things didn't go *that* wrong. :)
08:35:28 <Cale> there... should be
08:35:31 <sproingie> :t liftA
08:35:32 <lambdabot> Applicative f => (a -> b) -> f a -> f b
08:35:39 <c_wraith> Oh, great.  there is.  *sigh*
08:35:46 <Cale> Why is that wrong?
08:35:53 <Cale> It implements fmap in terms of (<*>) and pure
08:35:54 <c_wraith> Applicative always depended on Functor!  It doesn't need an extra operation.
08:36:03 <Cale> It's so that you can write
08:36:06 <Cale> fmap = liftA
08:36:11 <Younder> spoingie: you are selling yourself short. We all felt like this at first
08:36:24 <Cale> after having written your Applicative instance
08:36:25 <c_wraith> Then it should be named fmapDefault or something, like the equivalent in Traversable is
08:36:31 <Unode> c_wraith: as part of the guards in the third pattern, I understand that if isFirstInPair or isSecondInPair evaluates to True they are prepended to a list "(1 :: Int, concatLine s): ...". i.e. kept. In the case I mentioned s doesn't seem to be 'kept' anywhere.
08:36:40 <sproingie> it didn't always depend on Functor, did it?  or was that just Monad with the barren set of supertypes?
08:36:56 <c_wraith> sproingie: it was just Monad
08:37:04 <Cale> Also, it would be weird to have liftA2, liftA3, etc. but not that
08:37:51 <merijn> Does anyone know how I beat Haddock into displaying kind signatures on a datatype?
08:37:52 <sproingie> i never did get used to writing Applicative style, i dropped straight into monads
08:37:59 <erisco> really it should have been called liftA1 for consistency
08:38:15 <erisco> sproingie, come back!
08:38:26 <Cale> sproingie: A good number of people learned to program with monads before Applicative existed.
08:38:27 * sproingie >>= return
08:38:50 <erisco> monads lead you to the dark side
08:39:28 <shapr> The dark side leads to dissatisfaction with Python :-/
08:39:37 <sproingie> yah i'm just re-learning what i forgot now, and everything's different.  all the buzz is around Free Monads now :)
08:39:37 <c_wraith> Unode: oh, that's what you meant by kept.  Then yeah, when those three things are true, it just calls through to a recursive call to func without producing any output
08:39:50 <Cale> There aren't really all that many Applicative instances which are not also Monad instances in practice.
08:39:55 <shapr> sproingie: I'm having some of that myself, applicatives and lens and so many cool toys!
08:39:56 <c_wraith> sproingie: actually, we're in the backlash phase around free monads.  "they're too slow!" :)
08:40:21 <sproingie> slow is not a problem for me, i don't care if my haskell runs as slow as bash frankly
08:40:26 <phadej> Cale: there are, e.g.`optparse-aapplicative`
08:40:26 <Cale> I don't understand the recent wave of buzz about free monads
08:40:29 <sproingie> (well i will if i ever get around to that roguelike)
08:40:33 <Cale> Where did that come from?
08:40:43 <phadej> Cale: "Applicative which isn't a Monad"
08:40:56 <Cale> phadej: I know there are a handful of examples
08:41:57 <sproingie> my issue with lens and such is the punctuation-heavy operators
08:41:57 <phadej> and e.g. Const :)
08:42:06 <sproingie> which now that it's a stable set of operators isn't such a big deal
08:42:25 <Cale> I think it's totally okay if you see foo <*> bar and read it as do f <- foo; v <- bar; return (f v) in your head, for the most part.
08:42:42 <erisco> yeah but what a shame
08:42:55 <c_wraith> sproingie: there are patterns to the operators.  Learn the patterns and you reduce it to only like 6 cases, instead of 100. :)
08:43:03 <shapr> I just read it as "foo <*> bar"
08:43:05 <c_wraith> 6 is still a lot!
08:43:51 <Cale> I like most of what lens does, but I find most of those operators to be frivolous and silly
08:44:07 <Cale> I much prefer the ordinary function names for lens' stuff
08:44:28 <c_wraith> They introduce so many parenthesis, though..
08:44:41 <sproingie> i wish haskell just required whitespace between identifiers so it were possible to mix alpha and punctuation in operators
08:45:01 <Cale> c_wraith: you can still use (.) and ($) as usual to avoid most of the parens
08:46:02 <Cale> Being able to use kebab-case would be nice.
08:46:24 <c_wraith> think of all the lens tutorials that would break if you had to put a space on both sides of .
08:46:24 <Rembane> sproingie: Write a preprocessor. :D
08:46:36 <Cooler> are record updates not compositional? i thought they were https://youtu.be/cefnmjtAolY?t=187
08:46:45 <Cale> c_wraith: I enforce that rule anyway. I wish the lens tutorials would too.
08:46:56 <Cooler> you can just compose a bunch of getter functions right?
08:47:00 <c_wraith> Cale: I agree, actually
08:47:02 <Cale> Not putting spaces around (.) looks awful
08:47:06 <c_wraith> Cooler: yes, but you can't compose updates
08:47:16 <Cooler> what
08:47:28 <slack1256> I like lens with view/over/set/preview over the operators too
08:47:33 <Rembane> Cooler: That's one of the warts with that syntax and why people use lenses.
08:47:49 <c_wraith> Cooler: you can compose record accessors when you are using them as functions to get a value.
08:48:00 <c_wraith> Cooler: you can't compose them when you are using them to update a value.
08:48:07 <shapr> New #haskell band named ContraFunk?
08:48:24 <Cale> shapr: Felonious Thunk
08:48:27 <sproingie> ProFunky
08:48:27 <shapr> oooh
08:48:38 <shapr> Clearly this needs a lambdabot plugin.
08:48:41 <shapr> Best #haskell band names
08:49:21 <slack1256> "the simons" would work
08:49:32 <sproingie> as for python ... yeah, when i go back to python, i end up wanting to implement most of Prelude in it
08:49:38 <shapr> yeah, me too
08:49:51 <shapr> I end up rewriting scan and others about once every six months.
08:50:01 <shapr> and coworkers often say "what the heck is that?"
08:50:02 <sproingie> there's operator overloading magic that makes it not even that unpleasant
08:50:07 <orion> "Data families are the indexed form of data and newtype definitions." -- What does 'indexed' mean?
08:50:09 <sproingie> if baffling to cow orkers, yes
08:50:20 <c_wraith> I keep wanting to introduce traverse_ and traverse in Ruby projects at work.  My coworkers would be fine with those, right?
08:50:26 <shapr> suuure
08:50:34 <Cale> shapr: when they ask, link them to this http://cale.hn.org/share/Folds.svg
08:50:39 <Cale> shapr: ;)
08:50:45 <c_wraith> orion: it means that the implementation is selected by a type variable
08:51:05 <orion> I see.
08:51:10 <sproingie> i've seen several C++ Monad implementations that overload >> for bind (has better precedence and associativity than >>=)
08:51:17 <c_wraith> orion: that type variable (or those variables) is (are) called the index
08:51:21 <ski> (type parameter)
08:52:06 <Cale> sproingie: How many have you seen implement the abstraction correctly?
08:52:39 <sproingie> Cale: i did see one with a test suite that verified monad laws for some of the examples
08:52:53 <merijn> hvr: Can I kick off a matrix build for a package candidate somehow?
08:52:59 <Cale> I've seen a lot more incorrect implementations of Monad in other languages for which one couldn't write a generically usable sequence function than I have seen correct ones.
08:53:13 <Cale> If you can't write code which works in an arbitrary monad, you have failed.
08:53:49 <sproingie> once concepts land in mainstream c++, they're looking to add the standard types like Monoid etc to the stdlib
08:53:55 <Cooler> T1{get0::Int} ; T2{get1::T1} ; T3{get2::T2} ; T4 {get3::T3} ; get_foo = get3 . get2 . get1 . get0 ; get_bar = get2 . get1 . get0 ; get_bar record
08:53:58 <c_wraith> Cale: there's *some* value in recognizing that there's a common pattern that you're using.  But it's pretty small in comparison to the value of being able to abstract.
08:54:08 <sproingie> Functor is gonna confuse folks tho, given STL bastardized the term already
08:54:10 <Cooler> actually how do you update deep inside records?
08:54:25 <c_wraith> sproingie: I'm sure they'll just call it Mappable or something
08:54:29 <Cooler> do you have to unwrap everything and wrap it up again/
08:54:39 <Cooler> unwrap all the levels down
08:54:44 <lyxia> basically yes
08:54:47 <c_wraith> Cooler: r1{f1 = r2 {f2 = ..}}
08:54:51 <Cale> Cooler: yeah, without lens, or defining your own mapping functions
08:55:41 <shapr> Cale: my employer blocks that domain :-(
08:55:47 <Cooler> that seems horrible
08:56:04 <c_wraith> Cooler: now you know why there are at least 20 libraries on hackage for improving the situation :)
08:56:13 <Cale> shapr: ah, it's just my desktop machine
08:56:47 <Rembane> Cale: I love the curly ones, like scanl1. 
08:57:03 <Cale> http://i.imgur.com/3BIzhfH.png
08:57:13 <Cale> shapr: ^^
08:57:32 <shapr> Cale: ah nice!
08:58:28 <EvanR> Cooler: simple lenses make that really nice, and make other things really nice in the process
08:58:50 <EvanR> but because records sort of suck, you have to make them all yourself or generate them with TH
08:58:52 <Rembane> Is there a lenses for dummies tutorial somewhere?
08:59:08 * hackage websockets-simple 0.0.6.1 - Simpler interface to the websockets api  https://hackage.haskell.org/package/websockets-simple-0.0.6.1 (athanclark)
08:59:16 <sproingie> lens has a pretty good tutorial
08:59:33 <EvanR> and then theres lens
09:00:22 <fresheyeball> Anyone around who knows about the gloss package?
09:00:38 <Rembane> fresheyeball: It's nice, is it acting up?
09:00:51 <fresheyeball> Rembane: scaling an image looks unaliased
09:00:57 <fresheyeball> err
09:01:28 <sproingie> was thinking of using gloss for the roguelike but the font rendering looks awful
09:01:31 <Rembane> fresheyeball: Do you have a minimal example to show us? Codewise and imagewise.
09:01:38 <fresheyeball> un-anti-aliased
09:01:48 <sproingie> aliased :)
09:01:53 <fresheyeball> sproingie: right I have hte same problem
09:01:58 <Rembane> Everything is Nyquist's fault! 
09:01:59 <fresheyeball> the*
09:02:21 <sproingie> fresheyeball: i'm likely going with SDL instead
09:02:54 <c_wraith> sproingie: if it's terminal-only, everyone gets to choose their own font! :P
09:03:14 <fresheyeball> sproingie: what raw SDL?
09:03:27 <sproingie> SDL2.  very nice complete bindings.
09:03:37 <EvanR> sproingie: "font" is being pretty generous here
09:03:38 * hackage haskell-tools-demo 0.7.0.2 - A web-based demo for Haskell-tools Refactor.  https://hackage.haskell.org/package/haskell-tools-demo-0.7.0.2 (lazac)
09:03:51 <EvanR> its just simple lines forming vaguely correct letter shapes
09:04:13 <fresheyeball> sproingie: it looks excessively low level
09:04:34 <sproingie> fresheyeball: yeah my first challenge would be to slap a decent API on top of it
09:04:56 <fresheyeball> sproingie: go for it, I picked gloss to avoid re-inventing wheels
09:05:00 <EvanR> fresheyeball: are you asking for references on game engines or something?
09:05:03 <bodisiw> sproingie, do you have a suggestion for basic SDL2 'hello world'?  with stack maybe?
09:05:16 <sproingie> probably something imperative like tcod/bearlibterm/rotjs then try to make it more functional, steal ideas from lambdahack or soemthing
09:05:22 <EvanR> gloss is for simple graphics fast
09:05:38 <EvanR> its fast, but perhaps too simple for a real application
09:06:17 <fresheyeball> EvanR: you have a better direction that doesn't involve writing my own bindings, or working with OpenGL in a low level way?
09:06:38 <EvanR> there are a billion game engines, people like writing those more than actual games
09:06:42 <sproingie> bodisiw: grab the source for SDL2, should build effortlessly, and there's lots of example code including hello world
09:07:04 <fresheyeball> EvanR: Any good ones? I don't want to write and engine, I want to write a game.
09:07:07 <bodisiw> okay, i'll try again... i have not had good luck, or possibly i am dumb :-)
09:07:26 <fresheyeball> For what I've seen its mostly incomplete, immature code, of people reinventing wheels with no direction.
09:07:35 <EvanR> well yeah
09:07:39 <sproingie> i don't really *want* to write YA game engine either, but existing options are few.  there's a lot in lambdahack, but it's huge.
09:07:53 <EvanR> huge?
09:08:23 <sproingie> as in has tons of various features and backends
09:08:47 <sproingie> i'd rather reinvent wheels when i have to learn how they roll anyway
09:09:53 <sproingie> bodisiw: could be platform-related if it doesn't build cleanly.  i know it does well on linux and macos
09:10:48 <bodisiw> i'm on macos here, but possibly messed up environment with too much installs
09:10:53 <sproingie> also have to have SDL2 installed of course.  i used homebrew.
09:11:06 <bodisiw> yeah, i got it through homebrew
09:11:12 <bodisiw> works great from python
09:12:15 <EvanR> sproingie: and so the perpetuation of engines continues
09:12:19 <sproingie> oh sdl2_ttf might not build cleanly, i had to set INCLUDE_PATH and LIBRARY_PATH before building.  mostly because i didn't know how to fix the cabal file myself.
09:12:39 <EvanR> the work is 90% game engine and 90% actual game
09:12:50 <bodisiw> aha, iirc i was struggling with sdl2_image and sdl2_ttf
09:13:06 <fresheyeball> grr I just want to write game
09:13:11 <sproingie> yeah sdl2 knows to look in /usr/local, sdl2_ttf for some reason does not
09:13:17 <fresheyeball> and so I need to write an engine first
09:13:19 <bodisiw> use puzzlescript and make your game
09:13:26 <bodisiw> then you can build the engine you want for it
09:13:26 <fresheyeball> and now I need to write a graphics library first?
09:13:40 <sproingie> actually you should write a game then extract an engine from that
09:13:41 <EvanR> fresheyeball: what did you think of helm
09:14:05 <erisco> to make a game you have to give it 180%
09:15:02 <sproingie> erisco: and get paid for 100%.  certainly seems to be EA's work ethic.
09:15:05 <fresheyeball> EvanR: Helm looks nice
09:15:12 <fresheyeball> but it doesn't get many updates
09:15:17 <erisco> @remember sproingie i'd rather reinvent wheels when i have to learn how they roll anyway
09:15:17 <lambdabot> It is forever etched in my memory.
09:15:49 <EvanR> it has to be not big, be getting "updates", be feature packed,...
09:15:55 <EvanR> ok
09:16:27 <EvanR> the best libraries dont get updates, because theyre done
09:17:37 <EvanR> i will now go back to my game, which doesnt have an engine
09:17:49 * EvanR cackles maniacally
09:17:59 <sproingie> "done" to me means someone wrote a game in it beyond flappy bird
09:18:14 <erisco> it is a pushcart ;)
09:18:18 <EvanR> well thats not going to be a thing any time soon in haskell
09:18:58 <erisco> all framework and no engine
09:19:29 <sproingie> all hat no cattle
09:20:07 <EvanR> a DSL which lets you do the basic things a game needs but doesnt provide anything recognizable as an engine might be more haskell like
09:20:14 <erisco> I suspect that's not a percussion joke
09:20:18 <sproingie> yeah a DSL is kinda what i'm going for
09:20:35 <EvanR> and so far FRP is not that
09:22:05 <erisco> well, if you simplify the description of FRP as "computing with time" then it doesn't make much sense to expect that much specialisation from it
09:22:20 <erisco> it'd be like expecting functions and ADTs to be your engine
09:22:20 <EvanR> i mean the lack of engine 
09:22:34 <bodisiw> `stack run` gives me a 'Executable named lazyfoo-lesson-01 not found on path: ...'
09:22:55 <bodisiw> (in this SDL2 repo)
09:23:12 <sproingie> never cared too much for the emphasis on "time" in FRP.  it's really just an ordering, time is one means of imposing it
09:23:18 <sproingie> but event sourcing doesn't care much about "time"
09:23:35 <EvanR> smooth animations are really about time
09:23:40 <EvanR> not time tick events
09:23:50 <sproingie> sure, but FRP has gone well beyond animation now
09:24:03 <EvanR> and we still dont have what im talking about
09:24:11 <EvanR> so it seems to have missed the mark
09:24:25 <sproingie> that's the world of programming for ya
09:24:38 <erisco> it can be real time, but it has been known you can use other sources
09:24:39 <EvanR> beyond would mean, you actually can still do the simple stuff
09:25:50 <EvanR> not, decided on a totally different thing to do
09:26:54 <EvanR> zeno's paradox proved that time is not an event
09:27:25 <sproingie> it also proved zeno didn't know math.  or knew enough to baffle the masses with a silly trick.
09:28:09 <sproingie> i've been off doing web apps, so when i think FRP, i think rxjs/redux.  those were game changers for web apps.
09:28:19 <EvanR> oh god
09:28:27 <LKoen> yes, convergent series are silly
09:28:38 <sproingie> ok redux hardly counts, that largely just gives you persistence
09:28:45 <sproingie> but rxjs is quite nice
09:28:51 <LKoen> my indian friend calls them "convergent sillies"
09:28:56 <erisco> EvanR, I don't see how that is a proof that "time is not an event"
09:29:06 <erisco> do you mean that time is not discrete? because I don't see that either
09:29:07 <EvanR> its like the set of all sets isnt a set
09:29:33 <sproingie> it isn't?  i thought it was the set of sets not containing themselves
09:29:38 <EvanR> its not
09:29:43 <EvanR> neither is that one
09:30:14 <sproingie> the former's a category, the latter is just illogical, right?
09:30:47 <EvanR> a set of all sets is illogical too
09:31:52 <bodisiw> this conversation reminds me of the 'i see what you mean' peter alvaro's talk at strange loop
09:32:17 <EvanR> but hey this is haskell, and we are programming in an inconsistent logic
09:32:25 <EvanR> so sail on
09:32:49 <sproingie> eh fast and loose reasoning ...
09:33:04 <sproingie> pay no attention to the bottom behind the curtain
09:34:45 <WhereIsMySpoon> Hey, is there a more generic way to enumerate the conditions for this function: https://gist.github.com/anonymous/5d547790984af97fb8932ad43fa87c36 like if I wanted to do myThirdLast…etc, how do I say “anything less than this number of elements in the list is wrong”
09:35:58 <erisco> how do you show Haskell is inconsistent?
09:36:17 <monochrom> By re-defining "inconsistent".
09:36:19 <c_wraith> :t undefined -- erisco
09:36:20 <lambdabot> a
09:36:32 <torstein> Anyone familiar with intero on Emacs? When I select intero as flycheck-checker I don't get HLint warnings (but i do if i select haskell-hlint)
09:36:41 <EvanR> construct a value of a type that has no values
09:36:54 <monochrom> Like, if a program aborts or non-terminates, then you call it inconsistent.
09:37:13 <lyxia> WhereIsMySpoon: reverse then drop (thisNumber - 1)
09:37:15 <erisco> right, I suppose so
09:37:27 <EvanR> you could put a Data.Set inside itself ;)
09:37:28 <monochrom> As opposed to noticing that it still satisfies the safety property and so you should be calling it consistent.
09:37:47 <WhereIsMySpoon> lyxia: sorry, what?
09:37:56 <WhereIsMySpoon> im very nooby atm, so sorry
09:38:08 <erisco> well it is weird that bottom is a member of all types yet should we use it to prove a type we've demonstrated inconsistency
09:38:21 <EvanR> the inconsistent comes from using curry howard isomorphism to recast parts of haskell as logical connectives
09:38:29 <monochrom> Therefore don't prove a type at all.
09:38:37 <lyxia> WhereIsMySpoon: If you want to access the n-th element starting from the end of a list, you reverse it, then you access the n-th element from the beginning of the reversed list.
09:38:41 <EvanR> which you apparently shouldnt be doing
09:38:49 <c_wraith> erisco, taken advantage of inconsistency, in that case. inconsistent logics have advantages. 
09:39:44 <EvanR> erisco: example practical issue... the law (fst x, snd x) = x doesnt work in the presence of bottom, in haskell. (from the fast and loose reasoning paper)
09:40:06 <WhereIsMySpoon> lyxia: oh, duh
09:40:09 <EvanR> its illogical!
09:40:31 <sproingie> i always treat lists as either streams or sets, i never find myself having to access the nth element
09:40:32 <monochrom> Curry-Howard is really nice for total languages.
09:40:48 <erisco> I don't know what the correspondence is precisely for Haskell
09:40:56 <WhereIsMySpoon> sproingie: im doing exercises :)
09:40:58 <erisco> seems awkward
09:41:21 <sproingie> WhereIsMySpoon: ah.  i guess it's good to know how to do in case one runs across it
09:41:22 <lyxia> WhereIsMySpoon: in the bit of code you pasted, if you don't care about the error message too much you can drop the second case
09:41:46 <stphrolland> Hi. I have a question regarding FFI. I have read on stackoverflow that it should be used in last resort for performance critical code. Sometimes ago I made a draft of the stuff I plan to do (myriads of musical oscilators) in python, and that part was clearly a bottleneck, which completely disappeared when I wrote it in c++. I'm going to do something much more evolved wrapper in Haskell, that shoudl call that c++ core. 
09:41:47 <WhereIsMySpoon> sproingie: well im just trying to learn how to solve issues by writing haskell atm
09:42:07 <stphrolland> Do you really advise against FFI ?
09:42:16 <lyxia> WhereIsMySpoon: and then if you want to access the third-to-last element, you can change the [x,y] case to [x,_,_]
09:42:39 <sproingie> stphrolland: it's not so much that it's advised against, it's just that it's massively tricky and of course it's unsafe
09:43:05 <sproingie> stphrolland: but for something like realtime synthesis, you might have to reach for the FFI, yes
09:43:16 <EvanR> FFI can be a performance bottleneck 
09:43:27 <EvanR> if you need to make a lot of calls
09:43:35 <sproingie> yeah the boundaries of FFI are notoriously slow.  in most languages, really.
09:43:55 <stphrolland> there's a mutex or something like that when a call to the FFI is done ?
09:44:14 <sproingie> i don't believe so
09:44:19 <EvanR> theres a lot of stuff going on, especially if the foreign code may call *back* sometime
09:44:36 <EvanR> you can configure the ffi boundary to tweak it though
09:44:41 <stphrolland> what's the reason more or less that several FFI calls might be troublesome ?
09:44:42 <erisco> you want to batch when doing FFI calls
09:44:56 <sproingie> it's not like python with the GIL.  tho python tends to call into C precisely so that code *can* release the GIL
09:45:41 <erisco> first you have a lack of inlining and optimisation
09:45:49 <erisco> second you have the overhead of marshalling
09:46:00 <sproingie> if you just want to twiddle with oscillators, i believe there's supercollider bindings for haskell
09:46:14 <sproingie> SC's protocol is kinda bleh, but it does do the job
09:46:17 <stphrolland> Even if I use bytestring to comunicate between the two, there is marshalling ?
09:46:30 <erisco> concurrency, parallelism, garbage collection... these are just more pains
09:46:48 <EvanR> stphrolland: ByteString data is pinned, so you can pass a pointer to that data directly
09:47:23 <EvanR> but a pointer
09:47:33 <EvanR> is boxed, and you have to unbox it when you poke it
09:47:49 <EvanR> but there is more going on during an FFI call
09:48:06 <WhereIsMySpoon> lyxia: im sorry, im lost. How in the function do I reference the list and reverse it?
09:48:58 <WhereIsMySpoon> or anyone else lol
09:49:00 <EvanR> stphrolland: a possibly aging blurb about this in the wiki https://wiki.haskell.org/Performance/FFI
09:49:20 <sproingie> you can pack C structs into a bytestring, so you don't have to bang raw bits into them
09:49:35 <sproingie> can't recall what the package that does that is called
09:49:52 <fresheyeball> Ok so Helm is totally unmaintained
09:50:10 <EvanR> hmm.
09:53:24 <lyxia> WhereIsMySpoon: http://lpaste.net/355594
09:53:41 <stphrolland> sproingie: I think the module for marshalling structs you were talking about is import Foreign.Storable . It's documentation looks like that.
09:53:48 <sproingie> i looked around for haskell game engines, there's not much maintained.  for roguelikes, lambdahack was about it.
09:54:21 <sproingie> stphrolland: i could swear i saw something different, but my memory is pretty bad
09:54:34 <stphrolland> i will search for others, maybe there are some better packages
09:54:43 <colo> has someone had troubles compiling after the recent windows 10 update?
09:55:49 <cocreature> colo: there are new ghc binaries available that fix the issues
09:55:52 <cocreature> it’s a known issue
09:57:04 <colo> thanks
09:57:43 <sproingie> bah.  stack is not very robust about stale lockfiles
09:57:52 <sproingie> created part of a project and failed to create stack.yaml.  bad stack.
09:58:36 <jgt> hey folks, anyone know how to get all records in a table with persistent?
09:59:03 <bodisiw> sproingie, i had to `stack build --flag sdl2:examples`, but now i can run them!
10:01:13 <sproingie> bodisiw: quick way to run them is 'stack run example-foo-99' or whatever.  grep for '^exe' in the .cabal file
10:01:23 <sproingie> pretty sure that'll even force them to build
10:01:35 <jgt> oh, I think I got it. This seems to work: `users <- runDB $ selectList ([] :: [Filter User]) []`
10:04:17 <bodisiw> sproingie, well that didn't work for me for some reason, although now it does... at first `stack run` tried to run them without building them
10:05:17 <sproingie> tch.  yeah, stack is still pretty rough.
10:05:38 <bodisiw> next i'll have to figure out how to make a new project and use this library as a dependency... would i still want to use the git repo, or do i want to pull in from hoogle/stackage/whatever
10:05:44 <sproingie> i wish adding deps were as easy as npm or carton
10:06:04 <zachk> how easy is adding deps in npm or carton?
10:06:36 <bodisiw> npm is pretty easy
10:07:07 <bodisiw> except when some guy unpublishes his packages
10:07:19 <sproingie> npm add leftpad
10:08:20 <sproingie> i guess carton is about the same as cabal that way, you edit cpanfile
10:08:21 <jgt> fwiw, I've been pretty happy with Stack
10:08:33 <sproingie> oh i love stack, it's just still a little wobbly in places
10:09:05 <jgt> do we have issues filed for the wobbly bits?
10:09:18 <sproingie> probably
10:09:30 <jgt> (I know I'm coming across as adversarial here, and I don't mean to be)
10:09:54 <jgt> I should probably dig into Stack's issues list when I get some time
10:10:09 <bodisiw> jgt, tbh i'm too new to have much expectations of Stack
10:10:33 <bodisiw> other than people saying 'it just works' (which has not _quite_ born out in my limited experience)
10:10:45 <sproingie> naw, you don't come across as too argumentative.  i'm just a born whiner :-/
10:11:11 <jgt> bodisiw: it certainly 'just works' more than cabal did, in my experience
10:11:38 <sproingie> better than cabal-sandbox for sure
10:12:10 <sproingie> though it solves it in almost the same way, clone the world
10:12:49 <bodisiw> i guess i also see nix a lot and don't really understand that either
10:12:59 <sproingie> i'd love to try out nix but it's just hell on macos
10:13:02 <bodisiw> being new to cabal/stack/nix all at once is a little overwhelming
10:13:15 <shapr> After the pile of recent articles on lobste.rs, I think I'll try nix soon.
10:13:17 <sproingie> you end up with weird versions of core libs that may or may not build at any given time
10:15:20 <quchen> shapr: You don’t have to try it, you can just do it! I use Nix (the package manager) happily without problems
10:15:41 <quchen> NixOS on the other hand doesn’t save you much work, and compensates well for it by having to write your own derivations.
10:16:00 <quchen> It’s usable in production though, don’t get me wrong, but it’s not a good solution to everything.
10:16:44 <sproingie> i just have no use case for nixos, really.  when i want that level of isolation, i'd rather use docker.
10:17:20 <sproingie> nix would be a great build solution for docker images, sure.  but multiple userlands on one box makes no sense for deployment.  at least for me.
10:18:21 <quchen> Docker doesn’t isolate much. In particular the security aspect is just not there.
10:19:33 <orion> You know what's really neat? Compiling a Haskell application to a bootable ISO.
10:19:39 <sproingie> i'm told it's better (docker started out shockingly bad)
10:19:40 <orion> And then converting that to an EC2 AMI.
10:23:37 <sproingie> honestly i'll take full-blown VMs wherever that's cheap enough, way less to fuss over
10:24:23 <sproingie> but any decently complex app has to have some orchestration anyway, so no big whoop to have some config daemon handing out ports too
10:26:02 * orion just had an idea
10:26:13 <orion> You mentioned orchestration. Are you familiar with Consul?
10:28:25 <sproingie> i've heard of it, never used it.  i ended up writing my own coordinator with no kidding, a cgi script.
10:28:41 <sproingie> haven't done devops in years either :)
10:29:45 <sproingie> perl cgi script using sqlite to hand out configs and take status heartbeats.  worked like a dream.
10:31:50 <orion> Imagine that there was a Haskell implementation of Consul which you could plug it directly in to your application. If you were using HaLVM, you could package the entire thing up as an AMI, take advantage of auto-scaling groups, and get automatic orchestration.
10:33:29 <orion> All with *no operating system*.
10:34:02 * shapr sproings
10:34:38 <shapr> orion: Maybe the Reduceron will one day be useful there
10:35:35 <sproingie> i've had little need for bare metal apps thus far.  maybe if i start targeting RPi or something
10:35:50 <orion> shapr: That would be neat.
10:36:24 <orion> sproingie: Haskell on the RPi is awful. :(
10:36:36 <sproingie> i'm told it's generally awful on any ARM
10:37:00 <sproingie> tho iOS devices seem to have enough brute power to overcome
10:37:00 <shapr> A friend of mine is learning Haskell on his rpi, he says it works fine
10:37:31 <orion> How much demand is there for RPi/ARM Haskell development outside of toy projects?
10:37:45 <orion> I'm not aware of any businesses that rely on it.
10:37:55 <bodisiw> dang, i was hoping to run some haskell on rpi
10:38:09 <bodisiw> what's bad about it?
10:38:10 <shapr> At one of the local hackerspaces, I've met fifty kids who use an rpi for their home computer.
10:38:20 <sproingie> haskell itself is pretty niche in corporate environments.  a strong niche now, but still
10:39:54 <orion> bodisiw: I actually do use Haskell on a RPi to control access to a fraternity.
10:40:37 <orion> Each frat member gets a NFC tag that they use to get access to the building.
10:41:20 <orion> The application reads the tags, checks to see that they've paid their dues, and controls the GPIO pins to toggle the door latch.
10:41:28 <bodisiw> haha i like that
10:41:47 <bodisiw> nice way to ensure dues are paid :-)
10:42:17 <bodisiw> so what about that experience leads you to call it awful?
10:42:29 <orion> Indeed! Regarding development, I was unable to compile all the library dependencies without triggering the OOM killer.
10:42:48 <erisco> so what's the cool way to generate random numbers? some state monad thingie? passing around a RandomGen obviously sucks
10:43:09 <sproingie> compiling stuff on a pi is masochism
10:43:12 <orion> And I wasn't prepared to destroy a flash drive by adding multiple GB of swap space.
10:43:18 <bodisiw> orion, i would imagine cross-compiling is the way to go...
10:43:30 <sproingie> isn't it the *only* way to go with ghc on arm?
10:43:35 <orion> bodisiw: Not possible. The libraries I depend on require TemplateHaskell.
10:43:46 <Sonolin> sproingie I believe there's ARM binaries now 
10:43:54 <Sonolin> have yet to check 'em out though
10:44:10 <orion> TH is disabled on cross-compiled versions of GHC.
10:44:15 <sproingie> oh nifty.  other issue i seem to remember is it had to use a very slow GC on ARM
10:44:24 <bodisiw> ah, what's the reason for that?
10:44:25 <erisco> I am guessing this is cool https://hackage.haskell.org/package/MonadRandom-0.5.1
10:44:43 <sproingie> probably some tricky asm in the GC or something
10:45:00 <orion> bodisiw: Because TH actually executes code during the compilation process. If GHC is spitting out ARM instructions, they won't run on x86_64.
10:45:40 <bodisiw> orion, oh okay weird
10:45:43 <sproingie> orion: llvm would seem to be the answer here
10:45:45 <MarcelineVQ> orion: there's pretty active dev in that direction atm
10:45:53 <orion> MarcelineVQ: Cool.
10:45:59 <MarcelineVQ> angerman has some blog posts about the subject, iirc
10:46:36 <MarcelineVQ> ghcjs and external process ghci both take advantage of ferrying out compilation to get around that sort of limitation
10:47:16 <sproingie> oh neat didn't know ghcjs even did TH
10:47:18 <orion> bodisiw: I did find a solution though: The Linux kernel has a feature called binfmt, which allows you to specify an interpreter for binaries that match a certain fingerprint. The QEMU project has a package called, "qemu-user-static" which is one such set of interpreters.
10:47:22 <sproingie> reading up it looks like it kinda cheats
10:47:22 <orion> Including one for ARM.
10:48:08 <bodisiw> sounds like tooling is just not there yet, but maybe it's a matter of time
10:48:37 <sproingie> ghcjs is exciting but holy hell is project setup a pain
10:48:46 <bodisiw> i have not used TH at all
10:48:57 <sproingie> you might have in a library and not known
10:49:22 <orion> With binfmt support enabled, I was able to create a docker image of Raspian and compile/run Haskell code on my very powerful machine.
10:49:45 <bodisiw> sounds complicated... but i don't want to use python anymore
10:49:49 <orion> Then I just sftp the resultant binary right on to the RPi.
10:50:07 <sproingie> TH is really really cool but when TH code breaks the error messages are baffling
10:50:33 <orion> bodisiw: The whole process is neatly packaged up: https://github.com/centromere/ghc-arm
10:51:46 <bodisiw> thanks, hopefully i will get to the point where it's useful for me :-)
10:51:54 <orion> Ping me if you have any questions.
10:52:10 <bodisiw> right now i barely got SDL2 working, so i've got plenty of learning ahead
10:52:15 <orion> Cool.
10:52:33 <orion> sproingie: What is most exciting about GHCJS?
10:52:41 <bodisiw> (i assume i can use its framebuffer support to not run X on rpi)
10:53:34 <shapr> This was posted yesterday: https://medium.com/@zw3rk/a-haskell-cross-compiler-for-raspberry-pi-ddd9d41ced94
10:53:35 <sproingie> orion: having access to the browser platform
10:54:51 <orion> In a perfect world browsers would have Haskell interpreters built in, and everything would run in a restricted Monad.
10:55:29 <sproingie> wait for webasm i guess
10:55:32 <orion> ha
10:55:58 <orion> Actually, is it possible to have typed assembly?
10:56:07 <sproingie> sure, there's several implementations
10:57:07 <orion> That's actually really awesome: You could compile your Haskell code to a typed assembly and deliver that to the browser instead of the actual source code.
10:57:42 <sproingie> me, i don't care if the runtime is implemented with a bunch of hamsters on adderall
10:59:51 <sproingie> webasm i imagine just does something like pnacl for isolation.  works well enough.
11:00:57 <EvanR> on the subject of game engines, do people get anything out of "completed" game engines in other languages ever? pygame?
11:01:20 <EvanR> if so youd want to see what those libs provide and wonder if it makes sense for haskell
11:01:36 <EvanR> because theres millions in other languages that are write only and no one would realistically want to use
11:01:40 <Aruro> java --help ----> unrecognized option help, and people dream about haskell in browsers :D
11:01:55 <sproingie> pygame's had many many things written with it.  but pygame's age is showing, and there's better stuff out there
11:02:09 <EvanR> better stuff... that people use?
11:02:21 <sproingie> Aruro: java's always used single dashes for options
11:02:21 <erisco> windowing, mouse, keyboard, joystick, audio, rendering, physics, game state
11:02:37 <Sonolin> pygame was only really used for toys/pet projects though
11:02:43 <erisco> networking
11:02:49 <EvanR> erisco: ... that sounds like mostly something like SDL which isnt a game engine
11:02:50 <Sonolin> performance was terrible (not to mention the API)..
11:02:57 <sproingie> game state can bite me, most engines have a horribly primitive idea of states
11:03:12 <Aruro> sproingie: how hard is it for billion dollar monster to inlcude a couple of lines of code for 2 dashes :)
11:03:18 <erisco> EvanR, SDL checks a lot of boxes nonetheless
11:03:23 <EvanR> Sonolin: terrible api is not the focus of the question, but whether people use it
11:03:28 <sproingie> for me, input handling is the main reason for an engine, since it's so fiddly
11:03:34 <EvanR> erisco: not really what i was getting at though
11:03:53 <Sonolin> EvanR you mean like using a C/other language framework in Haskell?
11:03:53 <sproingie> Aruro: when java was new, it wasn't really a settled convention like it is now
11:04:03 <Sonolin> I'd think it would be useful for sure
11:04:03 <Aruro> btw gnu tools can do both
11:04:10 <EvanR> no
11:04:32 <sproingie> -foo in most gnu tools is equivalent to -f -o -o
11:04:37 <erisco> entity component frameworks
11:04:48 <erisco> i.e. "game objects"
11:04:54 <sproingie> entity systems can likewise bite me
11:05:24 <EvanR> "where are the game engines" answered: everywhere. "where are the engines in haskell" answered: nowhere.  "where are the game engines that i would use": ???.  "how to make an engine in haskell that i would use" f(???)
11:05:38 * hackage persistent-mysql 2.6.0.2 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.6.0.2 (MichaelSnoyman)
11:05:50 <sproingie> the use case in c++ was for specific memory layouts.  in other languages, it's about composition, which you're going to use anyway ... right?
11:06:13 <erisco> I just want some libraries to take away all the nonsense for me... like making a window and rendering fonts
11:06:21 <erisco> after that I'll handle the rest
11:06:24 <MarcelineVQ> what kind of fonts?
11:06:30 <EvanR> sproingie: many people dong use c++ or drop into something else for "scripting"
11:06:34 <sproingie> so as far as entity systems go, having to use goofy surrogate keys for entities is not a win for me
11:06:56 <EvanR> erisco: right so we have all that now, so isnt that interesting
11:07:06 <erisco> font rendering is a whole barrel of worms... I don't want to have to think about it :P
11:07:19 <EvanR> pango bindings, cairo bindings
11:07:24 <EvanR> hafbuzz
11:07:25 <sproingie> erisco: SDL is pretty much right up your alley then
11:07:26 <EvanR> harfbuzz
11:07:29 <erisco> you know the image libraries that let you throw in anything and get out anything? like that
11:07:45 <EvanR> not that all games need browser-like text
11:07:52 <sproingie> i think SDL is still using freetype and not harfbuzz, but for most purposes it really doesn't matter
11:08:14 <EvanR> ex. http://i.imgur.com/FMOYXVJ.png
11:08:38 <erisco> you have to be careful with sprite fonts... very restrictive
11:08:41 <EvanR> sproingie: two different things... one is rendering glyphs and the other is for complex layouts
11:08:54 <Tuplanolla> Is FreeGLUT the still only framework that provides stroke fonts out of the box?
11:08:57 <sproingie> juicypixels aims at being that "throw in anything" library afaik
11:09:11 <EvanR> erisco: if you look at an arcade game or a "megatouch" game or a casino video game... not too much non-sprite text
11:09:37 <EvanR> elaborate text in games is really specific to MMOs
11:09:46 <erisco> they're technically easy to do but also an aesthetic style
11:09:48 <sproingie> eh everyone wants a nice font in their menus
11:09:48 <EvanR> or space adventure 
11:10:10 <erisco> no, it is pervasive in all genres
11:10:20 <EvanR> no, i dont think so
11:10:36 <EvanR> big name computer games, and only some
11:10:56 <erisco> well, browse Steam sometime and let me know what you see
11:11:01 <MarcelineVQ> by sprite text do you mean the low-res look or do you mean bitmap fonts?
11:11:02 <EvanR> that is really a specific kind of game
11:11:20 <EvanR> MarcelineVQ: ill get you an example
11:11:22 <erisco> anyways they only satisfy a special case
11:11:26 <sproingie> bitmap fonts i'd guess, which can be as smooth as you like
11:11:35 <MarcelineVQ> EvanR: sorry I meant to be asking erisco
11:11:37 <sproingie> but lots of fun trying to kern those
11:11:44 <erisco> yes, bitmap fonts
11:12:09 <EvanR> MarcelineVQ: http://a2.mzstatic.com/us/r30/Purple1/v4/f0/f9/6a/f0f96a73-172a-c4b7-fcee-1e6f748cb227/screen520x924.jpeg
11:12:19 <erisco> "sprite font" in that it is rendered like you do sprites, i.e. you compile a "sprite sheet" and draw subsections of it for each sprite
11:12:26 <sproingie> kerning is actually easy, it's all the other hinting that's basically impossible with bitmaps
11:12:27 <MarcelineVQ> ah, what's restrictive about bitmap fonts? there's techniques like distance field rendering to keep them useable in most cases
11:12:29 <EvanR> right
11:12:35 <erisco> limited in that it is fixed in size
11:12:39 <sproingie> such hinting becomes important when you scale things to different sizes
11:12:51 <EvanR> MarcelineVQ: were both talking about fancy graphical lettering, not a font renderer for solid text
11:13:06 <sproingie> some languages become completely unreadable when you scale them down without hints
11:13:22 <erisco> eh, then we're just talking about it as an encoding rather than a presentation
11:14:10 <EvanR> so this is a no on my question
11:14:38 * hackage servant-auth-token-rocksdb 0.4.1.2 - RocksDB backend for servant-auth-token server  https://hackage.haskell.org/package/servant-auth-token-rocksdb-0.4.1.2 (NCrashed)
11:14:46 <EvanR> something that integrates everything SDL would do plus a physics engine, in a sort of browser-like programmed environment?
11:14:56 <EvanR> taking care of shaders and time and everything?
11:15:28 <sproingie> if you want a browser-like environment, it's hard to beat a browser
11:15:42 <erisco> EvanR, I think that is missing the point somewhat... but alright
11:15:53 <EvanR> sproingie: except for one thing... audio synth
11:16:00 <sproingie> oh no, that's there now too
11:16:06 <EvanR> erisco: which point?
11:16:10 <EvanR> sproingie: what you got
11:16:16 <erisco> the example you posted
11:16:43 <EvanR> that wasnt a point... nevermind
11:16:52 <erisco> that may be done with sprites, sure, but then we're really just talking about pre-computing
11:17:10 <sproingie> html5 audio does a lot beyond just <audio> tags
11:17:20 <EvanR> sproingie: i checked... it doesnt do what im talking about
11:17:27 <erisco> where did all the effects and initial rendering come from? some graphics program that has sophisticated font rendering
11:17:27 <sproingie> should be able to do synthesis
11:17:35 <EvanR> you cant get a callback, a sample stream
11:17:43 <erisco> the fact we can pre-compute it doesn't change the equation
11:17:43 <EvanR> you can only make oscillators
11:17:53 <EvanR> and they only do sinewaves
11:18:03 <EvanR> you cant do general DSP
11:18:47 <sproingie> well it's all sine waves in the end
11:19:07 <sproingie> there's higher level APIs around though
11:19:10 <EvanR> its a missing fragment of the browser platform
11:19:10 <orion> "It's sine waves all the way down..."
11:19:18 <erisco> what do you think the turnaround time is on their text renders? probably not great
11:19:43 <sproingie> https://www.w3.org/TR/webaudio/#idl-def-PeriodicWave
11:19:48 <EvanR> i didnt mean for my question to become a huge discussion of text rendering techniques
11:19:54 <EvanR> or DSP
11:20:32 <sproingie> EvanR: it's always more interesting a little deeper down the rabbit hole :)
11:22:19 <EvanR> sproingie: yes, you cant do general synthesis. they made a particular kind of one dsp thing you can use and called it done. im sure theyll "standardize" a few more primitives later
11:22:24 <ClaudiusMaximus> EvanR: there is a ScriptProcessor node in web audio it seems, that lets you use arbitrary js callback to fill an output buffer periodically
11:22:40 <tsahyt> how can I use lens to check whether a IntMap [Foo] contains the empty list at a given position?
11:22:41 <sproingie> EvanR: i think the idea was to provide the primitives and let library authors fill in the rest
11:22:54 <sproingie> EvanR: i mean do you really want another DOM?
11:22:55 <EvanR> something like what ClaudiusMaximus is what i was looking for
11:22:58 <infandum> Can I have a generic render for diagrams? Like, depending on the user input ".svg" or ".html", for instance, it would automatically render that file?
11:23:17 <EvanR> sproingie: i am not suggesting this browser idea, i was randomly poking at my original question
11:23:27 <Gurkenglas> tsahyt, "views (at k) null"
11:23:48 <tsahyt> ah
11:24:01 <tsahyt> hmm but I have this intmap as part of a Bar record and carry it around in a state monad
11:24:27 <tsahyt> I suppose there's a nice way to do this rather than accessing the state first and then checking
11:24:32 <Gurkenglas> tsahyt, "uses (mapfield . at k) null".
11:24:34 <cocreature> Gurkenglas: isn’t that a type error? at gives you a lens to a Maybe iirc?
11:24:46 <tsahyt> Gurkenglas: thanks!
11:24:56 <byorgey> infandum: yes, that is possible.  You have to define your diagrams with a polymorphic type (http://projects.haskell.org/diagrams/doc/manual.html#polymorphic-diagrams-and-partialtypesignatures is helpful here)
11:25:06 <tsahyt> this is the first time I'm using lens for anything, I'm still rather disoriented
11:25:13 <Gurkenglas> You're right. "uses (mapfield . at k . _Just) null" if no entry is supposed to return False
11:25:14 <EvanR> ClaudiusMaximus: looks like they want to create "audio workers" ... nice
11:25:24 <shapr> tsahyt: have you read Gabriel's lens tutorial?
11:25:30 <tsahyt> shapr: not yet
11:26:09 <byorgey> infandum: unfortunately there isn't anything to do this automatically so off the top of my head I am not sure how easy it is to keep all the nice options like -w and -h and so on, because you have to write main yourself so it can decide which backend to call
11:26:16 <Gurkenglas> tsahyt, if the map is supposed to contain a list of values for each key and [] is supposed to be equivalent to no values, use "mapfield . at k . non []" as your accessor and you don't need to worry about whether a key is in there
11:27:57 <tsahyt> it actually should always be in there
11:28:08 <infandum> byorgey: I am doing a render to a file, so there is no command line.
11:28:19 <tsahyt> the Nothing case would indicate an unrecoverable error here
11:28:47 <Gurkenglas> tsahyt, you're trying to remove an element from the list and remove the [] from the map if the element was the last one for that key?
11:28:49 <infandum> byorgey: Would I be using renderDia with this type as input or each renderHtml5 and renderSVG?
11:29:04 <byorgey> infandum: ah, ok, that's easier then
11:29:07 <glguy> If the elements of your list aren't instances of Eq, you can use: non' _Empty :: Iso' (Maybe [a]) [a]
11:29:32 <byorgey> infandum: I think you probably want to use renderHtml5 and renderSVG
11:29:42 <tsahyt> Gurkenglas: no it's not removed at the end, I just need to know when it hits empty
11:29:48 <tsahyt> it might fill up again
11:30:23 <james999> i'm downloading haskell 8.0.2a from the website, but the O'Reilly book I have says it uses version 2012.4.0.0. Can someone clarify the difference?
11:30:38 <infandum> byorgey: OK. Thank you!
11:30:48 <glguy> 2012.4.0.0 is a version of the Haskell Platform. 8.0.2a is a version of GHC
11:31:00 <glguy> GHC is the compiler, and the compiler is a component of the Haskell Platform
11:31:21 <glguy> james999: https://www.haskell.org/platform/contents.html
11:32:37 <sproingie> iirc some stuff in RWH doesn't work in 8.02 without minor adjustments
11:32:47 <sproingie> or maybe that's just LYAH
11:32:52 <james999> I'm looking at an installer window right now that says "Haskell Platform 8.0.2-a 32 bit"...
11:33:25 <glguy> james999: At some point there Haskell Platform versioning switch to use the GHC version number. YOu can see that by following the link I sent you
11:34:42 <james999> glguy: I see it now thanks. Will the sample code be fine or will it break?
11:34:52 <glguy> james999: Some will work, some will break
11:35:00 <james999> ok.
11:35:07 <sproingie> most will work, what breaks is usually due to imports you no longer need
11:35:14 <sproingie> or imports that were moved around
11:36:54 <james999> yeah. that's the problem with using books or tutorials that aren't current I suppose.
11:41:00 <infandum> byorgey: Having some trouble: it seems that even with that polymorphic type I still need to have "b" explicitely be one backend, so I can't have a function "renderType :: FileType -> QDiagram b V2 Double Any -> IO"
11:42:05 <byorgey> infandum: I would expect you at least need a Backend constraint,   renderType :: Backend b => FileType -> QDiagram ... -> IO ()
11:42:49 <infandum> byorgey: So that documentation had "f :: _ => stuff"
11:42:58 <byorgey> hmm, no, maybe not
11:43:00 <infandum> So I have "renderType :: _ => stuff"
11:43:06 <infandum> Forgot that part, sorry
11:43:12 <byorgey> infandum: you don't need that for renderType.  You need it for your diagrams.
11:43:18 <infandum> oh
11:43:23 <infandum> haha well I have that as well
11:43:35 <infandum> the diagram is of type QDiagram b V2 Double Any
11:43:42 <infandum> That part compiles
11:43:44 <byorgey> ok, at this point you will have to show me some actual code and error messages =)
11:44:41 <infandum> byorgey: https://pastebin.com/9rGnDx9p
11:45:56 <infandum> byorgey:     • Couldn't match type ‘b’ with ‘Diagrams.Backend.PGF.Render.PGF’
11:45:56 <infandum>       ‘b’ is a rigid type variable bound by
11:45:56 <infandum>         the inferred type of
11:45:56 <infandum>         renderType :: String -> D.QDiagram b D.V2 Double D.Any -> IO ()
11:45:59 <infandum>         
11:46:02 <infandum>  
11:46:25 <EvanR> erisco fresheyeball seems like the free-game package comes with support for graphics and fonts
11:47:08 <glguy> byorgey: Do you need any help getting "active" fixed to build against the current version of lens?
11:47:17 <byorgey> infandum: please show me ALL your code, and paste the full error message in the pastebin as well
11:47:48 <infandum> byorgey: Well there's a bit too much for that...
11:48:24 <byorgey> glguy: I might.  I haven't looked much at it yet since the semester was wrapping up.
11:48:50 <byorgey> infandum: well, can you make a small but complete example that demonstrates the problem?
11:49:15 <byorgey> infandum: I can't really debug code in my head without being able to actually try compiling and running it myself.
11:49:41 <infandum> byorgey: I can try
11:49:44 <byorgey> infandum: I suspect the problem may have something to do with renderType being defined in a 'let'
11:49:49 <byorgey> but I am not sure
11:51:00 <byorgey> infandum: oh!  no, I am being dumb.  Currently, the type of renderType says that the *caller* of renderType gets to choose the backend.
11:51:11 <byorgey> but the implementation is trying to choose some specific backends.
11:51:54 <byorgey> you would have to do something like  String -> (forall b. QDiagram b V2 Double Any) -> IO ()  but that will not work either, because none of the diagrams you define will have that type --- they will have more constraints
11:53:11 <infandum> byorgey: I figured I might have to do repetitive calls to the diagram with (:: PGF) and the like
11:53:19 <infandum> :(
11:53:24 <infandum> Let's see if that works
11:53:34 <byorgey> yes, that might be what you have to do.  I don't think it
11:53:45 <byorgey> ...don't think it's possible to make a generic function like renderType
11:53:49 <glguy> byorgey: Oh, looks like someone already fixed "active" for you, it just needs a release https://github.com/diagrams/active/commit/8cdf72f4f4160a7216614bb46bf8099e2d1b094d
11:54:11 <infandum> byorgey: OK, thank you for your help!
11:54:17 <byorgey> infandum: sure!
11:54:38 <byorgey> glguy: oh, great!  I hadn't noticed that.  cchalmers is our resident lens expert
11:55:23 <vbCrLf> Hey! I write a program in Python, which calls Haskell (compiled to a DLL and using FFI exports) in order to do some computations. How can I abort an Haskell function on demand?
11:55:26 <byorgey> glguy: it doesn't need a major version bump, does it?
11:55:36 <vbCrLf> Some computations take time and I want to be able to abort them using Python if needed
11:55:38 <glguy> byorgey: nope, very little bump at all
11:55:50 <glguy> It will only work in *more* cases than before now
11:56:45 <glguy> byorgey: Maybe take note while you're thinking about it that diagrams-lib needs an updated bound on intervals (0.8 came out), digrams-lib builds against this new version, but I don't know how to test that it behaves correctly http://hackage.haskell.org/package/intervals-0.8/changelog
11:56:52 <byorgey> ok. Making an upload now.
11:57:15 <glguy> Thanks!
11:57:17 <Gurkenglas> vbCrLf, you could kill the thread doing it
11:57:17 <byorgey> glguy: yes, I saw the intervals update.  I glanced at it just long enough to know that I didn't know if it still works correctly.
11:59:08 * hackage active 0.2.0.13 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.13 (BrentYorgey)
11:59:50 <infandum> byorgey: That did it!
11:59:55 <byorgey> infandum: great!
11:59:58 <infandum> Just a bunch of code repetition though
12:00:58 <byorgey> infandum: right, sadly I don't know of a good way to avoid that.  Other diagrams developers have definitely spent time thinking about this problem before, but I don't know that anyone's ever come up with anything reasonable.
12:02:15 <infandum> byorgey: The only worrying part is that they render differently :/
12:02:32 <infandum> The text was centered in the pdf but in the svg it's to the top left for some reason
12:02:50 <byorgey> infandum: I was just going to ask if it involved text.
12:03:12 <infandum> haha
12:03:17 <infandum> are there known issues?
12:03:28 <byorgey> since text is just passed off to each backend's native text support it is very hard to get text to look consistent across backends
12:03:40 <vbCrLf> Gurkenglas: Killing threads doesn't corrupt the state or something like that?
12:03:41 <byorgey> unless you use something like SVGFonts to convert text into paths and then stroke that
12:04:03 <Tuplanolla> Haskell threads come with exception handlers, vbCrLf.
12:04:12 <sproingie> bleh.  how in sam hell do i get sdl2 to use a hardware renderer?  i added opengl as a dependency, not sure what else i need
12:04:15 <vbCrLf> Okay, thanks! I'll try
12:04:26 <byorgey> infandum: with that said, there could also be bugs; reports are most welcome
12:05:01 <infandum> byorgey: I'll see if I can find some solution for that.
12:05:52 <infandum> byorgey: Is there a recommended way to handle size? I used to have it fixed like mkHeight 60 but that turned out to be a bust -- absolute makes everything too small -- is there some kind of automatic way of having a size (like em hight or something)?
12:05:53 <lep-delete> @src (.)
12:05:53 <lambdabot> (f . g) x = f (g x)
12:07:05 <sproingie> oh FFS sdl2-ttf used to work for me, now it won't even link.  i give up.
12:07:36 * shapr hugs sproingie 
12:08:09 <sproingie> i just want to program without constantly doing battle with the underlying system
12:08:15 <shapr> it gets easier?
12:08:28 <Tuplanolla> It doesn't get easier.
12:08:38 <sproingie> it got way easier when i switched to browser programming, yes.  maybe i'll give ghcjs another go.
12:09:35 <Tuplanolla> The more programming skill you gain, the faster you can solve relevant problems, so that more time is left for fighting build systems.
12:09:43 <srhb> Tuplanolla: :-P
12:11:54 <byorgey> infandum: size is complicated.  It depends on what you are trying to achieve.  Try reading http://projects.haskell.org/diagrams/doc/manual.html#measurement-units to start.
12:12:02 <byorgey> infandum: what exactly do you mean by "handle size"?
12:16:30 <sproingie> bloody f***ing hell.  it's looking for a symbol TTF_GetError ... which is apparently now a macro
12:16:49 <Tuplanolla> You have to admit that's a bit funny.
12:16:52 <sproingie> so looks like sdl2_ttf is broken
12:17:46 <infandum> byorgey: I'm not sure. When I open an html, for instance, the font size is up to the browser. I would prefer it that way. I don't know what the user would want and I want them to change the size of the result on the fly. However, if it's too tiny then it's nearly invisible even with 2000% zoom in the browser (which is what absolute does, as I have the base unit as 1).
12:18:40 <geekosaur> welcome to the world of programming. we talk about bitrot for a reason >.>
12:22:00 <infandum> byorgey: Like: I want 10 pt font size. What is that in diagrams' language for everything?
12:22:48 <EvanR> monads would be so scary if they werent called that. or maybe they would be! F# computation expression tutorials...
12:22:51 <EvanR> wouldnt*
12:23:17 <EvanR> "computation expressions have the reputation of being confusing..."
12:23:43 <EvanR> facepalm
12:24:10 <seequ_> It's like they tried to disguise monads as well as they possibly could
12:24:12 <geekosaur> isn't there already a "cute fuzzy things" monad tutorial somewhere?
12:24:22 <geekosaur> or s/fuzzy/fluffy/
12:25:01 <EvanR> in this video SPJ said "i think they called them 'Workflows'... which in retrospect is probably a good idea"
12:25:04 <byorgey> infandum: sorry, I have to go.  There are answers but they are a bit complicated.  Why don't you send a message to the diagrams mailing list and then others can chime in with suggestions as well.
12:25:11 <EvanR> but then... they didnt
12:25:16 <EvanR> its computation expressions
12:26:03 <sproingie> EvanR: workflows are just one of the things monads express though.  that'd be a good description of do-notation though
12:26:18 <infandum> byorgey: That's fine, I know it's a bit complex
12:26:20 <sproingie> the problem with trying to call monads something else is that it usually describes a subset of monads
12:26:21 <infandum> thank you
12:26:42 <EvanR> sproingie: whats funny is, Monad in programming *is* a subset of monads ;)
12:27:00 <sproingie> looks like s/TTF_GetError/SDL_GetError/ worked fine.  made a pull req but i don't get a good feeling about how maintained sdl2-ttf is
12:27:40 <sproingie> EvanR: anyway i don't think monads scare away people so much now that flatMap is appearing in other languages
12:27:48 <sproingie> they're just FlatMappables
12:28:01 <EvanR> i actually like FlatMappable
12:28:15 <sproingie> monad transformer stacks on the other hand get pretty daunting
12:28:26 <Tuplanolla> That's a bit verbose. Why not `Flattable` or `Pancake` instead?
12:28:47 <EvanR> at one point Flattenable ... pertaining to the join operation
12:28:59 <geekosaur> "Squishy"
12:29:01 <EvanR> should work in languages where most libraries are words much longer than that
12:29:10 <sproingie> MonoidInTheCategoryOfEndofunctors
12:29:36 <EvanR> Squishable
12:29:41 <sproingie> Squishy
12:30:03 <EvanR> Squishy may come off as sounding patronizing
12:30:14 <sproingie> thus we keep Monad
12:30:47 <Logio> monads are still quite okay compared to the legions of co-objects
12:31:04 <EvanR> SPJ "at least 'Monad' has the effect of filtering only people who really want to learn haskell"
12:31:41 <EvanR> (filter keeps things that predicate returns True)
12:31:42 <Akii> I like the term "Squishy Thingy"
12:31:46 <Akii> has a nice sound to it
12:31:52 <kuribas`> wait, flatMap is Monad?
12:31:57 <EvanR> yes
12:32:10 <Akii> and mapReduce is fold, right?
12:32:12 <sproingie> using the join . fmap intuition, yes
12:32:31 <sproingie> sometimes bind works better to explain a monad, sometimes join
12:32:35 <EvanR> > join [[1,2,3],[4,5,6],[7,8,9]] -- ;)
12:32:36 <taktoa> well, a monad is `flatten` (join) + `pure`
12:32:37 <lambdabot>  [1,2,3,4,5,6,7,8,9]
12:33:01 <sproingie> i find Maybe is easier to explain with bind, and join . fmap for List
12:33:41 <Akii> :t bind
12:33:43 <lambdabot> error:
12:33:43 <lambdabot>     • Variable not in scope: bind
12:33:43 <lambdabot>     • Perhaps you meant one of these:
12:33:48 <taktoa> yeah FlatMappable is not a complete description of Monad
12:33:48 <EvanR> i tried to make a list of monads just now, i got 19
12:33:49 <Tuplanolla> I wouldn't really mind `Pancake` or `Burrito` either.
12:33:51 <sproingie> bind in haskell is spelled >>=
12:33:53 <Akii> what's bind?
12:33:54 <Akii> ah
12:33:55 <Akii> right
12:33:59 <aewens> My main issue with teaching monads with Maybe is that the gap it puts you in between somewhat understand what monads are and how you'd go about using them for anything non-trivial.
12:33:59 <Akii> lol
12:34:02 <eschnett> :t (>>=)
12:34:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:34:06 <taktoa> you could maybe call it PointedFlatMappable
12:34:08 <Tuplanolla> Beamer already gets away with animals and plants for modules.
12:34:22 <EvanR> aewens: from concrete examples to the abstract
12:34:34 <sproingie> aewens: Maybe is a good trivial example that actually does something useful
12:34:52 <kuribas`> :t \f -> join . fmap f
12:34:53 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
12:34:54 <sproingie> List is a good step after that.  everyone knows map and ++ after all
12:35:16 <EvanR> most people dont (know they can) use non deterministic computation
12:35:28 <aewens> Yeah, but most guides I found on monads explained Maybe and then left it at that.
12:35:44 <EvanR> you need to explain these 19 example i compiled!
12:35:47 <sproingie> "nondeterministic" scares people though, they get images of amb and such in their head
12:36:07 <EvanR> whats wrong with amb!
12:36:14 <sproingie> (ok only lispers get amb into their head)
12:36:24 <eschnett> :t amb
12:36:26 <lambdabot> error: Variable not in scope: amb
12:37:19 <sproingie> http://www.randomhacks.net/2005/10/11/amb-operator/
12:37:21 <EvanR> amb [x] = x, amb (x:xs) = race x (amb xs)
12:37:45 <sproingie> poor explanation of amb in that article actually, but the examples are adequate
12:38:00 <sproingie> Icon had that sort of thing built in, damn fun little language
12:40:39 <vinny_wang1212> join #java
12:40:44 <sproingie> i had a lot of fun using Quantum::Superpositions in perl to generate rule combos.  hell that code might still be in use
12:41:18 <sproingie> took a stab at doing it in haskell but back then i didn't know how to tame the massive space leak i caused :p
12:41:24 <EvanR> QIO quantum computation monad
12:44:26 <taktoa> EvanR: sproingie: if you're interested in QM and know a little bit of category theory (e.g.: what a monoid category is), check out https://arxiv.org/abs/0908.1787
12:44:34 <taktoa> *monoidal
12:45:27 <sproingie> taktoa: QM seriously hurts my brane.  Q::S in perl was a goofy name for plain old nondeterministic programming
12:45:35 <taktoa> ah
12:45:45 <sproingie> perl6 has it built in with "junctions"
12:46:33 <EvanR> taktoa: sweet
12:46:43 <EvanR> i will forward this to the reading group
12:46:46 <sproingie> and haskell just plain has it built in because it has sensible "primitives" like fmap
12:47:49 <sproingie> design patterns for free, more or less
12:49:26 <EvanR> is there a current idiomatic "exit" monad going around?
12:49:49 <EvanR> or is EitherT, ExceptT used for this
12:51:45 <deech> Hi all, I'm trying out the GHC release candidate on one of my projects and it's complaining about base version bounds in dependencies (set to upper bound of 4.9.*). Is there a way to get Stack to ignore them?
12:52:42 <sproingie> EvanR: MonadFail perhaps?  maybe more modern alternatives exist.
12:53:02 <man_arab>  From which country are ye?
12:54:13 <EvanR> whoa
12:54:24 <EvanR> no PM
12:54:49 <EvanR> USA
12:54:58 <sproingie> deech: quick and dirty way would be to use a nightly resolver
12:55:10 <sproingie> or is that just a nightly stackage?
12:55:22 <EvanR> sproingie: MonadFail requires a String and isnt really a monad of its own
12:56:13 <sproingie> it subclasses Monad afaik.  but not very satisfying, no
12:56:39 <EvanR> heh, Identity as an exit monad
12:56:51 <sproingie> sure.  exit with success.
12:57:08 <EvanR> > (fail "hmm" :: Identity Int)
12:57:10 <lambdabot>  Identity *Exception: hmm
12:57:19 <EvanR> no
12:57:21 <sproingie> ugh
12:58:17 <man_arab> Hi
12:58:22 <deech> sproingie: I'm using 'resolver: nightly-2017-05-16' and I still get, for example, 'base-4.10.0.0 must match >=4 && <4.10 (latest applicable is 4.9.1.0)'
12:58:47 <sproingie> guess nightly resolvers aren't enough
12:59:47 <kadoban> Nightly resolvers tend to use nearly the most recent released GHC, I don't remember them ever using RCs
13:00:13 <kadoban> I think there's something about using RCs with stack/stackage on fp complete's blog a while back, but I don't recall exactly.
13:03:51 <rafaelcgs10> is here a good place to ask something about formal proof systems? more specifically
13:04:40 <rafaelcgs10> ...more specifically the formal system given in Wadler's paper: How to make adhoc polymorphism less ad hoc
13:07:56 <deech> sproingie: Got something working by doing 'resolver: ghc-8.2.0.20170507'.
13:09:50 <sproingie> ooh cool
13:20:05 <deech> Has anyone tried the release candidate with a non-trivial Setup.hs? I'm getting errors like 'Could not find module ‘Distribution.Simple.PreProcess’' and it's clearly there 'https://github.com/haskell/cabal/blob/2.0/Cabal/Distribution/Simple/PreProcess.hs'.
13:21:15 <glguy> deech: Yes, I've been building things with nontrivial Setup.hs and 8.2.1-rc1/2
13:23:15 <cocreature> deech: llvm-hs’s Setup.hs is fairly complex and I was able to get it working after adapting to the API breakage in cabal 2.0
13:23:27 <cocreature> deech: do you use setup-depends?
13:24:08 <unknownln> Is there any reason to prefer either (>) and (<) or (>>) and (<<) when dealing with a monad besides aesthetic appeal of one vs the other?
13:24:42 <WarmCookie> I don't know how you'd use (>) or (<); they aren't monadic.
13:24:46 <glguy> I'd prefer (>>) to (<<) because (<<) isn't defined
13:24:46 <deech> cocreature: Oh yeah. I just updated that to Cabal >= 2.0.0 and now I'm getting API breakage errors. Thanks!
13:25:00 <unknownln> sorry, meant `*>` and `<*`
13:25:24 <glguy> *> and <* do two different things, they aren't interchangable
13:25:39 <unknownln> I must mean something else
13:25:41 <unknownln> hmm
13:25:59 <mnoonan> (<*) doesn't have to be flip (*>)?
13:26:20 <unknownln> ^ wondering this myself now
13:26:42 <WarmCookie> I think your question is if it's reasonable to use Applicative style/syntax/operations on monadic values when you don't need the full power of monads?
13:26:45 <glguy> mnoonan: No, it's very unlikely not to be that
13:26:47 <glguy> mnoonan: No, it's very unlikely not to be that
13:26:50 <glguy> damn it
13:26:53 <glguy> mnoonan: No, it's very unlikely to be that
13:27:01 <unknownln> WarmCookie: yes that
13:27:03 <mnoonan> I get it, I get it :)
13:27:31 <unknownln> is there a reason to prefer the applicative operators to the monadic operators, for those operators which are equivalent
13:27:36 <glguy> no
13:27:48 <taktoa> well they have weaker constraints
13:28:17 <glguy> If you're using a type that supports both, then the weaker constraints won't matter
13:28:23 <mnoonan> glguy: oh, right; the sequence of actions is the same in both cases
13:28:36 <taktoa> code using the applicative operator will be more polymorphic
13:28:48 <glguy> Unless it's being used at a specific type already
13:28:51 <taktoa> yes
13:29:00 <glguy> It's possible that for a specific type that there could be a performance difference between the different choices, but there's no general guideline
13:29:31 <unknownln> in this case I'd be using it in some parsing code, so definitely a specific type is in play
13:29:48 <deech> Wow, this Cabal API breakage was way easier to fix than 7.10 -> 8.0.
13:30:06 <WarmCookie> It's common for parsing libraries to encourage an applicative-style usage.
13:30:34 <taktoa> I tend to use applicative operators whenever reasonable. I never use `return`, always `pure`. I usually forget to use `*>` instead of `>>` though.
13:31:28 <kamyar> Hello guys
13:31:37 <kamyar> Please help me about using groundhog
13:31:43 <taktoa> I think it's because *> is a bit uglier and doesn't convey the semantics quite as well as >>
13:32:39 <unknownln> yeah, I prefer the look of >>. I had thought << existed as well, but I've been using the applicative operators so I hadn't tried it
13:33:22 <hvr> it just gets mildly confusing as >> and << are used often as bitshift operators in other popular languages... :)
13:33:33 <taktoa> oh yeah lol
13:33:46 <WarmCookie> unknownln: You need >>= over <*> when the grammar of the second parser depends on the result of the first parser. Usually the grammar is designed such that the parsers are relatively easy to implement without having contextual changes in the grammar.
13:33:46 <taktoa> I'm so far down the haskell rabbit hole I forgot about that lol
13:34:15 <taktoa> I think every context-free grammar can be written using an applicative parser?
13:34:35 <kamyar> http://lpaste.net/355605
13:34:37 <WarmCookie> Yes, or at least it's what I'm trying to explain.
13:34:45 <kamyar> Please help me fix this code
13:35:29 <unknownln> that makes sense. If a library supports both, are there any performance gains in making sure a grammar is context-free?
13:36:07 <unknownln> performance isn't a concern for me right now, but I'm curious
13:36:29 <glguy> kamyar: flip withConn :: (MonadBaseControl IO m, MonadIO m) => conn -> (conn -> m a) -> m a
13:37:13 <taktoa> unknownln: I think you could write an applicative parsing library that is asymptotically faster than a monadic one
13:37:29 <kamyar> glguy: What should I do?
13:37:42 <WarmCookie> unknownln: Performance is neglectable for the case that's being made. What's more worrying is that when using the monadic approach, you cannot infer information about the parser without fully running it.
13:37:56 <glguy> kamyar: You'll need to make sure you're applying 'flip withConn pool' to something with type 'conn -> m a'
13:38:05 <glguy> kamyar: instead of what you're applying it to now
13:38:17 <WarmCookie> unknownln: There's a paper on static analysis that explains precisely that. I wonder if I can find it.
13:38:53 <kamyar> glguy: I haeve migrated from persistent to groundhog
13:39:01 <glguy> ok
13:39:08 <kamyar> glguy: I used a pool and I want to make a select query on it
13:39:52 <unknownln> If you find it, let me know. That's sounds pretty interesting
13:40:25 <kamyar> glguy: Can you help me?
13:40:57 <glguy> kamyar: I can't help you learn how to use groundhog. I can help you to understand why what you're doing with withConn is a type error
13:41:22 <unknownln> kamyar
13:41:23 <glguy> unknownln: I have an example of a type that only provides an Applicative interface so that the resulting values can be inspected if you're interested
13:41:36 <kamyar> glguy: Sould I use runDbConn instead? please see the signatures
13:41:53 <unknownln> change `u <- select ...` to `let u = select ...`
13:41:55 <glguy> kamyar: I don't know, I haven't used that library.
13:42:04 <unknownln> and see what happens
13:42:26 <cocreature> kamyar: as glguy explained, flip withConn pool expects a function "conn -> m a" but you are not providing such a function. you are starting a do block immediately
13:42:37 <unknownln> but I'm not sure that's actually the issue
13:42:44 <unknownln> oh shoot yeah
13:43:01 <unknownln> I was just looking at the error there, ignore me
13:43:02 <glguy> Just looking at the API I don't think you probably need to use withConn at all
13:43:15 <glguy> You should probably read the docs for groundhog to see how it's intended to be used
13:43:28 <kamyar> glguy: I did but I wanna use a pool not a conn
13:43:29 <unknownln> glguy yeah, that'd be neat to look at (the applicative)
13:43:38 <tttttttttttttttt> send nudes lmao
13:43:55 --- mode: ChanServ set +o glguy
13:43:56 --- mode: glguy set +b *!*@gateway/web/freenode/ip.40.132.243.84
13:43:56 --- kick: tttttttttttttttt was kicked by glguy (kynxbai)
13:44:39 <rafaz> hey where can i find support for sd disc recover?
13:44:53 <glguy> unknownln: See the example at the bottom of this page, it defines a parser for a config file and then is able to inspect the shape of the parser to make documentation for it http://hackage.haskell.org/package/config-schema
13:45:20 <glguy> rafaz: Oops, you're in the wrong channel. No this isn't the right place to find the right channel
13:45:47 <rafaz> can u help me out glguy and guide me :D
13:46:28 <koala_man> has anyone ever gotten afl-fuzz to work with Haskell programs? 
13:47:34 <sproingie> rafaz: the guy with the @ told you this was the wrong channel
13:47:55 <kamyar> glguy: There is no sample of groundhog using its pool!
13:48:00 <sproingie> not sure why i bother, good faith gets me nowhere on irc
13:48:15 <unknownln> thanks
13:49:08 --- mode: glguy set -oooo glguy glguy glguy glguy
13:49:37 <sproingie> oooo
13:51:11 <sternmull> why does "putStrLn <$> getLine" in ghci does not print the entered value? It asks me for the input, so it must be because putStrLn is actually evaluated... but then where is its output?
13:51:24 <glguy> :t putStrLn <$> getLine
13:51:26 <lambdabot> IO (IO ())
13:51:40 <taktoa> sternmull: putStrLn =<< getLine
13:51:44 <taktoa> is what you want
13:52:03 --- mode: ChanServ set +o glguy
13:52:04 --- mode: glguy set +b *!*@*/ip.40.132.*
13:52:08 * hackage concurrent-output 1.9.1 - Ungarble output from several threads or commands  https://hackage.haskell.org/package/concurrent-output-1.9.1 (JoeyHess)
13:52:42 <cocreature> kamyar: I think you want to use withResource instead of withConn
13:53:00 <sproingie> <$> is just `fmap`
13:54:29 <glguy> sternmull: with 'result <- putStrLn <$> getLine' the result is an action that each time if executed would print the line that getLine read from the console
13:54:48 <sternmull> thank you glguy and taktoa. I think i understand it now. The getLine was evaluated to produce an IO action that would print its value, and i never executed that action.
13:54:54 <kamyar> cocreature: ok let me see, What about runDbConn?
13:55:06 <kamyar> cocreature: It gets pool
13:55:17 <orion> Is reversing a list expensive?
13:55:25 <Tuplanolla> Yes, orion.
13:55:37 <glguy> It's as expensive as doing anything with the whole list
13:56:06 <orion> But it's not as expensive as, say, adding elements to the end of a list as opposed to the head.
13:58:51 <rafaz> need help to recover data from Sd card can anyone guide me to a good support channel?
14:00:38 <Tuplanolla> Self-sufficiency, rafaz: http://irc.netsplit.de/channels/?net=freenode
14:05:13 --- mode: glguy set +q-b *!*@67.170.253.182 *!*@*/ip.40.132.*
14:06:33 --- mode: glguy set -q *!*@67.170.253.182
14:06:38 * hackage graphmod 1.4 - Present the module dependencies of a program as a "dot" graph.  https://hackage.haskell.org/package/graphmod-1.4 (IavorDiatchki)
14:09:53 --- mode: glguy set -qqq *!*@46.214.237.86 *!*@31.10.154.65 *!*@*179.98.7.138
14:10:22 --- mode: glguy set -o glguy
14:23:21 <TheHoff> Hey guys, i need some help with quickCheck and Arbitrary Char's
14:28:24 <kadoban> TheHoff: What kind of help?
14:30:06 <TheHoff> kadoban: i want to verify that two functions always return the same, the input parameters are 2 finite strings, i defined a prop_function which compares the output of both function, with the corresponding parameters
14:30:47 <TheHoff> i think my problem is now to create arbitrary strings, i added Char to an instance of Arbitrary with  "arbitrary = chooose('a','z')
14:30:58 <TheHoff> but if i call quickcheck, it seems to run forever
14:31:24 <TheHoff> i guess the strings are too long (the 2 functions simply look for the second string in the frist string and return the indices of it)
14:31:47 <kadoban> Can you lpaste what you did? I think Char and String are already instances of Arbitrary, by the way.
14:34:49 <TheHoff> i have sent you an pm kadoban
14:35:07 <kadoban> I don't do private help, sorry.
14:35:31 <Xe> I will for $50 an hour
14:35:58 <TheHoff> kadoban: i just sent the paste in pm
14:36:08 * hackage hquantlib 0.0.4.0 - HQuantLib is a port of essencial parts of QuantLib to Haskell  https://hackage.haskell.org/package/hquantlib-0.0.4.0 (PavelRyzhov)
14:39:56 <imalison> Can someone help me understand why I had to make this change https://github.com/IvanMalison/taffybar/commit/2542b6ebc6337634736c413670792711639ac1f3 in order to make my write file call occur consistently?
14:40:14 <imalison> I suspect that it has something to do with lazyIO
14:43:44 <kadoban> imalison: What's the type of toggleStateFile ?
14:44:26 <imalison> IO FilePath
14:45:52 <imalison> kadoban: I'm assuming that the reason is basically because the value that is produced by the call of writeFile on the value coming from toggleStateFile is never used?
14:45:54 <kadoban> imalison: Ah, then <$> seems wrong. Wait ... how did that actually compile? Maybe I'm misunderstanding (??)
14:46:01 <imalison> yeah ?? is
14:46:07 <imalison> fab ?? a = fmap ($ a) fab
14:46:18 <imalison> it should definitely compile
14:46:30 <imalison> why would <$> be wrong?
14:46:42 <kadoban> Wouldn't  :t (writeFile <$> toggleStateFile)   be   IO (IO (FilePath))  ?
14:46:55 <Cale> imalison: Because you're constructing an action as the result of this thing which is just being discarded
14:47:08 <imalison> oh i need a join
14:47:11 <kadoban> Or no, not quite that *ponders*
14:47:22 <Cale> indeed... but you're already in a do-block
14:47:34 <Cale> So maybe just run the toggleStateFile on a separate line
14:47:45 <imalison> yeah thats what i did
14:47:51 <Cale> right
14:47:54 <imalison> but why did it compile
14:48:13 <Cale> Because it's okay if it's an IO (IO ())
14:48:22 <imalison> yeah but its applied to another argument
14:48:38 <imalison> ah well yeah the intermediate type s
14:48:38 <kadoban> Oh, it's     :: IO (String -> IO ())    and then  ?? show result   makes sense, but then you end up with IO (IO ())
14:48:43 <imalison> right yea
14:49:04 <imalison> yeah i think a join would have worked
14:49:10 <Cale> yeah, it would have
14:49:20 <kadoban> It would, but the way you changed it to is more idiomatic I'd say.
14:49:22 <imalison> ha well now i feel dumb
14:49:25 <Cale> Equivalently, capture the result of the action with <- and then run that
14:49:39 <imalison> kadoban: why is that
14:50:21 <kadoban> Not sure I have a good answer to that. It's just what I would expect and find easiest to understand.
14:50:22 <glguy> naming things and using do-notation is preferable to a mix of operators. It makes for easier code to understand
14:51:19 <glguy> This code was confusing enough that while it compiled you didn't understand what it meant with the operator version
14:52:34 <imalison> glguy: yeah thats a fair point, although I think the intent is pretty clear
14:52:52 <glguy> I don't think that was the case here, the diff you showed was an improvement
14:53:13 <Cale> imalison: Well, the *intent* was clear, but what the code actually did wasn't as clear ;)
14:53:22 <imalison> glguy: so when, do you think, is it appropriate to use things like '<$>' or ??
14:53:35 <imalison> which is sort of like the applicative style
14:54:43 <Cale> I think it can be just fine to use <$> and the other operators of that sort, but it's hard to explain exactly where it's profitable.
14:54:51 <glguy> Using ?? is cute but probably generally a way to write confusing code. <$> is fine on its own, but here combined with ?? lead to confusion
14:55:03 <Cale> Certainly if you were just going to join the result, you should be using =<< or something instead.
14:55:14 <imalison> glguy: yeah but the problem was more with <$> than ?? in this case
14:55:25 <kadoban> Yeah, I'd say (=<<) is pretty much always going to be preferable to using (<$>) and then join
14:55:26 <glguy> No, if it was just <$> it would have been more obvious what you'd done wrong
14:56:21 <kadoban> (or the equivalent do notation is of course fine too)
14:58:08 * hackage hlint 2.0.7 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.0.7 (NeilMitchell)
14:59:52 <Cale> The other thing is that ?? is pretty uncommon, so at least I wasn't familiar with how it would associate in the presence of <$> at first
14:59:54 <imalison> kadoban: yeah so something like that `flip writeFile (show result) =<< toggleStateFile`
15:00:17 <imalison> Cale: yeah i had defined ?? myself
15:00:24 <Cale> If it was  writeFile <$> toggleStateFile <*> pure (show result)
15:00:37 <Cale> then that would still be wrong, but it would be more idiomatically wrong ;)
15:00:44 <kadoban> Cale: Haha
15:01:02 <kadoban> imalison: Yeah, I think so. The flip is unfortunate, but that's how I would have done it I think.
15:01:07 <orion> > 4 > ((-1) :: Word8)
15:01:09 <lambdabot>  False
15:01:20 <imalison> kadoban: thats why I feel like one might prefer the <$> version
15:01:26 <kadoban> (or using do notation)
15:01:26 <imalison> it makes it feel more like the applicative style
15:01:45 <imalison> kadoban: hahah yeah. It seems like do notation is the consensus
15:01:51 <Cale> Well, the trouble with this thing is that there's no way to write the effect you want here with just Applicative
15:01:54 <kadoban> But it's outside of the realm of Applicative, Applicative isn't powerful enough.
15:01:57 <imalison> but I really don't feel like it adds to the clarity
15:02:05 <Cale> The effect you want to have on the world depends in some way on the result of one of the actions
15:02:15 <Cale> So it's impossible to write with Applicative
15:02:21 <imalison> Cale: yeah i get that
15:04:08 <hexagoxel> is the markdown flavor supported by hackage documented somewhere?
15:04:17 <hexagoxel> (README.md etc.)
15:12:45 * hexagoxel goes to #haskell-infrastructure
15:19:08 * hackage butcher 1.1.0.0 - Chops a command or program invocation into digestable pieces.  https://hackage.haskell.org/package/butcher-1.1.0.0 (lspitzner)
15:20:10 <hexagoxel> three days, three packages released, yay! (at least by UTC)
15:23:38 * hackage tensorflow 0.1.0.2 - TensorFlow bindings.  https://hackage.haskell.org/package/tensorflow-0.1.0.2 (JudahJacobson)
15:27:57 <Mibaz> Do arrows lie somewhere on the "functor / applicative / monad" spectrum?
15:28:14 <Mibaz> Everything I've found online has been vague or out of my league or conflicting.
15:28:46 <glguy> Mibaz: no, "arrows" are their own thing with a different kind
15:29:42 <Mibaz> glguy: Ok thanks!
15:31:28 <sproingie> the little category theory i've picked up hasn't helped me grok what Arrow is about
15:32:14 <geekosaur> Arrow is a thing that had Control.Applicative and Control.Category caged inside it and trying deperately to get out
15:32:23 <Mibaz> sproingie: I thought I was starting to get a hang of these typeclasses and then arrows showed up ;)
15:32:24 <sproingie> Control.Category is silly easy, Arrow is some weird business with tuples
15:32:41 <geekosaur> that was the cage >.>
15:33:03 <geekosaur> otoh Cotegory ended up with the tuples somehow
15:33:09 <geekosaur> *Category
15:33:29 <sproingie> eh, the Category class just defines id and .
15:34:20 <sproingie> seems pretty simple.  arrow seems to be computation over pairs, which i suppose represent the ends of the arrow ... ?
15:35:45 <kamyar> Hello
15:35:53 <sproingie> o/
15:36:07 <kamyar> Please someone tells me what the ~ sign do in constraints?
15:36:18 <phadej> it's type equality
15:36:25 <phadej> a bit like ==
15:36:28 <sproingie> type equality.  a ~ b means a is the same type as b
15:36:37 <phadej> but for type
15:36:40 <phadej> but for types
15:36:52 <kamyar> select :: (PersistEntity v, EntityConstr v c, HasSelectOptions opts conn (RestrictionHolder v c), PersistBackend m, Conn m ~ conn) => opts -> m [v]
15:36:57 <kamyar> See this
15:37:08 <sproingie> not sure why they didn't just make type equality ==
15:37:28 <phadej> sproingie: because there's type family == which returns lifted Bool
15:37:54 <sproingie> ah
15:38:29 <sproingie> boy that's a hell of a constraint
15:38:36 <phadej> that's not the real reason; but related to the real one (you should read about different equalities)
15:38:38 <sproingie> (on that select func)
15:38:57 <kamyar> sproingie: Yea! And I am getting confused now!
15:39:19 <phadej> `Conn` is at type-family, and `Conn m ~ conn` says that `Conn m` should be `conn`
15:39:25 <sproingie> the types in persistent are ... hairy :)
15:39:52 <phadej> i.e. it could been written HasSelectOptions opts (Conn m) (RestrictionHolder v c)..
15:39:53 <kamyar> sproingie: It is not persistent! It is groundhog!
15:40:21 <phadej> but not sure why maintainer went that way (consistency with more complicated variants?)
15:40:44 <sproingie> ah.  ok, looking at persistent, the types look pretty simple
15:41:09 <kamyar> sproingie: I was using persistent but for many reasons decided to migrate to groundhog but I am confused now!
15:41:30 <kamyar> sproingie: groundhog supports relations and database foreign keys
15:41:47 <sproingie> ooh nifty
15:42:10 <kamyar> sproingie: But with too less docs and samples
15:42:53 <sproingie> ah the famously complete documentation the haskell ecosystem is known for ;p
15:42:53 <kamyar> Hey guys can someone help em using groundhog-postgresql pool object in select function?
15:43:21 <kamyar> All the samples use a single connection not the pool
15:43:39 <sproingie> presumably you get a connection from the pool
15:44:16 <kamyar> sproingie: Yea but there are functions getting pool for example runDbConn 
15:44:48 <kamyar> sproingie: And, suppose u have a conn, does this select func get one? WTH
15:44:53 <planck> hello, i am new to irc and i have a question
15:45:09 <planck> i am trying to join a channel however it says i need gto be identified by services
15:45:16 <planck> but i am already identified?
15:45:24 <sproingie> ok so it's runDbConn that can handle a single conn or a pool.  looks like you should be able to just use a pool interchangeably with a connection
15:45:36 <sproingie> i'm guessing that's what ExtractConnection is about
15:45:41 <kamyar> sproingie: But how?
15:45:59 <sproingie> if my guess is right, just use it like a connection
15:47:17 <sproingie> very scala-esque idiom, "extract" naming and all
15:48:14 <Mibaz> planck: https://superuser.com/questions/106965/how-do-i-identify-with-services-on-irc might be a good starting place. Depends on your client
15:48:31 <planck> thank you!
15:48:35 <sproingie> planck: you'll want to start with /msg nickserv help
15:48:42 <sproingie> nickserv is what registers you
15:48:57 <planck> and what will be the best irc client
15:49:03 <phadej> there are instance ExtractConnection Postgresql Postgresql where and 
15:49:04 <phadej> instance ExtractConnection (Pool Postgresql) Postgresql
15:49:08 <planck> i am using xchat on ubuntu but i dont really like it]
15:49:18 <sproingie> the best client is the one you prefer.  anything maintained within the last 5 years will do
15:49:20 <planck> which one do you guys reccomend?
15:49:26 <Mibaz> planck: can confirm xchat is horrible
15:49:28 <sproingie> me, i rather like xchat.  i use irssi right now
15:49:57 <sproingie> irssi being a terminal app though, it's for old-skool types
15:50:02 <Tuplanolla> Pidgin works for me.
15:50:58 <sproingie> xchat's API is unbelievably idiotic though
15:51:25 <sproingie> but then so is pretty much the design of IRC
15:52:28 <Mibaz> sproingie: Once made an IRC client with Python. The protocol is pretty idiotic, as far as I could tell.
15:52:59 <planck> kiwi looks nice]
15:53:02 <planck> pidgin aswell
15:53:16 <planck> thank you for the recomendations 
15:53:22 <planck> which one was the terminal based?
15:53:38 <sproingie> i wrote an IRC implementation in MOO.  and yeah, the protocol started off awful and has only become worse
15:53:41 <sproingie> planck: irssi
15:53:43 <zachk> irssi and weechat
15:53:46 <mjora7> I live Textual (only MacOS), Irssi (terminal based) and thelounge (node, browser based).
15:56:30 <sproingie> i wonder if irc's server protocol has any kind of multipath routing or if it's still all a tree topology
15:56:54 <Mibaz> sproingie: haha In the last 2 minutes I haven't been able to find out what M00 even is. You're adventurous.
15:56:57 <PlasmaStar> RFC still being followed bud. 8-)
15:57:30 <sproingie> Mibaz: lambda.moo.mud.org
15:58:16 <sproingie> wrote it for E_MOO in my larval stage of hacking
15:58:45 <zachk> mibaz moo, likea  mud , old style multiuser text games
15:59:32 <sproingie> i'd hope on *IRC* i wouldn't have to give background on what a MUD is.  but i guess IRC has been more successful.
15:59:53 <jrm> If you worship in the church of Emacs, there is ERC and Circe.
16:00:05 <Rembane> sproingie: It isn't the 90s anymore. :D
16:00:34 <sproingie> Rembane: yet irc goes on.  so do MUDs i guess, but they're tiny islands with shrinking populations.
16:00:51 <Rembane> sproingie: It does indeed. 
16:01:01 <Mibaz> sproingie: Rembane: I get my hipster points just knowing what IRC is. Any more and I'd need to buy a beanie.
16:01:13 <sproingie> HellMOO is still a pretty fun MUD, long as you aren't easily offended
16:01:15 <Rembane> sproingie: Fun fact: I never started playing MMORPGs because they were too slow to play compared to MUDs.
16:01:31 <Rembane> Mibaz: Buy a beanie and get it over with, you will thank me later. :)
16:02:14 <sproingie> i got into WoW for a year, decided the game felt too much like work
16:04:19 <Mibaz> Rembane: Maybe I can afford a nice beanie after all this Haskell finally pays off and I become impressively wealthy
16:04:30 <Mibaz> I mean people who know Haskell are all wealthy, right? ... ?
16:05:06 <sproingie> the Simons probably do pretty well, sure
16:05:20 <Rembane> Mibaz: Oh yes, at least one.
16:06:59 <Mibaz> I definitely am missing the Simons reference. 
16:07:03 <hpc> actually all haskellers come from old money
16:07:07 <hpc> learning the language is like nerd polo
16:07:24 <EvanR> sproingie: and MUDs lost popularity like... 10 years before freenode
16:07:32 <EvanR> was born
16:07:45 <Mibaz> hpc: XD it all makes sense
16:07:48 <sproingie> Mibaz: two of the guys behind GHC are named Simon, and there's a third Simon also active in the haskell community
16:08:08 <sproingie> not sure if there were any simons in the committee.  i'd guess SPJ was there?
16:09:27 <Mibaz> sproingie: aah, they rake in the grant money, then, I suppose
16:09:54 <sproingie> eh, SPJ (Simon Peyton-Jones) works for microsoft and Simon Marlow for facebook
16:10:29 <Mibaz> sproingie: Oh got it. 
16:10:36 <EvanR> sproingie: definitely https://www.youtube.com/watch?v=re96UgMk6GQ
16:10:48 <EvanR> "SPJ Escape from the ivory tower"
16:12:13 <sproingie> been meaning to watch that.  i've seen some of SPJ's talks before, he's pretty good
16:12:15 <EvanR> sproingie: also this history of haskell and other lazy functional languages in the 80s http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
16:12:29 <EvanR> i just watched it, was hilarious
16:13:00 <sproingie> he's kind of the larry wall of haskell
16:13:07 <sproingie> (wall is way weirder tho)
16:14:37 <aez> @help
16:14:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:14:43 <aez> list
16:15:01 <aez> @help list
16:15:01 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:26:08 * hackage loc 0.1.2.1 - Types representing line and column positions and ranges in text files.  https://hackage.haskell.org/package/loc-0.1.2.1 (chris_martin)
16:28:38 * hackage loc-test 0.1.2.1 - Test-related utilities related to the /loc/ package.  https://hackage.haskell.org/package/loc-test-0.1.2.1 (chris_martin)
16:31:52 <kamyar> Fellows
16:32:10 <kamyar> Can someone give me a clue how to set tablename in groundg=hog mapping YAML?
16:33:06 <kamyar> Found out! Thnx!
16:47:32 <sproingie> > fix error
16:47:34 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:47:48 <sproingie> ... got there in the video :)
17:14:52 <pikajude> fix error is my favorite haskell-ism
17:15:11 <hpc> > floor (0/0) :: Integer
17:15:13 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
17:15:28 <hpc> (though that's a ghc/libgmp-ism)
17:19:22 <Hafydd> > floor (0/0) `mod` 10
17:19:25 <lambdabot>  6
17:19:56 <Hafydd> Well, that's quite demented.
17:20:18 <hpc> > floor (0/0) `mod` 256
17:20:21 <lambdabot>  0
17:21:03 <Hafydd> But it seems to have more to do with floating point numbers than with integers.
17:21:24 <hpc> sort of
17:21:41 <hpc> 0/0 is NaN, which has a particular representation
17:21:57 <hpc> floor i expect is specialized for Double -> Int and Double -> Integer
17:22:05 <hpc> > floor (0/0) :: Int
17:22:07 <lambdabot>  0
17:22:54 <hpc> anyhoo it's more interesting for Integer, because i expect it does some (mantissa * base ** exp) bitwise magic
17:22:57 <hpc> and then calls out to libgmp
17:23:16 <hpc> which... yeah does have a lot to do with floats
17:26:30 <glguy> > base 16 # (floor (0/0)::Integer)
17:26:33 <lambdabot>  "-18000000000000000000000000000000000000000000000000000000000000000000000000...
17:26:40 <hpc> :t base
17:26:42 <lambdabot> (Applicative f, Choice p, Integral a) => Int -> p a (f a) -> p String (f String)
17:26:50 <hpc> > base 5 # 100
17:26:53 <lambdabot>  "400"
17:27:03 <hpc> snazzy
17:27:23 * hpc pretends to know what Choice is
17:27:31 <exio4> that thing is creepy
17:28:22 <glguy> base :: Integral a => Int -> Control.Lens.Type.Prism' String a
17:29:28 <slack1256> on +RTS -s -RTS, the "total bytes allocated" includes memory that was overwritten (reused on a freelist) will count at least twice on that?
17:29:31 <Hafydd> :t (#)
17:29:33 <lambdabot> error: parse error on input ‘)’
17:29:47 <glguy> (#) :: AReview t b -> b -> t 	-- Defined in ‘Control.Lens.Review’
17:29:48 <hpc> different extensions in ghci vs mueval
17:30:00 <Hafydd> Interesting.
17:30:05 <hpc> unless they've changed how lambdabot interfaces with ghc recently
17:32:13 <slack1256> also, how is it different from alloc rate?
17:36:47 <crobbins> is there a type class for data structures which support O(1) indexing?
17:36:55 <crobbins> like Vector, Array, etc.
17:37:23 <geekosaur> slack1256, yes to the first. the second... would have to check but I think alloc rate gives you an idea of *time* periodicity (as opposed to *code location* periodicity) in allocations
17:40:03 <geekosaur> oh, no, it's a gc thing
17:40:29 <geekosaur> if you divide # allocations by wall clock time you get a time that is distorted by the time needed for major gcs
17:41:54 <geekosaur> and alloc rate is just a convenience, doing the math for you (total bytes allocated divided by the amount of time your code as opposed to the GC is running)
17:42:53 <slack1256> nice, actually the first (now you clarified) makes a lot of sense, because the copying strategy that is default on the GC
17:45:14 <slack1256> geekosaur: about the second, the math works. It didn't make sense to me, because the program I was testing runs on a fraction of a second :-P
17:45:29 <c_wraith> crobbins, why would that need a type class? 
17:45:32 <geekosaur> this is true, and it's even kinda evident in the example in the user manual
17:45:50 <crobbins> c_wraith: so you can generalize among various data types
17:46:20 <c_wraith> crobbins, but why would the time complexity of indexing affect that generalization? 
17:46:31 <geekosaur> on the flip side, *most* times you want to know this stuff, it's a longer running program which grows over time and you;re trying to get a handle on why
17:46:47 <crobbins> c_wraith: well, that's why it would need to be O(1)
17:46:54 <geekosaur> or, it;'s slower than you expect and you suspect it's allocaitng too much
17:47:27 <c_wraith> crobbins, in what way is it more useful than being able to abstract over an arbitrary indexing operation? 
17:48:29 <crobbins> c_wraith: would allow you to generalize stuff like binary search
17:49:38 <c_wraith> crobbins, how is that more useful than generalizing over a search algorithm?
17:51:28 <crobbins> c_wraith: maybe it's not, just seemed like if you had generic length and index functions you could derive a default implementation
17:52:26 <c_wraith> crobbins, my point is really that most different structures are so different that there's no useful sharing between them. 
17:52:48 <crobbins> c_wraith: fair enough
17:53:01 <c_wraith> crobbins, array/vector is an odd pairing in that sense, because they are conceptually the same. 
17:53:24 <c_wraith> that's rare. :) 
17:53:55 <crobbins> c_wraith: rare?
17:54:34 <c_wraith> for two libraries to export data types with all the same asymptotics 
17:55:00 <Mibaz> I'm running GHC 7.10.3. What's the easiest way to upgrade to 8.0.2? 
17:55:09 <Mibaz> From source or something automated?
17:55:31 <MarcelineVQ> where did you get your 7.10.3?
17:55:47 <Mibaz> I think it came with haskell-platform on ubuntu
17:55:59 <Mibaz> I don't really care about the rest of the platform, currently
17:56:11 <c_wraith> crobbins, though vector has a lot of performance enhancements that require any abstraction to be aware of them to not break them. 
17:56:55 <Clint> Mibaz: upgrade to zesty
17:57:20 <c_wraith> crobbins, for instance, Data.Vector.Generic abstracts over boxed, unboxed, and Storable vector variants in a way that's aware of preserving its optimizations. 
17:57:59 <Mibaz> Clint: Will haskell-platform include 8.0.2 in Zesty?
17:58:11 <c_wraith> crobbins, but the cost of that is that it only works with Vector
17:59:05 <Clint> Mibaz: yes
17:59:30 <Mibaz> Clint: Zesty it is! Thanks
18:08:33 <jordan335> https://ideone.com/hjGQ1B
18:08:50 <jordan335> what do i have to change to make the program compile without errors? : /
18:11:44 <jordan335> is it because i try to use list comprehension over a tuples
18:12:44 <Clint> jordan335: what is four_swap_cap_char supposed to do
18:14:07 <jordan335> it doesnt make sense much but its just a small part of a larger problem
18:14:20 <jordan335> i use it to change A to B and B to A
18:15:39 <Clint> jordan335: so if you pass (0,'a',True,'A') to it, what's going to happen?
18:16:20 <jordan335> oh i see
18:16:42 <jordan335> its reversed first then it changes A to B, then it changes True to ? theres the error?
18:17:34 <Clint> > let four_swap_cap_char x = if 'A' == x then 'B' else 'A' in four_swap_cap_char 'Q'
18:17:36 <lambdabot>  'A'
18:17:49 <Clint> > let four_swap_cap_char x = if 'A' == x then 'B' else 'A' in four_swap_cap_char (0,'a',True,'A')
18:17:51 <lambdabot>  error:
18:17:51 <lambdabot>      • Couldn't match expected type ‘Char’
18:17:51 <lambdabot>                    with actual type ‘(Integer, Char, Bool, Char)’
18:35:38 * hackage chart-unit 0.3.0 - A set of native haskell charts.  https://hackage.haskell.org/package/chart-unit-0.3.0 (tonyday567)
18:38:08 * hackage numhask-range 0.0.2 - see readme.md  https://hackage.haskell.org/package/numhask-range-0.0.2 (tonyday567)
18:47:38 * hackage chart-unit 0.3.1 - A set of native haskell charts.  https://hackage.haskell.org/package/chart-unit-0.3.1 (tonyday567)
18:56:32 <jordan335> how do add a tuple to a list of tuples?
18:57:13 <jordan335> > [] ++ (1,2,3)
18:57:15 <lambdabot>  error:
18:57:15 <lambdabot>      • Couldn't match expected type ‘[a]’
18:57:15 <lambdabot>                    with actual type ‘(Integer, Integer, Integer)’
18:58:51 <glguy> jordan335: What would you expect the result of doing that to be?
18:59:15 <jordan335> [(1,2,3)]
18:59:19 <glguy> > [] ++ [(1,2,3)]
18:59:21 <lambdabot>  [(1,2,3)]
19:00:06 <glguy> :t (++) -- so in   x ++ y, both x and y must be lists
19:00:07 <lambdabot> [a] -> [a] -> [a]
19:00:09 <kadoban> > (1,2,3) : []
19:00:11 <lambdabot>  [(1,2,3)]
19:00:18 <kadoban> That could be what you want ^
19:01:31 <jordan335> wow yeah kadoban thanks
19:03:50 <jordan335> > (0,'a',True,'A') : []
19:03:52 <lambdabot>  [(0,'a',True,'A')]
19:04:26 <jordan335> > let a = (0,'a',True,'A')
19:04:29 <lambdabot>  <no location info>: error:
19:04:29 <lambdabot>      not an expression: ‘let a = (0,'a',True,'A')’
19:04:51 <kadoban> lambdabot expects a single expression
19:04:58 <kadoban> > let x = 5 in x + x
19:05:01 <lambdabot>  10
19:05:13 <kadoban> @let blah = 2000 -- or you can do this
19:05:15 <lambdabot>  Defined.
19:05:16 <kadoban> > blah
19:05:18 <lambdabot>  2000
19:20:04 <koala_man> I want to test something on GHC 8.0.2 but I only have 8.0.1 in my distro's repo. Can I have stack install an independent copy somewhere?
19:21:56 <mrkgnao> koala_man: yes, just start a new stack project with resolver lts-8.13, say, and run stack build --install-ghc
19:22:14 <jordan335> i begin to see the beauty of haskell
19:22:56 <jordan335> i was stuck on a problem because i thought in imperative programming terms
19:23:04 <jordan335> now i found a one line solution
19:23:06 <jordan335> > [(a,b,c,d) | a <- [0,50..200], c <- [True,False], b <- ['a'..'c'], d <- ['A','B']]
19:23:08 <lambdabot>  [(0,'a',True,'A'),(0,'a',True,'B'),(0,'b',True,'A'),(0,'b',True,'B'),(0,'c',...
19:23:26 <mrkgnao> great! :)
19:23:35 <koala_man> mrkgnao: nice, thanks
19:23:43 <mrkgnao> jordan335: this looks project euler-ish
19:24:31 <mrkgnao> koala_man: yeah, stack does not care about your distro's packages, so you can always use whatever GHC you want 
19:25:06 <mrkgnao> lts-8.13 isn't necessary: you can use any LTS that is tied to GHC 8.0.2, and 8.13 is just the newest of those.
19:25:08 <jordan335> maybe that's where our prof takes all the tasks from
19:31:44 <c_wraith> well, the cross-wiring is complete now. I'm in the store, just walked past frozen burritos, and read it as "monads" 
19:33:33 <EvanR> lol
19:34:01 * geekosaur kinda wants to try that sometime (set up a burrito stand but with monad-related labeling)
19:34:09 <jordan335> im trying to build a program that creates a list of tuples (a,b,c) and a,b,c are natural numbers
19:34:15 <EvanR> talk to a monad
19:34:32 <jordan335> the problem is that i want the algorithm to terminate for every `elem` requeset
19:36:16 <koala_man> blerk, ghc 8.0.2 is still only using llvm 3.7
19:42:13 <jordan335> my idea is to look at the some of 3 elements
19:42:35 <jordan335> like first generate every 3tuples that has the sum 1 if u add all 3 elemnts
19:42:46 <jordan335> then generate all with sum 2 and so on
19:49:10 <ReinH> what does 'every elem request' mean?
20:02:32 <jordan335> if you load the program in ghci and then say sth like
20:03:01 <jordan335> (elem) (2,224,4) program
20:03:18 <jordan335> it should terminate for every input
20:03:29 <jordan335> ReinH
20:04:31 <ReinH> What is 'program'?
20:05:00 <jordan335> its the algorithm that is supposed to create 3-tuples of natural numbers
20:05:20 <ReinH> program is an algorithm?
20:05:28 <ReinH> what does 'elem' of an algorithm mean?
20:06:13 <jordan335> nvm, program is the list that the alg should create
20:06:29 <EvanR> chatbot?
20:06:35 <fDev2179> Hello fellow haskellers.  I have a question about the best way to assemble a sparse matrix using the hmatrix library.
20:06:39 <ReinH> @src elem
20:06:39 <lambdabot> elem x = any (== x)
20:06:43 <ReinH> @src any
20:06:43 <lambdabot> any p = or . map p
20:06:49 <ReinH> lol, down the rabbit-hole we go.
20:06:52 <ReinH> @src or
20:06:52 <lambdabot> or = foldr (||) False
20:07:37 <EvanR> ultimately... any list algorithm based on pattern matching is a fold
20:07:37 <ReinH> So what you need is for the algorithm to be productive
20:08:00 <ReinH> which essentially means that it needs foldr nature rather than foldl nature
20:08:05 <jordan335> well it doesnt have to be fast, it just has to terminate
20:08:10 <ReinH> recursion has to be guarded by the (:) constructor
20:08:15 <ReinH> I didn't say anything about speed.
20:08:36 <jordan335> im trying to do this using list comprehension
20:08:45 <fDev2179> I am writing a finite element code in Haskell.  I am at the point where I need to assemble all the element stiffness matrices into a global matrix.  Problem is that I'm trying to do this in an immutable way.
20:09:26 <ReinH> list comprehensions are productive
20:09:38 <peddie> fDev2179: can you post your code?
20:09:40 <ReinH> > take 10 $ [ x | x <- [1..10] ]
20:09:41 <fDev2179> I have a sparsity pattern from the mesh so I know which entries are nonzero in the global stiffness matrix.  I'm storing the entries from the element stiffness matrices as [(Int, Int, Double)]
20:09:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:10:10 <ReinH> specifically, [ x | x <- xs ] is productive if xs is productive
20:10:14 <fDev2179> peddie, it is about 200 lines in several Modules.  I can post the link to the git repo.
20:10:42 <fDev2179> peddie, https://github.com/jgrisham4/hfem1d
20:10:49 <jordan335> the one dimensional case is easy
20:11:01 <jordan335> aufgabeE = [(a,b,c) | a <- [1..], b <- [1..], c <- [1..]]
20:11:07 <jordan335> this doesnt terminate
20:11:09 <fDev2179> The whole code isn't necessary to understand my issue though.  I'll explain.
20:11:24 <jordan335> but i wish it would haha
20:11:25 <ReinH> jordan335: ah, you need diagonalization.
20:12:06 <ReinH> http://stackoverflow.com/questions/32465776/getting-all-the-diagonals-of-a-matrix-in-haskell
20:12:21 <fDev2179> Given a list of type [(Int, Int, Double)], which represents entries in a matrix in terms of row index, column index, and value, find all duplicate entries and sum the value to return one entry.
20:12:33 <ReinH> wait, no, that's the wrong diagonalization
20:12:39 <ReinH> https://hackage.haskell.org/package/control-monad-omega-0.3.1/docs/Control-Monad-Omega.html
20:12:43 <deech> Is there a way to get 'stack build' to show output from Cabal? For instance, show each module as it's compiling?
20:12:54 <fDev2179> I have one solution, but I'm not sure it is the best.  Also not sure if it works as it is just on paper.
20:13:42 <fDev2179> I should have said sum the duplicate entries to return one value for each entry in the matrix.
20:13:58 <ReinH> fDev2179: duplicate by value?
20:14:08 <fDev2179> Duplicate by row, column index.
20:14:25 <ReinH> I don't follow.
20:14:31 <fDev2179> I usually assemble these matrices in C++ or Fortran using something like a += operator.
20:15:09 <fDev2179> However, since I'm using Haskell, I'd like to stick to immutable data structures.  I saw there is a mutable matrix in hmatrix, but I'd rather not go down that road.
20:15:13 <ReinH> so your list contains duplicates or you have more than one list? Maybe I'm missing something.
20:15:22 <vaibhavsagar> deech: stack build --verbose?
20:15:27 <peddie> fDev2179: I see what you're saying; what's your solution?  I'm thinking something like `groupBy` with `sort` to get lists of matching elements
20:15:38 <jordan335> how do i implement diagonalization?
20:15:47 <deech> vaibhavsagar: Doesn't seem to do it. :(
20:16:00 <fDev2179> ReinH, I have a list of (Int, Int, Double) which contain coordinates of entries in a matrix in terms of row indices, column indices and values.  
20:16:15 <fDev2179> I have duplicated entries and I want to sum those and eliminate the duplicates.
20:16:19 <fDev2179> peddie,
20:16:30 <ReinH> jordan335: see https://hackage.haskell.org/package/control-monad-omega-0.3.1/docs/Control-Monad-Omega.html
20:16:36 <fDev2179> peddie, My solution involves a list comprehension and a filter.
20:17:04 <peddie> > map (foldr1 (\(x, y, a) (_, _, b) -> (x, y, a + b))) . groupBy (\(a, b, _) (c, d, _) -> (a, b) == (c, d)) . sort $ [(1, 2, 22.2), (2, 1, 33.3), (1, 2, 55.5)]
20:17:06 <lambdabot>  [(1,2,77.7),(2,1,33.3)]
20:17:26 <orion> Anyone know the best place to get HaLVM support?
20:17:41 <ReinH> fDev2179: so are you trying to do better than groupBy and map sum?
20:18:04 <ReinH> orion: here, I guess, such as it is?
20:18:13 <fDev2179> My solution didn't use groupBy.  Did use sum though.  Lemme look at peddie's solution.
20:18:20 <glguy> orion: Probably the HaLVM mailing list
20:20:10 <ReinH> jordan335: the operative bit is `diagonal`, which you should look at if you want to understand how it works
20:20:36 <ReinH> fDev2179: groupBy and map sum would be the naive way
20:20:52 <fDev2179> ReinH, what would you suggest?
20:21:25 <ReinH> Map (Int,Int) Double as a first attempt
20:21:58 <peddie> fDev2179: you could also form a bunch of matrices and then sum them, and if it's too slow, then just do that sum in a mutable way
20:22:08 <fDev2179> I understand what you did there, peddie.  Thanks.  That is definitely cleaner than what I had.
20:22:09 <ReinH> Actually, Map (Int,Int) (Sum Double) to get merging for free
20:22:31 <ReinH> That at least gets you within a log factor of the mutable method
20:22:41 <fDev2179> peddie, I feel like that would take up an unnecessary amount of memory.
20:22:55 <fDev2179> ReinH, how do you get merging for free?
20:22:57 <peddie> fDev2179: would it?  if they're sparse matrices?
20:23:10 <fDev2179> peddie, ahhhh true.
20:23:22 <fDev2179> That would probably be the easiest way.
20:23:41 <peddie> fDev2179: actually I guess if they were all sparse matrices and you were mutating one of them, it's probably not too different from ReinH's solution with the Map.  but it might be a little shorter with the library
20:24:08 <fDev2179> I still don't quite understand what ReinH wrote.  
20:24:11 <ReinH> fDev2179: the Monoid isntance
20:24:14 <ReinH> *instance
20:24:25 <fDev2179> Oh, not too familiar with monoids yet.
20:24:58 <peddie> fDev2179: if you do it his way with Sum, you can simply merge the maps for each element's stiffness matrix using the built-in way of merging maps
20:25:21 <ReinH> oh wait, that isn't the monoid instance
20:25:41 <ReinH> the monoid instance is a merge that prefers values to the left over values to the right
20:25:44 <fDev2179> What is the built-in way of merging maps?
20:25:56 <peddie> ReinH: I just made the same discovery :(
20:25:59 <ReinH> > fromList [("foo", "bar")] <> fromList [("foo", "baz")] :: Data.Map.Map String String
20:26:01 <lambdabot>  fromList [("foo","bar")]
20:26:02 <ReinH> peddie: that is sad
20:26:15 <peddie> fDev2179: ignore, it turns out that won't work after all
20:26:25 <ReinH> I don't really understand this new merge machinery
20:26:35 <peddie> ReinH: did the machinery change the instance?
20:26:46 <fDev2179> Okay.
20:27:12 <peddie> ReinH: maybe you're referring to the Merge module?  no haddock docs :(
20:27:26 <ReinH> peddie: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Merge-Lazy.html
20:27:43 <peddie> oh, I was looking for `Data.Map.Lazy.Merge` :)
20:27:53 <ReinH> I just want merge :: Monoid m => Map k m -> Map k m -> Map k m :/
20:27:54 <peddie> wow, this is complicated
20:27:58 <peddie> right
20:28:57 <fDev2179> I think I understand what you're talking about now.  We are talking about a type Map, not a function which applies a function to a list.
20:29:01 <fDev2179> More like a C++ map?
20:29:12 <jordan335> [(a,b,c) | summe <- [3..], c <- [1..], b <- [1..], a <- [1..], a+b+c==summe]
20:29:17 <jordan335> doesnt terminate : (
20:29:24 <ReinH> fDev2179: yes, sorry, Map k v is a dictionary from k to v
20:29:40 <fDev2179> Okay, that makes a lot more sense!
20:29:45 <fDev2179> I was a little lost.
20:29:46 <fDev2179> Thanks.
20:29:48 <ReinH> it is a log factor slower than its mutable (like C++) equivalent
20:29:49 <koala_man> I want my haskell program to crash in a way recognizable by fuzzers. How can I abort() or segfault or similar?
20:30:01 <ReinH> fDev2179: basically you merge maps into maps by summing the values
20:30:06 <fDev2179> Right.
20:30:12 <ReinH> and you get better asymptotics
20:30:12 <c_wraith> jordan335: well..  Yeah, that's going to be problematic.  It'll output (1,1,1) and then...  nothing else?  (if I read it right)
20:30:32 <fDev2179> I follow now.  I didn't think about looking for a container.
20:30:35 <ReinH> jordan335: Did you look at Omega?
20:30:46 <jordan335> yes but i didnt know how to use it
20:30:53 <ReinH> fDev2179: Ah! Often in functional programming the right data structure is just as important as the right algorithm, if not moreso
20:31:01 <fDev2179> For sure.  
20:31:17 <geekosaur> koala_man, raiseSignal sigSEGV (https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/unix-2.7.2.1/System-Posix-Signals.html)
20:31:40 <fDev2179> Scaling is important so I might try to find the right data structure before moving forward.  This code is a 1D code, but next I'm going to write a 3D code.
20:31:48 <koala_man> geekosaur: perfect, thanks!
20:32:13 <fDev2179> ReinH, any suggestions on where to look for something that merges the way I want?
20:32:18 <jordan335> c_wraith yeah i think thats the problem
20:33:01 <c_wraith> jordan335: that quick & dirty solution is to apply some domain knowledge.  You know that adding two positive numbers must always result in a positive number greater than either input.
20:33:18 <ReinH> jordan335: Oh, yeah, it's just fold
20:33:29 <c_wraith> jordan335: so you can do something like [(a,b,c) | summe <- [3..], c <- [1..summe], b <- [1..summe], a <- [1..summe], a+b+c==summe]
20:33:36 <ReinH> Wait, no it isn't
20:33:38 <ReinH> sorry
20:33:42 <c_wraith> jordan335: it's still not completely efficient, but it will be productive
20:33:43 <ReinH> ugh one sec
20:34:19 <ReinH> fDev2179: I guess somewhere in https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Merge-Lazy.html
20:34:49 <jordan335> thats exactly what i was looking for c_wraith
20:35:05 <jordan335> thanks a lot, that was a good idea
20:35:32 <fDev2179> Thanks, ReinH and peddie.  I need to learn more about containers provided by the language.
20:35:33 <ReinH> wow, it has all this merge machinery but not a simple merge of monoidal values
20:35:54 <ReinH> fDev2179: not by the language, by libraries!
20:36:08 <c_wraith> jordan335: do you see why that version makes progress?
20:36:10 <fDev2179> Okay, true.
20:36:26 <ReinH> this is one of the advantages of Haskell for me, that user-defined data structures can be efficient in a high level language.
20:36:31 <fDev2179> Just saw that's the containers library. 
20:36:35 <ReinH> which is why I mentioned the distinction
20:36:41 <fDev2179> Definitely agree. 
20:37:10 <fDev2179> It is really surprising as it would be very difficult to achieve something similar in C++.  
20:37:37 <fDev2179> Glad to know it is possible for that type of efficiency to exist in user-defined data structures.
20:37:48 <jordan335> yes it doesnt get stuck
20:37:53 <c_wraith> Oh, don't be mistaken.  It's not *easy* in Haskell either.  It takes a lot of benchmarking and experimenting. :)
20:38:04 <ReinH> fDev2179: Oh, it's just unionWith (+)
20:38:15 <fDev2179> c_wraith, something I need to learn more about.  haha
20:38:16 <ReinH> I'm so sorry, I must be having a brain aneurism
20:39:04 <fDev2179> So, I need to define a Map whose keys are the row and column indices and values are the entries and then use unionWith to merge the Maps, right ReinH?
20:39:19 <fDev2179> Whose key is a tuple of the row, and column indices, that is.
20:39:32 <ReinH> fDev2179: use fromList and convert (a,b,c) into ((a,b),c)
20:39:52 <fDev2179> Okay cool.
20:39:58 <fDev2179> Thanks, ReinH!
20:39:58 <ReinH> > fromList [((1,2),"hello")] :: Data.Map.Map (Int,Int) String
20:40:00 <lambdabot>  fromList [((1,2),"hello")]
20:40:25 <ReinH> > unionWith mappend (fromList [((1,2),"hello")]) (fromList [((1,2)," world")]) :: Data.Map.Map (Int,Int) String
20:40:28 <lambdabot>  error:
20:40:28 <lambdabot>      • Variable not in scope:
20:40:28 <lambdabot>          unionWith
20:40:39 <ReinH> > Data.Map.unionWith mappend (fromList [((1,2),"hello")]) (fromList [((1,2)," world")]) :: Data.Map.Map (Int,Int) String
20:40:41 <lambdabot>  fromList [((1,2),"hello world")]
20:40:45 <ReinH> tada!
20:40:48 <fDev2179> Sweet!
20:41:23 <fDev2179> I will definitely use that.  Thanks again!
20:41:26 <ReinH> you can use Map (Int,Int) Double and unionWith (+) or Map (Int,Int) (Sum Double) and unionWith mappend and get it 'for free'.
20:41:34 <ReinH> fDev2179: yw
20:41:52 <ReinH> hmm, I would also suggest strict maps for this, I think
20:42:06 <ReinH> and you may need to do extra work to make the values strict as well
20:42:11 <ReinH> to avoid building up thunks
20:42:14 <ReinH> but that's the basic idea
20:42:16 <fDev2179> Strict meaning...
20:42:56 <ReinH> you want your maps storing the result of 1 + 2 directly rather than a thunk representing the computation 1 + 2
20:43:45 <fDev2179> Oh, I wasn't familiar with the term thunk.  You mean we don't want to delay evaluation, right?
20:44:05 <ReinH> haskell uses 'thunks' to represent unevaluated expressions
20:44:17 <ReinH> you don't want to store thunks in your maps, you want to evaluate them and store the result
20:44:32 <fDev2179> Definitely agree.  Thanks.  Time to go read some documentation!
20:44:34 <ReinH> i.e., the difference between foldl and foldl'
20:45:09 <fDev2179> Learning all kinds of good stuff today.
20:46:05 <ReinH> so, e.g., unionWith add where add x y = x `seq` y `seq` x + y, or add !x !y = x + y (using BangPatterns)
20:46:50 <ReinH> although tbh you might end up just wanting to use ST and a mutable array...
20:47:13 <fDev2179> Another newbie question, what is ST?
20:47:20 <ReinH> sorry
20:47:38 <fDev2179> No worries!
20:47:41 <ReinH> ST is a monad for encapsulating mutation, more or less.
20:47:52 <ReinH> ST means strict threads (for state)
20:48:07 <ReinH> it gives you things like mutable arrays where mutation isn't observable outside of the ST action
20:48:12 <ReinH> principled mutation, you might say
20:48:15 <erisco> simplest is bestest if you're learning
20:48:18 <fDev2179> Okay.  I'd like to do this in such a way that it is easy to parallelize later on.
20:48:33 <ReinH> all of these methods would leave that door open
20:48:49 <fDev2179> That's why I was trying to stick with immutable data structures.  Wasn't aware this approach would leave that door open.  
20:49:22 <fDev2179> Then again, I have no experience writing parallel code in Haskell.  All my experience is in other languages using MPI and OpenMP.  I was just planning to learn it later.
20:49:29 <ReinH> well, with ST you will have to do a bit more work to divide up the problem into parallelizable chunks
20:49:44 <ReinH> @google parallel and concurrent programming in Haskell
20:49:45 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
20:49:45 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
20:50:12 <ReinH> Here's a free book by one of the primary authors of GHC's runtime system and its parallel/concurrent bits and bobs.
20:50:18 <ReinH> on, you know, that
20:50:32 <ReinH> it's one of my favorite Haskell books
20:50:48 <fDev2179> Yeah, already have that book on my favorites bar.  Just trying to make sure I've got the basics down before I dive into it.
20:51:31 <ReinH> it's a good way to learn the basics
20:51:36 <ReinH> it doesn't assume a lot of Haskell knowledge
20:52:09 <fDev2179> Okay, cool.  I'll check it out after I finish this 1D code.  
20:52:16 <ReinH> good luck!
20:52:31 <fDev2179> Thanks, ReinH, and thanks for your patience/help! 
20:52:51 <ReinH> you're quite welcome
20:52:59 <fDev2179> \e
20:53:10 <ReinH> o/
21:45:28 <Myrl-saki> @pl (\x y -> x :=> Identity y)
21:45:29 <lambdabot> (. Identity) . (:=>)
21:45:32 <Myrl-saki> Eh
21:47:29 <jle`> Myrl-saki: you can leave in a point
21:47:39 <jle`> Myrl-saki: \x -> (x :=>) . Identity
21:50:52 <sproingie> which would be just (:=> Identity)
21:51:25 <sproingie> (whatever the heck :=> does, composing with Identity seems kind of a no-op)
21:53:57 <Myrl-saki> @pl (\y x -> x :=> Identity y)
21:53:58 <lambdabot> flip (:=>) . Identity
21:54:33 <Myrl-saki> sproingie: That wouldn't typecheck. Probably.
21:54:34 <sproingie> meh.  the right-section is clearer imho
21:54:52 <glguy> sproingie: The thing you wrote isn't related to what Myrl-saki wrote
21:56:46 <sproingie> zounds, yeah i messed it up good
21:56:47 <jle`> sproingie: it's definitely more clear, but it does do something different
21:58:24 <Myrl-saki> @pl (\(y,x) -> x :=> Identity y)
21:58:24 <lambdabot> uncurry (flip (:=>) . Identity)
21:59:04 <lgas> does anyone know if there's a way to prevent haskell-mode from asking me if I want to kill all associated buffers every time I kill ghci other than commenting those lines out in haskell.el ?
21:59:08 * hackage yesod-job-queue 0.3.0.4 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.3.0.4 (nakaji_dayo)
21:59:10 <sproingie> heh so you mean (x `foo` Identity) y isn't the same as (x `foo` Identity y)?  :p
21:59:12 <Myrl-saki> lmao I giff up.
21:59:28 <Myrl-saki> this makes me wanna cry
21:59:44 <sproingie> prolonged thinko, i blame the mind control rays not working properly tonight :)
22:01:40 <Myrl-saki> It just stops responding lmao
22:03:13 <MarcelineVQ> what does
22:04:46 <sproingie> lgas: which lines?  far as i know, the prompt about killing subprocesses is something more deeply wired in emacs
22:05:56 <sproingie> i just use intero, it does its own ghci thing with no fuss
22:08:15 <radvendii> Hey guys, so I have Data.Matrix imported at the top of a file, but certain functions seem to be missing (prettyMatrix, the Num instance, ncols is called cols for some reason, transpose is called tr, multStd is missing)
22:08:42 <radvendii> and it doens't seem to be that I'm just using an older version of the package, because even the first version listed on hackage had prettyMatrix
22:08:42 <jle`> radvendii: check the docs for the module
22:09:11 <glguy> radvendii: You can check which version you're using: ghc-pkg list PACKAGENAME
22:09:42 <jle`> radvendii: try loading it in ghci and using :browse Data.Matrix
22:10:18 <radvendii> @glguy it can't find anything actually. This is probably a product of my being on NixOS
22:10:18 <lambdabot> Unknown command, try @list
22:10:42 <radvendii> jle`: yeah, I did something similar and those commands are missing there too
22:11:14 <cocreature> you probably need to run those commands inside of a nix shell or something like that
22:12:18 <MarcelineVQ> cols, tr, did you import from hmatrix instead somehow?
22:12:48 <radvendii> cocreature: Hm. Not sure what command to use though. I'm not such a veteran nix user unfortunately. Haskell itself usually works fine though, I haven't had problems in the past
22:13:28 <radvendii> MarcelineVQ: Interesting. Maybe? The import at the top is definitely Data.Matrix, but maybe something got confused?
22:13:38 <cocreature> radvendii: I think you are using this module https://hackage.haskell.org/package/matrices-0.4.4/docs/Data-Matrix.html instead of https://hackage.haskell.org/package/matrix-0.3.5.0/docs/Data-Matrix.html
22:13:49 <cocreature> so try changing your dependencies from matrices to matrix
22:13:56 <cocreature> not sure how you do that in nix
22:14:10 <sproingie> cocreature: golly, no chance of confusion with those package and module name combinations 8-/
22:14:27 <angerman> MarcelineVQ: yep, I do try to write a bit about cross compilation :) https://medium.com/@zw3rk should list them, in case you want to direct someone there the next time :-)
22:14:33 <Myrl-saki> I wonder if it's the X server that's rejecting me or something else.
22:14:39 <MarcelineVQ> angerman: I'll make a bookmark
22:14:40 <sproingie> FFS people, stop calling everything "Data" and "Control"
22:14:57 <radvendii> sproingie: hahaha
22:14:58 <MarcelineVQ> cocreature: golly, that's an easy mistake to make :(
22:15:09 <angerman> MarcelineVQ: thanks! 
22:15:21 <radvendii> cocreature: oh man, that's probably it. thanks, i'll work on making it use the other one now
22:15:43 <Rotaerk> we need a Control.Data and Data.Control
22:15:51 <radvendii> the worst part is it wasn't showing up when I searched for Data.Matrix on the web
22:16:15 <cocreature> Rotaerk: we already have Data.Data :)
22:16:16 <angerman> cocreature: wow. the edit distance between those two is really tiny: -"ces-0.4.4" +"x-0.3.5.0"
22:16:20 <cocreature> radvendii: here’s how I found it http://hoogle.haskell.org/?hoogle=Data.Matrix%20is%3Amodule%20is%3Aexact
22:16:22 <Rotaerk> heh
22:16:50 <sproingie> Control.Data - historically important ancestor to cray
22:19:46 <Myrl-saki> lmao
22:22:45 <radvendii> cocreature: This does indeed seem to have been the problem. Now I have to figure out how to not import 'matrices' which I never actively imported in the first place (sometimes nix is a nightmare)
22:23:12 <jle`> you can do package imports (a language extension), but this is the kind of thing that cabal files were made for
22:25:38 <sproingie> cabal and stack.  global installs are a nightmare
22:26:34 <radvendii> :/ yeah, yeah. I had hoped to postpone learning how to do that a little longer
22:26:47 <jle`> everything is easier with stack/cabal heh
22:26:51 <jle`> using haskell without it is a nightmare
22:27:01 <jle`> like, actually
22:27:04 <sproingie> stack has a small learning curve, then everything is *much* simpler
22:27:45 <geekosaur> until it breaks and then it breaks even more thoroughly
22:27:52 <sproingie> basically it's what java got right with maven: every project has its own private haskell, and stack caches all the things
22:28:01 <jle`> learning stack/cabal is a thousand times easier than learning how to deal without it
22:28:31 <sproingie> except unlike maven (but like scala and sbt), stack will also deal with installing haskell itself
22:28:34 <geekosaur> but of course never tell that to a True Believer who will swear even as it hoses them that it's user error
22:29:51 <sproingie> well it is usually user error, it just needs to be more graceful about it
22:30:18 <geekosaur> ...
22:30:33 <sproingie> stack is still a little wooly, but it's way tamer than doing it by hand
22:30:41 <geekosaur> sorry Ive had to deal with enough stack help requests in here to know better. also, enough stack bug reports
22:31:26 <sproingie> i've run into a stack bug or two myself.  still better than trying to manage multiple library versions by hand
22:33:41 <sproingie> the fact that it doesn't always clean up stale locks when stopping it with ctrl-C is the most annoying
22:37:57 <radvendii> When I start writing haskell code for production, I'll definitely need to learn stack. For now it's all just for personal projects though, and I don't really need to use different versions of libraries
22:38:50 <MarcelineVQ> you might not, but your dependencies might ;(
22:39:00 <MarcelineVQ> you should at least be using cabal sandboxes or cabal new-build :>
22:39:01 <sproingie> lemme give you a two-line intro to stack
22:39:07 <sproingie> #!/usr/bin/env stack
22:39:16 <sproingie> -- stack runghc --package foo-bar
22:39:40 <sproingie> presto, haskell is a scripting language that auto-downloads dependencies
22:39:46 <glguy> radvendii: If you take his pamphlet he'll move on
22:40:28 <radvendii> wait what? as in you put that at the top of your haskell file?
22:40:33 <sproingie> exactly that
22:40:36 <radvendii> and the comment tells stack what to do?
22:40:41 <sproingie> yep
22:40:55 <radvendii> where you put as many --package 's as you need for all your packages?
22:41:21 <sproingie> indeed.  though if you need several packages, you probably want to create a project ("stack new")
22:41:36 <glguy> The first two lines are free, then you gotta pay
22:41:49 <radvendii> hahahaha exactly
22:42:09 <radvendii> but as long as all I need is to install a couple packages, I can just use that intro with a bunch of --package s
22:42:12 <radvendii> wow
22:42:17 <radvendii> that actually seems super convenient
22:42:20 <sproingie> it's not to say stack is perfectly convenient all the time.  it just manages versions in a way cabal-sandbox never could
22:43:08 <MarcelineVQ> installing packages isn't quite the right way to think about using stack, https://docs.haskellstack.org/en/stable/GUIDE/ can explain more about that when you're interested in trying it
22:43:49 <sproingie> forget about "installing" anything with stack, it's like maven or npm that way
22:44:39 <sproingie> but even better than npm since it can install the platform itself
22:44:40 <radvendii> stack can't find my ghc
22:44:56 <sproingie> stack installs its own ghc
22:45:11 <radvendii> foo
22:45:17 <radvendii> foo
22:45:17 <radvendii> ahh! sorry
22:45:18 <radvendii> hang on
22:45:34 <radvendii> "No compiler found, expected minor version match with ghc-8.0.1"
22:46:01 <sproingie> might need to run "stack setup" to bootstrap things
22:46:05 <radvendii> oh i see. i just needed to add --install-ghc
22:46:08 <MarcelineVQ> sproingie should have added --install-ghc to his script :>
22:46:13 <radvendii> yeah
22:46:21 <sproingie> ah right, been a while since i started from scratch
22:46:22 <MarcelineVQ> though I'm not sure I advocate using the scripting facilies personally
22:46:24 <radvendii> but then it has to install all of ghc every time? XD
22:46:39 <sproingie> MarcelineVQ: pah, it's perfect for single-file examples
22:46:45 <radvendii> It's a good start. Better than what I'm currently doing
22:46:52 <MarcelineVQ> it's perfectly misleading ^^;
22:46:52 <sproingie> radvendii: no, it'll find an existing installation once it's done that
22:46:58 <radvendii> and yeah, at this point all of my projects are one file mostly
22:48:01 <radvendii> oh great. now something's assuming I have bash installed under /bin/bash
22:48:09 <sproingie> one killer feature is "stack ghci".  in a stack project, it'll load every module in exposed-modules
22:48:23 <radvendii> sproingie: oh that's nice
22:49:25 <sproingie> i'd hope stack isn't hardwiring /bin/bash anywhere :-/
22:50:07 <nightglare> sorry for the noob question but what was the command for making a new stack project?
22:50:13 <sproingie> stack new
22:50:15 <radvendii> """
22:50:22 <sproingie> just type "stack" without args and it'll show you the commands
22:50:33 <jle`> stack tutorial is also super helpful
22:50:44 <sproingie> (unfortunately that's as deep as stack's docs on the CLI go)
22:50:58 <radvendi1> whooops
22:51:03 <nightglare> ah thanks
22:51:31 <radvendi1> anyways, it is indeed trying to use /bin/bash somewhere in bash configuration
22:53:23 <sproingie> stack works on windows, guarantee it doesn't require a \bin, but maybe it's being sloppy on unixen
22:54:26 <radvendi1> huh. i dunno. I'll look into it more later, but for now I've gotta finish this final by tomorrow night so it's not worth it to do it now
22:54:43 <radvendi1> thanks for the help though :)
22:57:35 * sproingie ponders writing stack-tutorial so "stack tutorial" will launch a browser pointed at the stack tut
22:58:14 <sproingie> is there even a cross-platform browser-launching lib?
22:58:48 <MarcelineVQ> stack has a tutorial, it's called the user guide and no one ever reads it
22:59:59 <MarcelineVQ> That's not a comment on anything talked about just now, but a comment on help people seem to need most often being things explained as pretty much the first section in the user guide
23:00:15 <MarcelineVQ> Where it also explains what stack is, and by inferrence what stack isn't
23:02:14 <sproingie> the quick start in the readme seems all right.  the shebang + magic comment thing is almost an easter egg
23:03:11 <MarcelineVQ> I actually would like the quick start section removed so people have to stumble into the user guide instead ehe
23:03:49 <MarcelineVQ> that and "curl -sSL https://get.haskellstack.org/ | sh" could dissapear
23:04:01 <sproingie> on unix, i'd expect a manpage, but i don't see one for stack at all
23:04:40 <kadoban> MarcelineVQ: What's wrong with it, and what's better?
23:05:05 <MarcelineVQ> which item?
23:05:12 <kadoban> MarcelineVQ: The curl thing
23:05:17 <MarcelineVQ> hmm, piping into sh is just scary to me
23:05:22 <kadoban> Why?
23:05:27 <MarcelineVQ> I'm pretty sure we've had this convo though
23:05:40 <sproingie> MarcelineVQ: i'm no great fan of the whole "pipe scripts from random urls into shell" approach, but truth is it's exactly the same idea as any other download
23:05:42 <kadoban> Yes, I am as well. I don't recall you coming up with a much better idea though.
23:05:48 <MarcelineVQ> It ends with me not really knowing what I'm talking about
23:06:05 <MarcelineVQ> But it just doesn't seem like a good thing to advocate
23:06:27 <sproingie> yeah but it's absolutely isomorphic to downloading some installer exe and running it
23:06:33 <kadoban> But if there's nothing particularly better, is it something particularly to disuade?
23:07:40 <kadoban> Ya, it's just an executable, but better. If you actually care you can read it. (though reading it probably won't give you much/any extra security)
23:07:46 <radvendi1> I mean one better option is having the installation be simple enough that people can understand it and execute it themselves
23:07:47 <MarcelineVQ> Well for better I'm very much for distro releases and stack upgrade when needed
23:07:50 <radvendi1> not always possible though
23:08:20 <kadoban> Yeah, distro releases are good. But the people who are able to do those probably already know how
23:08:51 <sproingie> you can also install stack through OS package managers if trust is an issue (and i'd hope it is if you're deploying a production cluster or something)
23:09:37 <sproingie> but ultimately you're running arbitrary code in order to install something whose purpose is also to download and run arbitrary code
23:10:02 <sproingie> so ultimately you just go ¯\_(ツ)_/¯ 
23:10:12 <kadoban> Not to mention every time you're using a library without checking it, you're pretty much doing the same.
23:10:30 <kadoban> No idea how programmers don't get owned a lot more often than they do.
23:10:43 <sproingie> or even if you check it.  c.f. ken thompson "reflections on trusting trust"
23:11:23 <sproingie> just that modern open source has a way more open audit trail than the compiler thompson was demonstrating
23:12:56 <kadoban> I keep meaning to figure out if I should do a VM specifically for building things, or maybe some SElinux thing to really lock down compilers and built executables. But I never get around to it, too much work.
23:13:02 <sproingie> thing is, the distinction of "compiler" is starting to become blurry
23:13:42 <sproingie> so 20 years from now it might not be a deliberately backdoored compiler, just an exploit in an existing one that somehow manages to make itself persistent
23:14:30 <sproingie> in some ways, java already got itself there
23:15:38 <sproingie> (or sun's JVM did anyway by backdooring itself)
23:16:06 <simon> kadoban, same reason why people don't constantly get robbed in spite of how easy it is.
23:17:11 * hackage config-schema 0.3.1.0 - Schema definitions for the config-value package  https://hackage.haskell.org/package/config-schema-0.3.1.0 (EricMertens)
23:18:02 <sshine> kadoban, an automated pick gun doesn't cost a lot off ebay and will grant you easy access to the apartments of all your neighbours. not a lot of them, I reckon, have digital warning systems or physical traps to guard the door. :-P
23:18:52 <sproingie> robbery in the real world involves risk in a law-abiding society and a moral cost that taxes anyone not a complete sociopath
23:19:05 <kadoban> sshine: Ya, at some point we rely on people just being decent in general, but ... that seems to fall apart a lot on the internet where people can at least pretend they're anonymous
23:19:16 <sproingie> increasingly, neither are all that true when it comes to online explots
23:19:45 <sshine> kadoban, to me, the difference on the internet is the scale; *you* can rob your neighbours, but a hacker putting an exploit into a buildfile or a compiler can target a lot more people.
23:19:56 <kadoban> Exactly
23:20:13 * hackage machines-amazonka 0.6.2 - Machine transducers for Amazonka calls.  https://hackage.haskell.org/package/machines-amazonka-0.6.2 (misandrist)
23:20:28 * sshine wants to know what Amazonka is.
23:20:30 <sproingie> case in point, i occasionally pirate movies and music.  i use a reputable VPN provider and run minimal risk
23:20:54 <kadoban> Of course that requires a relatively high level of skill, and the rewards are usually probably not that great. People with the skill hopefully mostly have better things to do with their time.
23:21:01 <sproingie> yeah it's wrong, i don't do it that much, but it's so easy
23:21:06 <dmwit> sproingie, kadoban: Is this conversation still on-topic?
23:21:30 <sproingie> dmwit: yeah probably not :)
23:21:49 <kadoban> It's about the security of language tooling and libraries, especially haskell. Seems like it to me. But I think it's run its course anyway, I don't really have more to say.
23:22:19 <sproingie> yah it started with stack's "curl this url | sh" thing
23:22:41 <glguy> and then went off topic, anyway, looks like it's all done
23:23:19 <sproingie> i've noticed CS theory geeks do like talking about moral philosophy
23:23:40 <sproingie> which has been the fashion for over a hundred years or so
23:24:34 <sshine> the problem with "curl ... | sh" to me is not so much executing unsigned scripts on the internet, since we can always choose to trust the source, but rather copy-pasting from the browser into the terminal (since it might contain more than what's visible at first), since we implicitly trust the website that provides the copy-paste as much as the domain on which the script resides.
23:25:02 <sproingie> sshine: ah yes, i've seen that very exploit
23:25:21 <sproingie> (done as a POC that is)
23:25:56 <sproingie> anyway, not to continue the offtopicness.  i should probably hit the stack^Wsack
23:25:59 <kadoban> sshine: With an executable link you're also trusting the website. Is it any different? At least with the copy/paste you can probably see what you've pasted before you hit enter, if it looks very off.
23:26:07 <kadoban> Is this even off-topic? I don't understand why.
23:26:57 <sproingie> i always think of topic as the thing one comes back to when someone pops in with a topical question/point
23:26:58 <dmwit> Tips for pirating safely are off-topic. Tips for securing your devops are much closer to on-topic.
23:27:21 <kadoban> Ah, ya gotcha
23:31:44 <sshine> kadoban, you can't see what you've copy-pasted before you press enter if it secretly contains a linebreak. the moral is: don't copy-paste stuff from a website you don't trust into your terminal. :)
23:32:09 <sproingie> you could paste into a notepad then inspect that
23:32:13 <sshine> yup.
23:32:14 <kadoban> sshine: Yeah, true. But in this case the alternative would be clicking an executable link, right?
23:32:27 <sproingie> but then again if there was malicious intent, they could just put that into the script itself
23:32:27 <sshine> kadoban, I don't understand.
23:32:44 <opqdonut> my shell (zsh) seems to detect multiline pastes after some recent update
23:32:48 <sshine> sproingie, not if the source of the command isn't the same as the source of the script. there are lots of tutorials out there.
23:32:59 <sshine> opqdonut, that's neat.
23:32:59 <opqdonut> it doesn't run them until I actually press enter
23:33:06 <opqdonut> yeah I was impressed
23:33:09 <sshine> irssi has some support for it, too.
23:33:28 <kadoban> sshine: Well, if the website we're talking about wants to let you install things, you seem to be saying that "curl ... | sh" is bad beacuse of the copy/paste exploit. But isn't the alternative just as bad?
23:33:45 <sshine> kadoban, I don't understand the alternative.
23:33:55 <sshine> kadoban, but it isn't very important for me to understand.
23:33:58 <kadoban> sshine: Well, the obvious alternative to me would be linking to an executable file
23:34:32 <kadoban> Which, if anything, even more directly has the "can run arbitary code" problem
23:35:02 <sproingie> one imagines clipboard shenanigans would get noticed very quickly
23:35:18 * sshine would like a better clipboard.
23:35:33 <sproingie> wouldn't we all
23:39:22 <orion> If I define a ByteString on the top level of a file, is it guaranteed to only be constructed once?
23:41:42 <orhan89> i don't know, but when you want to install something you need to understand and trust what it is. The issue to me is more something like someone alter the file on the way, which in this case can be detected by using hash 
23:42:21 <kadoban> orhan89: Where do you get the hash from?
23:42:38 <opqdonut> tweeted by the dev :P
23:42:49 <opqdonut> printed in a newspaper?
23:42:50 <orhan89> kadoban: it should be mention on the website
23:43:09 <kadoban> orhan89: Right next to the link that you're not trusting?
23:44:04 <orhan89> i thought it's not the link that we are not trusting, but the data/file itself
23:44:28 <opqdonut> the link is data too, and if it's served by the same webserver...
23:44:47 <kadoban> The only thing "here's the hash for this thing: X" ever does for me is if I'm downloading from a mirror or over HTTP (no s) or something
23:45:03 <opqdonut> integrity for large things is also nice
23:45:25 <opqdonut> at least back in the day when downloading large linux .iso files I had some that got bitflipped somehow
23:45:29 <kadoban> Yeah. Though TCP seems to do fine for that usually, I can't remember my last broken download personally.
23:45:57 <opqdonut> or a silently truncated download or something
23:46:02 <opqdonut> but yeah, I can't remember that happening lately
23:49:48 <Myrl-saki>   let xs' = (\xs' -> fmap (\x -> x <$ xs) xs') <$> xs
23:49:55 <Myrl-saki> @pl (\xs' -> fmap (\x -> x <$ xs) xs') <$> xs
23:49:55 <lambdabot> fmap (<$ xs) <$> xs
23:50:14 <reliability> hi. I'm trying to follow this blog article here: http://blog.sigfpe.com/2009/01/fast-incremental-regular-expression.html. I have a few questions concerning this: What module do I need to load/install in order to make use of UArray? And what does 'U.!' in '(U.!) g ((U.!) f state))' mean?
23:51:13 <kadoban> reliability: UArray should be from Data.Array.Unboxed
23:52:11 <reliability> ok. Now, concerning the U.!: ! is array access, if I'm not mistaken, but what is U? 
23:52:17 <kadoban> reliability: U.! should be https://www.stackage.org/haddock/lts-8.14/array-0.5.1.1/Data-Array-IArray.html the (!) from here, under "Accessing arrays" it's indexing into the array
23:52:46 <kadoban> reliability: U is the module alias or whatever it's called from, near the top: import Data.Array.Unboxed as U
23:53:27 <jgt> can you do `import Data.Array.Unboxed as U`? I thought it had to be `import qualified Data.Array.Unboxed as U`
23:53:45 <reliability> Ah... so the dot ('.') in this case is module access and not function composition?
23:53:53 <jgt> reliability: yes
23:54:17 <kadoban> jgt: I think you can do it, I forget what it means. I remember I used to do it accidentally when I was new.
23:55:04 <quchen> reliability: The maximally confusing case is Prelude..
23:55:08 <quchen> :t (Prelude..)
23:55:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:55:19 <quchen> That’s »Prelude-dot-functioncomposition«.
23:55:25 <jgt> oh, yeah, you can rename modules but also keep unqualified names
23:55:40 <quchen> reliability: The second most maximally confusing case is
23:55:45 <quchen> > [False..]
23:55:47 <lambdabot>  <hint>:1:9: error: parse error on input ‘]’
23:56:03 <quchen> But other than that, dots are fairly well-behaved.
23:56:12 <quchen> > [False ..]
23:56:14 <lambdabot>  [False,True]
23:56:47 <reliability> Well, still not as bad as c++ templates, I guess.
23:57:04 <jgt> :t [False ..]
23:57:06 <lambdabot> [Bool]
23:57:12 <quchen> Silly behaviour is usually a special case in Haskell.
23:57:41 <quchen> jgt: »list all the Bools«
23:57:46 <jgt> haha yeah
23:57:57 <quchen> jgt: There is one even sillier thing to list all of,
23:57:58 <jgt> a range of bools seems silly and golfish
23:58:00 <quchen> > [() ..]
23:58:02 <lambdabot>  [()]
23:58:15 <reliability> hmm... but that essentially means that the parser cannot figure out of what type a dot is, unless it has figure out of what type the token just before is, right?
23:58:44 <quchen> reliability: It has to do one token lookahead, yes.
23:59:09 <kadoban> reliability: I don't think it cares about types, per se, just if it could be a module name (is a capitalized WordOrTwo). Unless that's what you meant
23:59:40 <quchen> You don’t need a typechecker to decide this though, it’s all done based on syntax, i.e. »what the code looks like«.
23:59:52 <quchen> Capital letter, then a dot: that’s a qualified name.
