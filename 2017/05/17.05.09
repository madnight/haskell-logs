00:03:12 <Antares> Parade Victory http://www.1tv.ru/live Parade Victory
00:12:32 <pacak> Antares: o_O
00:12:48 <pacak> Antares: ☭
01:49:21 <bollu> cocreature: ping
01:49:48 <bollu> cocreature: you had shown me a way to encode a "free-ish" DSL while still being inspectable (i.e, not having things of the form a -> Free f b)
01:56:20 <merijn> Is there a way to use cabal flags to cause the same target to be built multiple times?
01:57:00 <lemonxah> good day :)
01:57:35 <merijn> I have to flags Foo and Bar and one target that should be built with ghc-options X if Foo is true and with ghc-options Y is true and I'd like to build both versions if both flags are true
01:57:43 <merijn> Or am I stuck duplicating the target with a different name?
01:57:53 <lemonxah> i appologize if this is off topic to this channel, i am semi new to haskell and would like to know if there is a preffered library to use for writing RESTful API service
01:58:55 <stphrolland> Hi, I have a question about aeson. I work with a API which delivers objects which have an field called id. How do I do so as to avoid conflicts with id function defined in Prelude ?
01:59:01 <yushyin> lemonxah: maybe servant
02:00:21 <stphrolland> I mean, when I define the record which corresponds to the json object, I should have a field called id, which will collide with the Prelude id function.
02:01:28 <merijn> stphrolland: Well, the easiest solution is to avoid naming the field id. Another option would be to hide Prelude's id, which is not ideal. Or a final option is to only use explicitly qualified names for id
02:01:58 <lemonxah> yushyin: thank you i will check it out i am going to write some microservices 
02:03:07 <kamyar> Hello guys
02:03:13 <kamyar> PLease help mw in the code: http://lpaste.net/355351
02:03:20 <kamyar> What is the problem? See error below code
02:03:21 <TrumpPatrol1> ACTION TRUMP HAS ISSUED AN EXECUTIVE ORDER BANNING ALL NIGGERS FROM #FREENODE...EXIT IMMEDIATELY!
02:03:27 <TrumpPatrol1> ACTION TRUMP HAS ISSUED AN EXECUTIVE ORDER BANNING ALL NIGGERS FROM #FREENODE...EXIT IMMEDIATELY!'
02:04:11 <OnTheTrumpPatrol> ACTION TRUMP HAS ISSUED AN EXECUTIVE ORDER BANNING ALL NIGGERS FROM #FREENODE...EXIT IMMEDIATELY!'
02:04:14 <OnTheTrumpPatrol> ALERT ALERT
02:04:27 <OnTheTrumpPatrol> PLEASE EXIT NOW
02:04:48 <OnTheTrumpPatrol> ATTENTION NIGGERS PLEASE EXIT THE FREENODE SERVER
02:05:00 <stphrolland> merijn: if I hide id only in this module ? is it considered ok ?
02:05:13 <merijn> stphrolland: Yeah, just annoying
02:05:46 <stphrolland> merijn: I have never hidden functions from Prelude, how one does it ?
02:05:58 <merijn> stphrolland: "import Prelude hiding (id)"
02:06:11 <kamyar> Please check my code: http://lpaste.net/355351
02:06:15 <merijn> stphrolland: You can also add "import qualified Prelude" after that so that you can use "Prelude.id"
02:06:27 <TrumpPatrolAlpha> ACTION TRUMP HAS ISSUED AN EXECUTIVE ORDER BANNING ALL NIGGERS FROM #FREENODE...EXIT IMMEDIATELY!'
02:06:45 <TrumpPatrolAlpha> please exit now
02:06:54 <TrumpPatrolAlpha> ACTION TRUMP HAS ISSUED AN EXECUTIVE ORDER BANNING ALL NIGGERS FROM #FREENODE...EXIT IMMEDIATELY!
02:07:55 <AlphaTrumpAlpha> ACTION TRUMP HAS ISSUED AN EXECUTIVE ORDER BANNING ALL NIGGERS FROM #FREENODE...EXIT IMMEDIATELY!'
02:08:45 <Xnuk> @where ops
02:08:45 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
02:08:51 <AlphaTrumpAlpha> damn isn't anyone gonna ban me
02:08:55 <AlphaTrumpAlpha> this is one sorry ass server
02:08:56 <kamyar> No one helps me?
02:09:15 --- mode: ChanServ set +o dibblego
02:09:17 <entuland> AlphaTrumpAlpha, just go to #freenode and trhy there
02:09:18 --- mode: dibblego set +b *!*@ip-18-228-239-173.router.siliconvalleywifi.com
02:09:20 --- kick: AlphaTrumpAlpha was kicked by dibblego (AlphaTrumpAlpha)
02:09:27 --- mode: dibblego set -o dibblego
02:09:33 <entuland> :)
02:09:38 <merijn> Xnuk: Not really a point, they mostly get killed by freenode IRCops within a few seconds
02:09:50 <merijn> freenode is pretty quick with klining them
02:09:55 <Xnuk> oh
02:09:58 <tdammers> kamyar: it might help to paste something more complete
02:10:25 <kamyar> tdammers: I think the part is enough! Whole code is large
02:10:26 <entuland> it's nice how IRCops reads "I R Cops" to me :)
02:10:46 <merijn> Xnuk: Occasionally some scriptkiddie gets bored and starts spamming racist stuff in the top freenode channels, but they're pretty good at playing whackamole with them :)
02:10:57 <tdammers> kamyar: but anyway, it looks like the type inference algorithm can't figure out which type to use for `backend`
02:11:28 <kamyar> tdammers: It is persistent-postgresql
02:12:51 <tdammers> kamyar: what's the type of `listen`, and that of `conf`?
02:13:07 <tdammers> kamyar: no, forget that, that's not where it errors
02:13:12 <kamyar> tdammers: Teh are just records and these two are accessors
02:13:24 <tdammers> the problem is that both withPostgresqlPool and handler are polymorphic
02:14:19 <tdammers> so when you use them both in one expression inside main, without further type annotations, the `backend` is still polymorphic
02:14:29 <kamyar> tdammers: u mean backend is a type parameter 
02:14:30 <tdammers> but in order for that expression to type check, it has to unify
02:14:52 <kamyar> tdammers: OK I got the error but how to fix it?
02:15:05 <tdammers> the easiest fix is to add a type annotation
02:15:19 <kamyar> tdammers: I know but I am not sure which type
02:15:20 <tdammers> such that the `backend` is forced to a monomorphic type
02:15:46 <tdammers> you could either change `handler` to use a monomorphic type instead of the `backend` type var
02:15:58 <tdammers> or you can annotate parts of the line in main that uses handler
02:16:42 <tdammers> or you could annotatie withPostgresqlPool itself
02:16:49 <tdammers> whatever looks the most readable
02:17:09 <OnTheTrumpPatrol> ACTION TRUMP HAS ISSUED AN EXECUTIVE ORDER BANNING ALL NIGGERS FROM #FREENODE...EXIT IMMEDIATELY!'
02:19:15 <kamyar> tdammers: I guess if I complete the code and use the backend in the call stack the problem solves. AM I right?
02:19:34 <tdammers> could be, yes
02:19:44 <OnTheTrumpPatrol> PLEASE 
02:19:45 <OnTheTrumpPatrol> exit
02:19:46 <OnTheTrumpPatrol> NOW
02:19:53 --- mode: ChanServ set +o dibblego
02:19:59 --- mode: dibblego set +b *!*@ip-18-41-54-196.montreal.ca.northamericancoax.com
02:20:00 --- kick: OnTheTrumpPatrol was kicked by dibblego (OnTheTrumpPatrol)
02:20:30 <kamyar> tdammers: Thnkx!
02:21:31 <cloudhead> anyone know how I can create an 'edit' view with digestive-functors?
02:23:24 <LINK> hello
02:43:45 <stphrolland> Hi, another aeson question. The API I have to work with has a field wich begins with a number 24h_var, which does not fit as a field name for my record. How would you deal with it ? The fact of using GHC generics for having instance ToJson and FromJson written for me was really pleasant.
02:47:37 <liste> stphrolland: check out https://hackage.haskell.org/package/aeson-1.2.0.0/docs/Data-Aeson-Types.html#defaultOptions
02:47:45 <liste> you can use it to configure the naming conventions
02:48:01 --- mode: dibblego set -o dibblego
02:49:24 <liste> stphrolland: more here https://hackage.haskell.org/package/aeson-1.2.0.0/docs/src/Data-Aeson-Types-Internal.html#line-515
02:51:54 <liste> stphrolland: you use it like this: "instance FromJSON Coord where parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = ... }"
02:52:40 <stphrolland> perfect
02:53:08 <stphrolland> and for ToJson ?
02:55:31 <Grisha> hello everyone
02:55:58 <liste> stphrolland: there's a genericToJSON too
03:00:18 <Grisha> my program makes Postcards that are supposed to be sent to different Countries, so there is a class type Postcardable, which Countries might belong to. A part of the postcard making process, there is the composition of address, which is a simple operation on strings. Now, depending on the Country, there are different signatures of makeAddress, accepting different number of Strings. So makeAddress must be :: Postcardable country => AddressParameters count
03:00:18 <Grisha> -> String
03:01:01 <Grisha> how do I make makeAddresss country-aware?
03:02:29 <Grisha> and I feel that I don’t have to
03:03:14 <opqdonut> you could add the parameter type to Postcardable
03:03:24 <Grisha> opqdonut: yes, exactly
03:03:44 <opqdonut> either with fundeps or type families
03:03:51 <Grisha> like class Postcardable country where type AddressParameters country
03:03:52 <Grisha> but
03:03:58 <opqdonut> yeah
03:04:06 <Grisha> then I’ve got this type ambiguity thing
03:04:26 <Grisha> `makeAdress String String` wouldn’t know it’s for Australia
03:04:32 <opqdonut> you probably need to add a Proxy country
03:04:34 <opqdonut> to the args
03:05:10 <Grisha> hmm
03:05:18 <Grisha> I’ve seen those proxies before
03:05:29 <Grisha> and thought that I understood them
03:05:35 <Grisha> but now I don’t ;>)
03:06:07 <opqdonut> so you'd run `makeAddress (Proxy :: Proxy Australia) ""` or so
03:06:33 <Grisha> what would be the signature of makeAddress?
03:06:47 <opqdonut> makeAddress :: Postcardable country => Proxy country -> AddressParameters country -> String
03:07:29 <opqdonut> another option would be to use fundeps, "class Postcardable country params | country -> params, params -> country"
03:07:34 <opqdonut> and have a unique newtype for every country
03:07:54 <Grisha> I see
03:07:55 <opqdonut> then you could just invoke `makeAddres (AustraliaParams "hello" "boing")` or so
03:08:07 <Grisha> never touched fundeps before, have to read up
03:08:27 <opqdonut> maybe I'm not seeing everything, but you could also just identify the country with the params
03:08:41 <opqdonut> so you'd have "instance PostcardArgs AustraliaArgs"
03:08:45 <opqdonut> and none of this fancy stuff :)
03:09:09 <Grisha> opqdonut: it’s not injective, that’s the thing, different countries can have the same AddressParameters
03:09:28 <opqdonut> yeah, you'd need to newtype the differences away
03:09:40 <opqdonut> but if you want the non-injective design then you need to have country somewhere in the function
03:09:49 <opqdonut> either as a Proxy argument, or mentioned in the return type
03:09:49 <Grisha> yes, exactly
03:10:06 <Grisha> thanks a lot
03:10:08 <Grisha> now I remember
03:10:16 <Grisha> I saw Proxies in Servant
03:10:26 <opqdonut> I imagine the type could be something like `makeAddress :: Postcardable country => AddressParameters country -> Address country"
03:10:33 <opqdonut> (heh, mismatched quotes)
03:10:56 <opqdonut> and `data Address country = Address String` for instance, so just a phantom type for the country
03:11:10 <Grisha> oh, so `Address country` would be another dependent type, right?
03:11:20 <opqdonut> dependent type is the wrong term
03:11:54 <opqdonut> the `country` in `Address country` is a phantom type since it doesn't appear in the runtime value
03:12:22 <Grisha> should Address come from the class declaration?
03:13:38 <opqdonut> no, it can be a separate type
03:14:10 <opqdonut> there are some examples here: https://wiki.haskell.org/Phantom_type
03:15:19 <Grisha> opqdonut: thank you a lot! you’ve definitely told enough to keep my efforts rolling
03:21:23 <Grisha> opqdonut: reading about fundeps
03:24:41 <Grisha> sounds more like that you’re trying not to allow multiple AddressParams for the same country
03:24:49 <Grisha> rather just mapping countries to AddressParams
03:31:37 <opqdonut> Grisha: yeah well you can't have multiple AddressParams for the same country with associated types either
03:32:05 <opqdonut> Grisha: if you want m:n mapping between countries and params you need a separate type family for that, and a Proxy type or some way to specify the country
03:32:26 <Grisha> opqdonut: what’s the difference then between type families and fundeps?
03:32:40 <Grisha> ok, maybe too big a question :)
03:33:12 <opqdonut> "class MyClass a b | a -> b" is pretty close to "class MyClass a where type MyClassType"
03:33:29 <Grisha> but?
03:33:35 <opqdonut> no buts
03:34:33 <Grisha> one being syntactic sugar for the other?
03:34:46 <opqdonut> not sure how the implementation goes
03:40:28 <Grisha> opqdonut: you’ve been very helpful, thanks a lot
03:43:37 <rightfold> There are differences
03:54:13 <reino4477> could anyone take a look at this ? http://stackoverflow.com/questions/43865876/aeson-decode-and-overloadedstrings
03:57:22 <srhb> reino4477: decode takes a ByteString, you're feeding it a Text. Are you confused about the conversion?
03:57:48 <srhb> reino4477: OverloadedStrings only makes string *literals* polymorphic.
03:59:41 <reino4477> srhb: pack doesn't work either. 
04:00:49 <Philonous> Is there a way to construct singletons for Symbols? I.e. I want to have a value of type (Sing ("abc" :: Symbol)) 
04:01:54 <srhb> reino4477: Data.Text.pack? Isn't that String -> Text ?
04:02:05 <srhb> reino4477: You need Text -> ByteString, ie. some encoding aware function.
04:02:11 <maartinex> hello guys, what library or framework should i use for testing in Haskell ?
04:03:27 <szhwump> hi, I want to compile/run a .hs file without setting up a project, can I do that using stack?
04:04:02 <srhb> szhwump: I think stack has an implicit "project" that lives in your homedir that will be used if you try.
04:04:43 <srhb> szhwump: Or in other words, "try" :-)
04:04:45 <maartinex> srhb, whats the difference just doing ghc ... instead stack .. ?
04:04:56 <reino4477> srhb: of course
04:04:59 <reino4477> How can I convert Internal.ByteString to Lazy.Internal.ByteString?
04:05:00 <srhb> maartinex: stack commands will have access to stack install'ed packages.
04:05:18 <srhb> reino4477: If you're going from Text, just use the one that goes to lazy immediately.
04:05:28 <szhwump> srhb: so is there a sandbox in the homdir?
04:05:35 <reino4477> srhb: what's the one?
04:05:39 <srhb> szhwump: Yeah, somewhere in ~/.stack I think
04:05:45 <szhwump> cool thanks
04:05:49 <srhb> szhwump: I don't use stack myself, so someone else might be more knowledgable :-)
04:06:05 <dysfun> .stack-work
04:06:17 <maartinex> which testing library or framework should i use for my little project ?
04:06:47 <srhb> reino4477: Data.Text.Lazy.Encoding iirc.
04:07:14 <reino4477> thx
04:07:21 <szhwump> srhb: do you never do that though? even if you want to test out something quickly, do you always set up a project?
04:07:43 <srhb> szhwump: I don't use stack at all, I use Nix, so I just spawn a shell with the packages I need.
04:07:46 <szhwump> (assuming the repl isn't enough)
04:07:55 <maartinex> https://hackage.haskell.org/package/HUnit ? 
04:08:14 <srhb> szhwump: (I have a gwp (ghc with packages) shell alias than I can use like: gwp lens aeson text mtl and get a shell with ghc with those packages immediately)
04:08:25 <maartinex> i use nix too, no compling and liked it :D
04:08:45 <MasseR> srhb: .. that's not a bad idea actually
04:08:53 <srhb> MasseR: Well, it's just an alias for..
04:09:12 <srhb> MasseR: nix-shell -p "pkgs.haskell.packages.ghc802.ghcWithPackages (pkgs: with pkgs; [ lens aeson text mtl ])"
04:09:23 <srhb> MasseR: Which indeed is really useful :)
04:09:24 <szhwump> that sounds amazing
04:09:39 <maartinex> srhb, yes sir
04:09:42 <MasseR> srhb: yeah, I have similar lines in my command history, didn't think of aliasing it though
04:09:53 <srhb> MasseR: :)
04:10:11 <maartinex> you can use cabal2nix etc..
04:10:18 <srhb> MasseR: Well, I'm also lying. it's actually a function. I can do gwp -c 7.10.2 lens mtl aeson
04:10:24 <maartinex> i followed this, https://www.google.com.tr/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwi109qp1uLTAhVCCZoKHZndA0gQFggmMAA&url=https%3A%2F%2Fgithub.com%2FGabriel439%2Fhaskell-nix&usg=AFQjCNGIHfBySfZpQhLm1nXhz-iTacpAIg&sig2=gVu5MK1gxBbOvjSOMMHN9A
04:10:29 <srhb> MasseR: Which is occasionally useful.
04:10:33 <maartinex> sorry , https://github.com/Gabriel439/haskell-nix
04:11:26 <szhwump> so do I need to get NixOS for this?
04:11:39 <MasseR> szhwump: no, only nix the package manager
04:11:54 <szhwump> and does this do away with having to use stack somehow?
04:12:19 <MasseR> szhwump: to be honest, I find stack to be much, much easier
04:12:23 <srhb> szhwump: You can use both if you like.
04:12:25 <dysfun> me too
04:12:26 <srhb> I prefer nix.
04:12:42 <dysfun> stack is way way easier than understanding nix
04:12:46 <srhb> Agreed.
04:12:52 <szhwump> MasseR: so can you please answer that question then^
04:12:54 <szhwump> do you never do that though? even if you want to test out something quickly, do you always set up a project?
04:13:07 <MasseR> szhwump: no
04:13:20 <maartinex> szhwump, no you dont need at all, i installed nix on vagrant ubuntu and works as same on nixos
04:13:23 <MasseR> If I want to test something quickly I use the nix-shell solution above, or install packages inside my stack sandbox
04:13:32 <MasseR> stack --resolver=lts-7.14 install foo
04:13:36 <MasseR> stack --resolver=lts-7.14 ghci
04:13:43 <MasseR> import Foo.Bar
04:13:55 <szhwump> huh, neat
04:14:31 <maartinex> you guys find nix complicated too ?
04:14:36 <dysfun> it is
04:14:37 <MasseR> You can also create scripts with both nix and stack
04:14:40 <MasseR> #!/usr/bin/env stack
04:14:41 <dysfun> and the nix language is horrible
04:15:00 <maartinex> finally someone agreed with me :D yeah it is definetly horrible
04:15:18 <MasseR> --stack --resolver=lts-7.14 --install-ghc runghc --package brick --package vector
04:15:59 <hpc> nix is fairly close to being a good configuration language, to be fair
04:16:04 <maartinex> MasseR, instead of repeating --package ... , you could write little script :D
04:16:19 <hpc> it just needs types and a clear delineation between pure expressions and things that affect the system state
04:16:29 <MasseR> maartinex: but those are usually little scripts ;)
04:16:39 <MasseR> I don't need little scripts to handle package management for my little scripts
04:17:04 <maartinex> hpc, maybe it is only for defining configuration.nix etc.. in /etc/nixos
04:17:17 <maartinex> the rest for nix i dont know
04:18:00 <hpc> it does system configuration and packaging
04:18:16 <maartinex> i can do something with chef etc.. but those are more heavy
04:18:21 <hpc> i don't have much experience with the packaging side of things either
04:18:36 <hpc> it's 100% a worse system configuration language than puppet though
04:18:45 <hpc> which has both of the things i mentioned above
04:19:10 <maartinex> i have experience in chef but never tried puppet but i heard it is good too
04:20:16 <hpc> the way i would put it is, in the same way haskell is a pure functional language, puppet is a pure imperative language
04:20:21 <maartinex> i had packaged some software in nix though but it was very complicated for me :D
04:20:58 <ertes-w> maartinex: nix has a learning curve, but unlike haskell the curve actually becomes level at some point, so you won't find yourself constantly learning new things once you've mastered the basics =)
04:21:02 <ertes-w> also it pays off
04:21:09 <maartinex> i told them and agreed with me too, they have a lot of tools but documentation is poor or weird
04:21:11 <ertes-w> if only for not having to compile everything
04:23:10 <dysfun> is there something better than 'plugins' for loading haskell code at runtime? is there a ghci api?
04:23:35 <ertes-w> dysfun: during development or in production?
04:23:45 <dysfun> i'd be interested in both
04:23:49 <maartinex> ertes-w, sen turk degil miydin bu arada ? :D
04:24:18 <hpc> dysfun: at a low level there's sort of two options
04:24:19 <ertes-w> dysfun: for the former i have a project called rapid that you can use…  for the latter i would just use separate processes
04:24:27 <ertes-w> @package rapid
04:24:27 <lambdabot> http://hackage.haskell.org/package/rapid
04:24:40 <ertes-w> maartinex: sorry, i don't speak turkish
04:24:52 <hpc> dysfun: you can use dlls as plugins, or a more eval-ish approach with hint
04:24:56 <hpc> (haskell interpreter)
04:25:02 <maartinex> are you turkish ?
04:25:08 <maartinex> :P :D
04:28:40 <merijn> #haskell needs a name to nick map...
04:30:26 <dysfun> okay, i've got plenty to look at. thanks for the help
04:35:03 <srhb> merijn: Just change your legal name to whatever your nick is. Problem solved!
04:35:20 <merijn> srhb: I don't have to, my nick is already my name, but that doesn't help me find other people :p
04:35:35 <merijn> srhb: I've learned that badgering people on IRC is far more effective than email/tickets ;)
04:35:41 <srhb> merijn: Well, I obviously meant to make it an official policy of the channel. ;-)
04:35:45 <srhb> Agreed!
04:36:03 <merijn> srhb: Might wanna reconsider your nick, then ;)
04:36:30 <Philonous> Maybe that's his actual name?
04:37:09 <merijn> Philonous: Pretty sure it is her name, minus some vowels and most of the last name :p
04:38:09 <Philonous> Ugh, I need to get into the habit of using neutral pronouns. Is "they" still the appropriate choice?
04:38:40 <merijn> Philonous: I just use rote memorisation of people here :p
04:42:02 <srhb> merijn: You're right :-)
04:42:31 <srhb> It sounds like shrub when pronounced though, which I like, so I might just check if I can legally use that!
04:43:04 <Philonous> Can't we just have links to github pages as IRC-nicks? :>
04:44:51 <quchen> github.com/quchen :-þ
04:45:05 <merijn> github.com/merijn :p
04:45:41 <tdammers> github.com/tdammers
04:45:43 <tdammers> yay
04:46:50 <srhb> github.com/srhb >>
04:46:59 <srhb> We're obviously very clever.
04:48:23 <Philonous> OK, fair enough, maybe I should just make the names clickable in my IRC client so it sends me to the appropriate page 
04:48:28 <srhb> Philonous: (I use "they" by the way, if /who doesn't seem obvious)
04:49:39 <merijn> On a more practical (well...) haskell topic, suggestions how this could be written more nicely?
04:49:46 <lpaste> merijn pasted “No title” at http://lpaste.net/355355
04:49:56 <merijn> Specifically making line 3 suck less
04:50:46 <Philonous> I think line 3 is fine, except that I don't see where i comes into scope
04:51:01 <merijn> Philonous: oh, because I deleted it when I simplified it :p
04:51:23 <Philonous> Maybe newline/indent the parts of the tuple? Not sure
04:51:45 <merijn> Philonous: Suggestions on how to clean up the typing instead are welcome too :p
04:56:09 <Philonous> Although depending on how you use it, sticking the actions into a record instead of a pair might help with understanding. Memorizing which part of the tuple did what is taxing when producer and consumer of it are far apart 
05:00:38 <Philonous> There is currently no way to get singletons for Symbols, as in (sing :: Sing "abc"), is there ?
05:02:27 <Philonous> Oh wait, evidently there is
05:02:29 <Philonous> Never mind
05:04:57 <quchen> Is there a way I can tell Stack to run the benchmarks using certain arguments? I usually have a shell script thar runs Criteion with e.g. an --output folder, but I think »stack bench« ought to do this on its own somehow.
05:08:22 <merijn> Philonous: Not really the issue here, because I basically have "syncGeneral :: (Int -> IO (IO (), IO ())) -> String -> Int -> Benchmark" and then I have specialised versions for different primitives. So the tuple is immediately consumed and only exists to abstract a way a bunch of boilerplate :)
05:08:48 <merijn> Philonous: i.e., the actual function is "syncMVar = syncGeneral $ \i -> do ..." immediately consuming the tuple again
05:09:02 <Philonous> Yes, then it's not problem I think
05:09:08 <Philonous> s/not/no
05:10:45 <Philonous> Richard Eisenberg should hurry up and implement pi types already, mucking around with singletons is so painful. 
05:10:51 <Philonous> Maybe I can bribe him...
05:44:50 <jchia_1> I have many top-level names for monads that have the same context and differ only in the return value, e.g. 'foo :: (MonadState Int m, MonadParsec e s m, Token s ~ Char) => m Int' and 'bar :: (MonadState Int m, MonadParsec e s m, Token s ~ Char) => m (Int, Int)'. Is it possible to extract the '(MonadState Int m, MonadParsec e s m, Token s ~ Char) => m _' into a type synonym somehow, or something like that so that I don't have to keep re
05:44:51 <jchia_1> peating the same lengthy context in the code? It seems that type synonyms cannot have constraints. Is ConstraintKinds relevant?
05:45:53 <jchia_1> I mean "return type" instead of "return value"
05:47:45 <ski> jchia_1 : try `type Foo a = forall m e s. (MonadState Int m, MonadParsec e s m, Token s ~ Char) => m a' ?
05:49:09 <ski> (or `type Foo m e s a = (MonadState Int m, MonadParsec e s m, Token s ~ Char) => m a', if you prefer being able to "access" `m',`e',`s')
05:49:50 <jchia_1> ski: Thanks, it seems that the existential quantification was needed.
05:49:56 <jchia_1> I'm not sure why, though.
05:50:05 <Philonous> You can also just synonym the constraint: type Foo m e s a = (MonadState Int m, MonadParsec e s m, Token s ~ Char), adn then use it like forall e s m. (Foo e s m) => m ()
05:50:33 <Philonous> (needs -XConstraintKinds though)
05:50:42 <ski> jchia_1 : that's a universal quantification, not an existential quantification
05:52:37 <ski> you'd use existential quantification, if you'd go with Philonous variant, only not parameterizing on `e',`s', iow `Foo m = exists e s. (MonadState Int m, MonadParsec e s m, Token s ~ Char)', and then use `forall m. Foo m => m a' ..
05:52:50 <ski> .. except there is no `exists' keyword
05:53:04 <ski> (but conceptually this'd work)
05:53:49 <jchia_1> ski: I was under the impression that when forall is used in the code, it's because the ExistentialQuantification extension is being used, no?
05:54:16 <ski> (the point is that `(exists a. ..a..) -> ...' is equivalent to `forall a. (..a.. -> ...)', and also `(exists a. ..a..) => ...' is equivalent to `forall a. (..a.. => ...)' .. in this case, it's the latter equivalence that i referred to)
05:54:18 <c_wraith> jchia_1: only if it's being applied to a constructor
05:54:20 <merijn> jchia_1: No, there's others, such a RankNTypes and ExplicitForall and ScopedTypeVariables
05:54:28 <ski> jchia_1 : sometimes, sometimes not
05:54:43 <c_wraith> You can also encode existentials by CPS transforming with RankNTypes
05:55:05 <ski> jchia_1 : `ExistentialQuantification' enables one approach to *encode* `exists', by reformulating (via the equivalences i mentioned) into using `forall' instead
05:55:32 <ski> jchia_1 : there's also another encoding of `exists', that doesn't rely on the `ExistentialQuantification' extension (which imho is a misnomer)
05:56:01 <ski> (c_wraith mentioned the other encoding that's in use)
05:56:31 <ski> `forall' is always universal quantification, never existential quantification
05:56:38 <ski> if one writes
05:57:21 <ski>   data QueueOps a = forall q. MkQO (q,a -> q -> q,q -> Maybe (q,a))  -- empty queue, enqueue, dequeue
05:57:21 <jchia_1> I think I need to read a paper or a textbook on this.
05:57:44 <ski> then this means that the type signature of the data constructor `MkQO' will be
05:58:01 <ski>   MkQO :: forall q. (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
05:58:11 <ski> in order to construct a value of type `QueueOps a'
05:58:26 <ski> .. in fact, since this works for *any* type `a' (the parameter), it's really
05:58:30 <ski>   MkQO :: forall a q. (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
05:58:37 <ski> however, the type signature
05:58:41 <ski>   MkQO :: forall a. forall q. (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
05:58:56 <ski> is equivalent, via the equivalence i mentioned, to
05:59:06 <ski>   MkQO :: forall a. (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
05:59:37 <ski> so that a value of type `QueueOps a' conceptually wraps a value of type `exists q. (q,a -> q -> q,q -> Maybe (q,a))' -- and there's your existential !
06:00:01 <ski> the existential `exists q. ..q..' here is encoded, by means of a `forall'
06:00:30 <ski> more specifically, the data constructor `MkQO :: (exists q. ..q..) -> ...' is encoded as `forall q. (..q.. -> ...)'
06:00:36 <ski> jchia_1 : does that make any sense ?
06:00:36 <Unode> Hi all, someone was asking about stack versions the other day. Can someone help me understand this dependency failure: "base-4.9.1.0 must match >=4.5 && <5 && <0"
06:00:59 <ski> jchia_1 : would it help if i tried to give some intuition of what a type `exists q. ..q..' means ?
06:01:15 <c_wraith> Unode: it means something has declared a broken dependency.  Nothing should depend on base < 0
06:01:31 <ski> (`exists q. ..q..' is the actual type that i'd call an "existential type")
06:01:34 <Unode> c_wraith: I'm wondering where is this coming from.
06:01:59 <Unode> On my cabal I simply have 'base' without a version specified.
06:02:12 <c_wraith> Unode: some transitive dependency somewhere.  I'd know how to track it down using cabal, but not stack.
06:03:24 <Unode> c_wraith: ok, thanks. Knowing how to handle these would be helpful.
06:03:30 <Unode> I don't really know what to do from here.
06:03:45 <c_wraith> see if there's a verbose flag.
06:03:54 <lpaste> merijn pasted “Tight monadic loop?” at http://lpaste.net/355357
06:04:03 <merijn> I need some extra eyeballs
06:04:04 <c_wraith> Cabal will tell you exactly where every constraint comes from if you add -v
06:04:20 <merijn> Will that loop run efficiently, e.g, in constant space?
06:04:32 <c_wraith> in IO, yes
06:04:39 <merijn> c_wraith: It's IO, yes
06:04:53 <c_wraith> well, assuming n and i are Int or Integer
06:04:59 <merijn> Also yes :)
06:05:08 <c_wraith> then yeah, that should be constant space
06:05:15 <merijn> Just a spinloop on atomic-primops counter
06:08:41 <Unode> c_wraith: verbose doesn't add much :(
06:09:56 <merijn> Unode: "-v3" is what you want for troubleshooting cabal
06:10:05 <merijn> oh, wait, stack...ignore me
06:10:11 <Unode> :)
06:10:16 <c_wraith> ah, I can never remember if cabal wants -v3 or -vvv
06:10:39 <c_wraith> so I always try both
06:16:23 <merijn> eh...
06:16:36 <jchia_1> ski: Thanks. I think I lack background understanding of this topic. Is this something like set theory where the items are types?
06:16:38 <merijn> This is a new GHC error...
06:16:56 <merijn> "Undefined symbols for architecture x86_64:
06:16:59 <merijn>   "_add_and_fetch_word", referenced from:"
06:17:14 <jchia_1> ski: And I understand the exists and forall the same way as in set theory?
06:17:18 <c_wraith> that looks like a linker error
06:17:38 <merijn> ah, found the issue, I think
06:17:59 <merijn> atomic-primops-foreign is broken
06:18:54 <merijn> Or rather, bits-atomic is, I guess
06:19:28 <c_wraith> only a 32-bit version of it?
06:20:04 <merijn> c_wraith: bits-atomic supposedly uses GCC's builtin atomics, but on OSX I don't have GCC, of course. Somehow it compiled/installed but seems to refer to symbols that don't exist when linking
06:20:25 <c_wraith> Ah, that's a bit of an issue.
06:20:41 <merijn> meh
06:20:41 <merijn> I'll just stick to atomic-primops then
06:21:02 <jchia_1> Is there something like withReaderT for StateT?
06:21:19 <jchia_1> maybe lens is needed?
06:21:35 <ski> jchia_1 : they are similar to the corresponding quantifiers in logic
06:22:06 <ski> jchia_1 : a value having type `forall a. ..a..' means that for any type `a', it can be treated as having type `..a..'
06:22:35 <jchia_1> ski: So the '=>' corresponds to the implies symbol (->) from logic?
06:22:54 <srhb> @index withStateT
06:22:54 <lambdabot> Control.Monad.Trans.State.Strict, Control.Monad.Trans.State.Lazy, Control.Monad.Trans.State
06:23:15 <jchia_1> srhb: How come mtl doesn't have it?
06:23:23 <srhb> jchia_1: Because it's a transformers thing.
06:23:25 <ski> jchia_1 : e.g. `Nothing' has type `forall a. Maybe a'. this means that e.g. picking `a' as `Either String (Int -> IO [b])' (assuming `b' is in scope), we *can* treat `Nothing' as having type `Maybe (Either String (Int -> IO [b]))'
06:23:28 <c_wraith> jchia_1: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Strict.html#v:withStateT
06:23:34 <srhb> ... guess not.
06:23:44 <c_wraith> that sure looks like mtl has it
06:23:47 <srhb> Indeed. :)
06:24:06 <ski> jchia_1 : `length :: forall a. ([a] -> Int)' means that for any type `a', if we apply `length' to an argument of type `[a]', then the result will have type `Int'
06:24:21 <c_wraith> jchia_1: Note that if you want a type-changing variant, then you do want lens.  That's what the zoom function in lens does
06:24:35 <lemonxah> any big companies running haskell?
06:24:39 <lemonxah> for more than just 1 system
06:24:54 <jchia_1> c_wraith: OK. Somehow my local hoogle doesn't show it.
06:24:55 <c_wraith> that seems like a weird qualification
06:24:55 <ski> jchia_1 : otoh, a value having type `exists a. ..a..' means that there *exists* some type `a' such that the value actually has type `a' .. but we've currently forgotten which type `a' that was
06:25:14 <jchia_1> ski: I think I understand the basic meaning
06:25:20 <c_wraith> lemonxah: but even with that weird qualification, the most obvious case is facebook.
06:25:38 <jchia_1> c_wraith: I do want type changing, e.g. focusing on fst of a tuple.
06:25:47 <c_wraith> jchia_1: then yeah, you want zoom from lens
06:25:51 <lemonxah> no i meant like some people use haskell for like 1 small thing no eco system 
06:26:00 <ski> jchia_1 : `length :: (exists a. [a]) -> Int' means that as long as there *exists* some type `a' such that the argument has type `[a]', then applying `length' to that argument will yield a result of type `Int'
06:26:01 <lemonxah> if that makes sense maybe i am just not asking it correctly
06:26:07 <c_wraith> lemonxah: facebook uses haskell for several large things
06:26:46 <jchia_1> ski: Haskell has 'forall'. Can you type 'exists' in haskell?
06:27:00 <ski> jchia_1 : this is another valid way to think about the type of `length', which hopefully illustrates the logical equivalence between `(exists a. ..a..) -> ...' and `forall a. (..a.. -> ...)' (and similarly for `=>' instead of `->') that i mentioned
06:27:17 <c_wraith> jchia_1: technically...  ghc has 'forall'.  UHC has an extension that enables 'exists', but it's not very useful.
06:27:25 <Grisha> how do best I type-parameterize a function a -> b -> b -> … -> b -> c (n times b, including n=0)?
06:27:26 <c_wraith> jchia_1: Haskell as a standard has neither.
06:27:50 <c_wraith> Grisha: isn't that exactly what lists are for?  a -> [b] -> c ?
06:28:02 <ski> jchia_1 : no, but imho, it helps to think concetually in terms of such an `exists' quantifier (as c_wraith says, UHC (and LHC) supports it, but only in a restricted way, that's not that useful)
06:28:07 <Grisha> c_wraith: you’re right, omg
06:28:15 <c_wraith> Grisha: :)
06:28:42 <Grisha> c_wraith: I’m deeply in type families now, started thinking about type-valued lists
06:29:06 <srhb> lemonxah: Facebook, Galois, for instance.
06:29:10 <srhb> Woops, lag.
06:29:23 <Grisha> c_wraith: on a second thought
06:29:32 <ski> jchia_1 : just like `=>' (with left operand being a constraint) corresponds in some sense to `(->)', i find it helpful to also postulate a construction `*>', corresponding to `(,)'
06:29:56 <sullyj3> So, I've googled a bit, and all the methods I've seen of getting the text of a web page have been severely wordy. Is there anything that comes close to python's ```import urllib.request; with urllib.request.urlopen(url) as response: html = response.read()```?
06:30:04 <Grisha> c_wraith: I need a family of functions that (depending on the governing type) work on zero, one, two or more String inputs
06:30:23 <ski> jchia_1 : given a value of type `Cxt => T', *if* you can *provide* evidence of `Cxt', you can treat it as a value of type `T'
06:30:30 <c_wraith> Grisha: oh, so you want the count to be determined by some other factor?
06:30:48 <ski> jchia_1 : given a value of type `Cxt *> T', you're provided *both* with evidence for `Cxt', and can get value of type `T'
06:31:32 <ski> jchia_1 : `=>' would usually be preceded by a `forall'. and `*>' would usually be preceded by an `exists'
06:31:53 <Grisha> c_wraith: exactly
06:32:49 <Grisha> c_wraith: depending on whether a private address, business, government and so on, my makeAddress func should accept different number of fields which are to be combined into the final address
06:33:02 <ski> jchia_1 : the logical equivalence here is between `(Cxt *> T) -> U', and `Cxt => (T -> U)' .. you can think of this as some kind of currying, roughly (which is also how you can think of the equivalence between `(exists a. ..a..) -> ...' and `forall a. (..a.. -> ...)')
06:33:09 <ski> jchia_1 : does this make any sense ?
06:33:12 <Grisha> c_wraith: but there might be another solution for that I guess
06:33:51 <ski> (btw, note that `(T,U) -> V' is equivalent to `T -> (U -> V)', via currying)
06:34:01 <c_wraith> Grisha: if you know which you're creating ahead of time, you're probably best off just having different functions for each.  If you don't know which you're creating ahead of time, you're getting into the realm of dependent types.
06:34:17 <Grisha> c_wraith: i’d like to explore the realm
06:34:23 <Grisha> since the rest of my code is already there
06:34:28 <Grisha> but it’s new to me
06:34:44 <c_wraith> It's pretty painful in haskell right now.  There's a reason they call it hasochism
06:35:25 <c_wraith> And that's related to why I'm putting off learning the details until -XDependentHaskell is up and running. :)
06:35:38 <sullyj3> Grisha: Have you heard of Idris?
06:35:42 <Grisha> c_wraith: I could join the dark side alright
06:35:47 <Grisha> sullyj3: just heard of it
06:35:55 <jchia_1> ski: I think I got the forall and exists conversion, but don't understand what the *> means.
06:36:39 <EvanR> dependent types may cause such side effects as brain exploding, antisocial mathematical behavior, or PhD's
06:36:45 <c_wraith> Grisha: all I know is that if you're planning to work with this stuff in current ghc, the singletons library does a lot of work for you.  https://hackage.haskell.org/package/singletons
06:36:58 <c_wraith> I do *not* know how to use it. :)
06:36:59 <Grisha> c_wraith: I see, thanks a lot
06:37:01 <ski> jchia_1 : consider `data Showable = forall a. Show a => Wrap a'. this means that
06:37:14 <ski>   Wrap :: forall a. (Show a => (a -> Showable a))  -- brackets added for emphasis
06:37:20 <ski> er, sorry, should be
06:37:24 <ski>   Wrap :: forall a. (Show a => (a -> Showable))  -- brackets added for emphasis
06:37:25 <Grisha> c_wraith: does it go beyond type families and funcdeps?
06:37:31 <ski> (no `a' parameter for `Showable'
06:37:33 <jchia_1> I have a more concrete problem, though, about why GHC sometimes requires forall and sometimes not: http://lpaste.net/355358
06:37:35 <ski> )
06:37:45 <ski> jchia_1 : anyway, using one equivalence, we get
06:37:59 <ski>   Wrap :: forall a. (Show a *> a) -> Showable)
06:38:11 <c_wraith> Grisha: it gives you tools to make types depend on runtime values.  That's all I know about it.
06:38:29 <ski> you can think of the argument of type `Show a *> a' here as both providing evidence for `Show a', as well as actually giving a value of type `a'
06:38:33 <merijn> hmmm
06:38:43 <ski> next, using the `exists'-`forall' equivalence, we get
06:38:53 <ski>   Wrap :: (exists a. (Show a *> a)) -> Showable
06:39:07 <Grisha> c_wraith: my problem is much more humble, I guess. I’ve got a function makeAddress that accepts a number of Strings and produces a String. The number of Strings is parameterized by a type
06:39:19 <ski> which shows that the type `Showable', conceptually, is wrapping the type `exists a. Show a *> a'
06:39:27 <Grisha> c_wraith: I thought it was a straight-forward exercise in type families
06:39:42 <EvanR> Grisha: you an use typeclasses to encode what this number is
06:39:55 <c_wraith> Grisha: well..  Sort of.  You also need the implementation to vary, which implies you'll need a class
06:40:00 <Grisha> EvanR: I’m doing it currently
06:40:10 <Grisha> yes, ppl, that’s what I’m doing
06:40:42 <zaquest> Grisha, you probably could use something like fixed-vector for this specific task, avoiding singletons.
06:40:46 <Grisha> I’ve got smth like `class Address a where type ParametersOfAddressMaker a`
06:41:04 <ski> jchia_1 : in the case of `bar :: (Monad m,Num b) => b -> m b', that's an *abbreviation* of `bar :: forall m n. (Monad m,Num b) => b -> m b', which kicks in at the "toplevel" of a type *signature* (right after the `::'), and which automatically `forall'-quantifies all type variables which appear to be free in the type signature, and which aren't already in scope
06:41:24 <ski> jchia_1 : for an example of the exception at the end, consider
06:41:27 <ski> @src Functor
06:41:28 <lambdabot> class Functor f where
06:41:28 <lambdabot>     fmap :: (a -> b) -> f a -> f b
06:41:36 <ski> where, the method signature abbreviates
06:41:37 <Grisha> and makeAddress :: Address a => Proxy a -> (ParametersOfAddressMaker a) -> String
06:41:50 <ski>     fmap :: forall a b. (a -> b) -> f a -> f b
06:42:11 <ski> (note `f' is not included in the `forall', since `f' is already in scope, bound in the head of the `class' declaration)
06:43:07 <stphrolland> liste: about aeson and defining ToJSON and FromJSON when some field name are problematic, I have this error I cannot deal with:  Failed to load interface for ‘Data.Aeson.Types.Internal’     it is a hidden module in the package ‘aeson-1.0.2.1’
06:43:14 <ski> however, if we consider `fmap' not as a *method* signature belonging to `Functor f', but as "just another type signature", then we add the class "head" `Functor f' as a constraint, and universally quantify the class parameter(s) :
06:43:23 <ski>   fmap :: forall f. Functor f => forall a b. (a -> b) -> f a -> f b
06:43:27 <ski> which is the same as
06:43:36 <ski>   fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
06:43:59 <Grisha> stphrolland: you’ve got to include it explicitly in the dependency list in your .cabal file
06:44:00 <ski> jchia_1 : ok ?
06:44:17 <Grisha> stphrolland: i.e. the module `aeson`
06:45:01 <stphrolland> aeson is already in build-depends section of my cabal file ?!
06:45:19 <ski> (if the `class' head has any context, like in `class Eq a => Ord a where ...', then that context, here `Eq a', is not added to the signatures of the methods, only the actual class we're defining, applied to the parameters, here `Ord a')
06:45:33 <jchia_1> ski: I still don't know what *> really means, but I get that for type declarations, GHC automatically adds the forall. Why doesn't it do it for type synonyms, though? Is there a good logical reason?
06:45:55 <Grisha> stphrolland: do you have separate library and executable sections in .cabal?
06:46:13 <stphrolland> yes
06:46:19 <stphrolland> it is a stack project
06:46:45 <jchia_1> ski: I mean "type signature" instead of "type declaration"
06:47:38 <Grisha> stphrolland: that’s strange-o-matic, I usually get that error if the package has been installed as a dependency of another, but is not explicitely mentioned in .cabal
06:48:07 <ski> jchia_1 : if `exists' ever get added to GHC, it's not clear why an apparently unbound tyvar in a type synonym should abbreviate a `forall' quantificsation of it, rather than an `exists' quantification of it ..
06:48:20 <Grisha> stphrolland: so `aeson` should be in the right part, be it executable or library
06:48:29 <Grisha> stphrolland: depending on who’s using it
06:48:44 <ski> jchia_1 : the same thing also goes for `data' and `newtype', btw
06:50:12 <ski> jchia_1 : sometimes when one wants to declare a type, with some locally bound tyvar, one wants (conceptually) an existential quantification, sometimes a universal quantification (in both cases over one (or several) arguments of a data constructor, in the case of `data' and `newtype')
06:50:13 <stphrolland> it is in library, and no mention of it in executable, becuase my mian is relatively simple, calling the library
06:50:32 <Grisha> stphrolland: and the error pops up when compiling what?
06:51:14 <ski> jchia_1 : otoh, for type signatures, it seems to be much more common to want universal rather than existential quantification, and so the former is allowed to be implicit (as long as it's quantified at the "toplevel", as i said)
06:51:16 <stphrolland> stack build, it compile the whole project, Main and Lib
06:51:56 <Grisha> stphrolland: it’s usually at least to different compile runs, one for Main.hs and one for Lib.hs. Which of those causes the error exactly?
06:51:57 <jchia_1> ski: OK
06:52:09 <ski> jchia_1 : btw, in some ways, i might prefer not having implicit quantification at all (whether universal or existential) .. but that's not the path Haskell took historically
06:52:21 <Grisha> stphrolland: s/to/two
06:52:55 <ski> (it would be a bit more verbose, and require newbies to grasp polymorphism (a polymorphic value is one which has a universal type) more fully, earlier)
06:54:14 <ski> (`Nothing' and `length' are polymorphic values. `forall a. Maybe a' and `forall a. ([a] -> Int)' i call "universal(ly quantified) types". note that a "polymorphic type" would be something else (namely a type having a *kind* of shape `forall k. ..k..'))
06:54:55 <c_wraith> ski: that would also require ditching non-GADT data syntax.  Which I suppose you'd be fine with..
06:55:09 <stphrolland> Grishna: when it compiles one of the files used by Lib.hs
06:56:08 <ski> jchia_1 : .. i could try to explain a bit more about universal and existential quantification, their relation and uses, and how it's related to `ExplicitForall',`PolymorphicComponents',`Rank2Types',`RankNTypes',`ExistentialQuantification',`ScopedTypeVariables' (some of those are now obsolete)
06:56:27 <Grisha> stphrolland: are those files listed in the `library` section in your .cabal file? if so, is `aeson` included in `build-depends` in that section?
06:56:54 <ski> jchia_1 : .. but i need to leave, presently. if you'd like to continue the conversation later, try to grab hold of me ?
06:57:19 <ski> c_wraith : why not something like `data forall a. Maybe a = Nothing | Just a' ?
06:57:27 <jchia_1> ski: Thanks for the explanation of forall and exists. Sure, I'll ping you if I have questions about these topics.
06:58:00 <c_wraith> ski: that doesn't make it very clear that the Nothing constructor is universally quantified.
06:58:37 <ski> for every type `a', `Nothing' has type `Maybe a'
06:58:42 <ski> seems pretty clear to me ..
06:59:11 <ski> (and, for every type `a', if `x' has type `a', then `Just x' has type `Maybe a')
06:59:37 <c_wraith> ski: it's really not an improvement over the current situation.  GADT syntax actually spells those things out explicitly, rather than making you memorize translation rules.
07:00:07 <ski> well, i won't argue against that :)
07:00:54 <EvanR> http://lpaste.net/355359 isnt this some kind of fold...
07:00:59 <ski> (the main gain of the traditional notation is (a) similarity with BNF; (b) not having to repeat the return type of the data constructors)
07:01:15 <c_wraith> ski: I also consider the concision to be an advantage
07:01:31 <ski> yes, that's the (b) part
07:01:34 <Philonous> Grisha, Here's one way of accomplishing what you wanted: https://gist.github.com/Philonous/637928bffd918ad5a6fcffb5f26a8d3f
07:01:47 <ski> and, i suppose, slightly shorter way to specify argument types ..
07:02:05 <c_wraith> EvanR: that's a foldl
07:02:19 <Grisha> Philonous: oh great, thank you!
07:02:20 <ski> c_wraith : .. only saying that i don't think "require explicit binding" couldn't be combined in a reasonably sensible way with the traditional notation
07:02:30 <Philonous> Grisha, I'm giving it the the argument type per address type, but you could just as well return nats and take a length-indexed vector with that length
07:02:33 <c_wraith> EvanR: and in particular, reverse = foldl (flip (:)) []
07:02:39 <EvanR> c_wraith: i got the effect with a foldl (flip (:)) but doesnt this traverse the first list
07:02:39 <Grisha> Philonous: I don’t understand it at the first glance, but gonna try to wrap my head around it
07:02:48 <EvanR> before even beginning
07:02:54 <c_wraith> no
07:03:08 <c_wraith> EvanR: they have the same behavior
07:03:21 <EvanR> uhm
07:03:38 <EvanR> oh ok
07:03:58 <EvanR> yeah i cant get anything out of the result until i go through the whole list
07:04:02 <EvanR> crud
07:04:09 <ski> btw, otoh i think `data Expr a where Val :: a -> Expr a; App :: Expr (a -> b) -> (Expr a -> Expr b)' is confusing, since the first `a' doesn't have anything to do with the `a' in `App' (and technically not with the `a' in `Val' either)
07:04:24 <c_wraith> EvanR: that's inherent in [].  There's no way to get the last element without traversing everything before it
07:05:11 <c_wraith> EvanR: someone *did* write up a lazier reverse a while back, that would produce (:) constructors earlier.  But it took just as long to reach the values, so it didn't have much practical value.
07:05:14 <ski> for this reason i prefer `data Expr :: * -> * where ...', only mentioning explicit parameters in the "head" if i'm actually using that same parameter in the same position in the data constructor return types
07:05:38 <c_wraith> ski: I agree with that assessment
07:07:06 <ski> (i suppose one could imagine `data Foo :: _ where ...' for cases when one doesn't want to have to specify the argument kinds)
07:08:31 <Grisha> Philonous: would it work with zero Strings?
07:09:21 * ski disappears
07:09:51 <Rodenbach> 11 Mins, Functional Programming is outdated: https://www.youtube.com/watch?v=P0uAs9JRiqQ   – Peter van Roy. I think that guy was very involved in Oz.
07:10:45 <Philonous> Grisha, Sure, just set the argument type to ()
07:10:51 <Grisha> I see, thanks
07:11:15 <Philonous> Grisha, The way this is encoded you can make it take _any_ argument type, so (Int, String, Bool) would be fair game too
07:14:38 <Grisha> Philonous: and if there are zero args, would it be possible to make a constant out of it instead of a func?
07:15:13 <Philonous> Grisha, Yes. Gimme a minute, I'll show you how
07:15:26 <Grisha> Philonous: would be great
07:17:59 <Philonous> https://gist.github.com/Philonous/637928bffd918ad5a6fcffb5f26a8d3f
07:20:54 <jchia_1> I can apply Control.Lens.Zoom.zoom to a StateT but what about a MonadState where the StateT is somewhere in the middle of the stack? Is there something simple I can do for, say, ParsecT Dec Text (ConduitM Text (Int, Char) (SS.StateT (Int, HashMap (Int, Int) Text) m)) (), to change the 'state' part from '(Int, HashMap (Int, Int) Text)' to HashMap (Int, Int) Text?
07:21:37 <Catmaster26> Hi
07:21:41 <BoBIzASlOb> can somebody hack me and take down my internet?
07:21:44 <BoBIzASlOb> Please
07:21:48 <BoBIzASlOb> im begging you
07:21:55 <Catmaster26> Um
07:21:59 <Catmaster26> wot
07:22:10 <EvanR> clearly youre the same person
07:22:23 <BoBIzASlOb> I am with cat
07:22:27 <BoBIzASlOb> we are at school
07:22:32 <BoBIzASlOb> and take it down for us
07:22:35 <BoBIzASlOb> we got in troube
07:22:45 <Catmaster26> Um wot are you saying mate
07:22:56 <BoBIzASlOb> HACK ME
07:22:56 <BoBIzASlOb> HACK ME
07:22:56 <BoBIzASlOb> HACK ME
07:22:56 <BoBIzASlOb> HACK ME
07:22:58 <shiona> :D
07:24:43 <Grisha> Philonous: thanks a lot, I’m meditating over it
07:25:41 <hsk3> Grisha haskell is all about meditation
07:25:49 <Philonous> Grisha, Do you understand what's going on there or do you want me to elaborate?
07:26:09 <Grisha> Philonous: I kind of understand the idea, but have to look into the singleton library first
07:26:30 <ph88_> in attoparsec are there more ways i can make the parser fail, or only   fail :: String -> m a   ?
07:26:53 <lpaste> jimmy pasted “prompt” at http://lpaste.net/355361
07:26:57 <merijn> ph88_: empty
07:27:03 <merijn> :t empty
07:27:05 <lambdabot> Alternative f => f a
07:27:22 <merijn> ph88_: And, as a consequence also
07:27:24 <merijn> :t guard
07:27:25 <lambdabot> Alternative f => Bool -> f ()
07:27:34 <ph88_> what's empty ?
07:27:35 <sullyj3> hey guys, why is it that when I run main, my prompt message isn't printed until I've typed my input and hit enter, but when I run prompt from the repl it works as expected?
07:27:51 <ertes-w> Rodenbach: other than the usual bullshit reasoning people use against FP i couldn't find much else in that video
07:27:51 <sullyj3> sorry, I'm jimmy ^^^
07:27:54 <merijn> ph88_: Do you know MonadPlus?
07:28:05 <ph88_> no
07:28:28 <ph88_> what's guard as well ?
07:28:33 <merijn> ph88_: ok, basically Alternative is a Monoid on Applicative's
07:28:35 <ertes-w> "FP doesn't work as well as OOP in the real world, because look, i can point to many objects in this room, but you can't point to a single function"
07:28:38 <ertes-w> that kind of bullshit
07:28:46 <ph88_> oh ok
07:28:47 <glguy> sullyj3: buffering mode defaults are different in ghci. see hSetBufferingMode and hFlush
07:29:15 <merijn> ph88_: So you have "mappend :: Monoid m => m -> m -> m" and "mempty :: Monoid m => m" with mempty being the left and right identity of mappend
07:29:37 <glguy> ertes-w: pointing oriented programming sounds interesting
07:29:41 <merijn> ph88_: Alternative has "(<|>) :: Alternative f => f a -> f a -> f a" with "empty :: Alternative f => f a"
07:30:05 <stphrolland_> Grishna: it seems I fixed the error importing Data.Aeson.Types instead of Data.Aeson.Types.Internal, just for your information.
07:30:17 <sullyj3> glguy: perf thanks
07:30:21 <merijn> ph88_: Common class for things like parsers, where "empty <|> foo = foo = foo <|> empty"
07:31:02 <ph88_> so it just means the parser doesn't yield anything ?
07:31:15 <jchia_1> merijn: is <|> required to be associative like <>?
07:31:19 <merijn> jchia_1: Yes
07:31:34 <max3> this is probably a n00b question but how is it possible that Crypto.BCrypt returns True for validiatePassword for the same plain text but two different hashes
07:31:50 <jchia_1> merijn: So it's a law that you have to ensure when making an instance of Alternative, correct?
07:31:59 <merijn> jchia_1: Correct
07:32:44 <jchia_1> merijn: Is there a commonly-enough used thing that has both Alternative and Monoid instances?
07:32:56 <glguy> []
07:33:07 <ertes-w> more like pointing-oriented opinion persuation
07:33:10 <ertes-w> or POOP
07:33:24 <merijn> jchia_1: Also, attoparsec's Parser is both a Monoid and Alternative, iirc
07:33:34 <ph88_> merijn, what's guard then ?
07:34:14 <merijn> ph88_: "\b -> if b then pure () else empty"
07:34:16 <nshepperd> neither FP nor OOP work in the real world, because the real world isn't a program that you can modify by pure thought and pointing
07:34:23 <merijn> oh, attoparsec has a stupid monoid isntance
07:34:26 <Philonous> Grisha, Well, we want the _values_ Private and Business to be available at the type level, so the result type can depend on them. Unfortunately, Haskell doesn't allow that (yet). So instead we create new values SPrivate and SBusiness with the type (Sing private) and (Sing Business) respectively. They act as a sort-of bridge between values and types, because whenever we see SPrivate we know it has type (Sing Private), and whenever we see 
07:34:26 <Philonous> (Sing Private) we know the only possible value is SPrivate 
07:34:39 <nshepperd> none of the objects in my room have runnable methods either
07:34:56 <ph88_> merijn, i don't understand the difference between  pure ()  and  empty
07:35:01 <merijn> jchia_1: Trifecta's Parser shows an interesting distinction
07:35:08 <ertes-w> i've never told my apple to be eaten by me
07:35:12 <jchia_1> It seems that for [], <|> and <> mean the same thing. Is there something where they mean different things?
07:35:24 <Grisha> Philonous: I thought rather making Business and Private separate data types and dispatch on them
07:35:29 <Grisha> *about
07:35:48 <merijn> jchia_1: Yes, Trifecta, because it has "instance Monoid a => Monoid (Parser a)" and "instance Alternative Parser"
07:36:18 <Philonous> Grisha, So when we pattern match on the first argument and see that it is SPrivate, the type checker concludes that the type must have been (Sing Private), hence the type variable 'at' is Private, so the return type is (AddressParts at), which is String 
07:36:20 <merijn> jchia_1: So, for example, "foo <> foo <> foo" parser foo 3 times and then mappend's the results
07:36:35 <EvanR> oop is good for motivating new programmers to begin actual writing of code, convincing them that there is a tangible goal, to model real devices somehow
07:36:36 <jchia_1> merijn: I see the difference
07:36:36 <nshepperd> ph88_: mempty is 0, pure () is 1
07:36:41 <Philonous> (AddressParts Private), I mean
07:36:47 <merijn> jchia_1: Whereas "foo <|> bar <|> baz" first tries to parse foo, if it fails, it tries bar, etc.
07:36:59 <EvanR> the difficulties that come after this point are not apparent and not part of the narrative
07:37:06 <merijn> jchia_1: Also, Maybe is different, I think
07:37:07 <jchia_1> merijn: So there's no way to intuit what <|> or <> do for each case, and you just have to experiment or read tho docs to make sure, right?
07:37:13 <merijn> jchia_1: Right
07:37:20 <ph88_> nshepperd, i don't understand that either .. what does 0 and 1 mean in context of attoparsec
07:37:42 <Philonous> Grisha, You can make them types (i.e. *) and use classes, that's the classical way of achieving this, yes. It also has the advantage of being open, i.e. you can add more types later 
07:37:44 <merijn> jchia_1: In fact, fun fact: each applicative is, by definition at least 2 different Monoids :)
07:38:06 <merijn> jchia_1: Since you can trivially define "mempty = pure mempty; mappend = liftA2 (<>)"
07:38:21 <merijn> jchia_1: And, of course, "mappend = liftA2 (flip (<>))"
07:38:48 <nshepperd> ph88_: empty is a parser that always fails. it produces 0 outputs. pure () is a parser that always succeeds. it produces 1 output, namely ()
07:38:58 <Philonous> Grisha, You couldn't pattern-match on them then, though, because you can only pattern match on values, not on types. 
07:39:30 <ph88_> nshepperd, is    fail    like   emtpy + i can supply a string ?
07:40:25 <nshepperd> ph88_: yeah, normally parsers let you fail with an error message
07:40:50 <nshepperd> I suppose empty uses a default error message of some kind
07:40:56 <ph88_> ok
07:44:58 <Grisha> Philonous: thanks a lot once again, have to disconnect now
07:45:06 <Philonous> yw
07:45:11 <ertes-w> EvanR: problem is that people tend not to switch paradigms, because they don't think of the problems they face as inherent to their paradigm…  instead they start coming up with "solutions" in order to "fix programming"…  before you know it, you have factories, facades and directory structures so deep that you could drown trying to find a single semantically meaningful line among the "solution" noise
07:45:53 <jchia_1> :t (take 0) (many "a")
07:45:55 <lambdabot> [[Char]]
07:46:00 <EvanR> well there is semantic meaning to oop
07:46:06 <jchia_1> :t fmap (take 0) (many "a")
07:46:08 <lambdabot> [[Char]]
07:46:12 <ertes-w> EvanR: nice one =)
07:46:15 <jchia_1> How come with fmap it's still the same type?
07:46:21 <EvanR> theory of objects, etc
07:46:32 <EvanR> not sure how much that matters in practice
07:46:41 <ertes-w> anyway, enough ranting for today =)
07:47:52 <jchia_1> Never mind
07:48:45 <jchia_1> How can I understand what some & many mean for []? I'm looking at the default definition but not getting anything.
07:49:31 <merijn> jchia_1: Honestly, some/many aren't really useful for []
07:49:38 <merijn> jchia_1: They simply result in infinite loops :)
07:49:42 <jchia_1> merijn: I got an infinite loop.
07:49:52 <merijn> jchia_1: Right, hence why not so useful ;)
07:50:13 <jchia_1> merijn: Even if I (take 1) I get an infinite loop.
07:50:16 <merijn> jchia_1: some/many only really make sense for Alternative's that fail after some number of repetitions
07:50:16 <nshepperd> i don't think they mean anything, per se
07:50:28 <merijn> jchia_1: For example, for parsers
07:50:50 <jchia_1> merijn: I get the meaning for parsers.
07:51:28 <merijn> jchia_1: I spent an hour or so staring at the implementation until I understood why [] infinite looped and concluded: they make zero sense for the list alternative :)
07:53:44 <jchia_1> merijn: An hour well spent?
07:54:26 <jchia_1> If some & many mean nothing for [] and <|> means the same as <>, why bother making Alternative instance for []?
07:54:42 <merijn> jchia_1: Well, because it's lawful, so why not? :)
07:55:05 <EvanR> o_O
07:55:10 <jchia_1> merijn: But when is it useful?
07:55:25 <EvanR> bottom is lawful now?
07:55:29 <nshepperd> so that you can use 'guard' in a list monad
07:55:30 <jchia_1> I can always choose the Monoid instance
07:55:38 <merijn> jchia_1: Well, it's a superclass of MonadPlus and MonadPlus is useful
07:55:45 <merijn> EvanR: some/many don't have laws
07:56:36 <merijn> EvanR: They're implemented using <|> and empty, it's just that the way <|> and empty work for list doesn't produce useful code for some/many
07:56:57 <merijn> EvanR: This doesn't make list's alternative unlawful, nor does it make some/many useless :)
07:57:09 <nshepperd> some might say that some & many should be in a different class so they would only be available where it makes sense
07:57:10 <lpaste> hexagoxel pasted “CZip” at http://lpaste.net/355362
07:57:36 <nshepperd> but then again 'many (pure 1)' is bottom even for parsers, so whatever
07:58:32 <hexagoxel> the above CZip class seems to have some similarity to a "lifted" Distributive. Does this make sense? Does this "lifting" have a proper (CT?) name?
07:58:58 <hexagoxel> Distributive as in http://hackage.haskell.org/package/distributive-0.5.2/docs/Data-Distributive.html#t:Distributive
08:01:35 <rightfold> Is there a way to disable let generalization so that typed holes in let/where bindings become useful?
08:02:37 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMonoLocalBinds may help
08:02:50 <merijn> rightfold: Might be easier to insert holes directly in the expression and only move them to there where/let when you start implementing (although not really a solution, I know)
08:02:52 <jchia_1> Regarding the MonadPlus instance for IO, v >> mzero = mzero, but if v is 'putStrLn "abc"', I get some console output before the exception from mzero. How can you say that v >> mzero and zero are equal?
08:03:25 <jchia_1> mzero just throws an exception without printing "abc"
08:04:18 <merijn> jchia_1: mzero is the left identity of mplus, not of >>
08:05:20 <jchia_1> merijn: There are two things mzero needs to satisfy: http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#t:MonadPlus
08:05:26 <merijn> jchia_1: hmmm
08:05:29 <jchia_1> v >> mzero = mzero is one of them
08:06:23 <rightfold> merijn: Perhaps MonoLocalBinds will help. I think I'd like that anyway.
08:06:27 <merijn> jchia_1: You're right, actually
08:06:44 <merijn> jchia_1: IO didn't use to be an instance of MonadPlus, I wonder when they added that...
08:07:57 <rightfold> Applying for a Haskell job tomorrow, excited.
08:08:16 <merijn> Looks like they added it in 4.9
08:10:28 <quchen> MonadPlus’ laws are awkward :-(
08:10:33 <nshepperd> yeah, that law doesn't look right
08:11:01 <nshepperd> 'u >> mzero >> v = u >> mzero' would be more accurate, for IO anyway
08:11:14 <rightfold> MonadPlus IO is not lawful.
08:11:51 <nshepperd> that says that 'u >> mzero' is a zero-like thing, but doesn't necessarily have to be mzero itself
08:12:03 <rightfold> Oh wait, maybe it is.
08:12:33 <lyxia> print () >> mzero   prints something,   mzero   doesn't
08:13:23 <merijn> Looks like they added it to remove orphans from base to make it work for transformers?
08:15:05 <nshepperd> '(u >> mzero) >>= f  =  u >> mzero' for full generality i suppose
08:16:51 <rightfold> I like `(x <|> y) >>= f == (x >>= f) <|> (y >>= f)`
08:17:02 <lyxia> why not simply   mzero >>= f = mzero
08:17:59 <rightfold> lyxia: that's what PureScript does.
08:18:02 <jchia_1> I want to learn what all these instances of Alternative, MonadPlus etc do for different types like [] and IO. I go to hackage (http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html#t:MonadPlus) and click on the 'Source' next to the '#' next to, say, 'MonadPlus (Proxy *)' under instances. This links to http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-102 , which according to my browser is in
08:18:02 <jchia_1>  the middle of nowhere. Is haddock broken or is it something about my browser?
08:18:15 <nshepperd> lyxia: that's also a law
08:18:23 <lyxia> nshepperd: I mean it's sufficient to derive yours
08:18:43 <nshepperd> lyxia: nope
08:19:31 <lyxia> (u >> mzero) >>= f = u >> (mzero >>= f)
08:20:41 <nshepperd> oh, ofc
08:22:01 <nshepperd> well then I don't see much need for the right zero law at all in that case
08:22:01 <hexagoxel> jchia_1: haddock. if you follow source from Proxy docs, it correctly points to http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Proxy.html#line-102; i don't think the 102 is a coincidence.
08:22:15 <lyxia> > let x = Just 0 ; y = Just (1 :: Int) ; f = guard . odd in ((x <|> y) >>= f, ((x >>= f) <|> (y >>= f))) -- rightfold
08:22:17 <lambdabot>  (Nothing,Just ())
08:22:39 <jchia_1> hexagoxel: Thanks
08:24:21 <nshepperd> btw i think that mzero >>= f = mzero should be almost always true because of parametricity. mzero can be :: m Void, so you can't do anything useful with f because you can't produce a Void to pass to it
08:24:29 <nshepperd> not sure how to prove things like that though
08:27:01 <jchia_1> hexagoxel: At first I thought the haddock bug could be circumvented, but it seems that the link on the type's page has the same problem, e.g. the 'Source' for the MonadPlus Maybe instance also points to the middle of nowhere. http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Maybe.html#t:Maybe
08:27:23 <jchia_1> hexagoxel: Not always but at least sometimes.
08:27:35 <rightfold> lyxia: yeah
08:30:55 <hexagoxel> jchia_1: it seems to point to this from the class and the type: http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-729
08:31:47 <hexagoxel> that's not nowhere, i see "instance MonadPlus Maybe" at top.
08:32:19 <jchia_1> hexagoxel: You're right. Basically, it's pointing to the default instance
08:32:45 <hexagoxel> right
08:32:50 <lyxia> for Proxy it looks like a bug
08:33:25 <lyxia> it should point to Data.Proxy
08:34:16 <hexagoxel> yeah, some of the reexporting confuses haddock probably for the MonadPlus source link for Proxy instance.
08:35:26 <hexagoxel> but is the same "instance MonadPlus Proxy" only-defaults for Proxy.
08:57:03 <ADG> using stack `ghc -- o bin/2.o src/2.hs` -O2 still produces `2.hi` and `2.o` in `src/`
08:57:27 <brynedwardz> Should it be -o not just o?
08:57:45 <ADG> yes it is -o
08:57:55 <brynedwardz> Oh ok
08:59:55 <brynedwardz> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#redirecting-output
09:00:14 <brynedwardz> Says you can use -hidir and -odir to set output directory for .hi and .o
09:07:27 <hsk3> Why can't I name my program   hello-300 ?
09:07:41 <hsk3> hello-300.cabal       name:  hello-300      executable hello-300
09:08:08 <fresheyeball> hsk3: what happens if you run `cabal clean` first?
09:08:09 <hsk3> I get this error when doing "stack build": NoParse "name" 1
09:08:13 <hsk3> i'll try 1sec
09:08:43 <fresheyeball> hsk3: or `stack clean` in your case
09:08:58 <hsk3> fresheyeball yeah. don't have cabal. tried stack clean. still same error
09:09:07 <hsk3> (i also tried manually doing rm -rf .stack-work)
09:09:26 <fresheyeball> can you paste your full cabal file via some paste service?
09:09:37 <fresheyeball> I think you might just have a syntax issue
09:09:40 <lyxia> "stack new hello-300" says: "Package names consist of one or more alphanumeric words separated by hyphens. To avoid ambiguity with version numbers, each of these words must contain at least one letter."
09:09:42 <fresheyeball> given that parse is failing
09:09:55 <fresheyeball> ahh
09:10:09 <hsk3> thanks mates!
09:10:43 <fresheyeball> hsk3: I guess you are going to have to go with `hello-thisissparta` or something
09:11:05 <hsk3> yeah. it was supposed to be port number of a web app, so i'll probably go for hello-p300 or something
09:11:21 <fresheyeball> why not accept the port number as an argument?
09:11:40 <lyxia> yeah it seems odd to make it part of the package name
09:11:43 <hsk3> i do that :) just wanna be able to see it at a glance
09:12:23 <hsk3> good point thought..
09:12:36 <hsk3> i could have a special app-ports.txt file for that..
09:18:00 <fresheyeball> hsk3: I think the standard methods for port assignment, are cli flag and environment variables. If not provided use a default.
09:18:13 <fresheyeball> .txt is also kinda weird 
09:18:45 <fresheyeball> if you are looking to make it part of a text based conf, I recommend looking at Data.Configurator
09:28:53 <hsk3> you make a good point. i have decided not to hardcode the port.
09:28:59 <hsk3> that was a bad idea indeed.
09:30:26 <ph88_> does anyone know a function to go from a integer to a bytestring ?  when i have 7241  i want "7241"
09:32:48 <ReinH> ph88_: pack . show or use a builder, depending on your needs
09:33:16 <dmj`> ph88_: cereal / binary could work too
09:34:19 <ReinH> also using a ByteString for text is generally a bad idea
09:34:26 <dmj`> encode :: Binary a => a -> ByteString
09:40:43 <ReinH> (that would be Data.ByteString.Char8.pack)
09:43:26 <shapr> blackdog: have you tried scalpel for web scraping in Haskell?
09:47:34 <jordan3636363> https://ideone.com/rFxvQZ
09:47:47 <jordan3636363> i dont understand why this doesn't work :/ im  new to pattern matching
09:48:48 <Athas> jordan3636363: your code is fine, but you are trying to compile it as a standalone executable.
09:49:10 <Athas> To do that, you must have a 'main' function.  Probably this is not what you want, though.  Instead, you can load your code into GHCi and play with it interactively.
09:51:02 <jordan3636363> https://thepasteb.in/p/qjhLZqnlKxZfB
09:51:12 <jordan3636363> Athas
09:51:49 <ChaiTRex> jordan3636363: You need to import isNumber from Data.Char. You also need to convert the digit Chars to Ints.
09:51:55 <ChaiTRex> jordan3636363: You can't sum a bunch of Chars.
09:53:35 <ChaiTRex> jordan3636363: See https://ideone.com/oVQGEV
09:54:34 <ReinH> How do you know that "12" is the numbers 1 and 2 rather than the number 12?
09:55:43 <jordan3636363> u just assume that its 1  and 2
09:56:20 <ChaiTRex> jordan3636363: I've edited that to a simpler version with `digitToInt`, which needs to also be imported from Data.Char.
09:56:49 <jordan3636363> thanks a lot, it works like a charm ChaiTRex !
09:56:58 <ChaiTRex> jordan3636363: You're welcome.
09:56:59 <shapr> blackdog: You were asking about Haskell web scraping on twitter a month or so ago, have you tried scalpel?
10:03:00 <stphrolland> Using Aeson, I could not find why decode someByteString :: Maybe MyType was always returning me Nothing with my data. I made an HSpec test, and with a valid it put ( as far as I can judge) it still returns me nothing. What do you do to debug with aeson in general ? I have no error message so I have no clue what may go wrong.
10:03:17 <stphrolland> it put = input
10:04:17 <lyxia> stphrolland: how do you know your input should be valid
10:04:26 <ChaiTRex> stphrolland: I'm not sure, but my first try would be to encode a MyType value and see if it looks like what you're trying to decode.
10:04:38 <stphrolland> I think so, I'm not sure, that's why I'd like Aeson to tell me what it did not like
10:04:50 <lyxia> stphrolland: also try eitherDecode to get the error message
10:05:04 <stphrolland> okay, that sounds good
10:12:53 <stphrolland> lyxia: thanks very much, the error message was good to indicate me the problems
10:13:05 <stphrolland> I'll always use eitherDecode now
10:18:37 <lyxia> Great, you're welcome.
10:26:36 <bsima> Are exceptions used in anger? I've only done toy apps and learning exercises
10:27:03 <bsima> like Control.Exception
10:27:07 <EvanR> exceptions are good in IO related things
10:27:17 <Cale> They're used quite sparingly
10:27:48 <lyxia> never heard of a package named anger.
10:27:50 <Cale> It's generally a safer design decision to go without using them, but there are some cases where they're the right thing.
10:28:29 <bsima> I done my best to avoid them, but wreq uses them a lot so I guess I gotta learn how to do this
10:28:56 * bsima needs another cup of coffee first
10:30:50 <tsahyt> when I build two structures using the same references, does the data behind the references get duplicated?
10:31:09 <tsahyt> e.g. I have x :: Foo in scope, and I return ([x], (x,x)), how many instances of x are there in memory?
10:31:18 <ChaiTRex> tsahyt: Not usually.
10:31:20 <tsahyt> assuming Foo is something nontrivial
10:31:58 <EvanR> let x = complicated in ([x],(x,x)) there will only be 1 x
10:32:23 <tsahyt> EvanR: and this remains the case when I say deconstruct the outer tuple and pass the list and the other tuple around etc?
10:32:56 <EvanR> well once you start operating on x directly, you could be allocating more stuff
10:33:02 <EvanR> if you need to modify the x
10:33:15 <tsahyt> but if I only read it?
10:33:26 <EvanR> you can read to your hearts content
10:33:32 <tsahyt> great
10:34:42 <EvanR> remember lazy evaluation though, the x may not be fully evaluated, and whatever does the reading will be the thing doing the initial work to materialize the parts
10:35:12 <stphrolland> I'm using extension DuplicateRecordFields for two structure which are somewhat really similar. However I don't find the way to disambiguate one selector for one structure or another. 
10:35:20 <stphrolland> How do you do it ?
10:40:00 <lyxia> selector (myRecord :: RecordA)
10:42:35 <lyxia> stphrolland: c.f. the GHC user guide https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#duplicate-record-fields
10:49:33 <Lambda> Hey
10:49:45 <shapr> hi Lambda, are you anonymous?
10:49:52 <Guest87245> No haha
10:50:49 <Lambda_> I'm currently learning haskell and took a guess hoping this was a server
10:51:35 <shapr> It worked!
10:51:42 <Lambda_> What worked?
10:51:48 <shapr> You guessed correctly?
10:51:52 <Clint> this isn't a server
10:51:53 <Clint> this is a channel
10:51:56 <shapr> Lambda_: got any questions about Haskell?
10:52:33 <Lambda_> Got my stuff mixed up sorry Clint
10:53:43 <szhwump> guys can you help me with my hoogle-fu: I'm working with gnuplot, and need to figure out how to take a type from T to IO(). What should I search for?
10:53:46 <Lambda_> I'm almost finished the book Learn You A Haskell, Any recommendation on where to go after that book?
10:53:56 <szhwump> (T is Graphics.Gnuplot.Private.Plot.T)
10:53:58 <rom1504> recode pandoc
10:54:15 <rom1504> then you can recode ghc
10:55:41 <Lambda_> Haskell is also my first Funtional Programming language
10:55:46 <shapr> ooh, me too!
10:55:55 <shapr> Lambda_: Have you seen haskellbook.com ?
10:56:29 <Lambda_> No I haven't I'll check it out now
10:56:38 <Cale> http://chimera.labs.oreilly.com/books/1230000000929/index.html
10:56:57 <Cale> is a good follow up once you have a handle on the basics
10:57:11 <Clint> szhwump: is that like https://hackage.haskell.org/package/gnuplot-0.5.4.1/docs/Graphics-Gnuplot-File.html#t:T ?
10:57:11 <Cale> (Simon Marlow's Parallel and Concurrent Programming in Haskell)
10:57:17 <Lambda_> Is it worth the 59 dollars
10:57:19 <Lambda_> ?
10:57:44 <EvanR> + 0.95 :: Centi
10:58:18 <bsima> Lambda_: I can vouch for haskellbook.com, it's really great
10:58:21 <pikajude> > 10 / 3 :: Centi
10:58:23 <lambdabot>  3.33
10:58:25 <pikajude> no kidding
10:58:47 <EvanR> <3
10:59:11 <Cale> szhwump: Oh no, you've falling into another Henning Thielemann package
10:59:15 <Cale> fallen*
10:59:43 <lambdamu> Is it really not possible to automatically generate working complete lowest level bindings for c libraries?
10:59:51 <Lambda_> I'll read the free sample when I'm not at work and that's for the recommendation
10:59:59 <Cale> szhwump: The fact that he names all his types T and all his classes C makes it impossible to actually use
11:00:18 <stphrolland> lyxia; great I add this documentation to my bookmarks, I often have doubts about how to use extensions
11:00:27 <pikajude> doesn't ocaml name all the types t
11:00:32 <lambdamu> Cale: He tries to leverage the module system
11:00:46 <lambdamu> Cale: Your supposed to import qualified, but you probably know that
11:00:55 <Cale> I do
11:02:06 <Lambda_> I haven't seen a chat this active in awhile 
11:02:08 <lyxia> pikajude: it somehow works better with ocaml's module system
11:02:08 <Cale> The thing is, the fact that you can choose to import things qualified doesn't help you when you have to click on each occurrence of T to figure out which type it refers to in the documentation.
11:02:31 <Cale> cons :: T graph -> T graph -> T graph
11:02:33 <lambdamu> Cale: haha yes he considers haddock broken on that account
11:02:53 <pikajude> lyxia: that i agree with
11:02:57 <Clint> what does he think haddock should do?
11:03:53 <lambdamu> Clint: I didn't actually here him say that, to be clear, it just appears that way
11:04:10 <Cale> Probably preserve qualifications in top level signatures, except while that helps him somewhat, it doesn't really make any sense, because you can't just import the module and get things qualified like that.
11:04:53 <Cale> You'd have to know how everything was imported.
11:05:45 <Cale> I still don't understand why he'd be so adamant in sabotaging all his packages like that
11:06:00 <Cale> It's not any more convenient in any way.
11:06:06 <Philonous> Well you can choose to work with the tools that exist or against them. Disregarding established conventions and demanding that existing infrastructure be changed to accommodate your personal style choices while making your code neigh unusable is pretty immature and borderline antisocial 
11:06:16 <lambdamu> I guess one way to fix it is to prefix types with their source modules when there are name conflicts in scope scope
11:06:21 <Cale> and yeah, it means you're fighting against all the existing tools
11:06:56 <Cale> Yeah, that would "fix" it... though it would still be much uglier than if he didn't do this.
11:06:56 <lambdamu> actually I don't think it should be hard to fix
11:07:35 <Cale> It might not be so bad for Haddock. I once took a halfhearted shot at writing a source to source dehenning tool
11:07:53 <szhwump> okay, so what am I supposed to do to actually plot this T plot?
11:07:55 <Cale> and that's tricky, because modules can and will be imported as the same name
11:08:41 <Philonous> Honestly, if someone flaunts his disregard for convention and helpfulness so proudly, I wouldn't trust his code enough to use it in anything serious anyway 
11:08:45 <Cale> szhwump: If it were me, I would either give up entirely on this package, or fork it and rewrite all the types in it to not all be called T.
11:09:20 <szhwump> I think I'd still have that problem though
11:10:01 <Cale> maybe
11:10:03 <lambdamu> I think the idea has some merit to it, our module system just sucks and doesn't take well to this kind of abuse
11:10:25 <Tuplanolla> Could we get HT to write an un-HT compiler in HT style and then apply it to itself?
11:10:38 <szhwump> so anyone know of some other good plotting libs that can do 3d?
11:10:39 <lambdamu> on fixing haddock in their source modules all types have to be unambiguous. no? so one could always take that as prefix
11:10:46 <Cale> szhwump: The problem is, there are literally 19 different types in that package all named T. So nobody understands what you're asking.
11:10:53 <szhwump> oh
11:10:56 <szhwump> okay
11:11:23 <szhwump> cloud   :: (Graphics.Gnuplot.Value.Tuple.C a,       Graphics.Gnuplot.Value.Atom.C z, Graphics.Gnuplot.Value.Atom.C y,       Graphics.Gnuplot.Value.Atom.C x) =>      gnuplot-0.5.4.1:Graphics.Gnuplot.Private.Graph3DType.T x y z a      -> [a] -> T x y z
11:11:24 <Cale> The guy who wrote it is super stubborn and while he does a lot of interesting stuff, he ruins it all like this.
11:11:25 <EvanR> you could try to help anyway
11:11:37 <szhwump> ^ exists, so how do I actually plot this plot?
11:11:40 <szhwump> does that help?
11:11:59 <Cale> What's the last T?
11:12:10 <Cale> wait, maybe I can find it
11:12:31 <Cale> Graphics.Gnuplot.Plot.ThreeDimensional
11:12:40 <szhwump> I'm looking to try to use anything from Graphics.Gnuplot.Plot.ThreeDimensional that can just plot a list of 3D points
11:12:49 <Cale> oh, and that T is a type synonym
11:13:04 <szhwump> type T x y z =   gnuplot-0.5.4.1:Graphics.Gnuplot.Private.Plot.T     (gnuplot-0.5.4.1:Graphics.Gnuplot.Private.Graph3D.T x y z)   	-- Defined in ‘Graphics.Gnuplot.Plot.ThreeDimensional’
11:13:07 <lyxia> for another T?
11:13:11 <Cale> for Graphics.Gnuplot.Private.Plot (Graphics.Gnuplot.Private.Graph3D.T x y z)
11:13:12 <Gurkenglas> If you want to annoy him, you could write a tool that automatically forks all his projects and fixes them.
11:13:14 <EvanR> interesting i only thought these C and T packagers were for esoteric advanced math... this is gnuplot bindings
11:13:32 <Cale> Gurkenglas: I thought about it, it's trickier than I thought it would be.
11:13:46 <lyxia> But our T is in another module!
11:13:52 <szhwump> Cale: what is the advantage of wrapping them in T or C in the first place?
11:14:07 <Cale> szhwump: All the T's are completely different things
11:14:17 <Cale> szhwump: This guy names all his types T
11:14:20 <szhwump> ... that doesn't sound very advantageous
11:14:52 <Cale> That's why I was recommending we just abandon the whole package, or else carefully fork it all.
11:15:00 <Philonous> szhwump, I think the basic idea is that the type names are often redundant, like you have a type Plot in a module Plot. So (I'm guessing here) he decided to cut some boilerplate. 
11:15:22 <mnoonan> it's like a weird module-level version of Hungarian notation
11:15:24 <Cale> cloud :: (C x, C y, C z, C a) => T x y z a -> [a] -> T x y z
11:15:36 <Cale> But then you end up with haddock telling you stuff like this
11:15:41 <Cale> which is totally unreadable
11:15:50 <Gurkenglas> Cale, could you preprocess the source with that new haddock thing that inserts all the right hyperlinks?
11:15:58 <Cale> (and even with the qualified names, it's awkward to read)
11:16:06 <Cale> The hyperlinks are correct
11:16:15 <Cale> Haddock knows where things go
11:16:37 <Cale> So, maybe a tool based on Haddock (or just the GHC API) could do it.
11:16:37 <Gurkenglas> Right, so you can use Haddock's output to find out how to dehen
11:16:40 <szhwump> I don't think I'm qualified enough to hate this guy yet, so can someone at least recommend some other 3d plot library?
11:17:38 <Philonous> szhwump, It's not about hating the person. 
11:18:23 <mnoonan> so I successfully wrote some Template Haskell for a nontrivial task last night, and I kind of enjoyed it. Am I ill?
11:18:34 <Philonous> mnoonan, Nope. Welcome to the club.
11:18:38 <Cale> I hate him in the friendliest possible way. He ruined Haskore.
11:19:04 <Cale> Which was actually one of the original reasons that I found Haskell in the first place.
11:19:16 <lambdamu> szhwump: Did you take a look at diagrams? I think it can do 3d, too
11:19:23 <Philonous> Did he write it himself or did he "improve" it?
11:19:37 <Cale> He took over maintainership and "improved" it
11:19:51 <Philonous> Oh, well, that's actually a shame. 
11:19:55 <Cale> It was Paul Hudak's thing originally
11:23:08 <Cale> diagrams has somewhat limited 3D support
11:23:15 <szhwump> :(
11:25:16 <antoine9298> Cale: «him»?
11:27:34 <Cale> antoine9298: Henning Thielemann
11:28:23 <Cale> He does so much cool stuff, but sabotages it all with this dumb convention that renders it practically unusable
11:30:13 <Cale> Gurkenglas: Here's another good example of something which is tricky to fix fully automatically: https://hackage.haskell.org/package/gnuplot-0.5.4.1/docs/src/Graphics-Gnuplot-Private-Terminal.html#C
11:30:32 <Cale> Gurkenglas: He's got both a class and a type in this module, and they can't both be named the same thing.
11:30:54 <Cale> You could prefix the class names with Is or something as a best effort though.
11:31:13 <EvanR> CI CII CIII CIV
11:31:19 <Cale> "Is"
11:31:38 <Cale> i.e. in this case, you'd end up with a type Terminal, and a class IsTerminal
11:32:56 <Rembane> Well, as a first step, a tool that makes it easier to do these changes manually.
11:32:57 <Cale> szhwump: https://hackage.haskell.org/package/easyplot-1.0/docs/Graphics-EasyPlot.html seems to have some 3D support
11:33:12 <cocreature> as anybody ever tried to convince Henning to use a different convention?
11:33:15 <cocreature> *has
11:33:56 <Cale> I don't know. A long time ago, I think there was some mailing list traffic about it.
11:34:19 * magneticduck wonders how Hanning would write the Prelude
11:34:36 <Tuplanolla> We could sign a really passive-aggressive petition.
11:34:46 <Tuplanolla> I have all the good solutions.
11:34:48 <Cale> szhwump: I'll help you use that package if you have any trouble :)
11:34:59 <Philonous> Or you could spend the same effort making better packages
11:35:22 <Cale> The tool which makes it easier to repair his packages sounds good.
11:36:20 <Cale> Maybe just something which is split into two parts: one makes a file per source input with suggested renamings, one per line, and the other takes that file and the source, and performs the renamings.
11:36:40 <Cale> So you have a chance to edit the mapping, and can save the mapping files between releases of his packages.
11:37:24 <Philonous> Easiest case: An emacs macro that searches for T and C and suggests the current filename (without extension) as the replacement
11:37:40 <Rembane> Maybe ask first if he would be cool with a pull request to make the names easier to understand for people who aren't him. 
11:37:47 <Philonous> Oh, right, you have to redo it after every release
11:37:56 <Rembane> It might save quite some time.
11:38:04 <Cale> Philonous: right
11:38:51 <Cale> Rembane: Given that he's been at this for over a decade, I'm not sure that he'd merge :)
11:39:14 <Cale> I'm pretty sure that he must be aware that other people are annoyed by ut
11:39:15 <Cale> it*
11:39:34 <Philonous> It's not a new complaint. He knows about this. And yet he continues doing it. The prior probability that it would work is small
11:40:28 <Rembane> Cale: I like the concept of one last chance. :)
11:40:53 <glguy> It's licensed GPL, so if someone wanted to maintain a version without that naming they'd be free to
11:41:26 <Philonous> Cale, I don't think just de-obfuscating his packages automatically would work even in the medium-term. People using the translated version would still need to talk to HT for support and bug fixes, which would become awkward if they where using the modified version
11:41:50 <Cale> glguy: Looks BSD from here...
11:42:01 <Cale> Or which package?
11:42:07 <cocreature> it looks like he has even written a wikiarticle about this https://wiki.haskell.org/Qualified_names
11:42:08 <glguy> Oh, I thought you were talking about haskore
11:42:09 <Philonous> So it's either forking it and maintaining it yourself or keeping it as-is
11:42:13 <Cale> ah, haskore
11:42:25 <lyxia> haddock could have a way to qualify types, that may alleviate the problem a bit
11:42:28 <Cale> glguy: We started off with gnuplot, I mentioned haskore somewhere along the way
11:42:52 <glguy> I haven't been reading carefully, but BSD works too, if someone wants to maintain the package with a different naming convention they can
11:43:01 <lyxia> it would also be useful for the Strict/Lazy situation.
11:43:16 <Cale> Sure
12:00:54 <jordan23> hi i need to go through a list of tuples that have tuples in them in which are two numbers
12:01:05 <jordan23> [((2,20), (3,20), (1,19))] for example
12:01:21 <jordan23> i try to check if the fst of the tuples is 1 or 2 or 3
12:01:29 <jordan23> how do i check that?
12:03:19 <Philonous> pattern-match on the tuples. map (\(((x,_), (y,_), (z, _)) -> x `elem` [1..3] && y `elem` [1..3] && z `elem` [1..3]) xs
12:03:59 <Philonous> Oh, that may have too many opening parens
12:04:12 <jordan23> what does the backslash mean?
12:04:12 <ryantrinkle> is it possible to have cabal fail to build if haddocks aren't complete?
12:04:54 <Philonous> jordan23, It creates an anonymous function. \x -> y is a function with one parameter x that returns y
12:05:05 <Philonous> You may want to read an introductory text for Haskell 
12:05:29 <ph88_> is it possible to see Wall in ghci ?
12:05:34 <jordan23> alright
12:05:49 <Philonous> ph88_, :set -Wall
12:06:01 <Philonous> you can also start it with -Wall
12:07:03 <byorgey> jordan23: why do you have a list of tuples with tuples in them?
12:07:05 <ph88_> when i reload i don't get any warnings
12:07:08 <ph88_> Philonous, ^ 
12:07:25 <jordan23> its like a program that analyzes darts
12:07:40 <Philonous> ph88_, Maybe it's warning-clean? :D
12:07:43 <jordan23> [((2,20), (3,20), (1,19))] means the player has scored a double 20, a triple 20 and a single 19
12:07:44 <ph88_> :D
12:08:10 <byorgey> jordan23: I see.  Did you create this yourself or was it given to you as an assignment?
12:08:10 <jordan23> i wanna check if the input is correct, there are only 0 (miss) 1 (single) and so on possible
12:08:16 <jordan23> assignment
12:08:22 <ph88_> hmmm i restart ghci and reload again and now i see warnings ^^
12:08:29 <byorgey> ok
12:08:34 <jordan23> im stuck tho
12:08:40 <jordan23> i keep thinking in python terms
12:09:17 <byorgey> jordan23: we are happy to help, e.g. if you have some code and want help figuring out some errors, but we won't do your assignment for you
12:09:22 <jordan23> https://ideone.com/WnMoX2
12:09:26 <lyxia> ph88_: -Wall doesn't do anything for some reason.
12:09:37 <jordan23> yeah i just need some info on why this and that doesnt work every now and then
12:09:46 <jordan23> i wanna understand what im doing ^
12:09:47 <byorgey> jordan23: ah, ok
12:10:39 <byorgey> jordan23: the syntax error is because you are missing an opening parentheses before (2,20).  Or perhaps you have an extra one after (1,19).
12:10:44 <ph88_> lyxia, try restart ghci and reload again .. after that it worked
12:10:54 <byorgey> jordan23: is this supposed to be a list containing three pairs, or a list containing a single triple containing pairs?
12:11:37 <jordan23> i forgot the opening parentheses
12:11:50 <jordan23> its supposed to be a  list that has triples of tuples inside a tuple each
12:12:14 <byorgey> ok, then yes, you were missing an opening parentheses
12:12:17 <jordan23> [((3,20),(3,20),(3,20)), ((3,20),(3,19),(2,25))]
12:12:19 <jordan23> for example
12:12:21 <byorgey> right
12:12:28 <jordan23> now i get this error
12:12:41 <jordan23> https://thepasteb.in/p/RghnE28EmlvSz
12:12:51 <byorgey> jordan23: in line 4, what type is x ?
12:13:30 <jordan23> a tuple of tuples?
12:13:48 <byorgey> jordan23: correct
12:13:58 <jordan23> i need to go deeper right
12:14:01 <byorgey> jordan23: specifically a 3-tuple of 2-tuples
12:14:13 <byorgey> jordan23: so what are you trying to check in check_first_elem ?
12:14:46 <jordan23> the first element in the 2-tuples
12:14:46 <jordan23> mhm
12:15:26 <jordan23> how can i change line 3 to go one instance deeper into the list?
12:15:29 <byorgey> jordan23: I think you probably need to write check_first_elem using pattern matching.  Right now you refer to 'fst' but fst is a function, and it is not applied to anything.
12:15:42 <byorgey> jordan23: I don't understand what you mean by 'one instance deeper'
12:15:55 <jordan23> right now im checking the tuples inside of the list
12:16:21 <jordan23> but í wanna check the tuples inside of the tuples inside of the list
12:16:30 <byorgey> jordan23: in Haskell you can't iterate over tuples.
12:16:39 <byorgey> tuples in Haskell are very different than tuples in Python.
12:16:49 <jordan23> : /
12:16:54 <byorgey> Python tuples and lists are basically the same except tuples are immutable.
12:16:55 <Philonous> jordan23, You said you where thinking like a Python programmer, so this might be not obvious to you: Tuples in Haskell have a fixed length and the only way to get the elements is to pattern-match them 
12:17:19 <jordan23> map (\((x,_), (y,_), (z, _)) -> x `elem` [1..3] && y `elem` [1..3] && z `elem` [1..3]) xs
12:17:24 <jordan23> ill try to work with this
12:17:24 <byorgey> but in Haskell a list is an arbitrary-length sequence of elements all of the same type, whereas a tuple is a fixed-length sequence of elements which could all have different types
12:18:20 <magneticduck> jordan23: or [...] all (flip elem [1..3]) [x, y, z] [...]
12:18:31 <byorgey> if I were you I would forget about that and write it myself.
12:18:36 <byorgey> magneticduck: that's not helpful.
12:19:15 <magneticduck> I haven't read context
12:19:45 <byorgey> magneticduck: no worries, it's just that jordan23 isn't yet at a stage where that will make any sense
12:20:17 <jordan23> ^
12:20:23 <jordan23> first_component (x,_) = x
12:20:23 <byorgey> jordan23: try to fix check_first_elem x = ... using pattern matching:   check_first_elem (some pattern goes here) = ...
12:21:01 <byorgey> yes, that function is also known as 'fst'
12:21:02 <Philonous> jordan23, Maybe a better pattern to understand what's going on is: check_first_elem x = case x of ((x1, x2), (y1, y2), (z1,z3)) -> «your code here»
12:32:10 <xplat|work> is there some kind of way to do haskell scripting when your script has actual deps?  runhaskell doesn't really handle that iirc, and stack has a way to do it but it isn't quite satisfactory
12:33:00 <kadoban> xplat|work: The stack way works pretty well for me. What's unsatisfactory about it?
12:33:01 <byorgey> xplat|work: well, I was about to say 'stack can do that' but apparently that's not satisfactory.
12:33:10 <xplat|work> or at least, it wasn't last i checked -- it would drool on either stdout or stderr and didn't allow custom dependency versions
12:33:23 <xplat|work> have those things changed?
12:33:57 <kadoban> You can specify verbosity options, if that's what you mean. A long time ago I think it used to default to normal verbosity instead of quiet maybe, that could be what you're talking about.
12:34:14 <kadoban> As for specific versions, I'm not really sure. Does the --package syntax not support version numbers? I've never tried to be honest.
12:34:59 <davean> xplat|work: You can specify what packages should be in scope with runhaskell if you REALLY wanted to
12:35:44 <xplat|work> istr --package on stack would only let you use whatever was in the specified resolver
12:36:42 <kadoban> If you really want to I think you can make new resolvers in your config, but I've never bothered. Maybe that'd work the hopefully rare times you need that?
12:37:20 <xplat|work> davean: but only out of things in whatever global and local package database you have active for that runhaskell
12:37:49 <davean> xplat|work: sure, otherwise how is it different then building an executable?
12:37:59 <athan> In STM, is there something like `head :: TChan a -> TMVar a`?
12:38:05 <davean> xplat|work: if that isn't what you want I really am not sure what you could be wanting here
12:39:32 <frampton> Recently started learning Haskell. I have a question about about functions being first class citizens.           When you pass a function as an argument, what is then actually passed?
12:39:56 <xplat|work> davean: i'd actually want it to be as much like building an executable in capabilities as reasonably possible, but without doing a whole cabal init and having a source directory for a single file's worth of code
12:40:06 <jordan23> still stuck
12:40:20 <davean> xplat|work: so, where do you want it to know which packages you want?
12:41:37 <xplat|work> davean: a structured comment, a pragma, a header section before the actual source starts.  something of that sort.
12:42:14 <athan> frampton: That's theoretically not important :) you can just see it as "the function itself is passed as an argument"
12:43:54 <xplat|work> well, what is theoretically important is that the code of the function is passed, along with bindings for all the variables it uses other than its arguments
12:43:55 <davean> athan: and the exact how would very by implimentation
12:45:17 <frampton> athan: I get the concept. But it does mean that the function you are passing has to be statically encoded in the program?       If you have a client/server program, could the server execute functions that are completely client supplied?
12:45:42 <davean> frampton: in theory, but how would you serialize them?
12:45:45 <xplat|work> so references to resources/constants/whatever are resolved in the scope where the function is defined, not where it is used.  this is important in that it makes the type of the function a complete description of what is needed to call it
12:46:00 <davean> (In fact you CAN but it is hard to convy the function to the server)
12:46:15 <xplat|work> cloud haskell!
12:46:20 <davean> xplat|work: :(
12:46:27 <davean> xplat|work: Also, that doesn't
12:46:36 <davean> it just has a name for functions present in the server
12:47:07 <frampton> davean: That is one of the things I was thinking about. Since functions don't have a show instance you could not serialize them into a format that could be 'transported'.
12:47:49 <frampton> davean: Similarly, if the actual instruction encodings would somehow be passed then you are tied to a certain architecture.
12:47:57 <xplat|work> well, you could maybe build a function on the server side by using functions it already knows about and point-free style to assemble a function over there
12:49:24 <foolswoo1> Hi, I'm trying to write a composable bidirectional stateful processing pipeline without using threads for each stage, Pipes.Proxy was close but could have one end that was an event source. I have a gist of something that is similar and kinda does what I want, but am concerned that it doesn't form a category. https://gist.github.com/foolswood/d5891e320abbd31305318c668799a313 I'm new to Haskell, so if it 
12:49:30 <foolswoo1> seems like I've missed something obvious, I probably have. Thanks.
12:50:38 <foolswoo1> The idea is eventually to make something that manages serialisation and other middleware-like functions for a networked application.
12:52:42 <lyxia> "could have one end that was an event source", are you saying pipes was too expressive?
12:54:11 <xplat|work> i guess i'll check if the stack method has improved enough
12:55:00 <Philonous> frampton, If you have some function without knowing anything about it than you can't send it over the wire, obviously. But if you know how the function was created you have a chance. Many functions are created by starting with a static functions a filling in data. For example plusOne x = x + 1 starts with the (static) (+) function and adds the value 1 to the environment, creating what's called a closure. You can capture a pointer to the 
12:55:00 <Philonous> static function and the environment, serializing both, send it over the wire and then re-create the function from that. That's what cloud Haskell does 
12:56:12 <foolswoo1> lyxia: The crux of the issue with pipes was that the application isn't request response so there was more than one trigger for a state update.
12:56:40 <xplat|work> so you needed multiple event sources, but they were all still on one end?
12:57:35 <foolswoo1> Think of a UI on one end and a network on the other, you don't know which is going to fire next and they're kinda on opposite ends.
12:57:47 <xplat|work> oh
12:58:00 <frampton> Philonous: Like I wrote, just started with Haskell. So things like that are quite a way off. I was thinking a bit how the implementation works. Did not think that there were function pointers being passed around, but more 'call-by-name' instances that would get lazily evaluated.
13:00:12 <Tuplanolla> Haskell is kind of a low-level language in that types, names and intermediate data structures may be erased by the compiler, frampton.
13:00:16 <lyxia> foolswoo1: I see, that design doesn't work very well with multiple asynchronous sources on both ends. How about putting them both on the same end?
13:00:38 <Tuplanolla> If you want reflection, you'll have to ask the compiler for it explicitly.
13:00:48 <Guest48926> So...any people who love low level fiddling around? I need help fixing/making a low level spinloop work
13:01:03 <frampton> Philonous: But I was also hoping that you could add things dynamically. For instance, you have a function byteStream -> hash (or digest). That you could then plug in whatever function matched that signature. So when new ones come along (like the Blake family) that you could just supply those.
13:02:18 <frampton> Tuplanolla: Ok. When all those disappear after compilation, that does mean you can only use things that are statically known at compile-time, right?
13:02:42 <xplat|work> foolswoo1: i feel like that gist could use a few more comments.  e.g. what 'a' and 'b' parameters mean on block, what 'inStep' and 'outStep' represent
13:02:53 <Philonous> frampton, I'm not sure I follow. You can store functions in  Map (Haskell's name for Dictionary) and dynamically select one from it e.g. depending on user input and use that 
13:03:38 <Tuplanolla> I'm afraid to say yes, because that sounds so vague, frampton.
13:03:52 <xplat|work> there are ways to add functions to a program at runtime, e.g. hs-plugins
13:03:56 <blackdog> frampton: are you talking about plugging new functions into a running program, a la lambdabot?
13:04:08 <Tuplanolla> You certainly don't get `eval` for free.
13:04:44 <lpaste> merijn pasted “Fix the spinloop!” at http://lpaste.net/7143201469959766016
13:04:52 <foolswoo1> lyxia: You might be able too, you'd need feeder threads and I couldn't get it to drop out easily.
13:05:20 <foolswoo1> xplat|work: Thanks for giving it a read, I'll annotate it up.
13:05:28 <frampton> Philonous, Tuplanolla: Probably my question is vague too. I will take the empirical route and look at various 'layers' of GHC output (as a good exercise too) and see if that reveals what I am wondering about.
13:05:30 <merijn> I have this spinloop using atomic-primops, but it's not working, so clearly I'm missing some memory barrier somewhere that I need, but I'm unsure how to fix it
13:07:42 <frampton> blackdog: I was not really talking about that ... although if a server would be able to use a client supplied function (that the server did not previously know about, except that the type signature has to match of course) then that would be a practical consequence.
13:10:20 <edwardk> merijn: code?
13:10:34 <merijn> edwardk: http://lpaste.net/7143201469959766016
13:10:53 <merijn> edwardk: I'm also open to any other primitive for doing as cheap as possible synchronisation you might have
13:12:28 <merijn> edwardk: Right now I have implemented benchmarks for AtomicCounter, Chan, IORef, MVar, QSem, QSemN, TVar, TMVar, and a bunch of other STM primitives. But I suspect there's probably something faster to cobble together using GHC primitives
13:12:43 <merijn> But I haven't really had a good look at what's available there
13:12:45 <foolswoo1> xplat|work: I've added some comments, let me know what remains unclear :)
13:12:48 <edwardk> shouldnt you yield in your spin loop?
13:12:58 <merijn> edwardk: I dunno, should I? :)
13:13:09 <merijn> edwardk: This is for the threaded backend
13:14:18 <merijn> ok, yield works, at least, but I don't understand why :)
13:14:41 <xplat|work> a spinloop that doesn't allocate can still block an entire capability, and if some thread is bound to that capability a la forkOS or just sticky scheduling ...
13:14:58 <edwardk> yeah but while you're spinning nobody else is using your capability until it times out from doing constant allocation in the loop
13:15:04 <merijn> xplat|work: I don't have bound threads, but I suppose sticky scheduling might be an issue
13:15:18 <merijn> yield works, at least
13:15:20 <edwardk> if it doesnt allocate then you own the capability until you let the scheduler run
13:15:40 <edwardk> i think ghc changed its policy a while back to allow loops to not allocate, no?
13:15:53 <edwardk> which means that tight loops can hog a capability
13:15:56 <merijn> Which means it's time to move on to the next issue: Any recommendations for dark low level voodoo to implement even cheaper synchronisation?
13:16:29 <Sornaensis> woodoo
13:16:52 <lyxia> foolswoo1: I don't think compose is associative in general. inStep ((x `compose` y) `compose` z)   calls   outstep x   twice,   (x `compose` (y `compose` z))   calls it once.
13:17:28 <edwardk> anyways nothignstops you from easing in, doing a couple of spins, then yielding, then doing exponential backoff and yielding, etc
13:17:45 <edwardk> depends on how long your critical sections take
13:17:50 <lyxia> foolswoo1: maybe you have stronger assumptions about inStep and outStep
13:18:20 <edwardk> designing nice barriers is a bit of an art
13:19:19 <merijn> edwardk: Basically I'm trying to write some benchmarks for concurrent operations (i.e. channels, etc.) because the existing benchmarks for, e.g. unagi-chan are just bad. But that means I need a cheap way of detecting when all threads have terminated (so I can end my timing measurement)
13:19:38 <merijn> edwardk: So right now I'm writing a bunch of benchmarks to figure out the fastest/most efficient way to do that
13:20:00 <lyxia> foolswoo1: outStep bs1 >=> outStep bs2 = outStep (bs1 ++ bs2)   seems like a good candidate for a stronger assumption to make
13:20:14 <edwardk> that answer will depend on expected task duration
13:20:18 <merijn> edwardk: So really all I care about is: Thread marking they have terminated and have another thread wait until they've all terminated
13:20:52 <merijn> edwardk: Expected duration is microseconds (the actual operations are nanoseconds, but criterion batches them)
13:21:01 <edwardk> anyways you may want to rummage through sbahra's concurrencykit code forma dozen different spinlock variants to benchmark
13:21:04 <xplat|work> and it needs to be either super fast, or at least super consistent in delay
13:21:04 <merijn> maybe milliseconds, if the batches get really large
13:21:24 <edwardk> milliseconds is big for spinning
13:21:44 <edwardk> you'd probably want exponential backoff for that
13:21:50 <merijn> edwardk: Well, hence why I'm also benchmarking MVar/TVar, IORef, etc.
13:22:01 <edwardk> fair nuff
13:22:18 <merijn> edwardk: Well, since only 1 thread is ever spinning I don't particalurary care about the CPU efficiency
13:22:40 <edwardk> like i said, i expect your answer for "best" to flip a few times based on task duration
13:23:15 <merijn> edwardk: Quick termination after the stop condition is more important. If I have a single thread spinning, burning 100% CPU, but having almost no latency between threads finishing and that being detected, then that's fine for just benchmarking
13:23:20 <jordan23> still stuck
13:23:34 <foolswoo1> lyxia: I'm intending for them to compose serially, so I'm not sure how that assumption would (in general) not have problems with a mixed type list.
13:23:37 <merijn> I mean, not very efficient in a library or something, but that's not what I'm using it for anyway :)
13:24:44 <merijn> Anyway, time to see how the current ones perform/scale before I start the real low level voodoo ;)
13:24:45 <lyxia> foolswoo1: sorry I don't understand
13:25:35 <lyxia> foolswoo1: what is a mixed type list
13:25:57 <foolswoo1> lyxia: an outstep can return a different type to its input, so I don't think you could concatanate their inputs or outputs (since lists are homogenously typed)
13:26:11 <davean> merijn: one core spinning can lower the performance of other cores too.
13:26:17 <merijn> davean: True
13:26:29 <merijn> Concurrency and benchmarking are hard! Let's go shopping!
13:27:08 <foolswoo1> lyxia: If I understand correctly you'd need to be able to have 2 different types of things in that concatenated list, which isn't allowed. (Hence my confusing mixed type list statement).
13:27:24 <merijn> The one thing I can conclusively state already is that TMVar's performance is absolutely dreadful under contention...
13:27:39 <merijn> Because even with a single iteration that one takes several seconds...
13:28:09 <merijn> Now it's time for sleep and we'll see what criterion tells us tomorrow :)
13:28:27 <xplat|work> that's why they say lock free ain't wait free'
13:28:32 <lyxia> foolswoo1: actually that should have been outStep x bs1 >=> outStep x bs2 = outStep x (bs1 ++ bs2), with x :: Block s a b; bs1, bs2 :: [b]
13:28:47 <lyxia> foolswoo1: I'm not concatenating lists of different types
13:28:57 <c_wraith> STM in general is really bad under contention. 
13:29:23 <lyxia> foolswoo1: and this >=> is in the Writer monad, that is ((,) [a]).
13:29:55 <jordan23> > succ 69
13:29:58 <lambdabot>  70
13:30:44 <xplat|work> thx mr hunt
13:30:57 <lpaste> Gurkenglas annotated “CZip” with “CZip (annotation)” at http://lpaste.net/355362#a8279940933659656192
13:31:58 <Gurkenglas> Got a tentative CZip wrap of Distributive. I think there's more in CZip than in Distributive
13:32:38 <Gurkenglas> Because CZip can be heterogenous
13:32:44 <foolswoo1> lyxia: is bs1 what I'm calling b1 in compose?
13:33:33 <lyxia> foolswoo1: bs1, bs2 :: [b], these are simple lists.
13:33:38 <lpaste> Gurkenglas revised “CZip”: “Corrected the last sentence to what I think hexagoxel meant” at http://lpaste.net/355362
13:33:50 <lyxia> foolswoo1: the law I'm proposing does not involve compose.
13:34:27 <lyxia> foolswoo1: but I guess you could say x :: Block s a b corresponds to b1.
13:39:41 <shapr> oh wow, #haskell's 16th birthday was two weeks ago!
13:40:04 <foolswoo1> lyxia: I'm not sure I understand, might need to do some reading and working through on paper. Is what you're saying that the final state (and result) doesn't depend on the chunks that you break the input list into?
13:40:42 <lyxia> foolswoo1: that's right
13:41:19 <lyxia> is that true in your application?
13:44:03 <foolswoo1> Yes, the lists represent chunks of streams.
13:44:21 <foolswoo1> (sometimes of bytes, sometimes of semantic messages)
13:44:37 <jdreaver> Say I have a Haskell project and I want to write tons of docs and a tutorial. What's the best way to do that while having it all be type checked?
13:44:50 <jdreaver> Should I make a MyLibrary.Tutorial module? Can that be done in literate Haskell?
13:44:59 <jdreaver> Something with doctest maybe?
13:45:16 <lyxia> foolswoo1: if inStep and outStep took one element at a time, you would get that behavior for free
13:45:24 <jdreaver> I'm basically just afraid of my docs and tutorial becoming out of date with the library
13:45:43 <ChaiTRex> jdreaver: I haven't done it, but people tend to write blog posts in Literate Haskell, which they typecheck before posting.
13:46:04 <Gurkenglas> Is there "Distributive g => g a -> g b -> g (a, b)" that doesn't need to promise anything to the compiler?
13:46:47 <jdreaver> ChaiTRex: Thanks for the suggestion. Hmm, compiling a literate Haskell file to HTML docs is a good idea.
13:46:49 <c_wraith> Gurkenglas, isn't that the exact opposite of what Distributive does? 
13:46:59 <jordan23> Int is not the same as Integer okay im done for today
13:47:17 <Gurkenglas> Wait. There's a promising "Distributive g => g ()" too. Why isn't Applicative a superclass of Distributive? Lemme write this up.
13:47:36 <lyxia> jdreaver: The MyLibrary.Tutorial module is a nice idea
13:47:45 <foolswoo1> lyxia: Yes, they'd still need to return lists (as for instance one message can result in many bytes), but I think taking input one element at a time would work.
13:47:49 <c_wraith> Gurkenglas, because Distributive is the contravariant version of Applicative 
13:48:03 <Gurkenglas> No it isnt wat lol
13:48:20 <jdreaver> lyxia: Yeah I saw that with the pipes library, and their tutorial module is outstanding. I looked though and it looks like literate haskell but it isn't type checked via doctest or anything.
13:48:47 <jdreaver> I'm still actively developing my library so I just want an automated way to tell me to update the tutorial and docs :)
13:48:53 <exio4> what is Distributive?
13:49:09 <c_wraith> Gurkenglas, hmm, I seem to have been thinking of Divisible
13:49:59 <exio4> what does Distributive offers that `pure () and liftA2 (,)` can't do?
13:53:20 <lpaste> Gurkenglas pasted “c_wraith and everyone, here's an Applicative instance for Distributive (yea yea omniinstance overlaps with everything, Applicative should be a superclass of Distributive)” at http://lpaste.net/312022691085287424
13:53:49 <Gurkenglas> Do we need another AMP for this?
13:54:15 <xplat|work> i think Distributive is a container equipped with a type-changing Grate, much as Traversable is a container equipped with a type-changing Traversal
13:54:43 <nshepperd> hm, that is odd
13:54:59 <Gurkenglas> Distributive is isomorphic to some ((->) x), so obviously there's a zippy Applicative instance
13:55:31 <xplat|work> Monad too then
13:56:26 <Gurkenglas> ...huh. I think you're right. *back to lpasting*
13:56:39 <lyxia> jdreaver: since it is included as part of the library, the Tutorial module is type checked. It is not run, but you can just add a test to your project for that.
13:57:30 <nshepperd> Gurkenglas: can we do this without any partial functions though
13:57:32 <xplat|work> Gurkenglas: what's the reason for 'hack'?
13:58:02 <Gurkenglas> nshepperd, I don't know, I thought of this in the process of trying to shrink a question on how to get rid of that hack
13:58:22 <jdreaver> lyxia: Ah I was implicitly implying that if I did a Tutorial module the output would be haddock. I guess I could to literate Haskell and throw the resulting HTML on a website somewhere
13:58:41 <Tuplanolla> Does the isomorphism that relates indices with lexicographically ordered tuples have a name?
13:59:19 <xplat|work> what happens if you just use 'f' instead of 'hack' and 'id' instead of 'fmap Left' and 'fmap Right' ?
13:59:50 <lyxia> jdreaver: There is a misunderstanding somewhere... the Tutorial module will be included by haddock too
14:00:01 <Tuplanolla> The binary `0 -> (0, 0); 1 -> (0, 1); 2 -> (1, 0); 3 -> (1, 1)` is one example.
14:00:02 <nshepperd> xplat|work: distribute lets you turn (f a, f a) into f (a,a)
14:00:55 <Gurkenglas> xplat, a and b need to be identical for distribute to work, so I turned them both into Either a b
14:00:57 <nshepperd> xplat|work: in order to get the Applicative operator (f a, f b) -> f (a,b) we have to make both halves the same type
14:01:12 <nshepperd> do that by putting them in Either a b
14:01:26 <jdreaver> lyxia: Hmm, I've never actually used literate haskell before, I think I'm the source of the misunderstanding haha. I'll dive into it. Thanks for the help!
14:02:05 <xplat|work> oh, because you're using the Pair container
14:03:33 <lyxia> jdreaver: actually Pipes.Tutorial is not written in literate haskell. It's just one big haddock comment
14:03:53 <Gurkenglas> Might it be possible that Distributive non-constructively implies Monad?
14:04:05 <lyxia> jdreaver: with a few doctests
14:05:17 <jdreaver> lyxia: Ah the doctests are what I was looking for, I couldn't find them in the repo.
14:05:56 <xplat|work> i feel like you'd want to use the traverse-like thing (??) instead of the sequence-like thing (distribute)
14:06:31 <Gurkenglas> collect's the name
14:07:08 <lyxia> jdreaver: doctests are lines starting with >>>
14:07:19 <Gurkenglas> And I don't think so, collect also wants the a and b to be equal so I also need to do the hack before passing to collect
14:07:35 <lyxia> jdreaver: they are part of haddock comments
14:07:38 <xplat|work> no, collect is the wrong thing
14:09:55 <xplat|work> you want Functor f => (f a -> b) -> (f (g a) -> g b)
14:10:59 <Gurkenglas> oh, cotraverse. Makes sense.
14:11:57 <xplat|work> i guess that's (. distribute) . fmap
14:12:03 <vimalloc> Is there any sort of naming convention for two recursive functions, one that is the 'public' function (maybe calculates some extra data, etc), and then calls a helper function actually do the recursion?
14:12:11 <lpaste> Gurkenglas revised “c_wraith and everyone, here's an Applicative instance for Distributive (yea yea omniinstance overlaps with everything, Applicative should be a superclass of Distributive)”: “With xplat|work's suggestion.” at http://lpaste.net/312022691085287424
14:12:25 <vimalloc> Something like doThing :: <blah> / doThing_ :: <blah>
14:12:48 <hexagoxel> vimalloc: i have seen doThing / go
14:13:10 <vimalloc> hexagoxel: awesome, thx
14:13:25 <Tuplanolla> You must use `let` with `go` though, vimalloc. Otherwise the pun is ruined.
14:13:38 <vimalloc> hehehe
14:14:22 <xplat|work> i've also seen 'loop' for the local function
14:14:52 <xplat|work> and many instances of slides where people switched from using 'go' to 'loop' of vice versa midway through their function
14:15:55 <Gurkenglas> I usually replace the recursion with schemes and monad transformers. I did that to exference and now it's frozen, so take that with a side of salt.
14:16:28 <Tuplanolla> You can ruin anything with `hylo`.
14:16:41 <xplat|work> Gurkenglas: i feel if you want to get rid of 'hack' you should be using 'cotraverse' twice instead of once
14:17:03 <xplat|work> because you'd have to use it at two different concrete types
14:17:19 <Gurkenglas> cotraverse is what glues the two g's together. You are implying that I want to use it on a single g, transforming it into a single g?
14:17:37 <Gurkenglas> -glues+zips
14:18:23 <xplat|work> alternately i guess you could use cotraverse and fmap
14:19:00 <Gurkenglas> I am. Two fmaps even :P
14:19:18 <Gurkenglas> *do. I am do.
14:20:25 <mojjo> Hi!! I'm writing a function that inserts a value at key in a hashmap of type `M.Map a [b]` . When the key exists the val should be added to the list, otherwise it should be added to an empty list. Looks like a common enough pattern to question my implementation...
14:20:28 <mojjo> add :: Ord k => k -> v -> M.Map k [v] -> M.Map k [v]
14:20:36 <mojjo> add k v m = M.insert k (v:(maybe [] id $ M.lookup k m)) m
14:20:59 <foolswoo1> lyxia: I'll have a go at writing it to operate one element at a time, see what that tells me. Thanks for your help.
14:21:04 <Gurkenglas> Can we run a tool on hackage that shows us the subset relation of the instance for each class? Coz it's improbable that I happen to have found the last missing superclass relation
14:22:01 <xplat|work> ok, what if you use the datatype '(-> a)' as f
14:22:04 <foolswoo1> xplat|work: Thanks for getting me to clarify what I mean.
14:22:13 <Gurkenglas> :t M.alter -- mojjo, this one makes for a nicer implementation
14:22:15 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
14:22:57 <Gurkenglas> xplat|work, see the Applicative instance, or if you want it in terms of Distributable see the lpaste :P
14:23:06 <Tuplanolla> How are you supposed to understand Gurkenglas by the way?
14:23:27 <mojjo> Gurkenglas: nice, this is what I need here..
14:23:35 <Tuplanolla> My poor command of north European languages suggests it's something like "cucumber and ice cream".
14:24:08 <mauke> more like pickle glass
14:24:25 <Gurkenglas> https://www.google.de/search?q=gurkenglas&client=firefox-b-ab&source=lnms&tbm=isch&sa=X&ved=0ahUKEwiqjOa_3-PTAhUHYVAKHdngCLAQ_AUICigB&biw=1712&bih=938
14:24:40 <Gurkenglas> I imagine myself full.
14:24:49 <Arizona6882> isnt it central europe?
14:24:51 <Tuplanolla> Oh, neat. It's an actual thing.
14:25:17 <xplat|work> then cotraverse :: ((a -> b) -> c) -> (a -> g b) -> g b
14:26:11 <xplat|work> *then cotraverse :: ((a -> b) -> c) -> (a -> g b) -> g c
14:26:22 <Gurkenglas> g's the ((->) r), not f
14:26:36 <xplat|work> no reason they couldn't both be
14:26:52 <xplat|work> in a specific case
14:27:46 <Gurkenglas> You'll want a to be Bool then, if you want to use this to implement Applicative for g.
14:28:09 <Gurkenglas> (or Void, for the case of pure)
14:28:37 <xplat|work> no, i don't want a to be Bool, because then i'd just need hack again
14:28:45 <xplat|work> which would be pointless
14:29:18 <Gurkenglas> You only have two g's, though. Where will you take more, if a has more than two elements?
14:30:44 <xplat|work> i could make more, by fmapping things
14:31:13 <xplat|work> or by using pure
14:32:12 <xplat|work> what if i let a be 'g d'
14:32:57 <xplat|work> then cotraverse :: ((g d -> b) -> c) -> (g d -> g b) -> g c
14:34:08 <xplat|work> i guess that one won't work
14:34:54 <Gurkenglas> No, my counterargument fails against that one, you might be on to something, lemme see
14:35:54 <Gurkenglas> It's kinda cheating because if each g generates a g to give back then where'd the original 2 gs come in?
14:37:46 <thang1_> So I have a question I'm stuck on
14:37:57 <thang1_> (and by stuck I mean way overthinking everything)
14:39:08 <mojjo> Gurkenglas: still struggleing with the `add` implementation using `alter`, wouldn't I rather need `(Maybe a -> a)` in there instead of `(Maybe a -> Maybe a)`?
14:39:56 <mauke> :t Just . (?v :) . fromMaybe []
14:39:58 <lambdabot> (?v::a) => Maybe [a] -> Maybe [a]
14:40:04 <Gurkenglas> mojjo, the fact that you can add elements, but not remove them, leads to an asymmetry. You can express it by attaching "Just ." to the left of the (Maybe a -> a).
14:40:41 <nshepperd> i'm not sure about the Applicative superclass if <*> can only be written with the partial function
14:40:58 <Gurkenglas> mojjo, take a note to look at non from the lens library once you are fully grown as a Haskeller
14:41:17 <thang1_> "fully grown as a Haskeller" such a cute way to phrase that
14:41:28 <hexagoxel> (mojjo: perhaps using `unionWith (++)` and `singleton` would be prettier than `alter`, if less efficient)
14:41:39 <Gurkenglas> nshepperd, if it's a superclass we don't need to x)
14:42:19 <Gurkenglas> nshepperd, what in a case where it's even worse where the superclass relation can be proven, but not constructed?
14:43:14 <Gurkenglas> Oh hey, that can't be true, can it? We can just look at the Free Distributive. *lpaste*
14:43:28 <edwardk> gurkenglas a lot of folks consider lens rather overgrown :)
14:44:05 <Gurkenglas> Maybe edwardk's already through this. Why isn't Monad a superclass of Distributive?
14:44:29 <edwardk> instance Distributive (Compose f g)
14:45:03 <edwardk> go convince everyone that representable composition is the one true way to make that a Monad
14:45:27 <thang1_> While you're at it, convince them that bikesheds should always be painted orange
14:45:38 <edwardk> i'm likely to make it have an Applicative superclass
14:45:53 <edwardk> easier sell, instances all exist
14:46:02 <edwardk> and an explicit join member could be added
14:46:15 <thang1_> That'd be pretty nice (I think; I'm still far from groking lenses)
14:46:16 <edwardk> which would recover the missing bit of functionality
14:46:30 <mojjo> hexagoxel: the unionWith looks like a very clean way to express this.. is it way slower?
14:46:38 <Gurkenglas> I'm eager for join's implementation
14:46:53 <edwardk> just needs a reasonable name
14:47:10 <nshepperd> which 'join'
14:47:11 <edwardk> itd be an extra obligation for all providers
14:47:16 <Gurkenglas> no I mean how does one construct it from distribute
14:47:21 <edwardk> you cant
14:47:27 <thang1_> Forgive me if I sound stupid but is join not an acceptable name for join?
14:47:28 <edwardk> hence missing bit of functionality
14:47:51 <edwardk> thang1_ it'd collide with the monad version
14:47:59 <nshepperd> you're talking about the Monad join?
14:48:03 <edwardk> it usually gets imported unqualified
14:48:04 <edwardk> yes
14:48:06 <thang1> oh right, that makes sense
14:48:10 <Gurkenglas> huh my guess was right :D so wouldn't this mean that Monad can't be a superclass of Distributive because of the Free Distributive?
14:48:23 <edwardk> i dont know this free distributive
14:48:39 <edwardk> monad should be a superclass of distributive
14:48:47 <edwardk> it cant be for cultural reasons
14:49:03 <edwardk> if your free distributive cant be a monad then it really isnt distributive
14:49:12 <edwardk> at least what distributive is modeling
14:49:16 <hexagoxel> mojjo: no, especially when you are inserting single elements anyways. and if you have multiple, you can unionWith two maps.
14:49:27 <edwardk> the current class is a rough approximation of the real thing
14:49:40 <edwardk> representable is a better distributive anyways
14:49:48 <Gurkenglas> Oh, I thought the dictionary record that can be abused for a free Foldable works for any class
14:49:50 <edwardk> distributive just needs fewer extensions
14:50:43 <edwardk> Distributive f is exists x such that forall a. f a is isomorphic to x -> a
14:50:50 <edwardk> that is what it means
14:51:09 <edwardk> the current impl is an approximation of that in haskell 98
14:51:25 <mojjo> Gurkenglas: now I'm getting what you meant with the `Just .`. Didn't know that alter can delete as well in case of a Nothing.. Not fully grown Haskellers take their time..
14:51:29 <edwardk> representable gives access to 'x'
14:51:44 <edwardk> distributive forces you to talk about it obliquely
14:52:32 <Gurkenglas> Wouldn't it be advantageous in some cases to not explicitly talk about x?
14:53:07 <edwardk> giving distributive a monad superclass lets you state the rest of the things you can't currently say out of the side of your mouth about distributive
14:53:21 <Tuplanolla> Say, is there a function for turning two collections into an isomorphism?
14:53:43 <Tuplanolla> That would be something like `f a -> f b -> (a -> b, b -> a)`.
14:53:43 <edwardk> gurkenglas: it can be nice to not have to write the "logarithm"/representation
14:54:13 <edwardk> but there are no thpes thay can be really distributive and not representable except due to information hiding
14:54:16 <edwardk> er thpes
14:54:22 <edwardk> er types
14:54:32 <edwardk> anyways, plane tsking off
14:54:39 <edwardk> gotta go
14:54:39 <thang1> have a good flight!
14:55:23 <Gurkenglas> Tuplanolla, you mean \x y -> let xy = zip x y in (fromJust (`lookup` x), fromJust (`lookup` y))?
14:55:46 <Gurkenglas> Wah composition missing, imagine points there
14:57:35 <Tuplanolla> So that I could derive `(ord, chr)` from approximately `magicIso ['\NUL' ..] [0 ..]`, Gurkenglas.
14:59:19 <Gurkenglas> Tuplanolla, yea lookup. Or do you want something faster?
14:59:53 <Tuplanolla> I certainly expected the perfect solution to already exist.
15:02:59 <Gurkenglas> :t \x y -> ((M.fromList (zip x y) M.!), (M.fromList (zip y x) M.!)) -- Tuplanolla. Or do you want something faster than logarithmic time?
15:03:00 <lambdabot> (Ord k, Ord a) => [a] -> [k] -> (a -> k, k -> a)
15:03:24 <Gurkenglas> Oh, um, HashMaps probably get you O(1) right
15:03:31 <Tuplanolla> I'd do it with `Vector` if I needed to, Gurkenglas.
15:10:40 <vimalloc> Dumb question of the hour. With all the magic that is haskell (lazy evaluation and functional programming), is inserting an element into a list O(1) or O(n)?
15:11:29 <int-e> yes.
15:11:42 <Rembane> vimalloc: It depends.
15:12:02 <vimalloc> This whole learning haskell thing is making my brain twist in ways I didn't even know was possible :P
15:12:14 <Rembane> vimalloc: But you're on the safe side if you just assume the worst. :)
15:12:20 <int-e> If you make it fully lazy then insertion will be O(1) but getting elements from the resulting list gets more expensive for every "pending insertion" operation.
15:12:22 <Rembane> vimalloc: Fun! 
15:12:24 <magneticduck> vimalloc: for algorithmic purposes, a haskell list is more or less a singly linked list
15:13:00 <vimalloc> awesome. Thanks guys :)
15:13:01 <magneticduck> patterns like "tying the knot" and libraries like lens are the things that should be twisting your brain :p
15:13:29 <vimalloc> Hopefully I'll get there soon :)
15:13:34 <int-e> In the end you won't escape the linear time cost per insertion (assuming you're inserting at random places in the list).
15:14:37 <vimalloc> Is that different if you are always inserting at the front of the list, ie 'a' : "foobarbaz"?
15:15:04 <magneticduck> `:` is quite literally a constructor
15:15:15 <int-e> vimalloc: So it's worthwhile to use data structures like finger trees (as used in Data.Sequence) which have constant time access to head and tail and O(log(n)) random insertion.
15:15:44 <vimalloc> Wonderful. Thx
15:17:20 <int-e> Hmm, somehow I'm thinking about insertion by index here... if you want insertion by key, the usual search trees are probably best. Do we have finger tree variants of those?
15:36:51 <dmwit> vimalloc: (:) is O(1)
15:37:08 <dmwit> Well. O(whatever you believe your allocator costs) ;-)
15:37:26 <vimalloc> heh
15:37:36 <EvanR> isnt any 2-arg function O(1) in haskell ;)
15:37:56 <vimalloc> O(1 magical rabbit)
15:38:07 <EvanR> (:) x :: [a] -> [a], completes instantly
15:38:28 <dmwit> EvanR: I bet I can write a two-argument function which is nevertheless expensive even with only one argument.
15:38:30 <kadoban> Depends what model you use I suppose. I think you have to consider more than just what it costs to build the thunk.
15:38:59 <EvanR> youre right
15:39:18 <dmwit> > let f x = case last [1..1000000000] of x -> \y -> x in f 3 `seq` ()
15:39:20 <lambdabot>  ()
15:40:56 <dmwit> > let f x = last [1..] `seq` \y -> 3 in f 3 `seq` ()
15:41:03 <lambdabot>  mueval: ExitFailure 1
15:59:45 <Gurkenglas> > let f x = \y -> last [1..1000000000] in f 3 `seq` () -- Why not write the first one like so?
15:59:47 <lambdabot>  ()
16:28:40 <Awad> Hey
16:28:52 <Awad> Are there any good hacker in here
16:29:16 <glguy> Awad: Did you have a question about Haskell?
16:29:40 <Awad> I need to know if there are any good hacker in the chat room
16:29:54 <glguy> OK, looks like you're on the wrong IRC server
16:29:58 <Gurkenglas> I mean, I had that course about network security. What do you want to know?
16:30:08 <hpc> please to asking #ops they knows what do for hacking the gibson
16:30:57 <ChaiTRex> Eddie Haskell was sneaky.
16:31:03 <ChaiTRex> Maybe that's why they're asking here.
16:31:07 <Awad> I need someone to hack a snapchat account password 
16:31:31 <pacak> Awad: Would you like to learn Haskell instead?
16:31:31 --- mode: ChanServ set +o glguy
16:31:31 --- mode: glguy set +b *!*@gateway/web/freenode/ip.98.194.16.219
16:31:31 --- kick: Awad was kicked by glguy (offtopic)
16:31:43 --- mode: glguy set -o glguy
16:32:25 <hpc> pacak: A for effort, but i don't think "smother them with kindness" would have worked here
16:32:53 <pacak> hpc: It works sometimes,
16:34:55 <Tuplanolla> I wonder what would happen to this place if I wrote a free book called Haskell for Hackers featuring nothing but simple exploits.
16:35:37 <Koterpillar> Tuplanolla: in Haskell?
16:35:52 <EvanR> how about a book about exploiting haskell programs
16:35:55 <Tuplanolla> Of course, Koterpillar.
16:35:55 <pacak> unsafeCoerce :: [a] -> Maybe a? :)
16:36:08 <ChaiTRex> Find the flaws in the RTS!
16:37:21 <hpc> pacak: i have debated off and on writing an acme-coerce package that defines a bunch of useful things in terms of nothing but unsafeCoerce ;)
16:37:44 <hpc> yours is safeHead
16:38:14 <erisco> or maybe it is safeLast
16:38:26 <hpc> it would be ghc-specific
16:39:09 <erisco> Tuplanolla, like Hacker's Delight but for Haskell?
16:40:04 <Tuplanolla> No, erisco. This one looks educational and legal. Ideally it would be neither.
18:00:15 <Myrl-saki> Is it guaranteed that `m >>= const (pure x)` --> `pure (const x) <*> m` --> `pure x <* m` --> `x <$ m`?
18:00:44 <Myrl-saki> :t (<*)
18:00:45 <lambdabot> Applicative f => f a -> f b -> f a
18:02:21 <lyxia> yes
18:05:34 <lyxia> pure (const x) <*> m   =   pure (const x) >>= \f -> m >>= \a -> pure (f a)   =   m >>= \a -> pure (const x a)   =   m >>= \_ -> pure x   =   m >>= const (pure x)
18:12:17 <erisco> in school using equational reasoning was grating
18:12:24 <erisco> now it is a fun pass-time... what happened
18:14:34 <Myrl-saki> erisco: lol
18:15:25 <dmwit> Gurkenglas: It was a mistake. I should have written a pattern that forced `x`, but didn't because I wasn't thinking carefully.
18:15:39 <Myrl-saki> lyxia: Thanks. c:
18:20:24 <dmwit> :t \x _ -> pure x
18:20:27 <lambdabot> Applicative f => a -> t -> f a
18:20:34 <dmwit> :t \x a -> pure (const x a)
18:20:36 <lambdabot> Applicative f => a -> b -> f a
18:21:01 <dmwit> ah yes
18:21:54 <erisco> how did I not find recursion schemes until now, wow
18:22:49 <dmwit> x <$ m   ={def}   fmap (const x) m   ={monad law}   m >>= return . const x   ={calculation}   m >>= const (return x)
18:22:56 <Welkin> erisco: recustion schemes?
18:23:11 <Welkin> recursion schemes*
18:23:55 <dmwit> ?free const
18:23:57 <lambdabot> f . const x = const (f x) . g
18:23:58 <erisco> an excellent explanation of the paper (or some parts of) is right here http://blog.sumtypeofway.com/
18:24:02 <erisco> perfect for morons like me :P
18:24:26 <dmwit> Neat, you can even replace {calculation} with {free}. =) (Take g = id.)
18:25:41 <mnoonan_> So I’m working on this Haskell wrapper of a C++ API, and I want to call a foreign function that expects a uint64_t. On the Haskell side, I have it modeled as “newtype EA = EA CULong” and have provided a Storable instance; all is well. But if I replace “newtype” with “data”, I get “Unacceptable argument type in foreign declaration; ‘EA’ cannot be marshalled in a foreign call.”
18:26:06 <mnoonan_> is there some other bit of machinery I need to supply, or what?
18:26:42 <EvanR> i dont see what the problem is there, but wouldnt you want Word64
18:27:06 <EvanR> oh you replaced newtype with data
18:27:21 <EvanR> newtypes of marshallable types are marshallable, data is not
18:28:30 <dmwit> mnoonan_: Why do you want to replace `newtype` with `data`?
18:28:38 <mnoonan_> EvanR: hmm, interesting. I don’t suppose there is a typeclass that I can use to specify how to do the marshalling?
18:29:06 <mnoonan_> dmwit: some of the values are actually error values, so on the Haskell side I’d like to have “data EA = EA CULong | BadEA”
18:29:31 <EvanR> well that EA certainly wont go to C
18:29:38 <EvanR> its a sum type with structure
18:29:59 <mnoonan_> Sure, but the Storable instance tells how to splat it out to bits and read it back
18:30:07 <mnoonan_> I figured that would be sufficient
18:30:13 <EvanR> you can write a ffi wrapper which decides what marshallable type to use, accepting such an EA
18:30:39 <EvanR> but the raw calls have to match up with the C side
18:30:57 <dmwit> mnoonan_: I wonder whether you might prefer the `newtype` with some pattern synonyms.
18:31:21 <mnoonan_> dmwit: oh, that might be workable..
18:31:23 <dmwit> mnoonan_: But yeah, the standard way is to write very thin wrappers on the Haskell side.
18:32:27 <mnoonan_> dmwit: you just mean manually wrapping the ffi call with code that unpacks the Haskell values to something marshallable?
18:32:53 <dmwit> yes
18:33:14 <EvanR> Storable is for writing binary data to a region of memory pointed to be a pointer
18:33:17 <dmwit> mnoonan_: I think the c2hs/hsc2hs tools may have some machinery for making it a bit less painful. YOu might want to look into them.
18:33:26 <EvanR> not for generating word-sized single values to go through the ffi
18:33:29 <mnoonan_> ok, I can live with that. All of the FFI calls are done through TH splices in my case, so I can probably just make the TH more clever
18:33:45 <mnoonan_> EvanR: I see, that makes sense.
18:34:42 <dmwit> mnoonan_: To see an example, check out the X11 library, which does this all over the place: import a function via the FFI, then write a wrapper with more idiomatic Haskell types. e.g. https://github.com/xmonad/X11/blob/master/Graphics/X11/Xlib/Atom.hsc#L109
18:36:44 <mnoonan_> thanks dmwit, EvanR. I think I see the way forward now.
18:40:15 <erisco> I am reading about free and cofree lasagnas right now
18:41:11 <erisco> functional programming makes people hungry for some reason
18:41:26 <EvanR> Filename extension for executable files (including the dot if any) (usually "" on POSIX systems and ".exe" on Windows or OS/2).
18:41:33 <EvanR> wait. OS/2 ???
18:41:45 <Myrl-saki> erisco: Cofree Coffee when?
18:42:05 * EvanR writes down to mention OS/2 support whenever listing the short list of platforms haskell runs on
18:43:22 <erisco> it takes a lot of effort to understand most academic papers
18:43:32 <erisco> they're sometimes written in a made-up language for Pete's sake
18:43:38 <mnoonan_> Myrl-saki: Do you know the definition of a co-mathematician?
18:44:23 <Myrl-saki> mnoonan_: Do they eat mathematicians?
18:44:31 <erisco> and so it is difficult to rationalise giving effort required to only maybe reap some useful knowledge
18:44:42 <Myrl-saki> mnoonan_: Because that sounds scary.
18:44:50 <erisco> countless papers, finite time, and who knows if it is ultimately going to be of interest
18:44:52 <EvanR> it might take sometime to learn that made up language
18:45:02 <mnoonan_> Myrl-saki: nah, merely “a machine for turning cotheorems into ffee”
18:45:13 <Myrl-saki> mnoonan_: lmao
18:45:22 <Myrl-saki> mnoonan_: I'm glad I understand that now. :D
18:45:40 <erisco> which sucks because there are is probably knowledge vitally important to what you're trying to do and it is lost
18:46:05 <EvanR> now imagine all the vitally import knowledge that was never even published
18:46:09 <Myrl-saki> Talking about this stuff, what's the significance of contravariant/covariant argument positions in Haskell again?
18:46:40 <EvanR> and the contrast ratio between that and what you cant understand in a paper written in english in front of you
18:47:06 <erisco> "written in English" is a stretch
18:48:20 <Myrl-saki> erisco: Written in pseudo-English.
18:49:12 <EvanR> and the universe of other papers written in french or german
18:50:56 <Myrl-saki> erisco: "The reason for the name will be explained later," *explains* *gets more confused*
18:52:21 <erisco> I am just concerned of the tall order to breach these subjects when their benefit to your work is unclear and may be nonexistent
18:52:22 <glguy> Myrl-saki: what're you reading?
18:52:27 <Myrl-saki> glguy: Not me. :P
18:52:40 <Myrl-saki> glguy: I actually haven't read a "the reason for the name will be explained later" tbh.
18:53:15 <erisco> if you're doing it because it sounds interesting that is one thing, but when you're actively looking for solutions it is frankly ridiculous to study for a month or many unless you're dead certain the answer you are looking for is contained within
18:58:17 <erisco> the people simplifying and decoding academic papers are providing a vital service
18:58:41 <erisco> both formats are needed, really, and one person cannot do it all
18:59:12 <erisco> people who are specialised enough to understand the academic source and then apply it to an area, like Haskell, which we can readily understand
18:59:16 <erisco> that is invaluable
18:59:39 <mniip> from my experience
18:59:49 <mniip> you don't need to know all to understand academic papers
19:00:21 <mniip> there is an entry bar, but it's not as high as you might think
19:06:45 <Welkin> academic papers do not need to be indecipherable
19:06:58 <Welkin> simon peyton jones writes the easiest to understand papers I have seen
19:07:17 <Welkin> anyone with little to no knowledge of haskell or category theory could easily understand them
19:07:55 <Welkin> the problem is academia
19:08:17 <Welkin> I have friends who have had papers rejected from conferences because "they don't use enough math" or "it's too practical, not enough theory"
19:08:45 <glguy> Or just different conferences are looking for different things
19:34:29 <monochrom> With academic papers sometimes you have to learn what to skip.
19:36:51 <mniip> definitely
19:37:03 <monochrom> In grad school one of the first things they train new grad students is how to speed-read a paper. To decide whether to read in depth.
19:38:21 <monochrom> It amounts to spending more time on the abstract and the introduction, and only sampling time on the rest.
19:39:17 <mniip> I usually just seek the answers to my questions
19:39:20 <mniip> recursively
19:41:49 <monochrom> As for how to read a paper in depth, it is mostly training you how to write a paper that on the flip side dawns on you how to read one.
19:44:12 <mniip> is the converse true
19:45:10 <monochrom> I think yes.
19:47:34 <monochrom> To a large extent this training about papers is implicit by osmosis. But I did attend a class that made it explicit and explained both at the same time. (The class was ultimately about writing, but the teacher told us how readers read in order to justify why we write this way, so there.)
19:49:36 <c_wraith> I often skip to conclusions.
20:00:40 <MarcelineVQ> I'm not sure how relevant this comment is to points made earlier but I've noticed, in the particular papers I've been reading, that compared to haskell papers people repeat themselves a lot.
20:28:59 <ab9rf> yeah, there's a talent to usefully structuring a paper
20:29:10 <ab9rf> it's actually a lot like hw you write a business memo
20:29:49 <ab9rf> my training is in legal writing, but the same strategies apply there too
21:55:23 <ReinH> The best thing to do with a paper is to read the abstract and the conclusion, then decide if you want to read the rest
21:55:46 <ReinH> if you don't, you'll at least have indexed it in your brain in case it becomes useful later
21:56:01 <thang1> That's my method for sure
22:31:35 <qmm> x = IO [Foobar] -- and i want to count the number of items in the list
22:31:51 <qmm> maybe i need to use liftIO
22:32:10 <qmm> fmap works
22:33:06 <pacak> qmm: length <$> x
22:33:24 <pacak> That'll give IO Int
23:15:27 <Lokathor> imagine I'm going to be writing several operations that result in IO (Either String a)
23:15:58 <Lokathor> what's the easiest way to link them along so that the first failed one cancels the rest? There seemms to be a few transformer options
23:17:21 <quchen> ExceptT.
23:17:37 <quchen> Most importantly, not ErrorT.
23:17:40 <opqdonut> @unmtl ErrorT String IO a
23:17:41 <lambdabot> IO (Either String a)
23:17:55 <opqdonut> @unmtl ExceptT String IO a
23:17:55 <lambdabot> ExceptT String IO a
23:18:02 <opqdonut> well it desugars to the same
23:18:43 <quchen> Yes, but ErrorT has silly instances.
23:18:52 <opqdonut> yeah
23:19:50 <quchen> ?unmtl EitherT String IO a
23:19:50 <lambdabot> EitherT String IO a
23:19:55 <pikajude> well depends on your personal instance silliness preference
23:20:36 <quchen> Just like hammering nails into the wall with your fist depends on your personal pain preference.
23:20:54 <pikajude> might be a soft wall
23:21:05 <quchen> Might not be.
23:21:57 <Lokathor> ExceptT
23:21:59 <Lokathor> okay
23:22:09 <quchen> Anyway, to give a motivational example why not all errors should be stringly, imagine having 125 discrete error states (like Unix exit codes). Your error type is simply an Int.
23:22:28 <quchen> What should »String -> Int« be to write an instance for the Error class?
23:22:43 <quchen> :t strMsg
23:22:45 <lambdabot> error: Variable not in scope: strMsg
23:22:46 <Lokathor> so I can write each sub-action as its own IO (Either String a) and then chain them just once at the end with a function that runs them as an ExceptT ?
23:22:52 <quchen> Not even in scope, excellent :-)
23:23:06 <quchen> Lokathor: Exactly.
23:23:30 <Lokathor> quchen, in my case the errors are all Strings because they're all coming in via FFI, "getGLError" and those sorts of calls
23:23:46 <quchen> runExceptT (ExceptT (foo :: IO (Either String a) >>= doStuff >>= moreStuff)
23:24:05 <quchen> runExceptT (ExceptT (foo :: IO (Either String a)) >>= doStuff >>= moreStuff)
23:24:08 <quchen> Woops.
23:24:49 <Lokathor> runExceptT $ ExceptT $ do \n a <- foo \n etc
23:24:57 <Lokathor> :3
23:25:11 <quchen> That’s what the parenthesis is for ;-)
23:25:34 <quchen> ExceptT wraps an IO (Either a b). The result chains nicely and short-circuits.
23:25:41 <quchen> runExceptT gets you the result.
23:25:43 <Lokathor> neato
23:25:57 <Lokathor> I want to compile one shader, then compile another, and then link them all up into a program
23:26:08 <Lokathor> each stage of which might fail, so this seems like a good fit
23:26:28 <Lokathor> hide away all those nasty malloc calls and stuff too
23:28:25 <quchen> Lokathor: Does one shader need the result of the other?
23:28:45 <quchen> Asked differently, could you compile them in parallel?
23:29:09 <quchen> If so, there is something better you can do: run all of them, and collect the errors of all failing ones.
23:29:17 <Lokathor> the "link them into a program" depends on both having been compiled correctly. I would be very dubious about making two FFI calls to a giant FFI state machine in parallel
23:29:28 <quchen> The problem with ExceptT (and all Either monads, really) is that the first error cancels the entire rest
23:29:44 <quchen> But sometimes you’d like to run all actions and return all the errors instead of just the first one
23:29:49 <Lokathor> I'm not an expert, but I think exactly one thread is allowed to touch OpenGL things at once, or bad stuff happens.
23:30:26 <quchen> Hm, I didn’t phrase that well.
23:30:36 <quchen> Disregard OpenGL shenanigans.
23:30:36 <Lokathor> well of course you can run them all async if you want them to all attempt in any order :P
23:30:53 <quchen> Anyway, there’s the Validation Applicative.
23:31:16 <quchen> It’s also a wrapper around (Either e a), but it will collect all errors, instead of just returning the first one.
23:31:31 <quchen> Like GHC does: it gives you lots of type errors, not just one. Because fixing them one at a time is annoying.
23:31:35 <Lokathor> but quchen, i think you've got a solution in search of a problem right now :3
23:31:56 <Lokathor> I precisely want the "stop at the first error" version of things
23:32:16 <quchen> »No« then.
23:32:38 <quchen> I have lots of solutions, none of them search a problem, but that doesn’t mean there is no point in suggesting them.
23:33:20 <Lokathor> if you wanted them all to happen, sounds like a job for parMap or some such
23:33:51 <quchen> You can’t actually parallelize them because OpenGL, as you mentioned.
23:34:02 <quchen> But you could still try to create as many errors as possible.
23:34:11 <quchen> … in case there is an error.
23:34:24 <quchen> If there is no error, it’s best to create as little errors as possible. :-)
23:34:58 <Lokathor> in theory, you could compile both shaders async and look for an error with either, and then if that passes link them
23:35:01 <Lokathor> if opengl was smarter
23:35:42 <Lokathor> maybe vulkan or whatever can do that, dunno. opengl is the tutorial series i have though, so oh well
23:42:50 <sshine> can anyone recommend a way to express immutable, undirected graphs somewhat efficiently?
23:43:16 <sshine> I don't have Okasaki's book at hand, and I don't even know if it's in there.
23:44:00 <opqdonut> I know there's Data.Graph
23:44:29 <opqdonut> and https://hackage.haskell.org/package/fgl
23:45:10 <opqdonut> I guess the standard adjacency table and adjacency list approaches apply too
23:47:56 <sshine> so the table approach isn't sparse, and lists have linear lookup. I was thinking maybe something with trees?
23:48:19 <eklavya> is there a lib method to remove text between two markers ?
23:48:44 <opqdonut> sshine: something like IntMap IntSet might work
23:49:03 <Cale> sshine: Usually something like Map Vertex (Set Vertex) works well
23:49:05 <Cale> yeah
23:49:37 <sshine> and making it undirected you'd just add both directed edges?
23:49:44 <Cale> yeah
23:49:45 <opqdonut> yeah
23:49:55 <sshine> ok, thanks :)
23:50:04 <opqdonut> if you only need to query edges, you can just use Set (Int,Int) I guess
23:53:18 <lpaste> Hjulle pasted “Coverage condition fails” at http://lpaste.net/355373
23:54:11 <quchen> eklavya: I don’t think there’s one in Text, but you can easily write one in terms of find or partition.
23:54:24 <Hjulle> What am I missing? The information should be enough to uniquely determine the parameter t.
23:54:40 <eklavya> quchen: ok, just wanted to make sure I wan't reinventing the wheel :)
23:57:59 <lpaste> Hjulle revised “Coverage condition fails”: “Coverage condition fails” at http://lpaste.net/355373
