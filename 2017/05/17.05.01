00:01:33 <Myrl-saki> Lokathor: Is this API good? https://github.com/adrianparvino/reflex-bulma/blob/master/src/Reflex/Bulma/Grid.hs (This is how to use it: http://ix.io/sit )
00:01:45 <Myrl-saki> Lokathor: Sorry, didn't mean to ping you.
00:02:13 <Lokathor> i don't even know what i'm looking at :P
00:02:49 <Myrl-saki> Lokathor: Enforcing the usage of a function through RankNTypes.
00:03:13 <Myrl-saki> Literally the first time I used it.
00:03:19 <Lokathor> sounds beyond me
00:03:23 <Lokathor> I used runST once
00:07:11 <Myrl-saki> Welp.
00:07:15 <Myrl-saki> That didn't actually work.
00:07:41 <Myrl-saki> I can just make a `forall s. (m (Const () s)`
00:07:49 <Myrl-saki> Back to the drawing board. :(
00:09:49 <Myrl-saki> How about `forall p. ([Text] -> m a -> m (p a)) -> ((p a) -> a) -> m a`
00:11:24 <Myrl-saki> I don't want to define a new monad just for this.
00:14:30 <cocreature> Myrl-saki: why do you need a RankNType here in the first place? it seems like you are not making use of the fact that your function is polymorphic since you are only applying it once
00:17:24 <Myrl-saki> cocreature: I'm pretty much just tryign what works and what doesn't.
00:18:44 <cocreature> Myrl-saki: adding a phantom type parameter via Const but then forcing it to be polymorphic doesn’t seem particularly useful but maybe I’m missing something here
00:19:36 <Myrl-saki> cocreature: Wait, you mean that it'd have worked without the forall?
00:20:19 <cocreature> remove the Const and remove the forall
00:20:40 <Myrl-saki> cocreature: I want to force the usage of the passed function.
00:20:52 <cocreature> Myrl-saki: force what? and why?
00:21:40 <Myrl-saki> cocreature: http://ix.io/slr
00:22:08 <Myrl-saki> cocreature: It's hard to explain why.
00:23:43 <cocreature> :t \f x y -> Const <$> (f x y)
00:23:45 <lambdabot> forall k (b :: k) a (f :: * -> *) t t1. Functor f => (t1 -> t -> f a) -> t1 -> t -> f (Const a b)
00:24:04 <cocreature> you’re not actually restricting something, I can just create the function you expect based on an arbitrary function
00:24:12 <Myrl-saki> cocreature: Yeah.
00:24:25 <Myrl-saki> cocreature: That's why I said Myrl-saki | That didn't actually work.
00:24:43 <Myrl-saki> I'm trying to do this instead.
00:24:46 <Myrl-saki> columns :: (MonadWidget t n, MonadWidget t m) => [Text] -> ((forall a. [Text] -> m a -> n a) -> n a) -> m a
00:25:03 <cocreature> sry I’m not going to be able to help you if I don’t know what your goal is
00:25:03 <Myrl-saki> To say the last. It's still not working. Lol.
00:25:06 <Myrl-saki> To say the least*
00:25:18 <Myrl-saki> cocreature: Let me try to explain.
00:25:47 <Myrl-saki> cocreature: `foo $ (\bar -> do  {bar ...; bar ...; bar ... })`
00:26:45 <Myrl-saki> cocreature: I can't explain it very well lol
00:27:12 <Myrl-saki> cocreature: Basically, it should be that `bar` must be used to "postprocess" the wrapped monad.
00:27:40 <cocreature> what’s are the arguments to bar supposed to be?
00:27:58 <cocreature> s/what’s/what/
00:28:04 <Myrl-saki> cocreature: I could have used `traverse bar` but that makes me lose the mutual thingy.
00:28:10 <Myrl-saki> cocreature: Right.
00:28:18 <cocreature> mutual thingy?
00:28:20 <Myrl-saki> cocreature: The argument to bar is the same monad as `foo`
00:28:33 <Myrl-saki> cocreature: `x <- m; y <- m1 x`
00:28:42 <Myrl-saki> cocreature: Or even mdo
00:29:06 <Myrl-saki> I was thinking of saying `mutual recursion` but not too sure if it was appropriate.
00:30:02 <cocreature> you can’t enforce that the user does do {bar …; …} instead of bar (do …)
00:31:17 <Myrl-saki> cocreature: I want to enforce the user to do `do {bar ...; bar ...;} rather than `do {..., bar ...}`
00:31:40 <Myrl-saki> cocreature: (Every "root" must be `bar`)
00:31:47 <Myrl-saki> If that makes any sense.
00:33:34 <cocreature> maybe you’re looking for something like “f :: (forall n. (m a -> n a) -> n a) -> m a”?
00:35:19 <Myrl-saki> cocreature: Yeah, that's what I'm doing right now.
00:35:28 <Myrl-saki> cocreature: But I don't know how to unwrap the n.
00:35:39 <Myrl-saki> (How to produce an (n a -> m a))
00:35:52 <cocreature> well what do you want n to be?
00:36:32 <Myrl-saki> cocreature: You probably think this is stupid, but n == m? :D
00:36:52 <cocreature> Myrl-saki: now we’re back to the point, where I don’t know what you’re actually trying to do :)
00:37:12 <Myrl-saki> cocreature: :P
00:37:18 <cocreature> Myrl-saki: I think you need to make some minimal example that demonstrates the API you’re trying to get and then we can talk about if and how you can get that
00:37:47 <cocreature> if you really want n == m, just use "id" but that’s hardly useful
00:39:42 * ski . o O ( `n = m' )
00:39:54 <cocreature> ski: n ~ m
00:39:57 <Myrl-saki> A bit of a segway. What does ~ do?
00:40:12 * ski doesn't like that symbol chosen
00:40:15 <Myrl-saki> Does it make sure that you can interchange the 2?
00:42:02 <Myrl-saki> http://ix.io/slu
00:42:09 <Myrl-saki> That's my current code so far.
00:42:26 <Myrl-saki> (That doesn't work.)
00:43:27 <ski> er, why did you add `m ~ n' in the type signature ?
00:44:01 <Myrl-saki> ski: In which?
00:44:18 <Myrl-saki> The top level?
00:44:34 <ski> yes
00:45:07 <ski> oh, and the `forall' is wrong
00:45:42 <ski>   unwrap :: (m ~ n, MonadWidget t m, MonadWidget t n) => m a -> n a
00:45:47 <ski> should be the same as
00:45:50 <cocreature> Myrl-saki: let’s take a step back. what is “columns” supposed to do on a conceptual level. it takes some css classes, that’s relatively clear. then it takes some function. what does that function represent?
00:45:57 <ski>   unwrap :: MonadWidget t m => m a -> m a
00:45:59 <Myrl-saki> ski: Really? I think the forall is needed so that I can do `bar (return ()); bar (return 1)`
00:46:09 <ski> yes, but the `forall' is wrong
00:46:23 <ski> look aggain at what cocreature suggested
00:46:27 <Myrl-saki> cocreature: Right.
00:46:39 <Myrl-saki> cocreature: The function represents its direct descendant.
00:47:37 <ski> is there a reason why `column' has `classes' as a formal parameter ?
00:47:52 <ski> hmm
00:48:07 <ski> i suppose `m' is expecting it
00:48:57 <Myrl-saki> ski: To allow styling of individual column.
00:49:07 <ski> `m' will call `column' with a potentially different `classes' parameter ?
00:50:21 <Myrl-saki> Mhm.
00:53:44 <ski> Myrl-saki : oh, the `forall' is also in the wrong place ..
00:55:41 <Myrl-saki> I think I should make a cleaner API without the classes argument.
00:58:10 <Myrl-saki> http://ix.io/sly
00:58:17 <ski> anyway, i think `unwrap' has no real use here
00:58:24 <Myrl-saki> ski: Yep.
00:58:26 <jchia_1> I'm using typeclass A & type B from different hackage packages that I don't control. I want to have an A instance for B but avoid orphaned instances. I know I can wrap B in a newtype to do that but I want to avoid the boilerplate. How else can I do it safely? In seems that I could do it like how it's done in mono-traversable-instances (Data.MonoTraversable.Instances) & dlist-instances (Data.DList.Instances), but all that they seem to do
00:58:26 <jchia_1>  is to use '-fno-warn-orphans' to disable the warning. Specifically, I want to make a Data.Store.Store instance for a named tuple field from Labels.
00:59:09 <ski> Myrl-saki : and `forall' is still wrong, and additionally in the wrong place, in the new paste
00:59:23 <Myrl-saki> ski: Basically, I think I can solve my problem if I can define `m a -> n a` and `n a -> m a` such that m and n are pretty much the same monad, but they won't unify with each other.
00:59:54 <ski> please take a look at
00:59:56 <ski> <cocreature> maybe you’re looking for something like “f :: (forall n. (m a -> n a) -> n a) -> m a”?
01:00:30 <ski> again, and see how (the essential part of) it differs from what you have in that paste
01:00:36 <Myrl-saki> ski: How do I define (m a -> n a) though?
01:00:50 <ski> no need to
01:01:12 <ski> you already have
01:01:15 <ski>   column :: (m ~ n, MonadWidget t n, MonadWidget t m) => m a -> n a
01:01:18 <Myrl-saki> Oh true.
01:01:20 <ski> which can be simplified to
01:01:27 <ski>   column :: MonadWidget t m => m a -> m a
01:01:48 <ski> (the interesting thing happens with `m', not `columns')
01:02:14 <ski> (er, not `column'. i shouldn't confuse `column' and `columns' here ..)
01:03:32 <ski> .. but all this won't work unless you move the `forall' to its correct place. and also correct it in the other way i've been attempting to hint at
01:03:58 <cocreature> I don’t know reflex so take this with a grain of salt, but it seems like Myrl-saki is trying to enforce that each individual widget is wrapped in “column”. the problem is that this doesn’t make sense since reflex doesn’t have a concept of individual widgets: the composition of widgets (via >>) is a new widget
01:05:02 <cocreature> so you are either going to need to accept a list of widgets in which they can’t use MonadFix to reference each other or you deal with the fact that it’s up to the user to place “column” correctly
01:05:21 <cocreature> *in which case
01:06:15 <Myrl-saki> cocreature: I was able to use the List version, but I had problems with the result types.
01:06:36 <ski> is the composition of widgets (via `(>>)') a new *individual* widget, though ?
01:06:48 * ski doesn't know `reflex', either
01:07:18 <cocreature> ski: you can’t inspect them to see a difference afaict
01:07:49 <ski> (i.e. perhaps Myrl-saki have some notion of "individual widget" in mind that's meaningful to keep track of, even though `reflex' itself doesn't)
01:08:47 <ski> (.. well, there's many things you can't inspect, which you can reason about and keep track of, nonetheless)
01:12:40 <Myrl-saki> I honestly have no idea why this is working lol
01:13:07 <LiaoTao> Myrl-saki: That's my experience with Haskell in a nutshell
01:13:35 <Myrl-saki> If I use `MonadWidget t n` as a constraint in the Rank-2 forall, then it doesn't work?
01:13:39 <Myrl-saki> columns :: MonadWidget t m => [Text] -> (forall n. MonadWidget t n => ([Text] -> m a -> n a) -> n a) -> m a
01:13:47 <Myrl-saki> I get an untoucheable error.
01:14:42 <Myrl-saki> Maybe I should ask the contributors for this case. This seems to be implementation detail now.
01:15:08 <cocreature> I don’t think the RankNTypes solution is going to help at all if I understand your problem correctly
01:15:38 <Myrl-saki> http://ix.io/slC
01:15:44 <Myrl-saki> http://ix.io/slD
01:17:12 <cocreature> you probably need to add “t” to the forall
01:17:31 <Myrl-saki> cocreature: That makes sense.
01:18:31 <ski> i don't think so
01:20:08 <Myrl-saki> Doesn't work.
01:20:26 <ski> what's the code that generated that error ?
01:20:38 <ski> hm
01:20:45 <Myrl-saki> http://ix.io/slD
01:21:47 <ski> i mean, which version of `columns' ?
01:21:59 <Myrl-saki> This is my current code. http://ix.io/slG
01:22:05 <Myrl-saki> (For columns)
01:23:16 <Myrl-saki> It requires the inner a to be polymorphic?
01:23:50 <Myrl-saki> http://ix.io/slJ
01:23:52 <ski> it shouldn't
01:24:03 <Myrl-saki> That one compiles.
01:28:48 <ski> otoh, i'm not sure why it isn't
01:28:58 <ski>   columns :: MonadWidget t m => [Text] -> (forall n. MonadWidget t n => ([Text] -> m () -> n ()) -> n ()) -> m ()
01:29:15 <ski> since you'll anyway be discarding all but the last `a'
01:29:31 <Myrl-saki> ski: Right.
01:29:53 <Myrl-saki> ski: But I can compose the a out of the other types.
01:30:00 <Myrl-saki> Errr
01:30:02 <Myrl-saki> the other results.
01:30:25 <Myrl-saki> For example. `return [x, y]` where x and y are the result of the column.
01:30:36 <ski> aye
01:31:03 <Myrl-saki> columns :: MonadWidget t m => [Text] -> (forall n. MonadWidget t n => ([Text] -> m b -> n b) -> n a) -> m a
01:31:07 <Myrl-saki> This one also errors.
01:31:16 <Myrl-saki> I think it has problems with `m b -> n b`
01:32:05 <Myrl-saki> http://ix.io/slP
01:32:07 <Myrl-saki> Mark set [3 times]
01:34:07 <ski> Myrl-saki : hm, yea, i was just thinking along those lines
01:34:11 <ski> you need a `forall b.'
01:35:13 <ski>   columns :: MonadWidget t m => [Text] -> (forall n. MonadWidget t n => ([Text] -> m a -> n a) -> n a) -> m [a]
01:35:14 <Myrl-saki> ski: Right. But the problem gets moved back to the library's user.
01:35:28 <ski>   columns :: MonadWidget t m => [Text] -> (forall n. MonadWidget t n => (forall b. [Text] -> m b -> n b) -> n a) -> m [a]
01:36:21 <ski> hm
01:37:00 <ski> then `column' will have type `forall b. [Text] -> m b -> n b', iow it will be polymorphic in `b', so the caller of `column' will get to pick it
01:37:09 <ski> pondering whether that's a good thinge here or not
01:37:35 <Myrl-saki> I can do this though.
01:37:48 <Myrl-saki> columns :: MonadWidget t m => [Text] -> (forall n. MonadWidget t n => (forall b. [Text] -> m b -> n b) -> n ()) -> m ()
01:38:15 <Myrl-saki> I think it doesn't know what to do with the last (n a)?
01:38:17 <ski> not sure whether you need that extra generality of `column'
01:38:54 <ski> well, to get `m [a]', you'd need to collect results, something. pondering whether that makes sense here (whether it's something that can be done)
01:39:58 <ski> your `page' example could collect .. but possibly that's not something you want a user of `columns' to have to do
01:40:48 <ski> one could probably do something with an output monad, to collect, inside `columns'
01:41:17 <ski> but it's not clear whether functionality like that would be desired/useful ?
01:42:07 <ski> Myrl-saki : btw, you could rename `a' to `b', in the type signature of `column', to better match the naming
01:42:28 <Myrl-saki> ski: Ah. True. Thanks.
01:42:36 <ski> (iow, not confusing it with the `a' in the type signature of `columns')
01:45:06 <kamyar> Hello again
01:45:10 <kamyar> please check my code: http://lpaste.net/355097
01:45:29 <Myrl-saki> ski: For now, I'll just set the constraint to MonadFix.
01:45:30 <kamyar> Ask any question
01:45:37 <kamyar> line 7 is the problem
01:45:46 <kamyar> rand_str contains a IO String
01:45:47 <Myrl-saki> ski: And see if there's something I can't do with it.
01:46:06 <kamyar> I just need to cann redis hset which in second argument gets ByteString
01:46:31 <kamyar> I am trying to use curried feature and use =<< operaor to feed it
01:46:35 <kamyar> What is the problem?
01:49:56 <srhb> kamyar: Look at the expected type and the actual type. That's the relevant bit. Now convince yourself that the expression actually has the type of _actual type_
01:50:14 <srhb> kamyar: Once you've done that, remedy the expression to have expected type.
01:50:24 <srhb> kamyar: Ask if there's a step that doesn't make sense to you. :)
01:50:30 <kamyar> srhb: I think it is evident! I knwo it but how?
01:50:42 <srhb> kamyar: What is evident?
01:50:56 <kamyar> srhb: Your phrases!
01:51:05 <srhb> kamyar: Well, that's a start. :-)
01:51:25 <srhb> Do you agree that the argument *should* be a ByteString in order to typecheck?
01:51:52 <kamyar> srhb: I just do not know how to call a function with signature String -> ByteString -> ByteString -> IO x with an argument of type IO String
01:52:08 <srhb> kamyar: Indeed, you can't. You need a String.
01:52:25 <kamyar> srhb: String is easily converted to ByteString using pack, 
01:52:37 <srhb> kamyar: Indeed, but you don't have a String to convert.
01:52:43 <srhb> kamyar: You have an IO String.
01:52:53 <kamyar> srhb: I need some kind of operator like <$> or =<< to feed the function with inner part of IO String
01:53:22 <srhb> kamyar: You could do that, but since you already have a do block with access to IO via liftIO, why not use it?
01:53:23 <kamyar> srhb: Just watch the next line which is correct!
01:53:52 <cobreadmonster> Does anyone have advice on constructing parsers?
01:53:52 <kamyar> srhb: How?
01:53:54 <srhb> kamyar: ie theString <- liftIO rand_str
01:54:07 <cobreadmonster> I can use parsec, but it's more like a tool than an algorithm.
01:54:12 <kamyar> srhb: Cool! Lets test
01:54:38 <cobreadmonster> I'm trying to parse something with a very loose grammar (like markdown) so I need to be crafty about designing my parser first.
02:06:17 <kamyar> srhb: Anything fixed! I just revised my code using ur guide! I am newbie!
02:08:05 <srhb> kamyar: Welcome to Haskell then. :)
02:08:27 <kamyar> srhb: Wanna see my code and give me more guide?
02:08:46 <srhb> kamyar: Feel free to leave a paste link, others might be able to help as well, especially with concrete questions.
02:09:05 <kamyar> srhb: Thanks!
02:10:06 <kamyar> http://lpaste.net/355098
02:10:31 <kamyar> please help me omit dummy prints! print "test" in line 61
02:10:47 <kamyar> and print $ latitude in line 69
02:11:05 <kamyar> I just dunno how to return a IO () 
02:11:42 <srhb> kamyar: return ()
02:11:59 <srhb> I'm a bit confused by the lift there though.
02:12:17 <cobreadmonster> Any advice?
02:12:57 <kamyar> srhb: Thanks! Fixed!
02:13:39 <kamyar> srhb: Is it a good practice to use IO monad for such functions? saving in redis
02:13:42 <srhb> cobreadmonster: I think the question is currently too broad to give any helpful advice. 
02:13:57 <cobreadmonster> srhb: markdown's corner cases keep fucking me up.
02:13:59 <cobreadmonster> So that's a real problem.
02:14:08 <srhb> kamyar: runRedis :: Connection -> Redis a -> IO a -- so you really can't do much else.
02:14:17 <cobreadmonster> I can't do anything other than assume and back track and I was wondering if there's a cleaner way to do it.
02:14:17 <kamyar> srhb: I mean saveLocation and saveToken in my code
02:14:34 <kamyar> srhb: Thanks! I guessed so
02:14:34 <srhb> cobreadmonster: Perhaps take a look at how Pandoc parses markdown.
02:14:41 <kamyar> srhb: Is my code good for a newbie?
02:14:41 <srhb> cobreadmonster: I imagine that's about as clever as you can get about it.
02:15:19 <srhb> kamyar: I think it looks OK. :)
02:15:36 <kamyar> srhb: Thnk you so much! Feel good now!
02:18:09 <cobreadmonster> srhb: That's a real mess.
02:18:20 <cobreadmonster> I was hoping for something cleaner, because my langauge isn't going to be as complicated.
02:18:24 <cobreadmonster> But I guess not.
03:10:28 <mohsen_> Hi, I'm trying to run this simple program: add x y = x+y
03:10:30 <mohsen_> main = putStrLn (add 2 3)
03:10:39 <mohsen_> But I get this error: https://ptpb.pw/HG-g
03:11:21 <Athas> mohsen_: putStrLn takes a String as argument, but your 'add' function returns a number.
03:11:43 <mohsen_> Athas: Okay, how should I convert it?
03:11:56 <Athas> Due to type inference, the compiler assumes that what you mean is that the 'add' function takes (and returns) a String, which then confuses it further.
03:12:07 <Athas> mohsen_: use the 'show' function to turn a number into a String.
03:12:26 <pacak> Or use print instead of putStrLn
03:12:28 <pacak> :t print
03:12:30 <lambdabot> Show a => a -> IO ()
03:12:30 <pacak> :t putStrLn
03:12:32 <lambdabot> String -> IO ()
03:12:36 <Athas> However, you may still get a warning due to an ambiguity: you are not specifying exactly *which* numeric type you want to use.
03:12:49 <Athas> That 2 and 3 could be an Int, an Integer, a Double, or anything else that can be added.
03:12:56 <Athas> It will default to Integer, however.
03:13:04 <mohsen_> Athas: Can I also define the function so that it takes a number but returns a string?
03:13:13 <Athas> Yes, sure, just call 'show' inside 'add'.
03:13:29 <pacak> But it won't be add anymore...
03:13:47 <ski> call it `showAdd' ?
03:13:50 <mohsen_> Hmmmm
03:14:17 <ski> (you can keep the old `add', if you want to)
03:14:17 <mohsen_> Another question, should I generally define the type reference of functions or let the compiler determine them?
03:14:34 <pacak> Type signatures?
03:14:37 <mohsen_> I mean type definition like this: String -> IO()
03:14:39 <pacak> Add them to all the toplevel things
03:14:56 <ski> for top-level definitions in a module, most people prefer writing explicit type signatures
03:14:56 <mohsen_> Hmmm, what do you mean by toplevel?
03:15:02 <Athas> mohsen_: your choice, but current (compiler-enforced) style is type annotations for all top-level definitions.
03:15:04 <pacak> Error messages will be better if you mess things up.
03:15:13 <Athas> 'Top-level' is anything that is not indented, roughly.
03:15:19 <ski> you can also have local definitions, only visible inside some "parent" definition
03:15:19 <srhb> Athas: Compiler enforced?
03:15:28 <Athas> srhb: ghc -Wall warns about it.
03:15:31 <srhb> I had no idea.
03:15:44 <pacak> Using -Wall is probably a good idea.
03:15:50 <srhb> I do. :-)
03:16:01 * ski thinks John Hughes mostly prefers as few type signatures as possible
03:16:32 <mohsen_> Thanks guys
03:16:32 <Athas> ski: it seems like people from the early days of FP were quite enthusiastic about not having type signatures.
03:16:37 <ski> (istr he said something to that effect)
03:16:57 <Athas> I think it's a relic of trying to compete with Lisp in concision.
03:17:14 <cloudhead> any idea why compilation of Lucid html templates might be really really slow?
03:18:49 <pacak> cloudhead: Optimizations?
03:19:42 <cloudhead> pacak: I mean, why would it be slower than compiling "regular" haskell code is my question
03:19:57 <Athas> It uses Template Haskell, right?
03:19:58 <pacak> cloudhead: TH
03:20:30 <cloudhead> ah does it?
03:20:38 <Athas> Template Haskell is when you kick up your feet and pour yourself a cup of tea after starting the compiler.
03:20:45 <cloudhead> how can I find out
03:20:52 <cloudhead> I'm not sure why it would need TH
03:21:15 <pacak> Athas: Nah, TH can be fast.
03:21:37 <mikeplus64> is there a state monad (in a library somewhere) with no result? i.e. newtype NonStateT m s a = NonState (s -> m s)
03:22:00 <dibblego> it used to be called Pointed
03:22:00 <pacak> In fact I use TH in one project to make compilation faster - it derives typeclass instance that otherwise gets derived by generics
03:22:21 <pacak> When you have 200+ fields - generics are REALLY slow.
03:28:35 <cocreature> lucid doesn’t kneed TH afaik
03:31:08 <cloudhead> cocreature: yeah there is no reason for it to use TH
03:31:18 <cloudhead> I'm not sure what is affected the compile time
03:31:24 <cloudhead> affecting*
03:31:45 <cocreature> cloudhead: what are you comparing it to?
03:31:51 <cloudhead> it seems to be built on top of blaze-builder, so maybe this is slow for blaze too
03:32:31 <cloudhead> cocreature: my average module... when it compiles the lucid views, it takes almost 10s for about 400 lines of code
03:32:51 <cloudhead> I've never seen something take so long for so little code before
03:33:00 <cocreature> cloudhead: what options are you passing to GHC?
03:33:10 <cocreature> cloudhead: in particular, does it also happen if you use -O0?
03:33:54 <cloudhead> I'm only passing warning-related options
03:33:58 <cloudhead> and I have a few extensions enabled
03:34:04 <cloudhead> let me try that
03:37:02 <cloudhead> cocreature: yeah, using the --fast flag (I'm using stack) cuts it down to 1-2s from 10s
03:37:43 <cloudhead> I wonder though why specifically this module
03:38:25 <cocreature> cloudhead: 10s seems slow enough that it might be worth investigating which part of your code is causing the slowdown and make a ghc bug report out of it
03:39:57 <cloudhead> cocreature: ok, will try to isolate it :)
03:40:51 <cocreature> cloudhead: maybe try building it using an older version of GHC, e.g. 7.10. regressions have a pretty good chance of getting fixed
03:41:33 <cloudhead> cocreature: ah yes, good idea
04:17:40 <cocreature> we still don’t have a way to just overload integer literals without implementing all of Num or did I miss something?
04:39:32 <wz1000> cocreature: You can use -XRebindableSyntax and write your own fromInteger.
04:40:22 <cocreature> wz1000: ah good point, thanks
04:58:07 <stevenxl> Hi folks. If I have the following data type declaration: data Fake = Lie | AlternativeFact String Int, can I describe the type Fake as both a sum type, since the values can be Lie or AlternativeFact String Int, as well as a product type, since the data constructor AlternativeFact requires two type arguments?
05:00:40 <Arizona6882> L + A (S * I) ?
05:01:22 <Arizona6882> isnt it just a sum type on top?
05:02:03 <kuribas> yes, it's like Either Lie (String, Int)
05:05:45 <stevenxl> I'm just confused because data Bool = False | True is a sum type. data Person = Person String Int is a product type. if I combine these to form data Nonesense = True | Person String Int, how would we describe Nonesense?
05:05:47 <cocreature> ADTs in Haskell are always sums of products
05:06:19 <cocreature> a type with a single constructor is just a boring sum just like a constructor with no arguments is a boring product
05:08:44 <stevenxl> Oh OK. So sum type just means single data constructor, even if that data constructor takes two type arguments?
05:10:56 <cocreature> you construct the sum type of a set of types my making one constructor for each of those types. if your set of types contains just one type, then the sum type of that is isomorphic to that single type
05:13:29 <stevenxl> hm.. OK. Thank you. I'll have to dissect that sentence a bit, but that gives me a direction to look in. 
05:13:32 <stevenxl> Thanks
05:13:48 <cocreature> stevenxl: not that Person String Int is isomorphic to Person (String, Int)
05:15:21 <cocreature> maybe that makes it a bit clearer how you’re first taking the product of String and Int to get (String, Int) and then the sum of () and (String, Int) to get "data Nonesense = True () | Person (String, Int)" which is then isomorphic to "data Nonesense = True | Person String Int"
05:15:27 <srhb> stevenxl: In case you didn't see it yet, you can also think of it as the number of values encompassed. Each time you introduce a new data constructor (ie Foo a | Bar b) you are adding to the number of terms. There are now (the number of terms of type a) plus (the number of terms of type b)
05:19:44 <Gurkenglas> Does some stack command add the source of all dependencies to the project? (So intero can jump to the definitions)
05:21:57 <bennofs> Gurkenglas: stack already stores all the unpacked source code somewhere in ~/.stack iirc, but intero does not yet support that I believe(?)
05:22:21 <bennofs> Gurkenglas: look at ~/.stack/indices/Hackage/packages
05:26:55 <isqad> Hello, world!
05:31:19 <Gurkenglas> https://github.com/cydparser/demo-emacs-haskell has a block of code under "1. Move any preexisting Emacs configurations". How do I run it?
05:33:17 <cocreature> Gurkenglas: that’s sh
05:34:14 <Gurkenglas> So, uh, I suppose that means I save it in a file with ending .sh and do "sh < thatfile.sh"? Does that work on Windows?
05:34:44 <cocreature> windows does not have a unix shell by default iirc so it probably won’t work
05:35:21 <cocreature> you can install bash on windows
05:35:22 <Gurkenglas> emacs has a shell thing if you do "M-x shell". Can I use that?
05:35:57 <cocreature> I have no idea what exactly M-x shell does, somaybe? :)
05:36:01 <cocreature> *so maybe
05:49:56 <paolino> hi, the type b a can be matched against type family B a so that b becomes B ?
05:50:12 <na_th_an>  close
05:50:21 <paolino> not sure the way to express it
05:50:34 <paolino> quantify over the family ?
05:51:17 <mekeor> paolino: maybe give an example to illustrate your question?
05:52:07 <paolino>  (forall (u' :: Role) . State AcceptanceT u' a -> b (Opponent u') a) -> State s u a -> Either (b Taker a) (b Giver a)
05:52:31 <paolino> this doesn't compile for b cannot match a type family name
05:53:08 <paolino> ehm, it doesn't run
05:53:12 <paolino> it compiles
05:53:44 <paolino> as it is
05:54:47 <paolino> but if I try to match b it fails because b is Part in Couldn't match expected type ‘b (Opponent u') a’
05:54:48 <paolino>                   with actual type ‘Part (Opponent u') a’
05:55:26 <paolino> so the compiler cannot set b to Part
05:55:38 <paolino> that's my understanding
05:57:54 <paolino> so my question is if it's because Part is a TF or something else 
06:04:21 <paolino> mekeor, http://lpaste.net/355105
06:07:27 <godfrey> anyone knows how to make a type that only contains value of a sequence in haskell?
06:07:56 <godfrey> e.g. a type that can only contain even numbers
06:14:45 <srhb> godfrey: Actually constraining this at the type level needs dependent types, and it's tricky.
06:15:02 <srhb> godfrey: If you don't absolutely need this, you are better off using a smart constructor to prevent such values from being generating in user-facing code.
06:15:28 <godfrey> ummmmmm
06:15:38 <srhb> godfrey: (ie. hide the actual Even constructor and have a mkEven :: Integer -> Maybe EvenInteger)
06:15:41 <godfrey> I am just wondering if it's possible to achieve this in haskell 
06:15:53 <srhb> godfrey: It is, though it's not easy. :)
06:16:05 <srhb> godfrey: Good languages for this sort of thing are Agda, Idris and friends.
06:16:08 <godfrey> yeah I know that trick
06:16:31 <godfrey> hiding the constructor and using Maybe type 
06:16:34 <srhb> Right.
06:17:10 <srhb> If you absolutely want to try, you'll need to do something like a Nat type which only has even numbers. Ie. inductively define it to be either Zero or Succ (Succ n) or something like that.
06:17:30 <srhb> Well, at least that's one approach/
06:17:41 <godfrey> lol
06:18:08 <godfrey> do you know any place that I can look up some material about this ?
06:19:30 <srhb> godfrey: Here are some approaches, one involving liquid haskell: https://www.reddit.com/r/haskell/comments/225j2w/how_would_you_define_a_type_for_even_integers/
06:21:34 <godfrey> kk
06:21:40 <godfrey> srhb: many thanks ;D
06:22:40 <srhb> godfrey: I will also recommend trying it in Agda afterwards for comparison :)
06:22:58 <godfrey> sure lol
06:29:44 <Gurkenglas> I got http://lpaste.net/3532185850169262080 from following https://github.com/cydparser/demo-emacs-haskell from inside emac's shell. I'm on Windows. I have admin rights. What do? (At the end it's complaining about lack of permissions, that shouldn't happen, right?)
06:44:09 <Gurkenglas> (Simply executing the command again made it work. ...)
06:45:46 <jophish> Does anyone else get really odd behaviour in ghci when editing overlong lines?
06:46:16 <jophish> basically, when a line extends past the length of my terminal it becomes really garbled
06:46:33 <MarcelineVQ> I get that in my shell sometimes, makle sure it's not a terminal issue before a ghci one if you can
06:47:17 <jophish> ah, I've found the issue
06:47:33 <jophish> I had this: :set prompt "ESC[34mλ> \ESC[m"
06:47:47 <jophish> I think that ghci was taking the length of this string incorrectly
06:48:09 <Tuplanolla> I've had that happen on RHEL without any special characters, jophish.
06:48:48 <jophish> the lambda seems fine, it's just the coloring that breaks it for me
06:49:00 <Tuplanolla> I think it was a terminal emulator issue where line wrapping worked incorrectly.
06:51:53 <jophish> ah, wrapping the escape codes with \001 and \002 fixed it
06:52:03 <jophish> :set prompt "\001\ESC[34m\002λ>\001\ESC[m\002 "
07:13:32 <fresheyeball> quick question
07:13:49 <fresheyeball> lets say I need to run the same IO action over and over until a specific value is returned
07:14:09 <fresheyeball> I know how to do this with hand recursion, but is there a better way?
07:14:26 <Gurkenglas> Trying to use intero. Here's an emacs messages buffer. http://lpaste.net/4267388761236570112 Trying to use intero's M-. feature to jump to a definition adds invalid argument lines to that buffer. There are four chronologically ordered times that this worked, didnt work, worked and didnt work. They are iirc pairwise separated by at least one emacs restart. What do I do about this?
07:14:54 <fresheyeball> I'm thinking kind of a Monadic until function
07:15:20 <fresheyeball> untilM :: (a -> Bool) -> m a -> m [a]
07:19:46 <jophish> fresheyeball: you might be interested in this package https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
07:48:27 <mbw> Hi everyone. I wanted to ask a few questions about Repa, and intended to do so either on SO, Reddit or haskell-cafe. Unfortunately, Ben Lippmeier (the author of Repa) hasn't been online on SO since 2014, and from what I found out he's busy with other stuff now. On the other hand, my question might actually be more general than that, and has become more lengthy than I intended. So before I post it anywhere, I 
07:48:32 <mbw> would appreciate some input on this: Where to post it, whether it is clear what I'm asking or if it is just a waste of time. Any advice is appreciated - even if you don't have much experience with Repa, since it might just as well be a more general exercise in program transformation or equational reasoning. It can be found here: http://lpaste.net/355107 . Thanks in advance for any advice you might have!
07:52:54 <bf_> Hi everyone
07:53:19 <bf_> I have a question about encoding in ghc/base
07:54:30 <bf_> I want ghc/base to use the default encoding scheme (user's locale) but with the //ROUNDTRIP feature enabled
07:54:38 <bf_> How do I do that?
07:59:30 <geekosaur> https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/base-4.9.1.0/GHC-IO-Encoding.html
08:02:32 <fresheyeball> is there a function to cycle a list?
08:02:41 <fresheyeball> [1,2,3] -> [2,3,1] ?
08:03:09 <byorgey> fresheyeball: no
08:03:18 <Tuplanolla> There's one to do that infinitely, fresheyeball.
08:03:20 <srhb> fresheyeball: Usually people just take and drop the relevant parts after cycling (repeating endlessly) the original list
08:03:43 <byorgey> > drop 1 . take 3 . cycle $ [1,2,3]
08:03:46 <lambdabot>  [2,3]
08:03:52 <byorgey> hehe, whoops
08:04:00 <byorgey> > take 3 . drop 1 . cycle $ [1,2,3]
08:04:03 <lambdabot>  [2,3,1]
08:04:22 <fresheyeball> :t cycle
08:04:24 <lambdabot> [a] -> [a]
08:04:32 <byorgey> > cycle [1,2,3]
08:04:32 <fresheyeball> so what does cycle do?
08:04:34 <xa0> http://lpaste.net/revision/98916 i have this problem with postgresql-simple, anyone know why?
08:04:35 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
08:04:38 <fresheyeball> oic
08:04:39 <erisco> I had a nice way to find the rotations... let me see if I can find it again
08:04:55 <lyxia> mbw: a markdown gist would help with formatting, then I'd just put it on reddit
08:05:14 <srhb> bf_: I don't think you can adjust what GHC reads source files as. I think it'll just be UTF8 always, but you can ask in #ghc
08:05:24 <erisco> ah yes, that is it... first you find the partitions and then you can find the rotations
08:05:45 <c_wraith> what about the "zipWith const" trick?
08:05:59 <c_wraith> That's a really important trick for maintaining laziness!
08:06:02 <geekosaur> bf_, srhb, the Haskell report specifies that Haskell source is UTF8
08:06:19 <fresheyeball> let spinby x xs = take (length xs) $ drop x $ cycle xs
08:06:30 <erisco> > partitions [1,2,3]
08:06:32 <lambdabot>  [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([3,2,1],[])]
08:06:34 <erisco> > rotations [1,2,3]
08:06:36 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[3,2,1]]
08:06:44 <fresheyeball> Oooo
08:07:05 <Tuplanolla> The last one is bogus.
08:07:06 <fresheyeball> rotations xs !! 1
08:07:08 <kuribas> > zipWith const [5..] [1..5]
08:07:12 <lambdabot>  [5,6,7,8,9]
08:07:22 <c_wraith> fresheyeball: "take (length xs)" is too strict.  use the zipWith const trick instead. :)
08:07:28 <fresheyeball> > rotations [1,2,3] !! 1
08:07:30 <mbw> lyxia: I haven't done this before. gists are a git thing, right? It would be my first reddit post also. Since you seem to have read it, was it clear to you?
08:07:31 <lambdabot>  [2,3,1]
08:07:33 <erisco> I can give you the source or let you figure it out... if you like that solution
08:07:54 <lyxia> xa0: the root module only exports FromRow without its method. you can import Database.PostgreSQL.Simple.FromRow
08:07:55 <fresheyeball> kuribas: how? I don't have a bounded thing, I just have a list of a
08:08:10 <xa0> lyxia: ah! thanks!
08:08:56 <fresheyeball> > let spinBy x xs = zipWith const [length xs..] (cycle xs)
08:08:58 <lambdabot>  <no location info>: error:
08:08:58 <lambdabot>      not an expression: ‘let spinBy x xs = zipWith const [length xs..] (cycle...
08:09:22 <fresheyeball> I guess, what is too strict about my solution?
08:09:30 <c_wraith> fresheyeball: length forces the entire list
08:10:06 <Tuplanolla> > let xs = [1, 2, 3] in all (`isInfixOf` cycle xs) (rotations xs) -- This should hold, erisco.
08:10:13 <lambdabot>  mueval: ExitFailure 1
08:10:23 <erisco> Tuplanolla, I know it isn't all of them
08:11:01 <c_wraith> > let rotate n xs = zipWith const (drop n $ cycle xs) xs in rotate 10 [1..]
08:11:04 <erisco> Tuplanolla, there is a specific reason as to why
08:11:04 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
08:11:15 <c_wraith> fresheyeball: That wouldn't work with the length variant
08:12:26 <fresheyeball> c_wraith: is it possible to do this operation on an infinite list?
08:12:34 <dolio> erisco: [3,2,1] isn't a rotation of [1,2,3] at all. And ([3,2,1], []) isn't a partition of [1,2,3].
08:12:37 <fresheyeball> don't we need to know the end of the list?
08:12:42 <c_wraith> fresheyeball: nope!
08:12:55 <fresheyeball> ok so let me see how you would write this
08:13:02 <c_wraith> fresheyeball: I just did?
08:13:16 <fresheyeball> such that :: Int -> [a] -> [a]
08:13:26 <c_wraith> fresheyeball: I just did.  Look up
08:13:35 <bf_> geekosaur: thanks
08:13:42 <erisco> dolio, under a different specification, sure. I am just offering what I had
08:14:38 <bf_> srhb: no I meant for normal IO especially file names and stuff
08:14:40 <fresheyeball> c_wraith: sorry I don't see it
08:14:47 <fresheyeball> I see you referencing the zipWith const trick
08:14:58 <fresheyeball> but I don't see how to use that without also forcing the list with length
08:15:22 <fresheyeball> even in the abstraction, I am having troubling seeing how you could rotate an infinite list
08:15:33 <c_wraith> > let rotate n xs = zipWith const (drop n $ cycle xs) xs in rotate 10 [1..] -- this exact thing before the comment that I entered above?
08:15:37 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
08:16:52 <nshepperd> well, one can question whether an infinite list that is rotated really counts
08:16:56 <c_wraith> > let rotate n xs = zipWith const (drop n $ cycle xs) xs in rotate 10 [1..12] 
08:16:59 <lambdabot>  [11,12,1,2,3,4,5,6,7,8,9,10]
08:17:12 <c_wraith> I mean, it's definitely a rotate function.
08:17:27 <nshepperd> since you can't find [1..10] at the "end" of an infinite sequence
08:17:41 <Tuplanolla> I suddenly forgot how to write the pointless form of `\ x -> f (g x) x`.
08:17:46 <c_wraith> It works maximally sensibly.
08:17:57 <c_wraith> It produces output on the assumption it'll eventually work.
08:18:03 <c_wraith> Which is much better than just exploding.
08:18:25 <mbw> (Haskellers and their lists...)
08:18:38 <nshepperd> Tuplanolla: i bet it contains <*>
08:18:51 <Gurkenglas> Tuplanolla, g >>= f
08:19:22 <lyxia> mbw: yeah I got most of it though I only skimmed it. gist is a good place to put lots of text if you don't have a blog, for the formatting.
08:19:34 <c_wraith> I mean, from a program's standpoint, what's the difference between an infinite list and a list of all Int on 64-bit ghc?  You'll never iterate through either.
08:20:08 <c_wraith> Best to produce output immediately
08:20:15 <Tuplanolla> Ah, yes.
08:20:23 <dolio> You can even prove it's "at the end".
08:20:29 <mbw> lyxia: So if I got it right, I put the whole thing in the gist, and on Reddit instead of Post Text I use Post Link?
08:20:55 <dolio> Where that means that there is a list l such that 'l ++ [1..10]' is what you get.
08:21:20 <mbw> lyxia: Also, I don't think I am using the term "equational reasoning" correctly, since it is used in the context of proving things. Am I wrong?
08:22:58 <Tuplanolla> So indeed `rotate n = drop n . cycle >>= zipWith const`.
08:23:43 <lyxia> mbw: Yeah taht's how you do it. Your use of "equational reasoning" it looks fine.
08:25:38 <Gurkenglas> Now find a version of rotate n that uses O(n) space.
08:25:39 <mbw> lyxia: Ok then I will try to do it this way. Hopefully something useful comes out of this. Now I just need a descriptive title...
08:25:52 <c_wraith> Gurkenglas: my version does. :P
08:26:00 <erisco> dolio, I went back over it and the reversal of the last partition was indeed a mistake. Thanks!
08:26:04 <fresheyeball> c_wraith: sorry I crashed my box
08:26:08 <fresheyeball> can you repost your version?
08:26:14 <Gurkenglas> c_wraith, that uses O(length xs) space
08:26:49 <c_wraith> Gurkenglas: nope.  It uses O(n) space.  It forces n more list elements than it returns.
08:27:31 <Gurkenglas> c_wraith, it keeps track of all of xs even though it needs only the first n elements
08:27:33 <c_wraith> Gurkenglas: so assuming the producer uses O(1) space and the consumer uses O(1) space, the total memory use is O(n)
08:28:13 <fragamus> what's the most hipster cool parsing library available
08:28:16 <fresheyeball> I just want to see the version pleeeease
08:28:17 <Gurkenglas> When "rotate 3 [1..100]" is at (53, 50), 40 is still in memory
08:28:30 <c_wraith> Gurkenglas: oh, I guess cycle does keep the full thing around.
08:29:20 <erisco> > (partitions &&& rotations) [1,2,3]
08:29:22 <lambdabot>  ([([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])],[[1,2,3],[2,3,1],[3,1,2...
08:29:40 <erisco> well it is all better now :)
08:29:46 <c_wraith> :t liftA2 (++) (drop n) (take n)
08:29:47 <lambdabot> error:
08:29:48 <lambdabot>     • Couldn't match expected type ‘Int’ with actual type ‘Expr’
08:29:48 <lambdabot>     • In the first argument of ‘drop’, namely ‘n’
08:29:50 <c_wraith> hah
08:29:56 <c_wraith> :t \n -> liftA2 (++) (drop n) (take n)
08:29:58 <lambdabot> Int -> [a] -> [a]
08:30:07 <Gurkenglas> Still O(n)
08:30:10 <Gurkenglas> *length xs
08:30:15 <peddie> has anyone here used SBV to prove properties about floating-point programs?  I've just got started and am curious what kind of performance I should expect.  I managed to run about 20 lines of code overnight last night
08:30:41 <c_wraith> yeah, you'd have to force the entirety of the taken list in order to let go of the reference to xs
08:30:57 <erisco> peddie, I am using it for other purposes and I think it is much more to do with the solver than SBV
08:31:24 <peddie> erisco: interesting, thanks -- I'm using Z3.  do you happen to know whether there is a better solver for the FP theories?
08:31:34 <erisco> if you're solving boat loads of problems then maybe SBV is a bottleneck for you
08:31:45 <erisco> but in my case I send tough problems at the solver and it takes a while
08:31:55 <peddie> erisco: how long is "a while?"
08:32:05 <dolio> Do any SMT solvers actually know about floating point, or do people just tell them to assume they're real numbers, even though that's wrong?
08:32:12 <peddie> dolio: you can go either way
08:32:25 <peddie> there are theories for IEEE floating-point numbers and for algebraic reals
08:32:26 <erisco> depends what I throw at it, but worse has been a couple minutes, which in my application counts as far too long
08:32:46 <erisco> I don't know which has the best FP theory support, sorry
08:33:16 <peddie> erisco: got it, thanks.  I realize I'm asking it to prove stuff about 64-bit doubles, so the search space is obviously massive.  I'm just not sure how effective the FP theory is at reducing it
08:33:48 <Gurkenglas> :t \n xs -> let (t, d) = splitAt n xs in d ++ t -- c_wraith
08:33:50 <lambdabot> Int -> [a] -> [a]
08:34:22 <peddie> erisco: mind if I ask what your application is?
08:34:31 <erisco> as you might expect, my experience is if you do simple things then it tends to be alright
08:34:37 <c_wraith> Gurkenglas: it's the same thing as forcing the taken portion.  With one less traversal of xs, but the memory use is the same.
08:35:04 <erisco> but if you start mixing and nesting quantifiers, for example, it becomes really unhappy
08:35:21 <peddie> erisco: yeah, I ran some simpler things which took anywhere from about 1 second to 10 minutes.  haven't added any quantifiers yet.
08:35:23 <erisco> or if you start using quantifiers on array indicies which I had to abandon entirely
08:36:39 <erisco> peddie, I am constructing puzzles. I am using it to find solutions of a puzzle and also to find constraints to add to a puzzle to limit the number of solutions
08:36:57 <erisco> I had to stop asking it the latter because it was too slow. I wrote a custom solver instead which is significantly faster
08:37:02 <peddie> what kind of puzzles?
08:37:09 <shapr> ooh, sgt puzzles?
08:37:30 <erisco> and now it is too slow for finding solutions of puzzles of 8x8, so I will have to write my own solver for that as well =\
08:37:37 <peddie> haha, OK
08:37:39 <erisco> after so long fiddling with it lol
08:38:30 <peddie> I guess we know it is NP-hard, after all -- we shouldn't expect it to be fast on problems of significant size :)
08:38:45 <peddie> maybe I will have to give up on it
08:38:55 <pie_> hey. you guys have anything good to listen to while half-occupied?
08:39:02 <MarcelineVQ> what a neat little puzzle collection
08:39:05 <erisco> well, the problem is that I have to make my problem harder when I map it to what the solver understands
08:39:25 <pie_> MarcelineVQ, puzzles?
08:39:31 <pie_> :D
08:40:15 <MarcelineVQ> yeah, looks like a fun target for ML learning
08:40:28 <peddie> erisco: if `prove` is this slow, I can't imagine how slow `optimize` would be
08:40:45 <erisco> not necessarily harder in a complexity sense. I am not sure about that. but certainly the number of variables and size of expression explodes
08:41:24 <MarcelineVQ> pie_: oh I meant the '<shapr> ooh, sgt puzzles?'
08:41:37 <shapr> yeah, I like sgt puzzles
08:41:52 <peddie> erisco: that's what kills you in an NP-hard problem :)
08:42:46 <pie_> MarcelineVQ, i know you were talking to someone else :P
08:45:06 <erisco> peddie, a puzzle is an unsolved board and a list of patterns. An unsolved board is a finite grid with pieces in some cells. A pattern is a grid with possible pieces in its cells.
08:45:46 <erisco> peddie, the puzzle is solved when the board is complete and for each pattern there exists some sub-grid of the board which it matches
08:47:23 <fresheyeball> is there a right way to keep a haskell process from exiting?
08:47:27 <erisco> my method of construction should work for many kinds of puzzles
08:47:48 <fresheyeball> I am using `void getLine`
08:47:50 <fresheyeball> feels dirty
08:47:59 <erisco> first I find up to two solutions of the puzzle. if there is just one then I am done. if there are none then I screwed up the initial puzzle... heh
08:48:04 <jchia_1> Question about TypeFamilies. Is it possible to require that the type synonym inside a class have an instance of some other class? E.g.: http://lpaste.net/355108
08:48:25 <erisco> with two solutions I then find a new constraint (in this case a pattern) to add which satisfies one solution but not the other
08:48:36 <erisco> I then repeat this process until one solution remains
08:49:20 <lyxia> jchia_1: yes
08:49:21 <erisco> this just depends on the initial puzzle having at least one solution and for there to always be some constraint which can satisfy one solution but not another
08:49:27 <erisco> then it converges on one solution
08:49:29 <jchia_1> lyxia: How do I express it?
08:49:35 <erisco> ... also assuming there are finite solutions
08:49:43 <DrMentats> fresheyeball: you could either sleep in a loop or use an MVar
08:49:56 <lyxia> jchia_1: class (Ix (Tag s)) => Taggable s
08:50:03 <erisco> annoyingly ever since people started talking about infinity we have to keep qualifying our quantities :P
08:50:11 <lyxia> jchia_1: + a bunch of language extensions
08:50:22 <lyxia> the compiler will tell you
08:50:42 <erisco> the challenge is constructing interesting puzzles rather than just any puzzle
08:51:48 <shapr> How do you define interesting? That sounds like a difficult task.
08:51:51 <lyxia> jchia_1: http://hackage.haskell.org/package/persistent-2.7.0/docs/Database-Persist-Class.html#t:PersistEntity is a prime example of this
08:52:01 <jchia_1> lyxia: Thanks, it seems to work.
08:52:09 <erisco> so if you applied this to Sudoku you would start with an initial board and find two solutions. then you'd choose any cell on one solution which didn't match the same cell on the other
08:52:17 <erisco> then repeat this process until one solution remains
08:52:44 <jchia_1> lyxia: Putting Tag before Taggable seemed a bit counter-intuitive, so I didn't think to try that.
08:53:02 <erisco> but still the challenge of finding interesting puzzles and not just any puzzle
08:53:23 <fresheyeball> DrMentats: how would I use an MVar?
08:53:38 <fresheyeball> I thought this would work `newMVar () >>= readMVar`
08:53:42 <fresheyeball> but it doesn't hold on
08:53:59 <lyxia> jchia_1: yeah it looks surprising at first
08:54:36 <MitchellSalad> fresheyeball: you'd have to 'takeMVar' on some MVar that some other thread will eventually put to
08:54:36 <erisco> shapr, yes it is annoying :P
08:55:12 <MitchellSalad> like this: 'mv <- newEmptyMVar; <fork worker thread stuff>; takeMVar mv'
08:55:13 <erisco> from the outset I have the problem that I cannot just search the whole space to find interesting puzzles
08:56:06 <erisco> so instead I devise some criteria for where I'd like the puzzle to head as I am constructing it
08:56:10 <DrMentats> fresheyeball: then either putMVar from the worker thread when you want to exit
08:56:18 <fresheyeball> Ok that worked, thanks!
08:56:20 <DrMentats> or never do it if you want it to run forever
08:56:27 <erisco> constraint forms that I'd like to add to the puzzle
08:56:28 <fresheyeball> I didn't know about emptyMVars (I never use them)
08:56:56 <erisco> and as I am constructing I then devise a way to search through the possibilities in a way that closely matches what I am looking for
08:57:07 <nello78> ciao
08:57:08 <erisco> I may end up with an exact match or a close match. I cannot guarantee anything
08:57:18 <MitchellSalad> fresheyeball: an MVar is either empty or full; reads block on an empty MVar and writes block on a full MVar
08:57:45 <erisco> so with a model of these criteria I can then consider generating criteria themselves
08:57:56 <nello78> !list
08:58:34 <erisco> shapr, this is one of my secret weapons for doing that directed search http://hackage.haskell.org/package/data-list-zigzag
09:00:02 <erisco> another reason I need a custom solver is because it matters greatly as to what two solutions I find
09:00:17 <shapr> erisco: that's neat
09:00:27 <erisco> if the two solutions are too close together (which CVC4 likes to do, for example) then I cannot find any interesting constraints
09:00:35 <erisco> because almost everything matches both solutions
09:00:44 <shapr> erisco: So now you want to write an article about directed puzzle finding and ZigZag for The Monad.Reader, right?
09:00:52 <erisco> but I also cannot afford to search through the whole solution set
09:01:07 <erisco> haha
09:01:32 <shapr> erisco: please yes?
09:01:52 <shapr> You know I'm the new editor, aka person who must regularly beg for articles, yeah?
09:01:53 <erisco> it'd be premature at this point because I am still working on it
09:02:05 <shapr> I'm hoping to publish in July
09:02:22 <erisco> I have settled ZigZag but orphaned from the way I am using it there isn't much to talk about
09:02:42 <jchia_1> Given a data type T that has Bounded & Enum instance, is there a way to obtain a KnownNat for the fromEnum (maxBound :: T) - fromEnum (minBound :: T)?
09:03:08 <shapr> I wish I could bribe glguy into writing an article about which libraries to import in order to solve programming puzzles in the least amount of time, along with some selections from his Advent of Code 2016 solutions.
09:04:39 <jchia_1> E.g. if I have data Foo = Bar | Baz deriving (Bounded, Enum), I would like to get a KnownNat 1.
09:05:37 <glguy> jchia_1: At best you can get a 'Maybe SomeNat'
09:10:29 <jchia_1> glguy: That sounds like just someNatVal (fromEnum maxBound - fromEnum minBound).
09:10:35 <glguy> right
09:13:13 <cocreature> if you ensure that it’s not negative fromJust should be safe
09:16:57 <jchia_1> Is zero included as one of the natural numbers for the purpose of type literals?
09:17:25 <glguy> Yes, 0 is a natural number
09:17:38 <jchia_1> glguy, cocreature: thanks
09:23:16 <Gurkenglas> Anyone using intero on windows? I seem to be having a problem with phantom ^M path endings
09:24:31 <Myrl-saki> Why did they create PVP when Semver is already there?
09:26:38 <glguy> I think because of lack of time travel and because pvp has Haskell specific rules
09:28:49 <c_wraith> Myrl-saki, the time travel part is important. semver is only already there if you're going backwards in time. 
09:29:50 <cocreature> those lazy haskellers just didn’t want to invent time travel
09:30:04 <ggVGc> lack of time travel is such a nuisiance in general
09:30:08 <MarcelineVQ> new in ghc 9...
09:30:20 <Myrl-saki> Time travel?
09:30:21 <Myrl-saki> ._.
09:30:22 <glguy> If we had time travel we might not even need versioning, just go back in time to the initial package release any time you found a bug and fix it
09:30:42 <c_wraith> Myrl-saki, in particular, semver was not already there. the pvp is older.
09:30:48 <ggVGc> glguy: how do you solve merges?
09:30:56 <ggVGc> what if we both go back to the same version and fix it
09:31:01 <ggVGc> how do we manage time branches
09:31:05 <ggVGc> we're gonna need time-git
09:31:06 <glguy> With git
09:31:12 <Myrl-saki> c_wraith: Oh
09:31:24 <Myrl-saki> I'm stupid lmao
09:31:28 <rotaerk> git to the future
09:31:56 <ggVGc> there's a problem with git though
09:31:56 <glguy> Things start getting confusing when timelines are rebased
09:31:58 <ggVGc> it's not written in haskell
09:32:24 <glguy> You're worried too many people will use it?
09:32:28 <MarcelineVQ> supra-liminal-darcs
09:32:30 <ggVGc> glguy: how do we manage the access keys for commits to different branches of time?
09:32:49 <c_wraith> rebasing timelines is how you get Back to the Future 2.
09:32:54 <c_wraith> you don't want that. 
09:33:06 <ggVGc> have you guys seen the time-branching episode of Rick and morty?
09:33:29 <MarcelineVQ> c_wraith: luckily a later commit reverted the rebase
09:34:33 <MarcelineVQ> mmm it wasn't really time branching though was it, it was multiverse-branching, it just involved a 'time crystal'
09:41:02 <peddie> erisco: thanks for the description, that sounds cool :)
09:52:18 <Gurkenglas> Pressing M-. using intero for emacs on Windows produces lines like "make-directory: Creating directory: Invalid argument, c:/Users/Gurkenglas/intero-demo^M" (where the ^M disappears when you copypaste the line - I reinserted it here.) What do?
10:01:27 <Gurkenglas> "<sg2002> That stack thing even pulls msys2 and puts it into AppData. That's like even worse than defiling your PC with Haskell..." <- Is that bad, and is that necessary?
10:19:04 <Gurkenglas> To all who search the logs about my emacs problem in the future, it seems to appear iff I'm currently working from a desktop file (ie a session that's previously been saved when closing it) and removing the line that I put in the .emacs config myself to enable that got rid of this.
10:29:19 <paolino> mh ghc got confused by me redefining Any
10:29:36 <paolino> well, defining actually
10:31:19 <paolino> I changed to another name and now it compiles, GHC.Prim.Any got precedence without name clashing error
10:32:44 <bollu> is there any intuition behind the naming of runState / execState / evalState?
10:32:56 <bollu> I tend to google all three and find the one I want
10:33:09 <bollu> is there some sort of naming convention / mnemonic I'm missing?
10:33:39 <MarcelineVQ> yes, reflected in the types
10:34:49 <paolino> eval is forget the state, exec is forget the value 
10:36:38 <mathk> Hi, in the parallel library can someone explain the difference between `evalList` and `parList` ? One difference that I can see is that the number of Spark is twice the length of the list with `parList` will it is exact length of list for the other.
10:38:21 <cocreature> mathk: the source of parTraversable and evalTraversable (evalList and parList are just special cases of that) is probably the best explanation https://hackage.haskell.org/package/parallel-3.2.1.1/docs/src/Control.Parallel.Strategies.html#parTraversable
10:38:22 <Gurkenglas> bollu, eval as in evaluate as in value, run as in unpack the newtype, exec as in execute as in shut up and do the work
10:38:34 <MarcelineVQ> mathk: parList has an implicit  rparWith  added to your strategy
10:39:05 <MarcelineVQ> via parTraversable
10:39:48 <shapr> Has anyone tried https://github.com/iostreamer-X/FuncShell ?
10:40:06 <MarcelineVQ> cocreature: oop beat me to it :>
10:40:11 <bollu> :t evalState
10:40:13 <lambdabot> State s a -> s -> a
10:40:16 <bollu> :r runState
10:40:18 <bollu> :t runState
10:40:20 <lambdabot> State s a -> s -> (a, s)
10:40:22 <bollu> :r execState
10:40:25 <bollu> :t execState
10:40:27 <lambdabot> State s a -> s -> s
10:40:31 <bollu> ehh, I find "exec" weird
10:40:36 <bollu> but I get your point I guess
10:41:33 <cocreature> “parallel” is one of those packages that I’ve know about for a long time but I’ve never had a reason to use it
10:42:06 <MarcelineVQ> async is so much more common for your uses?
10:42:16 <cocreature> yep
10:43:22 <mathk> MarcelineVQ,  not really understanding the idea behind
10:44:27 <mathk> I am reading the book "https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/"
10:44:56 <mathk> "Parallel and Concurrent Programming in Haskell"
10:45:34 <MarcelineVQ> hmm, that's an odd place to find that, you can read it here without needing a sign in as well http://chimera.labs.oreilly.com/books/1230000000929/index.html
10:46:08 <Gurkenglas> With emacs, 'C-c p R' as per https://github.com/cydparser/demo-emacs-haskell/blob/master/demo.org#jump-to-dependency-definitions produces 'projectile-regenerate-tags: codex: C:\Users\Gurkenglas\Vorlagen: getDirectoryContents:findFirstFile: permission denied (Zugriff verweigert)' in the minibuffer. What should I do?
10:47:58 <Gurkenglas> (No idea why it's looking for a Vorlagen folder there. There's no such folder there.)
10:51:22 <EvilMachine> Hi. I’m wondering: How does GHCi load modules on the fly or how does the RTS load dynamic modules/libraries? There is a common pattern in software of modular software and dynamic libraries. It has been suggested to me that this goes against the ideas behind Haskell and that I shouldn’t do it. (E.g. because type safety of modules unknown at compile time can obviously not be checked, or something.) So how is that patt
10:51:22 <EvilMachine> ern meant to be used, or what does one want instead when believing one wants such a pattern?
10:52:34 <EvilMachine> (And I mean specifically when the main software only knows (in Java terms) Interfaces, and the modules provide (again in Java terms) Implementations.)
11:27:44 <rotaerk> hmm... is it normal when parsing to have to express something as (a <* c) <|> (b <* c)  instead of  (a <|> b) <* c
11:28:21 <johnw>  depends on which library you're using, and the way that 'a' is failing
11:28:34 <johnw> or wait, maybe not on 'a'...
11:28:36 <johnw> I'd expect that to work
11:29:36 <rotaerk> well, the string I'm parsing might have substrings that are also valid a's, but I want it to consume all the way up to the c
11:30:06 <Hamlet> Need help with this script / program ..
11:30:13 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
11:31:38 <acertain> is there some way to get a free monad over a mtl-style typeclass?
11:31:44 <acertain> without writing a GADT
11:31:59 <kuribas> :t ($>)
11:32:00 <lambdabot> error:
11:32:00 <lambdabot>     • Variable not in scope: $>
11:32:00 <lambdabot>     • Perhaps you meant one of these:
11:32:09 <kuribas> :t (<$)
11:32:11 <lambdabot> Functor f => a -> f b -> f a
11:33:17 <mauke> Hamlet: your code is misnested
11:33:48 <rotaerk> if I do (a <|> b) <* c, instead of consuming the a up to the c, it will consume the valid substring that matches a, and then fail because it's not immediately followed by the c
11:33:49 <mauke> 'myGivenNumber' (which you need on the outside) is a variable that only exists on the inside
11:34:06 <jship> @Hamlet This is a scoping problem.  Try making myGivenNumber part of the 'where' too and then it will be accessible in largestPrimeFactor
11:34:06 <lambdabot> Unknown command, try @list
11:34:39 <Hamlet> I don't understand
11:34:47 <mauke> Hamlet: you can use 'let' for both myGivenNumber/largestPrimeFactor, or 'where' for both, or 'let' for largestPrimeFactor and 'where' for myGivenNumber
11:34:55 <mauke> any of those will work
11:35:03 <mauke> you've picked the one combination that makes no sense
11:35:13 <mauke> a 'where' clause attaches to a declaration, not an expression
11:35:28 <mauke> i.e. 'largestPrimeFactor' scopes over the body of 'main'
11:36:04 <mauke> but 'myGivenNumber' only exists within 'main'
11:36:14 <Hamlet> can you fix it?
11:36:19 <mauke> yes
11:36:24 <mauke> and so can you, because I told you how
11:36:52 <lyxia> rotaerk: the behavior of (<|>) varies a lot depending on the parser
11:37:08 <Hamlet> how?
11:37:20 <mauke> Hamlet: you can use 'let' for both myGivenNumber/largestPrimeFactor, or 'where' for both, or 'let' for largestPrimeFactor and 'where' for myGivenNumber
11:37:23 <mauke> any of those will work
11:39:30 <acertain> is there TH somewhere to make a functor for use with free from a mtl-style typeclass?
11:39:56 <johnw> acertain: can you be a bit more specific?
11:41:05 <rotaerk> lyxia, ah
11:43:46 <jle`> someone unleased a markov bot of haskell buzzwords onto #haskell again :)
11:46:58 <acertain> actually i guess i just want like MonadReader => `data MonadReaderGADT r m a where Ask :: MonadReaderGADT r m r; Local :: (r -> r) -> MonadReaderGADT r m a -> MonadReaderGADT r m a; Reader :: (r -> a) -> MonadReaderGADT r m a`
11:47:29 <acertain> uh
11:47:36 <acertain> also `Lift :: m a -> MonadReaderGADT r m a`
11:47:37 <johnw> can you move reader constraint into the constructor types?
11:47:53 <johnw> that would make them only "evaluatable" in a MonadReader context
11:47:54 <acertain> huh?
11:47:59 <johnw> without having to construct them in such a context
11:48:18 <johnw> data Foo a where Foo :: MonadReader r b => a -> Int
11:48:30 <acertain> no i need to inspect the GADT
11:48:39 <johnw> inspection would incur the constraint
11:48:47 <acertain> like pattern match on it
11:48:56 <johnw> why wouldn't you be able to?
11:49:13 <johnw> note: I use this pattern all the time, so maybe I haven't understood your query
11:50:34 <acertain> i want to be e.g. foo Ask = bar; foo (Local f n) = baz
11:50:44 <johnw> why wouldn't that work?
11:51:00 <acertain> i could final-encode that, but i'd rather not
11:51:12 <johnw> what does final encoding have to do with this?
11:51:47 <acertain> i want to generate the corresponding initial encoding GADT from a final encoding typeclass
11:51:49 <acertain> basically
11:52:27 <acertain> ignoring laws
11:52:50 <acertain> i just don't want to write the GADT by hand
11:53:02 <johnw> ah
11:53:06 <johnw> I see
11:53:11 <johnw> you want reify a Monad* interface
11:53:22 <johnw> usually, you just write an instance to do this
11:53:23 <mathk> So when do I need to use evalList vs. parList ?
11:53:40 <johnw> instance MonadReader r MonadReaderADT where ask = Ask; local = Local, etc.
11:54:01 <johnw> then, take your MonadReader term, evaluate it to a MonadReaderADT value, and there you go
11:54:17 <acertain> sure, i just want to generate MonadReaderADT with TH
11:54:25 <johnw> yes, that should be straightforward to do
11:54:34 <johnw> I've written TH code to do the opposite, btw
11:54:39 <johnw> it would be a nice addition
11:54:46 <johnw> http://hackage.haskell.org/package/recursors
11:54:51 <johnw> that's goes from Initial -> Final using TH
11:55:00 <johnw> I'd _love_ a pull request to go from Final -> Initial :)
12:01:06 <fosskers> I'm having an attoparsec issue
12:02:42 <fosskers> I have a byte which denotes the number of bytes to follow it belonging to the same "group"
12:03:12 <fosskers> Parsing that byte and then passing it to Attoparsec's `take` gives us back the full `ByteString` of the bytes that followed
12:03:49 <fosskers> Except now I'd like to parse _that_ ByteString. The things inside the ByteString all use the same parser, but can each be of different length
12:05:17 <fosskers> Previously I was ignoring the length byte, and just doing `many1 foo`, except that `foo` is generic enough in behaviour that it's eating the rest of the input
12:06:28 <fosskers> So I'm trying to reconsile either writing the parser I have now "better", or attempting some sort of "nested parsing" after heeding the length byte and using `take`. Any thoughts?
12:09:00 <fosskers> I don't think there's any way I can ignore this length byte anymore
12:09:39 <fosskers> `many1` will descend into gluttony unless I cap the amount of input it's allowed to look at
12:10:07 <fosskers> `take` seems like a good candidate, but then I'm confused about how'd I apply another layer of parsing to a `Parser ByteString` result
12:17:39 <lyxia> attoparsec doesn't have any way to "embed" a subparser on a bounded portion of input
12:18:37 <lyxia> just use parse or parseOnly
12:20:37 <lyxia> I wonder how easy it would be to do something like that in a "neater" way
12:35:40 <sm> I think megaparsec just added support for this
12:36:52 <Gurkenglas> What's the most likely reason for and way to fix this? http://lpaste.net/5498937239993843712
12:37:17 <Gurkenglas> cloning exference and running stack build used to work, I think.
12:38:32 <sm> Gurkenglas: cabal file specifying a version of a package that isn't in the stackage snapshot you're using
12:38:56 <sm> possible quick fix: specify that version under extra-deps in stack.yaml
12:39:13 <rblaze> Gurkenglas which resolver version do you have in stack.yaml?
12:40:03 <Gurkenglas> rblaze, "lts-5.18". sm, 5.2 and 0.3.9 or 5.4.2 and 0.3.14?
12:40:07 <sm> better fix: update your cabal dependencies to use what's in the stackage snapshot you're specifying
12:40:21 <rblaze> Gurkenglas oh. the current one is 8.12
12:40:48 <Gurkenglas> I suppose it's wise to get it running on the old versions before upgrading to new ones, rblaze, I haven't touched exference in a while
12:41:02 <sm> agreed
12:41:33 <hexagoxel> Gurkenglas: it seems to be caused by one of the last commits, most likely the one that changed the constraints.
12:41:46 <hexagoxel> (and sorry for not checking the stack build before releasing..)
12:41:47 <sm> so the problem is opposite to what I said (hard to read those errors): https://www.stackage.org/lts-5.18 has bifunctor 5.2, your cabal deps probably require a newer version
12:42:25 <rblaze> if exference requires bifunctors 5.4, and lts-5.12 only have 5.2, you are out of luck. Forcing other version will force rebuild of many snapshot packages.
12:42:58 <hexagoxel> Gurkenglas: e.g. HEAD~3 does not show this problem.
12:43:25 <Gurkenglas> What command is that to clone HEAD~3 instead of HEAD?
12:43:52 <sm> you could also try stack init/stack solver to get a stack.yaml suitable for HEAD
12:46:39 <hexagoxel> Gurkenglas: i have fixed the bounds in the .cabal; is pushed to HEAD
12:46:53 <hexagoxel> eh, s/HEAD/master/ i suppose.
12:47:49 <sm> nice
12:49:09 <hexagoxel> and true, maybe i should update the lts as well, although i see much less need for a mostly-only-executable package.
12:50:22 <Tuplanolla> Today's xkcd did not need many changes to fit this channel perfectly: http://users.jyu.fi/~sapekiis/tmp/here-to-fp.png
12:52:12 * ski grins
12:52:37 <hexagoxel> Tuplanolla: Corepresentable,.. haha :)
12:56:23 <tfc[m]> lol
13:00:24 <fosskers> Alright, I'll try a nested use of `parseOnly`
13:03:17 <Profpatsch> intersperse/intercalate in Foldable?
13:03:26 <kamyar> Hello fellows
13:03:41 <kamyar> What is !ByteString? What is ! at first char?
13:04:08 <Profpatsch> kamyar: Strictness annotation
13:04:19 <Profpatsch> Will be evaluated to WHNF (I think?)
13:04:30 <kamyar> Profpatsch: thnx!
13:04:48 <Profpatsch> kamyar: See BangPatterns
13:06:58 <sm> hexagoxel: one reason to keep the recommended lts fairly current is people are more likely to have it or something close already built
13:07:14 <Profpatsch> Hm, is there something like intercalate for Foldable/Traversable?
13:07:21 <Gurkenglas> Can intero jump to use sites of a definition too?
13:07:36 <Profpatsch> Oh, it probably doesn’t make much sense for e.g. Trees
13:08:05 <sm> (saving build time and disk space)
13:13:02 <hexagoxel> ah, true.
13:13:15 <Gurkenglas> :t over (partsOf traverse) . intersperse -- extremely law-breaking. Will stretch one half of the data and drop the rest. Why would you want this?
13:13:16 <lambdabot> Traversable t => b -> t b -> t b
13:14:29 <Gurkenglas> :t partsOf traverse %~ sort -- Who needs all those fancy innovative newtypes to sort any traversable, reddit? This one isn't even illegal.
13:14:30 <lambdabot> (Ord b, Traversable t) => t b -> t b
13:15:59 <johnw> I like "extremely law-breaking"
13:16:08 <johnw> I try to prove my theorems with extreme prejudice
13:16:35 <hexagoxel> graphviz question: can anyone tell me if i am supposed to turn on OverloadedStrings? the examples in the haddocks seem to suggest it, but the ambiguities I get with it contradict.
13:17:42 <Twey> What's the reasoning behind the weird build-depends: base<=666 constraints I see around Hackage these days?  ( https://www.google.co.uk/search?q=site:hackage.haskell.org+base+666 )
13:19:51 <jle`> > over (partsOf traverse) sort (M.fromList (zip [1..] "hello"))
13:19:54 <lambdabot>  fromList [(1,'e'),(2,'h'),(3,'l'),(4,'l'),(5,'o')]
13:19:55 <hexagoxel> Twey: i'd assume it to be a humorous protest against the call for upper bounds on dependencies.
13:21:10 <jle`> hexagoxel: overloaded strings will often get ambiguous type errors during normal usage
13:23:37 <hexagoxel> jle`: the thing is that the copy-pasted examples do not to work, neither with nor without OverloadedStrings.
13:24:37 <hexagoxel> with the error suggesting to use/not use the extension, always the opposite of one currently does :D
13:24:57 <hexagoxel> (well, that is my interpretation of the errors)
13:26:09 <jle`> there...might have been a breaking change without an update to the examples, heh
13:27:38 <cocreature> the error created by enabling OverloadedStrings are usually fixed by adding a few type annotations
13:29:21 <hexagoxel> right; the type annotations are rather annoying due to the inference-inhibiting properties of this class: http://hackage.haskell.org/package/graphviz-2999.18.1.2/docs/Data-GraphViz-Types-Monadic.html#t:NodeList
13:30:00 <hexagoxel> i.e. no functional dep (and not possible with such instances)
13:30:37 <jle`> what a typeclass lol
13:32:00 <hexagoxel> the package does this a lot, i.e. use-typeclasses-for-function-overloading
13:32:10 <cocreature> someone payed attention in “shitty haskell api design 101”
13:32:16 <jle`> it looks like that particular typeclass only appeared from 18.0 onwards
13:32:28 <jle`> so maybe the examples were not updated to reflect that
13:32:32 <jle`> or were updated and not tested
13:33:13 <jle`> actually it only showed up 18.1 onwards
13:33:35 <jle`> which was less than a year ago
13:34:01 <btorf> hey! is there a convention for the name of `liftM2 (>>)`? 
13:34:33 <btorf> maybe (<>>>) ? but this looks really ugly
13:35:05 <Gurkenglas> If you're using it often enough to give it a name, maybe you want monad transformers... can we see the code?
13:35:08 <cocreature> btorf: just use "liftM2 (>>)". I don’t think that’s a function that’s often used (I can’t recall ever having used it)
13:35:14 <jle`> i don't think there is one....it sounds pretty specialized
13:36:53 <bartavelle> is there a name for "start" and "end" nodes in directed graph, where all paths starting from a node A must go through a node B, and all paths crossing node B are reachable from A N
13:36:54 <bartavelle> ?
13:36:56 <btorf> oh ok. I thought this would could be a common pattern
13:37:00 <btorf> thx
13:38:07 <jle`> for the composition of two applicatives, (*>) = liftA2 (*>)
13:38:18 <jle`> so this is actually something you can access using a newtype wrapper
13:39:22 <jle`> btorf: so if you wrap f (g a) in a newtype wrapper, you can get (*>) on it to be your liftA2 (*>)
13:41:13 <btorf> what do you mean "I can get"?
13:43:12 <jle`> btorf: if 'x' and 'y' are your f (g a)
13:43:21 <jle`> then `Compose x *> Compose y` is liftA2 (*>) x y
13:43:29 <jle`> so *> will "be" liftA2 (*>)
13:45:34 <jle`> > Compose (Just [1,2,3]) *> Compose (Just ['a'])
13:45:36 <lambdabot>  Compose (Just "aaa")
13:45:43 <jle`> > Compose (Just [1,2,3]) *> Compose Nothing
13:45:45 <lambdabot>  Compose Nothing
13:45:47 <jle`> > Compose (Just [1,2,3]) *> Compose (Just [])
13:45:49 <lambdabot>  Compose (Just [])
13:46:17 <jle`> this is useful if you want to use your thing for applicative-polymorphic functinos, like sequenceA or traverse
13:46:43 <jle`> or even do notation
13:52:48 <btorf> wow, thanks
13:55:12 <Gurkenglas> How do you abort a computation in intero's repl? (How could I have found that out?)
13:55:33 <jle`> btorf: no problem!  monad transformers let you generalize this to Monadic functions (like bind, etc.) too, but Compose is enough for Applicative and Functor functions
14:02:26 <mrus> How do you read the pipe character in something like [2 ^ x | x <- [1..5]], when you try to speak this as a sentence?
14:02:35 <johnw> "taken from"
14:02:57 <EvanR> speaking source code?
14:03:13 <EvanR> i wonder what C sounds like
14:03:15 <johnw> as in "the list of elements 2^x where x is taken from the list [1..5]"
14:03:18 <mrus> EvanR: lol
14:03:34 <geekosaur> yeh, I would say "where" or possibly "given"
14:03:45 <mrus> johnw: so the pipe would be "where"?
14:03:53 <johnw> yeah, I suppose so
14:03:56 <johnw> "such that"
14:04:01 <geekosaur> "2 to the x power where x taken from the range 1 to 5"
14:04:02 <johnw> { x : nat | x < 10 }
14:04:04 <johnw> reads similarly
14:04:07 <geekosaur> or "such that", yes
14:04:09 <EvanR> yeah set theory speak
14:05:03 <mrus> hm, makes sense. I just thought that there's a more... like.. sophisticated way to formulate that.
14:05:55 <geekosaur> the sophisticated ways are all written with mathy symbols >.>
14:06:09 <mrus> heh
14:07:03 <tdammers> [ f x | x <- xs ] -- "f applied to x for x from xs" or "f applied to x for x in xs"
14:07:54 <tdammers> (the second one is actually Python's list comprehension syntax: [ f(x) for x in xs ])
14:08:47 * seequ_ loves Python's comprehension syntax
14:09:46 <mrus> how about: "2 to the power of x such as x is derived from 1 to 5"?
14:13:18 <ChaiTRex> mrus: "Derived" seems to imply a bit more than taken directly. I'd say something more like "2 to the x given x from 1 to 5".
14:13:48 <EvanR> hmm
14:13:51 <mrus> I see
14:14:59 <EvanR> [ 2^x | x <- [1..5] ] "2, 4, 8, 16, 32"
14:15:27 <Myrl-saki> Great, now add a second list comprehension and try to English it. :D
14:15:29 <EvanR> "the first through fifth powers of 2"
14:15:50 <mrus> :-D
14:16:42 <Myrl-saki> [ x + y | x <- [1..5], y <- [1..5]]
14:17:10 <rotaerk> do { x <- [1..5]; y <- [1..5]; return $ x + y }
14:17:26 <geekosaur> "," is "and"
14:17:43 <michi7x7> > [ x + y | x <- [1..5], y <- [1..5]]
14:17:45 <lambdabot>  [2,3,4,5,6,3,4,5,6,7,4,5,6,7,8,5,6,7,8,9,6,7,8,9,10]
14:18:00 <rotaerk> is there anything you can express with comprehensions that you can't trivially convert to a do expression like that?
14:18:05 <michi7x7> I wonder if that sequence has a name
14:18:07 <Myrl-saki> Now that I think about it, monad comprehension is... pretty useless.
14:18:15 <Myrl-saki> rotaerk: Nope.
14:18:29 <mrus> so, appaently Haskell developers don't need to speak their code pretty often. :-)
14:18:30 <Myrl-saki> raatiniemi: for testing, you use `guard`
14:18:31 <jle`> rotaerk: there's parallel list comprehensions
14:18:42 <Myrl-saki> jle`: Which is still easy.
14:18:48 <Myrl-saki> jle`: (zipN)
14:19:14 <jle`> less trivial :o
14:19:16 <jle`> especially if N > 7
14:19:23 <Myrl-saki> jle`: true.
14:19:29 <jle`> that's more ad-hoc/arbitrary
14:20:47 <michi7x7> mrus: well, try speaking C. You would still explain what the code does and not what it looks like.
14:22:53 <Myrl-saki> michi7x7: "oh, and I don't know why this part works, but it does"?
14:23:33 <thang1> "yeah it only segfaults on tuesdays. Just don't run the program past 8pm on tuesday, other than that it works perfect"
14:24:01 <Myrl-saki> thang1: "other than that it works perfect" I love that line.
14:24:16 <Myrl-saki> "I mean, if you don't consider the fact that it's broken, then it works."
14:24:32 <michi7x7> Myrl-saki: you would say something "filter out all even numbers in a loop" and not "in a for loop that increments i from 0 to 10, remove all elements for which isEven returns true"
14:24:45 <michi7x7> that's what I meant
14:25:17 <thang1> michi7x7: Which I always found pretty funny. "Yeah, when you're explaining how your code works step by step in C? Just write that explanation down in Haskell and it'll compile, probably"
14:25:22 <ChaiTRex> @undo [ 2^x | x <- [1..5]]
14:25:22 <lambdabot> concatMap (\ x -> [2 ^ x]) [1 .. 5]
14:25:49 <ChaiTRex> @undo [ 2^x | x <- [1..5], isEven x ]
14:25:49 <lambdabot> concatMap (\ x -> if isEven x then [2 ^ x] else []) [1 .. 5]
14:26:16 <Myrl-saki> Eh
14:26:25 <Myrl-saki> > (2^) <$> [1..5]
14:26:27 <lambdabot>  [2,4,8,16,32]
14:27:17 <thang1> (2^) <$> filter isEven [1..5] -- Would this even work?
14:27:22 <Myrl-saki> Yes.
14:27:25 <Myrl-saki> It will.
14:27:33 <thang1> > (2^) <$> filter isEven [1..5] -- Would this even work?
14:27:35 <lambdabot>  error:
14:27:35 <lambdabot>      Variable not in scope: isEven :: Integer -> Bool
14:27:41 <hiptobecubic> Tada!
14:27:43 <thang1> ;-;
14:27:51 * thang1 is betrayed
14:28:00 <Myrl-saki> @let isEven x = (x `mod` 2) == 0
14:28:02 <lambdabot>  Defined.
14:28:03 <Myrl-saki> Wait...
14:28:05 <Myrl-saki> :t even
14:28:07 <lambdabot> Integral a => a -> Bool
14:28:13 <hiptobecubic> :)
14:28:14 * Myrl-saki facepalms
14:28:17 <thang1> lol
14:28:30 <thang1> > (2^) <$> filter even [1..5] -- This time with feeling
14:28:32 <lambdabot>  [4,16]
14:28:43 <michi7x7> > even == isEven -- can Haskell deduce smth like that?
14:28:45 <lambdabot>  error:
14:28:45 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘even’
14:28:45 <lambdabot>        prevents the constraint ‘(Integral a0)’ from being solved.
14:28:57 <Myrl-saki> michi7x7: subHask can.
14:29:11 <thang1> pretty sure it wouldn't do anything because you have two functions that haven't been applyed to anything
14:29:30 <Myrl-saki> Though, the resulting type will be `:: Integral a => a -> Bool`
14:29:31 <geekosaur> functions have no Eq instance
14:29:40 <Myrl-saki> It just so happens that the result is always True.
14:29:43 <geekosaur> however there is
14:29:44 <jle`> thang1: well, it'd be an (==) instance for (Int -> Bool), so it technically typechecks
14:29:46 <geekosaur> @hackage universe
14:29:47 <lambdabot> http://hackage.haskell.org/package/universe
14:29:54 <Myrl-saki> @hackage subhask
14:29:54 <lambdabot> http://hackage.haskell.org/package/subhask
14:30:01 <Myrl-saki> ;)
14:30:06 <ChaiTRex> michi7x7: That's impossible in general (halting problem), and I think that's part of the reason no one's included an attempt to do it.
14:30:14 <rotaerk> do { you <- even `liftM` bro; ... }
14:30:15 <thang1> oooh cool
14:30:16 <jle`> michi7x7: (==) is not provided by haskell in general
14:30:25 <jle`> it's implemented by users
14:30:42 <Myrl-saki> ChaiTRex: In general, sure.
14:30:55 <Myrl-saki> ChaiTRex: But `even == isEven` is easily decideable.
14:30:58 <ChaiTRex> It would be nice to be able to examine the AST or whatever for functions programmatically, though.
14:31:09 <ChaiTRex> Oh, sure. That one is easy.
14:31:10 <michi7x7> jle`: yeah, implementing Eq. I just liked the Idea
14:31:12 <ij> I've a "executable program" section in my "program.cabal" file. I want to write tests, so I've to include all "other-modules" and "build-depends" again? Repeat the 80 lines again, that is?
14:31:25 <jle`> you probably can write an instance of Integral where even == isEven is possible
14:31:27 <lyxia> ij: put it in a library
14:31:32 <jle`> well
14:31:37 <Myrl-saki> ChaiTRex: Oh wait no.
14:31:46 <glguy> ij: No, you just depend on the same library that has all the logic in it
14:31:52 <jle`> it wouldn't be a very useful Eq instance
14:32:01 <jle`> since it would have to normalize function representations
14:32:11 <ij> lyxia, Do I google "cabal library"?
14:32:14 <jle`> hm, actually, Eq a => Eq (Int -> a) is definally doable
14:32:19 <jle`> you'd just have to iterate over all of the Ints
14:32:29 <glguy> ij: For example https://github.com/glguy/irc-core/blob/v2/glirc.cabal#L155-L161
14:32:35 <Myrl-saki> jle`: Yep, ubt not Integral a => a -> b
14:32:35 <jle`> which is the premise of the 'universe' package
14:33:09 <jle`> you could use tricks like simple-reflect to prove that the two functions were created using the same abstract syntax tree
14:33:17 <jle`> but that would give false negatives
14:33:19 <geekosaur> ij, it's a matter of refactoring your executable into a library providing the guts, an executable that wraps the library, and then tests can access and test the guts via the library
14:33:22 <jle`> unless you had a way to normalize representations
14:33:41 <mrus> michi7x7: `int x = 2; for(int i = 0; i < 5; i++) printf("%i\n", x << i);`: "with x being 2 and i being 0, while i is smaller than 5, increment i and bitwise shift x by the value of i". Pretty easy to speak, actually.
14:33:56 <jle`> michi7x7: for example, would even be the same as some other implementation that returned the same thing, but in a different way?
14:34:11 <jle`> you'd have to somehow deduce that (== 0) . (`mod` 2) is the same as, say
14:34:17 <jle`> (== 0) . (`mod` 2) . (+ 2)
14:34:24 <Myrl-saki> Universe a => Universe [a]
14:34:28 <Myrl-saki> This... makes no sense.
14:34:46 <geekosaur> I was thinking one that tests the bottom bit
14:35:00 <jle`> even if you has access to the abstract syntax tree, you'd still get false negatives if you just compared the tree
14:35:04 <geekosaur> bit ops vs. modulus (even though, inside the CPU, they're likely the same!)
14:35:06 <jle`> since it would return "not equal"
14:35:16 <michi7x7> jle`: well, this is pretty similar to program optimization, no?
14:35:25 <pikajude> Myrl-saki: i think it's the entire universe of a inside lists of progressively larger size
14:35:26 <jle`> for `((== 0) . (`mod` 2) . (+ 2)) == ((== 0) . (`mod` 2))`
14:35:42 <ChaiTRex> michi7x7: Yeah.
14:35:52 <michi7x7> but I agree, it's not doable to implement this in a sufficiently exact way
14:36:19 <ChaiTRex> You can do it with Equivalent | NotEquivalent | NotSure
14:36:30 <Myrl-saki> ++
14:36:39 <MarcelineVQ> data IsEven = SoEven | SoNotEven | IDontEven
14:36:43 <ChaiTRex> Haha
14:36:46 <Myrl-saki> MarcelineVQ: ICantEven.
14:37:08 <jle`> compare :: Lattice a => a -> a -> Maybe Ordering
14:37:12 <michi7x7> ChaiTRex: What about ceil . fromIntergal == floor . fromIntegral
14:37:49 <jle`> (==?) :: MaybeEq => a -> a -> Maybe Bool
14:38:10 <MarcelineVQ> what does MaybeEq carry?
14:39:21 <ChaiTRex> :t ceil
14:39:22 <lambdabot> error: Variable not in scope: ceil
14:39:26 <ChaiTRex> :t ceiling
14:39:28 <lambdabot> (Integral b, RealFrac a) => a -> b
14:39:41 <ChaiTRex> michi7x7: That would depend on the type in the middle.
14:39:58 <ChaiTRex> michi7x7: Hmm, no it wouldn't.
14:40:38 <ChaiTRex> michi7x7: For badly-acting middle types, I guess.
14:40:43 <Myrl-saki> I wonder why Maybe's default Monoid instance isn't First though.
14:40:55 <jle`> for me, it's more useful
14:40:59 <jle`> since we have <|>
14:41:22 <Myrl-saki> jle`: Ah, true.
14:41:41 <Myrl-saki> jle`: But we can define `forall m. Monoid m => Maybe m -> m`
14:41:50 <jle`> but i'll admit, "in theory", the First instance "should" be the default instance
14:41:59 <Myrl-saki> jle`: :D
14:42:13 <jle`> but from an ecosystem perspective
14:42:28 <jle`> `Semigroup m => Monoid m` is bae
14:42:35 <jle`> er, Monoid (Maybe m)
14:42:50 <Myrl-saki> ++
14:43:08 <EvanR> michi7x7: deciding extensional equality of programs isnt possible
14:43:35 <Myrl-saki> `instance Applicative f => Monad (Fix f)` ?
14:44:23 <jle`> ill-kinded
14:44:27 <kamyar> Hello all!
14:44:34 <jle`> hi!
14:44:39 <Myrl-saki> jle`: Oh true.
14:45:26 <kamyar> I have a somewhat difficult question about WAI
14:46:27 <ij> glguy, Does library get attached to each section — test-suite and executable?
14:46:35 <kamyar> I am writing a middleware for WAI
14:46:53 <kamyar> I am getting username out of a bearer token
14:47:14 <kamyar> I can get username within any WAI (Scotty)  function via request
14:47:25 <michi7x7> EvanR: assuming no side-effects and a closed and countable domain, you could compare results of course. If the program compiles to equal bytecode you can assume equality and proving (not finding) inequality is easy. I think that's about it
14:47:27 <kamyar> but I prefer a more beautiful solution
14:47:50 <kamyar> for example a function returning username which can be used anywhere
14:47:55 <EvanR> michi7x7: a countable domain, like Integer ? no its not possible
14:48:02 <kamyar> same as request which pints to current request
14:48:25 <EvanR> that was the result of the entscheidungs problem
14:49:10 <EvanR> and if the domain and range were finite, you still cant compare results because one or both programs may not terminate
14:49:31 <Eduard_Munteanu> kamyar, well, you don't use a middleware then. A middleware is just an Application -> Application, but it seems you could use a (Username -> Application) -> Application
14:49:47 <EvanR> and unequal bytecode doesnt mean extensionally unequal
14:50:18 <dxtr> Hmm
14:50:26 <dxtr> What's the inverse of X OR !Y?
14:50:43 <EvanR> !(X OR !Y) ?
14:50:44 <pikajude> isn't it !X OR Y
14:50:46 <Eduard_Munteanu> !X AND !!Y?
14:51:01 <Eduard_Munteanu> No.
14:51:26 <Eduard_Munteanu> Negation inverts inputs and swaps 'or' for 'and' and viceversa.
14:51:30 <jle`> !(X or !Y), which you can simply using de morgan's laws
14:51:48 <dxtr> That's true
14:51:53 <jle`> => !X and !!Y
14:51:53 <EvanR> "simply"
14:52:00 <jle`> simplify ;_;
14:52:17 <EvanR> "sadly" de morgan doesnt work intuitionistically
14:52:31 <Eduard_Munteanu> Well, one of them doesn't work.
14:52:36 <kamyar> Eduard_Munteanu: what do u mean? I have to intercept requests anyway
14:52:52 <jle`> (Either X (Y -> Void)) -> Void
14:52:59 <kamyar> Eduard_Munteanu: But at the same time I need username many times
14:53:50 <Myrl-saki> > many $ Just 1
14:53:51 <mbw> Hello. Earlier today I asked about where to ask a rather lengthy question and got recommended to create a gist and post it on Reddit. Now I did all the markup work and I'm trying to create the gist on https://gist.github.com/. However I am not able to paste anything from the clipboard. I saw that there are scripts for this, but I wonder how you are "supposed" to use this?
14:53:56 <lambdabot>  mueval-core: Time limit exceeded
14:53:57 <kamyar> Eduard_Munteanu: Where can I hold username when extracted in my middleware so that I could access it from anywhere in scotty
14:53:58 <kamyar> ?
14:54:04 <Myrl-saki> Okay. I have to ask why. Lol.
14:54:13 <jle`> @djoinn Either a (b -> Void) -> Void
14:54:13 <lambdabot> -- f cannot be realized.
14:54:16 <Eduard_Munteanu> kamyar, I'm suggesting you should write a   withUsername :: (Username -> Application) -> Application   such that your WAI application is   withUsername applicationGettingUsernamePassed
14:54:49 <Eduard_Munteanu> kamyar, in a parameter or Reader environment
14:55:16 <michi7x7> EvanR: yeah, you're right
14:55:18 <Myrl-saki> jle`: Sounds impossible.
14:55:22 <Gurkenglas> Myrl-saki, it doesn't know that it isn't going to be Nothing until it's evaluated all of the list
14:56:00 <EvanR> michi7x7: what you can do, though, is restrict the kind of programming language under scrutiny
14:56:05 <Myrl-saki> Gurkenglas: I see.
14:56:21 <EvanR> i dont know how primitive it needs to get before you can decide equality though
14:56:35 <Myrl-saki> Gurkenglas: Where can I use some/many then?
14:56:44 <Eduard_Munteanu> mbw, you're supposed to pipe the relevant bits into the script
14:57:06 <Eduard_Munteanu> mbw, e.g. pastebinit < file.txt
14:57:55 <Eduard_Munteanu> mbw, if pasting doesn't work, remember there are two clipboards: one is triggered by the "paste" GUI command, the other by middle-click
14:57:59 <Gurkenglas> Myrl-saki, the fixed points of many as applied to Just 2 are undefined and Just (repeat 2). I advocate that we should not be using the least fixed point as the documentation says, but the greatest lower bound of the maximal fixed points, ie as long as there's only one way to go towards more defined, take it
14:58:19 <glguy> mbw: If you can't paste into the text box on gist.github.com it might be time to restart your computer or use a different browser
14:58:20 <michi7x7> EvanR: Hmm, I guess floating-point makes it quite hard already. If it's about math, the guys at Wolfram are probably the experts
14:58:42 <mbw> Eduard_Munteanu: Ok I just thought it should somehow be possible from the site. I used cat / xclip, which usually works. And I can paste it just fine in the title window, for instance.
14:59:06 <mbw> Where it says file title plus extention.
14:59:30 <Gurkenglas> In practice, you just promise Haskell that it's not undefined and it goes along with it. I've written this into Control.Alternative.Pointed and then manyLazy (Just 2) = Just (repeat 2) https://hackage.haskell.org/package/pointedalternative-0.1.0.0/candidate/docs/Control-Alternative-Pointed.html
14:59:30 <Eduard_Munteanu> xclip sometimes picks the wrong clipboard
14:59:40 <Eduard_Munteanu> There are actually 3 of them.
14:59:46 <Myrl-saki> Gurkenglas: Ah.
15:00:16 <mbw> Yeah you have to invoke it via cat somefile.txt | xclip -selection "clipboard".
15:01:39 <Eduard_Munteanu> mbw, try opening the file in a GUI editor like gedit
15:02:06 <Myrl-saki> Eduard_Munteanu: mbw?
15:02:12 <Myrl-saki> might be worth trying?
15:02:18 <mbw> Like I said, I can paste in "Gist description" and "Filename including extension".
15:02:41 <Eduard_Munteanu> Hm.
15:02:41 <mbw> I don't think I am trying to paste from the wrong clipboard.
15:02:45 <Myrl-saki> Eduard_Munteanu: Oh wait. I'm stupid.
15:02:50 <Myrl-saki> I thought it was an acronym.
15:02:52 <Myrl-saki> Whoops.
15:02:56 <Gurkenglas> Of course, why not just use repeat? Maybe is not the only Alternative. For the prototype, I also lift instances through StateT s, where many makes more intuitive sense (the term originally comes from parser combinator libraries, which are pretty close to StateT String)
15:02:57 <Eduard_Munteanu> :)
15:03:10 <thang1> Eduard_Munteanu: that's why I merge all of my clipboards in linux :p
15:03:23 <Myrl-saki> Eduard_Munteanu: I blame you for not using colons like normal people. :D
15:03:56 <Eduard_Munteanu> Comma seems a bit more natural for addressing people.
15:04:34 <Myrl-saki> Eduard_Munteanu: Everyone else in IRC is a bot though.
15:04:35 <thang1> colon is default on my irc client. I usually have it changed to comma but every now and then I reset my irc config and that bit gets undone
15:04:52 <Eduard_Munteanu> I think I had it set manually too.
15:05:02 <Gurkenglas> > evalStateT (many $ do i <- StateT uncons; modify $ drop i) [1..] -- which leads to this, which must first go through the infinite list...
15:05:06 <monochrom> Best of both world --- use ;
15:05:09 <lambdabot>  mueval-core: Time limit exceeded
15:05:10 <mbw> Depending on your irc client, it might make a difference. With irssi, in "<nick>: Bla bla bla", your own nick will get highlighted.
15:05:14 <rotaerk> hmm, I should change my default to exclamation mark
15:05:23 <Eduard_Munteanu> Good point, mr. compromise. :)
15:05:28 <monochrom> ;)
15:05:45 <mbw> Anyhow, noscript isn't at fault either. I'll just try to use one of those scripts.
15:06:21 <Myrl-saki> I disagree. If we'll make something different, it shoul be totally different.
15:06:29 <Gurkenglas> > evalState (manyLazy $ do i <- StateT uncons; modify $ drop i) [1..] -- becoming this. (with bonus type-level justice gurantee)
15:06:34 <lambdabot>  mueval-core: Time limit exceeded
15:06:39 <Gurkenglas> fail. wat
15:06:44 <Myrl-saki> Gurkenglas: lmao
15:06:58 <monochrom> Use @ but put it after, not before. "monochrom@ Hey that's an excellent idea!"
15:07:21 <mbw> Why not a lambda? Harder to type, too.
15:07:34 <Myrl-saki> lambda in Haskell should have been ,\
15:07:56 <mbw> That looks like lambda's crippled brother.
15:07:56 <iqubic> So I'm trying to write my own version of ExceptT. How does this look: http://termbin.com/gh84
15:07:58 <Myrl-saki> Look at how beautiful that is.
15:08:21 <rotaerk> dangit, I tried changing my addressing suffix to >>=
15:08:27 <rotaerk> but hexchat ignores all but the first char
15:08:30 <iqubic> Note that all of that except for the type hole at the bottom type checks.
15:08:39 <monochrom> ah dang it, rotaerk.
15:09:02 <Gurkenglas> > evalState (manyLazy $ StateT uncons) [1..] -- Hm, this works. Whence divergence?
15:09:04 <jle`> iqubic: nice :)
15:09:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:09:10 <iqubic> So, anyone know if my implementation of ExceptT works?
15:09:11 <hexagoxel> there must be some unicode 1-char >>=
15:09:19 <iqubic> Is it correct?
15:09:26 <Myrl-saki> hexagoxel: There is if you consider user-defined unicode.
15:09:56 <reactormonk[m]> How do I add type annotation to a variable in a do block? For type inference.
15:10:07 <reactormonk[m]> When I add it directly to the left of the <-, it tells me something about scoped type variables.
15:10:12 <jle`> reactormonk[m]: you can do (a :: Int) <- ..., if you turn on ScopedTypeVariables
15:10:17 <jle`> reactormonk[m]: yes, that's an extension
15:10:32 <reactormonk[m]> Does it do what I expect?
15:10:34 <Gurkenglas> > evalState (manyLazy $ do i <- StateT uncons; modify $ drop $ mod i 4; return i) [1..] -- Oh, of course. It originally ~doubled the amount of droppings each time :)
15:10:36 <lambdabot>  [1,3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,...
15:10:37 <geekosaur> reactormonk[m], it used to be a separate extension but got rolled into ScopedTypeVariables extension
15:10:39 <Eduard_Munteanu> Yes.
15:12:24 <iqubic> So no one is able to look at my implementation of ExceptT?
15:13:38 <jle`> iqubic: looks solid to me
15:14:03 <iqubic> Does it?
15:14:40 <jle`> yup
15:14:49 <jle`> next try Alternative
15:15:21 <iqubic> Why do I need to have Instance MonadTrans (ExecptT e) where... and not MonadTrans ExceptT?
15:15:37 <jle`> iqubic: what is the kind of MonadTrans
15:15:39 <Eduard_Munteanu> :k ExceptT
15:15:40 <lambdabot> * -> (* -> *) -> * -> *
15:15:52 <iqubic> :k MonadTrans
15:15:54 <lambdabot> ((* -> *) -> * -> *) -> Constraint
15:15:54 <mbw> Ok I managed the gist thing using the `gist` ruby script. However, the rendering looks way different (fortunately, better) than what I got from using pandoc. How do people usually test their markdown? I invoked pandoc like `pandoc -f markdown_github -t html thefile.md &> thefile.html`.
15:15:56 <jle`> the name of the typeclass should give you a hint
15:16:06 <jle`> something is a MonadTrans if it's a function from monad to monad
15:16:28 <jle`> so if 't' is a MonadTrans, it takes a Monad ( * -> * ) and returns another one ( * -> * )
15:16:37 <iqubic> So do I need to use that e for anything?
15:16:42 <jle`> so if t is a MonadTrans, it has kind (* -> *) -> (* -> *)
15:16:50 <jle`> 'ExceptT e' has that kind
15:16:57 <iqubic> Right.
15:16:58 <jle`> 'ExcetT e :: (* -> *) -> (* -> *)'
15:17:02 <jle`> ExceptT does not
15:17:10 <jle`> ExceptT takes an error type, and a monad, and then returns a monad
15:17:25 <iqubic> So what do I do to fill in my type hole?
15:17:32 <jle`> your typed hole?
15:17:34 <jle`> follow the types
15:17:34 <Eduard_Munteanu> :t lift
15:17:36 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
15:17:36 <jle`> :)
15:17:52 <iqubic> DO I need to use the e at all?
15:18:10 <Eduard_Munteanu> Replace 't' with 'ExceptT e' and see.
15:18:40 <iqubic> I don't think I will need to.
15:18:52 <Eduard_Munteanu> Yeah.
15:18:53 <jle`> what do you mean by 'use the e', anyway?
15:19:02 <jle`> use any value of type 'e' ?
15:19:34 <iqubic> Do I need to use the variable e anywhere in my functions?
15:19:45 <jle`> the type variable?
15:19:48 <iqubic> Oh, wait I'm dumb
15:19:52 <iqubic> I see how to do this.
15:20:00 <jle`> you usually don't have to use type variables
15:20:16 <Eduard_Munteanu> lift should be really straightforward.
15:20:19 <jle`> note that you bind the type variable 'e' for the Functor, Applicative, and Monad instances
15:20:20 <iqubic> It was.
15:20:32 <jle`> and you never explicitly use the type variable in any of those implementations
15:20:47 <iqubic> lift c = ExceptT $ fmap Right c
15:20:47 <jle`> in fact it should be possible to never need to explicitly refer to bound type variables for the most part
15:21:51 <iqubic> So what does alternative do?
15:22:03 <Eduard_Munteanu> Do you know MonadPlus?
15:22:09 <iqubic> I want to try writing alternative instances for my MaybeT and my ExceptT
15:22:14 <glguy> iqubic: Have you looked at the haddock for the typeclass yet?
15:22:15 <jle`> in general, it can do anything as long as it's monoidal
15:22:21 <iqubic> Eduard_Munteanu: What is MonadPlus?
15:22:29 <jle`> but for ExceptT e, it has a specific "expected" behavior
15:22:30 <iqubic> glguy: I have not.
15:22:38 <glguy> OK, that's the right place to start
15:22:49 <Eduard_Munteanu> Something akin to Alternative, I was going to explain Alternative in terms of that.
15:22:54 <jle`> `x <|> y` for ExceptT should be a short-circuiting either-or
15:23:26 <jle`> so if x is Right, it'll return Right w/ whatever x is; otherwise it'll execute y
15:23:34 <thang1> Finally submitted my summer of code application!
15:23:39 <iqubic> jle`: I'm not ready for that.
15:23:46 <jle`> this isn't the only Alternative instance possible (from the laws of Alternative), but it's the one people expect
15:23:49 <jle`> iqubic: i think you are
15:23:54 <iqubic> I want to learn about MonadPlus first
15:23:58 <jle`> since it's easier than (>>=)
15:24:03 <jle`> MonadPlus is just Alternative
15:24:05 <jle`> with an uglier name
15:24:07 <jle`> and more laws
15:24:07 <iqubic> It is?
15:24:17 <jle`> yes, it has the same methods
15:24:20 <jle`> it's a historical accident
15:24:26 <iqubic> Alright, what do I need to implement Alternative?
15:24:38 <jle`> `x <|> y` should do x, and return the result if x is Right
15:24:44 <jle`> otherwise it'll do y and return the result of y
15:24:47 <iqubic> What is the header for Alternative (ExceptT e)
15:24:56 <thang1> Y'know, the more I hear about these historical accidents, the more I wish we would just fix some of this shit...
15:25:04 <jle`> Alternative is * -> *
15:25:06 <pikajude> Right x <|> _ = Right x, _ <|> y = y
15:25:12 <monochrom> need a time machine
15:25:15 <jle`> you might need a Monoid constraint on e
15:25:48 <iqubic> Why do I need a monoid constraint?
15:26:13 <pikajude> good question
15:27:58 <iqubic> @index (<|>)
15:27:58 <lambdabot> Control.Applicative
15:29:19 <iqubic> What is the header for Alternative. I know I need something of kind * -> * but what do I write?
15:29:35 <Eduard_Munteanu> :k Alternative
15:29:37 <lambdabot> (* -> *) -> Constraint
15:30:24 <iqubic> What does that mean?
15:30:27 <Eduard_Munteanu> Start with Alternative (ExceptT e m) and go from there.
15:31:02 <Eduard_Munteanu> It will become apparent if you need other constraints.
15:31:30 <iqubic> What is empty supposed to return?
15:31:57 <Eduard_Munteanu> Look at the laws. It gives you a value such that empty <|> x = x
15:32:13 <iqubic> Why is that god?
15:32:29 <iqubic> s/god/good/
15:32:54 <Eduard_Munteanu> Alternative is a monoidal structure in which 'empty' is the identity element.
15:33:37 <iqubic> But why is Alternative even any good?
15:34:16 <Eduard_Munteanu> iqubic, for one thing it can be used to represent Applicatives which can fail
15:34:29 <pikajude> it's good for parsers
15:34:43 <pikajude> also, if you have two Maybes and you want either of them, but not both, you can use foo <|> bar
15:34:52 <pikajude> stuff like that
15:35:59 <iqubic> Are Alternatives only used with Monad Transformers?
15:36:06 <Eduard_Munteanu> No.
15:36:13 <Eduard_Munteanu> Maybe is an Alternative for example.
15:36:35 <Eduard_Munteanu> > Nothing <|> Just 3 <|> Just 5
15:36:38 <lambdabot>  Just 3
15:36:47 <iqubic> Why is that Just 3?
15:37:02 <iqubic> What is that doing?
15:37:06 <Eduard_Munteanu> iqubic, it gives you the result of the first action that succeeds
15:37:24 <Eduard_Munteanu> (Nothing is failure)
15:37:24 <pikajude> someone decided that Alternative would be useful and that implementation is the one that fulfills the laws for Alternative
15:38:13 <pikajude> > optional Nothing
15:38:15 <lambdabot>  Just Nothing
15:38:17 <pikajude> > optional (Just 3)
15:38:19 <lambdabot>  Just (Just 3)
15:38:22 <pikajude> that's odd
15:38:32 <iqubic> What does optional do?
15:38:37 <iqubic> :t optional
15:38:38 <lambdabot> Alternative f => f a -> f (Maybe a)
15:38:39 <Eduard_Munteanu> > optional 3
15:38:41 <lambdabot>  error:
15:38:42 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M50343...
15:38:42 <lambdabot>        prevents the constraint ‘(Show (f0 (Maybe a0)))’ from being solved.
15:38:48 <glguy> pikajude: why is it odd?
15:38:57 <pikajude> glguy: i forgot what optional should do for Maybe
15:39:01 <pikajude> i've only used it in parsers :)
15:39:08 <iqubic> > join $ optional $ Just 100
15:39:09 <Eduard_Munteanu> > Nothing <|> optional 3
15:39:10 <lambdabot>  Just 100
15:39:12 <lambdabot>  error:
15:39:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M386665625860...
15:39:12 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
15:39:14 <iqubic> > join $ optional $ Just 100
15:39:17 <lambdabot>  Just 100
15:39:27 <pikajude> join . optional doesn't really make any sense
15:39:35 <pikajude> i think it's always going to be id
15:40:55 <glguy> > optional [3..5]
15:40:57 <lambdabot>  [Just 3,Just 4,Just 5,Nothing]
15:41:28 <iqubic> Does empty need to take any parameters?
15:41:37 <Eduard_Munteanu> :t empty
15:41:38 <lambdabot> Alternative f => f a
15:41:52 <iqubic> So, I'm at a loss here.
15:42:00 <glguy> what's confusing?
15:42:01 <pikajude> empty <|> x should be x
15:43:06 <iqubic> I have this so far: empty = ExceptT $ return $ Left _
15:43:16 <iqubic> I don't know what to put in that type hole.
15:43:24 <pikajude> maybe that's why Eduard_Munteanu suggested a Monoid e
15:43:27 <pikajude> then you can put mempty in
15:43:38 <Eduard_Munteanu> Someone else did.
15:44:07 <iqubic> But do I need the monoid constraint?
15:45:04 <Eduard_Munteanu> It's one way to get an 'e'.
15:45:57 <iqubic> Yeah. Are there any other ways to get it?
15:46:03 <Eduard_Munteanu> Another is IsString e.
15:46:13 <iqubic> How does that work?
15:46:24 <Eduard_Munteanu> :t fromString
15:46:26 <lambdabot> IsString a => String -> a
15:46:48 <iqubic> Eduard_Munteanu: What would you do?
15:47:26 <Eduard_Munteanu> Monoid is probably better for now.
15:47:43 <Eduard_Munteanu> :t mempty
15:47:45 <lambdabot> Monoid a => a
15:48:19 <Eduard_Munteanu> Also Error.
15:48:38 <iqubic> What is Error?
15:49:05 <Eduard_Munteanu> @src Error
15:49:05 <lambdabot> class Error a where
15:49:05 <lambdabot>     noMsg  :: a
15:49:05 <lambdabot>     strMsg :: String -> a
15:49:14 <benzrf> huh
15:49:22 <iqubic> Do I need to use Error?
15:49:36 <Eduard_Munteanu> No.
15:49:53 <Eduard_Munteanu> There are many possible instances.
15:50:07 <iqubic> I selected on that seems to work.
15:50:49 <iqubic> s/on/one/
15:51:02 <iqubic> Now how do I write <|> for ExceptT?
15:51:10 <glguy> The benefit of the Monoid choice over Error or IsString is that empty is actually able to be both the left and right identity of <|>
15:51:57 <iqubic> Yeah.
15:52:13 <iqubic> Note I'm not writing this for Either, but for ExceptT
15:52:24 <NickHu> If I have lenses for a record type, how can I use those to create a value of that type without already having an existing default value (or something like that)?
15:52:39 <glguy> iqubic: That's fine. Give it a shot. If you get stuck you can put the code up on lpaste.net
15:52:59 <glguy> NickHu: No, not really
15:53:46 <glguy> NickHu: If you do that you'll need to make sure you specially craft your lenses to be that lazy (which you'll need to be very careful about later to avoid leaking in normal use)
15:55:14 <glguy> NickHu: If you're not worried about memory behavior you can generate those kinds of lenses with: http://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-TH.html#v:generateLazyPatterns
15:55:30 <glguy> in that case that URL includes an example of how to do it
15:55:41 <iqubic> > Left 5 <|> Right 5
15:55:43 <lambdabot>  error:
15:55:44 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M252048480198...
15:55:44 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
15:55:53 <iqubic> Why does that not work?
15:56:12 <Eduard_Munteanu> If you have control over the type, you should just construct a value with record syntax.
15:57:13 <Eduard_Munteanu> :t Left 5 <|> Right 5
15:57:15 <lambdabot> (Num a, Num a1, Control.Monad.Trans.Error.Error a1) => Either a1 a
15:58:05 <Eduard_Munteanu> > Left "err" <|> Right 5
15:58:08 <lambdabot>  Right 5
15:58:21 <iqubic>  Eduard_Munteanu: Why does that have the Error constraint?
15:58:46 <benzrf> :t (<|>)
15:58:48 <lambdabot> Alternative f => f a -> f a -> f a
15:58:52 <benzrf> huh
15:58:55 <benzrf> orphan instance?!
15:59:12 <Eduard_Munteanu> iqubic, because that's what they've chosen to use for Either's Alternative instance
16:01:22 <iqubic> http://termbin.com/6xai
16:01:30 <iqubic> What do I do from there?
16:01:59 <glguy> You'll need to fill in the definitions in your Alternative instance
16:02:00 <Eduard_Munteanu> iqubic, haven't you already done empty?
16:02:03 <glguy> like you did in the other instances
16:02:57 <iqubic> Eduard_Munteanu: See this instead http://termbin.com/1ate
16:03:52 <glguy> iqubic: thinking about what to do next is the whole exercise
16:04:38 <iqubic> What if both parts of <|> are Left?
16:04:42 <Eduard_Munteanu> iqubic, remember you're looking to handle failure
16:05:17 <Eduard_Munteanu> Then the whole thing fails.
16:05:18 <iqubic> I am?
16:05:39 <iqubic> How do I return failure as an ExceptT?
16:08:05 <Eduard_Munteanu> Well, you might already have a failure, i.e. a Left inside m
16:08:27 <duetosymmetry> pl \ls -> any (== 0) [x+y | x<-ls, y<-ls]
16:08:45 <duetosymmetry> > pl \ls -> any (== 0) [x+y | x<-ls, y<-ls]
16:08:47 <lambdabot>  <hint>:1:4: error: parse error on input ‘\’
16:09:09 <Eduard_Munteanu> And you can also make further use of the Monoid and add up the errors.
16:09:48 <iqubic> I can?
16:09:53 <iqubic> How can I do that?
16:10:03 <Eduard_Munteanu> Though it's most natural to drop leftmost failures.
16:11:06 <mbw> Alright, I posted my first reddit post ever on /r/haskell. However, it doesn't show up for me under new, so either I've managed to screw it up somehow, or it has to be confirmed by a moderator or something like that, since my account is new. The post can be found here: https://www.reddit.com/r/haskell/comments/68pc7a/equational_reasoning_with_multidimensional_arrays/ . Did I do it right?
16:11:08 <glguy> dropping the left-most failure stops empty from being the right identity
16:11:34 <Eduard_Munteanu> Oh, right.
16:11:40 <duetosymmetry> > pl (\ls -> any (== 0) [x+y | x<-ls, y<-ls])
16:11:43 <lambdabot>  error:
16:11:43 <lambdabot>      • Variable not in scope: pl :: ([Integer] -> Bool) -> t
16:11:43 <lambdabot>      • Perhaps you meant one of these:
16:11:55 <glguy> duetosymmetry: You can play with lambdabot privately with /msg lambdabot
16:12:07 <Eduard_Munteanu> @pl \ls -> any (== 0) [x+y | x<-ls, y<-ls]
16:12:08 <lambdabot> any (0 ==) . ap ((:) . (x +) . ((y | x) <-)) (return . (y <-))
16:12:09 <duetosymmetry> @glguy sorry for the spam, thx for the help
16:12:09 <lambdabot> Unknown command, try @list
16:12:30 <glguy> and @pl doesn't work for list comphrehensions
16:12:57 <Eduard_Munteanu> @. pl undo \ls -> any (== 0) [x+y | x<-ls, y<-ls]
16:12:57 <lambdabot> any (0 ==) . ((=<<) =<< (. (flip flip [] . ((:) .) . (+))) . (>>=))
16:13:18 <Eduard_Munteanu> :)
16:13:38 <iqubic> What's the canonical implementation of <|> for ExceptT?
16:13:58 <glguy> iqubic: You can find it in the transformers package
16:14:04 <glguy> just click the Source link next to the instance
16:14:46 <Eduard_Munteanu> @src Alternative ExceptT
16:14:47 <lambdabot> Source not found. Abort, Retry, Panic?
16:15:44 <iqubic> glguy: I want to try writting it myself. I just want to know what it should do.
16:16:52 <Eduard_Munteanu> iqubic, you have that Monoid constraint, go ahead and use it
16:17:30 <iqubic> How will that help me?
16:18:01 <Eduard_Munteanu> iqubic, it matters for handling Lefts
16:18:36 <iqubic> How do I return an m (Either e a) that represents failure?
16:18:53 <Eduard_Munteanu> return (Left ...)
16:19:38 <iqubic> So m (Left e) is failure?
16:20:26 <Eduard_Munteanu> Yes, it often means whatever action in the 'm' monad you ran just failed.
16:21:21 <iqubic> Eduard_Munteanu: What should I return if I have 2 rights?
16:21:57 <Eduard_Munteanu> iqubic, shortcircuit
16:22:06 <iqubic> after the first one?
16:22:44 <iqubic> What if I get just a single Right?
16:23:06 <iqubic> So Left <|> Right or Right <|> Left
16:23:54 <Eduard_Munteanu> Remember that Alternative should shortcircuit to the first succcessful action.
16:24:34 <iqubic> What if both actions return Left?
16:25:00 <Eduard_Munteanu> It fails (that far).
16:25:15 <Eduard_Munteanu> You can try it with Maybe...
16:25:27 <iqubic> I don't want to.
16:25:37 <iqubic> I like the challenge of ExceptT
16:25:42 <Eduard_Munteanu> > Nothing <|> Just 2 <|> Just 3 <|> Nothing
16:25:44 <lambdabot>  Just 2
16:25:50 <Eduard_Munteanu> I mean try some values.
16:26:19 <NickHu> Can anyone think of a neater way to write http://lpaste.net/355119 ?
16:26:50 <iqubic> If I have ExceptT x, how do I run the action of X?
16:27:18 <Eduard_Munteanu> NickHu, sequence?
16:27:26 <kadoban> Ya, that looks a lot like sequence
16:27:33 <Eduard_Munteanu> > sequence (1, [2,3,4])
16:27:35 <lambdabot>  [(1,2),(1,3),(1,4)]
16:27:52 <Eduard_Munteanu> :t Data.Traversable.sequence
16:27:54 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:28:00 <iqubic> > Right 5 <|> Right 5
16:28:03 <lambdabot>  error:
16:28:03 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M378179776698...
16:28:03 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
16:28:14 <iqubic> Why won't that thing work?
16:28:25 <iqubic> Eduard_Munteanu: Is there a way to make my thing work?
16:28:27 <NickHu> Oh nice!
16:28:44 <NickHu> I did hoogle for (a, [b]) -> [(a, b)] but it didn't come up
16:28:45 <kadoban> iqubic: There isn't enough context for it to figure out what type that should be, and there's not an appropriate default.
16:28:51 <Eduard_Munteanu> iqubic, the same way you did in Monad instances, for example
16:29:25 <iqubic> > Right 5 <|> Right 5 :: Either String Integer
16:29:28 <lambdabot>  Right 5
16:29:34 <iqubic> > Right 5 <|> Right 7 :: Either String Integer
16:29:36 <lambdabot>  Right 5
16:29:41 <Eduard_Munteanu> @hoogle distribute
16:29:42 <lambdabot> Data.Conduit.Lift distribute :: (Monad (t (ConduitM b o m)), Monad m, Monad (t m), MonadTrans t, MFunctor t) => ConduitM b o (t m) () -> t (ConduitM b o m) ()
16:29:42 <lambdabot> Pipes.Lift distribute :: (Monad m, MonadTrans t, MFunctor t, Monad (t m), Monad (t (Proxy a' a b' b m))) => Proxy a' a b' b (t m) r -> t (Proxy a' a b' b m) r
16:29:42 <lambdabot> Data.Distributive distribute :: (Distributive g, Functor f) => f (g a) -> g (f a)
16:29:52 <iqubic> > Right 5 <|> Left 5 :: Either String Integer
16:29:54 <lambdabot>  error:
16:29:55 <lambdabot>      • No instance for (Num String) arising from the literal ‘5’
16:29:55 <lambdabot>      • In the first argument of ‘Left’, namely ‘5’
16:30:06 <iqubic> > Right 5 <|> Left "Err" :: Either String Integer
16:30:09 <lambdabot>  Right 5
16:30:28 <iqubic> > Left "Err" <|> Right 6 :: Either String Integer
16:30:31 <lambdabot>  Right 6
16:30:47 <iqubic> Why did it just skip over the first thing there?
16:31:00 <iqubic> > Left "Err" <|> Left "or" :: Either String Integer
16:31:03 <lambdabot>  Left "or"
16:31:21 <iqubic> And why is it returning the second thing there?
16:31:22 <NickHu> Is there any benefit to using sequenceA over sequence in this case?
16:31:37 <Eduard_Munteanu> iqubic, that's Error e => Alternative (Either e)
16:31:48 <iqubic> Oh.
16:31:59 <Eduard_Munteanu> NickHu, the type is more general
16:32:08 <kadoban> NickHu: I don't think it should matter here specifically
16:32:34 <iqubic> Should my Monoid version always skip over the first thing if it
16:32:37 <geekosaur> NickHu, I think the only difference is that sequenceA is Applicative; since sequence only *needs* Applicative, the type of sequence is a historical wart
16:32:38 <iqubic> is a Left?
16:32:38 <Eduard_Munteanu> > Data.Distributive.distribute (1, [2,3,4])
16:32:41 <lambdabot>  error:
16:32:41 <lambdabot>      Not in scope: ‘Data.Distributive.distribute’
16:32:41 <lambdabot>      No module named ‘Data.Distributive’ is imported.
16:33:04 <Eduard_Munteanu> @hoogle f (g a) -> g (f a)
16:33:04 <lambdabot> Conversion convert2 :: Conversion (a x1 x2) (b x1 x2) => a x1 x2 -> b x1 x2
16:33:04 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoerceP :: a wX wY -> a wB wC
16:33:04 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoercePStart :: a wX1 wY -> a wX2 wY
16:33:22 <NickHu> Eduard_Munteanu: I get that, but do you think it's all compiled to the same thing by ghc?
16:34:19 <iqubic> Should my Monoid version always skip over the first thing if it is a left?
16:34:23 <Eduard_Munteanu> Not sure.
16:34:47 <ertes> NickHu: some monads have a more efficient implementation of (<*>)
16:34:55 <Eduard_Munteanu> iqubic, well, the obvious thing would be to sum up the errors
16:35:03 <ertes> NickHu: … more efficient than 'ap' that is
16:35:04 <iqubic> What are the Alternative Laws?
16:35:21 <Eduard_Munteanu> iqubic, see the docs on Alternative
16:35:24 <ertes> NickHu: nevermind, 'sequence' probably uses (>>) anyway
16:35:25 <geekosaur> they should compile to equivalent things, but sequenceA might well compile to something more efficient
16:35:30 <hpc> the docs just say "A monoid on applicative functors"
16:36:02 <ertes> ah, wait…  'sequence', not 'sequence_'
16:36:04 <hpc> so you have to do a bit of thinking on your own to arrive at the laws
16:36:12 <geekosaur> if they don't compile to equivalent things then someone's Applicative instance doesn't match their Monad instance which is a law violation
16:36:20 <hpc> https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Monoid - the Monoid laws
16:36:20 <NickHu> geekosaur: Why might the more general one compile to something more efficient as opposed to the more specialised one?
16:36:26 <hpc> let mempty = empty, mappend = (<|>)
16:36:33 <hpc> and you have the Alternative laws
16:36:47 <Eduard_Munteanu> Well, you have the Monoid laws and something extra that makes sense for an Applicative.
16:36:48 <ertes> NickHu: it's not about being more general, but (<*>) is just a more fitting combinator for the use case
16:37:00 <geekosaur> NickHu, because the more specialized one has in this case to "regain" Applicative via Monad, so it may be doing silly things
16:37:07 <hpc> (as well as the "laws" for some and many, which are basically just a default implementation)
16:37:19 <geekosaur> like we have to regain join via (>>= id)
16:37:30 <Eduard_Munteanu> Such that it's a bit more than applicative plus monoid.
16:37:39 <ertes> NickHu: sequence (c:cs) = c >>= \x -> fmap (x :) sequence cs
16:38:16 <ertes> NickHu: sequenceA (c:cs) = fmap (:) c <*> sequenceA cs
16:38:22 <iqubic> hpc: Wha about empty <|> x = x
16:39:05 <Eduard_Munteanu> iqubic, that's a monoid law... mempty `mappend` x = x
16:39:34 <NickHu> geekosaur: I see
16:39:35 <NickHu> So in principle, the more specialised one can be more efficient
16:39:36 <NickHu> But in this particular case, it's possible the inverse is true
16:39:40 <ertes> geekosaur: actually, post-AMP 'sequence' might be exactly the same thing as 'sequenceA'
16:39:48 <geekosaur> NickHu, right
16:39:55 <NickHu> (List monad/applicative)
16:39:56 <NickHu> Right?
16:40:10 <iqubic> Eduard_Munteanu: Does my Alternative need to follow that law?
16:40:26 <geekosaur> specialization can open a path to use a more optimized form but it can also cut off other optimization paths
16:40:35 <Eduard_Munteanu> iqubic, yes
16:40:37 <NickHu> Why is this true for the List instances?
16:40:37 <geekosaur> which one matters more tends to be case-by-case
16:41:01 <ertes> NickHu: (<*>) is a better fit to the problem…  it's not about expressiveness, but about "how much extra stuff do i need to do when using this combinator?"
16:41:02 <NickHu> Is it something GHC specific about how they are implemented, or is there something more fundamental here?
16:41:52 <iqubic> Why is it so hard to write an Alternative instance?
16:41:54 <ertes> also (>>=) is generally more sequential in nature
16:41:54 <geekosaur> mostly it's that Applicative didn't exist when Monad and things like sequence were defined. so sequence is defined the way it had to be for that "world"
16:42:06 <geekosaur> in a world that has Applicative, you have more possibilities
16:42:26 <Eduard_Munteanu> :t Control.Monad.sequence
16:42:28 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
16:42:39 <Eduard_Munteanu> Hrmpf.
16:42:44 <NickHu> So if GHC were reimplemented today, things would be different
16:42:47 <geekosaur> like i said, historical wart. not in GHC so much as in Haskell, since it was so late on recognizing that Monad should have been based on Applicative in the first place
16:42:58 <Eduard_Munteanu> :t Data.List.sequence
16:43:00 <lambdabot> error:
16:43:00 <lambdabot>     Not in scope: ‘Data.List.sequence’
16:43:00 <lambdabot>     Perhaps you meant one of these:
16:43:44 <ertes> > ping
16:43:47 <lambdabot>  pong
16:43:50 <NickHu> I've heard it said that monads are only lax monoidal functors in Hask, which Haskell approximates
16:43:58 <Eduard_Munteanu> @more
16:43:59 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
16:44:05 <NickHu> In category theoretic terms, what property causes that?
16:44:37 <Eduard_Munteanu> No, don't confuse that with Applicatives.
16:45:11 <Eduard_Munteanu> Applicatives are lax monoidal functors.
16:46:10 <NickHu> Eduard_Munteanu: I mean point 3 here https://github.com/mikeizbicki/subhask#functor-hierarchy
16:47:33 <ertes> for many monads (<*>) can be parallel…  not necessarily operationally, but it gives the compiler more options regarding evaluation order
16:47:33 <Eduard_Munteanu> Well, it just happens that Monads are Applicatives in Hask.
16:47:45 <ertes> i don't know how much GHC actually uses that information though
16:47:57 <Eduard_Munteanu> Or can be made so. But in other categories it might not be true.
16:48:57 <Eduard_Munteanu> More generally, applicatives and monads are unrelated.
16:51:22 <NickHu> Eduard_Munteanu: Yes, my specific question is why does that relationship exist in Hask? Is there some nice property of Hask that causes it?
16:52:52 <Eduard_Munteanu> Well, I'm not sure, but it's cartesian-closed for a start, so it's got all exponentials.
16:53:13 <Eduard_Munteanu> :t (<*>)
16:53:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:53:43 <Eduard_Munteanu> :t liftA2 ($)
16:53:45 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
16:55:41 <Eduard_Munteanu> :t liftM2 ($)
16:55:43 <lambdabot> Monad m => m (a -> r) -> m a -> m r
16:58:00 <Eduard_Munteanu> Applicatives are sort of exponential-preserving functors.
17:12:33 <iqubic> :t (<|>)
17:12:35 <lambdabot> Alternative f => f a -> f a -> f a
17:13:11 <iqubic> For ExceptT e m what is the f in that type signature?
17:13:37 <pacak> > Nothing <|> Just 4
17:13:40 <lambdabot>  Just 4
17:13:58 <pacak> > Left "uplorry" <|> Right "OK lah"
17:14:01 <lambdabot>  Right "OK lah"
17:14:39 <pacak> For ExceptT that'll be "ExceptT e" part
17:16:10 <iqubic> pacak, look at the kind of Alternative.
17:17:24 <iqubic> I needed to write instance (Monad m, Monoid e) => Alternative (ExceptT e m)
17:22:45 <pacak> Hmm... ExceptT e m a...
17:23:35 <pacak> iqubic: But there is Alternative instance in Control.Monad.Trans.Except for ExceptT
17:28:49 <iqubic> pacak, I'm writting this so I understand how it works.
17:34:17 <iqubic> Eduard_Munteanu: If I mappend the errors together, then this fails: empty <|> x = x
17:34:26 <iqubic> because my empty is a Left
17:35:27 <iqubic> and if I have Left 5 <|> Left 4 and I mappend, then I'm no longer returning x
17:38:47 <iqubic> Well I got something that type checks.
17:39:10 <iqubic> http://termbin.com/zsh0
17:39:18 <iqubic> Sure aint pretty
17:40:03 <EvanR> transformers
17:40:31 <glguy> Yeah, it'd be easier to implement ExceptT using ExceptT
17:40:36 <iqubic> http://termbin.com/571m
17:40:44 <iqubic> Alright, that's slightly better looking
17:40:57 <iqubic> Guys, I'm only writing this to prove that I can.
17:41:05 <thang1> "it'd be easier to implement ExceptT using ExceptT"
17:41:06 <iqubic> It's good practice for me.
17:41:07 <thang1> k
17:41:11 <glguy> iqubic: No, mappending the errors together doesn't fail "empty <|> x = x"
17:41:23 <glguy> but not mappending them together fails "x <|> empty = x"
17:41:46 <iqubic> Oh, so is my code wrong?
17:42:06 <iqubic> Because if the first thing is an error, I just ignore it.
17:43:58 <Koterpillar> glguy: empty is mempty anyway, so it makes no difference 
17:44:20 <glguy> Koterpillar: I'm not sure what you mean
17:44:37 <iqubic> Koterpillar: I'm still throwing away the value of the first computation if it's an error.
17:44:45 <iqubic> :t (<>)
17:44:47 <lambdabot> Monoid m => m -> m -> m
17:45:16 <Koterpillar> glguy: whether you mappend or not, the results of `empty <|>` or `<|> empty` will be the same
17:45:41 <glguy> oh, no
17:45:43 <iqubic> Koterpillar: Was the last paste I showed correct or now?
17:45:55 <iqubic> s/now/not/
17:46:12 <glguy> Koterpillar: That's not true
17:48:45 <iqubic> Koterpillar: Was the last thing I showed correct or not?
17:49:04 <glguy> iqubic: No, it doesn't combine the errors with mappend
17:49:18 <iqubic> How do I do that?
17:49:29 <glguy> map runExcept [ throwE "err" <|> empty, empty <|> throwE "err" ]
17:49:29 <glguy> [Left "err",Left "err"]
17:49:30 <iqubic> Because I have a thing, and I can't get it to work.
17:49:57 <iqubic> http://termbin.com/tzrp
17:50:10 <iqubic> That last mappend is not working properly.
17:51:01 <Koterpillar> glguy: I don't see that, can you show me a counterexample (privmsg if it's a spoiler)?
17:51:13 <glguy> Koterpillar: I just pasted the counter example
17:51:36 <glguy> If you forget to mappend the errors, then you won't get the output as pasted above
17:51:44 <iqubic> I don't understand how to make that last mappend work properly.
17:51:56 <glguy> iqubic: What isn't it doing?
17:52:11 <Koterpillar> glguy: in your example, which exact values are mappended?
17:52:29 <glguy> Koterpillar: mempty and "err"
17:52:44 <glguy> or rather: "" and "err"
17:52:48 <Koterpillar> mappend mempty doesn't change a thing
17:52:53 <glguy> Yes, that's important
17:52:58 <glguy> that's one of the laws of monoid
17:53:05 <glguy> and you rely on it for this Alternative instance
17:53:17 <iqubic> Why won't the mappend work in this: http://termbin.com/tzrp
17:53:19 <Koterpillar> but I can also choose to ignore one of the results
17:53:24 <Koterpillar> and it will still work
17:53:29 <glguy> Koterpillar: Then you won't  get the right answer
17:53:38 <glguy> empty won't be the identity for <|>
17:53:56 <iqubic> glguy: That mappend is not being given the right types.
17:54:16 <glguy> iqubic: Add the error messages you get to your pastes
17:54:47 <Koterpillar> glguy: aha, I see now. I had a different instance in mind and was confused
17:56:25 <lpaste> iqubic pasted “mappend error” at http://lpaste.net/355121
17:56:33 <iqubic> That is what's happening.
17:57:01 <glguy> do you know what that error message means?
17:57:15 <glguy> specifically the first line
17:57:21 <iqubic> Yeah. I do.
17:57:53 <iqubic> It means I'm using the wrong types for mappend
17:57:59 <glguy> no
17:58:05 <iqubic> What does it mean?
17:58:14 <glguy> it said "variable not in scope"
17:58:29 <iqubic> Oh. So I need to import Control.Monoid
17:58:57 <glguy> (<>) is a variable
17:59:02 <iqubic> It is?
17:59:12 <pacak> Isn't it Data.Monoid?
17:59:13 <iqubic> I though that it was an infix mapppend
17:59:19 <iqubic> pacak, I think it is.
17:59:29 <glguy> yes, it's a variable
17:59:32 <iqubic> :t (<>)
17:59:34 <lambdabot> Monoid m => m -> m -> m
17:59:35 <pacak> (<>) = mappend, and defined there
17:59:37 <glguy> and it's implemented with mappend
17:59:55 <iqubic> Well, now my thing works
18:00:27 <iqubic> http://termbin.com/494a
18:00:40 <iqubic> It's now mappending the errors together.
18:00:59 <iqubic> Or short-circuiting if that's what is needed.
18:01:56 <iqubic> It's a large ass pile of code, but I think it'll work.
18:02:52 <glguy> Regarding variables, variables are lowercase names, and operator symbols that don't start with :
18:03:04 <iqubic> Really?
18:03:07 <glguy> and then there are names that are constructors, captialized names and operator symbols starting with :
18:03:14 <iqubic> So <|> is a variable?
18:03:18 <glguy> yeah
18:03:26 <iqubic> Not a function?
18:03:38 <Axman6> what's the difference?
18:03:42 <glguy> function has to do with types
18:03:45 <glguy> not names
18:04:11 <iqubic> But I'm defining <|> in the same way I'd define a function.
18:04:18 <iqubic> How is it not a function.
18:04:27 <glguy> yeah, it's a function. that doesn't have anything to do with being a variable or not
18:04:56 <iqubic> A function isn't a variable.
18:05:02 <glguy> id is a function and a variable. Just is a function and a constructor
18:05:15 <Axman6> variables can definitely contain functions
18:05:29 <glguy> "A function isn't a variable." this is incorrect
18:05:32 <Axman6> functions aren't special
18:05:56 <glguy> True is a  constructor and not a function, getLine is a variable and not a function
18:06:15 <iqubic> Why isn't getLine a function?
18:06:34 <Koterpillar> why not call them values?
18:06:37 <iqubic> Oh. That's because getLine :: IO (String)
18:06:50 <pacak> :t getLine
18:06:51 <lambdabot> IO String
18:07:10 <iqubic> That's just a value.
18:07:20 <pacak> In a monad.
18:07:35 <Axman6> functiona take one argument, getLine taskes none, so it's not a function
18:07:38 <tzh> a function is any value that has a -> in it
18:07:56 <pacak> :t absurd
18:07:58 <lambdabot> Void -> a
18:08:36 <Lokathor> a quick check for oauth2 in haskell turns up the "hoauth2" package
18:08:48 <Lokathor> is this a favored package? or is there some other winner?
18:09:31 <iqubic> Axman6: I'm just used to the OOP style of programming where everything is a function. Even sub-routines that take no inputs.
18:09:44 <pacak> Lokathor: I usually look at "last updated" and "downloads count"
18:10:21 <Lokathor> Uploaded	Mon Apr 17 04:19:50 UTC 2017
18:10:22 <Lokathor> not bad
18:11:18 <glguy> tzh: It's not enough to have a -> in the type, the -> has to be the outermost type
18:11:33 <glguy> tzh: IO (a -> a) isn't a function, for example
18:12:09 <Lokathor> iqubic, a variable /can hold/ a function, but it can also hold some data (2, 'a', etc), but it's still a variable either way
18:12:41 <Axman6> iqubic: very7 few things in oop are functions generally, at least by the definition we use
18:13:17 <Axman6> "everything is an object" is generally closer to my experience with OOP
18:13:36 <Lokathor> iqubic, depending on your OOP flavor, what you're talking about might also be "methods", if it's a subroutine attatched to a class and/or instance
18:13:44 <Axman6> and objects have methods
18:14:24 <Axman6> functions usually don't have any kind of state, methods almost by definition must have state
18:33:53 <iqubic> Git vs Darcs?
18:34:06 <iqubic> Which do people here prefer?
18:34:16 <c_wraith> prefer in theory, or use in reality?
18:34:31 <iqubic> Which do people here use.
18:34:56 <c_wraith> there's a ton of haskell development that takes place on github, including a bunch of the most popular packages
18:35:00 <iqubic> I use Git, but I was thinking of switching to Darcs
18:35:28 <c_wraith> ghc itself uses arcanist/phabricator.  Just to confuse people. :)
18:36:01 <kadoban> Not many use darcs, as far as I can tell. git is quite generally popular.
18:37:32 <pacak> iqubic: git.
18:38:06 <Lokathor> +1 for git
18:38:08 <Lokathor> speaking of which
18:38:18 <Lokathor> https://github.com/facebookincubator/duckling did people see this new thing that was announced in the reddit?
18:38:22 <Lokathor> seems pretty cool
18:38:27 <thang1> I saw that! No idea wtf it actually is
18:38:44 <thang1> oh nvm should've looked at the github readme. I see
18:38:49 <thang1> That's awesome
18:38:56 <thang1> "we recommend using stack"
18:38:59 <c_wraith> the announcement was awfully light on what it actually was, yes.
18:39:03 <thang1> gg no re, stack won. Wrap it up, fuckers
18:39:32 <thang1> /s
18:39:42 <c_wraith> yeah, no matter how many things recommend stack, I still don't need it.
18:40:00 <thang1> Not all of us can be geniuses, c_wraith :p
18:41:23 <iqubic> Is that a thing that facebook is making?
18:41:32 <thang1> made. past tense. They're actively working on it
18:41:43 <iqubic> Facebook made that?
18:41:43 <thang1> anyway imma go for now. Gotta drive home, eat, then actually crank out some homework
18:41:58 <c_wraith> iqubic: hardly the first haskell thing facebook has done.
18:42:01 <thang1> Yup. Facebook does some cool crap. They're trying to be the second google faster than microsoft is getting there
18:42:23 <c_wraith> iqubic: they employ one of the very long-term authors of GHC.  (Obviously, he's worked on GHC longer than he's been at Facebook)
18:42:24 <Lokathor> iqubic, Facebook is a big user of Haskell. Some of GHC's top fixes and patches have come from the Facebook team
18:42:42 <thang1> And for good reason. It's absolutely amazingly ideal for a lot of their usecases
18:42:45 <iqubic> I thought that Facebook was C or C++
18:42:52 <thang1> They use tons of C++ internally too
18:43:06 <Lokathor> iqubic, they're very multi-language. You've gotta be when you're are big as them
18:43:11 <c_wraith> Their frontend is still PHP!
18:43:14 <thang1> You use C++ whenever you need raw speed, you use Haskell whenever you need extreme expressiveness and yet tons of safety and correctness
18:43:22 <exio4> Lokathor: woah, that's quite a cool library
18:43:33 <Lokathor> perhaps one day they'll use Rust for the raw speed :P
18:43:36 <thang1> c_wraith: I thought they were switching from PHP finally? They had PHP for a long time, and then made a typed PHP, and then made something that compiled into PHP, etc...
18:43:55 <thang1> Lokathor: oh most likely. Rust just needs to develop a tiny bit more before places like Facebook pick it up.
18:44:26 <thang1> The biggest thing preventing rust from hitting adoption (imho) is the fact that you can't just super painlessly take your project, snapshot it, and then incrementally write the new parts in rust seamlessly through FFI
18:44:29 <iqubic> Lokathor: Looks like this was created 2-months ago
18:44:29 <Lokathor> thang1, yeah, a few pain points to go
18:44:48 <thang1> Like, you can, but not perfectly. Tons of C/C++ stuff can't be seamlessly interfaced in and out of Rust
18:45:09 <chatter29> hey guys
18:45:12 <chatter29> allah is doing
18:45:13 <thang1> Once that happens, libraries and shit with decades of legacy work can pick up Rust without having to rewrite old work
18:45:14 <Lokathor> iqubic, hmm, the blog post about it that got posted to the /r/haskell feed is from today, https://wit.ai/blog/2017/05/01/new-duckling
18:45:16 --- mode: ChanServ set +o glguy
18:45:16 --- mode: glguy set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.138.68.182.181
18:45:16 --- kick: chatter29 was kicked by glguy (chatter29)
18:45:36 <thang1> lol
18:45:44 <Lokathor> that was fast :P
18:45:51 <thang1> Lokathor: I'm guessing it was created 2 months ago and then made public quite recently?
18:46:01 <iqubic> Lokathor: Look at the date and message for the commit for LICENSE.md
18:46:01 <thang1> anyway, see y'all
18:46:05 <Lokathor> probably yes, to get everything in order for the big reveal
18:46:19 <pacak> glguy: It uses the same nick every time, maybe chatter29!*@*
18:46:21 --- mode: glguy set +bb-b chatter*!*@* *!*@*138.68.182.181 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.138.68.182.181
18:47:41 <glguy> chatter is not chatting, glguy is banning
18:47:43 <iqubic> What did he just do?
18:47:43 --- mode: glguy set -o glguy
18:47:57 <iqubic> is glguy a mod here?
18:48:01 <Lokathor> iqubic, a spambot that keeps showing up
18:48:37 <iqubic> Lokathor: Why does he like our channel so much?
18:48:59 <c_wraith> it's one of the largest channels on freenode
18:49:04 <c_wraith> There are only a few larger.
18:49:12 <kadoban> That bot spams all the small channels too.
18:49:13 <Lokathor> and none as pure
18:49:18 <iqubic> This is a large Freenode Channel?
18:49:31 <iqubic> What channels are bigger than this one?
18:49:35 <iqubic> emacs, vim?
18:49:37 <kadoban> It's always in the top 10, I think it was the second or third biggest last I looked.
18:49:38 <c_wraith> #ubuntu is huge
18:50:16 <iqubic> kadoban: Is there a list of top freenode channels?
18:50:24 <Lokathor> even #rust over on their own Mozilla server is ~1300 compared to our ~1475
18:50:32 <Lokathor> and rust is kinda a big deal lately
18:50:37 <kadoban> Huh, I was way off, it's apparently 7th right now.
18:50:49 <iqubic> kadoban: Where are you getting that data from?
18:50:50 <kadoban> iqubic: Your client should be able to produce one, though don't ask me how, I probably won't know.
18:51:17 <jchia> I have a constraint "KnownNat nt" in the context of a function. How do I express that "KnownNat nt" cannot be zero?
18:51:33 <jchia> In other words, it cannot match "KnownNat 0".
18:52:15 <c_wraith> jchia: I suppose there are ways to write type inequality.  They scare me.
18:52:37 <geekosaur> fwiw my logs show nick chatter[1-9][0-9]* and various ip addresses via kiwiirc gateway
18:52:50 <jchia> c_wraith: There's '~' to express type equality. Is there an opposite?
18:53:20 <geekosaur> no
18:53:21 <c_wraith> jchia: there are ways to construct it, but they're indirect and I don't remember them.  I'm sure you can search for them, though.
18:54:37 <exio4> jchia: I think in this case, it might be better to find a "GreaterThan" constraint?
18:54:57 <c_wraith> actually, GHC.TypeLits already has that.
18:55:06 <glguy> jchia: http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html#t:-60--61-
18:55:41 <jchia> glguy: Thanks
18:55:48 <c_wraith> It's difficult to use, though.
18:55:59 <c_wraith> It doesn't know things like (n + 1) > 0
18:56:01 <EvanR> can you get strict fields in GADT syntax?
18:56:15 <c_wraith> EvanR: yeah.  you can even get record accessors in GADT syntax
18:56:26 <EvanR> how does that work
18:56:28 <glguy> data T where C :: !Int -> T
18:56:31 <EvanR> ok
18:58:59 <jchia> c_wraith: OK, I'll see how far I can get.
19:07:06 <vaibhavsagar_> c_wraith: how do you get record accessors in GADT syntax?
19:08:15 <vaibhavsagar_> ooh, very nice: https://downloads.haskell.org/~ghc/6.6/docs/html/users_guide/gadt.html
19:08:34 <monochrom> Yes, except 6.6 < 8.0
19:08:42 <nshepperd> jchia: you want (<=) from GHC.TypeLits
19:10:35 <vaibhavsagar_> monochrom: it was the first result when I googled "GADT record syntax"
19:11:51 <nshepperd> oh, glguy already pointed that
19:13:06 <Koterpillar> https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#record-constructors hmm
19:13:43 <Koterpillar> no, https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts
19:54:25 <mrck10> helo
19:56:44 <lambdabot> Hello.
19:57:57 <mrck10> whats this server?
20:10:57 <Zemyla> I wish fromRational weren't part of Fractional.
20:11:32 <Zemyla> Because there are objects where fromRational makes sense but (/)/recip don't, and vice versa.
20:12:15 <Zemyla> Example of the first: Polynomials on Q. Example of the second: Z_p where p is prime.
20:31:14 <doesthiswork> I tried :loading https://github.com/noelmarkham/learn-you-a-haskell-exercises/blob/master/03-types-and-typeclasses.hs and got parse error on input `('
20:32:32 <Koterpillar> doesthiswork: well, it's valid haskell. Try typing it manually?
20:37:46 <doesthiswork> haskell 2010 (the last version compatible with my operating system) doesn't permit defining typeclasses manually.
20:37:57 <doesthiswork> interactively
20:38:06 <Koterpillar> type it manually into a file
20:38:54 <pacak> doesthiswork: Can you show full error message?
20:39:25 <doesthiswork> :load 03-types-and-typeclasses
20:39:25 <doesthiswork> [1 of 1] Compiling Main             ( 03-types-and-typeclasses.hs, interpreted )
20:39:26 <doesthiswork> 03-types-and-typeclasses.hs:10:0: parse error on input `{'
20:39:26 <doesthiswork> Failed, modules loaded: none.
20:40:20 <pacak> Hmm... ghci --version
20:40:20 <pacak> ?
20:42:35 <panovia> Is that error an indication about wrong layout? Because there isn't even a brace on line 10
20:42:38 <mikeplus64> anyone got case-splitting working in [spac]emacs, or vs code or ...?
20:43:23 <doesthiswork> that was the wrong error message for that error message I had tried adding a brace to see if it remove the complaint
20:43:34 <doesthiswork> it didn't 
20:43:40 <pacak> panovia: There is one below
20:44:07 <doesthiswork> and I got no response for --version
20:44:28 <pacak> O_o
20:44:31 <glguy> doesthiswork: We need to see the actual contents of the file and the actual error message for that file to help
20:44:36 <pacak> How do you start it?
20:44:53 <doesthiswork> Prelude> :load 03-types-and-typeclasses
20:44:53 <doesthiswork> [1 of 1] Compiling Main             ( 03-types-and-typeclasses.hs, interpreted )
20:44:53 <doesthiswork> 03-types-and-typeclasses.hs:10:9: parse error on input `('
20:44:53 <doesthiswork> Failed, modules loaded: none.
20:45:02 <doesthiswork> and the file is unmodified
20:45:40 <glguy> There's no ( on column 9
20:45:42 <Koterpillar> doesthiswork: can you run sha1sum on that file?
20:45:53 <pacak> that's ghci. How do you start ghci? It should print version info
20:46:18 <panovia> doesthiswork: Make sure there's whitespace before "deriving" in your file
20:46:25 <doesthiswork> The Glorious Glasgow Haskell Compilation System, version 6.12.3
20:46:33 <glguy> doesthiswork: I suspect you deleted the whitespace from that line
20:46:44 <glguy> doesthiswork: that would generate the error at the location 
20:46:48 <doesthiswork> thank you panovia
20:47:16 <pacak> 6.12.3 is a bit old.
20:47:29 <doesthiswork> all leading whitespace had been deleted
20:47:39 <pacak> Some stuff you'll find on the internets might not work.
20:48:37 <glguy> doesthiswork: In Haskell, indentation is significant, so you'll need to take care to preserve it
21:09:31 <Axman6> 6.12.3 isn't a bit old, it's ancient
21:09:42 <Axman6> even ubuntu isn't that out of date
21:09:47 <Zemyla> It could be worse.
21:14:10 <Zemyla> I remember someone popped into ##c++ a while asking for help getting something to work with Borland C++ for Windows 3.1.
21:16:10 <erisco> would have to dig up my time capsule to help you with that one
21:18:06 <Koterpillar> that far back, there are emulators
21:18:34 <Zemyla> Oh, I found it http://qdb.us/310062
21:20:17 <Axman6> heh
21:27:38 <iqubic> What's cracking me amigos?
21:28:01 <iqubic> Quick poll: what colorscheme do people prefer?
21:28:14 <iqubic> I don't like my current emacs scheme at all.
21:29:01 <Axman6> perhaps #haskell-blah would be a better place to ask
21:29:12 <iqubic> Is that a real place?
21:29:19 <Axman6> yes
21:29:54 <Axman6> has over 100 people in it
21:30:07 <iqubic> Must be down right now.
21:30:24 <iqubic> irssi doesn't want to connect to it right now.
21:30:43 <Axman6> it's a channel? :\
21:30:52 <iqubic> What does that mean?
21:31:00 <Axman6>  /join #haskell-blah
21:31:06 <iqubic> I tried that.
21:31:12 <iqubic> It won't load
21:31:21 <Costar> Lol
21:31:26 <Koterpillar> You might have to have proper ident, or SSL connection, or something.
21:31:28 <athan> iirc -blah requires some kind of auth
21:31:33 <athan> use -offtopiuc
21:31:38 <athan> offtopic*
21:31:53 <athan> SASL
21:32:11 <athan> SxSL
21:32:11 <iqubic> How do I set up SASL?
21:32:26 <athan> it depends per-irc client :\
21:32:36 <athan> it's somewhat tricky
21:32:39 <Koterpillar> iqubic: #help for IRC questions
21:32:46 <athan> but it obsoletes `nickserv identify` iirc
21:32:47 <Axman6> @google irssi SASL
21:32:48 <lambdabot> https://freenode.net/kb/answer/irssi
21:32:53 <iqubic> #help
21:33:01 <athan> :v 
21:33:11 <athan> oh my sweet summer child
21:33:38 <Koterpillar> I meant the channel #help too
21:33:43 <glguy> 1) SASL isn't related to getting into #haskell-blah 2) figuring out SASL is offtopic in #haskell
21:33:58 <athan> glguy: re: 1) - why?
21:34:04 <glguy> because it's not
21:34:07 <iqubic> It is not related to getting into #haskell-blah?
21:34:11 <athan> er, how is it not relateded :|
21:34:47 <glguy> SASL is a way to authenticate to nickserv at connection time, it's not related to connecting to that channel
21:34:57 <Koterpillar> what is required then?
21:35:05 <athan> is it all "#haskell-blah is all registered securely with freenode and stuff" and stuff?
21:35:06 <glguy> TLS
21:35:10 <athan> oh hm
21:35:15 <athan> duy, sorry :x
21:35:29 * athan finds his unique mapping back to his dungeon
21:36:07 <iqubic> So, how is SASL not related to #haskell-blah?
21:36:51 <glguy> we just talked about that...
21:37:00 <iqubic> Also, enabling SASL didn't help me get into haskell-blah
21:37:17 <iqubic> glguy: I had to restart my client.
21:37:28 <athan> just do it &copy; nike
21:37:45 <glguy> iqubic: You need to connect with TLS (SSL)
21:37:57 <Koterpillar> iqubic: enable TLS, instructions are still in that link (https://freenode.net/kb/answer/irssi), for more help join #help channel
21:38:53 <iqubic> Why does #Haskell-blah require this?
21:39:25 <athan> ...semantics
21:39:43 <pacak> iqubic: https://cdn.meme.am/instances/500x/51628642/kumamon-why-for-the-glory-of-stan-of-course.jpg
21:40:33 <pacak> no, this one https://cdn.meme.am/cache/instances/folder129/500x/49480129/kumamon-why-for-the-glory-of-satan-of-course.jpg 
21:41:52 <Axman6> to stop spam and keep it to people who have some understanding of irc and its etiquette
21:41:55 <Axman6> possibly
21:42:27 <Axman6> oh iqubic left - this is was not a jab at iqubic btw
21:43:23 <iqubic> I need help enabling SSL in irssi
21:43:35 <MarcelineVQ> come on now
21:43:36 <iqubic> Sorry, wrong channel
21:43:43 <iqubic> I will be taking that to #help
21:45:07 <Axman6> I would help if I could remember now, but I stopped using IRC after about 12 years or so only recently
21:45:33 <iqubic> Axman6: How do you chat with us if you don't use IRC?
21:45:46 <Axman6> uh... irssi, whoops!
21:45:49 <MarcelineVQ> he's got you there
21:46:04 <Axman6> telepathy
21:46:13 <Axman6> this test is not really here
21:46:17 <Axman6> text*
21:46:25 <glguy> You use glirc, of course
21:47:07 <Axman6> indeed :)
21:47:45 <iqubic> What is glirc?
21:48:00 <athan> :v
21:48:04 <Axman6> it's glguy's Haskell irc client
21:48:10 <Axman6> it's pretty nice3
21:48:13 <athan> !!!!!!
21:48:20 * athan bookmarks
21:48:22 <glguy> https://imgur.com/a/ASDi2
21:48:38 <iqubic> Is it free, and availible for others to use?
21:48:49 <athan> that looks as good, if not better than irssi
21:48:51 <Axman6> yes
21:48:57 <athan> endoprops glguy
21:49:07 <iqubic> I love that.
21:49:16 <iqubic> I think I may have to switch right now.
21:49:24 <iqubic> Where can I get the download for that?
21:49:46 <iqubic> I want to use glirc.
21:49:46 <Axman6> it’s not as flexible as irssi, but is in many ways much nicer
21:49:55 <Axman6> github
21:49:55 <pacak> iqubic: /server add -auto -ssl -ssl_verify -ssl_capath /etc/ssl/certs -network freenode -port 6697 chat.freenode.net
21:50:12 <Axman6> pacak++
21:50:13 <iqubic> Axman6: I don't use any of the fancy irssi stuff
21:50:47 <iqubic> Looks like I can also get it on hackage
21:50:50 <athan> they botched their last release iirc
21:51:00 <athan> their latest release on github was broken
21:51:13 <athan> so irssi has gotten lower on the totem pole imho
21:51:24 <athan> v1 I mean
21:51:44 <iqubic> I'm switching to glirc
21:51:48 <iqubic> right now.
21:52:04 * athan waits for the cabal hell
21:53:27 <Axman6> heh
21:53:42 <Axman6> yeah iirc building it is a little less fun than it should be
21:54:22 <Axman6> I wonder if he'll ever be back...
21:58:56 <glguy> glirc? It should be find to build with any of the favorite Haskell build tools
21:59:02 <glguy> be fine*
22:37:28 <iqubic> So, how the heck do I install glirc?
22:38:34 <iqubic> I created a new stack project just because I didn't want to pollute the global project.
22:39:03 <iqubic> Not sure I actually needed to do that. But I did.
22:39:54 <iqubic> So why can't I install glirc??
22:40:08 <iqubic> I want to use that, but it has a ton of deps.
22:40:20 <suzu> clone the repo and `stack build`
22:40:36 <iqubic> Oh, is that all I need to do
22:40:40 <iqubic> I feel stupid.
22:41:04 <iqubic> I was trying to run "Stack Install glirc"
22:41:08 <suzu> stack init then stack build
22:41:13 <suzu> once you've cloned the project
22:41:15 <suzu> i think that should be all
22:41:19 <suzu> you may need to use a ghc8 resolver
22:41:31 <iqubic> I do.
22:41:48 <suzu> then you're good
22:41:50 <suzu> should be al lyou need
22:41:51 <glguy> stack init --solver --resolver=lts-8
22:41:55 <glguy> should work to make a stack.yaml
22:42:59 <glguy> You don't need the resolver flag, but it makes stack init run faster
22:43:48 <pacak> iqubic: Just use irssii
22:44:01 <suzu> glirc so pretty tho
22:44:07 * suzu is a weechat user himself
22:44:23 <suzu> speaking of which, everybody using weechat, upgrade to 1.7 or disable DCC
22:44:33 <iqubic> what's DCC?
22:44:35 <suzu> there's a flaw that'll let anybody crash your client with a privmsg
22:44:38 <ab9rf> why would anyone use weechat?
22:44:43 <yushyin> iqubic: direct client to client
22:45:15 <iqubic> yushyin: why is that bad?
22:45:33 <yushyin> only in 1.7 because of a bug
22:46:01 <iqubic> pacak: I'd like to use glirc, because I think it looks better than irssi
22:46:10 <ab9rf> weechat has a long history of being vulnerable to remote attaacks like that
22:46:18 <ab9rf> which is why sane people avoid it like the plague
22:46:24 <iqubic> Also, irssi lags a lot on my machine.
22:46:36 <yushyin> but weechat is nice <3
22:47:03 <ab9rf> i don't care how pretty or nice an app is, if it's insecure it's out the door
22:47:39 <iqubic> glguy: After running stack init, what should I do?
22:47:44 <iqubic> stack build?
22:47:49 <athan> via an explosion, due to insecurity
22:47:59 <iqubic> Alright, that seems to be working.
22:48:01 <athan> yes
22:48:42 <athan> iqubic: after `stack build` is legit'd, then run `stack install`
22:48:47 <suzu> weechat has a history of vulnerabilites?
22:48:48 <yushyin> iqubic: https://weechat.org/download/security/
22:48:54 <yushyin> suzu: so many!
22:49:28 <athan> at least (...join?), they know of them
22:49:32 <iqubic> athan: Why should I do that? Will it move the executable to ~/.local/bin?
22:49:38 <athan> like.. greatest lower bound of vulnerabilities...
22:49:42 <iqubic> where stack put all executables.
22:49:48 <athan> iqubic: copy it
22:49:58 <athan> so `glirc` is available in $PATH
22:50:12 <iqubic> So why would I do stack build then?
22:50:25 <athan> because stack needs some shit
22:50:36 <athan> that's not like "oh everything is hunkey-dorey"
22:50:45 <athan> you know?
22:51:08 <kadoban> If you really want you can skip to 'stack install', it doesn't matter.
22:51:26 <athan> given that you're inside a `stack.yaml` backed repo :x
22:51:38 <iqubic> kadoban: I'm not going to skip it.
22:52:02 <kadoban> *shrug* okay
22:53:35 * jle` hopes nobody noticed that he just logged off to upgrade weechat
22:53:58 <suzu> :)
22:54:05 <dysfun> hah, one of my friends discovered that
22:54:11 <suzu> the flaw?
22:54:13 <dysfun> yes
22:54:17 <suzu> they were the one to report it?
22:54:21 <suzu> that's really cool tbh
22:54:44 <suzu> the workaround posted on the site literally tells you what to do to sploit people though
22:54:47 <dysfun> they've recently been interested in finding security holes because their work doesn't keep them sufficiently busy
22:54:49 <suzu> kinda not cool
22:55:08 <dysfun> they got 4 CVEs in the last fortnight
22:55:14 <iqubic> So I'm trying to run stack build in the glirc repo, but it can't find the program Alex
22:55:24 <dysfun> iqubic: stack install alex
22:55:27 <suzu> ^
22:55:38 <dysfun> you might need happy too, you usually do if you need alex
22:55:44 <suzu> yup
22:56:15 <iqubic> What are Alex and Happy
22:56:17 <iqubic> ??
22:56:25 <dysfun> haskell eqiuvalents of lex and yacc
22:56:26 <suzu> they are parser generators
22:56:44 <iqubic> dysfun, what are lex and yacc?
22:56:50 <suzu> those are also parser generators
22:56:55 <dysfun> tools for building parsers
22:57:11 <dysfun> low level tools, i should say
22:57:30 <suzu> they're tools that'll let you write programs that can parse and understand a provided language specification
22:58:33 <iqubic> Alright, I can't install Alex, because I don't have QuickCheck.
22:58:43 <iqubic> Is there a way to fix this?
22:58:49 <suzu> uhh what
22:58:51 <dysfun> stack install QuickCheck ?
22:58:53 <suzu> it should install quickcheck for you
22:58:55 <iqubic> Or am in Stack hell
22:59:00 <suzu> there is no stack hell
22:59:05 <iqubic> suzu, it's not doing that for me.
22:59:06 <suzu> only stack afterlife
22:59:19 <suzu> hm, okay. try dysfun's suggestion
22:59:44 <iqubic> Great, QuickCheck wants tf-random
22:59:51 <kadoban> iqubic: What do you mean you don't have quickcheck? Stack installs libraries as it needs them. What exact message did you get?
22:59:58 <suzu> k this isn't the right solution
23:00:08 <suzu> `stack install quickcheck` just refuses to work?
23:00:13 <kadoban> iqubic: Are you still in the directory with whatever program you were trying to build? Go outside of it and install happy and alex first
23:00:37 <suzu> ^ you need to install alex and happy into your system
23:00:52 <kadoban> Well, 'stack install quickcheck' wouldn't be good, the capitalization is wrong. But it shouldn't ever be necessary anyway for this.
23:00:59 <Koterpillar> you might be able to install them as system packages even with your brain dead package manager
23:01:04 <Koterpillar> iqubic: ^
23:01:17 <dysfun> that's not a very nice way to talk about cabal
23:01:26 <Koterpillar> dysfun: they are on Gentoo
23:01:41 <suzu> he was joking about cabal
23:01:46 <dysfun> oh. yeah ok portage is pretty messed up
23:01:59 <athan> hey, I'm brain dead and I still kinda do things sometimes when I am
23:02:15 <dysfun> i've been braindead for many years now and i get by
23:02:16 <iqubic> Koterpillar: I installed them into the global stack package with "stack install happy" and "stack install alex" in my home dir
23:02:27 <suzu> is jumping in and writing something important in haskell a good idea
23:02:38 <athan> ...you know?
23:02:38 <suzu> or is it a method for making me miserable about both the project and haskell
23:02:42 <dysfun> 'important'?
23:02:43 <Koterpillar> iqubic: then go back to glirc and build it again?
23:02:52 <iqubic> Koterpillar: I'm trying that right now.
23:02:54 <athan> yes
23:02:55 <kadoban> suzu: Without knowing haskell you mean?
23:02:56 <suzu> web application that's going to process bitcoin
23:02:58 <glguy> I thought stack was supposed to handle build-tools for you, why would he have to manually install alex or happy?
23:03:08 <suzu> i know haskell up to a point
23:03:14 <dysfun> i mean writing stuff in haskell is a good idea, but if you don't know much of it you might get frustrated in maintenance
23:03:18 <kadoban> I think stack was supposed to do that, but its ability to do so seems limited and wonky.
23:03:33 <suzu> crazier things like type families and heterogenous lists and such escape me
23:03:34 <athan> ...the least fixed point..?
23:03:35 <dysfun> glguy: it's because of cabal. i don't understand the reasons, but they're because of cabal
23:03:43 <suzu> but i know my typeclassopedia and rank-n types and such
23:03:51 <iqubic> glguy: See this https://github.com/commercialhaskell/stack/issues/595
23:04:20 <athan> dysfun: I disagree; stack seems to be committed to ensuring reproducible builds
23:04:22 <suzu> i couldn't tell you how half the shit in servant works, but i can /use/ servant.
23:04:32 <glguy> iqubic: I think it fails less if you're using one of the lts resolvers
23:04:39 <glguy> are you using that or something else?
23:04:40 <athan> across any build envionment, where `stack` is available as an exec
23:04:57 <iqubic> How do I check what resolver I'm using?
23:05:05 <glguy> It gets put into the stack.yaml
23:05:12 <dysfun> athan: well it doesn't quite achieve that. but it does neatly stop cabal hell
23:05:13 <athan> suzu: use nested-routes! :v
23:05:19 <athan> jk don't actually use it
23:05:30 <athan> because it's lolworthy
23:05:34 <iqubic> glguy: I'll look at that.
23:05:48 <athan> iqubic: check your stack.yaml
23:05:58 <iqubic> I will
23:06:16 <athan> dysfun: how does it not achieve that explicitly?
23:06:31 <dysfun> well, build tools is the main area where it doesn't achieve that
23:06:41 <athan> ..?
23:06:49 <athan> build tools? like alex..?
23:06:51 <kadoban> C libraries are a pain point still
23:06:51 <dysfun> you pretty much can't avoid needing alex and happy if you build a webapp at all
23:06:53 <iqubic> Using GHC-8 as my resolver.
23:06:56 <athan> oh shit
23:07:02 <iqubic> What?
23:07:09 <dysfun> GHC-8 isn't a resolver
23:07:09 <athan> hm, I haven't seen that dysfun 
23:07:20 <glguy> dysfun: it is
23:07:23 <dysfun> is it?
23:07:24 <iqubic> stack init --resolver=ghc-8
23:07:29 <LAZAR> What happens when ghci hangs after an input? No error message etc
23:07:31 <dysfun> christ, when did that happen?
23:07:39 <iqubic> See the building instructions here: https://hackage.haskell.org/package/glirc
23:07:41 <suzu> LAZAR: maybe infinite loop? try a CTRL-C
23:07:46 <iqubic> That is what happened to me.
23:07:48 <athan> iqubic: for shits, try `lts-8.9`
23:07:58 <glguy> iqubic: Use one of the lts resolvers
23:08:09 <dysfun> we're on lts-8.12 now
23:08:12 <iqubic> athan: I already got my glirc installed
23:08:15 <glguy> when I wrote that page there wasn't an lts resolver for GHC 8
23:08:17 <athan> :s
23:08:42 <iqubic> Oh, but there is now?
23:08:44 <athan> I ain't a friggin person who should be dependenated upon
23:09:25 * athan sees the void, the void asks him on a shitty date with fuckin sparklers and shit
23:09:46 <iqubic> glguy: You thinking of updating that hackage page?
23:10:08 <LAZAR> Well this is the code: http://lpaste.net/355125 I just wonder why my interpreter works for assigning values to variables but not variables to variables
23:10:14 <glguy> yeah. I never have to fiddle with stack, I jsut "cabal install glirc" when I'm on a new environment
23:11:20 <iqubic> glguy: Once I've done "Stack install" where can I find the executable of glirc
23:11:34 <glguy> I believe it goes into ~/.local/bin
23:11:35 <thang1> that's funny, I have the opposite thing with cabal. I'm so glad I never have to fuck with cabal again
23:11:44 <athan> what's DAssign LAZAR?
23:11:49 <thang1> yes, stack install installs the exec into ~/.local/bin
23:12:00 <thang1> however stack exec will run the executable for you automagically
23:12:13 <thang1> so you don't ever really need to go inside ~/.local/bin/
23:12:13 <athan> please... no
23:12:26 <athan> `automagially` is forbidden in these realms
23:12:39 * dysfun automagically automagicates
23:12:49 * athan hates hate
23:14:44 <thang1> Welp, that derailed things
23:14:54 <athan> okay, so... will -XDependentHaskell be in GHC-9? place your bets
23:14:54 <thang1> s/automagic/automatic
23:15:15 <jle`> dependent haskell is scheduled for ghc 8.6 i believe
23:15:18 <athan> I am for srsly rtnw
23:15:25 <thang1> what jle` said
23:15:31 <athan> :O
23:15:49 <thang1> I'm so excited for DH + Linear Types
23:15:53 <athan> way to destroy a legitimate potential for gains jle` 
23:15:55 <dysfun> linear types scheduled for 8.4 :)
23:16:02 <thang1> However, I have to wonder...
23:16:05 <athan> :O!!!
23:16:06 <thang1> You guys know the language Curry?
23:16:15 <athan> KINDA
23:16:17 <thang1> https://en.wikipedia.org/wiki/Curry_(programming_language) 
23:16:18 <iqubic> What's DH?
23:16:21 <thang1> It's a logic based programming language
23:16:32 <thang1> DH == dependent Haskell. It's dependent types inside haskell
23:16:32 <dysfun> Dependent Haskell
23:16:34 <jle`> 8.8 i think the timetable actually is
23:16:48 <athan> thang1: I am pretending to try and read about the book about Oz right now
23:16:55 <dysfun> anybody made good use of TypeInType yet?
23:16:55 <suzu> any recommendations on a web framework? snap / happstack / yesod / scotty?
23:16:57 <athan> so I'm sorta kinda close to understanding curry
23:17:05 <thang1> Anyway, I really want to see logic && functional programming glued into haskell
23:17:23 <athan> dysfun: It's a hack, but it's useful
23:17:28 <dysfun> suzu: snap is easiest to get going with. yesod is pretty full stack. servant is the trendy for typesafe rest apis
23:17:36 <athan> suzu: nestedroutes!
23:17:37 <thang1> It'd be amazing to see if someone could blend linear types, dependant types, and logical programming into a single language usefully
23:17:40 <suzu> hmm, full stack sounds like what i want
23:17:45 <suzu> think i'll pick yesod then
23:17:50 <suzu> the TH makes me feel uneasy though
23:17:53 <dysfun> athan: it was also billed as "the first major step to DH"
23:17:56 <suzu> what if it breaks on something? i'll be so fucked
23:18:07 <athan> suzu: the TH is aids
23:18:11 <athan> it will consume your life
23:18:13 <suzu> y..eah
23:18:18 <thang1> suzu: TH is really not something to get your pants worked up about, it's totally chill
23:18:19 <dysfun> honestly i never liked yesod
23:18:29 <suzu> im looking at persistent right now and its making me feel uneasy too
23:18:36 <suzu> i dont know how this TH works or how to debug it if theres a problem
23:18:47 <dysfun> well for the most part it 'just works'
23:18:55 <athan> dysfun: have you looked into the caluclus of constructions / types for programming lang's by B. C. Pierce ?
23:18:57 <dysfun> stuff like yesod is by now well tested
23:19:05 <dysfun> athan: no
23:19:14 <suzu> hmm okay
23:19:17 <athan> dysfun: do so
23:19:35 <dysfun> but why?
23:19:52 <athan> but, TIT (type in type, srsly yall) is a very primitate subset of CoC
23:20:14 <athan> suzu: start with persistent
23:20:19 <dysfun> ah
23:20:23 <athan> so see M. Snoyman's method of TH
23:20:32 <athan> it's actually pretty okay for persistent
23:20:52 <dysfun> persistent comes with different problems though
23:20:55 <athan> but i don't trust yeosd so I stay away and have a legal restraining order
23:21:16 <dysfun> so i generated a yesod example project last week
23:21:27 <dysfun> i've never seen such a horrible cabal file
23:21:28 <suzu> what are the problems with persistent?
23:21:29 <athan> :s
23:21:36 <suzu> man i dont want to be debugging this shit at 3am plz plz no
23:21:39 <athan> suzu: not many iirc
23:21:47 <athan> i usually just go with acid-state though
23:21:56 <athan> because FUUUUUCKIN HASKELL AMIRITE?
23:22:01 <suzu> ye tru
23:22:03 <suzu> but is it WEBSCALE tho
23:22:12 <athan> not in the slightest
23:22:15 <athan> so yes
23:22:19 <suzu> lmao
23:22:21 <suzu> okay
23:22:23 <suzu> i'll stick with postgres
23:22:25 <suzu> and take my chances
23:22:29 <dysfun> but it has remote databases. that sounds erlang as fuck
23:22:31 <johnw> suzu: esqueleto works well
23:22:38 <suzu> yeah esqueleto looks sick
23:22:41 <suzu> man fuck this whamlet shit
23:22:46 <suzu> im putting blaze in asap
23:22:46 <athan> siiiiiiick*
23:22:56 * athan make sure you have a wolf tattoo
23:23:00 <suzu> gimme them monoids
23:23:11 <dysfun> yeah fuck hamlet
23:23:15 <athan> McWhamlet*
23:23:17 <suzu> rofl
23:23:25 <dysfun> but if you don't like any of the choices yesod makes, maybe you don't want yesod
23:23:41 <pacak> Yesod makes strange choices.
23:23:45 <suzu> what do i want then?
23:23:47 <athan> suzu: use lucid instead of blaze
23:23:53 <pacak> You not program in haskell, you program in yesod.
23:23:53 <suzu> if i want the rails dream but in haskell
23:23:57 <athan> you'll thank me later when you try to do insane shit
23:24:01 <suzu> lucid, kk
23:24:02 <dysfun> i'm leaning towards snap
23:24:22 <dysfun> not because it's amazing, because it gets out of your way
23:24:32 <pacak> suzu: There's nothing like rails in haskell.
23:24:33 <athan> the rails dream was fucked in the beginning
23:24:39 <suzu> yeah they picked ruby
23:24:40 <athan> they imagined reality as something fininte
23:24:41 <suzu> it was already doomed
23:24:48 <athan> so they fucker'd themselves
23:24:58 <suzu> "fucker'd" lmao
23:25:05 <athan> yeah that goes without saying
23:25:15 <athan> watch trailer park boys
23:25:27 <iqubic> glguy: Why does glirc have 2 executables?
23:25:47 <iqubic> What's the difference between glirc2 and irc-core-bot?
23:25:48 <pacak> Not really. Ruby is a nice language, implementation is bad. You can't make dynamic function names in haskell without doing TH magic
23:25:49 <athan> rtf,
23:26:05 <glguy> the bot is just some example code
23:26:12 <athan> seroiously that comma needs some attention and appreciation
23:26:14 <iqubic> Really?
23:26:20 <iqubic> glguy: What does the bot do?
23:26:44 <athan> pacak: that's what makes it static though iirc
23:27:00 <suzu> rails redefines so much dangerous shit
23:27:01 <glguy> check out the Main.hs in the bot directory. it's just an example of using the irc library
23:27:10 <suzu> rvm even modifies `cd` in your shell
23:27:22 <suzu> fucking
23:27:24 <suzu> cd
23:27:26 <iqubic> Do I need to run that?
23:27:27 <suzu> monkeypatched
23:27:37 <glguy> no
23:27:39 <iqubic> Do I need to run the bot?
23:27:40 <suzu> 2 years of rails dev was good but no more
23:27:49 <iqubic> I'm not going to run the bot.
23:27:54 <pacak> athan: Well... You can imagine find_by_foo_and_bar as MonadFind m, MonadPanic m, HasFoo a, HasBar a => m a
23:28:00 <dysfun> well it's ironic, but most of the jobs i'm seeing that will let me work remotely are rails
23:28:24 <dysfun> this... is not enough to make me write rails
23:28:25 <athan> suzu: I want to battle the rails inventor on something
23:28:31 <suzu> DHH?
23:28:32 <athan> like... doing things
23:28:34 <athan> for instance
23:28:35 <suzu> lolll
23:28:44 <suzu> you mean challenge him to do stuff?
23:28:48 <suzu> i dont understand
23:28:57 <dysfun> so i used to hate DHH, but i've agreed with him a lot recently
23:29:03 <athan> no i mean, challenge him on to being capable of doing shit
23:29:05 <athan> because wtf
23:29:12 <pacak> It's getting more and more offtopic.
23:29:23 <thang1> Ok so I'm confused here
23:29:34 <athan> exactly
23:29:47 <suzu> rofl
23:29:49 <thang1> In type theory, there's Calculus of Constructions, Homeotopy type theory, and Intuitionistic type theory
23:29:54 * athan finds that dungeon again, shit.
23:30:13 * athan thang1 be more specific :|
23:30:16 <thang1> Haskell uses a subset of Intuitionistic type theory, right?
23:30:35 <athan> very very like..... SUPER small subset
23:30:38 <athan> (iirc)
23:30:46 <athan> read PFPL
23:30:48 <thang1> And Homotopy theory being implemented in a computer language is still being studied, so no languages even uses it yet
23:30:50 <thang1> right?
23:31:04 <thang1> So then Calculus of Constructions... wher edoes that one come in? o.O
23:31:05 <athan> and you will have light shining from your eyes so you'll never need a flashlight again
23:31:16 <dysfun> PFPL?
23:31:27 <athan> thang1: Coq implements CoC
23:31:44 <thang1> Yeah, but someone said earlier that DH was gonna use CoC of some sort? o.O
23:32:09 <athan> iirc well
23:32:16 <athan> it's fucker'd
23:32:34 <thang1> Also, is CoC different than intuitionistic type theory or from the same "family" of type theories? It's a higher-order typed lambda calculus, but I'm not quite sure where all of these things fit together in the whole space of type theories...
23:32:46 <athan> yeaaa boiii: https://coq.inria.fr/refman/Reference-Manual006.html
23:32:48 <thang1> I also have no idea where the fuck logic programming fits in there 
23:33:06 <athan> thang1: I think you are right
23:33:13 <athan> in the sense of decidability
23:33:36 <athan> but that's something PFPL explains, given that I've already read it (get it?)
23:33:49 <thang1> Man if only I knew what tf that acronym meant...
23:34:00 <thang1> brb gonna see if based google knows
23:34:05 <thang1> ahhh, yes. Park forest public library
23:34:13 <athan> practical foundataions for parks and territories
23:34:15 <thang1> or practical foundations for programming languages
23:34:18 <athan> er, programming languages
23:34:23 <thang1> hahaa
23:35:13 <thang1> thx, downloaded it
23:35:15 <suzu> class Term arg result | result -> arg where
23:35:17 <suzu> wtf is this
23:35:19 <suzu> this | shit
23:35:26 <thang1> *cough* I mean added to cart
23:35:29 <athan> \me will cut you if you denote my T as not equivialent, extensionally to an L
23:35:53 <athan> suzu: it's close enough
23:35:55 <athan> you know>
23:35:59 <athan> ?**
23:36:00 <lambdabot> Maybe you meant: wn v rc pl id do bf @ ? .
23:36:15 <athan> > class WTF a b | a -> b
23:36:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘class’
23:36:36 <suzu> its what
23:36:38 <suzu> ?
23:36:47 <johnw> thang1: https://cstheory.stackexchange.com/questions/7561/whats-the-relation-and-difference-between-calculus-of-inductive-constructions-a
23:36:54 <suzu> > class WTF a b | a -> b where
23:36:55 <athan> > class WTF a b | a -> b where; fuckinn :: a -> b; instance WTF () () where; fuckinn () = ()
23:36:57 <lambdabot>  <hint>:1:1: error: parse error on input ‘class’
23:36:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘class’
23:37:08 <athan> basicall
23:37:11 <athan> y'd
23:37:22 <NJBS> Does Haskell support "or patterns" in pattern matching like OCaml? Basically I want to have multiple patterns invoke the same expression without needing to write the expression twice.
23:37:38 <athan> you're using `->` in the sense of "funcitonal dependencies"
23:37:58 <thang1> johnw: thanks
23:38:23 <athan> they denote the capacity to identify dependent "tags", of which can determine the exact instances of particular type classes
23:38:47 <athan> NJBS++
23:39:11 <Axman6> NJBS: I don't believe you can do it in Haskell
23:39:33 <NJBS> Ah, that's unfortunate :(. Thanks for the answer!
23:39:46 <suzu> oh ok let me look up fundeps
23:39:54 <athan> (given that the n-pair of dependent tags is accumulated at compile time)
23:40:01 <athan> it's chill'n
23:40:27 <suzu> so it says that the type of `b` can be determined by the instance of `a` being used
23:40:32 <suzu> thats what WTF a b | a -> b means
23:40:36 <suzu> is that correct?
23:40:51 <dysfun> yes. that's FunctionalDependencies
23:40:57 <suzu> why do we care though?
23:41:04 <suzu> why cant we live with class WTF a b
23:41:16 <suzu> and just define instances of a and b ourselves?
23:41:17 <dysfun> you can. but it'll reduce the helpfulness of the type checker
23:41:43 <yushyin> NJBS: https://github.com/ghc-proposals/ghc-proposals/pull/43 just for reference
23:41:46 <athan> correctanamamously
23:41:54 <athan> 'd
23:42:01 <athan> 'jet
23:42:11 <suzu> so i'm looking at the haskell wiki entry for fundeps and i dont understand the motivation for using these
23:42:24 <suzu> supposing you have:
23:42:26 <NJBS> yushyin, Oh great, thanks! I'll be sure to sub to the thread.
23:42:41 <dysfun> essentially, they give GHC an option for solving the constraint backwards
23:42:44 <jle`> in practice it seems to be mostly for type inference, although you can use them to simulate type functions in a way
23:42:48 <athan> suzu: you can use MultiParamTypeClasses, but you may find yourself annotating types to determine instances of which are used before typechecking
23:42:51 <athan> [tm]
23:42:56 <athan> *
23:43:06 <suzu> class Mult a b c where; (*) :: a -> b -> c;
23:43:08 <suzu> instance Mult Matrix Matrix Matrix where {- ... -}
23:43:10 <suzu> instance Mult Matrix Vector Vector where {- ... -}
23:43:19 <suzu> and
23:43:21 <suzu> m1, m2, m3 :: Matrix
23:43:25 <dysfun> you would have to solve this one way or another, but this way it won't require manual type entry at the use site
23:43:27 <athan> [tm*] of which defines a method where things are more better than our trash heap we like to call trademarks
23:43:33 <suzu> why does (m1 * m2) * m3
23:43:38 <suzu> give you an ambiguity error?
23:43:50 <suzu> i mean m1 and m2 are Matrix-es
23:44:01 <suzu> why cant the compiler choose to use Mult Matrix Matrix Matrix?
23:44:06 <suzu> wtf else could you use
23:44:21 <athan> because multiparam type classes doesn't prefer to define the set of which instances already exist
23:44:25 <quchen> The outer * could Mult Matrix Matrix Anything.
23:44:26 <athan> and constrain against it
23:44:26 <jle`> there might be other instances potentially
23:44:40 <suzu> but the m3 is there
23:45:01 <athan> because space math
23:45:03 <jle`> what abotu the type of (m1 * m2) * m3 ?
23:45:03 <suzu> so it can't be Mult Matrix Matrix _
23:45:14 <quchen> Yes, that’s the »Mult Matrix (Matrix) Anything« matrix.
23:45:19 <athan> ot
23:45:27 <athan> it's legit'dly space
23:45:29 <athan> srsly
23:45:38 <athan> okay I'm out, g'night yall
23:45:42 <suzu> im not sure where the anything part comes from
23:45:44 <suzu> night athan 
23:45:45 <dysfun> night
23:45:50 <jle`> suzu: yes, suppose m1 * m2 :: Int
23:45:55 <suzu> okay
23:46:03 <jle`> then (m1 * m2) * m3 could be a Matrix Int Matrix instance
23:46:09 <jle`> who knows
23:46:28 <athan> (fuckin Int is decided tho, and fundeps coerce decidability
23:46:29 <athan> )
23:46:30 <mivael_> hi all
23:46:30 <jle`> it could be that the inner one uses Matrix Matrix Bool, and the other * uses Matrix Bool Matrix
23:46:31 <suzu> but such an instance does not exist
23:46:37 <jle`> it could potentially exist
23:46:46 * athan fuckin had toomany wite-ish russians
23:46:47 <suzu> if it doesn't, would it typecheck ok?
23:46:58 <quchen> It could exist in another module.
23:47:08 <suzu> if it didnt exist at all, would it work?
23:47:11 <quchen> It could exist based on how the module is used in other modules.
23:47:29 <jle`> it might exist until some remote module imported some other remote module and everything breaks
23:47:36 <suzu> lol kk
23:48:00 <suzu> so pretty much ghc doesnt know what you want the (m1 * m2) to be
23:48:06 <dysfun> honestly if you want to avoid 'space math' as athan charmingly puts it, it's easier to just treat the type system as what it is and learn how to use it
23:48:15 <suzu> (m1 * m2) :: Matrix * m3 would typecheck
23:48:19 <suzu> but be uggo af
23:48:21 <mivael_> Are there backward compatible ways of "including" int64Dec in source code?
23:48:27 <jle`> ((m1 * m2) :: Matrix) * m3 :: Matrix might
23:48:32 <suzu> err yeah
23:48:35 <dysfun> yes. the functionaldeps stops you having to write that type sig
23:48:37 <suzu> didnt onion it enough
23:48:51 <suzu> so the fundeps here
23:48:55 <suzu> class Mult a b c | a b -> c where
23:49:04 <suzu> tell GHC that you can lookup c by knowing a and b
23:49:07 <dysfun> yes
23:49:10 <suzu> so do that to get the type of c
23:49:19 <dysfun> and ghc will tell you if you break a fundep
23:49:31 <athan> specifically
23:49:35 <suzu> if i define a Matrix A B X and an Matrix A B Y, it'll tell me that i fucked up?
23:49:37 <suzu> sweet
23:49:43 <dysfun> yes
23:49:48 <dysfun> it'll tell you it breaks the fundep
23:49:52 <athan> there must be a route of wich it can bona-fide decide `c`'s monomorphic type
23:49:53 <suzu> ily ghc
23:50:08 <athan> given `a` and `b`'s "shape"
23:50:10 <suzu> shoutz to spj for the sick compiler
23:50:13 <dysfun> well you could use IncoherentInstances if there's only one, but don't do that
23:50:40 <mivael_> According to the docs, int64Dec should reside in Data.ByteString.Builder (http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Builder.html#v:int64Dec)
23:50:46 <athan> (of which can be either monomorphic types or some kind of higher order thing that's not worth spending time on because I don't know why I'm here)
23:51:21 <athan> suzu: don't shout
23:51:35 <athan> SCREAM, for bitcoins and monero to go his way
23:51:43 <athan> somehow
23:51:53 <mivael_> However, it is an error on my current environment: "Could not find module `Data.ByteString.Builder'"
23:51:54 <athan> or, even better
23:52:08 <suzu> athan: lol what are you saying
23:52:12 <athan> do more research than me onto the unshowered devs that make our ideas
23:52:23 <dysfun> he should just go work at facebook with SM and be paid to improve ghc all day
23:52:29 <suzu> oh to go to spj
23:52:37 <suzu> ye
23:52:46 <athan> it'znt just spj tho
23:52:54 <suzu> i actually did apply to fb
23:53:00 <athan> he'dn't maketh' DH iirc
23:53:03 <suzu> i got an offer but no guarantee that i'd be doing haskell
23:53:05 <athan> therefore fuckin wat
23:53:05 <suzu> :(
23:53:06 <athan> you know?
23:53:23 <dysfun> oh i wouldn't want to work at fb unless i was famous enough to cut a great deal
23:53:29 <athan> suzu: I would bitch at them
23:53:31 <suzu> i'm sure all the other minds in this channel could do the same and get a haskell team unlike me
23:54:01 <athan> and say "haskell makes for sure that things will always be correct and working for your demos because you're fucking dumb"
23:54:05 <athan> and they usually bityer
23:54:11 <athan> bite* fak
23:54:17 <suzu> yeah recruiters don't understand those words
23:54:30 <suzu> they got team placement and quotas and shit to deal with
23:54:30 <athan> "fuck you" :D
23:54:32 <suzu> rofl
23:54:38 <suzu> i ended up not taking the offer fyi
23:54:53 <suzu> ¯\_(ツ)_/¯
23:55:14 <suzu> but y'all should go for a hs team at fb if you can. def would've taken it if offered :(
23:55:25 <athan> "yep haskell sure does put the dealio's in the effect modulator so that the area compartment sure does put the part in the dealio"
23:55:31 <suzu> lmfao
23:55:33 <suzu> athan go sleep
23:55:38 <athan> FUCK
23:55:45 <sophiag> question wrt to criterion: how do i call whnf or nf when benchmarking pure functions of arity 0?
23:56:00 <athan> suzu: fb'
23:56:03 <athan> s haskell
23:56:10 <athan> is unspeakable
23:56:17 <athan> so yea
23:56:18 <suzu> it is unspeakable?
23:56:24 <athan> fuckin spaaaaaace
23:56:32 <suzu> ur high m8
23:56:33 <johnw> athan: language, please
23:56:48 <dysfun> suzu: google for 'haxl', should give you an idea
23:56:54 <suzu> yeah i've seen haxl
23:57:10 <athan> only around the area of which doesn't techically have grammatical semantics because I somehow just convinced you of it, eh?
23:57:30 <suzu> can you go to bed yet
23:58:31 * athan will dive for cover before the mortars of assumed friggin' bad language hit. Thank you johnw and glguy for everything you've done for me, lmao srsly rn. RN, thank you.
23:59:01 <athan> SRS (mortar hits)
23:59:25 <mivael_> I finally found int64Dec in Data.ByteString.Lazy.Builder.ASCII -- but it should not be there according to docs (http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy-Builder-ASCII.html)
