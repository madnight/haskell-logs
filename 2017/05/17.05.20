00:00:54 <ph88> jle`, i changed line 7 to 10 .. this type checks too  https://bpaste.net/show/6957cefe34d8
00:01:31 <jle`> yes that was what i was thinking :)
00:02:00 <ph88> :)
00:02:30 <ph88> this is the first time that i used traversed .. i looked into it before .. but not super familiar
00:02:46 <ph88> it's like fmap + return  right ?
00:02:57 <jle`> in this context, traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
00:03:02 <jle`> it's like an "effectful map"
00:03:08 <ph88> ok
00:03:10 <jle`> map :: (a -> b) -> Maybe a -> Maybe b)
00:03:19 <jle`> traverse :: (a -> IO b) -> Maybe a -> IO (Maybe b)
00:03:34 <jle`> so instead of fmapping an (a -> b), you're "fmapping" an a -> IO b
00:03:46 <ph88> okidoki
00:03:50 <ph88> are there opportunities here to clean up the code some more from line 7 to 17 ?
00:07:30 <ph88> flip . traverse == for    ?
00:07:40 <jle`> for = flip traverse
00:14:05 <ph88> can i use  pure . fromMaybe   to replace line 15 to 17 ?
00:33:00 <merijn> hmm, is there a reason why there is a foldM, but not foldM'? Does foldM' not require strictness?
00:54:23 <ph88> does anyone know how i can disable reformatting help text with optparse-applicative? it's removing spaces and newlines where i want them
00:56:26 <ph88> i have this in my source: "Combinations of options:\n" ++ "| timecolumn | sampletime |  resample   | \n" ++ "|      ✘     |     ✘      |      -      | \n"   and it prints like this:  Combinations of options: | timecolumn | sampletime | resample | | ✘ | ✘ | - |
01:02:04 <jle`> optparse-applicative uses the ansi-wl-pprint library to do its formatting
01:02:22 <jle`> i think you can pass in explicit Doc's
01:03:07 <ph88> i thought maybe this function could help  https://hackage.haskell.org/package/optparse-applicative-0.13.2.0/docs/Options-Applicative-Help-Chunk.html#v:stringChunk
01:03:18 <cocreature> while we’re on the topic of optparse-applicative, is there any way to get it to show me help for positional arguments?
01:03:20 <ph88> to replace paragraph here   https://hackage.haskell.org/package/optparse-applicative-0.13.2.0/docs/src/Options-Applicative-Builder.html#progDesc
01:03:31 <ph88> cocreature, what are positional arguments ?
01:04:05 <jle`> ph88: yeah checkout progDescDoc
01:04:10 <jle`> instead of taking a String, it takes a Doc
01:04:14 <cocreature> ph88: arguments that don’t belong to some flag and are identified by their position in the argument list
01:04:30 <cocreature> e.g. in "cat a b" a is the first positional argument and b is the second
01:05:20 <ph88> oh i didn't even know that was supported o_O
01:05:50 <cocreature> ph88: you can just use "strArgument" or the more general "argument" parser for this
01:06:08 <cocreature> but it seems to be ignoring what I specify via help
01:10:23 <cocreature> ah I just need to use hsubparser instead of subparser and then --help works
01:10:26 <cocreature> nice
01:10:49 <ph88> cocreature, can you show ?
01:11:00 <cocreature> ph88: what?
01:20:13 <ph88> cocreature, what you were able to achieve with hsubparser
01:20:48 <ph88> by the way, why is the help text of optparse-applicative showing  Usage: <interactive> [..Myoptions here ..]    what is that interactive part ?
01:21:39 <jle`> it probably uses the name of the process/executable
01:21:45 <jle`> are you running it in ghci?
01:22:19 <ph88> ye
01:22:23 <ph88> ah right :D
01:22:32 <jle`> if you compile it, it'll use the name of the executable
01:22:41 <ph88> :)
01:22:46 <jle`> it's kind of like $0 in bash
01:22:52 <ph88> ye
01:23:05 <ph88> is there an easy way to manage blobs (resources) i want to include in my program ?
01:23:19 <ph88> instead of having separate files it would be nice to include them in the binary
01:23:58 <jle`> you'd probably have to do something with TH there
01:24:47 <ph88> oh ok o_O
01:24:57 <jle`> but popping resources into your binary probably isn't the best way to do things
01:25:01 <cocreature> ph88: the output now looks like this http://sprunge.us/WdjO
01:26:29 <cocreature> ph88: file-embed allows you to embed things in your executable via TH
01:31:04 <ph88> thx
01:31:06 <ph88> be back later guys
01:31:14 <ph88> looks good those options cocreature 
01:36:20 <mniip> why does ghci need to execute gcc?
01:37:24 <jle`> just tried it out and i'm slightly disappointed that :set -XCPP doesn't actually do anything
01:37:40 <jle`> well. it affects interpreted files i suppose
01:47:42 <mniip> apparently
01:47:47 <mniip> --print-file-name libgmp.so
01:47:50 <mniip> is all it needed
01:59:19 <mniip> what determines the location of .dyn_hi files for installed libraries and why is it not --prefix
02:00:42 <EvanR> i am noticing weak pointers reporting death when i dont expect it
02:01:23 <EvanR> "references to ordinary non-primitive haskell types are particularly fragile" what kind of objects does it make sense to get a weak ptr to?
02:03:47 <Adeon> IORefs, MVars, they have their own functions to create weakrefs that behave more as you'd expect
02:04:55 <EvanR> mkay i have some lying aroun, guess ill use refs to those
02:11:34 <EvanR> yeehaw
02:11:36 <EvanR> ghc: Prelude.undefine
02:11:41 <EvanR> d
02:11:58 <EvanR> when evaluating the result of deRefWeak
02:12:05 <EvanR> to see if its Nothing or Just
02:20:37 <EvanR> so thats using the IORef weak ptr
02:20:55 <EvanR> happens in compiled too
02:21:35 <EvanR> programName: undefined
03:18:45 <jchia_1> optparse-applicative reader question. There's no ReadM Double AFAICT. Is there a shorter route than something like 'Options.Applicative.Builder.maybeReader . ClassyPrelude.readMay'?
03:19:08 <jchia_1> I mean "optparse-applicative ReadM question."
03:20:22 <jle`> there is a ReadM Double
03:20:49 <jle`> it's `auto`
03:21:05 <jle`> http://hackage.haskell.org/package/optparse-applicative-0.13.2.0/docs/Options-Applicative-Builder.html#v:auto
03:21:40 <jle`> fwiw it's just a wrapper over eitherReader
03:22:42 <jchia_1> jle`: Thanks
03:23:14 <jle`> np!
04:52:56 * hackage libgraph 1.12 - Store and manipulate data in a graph.  https://hackage.haskell.org/package/libgraph-1.12 (faddegon)
05:02:54 <fred-fri> i'm running spacemacs with the haskell layer... if i put the caret on an application of one of my own functions and go to definition, spacemacs opens it for me... but if i do it on eg putStrLn nothing happens. what am i missing?
05:24:03 <kuribas> How do you create a suffix tree efficiently in haskell?
05:26:41 <mniip> kuribas, I would put strings into a map and do a monotonic filter probably
05:26:47 <mniip> repeatedly
05:26:58 <kuribas> does it have O(n) complexity?
05:27:06 <kuribas> or O(n log n) at most?
05:38:28 <kuwaity> 1
05:38:28 <kuwaity> 1
05:38:28 <kuwaity> 1
05:38:29 <kuwaity> 1
05:45:25 <maybefbi> should i avoid lists altogether, and use something else always?
05:46:07 <kuribas> maybefbi: why?
05:46:17 <kuribas> maybefbi: use what is appropriate.
05:46:26 <liste> maybefbi: no, lists have many useful use cases
05:46:37 <liste> maybefbi: the most important one is iteration
05:46:48 <maybefbi> relevant nick :)
05:46:55 <maybefbi> ok
05:47:09 <maybefbi> i guess i will use it then, because im iterating over it
05:47:09 <liste> I use lists in many cases I would use for loops in other languages
05:47:20 <kuribas> maybefbi: for example a Map, Set, Vector, Sequence, etc...
05:47:41 <maybefbi> what about String? should i avoid String always, and use ByteString or Text?
05:47:47 <liste> maybefbi: yes
05:48:52 <maybefbi> i wonder why people dont say use vector instead of list always, vectors have head and tail too and helps with iteration no?
05:49:16 <cocreature> maybefbi: they don’t have an O(1) cons operation
05:50:09 <maybefbi> but what if my list is consed just once during initialization using hardcoded constant data?
05:50:26 <cocreature> then vector is fine and potentially faster
05:50:33 <maybefbi> noted 
05:50:47 <cocreature> but as always benchmark to figure out if it’s actually faster :)
05:50:54 <Tuplanolla> You can reserve space ahead of time when constructing a `Vector`, maybefbi.
05:50:59 <liste> btw, what is the status of stream fusion?
05:51:02 <kuribas> maybefbi: use a vector when you need O(1) indexing.
05:51:30 <maybefbi> Tuplanolla, cool
05:51:35 <maybefbi> kuribas, ok
05:52:04 <kuribas> maybefbi: but beware than functional update is O(n).
05:52:11 <cocreature> that’s not the only reason to use a vector. even if you traverse it sequentially, the fact that you get better cache locality can make vector significantly faster
05:52:25 <maybefbi> kuribas, my vector is a constant list of domains
05:52:54 <kuribas> If you don't need indexing I'd say use a list.
05:53:02 <sternmull> maybefbi: In imperative languages vectors may be more often the better choice. In haskell lists often are nicer because they fit the functional programming problems (creating values) while vectors are often less useful because they are immutable.
05:53:06 <kuribas> even if it is a tiny bit slower.
05:53:24 <maybefbi> ok
05:53:53 <kuribas> You can have O(1) append for a vector, but it is a mutable operation.
05:53:54 <maybefbi> i guess i will use [ByteString] for my constant list of domains i iterate over
05:54:49 <cocreature> you can have _amortized_ O(1) append for a vector
05:55:39 <kuribas> The expert question on the current hackerrank competition is rather trivial with a suffix tree, but building one doesn't see trivial...
05:55:52 <kuribas> I wish copy pasting was allowed...
05:56:22 <kuribas> I wonder how people can solve these in under an hour...
05:56:56 <Tuplanolla> The trick is to stop caring about quality.
05:57:30 <Maxdamantus> also note that when you do something like `map f . map g . map h $ a`, it's not constructing lots of big intermediate structures.
05:57:43 <kuribas> Tuplanolla: even then, they will not work with brute force.
05:58:25 <kuribas> Perhaps they have a library of solutions to reuse...
05:58:28 <joncol> What's the current state of the book "The Joy of Haskell"? Tried visiting the web page for the book, but couldn't find much information.
06:03:11 <sternmull> when looking for online books i found https://en.wikibooks.org/wiki/Haskell to be the most useful.
06:03:59 <cocreature> joncol: I don’t think either of the authors come here so probably want to send them an email if you want more info
06:12:49 <balor> I've derived a Functor for a record type.  Is there a way to get `ghci` to show me the functor that it has derived?  Just out of interest.
06:14:24 <lyxia> balor: you can do   :set -ddump-deriv   before deriving
06:15:17 <balor> lyxia, thanks
06:20:06 <joncol> cocreature: OK, gotcha.
07:00:08 <kuribas> How do you turn a mutable structure in a pure one?
07:00:46 <kuribas> for example (s IORef) -> (s Identity)
07:01:29 <c_wraith> I mean, you could do that.
07:01:34 <hpc> start with addind MonadIO s to that type
07:01:41 <hpc> or something like that
07:01:51 <c_wraith> But there's no automatic answer.
07:01:59 <c_wraith> You just write the appropriate traversal for your type
07:02:04 <hpc> MonadIO s => s (IORef a) -> s (Identity a)
07:02:07 <jchia_1> Lens question. I have 'data NeedsLens = HasLens1 HasLens1 | HasLens2 HasLens2 | HasLens3 HasLens3' where HasLens[1-3] all have an instance of 'class HasPart a where part :: Functor f => (Int -> f Int) -> a a -> f a'. In other words, HasLens[1-3] all have lens that let them focus to an Int, as witnessed by HasPart. How do I easily define an instance of HasPart for NeedsLens easily making use of the HasPart instances of HasPart[1-3]?
07:02:19 <kuribas> c_wraith: I suppose so...
07:02:24 <c_wraith> hpc: that feels like an extra s
07:03:24 <jchia_1> Correction: 'Functor f => (Int -> f Int) -> a -> f a'
07:04:15 <hpc> c_wraith: i don't want to give up the whole game by reducing the type to something like IORef a -> IO a
07:04:19 <hpc> :P
07:04:33 <jchia_1> Basically, NeedsLens is a sum type and I want to make a lens for it in terms of the lens for the parts of the sum.
07:05:14 <Tuplanolla> Don't you need a prism, jchia_1?
07:05:32 <c_wraith> Tuplanolla: well, no.  Every branch has the same lens
07:06:18 <c_wraith> jchia_1: have you ever written a lens by hand?
07:06:53 <jchia_1> Tuplanolla: I don't know much about prism, only heard of them. I just need to have something to focus into the parts.
07:06:55 <AlainODea> jchia_1: instances are on types. HasLens[1-3] aren't types, they are inhabitants of the NeedLens type. There would be an instance of Functor for NeedLens that would handle each of HasLen[1-3] by pattern matching
07:07:31 <jchia_1> c_wraith: Only simple for accessing part of a simpel product type.
07:08:12 <c_wraith> jchia_1: this is a little more interesting, but.. not much.
07:09:10 <jchia_1> AlainODea: data HasLens1 = HasLens1 ...; data HasLens2 = HasLens2 ..; data NeedsLens = HasLens1 HasLens1 | HasLens2 HasLens2 | HasLens3 HasLens3;
07:11:20 <AlainODea> That won't compile. HasLens[1-3] are inhabitants or data constructors. They can't also be types.
07:11:44 <c_wraith> AlainODea: sure they can
07:11:49 <c_wraith> AlainODea: they're different namespaces
07:12:19 <Tuplanolla> It won't compile for other reasons.
07:12:25 <AlainODea> c_wraith: oh, right. It won't work as expected though ;)
07:12:56 * hackage JuicyPixels-extra 0.2.1 - Efficiently scale, crop, flip images with JuicyPixels  https://hackage.haskell.org/package/JuicyPixels-extra-0.2.1 (mrkkrp)
07:14:59 <jchia_1> AlainODea: OK, more accurately, I mean 'type HasLens1 = ( "a" := Int, "b" := Char); type HasLens2 = ( "a" := Int, "b" := [Int])'
07:15:17 <wilornel> I think it's interesting that Haskell needs many definitions for functions on 2-tuples, 3-tuples, 4-tuples, and others
07:15:49 <AlainODea> jchia_1: I'm out of my depth here. I'll leave you in more capable hands ;)
07:15:50 <wilornel> is there no way to define a function such that it can take different sized tuples?
07:16:19 <Tuplanolla> Lenses are accompanied with type classes for that, wilornel.
07:16:25 <Tuplanolla> @hoogle Field1
07:16:25 <lambdabot> Control.Lens.Tuple class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s
07:16:26 <lambdabot> Lens.Micro.Internal class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s
07:16:26 <lambdabot> Agda.Utils.Lens.Examples field1 :: Record a b -> a
07:17:01 <wilornel> ah, I don't know much about lenses yet, and these definitions are confusing D:
07:17:07 <wilornel> I've never seen this | syntax before
07:17:32 <Tuplanolla> You can almost ignore it if you just want to use the classes.
07:17:54 <wilornel> hmm alright
07:18:05 <wilornel> is that | an overloading of syntax?
07:18:06 <wilornel> :(
07:18:14 <Tuplanolla> It's a functional dependency.
07:19:45 <jchia_1> Tuplanolla: Actually, Prism allows me to do 'preview' and 'review'. I don't need those. I still just need the lens functionality of 'view' and 'set'. The part I'm focusing on exists in all the 'branches' of the prism and there's no 'Maybe' involved.
07:19:54 <wilornel> thanks Tuplanolla 
07:27:24 <c_wraith> jchia_1: http://lpaste.net/355704
07:28:52 <c_wraith> jchia_1: note that my entire dev procedure for that was using typed holes.  Throw a hole in, look at what types I need and what types are in scope..
07:29:57 <jchia_1> c_wraith: Thanks. Let me try that approach with my code.
07:33:32 <wilornel> I don't get   undefined :: (Plus (S Z) (S Z) r) => r :: S (S Z)
07:33:38 <wilornel> in  https://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/
07:34:26 * hackage ombra 0.3.1.0 - Render engine.  https://hackage.haskell.org/package/ombra-0.3.1.0 (ZioCrocifisso)
07:35:05 <c_wraith> wilornel: All it's really doing is demonstrating that the type is well-kinded
07:35:48 <wilornel> I'm trying to find how does it figures out what r is. Because that's what we show, right? We ask for r by doing `:t undefined :: (Plus (S Z) (S Z) r) => r`
07:35:48 <c_wraith> wilornel: well, and that GHC doesn't reduce the type
07:36:10 <c_wraith> wilornel: it's not figuring anything out.  That's why the output says the type is identical to what was provided
07:36:20 <wilornel> Hmmm
07:36:28 <wilornel> The type is identical?
07:36:40 <c_wraith> yeah
07:36:43 <wilornel> (S Z) (S Z) r  does not look identical to S (S Z)
07:36:47 <wilornel> that's what's confusing me
07:37:03 <c_wraith> Oh, you're further down the page than I was checking.  My mistake
07:37:17 <wilornel> ah yes
07:37:22 <wilornel> two boxes down
07:38:54 <c_wraith> So, the two instances in the previous box are how it works
07:39:39 <c_wraith> They almost read like a recursive function definition, except that the body comes before the head in the second instance
07:39:40 <wilornel> Hmmm so because we have Plus (S Z) (S Z) r, it's using the second instance definition
07:40:14 <wilornel> is that right?
07:40:18 <c_wraith> yes
07:40:28 <wilornel> oh, byorgey is here!
07:40:43 <wilornel> but how does that translate to r being S (S Z)
07:40:51 <wilornel> recursive function definition?
07:41:14 <wilornel> yeah it's weird if we say that r = (S r), right?
07:41:25 <c_wraith> well, the fundep says that m n -> r
07:41:38 <wilornel> so S( Z) (S Z) -> r
07:41:59 <wilornel> or (S m) n -> (S r)
07:42:02 <c_wraith> yes, that
07:42:11 <wilornel> aaah it's strange when we have two differnent r's
07:42:15 <c_wraith> yeah
07:42:20 <wilornel> Is it (S m) n -> (S r) or (S m) n -> r?
07:42:34 <wilornel> first one right right
07:42:36 <c_wraith> yes
07:42:53 <wilornel> but then that still does not fully explain S (S Z)
07:43:05 <wilornel> I see where Z comes from
07:43:15 <wilornel> (S m ) == (S Z), so m == Z
07:43:20 <c_wraith> No.  Then it goes recursively into the instance
07:43:37 <c_wraith> and matches against Z (S Z) r
07:43:39 <wilornel> you lost me with recursivity
07:43:48 <c_wraith> the second instance has a constraint
07:43:55 <wilornel> yes
07:43:56 <c_wraith> That constraint gets applied when the head matches
07:44:03 <wilornel> the head being Plus?
07:44:07 <wilornel> or m?
07:44:19 <c_wraith> The head being (S m) n (S r)
07:44:27 <wilornel> yes
07:44:34 <wilornel> but how is that recursive
07:44:36 <wilornel> oh wait
07:44:37 <wilornel> wait wait
07:45:02 <c_wraith> The constraint gets applied to those values of m, n, and r
07:45:13 <c_wraith> And the constraint is to the same class, so it's recursive
07:45:33 <wilornel> alright, yes
07:45:48 <wilornel> It's like saying Num a => Num a for simpler typeclasses
07:46:01 <c_wraith> Well, Num a => Num (Foo a)
07:46:05 <c_wraith> But yeah
07:46:14 <wilornel> Alright, and then the matching happens on the right side
07:46:46 <wilornel> So if I have Num (Foo 1), then 1 is Num
07:47:36 <c_wraith> By the way, this isn't just you.  Type-level programming with functional dependencies is basically doing a half-hearted prolog in the type system.  It's very different from writing functions as Haskell terms
07:48:21 <wilornel> It seems almost perpendicular to doing function definitions in terms of diffulty of understanding
07:48:42 <wilornel> I wonder how often do you end up havking to think about these things deeply for each feature in Haskell
07:48:45 <wilornel> or does it get easier?
07:49:23 <c_wraith> Most features in this area are trying to make type-level programming more like Haskell term programming, so there's less to learn. :)
07:49:33 <wilornel> oooooooh wait
07:49:34 <c_wraith> And you're right.  It's just a totally different way of doing things.
07:49:36 <wilornel> I think I get it!
07:50:23 <wilornel> so you said it's recursive so I had to realize there's a base case. I kept thinking that since it's recursive it should go on forever. The base case in this situation is the first instance definition: `instace Plus Z n n`, is taht right?
07:50:41 <c_wraith> yes
07:52:14 <wilornel> so first we match the second definition, and then we match the first one. On matching the second def, we get that m = Z, n = (S Z) and (S r) = r. Then, on matching the second def, we should get n = n, so (S Z) = (S r), which is = r
07:52:28 <wilornel> I still don't see where the first S in _S_ (S Z) comes from
07:53:29 <c_wraith> It comes from the S r in the second definition
07:53:52 <c_wraith> The thing is, when you're working with a fundep, you can see the things on the right side as output.
07:54:01 <wilornel> ok then (S Z) comes from the first definition
07:54:03 <wilornel> hmmmmm
07:54:19 <wilornel> aaaah yes I see
07:54:23 <wilornel> it's a strange way of doing this
07:54:32 <wilornel> and thanks for clarifying that the right hand side is like the output
07:54:39 <c_wraith> yes, it is.  Unless you have a lot of experience with prolog, which I don't. :)
07:55:57 <wilornel> it's interesting that Haskell can achieve this part of another language with an extensin
07:56:09 <c_wraith> It was sort of accidental :)
07:56:25 * hackage threepenny-editors 0.2.0.7 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.7 (PepeIborra)
07:57:17 <wilornel> cool! :) I wonder what else will end up being accidental easy addition and if extending the language will ever stop
07:58:01 <c_wraith> Well, fundeps were added to solve an entirely different problem.
07:58:33 <c_wraith> Then people noticed that they allow you to specify calculating types as the result of other types.
07:58:39 <liste> wilornel: if you're interested in type-level programming, check out Idris (or Agda)
07:59:08 <wilornel> is that what you would use for formal proofs?
07:59:36 <c_wraith> Agda is a proof language.  Idris is more intended as a programming language first
07:59:36 <wilornel> one of the things you'd use for formal proofs*
08:00:31 <wilornel> so Agda is built with Haskell, that's nice
08:00:47 <c_wraith> So is Idris, iirc
08:00:48 <liste> so is Idris
08:01:09 <ggVGc> one day GHC will be written in Idris and we'll be complete
08:01:19 <c_wraith> Well that would be complicated. :)
08:01:46 <wilornel> What's the reason for making Idris when Haskell is there? if Idris is a programming language when Haskell already is
08:02:01 <wilornel> You can't write GHC in Haskell?
08:02:03 <c_wraith> Idris is a full dependently-typed language
08:02:04 <ggVGc> depdendant types afaik
08:02:05 <ggVGc> mainly
08:02:19 <wilornel> fundeps are dependent types, right?
08:02:22 <c_wraith> No
08:02:25 <ggVGc> not really
08:02:25 <wilornel> fundeps are for* dependent typeS*
08:02:25 <liste> wilornel: it's hard to make Haskell fully dependently typed, starting from "scratch" is much cleaner
08:02:41 <c_wraith> Dependent types allow you to specify types that depend on values
08:02:48 <c_wraith> fundeps let you specify types that depend on types
08:02:49 <ggVGc> wilornel: it's one of the pieces of haskell that brings haskell towards being dependently typed
08:03:00 <ggVGc> but I believe haskell will never really have full dependent types
08:03:04 <wilornel> hmmm I see
08:03:09 <c_wraith> ggVGc: They should be in 8.6 or 8.8
08:03:13 <ggVGc> oh
08:03:15 <ggVGc> interesting
08:03:32 <c_wraith> Look for Rich Eisenberg's Dependent Haskell papers.
08:03:42 <wilornel> wow! So Haskell would be complete and no need for Idris?
08:03:46 <liste> I wonder what'll happen with Idris ten?
08:03:50 <liste> then*
08:04:05 <liste> wilornel: well, hardly "complete", I think it would still evolve after that
08:04:08 <c_wraith> But that version of dependent types won't allow lifting functions to the type level.  There's still a long way to go.
08:04:16 <Tuplanolla> Complete the way C++ is complete, wilornel?
08:04:39 <c_wraith> Also, Idris is a strict language.  It's just plain different. :)
08:05:07 <liste> Idris tries to learn from Haskell's mistakes
08:05:26 <c_wraith> Strictness is the mistake. :P
08:05:27 <wilornel> I was being overly irrationally innocently optimstic 
08:05:48 <ggVGc> what are you guys talking about. haskell is already perfect and complete
08:05:49 <wilornel> so we'll throw away Haskell and go with Idris!
08:05:51 <c_wraith> I mean, strictness sesms required for a termination checker.
08:05:53 <c_wraith> *seems
08:06:05 <wilornel> checking if something terminates??
08:06:17 <jchia_1> halting problem?
08:06:26 <c_wraith> Yeah. Idris and Agda have termination checkers.
08:06:39 <liste> wilornel: yeah, dependently-typed languages can be total
08:06:43 <wilornel> I guess it would be possible if your yprogram has a specific shape
08:06:44 <c_wraith> It's part of avoiding some type-level inconsistenties
08:06:58 <c_wraith> Like, Haskell's type system corresponds to an inconsistent logic.
08:07:13 <Tuplanolla> You can give up Turing completeness for some other nice properties, wilornel.
08:07:16 <wilornel> so for some fucntions, you'd get `terminates (my_function) == undetermined` ?
08:07:27 <wilornel> Hmmmm interesting!
08:07:29 <c_wraith> Here's the thing - Turing completeness is not a language feature.
08:07:36 <wilornel> it's a bug?
08:07:39 <c_wraith> Yes
08:07:43 <wilornel> WHAT
08:07:53 <wilornel> side-effect?
08:07:53 <c_wraith> The only thing Turing completeness adds is the ability to write infinite loops.
08:08:08 <c_wraith> non-productive ones, that is
08:08:38 <c_wraith> Any algorithm you want to write doesn't require Turing completeness, because it wants to be productive.
08:08:44 <wilornel> That's interesting. Any good readings on this? I feel like this would be some nice mind bending
08:08:53 <wilornel> what do you mean?
08:09:06 <wilornel> It want to be somewhat optimized in runtime/space complexity / structure?
08:09:17 <wilornel> It wants to be self-contained, and not required a variable amountof memory?
08:09:24 <c_wraith> None of the above.
08:09:28 <wilornel> :(
08:09:35 <c_wraith> I just mean that if you're running a program, you want it to do something.
08:09:40 <wilornel> Tuplanolla: any good readings?
08:09:49 <wilornel> c_wraith: yes, and that's what the turing machine does as well
08:09:54 <Tuplanolla> Do you accept tangentially related, wilornel?
08:09:55 <wilornel> You mean you want it to do a specific thing?
08:10:00 <wilornel> Tuplanolla: yes!
08:10:06 <Tuplanolla> @google software foundations book
08:10:08 <lambdabot> https://www.cis.upenn.edu/~bcpierce/sf/
08:10:23 <wilornel> Thank you!
08:10:24 <liste> Tuplanolla++
08:10:43 <wilornel> c_wraith++
08:10:47 <wilornel> Tuplanolla++
08:10:55 <wilornel> Anything keeps count?
08:11:02 <Tuplanolla> @bot
08:11:03 <lambdabot> :)
08:11:27 <liste> Tuplanolla: mind if I PM you on a thing related to Haskell but specific to you?
08:11:29 <wilornel> And c_wrait, so does that mean that you can structure programs to not have a variable memory size, which is what the turing machine has?
08:11:51 <c_wraith> wilornel: I mean that you want from a program is for it to produce results.
08:12:40 <wilornel> Hmmm and the turing machine is not specifically designed for this. It's designed to compute and at some point stop?
08:12:50 <Tuplanolla> Ask me via email if you can email me first, liste.
08:13:07 <c_wraith> wilornel: the whole point of the turing machine was that you can write programs that you can't tell if they terminate or not.
08:13:09 <wilornel> That was good IRC etiquette I thought
08:13:09 <liste> Tuplanolla: OK
08:13:18 <c_wraith> wilornel: but all programs you *want* to write do terminate.
08:13:44 <int-e> especially servers
08:13:50 <c_wraith> wilornel: (or equivalently, eventually perform IO, even if the process keeps running)
08:14:19 <wilornel> right, so you want to give up turing completeness in order to always know that it will terminate at some point
08:14:48 <c_wraith> Yes.  The problem, of course, is that termination proofs can be *hard*.
08:15:14 <int-e> Also, termination is quite overrated... the fact that a program does terminate still doesn't tell you when that will happen.
08:15:25 <c_wraith> That's also true.
08:16:06 <Tuplanolla> This banishment of Turing completeness tends to lead to useful results when applied in other computational contexts too, wilornel.
08:16:21 <c_wraith> In other words, requiring termination proofs often doesn't prove anything actually useful about the code, and adds a bunch of effort to writing it
08:16:40 <c_wraith> So..  This is why most languages accept Turing completeness.
08:16:52 <Tuplanolla> @google langsec babel
08:16:53 <c_wraith> It might be a bug, but it's easier to work with the bug than to fix it. :)
08:16:53 <lambdabot> http://www.cs.dartmouth.edu/~sergey/langsec/occupy/
08:16:54 <lambdabot> Title: Occupy Babel!
08:17:11 <wilornel> I see! Awesome
08:19:28 <wilornel> This page reminds me of something I had in mind before. Since Haskell is lazily evaluated, I think that in the representation that Haskell keeps, it probably has a sort of tree representation of all the functions calling eachother. Are there any visualizers for your variables in your code?
08:20:09 <wilornel> say `let x = (* 2); y = x 3`, then you would visualize y and it would show you that y is in fact (* 2) applied onto 3
08:20:26 <c_wraith> there is a package that introspects the runtime representation and produces DOT graphs
08:20:29 <wilornel> or at least print it out somehow
08:20:32 <ertes> termination does prove one useful thing: your program will always produce in one way or another
08:20:38 <wilornel> cool!
08:20:40 <ertes> that eliminates some bugs
08:21:05 <c_wraith> I can never remember the package's name, though
08:21:34 <ertes> but it comes at a price: you will not be filtering an infinite list
08:22:08 <wilornel> but you can filter a list of variable size, still, right?
08:22:17 <c_wraith> ertes: unless you can write a proof that an infinite subset of elements in the list satisfy the predicate. :P
08:25:22 <monochrom> Is that Hat? Is it Hood?
08:26:29 <c_wraith> No, it's a package kind of like vacuum
08:26:29 <ClaudiusMaximus> !hackage vacuum-graphviz -- c_wraith this?
08:26:38 <c_wraith> Except it can introspect thunks, too
08:27:06 <c_wraith> @hackage ghc-vis
08:27:06 <lambdabot> http://hackage.haskell.org/package/ghc-vis
08:27:07 <ClaudiusMaximus> http://hackage.haskell.org/package/ghc-heap-view perhaps
08:27:09 <c_wraith> I think it's that one
08:27:27 <c_wraith> which doesn't appear to have been updated for ghc 8
08:28:03 <c_wraith> and ghc-vis depends on ghc-heap-view, so yeah
08:33:38 <wilornel> awesome! that might make visualizing algorithm much easier now that I think about it
08:33:57 <wilornel> although you need to understand the graphs
08:34:22 <c_wraith> Yeah, it's not a magic bullet - but it's still really nice information
08:34:44 <wilornel> there's no magic bullet eh?
08:35:01 <wilornel> Would haskell be one? I do feel like it could be much more productive than procedural programming
08:35:05 <c_wraith> Only one, and it was used to assassinate Kennedy.
08:35:13 <wilornel> D:
08:35:48 <wilornel> ah we said magic bullet, I thought we were talking about silver bullet. Recently read about it in Mythical Man-Month
08:36:07 <c_wraith> Well, they have the same use in metaphor.
08:36:15 <c_wraith> They both do the impossible.
08:36:26 * hackage th-abstraction 0.1.1.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.1.1.0 (EricMertens)
08:36:44 <wilornel> ah yes, although software silver bullets don't assassinate any Kennedies
08:38:52 <c_wraith> jchia_1: did that approach work out?
08:43:26 * hackage vty 5.15.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.15.1 (JonathanDaugherty)
08:46:50 <ertes> c_wraith: have fun doing that =)
08:47:35 <ertes> "this filter is actually productive" is among the most horribly inconvenient proofs to write in a CH setting
08:49:30 <c_wraith> ertes: I did say proofs of productivity could be really hard. :)
08:50:34 <ertes> ah, i didn't read the whole backlog =)
08:51:21 <Rotaerk> hmm how should something that's allowed by the type system but is logically impossible be reported?
08:52:11 <EvanR> an exception?
08:52:34 <Rotaerk> I could, I suppose, was also considering assertion
08:52:52 <EvanR> if anything not like this
08:52:56 <Rotaerk> e.g. processing a result type that's A | B | C, but it *can't* be A
08:52:59 <EvanR> ghc: undefined
08:53:11 <ertes> Rotaerk: "segmentation fault"
08:53:33 <EvanR> Rotaerk: well, this is pretty fragile.... consider using a different result type
08:53:37 <ertes> that's how C does it, and everybody seems to be fine with that
08:53:44 <Rotaerk> EvanR, it's a parser
08:54:01 <Rotaerk> it can either fail, succeed, or partially parse
08:54:12 <Rotaerk> but in this case, there's no way the parser can fail, it will either succeed or partial
08:54:13 <LKoen> *** Exception: nameOfTheFunction: impossible value A
08:54:24 <ertes> "heartbleed a security issue?  nah, that's just our version of throwing an exception"
08:54:29 <EvanR> Rotaerk: so whats the argument for this?
08:54:45 <EvanR> seems like parsers can definitely fail no matter what
08:55:43 <Rotaerk> in this case, I'm doing:  ABS.takeTill (`BS.elem` "\CR\LF") <* (pCR <* optional pLF <|> pLF)
08:56:08 <EvanR> ok, so anything at all satisfies the parser?
08:56:26 <Rotaerk> it will parse everything until it encounters \CR or \LF; if it never encounters them before the end of input, then it will return a Partial
08:56:45 <Rotaerk> so either Succeed or Partial
08:56:59 <Rotaerk> s/Succeed/Done/
08:57:39 <Rotaerk> I could just ... not handle the Fail case
08:57:42 <EvanR> what would be interesting is to somehow attach a sentry to the parser code that says you verified its cant failness. you are allowed to ignore the failure case as long as you dont change the parser code
08:59:02 <EvanR> you can wrap the parser action and the result type in another set of types specifically for parsers than cant fail
08:59:16 <EvanR> but the question is how to make sure you only use it with cant fail parsers
08:59:42 <EvanR> its sort of the same thing as, only use div with non zero numbers
08:59:47 <Rotaerk> yea
09:00:32 <Rotaerk> I think I'm not going to try to solve THAT problem here, i.e. of adjusting the type system to match the logically possible results
09:00:41 <Rotaerk> since that's kind of a larger problem...
09:00:56 <EvanR> do handle the case so the warning goes away, and throw an exception
09:01:02 <Rotaerk> k
09:01:16 <EvanR> and make an extensive comment about it in the code, and hope it does become wrong ;)
09:01:21 <EvanR> doesnt
09:01:22 <Rotaerk> heh
09:02:12 <EvanR> ah you know what
09:02:15 <Rotaerk> hmm I guess assert throws an AssertionFailed exception when its input is false
09:02:24 <Rotaerk> and that's what this really is...
09:02:29 <Rotaerk> an assertion that this should never happen
09:02:48 <EvanR> you could make an entirely new parser lib based on cant fail parsers, but it would limit the kinds of cant fail parsers you could write
09:03:19 <EvanR> where is AssertionFailed?
09:03:32 <Rotaerk> Control.Exception
09:03:35 <EvanR> ah
09:03:39 <Rotaerk> the main downside to that is that assertions can be disabled
09:03:47 <Rotaerk> and I'm not sure I'd want this check to be disabled
09:03:53 <EvanR> just directly throw the assertion failed exception
09:03:57 <Rotaerk> true
09:04:19 <EvanR> or whatever exception you want. i have an exception type for this called Bug
09:05:15 <EvanR> bug "File.hs" 3423 "You dolt! (explanation of why this shouldnt happen)"
09:05:24 <Rotaerk> :P
09:07:18 <EvanR> if the only conceivable way your thing can crash is with messages about bugs you already thought of... thats pretty good
09:07:34 <EvanR> ignoring out-of-memory
09:10:19 <wilornel> hmmm... I am trying to fix an example that was labelled as bad practice in the haskell book I am reading
09:10:51 <wilornel> They say not to have a defaultValue function for your types. I am trying to make a defaultValue :: (Numberish a) -> a for my types that are instances of Numberish
09:11:10 <wilornel> How could I have that function defaultValue return different values depending on the type it is casted to?
09:11:19 <wilornel> defaultNumber :: Age = Age 65?
09:11:34 <wilornel> of course that does not work 
09:11:49 <srhb> wilornel: First off, there is no casting. Secondly, it sounds like you want Numberish a => a
09:12:12 <srhb> wilornel: Thirdly, that's like the Default typeclass.
09:12:13 <wilornel> ah, sorry yes
09:12:29 <wilornel> defaultValue :: (Numberish a) => a is what I have
09:12:32 <EvanR> the bad practice i think here is the Default-like typeclass
09:12:52 <wilornel> and this is just for the sake of trying things out, not necessarily looking to use this in the proper manner
09:12:53 <EvanR> or the Default-like behavior
09:13:09 <wilornel> yes the deafult-like typeclass is bad practice as they said
09:13:15 <wilornel> oh no wait
09:13:34 <wilornel> "Don't use typeclasses to define default values." "-- Seriously. Haskell Ninjas will find you""-- and replace your toothpaste with muddy chalk."
09:13:46 <EvanR> agreed
09:14:13 <wilornel> and so I could try to define defaultValue outside of the typeclass
09:14:28 <wilornel> not that that's good but just wondering how that would work out
09:14:38 <srhb> wilornel: It does not, really.
09:14:52 <wilornel> Ah, alright
09:14:56 <monochrom> I thought toothpaste was muddy chalk
09:14:58 <srhb> wilornel: At least not the way you are imagining it. The way to overload a name like that with multiple values is exactly through type classes, which is the no-no.
09:15:05 <EvanR> especially default numbers? weird
09:15:22 <EvanR> there are special zero and one like values for numbers with special properties, but they arent really defaults
09:15:25 <wilornel> alright, then I shall look at the previous thing that was bad. They didn't say why it was bad
09:15:33 <glguy> You know, for those times when any number will do
09:16:43 <monochrom> Default value without type class would be to always pass default values as parameters.
09:17:23 <EvanR> formatTime defaultTimeLocale "%Y-%M-%d" today
09:17:49 <EvanR> (... defaultTimeLocale... what is it...)
09:17:56 <wilornel> alright, I'm not quite sure why they say that the code was silly
09:18:01 <glguy> It's the default TimeLocale
09:18:06 <EvanR> "the" ?
09:18:15 <glguy> yeah
09:18:16 <wilornel> HAskell programming from First Principles section 6.11 
09:18:20 <EvanR> its per system right
09:18:27 <wilornel> the first block of code
09:18:34 <glguy> EvanR: No, I don't think so
09:18:37 <EvanR> o_O
09:18:56 <EvanR> default time locale is US english everywhere?
09:19:04 <glguy> yeah
09:19:09 <EvanR> mind blown
09:19:27 <glguy> If you want actual localized time , you have to generate a TimeLocale using whatever criteria you might want
09:19:56 <glguy> that would go into another package to extract it from various places on various operating systems, etc
09:20:05 <monochrom> Like the random number is 4 everywhere
09:20:11 <wilornel> alright, good day/night/evening/morning/lunch/dinner/breakfast #haskell!
09:20:40 <EvanR> default time of day
09:20:44 <rntz> glguy: so System.Locale provides "the ability to adapt to local conventions" - except that it doesn't actually do the thing that tells you want local conventions are? :P
09:20:59 <rntz> s/you want/you what/
09:21:00 <\u> Anyone use Arch Linux community/ghc-8.0.1 Can you share your output of  `ar tv /usr/lib/ghc-8.0.1/base-4.9.0.0/libHSbase-4.9.0.0.a | grep Weak`
09:21:57 <\u> I wonder why there are so many Weak*.o called Weak__1.o Weak__2.o Weak__3.o ... However, what I obtained by building GHC HEAD only contains two Weak.o (duplicated name)
09:22:10 <monochrom> -fsplit-objs ?
09:23:15 <glguy> rntz: That's a different package
09:23:26 * hackage prettyprinter 0.1, prettyprinter-ansi-terminal 0.1, prettyprinter-compat-annotated-wl-pprint 0.1, prettyprinter-compat-wl-pprint 1, prettyprinter-compat-ansi-wl-pprint 0.1 (quchen): https://qbin.io/zlrr5sy
09:23:30 <glguy> rntz: Data.Time.Format.TimeLocale is being discussed
09:24:36 <quchen> ?tell merijn Uploaded a pre-release, search for »prettyprinter«. Your nagging was successful. Pity Hackage displays the dependencies wrong (or has an old build system).
09:24:36 <lambdabot> Consider it noted.
09:24:40 <quchen> cocreature: ^
09:24:57 <cocreature> quchen: nice!
09:25:13 <quchen> At least you can now put it into your .cabal files.
09:25:18 <quchen> And have some sense of stability :-)
09:25:40 <quchen> I’ll put it on Stackage when I’m even more certain about everything.
09:25:52 <\u> monochrom: Yes! thx
09:25:58 <cocreature> quchen: btw, what kind of trouble am I getting myself into by using the internal Text constructor to trick prettyprinter into thinking that a text has a different width than it actually has?
09:26:30 <quchen> cocreature: I don’t think that might cause issues.
09:26:46 <cocreature> quchen: great so I can actually continue being evil and do that :)
09:27:03 <quchen> cocreature: The length field is just a cache of (Text.length t).
09:27:13 <quchen> The layouters use that to determine whether to insert line breaks etc.
09:27:36 <quchen> Lengthening the value is kind of like adding trailing whitespace to the Text, I guess.
09:27:37 <cocreature> I was wondering if the cache is ever recalculated and thereby me overwriting it could lead to inconsistencies
09:27:48 <cocreature> I was shortening it
09:27:57 <quchen> Nope, it‘s only ever filled by »unsafeText«.
09:28:04 <quchen> At least it should! :-)
09:28:17 <cocreature> so far everything seems to work just like I expect it to :)
09:28:38 <quchen> I’d be surprised if this broke things, or did something unexpected.
09:28:40 <cocreature> quchen: it would be nice if you could upload docs to hackage
09:28:56 <quchen> Arrr. We still have to do this manually eh
09:29:19 <cocreature> I mean you can probably wait for the builder and if you’re lucky at some point it will generate them
09:29:33 <cocreature> but just uploading them with your package is more convenient for users
09:29:40 <EvanR> we dont even have markovs principle for hackage docs
09:31:26 * hackage saltine 0.0.0.5 - Cryptography that's easy to digest (NaCl/libsodium bindings).  https://hackage.haskell.org/package/saltine-0.0.0.5 (amx)
09:31:40 <cocreature> huh, I thought saltine was dead
09:33:26 <amx> what gave you that impression?
09:34:20 <cocreature> amx: oh didn’t know you where here. the last time I looked, the readme mentioned that it’s an early release and it hadn’t received an update in quite some time so I thought you abandoned it. happy to see that this is not the case!
09:37:50 <quchen> cocreature: There you go. http://hackage.haskell.org/package/prettyprinter-0.1
09:37:52 <amx> I took over from tel end of last year and just now had some time to get a bit of work done on it. Since I'm using it in production it will stick with me for a while.
09:37:57 <quchen> Also: DAMN THIS IS ANNOYING
09:38:11 <quchen> 4 packages to go
09:38:42 <cocreature> quchen: the fact that you need to use cabal sandboxes and not stack or cabal new-build makes it even more annoying
09:39:29 <cocreature> oh have you tried to use stack? the  links are broken :)
09:41:11 <quchen> I’d rather gauge my eyes out than use Cabal to build this.
09:41:20 <cocreature> fair enough
09:41:20 <quchen> cabal configure -- error, package not found
09:42:34 <quchen> cocreature: I’ll use the »it’s just a pre-release for you and merijn« joker ;-)
09:43:15 <cocreature> quchen: heh, I accept that. thank for all the work you put into this, I really find it a lot more pleasant than the other libs
09:43:20 <quchen> Anyway, I’m off for now. Good luck with your text hack ;-)
09:43:36 <quchen> And: if you give me a compelling use case for your short-text I might add it
09:43:47 <quchen> Unlike the other maintainers, I’m observably alive ;-)
09:46:37 <Rotaerk> glguy, https://ptpb.pw/jlfb/hs
09:46:58 <Rotaerk> particularly pointing out the stuff starting at line 105
09:48:12 <Rotaerk> (I'll move that partial-pipe stuff out of the TCP module eventually... probably reusable)
09:48:54 <glguy> ah, cool
09:50:11 <glguy> Rotaerk: watch out with Network.Simple.TCP, it doesn't handle connecting to things with multiple results from DNS correctly
09:50:24 <glguy> Rotaerk: this can cause problems connecting on systems with ipv4/ipv6
09:50:47 <Rotaerk> hmm what do you suggest I use instead?
09:52:13 <Rotaerk> pipes generally exist to await input values and yield output values, all in one pipe...  partialPipe allows you to do this in multiple steps, each step converting *part* of the input into output
09:52:33 <Rotaerk> and by the time each of your steps is complete, all the input should've been consumed and only output values remain
09:52:48 <Rotaerk> so it ends up being kind of a case-expression for pipes
09:52:53 <glguy> Rotaerk: My hookup package handles this and TLS and SOCKS, or you can use network package directly, I don't recommend it, but the connection package is another choice
09:53:08 <Rotaerk> k, thanks
09:54:10 <cocreature> glguy: what’s your problem with the connection package? the API seemed rather nice the last time I looked at it iirc
09:54:51 <glguy> cocreature: It uses the tls package
09:54:58 <cocreature> glguy: so?
09:55:17 <glguy> and has had bugs in its recv function, I don't know if they're all fixed
09:55:25 <cocreature> fair enough
09:55:57 <glguy> cocreature: I don't trust the tls package to implement TLS, there are known isues with how it validates certificates
09:56:02 <glguy> it pulls in a dependency on the foundation package
09:56:17 <cocreature> huh I didn’t know it had problems with certificate validation
09:56:31 <cocreature> I guess I should look into this when I use it the next time
09:56:32 <Clint> still i'd take it over openssl any day
09:56:41 <glguy> I certainly wouldn't
09:56:58 <Clint> that seems evident
10:03:19 <glguy> it didn't handle timeouts as well as openssl, the underlying crypto library has a history of segfaults due to unsafePerformIO usage for passing around random number sources
10:04:10 <c_wraith> The problem is that tls is so complex that it should basically never be implemented.
10:04:24 <c_wraith> Sadly, that's not the world we live in.
10:04:29 <ongy> I wonder if 1.3 will make that better or worse
10:21:48 <cocreature> ongy: given that you can’t get away with only supporting 1.3 anytime soon, it can only get worse
10:22:55 * hackage etc 0.2.0.0 - Declarative configuration spec for Haskell projects  https://hackage.haskell.org/package/etc-0.2.0.0 (RomanGonzalez)
10:24:59 <glguy> Yeah, in the short term 1.3 adds new code paths that didn't exist before
10:26:01 <glguy> We just need a year or 20 so we can drop 1.2 and below :)
10:26:23 <c_wraith> By then we'll need to support 1.8 though
10:26:42 <glguy> \o/
10:26:53 <\u> Mac OS X users, does `libtool -static -o a.a -L$dir_of_libHSbase -lHSbase-4.9.0.0` retain all .o files of the same name (e.g. Weak__4.o Weak.o)?
10:30:23 <glguy> \u: here's some output for libtool -static -o a.a -L/Users/emertens/Tools/ghc-8.0.2/lib/ghc-8.0.2/base-4.9.1.0 -lHSbase-4.9.1.0 > libtool-output.txt 2>&1   and    nm a.a > nm-output.txt
10:30:33 <glguy> https://glguy.net/libtool-output/
10:32:53 <\u> Thx! libtool does retain all object files. I am trying to implement -staticlib for non iOS/Darwin/Mac OS X...
10:35:48 <\u> Weak__4.o occurs in libHSbase-4.9.0.0 multiple times , but I cannot find an option for GNU ar to extract all of them
11:13:31 <Boarders> If I do something like data Nat = zero | succ Nat then (roughly) there is a functor F: Type ->Type where X-> * \coprod X and the natural numbers is the largest fixed point of this functor
11:13:40 <Boarders> (so really is the natural numbers with infinity but whatever)
11:14:04 <Boarders> what if I do data Fun  = val (Fun -> Fun) 
11:14:12 <Boarders> what is the corresponding functor 
11:14:29 <Boarders> since X--> X^X is not a functor as far as I can tell
11:14:33 <EvanR> data Nat = Z | S Nat has all the natural numbers, an infinite natural number, and many bottomy elements that do not correspond to any number
11:14:55 * hackage universum 0.4.2 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-0.4.2 (gromak)
11:15:13 <zachk> EvanR, how do the nat's have many bottoms?
11:15:44 <EvanR> Z, S ⟂, S (S ⟂), S (S (S ⟂ ))
11:15:48 <Boarders> I am ignoring bottom
11:15:55 <Boarders> or bottom(s)
11:16:14 <zachk> EvanR, my unicode is broken, are you taking succ of bottom?
11:16:19 <EvanR> yes
11:16:40 <EvanR> S Z, S ⟂
11:16:45 <EvanR> fix S
11:18:02 <EvanR> Boarders: Fun = Fun (Fun -> Fun) isnt the right kind
11:18:02 <Boarders> you are really doing list on a unit type for Nat so it makes sense you have succ _|_
11:18:30 <Boarders> hmm ghc doesn't complain when I write it
11:18:39 <EvanR> i mean for a Functor instance
11:19:34 <Boarders> so if I write that do I just think of it as giving me a type Fun where F \iso (Fun -> Fun)
11:20:08 <Boarders> err Fun \iso (Fun -> Fun)
11:20:09 <EvanR> it looks like the type of lambda calculus programs
11:20:12 <monochrom> Boarders: X ≌ X^X is a model of untyped lambda calculus.
11:20:17 <Boarders> yeah that is what I was trying t write
11:20:31 <Boarders> this is abstraction and you can add application 
11:20:41 <EvanR> you already have it
11:20:54 <Boarders> have what?
11:21:04 <EvanR> newtype Fun = MkFun { apply :: Fun -> Fun }
11:21:20 <EvanR> f `apply` g
11:21:27 <monochrom> It is also true that X -> X^X is not quite a functor because you have an X in the contravariant position.
11:22:10 <Boarders> I think I was just caught up on a story about data being short hand for finding terminal F-coalgebras by taking fixed points
11:22:29 <Boarders> and so thought it always accompanied a functor of some sort
11:23:01 <Boarders> but that is probably putting the cart before the horse
11:24:38 <monochrom> That story cannot be complete. It cannot possibly cover data QuantitativeEasing = Q (QuantitativeEasing -> Money)
11:25:18 <Boarders> I thought that stuff was attached to a contravariant functor Type^op ->Type
11:25:48 <Boarders> though what the hell an F-algebra means makes it clear enough that I am being stupid
11:26:31 <Boarders> but yeah that all makes sense, thanks
11:26:35 <heath> i'm wanting more answers from the haskell community, so far i've mostly received answers from the erlang/elixir crowd
11:26:47 <EvanR> i know what it means i heard it enough as a university intro math assistant
11:26:50 <heath> if you have time and are open to responding, here are the questions: https://gist.github.com/heath/858a321b5fc96d3011d9b6ea4fca3cb9
11:27:55 <heath> if you think this is a pseudoscience or a wasted effort, i would love an explanation 
11:28:19 <EvanR> heath: the difference between the erlang way and haskell is so vast...
11:28:24 <EvanR> its really hard to even compare
11:28:45 <zachk> heath have you tried cloud haskell yet? 
11:28:46 <EvanR> i.e. "individual self contained units of logic" exists in both, and dont even remotely refer to the same thing
11:29:41 <EvanR> an abstract data type, properly implemented and proven, is a possibly small self contained unit of logic
11:29:51 <EvanR> and you dont need to keep pushing it
11:31:06 <EvanR> the wheels do not come off the Text type or the Queue type and require a hotcode reload
11:31:55 * hackage VKHS 1.7.3 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-1.7.3 (SergeyMironov)
11:32:03 <heath> zachk: indeed i have. one could start comparing runtimes once you start comparing CH and erlang, but i'm not wanting to go there right now. neither system is perfect in reality
11:32:26 <heath> the point of this is that i don't hear many haskell folk talking about this sort of thing, and i was hoping to gather a few responses
11:32:36 <EvanR> CH is not really a thing whereas erlang installations have been for a while
11:32:52 <EvanR> its a big experiment
11:32:59 <zachk> I tried elixir the other year, it was decent, debugging my code turned into me peppering it with print statements, and it was basically a "type" error in one of the messages being passed
11:33:24 <heath> i refer to the comparison as "a proven runtime vs provable types" :)
11:33:51 <heath> i've been reminded this isn't entirely accurate since haskell is used in production as well
11:33:57 <EvanR> heath: in my current project im making a lot of use of the tree of processes and retrying, using async. 
11:34:08 <EvanR> im a lot more comfortable doing that with types than without
11:35:34 <monochrom> There is going to be a self-selection phenomenon. Erlang people will tell you "I don't need types" and Haskell people will tell you "I need types". Consider why someone became an Erlang people or a Haskell people in the first place.
11:36:18 <EvanR> heath: check it out... high score saving may seem to fail, but while the game continues normally, tries to recover functionality goo.gl/AWux0wcontent_copyCopy short URL
11:36:23 <EvanR> goo.gl/AWux0wcontent_copyCopy short URL
11:36:27 <EvanR> wtf
11:36:33 <EvanR> https://goo.gl/AWux0w
11:36:37 <monochrom> I am certainly one of those who looked at Prolog and then looked at Haskell and settled with Haskell on the slight pretext of "but I want types".
11:37:30 <EvanR> heath: the code each component of this thing is in a separate module
11:39:17 <EvanR> since youve been asking the same question for days, i feel like youre not going to get anywhere unless you try haskell
11:40:08 <zachk> EvanR, are you using CH?
11:40:12 <EvanR> you can always bring the sort of reasoning that makes your haskell code work back to erlang and elixir, where you need it even more since lack of type checking
11:40:18 <EvanR> zachk: no
11:43:15 <heath> EvanR: i am using haskell :)
11:43:47 <EvanR> sweet preaching to the choir
11:44:33 <monochrom> It is still fair to ask other people "what do you do for reliability".
11:44:42 <int-e> what's that CH thing?
11:44:50 <monochrom> The problem is do they all agree on what it means?
11:44:58 <EvanR> cloud haskell, sorry for abbrieviating it gratuitously
11:45:45 <heath> that's true, nancy goes into the definitions in https://mitpress.mit.edu/books/engineering-safer-world and why, even, she looked back to methods from ww2 
11:45:55 <int-e> (I *think* earlier CH stood for Curry-Howard... google would probably suggest Switzerland. Hence the question.)
11:46:08 <EvanR> continous hypothesis
11:46:15 <EvanR> er... continuum hypothesis
11:50:05 <heath> thanks for responding. i won't continue asking for feedback (i'm always open to discussing it though)
11:59:50 <heath> EvanR: what are some reasons saving high scores fail in that particular project?
12:01:06 <heath> (ignore grammatical blunder please)
12:01:55 * hackage mywatch 0.3.0 - Web application to view and kill MySQL queries  https://hackage.haskell.org/package/mywatch-0.3.0 (ip1981)
12:03:51 <zachk> heath: it looks like it doesn't have permission yet to write to the file, probably the file is still opened from something else
12:04:26 * hackage shade 0.1.1.1 - A control structure used to combine heterogenous types with delayed effects.  https://hackage.haskell.org/package/shade-0.1.1.1 (fredefox)
12:06:14 <heath> int-e: CH == cloud haskell
12:06:26 <test> 91.218.247.104
12:06:40 <test> http://breachforums.com/
12:07:10 <Guest5481> hi
12:07:18 <Guest5481> http://breachforums.com/
12:08:32 --- mode: ChanServ set +q *!*@*/ip.216.66.6.76
12:09:23 <nshepperd> instance Applicative (State Endo s) where { mempty = Strict.unsafeHex }
12:09:31 <nshepperd> ^^ haskell written by a neural network :)
12:09:48 <jle`> looks like something i just wrote
12:09:59 <jle`> which makes sense, since i myself am a neural net
12:10:24 <heath> nshepperd: nice
12:12:30 <nshepperd> i think my library needs a function called unsafeHex
12:14:05 <dmj`>  /msg jle` you see that ghcjs comment
12:14:19 <jle`> i did :o
12:14:28 <jle`> it seems like it's compiling now, i just needed to stack clean
12:14:31 <jle`> ;_;
12:14:32 <dmj`> woops :o
12:14:37 <jle`> not sure what happened
12:14:38 <dmj`> pm fail
12:14:51 <dmj`> ah, nice
12:20:41 <Uncripted> Hello
12:22:41 <zachk> Uncripted, hello
12:22:44 <lambdabot> Hello.
12:22:55 <hpc> bwuh?
12:24:36 <Uncripted> New to IRC. Just trying out some channels.
12:25:25 <lyxia> lambdabot... speaks?
12:30:44 <buglebudabey> if i want to store a pretty large adjacency table / tables, what structure would be appropriate to store it in?
12:31:21 <cocreature> kuribas: sparse or dense?
12:31:25 <Athas> buglebudabey: if sparse, then a set.
12:32:10 <buglebudabey> Athas how does that work with it being multidimensional and all
12:32:34 <Athas> buglebudabey: the set element type can be an arbitrary type that is an instance of Ord.
12:33:16 <buglebudabey> So would I have a list of sets representing a particular node's set of neighbors, or a set of sets?
12:33:19 <buglebudabey> Athas ^
12:33:21 <jle`> you can store a set of tuples
12:33:35 <jle`> or a map of lists
12:33:47 <buglebudabey> set of tuples seems like a good option
12:34:06 <jle`> it does really depend on the things you want to do with it too of course
12:34:59 <buglebudabey> jle` it's to compile a local set of wikipedia articles and the pages they refer to within a few degrees of separation
12:35:25 <buglebudabey> like the first 2 level of all pages 'Haskell' links to
12:35:50 <jle`> i might do a map of lists then maybe
12:36:03 <buglebudabey> what's the reason behind that?
12:36:19 <jle`> since given an origin article, you can look up all of the ones it links to at the same time
12:36:28 <jle`> for a set of tuples, you'd have to filter the set
12:36:43 <jle`> and traverse the set's structure
12:36:49 <kuribas> cocreature: ?
12:37:09 <cocreature> kuribas: eh sorry wrong nick
12:37:14 <kuribas> np :)
12:37:15 <buglebudabey> jle` is that still good for if I wanted to do a page-rank sort of algorithm where i find articles based on how many link to it?
12:38:15 <jle`> hm, not sure exactly.  is page-rank an eigenvalue problem?
12:38:37 <jle`> i know it'd be much easier to "square" the map-of-lists adjacency matrix
12:38:42 <buglebudabey> jle` i haven't looked into yet to be honest although i do know it uses some linear algebra
12:39:09 <jle`> it'd probably be much faster to square :: Map k [k] -> Map k [k], than Set (k,k) -> Set (k,k)
12:39:24 <buglebudabey> noted
12:39:58 <buglebudabey> and k can be an Id :: Int with no problem right, and I can look up the article based on the id
12:40:14 <buglebudabey> would that lookup also be good as a map or as a set
12:40:22 <buglebudabey> jle` ^
12:40:43 <jle`> yeah, if you have k ~ Int, you can also use IntMap for some optimized implementations
12:41:14 <buglebudabey> sweet, thank you
12:41:56 <jle`> np
12:42:14 <buglebudabey> jle` does intmap only work for Map Int Int or could I use it for the Map Int [Int] as well?
12:42:27 <nshepperd_> Page rank is an eigenvalue thing, yeah. It's a fixed point of everyone's​ reputation being proportional to the total reputation of things that link to them. Something like that
12:43:02 <jle`> buglebudabey: you can use IntMap [Int]
12:43:13 <buglebudabey> sweet
12:43:20 <buglebudabey> yeah gotta look more into page rank
12:43:42 <Tuplanolla> Why not `IntMap IntSet`?
12:43:53 <buglebudabey> it could be too complicated for something like this
12:44:03 <jle`> hm yeah, a map of sets makes more sense
12:44:19 <jle`> buglebudabey: it'd actually be much simpler
12:44:37 <jle`> since squaring a Map k [k] you'd have to be careful to preserve uniqueness
12:44:44 <jle`> but not for Map k (Set k)
12:45:12 <buglebudabey> very cool, i would have taken a while to figure that out on my own
12:45:13 <buglebudabey> thanks guys
12:45:53 <jle`> np
12:46:04 <jle`> if you want to do pagerank, you also have to assign a weight to each edge, though
12:46:16 <jle`> so you might end up doing `IntMap (IntMap Double)`, heh
12:47:06 <buglebudabey> jle` is the double for squaring or something?
12:47:14 <jle`> not sure how ideal that is for performance though for the operations pagerank requires
12:47:22 <jle`> the double is for the weight of each edge
12:47:35 <buglebudabey> ah ok
12:51:25 <zachk> buglebudabey, I am currently starting to work/think on a similar project, and I am going to go with a graph database like neo4j most likely
12:51:42 <zachk> though orientDB is 10x faster in some benchmarks
12:52:25 <buglebudabey> zachk interesting, if I wanted to look for libraries like that myself, would graph database be the way to search for it? also i'm guessing those are haskell packages right
12:53:11 <monadicDuck> has anyone built an RNN in haskell that wouldn't mind sharing their repo link :)
12:54:01 <zachk> no they are databases like mysql or oracle, but optimized for storing graph's natively, they have their own modified sql like query languages usually
12:54:05 <AWizzArd> How quickly would an experienced Haskeller know what  (fmap . fmap) sum Just [10, 20, 30]   returns, without using a computer?
12:54:21 <zachk> though supposedly you can put apache tinkerpop over most of them and talk to them with something called gremlin
12:54:37 <zachk> haskell has neo4j and gremlin api bindings in hackage
12:54:50 <Tuplanolla> It's a bit tricky due to the `(a ->)` instance, AWizzArd.
12:54:59 <zachk> neo4j's query language is something called cypher, and it seems pretty interesting so far
12:55:01 <jle`> monadicDuck: there's grenade
12:55:05 <jle`> and i've made a few
12:55:18 <jle`> AWizzArd: well, it probably wouldn't take too long
12:55:30 <jle`> AWizzArd: but they would still get angry if they saw it used in a codebase
12:55:37 <jle`> since it's basically obfuscated code
12:55:56 <buglebudabey> zachk ah ok, what's the support like for orientDB?
12:55:58 <jle`> de-obfuscating code can be a mechanical process if you're familiar with the mechanics
12:56:13 <zachk> no idea, I have mostly been focusing on neo4j 
12:56:21 <buglebudabey> zachk and would performing operations on the graph for page rank be easy with something like neo4j
12:56:32 <AWizzArd> jle`: how would you parse this, without the help of a repl?
12:56:43 <jle`> AWizzArd: the same way you parse anything else in haskell
12:56:46 <jle`> by expanding the definitions
12:56:50 <AWizzArd> I can’t look at it and say „Ah of course, it’s clear whats going on here”.
12:56:52 <zachk> I was just looking that up and it looks like you need to use something outside of most graph databases to do that
12:57:01 <jle`> AWizzArd: it isn't immediately clear to anyone
12:57:13 <jle`> even most experienced haskellers would have to think about it
12:57:19 <AWizzArd> k
12:57:25 <jle`> that doesn't mean it's not interpretable at a mechanical level
12:57:31 <AWizzArd> Sure.
12:57:32 <jle`> you have the definition for (.)
12:57:35 <buglebudabey> zachk like source from the database and read into the data types we discussed above, perform the ops, then push the results back in?
12:57:35 <jle`> @src (.)
12:57:36 <lambdabot> (f . g) x = f (g x)
12:57:42 <zachk> I just looked at pagerank and I dont totally comprehend it for the time being, or how you would specialize it to certain words or phrases
12:57:44 <lyxia> AWizzArd: (fmap . fmap) sum Just [] = fmap (fmap sum) Just [] = (fmap sum . Just) [] = fmap sum (Just []) = Just (sum [])
12:58:21 <buglebudabey> zachk alright, fair enough
12:58:24 <zachk> buglebudabey, with neo4j I think you can get backlinks really easy and just calculate from those results in your language
12:58:31 <jle`> AWizzArd: it's pretty much like reading obfuscated code in any other language.  it's designed to be unintelligble at an immediate level
12:58:32 <AWizzArd> lyxia: why is this true?  fmap (fmap sum) Just [] = (fmap sum . Just) []
12:59:01 <buglebudabey> zachk ok i'll look more into it and see what makes sense
12:59:01 <lyxia> AWizzArd: because we're using the instance Functor ((->) a)
12:59:02 <buglebudabey> zachk thanks
12:59:10 <jle`> AWizzArd: fmap f g = f . g
12:59:21 <jle`> if g is a function type
12:59:23 <jle`> which Just is
12:59:25 <zachk> neo4j has a local web interface and tutorials built into its web interface
12:59:34 <jle`> so fmap blahblah Just = blahblah . Just
13:00:17 <AWizzArd> Yes okay, Just is also an ordinary function.
13:00:28 <zachk> buglebudabey, what I am thinking of doing is downloading the relevant pages for ranking searcching to a local cache first, then parsing them and then putting the relative data into a graph database
13:00:30 <jle`> depends on what you define as 'ordinary', but sure
13:00:45 <jle`> what else would it be? :)
13:00:48 <AWizzArd> I too easily forget about data constructors being functions like you and me.
13:00:56 <AWizzArd> Yes yes, you are right. Thx jle` and lyxia.
13:01:17 <lyxia> "functions like you and me"?
13:01:19 <buglebudabey> zachk that does sound pretty similiar, so you wanna keep the page data locally?
13:01:25 <AWizzArd> lyxia: ;-)
13:01:30 * geekosaur took that homiletically
13:01:43 <EvanR> but not the other way around...
13:01:52 <EvanR> functions are not made of constructors
13:01:55 <glguy> data constructors aren't necessarily functions, only the ones that are functions are
13:02:08 <AWizzArd> Yes.
13:02:14 <EvanR> :t False
13:02:15 <lambdabot> Bool
13:03:31 <jle`> the lesson is that the only prerequisite for something being a function is that it has to be a function
13:04:32 <jle`> its type is made with an application of (->) :)
13:04:45 <zachk> buglebudabey, well google keeps a cache of most of the world wide web and parses and analyzes offline, so I think local caching of pages for processing seems like a meritable idea
13:05:19 <buglebudabey> i'm more of an altavista man myself
13:19:41 <simon`> When I just need a simple String to String map, should I rather use Data.Map.Strict or Data.Map.Lazy?
13:20:15 <hpc> use Data.Map until you care one way or the other
13:20:23 <simon`> ok!
13:22:44 <EvanR> people seem to prefer HashMap for string to foo mapping
13:23:00 <EvanR> a strict map of any kind wont do much on String
13:23:13 <EvanR> since its a list of characters and that will just evaluate the first letter
13:23:54 <EvanR> talking about the values in the map
13:25:05 <simon`> EvanR: Sure, I know. That's why I asked what is "best practice" in that case
13:26:17 <EvanR> to get an approximation of a java script object of strings, use Data.HashMap.Strict and not String as the value
13:26:23 <EvanR> probably Text
13:26:43 <Welkin> I have a suspicion that the tendency for people to prematurely optimize their code comes from the terrible way in which programming is taught in schools
13:27:16 <simon`> It was not meant be an "optimization question"
13:27:19 <EvanR> alternative best practice, do not care at all and use Map + String
13:27:45 <Welkin> I've used String with parsec and never had an issue :P
13:27:55 <Welkin> to parse huge files
13:28:18 <EvanR> i have had issue with String and "huge" (1M) files "parsing" manually with splits etc
13:28:25 <EvanR> stack overflows
13:29:08 <simon`> Good to know, as I am currently writing a megaparsec parser for potentially > 50 MB files
13:29:09 <Welkin> the files were 12-20 mb
13:29:31 <Welkin> this was with parsec though, not my own handrolled parsing
13:29:36 <Welkin> no issues at all
13:29:44 <Lokathor> EvanR, good thing that IRC is usually 512 bytes or less per message frame! lets you do all the manual parsing you want :P
13:29:53 <EvanR> yeah!
13:30:26 <EvanR> as long as you consume String data incrementally it works
13:30:53 <monochrom> [Char] is huge. Expect 24 bytes per character.
13:31:41 <EvanR> is haskelll the only game in town with list strings...
13:32:05 <monochrom> This is why some people choose 32-bit GHC on 512MB rented virtual machines, even if the virtual machine can do 64. Because it is then just 12 bytes per character.
13:32:07 <hpc> maybe a lisp or two?
13:32:34 <monochrom> Lisps probably have native string types.
13:32:39 <[exa]> yup
13:32:49 <monochrom> I mean rather than "oh just re-use cons lists"
13:32:49 <hpc> haskell might be the only game in town to get even a slight benefit from list strings
13:33:02 <hpc> yeah, it'd be a toy lisp if anything
13:35:04 <EvanR> yay haskell: toy technology
13:35:39 <lyxia> all so we can do fix show
13:35:45 * EvanR goes back in time and renames Text to String and String to [Char]  not in that order
13:36:58 <monochrom> To be fair, Haskell compilers honed implementation of lazy evaluation really well, not toy at all.
13:37:20 <monochrom> Also on the frontier of GC.
13:37:26 <EvanR> i kind of cant get over the 24B thing
13:37:47 <EvanR> a unicode char is less than 3 bytes
13:38:47 <jle`> good thing people don't use [Char] for storing text
13:39:26 <simon`> Is there a way to show the memory "footprint" of a certain list in ghci?
13:39:47 <simon`> *any other data structure for that matter
13:40:11 <EvanR> theres GHC.Vacuum
13:40:21 <EvanR> and EKG
13:40:50 <mniip> hmmm
13:40:58 <mniip> there are monads in End(Hask) :o
13:41:44 <EvanR> vacuumLazy :: a -> IntMap HNode
13:41:51 <EvanR> doesn't force anything
13:42:36 <mniip> IdentityT and ReaderT
13:42:45 <EvanR> dont see an easy "size" function
13:43:05 <mniip> hmm
13:43:14 <simon`> Hm, might take a look at your proposels if I have time
13:43:48 <simon`> I am not really familiar with anything that happens behind the scenes with Haskell and that does bother me a little
13:43:57 <EvanR> hehe
13:44:11 <mniip> data MonadT m f a = MonadT (m (f a))
13:44:20 <mniip> instacnce Monad m => Monad (MonadT m)
13:44:47 <simon`> It's a beautiful language but I do miss C in this respect occasionally
13:44:58 <EvanR> haskell code runs on a highly optimized and bug free platform of denotational semantics that is all that matters. and you have infinite memory 
13:45:52 <EvanR> you can use inline-c ! ;)
13:46:01 <simon`> Well I would doubt the infinite memory part
13:46:09 <simon`> ^^
13:46:10 <mniip> use infinite memory in C with this one simple trick!
13:46:31 <jle`> mniip: . o O ( type MonadT = Compose )
13:46:42 <mniip> jle`, good point
13:52:47 <ondrejs> hi, I want to tell if a filepath leads to a file (or a dir.), the https://www.stackage.org/package/system-fileio package has `isFile` function but the package is deprecated. Is there some replacement for this or what's the standard way to solve this? Thanks
13:53:23 <ondrejs> system.directory has doesFileExist but that checks more than I want...
14:00:03 <ondrejs> ok I will settle for doesFileExist 
14:00:28 <verement> ondrejs: Any check you do could be invalid by the time you act on it. Couldn't you assume the filepath is indeed a file, and handle any resulting error if it isn't?
14:02:05 <EvanR> if you just want to poll and get a Bool back, doesFileExist
14:02:20 <ondrejs> verement: good point, but I don't think that will happen in my use case so I'll stick with what I have
14:02:38 <EvanR> anything more and you want a brackety thing that tries to use the file for something, but catches the does not exist (or similar) exceptions
14:03:05 <EvanR> the latter can implement the former
14:07:50 <ondrejs> EvanR: understood, thank you.
14:08:05 <jordan335> https://ideone.com/0NYbZI
14:08:13 <jordan335> can anyone explain me why this doesnt work in line 15
14:08:47 <lyxia> NKnoten is applied to three arguments, it accepts only two.
14:09:37 <jordan335> this is suppossed to be a tree
14:10:10 <jordan335> "sonne" is at the top and points to two things: "merkur" and "venus"
14:10:13 <int-e> please, use spaces... but [...] [...] is two lists, not a single list with two elements
14:10:59 <jordan335> oh its all in a list
14:11:00 <jordan335> NKnoten "Sonne"[NBlatt "Merkur", NBlatt "Venus"]
14:11:07 <jordan335> this should work then?
14:11:14 <int-e> Node "sun" [Leaf "mercury", Leaf "venus"]
14:11:17 <int-e> so, yes.
14:11:19 <jordan335> awesome
14:11:21 <jordan335> thanks a lot
14:11:41 <jordan335> do u recognize the language btw?
14:12:04 <lyxia> German?
14:12:06 <jordan335> dont answer haskell please
14:12:09 <jordan335> yes haha ^
14:13:11 <hpc> i guess it could technically be a number of ML-family languages
14:31:27 <simon`> Is there a Hashmap that preserves order?
14:33:07 <kuribas> no
14:33:10 <EvanR> order of what?
14:33:25 * hackage debug-me 1.20170510 - secure remote debugging  https://hackage.haskell.org/package/debug-me-1.20170510 (JoeyHess)
14:33:33 <kuribas> simon`: if you need order use a normal Map.
14:33:45 <EvanR> Map will keep order of keys, in terms of the ordering on keys
14:34:13 <EvanR> theres a package here, insert-ordered-containers which keeps order based on which order you inserted things in
14:34:38 <EvanR> which is more like how PHP works
14:35:00 <kuribas> EvanR: so a stack or deque?
14:35:09 <EvanR> well, with fast lookup
14:36:24 <kuribas> why would you need that?
14:37:08 <simon`> Yes, I need to preserve the order things got inserted into the Map
14:37:15 <simon`> *that
14:37:40 <geekosaur> there's also psqueues and such
14:38:08 <EvanR> its certainly a non typical requiremnt
14:38:24 <EvanR> and a source of bugs when people assume thats how it works
14:38:27 <simon`> I want to parse chess PGN files and I am looking for a suitable data structure for the tag pair section
14:38:28 <jordan335> https://ideone.com/yb39Vn
14:38:43 <jordan335> i want to make a function that convert one data type into the other
14:38:49 <jordan335> converts*
14:39:05 <jordan335> is pattern matching the way to go?
14:39:21 <simon`> Maybe a list of tuples would also suffice actually
14:41:10 <kuribas> simon`: you could create a vector of pgn files, then a map (Map ke Index), mapping from key into an index into the vector.
14:41:38 <kuribas> if the order of the chess games is important.
14:42:16 <EvanR> you can prepend an ordering number to the key itself
14:42:27 <kuribas> simon`: or simply have a Int field in the Pgn datatype describing the order.
14:42:28 <EvanR> (i, k) is the new key, but could get tedious
14:42:52 <kuribas> yes, having the position in the datatype is cleaner.
14:43:31 <kuribas> jordan335: sure
14:43:43 <jordan335> how would i start doing that?
14:43:53 <EvanR> having a separate index of what the order is, is something a new data structure should take care of for you
14:43:57 <jordan335> i dont have much experience with pattern matching
14:45:13 <kuribas> btreentree (BBlatt val) = ...; btreentree tree1 bm1 tree2 = ...;
14:45:28 <kuribas> to quick...
14:45:49 <kuribas> btreentree (BBlatt val) = ...; btreentree (BKnoten tree1 bm1 tree2) = ...;
14:46:28 <kuribas> jordan335: then reconstruct the second tree.
14:46:30 <simon`> Maybe I am just sticking with a list of tuples since the tag pair section of a game will hardy ever consist of more than 10 elements
14:46:44 <EvanR> oh jeez... then yes use a list
14:46:55 <buglebudabey> what's a good library for making api calls?
14:47:05 <simon`> Is there a predefined lookup function for tuple lists?
14:47:16 <EvanR> :t lookup
14:47:18 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:47:26 <simon`> Oh, perfect!
14:48:12 <kuribas> simon`: why not create a proper haskell datatype?
14:48:32 <kuribas> http://hackage.haskell.org/package/chesshs-0.2.1/docs/Chess-PGN.html
14:49:10 <simon`> kuribas: the library does not follow the spec
14:49:36 <kuribas> update it?
14:49:40 <simon`> for various reasons
14:49:53 <jordan335> kuribas im not sure what to do with that
14:50:23 <kuribas> jordan335: you need to fill in ...
14:51:12 <simon`> kuribas: How would "updating" work with haskell packages
14:51:47 <simon`> Just send a new proposel to the maintainer?
14:51:53 <kuribas> yes
14:51:56 * hackage jenkinsPlugins2nix 0.1.0.0 - Generate nix for Jenkins plugins.  https://hackage.haskell.org/package/jenkinsPlugins2nix-0.1.0.0 (MateuszKowalczyk)
14:52:09 <kuribas> simon`: download the source, make improvements, contact the author.
14:52:45 <kuribas> simon`: if you think it's worth improving, rather than beginning from scratch.
14:52:48 <simon`> I think I rather write my own library
14:53:09 <simon`> there is not much to the existing one
14:53:29 <simon`> plus I wrote most of the parser with megaparsec instead of attoparsec already
14:54:56 <jordan335> https://ideone.com/OPaAA9
14:54:58 <jordan335> kuribas
14:55:03 <jordan335> somehow this doesnt work
14:55:23 <jordan335> Not in scope: data constructor ‘BBaum’
14:55:45 <kuribas> jordan335: BBaum is a type, not a contructor.  
14:56:31 <kuribas> you can only match against BBlatt or BKnoten
14:56:53 <monochrom> Or just use a variable because you are not checking anyway.
14:57:32 <monochrom> Also [Int] and [5] mean very different things.
14:57:45 <geekosaur> they're extracting the thing under the constructor --- which won't work (what if the BBaum c is a BBlatt c?
14:57:51 <monochrom> Namely, [Int] does not say "length is 1", but [5] does.
14:58:40 <jordan335> hm
14:59:45 <jordan335> line 9 is correct though?
15:02:16 <kuribas> simon`: great, that sounds very useful.
15:03:13 <kuribas> simon`: if you use Map instead of hashmap you can do interesting things like looking up all games less than a key, or between two keys, etc...
15:04:10 <kuribas> simon`: if they have a proper Ord instance of course.
15:06:56 * hackage xml-conduit 1.5.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  https://hackage.haskell.org/package/xml-conduit-1.5.1 (koral)
15:16:25 <simon`> kuribas: I think I will not use haskell for a large collection of games
15:16:38 <kuribas> why not?
15:16:59 <simon`> I want all games to potentially fit into memory
15:17:14 <simon`> which might potentially be ~8 Mio
15:17:33 <simon`> So I am thinking of writing my own database format in C
15:18:12 <simon`> and to have some sort of tree structure with information packed into the least possible amount of bytes for each game
15:18:13 <ab9rf> i don't see why you'd prefer C to Haskell in that context
15:19:05 <simon`> Hm, I am not enough of an expert in Haskell as to know how to have precise control over every bit I am using for a datastructure
15:19:19 <ab9rf> why do you need precise control over every bit?
15:19:26 <ab9rf> are you prematurely optimizing?
15:20:15 <simon`> If you want to fit >10 Mio Chess games into memory I wouldn't call opimizatino prematurely
15:20:28 <simon`> My server has 4GB Ram
15:20:49 <kuribas> use a proper database?
15:21:05 <kuribas> sqlite or mysql for example?
15:21:18 <ab9rf> or come up with a means to characterize them that uses less memory
15:21:25 <simon`> I don't think they will be very useful for chess games
15:21:38 <ab9rf> i don't see why notr
15:21:53 <simon`> I want the database to allow for efficient prefix checking of move sequences as a major requirement
15:21:55 <ab9rf> what's a mio chess game?
15:22:10 <ab9rf> isn't that just a matter of storing the move sequence?
15:22:12 <jordan335> https://ideone.com/v79sDL
15:22:15 <kuribas> ab9rf: I think he means million
15:22:19 <jordan335> kuribas this doesnt work either : /
15:22:22 <ab9rf> any sensible database eingine can 
15:22:25 <ab9rf> do prefix matching
15:22:25 <monochrom> I think you phrased your concern on the wrong foot. Your wording was "control", but what you meant is careful accounting and informed decision.
15:22:54 <ab9rf> i can represent nearly any chess game in under a kilobyte
15:22:55 <simon`> million
15:23:14 <ab9rf> given that, 8 million chess games is well less than 8 gigabytes
15:23:15 <kuribas> jordan335: BKnoten isn't a constructor for NBaum
15:23:25 <ab9rf> don't really see the issue
15:23:48 <ab9rf> that's a tiny amoutn of data for any reasonable database engine
15:24:37 <kuribas> simon`: what's the goal, looking up moves?
15:24:38 <zachk> if you are storing the chess games as [Char] in haskell in memory (from earlier) each Chat is from 12 to 24 bytes
15:24:44 <zachk> so that might increase your size a bit
15:25:14 <kuribas> you can use bytestring as binary data
15:25:19 <ab9rf> the base representation i'd likely use is osmething like [ChessMove]
15:25:29 <ab9rf> where chessmove was an ADT that described every possible move
15:25:45 <ab9rf> there aren't that many possible moves
15:25:56 <simon`> The major goal is to efficiently insert a new game which might potentially be in the database in a slightly different form
15:26:18 <simon`> e.g. have one move less but otherwise the same
15:26:22 <kuribas> simon`: I am not sure what you goal is?
15:26:22 <ab9rf> that's trivial
15:26:30 <ab9rf> just serialize the moves and do a prefix match
15:26:43 <jordan335> i fixed it and it still doesnt work
15:26:44 <kuribas> simon`: do you want to match positions?
15:26:59 <simon`> The database engine would need to be able to quickly present me with a list of possible duplicates
15:27:02 <ab9rf> if you use a SQL database and index the "move" field, that's a constrained index seek
15:27:32 <kuribas> simon`: duplicate games?
15:27:36 <simon`> I also want to be able to search for games with a specific position
15:27:49 <ab9rf> simon`: you can characterize psotions into a single (largish) integer
15:28:07 <ab9rf> or a character string of 64 characters
15:28:07 <simon`> and with a certain set of positions (e.g. all 5 pawn endgames or similar)
15:29:02 <kuribas> simon`: in the worst case you can always "pack" into a Bytestring.
15:29:08 <kuribas> simon`: you don't need C for that.
15:29:29 <ab9rf> dpm
15:29:31 <kuribas> for example: https://hackage.haskell.org/package/binary
15:29:38 <ab9rf> don't obsess on representation
15:30:00 <simon`> If I am mostly dealing with bytestrings I might aswell make the database a standalone C-application I thought
15:30:02 <ab9rf> get the data structure first, figure out its in-memory and persisted representations later
15:31:31 <simon`> And use Haskell for Parsing and an abstraction layer to the database
15:33:09 <ab9rf> i've found haskell especially effective for doing ETL
15:34:10 <kuribas> simon`: an on-file database will also work when the database doesn't fit into memory.
15:34:37 <simon`> Sure, but a major requirement for me is speed
15:34:57 <kuribas> Aren't modern databases pretty quick?
15:35:00 <simon`> I already hate my chess program for being so slow with databases at times
15:35:10 <simon`> I want to be better in this respect :)
15:35:15 <kuribas> it's probably implemented inefficiently.
15:35:19 <kuribas> maybe doing linear search.
15:35:28 <simon`> Hm, not all chess databases it seems
15:35:56 <simon`> The most common chess database format is closed source unfortunately
15:36:25 <simon`> And I thought it would be a good exercise to see if I can make a better one
15:36:33 <kuribas> Of course loading a large png library from file into memory and indexing is going to take a long time.
15:36:46 <simon`> Yeah, that'd be stupid
15:36:57 <simon`> You need a smart representation 
15:37:13 <monochrom> No wait, that's a great idea! To "parse" a chess board from picture... :)
15:37:22 <ab9rf> simon`: if you're having speed issues, it's not because of the datbase engine itself, but how you're using it
15:37:23 <simon`> ^^
15:37:49 <simon`> How do you know?
15:38:00 <ab9rf> because i've been a database administrator since 1986
15:38:19 <simon`> A chess database admin?
15:38:32 <jordan335> kuribas i dont make progress
15:38:35 <monochrom> Supposedly one can pull a "but the status quo is wrong" on this :)
15:38:36 <ab9rf> i've never actually dealt with a chess database, but that barely matters
15:38:50 <ab9rf> monochrom: oh, possibly. a lot of apps are stupidly written.
15:38:58 <ab9rf> datas are datas
15:39:41 <ab9rf> most likely your slowness is due to not creating column indices, or using queries that cannot benefit from indices.
15:39:46 <kuribas> simon`: I used scid, and it was pretty fast (that's 15 years ago or so).
15:40:01 <kuribas> simon`: http://scid.sourceforge.net/
15:40:18 <simon`> I am studying physics, so I might be missing on some database theory. But I thought the database design should be optimized for the specific ways I want to retreive data from it. 
15:40:33 <simon`> Yeah, using scid too
15:41:08 <simon`> If you use a standard scid database as an opening tree, it's pretty slow for example
15:41:51 <ab9rf> also, scid doesn't appear to be closed source to me
15:41:58 <simon`> scid is open
15:42:14 <simon`> But chessbase cbv is by far the most popular 
15:42:19 <simon`> which is closed source
15:42:35 <simon`> afaik
15:43:03 <ab9rf> i don' tknow what's computationally necessary to "use a standard scid database as an opening tree" and so i can't advise on how to optimize the database
15:44:23 <simon`> I will have to figure that out
15:44:53 <simon`> Just thought C might be the better tool for it
15:45:02 <ab9rf> not particularly
15:45:29 <kuribas> simon`: it will give you a few linear improvements, but those are usually insignificant.
15:45:41 <ab9rf> you need precomputed indices that allow you to narrow your search set when you do searches so you don't have to spool your entire database
15:45:59 <kuribas> simon`: and linear improvement in memory or speed, not programming time, program complexity, safety, etc...
15:46:34 <ab9rf> so this comes down to coming up with ways to characterize games or positions with summary characterizations that can then be organized in a search tree that can be traversed much faster than the primary data set
15:47:03 <simon`> It's hard to judge for me, as I am not experienced enough in Haskell to know how big the overhead will be
15:47:06 <ab9rf> i don't know what sorts of searches you want to be able to do Especially Quickly, and so i can't advise on how to do those characterizations
15:47:16 <ab9rf> this has Almost Nothing to do with haskell
15:47:27 <jordan335> i did it finally
15:47:29 <ab9rf> it has to do with avoiding linear scans
15:47:54 <simon`> ab9rf: do you have a book recommendation on general database design?
15:47:59 <ab9rf> simon`: nope
15:48:05 <kuribas> simon`: heh, I did a few hackerrank problems in haskell, and it was maybe in 2x the speed of a C implementation.  But an unoptimized C implementation would be 1000x slower or so.
15:48:06 <ab9rf> simon`: i've been doing this for 31 years
15:48:15 <ab9rf> how much of that do you think i learned from a book?
15:48:28 <simon`> :)
15:48:52 <simon`> Well you'd have to start somewhere I guess?
15:48:56 <ab9rf> i started working with databases six years before SQL existed.
15:49:13 <ab9rf> well, sure, mostly product manuals and specific product technical documentation
15:49:28 <ab9rf> because to be a good DBA you need to know what's going on "under the hood"
15:50:01 <simon`> kuribas: 2x the speed would be a huge improvement if searching takes more than 1/10 second or so+
15:50:03 <ab9rf> i can go on for hours about how Microsoft SQL Server structures a database on disk, but that would not likely illuminate your problem :)
15:50:37 <kuribas> simon`: it wasn't particularly optimized haskell.
15:50:56 <kuribas> simon`: it just had the right algorithmic complexity.
15:51:20 <simon`> Just looked at the git design which is written in C
15:51:32 <simon`> So I thought I might aswell use C too :)
15:51:35 <ab9rf> getting the right algorithmic complexity is far more important than squeezing some efficiency out of the runtime implementation
15:51:46 <simon`> Sure, that's always a given
15:52:00 <ab9rf> but you're talking about language when you have no idea what your approach even is
15:52:26 <ab9rf> a slow algorithm is slow in every language
15:52:26 <Tuplanolla> Do you develop or just administer databases, ab9rf?
15:52:36 <ab9rf> Tuplanolla: i've done both.
15:53:18 <kuribas> simon`: heh, you can always port that 0.1% part of your program to C, once you find where the bottleneck is.
15:53:21 <Tuplanolla> I kind of expected that.
15:53:28 <monochrom> Time to say: Haskell makes a fast algorithm fast, and an infinite-time algorithm finite-time. :)
15:53:39 <ab9rf> Tuplanolla: it's usually the DBA who figures out how to optimize the database anyway, the devlopers rarely understand enough of the way the query engine works to be able tyo decide what indices should be added :)
15:56:03 <simon`> Maybe I am writing a Haskell prototype first
15:56:09 <ab9rf> i probably don't have as much database theory as i could, i'm aware that there's a relational algebra for databases but couldn't recite the laws off the top of my head
15:56:21 <Tuplanolla> How about database engines?
15:57:08 <ab9rf> at the same time, i do know the difference between a selection, a projection, and a join
15:57:21 <simon`> I basically know nothing about specific database engines
15:57:51 <ab9rf> simon`: do you know what a "column index" is? do you know the difference between a table scan, an index scan, and an index seek?
16:00:03 <ab9rf> iirc an index fetch from a B+ tree is normally O(lg n) in the number of records in the index
16:00:20 <ab9rf> most database engines use B+ trees or something very similar for indexes
16:01:56 <ab9rf> yeah, the base of the logarithm will depend on the implementation, but it's going to be logarithmic in the number of records stored
16:03:32 <Lokathor> so
16:03:39 <Lokathor> I want readFile, but not lazy
16:03:57 <ab9rf> Lokathor: you want to be assured that the entire file has been read?
16:04:03 <Lokathor> yes
16:04:23 <Eduard_Munteanu> Lokathor, you can use the strict bytestring's readFile
16:04:35 <Eduard_Munteanu> Or strict Text.
16:04:35 <ab9rf> System.IO.Strict?
16:04:45 <Eduard_Munteanu> Data.ByteString.IO
16:04:50 <Lokathor> yeah i figure you can do this with ByteString or Text, but I wasn't sure if there was an easy way with just stuff from base
16:04:56 <simon`> Hm, "table scan" = iterate over all rows in the db, "index scan" = iterate over all index items, "index seek" = iterate over all qualifying rows?
16:05:24 <ab9rf> simon`: basically, yes. the key to making a datbase fast is to have as many of your selects use index seeks instead of index scans or table scans.
16:05:29 <ab9rf> index scans are faster than table scans.
16:05:34 <ab9rf> (usually)
16:06:13 <Lokathor> Strict.hGetContents h  = IO.hGetContents h >>= \s -> length s `seq` return s
16:06:16 <ab9rf> index seeks are O(lg n), while index scans and table scans are O(n) (and table scans typically have a larger constant factor because a larger amoutn of data has to be skuffled about)
16:06:21 <Lokathor> simple now that I think about it
16:06:38 <ab9rf> Lokathor: heh, nice way to force it
16:06:54 <MarcelineVQ> I wonder about !foo <- readFile "nyar.txt"
16:07:13 <Lokathor> i just looked here https://hackage.haskell.org/package/strict-0.3.2/docs/src/System-IO-Strict.html#hGetContents
16:07:20 <Eduard_Munteanu> That just reads the first character.
16:07:46 <ab9rf> MarcelineVQ: only guarantees the first character, aeverything after that could still be a thunk
16:07:55 <MarcelineVQ> interesting
16:08:16 <Eduard_Munteanu> You could foldl/foldr with seq, though.
16:10:05 <Eduard_Munteanu> > foldr (\x xs -> x `seq` (x:xs)) [] [1,2,3,4]
16:10:07 <lambdabot>  [1,2,3,4]
16:10:08 <simon`> ab9rf: Ok, thank you!
16:10:12 <Eduard_Munteanu> > foldr (\x xs -> x `seq` (x:xs)) [] [1,2,undefined,4]
16:10:14 <lambdabot>  [1,2*Exception: Prelude.undefined
16:10:28 <simon`> What datastructure are databases usually stored in?
16:10:32 <simon`> *s
16:11:26 <Eduard_Munteanu> simon`, there's an on-disk format, not some generic data structure
16:11:44 <simon`> I mean some sort of tree I suppose?
16:12:22 <Eduard_Munteanu> Indexes are trees usually.
16:12:48 <simon`> And the leaves point to data on the disk?
16:13:17 <Eduard_Munteanu> The data may be stored inline in the tree or as pointers/offsets within the database.
16:14:01 <MarcelineVQ> Eduard_Munteanu, ab9rf: actually I feel like a fool now, of course it only forces the first element, that's what : is all about :>
16:14:17 <ab9rf> simon`: virtually all modern databases uses some variant on a B+ tree
16:14:47 <Eduard_Munteanu> Well, all modern classic RDBMSes :)
16:15:02 <ab9rf> yeah, key-value databases may use other structures
16:15:20 <Eduard_Munteanu> You can probably do with a binary tree for SSD-optimized stuff.
16:16:00 <ab9rf> simon`: in most of the db  engines i've used, a table is just an index with data in the leaves, while an index has pointers to table roes in the leave instead
16:16:08 <simon`> ab9rf: Ok, I see. I have to prepare a btrfs talk for work, so I need to learn about B-trees anyway
16:16:32 <ab9rf> the table is alsoa B+ tree indexed by either the "primary key" or by an internally-genreated unique row identifier
16:16:59 <ab9rf> also, in some cases some row data may be stored "elsewhere"
16:17:10 <ab9rf> (e.g. large binary object fields)
16:17:57 <simon`> Ok, that makes sense!
16:18:39 <simon`> ab9rf: What is the difference between a B- and a B+-tree actually?
16:19:13 <ab9rf> simon`: B-trees contain values at all nodes, not just leaves
16:20:19 <ab9rf> it's much harder to sequentially traverse a B-tree starting at some arbitrary point
16:20:54 <simon`> Ok, I understand!
16:21:04 <ab9rf> tpyically also B+ trees have much higher "fan-out" 
16:22:36 <simon`> Is the balancing done automatically or after "manually" after each insert/transaction?
16:22:53 <simon`> -after
16:23:53 <ab9rf> the database engine does the balancing, although it's an implementation details as to when balancing happens.
16:24:15 <ab9rf> normally transactionsa re not written to main store until committed
16:24:26 <ab9rf> until committed, they'll be in transient store (and the transaction log) only
16:25:47 <simon`> Ok, makes sense!
16:26:14 <ab9rf> it gets even more fun if you're dealing with a multiphase commit architecture 
16:26:21 <simon`> I will work through Knuth's chapter on B trees sometime next week to fully understand what's going on
16:26:33 <ckubrak> Hi guys, I'm currently learning haskell and I have a doubt. In the the books I'm reading (Real World Haskell and LYAH) they do this kind of stuff:
16:26:33 <ab9rf> can't argue with knuth
16:26:35 <ckubrak> https://gist.github.com/ckubrak/ebc5966ffc99aee2ba2c65287f8749a3
16:27:23 <ckubrak> Why do they use a where clause? Why don't they define step outside?
16:27:41 <EvanR> its only useful to that function being defined
16:27:51 <EvanR> a locally defined function
16:27:54 <ab9rf> simon`: on mssql, the dba can specify on a table-by-table (or index-by-index) the "desired" free space in the index
16:28:07 <EvanR> like you would use local variables instead of global variables for the same purpose
16:28:44 <ab9rf> simon`: if you know, as the dba, that additional records will only be added to the "end" of the table (as defined by its primary key) then you may want to set the fill factor to 100%, which forces the engine to only do splits when nodes are completely full
16:29:14 <ckubrak> EvanR: ok thanks
16:29:48 <EvanR> ckubrak: also, you see it uses the variable p... if you just moved it out, that would be "variable not in scope"
16:30:03 <ab9rf> simon`: but if you anticipate that additional records will be added across the entire range of the index alues, you would specify a smaller fill factor to leave room so that most inserts don't require a block split. most DBAs run periodic table reorganizations to reshape the indices back to the desired fill factor.
16:32:22 <ab9rf> ckubrak: otherwise you clutter up your module namespace to the point that it gets difficult to avoid collisions
16:33:24 <simon`> ab9rf: That's intersting! I think I will teach myself a thing or two about databases
16:33:42 <simon`> Do you know a good B-tree module for Haskell?
16:36:17 <Eduard_Munteanu> I've seen a couple on Hackage, although somewhat limited.
16:36:51 <Eduard_Munteanu> Note btrees are usually used as on-disk structures, not as much as in-memory structures.
16:37:09 <simon`> why not actually?
16:37:56 <Eduard_Munteanu> The fanout of btrees is useful for slow rotating media, but it's unnecessary for random access memory.
16:38:33 <ab9rf> Eduard_Munteanu: yeah, in-memory is a whole different chicken
16:38:59 <Engen> hey everyone, currently trying do an exercise to do with propositional logic in haskell and I'm having some trouble understanding the given data data instanciation to try and figure out if some given formula is satisfiable http://wklej.org/hash/cf20176d9a1/
16:39:20 <ab9rf> Eduard_Munteanu: although you still can get some benefit if you use a B-tree with a block size that matches your CPU cache line
16:39:38 <Engen> I understand that Exists takes in a list of some type a, but then the second argument which is a function is where I get confused on what's happening 
16:40:23 <simon`> what is fanout?
16:40:48 <ab9rf> simon`: this is getting a bit far afield for #haskell
16:41:21 <simon`> you started though ;-)
16:41:50 <Engen> the type definition is as follows: Show a => [a] -> (Term a -> Formula as) -> Formula (a, as). What is the function (second argument) saying?
16:41:52 <ab9rf> simon`: and you're not paying me enough for a tutorial lesson :)
16:42:04 <ab9rf> and Engen's question is actually about haskell and i want to focus on that :)
16:42:40 <Engen> I know that satisfiable has to try every combination of inputs and if any happens to be true, then output true, otherwise false
16:42:47 <simon`> ab9rf: I am paying you gratitude (and potentially awe) :)
16:42:48 <Eduard_Munteanu> simon`, it's the number of branches that go out of a node, e.g. 2 for binary trees
16:43:12 <Tuplanolla> I'm paying attention. Is that not enough?
16:44:02 <simon`> Eduard_Munteanu: ok, I see. Weird terminology :)
16:44:05 <zachk> great now I can get webpages over https using http-conduit :D
16:44:12 <zachk> now I can get to parsing them
16:45:03 <Gurkenglas> Engen, the second argument is something that becomes a formula given a term, such as a formula with blank spaces in it that are going to be filled with the given term. If you call the blank space by a name such as x, you've got yourself a formula with a free variable, which that functions is probably meant to represent
16:45:19 <Gurkenglas> *that function is
16:48:30 <Gurkenglas> Engen, "satisfiable xs func" is not something that will compile because satisfiable takes one argument. You may want to replace "satisfiable xs func" with some expression of form "map (satisfiable . _) xs" for some _, in order to turn each element of [a] into some Formula and then check it for satisfiability.
16:49:13 <ab9rf> yeah, i finally figured that out too
16:49:16 <Gurkenglas> Of course, 'foldl (||) False (map f x)' is 'any f x'
16:49:27 <ab9rf> you''re going to have to dive into func
16:49:45 <begriffs> What's a slick way to "filter" a Maybe? For instance turning (Just "") into Nothing, but preserving Just of any other string value?
16:49:53 <Gurkenglas> Engen, that last _ will probably need some way to turn a into Term a
16:50:06 <Gurkenglas> :t mfilter :: begriffs
16:50:08 <lambdabot> error:
16:50:08 <lambdabot>     • Couldn't match expected type ‘begriffs1’
16:50:08 <lambdabot>                   with actual type ‘(a0 -> Bool) -> m0 a0 -> m0 a0’
16:50:22 <Gurkenglas> :t mfilter -- begriffs (gotta go sleep i guess?)
16:50:24 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
16:50:27 <ab9rf> heh
16:50:57 <begriffs> Oh nice, my hoogle search was too specific I guess. :)
16:51:13 <Engen> Gurkenglas: yeah I was thinking of using map also but couldn't see how I'd map into the function/data compared to over it like you would with a list
16:52:55 <Gurkenglas> The _ will have type "a -> Formula a". The as yet unused argument has type "Term a -> Formula a". Want a hint? :P
16:53:51 <Engen> Gurkenglas: oh, would that just then be a -> Term a ?
16:54:24 <Gurkenglas> You should need to use such a function within the _, yes.
16:56:25 <ab9rf> heh
16:57:47 <Engen> Gurkenglas: I've defined the following though: data Term t where Con :: t -> Term t
16:58:56 <Engen> Gurkenglas: slight diversion, but what is the period inside (satisfiable . _) doing?
16:59:04 <Gurkenglas> :t (.)
16:59:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:00:28 <Gurkenglas> Function composition. It is only a convenient shorthand which, when you manage to use it without the brackets directly around it, is a hint that your code is elegant :3
17:00:51 <Gurkenglas> (satisfiable . _) is (\x -> satisfiable (_ x))
17:02:49 <Engen> Gurkenglas: oh I see. The implicit nature of variable x (in your example) never seems to make sense to me coming from a C background
17:04:05 <Engen> so coming back to the issue at hand, we want to a -> Formula a, I've defined it as a -> Term a hmm
17:05:31 <Gurkenglas> You want a Bool. You have "any :: (a -> Bool) -> [a] -> Bool", "satisfiable :: Formula a -> Bool" (recursively), "Con :: t -> Term t", "xs :: [a]" and "func :: Term a -> Formula a". Anyone got a Scratch-like that can let him lego this together?
17:07:45 <Engen> hey hey! got it! 
17:08:02 <Engen> I call func onto Con 
17:08:59 <Gurkenglas> (func :: Term a -> Formula a) applied to (Con :: t -> Term t) implies that Term a is equal to t -> Term t :P
17:10:54 <Gurkenglas> (in this case, that is - a better phrase than "is equal to" would be "can be unified with". For example, the a in (id :: a -> a) is not equal to the String ("asd" :: String), but id can be applied to "asd".)
17:11:41 <Engen> yeah so, (satisfiable . func . Con) is what I have
17:11:51 <Engen> I'm sorry that my terminology isn't correct
17:12:34 <Gurkenglas> I'm not, I get to make fun of someone >:D
17:12:48 <Engen> I guess "can be unified with" is synonymous to "composed of"
17:13:47 <Gurkenglas> (satisfiable . func . Con) looks right. Not sure whether you've got that last part right. a can be unified with String. [a] can be unified with String. String can be unified with String. Int cannot be unified with String.
17:14:27 <Gurkenglas> (String can be unified with a, too - "can be unified with" is a symmetric relation)
17:15:23 <Gurkenglas> "<Engen> I call func onto Con" <- the right formulation would have been "I compose func with Con"
17:17:59 <Engen> Gurkenglas: duely noted.
17:23:40 <Engen> Gurkenglas: thanks for the help :) 
17:32:11 <zachk> did they change the haskell layout parser in the past few years?
17:45:18 <lyxia> zachk: no idea. Why do you ask?
17:46:49 <zachk> ghc thought I was in a do block when I was missing a parentheses in a function definition and wanted a let binding for a '='
17:48:52 <lyxia> = most often comes with a let
17:50:09 <zachk> just found it to be a weird error message
17:50:12 <zachk> well g'night
18:02:52 <EvanR> ok. i know several not really solutions and some ok solutions, but what is the real final solution to this: collect a list of entries during a monadic action, like IO
18:03:03 <EvanR> without reversing
18:03:25 <EvanR> i.e. ordered forward in time
18:03:25 <gestone> so i've read haskell from first principles and now i'm looking to build something
18:03:47 <EvanR> Data.Sequence ?
18:03:57 <EvanR> builder?
18:04:05 <EvanR> some fancy type shenanigans
18:05:13 <gestone> so i have read most of haskell programming from first principles and now i think i'm ready to build something
18:05:22 <gestone> does anyone have any suggestions?
18:05:59 <ab9rf> a burrito?
18:06:03 * ab9rf runs
18:06:15 <Tuplanolla> Risch integrator, gestone.
18:06:20 <ab9rf> (sorry, i just saw a chipotle ad)
18:06:24 * Tuplanolla runs as well.
18:06:41 <ab9rf> tradionally, one writes an irc client
18:07:19 <EvanR> its like a jedi's lightsaber, each one is personally crafted
18:07:22 <gestone> ahh
18:07:53 <EvanR> bonus points for making it look like the graphics in the old movie "the matrix"
18:07:58 <ab9rf> heh
18:08:01 <gestone> oh dear that Risch integrator
18:08:09 <ab9rf> mine was written in emacs-lisp :)
18:08:27 <gestone> hmm an irc client you say?
18:08:42 <EvanR> seems legit
18:09:13 <gestone> haskell has good support for sockets?
18:09:27 <ab9rf> i've never really tried, but they shouldn't be that hard
18:09:32 <EvanR> ghc has a nice concurrent I/O manager
18:09:41 <EvanR> and nice concurrency libraries
18:10:13 <gestone> ah do you guys think simon's parallel and concurrent programming book would be a solid read before getting started then?
18:10:14 <EvanR> you can use sockets at whatever level of detail you want
18:10:20 <EvanR> definitely
18:10:35 <ab9rf> yeah, if you want to learn the FFI you can always rwite your own bindings to the syscalls
18:11:24 <EvanR> well, Network.Socket is low level enough already
18:11:29 <gestone> oh interesting
18:12:36 <ab9rf> for an irc client Network is probably sufficient
18:12:40 <ab9rf> you don't need UDP for an IRC client
18:12:46 <ertes> gestone: it's a very good book (simon's) and i recommend everybody to read it…  however…  why don't you just go and build something?  you're currently running the risk of a form of procrastination that is very characteristic to haskell
18:13:14 <ertes> gestone: don't worry about getting everything perfect…  start by getting something *at all*
18:13:39 <gestone> ertes: ah alright. guess best way to learn is by just doing
18:14:31 <gestone> just feel like there's so much to learn first to do things correctly in this language which isn't a bad thing at all, i certainly love the challenge
18:14:59 <ertes> gestone: that would be terrible
18:15:15 <ertes> gestone: the problem is that you will *never* run out of things to learn in haskell
18:15:40 <ertes> and one year from now you will look at your old code and think: "wow, that was primitive…  i'd do it completely differently today"
18:16:09 <unknownln> I find writing code helped me a ton to understand the motivation behind different abstractions and ghc extensions and whatnot, which in turn made it way easier to learn them. The same stuff, when I started out, made no sense at all to me when I first read about them
18:16:20 <EvanR> gestone: in comparison to language X... going back and refactoring haskell code is pretty pleasant
18:16:22 <ertes> by not ever actually writing something, you will rob yourself of that experience =)
18:16:40 <EvanR> so just f-ing write code
18:17:05 <gestone> ertes: i hope i certainly feel so :). i just keep on getting sucked into things. trying to understand free monads right now and why they're used, but i guess i shouuld just build something
18:17:21 <gestone> EvanR: yeah, i'll go do that
18:17:35 <gestone> is there some sort of like... code review channel of some sort?
18:17:38 <ertes> gestone: you will never understand free monads in an actual programming setting, if all you're writing is toy examples
18:18:20 <EvanR> you want to write hello world in haskell, let me tell you a little about free monads
18:18:46 <ertes> gestone: and if you have trouble deciding what to do, i can give you a challenge that is very easy to implement, but has a surprisingly high improvement ceiling
18:19:11 <gestone> ertes: yeah that's what i figured. i just want to know when i can identify an appropriate use case
18:19:19 <gestone> ertes: that'd be interesting, i'd be up for it
18:19:28 <ertes> gestone: don' worry about it…  you will learn to see the patterns
18:19:33 <ertes> gestone: write an echo server
18:19:47 <gestone> ertes: huh i'll give it a shot
18:20:12 <ertes> gestone: you have 12 hours
18:23:22 <samtay> A small CLI app is a great first project, that will usually let you flex some of what you've learned but also get used to the ecosystem and some common packages (like optparse-applicative)
18:24:05 <ertes> gestone: bonus points if i can have multiple concurrent connections, more bonus points if i can choose the listening port from the command line
18:25:29 <gestone> ertes: heh alright
18:26:58 <EvanR> thats going to be a bling echo server
18:51:26 <ab9rf> what's an echo server?
18:51:56 <Welkin> what's an echo server?
18:51:57 <ab9rf> oh, you mean an implemnentation of the "echo" service?
18:52:04 <ab9rf> i'm slew
18:52:08 <Welkin> oh, you mean an implemnentation of the "echo" service?
18:52:12 <gestone> :O
18:52:18 <Welkin> :O
18:52:20 <EvanR> hmm
18:52:31 * ab9rf RSTs Welkin's connection
19:08:44 <Lokathor> gestone, https://github.com/Lokathor/haizod it's old and I want to replace it with a better version some time, but here's a small enough demo
19:15:36 <benzrf> this is probably not the right place to ask, but im not sure where exactly is better -
19:15:54 <benzrf> does c-- have computed jumps that don't push a stack frame?
19:27:52 <ab9rf> benzrf: i think so based on the spec, but i'm not sure
19:28:07 <benzrf> hrm
19:29:08 <ab9rf> gotos can be computed, as can tail calls
19:29:14 <ab9rf> as can cut-tos
19:29:54 <wilornel> Hmmm .. here's an  interesting one I don't quite understand. `myX = 1 :: Int ; foo :: Int -> Int foo x = myX` . If I set `foo :: a -> a`, it does not work. The function wants anything but I return specificall an Int. Is it because it wants to be polymorphic?
19:31:24 <ab9rf> benzrf: labesl are first-class values and the argument to goto may be any expression as long as it evaluates to a label
19:31:32 <benzrf> nice
19:31:37 <wilornel> However, if I have `let myX = 1 :: Num a => a` and then `foo :: Int -> Int`, it works?
19:32:09 <benzrf> ab9rf: what are cut-to
19:32:21 <ab9rf> benzrf: cut-to is used with continuations
19:32:26 <ab9rf> benzrf: nonlocal jump
19:33:56 <ab9rf> benzrf: thre is also jump, used for tail calls
19:34:18 <benzrf> how does tail call differ from cut to
19:34:25 <monadicDuck> @wilornel: myX is an integer so the behavior seems expected?
19:34:25 <lambdabot> Unknown command, try @list
19:35:02 <wilornel> ah I think I get it
19:35:32 <wilornel> assuming the first argument can be anything, the returned value needs to be of the same type
19:35:48 <wilornel> if I'm returning an Int no matter what the first argument is, the types of the input and output wont match
19:36:30 <wilornel> if I assume that the input is `Num a`, then I can assume that the output is `Num a` and I can return Int in that case 
19:37:58 <wilornel> even though Int < a , and Int < Num, only Int < Num, with constrained/ad-hoc polymorphism works, because we can only get and do return something in Num
19:38:31 <wilornel> in the case of Int < a, with full-on polymorphism, the input type could be Num but it could also be String, and then it does not make sense to return Int
19:39:14 <EvanR> wilornel: is that supposed to be subtyping, that is not the right way to think of type classes or polymorphism
19:39:44 <wilornel> In functional programming class we learned about this syntax between types. I think it was something like Int < Num or Int < a. Meaning that Int is a more specific type than Num and a. Is there such a way of doing comparisons between types in Haskell, I wonder?
19:39:57 <EvanR> actually what is < supposed to be there
19:40:06 <Welkin> Num is not a type
19:40:09 <Welkin> Int is a type
19:40:12 <Welkin> Num is a typeclass
19:40:18 <wilornel> ah yes
19:40:19 <Welkin> a is a type variable
19:40:54 <wilornel> You can't say that Int is more specific than a?
19:41:02 <Welkin> it is
19:41:03 <EvanR> wilornel: there is no relationship like that... but you can say Int is an instance of the Num class, or that it has an implementation for the Num class
19:41:09 <Welkin> because `a` is a variable
19:41:14 <wilornel> yeah
19:41:17 <Welkin> it could be anything withint the type constraint that is given
19:41:19 <Welkin> if any
19:41:20 <EvanR> Int is a specialization of the polymorphic type forall a . a
19:41:31 <EvanR> two different issues going on 
19:41:33 <Welkin> otherwise, haskell has an implied `forall` on type variables
19:41:57 <wilornel> yes
19:42:15 <EvanR> neither Int -> b or a -> Char are more specific than each other, so youre getting into a partial order at best
19:43:11 <EvanR> think of forall a b . a -> b as ready to take a substitution for a, e.g. forall b . Char -> b
19:44:08 <wilornel> I see. I think I'll need to practice my intuition a little bit
19:45:03 <EvanR> in forall a . Num a => a -> a, youre ready to substitute, say Num Int => Int -> Int, and then you can only proceed if you have an instance of Num for Int
19:45:25 <EvanR> ghc does the finding of instances for you
19:46:22 <EvanR> the instance is concretely some bundle of functions (+) (*) negate and fromInteger (etc) for your type
19:48:30 <wilornel> Yes!
19:49:34 <wilornel> I wonder, all of these definitions ,  lke Num and Real and Int might not have been existant or created properly in the past. When the lagnague evolves, the contributors fix these types and typeclasses hierarchies,. Have there been problems wit hthis? back compatibility problems? 
19:50:08 <EvanR> sure
19:50:23 <EvanR> and then people fix their code
19:50:33 <EvanR> or continue to use old ghc
20:48:56 <Lokathor> does JuicyPixels have a way to flip an image?
20:49:01 <Lokathor> i'm not seeing anything ready made
20:52:07 <EvanR> its based on REPA right, maybe look there
20:53:28 <Lokathor> JuicyPixels-repa seems to be a different package
20:53:59 <Lokathor> hmm, https://www.stackbuilders.com/tutorials/haskell/image-processing/ oh my
20:54:02 <EvanR> hrm, maybe basic JuicyPixels is just for loading and saving
20:59:26 <geekosaur> that is my understanding, yes
22:12:45 <zetetetete> What's better, haskell or OCaml?
22:13:24 <cocreature> zetetetete: that depends on who you ask :)
22:15:19 <zetetetete> I've heard that Haskell is for "pretentious academics writing experimental and impractical features based on research papers"
22:15:36 <capisce> you've been misinformed
22:15:37 <c_wraith> it does work for that.
22:15:44 <c_wraith> It also works for building real-world software
22:16:02 <c_wraith> it's a multi-purpose language
22:17:03 <c_wraith> It also works for non-pretentious academics advancing the state of the art in practically useful type theory.  Quite of lot of that going on.
22:17:56 <glguy> I heard if you pressed A right when the Pokeball closes that it helps catch the Pokemon
22:18:33 <systemfault> Does it work for pretentious non-academics writing real-world software? :)
22:18:41 <c_wraith> systemfault: it works for me!
22:18:46 <systemfault> <3
22:19:35 <systemfault> glguy: It worked in Yellow, I'm pretty sure... (The only version I played a good 15 years ago)
22:21:14 <c_wraith> crazy how 15 years ago, pokemon was an old series.
22:23:22 <laxbro> What's up!
22:24:08 <c_wraith> ahoy, laxbro 
22:24:26 <vimalloc> So if I had something that could be computed in either applicative or monad, should I prefer one over the other? 
22:24:49 <c_wraith> vimalloc: Well..  is the computation different either way?
22:25:04 <vimalloc> No, end result would be the same going either route?
22:25:18 <c_wraith> Sure, but it might be more efficient one way or another.
22:25:20 <vimalloc> er, s/\?//
22:25:26 <cocreature> vimalloc: do you mean that you can generically compute it for all instances of Applicative or that you are working with a fixed type but you can use its Applicative instance or its Monad instance?
22:25:48 <vimalloc> cocreature: fixed type
22:26:21 <c_wraith> Applicative can be better optimized, but it isn't always.
22:26:35 <cocreature> for most types, it probably doesn’t matter
22:27:15 <c_wraith> I do often prefer Applicative if it makes my code shorter.  I wrote some parsers last night that were 5 lines using do notation and 2 lines using Applicative combinators.  They're pretty similar in readability.
22:27:47 <vimalloc> Sweet, so basically pick the one that is easier to read, and worry about optimization later as needed?
22:27:48 <c_wraith> Well, the Applicative stuff is more dense - might be slower to read the first time.
22:27:56 <c_wraith> vimalloc: absolutely.
22:28:27 <vimalloc> thx guys :)
22:29:53 <cocreature> there are some types where the Applicative instance actually behaves differently. perhaps the most popular one is haxl but that’s rare enough that if you’re using such a type you’re probably aware of it
23:59:58 <turbo_> h
