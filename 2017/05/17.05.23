00:00:33 <hanna> Hooray, with the `extern` added it builds!
00:00:38 <cocreature> LiaoTao: I’m maintaining Haskell bindings for llvm, so I’m quite used to those kind of problems :)
00:00:43 <hanna> Still confused about why that xapian-haskell thing doesn't need to mention libstdc++
00:01:20 <ongy> if you are linking an .so file, you get that from the .so file. When you just link a bunch of objects, you don't have that information
00:02:36 <LiaoTao> cocreature: That sounds like a lot of work for such a fast moving target
00:03:02 <cocreature> LiaoTao: tell me about it :)
00:03:54 <hanna> cocreature: you wouldn't happen to know how I can `cabal repl` without it crashing with an error message like “can't relocate, recompile with -fPIC”? :D
00:04:20 <hanna> for the record I already tried adding -fPIC to my cc-options
00:05:12 <cocreature> hanna: are you on 8.0.1 or earlier? iirc there was some bug that has been fixed in 8.0.2
00:05:35 <hanna> I'm on 8.0.2
00:06:55 <hanna> It seems like there's no cbits.dyn_o at all either
00:07:02 <hanna> looking at for example https://github.com/vimus/vimus/blob/master/cbits.o
00:08:07 <hanna> ah it invokes ghci with -lncursesw and the name of the .dyn_o
00:08:40 <hanna> it works with cabal repl --ghc-options="-lxapian -lstdc++"
00:08:48 <hanna> that seems like a cabal-install bug report
00:09:00 <hanna> It should load the extra-libraries when running `cabal repl`
00:09:08 <Lokathor> so sometimes you don't want to INLINE a function because it can make functions too large to fit properly in the cache and stuff, right?
00:09:18 <Lokathor> but is there a downside to putting INLINABLE on everything?
00:09:38 <cocreature> ghci and external C libraries seems to break half of the time for reasons that I haven’t yet figured out
00:17:34 <quchen> Lokathor: I’m not sure what INLINABLE does, but could it lead to giant header files all the time?
00:18:25 <Lokathor> quchen, yeah, INLINABLE keeps the definition around in the header files of packages you're depending on so that GHC will consider inlining it later on during a final build
00:18:49 <Lokathor> but, like, disk space is pretty cheap and all
00:28:06 <EvanR> heh... ghci... which "ignores -threaded"... will take a threadDelay 1000000 and sleep for a clean 2 seconds
00:28:17 <EvanR> lovin it
00:29:05 <EvanR> i do have several other threads
00:29:13 <EvanR> but wow
00:31:12 <merijn> Well, threadDelay does specify it won't sleep *less* than specified, it *might* sleep more than specified
00:31:48 <EvanR> it should sleep more than specified
00:31:51 <EvanR> not less
00:32:13 <merijn> sleeping 2 seconds for 1,000,000 is more?
00:32:32 <EvanR> and i get the same effect with compiled -threaded... so much be a bug on my part
00:32:43 <merijn> EvanR: Are you making the rookie mistake of assuming threadDelay takes seconds as argument?
00:32:51 <EvanR> o_O
00:33:00 <merijn> EvanR: Docs say it takes microseconds :)
00:33:13 <merijn> So 1,000,000 == 1 second :)
00:33:13 <EvanR> millions of seconds? i would have had to be debugging this for a while
00:33:25 <EvanR> merijn: it wakes up 2 seconds later, 2000000
00:33:39 <merijn> EvanR: Right, but that's more then 1 second, so that's fine
00:33:45 <EvanR> no it is not
00:34:09 <EvanR> ive never seen that kind of lag with -threaded, its a bug, probably my mistake
00:34:19 <merijn> Well, maybe not for your usecase. But it's within the definition of threadDelay
00:34:28 <merijn> "There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified."
00:34:40 <EvanR> i have seen threads do hundreds of ms over without -threaded
00:34:50 <EvanR> its usually much better with -threaded
00:35:43 <merijn> EvanR: Well, it's the single threaded runtime and you have multiple threads, yes?
00:36:12 <EvanR> same effect with ghc and -threaded
00:36:15 <merijn> EvanR: When the time out expires the thread is marked as "runnable" again, but if there's other threads in the queue those will run first and delay it
00:36:43 <merijn> EvanR: If you have the threaded runtime there's less chance of the queue of runnable thread being full and thus needing to wait long
00:37:03 <EvanR> yes ive gotten really good response times with -threaded
00:37:23 <Lokathor> i always forget that you can't shadow a variable based on its own definition in Haskell
00:37:27 <EvanR> able to wake up in time to schedule events for the audio system
00:37:50 <merijn> EvanR: Yeah, I wouldn't use threadDelay for that
00:38:08 <EvanR> its fine because you include the timestamps
00:38:15 <EvanR> as long as you dont wake up too late
00:38:16 <merijn> EvanR: I'd probably dedicate a capability to that thread and spinloop with unsafe foreign sleeps
00:38:37 <EvanR> worked great in my audio tests
00:38:44 <merijn> EvanR: "as long as you dont wake up too late" <- well, that's exactly what threadDelay doesn't guarantee :)
00:38:51 <EvanR> nothing guarantees it
00:39:00 <EvanR> multitasking OS
00:39:24 <merijn> EvanR: Sure, but you can get closer than that :p
00:39:36 <EvanR> yeah, by figuring out how i messed up
00:39:55 <EvanR> its almost exactly 2x too long
00:40:23 <merijn> Actually, I would probably fork a new pthread in C, mark it high priority with the kernel and do the looping there, so you have almost no chance of missing the deadline
00:40:35 <EvanR> thats... so unnecessary
00:40:54 <merijn> Unnecessary engineering is my middle name :)
00:40:57 <EvanR> and renders the thread unable to be killed
00:43:18 <EvanR> and spinlooping defeats the entire purpose of sleeping
00:43:43 <merijn> Not a tight spinloop, a sleeploop, but with high prio thread so it gets run immediately on wakeup
00:46:07 <EvanR> example of it "should work", in the first half of my test i get 1.000000000 1.005546132. first number is when something should happen, second number is when i woke up and realized it
00:46:12 <EvanR> how it*
00:46:34 <EvanR> using STM
00:58:54 <felixphew> hi!
00:59:22 <felixphew> I'm trying to get my head around parsec, but I don't seem to be getting it
00:59:38 <felixphew> I think it may be because the language I'm trying to parse is more complex than I think it is
01:00:01 <felixphew> as an example, the first line of each "group" can take one of these formats:
01:00:04 <felixphew> http://lpaste.net/4977949018270203904
01:00:35 <felixphew> is it possible to parse something like this with parsec? How would I go about it?
01:02:58 <quchen> felixphew: First, you must know what you want to parse to, i.e. have a data type that you want to generate from the text.
01:03:05 <merijn> felixphew: Well, whether you can parse it depends on a few things
01:03:18 <merijn> felixphew: Specifically, how are Name and Nickname different?
01:03:27 <merijn> felixphew: If the answer is "they aren't", you're boned
01:03:48 <felixphew> every set must have a "Name"
01:03:49 <merijn> oh, wait, maybe I wasn't reading the example right
01:04:19 <merijn> felixphew: Yes, but are names the same thing as nicknames? i.e. can something be both a valid name and a valid nickname?
01:04:34 <felixphew> yes, unfortunately
01:04:44 <felixphew> there are ~700 valid names
01:04:52 <merijn> What's M?
01:04:54 <felixphew> but a nickname can contain anything except a newline, basically
01:05:03 <LiaoTao> merijn: Are you sure he's boned?
01:05:10 <felixphew> M is a gender (as opposed to F), and is optional
01:05:13 <LiaoTao> I don't think there are any ambiguities
01:05:27 <merijn> LiaoTao: Yeah, I thought there was an inverted case, but it's not there
01:05:38 <merijn> Should be fine, albeit a bit inefficient to parse (lots of backtracking)
01:05:53 <merijn> felixphew: I'd recommend as a first step to write an EBNF of your language
01:06:06 <quchen> felixphew: 1. write individual parsers that parse Name, Nickname, Item, M.
01:06:07 <felixphew> The complicating factors as far as I can see it are 1) the number of forms, and 2) the fact that Nickname can contain both @ and ()
01:06:28 <merijn> felixphew: I'
01:06:29 <LiaoTao> ^ This is a bigger problem
01:06:36 <merijn> oh...
01:06:47 <merijn> felixphew: Can nicknames contain spaces?
01:06:52 <felixphew> yes
01:06:57 <quchen> Wait, so the line »Nickname Nickname Nickname (Name Name)« is valid for line 2?
01:06:59 <quchen> You’re boned.
01:07:05 <felixphew> Only 1 name
01:07:06 <merijn> You're boned
01:07:08 <quchen> :-S
01:07:12 <LiaoTao> Yeah
01:07:16 <merijn> Absolutely zero chance
01:07:17 <quchen> Is »Name Name« a valid name?
01:07:19 <quchen> Uuuuh.
01:07:37 <felixphew> Let me clarify a few things
01:07:43 <merijn> felixphew: Where are you getting this data from?
01:08:02 <felixphew> it's actually a format used to store Pokemon sets (no joke)
01:08:09 <felixphew> I didn't invent this stupid grammar
01:08:20 <quchen> Hello, my name is »Nickname (Name) (M) @ Item«
01:08:29 <felixphew> some examples of what it looks like:
01:08:29 <felixphew> http://pokepast.es/6fe3927d2f283a23
01:08:31 <taksuyu> Pokemon data should have byte limits
01:08:35 <merijn> felixphew: Sure, I realise that. Because even a complete beginner would design an easier grammar ;)
01:09:16 <merijn> felixphew: The question is: Is there an unambiguous separator that separates names/nicknames?
01:09:23 <felixphew> brackets
01:09:24 <quchen> That doesn’t look like »Nickname (Name)« at all! That looks like an HTML page with pictures.
01:09:33 <felixphew> ha ha
01:09:43 <merijn> felixphew: That's not unambiguous, since brackets are valid in names according to you?
01:09:44 <felixphew> those are 6 examples of the grammar I want to parse
01:09:55 <felixphew> brackets are valid in nicknames, but not names
01:10:04 <felixphew> and if a nickname is specified a name must also be specified
01:10:20 <felixphew> so the name will always be surrounded by the rightmost pair of brackets (if there are any brackets)
01:10:29 <merijn> felixphew: And nicknames cannot contain spaces?
01:10:36 <felixphew> nicknames can, unfortunately
01:10:39 <felixphew> so can names
01:10:43 <felixphew> and so can items
01:10:44 <quchen> … some example data would be in order.
01:11:02 <felixphew> that link contains 6 examples, but they're all in the same form
01:11:02 <quchen> The HTML page you linked does not match your examples from the paste above.
01:11:14 <merijn> well, how would you deal with the nickname "foo ) bar"?
01:11:16 <felixphew> look at the first line of each block
01:11:19 <felixphew> they do match
01:11:19 <LiaoTao> felixphew: Are you sure the names can contain spaces? Can't think of any pokemen with a two-word name
01:11:26 <merijn> felixphew: That'd look like "(foo ) bar)"
01:11:36 <merijn> But you'd probably parse that as "foo "
01:11:38 <felixphew> Tapu Koko / Tapu Lele / Tapu Bulu / Tapu Fini
01:11:44 <LiaoTao> Bleh
01:11:53 <felixphew> are the 4 space-containing pokemon names
01:11:54 <LiaoTao> Life was easier in the nineties
01:12:04 <merijn> Rather then trying to reverse engineer this grammar, I repeat my suggestion that felixphew writes down an EBNF
01:12:21 <felixphew> merijn: I'll try and do that
01:12:35 <merijn> felixphew: Here's a good description of EBNF (it's a bit focussed on binary format, so feel free to tweak it a bit to be more sensible for letters): https://tools.ietf.org/html/rfc5234
01:12:51 <LiaoTao> You may be able to match against those names to filter out all the names with spaces and then do the general case
01:13:02 <merijn> felixphew: This will also help you think about what you *really* mean :)
01:13:09 <LiaoTao> Listen to merijn, though, he _knows_ stuff
01:14:08 <merijn> Not sure you should listen to me, I'm currently considering the introduction of higher order bash functions and building a "library" of bash functions to cleanup my config. So I'm clearly not quite sane :p
01:14:08 <felixphew> thanks everyone!
01:14:21 <felixphew> I'll be back (hopefully) with some EBNF
01:16:45 <EvanR> merijn: explanation... i was actually waking up too early, because of lazy evaluation. the choice to sleep caused the time to force,which took exactly 1 second, so i didnt know what time it was. the fact that i was already printing the time out... i didnt notice it block because of line buffering!
01:17:23 <EvanR> so blocking too a second, and then it did a thread delay, adding additional delay
01:17:37 <EvanR> confluence of weirdness
01:18:12 <EvanR> ! fixed it
01:18:16 <merijn> o.O
01:18:35 <merijn> EvanR: That must've shaved some days of your life due to frustration :p
01:19:13 <EvanR> "are your debug prints working properly"
01:19:18 <EvanR> i take this for granted
01:19:23 <EvanR> stupid
01:20:32 <EvanR> time be a harsh mistress
01:22:09 <bollu> is it "worth" reading about lazy data structures? in the sense that, does it teach you cool things that you would not have known?
01:22:17 <bollu> I was considering taking up an independent study
01:22:27 <bollu> but I'm not sure if it's worth the time. Thoughts?
01:22:54 <merijn> There's some cool tricks
01:23:10 <merijn> But there's lots of cool tricks. I'd recommend focusing on the ones that'll help do what you want
01:23:42 <bollu> merijn: well, I have no real "aim", just want to understand how to exploit laziness
01:26:52 <halogenandtoast> Can anyone make suggestions on how they would separate the code in this Spock app? I can't decide which files are worth creating and I'm not sure of existing conventions. https://github.com/halogenandtoast/mirin/blob/master/app/Main.hs
01:27:13 <EvanR> bollu: i was just looking at a reversible incremental fold... 
01:27:15 <halogenandtoast> So currently everything is in one file, and I'm not happy abou tit.
01:27:20 <EvanR> laziness is awesome
01:27:34 <EvanR> unless it causes debug prints to appear to happen at a different time than they do
01:27:50 <halogenandtoast> EvanR: That's a feature!
01:27:52 <halogenandtoast> :p
01:28:33 <merijn> halogenandtoast: That's only a 100 lines, why would you split it?
01:28:54 <halogenandtoast> merijn: I generally like splitting concepts.
01:29:05 <halogenandtoast> Even if it's small
01:29:17 <EvanR> if its small, seeing everything on the same page is a +
01:29:27 <merijn> halogenandtoast: splitting a 100 line file of which only like 65 are code I'd really advice not to
01:29:51 <halogenandtoast> Fair enough.
01:30:00 <halogenandtoast> "I wouldn't split it" is a valid response
01:30:09 <halogenandtoast> I'll leave it as is.
01:30:38 <merijn> If you start expanding things beyond this, then I'd start to think about it, but only if it was expanding significantly
01:31:10 <halogenandtoast> merijn: Sure, and then I'd assume I'd look at the "patterns" of expansion.
01:31:13 <halogenandtoast> And isolate them.
01:32:34 <halogenandtoast> Thanks for the advice merijn  and EvanR 
01:32:57 <merijn> Is there a good vim syntax highlight file for GHC core?
01:35:12 <halogenandtoast> merijn: is there something the built in haskell syntax highlighter doesn't do?
01:38:06 <merijn> hmmm, I tried ghc-core's output before, but maybe the haskell highlight works passably too...
01:43:40 <quinor> hey, any neat way to divide [Type] by constructor of Type being used?
01:44:13 <EvanR> there are type families
01:44:35 <EvanR> which are like type functions
01:44:42 <quinor> what I'm trying to do is to write simple programming language parser and toplevel definitions are mixed expressions, type declarations etc
01:45:05 <quinor> and I'd like to process ie. all type declarations at once
01:45:09 <merijn> quinor: oh, I get what you mean
01:45:13 <merijn> quinor: Yes, you can!
01:45:36 <merijn> > [x | x@Left{} <- [Left True, Right 'c', Left False, Right 'a']]
01:45:38 <lambdabot>  [Left True,Left False]
01:46:07 <merijn> Replace Left with the constructor of your choice :)
01:46:17 <quinor> so just filter by each of the expected constructors, right?
01:46:30 <merijn> quinor: That's what it's doing, yes
01:47:06 <merijn> quinor: Simplest way I'm aware off. You traverse the list multiple times, but in a programming language that list shouldn't be long enough for that to matter
01:47:16 <EvanR> i dont even see the matrix quit messages anymore, just blond brunette..
01:47:34 <quinor> thanks merijn, sounds like a reasonable way
01:47:50 <quinor> though I'll probably use partition or something
01:48:19 <merijn> quinor: Also, note the neat trick of using {} on non-record constructor to future proof it. That way it works even if you change the number of parameters of the constructor you use :)
01:49:10 <quinor> merijn: missed that, but seems very nice
01:49:34 <quinor> what element of syntax is that?
01:50:04 <merijn> quinor: Record syntax, it just happens that record syntax is legal on constructors that weren't defined using record syntax too :)
01:51:04 <merijn> It's very nice if you only care about a specific constructor, because if you have like "foo (Lambda _ _) = something" and you  decide you need an extra field in Lambda, that function breaks and you have to update it
01:51:19 <merijn> If you write "foo Lambda{} = something" it works, even if the number of fields changes :)
01:51:34 <merijn> Underappreciated Haskell trick of the day :)
01:51:58 <quinor> Haskell is full of tricks
01:52:20 <quinor> can I do mixed record/constructor type?
01:52:54 <vaibhavsagar> what do you mean?
01:52:57 <merijn> Yes, but it's generally not recommend since applying the record fields to the wrong constructor crashes
01:53:19 <merijn> @let data Foo = Foo { fooInt :: Int, fooChar :: char } | Bar Bool deriving (Show)
01:53:20 <lambdabot>  .L.hs:159:42: error:
01:53:20 <lambdabot>      Not in scope: type variable ‘char’
01:53:20 <lambdabot>      Perhaps you meant type constructor or class ‘Char’ (imported from Data.C...
01:53:29 <merijn> @let data Foo = Foo { fooInt :: Int, fooChar :: Char } | Bar Bool deriving (Show)
01:53:31 <lambdabot>  Defined.
01:53:46 <merijn> > fooInt $ Foo 4 'c'
01:53:48 <lambdabot>  4
01:53:54 <merijn> > fooInt $ Bar True -- whoops
01:53:55 <lambdabot>  *Exception: No match in record selector fooInt
01:54:04 <quinor> I see
01:54:59 <quinor> I've thought of more like shared parameters for all of the constructors
01:55:09 <merijn> That works, yes
01:55:32 <merijn> But if there's record fields which don't apply to each constructor you have the same problem
01:55:43 <quinor> data Foo = {fooName :: String, Foo | Bar} ?
01:55:58 <EvanR> wacky
01:56:04 <merijn> You have to write it out explicitly
01:56:07 <merijn> @undefine
01:56:08 <lambdabot> Undefined.
01:56:21 <EvanR> you can define an accessor function separately
01:56:35 <merijn> @let data Foo = Foo { fooName :: String } | Bar { fooName :: String } deriving (Show)
01:56:36 <lambdabot>  Defined.
01:56:40 <EvanR> then you dont have to commit to having (partial) accessors for the other fields
01:56:44 <merijn> > fooName $ Foo "test"
01:56:46 <lambdabot>  "test"
01:56:49 <merijn> > fooName $ Bar "test"
01:56:51 <lambdabot>  "test"
01:57:35 <quinor> I see :)
02:03:58 <quinor> oh hod why
02:04:05 <quinor> is it like that always? -.-
02:05:01 <EvanR> IRC gateways are annoying
02:05:17 <merijn> Just hide joins/parts :)
02:05:24 <bollu> I wonder if we can move this to Discord
02:05:31 <EvanR> lol
02:05:32 <bollu> #haskell, that is
02:05:38 <bollu> what? it's not _that_ crazy :P
02:05:42 <vaibhavsagar> hi, what can I add to the nix section of stack.yaml to make libmagic available?
02:05:53 <EvanR> yet another suggestion to move a huge open source project to a proprietary platform
02:06:01 <opqdonut> yeah :(
02:06:44 <vaibhavsagar> found it: 'file'
02:07:04 <bollu> wait, discord is not open source?
02:07:07 <bollu> damn, I thought it was
02:07:08 <bollu> >_<
02:07:25 <vaibhavsagar> bollu: Zulip!
02:07:37 <bollu> vaibhavsagar: I don't know what that is :)
02:07:42 <EvanR> its a for profit company
02:07:54 <EvanR> like slack
02:07:57 <vaibhavsagar> also an open source project
02:07:59 <vaibhavsagar> https://github.com/zulip/zulip
02:08:10 <vaibhavsagar> it's quite nice, I like it a lot
02:08:16 <halogenandtoast> quinor: I turned off all of those messages.
02:08:24 <halogenandtoast> I never see when someone joins/leaves/etc.
02:08:33 <vaibhavsagar> https://zulip.org/index.html
02:08:46 <halogenandtoast> so for a bit I had no idea what you were going on about.
02:09:00 <felixphew> I'm back!
02:09:08 <halogenandtoast> felixphew: congrats!
02:09:08 <saurabhnanda> How to have a sum-type (ADT) with a known set of string literals?  https://stackoverflow.com/questions/44130436/how-to-have-a-sum-type-adt-with-a-known-set-of-string-literals
02:09:12 <felixphew> my attempt at an EBNF grammar for the pokemon thing:
02:09:12 <felixphew> http://lpaste.net/3317955982411169792
02:09:17 <saurabhnanda> I'm trying to work directly with the string literals that a remote API provides, instead of first mapping them to a regular Haskell sum-type/ADT and having to write serialisation and deserialisation functions for it.
02:09:29 <felixphew> it's simplified, but accurately portrays all the parts I was having trouble with
02:09:43 <bollu> vaibhavsagar: ah, cool
02:09:45 <opqdonut> saurabhnanda: no, that's not possible
02:10:03 <saurabhnanda> opqdonut: what about type-level literals?
02:10:17 <EvanR> bollu: i owe most of my life to freenode IRC, the amount of people and information all in one place... i see slack teams and discord one-off topic servers as not the right way to run a community
02:10:28 <opqdonut> saurabhnanda: hmm ok I don't know if those have strings yet
02:10:33 <opqdonut> oh they do
02:10:39 <merijn> felixphew: The hard bit will be distinguishing when a nickname has ended, the rest should be pretty trivial
02:10:44 <bollu> EvanR: I agree, I love IRC as well. But I've had people reject IRC because it's too old
02:10:56 <bollu> EvanR: so I'd like to move to a new platform for people who find IRC hard to adopt
02:10:57 <halogenandtoast> bollu: that seems silly
02:11:03 <bollu> saurabhnanda: howdy, how's it going?
02:11:05 <bollu> halogenandtoast: indeed
02:11:09 <cocreature> I’ve rejected people because they said irc is too old
02:11:14 <EvanR> bollu: so you go from 100000 people to 3... for that person
02:11:14 <bollu> cocreature: :P
02:11:19 <felixphew> the way I was previously doing it was scanning for the rightmost ( in the line
02:11:24 <halogenandtoast> cocreature: had my wife said that, I would have left her
02:11:29 <halogenandtoast> luckily for me she doesn't know what irc is
02:11:30 <bollu> lol
02:11:38 <saurabhnanda> bollu: going good, but slow with Haskell.
02:11:40 <merijn> felixphew: Example, nickname "foo) (M" leads to -> "(foo) (M) (M)"
02:11:44 <bollu> saurabhnanda: I see :)
02:12:06 <saurabhnanda> EvanR: merijn: cocreature: pinging wrt https://stackoverflow.com/questions/44130436/how-to-have-a-sum-type-adt-with-a-known-set-of-string-literals
02:12:06 <EvanR> freenode is *the* place for open source project real time chat
02:12:09 <halogenandtoast> felixphew: merijn could you have a non printing terminator for names?
02:12:25 <merijn> halogenandtoast: He has an existing format, afaict
02:12:34 <halogenandtoast> Ah
02:12:35 <felixphew> unfortunately yes
02:12:59 <cocreature> saurabhnanda: I think opqdonut already answered your question. you can’t do this
02:13:01 <bollu> type level strings?
02:13:02 <halogenandtoast> When I did something like this for NLP using a BNF (not in Haskell) I had compilation stages
02:13:14 <halogenandtoast> where it would do passes and fill in unknowns
02:13:23 <EvanR> saurabhnanda: you can take the API documentation and generate the (normal) sum types using TH
02:13:24 <halogenandtoast> or combine nodes, etc.
02:13:28 <halogenandtoast> not sure that helps here.
02:13:29 <felixphew> merijn: that example doesn't actually work, unless you're thinking that M is the pokemon name
02:13:37 <saurabhnanda> cocreature: is that final? No extension, no type-level voodoo is going to help me here? Is this a good use-case for Haskell Prime?
02:13:50 <halogenandtoast> felixphew: do you have your sample input available?
02:13:52 <saurabhnanda> EvanR: not more boilerplate!
02:13:58 <EvanR> boilerplate?
02:14:07 <merijn> felixphew: The point is, how do you decide where the nickname ended?
02:14:07 <EvanR> this is boilerplate generation
02:14:12 <cocreature> I guess you might be able to do some terrible typelevel hackery but I doubt it’s worth it
02:14:16 <EvanR> what good are those string leterals?
02:14:51 <merijn> saurabhnanda: What do you mean "use-case for Haskell Prime"? Haskell Prime is the committee for the new report and they're unlikely to introduce new untested big changes
02:14:56 <EvanR> saurabhnanda: the same is done to retool code against a database schem, which may contain 100s of record types
02:15:00 <felixphew> I have some sample input if you want it
02:15:01 <cocreature> and pattern matching would most likely look like crap
02:15:40 <halogenandtoast> felixphew: yes
02:15:58 <EvanR> im not sure what the cases being strings gets you
02:16:04 <saurabhnanda> EvanR: boilerplate for boilerplate generation. I'm trying to avoid boilerplate in the first place. String literal <=> Haskell constructor is boilerplate.
02:16:21 <EvanR> i dont think either of us knows what the other is talking about
02:18:19 <EvanR> saurabhnanda: what im talking about would be automated
02:18:28 <EvanR> you dont write out any strings or constructors
02:18:42 <saurabhnanda> Isn't this a very real-life use-case? You have a field which can have a bunch of pre-defined string values. Why can't one use those string values and expect the compiler to ensure that only those string values are used everywhere?
02:19:01 <bollu> is it not possible to write TH that does this?
02:19:04 <felixphew> here's some example inputs:
02:19:04 <felixphew> Buzz buzz buzz (Buzzwole) @ Leftovers  
02:19:05 <felixphew> Ability: Beast Boost  
02:19:05 <felixphew> EVs: 252 HP / 252 Atk / 4 SpD  
02:19:05 <felixphew> Adamant Nature  
02:19:05 <felixphew> - Leech Life  
02:19:05 <bollu> takes the strings and creates a sum type?
02:19:08 <EvanR> bollu: yes
02:19:16 <EvanR> thats what im getting at
02:19:41 <felixphew> sorry about that, pasted the wrong thing
02:19:46 <felixphew> here's the sample input:
02:19:47 <felixphew> http://lpaste.net/8274617510674825216
02:19:52 <bollu> TH is cumbersome, though
02:19:53 <saurabhnanda> bollu: yes, it is possible to write TH. But that is not ideal. THAT is boilerplate. I need to solve a domain problem, and now I need to take a detour and write TH for some random boilerplate. Haskell is not helping me achieve higher real-life productivity.
02:19:56 <bollu> and the docs are… bad
02:20:04 <bollu> saurabhnanda: what is the domain problem?
02:20:25 <EvanR> saurabhnanda: what youre asking doesnt even make sense...
02:20:32 <EvanR> its both a string, and a type
02:20:36 <saurabhnanda> bollu: that is not completely relevant. Domain problem = stuff that gets me closer to what the market/customer wants. TH is not that direction.
02:20:45 <EvanR> its works like a string, and its checkable by the compiler
02:20:52 <saurabhnanda> EvanR: I'm sorry to disagree. Typescript already has this.
02:21:03 <EvanR> stringly typed code isnt checkable by a computer
02:21:17 <saurabhnanda> EvanR: again, check Typescript. 
02:21:18 <opqdonut> untagged unions and singleton types
02:21:20 <bollu> saurabhnanda: can you show me the typeScript code that does this?
02:21:23 <opqdonut> would enable this
02:21:32 <EvanR> unless youre simply asking that the constructors be spelled with a lowercase letter and have quotes in their name?
02:22:03 <saurabhnanda> EvanR: yes -- it could essentially be that.
02:22:07 <EvanR> and youre asking to be able to spell it all out, as boilerplate... the opposite of my suggestion
02:22:36 <bollu> saurabhnanda: if there was a library that solved this for you, would that be "acceptable"?
02:22:43 <vaibhavsagar> saurabhnanda: define and ADT and a special Read instance
02:22:49 <bollu> saurabhnanda: like, I'm trying to understand what part of the ecosystem is annoying
02:22:55 <saurabhnanda> typescript -- https://www.typescriptlang.org/docs/handbook/advanced-types.html
02:22:56 <EvanR> saurabhnanda: you can easily write a replace in the editor to convert the strings into proper constructor names
02:23:20 <EvanR> as a regex
02:23:28 <vaibhavsagar> data EventTable = Table1 | Table2 | SomeOtherTable
02:23:32 <opqdonut> EvanR: the issue isn't constructor names, it's the function String -> Maybe ("foo" | "bar") function
02:23:41 <EvanR> the parser?
02:23:49 <opqdonut> yeah
02:23:56 <saurabhnanda> EvanR: nope -- doesn't solve the problem. The FromJSON/ToJSON instances still need to be written.
02:24:07 <EvanR> why?
02:24:55 <bollu> saurabhnanda: what do you gain by having strings? like, I'm trying to understand the use-case for this
02:25:20 <saurabhnanda> data EventTable = ItineraryBookings | HotelBookings deriving (Eq, Show, Generic) ==> need to serialised/deserialised as “itinerary_bookings | “hotel_bookings” — what’s the fastest way to get this done? and btw, there are 30 such fields, with each field having at least 10 possible values
02:25:27 <EvanR> saurabhnanda is not literally asking for this... but some tool which lets you access the api easier than writing the code for it
02:25:42 <felixphew> I guess the question I should really be asking is: is Parsec the right tool for this kind of job?
02:25:43 <saurabhnanda> bollu: faster development cycle.
02:25:56 <saurabhnanda> **just look at how Typescript does this**
02:26:02 <EvanR> you have to write the translations, if someone didnt already do it for you
02:26:14 <EvanR> ive done this countless times in ruby, because its not something than can be automated
02:26:19 <merijn> felixphew: Not more or less right than any other
02:26:31 <EvanR> sometimes because the vendor messed up and gave crap libraries
02:26:36 <EvanR> sucks but there you have it
02:26:41 <saurabhnanda> EvanR: very impractical answer. I can already see an alternative by using string literals. Typescript allows me to do that -- I don't understand why Haskell doesn't allow me to do that.
02:26:42 <merijn> felixphew: The difficulty in your problem is not really something created by parsec, but something that will be hard in almost any parsing solution
02:26:43 <cocreature> you probably also don’t want your code to operate on actual string literals if there is only a fixed number of them. using separate constructors for that will be a lot faster
02:27:14 <EvanR> saurabhnanda: you can just use string literals if you want
02:27:19 <bollu> saurabhnanda: I believe it's a type system thing
02:27:36 <merijn> felixphew: So it's going to suck to write, regardless of what you write it in, sadly
02:27:37 <saurabhnanda> cocreature: that was my core question. I don't care what the compiler sees the literals as. I want to type & read what I see in the API docs. Not some mapping that I have to first spend time writing, and then maintaing.
02:27:41 <EvanR> then youll have even less code for it than type script
02:28:06 <EvanR> saurabhnanda: thats why you generate the bindings, which is something youd really want to do in other languages too
02:28:08 <halogenandtoast> felixphew: you're back. Yeah having written stuff with parsers before I agree with merijn it's going to suck
02:28:17 <bollu> saurabhnanda: do you have a consistent naming convention conversion? like, MicrosoftCase <-> camel_case? then you'll have to write some boilerplate TH, I think. 
02:28:19 <EvanR> i guarantee you the vendor is doing that for languages they care about
02:28:27 <hanna> 09:08 <hanna> it works with cabal repl --ghc-options="-lxapian -lstdc++"
02:28:28 <halogenandtoast> felixphew: is user chars and game chars were swapped
02:28:31 <halogenandtoast> it would be easier
02:28:36 <EvanR> this usage of the word boilerplate makes no sense
02:28:38 <hanna> This seems like it was a red herring; what actually made it work was adding -fPIC
02:28:43 <halogenandtoast> but according to your grammar ( and ) can be in nicknames
02:28:50 <felixphew> I wish
02:28:50 <hanna> But the time I used cabal repl --ghc-options made it rebuild with fPIC
02:29:11 <felixphew> I guess in the meantime I could write a version that doesn't correctly handle brackets in nicknames
02:29:18 <hanna> I don't know why `cabal repl` didn't work the first time I added fPIC; maybe I forgot to save or maybe it needed a `cabal clean`
02:29:23 <felixphew> I could get away with that for a little bit
02:30:02 <EvanR> saurabhnanda: you can also write a script to convert the docs into code using whatever language you like
02:30:20 <bollu> technically, isn't this a Pi type? Pi(x: String) -> U ?
02:30:27 <bollu> where U is the "ADT" version of the strings?
02:30:34 <halogenandtoast> felixphew: you can cheat a bit
02:30:44 <felixphew> halogenandtoast: how?
02:30:45 <halogenandtoast> The names of Pokemon is currently a finite list.
02:30:51 <halogenandtoast> s/is/are/
02:31:08 <EvanR> bollu: if youre going there.. its not right
02:31:10 <saurabhnanda> EvanR: No. You're not getting the point. I know it's possible via TH. But Haskell should make this stuff easier. It has a very real-life use-case. A problem which many other programmers would need to solve many times.
02:31:20 <EvanR> since not all strings are correct
02:31:43 <felixphew> It will always be a finite list, but given that (in this scenario) different formes have different names, there are something like 1000 potential valid pokemon names
02:31:46 <bollu> EvanR: hm, I se
02:31:48 <bollu> see*
02:31:49 <saurabhnanda> Why can't I simply do ''some_random_literal and get the compiler to accept it like any other ADT value?
02:31:49 <EvanR> saurabhnanda: yeah, and now we have 19 different API generator frameworks... with how much benefit
02:32:09 <bollu> EvanR: you're not being practical
02:32:12 <bollu> EvanR: this is an actual problem
02:32:13 <halogenandtoast> felixphew: yeah and you could have some jerk who names their Pokemon (Buzzwhole)
02:32:20 <halogenandtoast> err (Buzzwole)
02:32:21 <EvanR> more work was put into those frameworks than just writing the code to interface to the API
02:32:37 <EvanR> bollu: how?
02:32:54 <EvanR> saurabhnanda does not want to take any of the suggestions
02:33:18 <saurabhnanda> okay, I have a deadline to meet. This is becoming a round-robin argument now. Take a step back and prioritise real-life productivity and you will reach similar conclusions.
02:33:25 <EvanR> it could be worse, there could be no TH at all
02:33:43 <opqdonut> saurabhnanda: the bottom line is that haskell isn't very good at ad-hoc typing. it's a "types first" language
02:34:00 <opqdonut> saurabhnanda: compared to the various JS typing systems or clojure's spec or ...
02:34:36 <merijn> This discussion is becoming kinda pointless "This tool should exist to save me time" -> "well it doesn't" -> goto 1
02:34:38 <bollu> saurabhnanda: personal recommendation: write the TH you need, publish as a library.
02:34:55 <EvanR> or skip the type system and just use strings 
02:34:59 <EvanR> and aeson Value
02:35:03 <saurabhnanda> last question -- what magic incantation do I need to give Aeson to serialise/deserialise `data EventTable = ItineraryBooking | HotelBooking` to "itinerary_booking" / "hotel_booking"
02:35:06 <bollu> saurabhnanda: that way, yes you're putting in time you don't *really* have, but it's something that will help other people who adopt the language
02:35:09 <merijn> If tools don't exist, there's no point in complaining about it. You can either write the tool, or not and use some different solution
02:35:17 <felixphew> thanks for the help everyone, I learned plenty
02:35:24 <opqdonut> EvanR: to clarify, in typescript you could do something like this (paraphrasing): "foo" :: Val "foo"; "bar" :: Val "bar"; type FooOrBar = Val "foo" | Val "bar"; "foo" :: FooOrBar;
02:35:36 <bollu> saurabhnanda: I'd be happy to help with packaging hacked up TH neatly into a library, if you need volunteers or something
02:35:46 <hanna> Hmm. Is there some easy magic way to try building my library under different GHC / library versions to see how permissive I can make my .cabal?
02:35:49 <opqdonut> EvanR: and then have the compiler check that this is exhaustive: case x :: FooOrBar of "foo" -> True; "bar" -> False
02:36:01 <hanna> The one `cabal init` generated for me is basically restricted to 8.0.2 only
02:36:07 <hanna> but I suspect it should work for 7.x as well
02:36:33 <EvanR> opqdonut: i dont see how different this is from haskell
02:36:36 <EvanR> besides the spelling
02:36:41 <opqdonut> EvanR: and also get some sort of String -> FooOrBar function for free
02:36:53 <opqdonut> EvanR: or rather, String -> Maybe FooOrBar
02:36:53 <EvanR> automatic parsers?
02:36:54 <halogenandtoast> Is there any way to remove this duplication somehow: https://github.com/halogenandtoast/mirin/blob/master/app/Main.hs#L102-L104
02:37:02 <winter_> Why not use Generics @saurabhnanda
02:37:16 <merijn> hanna: Restricted in what way?
02:37:16 <opqdonut> EvanR: it's not different in terms of expressiveness, it's different in terms of developer experience
02:37:21 <EvanR> Generics might be able to pull that off, but i bet you need to do some work to set it tup
02:37:38 <halogenandtoast> I might be missing something obvious with using request inside of the call for getProvider.
02:37:40 <bollu> opqdonut: yes, thank you for putting it that way
02:37:54 <halogenandtoast> but me and IO haven't gotten along lately.
02:38:09 <EvanR> saurabhnanda: you should learn about Generics, which lets you automatically produce support for normal ADTs using yes... strings
02:38:17 <EvanR> and its easier than TH ime
02:38:21 <winter_> Yeah~
02:38:54 <hanna> merijn: restricted in the sense that it requires e.g. directory >=1.3 && <1.4; which conflicts with earlier versions of GHC
02:39:11 <hanna> even though the only function I need is “doesFileExist” which presumably exists in basically every version of `directory`
02:39:41 <hanna> Rather than go through and audit every API call by hand I figure it should be easy to try loosening the deps automatically by incrementlly trying older versions of ghc/library until it no longer works
02:39:55 <hanna> no longer works in the sense of no longer building
02:39:57 <EvanR> if youre having trouble for just one doesFileExist function, you could write your own
02:40:07 <saurabhnanda> I'll investigate all the funky stuff later... can someone please help me in a very pedestrian problem --  how do I get Aeson's generic JSON functions to serialise/deserialise `data EventTable = ItineraryBooking | HotelBooking` to "itinerary_booking" / "hotel_booking"
02:40:09 <EvanR> try to open the file, catch the exception and return False
02:40:11 <bollu> EvanR: I really don't think asking people to reach for more type-level stuff is the answer here :/
02:40:21 <EvanR> bollu: eh?
02:40:39 <hanna> EvanR: That's not the point; the point is that I have 20 dependencies and they're all so strict that even `hackport` rejects them (because it's not compatible with GHC 8.0.1!)
02:40:42 <EvanR> generics is powerful stuff
02:40:45 <bollu> saurabhnanda: you can write your own instances right? From/ToJSON?
02:40:55 <bollu> saurabhnanda: but you want something scalable I assume
02:41:12 <saurabhnanda> okay -- I found it... `constructorTagModifier` it was
02:41:23 <vaibhavsagar> halogenandtoast: if you define a function boiler = do {settings <- getState; req <- request; provider <- runSQL $ getProvider req; return (settings, req, provider)}
02:41:58 <hanna> Seems like maybe `stack` might be able to do what I want?
02:42:11 <vaibhavsagar> then you can use it in both places like `(settings, req, provider) <- boiler` maybe?
02:42:19 <bollu> saurabhnanda: neat
02:42:22 <saurabhnanda> and the 100% correct answer was `{constructorTagModifier=(camelTo2 '_')}`
02:42:49 <saurabhnanda> need a frikkin' big cookbook to get anything done fast in Haskell.
02:42:53 <bollu> saurabhnanda: to which question?
02:43:06 <saurabhnanda> how do I get Aeson's generic JSON functions to serialise/deserialise `data EventTable = ItineraryBooking | HotelBooking` to "itinerary_booking" / "hotel_booking"
02:43:18 <EvanR> the more time you waste complaining in here, the less likely youll meet the deadline
02:43:22 <halogenandtoast> vaibhavsagar: hmm, not as clean as I'd like but okay.
02:43:46 <halogenandtoast> I think I could get away without returning req though
02:43:48 <bollu> saurabhnanda: I see
02:43:51 <halogenandtoast> since I don't need it outside
02:44:12 <saurabhnanda> EvanR: over and out :)
02:44:31 <vaibhavsagar> halogenandtoast: you could define a record type for your fields if that would make things easier
02:50:57 <tobiasBora> Hello,
02:51:11 <saurabhnanda> hit a GHC bug it seems
02:51:50 <saurabhnanda> intero: panic! (the 'impossible' happened) (GHC version 8.0.2 for x86_64-apple-darwin):	initTc: unsolved constraints
02:51:50 <saurabhnanda>   WC {wc_insol =        [W] processEventLog_a2bkY :: _a2bkX[tau:1] (CHoleCan: processEventLog)} Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
02:52:40 <halogenandtoast> saurabhnanda: do you have another ghci/haskell session running
02:53:18 <saurabhnanda> what's the easiest way to check that? FYI I'm using intero and it's standard REPL
02:53:35 <halogenandtoast> I've had that happen with Yesod which auto compiles when I make changes and then trying to compile my yesod app myself while it's running.
02:53:58 <halogenandtoast> So do you have a web server of something running that auto compiles?
02:54:19 <hanna> I actually ran into a remarkably similar bug not too long ago; I think it may have been the same error
02:54:34 <hanna> That one was triggered by doing acid-state related stuff without {-# LANGUAGE FlexibleInstances #-}
02:54:40 <hanna> the template haskell expansions blew up
02:57:25 <tobiasBora> I think that my program used way to much memory. Basically the main structure of my program is a Matrix (Cell Rational Rational Rational Rational), of size 2x2. And I create a list of 4^7 elements of these matrix. I would expect my program to run using a memory of around 4^7 * 4 (the number of cells in the matrix) * 4 (the number of rational per cell) * 2 (a rational can be written as 2 integer) * 4 (an
02:57:27 <tobiasBora> integer fit in 4bytes). 
02:58:14 <tobiasBora> = 2.10^6
02:58:17 <tobiasBora> bytes
02:58:55 <tobiasBora> However, it seems to use much more that that. To be sure, I tried to run my program with the profiler:
02:59:15 <tobiasBora> myprog +RTS -N -hc -M500M
03:00:36 <halogenandtoast> vaibhavsagar: it was a bit of work, but I made it work
03:01:43 <saurabhnanda> halogenandtoast: I'm constantly reloading in the REPL with -fobject-code
03:01:55 <hanna> tobiasBora: Seems like you're forgetting to account for the overhead of the constructors
03:01:58 <tobiasBora> and indeed, it uses around 140M of memory
03:02:18 <halogenandtoast> vaibhavsagar: for your reference if you care: https://github.com/halogenandtoast/mirin/blob/master/app/Main.hs#L83-L88
03:02:41 <halogenandtoast> getting the type correct was difficult as usual
03:02:54 <tobiasBora> (I forgot to say that I need in fact two times this structure)
03:03:11 <hanna> if the memory usage is *significantly* more than you expect even when accounting for constructors, then maybe you're storing lots of thunks instead of forcing the value?
03:03:25 <tobiasBora> anc 4.10^6 << 1.4
03:03:28 <tobiasBora> oups
03:03:37 <tobiasBora> 4e6 << 1.4e8
03:03:55 <vaibhavsagar> halogenandtoast: awesome! thanks for the update :)
03:04:38 * hackage BioHMM 1.1.5 - Libary for Hidden Markov Models in HMMER3 format.  https://hackage.haskell.org/package/BioHMM-1.1.5 (FlorianEggenhofer)
03:04:48 <tobiasBora> hanna: even with the overhead of the constructors I can't have a factor of 70 between the theoretical value and the experimentation no?
03:05:19 <hanna> Seems unlikely. Even the absolute worst case (String) is only like 10x
03:05:36 <hanna> Isn't there a tool to analyze memory issues like this? threadscope iirc?
03:05:48 <vaibhavsagar> halogenandtoast: also you have a typo on line 107
03:06:07 <hanna> But when working with data this big it's probably a good idea to use memory-efficient structures to begin with
03:06:11 <hanna> i.e. Vector instead of []
03:06:20 <vaibhavsagar> 'settingsWithProvidder' -> 'settingsWithProvider'
03:06:56 <hanna> And using unpacked data types as your elements
03:07:05 <tobiasBora> hanna: Vectors are usable when the list is around 4^7 elements ?
03:07:11 <tobiasBora> well actually much more
03:07:16 <tobiasBora> here it's just a small example
03:07:32 <hanna> Vector has no practical length limit
03:07:34 <tobiasBora> but I'd like to go further 4^13 elements
03:07:51 <hanna> Are you trying to store it all in memory or are you trying to stream fuse it so you only need small parts in memory at once?
03:08:12 <tobiasBora> hanna: I need to perform a sort on these data, so I need to store all of them in memory
03:08:33 <hanna> Oh btw, something else to account for: Rational is Ratio Integer, not Ratio Int
03:08:36 <hanna> Integers are bignums
03:09:26 <tobiasBora> hanna: I saw that if the numbers are small enough, it's stored in a native int no?
03:09:38 * hackage ngx-export 0.3.2.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.3.2.0 (lyokha)
03:10:10 <hanna> tobiasBora: that's true; maybe it's flipping to gmp representation for some reason though?
03:10:57 <tobiasBora> hanna: I'll try to use Ratio Int explicitely
03:11:07 <hanna> Anyway, for both performance and memory usage it would probably be a good idea to switch to Data.Vector.Unboxed
03:11:18 <hanna> And using an in-place sort
03:11:55 <tobiasBora> inplace sort is a good idea indeed
03:12:04 <hanna> `vector` can do this
03:15:17 <tobiasBora> Hum... How is it possible to convert a Ratio Int into a Double ? I used fromRational when I used Ratio Integer, but it does not work anymore
03:16:13 <hanna> tobiasBora: realToFrac
03:16:28 <hanna> which is absolutely horribly named
03:16:50 <tobiasBora> Waou really? Amazing, thank you
03:16:56 <hanna> tobiasBora: or you could do it the old fashioned way
03:17:20 <hanna> (\(n :% d) -> fromIntegral n / fromIntegral d)
03:17:39 <hanna> (which realToFrac basically amounts to)
03:18:23 <tobiasBora> ok thank you
03:18:48 <tobiasBora> hanna: When you talk about vector that can do inplace sort, I should use this one: Data.Vector.Unboxed ?
03:19:05 <hanna> Unboxed will be the most efficient
03:19:11 <hanna> but Generic is easier to use
03:19:33 <tobiasBora> ok I'll try. By the way, Rational <-> Ratio Int does not change anything
03:22:05 <tobiasBora> hanna: Hum I'm thinking
03:23:19 <tobiasBora> Wouah
03:24:37 <tobiasBora> I just tried to replace a sort uniq function done manually based on sort, and I just replaced it with nubOrd (actually I used it before but I got some trouble using it), and now it uses much less data, only 10M
03:24:57 <tobiasBora> I'll try the version using vector
03:25:33 <hanna> well there's your problem
03:26:00 <hanna> 12:02 <hanna> if the memory usage is *significantly* more than you expect even when accounting for constructors, then maybe you're storing lots of thunks instead of forcing the value?
03:26:03 <hanna> seems like this was the case
03:28:33 <tobiasBora> hanna: I don't see why? I used a deepseq when I perform the sorting
03:29:49 <hanna> That's all I can guess without seeing the code
03:30:44 <tobiasBora> ok
03:30:54 <tobiasBora> By the way, I'll try the version using vector
03:31:15 <tobiasBora> but I don't see the sort option
03:31:21 <hanna> it's in package vector-algorithms
03:31:49 <tobiasBora> Data.Vector.Algorithms.Intro ?
03:32:20 <hanna> Every one of those modules implements some sorting algorithm :D
03:32:56 <hanna> if you're sorting huge lists of numbers you could try radix sort
03:33:01 <hanna> but that requires more work
03:33:06 <hanna> to implement the Radix function on your data type
03:33:38 <tobiasBora> Ok. Does one of them perform nicely in multithreading?
03:34:06 <hanna> I would imagine all divide-and-conquer algorithms work well with multithreading in principle but I don't know if any of them support it out of the box
03:34:58 <jadrian> am trying to install / use stack, but first try to run `stack setup` returned "Unable to find installation URLs for OS key: linux32-tinfo6"
03:35:33 <jadrian> the best I could find about this was that tinfo seems to be related with ncurses, but I do have it installed (including devel packages)
03:35:51 <jadrian> this is stack installed via curl, and no ghc in my system
03:36:19 <jadrian> any suggestions on how to go about fixing this? 
03:37:43 <quchen> jadrian: If the automatic script does not work, you can also download the binaries directly.
03:38:40 * hackage concurrent-extra 0.7.0.11 - Extra concurrency primitives  https://hackage.haskell.org/package/concurrent-extra-0.7.0.11 (BasVanDijk)
03:39:49 <quchen> jadrian: It seems you have a system Stack does not recognize.
03:39:56 <hanna> tobiasBora: upon closer inspection I don't think any of them will benefit from threads; since they all run in ST or IO - both of which impose a total order on modifications
03:40:05 <hanna> I don't think whether it would be easy to use threads with ST eitheR
03:40:14 <quchen> jadrian: But there are 32-bit binaries available! https://docs.haskellstack.org/en/stable/README/
03:40:39 * hackage nonce 1.0.3 - Generate cryptographic nonces.  https://hackage.haskell.org/package/nonce-1.0.3 (ErikDeCastroLopo)
03:40:42 <jadrian> quchen: I have openSUSE Tumblweed on a HP core i5
03:41:17 <quchen> jadrian: https://docs.haskellstack.org/en/stable/install_and_upgrade/#suse
03:41:56 <hanna> tobiasBora: If you absolutely want high performance sorts and threading, you could try using `repa`. That could also help you get rid of the nesting, i.e. you could use a single multidimensional repa array to store the entire spine of your structure down to matrices / 2x2 cells
03:41:59 <quchen> Oh, wait – you have Stack already, and it fails to setup! Sorry, I misread the entire thing.
03:42:11 <tobiasBora> hanna: Why? I don't see why a sort that sort the first half part and the second half in parallel wouldn't help (like fusion sort)
03:42:22 <quchen> jadrian: Have you tried running »stack upgrade« to get the newest version, should the package be outdated?
03:42:44 <jadrian> quchen: I thought of using the openSUSE binaries but this seemed safer 
03:42:49 <quchen> jadrian: If that doesn’t work, go for the generic tarball and install it manually
03:43:01 <hanna> tobiasBora: Yes I understand the theory, I'm saying that `vector-algorithms` will not benefit from threads
03:43:04 <jadrian> quchen: not really, just downloaded it now with curl so I thought it would be up to date, but let me try
03:43:10 <tobiasBora> hanna: oh ok
03:43:15 <quchen> If *that* doesn’t work then I’m out of ideas. hvr might know more, I think he battled OpenSUSE recently
03:43:23 <tobiasBora> hanna: Thank you for repa, I'll see what I can do with that
03:43:23 <jadrian> quchen: yeah it's up to date
03:43:26 <quchen> jadrian: Oh, the curl-from-haskellstack.org is up to date
03:47:00 <hanna> tobiasBora: with `repa` you could use a multi-dimensional array of size (10^6 :. 4 :. 4) that stores your rationals directly - you'd probably also want to use (Int, Int) instead of Ratio Int so you can use the unboxed representation
03:47:18 <jadrian> quchen: completely OT, this is an Intel i5-6200U... but `uname -m` reutrns i686
03:47:31 <jadrian> thought this should be 64 bit
03:47:39 * hackage pagination 0.2.0 - Framework-agnostic pagination boilerplate  https://hackage.haskell.org/package/pagination-0.2.0 (mrkkrp)
03:51:14 <hanna> tobiasBora: ah, actually, I don't think repa supports sorting
03:55:55 <tobiasBora> hanna: Hum ok too bad. By the way, do you have any idea to make "data Cell = Cell Q Q Q Q" an instance of the Unbox class?
03:58:02 <tobiasBora> I saw that https://hackage.haskell.org/package/vector-th-unbox-0.2.1.6/docs/Data-Vector-Unboxed-Deriving.html
03:58:08 <tobiasBora> not sure it's what I need
03:58:23 <hanna> seems like that would help you
03:58:39 <hanna> (you can probably also use Storable instead of Unbox)
03:59:22 <hanna> but that derivingUnbox example seems like you could copy/paste it and make a few tweaks
03:59:38 <hanna> 4-tuples are already Unbox instances so you can use the same trick of transforming it to tuples and back
04:07:23 <jadrian> quchen: I just realised I installed a 32 bit openSUSE distro on a 64 bit laptop... maaaybe that has something to do with it
04:07:57 <tobiasBora> Hum... I tried this: https://paste.debian.net/935539/
04:08:17 <tobiasBora> but I've an error Expecting four fewer arguments to ‘Cell’, Expected kind ‘* -> * -> * -> * -> *’, but ‘Cell’ has kind ‘*’
04:10:24 <tobiasBora> Oh I think I got it
04:10:49 <tobiasBora> yes
04:10:54 <tobiasBora> now much darkers errors:
04:11:11 <tobiasBora> The exact Name ‘a_acql’ is not in scope Probable cause: you used a unique Template Haskell name (NameU),perhaps via newName, but did not bind it
04:12:41 <tobiasBora> using this code: https://paste.debian.net/935552/
04:17:25 <ClaudiusMaximus> tobiasBora: should you have a => in the type after the unbox stuff instead of -> (hard to tell with my font and the unicode)
04:17:53 <ClaudiusMaximus> oh nevermind you do
04:17:59 <hanna> tobiasBora: what happens if you insert a space after the \ but before the (Cell a b c d)
04:18:19 <tobiasBora> hanna: same error
04:18:42 <hanna> I'm honestly sort of confused by the unicode though, i.e. the ∀ stuff
04:18:49 <tobiasBora> me too
04:18:57 <tobiasBora> I'll convert in non-unicode
04:19:01 <tobiasBora> I was just using the example
04:20:38 <tobiasBora> hanna: ClaudiusMaximus: Here is a better formating: https://paste.debian.net/935554/
04:21:28 <tobiasBora> and the errors: https://paste.debian.net/935555/
04:25:29 <hanna> tobiasBora: err
04:25:50 * tobiasBora need to go, but he will read everything when he'll be back
04:26:21 <hanna> tobiasBora: your Cell thing is not polymorphic
04:26:42 <hanna> you just need to write [t| Cell -> (Q, Q, Q, Q) |]
04:26:45 <hanna> instead of the polymorphic stuff
04:27:09 <hanna> (and also an Unbox instance for Q)
04:27:17 <ClaudiusMaximus> tobiasBora: but you'll need V.Unbox Q, which is problematic as Integer is variable sized (and Ratio Int is highly unsafe)
04:29:08 * hackage plan-b 0.2.1 - Failure-tolerant file and directory editing  https://hackage.haskell.org/package/plan-b-0.2.1 (mrkkrp)
04:37:39 * hackage microstache 1 - Mustache templates for Haskell  https://hackage.haskell.org/package/microstache-1 (phadej)
04:43:42 <hanna> ClaudiusMaximus: I guess if you really, absolutely wanted to support Integer you could store it as an Either Int Pointer, which unboxes the “common” case in exchange for needing an indirection for the uncommon case? no idea how difficult that would be to implement though
04:43:45 <hanna> or whether it would even be worth it
04:44:06 <hanna> Either Int Pointer of course being (Bool, Int)
04:53:36 <ClaudiusMaximus> hanna: i don't know if it's possible, where would you store the Map Int Integer (or similar) for the pointers?
04:54:00 <hanna> Integer is basically a pointer to a memory region isn't it?
04:54:17 <hanna> (the bignum variant)
04:54:49 <ClaudiusMaximus> hanna: Integer is a sum type of a small integer (Int) or a large integer (sign plus ByteArray# iirc0
04:55:29 <ClaudiusMaximus> the ByteArray# is immutable, and can be moved by GC afaik
04:56:20 <hanna> ah, things must have changed since I last poked around GHC data types
04:57:07 <hanna> I recall in the past it was essentially a ForeignPtr + length ?
04:57:12 <ClaudiusMaximus> i wrote some FFI wrappers for integer-gmp (the hgmp package) so I'm relatively familiar with the current version, but yes integer gmp is different from earlier versions
04:57:55 <ClaudiusMaximus> the earlier version required gmp custom memory allocators, which broke foreign code sometimes (eg making mpfr bindings next-to-impossible)
04:58:54 <hanna> ah neat
04:59:36 <merijn> I'm always impressed with the speed of GHCs libgmp bindings
05:00:32 <ClaudiusMaximus> probably comes from using the super-fast ghc allocator instead of malloc (possibly?) for every integer operation
05:00:43 <hanna> Wasn't there a bignum shootout that came to the conclusion ghc-gmp was faster than gmp in C
05:01:46 <merijn> C wasn't in it, but GHC did beat basically every other language's GMP bindings
05:01:47 <merijn> http://www.wilfred.me.uk/blog/2014/10/20/the-fastest-bigint-in-the-west/
05:38:11 <NickCage> Hello everyone, im trying to write a function that removes all Leafs in an n-ary tree structured like this NTree x = NLeaf x | NNode x [NTree x]. Advice is very appreciated. So far im having a function that removes every child, leaving me with the root of the tree (which is very wrong. :-))
05:39:41 <ongy> NickCage: Have you tried to write something with filter?
05:39:59 <saurabhnanda> what's the safest way to read a complete file in Haskell? I'm assuming it's not readFile because of laziness -- http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:readFile
05:40:15 <NickCage> ongy does filter work, when Ntree is set as its own datatype?
05:40:28 <ongy> saurabhnanda: do you want to have all of it in memory? And as String, bytestring, Text?
05:40:49 <ongy> NickCage: no, you will have to use a recursive function that applies filter
05:41:32 <saurabhnanda> ongy: all in memory. Figuring out why flavour of string does my processing function like. Gotta keep it happy.
05:42:13 <mauke> @let data NTree x = NLeaf x | NNode x [NTree x] deriving (Eq, Ord, Read, Show)
05:42:15 <lambdabot>  Defined.
05:42:21 <ClaudiusMaximus> NickCage: i'd use mapMaybe in a recursion
05:42:50 <mauke> NickCage: what should the function return for NLeaf 42?
05:42:58 <saurabhnanda> ongy: Text
05:43:03 <saurabhnanda> ongy: read an entire file as Text
05:43:32 <mauke> saurabhnanda: http://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-IO.html#v:readFile
05:44:46 <NickCage> mauke an empty list of the above node
05:45:20 <ski> what's the desired type of the function ?
05:45:24 <mauke> NickCage: why a list?
05:45:36 <mauke> when would it ever return multiple values?
05:46:11 <NickCage> mauke well, the Ntree is defined, so that it either has a Nleaf, or Nnode [Ntree]
05:46:21 <NickCage> with all children of the node lying in the []
05:46:46 <NickCage> and my goal is to remove every leaf in that list.
05:47:08 <mauke> you're repeating yourself without answering my question
05:47:18 <ski> so do you want `NTree a -> [a]' ? `NTree a -> [NTree a]' ? something else ?
05:47:44 <NickCage> Ntree a -> Ntree a
05:47:50 <NickCage> is the signature of the function
05:47:58 <mauke> that's not what you just said
05:48:08 <mauke> if it returns a tree, it can't return a list
05:48:09 <ski> well, you said to return an empty list in one case. the empty list doesn't have that return type
05:48:28 <mauke> > [] :: NTree a
05:48:30 <lambdabot>  error:
05:48:31 <lambdabot>      • Couldn't match expected type ‘NTree a1’ with actual type ‘[t0]’
05:48:31 <lambdabot>      • In the expression: [] :: NTree a
05:48:47 <NickCage> sorry, my bad. I couldnt put it into words
05:49:14 <NickCage> Ntree a -> Ntree a has to be the signature, and my goal is to remove every leaf in the tree and return the "new" one.
05:49:19 <NickCage> i hope this helps
05:49:35 <ski> which tree should the function return, when passed `NLeaf 42' as input ?
05:49:44 <ongy> NickCage: what's: rmLeaves (NLeaf 42)
05:49:50 <NickCage> that would have to raise an error
05:49:55 <NickCage> because there wouldnt be anything left
05:49:58 <ski> ok
05:50:12 <ongy> :(
05:50:13 <ski> how about `NNode 42 []' ?
05:50:20 <NickCage> this is allowed
05:50:58 <NickCage> so id just convert the NNode 42 [] into NLeaf 42
05:51:03 <mauke> wait, what?
05:51:16 <NickCage> or not?
05:51:21 <mauke> why do you have NLeaf in the first place, then?
05:52:01 <mauke> what are you using this data structure for?
05:52:06 <NickCage> thats a good point, maybe thats the tasks's intention
05:52:24 <NickCage> well its homework. and both, the data type, and the functions signature is given
05:52:24 <saurabhnanda> mauke: ongy: thanks
05:52:45 <tobiasBora> ClaudiusMaximus: hanna: Hum... I tried to use Ratio Int, but still not working...
05:52:49 <tobiasBora> Could not deduce (V.Unbox (Ratio Int))
05:52:59 <hanna> Yes there's no Unbox Ratio instance
05:53:02 <hanna> you'd need to write your own as well
05:53:06 <hanna> based on (Int, Int)
05:53:11 <tobiasBora> ok ^^
05:53:13 <mauke> NickCage: is the text of the assignment online somewhere?
05:54:37 <NickCage> it is, though in german.
05:55:44 <mauke> link?
05:55:45 <ongy> you can still post it, at least I can read it :)
05:56:12 <NickCage> http://www-stud.informatik.uni-frankfurt.de/~prg2/SS2017/aufgaben/teil1/blatt5.pdf
05:56:33 <NickCage> 1.e)
05:57:02 <mauke> well, that's vague
05:57:02 <tobiasBora> hanna: Hum... But how can I construct a Ratio Int? Because I tried "derivingUnbox "Ratio Int"", and I've an error "Ratio Int" is not a valid constructor suffix!
05:57:58 <ongy> "Fehlermeldung ausgeben" -> "output error message" well, tell them their type doesn't allow it, since output is IO :)
05:58:08 <hanna> tobiasBora: there's a Complex example, no?
05:58:23 <mauke> ok, looks like NNode 42 [] is supposed to stay NNode 42 [] because it's not a leaf (nominally)
05:58:40 <ski> NickCage : i don't interpret that as saying that `NNode 42 []' should be converted into `NLeaf 42'
05:58:56 <NickCage> ski you are right, that was me typing before thinking. :-)
05:59:01 <tobiasBora> hanna: Hum... I may need to use default here. Let me look at that
05:59:08 <quchen> Woah, manually inferring types. Your lecturer must hate you.
05:59:36 <ski> NickCage : so .. how about `NNode 0 [NNode 1 [],NLeaf 2,NNode 3 [NLeaf 4,NNode 5 [NNode 6 []],NLeaf 7,NNode 8 []]]' ?
06:00:01 <ongy> compute the type? Is that proper terminology?
06:00:27 <mauke> > let removeLeaves (NLeaf _) = error "empty tree is empty"; removeLeaves (NNode x children) = NNode x [ removeLeaves t | t@(NNode _) <- children ] in removeLeaves (NNode 0 [NNode 1 [],NLeaf 2,NNode 3 [NLeaf 4,NNode 5 [NNode 6 []],NLeaf 7,NNode 8 []]])
06:00:30 <lambdabot>  error:
06:00:30 <lambdabot>      • The constructor ‘NNode’ should have 2 arguments, but has been given 1
06:00:30 <lambdabot>      • In the pattern: NNode _
06:00:32 <hexagoxel> ongy: the docs on `error` "error stops execution and displays an error message."
06:00:49 <mauke> > let removeLeaves (NLeaf _) = error "empty tree is empty"; removeLeaves (NNode x children) = NNode x [ removeLeaves t | t@NNode{} <- children ] in removeLeaves (NNode 0 [NNode 1 [],NLeaf 2,NNode 3 [NLeaf 4,NNode 5 [NNode 6 []],NLeaf 7,NNode 8 []]])
06:00:51 <lambdabot>  NNode 0 [NNode 1 [],NNode 3 [NNode 5 [NNode 6 []],NNode 8 []]]
06:01:01 <ClaudiusMaximus> tobiasBora: the constructor for Ratio Int is hidden (to allow invariants to be preserved), you must construct them with (%)
06:01:06 <tobiasBora> hanna: Yes, it seems to work great, thank you
06:01:17 <ongy> hexagoxel: if we are allowed to do more than requested, entferneBlaetter = error "I removed everything" would be valid :)
06:01:24 <hexagoxel> ongy: i would not give a student any points if they choose to nitpick over the phrasing in such a way.
06:01:30 <ongy> since removing the entire tree also removes all leafs :D
06:01:43 <quchen> ongy: Sure, why not? You get a value and an initial environment, and compute the type of the value given that.
06:01:51 <ongy> hexagoxel: in homework I would nitpick, for exams I wouldn't
06:02:15 <ongy> quchen: I'm just used to infer/determine, but I guess compute does fit
06:02:33 <mauke> I'd totally submit that solution
06:02:33 <tobiasBora> ClaudiusMaximus: yes, I think I got it. For types like "data Color = Red | Blue", I think to remember that there is a function that bind it to a Int, but I can't find it anymore
06:02:43 <quchen> ongy: »determine« would maybe allow asking GHCi :-)
06:02:51 <ClaudiusMaximus> tobiasBora: deriving Enum and fromEnum/toEnum
06:02:52 <hexagoxel> some homework is precondition for admission to finals.
06:02:56 <mauke> teachers need to learn to write unambiguous specs
06:03:26 <hexagoxel> ongy: on the other hand i agree that the tasks are worded poorly in general.
06:03:29 <tobiasBora> ClaudiusMaximus: thank you! And then the good way to proceed is to bind it in a derivingUnbox right?
06:03:30 <quchen> mauke: That will show him!
06:03:36 <mauke> particularly when it comes to programming
06:03:52 <mauke> you can't just handwave your way around a bug in code: "oh, you know what I mean"
06:04:43 <NickCage> mauke im still trying to grasp your suggestion. Ive never seen the @ and {} parts before.
06:04:44 <sshine> but handwaving makes regular bugs go away!
06:04:48 <ongy> quchen: but compute doesn't? I just outsource the computation :)
06:04:58 <sshine> surely handwaving will make software bugs go away, too.
06:05:40 <quchen> mauke: I guess the »(polymorphic)« type of »curry fst« is a false statement, since »curry fst« has many polymorphic types. Therefore, »duck in rubber suit« is a correct answer.
06:05:46 <ongy> NickCage: t@(NNode _) is a pattern match that also names the thing that is matched t
06:05:47 <quchen> (For exercise 3)
06:06:37 <ongy> we should create an "improved" version of the assignment and sent it to the TAs :D
06:06:39 * hackage stm-split 0.0.2 - TMVars, TVars and TChans with distinguished input and output side  https://hackage.haskell.org/package/stm-split-0.0.2 (HenningThielemann)
06:07:25 <NickCage> and what does the {} brackets do in this case? ongy
06:08:11 <quchen> :t let isNothing Nothing = True; isNothing Just{} = False in isNothing
06:08:12 <lambdabot> Maybe t -> Bool
06:08:17 <quchen> :t let isNothing Nothing = True; isNothing Just whatever = False in isNothing
06:08:18 <lambdabot> error:
06:08:18 <lambdabot>     • Equations for ‘isNothing’ have different numbers of arguments
06:08:18 <lambdabot>         <interactive>:1:5-28
06:08:41 <quchen> NickCage: The {} just omits all fields since we only care about the constructor, not the field values
06:08:46 <quchen> :t let isNothing Nothing = True; isNothing (Just whatever) = False in isNothing
06:08:47 <lambdabot> Maybe t -> Bool
06:08:50 <ongy> NickCage: if you have Constructor{} that matches (Constructor _) (Constructor _ _) and so forth, it makes code more robust against changes
06:08:56 <quchen> Note the unused »whatever«.
06:09:12 <quchen> We could write »_« there, sure, but that gets tedious when there are many fields.
06:09:19 * ski would prefer `{_}'
06:10:10 <NickCage> ongy mauke quchen hexagoxel ski clever, thank you very much.
06:10:35 <quchen> NickCage: It’s a bit of abuse of notation, since {…} is usually used for pattern matching on records.
06:10:36 * ski still isn't sure mauke's solution is what NickCage had in mind
06:10:45 <tobiasBora> ClaudiusMaximus: Ok it works thank you. Now, I've one more step to do: is it possible to have an unbox instance for "V.Unbox (V.Vector Alpha)", when I've an instance for "V.Unbox Alpha" ?
06:11:18 <ClaudiusMaximus> tobiasBora: no, because things must have a fixed maximum size (constant for the type) to be able to be unboxed
06:11:49 <tobiasBora> ClaudiusMaximus: Ok too bad. So I'm stuck with boxes
06:12:33 <ClaudiusMaximus> tobiasBora: either that or (if the vector size is fixed) you could do tricks with statically-sized vectors (size mentioned in the type)
06:13:10 <tobiasBora> ClaudiusMaximus: Hum interesting...
06:13:23 <hexagoxel> ski: i think mauke's solution is what was intended by the tutor. not that the task makes any particular sense :/
06:13:39 * hackage tagged-identity 0.1.2 - Trivial monad transformer that allows identical monad stacks have different types  https://hackage.haskell.org/package/tagged-identity-0.1.2 (mrkkrp)
06:13:53 <ClaudiusMaximus> tobiasBora: then unboxing could map a 0 length vector to (), and length (n+1) to (vector :: length n, item)
06:13:54 <tobiasBora> ClaudiusMaximus: I see lot's of implementation: fixed-vector, vector-sized, sized-vector... Is one better than the others?
06:13:55 <ski> hexagoxel : that's not what i remarked on, though
06:14:00 <ClaudiusMaximus> tobiasBora: i don't know
06:15:15 <tobiasBora> ClaudiusMaximus: I think I see, but need to write it to be sure. I will let you know, thank you
06:15:45 <ClaudiusMaximus> tobiasBora: is unboxing really necessary?  does the boxing overhead cause you trouble?
06:15:58 <tobiasBora> ClaudiusMaximus: I don't know, I will test that
06:16:16 <merijn> Unboxing a vector doesn't really make sense
06:16:16 <tobiasBora> The think is that I use way too much memory
06:16:19 <merijn> Actually
06:16:28 <merijn> s/doesn't really/really doesn't
06:16:49 <tobiasBora> merijn: In fact, I don't really mind to unbox the vector
06:16:53 <hexagoxel> ski: ah, you mean a different formulation of the same semantics. yeah, that's fair.
06:17:26 <tobiasBora> but the thing is that I do a map on the vector of vector, and that I would like to unbox the output of this map
06:17:54 <tobiasBora> so if you have a nice way to do a map from a vector to an unbox vector, I think it would be nice
06:18:12 <ski> hexagoxel : .. or even a different semantics
06:21:39 <tobiasBora> Grrr
06:21:47 <tobiasBora> I don't understand why, but here: https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html
06:21:54 <tobiasBora> there is a "uniq" function
06:22:48 <tobiasBora> but when I use V.uniq, he tolds me "Not in scope: ‘V.uniq’ Perhaps you meant one of these: 'V.init' from Data.Vector
06:23:14 <bollu> I'd asked this question in the idris forums but no one replied. I was hoping maybe someone here would have an idea? https://groups.google.com/forum/#!topic/idris-lang/qcZNGHJGJQY
06:24:05 <ClaudiusMaximus> tobiasBora: it's new in 0.12, maybe you are using an earlier version
06:25:39 <tobiasBora> ClaudiusMaximus: ok thank you
06:35:50 <reuben364> If I have an (a,b), Prism' a c, Prism' b d, can I construct a Prism (a,b) (c,d) easily without using prism' or constructing it directly.
06:35:50 <reuben364>   
06:38:06 <reuben364> Context: I want to build a prism from a generic xml-like tree to specific data types.
06:38:39 <c_wraith> reuben364: I think alongside does what you want
06:38:58 <quchen> Yeah
06:39:05 <quchen> Just don’t ask for its type
06:39:10 <quchen> https://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-Lens.html#v:alongside
06:40:25 <reuben364> Scary.
06:44:03 <quchen> > view (alongside _1 _2) (("hello", "world"), (123,456)) -- reuben364 
06:44:05 <lambdabot>  ("hello",456)
06:46:43 <mauke> lens types: don't ask, don't tell
06:47:45 <quchen> Combining the joy of weak typing with the convenience of Agda
06:48:06 <quchen> Most things fit together and then do something, except when they don’t
06:49:28 <wilornel> Hey ##haskell! What are some nice functions I could read up on? Any beautiful definitions in the standard lib?
06:50:16 <merijn> wilornel: Depends, how theoretical do you like to get?
06:50:24 <quchen> wilornel: the list sorting algorithm.
06:50:45 <quchen> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.OldList.html#sort
06:50:50 <wilornel>  merijn: I love theory! Our courses this semester don't have much theory
06:51:00 <merijn> wilornel: In that case: fold!
06:51:22 <merijn> wilornel: Specifcally: http://eprints.nottingham.ac.uk/224/1/fold.pdf
06:51:49 <merijn> wilornel: Or "proof that any recursive function can be written as fold + trivial helper"
06:52:05 <merijn> but yeah, sort is nice too
06:52:20 <quchen> merijn: surely fix counts as a trivial helper
06:52:33 <wilornel> Thanks merijn and quchen , checking them out
06:52:47 <merijn> wilornel: Also, this beauty: https://gist.github.com/merijn/c163cc106fd245d1cf2e
06:54:41 <wilornel> the cons operator is not surrounded my spaces on both sides, it seems
06:54:48 <wilornel> in that sort implementation
06:55:39 <byorgey> wilornel: no, spaces are not required around operators in Haskell
06:56:03 <ski> wilornel : fwiw, this is not ##haskell :)
06:56:18 <quchen> The clown operator! (o:)
06:56:33 <ski> wilornel : perhaps you'd be interested in the book "Pearls of functional algorithm design", btw
06:56:47 <merijn> I prefer the snowman operator
06:56:48 <merijn> ☃
06:56:59 <quchen> > let o = "hello " in (o:) ["world"]
06:57:01 <lambdabot>  ["hello ","world"]
06:57:03 * ski . o O ( snoyman operator )
06:57:46 <wilornel> thanks for the resources everyone! It's a little bit unclear, but it's good practice to go over these
06:57:59 <wilornel> and I'm getting that book now
06:59:37 <wilornel> Is that an efficient definition of split or is it specifically a short definition of split?
07:00:57 <merijn> wilornel: It's supposed to showcase DList (for efficient append) and a neat "tortoise & hare" trick. It should be fairly efficient, but the first half isn't lazy, so that's a downside
07:01:11 <merijn> wilornel: iow, it's efficient, depending on your criteria of efficiency ;)
07:01:37 <wilornel> I think I get the definition of split. You're skipping two elements on the second argument for every one element you concatenate on the first argument. 
07:02:07 <merijn> wilornel: right, and since they're the same list you know you've hit halfway as soon as the right hits the end
07:02:36 <wilornel> that's the first case
07:02:46 <wilornel> but then it _looks_ like you're switching them places
07:03:11 <merijn> wilornel: how so?
07:03:16 <wilornel> ooooh no I get it!
07:03:19 <merijn> :)
07:03:21 <wilornel> in the first case, xs is the second half
07:03:28 <merijn> Right
07:03:34 <wilornel> and f [] will allow you to rebuild the first half
07:03:34 <wilornel> nice
07:03:35 <hanna> I wonder if T.pack . foo . T.unpack is subject to fusion. Depends on `foo`, I suppose?
07:03:39 <wilornel> what about the second case?
07:03:52 <ClaudiusMaximus> merijn: is that splitInHalf in the split package?  if not, maybe suggest it?
07:04:00 <merijn> wilornel: Well, what if you have an uneven number of elements?
07:04:39 <wilornel> does it end up being |(a,b)| = (n + 1, n) or (n, n+1)... let's see
07:04:42 <merijn> ClaudiusMaximus: Split does something different, probably better
07:05:11 <merijn> (n, n + 1), since we use "xs" as right half and we have 1 element left on the right
07:05:12 <wilornel> yeah it ends up being (n, n+1) right?
07:05:14 <wilornel> yes
07:05:25 <wilornel> coooool!
07:05:30 <merijn> ClaudiusMaximus: Split does "[a] -> [[a]]" which lets you build the left side lazily
07:05:32 <wilornel> on to sort
07:05:45 <merijn> actually
07:05:56 <merijn> I don't even know if you can consume the left side lazily, tbh
07:06:30 <merijn> ClaudiusMaximus: Honestly, I can't really be arsed to do the work to propose a patch to split, but feel free to copy the implementation and do it for me :p
07:06:46 <wilornel> never seen this @ in as@(a:as')  syntax
07:06:57 <wilornel> found it
07:07:18 <ClaudiusMaximus> merijn: you might be able to make it lazier if you write it recursively using   let ~(as,bs) = ... in (a:as,bs)  instead of the dlist?
07:07:28 <merijn> possibly
07:07:47 <ClaudiusMaximus> if that is even possible..
07:07:49 <merijn> ClaudiusMaximus: I mostly wrote it to showcase DList + the tortoise&hare trick to people (like wilornel) :)
07:08:04 <ClaudiusMaximus> the tortoise+hare trick is nice :)
07:08:43 <wilornel> `    mergePairs (a:b:xs) = merge a b: mergePairs xs
07:08:54 <wilornel> `, it looks like there's three arguments given to merge
07:09:00 <wilornel> which takes two arguments
07:09:24 <wilornel> ah, no , nvm
07:11:09 <shapr> GOOD MORNING!
07:11:22 <wilornel> GOOD MORNING!
07:11:34 <wilornel> midnight and a quarter here
07:11:52 <wilornel> this one is weird: `    mergeAll xs  = mergeAll (mergePairs xs)
07:12:01 <wilornel> `, if we run into the case `mergePairs xs = xs `
07:12:28 <ClaudiusMaximus> an earlier case of mergeAll should handle that possibility i think
07:12:32 <wilornel> because then it's just `mergeAll xs = mergeAll xs`
07:12:38 <wilornel> hmm let's see
07:12:54 <wilornel> yes!
07:13:04 <wilornel> in (a:b:xs), can xs be [] ?
07:13:06 <ClaudiusMaximus> figuring out the pre/post conditions and invariants would make a good exercise i guess
07:13:19 <ClaudiusMaximus> yep
07:13:54 <shapr> wilornel: sounds like a good time to code!
07:14:25 <wilornel> ClaudiusMaximus: what do you mean with pre/post conditions? Pre is unsorted, post is sorted, and invariants is a sorted list inputted that comes back out sorted
07:14:36 <wilornel> shapr: hahah yes I think that's where it's headed tonight
07:14:48 <ClaudiusMaximus> wilornel: i mean for each clause of each helper function, not the whole function
07:15:16 <wilornel> ah yes, if there could be a function type declaration, right?
07:15:38 * hackage hs-multiaddr 0.1.0.0 - Multiaddr Library for LibP2P  https://hackage.haskell.org/package/hs-multiaddr-0.1.0.0 (CMCDragonkai)
07:16:10 <ClaudiusMaximus> wilornel: also properties like "length of output is strictly less than length of input" would be useful to prove termination
07:16:15 <jordan35353> http://lpaste.net/442024582266748928
07:16:27 <jordan35353> why doesnt my function work
07:16:31 <jordan35353> the one at the bottom
07:17:29 <jordan35353> i want to count how many "Blatt" mbaum has
07:17:37 <wilornel> hmm do you usually express these pre/post and invariants in comments around functions  in haskell?
07:17:48 <ongy> jordan35353: your help function only has clauses for lists with no or exactly 1 element
07:18:23 <wilornel> it's interesting how `sequences` will do `descending b [a] xs` or `ascending b (a:) xs` depending on if a < b or a > b. Notice the difference between [a] and (a:)
07:18:24 <ClaudiusMaximus> wilornel: sure, either that or link to a pdf of a paper describing it in more detail
07:18:51 <wilornel> gotcha!
07:19:28 <ClaudiusMaximus> wilornel: for exported functions, the comments can use haddock markup to look pretty in the generated html documentation
07:19:31 <jordan35353> how do clauses for lists longer than that look like? ongy
07:20:04 <ph88> how can i make this function for two inputs?  https://hackage.haskell.org/package/conduit-1.2.10/docs/src/Data-Conduit-Internal-Conduit.html#awaitForever
07:20:27 <saurabhnanda> quick question -- what is the opposite of -fobject-code
07:21:33 <wilornel> If we can't match `descending a as (b:bs)`, then we match `descending a as bs`... but this means that bs in the second case is [], right?
07:23:20 <ongy> jordan35353: you can match a list on (x:xs), then x will be the first element (head) and xs everything else (tail)
07:23:21 <ph88> is there some smart combinator to turn     awaitForever :: Monad m => (i -> ConduitM i o m r) -> ConduitM i o m ()    into     awaitForever :: Monad m => (i -> i -> ConduitM i o m r) -> ConduitM i o m ()    ?
07:24:14 <jordan35353> yes but the thing inside the list is a Baum not a list
07:24:23 <jordan35353> i dont know how to handle that ongy
07:25:08 <wilornel> I think you want to do pattern matching
07:25:10 <ongy> jordan35353: you call helpfunction on it :)
07:25:38 <ongy> jordan35353: first you should think about what you want that to return, then we can think about how you tell ghc to do it
07:27:45 <jordan35353> help_function (Knoten a [(c:cs)]) = help_function c
07:27:50 <jordan35353> doesnt work : /
07:28:05 <ongy> jordan35353: (Knoten a (c:cs))
07:28:31 <ongy> the ':' here is the Cons constructor of [], you don't need the syntax sugar for lists here
07:29:39 * hackage hs-multiaddr 0.1.0.1 - Multiaddr Library for LibP2P  https://hackage.haskell.org/package/hs-multiaddr-0.1.0.1 (CMCDragonkai)
07:30:01 <jordan35353> help_function (Knoten a (c:cs)) = help_function c
07:30:06 <jordan35353> this compiles but gives me 1
07:30:13 <jordan35353> now i need to handle the rest of the list
07:30:33 <jordan35353> help_function (Knoten a (c:cs)) = help_function c + help_function cs
07:30:41 <jordan35353> doesnt work because cs is not an element but a list
07:31:10 <Cale> Perhaps you want help_function c + help_function (Knoten a cs) ?
07:31:16 <Cale> I don't know what is going on though.
07:31:24 <Cale> That looks like it would at least type check
07:31:48 <Cale> It's probably worth thinking about what help_function is actually meant to be computing here (it's poorly named)
07:32:31 <jordan35353> its supposed to count all leafes of the tree
07:32:47 <Nk_> http://lpaste.net/355769 In this Coq code, what makes O the number 0?
07:33:21 <Nk_> How are peano numbers defined like this? 
07:33:30 <Cale> jordan35353: Okay, so the number of leaves of the tree Knoten a cs is the sum of the number of leaves of each of the trees cs, right?
07:33:35 * ski supposes jordan35353 is also doing <http://www-stud.informatik.uni-frankfurt.de/~prg2/SS2017/aufgaben/teil1/blatt5.pdf> ..
07:33:47 <glguy> Nk_: this is #haskell
07:34:35 <Cale> jordan35353: So, you should have  leafCount (Knoten a cs) = sum (map leafCount cs)
07:35:07 <jordan35353> who are you ski : D
07:36:24 <shapr> glguy: sparta reference?
07:36:55 <jordan35353> Cale now it works :))
07:37:02 <jordan35353> thanks ^
07:39:44 * ski is ski
07:39:49 <shapr> I met ski once.
07:40:35 <ongy> ski: :) I was wondering if I reference the assignment, but I opted not to do that
07:41:39 * hackage fltkhs 0.5.1.7 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.1.7 (deech)
07:41:44 * ski was figuring Cale might find it interesting
07:46:18 * ski remember seeing Hughes on a unicycle
07:46:41 <shapr> yeah, that was fun
07:48:09 * hackage graph-rewriting 0.7.10 - Monadic graph rewriting of hypergraphs with ports and multiedges  https://hackage.haskell.org/package/graph-rewriting-0.7.10 (JanRochel)
07:48:29 <Cale> Haha, I wasn't there for that, but I think I recall a photo of it
07:49:14 <shapr> There were pix, though I dunno what happened to all of them.
07:49:31 <shapr> Maybe in July I can post pix of Cale on my unicycle.
07:49:56 <Cale> hahahaha
07:50:38 * hackage graph-rewriting-gl 0.7.8 - OpenGL interface for interactive port graph rewriting  https://hackage.haskell.org/package/graph-rewriting-gl-0.7.8 (JanRochel)
07:50:51 <maffh> Hello, I am trying to build an application with Stack. However, when I import a library like Data.Map, it results into the following error: hs:5:1: error:
07:50:51 <maffh>     Failed to load interface for ‘Data.Map’
07:50:51 <maffh>     It is a member of the hidden package ‘containers-0.5.7.1’.   Use -v to see a list of the files searched for.
07:51:17 <jordan35353> i tried removing the help function
07:51:18 <jordan35353> anzahlStueckeMelodien (Entwuerfe b (Knoten a c) n) = sum (map anzahlStueckeMelodien ([Entwuerfe b c n]))
07:51:19 <maffh> How do you add the Data.Map library to the stack config?
07:51:22 <tolt_> maffh: you need to add containers to your dependencies in your cabal file
07:51:26 <jordan35353> now c at the end gives me the error:
07:51:37 <jordan35353> Couldn't match expected type ‘Baum’ with actual type ‘[Baum]’
07:51:42 <jordan35353> In the second argument of ‘Entwuerfe’, namely ‘c’
07:51:46 <jordan35353> why is that?
07:51:57 <Cale> shapr: What's in July that I should be coming to? I plan to go to ICFP/FSCD this year, but that's September
07:52:00 <shapr> HacBoston
07:52:06 <Cale> ahhh, yeah
07:52:13 <shapr> Is there something like Pandas for Haskell?
07:52:29 <ongy> jordan35353: because you are doing things wrong :P. think a moment about what '\x -> map f x' is, that may help you
07:52:30 <ski> i suppose <ScannedInAvian.com> isn't up anymore ?
07:52:34 <shapr> or more specifically, if I want to create google maps visualizations from cvs data
07:52:39 * hackage graph-rewriting-lambdascope 0.5.10 - Lambdascope, an optimal evaluator of the lambda calculus, as an interactive graph-rewriting system  https://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5.10 (JanRochel)
07:52:49 <shapr> ski: only for email at the moment
07:53:37 * ski was thinking <archive.org> might have something, but it doesn't look like it
07:53:38 * hackage graph-rewriting-layout 0.5.6 - Force-directed node placement intended for incremental graph drawing  https://hackage.haskell.org/package/graph-rewriting-layout-0.5.6 (JanRochel)
07:55:06 <Cale> jordan35353: Well, it says you used a list of Baum where it was expected you would put a single Baum...
07:55:08 * hackage graph-rewriting-ski 0.6.7 - Two evalutors of the SKI combinator calculus as interactive graph rewrite systems  https://hackage.haskell.org/package/graph-rewriting-ski-0.6.7 (JanRochel)
07:55:18 * ski blinks
07:55:37 <quchen> What’s the name for the ⊑ operator? »subtype« sounds like OOP, but »(Int -> Int) ⊑ (b -> b) ⊑ a« looks like subtyping as in »is also a (specialized version of)«.
07:55:49 <Cale> jordan35353: What's the type of Entwuerfe?
07:56:03 <maffh> @tolt, Thx it works!
07:56:03 <lambdabot> Unknown command, try @list
07:56:08 * hackage graph-rewriting-strategies 0.2.6 - Evaluation strategies for port-graph rewriting systems  https://hackage.haskell.org/package/graph-rewriting-strategies-0.2.6 (JanRochel)
07:56:27 * ski rewrites Ramsey numbers into Ramsey types
07:57:21 <lyxia> quchen: subtyping doesn't necessarily connote OOP
07:57:29 <ski> quchen : i always found that use of it suspicious .. but i suppose you could say something like "more concrete/specific/monomorphic than"
07:57:41 <Cale> quchen: It'll have different names wherever it gets used (it's used for a bunch of different orderings), but "is a specialisation of" doesn't seem bad for your use case.
07:57:48 <ski> (it's not subtyping)
07:58:18 <quchen> lyxia: Sure, but the term is heavily biased towards OOP.
07:58:38 * hackage graph-rewriting-trs 0.1.9 - Evaluate first-order applicative term rewrite systems interactively using graph reduction  https://hackage.haskell.org/package/graph-rewriting-trs-0.1.9 (JanRochel)
07:59:01 * ski . o O ( "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> )
07:59:43 <lyxia> ski: does that link explain why this isn't subtyping
08:00:36 <ski> i don't recall. it mentions subtyping, though
08:00:55 <ski> if you want non-traditional subtyping, you could try
08:01:01 <ski> @where ErikPoll
08:01:01 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
08:01:01 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
08:01:01 <lambdabot> pdf>
08:01:09 * hackage graph-rewriting-ww 0.3.7 - Evaluator of the lambda-calculus in an interactive graph rewriting system with explicit sharing  https://hackage.haskell.org/package/graph-rewriting-ww-0.3.7 (JanRochel)
08:02:05 <lyxia> Isn't "more monomorphic than" an example of subtyping?
08:02:06 <quchen> Alright, fair enough. I’ll go with the »specialzation of«, it’s fairly descriptive.
08:03:00 <quchen> Next, why can’t all polymorphically recursive functions be inferred?
08:03:09 <quchen> What breaks inference for them?
08:03:29 <quchen> :t let f [] = (); f (_:xs) = f (zip xs xs) in f
08:03:31 <lambdabot> error:
08:03:31 <lambdabot>     • Occurs check: cannot construct the infinite type: b1 ~ (b1, b1)
08:03:31 <lambdabot>       Expected type: [(b1, b1)] -> ()
08:03:36 <quchen> :t let f :: [a] -> (); f [] = (); f (_:xs) = f (zip xs xs) in f
08:03:38 <lambdabot> [a] -> ()
08:03:58 <shapr> I'm giving a talk comparing Haskell and Python implementations of a REST API in three weeks, come on down to Atlanta Functional Programming!
08:04:10 <quchen> Does it have to do with the way recursive let is typechecked?
08:04:58 <ski> lyxia : no. that involves type variables. subtyping doesn't
08:06:02 <ski> (well, one could mix subtyping with parametric polymorphism. but they're still different)
08:06:11 <kadoban> shapr: Interesting. Will it be streamed or posted anywhere afterwards?
08:06:14 <lyxia> Maybe I have a too broad definition of subtyping... T is a subtype of U if every value of type T is a value of type U...
08:06:22 <shapr> kadoban: er, hadn't thought of that
08:07:39 <lyxia> That doesn't exclude any use of type variables
08:09:19 <codygman__> It's not clear to me that Data.Time.Format as it is supports parsing a date like: 2014-03-08T16:57:17.507Z
08:09:30 <ph88> how can i check if an option has been parsed well and also use a default with optparse-applicative?   https://bpaste.net/show/545253c97393
08:10:14 <shapr> kadoban: I'm doing haskell/spock and python/flask, and I'll have the code up on github by tomorrow, I hope.
08:11:19 <ph88> shapr, can you include examples of a few HTTP methods, serving static content, serving json from database, and serving html template + values ?
08:11:33 <shapr> hm, sure
08:11:36 <dolio> quchen: Unification isn't designed to handle polymorphic recursion.
08:11:52 <shapr> ph88: I was going to start with something that just tracks exercise by name/reps/UTCTime
08:12:01 <shapr> then yesterday I realized I forgot to put in weight :-P
08:12:13 <shapr> so the next step is to finish this code, and then add weight and compare the ease of change
08:12:15 <lyxia> ph88: have you tried seeing what actually happens if the option can't be parsed?
08:12:19 <ski> presumably in the ordering quchen used, we have both ⌜α → α  ⊑  β → β⌝ and ⌜β → β  ⊑  α → α⌝, so, by anti-symmetry, ⌜α → α⌝ and ⌜β → β⌝ should be equivalent .. however clearly ⌜(α → α) → (α → α)⌝ isn't equivalent to ⌜(α → α) → (β → β)⌝ ..
08:12:35 <ph88> shapr, ye nice .. i was trying to use spock myself and it wasn't clear how to do the things i just mentioned
08:12:37 <ski> .. so it appears something weird/unexpected is going on
08:13:11 <shapr> ph88: I followed the tutorials on the spock.li site
08:13:16 <ph88> lyxia, oh ye optparse handles that
08:13:17 <shapr> they include json and db
08:13:25 <ph88> not static
08:13:26 <shapr> though I didn't lok for html+template
08:13:29 <shapr> oh, really?
08:13:35 <lyxia> ski: Maybe that's what quchen actually meant but I think that's assuming too much from what he wrote earlier.
08:13:52 <quchen> Sorry, was away for 5 minutes. Back now.
08:13:59 <ski> lyxia, possibly
08:14:21 <quchen> Yes, that’s too much.
08:14:27 <quchen> :-)
08:14:30 <quchen> dolio: How so?
08:15:05 <ski> quchen : so, which parts were assuming too much ? :)
08:15:27 <quchen> dolio: Unification finds the most general sub……………somethingtype, i.e. the most general substitution to unify the types. Is the »most general« something not easily defined with polymorphic recursion?
08:15:33 <nshepperd> ⌜α → α  ⊑  β → β⌝ seems only true if implicitly quantified?
08:15:38 <dolio> You don't get to unify the same variable with multiple different types. But the definition of polymorphic recursion is that you're instantiating a variable with different types in the recursive call than the function was called with.
08:15:47 <quchen> ski: The part where you had 50% non-ASCII characters in your line ;-)
08:16:02 <nshepperd> in which case you can't put these both in one type as if they were free variables
08:16:03 <ski> *which* part(s) of it ? :)
08:16:55 <quchen> I understood the line, it’s just not what I was trying to find out. I asked the question very handwavy because I only needed a handwavy answer. :-þ
08:17:11 <ski> nshepperd : .. but then how can one describe it compositionally ? in other words, does congruence fail ?
08:17:11 <quchen> Handwavily? Something like that.
08:17:15 <nshepperd> ⌜(forall α. α → α) → (forall α. α → α)⌝ is indeed equivalent to ⌜(forall α. α → α) → (forall α. β → β)⌝ though
08:17:40 <nshepperd> er, that's (forall β. β → β) of course
08:17:45 <quchen> dolio: So is it because type variable instantiation comes too early in the unification algorithm then?
08:18:15 <quchen> dolio: I’m still not seeing what exactly breaks it, or what exactly would make it possible
08:18:20 <dolio> It's because generalization is a distinct process from the unification used to infer types.
08:19:29 <dolio> To infer types, you make up variables for all the things you don't know, unify all the way down, and then generalize all the unification variables that are still unbound variables into quantified variables.
08:19:43 <quchen> Yup.
08:20:22 <ClaudiusMaximus> saurabhnanda: you can   :m + *Module   to force interpreted mode in ghci (note the *).  but this only works if source is available, so not for installed packages
08:21:24 <c_wraith> err, I thought that only worked for :load
08:21:35 <ClaudiusMaximus> c_wraith: works for both i think
08:22:23 <quchen> dolio: And now? :-) This seems sensible.
08:22:39 <dolio> Now what?
08:22:42 <quchen> dolio: Do two unequal type variables have the same name and are generalized to the same type?
08:22:45 <quchen> Where does it break?
08:23:22 <ski> lyxia : btw, note that ⌜σ₀ → τ₀⌝ is a subtype of ⌜σ₁ → τ₁⌝ in case ⌜τ₀⌝ is a subtype of ⌜τ₁⌝ and ⌜σ₀⌝ is a *super*type of ⌜σ₁⌝ (contravariance)
08:23:39 <quchen> At some point, some definition on the left-hand side and the »same, but differently typed« value on the RHS have to be unified, no? And that’s when type inference reports the failure?
08:23:42 <dolio> When you infer 'foo x = foo ()', foo is given a type `a -> b`, then `a` gets unified with `()` due to the recursive call, so foo has type `() -> b`.
08:23:42 <ski> lyxia : otoh ⌜σ₀ → τ₀⌝ would presumably be more specialized than ⌜σ₁ → τ₁⌝ in case ⌜τ₀⌝ is more specialized than ⌜τ₁⌝ and ⌜σ₀⌝ is *more* (not less) specialized than of ⌜σ₁⌝ (that's not precise enough, but should serve to point out that contravariance doesn't enter here)
08:24:26 <dolio> Before we get to generalize, we've unified a with () to concretize it.
08:24:42 <quchen> Aaah.
08:25:19 <dolio> In this case you get a valid type, but it's not the most general possible type.
08:25:34 <quchen> So if we generalized every time we created a new type variable, we would solve the problem, but then we’d have to instantiate again everywhere, which would cause a whole lot of problems.
08:25:40 <dolio> In other cases you might do something that falls afoul of the occurs check or something.
08:25:46 <quchen> Like too-many-∀s.
08:26:31 <dolio> You can't generalize immediately when you create a variable.
08:27:18 <quchen> Yes, that won’t work. I was just playing »what if« :-)
08:27:27 <dolio> I'm not 100% sure, but I think polymorphic recursion is impossible to infer. Like undecidable.
08:27:40 <ski> is it the case that polymorphic recursion (in the general) can't be inferred, or only that the algorithms we're using can't do it ?
08:27:43 <quchen> Undecidable? Like »may take forever«?
08:28:02 <ski> (cf. rank-`n', for `n >= 3')
08:28:23 <dolio> If you have a particularly nice type system maybe it's possible.
08:28:30 <dolio> Like with principal typings maybe.
08:29:04 <quchen> What’s the most general type of »foo x = foo ()« if not »() -> t«?
08:29:12 <dolio> a -> b
08:29:31 <quchen> Ah, right.
08:30:10 <dolio> The problem seems similar to rank-n inference to me, though.
08:30:50 <nshepperd> if you can do rank-2 inference, you can do some polymorphic recursion, by translating to an application of a rank-2 fix
08:31:08 * hackage BioHMM 1.1.6 - Libary for Hidden Markov Models in HMMER3 format.  https://hackage.haskell.org/package/BioHMM-1.1.6 (FlorianEggenhofer)
08:31:39 <nshepperd> i think
08:31:44 <ski> (which rank-`2' fix ?)
08:33:38 * hackage StockholmAlignment 1.1.1 - Libary for Stockholm aligmnent format  https://hackage.haskell.org/package/StockholmAlignment-1.1.1 (FlorianEggenhofer)
08:34:07 <dolio> Perhaps it's more like just rank-2, and so is decidable, just in an unintuitive way.
08:34:27 <nshepperd> let fix f = f (fix f) in fix (\recurse -> do something polymorphic)
08:34:28 <dolio> Not in the way we usually implement the checking algorithms.
08:34:39 <nshepperd> oh, maybe fix needs to be rank-3 there
08:35:14 <dolio> Yeah, I think that might be the case.
08:35:30 <nshepperd> yes, because the lambda is rank-2
08:36:28 <ph88> does someone know a more elegant way to write this piece of code?  https://bpaste.net/show/b636779ae2ba  the idea is that these values have a backup (when they are not set) when "device" is set
08:37:52 <quchen> :t fromMaybe -- ph88
08:37:54 <lambdabot> a -> Maybe a -> a
08:38:02 <quchen> > fromMaybe (Just 4) 10
08:38:05 <lambdabot>  error:
08:38:05 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M527627100159...
08:38:05 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:38:14 <quchen> > fromMaybe Nothing 10 :: Int
08:38:16 <lambdabot>  error:
08:38:16 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Maybe a0’
08:38:16 <lambdabot>      • In the expression: fromMaybe Nothing 10 :: Int
08:38:21 <quchen> Oo
08:38:22 <ski> nshepperd : i meant the type of it
08:38:49 <quchen> Ah, flipped the arguments. Anyway, that’s the »Just-or-default« function, ph88.
08:40:04 <ph88> oh ok
08:40:26 <nshepperd> ski: i guess the type is whatever matches the thing you want to apply it to
08:40:34 <nshepperd> which isn't ery helpful, heh
08:41:08 <ph88> quchen, like this?  https://bpaste.net/show/a97548d3f4ff  the code is still 4 lines ;/
08:44:02 <lyxia> ph88: just pattern match on device straight away
08:44:49 <ph88> on both st and device ?
08:44:56 <nshepperd> i guess for 'fix' to have an actual most-general type for this situation, you would have to go impredicative
08:46:08 <ph88> i also try this   https://bpaste.net/show/9162468d5f0c  not sure why that type error
08:46:14 <lyxia> ph88: http://lpaste.net/355772
08:46:42 <ph88> oh you use tuples, smart :P
08:47:07 <lyxia> ph88: fromMaybe st (changeSt <$> device)
08:48:03 <ph88> lyxia, it should check  st first .. if st is Just 2  it should use that
08:48:22 <ph88> on your lpaste you prioritize device first
08:48:42 <lyxia> Oh sorry
08:48:49 <lyxia> I was confused by your second paste
08:49:01 <lyxia> didn't notice st was a Maybe
08:49:03 <codygman__> Using wreq can i ignore all ssl errors (i really need to)? Failing wreq, can i do so with http-client-tls?
08:49:07 <dolio> ski, quchen: So, from what I can find, Milner-Mycroft inference is equivalent to semi-unification. And since there are papers titled 'a decidable instance of semi-unification', presumably the full problem is undecidable.
08:49:07 <ph88> let st' = fromMaybe (changeSt <$> device) st    here  st is tried first  i think
08:51:00 <ski> nshepperd : hm. which would that be, then ?
08:51:22 <lyxia> ph88: if you have two Maybes, fromMaybe won't be very useful
08:51:56 <ph88> if both device and st are Nothing i would like to get Nothing
08:52:09 <ph88> if both are Just then st has priority over device
08:52:15 <ph88> if one is Just then take that one
08:54:15 <lyxia> ph88: http://lpaste.net/355773
08:55:20 <lyxia> it would be simpler if tcol/vcol/st are either all Just or all Nothing at the same time
08:57:12 <lyxia> ph88: you described <|>. You would use fromMaybe if there were always a device available.
08:57:52 <ph88> ye i wasn't using fromMaybe initially , just an idea to try
08:58:04 <facu_> Hi!
08:58:07 <facu_> : (
08:58:11 <facu_> : )
08:58:16 <ski> hello facu_
08:59:55 <nshepperd_> ski: well, I guess with impredicative it would be the plain old (a -> a) -> a
09:00:28 <nshepperd_> With the rank 2 function unified with a
09:01:01 <ski> then `a -> a' will be rank-3, which can't be inferred
09:02:30 <nshepperd_> However, maybe we can do this with only rank 2 types by writing let f = (\recurse -> do stuff); y = f y in y
09:03:05 <nshepperd_> I don't think there's anything rank 3 or impredicative that happens in that one?
09:03:18 <spike`> /?
09:03:48 <nshepperd_> Or maybe I'm just kicking the can down the road in the inference of y
09:03:56 <ski> if `y' is rank-`2', wouldn't `f' then need to be rank-`3' ?
09:04:20 * ski looks at spike`
09:05:05 <nshepperd_> No, y is rank 1.
09:05:14 <ski> perhaps this specific use could still be inferred, though
09:05:30 <nshepperd_> Y is the original polymorphically recursive function
09:05:30 <ski> hm, i thought `y' would have the type that you unified with `a' before
09:05:56 <ski> hello again, spike`
09:07:40 <dolio> ski: I do see an algorithm that claims to infer polymorphic recursion and uses principal typings, though.
09:07:58 <ski> mhm
09:08:52 <dolio> Which HM and MM don't have, to the best of my knowledge.
09:11:52 <shapr> dolio: I know HM and DM, what's MM?
09:12:08 <dolio> Milner-Mycroft.
09:12:41 <shapr> ah, thanks
09:14:28 <tobiasBora> What is the good way to produce mutable vectors from Data.Vector using an input list?
09:14:52 <tobiasBora> I saw "thaw", but not sure it's the best thing to use
09:14:56 <codygman__> Answering my question about disabling https validation using http-client: newManager $ mkManagerSettings (def { settingDisableCertificateValidation = True }) Nothing >>= \manager -> withResponse "https://insecure" manager $ \res -> print $ responseStatus res
09:15:22 <codygman__> ^^^ took forever on mobile
09:15:41 <lyxia> tobiasBora: unsafeThaw if you care about performance
09:15:44 <DataComputist> After writing some Haskell code to https://code.world/haskell and clicking 'run', the side window has been showing 'running ...' for more than 10 minutes. It's probably not working. Anyone know why? I'm using macOS and Chrome.
09:16:13 <tobiasBora> lyxia: thank you
09:16:53 <kadoban> DataComputist: Most obvious reasons would be a problem with the website or a problem with your code. Does that site usually work? Never heard of it.
09:18:30 <lyxia> DataComputist: I also get stuck with "Running..." under firefox
09:21:30 <lyxia> DataComputist: Now it seems to actually run, with "Running..." not being updated.
09:22:15 <lyxia> DataComputist: this one draws a square https://code.world/haskell#PLK0sf9TIOeU0o9TUnrgMMw
09:24:20 <EvanR> lyxia: whoa
09:25:30 <EvanR> DataComputist: that site looks pretty awesome... if it works
09:25:34 <EvanR> i see the square
09:25:37 <EvanR> osx chrome
09:26:23 <DataComputist> Why this doesn't work: https://code.world/haskell#Pv-e2lr-WUT5nc0q4c-1gAw
09:26:42 <lyxia> EvanR: It is! Check out the recent talk https://www.youtube.com/watch?v=7CGuI9HcfqQ
09:27:05 <lyxia> DataComputist: it works, it drew a blank picture
09:27:21 <DataComputist> OK
09:27:29 <DataComputist> 'running ... ' is confusing
09:27:30 <EvanR> success, nothing
09:27:35 <DataComputist> as if it never finished
09:27:36 <EvanR> the unix philosophy
09:27:54 <EvanR> agreed running ... is superfluous ;)
09:27:59 <lyxia> DataComputist: Yeah it should be fixed.
09:29:01 <Cale> DataComputist: Try replacing blank with something like  circle 5
09:29:41 <EvanR> from the forum... https://code.world/#PSDuykS2GTlVtMYVgZDswfA
09:29:46 <EvanR> looks like haskell is the only language
09:31:22 <steve833> http://lpaste.net/35577
09:31:35 <steve833> im trying to convert a tree to a binary tree (if possible)
09:32:13 <EvanR> i wonder how you infer types here...
09:33:10 <Cale> steve833: http://lpaste.net/355774 ?
09:33:16 <lyxia> steve833: you mean http://lpaste.net/355774 ?
09:33:42 <steve833> ?? :D
09:33:42 <lambdabot>  :D
09:33:46 <steve833> wat
09:34:03 <steve833> why is the bot laughing about me
09:34:09 <steve833> yes i mean http://lpaste.net/355774
09:34:19 <duckqlz> :D
09:34:40 <Cale> steve833: Note that [b] is always a 1-element list
09:35:33 <steve833> thats bad news
09:35:38 <Cale> It can't have 0 or 2 elements, because it clearly has exactly 1, namely b.
09:36:25 <Cale> > length [6]
09:36:27 <lambdabot>  1
09:37:03 <Cale> You also probably want to pattern match rather than using the length function at all
09:37:38 <Cale> i.e. have a case for (NKnotten a []) separate from the case for (NKnotten a [b]) and (NKnotten a [b1,b2])
09:38:08 <Cale> Er, Knoten
09:38:17 <Cale> :)
09:38:26 <mauke> obviously, node = knot
09:38:45 <steve833> ntreebtree (NKnoten a []) = BBlatt a
09:38:50 <steve833> this works i thikn
09:38:53 <Cale> yes
09:38:55 <steve833> but the problem is here
09:39:01 <steve833> ntreebtree (NKnoten a [b]) = BKnoten (ntreebtree b) a (ntreebtree b)
09:39:13 <steve833> i cant know how deep i will have to go into b
09:39:19 <Cale> steve833: You want the subtrees to be the same in that case?
09:39:21 <steve833> maybe i need to use map again?
09:39:47 <steve833> no but i think my definition of a binary tree needs exactly 2 subtrees to work
09:39:57 <steve833> because if there is only one it says that an argument is missing
09:40:21 <Cale> Well, yes.
09:40:43 <steve833> well yes i need to use map again?
09:40:47 <Cale> It's somewhat unusual to have both the branches and the leaves labelled
09:41:00 <Cale> I mean yes your definition needs exactly 2 subtrees.
09:41:13 <steve833> thats ok then
09:41:15 <Cale> If it allowed for empty leaves, you could make one of the subtrees empty
09:42:14 <Cale> But as it is, that definition of binary tree doesn't allow for a tree having only 2 elements in it. You can only have 1 or at least 3.
09:42:49 <steve833> i can live with that
09:43:21 <mauke> this is exercise 1.d, right?
09:46:42 <steve833> yes mauke
09:48:16 <steve833> http://lpaste.net/355775
09:48:33 <steve833> this works better, but it still crashes when there are multiple Blatt in the list
09:49:15 <mauke> that's still too complicated. you can delete line 12
09:49:25 <mauke> er, and line 13 isn't quite right
09:49:36 <steve833> yes theres the problem
09:49:50 <steve833> someone told me tho to make a pattern for the emptyl ist
09:49:57 <mauke> it should be ntreebtree (NKnoten a [b1, b2]) = BKnoten (ntreebtree b1) a (ntreebtree b2)
09:50:58 <steve833> Non-exhaustive patterns in function ntreebtree mauke
09:51:09 <mauke> cool
09:51:17 <mauke> that means it's working
09:51:21 <steve833> which pattern are we missing?
09:52:14 <mauke> if you followed my suggestions, you have cases for NBlatt _ and NKnoten _ [_, _]
09:52:38 <mauke> so what's missing is NKnoten _ [], NKnoten _ [_], and NKnoten _ (_ : _ : _ : _)
09:53:09 <mauke> but those can be covered by adding: nbtreebtree _ = error "entsprechende Fehlermeldung"
09:53:38 <steve833> you can speak german?
09:54:26 <mauke> yes :-)
09:55:59 <steve833> http://lpaste.net/355776
09:56:05 <steve833> Multiple declarations of ‘ntreebtree’
09:56:07 <steve833> urgh
09:58:22 <ongy> steve833: that's because of your typo
09:59:22 <steve833> typo is fixed now, problem persists : /
10:00:32 <ongy> the typo with nbtreebtree?
10:01:30 <steve833> it works now
10:01:34 <steve833> i changed it to this:
10:02:01 <steve833> http://lpaste.net/355778
10:05:49 <ongy> steve833: Line 13 looks a bit weird to me, but that could be fro myour assignment
10:06:18 <steve833> thanks for everybody that helped me ^
10:06:52 <bartavelle> steve833: you still should have a warning
10:07:16 <steve833> why?
10:07:17 <bartavelle> steve833: just barging in, but I believe line 15 pattern should be (_ : _ : _ : _)
10:07:38 <bartavelle> which is very much different from [_,_,_]
10:07:39 * hackage threepenny-editors 0.2.0.9 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.9 (PepeIborra)
10:08:06 <steve833> youre right i think
10:08:26 <steve833> because when pattern is longer than 3 its a nonexhaustive pattern
10:08:32 <ongy> I'd go with _ or (b1:b2:_), but it's up to you
10:09:23 <steve833> look at this:
10:09:26 <bartavelle> that would work too, except elements from longer would be silently discarded (which might be right)
10:10:04 <ongy> bartavelle: it schould be "all others", b1 and b2 may be interesting for the error message (but I don't really think so)
10:10:14 <steve833> http://lpaste.net/355778
10:10:52 <steve833> what do we need to change to give the error when there is 3 OR MORE elements in a list=
10:10:55 <steve833> ?
10:11:17 <bartavelle> steve833: what I or ongy suggested, depending on if you want to raise an error or to silently ignore extra elements
10:11:29 <steve833> i want to raise an erro
10:11:48 <ongy> steve833: you could either go with _ and just catch "everything else" or if you want to do a pattern, you will have to use (b1:b2:...)
10:11:53 <bartavelle> then the proper pattern would be (_:_:_:_), that matches lists of length 3 or more
10:12:01 <ongy> steve833: you can change the pattern in line 14
10:12:04 <yoneda> exit
10:12:24 <steve833> do i substitude the list for (_:_:_:_) or everything including a ?
10:12:36 <ongy> steve833: think about it :P
10:12:40 <steve833> nvm
10:12:43 <steve833> only the list of course
10:12:49 <ongy> do you understand what you can match with ':' ?
10:13:13 <steve833> yeah we just check the FIRST 3 elements
10:13:32 <steve833> the rest wont matter then
10:14:11 <ongy> steve833: I meant in a more general way. When I have a pattern let (x:xs) = [1, 2, 3, 4, 5] what will x and xs be?
10:14:26 <steve833> x is 1
10:14:28 <steve833> xs is the rest
10:14:37 <ongy> ok, good :)
10:14:38 <steve833> i start to understand haskell i thikn
10:14:44 <steve833> thx for your help so far ^^
10:16:15 <ongy> so: are you actually here? I wonder what kind of person likes highlights enough to use such a common word as nick
10:16:42 <bartavelle> yeah, and it looks really strange to have all the 'so' words colored in red
10:16:47 <bartavelle> (with my client)
10:26:57 <tobiasBora> Hum...
10:28:34 <tobiasBora> It's funny, my code using vector + sorting in place instead of lists + sorting via nubOrd is slower (not that much) and uses 3x the memory of the version with lists !
10:29:37 <Tuplanolla> Is it not an unboxed vector, tobiasBora?
10:30:17 <tobiasBora> Tuplanolla: No. I tried to make a unboxed vector of it, but it was quite heavy...
10:30:30 <tobiasBora> like I needed to unbox also a vector
10:33:31 <tobiasBora> Wahou
10:33:44 <tobiasBora> it really depends on the sorting algorithm I use
10:34:03 <tobiasBora> the Intro sorting is still worse: 140M instead of 8M
10:34:46 <steve833> https://en.wikipedia.org/wiki/Bogosort
10:34:50 <steve833> use this sort
10:35:28 <tobiasBora> steve833: it's not here: https://hackage.haskell.org/package/vector-algorithms-0.7.0.1
10:35:42 <tobiasBora> how
10:35:45 <tobiasBora> what a good sort
10:36:03 <cocreature> tobiasBora: how’s the performance using tim sort?
10:37:11 <pie__> you guys know any tools for writing troubleshooting tools or something like that?
10:37:34 <tobiasBora> cocreature: around the same values than merge sort
10:37:41 <tobiasBora> But maybe I got why it's slower
10:37:58 <ph88^> is there a function for a conduit that does nothing ?
10:38:13 <tobiasBora> What I really want is counting the number of differents elements in a list
10:38:23 <tobiasBora> so I'm using for the list "Extra.nubOrd l"
10:39:03 <tobiasBora> and for the vector version, I first sort, then use the sort, and then the uniq function
10:39:27 <tobiasBora> some of you see a more elegant solution?
10:39:51 <cocreature> hyperlolog? :)
10:41:26 <tobiasBora> cocreature: I'm sorry, I don't want approximation ;)
10:41:39 <cocreature> tobiasBora: who cares about correctness if it’s fast!
10:41:56 <tobiasBora> cocreature: mathematicians
10:42:05 <tobiasBora> but I don't know why
10:42:16 <cocreature> show us the code :)
10:44:22 <tobiasBora> cocreature: It's not really organised not well written, but here is the idea: http://paste.debian.net/936187
10:44:42 <tobiasBora> forget about all the stuff commented
10:45:00 <tobiasBora> basiquely, I've a set of angle
10:46:01 <tobiasBora> I can convert one angle into a matrix J(angle)
10:46:24 <tobiasBora> then for a given list of angles, I compute J(angle1) J(angle2) ... J(anglen)
10:46:35 <tobiasBora> and I want to see the number of these matrix I can obtain
10:46:57 <tobiasBora> matrices*
10:48:54 <lyxia> ph88^: return ()
11:09:16 <actualHuman_462> pie__ : You mean like, Haskell programs as shell scripts?
11:09:36 <shapr> pie__: yeah, what kind of troubleshooting tools?
11:10:36 <pie__> so apparently i want to make decision trees
11:10:59 <actualHuman_462> Ooh, like the classic 'Menu' program
11:11:32 <Tuplanolla> Do you mean stuff like that Windows XP help system with hundreds of unhelpful stock responses, pie__?
11:12:06 <pie__> Tuplanolla, probably, except not actually shit
11:12:20 <actualHuman_462> Error 0x53 - "Error: Program execution failure"
11:13:18 <actualHuman_462> How much 'pretty' do you want? Does this need a GUI, or are we thinking like an interactive CLI thing?
11:14:01 <pie__> i dont actually know but for starters ill take what i can get
11:14:15 <pie__> i was hoping maybe something that can render to an interactive html page
11:14:40 <Tuplanolla> Who's going to be the victim?
11:14:51 <pie__> lazy sysadmins
11:14:57 <pie__> <----
11:15:00 <pie__> "sysadmins"
11:15:12 <Tuplanolla> Hey, that's me.
11:15:19 <pie__> home users trying to use nixos
11:15:25 <pie__> ok just me trying to use nixos
11:15:40 <pie__> without actually learning it...because I Have Things To Do(tm)
11:16:03 <actualHuman_462> Well, I'm not aware of any frameworks specifically for that purpose, but case (getLine) of "1" -> doThingOne works pretty damn smoothly
11:16:28 <pie__> actualHuman_462, i suppose the "runtime" has no reason to be complicated
11:16:34 <pie__> more like an authoring tool might be nice
11:16:49 <actualHuman_462> Ahhhhh
11:16:50 <pie__> because its zomg _DATA DRIVEN_ (r)(tm)(c)
11:17:55 <actualHuman_462> The idea, I assume, is to be static collections of markup for documentation that the user navigates using 'choose your own adventure' style input
11:18:14 <actualHuman_462> As opposed to something that goes out and interrogates the world to guide a user to a choice
11:18:15 <actualHuman_462> ?
11:18:45 <pie__> what do you mean by the latter?
11:19:20 <pie__> i didnt actually thing of integrating this inside documentation, that might even be a good idea :PP
11:19:40 <pie__> but yeah choose your own adventure is esentially what i was thinking
11:19:52 <pie__> basically, tech support flowchart but interactive
11:20:15 <EvanR> who knows how StaticPtr works... you run two of the same GHC programs , same computer or not, and you can send StaticPtrs between them to refer to values in either?
11:21:28 <actualHuman_462> Simplest possible solution I can think of:
11:22:20 <Tuplanolla> I'm reminded of Inform 7, pie__.
11:22:26 <pie__> you know
11:22:35 <pie__> inb4 i should just use textadventure software >.>
11:22:52 <pie__> oh wow thats what you just sai
11:22:57 <pie__> *said. lmao
11:24:40 <pie__> honestly though there has to be a proper tool for this...
11:25:10 <Tuplanolla> I'm perpetually surprised by how rarely that is true.
11:25:49 <pie__> Tuplanolla, :C
11:26:00 <pie__> i also have a harder problem
11:26:05 <pie__> how do i find common questions in irc logs
11:26:46 <Tuplanolla> You want neural networks even if you don't know it yet.
11:26:53 <pie__> obviously.
11:27:22 <Tuplanolla> I'll go be obvious somewhere else.
11:27:28 <pie__> :C
11:27:33 <pie__> noooo we like you here
11:27:53 <pie__> anyway, im just saying that because like ENTERPRISE and DECISION TREES
11:28:08 <pie__> that just means anything that doesnt suck costs 10k$ a seat
11:30:31 <EvanR> pie__: mechanical turk
11:30:56 <geekosaur> they suck too, they just suck differently
11:31:26 <angryShiva> \nick angryMonk
11:32:17 <actualHuman_462> https://gist.github.com/IronGremlin/237a2a7faa2dfb23a1b73cba32a1f166
11:32:18 <monochrom> Angry Monk was angry with you :)
11:37:05 <actualHuman_462> The idea there is basically just make the minimum possible amount of author effort - Literally anyone could write steps for the thing. You could migrate it to something more complex later with minimal effort because the tree would be insanely easy to scrape programatically.
11:38:02 * monochrom picks his nose.
11:40:21 * erisco generalises to a cavity phlegm extractor
11:43:08 <mnoonan> "you see, a monad is like a nose, and (>>=) is like a finger.."
11:43:33 <actualHuman_462> Does that make 'guard' a tissue?
11:53:31 <pie__> \it has been pointed out to me that these are usually called expert systems. facepalms were had
11:54:06 <DataComputist> What's wrong with https://code.world/haskell#PlaW4aJDPTJhZiub1_ZsUEg ?
11:54:30 <mniip> DataComputist, you forgot |
11:54:32 <mniip> in guards
11:54:49 <mniip> also you probably want `mod`
11:55:29 <EvanR> "parse error in" ... whaever happened to "unexpected foo, expecting bar1, bar2, bar3, or bar4..."
11:56:01 <erisco> those errors are dubious
11:56:08 <monochrom> It happened when GHC switched from parsec to happy. :)
11:56:30 <pikajude> what an ironically named parser
11:57:08 <EvanR> DataComputist: haha i fixed your code and now i see a blinking traffic light!
11:57:39 <monochrom> That's neat.
11:58:32 <mniip> hmm
11:58:35 <mniip> is that ghcjs
11:58:40 <erisco> because it is left-to-right parsing those errors assume that the left is correct and the right is incorrect
11:59:11 <erisco> and they usually assume left is maximally correct
12:00:12 <erisco> so it works in some cases, maybe most cases depending on the language and likely human errors, but can be entirely unhelpful in others
12:00:24 <erisco> because the inferred intent is wrong
12:00:31 <EvanR> parsing is not necessarily left to right
12:00:37 <EvanR> thats just how the text is displayed
12:00:44 <EvanR> its from beginning to end
12:01:03 <erisco> there is no difference in the parlance
12:01:30 <erisco> front to back, beginning to end, left to right, these are all the same thing
12:01:55 <erisco> but top to bottom and bottom to top describe something else, heh :P
12:02:46 <DataComputist> Are the compiling errors left OK? https://code.world/haskell#P1y7LjiIxUjZWtkRM9Kbi3Q
12:03:32 <lyxia> these are OK warnings
12:03:47 <lyxia> very nice traffic light
12:12:51 <greymalkin> Are there many packages like this on hackage: https://hackage.haskell.org/package/elo ? No code.
12:14:03 <EvanR> probably
12:14:31 <kuribas> that's rather pointless
12:14:38 <monochrom> That's bizarre.
12:15:09 <buglebudabey> i am using gloss in my stack project but it can't seem to find one particular function. what could be the reason?
12:15:28 <geekosaur> you're using the haddock from a different version than your project is using?
12:17:27 <geekosaur> ...not helping is that the language itself lets the type signature be somewhere other than the definition, but ghci can't do that at all
12:21:16 <merijn> ghc-prim is wired into GHC, no? i.e. I can get away without specifying version ranges on it
12:23:05 <monochrom> That depends on whether what you use is present in all versions.
12:24:09 <monochrom> It is between a rock and a hard place.
12:24:10 <geekosaur> whoops, I see I managed somehow to put that last message here instead of -beginners
12:24:53 <geekosaur> also the package itself is not in all versions (although I guess you can hope you don't need to care about versions that don't have it)
12:26:22 <monochrom> If you don't put a bound, #haskell will get a question from a user "merijn's package fails to build" and it will take us forever to find out there is a version incompatibility issue.
12:27:21 <monochrom> If you do put a bound, #haskell will get a question from a user "how do I install a different version of ghc-prim" and it will take us forever to find out they're trying to build your package with a version incompatibility issue.
12:27:42 <monochrom> By the law of excluded middle, PEBKAC. :)
12:29:55 <merijn> monochrom: I was asking specifically about ghc-prim, if it's wired into GHC that should already be covered by the bound on base
12:30:18 <monochrom> Ah you have a bound on base?
12:30:18 <merijn> Anyway, it's not my package and I noticed the library already had a way around the issue I saw
12:30:27 <merijn> Of course it got merged while breaking everything... :p
12:31:34 <merijn> ghc-prim is actually only for GHC7.4 anyway, 7.6 and later already reexport GHC.Generics
12:32:27 <merijn> Also, does everyone else also just rely on "push to github and wait for Travis" as a method for seeing if your commits work with old versions
12:32:42 <geekosaur> some people use hvr's repo
12:33:48 <hexagoxel> ghc-prim is a boot-lib, but in general it is possible to use a version of a bootlib different from the one included with the compiler one currently uses.
12:35:54 <clamchowder> hello
12:35:54 <hexagoxel> merijn: i run checks locally, the tool is published as `iridium` on hackage. it requires cabal and the relevant ghc versions to be installed.
12:36:17 <clamchowder> I have a question about Parsec
12:37:07 <merijn> hexagoxel: I run some checks locally, but not for all ghc's atm
12:37:22 <clamchowder> is there an "and" analog to the operator <|>?
12:37:35 <merijn> clamchowder: eh, >> :)
12:37:50 <monochrom> FSVO analog
12:37:57 <clamchowder> merijn: I tried that but it didn't work...
12:38:05 <clamchowder> merijn: let me be more specific
12:38:12 <monochrom> Difference being "same input" vs "the rest of the input"
12:38:13 <merijn> clamchowder: You're going to have to have some more specific example code/problems :)
12:38:26 <Cale> clamchowder: You mean that you want to check both parsers match the same portion of the input?
12:39:03 <clamchowder> Cale: no I want to apply parser1 to consume some string, then parser2 to consume the rest
12:39:22 <monochrom> Then it's >>
12:39:25 <merijn> clamchowder: That's what >> does, unless I misunderstand what you want :)
12:39:40 <hexagoxel> so, typewise, Parser a -> Parser b -> Parser ?
12:39:47 <monochrom> b'
12:39:50 <monochrom> err, b
12:40:05 <monochrom> If you want (a,b) there's liftA2(,)
12:41:09 <clamchowder> merijn: let me find an example...
12:41:14 * hexagoxel meant that question for clamchowder, to make sure.
12:41:28 <monochrom> Oh! Misread. Yeah.
12:42:21 <clamchowder> hexagoxel: yes
12:42:31 <hexagoxel> (there also is (*>) and (<*) that can make sense in the context of parsing)
12:43:36 <alanz> I hate RecordWildCArds
12:43:50 <monochrom> Why?
12:44:04 <merijn> I love RecordWildCards
12:44:21 <alanz> They hide information. You see random names and don't know where they come from
12:44:39 <alanz> until you notice the telltale {..} and have to chase decls
12:44:39 <hexagoxel> clamchowder: if you only want the value from the second parser, or don't care about their values at all, then (>>) or (*>) is appropriate.
12:44:43 <monochrom> Are you OK with FieldNamePuns?
12:44:47 <clamchowder> OK say I want to parse a string ended with a space or a tab followed by a -
12:44:58 <alanz> yes, they at least bring the name into (human) scope
12:45:12 <clamchowder> and I want to use manyTill
12:45:29 * alanz rant over, move along
12:45:30 <merijn> clamchowder: Can you lpaste what you've got right now? And what it fails to parse
12:46:13 <clamchowder> I want to use manyTill to use parser p1 until there's a space or a tab followed by a '-'
12:46:14 <mjora7> Can someone help me with a question? I'm using this "hello world" app for Scotty: https://hackage.haskell.org/package/scotty and I wanted to know how to add another route, so I looked in the documentation https://hackage.haskell.org/package/scotty-0.11.0/docs/Web-Scotty.html but I cannot figure out how to do it. So I just added another "get" underneath the current one and it worked. My question is... How was I supposed to know that's
12:46:15 <mjora7>  how you do it? When I look at the signature of the scotty function, nowhere is it apparent that it can take multiple arguments. What am I missing?
12:46:25 <clamchowder> say the parser for space / tab is p2
12:46:30 <clamchowder> and the one for '-' is p3
12:46:45 <clamchowder> I do: manyTill p1 (p2 >> p3)
12:47:10 <shapr> jud: howdy
12:47:31 <jud> shapr, 'lo
12:47:31 <shapr> mjora7: I thought scotty was no longer active? I've been using Spock
12:47:57 <clamchowder> If I test it with "2 3 -", I get error saying "unexpected 3 expecting "-""
12:48:12 <mjora7> shapr: I had no idea about that, which leads me to another question... How am I supposed to know what libraries to use and what to avoid? I picked scotty cause it looked simple.
12:48:26 <clamchowder> merijn: does that make sense?
12:48:30 <shapr> mjora7: I don't have a good answer other than asking here :-/
12:48:33 <merijn> clamchowder: Well, not without code :)
12:48:53 <shapr> mjora7: I agree, scotty is simple, and spock is almost as simple. Also, docs on spock.li are easy to read and have worked fine for me.
12:49:12 <mjora7> shapr: Do you have any idea about my original question though? I'm super confused about how to properly read Haskell documentation.
12:49:20 <mjora7> shapr: And thanks for the suggestion.
12:49:32 <clamchowder> you can think of p1 as matching anything...
12:49:37 <merijn> mjora7: As for how you should know
12:50:17 <shapr> mjora7: I don't think you're expected to know that kind of thing. Are the tutorials on spock.li easier to read?
12:50:34 <shapr> I usually look for a tutorial with some example code, and follow that.
12:50:40 <merijn> mjora7: The name as well as the actual documentation of ScottyM tell us that scotty is a monad instance, so that tells us that we can use >> (i.e. new line in do notation) to combine multiple "ScottyM ()" values together
12:51:14 <merijn> mjora7: Now, what that combination *means* is something that has to be documented somewhere, but for e.g. route configuration you can usually guess it's combining them somehow
12:51:46 <mjora7> merijn: Ok that went above my head, I think the answer is that I need to study more Haskell... Monads specifically. I'm about half way through my textbook and thought it was enough to start using some libraries to make stuff like with other languages, but I guess Haskell is a different beast as the code is still extremely confusing to me.
12:51:58 <merijn> mjora7: It's not very obvious from the docs, though.
12:52:08 <clamchowder> It seems like the problem is the program consumed the 2, and the space following the 2 triggered the (p2 >> p3) part in manyTill, and then look for the -, but encountered 3.
12:52:31 <merijn> mjora7: Monad is mostly just a convenient/common interface for "things that can be combined"
12:52:33 <lyxia> Maybe look for tutorials, this one lines up a get and a put or two https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html
12:52:33 <shapr> mjora7: ooh, which textbook?
12:52:54 <lyxia> uh, a get and a post or two
12:52:59 <mjora7> shapr: Learn You a Haskell
12:53:19 <merijn> mjora7: I would say that most of the "production" haskell libraries (especially in the web side of things) tend to be rather complicated and use significant haskell knowledge to actually understand. Additionally, Learn You a Haskell is...not very in-depth in what it covers
12:53:22 <shapr> mjora7: neat, is this for a class?
12:53:43 <mjora7> merijn: Yeah I'm starting to realize that.
12:54:05 <merijn> mjora7: Honestly, I would consider myself rather good at haskell and *I* still find a lot of the web framework's rather intimidating
12:54:22 <mjora7> shapr: Nope, just out of personal interest. I'm sick of using imperative languages, I feel like I'm just hitting a brick wall a lot of the times and being forced to write ugly code, which isn't fun.
12:54:29 <mjora7> merijn: What do you use Haskell for?
12:54:36 <merijn> mjora7: I've heard good things about the CIS194 haskell course: https://www.seas.upenn.edu/~cis194/fall16/
12:54:47 <lyxia> clamchowder: manyTill p1 (try (p2 >> p3))
12:55:55 <merijn> mjora7: Basically, everything...short throwaway scripts to parsing, task-farming of jobs on cluster, to hobby projects :p
12:56:21 <mjora7> merijn: Are you using it professionally though, or just for personal stuff?
12:56:37 <clamchowder> lyxia: that works! thank you.
12:58:45 <merijn> mjora7: I'm writing stuff for my job in it, yes. Although mostly tools/small things, since my main work is CUDA and that's easier from C++.
12:58:49 <bollu> merijn: do you work on HPC?
12:59:38 <Athas> From what I have seen of the Haskell web infrastructure, I would not call it pretty Haskell.
12:59:40 <merijn> mjora7: I would say of all languages I learned, Haskell probably took the longest to be able to productively write code in. But I also think that *once* you start to get productive you can ramp up crazy fast and attempt projects you'd never consider without it
12:59:46 <merijn> Athas++
13:00:07 <Athas> But I think I'm decoupled from the community taste-wise.  I don't like all the Template Haskell and tons of extensions.
13:00:46 <merijn> I like Template Haskell and I like a lot of extensions, but I still think a lot of web frameworks are ugly :p
13:00:59 <Athas> But that's basically all they are!
13:01:10 <merijn> Athas: Go figure!
13:01:44 <lifter> I read this blog about GHC Generics (https://stackbuilders.com/tutorials/haskell/generics/index.html) but I wasn't able to figure out why or when I'd use them. Can someone explain?
13:01:48 <mjora7> So what language is even good at web frameworks... I've never seen one that wasn't ugly.
13:02:20 <bollu> I want: (a -> f b) -> (b -> c) -> (a -> f c)
13:02:33 <Athas> mjora7: Well, the web is inherently ugly.  But... Go, maybe?  It's a flawed language, but it has good aesthetics.
13:02:40 <merijn> mjora7: I would say that, where many other language strive to make the first (small/trivial) programs the easiest to write. Haskell strives to make your advanced/big programs easier to write. At the cost of making those initial first programs harder...
13:02:49 <bollu> @djinn (a -> f b) -> (b -> c) -> (a -> f c)
13:02:49 <lambdabot> -- f cannot be realized.
13:02:52 <bollu> wat
13:03:01 <lyxia> lifter: you can use generics when you want to derive code from a type
13:03:05 <bollu> @djinn Functor f => (a -> f b) -> (b -> c) -> (a -> f c)
13:03:05 <lambdabot> Error: Class not found: Functor
13:03:06 <merijn> bollu: No Functor constraint :)
13:03:17 <merijn> :t \f g -> fmap g . f
13:03:18 <lambdabot> Functor f => (a1 -> f a) -> (a -> b) -> a1 -> f b
13:03:30 <bollu> hmm, I suppose that works
13:03:32 <bollu> ty
13:03:36 <EvanR> watch this
13:04:00 <EvanR> let x = 2 in (+) 0x
13:04:03 <EvanR> > let x = 2 in (+) 0x
13:04:05 <lambdabot>  2
13:04:09 <EvanR> bwahahaa
13:04:13 <bollu> wtf
13:04:15 <lifter> lyxia: How might I know when I'd want to do that?
13:04:27 <bollu> EvanR: how?
13:04:34 <EvanR> dont ask
13:04:35 <EvanR> dont tell
13:04:35 <merijn> zero width space?
13:04:42 <dolio> No.
13:04:44 <EvanR> no space
13:04:47 <ChaiTRex> > let x = 2 in (+) 5x
13:04:49 <lambdabot>  7
13:04:58 <Athas> Oh God.
13:05:04 <bollu> yeah, what the hell?
13:05:06 <Athas> Is it because 5x is treated as two lexemes?
13:05:09 <EvanR> overloaded whitespace before it was cool?
13:05:10 <bollu> no way
13:05:13 <shapr> mjora7: I suggest asking questions here in #haskell, you'll learn much.
13:05:21 <Athas> Jesus.
13:05:25 <dolio> 0x isn't a valid token, so it parses as two tokens.
13:05:28 <EvanR> yes 5x is parsed as 5 x
13:05:29 <bollu> Athas: I refuse to believe that it is the explanation
13:05:30 <bollu> wtf
13:05:44 <EvanR> i accidentally mistyped something and was surprised to see it actually work
13:05:44 <merijn> quchen: I thought your stgi thing was online somewhere or am I misremembering?
13:05:44 <Athas> I _have_ to use this.
13:05:47 <bollu> > let x = 2 in (+) x5 # will not work since it parses?
13:05:49 <lambdabot>  <hint>:1:53: error:
13:05:50 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:05:51 <bollu> yeah
13:05:56 <bollu> what the flying fuck
13:06:16 <lyxia> lifter: when you have repetitive code that can't be simply factored out as a function
13:06:16 <bollu> EvanR: ty for coolness
13:06:31 <bollu> > let x = 10 in (*) 5x
13:06:32 <lambdabot>  50
13:06:33 <EvanR> who needs space
13:06:46 <EvanR> APL style haskell
13:06:57 <Athas> This is the worst thing.
13:07:04 <bollu> this is amazing
13:07:14 <Athas> I definitely know what I'll take care to ban in my own language.
13:07:29 <lyxia> lifter: for example, aeson uses generics to derive conversions to and from JSON. That would be tedious to write by hand otherwise if you have a lot of types.
13:07:30 <Athas> It's actually trickier to catch this in a lexer than you'd think.  Probably it snuck in by mistake.
13:07:30 <EvanR> would you allow 5+5
13:07:39 <Athas> I refuse to believe anyone thought this was a good idea.
13:07:53 <merijn> Athas: I think it was just an accident
13:08:00 <dolio> It's not a mistake.
13:08:30 <hexagoxel> meh, that clashes with rust-style non-overloaded literals, like 5int or 1u64. i still want those in haskell.
13:08:35 <dolio> Unless you think the description of how things are lexed in the Haskell report is accidentally wrong.
13:08:42 <bollu> how do I ByteString to String
13:08:46 <bollu> pretend the world is ASCII with me
13:08:47 <bollu> please
13:08:55 <hexagoxel> bollu: haha
13:09:05 <ChaiTRex> bollu: BS.unpack?
13:09:13 <bollu> ah, thank you :)
13:09:14 <EvanR> BSC.unpack
13:09:37 <merijn> dolio: I meant "no one intentionally wanted this when they wrote the report"
13:09:40 <shapr> mjora7: how'd you find Haskell the language?
13:10:06 <merijn> dolio: i.e. it was an accidental interaction of individually sensible rules that wasn't actively strived for
13:11:37 <dolio> 0x isn't even the weirdest case that is implied by the rules, I think.
13:11:50 <shapr> uh oh
13:11:51 <EvanR> i meant to type 2x
13:12:00 <EvanR> but 0x is funny
13:12:13 <dolio> A long time ago, someone pointed out that e.g. F.where should probably be parsed as F.wher e
13:12:34 <dolio> Because where is a keyword and not a valid qualified name.
13:12:50 <dolio> GHC doesn't implement that, though.
13:12:52 <Tuplanolla> That's funny.
13:13:12 <merijn> dolio: Wow...I hope someone hit that person
13:13:25 <Athas> The Haskell grammar is surprisingly complicated.
13:13:31 <Athas> Glad I don't have to parse it.
13:13:41 <Tuplanolla> It's beautiful in the same way an everywhere-continuous nowhere-differentiable function is.
13:14:08 <lifter> > let in ()
13:14:10 <lambdabot>  ()
13:14:19 <dolio> merijn: For pointing out that the specification of the lexer/parser in the Haskell report should probably be rewritten?
13:14:43 <merijn> dolio: For suggesting "F.where" should be parsed as "F.whe e"
13:14:52 <dolio> The Haskell report suggests it.
13:15:00 <EvanR> i think they pointed out the report as is implies that
13:15:01 <Athas> GHC has some tricks to permit some keywords as variable names (like "as").  Are those also present in the report?
13:15:04 <hexagoxel> lifter: needs more random "do"s inserted
13:15:06 <EvanR> which is stupid
13:15:09 <bollu> Tuplanolla: you don't think weirstrass is beautiful? :P
13:15:25 <Tuplanolla> Real analysis is disgusting.
13:15:38 <bollu> Tuplanolla: agree.
13:15:46 <EvanR> constructive analysis tho
13:15:58 <bollu> EvanR: how? 
13:16:08 <bollu> EvanR: I don't care much, I <3 algebra
13:16:19 <EvanR> infinite algebra has the same issues
13:16:30 <EvanR> off topic
13:16:35 <dolio> Athas: Unsure. I suspect 'as' is a valid variable name per the report. The keyword can't appear in many places.
13:17:15 <dolio> Allowing 'where' would probably be considerably worse.
13:18:20 <Tuplanolla> > where where where = where -- fix id
13:18:22 <lambdabot>  <hint>:1:1: error: parse error on input ‘where’
13:18:44 <Athas> dolio: right, looks like the grammar just pulls the "as" terminal out of a hat; it's not in a production for 'reservedid'.
13:18:54 <quchen> merijn: Sure it’s online 
13:18:58 <quchen> STGi, that is
13:19:12 <bollu> quchen: have you hosted it someplace?
13:19:31 <quchen> ?google quchen stgi
13:19:33 <lambdabot> https://github.com/quchen/stgi
13:19:47 <dolio> Athas: Yeah.
13:20:17 <bollu> ah, the repo
13:20:26 <bollu> wait, does that work for anything?
13:20:29 <bollu> ?google bollu simplexhc
13:20:30 <lambdabot> https://github.com/bollu/simplexhc
13:20:31 <bollu> neat
13:20:37 <lyxia> What is 'as' a keyword for?
13:20:44 <hexagoxel> import qualified
13:21:11 <dolio> qualified isn't a reservedid, either.
13:21:24 <Athas> I'm not surprised the GHC parser has so many shift/reduce conflicts.
13:22:30 <lyxia> oh right.
13:22:36 <[exa]> How would you define the difference between closure and thunk?
13:23:00 <[exa]> (if there's any)
13:24:23 <lyxia> a thunk is code representing an unevaluated value, a closure is code capturing some environment.
13:25:25 <lyxia> it seems "thunk" is actually more general than I thought https://en.wikipedia.org/wiki/Thunk
13:26:19 <lifter> I don't know if one can say a thunk is code, I think of it more as a representation in memory of an unevaluated expression.
13:28:03 <lyxia> Okay. I would say code and representation are synonymous.
13:28:57 <Philonous> How do I read a judgment of the form Γ ⊨ a ≡ b : A   ?  is it Γ ⊨ (a ≡ b) : A  or  Γ ⊨ a ≡ (b : A)   ?
13:30:05 <lyxia> it depends
13:30:25 <dolio> Neither.
13:30:34 <dolio> The point is that a and b are equal terms of type A.
13:31:55 <Philonous> That's really strange, because this paper has a Lemma that states that from Γ ⊨ a ≡ b : A follows a:A and b:A, which would be not even worth stating if what you said is true dolio 
13:32:08 <lyxia> Philonous: what paper
13:32:36 <Philonous> Weirich "A Specification of Dependently-Types Haskell" 
13:32:37 <lyxia> It could be that Γ ⊨ a ≡ b : A is a different judgement from Γ ⊨ a : A
13:33:07 <dolio> It's not a triviality. There's probably no inference rule from 'G |- a = b : A' to `G |- a : A`.
13:33:53 <lyxia> Philonous: the notation "Γ ⊨ a ≡ b : A" can't be decomposed
13:34:03 <Philonous> Ah, OK
13:36:19 <jordan3533> hi
13:36:42 <jordan3533> i know that you can get the type of an expression in ghci with ":t"
13:36:51 <jordan3533> is there anyway to define your own type and use it?
13:37:04 <dolio> Philonous: It's probably kind of like when you see judgements for well formed types 'G |- A type', and then it's proved that when you have 'G |- M : A' it happens that 'G |- A type' also holds. That way you're justified in eliding the latter as a premise for everything.
13:37:09 <jordan3533> my_type :: (j -> k) -> (l -> j) -> l -> k
13:37:09 <dolio> So your proof trees are smaller.
13:37:19 <jordan3533> how can i tell ghci about mytype?
13:37:32 <lyxia> type MyType j k l = (j -> k) -> (l -> j) -> l -> k
13:37:59 <lyxia> ghci won't magically refactor types displayed with :t though
13:38:05 <dolio> Lots of papers probably don't even bother proving it, but if you're being really meticulous, you might.
13:38:47 <jordan3533> type test j k l = (j -> k) -> (l -> j) -> l -> k
13:38:52 <jordan3533> Malformed head of type or class declaration: test j k l
13:39:10 <lyxia> type Test
13:39:13 <lyxia> with an upper T
13:39:22 <jordan3533> wow
13:39:26 <jordan3533> now it works
13:39:30 <jordan3533> why no lowercase?
13:40:07 <lyxia> lowercase identifiers are for type variables only
13:40:15 <jordan3533> alright
13:40:17 <jordan3533> ghci won't magically refactor types displayed with :t though
13:40:23 <jordan3533> what do you mean by that?
13:40:33 <Philonous> dolio, I think the real problem is that I don't fully understand what's going on. Dependent type theory seems to be full of notations and terminology that's just assumed to be understood, and I haven't yet found an introduction that properly defines all the them. So I've been reading papers and watching talks and sort-of understand what they are doing, but not in every last detail
13:40:38 <kadoban> Concrete types are capitalized. It's part of the syntax.
13:40:45 <jordan3533> :t  (foldr const) Test (curry fst)
13:40:46 <lambdabot> error:
13:40:47 <lambdabot>     • Data constructor not in scope: Test :: b -> c
13:40:47 <lambdabot>     • Perhaps you meant variable ‘nest’ (imported from Text.PrettyPrint.HughesPJ)
13:40:52 <jordan3533> will this work with my own type?
13:41:09 <jordan3533> or did u mean it "cant refactor" that it wont work
13:41:15 <monochrom> @type curry fst
13:41:16 <lambdabot> c -> b -> c
13:41:38 <dolio> Philonous: That paper certainly isn't a beginner intro to formal type theory. :)
13:41:41 <monochrom> it looks like curry fst = const
13:42:02 <monochrom> but either way it is not a list.
13:42:04 <Philonous> dolio, I've read TAPL, but it didn't deal in equalities
13:42:13 <jordan3533> Not in scope: data constructor ‘Test’
13:42:23 <jordan3533> so it wont be able to help me with my own types?
13:42:29 <monochrom> Right.
13:42:30 <lyxia> jordan3533: (\f g x -> f (g x)) has type MyType j k l, yet if you ask  :t (\f g x -> f (g x))  it will not show   MyType j k l...
13:42:45 <jordan3533> ok
13:42:49 <monochrom> But you know how to run ghci on your own computer who has access to your Test.
13:43:17 <jordan3533> it still doesnt work
13:43:22 <monochrom> But Test is not the problem. curry fst is.
13:43:38 <monochrom> where foldr wants a list, you give it a function?
13:43:43 <jordan3533> :t (foldr const) Test (curry fst)
13:43:45 <lambdabot> error:
13:43:45 <lambdabot>     • Data constructor not in scope: Test :: b -> c
13:43:45 <lambdabot>     • Perhaps you meant variable ‘nest’ (imported from Text.PrettyPrint.HughesPJ)
13:43:55 <dolio> Philonous: Ah. Well, that notation is pretty common when it's somehow important that types are involved with how equality is defined.
13:43:56 <jordan3533> after i said type Test j k l = (j -> k) -> (l -> j) -> l -> k
13:44:13 <monochrom> *shrug*
13:44:19 <dolio> If you read any OTT, it's even more verbose, because there can be different types on each side.
13:46:02 <lyxia> jordan3533: Test is a type synonym... it's not a value to apply (foldr const) to.
13:48:39 * hackage schematic 0.1.0.0 - JSON-biased spec and validation tool  https://hackage.haskell.org/package/schematic-0.1.0.0 (dredozubov)
13:49:31 <dolio> Actually, maybe the equality judgments aren't heterogeneous. Just the types.
13:50:37 <Philonous> dolio, Ah, a little later they give the dynamics of the judgement
13:51:01 <Philonous> dolio, I think the confusion really was how it (didn't) decompose 
13:51:08 <Philonous> Thanks dolio, lyxia 
13:51:20 <kova> Hello, I forgot the name of a certain virtual machine commonly used to implement the execution model of functional languages like Haskell, and I can't find resources on the internet for it.
13:51:21 <codedmart> I have `exposed-modules: Mappings` in my cabal file, but when I `stack build` I get this `Warning: The following modules should be added to exposed-modules or other-modules`?
13:51:58 <kova> Its name is an acronym of the names of the registers in it
13:52:54 <kova> ... you've got to be f****** kidding me. I just found it.
13:53:10 <spoonm> kova: what's it called?
13:53:32 <kova> spoonm The SECD machine.
13:54:02 <Philonous> That's how it works, search for hours, finally ask in IRC only to find it immediately after. 
13:54:18 <lyxia> codedmart: do you have more than a library in your cabal file
13:54:20 <kova> spoonm Stack, Environment, Control, Dump.
13:54:24 <monochrom> Haskell's is STG not SECD.
13:54:31 <lyxia> codedmart: and do you see your module being compiled twice
13:54:42 <monochrom> Not to mention that SECD is call-by-value so very unrelated to Haskell.
13:54:48 <codedmart> lyxia: I have an executable.
13:55:08 <kova> monochrom well I read that it's a common target for functional language compilers
13:55:33 <monochrom> Well I read that SECD is call-by-value.
13:55:45 <lyxia> codedmart: I guess your executable and your library are at the same directory?
13:55:52 <lyxia> (they shouldn't)
13:56:07 <monochrom> I also read that "functional" is very broad, to the point Scala is functional too.
13:56:09 <codedmart> Yup they are
13:56:33 <monochrom> And Excel.
13:57:04 <monochrom> So much for reading.
13:57:11 <lyxia> codedmart: you should move the executable and the library in different directories
13:57:31 <lyxia> https://stackoverflow.com/questions/6711151/how-to-avoid-recompiling-in-this-cabal-file for instance
13:57:57 <kova> monochrom I wouldn't say that either Excel or Scala are functional. They just support the functional style (Excel less)
13:58:00 <codedmart> lyxia: OK thanks!
13:59:13 <bollu> is using sequence to convert from Either e (IO a) to IO (Either e a) "semantically true"?
13:59:20 <lpaste> Abel-Abel pasted “dynamic-cabal” at http://lpaste.net/355787
13:59:21 <bollu> I mean, it works, but it seems dishonest to use
13:59:39 * hackage threepenny-editors 0.2.0.10 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.10 (PepeIborra)
13:59:44 <quchen> bollu: »yes« and »not really«
14:00:02 <bollu> quchen: yeah, so what's the "semantically honest" function? :3
14:00:03 <abel-abel> I got this error when I run `cabal install dynamic-cabal`. How to solve that?
14:00:31 <quchen> bollu: »yes« it’s »semantically true« (whatever that means), »not really« its’t not dishonest no
14:00:33 <abel-abel> Do I have to fix the bug in the source code of the library?
14:00:45 <bollu> ah, I see
14:00:50 <bollu> quchen: like, in the sense of
14:01:24 <bollu> quchen: you can replace traverse with forM, but that's asking for too much strength
14:01:28 <quchen> abel-abel: It could just be a wrong version in the dependency of a package
14:01:32 <bollu> quchen: so, well, is using traverse in this situation something like that
14:01:36 <quchen> forM is redundant (because of for_)
14:01:42 <quchen> s/for_/for
14:01:47 <quchen> and for is just flipped traverse
14:01:54 <quchen> and traverse is sequence . fmap f
14:02:02 <quchen> So there you have your sequence back :-)
14:02:14 <bollu> :P
14:02:16 <bollu> OK
14:02:22 <bollu> but you got the spirit of my question I hope?
14:02:44 <quchen> Not really. »semantic honesty« is not something I’ve heard before.
14:02:58 <quchen> It works. It uses correct functions. It typechecks. It does what it should.
14:03:04 <bollu> quchen: am I asking for a ring when all I want is the underlying additive structure ?
14:03:08 <bollu> quchen: something like that
14:03:20 <abel-abel> quchen, a wrong version? where to fix that?
14:03:26 <bollu> quchen: "am I asking for the minimal algebra
14:03:26 <bollu> "
14:03:40 <quchen> Oh, you’re wondering whether there is something simpler. Well, explicit pattern matching, but then you’d just be reinventing things.
14:03:51 <bollu> hm, OK
14:03:52 <quchen> That’s how the traversable instance of Either works after all.
14:04:13 <quchen> Anyway, I think sequence is fine here.
14:04:27 <bollu> yeah
14:09:41 <quchen> abel-abel: I’m not familiar (enough) with Cabal anymore :-$
14:09:47 <quchen> There is a flag --allow-newer I think
14:09:56 <jordan3533> why do i even have to learn unification step by step
14:10:00 <jordan3533> my class is so weird
14:10:14 <quchen> Hah, you’re the second one having to do this today.
14:10:22 <quchen> Studying in Frankfurt by any chance?
14:10:26 <jordan3533> yeah
14:10:30 <jordan3533> who else did it?
14:10:38 <abel-abel> quchen, thanks.
14:10:38 <quchen> I don’t remember the name.
14:10:44 <quchen> It was exercise 3. :-þ
14:10:49 <monochrom> You don't have to. If you never make type errors, you don't need to do unification yourself.
14:10:51 <jordan3533> did he get the solution?
14:11:01 <jordan3533> i should start monitoring this irc ^
14:11:05 <quchen> We didn’t talk about that exercise.
14:11:09 <quchen> I just saw the PDF.
14:11:38 <EvanR> professor: "go to #haskell, im taking the day off"
14:11:55 <monochrom> But what's wrong with learning unification?
14:11:59 <Tuplanolla> I'm a bit surprised I've never seen our students here.
14:12:06 <jordan3533> prof: you dont know what unification is and never saw an example? well 50% of the points for this task gl hf
14:12:40 <quchen> Unification is fairly simple. Type inference would be worse.
14:12:47 <abel-abel> which course are you talking about
14:13:03 <jordan3533> programming 2
14:13:30 <abel-abel> programming 2?
14:13:38 <jordan3533> yes
14:13:50 <monochrom> Yeah, "programming 2" is a universally known standard. Right? Right?
14:13:51 <abel-abel> which programming 2?
14:14:04 <abel-abel> :(
14:14:04 <jordan3533> its the name of the course
14:14:07 <jordan3533> we do haskell
14:14:12 <jordan3533> and later sql i think
14:14:53 <quchen> Interesting combination.
14:14:54 <monochrom> Here in North America we call it "computer science 2.718"
14:15:23 <jordan3533> lel
14:15:24 <Tuplanolla> Even your courses have floating-point errors.
14:15:50 <jordan3533> does anyone do my task lol
14:16:00 <jordan3533> its 50% and i dont even get it
14:16:09 <jordan3533> wanna*
14:16:18 <monochrom> Consider changing career.
14:16:33 <jordan3533> i wanna learn it
14:16:38 <jordan3533> but not rn lol
14:16:51 <quchen> Rn is the worst, yes.
14:17:03 <Tuplanolla> Now is the only time for most things.
14:17:31 <abel-abel> googled 'programming 2' and got this: https://www.monash.edu.au/pubs/handbooks/units/FIT2034.html 
14:17:37 <jordan3533> :t curry fst
14:17:39 <lambdabot> c -> b -> c
14:17:40 <jordan3533> thats the task
14:17:42 <abel-abel> nothing about haskell :(
14:17:52 <jordan3533> why do i have to do it myself smh
14:18:19 <quchen> Same reason you calculated 1+1 yourself that one time.
14:19:19 <quchen> abel-abel: It’s called »Programmierung 2« and it’s in German.
14:20:47 <abel-abel> quchen, thanks. sadly. I don't know German.
14:21:23 <jordan3533> NOW is the time to learn it
14:22:30 <abel-abel> I guess I'll forget to learn Haskell when I am trying to learn German. :(
14:22:57 <quchen> abel-abel: The exercise isn’t really about Haskell, but about its background in Hindley-Milner type inference.
14:22:58 <jordan3533> there is no such thing as a full brain capacity
14:24:11 <abel-abel> quchen, got it.
14:30:22 <monochrom> Do I even want to read the actual assignment? :)
14:34:15 <jordan3533> https://imgur.com/a/t6gAP
14:34:19 <jordan3533> enjoy monochrom
14:35:15 <monochrom> Oh God, you can't even tell apart "foldr const (curry fst)" from "foldr const . curry fst".
14:35:55 <monochrom> (And what's with that "Test" thing which isn't even in the question?)
14:36:36 <jordan3533> the test thing was another name for "."
14:37:28 <monochrom> OK, that only adds two more problems.
14:37:35 <bollu> cocreature: ping
14:37:35 <jordan3533> the previous task was like "write a list comprehension that filters numbers bigger than 5"
14:37:37 <jordan3533> and now this
14:37:38 <jordan3533> wtf
14:38:25 <mauke> welcome to the learning wall :-)
14:38:27 <monochrom> "problem" in the sense of: When some people are confronted with a problem, they say, "I think ___ is a good idea". Now they have two problems.
14:38:36 <mauke> it's like a curve, only slightly steeper
14:38:50 <eacameron> I have a typeclass Atomable that allows me to turn various types into the "Atom" type. I'd now like to create a Map AttributeName Atom but without requiring anyone to use the "toAtom" method. I'd rather write `Map AttributeName (forall a. Atomable a => a)` but GHC complains about impredicative polymorphism.
14:38:54 <eacameron> Is there a workaround?
14:39:40 <mauke> it would have to be 'exists' anyway
14:39:46 <dmwit> eacameron: `insert :: Atomable a => AttributeName -> a -> Map AttributeName Atom -> Map AttributeName Atom`?
14:39:59 <bollu> https://github.com/llvm-hs/llvm-hs/blob/llvm-4/llvm-hs/test/LLVM/Test/Global.hs#L28 
14:40:02 <monochrom> But anyway, the two additional, self-inflicted, artificially created problems: 1. Test is a type, "." is not a type.  2. "f x y" and "f . y" are different, even when "x" is defined to be ".".
14:40:08 <bollu> ^ is that a haskell-ism I am unaware of?
14:40:22 <bollu> i.e, referring to a global data structure and then editing it with { }
14:40:34 <dmwit> bollu: It's just record update syntax.
14:40:34 <mauke> bollu: record update
14:40:43 <monochrom> This is beyond XY problems. This is XYZ@#$ problems. 
14:40:45 <dmwit> Whether you are aware of it or not, I don't think anybody here can say. =)
14:40:54 <eacameron> dmwit: That's not a bad workaround I suppose.
14:41:28 <eacameron> dmwit: I thought there was a way to use existential quantification in cases like this?
14:41:39 <bollu>  dmwit: nice
14:41:42 <dmwit> eacameron: Sure. But why?
14:41:46 <bollu> dmwit: that really simplifies life
14:41:51 <eacameron> dmwit: Why not?
14:41:53 <bollu> dmwit: how did I not know this exists?
14:42:03 <bollu> dmwit: I wound up just learning lens when I needed updates >_<
14:42:10 <dmwit> eacameron: Skip an extension without losing functionality or concision. What's not to love?
14:42:13 <bollu> dmwit: and I'm consider myself "intermediate" at haskell
14:42:49 <monochrom> @type const
14:42:50 <erisco> jordan3533, inadequate teaching is a fault, but relying on the compiler to tell you the type is weak
14:42:50 <lambdabot> a -> b -> a
14:43:00 <dmwit> eacameron: Bonus points: the library writer gets to do extra work rather than the library user. Usually that's a good tradeoff.
14:43:28 <eacameron> dmwit: I guess I'd have to use the constructor for the existential quantified type anyway?
14:43:28 <dmwit> (Even though the extra work is very light: one extra token in each case, usually.)
14:43:31 <erisco> jordan3533, it is much stronger to be able to do this in your head because it can, and usually does, guide you to the program you want
14:43:39 <dmwit> eacameron: Exactly what I'm referring to, yeah. =)
14:43:52 <monochrom> erisco: True about inadequate teaching, but do not be so quick to assume it, for you haven't really seen what the teacher did.
14:44:09 * hackage preamble 0.0.37 - Yet another prelude.  https://hackage.haskell.org/package/preamble-0.0.37 (markfine)
14:44:19 <erisco> and I do not assume it
14:44:32 <dmwit> monochrom: In fact, I am quick to assume the opposite, because there is an SO question with a quite detailed working out of this question in a very clean notation that I doubt a student could invent on their own.
14:44:36 <eacameron> dmwit: I don't understand why existential quantification is possible but my use case is not. All I'm doing is naming the thing.
14:44:37 <monochrom> My experience in efnet #math is that most students who claim "the teacher/textbook/whatever didn't tell us" were lying.
14:45:02 <erisco> may more often be explained as the student not listening ;)
14:45:03 <dmwit> eacameron: What do you mean by "my use case is not possible"?
14:45:06 <Logio> erisco, monochrom: that's also the kind of problem that is really trivial after you know what to do (and therefore hard to teach to people who don't)
14:45:17 <jordan3533> ^
14:45:36 <eacameron> dmwit: I mean I don't know why using the forall directly runs up against impredicative types but putting it inside a data constructor does not.
14:45:37 <Logio> speaking as a former TA of a Haskell course :P
14:46:28 <monochrom> "curry fst" and "foldr const" are within reach.
14:46:38 <dmwit> eacameron: Two reasons: 1. you are using a different quantifier (even though it's spelled the same in Haskell) 2. Because adding a constructor to guide the type system makes a lot of things easier. See also: equirecursive vs isorecursive types.
14:47:15 <dmwit> eacameron: The constructor acts as a "hint" about where exactly the boundary between polymorphic and monomorphic occurs.
14:47:32 <eacameron> dmwit: Very interesting.
14:47:51 <eacameron> dmwit: That's helpful. I'll use your workaround then. Thank you for the help!
14:48:19 <monochrom> Yes, equirecursive code is pretty confusing to me.
14:48:45 <monochrom> (Nevermind whether it is confusing to the computer. I'm sure someone can get it to work.)
14:49:01 <bollu> what's the context here with existentials?
14:49:13 <dmwit> I'm pretty sure the "obvious" equirecursive type system is undecidable for both checking and inference.
14:49:52 <dmwit> So, confusing to computers, too. =)
14:52:46 <erisco> monochrom, I think saying if we never make type errors then we needn't worry about types is a corollary from the purpose of types is to prevent errors
14:53:06 <erisco> monochrom, but I think we would both say this is not the only way to make use of types
14:54:29 <monochrom> Eh? That's not what I said.
14:54:46 <monochrom> Exercise for the reader: What did I say?
14:55:18 <erisco> your message just left my log, darn, but I must have misunderstood then
14:56:01 <monochrom> If you never make type errors, you don't need to do unification (or type inference) yourself.
14:56:16 <erisco> oh never mind, it is still there, and yes that is it
14:57:18 <bollu> @tell cocreature I may need coroutines in LLVM 5. Do you plan on supporting LLVM 5 just yet?
14:57:18 <lambdabot> Consider it noted.
14:57:31 <erisco> well now I can't steer myself to any other reading of it :P
14:57:42 <bollu> @tell cocreature if not, what's my best course of action? write C FFI and then link to it?
14:57:42 <lambdabot> Consider it noted.
14:58:03 <bollu> @tell cocreature, my stuff <-> C FFI <-> C++ code that does LLVM work with coro <—> LLVM?
14:58:03 <lambdabot> Consider it noted.
14:59:38 <erisco> monochrom, can you clarify for me?
15:00:29 <monochrom> How about this. Why do you think that "do unification yourself" and "worry about types" are equivalent?
15:02:05 <erisco> why not just tell me and then I won't have to wander about what you're really meaning
15:03:12 <monochrom> Unification means unification. OK? I don't see how that extrapolates to worrying about types which is so much broader and so many extra aspects than unification.
15:03:34 <bollu> @tell cocreature so, it's part of LLVM 4, but not part of llvm-hs. I left this issue, I'd love pointers - https://github.com/llvm-hs/llvm-hs/issues/110
15:03:34 <lambdabot> Consider it noted.
15:04:05 <monochrom> To me you're like "monochrom, you said under some circumstance one doesn't need to do math. So you mean one doesn't need to think?"
15:05:35 <monochrom> Why do people always do this to me? Why do they keep putting words into my mouth?
15:07:24 <erisco> it isn't a conspiracy, I assure you... but I need to reinterpret the conversation now because I am confused
15:08:01 <monochrom> I feel like some people are English Literature majors so that if I say so much as "I saw a dog playing with a cat today" they are going to say "monochrom, what you said is such a beautiful political allegory"
15:08:48 <hpc> monochrom: this is why i never say anything that can be misconstrued as factual
15:10:07 <c_wraith> hpc, is that so? 
15:10:56 <peterbecich> Hello, I'm trying to build `accelerate-llvm` and encounter an error when compiling the dependency `llvm-hs`.  Any ideas what I'm doing wrong?  I have LLVM 4.0.0.  Thank you: http://lpaste.net/667392219346370560
15:11:22 <erisco> monochrom, I am beginning with the picture of a programmer who never makes type errors yet does not know how to do unification
15:11:39 <peterbecich> The dependency is llvm-hs version 4.0.1.0.  I am compiling llvm-hs 4.1.0.0 to see if it has the same issue.
15:12:05 <mauke> you can't make type errors  <meme here>  if your language is untyped
15:12:10 <erisco> monochrom, and also that by saying "never makes type errors" I am assuming this programmer can write any program and not just trivial ones not involving polymorphism
15:12:45 <bollu> peterbecich: which OS and compileR?
15:13:05 <erisco> so somehow we're writing perfect programs yet are oblivious to the types. I cannot see how we'd have any picture of the types without knowing unification
15:13:08 <monochrom> erisco, you accept the fact that people like Ramajuan exist whose intuition is correct 99.9% of the time and they can't even tell you why?
15:14:02 <actualHuman_462> I write quite a bit of Haskell code that seems to work pretty well and have never heard of the concept of unification before today.
15:14:13 <erisco> I don't know this person but if they fit the description of the programmer I am describing then they do not refute my point here
15:14:14 <peterbecich> bollu: Debian 8.8   and presumably llvm 4.0.0.  I have other llvm versions on the path.  Maybe I need to remove those.
15:14:24 <peterbecich> llvm-ar --version gives 4.0.0
15:14:41 <bollu> peterbecich: no, LLVM is the LLVM version. But, which C/C++ compiler is being picked up?
15:14:47 <bollu> peterbecich: what's your CC / CXX?
15:15:06 <monochrom> I'm done explaining myself. Not my problem anymore.
15:15:16 <peterbecich> bollu: oh, thanks.  gcc --version gives 4.9.2
15:15:21 <bollu> peterbecich: hmm.
15:15:38 <peterbecich> bollu: clang --version gives 3.5.0-10
15:15:49 <peterbecich> bollu: I'm not sure whether it is using clang or gcc
15:15:50 <bollu> peterbecich: can you set CC and CXX to clang and then run stack build?
15:16:02 <bollu> peterbecich: I'd be interested in what happens. (I don't work on llvm-hs, just use it)
15:16:20 <bollu> peterbecich: so I'm just asking you to try things :)
15:16:24 <bollu> peterbecich: but, well
15:16:28 <bollu> peterbecich: could you try?
15:17:04 <erisco> well, I was just going to get around to specification as a purpose of types
15:17:39 <peterbecich> bollu: also, is this a problem?  "Debian clang version 3.5.0-10 ... (based on LLVM 3.5.0)"
15:18:29 <bollu> peterbecich: shouldn't be, because it's picking up the right llvm version. shouldn't matter what clang was compiled with
15:18:34 <peterbecich> I built and installed LLVM 4 manually as I don't have Debian Sid packages.  I think 4.0 is only available on Sid.
15:19:15 <peterbecich> Ah thanks.
15:19:39 <peterbecich> How do I set CC and CXX?  Happy to try this.  Sounds interesting.  Thanks
15:19:58 <bollu> export CC=clang
15:20:03 <bollu> export CXX=clang
15:20:21 <bollu> $ CC=clang CXX=clang stack build —verbose
15:20:27 <bollu> ^ that should work out of the box
15:20:45 <bollu> you'll have to replace — with "- -" because mac OS likes to fuse my — into a single line in a text bos
15:20:46 <bollu> box*
15:21:15 <peterbecich> bollu: Thanks, building now
15:22:48 <peterbecich> bollu: no luck   http://lpaste.net/355788
15:24:57 <bollu> peterbecich: can you stack clean --full
15:25:08 <bollu> peterbecich: and then run "CC=clang CXX=clang stack build —verbose"
15:25:14 <bollu> in the same line the CC, CXX and the stack build
15:25:21 <bollu> this is probably superstition
15:25:44 <monochrom> Does stack actually honour CC and CXX?
15:25:53 <bollu> I think so
15:26:16 <bollu> IIRC, I managed to force it to use ccache'd clang
15:26:20 <bollu> because building took way too long
15:26:22 <peterbecich> bollu: looks promising!  Hasn't crashed yet.  I had not set CC and CXX in the same line, before
15:26:34 <bollu> peterbecich: it shoudln't actually matter
15:27:56 <peterbecich> so you think the `stack clean --full` made the difference?  I built this from source successfully a few weeks ago, with an older commit.  The latest commit changed the version of llvm-hs: https://github.com/AccelerateHS/accelerate-llvm/commit/3dd939af03175f28cc79807dd575abede59f7a46
15:28:22 <peterbecich> bollu: I think it is building successfully.  May take a while.  I will report back.  Thanks!
15:28:45 <bollu> peterbecich: yeah, possibly. But then again, like I said, "superstition" :)
15:28:56 <bollu> peterbecich: I don't understand either stack or GHC's build process well / at all
15:28:57 <peterbecich> :) 
15:29:40 <peterbecich> me neither 
15:35:16 <peterbecich> bollu: accelerate-llvm built successfully!  Thanks very much!
15:37:23 <bollu> peterbecich: yw
15:37:27 <bollu> peterbecich: glad I could hep
15:37:29 <bollu> help*
15:56:50 <Rotaerk> is there a better hoogle instance than https://www.haskell.org/hoogle?
15:57:02 <Rotaerk> stackage is better in some ways, but it's missing some stuff
15:57:47 <geekosaur> I think hoogle.haskell.org is preferred now?
15:58:06 <geekosaur> but each has shortcomings: the one you used has an out of date database, but handles fuzzy types better than the new one
15:58:51 <Rotaerk> ah, thanks
16:02:49 <sm> http://hoogle.haskell.org
16:28:13 <nishiki_> Hi, how do I print what an instance of Arbitrary?
16:28:49 <nishiki_> I've defined an arbitrary for a binary tree and would like to see what it looks like
16:35:03 <sm> if you can make it also an instance of Show, use pretty-show ?
16:35:18 <pikajude> nishiki_: looks like `arbitrary` creates one
16:35:23 <pikajude> or a generator, rather
16:35:35 <pikajude> i'm assuming there's a function that runs a generator
16:35:59 <pikajude> oh, `generate`
16:36:05 <pikajude> looks like `generate arbitrary` will generate one
16:40:46 <mb013619> i'm trying write a rest client and following https://haskell-lang.org/library/http-client, but either the httpJSON example is out of date, or something else is wrong since the example isn't working for me
16:41:00 <mb013619> i'm somewhat new to haskell, here's a gist of the error:  https://gist.github.com/brailsmt/792a070d8111ff96aea7905be7a888f4
16:41:32 <mb013619> i've tried all sorts of things, but i can't seem to get the incantations just right...
16:41:59 <Rembane> mb013619: Try a request <- setRequestHeader ... 
16:42:07 <Rembane> mb013619: Instead of the let request = ...
16:42:31 <sm> indentation of line 19 looks wrong
16:43:37 <sm> the ambiguous type error for resp is because you aren't using resp for anything yet, you can comment out that line or add an explicit type annotation
16:43:54 <mb013619> yeah, using 'request <- setRequest...' winds up with a couldn't match IO Request with Request
16:44:30 <mb013619> sm: k, i'll try that
16:50:35 <sm> also parseRequest is a monadic function. I think you missed a line or two from the example you're following
16:51:28 <mb013619> yeah, i just fixed that one, and got Lib.hs to load
16:51:52 <mb013619> sm, Rembane: thx
16:52:18 <Rembane> mb013619: No worries. Good luck!
17:05:40 <mb013619_> is there an nvim-hs related channel that anyone is aware of?
17:28:28 <codedmart> I suck with lens. If I have a responseBody `"{\"message\":\"Body should be a JSON object\"}"` when using http-client. What is my best option to access `message`. Just return a `Maybe Text`?
17:33:17 <Gurkenglas> codedmart, I'm not sure I understood the question. http://hackage.haskell.org/package/lens-aeson-1.0.1/docs/Data-Aeson-Lens.html#v:key gives you that Maybe Text. If you want to crash if there's no message key, http://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-Fold.html#v:-94--63--33- gives you the corresponding Text.
17:35:19 <codedmart> Gurkenglas: Hmm... I am trying to use that but even using the example in ghci `"{\"a\": 100, \"b\": 200}" ^? key "a"` I get an error `Could not deduce (Data.String.IsString (Maybe A.Value))`
17:37:56 <Gurkenglas> You usually want to paste the whole error to lpaste or the like in such cases, but my first guess would be that you haven't enabled OverloadedStrings?
17:38:31 <codedmart> Gurkenglas: Yeah was getting that: https://gist.github.com/codedmart/377b16e921b6bb34083558eb64063a01
17:38:51 <codedmart> I do have OverloadedStrings set.
17:41:13 <Gurkenglas> If I encountered this error, I would proceed to spam type signature annotations in hopes that the error changes once one of my annotations surprises the compiler.
17:42:18 <Gurkenglas> I've heard that there's IDEs today that show you the types deduced for each term, so that you can be surprised by the compiler's annotations instead.
17:48:01 <codedmart> Gurkenglas: Thanks!
17:48:09 * hackage riak 1.1.2.0 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.1.2.0 (lambda_foo)
17:48:47 <Gurkenglas> Don't leave me hanging like that, what was the problem?
17:53:06 <actualHuman_462> Anybody know of some package implementing a Free Monad interpreter that's somewhere between 'FizzBuzz' and 'avionics controll system for cruise missile' on the complexity scale?
17:54:08 <monochrom> Consider free-game.
17:54:57 <monochrom> Read its oldest versions to see the basic idea. The current version adds too many features, becoming obfuscating.
17:57:22 <actualHuman_462> Thank you, this seems like a solid example
18:02:47 <dihuteno> if I'm working in the repl inside a stack project and I realised that I forgot to add a depedency to my project (because import X gives a module not found error) is there a way I can load it into the repl session without exiting and starting again?
18:05:32 <actualHuman_462> +/-
18:08:15 <actualHuman_462> As I understand it, stack just wraps ghci when it boots it up, so I don't think you can go through the full 'find my package on stackage and D/L it for me' set of steps - but if you already have the module locally, like it's a part of your project, you should be able to slap it into your .cabal file and use :module to re-load your project. It's probably a whole lot easier to just :quit, edit the file and re-run stack ghci tho.
18:09:29 <actualHuman_462> I have yet to run into a scenario in which it wasn't easier to just exit and re-load anyway.
18:20:39 <dihuteno> actualHuman_462: just had a few variables and functions that I didn't want to have to reset, I guess I should just be putting them in a .hs file and loading that
18:21:21 <dihuteno> :module didn't work unfortunately so quitting seems to be the way to go
18:28:02 <thang1> Anyone know of haskell stuff in portland besides Galois?
18:40:09 * hackage postgrest-ws 0.3.2.0 - PostgREST extension to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgrest-ws-0.3.2.0 (diogob)
18:51:58 <halogenandtoast> I'm trying out stack's docker integration. So far it seems amazing, is there anything I should be aware of or watch out for?
18:54:53 <TheInfosphere> Hey all! I'm trying to build a cross compiler from darwin to the raspberry pi and I'm almost done, but when I try to configure the makefile, configure can't find libffi
18:56:01 <TheInfosphere> pkg-config can find it, and other things that depend on it find it no problem. I'm not sure this is the right place to ask, but I hope someone can at least point me in the right direction
19:01:23 <Lokathor> so
19:01:42 <Lokathor> using List as a Monad is fine, but ListT is some sort of not fine thing?
19:03:19 <c_wraith> Lokathor: ListT is fine *sometimes*.
19:03:47 <c_wraith> Lokathor: which is why [] is fine, and [] is not considered fine for arbitrary use
19:03:58 <c_wraith> err, and ListT is not considered...
19:04:20 <Lokathor> computeVerticies :: (Int, Int) -> (Int, Int) -> [(GLfloat,GLfloat)]
19:04:20 <Lokathor> computeVerticies (rows,cols) (cellWidth,cellHeight) = do
19:04:36 <c_wraith> Lokathor: like, ListT is fine if it's only used with Reader, Writer, or State
19:04:38 <Lokathor> i'm just using this to build a long list
19:06:35 <c_wraith> Lokathor: by analogy..  ST is fine as a monad.  STT would have... issues.
19:06:50 <Rotaerk> here's a "ListT done right":  https://hackage.haskell.org/package/pipes-4.3.2/docs/Pipes-Tutorial.html#g:6
19:06:54 <c_wraith> Lokathor: validity of something as a monad does not mean it's also valid as a monad transformer.
19:07:09 <Lokathor> STT would be the most unboxed of all types
19:07:34 <Lokathor> the most deeply mutable possible structure
19:08:13 <dolio> ListT is okay with Reader, but not State and (in general) Writer.
19:08:49 <c_wraith> Oh, right.  I used it with Writer that was restricted to "add 1 to the accumulator", which is sufficiently restricted that it works.
19:09:02 <Lokathor> I also heard that Writer is a bit of a stinker of a Monad :P
19:09:04 <c_wraith> it's commutative, and all
19:09:18 <c_wraith> Writer is fine conceptually.  The implementation has a problem
19:10:19 <c_wraith> dolio: that's where it works, right?  ListT m is a monad when m is a commutative monad?
19:10:27 <dolio> Yeah.
19:10:46 <c_wraith> so ListT Maybe also totally works. :)
19:12:52 <c_wraith> Lokathor: if you're curious, a commutative monad is one where do { x <- m ; y <- n ; f x y } is equivalent to do { y <- n ; x <- m ; f x y} for all f, x, and y
19:13:39 <Lokathor> ah, well, i guess that makes sense
19:15:02 <c_wraith> Uh, f, m, and n, u mean
19:15:06 <c_wraith> *I
19:17:56 <Koterpillar> halogenandtoast: you can't cache ~/.stack
19:18:33 <Koterpillar> halogenandtoast: so even if you build yourself a nice Docker image with packages you depend on, it's useless for a cold start on another machine
19:21:17 <halogenandtoast> Koterpillar: hmm, I think I want to simply avoid issues like "setup: Missing dependencies on foreign libraries:"
19:21:25 <halogenandtoast> That sucks that ~/.stack can't be cached.
19:21:46 <Koterpillar> halogenandtoast: foreign libraries are fine
19:22:35 <Koterpillar> I'm curious whether Stack (or perhaps Nix) can move their respective stores from a POSIX filesystem to either S3 or IPFS
19:22:49 <halogenandtoast> Koterpillar: would you happen to know how I can add Mysql as a service for my image? Would I just make a docker compose image (or whatever replaced docker compose).
19:23:25 <halogenandtoast> And will stack integrate with docker compose in any way?
19:23:27 <Koterpillar> Why would you want the service in the image? You can add the library, and it'll help building, but a service won't run
19:24:02 <thang1> Just out of curiosity... What sort of thing would you guys write/use to convert integers into roman numerals in the most generic and powerful way possible? I was thinking of a parser but apparently they don't handle subtraction rules very well? (eg 4 = IV, not IIII)
19:24:02 <Koterpillar> Your end result from stack docker is still a binary. If you want, put it into another Docker image, and compose that with a MySQL one.
19:25:16 <halogenandtoast> Hmm okay.
19:25:36 <halogenandtoast> Koterpillar: thanks for the info, I'll have to mess with this a bit.
19:36:23 <EvanR> thang1: the roman numerals hackage package
19:39:11 <thang1> oooh, interesting. I'm not sure it's as powerful as I want it to be, but it looks better than most conversions
19:40:56 <thang1> He uses unicode in his haskell. Interesting :p
19:42:06 <halogenandtoast> Koterpillar: to answer your previous question, I actually understand very little about Docker. I just want to simplify installation for my non Haskell coworkers.
19:42:24 <halogenandtoast> I also want to make it deployable, it's quite possible I'm using the wrong terminology
19:42:31 <halogenandtoast> or attempting to do the completely wrong thing
19:43:51 <thang1> Damnit, the roman numerals package only works correctly for numbers 1..4000 and just spams M for numbers larger
19:43:53 <halogenandtoast> Which is pretty typical for me.
19:44:10 <Koterpillar> halogenandtoast: which of these are you expecting your coworkers not to have: GHC; foreign libraries you depend on; MySQL server; Docker?
19:44:30 <halogenandtoast> GHC and foreign libraries
19:45:01 <Koterpillar> then you don't need the compose bit for MySQL
19:45:23 <Koterpillar> you need a statically linked binary _or_ a container with all the libraries
19:45:54 <halogenandtoast> hmm, I went down this path because of how I interpreted this error message: "mirin: ConnectionError {errFunction = "connect", errNumber = 2002, errMessage = "Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)"}"
19:45:56 <Koterpillar> stack docker will only help with the first; plain docker with the second
19:46:13 <halogenandtoast> when running stack exec mirin.
19:46:19 <Koterpillar> ok, so you are expecting your users to run a local MySQL server?
19:46:36 <halogenandtoast> either way is probably fine.
19:46:57 <halogenandtoast> So basically I don't yet care, I may in the future, but I know everyone has a local mysql instance.
19:47:15 <halogenandtoast> If I run the app on a production server, it will probably use an Amazon instance for the database
19:47:18 <halogenandtoast> instead of locally
19:48:12 <Koterpillar> so _this_ bit docker compose can help address
19:50:05 <halogenandtoast> Koterpillar: okay I'll look into it, have to run for lunch now. Thanks for the pointers.
20:24:09 * hackage genvalidity-time 0.0.0.2 - GenValidity support for time  https://hackage.haskell.org/package/genvalidity-time-0.0.0.2 (Norfair)
20:49:08 * hackage amazonka-s3-streaming 0.2.0.2 - Provides conduits to upload data to S3 using the Multipart API  https://hackage.haskell.org/package/amazonka-s3-streaming-0.2.0.2 (AlexMason)
21:22:42 <mjora7> How do I run a stack project in a repl? When I use `stack repl` and then try to load my entry file `:load app/Main.hs`, I get a bunch of errors that modules could not be loaded
21:29:04 <TheInfosphere> Hey all! I'm trying to build a cross compiler from darwin to the raspberry pi and I'm almost done, but when I run ./configure, configure can't find libffi, despite LDFLAGS and CFLAGS being set correctly
21:30:06 <wedens> what library can I use if I need to extract some data from XSD schema?
21:30:20 <TheInfosphere> that is, when I run ./configure in the directory with the ghc source
21:38:49 <ninedotnine> when will i ever learn... https://github.com/ninedotnine/util/commit/b16bcbb1ee782558527f4873d3a1fbbd27948881
21:41:27 <halogenandtoast> ninedotnine: the correct answer is never.
21:41:47 <ninedotnine> :^( 
21:42:09 <halogenandtoast> I think I would have made the same mistake.
21:43:04 <halogenandtoast> Any good resources for learning the Free Monad gently?
21:43:18 <thang1> I think everyone makes the same mistake lol
21:43:35 <thang1> filter is an ambigious name in the worst way.
21:43:50 <mjora7> I get this error: `Couldn't match type ‘[Char]’
21:43:51 <mjora7>                      with ‘text-1.2.2.1:Data.Text.Internal.Lazy.Text’`, how do I convert a String to that long type?
21:44:04 <thang1> If you have to remember "coffee filters hold all the coffee" to remember how filter works, you named it the wrong thing
21:44:04 <halogenandtoast> You just need a text type right?
21:44:10 <halogenandtoast> pack probably
21:44:26 <halogenandtoast> I might be confusing ByteString one moment
21:44:28 <mjora7> halogenandtoast: Where do I find that?
21:44:30 <thang1> mjora7: somewhere you have a string conversion error
21:45:13 <halogenandtoast> mjora7: there's a pack in Data.Text, I usually import qualified Data.Text as T and use T.pack
21:45:22 <thang1> Haskell has String (which is [Char]), ByteString, a lazy ByteString, Text, and a lazy Text
21:45:43 <halogenandtoast> if you need lazy pack it's in Data.Text.Lazy  
21:46:15 <thang1> theres' also IsString, text-icu for more unicode stuff, utf8-string library, and a ListLike package for a common interface to all strings, yadda yadda
21:46:25 <mjora7> I try `import Data.Text` in ghci and get "could not find module Data.Text"
21:46:33 <halogenandtoast> add text to your cabal
21:46:56 <mjora7> Ok this is going above my head hahah
21:46:59 <thang1> You need to download it from hackage in your cabal file. It's confusing, to be honest. This is probably my least favorite part of haskell
21:47:20 <halogenandtoast> what function are you trying to use that gives you that error?
21:47:23 <halogenandtoast> mjora7: ^^
21:47:24 <mjora7> Ugh everything Haskell goes above my head, how high is the entry level for this language hahah. 
21:47:39 <halogenandtoast> mjora7: depends on where you are coming from.
21:47:47 <jle`> mjora7: btw, the type itself isn't that long, it's just Text
21:47:50 <mjora7> halogenandtoast: Just trying to do something with the Scotty framework, the html function
21:47:51 <jle`> it's just shown qualified
21:48:08 <halogenandtoast> mjora7 I have a solution for you
21:48:18 <halogenandtoast> add {-# LANGUAGE OverloadedStrings #-}
21:48:23 <halogenandtoast> to the top of your file
21:48:50 <lpaste> heath pasted “HelloWorldB.hs” at http://lpaste.net/355803
21:48:52 <mjora7> halogenandtoast: Actually already have that
21:48:57 <thang1> mjora7: dealing with frameworks and html and all that are generally not super great ideas for beginners. Haskell is really weird with that, you really have to start super slow and easy and work your way up or it's just too much to remeber all of the legacy crap you have to deal with
21:49:25 <heath> mjora7: check this out: http://lpaste.net/355803 stack will download the dependencies for you automatically if you write your app similar to this
21:49:39 <heath> s/app/script
21:49:55 <halogenandtoast> mjora7: if you have source code at the ready, I'd be happy to look (as would be others I assume)
21:50:00 <mjora7> thang1: Would you have any other suggestions of what I should do? If it was JavaScript I'd make a simple server, C I'd reimplement some command-line tools,
21:50:46 <halogenandtoast> mjora7: For me to learn Haskell I wrote a few simple games (ones without random numbers).
21:50:54 <mjora7> thang1: I just keep going through this Haskell textbook and wonder when I'm going to be able to write a program that does anything. Halfway through and I can't even do console input! Kind of ridiculous IMO. I'm aware that it's a bit more complex in Haskell than in other languages.
21:51:12 <halogenandtoast> mjora7: the sad part is this
21:51:18 <thang1> With C-family languages, you already know all of the standard ways of thinking about how it works. With Haskell you're learning a new way of thinking; the language itself is somewhat orthogonal to that goal
21:51:18 <halogenandtoast> Most things are simple
21:51:27 <halogenandtoast> so simple in fact that they go back around to being complicated
21:51:40 <thang1> mjora7: which textbook are you using? Just curious
21:51:48 <mjora7> Learn You a Haskell
21:51:51 <halogenandtoast> eh
21:52:03 <halogenandtoast> That was my least favorite Haskell book.
21:52:31 <thang1> oooh... Yeah, we really need to get rid of that book and all of the other outdated and inferior learning materials off of the r/haskell sidebar. It's ridiculous that they're still there at this point
21:52:35 <halogenandtoast> mjora7: can you paste your code somewhere?
21:53:01 <mjora7> Have to run at the moment, I will be back a little bit later and paste it though!
21:53:05 <mjora7> Talk to you guys soon.
21:53:07 <thang1> Anywya, mjora7, your problem is that you're [Char] or String somewhere and you're trying to shove that type into html which only works with Text
21:53:57 <thang1> OverloadedStrings allows literal "text" to be converted much more easily, but hand converting a bunch of stuff is often still required. Try surrounding the variable with ( :: Text) and seeing what that does
21:54:20 <halogenandtoast> thang1: My guess is there is a function somewhere explicitely returning String
21:54:42 <halogenandtoast> but can't tell without seeing the code of course.
21:55:17 <thang1> That's what I'm thinking. Now, my question is this... We have IsString and some pretty good "universal string" stuff in Libraries... How difficult would it be to just go through the entire prelude and use these universal things that automagick strings into their different representations as needed?
21:56:55 <halogenandtoast> I wish I could answer that question.
21:56:59 <thang1> Also, the amount of libraries out there that only use Text or only use ByteString or (worse) only use String just feels ridiculous. It feels dumb to have to hold the library's hand so often because nobody uses universal strings in the libraries and people often use the wrong string in their user code and it's just a fairly dumb situation all around that feels greatly worsened by a dogmatic and nigh
21:57:01 <thang1> fanatically-religious holding onto backwards compatibility
21:58:14 <thang1> I thought we learned from the mistakes of C++ :p
21:58:52 <c_wraith> you shouldn't conflate bytestring with the other two.  It really is fundamentally different.
21:59:37 <thang1> ninedotnine: using fromJust, let bindings in do, and using String. Impressive.
21:59:54 <c_wraith> 2/3 of those are perfectly fine
22:00:21 <thang1> c_wraith: absolutely. I'm fine with ByteString not being mixed around in there; that one feels much more of a PEBKAC error to me
22:00:22 <c_wraith> And the other 1/3 is ok on occasion
22:01:27 <thang1> I just wish we wouldn't have to pull out a whiteboard, slides, and some thesis papers everytime someone wants to write something even vaguely non-trivial involving strings/text of any kind. Plus, constantly converting willy nilly and forcing stuff through feels like I'm defeating the entire purpose of types
22:02:12 <c_wraith> That's not defeating the purpose of types, that's using types for their intended purpose.
22:04:28 <thang1> But if you don't care what the string is or how it works, shouldn't that be something you don't have to deal with? Explicit conversions only seem useful if they're used to make explicit something that should be made explicit. Strings and text are horrifically complicated for good reason, but "20 years of backwards compatibility and nonsense make it so I have to litter conversion everywhere" seems completely
22:04:30 <thang1> separate from the real reason strings are complicated.
22:05:18 <thang1> Like, if string libraries are complicated because they force you to handle encoding, edge cases, etc., and do things right then that's totally fine. If they're complicated because you have to do arbritrary/meaningless conversions then that's stupid.
22:05:46 <c_wraith> The thing is, all those "meaningless" conversions change semantics.
22:05:54 <c_wraith> That's..  pretty far from meaningless.
22:06:17 <thang1> what semantics are being changed?
22:06:47 <c_wraith> In what conversion?
22:07:19 <thang1> "I need to use this function A from library A and the library writer decided they were only going to use Text so now I can't use it with function B from library B where the writer used String because they didn't want to depend on Text"
22:07:29 <c_wraith> Which Text?
22:07:53 <thang1> Oh, that's what you're getting at. Strict vs Lazy?
22:08:00 <c_wraith> That's one of the things.
22:08:42 <thang1> What are some of the other ones?
22:10:20 <c_wraith> In general, Text handles unicode more correctly than String. It implements all the unicode things that depend on multiple codepoints.
22:10:30 <c_wraith> casefolding, for instance
22:13:48 <c_wraith> String provides a really handy way to play with [] in a friendly setting.  Admittedly, it has the least reason to exist.  I've argued (and still believe) that the entire design of the Show class was poisoned by its existence.  But it's also too tightly tied into everything now to just throw out.  And overall, it's really not bad for small-scale uses in practice.
22:14:46 <c_wraith> This isn't like the AMP, which broke everything for a real gain.  A breaking change to remove String would break a lot more with fewer benefits.
22:15:16 <thang1> Right, and I get that. I still think Haskell would be far better off if people just gave up on String and [Char] and never used that nonsense ever again. That being said, it should be pretty "easy" to default to "just make things work and if I ever care about performance later, I'll figure it out"
22:15:49 <EvanR> thang1: sounds sort of like the belief that there is a number type that "just works" for most use cases
22:16:54 <thang1> There kind of is, though? You don't have nearly the amount of pain working with number types than you do with string types in Haskell
22:17:23 <EvanR> theres like 15 number types to choose from
22:17:32 <EvanR> and 3 or 4 string types
22:18:11 <thang1> and I've seen number types outside of Integer, Int, and Double like three times so far?
22:18:24 <phadej> depends, I don't count ByteString as a string type
22:18:25 <EvanR> the similarity i see is that even if you rename Text to String and have that be the go-to, people still cant really succeed without understanding unicode
22:18:31 <phadej> it's "binary"
22:18:47 <thang1> You can use Num a, Fractional a, etc., to make your functions behave "correctly" for pretty much every number type out there just fine
22:19:10 <EvanR> as long as you understand the types involved yeah
22:19:20 <c_wraith> thang1: why can't you use the right classes to do the same with string types, then?  I mean, the classes exist.
22:19:23 <EvanR> which i gather is the gripe, from reading one page of history
22:19:57 <halogenandtoast> c_wraith: the argument is "I can, but what about those guys over there"
22:20:05 <thang1> And almost all libraries are built that way from the start, so when using a library I can't remebmer any time I had to "pointlessly" convert a number type from one to another in order to get something to work.
22:20:15 <EvanR> how do you design an api to let people succeed without really understand what they are working with
22:20:25 <c_wraith> thang1: then you've never used any low-level native bindings.
22:20:45 <c_wraith> thang1: because I assure you, manual conversions to GLInt are all over the place
22:20:48 <EvanR> thang1: you regularly have to convert number types... 
22:20:53 <thang1> (small exception: If I write code with a type that's needlessly specific for no reason, I occasionally have to use FromInteger)
22:20:54 <c_wraith> or, well, GLFloat
22:21:00 <EvanR> and i dont see it as pointless
22:21:25 <EvanR> and i beware needlessly polymorphic number code
22:21:37 <thang1> I wrote "pointless" in quotes because I don't see it as pointless either, but that from a pure beginner perspective it may appear pointless.
22:21:54 <EvanR> all the more reason to have it so people learn how unpointless it is
22:22:22 <EvanR> i kind of didnt really understand string technology until haskell 
22:22:30 <EvanR> where the string type was not "bytes + encoding tag"
22:22:35 <EvanR> blew my mind
22:22:36 <thang1> Right, but smashing a beginner over the head with String vs [Char] vs Lazy/Strict ByteText and Lazy/Strict Text isn't very conductive.
22:22:39 <Koterpillar> I depend on a non-Haskell file in a quasi quoter: thingy = [hereFile|src/somewhere.txt|]. How do I include somewhere.txt in the Cabal file so that the source is recompiled if somewhere.txt changes?
22:22:56 <halogenandtoast> thang1: String and [Char] are exactly the same thing though.
22:23:04 <EvanR> ByteText
22:23:15 <EvanR> now were cooking with gas
22:23:17 <thang1> They are, but they're not to beginners.
22:23:21 <c_wraith> Koterpillar: the hereFile quasiquoter should add the dependency inside the compiler by itself
22:23:33 <c_wraith> Koterpillar: if it doesn't, file a bug or use a different one.
22:23:34 <Koterpillar> c_wraith: do I have to do anything in the cabal file?
22:23:51 <phadej> IMHO it was quite nice that String = [Char] as a beginner
22:24:00 <thang1> Just like beginners aren't going to know when to use bytetext vs Text vs String or when to use Strict vs Lazy or why one should avoid needlessly polymorphic numeric code
22:24:01 <halogenandtoast> phadej: agreed
22:24:06 <c_wraith> Koterpillar: only if you plan on using cabal sdist
22:24:14 <phadej> though I cared about "let's play with haskell" not about "let's build a high performance webapp"
22:24:15 <halogenandtoast> thang1: I feel like I'm a beginner
22:24:16 <Koterpillar> c_wraith: OK, thanks
22:24:17 <halogenandtoast> I'm fine with it
22:24:41 <halogenandtoast> I couldn't tell you when I should use Strict vs Lazy
22:24:45 <EvanR> are you ranting about the strict vs lazy dichotomy of data structures in general?
22:24:47 <halogenandtoast> I just learned how to convert and deal with it
22:24:49 <thang1> At least with most numbers, you can avoid pretty much all complexity with them until you understand things. The more common something is in haskell, it seems the more broadly it works with "numbers"
22:25:09 <halogenandtoast> ByteString is perhaps a little poorly named
22:25:21 <c_wraith> Koterpillar: yeah, the quasiQuoter should use https://hackage.haskell.org/package/template-haskell-2.11.1.0/docs/Language-Haskell-TH-Syntax.html#v:addDependentFile
22:25:27 <EvanR> well "string" in math, it makes sense
22:25:28 <halogenandtoast> but once I learned that it was a string in the "conventional" sense I dealt with that as well.
22:25:34 <thang1> EvanR: nah, I understand why it's there and really appreciate the fact that haskell supports those things. It just gets in the way of doing things a lot if you don't internalize all that stuff first
22:25:35 <halogenandtoast> *wasn't
22:25:37 <EvanR> string in programming is supposed to mean text, which its not
22:25:39 <c_wraith> Koterpillar: doing that means that the compiler knows about the dependency and can handle it correctly.
22:25:48 <Koterpillar> nice!
22:26:13 <c_wraith> Koterpillar: so..  if it doesn't, file a bug report telling them about that. :)
22:26:34 <EvanR> i want to know what ByteText is
22:26:41 <halogenandtoast> a typo
22:26:49 <EvanR> the question remains
22:26:50 <phadej> EvanR: "In computer programming, a string is traditionally a sequence of characters, "
22:26:51 <EvanR> haha
22:26:55 <thang1> yeah, it's a typo :p
22:26:57 <Koterpillar> c_wraith: I didn't observe any breakage, I was trying to guard against that
22:27:03 <phadej> text is not exactly that
22:27:14 <EvanR> its not?
22:27:16 <EvanR> conceptually
22:27:16 <Koterpillar> *against it being not recognized
22:27:30 <c_wraith> Koterpillar: if you want to use cabal sdist at any point, list the file in the extra-source-files section of the cabal file, so that cabal knows to include it in the source distribution
22:27:40 <thang1> I guess my overall point is that in Haskell, you can remain hugely ignorant of numbers and still get quite a bit done in casual and normal usage.
22:27:51 <EvanR> i have not had that experience
22:28:00 <phadej> thang1: so you can with String?
22:28:16 <thang1> However, with strings, it feels like there's absolutely pretty much zero way to get that same experience with String/[Char]
22:28:18 <EvanR> when 1 + 0.1 is not 1.1, i would flip a table unless i understood what was going on
22:28:35 <EvanR> i felt the opposite [Char] was simple
22:28:57 <thang1> EvanR: 1 + 0.1 is 1.1 in ghci?
22:29:40 <nshepperd> in programming, text used to be a sequence of character, and then the unicode people ruined it all by making us support foreign languages
22:29:43 <EvanR> i can never remember the one like that that gives weird results
22:30:09 <EvanR> > 1.1 + 0.1
22:30:11 <lambdabot>  1.2000000000000002
22:30:28 <c_wraith> nshepperd: didn't those ascii guys ruin it first? making you have to care about how characters were represented?
22:30:39 <verement> > 29.99 + 4.71
22:30:41 <lambdabot>  34.699999999999996
22:30:52 <thang1> [Char] is simple, using it in things tends to be overly complicated to me. The second you want to use a library you're playing bingo lottery with whether or not it'll support [Char] or if you have to do some conversion you don't (yet) understand/care about
22:31:04 <halogenandtoast> > 0.36 + 0.4
22:31:06 <lambdabot>  0.76
22:31:07 <halogenandtoast> err
22:31:07 <jle`> yeah 7 bytes way too much to represent a character
22:31:12 <halogenandtoast> > 0.36 + 0.04
22:31:14 <lambdabot>  0.39999999999999997
22:31:15 <jle`> we only need logBase 2 26 bytes
22:31:20 <jle`> > logBase 2 26
22:31:22 <EvanR> thang1: yeah, so its really about a fungibility thing, how popular it is, not that it exists
22:31:22 <lambdabot>  4.700439718141093
22:31:33 <jle`> 5 bytes or bust
22:31:54 <nshepperd> yeah maybe. i've never written an \STX in an essay
22:31:59 <Koterpillar> c_wraith: Unknown fields: extra-source-files
22:32:05 <EvanR> jle`: 7 bits?
22:32:10 <jle`> um
22:32:15 <jle`> yes s/bytes/bits everything
22:32:21 <thang1> lol
22:32:25 <c_wraith> Koterpillar: are you putting it in the right section? https://www.haskell.org/cabal/users-guide/developing-packages.html
22:32:30 <halogenandtoast> I'd take 7 bytes
22:33:12 <c_wraith> Koterpillar: it's part of the package description, not the library or executable sections
22:33:12 <EvanR> utf-9
22:33:21 <Koterpillar> c_wraith: well, those files do belong to a library…
22:33:28 <Koterpillar> but yes, I should have consulted the docs
22:34:31 <halogenandtoast> Anyways, I'm perfectly fine with a variable length encoding, as long as I never have to implement it myself.
22:35:06 <EvanR> lazily nontheless
22:35:28 <halogenandtoast> how should I know?
22:35:30 <halogenandtoast> :p
22:36:21 <nshepperd> the problem isn't just encodings, it's that to even know what a 'character' is you need to know about combining code points, and rtl indicators and all that other fun stuff and how it interacts
22:37:21 <EvanR> well, javascript strings work and almost nobody using js understands unicode
22:37:45 <EvanR> but youre right its complicated if youre making a program to specifically use unicode features
22:37:52 <EvanR> or lib
22:38:00 <thang1> On the other hand, Swift's String API is famously very difficult for beginners because it forces you to understand what you're doing
22:38:35 <thang1> But, it's not difficult because you have to do a bunch of seemingly arbritrary conversions
22:38:36 <nshepperd> the normal solution is to avoid doing anything with characters and mostly just pass strings through unchanged from a to b
22:38:49 <EvanR> the percieved difficulty of an API for a beginner, interesting
22:39:34 <thang1> EvanR: I do find that sort of thing interesting, actually. It's one of the things that I really find fascinating as someone who likes to design/think-about learning materials and the most optimal designs/defaults for things
22:39:40 <EvanR> if its easy for a beginner to succeed with it, i want that api too please
22:39:48 <EvanR> but thats a big if
22:40:39 <EvanR> if you can easily create a acceptable trainwreck...
22:40:58 <EvanR> probably doing the world a disservice
22:43:59 <thang1> It's pretty difficult to design something that is very convenient, consistent with intuitions, yet also allows/enforces a high level of correctness.
22:44:11 <EvanR> can i get some clarification on atomically inside of unsafePerformIO. the docs say "its impossible. and any attempt to do so will cause a runtime error"
22:44:26 <mjora7> Hi, so is there a better way to accomplish this? https://gist.github.com/aryaforghani/63492a9ac248aa24a576f8a136278a6b#file-main-hs
22:44:33 <thang1> I think excellent error messages, sane choice of defaults, consistent library design, are all incredibly important
22:44:36 <nshepperd> the difference between being easy for beginners, and being easy for beginners to do the right thing
22:44:38 <EvanR> yet this is not happening for me, it does something (seems to be right), and no error is throw
22:45:17 <mjora7> Seems pretty complicated to just convert and integer to lazy text that can be given to the html function
22:46:00 <EvanR> (html . L.fromStrict . T.pack . show . getAge) birthYear ;)
22:46:06 <thang1> nshepperd: right. And I think the situation now where beginners end up getting frustrated and blindingly throw conversions at the wall until it works is unhelpful and even harmful. It doesn't encourage doing the right thing, it encourages the notion that you do "weird crap to strings to make the program compile" rather than understand the underlying reasons for why things are how they are.
22:46:23 <EvanR> (html . L.fromStrict . T.pack . show . getAge) <$> param "birthYear"
22:46:25 <thang1> It also doesn't help that libraries themselves don't always consistently use the "right string-type" for things
22:47:48 <nshepperd> i'm never sure what is the right canonical function for doing UTF-8 encoding/decoding between Text and ByteString
22:47:51 <EvanR> javascript has one string type and one number type, which of these is the one thats problematic
22:48:04 <thang1> I like this article/essay on Swift's string API: https://www.mikeash.com/pyblog/friday-qa-2015-11-06-why-is-swifts-string-api-so-hard.html
22:48:11 <EvanR> you get NaN guesses
22:48:59 <EvanR> this is the first im hearing about Swift having a "hard" string type
22:49:16 <EvanR> i want the blog post explaining why its considered hard
22:49:38 <mjora7> EvanR: Ok haha. So it's just inherently ugly. Am I doing those imports property? Any way to accomplish it with a single import?
22:49:46 <mjora7> EvanR: The Data.Text ones in particular.
22:49:55 <thang1> EvanR: it explains the API is "hard" in the first paragraph
22:50:35 <EvanR> mjora7: for common sequences of conversions like above, you can factor out pieces of the . chain... like L.fromStrict . T.pack . show
22:50:38 <EvanR> and reuse it
22:50:43 <thang1> The tl;dr is that Swift's string API doesn't assume much. If you work with string in C++ it's just "hurr durr I'm an array of bytes; hopefully you can figure it out from there"
22:51:00 <EvanR> thang1: it says "its hard" but i dont get why
22:51:27 <thang1> But swift's api enforces dealing with unicode correctly
22:52:27 <thang1> and you can't just pretend unicode is an array of bytes and just slice around arbritrary array positions and manipulate them willy nilly. The practice of array[index] being magically sized for you depending on your data type breaks horrifically with unicode due to differing widths and swift's string type enforces that knowledge
22:53:45 <EvanR> reading the last section which explains swift, it seems horrible
22:53:50 <EvanR> as far as strings go
22:53:53 <nshepperd> EvanR: maybe the atomically thing was changed in recent ghc?
22:54:09 <thang1> The flag unicode symbol, to quote from the article, is represented as two code points in unicode: You pick from 26 regional indicator symbols and smash them together to get your symbol. Two code points, four UTF-16 code units, eight UTF-8 bytes for one symbol
22:54:18 <EvanR> its exposing literally all details
22:54:44 <thang1> If you just convert that into an array of whatever, it's going to break any code that tries to manipulate that array "dumbly" on a generic string of unicode
22:54:48 <nshepperd> instead of throw an error on unsafePerformIO it's telling me "Control.Concurrent.STM.atomically was nested" when I try using atomically inside unsafePerformIO inside atomically
22:54:49 <EvanR> the default is to treat text as a sequence of grapheme clusters o_O
22:55:17 <EvanR> nshepperd: right i get that too, nesting STM is invalid. but simply having atomically inside an unsafePerformIO
22:55:28 <EvanR> is what i thought the doc is talking about
22:55:33 <thang1> Eh, honestly, I feel that's the right choice. Unicode /is/ a sequence of grapheme clusters
22:55:39 <EvanR> o_O
22:55:52 <cocreature> angerman: I’m now considering calling g++ in Setup.hs to compile an executable and run it. Good luck, cross compiling that :P
22:55:54 <EvanR> unicode data is a sequence of code points
22:56:32 <angerman> cocreature: I think we agreed that llvm-hs is not really a cross compilation target :)
22:56:43 <angerman> cocreature: however sad that might be.
22:56:50 <thang1> Right, but that's an implementation detail. It's like saying "arrays of characters are ones and zeros", well sure... but that's not really the point of characters now is it
22:57:09 <mjora7> EvanR: In that code I pasted... How can I stuff a console log in one of those routes? I'm not exactly sure where to put it. I don't get how "blocks" work in Haskell in that context.
22:57:10 <angerman> cocreature: in principle though, if we compile the Setup.hs on the build system, and use that for the setup, it might work.
22:57:40 <EvanR> thang1: ... you look at the unicode specs... it will give you picture after picture of arrays of "unicode characters"
22:57:40 <angerman> cocreature: if however the Setup, would need to pass --target or --host flags down to subprocess it calls, this would compilicate things tremendously.
22:57:59 <thang1> Unicode is made up out of grapheme clusters. These grapheme clusters are created by code points but you wouldn't ever manipulate code points or do things with code points or think about code points just like you talk about Char::'a' not a string of 1s and 0s
22:58:00 <cocreature> I think that won’t be necessary here
22:58:06 <EvanR> you can transform them in different ways
22:58:24 <angerman> cocreature: maybe you can get away with autotools and configure? In that case you'd get the --target/--host/--build magic (prefixed tools) for free. You *would* have to deal with autotools though :D
22:58:32 <EvanR> and can also do normalizations, but thats not the one true object
22:58:41 <cocreature> angerman: I’m willing to go quite far to avoid autotools :)
22:58:53 <cocreature> angerman: Setup.hs might be horrible but at least I can write haskell code
22:58:54 <angerman> cocreature: if only there was an alternative.
22:59:06 <EvanR> thang1: thats just wrong
22:59:35 <nshepperd> what about things that aren't grapheme clusters?
22:59:41 <EvanR> contrary, you would only be dealing with grapheme clusters if you were making a unicode text processing application
22:59:47 <nshepperd> like WORD JOINER or an RTL indicator?
23:01:25 <cocreature> angerman: I’ve seen a surprising number of opensource projects migrate from autotools to meson recently but I haven’t checked whether that’s actually an improvement
23:02:36 <thang1> my bad, I thought grapheme clusters were defined differently
23:04:10 <angerman> cocreature: so cmake with python
23:04:55 <thang1> ughh, unicode y u do dis ಠ_ಠ
23:09:30 <nshepperd> EvanR: seems like a bug. either in the docs or in ghc
23:09:42 <nshepperd> the behaviour is the same in 7.10, at least
23:13:14 <thang1> https://stackoverflow.com/questions/43618487/why-are-emoji-characters-like-treated-so-strangely-in-swift-strings How tf are you even supposed to handle this sorta thing
23:16:04 <nshepperd> thang1: good lord
23:17:55 <nshepperd> do the unicode people really have nothing better to do then add frivolous emoji stuff to the standard to make life difficult
23:17:57 <thang1> Right? What a messed up piece of garbage. Now, to be fair, this is a Unicode 9.0 emoji being handled in a string library that doesn't support unicode 9.0, so it's doing what it can
23:18:52 <thang1> nshepperd: to be fair, being able to combine multiple things together in an extended format is essential for a lot of complex languages such as chinese. The fact that unicode is also being used for emoji is beside the point
23:20:52 <EvanR> nshepperd: well at least theres a second opinion on the incongruity, yes im still on 7.10
23:21:01 <wedens> is there some minimal library I can use for string interpolation with Text?
23:21:15 <thang1> EvanR: why are you on 7.10 still? If you don't mind me asking
23:21:40 <EvanR> im scared of reinstalling my whole OS to upgrade
23:21:59 <EvanR> its been so long i dont really understand how ghc is installed on osx
23:22:00 <thang1> \> 2017
23:22:03 <thang1> \> not using stack
23:22:16 <thang1> do you even haskell, bro? /s
23:22:18 <EvanR>  \> ?
23:22:35 <thang1> escaping meme text so lambdabot won't try to run it
23:22:41 <EvanR> no ive never used stack, but ive seen plenty of people have trouble with it
23:23:42 <thang1> Really? I had a tiny bit of trouble with it at first but it was way easier than cabal for me and I never had such a seamless experience with cabal as I did with stack. Although the last time I seriously used cabal was back when "cabal hell" was a common oath you swore at your teddy bear with
23:25:23 <quchen> You’d rather upgrade your OS than to try X?
23:25:31 <quchen> You’re very brave.
23:25:40 <EvanR> would rather not
23:27:22 <thang1> EvanR: still, you can use stack without messing up your system ghc installation. Maybe give it a shot and see how you like it?
23:27:35 <EvanR> hmm.
23:27:45 <EvanR> maybe some day
23:27:52 <EvanR> right now my ghc is working fine
23:28:35 <thang1> It'll take about 5 minutes, just so you know :p
23:28:41 <EvanR> i doubt it
23:29:29 <thang1> Well it depends on your download speed but it literally does take me <5 minutes to nuke stack, wipe everything, reinstall stack, and redownload ghc + 7-10 packages for text editor and compile/build everything
23:29:46 <EvanR> o_O
23:29:55 <lambdaXtom> Not using stack's like not using a VCS...  Not the best of choices you ever made 
23:29:59 <thang1> (by everything I mean the packages like "hlint", etc., not my entire codebase)
23:30:22 <EvanR> compiling and building the dependency universe will not take 5 minutes on this macbook air
23:30:41 <EvanR> and when i have no reason to do it
23:31:03 <thang1> You download a ghc binary, you don't have to build ghc. Unless you were referring to a different dependency universe?
23:31:04 <EvanR> im past the point of getting enjoyment out of reconfiguring my computer
23:31:17 <EvanR> all the libraries i need
23:31:23 <EvanR> or that are needed by those libraries
23:31:38 <nshepperd> what about all the cool ghc 8.0 features
23:31:48 <EvanR> i dont need them yet
23:32:42 <EvanR> Often they simply give up on important questions like "what exactly is a character?" <-- in and out of unicode context... i still dont really know what a character is
23:32:49 <EvanR> in that blog post
23:33:24 <EvanR> theres probably a categorical explanation that avoids answer that
23:33:30 <EvanR> answering
23:33:49 <nshepperd> if you want to know what a character really is, you must first learn every language in the world
23:34:19 <EvanR> well i read through the unicode sections on all the scripts
23:34:42 <EvanR> still no mathematical definition of a character
23:34:51 <thang1> https://github.com/Kopachris/pybrainfuck -- amazing
23:35:53 <EvanR> also why is voynich manuscript not in unicode
23:36:01 <thang1> brainfuck interpreted by python interpreted by c. Even extensible :p
23:36:25 <thang1> EvanR: probably because the unicode committee is corrupt and bought out by Big Emoji
23:37:24 <EvanR> python brainfuck are totally off topic, C is mostly off topic
23:37:47 <EvanR> mainly i hate brainfuck
23:38:28 <quchen> Hate untyped lambda calculus! It’s much closer to Haskell.
23:40:11 <EvanR> ok i will
23:40:50 <EvanR> esolangs never seem to have a type system... i think we need to change that
23:41:35 <thang1> Introducing: Typed Brainfuck calculus
23:42:23 <quchen> EvanR: Quite the contrary! Writing everything in Haskell’s type system is an esolang, and it has types.
23:42:41 <thang1> This is an interesting article about unicode: https://unspecified.wordpress.com/2012/04/19/the-importance-of-language-level-abstract-unicode-strings/
23:44:59 <EvanR> right... i just looked at apple docs "NSString is conceptually a sequence of UTF-16 units"
23:45:08 <Maxdamantus> > In a language that properly abstracts over Unicode strings, the above string should have a length of 9. Programmers should only be exposed to encoding details when they explicitly ask for it.
23:45:10 <lambdabot>  <hint>:1:59: error: parse error on input ‘,’
23:45:18 <Maxdamantus> err .. that seems contradictory to me.
23:45:32 <EvanR> "but the underlying storage shouldnt be a concern"... so it has an implementation detail as its abstract model
23:45:57 <Maxdamantus> Programmers should only be exposed to encoding details when they ask for it .. that's why the language interpreted the string and gave the arbitrary answer "9"
23:46:18 <thang1> How is 9 an arbritrary answer?
23:46:27 <EvanR> > length "Hello, 世界"
23:46:29 <lambdabot>  9
23:46:31 <thang1> there are 9 symbols in the string
23:46:31 <EvanR> k
23:46:36 <Maxdamantus> Is it based on codepoints, or characters?
23:46:38 <EvanR> there are 9 characters
23:46:43 <EvanR> not symbols
23:46:48 <Maxdamantus> > length "á"
23:46:50 <lambdabot>  2
23:46:51 <halogenandtoast> Is there a way to make stack generate a Dockerfile?
23:47:02 <thang1> > length 'a'
23:47:04 <lambdabot>  error:
23:47:04 <lambdabot>      • Couldn't match expected type ‘[a0]’ with actual type ‘Char’
23:47:04 <lambdabot>      • In the first argument of ‘length’, namely ‘'a'’
23:47:11 <EvanR> > length "á"
23:47:13 <lambdabot>  1
23:47:15 <EvanR> heh
23:47:30 <thang1> > length "a"
23:47:32 <lambdabot>  1
23:47:39 <Maxdamantus> Unfortunately Haskell does it incorrectly too, where it applies an unjustified importance to codepoints.
23:47:46 <thang1> Maxdamantus: how'd you get 2 for yours?
23:47:46 <EvanR> its characters
23:47:54 <EvanR> youre talking about grapheme clusters
23:47:58 <thang1> Oh you have a invisible space?
23:47:59 <Maxdamantus> The point of Go's strings is that it more-or-less avoids giving pointless things importance.
23:48:20 <thang1> > length "𐒁̸"
23:48:22 <EvanR> the central thing unicode gives you is characters
23:48:22 <lambdabot>  2
23:48:34 <Maxdamantus> Java/JavaScript/Qt make an even more arbitrary thing seem important: UTF-16 code units
23:48:40 <halogenandtoast> Are we still talking about Strings?
23:48:45 <Maxdamantus> thang1: there's no invisible space.
23:49:00 <thang1> Haskell does it acceptably. 𐒁̸ is made up of "Osmanya letter" + "combining long solidus overlay"
23:49:02 <EvanR> thang1: its two characters, non precomposed a with a combining mark
23:49:03 <Maxdamantus> thang1: the string I wrote consists of the codepoints U+61 and U+301
23:49:57 <thang1> ah, got it. I meant combining mark, I just expressed myself inaccurately by saying invisible space
23:50:09 <EvanR> giving grapheme clusters importance would be mixing application level stuff in and make it a pain in the ass to work with the data
23:50:49 <Maxdamantus> Generally, you shouldn't have to be concerned about code points or code units or grapheme clusters or any of that, unless you're writing or interacting with some sort of font renderer or text layout engine.
23:50:55 <EvanR> it would be like putting colors in the string
23:51:34 <EvanR> Maxdamantus: twitter would disagree
23:51:39 <EvanR> 140 characters
23:51:45 <thang1> Also apparently unicode allows arbritrary length combining character sequences...
23:52:05 <Maxdamantus> Yeah, and I don't know how it counts the characters.
23:52:14 <thang1> So counting by CCS would allow for tons of exploits where counting by code points is "sane" (twitter counts by code point; same as Haskell)
23:52:35 <Maxdamantus> I wouldn't argue what I said absolutely.
23:52:40 <Maxdamantus> That's why I said "generally".
23:52:46 <EvanR> thang1: correct https://twitter.com/crashtxt
23:52:50 <thang1> code point is the "character" 𐒁̸ is two code points because it's a character + cross-mark character overlay
23:53:09 <EvanR> Maxdamantus: the same as most languages with unicode support, by characters
23:53:18 <EvanR> swift is this odd ball exception apparently
23:53:32 <hanna> How can I avoid having to duplicate my `build-depends` in between my executable and my test suite?
23:54:11 <thang1> I was a fan of 𐒁̸ being length 1 but I think I' coming around to the idea of it being length 2. The arguments are fairly compelling in this regard; mainly that arbritrary length CCS is allowed by unicode and that people intuitively usually type the character + / to get 𐒁̸ anyway so they're used to thinking of it as two "characters"
23:54:17 <Maxdamantus> EvanR: so is that a non-combining code point followed by a sequence of combining code points?
23:54:39 <thang1> 汉 however this should be 1 character, which it is with counting by code points
23:54:49 <EvanR> Maxdamantus: it really is the fundamental count in unicode, were not better off vaguifying the text data to have no decernable features, removing meaning from words we already have and leaving it on the floor a steaming pile
23:55:07 <EvanR> Maxdamantus: that?
23:55:09 <Maxdamantus> If so, that means you can write arbitrarily large characters/Twitter messages
23:55:44 <thang1> Maxdamantus: twitter will rack up character count if you write arbritrairly large CCS sequences
23:55:47 <EvanR> hundred forty characters, as in the most basic array of utf32 units
23:55:54 <Maxdamantus> > length "á́́́́́́́́́́́"
23:55:56 <lambdabot>  13
23:55:56 <EvanR> you cant go over
23:55:57 <thang1> because you're using multiple code points in that CCS sequence
23:56:09 <Maxdamantus> > length "á́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́́"
23:56:11 <lambdabot>  63
23:56:30 <nshepperd> you can't write arbitrarily long twitter messages precisely because it counts "characters" instead of grapheme clusters
23:56:40 <halogenandtoast> what have you done?
23:57:06 <Maxdamantus> So characters as in code points?
23:57:21 <EvanR> when i hear code point i think of a number
23:57:24 <Maxdamantus> "character" has lots of contradictory meanings in this context, need something concrete.
23:57:27 <EvanR> U+1234
23:57:37 <Maxdamantus> Well, "code point" is a technical term used in the context of unicode.
23:57:43 <halogenandtoast> http://i.imgur.com/Una0ZoH.png
23:57:48 <EvanR> yeah its a number
23:57:49 <nshepperd> well, I haven't read the unicode spec but it sounds like it defines "character" as something like a code point, yes
23:57:58 <thang1> Code point is the technical term that most closely represents what people intuitively think of as a "character"
23:58:13 <Maxdamantus> thang1: but it really doesn't, as I've already demonstrated.
23:58:18 <hanna> I wonder to what degree information you can squeeze into a tweet depends on the language; since it seems like languages with higher (non-ASCII) codepoints are at a disadvantage
23:58:21 <hanna> CJK most notably
23:58:22 <Maxdamantus> thang1: noone would call "á" two "characters"
23:58:28 <EvanR> theres a code point for each unicode character
23:58:36 <thang1> 汉 == 1 character. 𐒁̸ = 2 character (𐒁 + ◌̸)
23:58:43 <hanna> But CJK also conveys more information per coded character
23:58:54 <EvanR> Maxdamantus: its two characters, a and a combining character
23:59:03 <nshepperd> but anyway, if you want to count grapheme clusters, you can do that
23:59:09 <EvanR> people do call it a grapheme cluster 
23:59:09 <nshepperd> type GraphemeCluster = Text
23:59:14 <Maxdamantus> EvanR: this is a completely nonsensical meaning of "character"
23:59:23 <nshepperd> segment :: Text -> [GraphemeCluster] -- now everyone is happy
23:59:30 <Maxdamantus> EvanR: you should be saying "code point", because the fact that there are two things there is a representational matter.
23:59:33 <EvanR> Maxdamantus: unicode's use of the word character is nonsensical
23:59:57 <EvanR> right
