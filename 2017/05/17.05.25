00:01:04 <johnw> that's a very good point
00:01:31 <sternmull> nshepperd_: Maybe you are right. elems = [Foo 123, Foo "hello"] does not compile with "newtype Foo = Foo (forall a. Show a => a)".
00:02:37 <nshepperd_> (in fact there are no values of (forall a. Show a => a) apart from bottom, because Show a provides no way to build an a)
00:04:26 <sternmull> So it seems i really have to use data.
00:06:08 <nshepperd_> 'data Foo = forall a. Show a => Foo a' is basically the same as 'data Foo = forall a. Foo (Show a) a' after the dictionary transformation
00:07:58 <nshepperd_> The constructor has two arguments, one of which is a Show dictionary. So it doesn't work with newtype for the same reason that newtype constructors can't have two arguments normally
00:09:47 <nshepperd_> Well, and I guess there's also the fact that pattern matching has to be able to fail, in order to justify bringing a Show constraint in scope. But pattern matching on newtypes never fails 
00:11:05 <sternmull> I don't understand 'data Foo = forall a. Foo (Show a) a'. It seems like the (Show a) in there somehow adds a constraints to the forall thing. But it reads strange to me.
00:13:12 <EvanR> its odd syntax
00:13:22 <EvanR> if you use GADT syntax it is more clear
00:13:47 <EvanR> data Foo where
00:14:06 <EvanR>   Foo :: Show a => Foo a
00:14:14 <EvanR> er
00:14:50 <EvanR> nshepperd_ your second version has two args on Foo
00:15:29 <EvanR> oh thats the ctor
00:15:33 <EvanR> data Foo where
00:15:44 <EvanR>   MkFoo :: Show a => Foo
00:21:13 <nshepperd> data Foo where { Foo :: Show a => a -> Foo }
00:21:30 <nshepperd> ^ two arguments, (Show a) and a
00:21:42 <Lokathor> I have a (Maybe a), and an (a -> IO ()), is there some slick way to just make it run the IO bit if the maybe is a just, and otherwise have it do nothing
00:22:02 <Lokathor> i'm sure there's a magical one word combinator, or perhaps 7 punctuation marks placed just so
00:22:07 <johnw> traverse
00:22:10 <cocreature> Lokathor: traverse_
00:22:16 <cocreature> or mapM_
00:22:26 <Lokathor> ah, see, there we are then
00:22:42 <EvanR> i see the example for how unsafePerformIO can basically execute unsafeCoerce
00:22:44 <cocreature> it took me way too long to figure out that you can use traverse_ for that
00:22:56 <EvanR> but i do not understand how the type system is not stopping it
00:23:10 <EvanR> or how it normally gets stopped by the type system
00:23:21 <EvanR> something about "polymorphic values"
00:23:35 <Lokathor> cocreature, I'm already importing Control.Monad for other reasons, so mapM_ it is
00:24:15 <Lokathor> i was trying fmap at first, silly me
00:24:25 <cocreature> Lokathor: but traverse_ is more general! :)
00:24:46 <Lokathor> but the types are fully known already!
00:24:58 <cocreature> Lokathor: but the Applicative instance could be more performant!
00:25:04 <EvanR> whatever reads better
00:25:10 <Lokathor> of IO?
00:25:16 <Lokathor> for FFI wrapping code?
00:25:18 <Lokathor> hmmmmm
00:25:21 <cocreature> :)
00:25:31 <Lokathor> seems suspect
00:25:51 <nshepperd> EvanR: because unsafePerformIO (newIORef undefined) :: forall a. IORef a
00:26:14 <nshepperd> which means it can be used as an IORef String once, and then as an IORef Int later
00:26:20 <EvanR> x <- newIORef undefined...
00:26:33 <EvanR> is different?
00:26:39 <nshepperd> yes
00:26:50 <EvanR> how
00:27:31 <nshepperd> newIORef undefined >>= (\ref -> ...)
00:27:52 <nshepperd> the type of 'ref' is not 'forall a. IORef a'
00:27:58 <EvanR> i suppose it cant be
00:27:58 <Lokathor> newtyping a StateT
00:28:04 <Lokathor> ugggghhhhh i hate it so much
00:28:04 <EvanR> but what is it?
00:28:25 <nshepperd> because that would require the lambda to be rank-2
00:28:58 <nshepperd> uh, I would call it 'undetermined'
00:29:13 <nshepperd> i'm sure there's an actual technical term but i don't know it
00:29:22 <EvanR> is forall a. IORef a a impredicative type?
00:29:48 <nshepperd> its type is 'IORef a', for some free variable a to be determined by unification
00:30:25 <EvanR> ok and you could use it one way, not use it, but not use it two different ways
00:30:28 <EvanR> now i get it
00:30:38 <nshepperd> yeah
00:31:53 <EvanR> what is the type of ref, "depends on what ... is"
00:32:31 <hanna> Hmm. Is there a `group` or `chunk` pipe that groups values into lists of size N? i.e. group :: Int -> Pipe a [a] m r;  `group 3` would turn a stream like [1..10] into [ [1,2,3], [4,5,6], [7,8,9], [10] ]
00:32:52 <EvanR> that seems like a funny effect of unsafePerformIO
00:33:09 <EvanR> :t chunksOf
00:33:10 <lambdabot> Int -> [e] -> [[e]]
00:33:17 <hanna> The motivation: I have a `producer` that produces a list of entries, and a `consumer` that takes these entries and stores them in a database. For a variety of reasons I want to store them in the database in batches, rather than entry-by-entry
00:33:20 <EvanR> > chunksOf 3 [1..10]
00:33:22 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
00:33:31 <tsahyt> are there any naming conventions for lenses to newtype wrappers? say I have newtype Foo = Foo { getFoo :: Bar }, what should the lens to getFoo be called?
00:33:41 <osa1> I have a large servant API and I want to provide client functions for a subset of the endpoints, is this possible? servant-client's `client` functions doesn't allow this
00:33:42 <tsahyt> or is there some more elegant way in lens to deal with newtypes?
00:33:56 <hanna> tsahyt: lens has a class for newtypes
00:34:04 <osa1> ah! I think I found a way. never mind please ignore
00:34:22 <EvanR> oh pipe question
00:34:32 <EvanR> pipes 
00:34:52 <hanna> I guess I could write my own, just puzzled that this is not already defined somewhere; it seems useful for a number of things
00:35:22 <EvanR> might be in a pipes add on lib
00:36:00 <tsahyt> hanna: found it, thanks!
00:37:06 <hanna> I think I can do what I want but not with that type signature
00:37:08 * hackage sibe 0.2.0.5 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.2.0.5 (mdibaiee)
00:37:12 <hanna> The problem is that there's no “non-blocking await”
00:37:20 <hanna> but I could probably write something that transforms a producer instead
00:37:33 <EvanR> why does it need to be non blocking
00:38:05 <hanna> well if I do it the naive way I would fail to include the last [10]
00:38:31 <hanna> because the producer would terminate while my `group` is still stuck in `await`, right?
00:38:54 <EvanR> on 9 or on 10 ?
00:39:03 <EvanR> not sure i understand
00:39:17 <hanna> well this is how I would write it naively
00:39:29 <hanna> forever $ replicateM 3 await >>= yield
00:39:50 <EvanR> makes sense
00:39:58 <EvanR> except for the last 3
00:40:14 <EvanR> can you detect if the input is over with
00:40:14 <hanna> Yes, how do I handle with premature termination?
00:40:23 <hanna> I think I could sequence the producer with another producer
00:40:42 <halogenandtoast> Anyone have experience with Keter, I can't seem to get a "server" running.
00:40:50 <hanna> but then it seems like I need to account for this failure possibility in the body somehow, so I can pass on the values to that “termination” pipe...
00:40:53 <halogenandtoast> I have no idea how to debug this
00:41:06 <EvanR> this is too complicated
00:41:54 <mark___> I'm new to this, and I have some really simple code here that has the error "parse error on input <module name>".  Can someone help? https://pastebin.com/mnwBRpse
00:42:18 <sullyj3> Are there any base functions that would make this nicer? it's for generating pascals triangle, you subsequently map sum over the result.
00:42:29 <lpaste> sullyj3 pasted “windows” at http://lpaste.net/355830
00:42:38 <halogenandtoast> the only log output I see is: 2017-05-25 07:36:52.47: Unpacking bundle '/opt/keter/etc/../incoming/NhkReader.keter'
00:50:06 <Lokathor> @pl (\s -> s {window = window})
00:50:07 <lambdabot> (line 1, column 10):
00:50:07 <lambdabot> unexpected "{"
00:50:07 <lambdabot> expecting variable, "(", operator or ")"
00:50:13 <Lokathor> drat, i figured as much
01:07:57 <sabin> Is there a specific haskell beginner channel?
01:08:44 <Rembane> sabin: I can't find it right now, you can ask your questions here.
01:09:02 <cocreature> sabin: beginner questions are completely fine here! (there is #haskell-beginners iirc if you really want a separate channel)
01:10:18 <halogenandtoast> I got keter running, apparantly the setup script doesn't work
01:10:28 <halogenandtoast> because why would that be useful?
01:26:20 <hexagoxel> sullyj3: you can use zip/zipWith. And summing last is probably a rather inefficient route.
01:32:42 <mniip> sullyj3, I would use 1: and ++[1] and the zip`ap`tail trick
01:35:03 <sullyj3> :t ap
01:35:04 <lambdabot> Monad m => m (a -> b) -> m a -> m b
01:35:44 <sullyj3> :t ap zip tail
01:35:46 <lambdabot> [a] -> [(a, a)]
01:36:11 <sullyj3> > ap zip tail [1..10]
01:36:13 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
01:36:26 <sullyj3> oh, ok.
01:37:19 <sullyj3> mniip: but then the list becomes heterogeneous though? since the first and last elements aren't pairs?
01:44:10 <sullyj3> also, anyone have a good resource for explaining that zip `ap` tail trick? my understanding of applicatives is basic
01:44:21 <mniip> sullyj3, you zipWith (+) it, duh
01:44:43 <mniip> for functions,
01:44:47 <mniip> ap f g x = f x (g x)
01:59:07 <sullyj3> mniip: cool, ta
02:07:49 <sullyj3> How's this look? nextRow' row = 1:(zipWith (+) <*> tail $ row) ++ [1]
02:09:54 <tsahyt> I want to use lens to modify something in a structure, but for the operation I need a different part of the structure. e.g. I'd use over (foo . bar . each . quux) but for the function I'll need a view of (foo . bar . each . xuuq) for the corresponding element in each
02:10:10 <tsahyt> not sure if this question makes sense. it's a bit hard for me to even phrase lens questions because I lack experience with it
02:10:22 <tsahyt> anyhow, how would I go about this?
02:17:36 <brynedwards> :r
02:17:42 <brynedwards> :r
02:27:06 <hexagoxel> tsahyt: over (foo . bar . each) _  and continue from there? not sure if you can fill that hole elegantly, but it should work.
02:27:14 <hanna> tsahyt: one way you could do is over (foo.bar.each) $ \x -> do something using x^.xuuq
02:27:20 <hanna> but it's been a long while since I've lensed
02:27:53 <tsahyt> hexagoxel, hanna: that's about what I ended up doing
02:27:56 <hanna> you could probably find a combinator that “merges” quux and xuuq into a view on a tuple or something
02:28:03 <sullyj3> is there a way to view specialized type signatures of polymorphic functions? eg given (<$>) :: Functor f => (a -> b) -> f a -> f b could I specify f = [] and get (<$>) :: (a -> b) -> [a] -> [b] ?
02:28:05 <hanna> and then mape \(a,b) -> (a, modify b using a)
02:28:07 <hanna> map*
02:28:17 <tsahyt> hmm right
02:28:22 <hanna> but who knows
02:28:30 <tsahyt> "who knows" is pretty much my entire stance on lens
02:28:37 <hanna> if you have to think about this problem too much then you're not gaining simplicity by using lens
02:28:39 <hanna> so stick to what works
02:28:43 <tsahyt> but in this case here it really makes sense to use it
02:28:57 <tsahyt> I'm working with a somewhat deeply nested AST here, transforming it in multiple steps
02:29:01 <hanna> lens is a tool to make your code simpler, not more complicated :)
02:29:10 <tsahyt> tearing that apart manually and rebuilding it on every step is a massive pain
02:29:19 <tsahyt> so I finally gave in to lenses
02:30:30 <hexagoxel> :t \x -> (<$>) x `asAppliedTo` []
02:30:32 <lambdabot> (a -> b) -> [a] -> [b]
02:30:44 <tsahyt> :t asAppliedTo
02:30:46 <lambdabot> (a -> b) -> a -> a -> b
02:30:51 <tsahyt> hmm that's useful
02:31:18 <hexagoxel> sullyj3: it is still rather cumbersome for this example.. dunno.
02:32:39 <balor> The `-ddump-deriv` flag doesn't appear to dump the implementation of derived Typeable instances. Is this observation correct?  I can dump derived instances of Functor and Show.
02:34:03 <sullyj3> :t hexagoxel I'm not seeing asAppliedTo on hoogle?
02:34:04 <lambdabot> error:
02:34:04 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:34:10 <sullyj3> oops
02:34:42 <hexagoxel> @src asAppliedTo
02:34:42 <lambdabot> f `asAppliedTo` a = f where _ = f a
02:34:42 <lambdabot> infixl 0 `asAppliedTo`
02:36:02 <sullyj3> < (<>) `asAppliedTo` []
02:36:10 <sullyj3> > (<>) `asAppliedTo` []
02:36:12 <lambdabot>  error:
02:36:12 <lambdabot>      • No instance for (Typeable t0)
02:36:12 <lambdabot>          arising from a use of ‘show_M438695397355665942115330’
02:36:24 <sullyj3> :t (<>) `asAppliedTo` []
02:36:26 <lambdabot> [t] -> [t] -> [t]
02:36:49 <sullyj3> (<>) `asAppliedTo` [] $ [1..5] [6..10]
02:36:58 <sullyj3> > (<>) `asAppliedTo` [] $ [1..5] [6..10]
02:37:01 <lambdabot>  error:
02:37:01 <lambdabot>      Precedence parsing error
02:37:01 <lambdabot>          cannot mix ‘asAppliedTo’ [infixl 0] and ‘$’ [infixr 0] in the same i...
02:37:17 <harendra> Can someone help me on a question about MonadTransControl?
02:37:20 <sullyj3> > ((<>) `asAppliedTo` []) [1..5] [6..10]
02:37:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
02:38:27 <hexagoxel> sullyj3: The TypeApplications extension would be nicer, but lambdabot does not support it yet.
02:38:49 <hexagoxel> it is ghc-8 iirc
02:40:44 <hexagoxel> harendra: best chance of finding that out generally is asking the question :)
02:41:10 <hexagoxel> @let f `asAppliedTo2` a = f where _ = \b -> f b a
02:41:11 <lambdabot>  .L.hs:173:1: warning: [-Woverlapping-patterns]
02:41:11 <lambdabot>      Pattern match is redundant
02:41:11 <lambdabot>      In an equation for ‘asAppliedTo2’: asAppliedTo2 f a = ...
02:41:28 <hexagoxel> :t (<$>) `asAppliedTo2` []
02:41:29 <lambdabot> (a -> b) -> [a] -> [b]
02:43:06 <harendra> hexagoxel: alright. here is the question.
02:45:35 <harendra> the definition "defaultLiftWith t unT = \f -> t $ liftWith $ \run -> f $ run . unT" seems to be using liftWith of the wrappend monad. Whereas if I look at how liftWith is defined for MaybeT it does not seem to be doing so: "liftWith f = MaybeT $ liftM return $ f $ runMaybeT". Does'nt it have to recurse like defaultLiftWith does?
02:46:18 <tsahyt> given an AST (defined as a recursive sum type) with prisms, can I modify all nodes that match some constructor recursively? e.g. modify all the Bars in (Foo (Bar Quux) (Foo (Bar Quux)))?
02:48:32 <phadej> tsahyt: you'll need something like http://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-Plated.html 
02:49:49 <tsahyt> phadej: thanks, I'll look into it
02:50:21 <cocreature> plated is awesome
02:51:31 <phadej> somehow suggested that with TH support now in recursion-schemes one can "autoderive" Plated; helps to start fast
02:51:54 <cocreature> I just use the Data.Data default instance most of the time because I’m lazy
02:53:29 <osa1> ugh.. I have a module that fails to type check when I enable TypeFamilies
02:53:37 <osa1> without TypeFamilies it compiles fine
02:53:53 <cocreature> osa1: TypeFamilies implies a bunch of other extensions so maybe one of those is the problem
02:53:55 <phadej> cocreature: sometimes you have things which aren't Data :(
02:54:01 <osa1> hmm good point
02:54:05 <osa1> let me check the user manual
02:54:16 <phadej> probably MonoLocalBinds
02:54:40 <osa1> Implies:	-XMonoLocalBinds, -XKindSignatures, -XExplicitNamespaces
02:55:04 <phadej> i.e. probably you have to give a type-annotation to something in `where` clauses, to make it again polymorphic
02:55:15 <osa1> yup, NoMonoLocalBinds solved it
02:55:33 <phadej> I'd rather add a type-annotation
02:55:45 <osa1> yeah that's what I'll do because I can't even re-order my pragmas with this
02:55:46 <cocreature> huh, I didn’t even know NoMonoLocalBinds works in that situation
02:55:48 <phadej> TypeFamilies + NoMOnoLocalBinds is unsupported combination
02:55:51 <osa1> NoMonoLocalBinds has to come after TypeFamilies
02:57:18 <phadej> the manual says:
02:57:20 <phadej> > The flag -XMonoLocalBinds is implied by -XTypeFamilies and -XGADTs. You can switch it off again with -XNoMonoLocalBinds but type inference becomes less predicatable if you do so. (Read the papers!)
02:57:22 <lambdabot>  <hint>:1:125: error: parse error on input ‘type’
03:16:34 <Raddamu> L
03:24:47 * angerman is around in case anyone has questions re cross compiling th :-)
03:31:08 * hackage accelerate-llvm-ptx 1.0.0.1 - Accelerate backend generating LLVM  https://hackage.haskell.org/package/accelerate-llvm-ptx-1.0.0.1 (TrevorMcDonell)
04:04:39 * hackage ngx-export 0.3.2.1 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.3.2.1 (lyokha)
04:28:39 * hackage creatur 5.9.15 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.15 (AmyDeBuitleir)
04:44:43 <cocreature> does optparse-applicative have a way to use default options that are computed in IO or do I first need to use a Maybe and read the value after parsing?
04:46:58 <sternmull> how do i get ghc-mod to see the sources of my dependencies? I used "stack unpack" for a dependency and used that directory in "packages" of stack.yaml but ghc-mod still can not "go to definition" for it.
04:47:19 <cocreature> sternmull: I don’t think you can
04:48:18 <sternmull> cocreature: But ghc-mod can locate definitions in my modules. Why not also in dependencies when they are build from source...
04:49:10 <cocreature> sternmull: because GHC doesn’t know that you build them from source and where the sources live.
04:49:22 <ph88^> i like to put a conduit in a vector, i found a package but it's 5 years old https://github.com/jhance/vector-conduit not sure what to do
04:49:28 <cocreature> sternmull: codex should be able to do this
04:50:08 <sternmull> cocreature: codex looks interesting, thanks.
04:50:12 <angerman> cocreature: default options in IO sounds ... bah...
04:50:20 <angerman> cocreature: that would force IO all the way.
04:50:39 <cocreature> angerman: well everybody uses "execParser" anyway which lives in IO :)
04:51:10 <cocreature> angerman: I have a -j option and want it to default to getNumCapabilities. that doesn’t seem that unreasonable
04:51:38 <brynedwards> ph88^: conduit-combinators uses MonoFoldable typeclass which has a Vector instance
04:51:50 <angerman> cocreature: no, that doesn't sound unreasonable.
04:52:34 <angerman> cocreature: make your Option data type monoidal, and merge the parsed one with you `def` one from IO ;-)
04:53:15 <cocreature> angerman: but then I still need to separately execute some IO action instead of just running execParser
04:53:29 <cocreature> I guess that’s not so bad
04:56:26 <brynedwards> ph88^: in fact it has sinkVector as well https://hackage.haskell.org/package/conduit-combinators-1.1.1/docs/Conduit.html#v:sinkVector
04:57:18 <angerman> cocreature: I don't see how you can force it *into* execParser.
04:57:45 <cocreature> angerman: yeah I don’t see that either. I was hoping I had missed something in the API of optparse-applicative :)
04:58:21 <angerman> well, I'll try to see if I can manage to cross compile yesod...
04:58:32 <cocreature> good luck with that :)
04:58:50 <ph88^> brynedwards, that looks good ! do you think it would be an option to implement my own allocation strategy ? i see it starts at 10 then doubles
04:59:08 <angerman> I really hope people do not confuse the post from yesterday with the one from today...
05:07:27 <ph88^> is there a way to let ghci infer types and then give possible type synonyms for it ?
05:09:02 <angerman> ph88^: you mean String instead of [Char]?
05:44:07 <muzzle> Hi
05:44:19 <muzzle> so in haskell every function is supposed to have only one argument, right?
05:44:49 <lyxia> yes
05:45:06 <muzzle> so why do those two functions in http://lpaste.net/355834 behave differently ?
05:45:35 <muzzle> shouldn't they have the exactly same behaviour?
05:46:23 <Tuplanolla> You're using `Debug.Trace`, so all bets are off, muzzle.
05:46:40 <lyxia> it can be explained though
05:47:05 <muzzle> Tuplanolla what I really want to find out is, if I can keep haskell from re-evaluating 's' on every function call...
05:47:37 <muzzle> and my idea was that traceShow should be called every time the value is evaluated, right?
05:49:00 <Geekingfrog> doesn't s depend on a and b? And in that case you would need to recompute it every time a or b change right ?
05:49:10 <lyxia> in the first case traceShow will be evaluated at most once every time f is applied to two arguments
05:49:52 <muzzle> Geekingfrog right, but technically I could just not do that when using fmap
05:49:53 <lyxia> muzzle: and in the second it is evaluated at most once for every time g is applied to three arguments
05:50:03 <davean> muzzle: f introduces a lambda that g doesn't
05:50:23 <davean> muzzle: this gives GHC somewhere to capture
05:50:45 <muzzle> so f a b str isn't really equal to \a -> \b -> \str -> ... in that respect?
05:51:44 <davean> muzzle: https://wiki.haskell.org/Worker_wrapper
05:52:09 <lyxia> muzzle: in f if you move s into a nested where clause under f' you might get the behavior of g back
05:53:05 <davean> muzzle: if you tried to rewrite those as full out lambdas you might see it clearer - but to be clear the behavior would be "correct" if it was swapped too
05:56:09 * hackage snipcheck 0.1.0.1 - Markdown tester  https://hackage.haskell.org/package/snipcheck-0.1.0.1 (nmattia)
05:57:35 <Tuplanolla> Nesting shouldn't matter here, lyxia.
06:02:04 <muzzle> what is the preceise contract of debug.trace? That it prints every time, that it's argument thunk is evaluated?
06:03:11 <Tuplanolla> It's the same as for `unsafePerformIO`, which I recall had some elaborate documentation.
06:03:15 <c_wraith> muzzle: it creates a new thunk that produces output when it is forced.  When it is forced, it also forces its argument to WHNF
06:03:43 <c_wraith> Its second argument, that is.
06:04:09 <c_wraith> Once it is evaluated, that exact thunk won't produce output again.
06:04:23 <Geekingfrog> Btw, in what sense `unsafePerformIO` is unsafe ?
06:04:49 <c_wraith> Geekingfrog: in the sense that you give up all control over evaluation order and even how many times it's evaluated
06:05:09 <c_wraith> Geekingfrog: because the compiler assumes the result is a pure expression that can be inlined all over harmlessly
06:05:13 <Tuplanolla> You can produce a segmentation fault with it, Geekingfrog.
06:06:20 <c_wraith> Also, that that with polymorphic references that's usually prevented by the type system.
06:06:21 <muzzle> Geekingfrog: I guess it's also unsafe in the sense that it doesn't show that it's an IO action in it's result type
06:06:36 <ongy> Tuplanolla: without stuff from Foreign or ffi?
06:06:48 <Tuplanolla> You only need an `IORef`, ongy.
06:06:53 <c_wraith> ongy: yeah, it's actually documented in the docs for unsafePerformIO
06:07:04 <Tuplanolla> There are more creative ways too.
06:07:57 <c_wraith> Geekingfrog: if you use unsafePerformIO, you give up all control over when GHC might run the action - and it's free to run it exactly when you don't think it ever will.  And it probably will. :)
06:09:37 <Tuplanolla> We also have `unsafeDupablePerformIO`, `inlinePerformIO`, `accursedUnutterablePerformIO` and friends if you want even fewer guarantees.
06:10:26 <Geekingfrog> Yeah, I've heard of these as well, the last one has a nice comment in its source code as well :D
06:10:28 <Tuplanolla> Some may be deprecated; I don't remember.
06:13:58 <ongy> inlinePerformIO is deprecated and just accursedUnutterablePerformIO
06:26:49 <lyxia> Tuplanolla: nesting does matters because GHC is very conservative about floating out local bindings. I mean in this case you're free to try f2 and see for yourself. http://lpaste.net/355834
06:30:38 <Tuplanolla> Ah, in my head I nested them the other way, lyxia.
06:32:42 <lyxia> trace also seems much safer than unsafePerformIO
06:34:05 <Tuplanolla> That is, `let s = t in let f = s in f` instead of `let f = let s = t in s in f`.
06:35:59 <lyxia> I don't see how this unifies with the pasted code
06:36:55 <lyxia> anyway, IMO the situation with trace is much more nuanced than "all bets are off"
06:39:52 <Tuplanolla> I like your optimism.
07:10:11 <ij> What does cabal2nix's "--shell" do?
07:14:12 * hackage creatur 5.9.16 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.16 (AmyDeBuitleir)
07:34:41 <Lokathor> today's complaint of the day: show does the right thing for anything that isn't a String, but it does the wrong thing on Strings :P
07:36:13 <lyxia> what does it do wrong
07:39:04 <hexagoxel> Lokathor: does it do the right thing for (String, String) ?
07:39:45 <Lokathor> lyxia, it doesn't just do "id" :P instead it escapes a few things
07:40:05 <lyxia> just as designed
07:40:07 <Lokathor> hexagoxel, probably the same issue there
07:40:29 <hexagoxel> Lokathor: you looking in ghci? because ghci `print`s.
07:41:30 <Lokathor> hexagoxel, this is true in or out of ghci. You can't write a generic printing operation that does the "right thing" without rigging up your own typeclass or something
07:42:35 <Lokathor> and, as i recall, you also can't easily rig up your own typeclass for it because you need to write one instance for Show s => EasyPrint s, and then another for EAsyPrint String, and then you get a clash
07:42:40 <Lokathor> i could be wrong on the last part
07:43:15 <hexagoxel> > text $ show "hello, world"
07:43:17 <lambdabot>  "hello, world"
07:43:29 <hexagoxel> Lokathor: you really find that to be too much escaping?
07:44:19 <Lokathor> well considering that you (1) just passed it through text (2) saw your double quotes in your output, yes
07:46:00 <lyxia> Although it gets abused, the primary goal of show is to produce a Haskell representation of a value
07:46:03 <clamchowder> Question: how do I parse a string, where the parser succeeds and returns s if the string is of format *s*, and s neither begins nor ends with a space and s does not contain any *?
07:46:31 <Lokathor> lyxia, yes, I understand what you're saying on taht front :P
07:46:39 <ph88^> hey guys, i'm using this function https://hackage.haskell.org/package/conduit-combinators-1.1.1/docs/Data-Conduit-Combinators.html#v:sinkVector why is it slower than going to list first?  https://bpaste.net/show/5cf3431109e3
07:47:18 <clamchowder> using parsec
07:47:24 <hexagoxel> Lokathor: text just omits an additional "show"
07:47:50 <Lokathor> ph88^, "growing the vector as necessary to fit more elements.", maybe you're doing too many reallocations?
07:48:16 <ph88^> Lokathor, how can i check if i do too many ?
07:48:59 <Lokathor> ph88^, well I don't know. But it should generally be faster to use a Vector, so that's all I can think of
07:50:48 <clamchowder> I thought of doing lookAhead first and then get the s: lookAhead $ (noneOf " ") >> (manyTill anyChar $ try $ (noneOf $ " *") >> (char '*')
07:51:11 <Lokathor> hexagoxel, okay but what I want, if I was not clear, is the ability to say (smartPrint val) and have that act like (print val) for any type that's not String, and (putStrLn val) for String values. Particularly also, (smartPrintMany [thing1, thing2, etc])
07:51:32 <clamchowder> I thought of doing lookAhead first and then get the s: do{ char '*'; lookAhead $ (noneOf " ") >> (manyTill anyChar $ try $ (noneOf $ " *") >> (char '*'); manyTill anyChar (char '*')}
07:52:10 <Lokathor> but as far as I've ever seen you can't create an easy to use version of python's print statement in Haskell
07:52:15 <hexagoxel> Lokathor: i'd agree that needs either a new typeclass or an additional Data constraint.
07:52:49 <mniip> Lokathor, one se
07:52:50 <mniip> c
07:52:51 <lyxia> Lokathor: what you proposed works if you just add an {-# OVERLAPPING #-} pragma
07:52:52 <Lokathor> hexagoxel, hmmmm, I don't think that such a typeclass can easily be made... but tell me about this Data constraint?
07:53:12 <clamchowder> but this will not parse say "*a*" because the lookAhead rejects because the inside "a" has length 1
07:53:38 <Lokathor> lyxia, interesting suggestion. will it just pick the more specific instance when things overlap?
07:53:47 <lyxia> yes
07:54:26 <hexagoxel> Lokathor: you could generically traverse the input, wrapping all Strings in a newtype wrapper that has a different Show instance. then `show`.
07:54:35 <mniip> :t showStr
07:54:36 <lambdabot> ShowStr' a (ShowIsStr a) => a -> String
07:54:50 <mniip> > showStr ("foo", 123, ["bar"])
07:54:52 <lambdabot>  "(\"foo\",123,[\"bar\"])"
07:54:56 <mniip> > showStr "asd"
07:54:58 <lambdabot>  "asd"
07:56:51 <Lokathor> that seems right ish
07:57:08 <Lokathor> i have to leave the house in 5 minutes, unfortunately
07:58:11 <hexagoxel> i thought you wanted "(foo,123,[bar])"
07:58:44 <Lokathor> i do
07:58:47 <Lokathor> yeah seems to be right
07:59:10 <hexagoxel> :t everywhere'
07:59:11 <lambdabot> error: Variable not in scope: everywhere'
07:59:29 <hexagoxel> ah, nevermind. lambdabot has no syb.
08:00:44 <mniip> python wouldn't do "(foo,123,[bar])"
08:02:00 <Lokathor> mniip, you're right, but i've gotta go sadly
08:02:07 <Lokathor> perhaps we can fret over this another time
08:03:13 <hexagoxel> Lokathor: you can write what i have in mind using syb: everywhere, one of the "ext" functions, and a newtype.
08:03:18 <mniip> print calls __str__, and while str's __str__ is id, most structures' __str__ invoke __repr__ on the parts
08:04:06 <mniip> so print(foo) -> foo.__str__(), print([foo]) -> "[" + foo.__repr__() + "]"
08:04:10 * hackage som 9.0.2 - Self-Organising Maps.  https://hackage.haskell.org/package/som-9.0.2 (AmyDeBuitleir)
08:06:09 <shapr> good MORNING!
08:11:56 <maerwald> shapr: you're discriminating people in other timezones!
08:12:02 <plugin> I have a call to storablevector withStartPtr that appears to be throwing a runtime error:  "printf: argument list ended prematurely" I'm not sure how to proceed tracking down the issue.  could anyone advise?  gist is here: https://gist.github.com/o1lo01ol1o/6744a18c973407facb11aa3f121373d4
08:12:21 <cocreature> what’s the upper limit on the number of constructors a type can have?
08:12:34 <cocreature> INT_MAX or is it something significantly smaller?
08:12:42 <shapr> maerwald: it's not really morning here either
08:12:58 <mniip> cocreature, iirc there are no restrictions
08:13:04 <mniip> so probably on the scale of INT_MAX
08:13:12 <cocreature> mniip: alright, thanks
08:13:26 <shapr> cocreature: If you find out, I want to hear about it.
08:13:37 <shapr> I suspect compiling a module with INT_MAX constructors will be slow.
08:14:03 <cocreature> yeah, although I won’t get in the order of INT_MAX but it might be a few hundred
08:14:26 <cocreature> I guess I can always fallback to pattern synonyms and hope they compile faster
08:14:40 <mniip> a thousand cons compiles just fine
08:14:53 <cocreature> great, I should be safe then
08:15:12 <shapr> mniip: how did you discover that?
08:15:26 <mniip> > ("data D=" ++) $ intercalate "|" $ map (\x -> "C" ++ show x) [1..1000]
08:15:28 <lambdabot>  "data D=C1|C2|C3|C4|C5|C6|C7|C8|C9|C10|C11|C12|C13|C14|C15|C16|C17|C18|C19|C...
08:15:29 <mniip> copy-paste
08:16:21 <EvanR> and the case expression will probably end up being a table, so thtas not that slow
08:16:29 <EvanR> haskell rox
08:16:45 <shapr> yes!
08:16:59 <shapr> I'm building a simple REST API comparison, Haskell/Spock vs Python/Flask
08:17:06 <shapr> flask is making me sad in many ways :-/
08:17:36 <EvanR> pretty bad if the other thing in the comparison is making you too sad to finish the comparison
08:17:37 <shapr> persistent includes db migrations
08:17:56 <shapr> EvanR: I'm giving a talk, so I will finish the comparison, but golly Haskell is nice.
08:18:11 <EvanR> i dont know much about flask
08:18:18 <EvanR> maybe ill check out that talk
08:18:26 <shapr> A cup of monads, an ounce of persistence, a pinch of lucid html templating.
08:19:11 <shapr> EvanR: I haven't tried to arrange a video recording, but I'll see if I can do that.
08:19:32 <hanna> If I call a C++ function from a C shim and this C++ function throws an exception when the C shim is called via the FFI, what happens?
08:19:34 <EvanR> when and where?
08:19:43 <shapr> EvanR: Atlanta, two weeks from now.
08:19:50 <hanna> Do I get an IOException?
08:20:02 <mniip> with TH, I just defined a datum with 10k constructors
08:20:08 <mniip> albeit it took multiple seconds
08:20:18 <mniip> for anyone who wants to experiment,
08:20:19 <mniip> $(return $ return $ DataD [] (mkName "D") [] Nothing (map (\x -> NormalC (mkName $ "C" ++ show x) []) [1..10000]) [])
08:20:21 <EvanR> hanna: havent tried it, but i would guess an instant crash
08:20:32 <EvanR> via the default C++ exception mechanism
08:20:38 <shapr> EvanR: I could give the talk again at HacBoston, will you be there?
08:20:45 <hanna> EvanR: okay
08:21:13 <ij> Do I talk nix+haskell here or elsewhere?
08:23:33 <EvanR> shapr: having trouble finding hac boston info
08:23:47 <shapr> yeah, someone needs to put together a website, probably me :-/
08:23:59 <EvanR> sounds cool
08:24:00 <shapr> but hey, I can use this Spock thing for that!
08:24:07 <shapr> It's one of the three middle weeks in July
08:24:16 <shapr> EvanR: you're nawlens?
08:24:17 <EvanR> i can also zipper to atlanta potentially
08:24:20 <EvanR> yes
08:24:48 <shapr> I should visit there more often, last time was the Jazz Festival two years ago.
08:25:25 <EvanR> i am all that there is of haskell here period
08:25:44 <shapr> I feel that way about Atlanta sometimes.
08:25:47 <EvanR> which as far as web dev goes isnt much at all
08:25:52 <EvanR> since i dont do web dev haskell
08:26:07 <shapr> spock / persistent / lucid is easier than I expected/remembered.
08:26:52 <ph88^> is there any way i can see the chunks of memory that are being allocated by my program?
08:26:53 <EvanR> i need to try all that stuff, im just scared of the library complexity
08:27:16 <shapr> EvanR: it's surprisingly simple. I started with the spock.li tutorial that serves up json from a sqlite db
08:27:32 <shapr> then last night I grabbed spock-examples from github and re-learned some lucid.
08:37:07 <EvanR> ph88^: theres ghc-viz
08:42:20 <EvanR> shapr: ill be on the lookout for these itineraries
08:51:13 <hanna> acid-state question: I'm processing a few hundred posts per second and storing a log of posts that have been processed (as ID intervals); would it be a bad idea to issue an Update for every single post storing only the `id :: Int`? Right now I'm essentially doing them in batches and then issuing storing an interval (Int, Int) for every couple of hundred, but I'm having difficulties with this approach since I
08:51:15 <hanna> can end up in an inconsistent state if the process crashes after processing a post but before reaching the next “checkpoint”
08:51:34 <hanna> Issuing an Update per post would remove this problem, but I'm worried about performance / efficiency issues
08:52:56 <EvanR> each update just append data to a log
08:53:12 <hanna> yeah but I'm worried about the log growing too quickly if I append to it per post rather than per X hundred posts
08:53:18 <hanna> and as far as I can tell acid-state doesn't automatically trim the log?
08:53:29 <EvanR> the real work would be done on checkpoint or recovery
08:54:17 <EvanR> premature optimizsation!
08:56:09 <saurabhnanda> is there an easy way to set field's value, via lenses, only if the source value is not Nothing. Sample code: https://gist.github.com/saurabhnanda/ca405b6c580de3c4e5452b65f2e6ff8b
08:56:15 <hanna> EvanR: I'm asking to see if anybody has an answer before I have to go and benchmark it
08:56:25 <brynedwards> shapr: :o I just finished writing that Spock REST tutorial like a week ago. How did you find it?
08:57:55 <sdx23> hanna: you already got the answer. If you're concerned about the data, do updates. Checkpointing is sensible to faster load the state on application startup but otherwise not needed.
09:00:28 <lyxia> saurabhnanda: depSingular %~ (<|> Just (lookupHStore h "..."))
09:00:52 <saurabhnanda> lyxia: how exactly did you figure that out?!
09:01:01 <saurabhnanda> ...teach a man to fish...
09:01:48 <saurabhnanda> lyxia: where is <|> coming from?
09:01:58 <lyxia> saurabhnanda: Alternative from Control.Applicative
09:02:43 <saurabhnanda> lyxia:  and what's the difference between .~ and %~
09:03:26 <lyxia> If you want to set a value only in place of Nothing, that's what <|> is good for.
09:04:10 <lyxia> but using <|> you actually get a function to *modify* the field, rather than *set* it, hence %~ over .~
09:04:24 <saurabhnanda> lyxia: couldn't match Text with Maybe (Maybe Text)
09:04:49 <lyxia> ah I think I mixed things up
09:04:53 <lyxia> is the field not a Maybe?
09:04:56 <saurabhnanda> I'm trying to set a value only if the **incoming** value is not nothing. 
09:05:13 <saurabhnanda> the record field is not Maybe. The value being set is a Maybe.
09:05:17 <lyxia> ahhh
09:05:30 <saurabhnanda> it's the reverse thing
09:05:41 <lyxia> okay sorry, I would pattern match on the incoming value
09:05:43 <saurabhnanda> system has a bunch of default values. Override only if the user specifies Just x
09:06:43 <saurabhnanda> filed https://stackoverflow.com/questions/44184898/how-to-override-a-default-value-via-lenses-only-if-incoming-value-is-not-nothi
09:07:00 <saurabhnanda> I'm sure there's a combinator lurking in the lens library somewhere.
09:07:30 <lyxia> I doubt it
09:10:00 <lyxia>    DD.def @Nouns & maybe id (depSingular .~)
09:10:20 <lyxia>    DD.def @Nouns & maybe id (depSingular .~) (lookupHStore h "...")
09:10:29 <hanna> sdx23: EvanR: I gave it a test. Ran it for 10 million insertions; the “naive” approach (run update per post) gave me an acid-state dir the size of ~1 MB, and the “smart” approach (run update in batches of 1000) gave me an acid-state dir the size of ~1 GB
09:10:52 <hanna> so it does seem like acid-state dir size, and presumably performance, correlates 1:1 with the frequency of events you issue
09:11:43 <hanna> let's see if adding createCheckpoint+createArchive helps
09:13:06 <saurabhnanda> lyxia: (DD.def Nouns) & depSingular %~ (\x -> maybe x id (lookupHStore h "dep_label_singular"))
09:14:57 <sproingie> i wonder why acid-state would need so much more space once a transaction was committed.  do i misunderstand how it works?
09:15:41 <lyxia> saurabhnanda: also works
09:16:36 <saurabhnanda> thanks!
09:17:12 <hanna> Indeed, with createArchive those ~1GB are moved to a separate subdir `Archive`
09:17:33 <hanna> Why doesn't acid-state support automatically deleting them? I struggle thinking of a use case in which keeping old archives around is useful
09:17:39 <hanna> Since it's not like acid-state supports rollback
09:20:47 <EvanR> hanna: disk space is usually not a concern in acid state
09:20:58 <EvanR> its memory
09:21:10 <sproingie> disk space is always a concern if it grows without bound
09:21:15 <hanna> I have the opposite issue; my working set is tiny (a few kB) and I'm generating massive amounts of changes
09:21:28 <hanna> on the order of gigabytes
09:21:33 <hanna> Storing all that seems ridiculous
09:21:38 <EvanR> if you find out the Archive is not used
09:21:38 * hackage line 3.1.0 - Haskell SDK for the LINE API  https://hackage.haskell.org/package/line-3.1.0 (noraesae)
09:21:45 <EvanR> you can periodically delete it if it exists
09:21:55 <hanna> Indeed, I can; I'm puzzled as to why acid-state does not do this automatically
09:21:58 <hanna> it seems like it's designed to fail
09:22:02 <EvanR> hanna: to support acid, you really have to keep it around
09:22:21 <hanna> But why? the docs explicitly mention you can delete Archive as you see fit
09:22:25 <hanna> so clearly it's no longer needed
09:22:58 <EvanR> to support acid you have to keep the log until you checkpoint
09:22:58 <sproingie> external housekeeping can be a real pain, now you need your cron job to understand your app, at least where it lives
09:23:03 <EvanR> so youre going to use a lot of disk space
09:23:07 <EvanR> but the archive, im not sure
09:23:08 <sproingie> tho in the case of a single archive dir, that's hardly onerous
09:23:25 <EvanR> the behavior of your apps wrt to disk space usage is always an external issue
09:23:33 <EvanR> call sysops if you run out of space
09:23:46 <EvanR> get more
09:24:10 <EvanR> luckily this archive is not used and so cant reduce performance until you run out of disk
09:24:17 <sproingie> yah, as external housekeeping goes it's not so bad
09:24:38 <sproingie> unlike cassandra.  if you forget to clean that regularly, the whole cluster will bog down til it falls over
09:24:56 <EvanR> "historically" disk is not the concern $-wise
09:25:07 <hanna> I mean the standard fix here for me will be inserting a removeDirectory (acidDir </> "Archive")
09:25:18 <hanna> but I'm annoyed by having to hack like this
09:25:19 <EvanR> right after checkpointing
09:25:24 <EvanR> makes sense
09:25:33 <mniip> ski, ooh, I recently came up with a thing related to SEC, you might wanna take a look
09:25:36 <EvanR> you could also submit a pull request to disable the archive
09:25:39 * hackage glirc 2.21.1 - Console IRC client  https://hackage.haskell.org/package/glirc-2.21.1 (EricMertens)
09:25:44 <sproingie> there's an inflection point where more disk costs a *lot* more
09:25:49 <hanna> I'll give it a shot
09:26:06 <EvanR> sproingie: it doesnt sound like hanna is anywhere near this amount
09:26:08 <sproingie> but ok, not the worst maintenance headache
09:27:12 <EvanR> hanna: in the case that there is a bug in acid state, this archive is probably the only way to recover
09:27:30 <EvanR> so if this was mission critical probably good idea to not delete it
09:27:43 <hanna> I suppose that makes sense
09:27:45 <johnw> mniip: where is it at?
09:27:53 <hanna> Still, a “trimLog” function would make sense
09:27:57 <hanna> I'll try implementing it and submit a PR
09:28:04 <EvanR> trimlog = checkpoint
09:28:05 <mniip> one sec, lpaste is lagging
09:28:16 <EvanR> deleteBackupArchive would make sense
09:28:22 <hanna> I mean I basically need to copy/paste the createArchive code but remove the part that saves them
09:28:52 <sproingie> could make it so if Archive isn't writable, it warns (once) then ignores it thereafter
09:28:53 <EvanR> you probably need to actually save it
09:29:09 <ski> mniip : hm ?
09:29:09 <EvanR> then delete it after the checkpoint completes, and syncs
09:29:10 <EvanR> tricky
09:29:19 <EvanR> like hard syncs
09:29:27 <mniip> johnw, ski, basically, the FlipT/Apply here: http://lpaste.net/355313
09:29:34 <EvanR> which may not make sense in case of NFS
09:29:47 <sproingie> nothing makes sense with NFS
09:30:19 <mniip> the thing we're doing is, making a datatype with a certain type parameter being the last argument
09:30:32 <sdx23> EvanR: don't mix up checkpoints and archives. Archives is (superfluous) Log moved to a different directory after a checkpoint was made.
09:30:45 <EvanR> makes sense
09:30:51 <EvanR> i dont know how acid state does it
09:30:55 <sproingie> undeletable .nfsargebargle files, those were the bane of my existence at my last $workplace
09:31:10 <hanna> updating the acid-state per post also provides some major performance issues even on tmpfs where sync() should be essentially free; issuing 10 million ioctls vs issuing 10k ioctls is a question of ~1 min vs ~1 second
09:31:20 <hanna> although I think I could live with ~1 min extra time per 10 million posts
09:31:20 <mniip> consider something like natVal :: KnownNat n => p n -> Integer
09:31:30 <mniip> what if your 'p' doesn't have a nat argument in last position
09:31:34 <hanna> but I'm worried about sync() per post on HDD
09:31:48 <EvanR> hanna: it sounds like youre more worried about idempotence here than very granular acid
09:31:56 <ph88^> anyone know snoyberg ?
09:32:04 <hanna> I think I'll go the hard way after all, which is basically modifying my code to use DB transactions in order to synchronize the db_commit with the acid_update
09:32:05 <EvanR> which you could exploit to get more thoughput
09:32:09 <johnw> ph88^: if I admit that I do, what sort of question will follow?
09:32:25 <mniip> :t ((), 'a', True)
09:32:26 <lambdabot> ((), Char, Bool)
09:32:32 <mniip> :t FlipT $ Apply ((), 'a', True)
09:32:34 <lambdabot> FlipT Apply Bool ((,,) ()) Char
09:32:37 <mniip> :t FlipT $ FlipT $ Apply ((), 'a', True)
09:32:38 <lambdabot> FlipT (FlipT Apply Bool) Char (,,) ()
09:32:41 <mniip> and so on
09:32:45 <ph88^> johnw, i was a bit shut down, don't understand why
09:33:33 <ski> mniip : that's nice :)
09:34:49 <mniip> you can also "extract" the 'n' from 'P (Q n D)' with Compose
09:35:33 <mniip> :t FlipT $ Compose $ Just (Left 'a')
09:35:34 <lambdabot> FlipT (Compose Maybe) b Either Char
09:35:34 <ski> mniip : now i'm wondering whether `induce4 = unwrap . unflop . unflop . unflop . induce . flop . flop . flop . wrap' could be shrunk (avoiding conceptual repetition, DRY) to something like `induce4 = (wrapping . flopping . flopping . flopping) induce'
09:35:48 <mniip> ski, not for 'induce'
09:35:50 <mniip> because RankN
09:35:56 <mniip> would involve dependent types
09:36:03 <ski> yea, i was fearing that that might be a problem here
09:36:06 <sproingie> floperators
09:36:32 <mniip> well, sure, you could write a 'flopping'
09:36:48 <sproingie> you just can't read that code aloud and not giggle
09:36:50 <mniip> but it would be specialized to 'forall n. n -> (n + 1)'
09:36:56 * ski has been thinking, on and off, about something similar, for equality (and possibly also inequality) chain proofs
09:36:59 <mniip> i.e not useful in general
09:38:07 <mniip> you know, the best part is the backwards type inference
09:38:18 <mniip> where you don't see the FlipT types but see the type you're dismantling
09:38:24 <mniip> :t natVal
09:38:25 <lambdabot> error: Variable not in scope: natVal
09:38:32 <ski> it's nice, yes
09:38:43 <mniip> :t natVal
09:38:45 <lambdabot> KnownNat n => proxy n -> Integer
09:38:47 <mniip> :t natVal . Apply
09:38:48 <lambdabot> KnownNat n => f n -> Integer
09:38:51 <mniip> :t natVal . FlipT . Apply
09:38:53 <lambdabot> forall l (n :: Nat) (f :: Nat -> l -> GHC.Types.*) (b :: l). KnownNat n => f n b -> Integer
09:38:57 <mniip> :t natVal . FlipT . FlipT . Apply
09:38:58 <lambdabot> forall l l1 (n :: Nat) (f :: Nat -> l -> l1 -> GHC.Types.*) (b :: l) (b1 :: l1). KnownNat n => f n b b1 -> Integer
09:39:25 <mniip> :t natVal . Compose . FlipT . FlipT . Apply
09:39:26 <lambdabot> forall k1 l l1 (n :: Nat) (g :: Nat -> k1) (f :: k1 -> l -> l1 -> GHC.Types.*) (b :: l) (b1 :: l1). KnownNat n => f (g n) b b1 -> Integer
09:39:30 <mniip> stuff like that
09:39:50 <mniip> really cool imo
09:40:08 * ski nods
09:40:48 <ski> having to choose a particular argument ordering can be annoying, at times
09:40:59 <mniip> now you don't have to!
09:41:22 <jadrian> stack can't search/suggest missing packages by looking at imports can it? 
09:41:24 <ski> but getting lost in a forest of `Flip's,&c. haven't seen that fun, either
09:41:39 <ski> this may be a nice partial solution
09:44:25 <jadrian> mniip, ski: I wasn't following the conversation, but just to be clear, you're not talking about argument order in the general case right? 
09:44:39 <cocreature> jadrian: jadrian it can but only if they are already installed (but not in build-depends)
09:44:54 <jadrian> that is, this is not about being able to define a functior on `b` for an `F b a`
09:44:54 <mniip> jadrian, we're talking about argument order in type constructors
09:44:59 <mniip> uhh
09:44:59 <mniip> no
09:45:22 <jadrian> cocreature: oh I see
09:46:00 <mniip> jadrian, not in this particular case. We're talking about a class of functions that operate on 'forall p. p b'
09:46:10 <mniip> and fitting a 'F b a' into such a function
09:46:30 <mniip> for functors you might want to look at edwardk's Hask Functor
09:46:37 <mniip> that does some really cool stuff
09:46:50 <jadrian> mniip: don't know it, got to check it out
09:46:50 <wilornel> can you have a definition like so? `data MyFoo = MyFoo { name :: String, bar :: (a -> b) }? As in, bar would be an incomplete data type?
09:47:50 <jadrian> wilornel: incomplete? you mean because of the `a` and `b`?
09:49:45 <liste> wilornel: you can have "data MyFoo a b = MyFoo { ... }" OR use a GADT
09:50:17 <sproingie> i'd love it if IDE support meant it could reorder args as a one-click fix
09:50:20 <liste> wilornel: a GADT is like "data MyFoo where MyFoo :: String -> (a -> b) -> MyFoo"
09:50:52 <liste> wilornel: (or, with less confusing constructor name) a GADT is like "data MyFoo where MkMyFoo :: String -> (a -> b) -> MyFoo"
09:51:31 <sproingie> i always liked that ocaml has named args.  though not so much the syntax
09:51:54 <liste> (not sure how records and GADT's mix, maybe someone else is?=
09:52:13 <sproingie> GADTs with record labels is a thing
09:53:02 <sproingie> there's some (sensible) restrictions on overlap
09:54:45 <mniip> liste, you can write record GADTs
09:54:45 <liste> @define data Foo where Foo :: { bar :: String, baz :: a -> b } -> Foo -- wilornel
09:54:46 <lambdabot>  Defined.
09:55:00 <mniip> hmm
09:55:09 <mniip> last time I checked lambdabot had issues with record gadts
09:55:45 <wilornel> jadrian: Incomplete as in a possible candidate for bar would be `(,) 1`
09:55:56 <liste> > let foo = Foo { bar = "hi there", baz = id } in (baz foo) 5
09:55:58 <lambdabot>  error:
09:55:58 <lambdabot>      • Cannot use record selector ‘baz’ as a function due to escaped type var...
09:55:58 <lambdabot>        Probable fix: use pattern-matching syntax instead
09:56:36 <mniip> your foralls are backwards
09:56:44 <mniip> you're letting a skolem tyvar escape
09:56:47 <liste> yeah
09:56:51 <mniip> hmm
09:56:56 <mniip> @define data D where D :: forall a. { field :: forall f. f a } -> D
09:56:57 <lambdabot>  Parse failed: Parse error: {
09:57:00 <mniip> there
09:57:13 <wilornel> so for MyFoo, could I have `MyFoo "TheString" ( (,) 1 ) ?
09:57:14 <liste> that's the problem you mentioned?
09:57:18 <mniip> yes
09:57:29 <mniip> came up naturally when I tried defining natural transformations
09:57:54 <ph88^> where can i find the actual exectuable in a stack project? so far i've only been using   stack exec
09:57:58 <mniip> data NT (k :: kk -> kk -> *) (l :: ll -> ll -> *) (f :: kk -> ll) (g :: kk -> ll) where
09:57:58 <mniip>     NT :: (Functor k l f, Functor k l g) => { runNT :: forall a. Ob k a => l (f a) (g a) } -> NT k l f g
09:58:41 <wilornel> I'm so confused
09:58:54 <EvanR> what is a skolem tyvar
09:59:10 <mniip> EvanR, skolemized type-variable
09:59:10 <liste> ph88^: .stack-work/dist/...
09:59:16 <EvanR> yeah what is that
09:59:19 <mniip> think like...
09:59:32 <mniip> foo :: (forall a. a -> b) -> b
09:59:38 <EvanR> yeah
09:59:43 <mniip> if you say 'foo id'
09:59:49 <mniip> that would be foo id :: a
09:59:54 <mniip> where a is from the 'forall a'
09:59:58 <Sonolin> are orphan instances a bad idea?
10:00:06 <mniip> but that would mean the type variable would escape its scope
10:00:10 <sproingie> Sonolin: they're a code smell.  sometimes unavoidable.
10:00:15 <EvanR> wait, foo id is valid?
10:00:16 <Sonolin> hmm ok
10:00:18 <mniip> no
10:00:23 <ph88^> how can i make a zip for release ?
10:00:26 <jadrian> wilornel: I wouldn't call that incomplete
10:00:32 <EvanR> ok, so back to the question
10:00:37 <Sonolin> sproingie I ran into them because I'm trying to separate my persistance implementation, from my API
10:00:43 <mniip> it is invalid exactly because 'a' cannot escape its scope
10:01:04 <EvanR> whats a skolemized type variable
10:01:11 <Sonolin> so, for instance, I have a Data.User module which just exports the User types, and then I have an Api.User which implements the actual API (Aeson + Servant)
10:01:18 <jadrian> liste: you appear to want a record whose second field can take any function
10:01:21 <Sonolin> and another module Storage.User that implements the persistance backend
10:01:32 <Sonolin> am I going about this the wrong way?
10:01:34 <sproingie> Sonolin: if you control both modules, it's not quite "orphaned".  the danger is largely from importing a different implementation than expected
10:01:58 <jadrian> liste: also for some reason you appear not to want to parameterise your datatype over `a` and `b`
10:01:59 <mniip> EvanR, uhhh
10:02:02 <liste> jadrian: yeah, I was demonstrating to wilornel how to define a type with type variables in the definition that are not present in the type
10:02:10 <Sonolin> yea this is all contained in the same project (atm at least) sproingie
10:02:11 <jadrian> liste: so I would say there are two answers
10:02:30 <jadrian> liste: one answer would be, yes you can have that with existential data types
10:02:31 <EvanR> which thing in your story is that for example?
10:02:37 <mniip> a
10:02:38 * hackage esqueleto 2.5.2 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.5.2 (bitemyapp)
10:02:56 <EvanR> whats with this terminology?
10:03:04 <mniip> EvanR, during typechecking of a lambda like this, the type of the argument of 'id' is a type variable that cannot unify with anything
10:03:16 <jadrian> liste: the other answer would be, most likely you actually want the type constructor to be parameterised even though you don't think you do
10:03:53 <ph88^> bbl
10:04:00 <EvanR> mniip: no? you could pass it const and use it on various things inside the lambfa
10:04:01 <jadrian> liste: I would be inclined to think it's the latter, at least until you provide for a good reason not want that parameterization
10:04:12 <sproingie> if classes obeyed visibility rules like everything else, orphan instances would probably be a non-issue
10:04:13 <mniip> EvanR, when you use a function, e.g (id :: forall a. a -> a) ()
10:04:18 <mniip> the typechecker unifies a ~ ()
10:04:33 <liste> jadrian: yes, with using existentials you just push the problem around without solving it
10:04:58 <mniip> when you define a function, (\x -> ...) :: forall a. a -> a, the typechecker says that 'x :: a' but nothing can "displace" a
10:05:05 <mniip> so you can't unify a ~ ()
10:05:18 <mniip> because that would break the forall
10:05:20 <mniip> only, maybe, unify some other tyvar with it
10:05:33 <jadrian> liste: well, most likely but I don't know what problem you're talking about, as the only problem you posed was the definition of such a type without parameters
10:05:36 <EvanR> so that is what a skolemized type variable is
10:05:42 <EvanR> now what is zonking a skolem
10:05:45 <jadrian> liste: the existential will solve that problem
10:05:55 <mniip> zonking is the jargon for substituting
10:05:59 <jadrian> liste: but yes I don't see how that is useful, so most certainly you'll have other problems
10:06:05 <sproingie> ZONK ALL THE SKOLEMS
10:06:19 <jadrian> liste: I don't know what you're trying to do though, and why you don't want those parameters
10:06:21 <EvanR> ah
10:06:24 <mniip> well, a bit more specific than that
10:06:41 <mniip> I'd have to check with the GHC wiki to tell exactly what it includes and what it doesn't
10:06:49 <jadrian> liste: so it's a bit hard to reason, since I don't really know what it is that you want to solve
10:07:27 <jadrian> liste: so I guess the best starting point would be to make your case as to why you don't want those parameters there
10:07:31 <liste> jadrian: me? I'm not doing anything but demonstrating that there can be a type with  parameters in the constructor that are not present in the type signature
10:07:31 <jadrian> what would the problem be
10:07:48 <liste> jadrian: to wilornel
10:08:02 <jadrian> liste: and I got confused with names... 
10:08:10 <jadrian> liste: sorry!!
10:08:31 <mniip> when you typecheck '(flip :: forall a b c. (a -> b -> c) -> b -> a -> c) (id :: d -> d)', you derive a substitution: [(a -> b) ~ d, c ~ d]
10:09:17 <mniip> er
10:09:24 <mniip> [a ~ d, (b -> c) ~ d]
10:10:11 <liste> jadrian: no problem :)
10:10:14 <mniip> zonking is the stuff that turns '(type variable mess). b -> a -> c' into 'forall b c. b -> (b -> c) -> c'
10:10:24 <mniip> or something like that
10:10:30 <mniip> or related to that
10:11:08 <mniip> aha
10:11:21 <mniip> according to GHC wiki, zonking is both, because type variables are mutable cells
10:12:30 <EvanR> thats what i thought
10:12:32 <mniip> the latter is, I assume, tidying
10:12:38 <EvanR> the mutation process of the unification algorithm
10:13:58 <sproingie> zonking sounds a lot like instantiation
10:14:13 <EvanR> that cant be it
10:14:18 <EvanR> thats instantiation
10:16:21 <mniip> sproingie, would you call 'a ~ f b' instantiation
10:16:50 <mniip> or even, would you call 'a ~ b' instantiation
10:17:17 <sproingie> ah, no.  i'm going by the smattering of info and seeing "substituting variables with actual types" and the analogy popped in my head
10:17:36 <EvanR> actual types, not actors
10:31:22 <EvanR> i just converted (4, Just 'c') to Just (4,'c') with sequence, am i missing a more general version
10:32:05 <sproingie> they're not exactly isomorphic
10:32:08 <srhb> I seem to get InvalidUrlException no matter what I try to pass to a http-proxy app. Has anyone used this successfully, and what's a test request I can try?
10:32:16 <EvanR> huh
10:32:51 <EvanR> :t sequenceA
10:32:52 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
10:32:57 <EvanR> ah ha
10:33:51 <EvanR> the haskell goddess sequencea
10:34:06 <Kon> I want to learn data structures , should I learn it language agnostic and then try to implement in haskell or is it better to learn it directly in haskell
10:35:05 <glguy> You'll never be done learning data structures, and will do well to implement what you're learning as you go
10:36:19 <Kon> So which book is recommended for learning data structure functional way
10:36:33 <liste> @where okasaki
10:36:33 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
10:36:46 <liste> Kon: ^ that, and the book version
10:37:26 <liste> https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
10:37:42 <Tuplanolla> A typical cycle goes as follows, Kon: set out to solve a problem, reinvent something in the process, realize you did and read all about how someone else did it better.
10:39:16 <Kon> Thank you all for your help :)
10:39:17 <sproingie> okasaki might be a tad heavy.  classic data structures books work all right if you pay particular attention to recursive data structures
10:39:56 <jadrian> Kon, liste, sproingie: was about to say the same, Okasaki is pretty heavy for first timers. If that's the case I'd recommend this: www.iro.umontreal.ca/~lapalme/Algorithms-functional.html
10:40:26 <EvanR> sproingie: many of art of computer programming algorithms just dont translate to haskell
10:40:41 <Cale> Tuplanolla: Another typical cycle goes as follows: Set out to solve a problem, look for what others have done in that space, realise it's all terrible, branch the closest thing to being reasonable and hope that the upstream maintainer is still alive.
10:40:43 <maerwald> EvanR: idiomatic haskell you mean
10:40:51 <EvanR> yeah
10:41:16 <maerwald> I like the quicksort example https://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html
10:41:18 <Tuplanolla> Let's not crush their spirits yet, Cale.
10:41:30 <sproingie> yah AoCP is particularly yuck in that regard, self-modifying MIX code
10:42:09 <sproingie> great if you like a turing machine model of computation, not so good otherwise
10:43:13 <EvanR> hmm
10:44:07 <jadrian> sproingie: I do (somewhat) disagree with the notion that classic data structures are that helpful though, even if you focus on recursive
10:44:32 <sproingie> jadrian: they're plenty useful, just focus on the actual structure and not the imperative implementation
10:45:00 <jadrian> sproingie: well, a circular linked list is recursive
10:45:17 <jadrian> sproingie: that's not going to help you much
10:45:28 <jadrian> sproingie: the notion of state is fundamental
10:45:43 <EvanR> wouldnt call a circular linked list recursiv
10:45:52 <sproingie> a linked list certainly is
10:45:58 <EvanR> since its not an expression
10:46:05 <jadrian> sproingie: and of course you can use Ref's but then you're simulating the imperative approach
10:46:08 <jadrian> EvanR: the type is
10:46:08 <EvanR> its a assortment of heap objects
10:46:09 <nshepperd> it's good to learn about things like bloom filters and such, that aren't really considered 'functional'
10:46:25 <sproingie> hell you could do worse than a deep dive into linked lists
10:46:36 <nshepperd> (but they're not not functional either)
10:46:40 <EvanR> jadrian: eh... the type of a circular linked list?
10:46:54 <jadrian> sproingie: a linked list may be... it isn't if you e.g., put a pointer to each end so you can do a FIFO
10:46:56 <sproingie> tying the knot on a circular linked list would be a fun exercise
10:47:13 <EvanR> its a cyclic data structure, not a recursive expression
10:47:35 <jadrian> sproingie: most things you learn to do with linked lists in C don't translate
10:47:49 <sproingie> hm yah good point.  actually it's as simple as repeating a single list
10:47:49 <jadrian> sproingie: sure and for that you do need a functional data structures book, that's the point
10:48:01 <Tuplanolla> Relating to this: does anyone know of nonasymptotic time and space investigations of various data structures?
10:48:42 <nshepperd> all the different tree data structures are great for functional though
10:48:48 <sproingie> jadrian: i think we're just talking past each other.  i specifically mentioned to look at the structures, not the algorithms
10:48:56 <nshepperd> i think that's what was meant by recursive
10:49:14 <nshepperd> trees are sort of inductively defined in a way that circular linked lists aren't
10:50:00 <wilornel> I am hitting this weird compilation error. Given `data BinaryTree = Leaf | Node (BinaryTree a) a (BinaryTree a) deriving (Eq, Show, Ord)`, if I do `((Node Leaf (1 :: Integer) Leaf) :: BinaryTree Integer)`, I get     • Couldn't match type ‘Integer’ with ‘BinaryTree a’
10:50:02 <nshepperd> if you take any part of a circular linked list, you have something that isn't a circular linked list
10:50:04 <wilornel>       Expected type: BinaryTree (BinaryTree a)
10:50:07 <wilornel>         Actual type: BinaryTree Integer
10:50:31 <jadrian> sproingie: well, these are structures... a linked list with a pointer to head and tail is a structure
10:50:57 <sproingie> a linked list with either nil or another linked list is also a structure
10:50:58 <jadrian> sproingie: I mentioned algorithms because structures are defined with particular goals in mind
10:51:01 <EvanR> would be nice to have
10:51:08 <Kon> sproingie: You are talking about learning language agnostic , learning how they works .
10:51:15 <glguy> wilornel: Your data declaration doesn't match the error message
10:51:27 <sproingie> Kon: exactly
10:51:28 <glguy> wilornel: You can paste the actual code and actual error message to http://lpaste.net
10:51:34 <jadrian> sproingie: yes both are... and my point is while that one example does translate, most won't
10:52:10 <jadrian> sproingie: check any basic standard course on algorithms and data structures in C, look at the structures that are taught
10:52:16 <sproingie> the typical examples with the boxes and arrows tend to translate pretty well
10:52:53 <sproingie> if it's C or java source, not so much
10:53:11 <jadrian> sproingie: no, not really... because for the most part they aren't used in a purely functional way
10:53:13 <EvanR> sproingie: i dont think it does
10:53:43 <EvanR> many things you write in haskell are ambiguous as far as that box and arrow goes
10:53:47 <jadrian> sproingie: circular doesn't work, double linked doesn't work, pointers at both ends doesn't work, etc
10:53:58 <EvanR> soundness in the presence or absense of sharing..
10:54:14 <sproingie> closest thing to double-linked i can think of would be a zipper
10:54:42 <EvanR> which doesnt give you access to both sides
10:54:56 <wilornel> glguy: http://lpaste.net/355842 . I was messing around with other things as well. If needed, I can simplify the file 
10:56:15 <glguy> wilornel: you need to attach the error , too
10:56:32 <Tuplanolla> Swap the arguments of the folding function, wilornel.
10:57:59 <wilornel> http://lpaste.net/355842
10:58:56 <glguy> foldTree (\x y -> x) :: b -> BinaryTree b -> b
10:58:57 <glguy> foldTree (\y x -> x) :: b -> BinaryTree a -> b
10:59:02 <sproingie> i guess i'm extrapolating too much from my own experience.  learned lisp by doing my data structures class in emacs lisp
10:59:03 <glguy> Like Tuplanolla said
10:59:54 <wilornel> Ah, right! For some reason flycheck was highlight x and y in red in the proper ordering
11:00:14 <wilornel> Also, I forgot to think about reading this thing from left to right and doing the bindings mentally
11:01:58 <wilornel> Thank you glguy  and Tuplanolla 
11:15:04 <nshepperd_> Are iorefs expensive in GHC? There must be some special bookkeeping required to make them work with the generational collector?
11:15:52 <EvanR> that special bookkeeping happens with all mutable structures
11:15:58 <EvanR> beware!
11:18:17 <nshepperd_> I guess the same problem applies to tying the knot, so there must be a cheap solution
11:20:09 <nshepperd_> The problem is that older generations can point to newer generations
11:20:37 <EvanR> it does degrade performance from what i read
11:20:37 <sproingie> confine it in a STRef maybe?
11:20:43 <sproingie> (if applicable)
11:24:17 <nshepperd_> I guess maybe we just add the object to a "to be scanned" list whenever it points to something newer. But that sounds bad
12:31:04 <bollu> cocreature: pin
12:31:06 <bollu> ping*
12:33:02 <bollu> @tell cocreature where is CallableOperand in llvm-hs?
12:33:02 <lambdabot> Consider it noted.
12:33:16 <cocreature> bollu: git grep ftw :)
12:33:31 <bollu> cocreature: I did try -_^
12:33:36 <cocreature> oO
12:33:42 <cocreature> works just fine for me
12:33:50 <cocreature> it’s in LLVM/AST/Operand.hs
12:33:59 <cocreature> currently it’s a type synonym but it should really just be a separate type
12:34:09 <cocreature> bollu: btw I’ve finished the lexer for tablegen.
12:34:17 <bollu> "type CallableOperand  = Either InlineAssembly Operand" ?
12:34:22 <cocreature> yep
12:34:27 <bollu> cocreature: ah, that's good, I was considering sitting down and doing that
12:34:46 <bollu> cocreature: so, should we change this to an actual type with Intrinsic as well?
12:35:23 <cocreature> yep
12:39:08 * hackage stutter 0.1.0.1 - (Stutter Text|String)-Utterer  https://hackage.haskell.org/package/stutter-0.1.0.1 (nmattia)
13:08:40 <bollu> how do I use alex?
13:08:41 <bollu> https://pastebin.com/V86VRBzR
13:08:50 <bollu> I'm getting a "Encountered missing dependencies"
13:15:09 * hackage sbp 2.2.2 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-2.2.2 (markfine)
13:15:36 <sternmull> how do i write a ByteString literal? I turned OverloadedStrings on if that matters.
13:16:50 <c_wraith> sternmull, you start by internalizing the warning the strings are characters and bytestrings are bytes, and that difference really does matter. 
13:17:37 <sternmull> i know. But i thought i could turn my ascii string literal into bytes without any problems.
13:18:05 <c_wraith> sternmull, once you fully understand that, you will only sometimes be surprised by the results of importing Data.Bytestring.Char8
13:18:23 <c_wraith> becaise you *will* forget this warning. 
13:18:54 <c_wraith> it will break your program every once in a while when it runs into the real world. 
13:19:05 <sternmull> well... and is there a way to express a byte sequence in code?
13:19:44 <kadoban> sternmull: Calling pack on a list of Word8 would be my default
13:20:13 <c_wraith> I mean, I already told you how to do it. :P
13:20:28 <sternmull> i missed that
13:20:43 <c_wraith> the module I pointed out. 
13:20:58 <c_wraith> it contains an IsString instance. 
13:23:51 <sternmull> oh, i think my problems is actually something else. I tried to use a ByteString for oneOf in megaparsec and ByteString is not Foldable.
13:24:51 <kadoban> Are you parsing text or bytes?
13:25:33 <sternmull> it is ascii text. So i decided to stick with bytes. Everything else should be an input error.
13:25:57 <tdammers> bytestring is 8-bit; ascii is 7-bit
13:26:21 <sternmull> ascii encoding uses one byte per codepoint.
13:26:35 <sternmull> its just that the most significant bit should be zero.
13:27:09 <kadoban> sternmull: Typically, personally, I'd just call that utf8 and decode it as such and then treat it as text. Unless the format you're parsing is and will forever be ASCII, it's just better usually.
13:28:36 <sternmull> kadoban: Yeah... maybe handling unicode would give better error messages. The input is required to be ascii but if it happens to be utf-8 with non-ascii characters then my current approach will give strange error messages.
13:30:50 <kadoban> Right, that's my usual reason. Though if it's actually required to be ASCII by something outside of your code, just bailing out and saying "hey, that's not ASCII!" can be fine too
13:31:33 <EvanR> if your input will be forever ASCII, then UTF-8 works fine
13:31:45 <EvanR> thus, ascii is dead
13:32:12 <EvanR> treat expected ascii input as utf8
13:33:12 <EvanR> (if its ascii + weird stuff in other bytes... then dont do that)
13:33:19 <EvanR> in the other half of the byte
13:35:11 <sternmull> hm, i still fail to use Text.Megaparsec.Char.oneOf. I don't understand why i can't satisfy it with an ordinary String. oneOf " \t" leads to "Ambiguous type variable ‘f0’ arising from a use of ‘oneOf’"
13:36:25 <geekosaur> you have OverloadedStrings turned on, likely
13:36:35 <sternmull> yes i do
13:36:45 <geekosaur> so you need a type annotation because oneOf is polymorphic and therefore blocks it resolving to String
13:36:56 <lyxia> bollu: have you tried installing alex
13:37:38 <geekosaur> (which is what "Ambiguous type variable" means more or less; it's too polymorphic so it can't figure out what type to use)
13:37:45 <bollu> lyxia: I needed a build-tools in  my .cabal
13:37:46 <kadoban> sternmull: Ah, because oneOf in megaparsec takes any Foldable of Char, and there's no default for that with IsString. If you're not using OverloadedStrings for anything else, the easy way is just to turn off that extension.
13:37:48 <geekosaur> this is the downside of OverloadedStrings
13:37:52 <lyxia> bollu: oh yeah, that helps
13:38:07 <sternmull> geekosaur: I already tried "oneOf (" \t" :: T.Text)" but that does not help because Text is not foldable.
13:38:13 <geekosaur> right, you need String there
13:38:22 <geekosaur> neither Text nor ByteString will work
13:38:43 <geekosaur> but you need to explicitly annotate it as String because OverloadedStrings can't see through Foldable
13:39:17 <geekosaur> (sort of. it's a little more complex than that, but close enough)
13:39:19 <sternmull> geekosaur: Thanks! Adding :: String did the job. No idea why i didn't came up with that.
13:39:37 <kadoban> It's a bit weird of an error, I think everyone finds it confusing at first.
13:39:41 <geekosaur> yep
13:41:12 <geekosaur> especially since the corresponding Num hackery often works because the typeclasses you often use it with are specified by the language Report to make it work. but OverloadedStrings isn't part of the Report and Foldable is actually a bit hard to make work the 'automagic' way Num does
13:42:15 <geekosaur> rather, to make work the way the classes used with Num work
13:42:45 <sternmull> my understanding was that the string overloading should not be an issue because all the overloaded candidates are not foldable. So i didn't really expect overloading to take place in that case.
13:43:50 <geekosaur> the problem is the compiler can't check that. and the combination of global instances and support for separate compilation means it can never be 100% certain you won't later link in a module that provides another IsString instance that can also be Foldable
13:44:14 <geekosaur> well, and any time you run up against checking two classes like that, it's just plain hard to typecheck like that
13:44:15 <kadoban> It always takes place. All GHC knows is that it needs something that's both IsString and Foldable there, and there's no default for either, so it just goes *welp, dunno*
13:45:55 <geekosaur> and yes, there's no way to tell the compiler 'if you can't figure out something sensible for Foldable yourself, use a list'
13:46:23 <sternmull> i wouldn't want that
13:46:28 <geekosaur> (which is something of a pity because that'd also likely solve a lot of the weird confusing errors people get with other Foldable-related situations)
13:47:12 <thang1> Yeah, it'd be great if we could specify "sane defaults" for things.
13:47:14 <geekosaur> eh? it'd only come into play if it couldn't figure out anything else --- the cases where it currently spits out 'Ambiguous type variable' errors
13:47:33 <thang1> Our current defaulting strategy is fairly limited imo
13:47:37 <geekosaur> yes
13:48:00 <kadoban> I think there's a general understanding that it'd be nice if there was a way, right? Couldn't we just be able to set defaults when we define the typeclass I suppose? Isn't there even an extension, or did I misremember that?
13:48:03 <clamchowder> How do I invert a Parsec parser? Say I have parser p, and I want to transform into p' such that p' accepts if p rejects and vice versa
13:48:29 <thang1> clamchowder: my first thought is not . parser -- But that's probably wrong :p
13:48:52 <thang1> kadoban: There's some defaulting proposals out there iirc
13:48:56 <sternmull> That sounds like scary implicit magic to me. If something can not be determined by the rules that everyone agreed on then the compiler should give up with a good error message. Its up to the human to make clear what exactly he wants.
13:49:33 <clamchowder> thang1: thanks I'll try it out
13:49:46 <davean> No, clamchowder , not take a bool
13:49:51 <kadoban> sternmull: It already exists for other typeclasses. For example if you leave some Num ambiguous, you get an Integer. And it's usually fairly innocuous and helpful that that happens, AFAIK.
13:50:23 <geekosaur> fmap not?
13:50:28 <geekosaur> (re parser)
13:50:56 <geekosaur> there's also notFollowedBy but that is subtly different (it never consumes input)
13:52:00 <clamchowder> geekosaur: notFollowedBy seems to be the one I wanted
13:52:06 <clamchowder> geekosaur: thanks.
13:52:16 <sternmull> i don't have much practice with haskell. Its more my general opinion that software should not do magic tricks when something is unclear. But maybe it is appropriate to resolve some type ambiguities. I can't tell :)
13:53:04 <geekosaur> let's put it this way. would you prefer to have to somehow mark every numeric literal with its expected type, either by each one having its own syntax or by a type ascription?
13:53:26 <geekosaur> well, not every, but enough so it can always figure out the type.
13:53:41 <thang1> (1 :: Int) + (1 :: Int) -- seems fairly obtuse and pointless to me
13:53:45 <sternmull> probably not. I like overloading to some degree.
13:54:03 <geekosaur> you only need one of those, but without defaulting you would need to have at least one of those
13:54:10 <geekosaur> (the other can be inferred)
13:54:44 <geekosaur> so, basically we trade off some strictness in types in the name of usability
13:56:25 <Sonolin> is there a good writeup/explanation on the use of the apostrohe in types?
13:56:37 <Sonolin> i.e. Capture "id" Int :> Get '[JSON] Item
13:56:43 <Sonolin> I want to learn more about what '[JSON] means
13:57:01 <EvanR> the extension is DataKinds
13:57:04 <geekosaur> you're looking for DataKinds and kind promotion
13:57:28 <Sonolin> thank you!
13:58:39 <geekosaur> the short version is that, with DataKinds enabled, data Foo = Bar | Baz -- not only defines a type Foo with data constructors Bar and Baz, but also a kind Foo inhabited by type constructors Bar and Baz
13:59:21 <geekosaur> the leading single quote then indicates that you are talking about the promoted version instead of the normal one
13:59:42 <geekosaur> so '[JSON] is a type level list with one item, the (usually) promoted type constructor JSON
14:00:37 <geekosaur> ("usually" because '[Int] is also a perfectly valid type level list. it will not kind-check in a context expecting something like '[JSON] though
14:01:04 <dmwit> ...and to connect the dots about why it's needed, now suppose you have `data Foo = Foo` and write `Foo` at the type level. Should this be the unpromoted type `Foo` which classifies the term `Foo`, or the promoted `Foo` which is classified by kind `Foo`? The apostrophe disambiguates between these two.
14:01:37 <Sonolin> ok, so geekosaur the '[JSON] that corresponds to the type of a list that can only contain data of type JSON inside?
14:01:39 <geekosaur> right, was about to add a different example (whether [JSON] means a list of values of type JSON, or a type level list)
14:01:53 <geekosaur> no
14:02:16 <dmwit> Sonolin: No, `'[JSON]` is not the type of any list. It is a promoted list containing types.
14:02:37 <Sonolin> hmm ok
14:02:43 <Sonolin> well I have some reading to do I guess
14:03:11 <geekosaur> right. this gets tricky for people, much less for the compiler which is what needs the ' as a hint that it's not just seeing a list of values of type JSON but a list of _types_
14:03:39 <geekosaur> (rtaher, the type meaning a list of values of type JSON)
14:03:46 <dmwit> Sonolin: `'[JSON]` is not the type of *any* term -- much like `Monad` is not the type of any term, and `Maybe` is not the type of any term.
14:03:59 <monochrom> The fun of "data Foo = Foo" introduces four different Foo's.
14:04:00 <dmwit> Sonolin: It is just used in a completely different way than to classify terms.
14:04:33 <dmwit> Sonolin: You can write type constructors which, when applied to the list `'[JSON]` produces a type taht classify terms (and this is the normal way to use it).
14:04:54 <sproingie> monochrom: the type Foo, Foo the constructor, and ...?
14:05:00 <dmwit> Sonolin: e.g. in your example `Get` is such a type constructor.
14:05:08 * hackage bench 1.0.4 - Command-line benchmark tool  https://hackage.haskell.org/package/bench-1.0.4 (GabrielGonzalez)
14:05:16 <Sonolin> ah thanks dmwit, that makes more sense
14:05:20 <EvanR> sproingie: the kind 'Foo and the type 'Foo of kind 'Foo
14:05:22 <dmwit> sproingie: `Foo` the term constructor, `Foo` the type constructor, `'Foo` the type constructor, and `'Foo' the kind constructor.
14:05:37 <sproingie> i'm completely clueless on kinds that aren't *
14:05:53 <EvanR> its silly!
14:05:53 <sproingie> or made up of *'s and -> anyway
14:06:15 <dmwit> I bet you can grok kinds that include `Constraint`, too. =)
14:07:08 <geekosaur> at least until you run into the weirdness that happens because Constraint and * are treated identically by the typechecker >.>
14:07:09 * hackage fltkhs 0.5.1.8 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.1.8 (deech)
14:07:10 <sproingie> i only recently saw Constraint, still not entirely sure what that kind is about
14:07:35 <dmwit> sproingie: Have you seen the standard old-style type-level natural number? `data Zero; data Succ a`, so that you have types like `Succ (Succ (Succ Zero))`.
14:07:36 <geekosaur> Num a => a -> a
14:07:39 <geekosaur> (Num a) is of kind Constraint
14:07:47 <sproingie> dmwit: yah, i know those
14:08:00 <dmwit> sproingie: If so, you can already see the problem: this already allows non-natural-like types like `Succ (Succ (Succ Int))`.
14:08:12 <dmwit> sproingie: So you might like a sort of type-level type system that prevents such applications.
14:08:17 <geekosaur> basically Constraint is the kind of type level terms that occur before a =>
14:08:19 <sproingie> geekosaur: that much i get, i'm just not sure where that comes in in the kind system
14:08:28 <dmwit> sproingie: What you'd like to say is that there's a *kind* `Nat`, and `Succ` can only be applied to `Nat`s.
14:08:37 <geekosaur> (not entirely true because of some horkery in pattern synonym syntax)
14:09:13 <dmwit> sproingie: So, you might wish for some syntax like `kind Nat = Zero | Succ Nat` which would define a new kind `Nat`, and two type constructors `Zero` and `Succ` of kinds `Nat` and `Nat -> Nat` respectively. Now since `Int` has kind `*`, the application `Succ Int` is ill-kinded.
14:09:13 <sproingie> dmwit: so it's the type of a type, and actually strongly typed now?
14:09:33 <dmwit> sproingie: So this is what was done in GHC. Except instead of stealing a keyword for `kind`, the just reused `data`.
14:11:50 <dmwit> And to directly answer your question: yes, a kind is the type of a type.
14:12:43 <dmwit> GHC actually used to have *four* levels: term, type, kind, sort. That always bugged me, since it really badly violates the 0/1/many rule. That's all fixed up now, but the fix is confusing as heck.
14:13:27 <sproingie> seems this sort of thing could just infinitely regress if you wanted, à la metaclasses
14:13:45 <geekosaur> there's even a language that does that infinite regression, Tim Sheard's Omega
14:13:50 <sproingie> what, uh, sort of thing is a sort used for?
14:14:08 <dmwit> sproingie: For rejecting kinds like `(->) -> *`.
14:14:10 <geekosaur> a sort is the 'type' of a kind in the same way a kind is the 'type' of a type
14:14:35 <geekosaur> and yes, it lets you reject stuff like dmwit showed
14:14:47 <dmwit> Or like `(->) * * *`, where the arrow kind constructor is applied to too many kinds. You know, that kind of thing.
14:14:50 <pie_> so my friend has a problem for his CS class and i want to show him that haskell is cool
14:15:12 <pie_> he has some kind of binary encoding for characters so a is like 1 and b is 10 and c is 010 or something
14:15:21 <pie_> and he needs to parse a binay string
14:15:40 <pie_> presumably this is supposed to be such that the parseing is unique obviously
14:15:52 <pie_> i bet theres some really simple expression for this
14:16:04 <dmwit> Sounds like huffman coding or similar.
14:16:06 <sproingie> some kind of prefix code sounds like
14:16:12 <EvanR> so "0" -> 0, "10" -> 2, and so on
14:16:30 <EvanR> or more complex
14:17:09 <thang1> Parsec/Megaparsec seems somewhat overkill for this...
14:17:14 <monochrom> sproingie: Things like "Num a" has kind Constraint. (Therefore, Num has kind * -> Constraint.) Now it is possible to define "data G (c :: * -> Constraint) = forall a. c a => MkG a" such that "G Num" is as good as "data N = forall a. Num a => MkN a" and "G Show" is as good as "data S = forall a. Show a => MkS a".
14:17:38 <dmwit> For decoding, a regex might suffice. A trie or similar could be a nice way to implement it, too, and needs less theory to understand how it works.
14:19:09 <thang1> pie_: do you have a more precise definition of what the encoding is?
14:21:15 <monochrom> "sort" is a fairly overloaded word (how ironic). I am glad that the Haskell community actually stays away from it and just say "type" and "kind". Outside Haskell, one community uses "sort" for roughly what we call "kind", and another for what we call "type". It is a mess.
14:21:38 <geekosaur> it started to use it and then stopped.
14:21:42 <EvanR> its types all the way up
14:21:50 <geekosaur> at one point we had the sort BOX
14:22:54 <sproingie> does make me think of metaclasses from OO languages i've used
14:23:28 <hololeap> i want to use the Cabal libs to get a list of all installed cabal packages. does anyone know how to do this and/or where to start? there don't seem to be any examples of how to use Distribution practically
14:23:33 <geekosaur> (and that itself is a bit of a confusion of levels; it doesn't mean the 'type' of a kind, it means the representation of values of types inhabiting the kind)
14:24:00 <glguy> hololeap: I do something like that in my irc client to generate a list of the transitive dependencies and their versions I'm using
14:24:10 <geekosaur> so current ghc has RuntimeRep which is dissociated from the value/type/kind stack
14:24:26 <glguy> hololeap:  https://github.com/glguy/irc-core/blob/v2/Setup.hs
14:24:45 <glguy> as well as to validate their licenses
14:25:16 <glguy> hololeap: If you just want to inspect the user package database, then check out https://github.com/glguy/GhcPkgUtils
14:25:51 <sproingie> glguy: that'd be neat to use as a stack script
14:26:09 <sproingie> script, command, whatever stack calls it
14:27:15 <hololeap> glguy: my end goal is to compile a list of all the installed hackage docs into an html file
14:28:24 <glguy> hololeap: How about just opening the index? (e.g. ~/.cabal/share/doc/x86_64-osx-ghc-8.0.2/index.html )
14:28:41 <thang1> Random question: Would it be possible to think of values -> types -> modules, etc., all being on a hierarchy? (Not necessairly in haskell, but just in general programming language theory)
14:29:11 <glguy> hololeap: I don't have any example code specifically about installed haddock, but it's possible that some of the code in that repository will be useful to you for figuring out how to query installed things with Cabal
14:29:29 <sproingie> i'm not sure modules fit in there.  maybe in SML.
14:29:43 <pie_> dmwit, he did mention huffman actually (thang1)
14:29:57 <monochrom> It is both value->module and type->module, not value->type->module.
14:30:15 <hololeap> glguy: i've installed most of my cabal packages through my native linux package manager, and so the docs are scattered around the /usr/share/doc directory. i don't think there is a single index.html pointing to all of them
14:30:22 <thang1> monochrom: but all values have a type, don't they?/
14:30:26 <geekosaur> thang1, the Omega language I mentioned earlier does that
14:30:46 <geekosaur> although modules aren't part of it; for one thing, what meaning of 'module'?
14:30:53 <glguy> hololeap: How about just processing the output of "ghc-pkg dump"
14:30:55 <monochrom> Sure. That does not contradict value->module.
14:31:03 <glguy> hololeap: that lists the haddock-html directories
14:31:16 <hololeap> glguy: that's not a bad idea
14:31:24 <thang1> Well, to be fair, I've never really understood wtf people actually use first class modules for anyway and how they work
14:31:31 <monochrom> The fallacy here is assuming that everything is covered by one single relation.
14:32:07 <glguy> hololeap: or: for each pkg in ghc-pkg list; do ghc-pkg field $pkg haddock-html
14:32:14 <monochrom> If I own a cat, and my cat eats a mouse, I do not really write "mouse -> cat -> me".
14:32:37 <MarcelineVQ> what if you ate the cat that ate the mouse
14:32:50 <monochrom> Instead, I need two symbols, one for being owned, another for being eaten, and then it is "mouse ~> cat => me".
14:33:23 <monochrom> Oh BTW I could also be owning that mouse too.
14:33:29 <thang1> geekosaur: Omega was apparently created by a professor at my university. Neat!
14:34:06 <thang1> Yeah Omega is pretty much exactly what I was thinking of.
14:34:30 <thang1> Now, to fix my fallacy of thinking here. That makes sense, monochrom, one single relation is too simple
14:37:39 <monochrom> This is actually important when understanding Haskell because it has two fairly orthogonal classification systems of types, one is kind, the other is class.
14:38:13 <monochrom> For example type Int is at the same type a member of * and a member of Ord.
14:38:25 <monochrom> s/at the same type/at the same time/
14:38:27 <sproingie> "mouse -[eatenBy]-> cat -[owns]-> me" in one graph db thingie
14:39:10 <monochrom> To make things worse, Ord has a kind too, it's * -> Constraint.
14:39:33 <monochrom> Yes what you need is a multigraph or a multiple-table database.
14:41:53 <monochrom> Also, they're pushing us to rename * to Type. (So that parsing is easier.)
14:42:40 <thang1> Isn't * already considered "type"?
14:43:12 <monochrom> Yes. So I mean they want us to actually use "Type" more often.
14:43:59 <thang1> Which makes sense. I'd imagine  * is a pain to parse on 
14:45:56 <monochrom> It is an annoying exception because everywhere else * is infix.
14:52:56 <Sonolin> so I got a function now
14:53:06 <Sonolin> unshift :: HList (a ': b) -> (a, HList b)
14:53:19 <jadrian> monochrom: what do you call members of kinds, in general? 
14:53:27 <Sonolin> I'm assuming there's no way to signify that I want to accept either an HList with contents, or an empty HList?
14:53:39 <Sonolin> (working off of https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/kind-polymorphism-and-promotion.html)
14:53:43 <monochrom> types :)
14:53:49 <jadrian> monochrom: argh :/
14:55:22 <monochrom> Int :: *, so I say that Int a type. I extend this to: If Foo is a user-defined kind by way of DataKinds and "data Foo = F1", I say that F1 is a type too, and maybe remind you that the kind is F1.
14:56:34 <monochrom> The rationale being you are going to write type sigs like "f :: Int -> Proxy F1 -> ..." and F1 appears where you are looking for a type.
14:57:34 <jadrian> monochrom: yes but then renaming * to Type that whole explanation becomes slightly more confusing, no?
14:57:41 <monochrom> To be sure, when you finally confront me with "Ord Int :: Constraint, so are you going to say that Ord Int is a type too?!" I will admit I make an exception there :)
14:58:00 <monochrom> Ah yes, that's true, but has always been done everywhere.
14:58:05 <jadrian> true
14:58:23 <monochrom> "5 :: Int" suffers the same problem, just a bit more subtly.
14:58:24 <sproingie> monochrom: i thought it was a kind
14:59:10 <sproingie> if constraint is a kind ... argh thus hurts my brane
14:59:17 <monochrom> Namely, a more precise expression would be "5 :: SetOfInts" or "5 :: Ints"
15:00:06 <sproingie> well it's a single value from the set of Ints, so it's an Int
15:00:37 <monochrom> More acutely, "empty :: Set Int" but that means the type call "Set Int" stands for a powerset, so some people actually take issue and say "why is it not empty :: Powerset Int"?
15:01:58 <monochrom> sproingie, yes, but I am describing another school of thought, one that you and I don't necessarily agree with, but it exists.
15:02:06 <jadrian> monochrom: I was referring to the fact that  in T :: Type then T is a type that is a member of Type,  and  S :: F is a type that is not a member of Type
15:02:22 <monochrom> Ah OK, then I misthought.
15:02:44 <monochrom> We don't have a better wording.
15:02:45 <jadrian> monochrom: the fact being a type and being a member of Type are not the same appears a bit confusing
15:02:47 <jadrian> I think
15:03:01 <monochrom> I agree.
15:03:24 <monochrom> I have a cunning plan! * should be called ValuableType :)
15:03:40 <MarcelineVQ> IType, that won't be confusing :>
15:03:48 <sproingie> Thingie
15:04:14 <jadrian> monochrom: could actually work... maybe shorter like ValType or VType
15:04:17 <monochrom> No no no ValueableType is best because "X :: ValueType" iff "X has values"!
15:04:33 <jadrian> monochrom: there's Void though :P
15:04:44 <sproingie> or just phantom types
15:04:54 <jadrian> I guess we have undefined still
15:04:58 <Eduard_Munteanu> We already call * inhabited types.
15:05:10 <ystael> monochrom: you could follow Coq and call it `Set`, that wouldn't cause confusion at all
15:05:12 <lyxia> Sonolin: what would you do on an empty list
15:05:14 <sproingie> InhabitedOrBottom
15:05:42 <monochrom> IType would be a nice shorthand for "inhabited type" but it now sounds too close to iPhone and iTunes.
15:06:02 <MarcelineVQ> and peopel might come from java or C# and ask why IType and Constraint are different
15:06:44 <sproingie> certainly the C# folks would be confused
15:07:09 <Sonolin> lyxia that example is a little contrived
15:07:28 <Sonolin> but I was just wondering in general (i.e. if there's an "or" I can stick in the kinds)
15:07:43 <adw1n> How do I do 'throw TypeError "1234"' without getting 'Not in scope: data constructor ‘TypeError’' error?
15:08:03 <lyxia> Sonolin: I'm still not sure what you mean, but things like this are possible https://dpaste.de/MmCH
15:08:25 <lyxia> it's not very practical though, as it throws away some type information
15:08:55 <Sonolin> hmm interesting
15:09:55 <MarcelineVQ> adw1n: import it from Control.Exception
15:10:01 <Sonolin> ah yea that makes sense, that's essentially what you're doing (i.e. throwing away the information when you use Head or Tail)
15:11:08 <adw1n> MarcelineVQ:  Module ‘Control.Exception’ does not export ‘TypeError’
15:11:14 <sproingie> adw1n: TypeError from GHC.TypeLits or something else?  the former you can't use at runtime (that's the point, it's a type level thing)
15:11:48 <MarcelineVQ> in that case your base is old, it TypeError is exposed in Control.Exception in base 4.9 or higher
15:13:33 <lyxia> you're not supposed to be throwing TypeError anyway
15:14:19 <adw1n> where is the Exception type defined? I'm trying to do 'TestCase (assertRaises "" (Exception "Invalid board state") (evaluate (myFunction)) )'. I raise the error simply by error "Invalid board state" and I have no idea how to check that the error has been raised.
15:14:42 <sproingie> catch it
15:15:08 <adw1n> https://pastebin.com/aCBfHh98
15:15:29 <adw1n> If only I knew how to import the 'Exception' type... Not in scope: data constructor ‘Exception’
15:15:33 <lyxia> Exception is not a type, it's a type class
15:15:34 <EvanR> @hoogle [(a,b)] -> ([a],[b])
15:15:35 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
15:15:35 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
15:15:35 <lambdabot> GHC.OldList unzip :: [(a, b)] -> ([a], [b])
15:15:36 <MarcelineVQ> adw1n: here's a popular little primer on exceptions http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
15:15:57 <jadrian> did anyone ever suggest named class instances?  so instead of "instance Num n => Monoid (Sum n) where" we'd write e.g. "instance Sum of Num n => Monoid n where"   and use it as "Sum.mempty"  
15:16:29 <EvanR> idris and agda work like that, and instance is a record
15:16:35 <EvanR> an instance*
15:16:44 <sproingie> jadrian: that'd be awful nice, it would solve the import problem
15:17:04 <EvanR> but im not sure how free use of records as instances 
15:17:11 <jadrian> EvanR: didn't know, only messed around a bit with Agda
15:17:13 <EvanR> jives with the instance resolution protocol
15:17:33 <EvanR> haskell really wants you to have a single unique instance for a type, if any
15:17:55 <lyxia> adw1n: "error" throws an exception of type "ErrorCall", but this is going to be difficult to match exactly on GHC 8 and above.
15:18:15 <EvanR> at least in idris, fumbling with instance records gets painful fast
15:18:19 <sproingie> sure, but if they had names, you could choose to not import them
15:18:20 <jadrian> sproingie: I was just thinking of all the wrapping/unwrapping... what is the import problem?
15:18:56 <sproingie> jadrian: you can't choose to not import instances defined in a module, they're always imported
15:19:37 <sproingie> so if two modules define orphan instances, boom
15:19:47 <jadrian> sproingie: ah yes of course, true
15:20:26 <dmwit> The usual objection here is that this makes types like `Set` much more difficult. It is sort of hard-wired into, say, `union`, that the same `Ord` instance was used to construct both arguments.
15:20:45 <dmwit> (And that the `Ord` instance that should be used for the result is the same as both.)
15:20:46 <adw1n> lyxia: thanks a lot - using the ErrorCall solved the problem for me (TestCase (assertRaises "" (ErrorCall "Invalid board state") ...)
15:21:40 <lyxia> adw1n: it looks like you're using testpack, which is deprecated
15:23:05 <dmwit> That said, if you want to experiment with that style, there's nothing stopping you from doing it. Just `data Monoid a = Monoid { mempty :: a, mappend :: a -> a -> a }` and you can have explicit instance terms. e.g. `first :: Monoid (Maybe a); liftedSemi :: Semigroup a -> Monoid (Maybe a)`.
15:23:48 <dmwit> Where before you would write `foo :: Monoid a => ...` now you write `foo :: Monoid a -> ...` and explicitly build the dictionary.
15:24:30 <monochrom> You can emulate named instances by multiple parameter type class and lack of fundep.
15:24:39 <dmwit> You can even hook back into the existing instance resolution mechanism when you realize why that sucks by defining, e.g. `instance Default (Monoid (Maybe a))` and using `def` for all your dictionary arguments except the ones you want to explicitly choose.
15:25:20 <monochrom> class MyEq c a where myeq :: p c -> a -> a -> Bool
15:25:48 <jadrian> monochrom: true but only for my newly defined classes that adopt that style
15:26:55 <adw1n> lyxia: I've used it because the HUnit was missing the 'assertRaises' functionality.
15:28:51 * monochrom grins evilly. A cunning plan is taking shape!
15:29:59 <sproingie> dmwit: make that first arg implicit and you're writing scala in haskell ;)
15:31:37 <EvanR> the more i learn about scala features the more scared i am of having to use it
15:31:59 <dmwit> monochrom: \thoughtbubble{instance MyEq () a => Eq a where ...}
15:33:38 <monochrom> Nice, () is a cool way to say "default"
15:34:26 <dmwit> (==) = myeq [()] -- looks bizarre
15:36:00 <dmwit> > [(    {- reverse idiom brackets -}    )]
15:36:02 <lambdabot>  [()]
15:36:12 <sproingie> scala's nice, the type language does get awful noisy tho
15:38:10 <maerwald> scala is horrible, they couldn't decide what the language should be so they added weird features after feature to the point where you have 20 ways to define an enum and all are weird
15:38:24 <Tuplanolla> Sounds like C++.
15:38:38 <ij> What does cabal2nix's "--shell" do?
15:38:57 <sproingie> ghc isn't exactly lean and mean unless you mean core
15:39:09 <lyxia> (==) = myeq (launchMissiles :: IO ())
15:41:15 <sproingie> standard way to define an enum in scala is case classes, been that way from the start
15:42:54 <maerwald> Tuplanolla: yep, it doesn't feel designed, it just grew over time
15:44:51 <geekosaur> ij: it creates a default shell.nix file, see http://nixos.org/nixpkgs/manual/#how-to-create-ad-hoc-environments-for-nix-shell
15:46:08 <sproingie> maerwald: dotty is basically scala 3.0, they're putting it on more principled footing.  you might not agree with some of odersky's choices of course.
15:48:43 <maerwald> sproingie: I don't see a point in scala, even functionally it's really not interesting
15:49:20 <sproingie> maerwald: minds work better when open
15:49:27 <maerwald> ?
15:49:35 <EvanR> java libs
15:49:38 <sproingie> never mind.  no point.
15:49:58 <zachk> how do I switch windows with irssi? (which hotke(s)?)
15:50:38 <sproingie> zachk: for windows 1-10, you can use alt-#
15:50:46 <sproingie> otherwise /win #
15:51:05 <glguy> The merits of scala, C++, etc are off topic on #haskell
15:51:29 <EvanR> also ESC then Number on irssi in case ALT is not working
15:51:51 <zachk> thank you
15:53:00 <sproingie> most terminals have alt send an esc-prefix.  some aren't even able to do the high-bit trick anymore.
15:53:47 <sproingie> (looking at you Terminal.app)
15:55:12 <n_blownapart> hi anyone use spacemacs for haskell 
15:55:15 <n_blownapart> ?
15:55:28 <ij> geekosaur, ah, cool
15:58:56 <Koterpillar> n_blownapart: sure
15:59:16 <sproingie> n_blownapart: might want to just ask your question.  possibly check out the spacemacs channel on gitter too
16:00:12 <n_blownapart> hey Koterpillar thanks should I use the Evil vim style or classic emacs to learn Haskell AND emacs /
16:00:14 <n_blownapart> ?
16:00:37 <Koterpillar> matter of opinion
16:00:41 <sproingie> use evil if you prefer vim, otherwise regular.  should be fully functional either way.
16:02:18 <n_blownapart> sproingie: thanks both of you Koterpillar  . to elaborate, I was learning scheme and a professor said to learn emacs cold for scheme. So should I go with emacs classic mode ( I have some experience only with drracket for scheme and Atom for introductory haskell stuff) 
16:02:41 <zachk> why is #haskell-blah requiring ssl connection?
16:03:35 <n_blownapart> another mention has been intero on emacs
16:03:37 <glguy> That'd be a question to ask inside #haskell-blah
16:03:43 <ski> why is #haskell-offtopic not requiring ssl connection?
16:04:08 <sproingie> i use intero myself, works great.  and yes, i'd recommend emacs for scheme, whether you use evil or not is up to you
16:04:39 <n_blownapart> excellent thanks sproingie Koterpillar
16:04:49 <sproingie> for scheme, i'd recommend installing geiser
16:05:12 <n_blownapart> oh yeah heard of that . that's an emacs plugin?
16:05:56 <sproingie> it's a package.  add the melpa repo and you can find it.  http://melpa.milkbox.net/#/getting-started
16:06:31 <ski> (if you're using MIT Scheme, then there's Edwin, an emacs written in Scheme, integrated with it. has a few other modes like mail/news,&c. iiuc)
16:06:32 <sproingie> and if you need any more info on that, there's #emacs
16:06:38 * hackage gnss-converters 0.2.9 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.2.9 (markfine)
16:06:46 <n_blownapart> thanks
16:07:59 <sproingie> spacemacs likely already has melpa in the repo list.  you'd have to ask the spacemacs folks, i run vanilla
16:08:33 <sproingie> oop meant to pm.  enough OT babble from me :)
16:16:39 * hackage hnormalise 0.3.1.0 - Log message normalisation tool producing structured JSON messages  https://hackage.haskell.org/package/hnormalise-0.3.1.0 (AndyGeorges)
16:16:41 <Sonolin> ok new question
16:16:58 <Sonolin> why does `:k '[JSON, Maybe Int]` result in `[*]`?
16:17:11 <Sonolin> while `:k 'JSON` results in `'JSON :: JSON`
16:19:18 <geekosaur> kind inference
16:19:43 <geekosaur> the second, it can infer a more restrictive kind; the first, the only kind containing both types is *
16:20:33 <exio4> Sonolin: 'JSON is different to JSON
16:20:45 <Sonolin> ah ok I think I'm getting it geekosaur
16:21:01 <exio4> geekosaur: eh, I don't think it's that
16:21:06 <Sonolin> exio4 I know I'm using it to try to figure out DataKinds & PolyKinds
16:21:29 <exio4> Sonolin: what is the kind of '['JSON]?
16:22:03 <Sonolin> umm no idea, haven't gotten that far yet
16:23:14 <Sonolin> oh ok I think I get what you're inferring exio4
16:23:21 <Sonolin> since '[JSON] isn't using the 'JSON kind
16:23:37 <Sonolin> ah and :k JSON is *
16:23:42 <exio4> Sonolin: exactly! 
16:23:43 <Sonolin> so '[JSON] would be :: [*]
16:23:49 <Sonolin> thanks :)
16:24:31 <exio4> it could be easier if they had different names, heh 
16:24:40 <Sonolin> lol, yea I think so..
16:25:00 <Sonolin> I feel like not having a keyword like "kind" is a little bit of an oversight
16:27:18 <sproingie> it's good to be conservative about new keywords
16:27:48 <Sonolin> yea, but it sure makes it hard for a newcomer to approach the kind system IMO
16:29:01 <sproingie> probably not the biggest barrier tho
16:30:08 <exio4> the kind system is a messy thing on its own, keywords won't magically make it less messy :P
16:58:37 <muyfine> hi all! I'm trying to compose prisms together and having some trouble
16:58:52 <muyfine> is this the best way to compose them?
16:58:58 <muyfine> `f1 a = preview _1 a >>= preview _1 >>= preview _1`
16:59:54 <muyfine> and I'm trying to get something point free
17:03:28 <lyxia> :t \a -> preview (_1 . _1 . _1) a  -- more dots look more point free
17:03:30 <lambdabot> (Field1 a b b2 b2, Field1 a1 b1 a b, Field1 s s a1 b1) => s -> Maybe b2
17:07:50 <muyfine> oh nice!
17:07:57 <muyfine> thanks lyxia !!!
17:08:38 <lyxia> don't forget to eta-reduce
17:09:41 <Guest38510> Hi, is there a type class that is like a functor, but for higher kinded type? Like this `(m a -> n a) -> f m a -> f n a`
17:10:12 <lyxia> https://hackage.haskell.org/package/mmorph-1.1.0/docs/Control-Monad-Morph.html
17:12:18 <Guest38510> thanks! Why is 'm' a monad and not 'n' in the hoist function?
17:14:07 <c_wraith> Guest38510: That's an excellent question.  I can't see a single reason for m to have that constraint
17:14:24 <Clint> :t hoist
17:14:25 <lambdabot> error: Variable not in scope: hoist
17:14:28 * Clint sniffs.
17:15:05 <lyxia> The package is about monad morphisms
17:15:55 <c_wraith> Oh, I can see one reason for it.  If they discovered most instances require m to be a monad, you either put that constraint on hoist, or you have to make it a MPTC
17:16:25 <c_wraith> because there's no way to add constraints to m with the existing class definition
17:16:38 <Guest38510> mptc?
17:16:48 <andromeda-galaxy> multi parameter type class
17:19:30 <Guest38510> yeah that make sense, thanks! :)
17:24:26 <EvanR> Sonolin: would be even nicer if kinds didnt exist!
17:24:35 <EvanR> and it was just more Types
17:24:55 <thmannnnn> How can I represent types in template haskell? For instance runQ [d| data X = X { f1 :: String }|] gives me [DataD [] X_0 [] Nothing [RecC X_1 [(f1_2,Bang NoSourceUnpackedness NoSourceStrictness,ConT GHC.Base.String)]] []]    How do I represent GHC.Base.String in my TH code?
17:27:40 <thmannnnn> I essentially want to be able to generate a record with different names/types. I'm stuck on how to represent the type. I tried putting GHC.Base.String there but it didn't work
17:27:40 <Sonolin> EvanR that... would work well with the burrito analogy ;)
17:28:38 <EvanR> grothendieck burritos
17:30:40 <Cale> thmannnnn: ''String
17:30:59 <thang1> aka the grothendieck double prime type
17:31:10 <Cale> lol
17:31:40 <ski> c_wraith : looks like no instance in there requires anything of `m'
17:32:21 <c_wraith> ski: well then, it's a mystery.
17:32:58 <Cale> thmannnnn: See https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#th-syntax
17:33:20 <Cale> If you scroll down a little from there, you'll see all the various sorts of quotation that TH supports.
17:33:43 <ski> .. apparently `embed' has a `Monad' constraint on `n' instead .. which is actually used by instances there, thought `Functor' would be enough
17:54:03 <thmannnnn> Cale: Thanks!
18:03:39 * hackage sbp 2.2.3 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-2.2.3 (markfine)
18:09:17 <Lokathor> Map Char [V2 GLfloat]
18:09:37 <Lokathor> this should be a map from Char to 6-tuple, but writing out a 6-tuple's type is just horrible
18:09:42 <Lokathor> alas
18:10:02 <spoonm> hey, I'm using what little I know of haskell to write a few things, can you tell me what cool features I'm missing on here? http://ix.io/v54
18:10:50 <spoonm> by that I mean "what's not there that I could've used to simplify/optimize my job?", I want to learn more
18:11:06 <Lokathor> spoonm, for not knowing much about Haskell, you sure seem to have got yourself quite the fancy code bit
18:11:45 <Lokathor> if you would like, "mod a b" can be rewritten as "a `mod` b" using backticks like that to have it be infix. Some of the time it reads better that way
18:11:47 <spoonm> Lokathor: lol really? I read maybe 4 pages or so of "learn you a haskell for great good" long ago
18:12:19 <spoonm> any other contact with haskell is due to configuring/extending xmonad, which I've been told usually results in very ugly, improper haskell
18:12:54 <Lokathor> I'm not sure what improper haskell is, but if you're not using unsafePerformIO or unsafeCoerce you're probably okay
18:13:29 <spoonm> well, xmonad config examples include a lot of $, and the same people who told me that really dislike do blocks
18:14:15 <spoonm> as to `mod`: I was using it that way, but I wanted to save two columns to keep myself from going over the 80 limit, which I wound up doing anyways
18:15:22 <Lokathor> I like to stay under 80 for comments, which my editor re-wraps for me, and for code itself I drift out to 100 or so as needs demand
18:16:31 <Lokathor> putStrLn $ "WARNING: Requested: " ++ show (fbWidth,fbHeight) ++ ", Actual:" ++ show (fbx,fby))
18:16:32 <spoonm> I try to stay under 80 everywhere, I think it helps make things simple
18:16:50 <Lokathor> not really a good way to break up that putStrLn I think
18:17:09 <spoonm> :(
18:18:18 <Lokathor> you could do it after the second ++, if you really wanted to
18:18:59 <Lokathor> I've got a widescreen monitor, and a standard definition monitor. Even on the SD monitor my editor has over 100 columns in it with the sidebar open and everything
18:19:33 <spoonm> yeah, I'd probably do something like Python: http://ix.io/v59
18:19:46 <spoonm> granted in a 8print() call that's not how it'd be done lol
18:20:08 <spoonm> but in case I needed to do string concat elsewhere, that's probably how I'd go about it if 8str.format() was awkward
18:20:33 <Lokathor> oddly, i was lamenting the lack of a python2 style print ability in Haskell just earlier today
18:21:02 <drewbert> python's print is sooooooo nice
18:21:27 <spoonm> as in 8print a b c ... calling 8show for all arguments or...?
18:21:32 <spoonm> drewbert: it is!
18:21:54 <Lokathor> spoonm, yeah something like that. One catch: the show instance for String isn't actually helpful at printing out a string, because it's not identity
18:22:17 <spoonm> speaking of which, I think I looked this up when I was reading that haskell book, but are there variadic functions in Haskell?
18:22:20 <Lokathor> instead, it's what you'd type into a Haskell file to get that string value, which means that it has " around it and escapse " within it and so on
18:22:38 <Lokathor> spoonm, there are not as far as I've ever heard
18:22:54 <Lokathor> though, with enough GHC extensions i'm sure anything might be possible
18:23:36 <ski> spoonm : if i wanted to conserve horizontal space, i'd pull back the definitions under `where' to the same column as it, possibly change the `where' into being indented only two spaces, possibly define a `divides' function to avoid repeating the `== 0' part. then perhaps pull the list comprehension down to (two spaced indented) on the next line
18:23:38 <spoonm> I imagined it'd be one of the first things to pop up, but I come from very imperative C, I wouldn't dare dabble with functional programming purity or anything
18:24:13 <alexknvl> Can someone explain how liftControl works to me? I am trying to implement MonadControlIO for ReaderT manually
18:24:16 <alexknvl> And failing
18:24:17 <Lokathor> Haskell would be better if there was some sort of quasiquoter that could take a list and python print them, but I haven't the foggiest how one would write that. Perhaps someday
18:24:20 <spoonm> ski: I was thinking of renaming 8tuples, too, but dunno, it looks ok
18:24:53 <spoonm> but hey, thanks, I'll do that
18:25:16 <Lokathor> spoonm, in fact, you can even put the where on the same line
18:25:18 * ski often tries to keep pages at most sixtysix lines, preferably more than forty lines
18:25:28 <Lokathor> main = mapM_ print tuples where
18:25:36 <spoonm> that's a thing? I didn't know
18:26:11 <Lokathor> where is a keyword so it won't be eaten up as an expression argument
18:26:20 <ski> spoonm : you could also give a name to `spacing + iborder + border' in the list comprehension, using `let'
18:27:33 * ski personally prefers `where' on a separate line, occasionally continuing the remainder on the rest of the same line, if it's only one line
18:27:59 <spoonm> ski: oh, initially I thought I could use the where to bind `fwid - 2*hgap' to `uwid', but I realized it doesn't "see the inside" of the list comprehension
18:28:15 <spoonm> didn't know how `let' could work in the list comprehension
18:28:39 <ski> @undo [() | let]
18:28:39 <lambdabot> let { } in [()]
18:29:52 <spoonm> I'll be back in a bit, hopefully making you proud
18:30:13 <Lokathor> so if i want to have String errors, is "instance Exception [Char]" considered kosher? or should i just use error? or should i really really make my own error type and use throwIO with it?
18:30:51 <Lokathor> note: in this situation the error case is 99% likely to be unrecoverable from within the program anyway, without the user making a change to their system and trying it again
18:31:03 <ski> spoonm : you can kludge variadics with type classes .. `printf' uses that. it's not that pretty, though
18:31:53 <ski> i think there's one or two other ways to (at least sometimes) do it, as well. involving using polymorphic combinators of some sort, and possibly (internally) continuations
18:31:59 <EvanR> Lokathor: make your own error type, its not that hard
18:32:05 * ski doesn't recall details offhand
18:32:30 <lyxia> spoonm: http://lpaste.net/355846 shorter and less readable!
18:32:57 <EvanR> Lokathor: instance Exception String probably doesnt work without extensions and would be bad form i say
18:33:02 <Lokathor> EvanR, oh alright, but it's only going on the TODOs
18:33:57 <EvanR> data LokathorsError = LokathorsError String deriving (Show,Typeable); instance Exception LokatheorsError; myError = LokathorsError
18:34:12 <EvanR> but spelled right
18:34:20 <Lokathor> what's that last line?
18:34:29 <EvanR> the equivalent of userError
18:34:34 <EvanR> but you dont really need it
18:35:25 <EvanR> :t userError
18:35:27 <lambdabot> String -> IOError
18:35:27 <ski> spoonm : oh, it's also possible to say `(fwid,fhei) = (1920,1080)' and `(cwid,chei) = (7,14)', should you prefer that
18:35:55 <EvanR> throwIO . userError is also an option but the name is horrible
18:36:20 <EvanR> if a user saw "User Error..." they would probably resent it!
18:38:18 <ski> Lokathor,spoonm : sometimes i go like `(putStrLn . concat) ["WARNING: Requested: ",show (fbWidth,fbHeight),", Actual:",show (fbx,fby)]'
18:38:30 <ski> spoonm : using `printf' :
18:38:41 <ski> > let (fbWidth,fbHeight) = (80,25); (fbx,fby) = (8,40) in printf "WARNING: Requested: (%d,%d), Actual:(%d,%d)" fbWidth fbHeight fbx fby :: String
18:38:43 <lambdabot>  "WARNING: Requested: (80,25), Actual:(8,40)"
18:39:59 <ski> (you could use `IO ()' instead, to have it automatically output to `stdout'. most commonly (but not in interactive queries like this), the context would determine the return type, so that the type ascription wouldn't be needed)
18:40:24 <Lokathor> printf might ease my senses a bit I suppose
18:45:38 * ski isn't that fond of `printf'. would often rather name each "spliced" expression, and put it "inline" with `++' or `concat'
18:46:16 <ski> ("string interpolation" aka quasi-quotation would be acceptable as well)
18:46:39 * hackage versions 3.0.2 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.0.2 (fosskers)
18:47:13 <Lokathor> well within the greater function it looks like this https://gist.github.com/Lokathor/d69260f765a2bc735802b6771960fb75
18:51:56 <andromeda-galaxy> ski: re polyvariadics, are you thinking of anything other than oleg's set of techniques (http://okmij.org/ftp/Haskell/polyvariadic.html)? I think those are all typeclass based, if you know non-typeclass-based ones I'd be interested in that...
18:53:44 <spoonm> I thought the lack of parentheses was the problem, but ghc is asking me if I "intended to use TemplateHaskell", what am I doing wrong with `$'? http://ix.io/v5l
18:54:13 <spoonm> (@@ is meant to work like default divides notation, a | b => a divides b)
18:54:38 <lyxia> you can't mix infix operators like this
18:55:00 <andromeda-galaxy> spoonm: dollars is an infix operator, you can't mix it with another
18:55:18 <andromeda-galaxy> $() is also the syntax for TH splices, so ghc assumes that $ = TH whenever the operator doesn't parse right
18:55:21 <ski> andromeda-galaxy : i think there was something that was used in O'Caml ?
18:55:24 <lyxia> you can set the precedence of your custom operator
18:55:24 <spoonm> oj
18:55:40 <spoonm> oh*, thanks andromeda-galaxy 
18:55:45 <andromeda-galaxy> like lyxia said, the precedence setting is probably the way to do this
18:55:47 <andromeda-galaxy> np
18:56:07 <spoonm> really? that's a thing? how do I do it?
18:56:28 <andromeda-galaxy> infixr <levuel> opp
18:56:30 <andromeda-galaxy> *op
18:56:40 <ski>   d `divides` n = mod n d == 0  -- how i'd probably define it, spoonm
18:56:55 <ski> or using  n `mod` d  in there
18:58:07 <andromeda-galaxy> spoonm: http://zvon.org/other/haskell/Outputsyntax/fixityQdeclaration_reference.html
18:58:33 <ski>   infix 5 `divides`,@@
19:00:33 <andromeda-galaxy> ski: pointfree! ((.).(.)) (==0) mod
19:00:44 <andromeda-galaxy> (also am I the only one that wishes that you could put arbitrary exprs inside backticks?)
19:01:11 <MarcelineVQ> andromeda-galaxy: nay
19:01:36 <andromeda-galaxy> MarcelineVQ: on which?
19:02:53 <MarcelineVQ> the latest
19:05:17 <andromeda-galaxy> hmm, I guess there is https://wiki.haskell.org/Infix_expressions at least
19:05:46 <clamchowder> help: ghci complains "fail to load Data.List.Split" - what shall I do?
19:06:14 <lyxia> install split
19:07:29 <clamchowder> lyxia: thanks that works
19:08:01 <erisco> seemed strange to me why you couldn't use arbitrary expressions in backticks
19:08:29 <erisco> there is an awkwardness with nested backticks though
19:09:10 <andromeda-galaxy> hm, you can just require that if there are nested backtics, they are inside parentheses
19:09:22 <andromeda-galaxy> that way it's readable for the vast majority of cases and also unambiguous
19:10:30 <Lokathor> so, will a Vector.Storable of lists store all the values directly in line? or since it's a list you just get the heads of the lists in line?
19:12:19 <Lokathor> oh i take it all back
19:12:46 <Lokathor> i guess list isn't storable so you can't /actually/ put a list into a Vector.Storable, even though you can declare a vector of such a t ype
19:13:32 <clamchowder> how does "a $ b <$> c <$> d" resolve? is it a $ (b <$> (c <$> d))?
19:13:53 <andromeda-galaxy> @t \a b c d -> a $ b <$> c <$> d
19:13:54 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
19:13:59 <andromeda-galaxy> :t \a b c d -> a $ b <$> c <$> d
19:14:01 <lambdabot> Functor f => (f b -> t) -> (a1 -> b) -> (a -> a1) -> f a -> t
19:14:36 <Lokathor> infixl 4 <$>
19:14:36 <andromeda-galaxy> a $ (b <$> (c <$> d)) yes
19:14:56 <andromeda-galaxy> clamchowder: ^
19:15:02 <clamchowder> andromeda-galaxy: thanks.
19:18:58 <andromeda-galaxy> clamchowder, Lokathor: wait no I'm confused. the types make me think tha it is doing b <$> (c <$> d) but infixl should parse as (b <$> c) <$> d, right?
19:19:33 <andromeda-galaxy> *now I'm confused
19:20:12 <Lokathor> and (,,,) aren't storable either :/
19:23:01 <lyxia> that's odd
19:23:23 <andromeda-galaxy> clamchowder: oops I may have gotten that backwards wrt the <$> sorry, hang on one sec
19:23:51 <lyxia> <$> is associative
19:23:53 <andromeda-galaxy> oh if it is parsed as (a <$> b) <$> c then that fmaps the a argument over the -> in b so it composes them.
19:24:32 <andromeda-galaxy> so a <$> b <$> c = (a <$> b) <$> c = (a . b) <$> c?
19:24:33 <c_wraith> All the applicative-oriented operators seem to be infixl 4
19:25:57 <Lokathor> ah, but my good wraith, <$> is clearly Functor oriented, entirely different rules might apply :P
19:26:13 <andromeda-galaxy> Lokathor: but the infix declaration is indeed infixl 4
19:26:16 <andromeda-galaxy> :i <$>
19:26:20 <lyxia> Lokathor: https://hackage.haskell.org/package/storable-tuple
19:26:24 <Lokathor> i know I'm the one who said that
19:26:28 <andromeda-galaxy> oh does lambdabot not do info?
19:26:31 <andromeda-galaxy> oops nvm, sorry
19:26:44 <Lokathor> :3c
19:26:52 <Lokathor> lyxia, ho! mia diino!
19:27:30 <MarcelineVQ> mia hoomon, grr
19:27:55 <Lokathor> lyxia, so do I have to call storeQuadruple?
19:28:06 <Lokathor> or do I just import the module and it'll find the instance?
19:29:15 <lyxia> Lokathor: there are instances yes
19:33:18 <clamchowder> andromeda-galaxy: sorry I left. I think I'll just do brackets for now
19:33:22 <ski> andromeda-galaxy : .. or `((0 ==) .) . mod', aka `(0 ==) .: mod' :)
19:36:10 <spoonm> ski: I was gonna do `divides`, but I thought it'd look best if I used `a | b', like real maths, but sadly | is reserved for other things
19:36:59 <lyxia> real maths also knows to use words
19:38:32 <Rotaerk> I'm always disappointed when my haskell code compiles and doesn't run correctly
19:38:45 <Rotaerk> with C# I'm pleasantly surprised when it does...
19:38:53 <andromeda-galaxy> ski: ah yes, I always forget the right way to infix that
19:39:02 <ski> lyxia : not that often .. considering
19:40:21 <ski> (i intended `.:' to have the same number of dots as `(.) . (.)', and have the same number of characters as is "passed on" to the right operand)
19:41:01 <clamchowder> is there a variant of foldl that use the head of the list as the base and iterate over the tail of the list?
19:41:11 <lyxia> foldl1
19:41:30 <andromeda-galaxy> (.: isn't Prelude-ified though, unfortunately)
19:41:50 <MarcelineVQ> I'm okay with Prelude not being jammed up withe every tool in the box
19:42:30 <clamchowder> lyxia: thanks.
19:43:05 <EvanR> im not id like exactly each tool i use to be in prelude! ;)
19:43:25 <MarcelineVQ> :> I admit that's a bit of hyperbole, .: isn't a rare thing to need
19:43:36 <EvanR> <> :(
19:43:45 <EvanR> when, forever, 
19:43:47 <dmwit> :t \f g x -> f <$> g <$> x
19:43:49 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
19:43:52 <j-em> Hello - I'm trying to use interface with git from haskell with this lib https://hackage.haskell.org/package/gitlib-3.1.1/docs/Git-Types.html but i'm having a bit of a hard time figuring how to use it. Any pointers ?
19:44:16 <dmwit> Ah, the second `(<$>)` forces the first one's `Functor` to be `(a->)`.
19:44:58 <dmwit> j-em: Did you look at the included tutorial?
19:45:06 <j-em> dmwit: it is unfortunately out of date
19:45:15 <dmwit> Okay, bummer.
19:45:16 <j-em> there are multiple references to functions that doesn't exist anymore
19:45:27 <j-em> Pretty sure the only docs are the types
19:45:32 <Lokathor> I'm not even clear when I'd use .:
19:45:35 <dmwit> I suspect if you spend 5-10 minutes with this library, you will be more expert with it than most others in the channel.
19:46:08 <ski> (.. and ditto for `(.::) = (.) . (.) . (.)', &c.)
19:46:22 <dmwit> j-em: Except, perhaps, for johnw. ;-)
19:46:34 <EvanR> Lokathor: unless you want to frighten small children and people who are on the fence about haskell syntax... never
19:46:35 <ski> Lokathor : when you'd otherwise use `(f .) . g' ?
19:47:04 * ski smiles at EvanR
19:47:38 <Lokathor> concat $ map (\(a,b) -> [a,b]) $ zip first second
19:47:51 <Lokathor> this was already too much for my non-haskeller friends to deal with
19:47:51 <EvanR> yeesh
19:47:58 <EvanR> too much $
19:48:07 <dmwit> :t zipWithM
19:48:08 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
19:48:15 <jle`> dmwit: you could say that <$> is commutative
19:48:23 <jle`> er
19:48:24 <dmwit> Lokathor: zipWithM (\a b -> [a,b]) first second -- so much clearer ;-)
19:48:26 <jle`> associative
19:48:54 <jle`> (f <$> g) <$> x = f <$> (g <$> x)
19:48:56 <EvanR> (concat . map (\...) . zip first) second ;)
19:48:57 <dmwit> jle`: Yeah, assuming law-abiding instances. Neat!
19:48:58 <Lokathor> dmwit, but try to explain that version to a beginner who doesn't know Haskell :P
19:49:19 <jle`> dmwit: don't even have to assume that :o
19:49:20 <EvanR> also concatMap at least
19:49:34 <lyxia> > zipWithM (\a b -> [a, b]) [1,2,3] [4,5]
19:49:36 <lambdabot>  [[1,2],[1,5],[4,2],[4,5]]
19:49:43 <dmwit> jle`: I think you do. You have to assume `f <$> (g <$> x) = (f . g) <$> x`, which is a Functor law.
19:49:48 <Lokathor> ew no that's not the right result
19:49:49 <jle`> that wasn't what i meant
19:49:56 <jle`> i meant f <$> (g <$> x) = (f <$> g) <$> x
19:50:01 <jle`> hehe
19:50:22 <Lokathor> > (\first second -> concat $ map (\(a,b) -> [a,b]) $ zip first second) [1,2,3] [4,5,6]
19:50:24 <jle`> oh i suppose you do need to assume it
19:50:25 <lambdabot>  [1,4,2,5,3,6]
19:50:30 <jle`> darn
19:50:33 <dmwit> jle`: I agree that `(f <$> g) <$> x = (f . g) <$> x` without any laws. But I don't agree that `(f <$> g) <$> x = f <$> (g <$> x)` without laws.
19:50:47 <jle`> i see the flaw in my reasoning
19:50:48 <dmwit> Lokathor: Yes, I introduced a bug. =(
19:51:40 <lyxia> Lokathor: map ... $ zip  is  zipWith ...
19:52:18 <j-em> dmwit: I tried understanding by only reading the types and playing with it in a REPL, without much success. :-( 
19:52:26 <dmwit> > concat $ transpose [[1,2,3],[4,5]] -- in case you don't care about the behavior when the list sizes don't match
19:52:28 <lambdabot>  [1,4,2,5,3]
19:53:19 * dmwit lobbies for list sections: `[,] 4 5 == [4,5]`
19:53:30 <Lokathor> sure, sure to everyone, but the very first version was this http://lpaste.net/355851 :P
19:53:46 <MarcelineVQ> :t \first second -> [[x,y] | x <- first | y <- second]
19:53:47 <lambdabot> [t] -> [t] -> [[t]]
19:54:09 <Lokathor> and then going from that to actual combinators while simultaneoutly explaining every bit of syntax and operation involved doesn't lead to the most combinator'd code
19:54:14 <MarcelineVQ> I wish I had more uses for parlistcomps, they look neat
19:54:16 <dmwit> Lokathor: Oh, then `concat . transpose` is a more faithful translation than your `zip`y one, since yours sometimes throws elements away.
19:54:28 <duckqlz> ((.)$(.)) (==) 1 (1+) 0
19:54:45 <Lokathor> throwing elements away was actually a bug :/
19:55:12 <dmwit> Do you mean "not throwing elements away was actually a bug"?
19:55:57 <dmwit> ...or are you agreeing with me?
19:56:15 <Lokathor> i didn't want it to throw elements away
19:56:22 <Lokathor> when i made a version using zip, it did, and that's the bug
19:56:35 <dmwit> Right.
19:57:48 <spoonm> here http://ix.io/v5F
19:57:56 <spoonm> hope you're proud
19:58:33 <spoonm> couldn't get `infixr 5 `divides`' to work with `$', but hey, looks cool this way
20:00:15 <lyxia> spoonm: these `divides` conditions can actually be simplified
20:00:23 <spoonm> lyxia: how?
20:00:53 <spoonm> oh, lemme do the tuple thing too
20:00:54 <ski> spoonm : with the `infix' declaration i suggested, you don't need the four pair of brackets there
20:00:55 <lyxia> cwid `divides` gaps
20:01:05 <lyxia> instead of any one of the two cwid
20:01:17 <ski> spoonm : also, did you see my suggestion about `(fwid,fhei)' ?
20:01:25 <spoonm> ski: yeah, that's what I'm gonna do right now
20:01:33 <spoonm> got distracted, ate dinner and all
20:01:46 <ski> (no need to use `$' here, anywhere that i can see)
20:02:05 <ski> no worry
20:02:07 <lyxia>   cwid `divides` uwid, cwid `divides` 2 * gaps
20:03:09 <spoonm> lyxia: are you implying if `a | b - c', `a | b' and `a | c'?
20:03:25 <ski> lyxia : i don't think that's equivalent
20:03:28 <spoonm> ^
20:03:44 <andromeda-galaxy> lyxia: definitely false. 2 | (5 - 1) but ! 2 | 5 or 2 | 1
20:03:44 <spoonm> it isn't, 3 `divides` (8 - 2), but you can't distribute it
20:04:54 <lyxia> If `a | b - c` and `a | b - 2 * c` ...
20:06:07 <ski> hm, ok, then `a | c', and so `a | b'. you're right
20:06:15 <spoonm> o
20:06:18 <andromeda-galaxy> or ight
20:06:22 <andromeda-galaxy> *o right
20:06:23 * lyxia takes a cookie.
20:06:23 <spoonm> I did not see that
20:06:26 <andromeda-galaxy> sorry
20:07:01 <lyxia> you can also abuse the fact that cwid happens to be odd
20:07:03 <spoonm> 10/10 lyxia, you're my favorite person right now
20:07:17 <spoonm> oh, I'll be changing that around
20:07:42 <ski> lyxia : yeah, but i'd suspect that's more of an accident that might change
20:10:16 <spoonm> http://ix.io/v5L how is it now?
20:10:52 <spoonm> wondering if at this point `let' is actually needed to make it cleaner looking
20:11:48 * ski is still not happy with the brackets around `2*gaps', which requires an `infix' declaration on `divides' to get rid of
20:12:19 <lyxia> you still need chei `divides` (2 * gap)
20:12:20 <ski> spoonm : instead of those three `let's, you can have just one, containing your three (local) definitions (obviously aligned properly with each other)
20:12:30 <spoonm> ski: I'm not happy either, but what do you mean by `infix' declaration? do I have to change it to `(`divides`)' or...?
20:12:36 <ski> add
20:12:37 <spoonm> lyxia: oh, true, didn't see that, thanks
20:12:41 <ski>   infix 5 `divides`
20:12:52 <ski> on the top-level of the file
20:12:54 <spoonm> ski: I thought it was infixr
20:12:59 <spoonm> lemme try that
20:13:05 <lyxia> I'd put 2 or 3
20:13:07 <ski> i see no reason to make `divides' `infixr'
20:13:23 <plugin> I have some code that crashes at runtime with: printf: argument list ended prematurely.  I think it has to do with a storeable-vector's withStartPtr call but I'm not sure how to proceed debugging.  does anyone have any advice?  gist is here: https://gist.github.com/o1lo01ol1o/6744a18c973407facb11aa3f121373d4 
20:13:27 <lyxia> oh + is at 6
20:13:30 <lyxia> nvm
20:13:36 <ski> you're not going to type  d0 `divides` d1 `divides` n  anyway, that's a type error
20:14:08 <EvanR> similar to a < b < c
20:14:17 <ski> `||' is at `2', and `&&' at `3'. i think it makes sense to have it above those
20:14:21 <spoonm> ski: remind me how let would work, do I need {}?
20:14:37 <ski> spoonm : you don't (but you can, if you really want to)
20:14:56 <spoonm> o w8, I see it now, I think
20:14:57 <ski> just align the starts of the individual definitions inside the single `let'
20:15:32 <spoonm> check this baby out http://ix.io/v5M
20:15:35 <ski> if you really wanted to put the definitions on the same line, you'd have to separate them by `;'s
20:15:38 <codygman> I have a template Haskell error and can't figure out what to do, "Expected type: [VarBangTypeQ]; Actual type: Q VarBangTypeQ": https://pastebin.com/wxzEibgN  I don't know how to make a function of type (Q VarBangTypeQ) -> [VarBangTypeQ]
20:17:53 <ski> spoonm : personally, i often prefer aligning the `]' in the same column as the `[' (especially if i might be expected to move around, or add or remove lines inside). but if you think the `]' on a separate line would look lonely here, feel free to ignore this
20:18:11 <ski> this is obviously style and personal taste
20:18:22 <spoonm> ski: I was thinking the same thing, I still don't know what I like the mos
20:18:25 <spoonm> t
20:18:42 <ski> (another such matter is that i prefer `Integral a =>' over `(Integral a) =>')
20:18:50 <lyxia> plugin: try enabling stack traces, see 1.1 https://wiki.haskell.org/Debugging
20:19:06 <codygman_> Leaving on my main account, but still here I'm secondary if anyone has an answer for my TH problem
20:19:23 <spoonm> ski: I wasn't sure leaving the parentheses would work, but I agree with that
20:19:44 <ski> (and ditto for `deriving' clauses with only a single type class, fwiw)
20:20:06 <glguy> codygman_: {-# LANGUAGE TemplateHaskell, QuasiQuotes #-}
20:20:12 <ski> (you need the brackets, when you have multiple constraints/classes, obviously)
20:20:18 <glguy> https://paste.fedoraproject.org/paste/PozZfPgicgZ1Qni9DWP33V5M1UNdIGYhyRLivL9gydE=
20:20:30 <spoonm> ski: ok, that I couldn't follow, what is this "deriving" clause?
20:20:50 <spoonm> do you mean instead I could use idk, Integral -> Integral -> Bool?
20:21:09 <glguy> codygman_: and you probably don't want to use newName for the field name, mkName would be better
20:22:05 <ski> it's when you're making `data' or `newtype' declarations, for defining a new data type. `deriving' allows you to automatically get an implementation for a few fixed type classes (like `Eq',`Ord',`Show',`Read' and a couple more)
20:22:35 <ski> spoonm : no, `Integral -> ...' is a type error. `Integral' is a type class, not a concrete type
20:23:08 <spoonm> huh
20:23:27 <spoonm> ski: I thought you meant I had those in my file
20:23:43 <spoonm> gonna have to read up on that later :/
20:23:44 <codygman_> glguy: thanks! Hm *looks up difference between newName and mkName*
20:26:18 <ski> (what you had in mind was probably something like `(exists a. Integral a *> a) -> (exists a. Integral a *> a) -> Bool' / `forall a b. (Integral a *> a) -> (Integral b *> b) -> Bool' / `forall a b. (Integral a,Integral b) => a -> b -> Bool' .. or perhaps even `forall a. Integral a => a -> a -> Bool' .. but `exists' and `*>' doesn't exist in GHC)
20:26:35 <ski> spoonm : nah, sorry. just a related pet peeve :)
20:27:14 <spoonm> is it bad I only understood loose words?
20:27:45 <spoonm> ski: I have a question, and you might suggest I use monads or something else I don't understand yet, but hear me out
20:28:29 <spoonm> `divides` shouldn't accept a null first argument, but I think `mod' already handles that
20:29:11 <spoonm> suppose it didn't, how could I go about restricting the first argument to non-null integrals? is there a typeclass for it? do I have to do something like Maybe or whatever?
20:29:44 <ski> (only understood loose words from what ? my last comment involving `exists' and `forall' probably is beyond you at the moment. presumably, without you learning a bit more about polymorphism and type classes, it would be hard for me to explain it. you can safely ignore it at this point)
20:30:01 <spoonm> (yeah, that's what I'll do ;-;)
20:30:47 <ski> what do you mean by "a null first argument" ?
20:31:12 <ski> and by "non-null integrals" ?
20:31:34 <spoonm> 0
20:31:51 <Lokathor> https://gist.github.com/Lokathor/e8af714d48da6bbe80307ac8727eb7c1 I have created a thing that I believe to be a rather clean way of building up some texture info
20:32:30 <dmwit> spoonm: Haskell doesn't really have a good way to do that. See also https://stackoverflow.com/q/44068734/791604
20:32:49 <dmwit> (and the linked questions, as well; each adds a fun detail that the others miss, I think)
20:33:51 <ski> > let infix 5 `divides`; d `divides` n = n `mod` d == 0 in 0 `divides` 5  -- unfortunately, at this point,  n `mod` 0  aborts, rather than evaluating to `n', which i think would be the sensible choice
20:33:53 <lambdabot>  *Exception: divide by zero
20:34:30 <ski> if this choice was taken, then  0 `divides` n  would hold exactly when `n' is zero
20:35:03 <spoonm> huh
20:35:05 <dmwit> However, doing this correctly in `divides` should be easy.
20:35:23 <dmwit> Just add clauses `divides 0 0 = True; divides 0 n = False`
20:35:39 <dmwit> or, like, `divides 0 n = n == 0` if you're feeling fancy
20:35:39 <ski> so, from this point of view, i'd prefer it if `divides' accepts zero as left operand as well
20:36:46 <ski> spoonm : but to answer your question, no there's no easy and nice way to express the type consisting of all the values in type, say `Integer', *except* `0'
20:36:46 <spoonm> dmwit: oh, I wasn't talking about actually returning something, but restricting it so that calls to `0 `divides` n' would error out, but of course, I know `mod' already handles it, I just wanted to know how without actually dividing by zero
20:36:56 <spoonm> ski: rip
20:37:08 <ski> there's something called Liquid Haskell, which has some form of dependent types, which could possibly do it
20:37:23 <ski> otherwise i think there's no nice way
20:37:30 <spoonm> rip
20:37:31 <dmwit> ski: You should read my link, too, so you don't waste time repeating the info that other people have already nicely explained. ;-)
20:37:40 <spoonm> reading the link dmwit sent
20:37:50 <ski> partly because if you e.g. subtract a non-zero number from another non-zero number, you could get a zero result
20:38:02 <ski> so it's hard to keep track of such things, across various arithmetic operations
20:38:56 <ski> dmwit : huh ? .. which link ? -- oh, the one i completely didn't notice :)
20:43:23 <ski> spoonm : in *some* cases, it can be worth it to define a new, abstract, data type, that by construction doesn't allow you to make the values that you want to exclude. but it only makes sense to do this when you have a bunch of useful operations which "preserve" (alt. "is closed under") the subset of values you want to consider
20:43:30 <EvanR> "type minus" seems to be such a naively obvious thing to posit, but 
20:43:53 * ski . o O ( "Subtractive logic", Tristan Crolard )
20:46:14 <EvanR> reading
20:50:35 <ski> "Dual-intuitionistic logic" by Igor Urbas, revisited by Rajeev Gore, is probably also related
20:50:57 <ski> however, "The Mysteries of Counting: Euler Characteristic versus Homotopy Cardinality" by John Baez in 2005-07-14 at <http://math.ucr.edu/home/baez/counting/> might be closer to what you had in mind
20:56:48 <Sh4rPEYE> Hello. I have several small files and I want to use BasePrelude in them. Can I somehow "wrap them up" in one project with dependencies even though they are standalone?
20:57:08 * hackage haiji 0.2.1.0 - A typed template engine, subset of jinja2  https://hackage.haskell.org/package/haiji-0.2.1.0 (NoriyukiOhkawa)
20:59:17 <Lokathor> Sh4rPEYE, that should be possible using a normal project setup. Have you used the stack or cabal programs to manage a project before?
21:00:03 <Sh4rPEYE> No. I've been working with small files (-> didn't need a project) and used cabal just to download the packages and use them globally.
21:00:58 <Lokathor> ah ha, well if you're already using cabal then "cabal init"
21:01:10 <Lokathor> it will guide you through the cabal file making process
21:01:35 <Lokathor> i think it makes it in the current directory of wherever you are
21:02:49 <codygman> Can you use Control.Monad.Catch.MonadCatch like you used to be able to use MonadCatchIO with newtype deriving? Attempting to update this library to use exceptions package: https://github.com/the-real-blackh/cassandra-cql/blob/master/Database/Cassandra/CQL.hs#L1874
21:03:17 <ski> EvanR : there were also two other papers about negative and rational types that i found somewhere, but i can't seem to find them atm. (i have a print-out of them, i think, but not here)
21:06:08 <EvanR> mysteries of counting looks wild
21:08:04 <fresheyeball> how can I write a show instance for this type?
21:08:06 <fresheyeball> https://zerobin.net/?bc12316ed42e449e#0Mg4UkqFwYgCeJ2JtZTox9c7+VJpXJ6dRqsCNy6ak80=
21:08:56 <jle`> fresheyeball: are you asking about best practices
21:09:05 <jle`> or like about how to implement show
21:09:18 <fresheyeball> jle`: just how to do it
21:09:28 <fresheyeball> I can't figure out how to get a show for `Sing k`
21:09:56 <fresheyeball> https://zerobin.net/?76f8519af83e4167#dS5lduzepOTGaMKFkLrNp26IdYcloNejIhT/Vt32AOA=
21:09:59 <jle`> Sing (a :: k) is a different type for every kind k
21:10:01 <fresheyeball> jle`: here is more context
21:10:18 <jle`> k is kind of a misleading variable name here too
21:10:48 <jle`> doesn't Sing (a :: AreaName) have a Show instance for every a?
21:10:58 <jle`> if not you can just use fromSing and show the AreaName you get
21:11:15 <fresheyeball> jle`: I am still new to singletons
21:11:18 <fresheyeball> let me try that
21:11:35 <jle`> but your Sing (a :: AreaName) should have a Show instance, I believe
21:11:49 <fresheyeball> yeah fromSing works
21:11:51 <fresheyeball> ok
21:11:56 <fresheyeball> so now I am somewhat confused
21:12:08 <fresheyeball> what is the difference between `Sing k` and `DemoteRep k`?
21:12:34 <fresheyeball> I thought `Sing k` was the term level rep, what is DemoteRep then?
21:12:41 <jle`> careful about using the type variables there
21:12:48 <jle`> you are talking about Sing (a :: k) and DemoteRep k
21:13:35 <jle`> you have `SStudy :: Sing 'Study`
21:13:51 <fresheyeball> hmm ok
21:13:53 <jle`> SStudy is a term level rep that has the type Sing 'Study, and is the only value with that type
21:14:00 <jle`> DemoteRep is a type family/associated type
21:14:07 <fresheyeball> ok
21:14:09 <fresheyeball> ok
21:14:35 <fresheyeball> so why can't I show SStudy?
21:14:49 <jle`> i believe it should have a Show instance
21:14:57 <fresheyeball> I'm confused about the difference between (a :: k) and k
21:15:30 <jle`> a is a type variable whose *kind* is k
21:15:35 <jle`> and k is the kind we are talking about
21:15:52 <jle`> so you have values of type Sing 'Study
21:16:08 <jle`> and values of type DemoteRep AreaName
21:16:32 <jle`> or to use a more interesting example, you have values of type Sing 'True, Sing 'False
21:16:48 <jle`> and you also have values of type DemoteRep Bool.  (type DemoteRep Bool = Bool)
21:17:18 <jle`> so you'd have values of type `Sing (a :: Bool)`, which are STrue :: Sing 'True and SFalse :: Sing 'False
21:17:28 <fresheyeball> so fromSing
21:17:33 <fresheyeball> is kind of abstractly
21:17:38 <jle`> DemoteRep is sort of a "hack" so you can associate the *kind* Bool with the *type* Bool
21:17:43 <fresheyeball> (s :: k) -> k
21:17:46 <jle`> fromSing :: Sing 'True -> Bool, and fromSing :: Sing 'False -> Bool
21:17:58 <fresheyeball> gotcha
21:18:00 <fresheyeball> ok
21:18:05 <fresheyeball> jle`: I think I get it now
21:18:05 <jle`> in your case it's forall (a :: AreaName). Sing a -> AreaName
21:18:45 <jle`> Sing 'Study should have a Show instance, but if not, you can write one too pretty simply
21:18:48 <jle`> by pattern matching
21:19:02 <jle`> showSingAreaName = \case SStudy -> "SStudy"
21:23:33 <Lokathor> "oh, i forgot i have a command window open. I wonder what it was doing" *checks* "oh right it's generating the haddock for the entire gl package. whee"
21:23:55 <EvanR> handy
21:24:22 <n_blownapart> hi I downloaded the haskell-stack package. with stack --version I get correct info. but when I try to run ghci I get "command not found". any help?
21:24:43 <Lokathor> n_blownapart, you need to run it "through" stack, so 'stack ghci'
21:25:15 <Lokathor> for ease of switching ghc versions, stack doesn't actually put its ghc into your whole system level stuff
21:25:33 <n_blownapart> Lokathor, bingo, thanks I'm getting an update now
21:25:50 <n_blownapart> excellent thanks
21:28:09 <Lokathor> EvanR, I just wanted to see the docs on my own lib :/
21:28:17 <EvanR> heh
21:28:55 <fresheyeball> jle`: can I get the singleton when I only have its kind?
21:28:57 <EvanR> cabal haddock?
21:29:25 <Lokathor> EvanR, yeah but my lib depends on gl so now it's building up all that first :P
21:29:39 <EvanR> didnt know it built deps docs first
21:29:45 <Lokathor> well
21:29:47 <Lokathor> stack does
21:29:51 <Lokathor> not sure if cabal does
21:29:52 <EvanR> well there you go
21:31:01 <Lokathor> it finally finished!
21:31:08 <Lokathor> 83% doc coverage :/
21:33:21 <saurabhnanda> Just broadcasting this here -- https://stackoverflow.com/questions/44193630/how-to-customise-show-read-instances-on-the-lines-of-fromjson-tojson -- yet another place where Haskell's boilerplate is getting in my way of getting the job done. Why can't string literals itself be used as data constructors?!
21:34:38 <Lokathor> i don't get what you mean by "as data constructors"
21:36:57 <Koterpillar> saurabhnanda: implement your own genericShow
21:37:47 <Koterpillar> as to why it's not already there: Show is generally not used for outside purposes
21:43:59 <Lokathor> if only base supported both Debug and Display like certain new but rising languages :3
21:45:07 <Koterpillar> err, __repr__ and __str__ ?
21:45:55 <Rotaerk> hmm is there some way to have a DMap that contains Pipes i o m r where o m and r are fixed, but the tag determines the type for i?
21:46:14 <Rotaerk> s/Pipes/instances of Pipe/
21:47:01 <Rotaerk> tried doing:  type PipeReordered o m r i = Pipe i o m r
21:47:12 <Rotaerk> and then DMap k (PipeReordered o m r), but it didn't like that...
21:48:41 <jle`> fresheyeball: what do you mean?
21:59:56 <Lokathor> Koterpillar, rust :P
22:05:45 <codygman> Using lens can you delete the first item of a tuple? For maps you can use sans. I want:   (0,1) ^? sans _1 -- result: (1)
22:06:21 <jle`> do you mean using lens
22:06:22 <jle`> or using the library
22:06:32 <jle`> *lenses
22:06:57 <jle`> > (0,1) ^? _2
22:06:59 <lambdabot>  Just 1
22:07:13 <jle`> > view _2 (0,1)
22:07:15 <lambdabot>  1
22:07:53 <Koterpillar> codygman: if you want it to work on both (0, 1) and (0, 1, 2), then my guess is not easily
22:08:18 <jle`> you could easily write a lens to do individual cases, but doing the general case would probably require a typeclass
22:08:23 <jle`> which is what the lens library does for _1 and _2
22:10:45 <glguy> codygman: The various sized tuples are unrelated to each other, so any operation from one to another will be separately specified
22:10:59 <glguy> Beyond that, lenses don't delete structure
22:15:08 <Rotaerk> the reason I want a DMap that contains Pipes is I want something like:  split :: (Monad m, GCompare k) => (i -> DSum k Identity) -> DMap k (ReorderedPipe o m r) -> Pipe i o m r
22:15:21 <Rotaerk> is there a better way to achieve that?
22:15:52 <Rotaerk> to have a pipe where the input values are partitioned such that each group of inputs is processed by a different sub-pipe
22:16:47 <Rotaerk> (the inputs are also mapped to be compatible with their corresponding pipe)
22:17:28 <mikeplus64> anyone want to try write unsafeCoerce with "void" and "bivoid" from http://lpaste.net/355854 . it ought to be possible... right?
22:19:18 <Rotaerk> hmm I guess it works if I:  newtype PipeReordered o m r i = PipeReordered (Pipe i o m r)
22:19:33 <Rotaerk> but that's gonna be ugly
22:20:58 <halogenandtoast> Howdy all.
22:23:23 <codygman> jle`: I meant using the lens library
22:23:35 <codygman> Koterpillar: Yeah
22:23:48 <codygman> jle`:, glguy Ah, I see.
22:24:06 <Koterpillar> how did you get this use case at all?
22:26:09 <lyxia> mikeplus64: this looks pretty safe actually
22:26:50 <mikeplus64> lyxia: hm... you can definitely get it with if you use unsafeVacuous as well, but you can use unsafeVacuous to get unsafeCoerce anyway
22:31:54 <lyxia> mikeplus64: newtype I a = I { runI :: a } ; instance Foldable I where foldr = const const ; uc :: a -> b ; uc = runI . unsafeVacuous . fromJust . void . I
22:33:38 <mikeplus64> lyxia: yeah, refresh the lpaste, i did the same thing (though not as artfully :-))
22:33:52 <lyxia> void relies on foldr traversing all fields of type "a", but that isn't enforced, hence the abuse.
22:36:43 <Koterpillar> I have a ConduitM i o m r which I want to apply foldC to. How do I do that _and_ keep my result (r)?
22:40:47 <n_blownapart> hi if I'm using the atom haskell-ide environment, I can get the app to build but when I go to run it with "$ stack exec -- factorial" I get "not found on  path."   hints?
22:41:25 <n_blownapart> How does it find the path for the build but not exec ?
22:41:54 <cocreature> n_blownapart: are you sure the executable is called factorial?
22:42:04 <cocreature> n_blownapart: the executable name and the package name can be different
22:44:29 <n_blownapart> cocreature, well I guess it's Main.hs ? I tried this a few months ago and it worked. I thought it was .....
22:44:46 <n_blownapart> "stack exec factorial.exe
22:44:47 <n_blownapart> "
22:47:00 <cocreature> n_blownapart: can you show us your cabal file?
22:47:06 <n_blownapart> sure
22:47:07 <lyxia> Koterpillar: there are fuse* combinators https://hackage.haskell.org/package/conduit-1.2.9/docs/Data-Conduit.html#v:fuseUpstream
22:48:41 <Koterpillar> lyxia: thank you, fuseBoth is what I needed!
22:49:10 <n_blownapart> cocreature, http://lpaste.net/6718530591383355392
22:49:46 <cocreature> n_blownapart: "executable factorial-exe" means that the resulting executable will be called factorial-exe
22:50:25 <n_blownapart> sorry cocreature yeah got it I was using a "." and not a "-" . thanks kindly it ran
23:05:58 * Axman6 hates it when people add -exe to executables...
23:06:29 <cocreature> Axman6: the fact that stack defaults to this in its standard template doesn’t help here
23:06:32 <Axman6> do we really need some weird form of hungarian notation for files?
23:06:50 <Axman6> cocreature: yeah, "people" mostly consisted of "the stack template" :P
23:07:05 <cocreature> I’m often just too lazy to change it :)
23:07:23 <Axman6> yeah me too :(
23:07:34 <Axman6> actually.. no, I think i always change it eventually
23:10:28 <codygman> I made some code to generate data types from cassandra's system schema table. I'm not sure how I can update this library to allow something like aeson does with decode :: Maybe MyCustomDataType. It's function I envision as "executeRows QUORUM query  () :: Maybe MyCustomDataType". Here is the current code which takes the tuple type: https://github.com/the-real-blackh/cassandra-cql/blob/master/Database/Cassandra/CQL.hs#L1496  
23:14:46 <vaibhavsagar> Axman6: I assumed you couldn't have a library and an executable with the same name for the longest time
23:14:59 <vaibhavsagar> only figured out it was a stack thing a few weeks ago
23:23:11 <Axman6> yeah :\
23:28:30 <andromeda-galaxy> exit
23:37:10 <Axman6> but I don't want to :( is there a fire?
23:48:33 <halogenandtoast> Just bought Hutton's Programming in Haskell and Pierce's Types and Programming Language (man was TaPL expensive!)
23:49:05 <osa1> TaPL is worth it though (not sure about Hutton's)
23:51:32 <halogenandtoast> I've heard good things about Hutton's book.
23:51:55 <halogenandtoast> Otherwise I wouldn't have bought it of course.
23:54:37 <Lokathor> if i use a function inside another function, but define it to be undefiend without a type signature, GHCi won't infer the type of it based on the type it needs to be
23:54:46 <Lokathor> it'll just stay as ":: a"
23:54:49 <Lokathor> how odd
23:55:03 <phadej> :t undefined
23:55:04 <lambdabot> a
23:55:27 <phadej> it infers the most general type, which is "forall a. a"
23:55:51 <Lokathor> phadej, ...yes but if a function foo is used in another function bar (which has a definition and type) and then you say foo = undefined
23:56:00 <Lokathor> it feels like it should limit foo based on how you used it in bar
23:56:06 <cocreature> Lokathor: why should it
23:56:16 <cocreature> Lokathor: if it has type forall a. a you can definitely use it in bar
23:56:57 <Lokathor> feels like cheating
23:57:14 <halogenandtoast> That's the point of a bottom value is it not?
23:57:16 <cocreature> if polymorphism is cheating, then we are cheating a lot in Haskell
23:57:17 <Lokathor> any type more specific than :: a would need to be some much more specific type, and i feel it should limit it to that subtree of types
23:58:14 <halogenandtoast> you can't change the definition of undefined
23:58:21 <halogenandtoast> any more than you can change the definition of any function.
23:58:30 <halogenandtoast> You've defined an equivalence.
23:58:33 <phadej> Lokathor: undefined *is* cheating :)
23:58:55 <cocreature> undefined is cheating but this problem is not specific to undefined
23:59:16 <Lokathor> i guess I'm imagining that there's an undefined *in* every type, but Haskell thinks that there's an undefined *of* every type :P
23:59:27 <halogenandtoast> undefined is a function.
23:59:40 <cocreature> you are expecting GHC to infer a less polymorphic type than it could and it won’t do that by default (maybe except for the MonomorphismRestriction)
