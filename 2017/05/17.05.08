00:04:21 <sophiag> i'm sure people ask this all the time, but there's no language pragma DeriveApplicative?
00:04:44 <mniip> that's quite hard to do and the result is not always unique
00:05:29 <mniip> there's an infinite amount of ways to write Applicative [] and I'm not sure whether it's countable
00:05:49 <sophiag> but not the case with regular functors i guess
00:06:04 <mniip> fmaps (assuming laws) are unique
00:06:47 <mniip> fmaps without laws were discussed here the other day - turns out you can only define an invalid fmap if you can factor out a '+1' somewhere in the algebraic type
00:06:55 <sophiag> most of the time i just end up writing pure = pure, <*> = ap
00:07:06 <mniip> (well, that was a conjecture)
00:07:14 <mniip> pure=return you mean?
00:07:19 <sophiag> ah right
00:07:29 <toblorone_> dumb question: is haskell able to cache values from infinite lists? For example, if i ran this program with the inputs "0 0" would it recalculate the vaiues twice? http://lpaste.net/355322
00:07:58 <mniip> toblorone_, by2,by3,lists are all only computed once
00:08:03 <sophiag> i'm not sure what you mean by "factor out" 
00:08:51 <toblorone_> cool
00:08:52 <mniip> sophiag, use distributive (and other) laws of the type algebra
00:09:15 <mniip> e.g, Maybe a = 1 + a -- counts
00:09:22 <mniip> Pair a = a + a = (1 + 1) * a -- counts
00:09:41 <mniip> Const Int a = 1 + 1 + 1 ... + 1 -- counts
00:10:28 <mniip> (a, b) = a * b -- can't do anything
00:10:30 <sophiag> so you mean literally any sum type? 
00:10:38 <mniip> Pair isn't a sum type
00:10:42 <sophiag> i know
00:10:49 <mniip> Either is a sum type but you can't factor a +1
00:10:57 <sophiag> the more interesting part is thinking of instances of product types where you could factor something out
00:11:05 <sophiag> oh a + 1 i see
00:11:35 <mniip> I have a more categorical formulation
00:11:38 <sophiag> so Maybe counts because Nothing has an implicit unit?
00:11:45 <mniip> can you write a non-identity natural transformation?
00:12:09 <sophiag> idk
00:12:17 <mniip> that's the criterion
00:13:07 <sophiag> oh i see
00:13:51 <sophiag> i'm not sure how to determine when that's the case, but it makes sense as the criterion for ambiguity in the instance
00:14:18 <ertes-w> helo
00:14:26 <mniip> ehlo
00:14:44 <Hafydd> hole
00:14:59 <mniip> sophiag, byorgey came up with the idea of the +1, and I think they're equivalent to the NT definition
00:15:27 <mniip> and the NT definition comes directly from the free theorem of any fmap factoring into a natural transformation + real fmap
00:15:35 <glguy> mniip: how about a*a
00:15:46 <glguy> did that get covered above?
00:15:52 <mniip> glguy, like I said a^(1+1)
00:16:06 <mniip> oh, I mistakedly said (1+1)*a
00:18:27 <sophiag> ah ok. i'm starting to get it
00:24:41 <akfp> if I have an arbitrary number of `Gen Text` (Gen from quickcheck) and I want to mappend them, how do I lift the (<>) operator?
00:26:25 <opqdonut> liftM2, Gen is a Monad
00:27:00 <cocreature> :t fmap mconcat . sequence -- akfp
00:27:02 <lambdabot> (Monad f, Monoid b) => [f b] -> f b
00:27:03 <opqdonut> if it's a [Gen Text], you want something like liftM mconcat . sequence
00:27:08 <opqdonut> yeah
00:27:47 <mniip> oh no :(
00:27:51 <mniip> writing show instance by hand
00:28:18 <mrkgnao> "how many layers of law-breaking are you on?"
00:28:27 <mniip> one too many
00:28:38 <cocreature> mniip: TH your way to glory :)
00:28:42 <mniip> it's a polykinded gadt
00:28:50 <mniip> and unsafeCoerce is 10 lines away
00:29:18 <mniip> *and* it involved ghc typelits
00:30:15 <mniip> wait
00:30:20 <mniip> you *can* write Show for this
00:30:22 <mniip> can't you
00:30:40 <akfp> thanks!
00:32:19 <mniip> rip
00:32:31 <mniip> it's not possible without impredicative
00:34:08 <quchen> Booo liftM*
00:34:14 <quchen> Use fmap instead of liftM
00:34:21 <quchen> Use liftA2 instead of liftM2
00:39:36 <mniip>     • Couldn't match type ‘(1 + k0) + (b * n0)’
00:39:37 <mniip>                      with ‘(1 + n2) + (b * n1)’
00:39:42 <mniip> hello there!
01:11:22 <tesan> Heya... I started with the simple hello world tutorial from the stackoverflow documentation... and I ran across something that seems curious...
01:12:21 <tesan> When compiling  main :: IO ()  (and in another line) main = putStrLn "Hello World!" everything works fine... but in the GHCi, the first line will cause a "main not in scope".
01:12:40 <bennofs> tesan: GHCi does not really support multi-line input
01:13:20 <tesan> So the tutorial is totally legit and it's only repl related?
01:13:26 <bennofs> tesan: yes
01:13:48 <bennofs> tesan: i recommend using a file and loading that in GHCi for anything that is not just `1 + 1` or calling a function
01:14:59 <tesan> bennofs: Thank you.  (Also, do you recommend any haskell page to start learning other than stackoverflow: docs ?)
01:15:04 <bennofs> tesan: if you still want to define something in GHCi, you have to use let, like: let main :: IO (); main = putStrLn "hello world"
01:16:01 <tesan> bennofs: Ohh I see, so logical ; separation works here too...  thanks again.
01:19:44 <ReinH> tesan: you can consider ghci to be like operating inside an IO monad do block
01:19:48 <ReinH> so bindings require a let
01:20:22 <ReinH> and you are already at the value level, so type signatures aren't allowed
01:20:34 <bennofs> tesan: I've seen some people recommend http://www.seas.upenn.edu/~cis194/spring13/lectures.html, but I haven't read that one myself. I used http://learnyouahaskell.com/chapters and thought it was great, but it doesn't really teach you how to write "real" programs (very little focus on IO) 
01:21:36 <ReinH> combine that with the fact that each line is executed by itself and that's pretty much everything you need to know about ghci to get stuff done
01:22:03 <mniip> type signatures are allowed though,
01:22:07 <mniip> f :: Int; f = 3
01:22:15 <mniip> the problem is the single line thing
01:22:24 <mniip> also there's :{ :} or some such
01:22:36 <ReinH> mniip: well that's weird
01:22:48 <ReinH> and that also binds f without requiring a let
01:23:03 <mniip> new ghci doesn't require a let
01:23:03 <ReinH> I think I'd be happier if ghci didn't cheat as much
01:23:08 <ReinH> huh
01:23:10 <ReinH> welp
01:23:30 <mniip> modern ghci is actually trying not to be a pile of hacks
01:23:38 <mniip> every line gets compiled into its own module
01:23:44 <ReinH> I wonder if they rewrote the manual to indicate that ghci isn't really that much like an IO do block any more
01:24:23 <ReinH> it used to basically just say that and then decribe all the special cases that made it not like a do block
01:24:33 <ReinH> *describe
01:24:46 <mniip> well now I think being a do block *is* the special case
01:25:19 <tesan> bennofs: Thanks for the book recommendations.  Ohh and btw... as I am a starter, the word "monad" shouldn't have much meaning to me... [I heard it, and that's all. I saw it in something that looked like an import statement to me]
01:25:24 <mniip> 'pat <- exp' is special syntax, and IO expressions are simply executed
01:25:54 <ReinH> Well, it still says "The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell do expression."
01:25:56 <mniip> oh man I remember the code related to 'pat <- exp'
01:25:57 <ReinH> so...
01:26:04 <mniip> it's not good
01:26:20 <Rembane> mniip: Is it still there?
01:26:25 <mniip> yes
01:26:41 <mniip> basically it rewrites the code to match that, and then return a list of bound variables
01:26:53 <Rembane> Nice hack! :D
01:27:01 <mniip> the code is then compiled and run, and the list is then rtti'd
01:27:08 <mniip> and manually exposed in the scope
01:27:33 <mniip> you can actually see it
01:28:29 <ReinH> I think maybe "exactly the same" is a bit misleading...
01:29:10 <ReinH> It is exactly the same, except for a number of ways in which it is not.
01:29:24 <mniip> :set -ddump-ds
01:29:32 <mniip> if you read core
01:32:02 <mniip> 'x:xs <- ...' -> case ds_d1c5 of (x_a1by:xs_a1bz) -> returnIO [unsafeCoerce# x_a1by :: (), unsafeCoerce# xs_a1bz :: ()]
01:32:33 <ReinH> that seems fine
01:32:42 <mniip> well yes
01:32:54 <mniip> ghci has no interaction with compiled code other than HValues
01:33:35 <quchen> mniip: Counterexample, GHCi allows »foo = 4« as a statement, while do-notation does not.
01:33:38 <mniip> () is a weird choice to coerce to though
01:34:09 <quchen> GHCi also allows let…in expressions, which do-notation does not.
01:34:20 <mniip> quchen, is that addressed at me
01:34:38 <quchen> At the »GHCi is an IO do block« discussion.
01:34:39 <quchen> So yes.
01:34:52 <mniip> I said the opposite
01:35:38 <quchen> Oh.
01:35:56 <mniip> btw quchen, have you seen the fancy flip transformer
01:35:58 <ReinH> quchen: I was operating on outdated info
01:36:38 <mniip> quchen, http://lpaste.net/355313
01:44:38 <quchen> mniip: uUuuuhgh
01:44:59 <mniip> :t natVal
01:45:00 <lambdabot> KnownNat n => proxy n -> Integer
01:45:07 <mniip> :t natVal . FlipT . Apply
01:45:08 <lambdabot> forall l (n :: Nat) (f :: Nat -> l -> GHC.Types.*) (b :: l). KnownNat n => f n b -> Integer
01:45:11 <mniip> :t natVal . FlipT . FlipT . Apply
01:45:13 <lambdabot> forall l l1 (n :: Nat) (f :: Nat -> l -> l1 -> GHC.Types.*) (b :: l) (b1 :: l1). KnownNat n => f n b b1 -> Integer
01:45:21 <mniip> stuff like this
01:46:53 <quchen> Reminds me of how Java looks like when making an attempt at functional programming
01:47:26 <quchen> Is that the induction principle on Nath
01:47:28 <quchen> Nat*
01:47:29 <quchen> ?
01:48:08 <quchen> That one:   ind-ℕ : ∀ {α} → (C : ℕ → Set α) → C 0 → ((n : ℕ) → C n → C (succ n)) → (x : ℕ) → C x
01:48:22 <mniip> yes
01:48:53 <mniip> I'm writing a package with induction schemes on typelit
01:48:55 <mniip> s
01:49:00 <quchen> I see.
01:51:44 <mniip> check out this beauty
01:51:50 <mniip> (KnownNat b, KnownNat m) => r b -> (forall m. KnownNat m => q m) -> (forall k n. (KnownNat b, 1 + k <= b, KnownNat n) => q k -> p n -> p (1 + k + b * n)) -> p 0 -> p m
01:56:16 <quchen> Uhh okay
03:37:07 <mniip> man this looks bad
03:38:24 <lpaste> mniip pasted “GHC typelits induction schemes” at http://lpaste.net/355323
03:46:20 <quchen> ಠ_ಠ tabs
04:12:14 <Guest29369> names
04:22:35 <quchen> Is there a TH package with a quasiquoter for multiline text?
04:22:48 <quchen> Using unwords and lots of qoutes or the \ \ syntax is annoying
04:25:15 <lyxia> http://hackage.haskell.org/package/neat-interpolation-0.3.2.1/docs/NeatInterpolation.html ?
04:27:39 <j03_k> Hi, how do I do this: 'Define a list of tuples of pairs of numbers. Use a fold function to calculate the sums of the first elements from every tuple'
04:28:47 <quchen> cocreature merijn RFC https://github.com/quchen/prettyprinter/#why-another-prettyprinter
04:29:11 <quchen> Thinking about a standalone release just to avoid the process of convincing lots of people ;-)
04:29:58 <Guest19141> j03_k: For the first part, something like this would do; foo = [(1,42), (2,69)]
04:30:19 <j03_k> Guest19141: I know how to do that part. I just don;t know about the fold
04:30:50 <Guest19141> j03_k: Have you seen foldl and foldr yet?
04:31:01 <j03_k> Guest19141: I don't understand them
04:31:07 <Guest19141> :t foldr
04:31:09 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:31:32 <j03_k> Guest19141: please can you tell me. I've got to do this quickly
04:31:42 <merijn> quchen: Who do I need to beat up? Err..."convince"? ;)
04:31:43 <Guest19141> j03_k: foldr takes 3 arguments; (1) a folding function (we'll get back to that later), (2) an accumulator, (3) a foldable
04:32:11 <quchen> merijn: Now that I added annotations I ran out of reasons to postpone the release
04:32:33 <Guest19141> j03_k: In order, we start with the value of type `t a`, which is foldable `t` containing values of type `a`.
04:32:44 <Guest19141> j03_k: Then we have an accumulator of type `b`.
04:33:16 <Guest19141> j03_k: For each element, we pass `a` and `b` to the folding function `(a -> b -> b)`, resulting in a new accumulator of type `b` again.
04:33:56 <Guest19141> j03_k: The process repeats until all elements have been "folded" into a single unique value (your accumulator) and that's going to be your result.
04:34:12 <Guest19141> > foldr (+) 0 [1,2,3,4,5]
04:34:14 <lambdabot>  15
04:34:17 <j03_k> Guest19141: sorry but im not here to learn. i need to get this done quickly
04:34:28 <Guest19141> j03_k: Then you're here for the wrong reason.
04:34:29 <j03_k> Guest19141: as a one off
04:34:33 <j03_k> Guest19141: please
04:34:35 <Guest19141> j03_k: I'll see you later :)
04:34:38 <j03_k> Guest19141: my life is on the line
04:34:45 <pacak>  j03_k: Then you are going to die.
04:34:46 <Guest19141> With pattern matching we can get creative like:
04:35:07 <Guest19141> > foldr (\(x,y) -> ...) 0 [(1,42), (2,69)]
04:35:09 <lambdabot>  <hint>:1:18: error: parse error on input ‘...’
04:36:15 <merijn> quchen: Who are the lots of people you'd have to convince? Isn't it mostly just the handful of people maintaining ansi-wl-pprint and then just everyone telling everyone else to switch/unify? :p
04:36:23 <pacak> > getSum $ foldMap (Sum . fst) ((,) <$> [1..4] <*> [4..1])
04:36:26 <lambdabot>  0
04:36:37 <pacak> O_O
04:37:05 <merijn> And hey, edwardk is maintainer and at least he is fairly easy to reach and reasonable :p
04:37:09 <quchen> merijn: Well, one problem is that half of Stackage is a revdep of ansi-wl-pprint, so *lots* of libs would break
04:37:27 <quchen> I tried switching Trifecta and it took maybe 5 minutes
04:37:35 <merijn> quchen: Only if they fucked up their upper bounds, no?
04:37:40 <quchen> but there are lots of 5-minute versions
04:37:48 <quchen> optparse-applicative for example
04:38:00 <nitrix> pacak: The problem is your ((,) <$> [1..4] <*> [4..1])
04:38:00 <merijn> quchen: If you release a major version update they shouldn't be using it anyway?
04:38:01 <pacak> > getSum $ foldMap (Sum . fst) ((,) <$> [1..4] <*> [4,3..1])
04:38:02 <quchen> Stackage makes everything run in sync though and it’s heavily used
04:38:04 <lambdabot>  40
04:38:12 <pacak> nitrix: Yea.
04:38:32 <merijn> quchen: But if ansi-wl-pprint is being used than they could just stick to the current version?
04:38:43 <quchen> Right.
04:39:08 <quchen> (I also don’t like wl-pprint, it’s a terrible package name)
04:39:50 <merijn> quchen: On the one hand I agree, on the other, "We have 15 competing packages. Let's build one that addresses all their issues!" -> "We have 16 competing packages..."
04:39:55 <quchen> Maybe I should talk to Edward about this, he has a fairly good overview over the package ecosystem, and what breakage means on a larger scale.
04:40:06 <quchen> Right, that’s what stops me :-)
04:40:31 <quchen> On the other hand, I believe the new one is strictly better than any of the others
04:40:34 <merijn> I suppose maybe a new library and convincing all the mainteiners of wl-pprint libraries to mark them as deprecated could work
04:40:36 <quchen> s/any/all/
04:41:07 <merijn> i.e., release it, change all the existing libraries to compat shims over it and mark them as deprecated
04:41:21 <merijn> But that still involves browbeating a bunch of maintainers :p
04:41:35 <quchen> One of them is famously unreachable :-þ
04:41:43 <quchen> Source: I tried since December
04:41:48 <merijn> quchen: Which one?
04:42:00 <quchen> Noam Lewis, AKA sinelaw
04:42:03 <quchen> Maintainer of wl-pprint
04:42:06 <merijn> quchen: All but two being deprecated is already an improvement :p
04:42:12 <merijn> (yours and wl-pprint)
04:42:25 <agis> Hey guys, quick interruption: Talking about a little piece of code I wrote, a Reddit user told me that he remembers reading something about the Writer monad being too slow to be used in production code, but was not sure and gave no reference. Does someone here know anything about this? I was not able to find anything on the Internet
04:42:55 <merijn> Speaking of unreachable maintainers, if someone isn't responding to github issues, what's the best solution: 1) email, 2) twitter, 3) passive-aggressive complaining online?
04:42:59 <quchen> Writer isn’t terribly performant, but »not fast enough for production« is false. Source: I use Writer in production.
04:43:08 <nitrix> agis: WriterT over IO is going to be problematic, that sounds right.
04:43:15 <merijn> Depends rather strongly on what you're using it for in production :p
04:43:39 <quchen> My prettyprinter uses Writer and it’s faster than the original. Not that the original is very fast ;-)
04:44:07 <pacak> Writter is kind of slow, but it's OK if you are not in a hurry or you are not working with huge amounts of stuff.
04:44:37 <merijn> Also, slow is relative
04:45:05 <quchen> For high-performance logging, don’t use Writer.
04:45:09 <merijn> Some of my code deals with nanosecond operations, some of my code deals with "as long as it finishes within a few seconds" operations, you use different things for different cases :p
04:45:26 <nitrix> The lazyness can cause some neat space leaks when your base monad is IO.
04:45:47 <cocreature> there is writer-cps-transformers which should avoid the space leaks
04:46:22 <pacak> merijn: Nanoseconds? I'm curious. Any details?
04:49:00 <agis> Do you have any alternatives for high-performance logging?
04:49:41 <merijn> pacak: To be fair, that's not Haskell code, but C++ and GPU code. Trying to dynamically switch between implementations of BFS based on predictions to get better runtimes. The predictions are several tens of nanoseconds, the kernels anywhere from a few microseconds to a few seconds (depends on the size, when during the traversal, etc.)
04:50:12 <quchen> merijn: Are you going to any conferences this year? I remember never having met you each time summer comes up
04:50:26 <merijn> agis: Do you have a ballpark estimate for how high-performance? 10, 100, 1,000, 1,000,000 logs per second...
04:51:07 <merijn> quchen: Trying to get to ICFP this year (since it's nearby == cheap flight == easier to convince my advisor to pay for it), but I mostly end up in the non-PL conferences :p
04:51:13 <pacak> merijn: That's exactly I was curious. Foreign imported primops?
04:51:30 <quchen> Aww I’ll miss ICFP I think :-/
04:51:41 <merijn> Stuff like HPDC, HiPEAC, EuroPar, trying to go to MASCOTS this year
04:52:10 <pacak> Or foreign imported functions?
04:52:24 <agis> merijn: Honestly, not really hahaha. I just have this kind of post about how to implement a Writer-like monad, and this user in Reddit suggested that maybe Writer is not the best alternative, so I would like to also recommend other alternatives that can be better than Writer if you need faster code
04:53:04 <pacak> In my case it's primops and I'm doing numbers parsing/validation with vector instructions.
04:53:06 <merijn> pacak: Naah, this is all just straight C++ wrapper with no haskell :) I think Haskell would be fine for the boilerplate code, but I'd have to implement the bindings myself and I was a bit worried about how to eliminate/avoid potential overhead from GC pauses/etc. from things
04:53:20 <cocreature> the problem with using Writer for logging is also that in a lot of cases you want to immediately stream the logging results to whatever your log output is instead of accumulating them and then outputting them all at once
04:53:57 <merijn> agis: Honestly, if you literally don't know, I'd just go with whatever's easiest and fix it later if it becomes too slow
04:54:19 <cocreature> fast-logger is supposed to be reasonably fast I think :)
04:54:44 <agis> merijn: that seems about right, yup
04:54:55 <agis> Thank you for the insight, guys!
04:57:02 <merijn> I mean, I tend to go for "make everything way faster than necessary all the time", which is a good way to yak shave and slowly improve the world, but not one to get anything useful done :p
05:01:43 <agis> merijn: well, "making everything way faster than necessary all the time" seems like the kind of pet peeve I wouldn't mind on anyone haha
05:01:53 <Ulrar> So in JSONParseException from Network.HTTP.Simple, there seem to be a Request and a Response. How would I go about getting only the Response from it ? I'd like to display that, but avoid displaying the Request which contains auth headers
05:02:43 <merijn> Ulrar: Eh, which package is that?
05:02:53 <cocreature> Ulrar: just pattern match on it
05:02:58 <cocreature> merijn: http-conduit
05:03:02 <cocreature> https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Simple.html#v:JSONParseException
05:04:26 <Ulrar> cocreature: Yeah I'm trying to figure out how to do that :)
05:04:46 <Ulrar> (JSONParseException _ (resp ()) _) isn't working
05:04:52 <Ulrar> So I must be missing something in the doc I guess
05:05:04 <cocreature> just resp not resp ()
05:06:20 <Ulrar> Ah, indeed
05:06:24 <Ulrar> Thanks
05:06:37 <Ulrar> Not sure why the doc says JSONParseException Request (Response ()) ParseError then ?
05:07:07 <cocreature> Ulrar: "Response ()" is the _type_ but you pattern match on _values_
05:07:32 <cocreature> e.g. if it said Int you don’t pattern match on Int, you pattern match on 42
05:07:55 <Ulrar> I see
05:08:08 <merijn> cocreature: I don't, I pattern match on 69, because I'm 12 ;)
05:08:33 <cocreature> merijn: then you’re doing it wrong :P
05:12:57 <nitrix> I'm wearing my Stay Lifted Haskell t-shirt today; it can only be a good day.
05:13:04 <nitrix> (https://teespring.com/en-GB/haskell-stay-lifted)
05:13:40 <nitrix> I think only one person in the metro caught onto the logo and smirked :P
05:25:03 <tfc[m]> does anyone have experience with the persistence library and :memory: dbs? my concrete problem is: i create a pool with :memory: and 1 connection. then i do multiple runSqlPersistMPool actions on that, and between them all data seems to get lost. with postgres and sqlite files it works great.
05:25:34 <tfc[m]> i had the impression that :memory: as a backend stays filled until the pool is lost, and not after a runSqlFoo statement has finished.
05:27:41 <liste> tfc[m]: I usually have a specific connection that keeps the database alive
05:28:02 <liste> and additional connections for doing actual stuff
05:29:09 <merijn> tfc[m]: You can't use pool with :memory: according to the docs (when I checked a month or two ago)
05:29:20 <tfc[m]> liste: that's what i thought a pool would be good for.
05:30:15 <merijn> tfc[m]: The pool creates/deletes/reuses connections on demand, but doesn't guarantee "at least one connection" (so it could have 0) and :memory: gets wiped when all connections are closed
05:30:17 <tfc[m]> merijn: ok, so pool's bad for :mem:, and i should rewrite my functions in a way that they use explicit connections in case i use :mem: as backend... right?
05:30:23 <mmo> Could somebody tell me what the currently best testing framework for unit tests is, which also integrates with cabal? Thanks
05:30:33 <tfc[m]> oooh i see.
05:30:40 <cocreature> mmo: personally I prefer hspec
05:30:45 <tfc[m]> thank you merijn
05:30:58 <merijn> tfc[m]: Well, that or simply test with a file (I'm assuming this is SQLite) instead
05:31:11 <merijn> Then the pool should work
05:31:54 <mmo> cocreature: Thank you. What about HUnit and QuickCheck? Do you know the differences to hspec?
05:32:14 <tfc[m]> merijn: yes, that was also my observation. hoped i can avoid touching files, but that's also fine for me.
05:32:43 <merijn> tfc[m]: Honestly, using a file backend with SQLite is literally just writing a path instead of ":memory:" and that's it :)
05:32:49 <cocreature> mmo: they’re complementary. hspec wraps HUnit but provides a better interface (imho) and you can use existing hunit tests inside of hspec and it integrates with QuickCheck so you can use QuickCheck properties in hspec.
05:33:10 <merijn> tfc[m]: Plus, bonus, you can debug/inspect your database using the sqlite program :)
05:33:30 <mmo> cocreature: Ok. That sounds nice. I'll give it a shot. Thanks
05:33:39 <tfc[m]> merijn: maybe /dev/null is the best choice then
05:34:06 <merijn> tfc[m]: Eh...that won't work in any sensible way >.>
05:34:15 <tfc[m]> merijn: but i don't need no debuggers. haskell apps are always bug free because FP! :D :D
05:34:27 <cocreature> mmo: the other option is to use tasty which also integrates with HUnit and QuickCheck but doesn’t try to provide a better interface around HUnit
05:36:44 <merijn> What's the right way to mark a benchmark/test in a cabal file as not buildable?
05:37:20 <cocreature> merijn: I think buildable: false works for any component, not just executables
05:39:33 <merijn> cocreature: Can I override that locally?
05:39:53 <cocreature> merijn: what do you mean by that?
05:41:11 <merijn> cocreature: Something should be unbuildable for people grabbing it from, e.g., Hackage, but I want to actually build it locally (it's generally not buildable since I'm using patched dependencies that haven't been merged/released on hackage)
05:41:40 <cocreature> merijn: add a cabal flag that controls whether it’s buildable
06:22:35 <merijn> So, suppose I get "indefinitely blocked in an MVar operation" any way to trace *which* MVar/where is blocked?
06:30:02 <liste> is using Data.Dynamic to store state for eg. different kinds of game objects a bad idea?
06:30:16 <merijn> liste: Yes, no, maybe
06:30:22 <merijn> Oh, I forgot "It Depends"
06:30:24 <liste> so each object would have an uniform interface but different internal state
06:30:36 <liste> and the state is wrapped in Data.Dynamic
06:30:46 <Grisha> Hi, another newbie trying to escape the IO monad here. My problem: my code recieves a piece of configuration by performing an IO action and then passes it around with the help of the ReaderT. Can I somehow keep it (the piece of conf) between different calls in the ghci repl?
06:31:34 <Grisha> everything works like a charm when I run the whole big code, but I would like to poke the single funcs without having to make extra IO calls
06:32:22 <byorgey> Grisha: first do  config <- ioAction  at the ghci prompt, then   runReaderT someSingleFunc config  ?
06:33:05 <Grisha> byorgey: thanks! wait a sec.
06:33:46 <mauke> it would probably be easier to just not use ReaderT
06:33:52 <Grisha> wow
06:34:04 <Grisha> i didn’t know you could do this
06:34:06 <byorgey> liste: sounds to me like you should just be able to represent game objects as records of functions?  Using Data.Dynamic to wrap the internal state sounds like asking for trouble.
06:34:10 <Grisha> now I have a pure instance of config
06:34:25 <Grisha> I’ve got config :: Config instead of config :: IO Config
06:34:33 <Grisha> byorgey: thanks a lot man
06:34:34 <byorgey> Grisha: yes, you can run IO actions at the GHCI prompt.  It's as if the ghci prompt lives inside a do-block in the IO monad
06:34:37 <mauke> yes, because all of ghci is essentially impure :-)
06:34:49 <byorgey> Grisha: glad to help!
06:35:20 <Grisha> byorgey: you know how often I thought ``it would be nice to be able to do that''?
06:35:31 <Grisha> I hate you Haskell :~)
06:35:31 <byorgey> Grisha: also, as an aside, I do happen to be a man, but it's probably best not to assume that on IRC
06:35:36 <byorgey> hehe
06:36:02 <mauke> your realname says "Brent". looks male to me :-)
06:36:04 <Grisha> byorgey: thank you, point taken
06:36:47 <monochrom> But does it look real? :)
06:37:02 <Grisha> mauke: why did you suggest to drop ReaderT?
06:37:23 <mauke> Grisha: it's syntactic sugar for function arguments
06:37:34 <merijn> byorgey: To be fair, I have known plenty of people who'd say "thanks man" to women too :p
06:37:43 <Grisha> mauke: that’s why I’m using it
06:37:44 <mauke> Grisha: so instead of 'runReaderT foo config' you could just write 'foo config' directly
06:38:02 <byorgey> merijn: so have I.  That doesn't make it unproblematic.
06:38:27 <Grisha> mauke: being a total beginner, it was bothering me that I didn’t understand ReaderT, now I hope I do understand it a bit better
06:39:09 <merijn> Anyway, back to my earlier question: Any tips on finding which MVar is blocking indefinitely?
06:39:33 <liste> byorgey: thanks. I means something like "data GameObject = GameObject { ..., respondToAttack :: Int -> Action (), ... }" and have the game objects have health and have different responses based on that, but I guess I'll go with the more idiot-proof sum type
06:39:42 <rightfold> TIR ReaderT is flip Kleisli
06:39:48 <mauke> merijn: which version of ghc are you using?
06:39:58 <merijn> mauke: 8.0, so with the fancy callstack stuff
06:40:02 <mauke> ah
06:40:23 <byorgey> liste: data GameObject = GameObject { ..., respondToAttack ... }  is what I mean too.  And I'm saying I don't think you need Data.Dynamic for that.
06:40:42 <james42> Hi everyone, I don't understand what this data declaration means : data Test f = Test (f Int). ghci tells me f is of kind * -> *, which is fine to me. When i see the (f Int) part, I understand (and this is probably the part that I get wrong) this as a partial application of the function type f to Int, so a bit like (->) Int. But when I try this : Test (const 'a'), I see that ghc expects type: b -> Int, which is the opposite of what I 
06:41:15 <quchen> james42: No, it’s not partial application. It’s normal application.
06:41:16 <mauke> james42: your message got cut off at "opposite of what I"
06:41:30 <james42> "opposite of what I think"
06:41:30 <quchen> For example, »Test Maybe« has a field of type »Maybe Int«.
06:41:41 <Grisha> james42: it might be a type constructor application, if I’m not messing with the terminology
06:42:00 <byorgey> liste: oh, if you have it return an Action () then perhaps you do.  Instead, you might consider having it return an  Action GameObject --- i.e. it has some effect and returns an updated GameObject
06:42:03 <Grisha> james42: f could be Maybe
06:43:22 <byorgey> liste, like this:   monster :: Health -> GameObject;  monster health = GameObject { ..., respondToAttack a | a > health = ... | otherwise = someAction >> return (monster (health - a)), ... }
06:43:48 <james42> okay, so f is a type constructor that takes an argument and returns a type ? and it's applied to Int ? But if so, how is (const 42) a type constructor ? (Test (const 42) works fine)
06:44:20 <mauke> james42: there are two 'Test's here
06:44:21 <Grisha> james42: in other words, f is a type variable
06:44:25 <mauke> you're looking at the non-type one
06:44:42 <mauke> data Test f = MkTest (f Int)  -- possibly clearer
06:44:55 <mauke> and then the expression you're asking about is 'MkTest (const 42)'
06:45:21 <james42> mauke: yes, I see the difference, but I don't get how you can apply a type variable to something
06:45:30 <james42> for me, a type variable is just a placeholder for a type
06:45:33 <mauke> const 42 :: a -> Integer
06:45:42 <byorgey> james42: do you see how you can apply the type 'Maybe' to something?
06:45:45 <byorgey> i.e.  Maybe Int ?
06:45:48 <mauke> er
06:45:53 <liste> byorgey: thanks! that makes more sense :)
06:45:54 <mauke> const 42 :: a -> Int in this case
06:46:11 <mauke> MkTest (const 42) :: Test (a ->)
06:46:21 <mauke> which I think is a syntax error
06:46:27 <byorgey> james42: yes, a type variable is just a placeholder for a type, but some types can take other types as arguments.
06:46:43 <byorgey> like Maybe, or [], or (Either Char)
06:46:57 <mauke> let's go with const 42 :: (->) a Int; then MkTest (const 42) :: Test ((->) a)
06:47:11 <mauke> here f = (->) a
06:47:27 <mauke> the field in Test has type 'f Int', i.e. '(->) a Int'
06:47:34 <mauke> i.e. 'a -> Int'
06:47:48 <byorgey> liste: great! =)
06:48:17 * james42 is still alive, just reading carefully :p
06:48:33 <byorgey> @quote fire.hose
06:48:33 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
06:48:59 <Grisha> mauke: I’ve got a couple of funcs that a) do a http request, depending on some config and b) parse the json response (JSON parser returning Maybe a)
06:49:07 <merijn> mauke: I think I found out how to get a stack trace, using profiling and "+RTS -xc", of course even with that information it seems look perfectly fine, like all concurrency bugs always do
06:49:33 <mauke> merijn: oh, fun
06:49:42 <Grisha> mauke: do you think that `ReaderT Config (MaybeT IO) a` would be a good type for such funcs?
06:49:58 <merijn> mauke: The real fun is that I have two nearly identical implementations, only one of which works :)
06:50:32 <mauke> Grisha: depends on whether you need those monad instances. otherwise I'd just go with Config -> IO (Maybe a)
06:51:00 <mauke> ... which are still monad instances anyway
06:51:12 <Grisha> mauke: I fancy that if I had a transformers stack, I could map/appy through it more easily
06:51:20 <jchia_1> In cabal, what's the difference between 'extensions:' and 'default-extensios:'? Can I specify package-wide extensions that apply to every library and executable in the package?
06:51:32 <mauke> ((->) e) is an instance of MonadReader :-)
06:51:45 <Grisha> mauke: if my a = [b], I would like to map over bs
06:51:49 <ezyang> jchia_1: default-extensions apply without you having to add LANGUAGE 
06:52:00 <merijn> jchia_1: default-extensions are package-wide, extensions just list all extensions you use
06:52:04 <ezyang> other-extensions indicates to Cabal that you're using an extension, which lets Cabal make better decisions in some cases 
06:52:12 <Grisha> mauke: it’s rather about joining the Maybe and the IO layers into one monad
06:52:14 <merijn> jchia_1: It's preferable *not* to use default-extensions
06:52:17 <ezyang> for example, if you declare TemplateHaskell, Cabal will correctly build dynamic libraries for GHC to build 
06:53:16 <Grisha> mauke: I’d like to pPrint the results, for instance
06:53:32 <Grisha> with just a single `pPrint <$>` 
06:53:45 <merijn> jchia_1: Besides letting cabal make better decisions, correctly listing all extensions in extensions lets tools more easily make decisions (e.g. UHC supports some, but not nearly all extensions GHC does, so you could automatically scrape "buildable package" of hackage)
06:54:10 <jchia_1> merijn: I think default-extensions is not recognized at the top-level. The fields allowed are name, version, cabal-version, build-type, etc. There's nothing about extensions in that list. I just want to enable a few relatively safe and useful extensions like GeneralizedNewtypeDeriving, BangPatterns, LambdaCase, MultiwayIf, PatternGuards, TupleSections.
06:54:36 <merijn> jchia_1: It's not about safety, it's about keeping the source readable
06:54:46 <merijn> jchia_1: PatternGuards is no longer an extension, it's Haskell2010
06:54:55 <merijn> Which *everyone* always forgets :)
06:55:11 <jchia_1> merijn: OK, for me it's a project convention, so it's readable by people working on the project.
06:55:33 <merijn> jchia_1: If you explicitly list extensions at the top of the file it's easy to see what's enabled while browsing a file. Default-extensions are per library/executable, afaik
06:56:34 <jchia_1> merijn: I don't want to spend time thinking about whether each source file needs some simple extension like MultiWayIf or LambdaCase.
06:56:50 <jchia_1> the answer may flip between true and false as the code changes.
06:58:11 <merijn> Ok, so I have N threads that execute the task "readMVar start; do action" M times and one thread that does "putMVar start (); takeMVar start;" M times. Yet, mysteriously, the N threads mysteriously get "blocked indefinitely on MVar" *sigh*
06:59:42 <mauke> wouldn't that deadlock immediately?
07:00:03 <merijn> mauke: Why?
07:00:14 <c_wraith> if the thread that does the putMVar does the takeMVar before some waiting thread does the readMVar, you'll get that error
07:00:20 <mauke> there's only one putMVar at the beginning
07:00:29 <mauke> oh, wait
07:00:35 <mauke> readMVar, not takeMVar
07:00:48 * mauke reads source
07:01:02 <merijn> c_wraith: I force/deepseq the launching of threads before the main thread ever starts it's loop
07:01:15 <merijn> Although I did realise just now that there's a race
07:01:23 <c_wraith> merijn: you're still counting on round-robin behavior from the MVar, which isn't guaranteed
07:01:32 <merijn> Between the last worker finishing it's task/doing readMVar and the main one
07:01:55 <merijn> c_wraith: Nope, MVar guarantees all blocked reads complete before any take when a write happens
07:02:04 <merijn> The problem is a race I have at the end
07:02:19 <merijn> So at least I managed to rubber duck the issue :)
07:02:57 <merijn> At least, with recent GHC's this is true (base >= 4.7)
07:03:01 <merijn> "readMVar is guaranteed to receive the next putMVar"
07:03:57 <mauke> if 'action' is slow, the threads are going to miss all notifications past the first one. is this what you mean?
07:04:39 <merijn> mauke: The threads notify the main one when they're done, but of course there's a race between the last thread notifying the main one and running it's own readMVar and the main thread doing putMVar
07:07:49 <merijn> In other words, benchmarking concurrency primitives is fun >.>
07:08:36 <james42> mauke: thanks, I understand :)
07:10:10 <merijn> On that note: Besides the stuff in base, what are some good fast/low level synchronisation primitives?
07:10:27 <jchia_1> merijn: On the other hand, since I'd have to list the extensions per-library or per-executable in the cabal anyway, it's not much more trouble to just list in at the top if each .hs. There's not much benefit in putting it in the cabal if I can't make it a package-level setting.
07:11:08 <merijn> I'm doing MVar, QSem(N), Chan, STM, IORef, etc. did anyone ever produce some low-level primops or something?
07:11:09 <bennofs> jchia_1: i believe you should at least list TemplateHaskell in your cabal if you use it, since cabal needs to know about it 
07:11:21 <bennofs> merijn: LVar?
07:11:49 <bennofs> merijn: http://hackage.haskell.org/package/lvish idk if it applies
07:12:58 <jchia_1> bennofs: I didn't know that. I have a library that uses TH but the cabal doesn't mention it, and it builds fine.
07:13:27 <merijn> bennofs: I doubt that's going to be any faster, since those use IORef's internally
07:14:03 <bennofs> jchia_1: i think the failure case is like "sometimes rebuilds fail in weird ways" (perhaps it only happens if profiling or dynamic libraries are enabled)?
07:15:19 <bennofs> jchia_1: from https://www.haskell.org/cabal/users-guide/developing-packages.html: Additionally, certain language extensions such as Template Haskell require special handling from the build system and by listing the extension it provides the build system with enough information to do the right thing.
07:15:37 <infandum> In lens, I'm trying to get values that are very deep in a json structure. I'm just getting an empty list, however, because of some mistake I'm doing. Is there some kind of error message lens can split out when it fails to access a value so it can help me figure out what's wrong?
07:16:52 <byorgey> infandum: no, because it didn't fail to access a value, it succeeded in accessing zero values.
07:17:56 <jchia_1> bennofs: Maybe it depends on the compiler?
07:17:57 <infandum> byorgey: So there's no way to spit out a message at each step?
07:18:23 <infandum> like: I see these values, then I see these values, then I see these values, etc
07:18:36 <merijn> infandum: Are they lenses you implemented?
07:18:42 <infandum> by each step I mean val ^.. first . second . third etc
07:18:54 <infandum> merijn: Yeah, using Data.Aeson.Lens
07:18:59 <bennofs> jchia_1: it may work fine in most cases, but there's a few rare cases where it fails with GHC
07:19:13 <merijn> infandum: Maybe you can hack something together use traceShow?
07:19:28 <merijn> @quote refreshing.desert
07:19:28 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:20:09 <infandum> merijn: I was trying but it's a little verbose
07:20:42 <akfp> Anyone knows how I use quickcheck to generate an arbitrary constant?
07:20:59 <akfp> I mean an Arbitrary instance that always returns a constant.
07:21:08 <Grisha> I’m stuck again, having `ess :: Maybe [MyDataType]` (MyDataType is showable) and `pPrint :: (Show a, MonadIO m) => a -> m()`, I cannot `pPrint <$> ess`
07:21:37 <quchen> akfp: gen = pure <constant>
07:21:46 <quchen> eh, arbitrary = pure 5
07:22:04 <james42> mauke: so to check that I understand, if I have 'data Test f = MkTest (f Int Char)' and I have the expression y = MkTest (\x -> 'a')
07:22:05 <quchen> Or maybe phrased a bit bette: Arbitrary is Applicative.
07:22:07 <james42> we have: y :: Test (->)
07:22:11 <james42> because: (\x -> 'a') :: (->) a Char; then ghc "matches" '(->) a Char' with the expected type 'f Int Char'
07:22:13 <james42> it only matches if: f is (->), a is Int, Char is Char
07:22:15 <james42> therefore: y :: Test (->); which looks silly but is correct
07:22:18 <Grisha> or even `pPrint <$> Just 1`
07:22:19 <james42> and we could have Either instead of (->) for example, so this data definition is better than the definition: data Test = MkTest (Int -> Char)
07:22:35 <akfp> quchen: thanks!
07:24:45 <merijn> james42: That's about it, yes
07:25:11 <merijn> james42: And don't forget "Test (,)" in this example!
07:29:01 <fsestini> hi! i’m trying to derive Eq and Ord instances for a GADT with phantom data kinds. here’s a minimal example: http://lpaste.net/7800056528211279872
07:29:37 <fsestini> is there a way to leverage ghc’s automatic deriving?
07:29:53 <merijn> fsestini: StandaloneDeriving, I think I might have an example
07:30:23 <infandum> Okay, the real issue was that I was zipping multiple getters so when I was trying to debug the first one it always returned an empty list. But now I see the problem: how can I traverse an object to get the values over a list? I thought it was val ^.. key "a" but that didn't work as it returned an empty list, so I thought val ^.. traverse . key "a" might do it but that does not agree with the types
07:30:53 <cocreature> fsestini: enable StandaloneDeriving and put "deriving instance Show b => Show (Expr a b)" on a separate line
07:31:01 <cocreature> without any indentation
07:31:09 <merijn> ^^ that
07:32:51 <infandum> But it HAS to be traverse, that makes the most sense
07:33:06 <nitrix> How would one implement/represent ADTs in a completly visual language?
07:33:48 <merijn> nitrix: Personally I would either: 1) ditch the visual language or 2) start drinking heavily :)
07:33:51 <fsestini> cocreature: i still get unification errors if i try to “deriving instance Eq (Expr k a)”
07:34:13 <merijn> fsestini: Needs an Eq constraint on a
07:34:26 <nitrix> So far, the language looks like a graph; nodes are processes (ala erlang) and the edges are connections that represents the dependencies between each process that allows them to communicate via messages.
07:34:27 <merijn> "Eq a => Eq (Expr k a)"
07:34:27 <infandum> Nevermind, it is traverse, but because it's json it's values
07:34:31 <fsestini> merijn: yeah sorry, i meant with the Eq a
07:34:52 <nitrix> But I want a strict type system and can't wrap my head how to represent ADTs.
07:35:04 <nitrix> merijn: Drinking it is ;-;
07:35:09 <merijn> fsestini: Can you lpaste the entire error
07:35:40 <merijn> nitrix: Single malt scotch is good at dulling the pain of crappy languages ;)
07:36:05 <fsestini> merijn: yup: http://lpaste.net/8900165959600308224
07:36:14 <nitrix> merijn: It's not crappy. It cannot be crappy, it's still in the design phase. It has all the potential in the world to be a good language, I don't wanna give up :P
07:36:29 <cocreature> fsestini: huh I tried your example and it worked just fine with what I wrote
07:36:43 <merijn> fsestini: Which GHC version?
07:36:59 <nitrix> merijn: Imagine, Flow Based Programming (erlang-like) + Haskell. I guess Viskell is the closest, but without any Haskell code behind it.
07:37:15 <merijn> fsestini: Also, any other extensions enabled?
07:37:21 <nitrix> Actually, how does viskell deal with ADTs...
07:38:24 <JScully> hello :)
07:39:51 <fsestini> merijn: stack should be using 8.0.1. i also have gadt, kind signatures and datakinds
07:40:39 <merijn> cocreature: So, what's your GHC version? ;)
07:41:19 <fsestini> btw i tried with plain ghc 8.0.1 and its the same
07:42:13 <fsestini> full file here: http://lpaste.net/5461321942185279488
07:44:52 <infandum> Okay, last thing: what is the equivalent of ^.. and toListOf, but for ^? and preview? Like, returning [Maybe a]?
07:49:30 <MitchellSalad_> infandum: [a] = all targets, Maybe a = first target, [Maybe a] = ???
07:50:44 <fryguybob> merijn: About concurrency primitives, Ryan Newton has several collected here: https://github.com/rrnewton/haskell-lockfree
07:50:46 <infandum> MitchellSalad_: "[null,2]" ^.. values . _Integer, for instance, returns [2] instead of [Nothing, Just 2]
07:51:46 <merijn> fryguybob: Ah, the atomic-primops are interesting :)
07:53:13 <merijn> fryguybob: Will be interesting to compare an atomic spinloop vs MVar and co
07:55:55 <tsahyt> hello! I need a good implementation of okasaki's queue. which package should I use?
07:59:00 <tsahyt> or does Data.Sequence perform better?
07:59:36 <shapr> mmm, finger trees
08:00:05 <shapr> tsahyt: try Data.Sequence and see if it's fast enough?
08:00:16 <tsahyt> finger trees are very elegant, but at least for priority queues I've found them very slow
08:00:29 <tsahyt> but a simple dequeue might be different
08:02:42 <shapr> tsahyt: worth trying ?
08:03:52 <tsahyt> shapr: I'll give it a shot
08:04:37 <lyxia> fsestini: the derived instance will not typecheck with existentials.
08:05:25 <lyxia> fsestini: you must write a heterogeneous equality by hand
08:05:45 <fsestini> lyxia: exactly, i was wondering I there was a way to get around it without writing all by hand
08:06:19 <dolio> I think Data.Sequence will almost certainly be slower than an Okasaki queue. But the difference might not actually matter for you.
08:06:41 <lyxia> fsestini: it can probably be automated with template haskell but I don't know any existing library offering this.
08:09:08 <tsahyt> dolio: well since consing and unsnocing from the queue is almost everything I ever do, I think it matters quite a lot
08:09:18 <tsahyt> the rest is out of my control at this point
08:09:26 <tsahyt> i.e. it's generalized breadth first search
08:10:40 <tsahyt> dolio: I also don't need the persistent version I think, so the simple implementation would do
08:10:52 <tsahyt> I guess I could just implement it myself, it's not exactly a lot of code
08:11:25 <byorgey> tsahyt: https://www.well-typed.com/blog/2016/01/efficient-queues/
08:11:59 <tsahyt> byorgey: thanks!
08:17:12 <Grisha> byorgey: have you come across failing ambiguity checks in type classes?
08:24:57 <byorgey> Grisha: sure
08:25:08 <byorgey> I'm sure many others here have as well
08:25:40 <Grisha> i’m trying the simple `class T x where type Parameters x; fetch :: Parameters x -> String”
08:26:17 <Grisha> byorgey: and it’s not happy about the fact that `Parameters x` occurs only on the argument side of fetch
08:26:34 <byorgey> Grisha: yeah, that's not going to work.  The problem is that if you use the function fetch at some type, say,  Char -> String,  there is no way for it to infer what x should be
08:26:43 <Grisha> I’m currently reading about the type ambiguity and the non-injectiveness, but cannot grok it sofar
08:26:51 <byorgey> because there could be multiple types x for which  Parameters x ~ Char
08:27:18 <Grisha> hmmm, lemme think
08:28:51 <Grisha> byorgey: I see - i can instantiate the fetch func for my types, but at the moment I want to call it, the compiler wouldn’t know to what x this instance belongs, right?
08:29:50 <mauke> instance T () where { type Parameters () = Char; fetch c = [c] }; instance T Double where { type Parameters Double = Char; fetch _ = "hello" }
08:29:53 <mauke> fetch 'x' = ?
08:30:00 <Grisha> I see
08:30:18 <Grisha> thanks a lot folks
08:31:15 <ski> so you either need `Parameters' to be injective, or you need to have a method with `x' not (only) passed as argument to `Parameters'
08:32:11 <Grisha> ok, my actual problem is: I’m building the URL for a http request for diff data types. Some data types need one resource id, some need two, some zero
08:32:44 <Grisha> my initial solution would be to map the data type to the type of resource ids
08:33:06 <byorgey> Grisha: however, if you're using GHC 8, another solution is to turn on AllowAmbiguousTypes and TypeApplication, and call fetch with an explicit type argument, like   fetch @Int  or whatever.
08:33:11 <byorgey> I am not sure if this is a good solution.
08:33:13 <ski> can you use `data Parameters x' instead of using `type' ?
08:33:25 <Grisha> ski: what does that buy me?
08:33:35 <ski> then `Parameters' will be injective
08:33:38 <Grisha> hmmm
08:33:45 <Grisha> i’m really slow with that
08:33:59 <mauke> then every instance is forced to define a new type for Parameters
08:34:02 <Grisha> oh, I see
08:34:13 <byorgey> making Parameters an associated data type sounds like a good solution to me too
08:34:14 <Grisha> the `type` keyword just introduces a synonym
08:34:32 <Grisha> whereas `data` introduces truly distinct data types
08:35:35 <Grisha> you’re all awesome
08:36:22 <Grisha> thank you all a lot
08:36:29 <ski> yw
08:41:00 <Grisha> oh shoot, I’ve just written my first non-trivial polymorphic functions involving type deps and it compiled
08:41:59 <akr[m]> Hello, I'm not sure how to use the connectionGetLine function from the connection package: https://hackage.haskell.org/package/connection-0.2.8/docs/Network-Connection.html#v:connectionGetLine
08:42:15 <akr[m]> I don't understand what it does if it doesn't read LF
08:42:30 <akr[m]> does it just throw away the data it's read and throws an exception?
08:43:01 <mniip> okay, I need help bikeshedding a library
08:43:08 <mniip> http://lpaste.net/355323
08:43:25 <mniip> I don't like the names of half of the constructors but I don't know of better ones
08:44:40 <akr[m]> Context: I want to block until a whole line has been been delivered
08:47:09 <davean> akr[m]: well, what part leaves you in doubt? That documentation seems fairly clear to me
08:47:39 <akr[m]> davean: I don't understand what happens it if doesn't read LF, apart from throwing an exception
08:47:40 <davean> It does various things if it doesn't read a LF in various circumstances
08:47:50 <davean> I mean, theres generally no "appart from"
08:47:55 <davean> throwing an exception *is what it does*
08:48:16 <davean> And if you look at the LineTooLong datatype, you see it contains no other data
08:48:19 <akr[m]> okay, so the data that was delivered isn't lost?
08:48:24 <davean> ...
08:49:12 <davean> No, its definately thrown away if you don't get a LF in the buffer limit + 1 chunk
08:49:22 <davean> not in the case you read the end of the file though
08:49:25 <davean> as it clearly states
08:49:31 <davean> "An end of file will be considered as a line terminator too, if line is not empty."
08:49:45 <davean> These are not resumable exceptions or something
08:49:48 <davean> it *throws an exception*
08:50:23 <davean> Perhaps you don't know what an exception is?
08:51:08 <mauke> why would it have to be resumable?
08:51:29 <mauke> we're talking about an operation with side effects on a mutable object
08:51:33 <davean> mauke: well, the exception doesn't store the data, so the only way you could get at the data after an exception was thrown would be if it was resumable?
08:51:34 <akr[m]> davean: well, I haven't really studied Haskell's IO exceptions in detail yet
08:51:35 <cocreature> merijn: fsestini: I’m using ghc 8.0.2 so you might want to try updating
08:51:59 <davean> akr[m]: this is a general exception concept really
08:52:01 <mauke> davean: or if it didn't throw it away and left it in the Connection
08:52:04 <cocreature> fsestini: ftr this is the exact file that I used http://lpaste.net/355326
08:52:28 <lyxia> cocreature: what about Eq
08:52:49 <cocreature> oh that fails for me as well
08:52:50 <cocreature> meh
08:53:10 <davean> mauke: I suppose it could do that, but unless the semantics of some of the functions it uses are weird it doesn't.
08:53:24 <davean> (it calls getChunk, which I assume actually getsa a chunk)
08:53:31 <Grisha> ski: I’ve got another problem: when instantiating, I’m wringin “instance X Type1; data Parameters Type1 = String, fetch s = s`
08:53:40 <akr[m]> davean: ok, so presuming there is some data that was already delivered, the function returns as much as it can, stopping on newline?
08:53:45 <mauke> the semantics it currently has are weird enough
08:53:49 <cocreature> 8.2rc1 also fails
08:54:03 <davean> mauke: yes, I agree the library seems very poorly designed
08:54:07 <Grisha> and it complains taht it cannon match String with `Parameters Type1`
08:54:16 <Grisha> *cannot
08:55:49 <davean> mauke: My argument is absed on the fact that the connectionGetLine function has an internal accumulator
08:56:08 <akr[m]> davean: I'm confused by "This throws an isEOFError exception on end of input" — what is end of input, exactly? Apparently not EOF, as EOF is considered a line terminator?
08:56:26 <davean> akr[m]: EOF
08:56:32 <mauke> akr[m]: it depends on whether anything was read before hitting EOF
08:56:40 <davean> akr[m]: EOF is considered a line terminator if its buffer isn't empty
08:56:43 <mauke> if so, it is returned as a "line"; otherwise it throws
08:56:56 <davean> akr[m]: if its buffer isn't empty, it returns that, and the next call would be and EOF exception
08:57:10 <davean> This library looks TERRIBLE to me
08:57:35 <akr[m]> I see, thanks
08:57:44 <akr[m]> davean: heh, do you have any better recommendations?
08:57:46 <mauke> yeah, I wouldn't use it
08:58:00 <akr[m]> (I only want client-side connections)
08:58:45 <Grisha> hm
08:58:47 <davean> akr[m]: I've not really considered the problem, esp your requirements
08:58:50 <davean> akr[m]: sorry
08:59:04 <davean> akr[m]: This library just raises a whole heap of red flags for me
08:59:32 <davean> akr[m]: I don't even REALLY know what you're trying to do
08:59:42 <akr[m]> well, it's getting quite a lot of downloads
08:59:59 <akr[m]> so if it's extremely bad, someone should tell all those people :)
09:00:59 <LAZAR> can I do pattern matching in lambda expressions? like (\Person name -> Student name)
09:01:10 <davean> There are a lot of people writing haskell without strong engenering skills lately
09:01:21 <lyxia> LAZAR: \(Person name) -> Student name
09:01:23 <geekosaur> LAZAR, you need parens there
09:01:25 <akr[m]> davean: also I'm not trying to do anything complicated, just communicate with a server in JSON-encoded messages
09:01:28 <davean> if we ever could use downloads as an indicator of quality, we can't now, and I really doubt we ever could
09:01:32 <LAZAR> ah thx
09:01:37 <akr[m]> I thought it would be nice if each JSON payload was on a separate line
09:01:52 <davean> akr[m]: why don't you just parse JSON off the connection?
09:02:03 <davean> akr[m]: JSON isn't limited to single lines anyway
09:02:09 <davean> and its very parsable by its design
09:02:25 <davean> never mind its usually better form to length delimit connections
09:02:49 <akr[m]> I don't know how to parse JSON directly from the connection
09:03:07 <davean> https://hackage.haskell.org/package/aeson-1.2.0.0/docs/Data-Aeson-Parser.html
09:03:28 <davean> Its a lot less complicated to parse the JSON directly
09:03:28 <infandum> I'm scouring the internet and I really can't find out how to have a failure in ^.. as a Maybe
09:03:44 <davean> Its trivial to convert a stream of bytes to a stream of JSON values
09:04:20 <davean> Just keep applying that json parser
09:04:21 <akr[m]> davean: ah cool, didn't know you could do that so easily
09:04:31 <davean> akr[m]: its a LOT easier then what you were trying to do!
09:04:41 <akr[m]> indeed
09:05:04 <akr[m]> thanks a lot, I'll do as you suggested :)
09:05:24 <davean> akr[m]: if you're using a streaming system like pipes, conduit, or machines its a small one-liner at that
09:05:43 <Grisha> mauke, ski, byorgey: thanks a lot, you helped me to solve a big problem, I’m heading home now
09:06:44 <cocreature> infandum: if you want to talk about failure and get a Maybe you probably want to use Prisms and use ^? instead of ^..
09:07:28 <davean> akr[m]: with conduit for example, you'd just push the stream into https://hackage.haskell.org/package/conduit-extra-1.1.15/docs/Data-Conduit-Attoparsec.html#v:conduitParser parameterized by 'json'
09:09:18 <akr[m]> davean: this is quite nice, I need to read up on conduit though
09:09:22 <infandum> cocreature: Oh, so I can have ^? get values past the first one?
09:09:52 <cocreature> infandum: can you make some minimal example of what you are trying to do?
09:11:07 <infandum> cocreature: [[1],[]] ^? traverse . ix 0    to return [Just 1, Nothing], for instance
09:11:17 <infandum> oops, I mean [[1],[]] ^.. traverse . ix 0
09:11:49 <infandum> Instead, it treats failure as a filter instead, returning [1]
09:12:49 <davean> akr[m]: this sort of thing is a large part of the point of Haskell
09:13:29 <davean> akr[m]: it's rather uninteresting to have another language to write the same thing in, the point is to be able to write things better
09:14:06 <akr[m]> and safer, surely :)
09:14:27 <davean> They go together
09:15:02 <cocreature> > [[1],[]] ^.. traverse . pre (ix 0) -- infandum 
09:15:05 <lambdabot>  [Just 1,Nothing]
09:15:10 <davean> Safe usually comes from structure and enforcing the structure
09:15:20 <infandum> cocreature: Welp, now I gotta study up on pre
09:16:31 <akr[m]> davean: well put… thought I think I prefer 'syntax' to 'structure', it's just more specific
09:17:09 <cocreature> infandum: the problem is that "ix" is a Traversal and traversals don’t have a notion of failure. pre converts a Traversal (or actually a Fold but every Traversal is a Fold) into something with a weird name that gives you a Maybe for the first element of the Traversal
09:20:31 <infandum> cocreature: Just the first element? Then how come it does the whole list?
09:20:59 <cocreature> infandum: the first element that’s targeted by it’s argument. "ix 0" only targets 1 or 0 elements
09:21:40 <infandum> ah
09:21:52 <infandum> awesome, thank you!
09:22:54 <infandum> cocreature: Yeah, the documentation for pre is a bit confusing for me
09:23:10 <infandum> without your help, that is
09:23:14 <cocreature> > [[1],[]] & traverse %~ preview (ix 0)
09:23:16 <lambdabot>  [Just 1,Nothing]
09:23:19 <cocreature> that would be another solution
09:30:15 <glguy> phadej: Is cabal-doctest on hackage known to be incompatible with ghc 8.2.1-rc1 builds?
09:31:06 <Argue> g d
09:31:22 <Argue> getting ending d now
09:31:29 <Argue> zoomed out to show the start menu we were like woahh
09:33:06 <Argue> oops
09:33:06 <Argue> sorry
09:33:09 <Argue> wrong chan
09:42:59 <et09> reading about applicative functors and see a reference to <*> <- what is that?
09:43:11 <cocreature> :t (<*>)
09:43:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:43:20 <et09> ah - forgot the parens
09:43:30 <et09> ok thanks
09:45:16 <reino4477> hi. How can I return json in Spock? I've tried this -->            json "something" but it didn't compile
09:45:41 <reino4477>     lexical error in string/character literal at character '\n'
09:46:19 <cocreature> that error is most likely unrelated to this. can you show us the complete file and all of the error message?
09:46:53 <reino4477> correction, there're many errors like this "Ambiguous type variable ‘a0’ arising from a use of ‘json’"
09:47:35 <cocreature> where have you gotten the json method from? I can’t find it in the Spock package
09:48:29 <cocreature> ah it’s in Spock-core
09:48:31 <reino4477> https://github.com/agrafix/Spock/blob/f1bd59b64a72da4181a3b2dd3a95beda25dabdbe/Spock-api-server/src/Web/Spock/Api/Server.hs#L42
09:49:03 <cocreature> do you have OverloadedStrings enabled?
09:49:07 <reino4477> yes
09:50:01 <cocreature> the problem is that the json function accepts anything that can be converted to json via the FromJSON instance. but since you have OverloadedStrings enabled GHC doesn’t know what "something" should be and different instances could potentially convert to different json values
09:50:08 <cocreature> so you’re going to have to provide explicit type annotations
09:50:15 <cocreature> e.g. json ("something" :: Text)
09:51:05 <reino4477> cocreature: thx, working
09:55:23 <petrus> hello, I am getting this error message when use "stack build"
09:55:27 <petrus> Compiler version mismatched, found ghc-8.0.1 (x86_64), but expected minor version match or newer with ghc-8.0.2 (x86_64-ncurses6)
09:58:17 <petrus> I get this from a fresh skeleton project, but other older projects with the same resolver: lts-8.13 work fine.
09:59:37 <petrus> I use the system ghc, and want to keep it this way. I can't see what went wrong, any suggestion?
10:00:10 <petrus> my stack version is 1.4.0
10:09:12 <cocreature> petrus: are you sure that older projects still work or did they only work in the past? that error message seems correct to me
10:10:30 <cocreature> petrus: you’re probably going to have to mess with the compiler-check and/or compiler
10:10:32 <cocreature> options
10:11:41 <petrus> cocreature, I am sure - I have just wiped out one's .stack-work, and rebuilt it, with no problem.
10:12:49 <petrus> cocreature, my global .stack/config.yaml
10:12:51 <petrus> system-ghc: true
10:12:53 <petrus> compiler-check: newer-minor
10:13:10 <cocreature> 8.0.1 is not newer than 8.0.2 :)
10:13:34 <petrus> right, so why the other project works?
10:14:42 <cocreature> petrus: not sure. the only thing I can come up with that either there is a different GHC in $PATH or that stack is not using the system GHC for some reason
10:15:43 <petrus> it is not clear to me what this newer-minor means, in the past I introduced because some lts demanded 8.0.2
10:15:58 <petrus> it helped!
10:16:16 <petrus> in the past I mean.
10:16:29 <cocreature> it shouldn’t. newer-minor works the other way around. if a stackage snapshot requires 8.0.1 and you have 8.0.2 then it should work.
10:17:04 <petrus> there is no different ghc, it would take a wee to compile on my machine. that's why I use system ghc
10:17:30 <cocreature> stack downloads GHC binaries so you don’t need to compile GHC even if you don’t use the system ghc
10:18:18 <petrus> cocreature, great, except is it signed?
10:18:38 <cocreature> no idea
10:19:07 <petrus> I don't think so, not really an option for me.
10:19:26 <davean> petrus: GHC is available over SSL which is a type of signature, just detached
10:20:04 <petrus> davean, hmm ...
10:20:24 <kadoban> I believe that stack checks hashes on the things it downloads, like GHC. I'd have to look at the details though.
10:20:29 <davean> I mean, you'd likely get the public key over SSL also, which is why you'd trust it
10:20:33 <davean> so ...
10:21:43 <petrus> I have to think this ssl over ... still I would like to understand what is going on.
10:22:48 <petrus> petrus, there must be some minor details I over look.
10:23:20 <petrus> (not to self :-)
10:23:36 <petrus> I meant note
10:23:53 <davean> petrus: I'm not a stack user (Frankly I view it as counter productive) but one can easily pin the cert you're accepting uin most systems for extra security
10:25:52 <petrus> davean, sure
10:28:59 <petrus> davean, I am less and less a stack fan right now. Maybe I just return to good old cabal sandboxes.
10:29:41 <davean> petrus: new-build
10:30:55 <lep-delete> build systems get more and more complex yet they still all dont work
10:31:11 <petrus> davean, ???
10:31:42 <davean> petrus: theres been a massive upgrade that replaces sandboxes
10:31:54 <davean> I mean sandboxs are still there but theres no reason to use them any more
10:32:18 <davean> lep-delete: I've yet to have a single major issue with cabal frankly
10:32:21 <cocreature> davean: except for the things that new-build doesn’t support :)
10:32:28 <davean> cocreature: yes
10:32:48 <cheater> hi
10:32:56 <lep-delete> cabal build links a new exe even when i havent touched a thing
10:33:00 <cheater> what is that website that has video talks side by side with the slides?
10:33:06 <lep-delete> which wastes time 
10:33:28 <davean> lep-delete: but it correct
10:33:40 <davean> lep-delete: infact, it would often be incorrect not to?
10:33:50 <lep-delete> why relink when nothing has changed?
10:33:58 <davean> lep-delete: nothing tracked by *cabal* has changed
10:34:02 <davean> the system can change behind it
10:34:10 <cheater> lep-delete: why do cabal build if nothing has changed?
10:34:42 <davean> By calling build, you're claiming something has potentially changed
10:34:46 <davean> thus a relink is required
10:34:51 <davean> It would be incorrect to not relink
10:34:56 <lep-delete> meh, i only cabal for sandboxes anyway
10:35:01 <lep-delete> make still reigns supreme
10:35:41 <cheater> i dunno davean i don't think that logic stands up to scrutiny
10:35:50 <davean> cheater: Oh?
10:36:27 <cheater> it's just a layer of semantics that you've ascribed to explain a system that exists already..
10:36:36 <cheater> it's not necessarily intended
10:36:39 <davean> cheater: not really
10:36:57 <davean> cheater: this is a problem you run into with make a *lot*
10:37:07 <cheater> ok
10:37:15 <cheater> i haven't been experiencing the problem but i trust your experience
10:37:23 <cheater> i'm looking for spj's talk on stm, with slides and video, does anyone have a link?
10:37:59 <davean> cheater: I suppose you've never maintained long running servers then - major distro upgrades cause it
10:38:21 <davean> with make you have to run everything from the top
10:38:27 <davean> (cabal cause cause that requirement too though)
10:38:30 <cheater> yeah you'd make clean
10:38:34 <cheater> and then make
10:39:00 <davean> cheater: and probably have to autoconfig too
10:39:40 <davean> external system tracking is a major failure point in build systems
10:45:14 <petrus> davean, how is this new-build mixing with sandboxes?
10:45:28 <cocreature> petrus: it’s completely separate
10:45:33 <davean> Seperate
10:46:18 <petrus> cocreature, except behaves differently when there is a sandbox -- as far as I understand.
10:46:45 <davean> petrus: to my knowlege new-build shouldn't behave differently - its not build
10:47:03 <cocreature> I would be very surprised if it behaves differently
10:47:15 <cocreature> if that’s the case it’s probably a bug :)
10:47:55 <nshepperd_> There are build systems that can track system changes, such as tup (it builds the program in a chroot over fuse)
10:48:19 <Tuplanolla> Oh, the other Tup.
10:48:34 <nshepperd_> Heh
10:50:04 <petrus> the cabal new-... help messages are full of "When using a sandbox, ..." and similar ones.
10:51:07 <petrus> OK, I need to read up on this new- thing. Using stack, I missed it.
10:54:13 <petrus> petrus, haskell tooling is just ...*@$#&(*^
10:54:50 <cocreature> petrus: if you compare it to haskell tooling 5 years ago, it’s pretty good :)
10:55:21 <davean> petrus: Haskell tooling is sufficient, but short of eligant
10:55:32 <petrus> cocreature, half full - half empty :-)
10:55:34 <davean> petrus: what in particular would you like improved?
10:55:34 <kadoban> Right about when stack started up things seem to have taken an upswing. But it's still far from perfect.
10:56:01 <davean> kadoban: I don't know, there was a long upswing before that, with sandboxes being added, etc
10:56:05 <davean> its been a constant evolution
10:56:18 <davean> Theres really no place it stopped making constant, notable improvements
10:56:34 <kadoban> I wasn't around before sandboxes. But even those never worked right for me, so I'm happy to see new-build being a thing. Haven't tried it though.
10:57:02 <phadej> @tell glguy yes, but it works with 8.2.1-rc2 (which is right around the corner)
10:57:02 <lambdabot> Consider it noted.
10:57:14 <shapr> Long ago I would ghc from source and manually install packages. Haskell tooling is SO MUCH BETTER.
10:57:44 <kadoban> Well, they kinda worked, they at least let me get things done. But I'd have to nuke the world bimonthly when something randomly broke, which was annoying, but was still something that worked enough.
10:57:45 <cocreature> it did improve before stack came around but stack definitely accelerated the development of haskell tooling (cabal itself included!) significantly
10:58:47 <shapr> Yeah, I'm a fan of stack.
10:58:59 <shapr> It's certainly not perfect, but things are better than they were before stack.
10:59:15 <shapr> Sometimes I get frustrated when stack doesn't have a library I want
10:59:33 <cocreature> shapr: the funny thing is that stack is also probably the best thing that happened to cabal since it accelerated development so everybody can be happy :)
10:59:37 <shapr> but I figure if I really want a library that much, I can become a stack curator and fix the problem.
10:59:39 <MarcelineVQ> you can just ask it to grab the lib off hackage though :>
10:59:52 <shapr> MarcelineVQ: yeah, but some libs still don't work that way
11:00:04 <MarcelineVQ> any in particular?
11:00:22 <kadoban> cocreature: That's also my feeling, heh. Most of my really big gripes with cabal-install disappeared fairly quickly after stack appeared. Though I've been reluctant to posit cause and effect.
11:00:47 <shapr> MarcelineVQ: off the top of my head, accelerate with CUDA/OpenCL had problems I just could not fix, though that was a few months back
11:01:02 <cocreature> kadoban: I just use both and complain about both equally :)
11:01:04 <shapr> Given time to go through my Haskell projects I'm sure I could come up with five or six
11:01:16 <cocreature> shapr: accelerate might be in stackage by now
11:01:23 <davean> MarcelineVQ: Uh, nothing I want would ever work that way
11:01:25 <shapr> Personally, I want hackage libraries ordered by most recent updated plus number of times downloaded
11:01:25 <kadoban> cocreature: I should try cabal-install new-build stuff sometime, I should try nix as well ... but I mostly just stick with stack 'cause I'm lazy :-/
11:01:30 <davean> MarcelineVQ: stack is always ages in the past
11:01:39 <shapr> or maybe add in number of recently updated libs that depend on that library
11:01:44 <davean> MarcelineVQ: Stack feels like the stone age :(
11:01:56 <cocreature> shapr: at least I added llvm-hs to stackage partially because trevor asked for it so he could add accelerate
11:01:57 <shapr> I want a better way to skip the prototype libs that don't work well.
11:02:09 <MarcelineVQ> I see, since stack 1.4 custom cabal setrups are handled much better so don't be afraid to give it a shot again down the road
11:02:09 <cocreature> davean: your stack bashing is getting boring. if people are happy using it, just let them use it
11:02:27 <Tuplanolla> The past wasn't that bad, davean.
11:02:29 <davean> cocreature: They should feel free to, I was responding to shapr's issue and comiserating
11:02:55 <davean> cocreature: I don't think I've even told anyone not to use stack, the closest was I said I couldn't help with an issue because I don't use stack
11:03:31 <cocreature> “stack feels like the stone age” is not exactly helping anyone
11:03:37 <kadoban> I personally don't feel handicapped by old libraries/packages. Especially using the stackage nightlies, and knowing that I can pick a particular version of a library manually with extra-deps if I need it (or even pick one off of github if I really need)
11:03:58 <shapr> cocreature: I'll try accelerate again next week, I'd like to try CUDA/OpenCL dev in Haskell
11:04:12 <cocreature> and in the case of accelerate, you are probably even wrong. I’m pretty sure that the problem there is that the versions in stackage were too new
11:04:12 <MarcelineVQ> kadoban: pulling from github is one of stack's killer features, it's not far off from combing to cabal though
11:04:33 <kadoban> MarcelineVQ: Good, it'd be nice if they copied that, it's a nice feature.
11:04:48 <davean> I've always "pulled from github" with submodules
11:05:07 <davean> All my projects have a lib/ directory with submodules for extra dependencies
11:06:06 <davean> I even have the current state of hackage as one of the submodules in some projects
11:06:49 <nitrix> Sounds like you're more or less emulating what stackage is trying to solve.
11:06:56 <shapr> At the rate I install libraries, I should be a stack curator.
11:07:31 <shapr> I tend to jump into new fun projects and spend most of my time learning a few new libraries, and by that time the weekend is done and I'm on to the next project.
11:07:53 <Tuplanolla> You're done, but the project is not, shapr?
11:07:58 <shapr> yup, exactly
11:08:03 <Tuplanolla> I have this problem.
11:08:12 <davean> nitrix: eh, sorta
11:08:14 <shapr> it's piles of fun, I guess that's all that matters.
11:08:24 <shapr> I've completed a bunch of code katas.
11:08:45 <shapr> I keep meaning to fix GHC for codewars.com, they need to update to ghc 8 from ghc 7
11:08:52 <dansa> Quicksort in functional programming.  What is its time complexity?  Is it different from the imperative programming?  (Thank you.  Good afternoon.)
11:09:31 <Tuplanolla> I have at least four physics engines sitting there, waiting to be finished.
11:09:50 <shapr> Tuplanolla: somedays I consider pushing all my random code to github
11:09:54 <dansa> I understand it will consume more memory, but not in a relevant way.  As far as I can see, the time complexity must be the same because the recursive function is called the same number of times.  Does that proceed?
11:09:59 <shapr> but much of it is entirely incoherent
11:10:08 <kadoban> dansa: It depends how you write it. It's easy to get it to the same asymptotic complexity as written imperatively. But quicksort isn't used because of its asymptotic complexity.
11:10:16 <Tuplanolla> Indeed. I don't see anyone else enjoying n-dimensional floating-pointless physics either.
11:10:30 <shapr> that sounds interesting
11:10:41 <dansa> kadoban: consider the usual haskell two-liner.  That's how I write it.
11:10:42 <shapr> I have part of the fitbit api
11:10:49 <kadoban> O(n^2) isn't much to write home about. Even expected O(n lg n) isn't too great.
11:11:06 <shapr> ah well, I could stand to chat less and code more
11:11:24 <kadoban> dansa: Depends how you do pivot selection what the asymptotic complexity is (which is the same story as written imperatively)
11:11:42 <mniip> I have an nlogn qsort somewhere
11:12:05 <mniip> http://lpaste.net/354328
11:12:09 <kadoban> The median of medians one, or the usual randomized one?
11:12:10 <t7> what do i call new velocity after one step? like v'
11:12:20 <t7> ive heard people call it vee something
11:12:34 <shapr> v prime
11:12:35 <dansa> mniip: that's not the classic pure-version.
11:12:45 <mniip> dansa, it has nlogn worst case though
11:12:49 <mniip> for real
11:12:54 <t7> shapr: ta!
11:13:00 <dansa> I believe it.  But it's not the beautiful qsort.
11:13:07 <mniip> duh
11:13:23 <dansa> I'm not not-appreciating your work.  I appreciate it a lot.
11:13:37 <dansa> But I'm surprised to find out that the beautiful pure version isn't O(n^2) in the worst case.
11:13:51 <mniip> it is
11:14:00 <dansa> It is?  That's what I'd like to understand.
11:14:04 <kadoban> dansa: It is. But the "beautiful" imperative version is too.
11:14:17 <mniip> if the list is backwards
11:14:18 <dansa> kadoban: Right.
11:14:30 <mniip> you're basically doing a quadratic reverse
11:15:58 <kadoban> dansa: You at least have to do pivot selection well to get something better than O(n^2) worst-case bounds.
11:16:27 <dansa> kadoban: I'm interested only in the worst case.  So I'm asking myself: is the pure version worse than the imperative in-place version?
11:16:54 <kadoban> Considering only asymptotic complexity? No. But there's a reason that we don't *only* consider asymptotic complexity.
11:17:11 <kadoban> I'd argue that quicksort's worst-case asymptotic complexity is *very* little of the reason it's used practically.
11:17:51 <dansa> Sure.  I'm practice many constants matter.  I insist the same.  But at this moment, I'm really only concerned with assymptotic complexity in the worst case.
11:18:00 <dansa> /In/ practice [...].
11:18:17 <kadoban> Then it'd be hard to argue that it's worse, by only that measure.
11:18:50 <dansa> Okay.  Do you see why?  I'd like to build an argument that exposes this assymptotic equivalence.
11:19:05 <mniip> how about this beautiful pointless version
11:19:09 <Tuplanolla> Wow, lewd; assymptotic.
11:19:10 <dansa> I don't have any ideas at the moment.  (By the way, I'm also only interested in the tmie-complexity, not space.)
11:19:16 <mniip> @let qsort' = foldr ((uncurry (++) .) . uncurry (.) . (fmap . (:) &&& span . (>))) []
11:19:17 <lambdabot>  Parse failed: Ambiguous infix expression
11:19:32 <mniip> what
11:19:55 <dansa> Tuplanolla: sorry about the misspelling. :)
11:19:55 <mniip> @let qsort' = foldr ((uncurry (++) .) . uncurry (.) . ((fmap . (:)) &&& (span . (>)))) []
11:19:57 <lambdabot>  Defined.
11:20:08 <mniip> > qsort' [4,1,5,2,4,3]
11:20:10 <lambdabot>  [1,2,3,4,4,5]
11:20:24 <dansa> That's beautiful!
11:20:35 <dansa> Very sophisticated.
11:20:40 <mniip> not quicksort though
11:20:47 <mniip> more like insertion, I don't know
11:20:51 <dansa> Not like the pure-version?
11:20:57 <dansa> Or like the pure-version?
11:21:05 <nitrix> Seems like an insertion-sort.
11:21:07 <dansa> I mean, the classic pure version.
11:21:11 <nitrix> Is it quadratic?
11:21:15 <mniip> yes
11:21:45 <nitrix> It's somewhat readable.
11:22:08 <Tuplanolla> That's a missed opportunity to use `.:` though, mniip.
11:22:19 <mniip> I should've written 'f x . g x' as a join ;)
11:22:56 <mniip> ((f .) .) <*> g
11:22:58 <mniip> or something
11:23:03 <mniip> no
11:23:40 <kadoban> dansa: The argument would just be showing that they're both Θ(n^2) worst-case time I suppose, which shouldn't be too hard to show.
11:23:46 <mniip> (fmap . f) <*> g
11:24:32 <mniip> :t foldr ((uncurry (++) .) . ((fmap . (fmap . (:))) <*> (span . (>)))) []
11:24:34 <lambdabot> (Ord a, Foldable t) => t a -> [a]
11:24:39 <mniip> much more conscise
11:25:28 <Tuplanolla> :t foldr (uncurry (++) .: (fmap . fmap . (:) <*> span . (>))) []
11:25:30 <lambdabot> (Ord a, Foldable t) => t a -> [a]
11:25:36 <dansa> kadoban: I'm working on it.  I'm convinced about it in the in-place C-like version.  I'm not convinced about the haskell-classic-pure-two-liner.
11:25:36 <Tuplanolla> Let's not stop here, mniip.
11:26:42 <mniip> .: is in scope?
11:26:59 <Tuplanolla> :t (.:) -- Sure is.
11:27:00 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f1 (f a) -> f1 (f b)
11:27:05 <mniip> where from
11:27:49 <mniip> I feel like 'foldr f []' could be rewritten
11:28:10 <Tuplanolla> I feel like the `fmap` pair could be merged.
11:28:32 <mniip> you think?
11:28:43 <Tuplanolla> Depends on the type applications.
11:28:48 <mniip> no
11:28:55 <mniip> there's two differnt functors
11:29:00 <mniip> one of them stands for (.)
11:29:27 <mniip> ah
11:29:31 <mniip> you mean using (.:)
11:29:43 <mniip> :t foldr (uncurry (++) .: ((.:) . (:) <*> span . (>))) []
11:29:45 <lambdabot> (Ord a, Foldable t) => t a -> [a]
11:30:11 <Tuplanolla> Braille means good.
11:31:44 <mniip> :t foldr (uncurry (foldr (:)) .: ((.:) . (:) <*> span . (>))) []
11:31:46 <lambdabot> (Ord a, Foldable t) => t a -> [a]
11:36:49 <dansa> kadoban: I'm going to put the question in a more precise way --- with real code say in C.  I realize there are (perhaps subtle) things to consider.  For example, when in C, I can concatenate lists in constant time.  So consider this following C program: http://lpaste.net/355329
11:38:06 <ij> I would like to have a Record that has an attribute that could be added only with an additional constructor with a different name. Is that possible? accessor (RecordAdditonal "bar" "foo") = Just "foo"; accessor (Record "bar") = Nothing
11:39:55 <lyxia> ij: uh, I didn't understand
11:40:59 <ij> I would like to have a Record, whose one of values would be addable only via a different constructor.
11:41:33 <c_wraith> repeating the same words rarely improves communication. 
11:42:00 <exio4> dansa: how is `append` or `concat` there constant time?
11:42:14 <ij> Hehe, sorry.
11:42:53 <ij> Can you redefine data/record constructors?
11:43:05 <exio4> dansa: List* append(List* l1, List *l2) does last(l1) which is O(|l1|) 
11:43:29 <exio4> dansa: FWIW, that concat definition is sub-par, it would be "better" if it was append(ls1, append(ls2, ls3)) 
11:43:50 <lyxia> ij: what are you trying to do with that
11:43:58 <dansa> exio4: very well observed.  What if I keep a pointer to my last element turning append into constant-time?
11:44:00 <exio4> dansa: as last(l1) has to traverse, first, ls1 completely (for append(ls1, ls2) and then that list again for the result of appending ls1 and ls2 together.
11:44:31 <lyxia> @where xy ij
11:44:32 <lambdabot> http://xyproblem.info/
11:44:36 <nitrix> Denotationally, it should be understood as append(list1, append(list2, list3), which can be done very easily in Haskell.
11:45:42 <nitrix> Lists are just a degenerate case of trees.
11:46:27 <kadoban> dansa: I'm not sure why you don't just do the usual array implementation?
11:46:29 <exio4> dansa: well, that should work, but if we're modifying the structure, we might as well make it a double-linked list (which is quite painful to do in a non-mutable environment?)
11:46:37 <ij> lyxia, I know how to solve my problem in different ways, there's no xy problem.
11:46:47 <exio4> dansa: also, you're making some things harder (or adding another structure)
11:47:22 <exio4> dansa: where are the Element and List definition? (as they feel to be the same?)
11:47:43 <lyxia> ij: explaining your problem would help make sense of the way you are currently looking for
11:48:20 <exio4> dansa: you're making removing an element a much more complicated operation by having a pointer to the end on every element, as then removing the final element out of a list would require to somehow change all "elements" whose end_ptr points to it
11:48:51 <nitrix> dansa: Without mutable data structures, I think you can get something like O(log(min(n1,n2)))
11:48:59 <nitrix> for concatenation.
11:49:09 <nitrix> O(1) if you don't care about the ordering.
11:49:09 <exio4> concatenation can be done in O(1)!
11:49:19 <exio4> just use difference lists! :P
11:50:23 <nitrix> If that works like ShowS, it's only half the battle.
11:52:16 <exio4> dansa: FWIW, that's also leaking memory, badly :)
11:53:54 <dansa> exio4: all memory is released as soon as the sort is done. :-)
11:54:18 <dansa> exio4: I forgot to include my list.h in the paste.
11:55:10 <Tuplanolla> Tangentially related, but you know you can say `e = malloc(sizeof *e)`, dansa?
11:57:17 <exio4> dansa: got it? I would like to run your code through valgrin :)
11:57:19 <exio4> valgrind*
12:00:02 <dansa> Tuplanolla: I did not know.  It makes actually sense.  But when I wrote this, it didn't occur to me at all.  Thanks for the *pointer*. :-)
12:01:16 <dansa> exio4: you're quite right: both List and Element are the same.  I only created an alias to make the reading more natural.
12:02:19 <dansa> exio4: paste with the declarations: http://lpaste.net/355331
12:02:24 <dansa> Sorry about that, by the way.
12:04:19 <dansa> (I've just edited to include EMPTY and IS_EMPTY.)
12:05:41 <exio4> dansa: what about strerr?
12:06:18 <exio4> dansa: it's also missing one thing... the prototypes :P 
12:08:49 <dansa> exio4: you wanna run the program, right?  I'll produce you a version that's complete.  Hang on a second.
12:09:02 <dansa> Hang on a few minutes to be precise. :-) 
12:11:36 <exio4> dansa: no problem, heh :p 
12:11:46 <exio4> dansa: maybe you might wanna start a throwaway github repo?
12:13:12 <ij> Are there any alternative non-manual Show derivation mechanisms? I've a single MVar, which, if ignored, would make the record useful to show.
12:17:40 <dansa> exio4: here's a complete version: https://hastebin.com/cativomode.cs (swtiched to hastebin as it seems to color it better.)
12:18:02 <dansa> exio4: thanks for the github suggestion.  next time.
12:24:45 <dansa> I can't just put a last item in struct Element.  I'd have to make up a new struct, called say xList, with last and first pointers.  I would not like to do that.  I'm pretty much as minimalist as possible right now.  I'd like to keep it that way.  So I guess append() is not constant because I need to scan the entire list and there isn't anything I can do about it unless I change my data structure.
12:29:58 <exio4> dansa: yeah, and having an xList also adds some extra boilerplate :P
12:30:15 <exio4> dansa: "tail"/"rest" is no longer just returning something, but allocating memory
12:30:52 <dansa> yes, that's a pity, so I'd like to avoid that.  wow, so true regarding rest.  I'd like to allocate an xList structure every time.  Bad news.
12:31:11 <dansa> I'd like ==> It'd have
12:31:56 <dansa> So, concat/append has a problem.  It's not constant.  How worse is that?
12:32:13 <dansa> It's not constant, but it must be O(n) due to last().
12:32:40 <dansa> Perhaps that makes this quicksort always O(n^2) and never O(n log n)?
12:33:00 <dansa> I don't know how see infer these things.
12:33:06 <dansa>                  to
12:33:30 <exio4> dansa: well, the first thing I notice is the memory leaks, the whole thing is never freeing the memory requested by cons
12:34:15 <dansa> Cons shouldn't free it.
12:34:49 <dansa> That's all I know at the moment.
12:34:49 <exio4> dansa: `requested by` :) 
12:34:53 <dansa> Yes. :)
12:36:42 <exio4> dansa: one simple optimization, before I check anything, concat still has that issue I pointed before
12:36:59 <exio4> dansa: append(append(L1, L2), L3) is worse than append(L1, append(L2, L3))
12:37:26 <dansa> return append(ls1, append(ls2, ls3));  (Next paste it'll be like that.)
12:38:10 <exio4> dansa: in the first case, the append(append(L1,L2), L3) has to first traverse L1, add L2 at the end, and then traverse that thing again, to add L3 at the end of L2
12:38:26 <exio4> while append(L1, append(L2, L3)) can avoid that, and traverse L1 and L2 once
12:38:39 <dansa> exio4: yes; that's very well observed.  thank you!
12:39:01 <dansa> that had not ocurred to me.
12:39:14 <exio4> so, the first would take |L1| + (|L1|+|L2|) steps, while the second is `only` |L1| + |L2| 
12:39:57 <dansa> that's a relevant change --- in particular given the necessary work 
12:40:04 <dansa> ... to make the change.
12:40:12 <kamyar> Hello all
12:40:20 <dansa> hello
12:41:01 <kamyar> Please help me in using Reader monad
12:41:08 <kamyar> see this code: http://lpaste.net/355336
12:41:10 <dansa> Look, it's not clear to me any memory need to be freed.  First, rest, concat, last, append, they all work with what they're given.  They never throw anyway away and they shouldn't.  I think maybe qsort must free some lists, but it's not clear to me how it should do that yet.
12:41:32 <dansa> s/anyway/anything/g 
12:41:44 <exio4> dansa: work the step-by-step of a simple list cons(2, cons(1, cons(3, empty)))
12:42:10 <exio4> dansa: (err, btw, maybe we should move somewhere else, I think this is a bit too offtopic for #haskell?)
12:42:28 <dansa> exio4: sure.  any suggestions?
12:42:37 <Tuplanolla> We have #haskell-offtopic.
12:42:52 <exio4> dansa: ^ :)
12:42:57 <kamyar> I need Reader monad for 1) using redis settings from config instead of defaultConnInfo 2) sending postgresql connection pool to all repository methods in another repository module
12:43:02 <dansa> #haskell-offtopic sounds good to me :)
12:47:56 <vimalloc> Total noob here. Can you do nested folds in haskell, something like this: https://gist.github.com/vimalloc/8f336250f5b807dd2316299b4db92172
12:49:29 <vimalloc> I'm probably just doing something stupid, but I can't figure out how to write this without getting type errors. If I only do one foldr for the inner lists, and do pattern matching ([] and (x:xs)) for the outer lists, it seems to work.
12:49:30 <Cale> vimalloc: why would you be prevented from doing so?
12:49:43 <Cale> oh, well, if it's a type error :)
12:49:59 <vimalloc> Sorry, should have started with that :P
12:50:18 <vimalloc> Just wanted to make sure it should work in theory before banging my head against it more
12:50:36 <Cale> This looks pretty similar to unlines . map (unwords . map show)
12:51:03 <vimalloc> I'll look into that. Thanks!
12:51:05 <Cale> what's with the tuple?
12:51:22 <Cale> your result appears to be more than just a String here
12:51:50 <Cale> You're returning a function and grid itself
12:51:54 <Cale> Did you mean to apply the function?
12:52:22 <octarin> I think he did’nt mean to put a colon
12:52:27 <vimalloc> This is my working version: https://gist.github.com/vimalloc/1c2be7ac068e523915518dbd0cb424c6. Basically I'm just trying to convert that into using foldrs all the way down.
12:52:40 <Cale> octarin: a comma, you mean
12:52:49 <octarin> yes, a comma :)
12:52:54 <vimalloc> oh damnit!
12:53:03 <vimalloc> yep. Stupid commas. Thanks guys :)
12:53:20 <kamyar> Cale: Hello again! Please see my code and help again
12:55:48 <hexagoxel> vimalloc: the existing foldr looks like `map show` plus `unwords`.
12:56:09 <hexagoxel> and the outer recursion is unlines, probably.
12:56:23 <vimalloc> I'll look at those two functions, cale mentioned them too. Thanks :)
12:56:36 <hexagoxel> unless that differs in newline after last item.
12:56:56 * hexagoxel should have read the last 10 lines of chat.
13:00:52 <vimalloc> Totally overrated
13:04:37 <kamyar> No one helps me?
13:08:23 <hexagoxel> kamyar: ah, now i am supposed to read 40 lines back? i hope this trend does not continue :D
13:08:25 <Tuplanolla> > foldr mniipQsortF [] [8, 1, 5, 3, 2, 1] -- We had this previously, dansa.
13:08:28 <lambdabot>  [1,1,2,3,5,8]
13:08:29 <hexagoxel> i suppose you still are talking about http://lpaste.net/355336?
13:08:45 <Tuplanolla> > scanr mniipQsortF [] [8, 1, 5, 3, 2, 1] -- The intermediate results are useless.
13:08:48 <lambdabot>  [[1,1,2,3,5,8],[1,1,2,3,5],[1,2,3,5],[1,2,3],[1,2],[1],[]]
13:08:56 <LKoen> ? mniipQsortF
13:09:00 <kamyar> hexagoxel: No! I just want to use Reader monad  for redis and rdbms settings
13:10:14 <kamyar> hexagoxel: I tried to get help hours ago but samples they send me was not applicable
13:12:20 * hexagoxel does not understand the question.
13:15:26 <mniip> :t mniipQsortF
13:15:28 <lambdabot> Ord a => a -> [a] -> [a]
13:25:48 <nitrix> It's for reasons like this that you're supposed to learn the language by developing a strong foundation than requesting help upon stumbling on practical problems rather than fumbling around, hitting practical problems and not understanding what part of the foundation you're missing that'd be applicable to your problem :/
13:32:06 <nitrix> *then
13:34:37 <tdammers> the best way to learn is to stumble upon practical problems and then learning the relevant foundations so that the practical problems become solvable
13:34:52 <tdammers> learning the foundations in a vacuum is just as silly as not learning them at all
13:35:29 <Tuplanolla> I tend to favor that, but never recover from the tangents, tdammers.
13:36:17 <nitrix> Agreed, but the "let's not learn anything until it's needed" leads to trial and error, which is very frustrating and a waste of time -- especially in a language that has big ideas like Haskell and strongly typed.
13:36:31 <nitrix> You'll constantly hit a wall and beg for help on IRC.
13:37:25 <nitrix> tdammers: I'll support your point up to "exercises are needed". I still think you should learn from bottom-up, starting with a foundation.
13:38:12 <nitrix> People have been really greedy and aggressive today to get help. I had one even say it was a "life of death" situation. I mean c'mon.
13:38:25 <tdammers> hmm yes
13:38:41 <tdammers> it does require a certain humbleness and an open mind
13:39:21 <tdammers> and I definitely didn't mean "stumble upon a practical problem and demand help while refusing to acknowledge the fact that what you're lacking is knowledge of the foundations"
13:39:25 <tdammers> au contraire
13:39:26 <davean> tdammers: I've found the "start with practical problems" version to leave me with skewed views it takes me many years to fix
13:39:37 <nitrix> ^ this
13:39:43 <davean> tdammers: I've never managed to become as good a programmer in any system I've taken that approch in
13:39:45 <tdammers> my experience disagrees
13:39:49 <davean> tdammers: its always strongly limited my ability
13:39:58 <nitrix> It was my experience as well with other languages. Thankfully I approached Haskell cautiously (by recommendation).
13:40:14 <tdammers> the whole problem-solution-order thing, y'know
13:40:37 <tdammers> the foundations won't make sense unless they address a problem you know
13:40:39 <nitrix> In the end, it's probably some loop that just dog-feed itself but anyway.
13:40:52 <tdammers> even if that problem is "I wonder what the underlying pattern here is"
13:40:58 <davean> The "learn theory and then find interesting ways to apply it" has usually lead me to much stronger patterns of thinking
13:41:11 <tdammers> I think it's a back-and-forth
13:41:16 <exio4> it's always a bit of both :)
13:41:49 <tdammers> you encounter a theory that's juuuust beyond your current horizon, study it, and realize that you can apply it to things you know
13:42:06 <tdammers> but if the theory is too far from what you know, it just won't make sense
13:42:13 <davean> tdammers: what theory isn't just beyond your current horizon if you don't know it though?
13:42:43 <tdammers> and sometimes, it's actually something you already know and just didn't have a name for, or you just found a clearer formulation of it
13:43:04 <tdammers> davean: some are more than just a little bit beyond your current horizon
13:44:06 <Monoide> hello, I may have a silly question, I am trying to get the following code work point free, and below is my attempt
13:44:18 <hexagoxel> for me, a more important aspect is learning the relative (dis)advantages of new abstractions. what is frp good for, when exactly should i reach for it? that is much harder than understanding simple examples involving frp.
13:44:21 <Monoide> let five_up = 5 * (ceiling . (\x -> x / 5))
13:44:27 <Monoide> I do not really understand why this is not compiling
13:44:51 <Tuplanolla> You're multiplying a function, Monoide.
13:44:54 <cocreature> Monoide: try (5 *) . ceiling . (/5)
13:44:55 <ski> did you mean `(5 *) . ceiling . (/ 5)' ?
13:44:58 <Monoide> (this simply round to the multiple of 5 up, like 50 -> 50, 52 -> 55)
13:45:06 <Monoide> oh, my bad
13:45:09 <Monoide> indeed, thank you <3
13:46:42 <nitrix> Monoide: Equally, if not more readable: (\x -> 5 * ceiling (x / 5))
13:47:03 <Monoide> yes
13:47:10 <ski> > map ((* 5) . (`div` 5) . (+ (5 - 1))) [50 .. 56]  -- Monoide, would something like this work ?
13:47:13 <lambdabot>  [50,55,55,55,55,55,60]
13:47:28 <Monoide> I am more than happy, it is late here, I'm juste being silly
13:47:35 <ski> (in case you're working with integers, rather than fractionals)
13:47:38 <Monoide> couldn't see the homogeneity obvious error <_<
13:48:00 <Monoide> this last version is way better, I agree
13:48:09 <nitrix> Monoide: Two insights here, function application always has the highest priority (if we ignore record update syntax) so the parens around `ceiling` aren't needed.
13:48:28 <nitrix> Monoide: Secondly, (\x -> x / 5) could be written as a section (/5)
13:49:26 <nitrix> (5*) . ceiling . (/5)   -- Also fairly readable :)
13:49:55 <Monoide> right, thanks :)
13:52:34 <mniip> :t ((.) . (. ceiling) . (*)) <*> (flip (/))
13:52:36 <lambdabot> (Integral c, RealFrac c) => c -> c -> c
13:53:10 <suppi> five_up x = 5 * ceiling (x / 5)
13:53:25 <suppi> just to be complete :)
13:54:48 <nitrix> I just realised something. If <$> is more general than (.), and yet (.) is a categorical construct (Category) which is supposed to be an abstraction much higher... that seems to give a lot of power to morphisms suddently.
13:55:11 <nitrix> That might just be me realizing there's a path to categories of categories.
13:55:17 <johnw> :)
13:55:29 <johnw> a lot of concepts can be seen as objects or morphisms in some category
13:55:48 <johnw> "isomorphism" is just a morphism in a groupoid; "natural transformation" is just a morphism in a functor category; etc.
13:57:00 <nitrix> johnw: Just like you can make monoids of endofunctors and obtain monads. That one blew my mind too.
13:57:25 <nitrix> I remember thinking people were just joking with mumbo jumbos and one day it clicked :P
13:57:42 <nitrix> Having small eureka moments here, slowly c:
13:57:43 <johnw> yes; the whole power here is seeing complex constructions as another example of a simpler, known sturcture
13:58:02 <johnw> nitrix: did you see my most recent blog post?
13:59:24 <mniip> nitrix, (.) is more general than fmap imo
13:59:36 <mniip> because you're talking about the covariant Hom functor
14:01:34 <nitrix> I guess the question becomes "Would Haskell be able to type-check a definition akind to (.) = fmap" ?
14:01:55 <nitrix> With the proper type annotation.
14:02:02 <Tuplanolla> It's funny that you mention this, johnw. I had a moment today where a physicist colleague asked me what I was working with and I just said it's "the initial object in the category of algebras for this base functor".
14:02:11 <mniip> nitrix, I think that question is wrong
14:02:16 <mniip> you want to have fmap = (.)
14:02:33 <johnw> Tuplanolla: :)
14:02:35 <mniip> instance Category c => Functor (c a)
14:02:37 <Tuplanolla> Only then did I realize that my response was completely devoid of information.
14:02:49 <nitrix> mniip: Oh.
14:02:56 <mniip> as well as 'instance Category c => Functor c'
14:03:03 <mniip> but for that you need a more delicate functor class
14:03:08 <Tuplanolla> Is there even a question that can't be answered "x in the category of y"?
14:03:08 <Monoide> Tuplanolla: and so what is the real answer :) ?
14:03:10 <nitrix> Oh yeah otherwise you can't have categories of categories.
14:03:18 <nitrix> mniip: Which is where Haskell's Functors breaks, right?
14:03:22 <mniip> yes
14:03:31 <mniip> I should upload my Hask to github
14:03:33 <Monoide> Tuplanolla: in how many ways can you cut a polygones into triangles?
14:03:40 <nitrix> mniip: I'd love to see it.
14:04:21 <Tuplanolla> I'm sure there's one for that too, Monoide...
14:04:54 <Monoide> Tuplanolla: I'd be really curious if there is any interesting way to embbed Catalan numbers into nice categories
14:05:21 <nitrix> johnw: I had a fun exercise a few weeks ago, debating with people at work between what was the "best approach/most idiomatic/cleanest" between using some class inheritance of a language, vs doing some dependency injection to emulate composition. I ended up using CT to prove it formed a category :D
14:05:27 <nitrix> johnw: Composition always prevails >:3
14:06:08 <mniip> nitrix, enjoy https://github.com/mniip/Hask/find/master
14:06:43 <nitrix> Not that it made any difference mind you, I was just curious to see if they were equivalent and if so, which one was more general. Then CT came to mind and of course, composition. Composition is such a beautiful idea.
14:06:49 <nitrix> mniip: <3
14:07:41 <nitrix> class Functor (k :: kk -> kk -> *) (l :: ll -> ll -> *) (f :: kk -> ll) | f -> k l where fmap :: k a b -> l (f a) (f b)
14:09:06 <mniip> nitrix, I think CT.Limit.Product is unfinished
14:09:14 <nitrix> mniip: Scary looking, heh. Is it why it's not in base :P ?
14:09:50 <mniip> there's an even scarier looking functor out therre
14:10:12 <shapr> ok, what's your scariest functor?
14:10:25 <shapr> We should do a scary code evening near Halloween
14:11:25 <nitrix> instance Comonad Alien ...
14:11:59 <mniip> class Functor k (f :: *) where type Dom :: * -> k -> k -> *; type Cod :: * -> k -> k -> *; fmap :: proxy f -> Dom f a b -> Cod f a b;
14:12:04 <mniip> something along those lines
14:12:20 <mniip> with this you could have a true identity functor
14:12:20 <Tuplanolla> Could we lead newspapers to report on illegal assault functors?
14:12:23 <nitrix> Domain and codomains, seems clean though.
14:12:48 <nitrix> mniip: Curiously, would it ever be beneficial for Haskell to grow to use that?
14:13:04 <mniip> data Identity; instance Functor Identity where type Dom Identity a b = a -> b; type Cod Identity a b = a -> b; fmap = id
14:13:16 <mniip> no wait
14:13:18 <mniip> fmap = const id
14:13:25 <mniip> nitrix, I think it doesn't fit
14:13:28 <mniip> see the proxy argument
14:14:08 * nitrix adds implict magic.
14:14:13 <nitrix> Yours worked though, I think.
14:14:19 * nitrix scrolls up.
14:15:06 <nitrix> Yeah yours is inbetween and still very reasonable.
14:15:27 <mniip> oh yeah
14:15:31 <mniip> I got stuck on product
14:15:37 <mniip> and never got around to define monads
14:19:19 <nitrix> I'll have a look. This will probably make a lot more sense now. I should try implementing Hask too :P
14:23:19 <nitrix> mniip: http://mniip.com/powder/stock/
14:23:30 <nitrix> mniip: Interesting... you and I will need to chitchat some day :P
14:24:17 <mniip> that's uh
14:24:22 <nitrix> Tron 136% !
14:24:44 <mniip> let's say it's a very local meme
14:24:57 <nitrix> heh (:
14:28:20 <mniip> 1494278846 [00:27:26] <+boxmein> mniip, say you're selling variations of cocaine 1494278847 [00:27:27] <+boxmein> powder stocks 1494278848 [00:27:28] <+boxmein> get it
14:29:14 <nitrix> I see. Anyway, heading home. Cheers~
14:30:56 <kuribas> Why doesn't hackerrank include Data.MultiSet :(
14:31:06 <kuribas> there go my one-liners...
14:39:15 <kadoban> Heh, out of curiosity, what problem do you need them for?
14:40:48 <oisdk> Is there any state-like transformer that lets you write instance Applicative m => Applicative (OddStateT s m)?
14:41:47 <Tuplanolla> What would that be, oisdk? Nondeterministic state?
14:42:37 <mniip> oisdk, good question
14:42:59 <mniip> I stumbled across it myself too, as far as I can tell that's impossible with s -> m (a, s)
14:43:37 <oisdk> Had a look at the Update monad, but it seems like it won't work
14:44:12 <mniip> maybe, hmm, WriterT (Endo s)
14:45:20 <oisdk> Tuplanolla I actually just want a random number generator that I can replay, but letting the underlying m be just applicative would make things fit more nicely
14:45:53 <mniip> m (s -> (s, a))
14:45:56 <mniip> would that work
14:46:31 <kuribas> kadoban: there are quite few
14:47:30 <kuribas> kadoban: ransom note from cracking the coding interview
14:47:46 <kadoban> Ah, I've actually read that one, but I didn't implement it.
14:49:45 <oisdk> mniip That looks good! 
14:52:08 <kuribas> kadoban: and contacts, which I solved with Data.Set, even though I'm supposed to use a trie :)
14:53:08 <oisdk> I wonder why it's the other way around normally
14:53:25 <kadoban> Oh that one, I actually did that one. I wonder what I used
14:53:40 <kadoban> Oh, that's one of the few I didn't use haskell, apparently a trie, heh.
14:54:29 <kuribas> kadoban: I just looked up the prefix (with splitMember), then counted the number of elements starting with it :)
14:55:09 <kadoban> Haha, that's pretty funny
14:55:27 <kadoban> I don't think I would have thought of that
14:55:43 <lyxia> oisdk: it's more useful and more efficient
14:55:44 <kuribas> probably wouldn't count in an interview...
14:55:57 <kadoban> I'd think it would, for a good interviewer.
14:57:49 <kuribas> kadoban: what other language?
14:58:11 <kadoban> I've done a bit of C++, though it's mostly reminded me why I stopped liking C++.
14:58:55 <kadoban> Might try rust next, haven't been doing much hackerrank for a month or so though. Have google codejam coming up this weekend, probably after that.
15:01:35 <kuribas> I'm trying C++ as well, to practice.  It has more chance for a job thank haskell.
15:02:54 <leshow> kadoban: I didn't like hackerrank much, having everything funnel through IO makes it odd. exercism.io I thought was fun though
15:03:05 <leshow> they have test cases you can run in cargo
15:03:13 <leshow> for each problem
15:03:56 <kadoban> I mostly factored out the IO parts, to the extent I could. Though it's not perfect, I don't have to spend much time thinking about input/output for the vast majority of problems.
15:04:41 <leshow> fair enough, just saying if you want to try a site that actually spent some time thinking about each language they support
15:05:31 <kadoban> Yeah, I like exercism.io, but what I do on hackerrank is just different. It's not really about learning the language, though I've learned a bunch of haskell because of it. It's about "competitive programming" and algorithms
15:06:08 <leshow> That can be fun, doing X algorithm isn't a great way to learn a language though
15:06:22 <leshow> the problems on leetcode are good too
15:06:53 <leshow> but they dont have the same protean language support hackerrank does
15:07:14 <shapr> I enjoyed some of the Haskell puzzles on codewars
15:07:26 <kadoban> I didn't like what I've seen of leetcode, the problems and specifications didn't seem that well thought out :-/ I mostly do hackerrank and codeforces
15:07:44 <leshow> To each their own I guess
15:08:00 <kadoban> Yeah. One of my friends spent a lot of time there and seemed to enjoy it and learn
15:08:04 <kadoban> (leetcode)
15:08:14 <leshow> Traditional algorithms in rust can be a bit odd because of ownership and borrowing rules
15:08:43 <leshow> but then again, we're on #haskell lol
15:08:45 <kadoban> Yeah, I'm not sure how well that'll go, but I'm fairly excited to try.
15:08:49 <kadoban> Heh, ya.
15:09:59 <Tuplanolla> I noticed Rust doesn't have integer logarithms or any other extremely common number theory functions in its standard library, which is a big disappointment.
15:10:18 <kadoban> Haskell doesn't either, does it?
15:10:29 <Tuplanolla> No, but it should.
15:10:47 <leshow> Tuplanolla: what are you looking for? like log and log(basek)?
15:11:01 <hpc> :t \b -> floor . logBase b
15:11:02 <lambdabot> (Floating a, Integral c, RealFrac a) => a -> a -> c
15:11:18 <hpc> :t logBase
15:11:19 <lambdabot> Floating a => a -> a -> a
15:11:21 <Tuplanolla> That's slow and inaccurate, hpc.
15:11:30 <kadoban> Yeah, I've had to write my own before, it was unfortunate.
15:12:18 <Tuplanolla> In low-level languages it's very common to ask "how many bits does it require to represent this number" and the answer is an integer logarithm with rounding up.
15:13:10 <Tuplanolla> Another base comes up with "how long is this formatted number going to be".
15:13:24 <octarin> maybe in Data.Bits
15:13:45 <leshow> another thing that sucks about i32/i64/.. in rust std there's no generic Number trait
15:14:09 <leshow> with some effort you can put it together 
15:14:24 <leshow> and there's crates to do it for you, but it's not in std
15:14:27 <kadoban> I though there's traits for like add and subtract and all the rest separately. Or is that not good enough?
15:15:11 <leshow> There is Add/Sub/Mul etc
15:16:30 <leshow> And you can definitely combine those to get something like Num
15:16:39 <kadoban> Is it just kind of tedious?
15:16:53 <leshow> yeah, it would be nice if it was included in std
15:17:01 <ChaiTRex> It's nice, because you can make types that don't include all the operations of Num.
15:17:26 <leshow> but sometimes i just want to say, take any type thats a number
15:20:43 <antoine9298> hi. I’d like to know how ugly is this code, and see some more readable alternatives
15:21:04 <antoine9298> basically, I’m trying to have a set of conditions matched
15:21:32 <antoine9298> if any ($ args) [(1>).length, ("-u"==), ("-h"==)] then …
15:22:23 <antoine9298> (also, I tried to use empty instead of `(>1).length`, but couldn’t find where it belong)
15:22:44 <ChaiTRex> I think you need null instead of empty.
15:23:58 <antoine9298> ^ thanks
15:24:10 <antoine9298> It works
15:24:18 <ChaiTRex> You're welcome.
15:24:45 <antoine9298> How bad it that code anyway?
15:26:19 <ChaiTRex> It's not that bad. I'd personally do if any (\x -> null x || "-u" == x || "-h" == x) args, but it's just a personal preference.
15:26:59 <ChaiTRex> You might not need the null part if you're parsing command line options, since passing '' to a program is very rare.
15:27:12 <ChaiTRex> It doesn't mean that the argument list is empty.
15:27:32 <ChaiTRex> For that: null args || any ... args
15:27:56 <antoine9298> tried to golf it with any, but got caught with the “argh, the list is the 2nd argument”, that’s why
15:28:07 <antoine9298> (1st try with `any`)
15:28:12 <ChaiTRex> There also might be a nice option parsing library, but I haven't dealt with that myself.
15:29:05 <antoine9298> well, I though of it too, but it’s only for usage flag, so that’s not a big deal
15:29:36 <ChaiTRex> Ahh, OK.
15:30:07 <antoine9298> Nah, otherwise, it’s a bit like trying to parse JSON with regexp — madness.
15:30:56 <antoine9298> (except that your broken inplementation is not as dangerous, but yet)
15:33:32 <antoine9298> (but there are some that do even worse: they do it with html… https://ctrl.blog/entry/rdfa-socialmedia-metadata)
15:43:48 <antoine9298> hmm… I see what you meant with "passing '' as arg": I’ve given (← is that even english?) the arg list and the 1st arg test the same argument, can’t work.
15:44:39 <antoine9298> (the compiler could’nt type-check it ’cause the getArgs line was yet undefined, and a String is still a list)
15:45:00 <antoine9298> (or is it «I gave?»)
15:51:11 <joe9>  I am trying to read a binary data written to stdin, but, for some reason Data.ByteString.hGet does not seem to read anything. I piped the same output to xxd and it is being read fine. Any suggestions on what I might be missing, please?
15:52:06 <ChaiTRex> joe9: Try setting the reading mode. Let me see...
15:52:21 <joe9> oh, Thanks. will try that.
15:52:57 <ChaiTRex> hSetBuffering stdin NoBuffering
15:53:01 <ChaiTRex> Something like that.
15:53:23 <ChaiTRex> joe9: ^
15:53:34 <joe9> Thanks.
15:53:50 <ChaiTRex> You're welcome
15:55:00 <Cale> antoine9298: "I gave" (past tense) and "I've given" (perfect tense) are both valid English.
16:06:37 <antoine9298> Cale, well, I guess it’s ok, then :-)
16:23:49 <mekeor> why is there no HOST environment variable in GHCI (ie. System.Environment.lookupEnv "HOST" == Nothing) although there is such a variable in my shell?
16:25:08 <hpc> are you sure there's such a variable in your shell?
16:25:11 <hpc> env | grep -i host
16:25:34 <mekeor> :O oh, indeed, there is no such variable
16:25:43 <mekeor> but `echo $HOST` returns my hostname...
16:25:52 <mekeor> it must be some shell-foo, huh?
16:25:56 <hpc> try echo $RANDOM sometime
16:26:03 <mekeor> i see
16:26:12 <hpc> yay for pseudo-variables
16:26:14 <geekosaur> mekeor, there are envars and shell vars
16:26:21 <mekeor> ah
16:26:23 <geekosaur> conventionally all-0uppercase is env, but bash cares not about convention
16:26:35 <geekosaur> so $HOST is a local shell var that is all uppercase
16:26:43 <geekosaur> "thanks, bash"
16:26:50 <mekeor> well, zsh does the same
16:27:47 <hpc> this is why i only use cmd.exe
16:28:00 <geekosaur> pretty sure zsh picked that up only because bash was already doing it and "all good linux programmers" therefore knew it is always available under that name as a 100% portable guarantee
16:28:52 <mekeor> thanks, bash
16:32:21 <hpc> when debugging, sometimes it helps to assume the code knows more than you
16:32:49 <hpc> the line where you draw that "sometimes" varies, but i find that most of hackage knows more than i do
16:33:14 <monochrom> Cunning plan: Fork bash to create a new shell, call it lash, to present environment variables as lowercase. :)
16:34:13 <hpc> that doesn't scale, you can only fix 25 bugs that way
16:34:19 <hpc> and some of them are already fixed!
16:35:19 <hpc> give it a guid, those are much easier to manage :P
16:36:07 <monochrom> Good idea!
16:36:53 <hpc> #!/bin/71bbee79-42a6-4a86-a18e-eaf8a2adc298
16:36:59 <hpc> #!/bin/71bbee79-42a6-4a86-a18e-eaf8a2adc298 -x for debugging
16:37:22 <hpc> also TIL if you search duckduckgo for "guid" it generates one
16:37:22 <geekosaur> (zsh certainly has its own sins; it's a csh-oid, which means it conflates envars and shell vars *differently* weirdly, and has a bunch of lowercase vars with odd behaviors to emulate csh)
16:42:25 <et09> i'm trying to read this: http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
16:42:34 <et09> and i'm having trouble understanding this line on page 2: sequence (c : cs) = return (:) ‘ap‘ c ‘ap‘ sequence cs
16:43:14 <monochrom> hpc! I just notices that the prefix 71bbe looks too similar to "tibbe". Is there is hidden message? :)
16:44:26 <monochrom> !. Do you know "ap"?  2. Do you know the infix syntax such as 10 `div` 3 ?
16:44:45 <mekeor> :t ap
16:44:46 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:45:05 <et09> i don't know "ap", but i see the definition right above it.  and i get infix syntax, altho not positive on the operator precedence here - is it going from left to right?
16:45:33 <monochrom> It is infixl. (return (:) `ap` c) `ap` sequence cs
16:46:33 <et09> ok, so (return (:) `ap` c) is a monadic wrapped function?
16:46:36 <et09> is that right?
16:47:33 <monochrom> Since it uses ap twice, it is going to be a stress test on your understand of ap. You may need to work slowly, e.g., begin with "Just sin `ap` Just 0.1".
16:47:44 <monochrom> Let's ask lambdabot
16:47:58 <monochrom> @type return (:) `ap` (Just 5)
16:47:59 <lambdabot> Num a => Maybe ([a] -> [a])
16:48:14 <monochrom> Generalize "Maybe" to arbitrary monad m.
16:48:48 <monochrom> The []'s are caused by (:). They stay.
16:51:50 <et09> ok so ap took two arguments, (return (:)) and (Just 5) - right?  so those are the arguments m a and m b 
16:52:01 <et09> and it merged it to m (a b)
16:52:05 <et09> and it merged it to m (a -> b)
16:52:28 <monochrom> m (a->b) and m b.
16:52:30 <et09> wait sorry.
16:52:41 <monochrom> Err heh
16:52:42 <monochrom> m (a->b) and m a.
16:52:43 <et09> it took m (a->b) and m a
16:52:45 <et09> yeah
16:53:05 <et09> so this should give a -> b
16:53:08 <et09> :t (:)
16:53:09 <lambdabot> a -> [a] -> [a]
16:53:23 <et09> ugh n/m lol i get it
16:54:43 <et09> but i guess the idea is that the whole expression -- return (:) `ap` c - has the type m (a->b), thus it can be fed again as the first argument to ap.  right?
16:55:10 <Welkin> why are you using `ap` and `return` (or monads) here?
16:55:14 <Welkin> why not use applicative?
16:55:27 <monochrom> return (:) :: m (a -> ([a] -> [a]), so b = [a]->[a].
16:55:29 <et09> Welkin: i'm trying to understand an article explaining the invention of applicative, lol
16:55:34 <Welkin> lol
16:56:36 <monochrom> return(:) `ap` c :: m b = m ([a]->[a])
16:56:53 <monochrom> which is ripe for one more ap.
16:57:04 <et09> got it 
17:13:53 <robertkennedy> Is there any sort of Compact or other serialization library for extremely recursive data? Ie where I might hope to send the list `lst = 3 : lst`?
17:14:30 <robertkennedy> > let lst = 3 : lst in take 10 lst 
17:14:32 <lambdabot>  [3,3,3,3,3,3,3,3,3,3]
17:15:22 <Welkin> how would you serialize an infinite list?
17:15:36 <ertes> robertkennedy: https://hackage.haskell.org/package/data-reify
17:15:52 <robertkennedy> Well `lst = 3 : lst` serialized it pretty well
17:15:55 <robertkennedy> Ty
17:16:17 <ertes> robertkennedy: however: https://ro-che.info/ccc/9
17:16:30 <monochrom> I like that comic too :)
17:16:56 <ertes> robertkennedy: what you're asking for is called observable sharing, and it's an IO effect
17:17:47 <monochrom> Hrm, where is the doc for DeRef?
17:18:00 <monochrom> Err nevermind! Associated type.
17:18:42 <monochrom> But you have to write your own code for recognizing cycles in your own data structures.
17:19:58 <Guest14204> Just wonder is this declaration make sense? data T1 = TypeA | TypeB data T2 = TypeC  data T3 = T1 | T2 It complies but I can't really use it
17:20:27 <glguy> Guest14204: You've defined two different T1 and T2 constructors
17:20:35 <robertkennedy> Hmmm. Hopefully I can do that. The usecase I'm looking at is essentially foreign indexes for SQL tables, and its definitely a Graph structure, so this is promising 
17:20:36 <glguy> The first two defined type constructors
17:20:40 <glguy> and the second two live at the value level
17:21:23 <glguy> data TypeConstructorHere = ValueConstructorHere
17:21:54 <Guest14204> I see, so T1 and T2 in the second expression is constrctors and not the type in the first expression ....
17:22:09 <glguy> they're values and not types
17:22:13 <glguy> all the T1 and T2s are constructors
17:22:37 <robertkennedy> Yeah, you likely want something like `data T1 = T11 | T12; data T2 = T2; data T3 = T31 T1 | T32 T2`
17:22:51 <glguy> right
17:24:47 <Guest14204> My original intent is something like data T1 = apple | orange, data T2 = pear, and data T3 = apple | orange | pear - seems like I need to rethink the whole apporach
17:25:31 <ertes> Guest14204: one option is to use (Either T1 T2) in place of T3
17:25:56 <Guest14204> Either only has left and right, but I need more the two
17:26:13 <ertes> Left Apple :: Either T1 T2
17:26:17 <ertes> Left Orange :: Either T1 T2
17:26:23 <ertes> Right Pear :: Either T1 T2
17:26:30 <Guest14204> oh, like a tree ...
17:26:40 <ertes> more like nested choice
17:26:46 <monochrom> It is always a good idea to rethink the whole approach. :)
17:27:00 <Guest14204> thx - back to drawing board.
17:27:28 <monochrom> in the twilight zone of decision trees
17:27:31 <ertes> Guest14204: side note:  T1 is basically Bool, and T2 is basically ()
17:27:33 <joe9> I get this error: 57,1)-(62,5): Non-exhaustive patterns in function processMessage -- I have a blank pattern that can match against any type. But, still I get that message.
17:28:14 <ertes> Guest14204: and then T3 is basically Ordering, a 3-value type
17:28:58 <ertes> Guest14204: call Bool and T1 collectively "2", and call T2 and () collectively "1"
17:29:07 <ertes> then read "Either" as "plus" =)
17:29:41 <joe9> got it. sorry for the bother.
17:29:58 <monochrom> data Six = Six Bool Ordering
17:30:12 <ertes> then you might call "Either T1 T2" or "Either Bool ()" "2 + 1"
17:30:26 <ertes> and that of course is Ordering, also known as "3" =)
17:31:05 <ertes> (i'm using slightly imprecise language)
17:31:07 * monochrom summons Russell and Whitehead to rewrite their book in Haskell
17:31:08 <Guest14204> humm interesting, so that is the sum type right? I was thinking about that but the syntax caught me up
17:31:08 <robertkennedy> Guest14204: maybe vinyl has this type? You're looking for extensible sum types, it seems. I've done a lot of research recently into extensible product types
17:31:23 <ertes> Guest14204: yeah, that's why it's called "sum"
17:32:30 <Guest14204> is vinyl a library?
17:33:10 <ertes> vinyl is an exercise in forcing haskell to do multiple things it sucks at
17:33:30 <kadoban> Hah, I like that description.
17:33:55 <hpc> "Extensible records for Haskell with lenses using modern GHC features" - yeah, sounds about right
17:34:20 <robertkennedy> The pattern your describing might be exactly right - for instance, if you want `data Fruit = Peach | Apple; data Vegetable = Lettuce; data GoodFood = Fruit Fruit | Vegi Vegetable`
17:34:56 <hpc> maybe someday after we have extended the type system to the point that it can make coffee just right, we'll make a good record system ;)
17:35:12 <ertes> the outcome is what you might expect…
17:35:12 <robertkennedy> If you ever use that Fruit and Vegis are different, that's probably exactly what you want. But if you are just dividing them for modularity, it will feel wrong
17:35:14 <ertes> "interesting"
17:35:15 <Guest14204> the fruit / veg example is what I am trying
17:37:10 <Guest14204> when I try something like fun :: GoodFood -> String, then try to pattern match e.g. fun Peach = "Peach" ghc flags an error
17:37:55 <ertes> Guest14204: fun (Fruit Peach) = …
17:38:23 <Guest14204> so that's is what I am missing ... !!
17:38:25 <ertes> remember that you need to pattern-match on constructors with proper nesting
17:38:46 <ertes> if your type is (Either A B), your outermost constructors will be Left and Right
17:39:01 <Guest14204> going to give it a try. brb
17:39:02 <ertes> if your type is GoodFood, your outermost constructors will be Fruit and Vegi
17:39:19 <robertkennedy> Yeah, you'll want to do something like `fun goodfood = case goodfood of {Vegi v -> funV v; Fruit f -> funF f}
17:40:08 <Guest14204> ah, vinyl is extensible record, witty ...
17:40:32 <ertes> beware of libraries that depend on the 'singletons' library
17:40:51 <ertes> they tend to be…  "interesting"
17:41:05 <monochrom> I have just discovered the best slogan for that library.
17:41:14 <robertkennedy> Or, as ertes says, `case goodfood of {Fruit Peach -> ...}`
17:41:27 <monochrom> Extensible record for an inextensible language using a lot of extensions.
17:42:05 <ertes> … using dependent types in a non-dependent language
17:42:12 <monochrom> \∩/
17:42:22 <robertkennedy> http://ircbrowse.net/browse/haskellNothing that Zerg does early will kill you, and then [...] late game you're INnoVation so nothing Zerg can do late will kill you - @Artosis
17:42:30 <robertkennedy> Oh sorry my bad
17:42:45 <robertkennedy> http://ircbrowse.net/browse/haskell
17:42:58 <robertkennedy> Seems dead - anyone know who to contact?
17:43:36 <sm> still chris done AFAIK, but he hasn't been too responsive lately
17:43:41 <ertes> robertkennedy: the operator is aware…  IIRC he's looking for a new admin
17:51:07 <athan> Are there any race conditions for using StateT vs. an STM TVar in a -threaded application?
17:52:35 <Guest14204> thx everyone, I think I got the Fruit/Vegi thing working
17:53:04 <lyxia> athan: How can you compare these? There is no concurrency involved in StateT.
17:53:05 <Guest14204> I didn't expect / know I need to use an outer constructor
17:53:36 <robertkennedy> athan: if your StateT is in STM it would act the same as any other STM yeah?
17:57:55 <robertkennedy> What's​ the canonical motivation for `fix`?
17:58:23 <mniip> motivation?
17:58:25 <ChaiTRex> It's from functional programming.
17:58:50 <ertes> robertkennedy: general recursion
17:58:54 <jchia> I think maybe robertkennedy means use case
17:58:55 <ChaiTRex> You can, for example, make unnamed (anonymous) recursive functions with it.
17:59:57 <robertkennedy> ChaiTRex: could you give an example?
18:00:55 <ertes> robertkennedy: simply typed lambda calculus is not turing-complete, and as such can be used as a consistent logical calculus
18:01:04 <ChaiTRex> Here's not a very good one:
18:01:08 <mniip> > fix ((1 :) . scanl (+) 1)
18:01:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:01:12 <ertes> robertkennedy: a fixed-point combinator makes it turing-complete
18:01:17 <robertkennedy> Yeah, use case is fine, but Wadler mentioned it as an impossible function in some calculuses. So I wondered what it might add
18:01:24 <ChaiTRex>  > (fix (\f x -> if x == 1 then 1 else f (x - 1))) 2
18:01:35 <ertes> robertkennedy: yes, that's exactly what i'm referring to
18:01:41 <ChaiTRex> > (fix (\f x -> if x == 1 then 1 else f (x - 1))) 2
18:01:43 <lambdabot>  1
18:01:54 <ertes> robertkennedy: consider fix id = ⊥, an infinite loop
18:02:19 <mniip> fix id :: a *gasp*
18:03:38 <ChaiTRex> > (fix (\f x -> if x == 1 then True else if even x then f (div x 2) else f (3*x + 1))) 100
18:03:41 <robertkennedy> mniip: that fib sequence is insanity
18:03:41 <lambdabot>  True
18:03:49 <ChaiTRex> The Collatz whatsit ^
18:04:06 <ertes> > fix (\r x y -> x : r y (x + y)) 0 1
18:04:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:04:19 <ertes> robertkennedy: ^ here is an easier one
18:05:00 <robertkennedy> ChaiTRex so there you're fixing the function, right? Is that the normal case you see? The fix examples all use ie `fix cos = 0.43791694940` or whatever
18:05:05 <robertkennedy> > fix cos
18:05:11 <ertes> robertkennedy: or try this:  main = fix (\again -> putStrLn "Hello!" >> again)
18:05:11 <lambdabot>  mueval-core: Time limit exceeded
18:05:46 <ChaiTRex> robertkennedy: fix (\f args -> you can use f here, even though it's not named externally) is the main case I see.
18:06:19 <ChaiTRex> robertkennedy: There are other cases, though, as you've seen with the Fibonacci one.
18:06:23 <ertes> robertkennedy: challenge: define 'fix' without using recursion, and without referring to any existing recursive function
18:06:47 <ertes> you may use lambdas freely
18:07:10 <mniip> can one use ADTs?
18:08:22 <robertkennedy> See, my intuition was `fix f x = let x' = f x in if x' == x then x else fix f x'`, but that's clearly not what's being fixed
18:08:25 <athan> aie karumba, sorry lyxia & robertkennedy 
18:08:47 <erisco> at some point we have to give up this class hierarchy, don't we?
18:08:54 <erisco> Monoid, Alternative, MonadPlus
18:09:00 <athan> I was imagining `StateT s m a ~ MonadBaseControl IO m => ReaderT (TVar s) m a`
18:09:04 <ertes> mniip: not sure, but i think ADTs can be allowed, unless i'm missing something
18:09:13 <mniip> without adts it's impossible
18:09:14 <ertes> robertkennedy: 'fix' has only one argument
18:09:14 <mniip> I think
18:09:15 <athan> but I'm off :) thank you
18:09:26 <ertes> mniip: it better be =)
18:09:48 <robertkennedy> > :t fix
18:09:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:09:55 <robertkennedy> :t fix
18:09:56 <lambdabot> (a -> a) -> a
18:10:09 <robertkennedy> Okay I'll be back
18:10:25 <ChaiTRex> > fix (flip div 2) 1
18:10:28 <lambdabot>  error:
18:10:28 <lambdabot>      • Could not deduce (Integral (t0 -> t1))
18:10:28 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
18:10:36 <NextHendrix> :t (.) . (.) . (.) . (.)
18:10:38 <lambdabot> (b -> c) -> (a3 -> a2 -> a1 -> a -> b) -> a3 -> a2 -> a1 -> a -> c
18:10:52 <ChaiTRex> @unpl (.) . (.) . (.) . (.)
18:10:52 <lambdabot> (\ x g x0 x1 x2 x3 -> x (g x0 x1 x2 x3))
18:11:38 <NextHendrix> lol
18:11:41 <lyxia> robertkennedy: fix f is f's all the way down: f (f (f ...))
18:11:58 <ChaiTRex> > fix (flip div 2)
18:12:01 <smw_> Hi all. I am trying haskell for the first time. I am trying to create an infinite fib sequence. What is wrong with the following code? fib a b = (a+b):(fib b a+b). I see the occurs check error, but I don't understand why.
18:12:04 <lambdabot>  mueval-core: Time limit exceeded
18:12:07 <NextHendrix> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap map map map fmap
18:12:15 <lambdabot> error:
18:12:15 <lambdabot>     • Couldn't match type ‘f0 a1 -> f0 b1’ with ‘[[a -> b]]’
18:12:15 <lambdabot>       Expected type: ((((((((((a -> b) -> [a] -> [b])
18:12:27 <lyxia> smw_: fib b (a+b) <- you forgot parentheses
18:12:42 <ertes> smw_: fib b a + b = (fib b a) + b
18:12:47 <smw_> lyxia: ah
18:13:55 <smw_> lyxia: it worked :-)take 5 fib'
18:13:55 <smw_> [1,2,3,5,8]
18:14:16 <mniip> :t \f -> (\y -> f (unFix y y)) (Fix (\x -> f (unFix x x)))
18:14:18 <lambdabot> (t -> t) -> t
18:14:38 <smw_> ertes: interesting. I didn't know you could do that.
18:15:02 <hololeap> i'm looking for an abstraction that can be found in the standard libraries that works like until, but instead of (a -> a) it takes (a -> m a) where m is a monad
18:15:09 <EvanR> smw_: occurs check error, thats when inference sees a type that contains itself, an infinite type
18:15:09 <ertes> smw_: it's not really "doing" anything…  i'm just telling you how the compiler interprets "fib b a + b" =)
18:15:27 <EvanR> its probably not what you intended, so its an error
18:15:33 <smw_> ertes: ah
18:15:48 <hololeap> and basically binds recursively until the condition holds, in which case it just runs pure
18:15:51 <lyxia> hololeap: take a look at monad-loops
18:16:00 <smw_> ertes: I am up to the recursion part of learn you a haskell. I have no idea what I am doing.
18:16:15 <smw_> ertes: apparently, I don't know basic order of operations yet.
18:16:25 <hololeap> lyxia: oh, i actually have that installed :)
18:16:34 <ertes> smw_: just keep in mind that function application binds more tightly than any operator
18:16:53 <smw_> ertes: got it. That is helpful.
18:17:22 <ertes> smw_: and you can always ask GHCi, for example:  :i +
18:17:28 <ertes> tells you: infixl 6 +
18:17:38 <ertes> priority 6, left-associative
18:17:48 <ChaiTRex> :i +
18:17:59 * ChaiTRex chides lambdabot.
18:18:13 <hololeap> botsnack
18:18:23 <ChaiTRex> @botsnack
18:18:24 <lambdabot> :)
18:19:15 <mniip> beep boop
18:20:19 <smw_> ertes: one more question before I go back to learn you a haskell and project euler: How can I create a runnable haskell script? It hates it when I have a naked expression at the top level.
18:20:59 <mniip> you'll need an IO action
18:21:11 <mniip> main = do {- something -}
18:21:12 <et09> :t (Just (+)) <*> (Just 5) 
18:21:14 <lambdabot> Num a => Maybe (a -> a)
18:21:49 <ChaiTRex> main = print $ expression to evaluate and print here
18:22:09 <smw_> mniip: action? That sounds awfully imperative :-). Anyways I am not there yet so I will wait for it to come in the book.
18:22:20 <et09> :t (Just (+)) <*> (Just 5) <*> (Just 3)
18:22:21 <lambdabot> Num b => Maybe b
18:22:39 <mniip> smw_, you could put 'main = print (expr)'
18:22:46 <et09> :t fmap (\x -> x + 5) $ (Just (+)) <*> (Just 5) <*> (Just 3)
18:22:48 <lambdabot> Num b => Maybe b
18:22:53 <mniip> would make the program output a Show-able value
18:22:54 <smw_> mniip: awesome, that I can do :-)
18:22:55 <et09> wait what 
18:23:15 <et09> oh right.  now how do i actually extract the alue
18:23:30 <et09> does it have to be pattern matching
18:24:17 <robertkennedy> smw_ what pe problems you working through?
18:25:27 <smw_> robertkennedy: well, I did number 1 in a single line in the repl. Just got a working infinite fib sequence to answer problem 2
18:26:19 <et09> what's the non-infix name for <*> 
18:26:28 <kadoban> ap
18:26:32 <smw_> Any way to make ghci run the given script then exit immediately?
18:26:37 <kadoban> Or (<*>) of course
18:26:41 <et09> it's ap ??
18:26:54 <et09> oh god.  of course
18:26:56 <kadoban> :t ((<*>), ap)
18:26:58 <lambdabot> (Applicative f, Monad m) => (f (a1 -> b1) -> f a1 -> f b1, m (a -> b) -> m a -> m b)
18:27:03 <kadoban> Yep
18:27:14 <et09> this language, whew 
18:28:34 <mniip> pff
18:28:47 <mniip> @let data Apply (f :: k -> *) (a :: k) = Apply { unApply :: f a }; data FlipT (c :: m -> l -> *) (b :: l) (f :: k -> m) (a :: k) = FlipT { flopT :: c (f a) b }
18:28:49 <lambdabot>  Defined.
18:28:49 <et09> wait so ap is the monadic version, <*> is the applicative version?
18:29:11 <pacak> :t ap
18:29:13 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:29:17 <mniip> :t FlipT $ FlipT $ FlipT $ FlipT $ FlipT $ Apply (1,2,3,4,5,6)
18:29:18 <lambdabot> (Num b1, Num b, Num b2, Num b3, Num b4, Num a) => FlipT (FlipT (FlipT (FlipT (FlipT Apply b1) b) b2) b3) b4 (,,,,,) a
18:29:26 <geekosaur> well, sort of. before there was Applicative we put them in Monad, so ap has a Monad constraint (and will keep it because the retrofit for Applicative instances is <*> = ap)
18:30:01 <et09> ah
18:31:36 <et09> what is FlipT 
18:32:07 <mniip> I just defined it above!
18:34:07 <et09> ah.  now what does what you wrote do, lol
18:34:45 <mniip> plumbing for indexed datatypes
18:35:54 <mniip> when working with type-indexed stuff you can often come across functions that derive some info from a type-index, but they don't care what type the index is provided with, so they have a type 'forall p. p Index -> Data'
18:36:01 <mniip> letting you substitute any 'p'
18:36:08 <mniip> one example is
18:36:13 <mniip> :t GHC.TypeLits.natVal
18:36:15 <lambdabot> GHC.TypeLits.KnownNat n => proxy n -> Integer
18:36:44 <mniip> the problem with that is that the index has to be the last argument of your 'p' datatype
18:36:48 <mniip> which is not always the case
18:37:17 <et09> you say 'index' and i think array index and db index 
18:37:33 <smw_> ertes: ok, so what did I fail now? https://pastebin.com/x0nP7856. It looks like it is unhappy that I didn't tell it what types to use?
18:37:42 <mniip> this is where FlipT, Apply, and Compose come in - the three can be used to construct an (isomorphic) wrapper where any part of the type you wish will be on the end
18:37:57 <EvanR> et09: this is index as in indexed family of something
18:38:05 <mniip> what EvanR said
18:38:10 <et09> https://wiki.haskell.org/GHC/Type_families this?
18:38:26 <EvanR> hmm. type families are more like type functions
18:39:35 <mniip> et09, does any of "GADT", "kind polymorphism", "higher rank type" ring a bell?
18:39:55 <et09> GADT.  and i know what polymorphism is in OOP
18:40:27 <mniip> sounds like you have much to learn then
18:40:40 <et09> yup
18:41:59 <mniip> (your guess at polymorphism was wrong)
18:42:07 <Lokathor> so are sin and cos and all that in radians?
18:42:16 <EvanR> yep
18:43:26 <et09> oh.  KP reminds me of TemplateHaskell 
18:44:02 <NextHendrix> atan2 is bae
18:44:37 <EvanR> bae?
18:50:52 <ski> et09 : see "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
18:51:36 <ski> et09 : that talks about different senses of the word "polymorphism"
18:52:02 <et09> this is some kind of seminal paper isn't it
18:53:10 <mniip> welcome to haskell
18:53:18 <mniip> you'll be reading papers all the time
18:53:23 <et09> i've been writing haskell for 10 years lol
18:53:49 <ski> et09 : if you're unfamiliar with type systems, then perhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> might also be interesting
18:53:55 <ski> ok
18:54:48 <mniip> cool
18:54:49 <ski> there's also an "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> which talks about OO and closures
18:55:16 <et09> ok, i'll save these
18:55:50 <sm> any particular known performance regressions in emacs-25.2.1, compared to 25.1-ish ? Certain things seem to hang more (eg half a minute plus while doing something in list-packages), and cursor movement begins to pause every second or so in some buffers
18:56:18 * ski points in the direction of #emacs
18:56:37 <sm> argh, apologies
18:56:41 <mniip> hey sm
18:56:51 <mniip> mind a PM?
18:56:56 <sm> hi mniip, what's up ?
18:57:11 <robertkennedy> mniip: why do you want to move the target type to the end?
18:57:50 <mniip> robertkennedy, 1494293782 [04:36:22] <mniip> the problem with that is that the index has to be the last argument of your 'p' datatype
18:58:44 <ski> smw_ : .. it's meant to sound imperative
19:00:11 <robertkennedy> Ah, they are newtypes and not data types, gotcha
19:01:09 <smw_> ski: sorry, just a joke. Anyways, I am giving up on haskell for tonight. I have a 3 hour "haskell 101" class tomorrow to try it out :-)
19:01:36 <ski> no worry. take your time
19:04:13 <smw_> ski: I am finding haskell very difficult due to the material I am learning from. A lot of the concepts are not difficult for me thanks to experience with many of these things in other languages. I guess my problem is the book I am working from doesn't properly explain the code samples. That, and I am impatient :-)
19:04:49 <et09> smw_: Constants are 16-bit values only and may range from 0 to 65535. They are prefixed by a mesh (#). Caution! Under no circumstances confuse the mesh with the interleave operator, except under confusing circumstances!
19:05:18 <smw_> et09: wrong person?
19:05:25 <Welkin> lol
19:05:30 <et09> no, it's an old joke from the intercal manual 
19:06:17 <smw_> et09: you haskell people are all weird :-P
19:06:24 <Cale> smw_: When I started out back in 2001 or so, it took me about 2 months to feel like I could really be productive, and about a year to be comfortable.
19:06:42 <Cale> So don't be too surprised if it takes a bit of getting used to.
19:06:44 <Welkin> smw_: it will takes a couple months at least
19:07:00 <smw_> better error messages would be awesome.
19:07:10 <Welkin> and one or two non-trivial (medium sized) projects
19:07:30 <Welkin> smw_: the error messages are actually very good, you just need to get used to/learn how to read them
19:07:31 <et09> smw_: the error messages take getting used to as well.  they all deal with the same academic discipline 
19:07:38 <Welkin> it also depends on the library
19:07:39 <et09> jinx
19:07:43 <Welkin> some have better ones than others
19:08:08 <smw_> et09: yeah, but I never had a formal education :-)
19:08:22 <et09> me neither, that's why i'm in here right now
19:08:41 <et09> only reason i have the first clue is cause i've been using xmonad for a decade
19:09:22 <Welkin> formal education in what?
19:10:05 <smw_> Welkin: um... anything past community college?
19:11:23 <smw_> So, anyone know what I did wrong here? https://pastebin.com/Fx6c88pe
19:11:36 <glguy> You used pastebin.com
19:11:52 <Lokathor> :P
19:11:57 <glguy> 4e6 is a floating-point literal
19:12:07 <glguy> but you're wanting to work with integers
19:12:25 <glguy> There's an extension you can enable to allow 4e6 as an integer literal, but it's not on by default
19:12:33 <smw_> glguy: I see
19:12:35 <isovector> heya! i'm looking for a function `Prism' a b -> b -> a` which i feel like must be stupid and obvious, but i can't seem to find it
19:12:48 <glguy> If you added {-# Language NumDecimals #-} to the top of your file it would work
19:13:38 <glguy> Or change 4e6 to 4 * 10^6
19:13:51 <pacak> > review _Left 100500
19:13:53 <lambdabot>  Left 100500
19:14:13 <smw_> glguy: well, it works. Just solved project euler #2 :-)
19:14:35 <isovector> pacak: thanks! knew it was dumb :)
19:14:38 <smw_> glguy: now, I am going to go break it again and try to understand that error message.
19:14:48 <glguy> smw_: In the future it'll help to include the error message in your paste when you have questions about an error
19:14:54 <Lokathor> smw_, note that Project Euler is usually not a good way to learn a new programming language
19:15:02 <smw_> glguy: good to know
19:15:15 <Lokathor> most of the questions are more about knowing the right math trick than they are about knowing how to express that in a progamming language
19:15:26 <smw_> Lokathor: why not? I mostly do the same project euler questions for each programming language I learn.
19:15:44 <smw_> Lokathor: I know the math tricks for the ones I do :-)
19:15:45 <glguy> I liked the Advent of Code problems more for having some simple programming exercises to play with
19:16:07 <Lokathor> Advent of Code was good it seemed, I did a few this year
19:16:16 <Lokathor> well, "this last one"
19:16:47 <EvanR> :t identity
19:16:49 <lambdabot> error:
19:16:49 <lambdabot>     • Variable not in scope: identity
19:16:49 <lambdabot>     • Perhaps you meant data constructor ‘Identity’ (imported from Control.Monad.Identity)
19:17:40 <Lokathor> smw_, one thing to note if you're doing Euler (or other computationally intense things) is that ghci is extremely slow compared to a compiled binary in many cases
19:18:00 <Lokathor> because it can't do particular optimizations, so you get bad GC performance and stuff like that
19:18:31 <smw_> Lokathor: makes sense. I gave up on ghci because I couldn't figure out how to get it to just run what is in the file and quit.
19:18:57 <Lokathor> ah, it's more like a python shell than like a script runner. if you want to just "run a file" try the runhaskell command
19:19:52 <smw_> Lokathor: sweet
19:23:57 <smw_> Lokathor: I just found real world haskell. From a quick skim it looks more like something I would like :-)
19:24:08 <Lokathor> ah
19:24:08 <Lokathor> well
19:24:19 <smw_> Lokathor: ?
19:24:31 <Lokathor> it's okay as far as "free" goes, but if you want to put down the 60 bucks, http://haskellbook.com/ is your best bet
19:25:17 <smw_> Lokathor: why this one instead?
19:25:19 <glguy> That's certainly one of the choices. There's also Programming in Haskell 2nd ed by Hutton
19:26:46 <Lokathor> smw_, RWH has suffered a bit from code rot in places, for one. and it also lacks "homework problems", which Haskell Book has, and those are the real edge I think
19:26:58 <glguy> That one's nice in that it gets you through the language in about 300 pages and it ends in a neat section on "calculating compilers" by incrementally transforming a simple program into an efficient one
19:27:20 <Lokathor> well, okay, it has some exercises, but often not of the tricky kind that give you good insights
19:31:20 <sm> HTAC (Haskell Tutorial And Cookbook) is also good for some
19:40:10 <dmj`> smw_: Brent Yorgey’s resources are great as well
19:40:15 <dmj`> @typeclassopedia
19:40:15 <lambdabot> Unknown command, try @list
19:40:24 <dmj`> @google typeclassopedia
19:40:25 <lambdabot> https://wiki.haskell.org/Typeclassopedia
19:40:43 <smw_> dmj`: will look
19:59:53 <Lokathor> https://hackage.haskell.org/package/haskeline-0.7.4.0/docs/System-Console-Haskeline.html#v:getExternalPrint
20:00:24 <Lokathor> I'm not clear how I send this off to an async (possibly a lifted async), since i can only obtain it after I enter the InputT
20:00:52 <geekosaur> you don't want to do that
20:00:59 <geekosaur> you *really* don;t want to do that
20:01:13 <geekosaur> terminals have ONE cursor position. you expect it to sanely share between threads?
20:01:42 <geekosaur> also one source of input and one output stream. not one per thread
20:02:12 <Lokathor> but it says right there "and may be run concurrently with user input without affecting the prompt."
20:03:06 <geekosaur> oh, it's some kind ogf wrapper that you payfor on every I/O operation. ok, carry on...
20:03:21 <EvanR> ogf?
20:03:29 <geekosaur> "of"
20:03:51 <geekosaur> point being that now every operation whether through that wrapper or not has to check a terminal mutex
20:04:12 <Lokathor> i think haskeline is checking the terminal mutex even if you don't call that
20:04:23 <geekosaur> probably
20:04:28 <geekosaur> not great in any case
20:05:18 <geekosaur> but then I don't think they had any interest in performance since --- with the possible exception of cases where you'd want to use getExternalPrint, naturally --- the usual limiting case is the user on the other side of the terminal >.>
20:06:14 <Lokathor> okay, so... how do i pass the externalPrint to an async?
20:06:34 <geekosaur> I also don't know how tightly wedded it is to the InputT context... you may not be *able* to hand it off
20:07:35 <Lokathor> damn
20:08:02 <geekosaur> although the type suggests it "should" be okay, I guess? since if you needed that context it ought to be in the type instead of it being IO ()
20:08:48 <Lokathor> i think, if i had to guess, once the mutex check has been injected into the action it's fine
20:09:05 <geekosaur> which still leaves your question, but ... I suspect your use case is not the intended one. or, if you can't delay the thread start until after you call this, you must initialize the terminal earlier
20:09:08 <Lokathor> i made a similar thing to what they have without knowing it once, but it wasn't cross platform
20:09:26 <Lokathor> windows only i'm afraid
20:09:30 <geekosaur> that is likely a good idea anyway as you will get unfortunate results if you try to use it before you have the terminal in the mode it expects
20:09:50 <geekosaur> which is to say, just to model the terminal properly it *ought* to have made the type InputT m IO () instead of IO ()
20:10:47 <geekosaur> character at a time mode may change both input and output termios settings, which will affect how the output function works
20:12:00 <Lokathor> well you can do something like this https://github.com/Lokathor/galaxy-break/blob/master/src/ConcurrentConsole.hs
20:12:06 <Lokathor> but that version basically only works on windows right now
20:12:48 <geekosaur> yeh, on Windows it's different
20:12:59 <EvanR> a haskell-like terminal lib for stuff like nethack would be cool
20:13:13 <geekosaur> unix terminal handling is a generally messy and frustrating thing
20:13:18 <Lokathor> you mean HScurses, vty, etc?
20:13:28 <geekosaur> partly for historical reasons
20:13:30 <geekosaur> the interface those have to talk to
20:13:37 <geekosaur> which is why they end up sucking a bit
20:13:43 <EvanR> i havent heard good things about HScurses
20:13:45 <geekosaur> also the interface haskeline talks to, so...
20:14:09 <geekosaur> well, curses is a mess, and only some of that is because of termios. but some of it is because of termios
20:14:47 <Lokathor> EvanR, I made a curses wrapper using inline-c, and it worked 99% like a dream
20:14:59 <Lokathor> but if you resized your terminal the program would instantly crash :/
20:15:04 <EvanR> nice
20:15:24 <Lokathor> couldn't get the system signal stuff to interface right
20:15:51 <EvanR> maybe a thing that looks like a terminal lib for stuff like nethack
20:16:03 <Lokathor> what i wanted was
20:16:04 <EvanR> which doesnt really do any real terminal anything because its so insane
20:16:11 <Lokathor> haskeline reading in 1 character at a time
20:16:25 <Lokathor> https://hackage.haskell.org/package/haskeline-0.7.4.0/docs/System-Console-Haskeline.html#v:getInputChar
20:16:31 <Lokathor> says that you can do that
20:16:38 * geekosaur occasionally wants to write a terminal interface in haskell just so he can have a type Terminal t r a i n w r e c k
20:16:39 <Lokathor> and then ansi-terminal doing output
20:17:04 <Lokathor> cause guys, check this: https://gist.github.com/Lokathor/b9275c459ad4707025587a96ecee86aa
20:17:33 <Lokathor> that ansi-term snippit gives you output like this: https://www.dropbox.com/s/j7l511x2rf8xi1i/Screenshot%202017-05-08%2000.01.39.png?dl=0
20:18:17 <Lokathor> if you just shove enough output at once (all ~24 lines), you can "emulate" curses in a cross platform way via ansi-terminal and haskeline
20:18:45 <Lokathor> ansi-terminal also allows clearing of the screen, setting cursor location, etc
20:20:19 <geekosaur> anyway, my advice is initialize the terminal and get your InputT early, before spawning threads. because if you were to use that callback before the terminal is initialized, you will probably be unhappy
20:20:34 <Lokathor> well of course
20:20:45 <Lokathor> you can't get handed that callback before the InputT starts anyway :P
20:21:03 <geekosaur> exactly. I think that's the point
20:21:41 <Lokathor> so once you're inside InputT, how does one call async?
20:22:00 <Lokathor> can you just liftIO on it?
20:22:08 <kamyar> Hello guys
20:22:25 <Lokathor> last time i tried to lift async, it lead to an entirely other package i didn't know exited that did strange things
20:22:27 <EvanR> hi
20:22:29 <Lokathor> kamyar, hey
20:22:29 <kamyar> Please take a peek on my code
20:22:31 <kamyar> http://lpaste.net/355336
20:23:09 <kamyar> I just wanna use Reader MOnad to read redis and postgresql config and pass pool to repository module
20:23:45 <kamyar> as you can see there are 2 functions using redis
20:24:01 <Lokathor> kamyar, do the version that doesn't user Reader at all
20:24:04 <kamyar> and there is a module 'Repository' which uses postgresql pool
20:24:17 <Lokathor> just pass around your handle to the connection pool all the time, that should be simple enough in this case I think
20:24:18 <kamyar> Lokathor: Why?
20:24:52 <Lokathor> because MonadReader isn't getting you much value added if your call stack isn't too deep, and i don't think it's too deep here
20:25:59 <kamyar> Lokathor: So I have to change redis functions to get redis config, and Repository module funcitons to get postgresql pool
20:25:59 <Lokathor> right now most of your stuff is just in IO
20:26:10 <Lokathor> converting that to a monad stack at all is a fair deal of work
20:26:36 <kamyar> Lokathor: Also I have to change handler funciton signatore to get pool
20:27:57 <EvanR> https://pbs.twimg.com/media/C8QejJ1VoAAQgDE.jpg
20:28:48 <geekosaur> Lokathor, yes, I'd think so
20:28:57 <geekosaur> (re async)
20:30:32 <kamyar> Lokathor: What if I define some types to hold my stuff and change functions to get them in
20:32:09 <Lokathor> I'm not fully familiar with your program, but I can say that "do the first version without using Reader then see if you really need it later" is always solid advice
20:34:25 <Lokathor> :t liftIO withAsync
20:34:26 <lambdabot> error: Variable not in scope: withAsync :: IO a
20:35:09 <Lokathor> :t liftIO Control.Concurrent.Async.withAsync
20:35:11 <lambdabot> error:
20:35:11 <lambdabot>     • Couldn't match expected type ‘IO a’
20:35:11 <lambdabot>                   with actual type ‘IO a0
20:35:29 <Lokathor> geekosaur, trying to lift async gives you that insane type error thing ^
20:35:42 <Lokathor> a proper ghci can tell you the full story and such
20:36:02 <mniip> withAsync sounds like a higher rank type
20:36:19 <mniip> :t Control.Concurrent.Async.withAsync
20:36:20 <lambdabot> IO a -> (Control.Concurrent.Async.Async a -> IO b) -> IO b
20:36:25 <Lokathor> yeah, it uses bracket and stuff
20:36:31 <EvanR> i dont see why there would be a problem spawning threads with async inside a MonadIO monad
20:36:35 <mniip> :t liftIO
20:36:36 <lambdabot> MonadIO m => IO a -> m a
20:36:53 <Lokathor> EvanR, type mismatch is all :P
20:36:57 <mniip> ah, here's the problem
20:37:07 <EvanR> not a higher rank type, but a higher order function
20:37:28 <mniip> EvanR, yeah but the error message suggested rankn
20:37:38 <EvanR> bad error msg, bad
20:38:02 <geekosaur> depends on the context of the error message
20:38:07 <Lokathor> https://hackage.haskell.org/package/lifted-async-0.9.1.1/docs/Control-Concurrent-Async-Lifted.html
20:38:11 <Lokathor> so there's this package
20:38:43 <Lokathor> but last time i had to use it, someone else told me how to make the MonadBaseControl dealybooper
20:40:03 <Lokathor> i've no real idea how it works :/ something about shifting things around and then reversing them later
20:44:22 <Lokathor> even dropping the bracket stuff, liftIO Control.Concurrent.Async.async doesn't work because it's still higher order.
20:49:25 <MarcelineVQ> doesn't work?
20:49:36 <Lokathor> doesn't type check
20:49:39 <Lokathor> :t liftIO Control.Concurrent.Async.async
20:49:40 <lambdabot> error:
20:49:40 <lambdabot>     • Couldn't match expected type ‘IO a’
20:49:40 <lambdabot>                   with actual type ‘IO a0 -> IO (Control.Concurrent.Async.Async a0)’
20:49:52 <MarcelineVQ> that's an arity issue isn't it
20:49:58 <Lokathor> is it?
20:50:03 <MarcelineVQ> liftIO . async ?
20:50:35 <Lokathor> hmm
20:50:57 <geekosaur> that was what I meant by context earlier
20:51:08 <geekosaur> :t liftIO . Control.Concurrent.Async.async
20:51:09 <lambdabot> MonadIO m => IO a -> m (Control.Concurrent.Async.Async a)
20:51:15 <Lokathor> that blasted dot
20:51:35 <geekosaur> without the dot, you do indeed have some higher order and probably impredicative monstrosity
20:58:43 <Lokathor> hmm
20:59:08 <Lokathor> http://lpaste.net/355347
21:03:19 <Lokathor> a billion curses
21:03:34 <Lokathor> even mixing in ansi-terminal stuff, it doesn't print in colors you set
21:04:14 <Lokathor> eg, http://lpaste.net/355348
21:09:59 <Lokathor> perhaps if you do the thing where you send the control sequences as part of the string, but that doesn't work on windows so i don't care
21:10:18 <EvanR> >_<
21:10:33 <EvanR> might should have just made a terminal-looking thing in SDL
21:10:43 <Lokathor> yeah
21:11:23 <Lokathor> that's why i was making that dumpy triforce actually... I did a lesson of opengl and i'm hoping to make it into a 2d grid of glyphs thing
21:11:45 <Lokathor> (yes i could use SDL, but then i'd need the SDL.dll to be packaged too, so i'll learn a little opengl along the way)
21:12:14 <EvanR> sdl or glfw
21:12:29 <Lokathor> GLFW-b is making my window
21:12:50 <Lokathor> but it sure seems to be fine without a backing dll on windows, or at least said dll is part of the system files enough that i could assume the user will have it
21:13:13 <Lokathor> of course, then there's no sound support and stuff, oh well
21:13:30 <EvanR> port audio bindings
21:13:47 <EvanR> actually what rogue likes have sound
21:14:05 <Lokathor> that too
21:14:16 <Lokathor> i mean the end user of the library can still add audio via whatever audio library they want
21:14:57 <Lokathor> but i think i could even package the font bitmap straight into the EXE if i wanted to have an executable that you could just run from anywhere
21:15:48 <Lokathor> convert the font data into a huge bytestring, shove that as a literal into a module the program compiles in, convert that at runtime instead of loading form disk. ugly, but would work i think?
21:16:44 <EvanR> sounds good
21:19:04 <Lokathor> it's all just bytes in the end
21:19:49 <EvanR> bytes are just another abstract data type
21:20:08 <Lokathor> main = do { a <- doThing; doOtherThing (unsafeCoerce a)}
21:20:26 <EvanR> o_O
21:34:23 <Lokathor> https://www.dropbox.com/s/3rokj1l14lmtn3f/Screenshot%202017-05-08%2022.32.42.png?dl=0
21:35:28 <EvanR> woo colors
21:37:20 <Lokathor> sadly, this only works on windows at the moment
21:39:21 <Lokathor> specifically in the cmd prompt, not in other forms of prompt
21:54:23 <mniip> Lokathor, can't you just load ansi.sys
21:54:56 <Lokathor> mniip, i don't know what package that module is from
21:55:11 <mniip> dos?
21:55:31 <Lokathor> well, the goal is to have a cross-platform version
21:56:02 <Lokathor> i mean ansi-terminal already does colors, you just can't mix ansi-terminal with haskeline it seems
21:56:10 <mniip> ansi.sys translated ansi escape sequences into dos formatting interrupts so
22:00:43 <Lokathor> hmm
22:01:28 <Lokathor> i don't see a dos package on hackage...
22:08:34 <Lokathor> mniip, ^
22:09:06 <mniip> um
22:09:14 <mniip> I think you've misinterpreted me
22:09:31 <Lokathor> i'm starting to think the same
22:09:49 <mniip> I'm talking about DOS the operating system
22:14:31 <Lokathor> mniip, this would be more modern versions of windows :P
22:34:21 <reino4477> hi. will anyone help me to fix an error https://gist.github.com/GildedHonour/02007863f4c10fc611efcfc361507c6d ?
22:34:33 <reino4477> that's Spock
22:35:03 <reino4477> I've tried different ways to fix it, but...
22:35:04 <glguy> reino4477: It looks like part of the error message got cut of
22:36:03 <reino4477> glguy: updated
22:36:21 <reino4477> it's all about types mismatch
22:38:03 <glguy> That error message doesn't appear to match the code you pasted
22:39:10 <reino4477> ok. how do I properly return an html file from the "post" with the "do"?
22:40:16 <reino4477> post "/some_port_url" $ do ..........
22:52:09 <cocreature> ReinH: take a look at https://hackage.haskell.org/package/Spock-core-0.12.0.0/docs/Web-Spock-Action.html#v:html
22:52:34 <cocreature> eh sry, reino4477 already left and autocomplete broke
23:07:07 <reino4477> does anybody know how to capture POST parameters in Spock?
23:13:12 <cocreature> reino4477: do you want to capture query string parameters or the request body?
23:14:28 <reino4477> cocreature: no
23:15:29 <cocreature> … so what do you want to do?
23:16:10 <reino4477> capture  parameters of a POST
23:18:54 <cocreature> you can get the request body using "body" from Web.Spock.Action
23:19:34 <txx> Seems like Haskell is working its way "up" the chain of mathematical objects: https://en.wikipedia.org/wiki/Magma_(algebra)#/media/File:Magma_to_group2.svg
23:19:57 <reino4477> cocreature: thx
23:20:06 <txx> This creates issues w/ compatiblity: https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
23:20:18 <txx> Why not just work down from magna :P?
23:20:21 <txx> *magma
23:21:00 <cocreature> txx: because you can’t change history and Monoid was there before :)
23:21:15 <txx> Yes, but it's never too late to start
23:21:34 <cocreature> also Magma is not really a useful class
23:21:40 <txx> Don't think Magma, Quasigroup, or Loop exist yet
23:22:31 <cocreature> Haskell is still a programming language and not a way to formalize math so you have to think about what is actually useful in programs
23:23:34 <txx> Inb4 need to implement Axiom of Choice
23:24:39 <txx> Sure, well, the Functor-Applicative-Monad and Semigroup-Monoid proposals just made me smh at the necessary shoehorning things back in
23:25:27 <pacak> txx: Do you have any good examples of something that is Magma, but not Semigroup/Monoid?
23:25:55 <cocreature> pacak: (-) on integers
23:29:08 <pacak> Hmm... Good and useful example I wanted to say.
23:30:49 <cocreature> well things that are not associative are always awkward :)
23:35:06 <reino4477> what's the simpliest way to convert a json string to a map or tuple? preferably, without a 3rd party dependencies
23:36:15 <pacak> aeson?
23:36:30 <reino4477> why are you asking me?
23:37:02 <liste> reino4477: by using dependencies (the aeson library for json parsing)
23:37:16 <liste> @hackage aeson -- reino4477
23:37:16 <lambdabot> http://hackage.haskell.org/package/aeson -- reino4477
23:37:28 <reino4477> and without them?
23:37:47 <cocreature> write your own json parser
23:38:16 <pacak> > (\x -> (x, "1")) "Json string" -- in a tuple
23:38:19 <lambdabot>  ("Json string","1")
23:38:30 <reino4477> isn't there anything in haskell standard library?
23:38:40 <liste> reino4477: for json? no
23:38:47 <reino4477> thanks
23:39:31 <liste> the `base' library is minimal
23:39:39 <liste> you should really be using other libraries too
23:39:50 <cocreature> liste: they already left
23:40:19 <liste> cocreature: oh, I see, thanks. (I have part/join notifications off)
23:41:18 <cocreature> liste: weechat has a cool feature where it shows you part/join notifications only when the person talked within a configurable timespan (the last 5 minutes by default) :)
23:41:57 <kadoban> Yeah, my client has that as well, it's a nice feature.
23:42:14 <ongy> glirc has a cool feature where it collapses all join/part into one line :)
