00:00:09 <Cale> no, it just picks one
00:01:37 <sophiag> oh *if* you make sure they're equal
00:01:41 <sophiag> otherwise it's like Go
00:01:50 <Cale> Yeah, it's a precondition that they're equal
00:01:55 <Cale> or else bottom
00:02:38 <Cale> It's okay if only one of the two is defined -- it will result in whichever of the two expressions becomes available first, so if one doesn't terminate, you'll get the value of the other
00:03:27 <sophiag> anyway, what i was thinking of in Go is called alt! in Clojure
00:03:45 <sophiag> it's the one Pike demos where he puts in Google searches and grabs the one that finishes first
00:05:09 <sophiag> mrkgnao: and Amb in Scheme does just do backtracking search
00:05:14 <mrkgnao> Speaking of bottom, I find it interesting that all the Haskell-ish languages that have been developed recently are strict by default, for different reasons.
00:05:42 <sophiag> it's much easier to write a decent compiler for a strict language
00:05:48 <dysfun> when i was designing my toy lisp, first thing i did was make it strict
00:05:53 <Paul__> is there a library that provides sorted sequence with index lookup (i.e., get its position in the queue)?
00:06:18 <Cale> Yeah, as much as I'd really like Idris to have been lazy, I totally understand why Edwin didn't want to spend a whole bunch of time on that aspect.
00:06:25 <mrkgnao> sophiag: alt! sounds exactly like race
00:06:27 <sophiag> also nearly all strict functional languages still have bottom. it just behaves differently
00:06:49 <sophiag> mrkgnao: i haven't used async yet actually
00:07:21 <Cale> Well, you don't really need the Scott domain semantics for strict languages.
00:07:39 <Paul__> I've browsed through all hackage and cannot find it. Ordered sets (from sets package) came close, but still it is not the same because its membership lookup is based on key, not value
00:07:40 <mrkgnao> yeah, pervasive laziness is actually super weird once you stop using it and start thinking about what it *means* (either for fun, or for compiler implementation)
00:07:40 <sophiag> Cale: why not? they all use them
00:07:43 <Cale> I suppose you could use it anyway though, and most values would just be inaccessible.
00:08:08 <sophiag> i think you're talking about something more specific than i am
00:08:56 <Cale> I'm talking about the definedness ordering of which _|_ is the least element.
00:09:08 <Cale> (hence the name "bottom")
00:09:40 <Cale> e.g. for the type [Bool] you have _|_ at the bottom, and then immediately above that, you have [] and _|_ : _|_ which are incomparable
00:10:07 <Cale> and then above _|_ : _|_, you have False : _|_, True : _|_ as well as _|_ : [] and _|_ : (_|_ : _|_)
00:10:13 <Cale> all of which are incomparable
00:11:00 <Cale> and just generally, things proceed in that fashion, with x <= y when one can substitute some occurrences of _|_ in x somehow in order to obtain y
00:13:22 <sophiag> wait, but in strict functional languages it's bottom on one side of products thats leads to inconsistency. so doesn't that mean ordering of it does matter?
00:13:57 <mrkgnao> this kinda sorta sounds like instance selection rules for overlapping instances, Cale
00:14:03 <sophiag> like in ML (x,_|_) and (_|_,x) both evaluate to _|_
00:14:12 <Cale> Well, in a strict language, if you want to apply these semantics, anything will be totally defined or _|_
00:14:20 <Cale> There won't be anything in-between
00:14:50 <Cale> (which makes it a bit of a waste -- most of the detail in the model is inaccessible via the language)
00:16:39 <sophiag> well, in practice we're fine either way. but ideally fst (x,_|_) == x
00:16:58 <sophiag> i suppose it's much like dividing by zero
00:58:17 * dfordivam /msg ALIS help
00:58:55 <ccapndave> Morning Haskellers.  I am quite a noob to Haskell and can't figure out why this doesn't compile.  The problem is that line 5 doesn't type check (error included in gist).  Any ideas why?  https://gist.github.com/ccapndave/5d35786e182e830ad197ce0a315bc9bc
01:00:11 <glguy> .url
01:00:31 <glguy> ccapndave: By default Haskell doesn't have "scoped type variables"
01:00:40 <dfordivam> ccapndave: try -XScopedTypeVariables
01:00:45 <glguy> so the 'g' on line 5 is not related to the 'g' on line 1
01:00:51 <ccapndave> Ah
01:01:14 <ccapndave> But if I put another (RandomGen g) in there that doesn't work either (and neither if I give it a different type variable name)
01:01:33 <ccapndave> e.g. random gen :: (RandomGen g1) => (Float, g1)
01:01:35 <glguy> Right, in this case it has a specific type , you just can't name that type
01:01:55 <glguy> If you write this type signature with g1, you're asserting that it has any type g1
01:02:02 <glguy> but it doesn't have any type, it has some specific type
01:02:20 <ccapndave> Ah, I see
01:02:34 <glguy> > let x :: Int; (x,y) = (10,20) in x
01:02:37 <lambdabot>  10
01:02:53 <glguy> Since you are trying to give 'rand' a type signature and not the generator
01:03:04 <glguy> You can just add such a signature on the line before 5
01:03:08 <glguy> err, before 4
01:04:16 <glguy> dfordivam: Remember when suggesting -XScopedTypeVariables that it doesn't do anything without the extra 'forall' quantifiers
01:04:17 <ccapndave> glguy: Aha!  rand :: Float
01:04:19 <ccapndave> That does it
01:04:34 <ccapndave> Thanks very much :)
01:04:40 <glguy> yw
01:05:04 <ccapndave> Haskell is awesome but confusing :)
01:06:56 <dfordivam> glguy:Yeah right..
01:14:37 <dfordivam> Does rec block have known limitations, which causes it to unable to infer type of polymorphic functions defined in a let block inside rec block..
01:41:31 <[exa]> Mhm guys.
01:42:39 <[exa]> Let's say I'd like to do simple mathematics, like e.g. write a+b*c, and I'd want the + and * operators have a side effect, for example logging.
01:43:49 <[exa]> One obvious possibility is to break stuff into: do { tmp <- mult b c ; add a tmp }
01:44:13 <[exa]> but having the original syntax around would be a lot cooler.
01:46:15 <sophiag> [exa]: i'm not sure what you mean by logging (like the writer monad?) but you can easily just override those operators to write to an IORef or whatever you want
01:47:33 <[exa]> sophiag: logging was an example of one sane thing to do with it; general monadic behavior is the target
01:48:50 <glguy> you can make operations that take different types, IO Int -> IO Int, instead of Int -> Int
01:49:06 <glguy> like template haskell does
01:51:31 <[exa]> so (+),(*) would be of type m a->m a->m a and I'd somehow lift the incoming values to monad?
01:52:11 <[exa]> yeah that would make sense I guess
02:11:35 <rightfold> I believe IO a has a Monoid instance when a has a Monoid instance
02:11:49 <rightfold> You can add the same for Semiring, then you can use + and * from Semiring
02:12:51 <rightfold> Although commutativity is hard with side effects
02:13:22 <Taneb> rightfold, that's true of any applicative functor
02:14:02 <rightfold> If + adds actions that log it's probably not commutative anymore
02:24:48 <matrium> hi, is there an infix mconcat? something like <?> = lift2A (<>)
02:25:08 <mauke> :t mconcat
02:25:09 <lambdabot> Monoid a => [a] -> a
02:25:50 <Gurkenglas> :t liftA2 (<>)
02:25:52 <lambdabot> (Monoid c, Applicative f) => f c -> f c -> f c
02:26:10 <Gurkenglas> matrium, if you would be using it a lot perhaps you want WriterT
02:28:13 <matrium> I use it alot for parser combination. e.g. "(liftA2 (<>) (pack <$> many (pnChars <|> char '.')) (singleton <$> pnChars)"
02:29:07 <matrium> "parse and concat two text chunks"
02:29:24 <matrium> I thought there is maybe a well known abstraction for that
02:29:41 <matrium> with a fancy infix operator :-)
02:29:59 <cocreature> matrium: if you use that a lot just make your own infix operator :)
03:19:10 <hasky> okk
03:20:20 <hasky> i've learned SML, is Haskell still worth learning
03:20:24 <mauke> yes
03:26:17 <kritzcreek> how do I read a file as ByteString, but with the handle in Text rather than in BinaryMode?
03:28:27 <cocreature> kritzcreek: try combining withFile to get a Handle, hSetBinaryMode False and ‚ÄúhGetContets‚Äù to read from the handle
03:28:41 <kritzcreek> that'll be lazy though right?
03:29:00 <kritzcreek> it probably doesn't matter. Thanks I'll go for that
03:31:46 <cocreature> kritzcreek: hGetContents for strict bytestrings is strict iirc
03:32:08 <sophiag> Cale: i'm listening to Conal on the Haskell Cast and he says unAmb was inspired by Amb in Lisp. it's the same technique of backtracking search, but it's deterministic since the values have to be equal and so it only takes the first one that returns and avoids hanging or stack overflows
03:32:16 <cocreature> it pretty much has to be
03:33:13 <rightfold> cocreature: the only laziness it could do is defer reading the entire bytestring until you process any part of the bytestring
03:34:08 <rightfold> If any part of a strict ByteString is evaluated, all other parts are too
03:34:24 <kritzcreek> Oh no I think I understand now why the default readFile doesn't use hGetContents, it reads the filesize of the handle to avoid chunking
03:34:41 <cocreature> rightfold: right but not only does that bring the usual problems accompanying lazy IO it also doesn‚Äôt have any benefits in most situations
03:34:52 <cocreature> so that would be a really silly implementation :)
03:34:55 <rightfold> Indeed üò∏
03:43:34 <entuland> hello everybody, I've installed the core package for haskell on win10, the instructions here: https://www.haskell.org/platform/ tell me to add some lines regarding msys and mingw to my config file, in particular extra-prog-path
03:43:50 <entuland> but extra-prog-path is already there in my config file, with a different value
03:44:10 <entuland> should I merge them somehow or add a new extra-prog-path line?
03:50:10 <reptar_> is it possible to get this result without sorting the list twice? http://lpaste.net/6416348323208232960
03:50:40 <reptar_> i want to compare on (angle low) if it's not equal and snd if it is
03:51:03 <reptar_> if that makes sense
03:54:44 <kritzcreek> cocreature: üôè Thank you very much
03:54:50 <kritzcreek> It's not pretty but it works :)
03:55:05 <alexbiehl> reptar_: compare gives you an Ordering, and Ordering is a Monoid: try something like this: (compare `on` (angle low) <> compare `on` (snd low))
03:55:34 <reptar_> alexbiehl: oooh, thanks :)
03:56:18 <cocreature> kritzcreek: just wrap it up in a ‚ÄúreadBinaryTextFile‚Äù function and your code looks nice again :)
03:56:37 <akr[m]> Hello, any idea if I can write to a Brick.BChan (https://hackage.haskell.org/package/brick-0.17.2/docs/Brick-BChan.html) from a different thread? What I'd like to do is write a TCP client application which listens for TCP input and parses them to events, then forwards them to the Brick UI
03:56:38 <akr[m]> so I'm fairly sure I should use 2 threads‚Ä¶ right?
03:56:39 <akr[m]> one for listening for TCP input and the other for running the Brick UI
03:57:20 <kritzcreek> cocreature: yeah no worry it's almost pretty next to the insane invocation to decode a strict utf8 bytestring into text
03:57:49 <cocreature> kritzcreek: huh? you can just use ‚ÄúdecodeUtf8‚Äù for that
03:57:59 <kritzcreek> TL.toStrict . decodeUtf8 . BSL.fromStrict
03:58:00 <kritzcreek> nope
03:58:16 <cocreature> you can
03:58:18 <cocreature> just import the right one
03:58:28 <kritzcreek> argh
03:58:30 <cocreature> e.g. Data.Text.Encoding instead of Data.Text.Lazy.Encoding
03:58:35 <kritzcreek> you're right my import was left over in lazy
03:59:07 <kritzcreek> Maybe I shouldn't write code today O.o
03:59:33 <cocreature> if people stopped writing code when they make a mistake nobody would ever write code :)
04:02:01 <entuland> how should I merge these two lines together? one was in my config file for starters, the other should be added as per the haskell installation instructions: -- extra-prog-path: C:\Users\user\AppData\Roaming\cabal\bin -- extra-prog-path: C:\Program Files\Haskell Platform\8.0.2\mingw\include
04:03:07 <entuland> the latter should actually be extra-prog-path: C:\Program Files\Haskell Platform\8.0.2\msys\usr\bin
04:03:46 <entuland> i can't find any indication whether a duplicate key would be okay or whether I should join the values with a comma or a space or whatever
04:10:44 <cocreature> entuland: according to https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-extra-prog-path they have to be newline or comma separated
04:11:39 <entuland> uhm... I wonder how I didn't manage to find that doc... I'm pretty good at googling normally...
04:11:45 <entuland> thanks a lot cocreature 
04:11:48 <cocreature> np
04:17:55 <akr[m]> anyone knows if I can write into a Brick.BChan from a different thread?
04:18:17 <akr[m]> I mean, idk how to use it otherwise :)
04:18:47 <cocreature> akr[m]: it looks like it‚Äôs just a wrapper around TBQueue so that should definitely work
04:19:05 <akr[m]> cocreature: ah great, thank you
04:23:27 <reptar_> alexbiehl: <> is not in scope, where does it come from? tried hoogle, but the results didn't make sense
04:23:48 <alexbiehl> reptar_: try importing Data.Monoid
04:24:05 <reptar_> thanks
04:32:41 <reptar_> alexbiehl: https://pastebin.com/QA3yVAsF
04:41:09 <kritzcreek> cocreature: seems not to be working unfortunately :(
04:41:22 <kritzcreek> the ByteString still contains \r\n
04:43:09 <cocreature> kritzcreek: can you show us the code?
04:44:57 <cocreature> kritzcreek: also are you on windows? afaik text mode has no effect on linux and macos even if you read files with dos line endings
04:45:12 <kritzcreek> yes I am ^^ that's why I'm doing it in the first palce
04:45:18 <kritzcreek> I have no trouble on linux
04:45:22 <kritzcreek> http://lpaste.net/355288
04:46:05 <kritzcreek> I get the same if I explicitly set `hSetNewlineMode h universalNewlineMode `
04:46:58 <ollieh[m]> Anyone know why I might be getting these errors when trying to build the tensorflow-ops library in  https://github.com/tensorflow/haskell ? http://lpaste.net/355289
04:49:44 <cocreature> kritzcreek: sorry not sure what‚Äôs going on here
04:50:21 <kritzcreek> cocreature: no problem :) thanks a lot for your help so far, I had expected that to work it looked promising :)
04:50:44 <alexbiehl> reptar_ try: sortBy (\x y -> comparing (angle low) x y <> comparing snd x y) 
04:53:08 <cocreature> kritzcreek: I guess just reading the file and then search&replacing \r\n is probably the easiest solution. alternatively you can read it line by line and fix the line endings in each step
05:06:47 <jchia_1> Lens question. If I have a function 'batchTransform :: Traversable t => t Int -> t Int' that returns the same number of output items as input items, how can I use lens to apply it to all the odd items in a list with only one call to batchTransform? E.g. if batchTransform multiplies each item by 2, I want to get [2, 2, 6, 4] from [1, 2, 3, 4]. The point is that that batchTransform is some kind of batch lookup and I want to minimize the n
05:06:47 <jchia_1> umber of calls to it. Without this requirement, I would simply be using fmap.
05:14:30 <nut> how to serve yesod website over https
05:14:36 <nut> instead of http
05:15:16 <lyxia> jchia_1: partsOf looks relevant. I can't find a lens for filtering though...
05:15:39 <entuland> any advice for some simple, interesting program to try and implement with haskell when starting to learn it?
05:16:05 <entuland> (simple is relative, I have 22 years experience in coding, just out of ideas :P )
05:16:19 <jchia_1> lyxia: Is 'filtered odd' relevant?
05:17:06 <lyxia> jchia_1: yes! I was looking for that one
05:19:32 <jchia_1> lyxia: Thanks, let me see if I can combine partsOf with filtered odd to get what I want.
05:20:26 <cocreature> > [1,2,3,4] & partsOf (traverse . filtered odd) %~ map (*2)
05:20:28 <lambdabot>  [2,2,6,4]
05:20:31 <cocreature> ^ jchia_1 
05:21:29 <jchia_1> cocreature: Great, thanks
05:21:58 <cocreature> at some point I was planning to look up how ‚ÄúpartsOf‚Äù is implemented but I‚Äôm still too scared to take a look
05:44:12 <Gurkenglas> jchia_1, maybe you want to implement batchTransform as "Traversal' s Int -> s -> s" - then you could pass "traverse . filtered odd" to it
05:44:59 <Gurkenglas> "Traversal s t Int Int -> s -> t", that is :P
05:46:38 <Gurkenglas> Or perhaps just "Int -> f Int" with whatever f you were going to pass to that traversal
05:50:12 <drninjabatman> hey, I am trying to convince gchi to `:kind! forall x . C x => F x` which has kind a lifted datatype. But it looks like I can only use Type kinded stuff on the right of `=>`. Is there a way to get around that?
05:50:46 <Gurkenglas> entuland, command-line hangman or 2048 or tetris for example
05:52:17 <entuland> Gurkenglas, thanks for the advices
05:52:35 <entuland> I wonder how complex could it be to do desktop programs with Haskell
05:57:49 <Gurkenglas> A straightforward gruffy way would be to use a library that provides bindings for your favorite gui library from another language
06:04:11 <lyxia> drninjabatman: I don't think you can. Why do you need that?
06:04:48 <drninjabatman> lyxia: I have a type level function that I need to find out what it evaluates to under certain constraints
06:06:16 <entuland> Gurkenglas, isn't there a preferred, common way to create interfaces with Haskell?
06:07:02 <Gurkenglas> entuland, you mean a thing that automatically creates a library of bindings to a given c library? Hmm.
06:07:19 <entuland> Gurkenglas, it's all new to me
06:07:32 <entuland> I'm barely swifting through http://learnyouahaskell.com right now
06:07:36 <Gurkenglas> Or do you mean https://wiki.haskell.org/Foreign_Function_Interface
06:07:48 <lpaste> Hjulle pasted ‚ÄúParse error when combining ImplicitParams with explicit binding‚Äù at http://lpaste.net/355292
06:08:41 <entuland> I'll refer to this Gurkenglas, I guess: https://wiki.haskell.org/Applications_and_libraries/GUI_libraries
06:09:31 <Hjulle> Same problem with let bindings:
06:09:45 <Hjulle> > let a = 1; ?b = 2 in 1
06:09:47 <lambdabot>  <hint>:1:12: error: Parse error in pattern: ?b
06:09:57 <Hjulle> > let ?a = 1; ?b = 2 in 1
06:10:00 <lambdabot>  1
06:10:08 <lyxia> drninjabatman: typeRep (Proxy :: forall x. (x ~ 2) => Proxy (F x))   ... maybe? This works because there are only equality constraints though...
06:10:44 <lyxia> drninjabatman: Can you give more context about what you are actually trying to do
06:11:44 <javjarfer> edwardk, hi! Are you available?
06:12:16 <lyxia> Hjulle: implicit and explicit variables must be bound in different groups
06:12:46 <Hjulle> lyxia: Aha, thanks. How do you do that with where bindings?
06:13:49 <lyxia> you don't. "You may not mix implicit-parameter bindings with ordinary bindings in a single let expression; use two nested lets instead. (In the case of where you are stuck, since you can‚Äôt nest where clauses.)"  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameter-bindings
06:15:15 <Hjulle> Ok :(
06:16:56 <drninjabatman> lyxia that is actually what I did, could I interest you in aswering my stackoverflow question? http://stackoverflow.com/questions/43831769/using-a-a-lifted-data-type-on-the-right-of-in-ghci
06:18:33 <Gurkenglas> javjarfer, the faux-pas of asking to ask combined with the l√®se-majest√© of pinging ekmett! *swoons*
06:18:36 <drninjabatman> actually lyxia instead of using Typeable I used `:t Proxy :: ...` but its essentially the same concept
06:21:07 <javjarfer> Gurkenglas, it was to return to a previous conversation
06:31:49 <lyxia> drninjabatman: Oh, :t works indeed. I'll let you answer your question.
06:48:08 <drninjabatman> Why does this `:t Proxy :: forall x y . (F x ~ y, 3 ~ y)  => Proxy y` and this `:t Proxy :: forall x y . (3 ~ y, F x ~ y)  => Proxy y` throw an error about x0?
06:53:15 <lyxia> x is ambiguous
06:54:28 <drninjabatman> how so? lyxia
06:56:40 <lyxia> drninjabatman: if you know (F x), you don't necessarily know x, because F may not be injective.
06:57:01 <ClaudiusMaximus> you could have   F Int ~ 3  and  F Bool ~ 3  for example
06:58:31 <drninjabatman> so defining F as `type Family F x = r | r -> x` should resolve the problem?
06:58:48 <lyxia> only if F is actually injective
06:58:55 <drninjabatman> (didn't work)
06:58:59 <drninjabatman> it is
07:00:44 <lyxia> How did it not work
07:01:35 <drninjabatman> lyxia: I am getting the same behavior
07:03:04 <drninjabatman> lyxia: https://gist.github.com/a064eb4acf99c7192254b855d34f8b56
07:03:22 <lyxia> drninjabatman: there is no x such that F x ~ 3
07:04:24 <drninjabatman> lyxia: aah yes
07:04:53 <lyxia> it actually works on my side either way
07:05:50 <lyxia> make sure you reloaded your file
07:27:17 <Hjulle> Can hoogle search for instances of a class?
07:41:03 <Gurkenglas> @instances Alternative
07:41:06 <lambdabot> Alt f, Either e, IO, Maybe, Proxy, Seq.Seq, []
08:34:49 <bollu> this is possibly silly, but, well, is there an implementation of python's standard library stuff for lists and strings in Haskell? examples of things being "".join(<stuff>)
08:34:59 <bollu> the pure functions that exist on python lists
08:35:06 <bollu> find, split, etc
08:37:30 <cocreature> bollu: I don‚Äôt think there is one with the same naming conventions but the functions exist, partially in base, partially in other libraries (e.g. there is a ‚Äúsplit‚Äù library), join is called intercalate, find is called elemIndex, ‚Ä¶
08:39:46 <mbw> I have an expression like "mkFun [2,4,3] $ \[i,j,k] -> (i+j)^k", where the list [i,j,k] is guaranteed to consist of three elements. How can I avoid the warning about non-exhaustive pattern matches?
08:40:40 <mbw> Besides matching against wildcard patterns, that would become annoying quickly I think.
08:40:50 <Athas> Turn it into a let-pattern, maybe?
08:40:56 <Athas> I don't think those come with warnings.
08:42:06 <bollu> cocreature: yeah, I know of intercalate, did not know of `elemIndex`
08:42:08 <bollu> interesting
08:42:16 <mrkgnao> mbw: any reason why a tuple wouldn't work?
08:42:57 <mbw> mrkgnao: I am using the hTensor library, which uses this convention.
08:43:40 <mbw> Athas: You mean just use a "worker function" instead of an anonymous one?
08:44:10 <mbw> Could you somehow make irrefutable patterns work maybe?
08:44:13 <Athas> mbw: yes.
08:46:04 <lyxia> for some reason I get no warning with a partial lambda
08:46:05 <glguy> making the pattern irrefutable would remove the warning but also change the behavior of the resulting code
08:46:53 <mbw> I think my usage of a "modified Weverything" is the culprit here.
08:46:56 <glguy> you don't get warnings about partial patterns when using syntax that only allows for single patterns
08:47:14 <glguy> oh, unless you turn on the warnings about uni patterns
08:47:36 <mbw> I just use Weverything with two or three specific warnings disabled.
08:47:47 <glguy> sounds exciting
08:47:59 <mbw> Not because I'm a pro, just because I'm paranoid though...
08:48:10 <cocreature> you could probably also write a function "from3 :: [a] -> (a, a, a)" and then use \(from3 -> (i,j,k)) -> ‚Ä¶
08:48:28 <cocreature> or does ghc complain about incomplete patterns for view patterns? I don‚Äôt remember
08:48:49 <mbw> That's an interesting idea, I'll try that out.
08:48:51 <lyxia> it assumes the function is total
08:49:09 <cocreature> you‚Äôll need a wildcard in from3 but you need only one
08:50:36 <lyxia> I mean, how could (from3 -> (i, j, k)) *not* match without throwing an exception
08:51:14 <lyxia> so this probably counts as a complete pattern
08:51:51 <mbw> Getting this stuff right is difficult I assume, after all that's probably why Repa and Accelerate use these snoc lists.
08:52:35 <mbw> (Z:.i:.j:.k) I mean. Which isn't exactly pretty either.
08:53:14 <Athas> Right, those confuse me whenever I have to read or translate Accelerate code.
08:53:26 <Athas> It's not like keeping track of array index arithmetic is easy in the first place.
08:54:16 <mbw> Do you do this on a regular basis? I presumed people who use these libraries are kind of in the minority...
08:55:48 <Athas> Yeah, but the Accelerate examples are a great source of well-written and readable simple data-parallel programs.
08:56:10 <Athas> (And they have already been vetted for whether they support pretty visualisations, which is important.)
08:58:47 <mbw> My experience with Accelerate has been underwhelming. For starters, some type errors are deferred to runtime, which is kind of a deal breaker for me. Also I can't get anything to typecheck, and the examples don't show slice usage. The latter people may presumably know from Repa, but still, the types are different and you have to get the lifting/unlifting right...
08:59:41 <mbw> But at least it is actively developed I guess. Ben Lippmeier stated that he doesn't have time to do work on Repa anymore.
08:59:43 <Athas> I also find it difficult to use, but that's hardly unusual for a Haskell library.  I've been unable to find anyone who uses it, unfortunately.
09:01:55 <mbw> Yeah I came to that conclusion as well. I asked a question about Repa/Accelerate on Reddit https://www.reddit.com/r/haskell/comments/68pc7a/equational_reasoning_with_multidimensional_arrays/ and it wasn't of much help unfortunately. I think I even got downvoted at first
09:06:32 <Welkin> why not use matlab/numpy instead?
09:06:49 <Welkin> There doesn't seem to be much support for that kind of thing in haskell
09:09:20 <mbw> Yeah I was thinking of trying to use numpy or Julia. But first of all, I would have to learn yet another language. Second of all, they're dynamically typed (with optional type annotations in Julia, though). But I just like Haskell you know? I'm kind of struggling against giving it up...
09:09:56 <Tuplanolla> At least you get to choose the way you lose your sanity, mbw.
09:10:21 <Welkin> matlab/numpy/etc are just tools
09:10:43 <Welkin> it's not the same as building applications
09:10:54 <Welkin> they have industry support at least
09:11:06 <Welkin> also, numpy is luckily not python
09:11:22 <mbw> Then what's the "py" for?
09:11:48 <Welkin> it doesn't use python "arrays" and has all its own functions
09:11:53 <Welkin> it uses C arrays
09:12:12 <Welkin> but the syntax is python
09:12:47 <jcjf> wow, I never thought I'd find someone who might find Python difficult
09:12:55 <Cale> I'm pretty sure NumPy is a library for Python...
09:13:01 <jcjf> I'm sitting here as a Python enthusiast curious about Haskell...
09:13:06 <Welkin> python isn't difficult, it's just a crappy language
09:13:41 <jcjf> NumPy is a Python library that makes it easier to efficiently deal with n-dimensional arrays of numbers
09:14:03 <jcjf> Welkin: depends on what your language requirements are
09:14:06 <mrkgnao> Maybe we could be a little more forgiving. The only language we've collectively decided to is fair game is JavaScript, after all.
09:14:09 <mrkgnao> ;)
09:14:13 <Welkin> I used to like python before I knew how bad it was after discovering haskell
09:14:31 <mrkgnao> s/to is/is/
09:14:48 <jcjf> Welkin: it's a completely different paradigm, but Haskell isn't without its weaknesses
09:14:53 <mrkgnao> It's okay as long as you're writing stuff that doesn't run for a long time, imo.
09:15:02 <mbw> I learned a little python. Having already been fluent with Fortran/C/C++ at the time, I didn't see the point in delving deeper into it, since I thought it wouldn't help me think about problems "differently", so I decided to pick up Haskell.
09:15:09 <Welkin> jcjf: I mostly mean api decisions in the syntax and standar libraries
09:15:44 <mrkgnao> Having Django give you NoneType nonsense after a server running for some time is annoying. Like a superset of -fdefer-type-errors. 
09:15:47 <jcjf> Welkin: wow.... THAT'S the part you think sucks? The CPython interpreter internals are a disgusting mess
09:15:51 <mbw> Also I think as soon as you have to write something non-standard that isn't solved by calling into BLAS/LAPACK, NumPy is probably not so efficient after all.
09:16:14 <Tuplanolla> I first found Haskell when I grew tired of incomplete and poorly designed Scheme libraries.
09:16:54 <jcjf> I'm having trouble finding a use for Haskell... my full-time job isn't as a programmer so it's really hard for me to find an excuse to use it
09:16:57 <Welkin> I almost exclusively use haskell for web development, something that most people who don't already know haskell would never imagine it would be used for
09:17:14 <jcjf> Welkin: that's what I was thinking of doing!
09:17:17 <Welkin> it's the best web dev language I have found
09:17:30 <jcjf> Welkin: but there's so much cognitive overhead for a beginner
09:17:32 <Welkin> writing api servers with servant + persistent is super easy
09:17:54 <jcjf> Welkin: like for me... Yesod seems to require somehow grokking what Template Haskell is doing
09:17:58 <Welkin> yeah
09:18:07 <Welkin> yesod is a bit weird
09:18:09 <jcjf> servant and persistent... thanks for the tip!
09:18:18 <Welkin> I used it for a while when I did a lot of server-rendered web apps/sites
09:18:25 <Welkin> now I have moved almost entirely to client-rendering
09:18:32 <Welkin> so the backend is just an api server
09:18:36 <Welkin> I prefer this
09:18:42 <Welkin> yesod does have a steep learning curve indeed
09:18:54 <jcjf> Welkin: do you use purescript or something for front end?
09:19:09 <jcjf> I really hate JavaScript
09:19:09 <Welkin> I have used elm and regular js with react+redux
09:19:19 <Welkin> elm is not ready for production by any means
09:19:26 <Welkin> I have found that I actually enjoy js
09:19:32 <mbw> My first success story with Haskell was when I had a huge arithmetic expression consisting of 256 terms or so, and I had to figure out which terms could be neglected due certain symmetries and other criterions. I had tried it several times on paper, and wasn't sure if it was correct. Implementing it in Haskell was a breeze, and at the time I had only known haskell for three months or so.
09:19:32 <Welkin> it can be a great language if you use it right
09:19:54 <jcjf> Welkin: like with Flow or TypeScript? or just regular ES6?
09:19:57 <Welkin> I'll soon test out purescript
09:20:04 <Welkin> es6 with flow
09:20:13 <Welkin> typescript is very oop
09:20:17 <Welkin> I'd saty away
09:20:19 <Welkin> stay*
09:20:39 <Welkin> I can write js almost like I would write haskell (except without al lthe nice types)
09:20:44 <jcjf> I forgot... this is not the place to discuss mutable state :)
09:21:20 <Welkin> just use a decent utility library like ramda (there is also sanctuary and fantasy-land that make js more like haskell)
09:21:30 <Welkin> using algebraic structures in js is kind of messy though
09:22:23 <jcjf> anyway, I still haven't grokked monad transformers so I feel like I don't quite belong here
09:22:35 <Welkin> that's fine
09:22:43 <Welkin> using yesod taught me about monad transformers
09:22:48 <Welkin> they're nothing special
09:22:54 <mbw> jcjf: Have you read "Monad Transformers step by step"?
09:23:08 <jcjf> googling now!
09:23:26 <mbw> It's what made it click for me.
09:23:44 <jcjf> I even stopped to teach myself category theory to try and appreciate Haskell better
09:24:00 <jcjf> it's just so hard to get traction and get "useful" things done as a beginner
09:24:02 <Athas> mbw: which kind of run-time type errors do you get in Accelerate?
09:24:16 <Welkin> jcjf: I know how you feel
09:24:41 <Welkin> jcjf: for me, the turning point was when I started a project with yesod and rebuilt one of my medium-sized web apps that used to be in python
09:24:56 <jcjf> jcjf: I was actually thinking about doing this at work
09:25:13 <jcjf> Welkin: but I would never get anyone else to ever look at that code
09:25:31 <Welkin> although I'd suggest starting with a blog/twitter clone made with scotty if you aren't confortable with http or web dev yet
09:25:55 <jcjf> Welkin: I've dabbled with Flask and Express, so I get the basics
09:26:26 <mbw> Athas: I wrote about it in the Reddit thread I posted before, at the very bottom inside my comment.
09:26:28 <Welkin> yesod has a lot of "magic" which is why it's not often suggested for people new to haskell
09:26:31 <Welkin> too much template haskell
09:27:35 <jcjf> mbw: oh, I HAVE seen this step by step before
09:27:47 <jcjf> I actually went through it once
09:28:01 <jcjf> but I didn't understand the subtleties of the stack order
09:28:48 <mbw> jcjf: There's a chapter about transformer stack in Real World Haskell as well, which you can read online. Also, Lambdabot has an "unmtl" command.
09:29:13 <mniip> 1494174292 [19:24:52] <jcjf> Welkin: but I would never get anyone else to ever look at that code
09:29:15 <mniip> hahaha
09:29:16 <Cale> jcjf: This channel is generally welcoming to beginners -- there's no specific knowledge required to belong here :)
09:29:36 <Athas> mbw: hm, I see.  Looks like the common Haskell sin of providing faulty implementations of type classes.
09:29:50 <jcjf> thanks Cale!
09:30:06 <Athas> That has more to do with the base type class hierarchy being poor than any flaw in Accelerate.  (And perhaps it's type classes in general that are flawed...)
09:30:56 <Cale> Learning category theory is the really slow way to learn anything about Haskell -- if you like other areas of mathematics, you might find it's a worthwhile use of time, but if you're only learning to apply it to programming, it'll take a long time to pay back any effort that you put in (but it might still be enjoyable)
09:32:03 <mniip> I often feel like CT requires topology
09:32:23 <mniip> not explicitly but rather implicitly to understand the reason things are a certain way
09:32:27 <Cale> It's one of those things which you might be inspired to do eventually -- but it's much easier to understand all the concepts we've stolen from category theory just within Haskell, without trying to understand the more abstract versions of things.
09:32:54 <mbw> I think Accelerate tries to be too many things at once. We don't have a sensible multi-dimensional array implementation for *serial* execution to begin with. And Accelerate wants to be 1) parallel 2) support multiple backends 3) support arrays of arbitrary rank. This is still in the exploration phase of the design space I think.
09:32:59 <jcjf> mniip: totally... there's so much stuff that doesn't make sense to anyone (like me) that hasn't studied higher mathematics (I'm an engineer)
09:33:00 <Cale> mniip: Yeah, algebraic topology has the most natural avenues into CT
09:33:32 <Gurkenglas> What library should I use to write something that'll let people visit a website, enter text and get back text that depends on it?
09:33:45 <Cale> You shouldn't need to know a *lot* of algebraic topology
09:33:58 <Welkin> you can learn what you need from the typeclassopedia
09:34:12 <Cale> But a bunch of category theoretical definitions are inspired by corresponding notions in topology
09:34:17 <jcjf> like pushouts and pullbacks make no sense as terms on their own, unless you have a mental picture
09:34:19 <mniip> usually categorical examples include Grp and Vect - that's something I understand because I know something in those fields
09:34:35 <Gurkenglas> (such that the text they send back is computed by the computer that provides the website, and possibly depends on other people currently using the website)
09:34:37 <mniip> but as topics get more advanced it's just Top and Toph and Top.
09:34:51 <Welkin> Gurkenglas: are you talking about writing a web app?
09:34:59 <sm> Gurkenglas: ie, a trivial website ? scotty or any other web framework
09:35:12 <Welkin> it's not clear if you are talking about a browser extensions or a web application
09:35:22 <Gurkenglas> I think web application is right
09:35:28 * sm meant to say web application
09:35:31 <Welkin> if you want an extremely simple  web app, go for scotty
09:35:31 <jcjf> I remember I wanted to try and understand the CT version of Applicatives, and I couldn't see the link to Day Convolutions
09:35:34 <Gurkenglas> sm, that's trivial? I thought trivial websites were static html pages
09:35:47 <Welkin> even more bare-bones would be to use wai directly
09:35:54 <Welkin> but then you may need to know more about http
09:36:04 <jcjf> Welkin: what do you recommend for writing REST (JSON returning) APIs?
09:36:19 <Welkin> jcjf: https://hackage.haskell.org/package/servant
09:36:24 <Gurkenglas> (Ideally, there'd be an analogon to https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss.html#v:play )
09:36:33 <[exa]> Hm guys. I'm trying to get a nice syntax for "simple mathematics with side effects". I'd like something like do { a <- b*c+d; return a*2 }, but so that the * and + ops have side effects, e.g. log something or so. (If you see C++ and implicit allocations, you're right)
09:37:01 <mniip> jcjf, studying applicatives in a purely CT setup might be a bit over your head, but it looks kinda fine in haskell
09:37:04 <Cale> jcjf: It might be easier to understand applicative functors as monoidal functors -- if you change the API slightly, the connection becomes clearer
09:37:08 <[exa]> Currently I'm at  a <- pure b * pure c + pure d, with the type being computed with is both Monad and Num
09:37:09 <Welkin> jcjf: http://haskell-servant.readthedocs.io/en/stable/tutorial/index.html
09:37:28 <[exa]> Any suggestion for syntactical magic that would allow the "pure" go away?
09:37:34 <mniip> in order to understand day convolution you have to understand profunctor ends
09:37:39 <mniip> in haskell that's just 'forall'
09:38:37 <Cale> jcjf: If instead of pure :: a -> f a, we had unit :: f () (where unit = pure ()) and instead of (<*>), we took instead pair :: f a -> f b -> f (a, b), that is, liftA2 (,)
09:39:02 <Cale> jcjf: Well, perhaps it's easiest if we think of it as pair :: (f a, f b) -> f (a, b)
09:39:21 <jcjf> Cale: I believe that's the trick I recall
09:39:33 <jcjf> Cale: then (,) can be repeatedly applied
09:39:44 <Athas> mbw: I think the Data Haskell guys are trying to come up with a design (inspired by Numpy), but I have no idea how far they are.
09:40:06 <Athas> I'm personally a bit disillusioned with the ability of a normal inductive-types language like Haskell to support arrays well.
09:40:18 <Cale> Well, it's just that this lines up with the definition of a (lax) monoidal functor, where we take the "tensor product" to be the pair type constructor (,)
09:40:18 <Zeldhoron> i'm getting an error when i try to compile a simple hello world program, command line: "ghc-8.0.2.exe .\devtest.hs", error: "`gcc.exe' failed in phase `Assembler'. (Exit code: -1073741515)", platform: windows 10 64-bit
09:41:15 <sm> Zeldhoron: tried googling for the error message ?
09:41:16 <mniip> Zeldhoron, wow it sounds like you're using some ancient version
09:41:19 <jcjf> Cale: where does the part about "having strength" become important?
09:41:29 <monochrom> But 8.0.2 isn't ancient.
09:41:37 <mniip> ah wait it saays 8.0.2 right here
09:41:38 <mbw> Athas: Are you referring to this? https://github.com/wellposed/numerical I talked to the guy yesterday, they're still at it and maybe they'll release an alpha this summer. I wasn't aware that Data Haskell was developing something on their own though.
09:41:44 <Zeldhoron> tried googling, found nothing
09:41:52 <[exa]> Zeldhoron: can you get the output of the failed gcc? anyway the exitcode itself seems bogus, I suspect something microsoftish
09:42:26 <Zeldhoron> [1 of 1] Compiling Main             ( devtest.hs, devtest.o ) `gcc.exe' failed in phase `Assembler'. (Exit code: -1073741515)
09:42:33 <Zeldhoron> that's all i get
09:42:43 <geekosaur> how did you install ghc?
09:42:53 <Zeldhoron> the web installer
09:43:04 <sm> Zeldhoron: I found this one: https://github.com/commercialhaskell/stack/issues/2998
09:43:17 <Athas> mbw: I don't know the details.
09:44:00 <Zeldhoron> my stack works tho, i've already installed some packages to setup atom with haskell
09:44:22 <Athas> mbw: which algorithms would you like to implement with Accelerate/Repa?
09:45:49 <sm> Zeldhoron: short story, you need this 4/15 update of GHC for windows 10: https://mail.haskell.org/pipermail/ghc-devs/2017-April/014131.html
09:46:02 <geekosaur> Zeldhoron, this is probably the win10 creators update breakage, you need to use https://downloads.haskell.org/~ghc/8.0.2/ghc-8.0.2-x86_64-unknown-mingw32-win10.tar.xz
09:46:08 <geekosaur> right, that
09:46:12 <Cale> jcjf: That's just something about Haskell monads which you generally don't get for free in other categories. In Haskell, we can define strength :: (Monad m) => (a, m b) -> m (a,b) -- and that works for any monad. (In fact, this is sequence for the pair type.)
09:46:28 <Zeldhoron> ah nice, thanks guys :D
09:46:36 <geekosaur> I thought they were going to update the web page but it doesnt seem to have happened yet
09:47:28 <mbw> Athas: I was giving it a shot with some simple quantum chemistry stuff, which is mainly linear algebra really. And I did get things to work using Repa, had to do some convert-fu to do an eigen decomposition though. All really for prototyping purposes only. Unfortunately, as soon as you need something non-standard, like exploit symmetry properties of matrices for instance, it all breaks down. Now I'm trying 
09:47:34 <mbw> out hmatrix/hTensor, which are not bad.
09:48:28 <Athas> Ow, yeah, symmetry properties are tricky in a functional parallel array setting.
09:48:48 <carter> mbw: data Haskell is its own thing
09:49:07 <Gurkenglas> http://lpaste.net/1738718579508903936 from Emacs's M-x shell on Windows
09:49:20 <monochrom> mbw: The other day I ran into http://hackage.haskell.org/package/numeric-quest . But I haven't tried it or benchmarked it.
09:49:28 <carter> I actually think imperative algorithms and nested array parallelism are under used in Haskell array lib
09:49:58 <Athas> Does any Haskell library support nested parallelism?
09:50:04 <akr[m]> Hello, does anyone know if I can read from a IO Handle returned by Network.connect to in one thread and write into it on another?
09:50:09 <Athas> Not many languages or libraries support it outside Haskell.
09:50:30 <carter> Nested parallel stuff is also known as recursion:)
09:50:37 <carter> Plus work stealing
09:50:41 <EvanR> akr[m]: yes you can
09:50:50 <monochrom> Do "(x `par` y) `par` (a `par` b)" and "forkIO (moar forkIO)" count?
09:50:54 <Cale> carter: I think Athas is referring to nested data parallelism?
09:51:00 <Gurkenglas> Doing the same with the "new-template" template works
09:51:09 <mbw> monochrom: I think I had a look at that last year or so. Sadly, it seems to be abandon-ware and from what read it's "yet another fancy EDSL". They did have some nice ideas though.
09:51:22 <monochrom> Ah.
09:51:26 <carter> Cale:yes. But that's just parallel recursion afaik
09:51:49 <akr[m]> EvanR: great thank you‚Ä¶ how do you find out these sorts of things, by the way? Do you just need to know about the underlying GHC implementation of Handles, the network library, or something else completely?
09:52:04 <EvanR> knowing about Handles is a good idea yes
09:52:13 <EvanR> thats a GHC implementation detail
09:52:22 <Athas> carter: well, there is nothing hard about evaluating nested data parallelism, but it is bloody hard to execute it efficiently.
09:52:45 <Athas> In Haskell-land, Data-Parallel Haskell is the only effort I know of, and that essentially broke under the difficulty.
09:52:54 <EvanR> how do you find out, you can read the GHC manual or i reckon most people ask on IRC ;)
09:53:19 <akr[m]> EvanR: I see, thanks again :)
09:55:01 <Cale> carter: It's not super-simple at the type level. A parallel array of parallel arrays is implemented by storing a single array with an array of indices at which the subarrays start and their lengths
09:55:16 <carter> Yes I know.
09:55:42 <carter> I'm saying that in many cases recursive decomposition is simpler to do.
09:57:00 <carter> Granted it's also top down vs bottom up
09:57:27 <Athas> Usually recursive decomposition ends up with nested data parallelism, doesn't it?
09:57:37 <Athas> Or do you mean manual flattening?
10:00:30 <kamyar> hello guys!
10:00:54 <kamyar> My question is somewhat long
10:01:07 <kamyar> In imperative languages we have something like Object Lifecycle Management
10:01:25 <Cale> The main snag that the DPH effort hit as I recall wasn't actually in the flattening transformation (though I think that did result in data families and the new generics system) -- but in getting stream fusion or something like it to work on the output of the vectorisation transformation.
10:01:28 <kamyar> It consist any type of object including connections to databases
10:02:02 <kamyar> Q1: Do we have to care about same thing here in Haskell? DO I have to close/dispose some resources?
10:02:30 <kamyar> Q2: How can I manage connection lifecycles, e.g. redis connections? Do I have to 'unredis' for example?
10:03:00 <Cale> kamyar: It's common in such cases to use a pattern which is captured by bracket
10:03:03 <Cale> :t bracket
10:03:04 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:03:20 <EvanR> if you want to connect, use the resouce, then disconnect each time, then its easy with bracket
10:03:36 <Cale> bracket takes an action for initialising a resource, a function which can be used to finalise it
10:03:57 <Cale> and then a function specifying what action should be performed with that resource
10:04:01 <kamyar> You mean something like Context Managers in Python?
10:04:34 <Cale> and it puts them together in the natural way: the initialiser will be run first, then the action you gave, and then the finaliser
10:04:40 <Athas> Cale: oh yeah, doing anything with the result of a flattener is a nightmare, too.
10:05:01 <Athas> But they would eventually have encountered performance problems with flattening too.  It's not exactly known for its great speed.
10:05:04 <kamyar> Can u give me a sample for redis (hedis)?
10:07:42 <Cale> kamyar: If you can tell me what you want to do so far as cleaning up the connections... I've never used the library and I don't see a 'disconnect'
10:08:06 <kamyar> Cale: It has 'unredis' that means disconnect. 
10:08:13 <kamyar> Cale: For example set or get something
10:08:36 <Cale> I don't think that's right
10:08:52 <Cale> unRedis just unpacks a Redis action into the underlying ReaderT
10:09:17 <kamyar> Cale: I am not sure. 
10:09:22 <kamyar> Cale: I have no clues
10:09:47 <Cale> It does have this quit action, but that's in the redis monad itself. I suppose that's fine. We could write a thing that makes sure that happens.
10:10:24 <Gurkenglas> Doing this https://github.com/cydparser/demo-emacs-haskell/blob/master/demo.org#Jump to the second S.get in the Example.hs of the "scotty-hspec-wai" lands me at System.Console.CmdArgs.GetOpt
10:12:17 <Cale> Something like...  withRedis ci x = do conn <- connect ci; runRedis conn (do v <- x; quit; return v)
10:12:35 <Cale> Maybe that should be checkedConnect
10:13:51 <Cale> However I think you're meant to create a connection and then reuse it, more often than not. It's a whole connection pool you're getting there.
10:14:06 <kamyar> Cale: Do we have to use quit in this special case? Note that hedis atuomatically creates connection pool
10:14:35 <Cale> It doesn't appear that you have to, but I've never used this library
10:14:39 <kamyar> Cale: Yes! Exactly
10:15:19 <kamyar> Cale: I am writing a service that I need great performance and concurrency
10:15:23 <Cale> anyway, any setup and teardown you might have to do can usually be packaged up into a function like that
10:15:37 <kamyar> Cale: It is critical for me to make sure any resource is close and omit any resource leak
10:17:41 <kamyar> Cale: Now see this link: https://hackage.haskell.org/package/persistent-postgresql-2.6.1/docs/Database-Persist-Postgresql.html
10:17:48 <Cale> kamyar: Yeah, I just have no idea what you're required to do by redis
10:17:58 <Cale> yep
10:17:59 <kamyar> Cale: I guess functions starting 'with' are bracket pattern. Yes?
10:18:02 <Cale> yes
10:18:16 <kamyar> cool! 
10:19:42 <Gurkenglas> Requesting the proper way to do "(String -> IO String) -> ActionM ()", which is a scotty page displaying a textbox in which each line is answered by the server with a line according to the function parameter
10:26:01 <kamyar> PLease see this code: https://github.com/parsonsmatt/servant-persistent/blob/master/src/Api/User.hs
10:26:31 <kamyar> What does :> operator mean?
10:26:43 <Welkin> kamyar: it is a type level operator
10:26:59 <kamyar> Welkin: What does it do here?
10:27:02 <Welkin> it's like list cons for the srvant api
10:27:13 <Welkin> er
10:27:17 <Gurkenglas> kamyar, http://hackage.haskell.org/package/servant-0.10/docs/Servant-API-Sub.html#t::-62-
10:27:33 <Welkin> it's like an append
10:27:36 <Welkin> or a "/"
10:27:40 <Welkin> in the url
10:28:37 <kamyar> Welkin: Thanx!
10:33:16 <kamyar> Please someone give me a good sample of persistent-postgresql https://hackage.haskell.org/package/persistent-postgresql-2.6.1/docs/Database-Persist-Postgresql.html
10:33:23 <_101010> Can someone tell me how to get the day of the week(eg: Monday) from given UTCTime?
10:33:31 <kamyar> I need sample with.... implementation
10:34:04 <Cale> _101010: You'll need to know which timezone you're in
10:34:31 <_101010> Why?
10:35:01 <Gurkenglas> For my question, 'get "/:x" $ text . f =<< param "x"' is a start but requires people to write in the address bar and reload the page for each line, and characters such as ? don't work for the input
10:35:02 <_101010> I have already adjusted for that.
10:35:18 <kamyar> I need bracket implementation for that url
10:35:36 <Cale> _101010: Because which day of the week it is can't be determined from only a UTC time
10:36:43 <_101010> I get that, but like May 8, 2017 is a Monday everywhere on earth right?
10:36:59 <Cale> Yeah, it's just a different day in different places
10:37:10 <Cale> For a given UTCTime
10:37:22 <_101010> So I just need that Monday given May 8, 2017
10:37:24 <Cale> So you can do getTimeZone
10:37:29 <_101010> ignoring the timezone
10:37:48 <_101010> I am already pissed at the timezone thing as it is.
10:37:48 <Cale> utcToLocalTime :: TimeZone -> UTCTime -> LocalTime
10:38:04 <Cale> localDay :: LocalTime -> Day
10:38:34 <Cale> toWeekDate :: Day -> (Integer, Int, Int)
10:38:40 <Cale> "Convert to ISO 8601 Week Date format. First element of result is year, second week number (1-53), third day of week (1 for Monday to 7 for Sunday). Note that "Week" years are not quite the same as Gregorian years, as the first day of the year is always a Monday. The first week of a year is the first week to contain at least four days in the corresponding Gregorian year."
10:39:03 <_101010> Why is such a long process in Haskell honestly?
10:39:17 <Cale> Or you can just format the time
10:39:26 <_101010> Why isn't it more straightforward like other languages?
10:39:34 <Cale> It's always complicated
10:39:49 <_101010> Where you can just time.day == Monday or something?
10:39:59 <Cale> Well, what does that mean?
10:40:17 <Cale> If you have a *time* only, that doesn't tell you which day it is.
10:40:32 <Cale> You need to know which time zone you're in to know that
10:40:33 <_101010> It does at least in GMT
10:40:44 <Cale> Well, you can pick GMT
10:41:00 <_101010> Not with Haskell can you?
10:41:12 <[exa]> If I try to bind Integer to a Num member, I'm getting fromInteger called automatically. Is there some rationale behind that?
10:41:31 <Cale> utc :: TimeZone
10:42:37 <Cale> Or you can use minutesToTimeZone or hoursToTimeZone to build a zone from scratch if you need to.
10:42:49 <Cale> That usually isn't required...
10:43:13 <Tuplanolla> They're gone, Cale.
10:43:32 <sm> guess they ran out of time
10:43:36 <nshepperd> if you have a civil time, that tells you what day it is
10:43:40 <Cale> Someone who obviously has not written very much software involving times
10:43:52 <Cale> Yeah, you need a LocalTime
10:43:55 <nshepperd> ie. a point on the gregorian calendar
10:44:04 <nshepperd> looks like LocalTime is the haskell version of that
10:44:09 <Cale> yep
10:45:07 <sm> haskell's time libs are great, but is there a need for a rethought api with more user-friendly organization ?
10:45:32 <jordan32942> https://ideone.com/QQS0LD
10:45:35 <sm> and, any projects working on that ?
10:45:42 <jordan32942> can anyone help me with this short program?
10:45:54 <Tuplanolla> We can't really have nice things until the operating system supports atomic time, sm.
10:50:25 <geekosaur> jordan32942, the main problem is that main has to be an IO something.
10:50:35 <geekosaur> the easiest solution is to do something with the result of f1, like print it
10:51:12 <jordan32942> i still get the same error tho
10:51:20 <jordan32942> Parse error in pattern: help_function
10:51:20 <jordan32942>     Possibly caused by a missing 'do'?
10:52:53 <geekosaur> but that error is not shown in your paste. does the paste actually match your local code? including indentation?
10:53:19 <Gurkenglas> Can I use scotty to have a user communicate with the server without reloading the page?
10:55:30 <cocreature> Gurkenglas: sure
10:55:58 <cocreature> Gurkenglas: there is nothing special you need to do on the backend site. just make a route that exposes the information you want to provide to the user and then make an ajax request in your frontend code
10:57:03 <jordan32942> oops youre right, its working with the print statement, thanks geekosaur
10:57:45 <Gurkenglas> cocreature, do you have a oneliner that expresses that as "(String -> IO String) -> ActionM ()", where the argument maps user lines to lines the server answers with, or something else that exemplifies the concept?
11:00:51 <cocreature> Gurkenglas: something like "\f -> get "/communicate" $ do arg <- param "arg"; response <- f arg; text response" should work but from scotty‚Äôs perspective there is really no difference in a request that is send by loading a page in your browser or an ajax request
11:00:58 <nshepperd> Tuplanolla: we could have a library correcting system time back into TAI by downloading the leap second tables
11:01:01 <cocreature> so you don‚Äôt need to do anything special here
11:01:30 <Tuplanolla> That sure is a nice solution, nshepperd.
11:02:48 <nshepperd> the correction itself would be a bit complex but once you've got the basic functions you could have first class support for TAI at least within your program
11:08:15 <[exa]> OK I refined my example a bit. I got data I = Normal | MadeFromInteger which is a member of Num, all methods of Num return Normal except fromInteger, which returns MadeFromInteger. Now 5::I returns MadeFromInteger instead of typechecking failure I'd expect. Is there any documentation to that behavior?
11:08:23 <Gurkenglas> cocreature, so by "making an ajax request in your frontent code" you mean adding a UI element to the webpage I'm providing that will transform lines entered into these "ajax requests" and then that same element will have to receive and display the server's responses? (I'm assuming what I want to do is the basic usecase of *something* and thus trying to find the oneliner that does it)
11:09:14 <Tuplanolla> How would you ensure the operating system hasn't neglected some of the corrections, nshepperd?
11:12:19 <nshepperd> i think you would assume that the operating system is synchronized to utc
11:12:53 <cocreature> Gurkenglas: no I mean write some javascript that sends a http request to your scotty server at the point you want and with the contents you want, receive the response and then do whatever you want with that
11:13:58 <nshepperd> if it's not, there's probably not much you can do about it, outside of embedding an ntp client and doing your own timekeeping
11:15:36 <Cale> [exa]: Yes, that's specified in the Haskell Report
11:15:56 <Cale> [exa]: Integer literals implicitly have fromInteger applied to them
11:16:06 <Cale> :t 5
11:16:07 <lambdabot> Num t => t
11:16:18 <Cale> ^^ that's how 5 gets to be polymorphic in the first place
11:16:21 <[exa]> oh so
11:16:35 <Gurkenglas> How can I write a webpage that commicates with the server without using javascript?
11:16:36 <Cale> That doesn't look like a very good instance of Num
11:16:39 <[exa]> thanks! I was starting to suspect some defaulting weirdness
11:17:03 <Gurkenglas> I mean, using it under the hood is alright, just no writing pls
11:17:57 <Cale> Gurkenglas: Well, there's XHR and Websockets support in Reflex.
11:18:18 <Cale> Gurkenglas: There's also support for those things at a lower level in GHCJS
11:19:58 <cocreature> there is also purescript, elm and various other ways to generate js
11:20:04 <nshepperd> Tuplanolla: i dunno, it might be possible to detect if the latest leap second hasn't been applied yet due to the machine being offline during it or something
11:20:15 <nshepperd> if there is no observed discontinuity in the system clock
11:35:55 <tippenein> if I run cabal test, it's missing the test dependencies. If I run cabal configure --enable-tests it's missing all the other dependencies as well. What's the deal?
11:36:36 <tippenein> usually I use stack, so I'm unaccustomed to this. (also, cabal build works fine)
11:42:17 <cocreature> tippenein: it‚Äôs been a while since I‚Äôve done the standard cabal build dance but try "cabal install --only-dependencies --enable-tests"
11:42:55 <tippenein> Is there another dance? This one is getting tiresome
11:43:50 <tippenein> that fails for a different reason
11:44:06 <cocreature> if you‚Äôre feeling adventurous, there is ‚Äúcabal new-build‚Äù but you probably want to build cabal from the master branch for that since the version included in 1.24 won‚Äôt get you very far
11:44:27 <cocreature> tippenein: show us the error message :)
11:44:59 <tippenein> I'm using ghcjs with nix, and everything is working for builds, but somehow tests are barfing all over
11:45:19 <tippenein> it's just a "could not resolve dependencies" on reflex-dom
11:46:42 <cocreature> there are various reasons  why dependencies can‚Äôt be resolved and the error message often contains important information for getting it to work
11:49:03 <lpaste> tippenein pasted ‚Äúcabal test ‚Äù at http://lpaste.net/355296
11:49:53 <cocreature> tippenein: your ghc is too new
11:50:14 <cocreature> base 4.9 is ghc 8.0 but reflex-dom requires 7.10
11:50:25 <cocreature> (or 7.8)
11:51:20 <tippenein> why would the tests use a different base than the executable?
11:51:37 <Lokathor> one of these days base should just match GHC's version number
11:51:42 <Lokathor> skip however many in between
11:51:56 <kamyar> Hello friends!
11:52:01 <Lokathor> hello kamyar 
11:52:02 <cocreature> Lokathor: or it should be upgradable :)
11:52:07 <cocreature> but the current state is bad
11:52:21 <kamyar> please help me write postgresql-persistent code
11:52:37 <kamyar> this is the link: https://hackage.haskell.org/package/persistent-postgresql-2.6.1/docs/Database-Persist-Postgresql.html#t:ConnectionString
11:52:56 <Lokathor> cocreature, if "base" reprisents, among other things, primops that the compiler inserts in place of the actual code (such as with Word/Int/etc) then making it upgradable might not make sense
11:53:04 <kamyar> I want my code to open a connection pool at start (initilization) and use its connections during function calls
11:53:31 <kamyar> I have no clue how to call withPostgresqlPool at app initilization
11:53:37 <kamyar> and hold the resulting pool
11:53:47 <Lokathor> kamyar, okay, this sounds normal enough
11:53:50 <Lokathor> so there's two parts
11:53:55 <cocreature> tippenein: are you sure that "cabal install --only-dependencies" works? if so the only reason I can come up with is that only your test suite depends on reflex-dom
11:54:05 <tippenein> kamyar: this should help you https://github.com/parsonsmatt/servant-persistent/blob/master/src/Config.hs
11:54:19 <Lokathor> (1) you have to declare your pool setup (2) you have to give it a function to perform with that pool
11:54:34 <cocreature> Lokathor: yeah you definitely can‚Äôt make all of base upgradable. but you could split it and make reasonably large parts of it upgradable. at some point there were proposals for that but i think they‚Äôve just died
11:55:19 <tippenein> cabal install --only-deps doesn't work
11:55:39 <Lokathor> cocreature, well, jumping base from 4.9 to 8.0.2 and having base's version always match GHC's version seems like it would clear a lot of confusion and make the least waves
11:55:41 <tippenein> which is baffling because cabal build does.. 
11:56:03 <tippenein> must not be the same as stack install where it just moves the build to a local exe dir
11:56:10 <kadoban> Lokathor: Now that would be nice, IMO.
11:56:25 <cocreature> Lokathor: yeah at this point that‚Äôs definitely the most reasonable solution
11:56:57 <Lokathor> i personally can't think of a reason to not do that other than "i don't wanna"
11:57:00 <Lokathor> but i'm no haskell expert
11:58:20 <davean> Lokathor: Base isn't really quite exactly linked to GHC?
11:59:19 <Lokathor> davean, base doesn't have to actually change code each GHC version, but when it does it's easiest to remember the changes by GHC version, because that's what people talk about a lot more
11:59:34 <davean> Lokathor: Yes, but the conenction is in NEITHER direction
11:59:51 <davean> base is truly seperate from GHC, they're just closely connected
11:59:59 <Lokathor> i'm not sure what you mean by that
12:00:39 <Lokathor> i mean, as far as i know, you can't run GHC with a version of base it's not intended for. you just have to get a newer GHC if you want a newer base for some reason
12:00:45 <davean> Lokathor: "base" can be used by other compilers (and has been), I can use multiple versions of base even
12:00:51 <davean> Lokathor: ah, but you can!
12:00:56 <davean> it requires recompiling GHC
12:00:59 <Lokathor> ha
12:01:04 <Lokathor> then that doesn't count so much, does it
12:01:08 <davean> sure it does
12:01:21 <davean> I have no idea why it wouldn't count
12:01:38 <kamyar> tippenein: Thnx! But there is still something I can understand here
12:01:53 <Lokathor> because people aren't going to recompile their compiler, they're just going to get the newer compiler if they're going to go through that much effort
12:01:58 <davean> ... I do
12:02:08 <davean> the fact that most people doesn't seems entirely irrelivent
12:02:25 <Lokathor> uh, that's a silly statement i think
12:02:28 <davean> infact, if no one did it wouldn't really matter
12:02:32 <kadoban> davean: Would the version numbers not lining up in your very esoteric case ruin something?
12:02:33 <Lokathor> serving the most people at once is exactly what projects shouhld do
12:02:35 <davean> the fact is, they're not directly linked
12:02:54 <kamyar> tippenein: How can we 'hold' pool for later use?
12:02:59 <Lokathor> davean, but you can allow version ranges in your cabal file, so
12:03:03 <davean> Lokathor: No, projects should make the best tools or products they can
12:03:08 <kamyar> tippenein: I dont see any code for this
12:03:35 <cocreature> davean: but the best tool or product is not necessarily the most flexible one
12:03:38 <Lokathor> kamyar, going by the docs you linked, you want createPostgresqlPool
12:03:42 <davean> cocreature: correct
12:03:45 <tippenein> kamyar: https://github.com/parsonsmatt/servant-persistent/blob/master/app/Main.hs#L21-L23
12:03:53 <Lokathor> but if you use withPostgresqlPool instead, it'll automatically clean up the pool for you
12:04:22 <Lokathor> depending on your use case, you might choose to pass your entire program into withPostgresqlPool and run your entire program within a single connection pool
12:04:26 <kamyar> Lokathor: I know, but each time I call the function, a new pool is created! I just want to return the same
12:04:42 <tippenein> generally you keep your access to the pool in a Reader which all your application can access
12:04:59 <Lokathor> then you want withPostgresqlPool, that uses one pool the whole time that the function you pass in is running
12:05:47 <kamyar> Lokathor: Ok just got the key
12:05:51 <kamyar> tippenein: Thanx
12:05:53 <davean> Lokathor: basicly I see no more reason for base to be GHC version linked then mtl to be
12:06:20 <davean> it would be, frankly, counter productive IMO
12:06:31 <kamyar> I just have not yet get used to functional declarative pattern in which the whole program is a function and it calls others!
12:06:58 <c_wraith> davean: are you suggesting putting all functionality that depends on GHC internals into a different package than base?
12:07:08 <Lokathor> anything that requires that you *recompile the compiler itself* should be in a package called base/std/com.java/whatever that's always of a version that matches your compiler's version
12:07:12 <tippenein> kamyar: you'll get it. 
12:07:13 <kamyar> So to have a, lets say singleton, variable I just have to make it in main function
12:07:20 <davean> c_wraith: Most of it already is really
12:07:40 <Lokathor> kamyar, one moment, let me write a small example
12:07:49 <c_wraith> davean: well, not really.  Look at how many GHC.* modules are in base.
12:08:16 <davean> c_wraith: a lot of those aren't tied to GHC, they're just base internal modules
12:09:47 <c_wraith> davean: a quick scan of their contents suggests more than half of them depend on details of GHC's data layout or IO manager
12:10:04 <c_wraith> or runtime system as a whole
12:10:08 <davean> The IO manager is mostly not GHC specific
12:10:15 <Lokathor> kamyar, http://lpaste.net/355297 here is a very small example of how you might do it
12:10:33 <Lokathor> oh whoops
12:10:40 <davean> (actually, what parts of the IO manager are GHC specific at all these days?)
12:10:47 <davean> (No part I've touched)
12:10:55 <kamyar> Lokathor: Great! Thnx!
12:11:03 <Lokathor> kamyar, there, refresh the page, i had to fix the type signature
12:11:36 <Lokathor> i hope that helps as a starting point. I've never actually done this particular thing before, so come back if there's more trouble :3
12:11:38 <davean> (uh, maybe the initial setup of handlers?)
12:12:01 <davean> (The pumps aren't GHC specific at all, but their actual creation is ... sorta)
12:13:39 <Lokathor> davean, so here's my question for you: if the version on the base package were to change more often, since you can already set version ranges in your cabal file, how does that hurt you?
12:13:52 <Lokathor> And as a follow up, do you understand that it would help others (perticularly newbies) to have that system of baseVersion==GHCversion?
12:13:52 <davean> Lokathor: its not that it "changes more often"
12:14:02 <davean> Lokathor: I have no idea how it would help anyone
12:14:17 <Gurkenglas> I've told intero to apply its suggestion to add the text package when I tried to import Data.Text, but calling "stack build" from the shell still says that I should put text into the build-depends of my .cabal file. What did I do wrong?
12:15:18 <davean> Lokathor: I only see problems from it
12:16:28 <Lokathor> since you're the only person who's ever even suggested recompiling GHC to work with a different version of base as a practical thing to do, i suppose perhaps you're an outlier enough that it would harm your usecase
12:16:53 <MarcelineVQ> davean is definetly not alone in his opinion
12:17:05 <tippenein> do ppl actually use cabal successfully? They must
12:17:08 <MarcelineVQ> there is and has for awhile been ongoing work to split up base in such a way as to reduce or remove the neccesity for ghc to be involved and allow less version bumping when smaller parts change
12:17:14 <davean> tippenein: whats your issue with cabal?
12:17:36 <glguy> tippenein: sure, lots of people only use it
12:18:13 <davean> Lokathor: I mean, consider if what you're supporting is base, and NOT GHC, now you've ruined the package version policy
12:18:21 <davean> among other issues
12:18:47 <Lokathor> tippenein, almost everyone uses the project.cabal file format. not everyone uses the cabal program. many use the stack program (but that still uses the same project.cabal file format)
12:19:07 <hpc> stack uses it because it stack calls cabal
12:19:11 <davean> Lokathor, tippenein: Even when you use stack, you're using cabal, stack just uses cabal for you
12:19:32 <Lokathor> sure but i mean *manually* using the cabal program folks :P
12:19:37 <tippenein> ^
12:19:59 <davean> tippenein: so, what issue are you having?
12:20:09 <Lokathor> i'm sure that i sometimes use gcc as well when a compile a haskell project, but i wouldn't call myself a direct user of gcc
12:20:29 <tippenein> http://lpaste.net/355296
12:20:40 <tippenein> cabal build works fine. everything else fails with dep issues
12:20:58 <tippenein> I haven't figured out how to use stack with nix, so I've been trying to get more used to cabal
12:21:04 <tippenein> *raw cabal*
12:21:15 <davean> tippenein: uh, I feel thats pretty direct in what its saying
12:21:18 <Aruro> tippenein: did you read cabal docks?
12:21:31 <davean> reflex-dom specificly doesn't work with the version of base you have
12:21:43 <tippenein> davean: but it does if I build the project
12:21:46 <tippenein> why is that different?
12:22:14 <Lokathor> something you pull in as part of testing might need a lower version of reflex-dom than the version that the main binary uses
12:22:17 <tippenein> Aruro: are you really telling me to rtfm?
12:22:22 <davean> tippenein: well, you didn't conclude the configure command
12:22:25 <glguy> are the dependencies list ed in the tests in need of an update?
12:22:31 <davean> tippenein: so one has to infer what you asked for when you did the build
12:22:48 <Aruro> tippenein: im suggesting to look here, there is lots of stuff with nix, https://cabal.readthedocs.io/en/latest/
12:22:55 <davean> tippenein: one infers you already have a reflex-dom installed, and you might have a sandbox? its hard to say
12:23:06 <Aruro> tippenein: there is nothing wrong to rtfm, i wish people tell it to me more often
12:23:33 <davean> personally, I try to fully read the manual before using any software
12:23:43 <davean> cabal's isn't the best sadly
12:23:49 <davean> it doesn't even fully describe its own formats
12:24:21 <davean> ok, actually the cabal documentation is rather bad. Bad enough I'm not sure how to make an incrimental improvement which is why I haven't submitted any patches
12:24:29 <MarcelineVQ> new-build has better docs, iirc
12:24:43 <MarcelineVQ> for the user I‚Äã mean
12:25:14 <davean> MarcelineVQ: new-build is notably better at the very least
12:25:32 <davean> the docs still tie back into the bad base documentation though
12:25:39 <tippenein> ^
12:25:42 <viran> Hey folks, maybe you could help, I need to implement an equation solver (non-linear) and provide a step by step solution... any known methods on doing that?
12:25:49 <davean> the cabal docs spend a lot of time refering to cabal specific things the docs never actually describe or define for one
12:26:08 <tippenein> ok, so we agree, RTFM isn't useful in this case
12:26:14 <tippenein> Should I just switch to new-build?
12:26:23 <davean> IIRC the "data-files" part is particularly poorly dealt with
12:26:30 <jordan32942> f2 liste = ["F:" ++ a | a <- liste, '?' `elem` a]
12:26:34 <Aruro> people have been complaining about new build too
12:26:37 <davean> tippenein: one should always use new-build now IMO, but lets solve your actual problem?
12:26:48 <jordan32942> is there any way to do something else when ? is NOT elem of a ?
12:26:52 <tippenein> I don't even know what my "actual problem" is tbh
12:27:02 <davean> tippenein: we've proposed some information you didn't include and some possible sources of the problem already
12:27:13 <davean> tippenein: I think we're all just waiting for your reply to those things
12:27:28 <Aruro> and he complained about RTFM
12:27:29 <Aruro> nice
12:29:11 <tippenein> it's within a nix-shell. none of the configure commands succeed because of missing deps. cabal build completes successfully. reflex-dom is definitely installed because my build is successful. 
12:30:06 <davean> tippenein: yes, but we have no reason to believe the install is using the same things, which is specificly what we were talking about
12:30:20 <tippenein> why would the install use different deps than the build?
12:30:33 <davean> tippenein: unlike new-* theres no build plan connection here
12:30:48 <davean> tippenein: well, because, as I said, you didn't mention what the configure was for the build
12:31:07 <Lokathor> tippenein, i think what they're saying is that the "build" uses the executable profile, but that might not match the same deps a the "test" profile
12:31:48 <Aruro> tippenein: #hackage and #ghc has many people who have written cabal, perhaps they can help
12:32:14 <davean> or, the build plan might just be old - the install will make a new build plan as would configure
12:32:38 <davean> tippenein: you see the test plan isn't working in general
12:32:56 <Lokathor> (this is why you always use sandboxes with cabal, and just delete them and start over if anything at all goes wrong; we call this the "erlang" method of development)
12:32:57 <davean> and you're demanding the test plan for the install
12:33:09 <davean> Lokathor: how does that relate here?
12:33:21 <Aruro> we are talking about nix on top of everything, nobody knows what is in shell.nix yet.
12:33:21 <Gurkenglas> Is there a way to get intero to build and execute my project so I dont have to go to emacs's shell and do that manually?
12:33:35 <Lokathor> davean, you yourself just suggested that there might be an old plan in effect that's confusing things
12:33:46 <ezyang> Is this Cabal problem in conjunction with nix? 
12:33:47 <davean> Lokathor: its not confusing anything
12:34:18 <davean> Lokathor: the plans are clearly different plans, we don't have any idea how he made the plan that build works for, we know how whe can make two non-working plans
12:34:20 * ezyang doesn't know how to debug nix problems, sorr 
12:34:28 <davean> he's just not telling us what he actually did
12:34:54 <Aruro> ghcjs+nix+hell lots of stuff --> definitely cabals fault! :D
12:35:12 <ezyang> well, it probably is Cabal's fault... 
12:35:34 <Lokathor> davean, and if it was/is a sandbox then you could just delete the sandbox, start from scratch, and log all the output the entire time, so we'd be able to see what's going on in the log
12:35:54 <davean> Lokathor: don't need the sandbox for that - he could just run configure again
12:36:31 <tippenein> there definitely _is_ a lot of possible points of failure here. I'v ebeen successfully using nix-build, nix-shell, and cabal build within it for weeks now, but I only recently wanted to add a test suite
12:36:58 <davean> tippenein: I suspect you failed in adding the test suite from what I see - do you want to paste the cabal file?
12:37:09 <Aruro> and shell.nix
12:38:45 <lpaste> tippenein revised ‚Äúcabal test ‚Äù: ‚Äúcabal test ‚Äù at http://lpaste.net/355296
12:40:17 <davean> tippenein: you know "2.*" isn't very safe, right?
12:41:29 <tippenein> I'm pretty comfortable with that tbh
12:41:52 <tippenein> that's the least of my worries atm
12:42:16 <mniip> fmapping in the category of natural transformations is a way to lift the fmapping to a second/third/... type argument in a bi/tri/...-functor, does a similar construct exist for other functions
12:42:25 <davean> Its just weird you made a "2.*" on that and no constraint on anything else
12:42:53 <tippenein> it's thrown out anyway but I just copy-pasted from one of my other projects
12:43:10 <mniip> I mean, I'm writing a function that accepts an arbitrary indexed type constructor, but how can I let the user decide what argument of the constructor is the index?
12:44:07 <davean> tippenein: this is weird, I have to assume the lack of tasty-hspec is a nix issue
12:46:32 <Lokathor> so how fast is C compared to unboxed+unpacked int values?
12:47:32 <tippenein> davean: you might be right about that. the results of cabal test being the indicator?
12:47:57 <davean> yes
12:48:54 <tippenein> package.nix is part of the environment and tasty/tastyhspec are part of that. I'll check a lil deeper within the nix-shell, but I can test that quickly
12:50:01 <davean> tippenein: I mean, my main concern is still that you don't have a good reflex-dom in scope, but the test output shows something is deeply wrong with your available package set to begin with
12:50:22 <davean> never mind I'd never thouch a cabal file so poorly specified in required versions
12:50:45 <davean> but it isn't cabal's fault it can't find an install set, clearly the packages simply don't exist
12:50:55 <davean> (for your test dependencies at least)
12:51:00 <davean> Its no even a version issue
12:51:24 <tippenein> nix is the one choosing the versions
12:52:27 <davean> yes, which is exactly why I stopped using nix actually ...
12:52:44 <mniip> what edwardk module defines NT?
12:55:54 <tippenein> possibly Control.Natural mniip 
12:56:08 <mniip> thanks
12:56:18 <tippenein> thank hoogle :D
12:56:58 <mniip> weird
12:57:01 <mniip> it isn't a kmett package
13:17:01 <JScully> hi everyone, i am new to haskell
13:17:23 <JScully> i have a function called halfadder that returns a tuple (Bool, Bool)
13:17:35 <JScully> i cannot apply fst on it
13:18:01 <JScully> fst halfadder(a, b) gives me and error altough halfadder returns (Bool, Bool)
13:18:24 <lep-delete> because you apply fst to two values
13:18:32 <davean> JScully: so "fst halfadder(a, b)" is the incorrect syntax
13:19:14 <davean> JScully: you might want something like "fst $ halfadder (a, b)", or "fst . halfadder $ (a, b)" or "fst (halfadder (a, b))" or ...
13:20:53 <lyxia> fst halfadder (a, b) = (fst halfadder) (a, b), which is not what you want.
13:21:09 <JScully> ahh
13:21:34 <davean> all the things I showed are ways of reprioritizing the binding
13:23:14 <JScully> still getting errors :/
13:24:13 <monochrom> Yes, usually you make multiple mistakes at once.
13:24:25 <JScully> https://pastebin.com/2FEhArKE
13:24:38 <JScully> Couldn't match expected type `Bool'
13:24:38 <JScully>                   with actual type `(Bool, Bool)'
13:24:50 <JScully> where is this coming from?
13:25:01 <davean> I would suspect you're wrong about the type of halfadder?
13:25:05 <Tuplanolla> Does it not give you line and column numbers, JScully?
13:25:22 <davean> and ... infact you are not correct about it
13:25:28 <davean> it takes two bools, not a tuple of bools
13:25:36 <monochrom> I think halfadder is OK. How many parameters does test take? 2? 3?
13:25:36 <JScully> ahhhh
13:25:38 <davean> halfadder :: Bool -> Bool -> (Bool, Bool)
13:25:55 <Costar> you should call halfadder a b and not halfadder(a,b)
13:26:42 <monochrom> And yeah, that too.
13:27:04 <tesan> Hello @ Haskell programmers. I'm new to programming and had some experience with imperative oop... and when I came across Haskell I got confused. Would anyone mind telling me the key-advantage[s] of Haskell? (Whisper at me if you think this is spam'sh)
13:27:43 <JScully> i understand, thanks
13:27:44 <monochrom> The key advantage is lack of Object Obfuscation Pomposity (OOP).
13:28:56 <mniip> lax monoidal endofunctors? /s
13:29:02 <monochrom> https://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt  Especially slide 13.
13:29:20 <mniip> monochrom, broken link
13:30:03 <monochrom> Works here. Keep trying. I even have Adblock.
13:33:51 <mniip> weird
13:34:18 <mniip> getting ECONNREFUSED
13:34:45 <monochrom> That's strange. Works here for the 3rd time.
13:34:46 <mniip> ah good job
13:34:55 <mniip> site's blocked by govt
13:35:08 <monochrom> Eeek...
13:35:24 <Tuplanolla> They got sick of people not just sharing PDF files.
13:35:39 <tesan> monochrom: So you think OOP is a waste of resources?
13:35:44 <monochrom> Your government wants to fight university students' plagiarism? :)
13:36:08 <monochrom> Yeah, waste of natural resources.
13:37:10 <monochrom> Generally any indirect encoding of what you really mean is.
13:37:18 <JScully> phew this is though
13:37:37 <JScully> https://pastebin.com/1UP5pb9r
13:37:44 <JScully>  Probable cause: `fst' is applied to too few arguments
13:37:50 <JScully> whats wrong with that :|
13:38:20 <monochrom> moar parentheses
13:38:39 <monochrom> halfadder cin (fst (halfadder a b))
13:39:52 <monochrom> In general, just because you shrink some spaces such as "a b c(d)" doesn't mean the compiler won't stretch it back to "a b c            (d)"
13:39:57 <JScully> Couldn't match expected type `Bool' with actual type `(Bool, Bool)'
13:40:02 <JScully> error after error :D
13:40:14 <monochrom> where?
13:40:26 <JScully> 2:17:
13:40:26 <monochrom> You need to keep most updated code and error.
13:40:36 <monochrom> What's on 2:17?
13:40:47 <monochrom> You need to keep most updated code and error.
13:40:50 <JScully> my tuple starts there (halfadder cin (fst(halfadder a b)), False)
13:41:05 <JScully> https://pastebin.com/s6MD2E37
13:41:08 <mniip> monochrom, I must say I disagree
13:41:10 <mniip> OOP has its use
13:41:23 <JScully> oh
13:41:24 <JScully> i got it
13:41:26 <JScully> sorry
13:41:28 <monochrom> Yes mniip, I agree too. But minority.
13:41:47 <mniip> if you have a large codebase OOP is a good and easy to understand way to achieve modularity
13:42:49 <monochrom> I guess I am disqualified to talk about large codebase because I haven't even seen one, eh?
13:43:01 <systemfault> Assuming very experienced developers and a ton of discipline? :/
13:43:15 <monochrom> But I'll point to the fact that aspect oriented programming was a thing precisely because OOP got you the wrong modularity.
13:43:28 <systemfault> The large OOP codebases I've seen become entangled mess of mutable state.
13:44:26 <monochrom> So, I don't have first-hand evidence to support my disagreement, but I can always pit one camp of large codebase programmers against another camp.
13:45:16 <JScully> it works :>
13:45:18 <JScully> thanks
13:45:24 <monochrom> congrats
13:45:54 <Welkin> mniip: oop is anything but easy to understand
13:46:03 <Welkin> it's like a practical joke
13:46:15 <Tuplanolla> I don't have a strong opinion, but I've noticed that I certainly can't build sensible object-oriented architectures, tesan.
13:46:36 <tesan> OOP seems very easy for me to understand. Atleas as far I have seen... even with operator overloading.
13:46:44 <Welkin> what counts as a "large codebase"?
13:46:56 <Welkin> it depends on the language, of course
13:47:12 <Welkin> the rails codebase I work on is terrible
13:47:19 <Welkin> it is very oop
13:47:52 <Welkin> things are throw into seemingly random files and functions come out of nowhere because they are inherited by some other class deeper in the hierarchy
13:47:53 <Tuplanolla> I've probably written some tens of thousands of lines of object-oriented code, but it's only ever ranged from terrible to mediocre.
13:48:16 <Welkin> mutations everywhere
13:48:25 <tesan> Well, Ruby is meant to be as much oop as possible, as far as I remember reading on Wikipedia. The maker said "I have seen Python, but it wasn't nearly oop enough in comparison to what I wanted... they had it like an add-on" or something like that.
13:49:16 <Welkin> 2/3rds of the codebase is tests, in terms of lines of code
13:49:33 <Welkin> and things still break all the time
13:51:02 <monochrom> In terms of armchair philosophy, I can't argue against the multiple dispatch story, but the single dispatch story is morally wrong.
13:51:55 <Tesan[ES]> Looks like someone took my nickname. Welkin, did you say something to me in the meantime?
13:52:41 <Tuplanolla> That someone was you, Tesan[ES].
13:53:20 <Tesan[ES]> More like, someone else connected with "tesan" too and kicke me off of freenode... so I had to change to Tesan[ES].
13:53:41 <Tuplanolla> Oh. That's always nice.
13:54:40 <entuland> Tesan[ES], didn't you register your username?
13:54:45 <MarcelineVQ> hmm, usually that says nick relcained or something rather than ping timeout I thought
13:54:47 <Tesan[ES]> Well, my OOP experience comes from Python. There, the help function and the way docstring documentation is made allows easy documentation of a class and all the methods and attributes it inherits.
13:55:03 <EvanR> idris has nice doc strings
13:55:17 <EvanR> haskell has something
13:55:22 <Tesan[ES]> @entuland: No, I didn't.  I just downloaded Konversation from KDE for Linux and gave it a go.
13:55:22 <lambdabot> Unknown command, try @list
13:55:54 <monochrom> Good help systems are not caused by OOP. Only accidentally highly correlated.
13:56:19 <entuland> Tesan[ES], ah okay
13:56:29 <monochrom> The same way density of cellphone signal towers is highly correlated to birth rate.
13:57:04 <mniip> Tesan[ES], most likely you just timed out. tesan is not registered
13:57:07 <entuland> Tesan[ES], try issuing "/nick tesan" 
13:57:09 <monochrom> Racket has good help system.
13:57:33 <Tesan[ES]> Yet, I kept my connection to Mozilla.  Well okay I'll check it...
13:57:53 <tesan> Weird...?
13:58:11 <nshepperd> blame your internet connection
13:58:33 <tesan> As I said, I kept my connection to the Mozilla irc server ^^   The rust language chatroom was active all along.
13:58:53 <tesan> So it's something between my client and freenode
13:59:39 <geekosaur> [07 20:52:05] * tesan has quit (Ping timeout: 240 seconds)
14:00:22 <geekosaur> probably behind a NAT and it either wrapped around (common for off the shelf router/APs) or timed out (likewise, occasionally adjustible)
14:01:39 <monochrom> "Only time will tell." :)
14:03:20 <torstein> "NB: With TypeInType, you must import * from Data.Kind" how the hell to I do that?
14:03:50 <torstein> import Data.Kind (*) gives parse error, and importing Data.Kind alone is not sufficient
14:03:51 <JScully> i dont understand the error messages
14:03:55 <JScully> https://pastebin.com/TtAK5q5p
14:04:04 <JScully> 4:31, Couldn't match type `(Bool, Bool, Bool, Bool)' with `(Bool, b0)'
14:04:08 <monochrom> Is it OK for you to "import Data.Kind"?
14:04:24 <tesan> Well, let me ask something this way...  I made an OTP [One-Time Pad] Cypher, as those who know this basic cypher, it replaces the characters of a text with the character of the same position in the alphabet + (or minus, depending on choice) the random number assigned to that specific characterposition in the text. How would you approach this project in Haskell-esque style?
14:04:25 <monochrom> If not, Data.Kind((*)) ?
14:04:48 <nshepperd> 'import Data.Kind'
14:04:50 <JScully> Expected type: (Bool, b0) , what is b0 :|
14:05:32 <nshepperd> neither 'import Data.Kind (*)' nor 'import Data.Kind ((*))' work, eh
14:06:04 <sphinxo> What is the name of a property a type system can have to prove its soundness?
14:06:23 <monochrom> JScully, fst is for 2-tuples only, not 4-tuples such as your Nibble.
14:06:57 <monochrom> And I do not understand why Nibble is involved at all.
14:07:21 <JScully> ashh
14:07:26 <JScully> that clears that up thanks
14:07:30 <monochrom> sphinxo: Is it OK to answer "soundness"? :)
14:07:56 <monochrom> The other one I can think up now is "has model".
14:09:27 <MarcelineVQ> torstein: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-kind
14:09:40 <sphinxo> monochrom: has model?
14:15:07 <jabesed> I still have quite a bit to read on haskell's 'dependent' type programming, and there's something I haven't come across yet and would like to know
14:16:33 <jabesed> is there some usual idiom for establishing some property relating types, i.e.   guaranty that the type T x y, is such that R(x,y) for some selation R  
14:16:41 <jabesed> *guarantee
14:17:26 <sphinxo> it might be worth taking a look at idris for ( for the moment ) nicer syntax and less performance
14:18:18 <jabesed> sphinxo: I've used coq (although I've forgoten a bit), so I'm somewhat familiarised with the basic principles
14:18:28 <jabesed> but for instance, in coq totality is fundamental
14:19:15 <sphinxo> fundamental, meaning?
14:19:15 <jabesed> if I recall correctly you can establish relation between types via a function F(t1,t2) returning either a singleton type or void
14:20:26 <jabesed> such that when Void is returned you cannot typecheck since you lack a witness (that is, you cannot return a result)
14:20:38 <jabesed> in Haskell you are free to diverge
14:20:43 <sphinxo> yeah in idris you can write a function suchlike plus_commutes : (n : Nat) -> (m : Nat) -> n + m = m + n
14:20:57 <jabesed> right
14:21:36 <jabesed> and wouldn't that relly on totality, in the sense that without it you could prove false?
14:22:12 <lyxia> if you assume some good faith on the part of users you can do something like that in Haskell.
14:22:40 <sphinxo> what would the type  n + m = m + n look like in haskell?
14:22:44 <jabesed> lyxia: how so?
14:22:55 <lyxia> One can certainly put a bottom anywhere but that's no fun for anyone.
14:23:01 <Cale> :t fix id
14:23:03 <lambdabot> a
14:23:15 <jabesed> lyxia: in the sense that he will himself make sure not to diverge? 
14:23:21 <sphinxo> ( also idris has a nice thing to automatically write code for you )
14:24:01 <jabesed> lyxia: right, but there's more ways to diverge other than just writing bottom, you may accidently diverge if your computation won't terminate (by accident)
14:24:12 <nshepperd> what does 'T x y, is such that R(x,y) for some relation R' mean?
14:24:41 <jabesed> nshepperd: T is a type constructor, x and y types passed as arguments, R(x,y) a relation between types
14:25:12 <sphinxo> is that just a dependent type?
14:25:30 <lyxia> jabesed: the guarantees are much weaker, but they are still useful.
14:25:38 <jabesed> sphinxo: not sure if I understood the question...
14:25:40 <nshepperd> you can make T a GADT and add 'R x y' as a constraint to all its constructors
14:26:01 <nshepperd> data T x y where { MkT :: R x y => ... }
14:26:42 <sphinxo> Ahh sorry I misunderstood
14:27:04 <nshepperd> then for any x,y where ¬¨(R x y) the only element of T x y is bottom
14:27:06 <jabesed> lyxia: I was wondering though if there was some "workaround"... for instance,  we could define the relation as a type family, and have some "error type" that when returned the program fails to compile
14:27:51 <jabesed> lyxia: disclaimer, I didn't put much thought into this yet, but at first sight seems like a possibility
14:28:05 <lyxia> a workaround for what
14:28:50 <jabesed> nshepperd: not sure if I understand how that works... you mean make R a class?
14:29:51 <jabesed> lyxia: a workaround for implementing certain checks that in languages like cock relly on totality 
14:30:52 <tippenein> `there is no file-watch for cabal, right?
14:31:53 <jabesed> lyxia: the idea would be that while in a total language we return void in order to guarantee a type with no possible term that makes it compile (for lack of witness), here we'd just return an error type that guarantees a type error
14:32:39 <nshepperd> jabesed: i thought R was already a class. but if it's a function like * -> * -> Bool then that works too, putting (R x y ~ True) as the constraint
14:33:19 <JScully> test :: (Nibble -> Nibble -> Nibble) -> [( Nibble , Nibble )] -> String
14:33:23 <JScully> i have this signature
14:33:31 <JScully> the first parameter is a function, the second a list
14:33:43 <JScully> is it possible to run all elements in the list with this function
14:34:26 <Tuplanolla> :t map . curry
14:34:28 <lambdabot> ((a, b) -> c) -> [a] -> [b -> c]
14:34:40 <seequ_> JScully: map (uncurry f) l
14:34:49 <Tuplanolla> Yes, that direction.
14:35:00 <Tuplanolla> :t map . uncurry
14:35:01 <lambdabot> (a -> b1 -> b) -> [(a, b1)] -> [b]
14:35:26 <jabesed> nshepperd: ok that's what I was looking for, so what happens if: not (R x y)
14:35:40 <jabesed> nshepperd: will it not type check?
14:36:10 <JScully> hmm interesting
14:36:29 <nshepperd> jabesed: creating a value of that type other than bottom will not type check
14:37:36 <jabesed> nshepperd: yeah but that's the problem I was raising :/  you can still satisfy it using bottom
14:38:02 <jabesed> nshepperd: which is why I was saying it would be nice to have something like an error type
14:38:21 <lyxia> jabesed: I think sometimes it's still useful to have the empty type around than just crash.
14:38:21 <jabesed> nshepperd: then one could define R as a type family 
14:38:37 <JScully> how to i iterate over all pairs ?
14:38:44 <jabesed> lyxia: I don't mean crash, I mean not type check
14:38:52 <seequ_> JScully: just map
14:39:05 <nshepperd> I don't know if it's possible to make simply naming 'T x y' fail to type check
14:39:12 <JScully> it seems like this only gives the first pair of the list
14:39:51 <lyxia> jabesed: that's what I meant. You're introducing a type level bottom, and bottom can colloquially be interpreted as a crash.
14:40:22 <jabesed> lyxia: why wouldn't you want that though? 
14:42:34 <seequ_> Tuplanolla: 00 :)
14:43:47 <Putonlalla> Now what?
14:45:57 <JScully> whats the difference [(Nibble, Nibble)] vs (Nibble, Nibble)
14:46:02 <JScully> list vs tupel ?
14:46:55 <entuland> not just that, for the few thigs I know about haskell JScully 
14:46:58 <lyxia> "list of tuples" vs "tuple"
14:47:08 <entuland> the former is a list with one tuple inside
14:47:12 <entuland> the latter just the tuple
14:47:24 <JScully> ok
14:47:53 <JScully> so if i want to get the first item of the tupel i need to something like
14:47:55 <entuland> lyxia actually got that more precise than me I guess, JScully 
14:48:04 <JScully> fst(fst(list))
14:48:48 <JScully> acutally
14:48:52 <JScully> fst(head(list))
14:48:54 <JScully> as it seems
14:50:28 <entuland> uhm... just "fst (head list)" should be enough I think, the inner paren is not necessary AFAICT JScully 
14:50:54 <JScully> oh yes :)
14:51:21 <entuland> > fst (head [(1, 2)])
14:51:23 <lambdabot>  1
14:51:26 <entuland> yep
14:52:39 <JScully> so what is the right approach to return a string from a function
14:52:44 <JScully> should i use show?
14:53:00 <JScully> i need to concat it from different values
14:53:36 <entuland> I bet the best option there is to show your attempts in a bin or the alike, JScully, so to provide context
14:53:45 <entuland> but I'm new here and I'm not sure about the customs
14:54:29 <JScully> just generally, i have a function that returns a string which i would call from different other functions
14:54:47 <JScully> i only want to "show" the string in the calling-functions
14:55:51 <JScully> in other language you would use something like "return"
14:55:59 <entuland> unfortunately I'm not that into the language to be of any help there... I've arrived just here: http://learnyouahaskell.com/higher-order-functions in my study of Haskell
14:56:12 <seequ_> JScully: show gives a string representation of a thing. That might or might not be what you want.
14:56:39 <seequ_> JScully: oh, return us implicit
14:57:03 <seequ_> JScully: f x = x + 1 returns x + 1
14:57:14 <seequ_> return is implicit*
14:58:02 <c_wraith> Think of it as being an expression-oriented language.  Expressions don't return values, they *have* values.
14:58:02 <JScully> ok so i have a function A that return an Integer, i have another function that makes 4 calls on that function A and now i want to return it as a string
14:58:17 <JScully> is it, show(functionA a) ++ show(functionA b) ++ and so on
14:58:17 <JScully> ?
14:58:34 <Cale> JScully: that should work
14:58:42 <c_wraith> That's basically right.  If you have problems, show us the precise code
14:59:10 <Cale> You could also write something like concatMap (show . functionA) [a,b..]
14:59:38 <Cale> (though, it would be surprising if you didn't want to also stick some spaces in there, so maybe that's a little too terse)
14:59:55 <JScully> the problem is when i call this function from oither fcuntions that return strings
15:00:02 <JScully> i have show(show(show(...)))
15:00:08 <seequ_> :t concatMap
15:00:09 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:00:11 <JScully> which gives me a odd looking output
15:00:29 <c_wraith> well.  don't show String values.
15:00:33 <c_wraith> they already are Strings
15:00:34 <seequ_> I've been folding for no reason
15:00:34 <JScully> i basically want to call show only one time
15:00:40 <JScully> hm
15:00:49 <MarcelineVQ> JScully: consider the ++ you used above as a possible solution to that
15:00:50 <Cale> JScully: Yeah, just don't apply show to something if it's already a String
15:01:03 <sphinxo> how would you go about writing something like http://lpaste.net/280646335785336832 in haskell?
15:01:25 <Cale> applying Show to a String adds quotes and escapes anything outside of printable ascii
15:01:26 <JScully> how do i concat two functions that both return strings
15:01:48 <Cale> JScully: You mean concatenate their String results? Using (++)
15:01:57 <JScully> myWrapper = functionA() ++ functionB()
15:01:59 <JScully> is not working
15:02:04 <sphinxo> drop the ()
15:02:12 <JScully> oh wait
15:02:13 <JScully> it is
15:02:17 <JScully> :| sorry
15:02:33 <mbw> How can I get an Array (from the array package) from a Vector?
15:02:45 <sphinxo> three = add 1 2
15:03:17 <MarcelineVQ> sphinxo: what does -> mean there?
15:03:23 <Rembane> mbw: Via a list?
15:03:44 <sphinxo> MarcelineVQ: returns a function type
15:03:50 <mbw> But there should also be a dirty way, right?
15:04:01 <JScully> does haskell has function to convert 1001 to 9 ? binary to decimal ?
15:04:03 <mbw> I thought array was the underlying representation anyway.
15:04:12 <sphinxo> so given [Int, Int, Int] produce a function like Int -> Int -> Int
15:04:15 <MarcelineVQ> are you crafting a n-ary function from a list of types?
15:04:16 <MarcelineVQ> ah
15:04:25 <Cale> :t readIntAtBase
15:04:27 <lambdabot> error: Variable not in scope: readIntAtBase
15:05:08 <Cale> oh, right
15:05:10 <Cale> it's just readInt
15:05:14 <Cale> :t readInt
15:05:15 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
15:05:44 <Cale> > readInt 2 (`elem` "01") digitToInt "1001"
15:05:46 <lambdabot>  [(9,"")]
15:06:05 <JScully> uff
15:06:22 <Cale> It's pretty generalised :P
15:06:49 <Rembane> mbw: Maybe, why do you need a dirty way?
15:07:02 <JScully> ok 2 is the base
15:07:16 <JScully> you have 01 as valid inputs
15:07:35 <JScully> and a function that does some magic :D
15:07:44 <Cale> yeah, and digitToInt is used to convert the '0' and '1' into actual Int values.
15:08:53 <lyxia> sphinxo: type family Interp (as :: [*]) where Interp '[t] = t ; Interp (h ': t) = h -> Interp t
15:08:57 <Cale> and then the result is a list of possible parses (which should only ever really have 0 or 1 elements), each of which consists of the number that was parsed, and the remainder of the string
15:09:51 <JScully> so i need to sum it up?
15:10:03 <Cale> Well, I don't know what you're trying to do
15:10:13 <JScully> convert 1001 into 9
15:10:14 <mbw> Rembane: If I work with an immutable vector, I shouldn't have to copy it in order to work with an equivalent array representation.
15:10:18 <Cale> It produces 9 there
15:10:31 <JScully> but it does not return an int right
15:10:34 <Cale> (Well, it produces [(9, "")], but you can pattern match that)
15:10:39 <Cale> The parse might in some cases fail
15:10:41 <JScully> i se
15:10:45 <Cale> > readInt 2 (`elem` "01") digitToInt "apple"
15:10:46 <JScully> see
15:10:47 <lambdabot>  []
15:10:52 <Cale> > readInt 2 (`elem` "01") digitToInt "10001001apple"
15:10:54 <lambdabot>  [(137,"apple")]
15:11:07 <lyxia> sphinxo: http://lpaste.net/355304 a proof of n + m = m + n
15:11:34 <sphinxo> lyxia: woah! awesome!
15:12:35 <Rembane> mbw: Why do you need an array representation?
15:14:22 <mbw> Rembane: Since I am trying to work with multi-dimensional arrays. I tried Repa, Accelerate, hmatrix, hTensor and now I want to go with the array package.
15:15:24 <Rembane> mbw: I see. Fun!
15:15:26 <JScully> my last task is to represent 1001 as -7 (complement of two ???)
15:15:28 <mbw> I *could* just scratch vector alltogether, but being able to zip/unzip in O(1) time is helpful, since it can assure things like "these vectors all have the same length".
15:15:40 <JScully> does anyone know where -7 is coming from :|
15:16:01 <Putonlalla> @google two's complement integer
15:16:03 <lambdabot> https://en.wikipedia.org/wiki/Two%27s_complement
15:16:14 <JScully> ahh its that one
15:16:17 <JScully> thanks
15:24:25 <JScully> hm does not seem there is such function to represent two complements
15:29:15 <mbw> What is this netsplit thing?
15:29:40 <Clint> it's what makes irc go 'round
15:30:21 <mbw> So what was that message just now?
15:34:04 <hpc> mbw: freenode the network is made up of multiple irc servers distributed across the world
15:34:15 <hpc> mbw: when one can't talk to the rest, the network "splits"
15:34:56 <mbw> I see.
15:35:17 <sphinxo> is it possible to make type level lists lazy?
15:35:26 <sphinxo> am I even making sense
15:35:36 <mbw> Btw I found out that I can pattern match against the Vector from Data.Vector.Primitive, to get access to the underlying ByteArray.
15:35:40 <mbw> Cool stuff.
15:36:36 <c_wraith> sphinxo: making sense?  yes.  Can you do it?  Not at the moment.  Types are strict.  (Until someone comes along with a GHC extension to change that...)
15:36:36 <JScully> my rippleCarryAdder is not working :(
15:37:04 <sphinxo> c_wraith: ahh ok thanks
15:37:18 <c_wraith> sphinxo: I don't know of any current plan to add it, but who knows what'll happen in the future.  5 years ago, I figured GHC would never get dependent types...
15:37:20 <sphinxo> JScully: paste the entire code somewhere: http://lpaste.net/
15:39:12 <JScully> sphinxo this page does not let me paste
15:39:17 <JScully> it times out
15:39:28 <sphinxo> oh :|
15:39:35 <sphinxo> well any paste site would do
15:40:12 <JScully> https://pastebin.com/bCfxB6KL
15:40:23 <JScully> well it does compile but gives a wrong result
15:41:05 <sphinxo> What's get1st
15:41:15 <JScully> first element of the nibble
15:41:43 <JScully> implemented like get1st (a,_,_,_) = a
15:42:39 <JScully> rippleCarryAdder (True, False, False, True) (False, False, False, True) gives True, False, False, False
15:42:47 <JScully> but it should give True, False, True, False
15:43:01 <monochrom> You're really better off writing like "rippleCarryAdder (a1, a2, a3, a4) (b1,b2,b3,b4) = ..."
15:43:44 <JScully> yes, well the signature was given :|
15:43:49 <JScully> i could change it temporary though
15:43:53 <JScully> but would need to switch back
15:43:57 <MarcelineVQ> that doesn't change the signature
15:44:09 <JScully> oh
15:45:24 <MarcelineVQ> monochrom is showing you how to pattern match on a Nibble to name its parts, just like what your get functions do but all at once
15:45:45 <JScully> i see
15:45:58 <JScully> i change this now
15:47:34 <JScully> https://pastebin.com/8jkAqRBX
15:47:37 <JScully> looks better
15:48:43 <JScully> ok double check my fulladder
15:49:19 <monochrom> Next thing you need is a "where"-clause like "where (s1, c1) = fulladder a1 b1" etc for well organization and easy inspection.
15:49:54 <JScully> full adder is working correctly
15:49:56 <monochrom> (Is lpaste no working?)
15:50:18 <MarcelineVQ> it's working, just sometimes you gotta ask it twice lately
15:50:37 <monochrom> Ah
15:51:24 <JScully> maybe i should recheck the expected result
15:51:37 <JScully> does anyone know a online rippleCarryAdder?
15:52:28 <lpaste> monochrom pasted ‚ÄúUse patterns and local defs already‚Äù at http://lpaste.net/355306
15:52:33 <monochrom> That.
15:53:09 <monochrom> Err wait a second this makes no sense. fulladder has how many parameters?
15:53:20 <monochrom> Oh, my mistake.
15:53:22 <JScully> three
15:53:50 <lpaste> monochrom revised ‚ÄúUse patterns and local defs already‚Äù: ‚ÄúUse patterns and local defs already‚Äù at http://lpaste.net/355306
15:53:56 <monochrom> Like that.
15:54:41 <monochrom> Well-organized unrepetitive code is easiest to inspect and debug (and probably no bug to de in the first place).
15:55:07 <JScully> looks good
15:55:09 <MarcelineVQ> even just a fullAdderSnd in the where combining  fulladder and snd  would help a lot for readability
15:55:28 <JScully> let me think about the todo part :D
15:57:42 <sphinxo> JScully: I think your fulladder is implemented incorrectly
15:58:02 <sphinxo> oh wait
15:58:03 <JScully> i have checked it against the truth table :|
15:58:23 <sphinxo> expected output for  (True, False, True, False) (False, False, False, False)
15:58:25 <sphinxo> ?
15:58:32 <sphinxo> for rippleCarryAdder
15:58:48 <JScully> T,F,T,F
15:58:57 <JScully> no wait
15:59:17 <JScully> (T,F,F,T) (F,F,F,T) SHOULD BE T,F,T,F
15:59:42 <JScully> thats the only combination i have
16:30:17 <monochrom> Perhaps False means 1, True means 0. :)
16:31:06 <JScully> hm
16:31:12 <JScully> well it gives 1000
16:31:17 <JScully> not 1010 or 0101
16:31:36 <JScully> its messed up somewhere :|
16:32:03 <monochrom> To be fair I don't even know who's MSB and who's LSB.
16:32:21 <JScully> whats that
16:32:48 <hololeap> something about eggs
16:32:56 <monochrom> If you don't know them, you aren't ready for bitwise operations.
16:33:20 <hololeap> basically, its the direction the bits are read
16:33:31 <hololeap> left-to-right or right-to-left
16:33:41 <JScully> ahh, well i dont know the english abbreviations
16:34:00 <hololeap> stands for most-significant bit and least-significant bit
16:34:12 <JScully> yes i just looked it up
16:34:13 <JScully> thanks
16:34:45 <hololeap> yw
16:38:38 <mniip> 1494199954 [02:32:34] <monochrom> If you don't know them, you aren't ready for bitwise operations.
16:38:49 <mniip> tbh in bit"wise" operations you don't need to know
16:39:17 <mniip> s/tbh/to nitpick,/
16:41:10 <monochrom> It would be cool to hold a debate between you and maerwald.
16:44:02 <JScully> how big is the depth of a 2^k-Bit carry select adder?
16:44:10 <JScully> how do i calculate that?
16:45:26 <monochrom> Are you sure it's 2^k bits? Not just k bits?
16:45:52 <JScully> the question states 2^k
16:46:01 <monochrom> But I forgot carry select adders.
16:46:05 <JScully> i dont even know what 2^k is :(
16:46:31 <monochrom> Ah! They want nice powers of 2, like 8 bits or 16 bits or 32 bits or 64 bits.
16:47:39 <JScully> can you explain that further please
16:47:54 <mniip> monochrom, but debate is so much harder than shitposting on irc
16:48:23 <monochrom> Oh! Just s/debate/shitposting then.
16:48:34 <mniip> count me in
16:48:41 <JScully> what does k stand for?
16:48:55 <monochrom> k stands for 0 or 1 or 2 or 3 or 4 or ...
16:49:06 <monochrom> 32 bits is 2^5 bits.
16:49:42 <JScully> ah
16:50:42 <JScully> on the internet it says the gate level depth is O(sqrt n)
16:50:55 <monochrom> Very likely n = 2^k
16:51:41 <JScully> so a 32 bit carry select adder has a depth of O(sqrt 2^5)
16:52:10 <JScully> where O just means "worst case" ?
16:52:12 <mniip> monochrom, to me bitwise functions are strictly those that are expressible with 'zipWith' on bit arrays
16:52:51 <rightfold> JScully: O means upper it never goes above that
16:53:03 <mniip> O is upper asymptotic bound
16:53:18 <JScully> thanks
16:53:41 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCB63-2017-Summer/01-asymptotic-p1.pdf by yours truly.
16:54:05 <rightfold> Mnemonic is the position of the "-": Œ© has it low, Œò has it in the middle, O has it up in cursive üòõüòÇ
16:54:30 <Lokathor> https://github.com/Lokathor/learnopengl/blob/master/app/Lesson01.hs wheeeee
16:54:50 <mniip> rightfold, um to me the mnemonic was
16:54:54 <mniip> O is really omicron
16:55:40 <monochrom> rightfold: Then you will like my cursive joke https://plus.google.com/u/0/102208456519922110915/posts/PC5W3XVtq5M
16:55:54 <rightfold> œÉ
16:58:45 <mniip> rightfold, that's the small-o
16:58:54 <mniip> you're looking for big omicron
17:04:22 <JScully> How deep are 2^k-Bit carry select adders, if the adders Low, High0, High1 are implemented as 2^k-1 Bit adders
17:04:22 <JScully> whats the point here?
17:04:22 <JScully> like i need more adders because the adders used are processing less bits
17:04:35 <JScully> is this a right assumption?
17:20:59 <JScully> hm no this is wrong
17:24:16 <JScully> if a 2^5 adder is realized using 2^4 adders, that means a 32 bit adder only needs two 16 bit full adders right
17:25:04 <JScully> that means it needs twice the depth
17:25:10 <hololeap> after installing bash-completion, it just does
17:26:32 <hololeap> wrong channel
17:35:41 <JScully> https://pastebin.com/WubVTVYs
17:35:53 <JScully> in line 11, is c1 even available at that time
17:36:04 <JScully> is line 10 executed before line 11 is accessd?
17:37:52 <JScully> i am not sure how i can check that
17:40:23 <JScully> hm no its not !!
17:40:36 <JScully> c2 should be true but it is not true
17:44:55 <Efe> Hello, can someone help me with a really basic error?
17:45:12 <mniip> ?
17:45:20 <Efe> I researched but I could not find any solution : ERROR - Unrecognised character `\1' in column 1   
17:45:25 <JScully> ok my halfadder and my fulladder are working
17:45:27 <JScully> thats for sure
17:45:46 <JScully> Efe, post the code :D
17:45:53 <Efe> My function is higher l = [x|x <- l , x > 3]
17:46:17 <Efe> I'm trying to use filters, because I read at haskell oficial tips that recursion is pretty bad 
17:46:30 <Efe> Even at university we are using recursion for list
17:46:37 <mniip> that's weird
17:46:37 <monochrom> You have an invisible control character in your file. Delete it and start again for scotched earth policy.
17:46:41 <mniip> everything in haskell is recursion
17:46:58 <Efe> explicit one I mean
17:47:30 <mniip> writing code that has already been written is bad
17:47:33 <mniip> not explicit recursion
17:47:54 <Efe> wow... thank you very much monochrom
17:48:35 <monochrom> mniip: The actual advice from those teachers (some of them are here too like byorgey) is more subtle, but to student it does come across as "don't recurse" because students oversimplify.
17:48:47 <mniip> well yes
17:49:03 <mniip> I was trying to say that it's a misinterpretation
17:49:07 <Efe> yeah, we are going thorught code logic , not for sugar code
17:49:12 <monochrom> Students always oversimplify. It's why they religiously believe "big-O = worst case" for example.
17:49:41 <mniip> monochrom, what do you mean by that
17:50:12 <monochrom> I don't know how to say it better, since I'm conveying a wrong belief anyway.
17:50:23 <erisco> a more relatable explanation may be to think why we use higher level languages
17:50:30 <erisco> i.e. why Haskell and not, say, assembly
17:50:32 <monochrom> "use big-O for worst case, big-Omega for best case" something like that.
17:50:40 <mniip> do you mean that big-O could be an unstrict bound? 
17:50:53 <mniip> or is there something I don't know about big-O
17:50:58 <erisco> we can write programs that exhibit the same behaviour with either one
17:51:25 <erisco> but what we're missing in assembly is exactly why we call other languages "higher level" languages
17:51:38 <erisco> we're missing higher level concepts and definitions which make reasoning about problems simpler
17:51:51 <erisco> or certain problems, I should say. it is a pick a tool for the job kind of problem.
17:52:17 <erisco> by using explicit recursion we're limiting ourselves to the most basic facilities
17:52:36 <erisco> by using definitions like foldr we're using higher level facilities
17:52:59 <erisco> this makes our reasoning, intent, and code better and clearer
17:54:19 <erisco> the beginner defaults to using explicit recursion extensively because it can be used universally
17:54:40 <erisco> so just by knowing how to use that you can start to think of solutions using it
17:55:17 <erisco> whereas other methods are more specialised and require further knowledge and study
17:57:17 <davean> "haskell oficial tips" uh
17:57:40 <JScully> [((True,False,False,True),(False,False,False,True))]
17:57:53 <JScully> does "map function [((True,False,False,True),(False,False,False,True))]" work
17:58:00 <JScully> or should i remove the [ ]
17:58:00 <erisco> Efe, that's for you in case you're not looking :)
17:58:22 <erisco> JScully, start up ghci or /dialog lambdabot and try it out
17:59:07 <erisco> I can catch one error for you or I can teach you how to catch errors yourself ;P
17:59:44 <Lokathor> I'd say that the primary reason to avoid explicit recursion is that you write the hidden-recursion form once and test that and then you can trust that later, so if there's a break you can focus on just what's new this time
17:59:46 <JScully> both does not work
17:59:46 <JScully> hn
18:00:11 <Lokathor> the same reason that you don't use explicit GOTO in C when you can use for or while, even though technically you could just use GOTO all the time
18:00:33 <erisco> JScully, okay, the next step is to explain what you are trying to do, what you tried, what the error is, and what you expected
18:00:59 <erisco> JScully, you can make use of lpaste to share longer code segments
18:01:17 <dmj`> fix is the new goto
18:01:33 <JScully> i think i got this, but my question from before is still unclear
18:01:55 <JScully> http://lpaste.net/355308
18:02:09 <JScully> is c1 in line 11 even available, it seems like its always false
18:02:19 <JScully> is the c1 in line 10 used in line 11?
18:02:24 <JScully> does haskell work that way?
18:02:36 <erisco> JScully, all definitions in a where block are available to each other
18:02:50 <erisco> that is, they are all in the same scope
18:03:17 <JScully> can i debug somehow single values in that function
18:03:26 <JScully> i would like to monitor all values
18:03:40 <Lokathor> JScully, that's a little less easy, but possible
18:03:42 <erisco> for this I would just evaluate the individual expressions in ghci
18:04:00 <Lokathor> JScully, ^
18:04:26 <Lokathor> but if you really want, something like traceShow from https://hackage.haskell.org/package/base-4.9.1.0/docs/Debug-Trace.html
18:05:38 <Lokathor> or just trace
18:05:43 <JScully> i saw that function
18:05:44 <Lokathor> it gets ugly fast, unfortunately
18:05:51 <JScully> but i cannot just put it inside my code
18:05:57 <Lokathor> (s2, c2) = fulladder a2 b2 c1  ----> (s2, c2) = trace ("s2,c2:" ++ show (fulladder a2 b2 c1)) (fulladder a2 b2 c1)
18:06:29 <erisco> fulladder True True False  is easy to evaluate
18:06:43 <JScully> the fulladder works
18:06:43 <erisco> that is the case where c1 should not be False, if I understand the content
18:06:54 <JScully> i dont know if the ripplecarryadder gets the right values
18:06:58 <JScully> not sure how i can debug this
18:07:15 <erisco> you mean you are not sure if the arguments to rippleCarryAdder1 are correct?
18:07:19 <JScully> yes
18:07:28 <JScully> because it seems like c1 is false
18:07:31 <JScully> where it should be true
18:07:46 <erisco> well then I'd go further up to the expression involving rippleCarryAdder1
18:07:47 <Lokathor> JScully, I'd evaluate all possible inputs to fulladder one at a time to see if they're all correct. If they are, then you might be threading the output values around wrong
18:08:34 <JScully> i did that already
18:08:38 <JScully> fulladder is working 100%
18:08:55 <Lokathor> then your arguments are being threaded around wrong
18:09:09 <JScully> i manually tried this https://pastebin.com/c3KtVx60
18:09:14 <JScully> which gives the correct result
18:09:24 <JScully> so c2 seems to hold a wrong value
18:09:39 <Efe> did you guys work programming in haskell?
18:09:45 <erisco> okay, well, first thing is to stop going back to the incorrect explanation
18:10:02 <erisco> you've verified fulladder so c2 definitely does not have the incorrect value
18:10:25 <JScully> i verified fulladder manually with a truth table in ghci
18:10:31 <JScully> i have no idea what c2 is
18:10:38 <JScully> at the time it is computed
18:10:43 <Lokathor> if fulladder is correct, c2 can't be incorrect
18:11:23 <JScully> c2 is a parameter in rippleCarryAdder
18:11:29 <JScully> i did not verify the fulladder inside that
18:11:39 <Lokathor> c2 is calculated based on the result of the the "fulladder a2 b2 c1" expression, so it's value "when it's computed" can't affect the result, since it's not part of its own input
18:12:06 <JScully> yes i would like to debug that inside the ripple carry adder
18:12:11 <Efe> may l i = [x|x<-l,x>i] how its called the [] part, comprehension, filter? 
18:12:39 <Lokathor> JScully, haskell doesn't actually have an execution order like in C, where you can debug line by line
18:13:09 <kadoban> Efe: list comprehension
18:13:09 <erisco> a lot of the time you can solve the problem analytically
18:13:18 <Efe> Thank you kadoban
18:13:21 <halogenandtoast> Lokathor: it might be more accurate to say GHC doesn't allow you to debug line by line right?
18:13:34 <lin___> can i install XMonad using stack (from commercialhaskell)?
18:13:40 <halogenandtoast> I'm assuming a compiler author could provide that functionality.
18:13:46 <erisco> JScully, lets go through this step by step.
18:13:48 <monochrom> And then GHCi comes along allowing you some notion of stepping :)
18:13:57 <erisco> JScully, what are the values of a1, a2, a3, a4, b1, b2, b3, b4?
18:14:12 <Lokathor> halogenandtoast, you can use ghci to execute IO actions one step at a time, and a non-IO expression is printed as if you'd prefixed the expression with "print $"
18:14:18 <JScully> True, False, False, True), (False, False, False, True)
18:14:26 <erisco> okay, let me write that out
18:15:03 <halogenandtoast> Lokathor: I jumped in mid conversation so my comment might have been out of context with the rest of the conversation.
18:15:03 <JScully> rippleCarryAdder (True, False, False, True) (False, False, False, True)
18:15:11 <JScully> this is how i call it
18:15:14 <erisco> JScully, http://lpaste.net/355310 seem good?
18:15:24 <JScully> yes
18:15:53 <Lokathor> halogenandtoast, they want to "break on" a line of a pure expression, like you would in Java or C, but Haskell doesn't quite provide that because it doesn't quite execute like that
18:15:54 <erisco> now we want to know (s1, s2, s3, s4)
18:16:01 <JScully> T,F,F,F
18:16:10 <erisco> and by wanting to know that we have to look at the definitions in the where block, alright, lets do that
18:16:18 <JScully> but it should be TFTF
18:17:25 <erisco> JScully, http://lpaste.net/355310
18:17:42 <erisco> I've started working on evaluating the first fulladder. So what is fulladder True False False?
18:17:50 <JScully> True,False
18:18:09 <JScully> c1 is false
18:18:20 <erisco> good, so now we have s1 = True and c1 = False
18:18:43 <JScully> s2, c2 = fulladder False False False
18:18:58 <JScully> well thats bad
18:19:27 <erisco> JScully, now we start on the next one. What is fulladder False False False? http://lpaste.net/355310
18:20:11 <JScully> s2=False, c2=False
18:20:16 <JScully> we can stop here it hink
18:20:24 <JScully> because thats already wrong as it seems
18:20:31 <erisco> okay, what went wrong?
18:21:00 <JScully> well no nothing
18:21:04 <JScully> S2=False, C2=False
18:21:21 <erisco> so is something wrong or not wrong? should we continue?
18:21:23 <JScully> (s3, c3) = fulladder False False False
18:21:31 <JScully> results into False again
18:21:42 <JScully> now we have T,F,F so far
18:21:55 <JScully> the result from the sheet provided is T,F,T
18:22:33 <erisco> okay, so the first observation is we were able to identify where the evaluation did not meet our expectations just by working the example by hand
18:22:54 <erisco> and I did it verbosely but you were able to skip many steps and figure it out more quickly
18:23:04 <erisco> this is generally how we're going to think about Haskell programs
18:24:14 <erisco> so we've progressed from thinking something is weird with c2's scope to realising our algorithm for computing the sum is just wrong
18:24:27 <erisco> would you agree?
18:25:02 <JScully> Or the result provided is wrong
18:25:17 <erisco> well, here is something you may want to consider: endianness
18:26:26 <erisco> do you know what that is?
18:26:33 <JScully> i dont
18:26:53 <Lokathor> JScully, you said yourself that fulladder has been entirely verified. so the result provided can't suddenly just be wrong
18:26:55 <Efe> Guys, If I had to find the position of the element in a list, where the values correspond to minimum value in the list
18:26:57 <erisco> okay, here is something important about storing numbers on computers
18:27:15 <erisco> like on paper, we need to decide what order we put the digits in
18:27:40 <erisco> so with decimal notation we put the most significant digits first and the least significant at the end
18:27:43 <Lokathor> eg, 123 = "one hundred and twenty three"
18:28:14 <erisco> this normal way of writing numbers is called "big endian" in computer terms
18:28:53 <erisco> so when we have a binary number such as 1101 we understand this is 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0
18:29:09 <erisco> rather than 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0
18:29:25 <erisco> or like Lokathor says, there is a difference in how we understand 123 and 321
18:29:30 <erisco> same thing on computers
18:29:52 <erisco> now, on some computers numbers are stored in little-endian
18:29:53 <JScully> right
18:30:07 <erisco> this is backwards to how we're used to writing numbers and so can be confusing
18:30:43 <erisco> the way you are computing the sum of the nibbles assumes an interpretation of little-endian numbers
18:30:46 <erisco> can you see why that is?
18:31:39 <JScully> you mean a1 should be in place of a4 and a4 should be in place of a1=
18:31:47 <JScully> ?
18:32:03 <erisco> well, that is part of it
18:32:27 <erisco> what I mean to show you is that if you consider the addition algorithm, which I presume you're familiar with, look at how you're doing the carries
18:32:36 <erisco> you are carrying from left to right
18:33:01 <erisco> if you were doing addition on paper you'd be carrying from right to left (because you'd write the numbers in big-endian)
18:33:26 <erisco> the addition algorithm carries from the smaller to the larger
18:34:02 <erisco> so, lets guess that you've mixed up the endianness
18:34:17 <erisco> there is an easy way to see if this might be the case without changing your function at all
18:34:28 <erisco> can you find it?
18:34:45 <JScully> without a chance in code?
18:34:51 <JScully> change*
18:35:01 <erisco> without changing the definition of rippleCarryAdder1 or fulladder
18:35:35 <JScully> well i can change the order of the bits in the nibble of the calling function
18:36:03 <erisco> yes, that's it. you can just reverse both nibbles and see if you get the expected answer
18:36:11 <JScully> 0101
18:36:17 <JScully> its closer to 1010
18:36:23 <JScully> :D
18:36:36 <erisco> think a bit more
18:36:52 <JScully> do i have to revert them after calculation?
18:37:00 <erisco> remember that your adder interprets as little-endian
18:37:05 <erisco> so what format is the answer going to be in?
18:37:17 <erisco> yes, you have to reverse the answer as well to get back big-endian
18:37:25 <JScully> ah interesting
18:37:26 <JScully> :D
18:38:05 <erisco> so now you can either just write a function to reverse the nibbles as appropriate and keep rippleCarryAdder1 as-is
18:38:05 <JScully> that is probably going to be it, thank you first of all
18:38:16 <erisco> or you can change the direction you are carrying in
18:39:51 <JScully> oh my god :D !
18:40:01 <JScully> you are the smartest person i have met today :D
18:40:04 <JScully> thanks
18:40:22 <JScully> i need to read further on that endian thing
18:40:25 <mniip> that is about to change
18:40:40 <mniip> jk
18:41:42 <erisco> lol
18:42:24 <erisco> JScully, thanks and glad it worked out. I have to admit there are many people smarter than I here. after all, some of them taught me!
18:48:53 <JScully> overwhelming, thanks thanks thanks :D
18:50:04 <JScully> enough for today but i will come back for sure :)
18:53:38 <riaqn> hello, is there some index type such that, Ind n is integers in [0,n)?
18:53:47 <riaqn> I know dependent types in haskell sucks, but still wondering.
18:54:02 <erisco> riaqn, Fin
18:55:15 <erisco> data Fin :: Nat -> * where FZ :: Fin (S Z); FS :: Fin n -> Fin (S n)
18:55:24 <erisco> might be in singletons but I can't recall
18:56:07 <riaqn> erisco: thanks! https://hackage.haskell.org/package/data-fin-0.1.1.3/docs/Data-Number-Fin-Integer.html
18:56:08 <riaqn> this looks promising.
18:56:37 <mniip> riaqn, hold on!
18:56:40 <mniip> @hackage finite-typelits
18:56:41 <lambdabot> http://hackage.haskell.org/package/finite-typelits
18:56:45 <erisco> I ran into problems with promotion
18:56:48 <riaqn> never understand dependent types in haskell, so twisted.
18:57:31 <erisco> yes you can promote that type, but you don't have an unpromoted definition that is as strong as it could be
18:57:48 <erisco> particularly you're missing the SingI constraint on the natural
18:58:06 <erisco> and if you add in that constraint then you cannot promote it
18:58:30 <erisco> so for me it was a road that lead to disappointment, unfortunately
18:58:46 <erisco> detour ahead, use Idris
18:59:45 <riaqn> erisco: yeah idris. But I need some threaded programming..
18:59:52 <riaqn> might stick to haskell..
19:00:02 <erisco> riaqn, well they are not dependent types
19:00:31 <erisco> the name "singleton" is well chosen. it is that each type only has one value (ignoring bottom)
19:00:53 <riaqn> I'm not in bad need for the type checking, simply want to express"it's in the range" to the code reader.
19:00:57 <erisco> so if you know the type you know the value, and that is the key
19:00:59 <mniip> riaqn, did you check out my package :o
19:01:27 <riaqn> erisco: some kind of hack? pretty haskell..
19:01:41 <erisco> it is not a hack
19:01:46 <riaqn> mniip: Yeah I checked. How is it compared to the last package?
19:01:49 <erisco> it is as straight-forward as unit
19:01:53 <mniip> it uses typelits
19:01:54 <erisco> in principle, anyways
19:02:34 <erisco> in practice the implementation includes TH (if we're talking singletons package) which has pros and cons
19:02:45 <mniip> typelits have cleaner syntax but sometimes the compiler can't figure out your types
19:02:51 <erisco> pro is you can write straight (limited) Haskell code and have it lifted automatically
19:03:12 <erisco> con is that you have to sift through confusingly named definitions... particularly in error messages
19:03:35 <mniip> there's typelits-witnesses for doing advanced typelits arithmetic that does type-check
19:03:38 <riaqn> mniip: cool. I'll try that out. (don't know what you mean though).
19:03:51 <mniip> :k 1
19:03:52 <lambdabot> GHC.Types.Nat
19:04:02 <mniip> riaqn, this stuff ^
19:04:14 <mniip> :t undefined :: Proxy (3 + 4)
19:04:15 <lambdabot> error:
19:04:16 <lambdabot>     Not in scope: type constructor or class ‚Äò+‚Äô
19:04:26 <mniip> :t undefined :: Proxy (3 GHC.TypeLits.+ 4)
19:04:28 <lambdabot> Proxy 7
19:05:47 <riaqn> mniip: erisco: thanks for explaining.
19:06:00 <riaqn> I wish all the packages ported to idris overnight.
19:06:42 <erisco> Idris is not painless either. Partly because it is in development.
19:07:14 <mniip> oh yeah
19:07:20 <erisco> the other part being that if you are new to dependent typing, like myself, then the changes can be really awkward
19:07:37 <mniip> once again, in what package can I find a good definition of natural transformations
19:08:34 <erisco> like how (->) is not a type constructor, and f x = m is not the same as f = \x -> m
19:08:36 <riaqn> mniip: I think there is some category theory in Coq. should be easy ported to idirs.
19:08:45 <erisco> and f X = m is not the same as f x = case x of X -> m
19:08:49 <erisco> and things like this
19:08:54 <mniip> I meant a haskell package
19:10:38 <erisco> on one hand it is wonderful to be able to express such complex properties in types
19:10:54 <erisco> on another I really like where we are now
19:11:54 <erisco> or at least there are things I want to keep or improve rather than abandon
19:15:31 <riaqn> another question: fixed length bit vector with length info in type?
19:16:26 <erisco> well there is Vec which you can fill with Bool
19:17:19 <riaqn> cool!
19:18:39 <riaqn> erisco: ahh.. predefined Vec1 to Vec19?
19:19:47 <erisco> riaqn, no, and I think we're both looking at something I didn't expect
19:20:15 <erisco> there should be a Vec :: Nat -> * -> * somewhere... or maybe it is called something else
19:20:33 <erisco> if you're looking at Vec package, like I am, then that is something else actually
19:20:42 <erisco> that is effectively type lists
19:21:03 <erisco> and the Vec1 to Vec19 are not predefined... they're just convenient aliases
19:22:34 <erisco> hm, I don't know what package it is in
19:22:51 <riaqn> erisco: maybe you mistake some idris def as haskell packages..haha
19:23:02 <erisco> probably
19:23:38 <riaqn> anyway..I'm writing some digital circuit simulator.. so lots of info in type.
19:23:42 <erisco> that package might work for you but it is not the definition I had in mind
19:23:45 <riaqn> maybe I should just use Integer in all place.
19:24:39 <erisco> I was thinking  data Vec :: Nat -> * -> * where VZ :: Vec Z a; VS :: a -> Vec n a -> Vec (S n) a
19:25:08 <erisco> exactly lists but augmented with length
19:25:57 <riaqn> erisco: that's exactly how you do it in idris...
19:26:01 <riaqn> I don't know if it's possible in haskell..
19:26:47 <erisco> you can do this
19:27:06 <erisco> you need GADTs and DataKinds
19:28:22 <erisco> this is the classic example so it has to be defined somewhere
19:28:32 <riaqn> thanks.. I avoid ghc extensions as I can...except when I'm prompted to add a line or two..
19:28:41 <riaqn> nevermind, I will just use integer all where.
19:29:19 <erisco> avoid extensions? that's just like trying to hold your breath
19:33:36 <mniip> question
19:34:07 <mniip> I'm writing a function that accepts an arbitrary indexed type constructor, how can I let the user decide what argument of the constructor is the index?
19:34:27 <Welkin> mniip: alright dwight schrute
19:34:35 <LordBrain> mniip, use a view pattern
19:34:44 <turnage> I'm totally miss the Office reference here
19:34:54 <mniip> LordBrain, ?
19:35:02 <erisco> I don't use view patterns but I don't think they apply here
19:35:25 <erisco> you can define a type family, mniip, that projects the index
19:35:39 <LordBrain> mniip, maybe i misunderstand you...  but it sounds like you just want to do pattern matching without referring to the data constructor... 
19:35:49 <erisco> alternatively you can expect them to reorder their arguments appropriately with newtypes
19:35:49 <mniip> I never said data constructor
19:35:57 <mniip> type constructors is where it's at
19:36:10 <mniip> erisco, I'm somewhat encouraged by zipWith
19:36:12 <LordBrain> okay, well how do you mean user tho
19:36:21 <erisco> :t zipWith
19:36:23 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:36:24 <mniip> thinking I can define a function to inductively lift my function
19:36:42 <mniip> erisco, I mean, have you seen the zipWithN paper?
19:37:00 <Welkin> mniip: link?
19:37:01 <erisco> no
19:37:37 <LordBrain>  mniip would passing a lens as a parameter or something do what you want?  i am sorry if i dont get it.
19:37:44 <erisco> sounds like ZipList
19:37:49 <turnage> Welkin: oohhhh it's because they lead in with "question"
19:37:51 <turnage> gotcha
19:38:19 <LordBrain> mniip, am i right in assuming you want to avoid a type class?
19:38:31 <mniip> Daniel Fridlender and Mia Indrika (2000)
19:38:58 <mniip> https://www.cambridge.org/core/services/aop-cambridge-core/content/view/S0956796800003658
19:39:12 <erisco> a type family is a possible solution to the problem stated
19:39:27 <mniip> erisco, could you expand?
19:39:45 <glguy> mniip: Why does it need to be specific to being a type constructor? Perhaps you can have a type family that projects the "index" type from whatever type the user is choosing?
19:40:14 <erisco> glguy and I are saying the same thing
19:40:15 <mniip> uhhh
19:40:26 <mniip> not quire sure how that would work
19:40:32 <LordBrain> if you use a type family tho, they have to have instances declared of course
19:40:41 <erisco> mniip, what is the kind of your type constructors?
19:40:55 <glguy> mniip: Do you have an example of what you're trying to do without the flexibility you want in the indexes of your types?
19:41:02 <mniip> my function is 'forall (p :: Nat -> *)'
19:41:09 <Welkin> mniip: wtf? "Unfortunately you do not have access to this content, please use the Get access link below for information on how to access this content."
19:41:34 <Welkin> is there a non-paywalled version?
19:41:35 <erisco> I am not sure how that constitutes a function
19:41:49 <erisco> or you're saying that your type constructors have kind Nat -> * ?
19:41:59 <mniip> Welkin, https://scholar.google.com/scholar?hl=en&q=do+we+need+dependent+types
19:42:01 <mniip> does this help?
19:42:20 <mniip> erisco, glguy, induce :: KnownNat m => (forall n. KnownNat n => p n -> p (1 + n)) -> p 0 -> p m
19:42:38 <mniip> this, however, implies that the Nat is the last argument to the tycon
19:42:43 <glguy> (reminder: being a type constructor has nothing to do with kinds)
19:42:44 <mniip> which is not always the case
19:43:00 <LordBrain> mniip, they want $35
19:43:13 <LordBrain> including your second link
19:43:59 <erisco> mniip, is there a fixed arity for the constructors?
19:44:01 <MarcelineVQ> LordBrain: 2nd leads to https://pdfs.semanticscholar.org/7e66/7dd0515e4f674e42c0b0860644fee3dd5846.pdf
19:44:22 <mniip> sigh, Welkin LordBrain http://tcpst.net/pf6v.pdf
19:44:23 <LordBrain> alright that works
19:44:29 <glguy> mniip: OK, so you want something like:  induce :: KnownNat m => (forall n. KnownNat n => SetIx p n -> SetIx p (1 + n)) -> SetIx p 0 -> SetIx p m -- where SetIx is a type family that takes a some 'p' and sets it's "index" to the given Nat?
19:45:09 <glguy> (a proxy argument would be needed there to disambiguate p and m and n
19:45:27 <mniip> yeah that sounds like a lot of problems
19:45:46 <glguy> Problems are the name of the game when you start getting this clever!
19:45:52 <mniip> because SetIx needs to be injective
19:45:58 <mniip> and it isn't
19:46:07 <mniip> it is type C injective which is unsupported
19:46:22 <glguy> Why would it need to be injective?
19:46:37 <mniip> to disambiguate m,n?
19:46:46 <glguy> You just add proxy arguments
19:46:52 <mniip> yeaa
19:47:01 <erisco> there is this, and there is the other thing I said
19:47:08 <erisco> which is to just use newtypes
19:47:20 <mniip> yes
19:47:26 <mniip> newtypes is the default solution
19:47:36 <mniip> if I don't find a better one
19:52:33 <mniip> I think I did it
19:53:49 <athan> Hey all, has anyone been getting 443's when running `stack upgrade --git`? This is in a fresh install
19:54:21 <athan> so no dependencies exist, and it's failing when fetching base-compat from fpcomplete's s3 clone
19:55:16 <athan> here's a paste of the log http://lpaste.net/8814933119590203392
19:56:14 <erisco> mniip, why is my experience of that feeling usually followed by disappointment
19:56:24 <mniip> yeah no
19:56:27 <mniip> I did not do it
19:56:30 <LordBrain> lol
19:56:34 <mniip> only for the second parameter
19:56:43 <mniip> it did not magically expand for arbitrary n
20:26:44 <Lokathor> any gl experts about? I'm trying to convert this program https://learnopengl.com/code_viewer.php?code=getting-started/hellotriangle and my work so far is here: https://github.com/Lokathor/learnopengl/blob/master/app/Lesson02.hs
20:27:01 <Lokathor> it shows the colored window, but not the triangle.
20:28:11 <mniip> hm
20:28:26 <mniip> been a while since I've been writing out types (kinds) on paper haha
20:33:28 <mniip> FlipT :: (m -> *) -> l -> (k -> l -> m) -> k -> *
20:33:30 <mniip> exciting
20:34:26 <erisco> I kind of want a class where I know the zero
20:34:26 <iqubic> How GHC be written in Haskell. How would you compile it the first time?
20:34:46 <erisco> I guess that can just be Eq1 m, MonadPlus m
20:34:59 <Lokathor> iqubic, you compile the next version with the previous version
20:35:04 <erisco> but equality here is kinda meh
20:35:29 <erisco> it is too strong, certainly
20:35:48 <matthewbauer> iqubic: https://en.wikipedia.org/wiki/Self-hosting
20:36:44 <erisco> Maybe (a -> a)  it is easy to determine the zero
20:37:31 <erisco> all I get is z <> x = x and x <> z = x but this isn't telling me enough
20:37:57 <erisco> because I can't observe what it reduced to either
20:39:10 <iqubic> Lokathor: That's well and fine. Now, how was the very first version of GHC compiled?
20:39:18 <erisco> it'd be nice to have something more elegant than  class HasZero m where isZero :: m -> Bool
20:39:19 <davean> iqubic: with Hugs I think
20:39:37 <iqubic> How was Hugs compiled.
20:39:38 <iqubic> ?
20:39:47 <Lokathor> iqubic, the earliest Haskell code wasn't executed by a program written in Haskell
20:40:02 <iqubic> How was it executed then?
20:40:10 <Lokathor> Hugs was written in C (or whatever language), and it could interpret Haskell code
20:40:38 <davean> iqubic: this isn't really a Haskell question though. This is pretty general to any compiler
20:40:55 <davean> iqubic: the first compilers were hand-done in machine code (well, first assemblers really)
20:41:09 <iqubic> erisco: why not just write a class HasZero m where zero :: m
20:41:14 <davean> if you go far enough back its someone setting toggle switches on a computer
20:41:31 <erisco> because I want to determine if an object is the zero
20:41:47 <erisco> otherwise I'd just use empty/mempty/mzero
20:42:11 <iqubic> Oh, yeah. I think you either need a clever law or a isZero :: m -> Bool
20:43:15 <iqubic> Why can't use just add a constraint to the class or function you're using so you know that a zero will exist
20:43:26 <erisco> such as?
20:44:07 <iqubic> Such as Moniod m.
20:44:29 <erisco> knowing a zero exists is different than knowing if a particular object is the zero
20:44:39 <iqubic> Oh, right.
20:45:35 <iqubic> So I think you need a method like HasZero m :: m -> Bool
20:47:26 <iqubic> :t isZero (Monoid m, Equal m) :: m -> Bool; isZero m = m == empty
20:47:28 <lambdabot> error: parse error on input ‚Äò;‚Äô
20:47:41 <iqubic> Something like that I'd assume
20:47:49 <erisco> I think there has to be a better way to formulate it
20:47:52 <iqubic> :t isZero m = m == empty
20:47:53 <lambdabot> error:
20:47:54 <lambdabot>     parse error on input ‚Äò=‚Äô
20:47:54 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
20:48:05 <iqubic> :t m == empty
20:48:07 <lambdabot> error:
20:48:07 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚ÄòExpr‚Äô with actual type ‚Äòf0 a0‚Äô
20:48:07 <lambdabot>     ‚Ä¢ In the second argument of ‚Äò(==)‚Äô, namely ‚Äòempty‚Äô
20:48:16 <erisco> let me try and condense the pattern
20:48:22 <iqubic> :t (\m -> m == empty)
20:48:24 <lambdabot> (Alternative f, Eq (f a)) => f a -> Bool
20:48:44 <iqubic> That's not what I wanted. Why does it give that answer?
20:49:22 <iqubic> Actually, that makes perfect sense.
20:49:26 <iqubic> :t (\m -> m == mempty)
20:49:28 <lambdabot> (Monoid a, Eq a) => a -> Bool
20:49:34 <mniip> hahahaha
20:49:37 <mniip> unlimited power
20:49:43 <iqubic> That's also a way to write it.
20:50:27 <mniip> check this out
20:50:48 <iqubic> mniip: What do you want to show me?
20:50:48 <mniip> @define data A = A; data B = B; data C = C; data D = D; data E = E
20:50:50 <lambdabot>  Defined.
20:50:57 <mniip> @define data FlipC (b :: l) (f :: k -> l -> *) (a :: k) = FlipC (f a b)
20:50:59 <lambdabot>  Defined.
20:50:59 <erisco> Eq is too strong
20:51:04 <mniip> @define data FlipT (c :: m -> l -> *) (b :: l) (f :: k -> m) (a :: k) = FlipT (c (f a) b)
20:51:06 <lambdabot>  Defined.
20:51:15 <mniip> :t (A, B, C, D, E)
20:51:16 <lambdabot> (A, B, C, D, E)
20:51:20 <mniip> :t FlipC $ (A, B, C, D, E)
20:51:22 <lambdabot> FlipC E ((,,,,) A B C) D
20:51:26 <mniip> :t FlipT . FlipC $ (A, B, C, D, E)
20:51:28 <lambdabot> FlipT (FlipC E) D ((,,,,) A B) C
20:51:31 <mniip> :t FlipT . FlipT . FlipC $ (A, B, C, D, E)
20:51:33 <lambdabot> FlipT (FlipT (FlipC E) D) C ((,,,,) A) B
20:51:36 <mniip> :t FlipT . FlipT . FlipT . FlipC $ (A, B, C, D, E)
20:51:38 <lambdabot> FlipT (FlipT (FlipT (FlipC E) D) C) B (,,,,) A
20:51:59 <iqubic> mniip: What is the point of that?
20:52:12 <mniip> 1494210825 [05:33:45] <mniip> I'm writing a function that accepts an arbitrary indexed type constructor, how can I let the user decide what argument of the constructor is the index?
20:52:27 <iqubic> Oh. That's cool
20:52:37 <erisco> this is what I am working with, but it is wrong  f x = g x >>= mplus y . f
20:53:10 <mniip> hm
20:53:16 <mniip> FlipC = FlipT Identity
20:53:32 <erisco> actually no, it is this   f x = (g x >>= f) `mplus` y
20:53:42 <mniip> it's a flippin' transformer!
20:54:04 <iqubic> erisco: Why do you need to know if something happens to be the zero?
20:54:40 <erisco> because this is what it begins expanding to  f x = (g x >>= \x -> (g x >>= f) `mplus` y) `mplus` y
20:54:40 <iqubic> Also. x `mplus` empty = empty `mplus` x = x
20:55:01 <erisco> and this is not what I want
20:55:29 <iqubic> erisco: Why does it expand to that?
20:55:40 <erisco> that is just by substitution
20:55:53 <erisco> what I want is this   f x = if isZero (g x) then y else g x >>= f
20:56:12 <iqubic> So why not use eq?
20:56:14 <erisco> so it is quite simple in intuition
20:56:17 <erisco> because Eq is too strong
20:56:22 <erisco> I've answered many of these things already
20:56:25 <iqubic> How is it too strong?
20:56:29 <erisco> Maybe (a -> a)
20:56:58 <iqubic> Alright. And a can't be of type eq because...? Why not exactly?
20:57:09 <erisco> intuitively we are sequencing g, so g >=> g >=> g ... until we hit mzero
20:57:24 <erisco> after which we use y
20:57:38 <erisco> so it is tempting to use mplus here because we know mzero `mplus` y is y
20:58:00 <erisco> the problem is that if you write a definition like I did above then you get an `mplus` y at every item in the sequence, and that is wrong
20:58:07 <iqubic> I wish glguy or c_wraith were here to help.
20:58:21 <erisco> iqubic, you cannot define Eq on functions
20:59:13 <iqubic> erisco: That tells me why Eq is out of the picture.
21:01:31 <erisco> so I need an op <+> where  x <+> y = x  if  x /= zero   and  x <+> y = y  if  x == zero
21:02:06 <erisco> and it can be true on both sides, doesn't really matter
21:02:43 <erisco> that is as generic as I can think about it at the moment
21:03:27 <erisco> law 2 is given by monoid, but law 1 is not
21:04:06 <erisco> law 1 on both sides doesn't make sense actually
21:04:14 <erisco> that'd be a contradictory system :P
21:05:13 <erisco> so that's fine... I can define this extension to Monoid/Alternative/MonadPlus and go through all the instances and see what I can learn about it
21:05:22 <glguy> reminds me for logict's ifte
21:06:16 <glguy> http://hackage.haskell.org/package/logict-0.6.0.2/docs/Control-Monad-Logic-Class.html
21:07:06 <erisco> thanks glguy I will take a look
21:12:30 <lpaste> mniip pasted ‚ÄúFlipT‚Äù at http://lpaste.net/355313
21:12:32 <mniip> glguy, erisco ^ check out
21:14:56 <mniip> I don't think it's possible to generalize any further without either specializing the dependency 'induce' places on the indices or using dependent types
21:16:16 <mniip> this actually has good applicability
21:16:18 <mniip> consider e.g
21:16:24 <mniip> :t GHC.TypeLits.natVal
21:16:26 <lambdabot> GHC.TypeLits.KnownNat n => proxy n -> Integer
21:18:25 <mniip> :t GHC.TypeLits.natVal . FlipT . Apply
21:18:27 <lambdabot> forall l (n :: GHC.Types.Nat) (f :: GHC.Types.Nat -> l -> *) (b :: l). GHC.TypeLits.KnownNat n => f n b -> Integer
21:18:36 <mniip> :t GHC.TypeLits.natVal . FlipT . FlipT . Apply
21:18:37 <lambdabot> forall l l1 (n :: GHC.Types.Nat) (f :: GHC.Types.Nat -> l -> l1 -> *) (b :: l) (b1 :: l1). GHC.TypeLits.KnownNat n => f n b b1 -> Integer
21:18:42 <mniip> :t GHC.TypeLits.natVal . FlipT . FlipT . FlipT . Apply
21:18:44 <lambdabot> forall l l1 l2 (n :: GHC.Types.Nat) (f :: GHC.Types.Nat -> l -> l1 -> l2 -> *) (b :: l) (b1 :: l1) (b2 :: l2). GHC.TypeLits.KnownNat n => f n b b1 b2 -> Integer
21:18:46 <mniip> etc
21:19:56 <Lokathor> here's a fun little example for folks: http://lpaste.net/355314
21:20:12 <erisco> a pattern to bubble parameters
21:22:58 <erisco> that does look fun mniip. I'll have to study FlipT some later
21:46:30 <toblorone_> dumb question: I'm reading this article on automatic differentiation and I don't understand the (*) instance. They seem to be multiplying "a" with "Dif a" which shouldn't be possible... ?
21:46:30 <toblorone_> http://conal.net/blog/posts/beautiful-differentiation
21:46:50 <toblorone_> p@(D x x') * q@(D y y')  =  D (x * y) (x' * q + p * y')
21:46:58 <toblorone_> ooo
21:46:59 <toblorone_> nvm
21:47:05 <toblorone_> :^)
21:47:16 <geekosaur> rubber duck debugging, at your service >.>
21:47:43 <rotaerk> lol
21:53:32 <iqubic> Anyone here tried writting a Prolog parser in Haskell?
21:54:04 <toblorone_> i've wrote one years ago
21:55:43 <_sras_> How can I make a foldM call to execute operations using multiple threads?
21:55:44 <iqubic> Do you have the code?
21:56:02 <iqubic> toblorone_: Can I look at the prolog parser?
21:56:39 <sophiag> toblorone: i just saw your question about AD. i'm not sure if you're referring to how multiplication is overloaded for polynomials or that values need to be lifted up to the appropriate level of derivative
21:57:27 <toblorone_> I'm not sure I can dig up the code : ( sorry. Like i said, it was years ago :^). It should be pretty straight forward though. here's the bnf https://github.com/simonkrenger/ch.bfh.bti7064.w2013.PrologParser/blob/master/doc/prolog-bnf-grammar.txt
21:57:42 <sophiag> if it's the latter, Barak Pearlmutter has written a great deal about it. he refers to it as "perturbation confusion." edward kmett's AD package solves that problem
21:59:06 <glguy> mniip: Now you need to find a way to generate the various induceN definitions given a Nat parameter
21:59:20 <toblorone_> sophiag: ha nothing that complicated. For some reason when i was reading the code I didn't notice that x' in x' * q was also a (Dif a) value. I immediately realized my mistake when i pasted it the channel.
21:59:33 <mniip> glguy, no thanks
21:59:36 <glguy> aw :)
21:59:44 <mniip> I'm not planning to include induce* functions
21:59:54 <iqubic> What is BNF??
21:59:59 <mniip> just that given wrap/unwrap the user will be able to fit 'induce' to their own constructors
22:00:02 <mniip> iqubic, google it
22:00:44 <iqubic> So for BNF grammer, I think I can just make a whole bunch of Data types.
22:00:46 <mniip> glguy, besides, not sure if that's possible
22:00:57 <mniip> there's a higher rank type involved
22:01:08 <mniip> practically slipping into dependent types there
22:01:08 <iqubic> What's a higher-ranked type?
22:01:15 <mniip> iqubic, google it
22:01:57 <toblorone_> iqubic: Yeah, you can basically make a bunch of data types directly corresponding to each line of the BNF file and use something like parsec which more or less directly translates to bnf
22:02:37 <iqubic> I need ot learn how to use parsec.
22:02:41 <toblorone_> ah
22:02:42 <toblorone_> ok
22:02:45 <iqubic> s/ot/to
22:02:50 <toblorone_> well its well worth learning
22:03:01 <iqubic> Anyone know of a good parsec tutorial?
22:03:41 <toblorone_> this might work? https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
22:03:52 <mniip> that's attoparsec
22:03:55 <mniip> a slightly different library
22:03:58 <toblorone_> yeah
22:04:08 <iqubic> Should I learn both. Or just one?
22:04:30 <glguy> The first step is to learn any parser combinators library at all, there's a theme to them all
22:04:38 <ReinH> They're similar enough that you can learn both at the same time
22:04:38 <toblorone_> i usually (always?) have used attoparsec...
22:04:43 <glguy> after that you can learn the differences
22:05:01 <mniip> that much is correct
22:05:10 <mniip> does attoparsec have explicit backtrack too?
22:05:30 <ReinH> attoparsec always backtracks
22:05:35 <ReinH> i.e.., try is immplied
22:05:40 <ReinH> implied
22:06:52 <glguy> If the first operand of a <|> succeeds, it won't backtrack to the second branch, however, even if there's a failure in the future
22:06:57 <glguy> so it's not complete backtracking
22:06:58 <mniip> well then
22:07:04 <mniip> it's a significant difference
22:07:38 <ReinH> Just use try everywhere :p
22:07:54 <iqubic> What tutorial should I use?
22:08:03 <ReinH> glguy: I guess I expected "always" to be interpreted as "when useful" ;)
22:08:48 <glguy> Just distinguishing it from something like []
22:09:18 <ReinH> Any of these should be good https://www.google.com/search?q=haskell+parsec+tutorial
22:09:43 <ReinH> glguy: fair enough
22:10:01 <toblorone_> iqubic: if you have a good grasp on monads and applicative then it should be pretty quick to learn
22:10:02 <ReinH> I should have said that it automatically backtracks
22:10:44 <toblorone_> and if not its a good way to learn applicative style
22:11:34 <mniip> glguy, so it acts like Yoctoparsec Maybe then?
22:14:20 <glguy> Yeah, that appears to be the case
22:14:46 <iqubic> toblorone_: I know monads and applicatives quite well.
22:15:06 <toblorone_> great, so learning parsec should be a breeze then
22:15:43 <glguy> mniip: Is Yocto- the smallest modifier?
22:16:06 <mniip> yes I think
22:16:19 <mniip> do you think you can write something an order of magnitude smaller?
22:16:31 <glguy> That was nice of bos to leave room under Zepto
22:17:24 <glguy> smaller? Nothing comes to mind at the moment :)
22:18:06 <mniip> you'll have to fit in 0.5 lines
22:18:25 <glguy> so that's about 40 characters?
22:19:08 <mniip> if we're counting characters then 
22:19:27 <glguy> I'm wondering what we'd have to do to justify a kiloparsec
22:19:39 <mniip> you have about 99
22:19:42 <mniip> err
22:19:44 <mniip> you have about 19
22:21:19 <mniip> 'type P b t a=[t]->b a' is 21 chars
22:21:36 <mniip> and then the only combinators you get for "free" is composition
22:21:54 <mniip> a hardly useful composition at that
22:26:14 <ReinH> mniip: that's just about long enough to import Parsec ;)
22:27:59 <mniip> hahahhaha
22:40:46 <ReinH> you import free monads, which basically write your whole library for you, so
22:41:01 <ReinH> I may not know what free monads are
22:41:27 <Lokathor> Free Monads are magic runes that you scribe on your broom to make it into a flying broom
22:41:54 <glguy> Don't miss out of free applicatives
22:57:42 <kamyar> Hello all
22:58:14 <kamyar> I need some guide about Reader monad
22:58:52 <turnage> what's the q mate
23:00:00 <kamyar> I have a service application that I want to read configuration from a YAML file
23:00:17 <Guest84872> what magic incantation does one use to get haddock to produce this sort of output: http://hackage.haskell.org/package/th-abstraction-0.1.0.0/docs/src/Language.Haskell.TH.Datatype.html#DatatypeInfo
23:00:30 <kamyar> I want to read yaml file into a record just once and then use the variable to read config anywhere
23:00:43 <kamyar> I dont want to send the variable to any of my functions
23:01:05 <kamyar> instead I want a way for my modules to access config variable
23:01:20 <kamyar> Is Reader monad appropriate for this ?
23:01:43 <osa1> kamyar: yes
23:01:48 <c_wraith> Guest84872: add --hyperlink-source to the haddock command
23:02:15 <kamyar> So, Is the answer is yes, I am confused about reading YAML and integrating it with Reader monad
23:02:20 <Guest84872> c_wraith: I tried that. It doesn't get me that level of source annotation
23:02:25 <kamyar> I have read reader and YAML samples 
23:02:33 <kamyar> But I cant mix them up
23:03:11 <c_wraith> Guest84872: huh.  don't know then.  I haven't worried about that much in my own stuff.
23:03:12 <cocreature> Guest84872: --hyperlinked-source is the fancy output iirc
23:03:20 <osa1> kamyar: once you read the YAML into the format you like you do something like `runReaderT <your reader action> <your data parsed from YAML>`
23:03:26 <_sras_> How can I make a foldM to run in multiple threads?
23:03:30 <cocreature> the names of those options are terrible
23:03:33 <Guest84872> Just --hyperlinked-source gets me this sort of output: http://hackage.haskell.org/package/di-0.1/docs/src/Di.html#Di
23:03:49 <Guest84872> c_wraith: but the one I linked first is one level further up
23:03:54 <cocreature> Guest84872: which version of haddock do you have?
23:04:12 <kamyar> osa1: 1) Where should I put this line? In which function with what signature?
23:04:13 <Guest84872> c_wraith: with the source itself hyperlinked (not just coloured)
23:04:23 <kamyar> osa1: 2) What is my reader action?
23:05:27 <cocreature> Guest84872: also --hyperlinked-source as a flag that needs to be passed to "haddock" itself not to "cabal haddock". you can pass --haddock-options=--hyperlinked-source to cabal
23:06:04 <Guest84872> cocreature: I ran it precisely like this: cabal haddock --haddock-option=--hyperlinked-source
23:06:27 <Guest84872> cocreature: still didn't get the fancy output!
23:06:54 <cocreature> Guest84872: which version of haddock are you using?
23:06:59 <cocreature> that‚Äôs a relatively new feature
23:07:01 <Lokathor> _sras_, http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
23:07:15 <cocreature> also there might be a difference between --haddock-option and --haddock-options so try the latter one as well
23:07:17 <glguy> Guest84872: Neat, you found my package :)
23:07:26 <osa1> kamyar: http://lpaste.net/355320
23:07:51 <glguy> Guest84872: This is my documentation upload process: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
23:08:31 <cocreature> _sras_: fold is inherently sequential so I‚Äôm not sure what you expect to parallelize here
23:08:35 <kamyar> osa1: Great thanx!
23:11:44 <mniip> cocreature, o/
23:11:49 <_sras_> cocreature: Oh. yes. 
23:12:01 <Guest84872> glguy: excellent script. thanks!
23:12:04 <cocreature> mniip: \o
23:12:30 <_sras_> cocreature: What about mapM_?
23:12:49 <Lokathor> _sras_, you can make mapM run in parallel easily, that link i gave will explain it all from bottom to top
23:13:04 <cocreature> _sras_: https://hackage.haskell.org/package/async-2.1.1.1/docs/Control-Concurrent-Async.html#v:mapConcurrently_
23:14:36 <kamyar> osa1: Is f what I should call from other modules to read config?
23:15:02 <osa1> kamyar: no f is the function that can read config using `MonadReader` methods (`ask`)
23:15:02 <dmj`> cocreature++, and forConcurrently_
23:15:15 <osa1> kamyar: you can call other functions with the same `MonadReader` constraint from that function
23:15:23 <kamyar> osa1: Cant understand ! What should I do in it?
23:16:23 <kamyar> osa1: You mean m?
23:16:57 <kamyar> You mean MOnadReader helps other functions e able to read data from config variable (YAMLDAta)
23:17:16 <kamyar> osa1: You mean MOnadReader helps other functions e able to read data from config variable (YAMLDAta)
23:17:42 <kamyar> osa1: I dont want to change all functions signature!
23:17:53 <glguy> On the topic of configuration files I've been working on this package this weekend: http://hackage.haskell.org/package/config-schema
23:18:07 <Lokathor> kamyar, you've gotta have a MonadReader constraint on a function for it to benefit from Reader stuff
23:18:30 <Lokathor> kamyar, otherwise you have to pass in the argument manually
23:18:46 <kamyar> Lokathor: Oh ok! But anyway I have to change my whole code! Is there a better way?
23:19:23 <Lokathor> kamyar, sorry, but not really. part of Functional Programming means that functions are only working with the arguments you pass them
23:19:43 <Lokathor> the MonadReader stuff just hides away some of what's going on, but it's passing around the "reader" value in the background
23:20:13 <kamyar> Lokathor: Yes u r right! Otherwise we are denying referential transparency
23:22:29 <kamyar> osa1: So what should I write instead of undefined in f?
23:23:00 <mniip> glguy, erisco I just realized there's more
23:24:11 <mniip> :t natVal . FlipT . Apply
23:24:12 <lambdabot> forall l (n :: Nat) (f :: Nat -> l -> GHC.Types.*) (b :: l). KnownNat n => f n b -> Integer
23:24:17 <mniip> :t natVal . Compose . FlipT . Apply
23:24:18 <lambdabot> forall k1 l (n :: Nat) (g :: Nat -> k1) (f :: k1 -> l -> GHC.Types.*) (b :: l). KnownNat n => f (g n) b -> Integer
23:24:30 <mniip> :t natVal . FlipT . Apply . Compose . FlipT . Apply
23:24:32 <lambdabot> error:
23:24:32 <lambdabot>     ‚Ä¢ Couldn't match kind ‚Äòl -> k1‚Äô with ‚ÄòNat‚Äô
23:24:32 <lambdabot>       When matching the kind of ‚ÄòFlipT
23:24:36 <mniip> oop
23:24:48 <mniip> ah I guess you can't do that
23:25:16 <mniip> ah you don't need Apply and it has the wrong kind
23:25:22 <mniip> :t natVal . FlipT . Compose . FlipT . Apply
23:25:23 <lambdabot> forall l k1 l1 (n :: Nat) (f :: Nat -> l -> k1) (b :: l) (f1 :: k1 -> l1 -> GHC.Types.*) (b1 :: l1). KnownNat n => f1 (f n b) b1 -> Integer
23:26:29 <glguy> No arguments are safe from your reach!
23:26:34 <kamyar> PLease help I am confused
23:26:36 <mniip> well some are safe
23:27:30 <mniip> I don't immediately see a way to feed 'Maybe Int' into a function accepting 'forall (p :: (* -> *) -> *). p m'
23:27:56 <mniip> i.e how to turn Maybe Int into '_ Maybe'
23:28:36 <Lokathor> kamyar, http://lpaste.net/355321 here's an example of how you might do it
23:28:44 <Lokathor> normally, MonadReader isn't too helpful
23:29:05 <Lokathor> you might use something like, doThing :: (MonadReader m, MonadIO m) => m ()
23:29:19 <Lokathor> then your doThing action can use the reader context, and also perform IO actions
23:29:55 <mniip> glguy, ha
23:29:59 <mniip> I take that back
23:30:04 <mniip> FlipT . Apply . Apply
23:30:10 <mniip> a b -> FlipT Apply b Apply a
23:31:46 <kamyar> Lokathor: So again I am sending the config to needing function!
23:31:55 <kamyar> Lokathor: What is reader monad doing>
23:32:11 <kamyar> Lokathor: How it helps?
23:32:26 <glguy> The Reader type is just a function. There's no magic
23:32:35 <Lokathor> If you stick a MonadReader constraint on your operations, you can forget about who needs the context specificly and who does not. it'll always be in the background when you do need it
23:33:05 <Lokathor> it only really helps if you have deep layers of calls and returns, and not all the layers use the context
23:33:26 <Lokathor> if you're not fully comfortable with it, i'd just pass whatever variable around explicitly
23:33:57 <kamyar> Lokathor: Thanks! Yes passing variable may be enough but I wanted to use this opportunity to understand Reader monad!
23:34:24 <Sh4rPEYE> Hello. How one implement this for "an arbitrary number of generations"? 
23:34:24 <Sh4rPEYE> https://en.wikibooks.org/wiki/Haskell/Understanding_monads/List#Bunny_invasion
23:34:26 <Lokathor> sadly it's not too useful on its own
23:34:39 <Sh4rPEYE> It's a simple monad exercise, but I cannot deal with it
23:36:40 <Sh4rPEYE> They want me to use some of the Monad function, and that's the problem I have with it...
23:37:13 <cocreature> Sh4rPEYE: so you‚Äôre having trouble with implementing "themselvesTimes"?
23:38:23 <Sh4rPEYE> cocreature: No, the bunny invasion. For an arbitrary number of generations. The link I posted is info about bunnies, the exercise itself is defined here:
23:38:32 <Sh4rPEYE> https://en.wikibooks.org/wiki/Haskell/Understanding_monads/IO#Monadic_control_structures
23:39:30 <cocreature> Sh4rPEYE: I think I don‚Äôt really understand the exercise. are you just supposed to take the number of generations as a parameter instead of leaving it at 3?
23:41:28 <Sh4rPEYE> cocreature: I think the "reproduction rate" stays at 3. The number of generations is rather the number of bunnies after certain time... Say, gen 1 you have 1 Bunny, gen 2 you have three, gen 3 you have 9 (because each of those three had 3 kits), gen 4 you have 27 etc
23:42:15 <Sh4rPEYE> It'd look like this: bunnyGen' n = print $ concat $ replicate n $ ["bunny"] >>= generation
23:42:25 <cocreature> ah ok
23:42:32 <Sh4rPEYE> where generation = replicate 3
23:43:06 <Sh4rPEYE> But I can't figure out what standard functions (forM/replicateM...) am I supposed to use here
23:44:45 <yourname1> script load trackbar22
23:45:38 <cocreature> Sh4rPEYE: I think you‚Äôre just supposed to use recursion here tbh
23:46:13 <Sh4rPEYE> as in go n and then call go (n - 1) etc? Maybe, yes
23:46:20 <cocreature> yep
23:46:35 <Sh4rPEYE> Doesn't make too much sense in IO chapter though
23:52:02 <cocreature> Sh4rPEYE: try writing a function of type "iterateN :: Monad m => Int -> (a -> m a) -> m a -> m a". you should then be able to use that to solve your problem
23:52:48 <Lokathor> http://stackoverflow.com/a/43840223/455232 someone figured it out :3
