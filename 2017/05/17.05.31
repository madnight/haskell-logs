00:08:13 <osa1> I'm wondering why containers isn't using `Foldable t => t a -> ...` in fromList functions instead of `[a]`
00:08:42 <Lokathor> pacak, the reason for all the nested tuples is that it makes the Storable instance something I can just plan derive (with the storable-tuples package, and GeneralizedNewtypeDeriving)
00:08:48 <quchen> Because fromList literally says that it takes a list, osa1?
00:09:36 <EvanR> what would the foldable version do, union singleton maps together with mappend?
00:10:00 <osa1> quchen: right, but Data.List functions do this so I was thinking maybe this is reasonable these days
00:10:03 <Lokathor> fromFoldable = fromList . toList
00:10:30 <EvanR> that would have the same issues as the Snoc list from earlier
00:10:32 <osa1> fromFoldable would be good addition I think
00:10:43 <quchen> osa1: Data.List does this because of an awkward way that was chosen when putting Foldable into Prelude
00:10:59 <quchen> osa1: It’s not deliberate design, but rather a necessary accident
00:12:43 <EvanR> cant remember... what is the conventional name for data Two a = Two a a
00:12:57 <cocreature> EvanR: V2?
00:13:59 <EvanR> data V2 a = V2 !a !a ?
00:14:19 <cocreature> I think I’ve also seen lazy versions if you really need that
00:22:01 <glguy> quchen: when you release a package with a single digit version, you stop people from being able to depend on a major version of it like this: 1.0.*
00:22:51 <glguy> that one's not a big deal, just something to keep in mind
00:24:32 <glguy> unfortunately 1 < 1.0
00:25:32 <quchen> Urgh, okay
00:26:36 <EvanR> 1 is a valid version number?
00:26:44 <quchen> Sure
00:27:00 <EvanR> for cabalized packages?
00:27:19 <quchen> https://hackage.haskell.org/package/prettyprinter EvanR 
00:27:37 * quchen is guilty and pleads incompetence
00:27:40 <cocreature> iirc cabal just uses a list of Ints internally
00:27:46 <cocreature> for version numbers
00:27:47 <EvanR> it must be the loneliest version number that you ever knew
00:28:55 <quchen> glguy: I guess there’s no way to make Hackage hide the dependencies that are only added for old compilers, like semigroups in my case?
00:29:07 <quchen> It’s only used if building with ghc-ooold
00:29:12 <glguy> doesn't seem to be
00:31:07 <merijn> quchen: Don't think so, no
00:31:08 * hackage weather-api 0.4.3.2 - Weather API implemented in Haskell  https://hackage.haskell.org/package/weather-api-0.4.3.2 (PeterGoncharov)
00:31:49 <merijn> quchen: Oh...
00:31:53 <merijn> Actually, it already does
00:32:02 <merijn> quchen: Just click [details] after dependencies
00:33:01 <quchen> Hmmm okay. It’s there but nobody clicks it when just looking at »how many deps does this have«.
00:33:13 <quchen> I was hoping for a bit of a minimal dependency footprint.
00:33:21 <quchen> i.e. base and text
00:34:37 <glguy> maybe mention it explicitly near the top of the read me
00:40:03 <BernhardPosselt> hi im a bit confused regarding the fucntor instance for functions
00:40:27 <BernhardPosselt> fmap (a -> b) (b -> c)  = (a -> c)?
00:41:07 <EvanR> fmap :: (b -> c) -> (a -> b) -> (a -> c)
00:41:18 <duckqlz> is there a way to do an equivalent to `type NumList = [Num]`
00:41:36 <EvanR> you can see it modifies the result of the function
00:41:38 <cocreature> fmap :: (a -> b) -> f a -> f b, now replace f by (c ->) and you have fmap :: (a -> b) -> (c -> a) -> (c -> b)
00:41:52 <vaibhavsagar> duckqlz: what's wrong with `type NumList = [Num]`?
00:42:03 <EvanR> fmap tends to modify the "result" of the type, whatever that means for that type
00:42:08 <quchen> glguy: Can’t change the buildable flag in a revision, unfortunately.
00:42:28 <glguy> there's always next release
00:42:30 <BernhardPosselt> EvanR: i see, ty
00:42:43 <cocreature> duckqlz: can you explain what you are actually trying to do? Num is a typeclass so [Num] doesn’t really make sense
00:42:44 <EvanR> turns out its just
00:42:46 <EvanR> :t (.)
00:42:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:43:32 <BernhardPosselt> yep, (.) is always confusing me a bit
00:43:33 <duckqlz> vaibhavsagar: "Expecting one more argument to Num"
00:43:54 <BernhardPosselt> because order of execution :D
00:43:55 <duckqlz> I want to have a type synonym for a list of numbers which are floating or Int
00:44:08 <glguy> duckqlz: what were you hoping for that to mean?
00:45:05 <duckqlz> so I can do type NumList = [Int] or type NumList = [Float] but how can I make a generic type synonym for a list of numbers which can be floating or integral?
00:45:31 <EvanR> type NumList = [Either Int Float]
00:45:40 <duckqlz> ahh
00:45:42 <EvanR> oh...
00:45:43 <merijn> duckqlz: Items in a list must all be the same type
00:45:52 <EvanR> Floating, Integral, the classes? 
00:45:58 <merijn> duckqlz: You can't have list containing values of different types
00:46:03 <duckqlz> merijn: I want them to all be the same type
00:46:20 <peddie> type NumList = Either [Int] [Float] perhaps
00:46:29 <glguy> duckqlz: this just isn't really what type synonyms are for, then
00:46:30 <merijn> duckqlz: right, so you want a list that contains numbers that all have the same type, but can be either Int or Float?
00:46:41 <glguy> the constraints go on the operations
00:46:43 <duckqlz> merijn: yes
00:46:45 <merijn> duckqlz: That'd just be "myList :: Num a => [a]"
00:46:52 <glguy> and so all you have left is the list part
00:46:55 <merijn> :t [1,2,3,4]
00:46:56 <lambdabot> Num t => [t]
00:47:03 <merijn> :t [1,2,3,4] :: [Float]
00:47:04 <lambdabot> [Float]
00:47:07 <merijn> :t [1,2,3,4] :: [Int]
00:47:08 <lambdabot> [Int]
00:48:40 <nshepperd_> duckqlz: write your functions to work with lists of any type, with constraints added for whatever numerical operations you need
00:49:43 <tsahyt> I'm having some trouble getting the right short circuiting behavior for a fold. The fold can abort once the accumulator reaches a certain threshold. this requires me to inspect the accumulator, hence not short circuiting with foldr (unless I misunderstand). but foldl first needs to walk the entire list, right?
00:49:44 <duckqlz> hmm ok I was just hoping to name a special list of numbers to clarify my code... similar to how String is a list of characters but I will just abandon this idea if it doesn't conform to the haskell style
00:49:56 <halogenandtoast> Is there a way to start ghci with classy prelude?
00:50:28 <quchen> halogenandtoast: Write a ghci.conf 
00:50:53 <quchen> tsahyt: Right fold (on lists) does not have an accumulator.
00:50:53 <halogenandtoast> quchen: can I not just do it with command line flags?
00:51:08 <glguy> tsahyt: only foldr can stop early
00:51:08 * hackage hreader-lens 0.1.3.0 - Optics for hreader package  https://hackage.haskell.org/package/hreader-lens-0.1.3.0 (dredozubov)
00:51:09 <quchen> halogenandtoast: mmmh, maybe, but I don’t know
00:51:15 <halogenandtoast> ghci -XNoImplicitPrelude seems to start it without prelude
00:51:45 <tsahyt> what do you call z then? from the docs, foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...). so when I need to inspect the second argument to f, doesn't that force the whole evaluation?
00:51:51 <glguy> duckqlz: String is a synonym for a specific type, no constraints
00:53:21 <glguy> tsahyt: it forces a single step of the evaluation. you'll need to be more creative in what your foldr computes so that the whole list isn't needed
00:53:22 <tsahyt> in my case, f x z = if z > threshold then z else max (foo x) z
00:53:49 <tsahyt> I'm not sure how I'd express that such that I don't need evaluate it all the way down
00:54:56 <halogenandtoast> what's the most beloved prelude alternative currently?
00:55:12 <glguy> :t foldr (\x next acc -> if acc > 10 then acc else next (max acc x)) id
00:55:14 <lambdabot> (Num t, Ord t, Foldable t1) => t1 t -> t -> t
00:56:18 <glguy> halogenandtoast: better to just learn Prelude
00:56:37 <merijn> halogenandtoast: What's so bad about Prelude?
00:56:45 <tsahyt> glguy: what
00:56:51 <tsahyt> what's that next function here?
00:57:03 <cocreature> halogenandtoast: protolude is quite popular and personally I like it a lot
00:57:30 <glguy> > foldr (\x next acc -> if acc > 10 then acc else next (max acc x)) id [1..]
00:57:32 <lambdabot>  <Integer -> Integer>
00:57:37 <glguy> > foldr (\x next acc -> if acc > 10 then acc else next (max acc x)) id [1..] 0
00:57:39 <lambdabot>  11
00:58:23 <glguy> tsahyt: I used foldr to build up a function
00:58:32 <tsahyt> so this builds up a function that evaluates exactly as much as needed?
00:58:55 <glguy> yeah
00:59:03 <halogenandtoast> glguy: I don't like that Prelude has unsafe functions
00:59:18 <halogenandtoast> merijn: ^^
00:59:24 <glguy> you mean partial ones?
00:59:27 <halogenandtoast> Yes
01:00:12 <merijn> Simplest solution is to "not use them", because sometimes you need them
01:00:14 <tsahyt> glguy: my original z is then the argument to that function I suppose?
01:00:21 <halogenandtoast> merijn: I can't trust other people
01:00:48 <merijn> halogenandtoast: Can't do things like "map head . groupBy myPredicate" without them
01:01:03 <merijn> halogenandtoast: Sounds like an issue better tackled by a psychologist ;)
01:01:39 <kuribas> or tail . scanl kons nil
01:01:41 <johnw> I wouldn't mind a -Wall warning for every place I use a partial function
01:01:42 <glguy> is psychologist yet another alternative prelude?
01:01:49 <halogenandtoast> merijn: Well I have a company of non-haskell programmers
01:01:57 <halogenandtoast> or nil-lovers as I like to call them.
01:02:00 <johnw> requiring me to use a pragma at the call site to silence the warning, advertising that "yes, I know"
01:02:13 <merijn> johnw: That'd be okay
01:02:28 <tsahyt> johnw: that just leaves the problem of actually detecting partial functions
01:02:36 <glguy> making people who already aren't familiar with Haskell use a more complicated or less known library sounds like a bad plan
01:02:43 <merijn> johnw: I'm actually toying with the idea of an "ADOPT" pragma to selectively silence orphan warnings (rather than -Wno-orphans silencing all of them)
01:02:46 <johnw> and if GHC could analyze when compositions make some partial functions total, and then not warn, would be even better
01:03:04 <johnw> like head . (x:) . ...
01:03:34 <johnw> tsahyt: presumably we'd add a PARTIAL flag, to be used throughout the Prelude, rather than abandoning those functions
01:03:49 <johnw> merijn: ooh, I'd like that (ADOPT)
01:04:22 <merijn> johnw: It'll have to wait a good long while, though
01:04:41 <btk> Tyż
01:04:41 <merijn> johnw: I first need to fix other stuff and work and add more stuff to criterion before I get to that
01:06:13 <merijn> johnw: Also, I need help populating this list to kickstart it (I guess adding an ADOPT pragma might a bit to hard, since it requires toying with the GHC parser): https://wiki.haskell.org/Yak_shaving
01:08:26 <ph88> shapr, no but i'm not into blockchain :/
01:14:56 <johnw> merijn: will there be a shepherd to manage this list?
01:14:59 <ph88^> hi guys, anyone know how i can get conduitDecode to work?  https://bpaste.net/show/16a5c91072a6
01:15:07 <johnw> otherwise, I see it getting out of date quickly
01:15:18 <ph88^> hi johnw 
01:15:20 <johnw> text-based issue tracker, etc
01:15:23 <johnw> hi ph88^ 
01:15:46 <johnw> and good night, I'm heading to bed now
01:16:00 <johnw> finally completed a proof that wiped the entirety of yesterday, so now is time for the sleep of the just
01:16:01 <halogenandtoast> glguy: fair enough, I guess that is what code review is for.
01:16:35 <merijn> johnw: For now I'm sorta keeping track, but I figured "there's lots of time I don't have time to do something" and "there's lots of times people ask 'what should I do as first Haskell project'?", I figure, why not fix two issues in one go :)
01:16:47 <merijn> johnw: Especially if someone can give them pointers how to get started
01:48:08 * hackage tar-conduit 0.1.1 - Parse tar files using conduit for streaming  https://hackage.haskell.org/package/tar-conduit-0.1.1 (SimonMarechal)
01:57:13 <LAZAR> umm guys does anyone have a clue how to parse json objects with arbitrary fields? im really stuck on this one using aeson
01:57:38 <tfc[m]> LAZAR: what do you mean by arbitrary fields?
01:57:48 <BernhardPosselt> can you map over a functor of functor
01:58:00 <BernhardPosselt> List (Maybe Int)
01:58:08 <merijn> BernhardPosselt: Sure, just fmap more
01:58:15 <BernhardPosselt> is there a generic solution?
01:58:18 <merijn> :t fmap . fmap
01:58:19 <liste> :t fmap.fmap
01:58:19 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
01:58:20 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
01:58:32 <BernhardPosselt> to map over abitrarily nested functors?
01:58:35 <merijn> BernhardPosselt: There's the Compose newtype, but not sure if that's "generic"
01:58:52 <BernhardPosselt> e.g. List (Future (Maybe Int))
01:59:01 <BernhardPosselt> like add 2 to all ints
01:59:14 <LAZAR> tfc[m]: like object {"a": 1, "b": 2} where a and b are not known and there could be more or less fields in object
01:59:58 <tfc[m]> LAZAR: if there are more fields, you can just ignore them. if there are less fields, then the data contained in the json object might not be sufficient for you needs and you need to error out anyway, right?
02:01:07 <LAZAR> tfc[m]: well i want all of the data inside that object and i dont even have specific fields to look for
02:01:11 <BernhardPosselt> > fmap (+2) [Some 1, Some 2, Nothing]
02:01:13 <lambdabot>  error:
02:01:13 <lambdabot>      • Data constructor not in scope: Some :: Integer -> Maybe a
02:01:13 <lambdabot>      • Perhaps you meant variable ‘some’ (imported from Control.Applicative)e...
02:01:40 <BernhardPosselt> > fmap.fmap (+2) [Some 1, Some 2, Nothing]
02:01:49 <inr> > runMaybeT . fmap (+7) . MaybeT $ [Just 1, Nothing, Just 3]
02:02:22 <BernhardPosselt> why do you need a monad transformer?
02:03:05 <lambdabot>  error:
02:03:05 <lambdabot>      Variable not in scope: runMaybeT :: f0 Integer -> cerror:
02:03:05 <lambdabot>      • Data constructor not in scope:
02:03:05 <lambdabot>  error:
02:03:05 <lambdabot>      • Couldn't match expected type ‘a1 -> a -> b’
02:03:07 <lambdabot>                    with actual type ‘[Maybe a0]’
02:03:23 <tfc[m]> LAZAR: ok, looks like you can't deserialize your data into fixed structures then. `decode "{\"foo\": 123}" :: Maybe Value` will give you an object that you can traverse dynamically at runtime.
02:04:25 <tfc[m]> LAZAR: traversing such an object is clunky, but possible. you can access the items via common map functions etc. but you will need to study the aeson documentation alot until you get working code.
02:05:54 <inr> BernhardPosselt: you can do fmap (fmap (+7)) [Just 1, Nothing, Just 3] if you prefer, then you have to count your fmap:s instead
02:08:05 <BernhardPosselt> inr: right, but i need to know the nesting level right?
02:08:35 <BernhardPosselt> cant i define fmap for Functor (Functor a)) and let it all work out recursively?
02:11:44 <RexSumEgo> hello
02:14:50 <halogenandtoast> hello
02:19:16 <Saizan> BernhardPosselt: you can't define an instance "Functor f, Functor g => Functor (f . g)" that would just work, because the "." would need to be a newtype
02:21:04 <BernhardPosselt> i see :)
02:25:47 <BernhardPosselt> > fmap (+) (Just 1)
02:25:49 <lambdabot>  Just <Integer -> Integer>
02:26:19 <BernhardPosselt> > fmap (+) (Just 1) <*> (Just 4)
02:26:21 <lambdabot>  Just 5
02:26:35 <BernhardPosselt> unfortunately fmap (+) (Just 1) cant be printed on ghci
02:26:53 <BernhardPosselt> is there a nice way to show what happens?
02:26:53 <halogenandtoast> you can to :t in ghci
02:27:02 <halogenandtoast> s/to/do/
02:28:25 <halogenandtoast> fmap (+) Just 1 :: (Num (Maybe t), Num t) => Maybe t -> Maybe t
02:28:34 <halogenandtoast> is at least some information
02:28:51 <BernhardPosselt> ty
02:29:28 <halogenandtoast> BernhardPosselt: sorry I typed that wrong
02:29:30 <halogenandtoast> fmap (+) (Just 1) :: Num a => Maybe (a -> a)
02:29:43 <halogenandtoast> which is mich better
02:29:47 <halogenandtoast> s/mich/much/
02:29:49 <halogenandtoast> can't type today
02:36:39 <halogenandtoast> Anyone ever setup a Yesod site from scratch? I'm trying to get lucius to work. It shows the hamlet file currently but without the lucius stylesheet
02:37:16 <halogenandtoast> I can post my repo online.
02:38:02 <halogenandtoast> My current attempt: https://github.com/halogenandtoast/squawkr
02:59:34 <matrium> hi, how can I map over the elements of a NonNull? I have a NonNull list of sets and want to map over the elements of the sets: "omap (\(a :: Set Node) -> (S.map Ontology a :: Set Ontology)) (x :: NonNull [Set Node])"
03:00:12 <matrium> "Couldn't match type ‘Ontology’ with ‘Node’   Expected type: Element (NonNull [Set Node])     Actual type: Set Ontology"
03:01:29 <ph88^> hi guys, anyone know how i can get conduitDecode to work?  https://bpaste.net/show/16a5c91072a6
03:06:21 <LAZAR> How can i do nested object deconstruction in functions like toJSON (Dependencies (Map name dependency)) ?
03:12:06 <stobix> If I have, e.g., a data Foo = Foo {someVal::String,otherVal::String}, and have created a foo = Foo "foo" "bar", is there some syntax similar to foo {someVal="baz"} that will give me a Foo "baz" "bar"?
03:12:45 <stobix> That is, can I set individual fields in a type in a way that isn't horrendously verbose?
03:13:54 <Xion_> foo { someval = "baz" } -- it's exactly that
03:15:36 <stobix> ... huh.
03:15:43 * stobix checks his code for spelling errors
03:17:13 <Xion_> I'm assuming you're aware but just to remind, this evaluates a new Foo with the fields changed
03:18:13 <stobix> Yeah. The alternative would've been to explicitly build a new Foo, with all arguments but one respecified needlessly.
03:18:29 <stobix> Turns out that haskell wants to have a matching ) for each (. Who would've thought.
03:19:38 * hackage weather-api 0.4.3.3 - Weather API implemented in Haskell  https://hackage.haskell.org/package/weather-api-0.4.3.3 (PeterGoncharov)
03:19:41 <Xion_> hah :)
03:20:06 <Xion_> I still don't get the indentation rules in Haskell. They seem much more fussy than in Python
03:22:27 <stobix> At least we seldom get the "missing ;" error
03:23:34 <stobix> It's kinda the Haskell counterpart to Java's NullPointerException: "But the code shouldn't even have those!"
03:41:32 <merijn> Xion_: They're rather simple, but they're not what people naively excpect
03:41:47 <merijn> Xion_: https://en.wikibooks.org/wiki/Haskell/Indentation
03:41:55 <merijn> Read that and be confused no longer
03:42:21 <merijn> stobix: Time to use rainbow parenthesis and avoid similar problems in the future ;)
03:44:27 <Xion_> merijn: o.0
03:44:43 <Xion_> merijn: The first example is literally contravening the so-called "golden rule" stated there
03:45:31 <merijn> Xion_: No
03:45:47 <merijn> Or rather, yes
03:46:05 <merijn> "x = a" is part of the let expression and is indented further than let
03:46:30 <Xion_> But `let` isn't a part of let expression?
03:46:37 <Xion_> Because that's what the 2 "wrong" examples suggest
03:47:20 <merijn> Xion_: That's for a different reason (which is that let is one of 4 layout introducing words)
03:47:43 <merijn> It's a bit odd that they put the golden rule and let so close to each other there
03:48:29 <Xion_> Well, they say let is an *example* of the golden rule. The easiest one, at that.
03:49:00 <merijn> Xion_: I recommend reading the entire thing first THEN thinking about things
03:49:39 <mutsig_> If I were to write a NFData instance for list manually, is this correct: "rnf [] = (); rnf (x:xs) = rnf x `deepseq`rnf xs"?
03:50:38 <opqdonut> mutsig_: I think `seq` is enough
03:50:44 <opqdonut> since rnf returns ()
03:51:12 <opqdonut> yes, that's how it's written: https://hackage.haskell.org/package/deepseq-1.4.2.0/docs/src/Control.DeepSeq.html#line-353
03:52:43 <mutsig_> opqdonut: Ah, thanks. Is `seq` enough for other datatypes with multiple fields in their constructor as well?
03:54:25 <opqdonut> mutsig_: no, seq evaluates to weak head normal form, i.e. just the constructor
03:54:28 <BernhardPosselt> does an applicative functor interface imply a functor?
03:54:41 <opqdonut> BernhardPosselt: yes
03:55:01 <opqdonut> @src Applicative
03:55:01 <lambdabot> class Functor f => Applicative f where
03:55:01 <lambdabot>     pure  :: a -> f a
03:55:01 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
03:55:08 <BernhardPosselt> aah :D
03:55:13 <BernhardPosselt> ty
03:55:28 <mutsig_> opqdonut: Ok, thanks again
03:56:15 <barrucadu> mutsig_: I find the most obvious way to write NFData instances for types with multiple fields is like this: `rnf (Foo a b c) = rnf (a, b, c)`
03:56:42 <barrucadu> Don't need to worry about `seq`ing things, just re-use the `NFData` instance for tuples
03:56:44 <Xion_> BernhardPosselt: The <$> you often see in applicative chains of <$> and <*> is just fmap from Functor
03:58:18 <felixphew> Ok, so after several unsuccessful attempts involving Alex/Happy and Parsec, I’m taking a step back.
03:58:21 <felixphew> What I want to do is turn this: http://lpaste.net/1911631866901823488
03:58:27 <felixphew> into this: http://lpaste.net/1364060168437891072
03:58:32 <felixphew> (and ultimately into this: http://pokepast.es/593da90af2229416)
03:58:39 <felixphew> I’m relatively new to Haskell, and so what I’m really after is general information about how I should go about solving this problem.
03:58:49 <felixphew> (For the record, this is my attempt at a rewrite of a site I wrote in Python:  https://github.com/felixphew/pokepaste)
04:00:04 <mutsig_> barrucadu: Oh, nice! Good note
04:00:13 <ertes-w> felixphew: if you make a few minor adjustments to the original one, it becomes valid YAML
04:00:21 <ertes-w> felixphew: then you can just use the 'yaml' library
04:00:31 <felixphew> unfortunately, the syntax is out of my hands
04:00:38 <felixphew> it's been around for years
04:01:04 <mpickering> felixphew: What problems were you having with Alex and happy?
04:01:19 <felixphew> the fact that I'm too new to Haskell to actually wrap my head around them, mostly
04:01:57 <ertes-w> felixphew: parsec is probably simpler
04:02:13 <merijn> felixphew: Honestly, I doubt that's being new to Haskell. Alex and Happy are basically just "Haskell flex & bison", and every year all our compiler students spent weeks struggling with flex and bison
04:02:29 <ertes-w> alex/happy have the whole "how do i connect syntax to semantics?" deal as well as an extra language to learn
04:02:58 <felixphew> the part I'm having the most trouble with though is having to use the monad wrapper
04:03:02 <felixphew> because I need startcodes
04:03:04 <ertes-w> with parsec everything is "just haskell"
04:03:06 <LAZAR> How do i process a Map in haskell? like print its elements
04:03:22 <merijn> LAZAR: "mapM_ print"?
04:03:26 <ertes-w> LAZAR: Map has a Traversable instance
04:03:45 <ertes-w> although for printing Foldable is enough
04:03:48 <ertes-w> :t traverse_ print
04:03:50 <lambdabot> (Show a, Foldable t) => t a -> IO ()
04:08:03 <arbus> Are there any haskell libraries that support the generation of keys pairs with passphrase? I've been looking at hackage and crypto-pubkey seems to be the closest but it doesn't seem to support specifying a passphrase during key generation
04:11:09 <BernhardPosselt> Xion_: oh i see :)
04:11:09 <BernhardPosselt> ty
04:11:43 <BernhardPosselt> i suppose the real reason why a functor interface is awesome is because other types can be built on top
04:11:47 <ElyKar[m]> You don't specify a passphrase during keypair generation, you need it when you're writing the priv key on the disk, usually with PEM format.
04:11:50 <BernhardPosselt> e.g. Monad
04:12:08 <BernhardPosselt> tl;dr if you use Monad you get all the other stuff for free
04:12:41 <Xion_> BernhardPosselt: Monad doesn't need to be a Functor iirc
04:12:46 <Xion_> @src Monad
04:12:46 <lambdabot> class Applicative m => Monad m where
04:12:46 <lambdabot>     -- Note: Applicative wasn't a superclass before GHC 7.10
04:12:46 <lambdabot>     (>>=)  :: m a -> (a -> m b) -> m b
04:12:46 <lambdabot>     (>>)   :: m a -> m b -> m b
04:12:46 <lambdabot>     return :: a -> m a
04:12:48 <lambdabot>     fail   :: String -> m a
04:12:54 <BernhardPosselt> Xion_: its applicative right?
04:12:58 <Xion_> Yeah, the Applicative constraint is phony
04:13:08 <Xion_> It was added in some later version of GHC
04:13:24 <BernhardPosselt> because it was useful right?
04:13:31 <Xion_> (mostly because all practical Monad instances were Applicatives already)
04:13:56 <BernhardPosselt> so can you build monads that are not applicative?
04:14:32 <Xion_> I'd think so. Especially with this definition
04:14:41 <Xion_> (The alternative one with `join` definitely requires a Functor though)
04:14:42 <merijn> No
04:15:16 <merijn> Monads are, by definition, applicatives. So, as of GHC7.10 it's REQUIRED to provide the relevant Applicative instance
04:15:33 <Xion_> Oh. TIL
04:15:35 <merijn> There *are* Applicatives which don't have a corresponding Monad, though
04:17:11 <arbus> ElyKar[m] Thank you for that, I found this module which maybe what I need: http://hackage.haskell.org/package/HsOpenSSL-0.11.4.8/docs/OpenSSL-PEM.html
04:19:39 <ElyKar[m]> arbus: Glad it helped
04:22:37 <ph88^> could anyone take a look please? i have a problem with conduitDecode of Data.Conduit.Serialization.Binary  https://bpaste.net/show/16a5c91072a6
04:32:49 <saurabhnanda> how do I express the following idea in Haskell? https://gist.github.com/saurabhnanda/6e5c802aa08c7c9ae8cb5f3a6f852654
04:32:57 <lyxia> ph88^: have you tried to see whether Data.Binary.decodeFile works
04:34:52 <lyxia> ph88^: and what is the format of your dat file
04:35:34 <lyxia> saurabhnanda: what is the idea you want to express
04:35:56 <lyxia> does that file compile?
04:36:29 <saurabhnanda> lyxia: if there is a newtype with the followng pattern `newtype MyId  = MyId Int64" then simply making it an instance of PrimaryKey should lead to other boilerplate instances being immediately available.
04:36:37 <saurabhnanda> lyxia: no, it doesn't compile.
04:38:31 <saurabhnanda> lyxia: check the updated gist at https://gist.github.com/saurabhnanda/6e5c802aa08c7c9ae8cb5f3a6f852654
04:42:32 <quchen> merijn: Monads are »by definition« Applicatives since 7.10, before that only »de facto«. /nitpick
04:43:07 * quchen enjoys it quite a bit when people are told this piece of history and go »woah, that must have been awkward« ;-)
04:43:42 <lyxia> saurabhnanda: you can derive PrimaryKey from Coercible
04:43:53 <saurabhnanda> lyxia: what does that mean?
04:43:56 <merijn> quchen: I didn't capitalise Applicatives for a reason!
04:44:05 <merijn> quchen: I was refering to the mathematical applicative notion
04:44:21 <quchen> Oh, you mean lax monoidal semifunctors or something?
04:44:41 <quchen> I think that’s a speciality of Hask(ell) actually – Applicatives being Monads.
04:45:05 <lyxia> saurabhnanda: http://lpaste.net/355961
04:45:29 <quchen> Monads being Functors is true in general, but monads being Applicatives isn’t. At least I heard that multiple times.
04:45:39 <saurabhnanda> lyxia: okay, that's step 1
04:46:03 <saurabhnanda> lyxia: I'm getting stuck with the following, "if type is of instance X, then it is also an instance of type Y"
04:48:49 <lyxia> That's not really possible. Technically you can use UndecidableInstances+OVERLAPPABLE but it's quite yucky.
04:52:52 <lyxia> saurabhnanda: http://lpaste.net/355962 this would be more proper IMO
04:53:41 <saurabhnanda> lyxia: tried using UndecidableInstances but FromField starts overlapping with everything under the sun, after that
04:54:13 <LAZAR> How do I use pattern matching with nested data types... assuming i want to access var: function (OuterVar x y (InnerVar var))
04:54:17 <lyxia> that's why it's yucky
04:54:22 <saurabhnanda> lyxia: that's the boilerplate I'm trying to avoid. For every such newtype there are about 8 instances that I need to declare. And I have 30+ newtypes.
04:55:29 <lyxia> LAZAR: just like you wrote.
04:56:55 <quchen> > let (a, (b,c)) = ("hello", (True, "LAZAR")) in a ++ " " ++ c
04:56:57 <lambdabot>  "hello LAZAR"
05:01:23 <lyxia> saurabhnanda: do you also plan to have another class X' which should imply the same class Y
05:02:11 <lyxia> if not, what you did with overlapping instances might be the best option. Or Template Haskell.
05:02:54 <lyxia> A cosmetic improvement would be to rename PrimaryKey to FromField
05:07:06 <Jinxit> what's the simplest way to check the type of something deep in monadic code?
05:07:24 <phadej> (foo :: ()) and then check the type error :)
05:08:03 <merijn> Jinxit: typed holes, usually
05:08:55 <merijn> Jinxit: If you replace an identifier with an _ then GHC will print out it's type when you compile
05:09:20 <merijn> Jinxit: Alternatively, tools like hdevtools/ghc-mod let you query the type of an expression from your editor (assuming someone wrote a plugin for your editor)
05:10:56 <Jinxit> alright, thanks
05:12:46 <merijn> emacs/vim, as usual, should have decent support. No clue about the rest
05:14:17 <fendor> atom also has decent ghc-mod support
05:41:27 <Benzi-Junior> is there a way to get aeson to give useful information about where the parsing fails ?
05:41:40 <Benzi-Junior> rather than just ending up with Nothing
05:42:36 <quchen> Benzi-Junior: Isn’t there an »eitherParse« function? Or »parseEither«?
05:43:07 <cocreature> parseEither
05:43:33 <Benzi-Junior> eitherDecode is probably what I'm looking for
05:43:46 <Akii> yep
05:44:37 <Benzi-Junior> aw crap apparently it's an encoding problem
05:45:43 <cocreature> aeson expects utf8
05:46:13 <quchen> Doesn’t JSON expect UTF8 only?
05:46:37 <quchen> Ah no, it’s any Unicode.
05:47:42 <merijn> JSON doesn't specify an encoding (yay...)
05:48:27 <bollu> cocreature: I'm sorry, I haven't been able to find time :/ worst case, we can hack on this at ZuriHac
05:48:54 <cocreature> bollu: np. zurihac won’t work sadly since I’m not able to make it after all
05:49:12 <bollu> cocreature: ah, dang. That's unfortunate :( 
05:49:46 <quchen> cocreature: Nooooo!
05:49:57 <quchen> bollu: At least we’ll meet. :-)
05:50:02 <bollu> quchen: indeed :)
05:50:12 <bollu> quchen: do we wear badges with IRC names? -_^
05:50:23 <quchen> I always write my name on my badge, yes.
05:50:57 <cocreature> quchen: any plans for a munihac? :)
05:51:01 <ventonegro> it would be cool to meet, yes :)
05:51:08 <ventonegro> in ZuriHac
05:51:21 <cocreature> quchen: I still need to buy you a beer for your work on prettyprinter :)
05:51:22 <ongyerth> munihac? I think that sounds good
05:51:24 <quchen> cocreature: Yes, but we have conflicts with other conferences; we may have to push it back to October
05:51:31 <quchen> cocreature: Heh, you could just take a train to Munich ;-)
05:52:08 <quchen> ongyerth: Come to our usergroup! We just had the first one, second one will follow. μHUG @Meetup
05:52:11 <cocreature> quchen: that’s going to be an expensive beer for me :)
05:52:50 <quchen> cocreature: I just hope people start adopting the new lib
05:53:33 <quchen> It does introduce some breaking changes that need fixing, so there is a drawback. The changes are easily fixed, but some downstream libraries need fixing as a result, and so on.
05:53:50 <bollu> quchen: the pretty printer? Yep, I want to use it for my stuff (simplexhc)
05:54:01 <quchen> bollu: Glad to hear that :-)
05:54:55 <cocreature> quchen: getting people to move from llvm-general to llvm-hs seemed to work surprisingly well so I’m hoping the transition for prettyprinter is going to go just as well
05:55:17 <ongy> quchen: I will try to come to the next one, no guarantees though
05:55:29 <quchen> Cool!
05:55:42 <quchen> cocreature: I guess it’s mainly an advertising thing. Getting the core libs to switch and you’ll make everyone migrate ;-)
05:55:50 <Drakonis> hey folks, how's haskell doing in math libraries?
05:56:20 <quchen> optparse-applicative is fairly central, I should check whether the author considers switching, and if so help doing it
05:56:33 <quchen> And Trifecta if I can convince edwardk.
05:56:46 <quchen> Everything else will follow. In theory. :-)
05:57:21 <EvanR> :t minBy
05:57:23 <lambdabot> error: Variable not in scope: minBy
05:57:26 <cocreature> I guess it’s hard to find a reason to convince people to switch their code if it already works
05:57:40 <Jinxit> cocreature: what happened to llvm-general?
05:57:58 <cocreature> the pretty printer is usually not at library boundaries so there is no pressing reason to switch
05:58:05 <quchen> cocreature: Exactly. On the other hand, shutting yourself off less from the rest of the world can be a benefit even for an existing lib.
05:58:27 <cocreature> Jinxit: nothing, that’s the problem. there is still no release that supports anything > llvm 3.5 which is ancient at this point
05:59:27 <Jinxit> ah okay
06:00:49 <cocreature> Jinxit: there are branches for 3.8 and 3.9 on llvm-general’s github (mostly results of my work) but at some point contributing to llvm-general was more annoying than just maintaining a fork so stephen diehl, anthony cowley and I created llvm-hs
06:02:32 <mpickering> quchen: Make it around the same time as Nixcon :) ?
06:02:59 <quchen> Nixcon is in Munich as well, because a colleague is coorganizing it :-)
06:03:09 <quchen> So it won’t be at the same time unfortunately
06:03:20 <quchen> NixCon is at InnoQ right?
06:03:36 <mpickering> I don't know, just saw it's in Munich in October 
06:03:38 <ongy> quchen: can I derive Pretty instances for types?
06:04:15 <quchen> ongy: No, deriving isn’t something you can easily do for prettyprinting, since »being pretty« is hard to put into laws/algorithms
06:04:15 <merijn> ongy: That...seems nonsensical?
06:04:41 <quchen> ongy: You can write pretty instances based on Show output, but that’s rarely pretty
06:04:53 <ongy> or would that even be useful?
06:06:48 <quchen> I don’t think it would be, no.
06:07:05 <quchen> Anyway, you can’t do it, and I won’t build it ;-)
06:07:22 <quchen> You could cook up something with Generic, but the result would hardly be pretty.
06:09:19 <cocreature> if you just want some sort of slightly more readable output for "Show", pretty-show might be what you’re looking for
06:10:06 <ongy> mhh, I was looking for something that's derivable, but is intended to have pretty instances for some things
06:10:52 <ongy> cocreature: well, I wanted hexdump output for a Map Int ByteString (and when I get more into it, make some of those be even further parsed)
06:11:29 <ongy> it's in the netlink package, I'm currently abusing show, since I don't want to write all the instances and I highly doubt anybody minds it not being valid haskell
06:13:08 <quchen> I wrote show-prettyprint for this. Fairly robust even for awkward output, but has a Trifecta dependency :-/
06:13:22 <quchen> And one on ansi-wl-pprint. Maybe I should migrate my own package ;-)
06:14:59 <bitonic> quchen: thanks for the new pprint package BTW
06:15:05 <quchen> :-)
06:15:06 <bitonic> ansi-wl-pprint is nice but always felt a bit old
06:15:15 <quchen> bitonic: Try building HTML from it :-x
06:15:26 <bitonic> quchen: why? :P
06:15:45 <quchen> To understand what drives a person to write an alternative ;-)
06:16:10 <bitonic> quchen: how "drop in" is it? Do I just have to rename a few operators?
06:16:40 <quchen> bitonic: Two answers. a) use the compatibility package and it’s drop-in
06:16:56 <kosmikus> cocreature, ongy: in case pretty-show happens to be what is being looked for, there's pretty-sop which generically derives PrettyVal instances
06:16:56 <quchen> b) without the compat module, it should be just a few renames/definitions
06:17:11 <quchen> I don’t have </> for example, so if you rely on that being there you have to create it
06:17:51 <quchen> bitonic: It’s certainly something you can just try to do in a coffee break with a good chance of success
06:18:14 <bitonic> quchen: OK, thanks!
06:18:25 <bitonic> Maybe we can write a latex backend for it as well
06:18:27 <quchen> Idris took 30 minutes to migrate :-)
06:18:38 <quchen> Including cloning, clean bulid and all.
06:19:08 <quchen> bitonic: Sure, Latex backend is simple enough to build. I did not include one since Latex is so full of different styles that it wouldn’t be clear how to render to it exactly.
06:19:19 <quchen> Likewise for HTML. Should we include paragraphs? headlines? what colors?
06:19:46 <ongy> quchen: to my understanding show-prettyprint should refactor text generated by show? That wouldn't allow me to use hexdumps or similar for some field, would it?
06:19:49 <quchen> I think each use case here is so specific that it’s easier for everyone to just write their own backends, and provide simple API functions to do so
06:20:10 <quchen> ongy: It just adds line breaks after commas and parentheses, mostly.
06:20:40 <quchen> It wouldn’t touch hexdumps.
06:20:40 <Benzi-Junior> ok how do I check/change the encoding of a ByteString 
06:20:56 <quchen> Decode it, see if it works?
06:21:10 <EvanR> ByteString doesnt carry any encoding tag that you can check
06:21:13 <quchen> Bytestring does not have an encoding on its own; it’s just bytes
06:21:37 <EvanR> JBOB
06:22:02 <cocreature> Benzi-Junior: ask the person/take a look at the code that created it :)
06:24:10 <Benzi-Junior> so the problem I'm having is that it isn't a valid UTF8 stream (according to Aeson)
06:25:04 <EvanR> corrupted json data :(
06:25:23 <quchen> Benzi-Junior: Try Text’s decoding functions, they have error reports: https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Encoding.html#v:decodeUtf8-39-
06:25:47 <cocreature> the unix "file" command can guess encodings. if it’s not just broken utf-8 but some other encoding, it might be helpful
06:26:29 <EvanR> if you can guess the encoding, you might be able to compensate, but no telling what else you might get until you fix the source
06:26:58 <cocreature> there is also "chardet" which is a bit better at guessing encodings
06:32:21 <Benzi-Junior> very annoyingly all the problematic characters occur in fields of the JSON that I don't need
06:33:24 <EvanR> the decoder cant strictly know the problematic characters dont close the string quotes
06:35:32 <EvanR> i think Data.Text.Encoding has ways to decode something like that while recovering as soon as possible, youll get garbled data for the invalid bytes
06:35:43 <EvanR> then you can reencoding it, and put it back through aeson
06:36:11 <Benzi-Junior> decodeLatin1 successfully parsed the string 
06:37:05 <EvanR> even better, reencoding that as utf8, put it back through aeson
06:38:57 <Benzi-Junior> ye I'm trying that right now
06:39:15 <Benzi-Junior> I also have to be casting it between strict and lazy bytestring
06:39:16 * EvanR wonders what braindamaged system puts latin1 into a string, and that ends up making it through a json encoder
06:40:06 <EvanR> going from string to lazy is fine
06:40:12 <EvanR> strict to lazy
06:40:59 <EvanR> which is why aeson takes lazy
06:41:06 <Benzi-Junior> EvanR, ye it's no problem it's just kind of silly
06:41:24 <EvanR> actually aeson could take either
06:41:24 <cocreature> aeson has decodeStrict
06:41:42 <Benzi-Junior> because I have to take lazy to strict then latin to utf  and then strict back to lazy 
06:41:57 <Benzi-Junior> or that 
06:42:51 <EvanR> ... why doesnt encodeUtf8 output lazy
06:43:08 <Benzi-Junior> and EvanR this is a system that was written pre 2000 and has had minimal updates since then (this by no means the worst thing it does)
06:44:13 <EvanR> ah Data.Text.Encoding can output a Builder, which can be made lazy
06:44:24 <EvanR> toLazyByteString :: Builder -> ByteString
06:44:31 <EvanR> and all is gravy!
06:46:41 <tabaqui> I used hDuplicateTo to redirect stdout into some file
06:46:50 <tabaqui> and set NoBuffering(/LineBuffering)
06:47:06 <tabaqui> but when I use putStrLn, there is no data in the file
06:47:10 <Benzi-Junior> ok Aeson eitherDecode error messages could do with some improving
06:47:38 <tabaqui> looks like RTS flushes it after some time
06:48:00 <tabaqui> or don't write it at all due of lazyness
06:48:13 <EvanR> not laziness
06:48:22 <EvanR> you can hFlush stdout
06:48:37 <tabaqui> stdout is already closed, handle maybe
06:48:54 <tabaqui> I'll try, but I think lazyness is not a cause too
06:49:34 <EvanR> correct, putStrLn cant complete until the string you gave it is fully consumed, thats whats ultimately driving the evaluation
06:50:09 <EvanR> but then theres buffering
06:50:19 <tabaqui> sound reasonably
06:50:28 <tabaqui> hFlush does the thing
06:51:13 <EvanR> and flushing doesnt guarantee its synced to the disk, etc, etc
06:51:13 <Rodenbach> I was thinking about using Haskell for some minor tasks in a project that already is written in a different language. Could one compile Haskell code into a lib and use the FFI from that other language to call the 2-3 helper functions that I would be writing in Haskell?
06:53:28 <tabaqui> I tried `putStrLn $! "content"`, but it doesn't help
06:53:45 <glguy> Rodenbach: one could
06:53:55 <EvanR> $! doesnt do anything there
06:54:09 <tabaqui> "content" is still a list, right?
06:54:16 <EvanR> yeah
06:54:22 <Rodenbach> glguy: is there much overhead when calling such functions?
06:54:38 <EvanR> so before doing the putStrLn, 'c' will be evaluated, but it already is
06:54:47 <EvanR> actually no, the _:_ will be
06:55:03 <tabaqui> what?
06:55:18 <EvanR> f $! x, if evaluated, first evaluates x to WHNF
06:55:22 <EvanR> then applies f
06:55:33 <tabaqui> ah, yes
06:55:40 <glguy> Rodenbach: it varies with the amount of marshaling you need to do
06:56:04 <EvanR> "content" = 'c':'o':... already is, even if 'c' etc werent
06:56:24 <tabaqui> but I still cannot use it for logging because of delayed records
06:56:24 <glguy> $! doesn't force an order of evaluation
06:57:21 <EvanR> erm, f $! x is bottom if x is bottom
06:57:32 <glguy> correct
06:57:35 <Rodenbach> glguy: one interesting thought… in principle one could make certain Haskell data structures available, and the host language could use them then. Does that make sense? For example, bringin a Haskell hashmap implementation to the JVM or some Delphi program.
06:58:12 <EvanR> but its not going to do a deepseq on your list, and even if it did, doesnt help with your buffering lag
06:58:53 <glguy> sure, the point is just that $! and seq don't impose an order on evaluation
06:59:26 <glguy> so it's misleading to say "first"
06:59:33 <EvanR> yes
06:59:48 <EvanR> the 4th degree original point was that $! is not having any effect there
07:00:01 <glguy> agreed
07:00:06 <EvanR> and is not the right way to help with buffering
07:01:25 <EvanR> i dont understand "delayed records"
07:03:40 <tabaqui> EvanR: I have highly imperative code in IO monad
07:03:49 <tabaqui> with many "logMessage" functions
07:03:57 <EvanR> sure
07:04:19 <tabaqui> and log file has no content before I close the application
07:04:25 <tabaqui> (or maybe before some time)
07:04:33 <EvanR> you have to flush before you close the application
07:04:50 <tabaqui> but I don't want to close the application
07:04:54 <EvanR> then dont
07:05:00 <tabaqui> I want to see logs while it running
07:05:12 <EvanR> then you need to flush on a regular basis
07:05:19 <tabaqui> it looks so
07:07:05 <tabaqui> hm, it works
07:07:08 <tabaqui> dunno
07:07:39 <tabaqui> thank you then
07:07:52 <EvanR> are you sure youre setting the buffering mode correctly on the correct handle
07:12:59 <kuttifunk> rodenbach: i don't think it's easy. maybe serialization is the way. one needs to understand the exact memory layout of non simple types like hashmap afaics to have them mapped/casted/changed into a structure (=memory layout) of another language. possibly, if you have relatively simple types then maybe there is a haskell-type->C->Other Language Type conversion somewhere
07:13:55 <EvanR> you can hold references to pass the haskell 
07:13:58 <kuttifunk> eg see https://github.com/ddfisher/HaPy/blob/master/HaPy-python/HaPy.py
07:14:28 <EvanR> StablePtr
07:17:49 <kuttifunk> EvanR: yes, but you still have to know how your hashmap is represented in memory to access it in say, Ruby, or don't you? still learning all of it..
07:18:17 <EvanR> not in this case
07:19:57 <kuttifunk> i mean, if i want to have a python dict out of a haskell hashmap and vice versa.
07:20:37 <EvanR> i think the map is secondary here to the data youre putting and getting out of the map
07:21:08 <EvanR> since the map can live entirely on the haskell side, but you cant do anything with it without converting the values to and from haskell
07:21:53 <kuttifunk> but this is how i understood the question of rodenbach in the first place :) anyway.. 
07:22:06 <EvanR> i assumed thats what "use haskell data structures" meant, and not getting a local representation of whats in haskell
07:25:38 * hackage ansi-terminal 0.6.3.1 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.6.3.1 (RomanCheplyaka)
07:35:40 <tabaqui> EvanR: I've set it for both handles: stdout and log file
07:36:13 <EvanR> which platform
07:36:58 <tabaqui> linux, x86_64
07:37:12 <tabaqui> ghc 8.0.2
07:41:52 <tabaqui> okaay
07:41:59 <tabaqui> 1) open handle
07:42:10 <tabaqui> 2) duplicate stdout to the handle
07:42:28 <tabaqui> 3) set buffering for stdout 
07:42:32 <tabaqui> 4) works
07:43:00 <tabaqui> doesn't work if you set buffering for file handle or if you set buffering BEFORE duplicate
07:43:52 <shapr> Good morning Haskell!
07:44:05 <tabaqui> good evening
07:45:55 <Rodenbach> I was thinking about offering an API to create and work with one of the Haskell Hashmap implementations.
07:46:05 <shapr> Hm, I ran across IOHK using a custom prelude this morning, and it looked great, but I can't find it again.
07:46:39 <Rodenbach> One function that creates an empty map, or just a constant that points to an empty map. Then the calling language would pass the pointer to several functions, one for inserting a new key/value pair, one for removing a key, to iterate over it, etc.
07:47:48 <ertes-w> Rodenbach: if "because haskell" is not a valid answer, why are you doing this?
07:53:07 <cheater> can ghc produce reproducible builds?
07:55:26 <ongy> cheater: afaik there's some problems, debian has a wiki about reproducable builds that's usually rather informative
07:56:02 <cheater> ongy: problems that have workarounds or problems that no one has solved yet?
07:56:09 <cheater> i'm talking about builds of my own code, not builds of ghc btw
07:57:04 <ongy> cheater: iirc avoidable if you set up a build container to force exact dependency version and paths. But I'm not 100% sure
07:57:12 <cheater> OK
07:57:16 <cheater> good to know, thanks
07:57:22 <cheater> that's good enough for me
07:58:59 <cheater> do you guys think once modules are in a lot of libraries will move from type classes to modules?
08:00:02 <ongy> cheater: is a word missing in that sentence?
08:01:17 <foojin> Is there a library/Prelude function that behaves like flip forM id :: [Maybe a] -> Maybe [a]?
08:01:31 <ongy> :t sequence
08:01:32 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:01:50 <ongy> :t traverse -- I tend to do sequence . map, when there's this
08:01:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:01:56 <cheater> ongy: no. why would there be a word missing?
08:02:11 <cheater> i'm asking about whether people will move from typeclasses to modules once those become available in ghc
08:02:48 <ongy> then you are missing punctuation. "once modules are in a lot of libraries..."
08:02:53 <reactormonk[m]> cheater: what do you mean by modules
08:03:11 <ongy> since modules exist since quite some time
08:03:25 <merijn> ongy: I think he means ML style module functors
08:03:30 <cheater> i mean ML like modules
08:03:35 <merijn> ongy: What ezyang is working on with backpack
08:04:00 <foojin> ongy: Thanks.
08:04:16 <ongy> merijn: then why wouldn't he say so? :)
08:05:17 <ongy> To answer the question: probably not for another 2 or 3 compiler versions, to keep backwards compatability. once a GHC with backpack is a common version, maybe
08:07:48 <ezyang> It's going to take time 
08:08:05 <ezyang> We don't even know if people like the Backpack programming model. 
08:10:19 <ph88^> lyxia, i just tried decodeFile, it gives a similar exception (also not enough bytes). The format of the file _should_ be 8 byte reals (double precision floats) .. but in case it's garbage i still expect number or otherwise NaN .. in any case not "not enough bytes"
08:11:05 <ADG_> how to get variable length array in Data.Array
08:11:22 <glguy> no
08:11:49 <ADG_> I'm doing a fibonacci like function but I am trying to get thefirst index with so and so
08:11:52 <ADG_> it coul dbe anything
08:11:56 <dolio> Data.Array doesn't implement variable length arrays.
08:12:03 <ADG_> anything else?
08:12:05 <ReinH> Use an IntMap.
08:12:16 <zachk> ADG_, are you trying to memoize?
08:12:24 <ADG_> yes
08:12:27 <ReinH> or one of the memoization packages
08:12:27 <ADG_> but !! is slow
08:12:39 <ADG_> that isnt quite standard
08:12:51 <ReinH> what?
08:13:40 <cheater> ezyang: why wouldn't people switch to backpack as soon as it's available?
08:15:09 <nshepperd_> I like typeclasses just fine. Why would I rewrite all my code for no good reason?
08:15:38 <phadej> indeed, e.g. http://hackage.haskell.org/package/parsers approach works quite well.
08:15:51 <phadej> especially with cascade of different Parsing type-classes
08:16:00 <merijn> phadej: Well parsers does force a dependency on both attoparsec and parsec
08:16:01 <phadej> I have no idea, how that would map into Backpack
08:16:26 <phadej> merijn: the instances could be in orphan packages, they just aren't
08:16:40 <phadej> s/orphan/as orphans in separate/
08:16:45 <dolio> The dependencies could also be inverted. :)
08:17:03 <glguy> ezyang: You aren't designing backpack as a direct replacement for typeclasses, are you?
08:17:06 <dolio> Which is probably what should actually happen for that case.
08:17:20 <ezyang> Backpack is not supposed to replace typeclasses. There are many typeclasses which you can't do / would be really horrible to do 
08:17:34 <phadej> dolio: except that parsers depend on a lot of stuff neither parsec or attoparsec depend even transitively :)
08:17:36 <merijn> dolio: Well, you try getting either Parsec of bos to release something new when you want :p
08:17:48 <merijn> And that
08:17:53 <dolio> Yeah, I know it won't happen.
08:18:11 <lyxia> ph88^: the file should start with the number of elements in the list
08:18:42 <ezyang> What Backpack will let you do is do 'parsers' style parametrization, without having to build the parsers library first. You just write a signature of the things you need 
08:19:31 <lyxia> ph88^: and the encoding of Doubles might also be very peculiar
08:20:06 <dolio> Anyhow, of course it won't replace type classes. The fact that backpack lives at the packaging level means that that doesn't make much sense.
08:20:47 <phadej> I can imagine using backpack to implement servant-client-http-client and servant-client-http-streams
08:20:58 <phadej> but have first to find out what the right interface is :)
08:21:38 <phadej> at least it would be nice exercise to do that
08:21:47 <phadej> to *try* to do
08:22:43 <ReinH> You can find a lot of uses for a proper module system once you get to use one. :D
08:23:20 <ReinH> Just look at any ML or Agda code you'd care to name.
08:23:28 <phadej> ReinH: but I'm still struggling how backpack and type-classes interact
08:23:42 <ReinH> They overlap somewhat but not entirely.
08:23:52 <ReinH> In fact, I don't think they overlap that much.
08:23:59 <lyxia> ph88^: using the out-of-the-box Binary deserializer seems very fragile when working with anything other than the output of the corresponding serializer.
08:24:30 <ReinH> Once you add LANGUAGE KitchenSink they start to overlap a bit more
08:24:32 <phadej> ReinH: what happens to instances declared in a module instantiated with a bit different types; how it affects MPTC
08:24:35 <phadej> FunctionalDependencies etc
08:24:58 <ReinH> I think in some ways the extensions to typeclasses were meant to be a poor man's functorization
08:25:00 <lyxia> ph88^: so you should probably write a custom get
08:25:03 <ezyang> phadej: It's actually all very dumb 
08:25:32 <ezyang> just pretend that a dep on a signature desugars into a dep on the implementing module, with an explicit export list 
08:25:38 <cheater> ezyang: i don't want backpack to replace good useful typeclasses. but there's a lot of bad hacks using typeclasses and that's what i think backpack will replace. so i wonder how soon people will switch from tc hacks to that.
08:25:40 <phadej> ezyang: I'm sure you explained it somewhere (in paper or blog post), i'm just too lazy to explore them :)
08:25:47 <dolio> ezyang: Is the story still that backpack kind of ignores type class uniqueness, and hopes for the best (and lets the compiler catch errors in the elaborated stuff)?
08:25:49 <ReinH> otoh one problem Backpack has not solved is the namespace collision between different meanings of functor.
08:26:00 <ezyang> dolio: Yeah, exactly 
08:26:03 <dolio> Okay.
08:27:50 <cheater> dolio: is that good or bad?
08:27:55 <phadej> ezyang: what if two different packages instantiate the same module with the same type, will the code be deduped somehow?
08:28:02 <ezyang> cheater: I hope earlier than later, but for now, it will only be the "Is comfortable with GHC 8.2 only" crowd. Which, for big packages, is pretty small 
08:28:04 <dolio> It's bad, I guess. But expected.
08:28:38 <cheater> ezyang: can't there be provisional support added with backwards compatibility in place?
08:28:39 <ezyang> phadej: Not if there are different modules. Which is important, because you might be depending on the instantiations to be different if the functions in those two different modules are different 
08:29:03 <phadej> ok I see. In Agda you could prove them to be same, but not in Haskell :)
08:29:12 <cheater> ok, so i guess a lot of people want to support the last 3 versions of GHC. when will ghc 8.4 be out, roughtly?
08:29:24 <ezyang> dolio: So, I conjecture that there actually is a pretty well-defined subset of Haskell which will handle type classes compositionally 
08:29:31 <ezyang> next year :) 
08:29:45 <cheater> early or late next year?
08:29:50 <dolio> cheater: Actually, it's probably not much of a problem. If you never write orphan instances in a backpack module, I think you're okay.
08:29:52 <ezyang> GHC has a yearly release cycle 
08:30:07 <dolio> That's what edwardk and I came up with, at least.
08:30:07 <phadej> cheater: https://www.haskell.org/ghc/ extrapolate from that :)
08:30:10 <cheater> yeah but 8.2 is this year right
08:30:31 <saurabhnanda> is there any document that describes the battle-tested + recommended structure for organising test suites in a large Haskell project
08:30:32 <saurabhnanda> ?
08:30:34 <dolio> Never writing orphans seems like a sufficient condition for not having problems.
08:30:51 <cheater> so we only get to do this in 8.6 which would be what, 2019?
08:30:58 <cheater> that's kind of silly
08:31:19 <phadej> cheater: you don't come from C++ community, don't you :)
08:31:19 <cheater> i.m.o.
08:31:32 <cheater> phadej: i don't know how to answer this question
08:31:36 <phadej> it might turn out that Backpack is bad idea (tm)
08:31:39 <dolio> ezyang: Maybe that's the subset you were thinking of, too?
08:31:54 <phadej> or how it interacts with DependentHaskell
08:32:15 <nshepperd_> I've read a lot about ml modules and I don't see a reason to get so excited
08:32:19 <kamyar> Hello guys
08:32:21 <cheater> i don't see how backpack could make DH go wrong
08:32:33 <cheater> backpack is on the package level, dh is on the code level
08:32:34 <ezyang> dolio: Basically. 
08:32:38 <kamyar> I have a question about lens:
08:32:52 <phadej> cheater: C++ is ridiculously slowly evolving language
08:33:07 <cheater> phadej: i don't think we should be mimicking C++ in any way
08:33:14 <ezyang> I think we will have to think about how Dependent Haskell interacts with Backpack. Backpack makes some staging assumptions (typecheck types first, then values) which may be broken by DH 
08:33:15 <cheater> or comparing to it
08:33:28 <cheater> ezyang: interesting
08:33:44 <ReinH> saurabhnanda: I don't know of one, but I also don't think it's that different from usual approaches
08:34:02 <ReinH> unit tests of modules, integration tests of... integrations between modules.
08:34:32 <saurabhnanda> is the advice given at https://stackoverflow.com/questions/4687387/organizing-haskell-tests sound?
08:34:34 <kamyar> Apparently lpaste is out of order!
08:34:51 <saurabhnanda> and what's the difference between tasty, haskell-test-framework, and HTF?
08:34:57 <cheater> nshepperd_: the major win with module functors is that you can build your application with a choice of dependencies.
08:35:00 <cheater> for me.
08:35:27 <cheater> nshepperd_: this means you can eg build a web server against different event loops, or build a gui app against different toolkits.
08:35:37 <cheater> stuff like that.
08:35:43 <cocreature> kamyar: just use one of the other paste services :)
08:36:00 <kamyar> cocreature: I am just doing 
08:36:12 <kamyar> Here is my code: https://pastebin.com/PrtDSvZZ
08:36:16 <ReinH> saurabhnanda: Yes, that's what people tend to do.
08:36:21 <kamyar> PLease help me rewrite the last line using lens
08:36:50 <ReinH> saurabhnanda: They are different test frameworks that let you combine unit tests, quickcheck properties, and such into a single test suite
08:37:07 <ReinH> You should look at their documentation to see how they differ
08:37:56 <cocreature> kamyar: assuming you have generated lenses using makeLenses (which requires prefixing the record accessors with an underscore) you should be able to use "set (account . accountId) aid v"
08:37:59 <phadej> cheater: yeah, but three year interval doesn't seem to be too long. Backpack haven't yet proved it's good idea. And it would be great that people try out it (e.g. you) making things on top of backpack
08:38:23 <phadej> but as industrial user, it's just too big risk for me to use it
08:38:26 <phadej> (now)
08:38:40 <cocreature> welp, figuring out how "partsOf" is implemented is turning out to be even more complicated than I thought
08:38:57 <saurabhnanda> ReinH: is there a known good choice? I really don't want to spend time writing tests with one framework only to get stuck in a hole. I'm not knowledgable enough to make a choice at this point.
08:39:31 <saurabhnanda> kamyar: did you get what you needed?
08:39:32 <sm> morning all
08:39:43 <phadej> cocreature: it's virtually a two traversals, first collecting and then putting back with State
08:39:59 <sm> cheater: re web server against different event loops - I've been able to do that for years thanks to wai, how would module functors be better ? less recompilation ?
08:40:13 <kamyar> cocreature: Do I have to use underscore to be able to use lens?
08:40:14 <cocreature> phadej: yeah I get the basic idea but once I tried to unwrap all the newtypes and type synonyms I got really lost
08:40:21 <cheater> less pretending that type classes are a good idea for this
08:40:59 <sm> saurabhnanda: choose based on their activity level, eg recent releases and issues closed. tasty is probably the popular one at the moment
08:41:03 <kamyar> sm: Here is Internet! Not all of us are in the orning!
08:41:10 <phadej> cocreature: maybe #haskell-lens is better place to discuss the details
08:41:13 <kamyar> sm: morning
08:41:31 <kamyar> saurabhnanda: Not exactly. I just asked another question
08:41:32 <nshepperd_> Can't you already build your program against different libraries
08:41:33 <cocreature> phadej: yeah, I need to go buy food now but I’ll jump in there later today :)
08:41:33 <sm> kamyar: I know, just bringing a little california sunshine :)
08:41:45 <nshepperd_> Just import a different package
08:41:49 <saurabhnanda> kamyar: is your lens related problem solved?
08:41:54 <phadej> cocreature: food, thanks for the reminder
08:42:13 <kamyar> saurabhnanda: I dont wanna use underscore in my accessors. Is there still a way to use lenses?
08:42:46 <phadej> you can configure makeLenses variant to generate  lenses named in own way
08:42:48 <saurabhnanda> kamyar: give your record fields a common prefix.
08:43:26 <phadej> https://s3.amazonaws.com/haddock.stackage.org/lts-8.16/lens-4.15.1/Control-Lens-TH.html#v:makeLensesFor
08:43:29 <byorgey> kamyar: yes, you can use makeLensesFor instead of makeLenses
08:43:34 <saurabhnanda> kamyar: data Account = Account { acField1, acField2, acField3}; makeLensesWith abbreviatedFields ''Account
08:44:08 * hackage network 2.6.3.2 - Low-level networking interface  https://hackage.haskell.org/package/network-2.6.3.2 (dukerutledge)
08:44:18 <Unode> if there's anyone fluent in conduit in the channel. I have http://dpaste.com/1MZTHHH but don't know how to handle the 4th argument properly. The tutorial https://github.com/snoyberg/conduit#terminology-and-concepts mentions the forth argument to be the result-type of a component but I can't seem to find the right functions to handle this. The tutorial also mentions this would be explored in the folds section
08:44:20 <Unode> but it doesn't elaborate much.
08:44:35 <kamyar> saurabhnanda: Is is feasible to use lenses then? for my case
08:44:54 <saurabhnanda> kamyar: and if you think this is a code smell, then yes, I agree with you. This is a super idiotic thing about Haskell. I hated it when I came across it the first time as well. I've learnt to ignore it and move on with solving the real problem/project at hand. But, yes, being forced to do this is idiotic.
08:45:43 <saurabhnanda> kamyar: yes, it's feasible to use lenses. Just give your fields a common prefix. Just do that and move on. I've learnt it the hard way.
08:46:04 <kamyar> saurabhnanda: since I have not so many deep levels
08:46:25 <kamyar> saurabhnanda: for 2 or 3 levels I think lens is not so shining
08:46:50 <saurabhnanda> kamyar: Use lenses. Period. When your app grows even a little bit you'll want to kick yourself for not using them since the beginning. Apart from nesting, lenses also alleviate the problem of being able to refer to fields with the same name.
08:47:14 <glguy> The lens package is about much more than updating records. Updating records is the least interesting thing it does
08:47:20 <saurabhnanda> kamyar: in your current code you want be able to call two fields `userName` in two different record types.
08:47:48 <kamyar> glguy: But lens is very complicated to learn!
08:47:56 <saurabhnanda> kamyar: the faster you wrap your head around lenses, the easier writing mundane code will become.
08:48:18 <glguy> kamyar: ok?
08:48:45 <kamyar> glguy: Ok! So I have to get wet sooner
08:48:50 <nshepperd_> So when are we getting -XRecordLenses
08:48:59 <saurabhnanda> kamyar: yes, I agree. Haskell's core language should have the ability to deal with record types better. Lenses feel like a nuke when a dagger would do. But that's what there is.
08:49:24 <kamyar> Actually I love haskell but it is full of complicated hard-to-learn things
08:49:59 <shapr> lenses are awesome
08:50:00 <saurabhnanda> kamyar: don't even try to understand the types that lens produces. It's a rabbit hole. Just learn to **use** the following: ^. ^? .~ and & -- rest you'll figure out when you get more comfortable.
08:50:10 <glguy> You don't have to use lens, it's a bonus. Typically you'd just not get to express the concepts that lens allows
08:50:13 <mniip> saurabhnanda, but but
08:50:14 <reactormonk[m]> kamyar: and simple
08:50:59 <saurabhnanda> kamyar: are you approaching Haskell with an intent to learn esoteric stuff or with an intent to solve real life problems?
08:51:09 <saurabhnanda> mniip: ?
08:51:17 <kamyar> I think there are many necessary concepts that are complicated
08:51:30 <kamyar> I have to learn Conduit, Pipes, Arrows....
08:51:38 * hackage streaming-binary 0.2.2.0 - Streaming interface to binary.  https://hackage.haskell.org/package/streaming-binary-0.2.2.0 (MathieuBoespflug)
08:51:50 <saurabhnanda> kamyar: only if you want to. I've gone down that rabbit hole and a lot of that stuff isn't necessary.
08:51:50 <sm> haskell is a big language kamyar, it should be learned gradually
08:51:55 <kamyar> saurabhnanda: I am using Haskell in real world problem. This code is part of a big program I am just writing
08:52:13 <mniip> saurabhnanda, I wouldn't say with such confidence that one shouldn't even try to learn the lens types
08:52:21 <mniip> they're fun to figure out imo
08:52:39 <saurabhnanda> kamyar: then take my advice, please. Solve the problem at hand first. Don't get distracted by esoteric stuff. 
08:53:08 <kamyar> saurabhnanda: So please reweite the equivalent lens phrase
08:53:21 <kamyar> saurabhnanda: rewrite
08:54:27 <saurabhnanda> kamyar: let v = v & account.accountId .~ aid
08:54:32 <ReinH> saurabhnanda: I think any of them are fine. I've used tasty in the past.
08:54:41 <mniip> hmm
08:54:41 <saurabhnanda> kamyar: if I've understood the intent of the code correcly. Let me know if it compiles.
08:54:43 <kamyar> saurabhnanda: thnx
08:54:53 <mniip> can I lift Const to higher kinds...
08:54:58 <ReinH> kamyar: you don't have to learn any of those things
08:55:32 <ReinH> At most, you should learn what they do so you can decide if you need to learn them.
08:55:38 <saurabhnanda> btw let v = v blah is a recursive definition -- DONT DO THAT
08:55:53 <saurabhnanda> yet another haskell wart.
08:56:01 <ReinH> That's like saying you have to learn [ insert popular python library ] to use python.
08:56:02 <mniip> wart?
08:56:04 <ReinH> Not a wart, a feature.
08:56:08 <saurabhnanda> kamyar: let v1 = v & account.accountId .~ aid
08:56:31 <saurabhnanda> ReinH: not a wart. It's a landmine. Useful in few situations, but dangerous.
08:56:36 <ReinH> No, it is not.
08:56:40 <ReinH> It's by design.
08:56:57 <ReinH> Mutation is dangerous.
08:57:15 <saurabhnanda> ReinH: IMO it should be explicit, not implicit. That's it. A simple tweak will still have all the power, minus all the confusion. Better programmer UX.
08:57:16 <mniip> RealWorld is a dangerous place
08:57:32 <ReinH> Seriously, you make that mistake once and your program doesn't run and you never make it again
08:57:35 <ReinH> I don't see what the problem is
08:58:01 <dolio> I write a ton of local recursive definitions. Way more than 'a few'. Maybe that's just me.
08:58:01 <ReinH> But I have and continue to be bitten by mutation in other languages.
08:58:04 <saurabhnanda> ReinH: It's okay. There are bigger problems with the language that need to be solved first. This one is minor compared to others.
08:58:07 <nshepperd_> saurabhnanda: you want letrec to be a separate keyword from let?
08:58:15 <ReinH> It's so minor that it isn't even a problem.
08:58:21 <mniip> dolio, agreed
08:58:32 <mniip> every haskell module has at least a dozen of
08:58:38 <mniip> where go = ... go
08:58:44 <saurabhnanda> what kind of code are you guys writing?
08:58:48 <ReinH> Haskell.
08:58:50 <mniip> haskell
08:58:57 <saurabhnanda> which problem domain?
08:59:04 <ReinH> Any.
08:59:30 <ReinH> It's a normal thing to do.
09:00:22 <saurabhnanda> anyways, I just feel that a explicitly marking a recursive definition has the same power, but lesser confusion. 
09:00:38 <ReinH> And I feel like it's a complete waste of three characters.
09:00:50 <ReinH> And it makes it harder to change your code for no benefit.
09:01:00 <ReinH> Haskell is not a total language. You can't stop people.
09:01:18 <dolio> Stop what?
09:01:24 <glguy> people
09:01:56 <ReinH> from using general recursion
09:01:56 <glguy> Maybe you can't stop them from accidentally constructing bottoms?
09:02:36 <mniip> saurabhnanda, confusion?
09:02:56 <ReinH> What is confusing about using recursion in Haskell? It's how you get stuff done.
09:03:17 <kamyar> ReinH: I have to learn! Just for reading some data from database I have to learn Conduit
09:03:29 <ReinH> kamyar: You do not.
09:03:49 <kamyar> ReinH: The best way is to use pipes or conduit. Yes I know there are other ways
09:03:50 <glguy> You can go along your whole Haskell career and never need conduit
09:04:16 <ReinH> How would you know if it is the best way?
09:04:22 <kamyar> My next project is about streaming Video and I guess I have to use PIpes, COnduit Streams...
09:04:41 <ReinH> Yes, if you're doing things that conduit is designed for, you probably want to use conduit.
09:04:43 <nshepperd_> The difference here is between your program having a compile error or a <<loop>>
09:04:49 <ReinH> That doesn't mean you *have* to use it to write Haskell.
09:04:49 <kamyar> ReinH: From documents of Persistent and Groundhog
09:04:56 <nshepperd_> I don't see a significant difference in confusion
09:05:59 <dolio> One is harder to track down.
09:06:46 <EvanR> havent used conduit yet
09:06:46 <mniip> heh
09:06:54 <ReinH> And letrec is supposed to fix this?
09:06:58 <mniip> I've been using encodeFile/decodeFile for a database for quite a while
09:07:24 <mniip> :t Data.Binary.encodeFile
09:07:26 <kamyar> cocreature: u still there?
09:07:26 <lambdabot> binary-0.8.3.0:Data.Binary.Class.Binary a => FilePath -> a -> IO ()
09:07:40 <EvanR> mniip: the simplest thing that will work
09:07:49 <mniip> yeah
09:08:00 <ReinH> What happens with letrec is people write the thing they way, the compiler tells them to use letrec, they use letrec, and then they get a <<loop>>. It doesn't fix anything.
09:08:00 <mniip> didn't need to be industrial strength
09:08:15 <ReinH> s/way/want
09:08:28 <cocreature> kamyar: yes?
09:08:31 <ReinH> it's just extra steps for no benefit
09:09:41 <kamyar> cocreature: I cant use prefix since I am using GroundGog
09:09:50 <kamyar> cocreature: Let me add the whole code file
09:10:19 <cocreature> kamyar: several people have told you already that you can use makeLensesFor to generate lenses without relying on an underscore prefix
09:10:40 <kamyar> cocreature: I cant use any prefix
09:10:42 <glguy> You don't even have to use a prefix at all
09:10:43 <nshepperd_> Well in theory you would read the compiler error and see that you didn't intend the definition to be recursive
09:10:50 <nshepperd_> But I agree
09:11:10 <kamyar> cocreature: https://pastebin.com/MyHrqHLn
09:11:11 <glguy> kamyar: You should start here if you have questions about what the lens package can do with template haskell http://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-TH.html
09:12:02 <kamyar> glguy: Thnx! See my code plz: https://pastebin.com/MyHrqHLn
09:12:28 <glguy> kamyar: Let me know if you have questions about something you read in the link I sent
09:12:39 <kamyar> glguy: I am just reading the link
09:13:24 <EvanR> is the suggestion to add a letrec and make let non recursive
09:13:55 <EvanR> i have a better idea, if you want non recursive, use getIdentity $ do <lets lets lets, return result>
09:14:26 <glguy> let in do-notation is recursive...
09:14:50 <EvanR> oh right
09:15:02 <EvanR> if you want non recursive let x = x + 1, then nevermind im totally against it
09:15:34 <ReinH> I'm even more against the behavior changing depending on which version of let you're using.
09:15:57 <EvanR> or something like nonreclet x = x + 1 ;)
09:17:23 <ReinH> If you have a bunch of let x' = x + 1 then I submit that you're trying to write imperative code.
09:17:51 <EvanR> sure
09:17:59 <ReinH> EvanR: in fact, if you use getIdentity then you can write x <- x + 1
09:18:12 <EvanR> er...
09:18:20 <EvanR> x <- return (x + 1) ?
09:18:34 <ReinH> sure, whatever version typechecks
09:19:02 <dolio> ReinH: The presumption is that lots of people accidentally write recursive definitions that they meant to be shadowing. Not that they'd be writing lots of vacuous recursive code that would be invalid unless they typed rec.
09:19:37 <dolio> But yes, writing a lot of that shadowing is likely to be due to imperative-like code.
09:20:27 <EvanR> x', x'', x'''... i kind of dont want to set up the State is takes to do this when its more than one variable
09:20:57 <EvanR> but it is error prone
09:20:57 <c_wraith> I think in something like 4 years of writing production haskell code, I had an accidentally recursive value twice. 
09:21:20 <dolio> Yeah, I don't get bitten by that very much.
09:21:35 <c_wraith> I had intentionally recursive values a lot more than that. 
09:22:08 <EvanR> language design for expert proficient, or for relative programming novice
09:23:40 <EvanR> i think design for the quality level results you want, if you encourage verbosity and redundancy, itll be lower quality
09:24:04 <dolio> Also, fairly frequently when I do accidentally write a recursive value, it's a type error.
09:24:17 <c_wraith> and I mean, this isn't an issue like "good programmers don't write buffer overruns in C" 
09:24:37 <c_wraith> the worst case is a program hanging. 
09:25:08 <EvanR> so its middly bad between crashing with an error, and going into undefined exploitable behavior
09:25:47 <ADG_> I need to make newton-raphson-sqrt, i.e. do x = x-(x^2-n)/(2x) until taking first 100 decimal places of x is accurate to x^2=n, should I use Double?
09:25:51 <c_wraith> sadly, I've written more buffer overruns in Haskell, with incorrect use of unsafe vector indexing.. 
09:26:05 <EvanR> :(
09:26:46 <EvanR> ADG_: Double doesnt have 100 decimal places of accuracy
09:26:55 <nshepperd_> ADG_: double only has like 9 decimal digits of precision
09:27:01 <ADG_> so (Integer, Integer) ?
09:27:16 <c_wraith> ADG_, maybe Rational 
09:27:16 <EvanR> Rational ?
09:27:17 <phadej> ADG_: Rational
09:27:41 <EvanR> > (10^100 - 1) % (10^100)
09:27:43 <lambdabot>  9999999999999999999999999999999999999999999999999999999999999999999999999999...
09:27:51 <EvanR> hmm.
09:28:12 <EvanR> > realToFrac ((10^100 - 1) % (10^100)) :: Double
09:28:14 <lambdabot>  1.0
09:28:22 <EvanR> ship it
09:31:11 <nshepperd_> Rational probably too slow. Maybe use a Decimal or something
09:31:23 <nshepperd_> Or one of the CReals
09:31:53 <EvanR> this algorithm with CReal seems roundabout
09:32:03 <c_wraith> nshepperd_, shouldn't it be more than that? like, isn't there 53 bits of mantissa in a 64-bit double? that should be a bit under 20 decimal digits. 
09:32:17 <EvanR> its like 15 digits
09:32:38 <nshepperd_> Oh yeah, 15
09:32:51 <EvanR> Float is less
09:32:57 <EvanR> should be about half
09:33:24 <nshepperd_> > 53 / logBase 2 10
09:33:26 <lambdabot>  15.954589770191003
09:33:57 <c_wraith> almost 16. so close. 
09:37:03 <c_wraith> anyway, newton-rhapson sqrt is just repeated divide and average. that should be plenty fast with Rational, especially given that it basically doubles precision with each iteration. 
09:37:58 <c_wraith> so 100 digits of precision should only take 8 or so iterations. 
09:38:32 <c_wraith> maybe 11, to get to decimal. 
09:46:40 <EvanR> divide, average, square, compare... might be a little too much for a generic data structure made of those 4 syntaxes
09:47:09 <EvanR> the compare parat
09:58:27 <saurabhnanda> doe snayone know what could be causing this -- <command line>: can't load .so/.DLL for: /Users/saurabhnanda/projects/vl-haskell/.stack-work/install/x86_64-osx/nightly-2017-03-01/8.0.2/lib/x86_64-osx-ghc-8.0.2/libHSwebservice-0.1.0.0-7LcdrtHUa9ZAc4YOd1p47l-ghc8.0.2.dylib (dlopen(/Users/saurabhnanda/projects/vl-haskell/.stack-work/install/x86_64-osx/nightly-2017-03-01/8.0.2/lib/x86_64-osx-ghc-8.0.2/libHSwebservice-0.1.0.0-7LcdrtHUa9ZAc
09:58:27 <saurabhnanda> 4YOd1p47l-ghc8.0.2.dylib, 5): Symbol not found: _webservicezm0zi1zi0zi0zm7LcdrtHUa9ZZAc4YOd1p47l_ModelsziBookingziTypes_zdfDefaultConstantConfirmationModeColumn1_closure 
09:59:46 <kadoban> Is that the error you get sporadically when you have modules that are neither in exposed-modules or other-modules in the .cabal file? That'd be my wild guess.
10:01:18 <saurabhnanda> that was my first guess, but I tried putting Models.Booking.Types into exposed-modules, but still get the same error
10:02:50 <saurabhnanda> if my test suite is in a separate directory called tests/, do I need to expose every module of my app?
10:03:39 <kadoban> Just the ones used in tests
10:04:57 <saurabhnanda> aargh...
10:08:15 <saurabhnanda> I'm still getting it... added that module to exposed-modules and other-modules -- still gett it.
10:08:38 <saurabhnanda> I'm doing this on intero, btw. Switching target to the test suite. That's what is throwing the erro
10:10:57 <drdo> cabal-install is one hungry guy
10:11:15 <drdo> Can't run it on this small machine with 256MB ram and 512MB swap
10:12:00 <saurabhnanda> drdo: are you install lens?
10:12:07 <saurabhnanda> *installing
10:13:05 <kadoban> 256MB is really low for compiling haskell code. I used to barely get by on my old machine with 2GB
10:13:07 <drdo> saurabhnanda: I was trying to install wai, but it doesn't even get past resolving the deps :P
10:13:19 <EvanR> i vaguely remember compiling with 128M ram on a VPS, but it was several GHC's ago
10:13:40 <kadoban> And if you're going to swap, you might as well go take a nap and come back later.
10:13:58 <drdo> I won't even bother with this
10:14:11 <saurabhnanda> drdo: https://medium.com/@saurabhnanda/building-haskell-specifically-lens-library-in-a-low-memory-environment-5ef58ec294a2
10:14:37 <drdo> saurabhnanda: It doesn't even start compiling anything
10:14:39 <drdo> Gets killed
10:14:49 <drdo> There's no output at all from cabal-install before getting killed
10:22:26 <cocreature> drdo: if you can, compile on a different machine and copy the executable to your target machine
10:34:38 * hackage wai-middleware-json-errors 0.1.0 - Converts errors from plaintext to json  https://hackage.haskell.org/package/wai-middleware-json-errors-0.1.0 (seanhess)
10:46:12 <lambdamu> wow the fact that using any other IO capable monad than IO brings you a world of pain with regards to higher order function expecting IO returning functions is so bad
10:47:54 <lambdamu> I would have thought that at least base is covered with some alternative package but lifted-base is really meager
10:51:00 <lyxia> lambdamu: monad-control addresses some of the issues
10:53:43 <lambdamu> yes I think thats what lifted-base uses
10:57:15 <cocreature> for some reason I almost never seem to run into this problem
10:57:55 <cocreature> usually all I need is bracket and I use ExceptT very rarely so MonadMask works just fine
10:58:39 <lambdamu> I wanted to use Forein.Marshal.Utils:with with a custom monad stack
10:59:56 <lambdamu> Now I have to figure out how to use monad-control, looks abominal
11:00:42 <lambdamu> And all I wanted was region local pointer
11:03:37 <cocreature> :t \a f -> control $ \runInIO -> with a (runIO . f)
11:03:38 <lambdabot> error:
11:03:38 <lambdabot>     • Variable not in scope: control :: (t0 -> t1) -> t
11:03:38 <lambdabot>     • Perhaps you meant data constructor ‘Control’ (imported from Data.Char)
11:03:59 <cocreature> ^ lambdabot I think that should work
11:09:18 <ReinH> drdo: I've seen GHC take over 5GB of resident fwiw. I'd definitely recommend building elsewhere and shipping a binary.
11:09:49 <ReinH> lambdabot: the lack of ubiquitous MonadIO is indeed a pain :/
11:09:57 <ReinH> Er.
11:10:08 <ReinH> lambdamu: ^
11:10:23 <Tuplanolla> It's funny that the compiler solves harder problems to compile your program than your program ever will.
11:12:08 * hackage feature-flipper 0.2.0.0 - A minimally obtrusive feature flag library  https://hackage.haskell.org/package/feature-flipper-0.2.0.0 (toddmohney)
11:12:29 <kadoban> Tuplanolla: Hah, yeah
11:12:35 <lambdamu> ReinH: you mean that IO functions aren't lifted by default? That isn't nice, but the fact that higher order functinos break down is far worse, that can't be solved with an occasional liftIO
11:13:05 <ReinH> lambdamu: Yes, I mean IO in places where you can't just liftIO
11:13:12 <ReinH> like monad transformer stacks
11:13:23 <lambdamu> yep that sucks hard
11:18:08 * hackage feature-flipper-postgres 0.1.0.0 - A minimally obtrusive feature flag library  https://hackage.haskell.org/package/feature-flipper-postgres-0.1.0.0 (toddmohney)
11:31:48 <dolio> ReinH: 5 is small time.
11:31:58 <dolio> Try building vector's O2 test suite.
11:32:01 <dolio> Takes 20 GB.
11:35:18 <vektorweg1> any chance that ghc will be usable again in future, on machines with less than 8 gb ram? 
11:35:29 <kadoban> dolio: O.o wow
11:35:47 <kadoban> I use GHC fine on 4GB
11:36:06 <dolio> Yeah, it doesn't always take huge amounts of memory.
11:36:11 <kadoban> I even used to get by on 3GB, but it was kind of annoying very rarely.
11:36:16 <vektorweg1> i only have 4 gb here and cabal/stack builds crash quite often with oom. 
11:36:28 <kadoban> vektorweg1: Do -j1 when they do
11:36:32 <dolio> It depends a lot on the code it's building.
11:36:35 <koala_man> I have 3.7GB and I had to add swap
11:36:45 <kadoban> Yeah, it does depend what you're building.
11:36:48 <sm> vektorweg1: seems unusual, what are the packages that make it blow up ?
11:37:11 <sm> also how many cores do you have ? maybe that matters
11:37:20 <vektorweg1> e.g. everything snoyman has made. lol
11:37:31 <dolio> There are a lot of packages based on inlining everything to get performance, and that makes GHC use a lot of memory.
11:37:40 <hvr> vektorweg1: the matrix builder runs on VMs w/ 2GiB ram and it's able to build most packages
11:37:48 <Tuplanolla> I've had that problem in addition to `/tmp` running out of space.
11:37:52 <hvr> vektorweg1: otoh, it doesn't use stack
11:39:42 <vektorweg1> luckily, i hadn't installed new stuff recently, besides trying to build stack with cabal on an rpi2 (1 gb ram). it was impossible to build (oom) and with swap enabled it took literally forever.
11:39:45 <dolio> Well, not a lot of packages, maybe, but multiple commonly used packages.
11:41:36 <sm> vektorweg1: it'll take forever if swapping, that's normal. Use -j1, +RTS -M, and build fewer packages at once to stay out of swap
11:42:03 <vektorweg1> sm: thank you. i'll try.
11:42:08 * hackage haskell-src-meta 0.8.0.1 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.8.0.1 (GeoffreyMainland)
11:42:45 <shapr> GHC is way more fun after I upgraded from a dual i3 with 16gb to a quad xeon with 64gb
11:42:58 <sm> bah shapr 
11:43:01 <shapr> I can compile EVERYTHING! AT THE SAME TIME!
11:43:14 <shapr> sm: downside is that my laptop burns my leg sometimes :-(
11:43:15 <sm> will you compile my things ? :)
11:43:18 <capisce> compile all the things?
11:43:26 <maerwald> sm: hey my friend, how you doing
11:43:26 <shapr> sm: I was thinking about setting up that kind of server
11:43:56 <vektorweg1> wait? you got a decent processor, but a terrible cooling system?
11:45:27 <sm> hey there maerwald 
11:45:33 <sm> good and yourself ?
11:46:23 <maerwald> I try :D
12:00:17 <rgrinberg> How do you stream a response with snap?
12:00:22 <EvanR> i have gotten this far without a gaming rig... it would be ridiculous to finally get one so it can run GHC
12:00:55 <ocramius> rent an x2.large?
12:01:42 <EvanR> rent time on the main rame
12:01:52 <EvanR> frame. 
12:02:14 <EvanR> in the future we will be able to compile haskell programs on our phones!
12:05:55 <eschnett> distcc?
12:08:39 <EvanR> why does cabal take so much resources, i would think the compiler itself would take way more
12:10:33 <sm> does it ?
12:10:46 <sm> (cabal)
12:11:00 <EvanR> that is what it sounds like from reports of build failures on low end machines
12:11:27 <EvanR> you are much more likely to compile a single independent file with ghc than to cabal install dependencies
12:11:40 <geekosaur> the discussion I read semmed to be pointing at *stack* taking up the resources
12:11:45 <sm> cabal is usually running multiple ghc and ld processes, which I think are taking the resources
12:11:55 <geekosaur> (e.g. stuff builds in 2G VM on matrix which is cabal based)
12:11:55 <sm> I don't know if cabal/stack add much overhead beyond that
12:12:27 <EvanR> well if you scroll up they didnt even get to the compile stage
12:12:51 <sm> that's not very definitive, I was just wondering if someone had measured it
12:12:53 <EvanR> stack ...
12:13:09 <EvanR> i just keep hearing the same story in this channel and raspberry pi forums
12:13:37 <EvanR> i could ask the same question, why would stack take so much
12:13:52 <sm> it's not new, ghc builds and links of certain packages have always been expensive and cabal/stack run many of them at once, etc.
12:14:01 <ph88^> hey lyxia how did you know that the function required the amount of doubles at start ?
12:14:24 <EvanR> so if you ask it to do 1 think at a time you think it would totally eliminate the issue
12:14:58 <sm> dependency trees are getting bigger, types are getting crazier, GHC is getting more bloaty (hopefully 8.2 turns the tide!)
12:15:01 <ph88^> lyxia, i mean how did you know the file shoudl start with the number of elements in the list ..
12:15:31 <geekosaur> 8.2 reported smaller memory for many things but larger memory for a few. was still being tracked down last I heard
12:16:08 <sm> even a single build can exceed 1G. It helps to use +RTS -M, or to build a few dependencies at a time, not all of them
12:16:17 <sm> there really needs to be a FAQ on this
12:16:47 <sm> come to think of it, there needs to be a haskell FAQ
12:18:12 <EvanR> im not sure what would be on it
12:18:32 <EvanR> everyone here has weirdo one off questions
12:18:34 <sm> probably maintained using lambdabot, since most of the answers are in this room
12:18:49 <sm> there are plenty of recurring questions
12:19:57 <sm> I remember trying lambdabot's quote db for this, come to think of it
12:20:03 <mnoonan_> this is pretty darn close: http://dev.stephendiehl.com/hask/
12:20:48 <Tuplanolla> I can't find anything in there since it's so long.
12:21:24 <ph88^> is there a library that analyses my haskell code and randomly puts bang patterns and measures how it can get the best performance ?
12:21:49 <johnw> ph88^: not that I know of
12:22:12 <Tuplanolla> Besides the language extension table was subtly wrong last time I checked.
12:22:16 <cocreature> there was some tool that uses evolutionary algorithms to infer strictness annotations iirc which is somewhat close
12:22:40 <Tuplanolla> For example `MonoLocalBinds` is not marked benign, but other extensions that implicitly enable it are.
12:22:58 <sproingie> random might not work so well where laziness affects semantics
12:23:46 <sm> @quote faq-help
12:23:46 <lambdabot> FAQ says: faq-help: @remember FAQ topic: some info , @forget FAQ topic: some info , @quote topic:
12:23:54 <geekosaur> ph88^, you could check don stewart's web page, he did some stuff on that before disappearing into the depths
12:24:30 <geekosaur> (cocreature is in fact referring to one of dons's tools)
12:24:36 <foojin> What alternative is there to takeWhile (/=Nothing) if the type wrapped in maybe doesn't belong to Eq?
12:24:39 <geekosaur> I think
12:26:03 <Clint> foojin: the opposite of isNothing?
12:26:08 <geekosaur> :t isJust
12:26:09 <lambdabot> Maybe a -> Bool
12:26:28 <geekosaur> which is a pattern match not an Eq
12:26:31 <ph88^> what happened to don stewart ?
12:26:52 <geekosaur> went to work for Standard Chartered, stopped having time/energy for anything else
12:27:20 <ph88^> looks like he's working for facebook now
12:27:38 <foojin> Clint, geekosaur: Thanks.
12:27:48 <geekosaur> possible, I stopped paying attention when he was reduced to posting pictures of sunsets and nothing else >.>
12:28:05 <cocreature> geekosaur: I’m pretty sure I’m not. it was some icfp paper last year
12:28:20 <ph88^> who doesn't like sunsets :D
12:28:32 <cocreature> that’s the one I was talking about http://dl.acm.org/citation.cfm?id=2976009
12:28:36 <ph88^> well i found his software ... it's quite a long list ^^  https://donsbot.wordpress.com/software/
12:29:03 <ph88^> is that what i think it is ?
12:29:04 <geekosaur> ok. I know dons was working on stuff like that earlier. there was one that evolved a list of optimization flags, and I thoguht there was some work on evolving strictness
12:29:05 <ph88^> A PAYWALL ?!
12:29:16 <sproingie> let's hope facebook gives him more time in the community
12:29:33 <cocreature> ph88^: scihub helps with that :)
12:30:12 <ph88^> i think i've seen this before actually :P
12:30:36 <ph88^> there was also talk on automatic parallelism (not in this paper though)
12:30:55 <ReinH> google scholar also usually helps with that
12:31:24 <geekosaur> acm survives on payment for paper access, I'm more willing to deal with their paywall than, say, elsevier (best pronounced "(go) elsewhere")
12:32:28 <cocreature> selling articles people give you for free is a pretty shitty business model
12:32:51 <ptek> edwardk, may I ask you something about machines?
12:33:25 <ph88^> they gonna take over the world
12:33:36 <EvanR> you mean brilliant business model?
12:33:58 <ReinH> I am also more willing to deal with ACM's paywall than elsevier's. I am still not willing, of course.
12:35:04 <ptek> edwardk, I have just starting to understand how it works and wonder if there is a way to clone a stream so it produces two. What I would like it to do, is when a new data comes in, I want to calculate a diff to the previous state, yield it, and save the new state to the disk
12:35:56 <ptek> edwardk, is machines a right tool for this at all?
12:35:57 <geekosaur> see, elsevier is even more guilty of that one. acm it happens because acm lets the author(s) retain rights and distribute as they wish
12:36:46 <ph88^> this is how they did floating point in the old days https://upload.wikimedia.org/wikipedia/commons/4/4c/Z3_Deutsches_Museum.JPG
12:37:15 <ReinH> geekosaur: yes, the thing that you just said is the reason I said the thing that I just said. :)
12:37:17 <cocreature> geekosaur: oh I am in no way saying that elsevier is better than acm. but that doesn’t mean I’m going to support acm’s business model
12:37:20 <Tuplanolla> I have a bigger problem with fringe libraries like CiNii, because their papers don't end up in the likes of Sci-Hub and universities don't bother buying access.
12:40:47 <EvanR> ph88^: did they have NaN
12:41:16 <ph88^> EvanR, no they got all numbers in there
12:41:39 <sm> is there a way to list lambdabot's saved quotes ?
12:41:55 <ph88^> storage was in the rest of the building
12:48:54 <ph88^> how can i encode a conduit/pipe/stream/list of Double into a file so that each Double takes 8 bytes ?
12:49:27 <ph88^> when i used this function  https://hackage.haskell.org/package/binary-0.9.0.0/docs/Data-Binary.html#v:encodeFile   DB.encodeFile "singleDoubleEncode.dat" [0 :: Double]    the file is 14 bytes, not 8 bytes as i want
12:49:56 <lyxia> ph88^: I look at the implementation of Binary
12:50:24 <ph88^> lyxia, i was looking too .. but i couldn't find it .. where exactly ?
12:50:31 <ph88^> good thing you're back :P
12:53:39 <lyxia> ph88^: http://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary.html#t:Binary find Binary [a], click on Source
12:54:44 <ph88^> right .. i wasn't using a list with conduitDecode originally .. but i can imagine it would convert to a list kind of ^^
12:56:38 <edwardk> ptek: what keeps you from defining a stream that does something like start = do x <- await; yield x; {- record x to disk }; diff x; diff x = do y <- await; yield (y - x); {- record y to disk -}; diff y
12:57:18 <edwardk> ptek: that one 'ProcessT' converts from inputs to differences and records the values to disk
12:58:03 <edwardk> ReinH: i give the ACM their pound of flesh every year. can't recall the last time i gave one to elsevier
12:59:16 <ph88^> lyxia, that conduitDecode is implemented as   conduitGet get   -- where get is the function from Data.Binary .. but in this case i think it's called on a single Double in the stream .. so i still don't get what is going wrong
12:59:17 <ReinH> ACM actually provides some value.
13:00:38 <ptek> edwardk, that looks promising. Thank you. I thought await and yield work only with Plan. Will have to understand the types...
13:00:53 <edwardk> that builds a plan. plans are used to build machines
13:00:59 <ph88^> lyxia, when i do   DB.encodeFile "singleDoubleEncode.dat" (0 :: Double)   i still get a 13 byte file o_O    ok that explains why conduitDecode is going wrong as well ..  
13:01:03 <edwardk> i think it is 'construct' it has been a while
13:01:52 <ptek> ah. I think I understand... I'll try and see where it leads me
13:02:49 <lyxia> ph88^: http://hackage.haskell.org/package/binary-0.8.5.1/docs/src/Data-Binary-Class.html#line-667 with encodeFloat :: RealFloat a => Integer -> Int -> a
13:02:57 <lyxia> This encoding looks insane
13:03:27 <lyxia> ph88^: heh https://github.com/kolmodin/binary/issues/69
13:06:30 <kamyar> Hello friends
13:06:34 <EvanR> is there a terrible typeclass trick i can use to make an action m (<something> a) where the <something> i get back can be used as either A a or B a, stays polymorphic like number literals until you use them somewhere
13:06:46 <kamyar> I have a ambiguous question about Haskell performance
13:06:48 <ph88^> lyxia, lol "absolutely batty"
13:06:52 <ph88^> ezyang reported it
13:07:18 <kamyar> I have written a part of my code in both Python (Flask) and Haskell (SCotty)
13:07:33 <kamyar> This code uses Redis as backend store
13:07:48 <jle`> EvanR: um, try showing us a concrete example
13:07:51 <kamyar> Unbelievably Python code is much faster than Haskell!
13:08:02 <lyxia> EvanR: wrap a universally quantified type in a newtype
13:08:25 <kamyar> using ab (Apache Benchmark) Python response is about 450 req/sec but haskell 137 req/sec
13:08:42 <kamyar> What may make Haskell code slower?
13:08:53 <kamyar> instead it is native compiled 
13:08:59 <kamyar> in compare with python's interpreter
13:09:11 <EvanR> imagine declaring a variable, then it can be used as an Expr or as an LVar (C lingo)
13:09:18 <kamyar> sorry! Alghough it is native compiled
13:09:35 <cocreature> kamyar: there are about a million different things that could make it slower and without seeing code it’s pretty much impossible to tell what is responsible in your case
13:09:53 <kamyar> cocreature: Ok let em send my code
13:10:17 <cocreature> it might just be some mistake/ineffiency in your own code, it might be the redis backend doing more serialization/deserialization, it might be the web framework doing things differently, …
13:10:22 <EvanR> only LVars can be assigned, but you cant add LVars to other Expr because they have two different types
13:10:38 <kamyar> http://lpaste.net/355971
13:10:56 <kamyar> Note that I just test /locations (post and get) in both codes
13:11:23 <kamyar> IN this case, I am not using database, I just get a ready token and test the code
13:11:39 <EvanR> lyxia: universal?
13:11:40 <kamyar> So repository is not used
13:11:54 <n_blownapart> hi in haskell-vim-now the code converts over to math symbols while in insert mode, just by hovering over the characters or lines. how do you set this on one or the other?
13:12:03 <cocreature> loadLocations definitely calls redis so I’m not sure why you are saying you’re not using the database
13:12:51 <kamyar> cocreature: What seems bad in my code?
13:14:08 * hackage streaming-binary 0.3.0.0 - Streaming interface to binary.  https://hackage.haskell.org/package/streaming-binary-0.3.0.0 (MathieuBoespflug)
13:15:56 <kamyar> cocreature: I use redis but I meant RDBMS by database
13:16:04 <kamyar> cocreature: I use redis but not postgresql
13:18:06 <kamyar> cocreature: Still inspecting my  code?
13:18:17 <cocreature> kamyar: step 1: make sure you are actually doing the same thing in your python code and Haskell code, e.g., make sure that you are querying redis in the same way. step 2: profile your Haskell code to figure out what is slow. step 3: figure out why it is slow
13:19:02 <cocreature> kamyar: fwiw using Redis.mget instead of mapM Redis.get will probably be faster but it’s hard to see if that’s the culprit
13:19:44 <kamyar> cocreature: The codes are exactly the same and redis commands are the same, I can even send you the python code
13:20:21 <ph88^> lyxia, when you recommended writing a custom get .. how would i proceed in doing that? I think it would have to be an instance of Binary, but an instance Binary Double already exist ..
13:20:39 <Gurkenglas> Is there some way to use ArgumentDo and have intero work with it even though it hasn't been accepted into GHC?
13:20:42 <cocreature> ph88^: newtype?
13:21:05 <ph88^> actually i don't think i will have to write that instance .. i just found this  https://hackage.haskell.org/package/data-binary-ieee754-0.4.4/docs/Data-Binary-IEEE754.html#g:1
13:21:38 <kamyar> cocreature: Any further guide?
13:21:53 <cocreature> kamyar: I already told you 3 things you should do. have you tried those?
13:22:18 <kamyar> cocreature: How to do profiling? Which tools?
13:23:00 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
13:24:20 <ph88^> "cereal can be considered deprecated and new apps should use binary instead"   eeehhh ok
13:24:42 <ph88^> https://github.com/kolmodin/binary/issues/79#issuecomment-122597458
13:24:56 <EvanR> wouldnt be surprised to see "binary can be considered deprecated use cbor instead" ... though its not ready
13:26:35 <kamyar> cocreature: My problem is that the code is not so complicated! Rather simple! HOw can be so slow? I have got disappointed!
13:26:57 <kamyar> cocreature: Profiling is effective for complicated long code
13:28:01 <cocreature> kamyar: I’m not sure what you are expecting to hear from me. I’ve told you several reasons why your code could be slower and how you should investigate what is causing the problem. if it helps, it is unlikely to be related to Haskell as a language
13:29:11 <kamyar> cocreature: I expect your experience for example you may guess the bottleneck is JSON, or CBOR or something else here
13:29:28 <kamyar> cocreature: Or is there any compilation switch to make the program faster?
13:29:48 <cocreature> kamyar: yes, compile with -O2
13:30:02 <kamyar> cocreature: What is it?
13:30:25 <mauke> a compilation switch to make the program faster
13:30:34 <cocreature> -O is for optimizations, 2 is the optimization level (2 is the maximum supported by GHC)
13:30:43 <EvanR> think of -O2 as ludicrous speed
13:32:20 <ph88^> ah that's nice kamyar you are using Scotty too :)
13:32:37 <ph88^> kamyar, do you know how to serve up a static file? i would like to know
13:33:44 <kamyar> ph88^: Up to know I have not used it but I guess it is not so difficult
13:34:28 <n_blownapart> On haskell-vim-now, how do you control scroll-over toggling between math code and symbols? 
13:34:48 <n_blownapart> in insert mode ^^
13:36:21 <n_blownapart> I want to turn the symbols off altogether if possible
13:36:43 <ph88^> does it still make sense to use redis with haskell ? haskell can keep the values in memory itself, no ?
13:37:13 * hackage streaming-binary 0.3.0.1 - Streaming interface to binary.  https://hackage.haskell.org/package/streaming-binary-0.3.0.1 (MathieuBoespflug)
13:39:08 * hackage wai-middleware-json-errors 0.1.1 - Converts errors from plaintext to json  https://hackage.haskell.org/package/wai-middleware-json-errors-0.1.1 (seanhess)
13:39:55 <sm> @quote FAQ commands
13:39:56 <lambdabot> FAQ says: Let's start a haskell faq. Commands: "@quote FAQ question", "@remember FAQ question ? answer", "@forget FAQ question ? answer"
13:39:57 <kamyar> ph88^: Yes! Redis is much more powerful
13:40:14 <sm> @remember FAQ To build/link on low memory machines: use -j1, +RTS -M500m -RTS, and/or build fewer dependencies at once. Avoid swap, it's too slow.
13:40:14 <lambdabot> It is stored.
13:40:23 <ph88^> kamyar, is it faster ?
13:40:29 <sm> @quote FAQ memory
13:40:29 <lambdabot> FAQ says: To build/link on low memory machines: use -j1, +RTS -M500m -RTS, and/or build fewer dependencies at once. Avoid swap, it's too slow.
13:41:29 <Tuplanolla> How do you list all answers, sm?
13:41:44 <sm> I haven't figured out if that's possible, Tuplanolla
13:41:57 <Tuplanolla> That would be a good thing to do before starting.
13:42:01 <sm> other than run @quote FAQ many times
13:42:28 <sm> there are two or three FAQ answers right now
13:42:49 <sm> (upper case to distinguish them from random use of "faq" tag)
13:44:14 <ptek> edwardk, I think I understand now how it works. Thank you a lot!
13:47:03 <sm> one could also grep channel logs for "@remember FAQ"
13:48:16 <fnurglewitz> &%/
13:48:18 <fnurglewitz> 7
13:59:53 <dmwit> sm: ?quote FAQ ^question will only match if that's the actual question (as opposed to if that question matches in the middle of some other answer).
14:06:42 <ph88^> lyxia, i got it to work now :)   B.writeFile "singleDoubleEncode.dat" (DB.runPut (DB.putFloat64be (2 :: Double)))   ..  now onto the conduit :P
14:08:08 <sm> dmwit: thanks, I was thinking that @quote takes a case insensitive regexp. Doesn't seem to support a lot of regex constructs though
14:08:44 <sm> or I did it wrong
14:12:54 <geekosaur> it's using TDFA so don't expect PCRE extensions to work. may also only do POSIX BRE
14:13:26 <sm> there's no easy way to list quotes, right 
14:13:39 <thang1> Aww, no PCRE?
14:13:44 <thang1> I like PCRE, it's like black magic
14:15:41 <geekosaur> ok, looks like it's ERE with some "GNU extensions" (mostly lifted from BSD vi)
14:16:17 <sm> like http://hledger.org/manual.html#regular-expressions maybe
14:18:25 <ph88^> what's the right function to remove spaces and \r\n from left and right of bytestring ?
14:19:09 <glguy> There probably isn't one
14:20:01 <glguy> bytestrings aren't text. If you were using text the answer would be 'strip'
14:20:20 * shapr strips a bytestring down to its bare essentials
14:20:25 <ph88^> hhmm ok
14:20:48 <ph88^> how can i then remove 3 specific bytes from the left and right?  0x20 0x0A 0x0D
14:21:38 <glguy> I'd start with looking at the haddocks for Data.ByteString to see if any of the functions look like they will help you
14:21:44 <ph88^> okidoki
14:21:45 <glguy> ?hackage bytestring
14:21:45 <lambdabot> http://hackage.haskell.org/package/bytestring
14:21:49 <mauke> is there a dropWhile?
14:23:24 <ph88^> ye there is a dropWhile
14:24:20 <thang1> > dropWhile (<5) [1..10]
14:24:22 <lambdabot>  [5,6,7,8,9,10]
14:25:47 <ph88^> ye just thinking about how to drop from the end
14:26:50 <ph88^> well there is this .. https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Unsafe.html#v:unsafeLast
14:29:56 <thang1> How to drop from the end? Because of how a list is structured, you can't really think about doing things backwards
14:30:13 <thang1> > dropWhile (<5) $ reverse [1..10] -- this should work just fine, though :p 
14:30:15 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:30:15 <iqubic> So I have this issue where I can't use arrays.
14:30:38 * hackage xlsx 0.6.0 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.6.0 (KirillZaborsky)
14:30:48 <glguy> thang1: ph88^ is working with bytestring rather than list, so dropping from the end is as easy as from the front
14:30:59 <thang1> > dropWhile (>5) $ reverse [1..10] -- I can math, trust me
14:31:01 <lambdabot>  [5,4,3,2,1]
14:31:06 <thang1> glguy: oh, good t'know
14:33:50 <AerialBoundaries> first Haskell code in a year: https://paste.pound-python.org/show/mmTtntt5TtKbVuL6WX3z/
14:34:03 <AerialBoundaries> 1 Dimensional Cellular automata as described in http://mathworld.wolfram.com/ElementaryCellularAutomaton.html
14:35:39 <AerialBoundaries> produces this output: https://paste.pound-python.org/show/Qq2k9xeNy2bdbjpnEYqn/
14:43:19 <ph88^> glguy, i wrote this function for trim https://bpaste.net/show/49d53a4a853e .. but now i find out that i can't use data constructor PS :(
14:43:43 <ph88^> pretty picture AerialBoundaries :)
14:44:38 <glguy> ph88^: No, you don't need to anything like that
14:44:44 <glguy> ph88^: Look at spanEnd
14:45:00 <ph88^> glguy, i thought spanEnd gave me too much functionality
14:45:34 <glguy> ph88^: OK, just keep the functionality you need, ignore the rest
14:45:38 * hackage pipes-extras 1.0.10 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.10 (GabrielGonzalez)
14:46:47 <AerialBoundaries> ph88^: thank Sierpinski
14:46:56 <AerialBoundaries> or Wolfram, or both
14:47:03 <thang1> glguy: what about breakEnd?
14:47:06 <AerialBoundaries> I don't even understand the maths behind it :)
14:47:19 <glguy> thang1: 6 of one, half dozen the other
14:47:21 <ph88^> glguy, i will try this    fst $ spanEnd isSpace (dropWhile isSpace bs)
14:47:40 <thang1> good point. Didn't see that break returned a tuple at first
14:50:42 <kamyar> How can I make a Data.Map from 2 lists, first keys and the second values
14:50:53 <kamyar> Something like zip but with Map
14:50:54 <Tuplanolla> You `zip` them first, kamyar.
14:51:08 * hackage turtle 1.3.5 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.3.5 (GabrielGonzalez)
14:51:13 <kamyar> :t zip
14:51:14 <lambdabot> [a] -> [b] -> [(a, b)]
14:51:15 <Eduard_Munteanu> :t M.fromList
14:51:16 <lambdabot> Ord k => [(k, a)] -> M.Map k a
14:51:44 <Tuplanolla> :t M.fromList .: zip
14:51:45 <lambdabot> Ord k => [k] -> [a] -> M.Map k a
14:52:00 <EvanR> is there a way to get a Show instance for an existential type that has a Showable type in it
14:52:13 <glguy> Not without writing it by hand
14:52:27 <EvanR> ok writing it by hand, and using the Show instance of the inner thing?
14:52:29 <glguy> (or maybe there's some TH out there)
14:52:41 <ph88^> glguy, i get this error when i try to use spanEnd   https://bpaste.net/show/d434be1fb6db
14:53:18 <glguy> ph88^: OK, because you're using Data.ByteString.Char8 instead of Data.ByteString, then you need to work with Char instead of Word8
14:53:22 <EvanR> by hand... if type is not Showable... "?", else show it
14:54:02 <glguy> It's showable since you said the existentially quantified type variable had a show instance constraint
14:54:04 <Eduard_Munteanu> That won't work.
14:54:23 <EvanR> it doesnt
14:54:46 <glguy> Oh, then you'd need to add one
14:54:50 <Eduard_Munteanu> You can't do anything with it then.
14:55:16 <EvanR> you know what would be cool, compiler gives you a default instance of Show when you use the thing at a type which has no Show instance
14:55:32 <EvanR> what is the default, you tell it
14:56:14 <EvanR> [E 1, E Bool, E <unshowable>]
14:56:39 <EvanR> er E 1, E False
14:57:21 <ph88^> glguy, thx it works now .. except when i put a type signature i get this  https://bpaste.net/show/2c9e267fb0ce  i already tried to move the function around the file to another place
14:57:48 <glguy> ph88^: case matters in Haskell
14:58:02 <Eduard_Munteanu> EvanR, you can do that with a different type class or a GADT
14:58:14 <EvanR> oh really
14:58:52 <ph88^> don't see i did anything wrong with the case, function name match and type seems to be ok too
15:00:00 <Eduard_Munteanu> data JustShow = Show a. Showable a | NotShowable
15:00:56 <EvanR> pretty invasive... but works
15:01:31 <EvanR> so its like pairing each element with a string
15:02:33 <StoneToad> EvanR: isn't there module on hackage that generates show instances using TH or one of the generic programming things?
15:02:38 <StoneToad> autogenerates*
15:02:44 <Eduard_Munteanu> With the right extensions, you could get a    class JustShow a where justShow :: a -> String; instance Show a => JustShow a where justShow = show; instance JustShow a where show _ = "<unshowable>"
15:03:10 <EvanR> whats that overlapping instances
15:03:10 <StoneToad> err, no that was pretty printer
15:03:12 <Eduard_Munteanu> s/where show/where justShow/
15:03:38 <Eduard_Munteanu> Overlapping, undecidable too I think
15:03:48 <EvanR> yeesh
15:03:49 <ph88^> i have this case    tcol' = deviceDefault tcol $ \d -> case d of { OmniBer -> 1;   SJ300E -> 1    }    however it's not complete, the type has 2 more alternatives .. why don't i get an error on this ?
15:05:06 <geekosaur> what warnings do you have turned on? (not an error by default, you'd need -Werror and it affects all warnings)
15:12:52 <ph88^> don't think i have that turned on .. working in ghci with default setting
15:14:11 <geekosaur> then that's why you got nothing. -Wincomplete-patterns is what you want to enable, but -Wall is often a good idea
15:15:00 <geekosaur> or just -W which omits some warnings that annoy people with some development styles (notably -Wmonomorphism-restriction and -Wmissing-import-lists)
15:16:05 <ph88^> oki
15:24:27 <Philonous> It's a bit weird that texts (even introductory ones) use this vertical style of writing down inference rules (sometimes they just call it "natural deduction") without ever introducing it (rigorously or otherwise). Is there a place where it is properly defined? I'd like to see it really nailed down, so that if in doubt I can just keep applying definitions until I end up with axioms. 
15:25:43 <Tuplanolla> What's missing on Wikipedia, Philonous?
15:27:54 <Philonous> Tuplanolla, I've been looking through the page of natural deduction, but can't seem to find what the notation actually denotes.
15:30:01 <EvanR> Philonous: i noticed this is in chapter 2 of practical foundations for programming languages by harper
15:30:22 <thang1> "if you have everything on the top bar, you're allowed to replace it with the bottom bar"
15:30:45 <EvanR> but they dont call it natural deduction. and in fact theres something else called that making it hard to find by that name. and wikipedia sucks
15:31:06 <EvanR> in chapter 2 of that book they call it inference rules
15:31:06 <thang1> it's just a style of writing logical proofs
15:31:09 <Philonous> EvanR, I've been watching one of his lectures, "Type Theory Foundations', and he's been hand-waving so much I was wondering whether he'd accomplish lift-off. 
15:31:17 <Tuplanolla> The answer depends on your metatheory, Philonous.
15:31:19 <Philonous> I seriously don't have any idea what he's talking about
15:31:21 <thang1> there's tree style proofs, fitch proofs, hilbert style proofs, etc
15:31:33 <thang1> They're all the same thing, just different notational systems for logic proofs
15:31:46 <Tuplanolla> For example in calculus of constructions, proofs in the form of natural deduction are lambda terms.
15:32:11 <thang1> stack build
15:32:14 <EvanR> Philonous: note this is introduced in chapter 2... *after* chapter 1 which talks about syntax and substitution
15:32:16 <thang1> damnit, wrong window
15:32:42 <Tuplanolla> That interpretation makes assumptions arguments.
15:32:47 <EvanR> but in logic, it doesnt seem to have anything to do with substitution its used as a proof notation
15:33:10 <thang1> Well it does use substitution, just not really substitution that you think of
15:33:26 <EvanR> is this a form of "anything is substitution if you look at it right"
15:33:33 <thang1> For instance if I have a proof and I use an internal IP and I assume "P" and assume "C"
15:33:36 <thang1> I have a P, and I have a C
15:33:52 <thang1> so my next line can be P^C (insert logic rule of inference that allows me to write this down)
15:34:23 <EvanR> i tend to see   A -> B True, A True <BAR> B True as not a substitution.
15:34:57 <EvanR> it says, if A -> B is true, and A is true, then you can conclude B is true
15:35:14 <Philonous> Yes, I have gathered as much. It makes a lot of intuitive sense. But at some point I always find myself with an edge-case where I wonder what operations are allowed and which aren't. At that point I wish I had a formal grammar for the valid terms and formal derivation rules that I could check
15:35:15 <thang1> Right, but technically it is a substitution if you write it down in a proof :p
15:35:16 <EvanR> where True doesnt mean anything necessarily
15:35:22 <EvanR> :|
15:35:42 <EvanR> Philonous: well, chapter 2 of that book...
15:36:09 <Philonous> EvanR, Oh, then I misunderstood you earlier.
15:36:13 <Philonous> Thanks, I'll check it out
15:36:19 <thang1> Because you started with A -> B, and with "A is true", and then replaced both with "B is true" in the final line of the proof
15:37:23 <Tuplanolla> You could explain the rules of natural deduction using natural deduction, but then you'd be staring at a fixed point looking for its origin, Philonous.
15:37:46 <thang1> That's a good way to state it, Tuplanolla :p
15:37:51 <EvanR> talking about the mechanisms of doing a proof by substitution is like operational semantics
15:38:10 <EvanR> thats really a lot of extra baggage for Philonous's actual concern
15:38:46 <thang1> Right. The only thing that's really necessary is "if you have the stuff on the top, the rule denoted by the bar allows you to write down the stuff on the bottom"
15:38:56 <EvanR> its interesting if you go back to 1870 Fege's Begriffschrift, hes uses a similar notation for a similar purpose in proofs
15:39:13 <EvanR> thang1: allows you to write down....
15:39:26 <EvanR> now its almost imperative programming :)
15:39:37 <Philonous> thang1, Yes, and then the caveats come, and it ends up not being that clear at all 
15:39:40 <tieTYT> asking this here because elm channel is dead: It’s my impression that elm commands are not pure and haskell’s IO works completely differently.  Elm doesn’t have a pure core and imperitive shell.  Is that a correct assessment? 
15:40:39 <thang1> Philonous: what caveats?
15:41:48 <Philonous> Well, one thing that came up is that you can only use assumptions in the same sub-proof, which is why they are labeled with unique names (or numbers).
15:42:59 <thang1> Philonous: Only for proof by contradiction (IP). If you use a CP proof you end up with assumption -> result and then as long as you continue with assumption -> result you can use anything inside that first CP proof
15:43:27 <thang1> (of course, that answer assumes the "normal" logic you learn in a basic logic course...)
15:43:46 <EvanR> which is only one application of this notation
15:44:11 <Philonous> You mean classical logic?
15:45:06 <thang1> Yes, classical logic. It also applies to whichever logical system happens to also use that same rule; but that is a bit of a useless statement :p
15:46:26 <thang1> You have any idea what logical system and/or application the speaker is using the notation for, Philonous?
15:46:45 <Philonous> Intuitionistic Logic 
15:51:03 <thang1> https://en.wikipedia.org/wiki/Intuitionistic_logic does this not make sense?
15:57:03 <jle`> what do yall use for kind variables other than k ?
15:57:22 <Eduard_Munteanu> k, l, m
15:57:44 <jle`> makes sense
15:57:53 <Philonous> thang1, I'll have to continue this tomorrow, thanks for the help
15:58:08 <thang1> no problem. Glad I could help by getting shot down by everyone else for being only partially correct :p
16:02:32 <johnw> thang1: that's the #haskell effect, totally normal
16:04:21 <Taneb> Eduard_Munteanu, that's my third favourite airline
16:06:05 <thang1> johnw: I'm used to it in general 'cause I tend to speak before I've fully double checked I'm using the right words for things :p
16:06:27 <johnw> thang1: same here
16:07:32 <hpc> thang1: the secret is that most things that happen here are only partially correct
16:08:08 <thang1> Hmm... does that mean knowledge is curried?
16:08:18 <hpc> thang1: intuitionistic logic and constructive math in particular being pretty new and new stuff is being discovered regularly
16:08:24 <hpc> heh
16:09:20 <thang1> ooh neat, didn't realize they were that new
16:13:28 <thang1> All the fun stuff looks like it's just around the corner. Dependent types, linear types, (insert other funky types here), new logical systems, etc... I reallydo enjoy this field
16:13:38 * hackage json-feed 0.0.2 - JSON Feed  https://hackage.haskell.org/package/json-feed-0.0.2 (fozworth)
16:31:57 <johnw> thang1: and all of our new stuff is actually decades old, we've just been waiting for it to become available :)
16:32:25 <thang1> True. The never ending cycle of waiting and wanting.. Science is cruel like that :p
17:48:00 <alexv119> Is there an opposite of Prism? With `Prism' s a` you always can construct a value of `s`, but getting value `a` is partial. So, is there a thing that works other way around? With `AntiPrism s a` you can always get value `a`, but construction of `s` is partial?
17:51:03 <thang1> alexv119: is it not sufficient to turn the prism around with re to make a getter?
17:51:41 <c_wraith> alexv119: that's a prism with its arguments reversed.
17:51:57 <thang1> oooh, neat
17:52:05 * thang1 knows nothing about lens
17:53:18 <c_wraith> A Prism is an almost-isomorphism.  It's partial in one direction, total in the other.
17:54:02 <c_wraith> If you are asking about something total and partial in the opposite directions as a Prism...  It's still a Prism, just in the other direction.
17:54:36 <alexv119> c_wraith: Oh, I was thinking about it. The types fit, but I though it's weird. Thanks!
17:56:22 <thang1> Now I gotta know, is s t a b on purpose?
17:56:49 <thang1> Or is there some semantic meaning behind the 1 letter words other than "heh stabby stab"?
17:57:16 <c_wraith> No and yes.
17:58:01 <c_wraith> 4 type variables are required, and they naturally pair off.  a and b are the natural choices for one pair.
17:58:14 <c_wraith> s and t pair off nicely as well.
17:58:48 <c_wraith> But it wasn't unnoticed that they spell stab, and that wasn't found to be a reason to find different letters
18:00:16 <thang1> fair enough :p
18:01:23 <geekosaur> also note the profunctor stuff... p a b s t
18:01:47 <geekosaur> 's t a b' might be a side effect >.>
18:01:51 <c_wraith> It's hard to believe that stuff ever won a blue ribbon.
18:02:41 <geekosaur> oh, it prolly did... where that meant 'honorary mention' and the top was a gold ribbon, or something.
18:03:18 <c_wraith> Actually, it was a first prize.  But it was over a hundred years ago.  The recipe was different, the process was different, the competition was different...
18:03:30 <c_wraith> Basically nothing in common with the current state
18:04:04 <c_wraith> I lived almost 10 years in Portland.  You're required to learn these things.
18:04:42 <thang1> *someone mentions portland* oh hey, #represent
18:05:59 <thang1> It's a shame pabst has dropped so far, but... cheap as hell and they absolutely own that super small niche in the market for "need alcohol, have no money, want to look classier than budlite"
18:18:21 <glguy> does pdx have a Haskell user group?
18:18:46 <thang1> I think it does, but it's pretty dead
18:19:23 <thang1> beaverton has a somewhat active-ish brand new FP meetup group but they're going over some weird write a scheme in 48 hours, which backfired a bit, so now they're doing something else, idk :p
18:19:38 * hackage uri-bytestring 0.2.3.2 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.3.2 (MichaelXavier)
18:19:49 <thang1> http://pdxfunc.org/ closest thing I know of is this
18:20:35 <n_blownapart> hi I'm having a hard time getting stack to work properly. please see this github issue and my gists (the issue is combined with haskell-vim-now issue I'm having). thanks https://github.com/begriffs/haskell-vim-now/issues/250
18:20:54 <n_blownapart> I have a 32bit debian machine
18:22:39 <n_blownapart> begriffs, hi I'm here to haunt you as well. just posted the issue on github above ^
18:22:56 <n_blownapart> https://github.com/begriffs/haskell-vim-now/issues/250
18:24:31 <n_blownapart> I can't get past stack now to try out the ide. I was deleting stack manually so probably got in big trouble
18:33:08 * hackage Euterpea 2.0.3 - Library for computer music research and education  https://hackage.haskell.org/package/Euterpea-2.0.3 (DonyaQuick)
18:36:56 <iqubic> Let's say I have a parsec parser, and I want to take input until I have an input that passes the parser. How would I do that.
18:36:59 <iqubic> ??
18:42:15 <Gurkenglas> The amount of input a parser takes is already decided by the parser
18:43:45 <geekosaur> they left
19:09:08 * hackage dependent-sum-template 0.0.0.6 - Template Haskell code to generate instances of classes in dependent-sum package  https://hackage.haskell.org/package/dependent-sum-template-0.0.0.6 (RyanTrinkle)
19:27:38 * hackage HSoM 1.0.0 - Library for computer music education  https://hackage.haskell.org/package/HSoM-1.0.0 (DonyaQuick)
19:29:01 <unknownln> How can I flatten an unboxed Vector (Word8, Word8, Word8, Word8) to an unboxed Vector Word8 without copying any data?
19:30:22 <unknownln> (Without copying any of the Word8s I mean, you'd have to copy the pointer to the data and whatnot of course)
19:30:55 <glguy> unknownln: You don't
19:31:50 <glguy> In the unboxed case, a Vector (Word8, Word8, Word8, Word8) is represented with 4 separate Vector Word8
19:32:05 <unknownln> Ah
19:32:21 <kebertx[m]> My understanding of the `ST` monad is that you can "thaw" data to do mutable state-y stuff with it, but to get haskell values out you need to "thaw" it, meaning the result is copied into new memory rather than changing the originals
19:32:49 <unknownln> can I convert a unboxed Vector Word32 to an unboxed Vector Word8 the way I'm thinking here? That'd work for me too
19:33:03 <pacak> thaw-unthaw will copy stuff.
19:33:20 <pacak> There are unsafe versions, but using them can result in obscure bugs.
19:33:58 <pacak> like 2 + 2 = 5 bugs.
19:34:08 <kebertx[m]> Yeah, that makes more sense... "freezing" is the step that would be able to share memory with the ST thread
19:39:11 <glguy> unknownln: It's possible but not supported
19:42:27 <unknownln> Maybe I'm going about this wrong; here's what I'm actually doing. So I'm generating an image with repa, and afterwards I need to convert it to a JuicyPixels image. With repa of course I can only store one value per index, so that leaves me with an RGBA tuple or an RGBA Word32, JuicyPixels expects a vector of Word8 though (and a Storable one at that, not Unboxed), so I'm trying to figure out what the best way to convert to
19:42:28 <unknownln> that is
19:43:06 <unknownln> And by best I mean most efficient in this case
19:45:04 <EvanR> an iffy combination of unsafeFoos followed by a prayer to cthulu
19:46:04 <superobserver[m]> Oh wow. So IRC was finally bridged here. Cool.
19:47:50 <pharaun> ?
19:48:41 <superobserver[m]> pharaun: not attempting to derail, but I'm on matrix.org. The room wasn't bridged to IRC for quite some time, but now it is.
19:51:47 <EvanR> i dont know what matrix.org is, but im not sure i like it
19:53:41 <superobserver[m]> If you don't like the room being logged, you probably won't like matrix.org being bridged here.
19:54:11 <ab9rf> this isn't a room. it's a channel.
19:54:31 <superobserver[m]> In matrix.org, it is a "room".
19:55:35 <ab9rf> i deny the existence of matrix.org
19:55:37 <EvanR> :|
19:56:00 <capisce> why the hostility?
19:56:03 <superobserver[m]> You can deny the existence of anything at all. Doesn't mean you're right.
19:56:30 <dolio> Maybe you should discuss Haskell.
19:56:48 <geekosaur> this was discussed and okayed in #haskell-ops, and any issues should be raised there
19:57:17 <ab9rf> this channel has been logged since i can'ty remember how long ago, so it's not an issue
19:57:33 <superobserver[m]> I was merely pointing out that IRC channel was suddenly bridged to matrix.org. It was something I found surprising and was glad to see. That is all.
19:58:11 <geekosaur> there has in the past been discussions about public channel logs not under direct control of the channel moderators, iirc
19:58:21 <superobserver[m]> But judging from the responses I'm getting, I'm guessing I'll just leave.
19:58:34 <ab9rf> you're welcome to talk about haskell
19:58:35 <pharaun> superobserver[m]: ahhhh i see, thanks :)
19:58:42 <ab9rf> mmm
19:58:53 <ab9rf> i had some code that was generating a weird runtime error but now it won't do it
19:58:54 <geekosaur> but from my pov that's really a silly thing to argue about because you can't stop randoms from dumping their client's logs into something googleable
19:58:59 <capisce> which bot does the bridging?
19:59:54 <ab9rf> so since i can't replicated it i won't ask about it :\
20:00:03 <EvanR> yes that concern is silly
20:00:07 <geekosaur> (and, well, I have experience with that under another guise, a global filesystem that periodically gets exposed via misconfigured web servers, confusing users who think it's a private filesystem)
20:00:12 <capisce> "Matrix's initial goal is to fix the problem of fragmented IP communications: letting users message and call each other without having to care what app the other user is on - making it as easy as sending an email."
20:00:29 <ab9rf> probably some haziness with this external library i found on github that i had to beat with sticks to get to build with ghc 8
20:01:43 <capisce> for those interested in learning more: http://matrix.org/docs/guides/faq.html
20:55:03 <m0dus0ps> fuck
20:55:46 <ab9rf> no thanks
21:41:28 <ReinH> There's no reasonable expectation of privacy in a public IRC channel...
21:42:35 <EvanR> the issue i have is with slack bridge bot, or other bridge bot. its distracting and mooching content from another venue to prop up your own
21:42:45 <EvanR> matrix.org doesnt seem to be a bot though
21:42:54 <EvanR> or a single bot
21:43:03 <mniip> it's distributed
21:43:16 <mniip> (and so distributedly falls when something fails)
21:44:23 <EvanR> so as long as we dont get into discussion about bridges, its like theyre regular users
21:47:38 * hackage foldl-statistics 0.1.4.4 - Statistical functions from the statistics package implemented asFolds.  https://hackage.haskell.org/package/foldl-statistics-0.1.4.4 (AlexMason)
21:50:33 <Axman6> hey that's me
21:51:02 <halogenandtoast> One day I'll post something to hackage
21:51:49 <MarcelineVQ> make it total in every way please :X I'm fighting one that throws random errors often enough that I'm going to end up remaking it
22:00:17 <halogenandtoast> MarcelineVQ: I only believe in total functions.
22:00:30 <halogenandtoast> Partial functions are an abomination
22:00:46 <halogenandtoast> and throwing errors is an abomination, that's why we have Either
22:01:05 <pacak> > length $ fix (:1)
22:01:07 <lambdabot>  error:
22:01:07 <lambdabot>      • Occurs check: cannot construct the infinite type: a0 ~ [a0]
22:01:07 <lambdabot>        Expected type: [a0] -> [a0]
22:01:20 <pacak> > length $ fix (1:)
22:01:21 <thang1> the ten commandments of Haskell
22:01:27 <lambdabot>  mueval: ExitFailure 1
22:01:28 <halogenandtoast> (no need to correct me, I know there are use cases, that's fine, I'm being dogmatic for the sake of humor and also because it's just my personal taste)
22:01:29 <thang1> 1. Thou shalt not have partial functions
22:01:46 <halogenandtoast> Oh I really want to see all 10 of these
22:01:55 <halogenandtoast> we're off to a good start with #1
22:01:57 <thang1> 2. Error: Ten commandments not fully defined
22:02:16 <pacak> thang1: That's 1, 10, 11, 100, 101, ...
22:03:17 <thang1> (jk, but what would the other commandments be?)
22:03:53 <dmwit> 2. A little bit of documentation goes a long way.
22:03:55 <pacak> type signatures
22:04:10 <dmwit> 3. Type signatures are not a little bit of documentation.
22:04:30 <pacak> Don't write c in haskell.
22:04:49 <thang1> Sometimes write c in haskell
22:05:17 <pacak> thang1: I've seen a solution to our sample task that was literally c written in haskell. EVERYTHING was in IO monad.
22:05:18 <dmwit> I would be impressed with a C implementation in Haskell.
22:05:19 <thang1> ie "everytime someone says to never ever use unsafePerformIO, there exists at least one user on #haskell that will immediately chime in with BUT SOMETIMES YOU NEED IT"
22:05:46 <mniip> accursedUnutterableUnsafeIlinePerformIO
22:05:48 <pacak> dmwit: Not language, but style.
22:06:15 <mniip> dmwit, why?
22:06:20 <pacak> The determined Real Programmer can write FORTRAN programs in any language.
22:06:26 <mniip> ghc is quite similar
22:06:43 <thang1> it'll be funny if someone formally proves the correctness of some C implementation and it turns out there's a memory error somewhere but they can't fix the critical bug because 90% of the world depends on the answer being "wrong"
22:06:49 <mniip> or you mean a c interpreter/runtime
22:07:33 <mniip> thang1, that's not how that works
22:07:48 <dmwit> mniip: Because a language implementation is a sizable project which requires many man-hours of effort.
22:07:57 <mniip> ok
22:08:10 <pacak> thang1: Microsoft would totally keep this bug.
22:08:13 <dmwit> This feels like one of those antijokes. Why do undertakers wear ties? Because they have a very serious job and need to project an air of professionalism.
22:08:46 <pacak> thang1: http://i.imgur.com/aDAZGB1.png
22:09:18 <nshepperd> i use unsafePerformIO all the time
22:09:24 <nshepperd> it's my favourite combinator
22:09:31 <dmwit> I mix tabs and unsafePerformIO
22:09:52 <nshepperd> :O
22:10:02 <dmwit> tabs for indentation, unsafePerformIO for alignment
22:10:13 <thang1> ಠ_ಠ
22:10:36 <thang1> but for serious, microsoft would totally keep that bug
22:10:44 <thang1> y'know why? Because they skipped windows 9 and went to 10
22:11:31 <nshepperd> because of the "Windows 9*" thing, yeah
22:11:34 <nshepperd> classic
22:11:45 <dmwit> Please, keep it PG13. clbuttic
22:15:29 <cocreature> @remember dmwit tabs for indentation, unsafePerformIO for alignment
22:15:29 <lambdabot> I will remember.
22:19:41 <thang1> dmwit: what's not PG13 about that?
22:19:53 <thang1> 13 year old me would've thought it was hilariously clever
22:20:47 <geekosaur> I think that was a joke
22:20:50 <dmwit> thang1: https://en.wikipedia.org/wiki/Scunthorpe_problem
22:21:11 <geekosaur> (or a shoutout to everyone using the cloud-to-butt plugin >.> )
22:21:42 <dmwit> Rereading that article made me laugh at "buttbuttinate" again. =D
22:23:40 <nshepperd> (I still use the keyboard-to-leopard plugin. got quite good at translating back on the fly but sometimes things like 'data LeopardEvent = ...' still trip me up)
22:24:07 <thang1> I hate plugins like that tbh
22:24:35 <thang1> I sometimes I'm read so fast I just grab half a sentence at one go and if there's a word mixed up it'll totally mess with me
22:24:39 <nshepperd> surprisingly, I don't actually see that much discussion of keyboards, so it always amuses me when i notice it
22:26:19 <thang1> someone isn't subscribed to r/mkb :p
22:26:23 <mniip> dmwit, what? I've always used unsafePerformIO for indentation
22:30:06 <mniip> hmm
22:30:15 <mniip> does unsafePerformIO codistribute
22:30:48 <mniip> unsafePerformIO (f <*> x) = unsafePerformIO f $ unsafePerformIO x
22:30:53 <Sh4rPEYE> Hey. I have a list of sets and I need to find their intersection. How would I do that? I tried to foldr1 them, but the list is sometimes empty and it throws (unsuprisingly) an error
22:31:35 <mniip> Sh4rPEYE, what is an intersection of 0 sets?
22:32:01 <Sh4rPEYE> Well, in my case preferable an empty set
22:32:09 <dmwit> nooooo
22:32:16 <mniip> but
22:32:20 <mniip> that's not
22:32:59 <dmwit> You should want `intersection (a ++ b) = intersect (intersection a) (intersection b)` whenever both are defined. If you let `intersection []` be defined you're going to have a problem with that.
22:33:25 <Sh4rPEYE> Ok. I'll check for the empty list and use foldr1 otherwise
22:33:34 <pacak> Sh4rPEYE: What do you expect when you intersect empty set with non-empty set?
22:34:00 <Sh4rPEYE> pacak: That would be another empty set, no?
22:34:00 <dmwit> You could consider returning a `Maybe Set`. Seems cleaner.
22:34:31 <pacak> Sh4rPEYE: Right. That's why foldr1.
22:34:45 <Sh4rPEYE> dmwit: I'm wrting a longest common substring algo, so in my case it wouldn't be particularly more elegant
22:34:54 <dmwit> :t S.intersection
22:34:56 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
22:37:09 <Sh4rPEYE> dmwit: After I'm finished, it'd be nice to look at the "official" way to find the lcs. Is there any resource where I could find it?
22:37:27 <Sh4rPEYE> (the official=idiomatic way in Haskell, I mean)
22:39:01 <dmwit> :t foldr (\x -> Just . maybe x (S.intersection x)) Nothing
22:39:03 <lambdabot> (Ord a, Foldable t) => t (S.Set a) -> Maybe (S.Set a)
22:39:46 <dmwit> I don't know of a package for longest common substring. There are a few for longest common subsequence.
22:39:57 <mniip> fmap Just . maybe <*> S.intersection
22:39:58 <mniip> ha
22:40:31 <dmwit> I know which I'd prefer in my codebase. =)
22:40:45 <mniip> you can actualy upgrade any fold this way kinda
22:40:54 <Sh4rPEYE> mniip: Cool
22:41:08 <mniip> :t \f -> foldr (fmap Just . maybe <*> f) Nothing
22:41:10 <lambdabot> error:
22:41:10 <lambdabot>     • Couldn't match type ‘Maybe (Maybe a1 -> a2)’
22:41:10 <lambdabot>                      with ‘Maybe a -> Maybe a’
22:41:29 <mniip> oops
22:41:34 <Sh4rPEYE> dmwit: So be sure to tell me :-D 
22:41:43 <dmwit> Sh4rPEYE: Tell you what?
22:41:45 <mniip> :t \f -> foldr (fmap Just . (maybe <*> f)) Nothing
22:41:47 <lambdabot> Foldable t => (a -> a -> a) -> t a -> Maybe a
22:42:28 <thang1> :t fmap Just . maybe <*> S.intersection
22:42:30 <lambdabot> Ord a => S.Set a -> Maybe (Maybe (S.Set a) -> S.Set a)
22:42:46 <Sh4rPEYE> dmwit: When you said "I know which I'd prefer in my codebase" I whought you were talking about some algo 
22:43:02 <dmwit> Actually, I think I'd probably want `intersections [] = Nothing; intersections xs = Just (foldr1 S.intersection xs)` in my codebase. No sense (de)constructing all those `Maybe`s.
22:43:11 <thang1> nah they were talking about how you shouldn't reinvent the wheel and how shorter, concise, and to the point is usually way better
22:43:12 <Sh4rPEYE> I guess it was about the fold things :-D 
22:43:23 <dmwit> Sh4rPEYE: Oh, no, I was talking about my version vs. mniip's pointfree version. I think mine is much clearer.
22:43:54 <mniip> well, can't help myself...
22:43:59 <mniip> when I see 'f x (g x)'
22:44:09 <thang1> I thought mniip's was clearer myself :p
22:44:13 <pacak> @pl \xs -> if null xs then Nothing else Just (foldr1 S.intersection xs)
22:44:13 <lambdabot> ap (flip if' Nothing . null) (Just . foldr1 S.intersection)
22:44:50 <thang1> if I see a buncha flips and dots everywhere in a codebase it makes me want to cry. It's okay to not be point free, guys
22:44:55 <mniip> pacak, I'd express that as
22:44:56 <pacak> Hmmm... No.
22:45:09 <mniip> :t bool (const Nothing) (Just . foldr1) null
22:45:10 <EvanR> thang1: no, you dont like esolangs?
22:45:10 <lambdabot> error:
22:45:10 <lambdabot>     • Couldn't match expected type ‘Bool’
22:45:10 <lambdabot>                   with actual type ‘[a0] -> Bool’
22:45:24 <mniip> :t liftA3 bool (const Nothing) (Just . foldr1) S.empty
22:45:26 <lambdabot> error:
22:45:26 <lambdabot>     • Couldn't match expected type ‘S.Set d’
22:45:26 <lambdabot>                   with actual type ‘b0 -> Maybe a0’
22:45:31 <nshepperd> mniip: 'unsafePerformIO (f <*> x) = unsafePerformIO f $ unsafePerformIO x' won't hold if the result of f is 'const anything'
22:46:05 <mniip> :t liftA3 bool (const Nothing) (Just . foldr1 S.intersection) null
22:46:06 <lambdabot> (Ord a, Foldable t) => t (S.Set a) -> Maybe (S.Set a)
22:46:08 <thang1> nshepperd: it should typecheck just fine, though :p
22:46:09 <mniip> there, I need sleep...
22:46:32 <thang1> liftA3 and a null? *we've gone too far*
22:46:43 <nshepperd> maybe there are cases where you can get the strictness analyzer to evaluate the argument first, also, so that the execution order will be reversed
22:46:51 <nshepperd> not sure about that one
22:47:10 <thang1> unsafe is unsafe
22:47:25 <thang1> unsafePerformIO means "hold m'beer, ghc. I got dis"
22:47:42 <mniip> *crashes into gc barrier*
22:48:10 <thang1> @remember thang1 unsafePerformIO means "hold m'beer, ghc. I got dis"
22:48:10 <lambdabot> I will remember.
22:48:43 <nshepperd> that's why it's important to know how ghc's beer holders work
22:54:01 <dmwit> ?yow
22:54:01 <lambdabot> OVER the underpass!  UNDER the overpass!  Around the FUTURE and BEYOND REPAIR!!
22:54:09 <dmwit> ?quote
22:54:09 <lambdabot> knuth says: To help the reader drowning in a sea of abstraction, the following example may serve as a concrete life preserver
22:54:54 <jle`> heh, we looking for an "over with passthrough", that lets me modify a field and also return an extra value in the process
22:55:04 <jle`> a Lens s t a b -> (a -> (c, b)) -> s -> (c, t))
22:55:10 <jle`> then i realized that it was just 'id'
22:55:55 <jle`> > _1 (\x -> ("some result", 'q')) ('a',3)
22:55:58 <lambdabot>  ("some result",('q',3))
22:57:41 <mniip> now do the same for prism
22:58:17 <jle`> > hex (\x -> (First (Just x), x*2)) "5ab3d"
22:58:19 <lambdabot>  (First {getFirst = Just 371517},"b567a")
22:58:33 <jle`> > hex (\x -> (First (Just x), x*2)) "qwerty"
22:58:35 <lambdabot>  (First {getFirst = Nothing},"qwerty")
22:59:07 <jle`> the power of haskell subtyping
22:59:16 <jle`> and of ...applicatives?
22:59:28 <jle`> ... in the first case, of Functors, i guess?
22:59:55 <jle`> more and more of my projects recently have been abusing RankN types to build subtyping hierarchies
23:02:28 <nshepperd_> I think one of the lovely things about lenses is you can always just apply them at any choice of functor to get a new effect
23:02:52 <EvanR> how do you abuse rankN to get subtyping hierarchies
23:03:15 <jle`> i guess this is a triumph of VanL lenses then
23:03:27 <nshepperd_> > _1 (\x -> [4, 6, 9]) (3, "a") 
23:03:30 <lambdabot>  [(4,"a"),(6,"a"),(9,"a")]
23:03:47 <jle`> EvanR: well, see how in 'lens', you can use a Traversal as a Lens
23:04:27 <jle`> Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
23:04:38 <jle`> Trav s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
23:05:14 <jle`> Traversal is a subtype of Lens
23:05:33 <nshepperd_> Other way around, you can use a lens as a traversal :p
23:05:48 <jle`> ah yeah
23:05:50 <mniip> yeah
23:05:56 <jle`> Lens is a subtype of Traversal
23:06:17 <jle`> any function that expects a Traversal can be given a Lens
23:07:33 <EvanR> jle`: ah
23:07:48 <jle`> we could have written transformers a little differently
23:07:55 <jle`> instead of type State s a = StateT s Identity a
23:08:22 <jle`> we could have had type State s a = forall m. Monad m => StateT s m a
23:08:39 <jle`> and so State s a would be an actual subtype of StateT
23:09:11 <jle`> ...with some limits
23:10:05 <mniip> jle`, ikr, instead of fmap :: (a -> b) -> f a -> f b, we could have fmap :: Cod f a b -> Dom f (f a) (f b)
23:11:19 <jle`> i think that might be a different thing but that is also something that would be nice
23:12:37 <mniip> jle`, see my Show1 ramblings in -lens
23:12:57 <thang1> ot: I have the developer dogfood version of the google Gboard app and I'm totally not supposed to have it. Google gave it to me by mistake somehow
23:13:35 <Lokathor> how might one see what bytes the storable instance of a type generates?
23:14:05 <thang1> write it to a file then cat it out? :p
23:14:23 <thang1> (and by cat I mean inspect it at the byte level somehow...)
23:14:26 <Lokathor> hnnng
23:15:29 <Lokathor> i think the storable instances that my nested tuples are using aren't giving the same bytes that concatMapping them into list gives
23:15:42 <nshepperd_> Use poke to write a value into a ByteString and print it
23:16:12 <Lokathor> oooh, nice
23:19:04 <thang1> You can probably also use that with quickCheck somehow :p
23:19:31 <Lokathor> hmm
23:19:46 <Lokathor> i'm not seeing how you get at the pointer under a bytestring :/
23:20:19 <Lokathor> but i can use two vectors i guess
23:23:21 <cocreature> Lokathor: unsafeUseAsCStringLen will give you access to the pointer but as the name says it’s unsafe :)
23:23:56 <Lokathor> i can just use unsafeCast from Data.Vector.Storable
23:23:59 <matrium> hi, is there a nice pattern to create a reader-based function for a pure function whose first argument is the reader's value? preferably point free?
23:24:13 <matrium> my current solution looks like this: objectsM subject predicate = reader objects <*> pure subject <*> pure predicate
23:25:05 <nshepperd_> Maybe put the value into a storable vector then cast it to a vector of word8s
23:29:46 <quchen> matrium: Point-free is nothing to be preferred, readability is.
23:30:50 <Lokathor> nshepperd_, http://lpaste.net/355975
23:31:24 <matrium> quchen: Yes, I agree. But wouldn't something like "objectsM = reader objects" be more readable?
23:31:29 <Lokathor> quchen, isn't point free generally a CAF, and thus have runtime implications?
23:32:32 <quchen> Lokathor: Apart from typeclass shenanigans: yes. But that’s not something that’s strictly better than the pointful version, and in general nothing to be concerned about too much.
23:33:02 <Lokathor> i wish that Data.Storable.Vector had a "byteCount" function
23:33:08 <Lokathor> oh well
23:33:30 <jle`> matrium: whether or not something is readable is independent of whether or it it's point-free
23:33:41 <jle`> you shouldn't be "preferring" point-free
23:33:46 <jle`> you should be preferring readability :)
23:34:08 <quchen> Hello echo ;-)
23:35:13 <quchen> juhp__: Ping
23:35:21 <quchen> Are you @juhp on Github?
23:40:42 <Lokathor> so, is the reason that Vector.Storable isn't a Functor the fact that it has the extra Storable constaint on its map operation?
23:41:16 <thang1> matrium: in the case of your example, that looks perfectly readable to me
23:41:48 <cocreature> Lokathor: yep
23:41:49 <pacak> Lokathor: Right.
23:42:19 <thang1> Lokathor: Affirmative
23:43:38 * hackage prettyprinter-compat-wl-pprint 1.0.0.1 - Prettyprinter compatibility module for previous users of the wl-pprint package.  https://hackage.haskell.org/package/prettyprinter-compat-wl-pprint-1.0.0.1 (quchen)
23:43:41 <NikolajK> I tried to get to a ghci version that starts with a 8 but failed. I ended up deleting everything to do with haskell, for a complete reinstall of just haskell 8.0.2., but somehow the Terminal still opens ghci 7.10.3. Does anybody have any idea where this sits? The Libraries/Haskell folder is definately gone (mac)
23:44:38 <jle`> which 'which ghci'
23:44:44 <peddie> NikolajK: can you just run `which ghci`?
23:44:49 <peddie> oops, too slow
23:44:59 <jle`> but, at the risk of sounding like a snake-oil salesman, you can just install stack and have stack manage your ghc/ghci instead
23:45:16 <jle`> then 'stack ghci' will specifically use the ghc that is configured in the resolver
23:45:36 <thang1> stack ghci is best ghci
23:45:41 * pacak dislikes stack
23:46:13 <NikolajK> okay, thx, there is indeed a ghci in Applications that the general search didn't find
23:46:23 <NikolajK> gonna kill it and install the haskell package anew
23:47:16 <thang1> pacak: why?
23:47:18 <NikolajK> isn't Stack part of the haskell platform?
23:47:29 <NikolajK> how to choose "stack ghci"?
23:47:32 <jle`> stack is indeed a part of the haskell platform
23:47:35 <jle`> 'stack ghci' is the command you'd type
23:47:36 <jle`> instead of 'ghci'
23:47:43 <NikolajK> ah, simple
23:47:50 <NikolajK> okay, let's reinstall
23:48:13 <jle`> you can also override the configured resolver
23:48:23 <jle`> with 'stack ghci --compiler=ghc-8.0'
23:48:55 <jle`> you might need to 'stack setup --compiler=ghc-8.0' first if it's not installed yet
23:50:00 <thang1> I just find it easier to update all resolvers I care about, but command flags can be easier sometimes :p
23:50:17 <quchen> `stack ghci` is fairly slow to start though, that’s my only complaint
23:50:39 <pacak> thang1: I'm working on a relatively big project ~700 modules with customized build system. We also have one unrelated project that consists of about 5 or so different modules - it's managed by stack. If I make small change in either of those projects - one managed by stack takes about 10 times longer to recompile.
23:51:20 <johnw> pacak: to what do you attribute that difference?
23:52:00 <thang1> stack can be a bit aggressive with recompiling everything from scratch instead of using caching for everything it can
23:52:25 <thang1> (I think)
23:52:26 <pacak> johnw: I have no ideas what stack does. I know what custom build system does because I wrote it myself.
23:52:53 <pacak> custom build system tries to cache stuff.
23:53:11 <pacak> And avoids recompilations when it can
23:53:14 <matrium> Ok thanks! so i'll just stick with my current syntax
23:53:31 <Lokathor> alright folks, the program pulses funny colors now
23:53:52 <Lokathor> all that's left is a zillion little update functions so that you can update easily all sorts of ways
23:53:55 <matrium> just thought there might be some kind of general pattern for factoring out the first parameter of a pure function into a reader 
