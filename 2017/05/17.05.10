00:05:48 <Hjulle> Are type level functions not invertable?
00:07:28 <Cale> Hjulle: Not always
00:08:11 <Hjulle> How can I tell the compiler that this one is?
00:08:29 <Cale> I would just turn on UndecidableInstances here
00:09:06 <Hjulle> Since I'm pattern matching on it in the instance header, it should realise that I'm trying to invert it. 
00:10:33 <Hjulle> Cale: Why is it needed? It doesn't seem undecidable to me?
00:12:38 <Cale> Well, let's see
00:13:18 <Cale> Due to the functional dependency, we ought to have that if we know f, f s, a, and b, then we ought to be able to uniquely determine f t
00:14:16 <Cale> Given f, s, a and b, we would be able to determine t, but actually we don't know s
00:14:53 <osa1> what's the correct lens expression for this: `x ^? _Constr ^. _1 :: Maybe FirstFieldOfConstr` ?
00:15:44 <glguy> change ^. to .
00:16:04 <osa1> glguy: awesome, thanks
00:18:47 <Cale> Hjulle: wait, that's not the error message that I get while compiling this
00:18:59 <Cale> Hjulle: I just get a complaint about ambiguity
00:19:16 <Cale> (also KindSignatures wasn't switched on)
00:19:43 <glguy> Hjulle: undecidable instances ate required to use fun dep deps from your instance's context
00:19:50 <lpaste> Hjulle revised “Coverage condition fails”: “Coverage condition fails” at http://lpaste.net/355373
00:20:24 <Hjulle> glguy: Aha, that explains it, thanks.
00:20:28 <Cale> Right, that's what I get
00:20:42 <Hjulle> Cale: And that makes even less sense :S
00:20:50 <Cale> I didn't need UndecidableInstances to get the complaint about it being ambiguous which f is involved.
00:21:13 <Cale> Hjulle: Write the explicit type that you want deepFmap to have there
00:21:16 <Cale> What is it?
00:21:43 <Hjulle> (There is only ever one f involved.)
00:21:44 <Cale> Hjulle: In fact, this is intrinsically ambiguous
00:21:51 <Cale> class DeepFmap (f :: * -> *) s t a b | f s a b -> t where
00:21:51 <Cale>   deepFmap :: (a -> b) -> s -> t
00:21:56 <Cale> look at your class declaration
00:21:58 <glguy> you forgot to use f in your method's type?
00:22:08 <Cale> f isn't mentioned in the method's type, right
00:22:29 <Hjulle> Aha, right. 
00:24:49 <lpaste> Cale annotated “Coverage condition fails” with “Coverage condition fails (annotation)” at http://lpaste.net/355373#a355376
00:25:09 <Hjulle> Cale: A concrete example would be: deepFmap :: DeepFmap Maybe (Maybe (Maybe a)) (Maybe (Maybe b)) a b => (a -> b) ->  Maybe (Maybe a) -> (Maybe (Maybe b)
00:25:22 <Cale> ^^ my paste works
00:26:51 <Cale> Well, for some definition of "works"
00:26:59 <Cale> This also still requires overlapping instances
00:27:50 <Hjulle> Aha, right, by mentioning f in deepFmap, the typechecker can know more.
00:28:03 <Cale> oh, maybe not...
00:28:13 <Hjulle> Cale: But I still don't get why f0 is a ambigous?
00:28:14 <Cale> You can get away with monomorphic usages
00:28:35 <Cale> There are two f's which are different and might not match
00:28:57 <Hjulle> Also I lose the "feature" of deepFmap = id. :P
00:29:15 <Cale> Because each usage of deepFmap with your original definition would introduce a new f which didn't have anything to do with the actual type of the method.
00:29:18 <Hjulle> Cale: Which are the two different fs?
00:29:42 <Cale> So there would be no way to confirm that they matched, because they weren't mentioned elsewhere
00:30:44 <Cale> When you go and use deepFmap there, it knows that it's got to have type (DeepFmap f0 s0 t0 a0 b0) => (a0 -> b0) -> (s0 -> t0) for some f0, s0, t0, a0, and b0
00:30:56 <Hjulle> Ah, right. So, if I explicitly mention f in the type signature of the deepFmap that is used in deepFmap = fmap . deepFmap, then it wouldn't be ambigous?
00:31:09 <Cale> yeah, not immediately anyway
00:31:43 <Cale> Well, I mean, if you change the type of deepFmap so that it actually mentions f
00:32:05 <Hjulle> Maybe a phantom argument would solve the problem?
00:32:09 <Cale> You can't just give a type annotation to that deepFmap in-place which would do any good there.
00:32:16 <Cale> You could also use a Proxy, sure.
00:32:38 <Cale> This whole class is a pretty silly idea though -- it's not going to be all that easy to use it.
00:33:03 <Cale> deepFmap :: (a -> b) ->  Maybe (Maybe a) -> Maybe (Maybe b) -- note that this will still be a type error
00:33:04 <Hjulle> The Proxy would also help with making the class less unsuable
00:33:09 <Cale> Even with my version
00:33:30 <Cale> Because a and b are yet to be determined -- we can't know if they're of the form Maybe s and Maybe t yet
00:33:40 <Cale> So the instances overlap, and you get an error
00:34:35 <Cale> deepFmap :: (Int -> Char) ->  Maybe (Maybe Int) -> Maybe (Maybe Char) -- this will work fine with my version though
00:34:35 <ZuluKing> can someone tell me why I keep getting Ilegal Tuple section error for the following:
00:34:43 <Hjulle> Cale: Thanks
00:35:06 <ZuluKing> x :: [(String, [String])]
00:35:40 <ZuluKing> x = [ ("Monday", ["ssfew", "sffwqefwe"])
00:36:22 <Cale> You're missing a ]
00:36:41 <Cale> I can't see why you'd get that error though
00:36:43 <ZuluKing> I just missed it right now
00:36:50 <ZuluKing> it's there in the code
00:37:03 <Cale> A tuple section looks like (foo,) or (,bar)
00:37:18 <Cale> :t ("hello",)
00:37:20 <lambdabot> t -> ([Char], t)
00:37:35 <Cale> > map ("hello",) ["there", "world"]
00:37:37 <ZuluKing> So, is this illegal [(String, [String])] ?
00:37:38 <lambdabot>  [("hello","there"),("hello","world")]
00:37:46 <Cale> no, that's fine.
00:37:59 <ZuluKing> I want a list as the second component of each tuple
00:38:06 <Cale> sure
00:38:09 <Cale> That's not a problem
00:38:21 <Cale> Can you post the exact source on lpaste.net?
00:38:29 <ZuluKing> sure, one second
00:39:49 <lpaste> ZuluKing pasted “TupleError” at http://lpaste.net/355377
00:39:57 <lpaste> ZuluKing pasted “TupleError” at http://lpaste.net/355378
00:40:08 <lpaste> ZuluKing pasted “TupleError” at http://lpaste.net/355379
00:40:32 <ZuluKing> Cale can you check?
00:41:34 <Cale> ZuluKing: I put that code in a file and loaded it and it's fine.
00:42:06 <Cale> ZuluKing: Put the actual code which you are having trouble compiling on lpaste.net
00:42:33 <ZuluKing> Cale, thanks, I think haskero has some issues then
00:43:27 <Cale> Oh, try just loading it in ghci
00:45:01 <ZuluKing> Cale, works fine, thanks!
00:46:26 <Hjulle> Cale: It worked with the proxy. :) Thanks.
00:46:45 <Cale> Hjulle: You're not actually going to use that thing, are you?
00:47:14 <Hjulle> No, not for real code. Only toy projects. :)
01:01:57 <wolfsif> Hi everyone
01:01:59 <lpaste> Hjulle annotated “Coverage condition fails” with “Coverage condition fails (working version)” at http://lpaste.net/355373#a355380
01:02:52 <wolfsif> I'm watching Evan Czaplicki's talk from Strange Loop on different types of FRP, but I'm a little confused by his claim that in arrowized FRP, "signals aren't connected to the world"
01:04:02 <wolfsif> My understanding was that arrowized FRP libraries (ie yampa, netwire) are intended for writing interactive programs -- so they must be connected to the world somehow
01:04:41 <wolfsif> Can anyone offer some insight?
01:04:54 <ertes-w> i'm positively surprised by the 'jq' program written in C…  its interface docs basically say: "mooonad…  i'm a mooooonad!"…  i would be interested if the author was aware of that
01:05:38 <ertes-w> wolfsif: yes, they are connected to the world, but there is a clear separation between the real world and the FRP system
01:05:46 <comerijn> wolfsif: I'm not familiar with this talk, but I'm assuming he means that you don't *directly* connect to the world, there's usually primitives for converting regular "IO" into signals that FRP system works with
01:06:13 <ertes-w> wolfsif: not just a semantical separation, but an actual technical separation, because every time frame of the FRP system needs to run as a "transaction"
01:06:57 <ertes-w> wolfsif: however, it's not strictly true…  wires, the successor of netwire, dispenses with this separation, coming much closer to non-A FRP
01:07:36 <ertes-w> wolfsif: in wires it is not only allowed but the standard approach to create events *within* the reactive part of the application
01:08:07 <bollu> is there a way to encode an "imperative-ish" DSL within haskell such that it is fully inspectable? in the sense of, I don't want functions in the DSL, since I can't inspect / pattern match them at compile time
01:08:32 <ertes-w> bollu: there are free Applicatives
01:08:35 <bollu> I want to to create something like compile :: DSL -> <whatever>. The DSL can't have a haskell function if I wish to be able to inspect it
01:08:51 <bollu> ertes-w: less powerful, I take it?
01:08:52 <wolfsif> I see, thanks for the responses
01:09:05 <ertes-w> bollu: but there are still functions…  the main difference to free monads is that you can see the full program, but you can't see how it transforms its results
01:09:38 <ertes-w> bollu: if you really want to see everything, you have to come up with an expression type
01:09:50 <bollu> ertes-w: could you elaborate on that?
01:09:58 <bollu> ertes-w: do you mean like, an actual ASTR?
01:09:59 <bollu> AST*
01:10:11 <ertes-w> bollu: pure (5 +) <*> pure 5
01:10:25 <ertes-w> bollu: you can't see the 10, until you actually run it
01:10:32 <bollu> right
01:10:38 <ertes-w> yeah, like an AST
01:10:44 <ertes-w> of course then it gets complicated
01:10:45 <bollu> hm, unfortunate
01:10:47 <bollu> yeah
01:11:32 <ertes-w> bollu: also you have the usual caveat that Applicative is far less expressive than Monad
01:11:38 <bollu> can TH see things across modules? I think not, yes?
01:13:39 <primal_> /join ##security
01:13:46 <primal_> oups sry
01:14:06 <wolfsif> ertes-w: so if a clear separation between the world and the FRP system is not strictly true in A FRP, what is the real distinction that defines A FRP?
01:16:21 <ertes-w> wolfsif: its awkward interface =)
01:16:28 <wolfsif> hahah
01:16:46 <bollu> what's AFRP?
01:16:55 <wolfsif> arrowized frp
01:16:58 <bollu> ah
01:17:37 <ertes-w> wolfsif: it can manage everything as implicit state using an automaton-based approach to state by not allowing first-class events and behaviours
01:18:47 <ertes-w> it actually manages to make certain things even simpler that way:  everything is a behaviour, so you don't even have a Behaviour wrapper type…  if you have to time-varying integers x and y, the sum is just x + y, and the result is just Integer
01:19:08 <wolfsif> ertes-w: also, NOT having a clear distinction between the world and the FRP system sounds like giving up on purity. I thought that the whole idea of FRP was to be able to write interactive programs with pure functions -- am I misunderstanding?
01:19:11 <merijn> Once again, the ridiculous Monoid instance of Map ruins my day :\
01:19:12 <ertes-w> but not having first-class behaviours and events is a major drawback
01:19:50 <ertes-w> wolfsif: no, the semantics is still pure…  it just allows the system to be more dynamic
01:20:12 <ertes-w> you can create new events whenever you need…  imagine a user creates a new window
01:20:33 <bollu> merijn: left absorbing?
01:20:44 <liste> is there a nice way to clear the screen with vty?
01:20:56 <merijn> bollu: Left union, rather than "instance Monoid v => Monoid (Map k v)"
01:21:37 <merijn> Number of times that Monoid would've simplified my code: 20+
01:21:47 <merijn> Number of times I've used the actual Monoid of Map: 0
01:23:32 <Cale> merijn: Do you have any opinion as to where we ought to put a newtype of Map that has the correct instance?
01:23:39 <bollu> merijn: wait what?
01:23:46 <bollu> merijn: isn't the monoid on map based on the keys?
01:24:17 <Cale> The monoid on Map just picks the value from the left Map on a collision.
01:24:37 <merijn> Cale: I've proposed adding a newtype to containers, but very little useful response. Mostly people complaining "that such a newtype would be useless without duplicating the entire Map interface"
01:24:57 <Cale> You'd usually want the instance Semigroup a => Monoid (Map k a) which uses the Semigroup instance to combine the values at colliding keys.
01:25:00 <bollu> Cale: yes, I wanted right absorbing based on keys
01:25:04 <bollu> Cale: ah
01:25:08 <bollu> Cale: I see what you mean
01:25:33 <merijn> Cale: At this point I might simply write my own containers wrapper, put that on hackage and be done with it
01:25:34 <Cale> merijn: Well, that's what we've done at Obsidian. We have a module Data.AppendMap which has a newtype wrapper and then the entire interface
01:26:06 <ertes-w> that's how stupid the existing Monoid instance is
01:26:08 <merijn> Cale: I'm leaning towards Monoid rather than Semigroup, since as yet I think there's more instance of Monoid?
01:26:37 <merijn> If semigroup ever becomes a superclass of Monoid that goes away, but until then
01:27:02 <mrijkeboer> QuickCheck question: How can I combine `ioProperty` with `forAll`? I have a function that throws exceptions on invalid input and would like to make a QuickCheck test to validate that the correct exception is thrown.
01:28:51 <Cale> forAll gen (\v -> ioProperty (something v))
01:29:07 <merijn> Right now I have a bunch of functions producing "[Foo -> [Bar]]" as output, but I'd like to change that to "[(String, Foo -> [Bar])]" and then after running a buch of those merge based on the String key
01:29:18 <Cale> or you can do it the other way around
01:30:06 <merijn> So I either group via Map or annoying list work
01:30:21 <Cale> merijn: Well, we're going to end up open sourcing what we've done one way or another, but we'd like to figure out where the code should go so that people can actually find it and use it.
01:30:41 <Cale> (but I think Semigroup is required in our case)
01:30:49 <merijn> Cale: See, that's why I'm sad that hackagebot is gone
01:30:57 <merijn> I liked discovering neat libraries like this that way
01:31:56 <Hjulle> How do you destruct a DataKinds Nat? If I defined it myself I would just pattern match for S(n) or Z in the type signature, but how do you do it with the builtins?
01:31:58 <mrijkeboer> Cale: Thanks that worked.
01:32:01 <Cale> mrijkeboer: Note that Property is an instance of Testable
01:33:50 <mrijkeboer> Cale: I noticed, but didn't put the pieces together...
01:33:54 <Cale> Hjulle: usually pattern matching with type class instances? Or by defining a type family.
01:34:38 <Hjulle> I mean the built in kind Nat. What do I pattern match for in the instances?
01:36:54 <Cale> Are you talking about the TypeLits one?
01:37:00 <Hjulle> Yes
01:37:09 <Cale> I don't think you can pattern match on that
01:37:19 <Hjulle> aha, ok
01:37:33 <Cale> There's some built in arithmetic you can do
01:51:36 <Hjulle> "KnownNat (n-1) => do something with (n-1)" seems do do the job
02:01:02 <Hjulle> Is there any sugar for Proxy? "Proxy :: Proxy 3" is a very long way to write "3".
02:03:04 <osa1> you could use TypeApplications if you're designing the API (as opposed to using an existing one that uses Proxy)
02:05:21 <merijn> Quick question: What happens when I run setNumCapabilities without the threaded runtime? Is it a no-op?
02:14:26 <jle`> Hjulle: Proxy @3
02:14:45 <Hjulle> aha, nice
02:15:25 <jle`> Hjulle: that's not sugar for Proxy, btw
02:15:29 <jle`> it's just type application syntax
02:15:57 <wolfsif> I'm having trouble picking which FRP library to learn, with the intent of writing interactive sound and graphics applications (ie games, sound synths, etc). Anyone have advice?
02:23:12 <merijn> wolfsif: ertes-w's wires, maybe? It kinda depends on what kinda latency/jitter you're willing to tolerate, I think
02:26:55 <wolfsif> thanks, I'm checking out wires
02:33:56 <kuribas> Everytime a thunk is encountered, it must be checked if it is already evaluated, right?
02:34:03 <kuribas> Doesn't that give a lot of overhead?
02:36:14 <bollu> kuribas: no, a thunk evaluation is just a function pointer call
02:36:20 <merijn> kuribas: Why does it have to be checked?
02:36:25 <bollu> kuribas: it gets rewritten with the computed value upon execution
02:36:33 <kuribas> bollu: oh, right
02:36:46 <bollu> kuribas: at least, that's what the STG paper says. Not a GHC dev so this may not be the truth
02:37:13 <kuribas> merijn: so it doesn't get evaluated twice?
02:37:56 <merijn> kuribas: That assumes the representation of the thunk and it's result are not uniform :)
02:39:37 <bollu> kuribas: no, a think has a field that tells whether it is updatable or not. If it is marked as updatable, then the thunk is overwritten with the updated value (again, in theory)
02:39:39 <bollu> thunk*
02:39:56 <merijn> Also, nothing says a thunk cannot be evaluated twice
02:39:59 <kuribas> wouldn't it be like "case thunk of UnEvaluated fun -> evalute fun; Evaluated expr -> expr"
02:40:01 <merijn> In fact, GHC sometimes does that
02:40:06 <bollu> merijn: really?
02:40:10 <bollu> merijn: why?
02:40:22 <bollu> the STG paper does not talk about this, interesting
02:40:31 <merijn> bollu: Because recomputing can be cheaper than, e.g. locking when you run multithreaded
02:40:39 <bollu> merijn: ah, I se
02:40:40 <bollu> see*
02:40:58 <kuribas> I suppose ghc can infer if it is evaluated before in the same function.
02:47:18 <mniip> kuribas, in STG, the evaluated and unevaluated thunks have the same interface
02:47:24 <mniip> you just enter a pointer
02:47:39 <mniip> an unevaluated thunk evaluates and replaces the values
02:47:45 <mniip> and evaluated thunk returns immediately
02:47:53 <mniip> fsvo returns
02:48:21 <mniip> there's also pointer tagging involved
02:49:38 <mniip> it's cool how it manages to be *nothing* like the C runtime
02:54:54 <merijn> mniip: :)
03:44:03 <vegai> Hey
03:44:23 <vegai> Would it be possible to form a bridge between this channel and the corresponding channel in Matrix?
03:44:46 <vegai> I haven't done it myself ever, but I understand it requires a channel admin to do something
03:47:29 <bennofs> vegai: matrix.org already bridges all of freenode: https://matrix.org/blog/2015/06/22/the-matrix-org-irc-bridge-now-bridges-all-of-freenode/
03:47:48 <bennofs> vegai: (including this channel)
03:50:56 <vegai> yeah, that's something different. In fact, what I'm using right now
03:52:06 <vegai> ... I think :) I'm on several "native" channels on Matrix which contain bridges to various places
03:52:17 <vegai> one of which is a Haskell channel
03:52:47 <vegai> , which does not contain a bridge to here
03:53:08 <vegai> but I don't claim to know if there's any benefit to adding that. There are 115 people there currently
04:02:49 <ertes-w> aren't those the people with the "[m]" suffix in their nick?
04:06:51 <Lambda__> Hey
04:21:06 <quchen> mniip: Pointer tagging is an optimization though, not something the STG *needs*
04:21:23 <quchen> In fact, pointer tagging is something that makes the »T« in STG wrong ;-)
04:21:58 <quchen> kuribas: Check out my STGi program if you want to see the STG work! :-)
04:22:01 <quchen> ?google quchen stgi
04:22:03 <lambdabot> https://github.com/quchen/stgi
04:25:03 <ysangkok> i remember reading a paper of someone implementing java-like subtyping in haskell, probably even with Null.. i can't seem to find it... any hints?
04:29:07 <merijn> Wow, I already suspected it, but TMVars are *terribad* under contention
04:29:35 <merijn> like, 3 orders of magnitude terribad
04:29:52 <guest423> How can I convert [Shape] to [Double] where double is area from this example https://wiki.haskell.org/Existential_type#Dynamic_dispatch_mechanism_of_OOP ?
04:36:37 <matrium> hi, can I somehow "unlift" a moniadic function, when I'm in the right context?
04:36:47 <byorgey> guest423: you could define   getArea :: Shape -> Double; getArea (Shape s) = area s
04:36:51 <byorgey> guest423: then  map getArea shapes
04:37:14 <byorgey> matrium: I'm not sure what you are asking, can you give an example?
04:37:20 <matrium> I have a sorting function that runs in a Reader context
04:37:58 <byorgey> matrium: what is the actual type of your sorting function?
04:38:19 <matrium> but there's no such thing like a sortM :: (a -> m Ord) -> t a -> m (t a)
04:38:33 <Philonous> guest423, When you pattern-match on the Shape type you get a value which is an instance of the Shape_ class, so you can call area on it
04:38:56 <Philonous> so for example: getArea (Shape s) = area s
04:39:19 <Philonous> Errr, byorgey already answered, never mind then
04:39:33 <matrium> byorgey: sortObjects :: [Obj] -> MonadReader FormattingContext m => m [Obj]
04:39:44 <byorgey> Philonous: I think your extra explanation was probably helpful =)
04:40:26 <byorgey> matrium: OK, and when you say "unlift", what type would you like it to have instead?  [Obj] -> [Obj] ?
04:40:40 <Philonous> guest423, You could also make Shape an instance of Shape_, so you could call area directly on it. 
04:40:59 * byorgey likes Philonous's idea
04:41:47 <Philonous> guest423, It's generally a pretty bad idea, though. You're better off just defining a recoird type with perimeter and area accessors. 
04:41:56 <implementation> :t runReader
04:41:57 <lambdabot> Reader r a -> r -> a
04:41:59 <Philonous> s/accessors/fields
04:42:04 <implementation> this might help
04:42:32 <guest423> byorgey: thanks, is it possible to do something like this unwrap :: (Shape_ a) => Shape -> a;unwrap (Shape s) = s ?
04:42:34 <matrium> byorgey: sortBy :: (a -> a -> Ordering) -> [a] -> [a] only takes a non-moniadic ordering function
04:42:41 <byorgey> guest423: no, it is not
04:42:59 <matrium> but my ordering function is moniadic
04:43:09 <byorgey> guest423: because once you have a Shape you no longer know the type of the thing inside it.
04:43:32 <byorgey> guest423: notice that the type  (Shape_ a) => Shape -> a   means that given a Shape, it can produce *any* type that the caller of the function chooses!
04:43:42 <Philonous> You can have Shape -> (forall a. Shape_ a => a -> r) -> r though
04:43:53 <byorgey> guest423: but obviously it can't do that.  It could only produce the actual type of the thing that is inside the Shape wrapper.
04:44:18 <ventonegro> funny, was reading about that today
04:44:25 <matrium> byorgey: I would need something like "unlift :: (a -> m b) -> m (a -> b)
04:45:05 <implementation> matrium: that doesn't exist in general, but for Reader you can use runReader.
04:45:08 <byorgey> matrium: it is not possible to have such an unlift function in general.  It is possible for some specific m, though (e.g. Reader)
04:45:39 <matrium> Ok, thanks :-)
04:45:40 <guest423> thanks all
04:45:41 <byorgey> matrium:   If  fc :: FormattingContext,  then   (\objs -> runReader (sortObjects objs) fc) :: [Obj] -> [Obj]
04:47:39 <byorgey> more generally,  (ask >>= \fc -> return (\objs -> runReader (sortObjects objs) fc)) :: MonadReader FormattingContext m => m ([Obj] -> [Obj])
04:58:33 <nuclx> hey, where are packages installed to on windows when using 'stack install <pkg>'?
05:00:31 <quchen> nuclx: Check `stack path`
05:00:41 <quchen> It lists most (all?) directories Stack uses
05:03:44 <nuclx> quchen: ah, thanks for the tip
05:21:23 <exarkun> This is basically the example from the Data.Aeson docs, http://codepad.org/c4f6ADOz - but it fails to compile: ‘toEncoding’ is not a (visible) method of class ‘ToJSON’.  Yet it would certainly _appear_ to be a visible method of the class: https://hackage.haskell.org/package/aeson-1.2.0.0/docs/Data-Aeson.html#t:ToJSON
05:21:28 <exarkun> I wonder what I'm missing.
05:23:07 <byorgey> exarkun: there is an explicit import list which imports the name of the class but not any of the methods.
05:24:21 <byorgey> toEncoding is not visible because it is not imported.  Try changing it to  import Data.Aeson (ToJSON(..), ...)
05:25:13 <byorgey> sorry, to be clear, the first two dots are actual syntax, and the last three dots are metasyntax meaning I didn't want to write out the rest of the imports =)
05:29:15 <exarkun> byorgey: ah thank you
05:39:40 <merijn> Interesting...
05:39:56 <merijn> I seem to have managed to overflow Criterion's statistics, getting a negative runtime xD
05:51:21 <merijn> ok...I'm really confused how the hell criterion ends up benchmarking negative times...
05:53:03 <c_wraith> does it use the high-performance counter?  Because that counter rolls over really fast.
05:53:15 <merijn> I have no idea
05:53:34 <merijn> c_wraith: But these are runtimes in milliseconds and it's reliably measuring negative times
05:53:52 <exarkun> How do I do anything useful with a Data.ByteString.Lazy.Internal.ByteString (as returned by Data.Aeson.encode)
05:53:55 <merijn> Whereas I have experiments that are measured in multiple seconds which don't go negative
05:54:01 <c_wraith> Hmm.  maybe your code is just magical?
05:54:44 <merijn> c_wraith: Actually, I suspect one of the machines might just be broken..
05:55:03 <rightfold> exarkun: this is just a lazy ByteString
05:55:04 <c_wraith> that does seem more likely.  But even then, bizarre
05:55:30 <rightfold> exarkun: there are many operations on them, and you can turn them into strict ones. See the Data.ByteString.Lazy module.
05:55:34 <exarkun> rightfold: So .. I can use APIs from Data.ByteString.Lazy on it?
05:55:37 <exarkun> okay, thanks
05:55:40 <rightfold> Pretty sure yes
05:55:45 * exarkun tries that
05:55:48 <rightfold> It's the same type
05:56:05 <rightfold> Exported by multiple modules
05:56:21 <exarkun> confusing, but yea Data.ByteString.Lazy.putStr is working with this.  thanks.
05:59:10 <merijn> c_wraith: Usually I get runtimes between 2-5ms, but sometimes several microseconds or negative 2-20 ms >.<
05:59:59 <byorgey> merijn: perhaps you are travelling at a speed greater than the speed of light relative to your computer.
06:00:23 <byorgey> you know, one has to consider these things.
06:04:13 <Philonous> merijn, That just means the acausal compute engine is working properly :>
06:37:59 <merijn> Not getting great R^2 values either...
06:42:58 <merijn> The code that's acting up is: https://github.com/merijn/broadcast-chan/blob/master/benchmarks/Sync.hs#L78-L87
06:44:13 <merijn> Since it's a spinloop it might just be nasty outliers, but I'm not sure how to get a more reliable spinloop
06:45:15 <merijn> oh!
06:45:18 <merijn> Idea!
06:48:34 <merijn> Any linux experts here? Does anyone know if clock_gettime with CLOCK_MONOTONIC is threadsafe?
06:49:17 <mfukar> via POSIX, it's thread-safe unless explicitly stated otherwise
06:49:37 <mfukar> and there's no exception as far as i can see
06:49:52 <merijn> hmmm
07:01:07 <ertes-w> is there a portable library for file locking?  i specifically need shared and exclusive locks
07:01:23 <merijn> ertes-w: Good luck :)
07:02:41 <ertes-w> well, using 'unix' doesn't bother me too much, but if i ever release this library, people with questionable OS choices might benefit from it, too =)
07:02:57 <merijn> ertes-w: Even on unix you're fucked
07:03:05 <ertes-w> merijn: why?
07:03:15 <merijn> ertes-w: If the filesystem happens to be NFS it'll *look* like locking works, but it subtly and silently won't
07:03:36 <ertes-w> yeah, that's a fairly common caveat
07:03:38 <merijn> If anything, windows will give you better odds of sane locking
07:03:58 <ertes-w> but i can't really do anything about it, so i'll just document it
07:08:41 <vikings> join
07:09:12 <ertes-w> and BTW, that's why you don't use NFS =)
07:09:32 <vikings> i use NFS
07:12:27 <lambdamu_> Is there any lens machinery for references (IORef, TVar, etc.)?
07:14:30 <merijn> lambdamu_: To do what?
07:14:39 <ertes-w> lambdamu_: modifyIORef' (myLens +~ 15)
07:14:56 <ertes-w> modifyIORef' ref (myLens +~ 15)
07:14:59 <ertes-w> view myLens <$> readIORef' ref
07:16:34 <lambdamu_> hm yeah that's what I'm doing I thought about something, like: var & fromTVar . foo .~ True
07:17:05 <lambdamu_> but I see that this can't work with the lens signatures
07:17:53 <byorgey> lambdamu_: if you make an infix operator alias for modifyIORef you can even use it like & :    ioRef &# foo .~ True
07:18:20 <joelburget> splits
07:18:32 <lambdamu_> byorgey: that's nice, similiar to the monadstate operators
07:18:42 <byorgey> yep
07:19:12 <byorgey> I made up the name (&#), you can paint that bikeshed whatever color you want =)
07:20:00 <lambdamu_> now i just to pick one of the reference abstractions out there :D
07:20:18 <merijn> ugh
07:20:45 <merijn> I think it's part of the statistics/regression stuff breaking my measurements, but I don't understand that voodoo well enough to see what's fucking up
07:27:09 <merijn> Timing of NaN seconds...definitely something wrong...
07:58:46 <ertes-w> computers get slower, too, as they get older, so they charge less for cookies…  when their speed and cookie price matches your grandmothers', you experience nan seconds
08:14:26 <Sh4rPEYE> Could somebody here help me understand what's going on here?
08:14:26 <Sh4rPEYE> http://lpaste.net/1677977249338359808
08:14:37 <Sh4rPEYE> It is a simple example of using the State Monad.
08:18:05 <Sh4rPEYE> generator should be of type (s -> (a,s)) and I don't get why RandomR then works with that as a generator
08:19:06 <byorgey> Sh4rPEYE: no, generator is of type Int.
08:19:21 <byorgey> er, sorry, I mean type  StdGen
08:20:16 <Sh4rPEYE> In the code there is generator <- get, and because get is State f, generator should be of type f, no? And that is (s -> (a,s))
08:20:23 <geekosaur> Sh4rPEYE, a thing of type State s a is not a simple valuer, it is an action. "get" is such an action
08:20:34 <geekosaur> "generator" is the result of that action
08:21:03 <geekosaur> :t get
08:21:06 <lambdabot> MonadState s m => m s
08:21:08 <Sh4rPEYE> Oh, I though generator will be still the action. How come it is the result when I'm not passing anything to get?
08:21:50 <byorgey> Sh4rPEYE: because the do-block gets desugared into calls to >>= and so on, and behind the scenes the implementation of >>= for State is passing the current state to get
08:22:44 <bartavelle> Sh4rPEYE: "get" is the action of retrieving the state, it doesn't require any argument to be passed to, as can be seen in its type signature
08:23:05 <geekosaur> also don't confuse <- with =
08:23:20 <Sh4rPEYE> It was in the text that get = state $ \st -> (st, st)
08:23:30 <geekosaur> <- is not just "oh, that's = for monads", it's "perform the action"
08:23:33 <geekosaur> in some sense
08:23:34 <Sh4rPEYE> That'd put me on the wrong track I guess
08:23:52 <byorgey> there are two levels going on here.  At the abstract level, 'get' is a State action which does not require any argument.  It simply returns the current state.  The other level is the way the State monad is actually implemented, with s -> (a,s) functions.
08:24:11 <Lokathor> Sh4rPEYE, yes, and one side of the (st,st) tuple becomes the result of "get"
08:24:20 <Lokathor> that you see in your own function
08:24:21 <byorgey> Sh4rPEYE: I think the biggest problem is that you are confusing these two levels.  When working with do-notation you do not need to think at all about how State is actually implemented "under the hood"
08:25:13 <byorgey> Sh4rPEYE: I cannot tell, but you may also be confused about what <- means
08:25:56 <Sh4rPEYE> byorgey: That might be the case, too, as I'm not really familiar with monads and do-notation
08:27:59 <bartavelle> Sh4rPEYE: you might get started without really understanding what is going on, as long as you understand that when you have "a <- foo", foo is of type 'm x', where 'm' is the monad you are working with (here State StdGen), and 'a' is of type x
08:28:20 <bartavelle> and that the <- only works in do-notation
08:28:33 <bartavelle> :t get
08:28:35 <lambdabot> MonadState s m => m s
08:28:57 <bartavelle> so here, 'get' has type 'State StdGen StdGen'
08:28:59 <Sh4rPEYE> bartavelle: That's how I think about it... Almost as a way to strip themonad off of something, in a monad-specific way
08:29:35 <bartavelle> so generator has type 'StdGen'
08:30:15 <bartavelle> Sh4rPEYE: just look at the type of your functions, and forget for now how they are implemented
08:31:12 <bartavelle> Sh4rPEYE: my first real haskell program was a large parsec-parser, and I had no clue about monads, yet I managed to write it, after brute-forcing the type checker for a long time), so it is quite possible
08:39:14 <Jinxit> ^same
08:40:46 <Sh4rPEYE> Ok, I think I understand the basic things. Get is State StdGen StdGen, so generator is StdGen and it works. 
08:44:43 <byorgey> Sh4rPEYE: right
08:46:21 <Sh4rPEYE> So it makes sense considering types... But what does it mean to "get current state" I don't yet understand. Especially when I haven't yet set any.
08:47:16 <hexagoxel> :t runState
08:47:18 <lambdabot> State s a -> s -> (a, s)
08:47:56 <geekosaur> a computation of type State s a doesn't need to set state, it receives the state. runState is what injects an initial state value into a State computation
08:51:40 <Sh4rPEYE> I just need a break, I think. This is supposed to be simple stuff and I'm gazing into the monitor for an hour straight and haven't yet figured out five lines of code. I'll try in the evening. 
08:51:51 <Sh4rPEYE> Thanks everyone for help :-)
08:52:11 <bartavelle> gl!
08:52:35 <glguy> yes?
08:57:04 <geekosaur> heh
08:58:23 <glguy> If I don't protect gl™, it might slip into common use and ruin my trademark :-p
08:59:10 <bartavelle> haha, I am pretty sure others have it protected already ;)
08:59:16 <bartavelle> you can relax
08:59:30 <Lokathor> glguy, i've always wondered if you rose to power as the top GL progammer in the world
08:59:34 <Lokathor> I'll just assume that's true
09:20:40 <WhereIsMySpoon> Hey, anyone use intellij here would like to tell me which plugin I should use? HaskForce or Intellij-Haskell?
09:21:05 <WhereIsMySpoon> haskforce has loads more downloads but intellij-haskell seems to have been updated much more recently
09:30:10 <antoine9298> ping
09:30:52 <bollu> pong?
09:31:51 <WhereIsMySpoon> also whats the difference between building with stack and with cabal
09:48:25 <electrocat> WhereIsMySpoon: stack build your project including the dependencies using a stable snapshot of versions, while cabal has, ... issues. just use stack :p
09:48:26 <sproingie> WhereIsMySpoon: stack uses cabal
09:48:40 <WhereIsMySpoon> oki
09:48:50 <electrocat> sproingie: depends if you mean Cabal or cabal-install
09:48:57 <sproingie> cabal builds, stack solves dependencies.  mostly.  there's some overlap.
09:49:00 <WhereIsMySpoon> i tried learning some haskell a while ago and got some way but forgot it all :P
09:49:05 <WhereIsMySpoon> so now im gonna try again
09:49:20 <sproingie> WhereIsMySpoon: it's a lot faster the second or third time
09:49:22 <WhereIsMySpoon> gonna use learnyouahaskell again :)
09:49:25 <sproingie> this is like my third with haskell
09:49:30 <WhereIsMySpoon> i remember it being great last time
09:49:43 <torstein> How can I deserialize a Map String (String Int Int) from a file, given that it was written with 'show'?
09:49:52 <sproingie> LYAH is a bit out of date, some of it has functions in the wrong type classes now
09:49:55 <electrocat> torstein: 'read'
09:50:08 <WhereIsMySpoon> i see
09:50:17 <sproingie> LYAH is generally good imho til it gets all wall-of-text on you
09:50:27 <WhereIsMySpoon> would you rather recommend another one?
09:50:39 <sproingie> haskell from first principles is good
09:50:49 <sproingie> (not free tho)
09:51:19 <glguy> Hutton's Programming in Haskell is a good place to start
09:51:48 <WhereIsMySpoon> also not free it seems
09:51:55 <sproingie> bouncing between various haskell blogs was my approach, works ok when you have some basics down
09:51:55 <shapr> glguy: I just bought the 2nd edition, I'll compare it to my 1st edition.
09:52:06 <shapr> Dunno why I never got my 1st edition signed, maybe hutton will be at ICFP 2017
09:52:20 <shapr> edwardk: when will you write a book so I can get it autographed?
09:52:20 <sproingie> for learning features like GADTs and type families, just read the GHC docs
09:52:26 <WhereIsMySpoon> ill just use lyah for now and if it starts being really wrong ill switch
09:52:37 <WhereIsMySpoon> i dont even know what a gadt and type family is :P
09:52:42 <glguy> WhereIsMySpoon: You won't know if it's wrong until you know what's right though
09:52:53 <WhereIsMySpoon> i will if i type stuff in and it doesnt run
09:52:55 <WhereIsMySpoon> :P
09:53:01 <glguy> That's just he most extreme form of wrong
09:53:15 <electrocat> i learned the basics in college, and for a little more advanced stuff i used Real World Haskell, not sure if it's actually good though compared to other things available
09:53:17 <torstein> electrocat, yeah I get errors when trying in GHCi.. Assume I have: type SomeMap = Map ...; then doing (readFile "myfile" >>= read) :: IO SomeMap yields "No Instance for (Read (IO SomeMap))"
09:53:17 <sproingie> type families are good when you're making your own type classes.  GADTs are pretty good to learn early.
09:53:50 <glguy> You can get a LOT done and never need to worry about  GADTs
09:54:03 <sproingie> or type families.  or your own typeclasses for that matter.
09:54:39 <glguy> They're good to learn eventually, but not necessary to program productively
09:54:43 <sproingie> but once you start wanting existential types and fundeps, you probably want GADTs
09:54:45 <electrocat> torstein: 'read' isn't an IO function, try (read <$> readFile "myfile"), that's the same as writing (readFile "myfile" >>= return . read) but better
09:55:10 <torstein> gracias
10:10:35 <frew> I am trying to configure taffybar, which is haskell and gtk, to distinguish buttons on a click event
10:10:54 <frew> I wrote the following code, which I thought was close to correct: https://github.com/frioux/dotfiles/commit/34127e2eac9b09d1a37fce58f801efe3174d9b83
10:10:58 <frew> but it fails to typecheck
10:11:13 <frew> it looks similar to some other cases I found on github that are doing the same thing, I think
10:11:35 <frew> anyone see any obvious mistakes? I am pretty sure the _ -> _ is totally wrong, that's just because I want to ignore all other cases
10:11:58 <hsk3> This just worked:    import Heist.Compiled (Splice, yieldPureText)
10:11:58 <hsk3> Since when it is possible to put types into imports?
10:12:16 <hsk3> Was this possible before GHC 8?
10:12:32 <kadoban> I don't know what _ -> _  would do, probably nothing sensical.    _ -> return ()       might work, I don't know the type of "unsafeSpawn"
10:13:14 <frew> kadoban: I don't either, but I'm trying to discard it (note the return True afterwards)
10:13:26 <frew> but I guess the _ block needs to match
10:13:51 <kadoban> The branches of a case all need to match in type, yeah
10:16:17 <frew> kadoban: unsafeSpawn is from https://hackage.haskell.org/package/xmonad-contrib-0.11.1/docs/XMonad-Util-Run.html
10:16:27 <pie_> what are the key parts of modern functional langauges? expressive type systems, higher order functions, immutabiliyt, ...?
10:16:57 <kadoban> frew: It appears that I guessed correctly then
10:17:11 <frew> yeah I thoght so too.
10:17:23 <frew> so that fixes the hole.
10:17:46 <frew> but I still get: https://gist.github.com/frioux/a52a9fe6fc4907099296f7e6aa7966b9
10:18:00 <frew> *something* is wrong with my case but I'm not sure what or why
10:19:27 <pie_> *immutability
10:19:37 <frew> I think I need return or something like it to fix the type of Gtk.RightButton etc
10:20:23 <kadoban> frew: What's the type of Gtk.eventButton ?
10:20:46 <kadoban> https://www.stackage.org/haddock/lts-8.13/gtk-0.14.6/Graphics-UI-Gtk-Gdk-EventM.html#v:eventButton  this one probably?
10:20:56 <frew> yeah I thnk so
10:21:18 <frew> which it looks like the error message matches, but my code doesn't
10:21:28 <kadoban> So you likely need to do something like   butt <- Gtk.eventButton    and then  case butt of  [...]
10:21:55 <frew> ok so why is that diff from `case Gtk.eventButton` ?
10:23:01 <kadoban> Because eventButton isn't a MouseButton, it's an action that lets you query the MouseButton. Or something, I don't know Gtk or this code
10:23:12 <frew> sure I get it
10:23:22 <frew> I just assumed foo <- bar assigned the result of bar to foo
10:23:29 <frew> so they could be substitutable
10:23:49 <kadoban> In one sense it assigns the result of bar to foo, but I don't think they're ever substitutable
10:23:53 <frew> ok
10:23:58 <frew> let me try it
10:24:01 <frew> I almost did that but it seemed silly
10:24:33 <frew> wow that did it
10:24:49 <frew> thanks kadoban, I've been wrestling with this for too long :)
10:25:05 <kadoban> Anytime
10:25:50 <seequ_> (b <- Gtk.eventButton; stuff) is the same as (Gtk.eventButton >>= \b -> stuff) - not quite just assignment
10:26:11 <frew> so basically the problem here is htat I assumed a function in place of a value would be called
10:26:15 <frew> but that's not really true
10:26:21 <frew> and makes sense when I write it out
10:26:43 <seequ_> Understanding monads would be helpful.
10:27:00 <kadoban> I think of monadic actions, like Gtk.eventButton as "procedures" I think, though that's not quite correct. I would try to avoid thinking of them as functions, because functions are pure in haskell
10:27:24 <frew> good point
10:27:37 <frew> I am not even close to understanding haskell or monads
10:27:53 <frew> I'm cargo culting for now and picking up information as I go
10:28:22 <nshepperd> a function maps input values to output values. an IO action.. doesn't do that
10:28:50 <nshepperd> 'procedure' is a perfectly good term for IO actions, I think
10:28:51 <frew> yeah I understand the concept of pure functions
10:29:04 <frew> it's the Haskell specific stuff (ie I mostly understand ML) that is new to me
10:29:13 <kadoban> seequ_: I mostly think of it as "run this thing and then assign the value to this binding" (though that's not quite correct I'm aware). But it works for IO and IO-ish monads pretty well
10:29:23 <nuclx> can anyone explain why i encounter this error when trying to downgrade parsec from 3.1.11 to 3.1.3? 'stack build interim-demo' fails with: Error: While constructing the build plan, the following exceptions were encountered: In the dependencies for intero-demo-0.1.0.0: parsec-3.1.11 must match ==3.1.3 (latest applicable is 3.1.3) Plan construction failed.
10:29:49 <kadoban> nuclx: What did you do to downgrade parsec?
10:29:56 <cocreature> nuclx: have you added parsec-3.1.3 to extra-deps?
10:30:01 <kadoban> (why do you want to downgrade a library anyway? Did they add a bug?)
10:30:13 <nuclx> kadoban: trying to run some tutorials which apparently dont build with 3.1.11
10:30:19 <kadoban> Ah
10:30:53 <kadoban> That's ... weird. I wouldn't expect much to work with version 3.1.3 that doesn't with 3.1.11, in general.
10:30:58 <nuclx> cocreature: only to build-deps
10:31:13 <cocreature> nuclx: then add it to the extra-deps section in your stack.yaml file
10:31:23 <kadoban> Yeah, that should take care of it
10:32:02 <nuclx> kadoban: that's what was stated in the tutorial as well, anyways gonna try adding it to extra-deps and see if it works
10:34:14 <seequ_> kadoban: Instead of procedures, i recommend thinking of monads as opaque actions. (do x <- getLine; putStrLn x) is just a single action, or value if you prefer, that represents the action of reading a line and printing it. It itself does no such thing, but the handler that reads it will if given to it.
10:34:48 <nuclx> stack build fails now with: In the dependencies for parsec-3.1.3: /  text-1.2.2.1 must match >=0.2 && <0.12 (latest applicable is 0.11.3.1)   / needed due to intero-demo-0.1.0.0 -> parsec-3.1.3
10:35:45 <kadoban> nuclx: Sounds like that's just not going to work. Perhaps you can try moving stack.yaml elsewhere (to a new name) and then stack init and see if it can find a better resolver for you. Can try with --solver as well
10:35:54 <cocreature> nuclx: you need to add text-0.11.3.1 to extra-deps. alternatively you can try "stack solver" which should figure that out automatically
10:36:25 <cocreature> nuclx: or just show us the build error with parsec 3.1.11. I doubt that it’s hard to fix so that might be the easiest route
10:36:50 <kadoban> Both of those sound like good ideas too
10:37:05 <nuclx> cocreature: going back to 3.1.11, one sec
10:41:18 <nuclx> it's probably just some renamed imports: https://paste.ofcode.org/aEybAYDKNG4x2c8eSyAGZt
10:42:04 <nuclx> it tried to use the proposed names, but not all of them worked
10:43:02 <cocreature> nuclx: are you using this project? https://github.com/JakeWheat/intro_to_parsing
10:43:19 <nuclx> yeah
10:43:51 <cocreature> how are you trying to build it? it doesn’t seem to contain a cabal file
10:44:52 <nuclx> i put it into a project i created with stack new, based on the lts-8.13 resolver
10:45:41 <cocreature> the first two imports should probably work if you change them as suggested. the third means that you need to add FunctionsAndTypesForParsing to exposed-modules in your cabal file
10:52:58 <nuclx> cocreature: ok, great. got it to build.
10:53:06 <cocreature> nice
11:05:04 <sproingie> is there a way to tell cabal to expose everything, or do I have to list every .hs file in exposed-modules?
11:05:14 <sproingie> b
11:05:20 <kadoban> You have to list them, AFAIK
11:05:21 <sproingie> whup
11:05:49 <sproingie> bleh.  annoying when i forget a new file and get mysterious compile errors
11:06:07 <sproingie> well, usually not that mysterious
11:06:39 <kadoban> Yeah, it's pretty unfortunate. The worst is when you forget to add to other-modules and later get wacky errors. Though stack seems to warn me sometimes, or maybe that warning is from Cabal, dunno.
11:07:19 <sproingie> stack's default colors aren't helpful either.  dark gray on a black background, whee
11:08:21 <kadoban> Stack has default colors?
11:08:47 <kadoban> Of what, the warning outputs or something? I don't know if I ever noticed them being colored differently from usual text.
11:08:50 <sproingie> it colorizes output, and i didn't change anything, so there's some kinda default
11:08:59 <kadoban> Huh, weird
11:09:18 <sproingie> all compiler output comes out in dark gray, errors or not.  basically not useful.
11:10:39 <kadoban> That sounds bizarre. I don't think mine does that. Or maybe it's something to do with my terminal colors
11:12:09 <sproingie> huh i don't always get it either
11:12:51 <sproingie> ah "stack build" doesn't colorize, "stack run" does
11:13:21 <cocreature> yeah that’s the primary reason why I’m still using stack build && stack exec over stack run
11:13:27 <cocreature> the colors really annoy me
11:13:43 <kadoban> I didn't know stack run was a thing. I wonder if anyone has complained about that on the bug tracker ... sounds awful
11:13:50 <sproingie> i don't mind muting the compiler noise when the output from run is what you're looking for anyway
11:14:11 <sproingie> but i'd like to see errors colorized a lot more prominently
11:14:13 <cocreature> kadoban: it’s a separate package
11:14:19 <kadoban> Oh
11:14:41 <cocreature> kadoban: but stack looks for executables called stack-* so you can just execute "stack run" instead of "stack-run"
11:15:23 <sproingie> basically git's trick
11:15:26 <kadoban> Right, I think I remember that from back when it was just a couple of scripts to supplement cabal-install
11:15:48 <sproingie> accounts for why git's commands have such a consistent look and feel and command set :^)
11:16:36 <kadoban> xD unfortunately I don't think that's actually why for git, I'm not sure why git's UI is so wacky. Maybe just lack of planning.
11:16:49 <sproingie> git was more grown than built
11:16:55 <sproingie> tho for the kind of thing git is, that makes sense
11:17:27 <sproingie> (i see "whither darcs" has come back up on /r/)
12:29:50 <frew> I'm trying to figure out how to call https://hackage.haskell.org/package/gtk-0.14.2/docs/Graphics-UI-Gtk-Abstract-Widget.html#v:widgetSetTooltipText; it calls for a GlibString, and I can't seem to find a constructor for that
12:36:10 <verement> frew: GlibString is a class, of which both Text and String are instances
12:36:37 <frew> yeah that's what I thought
12:36:39 <frew> but
12:36:57 <frew> oh wait...
12:37:07 <frew> "Maybe text0" with [Char]
12:37:12 <frew> I need Just
12:38:47 <frew> ugh and now I'm back in haskell land.  (`Expected type: IO [Char], Actual type: Maybe [Char]`
12:39:09 <Rembane> frew: Welcome back
12:39:14 <frew> ;)
12:51:41 <frew> hm ok so I figured out how to set the tooltip, and I was trying to set it from within a callback since I need some of the values in the callback in the tooltip, but because the callback is an IO (I guess?) it errors when it's called from there
13:34:59 <fresheyeball> hello out there
13:35:07 <fresheyeball> I am giving this one more shot before I give up
13:35:15 <fresheyeball> is it possible to write a function like this
13:35:28 <fresheyeball> prepay :: Monad m => (a -> m b) -> m (a -> b)
13:35:35 <fresheyeball> cuz it sure seeeeems like it
13:36:19 <lyxia> no
13:36:22 <fresheyeball> Djinn says no
13:36:33 <mniip> no
13:36:42 <mniip> consider m ~ Maybe
13:36:54 <mniip> how do you turn (a -> Maybe b) into Maybe (a -> b)
13:37:43 <fresheyeball> mniip: strong counter example
13:40:30 <Squarism> if i want to do database transactions is "tsession" the package to use? It doesnt have a git repo or a homepage link. 
13:46:02 <fresheyeball> mniip: what if we specialize this function to IO?
13:46:18 <fresheyeball> prepay :: (a -> IO b) -> IO (a -> b)
13:49:18 <kadoban> I don't think that one is sensical either. You'd have to be able to yield a pure function, but what if one of the IO effects in the original is printing something depending on the value of type "a". You don't even have an ``a`` yet, but you have to do the effect already and give up a pure function.
13:49:19 <mniip> fresheyeball, then it gets worse
13:49:24 <mniip> you definitely cannot write that
13:51:28 <fresheyeball> mniip: prepay f = return $ unsafePerformIO . f
13:51:37 <fresheyeball> is there a way I can do that more properly?
13:51:40 <mniip> no
13:51:51 <mniip> if we imagine unsafePerformIO doesn't exist
13:51:53 <mniip> then no
13:58:37 <thang1> Is there a way to restructure the problem to avoid having an unsafePerformIO in the first place?
14:04:27 <flipflop> hi
14:05:23 <flipflop> is anybody here
14:05:40 <Gurkenglas> You can see previous discussion in the logs
14:09:51 <slack1256> any package that does import statement organisation?
14:10:01 <slack1256> for emacs if possible
14:10:14 <ertes> slack1256: haskell-mode can sort and align your imports automatically
14:10:40 <Mibaz> Can anyone explain the point of >> ? The internet says it's for "ordering operations"; I'm not quite grasping that. 
14:10:42 <ertes> slack1256: haskell-sort-imports, haskell-align-imports
14:10:51 <slack1256> really? maybe I haven't see such function nor set up a key
14:10:51 <Boomerang> slack1256: stylish-haskell
14:10:56 <ertes> Mibaz: are you familiar with (>>=)?
14:11:25 <Mibaz> ertes: yes, I think I have my head around that. (I understand how >> works, just wondering why it exists)
14:11:39 <ertes> Mibaz: as a shortcut
14:11:54 <ertes> Mibaz: and sometimes (>>) can also be implemented more efficiently than (>>=)
14:13:01 <Mibaz> ertes: Is there some kind of motivating situation that comes up often that requires x >>= \_ -> y  ?
14:13:09 <MarcelineVQ> ertes: do you know of any in isntances particular that's true for?
14:13:26 <tsani> Mibaz: do blocks
14:13:47 <ertes> Mibaz: no, because that's just an uglier version of (x >> y)
14:14:15 <ertes> MarcelineVQ: i think IO is such an instance
14:14:34 <Mibaz> ertes: right right, I was using it synonymously. "Is there some kind of motivating situation that requires >> ?"
14:14:39 <ertes> but it's hard to observe, because GHC will most likely optimise the (>>=) to the equivalent (>>) automatically
14:14:58 <ertes> Mibaz: tons of them:  forever, traverse, …
14:15:02 <ertes> err
14:15:03 <tsani> Mibaz: whenever you have a statement in a do block that doesn't use <-, it desugars to >>
14:15:04 <ertes> Mibaz: tons of them:  forever, traverse_, …
14:15:31 <slack1256> > putStrLn "hello" >> putStrLn "how are you"
14:15:33 <lambdabot>  <IO ()>
14:15:36 <slack1256> vs
14:15:47 <slack1256> > putStrLn "hello" >>= \_ ->  putStrLn "how are you"
14:15:49 <lambdabot>  <IO ()>
14:15:49 <Mibaz> tsani: Hm, interesting
14:16:08 <ertes> Mibaz: it's quite common to sequence two effects while ignoring their results
14:16:31 <ertes> putStrLn "Hello ..." >> putStrLn "... world"
14:17:19 <Mibaz> ertes: slack1256: Ok, I'm close to understanding. Could you give an example using Maybe where that's useful? (Maybe is simple to understand)
14:17:32 <ertes> Mibaz: 'guard'
14:18:35 <ertes> @let half x = guard (r == 0) >> pure q where (q, r) = divMod x 2
14:18:37 <lambdabot>  Defined.
14:18:44 <ertes> > half 4 :: Maybe Integer
14:18:46 <lambdabot>  Just 2
14:18:47 <ertes> > half 5 :: Maybe Integer
14:18:50 <lambdabot>  Nothing
14:19:15 <slack1256> ertes is the new slack1256
14:19:20 * slack1256 stars to fade away
14:19:52 <Mibaz> ertes: ah, so would 'x >> \_ -> y' essentially mean "If the value in our chain isn't nothing at this point, then it is y"?
14:20:11 <Mibaz> ertes: Just y, of course.
14:20:44 <Mibaz> ertes: In the maybe monad. Sorry that code example was not good ;)
14:20:54 <Mibaz> ertes: I'm talking about my code example, of course.
14:20:55 <ertes> Mibaz: unless you're in the ((->) e) monad, your expression is a type error
14:21:10 <ertes> heh
14:21:26 <ertes> Just _ >> my = my
14:21:30 <ertes> Nothing >> _ = Nothing
14:21:53 <Mibaz> ertes: Alright, I think I'm on board now.
14:22:03 <Mibaz> Thank you guys so much! You all rock, as always
14:22:46 <monochrom> I think >> was typo for >>=
14:24:16 <athan> Hey all, anyone here familiar with monad-control?
14:25:08 <athan> I'm wondering if anyone here has needed `StT t a -> a` or `StM m a -> a` functions
14:25:20 <stphrolland> in this video: https://begriffs.com/posts/2017-04-09-monad-tutorial-workshop.html    at    -52:21   , I have a problem, the speaker explain that join can be define like   join mma = mma >>= id     but according to me and to ghci the id function is not a kliesli arrow, but an effectless function. Could you confirm, I'm puzzled, I'm afraid I miss the point.
14:25:22 <athan> so you can use `runInBase` more usefully
14:26:00 <stphrolland> Is the speaker wrong on this point like I think he is, we cannot bind with the id function as second parameter ?
14:26:01 <athan> I'm considering forking it, and exposing the `StT`/`StM` types as a multiparam type variable, then making an `Extract` typeclass which would allow someone to work with those expectations
14:26:38 <ertes> athan: what would the latter do for IO or for ((->) e)?
14:26:42 <athan> because I'm not sure if all monadic-trans states could have _exactly one_ `a` given a `m a`
14:27:04 <athan> ertes: it's a class, so only the StT's which support it would actually do so
14:27:10 <athan> but I'm pretty sure those instances are just `id`
14:27:22 <athan> `type StM IO a = a`
14:27:36 <ertes> athan: well, Writer could support it, too
14:27:41 <athan> `type StM (Reader r) a = a`
14:28:01 <athan> ertes: yeah I think you're right
14:28:20 <athan> I'm just not sure if there would always be exactly _one_ subject value in any monadic value
14:29:38 <lyxia> athan: MaybeT   has   StT MaybeT a = Maybe a
14:30:43 <athan> Ahh perfect, thank you lyxia 
14:30:56 <athan> that's why the Extractable class needs to be optional
14:31:52 <ertes> athan: please don't call the function 'extract' =)
14:32:06 <athan> yeah :\ I need to think of a better one
14:32:14 <ertes> just a different one
14:32:15 <athan> `takerOuter`
14:32:28 <ertes> extract :: (Comonad w) => w a -> a  -- because of this one
14:32:37 <athan> yeah I'm familiar
14:32:49 <mckeankylej> Does applicative do not work? When I turn it on it still gives me an error than my applicative isnt a monad when I use it in a do block. I am also sure my code doesnt have any data dependencys
14:32:57 <athan> I'll relate it to the "Monadic Value" term
14:33:16 <ertes> mckeankylej: you need -XApplicativeDo, if you want that
14:33:59 <mckeankylej> ertes: {-# LANGUAGE ApplicativeDo #-} is at the top of my file
14:34:08 <lyxia> mckeankylej: ApplicativeDo is overly restrictive about what it accepts, that may be the issue
14:34:18 <ertes> mckeankylej: be sure that you don't write something like this:  pure $ …
14:34:27 <lyxia> show us your code
14:34:29 <kadoban> mckeankylej: Can you lpaste an example and the error message?
14:35:00 <ertes> mckeankylej: pure $ x + y = ($) pure (x + y), which does not match the pattern that ApplicativeDo expects
14:35:16 <ertes> pure (x + y)  -- this is fine
14:36:38 <mckeankylej> ertes: kadoban: lyxia: http://lpaste.net/355408
14:37:08 <mckeankylej> the thing inside that do is not a monad
14:37:22 <lyxia> use return
14:37:55 <ertes> 'pure' should work though
14:37:57 <mckeankylej> lyxia: that didnt help
14:38:21 <lyxia> mckeankylej: then also try rewriting the first statement to   "_ <- Form.static ..."
14:38:31 <lyxia> it should but it currently doesn't.
14:38:38 <mckeankylej> lyxia: wooooooo
14:39:07 <mckeankylej> Thats crazy to me that applicative do cant figure that out but thanks lyxia that worked
14:39:17 <ertes> ah, so it wants explicit bindings?  that's really weird
14:39:28 <frew> I have an `IO Gtk.Widget` and I want to "get the widget out."  I thought that I should use `liftIO w` to do that, but that gives a type error; any ideas? Code and error here: https://gist.github.com/frioux/b09aecbfdb7a3b5f53e6f36f14de91c2
14:40:18 <lyxia> mckeankylej: ApplicativeDo needs a lot of polishing. It's still very experimental.
14:40:51 <ertes> lyxia: 'pure' does work, i've verified
14:41:05 <ertes> it has worked for me in the past, too
14:42:29 <lyxia> oh, it does. My bad. I guess I was confused with another issue involving rebindable syntax.
14:49:16 <frew> ok so I'm trying to get this widget "out" of the IO, and I used `unsafeDupablePerformIO`; and everything typechecks and runs, but as far as I can tell the code is not running
14:49:54 <frew> https://gist.github.com/frioux/b09aecbfdb7a3b5f53e6f36f14de91c2#file-code-hs-L27-L31 <-- current code
14:52:34 <lyxia> why unsafe...PerformIO rather than   w <- mem
14:53:27 <monochrom> XYX problem: Extract out of IO so you can later inject into IO again.
14:54:24 <frew> lyxia: I dunno, I just searched hoogle for :: IO a -> a
14:54:34 <frew> monochrom: I don't follow
14:54:59 <kadoban> frew: Anything with unsafe in the name you probably shouldn't be using unless you have a strong reason really.
14:55:07 <frew> I believe it
14:55:11 <thang1> I'm guessing it's a riff off of the XY problem. You ask for X instead of how to do Y? It's a common problem among beginners
14:55:28 <Tuplanolla> @where xy
14:55:28 <lambdabot> http://xyproblem.info/
14:55:30 <frew> thang1: I know what he means, but I thought he was implying a solution too
14:55:40 <frew> lyxia: https://www.haskell.org/hoogle/?hoogle=PerformIO ?
14:56:26 <lyxia> don't look for a IO a -> a
14:56:28 <clamchowder> Hello #haskell, I'm trying to understand the pandoc code because I want to write a new Reader. Does the pandoc deconstructed youtube video (https://www.youtube.com/watch?v=FEFETKhhq8w) describe the current version well? Or is outdated?
14:56:45 <clamchowder> Or is *it outdated?
14:58:39 <jle`> frew: any 'IO a -> a' is a hack
14:58:50 <lyxia> frew: w <- mem  is how you bind w to the widget.
14:58:50 <frew> jle`: so how do I do what I want to do?
14:58:51 <c_wraith> frew, the rule with any function with "unsafe" in the name is that you need to know what is unsafe about it before you can even consider using it. (and then you still need to consider it carefully) 
14:59:03 <jle`> frew: what do you want to do with the widget?
14:59:07 * frew looks up w <- mem
14:59:25 <frew> jle`: set a tooltip in a callback where the data for the widget is being loaded
14:59:42 <jle`> frew: what function do you use to set the tool tip?
14:59:54 <jle`> if you're in an IO do block, you can bind the result of your widget-maker with <-
14:59:55 <frew> `Gtk.widgetSetTooltipText w str`
15:00:03 <jle`> are you familiar with how to work with IO in haskell?
15:00:08 <frew> I am not
15:00:13 <jle`> ah yeah, that might be a good first step
15:00:17 <frew> I know :/
15:00:23 <frew> but I'm *soo* close ;)
15:00:24 <jle`> what is the type of widgetSetTooltipText w str?
15:00:27 <jle`> do you know how do blocks work?
15:00:31 <frew> I think so?
15:00:41 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml
15:00:50 <jle`> an 'IO Widget' is not a widget
15:00:53 <frew> jle`: fwiw the code is here: https://gist.github.com/frioux/b09aecbfdb7a3b5f53e6f36f14de91c2#file-code-hs-L27-L31, the function is https://hackage.haskell.org/package/gtk-0.14.2/docs/Graphics-UI-Gtk-Abstract-Widget.html#v:widgetSetTooltipText
15:01:05 <frew> monochrom: thanks, loading
15:01:33 <frew> jle`: I know that, that's why I was doing this whole thing
15:01:55 <frew> (note: I am probably totally confused)
15:02:12 <jle`> it's ok :)  it will all be clear shortly
15:05:36 <Tuplanolla> Should I expect `sum (replicate n dx) <= n * dx` to hold with IEEE 754?
15:06:30 <frew> hm
15:06:48 <frew> jle`: so this would make sense to me if setTooltipText wanted an IO
15:07:23 * frew keeps reading
15:08:40 <monochrom> Tuplanolla: round-to-even is the default, but it means rounding up sometimes, and you may get >
15:08:58 <frew> huh ok
15:09:12 <c_wraith> frew, the big thing to learn is that there are ways to apply a function that takes a non-IO value to an IO value, and putting the result into IO. 
15:09:13 <frew> so this makes more sense to me, but as far as I can tell nothing is happening, still
15:09:21 <Tuplanolla> How about with a little margin, monochrom?
15:09:35 * frew updates gist
15:09:45 <monochrom> Then it works. The hard part is setting a good margin. :)
15:09:50 <Tuplanolla> At least `==` may not hold even with a great margin.
15:10:21 <frew> so here's what I have now: https://gist.github.com/frioux/b09aecbfdb7a3b5f53e6f36f14de91c2#file-code-hs-L23-L30
15:10:28 <frew> it compiles and runs without errors
15:10:38 <frew> but the tooltip never shows up, making me think that something is not ever running
15:10:46 <frew> presumably something is too lazy
15:10:49 <monochrom> In general, floating-point-op(x, y) = round(ideal-math-op(x, y)). "round" depends on rounding mode, a config thing, but default is round-to-even and no one really bothers to change it behind your back.
15:11:00 <frew> guessing it has something to do with the _ <-
15:12:02 <chilli> noob here, trying to read frames from a bytes stream, frames start with a Word32 length n and then n bytes .. i have a function that reads the length and then the data, how can i loop this over the bytestream to read a list of frames? 
15:12:11 <Tuplanolla> Well...
15:12:45 <Tuplanolla> I don't really see how to construct a counterexample.
15:15:36 <vimalloc> Haskell and funtional programming noob here, looking for feedback if anyone is feeling particularly bored at the moment :)
15:16:05 <chilli> vimalloc: i'll take a look
15:16:07 <vimalloc> I'm building a solver for a bridges game. So far I just have how I am encoding the data, as well as a function to print it out in a nice readable manor. I would love any critiques of things I am doing stupidly or not in a very 'haskell-y' way. https://gist.github.com/vimalloc/369f979c8c9d5993694fcc5691d3efb4
15:16:14 <vimalloc> thx chilli :)
15:16:14 <chilli> vimalloc: but i'm also a noob
15:16:17 <vimalloc> hehe
15:17:52 <Tuplanolla> Drop those aliases and look into `Enum` for `Value` things, vimalloc.
15:18:31 <vimalloc> Tuplanolla: Will do
15:18:40 <kadoban> chilli: type Islands = [Island] strikes me as probably not a great idea usually
15:18:58 <chilli> http://lpaste.net/355409 -- anyone got a minute?
15:19:08 <c_wraith> chilli, the general strategy is to split the bytestring before recursing. 
15:19:26 <kadoban> Oh, that was to vimalloc, wrong person.
15:19:36 <vimalloc> :)
15:19:58 <Cale> vimalloc: getIslandAtPoint's case expression looks like it's the identity
15:20:19 <chilli> c_wraith: i feel i could do this with a regular list, but using the Get reader is confusing me a lot
15:20:57 <mniip> vimalloc, bridges game?
15:21:26 <Cale> mniip: https://www.chiark.greenend.org.uk/~sgtatham/puzzles/js/bridges.html
15:21:29 <vimalloc> mniip: These http://www.puzzle-bridges.com/
15:21:35 <c_wraith> chilli, oh, you're using a serialization library? that simplifies things in some ways. 
15:21:39 <mniip> ooh
15:21:41 <vimalloc> Play em all the time when I'm board at work :)
15:21:44 <mniip> I remember seeing those before
15:22:34 <vimalloc> Cale: identity as in a == a?
15:22:37 <chilli> c_wraith: yeah, using Data.Binary .. it was all going well until I needed to loop
15:22:50 <chilli> vimalloc: identity as in `id`
15:22:58 <chilli> it always returns the input
15:23:06 <Cale> vimalloc: As in id x = x
15:23:28 <Cale> vimalloc: That is, you could also just write  getIslandAtPoint islands p' = find (\(Island p _) -> p == p') islands
15:23:56 <vimalloc> Cale: Oooh. I get it. Thx
15:24:54 <Cale> You could also write pointBetweenBridges using find.
15:25:25 <Cale> pointBetweenBridges p = find (pointBetweenBridge p)
15:25:35 <c_wraith> chilli, how comfortable are you with the monad interface? 
15:26:22 <vimalloc> Ah ha! I could indeed. 
15:26:52 <c_wraith> chilli, or in other terms, with using do notation? 
15:27:13 <Cale> vimalloc: Your question about how to solve the problem of invalid bridges using types is interesting. Perhaps you could represent a bridge using a single starting point and a direction
15:27:55 <chilli> c_wraith: just finding my way, i get the concept but the syntax often surprises me
15:28:09 <mniip> hum
15:28:09 <vimalloc> Cale: That's a very interesting idea, I didn't think of that. I'll ponder it some
15:28:12 <mniip> getting a deja-vu here
15:28:13 <thang1> Cale: I feel like representing valid bridges using types is a very slippery slope into full on type programming and dependent types
15:28:18 <Cale> But then you would either need to know where the islands are to know where the bridge ends, or the length of the bridge
15:28:22 <mniip> probably one of my british friends introduced me to that website before
15:28:43 <Cale> thang1: Nah, in this case, I think there's some fat in the representation that we could trim.
15:28:57 <thang1> Ah, okay.
15:29:06 <c_wraith> chilli, well, Get provides a helpful function - https://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary-Get.html#v:isEmpty
15:29:37 <Cale> mniip: I too am experiencing a little bit of deja vu -- I think someone else has asked about this very problem at some point in the past.
15:30:56 <chilli> c_wraith: thanks, i'll give that a go
15:31:25 <c_wraith> chilli, so readChunks will look basically like.. check to see if the stream is empty. if it is, return []. if it's not, read a chunk, recursively call readChunks, and return the combined result list. 
15:31:33 <frew> ok so I think I understand monads, and I *think* my code makes sense wrt monads, but it looks like this line of my code (https://gist.github.com/frioux/b09aecbfdb7a3b5f53e6f36f14de91c2#file-code-hs-L37) is simply not running; it's hard to tell since I'm not sure how I could debug further, but the tooltip is not showing up and placing that line of code elsewhere (with a static string) works
15:31:43 <c_wraith> chilli, that description might actually be longer than the code. :) 
15:33:30 <Cale> frew: Do the other occurrences of 'pollingGraphNew' work?
15:33:40 <frew> I have none with tooltips yet
15:33:47 <frew> everything works except for the tooltip right now
15:34:15 <Cale> Maybe stick a putStrLn in there just so that you can be sure it's running.
15:34:35 <frew> I am pretty sure it is since the graph itself is showing values
15:34:39 <frew> but not a bad idea
15:34:41 <frew> sec
15:34:43 <Cale> ah, fair enough
15:34:52 <Cale> If it's running, then the reason for not seeing the tooltip probably has more to do with GTK than with anything on the Haskell side of things
15:35:58 <frew> yeah added putStrLn tooltip and it's printing values every second.
15:36:29 <c_wraith> I wonder if you are just not allowed to change UI structures during a callback. 
15:36:42 <c_wraith> or some limited form of that. 
15:36:53 <frew> I just don't see how that could be implemented?
15:37:34 <c_wraith> frew, it could be a thread thing.
15:37:42 <frew> yeah...
15:37:45 <frew> that would make good sense actually
15:37:53 <frew> because at least the weather widget could be really slow
15:38:08 <chilli> c_wraith: got it! thanks for the help
15:38:21 <c_wraith> chilli, nice. 
15:38:38 <frew> ok, I'll take it to the author of the widgets, thanks folks
15:39:21 <vimalloc> This is the code with all your suggestions: https://gist.github.com/vimalloc/369f979c8c9d5993694fcc5691d3efb4
15:39:24 <vimalloc> Thanks guys :)
15:40:05 <vimalloc> One last question, if you don't mind. Is having those nested case statements bad practice? I dunno what it is, but I don't really like looking at that code.
15:40:51 <kadoban> vimalloc: ``minimum [y1, y2]``  is a little funny. You can use  ``min y1 y2``   for that
15:41:02 <vimalloc> kadoban: cool, thanks :)
15:41:03 <kadoban> It works, it's just a little roundabout looking
15:41:22 <vimalloc> ok
15:42:23 <kadoban> vimalloc: One thing in the code that worries me is ...
15:42:26 <kadoban> > minimum []
15:42:28 <lambdabot>  *Exception: Prelude.minimum: empty list
15:42:57 <vimalloc> That's a nifty bot
15:43:00 <kadoban> vimalloc: So pprint and etc. will just crash if you have empty lists. I'm not sure if that's as it should be or if there's a better way to handle that (depends on what this all does I think, if empty lists are ever expected)
15:43:11 <c_wraith> vimalloc, I can understand your objection to that nested case, but the only way I'd consider changing that is pulling those pieces into helper functions. 
15:43:48 <c_wraith> vimalloc, there's nothing inherently wrong with nested cases, but that example is pretty dense because of how much else is happening 
15:45:15 <vimalloc> kadoban: Thanks for the heads up there. I'll think on that. An empty list mean an invalid puzzle, but having a better error message then just crashing would obviously be better
15:45:33 <vimalloc> c_wraith: Awesome, thanks for the feedback
15:46:10 <kadoban> Yeah, sometimes crashing is fine, sometimes it's not that great. Something in the 'safe' package could help (even if you just want to crash with a more specific error)
15:46:11 <Tuplanolla> One good approach would be to try to figure out how an empty puzzle would make sense, vimalloc.
15:48:32 <Tuplanolla> For example it is completely reasonable to say that a zero-dimensional ball has a volume of one and a surface area of zero.
15:49:41 <thang1> Is there any particular reason for the choice of all the symbols in this paper or did they just choose them 'cause they look pretty? https://pdfs.semanticscholar.org/fec6/b29569eac1a340990bb07e90355efd2434ec.pdf
15:51:51 <dmwit> thang1: pretty
15:52:02 <entuland> thang1, what symbols do you refer to exactly?
15:52:03 <dmwit> (the silly names are for aesthetics, too)
15:52:31 <dmwit> But people will generally recognize the more formal names. Anamorphism, catamorphism, hylomorphism are all well-known here.
15:52:34 <jle`> frew: not sure if your question was answered, but regarding what you pinged me with earlier
15:52:44 <jle`> you can turn any function that takes an 'a' into a function that takes an 'IO a'
15:52:58 <thang1> On page 15, for example, "a simple calculation shows that average = DIV * (| ( O* downtriangle (+) * id|| weirdPi uptriangle .....
15:52:59 <jle`> using fmap/bind/etc. and friends
15:53:02 <dmwit> :t (=<<)
15:53:03 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:53:47 <thang1> dmwit: I have no issue with the names. I was just wondering if there was any prior mathematical precedent to the downtriangle, uptriangle, weird Pi variant, (| |) style brackets, etc
15:53:49 <dmwit> :t fmap -- or if your function doesn't already do IO...
15:53:49 <entuland> thang1, most of the symbols there are very precise mathematical symbols
15:53:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:54:02 <entuland> I don't know if they added their own there thang1 
15:54:30 <dmwit> thang1: The symbols have been around a long time. I don't think their connection with the various kinds of morphisms is a convention anywhere but this paper.
15:54:32 <entuland> but they surely serve a very precise purpose, perhaps they didn't "invent" any new symbol there
15:54:59 <dmwit> thang1: tl;dr: pretty =)
15:55:27 <thang1> Right. I knew they didn't invent any new symbols, I was just curious as to whether the symbols had a prior established connection to the *isms or if they just chose symbols and stuck them into the isms to get all their code to look like APL :p
15:56:15 <entuland> for sure they are using at least one symbol with a double meaning there
15:56:37 <entuland> the "cross" (so to say) symbol besides of Maarten Fokkinga at page 1
15:56:56 <entuland> is also used as the symbol for the bifunctor at chapter 3
15:57:09 <mniip> now I want to make a nonogram solver in haskell
15:58:05 <dmwit> mniip: Do you want to make it, or do you want it to exist?
15:58:25 <mniip> implementing it sounds like an interesting task
15:58:41 <dmwit> yeah =)
15:59:27 <thang1> What's a nonogram solver?
16:00:34 <Tuplanolla> @google ioccc nonogram
16:00:36 <lambdabot> http://www.ioccc.org/2011/hamaji/hint.html
16:00:36 <lambdabot> Title: Best solved puzzle
16:03:25 <thang1> oooh got it
16:08:05 <mniip> thang1, stuff like this http://tcpst.net/i3kx.png
16:09:34 <thang1> that's pretty cool. I'd like to see a good solver for that in Haskell
16:09:46 <thang1> (I have to go before rush hour kicks in and totally messes up traffic)
16:16:31 <Cale> mniip: I'd really like to see a good nurikabe generator
16:27:42 <entuland> well this is weird, the link there on ioccc pointing to codegolf.com doesn't work
16:27:58 <entuland> pinging it from the command line resolves to localhost :/
16:28:07 <entuland> and I don't have anything weird in my hosts file
16:28:25 <entuland> I must have a screwed up DNS
16:29:12 <Maxdamantus> fwiw, it resolves to 127.1 fo me too
16:29:21 <entuland> really?
16:29:29 <entuland> there must be something weird going on there
16:29:42 <entuland> because I swear I opened that site sometimes in the past
16:31:01 <entuland> uhm... even some online tools return localhost for that domain...
16:33:11 <Maxdamantus> Yes, it's quite definitely set to resolve to 127.1
16:33:52 <Maxdamantus> it's cached in the tld server things, and the nameservers it points to alsoreturn 127.1
16:34:34 <entuland> great
16:39:25 <wizwizwizwiz> i'm realizing that as i write a sql-backed web application that sql doesn't necessarily gracefully handle multiple simultaneous users trying to manipulate the database
16:39:53 <wizwizwizwiz> that and establishing ORM is redundant and kind of a waste of time
16:40:39 <wizwizwizwiz> so i am wondering whether it's a common thing to model data, especially in the style of relational databases in haskell
16:40:54 <wizwizwizwiz> and then have some kind of persistent storage and query system, sort of in the general style of sql
16:40:58 <koala_man> isn't that the CI in ACID?
16:41:23 <wizwizwizwiz> well, the problem is that the "types" which you use in your sql database may not be adequate
16:41:52 <koala_man> A and I I guess.
16:42:08 <koala_man> how do you mean?
16:42:44 <koala_man> are you building more complex types spanning multiple tables?
16:43:02 <wizwizwizwiz> i may not necessarily be able to represent my type adequately in sql
16:43:21 <mniip> noooooo
16:43:32 <mniip> I messed something up and got a conflict
16:43:53 <wizwizwizwiz> consider a database of students
16:44:13 <wizwizwizwiz> and classes and grades
16:44:20 <koala_man> ok
16:44:36 <wizwizwizwiz> with multiple users modifying each table simultaneously
16:44:43 <robkennedy> Has anyone looked into something like {-# language OverloadedStrings! #-}  that would have compile time error for fromStrings that didn't parse? Is there a deeper reason for that?
16:45:06 <koala_man> wizwizwizwiz: seems right up sql's alley. go on
16:45:09 <wizwizwizwiz> it isn't hard to imagine various problems which resemble issues "multithreading"
16:45:12 <robkennedy> *is there a deeper reason for why that isn't true
16:45:17 <wizwizwizwiz> issues from "multithreading"
16:45:45 <wizwizwizwiz> for instance an administrator might need to add or remove students from a table
16:46:03 <wizwizwizwiz> and immediately simultaneously a professor might be adding or removing students from a class grade table
16:46:11 <wizwizwizwiz> (possibly with blank, unfilled grades)
16:46:34 <koala_man> wizwizwizwiz: I see. Your operations are not in the same transaction. 
16:47:06 <wizwizwizwiz> now, the administrator could have a telephone call with the professor
16:47:09 <wizwizwizwiz> and coordinate
16:47:11 <robkennedy> The current implementation leads me to believe that OverloadedStrings comes at a cost. It seems like OverloadedStrings should be template haskell
16:47:23 <erisco> robkennedy, there isn't supposed to be parse errors
16:47:28 <wizwizwizwiz> but then we need lots of phone calls and soforth, and really if things are being handled well, the software should prevent screw-ups
16:48:06 <monochrom> Two conflicting administrators may be phoning the prof, and now the prof has a race condition. :)
16:48:07 <robkennedy> Ericso: life is tough, and then you die
16:48:13 <wizwizwizwiz> right :)
16:48:35 <erisco> robkennedy, if there is a parse error then your type isn't really a string
16:48:44 <robkennedy> "if it compiles" is a promise 
16:49:04 <koala_man> wizwizwizwiz: in sql, all operations that should be performed as a unit needs to be in a transaction. that's tricky in a web interface because clicking buttons are not part of the transaction
16:49:17 <wizwizwizwiz> well nevermind the web aspect
16:49:36 <erisco> if you want to convert a string to some other type look at Read or other deserialisation libraries
16:50:13 <koala_man> wizwizwizwiz: it's not a problem on the sql side alone. if you look up a student and then add a grade for that student, that student is guaranteed not to be deleted in the mean time
16:51:09 <monochrom> sql does have this "transaction" thing for atomicity of compound operations like this lookup-then-update.
16:51:25 <glguy> When did it get those?
16:51:35 <erisco> robkennedy, because the string is a constant I assume that it is evaluated aggressively. I am not sure, but it is certainly possible to do so
16:51:49 <monochrom> When it got "BEGIN TRANSACTION"?
16:52:46 <wizwizwizwiz> except that you might do something like
16:52:57 <wizwizwizwiz> grab some data from a sql database
16:53:03 <wizwizwizwiz> run a task which takes four hours
16:53:12 <wizwizwizwiz> then update that data in the sql database
16:53:29 <wizwizwizwiz> ... so that's a four hour transaction?
16:54:02 <monochrom> Yes.
16:54:35 <wizwizwizwiz> and it may be difficult to determine where in the database modifications occur
16:54:42 <monochrom> IIRC the catch is when you finally say "END TRANSACTION" the database is entitled to say "fail".
16:54:43 <wizwizwizwiz> i'm imagining that this ends up behaving like the entire db being locked
16:55:12 <wizwizwizwiz> so if, during that four hour period, if somebody tries to do something, they are out of luck
16:55:29 <monochrom> No, it's more funny than that.
16:55:46 <wizwizwizwiz> ok, what then?
16:55:49 <koala_man> wizwizwizwiz: determining where modifications occur is the DB's problem, and they do it very well. 
16:56:22 <monochrom> During the lengthy transaction, the database can do a multiverse thing. When you end, the database tries to merge. But it can say "I don't know how to merge, I need a drink".
16:56:45 <wizwizwizwiz> haha
16:56:49 <wizwizwizwiz> ok
16:57:19 <koala_man> in that case, it'll be (to the state of the database) as if you never did anything. even if you deleted a bunch of stuff before you started this four hour process.
16:57:37 <monochrom> In fact IIUC the multiverse thing is why PostgreSQL needs you to run a GC command every once in a while.
16:59:01 <monochrom> But yeah, it's still atomic. Atomically success, or atomically fail. All or nothing. Better than something.
16:59:56 <monochrom> Whereas Haskell's STM is a "failure is not an option" and it may keep retrying forever.
17:00:22 <wizwizwizwiz> well,... in my case failure isn't really an option :/
17:00:25 <wizwizwizwiz> lost data isn't cool
17:00:56 <monochrom> You can code up your own retry.
17:01:15 <koala_man> there's no lost data. though if you spent those four hours making promises you can't keep, that's your business and not the DB's fault
17:01:46 <monochrom> Not so much lost data as lost opportunity.
17:02:03 <wizwizwizwiz> ... i'm also having weird troubles with foreign keys in mysql
17:02:24 <wizwizwizwiz> i don't remember the details clearly enough to ask about them but
17:02:38 <wizwizwizwiz> i've had two tables with identical foreign key entries
17:02:43 <wizwizwizwiz> one has no issue, the other complains endlessly
17:02:56 <wizwizwizwiz> i've even copy/pasted the foreign key definitions
17:02:59 <monochrom> Like maybe there is a cash prize for "get your mark accepted before noon for a chance to win $10" but your transaction keeps failing before a hundred other people are also doing it.
17:03:01 <wizwizwizwiz> and that's also with the tables blank,...
17:03:11 <wizwizwizwiz> haha
17:05:05 <wizwizwizwiz> what about the "ORM redundancy" issue?
17:06:49 <wizwizwizwiz> i have to define my tables/types in sql
17:06:58 <wizwizwizwiz> and then re-define them in my code (in this case, python)
17:19:49 <robkennedy> ericso: sorry for late follow up. I think I'm looking for Template Haskell.
17:21:21 <erisco> robkennedy, you can write a quasi-quoter and employ a library such as Parsec. If the parse fails you throw an error in the QQ and the compilation will fail with the error message
17:21:56 <erisco> robkennedy, I used this to implement regex strings
17:24:13 <erisco> robkennedy, this may help you as a reference https://github.com/erisco/regex-tdfa-quasiquoter
17:42:32 <justkkay> When we search inside a hash table, how do we find a value that was moved due to collisions using linear probing?
17:43:44 <erisco> been a few years... but as I remember it you just keep traversing forward (and roll over when necessary)
17:44:26 <erisco> so the first collision goes in the slot after, and the second in the second slot after, and so on
17:44:40 <justkkay> hmm, so I'm guessing we start with the hash value as a base, then move forward until we find it ?
17:44:50 <erisco> that's right
17:45:53 <erisco> "linear probing searches the table for the closest following free location and inserts the new key there" https://en.wikipedia.org/wiki/Linear_probing
17:46:45 <mniip> ListT IO is lawful, right?
17:46:51 <mattn> we (EvanR, dmwit) had a discussion last night about why only certain types (and newtypes of those) can be marshalled via the FFI. For my project, I wanted to be able to marshal more general types, such as “data EA = BadEA | EA Word64”, where BadEA is represented on the FFI side by a magic number. 
17:46:57 <jle`> mniip: well
17:47:16 <mattn> stemming from that conversation, I added a typeclass for marshalling values to and from the FFI to my code
17:47:35 <mattn> would it be worthwhile to split that out into a small package?
17:48:04 <erisco> hashes aren't so functional though, last I knew
17:48:45 <erisco> moreso an exploit of the memory addressing hardware
17:54:31 <wizwizwizwiz> so is there a way to do away with ORMs?
17:54:49 <johnw> wizwizwizwiz: we just all have to stop using them
17:54:59 <wizwizwizwiz> what is the alternative?
17:55:01 <johnw> they'll get the hint if we do that
18:09:43 <erisco> the only thing stopping paramorphisms from being catamorphisms is the zero, if I am seeing this correctly
18:10:08 <erisco> otherwise we can just build the tuple bottom up with a catamorphism
18:11:59 <johnw> erisco: was that in relation to something I missed?
18:12:04 <erisco> no
18:12:50 <johnw> I thought a paramorphism provides the context for deciding the value at each point
18:13:12 <johnw> like, for a list, it gives you the tail at each element
18:13:50 <erisco> yes, but we can almost do this with a catamorphism... let me demonstrate
18:16:56 <erisco> > oldr (\a (xs, b) -> (a:xs, xs:b)) ([], []) [1,2,3]
18:16:58 <erisco> > foldr (\a (xs, b) -> (a:xs, xs:b)) ([], []) [1,2,3]
18:16:58 <lambdabot>  error:
18:16:58 <lambdabot>      • Variable not in scope:
18:16:58 <lambdabot>          oldr
18:17:00 <lambdabot>  ([1,2,3],[[2,3],[3],[]])
18:18:47 <jle`> interesting thing you can type into ghci
18:18:48 <jle`> 1 = 0
18:18:56 <jle`> now that ghc doesn't require lets anymore
18:19:00 <erisco> but notice what I did here to make it work
18:19:27 <erisco> what is the first context? i.e. what is my zero... well I can't know
18:19:44 <erisco> so I've used a monoid to collect the contexts instead
18:19:51 <erisco> specifically because the monoid has a zero
18:20:27 <erisco> in my Coalgebra if I actually wanted to know the context I'd have to first figure out if the list was non-empty
18:20:59 <erisco> I don't have to do this with a RCoalgebra
18:21:10 <erisco> derp, I mean Algebra and RAlgebra
18:23:00 <erisco> I guess the way I set it up makes it more like a histomorphism... so use  foldr (\a (xs, _) -> (a:xs, Just xs)) ([], Nothing)  instead
18:29:36 <johnw> I don't quite follow
18:29:44 <johnw> if you ignore the argument, why are you passing it through?
18:30:30 <erisco> johnw, I am just showing that the context is available even though this Algebra doesn't use it
18:30:59 <erisco> that is why I collected it in a list first... so it did something interesting
18:32:34 <erisco> now in the case of lists specifically we can cheat because we know exactly the context our zero appears in
18:32:46 <erisco> i.e. the empty list... it just doesn't generalise to Functor fixpoints
20:15:52 <threshold> What are the possible ways of creating a Future?
20:16:59 <threshold> If STM can replicate the behaviour of MVar, then why not always use STM? When does it make sense to use MVar instead? 
20:17:00 <jle`> the best future starts with the work we do today
20:17:18 <threshold> !quote
20:17:37 <threshold> I am unsure how to save timeless advice 
20:17:59 <threshold> I will heed your advice though jle` 
20:19:59 <threshold> The Async library looks it would do the job, but is there something equivalent. Can the Async functionality be replicated in STM?
20:21:29 <jchia> I have a monad transformer stack where two components inside at different levels of the stack need to maintain their own states. The states are of types Foo & Bar. Can I expect a performance difference between using StateT (Foo, Bar) and using 'StateT Foo' & 'StateT Bar' separately in the stack? Generally, can I expect worse performance from deeper monad transformer stacks?
20:25:17 <glguy> threshold: async is implemented using STM
20:28:18 <jle`> jchia: program abstractly if you can
20:29:39 <jle`> you can benchmark to figure out which concrete instance works better
20:47:17 <robkennedy> threshold: MVar can give you nice guarantees about single concurrent use, but that can also be achieved with TMVar. So probably the only real reason is performance (although I've not had performance problems with STM)
20:48:11 <johnw> and I believe only performance under the right circumstances
20:48:39 <johnw> meaning, STM only loses under certain conditions
20:50:20 <ReinH> johnw: o/
20:50:26 <johnw> Hi ReinH!
20:50:30 <johnw> will you be at Compose?
20:50:38 <ReinH> johnw: no :(
20:50:46 <johnw> *sniff*
20:50:50 <ReinH> I agree
20:50:54 <ReinH> maybe next year!
20:52:48 <ania123> Construct regular expression to generate a language where every 1 is followed immediately by 00
20:52:52 <ania123> my english is not ok
20:52:58 <ania123> should this language contain
20:53:00 <ania123> 001?
20:53:02 <ania123> or 110?
20:58:06 <alx741> ania123: no
20:58:22 <kadoban> ania123: No, neither of those
20:58:52 <ania123> why not? 
20:58:59 <ania123> 100
20:59:05 <ania123> i meant sorry
20:59:12 <ania123> misprint 
21:01:23 <alx741> '001' nor '110' fit the requirement "1 immediately followed by 00"
21:02:26 <lpaste> threshold pasted “Async question” at http://lpaste.net/355412
21:02:38 <ania123>  (0*100)*
21:03:13 <threshold> Thank you for the feedback. I am now trying to understand how to group these actions into a single transaction
21:03:35 <threshold> The general look of the code is in lpaste above.
21:05:18 <threshold> The second and third actions don't need to wait on the first action, but they should be rolled back somehow if the first fails.
21:08:22 <Cale> threshold: I'm not sure how to answer this... are you asking about how to fork threads?
21:11:10 <Cale> threshold: You can pass an IO action to forkIO which will run it in a new thread
21:16:44 <threshold> Cale: I'm not sure. This is my first time to think about this. I thought Strategies, Par, but then decided STM might be better. Why forkIO instead of STM?
21:17:20 <Cale> You might use STM in conjunction with forking threads
21:17:30 <Cale> You generally won't use STM without using forkIO at all.
21:17:47 <EvanR> not going to ask why youd use STM without multiple threads
21:18:27 <threshold> EvanR: I'm new to this and do not know better :)
21:19:25 <EvanR> are you trying to run 3 actions in parallel, with side effects only getting committed if they all succeed?
21:20:05 <threshold> EvanR: Yes
21:21:12 <EvanR> does it involve IO
21:21:36 <threshold> EvanR: Yes
21:22:03 <EvanR> you can spawn 3 threads and wait for 3 results, (convenient with the async library), then you can commit the result
21:22:08 <EvanR> in the original thread 
21:24:52 <threshold> It's possible my mind can handle that. I have a question that is completely ignorant, because I'm completely ignorant about this matter. If I delete a row from a database, how is it that those results can be turned into a transaction which can be rolled back?  
21:25:17 <EvanR> the delete happens within a database transaction
21:25:41 <EvanR> there various ways the database could implement that, but in any case, the delete does not happen until the transaction succeeds
21:26:26 <EvanR> in any haskell db lib ive seen, you always run your modifications inside some transaction context
21:26:38 <EvanR> if an error occurs, transaction is never committed
21:27:02 <EvanR> you could also intentionally rollback if you detect an inconsistency
21:28:38 <EvanR> the simplistic way to understand it is, the transactions are basically a data structure, and only one transaction runs at a time
21:29:04 <EvanR> however default isolation levels dont actually act that way and you have gotchas
21:33:12 <threshold> I am seeing atomic transactions are used for the database client I'm using, through atomicModifyIORef. This is helpful. Hope I can be helpful to new Haskellers one day
21:33:30 <EvanR> thats not the same thing
21:34:18 <threshold> *blush*
21:36:54 <EvanR> concurrent communication is tricky business
21:40:04 <Cale> threshold: atomicModifyIORef just mutates memory, it isn't related to the database.
21:42:10 <Mibaz> I'm trying to understand the difference between applicative functors and monads. Is it essentially that chains of applicatives can't change type constructors partway through their execution?
21:42:28 <Mibaz> I'm getting a lot of metaphors online that are a bit too vague
21:42:55 <EvanR> chains of applicatives cant inspect intermediate results like monads can
21:43:09 <EvanR> to decide on a different continuation
21:43:18 <Mibaz> What do you mean by "continuation"?
21:43:23 <EvanR> :t (>>=)
21:43:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:44:15 <EvanR> a monadic expression may contain many >>='s, and the later (a -> m b)'s depend on the previous a's
21:45:26 <Mibaz> :t (<*>)
21:45:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:46:14 <Mibaz> So you can't put inspection in <*>. Give me a second to think about that.
21:47:16 <EvanR> in f <*> x <*> y <*> z, x y and z must "happen", no matter what f <*> x is, or (f <*> x) <*> y is
21:47:36 <EvanR> er, the f x y and z must "happen"
21:48:02 <pacak> > pure (+) <*> undefined <*> Just 4
21:48:04 <lambdabot>  *Exception: Prelude.undefined
21:48:15 <pacak> EvanR: Is it?
21:48:30 <EvanR> thats a different demonstration
21:50:03 <Mibaz> In " Just 4 >>= \x -> x >>= \y -> x + y " don't both anonymous functions just "happen" efen if the first value had been Nothing ? (That might not compile #newbproblems)
21:50:31 <Mibaz> yeah sorry that's a garbage code example
21:50:44 <Mibaz> I don't see how that chain of functions don't "happen" in monads
21:50:54 <EvanR> in that example it does
21:51:27 <EvanR> Just 4 >>= \x -> if x < 3 then <more nested monad code> else <different nested monad code completely>
21:52:04 <pacak> Mibaz: In a monadic computation you can look at values and decide what to do next. In applicative - you can't.
21:52:33 <pacak> Resulting shape of applicative computation depends only on shape of components.
21:52:56 <Mibaz> EvanR: are these "continuations" necessarily demonstrated with if / else statements (or some other branch like that)?
21:53:07 <pacak> > (,) <$> [1,2] <*> [3,4]
21:53:09 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
21:53:14 <EvanR> the continuation is the second argument to >>=
21:53:17 <Mibaz> pacak: There's my confusion, what do you mean by "shape"?
21:53:36 <pacak> This will always* produce a list of 4 elements no matter what elements are.
21:54:00 <pacak> Always - given there's no undefined
21:54:40 <pacak> In Monad you can inspect values.
21:54:53 <int-e> > length $ undefined <$> [1,2] <*> [3,4]
21:54:56 <lambdabot>  4
21:55:06 <jle`> Mibaz: one way you can see it is that for Applicative, the "structure" or "effects" is known in advance
21:55:22 <EvanR> that case, you used fmap first not <*>
21:55:22 <pacak> int-e: Nice one.
21:55:24 <jle`> based on the structure/effects of the inputs
21:55:45 <jle`> for example, for lists, you always know the length of the resulting list
21:55:46 <threshold> Does Persistent operate within a transactional context?
21:55:50 <jle`> just based on the length of the input lists
21:55:53 <jle`> this isn't the case for Monad
21:56:06 <Lokathor> threshold, it can do transactions, yeah
21:56:27 <jle`> for IO, the resulting IO action's effects are pre-determined, before any of the input IO actions are computed
21:56:32 <jle`> s/computed/executed
21:56:52 <jle`> for Maybe, the Nothing/Justness of the final result can be determined just from the Nothing/Justness of the inputs
21:56:59 <jle`> without looking at the function being mapped or lifted over them
21:57:13 <EvanR> you mean Applicative instance of IO
21:57:21 <Mibaz> jle': ah, ok, what you just said made more sense.
21:57:26 <jle`> i mean, using the Applicative combinators with IO
21:57:47 <jle`> if you only use the Functor and Applicative API for IO, the resulting actions will have effects that can be pre-determined
21:58:00 <jle`> but if you use >>=, that's not the case
21:58:12 <jle`> if you use >>=, the effects that are performed depend on the function you bind
21:58:19 <jle`> and cannot be known until you actually execute the IO action
21:58:42 <Mibaz> jle': can monads be thought of as applicative functors with an extra function thrown in? (rough statement, obviously).
21:58:44 <jle`> but for something like f <$> x <*> y, the effects in the reuslting IO action only depend on the effects of x and y
21:59:04 <jle`> Mibaz: i don't know if that's a useful way to think of monads
21:59:08 <jle`> i don't think it is
21:59:25 <jle`> some applicative functors are monads, and some aren't
21:59:33 <EvanR> Mibaz: there not really directly related. Monad are Functors with a join operation m (m a) -> m a
21:59:33 <jle`> you can't just "throw extra functions" into ZipList, or Const
21:59:36 <jle`> and expect them to become monads
21:59:45 <jle`> there is no exact function you can add to Const that will make it a lawful monad
21:59:51 <jle`> s/exact/extra
22:00:03 <EvanR> f (f a) -> f a
22:00:28 <jle`> take a look at the Const Applicative.  you can't just add an extra function and turn it into a monad
22:00:58 <Mibaz> jle': right right, I wasn't suggesting you could just add a function. I was speaking conceptually (and only conceptually about the relationship between applicatives and monads)
22:01:35 <Mibaz> EvanR: Doesn't a monad also have to be an applicative?
22:01:44 <jle`> for something to *be* a monad, it has to support all the things associated with applicatives, and there is an extra requirement, as well
22:01:45 <EvanR> yeah, now
22:02:07 <EvanR> but thats just a convenience for haskell code
22:02:16 <EvanR> you can implement an applicative for free with any monad
22:02:25 <EvanR> so now they make you
22:02:25 <Mibaz> EvanR: So they're not mathematically related, is what you are saying?
22:02:25 <jle`> Mibaz: the concept of a monad has one extra requirement
22:02:35 <EvanR> (unless you have a better applicative instance for it)
22:02:54 <EvanR> right
22:02:57 <jle`> Mibaz: kind of like, for something to be considered a square, it needs to fulfil all of the requirements of being a rectangle (four-sided polygon, right angles), and also one extra requirement
22:03:04 <jle`> Mibaz: which is that the four sides have to have the same length
22:03:38 <jle`> the requirements that qualify something to be called a square is just slightly more restrictive than the requirements that qualify something to be called a rectangle
22:03:40 <EvanR> and they you stretch it and say applicatives are a rhombi ;)
22:04:07 <jle`> but it is true that anything that qualifies to be called a square will also, by definition, be qualified to be called a rectangle
22:05:13 <int-e> EvanR: Note that for Const, join isn't the problem, it's the return/pure.
22:05:31 <jle`> er, wait, pure for Const is fine
22:05:32 <EvanR> interesting
22:05:34 <Mibaz> jle': EvanR: Ok, I kind of have all of this (rhombariffic) information at the top of my head, let me read a little more and think about it. What's going to help at this point is examples.
22:06:05 <cocreature> int-e: pure = Const mempty
22:06:22 <EvanR> right, monads are functors with *two* more operations, pure and join
22:06:32 <jle`> it's possible to write a typechecking join, but not one that satisfies the laws
22:06:33 <int-e> jle`: well that's cheating by taking something pointed as the base type
22:06:45 <int-e> huh, cocreature: I mean
22:06:45 <jle`> int-e: well we're talking about this in the context of the Applicative instance
22:07:18 <int-e> I guess you can have  pure _ = Const undefined.
22:07:26 <jle`> if you take Const X to have an Applicative instance, then you can't make a lawful Monad instance
22:07:32 <jle`> where ap = (<*>)
22:07:35 <cocreature> int-e: and that’s not cheating? ;)
22:07:49 <Lokathor> how do i make a Double into a Float
22:07:53 <int-e> cocreature: yes it is
22:07:53 <jle`> realToFrac
22:07:54 <Lokathor> the number tower always gets me lost
22:07:58 <Mibaz> jle': quickly for clarification, the "effects" of <*> are known in advance, but the effects of >>= are also known IF you know the (a -> m b) in the type signature, correct?
22:08:08 <EvanR> Lokathor: realToFrac
22:08:09 <jle`> Mibaz: they are not known in advance
22:08:09 <int-e> cocreature: And I didn't want to allow either.
22:08:13 <Lokathor> cool
22:08:23 <EvanR> Lokathor: because its not a tower, its a salad bowl
22:08:29 <jle`> Mibaz: knowing the type 'm b' does not tell you mch about the effects
22:08:36 <cocreature> Lokathor: if you remember fromIntegral and realToFrac you can do most conversions
22:08:41 <jle`> Mibaz: oh, i see what you're asking
22:08:46 <jle`> Mibaz: no, not necessarily.
22:08:47 <Lokathor> well i remember fromIntegral all the time
22:08:51 <jle`> Mibaz: because the 'a' isn't known in advance
22:08:58 <Lokathor> usually i don't need Float, just GL using them is all
22:09:05 <EvanR> and fromInteger when possible
22:09:09 <jle`> Mibaz: 'getLine >>= putStrLn' for a counter-example
22:09:10 <EvanR> or fromRational
22:09:21 <jle`> Mibaz: it's impossible to know the effects until getLine is fully executed
22:09:30 <int-e> cocreature: I answered an objection I had that didn't make it to the channel: To define pure = Const mempty imposes a type class constraint on the first argument of Const.
22:09:30 <Mibaz> jle': ah, persuasive counterexample.
22:09:32 <EvanR> Lokathor: ;_; cant you use Double
22:09:45 <EvanR> (answer, you can)
22:09:51 <jle`> Lokathor: i believe realToFrac has a rewrite rule that makes it performant
22:10:02 <cocreature> int-e: fair enough.
22:10:03 <jle`> for the case of Float -> Double
22:10:20 <Mibaz> jle': there can't be an applicative implementation of IO, then?
22:10:30 <jle`> Mibaz: there can be an applicative instance for IO
22:10:32 <EvanR> jle`: are we sure of that
22:10:33 <jle`> well, there is one
22:10:49 <jle`> Lokathor: normally, realToFrac converts to a Rational, then converts back
22:10:51 <jle`> which is pretty bad
22:11:00 <Lokathor> EvanR, what i'm doing in this example is taking the time from GLFW-b (Maybe Double) and setting it as the green value of the pixels of a triangle (which are all Float)
22:11:12 <jle`> Mibaz: `f <$> getLine <*> getLine`   -- the effects are known ahead of time, even if you don't know what 'f' is
22:11:38 <jle`> in general, 'f <$> x <*> y' will have exactly the effects of x and of y, sequenced after each other
22:11:52 <jle`> (talkin bout IO)
22:12:21 <Mibaz> jle': what about getLine <*> putStrLn
22:12:32 <jle`> that doesn't really typecheck
22:13:00 <EvanR> getLine doesnt have type IO (a -> b) 
22:13:07 <jle`> maybe you mean f <$> getLine <*> putStrLn "hello"   ...?
22:13:18 <jle`> in that case, the effects are also knowable w/o knowing f
22:13:35 <Mibaz> jle': ah, sorry forgot the type
22:13:39 <Mibaz> :t <*>
22:13:40 <lambdabot> error: parse error on input ‘<*>’
22:13:48 <Mibaz> um
22:13:48 <jle`> the type is only a reflection of the deeper problem
22:13:55 <jle`> which is what you gave doesn't really make sense
22:13:59 <Mibaz> :t (<*>)
22:14:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:14:10 <Mibaz> jle': of course
22:14:13 <nshepperd> getLine >>= f -- might print the line you entered. for instance let f = putStrLn
22:14:23 <cocreature> in case anybody else got curious where the rules for realToFrac are declared, they’re here https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Float.hs#L1194
22:14:38 <nshepperd> g <*> getLine -- won't have any effects involving the line you entered, no matter what g is
22:14:56 <EvanR> nice
22:16:12 <Mibaz> nshepperd: Can you define "effects"
22:16:23 <nshepperd> Mibaz: eg. printing stuff
22:16:37 <nshepperd> opening files, etc
22:17:31 <Mibaz> Ok, I'm going to go read more. I'll probably be back with more dumb questions ;) thanks guys
22:17:41 <jle`> for a simplified example, you can look at Maybe, too
22:17:51 <jle`> where "effects" means Justness/Nothingness
22:18:11 <jle`> so for f <$> x <*> y, whether the result is Just or Nothing depends only on whether or not x and y are Just or Nothing
22:18:12 <Mibaz> jle': ok, that makes sense. 
22:18:36 <jle`> but if you throw in >>=, all bets are off
22:19:02 <jle`> `x >>= guard`, for instance, might be Just or Nothing, and you can't tell which just by looking at if x is Just or Nothing
22:19:27 <jle`> > Just True >>= guard
22:19:30 <lambdabot>  Just ()
22:19:30 <jle`> > Just False >>= guard
22:19:33 <lambdabot>  Nothing
22:19:35 <jle`> > Nothing >>= guard
22:19:37 <lambdabot>  Nothing
22:19:46 <Mibaz> :t guard
22:19:48 <lambdabot> Alternative f => Bool -> f ()
22:20:19 <jle`> guard True = Just (); guard False = Nothing
22:20:44 <Mibaz> jle': thanks, hadn't seen that yet
22:20:46 <Lokathor> hey everybody, quiz time: what's wrong with the following line that's constructing a string to send off to OpenGL?
22:20:47 <Lokathor> ourColorP <- newArray (map (fromIntegral.fromEnum) "ourColor")
22:20:54 <Lokathor> blink and you'll miss it
22:21:12 <jle`> Mibaz: same for Either, too, btw, and it's actually a more interesting guaruntee
22:21:31 <jle`> if the result is Left, you can determine *exactly* what's in the Left
22:21:36 <jle`> without looking at the function
22:21:52 <Mibaz> jle': but given the definition of guard, aren't those results self evident? That's cool with Either.
22:21:55 <jle`> you only need to look at whether or not the inputs are Left, and what is 'inside' those lefts
22:22:06 <Cale> Lokathor: Array bounds?
22:22:07 <jle`> what results?
22:22:19 <Mibaz> > Just True >>= guard
22:22:21 <lambdabot>  Just ()
22:22:29 <Mibaz> > Just Fale >>= guard
22:22:32 <lambdabot>  error:
22:22:32 <lambdabot>      • Data constructor not in scope: Fale :: Bool
22:22:32 <lambdabot>      • Perhaps you meant ‘False’ (imported from Data.Bool)
22:22:41 <Mibaz> >Just False >>= guard
22:22:42 <Lokathor> Cale, very close! I can't send the string "ourColor", I have to send the string "ourColor\0", because C strings
22:22:52 <Cale> ah
22:22:55 <jle`> yes, so if you use the monad interface for Maybe, you can't necessarily determine ahead of time if the result is Just or Nothing based *only* on the just/nothingess of the input Maybe's
22:23:15 <Cale> I didn't know which newArray that is, but if it's the one from Data.Array.MArray, it would be a type error not to provide the bounds as the first argument
22:23:18 <Mibaz> jle': aaahh, you need to look at the value in the context, right? 
22:23:20 <Cale> Apparently it's not though.
22:23:26 <jle`> Mibaz: for the case of Maybe, yes
22:23:46 <jle`> just/nothingness of the input is not enough to answer just/nothingess of the result
22:23:54 <Mibaz> jle': so the effects of applicatives are dependent on the effects of the inputs while the effects of a monad can depend on values
22:24:22 <jle`> yeah
22:24:32 <jle`> values, and the binding funtions
22:24:34 <Lokathor> Cale, it's just the normal one from Foreign.Marshal, so it makes an array pointer to an array that holds the contents of the list you give it
22:24:51 <Mibaz> jle': That might've cleared it up for me. Thanks for saying the same thing over and over again until it clicked
22:25:25 <jle`> no problem.  this is a difficult concept because it touches on "general" ideas about monads and applicatives
22:25:51 <jle`> things that are true about monads and applicatives 'in general'
22:25:52 <Mibaz> Thanks guys. I'll be back.
22:26:06 <Cale> ah, that one
22:26:40 <Cale> Lokathor: You could use newArray0
22:27:22 <Lokathor> Cale, oh, right, there's that too.
22:27:27 <Cale> Lokathor: Perhaps better yet to use withArray0 so that you can ensure the memory is deallocated when you're done.
22:28:08 <Lokathor> Cale, well, I need to keep that array for the duration of the program, it's more like a literal than a value
22:28:18 <Lokathor> vertexColorP <- glGetUniformLocation shaderProgram ourColorP -- this line here runs every frame
22:29:21 <Lokathor> I'm sure that I'll need to craft quite a few helper functions to make opengl cleaner and safer if I really get into it. But I don't think I'll get too into it. I just wanna make a glyph grid thing as my short term goal.
22:46:45 <osa1> anyone know a good way of using IntMap with Int newtypes as keys? I don't want to duplicate the whole API
22:48:00 <opqdonut> you might get some traction with Control.Newtype.under
22:48:11 <opqdonut> but I think you'll just have to write some boilerplate
22:49:26 <osa1> that's more boilerplate than I can afford. let me see the package though it looks interesting. never heard of it before.
22:50:15 <opqdonut> actually it might not help you, it's more for lifting a->a stuff to newtype->newtype stuff
22:51:09 <opqdonut> you just basically need lookup . unMyNewtype etc.
22:51:53 <osa1> yeah I don't want to do that. in fact my newtype constructor is not even exposed.
22:52:08 <osa1> *sigh*
22:54:11 <opqdonut> I think your options are Data.Map, or duplicating the IntMap api (perhaps with something like "class IntMapKey a where toKey :: a -> Int; fromKey :: Int -> a; newtype MyIntMap a b = MyIntMap (IntMap b); lookup :: IntMapKey a => MyIntMap a b -> a -> Maybe b"
22:54:46 <opqdonut> the latter part would make for a nice hackage lib
22:55:18 <osa1> yeah I'm surprised that there isn't a package for this already
22:57:09 <kadoban> I think there's an EnumMap somewhere that's a wrapper for IntMap
22:57:26 <kadoban> Which is almost but not quite the same thing?
22:57:36 <Axman6> just use Data.Coerce on insert and lookup
22:57:47 <opqdonut> https://hackage.haskell.org/package/EnumMap-0.0.2/docs/Data-EnumMap.html
22:57:50 <Axman6> if they keys you're using are newtypes you should be fine
23:00:12 <Lokathor> are there still strong opinions on gl vs OpenGLRaw?
23:03:20 <johnw> it's only when you google for "how to make z3 faster" that you realize how many different products are known by the label 'Z3'
23:03:27 <johnw> and how speed relates to them all
23:03:41 <Axman6> vroom vroom!
23:03:48 <pacak> Lokathor: I'd go with gl only because of author.
23:03:54 <Axman6> :t coerce
23:03:56 <lambdabot> error:
23:03:56 <opqdonut> you're talking about the Z3 cyclic group of course?
23:03:56 <lambdabot>     • Variable not in scope: coerce
23:03:56 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
23:04:11 <Axman6> :t coerceed
23:04:13 <lambdabot> error:
23:04:13 <lambdabot>     • Variable not in scope: coerceed
23:04:13 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
23:04:14 <Axman6> :t coerced
23:04:15 <lambdabot> (Coercible t b, Coercible s a, Functor f, Profunctor p) => p a (f b) -> p s (f t)
23:04:30 <Axman6> :t (^. coerced)
23:04:32 <lambdabot> Coercible s a => s -> a
23:04:40 <Axman6> :t (^. coerced) IM.insert
23:04:42 <lambdabot> Coercible a1 (IS.Key -> a -> IM.IntMap a -> IM.IntMap a) => a1
23:05:18 <Axman6> :t (^. coerced) IM.insert :: Sum Int -> IM.Intmap a -> IM.IntMap a
23:05:19 <lambdabot> error:
23:05:19 <lambdabot>     Not in scope: type constructor or class ‘IM.Intmap’
23:05:19 <lambdabot>     Perhaps you meant ‘IM.IntMap’ (imported from Data.IntMap)
23:05:28 <Axman6> :t (^. coerced) IM.insert :: Sum Int -> IM.IntMap a -> IM.IntMap a
23:05:30 <lambdabot> error:
23:05:30 <lambdabot>     • Couldn't match representation of type ‘IM.IntMap a0
23:05:30 <lambdabot>                                              -> IM.IntMap a0’
23:05:48 <Lokathor> pacak, yeah. gl is pretty nice as well
23:06:18 <Lokathor> OpenGLRaw has a "merge this with gl" page on its git wiki, and for every point of contention it basically just says "resolution: go with our way"
23:06:23 <Lokathor> which strikes me as a little silly
23:06:27 <Axman6> not sure if Ed keeps it up to dte, but gl represented the entirety of OpenGL, including all extensions
23:06:46 <Axman6> which is pretty amazing
23:06:58 <Lokathor> Axman6, latest version is "Uploaded	Sat Mar 25 00:20:59 UTC 2017 by EdwardKmett" according to Hackage
23:07:13 <Axman6> that's pretty good
23:07:26 <osa1> Axman6: that's not gonna work because my newtype is actually opaque (i.e. no constructor in scope)
23:13:57 <osa1> :t \k -> IM.insert (k ^. coerced) "ok" IM.empty
23:13:59 <lambdabot> Coercible s IS.Key => s -> IM.IntMap [Char]
23:14:16 <osa1> :t \k -> IM.insert (k ^. coerced)
23:14:17 <lambdabot> Coercible s IS.Key => s -> a -> IM.IntMap a -> IM.IntMap a
23:14:22 <Axman6> osa1: would it make sense to export something like insertIM :: MyKey ->  a ->  IntMap a -> IntMap a; insertIM = coerce IM.insert?
23:15:19 <osa1> Corercible here means any IS.Key can be coerced to my type, right? maybe I need one-way coercible here
23:15:34 <Axman6> yeap
23:15:37 <nshepperd> module MyMap (MyMap, insert, ...) where { newtype MyMap a = MyMap (IntMap a); insert = coerce IntMap.insert; ... }
23:15:53 <nshepperd> you will need the constructor of your newtype in scope there
23:16:10 <osa1> nshepperd: that's too much boilerplate because IntMap API is large and I need pretty much all of it
23:16:52 <nshepperd> I don't see any other way to do it
23:17:12 <osa1> I think one way Coercible would be a good solution
23:17:14 <nshepperd> not if you want to keep the newtype constructor hidden
23:17:35 <osa1> nshepperd: I could provide a one-way Coercible instance without exposing the constructor
23:17:54 <osa1> so you could coerce to Int from my type but not the other way
23:18:05 <nshepperd> how are you supposed to insert with that
23:18:21 <osa1> IM.insert (oneWayCoerce myType) value ?
23:18:48 <nshepperd> IM.insert needs an Int
23:18:58 <nshepperd> coerceForInsert :: MyType -> Int
23:19:07 <osa1> that's what oneWayCoerce does
23:19:11 <nshepperd> oh, to
23:19:20 <osa1> but ther's not `Int -> MyType`
23:19:30 <nshepperd> ok, that will work as long as you don't need the adjust functions
23:19:36 <nshepperd> or toList
23:19:38 <osa1> hmm right
23:19:55 <nshepperd> or anything WithKey
23:20:37 <osa1> I guess that could be done with a new map implementation that uses Ints for keys but also stores original (un-coerced) keys
23:23:50 <nshepperd> dunno, to me this seems inferior to just writing the boilerplate
23:24:26 <nshepperd> but what do i know
23:24:43 <osa1> agreed I was just thinking out loud
