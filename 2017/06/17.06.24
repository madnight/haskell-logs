00:04:05 <Lokathor> so if you had to write a video game in haskell
00:04:07 <Lokathor> a roguelike say
00:04:25 <Lokathor> is there any special technique that one would favor for handling all the monsters and items and such?
00:04:51 <Lokathor> None jump to mind, I think you can just use records for it all easily enough
00:05:09 <zomg> Just don't go crazy with types or you'll just get really stuck like I do :D
00:05:53 <merijn> Lokathor: Honestly, records are probably the sanest way to go
00:06:00 <zomg> Records seems to be the suggested way, I think there's even some wiki and SO answers specifically discussing RPG stuff like representing NPCs or spells or whatever
00:06:20 <sophiag> lenses came out of using lots of records for game design
00:06:52 <merijn> Lokathor: You can use what I always call OO Haskell if you want, here's an example: https://github.com/merijn/broadcast-chan/blob/master/benchmarks/Channels.hs#L51-L56
00:07:18 <MarcelineVQ> reflex came out of game design too, in some spirit at least, good times
00:07:26 <Lokathor> well at least they're *strict* IO values :P
00:07:44 <cocreature> sophiag: are you sure you want SList here?
00:07:52 <Lokathor> Yeah I guess i'll end up with some sort of data Creature = Creature { ... }
00:07:57 <cocreature> sophiag: SList is parametrized by a typelevel list not by the element type
00:08:17 <merijn> Lokathor: Well, don't want the thunk producing the IO to get forced inside the benchmark, rather than before it runs :)
00:09:29 <Lokathor> http://www.roguebasin.com/index.php?title=Complete_Roguelike_Tutorial,_using_python%2Blibtcod,_part_2 specifically, this would be the tutorial step whose vague struture i'd be copying
00:09:48 <Lokathor> in terms of function (a creature with a position) rather than specific architecture
00:10:07 <sophiag> cocreature: i'm not sure at all! it seems it's just sugar over Sing. so i could have (Sing [SNat a]) or (SList (SNat a)). the second doesn't typecheck, though. the first still throws errors in ghci :/
00:10:09 <cocreature> sophiag: I also don’t really understand what iterNat is supposed to be I think. it seems like that’s just an infinite loop?
00:10:44 <sophiag> cocreature: yes, it's just an infinite list of Nats. iterNatStep allows you to step through them. it's a contrived example of what i'd like to develop further
00:11:33 <cocreature> sophiag: but it’s not a list it’s a "Const (SNat a) something"
00:12:19 <cocreature> sophiag: are you trying to make an infinite _typelevel_ list?
00:12:22 <cocreature> you can’t do that
00:12:31 <sophiag> yes, exactly what i'm trying to do
00:12:41 <cocreature> types are not lazy
00:12:47 <sophiag> i know you can't have infinite types themselves
00:13:03 <sophiag> but couldn't i still have an infinite list of Nats?
00:13:16 <cocreature> that seems very much like an infinite type
00:14:28 <sophiag> oh, because it presumes some element with infinite numbers of Succ?
00:14:40 <sophiag> i didn't think of it that way
00:15:07 <[exa]> btw, is there a debian package that would contain Math.NumberTheory.Primes.Testing?
00:15:13 <cocreature> your typelevel list would then contain an inifinite number of types
00:17:17 <sophiag> cocreature: i wasn't thinking of it as a type level list, but rather a list of types. are you saying that because it's in Sing?
00:17:48 <cocreature> sophiag: what’s the difference between a typelevel list and a list of types?
00:18:00 <cocreature> seems like two names for the same thing
00:18:17 <sophiag> [Zero, (Succ Zero), (Succ (Succ Zero)), ..]
00:18:22 <sophiag> is that unacceptable?
00:18:33 <cocreature> well is that a value or a type?
00:19:07 <cocreature> as a value it’s obviously fine. as a type, lifted via DataKinds, it isn’t
00:19:49 <sophiag> so to be clear...it's making it a singleton list that causes the problem?
00:20:28 <cocreature> no making an infinite type is the problem. whether that type has a corresponding value via singletons doesn’t matter.
00:21:03 <sophiag> so where i wrap it in Iterator and IteratorT?
00:21:34 <sophiag> this typechecks: iterNat :: (Enum (Sing a)) => Iterator SNat a (Sing [SNat a])
00:22:13 <cocreature> Sing [SNat a] is a typelevel list that contains the element SNat a, it’s not the kind of a typelevel list of SNats
00:23:16 <sophiag> got it. that's what i was trying to ask earlier
00:24:36 <sophiag> if i'm stuck with pre-allocated lists then i'm a bit unsure how to proceed tho
00:26:41 <cocreature> hm you can actually make an infinite list  with UndecidableInstances but GHC loops forever if you try to use it :)
00:27:03 <cocreature> http://lpaste.net/356437
00:27:04 <merijn> Anyone an expert on GHC's Handle?
00:27:15 <cocreature> and then try ":kind! Head Infinite"
00:27:55 <merijn> Specifically, when using fdToHandle, does closing the handle also close the fd or do I need to do that separately?
00:27:56 <sophiag> cocreature: i am using UndecidableInstances... can you not just call take on your list?
00:28:30 <mauke> merijn: I don't know but my guess would be it closes the fd
00:28:34 <mauke> and I'd use strace to confirm
00:28:38 <cocreature> sophiag: no, you can’t even call Head because when you do that, GHC tries to unify the types and since there is an infinite number of list elements it never finishes
00:29:07 <sophiag> cocreature: same for sHead i assume? based on having just tried it :p
00:29:16 <cocreature> sophiag: yeah
00:29:26 <merijn> mauke: It's all a bit confusing and ambiguous, since handleToFd closes the handle, but the Fd is still usable after that
00:29:46 <sophiag> welp, i seem to have reached the point Cale told me about. "it will be informative finding where it becomes frustrating"
00:29:49 <merijn> mauke: However, closing the Fd after closing it's handle seems to error out for me...
00:30:01 <cocreature> sophiag: what you can do is make a function that generates a typelevel list containing the first n naturals given an SNat n
00:30:03 <sophiag> before this i always wondered why anyone would even want infinite types
00:30:31 <sophiag> right. lemme do that
00:30:37 <merijn> sophiag: Some of this stuff is easiest understood when you finally figure out you want that ;)
00:30:39 <cocreature> I wonder if there’s any language which does some sort of lazy typechecking and can give you infinite typelevel lists
00:30:50 <sophiag> the use case i'm imagining for this doesn't invovle infinite lists anyway
00:30:57 <sophiag> i'm thinking of using it for parsing
00:31:13 <sophiag> pretty sure you can tell OCaml to let you use infinite types
00:31:20 <merijn> mauke: I'm worried that even a minimal test case will do a lot of redundant operations, making it hard to figure out via strace
00:32:03 <sophiag> yeah, OCaml has a -rectypes flag
00:32:46 <sophiag> cocreature: couldn't i also create a newtype using Sing and Fix?
00:33:29 <cocreature> sophiag: a newtype for what?
00:34:59 <sophiag> cocreature: i was thinking something like "newtype SList a = Fix (Sing :: [a] -> *" but that doesn't typecheck
00:35:13 <sophiag> *)
00:35:53 <cocreature> sophiag: I think it might be helpful if you step back for a moment and try to figure out/explain what your goal is and then we can think about how you can get there :)
00:37:40 <mauke> merijn: http://lpaste.net/356438
00:37:56 <sophiag> cocreature: eventually type level traversables i was thinking i could use as a better way to parse ASTs from haskell-src-exts rather than using type casing. but for now i'm thinking just implementing some simple examples with Nat and maybe a BTree after that, like sorting for example
00:38:16 <sophiag> the idea of iterators is based on the C++ STL ones when they were originally implemented in Scheme
00:38:25 <merijn> mauke: I've managed to find the right strace via tactically place prints, which seems it indeed closes the fd too
00:38:36 <sophiag> he uses Nats and continuations and builds up to sorting algorithms
00:38:49 <merijn> mauke: Ah, like that yes :p
00:39:44 <sophiag> cocreature: i would just continue playing with it using modified generators that take a parameter like you suggested, but am unclear on why i can't use Fix to get an infinite type level list
00:41:05 <sophiag> maybe just "newtype SListT t a = Fix (Sing [t a])"
00:45:56 <cocreature> sophiag: that’s Fix as in "newtype Fix f = Fix (f (Fix f))"?
00:47:00 <sophiag> yes
00:47:16 <sophiag> i think the problem is i'd need to unwrap it in the function body
00:49:27 <cocreature> sophiag: do you mean "newtype SList t a = SListT (Fix (Sing [t a]))"? because otherwise Fix is just the constructor name of your newtype
00:49:43 <sophiag> yeah, i realized i screwed that up to begin with
00:49:53 <sophiag> i should just define Fix and then use it in the type signature
00:50:11 <cocreature> then it doesn’t kind-check
00:50:19 <cocreature> Fix requires that it’s argument is of kind * -> *
00:50:24 <cocreature> Sing [t a] is not of kind * -> *
00:50:25 <sophiag> yup
00:51:57 <sophiag> doesn't SList have the right type?
00:52:34 <cocreature> "SListT t" has the right kind
00:56:14 <sophiag> you can't mean "newtype SList t = SListT (Fix (Sing [t]))" 
00:57:01 <cocreature> newtype SListT t a = SListT (Fix (SListT t))
00:57:09 <cocreature> that’s a valid definition
00:57:15 <cocreature> why you would want that definition I don’t know :)
01:00:32 <sophiag> that definition is still recursive though...
01:02:11 <cocreature> so?
01:02:21 <cocreature> I think I don’t understand what you are trying to say here
01:02:35 <sophiag> ah, no i made a mistake leaving out the a 
01:02:50 <sophiag> anyway, the real point is i can't use it for much, right?
01:02:59 <cocreature> right :)
01:03:04 <sophiag> i'd need to unwrap it even to call sHead?
01:06:12 <sophiag> anyway, i'm unsure how to write the body if i do just use "iterNat :: (Enum (Sing a)) => SNat n -> Iterator SNat a [SNat a]"
01:08:43 <cocreature> sophiag: I would recommend to first write this without the singletons package. it tends to make things even more confusing ime. after you’ve managed to do that you can try to convert it to it
01:11:32 <cocreature> sophiag: I’m also not sure why you’re using Const for Iterator. it seems like you probably want something like Vinyl’s Rec type
01:11:41 <sophiag> that's not actually the confusing part for me (once i found their haddock docs...). it's just using Nats instead of Num a
01:13:27 <sophiag> i'm using Const because i was going to work with Monoid instances, although not sure how that fits in with using singletons now. i can't write a Monoid for SNat
01:15:51 <sophiag> what i need is sIterate. that doesn't seem to exist :/
01:17:50 <sophiag> i shouldn't have a problem with the shift/reset version though
01:18:06 <sophiag> not sure what's going on there: "iterNatStep = reset (succ $ shift iterNatStep)"
01:21:34 <eklavya> piyush-kurur: I was thinking from a web app perspective and it doesn't make sense to use Haxl there, right? You can't cache IO results much if at all.
01:22:01 <eklavya> I meant Haxl without cache control
01:24:03 <cocreature> sophiag: here’s a version of iterNat without the singletons package http://lpaste.net/356439
01:25:07 <petrus> Hello, I am having problems with dynamic linking using stack. Platform archlinux, ghc8.0.2, using system-ghc, arch provides only shared libraries for haskell. stack insists to link statically. How can I change this behavior?
01:26:28 <sophiag> cocreature: wow, thanks. but couldn't i achieve the same thing using iterate?
01:26:46 <cocreature> sophiag: that won’t give you an HList
01:27:15 <cocreature> sophiag: I mean sure if you don’t care about having the list represented at the typelevel use iterate but it seems like that’s what you are trying to do here
01:27:17 <sophiag> why do i need an HList? they're all of type Nat
01:27:31 <cocreature> no the elements are of type SNat n for different n
01:27:56 <sophiag> hmm
01:28:26 <sophiag> i need to rethink what the type variable in SNat is actually doing
01:29:18 <cocreature> "SNat n" is a type that contains exactly one inhabitant (ignoring bottom) and the "n" is responsible for choosing which inhabitant that is
01:29:32 <cocreature> so SNat 'Z can only be 'SZ
01:29:35 <sophiag> and in this case it's where the list terminates, yes?
01:29:55 <cocreature> it’s the number of elements in the list
01:29:59 <sophiag> right
01:30:19 <sophiag> but the elements in the list shouldn't actually have n in them
01:30:29 <sophiag> just the last should have n applications of Succ
01:31:17 <cocreature> "iterNat (SS (SS SZ))" will give you "(Cons SZ (Cons SS SZ Nil))"
01:31:42 <cocreature> which has type HList SNat '[ 'Z, 'S 'Z]
01:36:23 <sophiag> ok gotcha. this probably saved me a lot of time :p
01:36:47 <cocreature> you’ll have to figure out how to translate that to singletons yourself, my singletons foo is very weak :)
01:37:04 <sophiag> well, there should be a promoted iterate, but i can't find it
01:37:15 <sophiag> i can just hide it from prelude and promote the definition
01:37:27 <cocreature> I’m not sure if singletons has something like HList
01:38:00 <sophiag> oh...that too
01:38:03 <sophiag> i would doubt it
01:38:27 <sophiag> but i can deal with that similarly
01:38:32 <sophiag> (if it's even necessary?)
01:38:47 <sophiag> i mean using like SHList rather than just HList
01:40:58 <sophiag> uh, woah...trying to promote iterate overflows the stack
01:41:26 <cocreature> well that would create an infinite type, no?
01:41:39 <cocreature> so promoting iterate doesn’t really work
01:42:25 <sophiag> oy, so functions that don't terminate can't be promoted?
01:42:52 <sophiag> that seems obvious now, but shouldn't it have been mentioned in the paper...
01:43:15 <cocreature> non-termination is not necessarily a problem with UndecidableInstances I guess but producing an infinite result will mean that they produce an infinite type
01:43:30 <merijn> sophiag: Incidentally, at this point where you've figured out why the original paper was called Hasochism it might be worth considering having a look at Idris :)
01:43:31 <sophiag> right, those are different things
01:43:46 <sophiag> merijn: hahaha
01:43:51 <sophiag> yeah i finally get it now
01:43:57 <merijn> sophiag: All this type level stuff is much nicer and simpler there
01:44:29 <sophiag> does it allow you to do away with type casing?
01:44:45 <sophiag> i'm imagining treating an AST of types like a zipper
01:44:52 <merijn> sophiag: In Idris anything you can do on the value level you can just straight up do at the type level
01:44:52 <sophiag> a la McBride
01:45:38 <sophiag> what about the phase distinction issue? do you deal with that manually in Idris? like just have assert yes on proofs you don't want in runtime?
01:47:03 <merijn> sophiag: Honestly, I haven't done much Idris at this point. So my knowledge boils down to: 1) it's dependently typed from the start, so all the hasochism/lifting/reifying stuff mostly boils away and 2) it's explicitly designed to be easy to transition into from Haskell
01:50:13 <sophiag> merijn: and you were recommending Brady's book on it? i always thought i'd get into dependent typing by reading Software Foundations and writing proofs, but now i'm realizing i have a more practical use for it with just type level programming. i just never got far enough in Haskell before to realize how much you have to contort it to even attempt this stuff
01:51:14 <merijn> sophiag: I've not read Brady's book, so I can't say. I think Software Foundations and learning Idris are two separate, but slightly differing goals
01:51:20 <cocreature> brady’s book is great
01:51:31 <cocreature> so is sf but they teach different things
01:51:40 <merijn> sophiag: SF is really focussed on "proving stuff about programs, using theorem provers"
01:52:03 <merijn> sophiag: Idris is not trying to be a theorem prover, it's trying to be a practical general purpose language, that happens to have dependent types.
01:52:22 <sophiag> yeah i know 
01:52:24 <merijn> sophiag: And yes, once you start doing even very basic things at the type level a proper dependent languages is just much simpler
01:52:42 <merijn> sophiag: So, I'd say the two approaches are complementary and you should just alternate :)
01:52:43 <sophiag> i just never though i'd need Idris for this kind of stuff
01:53:15 <merijn> sophiag: This might be a good short intro to see if it's for you: https://www.youtube.com/watch?v=fVBck2Zngjo
01:53:21 <merijn> sophiag: Type safe printf in Idris
01:56:48 <sophiag> cool, thanks!
01:57:11 <sophiag> i mean, i was going to read SF. especially since they reworked it to be a three part series with more coming
01:57:17 <sophiag> i suppose it's just what i read first
01:57:45 <sophiag> i should probably look into how practical Idris currently is. like if anyone is using it in industry
01:58:09 <merijn> sophiag: I saw a remark on reddit that Idris is at 2007 Haskell levels of real world usability
01:58:18 <sophiag> hmm
01:58:32 <sophiag> it seems it should actually be easier to make perform well
01:59:00 <sophiag> also i wouldn't trust benchmarks unless they mention whether the types are left in at runtime
01:59:55 <merijn> sophiag: afaik Idris does type erasure
02:00:05 <merijn> sophiag: But you may get better answers in #idris
02:00:20 <cocreature> tbf typelevel Haskell is also at the level of 2007 valuelevel Haskell :)
02:00:32 <merijn> :)
02:01:13 <sophiag> cocreature: worse...
02:01:55 <sophiag> i'd be excited if the Idris spec seems like people could more easily develop different optimizing compilers for it than with Haskell. seems that could be the case
02:02:16 <sophiag> like ML or Scheme where every grad student writes one and some are super fast
02:02:57 <merijn> I'm just a little sad that it's strict by default
02:04:47 <sophiag> well laziness does seem to be at the compiler level. it's not like using streams in scheme or something, right?
02:05:15 <merijn> Yes, but I think strict is the wrong default
02:05:34 <merijn> It's easier to fix excessive laziness with a localised fix than fixing excessive strictness with a local fix
02:06:27 <sophiag> from a software engineering standpoint, but it's the opposite from a compiler standpoint
02:07:12 <Taneb> There are more software engineers than compilers
02:08:21 <sophiag> having a language spec that requires such a complex compiler is the largest block to performance and innovation in general
02:08:55 <dysfun> but ghc is quite good at optimisation and strict mode seems to have had most of the kinks worked out
02:09:00 <merijn> When we're truly talking performance you end up designing your program around your inner loop anyway
02:09:05 <sophiag> i appreciate that haskell is a testbed, but there's a reason why a lot of companies choose OCaml and i don't think it's strictness
02:09:16 <sophiag> dysfun !
02:09:20 <merijn> sophiag: Honestly, there's far more companies using Haskell than OCaml now
02:09:27 <dysfun> well it's certainly not multicore processing, that's way too new and untested in ocaml
02:09:30 <dysfun> hi sophiag 
02:09:45 <sophiag> merijn: i think as a function of the overrall popularity though it's massively skewed toward OCaml
02:09:46 <merijn> sophiag: I can, of the top of my head, name like 10 or more Haskell companies. I know exactly one OCaml company
02:09:51 <sophiag> i don't know many hobbyist OCamlers
02:10:08 <sophiag> i know a ton of startups in NYC using OCaml. it's not just Jane St...
02:10:08 * dysfun also knows of exactly one ocaml company
02:10:40 <sophiag> at least equal number of startups here using OCaml as Haskell
02:10:53 <dysfun> well, haskell isn't exactly the most popular startpu choce
02:10:59 <dysfun> startup choice*
02:11:18 <sophiag> but it's true i guess. like they still don't have an industry ready multicore compiler because Jane St just doesn't need that...
02:11:28 <merijn> sophiag: Lots of multi-nationals using Haskell, though
02:11:34 <sophiag> true
02:11:45 <merijn> sophiag: Morgan Stanley, Standard Chartered, Barclays, Facebook, etc.
02:12:02 <sophiag> i've just been reading a ton of Scheme papers lately and thinking of all the shitload of super performant compilers those folks have written
02:12:05 <sophiag> same with ML
02:12:19 <sophiag> those two languages invented most modern compiler techniques
02:12:53 <dysfun> aside from everything LLVM did, you mean?
02:13:06 <dysfun> and hotspot
02:13:25 <sophiag> dysfun: i mean in the optimizing stage, not code generation 
02:13:35 <dysfun> LLVM has an entire optimisation toolchain
02:13:39 <merijn> sophiag: LLVM does plenty of optimisation
02:13:47 <dysfun> ghc taps into it for a while now
02:13:57 <merijn> What's the nicest/simplest way to write multi-line strings?
02:14:04 <sophiag> like some folks i know just wrote a new dialect of Scheme that has specialized primitives for their applications and have a Scheme->C compiler for it that's very fast. the whole thing ends up being as fast as Fortran for their specific application
02:14:09 <merijn> dysfun: tbh, for most people GHC isn't using LLVM
02:14:21 <ADG> how to do splitAt [1,3,5] "123456" = ["1","23","45","6"]
02:14:30 <sophiag> but apparently Idris is using LLVM so that's a big plus
02:14:43 <dysfun> merijn: "ghc has supported llvm for a while now" - better?
02:14:51 <ADG> I am currently using uncurry (:) . mapAccumR (flip splitAt) which I think does repetitive work?
02:14:55 <sophiag> like it won't take 10 years to get from 2007 to where Haskell is at now
02:15:19 <dysfun> idris is not a practical tool in the way haskell is
02:15:48 <merijn> sophiag: I think you're dramatically underestimating how much work has gone into Haskell if you think Idris will catch up in less than 10 years...
02:16:23 <dysfun> yeah, she started off with "such a complex compiler" without asking why it's that complex
02:16:53 <merijn> Far from all work in GHC is in making things faster
02:17:10 <merijn> And there's lots of tedious and painful engineering going into other cool shit
02:17:36 <dysfun> yup. like the linear types stuff. which has the potential to improve haskell performance
02:18:07 <merijn> dysfun: Compact regions, StaticPointers, etc.
02:18:15 <dysfun> yup
02:18:17 <dysfun> all good
02:18:40 <dysfun> i think ghc is starting to look pretty damn good
02:19:05 <ocramius> it is - as a newbie jumping in, the exceptions almost look readable :P
02:19:18 <ocramius> so kudos =)
02:19:33 <dysfun> yeah, they've improved error messages somewhat in the last decade
02:19:46 <merijn> dysfun: There's a lot of on-going work to improve them far more
02:20:04 <dysfun> yeah. the most exciting days are ahead
02:20:08 <merijn> Any recommend quasi-quoter for multi-line Text?
02:22:18 <sophiag> ha. i went to go make some food and came back to this
02:23:05 <sophiag> i appreciate why ghc is complex, but it seems obvious Idris doesn't require a lot of that as far as performance and also probably won't have to implement the vast majority of the extensions
02:24:07 <sophiag> i'm just trying to tout the value of having a standard that you can write simpler compilers for, not saying ghc isn't great engineering
02:24:29 <sophiag> and obviously there's a huge middleground between haskell and say...scheme
02:24:49 <Taneb> sophiag, I think it's more important to have a standard that lets developers be maximally productive
02:25:44 <Taneb> (while still being able to implement the language effectively)
02:28:24 <sophiag> Taneb: those are not in any way mutually exclusive
02:28:54 <sophiag> and your statement is contradictory: very few haskell devs could even contribute to ghc
02:29:42 <dysfun> i think on average very few devs would dare to contribute to any compiler
02:29:49 <Taneb> Compilers in general for non-toy languages are difficult
02:30:01 <sophiag> i'm just stating the obvious so it's funny people have to take it as a "language war." i'm in #haskell and it's one of the two languages i most use nowadays...
02:30:43 <sophiag> i've cited two "non-toy" languages where compilers are not difficult and have been testbeds of great compiler design: ML and Scheme
02:31:18 <dysfun> but scheme compilers are also complex beasts
02:31:22 <sophiag> dysfun: i, like many many people, would contribute to the clojure compiler were we...you know...allowed to :)
02:31:39 <dysfun> sophiag: haha, i got fed up of having patches rejected
02:31:53 <sophiag> i luckily learned the story on my first rejection :)
02:32:03 <sophiag> some folks early on got really burnt
02:32:50 <sophiag> anyway scheme compilers can be incredibly simple. the ones that are complex (still not by ghc standards, but for the standard size absolutely) are that way because the optimizations are ridiculous
02:35:19 <dysfun> ghc has to support quite a lot of experimental work. you aren't going to get what it does as well as it does into a significantly smaller codebase
02:36:17 <asdfoiawe> Hi, is there any easy way right now to set up a cross compiler on linux for win32? And does stack support cross compilation?
02:37:01 <sophiag> dysfun: agreed
02:37:09 <louispan> Question about GHC.Generics, is it okay to provide an instance of Generic without Data (D1), Constructor (C1) and Selector (S1) metadata. Ie, just Rec0?
02:37:40 <sophiag> i've been following DDC, although it's far from ready after (i think) a decade. curious to know if anyone's used that compiler from intel research
02:37:45 <merijn> asdfoiawe: Honestly, you know what the simplest solution is?
02:37:59 <merijn> asdfoiawe: Grab a VM (VirtualBox, or similar), install a copy of windows and compile on that
02:38:19 <merijn> asdfoiawe: Because that workflow is a 1000 times simpler than getting cross-compilation working :)
02:38:28 <dysfun> i'll second that. or outsource it to appveyor or such
02:39:59 <dysfun> sophiag: i can't find a reference to that compiler. url?
02:40:36 <sophiag> https://www.semanticscholar.org/paper/The-Intel-labs-Haskell-research-compiler-Liu-Glew/d90a018d01c5865f57db29bfb8d80ae46e7fcd61
02:40:39 <asdfoiawe> merijn: I'm actually going to use a vm for running the application, but compiling on the host makes the workflow more efficient
02:40:52 <dysfun> ta
02:40:56 <sophiag> it's just a ghc frontend they were able to optimize for some applications and not others
02:41:14 <sophiag> then open sourced it and ceased maintainence
02:41:25 <dysfun> they got their paper out of it...
02:42:02 <sophiag> dysfun: this is much more interesting, but not really usable yet (no stream fusion): http://disciple.ouroborus.net/
02:42:11 <sophiag> i saw ben talk on it a couple months ago
02:42:24 <sophiag> it is strict though. that will turn a huge amount of people off
02:42:59 <dysfun> i don't mind strictness too much, i have to write strict languages too often to really take offense
02:43:40 <sophiag> it's much easier to implement laziness in a strict language than vice versa. unfortunately many do it so horribly (e.g. Scheme)
02:43:47 <sophiag> Clojure does laziness well
02:43:48 <dysfun> but i'd say stream fusion is a pretty important thing to a language like haskell
02:43:54 <dysfun> no, clojure does laziness terribly
02:43:58 <sophiag> it's crucial
02:44:03 <sophiag> that's why i said DDC isn't usable yet
02:44:33 <sophiag> why do you say that about Clojure? have you ever used laziness in other lisps? it's garbage
02:45:04 <dysfun> yes, but i compare it not against lisps but other jvm languages
02:45:12 <sophiag> for example?
02:45:33 <dysfun> for example, lazily realising something with concat can cause a stack overflow in some cases
02:45:57 <sophiag> hmm. i use lazy seqs a lot and am very fast and loose with stack discipline yet have never experienced that
02:46:24 <dysfun> the problem is that because of the unique way in which they've implemented lazy sequences, getting each item involves adding a stack frame
02:46:27 <sophiag> i'm wondering your comparison tho since i'm really not a jvm type. i'm interviewing at a company soon that ditched both scala and clojure for groovy, which i know very little about
02:46:48 <sophiag> dysfun: that'd be true in any language that uses stack allocation tho. it's just hidden from you in clojure
02:46:50 <dysfun> i'm not fond of groovy. i settled on kotlin
02:47:03 <dysfun> no, scala and kotlin work around this
02:47:24 <sophiag> how so?
02:47:51 <dysfun> i won't pretend i understood the explanation i was given, btu i was convinced
02:47:54 <sophiag> i'm guessing something like chicken scheme?
02:48:21 <sophiag> in other words, just have a pointer to the environment that lives on the heap
02:48:37 <dysfun> no. on the jvm you don't have the freedom to do that
02:49:02 <sophiag> you can. it's just much much more complicated to implement
02:49:07 <sophiag> you cps it
02:49:22 <sophiag> that's where what's his name behind chicken got the idea: from appel's ML compiler
02:49:58 <sophiag> but i'm guessing what you're describing just jumps up stack frames internally to the lazy seq implementation
02:50:22 <sophiag> you have a good point i never considered before about how clojure hides the ability to use recur from you when you're not generating the lazy-seq yourself on every function call
02:50:37 <sophiag> you'd think they could have just built it in?
02:51:03 <dysfun> mumble mumble "java semantics" mumble mumble
02:51:03 <sophiag> i'm actually not convinced they didn't since i've never had these stack overflows
02:51:17 <sophiag> i mumble that mumble a lot
02:51:19 <dysfun> okay, well trust me when i say that concat can cause stack overflows
02:51:37 <sophiag> it's 2017: fuck stack machines. jvm is for enterprise now, not programming toasters
02:51:50 <sophiag> android uses registers like an adult
02:52:16 <dysfun> yes, i prefer register machines too, but they're roughly equivalent, it doesn't matter all that much
02:52:19 <sophiag> oh, actually i could imagine concat circumventing a jump mechanism like recur
02:52:34 <sophiag> registers matter a ton for compiler writers
02:53:24 <sophiag> concatenation can only jump up the combined stack frames. so if they're very large then, yes, you'd be screwed
02:53:36 <sophiag> at least that's my intuition having written scheme compilers coming out my ears
02:54:53 <dysfun> *shrug* you've used dalvik as an example of register machine superiority but it's slow as
02:57:24 <sophiag> i've never actually used dalvik (or whatever they're calling it now) so...
02:57:44 <sophiag> they just need to throw the bodies of more grad students on the gc
02:57:57 <sophiag> the upside of stack machines was supposed to be size, not speed
02:58:08 <dysfun> anyway, i have to run, good to catch up
02:58:59 <sophiag> yeah, hope you're doing well
02:59:04 <sophiag> i need to...sleep
02:59:20 <sophiag> if i catch you on here it's because something's wrong one way or another...
02:59:23 <dysfun> haha
03:29:13 <LiaoTao> How's GHC 8.2 coming along? I read a while back that it was scheduled for a June 2017 release.
04:03:35 <cocreature> LiaoTao: afaik there are still a few open bugs. once those are fixed we’ll get an rc3 and if no further bugs turn up a release. so still a few weeks
04:25:44 <ocramz> hullo!
04:29:58 <wz1000> is there a kliesli endomorphism monoid?
04:31:59 <cocreature> wz1000: monoid in what sense? you can’t make an instance of Monoid but ">=>" and "return" should form a monoid on a mathematical level
04:32:52 <wz1000> cocreature: why can't that be an instance of Monoid
04:33:51 <wz1000> instance Monoid (EndoKliesli m a) where mempty = EndoKliesli return...
04:34:20 <cocreature> oh I missed the endomorphism in your question
04:34:31 <cocreature> yeah I guess if you restrict them to "a -> m a" it should work
04:34:52 <wz1000> but is it defined anywhere?
04:35:37 <wz1000> or should I just use foldr
04:35:51 <cocreature> I haven’t seen it anywhere
04:37:11 <wz1000> somewhat unrelated, but is there some library that relates the positions across two versions of a text document?
04:37:32 <wz1000> like a diff
04:38:22 <wz1000> But gives functions oldPosToNew, newPosToOld :: Position -> Maybe Position
04:39:01 <wz1000> so that if you give it a position in an old text document, it gives you the position of that point in the new text document(if it hasn't been deleted)
05:02:56 <ADG> I have a function f :: Int -> Bool, I want to use it as f :: Integer -> Bool, so I defined f :: Integral i => i -> Bool, but I want it to set i as Int by default 
05:04:42 <ocramz> ADG it will work with both Int and Integer
05:05:28 <ADG> actually I have used it at multiple places but it defaults it as Integer so it is quite slow
05:05:39 <ADG> that's why I was wishing it could defualt to Int
05:06:46 <ocramz> uhm what kind of computation is it? I never encountered this type of speed difference
05:06:56 <ocramz> a noticeable one, I mean
05:07:00 <ADG> isPrime
05:07:09 <ADG> 13 sec to 45 sec
05:07:29 <ocramz> wow
05:09:35 <ocramz> ADG: does this type of 'lifting' work? :t \i -> fromIntegral i :: Int
05:09:49 <ocramz> Integral a => a -> Int
05:11:26 <ocramz> anyway, I have a question as well, related to `sepBy` from attoparsec : http://lpaste.net/356442
05:11:48 <ocramz> I don't understand why it short circuits at the first Nothing
05:18:40 <Clint> ocramz: what do you expect it to do?
05:22:47 <ocramz> Clint: I was hoping it to return [Just[2,3], Just[4], Nothing, Just[5, 6], Just[7]]
05:23:54 <cocreature> ocramz: so your first problem is that "space" parses newlines
05:23:59 <ocramz> ugh
05:24:24 <ocramz> thanks cocreature, missed that
05:28:53 <ocramz> cocreature: after defining `space = char ' '`, the output becomse `Right [Just [2,3],Just [4],Just []]`, which is closer to what I need but still don't get the short circuiting behavior
05:30:05 <cocreature> ocramz: short circuiting is not the right word here. the problem is that sepBy is successful even if there are no inputs so it never tries the no_dat parser
05:30:20 <cocreature> ocramz: the easiest solution is probably to use no_dat <|> dat
05:31:18 <Shockk> I have a quick question about the Applicative operators in Haskell
05:31:48 <Shockk> I'm using them in the context of attoparsec, so I can do stuff like the following:
05:32:10 <Shockk> definitionParser = Definition <$> identifierParser <* char '=' <*> identifierParser
05:32:33 <Shockk> so here I understand that the result is going to be Definition (the first parsed identifier) (the second parsed identifier), 
05:32:52 <Shockk> and I understand that using <* for the (char '=') causes the output of that to be discarded
05:33:08 <Shockk> is this the same for <$ or does <$ do something differen? i.e. could I do the following?
05:33:25 <Shockk> definitionParser = Definition <$ char '=' <*> identifierParser
05:41:43 <hanna> Some time ago somebody wrote a satirical new package manager for Haskell which was to replace Cabal by a system where you spontaneously receive code and it compiles itself; and the way of using it is to wait until you receive the necessary enlightenment
05:41:56 <hanna> If I remember correctly the name may have been some pun on cabal and kabbalah
05:42:04 <hanna> but I can't seem to find it via search engines. Anybody know what I'm talking about?
05:43:53 <ocramz> yep, thanks cocreature ^_^
05:49:14 <Shockk> sorry to re-ask, but anyone know the answer to my question?
05:49:26 <hanna> aha, found it: http://www.yesodweb.com/blog/2012/04/replacing-cabal
05:53:09 <ocramz> Shockk : reading your question
05:56:04 <ocramz> Shockk : the definitions are `<$ :: Functor f => a -> f b -> f a` and `(<*) :: Applicative f => f a -> f b -> f a`
05:56:37 <Shockk> ocramz: right, so it seems to be that <$ is to <$>, as <* is to <*>
05:56:40 <Shockk> is that correct?
05:56:54 <ADG> How to improve this function to split a given string at given positions: https://hastebin.com/udefujuhad.pl
05:57:44 <ocramz> Shockk : I don't think so because the first argument of <$ is a constant object
05:58:04 <ocramz> it expands to `fmap . const`
05:58:21 <Shockk> hmm
05:58:48 <ocramz> whereas when composing parsers there is a "context" to carry around
05:59:07 <Shockk> I mean, in the case where this is, for example, a Parser from attoparsec, and I do: Definition <$ char '='
05:59:28 <ocramz> what's Definition again?
05:59:30 <Shockk> would the char '=' still be consumed from the parser, and the result discarded?
05:59:34 <Shockk> it's just some type 
05:59:40 <Shockk> my own type I mean
05:59:48 <ocramz> yes but not a parametric one
05:59:49 <ocramz> ?
05:59:59 <tomzz> Can i change the infix precedence of a function named "<?>" ? infixl 6 (<?>) throws parser error :<
06:00:47 <Shockk> okay hm let me give a better example
06:01:29 <Shockk> for example:
06:01:32 <Shockk> wrappedInput = Just <$ getLine <*> getLine
06:02:00 <Shockk> would the result of wrappedInput be Just (the second line of input)?
06:03:16 <tomzz> ah, (<?>) is the prefix version. infixl 6 <?> is right.
06:04:55 <ocramz> Shockk : yes, by direct inspection, but I don't have an intuition for <$ right now. Never used it so far
06:05:02 <Shockk> ahh rgiht
06:05:03 <Shockk> right*
06:05:05 <Shockk> okay
06:06:11 <ocramz> I usually stick to <$> , <*> and *> , which fit together nicely in my head :D
06:07:42 <Shockk> <* is particularly nice for parsing 
06:08:16 <Shockk> I started thinking about <$ when I wanted to parse but ignore something at the start too
06:08:55 <ocramz> right, I'll experiment with it ^_^ thanks for the tip
06:09:05 <Shockk> thanks for the help too
06:15:16 <sepakorayl> how could i make something akin to c++'s get<T> for nested two-element tuples?
06:37:09 <sepakorayl> say n = ((((1 :: Int), (2 :: Float)), 'C'), "string"), (get n) :: Float = 2
06:53:52 <cocreature> sepakorayl: there is not really a nice solution for that. you can technically use http://lpaste.net/356444 but you probably don’t want to :)
06:54:26 <sepakorayl> :/
06:58:08 <sepakorayl> Sometimes I miss cpp metaprogramming
07:00:24 <cocreature> going back to C++ for a a bit usually solves that problem for me :)
07:01:16 <sepakorayl> nah I really like c++ I just avoid all non-modern features.
07:04:21 <sepakorayl> is there an alternative for writing extendible records?
07:04:35 <sepakorayl> extensible
07:12:39 <JScully> hello ! i have this datatype https://pastebin.com/jER7HCN4
07:12:55 <JScully> how can i manipulate tuples from the "run" list for example
07:13:02 <JScully> eehw, ready list
07:15:08 <JScully> i have created an instance of this data type
07:15:20 <JScully> with all proccesses having the state new
07:15:28 <JScully> now i want to move some to ready :|
07:15:52 <JScully> do i have to create a new instance of this list
07:15:54 <JScully> or can i work inside it
07:23:43 <dtornabene> curious about recommendation on the best way to install multiple versions of ghc on debian
07:24:37 <dtornabene> long story short, I grabbed a copy of Real World Haskell and want to do the coding as is, with an old compiler (as much as is possible) and then learn about the changes since on my own
07:25:23 <dtornabene> so, is there a general consensus on the best way to add an old compiler along side the system install? Like, Stack? or Vagrant? or.... something else?
07:31:46 <JScully> so basically what iam tryint to do is https://pastebin.com/e4Ze1WAC
07:31:49 <glguy> dtornabene: you don't need anything special, GHC supports multiple installed versions. easiest way is to specify a different --prefix flag to configure
07:32:07 <JScully> i want to move proccesses from "new" to "ready"
07:32:22 <JScully> so iam thinking i have to write a function that removes them from new
07:32:27 <JScully> and another function that adds them to ready
07:32:32 <JScully> is that too complicated?
07:37:34 <JScully> how can i apply "filter" to a object variable
07:38:06 <JScully> is there a variable name that is used in filter for each element of the list provided?
07:43:20 <davr0s> liftA2  ... applies a function to 2 containers, but they must indidivually have homogeneous data?
07:44:53 <JScully> how do i access object properties in filters
07:44:54 <JScully> ???
07:46:41 <yushyin> JScully: sorry I don’t understand your question
07:49:15 <dtornabene> glguy: thank you!
07:56:40 <JScully> yushyin i think my problem starts here
07:56:40 <JScully> https://pastebin.com/arM1FDML
07:56:49 <JScully> i am tryint to return the lectureExample object
07:56:52 <JScully> with that function :|
08:03:03 <JScully> impossible to just return an object
08:05:09 <pavonia> JScully: It's literally "return lectureExample"
08:05:39 <JScully> have it now i think, indentation problems everywhere :|
08:10:49 <davr0s> the standard multiplcation, * , is part of 'Num', right... would it be possible, and how would it pan out, to replace that with something taking/producing arbitrary types;
08:11:15 <davr0s> when trying to do that in Rust.. the result seems to be hell r.e. constraints
08:12:17 <davr0s> (^ i mean when trying to write generic code in rust where '*' can take different LHS,RHS, and produce another Output.. along with other operators, e.g. all of a sudden if you do +,- on the output of *   you need to put constraints upfront for that.. you basically end up writing the function again in the type constraints)
08:13:03 <pavonia> davr0s: You can override (*) locally. Or do you want it to be in a new type class?
08:13:34 <davr0s> what i've done is made   'class Mul a b c where    mul::a->b->c' 
08:13:58 <davr0s> i'm thinking 'could i un-import the standard * , and just use this for *'
08:14:24 <ski> perhaps you could add FDs to that class declaration ?
08:14:26 <pavonia> "import Prelude hiding (Num (*))" or so
08:14:38 <davr0s> typical uses = dimensional analysis,  fixed-point arithmetic, or  'matrix * matrix',  'matrix * vector',  etc
08:14:54 <ski> that would avoid some ambiguity requiring type ascriptions
08:15:03 <davr0s> FD = Functional Dependancies, ok I must read up..
08:15:10 <ski> (but you should only add such FDs if you're ok with what they mean semantically)
08:15:23 <davr0s> i've heard of them, and i dont know how they work yet :)
08:15:52 <ski> e.g., if you say `class Mul a b c | a b -> where mul :: a -> b -> c', then you're saying that the types `a' and `b', (functionally) determines `c', wrt `Mul a b c'
08:16:23 <davr0s> oh, so that constrains the inference
08:16:34 <ski> this means that for any `a' and `b', you can have at most one `c' with an instance declaration `Mul a b c', for these particular `a',`b',`c'
08:16:42 <davr0s> so basically that can get you back to the C++ case where 'the output is computed from the inputs'
08:16:51 <davr0s> or not
08:16:56 <ski> er, it should be `| a b -> c', not `| a b ->'
08:17:05 <davr0s> ahh ok 
08:17:09 <davr0s> it means 'c' depends on a,b
08:17:20 <ski> yes, "depends" in some way
08:17:23 <davr0s> 'this type is generated entirely from knowledge of a and b'
08:17:41 <davr0s> seems to be exactly what i want.
08:17:43 <ski> you don't have to specify some algorithm for how to compute `c'
08:18:09 <davr0s> you just specify examples in the 'instances', ?
08:18:14 <ski> the effect is that it just forbids you to make instances `Mul a b c0' and `Mul a b c1', for distinct `c0' and `c1', and the same `a' and `b'
08:18:27 <davr0s> ok thats perfect
08:19:11 <davr0s> in Rust what they do is 'c' here would be an associated type.   In C++, it's always generated from the inputs
08:19:13 <ski> and this means that when it infers constraint `Mul a b c0' and `Mul a b c1', it knows that `c0' and `c1' *must* be equal, so it replaces them by a single type variable (or whatever) `c', replacing those two inferred constraints by `Mul a b c'
08:19:59 <ski> davr0s : it's also possible to say `class Mul a b c | a b -> c , c a -> b , c b -> a where ...' if you also want to say that `c' and `a' together determines `b', and similarly with `c b -> a'
08:20:50 <ski> but you should only add such FDs if you're ok with restricting the class here, by forbidding "multiple" instance declarations along the lines i sketched above
08:21:37 <davr0s> yes, thats absolutely what I want. That will recover what I'm used to in C++, if i've understood correctly.
08:21:42 <ski> potentially, the more FDs you have, the less ambiguity there will be .. but not all of those situations might arise that commonly in practice, so it depends on how your use cases typically look like
08:23:00 <ski> davr0s : btw, functional dependencies here are similar to FDs in relational database theory (normalization of relations/tables), if you know anything about that. the difference here is that the relations/tables are now type classes (relations between types), and that this can be used to enforce a semantic "integrity constraint" on the type class, and avoid ambiguity
08:23:49 <davr0s> ski i do not know anything about that.
08:23:53 <ski> ok
08:24:36 <ski> davr0s : i should also mention that you can also make an associated type in Haskell. instead of `class Mul a b c | a b -> c where mul :: a -> b -> c', you can say `class Mul a b where type Prod a b; mul :: a -> b -> Prod a b'. here you get the effect of the FD for free (you can't *not* get it). `a' and `b' automatically determines `Prod a b'
08:25:01 <davr0s> that might be better,
08:25:28 <davr0s> i've seen the associated types in Rust and of course in C++ we have all sorts ('here's a collection, here's it's iterators..')
08:25:43 <ski> davr0s : `type Prod a b' here is an associated type synonym. this means that `Prod a0 b0' and `Prod a1 b1' are allowed to be equal, for `a0',`b0' being distinct from `a1',`b1', respectively
08:26:24 <davr0s> i presume that Prod there would be defined or computed by instances,
08:26:49 <davr0s> and i'd hope defaults could also yield a Prod .. (Rust has that disabled at the moment)
08:26:59 <ski> davr0s : if you replace it by `data Prod a b', then you get an associated data type, and you *must* use `data' (or `newtype') in an instance to define it. then `Prod' will automatically be injective, iow you get the effect of (separate) FDs `Prod a b -> a',`Prod a b -> b'
08:28:28 <ski> davr0s : yes, in an instance, you will say something like `instance Mul X Y where type Prod X Y = ...' (in the former case) or (in the latter case) `instance Mul X Y where data Prod X Y = ...' (or with `newtype')
08:29:20 <ski> with an associated *data* type, `Prod X Y' is always a new type (can remove ambiguity). with an associated type synonym, `Prod X Y' could simplify to a preexisting type
08:30:28 <ski> using FDs on the class is somewhat more general and powerful, but also a bit more clunky, if all you need is an associated type
08:31:17 <ski> logically, the FD in `class Mul a b c | a b -> c' means that for any types `a' and `b', there can be at most one `c' with `Mul a b c' holding
08:31:27 <juri_> i'm getting a monomorphism restriction warning, and a polymorphic local binding warning about a function that has no type signature. my code, however, compiles. when i stick the cype given by the polymorphic local binding warning into my code, my code fails to compile, complaining about a missing instance.
08:31:32 <juri_> what gives? ;)
08:32:26 <ski> formally, one can express this as `forall a b. unique c. Mul a b c' (`unique' expressing "exists at most one"), which is the same as `forall a b c0 c1. (Mul a b c0,Mul a b c1) => c0 = c1', iow if we have two instances with the same `a' and `b', then the `c's *must* in fact also be equal
08:32:40 <juri_> http://kalli1.faikvm.com/ImplicitCAD/Stable/files/d34f3ca1a847693986b0ad044266471a80e7168e/tests/ParserSpec/Util.hs < -- the code in question.
08:33:08 <juri_> specifically, the 'parseWithLeftOver' function's use of 'leftOver'.
08:33:49 <Logio> siihen olisi se kämppä ratkaisu mutta ehkä just ennen sitä se kannattais nähdä miten pitkään sietää oleskelua tuollaisen jonnen seurassa :D
08:34:13 <Logio> oh sry, mismeta
08:34:37 <mrkgnao> is that Finnish?
08:34:53 <Logio> yes
08:39:53 <ski> juri_ : hm, what's the type given by the polymorphic local binding warning ?
08:40:23 <juri_> leftOver :: forall u. ParsecT s0 u m0 [ghc-prim-0.5.0.0:GHC.Types.Char]
08:43:10 <ski> juri_ : what if you try with `leftOver :: Parser String' ?
08:43:28 <ski> juri_ : er, i also forgot to ask what what the missing instance it complained about was
08:50:08 <juri_> No instance for (Stream s0 m0 ghc-prim-0.5.0.0:GHC.Types.Char)
08:54:37 <ski> hm, yes. it doesn't work for all `s0' and `m0', you'd at least have to (either say `leftOver :: forall u. Stream s0 m0 Char => ParsecT s0 u m0 [Char]', i think, or) specify `s0' at least to some more specific token stream type, e.g. `String' (which you're using anyway in `parseWithLeftOver'), or `ByteString'
08:59:07 <ski> (and then probably need to either also add a constraint `Monad m0', or else just replace `m0' by e.g. `Identity', also setting the user state `u' to `()' since you don't use it, so that `leftOver :: ParsecT String () Identity [Char]' is the same thing as `leftOver :: Parser String')
09:03:03 <Lowl3v3l1> hey guys. I am trying to install leksah using the haskell stack, but i get various errors because a lot of my software is too new ( including ghc 8). Is there a nice tutorial on how to go about using leksah? Or shouldn't i be using it anymore at all?
09:04:41 <ooh-hes-tryin> can anyone tell me how to silence deprecation warnings in ghci?
09:06:16 <mrkgnao> :set -Wno-deprecations?
09:06:19 <mrkgnao> or something similar
09:07:30 <ooh-hes-tryin> awesome. that did it. thanks mrkgnao++
09:07:49 <mrkgnao> yup
09:09:14 <sm> Lowl3v3l1: it's probably going to require specific support from the author, you could try the bug tracker
09:09:24 <juri_> ski: sorry for the lag, and thanks for the help.
09:10:25 <joe9> I have a date (Day) and want to find the last month's day. I could not find removeMonths in Data.Time. There is an addMonths go. any suggestions, please?
09:11:16 <glguy> add -1 months?
09:11:33 <juri_> wow. ok, "leftOver :: Parser String" works.
09:11:35 <joe9> glguy: cool. Thanks.
09:12:38 <ski> juri_ : np
09:12:57 <ski> juri_ : i'd also have suggested trying to inline `leftOver' ..
09:13:07 <juri_> and yay, i do understand some of the rest of what you are talking about. \o/
09:13:33 <juri_> I'm almost partially a haskell programmer. i swear...
09:14:07 <ski> i agree it's annoying that it doesn't work with the signature it suggested
09:14:39 <juri_> that's not too common.
09:14:43 <muzzle> I have a problem with using ghc's llvm backend. GHC says 'could not execute: opt' even though i have 'opt' in path
09:14:50 <muzzle> I'm on OSX 
09:14:57 <muzzle> and I'm using homebrew llvm
09:15:00 <juri_> I'm '-Weverything'ing all my code.
09:17:57 <muzzle> how can I get ghc to use the opt and llc binaries in my PATH ?
09:23:49 <joe9> is there a library function to get the weekday? (1 == Sunday or Monday, 2 == next day,) . There is Data.Time.Calendar.WeekDate.toWeekDate, but, it assumes that the 1st of the year is a Monday(?)
09:30:45 <sm> joe9: that's just for purposes of week numbering. It will give you the correct weekday
09:31:00 <sm> try it
09:36:46 <joe9> sm, Thanks.
09:37:05 <joe9> sm, 2017 starts on a sunday. so, I was not sure.
09:38:23 <hpc> in that case, make sure the last day of 2016 was a saturday
09:38:29 <hpc> because it didn't start on a sunday :D
09:40:41 <sm> that haddock could probably be written more clearly
09:40:51 <sm> http://hackage.haskell.org/package/time-1.8.0.2/docs/Data-Time-Calendar-OrdinalDate.html#v:mondayStartWeek is easier
09:52:19 <ooh-hes-tryin> is there a way to tell ghci to load all the dependencies of a given module you're working on?
09:53:33 <glguy> ooh-hes-tryin: yes, add import declarations at the top of the file
09:54:59 <ooh-hes-tryin> ohh. working with stack ghci and when it built and reloaded, I didn't have access to any of that. but sure enough if I just use :l Module I get it all back
09:55:11 <ooh-hes-tryin> thanks glguy++
09:55:59 <ooh-hes-tryin> ahh it was looking at Main previously ;)
10:08:34 <joe9> sm, Thanks.
10:25:31 <davr0s> can haskell functions use file IO lazily, e.g. 'read a file', but you dont actually get a file, you get an acessor that will bring parts in on demand ... how would that compare to relying on memory-mapped files through the OS
10:32:06 <mauke> davr0s: that is pretty much what hGetContents does
10:33:17 <davr0s> I guess form haskel's purity perspective, that data is still just immutable so it doesn't matter that there's IO going on behind the scenes
10:34:12 <mauke> it comes with its own set of problems
10:34:25 <monochrom> Prelude's hGetContent is going to incur much more overhead because of list.
10:35:26 <monochrom> ByteString's and Text's hGetContent reads one chunk at a time (around 64KB), but it still goes through the usual file system read, rather than mmap.
10:37:19 <monochrom> And as usual all hGetContent's first go through Haskell's own Handle mechanism, with its own layer of buffering and code.
10:37:55 <monochrom> and book-keeping.
10:38:24 <monochrom> It's Lasagnas all the way down!
10:38:44 <Unicorn_Princess> what should I use to sleep a haskell program for a few seconds? threadDelay says it's GHC only, and I was wondering if there's something more portable-ish
10:38:54 <mauke> threadDelay
10:39:04 <Unicorn_Princess> heh, fair enough :)
10:39:18 <mauke> there are no compilers but ghc and simon is its prophet
10:39:18 <monochrom> I don't think there is a portable alternative.
10:39:43 <monochrom> IIRC even Hugs goes with GHC's Control.Concurrent and threadDelay. I think it's pretty safe.
10:40:57 <monochrom> Just watch out its time unit. "threadDelay 1000" is going to be merely 0.001 seconds.
10:41:01 <c_wraith> Didn't hugs use the same base library as GHC (with a bunch of conditional compilation thrown in)?
10:41:12 <Unicorn_Princess> well, there's 0 chance I'll port this program ever, was just curious
10:41:22 <monochrom> :)
10:41:31 <monochrom> Yeah c_wraith.
10:43:27 <Lokathor_> "in microseconds"
10:43:34 <Lokathor_> what a goofy unit to have picked
10:43:54 <c_wraith> I remember seeing lots of those ifdefs for for Hugs when I first started using haskell.  But they've gone away since then.
10:44:04 <monochrom> The large part of Control.Concurrent has been around for 17 years. It is definitely tenured, if not portable.
10:44:09 <cocreature> it also overflows quite quickly so if you want to sleep for a large amount you can’t use it
10:44:25 <c_wraith> cocreature: only on systems with 32-bit Int
10:44:43 <c_wraith> But yeah, the overflow is like 34 minutes on systems with 32-bit Int
10:45:01 <monochrom> But yeah microsecond was an extremely futuristic choice when it was conceived in year 2000.
10:45:01 <cocreature> oh yeah I forgot that Int is 64bit on 64bit systems
10:45:13 <monochrom> Before 2000, too.
10:46:01 <cocreature> iirc there is a longsleep  or something like that in some package
10:46:40 <c_wraith> threadDelay has also had bugs on some versions of OS X, where the way it used kqueue overflowed with long delayhs..
10:46:45 <c_wraith> *delays
10:47:01 <c_wraith> some versions of OS X and GHC, that is
11:43:40 <tomleb> Hi, I'm trying to create a encrypted cookie with Servant.Server.Experimental.Auth.Cookie
11:43:55 <tomleb> But I get a 'CannotMakeIV' error
11:44:06 <tomleb> So I'm obviously not create the cookie with a proper IV
11:44:18 <tomleb> But I don't see anywhere how to create a valid IV
11:54:10 <bollu> cocreature ping again? ;)
11:55:49 <Lokathor> http://lpaste.net/356447 ta da, an @ moves on the screen
12:09:49 <tomleb> Here's my problem http://ix.io/xYn/hs, I'll read more on IV later to see if I can figure it out myself but would be nice if someone had a clue
12:16:19 <malc_> Having trouble building shake, `cabal install shake.cabal' Linking dist/build/shake/shake ...
12:16:19 <malc_> /usr/bin/ld: cannot find -lHSrandom-1.1-9tceXaeYIMZ4JrKq20Egog
12:16:19 <malc_>  ... does anyone have an idea what's wrong here?
12:18:04 <geekosaur> you are on arch and they broke their ghc
12:18:09 <geekosaur> try explicitly with -dynamic
12:19:22 <geekosaur> hm, I think via cabal-install that is --enable-executable-dynamic
12:19:31 <malc_> geekosaur: thank you, trying
12:21:25 <malc_> geekosaur: worked like a charm, once again - thanks
12:32:45 <c_wraith> tomleb: things to know about an IV.  1. It should be the same size as cipher's block size.  2. It is not secret.  3. It must never be repeated.
12:33:48 <MagneticDuck> Is there any name for a F_sigma set that is not G_delta and vice versa?
12:35:19 <c_wraith> tomleb: never be repeated per key, that is.  But I'm betting for that use case, the key never changes.
12:37:02 <c_wraith> tomleb: also, any library that makes you specify an IV is broken.
12:38:59 <tomleb> Hum
12:39:53 <c_wraith> mostly because any time you put requirements like that on the user of a library, there will be a large set of users who don't understand them and do it wrong.
12:40:03 <tomleb> Like me
12:40:30 <c_wraith> and that's no indictment of your skill.  That stuff is just specialized knowledge with lots of fiddly details. :)
12:41:07 <tomleb> Yeah what I thought, that's why I wanted to come here. I mean I could probably read tons of documentation and find out how, but I didn't plan to become a crypto expert this weekend
12:41:48 <tomleb> So if my key is 5 bytes, then the IV should also be 5 bytes ? Can I put anything in the 5 bytes though ?
12:42:12 <c_wraith> well, it should match the block size, which is a property of the cipher.
12:42:15 <tomleb> If I change "iv??" to "12345" and put the key with length 5, I still get CannotMakeIV error
12:42:25 <tomleb> oh
12:42:35 <c_wraith> It's probably 128 bits
12:42:55 <tomleb> Right so it's not the server key length, but the block size
12:43:21 <c_wraith> And it's really important to not reuse them.  Like, really. :)
12:43:43 <c_wraith> So they should come from a per-key counter or be randomly generated.
12:44:07 <tomleb> Yup, with 128 that worked
12:44:20 <Adeon> is ExitSuccess strictly exitcode 0 or any non-zero value when you run processes with `process` package?
12:44:23 <tomleb> oh wait no
12:44:26 <tomleb> it didn't lmao
12:44:33 <c_wraith> Did it just have a different error?
12:44:50 <tomleb> No, just output was longer so I didn't even read it and assumed it worked
12:44:55 <c_wraith> ah
12:45:09 <tomleb> (pack $ replicate 128 '1') I put that
12:45:22 <c_wraith> Oh.  that's bytes, not bits
12:45:24 <c_wraith> uh.
12:45:27 <c_wraith> > 128/8
12:45:27 <ongy> replicate 16
12:45:29 <lambdabot>  16.0
12:45:36 <tomleb> Ah
12:45:39 <c_wraith> yeah, I can't divide by 8 in my head. :)
12:45:51 <tomleb> yup, worked
12:46:10 <tomleb> Ok so now the good stuff, you're saying whenever I change the server key I should change the IV as well ?
12:46:27 <c_wraith> No, I'm saying you should use a different IV every single time you encrypt something
12:46:36 <ongy> c_wraith: you clearly haven't done a lot of manual packet building for ipv6 :P
12:46:46 <c_wraith> ongy: correct! :)
12:47:05 <tomleb> Oh! Ok
12:47:19 <ongy> tomleb: the IVs should be unique for the life time of a key. When you generate a new key, you can reuse IVs (and generally you should generate new keys, when you run out of possible IVs)
12:47:36 <c_wraith> Unfortunately, I think these are being used to encrypt session cookies
12:47:43 <c_wraith> which means you can't really change keys
12:47:55 <c_wraith> Unless you're ok with destroying all current sessions when you do
12:48:51 <tomleb> So how should I generate IV's then ? and why isn't this library doing it for me :')
12:49:21 <c_wraith> You should probably just generate them randomly
12:49:30 <tomleb> Ok, with a random generator
12:49:44 <c_wraith> Because that's durable to multiple servers and accidental loss of state, unlike counters.
12:49:54 <tomleb> let random = 16
12:49:55 <tomleb> :')
12:50:07 <c_wraith> The problem with random generation is that 128 bits is small enough to hit birthday paradox issues.
12:50:19 <nshepperd>  oh noooo, arch got ghc 8.0.2 but it's borken
12:50:36 <ongy> nshepperd: the dynamic linking stuff?
12:50:48 <tomleb> c_wraith: Any place I should read about this ? I don't want to bother you too much either
12:51:03 <nshepperd> ongy: yeah, it's all borken
12:51:28 <ongy> tomleb: basic crypto/security stuff. IVs are something that comes up whenever you do chaning crypto modes
12:51:31 <nshepperd> trying to build cabal-install in a sandbox: /usr/bin/ld: cannot find -lHSCabal-1.24.2.0 :(
12:51:38 <geekosaur> yep
12:51:58 <c_wraith> tomleb: really, you shouldn't have to know this stuff.  It should be the library's responsibility.
12:52:01 <ongy> argh -.-. Time to make ghc-git aur package?
12:53:48 <tomleb> Then I'll just use that and have some random generator for now
12:53:50 <unclechu> guys, why the docs tell me that reader monad is simplier than state monad? why is that should be true?
12:54:12 <c_wraith> unclechu: just conceptually, it's read-only instead of read/write
12:54:41 <c_wraith> unclechu: so you don't need to worry about details of propagating writes
12:55:18 <systemfault> Easier to use, not really... I'd say it's easier to write the instance.
12:56:09 <c_wraith> There's also the weird conceptual detail where the Monad instance for Reader is kind of unnecessary.  It adds no power beyond what you get out of the Applicative instance.
12:56:18 <c_wraith> Which isn't true at all of State
12:57:37 <ongy> nshepperd: any idea why pacman -Syu wants to install ~100 haskell packages, when I don't have anything ghc installed currently?
12:58:26 <nshepperd> ongy: the dynamic linking stuff means that packages like stack & cabal-install now have runtime deps, I guess
12:58:30 <monochrom> Perhaps you're using xmonad? :)
12:58:43 <nshepperd> ongy: instead of build deps
12:59:06 <ongy> nshepperd: I don't have stack installed. And I'm using (my own) cabal-install-git from the aur. pretty sure that doesn't have deps
12:59:34 <nshepperd> oh, ghc depends on some stuff also
12:59:38 <MarcelineVQ> sure it does
12:59:58 <nshepperd> basically any haskell binaries you have installed
13:00:54 <ongy> pandoc... this is silly
13:00:59 <nshepperd> auugh, this is a mess
13:02:17 <ongy> I moved from arch packages to local builds some time ago either way (mostly for new-build). Let's see if my setup breaks with the current ghc...
13:02:44 <geekosaur> likely yes
13:02:51 <tomleb> c_wraith: Now reading up on birthday paradox :')
13:07:45 <monochrom> The birthday paradox is less crazy than the why-all-assignments-are-due-on-the-same-day paradox. :)
13:08:59 <tomleb> lol
13:09:14 <monochrom> You're taking 5 courses. Each course's professor randomly, independently picks one of Monday-Friday for his/her tri-weekly assignment due date. What is the probability that two assignments are due on the same day?
13:09:55 <ongy> monochrom: or the even better: "All you exam dates are given out by a central organization. What's the chance, at least 2 of them are at the same time"
13:10:33 <Lowl3v3l> monochrom: the solution is simple : they are not given  at random, but her godness, Eris, herself makers them all fall to the same date! :D
13:11:18 <monochrom> Now I want to ask Eris out for dinner and movie.
13:11:28 <c_wraith> just don't let her offer you any fruit
13:11:41 <Lowl3v3l> monochrom: whatever you do, never pray for it! praying is dangerous
13:12:21 <ongy> well, ghc-static fixes local builds for now (but mixing package and local libraries will be even more of a mess than before)
13:22:26 <nshepperd_> ongy: i think maybe we will need at least aur {pandoc,happy,...}-static if we want to not have all these libraries
13:23:57 <ongy> I'm ok with my /builds/ directory. Setting up the aur packages... they'd have to be -bin, and I don't like that either
13:28:03 <ongy> oh, this is annoying. happy requires happy to build...
13:28:48 <c_wraith> ongy: huh.  I've built it from source without having it installed..
13:30:08 <ongy> http://lpaste.net/356450 mhh
13:30:12 <davr0s> if i have 'functor', 'applicative', is there a way to roll this from any library code .. mat4_to_vec4 (Mat4 ax ay az aw) = Vec4 ax ay az aw   -- 'store a matrix as a vector of vectors'
13:30:33 <davr0s> (the idea being i'd have that for 2,3,4 elements..)
13:30:56 <davr0s> i'm thinking haskell might have a less cut-pasty way to do that
13:45:49 <ertes> davr0s: i'm not sure i understand your question, but look at the 'linear' library
13:46:03 <ertes> davr0s: it simply represents a matrix as a vector of vectors
13:46:22 <davr0s> makes sense sometimes
13:46:45 <davr0s> i guess the quetison is 'is there a more general way to convert data between sequence types'
13:47:21 <ertes> davr0s: well, you can always go through a list
13:47:27 <monochrom> I think no, unless you accept "Y.fromList . X.toList".
13:47:56 <ertes> if your sequence type is Foldable, you even get 'toList' for free
13:48:07 <davr0s> it is foldable.
13:48:11 <monochrom> All of them tend to have fromList's and toList's. Now, if you ask me "will the compiler eliminate the intermediate list?", I don't really know.
13:48:38 <ertes> it will usually eliminate the intermediate list, if your 'fromList' is written as a fold
13:48:49 <davr0s> i went through the exercise of implementing 'dot product'  through 'applicative' and 'foldable' ..  applying * to the pair and reducing with +
13:49:47 <davr0s>  Now, if you ask me "will the compiler eliminate the intermediate list?", I don't really know. <<< heh
13:49:58 <ertes> fromList is problematic for fixed-length sequences though…  there is still no standard library for length-indexed sequences
13:50:01 <davr0s> i was about to comment.. if you showed me this 20 years ago, i would have laughed
13:50:23 <davr0s> "what kind of idiot would wrap vector maths in so many layers"
13:51:09 <davr0s> but the knowledge here will have broeader application.
13:51:44 <ertes> davr0s: are you worried about run-time performance with nested data types?
13:52:20 <davr0s> ertes  nothing like C++  "std::array<T,N>" ? , so maybe it really does need the explicit approach for 2,3,4 elements?
13:52:45 <davr0s> ertes   both.. i would have traditionally laughed at the idea of wrapping it in so many layers, then even expecting it to perform well
13:53:20 <ertes> if your fields are strict, GHC will actually flatten the memory-representation
13:53:47 <ertes> it has done that by default since a bunch of major versions now
13:54:02 <davr0s> as much as anything i'm still finding my way around how you can compose types and write polymorphic code on them (with all the nesting)
13:54:31 <ertes> as for the conversion: there are ways to generalise it, and they go in different directions
13:54:44 <ertes> for example you can have a lens from a 4D vector to a 3D subvector
13:55:01 <ertes> then you can use that lens to extract or even modify that subvector in isolation
13:55:16 <davr0s> like x,y,z,w  ->   (x,y,z)  , w ?
13:55:44 <ertes> @let data V3 a = V3 !a !a !a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
13:55:46 <lambdabot>  Defined.
13:55:52 <ertes> @let data V4 a = V4 !a !a !a !a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
13:55:54 <davr0s> i've thought about doing things like making  x,y,z  , w differnt types, so you could do homogeneous coordinates with 3 values and w= type 'One' or 'Zero'
13:55:54 <lambdabot>  Defined.
13:56:22 <davr0s> if I try to do that right now i'll just be in for a world of compiler-error pain
13:57:00 <ertes> @let sub3 :: Lens' (V4 a) (V3 a); sub3 f (V4 a' b' c' d) = (\(V3 a b c) -> V4 a b c d) <$> f (V3 a' b' c')
13:57:02 <lambdabot>  Defined.
13:57:03 <davr0s> 'deriving Foldable,Functor,'  .. i didn't know you could do that, i rolled those manually , lol
13:57:20 <ertes> > V4 11 22 33 44 ^. sub3
13:57:23 <lambdabot>  V3 11 22 33
13:57:41 <ertes> > (sub3 . traverse +~ 100) V4 11 22 33 44
13:57:44 <lambdabot>  error:
13:57:44 <lambdabot>      • Couldn't match expected type ‘Integer
13:57:44 <lambdabot>                                      -> Integer -> Integer -> Integer -> t’
13:57:56 <ertes> > (sub3 . traverse +~ 100) (V4 11 22 33 44)
13:57:58 <lambdabot>  V4 111 122 133 44
13:58:04 <ertes> davr0s: ^
13:58:11 <davr0s> whats +~ ?
13:58:42 <ertes> (l +~ dx) adds the value dx to each component the setter 'l' points to
13:59:06 <davr0s> oh is it part of the lens library..
13:59:12 <ertes> yeah
13:59:36 <ertes> > (both +~ 5) (3, 4)
13:59:38 <lambdabot>  (8,9)
13:59:43 <tomleb> c_wraith: Oh, I think I don't even need to play with IV's
13:59:59 <c_wraith> that's good news. :)
14:00:05 <davr0s> '.traverse',  i'm not familiar with that. i thought you'd have done that with 'fmap ((+) 100)'
14:00:10 <callmecabman> > foldr id 0 [(+1), (+2), (+3)]
14:00:12 <lambdabot>  6
14:00:18 <tomleb> There are a couple of functions dealing with sessions, I was going to do that manually, guess I can just use those instead
14:00:21 <ertes> davr0s: (.) is just the way you compose lenses
14:00:39 <ertes> davr0s: it's literally just function composition
14:00:40 <davr0s> . is just general function composition, right?
14:01:11 <davr0s> i haven't even started looking at lenses really... i'll see how far i can get without them
14:01:43 <c_wraith> iirc, the initial reason the lens library was created was to make working with the linear package easier.
14:01:57 <ertes> davr0s: or you could learn them…  lenses are really useful with vectors anything =)
14:02:57 <callmecabman> do not consider it an advertisment, but @neongreen has quite a nice guide about lenses
14:03:24 <davr0s> I still have more to learn about the rest of haskell I think , but I'll take on board what you said.
14:03:59 <c_wraith> The big thing about lens is that using them is usually *way* easier than understanding the implementations. :)
14:04:09 <callmecabman> exactly^
14:04:16 <davr0s> that would worry me.
14:04:36 <davr0s> i dont expect to understand my CPU gate for gate.. but i do expect to understand my programming tools :)
14:04:55 <ertes> but they aren't actually that difficult to understand either
14:04:58 <c_wraith> The problem is that the type errors sometimes leak implementation details, making small errors have messages that look like the world is ending. :)
14:05:04 <monochrom> Moar lasagnas.
14:05:29 <davr0s> c_wraith that sounds familiar from the world of C++ templates.
14:05:30 <ertes> the most mind-bending thing about them is how (.) composes them, and that can be understood by expanding definitions
14:05:55 <c_wraith> davr0s: that's analogous, yes
14:06:04 <davr0s> i gather lenses make it easier to write mutative code with state monads etc
14:06:21 <Tuplanolla> Lenses solve every problem, davr0s.
14:06:23 <c_wraith> that is certainly a thing they can do. :)
14:06:23 <ertes> (it's usually easier to understand, if you're already somewhat familiar with how CPS works)
14:07:02 <monochrom> In an alternate universe, lenses are defined by newtype rather than type aliases, error messages are less leaky, but you can't use vanilla (.), you have to use a different name (whose sole job is to unwrap, (.), rewrap).
14:07:05 <davr0s> i am , conversely, very interested in figuring out how to do things with the least amount of mutation
14:07:45 <c_wraith> davr0s: lenses are actually good for that.  They usually optimize very well.
14:08:14 <ertes> oh, and lenses make for one hell of a stunning live coding performance =)
14:08:19 <c_wraith> Which is part of why their implementation gets weird sometimes. :)
14:08:54 <ertes> (well, not lenses per se, but traversals)
14:09:17 <callmecabman> Can you elaborate a bit about traversals and their connection to lenses?
14:09:17 <ertes> (lenses are kind of the most boring object in the universe of optics)
14:09:32 <ertes> callmecabman: a traversal can point to multiple values
14:09:49 <ertes> a lens is a traversal that is restricted to exactly one value
14:10:04 <ertes> for example 'both' is a traversal
14:10:07 <c_wraith> callmecabman: and thanks to clever representation choice, traversals and lenses can be combined in a way that makes them just sort of work the way you'd want
14:10:10 <ertes> > (both +~ 5) (3, 4)
14:10:12 <lambdabot>  (8,9)
14:10:42 <ertes> > ("muha", "haha") ^. both
14:10:44 <lambdabot>  "muhahaha"
14:11:23 <c_wraith> > [(1,2),(3,4)] ^.. traverse . _2
14:11:26 <lambdabot>  [2,4]
14:12:08 <ertes> callmecabman: it also makes sense if you look at the types
14:12:20 <c_wraith> > ([1,2],[3,4]) & _2 . traverse +~ 10
14:12:22 <lambdabot>  ([1,2],[13,14])
14:12:30 <ertes> type Lens s t a b = forall f. (Functor f) => (a -> f b) -> s -> f t
14:12:37 <ertes> type Traversal s t a b = forall f. (Applicative f) => (a -> f b) -> s -> f t
14:12:58 <callmecabman> finally the type comparison was enlightening. Thxalot
14:13:02 <ertes> a Functor is kind of like an Applicative that is restricted to a single f-action
14:13:23 <ertes> with Applicative you have liftA2, liftA3, etc.
14:13:39 <ertes> with Functor you only have 'fmap', which you might call liftA1
14:14:23 <monochrom> Interesting.
14:15:34 <ertes> both f (x, y) = liftA2 (,) (f x) (f y)
14:15:55 <ertes> fstL f (x', y) = fmap (, y) <$> f x'
14:16:17 <unknownln> somehow I didn't realize that ^. combines results with monoid, that's neat
14:16:28 <unknownln> > [1, 2, 3] ^. traverse . to Sum
14:16:30 <lambdabot>  Sum {getSum = 6}
14:16:36 <ertes> unknownln: (^.) doesn't, but Const does
14:16:46 <unknownln> yup, just looked at the definition for Getting
14:16:51 <unknownln> makes sense
14:28:07 <Tuplanolla> > (+) <$> ("It's not even ", 42) <*> ("exclusive to `Const`.", 13)
14:28:10 <lambdabot>  ("It's not even exclusive to `Const`.",55)
14:30:04 <Tuplanolla> If `Functor` gives rise to `Lens` and `Applicative` to `Traversal`, how about `Monad`?
14:30:04 <akfp> how can I use lens to traverse all but the first element in a list?
14:31:17 <ertes> > (_tail . traverse +~ 10) [1,2,3,4]
14:31:20 <lambdabot>  [1,12,13,14]
14:31:38 <akfp> ertes thanks!
14:37:47 <bollu> cocreature ping
14:53:21 <tomleb> I have 'data Foo = Foo Text' and I need to have an instance of Serialize for Foo
14:53:45 <tomleb> I tried using Generic and 'instance Serialize Foo' but I can't because Text doesn't have an instance of Serialize
14:53:52 <tomleb> What is the best way to go about this ?
14:54:22 <ertes> tomleb: https://hackage.haskell.org/package/cereal-text
14:54:45 <tomleb> uploaded 1 year ago
14:54:47 <ertes> tomleb: if you turn 'data' into 'newtype', you can use GeneralizedNewtypeDeriving, which might give you a slightly cheaper instance
14:54:50 <tomleb> Heh, is that the best method ?
14:55:13 <tomleb> I actually have a newtype
14:55:15 <ertes> tomleb: well, i'm pretty sure a Serialize instance for Text is fairly low-maintenance
14:56:11 <tomleb> I actually have newtype Bar = Bar Foo
14:56:15 <ertes> tomleb: disclaimer: i don't know the author, and they don't seem to have uploaded a lot
14:56:29 <tomleb> and just need the Serialize for Bar, not Foo
14:56:48 <ertes> if you don't trust that package, feel free to create your own, or even encode to ByteString for serialisation
14:56:51 <tomleb> but I thought I must have the instance for Foo as well, is that not the case ?
14:57:23 <tomleb> Well I have a ToJSON and FromJSON instance, could I just use that ?
14:57:35 <ertes> automatic generation of the instance only works, if all components have Serialize instances
14:57:41 <tomleb> right
14:57:58 <ertes> personally i would encode to ByteString
14:58:07 <ertes> in an explicit instance that is
14:58:19 <ertes> see Data.Text.Encode
14:58:24 <tomleb> Oh
14:58:31 <tomleb> So basically just encode/decode ?
14:58:44 <ertes> yeah…  encode, then serialise the ByteString
14:58:48 <tomleb> yeah
14:58:50 <tomleb> ok
14:58:55 <tomleb> that's a good idea
14:58:58 <tomleb> I'll try that out
14:58:59 <tomleb> thanks
15:03:48 <bollu> @tell quchen I found this document which seems useful: file:///Users/bollu/reading/2-Functional-Compilers/the-stg-RTS-revised.pdf
15:03:48 <lambdabot> Consider it noted.
15:04:11 <bollu> @tell quchen: dang, wrong link: https://www.researchgate.net/publication/242608990_The_stg_runtime_system_revised
15:04:11 <lambdabot> Consider it noted.
15:13:07 <colonelj> hi I don't understand how the do syntax combines with infix words and other stuff
15:14:30 <c_wraith> infix operators always have lower precedence than function application.
15:14:40 <c_wraith> operator precedence is library-configured
15:14:44 <colonelj> here's the code, I want to make the r in scope http://lpaste.net/356451
15:14:58 <ertes> colonelj: if an operator is indented less than the do-block, but on the parent level, it will act on the do-block as a whole
15:15:18 <ertes> colonelj: yeah, exactly like that
15:15:51 <colonelj> I think the `catch` is acting on the whole do block not the sub do-block I defined
15:16:05 <colonelj> what's the correct syntax?
15:16:17 <c_wraith> indent it further, so it doesn't close the do block
15:16:23 <colonelj> I've tried putting braces and parentheses around stuff and it just complains
15:17:07 <ertes> colonelj: if it's on the same level as the do-block *contents*, it will still act on the whole block
15:17:23 <colonelj> can I move the `catch` indented more?
15:17:32 <ertes> you have to
15:18:10 <ertes> and then it's just a continuation of the expression on the previous line
15:18:13 <colonelj> ok right yes it seems to be working now
15:18:39 <colonelj> or at least it builds, not sure if it actually works
15:19:15 <colonelj> ertes: what do you mean by just a continuation of the expression on the previous line?
15:19:39 <colonelj> it's taking on the whole do block at the same indentation level as its argument 
15:24:30 <ertes> colonelj: you can write 'putStrLn', then on the next line, you can write its argument, if you indent it past the level of 'putStrLn' indented
15:24:34 <ertes> -indented
15:24:48 <ertes> -,
15:33:14 <colonelj> ertes: ok that makes sense
16:01:59 <will_> so say in python i wanted to find the maximum product of two adjacent elements of an array, then i can just iterate over a[i] and a[i+1], how can you approach this in Haskell? 
16:02:28 <Tuplanolla> > ap zip tail [1 .. 8]
16:02:30 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8)]
16:03:05 <Tuplanolla> You can then replace `zip` with `zipWith` to work with the pairs, will_.
16:03:40 <will_> alright, i'll try that, thank you
16:04:23 <Tuplanolla> However, if by arrays you really mean arrays, then the answer is the same as it is for Python, will_.
16:05:05 <will_> the input is given to me as an array
16:05:43 <Tuplanolla> What's the type?
16:09:16 <will_> int
16:09:34 <Tuplanolla> That's a number, not an array.
16:09:47 <tomleb> Hum, I'm having a weird problem
16:09:53 <will_> oh sorry i thought you mean in the array 
16:09:57 <will_> *meant
16:10:33 <tomleb> I have a route with Servant that accept a Post '[JSON] User and when I make a request, it just hangs
16:10:44 <tomleb> If I change User to something else, then it's fine
16:11:43 <Tuplanolla> I bet it was `[Int]`.
16:16:27 <np356> Hello Haskell Gods! I've got past every haskell tutorial on the web and I'm in love with this language. However I can never justify using it for production work due to things like hosting and dev produtivity, hiring haskell dev and code readibility.
16:16:38 <np356> What's your experience in dealing with that?
16:17:15 <EvanR> i was really surprised by readability of existing code very shortly after starting haskell
16:17:33 <EvanR> i found i could tell what stuff was doing in libraries without really having any writing experience
16:17:45 <EvanR> much more so than say PHP
16:17:52 <Rembane> EvanR: Was this before lens was introduced?
16:17:56 * Rembane ducks
16:18:15 <davr0s> heh
16:18:20 <EvanR> lens is sort of its own language
16:18:31 <Rembane> Indeed.
16:18:40 <Rembane> I only know Haskell, I don't know lens.
16:18:46 <np356> thats another problem...
16:18:48 <EvanR> the stuff im talking about didnt use any lenses
16:19:10 <np356> shit like lens or yesood make things much harder to work with
16:19:13 <Rembane> I do agree with EvanR though. Reading and maintaining Haskell code is a true joy.
16:20:18 <np356> a :--> B b
16:20:22 <EvanR> hiring haskell devs might be hard, but really, hiring devs at all seems hard
16:20:24 <np356> no, thank you
16:20:50 <np356> I actually go to plenty local haskell meetups and have tons of hungry haskell beasts
16:20:59 <np356> mostly at the junior-mid level
16:21:00 <davr0s> is there going to be more of a gateway drug effect going on, what with rust and rust-inspired swift out there
16:21:02 <EvanR> i want to test a theory, hiring random terrible coders off the street to work on PHP or to work on haskell and see what happens
16:21:54 <EvanR> i thought haskell inspired swift
16:22:02 <Tuplanolla> Hey, `LANGUAGE DataKinds, PolyKinds, GADTs`, I didn't want to read the source code of this module anyway.
16:22:09 <davr0s> swift is rust crossed with objective-C
16:22:19 <davr0s> i call it 'objective-rust'
16:22:39 <davr0s> rust is c crossed with haskel
16:22:39 <np356> One way of doing, I thought was starting a .NET Core project in C#, then slowly start mixing F# elements and then maybe haskell
16:22:40 <EvanR> eh... isnt it a dynamically typed language backwards compatible with obj-c
16:22:49 <davr0s> yes
16:22:58 <davr0s> no
16:23:04 <davr0s> it's statically typed.
16:23:20 <EvanR> it has a rust-like type system?
16:23:29 <davr0s> yes, it's got trait bounded generics
16:23:41 <lmapper> I have been reading about PolyKinds and DataKinds lately.  Still not quite sure what they are exactly.
16:23:54 <EvanR> garbage collected?
16:24:05 <davr0s> i dont konw what it calls them, but it copies the same thing where an interface can be used as a generic bound or vtable
16:24:15 <davr0s> it's ref-counted mostly
16:24:21 <EvanR> it sounds more like haskell
16:24:24 <davr0s> they are retrofitting rust-like move-semantics
16:24:40 <EvanR> and it seems like rust has not much to do with haskell
16:24:52 <UserOO7>  what the easiest way on encoding short json objects to be pass via wreq? something simple like: {"Field":"Value"}
16:24:57 <davr0s> haskell inspired rust,  rust inspired swift.
16:25:10 <davr0s> there's a bit of a divergence there of course
16:25:22 <EvanR> i really havent seen too much haskellism in rust
16:25:45 <davr0s> coming from a C++ perspective, i totally get the idea of calling rust a gateway drug to haskell
16:26:01 <EvanR> functional programming vs low level memory constrained imperative programming
16:26:02 <davr0s> rust traits -> haskell typeclasses 
16:26:17 <davr0s> it does a lot of lazy iterator chaining stuff in the standard library
16:26:35 <davr0s> it has tagged-unions
16:26:41 <EvanR> iterators are not very functional
16:26:57 <davr0s> look at the iterator chaining stuff you can do in rust
16:26:57 <systemfault> And Haskell is a gateway to C++ template metaprogramming godhood
16:27:11 <Rembane> How to win life
16:28:15 <davr0s> it doesn't need all the io monad stuff of course, because it's eager eval , it's not pure, but neither is swift
16:29:19 <davr0s> anyway.. .coming from C++, originally haskell was bewildering. It's making much more sense to me now after Rust.
16:30:28 <EvanR> i can imagine, like you lived your whole life with beer goggles on then suddenly took them off :)
16:32:30 <teurastaja> hey im not a good haskell programmer and i try to avoid haskell explanations for this project because i want to avoid all lambdas. im trying to implement the SKI combinators in assembly or in C. its very easy. the only bottleneck is implementing the "apply(f, x)" function the S combinator uses
16:33:02 <teurastaja> searching for examples on the net returns mostly haskell tutorials
16:33:11 <teurastaja> i consider this cheating
16:33:16 <Tuplanolla> I'm reminded of SKIM.
16:33:31 <teurastaja> SKIM? i said SKI
16:33:45 <Tuplanolla> It's a functional hardware architecture.
16:34:01 <teurastaja> made with what? an FPGA?
16:34:37 <Tuplanolla> See for yourself: https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-81.html
16:34:38 <teurastaja> id like to implement it in assembly before implementing it directly on silicon
16:35:19 <EvanR> is programming in SKI kind of like solving towers of hanoi for each step of an operation
16:35:31 <teurastaja> Tuplanolla: can i get more than just the introduction?
16:35:44 <Tuplanolla> Might you click the link, teurastaja?
16:36:09 <teurastaja> Tuplanolla: i clicked, but theres only a small introduction with no further links
16:36:24 <EvanR> teurastaja: eager evaluation or lazy
16:36:43 <teurastaja> EvanR: eager, unless lazy is simpler to implement
16:36:50 <EvanR> probably isnt
16:36:57 <teurastaja> then eager
16:36:58 <Tuplanolla> That's an unfounded assumption, teurastaja.
16:37:18 <teurastaja> im more comfortable with eager evaluation
16:37:48 <EvanR> seems pretty simple
16:37:55 <EvanR> the S operation does this
16:38:58 <EvanR> erm, apply does this
16:39:01 <teurastaja> EvanR: the S does it, but how do you define 'S'?
16:39:09 <teurastaja> apply
16:39:15 <teurastaja> im trying to define apply
16:39:40 <teurastaja> SKI was easy using only the stack, but im stuck on apply
16:40:26 <Eduard_Munteanu> I?
16:40:30 <EvanR> so youre trying to apply something to 3 arguments right
16:40:36 <teurastaja> I=SKK
16:40:57 <teurastaja> just S and K if possible, else I is ok to implement
16:41:20 <teurastaja> the hardest one is S's apply
16:42:05 <teurastaja> i could also implement only IOTA but i need to define it first...
16:42:07 <EvanR> solution, implement a compiler for lambda calculus, and feed in the code for S K and I :)
16:42:37 <teurastaja> EvanR: im trying to implement lambda calculus FROM SKI combinators
16:43:24 <EvanR> riddle me this, what is the type of your apply function
16:43:29 <EvanR> what does it return
16:44:34 <teurastaja> EvanR: apply isnt totally defined yet. i dont know how to implement it but im thinking there are 3 cases: S, K, and ()
16:44:46 <Tuplanolla> I'm just wondering how long it's going to take for you to find the link on the page.
16:45:41 <EvanR> i have a feeling your basic data structure is simply data Expr = S | K | Apply Expr Expr
16:46:11 <EvanR> in which case apply (S x y z) = Apply (Apply x z) (Apply y z)
16:47:10 <EvanR> rather reduce (Apply (Apply (Apply S x) y ) z) = that
16:47:54 <EvanR> in C, Expr is a struct with one tag slot and two data slots
16:48:19 <EvanR> reduce by allocating a new struct and fill in the slots, return
16:48:47 <EvanR> and analyzing the structure of the args to figure out what to do
16:51:17 <teurastaja> do all SKI expressions reduce to the identity function eventually unless it never halts?
16:51:25 <EvanR> no
16:51:38 <EvanR> example, S
16:51:57 <EvanR> K S S
16:53:00 <EvanR> K K S
16:53:05 <teurastaja> but (S x y) is (S K(T[x]) K(T[y])) right?
16:53:23 <teurastaja> no wait
16:53:27 <teurastaja> this is identity
16:53:28 <EvanR> according to my notes, S x y doesnt reduce to anything else
16:54:00 <nshepperd> wouldn't it be rather useless as a computing language if every expression would reduce to the same thing
16:54:09 <teurastaja> ...so how should i implement apply?
16:54:16 <EvanR> nshepperd: it would allow very efficient implementations though
16:54:33 <EvanR> teurastaja: apply is an expression, do you mean implement reduce?
16:54:58 <EvanR> not all applies reduce
16:55:51 <\u> How to force rebuild a package after executing `stack build`? neither `stack clean` nor `stack build --force-dirty` triggers rebuilding
16:57:13 <bollu> stack clean --full?
16:57:57 <bollu> EvanR do you know a good reference as to why S K I "span" simply typed lambda calculus?
17:01:49 <teurastaja> EvanR: yes, reduce
17:02:15 <EvanR> ill give you haskell code
17:02:37 <EvanR> bollu: does it? SKI seems pretty untyped
17:02:50 <mniip> bollu, you can turn any lambda into SK
17:02:58 <bollu> mniip yes, I know the fact
17:03:03 <bollu> mniip I was looking for slick proof
17:03:12 <mniip> By induction
17:03:16 <bollu> mniip I've seen an algorithm once, but I couldn't really get the intuition
17:03:19 <bollu> oh, interesting
17:03:21 <bollu> induction on?
17:03:32 <EvanR> teurastaja: https://gist.github.com/evanrinehart/78a9170fba48521e3fe1c470a2e913da
17:03:34 <mniip> Terms
17:04:31 <EvanR> it eventually made it to lpaste http://lpaste.net/356453
17:05:18 <mniip> Any term is either (\x -> free of x), (\x ->  f g) or (\x -> x)
17:05:24 <bollu> right
17:05:48 <mniip> K, S, I, respectively
17:05:56 <bollu> mniip hm, but, consider
17:05:59 <bollu> \x -> y
17:06:00 <EvanR> bollu were you asking the other way around, how to compile any lambda into SK
17:06:01 <bollu> then what?
17:06:04 <mniip> K y
17:06:10 <bollu> but that's incorrect?
17:06:12 <bollu> oh wait
17:06:20 <bollu> no, it's incorrect
17:06:23 <mniip> Your expression has free variables
17:06:32 <bollu> right, so?
17:06:32 <mniip> Mine has as many
17:06:36 <bollu> but K y != y
17:06:42 <bollu> it's not a faithful translation, no?
17:06:52 <mniip> K y = \x. y
17:07:09 <bollu> ah
17:07:10 <bollu> ah
17:07:12 <bollu> OK
17:07:30 <bollu> ahh, thanks :)
17:07:32 <bollu> much appreciated
17:07:44 <bollu> that makes so much sense!
17:09:34 <bollu> mniip can you suggest a book for lambda calculus theory?
17:10:22 <EvanR> oops, fixed
17:10:56 <mniip> Uh
17:11:08 <mniip> No, I didn't read any
17:11:40 <EvanR> a lot of stuff written on LC on the web seems to have no source really
17:12:03 <EvanR> we did track the *source* down though the other day, to 2 papers by church and 1 by turing
17:12:09 <mniip> Just like arithmetics, it's obvious
17:12:43 <EvanR> yeah well that early LC paper was far from obvious looking, not like the current simplified form
17:12:59 <EvanR> heh, do you think ancient civilizations had something like LC
17:13:11 <EvanR> it was so obvious they never even recorded it
17:13:23 <mniip> Yes
17:13:39 <mniip> Well, the cult of the bound variable
17:14:02 <mniip> And the universal machine!
17:14:59 <ertes> i guess a lot of non-obvious information about LC is more about proving and foundational mathematics than about computing
17:16:18 <ertes> which reminds me…  i'm still looking for a replacement for agda =)
17:16:56 <EvanR> why
17:17:15 <ertes> it would be really nice, if i could use it as a proof assistant in some of my crypto-related workshops…  HOL light seemed nice, because it has all the modular arithmetic stuff predefined, but it's super-awkward to use
17:17:42 <ertes> EvanR: because agda is too expensive to use
17:17:51 <ertes> especially for equational reasoning
17:18:00 <ertes> also i hate being explicit about universes
17:21:50 <iqubic> Anyone have a good guid on LC?
17:25:36 <iqubic> s/guid/guide/
17:33:48 <EvanR> http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf
17:36:36 <davr0s> so the  [ ...] syntax is overloaded for data constructors,   but is the [T] type always 'a linked list' ... could the [T] itself be overloaded to be some user-chosen default sequence
17:39:11 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-lists
17:44:20 <ertes> davr0s: i would stay away from the "linked list" interpretation, because it is only ever true, if a list actually manifests itself as a real memory object…  the reason i would stay away is that linked lists are about the worst possible data structure in most cases, so you could be mislead into thinking that haskell lists are bad in general
17:46:39 <davr0s> i suppose laziness means sometimes it will just be a point where a producer connects to a consumer
17:47:37 <davr0s> but would it be possible to over-ride what it gets represented as 'when it actually manifess itself as a real memory object'
17:47:38 <ertes> yeah
17:47:45 <ertes> no
17:48:15 <ertes> you can control it to some extent, but a cons-list, if it's ever evaluated, will always be a linked list
17:48:23 <EvanR> you can use the FFI to create your own data type guts
17:48:48 <davr0s> that sounds interesting,
17:48:57 <ertes> due to the way GHC handles memory, it will probably be more efficient than a linked list in C/C++, but it still has the problem of indirection and potential memory non-locality
17:49:13 <davr0s> i get the impression laziness would mean a lot of tha
17:49:31 <davr0s> building chains of linked stuff waiting to be queried
17:49:43 <EvanR> laziness has a cost, but a lot of laziness is unecessary and just not done thanks to optimization
17:50:24 <EvanR> building large chains isnt always necessary
17:51:20 <EvanR> actually chains is probably a bad intuition
17:51:37 <davr0s> chains .. ok graphs
17:51:41 <davr0s> dependancy graphs
17:52:14 <EvanR> you might be thinking a big graph is set up first then reduced
17:52:25 <EvanR> which is, entirely defeating the point of lazy evaluation
17:52:44 <davr0s> well, i've seen people build lazy eval systems manually
17:53:25 <davr0s> heh
17:53:32 <EvanR> ideally you are using only as much memory as you need for the algorithm, which in amny cases is a fixed amount
17:53:48 <EvanR> but it takes practice to know thats what you did, or need
17:54:22 <davr0s> are there any  tools for visualizing how the haskell engine behaves
17:54:31 <ertes> laziness is more about creating such memory-efficient algorithms in a composable way
17:54:32 <EvanR> yes!
17:55:01 <ertes> the way you have to do it in strictly strict languages is non-composable
17:55:09 <EvanR> http://felsin9.de/nnis/ghc-vis/
17:55:20 <davr0s> i suppose these days the kind of code i used tp have to optmize is done on gpus..
17:58:07 <ertes> davr0s: you might be interested in the 'accelerate' package
18:00:30 <davr0s> i would also like to know if a subset of haskell could be run without GC (move-semantics,borrowed refs), but i'm told immutability cann be exploited by the GC strategy
18:01:12 <EvanR> the gc is really good with short lived garbage
18:02:00 <davr0s> there were games that used a lisp variant with some sort of special seperation between per-frame temporaries and persistent data
18:02:06 <ertes> davr0s: even unlambda needs GC
18:03:09 <davr0s> http://www.pipeline.com/~hbaker1/LinearLisp.html
18:03:13 <EvanR> theres the cool looking feature now in GHC called compact regions. if you have a bunch of static data that you know youll need for a while (like a whole game level), you can put it in a compact region
18:03:26 <ertes> davr0s: but keep in mind that GHC will rewrite most of dynamic GC to static memory management, basically what you would have written by hand, as long as the lifetime of an object can be statically determined
18:03:38 <EvanR> this lets you use it like a normal value, but the whole thing will be treated by the gc as one unit
18:03:44 <davr0s> that sounds similar EvanR to the strategies ive heard of being used for lisp in games the few times it was used.
18:03:49 <EvanR> you can also serialize and deserialize it!
18:04:49 <EvanR> you can also control the gc in various ways
18:16:24 <juri_> so, all my hspec tests are broken.
18:18:08 <juri_> or rather, all of them do not type check, except for the first one in each function.
18:29:26 <Shockk> does anyone know if there's a supported way to install stack in the cygwin environment on windows?
18:30:54 <Shockk> using the windows version of stack isn't suitable as it's unable to see some directories
18:30:57 <Shockk> Warning: 'extra-lib-dirs: /home/shockk/usr/llvm/lib' directory does not exist.
18:31:06 <Shockk> but this directory most certainly exists
18:51:48 <sophiag> anyone here experienced with singletons? apparently they should be able to promote higher-kinded types now, but i'm trying it with a hand-rolled HList and still get the "Cannot promote an applied type variable" error
18:55:34 <davr0s> in destructuring, can one ignore the 'rest' of a record or tuple  
18:55:48 <EvanR> a record, yes
18:57:44 * EvanR fumbles with a stack of papers looking for the answer
19:00:11 <EvanR> foo MyRecord{myField=x} = ...
19:00:44 <davr0s> ok that works, thanks
19:01:55 <EvanR> if its something like foo MyRecord{name=name} = ... then that can be reduced to foo MyRecord{name} = ... with NamedFieldPuns
19:02:07 <davr0s> again, 'gateway drug' .. i found myself gradually trying to use 'tuple-structs' in rust a bitmore, 
19:02:24 <davr0s> but there they have the '.0 .1 .2 ...' accessors aswell
19:03:09 <davr0s> .. which work on tuple-structs of any length  .. last time i tried, you can't make a general purpose 'nth' accessor in haskell?
19:03:24 <EvanR> you can, with type classes
19:03:52 <EvanR> lens has something like that i think
19:04:09 <EvanR> but triples and quadruples etc are really uncommon in haskell
19:04:22 <EvanR> instead you see V3, V4, etc or records
19:05:43 <EvanR> many classes arent even implemented past 7 tuples at all
19:06:55 <ertes> davr0s: the problem with having something like ".1" is that it's surprisingly difficult to figure out its type
19:06:56 <EvanR> though with dependent types you can put a proper type on operations like "nth" thing in a tuple-of-size m
19:07:10 <ertes> davr0s: lens uses an ad-hoc type class to do it
19:07:12 <ertes> :t _1
19:07:14 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
19:07:32 <EvanR> which will let you use actual numbers to do the indexing and wont fail on somthing too short
19:07:37 <ertes> in this case the Field1 class
19:07:48 <ertes> > (10, 20, 30) ^. _2
19:07:50 <lambdabot>  20
19:07:52 <ertes> > (10, 20, 30, 40) ^. _2
19:07:54 <lambdabot>  20
19:08:15 <ertes> but you can't make the tuples arbitrarily long…  at some point you will run out of Field1 instances
19:08:20 <EvanR> > (10, 20) ^. _3
19:08:22 <lambdabot>  error:
19:08:23 <lambdabot>      • Could not deduce (Field3 (t1, t0) (t1, t0) b b)
19:08:23 <lambdabot>        from the context: (Field3 (t, t2) (t, t2) b b, Num t2, Num t)
19:09:05 <davr0s> I wondered if 'i still have a need for 'structs'' i'm still 'doing it wrong'..
19:09:21 <davr0s> e.g. working in a haskelly way you just wont run into the naming-clash issue
19:09:21 <ertes> as EvanR noted to generalise this to arbitrary tuples means to do it inductively, which in turn means that you need some form of type-level computation
19:10:02 <ertes> that's possible in haskell, but not with the built-in tuple types
19:10:31 <EvanR> davr0s: is every field the same type
19:11:25 <davr0s> EvanR sometimes... sometimes not
19:11:59 <EvanR> do we even have a well defined problem? :)
19:12:49 <ertes> i think so: "how do i do rust tuples in haskell?" =)
19:13:16 <EvanR> going with what i know, is this the same question as how do i do python tuples in haskell
19:13:52 <ertes> i don't think so…  python tuples are pretty much just heterogenous lists…  the only difference to python lists is that they are immutable, which lists are not
19:14:05 <EvanR> so whats the difference?
19:14:12 <EvanR> between that and rust
19:14:28 <ertes> aren't 3-tuples and 4-tuples of different type in rust?
19:14:28 <EvanR> implementation backend aside
19:15:36 <colonelj> in the language I'm making there isn't even any distinction between tuples and lists
19:15:59 <EvanR> well, i hope you choose only 1 name then :)
19:16:14 <colonelj> I just call them stack objects
19:16:20 <colonelj> it's a stack based language
19:16:40 <EvanR> do you keep all your stacks in a stack
19:16:44 <colonelj> of course
19:16:47 <EvanR> haha
19:17:07 <ertes> colonelj: so your language is non-static?
19:17:27 <davr0s> ok i can see now that with -XDisambiguateRecordFields  it lets me use 'name' in multiple records, and instance a 'HasName where nameOf..' extractor
19:17:36 <colonelj> ertes: it's optionally static
19:17:46 <colonelj> the type system is able to represent lists and tuples differently
19:17:54 <colonelj> e.g. as {int*} vs {int, double}
19:17:58 <EvanR> davr0s: wait, you can do that without an extension
19:18:13 <davr0s> i think it needs manually disambiguated names for that 
19:18:17 <davr0s> before the extention
19:18:39 <colonelj> some sample code: http://lpaste.net/356323
19:19:09 <EvanR> no
19:19:21 <EvanR> davr0s: with that extension you would use name directly, no class
19:19:36 <EvanR> the class way is how lens does it, without an extension
19:20:51 <davr0s> what i've got is    ghc main.hs -XDuplicateRecordFields -XDisambiguateRecordFields -XFlexibleInstances -XMultiParamTypeClasses -XUndecidableInstances -XTypeFamilies -XFunctionalDependencies -XUnicodeSyntax    .... it still seems to tell me 'ambiguous blah blah' unless i actually use the class.. but within the class instance, i can desructure and grab by the field name (within the destructure braces preceeded by the type
19:20:51 <davr0s>  name)
19:21:23 <EvanR> just saying, you dont need the extension with the class
19:21:48 <EvanR> its not doing anything that way
19:22:11 <EvanR> *with* the extension, i still am not sure if it will always work
19:22:43 <EvanR> also most of those extensions arent relevant to this topic
19:23:17 <davr0s> just showing what i'm compiling with for reference
19:27:59 <davr0s> https://gist.github.com/dobkeratops/2ddc3f1a6e8099668786ce32e674c922  ... this is what it lets me do, is there some template-haskell magic that can roll the commonly named accesor perhaps
19:28:20 <davr0s> i might be ok with a restriction 'all similarly named fields must have the same type'
19:28:34 <EvanR> lens includes TH that does it
19:31:56 <ADG> I have `data Node = Node { value :: Integer, parent :: (Maybe Node) }`. I want to get values of this node and its ancestors
19:32:29 <ADG> something like iterate parent until Nothing, but that would also require extracting from Maybe repeatedly
19:32:39 <davr0s> import Control.Lens ...   import Lens ..   doesn't find it .. i guess it's some package you need to install 
19:32:41 <ADG> I also saw unfolr
19:32:54 <EvanR> thats a simple recursion
19:33:09 <EvanR> f (Node i Nothing) = []
19:33:18 <EvanR> er
19:33:22 <EvanR> f (Node i Nothing) = [i]
19:33:23 <andromeda-galaxy> davr0s: I believe EvanR is talking about makeClassy or similar from Control.Lens.TH
19:33:29 <EvanR> f (Node i (Just p)) = i : f p
19:33:41 <andromeda-galaxy> f (Node i (Just p)) = i:f p
19:34:10 <andromeda-galaxy> (sorry EvanR - didn't mean to duplicate you there)
19:34:22 <EvanR> wondertwin powers activate!
19:34:50 <andromeda-galaxy> let's teach ADG about recursion-schemes now
19:35:19 <ADG> Ah.. that is good.
19:35:19 * duckqlz takes form of a duck
19:36:57 <davr0s> i'll need to find the package it seems. (cabal..)
19:37:16 <ertes> ADG: Node ≃ [Integer]
19:37:39 <ADG> ?
19:37:53 <andromeda-galaxy> ADG: ertes says: your node type is isomorphic to lists of ints
19:38:06 <andromeda-galaxy> do you know the term isomorphic?
19:38:13 <EvanR> no its not
19:38:16 <ADG> Oh kind of, I also store depth, I am doing BFS-kind-of-thing
19:38:20 <EvanR> since theres no way to get []
19:38:26 <ertes> oh, yeah
19:38:33 <ertes> ADG: Node ≃ (Integer, [Integer])
19:38:38 <andromeda-galaxy> ah yeah, good point
19:39:06 <EvanR> [Z]_1
19:39:07 <ertes> or alternatively:  Node ≃ NonEmpty Integer
19:39:08 <geekosaur> davr0s, the package is 'lens'
19:39:10 <MarcelineVQ> home come no one reaches for NonEmptyList :>
19:39:13 <ertes> from Data.List.NonEmpty
19:39:16 <ADG> I tried that previously but my system crashed from execcisve RAM usage, so I am not storing all ancestor values and generating them
19:39:20 <davr0s> ok cabal is churning away now
19:39:51 <EvanR> you may have done something wrong if you are using so much RAM
19:39:57 <ertes> ADG: that is related to your algorithm, not to the type, because the types are isomorphic
19:40:10 <ADG> hmm
19:40:21 <ertes> ADG: in other words: if you ran into that problem with (Integer, [Integer]), you will also run into it with Node
19:40:26 <davr0s> lol , i think this is overkill just for named fields
19:40:42 <EvanR> davr0s: probably... 
19:40:53 <EvanR> note you dont need any of these extensions to use named fields
19:40:58 <ADG> erets I wrote an equivalent version in Java and that works
19:41:08 <andromeda-galaxy> davr0s: in theory, you could adapt the TH from lens to just generate simpler classes... Or you could write the classes by hand
19:41:12 <ertes> ADG: then it was not equivalent =)
19:41:26 <ertes> ADG: strictness matters
19:41:31 <andromeda-galaxy> ADG: is it possible that you are getting a memory leak due to lazyness?
19:41:37 <ADG> see https://github.com/adityagupta1089/Project-Euler/blob/master/src/problems/P122.java
19:41:44 <davr0s> andromeda-galaxy sure it might be useful to figure out enough TH to roll the accessors.
19:42:52 <ertes> ADG: if you paste your haskell variant (the one that crashed), we might be able to help you
19:44:06 <andromeda-galaxy> davr0s: so looking at the way that the lens TH works, we can probably write some TH to make classes for each record name that you care about pretty easily, at least as long as you don't mind supplementing every record with some kind of $(makeAccessorClassInstances ''MyType) or some such
19:44:14 <ADG> This is only for 15, I need to sum bfs values for 1 to 200 : https://hastebin.com/vowejudiyi.sql
19:44:41 <davr0s> andromeda-galaxy that is perfectly acceptible
19:45:30 <EvanR> ... have you figured out how to use DuplicateRecordFields and DisambiguateRecordFields yet?
19:45:36 <EvanR> because it sounds like you didnt
19:46:06 <andromeda-galaxy> davr0s: relatedly: what ghc version?
19:46:27 <davr0s> 8.0.2 
19:46:42 <andromeda-galaxy> okay, cool
19:47:08 <ertes> ADG: could you link to the raw version?  hastebin needs JS
19:47:43 <ADG> lpaste?
19:47:51 <ertes> or that
19:48:50 <ADG> http://lpaste.net/356458
19:49:48 <andromeda-galaxy> davr0s: just to confirm that I'm interpreting scrollback correctly, you would like to have (somewhat) dynamic dispatch here right? In particular, you do want to be able to write something like` foo :: (HasName t String) => t ->...` that uses some `name :: HasName t a -> t -> a`?
19:49:59 <andromeda-galaxy> neither DisambiguateRecordFields nor DuplicateRecordFields will let you do that
19:50:13 <andromeda-galaxy> OverloadedRecordFields in the future will, together with OverloadedLabels
19:50:25 <EvanR> davr0s is trying to use the same name with different records without qualifying
19:50:35 <EvanR> not nec with a class
19:51:21 <EvanR> to access fields
19:51:22 <andromeda-galaxy> hmm.., my question was more: does davr0s want to do this only in contexts where the type is definitely known statically?
19:51:42 <EvanR> i assumed yes, but dunno
19:52:05 <davr0s> andromeda-galaxy  statically known type at least yes
19:52:30 <davr0s> i can see that with a 'class' , i could write generic code that would work on 'any type that has 'name' ..' , i can see that would be useful
19:52:41 <EvanR> i suspect HasName thing is premature generalization
19:52:55 <EvanR> like using Floating everywhere instead of Double
19:53:15 <andromeda-galaxy> that may be, sorry davr0s, I got distracted by all the shiny new work on OverloadedRecordFields or whatever we are calling the thing that makes HasLabel instances
19:53:48 <EvanR> otherwise, you might want a proper record type system, to write very precise types about how you will use "records" (not specific types that happen to be products)
19:54:05 <EvanR> not sure which language has this
19:54:39 <EvanR> keywords "row polymorphism"
19:54:45 <andromeda-galaxy> Haskell gets reasonably close with some of the first-class dependently-typed-records libraries
19:54:59 <EvanR> yeah vinyl looks cool
19:55:01 <davr0s> well just to compare , in c++ if you have a templated type, you can write generic code that will work on any type that just happens to have those fields;   I can see that in haskell you would control that a bit better by using a class to say 'HasName' or whatever
19:55:23 <EvanR> i think HasName is kind of an abuse of typeclasses
19:55:27 <andromeda-galaxy> HasLabel instances (8.2 or 8.4, I forget) should put native records within shouting distance of proper row polymorphism
19:55:35 <EvanR> its a clumsy way to accomplish the task
19:56:20 <davr0s> i'm sure that the absence of unique field names isn't a problem for people who are used to 'thinking in haskell'
19:56:44 <andromeda-galaxy> EvanR: what would you consider not a clumsy way?
19:56:55 <EvanR> theres a handful of situations whre different ways of handling this seem better
19:56:57 <davr0s> i'm always going to have a chunk of c++/c conditioned brain.. even back in assembly language, I could have objects with shared field labels :)
19:57:08 <EvanR> but without experience of those ways, well, everything might look like a typeclass :)
19:57:26 <andromeda-galaxy> in particular, the ability to have 3rd party libraries use fun overloaded labels stuff has so far been super fun
19:57:42 <EvanR> davr0s: right, you really want a *record type* system, which we dont have. but the library vinyl is faking it with type level shenanigans
19:58:04 <davr0s> i would put the same named fields at the same offsets in memory back when writing 68000 assembly .. 'these objects are compatible up until this point' (-> single inheritance in C++ made sense because it mapped onto something easy to do in asm)
19:58:17 <EvanR> if you have a bunch of records in your program that need to mix and match fields, then something like vinyl might work
19:58:23 <andromeda-galaxy> EvanR: I don't super much see the difference between "having" a record type system and writing one using DTs, which is basically the Vinyl approach
19:58:28 <EvanR> another keyword is extensible records
19:58:28 <andromeda-galaxy> yeah, vinyl is a fun library
19:58:46 <EvanR> andromeda-galaxy: the only different is convenience, setup cost, syntax
19:59:02 <davr0s> anyway, another asside i seem to have broken my program. i have a really weird compile error. i must rollback and see what i did
19:59:25 <andromeda-galaxy> if we get to full DT, syntax should be way better, and just throwing this stuff into prelude would improve setup cost + convenience
19:59:42 <EvanR> i hope youre right
20:00:08 <EvanR> andromeda-galaxy: heres what some guy did with dependent types and syntax extensions https://github.com/jmars/Records
20:00:11 <EvanR> in idris
20:00:59 <EvanR> the types are automatically found out through proof search
20:01:48 <andromeda-galaxy> that's an interesting approach
20:01:52 <EvanR> from what it looks like, dependent haskell is going to be a wild ride, quite different from these existing systems
20:02:01 <andromeda-galaxy> thanks for pointing me at that, I was actually just writing some Idris this morning
20:02:04 <andromeda-galaxy> indeed!
20:02:04 <EvanR> in a good way (?)
20:02:09 <andromeda-galaxy> (hopefully)
20:02:34 <andromeda-galaxy> I'd also love to see some way of integrating the existing Liquid work with the DT work
20:04:21 <andromeda-galaxy> davr0s: btw sorry for forgetting to respond to you during this tangent... 
20:04:36 <davr0s> ok i got my code compiling again.. where was i..
20:05:08 <andromeda-galaxy> davr0s: DuplicateRecordFields unfortunately doesn't really solve your statically known problem, because ghc for some reason refuses to do type inference to disambiguate
20:05:15 <davr0s> firstly testing if  -XDuplicateRecordFields -XDisambiguateRecordFields    actually work
20:05:42 <andromeda-galaxy> so my understanding is that DisambiguateRecordFields is mostly important in constructing/pattern matching. DuplicateRecordFields will also work in these cases
20:06:09 <andromeda-galaxy> but if you use the selector function without explicitly annotating the type of the thing that you are selecting on, ghc refuses to infer the type of the argument before resolving the selector function, so you get ambiguity problems
20:06:22 <davr0s> ok i have that working, i used those in the 'HasName' instances
20:06:35 <davr0s> andromeda-galaxy right thats my understanding at this point
20:07:08 <davr0s> what I could do is: just go ahead and code, and when I come up against a common name, roll one of these accessor classes/instances
20:09:00 <davr0s> something i kind of wish you could do sometimes is 'get the field of a specific type, if all the fields are of different type' .. even in C or C++, i.e. the name of the type should be enough
20:09:01 <EvanR> are you expecting to have multiple records with the same fields?
20:09:13 <EvanR> or is this just hypothetical
20:09:27 <davr0s> multiple records which may have different permutations of the same fields:   this is a situation I take for granted
20:09:40 <EvanR> huh
20:10:40 <davr0s> e.g. years ago the last time I tried haskell, as an excercise I tried to write a loader for a skeleton mesh file format, following docs and producing a datastructure. In C++, you'd end up with that looking as described in the docs. In haskell you had to start using prefixed field names... which looks really primitive and clunky (in stark contrast to the rest of the language's elegance)
20:11:20 <EvanR> yeah because haskell doesnt really have records
20:11:21 <davr0s> bear in mind whilst one might have an idealised way of doing something, often one is dealing with data from elsewhere
20:11:37 <EvanR> but vinyl!
20:11:45 <davr0s> i remember once asking "could we have a scene file format based on JSON"
20:12:00 <davr0s> other people replied "JSON is not suitable for representing scenes"
20:12:00 <EvanR> (also, fields name = fields type seems like itll be less useful more often than not)
20:12:15 <davr0s> of course that is a stupid reply
20:12:24 <davr0s> of course you can represent a scene in JSON
20:12:34 <EvanR> sure
20:12:46 <iqubic> Anyone have Lambda Calulus tutorial I can read?
20:12:49 <davr0s> but the way the 3d packages spit their stuff out... they have a way of naming things that just doesn't map so naturally into it
20:12:56 <EvanR> iqubic: i linked one to you a while back...
20:13:33 <andromeda-galaxy> davr0s: so there are a few things that you could do. Basically, at least until ghc 8.2, you do have to go the fully dynamic and typeclass based approach
20:14:06 <andromeda-galaxy> you could write these classes ad-hoc, the way that you have been doing
20:14:07 <iqubic> This? http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf
20:14:19 <davr0s> yes, certainly from what I've seen over the past couple of days - the situation is better than what I knew of  x years ago
20:14:23 <andromeda-galaxy> you could write some TH that would make those instances automatically, which is what I was suggestiong
20:14:25 <EvanR> davr0s: you might also take inspiration from json and not use a record at all, but a type like data Scene = Leaf Matrix | Branches (HashMap String Scene)
20:14:46 <EvanR> which will give more flexibility at the cost of static checking
20:15:04 <andromeda-galaxy> you could use a real extensible records library like vinyl
20:15:37 <davr0s> it's certainly a possibility, one could consder it as an intermediary before turning it into something even more suited to Data-Oriented-Design.
20:15:39 <andromeda-galaxy> there might be something fancy that you could do between GHC.Generics and OverloadedLabels, also, but I'm not sure on that
20:16:20 <davr0s> as you seem to have alluded to there - just make the scene nodes have static fields for the thigns you know *everything* has, and just have a dynamic list for everyhting else.
20:16:31 <EvanR> or data Scene a = Leaf a | Branches (HashMap String (Scene a))
20:16:35 <EvanR> now its a functor
20:16:46 <andromeda-galaxy> Hmm, I'd have to argue against using Strings for the hashmap keys here 
20:16:59 <andromeda-galaxy> extensible records libraries are the real way to go here, use HList or vinyl!
20:17:04 <EvanR> its convenient
20:17:22 <andromeda-galaxy> (or, if you do insist on using a HashMap, at least use some ADT instead of random String-s!)
20:17:25 <EvanR> i would like to see what you come up with, practically speaking, using vinyl for this
20:17:33 <davr0s> it could be data ExtendedFields |  Light ...  |Name ...| BlendWeights...|
20:17:48 <davr0s> data SceneNode = .... [ExtendedFields]
20:17:50 <EvanR> yeah if the keys are from a known list
20:17:59 <davr0s> they would be
20:18:02 <andromeda-galaxy> yes, that might be a reasonable compromise
20:18:16 <davr0s> the program has to know about the field types to do anything with them, so thats ok
20:18:18 <andromeda-galaxy> EvanR: presumably the keys are known, since before the HashMap idea came up, we were talking about a fully static approach?
20:18:34 <EvanR> good point
20:19:02 <EvanR> as soon as i heard "3d scene graph file" i figured all structure went out the window :)
20:19:31 <davr0s> i'm not going to be rolling some sort of plugin node system.. one can get the source and add the variants needed
20:20:06 <davr0s> again this might sound really dumb but
20:20:21 <davr0s> after using rust i'm much more inclined to actually use tagged unions
20:20:33 <davr0s> having had them in an environment with familiar syntax
20:20:59 <EvanR> its pretty painful to see them missing from so many languages, or existing only for the purposes of a Maybe sort of thing
20:21:13 <AnthonyWeis> hi, is the "just" instance for "mfix" actually of any use ? (besides monad transformers )
20:21:33 <davr0s> again i did things like tagged unions in raw assembly, that was the first way i ever did anything polymorphic
20:21:51 <davr0s> so in many ways this is C++ poison that they're not an instinctive part of my repetoir today
20:22:35 <andromeda-galaxy> yeah, sounds about right from my experience, too
20:22:54 <EvanR> C++ java scala ruby decided that instead of case on a tagged union, youre supposed to split up cases of every case and cast them into separate class files in the 7 corners of your project
20:23:03 <c_wraith> AnthonyWeis: you mean the Maybe instance?
20:23:31 <AnthonyWeis> c_wraith: ups , yes ^^
20:23:54 <EvanR> and it feels horribly wrong
20:24:06 <davr0s> "sort by type" or "sort by function"  ... the correct answer is to have both available and choose which is best per situation
20:24:11 <c_wraith> AnthonyWeis: it's got some use, it looks like.
20:24:23 <davr0s> rather than have someone dogmatically declare the whole world has to work one way or the other :)
20:24:40 <c_wraith> > mfix $ Just . (1:) -- AnthonyWeis: it's clearly productive in the right circumstances
20:24:40 <andromeda-galaxy> yep :)
20:24:42 <lambdabot>  Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:24:49 <EvanR> the result is i still have trouble explaining how sum types work to people :(
20:25:15 <andromeda-galaxy> a bunch of the annoyingly verbose OOP patterns are basically just trivial constructs on ADTs that have been forced into this strange idea that sum types should be sibling classes
20:25:21 <andromeda-galaxy> with an abstract class for every adt
20:27:15 <davr0s> i can certainly see why vtables are useful for software that can accept plugins
20:27:27 <davr0s> there might have been commercial motivation for this
20:27:35 <EvanR> a record of functions is essentially a vtable!
20:28:02 <AnthonyWeis> c_wraith: hm ok. Guess I have to have another look at it then... Thank you very much :)
20:28:14 <c_wraith> AnthonyWeis: But I don't see offhand what it can do that's more useful than fmap . fix...  It can't inspect its argument
20:29:04 <c_wraith> AnthonyWeis: err.  Well.  Just . fix, I guess
20:29:40 <AnthonyWeis> yes that was exactly what was bothering me
20:30:03 <c_wraith> AnthonyWeis: let me try a couple more things
20:30:14 <AnthonyWeis> c_wraith: ok. 
20:30:21 <lyxia> > mfix (const Nothing)
20:30:24 <lambdabot>  Nothing
20:30:34 <EvanR> if you load a plugin that gives a new value of a record type, satisfying whatever interface you defined, youre essentially doing OOP
20:31:56 <EvanR> which shows that FP and OOP are not orthogonal at all
20:32:15 <EvanR> or mutually exclusive
20:33:33 <lfairy> > Map.fromList [(1, "foo"), (1, "bar")]
20:33:35 <lambdabot>  error:
20:33:36 <lambdabot>      Not in scope: ‘Map.fromList’
20:33:36 <lambdabot>      Perhaps you meant one of these:
20:33:46 <lfairy> > Data.Map.fromList [(1, "foo"), (1, "bar")]
20:33:48 <lambdabot>  fromList [(1,"bar")]
20:34:42 <lfairy> > Data.Map.union (Data.Map.fromList [(1, "foo")]) (Data.Map.fromList [(1, "bar")])
20:34:44 <lambdabot>  fromList [(1,"foo")]
20:34:49 <lfairy> why...
20:36:56 <EvanR> union is left biased
20:37:05 <EvanR> fromList inserts items one after the other
20:37:38 <EvanR> in list order
20:38:53 <lfairy> I guess that makes sense? still unintuitive though
20:39:14 <EvanR> what would make more sense, right biased union?
20:40:48 <lfairy> I'd be happy with either way as long as it's consistent
20:41:02 <lfairy> with Map.fromList xs == Map.union (map (uncurry Map.singleton) xs)
20:42:33 <EvanR> unions
20:43:17 <EvanR> well if you want left biased unions to be consistent with that, fromList will have to do some crazy shit
20:45:04 <c_wraith> AnthonyWeis: yeah, I'm not seeing anything especially useful with it other than it forms a uniform interface with other cases where it is more useful
20:46:46 <lfairy> EvanR: if that's the case, then how is unions efficient? (if it is)
20:47:04 <lfairy> ftr, hackage had a bug around encodings because it mistakenly assumed that union is right-biased
20:47:24 <lfairy> so that's a data point in favor of right bias
20:47:47 <EvanR> unions just repeats union
20:48:23 <EvanR> which is... O(m*log(n/m + 1)), m <= n
20:48:27 <AnthonyWeis> c_wraith: by that you mean that the other instances are more useful and the maybe instance is "just there" , right?
20:49:18 <EvanR> so its faster if the first one is smaller
20:49:27 <EvanR> might have something to do with it
20:49:33 <AnthonyWeis> c_wraith: sorry my english is not the best, sadly ....
20:54:31 <lfairy> question about hackagebot! if someone uploads foo-0.1.0.0, then uploads foo-0.1.0.1 an hour later, should the bot announce both?
20:54:46 <EvanR> it used to do that
20:54:51 <geekosaur> an hour later, sure. 5 minutes later, maybe not.
20:55:02 <EvanR> it seems to be batching now
20:58:38 <AnthonyWeis> c_wraith: anyways , thank you very much :)
20:59:19 <lfairy> I was thinking of "don't announce the same package until it drops off the bottom of the rss feed", since that's the easiest to implement
21:01:05 <lfairy> currently the oldest item in the feed dates from just under 2 days ago. I think that's reasonable personally
21:02:24 <lfairy> don't *re-announce, I mean
21:05:41 <iqubic> lfairy: Do you maintain hackage bot?
21:07:14 <lfairy> iqubic: I will! sm passed the baton to me a few months ago
21:07:38 <lfairy> currently working out the rules to balance promptness vs avoiding spam
21:14:02 <iqubic> I see. Sounds great.
21:34:53 <andromeda-galaxy> davr0s, EvanR: you might enjoy http://lpaste.net/5623864296602599424
21:35:11 <andromeda-galaxy> this gives "proper" OverloadedRecordFields support on GHC8 by way of a bunch of typeclass/typefamily hackery
21:37:55 <EvanR> how the heck.. and how is #x valid
21:38:21 <andromeda-galaxy> EvanR: #x is OverloadedLabels
21:38:42 <EvanR> oh
21:38:46 <andromeda-galaxy> #x ==> fromLabel (Proxy :: Proxy "x")
21:39:55 <andromeda-galaxy> the rest of it is reasonably straightforward. We use GHC.Generics to get static metadata about the fields of a type, and then a type family to search for a record field with a given name. With the path from the search, we can easily make a Generics-based class for getting the value out of it, and then make a generic IsLabel instance based on he two of those
21:42:50 <andromeda-galaxy> anyway, I think that this solves davr0s's problem
21:43:08 <andromeda-galaxy> @tell davr0s There is a way to get OverloadedRecordFields without using vinyl on GHC 8.0: http://lpaste.net/5623864296602599424
21:43:08 <lambdabot> Consider it noted.
21:43:09 <EvanR> yes, how much boilerplate per record type though
21:43:13 <andromeda-galaxy> none?
21:43:18 <andromeda-galaxy> look at the example
21:43:24 <EvanR> deriving Generic on each one?
21:43:35 <andromeda-galaxy> okay, yes, I admit I forgot that
21:43:43 <andromeda-galaxy> I just do deriving (Generic) automatically nowdays
21:43:52 <EvanR> yes generic is bad ass
21:44:32 <andromeda-galaxy> I would like {-# LANGUAGE AutoDeriveGeneric #-} or something that just automatically sets up Generic instances for everything
21:44:55 <EvanR> i would also like AutoDeriveShow
21:45:09 <EvanR> which derives Show if its not already implemented as an instance
21:45:23 <andromeda-galaxy> yeah... that would be nic
21:45:35 <EvanR> if its possible
21:45:49 <geekosaur> I don't think it is
21:46:00 <EvanR> i mean dont derive on function types
21:46:05 <andromeda-galaxy> open world would make the "if not already implemented" basically impossible 
21:46:11 <andromeda-galaxy> (can have orphans)
21:46:16 <geekosaur> ^
21:46:40 <geekosaur> but something like 'default deriving (Show, Generic)' or w/e might be nice
21:46:44 <EvanR> theres some way to do it
21:47:12 <EvanR> it would certainly be outside the norm for typeclass and linkage
21:47:16 <andromeda-galaxy> I would be for -XAutoDeriveShow and/or -XAutoDeriveGeneric where you have to write noderive (Show) or whatever to allow a regular instance
21:47:18 <geekosaur> not with the 'if its not already implemented' constraint; it would have to be done at link time
21:47:31 <EvanR> right
21:47:33 <andromeda-galaxy> (assuming you don't want to break haskell semantics)
21:47:49 <EvanR> when linking prefer a real Show instance if you see it
21:48:16 <EvanR> actually, just make a dummy show a part of the language
21:48:17 <geekosaur> (as if linking weren't already a minefield)
21:49:44 <EvanR> or like, "NotShowable" is a feature, and is seldomly used because you consider this secret
21:52:36 <geekosaur> actually I think it might be even worse because dictionaries have to be built at compile time. someone else could define and use a dictionary for an instance that doesn't have one, but can't retroactively make your code pass a dictionary it didn't know existed
21:53:09 <andromeda-galaxy> ooh, good point
21:53:12 <geekosaur> whereas this opens that possibility because the dictionary may have to be constructrd at link time
21:53:27 <EvanR> i take it back, its the wrong way to go about it
21:53:33 <andromeda-galaxy> another reason that an actually working ifcxt isn't possible :-(
21:53:55 <andromeda-galaxy> I think that the cost/benefit tradeoff for "automatically derive Show/Generic on every data definition in this module unless noderive clause is given" would be pretty good though
21:54:12 <EvanR> autoderive Generic makes sense right
21:54:19 <EvanR> since you cant derive it yourself anyway?
21:54:22 <andromeda-galaxy> yeah you can
21:54:25 <EvanR> oh
21:54:38 <andromeda-galaxy> it's just a typeclass like any other
21:54:40 <cocreature> it’s typeable that you can’t implement yourself
21:54:48 <andromeda-galaxy> oh I take that back maybe
21:54:50 <andromeda-galaxy> really?
21:54:53 <geekosaur> yes
21:55:41 <andromeda-galaxy> where is the bit that can't be implemented?
21:55:47 <geekosaur> because the compiler has to derive it for itself and ensure it's unique, otherwise you get some spectacularly nonobvious unsafeCoerce-s out of it
21:56:48 <andromeda-galaxy> aah. So it's not that the class definition obviously can't be written, it's that ghc can't allow that without even more baskets of unsoundness?
21:56:51 <andromeda-galaxy> that makes more sense
21:56:54 <geekosaur> yep
21:57:07 <geekosaur> there's a few now-closed ghc bugs about abusing Typeable that way
21:58:10 <andromeda-galaxy> makes sense...
21:58:43 <andromeda-galaxy> did any of that have to do with the brand-new indexed typeable stuff in 8.2?
21:59:01 <geekosaur> no. go look for when Fingerprint was added to Typeable
21:59:13 <cocreature> I think ghc doesn’t allow you to implement typeable yourself since 7.10 or something like that
21:59:17 <geekosaur> was around 7.8 iirc
21:59:26 <Costar> Hi
21:59:30 <cocreature> close enough :)
22:00:09 <geekosaur> well,I think 7.8 added it and made deriving it a warning, with 7.10 being the hard "no more deriving" cutoff? or maybe that was 7.6 and 7.8 respectively
22:00:37 <andromeda-galaxy> hmm, neat! in that case, why isn't Generic one of those magical typeclasses that you never have to derive /or/ write instances for but the typechecker constructs on demand? (like Typeable itself)?
22:00:50 <geekosaur> I recall being annoyed because there's a place we'd like to be able to use it for safety across serialized data but can't because of old-debian shipping 7.6
22:01:18 <geekosaur> you still have to derive Typeable. you just can't write your own explicit instance
22:01:45 <geekosaur> the compiler derives it for its own use at compile time but only adds it to the generated code for runtime if you deriving (Typeable)
22:01:45 <andromeda-galaxy> oh nvm, sorry. I can't remember which class it was that I was thinking of, I though thtat there was /something/ like that
22:02:05 <andromeda-galaxy> maybe I'm only thinking of IP or one of those nasty classes used in implementing a surface feature
22:02:15 <geekosaur> Coercible, and that's tied to newtypes
22:02:28 <andromeda-galaxy> ahh yes
22:02:31 <geekosaur> (so in effect every newtype automatically derives Coercible)
22:02:31 <cocreature> andromeda-galaxy: generic is just an associated type and conversions from and to that type
22:02:40 <andromeda-galaxy> so why do we not do that for Typeable/Genreic?
22:02:40 <cocreature> there is nothing particularly magic or internal to GHC about it
22:02:52 <andromeda-galaxy> cocreature: yeah, that's why I was surprised that you can't write your own instances
22:03:04 <cocreature> andromeda-galaxy: I’m pretty sure you can write your own instances
22:03:26 <andromeda-galaxy> cocreature: geekosaur says some typeable magic makes that impossible?
22:03:36 <cocreature> andromeda-galaxy: that’s Typeable not Generic
22:03:42 <geekosaur> no, what you cant write explicit instances for is Typeable itself
22:04:12 <geekosaur> any other class you are free to write your own instances
22:04:31 <andromeda-galaxy> oh oops, I must have misunderstood you somehow. When EvanR said that Generic couldn't have user instances written, I said it could and I thought you were contradicting me there...
22:04:34 <geekosaur> well, and probably Coercible
22:04:36 <andromeda-galaxy> now this discussion makes a bit more sense
22:04:51 <geekosaur> (actually I think ghc spells that Coerceable or something)
22:04:53 <EvanR> me too
22:05:25 <andromeda-galaxy> same question about Typeable though, why not make that magic like Coercible?
22:05:42 <geekosaur> overhead mostly
22:05:49 <geekosaur> Coerceable is special, it *reduces* overhead
22:06:15 <cocreature> what would a magic version of Typeable look like?
22:06:21 <geekosaur> (by making it possible to avoid the cases where newtypes inadvertently add overhead, like mapping a newtype over a foldable)
22:06:48 <andromeda-galaxy> how does Typeable increase runtime overhead if you don't use any TypeRep functions?
22:09:31 <geekosaur> I think it's runtime initialization overhead, TypeRep has to refer to a static table to get Fingerprint-s
22:10:08 <geekosaur> it can't just make one up on the fly or you're back to Typeable being unsafeCoerce
22:10:15 <geekosaur> potentially
22:10:27 <andromeda-galaxy> oh okay, that makes more sense
22:10:29 <andromeda-galaxy> right
22:11:21 <andromeda-galaxy> Luckily for users of typeable everywhere, that's not /that/ much overhead, if it only hits once (initialization)
22:12:59 <EvanR> slow initialization is a great way to go from basic unix processes to a "keep it running at all costs" VM demon design
22:13:10 <EvanR> basic unix programs*
22:13:30 <andromeda-galaxy> btw, do you know how good ghc is at compile-time optimizing applications of generic functions? My one qualm about using them (as opposed to the rather more annoying TH) is that they seem like they would add a good bit of runtime overhead
22:14:00 <cocreature> if it can specialize and inline them, the overhead usually goes away
22:14:02 <geekosaur> they often do, yes. that's one reason you might want to derive your own instances, so you can optimize instead of using the general-but-slow defaults
22:14:33 <glguy> the overhead of using Typeable is carrying around the pointer to a TypeRep
22:14:33 <geekosaur> er, not derive, write
22:15:16 <andromeda-galaxy> cocreature: do you know how often that actually works? geekosaur: but you still have the overhead (if things are not inlined and specialized) of recursively convering the data into the rep and then going down that tree, and potentially a bunch of dictionary passing, don't you?
22:15:42 <cocreature> andromeda-galaxy: not really, I think it’s something you’ll have to figure out on a case by case basis
22:15:54 <geekosaur> ^
22:16:27 <geekosaur> and consider that a default generics implementation will do things the slow-but-maximally-compatible way whereas a manually written instance can do things directly
22:16:43 <andromeda-galaxy> cocreature: ah, that makes sense, although it's still too bad
22:17:15 <geekosaur> i.e. you know your type and can use its values directly, whereas a default generic implementation would have to deconstruct your type with generics functions and go through dictionaries to access components of its values
22:17:29 <cocreature> I usually don’t use Generic for the things where I care about performance so it doesn’t matter to me
22:17:42 <andromeda-galaxy> oh really, the derived generics don't do more direct access?
22:17:44 <zomg> Bah, deleted my GADT. Too much of a pain in the ass when I don't know how to deal with it :D
22:17:46 <glguy> ghc can eliminate the generics overhead if you both write something that isn't recursive and doesn't hide parts of the generics representation under uninterpreted functions and you turn up the inning flags enough depending on the size of the data type you're using
22:18:20 <geekosaur> andromeda-galaxy, the usual usage mode is you derive an empty Generics instance and get a class default implementation
22:18:23 <zomg> Want to make a function that goes from MyGadt a -> Result a which works as long as I don't touch MyGadt in any way - as soon as I try to do something with it (like map it into a text value for reasons), the typechecker goes nuts :p
22:18:29 <geekosaur> so it can't know the details of specific instances
22:18:37 <glguy> there's an art to writing things so that generics can be efficient
22:19:20 <andromeda-galaxy> geekosaur: my point was that when you write deriving (Generic), ghc should know what it needs to not need to do that.
22:19:51 <andromeda-galaxy> glguy: that's useful information (re: some of the conditions that ghc uses). Is there much other documentation around on the important components of that art?
22:19:54 <cocreature> zomg: you’ll have to show some code and the error messages if you’d like help with that
22:20:06 <andromeda-galaxy> zomg: show us code?
22:20:28 <geekosaur> andromeda-galaxy, part of the problem there is that, while ghc provides a generics implementation, it does not force you to use it
22:20:37 <geekosaur> you could use e.g. SYB instead
22:20:47 <geekosaur> so the compiler is not allowed to assume you meant GHC.Generics
22:21:09 <geekosaur> whoch means it doesn't necessarily know what it can get away with
22:21:11 <glguy> andromeda-galaxy: it's mostly general purpose Haskell optimization stuff, 
22:21:24 <glguy> it's not special treatment of generics
22:21:29 <zomg> cocreature, andromeda-galaxy yeah thanks but I suspect it'll take you both a year to explain it in a way that I'm not going to have another problem with it later ;)
22:21:46 <zomg> I'll just go back to interesting type shenanigans once I get this program working
22:21:53 <andromeda-galaxy> glguy: hmm, makes sense
22:22:45 <glguy> the only magic to ghc generics is that ghc makes the instances for you if you want. you could just as easily make the equivalent instances by hand
22:24:04 <andromeda-galaxy> right, that makes sense. My confusion here is that geekosaur is indicating that you can write by hand better/more efficient instances, but I think that DeriveGeneric should be able to (regardless of whether or not it does right now) write equally good instances
22:24:40 <glguy> three isn't really any room for improvement
22:26:03 <andromeda-galaxy> that makes more sense
22:26:19 <Guest13167> iran ?
22:26:40 <MarcelineVQ> so far away-ay-ay
22:27:29 <glguy> https://github.com/glguy/generic-traverse/blob/master/src/Boggle/Demo.hs
22:28:17 <glguy> this was a demonstration package I did for an example of how to get efficient generated code via generics for a tricky case
22:29:20 <andromeda-galaxy> wow, that looks interesting
22:30:42 <glguy> boggle is just a silly name I picked after ed renamed by lens fusion function fusing and the traversal one confusing
22:33:31 <LiaoTao> Well it's certainly boggling
22:42:40 <EvanR> is there a combination take drop
22:43:13 <LiaoTao> splitAt?
22:43:19 <andromeda-galaxy> EvanR: splitAt?
22:43:28 <EvanR> > splitAt 9 [1,2,3]
22:43:30 <lambdabot>  ([1,2,3],[])
22:43:32 <EvanR> k
22:43:39 <andromeda-galaxy> sorry LiaoTao, didn't see your msg
22:43:54 <LiaoTao> andromeda-galaxy: Double the help is better than no help :)
22:44:41 <andromeda-galaxy> LiaoTao: true ;)
22:57:47 <sophiag> glguy: i'm just looking back on all this discussion about generics now and wondering why there are efficiency problems with generically derived traversable instances?
23:04:29 <glguy> sophiag: elements of the generic representation get hidden behind applications of fmap and (<*>) and this prevents the ultimate application of to from observing all the elements of the generic representation at once and thus it can not optimize away
23:08:56 <athan> Hmm... has anyone here messed around with sum types for constraints?
23:09:25 <athan> (not saying I have a complete idea)
23:10:52 <sophiag> glguy: thanks. i guess that should be fairly obvious when considering data types of any relative complexity, but i never thought about it before. obviously i've been thinking about Traversable given my "type level Traversable" idea (which i realized is horrendous to implement in Haskell), but i'm also actually reading Andy Gill's paper about Type-Safe Observable Sharing right now and that touches on somewhat similar themes (although
23:10:52 <sophiag> from 2012 so don't think they could have derived generic Foldable or Traversable instances back then)
23:10:53 <athan> Maybe... I could keep around a type-level token, to act as a ST thread for types, then say something frickin weird like `foo :: Engage Ord k m => Manager m => ...` or something
23:23:46 <sophiag> actually the application i was thinking of using type level traversables for, parsing ASTs from haskell-src-exts, may be greatly simplified by some of Conal Elliott's work in Compiling Embedded Languages. the bulk of the code was turning ASTs for lambdas with basic equality and arithmetic into functions i could store in records and apply later
