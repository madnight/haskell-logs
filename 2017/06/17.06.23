00:02:30 <Unhammer> with stack, can I install a e.g. "pretty-show" and have it available in ghci without putting it in the cabal?
00:12:39 <asdfjfjjfd> how to update variable based on user input?
00:13:26 <asdfjfjjfd> fails: var = var ++ user_input
00:14:59 <MarcelineVQ> Unhammer: stack ghci --package pretty-show
00:17:04 <Unhammer> oh neat, thank MarcelineVQ 
00:17:22 <Unhammer> *thanks
00:19:48 <asdfjfjjfd> coming from python. using main = do ... main loop and want to maintain state in variable. in python, would have global var. how do accomplish this in haskell?
00:20:34 <glguy> you can add function parameter to your logic loop
00:20:41 <zomg> asdfjfjjfd: state monad would be one option, ioref, tvar, mvar other options
00:21:05 <asdfjfjjfd> zomg: thanks, any other option beside monad? have not learned them yet. sorry new to haskell..
00:21:12 <int-e> asdfjfjjfd: the most fundamental idea is to turn the global variable into an argument of the function: main = main' (initial value); main' var = do ... main' (new value of var)
00:21:23 <zomg> asdfjfjjfd: glguy's suggestion is probably the way to go then, it's definitely the simplest way to do it :)
00:21:40 <asdfjfjjfd> hmm ok
00:21:54 <asdfjfjjfd> how to add function parameter to logic loop?
00:22:08 <zomg> IORef is pretty easy to use too but it might be a bit "unhaskell'y" to use it in that fashion :P
00:22:17 <int-e> asdfjfjjfd: it's the same as what I just sketched.
00:22:37 <asdfjfjjfd> int-e: ok, thanks!
00:23:09 <halogenandtoast> for running database queries is it suggested to use resourcet like https://github.com/agrafix/funblog/blob/64a3d7cc369fc784d3b603d4a82f74f3103d5e70/src/Web/Utils.hs#L31
00:23:47 <halogenandtoast> the description of resourcet sounds reasonable, but I am wondering if other have experience with it.
00:25:14 <Guest13818> Hello Haskellers
00:25:21 <osa1> is there syntax for giving multiple pattern synonyms same type? like x, y, z :: Int
00:25:26 <zomg> halogenandtoast: iirc Persistent or some other lib uses ResourceT so it seems proven at least
00:26:15 <merijn> halogenandtoast: Literally everything using conduit, yesod or persistent is using ResourceT :p
00:26:44 <halogenandtoast> merijn: zomg thanks, good to know.
00:28:05 <merijn> Sometimes I wish there was a simple way to fork/exec processes with more input pipes than just stdin...
00:29:15 <cocreature> halogenandtoast: you might also be interested in michael’s recent blogpost about resourcet https://www.fpcomplete.com/blog/2017/06/understanding-resourcet
00:30:06 <halogenandtoast> cocreature: ah thanks
00:30:44 <Guest13818> As a beginner which recource is good for learning haskell?
00:31:48 <cocreature> @where learnhaskell
00:31:48 <lambdabot> https://github.com/bitemyapp/learnhaskell
00:32:25 <cocreature> Guest13818: that contains a bunch of free resources. a lot of people also seem to like http://haskellbook.com/ but I haven’t read that one myself (it came out after I’ve learned Haskell)
00:32:47 <merijn> Anyone have any suggestions/alternatives if I want multiple pipes to write to a subprocess? Or should I just fork/exec with extra pipes in C?
00:32:48 <Guest13818> Thanks
00:33:43 <cocreature> merijn: are you talking about unix pipes and OS processes or pipes from the pipes package and haskell threads?
00:34:06 <merijn> cocreature: unix pipes, OS processes (I'm communicating with python code)
00:34:28 <merijn> I mean, if it happens to work on windows too, that's a bonus. But POSIX is all I really give a shit about
00:34:47 <halogenandtoast> Guest13818: yeah Haskell Programming from First Principles is supposed to be good, personally I've been enjoying http://www.cs.nott.ac.uk/~pszgmh/pih.html but it's not free.
00:35:31 <halogenandtoast> but the example problems in programmig in haskell are amazing to me
00:35:49 <cocreature> merijn: I’m not really following. fork doesn’t close fds so you should just be able to access it in the new process, no?
00:36:21 <merijn> cocreature: Right, but process doesn't have an API for that. Hence, my question: Does something already exist or do I roll my own in C?
00:38:39 <cocreature> ah ok
00:38:44 <cocreature> I don’t know of anything
00:41:06 <EvanR> when a thunk is evaluated and the result "cached", does every access of this value later have to check the status of the thunk to see if its already evaluated, and if not, do it
00:41:34 <merijn> EvanR: "It Depends (TM)"
00:42:11 <merijn> In the tagless approach I don't think you have to, but I think GHC switched to a somewhat tagged approach at some point?
00:43:01 <EvanR> ah, you could put a pointer to code there rather than status info
00:43:13 <EvanR> and overwrite the pointer
00:47:05 <merijn> EvanR: The idea behind the tagless approach is that you have a pointer to code that returns the value OR code that evaluates the thunk, overwrites the pointer and returns the value
00:47:11 <EvanR> unrelated, is there a go-to reference for optimizations possible for a purely functional language
00:47:21 <EvanR> purely functional language compiler
00:47:24 <cocreature> the ghc source code? :)
00:47:28 <EvanR> :(
00:47:41 <merijn> EvanR: Well, most of the stuff imperative compilers do works in functional languages, but easier
00:47:51 <EvanR> yes theres that
00:47:55 <merijn> EvanR: What kinda things are you looking for?
00:48:01 <EvanR> but wondering about the stuff specific to purely functional
00:48:04 <EvanR> no idea
00:48:42 <merijn> Is HsBase.h generated?
00:48:56 <EvanR> i get the impression ghc outputs machine code that doesnt resemble anything you wrote at all
00:49:09 <merijn> Ah, not github search is just shit
00:49:15 <merijn> EvanR: That's definitely true
00:49:26 <merijn> EvanR: Your first stop should probably be the STG paper
00:49:34 <merijn> @where stg
00:49:34 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
00:49:47 <EvanR> does this have anything substantial on optimizations
00:50:19 <merijn> EvanR: Not optimisations per se, but it's literally called "Implementing Lazy Functional Languages on Stock Hardware", i.e. x86/x86_64
00:50:41 <EvanR> right, i guess thats the most basic optimization of all :)
00:50:57 <EvanR> as opposed to an interpreter
00:51:14 <merijn> EvanR: So it covers the basic intuition of how you would produce machine code from something like STG (generalising to Haskell should be fairly straightforward if you understand compilers a little)
00:51:30 <merijn> EvanR: The exact minutiae are outdated, but it's still the best "first step" I'm aware of
00:52:00 <merijn> For example, the way partially applied functions are handled was changed (see the How to Make a Fast Curry paper for that)
00:52:14 <EvanR> as two examples, how do you optimize lambda calculus code before it becomes ready to be compiled into machine code, how do you optimize the code right before it becomes assembly, cmm, llvm, or wahtever
00:52:46 <EvanR> like program transformations rather than how-to-call-a-function how-to-implement-a-thunk
00:53:18 <FluBar> Hi guys - I'm trying to parse a csv file with numbers in a foreign format (using Cassava). I've tried to make custom instances of FromField and ToField but with no luck. I would like to do some string replacements on the Field before parsing the resulting string with the normal Double Parser. A (non-functioning) stub of code can be found here: http://lpaste.net/356416 . Thank you.
00:53:26 <merijn> EvanR: The GHC pipeline is: Haskell -> Core -> STG -> ((Cmm -> ASM), LLVM)
00:54:07 <merijn> EvanR: A lot of it boils down to "inlining and watching for classic imperative style control-flow optimisations, etc."
00:54:11 <EvanR> i assume optimizations after the STG stage are really to be found anywhere in a compiler textbook
00:54:11 <cocreature> more like CMM -> (ASM, LLVM)
00:54:19 <merijn> cocreature: I wasn't sure about that
00:54:23 <cocreature> merijn: I am :)
00:54:43 <EvanR> but prior to that, we get bed time stories about how amazing purely functional languages are to optimize
00:55:11 <merijn> EvanR: Well, lemme tell you how my (imperative language based) compiler class went:
00:55:19 <EvanR> i took that too...
00:55:27 <EvanR> they didnt cover haskell
00:55:42 <merijn> 1) Here's a neat idea for an optimisation, 2) sketch of how to do that, 3) now here's why we can't do it unless we have ridiculously complex control flow analysis because of aliasing/mutability
00:55:57 <merijn> EvanR: Oh, so you know SSA?
00:55:58 * quchen recommends looking at Santos’ thesis, it’s about optimizing Haskell and it’s excellent
00:56:19 <EvanR> i know about SSA
00:56:22 <bollu> quchen link please?
00:56:28 <quchen> ?google santos thesis haskell
00:56:30 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
00:56:33 <quchen> Arr.
00:56:35 <EvanR> another line of query is about compilers for lisp
00:56:38 <bollu> quchen also, have you seen GRIN? It is _so much simpler_ than STG
00:56:40 <merijn> EvanR: Core is basically in SSA
00:56:45 <EvanR> im not sure if those involve any deep optimizations though
00:56:47 <bollu> quchen like, it's so simple I almost wept yesterday
00:56:52 <bollu> quchen fuck STG >_>
00:57:08 <quchen> :-C
00:57:11 <EvanR> o_O
00:57:37 <bollu> question to anyone who knows how to compile STG: since the Node register is basically a global variable between function calls, how can you ever perform inter-procedural analysis or something with it?
00:57:54 <bollu> the Node register will "lock" separate invocations, will it not?
00:57:57 <merijn> bollu: Most of the high level optimisation is done on Core
00:58:15 <quchen> bollu: Got a link to a paper?
00:58:27 <quchen> »grin haskell« doesn’t yield one 
00:58:32 <merijn> bollu: So when you move to STG you're mostly going to be doing lower level optimisations (and even lower level when you move to Cmm)
00:58:47 <mekeor> wtf is Spineless Tagless G-machine?
00:58:52 <asdfjfjf> why 'if True then exitSuccess' causes error in main loop? I have included 'import System.Exit'
00:58:53 <merijn> bollu: So I think the answer to do "how do you do high-level analysis on STG?" is "you don't"
00:58:53 <bollu> quchen http://web.archive.org/web/20080222023943/http://www.cs.chalmers.se:80/~boquist/ifl96-abstract.html
00:59:02 <bollu> merijn yes. that is unfortunate
00:59:13 <merijn> mekeor: The abstract machine that older implementations of GHC are based on
00:59:14 <bollu> merijn which is why I also feel that STG is a "pointless" abstraction in some sense.
00:59:25 <bollu> merijn still are? 
00:59:27 <merijn> bollu: STG exists to be easier to translate to Cmm
00:59:28 <bollu> merijn with some changes
00:59:37 <merijn> bollu: Well, it's no longer tagless, afaik
00:59:46 <bollu> merijn yeah, because eval/apply
00:59:50 <merijn> It'd be an Spineless G-machine at best :p
01:00:00 <bollu> spineless tagless G machine sounds more badass than spineless G machine
01:00:13 <bollu> I'll be honest, the only reason I started reading the STG paper was because it sounded *so cool*
01:00:48 <merijn> mekeor: The confusing name of the STG isn't really all that relevant. The paper, incidentally, is highly readable to anyone with basic Haskell knowledge and some familiarity with C and/or ASM
01:01:10 <merijn> mekeor: I highly recommend reading it for anyone interested in "how do you even compile something like Haskell to assembly?"
01:01:15 <quchen> Even without knowing C or ASM it’s very useful to read the first two parts
01:01:24 <EvanR> spineless tagless G-less non-machine
01:01:27 <EvanR> incredible
01:01:28 <bollu> merijn you don't need that much of machinery if all you're trying to do is compile
01:01:30 <merijn> quchen: Sure, you don't even need that much C :)
01:01:51 <EvanR> quchen: which santos paper
01:01:58 <merijn> Like, you need to understand the idea of the C stack vs heap for the latter explanations
01:02:09 <bollu> merijn also, I realised that the while(1) { cont = (*cont)() } thing doesn't work exactly that way because you can't type that function?
01:02:10 <quchen> EvanR: Optimizing something something. Let me fetch a link.
01:02:30 <bollu> quchen yes please, I'm interested as well
01:02:46 <Unhammer> merijn: my earlier question about ghc panic with ffi was solved with the opposite of your suggestion :-) ensure fobject-code is *off*
01:03:01 <merijn> mekeor: The STG is basically 2 things: 1) a very minimal/simple functional language and 2) an abstract machine that can evaluate that language (and thus explain what STG *does* operationally)
01:03:01 <Unhammer> I had it on in .ghci
01:03:09 <bollu> merijn the fact that STG exists to lower to C-- is a bummer. I was hoping that writing it in LLVM would give me fancy optimisations, but I don't think that's going to happen because of the "Node register"
01:03:15 <Unhammer> But :set doesn't show that :-(
01:03:57 <bollu> mekeor the original paper is decent: https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
01:04:11 <bollu> mekeor but I feel it can be explained better, tbh.
01:04:14 <merijn> mekeor: The idea is you compile Haskell to STG (reasonably easy, since it's also a functional language, but without all the complex sugar/typeclasses, etc.) and then you basically need to mimic the abstract machine in hardware. (The same way the C standard defines an abstract machine to describe what compiled C should do)
01:04:28 <asdfjfjf> why 'if True then exitSuccess' causes error in main loop? it raises parse error on the next line. I have included 'import System.Exit'.
01:04:38 <merijn> asdfjfjf: Missing else
01:04:41 <bollu> quchen also, remember we were discussing why they show it as 3 separate stacks? It's because it helps during codegen for GCing. Abstractly, one stack is cleaner
01:04:42 <quchen> The paper is hard to find, woah. I remember just googling »santos thesis« and finding it. It’s a fairly long paper about the different possible core-to-core transformations and their utility in GHC
01:04:48 <asdfjfjf> merijn: thanks
01:05:09 <quchen> bollu: It uses two stacks that are different than the three stacks for compilation, no?
01:05:17 <quchen> One for primitives and one for lifted data
01:05:23 <bollu> quchen yep
01:05:31 <merijn> asdfjfjf: Assuming you want to continue when it's False you might want 'when' in this specific scenario
01:05:34 <merijn> :t when
01:05:36 <lambdabot> Applicative f => Bool -> f () -> f ()
01:05:53 <bollu> quchen but they motivate it by saying that "we can merge the stacks but GC has to do more work". "However, we can coalesce the stacks this way to get 2 stacks!"
01:05:55 <asdfjfjf> merijn: ok, thank you
01:06:01 <merijn> asdfjfjf: "when b act" is basically "if b then act else return ()"
01:06:04 <bollu> quchen I was re-reading the "lowering to C" part because I'm lowering it to LLVM
01:06:22 <asdfjfjf> merijn: great that is what I needed
01:06:29 <bollu> quchen read the GRIN paper, it
01:06:39 <bollu> it's very nice* at least. how much I've read
01:06:55 <bollu> quchen it's on the level of Core though, their IL. it's not an abstract machine
01:07:07 <quchen> My network is slooooow
01:07:11 <bollu> However, lowering GRIN IR to STG would be interesting. I'm not sure if it would work because it's in CPS style
01:07:14 <quchen> This one? http://mirror.seize.it/papers/The%20GRIN%20Project.pdf
01:07:23 <bollu> s/not sure if it would work/not sure if it would be performant
01:07:35 <quchen> Wasn’t edwardk working with GRIN in TurboHaskell?
01:07:53 <quchen> I remember him mentioning something in Zürich a year ago
01:08:07 <merijn> hmmm
01:08:22 <bollu> quchen this: http://dl.acm.org/citation.cfm?id=743083
01:08:22 <merijn> Well this is a mess
01:08:26 <bollu> quchen yes and no
01:08:36 <bollu> quchen he's writing a tracing JIT that starts out STG and moves to GRIN
01:08:39 <merijn> base doesn't open files with O_CLOEXEC, that's probably not right...
01:08:43 <bollu> quchen because GRIN is whole program optimiser
01:09:03 <bollu> quchen so, he wishes to "collect information as it goes along" and then gradually go from STG repr -> GRIN repr
01:09:08 <HasNoob> In this " phoneBookToMap xs = Map.fromListWith (\number1 number2 -> number1 ++ ", " ++ number2) xs " how does 'number1' and 'number2' binds to value of map?
01:09:14 <bollu> quchen at least, that was what I gathered when we spoke. I could be wrong
01:09:21 <bollu> "THC" is such a cool name though :P 
01:09:57 <quchen> Because weed, yes very funny.
01:10:29 <HasNoob> please help
01:10:39 <bollu> quchen no, because "turbo haskell" is perfect irony :P 
01:11:03 <bollu> :t fromListWith
01:11:05 <lambdabot> error:
01:11:05 <lambdabot>     • Variable not in scope: fromListWith
01:11:05 <lambdabot>     • Perhaps you meant one of these:
01:11:10 <quchen> :t M.fromListWith
01:11:11 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
01:11:12 <bollu> ah
01:11:29 <EvanR> a purely ironic language
01:11:54 <HasNoob> thanks, got it.
01:12:26 <bollu> > M/fromListWith (+) (zip (map show [1..] [1..10])
01:12:29 <lambdabot>  <hint>:1:49: error:
01:12:29 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:12:35 <bollu> > M.fromListWith (+) (zip (map show [1..] [1..10])
01:12:37 <lambdabot>  <hint>:1:49: error:
01:12:37 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:13:35 <quchen>  /q lambdabot etc
01:13:37 <FluBar> Hi guys - I'm trying to parse a csv file with numbers in a foreign format (using Cassava). I've tried to make custom instances of FromField and ToField but with no luck. I would like to do some string replacements on the Field before parsing the resulting string with the normal Double Parser. A (non-functioning) stub of code can be found here: http://lpaste.net/356416 . Thank you.
01:13:59 <quchen> I think I’m chatting as much with Lambdabot as I am on this channel ;-)
01:15:05 <quchen> FluBar: Is the comma in the number confusing your parser?
01:15:12 <quchen> FluBar: In other words, is it a well-formed CSV or not?
01:15:57 <FluBar> quchen, the CSV is wellformed but attoparsecs Double parser won't accept the number format: 1.234,50
01:16:11 <FluBar> quchen, so I would convert it into 1234.50
01:17:25 <merijn> FluBar: Looks like you need a locale aware format
01:17:44 <merijn> I'd google for some library that implement locale aware number parsers
01:18:20 <quchen> FluBar: You can write your own parser for your format instead of converting the raw format using byte replacement
01:18:31 <quchen> I think that might be cleaner and easier to understand (but also more verbose)
01:19:10 <asdfjfjf> why this does not exit? also any other code advice for haskell newbie. thank you: https://pastebin.com/CWPALvmf
01:19:34 <merijn> quchen: I can't imagine a locale aware parser not yet existing
01:20:11 <EvanR> believe it
01:20:16 <merijn> asdfjfjf: You keep appending each new word at the end of guesses
01:20:29 <merijn> asdfjfjf: Try printing out guesses every iteration ;)
01:21:15 <asdfjfjf> merijn: hmm ok
01:21:20 <EvanR> GHC hilariously uses a US american locale despite being british, and thats the only choice
01:21:52 <FluBar> quchen, merijn, thanks. I guess if I have some parser `Field -> Double` I can make the FromField instance that I need.
01:22:07 <asdfjfjf> merijn: main problem is that exitSuccess is never executed, not sure why
01:22:16 <quchen> FluBar: Exactly, yes.
01:22:28 <asdfjfjf> merijn: wait found problem
01:22:59 <asdfjfjf> should be if word == blanks
01:24:38 <merijn> asdfjfjf: :)
01:25:05 <merijn> EvanR: No, it's not using US locale
01:25:16 <merijn> EvanR: It's using C locale, like almost all unix programs do by default
01:25:28 <merijn> EvanR: Which is why there's no thousands separator in large numbers
01:25:38 <EvanR> i was going to say, whats the diff
01:25:44 <merijn> EvanR: If it was using US locale you'd get "1,489.50" rather than "1489.50"
01:25:50 <FluBar> I have another (noob) question regarding same problem. In the cassava library Field is defined like this: `type Field = ByteString`. Can I use any function that works with ByteStrings on the Field without any "boilerplate" code or will the type checker complain? I've seen some errors regarding this but I'm not sure if it was because of Lazy vs Strict ByteStrings. Just so I have no doubts about the type synonym.
01:27:29 <quchen> FluBar: type creates synonyms that you can interchange arbitrarily
01:27:46 <FluBar> quchen, OK thanks.
01:27:57 <quchen> FluBar: This might clarify data/newtype/type: https://github.com/quchen/articles/blob/master/fbut.md#data-newtype-type
01:28:05 <quchen> 2 minute read, hopefully worth it :-)
01:28:51 <ertes-w> helo
01:29:05 <quchen> ertes-w: helo!
01:30:09 <FluBar> quchen, got it, thank you. It's stuff that I (ought to) know but being a beginner sometimes I confuse the data, newtype and type thing :-) Practice I guess..
01:30:16 <quchen> bollu: How is changing the GHC prettyprinter coming along?
01:30:26 <quchen> FluBar: They’re also very poorly named if you ask me :-/
01:30:29 <bollu> quchen not bad, there's a phab diff
01:30:39 <bollu> quchen but my GHC build is breaking mysteriously 
01:30:42 <bollu> quchen I need to fix that tonight
01:30:46 <quchen> bollu: Oh nice! Compiles and everythinggggg okaynevermind
01:30:47 <bollu> quchen https://phabricator.haskell.org/D3650
01:30:51 <bollu> quchen xD
01:31:04 <bollu> quchen yes, it "should" compile, but my package.conf is broken, strangely
01:34:09 <ertes-w> quchen: nice article!
01:34:39 <ertes-w> i was going to write something like that =)
01:34:49 <quchen> ertes-w: FBUT?
01:34:50 <merijn> Here I go, tilting at windmills again...
01:35:05 <ertes-w> quchen: yeah
01:35:05 <merijn> ertes-w: FBUT saves me so much time here :p
01:35:15 <quchen> ertes-w: Saved me loooots of repeated explanations here! :-) Feel free to add something that you think fits
01:35:21 <ertes-w> indeed
01:35:39 <ertes-w> yeah, but it pretty much covers everything i wanted to write about =)
01:35:41 <quchen> I guess it’s my version of Stephen Diel’s what-I-wish
01:35:47 <quchen> Different focus though
01:36:27 <quchen> bollu: I’m surprised how small the patch is! You basically just implemented a compatibility module, no?
01:36:37 <quchen> bollu: I guess the breakage comes from including Text
01:36:50 <quchen> bollu: And somewhere some flag wasn’t set right or something
01:38:54 <quchen> cocreature: I just had an idea for your different-width-text. Why not have a »Doc Text« document with annotations such as »annotate "forall" "∀"«? This would look like »∀« to the layout algorithm, but your renderer could output it as »forall«.
01:39:12 <quchen> cocreature: I mean the expanded version is really just something a certain backend should be interested in
01:39:31 <quchen> cocreature: This way you don’t break having different backends by hardcoding the length of »forall« to be 1, for example
01:42:07 <cocreature> quchen: seems reasonable
01:42:31 <quchen> That way you can even define multiple paragraphs to render as »foo« ;-)
01:42:55 <quchen> This eliminates the pain point that I had with your solution: it works only for text nodes, not for vertically separated things and so on
01:43:01 <quchen> So it felt like a special case
01:43:19 <quchen> cocreature: On a different note, I noticed you’re working on the LLVM-HS project, pretty cool!
01:43:42 <cocreature> quchen: let me know if you end up using it for something :)
01:44:02 <halogenandtoast> if I could figure out LLVM I'd use it for my language
01:44:19 <cocreature> halogenandtoast: have you read stephen diehl’s tutorial?
01:44:22 <quchen> halogenandtoast: Read Stephen Diehl’s Kaleidoscope tutorial, it’s excellent
01:44:34 <quchen> It’s almost like enabling easy mode
01:44:49 <halogenandtoast> I'm aware of it, haven't read it
01:44:50 <quchen> cocreature: I will definitely at some point! I’m fleshing out my go-to project for learing new languages so I have something comparable
01:44:52 <halogenandtoast> I have some time this weekend
01:44:56 <halogenandtoast> I'll check it out
01:45:16 <quchen> halogenandtoast: It shouldn’t take much longer than an hour to read through it superficially, which already helps a lot
01:45:58 <quchen> cocreature: It will be a Brainfuck compiler webservice of some sort, I just have to decide which features to use. https://github.com/quchen/articles/blob/master/fbut.md#what-program-should-i-write
01:46:51 <quchen> I’m currently trying to do it in Rust with both hands tied behind my back. One because I’m new to Rust, another one because lots of useful abstractions don’t work in Rust’s limited type system regardless of skill level :-/
01:47:27 <quchen> Writing a parser is something you have to think about. I’m not used to that.
01:47:40 <ertes-w> it baffles me that so few languages support full polymorphism
01:47:46 <merijn> quchen: The exact reason I'm rewriting my Python to Haskell :p
01:48:01 <merijn> Although I do find myself having to resort to SQL via Text concatenation...
01:48:22 <ertes-w> rust in particular, because on the surface you might think that it has a strong connection to haskell, but it doesn't really
01:49:07 <quchen> What irks me the most is that there is no focus on immutability; mut is something you just do if necessary, not something you think about
01:49:15 <quchen> &mut self all the time
01:49:39 <quchen> I did not expect that
01:50:26 <tomboy64> don't forget, rust is aimed at people coming from languages like c, python, perl. those can't really deal with lots of immutability (ime)
01:51:01 <EvanR> i use immutability in C all the time!
01:51:12 <cocreature> trying to use rust made me realize how much I’m relying on a garbage collector in other languages :)
01:51:22 <halogenandtoast> quchen: neat that you have a learn a language project
01:51:26 <halogenandtoast> I have one too, I write Sokoban
01:51:34 <merijn> cocreature: I'm doing lots of C++, RAII all the things!
01:51:38 <tomboy64> sokoban!
01:51:50 <tomboy64> <3
01:51:58 <merijn> cocreature: RAII + shared_ptr/unique_ptr has (almost) eliminated my main problem with C's memory management
01:52:16 <ertes-w> the thing that really gets me is that i prefer C++ over rust, because i can use the abstractions i'm used to…  abstractions that work
01:52:39 <cocreature> merijn: sure I write c++ like that as well but throwing shared_ptr all over the place can bite you really hard it it becomes the bottleneck and figuring out how to convert everything to unique_ptr is not trivial
01:52:49 <halogenandtoast> tomboy64: https://github.com/halogenandtoast/all_the_sokobans
01:53:59 <halogenandtoast> Eventually I should add some more languages...
01:54:09 <tomboy64> ^^
01:54:22 <halogenandtoast> I had a simpler program I wrote in a bunch of languages, but not Sokoban
01:54:23 <halogenandtoast> https://github.com/halogenandtoast/randl
01:55:18 <dramforever> I not sure at all if I should ask it this way, but: Has *anyone* here understood what's going on with this 'transient' thing?
01:55:22 <dramforever> https://github.com/transient-haskell
01:56:33 <mrkgnao> hmm, I can't understand where the putDocW function is in prettyprint. Anyone familiar with the library?
01:56:35 <merijn> hmm, I think the simplest solution for my multi FD issue is to simply send a new fd to stdin of the child
01:56:45 <mrkgnao> <https://github.com/quchen/prettyprinter>
01:57:10 <mrkgnao> um, https://github.com/quchen/prettyprinter works better, I suppose.
01:57:11 <merijn> quchen: Hmm, do you think anyone is familiar with that library? :p
01:57:20 <cocreature> mrkgnao: Data.Text.Prettyprint.Doc.Render.Text
01:58:42 <ertes-w> dramforever: each time i wanted to try it, there was a much simpler solution with far less conceptual overhead just around the corner =)
01:58:49 <mrkgnao> cocreature: there's a putDoc, no putDocW. and the types are different.
01:59:02 <ertes-w> dramforever: i think the whole transient thing suffers from what i like to call the enterprise syndrome
01:59:19 <mrkgnao> I have 1.1 in stack.yaml, but I also used GitHub "search".
01:59:22 <cocreature> mrkgnao: what’s putDocW? hoogle doesn’t find that in any lib
01:59:33 <ertes-w> dramforever: making things huge and complex and solve every problem, while at least apparently forgetting what they are actually about
01:59:38 <dramforever> ertes-w: It's *advertised* as otherwise so...
01:59:52 <dramforever> They *say* it's simple
01:59:54 <mrkgnao> cocreature: yeah, but all the prettyprinter docs use that function a lot.
01:59:55 <cocreature> oh it’s in the docs
01:59:56 <mrkgnao> owait.
02:00:01 <mrkgnao> the docs are for 1.0.1
02:01:01 <ertes-w> dramforever: it still has a lot of conceptual overhead that is only ever justified if you do actually need all of its features at once
02:01:43 <cocreature> mrkgnao: https://github.com/quchen/prettyprinter/blob/a846295db3bebf74efe07cb75fd7ac9b7a78158c/prettyprinter/src/Data/Text/Prettyprint/Doc/Util.hs#L54
02:01:52 <dramforever> ertes-w: You mean that the claimed benefits don't check out?
02:01:54 <dramforever> Say, https://github.com/transient-haskell/transient/wiki
02:03:15 <dramforever> (tbh I lost much interest when it says 'If you can play guitar without knowing music notation'. I think that's not how music works. I'm pretty sure that's not how programming works)
02:03:16 <ertes-w> dramforever: i mean that i'm not convinced they check out…  perhaps i'm missing the point, but the conceptual overhead never appealed to me
02:04:36 <EvanR> most people who play guitar dont read music
02:04:38 <ertes-w> dramforever: cloud haskell has the same problem: it's supposed to make distributed computing easier, but then it starts to come up with all those extra concepts like static methods
02:04:47 <merijn> EvanR: Word :p
02:05:00 <merijn> ertes-w: tbh, static methods are pretty awesome
02:05:12 <merijn> ertes-w: And that's hardly something Cloud Haskell came up with
02:05:13 <dramforever> EvanR: oh thanks for that fyi
02:06:19 <ertes-w> merijn: yeah, but ultimately it's tangential and raises the conceptual overhead substantially
02:06:42 <dramforever> But the message passing does seem to work pretty well
02:07:12 <merijn> ertes-w: I don't think it's tangential. I've reimplemented a hacky version of static a bunch of times in Haskell
02:07:48 <merijn> ertes-w: I think StaticPointers are crucial for sensible use of distributed Haskell
02:10:00 <dramforever> Perhaps it's a similar thing with transient? Only a part of it really matters, and the rest is just sugar to make you feel more gross than necessary trying it out
02:10:03 <ertes-w> merijn: i disagree…  distributed programming is really about discovery, message-based networking and fault tolerance…  RPC is merely an abstraction on top of that
02:10:19 <ertes-w> merijn: cloud haskell gets that completely wrong
02:10:39 <ertes-w> it focusses on all the wrong things IMO
02:11:48 <ertes-w> network-transport is really the most useful they came up with, but then i'd ask: why should i even use it given ZeroMQ?
02:18:08 <merijn> ertes-w: Clearly you're doing very different stuff like me
02:18:32 <merijn> ertes-w: I'm doing "I wanna shoot a bunch of jobs into the cluster" and having to find a way to serialise jobs is a pain
02:19:54 <merijn> See, I don't believe in "distributed computing is about discovery" if you care about discovery, you're essentially having several independent services interacting, that's not just distributed, that's regular code communicating
02:20:15 <merijn> I wanna run the same program/code on a bunch of machines and communicate computations between them
02:23:53 <ertes-w> merijn: yeah, that's true, but i think both are distributed computing, and even in your scenario you would benefit from discovery and fault tolerance…  RPC could be an extra library; it shouldn't be a primitive
02:25:32 <ertes-w> or let me put it this way: cloud haskell could be simpler and more elegant, while covering *both* use cases
02:25:37 <merijn> ertes-w: How can you sanely communicate closures without having something like StaticPointers built in?
02:25:50 <merijn> Honestly, my fault tolerance is "fail early and rerun"
02:26:07 <ertes-w> merijn: i wouldn't…  i would send messages
02:27:18 <merijn> ertes-w: Which brings me back to my original point of: Some things are stupidly convoluted to turn into messages
02:28:16 <ertes-w> merijn: right…  as i said, it's not that you have to do it without RPC, it's that RPC shouldn't be a primitive
02:28:30 <mrkgnao> cocreature: as a matter of fact, I generated local Haddocks for 1.1, the references to putDocW are still there. 
02:29:09 <dramforever> ertes-w: I think merijn asked: How can you sanely communicate closures without having something like StaticPointers built in?
02:29:46 <ertes-w> dramforever: you can't, but how is that relevant?
02:29:59 <ertes-w> you would of course use them
02:30:41 <merijn> ertes-w: You were literally saying that StaticPointers "shouldn't be a primitive"
02:30:51 <dramforever> Wait... what do you mean by 'RPC' shouldn't be a primitive
02:31:08 <ertes-w> merijn: no, that's not what i mean
02:31:16 <merijn> ertes-w: Then you should work on your wording :p
02:33:09 <ertes-w> merijn: RPC should not be a primitive in cloud haskell, but should be a layer on top of messages…  of course that layer would use static pointers
02:33:38 <ertes-w> and of course those need to be built in
02:40:23 <quchen> mrkgnao merijn Yes I am familiar with that library
02:40:37 <quchen> mrkgnao: putDocW is used for the doctests, mostly
02:41:13 <quchen> mrkgnao: It used to be defined as a doctest comment actually, now I’ve put it into the Utils module
02:45:24 <mrkgnao> quchen: great, thanks!
02:46:31 <quchen> mrkgnao: If you’ve got questions or the documentation isn’t clear, do tell me! Feedback from first time users is often very valuable
02:46:57 <mrkgnao> the docs are orders of magnitude better than the old ansi-wl-* libraries :)
02:47:02 <quchen> :-)
02:47:28 <mrkgnao> I'm going to try and hack trifecta to use this using the compat modules. 
02:47:50 <mrkgnao> maybe you could put a warning about putDocW in the docs, though. it tripped me up, as you can see.
02:50:27 <bollu> quchen since you have push access to trifetca, can you document the "here's how you parse tokens when you have identifiers"
02:50:46 <bollu> :)
02:50:52 <quchen> bollu: I don’t have push access to Trifecta I think
02:50:57 <bollu> ah, I see
02:51:17 <quchen> bollu: You have push access to your own fork of Trifecta though, why not doucment it and file a PR :-þ
02:51:43 <bollu> quchen the fruits of labour is sweetest when you're not doing the labour :P 
02:51:53 <bollu> though in all seriousness, I will do that this saturday
02:51:54 <quchen> I curse you haha
02:52:02 <quchen> But you’re right
02:54:48 <bollu> about the documentation part?
02:55:14 <quchen> About everything
02:56:30 <bollu> ah xD
03:46:24 <piyush-kurur> bollu: your quote on fruits of labour is great. I will use it some where. 
03:46:48 <bollu> piyush-kurur go ahead xD
04:24:09 <merijn> hmmm, unix package doesn't cover ioctl?
04:27:54 <ertes-w> merijn: what do you need?
04:29:46 <merijn> ertes-w: I_SENDFD and I_RECVFD
04:31:38 <ertes-w> merijn: for a socket?  if yes: https://hackage.haskell.org/package/network-2.6.3.2/docs/Network-Socket.html#g:10
04:31:49 <merijn> No
04:31:57 <merijn> ioctl is for pipes
04:32:08 <merijn> You use sendmsg (i.e. network) for sockets
04:32:57 <ertes-w> well, if you can switch to a unix socket instead of a pipe, you don't have to write ioctl bindings =)
04:33:10 <ertes-w> unix sockets support FD transmission, too
04:33:26 <merijn> unix sockets would dramatically complicate all the other code
04:33:35 <merijn> Since I can't pipe via stdin
04:35:35 <kuribas> is haskell suitable for testing and continuous integration?
04:35:39 <kuribas> for other languages?
04:36:06 <ertes-w> merijn: another option, if you're execing into the process yourself, would be to disable CLOEXEC and just inherit the FD directly
04:36:36 <ertes-w> the unix package supports that
04:36:56 <merijn> ertes-w: You don't have to disable CLOEXEC (see my email to libraries@ from today :p), but then I still need to communicate the FD to the child process
04:38:49 <ertes-w> yeah, but you no longer need FD passing…  just give it the numeric FD value
04:39:36 <merijn> True, I suppose
04:39:59 <ertes-w> alternatively: take over the 'ioctl' package and make it usable =)
04:40:13 <merijn> ertes-w: Yeah, I looked at it, but it doesn't seem to have any content...
04:40:25 <merijn> ertes-w: I'd probably just inline ioctl FFI into my package
04:40:37 <ertes-w> yeah, looks like an early alpha that was immediately abandoned
04:41:40 <ertes-w> yay, i found a short-coming in the machines library
04:43:11 <ertes-w> i wish MachineT were based on a monad, so that i could delimit it
04:53:08 <clamchowder> Hello, is there a haskell port of fuzzy wuzzy? https://github.com/seatgeek/fuzzywuzzy
04:54:30 <heebo> anyone have any recommendations for a digraph library
04:54:52 <merijn> clamchowder: Looks like it's just Levensteihn distance on strings, google for that to find some Haskell library
04:56:00 <clamchowder> merijn: OK thanks.
04:57:16 <ertes-w> clamchowder: https://hackage.haskell.org/package/edit-distance
04:58:51 <clamchowder> ertes-w: that looks like a good starting point for me. thanks
05:10:24 <quchen> edwardk: Thanks for merging. Any chance I get get a Hackage release soon so I can use it for prettyprinter? :-)
05:12:55 <Unhammer> Can I deconstruct a Maybe in pattern guards? something like
05:12:56 <Unhammer> f x y z
05:12:58 <Unhammer>   | foo == Just x -> [x]
05:13:00 <Unhammer>   | foo == Nothing -> []
05:13:02 <Unhammer>   where foo = getMeAFoo x y z
05:13:42 <Unhammer> I mean, deconstruct something defined in a where clause
05:14:10 <merijn> Unhammer: Looks like you want a pattern guard
05:14:29 <Unhammer> yeah, but can I bind the x there?
05:14:36 <Unhammer> oh I shadowed, confusing
05:14:38 <merijn> "| Just x <- getMeAFoo x y z = [x]; | otherwise = []"
05:14:42 <Unhammer> f y z
05:14:44 <Unhammer>   | foo == Just x -> [x]
05:14:46 <Unhammer>   | foo == Nothing -> []
05:14:48 <Unhammer>   where foo = getMeAFoo y z
05:14:52 <merijn> Unhammer: Use pattern guards, not ==
05:16:32 <Unhammer> ooh, I've never used <- there before
05:17:20 <ij> !ping
05:25:22 <quchen> Unhammer: One of the things Haskell 2010 gave us! :-)
05:29:04 <Unhammer> :)
05:35:46 <merijn> hmmm
05:36:10 <bollu> does anyone here work at tweag? 
05:39:40 <Geraldus> Hi folks!
05:40:38 <Geraldus> Is it possible to make secondary index field in Persistent's model DSL?
05:41:50 <ertes-w> Unhammer: ironically "_ <- _" is what you would call "pattern guards" =)
05:42:45 <Unhammer> haha yeah I never know what to call all the little bits of syntax
05:45:46 <ertes-w> edwardk: [machines] what's your opinion on changing MachineT such that it's just the non-CPS version of PlanT, or at least providing one as the underlying abstraction used by MachineT?  that would be really useful, because you could delimit it, which MachineT only supports in a very awkward way
05:46:32 <ertes-w> edwardk: example: lines :: MachineT k Text m r -> FreeT (MachineT k Text m) m r
05:46:55 <bollu> edwardk quick question: in the GRIN IR, there seems to be no support for a "default pattern match". So, how would someone implement seq?
05:47:14 <bollu> edwardk The question is, if you have a default pattern match, how will you lower it down to GRIN?
05:48:42 <ertes-w> edwardk: another example: take :: Int -> MachineT k o m r -> MachineT k o m (MachineT k o m r)
06:00:59 <cocreature> do we have a binary search for sorted immutable vectors somewhere? vector-algorithms only seems to have one for mutable vectors for reasons I don’t understand
06:05:07 <yamadapc> I'm having an issue with a windows binary compiled with stack; where it'll run with stack exec but complain about missing DLLs when ran normally
06:13:26 <ertes-w> cocreature: i'm using unsafeThaw with vector-algorithms
06:13:42 <Geraldus> Please ping me If you know how to make secondary index field in Persistent DSL!
06:14:09 <cocreature> ertes-w: yeah I was considering that but it seems ugly so I was hoping that there is something prettier
06:15:21 <mpickering> Is there some trick to emulate closed type classes?
06:18:15 <quchen> mpickering: Yes! Give them superclasses that you don’t export
06:19:34 <cocreature> does “Gave up! Passed only x tests” mean that QuickCheck reached some kind of timeout?
06:20:08 <quchen> cocreature: Hmm, or that you used ==> too much and not enough tests were generated
06:20:21 <cocreature> quchen: ah it’s definitely the latter in my case, thanks
06:20:43 <cocreature> using isPrime is probably not such a good idea :)
06:21:04 <quchen> Hah no
06:21:08 <quchen> Write your own generator
06:21:15 <cocreature> I’m too lazy for that :)
06:21:20 <quchen> elements (take 1000 allPrimes)
06:21:26 <quchen> Here you go
06:21:28 <quchen> :-)
06:21:33 <cocreature> heh :)
06:24:18 <ertes-w> cocreature: instance Arbitrary Prime where arbitrary = fix (\again -> do x <- arbitrary; if isPrime x then pure (Prime x) else again); shrink = coerce . filter isPrime . shrink . coerce
06:24:43 <quchen> ertes-w: A+ suggestion would consult again
06:24:49 <cocreature> thanks :)
06:25:51 <quchen> isPrime x = factors x == [1, x]
06:25:55 <quchen> Hope that helps
06:26:15 <quchen> Can we do better, that is, worse?
06:26:24 <cocreature> factors x | isPrime x = [1,x]
06:26:40 <ertes-w> quchen: what?
06:26:46 <ertes-w> ah
06:26:53 <ertes-w> i had trouble parsing that
06:27:02 <quchen> isPrime x = null (filter (`divides` x) [2 .. x-1])
06:27:08 <ertes-w> mpickering: you can also use a GADT to close a class
06:29:39 <ertes-w> mpickering: https://gist.github.com/anonymous/a3cde0a93306b39b5e6787aa54241f29
06:42:08 <Guest3217> any body in iran ?
06:42:13 <Guest3217> here
06:42:40 <Guest3217> iran please
06:48:37 <merijn> Question: If I convert an Fd to a Handle and hClose the Handle, do I still need to also close the Fd?
06:53:07 <merijn> Looks like the answer is yes
07:11:57 <juanpaucar> I have 2 newtypes for a Transformers over ReaderT which would be the equivalent of `unFoo` for Bar?
07:11:59 <juanpaucar> https://gist.github.com/juanpaucar/c6294a7b4387837e91b122ccdd5ac741
07:12:26 <dmj`> you can define a function for that
07:12:38 <dmj`> unBar (Bar x) = x
07:13:08 <dmj`> \r m -> flip runReaderT r (unBar m)
07:14:39 <juanpaucar> dmj`: I see, i though it was shorter. Thanks a lot
07:15:04 <dmj`> juanpaucar: you could make it shorter 
07:16:04 <juanpaucar> dmj`: I was trying to figure out how, i think my brain is already fried
07:16:19 <dmj`> it’s probably not as pretty
07:16:28 <dmj`> you could use a where block for unBar
07:16:58 <dmj`> \r m -> flip runReaderT r ((\(Bar x) -> x) m)
07:19:11 <juanpaucar> dmj`: Thanks :)
07:30:46 <dmj`> juanpaucar: np
07:31:10 <ertes-w> anyone know a good library for streaming JSON?
07:31:19 <ertes-w> *does
07:31:58 <ertes-w> this is mostly about streaming output, but streaming input would be useful, too
07:33:06 <clamchowder> How do I declare type synonym with instance constraints?
07:33:32 <clamchowder> type Vector a = (Num a) => [a]
07:33:47 <ertes-w> clamchowder: you need RankNTypes for that
07:33:53 <clamchowder> this gives me an error
07:36:40 <dmj`> ertes-w: io-streams can do that
07:37:24 <dmj`> ertes-w: parseFromStream (Data.Aeson.Parser.json)
07:37:57 <dmj`> :: InputStream ByteString -> IO r
07:38:14 <clamchowder> ertes-w: how do i do that? I read haskellwiki page on rankntypes but it's not clear for me
07:38:15 <ertes-w> dmj`: does io-streams support being converted to other stream processors?
07:38:30 <ertes-w> clamchowder: write this at the top of your file:  {-# LANGUAGE RankNTypes #-}
07:39:39 <dmj`> ertes-w: you mean like converting between different libraries?
07:39:57 <clamchowder> ertes-w: OK thanks that works.
07:40:25 <merijn> Is there a way to pinpoint exactly which expression is throwing an exception? I'm getting an exception in hClose but I can't figure out which one
07:41:57 <ertes-w> dmj`: it needs to support being converted to machines…  seems like it's possible, although i'm a bit puzzled why it pulls in attoparsec and zlib
07:42:26 <dmj`> “batteries included"
07:43:17 <ertes-w> dmj`: ah, it's not quite the kind of streaming parsing i was looking for
07:43:24 <ertes-w> it still results in an in-memory Value
07:43:28 <ryantrinkle> does anyone happen to know if -dynamic is supposed to be the default on macOS?
07:43:33 <ryantrinkle> for executables
07:43:48 <ertes-w> dmj`: and i could do that using attoparsec directly…  no need to pull in io-streams
07:44:10 <ryantrinkle> i'm running into an issue where it looks like ghc tries to link statically by default, but that's rather broken (when depending on a library that depends on a system framework)
07:44:14 <ertes-w> (in fact that's exactly what i'm doing)
07:49:26 <dmj`> ertes-w: sure, wasn’t aware you were already using machines
07:50:59 <ertes-w> looks like i'm gonna have to write it myself
08:00:21 <kuribas> Is there any advantage in using haskell for testing or continuous integration?
08:00:30 <Fuuzetsu> bollu: "<bollu> does anyone here work at tweag?  [12:35:54]" hey, can I help?
08:01:03 <bollu> Fuuzetsu hey :) I was wondering if tweag offers summer internships to interested haskeller undergrads.
08:02:08 <shapr> kuribas: generative testing is well supported in Haskell
08:02:32 <kuribas> shapr: for haskell code, or also other languages?
08:02:45 <shapr> I've seen QuickCheck used to generate tests for other languages.
08:03:08 <shapr> https://wiki.haskell.org/QuickCheck_as_a_test_set_generator
08:03:20 <kuribas> oh, that's neat
08:03:29 <shapr> though these days many languages have their own framework for generative testing.
08:03:37 <merijn> ertes-w: I don't think trying to use the file descriptor across a fork was a smart choice...
08:03:41 <shapr> "property based testing" is the most popular term I've heard for that.
08:03:55 <merijn> ertes-w: Now I get the fun debugging experience of "why does python believe this pipe is broken?"
08:06:47 <kuribas> haskell webdriver seems useful as well
08:06:59 <ertes-w> merijn: sorry
08:07:21 <ertes-w> merijn: but it's actually pretty standard practice among systems tools
08:10:11 <merijn> ertes-w: Yeah, I know, but debugging it is a pain in the ass :\
08:10:59 <ertes-w> i can imagine
08:11:10 <ertes-w> is FD passing really the only optino?
08:11:12 <ertes-w> option
08:11:39 <merijn> ertes-w: Not the only one, but it would be the simplest. Going through a file is also a hassle, as-is setting up sockets
08:12:19 <ertes-w> i'm not sure you wouldn't get the same kind of weird bugs with SENDFD
08:12:41 <ertes-w> i think FD passing is a questionable technique in general
08:13:58 <merijn> oh well, fuck it, I'll debug this later
08:40:23 <clamchowder> Say I define a datatype: data Vector a = V [a], is there a function to access the list given a variable x of type Vector Int, like in racket one can use something like (V-Vector x)?
08:41:19 <Fuuzetsu> clamchowder: I suspect yes but I don't really understand your question. What does (V-Vector x) do?
08:41:42 <clamchowder> Fuuzetsu: it returns the list inside x
08:42:32 <Fuuzetsu> data Vector a = V { _unVector :: [a] }; _unVector :: Vector a -> [a]
08:42:43 <clamchowder> Fuuzetsu: sorry should be (Vector-V x) but you know what i mean
08:43:42 <clamchowder> Fuuzetsu: thanks. The haskell way looks more clumsy than Racket though
08:44:23 <Fuuzetsu> is it? here _unVector is just your "x"
08:44:45 <Fuuzetsu> you just want to unpack the vector right? Again, I don't know racket and unsure I'm getting you...
08:45:14 <Fuuzetsu> In practice you don't unpack things that often anyway, you just hid the implementation for a reason!
08:45:22 <clamchowder> Fuuzetsu: yes just want to unpack
08:46:43 <Fuuzetsu> then you use _unVector or whatever you want to call it; it's just a record field
08:47:21 <ertes-w> clamchowder: you could also pattern-match
08:47:28 <ertes-w> f (Vector xs) = …
08:47:31 <max3> can someone help me figure this out 
08:47:33 <max3> https://github.com/databrary/databrary/blob/1e2a94ac93aa6548db418d9dea5edf2b088a9609/Databrary/Controller/Upload.hs#L52
08:47:44 <max3> for some ungodly reason the deformCheck fails
08:47:54 <max3> even though `(isJust . getFormatByFilename)` returns true
08:49:13 <clamchowder> thanks.
09:15:00 <NemesisD> does anyone know how to configure stack to use a different stackage mirror? their main mirror seems to be having SSL problems
09:24:06 <ertes-w> gaaah…  library design 101: you do not export identifiers named "str"
09:26:58 <ryantrinkle> has anyone seen runghc or runhaskell give "Too late for parseStaticFlags: call it before runGhc or runGhcT"?
09:28:50 <Fuuzetsu> ertes-w: I exported "span" in some new package recently...
09:29:47 <cocreature> Fuuzetsu: that’s not so bad. in fact I can’t recall that I’ve ever had a variable named "span" in my code
09:30:01 <ertes-w> Fuuzetsu: shame on you =)
09:30:20 <Fuuzetsu> cocreature: Prelude.span..
09:30:20 <ertes-w> i guess it's my fault for not importing Options.Applicative qualified
09:30:33 <cocreature> Fuuzetsu: oh …
09:30:45 <cocreature> *bangs head on desk*
09:30:46 <Fuuzetsu> _and_ we have a span in the codebase it's being used in..
09:38:52 <grl_> Haskellveien_
09:38:54 <grl_> ?
09:57:48 <sepakorayl> FunctorDeriving works for multiparam datatypes.
09:58:20 <sepakorayl> is it possible to derive it for newtypes focusing on different parameters other than the last one ?
09:58:39 <cocreature> sepakorayl: no, you can’t write that instance manually either
09:59:41 <cocreature> sepakorayl: making f an instance of Functor requires that f has kind * -> * which basically means that it only has one parameter, i.e., all other parameters have already been applied
10:00:18 <sepakorayl> i can make f a b, a functor no?
10:00:33 <cocreature> depends on what f is
10:01:00 <cocreature> you can’t make "Either" a functor, you can only make "Either a" a functor
10:01:01 <Fuuzetsu> you can give ‘f a’ an instance
10:02:10 <sepakorayl> i have an f a b c. functor deriving makes an instance for f a b. I want to use wrappers and make instances for them so I can selectively fmap on different parameters.
10:02:29 <sproingie> functors and monads only ever take one arg, i.e. they're kind * -> *
10:02:59 <Fuuzetsu> sepakorayl: you could write Trifunctor class or something
10:03:13 <sproingie> pretty sure there's a bifunctor package
10:03:19 <Fuuzetsu> one too few parameter!
10:03:22 <sepakorayl> there is a genifunctor package
10:03:24 <Fuuzetsu> bifunctor is in base
10:03:42 <sproingie> myself, i've no idea what i'd write a bifunctor for
10:03:46 <sepakorayl> I was just wondering if it's possible to use a language extension instead
10:03:47 <Fuuzetsu> Either!
10:03:57 <cocreature> (,)
10:04:21 <Fuuzetsu> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Bifunctor.html#t:Bifunctor all of these unexciting things
10:04:23 <sproingie> probably something involving arrows ... ditto on what i'd do that for
10:04:33 <sproingie> i took one look at yampa and my brane went boom
10:11:25 <cocreature> hvr: Hey, I saw you’re the maintainer of integer-gmp. can I convince you to move powModInteger and recipModInteger out of the Internals module? They don’t seem really seem internal to me and they’re really useful for doing modular arithmetic.
10:18:08 <ertes-w> let (swap :: F2 a b -> F2 b a) and (rotate :: F3 a b c -> F3 c a b) such that swap . swap = id, and rotate . rotate . rotate = id
10:18:15 <ertes-w> is there a name for structures like F2 and F3?
10:18:58 <sproingiesaur> the forth guy in me says Stack
10:19:42 <sproingiesaur> and spells that second combinator "rot"
10:21:34 <ertes-w> sproingiesaur: doesn't sound right…  (swap . swap = id) says that F2 uses its point types the same number of times
10:22:00 <ertes-w> contrived example: data Bistream a b = Cons a b (Bistream a b)
10:22:46 <ertes-w> if you could extract the individual substructures, they would be isomorphic
10:23:52 <sproingiesaur> isomorphic it would seem to Stream (a,b)
10:24:20 <sproingiesaur> have some curry, it's good for you.  or is that uncurry :)
10:28:32 <torstein> If there's a module that's not on hackage, but there's a git repo with a .yaml and .cabal, what's the best way of using that package in my project? Where should I pull the repo to so that cabal can find it if I list in the deps, etc
10:29:07 <glguy> torstein: If you're using new-build, you can add it to the packages: section of your cabal.project
10:29:23 <glguy> If you're using sandboxes: cabal sandbox add-source
10:29:32 <sproingiesaur> just mind the indentation level of extra-deps: in stack.yaml
10:29:37 <sproingiesaur> it's super fiddly
10:30:03 <sproingiesaur> er, s/-deps:/-dep:/
10:31:38 <sproingiesaur> torstein: here's an example: https://github.com/chuckadams/scamp/blob/master/stack.yaml
10:31:52 <codygman_> I seem to recall a haskell package that generates API bindings for swagger APIs. Does it exist or is it wishful thinking?
10:31:59 <shapr> Isn't that in servant?
10:32:14 <torstein> sproingiesaur: Thanks, I'll give that a try
10:32:38 <shapr> codygman_: at first glance, it's the other direction: https://hackage.haskell.org/package/servant-swagger
10:44:44 <Fuuzetsu> ertes-w: F2 = (,); F3 = (,,)
10:44:48 <Fuuzetsu> ;^)
10:45:09 <Fuuzetsu> oh, you mean general name
10:47:10 <ertes-w> Fuuzetsu: yeah
10:47:17 <ertes-w> F2 and F3 could be sum types
10:47:25 <Fuuzetsu> right
10:47:26 <sproingiesaur> tuple is product
10:47:35 <Fuuzetsu> yes but sum would work too
10:48:17 <sproingiesaur> that would make F2 Either
10:48:24 <sproingiesaur> er, F2 == Either
10:48:54 <sproingiesaur> overall concept then would be just ... Sum
10:50:04 <ertes-w> anyway, gotta go now…  thanks for your input
10:50:12 <Fuuzetsu> or lack thereof..
10:50:17 <Fuuzetsu> o/
10:56:58 <codygman_> shapr: hm alright, thanks
11:06:54 <grayhatter> is the a way to [re]load haskell modules
11:07:22 <grayhatter> I have a client app that I'd like to be able to update without losing the current state
11:07:57 <EvanR> theres a few ways to attempt that
11:07:58 <grayhatter> e.g., send it a command, and it'll unload/reload the selected functions
11:08:33 <sproingiesaur> it's decidedly untrivial
11:08:46 <EvanR> the most obvious way is to try to use a dynamic loader after you swap out a plugin DLL
11:09:09 <EvanR> see package plugins
11:09:26 <EvanR> you might find this way sucks for one or more reasons
11:09:31 <sproingiesaur> i'd suggest dividing the client into a front and back end and just restarting the entire backend process
11:09:51 <sproingiesaur> it's robust and works for any language
11:10:06 <grayhatter> what about forking with a pipe? the reload command could kill the first child, and then refork, exec the new backend code, and then handle everything else with pipes?
11:10:21 <EvanR> that is another way
11:10:23 <sproingiesaur> that's basically what i said with more detail
11:10:40 <EvanR> separate processes that communicate with IPC is probably the most reliable
11:10:41 <grayhatter> sproingiesaur: yeah, I was already typing and didn't want to start over :P
11:10:43 <EvanR> and the most work
11:10:44 <sproingiesaur> there's supervisors that work out of the box for this sort of thing
11:11:17 <grayhatter> the better way, may be is there a haskell equiv to python's pickle
11:11:21 <sproingiesaur> systemd being the obvious choice for linux, tho i'm partial to runit
11:11:34 <grayhatter> in C I'd just dump the struct to a bin on disk
11:11:41 <grayhatter> in python I'd just pickel
11:11:42 <sproingiesaur> there's serialization packages, tho i recommend aeson
11:11:43 <EvanR> are you just trying to update data?
11:11:46 <EvanR> rather than code?
11:11:53 <grayhatter> but in haskell I have no idea how to store/load a state
11:11:55 <sproingiesaur> most of #python tends to steer people away from pickle
11:12:03 <sproingiesaur> and toward json
11:12:11 <grayhatter> sproingiesaur: right, there's almost always a better way, but I'm lazy
11:12:14 <EvanR> i assumed you wanted to update the running program with new code
11:12:22 <grayhatter> EvanR: I do, that's the ideal
11:12:38 <sproingiesaur> trust me, serialization is not for lazy people.  you have to constantly guard against even trivial changes and write migration code every time
11:12:49 <sproingiesaur> with json, you agree on a schema and robert's your father's brother
11:12:51 <EvanR> ... ok if you just want to update some data structure theres better ways than dividing the project into two processes and rewriting
11:12:59 <grayhatter> but I don't want to work that much, so if I can just save the previous state, then load it, so I only have down time, and not loss of data, that's almost as good
11:14:03 <grayhatter> I've got an irc bot wirtten in haskell (obviouslly), I'd like to be able to update the source when I fix bugs, without having the bot spam channels with quit/joins. But what I REALLY want, is to not lose information saved in the state monad
11:14:31 <EvanR> im having a hard time figuring out which thing you really want
11:14:39 <EvanR> this is like parallel questions
11:14:54 <grayhatter> EvanR: that's the problem I'm trying to solve
11:14:57 <sproingiesaur> maybe saving a write-ahead log of state changes.  easy if your app is event-sourced to start
11:15:08 <EvanR> not losing state = database
11:15:14 <grayhatter> all my previous questions where "does haskell have a tool like the tool I've already used"
11:15:15 <sproingiesaur> yah you could just use sqlite
11:15:20 <EvanR> not closing connections = separate processes
11:15:27 <sproingiesaur> sqlite gives you a battle-tested WAL out of the box
11:16:21 <glguy> grayhatter: I don't know of any existing libraries to help with this, but I would expect you should be able to fork the new version and have it inherit the socket, and pass the state serialized as an argument or via a file
11:16:22 <EvanR> sometimes erlang is described as solving both of these at once with its runtime, but no it only solves the not closing connections part, with separate internal processes
11:16:32 <pikajude> climbing up the WALs
11:16:46 <EvanR> it solves not losing state with, a database, or the implicit assumption that you really dont care about the state if you reboot
11:16:49 <sproingiesaur> actually just have your bot connect to a bouncer proxy
11:17:00 <grayhatter> glguy: that sounds awesome actually 
11:17:15 <glguy> going through ZNC as sproingiesaur mentions is going to be easier, though
11:17:32 <EvanR> sending fds to another process :S
11:17:33 <grayhatter> lol sproingiesaur that's pretty clever too, I may just do that, as the least friction way, then just save the state
11:17:34 <sproingiesaur> irssi has a built-in bouncer
11:18:09 <grayhatter> I'm already running a znc server on the box
11:18:28 <glguy> grayhatter: Do you know about #haskell-irc ?
11:18:32 <grayhatter> too bad I didn't think of that before, I spent about 2h learning how to do SSL sockes in haskell
11:18:32 <sproingiesaur> yah if you just need to persist connection, that's the way to go
11:18:36 <EvanR> so use a bouncer and a database 
11:18:39 <grayhatter> glguy: no I don't
11:18:53 <sproingiesaur> database is useful if you need to replay commands in a crash-only design
11:19:08 <sproingiesaur> you're talking about scheduled maintenance like upgrades, you don't really need the WAL for that
11:19:34 <grayhatter> ...in a crash-only design
11:19:42 <EvanR> is WAL the new term for "database"
11:19:47 <grayhatter> I've never heard that before, can you explain or suggest required reading?
11:20:14 <sproingiesaur> no i was suggesting a WAL of commands for an event-sourced design, and sqlite gives you a nice WAL
11:20:31 <sproingiesaur> https://en.wikipedia.org/wiki/Crash-only_software
11:20:45 <sproingiesaur> most of erlang OTP is built as crash-only
11:20:49 <c_wraith> EvanR, WAL is write-ahead log. it's a technique databases can use to be ACID-compliant 
11:21:39 <sproingiesaur> i suppose i should expand my TLAs from time to time
11:22:05 <grayhatter> sproingiesaur: TLA is my favorite TLA
11:22:18 <sproingiesaur> MFT
11:22:20 <EvanR> yeah i know about that, i just thought this was going to be the birth of a renaming of old jargon to related jargon
11:22:48 <sproingiesaur> naw, i'm just kinda careless how i conflate terms
11:23:21 <sproingiesaur> i chalk it down to chronic mental flatulence.  brainfarts.
11:24:23 <merijn> sproingiesaur: Incidentally, if you're interested in "crash-only" design, but don't need a database, acid-state is really cool
11:24:38 <merijn> sproingiesaur: It's basically ACID for Haskell heap data
11:25:08 <sproingiesaur> ohyah, i forgot about that.  that one looks super nice.
11:25:29 <merijn> I think the constant confusion of "acid-state as database" is rather unfortunate, ACID heap data is much more interesting (if a bit niche)
11:25:34 <EvanR> somehow the crash-only thing seems misleadingly simple, because i imagine a buggy program crashing in an infinite loop due to a bug
11:26:05 <sproingiesaur> crash loops result in a service shutdown.  which usually means a system rollback.
11:26:25 <EvanR> back to before the bug was written? :)
11:26:37 <merijn> EvanR: The idea behind crash-only isn't "always crash", but "no explicit shutdown"
11:26:38 <sproingiesaur> something th eswitch networks also probably did automatically
11:27:00 <sproingiesaur> back to a known good state anyway.  basically rebooting..
11:27:05 <merijn> EvanR: They idea is, treat "clean shutdown" as an optional optimisation over crashing, rather than mandatory
11:27:22 <EvanR> shutdown, though wikipedia is emphasizing restarting
11:27:38 <EvanR> shutting down is the easy part :)
11:27:40 <merijn> EvanR: It's basically "able to restart from any termination as if it was controlled termination"
11:27:41 <sproingiesaur> cassandra is a crash-only design.  you can shut it down with kill -9
11:27:58 <sproingiesaur> they still recommend the shutdown command so it gets logged
11:28:17 <EvanR> so now im not sure if were even talking about crashing
11:28:20 <merijn> EvanR: For example, if you have a daemon whose program state is ACID, you don't really have to think about "clean" shutdown. You can simply kill it, reload the state when it died and continued
11:28:27 <sproingiesaur> kill -9 is a very hard crash
11:28:42 <sproingiesaur> hell, segfaults are way more polite about it
11:28:43 <monochrom> Today's xkcd is relevant re: restarting :)
11:29:12 <EvanR> it seems were using crashing as a euphemism for asking something to stop
11:29:15 <sproingiesaur> ah yah a robust web app is also crash-only in a way
11:29:35 <EvanR> rather than failing for some unplanned reason
11:29:39 <merijn> EvanR: Let's approach the explanation from the other side: "Regardless of when it exits, you should be able to restart from any exit with minimal recovery (and definitely not manual recovery)"
11:30:09 <merijn> EvanR: It's called "crash-only" because you're designing as if there is no such thing as "controlled shutdown", only crashes (hence, crash-only)
11:30:13 <EvanR> now it sounds like idempotence
11:30:36 <merijn> EvanR: I would say that's probably a good association
11:30:50 <merijn> Not quite the same thing, but certainly closely related
11:31:00 <monochrom> Hmm what if every crash comes with controlled shutdown?
11:31:02 <sproingiesaur> idempotence is part of such a design
11:31:20 <merijn> EvanR: The term originates here: https://dslab.epfl.ch/pubs/crashonly.pdf
11:31:20 <sproingiesaur> monochrom: impossible.  think power loss.
11:31:29 <merijn> monochrom: See above
11:31:34 <EvanR> im not really sure where "controlled shutdown" comes from, seems like a bad idea from every which way
11:31:35 <monochrom> Oh oops.
11:32:06 <sproingiesaur> naw, giving users a few minutes warning before a system goes down is "controlled"
11:32:13 <EvanR> slow, takes work, can fail
11:32:14 <merijn> EvanR: Yet every OS has an explicit "shutdown" command that takes a while
11:32:19 <EvanR> i know
11:32:27 <merijn> EvanR: Most services/daemon have explicit shutdowns that take long, etc.
11:32:28 <EvanR> its terrible!
11:32:32 <merijn> EvanR: Well, yes
11:32:36 <anon1324> Is there a point to making a newtype of a tuple vs a data? I understand that newtypes will be thrown away completely by GHC and that tuples sometimes get unboxed where it makes sense. Would both of these optimizations happen for a newtype of a tuple?
11:32:39 <sproingiesaur> crash-ony is designed for environments where there's no tolerable concept of "down".  telephone switches for example.
11:32:40 <merijn> EvanR: That's the entire point of crash-only design ;)
11:32:49 <merijn> EvanR: To throw all that out
11:32:58 <EvanR> who invented controlled shutdown
11:33:05 <monochrom> Me.
11:33:05 <EvanR> nuclear plant engineers i guess
11:33:11 <sproingiesaur> good one
11:34:10 <EvanR> monochrom why, why
11:34:27 <Lokathor> anon1324, yes there are situations where you might want a newtype to wrap a tuple
11:34:46 <sproingiesaur> anon1324: i'd imagine that they both do apply, but you might want to dump out the Core to know for sure
11:34:47 <pedrorolo> hi there
11:34:56 <monochrom> I invented "graceful degradation", so "controlled shutdown" is just a special case. :)
11:35:04 <pedrorolo> how do I run stack ghci with no implicit prelude?
11:35:18 <EvanR> merijn: how about "stop any time"
11:35:19 <sproingiesaur> stack ghci -- args-to-ghci
11:35:19 <monochrom> Everyone loves graceful degradation, amirite?
11:35:21 <grl_> hey guys
11:35:22 <grl_> im from norway
11:35:25 <grl_> and i got a problem
11:35:33 <grl_> i was looking at some C source code
11:35:35 <grl_> and i was thinking
11:35:36 <anon1324> Lokathor: Do you have an example of a specific situation where it would make sense?
11:35:45 <grl_> what fucking homo invented this shit?
11:35:53 <sproingiesaur> @ops
11:35:53 <lambdabot> Maybe you meant: pl oeis docs
11:36:00 --- mode: ChanServ set +o glguy
11:36:00 --- mode: glguy set +b grl_!*@*
11:36:00 --- kick: grl_ was kicked by glguy (offtopic)
11:36:08 <EvanR> monochrom: now you have me about to rage about that one
11:36:14 <monochrom> :)
11:36:24 <Lokathor> anon1324, well, in a library I wrote I wanted to use the tuple's Storable instance to make it easy to put into a pointer, so I did a newtype over that instead of making my own data type and having to write Storable myself
11:36:25 --- mode: glguy set +b *!*@*/ip.92.220.69.55
11:37:16 <anon1324> Lokathor: Fair enough, thanks
11:37:29 <shapr> glguy: thanks!
11:37:32 <EvanR> list of oxymoronic technical patterns
11:37:33 --- mode: glguy set -bo grl_!*@* glguy
11:37:51 <Lokathor> EvanR never approves of my code :(
11:38:44 <EvanR> i dont know if thats fair, but if i never do im sorry
11:38:46 <monochrom> EvanR: Do you also have "machine learning" on that list?  <duck>
11:39:11 <Lokathor> no is fine
11:39:25 <EvanR> im about to rage about machine learning only because it suddenly is in every university cirriculum out of nowhere, and im not sure how its different from AI
11:39:42 <Lokathor> AI got a bad wrap when Terminator came out
11:39:44 <pedrorolo> <sproingiesaur>  it does not work
11:39:49 <sproingiesaur> uh, it certainly is related.  why the rage?
11:39:50 <monochrom> Oh, AI is broader.
11:40:00 <EvanR> AI are characters on steam games, machine learning is now real science
11:40:03 <sproingiesaur> ML is a hot subtopic of AI
11:40:03 <pedrorolo> https://www.irccloud.com/pastebin/CpzAh7sA/
11:40:41 <dobkeratops> is there a convention for something like a 'conversion operator' , like C++ Foo::Foo(Bar),  or Rust "A:From<B>/B:Into<A>"
11:40:49 <monochrom> For example "expert system" falls under AI but it contains no learning whatsoever. It's some human hardcoding a lot of axioms and the computer doing merely deductions.
11:41:03 <geekosaur> every time they come up with a new angle of attack on AI, it becomes the hot new thing and everywhere
11:41:03 <shapr> dobkeratops: is that a cast?
11:41:14 <shapr> geekosaur: they're fun to learn too
11:41:22 <sproingiesaur> dobkeratops: not for all types.  there's Coercible and Typeable for two different approaches though
11:41:27 <dobkeratops> 'casting' , 'conversion operator' .. whatever you'd call it-  turning one type into another
11:41:32 <shapr> I'm learning how to use principal component analysis on my own fitbit data.
11:41:34 <monochrom> Yeah geekosaur is speaking the truth. Last time expert systems were hot. :)
11:41:46 <sproingiesaur> there's also unsafeCoerce which is basically reinterpret_cast<>
11:41:59 <sproingiesaur> using it is as potentially disastrous as it sounds
11:42:08 <dobkeratops> in my context i'm definitely after a meaningful conversion
11:42:14 <glguy> pedrorolo: Check out 'stack ghci --help' to see how to pass options to GHCi
11:42:15 <muzzle> hi, can anyone tell me what the fastest way to do something like [v] -> (v -> k) -> Map k [v] is (time wise).
11:42:19 <dolio> Why not give it a meaningful name? :)
11:42:21 <dobkeratops> not a mere re-interpreting of the bitpattern
11:42:43 <sproingiesaur> dobkeratops: Typeable perhaps
11:42:45 <koala_man> I have a MS in AI/ML from 2008. Now with Deep Learning it's almost all useless ^^
11:42:58 <dobkeratops> (if i make my own i will copy the pattern from rust )
11:43:18 <sproingiesaur> or maybe Coercible...  i'm not really sure what fits there
11:43:20 <shapr> dobkeratops: what types do you wish to convert?
11:43:22 <koala_man> no one cares about Baysian networks and decision trees anymore
11:43:40 <monochrom> dobkeratops: There is no global convention. There are subculture conventions such as Data.Set, Data.HashSet, and Data.Vector.* all using the names "fromList" and "toList".
11:43:44 <sproingiesaur> koala_man: if your degree is worth anything, your skills are good for decades.
11:43:46 <pedrorolo> glguy thnks. 
11:43:58 <dobkeratops> shapr example: vertex data, which may be packed / unpacked, but semantically keeping meaning
11:44:04 <monochrom> And Data.ByteString and Data.Text both using the names "pack" and "unpack".
11:44:23 <sproingiesaur> koala_man: just that the software and libs you know are probably already obsolete.  c'est la vie.
11:45:05 <sproingiesaur> dobkeratops: generics perhaps
11:45:30 <dobkeratops> monochrom ok I guess you leverage the function name to specify the type, with inference, in those examples
11:46:29 <dobkeratops> i figured somethig like rusts 'from' might appear (by the sounds of it, coercible?),  given both languages have the abiltiy to infer types from output as well as input(?)
11:47:30 <sproingiesaur> for guiding inference, you just use a signature.  a type class perhaps.
11:47:45 <sproingiesaur> there is certainly no universal cast operation
11:47:58 <dobkeratops> i'll see how far I get without it.
11:48:42 <koala_man> fundamentals last forever
11:49:25 <dolio> Coercible is for casting between types that are defined to have the same representation.
11:50:15 <dolio> There is no single 'abstraction' for converting between two arbitrary types, because that is so ad hoc that most people would find it unpalatable, I think.
11:50:26 <sproingiesaur> yah neither Coercible or Typeable really fit.  it's really conventions like IsString and IsList
11:50:35 <sproingiesaur> (where's my IsNum?)
11:50:49 <monochrom> That's called fromInteger!
11:50:53 <monochrom> Also:
11:50:54 <sproingiesaur> er, IsTuple i guess is the missing one
11:50:59 <monochrom> @quote monochrom fromIntegral
11:50:59 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:51:12 <monochrom> Ah, IsTuple is called lens :)
11:51:43 <sproingiesaur> ouch.  but yah, i guess it's more complicated with a product type
11:54:14 <eborden> :q
12:02:25 <iqubic> What's the difference between a traversable and a prism?
12:02:38 <iqubic> or rather a traversal.
12:03:00 <johnw> prisms are sometimes called affine traversals, 0 or 1
12:03:49 <iqubic> How does that work?
12:04:13 <johnw> can you be more specific?
12:04:42 <iqubic> How does one create a prism?
12:04:44 <cocreature> one difference is that prisms allow you to "review"
12:05:02 <iqubic> And what are the basic prism combinators?
12:05:23 <cocreature> review and preview
12:06:12 <cocreature> but you might just want to take a look at the docs of Prism. for the most part they’re actually quite readable and describe the difference to a Traversable and what you can do with them https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Type.html#t:Prism
12:09:58 <NemesisD> i've got a laziness bug in some code I unfortunately can't share, but I'm stumped. i've got a function f :: Int -> STM Foo, and a call foo <- liftIO (atomically (f n)) throws an "atomically was nested" error.  doing f $! n, f $!! n, f (force n) all error, but if I use print or evaluate on n, no error
12:11:15 <NemesisD> its weird because $!!/force are supposed to evaluate deeper than `evaluate` which evaluates to WHNF (though I guess its an Int so that may not matter). basically evaluating in IO works and everything else doesn't
12:11:37 <johnw> f $! n doesn't evaluate n until you evaluate the result of f $! n
12:11:48 <johnw> printing n first will evaluate it before passing it as an argument to f
12:12:14 <monochrom> NemesisD, you can use "evaluate" and "rnf" together for maximum goodness.
12:13:01 <NemesisD> yeah i mean i figure if i have to spend too much more time on this i'll just throw in evaluate and call it a day but i have absolutely no understanding of why this is happening
12:13:36 <NemesisD> johnw: what about $!! ?
12:13:43 <kosmikus> well, atomically *is* nested in your code, isn't it?
12:14:00 <johnw> NemesisD: same thing
12:14:11 <kosmikus> oh, disregard that
12:14:12 <johnw> only `evaluate` forces a value in IO before the next statement in IO happens
12:14:16 <kosmikus> I've not been reading properly, I think
12:15:04 <NemesisD> yeah, i don't have any visible nesting of atomically that i can find. in fact, the function f for the time being could actually be :: (Applicative m) => Int -> m Foo
12:15:41 <monochrom> Are you talking about "liftIO (atomically (f $! n))"?
12:16:04 <NemesisD> yes, thats how i'm calling f
12:17:08 <c_wraith> NemesisD, what are you lifting it into?
12:17:12 <cocreature> NemesisD: where is n coming from? if that’s the result of an STM operation itself I could see how they’re being nested and evaluating it first works
12:17:25 <NemesisD> c_wraith: WriterT RunReport IO
12:17:42 <monochrom> No way.
12:18:10 <monochrom> There is not an unsafeInterleaveSTM to lazyize STM decisions.
12:18:41 <monochrom> The Int is lazy but the STM decisions made behind it are not.
12:18:44 <NemesisD> n is a field in a record that's passed into a function which in the caller is created in IO
12:19:09 <dolio> There's unsafeInterleaveIO.
12:19:12 <monochrom> Well I guess there is unsafeInterleaveIO (atomically (...))
12:19:13 <dolio> Also unsafePerformIO.
12:19:23 <NemesisD> i'm definitely not doing that though
12:19:49 <c_wraith> are you depending on any library that does concurrency things? 
12:20:23 <cocreature> do we have a library that provides hashtables that I can freeze and then read from outside of IO/ST?
12:21:39 <NemesisD> c_wraith: certainly. in fact n is actually a max concurrency count and f originally would build a TSem with it but i've walked that back while troubleshooting this (and losing my mind somewhat) so its just returning an unrelated pure value from STM
12:22:15 <NemesisD> c_wraith: but the program never makes it to the concurrent bit. it crashes on this nested atomically before all of that
12:23:20 <monochrom> I want to see more precise code. So you're saying "n <- liftIO (atomically (return 5)); liftIO (atomically (f $! n))" ?
12:26:16 <NemesisD> monochrom: i can try that, but its more like data Conf = Conf { _maxConc :: Int }; go :: Conf -> WriterT RunReport IO (); go conf = let n = conf ^. maxConc; foo <- liftIO (atomically (f n)); ... never gets here, crashes
12:54:40 <EvanR> cocreature: like... HashMap is too slow?
12:55:12 <cocreature> EvanR: too slow and too much memory overhead
12:58:15 <juanpauc_> Does somebody know why it can't infer the Generic instance for this code?
12:58:16 <juanpauc_> https://gist.github.com/juanpaucar/0b65e45864c0a6bfadc3391b55b022c8
12:58:58 <cocreature> juanpauc_: the error message is pretty clear: generics don’t work with data type contexts
12:59:23 <juanpauc_> cocreature: not sure about the "data type contexts"
12:59:44 <cocreature> juanpauc_: that’s the (FromJSON a, …) part in your data declaration
13:00:47 <juanpauc_> cocreature: does this mean that it needs a specific type instead of what i have (FromJSON....)
13:00:48 <merijn> Kill it with fire >.<
13:00:49 <cocreature> juanpauc_: it’s probably also worth pointing out that DataTypeContexts are deprecated and probably don’t do what you think they do
13:00:53 <merijn> Never use DataTypeContexts
13:01:13 <cocreature> juanpauc_: just remove the constraints and add them to the functions that operate on ObjectSnapshot instead of to the type itself
13:01:27 <merijn> cocreature: He has to add them to the functions anyway :p
13:01:56 <cocreature> merijn: right, that’s why DataTypeContexts are useless :)
13:01:57 <juanpauc_> cocreature: merijn: ara data type contexts bad?
13:02:20 <merijn> juanpauc_: They're useless, therefore they're clutter, therefore bad
13:02:33 <merijn> juanpauc_: So, not directly bad, but you still should get rid of them
13:03:30 <juanpauc_> But if I have to express properly my data record and it must be only something which has FromJSON and ToJSON, how could i represent it in the type and constructor declaration
13:03:31 <juanpauc_> ?
13:03:49 <merijn> juanpauc_: Well, while do you feel you should express that?
13:03:53 <merijn> s/while/why
13:04:31 <juanpauc_> So that anybody who reads the data record definition knows that for that property it must be something with those constraints
13:04:37 <juanpauc_> otherwise, how would they know
13:05:02 <merijn> juanpauc_: Well, that would normally be visible in the function producing the ObjectSnapshot
13:05:11 <cocreature> why does it need to have those constraints? as long as I don’t call any of the functions that try to deserialize/serialize I don’t need them
13:05:17 <cocreature> and if I do the constraints are on those functions
13:06:57 <juanpauc_> But wouldn't the type system prevent me from creating an invalid object like one which does not accomplish those constraint?
13:07:33 <merijn> juanpauc_: If all functions that create ObjectSnapshots have those constraints, then the type system already stops you from doing that
13:08:00 <EvanR> if all functions that use that functionality dont work, its stopping you, whether you can create the objects or not
13:08:28 <EvanR> while theoretically other stuff would still work when it doesnt need the functionality
13:08:41 <EvanR> very theoretically since you probably have no use for that
13:09:21 <EvanR> (singleton Sets of something with no Ord instance)
13:09:38 <juanpauc_> I see your point, i think that i never considered other functions out of the constructors themselves
13:09:58 <juanpauc_> Thank you all merijn cocreature and EvanR :)
13:11:05 <merijn> juanpauc_: Normally people hope putting the constraints on the datatype will let you leave them off of functions. Except, the way the type system works, that doesn't work, so you STILL need constraints on the type anyway :)
13:11:32 <merijn> juanpauc_: So, it just doesn't really add much, which is why they were removed in Haskell2010
13:12:16 <EvanR> so the system is to blame!
13:12:59 <juanpauc_> And when I compile the project and not only that file it actually warns me about that
13:13:23 <merijn> hmmm
13:14:11 <merijn> Any conduit experts? I'm having a weird issue. I'm using streaming-commons to stream stuff to a subprocess, however my stream to stdin seems to not be flushed for some weird reason...
13:14:20 <EvanR> it is possible to put the context in GADT constructors
13:14:40 <merijn> It hangs until I hit ctrl-C and then it promptly exits and runs whatever IO it was trying to...
13:14:58 <EvanR> which effectively stores the instance dictionary in the data object
13:15:36 <sproingiesaur> haskell sure is OO under the covers ;)
13:15:43 <EvanR> sounds like a lazy conduit
13:16:21 <EvanR> sproingiesaur: no! its totally different!
13:17:43 <merijn> EvanR: But that's the exact opposite of the point of conduit >.>
13:17:58 <merijn> EvanR: Also, it's a trivial pipeline, so I don't understand what's introducing the laziness
13:18:24 <sproingiesaur> buffering?
13:19:06 <merijn> sproingiesaur: That could delay the output a bit, but I included print statements to stderr inside the conduit, which aren't running either
13:19:14 <merijn> So the conduit is not running for some reason...
13:21:45 <EvanR> to preclude buffering as an explanation completely, instead of printing to stderr, throw an exception?
13:22:19 <merijn> Why would you expect that prints to stderr not happening aren't sufficient?
13:22:47 <EvanR> i always suspicious (nowadays) of "prints not happening"
13:22:49 <merijn> stderr is in default mode (line buffered) and I'm using putStrLn, so stderr prints
13:23:09 <merijn> EvanR: The conduit output is not "not printing", it's being written to a subprocess
13:23:27 <merijn> EvanR: So buffering is not relevant. It should be printing and then closing the stream
13:23:38 <merijn> But the receiving process is blocked indefinitely waiting for input
13:23:48 <EvanR> buffering exists for all fds
13:24:08 <glguy> stderr is default NoBuffering
13:24:14 <glguy> err, at least for Haskell/GHC
13:24:18 <merijn> That's irrelevant, the problem is the conduit is not finishing and thus not closing the output handle
13:24:24 <merijn> Buffering nevers stop writes from running
13:24:34 <merijn> It merely changes when they're observed
13:24:44 <merijn> But the writes aren't even finishing, that's the entire problem
13:24:48 <EvanR> and you observe it after hitting ctrl C !
13:32:17 <torstein> I have a function (Input -> Either Solution Input) and want to recurse it until a Solution is found. MonadFix mfix seems suitable for this. The docs say: "mfix f executes the action f only once, with the eventual output fed back as the input. Hence f should not be strict, for then mfix f would diverge." What does it mean? My function is strict but guaranteed to terminate
13:32:51 <merijn> torstein: mfix is *not* what you want
13:33:24 <merijn> torstein: mfix is for constructing IO actions that depend on their *own* result
13:34:41 <torstein> merijn: The function does depend on it's on result, in the sense that it's used the next iteration. Either does have a MonadFix instance. Why is it not applicable to my situation? (The function does not do IO)
13:35:02 <merijn> torstein: mfix has no next iteration
13:35:05 <sproingiesaur> fix itself won't terminate without laziness
13:35:21 <ReinH> @hackage monad-loops
13:35:22 <lambdabot> http://hackage.haskell.org/package/monad-loops
13:35:24 <merijn> torstein: It only runs once and the result of that run is being used as input to the function
13:35:29 <ReinH> torstein: Look in monad-loops
13:37:16 <merijn> EvanR: gah
13:37:22 <merijn> EvanR: Found the issue...
13:38:01 <merijn> EvanR: streaming-commons blocks until the child process exits
13:38:20 <ReinH> oh, I think that's just iterateM_.
13:38:36 <merijn> EvanR: So, if the child-process is blocked for input, the parent is blocked waiting for termination and you're not using the threaded runtime, guess what happens...
13:38:40 <monochrom> @type iterateM_
13:38:41 <lambdabot> error:
13:38:41 <lambdabot>     • Variable not in scope: iterateM_
13:38:42 <lambdabot>     • Perhaps you meant one of these:
13:38:47 <ReinH> iterateM_ f = g where g x = f x >>= g
13:40:05 <monochrom> Ah.
13:40:32 <ReinH> if f x produces a Left then it will terminate.
13:40:38 <monochrom> Yeah!
13:46:44 <glguy> osa1: Why did you need to set LIBRARY_PATH or LD_LIBRARY_PATH? How are you installing openssl?
13:47:44 <osa1> glguy: I have no idea. I installed it via brew.
13:47:51 <monochrom> Speaking of which there is a common misunderstanding that says "/usr/local/lib is not one of the defaults, you have to put it in LD_LIBRARY_PATH"
13:48:09 <osa1> osa1: brew put the include and lib dirs into non-standard locations
13:48:10 <glguy> osa1: Building with stack? cabal-install?
13:48:19 <osa1> glguy: stack
13:48:31 <monochrom> It is false. /usr/local/lib is totally one of the defaults. You just need to ldconfig. Even /lib needs you to run ldconfig.
13:48:47 <glguy> osa1: Are you setting the homebrew-openssl flag on HsOpenSSL?
13:48:49 <sproingiesaur> yes, you can globally add it.  probably should.
13:49:02 <sproingiesaur> OSX has no ldconfig
13:49:07 <osa1> glguy: I'm using the default setting
13:49:11 <sproingiesaur> nor do several other os's
13:49:18 <sproingiesaur> (with windows, it's just PATH)
13:49:23 <monochrom> To be sure, I'm only talking about Linux. I don't know Mac.
13:49:43 <glguy> osa1: If you turn on that flag then you shouldn't need to override anything else
13:50:13 <osa1> glguy: maybe readme should mention that
13:50:20 <sproingiesaur> managing libs on a mac is pretty similar, you just use .dylib instead of .so, otool -L instead of ldd, etc
13:50:40 <merijn> sproingiesaur: You can name you libraries .so just fine on OSX
13:51:13 <merijn> At least, my code works on my mac and I'm not using .dylib :p
13:51:13 <monochrom> What is the first "o" in "otool"?
13:51:18 <sproingiesaur> object
13:51:19 <merijn> monochrom: object
13:51:29 <monochrom> That's a bit bland. :)
13:51:32 <glguy> overruled
13:52:31 <EvanR> overtool
13:53:24 <monochrom> Oh wget can print headers (use -S). And all these years I thought it couldn't and I wrote my own Haskell program using HTTP-4000 to get headers.
13:54:28 <mauke> GET -e http://example.com
13:54:41 <mauke> (this assumes you have LWP installed)
13:56:04 <sproingiesaur> merijn: .so files are different things in osx, but there's some compatibility glue that makes them loadable as DLL's
13:56:10 <sproingiesaur> it's all pretty damn weird
13:56:57 <saml> is haskell good now?
13:57:02 <monochrom> Yes.
13:57:11 <merijn> Haskell has been good for ages :p
13:57:16 <sproingiesaur> no, it's evil
13:57:29 <saml> it was good for memory leak and slow programs
13:57:41 <sproingiesaur> i mean, the whole thing is designed around laziness.  sloth is one of the deadly sins.
13:57:53 <saml> installing ghc stuff has been changed? or still go through haskell platform?
13:58:02 <sproingiesaur> stack is popular
13:58:08 <saml> ah thanks
13:58:21 <sproingiesaur> haskell platform is handy for noodling around outside a project.  i have both.
13:58:31 <sproingiesaur> (haskell platform includes stack)
13:59:00 <merijn> I always just install GHC binary + cabal, but apparently I'm weird
13:59:24 <sproingiesaur> i fibbed a bit, i actually reverted to installing ghc from homebrew
13:59:35 <glguy> merijn: probably just less vocal
13:59:37 <saml> /topic links to https://downloads.haskell.org/   cool
13:59:46 <merijn> glguy: To busy actually doing stuff ;)
13:59:48 <sproingiesaur> other systems i just install the platform then use stack
14:00:43 <monochrom> Actually I will be just installing GHC binary + cabal too. I have been happy with Haskell Platform, but lately its out-of-the-box library docs have been unreliable.
14:01:27 <merijn> monochrom: Plus, GHC binaries + cabal is the most reliable way to install a user local version as unprivileged user
14:01:33 <sproingiesaur> i just use hackage for docs
14:01:58 <barcabuona> how to undo stack setup?
14:01:59 <monochrom> Ah hackage has its own doc unreliability!
14:02:00 <sproingiesaur> pretty much the same habit i had with perl, i just hit up cpan instead of perldoc
14:02:02 <barcabuona> i want to delete the extra ghc
14:02:07 <sproingiesaur> easier to browse to source with both
14:02:33 <monochrom> merijn, but I am installing a lot of --global libraries.
14:02:38 <sproingiesaur> barcabuona: "rm -rf ~/.stack" will nuke whatever stack installed
14:02:44 <saml> ./install-haskell-platform.sh
14:02:48 <saml> The directory / is not writable. Please run this script as root.
14:02:50 <saml> ugh
14:03:03 <sproingiesaur> haskell platform is an OS-level install
14:03:10 <sproingiesaur> typically you use your package manager
14:03:20 <saml> merijn, you don't use stack, i assume?
14:03:22 <monochrom> Basically if I switch from Platform to my own, I will be just mirroring a lot of Platform's.
14:03:53 <barcabuona> nice thanks. i guess i'll just reinstall what i need
14:03:56 <monochrom> "Reason" being when I backup my home directory I don't want to include the libraries.
14:04:23 <sproingiesaur> stack can install to an alternate root
14:04:28 <monochrom> So anyway the whole point is that I am even more weird :)
14:04:45 <sproingiesaur> that or just exempt the stack cache from your backups
14:05:00 <monochrom> Actually install-haskell-platform.sh has an option for home-directory install.
14:05:12 <sproingiesaur> at which point you may as well use stack
14:05:39 <sproingiesaur> the only real difference being your $PATH looks slightly uglier if you want a stack ghc to be "global"
14:06:27 <saml> fedora package for haskell platform is old
14:07:00 <barcabuona> did anyone check out luna btw?
14:07:12 <sproingiesaur> saml: is there a copr repo you can add to get a newer platform?
14:07:15 <barcabuona> it looks like they might have implicit parallelism AND dependent types
14:07:15 <monochrom> Right, basically if your linux distro isn't arch or gentoo, don't bother with your distro's.
14:07:25 <barcabuona> depndent types are coming to ghc anyway right?
14:07:34 <monochrom> And if it's Ubuntu, use hvr's PPA instead of Ubuntu's.
14:07:35 <cocreature> barcabuona: you can’t really check it out, can you? they haven’t yet released anything
14:07:46 <barcabuona> that part about automated concurrency is something i really wanted to work on myself and i was very surprised
14:07:52 <sproingiesaur> barcabuona: yes, dependent haskell is one guy's project
14:07:53 <saml> there could be. i'll install manually. install-haskell-platform.sh is simple. just decompresses a file and executes a script
14:07:53 <geekosaur> barcabuona, eventually. they're a long way away
14:07:57 <barcabuona> cocreature: no but supposing it's not a big lie
14:08:03 <sproingiesaur> said project does have an alarmingly high Bus Factor
14:08:44 <monochrom> Dependent typing is not going to buy you automatic concurrency (or automatic parallelization, or automatic distributed computer, or automatic cloud, or automatic ocean, or automatic hot-word-of-the-day)
14:08:51 <cocreature> barcabuona: I’ll wait until I have something that I can play around with before I get my hopes up :)
14:09:25 <sproingiesaur> hopefully it'll buy you some degree of automatic code generation
14:09:31 <barcabuona> yeah for sure. but just even stating you have automated parallelism...damn
14:09:31 <saml> tar xvzf hp-usr-local.tar.gz && usr/local/haskell/ghc-8.0.2-x86_64/bin/activate-hs --prefix "$HOME/yolo"
14:10:08 <monochrom> But no one is really contemplating automatic parallelization for GHC.
14:10:32 <sproingiesaur> laziness interferes somewhat, doesn't it?
14:10:41 <systemfault> I started reading the Idris TDD book and I found it really cool to develop using type holes/case split/search, does Haskell with GHC has something like that? (I know ghc has type hole but I don't know if they're the same thing)
14:10:44 <monochrom> My friend did a master thesis on automatic parallelization for Java. Even got a paper award in a conference for it. The conclusion is "overhead outweights savings".
14:10:52 <barcabuona> monochrom: i know. i'd like to try it in the future though, when i want to play around
14:11:07 <Eduard_Munteanu> Isn't DPH in the realm of automatic parallelization?
14:11:13 <sproingiesaur> ghc has type holes, and it's largely the IDE support that's holding it back
14:11:20 <sproingiesaur> Eduard_Munteanu: FSVO "automatic"
14:11:35 <glguy> *typed* holes
14:12:09 <monochrom> YES! Start with "main = _ :: _" for maximum automatic computer-guided programming!
14:12:17 <sproingiesaur> i think the main thing is idris has more machine-readable feedback in its REPL than ghc
14:12:27 <monochrom> (It will even tell you which extensions you need to add!)
14:12:46 <sproingiesaur> intero has to take apart arbitrary error messages, and it's not taking heroic effort to do it
14:12:48 <MP2E> typed holes in GHC are fantastic, and something I didn't even know were a thing until a few weeks ago heh
14:12:58 <MP2E> don't know how i lived without them
14:13:12 <sproingiesaur> intero is very good about taking suggestions about extensions tho
14:13:15 <monochrom> I lived without them by doing my own type inference.
14:13:43 <sproingiesaur> unfortunately that's the only thing intero does when it hits a hole, is suggest PartialTypeSignatures
14:13:51 <monochrom> I support making error messages more machine readable.
14:14:01 <sproingiesaur> monochrom: every python programmer does type inference in their head
14:14:13 <sproingiesaur> (to the expected result)
14:14:27 <monochrom> No wonder I'm such a good Python program reader without learning Python.
14:14:29 <cocreature> when you’re using a typed hole it’s actually sending a request to monochrom who infers the type and sends the result back
14:14:36 <MP2E> haha
14:14:37 <monochrom> Haha
14:14:42 <barcabuona> i also tried the idris repl and found it to be nicer (like the default typing shown by ocaml)
14:14:44 <sproingiesaur> (s/python/DuckTypedBlub/)
14:14:56 <saml> yeah haskell platform things are all hardcoded. prefix cannot be specified.  ghci is a script exec "/usr/local/haskell/ghc-8.0.2-x86_64/bin/ghc-8.0.2" --interactive "$@"
14:14:59 <barcabuona> and also i think the syntax is slightly improved in some places compared to haskell but not much
14:15:13 <barcabuona> i find too many symbols in haskell but ok it's not c++ 
14:15:15 <sproingiesaur> cocreature: ah, i see oleg has delegated somewhat ;)
14:15:43 <EvanR> idris doesnt have the symbols because it has almost no code written in it
14:15:45 <cocreature> sproingiesaur: I think he’s mostly responsible for the typed holes in ocaml (I have no idea if they have those) these days
14:15:47 <barcabuona> what i'd like is if people got together and made a parametric backend and languages could just evolve based on syntax
14:15:58 <EvanR> (symbols are products of library not the language)
14:16:03 <monochrom> Ah maybe that's why some of my Platform haddock links are broken. I put it in /usr/local/haskell/ghc-8.0.2...
14:16:27 <sproingiesaur> the running gag for a while was for some ghc extension, it just IM'd your code to oleg
14:16:29 <systemfault> So, there's no way "today" to have a similar experience with ghc but it's only due to IDE support, not really GHC
14:16:39 <EvanR> barcabuona: i know, coffee-skell, the same thing as haskell but a syntax skin
14:17:21 <sproingiesaur> i love alternate syntaxes.  until i get error messages that don't understand the syntax.
14:17:23 <Eduard_Munteanu> I would like to see languages defined by abstract syntax rather than concrete syntax.
14:18:12 <Eduard_Munteanu> We're still stuck with the assumption that a text editor is all we've got.
14:18:16 <sproingiesaur> i'd rather see them defined by semantics, and use whatever bloody syntax you like that fits
14:18:31 <sproingiesaur> making a syntax fit is non-trivial, to be sure
14:19:06 <zomg> EvanR: btw I was looking at the extensible record stuff you suggested... Is it just the odd syntax that makes it look complicated or is it actually kind of complicated? :D
14:19:09 <sproingiesaur> basically the promise of intentional programming
14:19:18 <barcabuona> EvanR: that returns nothing
14:19:45 <sproingiesaur> stuff like what idris is doing is a sorta step toward IP
14:20:04 <barcabuona> sproingiesaur: that's exactly what i meant
14:20:10 <bollu> sproingiesaur what's intentional programming?
14:20:41 <sproingiesaur> bollu: hard to describe, and the original paper is pretty vague too.  lemme try and dig it up
14:20:48 <sproingiesaur> or just google simonyi intentional programming
14:20:59 <btorf> Why does `() {}` work and evaluate to `()`, same for `Foo {}` -> `Foo` (where `data Foo = Foo | Bar`)? If this all works why does `12 {}` not?
14:21:06 <sproingiesaur> he didn't really have type systems in mind, but they seem to be a means to that end
14:21:26 <monochrom> btorf, () and Foo are data constructors, 12 is not.
14:21:50 <sproingiesaur> isn't it a constructor for Nat? ;)
14:22:03 <glguy> Not, it is an integer literal
14:22:06 <glguy> no*,
14:22:06 <monochrom> Similarly you will find that True{} is OK but 'x'{} is not.
14:22:44 <bollu> also, is the crrent STG output formalised somewhere?
14:23:11 <btorf> monochrom: Cheers! 
14:23:26 <monochrom> But there is something I'm wondering about.
14:23:33 <monochrom> > "hello"{}
14:23:35 <lambdabot>  error: Empty record update
14:23:37 <Eduard_Munteanu> > 12 {}
14:23:39 <lambdabot>  error: Empty record update
14:23:55 <monochrom> > True{}
14:23:57 <lambdabot>  True
14:24:02 <btorf> []{}
14:24:06 <monochrom> That is a strange message.
14:24:06 <bollu> monochrom o_O
14:24:13 <glguy> When you use a non-constructor expression, in Haskell that means you're doing a record update
14:24:16 <bollu> > [True, True] {}
14:24:18 <lambdabot>  error: Empty record update
14:24:21 <glguy> but you must specify at least one field to do a record update
14:24:34 <monochrom> Ah!
14:24:39 <sproingiesaur> bollu: the standard is the source.  most things desugar to Core, which is an implementation of System FC
14:24:42 <bollu> glguy why does True {} work? ah, because you're saying you're constring true with no parameters?
14:24:55 <bollu> sproingiesaur :( I wanted a spec of the STG *output* format at least
14:24:56 <sproingiesaur> s/most things/all the things/
14:25:00 <Eduard_Munteanu> Because it's record creation.
14:25:04 <bollu> sproingiesaur well, ty
14:25:08 <monochrom> Right, True{} is not update (it's creation), <expr>{} is an update (even if expr evaluates to True)
14:25:10 <Eduard_Munteanu> > (True) {}
14:25:12 <lambdabot>  error: Empty record update
14:25:15 <bollu> ah, interesting
14:25:15 <glguy> Yes, when you use a constructor then it's not an "update" , its just a new value
14:25:35 <bollu> > mempty {}
14:25:37 <lambdabot>  error: Empty record update
14:25:39 <glguy> Eduard_Munteanu: Good example
14:25:39 <bollu> hmm
14:25:47 <bollu> > #1 {}
14:25:49 <lambdabot>  <hint>:0:2: error: lexical error at character '}'
14:25:51 <bollu> > 1# {}
14:25:53 <lambdabot>  error: Empty record update
14:26:00 <bollu> that's weird, no?
14:26:08 <bollu> I would expect a prim int to be "constructed"
14:26:10 <glguy> bollu: No, that's what we've been talking about
14:26:15 <sproingiesaur> prims have no box
14:26:16 <glguy> 1# isn't a constructor
14:26:19 <bollu> ah
14:26:19 <monochrom> > Let x = (:){} in ()
14:26:22 <lambdabot>  <hint>:1:7: error:
14:26:22 <lambdabot>      parse error on input ‘=’
14:26:22 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:26:26 <monochrom> > let x = (:){} in ()
14:26:28 <lambdabot>  ()
14:26:31 <monochrom> \∩/
14:26:42 <bollu> lol, nice
14:27:02 <glguy> > (:){}
14:27:04 <lambdabot>  [*Exception: <interactive>:3:1-5: Missing field in record construction
14:27:08 <sproingiesaur> it could auto-box it i suppose, but the express intent is not to
14:27:36 <bollu> > (,) {}
14:27:38 <lambdabot>  (*Exception: <interactive>:3:1-6: Missing field in record construction
14:27:56 <monochrom> Well "1#{}" is legal or illegal based on syntactic restrictions and "did anyone think of it before?" rather than semantics.
14:28:37 <sproingiesaur> you see # and you're talking implementation-level stuff
14:28:40 <monochrom> Afterall "True{}" vs "(True){}" is also purely syntactic (and possibly dumb but what can you do to a standard document no one wants to change now)
14:29:15 <btorf> What's 1#?
14:29:35 <glguy> An unboxed integer literal
14:29:52 <sproingiesaur> enabled with my favorite extension name, MagicHash
14:30:17 <btorf> Wtf, never heard of both of them 
14:30:18 * sproingiesaur packs some MagicHash into the bowl
14:32:13 <NemesisD> monochrom: i figured out my weird STM issue. you will not be surprised to learn it was my fault (though indirectly), it was unsafePerformIO and I got what I deserved
14:32:26 <monochrom> Oh!
14:33:09 <monochrom> So some library does an "unsafePerformIO (atomically ...)" behind your back?
14:33:19 <sproingiesaur> ouch
14:33:30 <NemesisD> a library was using unsafePerformIO, its a library I had a hand in though I didn't write that code directly. I should probably eliminate the function involved as it is not really a good idea to use
14:34:30 <NemesisD> monochrom: the library itself uses STM internally, i think with a TBQueue or something, so evaluating that int probably forced part of the larger data structure and triggered the STM action inside of atomically
14:34:34 <sproingiesaur> unsafeFoo eventually earns its prefix
14:36:01 <monochrom> sproingiesaur: I forgot whether you saw NemesisD's problem. But it's basically "atomically (f n)" vs "atomically (f $! n)", n :: Int, why does one of them cause "you're nesting atomically"?
14:36:34 <saml> oh man haskell installation is crazy. libtinfo.so.5 can't find this.   i'll use older version supplied by fedora
14:36:53 <sproingiesaur> yah i saw the conversation, i thought it was maybe the whole computation that was lazy then being forced somewhere inside an atomic block
14:37:11 <sproingiesaur> but then the point of IO is that kind of thing shouldn't happen
14:37:30 <monochrom> saml: cabal hell and stack hell aside, I do think that Fedora adds its share of craziness.
14:37:32 <sproingiesaur> suggests to me there need to be better error messages
14:37:48 <saml> maybe there's a docker image for haskell development?
14:37:48 <sproingiesaur> like oh, WHERE the nested atomic is
14:37:58 <saml> docker run haskell-yolo -v ...
14:38:34 <saml> let's fix haskell installation problem.  ideally just unzip and add to PATH and bam it works
14:38:46 <saml> can ghc stuff be all statically linked?
14:38:57 <sproingiesaur> saml: other than having to run a little fixup script, that does work
14:39:11 <sproingiesaur> that's how i used to install ghc
14:39:15 <monochrom> GHC itself already satisfies that property.
14:39:19 <saml> yup
14:39:27 <saml> but do i need platform?
14:39:33 <sproingiesaur> that little fixup should have been unnecessary, it should just have done it on first run
14:39:37 <monochrom> But you are just not going to be satisfied with just having GHC.
14:39:56 <sproingiesaur> if i ran the zoo that's how i would have done it, but when i was a build manager i let my OCD freak flag fly
14:39:58 <saml> i guess i can install ghc.  then cabal (hope that cabal install is easy).  and with cabal, I can install stack and all utils easy?
14:40:32 <sproingiesaur> nowadays i don't really care how a raw install goes, package managers fix that, and outside of the package system there's stack
14:40:56 <monochrom> This is why I sometimes say "go back to Hugs". Because it's like Python. Interpreter. Going back to interpreter solves 90% of DLL hell because there is no DLL, no compilation. You always just re-interpret the libraries again. No ABI trouble because there is no ABI.
14:41:02 <sproingiesaur> not my circus anymore, ergo not my monkeys :)
14:41:05 <Denommus> hello
14:41:22 <sproingiesaur> i remember when hugs had nicer error messages
14:41:27 <monochrom> See also http://www.vex.net/~trebla/humour/tautologies.html #1
14:42:32 <monochrom> Anyway I have this beef because people are naïve like "Python doesn't have your installation problem!" Excuse me do you recall that Python (at least the popular implementation) is interpreted?
14:42:57 <Rembane> Python is trluy nasty when it comes to packaging.
14:43:28 <glguy> monochrom: The only other time that phrase was uttered in #haskell was: 23:05:14 * quchen is puzzled by how the introduction of new language extensions makes people go back to Hugs
14:43:29 <sproingiesaur> it has a mix of good and bad for sure
14:43:40 <sproingiesaur> perl has a pretty similar WTF ratio
14:43:50 <ElyKar[m]> It's improving though
14:43:52 <glguy> 2016/16.03.31
14:44:00 <ElyKar[m]> (Python packaging)
14:44:21 <sproingiesaur> eggs were a good attempt
14:44:24 <monochrom> Haha, that's another data point for my belief that programmers are control freaks.
14:44:25 <sproingiesaur> wheels are better
14:44:49 <ElyKar[m]> This is a landmine for beginners
14:45:02 <barcabuona> i get some errors with stack sanity check https://ptpb.pw/ixZS
14:45:08 <sproingiesaur> ghc is about to hit a pretty big shift in that area too what with Backpack
14:45:16 <monochrom> Extensions cause people to go back to Hugs because it is not enough that oneself turns off the extensions. Oneself must also force other people to turn off the extensions.
14:45:41 <sproingiesaur> gonna be chaos for a while when ghc 8.2 lands
14:46:46 <sproingiesaur> that or hackage 2 will release at the same time and all will be fine
14:46:58 <monochrom> Haha don't be so optimistic.
14:47:31 <monochrom> If both GHC 8.2 and Hackage 2 happen at the same time, rest assured that it's worst of both worlds.
14:47:32 <sproingiesaur> i haven't been optimistic since Nov 8
14:48:24 <sproingiesaur> ideally hackage 2 is testing with 8.2 already
14:48:42 <monochrom> OK, if they do that, that's better.
14:49:41 <sproingiesaur> package ecosystems are strange things
14:49:50 * monochrom moans that the good old days of "Dijkstra writes the OS, a colleague builds the hardware, then they get together and it just works"
14:50:00 <monochrom> ... have long gone
14:50:04 <sproingiesaur> monochrom: "it just works" was a rare result
14:50:15 <monochrom> err, s/moans/mourns/ !
14:50:35 <sproingiesaur> not to mention the barrier to entry
14:50:37 <monochrom> Yeah, but Dijkstra had his secret of success.
14:51:07 <monochrom> He and the other guy seriously sat down and nailed the interface specification precisely. No misunderstanding whatsoever.
14:51:13 <sproingiesaur> yeah he was edsger friggin dijkstra
14:51:20 <sproingiesaur> that helped too
14:51:50 <sproingiesaur> but how many production apps got written in algol-60?
14:52:07 <sproingiesaur> it helped later efforts, sure
14:53:04 <EvanR> algol-60 succeeded at not become unfortunately immortal like cobol
14:53:14 <sproingiesaur> "avoid success"
14:53:22 <monochrom> Heh, I guess that's a plus.
14:53:25 <davr0s> haskell is so much easier to understand after using rust
14:53:59 <EvanR> there should be a "programmed cell death" of programming languages
14:54:19 <MP2E> funnily enough, I had the opposite experience, I tried to learn rust back in 2013 when I only had experience with C/C++, and ended up jumping to Haskell. Now, checking out rust again, I find it much easier
14:54:20 <monochrom> Yeah. I thought programmed human death would do that.
14:54:23 <MP2E> I might just be weird though
14:54:27 <sproingiesaur> haskell is doing much the same in the space of laziness.  it's changed a lot of thinking, but not entirely to the side of totally pervasive laziness
14:54:28 <EvanR> haskell will self destruct around 2029 forcing people to redesign a new language better than the last one
14:54:32 <davr0s> MP2E yeah tahts weird :)
14:54:43 <MP2E> hehe :P
14:54:45 <sproingiesaur> come to think didn't algol-60 introduce call-by-name?
14:55:00 <davr0s> originally looking at Haskell, i remember all the discussions.. trying to ask 'what is a monad' and seeing all sorts of convoluted explanations
14:55:02 <monochrom> You need to be more pessimistic. Even Y2K did not kill COBOL.
14:55:27 <davr0s> once one has seen 'Option<T>   or an equivalent thing in c++, it is so much clearer.
14:55:28 <sproingiesaur> i started learning haskell sometime around 2000
14:55:30 <monochrom> And Y2K was already as close to COBOL-self-destruct as you could get.
14:55:39 <sproingiesaur> i slogged through *every* monad tutorial
14:55:54 <davr0s> dammit if you had 'haskell for C++ tutorials' i could have had several years of using haskell by now
14:56:03 <davr0s> "haskell explained in C++ user terms"
14:56:12 <monochrom> sproingiesaur, I'm wonder if it was 60 or it was the more ambitious 68.
14:56:18 <sproingiesaur> i was a fairly early adopter of C++ too, at least as programming on the PC went
14:56:39 <sproingiesaur> it was terrible.  there weren't even templates in my first compiler, just some macros that sorta simulated them
14:56:43 <davr0s> what I seemed to see when I originally looked into haskell was mutually hostile priestly cults
14:56:46 <monochrom> Hrm maybe it was 60 afterall because that's what Landin was doing with call-by-name.
14:56:48 <EvanR> yeah i pretty clearly remember looking at monads first on wikipedia, they were defined as "a way to do imperative programming, but making new monads is very hard"
14:57:00 <EvanR> every tutorial after that was like, worse
14:57:03 <davr0s> as such eacho community was more keen to explain why the other language cannot expres their concepts
14:57:26 <davr0s> "a monad is a programmable semicolon"
14:57:27 <sproingiesaur> monochrom: yah landin was on the algol-60 committee, no?
14:57:35 <MP2E> I picked up monads after studying a lot of different tutorials/resources and just playing around in ghci. but as per the curse, the moment I learned, I was unable to explain to a colleague adequately what they are
14:57:40 <MP2E> well, in a way he understood
14:57:51 <MP2E> haha
14:57:52 <EvanR> i figured out how to use monads by just trying it
14:57:58 <davr0s> i like the idea that rust can be a gateway drug to haskell 
14:57:59 <EvanR> but still i never really "got" monads
14:57:59 <sproingiesaur> monochrom: oh reading his bio on WP, he was just an early adopter
14:58:01 <monochrom> I believe that a "Haskell in C++ terms" is mostly in negation form, i.e., "you know this C++ idea? Haskell does not do things this way".
14:58:19 <davr0s> monochrom thats it though, thats what made it hard to lern
14:58:20 <EvanR> haskell is subtractive synthesis
14:58:21 <monochrom> E.g., "you know functions in C++? Haskell functions are almost unrelated"
14:58:26 <davr0s> learn^
14:58:29 <sproingiesaur> monochrom: that's a little ingenerous.  instance selection works a lot like template instantiation
14:58:35 <davr0s> monochrom instead of saying that .. you could have shown "this is what Maybe would look like in C++."
14:59:00 <sproingiesaur> davr0s: actually, just point at std::option in C++17
14:59:07 <EvanR> when i relearn C++, i will be expecting C++ programmers to explain the concepts to me in haskell terms
14:59:08 <davr0s> now that can be done, yes :)
14:59:16 <johnw> "What then is a monad? If no one asks me, I know what it is. If I wish to explain it to him who asks, I do not know."
14:59:16 <monochrom> You will need a C++ (or just C) tagged union for Maybe.
14:59:22 <sproingiesaur> davr0s: then point them to how option implements various concepts like Monoid and Monad
14:59:34 <davr0s> you can implement the tagged union manually, or just use a bool
14:59:35 <monochrom> haha johnw
14:59:46 <sproingiesaur> (actually i dunno if there's a proper Monad concept yet, there's definitely Functor tho)
15:00:01 <EvanR> davr0s: right, thats pretty bad. theres a good video on sums in clojure that highlights why
15:00:13 <MarcelineVQ> there's something called functor, idk if it's related
15:00:22 <rullie> yea, a monad is a functor
15:00:30 <monochrom> Have you taught numbers to kids? It's exactly the same deal as teaching monads to adults.
15:00:32 <davr0s> even laziness of sorts can be done in C++ with expression templates
15:00:43 <sproingiesaur> no, not <functional> functors, tho it'd be awesome if those implemented Functor too
15:00:47 <davr0s> i didn't even know C++ does actually have 'template template parameters'
15:00:53 <monochrom> If a kid asks "what does 3 mean, really?" what are you going to do?
15:01:18 <EvanR> ill ask him to choose a semantic domain
15:01:22 <sproingiesaur> c++ templates are pretty much how modern c++ is structured.  inheritance is pretty much optional
15:01:31 <monochrom> (And whatever you do, why is the kid happy with your answer?)
15:01:36 <davr0s> indeed,
15:01:36 <EvanR> then provide a faithful functor from syntax to semantics
15:02:05 <EvanR> when he complains, give him some isomorphism theorems
15:02:19 <sproingiesaur> if a kid asks me what 3 means, i'll hold up three fingers
15:02:30 <EvanR> you did it!
15:02:38 <johnw> it's a symbol that means "one more than 2"
15:02:41 <MP2E> that's just an instance of 3 though ;)
15:02:48 <johnw> then we can proceed by induction to reach zero
15:02:52 <EvanR> faithful functor from numerals to fingers
15:02:59 <monochrom> See, that's adequate for most kids because they don't overthink it.
15:03:29 <monochrom> Pretty much only adults will say "that is fingers not 3 itself".
15:03:47 <sproingiesaur> most kids understand "one more"
15:04:01 <sproingiesaur> grokking zero is a more recent thing
15:04:20 <sproingiesaur> our brains seem to be 1-based
15:04:37 <johnw> it's hard to think about nothing
15:04:43 <EvanR> unless you were born with zero fingers
15:04:54 <sproingiesaur> tell me about it, i was a zen buddhist for 20 years
15:05:00 <johnw> I can see when I have an apply in the pantry. I have to think to see zero apples in it.
15:05:30 <monochrom> So basically adults with monad are too demanding and too overthinking and seek the unanswerable "what does >>= mean, really?" and not settle with 5 examples of []'s >>=, Maybe's >>=, Either's >>=, etc.
15:05:34 <EvanR> how exactly did subtraction work without zero, i suspect a gross simplification of mathematical history
15:05:49 <sproingiesaur> i have zero lamborghinis in my driveway
15:05:56 <davr0s> how does 'idris' compare wth haskell.
15:05:59 <sproingiesaur> and zero supermodels in my bed
15:06:03 <monochrom> Whereas kids are OK with having seen a few fingers, then a few apples, then a few coins.
15:06:44 <sproingiesaur> one at least lets you start with something
15:06:51 <EvanR> so adults are prone to abstract thinking
15:06:57 <EvanR> luckily
15:07:12 <monochrom> No.
15:07:13 <johnw> sometimes I've even thought that wisdom consists in how many zeroes you're able to see
15:07:13 <sproingiesaur> that's our brains' biggest feature
15:07:23 <sproingiesaur> johnw: mu
15:07:41 <sproingiesaur> (little zen joke)
15:07:49 <johnw> I get the joke :)
15:07:55 <monochrom> Adults ask that ought-to-be-abstract question "what does >>= mean, really?" But they are not going to accept an abstract answer such as "it just has to satisfy two laws".
15:08:18 <davr0s> now i am undecided.. do i continue getting into rust, or diverge.. stick with familiarity of C++ and get more into haskell for 'something different'.
15:08:23 <monochrom> So don't kid me, adults can't think abstractly. Instead, kids fare so much better.
15:08:36 <johnw> monochrom: because they don't want to know what it means; they want it to be _meaningful to them_ 
15:08:56 <davr0s> or is haskell on the way out because the mainstream languages picked up it's best ideas already
15:09:09 <EvanR> they didnt
15:09:15 <EvanR> so many are missing still
15:09:15 <johnw> davr0s: I would not say it's on the way out at all
15:09:20 <sproingiesaur> haskell is always on the way *in*.  it just hopes to not arrive.
15:09:37 <johnw> it remains an ongoing experiment in lazy evaluation
15:11:35 <sproingiesaur> indeed.  Core is also turning out to be a nice IL
15:11:58 <maerwald> davr0s: I agree on that, there are better languages that picked up haskell ideas, but they don't have such a big ecosystem like haskell
15:12:04 <sproingiesaur> lots of experimentation in compiler tech.  which is ironic since ghc itself is horribly monolithic
15:12:24 <barcabuona> how can i ghc-pkg unregister all packages?
15:12:40 <barcabuona> it's giving me issues with the system package manager. unregistering would break the following dependency...
15:12:41 <EvanR> type checker plugins
15:12:53 <sproingiesaur> barcabuona: this is sort of why stack exists
15:12:59 <EvanR> hackable backends
15:13:19 <sproingiesaur> package-wise, stack starts from scratch with every project.  it just caches installs.
15:13:22 <sproingiesaur> sorta like npm
15:14:22 <sproingiesaur> i watched SPJ's talk "Into the Core" and i was pretty dazzled
15:14:25 <barcabuona> yeah but i have many packages installed with the system and ghc-pkg has issues registering them or something when i update. if i remove everything then it won't unregister. if i force unregister everything and then reinstall itll probably fix it
15:14:30 <sproingiesaur> weirdly he was presenting it to an Erlang conference
15:14:49 <lambdamu> barcabuona: something like: ghc-pkg list | xargs ghc-pkg -f unregister
15:14:50 <sproingiesaur> but erlangers do appreciate a clever virtual machine
15:15:13 <EvanR> i can totally see each erlang process chewing through a core expression pausing to execute free monad commands
15:15:34 <sproingiesaur> i *really* need to learn free monads sometime
15:16:33 <sproingiesaur> the "free" comes from the monad instance resulting from some kind of free theorem from functors, right?
15:16:34 <sm> https://gist.github.com/timmytofu/7417408
15:16:41 <EvanR> cool thing about core, among others ,is its well typed
15:16:43 <sm> (barcabuona)
15:17:03 <monochrom> sproingiesaur: No, it's the "left adjoint of a forgetful functor" kind of free.
15:17:30 <sproingiesaur> monochrom: i understood "of", "a", and "functor"
15:17:52 <EvanR> adjoints is another thing like monads
15:17:58 <EvanR> super abstract
15:17:58 <sproingiesaur> and i have a very vague recollection of forgetful functors.  somewhere where my monad knowledge was in 2001
15:18:12 <monochrom> In terms I understand, it's the "two different expressions are unlikely to be equal" kind of free.
15:18:32 <EvanR> huh
15:19:02 <monochrom> What do I mean? Suppose I'm looking at monoids, and I'm looking at the example of Bool with &&.
15:19:45 <monochrom> "False" is a different expression from "False && False", but we call them equal. We have an extra simplification rule, not already in the monoid axioms.
15:20:17 <EvanR> ah
15:20:49 <monochrom> And then I look at lists/sequences with ++.  "[1]" is a different expression from "[1]++[1]", and we don't call them equal.
15:21:22 <monochrom> So list/sequences with ++ is what we call "free monoid". I.e., apart from the axioms, you can't do further, extra simplifications.
15:21:37 <EvanR> the free thing over a thing is the raw language of the thing, no additional optional details
15:22:31 <monochrom> So a free monad is when you define, say, "data X a = Pure a | Get (Int -> X a) | Put Int (X a)".
15:23:08 <sproingiesaur> False && False evaluates to False, which suggests a pretty strong equality to me
15:23:22 <EvanR> Bool && isnt the free monoid
15:23:30 <monochrom> At this point, "Get (\n -> Pure n)" is a different expression from "Get (\n -> Get (\m -> Pure m))". And up to now, we also declare them not-equal.
15:23:49 <monochrom> So my X is a free monad.
15:24:00 <sproingiesaur> "the free thing over a thing is the raw language of the thing"
15:24:08 <sproingiesaur> koans indeed
15:24:16 <monochrom> But you know what? The most useful thing we do to a free monad like X is to kill its free-ness.
15:24:28 <EvanR> they usually come with an "over a thing" in haskell but its not a requirement
15:24:50 <Unicorn_Princess> I have the filtering exercise of the Applicative.hs segment of the data61 course working, but if I add (some) type signatures, it refuses to compile: http://lpaste.net/356426 can someone explain what the error message is trying to say?
15:24:58 <EvanR> free monoid over an alphabet, free monad over a functor
15:24:59 <monochrom> I'm going to write an interpreter for my X. It is going to do what a state monad does. (My "Get" and "Put" names are suggestive.)
15:24:59 <johnw> freeness is "structure alone", no meaning, no interpretation.  The free monad is exactly expressive enough to reflect the use of return and bind, but nothing else, such as what return or bind might mean. It leaves that interpretation up to an evaluation of the structure at a later point in time.
15:25:32 <monochrom> And my interpreter is going to behave the same way whether you give it "Get (\n -> Pure n)" or "Get (\n -> Get (\m -> Pure m))".
15:26:19 <monochrom> My interpreter killed the free monad. Now it has introduced an equivalence relation and uses it for a new equality (behaviorial/observational equality)
15:26:49 <EvanR> my interpreter dequeued 2 bytes instead of 1
15:26:58 <lambdamu> 50 modules / 30s compilation / 55s linking
15:27:01 <lambdamu> This sucks
15:27:16 <johnw> lambdamu: how big is that link line?
15:27:39 <sproingiesaur> i'm having a hard time thinking of what return or bind might mean outside of any implementation
15:28:02 <sproingiesaur> it was trying to give them concrete meaning in the first place that gave me so many headaches with monads
15:28:07 <EvanR> its some data structure
15:28:44 <johnw> sproingiesaur: yeah, with any implementation, think data constructor
15:28:59 <sproingiesaur> sure the abstract meaning, like return :: a -> m a
15:29:04 <lambdamu> johnw: ~400 -l flags, that what you mean right?
15:29:04 <johnw> data Free f a = Return a | Bind ...
15:29:20 <johnw> lambdamu: ah, yes; are you using a traditional hard drive, or an SSD?
15:29:24 <sproingiesaur> so it's lifting it to the type level
15:29:40 <lambdamu> johnw: ssd
15:29:57 <johnw> sproingiesaur: it's reifying the structure of the monad
15:30:07 <sproingiesaur> yah, better wording
15:30:13 <lambdamu> johnw: I'm currently trying to switch to gold or maybe even lld
15:30:37 <lambdamu> johnw: but I'm surprised that it is so bad, the  project isn't really that big
15:30:40 <johnw> data constructors are just how we do this in the type theory we have available
15:30:41 <sproingiesaur> ok, i'm thinking if i were writing my own do-notation desugaring thing i would represent it a bit like that
15:30:48 <sproingiesaur> am i on the right track?
15:30:52 <barcabuona> sm: thanks. that worked but didn't help in the end. i actually got 4x as many errors when reinstalling hte packages XD
15:31:01 <johnw> sproingiesaur: that's a good example, actually
15:31:16 <johnw> sproingiesaur: if you were doing do-notation desugaring, you'd want to work with monads in a way that does nothing to affect what they mean in any context
15:31:26 <sproingiesaur> i.e. generically?
15:31:29 <johnw> yes
15:31:42 <sproingiesaur> makes sense so far
15:32:13 <johnw> in reality you'd proabably not need to reify the expression in order to desugar, but if you were writing a runtime syntax analyzer, you might
15:32:14 <EvanR> many structures only have 1 valid monad instance, but when they get complex, like DSL APIs, you could have amny
15:32:37 <EvanR> but the syntax of your programs is the same
15:32:40 <lambdamu> johnw: it's just ~100 lines emacs lied to me
15:32:59 <johnw> lambdamu: still, you have the IOPS, I wonder where all that time is being lost
15:33:14 <johnw> is the linker doing actual work, or are you blocking on I/O somewhere
15:33:27 <monochrom> Yeah, I spoke like I'm going to write an interpreter to kill the freeness. But the biggest deal is you can write several different interpreters.
15:33:42 <johnw> one for every possible monad instance, in fact :)
15:33:50 <sproingie> what is it with ghc that makes linking so crazy slow?
15:34:02 <EvanR> slow linkers
15:34:04 <lambdamu> johnw: I'm gonna find out but I suspect it is really just ld
15:34:05 <EvanR> GNU ld
15:34:14 <johnw> sproingie: split objects can really slow things down, but that's not the default
15:34:22 <johnw> https://stackoverflow.com/questions/6952396/why-does-ghc-take-so-long-to-link
15:34:26 <sproingie> even so, link speed is extraordinarily slow in ghc
15:34:39 <monochrom> GNU ld uses a quadratic-time algorithm (I think?), and GHC is generating above-average input sizes.
15:34:46 <sproingie> does it just create a shedload of separate .o files?
15:34:56 <sproingie> or just a few very large ones?
15:34:58 <johnw> snoyberg recommends gold; if he's using it, I'd give it a try
15:35:03 <EvanR> lots of symbols
15:35:06 <monochrom> No, but each *.o file has a shitload of symbols.
15:35:29 <EvanR> ld not only is slow, it uses helluva memory
15:35:31 <sproingie> are they all actually necessary, or are there a bunch of intermediates?
15:35:31 <johnw> yeah, Haskell files generate tons of symbols
15:35:41 <johnw> most of which are not exported from the module
15:35:44 <pikajude> yeah
15:35:49 <pikajude> lots of variables specific to closures
15:36:17 <monochrom> You need more symbols because lazy evaluation causes more control-flow points.
15:36:41 <lambdamu> johnw: so IO is not the problem
15:36:49 <EvanR> still... if most symbosl arent exported...
15:36:58 <EvanR> then *linking* seems like it shouldnt care
15:37:13 <EvanR> or is it cross module compilation
15:37:17 <sproingie> yeah does sound like there's symbols being generated that needn't
15:37:26 <monochrom> Yeah gold uses a lower-big-O algorithm.
15:37:44 <sproingie> gold sounds nice, but it's elf-only
15:37:50 <monochrom> Ah.
15:38:00 <EvanR> surely theres a way to tell the linker, in the object, that these symbols are internal ?
15:38:06 <EvanR> or are they not really internal
15:38:08 <sproingie> yeah, you don't export them
15:38:18 <monochrom> This is why the typical Windows-10-compatible PC comes with at least 8GB of RAM. :)
15:38:39 <monochrom> And the Macbook Pros give you even more.
15:38:56 <sproingie> it comes with that much ram because people want to switch between a netflix stream and facebook instantly
15:39:06 <monochrom> Because they know you're doing Haskell projects!
15:39:48 <EvanR> haskell on arduino 
15:40:03 <EvanR> haskell on a single flip flop
15:40:08 <sproingie> phones are designed around slightly more mono-tasking workflows
15:40:36 <sproingie> with "phone call" being largely an entirely different subsystem
15:44:50 <jakehehrlich> Is there something faster than integer-simple that doesn't use gmp or any other lgpl licenses?
15:45:08 <monochrom> I don't think there is one.
15:45:09 <sproingie> if only gmp were lgpl
15:45:47 <johnw> "Since version 6, GMP is distributed under the dual licenses, GNU LGPL v3 and GNU GPL v2."
15:46:16 <sproingie> oh how nice
15:46:25 <jakehehrlich> well for me that's not ideal
15:46:34 <johnw> yeah, I've been using it in Ledger since forever, and I wouldn't have if it were only GPL
15:46:42 <sproingie> looks like readline is still viral GPL
15:46:53 <johnw> use
15:46:59 <johnw> libedit is the freer replacement
15:47:31 <sproingie> libedit doesn't grok .inputrc tho, does it?
15:48:38 <johnw> dunno
15:49:39 <sproingie> ah it does .editrc
15:50:12 <TheLoneNoMad> anyonnnn here have a programmers perspective
15:50:19 <sproingie> most of us i suspect
15:50:33 <TheLoneNoMad> the book i mean
15:50:34 <TheLoneNoMad> lol
15:50:45 <monochrom> No one does.
15:51:04 <schell> is there a package that provides singleton promotion for types with String in them?
15:51:52 <TheLoneNoMad> whys that
15:52:01 * sproingie ports his .inputrc to a .editrc.  something productive came out of today at least :)
15:52:12 <schell> using singletons’ `$(singletons [‘’MyType])` seems to barf whenever `MyType` has `String` in it
15:52:42 <schell> though my guess is that it’s possible with `Symbol` or something
15:56:34 <TheLoneNoMad> is thie channel about the horse racing champ haskell?
15:56:41 <monochrom> No.
15:56:50 <sproingie> see the /topic
15:57:15 <Unicorn_Princess> I've been in the wrong channel all this time?
15:57:33 <MarcelineVQ> Unicorn_Princess: same thing happened to me 4 times in a row
15:57:36 <monochrom> haha
15:57:51 <sproingie> happens every other day on /r/haskell
15:57:56 <TheLoneNoMad> well your name is unicorn so i guess you are also a horse racing fan?
15:58:04 <sproingie> tho that's some kind of strange "newsbot" spam
15:58:19 <Unicorn_Princess> all that time trying to figure out what monoids had to do with horse racing...
15:58:45 <sproingie> so there's a racing performance champ named Haskell?  we should be trumpeting this news :)
15:58:51 <TheLoneNoMad> http://www.monmouthpark.com/haskell/horses_to_watch.aspx?id=3073
15:59:02 <sproingie> guy says the horse can do
15:59:18 <geekosaur> why not the rugby player?
15:59:49 <sproingie> Haskell: Agile, Strong, Fast
16:00:14 <TheLoneNoMad> guess i joined the wrong channel sorry!
16:00:19 <sproingie> 's ok
16:00:41 <pikajude> HASF?
16:00:47 <pikajude> oh
16:01:01 <sproingie> inb4 "pick any two" 
16:01:14 <pikajude> didn't like agile much
16:01:51 <sproingie> i dunno.  my code is test-driven, just that my primary test suite is the compiler
16:04:10 <sproingie> (actually it's still me firing up ghci, but i'm getting there)
16:05:23 <sm> sproingie: have you tried ghcid ?
16:05:57 <sproingie> not yet.  i'm more into IDE support now like intero
16:06:21 <sproingie> gotta try the intellij plugin sometime
16:06:25 <sm> it's great. For when IDE support doesn't work
16:06:41 <sproingie> which is pretty bloody frequent
16:07:02 <sm> yes, pretty much always
16:07:41 <sproingie> intero is pretty good, and microsoft has this LSP thing that's gaining traction
16:09:04 <freeman42> http://haskelltools.org/ should probably be added to https://wiki.haskell.org/IDEs
16:09:06 <sproingie> but i miss the kind of project-wide refactorings i can do with IDEA tho, to say nothing of being able to navigate to definitions with a click
16:10:13 <sproingie> even CLion was able to do some radical refactoring over basically broken C code
16:21:43 <Zemyla> Where was the paper about Church encoding of non-regular data types?
16:37:32 <Unicorn_Princess> Alright, got it down to a compiling example: http://lpaste.net/356428 -- how can I make the type errors (expected: a1 -> f1 Bool, actual: a -> f Bool) go away?
16:39:22 <monochrom> If you write "taggedA :: [f (a, Bool)]", even in an inner scope, it means "for all f, for all a". Not synced with the "f" and "a" from the outer scope.
16:39:44 <monochrom> Solution is sometimes you omit the inner type sig, if you can afford to.
16:40:17 <monochrom> The other times you turn on ScopedTypeVariables. Please see the GHC user's guide on this because there is one extra thing you need to do, and it's said there.
16:41:35 <Unicorn_Princess> the user's guide on ScopedTypeVariables?
16:41:42 <monochrom> Yes.
16:42:43 * mekeor ponders
16:42:47 <mekeor> it's a bit strange that the MonadIO type class makes sense because: "Monads in which IO computations may be embedded" don't seem to make sense on first sight because: if IO a ≈ World -> (A, World), i.e. IO can do anything, i.e. you can do anything inside and outside of that MonadIO, what is it for? but monads apparently aren't only for restricting but also for abstraction, hm?
16:43:16 <zomg> so basically MonadIO is zombo.com
16:44:05 <luisdevlopez> Hey, I have a weird question; does anybody know why ([1..3] >>= return "Hey") yields "HeyHeyHey" but ([1..3] >>= (\_ -> return "Hey")) yields ["Hey", "Hey", "Hey"]? I understand why the 2nd case returns what it returns; but what's the explanation behind the 1st case?
16:44:17 <monochrom> To appreciate what MonadIO is for, never use it and see what happens.
16:44:27 <MP2E> It's more that in Haskell, we like restricted our types so that they can only do things we want, and IO is the 'escape hatch' to reach for when that gets too dirty or becomes unfeasible
16:44:33 <MP2E> we like ot restrict our types*
16:44:36 <MP2E> can't type today :P
16:44:54 <MP2E> so monadio is just embedding that escape hatch
16:45:30 <Rembane> MP2E: MonadEscapeHatch?
16:45:42 <monochrom> So for example suppose you're working with "StateT Int (ExceptT Bool IO)". You're going to write "lift (lift getLine)" instead of "liftIO getLine".
16:46:42 <mekeor> monochrom: yeah, that's one point. but the other is that 'StateT Int (ExceptT Bool IO)' makes sense in first place, isn't it?
16:46:55 <monochrom> It is also false that you can do "anything" inside MonadIO.
16:47:17 <mekeor> why?
16:47:29 <dmwit> :t catch
16:47:30 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
16:47:38 <dmwit> Have fun `liftIO`ing that.
16:47:43 <MP2E> interesting
16:47:46 <monochrom> Again working with "StateT Int (ExceptT Bool IO)", suppose you have "lift (lift (forkIO xxx))". Then xxx must have type "IO X", not "StateT Int (ExceptT Bool IO) X".
16:47:57 <monochrom> So that's a counterexample of "do anything".
16:48:06 <Unicorn_Princess> monochrom: thanks, and it worked
16:48:19 <monochrom> And also what dmwit says which is usually more urgent.
16:48:22 <Unicorn_Princess> now to learn about this forall thing I guess
16:48:26 <dmwit> See also: https://stackoverflow.com/q/9243215/791604
16:49:20 <ALoneNoMad> should i learn haskell?
16:49:20 <monochrom> I don't know whether "StateT Int (ExceptT Bool IO)" per se makes sense. It's just a toy example.
16:49:59 <monochrom> But presumably a lot of web app libraries are even more stacked up than my toy example.
16:50:41 <mekeor> dmwit: wow, interesting, thakns
16:50:45 <dmwit> ALoneNoMad: Insufficient data for meaningful answer. Therefore, "yes".
16:51:13 <mekeor> ALoneNoMad: yes, it's fun and future
16:51:25 <zomg> luisdevlopez: that's a good question, as far as I can tell `return "Hey"` shouldn't match the type signature of >>=
16:51:25 <ALoneNoMad> ok how do i go about learning it?
16:51:34 <zomg> luisdevlopez: but someone more experienced than me could probably explain it
16:52:44 <monochrom> @type ([1..3] >>= return "Hey")
16:52:46 <lambdabot> [Char]
16:53:13 <monochrom> Actually, a sharper experiment is:
16:53:23 <monochrom> @type (\x -> [1..3] >>= x)
16:53:25 <lambdabot> (Enum a, Num a) => (a -> [b]) -> [b]
16:53:43 <Unicorn_Princess> [1..3] >>= ["Hey"] gives an error, so, how to figure out what the type of return "Hey" is, in the [1..3] >>= return "Hey" example?
16:53:44 <ALoneNoMad> will ai replace programming bc if it does learning will be futile
16:54:06 <Unicorn_Princess> ALoneNoMad: when it does, it will replace all professions
16:54:24 <dmwit> :t \x -> [1..3] >>= x
16:54:25 <lambdabot> (Enum a, Num a) => (a -> [b]) -> [b]
16:54:35 <ALoneNoMad> well do you think it will happen?
16:54:42 <mekeor> so, (return "Hey") has type (a -> [b])
16:55:03 <dmwit> :t let [x, _] = [undefined, return "Hey"]; _ = [1..3] >>= x in x
16:55:04 <lambdabot> Monad m => m [Char]
16:55:14 <monochrom> So (return "Hey") has type A -> [B] for some A,B. This means the return there is using the ((->) A) monad, not the list monad.
16:55:15 <Unicorn_Princess> ALoneNoMad: probably not within 50 years
16:55:38 <monochrom> In other words you're looking at ([1..3] >>= const "Hey")
16:55:38 <ALoneNoMad> arent people giving the ai too much or is it possible
16:55:42 <zomg> monochrom: I had a hunch it had something to do with the ->, idling on this channel has not been in vai!
16:55:45 <zomg> *vain
16:55:51 <mekeor> because instance Monad (-> a) -- ?
16:55:53 <dmwit> ah, I see
16:57:03 <mekeor> @instance Monad (-> a)
16:57:04 <lambdabot> Maybe you meant: instances instances-importing
16:57:21 <mekeor> can lambdabot show us the implementation of (>>=) for (-> a) ?
16:57:28 <monochrom> Speech recognition has replaced typing. Now look what you're still doing with your keyboard on IRC.
16:57:52 <dmwit> Aha, here we go:
16:58:00 <monochrom> Going back further, cars have replaced running. Now look what those guys in the Olympics are doing.
16:58:04 <dmwit> :t [1..3] >>= head [return "Hey", ?x]
16:58:06 <lambdabot> (?x::a -> [Char], Enum a, Num a) => [Char]
16:58:29 <dmwit> Now you know how to ask the type of a subterm of an expression!
16:58:42 <mekeor> :D
16:58:49 <monochrom> Hmm does lambdabot have type wildcards?
16:58:50 <ALoneNoMad> well exercise is good for you 
16:58:54 <monochrom> > 5 :: _
16:58:56 <lambdabot>  error:
16:58:56 <lambdabot>      • No instance for (Num t1)
16:58:56 <lambdabot>        Possible fix:
16:58:56 <Unicorn_Princess> monochrom: they're staying off the highway is what they're doing :P
16:58:59 <ALoneNoMad> but i do like the speech analogy
16:59:05 <ALoneNoMad> that made me feel better
16:59:05 <monochrom> > () :: _
16:59:07 <lambdabot>  error:
16:59:07 <lambdabot>      • Found type wildcard ‘_’ standing for ‘()’
16:59:07 <lambdabot>        To use the inferred type, enable PartialTypeSignatures
16:59:11 <monochrom> YES!
16:59:27 <mekeor> let's enable PartialTypeSignatures
17:00:13 <dmwit> Let's not. Then we can't get this nice informative error message. =)
17:00:34 <monochrom> Programming by human is also a good brain exercise.
17:00:38 <Unicorn_Princess> ugh, it's too late to be in such an informative channel
17:01:07 <ALoneNoMad> then again compilers are a form of ai 
17:01:16 <ALoneNoMad> and assembly programming no one does anymore
17:01:19 <mekeor> i'm here because it's too late to code
17:02:11 <Rembane> We should all do more assembly programming
17:02:39 <monochrom> Olympic runners running is not good for my health. In fact I suspect not good for their health either. Look at all those sports injuries they seldom talk about.
17:03:18 <ALoneNoMad> well essentially if we replaced low level programming with high then high level will be replaced by automated
17:03:25 <ALoneNoMad> so its gonna be pointless 
17:03:25 <ALoneNoMad> sigh
17:03:27 <ALoneNoMad> life sucks
17:03:42 <MarcelineVQ> how terrible.
17:03:52 <ALoneNoMad> and trump wont give me unemplpyment
17:04:16 <ALoneNoMad> should of been a  lawyer
17:04:18 <sproingie> there will always be some higher level.  at least until the machines get better at that than us.
17:04:32 <ALoneNoMad> the thing is will it?
17:04:43 <sproingie> not while we're still in charge of making them
17:04:56 <ALoneNoMad> o i see 
17:05:10 <ALoneNoMad> so until they can procreate themselves we're safe
17:05:23 <mekeor> at the moment it's still us that we decide on how powerful machines will become. we can decide to let them decide
17:05:42 <johnw> a reminder to please take off-topic (i.e., not Haskell) discussion to another channel...
17:05:49 <Unicorn_Princess> us = the heads of a few giant corporations tho
17:05:56 <ALoneNoMad> sorry johnw
17:05:59 <mekeor> #haskell-offtopic
17:06:06 <mekeor> (or #emacs )
17:06:22 <ALoneNoMad> thansk
17:06:22 <ALoneNoMad> sorry
17:07:00 <ALoneNoMad> can i get forgiveness?
17:07:08 <johnw> no worries, we all forget when things get interesting
17:19:26 <lamefun> Map31 is not for humans.
17:19:58 <c_wraith> at that point I would be using ZipList
17:20:06 <lamefun> wrong channel nvm
17:20:11 <monochrom> Haha
17:39:16 <lambdamu> here is a riddle: http://lpaste.net/356429
17:41:56 <jmcarthur> wat
17:41:59 <monochrom> That's interesting.
17:42:50 <monochrom> During the second compilation, the CPU is traveling near the speed of light relative to the time measurement device, so the measurement comes out as many times longer.
18:00:06 <nshepperd> in the second compilation only one invocation of gcc is created, and passed all arguments, resulting in large amounts of memory use and swapping?
18:00:21 <nshepperd> not sure if swapping takes up 'user' time
18:02:08 <nshepperd> oh wait, it's because the first one is timing the output of gcc (isn't that the empty string?), not gcc itself
18:04:11 <nshepperd> or... no, the builtin 'time' is magic and doesn't do that
18:09:55 <geekosaur> what's in the response file? if it's empty with xargs, ghc is invoked with no parameters
18:10:07 <geekosaur> whereas ghc must process the file always in the second case
18:11:05 <lambdamu> geekosaur: /ghc/gcc/ but no it's not empty, I've grabbed it from some temp folder, ghc produced it
18:11:09 <geekosaur> hm, guess it can;t be empty if it recreated the file.
18:12:02 <lambdamu> it's the final linking step, it is acutally quite big, I don't have a clue going on here
18:13:03 <lambdamu> I patched runSomethingResponseFile from runCc in GHC and while it compiles im reviewing expandargv in gcc
18:13:36 <geekosaur> yeh, I am now having a vague recollection of gcc's response file handling being expensive
18:13:44 <geekosaur> not something I paid much attention to through
18:15:05 <geekosaur> also consider that if you use a response file with gcc, it may build and use a response file with ld, so now you have extra overhead there too
18:15:55 <lambdamu> geekosaur: But all things considered it's just a list of arguments, how expensive can that be?
18:16:28 <geekosaur> depends on how stupidly it's implemented :)
18:17:07 <geekosaur> also... "just a list of arguments" have you ever tried to reproduce shell quoting?
18:20:43 * nshepperd wonders if the solution to this riddle will end up being a good submission to the 'Accidentally Quadratic' blog
18:47:13 <lambdamu> The problem it actually in the nix wrapper around gcc
19:09:29 <heebo> hello I would like to get ordinal numbers from my sum type.
19:10:48 <heebo> is this possible to have f so that given ``` data MySumType = A | B | C | D ``` 
19:11:33 <heebo> f A == 0 , f B == 1 etc...?
19:11:39 <iqubic> heebo, try deriving enum.
19:12:27 <heebo> thanks
19:12:41 <geekosaur> you may also want Bounded
20:17:52 <glguy> I've been playing around with adding smarter command recognition to my IRC client tonight. The server sends information about what all the channel modes are and which ones require arguments. Example https://glguy.net/irc-modes.png ^_^
20:18:20 <glguy> (the white boxes are transient placeholders, they go away when you fill in the parameter)
20:20:39 <glguy> I think I'm only confident in the meaning of 18 of those flags
20:21:45 <glguy> Oh, and somehow I missed f !
20:30:47 <mrkgnao> glguy: that is really cool. reminds me of when I used an OCaml repl for a couple of minutes for some reason.
20:30:56 <mrkgnao> (I mean the completion-y thing)
20:36:15 <zomg> hm so it was suggested that using records to model an api (ie. like a client to a web service) would be a good way to do it - putting the functions of the api as fields
20:36:47 <zomg> of course this presents a minor problem in the sense that one of the functions is polymorphic on its own
20:37:15 <zomg> so while I could say data Api a b, a and b can change per invocation of the function and has nothing to do with the data type
20:37:31 <glguy> zomg: And so you need to enable RankNTypes?
20:37:56 <zomg> Ok, if that might help I'll look that up next :D
20:38:10 <zomg> I was going to say I saw existential qualification can hide the types, but that then presents other annoyances
20:38:37 <glguy> Among other things, that extension allows you to have record fields with polymorphic types
20:38:44 <davr0s> do haskell typeclasses always result in runtime type information being thrown around, or are there situations (like with Rust traits) where that compiles out (monomorphised..)
20:39:12 <glguy> davr0s: Specialization is possible
20:39:19 <zomg> glguy: sounds good, gonna check it out :) thanks
21:03:18 <jchia_1> Question related to AMP & functions like traverse & forM_: Other than historical and compatibility reasons, are there other valid reasons (e.g. performance reasons) to use things like mapM that require Monad instead of their more general counterparts like traverse that only require Applicative?
21:04:02 <jchia_1> I'm thinking of hiding these Monad functions from all my imports.
21:05:55 <glguy> Yes, the difference is performance
21:41:17 <sophiag> can anyone familiar with singletons help me with this code? http://lpaste.net/356432
21:42:01 <zomg> glguy: I think I got it working, and amazingly enough I seem to also have learned a bit more about how DataKinds and GADTs work purely by having to make some other crap I made work with this :P
21:43:54 <sophiag> the examples might seem a bit odd, but it's a preliminary attempt at using something like an "iterator" type, but on ADTs and GADTs where the "iteration" needs to occur accross data type constructors. so right now i'm just trying it with Nat and one function that generates an infinite vector of Nats and another that does the same except stepping through the generation using shift/reset
21:45:22 <sophiag> i'm also unsure about the standalone show instance for Vec and whether i should define a Monoid instance for SNat (if so, i'm surely not doing it correctly...) 
21:47:23 <zomg> although the whole part with the datakinds stuff is still... not doing a whole lot other than being annoying
21:47:26 <zomg> :D
21:51:28 <cocreature> sophiag: "SNat n" is not a Monoid because "SZero" is of type "SNat Zero" and not of type "SNat n"
21:54:57 <sophiag> cocreature: ah ok. thanks. but you're saying rather that it can't be *made* a monoid, right? i'm unsure if i even need it to be or not
21:55:16 <cocreature> sophiag: right
21:55:38 <sophiag> i think i need to set aside the monoid instance since i'm not really using it yet and fix the basics
21:55:49 <sophiag> i'm very confused why nth is throwing that error
21:56:00 <MarcelineVQ> sophiag: you're always working on interesting things :>
21:56:14 <cocreature> probably GHC is not clever enough to dedcude m :< n from S m :< S n
21:56:20 <sophiag> MarcelineVQ: that's a very polite way to put it! :p
21:56:37 <cocreature> but I can’t figure out where :< for Nat is actually defined so I’m not quite sure why that’s the case
21:56:46 <sophiag> cocreature: pretty sure i copied that code verbatim from the singletons paper, but those things change so fast...
21:58:22 <cocreature> hm ddump-splices also doesn’t seem to show the definition of :< for Nat
21:59:28 <glguy> sophiag: I think you'll need to add: promoteEqInstance ''Nat; promoteOrdInstance ''Nat
21:59:32 <glguy> To make progress with nth
21:59:33 <zomg> Ugh, frankly half of the time I feel like I should just toss these more advanced type shenanigans
21:59:56 <zomg> I can make the program work without them and all they do is get in the way because I don't fully understand how to make it work in the particular way I'd like :D
22:00:13 <sophiag> from the paper: "The nth code type checks in the second case because pattern matching refines the type variables m and n to be headed by Succ. Therefore, the constraint m :< n reduces to the simpler constraint required by the recursive call to nth. Furthermore, GHC observes that indexing must succeed."
22:00:29 <sophiag> The second sentence clearly isn't happening...
22:00:40 <cocreature> glguy: oh right, that explains why I can’t find the definition :)
22:01:16 <sophiag> glguy: oh thanks! that's something that must have changed since the paper was written
22:01:33 <sophiag> Eisenberg says singletons was a mistake now :p
22:01:52 <glguy> sophiag: I'd be surprised if singletons ever automatically derived an Ord instance for your type without being asked
22:02:07 <MarcelineVQ> if he does it's probaly because he's working on something better
22:02:25 <zomg> I wanted my Api values to have a phantom type as to allow the api functions to return results using that type, to prevent the results from being mixed
22:02:48 <zomg> However that of course poses the issue of being able to put the apis into a list to for example perform the same request on all of them and collect the results...
22:02:51 <zomg> :P
22:02:56 <zomg> *not
22:03:04 <cocreature> singletons feels more like a pretty impressive poc than something you should or want to use
22:03:44 <sophiag> MarcelineVQ is right. it's because he's trying to get some form of dependent types actually into GHC
22:04:52 <zomg> I'm sure the issue is solvable with even more type shenanigans
22:05:13 <zomg> But I think I'll just opt to make the program work and then look more into that... as much as I'd like to do it now
22:05:16 <zomg> :D
22:05:45 <sophiag> but the story for my use case goes like this: i was bored and had the idea to port parts of the C++ STL to Haskell since Stepanov is always saying it's the only language that can support what he was trying to do with generic programming (except no one uses it..). then i realized i'd need to somehow count data type constructors to be able to iterate over ADTs so had the idea for a type level Traversable class, which is when someone
22:05:45 <sophiag> recommended type casing
22:07:03 <sophiag> now i'm actually trying to move forward with this because upgrading haskell-src-exts broke a whole DSL i wrote and i figured the issue is i shouldn't have to rewrite my codebase just because the AST format changed slightly. if i could traverse data types then i wouldn't need to use a ton of horrible type casing
22:07:37 <cocreature> and down the rabbit hole you go :)
22:07:52 <zomg> yeah
22:08:09 <zomg> there's lots of stuff which talks about these different features but it's sometimes a bit hard to know how that applies into practice
22:08:19 <glguy> You're investigating singletons in order to avoid fixing up your code to work with a new version of haskell-src-exts? o.O
22:08:36 <zomg> especially when most of the examples are ways of representing lists in strange structures
22:09:05 <cocreature> zomg: you might want to take a look at edwin brady’s book for some more realistic examples
22:09:28 <MarcelineVQ> zomg: https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html
22:09:47 <sophiag> glguy: not to avoid it. so that it could be more modular in the first place. we were having this discussion after compose conference to the effect of "type casing considered harmful" and then i realized it was the sole reason that code broken by singletons would be such a pain to update
22:10:36 <jchia_1> FFI question. I want to make a Haskell program that calls C++ functions. The C++ functions in turn creates threads that can call some Haskell functions that I export. Can this work? Does it matter that the C++ creates its own threads and calls Haskell from them? (Can Haskell functions be called from arbitrary thread?) Given that the Haskell program is already running and the RTS is already up, does the C++ code still need to call hs_ini
22:10:37 <jchia_1> t() and hs_exit()?
22:10:45 <sophiag> my vague idea is if i could use something like Conor McBride's zippers with the ASTs then changes like the recent one would hardly matter
22:11:21 <zomg> cocreature: the only one by someone named that is about Idris?
22:11:28 <glguy> It sounds like you're way off base, but who knows :)
22:11:37 <zomg> MarcelineVQ: thanks - looks interesting, to the list of things to read it goes :)
22:12:10 <MarcelineVQ> it's quite a list isn't it?
22:12:20 <sophiag> i may be...Cale also said that type level traversables would be very frustrating to implement, but probably informative to find out where exactly the frustration lies :p
22:12:46 <zomg> nah not yet :P maybe it will be
22:13:31 <lambdamu_> jchia_1: I think you should be ok, as long as your foreign function imports aren't declared as unsafe
22:13:36 <sophiag> glguy: anyway, i'm a bit confused about the syntax for promoting instances. are you saying just put Nat inside promote? or have like $(promoteEqInstance[''Nat]) after already generating it?
22:18:24 <MarcelineVQ> oh it will be
22:18:53 <MarcelineVQ> so long you'll lose parts of it when your browser crashes and you'll constantly rediscover things you mean to read and never actually do
22:22:13 <zomg> lol :)
22:26:05 <sophiag> ah, ok. it seems perhaps promoteSingletonInstance has been deprecated in favor of promoteSingletonInstances? either that or it doesn't work with generated types
22:32:26 <sophiag> i'm getting the same error from nth though. i must be confused about how to apply these constraints. here's my updated gist: http://lpaste.net/356432
22:34:23 <eklavya> Just watched the talk by simon marlow on haxl
22:34:39 <eklavya> and I remembered something I had wondered about the first time I heard about it
22:34:54 <eklavya> haxl caches the IO requests
22:35:09 <eklavya> never mind
22:35:28 <eklavya> somebody just asked that question the qna part of the video :P
22:40:21 <piyush-kurur> eklavya: Simon marlow mentions build systems as one potential application. The others I can think of is package management. May be it is time to rewrite some of these applications by making use of Haxl
22:40:40 <halogenandtoast> When you have something in the format of f x = do { x' <- g x; x'' <- g x'; unless (h x'') (f x''); }
22:40:46 <halogenandtoast> Is there some monad I should be using instead?
22:40:51 <piyush-kurur> package management includes cabal-install/stack by the way
22:42:33 <jchia_1> lambdamu_: OK, thanks.
22:43:46 <MarcelineVQ> @bot
22:43:47 <lambdabot> :)
22:44:11 <MarcelineVQ> that's more like it, lambdabot, my tab completion didn't have you at the top of the list
23:18:24 <cocreature> zomg: yep it’s about idris but even if you’re not interested in Haskell itself it’s a nice book for learning how to use dependent types without all the cruft currently required for using them in Haskell. and translating some of the idris code to Haskell is a nice exercise :)
23:21:16 <cocreature> eh s/Haskell itself/idris itself/
23:28:11 <sophiag> cocreature: i'm still sitting on this snippet...any ideas? http://lpaste.net/356432
23:28:42 <sophiag> i think the constraints on line 49 are...off
23:29:43 <glguy> sophiag: I don't think you're going to make any progress using :<
23:30:55 <sophiag> glguy: that function actually isn't even particularly important to me. it was just from the original singletons paper :p
23:31:28 <MarcelineVQ> if there was progress to be made with :< would POrd be the constraint to use?
23:33:00 <\u> why doesn't `cabal install --enable-shared lens` build shared libraries but `runghc Setup configure --enable-shared lens; runghc Setup install` does
23:33:16 <cocreature> sophiag: sorry not sure what’s going on here
23:34:06 <sophiag> MarcelineVQ: trying to promote POrd doesn't work for some reason (not on this type, in general)
23:34:26 <MarcelineVQ> I don't know much about that stuff, just saw that :< was from POrd
23:34:47 <sophiag> cocreature: i'd like to set aside whatever is going on with nth. i'm really just curious about getting iterNat and iterNatStep to work
23:35:42 <sophiag> the former typechecks, but i get a runtime error: "Non type-variable argument in the constraint: Enum (Sing n)" despite using FlexibleContexts
23:36:07 <cocreature> that doesn’t look like a runtime error?
23:36:07 <merijn> sophiag: What's the kinda of "Sing n"?
23:36:41 <sophiag> cocreature: i shouldn't have said that. just when i try calling it in ghci
23:37:06 <cocreature> sophiag: how exactly are you calling it?
23:38:22 <sophiag> just by itself, which should run on forever. if i try "take 10 $ iterNat" i get a type error because take wants a list
23:38:46 <sophiag> it may be wise to abandon this contrived "Vec" type from, again, the singletons paper...
23:39:12 <cocreature> sophiag: after enabling FlexibleContexts in GHCi it works for me
23:39:33 <cocreature> well I get an error about ghci not being able to print it due to a missing Show constraint but that’s a different problem
23:39:37 <sophiag> wait, what?
23:40:08 <cocreature> sophiag: have you enabled FlexibleContexts _in ghci_?
23:40:23 <sophiag> oh...
23:41:06 <sophiag> yup, ok
23:41:25 <sophiag> i should still probably switch to Data.Singletons.Prelude.List tho
23:41:45 <sophiag> otherwise i need to fix my show instance for Vec
23:44:06 <sophiag> wow, i hate how singletons has haddock docs but you need to use google to find them?
23:45:37 <MarcelineVQ> you don't, but the latest version's docs are broken so you need to step back a version iirc
23:45:56 <sophiag> ah ok. the problem is the fixed link points to 2.3
23:52:02 <zomg> cocreature: ok - dependent types seem like a bit further down the road than what I need atm but into the list it goes :D
23:54:06 <sophiag> i'm still unsure about the type signature for iterNat. seems either "(Enum (Sing a)) => Iterator SNat a (Sing [SNat a])" or "(Enum (Sing a)) => Iterator SNat a (SList [SNat a])" but the latter doesn't typecheck
23:59:43 <sophiag> this is what i'm working with now: http://lpaste.net/356432
