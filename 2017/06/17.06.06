00:00:52 <MarcelineVQ> it's not great :(
00:50:09 <bollu> If anyone has examples which causes GHC to emit unintuitive error messages, could you please ping me or send a PR to this repo (https://github.com/elm-lang/error-message-catalog)? I'm collecting examples where GHC generates unintuitive error messages to try and help improve this system.
00:50:57 <ph88^> this function takes up the main time in my program https://bpaste.net/show/98f27a726c72 i have an image here where the bigger squares take more time https://i.imgur.com/dJGikql.png   anyone a suggestion how to optimize this little piece of code ?
00:53:17 <butterthebuddha> Is there a more up-to-date alternative to Real World Haskell?
00:54:13 <merijn> butterthebuddha: Depends on the parts you're interested in :)
00:55:33 <butterthebuddha> I'm working on CIS194 (UPenn) right now and Real World Haskell is pretty much required reading because their lecture notes are very sparse. The other reading, "Learn You Haskell" is ***very*** verbose
00:55:38 * hackage watchdog 0.3 - Simple control structure to re-try an action with exponential backoff  https://hackage.haskell.org/package/watchdog-0.3 (JanVornberger)
00:55:38 <cocreature> most of it is also not terribly out of date and you can usually figure out relatively easily how to adapt it to newer versions of libraries or GHC
00:55:39 <merijn> For the library chapters, not so much. For the language itself RWH was never that great to begin with. There's "Haskell Programming from First Principles" (i.e. haskellbook.com), Introduction to Functional Programming using Haskell
00:56:28 <merijn> I think there's basically two extremes: Really verbose and really sparse (i.e., the tutorial)
00:56:40 <merijn> But the tutorial assumes a bunch of knowledge about FP in general
00:57:14 <butterthebuddha> I have a passing familiarity with SML so I'm not a complete stranger to FP
00:57:25 <butterthebuddha> But the lecture notes don't mention some topics like let expressions at all
01:00:23 <merijn> butterthebuddha: ah, ok if you have a little SML knowledge you may wanna try the tutorial
01:00:32 <merijn> @where gentle
01:00:32 <lambdabot> http://www.haskell.org/tutorial/
01:01:18 <merijn> butterthebuddha: The tutorial was written as a syntax/basic differences guide for people coming from SML
01:01:36 <merijn> Although since it's Haskell98 I guess the pattern guards example from earlier still wouldn't be covered >.>
01:24:10 <ph88^> was able to shave off another 3.5 seconds with this alternative code :D https://bpaste.net/show/998cdbb12d51
01:26:41 <pacak> ph88^: That is some ugly haskell code.
01:26:48 <ph88^> :'(
01:27:53 <merijn> ph88^: Needs finer grained where clauses
01:28:02 <ph88^> what for ?
01:28:25 <pacak> To make it readable.
01:28:42 <ph88^> oh i just care for performance at the moment ^^
01:28:46 <pacak> Also type signatures.
01:28:50 <pacak> To make it readable.
01:29:35 <pacak> And once you can read it - you might be able to express more things in terms of vector operations - they fuse and get compiled into something more efficient.
01:30:26 <bollu> pacak: how do you use vectored operations in haskell? isn't that like, 3 levels of abstraction too low?
01:30:47 <ph88^> pacak, like which vector operations ? i do vector indexing
01:30:58 <pacak> bollu: In this case I'm talking about vector operations as in vector library.
01:31:23 <pacak> ph88^: Sure, but I also see sum...
01:31:42 <ph88^> pacak, ye i see it too, what about it ?
01:31:53 <NextHendrix> anyone know the progress on musl/uclibc build of ghc
01:32:05 <pacak> bollu: If you want to use vectorized instructions (AVX, SSE, etc) - that's also possible.
01:32:18 <cocreature> NextHendrix: ghc is in the alpine repos so a musl build should be available
01:32:37 <NextHendrix> oh? wasn't last time i checked
01:32:38 <bollu> pacak: how?
01:32:43 <pacak> ph88^: sum of vector can be more efficient compared to a doing sum by hand.
01:32:46 <NextHendrix> thanks, ill investigate
01:33:16 <ph88^> pacak, but i'm not summing the vector itself, but only some particular values inside the vector
01:33:29 <cocreature> NextHendrix: I think it’s in the stable repos by now but I’m not entirely sure. a while back it was still in testing or whatever that’s called in alpine
01:33:31 <pacak> ph88^: Well... That I can't see.
01:33:43 <ph88^> i only use VU.! 
01:33:45 <NextHendrix> edge iirc
01:33:51 <ph88^> Vector Unboxed Double
01:34:14 <merijn> bollu: If you care about low level dirty things, like AVX, etc. you shoul have browse through GHC.Prim some day
01:34:32 <merijn> bollu: https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Prim.html
01:34:45 <merijn> Lots of neat low level stuff you can get at
01:34:57 <pacak> bollu: You can manually define foreign primops
01:35:51 <bollu> whoa, interesting
01:35:55 <pacak> bollu: http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel - or this
01:36:11 <bollu> I actually had a related question: what are the primops that STG implements?
01:36:18 <bollu> there has to be a primop for IO, right?
01:36:25 <pacak> IO is a monad.
01:36:26 <bollu> I wanted a list of such primops that's implemented in sTG
01:36:38 <pacak> Monad is like a burrito. How would you implement a primop for burrito?
01:36:39 <bollu> I mean, whatever, "ST RealWorld"
01:37:04 <NextHendrix> guacemole composition
01:37:21 <NextHendrix> cheese transformers
01:37:49 <pacak> IO a is (# a,  RealWorld #) or something similar and RealWorld part gets optimized away
01:37:59 <bollu> okay, but how is it *implemented*?
01:39:14 <pacak> I suspect it's something similar to newtype RealWorld = RealWorld ()
01:39:31 <pacak> It's just a token.
01:40:10 <quchen> pacak, bollu: https://github.com/quchen/articles/blob/master/fbut.md#where-is-io-defined
01:40:17 <bollu> quchen: ty
01:41:02 <bollu> quchen: what does something like "print" get desugared to, STG-wise?
01:41:09 <merijn> bollu: Also, check out the paper "Lazy Functional State Threads"
01:41:18 <quchen> No idea.
01:41:20 <merijn> bollu: Which covers both ST and IO
01:41:27 <bollu> merijn: ah, I see
01:41:31 <pacak> quchen: Right, something like that. Nice list btw.
01:41:44 <merijn> IO and ST are both (differently specialised) versions of an unboxed state monad
01:41:48 <pacak> bollu: -ddump-to-file -ddump-stg
01:42:01 <bollu> pacak: ah yes :)
01:42:09 <AWizzArd> Why can I write     [2, 4, 6] :: [Product Int]    instead of [Product {getProduct = 2},Product {getProduct = 4},Product {getProduct = 6}] ?    With Maybe Int this wouldn’t work.
01:42:41 <pacak> AWizzArd: There's Num instance for Product.
01:42:49 <merijn> bollu: IO is "State# RealWorld -> (#State# RealWorld, a#)" where State# is unboxed State, returning an unboxed tuple
01:42:55 <pacak>  Num a => Num (Product a)
01:43:06 <pacak> There's no such instance for Maybe.
01:43:23 <bollu> merijn: hm?
01:43:30 <bollu> ah
01:48:26 <kuribas> Can anyone tell my how to make this work?  http://paste.lisp.org/display/348224
01:49:02 <bartavelle> kuribas: shouldn't it be replicateM ?
01:49:27 <kuribas> right
01:49:47 <bartavelle> (however, as this is probably the list monad, it should be identical)
01:50:04 <bartavelle> oh it's M.replicate, lemme just check
01:50:25 <cocreature> kuribas: what’s the error?
01:50:27 <kuribas> hm, no replicate is right
01:51:22 <bartavelle> kuribas: this code seems right to me
01:51:34 <kuribas> http://paste.lisp.org/display/348224#1
01:51:49 <kuribas> perhaps there is something wrong with my cubicbezier package?
01:52:17 <cocreature> it probably doesn’t provide an Unbox instance
01:52:20 <bartavelle> kuribas: oh right, you are using unboxed vectors, which only work for things that are unboxable
01:52:38 <kuribas> bartavelle: there is an instance here: https://hackage.haskell.org/package/cubicbezier-0.6.0.3/docs/Geom2D.html
01:52:49 <kuribas> I cannot see what is wrong with it...
01:53:20 <cocreature> there is an instance for Vector but I don’t see an instance of Unbox
01:54:11 <kuribas> cocreature: "Unbox a => Unbox (Point a)"
01:54:25 <kuribas> https://hackage.haskell.org/package/cubicbezier-0.6.0.3/docs/src/Geom2D.html#line-66
01:54:26 <cocreature> oh right I missed that
01:54:27 <bartavelle> still requires an instance
01:54:36 <bartavelle> oh
01:54:57 <bartavelle> kuribas: can you see the instances in ghci with :info Point ?
01:55:15 <bartavelle> kuribas: are you using the same version of the library than the version you are looking the docs of on hackage ?
01:56:17 <bartavelle> oh you are the author of the package
01:56:23 <kuribas> yes...
01:56:26 <bartavelle> so you are probably using the latest version :)
01:56:54 <kuribas> strange it isn't there...
02:00:30 <kuribas> http://paste.lisp.org/display/348224#2
02:00:37 <bartavelle> kuribas: you should probably do some sort of rm -rf or "stack clean", your code works fine for me
02:00:50 <bartavelle> with cubic-bezier 0.6.0.3
02:00:52 <kuribas> bartavelle: ok, I see
02:00:55 <kuribas> bartavelle: thanks
02:00:59 <bartavelle> good luck*
02:01:18 <kuribas> so the package database is messed up...
02:02:09 <bartavelle> you might also need to import the Vector module to see the instances
02:02:40 <bartavelle> as a matter of fact, you do need to also import something like Data.Vector.Unboxed
02:03:13 <kuribas> I have right?
02:03:24 <bartavelle> not in the ghci snippet
02:03:31 <kuribas> well I did...
02:03:42 <kuribas> but if the code compiles for you, something is messed up...
02:03:48 <bartavelle> oh weird
02:03:51 <kuribas> or there is a bug in ghc-8.2
02:04:04 <bartavelle> you use stack or cabal ?
02:04:09 <kuribas> cabal
02:04:49 <bartavelle> then perhaps create a new sandbox and start again, it works fine with lts-8.4 for me, with cubicbezier version number bumped to 0.6
02:04:58 <bartavelle> (with stack)
02:05:05 <bartavelle> (this ghc 8.0.2)
02:05:45 <kuribas> right, I have 8.0.2
02:08:24 <AWizzArd> pacak: okay good, makes sense, thx
02:33:44 <itsu> Guys, I'm trying to do "async" operation on a Monad transformer that has IO at the bottom of its stack
02:34:01 <itsu> But I can't make it work... :-(
02:34:17 <itsu> it looks like something like this : http://lpaste.net/356065
02:35:22 <itsu> if anyone can help, it would be much appreciated
02:35:40 <Akii> itsu: use `liftIO`
02:35:49 <Akii> :t liftIO
02:35:51 <lambdabot> MonadIO m => IO a -> m a
02:36:17 <itsu> Akii: yeah I tried but I missed something I think
02:36:33 <itsu> So what I did was something like: liftIO async
02:36:38 <Akii> actually.. looks like you need "return" here :D
02:36:44 <Akii> return $ (async . ...
02:37:16 <Akii> but to execute the async you need to do IO
02:37:27 <Akii> so more like `return $ liftIO`
02:37:42 <Akii> s/execute/create
02:38:11 <itsu> Akii: if I do: liftIO async 
02:38:17 <itsu> then it doesnt compile
02:38:30 <ph88^> meh if i play youtube it totally skews my benchmarks -___-
02:38:34 <Akii> as <- liftIO $ async; return as
02:39:11 <mniip> itsu, if you want to run 'handler' inside async then you will have to get rid of your monad stack
02:39:20 <mniip> async (runApp ... handler)
02:39:47 <itsu> Akii: Couldn't match expected type ‘IO a1’
02:39:47 <itsu>                   with actual type ‘IO a0 -> IO (Async a0)’
02:39:47 <itsu>     • Probable cause: ‘async’ is applied to too few arguments
02:39:59 <itsu> so it seems you cannot liftIO functions ?
02:40:08 * hackage elm-bridge 0.4.1 - Derive Elm types and Json code from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.4.1 (SimonMarechal)
02:41:22 <itsu> mniip: I don't think I want to my handler inside async. I run it outside where I can give it my reader and stuff
02:41:26 <ertes-w> itsu: aside from the transformer law (liftIO c >>= liftIO . f = liftIO (c >>= f)), what would liftIO-ing functions even mean?
02:41:32 <ertes-w> oh, and helo =)
02:42:53 <mniip> itsu, what do you want from it then?
02:43:19 <itsu> well from my understanding, I have -- async :: IO a -> IO (Async a)
02:43:35 <mniip> right
02:43:45 <itsu> but I need something like async' :: App a -> App (Async a)
02:43:54 <mniip> then you will have to runApp
02:43:58 <itsu> which means I need to liftIO async right ?
02:44:02 <mniip> no
02:44:08 <mniip> liftIO goes one way
02:44:30 <mniip> IO (Async a) -> App (Async a)
02:44:58 <mniip> to pull this off you would need to go App a -> IO a, too but alas you cannot
02:45:17 <ertes-w> you don't necessarily need (App a -> IO a)
02:45:48 <mniip> itsu, you *will* have to disassemble your monad stack
02:46:09 <mniip> one way or another
02:46:39 <kuribas> bartavelle, cocreature: it compiles now.  Thanks, I was confused by this error.
02:46:46 <mniip> say, here's a motivating example
02:46:50 <phadej> lifted-async does the magic, but there is Safe and Unsafe variants for the reason (which is good to understand!)
02:47:17 <reactormonk[m]> itsu: a) do lots of hoist b) some mtl
02:48:09 <itsu> mniip: I really don't have any other options ?
02:48:14 <mniip> :t \m -> ReaderT (\r -> Control.Concurrent.Async.async (runReaderT m r))
02:48:15 <lambdabot> ReaderT r IO a -> ReaderT r IO (Control.Concurrent.Async.Async a)
02:48:34 <itsu> phadej: thanks, I'll give it a look ;-)
02:50:17 <itsu> mniip: I think I got what you are doing. Are you dissasembling the transformer, wrapping the value with an async and assembling it back ?
02:50:29 <mniip> yes
02:50:31 <ertes-w> itsu: no…  let's say you have (type App = ReaderT E IO), then running an App in another thread requires an E to even start…  there is no inherent connection between this thread's E and the new one's, unless you create one
02:51:31 <ertes-w> itsu: in fact 'c' in (liftIO c) doesn't even get to know the E, because it is not even an App action, but just an IO action
02:52:04 <mniip> I expected lifted-async to be a tad bit simpler
02:52:52 <merijn> mniip: MonadBase is a confusing mess, imo
02:53:03 <mniip> I figure
02:53:17 <ertes-w> mniip: what's wrong with it?
02:53:18 <merijn> mniip: Do you really need lifted async? Can't you lift async into your app?
02:53:33 <ertes-w> mniip: because of the StM?
02:54:38 <merijn> mniip: Do you Async tasks actually need anything from your App type?
02:54:47 <merijn> mniip: If so, can't you just explicitly pass it in?
02:55:05 <mniip> merijn | tee itsu
02:55:39 <itsu> ertes-w: I think I understand your point, thanks ;-) 
02:56:16 <ertes-w> itsu: my pleasure
02:56:19 <itsu> merijn: yeah I could do that, but having a reader makes it much easier to deal with 
02:56:35 <ertes-w> itsu: does it?  try it without
02:57:39 <ertes-w> itsu: the apparent ease of implicit passing that ReaderT provides is often just an illusion
02:58:04 <itsu> ertes-w: my code used to have no reader at all, so I had to pass functions (which is my reader environment) to many functions which makes my code a bit unreadable at some point
02:58:24 <itsu> so yeah, it was easier but less readable I think
02:59:14 <ertes-w> itsu: remember that you can always create an environment type that holds all the data you need
02:59:34 <ph88^> pacak, i tried making a simplified version but it doesn't speed up stuff  https://bpaste.net/show/06fccadd6280
02:59:45 <ertes-w> it's not always a good idea to do that, but it gets you 99% of the advantages you would think ReaderT would give you =)
03:01:06 <itsu> ertes-w: yeah I follow you, if I can't get any other solutions to work, I'll probably go with your idea 
03:03:09 <pacak> ph88^: Second version is a bit more readable, but  still ugly.
03:05:24 <pacak> ph88^: I see you have "-1" all over the place. Why not change lu to account for that?  Or even better - move all elements by 1?
03:05:31 <pacak> Or change range
03:06:00 <merijn> itsu: You can just wrap "liftIO . async" with something that grabs the readert and pass it to the reader inside the async
03:10:45 <itsu> merijn: are you saying the same thing as mniip ? Dissasemble, wrap with async, reassemble ? not sure I understand your "grabs the readerT and pass it to ..."
03:12:12 <merijn> itsu: I'm saying the same thing, except "write a wrapper that does it"
03:13:06 <itsu> ah ok, gotcha ! thanks merijn 
03:13:14 <merijn> itsu: "myAsync :: ReaderT Env IO a -> App (Async a)" and inside you grab the Env from App, run the ReaderT to get an IO and pass that to async + liftIO
03:13:24 <merijn> itsu: Assuming you wanna do this a lot in your code, of course
03:15:06 <itsu> yeah, I understand :-)
03:18:39 <Jinxit> so the Writer monad is very nice for constructing "linear" things like monoids, is there something similar for building tree structures?
03:20:41 <quchen> No, but you can write your own
03:24:24 <ertes-w> Jinxit: if your tree structure happens to be a free monad, then:  joinFreeT :: (Monad m, Traversable f) => FreeT f m a -> m (Free f a)
03:24:43 <Jinxit> it could be i suppose, not sure
03:32:01 <ADG_> `cabal install ghc-mod` isn't working, getting https://hastebin.com/ipobukumav.pas
03:45:36 <Reisen> I'm struggling a little bit to write a type family that can flatten a nested Either into a type level list of types
03:46:10 <Reisen> type family Flatten a :: [*] where; Flatten (Either a b) = Flatten a ': Flatten b ': []; Flatten a = a
03:46:33 <Reisen> Doesn't really get anywhere near, and I don't think I can do the equivelent of ++ at type level unless I'm mistaken
03:48:42 <lyxia> you can
03:49:06 <Reisen> Solution just jumped out at me
03:49:26 <Reisen> I can define a type family (x :: [k] ++ y :: [k])) :: [k] and use that
03:49:54 <tsahyt> when profiling an algorithm that builds up a large intermediate structure that cannot be collected until the end, are really low productivity values (<35%) normal?
03:50:37 <lyxia> Dependent Haskell claims another casualty!
03:54:44 <pacak> tsahyt: I've seen code with 50% productivity that worked orders of magnitude faster than code with 99.9% productivity.
03:55:41 <tsahyt> why would that be?
03:57:27 <pacak> author of 99.9% productivity solution was especially proud of it, but in reality code was doing a ton of stupid computations that don't generate much  garbage so there's no GC overhead.
03:58:02 <tsahyt> in my case I don't think the problem is because there's too much garbage, it's simply because a lot of data accumulates and gets copied into the new generation every time, again and again
03:58:20 <pacak> You can try organizing this data so it's easier to copy it.
03:58:35 <pacak> Unboxing constructors, using vector and so on.
03:59:08 <tsahyt> it's a HashMap, and there's little I can do to make it more compact while still preserving the complexity of the important operations
03:59:10 <pacak> Is it leaking memory due to laziness by any chance?
03:59:18 <tsahyt> nope, it behaves just as expected
04:00:44 <pacak> You can run memory profiling to see what's in memory.
04:00:52 <pacak> Is it something you expect?
04:01:27 <tsahyt> ah yes, about that, it's a library and I've got an executable listed in the cabal file which contains a simple profiling benchmark. when heap profiling I somehow get no cost centers within the library
04:01:57 <tsahyt> even with explicit -fprof-auto in the ghc options for the library
04:02:11 <merijn> tsahyt: Using cabal?
04:02:14 <tsahyt> merijn: stack
04:02:20 <pacak> Ugh
04:02:29 <tsahyt> stack build --executable-profiling --library-profiling
04:04:09 <tsahyt> huh, enabling -XStrict makes a tangible difference, so there's that
04:05:28 <pacak> So thunks.
04:05:35 <pacak> Then profilier is your best friend.
04:05:46 <tsahyt> no, the productivity is still abysmal
04:05:50 <tsahyt> but it's a bit better
04:06:19 <tsahyt> up to 43% now
04:08:03 <pacak> What are keys/values in this hashmap?
04:08:53 <tsahyt> HashMap a (a, b, c), all of which are type parameters of the function
04:09:16 <tsahyt> a represents nodes in the state space graph, b are edge labels, c are edge weights.
04:09:53 <tsahyt> basically the map keeps track of the current best edge between two nodes
04:11:47 <pacak> replace tuple with Foo !a !b !c, maybe with unbox
04:13:15 <kuribas> I wonder if C isn't better than haskell.  In C you just write an explicit loop, mutating a variable, and be done with it.  In haskell you must choose, a recursive function, a fold, an accumL, state monad, ST monad, IOref, so many different ways.
04:14:32 <tsahyt> kuribas: better for what exactly
04:14:45 <kuribas> tsahyt: development speed
04:15:05 <kuribas> for low level stuff, vector processing etc...
04:15:11 <tsahyt> kuribas: I don't think so. I'd just spend most of my day debugging segfaults and complaining about the lack of abstraction capabilities
04:15:50 <tsahyt> that said if all else fails I do implement low level stuff in C and then pull it back into Haskell via FFI at the first opportunity
04:16:06 <pacak> kuribas: https://hackernoon.com/are-mutable-references-in-haskell-fast-f095f4144977?source=linkShare-5d40d36b9bda-1496319654
04:16:49 <kuribas> Well, I suppose a good abstraction gives better readable code.
04:17:15 <tsahyt> I'd also say that all the options that haskell provides over just writing a loop are well worth having
04:17:42 <kuribas> I am talking about low-level code though, like number crunching, vector manipulation, etc...
04:18:20 <tsahyt> I've found that most of the time, writing a reasonably idiomatic transformation using the things provided by vector is sufficiently fast though
04:20:01 <kuribas> yeah, I think most of the speedup in language comparisons comes from using SSE, etc...
04:20:10 <kuribas> which is very limited in haskell
04:20:28 <merijn> kuribas: Compared to what?
04:20:39 <tsahyt> kuribas: last I checked, gcc also didn't just automatically generated code using the packed SSE instructions
04:20:47 <tsahyt> at least not for anything but trivial examples
04:20:49 <merijn> kuribas: The only languages that I know that really leverage SSE, etc. are C/C++/etc
04:21:00 <kuribas> merijn: yes, that's what I meant
04:21:01 <tsahyt> but that was a few years ago
04:21:16 <merijn> tsahyt: Modern GCC is pretty good at vectorising stuff BUT, you *have* to specify an architecture flag
04:21:24 <tsahyt> ah that might be why
04:21:42 <merijn> kuribas: Yeah, but the fact that you even *can* access SSE in Haskell is pretty unique compared to everything that isn't C
04:21:46 <tsahyt> merijn: but even without that flag it still generates code using non-packed SSE instructions for FP maths
04:22:03 <tsahyt> wait, you can use SSE in haskell?
04:22:05 <kuribas> merijn: the 5x faster code in C usually has agressive manual optimization using intrinsics.
04:22:31 <kuribas> tsahyt: some instructions yes, but only for a particular version of LLVM.
04:23:14 <merijn> tsahyt: You can access vector instructions, yes
04:23:20 <merijn> tsahyt: See GHC.Prim
04:23:27 <pacak> kuribas:  You can use intrinsics in haskell as well, just in a bit more perverted way.
04:23:37 <kuribas> pacak: via C?
04:23:47 <pacak> And to my experience most of speedups come from better algorithms.
04:23:51 <merijn> tsahyt: Plus, you can write your own Cmm primops and have GHC hook those in
04:23:54 <tsahyt> in my experience, intrinsics are a pain to use in C too
04:23:56 <pacak> kuribas: yes. primops and foreign primops
04:24:11 <tsahyt> merijn: that sounds interesting, I should look into that
04:24:12 <merijn> tsahyt: So if you think the FFI is "too slow" you can go even faster
04:24:41 <merijn> tsahyt: I would start by browsing the modules in the ghc-prim package and googling for "foreign primops"
04:25:06 <pacak> http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel - or this
04:25:08 <tsahyt> well I have no immediate use for it. I can't really make use of vectorized FP maths for graph search unfortunately
04:25:24 <tsahyt> but it sounds very interesting. thanks for mentioning it
04:25:58 <merijn> tsahyt: What kinda graph search? :)
04:29:40 <kuribas> merijn: does that mean you can define primops without modifying the compiler?
04:29:53 <merijn> kuribas: Yes!
04:29:59 <kuribas> that pretty cool
04:30:14 <merijn> kuribas: https://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps#Foreignout-of-linePrimOpsandforeignimportprim
04:30:42 <tsahyt> merijn: this is just a pretty standard A*. it's part of a larger search library that I've been working on lately
04:31:18 <tsahyt> since no existing library really fit the bill. the astar package can't deal with loops for example and really only has A*. there's another one that is implemented in a very nice way but iirc it wasn't performing that well.
04:33:20 <tsahyt> pacak: about your suggestion for Foo !a !b !c earlier, how would GHC even unpack polymorphic fields?
04:37:44 <tsahyt> since this is still open, I guess it doesn't. https://ghc.haskell.org/trac/ghc/ticket/7647
04:37:45 <osa1> kuribas: http://hackage.haskell.org/package/atomic-primops does that
04:39:12 <kuribas> osa1: interesting
04:40:35 <osa1> ghc is pretty great. I wonder if any other compilers allow this
04:41:05 <merijn> osa1: In C/C++ you would usually do this with inline ASM
04:42:01 <osa1> ah, right. we can count rustc too as it also has some kind of inline asm support
04:42:57 <tsahyt> merijn: the library I mentioned https://github.com/tsahyt/heuristic-search
04:43:05 <tsahyt> it's probably far from usable atm
04:43:34 <merijn> tsahyt: I mostly care about the graph algorithms people are using to see if there's anything interesting I could copy :p
04:44:00 <bollu> Guys, I'm trying to collect error messages produced by GHC that would be difficult / unintuitive. I'd appreciate it if whenever someone submits some piece of code that they find difficult to understand the errors for, if they could send a PR or something here: https://github.com/bollu/hask-error-messages-catalog
04:44:13 <tsahyt> in terms of heuristic search algorithms, there haven't been many *really* interesting developments lately.
04:44:20 <bollu> BTW, if anyone has examples that create pathological error messages, please do open a pull request or send me an email or something
04:44:26 <tsahyt> I guess the new kid on the block is monte carlo tree search for game playing
04:44:32 <tsahyt> e.g. used in alphago
04:44:54 <tsahyt> I've taken an interest in beam stack search lately, since it has a bunch of really interesting properties all in one, but haven't gotten around to implementing it yet
04:45:18 <LKoen> tsahyt: for the game of go at least, monte carlo tree search has been used with great results since 2006
04:45:35 <tsahyt> indeed, it's not exactly new anymore
04:45:40 <LKoen> I know the chess program Komodo uses it too though I don't have a year
04:46:15 <tsahyt> I should probably investigate whether it makes sense to add MCTS to this library
04:46:34 <tsahyt> iirc there are quite a few things that you can tweak about it, so it might not make that much sense to provide an off the shelf implementation to begin with
04:46:45 <tsahyt> but maybe it's possible to provide a nice API to a flexible implementation
04:46:46 <bartavelle> kuribas: what did you do to fix the build ?
04:47:02 <kuribas> bartavelle: rm -rf .ghc :)
04:47:41 <tsahyt> the interesting thing about beam-stack search is that it can operate with limited memory, is still optimal, and is anytime. the downside is that weights need to be uniform.
04:53:27 <bartavelle> kuribas: well, that's the kind of bugs that suck :/
04:55:10 <kuribas> bartavelle: I probably need to use sandboxes or stack...
04:55:29 <bartavelle> or new build, although I have never tried ti
05:01:11 <merijn> Persistent doesn't have a convenient method for dealing with vectors in datatypes, does it?
05:05:29 <bartavelle> merijn: do you mean json-encoded columns, or results of things like array_agg ?
05:05:57 <merijn> bartavelle: I mean "I have datatypes with LOTS of fields and dealing with them using record syntax is a pain in the neck"
05:06:34 <bartavelle> then I am not aware of any convenient solution :/
05:07:44 <merijn> I wish I had the time to fix opaleye-sqlite so I could use that. It seems like it is far more convenient for dealing with large rows and projections
05:08:15 <merijn> bartavelle: I have stuff like: http://lpaste.net/4062186489532907520 and will probably add more fields into the future...
05:09:02 <bartavelle> merijn: and you would like to be able to use `Vector Double` instead of `GraphProp` ?
05:09:41 <merijn> bartavelle: Something like that
05:10:49 <merijn> Alternatively, I suppose I could do "GraphProp { graphId GraphId; type Text; value Double }", but that seems like it'd be unnecessarily inefficient when you wanna group a bunch of stuff
06:02:44 <merijn> heh
06:03:44 <merijn> cabal is complaining that it can't build persistent-sqlite + persistent, because aeson-1.2.0 isn't allowed, despite all dependencies allowing aeson versions older than that...
06:03:48 <merijn> I'm thoroughly confused
06:04:11 <ph88^> if i have a Conduit which produces a tuple and i don't use an element of that tuple will it get optimized away ?
06:04:18 * merijn sighs
06:04:30 <merijn> missing .* on a version bound...
06:09:02 <sproingie> it'll be optimized away in the sense that laziness will keep said element as a thunk
06:10:22 <sproingie> doing any pattern matching on it will force it tho
06:12:48 <ph88^> sproingie, what if i pattern match with _  ?
06:12:59 <Akii> also doesn't evaluate afaik
06:17:54 <ph88^> if i want to lookup key-value but there are just 3 combinations am i better of with a normal list or still with hashtable or other solution ?
06:18:37 <merijn> ph88^: What's wrong with Map?
06:19:46 <ph88^> nutting
06:20:03 <geekosaur> for just 3 combinations I'd just use an alist; Map seems like both cognitive and likely computational overhead for something that short
06:25:00 <bollu> I don't understand the difference between smallstep and bigstep semantics
06:25:06 <bollu> could someone explain this to me?
06:25:25 <sproingie> if you're looking for reusable and polymorphic, go for a Map from the start.  otherwise, alist will do the job nicely
06:25:40 <bollu> bigstep seems to be like assigning a dentational semantics?
06:25:46 <bollu> but, well, aren't they both supposed to be operational?
06:25:53 <sproingie> there's probably a Map instance for [(k,v)] anyway
06:28:50 <geekosaur> Map's a type not a typeclass
06:29:48 <geekosaur> there have been various attempts to make container typeclasses, but in general they add excessive overhead for very little gain
06:31:35 <geekosaur> (largely because you only care during earlyish development when performance isn't that important; once you settle on one, there is often little reason to change it after unless you underthought the design in the first place)
06:33:08 * hackage inliterate 0.1.0 - Interactive literate programming  https://hackage.haskell.org/package/inliterate-0.1.0 (glutamate)
06:35:35 <merijn> Can anyone recommend a library for globbing/traversing files/directories?
06:37:21 <lambdamu_> how about filemanip?
06:37:31 <Athas> merijn: I've used directory-tree for simple things.
06:38:19 <merijn> Athas: I just need "recursive descent + glob" to ingest large numbers of benchmark output :)
06:38:25 <merijn> Nothing fancy
06:38:46 <Athas> Well, directory-tree is good for turning a directory name into a list of FilePaths.
06:38:55 <Athas> Then you can slurp it on your own.
06:47:26 <cocreature> bollu: smallstep is “in one step of evaluation the term X evaluates to Y”. bigstep is “if I keep evaluating X until it’s a value I get Y”
06:49:10 <sproingie> bigstep certainly sounds closer to denotational
06:51:53 <bollu> cocreature: ah, I see
06:52:03 <bollu> cocreature: so if I consider "chains of smallstep" I get bigstep?
06:55:58 <merijn> hmmm
06:56:29 <merijn> The only way to "name" the field of an ADT is record syntax, right? Kinda annoying when I don't have overlapping fields but would like to name fields as documentation
06:56:43 <shapr> lens?
06:57:08 <merijn> shapr: That doesn't really help document the actual ADT, though
06:57:16 <tsahyt> is there a really fast priority queue implementation for within ST somewhere?
06:57:52 <AWizzArd> When Haskell compiles, are then all type signatures lost in the compilation result? What if it is a lib, closed-source? Will I have all type signatures?
06:57:52 <tsahyt> just wondering as I'm about to take hashtables for a spin and see how it compares for this algorithm
06:58:01 <tsahyt> so I might as well switch out the queue type as well
06:58:09 <merijn> AWizzArd: What do you mean with "will I have all type signatures?
06:58:20 <AWizzArd> merijn: in the repl, I would like to try    :t foo
06:58:38 <AWizzArd> Will ghci be able to tell me the type signature, when foo comes from a pre-compiled lib?
06:59:04 <merijn> Honestly, I don't know
06:59:05 <sproingie> it can and does
06:59:34 <sproingie> i believe that info is in .hi files
07:00:13 <byorgey> bollu: essentially, yes, though the way you would define it is different
07:00:34 <AWizzArd> Okay, I saw those files before, indeed.
07:00:43 <exio4> I am using `hint`, loadModules is throwing me some weird errors, any ideas? http://dpaste.com/0K729EG 
07:00:46 <AWizzArd> Maybe hi is for Haskell Information?
07:00:57 <exio4> (module `X.Y.Z` is a package module)
07:01:07 <byorgey> bollu: for example suppose we have a language with natural number literals and addition.  A bigstep semantics would be something like:  if t1 => v1 and t2 => v2  then  t1 + t2 => v1 + v2
07:02:08 <byorgey> bollu: whereas small step would be something like     v1 + v2 -> [v1 + v2]  (i.e. if we have the addition of two natural numbers then it reduces to their actual sum],  and  if  (t1 -> t1') then  t1 + t2 -> t1' + t2,  and if   (t2 -> t2') then t1 + t2 -> t1 + t2'
07:02:19 <sproingie> AWizzArd: haskell interface, actually
07:03:45 <bollu> byorgey: how is the first different from denotation>
07:06:11 <exio4> all the similar errors I found online are related to own modules, but I am trying to load Data.Functor, which.. shouldn't that many issues? 
07:09:23 <exio4> setImportsQ replaced it with a single error related to Web.Telegram.API.Bot
07:11:16 <geekosaur> exio4, "is a package module" means you need to load the package before you can load the module info
07:12:46 <exio4> geekosaur: how could I do that? I don't really know how to use hint 
07:13:46 <exio4> now I have another issue though, I can't make it find Web.Telegram.API.Bot -- which I installed on the sandbox, so I am guessing there's something I am missing
07:13:49 <geekosaur> hm. this is actually more ghc-api level stuff. (and it occurs to me Data.Functor should be in base...)
07:14:39 <exio4> geekosaur: I replaced loadModules (which seem to be for .hs files you actually have) with setImportsQ and it's now loading Data.Functor
07:14:52 <geekosaur> same thing again, it knows nothing about sandboxes, it AGAIN does not simply find a package in the package db that has that module and magically load fo ryou because it can't know if that's the one you actually need
07:15:39 <exio4> indeed, how could I use sandboxes with hint, though?
07:16:13 <shapr> I'm using spock and sqlite, but I'd prefer to produce browser based field validation so users will know not to enter text into a number field. Is there a Haskell lib that does that?
07:17:12 <geekosaur> of course the example doesn't show any packages outside of base x.x
07:17:26 <ertes-w> shapr: there is digestive-functors, but not a spock binding, as far as i see…   you would have to write that one yourself
07:17:34 <shapr> ok, thanks
07:17:58 <exio4> geekosaur: yeah, I thought running it from inside the sandbox (cabal run) would do the trick... it didn't :P
07:18:10 <geekosaur> yes, you are expecting magic
07:18:11 <cocreature> bollu: a terminating chain of smallsteps
07:18:26 <sproingie> for that particular case, can use the html5 pattern attribute
07:18:37 <geekosaur> I think in this case you probably will be happier (right up until it screws you) with http://hackage.haskell.org/package/hint-0.6.0/docs/Language-Haskell-Interpreter.html#v:installedModulesInScope
07:18:39 <cocreature> i.e. one where the last smallstep leads to a value that doesn’t evaluate further
07:18:56 <geekosaur> because that way you can pretend it's all magic underneath and it all magically works without any thinking
07:19:10 <geekosaur> right up until it picks the wrong package and you have to actually do it right
07:19:32 <bollu> cocreature: ah, right. fair
07:20:07 <cocreature> bollu: one important consequence of that is that you can’t talk about nonterminating programs using bigstep semantics
07:20:24 <butterthebuddha> What would be the most efficient way of going about creating a list of the fibonacci numbers?
07:20:34 <bollu> cocreature: interesting, I hadn't considered that
07:20:35 <geekosaur> hmf. looks like if you need to actually control which packages it uses, you get to use ghc-api directly instead of hint
07:20:47 <bollu> cocreature: dang, I should take the popl class at uni sometime.
07:20:54 <butterthebuddha> Because to find the number at position n, I'm going to have to recurse down and calculate all the values from n = 1
07:20:59 <merijn> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs -- butterthebuddha 
07:21:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:21:06 <exio4> geekosaur: I don't see how installedModulesInScope will do any kind of magic if it can't originally find it at all :/ 
07:21:28 <cocreature> bollu: iirc sf also contains a decent explanation of that
07:21:46 <merijn> butterthebuddha: You only have to recurse that much if you write it the naively recursive way :p
07:22:03 <merijn> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 1000000 -- blazing fast! Whooo!
07:22:04 <geekosaur> exio4, that is because you didn't pay attention to what I said about packages vs. modules
07:22:05 <lambdabot>  *Exception: stack overflow
07:22:12 <bollu> cocreature: I see
07:22:12 <merijn> awww
07:22:12 <byorgey> bollu: in this particular simple language (natural numbers and addition) there is not much difference between denotational and big-step semantics
07:22:19 <bollu> cocreature: hm, I did it till chapter 5
07:22:21 <merijn> Oh, lang of strictness...sad
07:22:23 <bollu> cocreature: I should continue it sometime
07:22:26 <geekosaur> it "doesn't find it" because it does not load packages other than base by itself
07:22:31 <bollu> byorgey: ah, I see
07:22:34 <merijn> Is there a strict zipWith?
07:22:41 <cocreature> bollu: it’s a great book, it’s definitely worth continuing
07:22:46 <bollu> byorgey: what's the minimal language where there is a difference?
07:22:51 <geekosaur> if you set that flag, it will happy-go-lucky load the first package it finds containing that module, and you get to hope that's the right one
07:23:01 <bollu> cocreature: yep, but I'm currently trying to understand more about GHC/STG/LLVM/compilers :)
07:23:08 <bollu> cocreature: too many interests :P
07:23:10 <exio4> geekosaur: OK, I'll try
07:23:12 <merijn> > let fibs = 0:1:zipWith (\!x !y -> x + y) fibs (tail fibs) in fibs !! 1000000 -- bangpatterns?
07:23:15 <lambdabot>  <hint>:1:32: error: parse error on input ‘->’
07:23:18 <byorgey> bollu: but if you imagine e.g. a language with lambdas and function application, a denotational semantics would just say "the denotation of a lambda is a function", whereas a big-step semantics would say things like "if f reduces to a lambda and x reduces to a value, then f x reduces to such-and-such substitution applied to the body of the lambda" or whatever.
07:23:37 <bollu> byorgey: hm.
07:23:47 <lambdamu_> Any ideas on this? Can I coax the compiler into deriving the instance? http://lpaste.net/356067
07:23:53 <bollu> byorgey: so, bigstep feels more like .. reduction rules?
07:24:03 <geekosaur> and it looks like if you need something else, you either use ghc-api directly or you can try using http://hackage.haskell.org/package/hint-0.6.0/docs/Language-Haskell-Interpreter-Unsafe.html#v:unsafeRunInterpreterWithArgs and pass -package parameters for the exact packages to use
07:24:08 <sproingie> > let fibs = fix $ scanl (+) 0 . (1:) in take 10 fibs
07:24:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
07:24:11 <byorgey> bollu: yes.  big step and small step are both reduction rules.
07:24:51 <bollu> byorgey: but, I always thought of operational semantics as (State -> State). I guess you could see that as "reduction rule"
07:24:57 <exio4> geekosaur: thanks, I didn't thought of going directly with ghc-api, I'll be playing with it
07:25:04 <bollu> byorgey: like, operational = "crank a machine"
07:25:16 <bollu> denotational = "compile to a pure functional programming language" :]
07:25:28 <byorgey> bollu: denotational = "compile to math" =)
07:25:32 <cocreature> it’s more like "crank an abstract machine"
07:25:42 <merijn> hmmm
07:25:45 <cocreature> and you can choose a machine that does a reduction at each step
07:25:47 <bollu> byorgey: "by the great power of curry howard, our statement are equivalent"
07:25:53 <bollu> cocreature: yeah
07:25:53 <byorgey> bollu: =D
07:26:16 <merijn> So I'm using hdevtools to do error highlighting, etc. But whenever I depend on a library with TH it becomes wicked slow due to always recompiling everything. Any suggestions how to avoid that?
07:26:32 <exio4> geekosaur: (fwiw, when I replaced loadModules with setImportsQ -- I could now load Data.Functor, and the error changed to "module not found", which persists even with that setting enabled) http://dpaste.com/23SY23V
07:26:35 <bollu> cocreature: I actually want to write a library that abstracts over common patterns in abstract machines, like heap, stack, environment, etc
07:26:45 <bollu> cocreature: because I'm considering implementing both push/enter & eval/apply, to compare
07:26:51 <bollu> I don't want to rewrite the code for both of them
07:27:14 <geekosaur> exio4, yes, you said that before
07:27:15 <bollu> does anyone know of anything similar? :)
07:27:55 <sproingie> so, an abstract abstract machine? :)
07:28:06 <geekosaur> and yes, I understand you still thinkt hat changes something
07:29:26 <geekosaur> what it's supposed to change is your incorrect assumption that you can completely ignore the notion of packages and pretend every package in existence is already loaded for you. I gave you a way to pretend that's true (that will bite you the first change it gets) and a way to tell it which packages to bring into scope
07:29:52 <exio4> ah, got it
07:31:28 <bollu> sproingie: more like, lego for abstract machines :)
07:31:48 <geekosaur> the other alternative is teach ghci to read cabal files directly instead of relying on something else to read it and invoke ghci appropriately (stack and cabal-install both do this)
07:32:02 <bollu> exio4: if the error you got was uninformative, please add a PR with a file or something to: https://github.com/bollu/hask-error-messages-catalog
07:32:11 <geekosaur> I mean change ghc-api
07:32:13 <bollu> exio4: I'm trying to collect unintuitive error messages in haskell
07:32:47 <geekosaur> and I don;t think that is going to happen, nor do I think either stack or cabal-install will sprout hint-alike interfaces that do that for you
07:34:15 <butterthebuddha> merijn: care to explain your method?
07:34:34 <geekosaur> ...tbh this and some annoying corner cases that neither stack nor cabal-install can get right actually indicate that this *does* belong in ghc-api. but that's something of a hard thing to sell
07:34:42 <merijn> butterthebuddha: "tail l" returns l with the first element lopped off
07:35:27 <merijn> butterthebuddha: So "zipWith (+) l (tail l)" adds the elements of 'l' offset by 1 (since 'tail l' starts at 1)
07:36:07 <merijn> butterthebuddha: So it's saying "fibs" is the list starting with the elements '0' and '1', followed by the list created by doing zipWith on fibs and (tail fibs)
07:36:10 <geekosaur> especially since the relevant interfaces to cabal files are not standardized and nobody wants to standardize them because they're still changing too frequently
07:36:20 <tsahyt> nice. with hashtables instead of unordered-containers I've now easily broken the 1 million nodes per second barrier. now up to 1.8 million / s.
07:36:39 <tsahyt> unfortunately one benchmark now either leaks space or just runs out of memory
07:36:50 <merijn> butterthebuddha: The first element of "zipWith (+) fibs (tail fibs)" ends up being "0 + 1" (0th and 1st index of fibs) and then it just keeps going summing things offset by one
07:36:53 <sproingie> take that, harrop
07:37:36 <hyperfekt> Hello everyone, I'm currently doing the 99 questions (https://wiki.haskell.org/99_questions) and wanted to ask for feedback on my solution to problem 5, reversing a list:     myReverse = foldl (flip (:)) []
07:37:46 <tsahyt> also unfortunately, this still makes it much slower in terms of nodes throughput than the IDA* implementation, which hangs around at 4.1 million / s without even any optimizations yet
07:38:03 <hyperfekt> The solutions only include a quite weird looking version with foldr, is there any reason for that?
07:38:10 <tsahyt> but I suppose for less trivial problems the properties of the algorithms involved will make that irrelevant
07:38:49 <sproingie> you can write foldl in terms of foldr.  and vice-versa for finite lists
07:39:18 <hyperfekt> Nevermind me, I'm not very smart. ^^ Forget that I asked!
07:39:26 <sproingie> hyperfekt: if you're reversing a list, it's obviously finite.  so your answer is pretty much perfect
07:40:33 <hyperfekt> sproingie: Turns out that that's the prelude definition, I just skipped throught that when I read the words 'not very readable' and came up with it on my own (as a second version, the first one was the naive recursive one)
07:44:35 <tsahyt> is there no version of foldlM that is strict? or is this not necessary for the monadic version?
07:45:41 <sproingie> it would depend on the monad
07:54:48 <ertes-w> tsahyt: which hash table implementation are you using?
07:57:40 <merijn> There's no convenient way to rate-limit async, is there?
07:58:19 <merijn> Suppose I need to checksum a few 100 files, if I naively use async to do 1 async per file I will just run out of file descriptors and crash
07:58:23 <drdo> Is there an easy way (in ghc) to perform some computation with a memory limit?
07:58:33 <merijn> drdo: Not really
07:58:57 <quchen> You can limit the heap/stack size using RTS flags, but not from within the program
07:59:45 <cocreature> there is also enableAllocationLimit which you can use from a program
07:59:55 <cocreature> it’s per thread iirc
08:00:26 <cocreature> merijn: there is async-pool but it’s been a while since I’ve looked at it
08:01:07 <merijn> cocreature: hmm, might just be easier to stuff a semaphore in there
08:01:25 <drdo> cocreature: That seems useful, but what I rather want to control is how much memory is used at once, not allocation
08:01:31 <merijn> Anyone know how I can query the ulimit for file descriptors?
08:01:45 <drdo> In particular, GHC is free to do more agressive GC to stay under
08:01:59 <tsahyt> ertes-w: the hashtables package
08:02:06 <merijn> Or should I just hard limit the number of FD at a few 100 and just assume it'll work
08:02:14 <tsahyt> in particular Data.HashTables.ST.Basic
08:02:43 <quchen> merijn: I think it was monochrom who called ulimit a »lazy yes-man«, so I wouldn’t count on it imposing any limits
08:02:47 <cocreature> drdo: I don’t think that’s possible
08:02:51 <merijn> drdo: Can you clarify what exactly you're trying to do?
08:03:04 <cocreature> at least not per operation in a running program
08:03:28 <merijn> quchen: That holds true on desktops, yes. But in shared environments ulimit tends to be less generous
08:03:46 <drdo> merijn: Allowing remote running of some algorithm, but limiting memory and runtime
08:03:50 <merijn> quchen: Not to mention that even without limit you can still run out of file descriptors when processing ginormous lists of files
08:04:43 <k0001_> merjin: ulimit -n? 
08:05:13 <merijn> k0001_: Yes, I know that. But I wanna know if there's a haskell library that lets me query that from my program
08:05:23 <merijn> unix package doesn't seem to have anything
08:06:04 <merijn> oh, maybe it does
08:06:14 <merijn> System.Posix.Resource seems to have it :)
08:16:18 <geekosaur> note that there are both soft and hard limits; the difference is you can adjust the soft limit down or up to the hard limit, the hard limit can only be adjusted downward without root
08:16:36 <geekosaur> and this matters on os x where the hard limit is reasonably high but the soft limit defaults to something fairly small
08:17:02 <ertes-w> tsahyt: then they must have improved it a lot…  in my last benchmark unordered-containers actually outperformed all implementations of the hashtables package
08:17:10 <ertes-w> a few months ago
08:17:27 <tsahyt> ertes-w: I did benchmark them a few months ago too and had the opposite result iirc
08:17:45 <tsahyt> I don't have the numbers anymore though
08:17:55 <tsahyt> maybe I screwed up my benchmark
08:18:40 <tsahyt> ertes-w: what I noticed today was that it performed worse on small examples and pulled ahead around the 10000 node mark
08:19:15 <ertes-w> tsahyt: i should benchmark again with a real application
08:20:01 <ertes-w> also i'm a bit worried about unordered-containers due to <https://github.com/tibbe/unordered-containers/issues/147>, which is why i'm currently using 'containers' even for string keys
08:20:42 <ertes-w> (the issue is closed, but read the last couple of comments)
08:22:59 <merijn> hmm
08:23:34 <merijn> Is there some library like conduit that can stream results from async operations first come-first serve
08:23:47 <tsahyt> ertes-w: then why was this even closed?
08:24:03 <tsahyt> this does not look very good
08:24:18 <tsahyt> luckily I never ran into this problem. I've been using unordered-containers quite a lot lately
08:25:47 <ertes-w> merijn: concurrent-machines?
08:25:56 <ertes-w> tsahyt: i don't know
08:27:07 <tsahyt> on the one hand I always run into these problems where performance is very important. on the other hand they all parallelize really badly, so I guess I'm unlikely to run into this bug
08:27:09 <ertes-w> i guess it happens with a very specific concurrency pattern
08:27:23 <merijn> ertes-w: Using something other than conduit leaves me needing to convert to conduit since I'm stuck with that from some dependencies
08:27:43 <geekosaur> I think it got closed because it got filed upstream as a ghc bug
08:28:18 <geekosaur> but if I understood *that* discussion correctly, ghc devs think the code in question is dubious at best
08:28:36 <merijn> It seems weird that async doesn't support somehow streaming a bunch of results in a first-to-complete oder
08:28:39 <AWizzArd> Can one use unsafe arrays in Haskell, as the ones that one finds in C?
08:28:48 <ph88^> hey guys can someone give an advice on how to refactor this code? https://bpaste.net/show/7dff1740ea05 the thing is i don't want to do IO () but return (p, st', ppd, vvv, snk) (and similar variables) .. but when i put put that return it doesn't match the type of my putStrLn's anymore ..
08:28:58 <merijn> AWizzArd: Sure
08:29:00 <ph88^> AWizzArd, yes you can use pointers too
08:29:02 <tsahyt> AWizzArd: yes you can, but it's very unlikely that it is what you really want
08:29:08 * hackage uri-bytestring 0.2.3.3 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.2.3.3 (MichaelXavier)
08:29:10 <AWizzArd> tsahyt: I really want that.
08:29:15 <tsahyt> why?
08:29:35 <tsahyt> just asking out of curiosity
08:29:36 <AWizzArd> tsahyt: Because I want to use it for evoling trading strategies, and I have some hundred gigs of data that needs to fit into ram.
08:29:57 <AWizzArd> Once that data has been loaded it's read-only anyway, and I want as little performance cost as possible.
08:29:58 <ph88^> AWizzArd, you can use Vector Unboxed instead of arrays
08:30:10 <AWizzArd> ph88^: what would the advantage be?
08:30:25 <tsahyt> the advantage is an interface that doesn't drive you insane
08:30:35 <ph88^> they are like "managed arrays" .. with more convenience .. but they should still be fast and not use more memory
08:30:36 <tsahyt> storable vectors are really just C arrays underneath
08:30:39 <AWizzArd> tsahyt: in Java for example each array access is guarded against being out of bounds. I don’t even want such checks, I just want the data.
08:30:48 <tsahyt> vector gives you that option
08:30:51 <tsahyt> see unsafeLookup etc
08:30:58 <tsahyt> and yes if you're out of bounds that will segfault
08:31:00 <ph88^> ye you can still go out of bounds with vector
08:31:03 <AWizzArd> That sounds good then.
08:31:21 <AWizzArd> I want that, because I know I will always address only existing items.
08:31:29 <ph88^> AWizzArd, https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Unboxed.html
08:31:39 <tsahyt> everybody always knew that they were only going to address existing items ;)
08:31:48 <ph88^> AWizzArd, what is your data type you want to put in the vector ?
08:31:51 <pja> tsahyt: :)
08:33:03 <ph88^> AWizzArd, do you know where to get hundreds of gigs of trading data on the cheap ?
08:33:07 <tsahyt> hmm either the heaps package is amazingly fast, or my benchmark is off
08:33:17 <tsahyt> the fact that it doesn't have an NFData instance doesn't help :/
08:34:45 <c_wraith> tsahyt: using nf for benchmarking data structure operations can often end up lying to you by adding a bunch of overhead
08:35:11 <tsahyt> ah because it would need to traverse the whole thing one more time, right?
08:35:14 <c_wraith> yes
08:35:17 <AWizzArd> ph88^: well, I’m collecting this myself.
08:35:22 <ph88^> sweet
08:35:28 <ph88^> if only i had the time :P
08:35:45 <ertes-w> merijn: it should be easy enough to convert to and from conduit, as long as you don't use any of the advanced features of MachineT
08:35:50 <AWizzArd> ph88^: I suggest you to write software that works with your own broker, and records the data.
08:36:36 <ph88^> AWizzArd, you recorded everything ?
08:36:44 <tsahyt> yes that was indeed the problem
08:36:52 <tsahyt> heaps is still a tiny bit faster than the IntPSQ though
08:37:00 <tsahyt> for findMin that is
08:38:11 <AWizzArd> ph88^: not everything, but only data that is interesting for me, for trading.
08:38:20 <ph88^> that's nice :)
08:38:23 <ph88^> if only i had the time :P
08:44:09 <AWizzArd> ph88^: well, the idea is that such a recorder is a very small program. And when you have it then you personally have to spend no time anymore. Your computer will do the recording while you work and sleep.
08:44:20 <ertes-w> tsahyt: indeed, you should never force NF for benchmarking…  instead make sure that WHNF = NF
08:44:22 <AWizzArd> Doing this in Haskell will provide extra joy :)
08:44:24 <ReinH> AWizzArd: a storable vector will have a pretty compact representation
08:44:45 <AWizzArd> What is the difference between unboxed vectors and arrays? Just the user interface?
08:44:49 <c_wraith> ertes-w: well, that depends on what you're benchmarking.  nf is great if you want to test the time to create a whole lsit of something.
08:44:53 <ReinH> A storable vector of Word8 is a contiguous sequence of bytes plus some bookkeeping.
08:45:12 <c_wraith> ertes-w: it's one of those situations where no rule of thumb is right - you just have to know what you're doing.
08:45:20 <ReinH> so you can, e.g., mmap directly into a storable vector
08:45:44 <ertes-w> c_wraith: right…  i guess this is where the blur between data and control structure becomes very apparent
08:45:52 <ertes-w> NF for control, WHNF for data
08:46:38 <ertes-w> tsahyt: basically keep this in mind: rnf (the underlying operation of 'deepseq') needs to traverse the whole data structure every single time, even if most of it is already in NF
08:48:47 <AWizzArd> ReinH: and an array would be a contiguous sequence of bytes without that bookkeeping?
08:49:41 <tsahyt> ertes-w: I usually only use nf for when I have a Maybe SmallResultType or something like that
08:50:15 <tsahyt> for when there are cases when the outer constructor can be determined without doing all the work
08:57:28 <ph88^> AWizzArd, ye i know .. i mean if only i had the time to do the analysis on it (not that i have the data) .. but would be interesting ^^
08:58:14 <ph88^> AWizzArd, i think the bookkeeping that ReinH is talking about is a few bytes or few kilobytes for all your gigabytes of data
09:00:08 <c_wraith> It's like 3 words per Vector
09:00:31 <c_wraith> I think 4.  If I'm counting right.
09:02:19 <ReinH> An Array is not a C array.
09:03:03 <c_wraith> Hmm.  I guess if you count the card-marking overhead, a little bit more.  But not much.
09:03:48 <c_wraith> Though that won't come into play for stores of unboxed values.
09:04:06 <merijn> ReinH: Ah, a fellow believer of the "mmap is the solution to all my problems with efficiently loading stuff into RAM" :)
09:04:27 <merijn> mmap is, like, my favourite system call ever
09:04:50 <leshow> Say I want to use Vector, I often have to construct it first explicitly with a list then call V.fromList, I'm sure this incurs a performance hit because I'm making the list initially. 
09:04:54 <tsahyt> merijn: dunno, I'm rather fond of sbrk. allocating is a rather useful thing after all.
09:05:21 <merijn> tsahyt: sbrk is only rarely used nowadays
09:05:21 <EvanR> leshow: well in another language yes
09:05:22 <blackdog> merijn: kinda bums me out that it seems difficult to serialise haskell data structures in an mmap-friendly way
09:05:25 <leshow> I had read somewhere that if I turnon OverloadedLists, and construct a Vector, I can avoid the overhead and still be able to declare it easily
09:05:30 <merijn> tsahyt: Almost ever malloc is implemented using mmap nowadays
09:05:34 <tsahyt> TIL
09:05:35 <EvanR> you create an entire list first, then create the vector
09:05:58 <drdo> GHC profiler says my program is spending >80% of its time in "compare", but the parent function in the profile report does not even call compare (at least apparently)
09:06:00 <merijn> tsahyt: mmap can do anonymous (i.e. not backed by a file) mappings too
09:06:05 <blackdog> at least, complex ones - probably not too hard with straight arrays/vectors
09:06:06 <leshow> for instance if i do [1,2,3,4] :: Vector Int. Can it create the Vector directly?
09:06:06 <ReinH> merijn: when I found out I could load stuff directly into storable vectors I got very excited.
09:06:11 <merijn> tsahyt: And unlike sbrk mmap can release things more easily
09:06:22 <merijn> blackdog: You are probably looking for Storable :)
09:06:26 <leshow> or is it going to construct a List, and call fromList
09:06:43 <EvanR> leshow: however, in haskell a list is a control structure. ideally you are using it as the "loop" that fills in each vector cell. and the only question is if it creates and forgets a list cell each time, sometimes that is skipped by fusion
09:06:58 <merijn> blackdog: Storable is the typeclass for converting stuff into C structs. Combined with Storable Vector you can just directly mmap arrays. It's cool stuff!
09:07:05 <ReinH> leshow: how do you know the list isn't optimized away?
09:07:33 <ReinH> and anyway, you still need to provide the values somehow
09:07:44 <EvanR> if you create an entire list in haskell first, fully materialized, then do something with it, you might be doing something wrong
09:08:15 <leshow> perhaps I should show the link where im getting this from
09:08:37 <blackdog> merijn: hm, not quite i think? at least, most of the datatypes i care about like HashMap and Map don't implement Storable.
09:08:38 <leshow> https://books.google.ca/books?id=rIVcDgAAQBAJ&lpg=PA53&ots=cnWrsLl_eb&dq=haskell%20bubblesort%20ST%20monad&pg=PA54#v=onepage&q=haskell%20bubblesort%20ST%20monad&f=false
09:08:41 <nshepperd> I doubt that OverloadedLists will be any faster
09:09:24 <blackdog> and it's difficult to see how they could
09:09:27 <leshow> the book says "...We should change indices so that it uses V.enumFromTo instead (alternatively turn on OverloadedLists extension and from V.fromList)
09:09:32 <EvanR> i cant see anything in this book
09:09:40 <ReinH> me neither
09:09:43 <h3x__> how is the performance of haskell programs compared to imperative languages when it comes to manipulating elements in a list? when the lists become large, an imperative language can directly mutate an element, while in haskell you have to make a whole new copy, no?
09:09:56 <leshow> EvanR: what do you mean can't see anything?
09:10:06 <leshow> the link doesnt work?
09:10:19 <ReinH> h3x__: I'll assume you don't mean [] when you talk about lists.
09:10:19 <leshow> I'm looking at point 2 on page 54
09:10:40 <ReinH> Haskell supports mutability through the ST monad, which lets you implement algorithms that require mutation.
09:10:43 <blackdog> h3x__: if you actually want to be able to do that, there's nothing stopping you from making a structure that uses IORefs for the cons cells.
09:10:48 <h3x__> ReinH: more specifically, im looking into the Data.Matrix package 
09:10:49 <EvanR> it seemed to appear after a while, but at first every page was "not available for preview"
09:10:50 <blackdog> it's usually a bad idea though. 
09:11:05 <ReinH> But there are algorithms that don't require mutation that are only a log factor worse asymptotically. These are often better in practice.
09:11:34 <EvanR> h3x__: modifying a haskell list doesnt always require making a copy of the whole thing, similarly for other haskell data structures
09:11:36 <sproingie> sometimes you just need to port an algorithm that's mutation-heavy
09:11:41 <blackdog> h3x__: in particular, having persistent (non-mutable) data structures means that you can often share large chunks, meaning you get big memory and locality savings.
09:11:51 <ReinH> Often the answer is to find a different algorithm that works better in Haskell.
09:11:55 <ertes-w> h3x__: if you take a list of 100 elements, throw away the first 50 and replace them by another list, then the new list will share the common suffix
09:12:02 <blackdog> sproingie: yeah, that's where ST is good.
09:12:08 <leshow> I'm just talking about the construction of a vector, not when to use ST
09:12:18 <sproingie> then there's interfaces with stuff that's shamelessly stateful
09:12:24 <sproingie> i'm looking at you, opengl
09:12:25 <ReinH> leshow: I'm talking to h3x__ 
09:12:30 <leshow> oh sorry
09:12:33 <ertes-w> h3x__: however, you can't do that with prefixes…  if you need that, there is Data.Sequence, which is internally a tree structure, so you can do arbitrary manipulations in O(log n) time and space
09:12:38 <leshow> the book also mentions ST
09:12:44 <sproingie> those interfaces tend to use IORefs though, not ST
09:12:46 <leshow> On the same page, got confused
09:13:03 <ReinH> (see above about doing stuff immutably for an additional log factor)
09:13:04 <ertes-w> h3x__: lists are generally not a good choie as a *data* structure…  in most cases you would use them as a *control* structure
09:13:05 <nshepperd> leshow: oh, enumFromTo could be slightly faster, because it compiles into a loop that fills in 1..4 instead of listing [1, 2, 3, 4] in the object code
09:13:35 <leshow> nshepperd: As I understood it, OverloadedLists just called fromList under the hood
09:13:36 <ertes-w> h3x__: note that linked lists are generally not a good choice as a data structure, regardless of language =)
09:13:37 <EvanR> leshow: you can look at the source code for Vector fromList to see how it works, then you can look at some core output to see if what you did gets optimized further
09:13:46 <leshow> so I don't see how it would be any faster to turn the pragma on
09:14:01 <EvanR> me neither
09:14:32 <nshepperd> leshow: yeah, i don't see any way for that to be faster
09:14:36 <ReinH> I don't think speed is the goal of the pragma
09:14:40 <sproingie> ertes-w: linked lists are optimal in some cases, e.g. if you have a lot of tail sharing
09:14:42 <EvanR> ertes-w: not a lisp weenie?
09:14:44 <nshepperd> either way, the fromList should be fused away
09:14:57 <blackdog> ertes-w: why do you say that? linked lists are often far faster than you expect in haskell
09:15:00 <leshow> ReinH: It doesn't appear to be that way from it's GHC page, yet this book claims it will net perf gains
09:15:15 <blackdog> especially if they're constructed in such a way that they can be lazily consumed and fusion kicks in.
09:15:16 <leshow> nshepperd: fused away?
09:15:27 <EvanR> blackdog: hes talking about using them fully materialized
09:15:33 <EvanR> like in C or lisp or whatever
09:15:40 <blackdog> ah
09:15:52 <h3x__> thanks for the suggestions! do you know by chance if the Data.Matrix package implements these techniques for mutation?
09:15:56 <ReinH> leshow: What is the specific claim in the book?
09:16:15 <blackdog> nshepperd: not sure fromList will be fused away always - you'd expect V.fromList [1..] to not blow up until you actually touch it, right?
09:16:47 <sproingie> as for data vs control, the line can get pretty blurry.  you're likely not determining control flow with a hash table or a finger tree, but other trees can represent decision points for example
09:17:08 <leshow> "Large lists are inefficient, and they don't compose with vectors stream fusion. We should change indeices so that it uses V.enumFromTo instead (laternatively turn on OverloadedLists extension and drop V.fromList). Down to 360ms and 94% less GC traffic"
09:17:15 <sinelaw> what are the expected effects of +RTS -V0  on perf ?
09:17:17 <leshow> ReinH: 
09:17:30 <sinelaw> (disables RTS clock according to docs)
09:18:09 <ReinH> Does [1..10] :: Vector Int turn into V.enumFromTo 1 10 or V.fromList [1..10]?
09:18:48 <ReinH> and if the latter, is the list deforested?
09:18:50 <leshow> fromList (enumFromTo x y)
09:18:57 <leshow> ReinH: is what it gets desugared
09:19:01 <leshow> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
09:19:03 <leshow> according to this
09:19:10 <ReinH> I'd like to see the core.
09:19:19 <ReinH> with -O2, ofc
09:20:06 <EvanR> blackdog: of course fusion doesnt always work, because it has to be positioned syntactically as a sequence of compositions. then intermediate lists dont need to be created. and when it does happen, doesnt change the semantics you mentioned
09:20:22 <leshow> I don't know how to get that, I don't even have a program I'm really profiling. I was just wondering if you all agreed with this book, b/c the statement seemed fishy
09:20:57 <EvanR> i dont see how to the size of the list has anything to do with fusion
09:20:59 <ReinH> I agree with the book depending on whether the list is fused away when OverloadedLists is used. I'm not sure why it would be in that case but not when it isn't used.
09:21:01 <nshepperd> I would expect [1..10] :: Vector Int to turn into V.fromList (enumFromTo 1 10), and then into V.enumFromTo 1 10 due to RULES
09:21:04 <blackdog> EvanR: yeah. went to a really interesting talk about vector fusion recently - seems hilarious that it works at all really. one of the things he showed required something like 100 rules to fire in sequence.
09:21:19 <nshepperd> but V.fromList [1..10] should do exactly the same
09:21:24 <ReinH> nshepperd: but then wouldn't you expect fromList [1..10] to do the same?
09:21:25 <ReinH> right
09:22:21 <ReinH> leshow: I will say that I consider Packt to be a borderline scam and I'm automatically dubious of any book they publish.
09:22:32 <ReinH> I saw a Haskell book they published that was absolute garbage.
09:22:55 <blackdog> they pretty much spam people in the community to write books for them too.
09:23:00 <leshow> Yeah this popped up in a google search about unboxed vectors or something.
09:23:18 <ReinH> I don't think it was this book, but I have no particular reason to think this book is good
09:24:10 <EvanR> with random books its crap until proven otherwise !
09:26:43 <ReinH> It was a book called Haskell Design Patterns, which you should never under any circumstances buy.
09:26:49 <ReinH> If someone gives it to you, throw it away.
09:27:09 <bitemyapp> Packt bragged in a marketing email about having published 550 books in the previous year
09:27:13 <bitemyapp> which tells you about all you need to know
09:27:16 <sproingie> packt used to be more reputable.  something changed, they got a lot more scummy
09:27:18 <leshow> ReinH: I've heard about that one
09:27:19 <ReinH> It contains gems like typeclasses that are provably uninhabited because they're broken
09:27:22 <leshow> I actually donwloaded it
09:28:00 <leshow> Haven't wasted my time reading it though, thankfully
09:28:12 <ReinH> And this paragon of technical writing and editing https://www.dropbox.com/s/1cxiucfr1ft875e/Screenshot%202015-11-06%2017.58.38.png?dl=0
09:28:14 <leshow> I bought Haskell: First Principles, and that's been a good book I find
09:28:34 <ReinH> Yeah, bitemyapp and his coauthor are writing a good book.
09:28:58 <leshow> Another one? Or do you mean finishing H:FP
09:29:07 <ReinH> That one, yes.
09:30:20 <leshow> What's left to do? I'm almost on the last chapter now
09:31:08 <ReinH> Maybe nothing? idk
09:31:21 <cocreature> I think they’re just fixing typos at this point
09:31:29 <bitemyapp> It's content complete
09:31:39 <bitemyapp> It's actually almost done being edited too, just need to cut a release.
09:31:48 <bitemyapp> What remains after final editing is printing and fulfillment.
09:34:10 <leshow> Awesome!
09:34:43 <Iceland_jack> great bitemyapp
09:35:02 <leshow> bitemyapp: I loved the book btw, I've been slowly working through it after work and doing the examples. It's taken about a year but I feel like I can actually be useful in Haskell now
09:37:14 <ertes-w> a few years ago packt approached many known haskellers to write books for them, me included…  i couldn't tell whether they were legitimate
09:37:51 <Teknokratsevilla> hi
09:38:10 <Teknokratsevilla> is there a wiki server written in haskell ? 
09:38:10 <ertes-w> ironically they approached me based on a misguided monad tutorial i had written =)
09:38:21 <ertes-w> Teknokratsevilla: gitit
09:39:36 <Teknokratsevilla> awesome !
09:41:27 <ertes-w> Teknokratsevilla: there is also hakyll, if you prefer a static site
09:42:24 <AWizzArd> ReinH: I mostly would be interested in using it without mmapping into it.
09:43:03 <AWizzArd> ReinH: on AWS I can have a machine with 480 GB RAM. So all data could be loaded into it.
09:43:36 <sproingie> that's a spendy instance
09:46:16 <AWizzArd> sproingie: on the spot market for 2-5 hours it’s fine.
09:47:18 <leshow> Whats a popular client side http lib for Haskell
09:47:59 <sproingie> wreq
09:48:01 <shapr> leshow: wreq
09:48:10 <leshow> cheers thanks
09:48:22 <AWizzArd> sproingie: one hour for 50 cents is realistic.
09:48:47 <sproingie> AWizzArd: wow.  guess i'm still not used to such an embarassment of riches
09:48:54 <ertes-w> leshow: personally i'd prefer http-conduit
09:50:44 <sproingie> even plain http-client is pretty nice
09:51:08 <ertes-w> leshow: wreq is mostly useful, if you need sessions (including a dynamic cookie jar)
09:51:10 <bitemyapp> leshow: good, glad to hear it. Doing the work (exercises) is important :)
09:52:08 <leshow> ertes-w: thank you
09:52:21 <ertes-w> sproingie: http-client is a bit too low-level for most applications, including most notably an extra API for TLS connections (http-client-tls)
09:55:29 <sproingie> yah that's a little annoying
09:56:00 <athan> Does anyone here know of a URI parsing / printing implementation, where each subcomponent of the well-typed URI structure has it's own Alternative parser, and is fully exposed?
09:56:04 <sproingie> separating it might make sense internally, but if it sees an https scheme, it should just DWIM
09:56:24 <athan> cuz if not I'll totally get on it
09:56:25 <ertes-w> athan: something like boomerang/web-routes-boomerang?
09:56:29 <athan> oh hm
09:56:43 <athan> I mean, I don't actually need an iso
09:57:02 <athan> I would be happy with a show instance and an attoparsec parser
10:02:32 <ertes-w> athan: what about the network-uri library?
10:02:42 <ertes-w> https://hackage.haskell.org/package/network-uri
10:03:43 <rt_> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
10:03:43 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
10:04:39 <rt_> @undo multWithLog = do       a <- logNumber 3       b <- logNumber 5       return (a*b)  
10:04:39 <lambdabot> <unknown>.hs:1:13:Parse error: =
10:04:51 <rt_> @undo let multWithLog = do       a <- logNumber 3       b <- logNumber 5       return (a*b)  
10:04:51 <lambdabot> <unknown>.hs:1:53:Parse error: Last statement in a do-block must be an expression
10:04:59 <theone> Is there a way to make forM_ work with guards? I'm getting "parse error on input ‘|’ ". Code -- https://pastebin.com/hd1axa33
10:05:36 <quchen> theone: Use a »case«, 
10:05:45 <leshow> Anyone have any idea why I can compile a file with stack ghc -- -O2 src/whatever.hs -o foo just fine, but if I pass -prof it's unable to resolve package dependencies? "Failed to load interface for Data.Text"
10:05:53 <quchen> \dividend -> case dividend of | foo -> 1; bar -> 2
10:06:06 <quchen> | instead of ; there
10:06:14 <cocreature> leshow: try "stack --profile ghc -- …"
10:06:37 <rt_> @undo do       a <- logNumber 3;       b <- logNumber 5;       return (a*b)  
10:06:38 <lambdabot> logNumber 3 >>= \ a -> logNumber 5 >>= \ b -> return (a * b)
10:06:39 <byorgey> quchen: I think that is a parse error also.
10:06:57 <leshow> cocreature: compiled OK, ill give it a run
10:07:07 <quchen> Oh, the leading | is wrong as well.
10:07:36 <quchen> … I should probably compile this before saying anything else.
10:07:41 <geekosaur> leshow, that usually means you don't have the profiling libraries for Data.Text, just the normal ones
10:08:26 <geekosaur> leshow, this matters in a lazy language because if your "profiled" code gets forced in a library that wasn't built for profiling, it is effectively no longer profiled
10:09:03 <leshow> geekosaur: how do i get the profiling libraries?
10:10:13 <leshow> cocreature: when I run with -p, the binary spits out how it wasnt compiled with the profile flag
10:10:15 <geekosaur> leshow, normally stack would handle that for you, but because you;re using 'stack ghc' you are going behind its back. I would guess you need to do something like 'stack install text --profile'
10:10:34 <geekosaur> hm, I don't know that is actually the right option...
10:10:50 <leshow> stack install is going to install text globally wont it?
10:11:38 <rt_> @undo do       a <- logNumber 3;       b <- logNumber 5;       tell ["added"]; return (a*b)  
10:11:38 <lambdabot> logNumber 3 >>= \ a -> logNumber 5 >>= \ b -> tell ["added"] >> return (a * b)
10:11:53 <cocreature> leshow: are you still passing -prof to stack ghc?
10:12:25 <leshow> cocreature: I did  stack ghc --profile --  -rtsopts -O2 src/Ch28-Text.hs -o foo
10:12:35 <leshow> If I also pass -prof, I get the same error
10:12:56 <cocreature> leshow: alright try "stack build --profile text" first
10:13:09 <sproingie> stack install will install into the global instance you get when you run stack outside a project
10:13:44 <sproingie> curious whether that does affect the cache though
10:14:00 <cocreature> it will also copy executables to ~/.local/bin even if run inside a project but it won’t install the actual library globally
10:14:26 <cocreature> so for "text", "stack install text" and "stack build text" should do the same thing when run in a project
10:15:34 <leshow> cocreature: that sure is taking it's time to compile lol
10:16:23 <leshow> cocreature: that worked!
10:16:26 <leshow> thank you!
10:16:42 <cocreature> np I ran into the same problem recently :)
10:23:04 <LordBrain> > (unsafeCoerce (-1::Int32))::Word32
10:23:05 <lambdabot>  error:
10:23:06 <lambdabot>      Variable not in scope: unsafeCoerce :: Int32 -> Word32
10:23:38 <LordBrain> in ghci, when i use that above code, it sets the type to Word32, but still uses the Show instance for Int
10:24:18 <byorgey> well, it is unsafe, after all!
10:25:38 <LordBrain> lpaste is not responding to me
10:26:48 <EvanR> its been in a coma for a while
10:27:07 <LordBrain> well, i just wanted to paste the code showing it
10:27:19 <cocreature> I can reproduce it if that makes you happy :)
10:27:22 <cocreature> not quite sure why
10:27:27 <LordBrain> thanks
10:28:00 <EvanR> unsafeCoerce throws the type system under the bus, everything else remains the same
10:28:26 <EvanR> dictionary passing is a runtime thing
10:28:41 <LordBrain> let x = ((unsafeCoerce (-1::Int32)) ::Word32 and :t x shows Word32
10:28:53 <cocreature> ah Show for Word32 is implemented via toInteger
10:29:05 <cocreature> so it’s probably toInteger that takes the - into account
10:29:24 <LordBrain> but why does toInteger see a - ?
10:29:33 <cocreature> not sure, looking at the implementation atm
10:29:40 <EvanR> its the toInteger for Int32
10:29:49 <EvanR> gotta be
10:30:08 <cocreature> EvanR: how could it? the typechecker sees a Word32 when it needs the dictionary, no?
10:30:29 <EvanR> i dont think the type checker is using any dictionary
10:31:00 <Unode> Is anyone familiar with any haskell code that implements disk-based lookup tables? hash, b-tree or otherwise?
10:31:03 <EvanR> not sure when that comes into play on ghci
10:31:22 <shapr> Unode: disk based?
10:31:54 <cocreature> what I’m trying to say is that you’re using toInteger at Word32 so regardless of what the value is and whether it is produced using unsafeCoerce or not, it should use the instance of Word32 and not the instance of Int32
10:32:21 <EvanR> unless the dictionary is chosen and packed in somehow with that value
10:32:48 <Unode> shapr: that allows storing arbitrarily big tables (as big as the available disk-space) while keeping reasonable performance.
10:32:53 <LordBrain> Unode, i am working right now with a interface implemented on top of LMDB
10:33:02 <cocreature> I’m not yet willing to believe that GHC does that or is even allowed to do that
10:33:08 <LordBrain> its an extension of the package on haskell i ahvent published yet
10:33:45 <LordBrain> i've been planning on publishing it soonish
10:33:45 <EvanR> try compiling the offending code
10:33:53 <Unode> LordBrain: checking LMDB, not familiar with it.
10:34:04 <LordBrain> Unode, its b-tree memory mapped
10:35:16 <Unode> LordBrain: sounds like the solution I'm after
10:35:20 <LordBrain> Unode, i can give you access to a devel version if you want, if you think you might be interested in helping us work out the kinks
10:35:46 <LordBrain> Unode, the one on hackage has no safety
10:35:48 <dolio> LordBrain, cocreature, EvanR: I believe the answer is that x is in an invalid Word32 state.
10:35:55 <dolio> x + 0 gives the expected answer.
10:35:56 <Unode> LordBrain: I'm still much of a beginner on Haskell.
10:36:00 <LordBrain> this one has a stm like monad and some atomic operations in io
10:36:21 <dolio> But unsafe coercing -1 to Word32 leaves the higher 32 bits of the underlying 64-bit word set.
10:36:33 <dolio> Instead of being zeroed.
10:36:43 <cocreature> dolio: ah that makes sense, thanks!
10:36:45 <Unode> LordBrain: the reason I'm asking is someone else in the office was looking for a disk-based hash table for a reasonably big dataset. We already have some haskell software in-use so I figured something could exist out there.
10:36:54 <LordBrain> dolio, even tho its called 'unsafe', i still think this is a bug...
10:37:03 <dolio> No.
10:37:24 <dolio> It's your fault for breaking the invariants.
10:37:25 <LordBrain> alright
10:37:40 <LordBrain> hmmm
10:38:02 <EvanR> yeah Word32 is implemented as a Word64 and its none of our business
10:38:07 <LordBrain> well now you make me feel worse than is necessary
10:38:23 <EvanR> and so is Bool probably
10:38:33 <EvanR> a slended waste of 63 bits! ;)
10:38:36 <LordBrain> its not unreasonable to think a 32 bit block can be pushed to a different 32 block assuming the bits are right
10:39:28 <dolio> Well, don't feel too bad. :)
10:40:04 <dolio> But, unsafeCoerce is not required to give you the results you expect in this case.
10:40:10 <EvanR> and CInt on 32bit system is apparently newtype over Int32
10:40:28 <EvanR> which will would have the same issues if you just moved to 64bits
10:40:56 <EvanR> wonder how you get what LordBrain wants without extra computation... intrinsics?
10:40:57 <dolio> I think the only thing it specifies is that it will give the right answer when coercing any type to itself.
10:41:08 <dolio> Or coercing a type to Any and back.
10:41:13 <cocreature> dolio: not even for newtypes?
10:41:43 <dolio> I don't know if it even says you can do that.
10:42:11 <LordBrain>  cocreature for new types, we have coerce
10:42:32 <LordBrain> the Coercible class
10:42:34 <cocreature> LordBrain: oh sure but I thought unsafeCoerce was still supposed to work (I think in practise it does)
10:42:48 <LordBrain> oh
10:42:55 <LordBrain> yeah it seems like a bug to me
10:43:04 <LordBrain> certainly violates my expectation
10:43:33 <cocreature> well it doesn’t claim to do what you expect it to do so calling it a bug seems weird
10:43:49 <dolio> EvanR: Bool is better than Word64, because the latter probably takes 128 bits.
10:43:51 <LordBrain> well... its a violation of expectation
10:43:59 <LordBrain> common expectation i think
10:44:01 <dolio> Bool only needs the tag bits, not a payload.
10:44:05 <LordBrain> i doubt i'm the only one here surprised
10:44:26 <LordBrain> so it violates the principle of least surprise
10:44:47 <LordBrain> anyway
10:45:10 <LordBrain> whats reasonably quick way to do the conversion i want?
10:45:11 <kadoban> LordBrain: Being surprised by dont-do-that code is itself not surprising.
10:45:21 <LordBrain> i already said i felt bad
10:45:33 <LordBrain> what do you want? should i be lashing myself?
10:45:33 <cocreature> the only reasonable solution that I see here would be to have Word32 complain more loudly when it’s invariants are violated
10:45:43 <sproingie> moar flagellation!
10:45:49 <cocreature> and I’m not sure if that’s possible without loosing performance
10:46:32 <EvanR> you should feel bad for imply violation of principle of least surprise is bad
10:46:39 <LordBrain> cocreature, well maybe its a worthy trade, what would it look like tho? when would it complain?
10:47:39 <cocreature> LordBrain: not sure, in this case it would be sufficient to check the invariant when calling toInteger
10:47:42 <LordBrain> well, when we're done chastising me, for being the unfortunate one to fall in this hole... can someone tell me the correct way to do a bitwise coercion like this?
10:48:08 <EvanR> instead of using unsafeCoerce for this, which is probably completely wrong, in addition to being empirically wrong, you should use a compiler primitive which guarantees the behavior you want and is implemented in the most efficient way
10:48:20 <dolio> fromIntegral
10:48:22 <EvanR> or just use fromIntegral
10:48:23 <kadoban> What's wrong with fromIntegral?
10:48:59 <dolio> By the way, if you do: W32# (int2Word# 18446744073709551615#)
10:49:03 <dolio> You get -1 printed.
10:49:39 <LordBrain> well i didnt know fromIntegral would do the sign conversion correctly
10:49:56 <cocreature> there is an int2word primop
10:50:17 <dolio> Yeah, but that will also give the wrong answer, as I showed. :)
10:50:22 <EvanR> but its on 64 ints
10:50:24 <dolio> Unless you mask yourself.
10:50:34 <dolio> Which is what fromIntegral will do.
10:51:14 <EvanR> narrow32Word# :: Word# -> Word#
10:51:57 <EvanR> maybe fromIntegral uses all these in the specific case of Int32 to Word32 via rules
10:52:09 <EvanR> when compiling with optimizations
10:52:55 <LordBrain> fromIntegral might be the best solution, but it actually feels a bit wrong too, because it looks safe when its obviously changing a negative number to a positive one
10:52:55 <dolio> They probably are. There are a bunch of fromIntegral rules that avoid going through Integer.
10:53:23 <EvanR> the specific thing doing that is conceptually fromInteger
10:53:31 <EvanR> > fromInteger (-1) :: Word32
10:53:33 <lambdabot>  4294967295
10:53:46 <EvanR> so blame this on the behavior, whether its right or wrong
10:54:02 <cocreature> hm I can’t find a rule for Int32 -> Word32 
10:54:08 <EvanR> > toInteger (-1 :: Int32) 
10:54:10 <lambdabot>  -1
10:54:17 <EvanR> that part is unquestionable
10:55:27 <cocreature> ah it’s getting rewritten
10:55:42 <cocreature> it’s first rewritten to Int->Word and then there is a rule for that
10:56:08 <LordBrain> do i need to get Integer involved for some reason?
10:56:17 <LordBrain> is there an advantage
10:56:21 <dolio> No.
10:56:31 <EvanR> when you use fromIntegral, its conceptually using integer but then the compiler is smart
10:56:32 <dolio> fromIntegral is defined by going through Integer, but then optimizations eliminate it.
10:56:49 <LordBrain> ok
10:57:04 <LordBrain> i guess that helps thinking about it some
10:57:47 <EvanR> i brought up fromInteger because its behavior for Word32 either does what you want or doesnt
10:57:55 <EvanR> its what youre after
10:58:07 <EvanR> but it doesnt necessary even actually happen after optimizations
10:58:30 <LordBrain> oh
10:58:35 <LordBrain> hmmmm
10:58:53 <EvanR> (i mean, converting -1 to a Word32 could concievably be 0)
10:58:57 <LordBrain> well, i mean i could go thru the bits comparing them one by one
10:59:00 <EvanR> (via clamping)
10:59:08 <LordBrain> yeah
10:59:26 <LordBrain> i know, thats why i think i was afraid to go that route
10:59:26 <EvanR> but it aint
10:59:45 <sproingie> what you mean by -1 isn't necessarily clear, whether you had the bit pattern in mind or an actual negative
10:59:58 <LordBrain> ah
11:00:02 <LordBrain> good point sproingie ...
11:00:06 <sproingie> so it falls onto whatever conversion you use
11:00:21 <LordBrain> its a bit hackerish, but people might use -1 and really mean FFFFFF
11:00:22 <cocreature> hm why does Data.Bits not provide a bitcast operation. only because they could have different sizes?
11:00:32 <EvanR> this is haskell, -1 means -1
11:00:37 <cocreature> LordBrain: C programmers do that all the time :)
11:01:07 <sproingie> C programmers do all kinds of awful stuff
11:01:31 <EvanR> actually this is haskell, -1 means negate 1, which is morally -1
11:01:45 <LordBrain> EvanR, i think we can rely upon it, because of the the instance for Integral would have the wrap around effect...
11:01:59 <EvanR> fromInteger is in Num
11:02:11 <LordBrain> yes Num i meant sorry
11:02:18 <Sornaensis> noom
11:02:18 <EvanR> yeah makes sense to m
11:02:40 <LordBrain> there is + and - in there... and so its probably not reasonable to implement clamping... or is it?
11:02:55 <EvanR> not that a wrap around effect is easier to implement when coming from GMP integer
11:03:23 <LordBrain> anyway, i think i'm going with fromIntegral
11:03:24 <EvanR> i can imagine clamping 
11:03:43 <LordBrain> changing it to a clamp would break too much code i think
11:04:01 <EvanR> yeah but you could make a newtype for a different Num instance
11:04:05 <LordBrain> not that i know for sure, but that would be my guess... 
11:04:19 <LordBrain> oh sure
11:04:23 <EvanR> you can also do this
11:04:31 <EvanR> (but dont)
11:04:37 <LordBrain> but i mean, all haskell implementations are probably going to do what is now done
11:05:05 <LordBrain> and if they dont, they probably broke so much other stuff that they're not worth worrying about
11:05:16 <EvanR> > fromInteger (-1 `mod` (fromIntegral (maxBound :: Word32)))
11:05:18 <lambdabot>  -1
11:05:28 <EvanR> > fromInteger (-1 `mod` (fromIntegral (maxBound :: Word32))) :: Word32
11:05:31 <lambdabot>  4294967295
11:06:04 <EvanR> i dont want to live in a world where the answer to that isnt 4294967295
11:07:40 <dolio> EvanR: -x `mod` y = -(x `mod` y)
11:07:40 <Tuplanolla> I sometimes long for integers whose overflow is a trap.
11:08:08 <EvanR> syntax wise?
11:08:15 <dolio> Yes. That's how it's parsed.
11:08:18 <EvanR> WHAT
11:08:31 <dolio> - is an additive operator and mod is multiplicative.
11:08:40 <dolio> Multiplication binds tighter than addition.
11:08:52 <sproingie> > (-1) `mod` 3
11:08:54 <lambdabot>  2
11:08:57 <sproingie> aha
11:09:05 <EvanR> > -1 `mod` 3
11:09:07 <lambdabot>  -1
11:09:15 <EvanR> i thought about putting parens around -1, but then i thought.. if im wrong itll crash ;)
11:09:20 <EvanR> then i was even more wrong
11:09:26 <dolio> :)
11:09:29 <Tuplanolla> With `NegativeLiterals` however...
11:09:37 <sproingie> > -1 `mod` 3
11:09:38 <lambdabot>  -1
11:09:43 <EvanR> ^ thats insane
11:09:47 <EvanR> haskell sucks
11:10:03 <blackdog> oof, that really is nasty.
11:10:09 <dolio> Yeah, with NegativeLiterals -1 `mod` y is different from - 1 `mod` y.
11:10:23 <orion> > -(1 `mod` 3)
11:10:26 <lambdabot>  -1
11:10:32 <orion> > (-1) `mod` 3
11:10:34 <lambdabot>  2
11:11:00 <blackdog> oh right, that makes more sense :) just got the application order wrong.
11:11:09 <sproingie> arguably a big syntax wart
11:11:54 <blackdog> sproingie: sure, but it's only going to show up in literals, not code read in from elsewhere, so it's just not going to get the right answer ever - not a bug that's likely to leak to prod
11:12:06 <EvanR> > - 1
11:12:08 <lambdabot>  -1
11:12:12 <EvanR> yeesh
11:12:18 <blackdog> i kinda wish we'd used _ or something for unary negation
11:12:30 <blackdog> are there any other variadic haskell functions?
11:12:36 <EvanR> ... _ is an alphanum character though
11:12:39 <dolio> No, - is special case.
11:12:51 <dolio> And it's the only one of its kind.
11:12:55 <sproingie> i believe ML uses ~
11:13:13 <sproingie> i forget if ocaml does too
11:13:20 <EvanR> in 3017, people will wonder wtf people were thinking back now
11:13:24 <blackdog> i guess the explicitly variadic stuff like printf
11:13:43 <dolio> They were thinking it'd be nice to write things like grade school arithmetic.
11:13:45 <sproingie> EvanR: i spend every goddam day wondering wtf people were thinking today
11:13:59 <dolio> f x y = - x*y
11:14:03 <EvanR> including why grade school arith is written with the unary -
11:14:13 <blackdog> (but printf is just a cheap trick :) )
11:14:42 <EvanR> they will surely have a more logical syntax
11:15:43 <mivael> > -1 + 10
11:15:45 <lambdabot>  9
11:16:04 <EvanR> also
11:16:12 <sproingie> and the rabbit hole gets deeper
11:16:17 <EvanR> where did "unary minus is an additive op" come from, that makes no sense
11:16:48 <mivael> why behaviour in "-1 + 10" is different from "-1 `mod` 3"?
11:17:08 <dolio> Because - and + have the same precedence, and are left associative.
11:17:21 <mivael> oh
11:17:35 <EvanR> x - -(y - z) = x - (-y + z) = x - (-y) + z = x + y + z
11:17:53 <EvanR> the 2nd minus in that sequence acts like multiplication, to me
11:17:55 <Tuplanolla> You see `- x` could desugar to `0 - x`, EvanR.
11:18:15 <EvanR> which is why it distributes
11:18:24 <sproingie> the desugaring that never should have been
11:18:58 <EvanR> Tuplanolla: there is no real - space x in math... thats some kind of agda artifact
11:19:04 <sproingie> NegativeLiterals on by default probably would have broken all kinds of stuff
11:19:17 <Sornaensis> wait what
11:19:24 <dolio> EvanR: What are you talking about?
11:19:25 <EvanR> -x `mod` y has the same issue
11:19:26 <Sornaensis> there is no -x in maths?
11:19:34 <EvanR> minus space x
11:19:39 <Sornaensis> - x  ?
11:19:43 <EvanR> who sees -    x anywhere
11:19:52 <EvanR> besides here
11:19:56 <mniip> x - y
11:20:00 <mniip> is usually spaced
11:20:03 <Sornaensis> wats the difference between -x and  - x
11:20:04 <EvanR> thats a different operator
11:20:17 <sproingie> Sornaensis: nothing unless NegativeLiterals is on
11:20:18 <EvanR> - x should be a syntax error
11:20:29 <dmwit> EvanR: Are you arguing for significant whitespace? I don't think most math folks will buy into that.
11:20:51 <sproingie> significant whitespace would have been nice, then we could have kebab-case
11:20:58 <sproingie> (speaking of another use for -)
11:21:09 <Sornaensis> there already is significant whitespace
11:21:11 <Tuplanolla> In math negation is almost always used when it commutes with the rest of the binding group, EvanR.
11:21:12 <sproingie> but that's another language entirely now
11:21:12 <EvanR> sure, F o o and Foo...
11:21:16 <Sornaensis> all ur shit has to line up in haskell
11:21:41 <dolio> Negating variables or even expressions isn't that uncommon.
11:21:48 <dolio> In aritmethic.
11:21:54 <dolio> Or algebra.
11:22:00 <EvanR> let me repeat my complain since it seems like we missed it
11:22:10 <dmwit> EvanR: Without further discussion, if I saw either of those in a math paper I would parse both as F*o*o.
11:22:18 <sproingie> does hlint or anything complain about unparenthesized unary - ?
11:22:20 <EvanR> in x + -(y + z), you have x - y - z, its distributing
11:22:36 <EvanR> so the - there is multiplicative
11:22:46 <EvanR> which i seem to feel is always the case with an unary -
11:22:47 <dolio> That's because it's a group operation.
11:23:02 <EvanR> you see -x, it means multiply whatever x is by -1
11:23:02 <Tuplanolla> People also tend to write `-x = z  (mod y)` instead of `-x mod y = z mod y`, EvanR.
11:23:12 <dolio> op(x <> y) = op x <> op y
11:23:42 <sproingie> assuming <> is distributive
11:23:43 <dolio> It's part of the additive group structure.
11:23:54 <EvanR> increment (y + z) = y + z + 1 
11:24:06 <EvanR> not (y + 1) + (z + 1)
11:24:22 <dolio> increment isn't the dual operation in the additive group structure.
11:24:24 <EvanR> distributive law is about multiplication
11:24:47 <EvanR> this is a ring
11:25:16 <mniip> negation is a group operation
11:25:24 <mniip> which is a more general term than ring
11:25:42 <EvanR> x + -2(y + z)
11:25:50 <mniip> in fact, negation, not subtraction, is the second fundamental group operation
11:26:06 <mniip> EvanR, what's a "2"
11:26:12 <EvanR> i have been arging this whole time against comprehending it as subtraction from an invisible zero
11:26:22 <EvanR> fromInteger 2
11:26:46 <sproingie> the problem pretty much boils down to - binding so loosely
11:26:57 <EvanR> just regular school math, polynomials, unary - seems like multiplication
11:27:34 <dolio> It also seems like subtraction from an implicit 0.
11:27:45 <EvanR> x + (0-2)(y + z) ?
11:28:14 <EvanR> x + (0y - 2y - 2z + 0z)
11:28:20 <EvanR> thats out of the way
11:28:40 <EvanR> and we still had to do multiplication
11:29:06 <sproingie> this very same conversation 10 years ago: https://prime.haskell.org/wiki/NegativeSyntax
11:30:14 <EvanR> in there they assume (- 1) would still exist and be a section ?
11:30:35 <EvanR> that would make way more sense
11:30:36 <petercommand> > (- 1)
11:30:38 <lambdabot>  -1
11:30:39 <sproingie> perhaps with the significant whitespace
11:31:09 <petercommand> > (1 -)
11:31:11 <lambdabot>  <Integer -> Integer>
11:31:51 <sproingie> (- 1) is still not a section even with -XNegativeLiterals
11:31:59 <EvanR> x-1 = x (-1) sucks... yes, whitespace distinguishes fx and f x, whats the problem
11:32:26 <EvanR> in programming you sometimes need to use words for variables mind blown
11:33:47 <sproingie> it's when whitespace is significant between tokens.  which still doesn't bother me, since foo bar /= foobar
11:34:11 <mivael> :t (-1)
11:34:12 <lambdabot> Num a => a
11:34:13 <mivael> :t (+1)
11:34:15 <lambdabot> Num a => a -> a
11:34:19 <EvanR> :(
11:34:23 <mivael> liiks inconsistent for me...
11:34:26 <monochrom> Clearly, foo bar = f*o*o*b*a*r = foobar :)
11:34:27 <mivael> *looks
11:34:51 <monochrom> Yes.
11:35:05 <EvanR> i have wanted to use (-1) and (+1) next to each other in code
11:35:11 <EvanR> alas
11:35:13 <sproingie> i know, we could use unicode nonbreaking spaces ;)
11:35:31 <monochrom> Haha nonbreaking spaces, now that's a thought.
11:35:52 <sproingie> and on the flip side, support zero-width spaces too
11:36:25 <monochrom> Oh wouldn't that be cute.
11:36:30 <sproingie> actually i wonder... no idea how to test that though
11:36:40 <sproingie> it's kinda hard to copy/paste a nonbreaking space to try it
11:36:57 * geekosaur suggests U+2062, U+2064
11:37:12 <geekosaur> and U+2063 for that matter...
11:38:33 <ystael> geekosaur: or U+002D vs U+FF0D? :)
11:39:12 <glguy> text "10 * -\x2060\&20"
11:39:15 <glguy> > text "10 * -\x2060\&20"
11:39:17 <lambdabot>  10 * -⁠20
11:40:14 <afhole> Hi everyone - me again I'm afraid. I am still blundering my way through an Algebraic Isomorphism exercise on Codewars and have stumbled on the last two functions. The penultimate implementation is of `powS :: ISO (Maybe b -> a) (a, b -> a)`. Can anyone see an alternative to what I have here? http://lpaste.net/7215612432431972352 The only way I can see to call `Maybe b -> a` in lieu of a `b` is to give it a Nothing. I'm worried it is sw
11:40:24 <sproingie> > let foobar = bar + 1 in foo 2
11:40:27 <lambdabot>  error:
11:40:27 <lambdabot>      • Variable not in scope: bar
11:40:27 <lambdabot>      • Perhaps you meant one of these:
11:40:48 <sproingie> tch.  not sure if the zero-width space copied or not
11:41:08 <afhole> *... The test fails rather cryptically with `expected: "da ze da ze da ze " but got: "it was me, DIO!"`. Thank you!
11:41:49 <mivael> EvanR, it looks like you should use (flip (-) 1) and (flip (+) 1) instead  ;)
11:42:38 <ggVGc> flip off
11:43:10 * geekosaur did not see the selection glitch that would have resulted from mousing over it here
11:43:16 <mivael> ggVGc, would not work for (-)
11:43:19 <monochrom> sproingie: which codepoint did you use for zero-width space?
11:43:55 <sproingie> monochrom: \N{ZERO WIDTH SPACE}
11:44:18 <sproingie> whatever perl spit out from that.  actually i just saw the wide char warning so it probably never printed it
11:44:32 <monochrom> U+200B
11:44:52 <AWizzArd> In several programming languages functions are functionally transparent. To a caller them seem to be pure, while internally they create an object and mutate it. As I understand it this is not possible in Haskell. Is that correct? And if yes, why is it desireable to require doing this explicit (via IO in the type signature)?
11:45:05 <monochrom> I just tried that (hexeditor then ghci). "lexical error at character '\8203'"
11:45:15 <Tuplanolla> We have `ST` for that, AWizzArd.
11:45:33 <AWizzArd> ST is a type yes?
11:47:03 <sproingie> it's a parametric type.  uses some trickery to ensure the state can't escape, only the result
11:47:39 <kadoban> AWizzArd: Yes. ST s is a monad that can do all of the fun mutability stuff that IO can, in terms of arrays and IORefs (STRefs) and etc. but once you get the result out, it's just a normal pure result.
11:48:05 <AWizzArd> Interesting. I should study this. ST sounds a bit like the STate monad. Possibly it is similar to it.
11:48:22 <sproingie> it can be used for stateful stuff, but it does it in a totally different way
11:48:22 <EvanR> ST doesnt just let you mutate stuff internally, it statically verifies what you do cant leak out
11:48:29 <monochrom> Completely total antipodal opposite.
11:48:34 <kadoban> It's mostly different from State
11:48:44 <EagerBackpacker> Hello! My coworkers and I are looking for a way to implement a kind of SMD (separate module development) before Backpack is ready for production. We've come up with an example: https://github.com/toddaaro/haskell-di
11:48:57 <kadoban> State is just a convenience around functions with a certain form of parameter passing
11:49:10 <EagerBackpacker> We want to be able to swap components out for testing, but they will sometimes share some component state.
11:49:35 <EagerBackpacker> Any feedback would be great. It's also possible we're barking up the wrong tree entirely.
11:49:36 <AWizzArd> So, the state monad is in practice not really used very often, while the ST monad is regularily used?
11:49:53 <EvanR> State alone, no i dont think its that popular in practice
11:49:54 <sproingie> both are used very often
11:49:58 <geekosaur> what?
11:49:59 <EvanR> but StateT is very popular
11:50:16 <sproingie> IO is in fact "ST RealWorld"  (where RealWorld is rather magical)
11:50:19 <geekosaur> AWizzArd, ST and State/StateT serve different purposes
11:50:35 <Sornaensis> what is ST
11:50:46 <monochrom> ST is as in Control.Monad.ST
11:50:50 <AWizzArd> But State and StateT are very similar, while ST is more orthogonal yes?
11:50:52 <sproingie> stands for State Thread
11:51:04 <EvanR> lets get precise about one of the three
11:51:11 <sproingie> StateT is the transformer version of State
11:51:21 <geekosaur> State /per se/ is not used that often, because it's most useful when carrying "state" in some other context such as IO (thus you more often want StateT)
11:51:27 <monochrom> This is one of those times when "meaningful" names like "State" are completely misleading and misrepresenting.
11:51:30 <sproingie> usually you use StateT in non-trivial apps
11:51:43 <Tuplanolla> What is not state, monochrom?
11:51:54 <sproingie> or these days, RWST
11:52:12 <AWizzArd> Uh, RWST is again something different?
11:52:15 <monochrom> What you really need to do is go read the doc the API and perform some experiments to find out what it really does and doesn't, rather than trying to infer from someone else's subjectively misconceived names.
11:52:19 <Tuplanolla> Let us enter the philosophical murky waters.
11:52:37 <EvanR> i dont recommend using StateT or RWST off the bat, but they are possibly useful as the backend for a more app-specific monad, which again you may not even want
11:52:39 <sproingie> RWS is Reader, Writer, and State rolled into one convenient tortilla
11:53:02 <dmj`> transformin’ tortillas
11:53:04 <AWizzArd> monochrom: yes, I will do that with the ST thingy. With State I feel mostly comfortable, but haven’t looked at StateT yet.
11:53:20 <monochrom> But if you say you don't have time now, sure that's fair, so you just trust me when I say "completel totally antipodal opposite".
11:53:46 <monochrom> And don't argue on the ground of "it's called 'state'"
11:54:12 <sproingie> i'd suggest starting with State/StateT.  ST is pretty low-level stuff 
11:54:13 <monochrom> A name makes sense to the person who coined it, only.
11:54:22 <bitemyapp> EvanR: I end up eschewing StateT in work code because I need monad-control for the lifted stuff.
11:54:34 * geekosaur is actually somewhat confused by RWST, since the point of RWS usually seems to be "transformer stacks are annoying"... so what do we do, we make it into a stackable transformer
11:54:43 <sproingie> i started with A Gentle Introduction which does the charming thing of introducing the State monad from first principles, and it calls it ST
11:54:50 <sproingie> that was confusing to say the least
11:54:53 <geekosaur> I feel like I missed the point somewhere. Or someone else did
11:55:05 <bitemyapp> Given stateful-anything isn't safe when combined with monad-control, I end up using ReaderT + local where possible.
11:55:16 <dolio> geekosaur: I think the point was, collapsing them into one thing generates faster results.
11:55:21 <EvanR> yes StateT leads to RWST. RWST leads to monad base control, monad base control leads to ...
11:55:26 <sproingie> geekosaur: you only need one transformer then instead of stacking three.  less lifting.
11:55:27 <monochrom> geekosaur, I think it was from an efficiency angle.
11:55:29 <shapr> EagerBackpacker: you might get more feedback on the haskell-cafe mailing list?
11:55:46 <bitemyapp> EvanR: I don't know what you mean by "leads to", lifted-base/lifted-async are what necessitate MBC for me.
11:55:46 <monochrom> Unless your "annoying" also includes "annoying inefficiency"
11:55:47 <Tuplanolla> To continue the food analogies, `RWST` is the kind of protein sludge that can replace an otherwise diverse diet, geekosaur.
11:55:50 <shapr> EagerBackpacker: possibly post a link on the haskell reddit as well?
11:55:52 <sproingie> the error messages are slightly less heinous when they're all in one
11:56:06 <monochrom> But surely 10 layers is better than 13 layers :)
11:56:07 <EvanR> leads to in the sense of star wars dark side
11:56:18 <bitemyapp> yeah I don't think this is what happens usually
11:56:24 <sproingie> RWS is a symptom of a problem.  the problem being transformers suck
11:56:33 <bitemyapp> MBC is more expressive than the alternatives and the motivation is usually IO in the negative position
11:56:54 <EagerBackpacker> shapr: Thanks for the pointer to haskell-cafe! I tried posting to /r/haskell, but I did it on a new account, so my post doesn't show up on New, and my explanatory comment isn't visible. It's here, FWIW: https://www.reddit.com/r/haskell/comments/6fn09r/dependency_injection_in_haskellfeedback_wanted/
11:56:55 <sproingie> i still need to learn Eff sometime
11:57:14 <bitemyapp> Eff doesn't really fix anything we're talking about here
11:57:20 <cocreature> I don’t think I’ve ever used rwst
11:57:27 <bitemyapp> I've never used RWS/RWST either
11:57:49 <cocreature> I don’t use Writer either so RWS just doesn’t make sense for me
11:57:56 <monochrom> I don't think the Gentle Introduction called it "ST". (I am checking just now, it's "SM" now. Forgot whether it was back then.) I do think it's Theo Norvell's monad tutorial that calls it "ST", and I did recommend that tutorial back then.
11:58:04 <bitemyapp> same, it's just ReaderT usually and _rarely_ StateT.
11:58:22 <bitemyapp> Quine uses Lazy StateT IIRC which surprised me.
11:58:30 <EvanR> if you have IO, then it makes more sense to have your state variables as IORefs and stuff, in a reader
11:58:37 <cocreature> I probably use State more than StateT
11:58:37 <ezyang> EagerBackpacker: DI in Haskell can certainly be done with typeclasses 
11:58:44 <sproingie> monochrom: ah yes, that sounds right, thanks :)
11:58:45 <ezyang> there are some downsides but it is a technique that people often use 
11:58:58 <ezyang> similarly, passing around a higher-order record often works well too 
11:59:04 <bitemyapp> Reaching back further, the reason I needed lifted-base/lifted-async was so that I could parameterize over async/io actions
11:59:16 <bitemyapp> turtles all the way down leading to my not being able to use State
11:59:47 <bitemyapp> it was actually ezyang's article that popularized awareness of the State/monad-control issue I think.
11:59:55 <AWizzArd> Thanks to the several guys who replied. I got some nice motivation about what to read.
12:00:03 <bitemyapp> I miss the Harper-esque title though
12:00:39 <monochrom> Harper-esque title? Such as "Monad Blindness"? :)
12:01:14 <sproingie> i was thinking Harper Lee, à la To Mock a Mockingbird
12:01:15 <shapr> ezyang: didn't you write a thesis on backpack?
12:01:39 <monochrom> Oh! To bind a monad bind.
12:01:48 <EagerBackpacker> ezyang: Yeah, for pure library-like things, typeclasses are enough to give you nice inversion of control. The tricky thing is, how do you assemble a bunch of components that are decoupled except for the fact that they share a state? These things may be happening in parallel without any top-level sequencing.
12:02:15 <EagerBackpacker> ezyang: We could put a bunch of dependencies in a monad stack so that they can call each other, but that seems brittle.
12:02:33 <EvanR> EagerBackpacker: if they share *a* state... you can pass in an MVar or TVar either normally or with a Reader
12:02:55 <sproingie> "brittle" is a pretty common criticism of monad stacks 
12:03:05 <EagerBackpacker> EvanR: Yeah, that's what we've been doing.
12:03:37 <EvanR> or a record of MVars, TVars, actions etc
12:03:43 <EvanR> which is what im doing right now
12:03:55 <EvanR> and only using IO
12:04:01 <EagerBackpacker> https://github.com/toddaaro/haskell-di shows how we're trying to break apart the stack a bit, to make the dependencies more manageable, but it uses a lot of pragmas and is not that easy to work with.
12:04:22 <EagerBackpacker> EvanR: That sounds interesting. Do you have an example on a public repo I could look at?
12:04:33 <EvanR> yes
12:04:38 <dmj`> EvanR: I like wrapping MVar’s / TVar’s in a record too, and just exposing functions like (a -> IO ()), etc. 
12:04:41 <EvanR> now that you mention it
12:05:53 <cocreature> the surprising power of closures
12:05:57 <ezyang> shapr: Yes I did! 
12:06:09 <EvanR> dmj`: yes, well im doing that somewhat. but in the case of a Chan, it would cause the number of things to double, read and write
12:06:34 <EvanR> and in the case of TVar, read and write
12:06:44 <EvanR> which is the two things youd want to do in this case
12:07:00 <EvanR> TVar Integer
12:07:09 <monochrom> EagerBackpacker: I wonder if my https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html is relevant or tangential
12:07:42 <dmj`> EvanR: interesting, unsure why things would double.
12:07:49 <EagerBackpacker> monochrom: I will certainly read it; thank you.
12:08:11 <EvanR> dmj`: i mean, record fields. one TVar from two STM actions
12:08:14 <EagerBackpacker> EvanR: Could you throw me a link to where you program in that style? I'm curious to see what it looks like.
12:08:16 <EvanR> vs
12:08:43 <cocreature> EvanR: data ChanOps a = ChanOps { read :: IO a, write :: a -> IO () } now you only need one field :)
12:08:54 <cocreature> and you can write Chan a -> ChanOps a to make it easy to construct that field
12:09:46 <EvanR> let me tell you, one thing im struggling with is the upfront cost of setting up all these bike shedding-like things
12:09:52 <EvanR> just the raw typing the support code
12:10:09 <EvanR> its really kind of a drag
12:10:23 <EvanR> so im still looking for ways to cut down on that aspect of solutions
12:10:43 <dmj`> EagerBackpacker: data Notify = Notify { wait :: IO (), notify :: IO () }, newNotify :: IO Notify = newMVar () >>= \mvar -> Notify (takeMVar mvar) (putMVar mvar ()). Then doThing Notify {..} = ...
12:10:44 <EvanR> by using the premade stuff already in libs like Control.Concurrent, i do less myself
12:10:46 <EagerBackpacker> monochrom: Named instance certainly look like an idea worth exploring, but aren't useful for our particular case, I think.
12:10:55 <EvanR> EagerBackpacker: yeah i can, looking for something worth showing
12:11:03 <EagerBackpacker> EvanR: Thank you!
12:11:04 <dmj`> EvanR: ah, sure, I see
12:11:57 <EvanR> cocreature: right in this case, the work is going into *stopping* someone from using everything else you can do with a Chan... 
12:12:18 <EvanR> after enough of that it feels like friction
12:13:04 <EvanR> i hope to impress people with the constructive aspects of haskell and not the defensive guardrail aspects
12:13:16 <EvanR> public vs private in C++ was also a drag
12:13:24 <cocreature> yeah it can definitely be annoying sometimes
12:14:02 <EagerBackpacker> dmj`: Ah, hmm. This feels like we're losing quite a bit of type safety, no? The interface is both impoverished and restricted. I can't make a fake IO-less dependency for my tests. 
12:14:59 <EvanR> if you want testability, you really want pure code
12:15:04 <EvanR> no IO even in production
12:15:29 <EagerBackpacker> Ah...that seems rather defeatist.
12:15:49 <EagerBackpacker> Either your program is a function or you can't have tests?
12:16:04 <EvanR> no its just that IO covers too much
12:16:07 <cocreature> usually the things that are in IO are the things that I want to test using integration tests that actually test what I will be running in production
12:16:20 <EvanR> its not specific, it may contain things that are testable or may not, but the framework cant know
12:16:34 <dmj`> EagerBackpacker: yea, true, you’d need to parameterize it over both m and a if you wanted to mock out IO. Otherwise, you could create a Notify in IO that doesn’t perform IO, emptyNotify = Notify (pure ()) (const $ pure ()), but this obviously has different semantics, and IO is too specialized.
12:16:42 <EvanR> if its using I/O for things like quantum mechanics, you cant reproduce a test
12:16:44 <cocreature> if your IO is just a relatively thin wrapper around pure code there is not much benefit in mocking it’s parameters
12:16:59 <cocreature> you’re just testing the pure functions at that point
12:17:32 <EvanR> EagerBackpacker: not necessarily a function, but pure code
12:17:42 <EagerBackpacker> Granted. Alas, in our case we will be doing a lot of heavy IO. Being able to fake out some dependencies (to be pure instead of IO), would certainly help our testing story.
12:18:21 <EagerBackpacker> Consider the case where a slow network API is replaced by a pure function.
12:18:39 <EvanR> i have an idea for that
12:18:40 <EagerBackpacker> When we're testing the caller of the network API, we'd enjoy that replacement.
12:19:23 <EvanR> pretty cheap advice, its just my theory, but lets say you wrote the code to take an IO Foo, and executing that is what does the API request
12:19:34 <EvanR> and you want to make it testable
12:20:57 <EvanR> you could provide alternative IO Foos which are as slow as you want, that would avoid removing IO from everything
12:21:49 <EagerBackpacker> That is true. And if we just use an IO as our monadic context, that's quite possible.
12:22:18 <EagerBackpacker> Now, what if we have a complicated stack which describes some stateful dependencies. Sometimes we want to be able to replace part of that wiring, which means it has to be more general than IO.
12:22:21 <EvanR> but if your component were pure code, then instead of IO Foo, you make a new type for requests, the responses would be provided by the thing running your pure code, and in a test that would be reproducible test data
12:22:50 <EvanR> including timing info
12:23:04 <EagerBackpacker> That makes sense.
12:23:27 <EvanR> have you looked at free monads
12:23:44 <EagerBackpacker> Yeah, looking into that. It seems like it could be the best way to achieve what we want.
12:24:24 <EagerBackpacker> I'm still learning Haskell; I haven't used free monads before, but it certainly feels promising.
12:24:38 <cocreature> for some reason I’m now imagining EvanR knocking at my door asking if I have a moment to talk about free monads
12:24:54 <EvanR> have you heard the good newtypes
12:25:15 <EagerBackpacker> What about the operational monad. Is that what we want?
12:25:52 <EvanR> it looks like the same idea
12:26:27 <EagerBackpacker> The tutorials I've looked at talk about how it's good at implementing a sequence of instructions with multiple interpreters. I wonder if that's enough to capture the module-framework idea...
12:29:08 * hackage diagrams-lib 1.4.1.1 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.4.1.1 (BrentYorgey)
12:38:19 <AWizzArd> writeSTRef vs modifySTRef – would that be in clojure like reset! vs swap! ?
12:39:34 <tdammers> :t writeSTRef
12:39:35 <lambdabot> STRef s a -> a -> ST s ()
12:39:40 <tdammers> :t modifySTRef
12:39:41 <lambdabot> STRef s a -> (a -> a) -> ST s ()
12:39:48 <tdammers> look at those types
12:40:07 <AWizzArd> Yes, it really seems that ST is like Clojure’s (atom …)
12:40:22 <tdammers> the former takes a ref and a value, the latter takes a ref and a function over its value type
12:40:43 <sproingie> writeSTRef is basically modifySTRef ref (const val)
12:40:48 <tdammers> "write" means "put this value in the ref", "modify" means "apply this fn to the value inside the ref"
12:41:08 <AWizzArd> bitemyapp did Clojure in the past I think, so he may know if newSTRef is like (atom …),  writeSTRef is like reset!,  modifySTRef is like swap!  and readSTRef is like (deref …)
12:41:54 <tdammers> writeSTRef is roughly like reset!
12:42:01 <AWizzArd> Yes.
12:42:11 <tdammers> modifySTRef is roughly like swap!, except that it doesn't return the old value
12:42:13 <sproingie> clojure's swap is more like atomicModifyIORef'
12:42:15 <AWizzArd> I think ST is mostly equivalent to Clojure’s atoms.
12:42:32 <Tuplanolla> You can't do concurrency with `ST`, AWizzArd.
12:42:46 <Tuplanolla> Don't confuse `ST` with `STM`.
12:43:07 <AWizzArd> But still, just knowing that basically ST is conceptually like Clojure’s atom explains it very fast.
12:43:38 <AWizzArd> Tuplanolla: Clojure’s atoms don’t participate with STM. Those are Refs: (ref …)
12:43:48 <qmm> is there a way to search for packages which depend on a particular package?
12:44:16 <Tuplanolla> So `atom` has nothing to do with atomicity, AWizzArd?
12:44:55 <sproingie> qmm: http://packdeps.haskellers.com/reverse
12:45:54 <AWizzArd> Tuplanolla: they do atomic updates, yes, but outside of the STM.
12:46:04 <AWizzArd> Tuplanolla: it uses java.util.concurrent.atomic.AtomicReference under the hood.
12:46:12 <Tuplanolla> I see.
12:46:24 <AWizzArd> But still, very good that this is comparable.
12:46:41 <sproingie> ST keeps everything isolated, you'd communicate an eventual result via a MVar or TVar or somesuch
12:47:02 <AWizzArd> Clojurists can be introduced to ST with this comparison. „Nah, ST is just very similar to atom…” and they will immediately be very close to grasp how to use it (but not how to implement it).
12:47:37 <qmm> sproingie: thank you so much!
12:48:09 <Tuplanolla> It sounds more like an `MVar` to me, AWizzArd.
12:49:42 <sproingie> MVar is more like a one-element queue
12:51:37 <sproingie> or a semaphore with a value, if you prefer.  lots of uses.
12:54:08 <kyclark> If I add “resolver: lts-8.17” to my ~/.stack/config.yaml, I get “Unrecognized field in ConfigMonoid: resolver” when I start up “stack ghci”.  What is the proper way to add this so I don’t have to put “—resolver” on the command line?
12:54:25 <cocreature> kyclark: add it to ~/.stack/global/project.yaml
12:54:53 <kadoban> ~/.stack/global-project/stack.yaml isn't it?
12:55:15 <cocreature> kyclark: config.yaml is for nonproject-specific configuration that applies to all invocations of stack. global/project.yaml is for the global project that is used when you are not inside any other project
12:55:32 <cocreature> kadoban: I have it in ~/.stack/global/stack.yaml and that seems to work just fine
12:55:58 <kadoban> Huh. I have the other. Maybe one is the old way.
12:56:25 <kyclark> OK, I added it to ~/.stack/global/project.yaml and “stack ghci” still starts up with 7.10.3
12:56:35 <kyclark> No complaints about the field, however.
12:56:44 <sproingie> try stack setup
12:57:03 <cocreature> kyclark: in which directory are you when you’re running "stack ghci"?
12:57:09 <kyclark> Just $HOME
12:57:17 <cocreature> kyclark: in particular is there a stack.yaml file in some parent directory?
12:57:18 <kyclark> Specifically not in a project directory
12:57:19 <kadoban> kyclark: There's no stack.yaml there I assume?
12:57:34 <kyclark> None.
12:57:36 <sproingie> stack might not be detecting the change.  stack setup might kick it into seeing it
12:57:48 <kadoban> kyclark: Try the file I mentioned.
12:58:07 <cocreature> kadoban: hm looks like global is deprecated (but still works)
12:58:20 <kadoban> Ah, interesting.
12:59:13 <cocreature> although I’m not getting the deprecation warning that I should be getting according to the changelog
12:59:17 <kyclark> kadoban, that did it!
12:59:28 <kadoban> cocreature: Are you on really old stack maybe?
12:59:38 <cocreature> kadoban: no the newest version
12:59:55 <kadoban> Wacky. Are you sure it actually works and it's not just accidentally the same?
13:00:17 <cocreature> yeah, I just changed something earlier today to get something to work
13:00:34 <kadoban> Hmm, strange.
13:00:43 <cocreature> --verbose is also showing that it’s picking it up
13:01:02 <kadoban> kyclark: Cool. That's strange the other didn't
13:01:04 <cocreature> I mean it is still supposed to work afaict. It just should show a warning which it doesn’t seem to
13:01:15 <cocreature> well I’ll just move it around
13:01:26 <kadoban> Yeah I couldn't remember. I had a vague recollection it was deprecated a long time ago, I think I just assumed it was removed since.
13:03:05 <cocreature> btw has something changed in the readthedocs search haskellstack.org embeds? it doesn’t seem to find anything anymore, e.g., https://readthedocs.org/search/?q=global&check_keywords=yes&area=default&project=stack&version=stable&type=file
13:04:05 <cocreature> it has never been particularly great but I can’t even come up with a single search term that it finds something for atm
13:08:25 <kadoban> I'm not sure I even knew there was a search. But ya, it sure doesn't seem to work.
13:11:16 <jadrian> I'm importing Data.Singletons, and I have 'True but not STrue, even though it's listed in https://hackage.haskell.org/package/singletons-2.2/docs/Data-Singletons.html 
13:11:33 <ryba> hi
13:11:44 <ryba> anyone here is familiar with accelerate library?
13:13:36 <jadrian> and `sing :: Sing 'True` doesn't work either 
13:14:34 <cocreature> jadrian: are you’re sure you are using singletons-2.2 and not some other version?
13:15:06 <jadrian> cocreature: let me check again, but pretty sure I am... I'm using stack and just installed it
13:19:51 <kadoban> jadrian: Installed it how? 'stack install' for libraries often doesn't do what you actually mean.
13:19:51 <jadrian> cocreature: bit lost here, how do you check the installed package version number when you're using stack?
13:20:45 <kadoban> jadrian: You just depend on it in the .cabal file, and you get the version that comes from the resolver you're using (specified in the stack.yaml usually). If you need a different version, you can use an extra-dep (again in stack.yaml)
13:20:56 <cocreature> jadrian: there is probably a better way but "stack exec ghc-pkg -- list | grep singletons" should to the trick
13:20:58 <jadrian> kadoban: may be the issue, I just started using stack so still getting the hang of it, I did stack install, imported in my file and stack built it
13:21:28 <kadoban> 'stack install' is really just for executables. It builds the thing you tell it to and copies the executables from it to ~/.local/bin . You shouldn't really use it for anything else.
13:21:30 <cocreature> jadrian: make sure you’re running that from the same directory where you’re running the other stack commands
13:22:37 <jadrian> cocreature: yes 2.2 but I think kadoban is right, I may need to edit .cabal...
13:23:23 <jadrian> kadoban: thanks that must be it... 
13:23:30 <cocreature> I would be surprised if that helps. if you can import it, it should be that version. editing the cabal file would help if you couldn’t import it or if there was a different version
13:24:03 <jadrian> surprised 'True works though
13:24:16 <cocreature> kadoban: heh those are the moments where I hate myself for complaining loud enough that they didn’t deprecate "stack install"
13:24:17 <jadrian> and that it doesn't complain about me importing Data.Singleton
13:24:24 <cocreature> jadrian: that doesn’t require singletons
13:24:33 <cocreature> jadrian: that just requires enabling -XDataKinds
13:25:02 <kadoban> cocreature: Yeah, 'stack install' is too confusing after coming from cabal-install I think. Especially because in some cases it "works" and does what people expect, and most cases doesn't.
13:25:42 <jadrian> cocreature: how about the import of Data.Singletons itself?
13:27:04 <MarcelineVQ> hmm I think stack install isn't a problem, the problem is that people are mostly told to use stack before being told to read what stack IS
13:28:27 <MarcelineVQ> stack install is inherantly not quite the right thing to use for most situations, if you understand what stack does
13:29:32 * MarcelineVQ puts the tablecloth back over the soap-box
13:31:20 <cocreature> maybe it would help if "stack install" was an error for packages that didn’t contain executables
13:31:23 <cocreature> jadrian: what about it?
13:33:19 <cocreature> jadrian: looking at the docs, what makes you think that STrue is available in Data.Singletons? it’s not listed in the docs you linked
13:34:09 <jadrian> cocreature: I thought that if the problem was that I need to add "singletons" to my project.yaml then "import Data.Singletons" would result in a failed build
13:34:37 <jadrian> cocreature: as for STrue it is listed in the Sing instance for Bool
13:38:05 <jadrian> cocreature: but indeed, I just added singletons-2.2 to project.yaml extra-deps, rebuilt and still don't have STrue
13:39:40 <kadoban> jadrian: You mean stack.yaml, right?
13:40:14 <MarcelineVQ> project.yaml is used by hpack, if you have hpack, to generate project cabal files
13:40:49 <MarcelineVQ> you shouldn't need extra-deps to use singletons 2.2 though, it's in every 7 and 8 lts
13:42:02 <MarcelineVQ> oops good catch though extra-deps are part of stack.yaml not project.yaml
13:42:44 <cocreature> jadrian: import Data.Singletons.Prelude
13:43:07 <jadrian> cocreature: yeap just found it... I actually imported Data.Singletons.Prelude.Bool directly
13:43:44 <cocreature> time to go to bed, good night :)
13:44:07 <jadrian> thanks and good night!
14:04:25 * EvanR smokes cigar "love it when numeric algorithm fails unexpectedly with Double but behaves as expected with Rational"
14:05:24 <EvanR> http://lpaste.net/356074
14:05:58 <EvanR> fence 0.01 1.122345 => Just (1.12,1.1300000000000001)
14:05:58 <pikajude> Is the cigar saying that?
14:06:32 <EvanR> fence 0.01 1.12 => Just (1.12,1.1300000000000001), but should be Nothing
14:06:50 <EvanR> fence 0.01 1.12 :: Maybe (Rational,Rational) ==> Nothing
14:07:03 <pikajude> well, at least it's behaving rationally?
14:07:24 * byorgey doesn't see what is unexpected about that failure with Double
14:07:36 <orion> Hey, are there any other ways to achieve the encoding of types which *isn't* described in this blog post?: http://aaronlevin.ca/post/111871447488/using-dataproxy-to-encode-types-in-your-json
14:07:56 <byorgey> I would expect it to fail if you ever compare Doubles for equality
14:08:05 <EvanR> well, i wrote it against Rational originally, then generalized to get easier testing
14:08:19 <byorgey> I guess "unexpected" is always relative to what you expect =)
14:08:21 <EvanR> which didnt help with the default type, Double
14:09:00 <shapr> IEEE754 is less bad than the things that came before it; but it's certainly not wonderful.
14:09:53 <EvanR> also because when using rationals, the answers look like this
14:09:55 <EvanR> Just (28 % 25,113 % 100)
14:10:06 <EvanR> not obvious that its working
14:11:56 <byorgey> > Just (28 % 25, 113 % 100) & mapped . both %~ (fromRational :: Rational -> Double)
14:11:58 <lambdabot>  Just (1.12,1.13)
14:12:01 <mbw> What exactly does Stack/Cabal do if you have a project with C-code and "includes: include/mylib.h" / "c-sources: lib/mylib.c" inside you .cabal file? I used awkwardly create shared libraries by hand because I thought that is the way to include C-code with the FFI, but it seems to me this is not what cabal does. If I "stack install" my executable, it will relocate it to $HOME/.local/bin, and it will still 
14:12:07 <mbw> work. ldd doesn't show anything and I can't locate the function call with objdump. Under .stack-work, there are some files mylib.o and mylib.dyn_o, however. What is mylib.dyn_o? And what exactly could be happening here?
14:13:39 <geekosaur> it makes a static object not a shared object
14:14:37 <sproingie> .dyn_o is possibly position-independent code for when you do want dynamic
14:15:51 <geekosaur> I think it's used with ghci actually? but the one linked into the executable is the static one
14:15:54 <mbw> It appears mylib.o and mylib.dyn_o are byte-identical.
14:16:44 <monochrom> It is much more complicated than that. Artificially.
14:16:56 <mbw> mylib.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
14:17:01 * geekosaur doesn't actually know what ghc (not stack/cabal!) is doing with C sources when building with way dyn
14:17:43 <sproingie> so it's generating PIC for all object files.  might not be the case on all platforms
14:18:04 <mbw> So nopie /= "nopic"?
14:18:08 <monochrom> You will want position-independent code, and linking against shared libraries, for loading in ghci and producing your own shared library.
14:18:27 <geekosaur> actually relocatable there does not necessarily mean PIC, it may mean it's got static relocation entries
14:18:29 <monochrom> However, when you do that, the filename does not always end up as *.dyn_o
14:19:40 <okkk> @type fix
14:19:41 <lambdabot> (a -> a) -> a
14:19:56 <sproingie> > fix error
14:19:57 <monochrom> Suppose you invoke "ghc -fPIC -dynamic Mine.hs". You will get Mine.o, and it is position-independent and linked against shared libraries. It is ready for ghci loading, because ghci looks for *.o filenames.
14:19:58 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
14:20:10 <EvanR> is there a proper fraction which gives "the other" behavior for negatives
14:20:18 <monochrom> Unfortunately when producing your own shared library, no one expects that filename.
14:20:29 <sproingie> spanish_inquisition.o
14:21:41 <monochrom> So instead, if you invoke "ghc -dynamic-too Mine.hs", then you get both Mine.o (static) and Mine.dyn_o (dynamic). Later, when producing your own library, the static linker goes for Mine.o, the dynamic linker goes for Mine.dyn_o.
14:22:12 <monochrom> And yet, ghci is too dumb to honour Mine.dyn_o. Instead, it takes a look at Mine.o, "hrm it looks static", and ignores.
14:22:30 <sproingie> so that bug is still open?
14:22:47 <monochrom> -dynamic-too is also what cabal build uses.
14:25:55 <mbw> I don't think I get it. Assuming I have Mine.o and Mine.dyn_o, and Mine.o gets statically linked. Suppose there is a myFunc in Mine.hs, which is a C-wrapper. Shouldn't invoking myFunc in ghci then fail, if this kind of bug exists?
14:26:14 <mbw> (Because it doesn't for me)
14:26:36 <mbw> But I did encouter these kinds of errors yesterday, to be fair.
14:26:57 <glguy> mbw: What is the specific problem behavior?
14:27:39 <monochrom> Is it on Windows? What I said is for LInux only. Maybe Mac too, but not Windows. Windows is still stuck at the pure static stage, and ghci for Windows still loads static *.o
14:27:44 <mbw> glguy: I don't have a specific problem. Everything works smoothly if you let cabal do the work, and I'd like to know why :)
14:28:06 <mbw> No I'm on linux.
14:28:10 <glguy> mbw: Why what works specifically?
14:28:18 <monochrom> What is C-wrapper? "foreign import ccall ..."?
14:28:24 <mbw> yes
14:28:49 <monochrom> OK, I'm guessing that Mine.o is ignored and ghci is still looking at Mine.hs directly.
14:28:59 <monochrom> But I can test that.
14:29:12 <glguy> mbw: The objects generated by c-sources are eventually statically linked into the package library
14:29:28 <mbw> That could be the case. But it would make sense to boil this down to a minimally working example, which is not exactly what I am working with right now.
14:30:38 <mbw> If these functions are statically linked, could they be inlined? I can't really locate it in the disassembly, since the majority is just one big <.text>
14:31:33 <mbw> But objdump -d does not give you all segments
14:31:45 <monochrom> RIght, I have f.hs: foreign import ccall "sin" sine :: Double -> Double
14:31:47 <geekosaur> they can't be inlined. they *will* be in the one big .text segment
14:32:03 <monochrom> and ghci f.hs succeeds, and sine 1 = 9.98...e-2
14:32:18 <monochrom> ghci is totally interpreting the foreign import
14:32:39 <hjulle> :kind! does not seem to expand type synonyms for me (in GHC 8.0.2), it just prints them verbatim. Does anyone else have this problem? Example: "type A = ()" ":kind! A" will print out "A :: * = A" (which is not very helpful).
14:32:45 <monochrom> err, sine 0.1 !
14:34:07 <glguy> Sure, GHCi can handle foreign imports, you can even pass object files as arguments to ghci
14:35:30 <monochrom> The default ghci prompt reminds you whether it's interpreting or using your *.o
14:35:43 <mbw> Assuming I have an executable with this foreign code inside .text, does it leave any traces? For instance you would be able to see it being used with ldd if it was dynamically linked.
14:35:48 <glguy> I mean the .o for the c-sources you're foreign importing
14:35:56 <monochrom> If you see "*XXX>" (the point is the * at the front) it means interpreting and ignoring *.o
14:36:08 <glguy> mbw: the c-source isn't dynamically linked, so ldd won't see it
14:36:15 <monochrom> If you see "XXX>" then it is honouring compiled code.
14:36:24 <mbw> Yeah I wanted to know if there was some kind of equivalent.
14:36:37 <glguy> nm is for listing symbols
14:37:00 <joelburget> Hi all, I'm trying to work out some Template Haskell I'm not sure how to do without violating the stage restriction. Example here: https://gist.github.com/joelburget/6ffffb44c31884561b74a0e2dd1c1a86
14:37:57 <mbw> I get "no symbols", even when I tell stack not to strip the executable.
14:38:41 <mbw> Because apparently, it still strips it :)
14:39:03 <geekosaur> if you used 'stack install' it may strip it anyway
14:39:11 <mbw> ah
14:39:14 <mbw> good point
14:39:29 <mbw> That was it.
14:44:36 <mbw> Thank you all for your advice.
14:45:36 <EvanR> playing guess the module for Printf
14:45:49 <EvanR> Data, Control, System, String, 
14:46:03 <monochrom> Text.Printf
14:46:05 <EvanR> ah Text
14:48:06 <glguy> joelburget: Move the definition of decls' inside the splice on line 17
14:48:41 <glguy> oh, actually that'll be tricky because it uses str :)
14:49:36 <mbw> Oh yeah I forgot to ask. If I have C-Functions like fund/funf that work with double and float, would it be possible to make a wrapper that took a Floating instance as argument and dispatched to the correct "overload"?
14:49:52 <mbw> (Well probably, but how...)
14:50:54 <mbw> It doesn't need be this concrete example, I'm just asking about the general concept.
14:53:37 <Cale> mbw: It's obviously easier if you invent your own type class to distinguish.
14:53:38 <joelburget> glguy: right, the source of my trouble is that I have a start with `String -> ExpQ` but need to (splice to) use that `ExpQ` as `[Decl]`
14:53:54 <joelburget> but that splice induces a staging violation
14:54:53 <glguy> joelburget: Why are you using dataToExpQ on line 10?
14:55:14 <glguy> from your comments there decls :: [Decl], which is the type expected by makeTables
14:55:21 <mbw> Cale: That sounds like a straight-forward solution. It's probably what hmatrix uses the "Field" class for.
14:55:39 <joelburget> glguy: to run `replaceVars :: Text -> Maybe ExpQ` which does antiquotation
14:56:08 <joelburget> IE replaces `$varName` in a `Decl` with the in scope `varName`
14:58:22 <mbw> After looking at the source, it seems to be `Element`. Still, typeclasses seem to be the way to go. Thanks.
15:14:17 <hjulle> joelburget: Your safest bet is probably to rewrite makeTables to take in an ExpQ instead of [Decl]. Your current code would require run time compilation for that function.
15:16:40 <joelburget> hjulle: I considered that but `makeTables` is pretty involved. It's much, much easier to write it on `[Decl]` unless there's an easy way to lift it to `ExpQ`
15:22:14 <hjulle> joelburget: Then you need to try to avoid returning ExpQ instead. Those are basically your only options. There is no way for the compiler to know on beforehand that the ExpQ will evaluate to a [Decl].
15:23:24 <joelburget> a little frustrating but that makes sense
15:23:26 <joelburget> thank you
15:27:02 <Eduard_Munteanu> TH types are rather inexpressive.
15:27:50 <hpc> inexpressive in the "can't express invariants" way, i assume is what you mean?
15:27:54 <hpc> because you can perform IO in TH
15:27:55 <hpc> :D
15:28:22 <hjulle> joelburget: Maybe you can split it up in two functions, and run it like $(outer $(inner))?
15:28:25 <Eduard_Munteanu> Yeah, you can't really tell what some Q Dec does from the type.
15:29:10 <Eduard_Munteanu> It's quite apparent when you look at docs for TH helpers.
15:29:58 <Eduard_Munteanu> I guess you can argue the same about IO though.
15:40:57 <hjulle> joelburget: Yeah, that should actually work. Make everything up to defining decls' one function and everything from makeTables into another. Then you can run it with $(second_half $(first_half input)). It won't work for a quasi-quoter though. :/
15:43:39 <joelburget> hjulle: why do you say it won't work for a quasi-quoter?
15:44:38 <Eduard_Munteanu> By the way, why does TH really need a Lift class? Are there any values which are not liftable using some compiler magic?
15:48:07 <mbw> Is it possible to add haddock documentation to hsc2hs processed #enums ?
15:51:22 <hjulle> joelburget: You can't run the standard [f|...|] syntax, because that requires f to be a single function of type String -> ExpQ (or rather a QuasiQuoter object), but you can run it like $(outer [inner| ...|]) or something like that.
15:51:56 <hjulle> joelburget: It's a bit verbose, but at least it works. :)
15:51:59 <geekosaur> Eduard_Munteanu, the Lift class *is* the compiler magic, as I understand it. recent ghc versions make it possible to derive Lift automatically. (older versions couldn't, and iirc that was more "nobody had really thought about it")
15:53:33 <Eduard_Munteanu> I see.
15:54:23 <Eduard_Munteanu> Well, AFAICT, it could very well involve no typeclass at all, i.e. lift :: a -> Exp
15:54:48 <Eduard_Munteanu> Or   lift :: a -> Q Exp   more reasonably.
15:55:11 <pikajude> lift = error "this function is impossible to implement"?
15:55:22 <pikajude> or lift _ = [e|undefined|]
15:56:49 <Eduard_Munteanu> That's my point, there's nothing to implement. Why construct an expression in the TH AST for a value which you already have in memory?
15:59:47 <mbw> Or maybe there is a hsc2hs alternative that is able to do that?
16:03:48 <John[Lisbeth]> I figured out the krivine machine
16:09:57 <hanna> x86_64-pc-linux-gnu-gcc: error: unrecognized command line option ‘-nopie’; did you mean ‘-no-pie’?  <- when running `cabal configure` on a project containing c-sources
16:11:25 <hjulle> joelburget: Ooh, I just realized that there is a nicer way. You can get around the stage restriction by wrapping the result in a quotation. While \a -> f $a is not allowed, \a -> [| f $a |] is. 
16:18:23 <John[Lisbeth]> the krivine machine is a machine that interprets lambda calculus and nothing more
16:18:41 <hjulle> joelburget: This means that you can e.g. write let tables = [| makeTables $decls' |] instead. You'll still have to deal with Exprs, but you can do any amount of preprocessing on it to simplify it.
16:20:53 <ReinH> Has there been a marked increase in template haskell interest in here lately?
16:21:38 <hjulle> joelburget: Or actually, no, not even that. Since nested $() is allowed, just write the final line as [| $(dataToExpQ ... $tables) |] and it should work.
16:28:40 <joelburget> hjulle: thank you! i think your help got me unstuck
16:39:22 <hjulle> Ignore my last line. That is (obviously) not allowed, since it would be equivalent to just writing dataToExprQ ... $tables, which is disallowed. Also, my second to last comment was not very helpful either, since it will just keep the function application verbatim, without evaluating.
16:39:51 <hjulle> joelburget: Glad I can help. :)
16:39:58 <joelburget> hjulle: I ended up with a slightly different solution
16:40:13 <joelburget> I realized that I really only needed the first half to run at compile time
16:40:40 <joelburget> It would be cool to run both halves at the same time, but the first half is where variable capture happens
16:40:48 <joelburget> So I just defer the second half to runtime
16:40:52 <joelburget> Simpler that way
16:41:07 <hjulle> joelburget: Aha, nice. :)
16:43:18 <\u> hanna: ghc will invoke `gcc` listed in `ghc --info`
16:43:50 <\u> if its version is different from the gcc used to build ghc and its version is too low to support -no-pie
16:43:57 <hanna>  ,("C compiler supports -no-pie","NO")
16:43:58 <hanna> huh
16:44:15 <hanna> but yeah maybe I need to rebuild ghc to get it to “update” itself to the new version
16:44:39 <kyclark> Re: https://paste.ofcode.org/Gb3vwEEB9Sq2ytGkMhJupA I’m working through some Haskell material that wants me to write a Functor instance of a trivial linked list, but I’m stuck on how to unpack the non-Nil version.
16:44:44 <\u> you can edit /usr/lib/ghc-8.0.1/settings
16:45:37 <kyclark> Specifically, I figure I can apply the function “f” to the “Cons a” but what do I do with the other part of the list which could be another List or Nil?
16:45:58 <hanna> even if I set that to "YES" it still errors
16:47:31 <sveit> i am trying to understand some of the detailed coding decisions that went into the transformers package. for example, the implementation of Applicative for MaybeT (source at https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.Maybe.html#line-130) seems long-winded compared to "f >>= (flip fmap v)", and since Monad is required as a constraint anyway, I was wondering the second implementation is not used?
16:47:57 <sveit> i mean of the (<*>) function for the Applicative class of course
16:52:22 <kyclark> Sorry, maybe this is a better stab? https://paste.ofcode.org/jjKjKfvrV7LMdDBb9qbjfU
16:55:35 <Eduard_Munteanu> kyclark, that's only going to affect the first element of the list. You have to recurse.
16:56:33 <Eduard_Munteanu> (In fact, that's not even typed properly.)
16:57:15 <kyclark> I think I have it: https://paste.ofcode.org/vnzKt5UQEhk7DNJ99P39v7
16:57:32 <Eduard_Munteanu> kyclark, yep, that's alright
16:58:02 <kyclark> Thanks for pointing out the recursion.  That was slowly dawning on me.  Now to write the Applicative!
17:02:03 <iqubic> Hello folks
17:02:26 <Eduard_Munteanu> Hi.
17:03:36 <iqubic> What's the difference between: forall a. (a -> a) -> (Char, Bool) and (forall a. a -> a) -> (Char, Bool)
17:03:37 <iqubic> ??
17:04:05 <hpc> iqubic: the second one is a rank-2 type
17:04:08 <sveit> sorry to bump, but just to double-check, "f <*> v = f >>= (flip fmap v)" is legitimate for any monad, correct? if so, why is this code not used in the transformers package where Monad is required for providing applicative for many transformers (specifically MaybeT, for example)?
17:04:22 <hpc> a rather silly-sounding way of describing it is "monomorphically polymorphic"
17:04:34 <iqubic> hpc, What the heck does that even mean?
17:04:37 <hpc> the thing you pass as the (forall a. a -> a) parameter in the second type /has/ to be polymorphic
17:04:43 <hpc> you can pass id and undefined, but not (+ 1)
17:04:46 <hpc> or not
17:04:52 <hpc> :t not
17:04:53 <lambdabot> Bool -> Bool
17:05:22 <hpc> @let test :: (forall a. a -> a) -> Bool; test _ = False
17:05:24 <lambdabot>  Defined.
17:05:26 <hpc> :t test id
17:05:28 <lambdabot> Bool
17:05:29 <hpc> :t test not
17:05:31 <lambdabot> error:
17:05:31 <lambdabot>     • Couldn't match type ‘a’ with ‘Bool’
17:05:31 <lambdabot>       ‘a’ is a rigid type variable bound by
17:05:41 <hpc> that's the error you get when that goes wrong
17:05:44 <iqubic> What the heck??
17:05:46 <hanna> iqubic: in forall a. (a -> a) -> (Char, Bool); the *caller* can choose ‘a’
17:05:52 <iqubic> Oh. I see.
17:05:57 <hpc> and yeah, that's the other end of it
17:06:00 <hpc> @undefine
17:06:00 <lambdabot> Undefined.
17:06:01 <iqubic> Are there any rank 3 types?
17:06:03 <hanna> iqubic: in (forall a. a -> a) -> (Char, Bool), the *function* can choose ‘a’
17:06:12 <hanna> (and the caller has to provide a polymorphic function)
17:06:13 <Eduard_Munteanu> iqubic, sure
17:06:21 <hanna> iqubic: there are also rank-N types in general
17:06:24 <hanna> such as -XRankNTypes
17:06:34 <hpc> @let test :: (forall a. Show a => a -> String) -> (String, String); test f = (f 5, f False)
17:06:36 <lambdabot>  Defined.
17:06:38 <hpc> > test show
17:06:41 <lambdabot>  ("5","False")
17:06:43 <hpc> @undefine
17:06:43 <lambdabot> Undefined.
17:06:49 <hanna> which allow you to have a ‘forall’ that's nested arbitrarily deeply
17:06:58 <hpc> @let test :: Show a => (a -> String) -> (String, String); test f = (f 5, f False)
17:06:59 <lambdabot>  .L.hs:162:18: error:
17:06:59 <lambdabot>      • Couldn't match expected type ‘a’ with actual type ‘Bool’
17:06:59 <lambdabot>        ‘a’ is a rigid type variable bound by
17:07:13 <hanna> e.g. ((forall a. a -> a) -> (Char, Bool)) -> String
17:07:14 <hpc> ^ this is the error you get if you don't use a rank-2 type in this sort of use case
17:07:32 <hanna> (in which case the caller again gets to decide ‘a’, in practice)
17:07:44 <iqubic> hpc: How do we decide what rank a type?
17:08:11 <iqubic> I mean how do we determine what rank a type is.
17:08:31 <Eduard_Munteanu> Also note that foralls can be moved to the left of -> without changing rank. forall a. (a -> forall b. b) is forall a b. (a -> b)
17:08:55 <hanna> iqubic: in layman's terms, how “deeply nested” the forall is inside the parameter of a function
17:09:05 <iqubic> Oh. I see
17:09:18 <hanna> rank 0: forall a. a;  rank 1: (forall a. a) -> T; rank 2: ((forall a. a) -> T) -> X
17:09:19 <hanna> and so on
17:09:34 <hanna> note that only nesting on the “left” matters, because of what Eduard_Munteanu pointed out
17:09:40 <hpc> a rough way of putting it is the rank of a type is how many (->)'s the forall is to the left of
17:09:42 <iqubic> I see.
17:09:49 <hanna> nesting on the right doesn't exist since X -> (forall a. T) is the same as forall a. X -> T
17:09:49 <hpc> in the case of something like id
17:09:50 <hpc> :t id
17:09:52 <lambdabot> a -> a
17:10:01 <hpc> in the case of something like id, the forall is "above" the (->)
17:10:03 <hanna> formally if you would write the type as a tree it would be the depth of the forall
17:10:05 <hpc> if you view the type as a tree
17:10:07 <hanna> after floating it out
17:10:12 <hanna> (as far as possible)
17:10:21 <hpc> hanna: not quite, foralls to the right of (->) can be lifted out
17:10:26 <hpc> gotta be to the left
17:10:28 <hanna> that's what I said :)
17:10:35 <hpc> oh, derp
17:10:42 <hpc> something something majestic stereo
17:11:22 <Eduard_Munteanu> And you also don't get type inference for arbitrary rank-n types.
17:11:33 <iqubic> You don't
17:11:35 <iqubic> ?
17:11:50 <Eduard_Munteanu> No, Haskell practically only infers rank-1 types.
17:12:10 <Eduard_Munteanu> Anything else you must type explicitly.
17:12:12 <iqubic> If we use a rankNType, do I have to use an explicit forall a.?
17:12:40 <EvanR> does F# have higher ranked polymorphism, and does it infer?
17:12:42 <Eduard_Munteanu> Yes.
17:12:55 <iqubic> Eduard_Munteanu: Yes to what???
17:13:04 <Eduard_Munteanu> iqubic, just your question
17:13:12 <EvanR> or rank2 inference is undecidable
17:13:20 <hanna> rank2 type inference would be possible in some systems but not in GHC's System Fw-whatever, right?
17:13:32 <hpc> type inference is possible for rank-2 types, but iirc Rank2Types has been folded into RankNTypes so that's no longer the case?
17:13:43 <hpc> (for ghc)
17:14:19 <geekosaur> right, Rank2Types is just an alias for RankNTypes now
17:14:21 <Eduard_Munteanu> The fact that it won't infer rank-2 probably catches some errors, too.
17:14:47 <Koterpillar> https://dpaste.de/ZHwQ which Lens operator am I missing?
17:15:14 <geekosaur> .oO { most of them }
17:15:17 <Koterpillar> I want something like `to` that builds a prism
17:15:55 <Gurkenglas> > Right [True] ^? _Right . _head
17:15:57 <lambdabot>  Just True
17:16:19 <Koterpillar> Gurkenglas: sorry, bad example on my part there; I have my own function of type a -> Maybe b that I want to use
17:16:33 <dmj`> > Right [True] ^. _Right ^. to listToMaybe
17:16:35 <lambdabot>  Just True
17:16:45 <iqubic> Isn't having a prism into the head of a list a Bad Idea?
17:16:46 <glguy> Nooooo, never with two ^.
17:17:04 <Gurkenglas> > Right [True] ^? _Right . to listToMaybe . _Just
17:17:06 <lambdabot>  Just True
17:17:17 <Koterpillar> OK, this one might work, let me see
17:17:30 <iqubic> How does one create a prism in the first place?
17:17:48 <glguy> iqubic: Have you looked in the documentation yet?
17:18:18 <iqubic> Yes. It confused the heck out of me.
17:18:19 <alexv119> Lens view operator (^.) doesn't seem to work with lenses `Lens s t a b` where `s` and `t` are different. What should I use to view into those?
17:18:27 <Gurkenglas> iqubic, prism and prism'
17:18:35 <dmj`> > Left [True] ^. _Right ^. to listToMaybe
17:18:37 <lambdabot>  Nothing
17:18:41 <Koterpillar> Gurkenglas: worked great
17:18:48 <iqubic> :t prism
17:18:49 <glguy> alexv119: How are the s and t different?
17:18:49 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
17:18:52 <iqubic> :t prism'
17:18:53 <lambdabot> (Applicative f, Choice p) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
17:19:08 <Koterpillar> Is there an iso for encodeUtf8?
17:19:16 <Eduard_Munteanu> > Right [True] ^? _Right . pre listToMaybe
17:19:18 <lambdabot>  error:
17:19:18 <lambdabot>      • Couldn't match type ‘a -> Const (First a) a’ with ‘[a0]’
17:19:18 <lambdabot>        Expected type: Getting (First a) [Bool] a
17:19:18 <hanna> would be a Prism not an Iso
17:19:24 <hanna> and I'm sure it exists
17:19:25 <Eduard_Munteanu> Nvm.
17:19:41 <iqubic> What the heck are those complex type signatures for prism and prism'
17:19:55 <Eduard_Munteanu> :t prism'
17:19:56 <lambdabot> (Applicative f, Choice p) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
17:20:19 <hanna> iqubic: `choice` is basically what allows prisms to be reversed
17:20:20 <Koterpillar> iqubic: better signature for prism': (b -> s) -> (s -> Maybe a) -> Simple Prism s s a b
17:20:27 <Koterpillar> iqubic: better signature for prism': (b -> s) -> (s -> Maybe a) -> Prism s s a b
17:20:37 <hanna> think of the ‘p’ as being (->) when used normally
17:20:39 <hanna> if that helps
17:20:52 <Eduard_Munteanu> Think of 'p' as something like a special arrow.
17:21:06 <iqubic> I see.
17:21:12 <iqubic> :t lens
17:21:14 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
17:21:20 <Eduard_Munteanu> It's probably easier if you start with lens first.
17:21:21 <iqubic> :t lens'
17:21:23 <lambdabot> error:
17:21:23 <lambdabot>     • Variable not in scope: lens'
17:21:23 <lambdabot>     • Perhaps you meant ‘lens’ (imported from Control.Lens)
17:21:37 <iqubic> Eduard_Munteanu: I understand lenses fairly well. Traversals too.
17:22:01 <Gurkenglas> iqubic, :t unpacks the Prism newtype into its internal definition which is "turn small actions into big ones" for a fitting definition of action. All optics work this way.
17:22:20 <Gurkenglas> -newtype+type alias, whoops
17:22:38 <iqubic> Oh. Optics are weird.
17:22:53 <Gurkenglas> Lenses are optics, and so are traversals.
17:22:57 <iqubic> I get that.
17:22:59 <glguy> alexv119: You can use getting: http://hackage.haskell.org/package/lens-4.15.2/docs/Control-Lens-Getter.html#v:getting
17:23:14 <glguy> alexv119: But generally if this is happening you've done something wrong
17:23:49 <hanna> alexv119: ‘t’ doesn't matter at all for viewing (^.)
17:24:01 <hanna> afaik
17:24:11 <glguy> hanna: That's not quite true since (^.) constrains t to match s
17:24:41 <glguy> It's not a necessary constraint, but it can help with type inference and it should basically always be the case that they can be so constrained
17:24:41 <hanna> oh, right
17:25:00 <hanna> alexv119: if ‘s’ can't match ‘t’ then your lens almost surely violates over l id = id
17:25:28 <alexv119> glguy: hanna: I have `let l :: Lens A (Maybe A) B B` and I can't write `(undefined :: A) ^. l`. I got error: `Expected: Getting B A B, Actual: (B -> Const B B) -> A -> Const B (Maybe A)`
17:25:46 <glguy> alexv119: Your l just isn't a "lens"
17:26:08 <glguy> I needs to be the case that s and t can be unified
17:26:18 <hanna> yes, double check the lens laws and you will find they're unsatisfied
17:26:26 <Gurkenglas> Why isn't it "type Getting r s a = forall t. (a -> Const r a) -> s -> Const r t"?
17:27:09 <glguy> Gurkenglas: Getting is intended to be used as a function argument type
17:27:12 <hanna> Gurkenglas: presumably because there's no need to be that generic
17:27:25 <hanna> Gurkenglas: if a ~ b then s ~ t
17:27:32 <hanna> for legal lenses
17:28:46 <Gurkenglas> Why isn't it "type Getting r s a = exists t. (a -> Const r a) -> s -> Const r t", however you would correctly write that?
17:29:01 <glguy> Gurkenglas: We don't want quantifiers in the type
17:29:31 <hanna> Gurkenglas: actually that forall t. wouldn't even work
17:29:41 <hanna> because it would require rank2 types and also fail to typecheck with any actual lens
17:29:55 <hanna> and exists t. is not a thing that exists (ironically) in haskell
17:30:33 <hanna> it would have to be type Getting r s t a = (a -> Const r a) -> s -> Const r t
17:30:38 <hanna> but again there's no point in being this generic
17:30:45 <Gurkenglas> Why isn't it "type Getting t r s a = (a -> Const r a) -> s -> Const r t" in order for - ah, ninja'd.
17:31:04 <hanna> because of the `over l id = id` law
17:31:54 <alexv119> Ok then. What optic do I need for this: I have a fixed length vector and I want to view and modify part of it as a list. So I have two functions: getSlice :: Vector a -> [a] and setSlice :: Vector a -> [a] -> Maybe (Vector a). I thought I could combine them into lens.
17:32:23 <Gurkenglas> What do you do when your code contains "Functor f => (a -> f a) -> s -> f (Maybe s)"-type things?
17:32:48 <hanna> call it Lens' s a  ?
17:33:00 <glguy> No, the extra Maybe
17:33:29 <glguy> alexv119: No, that won't quite work out
17:33:30 <Rotaerk> hmm, is that a prism?
17:33:55 <Gurkenglas> Rotaerk, Prism' s a is a witness that s is a disjoint union of a and something else
17:34:38 <Gurkenglas> Although I guess that model doesn't predict what they do without the '.
17:35:08 * hackage n-tuple 0.0.0 - Homogeneous tuples of arbitrary length.  https://hackage.haskell.org/package/n-tuple-0.0.0 (athanclark)
17:36:34 <hanna> alexv119: what `lens` sometimes likes doing is using a semi-legal lens that is only legal as long as you make sure to follow invariants
17:37:42 <hanna> which is what partsOf does, for example
17:38:18 <Gurkenglas> Perhaps what he wants is a "Plus f => LensLike' f (Vector a) [a]"
17:38:22 <hanna> > [1..10] & partsOf (taking 3 each) .~ [100,200,300]
17:38:24 <lambdabot>  [100,200,300,4,5,6,7,8,9,10]
17:38:50 <hanna> this is only legal as long as you make sure not to “change” the number of elements
17:38:52 <hanna> > [1..10] & partsOf (taking 3 each) .~ [100,200,300,400]
17:38:54 <lambdabot>  [100,200,300,4,5,6,7,8,9,10]
17:38:57 <hanna> -- this technically violates a lens law
17:39:09 <hanna> -- since `get` followed by `set` should return [100,200,300,400] again
17:39:34 <hanna> maybe that helps your specific use case
17:40:21 <hanna> it sounds like partsOf is basically the moral equivalent of your vector slice
17:40:53 <Gurkenglas> I expected that to become a cautionary tale not a sales pitch
17:43:38 * hackage n-tuple 0.0.1 - Homogeneous tuples of arbitrary length.  https://hackage.haskell.org/package/n-tuple-0.0.1 (athanclark)
17:45:41 <platz> been thinking about how to read (.) in a "forwards" manner, since I alwasy reason about it by reading it "backwards".  would it be fair to say that in (a . b) that we take "a" and then substitute it's argument with "b" ?
17:45:44 <hanna> well yes, dealing with illegal lenses always deserves a cautionary tale
17:45:48 <Gurkenglas> Ah, it can't be Plus, because we can't let justice impact failing. We'd need MonadPlus, but we don't even want Applicative
17:46:03 <hanna> alexv119: what you could do instead is slice the traversal directly, which is perfectly legal
17:46:27 <hanna> :t toListOf (itraversed.indices even)
17:46:29 <lambdabot> error:
17:46:29 <lambdabot>     • Couldn't match expected type ‘(a1 -> Const (Endo [a1]) a1)
17:46:29 <lambdabot>                                     -> p0 a (Const (Endo [a1]) a)’
17:46:34 <kadoban> platz: I just read a string of (.) "backwards", it works fine.
17:46:35 <hanna> :t over (itraversed.indices even)
17:46:36 <lambdabot> error:
17:46:37 <lambdabot>     • Couldn't match expected type ‘(a1 -> Identity b1)
17:46:37 <lambdabot>                                     -> p0 a (Identity b)’
17:46:38 <hanna> bleh
17:46:43 <hanna> works locally for me
17:46:50 <hanna> old lens version on lambdabot?
17:47:56 <hanna> but anyway that would get you Vector a -> [a]  and (a -> a) -> Vector a -> Vector a
17:48:05 <alexv119> hanna: then I don't understand when it's legal for `Lens s t a b` have different `s` and `t`
17:48:07 <hanna> where the subset is limited to only even indices (or any other imaginable function)
17:48:19 <hanna> alexv119: it's basically only legal when ‘s’ and ‘t’ are polymorphic with different variables
17:48:24 <Gurkenglas> :t over (itraversed. Control.Lens.indices even) -- hanna, no, namespace clashes
17:48:26 <lambdabot> (Integral a, TraversableWithIndex a t) => (b -> b) -> t b -> t b
17:48:38 <hanna> the classic example would be traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:48:38 <platz> kadoban: seems to make the most sense, just wanted to make sure I wasn't missing something
17:49:04 <hanna> or: traverse :: Traversable t => Traversal (t a) (t b) a b
17:49:10 <hanna> you can see that ‘s’ and ‘t’ allows the “variable” of ‘t’ to change
17:49:23 <hanna> but you can also set a ~ b which implies t a ~ t b i.e. s ~ t
17:50:12 <kadoban> platz: Honestly my main complaint about: blah . something . this . whatever  is it's kind of annoying to type, working backwards. More of an editor problem than anything though.
17:51:44 <hanna> kadoban: that's a mindset thing more than anything
17:51:55 <alexv119> hanna: I see.
17:51:55 <hanna> i.e. do you start in terms of what something ultimately is and work your way “backwards” to the argument
17:52:05 <hanna> or do you start in terms of what you have and work your way “forwards” to the solution
17:52:28 <kadoban> I almost always work my way forwards to the solution. Working backwards usually seems awkward to me.
17:52:37 <hanna> I find it's often easier to start with what result I want and then work my way backwards
17:52:45 <hanna> but it depends on the situation, as always
17:53:07 <sveit> is it true that "f <*> a = f >>= flip fmap a" always a good implementation of (<*>) when (>>=) is defined?
17:53:19 <kadoban> I more and more find myself using a flipped (.), which is probably not great for sharing code.
17:53:57 <platz> (.) is almost like substitution.. application substitues with the whole term, (.) substitues with just the result
17:54:10 <hanna> sveit: it's true in that it's always legal, yes; define “good”
17:55:18 <sveit> hanna: for now, i meant legal :) my follow-up is more subjective. I was wondering why this definition is not used in transformers here: https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.Maybe.html#line-130
17:55:33 <platz> seems like the question is whether you want to substituion as "forwards" or "backwards"
17:55:43 <platz> 'want want to think of'
17:55:53 <sveit> it seems just as performant, more concise, and more obviously correct than the one used there. just trying to get some sense of "good" haskell coding style.
17:56:17 <hanna> f >>= flip fmap a  is basically  f >>= \x -> a >>= \y -> return (x y) which is the definition of `ap`
17:56:39 <alexv119> hanna: glguy: thanks for help!
17:58:00 <hanna> sveit: good haskell coding style if you don't want to implement your own <*> would be to set it to `ap`
17:58:16 <sveit> hanna: yep. like i said, i was pretty sure f >>= flip fmap a was correct, my "real" question is in that case why is it not used instead of the more verbose definition
17:59:05 <hanna> sveit: a lot of haskell authors have the mindset of “if I write it out it'll be faster / better for inlining / folding / whatever”
17:59:19 <hanna> If it isn't actually faster, and you can back this up with benchmarks, perhaps submit a pull request? :)
17:59:54 <hanna> you'll find this mindset especially prevalent among “core” libraries that are supposed to be “fast”
18:00:05 <hanna> which `transformers` certainly qualifies as
18:02:57 <Guest21952> hi, it is not clear to me why Identity x >>= f == Identity (f x), since (f x) is Identity  
18:02:58 <sveit> i see. it's a bit worrisome that even such "simple" optimizations are not reliable.
18:03:42 <hanna> sveit: If you want to investigate this more closely, it would probably be a good first step to check the generate core and see if it results in the same code
18:03:50 <hanna> there's a chance it might
18:04:00 <hanna> and if not, think about what those differences are and what problems they could cause
18:04:25 <ertes> Guest21952: Identity x >>= f = f x
18:05:06 <ertes> :t (\(Identity x) f -> f x) :: Identity a -> (a -> Identity b) -> Identity b
18:05:07 <lambdabot> Identity a -> (a -> Identity b) -> Identity b
18:05:11 <hanna> fmap f (Identity x) = Identity (f x)
18:05:30 <Guest21952> I got this from http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Identity.html#t:Identity 
18:05:32 <EvanR> platz: you cant really expand f . g until you have x, f(g(x))
18:05:47 <EvanR> g itself isnt the argument
18:05:59 <hanna> Guest21952: congratulations, you've found an error in documentation :p
18:06:18 <ertes> Guest21952: yeah, that's a definite documentation error
18:06:41 <ertes> Guest21952: you may want to report it =)
18:07:05 <hanna> EvanR: pretty sure that's what he meant by substitute with “the result”
18:07:14 <hanna> these are mental models anyway
18:07:29 <EvanR> i didnt see that
18:07:36 <Guest21952> ertes, to whom ?
18:08:04 <hanna> platz: in terms of how I think, it's more like thinking in terms of “okay, now what does this want?”; like say I have a function mkFooBar :: * -> FooBar and I know I want a FooBar; I'll type in “mkFooBar” and then thinkg about what mkFooBar itself “wants”
18:08:18 <ertes> Guest21952: https://github.com/ekmett/mtl/issues
18:08:26 <hanna> obviously this works better the more well-typed your things are
18:08:31 <ertes> Guest21952: alternatively just fix it and issue a pull-request
18:08:46 <Guest21952> ertes, ok, thanks
18:08:48 <hanna> If it's all stuff like  Int -> Int or [a] -> [a] I usually do the other way around (incrementally building up my result)
18:08:58 <ertes> and you shall be forever engraved in the mtl contributors list
18:09:12 <EvanR> special thanks to Guest21952 for doc fixes
18:12:13 <platz> yes, the backwards way is natural for me
18:12:46 <EvanR> once you have x, then you can have f(g(h(x)), and then you can start reading it forwards starting with f
18:12:59 <EvanR> like peeling an union
18:13:01 <EvanR> onion
18:13:39 <EvanR> const 3 . (+1) . sum . group
18:13:49 <platz> in terms of the types, without choosing concrete types, i don't see why i "x" is a think i should need
18:14:03 <EvanR> because theres nothing to substitute into the f
18:14:03 <platz> of course f . g = \x -> f(g(x))
18:14:25 <platz> yes, but i'm not thinking about values yes
18:14:27 <ertes> i think that backwards reading is an acquired taste
18:14:28 <platz> yet
18:14:30 <EvanR> you could use invisible spaces, but itll get confusing if theres more than one thing like that
18:14:36 <platz> i'm only thinking about types
18:15:00 <hanna> if functions are the first-class citizens in your brain then the values you pass into them are irrelevant
18:15:40 <platz> :t fromInteger
18:15:41 <lambdabot> Num a => Integer -> a
18:15:43 <platz> :t toInteger
18:15:44 <lambdabot> Integral a => a -> Integer
18:15:48 <platz> :t fromInteger . toInteger
18:15:49 <lambdabot> (Num c, Integral a) => a -> c
18:18:40 <platz> so reading forwards, can i say "i need to substitute Integer in the type sig of 'fromInteger' with the "result" of 'toInteger' and float the argument of 'toIngeter' out
18:19:01 <platz> probably not helpful
18:19:02 <EvanR> come to think of it, forwards and backwards dont even necessarily make sense..
18:19:42 <EvanR> f(g(h(x)) isnt forwards or backwards
18:20:13 <EvanR> i have heard confusing tales of haskell being explained as "left to right vs right to left"
18:20:23 <EvanR> and $ somehow factors in
18:20:27 <hanna> “forwards” means “eager evaluation”, “backwards” means “lazy evaluation”
18:20:30 <hanna> to some extent
18:20:32 <EvanR> o_O
18:20:49 <EvanR> now i really dont know what were talking about
18:21:21 <slack1256> Is there a good way to navigate of mailing list archive?
18:21:23 <hanna> in an eager evalutaor, you start with ‘x’, then compute ‘h’ on it, then compute ‘g’ on it, then compute ‘f’ on it -> “control flow” is “forwards” in some sense
18:21:36 <EvanR> evaluating f applied to an argument before evaluating its argument, seems syntactically forward to me, if anything
18:21:38 <hanna> in a lazy evaluator, you start by ignoring g(h(x)) and peek inside the body of ‘f’, replacing its parameter
18:21:40 <slack1256> I've thinking on downloading all of -cafe for searching answers
18:21:48 <hanna> then when that eventually looks at the argument, you peek inside ‘g’, and so on
18:21:52 <hanna> working your way “backwards” to the ‘x’
18:22:03 <EvanR> the words youre using seem backwards themselves
18:22:16 <hanna> well “forwards” and “backwards” are symmetric :)
18:22:22 <hanna> if your brain works the other way around, feel free to swap the words
18:22:32 <EvanR> im going to argue they mean nothing
18:24:51 <ertes> there is no inherent reason to prefer one over the other, other than personal taste
18:25:27 <hanna> EvanR: well “forward” to me means that say you have a function f :: X -> Z (given let's say X -> Y and Y -> Z);  you would start from the input and work your way “forwards” to the output; i.e. you first think about the step :: X -> Y; and then you have a Y, so then you think about the step :: Y -> Z
18:25:33 <EvanR> a word? im not sure what were referring to anymore. evaluation order? reading ordering?
18:25:43 <ertes> slack1256: yes, download it to get a local Maildir, then use notmuch =)
18:25:51 <hanna> “backward” to me means that you start by thinking “okay I want a Z, where do I get a Z from? oh right, the Y -> Z.. okay so now I want a Y, where do I get a Y? oh right, I can use X -> Y”
18:26:01 <hanna> basically starting with the function output and working your way “backwards” to the input
18:26:10 <hanna> It's a question of what order you need to type things in when using (.), for sure
18:26:16 <EvanR> you dont start with output
18:26:22 <hanna> But see I often do
18:26:28 <hanna> and I argue that this matches haskell's nonstrict model better
18:26:33 <hanna> because haskell also “starts with the output”
18:26:38 * hackage mailchimp 0.3.0 - Bindings for the MailChimp API  https://hackage.haskell.org/package/mailchimp-0.3.0 (jpvillaisaza)
18:26:40 <EvanR> you cant start with output, thats the end
18:26:44 <hanna> It also matches the argument order of (.)
18:26:46 <EvanR> youd already be done, which we know were not
18:26:56 <EvanR> f isnt the output
18:27:13 <hanna> Well you're free to draw whatever ignorant conclusions you want about what what mental processes you can and can't use
18:27:21 <EvanR> i think a better way to talk about the expression at hand is top down, as if it were a tree
18:27:26 <EvanR> not left right right left
18:27:30 <EvanR> or inside outside
18:27:37 <EvanR> you start with the outside
18:27:44 <EvanR> but thats not the output or the final answer
18:27:59 <hanna> nvm
18:28:40 <EvanR> and you have nothing to evaluate without providing the x
18:29:39 <platz> so for  (f . g) = \x -> f(g(x)), we see that x unifies with the argument of g
18:30:05 <platz> so x can be implicit, it's really only the argument of g
18:30:18 <EvanR> right, so you can begin with a blank spot everywhere x would be
18:30:30 <EvanR> and if the answer were x itself, youd see nothing
18:31:07 <EvanR> id . id would then be considered <blank space>
18:32:00 <platz> everyone is right
18:39:01 <athan> Does anyone here know of a `Word16 -> (Word8, Word8)` function?
18:39:34 <platz> slack1256: gmane use the be the best but since it's broken i know some folks use emacs, but a bit of a learning curve to get comfortable with NNTP in emacs
18:40:26 <EvanR> athan: which such function would you like
18:40:37 <pacak> athan: const (0, 0)
18:40:42 <athan> EvanR: The one which breaks it in half
18:40:47 <EvanR> theres 2 ways to do that
18:41:03 <EvanR> which is why we have LE and BE shenanigans
18:41:27 <pacak> athan: Data.Bits is your friend
18:41:45 <pacak> You need one shift and two fromIntegral
18:43:41 <athan> pacak: hmm... so, rather than a tuple we could use `data Broken a = Broken {greater :: a, lesser :: a}` or something
18:43:59 <athan> then have `breakWord16 :: Word16 -> Broken Word8` or something
18:44:06 <pacak> :t V2
18:44:08 <lambdabot> error:
18:44:08 <lambdabot>     • Data constructor not in scope: V2
18:44:08 <lambdabot>     • Perhaps you meant variable ‘_2’ (imported from Control.Lens)
18:44:33 <pacak> linear package.
18:44:50 <pacak> athan: Word8 will still take 64 bits btw.
18:45:15 <athan> eh I'm just concerned with semantics :) but thank you for the warning
18:46:32 <EvanR> athan: good idea
18:50:22 <EvanR> too bad you cant do fix Broken
18:51:45 <orzo> I'm trying to make a constraint kind type function, but i keep getting this unhelpful error message: Expected a constraint, but ...  has kind ‘*’
18:51:55 <athan> lol
18:51:57 <orzo> i understand it has kind '*', but how do i make it have kind constraint
18:52:29 <athan> orzo: constraints decide type variables
18:52:35 <athan> like `foo :: Ord a => a...`
18:52:39 <orzo> yes
18:52:42 <orzo> Ord is a constraint
18:52:43 <athan> not decide - help in the decidability
18:52:52 <athan> `Ord a` has a kind Constraint
18:52:56 <orzo> i'm trying to use ConstraintKinds
18:53:02 <athan> `Ord :: * -> Constraint`
18:53:12 <orzo> type family SerializableTo raw a
18:53:42 <athan> just return a Constraint in the type family
18:53:45 <orzo> i want SerializableTo ByteString a to resolve to Binary
18:54:02 <athan> where `Binary` is a typeclass?
18:54:09 <orzo> er
18:54:10 <orzo> Binary a
18:54:20 <orzo> SerializableTo ByteString = Binary
18:54:33 <athan> what's Binary?
18:54:35 <athan> is that a class?
18:54:49 <orzo> it's a class, yes, the usual serialization class
18:55:00 <orzo> you're unfamiliar?
18:55:09 * athan still hasn't messed with it
18:55:11 <athan> hm okay
18:55:16 <orzo> Data.Binary from binary package
18:55:27 <orzo> could also use Serializable from cereal package
18:55:43 <athan> I'd do `type SerializableTo ByteString a = Binary a`
18:56:07 <orzo> well no, i want a type family SerializableTo and i want the particular instances defined elsewhere
18:56:17 <athan> you can always add kind signatures to help locate the type mismatch
18:56:29 <athan> oh an open type family?
18:56:41 <athan> you should still be okay iirc
18:56:41 <orzo> type family SerializableTo raw a :: Constraint
18:56:43 <orzo> that doesn't compile
18:56:59 <orzo> it says Not in scope: type constructor or class ‘Constraint’
18:57:24 <orzo> does that symbol need to be imported?
18:57:25 <athan> I think it's `import Data.Constraint (Constraint)`
18:57:29 <athan> yeah
18:57:36 <orzo> that's a little odd
18:57:42 <athan> :)
18:57:44 <orzo> i mean, '*' is built in and this is just as special
18:58:05 <orzo> thanks, it compiles now
18:58:11 <athan> I think `Type` is actually technically more built-in than * now lol
18:58:15 <athan> np
18:58:17 <MarcelineVQ> except when you need to import Data.Kind to use * in interesting ways
18:59:53 <riaqn> Hi, is there some fast way to call C function simply by the header files?
19:00:10 <riaqn> I mean like, generating hsc file from C header.
19:00:36 <Axman6> possibly hsc2hs? I can't remember what tools do that automatically
19:01:02 <Axman6> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/hsc2hs.html
19:02:36 <riaqn> Axman6: yeah, but that thing  is more like addressing a field in C struct.
19:02:42 <orzo> the error message should probably mention the symbol 'Constraint' and the module 'Data.Constraint'
19:02:48 <riaqn> Maybe I didn't phrase my question well.
19:03:08 <riaqn> I'm hoping to generate FFI from C headers.
19:03:16 <orzo> it's irksome to be told it wants a constraint with no clue how to make it one
19:05:46 <orzo> should be like any type error, expected kind blah, actual kind blah
19:05:58 <orzo> where blah shows me actual haskell notation for the kind
19:06:14 <MarcelineVQ> orzo: you're supposed to read the manual section relevant to an extension before using it :> which does mention importing Constraint, though it suggests doing so from GHC.Exts
19:06:25 <orzo> i've read it too long ago
19:06:34 <orzo> obviously
19:07:36 <orzo> MarcelineVQ: that response could be given to any body who is confused by any errore message at any time
19:07:46 <MarcelineVQ> Absolutely
19:08:03 <MarcelineVQ> But more applicably with specific extensions since it's easy to find the relevant section
19:08:15 <John[Lisbeth]> has haskell been ported to lambda calculus?
19:08:17 <MarcelineVQ> Anyway you've got it sorted out now
19:08:22 <athan> pacak: So only /one/ bit shift?
19:08:33 <athan> is required to break the Word16 I mean
19:08:37 <pacak> athan: yep.
19:08:40 <athan> hmm
19:09:01 <pacak> >  (fromIntegral :: Word16 -> Word8) 1025
19:09:03 <lambdabot>  1
19:09:16 <athan> oh, but by some number of bits
19:09:29 <athan> so `shift foo n` shifts it by n bits
19:09:49 <athan> did you mean that n == 1?
19:10:00 <pacak> Lower half you can get without shifting
19:10:14 <athan> x_x
19:10:15 <pacak> >  (fromIntegral :: Word16 -> Word8 . shiftR 8) 1025
19:10:17 <lambdabot>  <hint>:1:34: error:
19:10:17 <lambdabot>      Illegal symbol '.' in type
19:10:17 <lambdabot>      Perhaps you intended to use RankNTypes or a similar language
19:10:24 <pacak> >  ((fromIntegral :: Word16 -> Word8 ). shiftR 8) 1025
19:10:27 <lambdabot>  0
19:11:01 <pacak> >  ((fromIntegral :: Word16 -> Word8 ). flip shiftR 8) 1025
19:11:03 <lambdabot>  4
19:11:16 <athan> :|
19:11:24 <athan> I don't understand why you did that
19:13:01 <athan> sorry pacak I'll venture elsewhere :) thank you for your help!
19:23:42 <suzu> omfg
19:23:51 <suzu> i haven't been using --fast when doing stack build for days
19:24:07 <suzu> and it was taking like >30sec to build my project
19:24:08 <suzu> fml
19:36:08 <unknown1n> @type concat . map
19:36:10 <lambdabot> Foldable ((->) [a]) => (a -> a1) -> [a1]
19:36:47 <unknown1n> @type (\f -> concat . map f)
19:36:48 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
19:37:22 <unknown1n> @type flip (\f -> concat . map f)
19:37:23 <lambdabot> [a1] -> (a1 -> [a]) -> [a]
19:53:17 <John[Lisbeth]> has haskell been ported directly to the lambda calculus?
19:55:41 <Axman6> John[Lisbeth]: not sure what you mean, while that might be possible, I wouldn't say it's very useful
20:03:37 <qmm> if in app/main.hs i do args <- getArgs ; Lib.execWith args ; how do i access the args passed into execWith from within execWith?
20:04:08 <Axman6> is execWith something you've written?
20:04:14 <qmm> yeah
20:04:20 <Axman6> args is just a [String] that's passed to execWith
20:04:28 <Axman6> it's nothing special
20:04:40 <qmm> execWith :: args -> IO () ; execWith = do { if null args then print "is null" else print $ show args }
20:05:04 <Axman6> your type is wrong
20:05:15 <Axman6> that's the same as saying execWith :: a -> IO ()
20:05:31 <qmm> getArgs :: IO [String]
20:05:32 <Axman6> it should be execWith ::[String] -> IO ()
20:05:39 <qmm> i will try that
20:06:40 <qmm> that did it
20:10:43 <NateJackDev> hello
20:10:51 <lambdabot> Hello.
20:11:51 <EvanR> time for a turing test
20:14:24 <NateJackDev> Turing Test?
20:18:13 <qmm> is this legal do { print "foo" ; doThings someValue } -- where doThings takes the type of someValue and returns an IO ()
20:18:51 <pavonia> Should be
20:19:01 <EvanR> yes thats not really different from print "foo"
20:19:10 <EvanR> takes "foo" returns an IO ()
21:08:38 * hackage jsaddle-warp 0.9.1.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-warp-0.9.1.0 (HamishMackenzie)
21:24:15 <Ninja_Coder> I want to use unpack from Data.ByteString.Char8, but import Data.ByteString.Char8 , causes many errors in my program such as
21:24:17 <Ninja_Coder> Ambiguous occurrence `putStrLn'
21:24:17 <Ninja_Coder>     It could refer to either `Prelude.putStrLn',
21:24:17 <Ninja_Coder>                              imported from `Prelude' at generate.hs:1:1
21:24:17 <Ninja_Coder>                              (and originally defined in `System.IO')
21:24:18 <Ninja_Coder>                           or `Data.ByteString.Char8.putStrLn',
21:24:18 <sm> huh, isn't there a doctest shim for tasty ?
21:24:19 <Ninja_Coder>                              imported from `Data.ByteString.Char8' at generate.hs:6:1-28
21:24:29 <Ninja_Coder> how would I fix the ambiguous occurence?
21:25:07 <Ninja_Coder> Its probably really simple, but doing qualified imports isn't working correctly for me 
21:25:10 <exio4> Ninja_Coder: you can import Data.ByteString.Char8 qualified 
21:25:20 <Ninja_Coder> could you give me an example, Im probably doing the syntax wrong
21:25:32 <exio4> Ninja_Coder: ``` import qualified Data.ByteString.Char8 as C8 ``` 
21:25:43 <exio4> Ninja_Coder: then you do C8.xyz to call a function from Data.ByteString.Char8 
21:25:56 <Ninja_Coder> Oh great! Thank you exio4!
21:27:11 <Ninja_Coder> great it works :)
21:34:10 <orzo> weird, Data.Constraint isn't even in base.  To make a Constraint family I need to link against the constraints package
21:34:55 <orzo> hm, nevermind, Data.Kind exports it from base
21:40:03 <sm> poor doctest, nothing much integrates with it
21:40:23 <sm> there's http://hackage.haskell.org/package/test-framework-doctest, but looking quite deprecated
21:42:16 <glguy> sm: cabal-doctest
21:43:22 <sm> I want to integrate it with other kinds of tests
21:44:07 <sm> with multiple separate test suites I realised I was missing some doctest failures because they scrolled offscreen
21:45:22 <sm> https://github.com/sol/doctest/issues/106 seems to imply it might be not entirely easy
21:46:46 <sm> also, it would be great if doctest was fast
21:47:26 <glguy> yeah, doctests are the slowest part of the lens travis job
21:51:43 <glguy> I think it does one compile/link per doctest
22:13:40 <slack1256> On the turtle library, the main way to combine Shell a is via (&) right? Usual functions got the types Shell a -> Shell b
22:13:48 <slack1256> is it something I am not seeing?
22:20:18 <cocreature> slack1256: well you can also just use regular function application
22:20:37 * hackage sensu-run 0.1.0 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.1.0 (MitsutoshiAoe)
22:21:07 <slack1256> yeah, but its weird no seeing Monad or Applicative on the spotlight. lol
22:22:52 <cocreature> Shell is an instance of Monad but not everything fits that pattern
22:25:01 <slack1256> How useful would be to extend haddock to add highlight to certain instances? For example the foldl package, relies *a lot* on Applicative for it just to be a single line in the html page
22:25:47 <slack1256> It should be more notorious that fundamentally you should be using that class with it
22:29:36 <glguy> That kind of information can be included in the haddock comment on the type, and instances support comments, too
22:31:11 <glguy> some examples http://hackage.haskell.org/package/prettyprinter-1.0.1/docs/Data-Text-Prettyprint-Doc.html#t:Doc
22:33:26 <jordan3353> can someone help me real quick with implementing a stack machine?
22:33:27 <jordan3353> http://lpaste.net/4579163151672541184
22:36:44 <cocreature> jordan3353: what does “doesn’t work” mean here?
22:37:23 <glguy> jordan3353: Get rid of the extra ()s
22:37:31 <glguy> interpret [] stack prg =
22:37:38 <glguy> interpret (pop:prest) stack prg =
22:38:17 <slack1256> glguy: awesome, I didn't know that!
22:38:35 <cocreature> the rhs of the last line should probably be "interpret prest srest prg"
22:38:48 <cocreature> prest is not a function so applying it to srest and prg is not going to work
22:39:45 <jordan3353> https://thepasteb.in/p/qjhLw9RX3znSB
22:40:06 <jordan3353> interpret (pop:prest) (a:srest) prg = prest srest prg
22:40:14 <jordan3353> thats my last line atm
22:40:25 <glguy> jordan3353: read the rest of the chat messages
22:40:26 <cocreature> that’s what I was trying to explain just now
22:40:49 <jordan3353> this is where im stuck
22:41:06 <glguy> jordan3353: read the rest of the chat messages
22:41:29 <jordan3353> i removed the extra ( ) glguy
22:41:40 <glguy> Good, keep reading
22:41:46 <cocreature> jordan3353: take a look at what I wrote :)
22:42:18 <jordan3353> "the rhs of the last line" what does rhs mean?
22:42:24 <cocreature> right hand side
22:42:29 <cocreature> i.e. the things on the right of "="
22:42:42 <jordan3353> ohh
22:43:13 <jordan3353> yes it works now so far
22:52:07 <jordan3353> interpret (Add:prest) (a:b:srest) prg = interpret prest (b+a:srest) prg
22:52:21 <jordan3353> this line doesnt work because Add isnt expected
22:52:38 * hackage time-qq 0.0.1.0 - Quasi-quoter for UTCTime times  https://hackage.haskell.org/package/time-qq-0.0.1.0 (ChristianMarie)
22:53:03 <jordan3353> how can i make the program expect PrimOp instead of StackCmd right now?
22:53:41 <cocreature> change the type signature, but I don’t think that’s what you actually want to do. you probably want to pattern match on (PrimOp Add:prest)
22:54:32 <jordan3353> i tried that
22:54:38 <jordan3353> but the compiler says Not in scope: data constructor ‘PrimOp’
22:54:50 <cocreature> eh sry "Op Add"
22:55:52 <jordan3353> it works now but theres a warning
22:55:59 <jordan3353> Pattern match(es) are overlapped
22:57:00 <stobix> good morning haskellers!
22:57:15 <cocreature> jordan3353: you’ll have to show us the code producing the warning
22:57:26 <cocreature> stobix: good morning :)
22:57:40 <stobix> :)
22:59:15 <glguy> jordan3353: what materials are you reading to learn Haskell?
23:00:47 * stobix has just finished writing (and documenting!) some XMonad modules. Feels so good when things fall into place! (Especially when you're actually using the code on a daily basis.)
23:01:08 <jordan3353> im reading Real World Haskell
23:01:27 <matrium> hi, one of my library processes a file using template haskell during compile time and everything works fine. but when running ghci in a project importing the library, the relative file path can not be resolved. Any clue how to fix this?
23:01:39 <jordan3353> cocreature the program is working so far even with the pattern matching warning
23:04:51 <glguy> matrium: in the past I've computed the file path relative to the module's path
23:04:53 <glguy> e
23:05:31 <glguy> you can use CPP's __FILE__ , and there's a way to get that path from template haskell
23:07:16 <cocreature> jordan3353: it probably isn’t working in all correctly for all inputs, there is a reason that warning exists. but if you’re not willing to show us the code you’ll have to figure this out yourself
23:14:14 <jordan3353> cocreature i fixed it now im at this point http://lpaste.net/4579163151672541184
23:14:32 <jordan3353> i want to interpret a list of stack commands
23:34:21 <ricksanchez> Hello, I guess many of you use emacs haskell-mode, how can I change the default indentation 2, I changed this: '(haskell-indent-spaces 4), but no effect at all on new lines and tab key
23:34:55 <iqubic> When would one every want to use a MonadTransformer like MaybeT?
23:35:01 <iqubic> I can't think of any use case.
23:35:35 <iqubic> I get that MaybeT IO String is a thing that's used for parsing, but I just don't get how.
23:37:01 <EvanR> iqubic: MaybeT gives you a way to exit early from an action in another monad
23:37:35 <EvanR> essentially, you can throw a pure exception with no content
23:38:21 <EvanR> in the case of MaybeT IO, though, your IO effects prior to that will happen anyway
23:38:25 <iqubic> What the heck?
23:39:05 <EvanR> :t runMaybeT
23:39:07 <lambdabot> error: Variable not in scope: runMaybeT
23:39:21 <EvanR> runMaybeT :: MaybeT m a -> m (Maybe a)
23:39:23 <iqubic> So let's say I have a parser of type (String -> Maybe a) -> String -> IO a
23:39:39 <iqubic> Or rather an input Taking function of that type
23:39:40 <nesqi> mapMaybeT :: (m (Maybe a) -> n (Maybe b)) -> MaybeT m a -> MaybeT n b 
23:40:02 <EvanR> i dont understand how that function could work
23:40:27 <EvanR> if you get Nothing, what do you return
23:40:45 <EvanR> oh, its a prompt
23:41:11 <iqubic> EvanR: Yeah
23:41:40 <EvanR> so are you calling the function passed in the parser
23:41:41 <EvanR> or
23:42:50 <EvanR> because that doesnt require any IO
23:42:52 <iqubic> http://dpaste.com/00YH4RM
23:43:03 <iqubic> That is the function I'm talking about.
23:43:29 <EvanR> ok, so you dont seem to need any "exit early" functionality
23:43:42 <iqubic> Parser uses readMaybe to verify the String
23:43:50 <EvanR> ok
23:44:20 <iqubic> EvanR: I don't?? I just keep asking for an input until I get something that works. Is that not exit early?
23:44:44 <EvanR> no its exiting exactly on time
23:45:06 <EvanR> its an IO a, you execute it, eventually it returns a, when the action is complete
23:45:14 <iqubic> EvanR: Why would you ever need to exit early then??
23:45:48 <iqubic> I can't think of a single case when MaybeT IO would be needed.
23:45:49 <EvanR> are you sure thats the question you want to ask?
23:46:22 <iqubic> In fact I don't see why any monad transformers exist. Isn't it fine to use only one monad at a time
23:46:30 <EvanR> you do use one at a time
23:46:44 <iqubic> Even with a Monad Transformer Stack?
23:46:48 <EvanR> yep
23:47:10 <iqubic> I thought a return type of MaybeT IO a was like returning IO (Maybe a)
23:47:11 <EvanR> but some people like their 1 monad to more complicated than others
23:47:16 <iqubic> That's two monads.
23:47:25 <EvanR> MaybeT IO is 1 monad
23:47:30 <iqubic> It is??
23:47:31 <EvanR> IO is 1 monad
23:47:36 <EvanR> Maybe is 1 monad
23:47:45 <iqubic> What about StateT IO a?
23:47:50 <EvanR> StateT IO is 1
23:47:52 <iqubic> Is that one complex monad?
23:47:56 <EvanR> yep
23:48:05 <iqubic> I don't get when you'd ever want or need StateT
23:48:09 <EvanR> whether you used a transformer to get it, or made it yourself, which you can do, its still 1
23:48:22 <iqubic> Regular State is enough for me.
23:48:36 <EvanR> sweet
23:48:54 <iqubic> Wait, can't you use the State Monad to implement a zipper? Like for a list or a tree or something?
23:49:17 <iqubic> Just have it be State currentVal dataStructure
23:49:39 <EvanR> not sure why youd do that
23:49:54 <iqubic> Just an example for example's sake
23:50:16 <EvanR> if you only have 1 mutable variable in your algorithm, then a State program will be pretty natural
23:50:28 <iqubic> What good is the Reader Monad?
23:50:50 <EvanR> it passes a single argument in "implicitly" for you
23:50:58 <EvanR> so you dont have to
23:52:08 <EvanR> its good when your algorithm exists in some fixed environment, like env vars in C
23:52:34 <EvanR> though it would be even nicer if you didnt have to use monads to get at that environment
23:52:57 <EvanR> just accessing a fixed environment isnt much of an effect
23:53:50 <iqubic> Oh.
23:53:53 <EvanR> this backpack thing might help with that
23:54:20 <iqubic> Maybe I'll understand these things better when I come across a use case for them in the wild.
23:54:50 <iqubic> For now I'm just looking for explanations for explanation's sake
23:55:13 <EvanR> try accomplishing something useful in haskell, call back later
23:55:21 <iqubic> I will do that.
23:56:01 <iqubic> So let's say I'm writing an IO function. Do all the values I assign have to be of type IO a.
23:56:18 <EvanR> do you mean x <- ...
23:56:23 <iqubic> Yeah.
23:56:30 <EvanR> thats not assignment, its monad bind
23:56:36 <iqubic> x <- someFunction
23:56:49 <iqubic> does the return type of someFunction have to be IO a?
23:56:50 <EvanR> in that position, someFunction probably isnt a function
23:56:54 <EvanR> its an action
23:56:57 <iqubic> Oh.
23:57:01 <glguy> IO actions aren't functions, either
23:57:23 <iqubic> So how do I do non-IO stuff in an IO function?
23:57:36 <glguy> I'm too slow on my phone. I'll leave it to Evan
23:58:01 <iqubic> I found that doing x <- pure $ someFunction arg1 arg2 agr3 works
23:58:13 <cocreature> let x = someFunction arg1 arg2 arg3
23:58:13 <EvanR> :t pure
23:58:15 <lambdabot> Applicative f => a -> f a
23:58:34 <iqubic> And then someFunction can return anything I'd like, IO or not.
23:58:44 <EvanR> to assign stuff to a variable in do notation you use let like ^
23:58:53 <iqubic> Oh.
23:58:59 <EvanR> but i could have sworn you knew that
23:59:20 <iqubic> I just use "x <- pure $ someFunction" which might not be the best
23:59:33 <EvanR> x <- return foo is the same as let x = foo
23:59:42 <EvanR> pure = return
23:59:54 <iqubic> Oh. So is my method acceptable?
