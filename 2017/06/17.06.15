00:31:22 <cocreature> saurabhn_: the other day I was looking for something that allows me to procrastinate so I wrote a small lib that deserializes postgresql rows to Haskell records based on column names. if you still need that, you can find it at https://github.com/cocreature/postgresql-named
00:31:39 <saurabhn_> brilliant!
00:31:41 <saurabhn_> yes, definitely need that
00:32:25 <cocreature> I wouldn’t yet recommend it for production use but I intend to polish it up over the next days and then I’ll do a hackage release
00:32:57 <merijn> I've got plenty of stuff you can do to procrastinate :p
00:33:30 <saurabhn_> cocreature: IMO, this should be something that should be part of pg-simple itself. Please consider a PR.
00:34:57 <saurabhn_> right now I'm stick with writing a ToJSON instance for Data.Decimal
00:35:30 <cocreature> merijn: you need to find the right moment to get me interested in your stuff :)
00:36:31 <merijn> cocreature: Well, there's reviving opaleye-sqlite and consolidating the common code between it and opaleye, there's finally implementing an ADOPT pragma to allow for per instance silencing of orphan warnings (rather than the entire module), implementing pager support for cabal... :p
00:37:07 <cocreature> merijn: I’m a postgresql/sqlite-simple person so my interest in reviving opaleye-sqlite is really small :)
00:37:10 <bartavelle> "implementing pager support for cabal" <- what does taht mean ?
00:37:57 <cocreature> merijn: the ADOPT pragma would be great. I might add that to the list of things I could give a shot when I need to procrastinate :)
00:38:02 <ongy> the compile errors from cabal can be a bit large, so it could be nice to have it in a pager
00:38:20 <bartavelle> oh, right, would be useful for servant
00:38:21 <merijn> bartavelle: A flag where it automatically pipes stuff into a pager like less
00:38:33 <ongy> bartavelle: I think systemds journalctl does that, shot messages will be printed and anything longer than (I guess 25?) lines is piped into a pager
00:38:57 <bartavelle> yeah, so does psql
00:39:05 <merijn> Right now I've got it aliased, but since I'm hoping the work on GHC errors will include colour codes a specific pager flag that ensures it doesn't disable colouring would be nice
00:39:11 <bartavelle> didn't understant what this meant in the cabal context
00:39:16 <bartavelle> understand
00:39:26 <merijn> ongy: Actually, with less you can simply configure less to handle that for you and just always pipe
00:39:48 <cocreature> wow Coq managed to produce an error that’s significantly worse than GHC error messages
00:40:36 <merijn> ongy: "less -F" configures less to auto-quit when it hits end of input before running out of screen
00:41:06 <merijn> But yeah, all terminal output is better with colouring
00:45:49 <ongy> less can do the colours, so if there's a force colour option, that would still work. And is -F only if it reaches that in one screen? I knew of an option to exit once the end is displayed
00:46:44 <merijn> ongy: -F only exits if it's less than one screen. If it's more it stays open until you quit explicitly
00:47:18 <merijn> There's also an option to quit when you hit end, but with multi-screen output I usually want to scroll back up when I hit end
01:11:11 <merijn> ugh...next time I'm writing a build-system I'm just going Shake right away >.>
01:11:17 <merijn> Must be easier to debug than gmake...
01:27:45 <aphorisme> The good old design question: I've a few pure functions which return some `Either ExceptionType a` which are about to get called within an `IO` function, since they need to get arguments from files, user input, etc. Would you make the `IO` function into something like `... -> IO (Either ExceptionType a)` or just `IO a` and let the function throw on an exception?
01:30:04 <piyush-kurur> saurabhn_: did the code that I sent you work out?
01:31:01 <saurabhn_> piyush-kurur: no, not really... I'm still stuck with trying to understand it... I don't want to blindly copy-paste.
01:31:18 <merijn> aphorisme: My golden rule: Library APIs should return either, applications should use exceptions (assuming you don't plan to "work-around" the error)
01:31:53 <merijn> aphorisme: An acceptable library compromise would be to default to Either and expose a throwing variant for users that want to "opt-in" to exceptions
01:32:22 <aphorisme> merijn: So even within `IO` you would rather return `Either e x`?
01:32:55 <merijn> aphorisme: Yes, because it makes it *very* clear which errors I need to handle as a user
01:33:04 <aphorisme> good point.
01:33:28 <merijn> aphorisme: Like I said, you can basically have "foo :: IO (Either e x)" and then also add "foo_ :: IO x" which throws an exception
01:33:44 <merijn> or have a separate module that contains throwing versions of functions
01:33:57 <merijn> For applications this is less relevant since you're both author and consumer of the code
01:35:00 <aphorisme> I see. I might give it a try this way – to see which exceptions can happen sounds convincing. 
01:35:53 <merijn> aphorisme: Personally I'm really annoyed with, e.g. the network package, because it's not very clear which exceptions I should be catching
01:36:29 <aphorisme> I guess its even good to see if you're consumer of the code and author – time goes by and you might forget.
01:36:37 <merijn> aphorisme: If you *do* use exceptions I recommend reading Simon Marlow's "An Extensible Dynamically-Typed Hierarchy of Exceptions" paper
01:37:15 <aphorisme> Ah
01:37:42 <merijn> Because everyone seems to always forget that in GHC you can have a subclass-like hierarchy of exceptions
01:37:55 <cocreature> it’s a shame that this paper hasn’t resulted in a better exception hierarchy in base
01:38:00 <cocreature> IOException is the worse
01:38:04 <cocreature> *worst
01:38:18 <merijn> cocreature: Word
01:38:48 <merijn> I wonder if we could retrofit something better. As long as the improvement is a sub-hierarchy of IOException it should be backwards compatible...
01:39:54 <cocreature> merijn: afaik problems with backwards compat are the reason why it was not introduced but I don’t recall what exactly caused problems
01:43:47 <EvanR> merijn: ah hmm... if you use async the annoyance is cancelled out because you have to catch *all* exceptions when monitoring a thread
01:44:05 <EvanR> so it "doesnt matter" what a network worker died from
01:44:20 <merijn> EvanR: I generally don't use async for networking
01:44:56 <merijn> EvanR: because that's not very amenable to "per connection" state
01:45:28 <EvanR> a dumb loop ?
01:46:01 <merijn> I'm not sure what you mean by that?
01:46:22 <EvanR> worker state = do
01:46:24 <EvanR>   ...
01:46:27 <EvanR>   worker state'
01:47:41 <merijn> You need 2 threads per socket if you want to send and receive simultaneously. And if sending/receiving require some shared information you need state shared by both threads
01:48:21 <EvanR> send and recieve simultaneously seems incompatible with shared state
01:48:39 <merijn> Why?
01:49:04 <EvanR> because you cant modify state simultaneously
01:50:00 <EvanR> so im interpreting this as, send and recieve only one or the other at a time
01:50:34 <merijn> EvanR: I have messages coming in on a Chan that I need to dump to the socket as they arrive (and modify some state when I do), at the same time I need to dump messages from the socket into a Chan as they arrive and again modify the same state based on that
01:50:56 <EvanR> sounds like a great situation for async ?
01:51:00 <merijn> EvanR: You can't block on both a Chan *and* a socket, so you need one thread blocking on the Chan and one blocking on the socket keep state in sync
01:51:57 <Gurkenglas> http://lpaste.net/4572023601766596608 how do I handle this error as a user?
01:52:03 <saurabhnanda> help please with - https://stackoverflow.com/questions/44516946/how-to-conditionally-parse-json-based-on-settings-in-a-reader-environment
01:52:04 <EvanR> a small army of threads for a "connection" that needs to live or died together
01:52:44 <Gurkenglas> Oh wait, that error is thrown by the library itself. I suppose I'll have to specify the ghc version manually. How?
01:52:52 <cocreature> saurabhnanda: I’m not following. you say that you have trouble writing the ToJSON instance but you already have that instance in your gist
01:53:26 <Gurkenglas> Maybe something like "stack init --solver --glasgow-haskell 708"?
01:54:28 <merijn> Gurkenglas: Seems stupid that the author didn't constraint GHC version using base
01:55:16 <saurabhnanda> cocreature: https://gist.github.com/saurabhnanda/6b2eaa437be9a2fff14540e0dcbbc334 -- how to write the ToJSON instance for that one
01:55:32 <cocreature> oh ToJSON I read FromJSON
01:55:44 <saurabhnanda> more context - https://stackoverflow.com/questions/44516946/how-to-conditionally-parse-json-based-on-settings-in-a-reader-environment#comment76114804_44516946
01:56:58 <cocreature> I’m not sure you can write that instance unless you are fine with accepting some default value
01:57:11 <cocreature> you basically have a "Word8 -> Decimal" and are trying to get a Decimal
01:57:21 <cocreature> that’s not possible without getting a Word8 from somewhere
01:57:47 <cocreature> but I’m also not sure why you would want that instance
01:57:56 <cocreature> what is the Word8 supposed to do here?
01:58:23 <Gurkenglas> As per https://stackoverflow.com/questions/28292476/ghc-version-check-in-code , 708 means 7.8.x. How do I figure out which version of base to add as a constraint?
01:58:58 <cocreature> Gurkenglas: https://wiki.haskell.org/Base_package has a table with the corresponding versions
02:04:50 <EvanR> elixir has a datatype called "binary" which is conceptually a bytestring. but in the languages its a "subtype" of "bitstring" which is in conceptually a string of bits, not necessarily a multiple of 8. internally its just using a byte array and not using some of the last few bits
02:05:04 <EvanR> i was like, man too bad haskell doesnt have this
02:05:21 <EvanR> then i thought, who would use this and why
02:05:22 <Athas> Surely you can emulate it with type classes?
02:05:41 <merijn> EvanR: Word.
02:05:50 <merijn> Athas: Not the way you can do complex pattern matches on it
02:06:01 <merijn> EvanR: People who do low-level bitpacking/twiddling
02:06:05 <Athas> Oh, right, it's the Erlang thing.
02:06:16 <merijn> EvanR: Like, writing IP backends by hand
02:06:23 <Athas> Yeah, that's cool.  Maybe you can get partway there via view patterns.
02:06:28 <merijn> EvanR: Don't forget it was written for telecoms :)
02:06:35 <EvanR> i know it can come in handy hypothetically, if your haskell is running on an arduino
02:06:35 <merijn> Athas: I was just thinking the same thing
02:06:57 <merijn> EvanR: Well, suppose you wanna do your own IP/TCP stack in haskell on top of raw sockets
02:07:15 <Athas> Making Haskell run on an Arduino has a few serious hurdles you have to clear first.
02:07:21 <EvanR> right
02:08:06 <EvanR> and the dynamic code to mess with these is pretty snazy
02:08:44 <EvanR> haskell could drum up something with a library, though "bitstring" is taken by what looks like an abandoned codebase
02:11:37 <Gurkenglas> Why does the base version constraint not stop it from using the new ghc? http://lpaste.net/6924822625139032064
02:12:33 <tdammers> I think the idea of having generic packed arrays of binary values has a certain appeal to it
02:13:00 <merijn> Gurkenglas: Eh...what is the base constraint? It's not in the paste
02:13:11 <Gurkenglas> Oh wait, I think githubs web interface made a branch when I told it to edit that file. nvm
02:13:37 <Gurkenglas> (Turning "base            >  3 && < 5," into "base            >= 4.3 && < 4.8,")
02:13:49 <merijn> bah
02:13:56 <EvanR> tdammers: the only thing i havent determined is "why not". either why not, or "no reason why not"
02:15:07 <EvanR> .oO haskell to erlang compiler
02:17:54 <saurabhnanda> cocreature: the basic problem is given in the SO post. Ability to encode/decode JSON based on a reader environment. **One** of the suggested approaches is at https://gist.github.com/saurabhnanda/6b2eaa437be9a2fff14540e0dcbbc334
02:18:34 <saurabhnanda> I think EvanR pointed me to some other approach the other day. Using proxies
02:21:03 <saurabhnanda> can I do a search on IRC messages?
02:22:09 <Itkovian> There's a backlog somewhere of all IRC traffic
02:22:33 <merijn> Normally I'd point to ircbrowse, but it seems defunct nowadays
02:23:10 <Itkovian> ah dang
02:23:10 <EvanR> tunes.org logs in the topic
02:23:26 <Itkovian> http://tunes.org/~nef/logs/haskell/
02:23:34 <saurabhnanda> EvanR:  did you share a link with me the other day related to https://stackoverflow.com/questions/44516946/how-to-conditionally-parse-json-based-on-settings-in-a-reader-environment
02:23:45 <EvanR> nope
02:24:32 <cocreature> saurabhnanda: something like "newtype Money currency = Money Decimal" is probably going to work better than the Reader stuff
02:24:47 <saurabhnanda> merijn: glguy: tdammers: did you share a link with me the other day related to https://stackoverflow.com/questions/44516946/how-to-conditionally-parse-json-based-on-settings-in-a-reader-environment
02:25:15 <tdammers> saurabhnanda: not that I can remember
02:25:16 <Gurkenglas> It can't figure out the ghc version it just installed? http://lpaste.net/5683022166820388864
02:25:32 <merijn> No, because I don't do JSON :D
02:25:36 <cocreature> saurabhnanda: or if you’re too lazy to create a separate type for each currencies or can’t do that because the currencies are not fixed you can use the reflection trick I linked you to a few days ago
02:25:58 <saurabhnanda> cocreature: yes... you shared a link? it was using reify and proxy and other hackery.
02:26:36 <tdammers> reading that question, though, I believe that this just isn't something you can do at all
02:26:37 <cocreature> saurabhnanda: yes http://newartisans.com/2017/02/a-case-of-reflection/ but "newtype Money currency = Money decimal" will probably be easier
02:27:07 <tdammers> what I would do is create an intermediate format that doesn't require the precision parameter, and then write an explicit conversion function from the intermediate format to your final data structures and back
02:27:08 <Itkovian> Gurkenglas Using compiler: ghc-7.8.4 
02:27:18 <Itkovian> ah :)
02:27:20 <Itkovian> lower
02:27:37 <tdammers> alternatively, if you can pick precisions at compile time, make separate newtypes for each currency, and hard-code precisions into those
02:28:05 <cocreature> I’m not sure what that buys you over a single newtype with a phantom type parameter
02:28:09 <tdammers> you can even combine both approaches, such that you can parse either a compile-time currency, or a generic value without precision that requires explicit conversion later down the pipeline
02:28:17 <tdammers> cocreature: yeah, or that
02:28:21 <saurabhnanda> tdammers: I want to pick default precision from locale settings, that will come from the DB
02:28:42 <tdammers> saurabhnanda: those are effects; Aeson's API for parsing JSON is effectless
02:28:43 <saurabhnanda> tdammers: and each customer will have the ability to change that.
02:29:16 <tdammers> the only alternative I could think of is to patch Aeson to provide a monadic API, through which you could thread a Reader
02:29:27 <tdammers> but then things get a LOT more complicated
02:29:32 <saurabhnanda> what about using an IORef
02:29:43 <saurabhnanda> some thread-global variable?
02:29:46 <tdammers> you still need to thread the IO effect through the parsing code then
02:30:10 <tdammers> technically speaking, you could use unsafePerformIO, but this isn't a valid use case for that
02:30:10 <EvanR> o_O
02:30:12 <cocreature> saurabhnanda: have you tried the newtype approach? I think that’s exactly what you need here.
02:30:13 <saurabhnanda> wow, the type system is really making this hard!
02:30:23 <saurabhnanda> cocreature: reading it
02:30:28 <tdammers> no, the type system is telling you that what you want is not sound
02:30:38 <saurabhnanda> cocreature: my mind just switches off when I see Proxy.... have... to... force... myself
02:30:47 <cocreature> saurabhnanda: not the link I sent you, just "newtype Money currency = Money Decimal"
02:31:02 <tdammers> or maybe that what you want is a JSON parser that can handle effects
02:32:16 <EvanR> saurabhnanda: you dont need to use the type system here, if you dont want to. numbers in json are just Scientific
02:32:35 <EvanR> you can pass those around and pretend this is (decimal) javascript
02:32:36 <saurabhnanda> cocreature: how does `newtype Money **currency** = Money Decimal` help, did you mean `newtype Money precision = Money Decimal`
02:32:48 <cocreature> saurabhnanda: ah right.
02:32:51 <cocreature> names are hard :)
02:32:54 <tdammers> the currency determines the precision, I guess
02:32:54 <EvanR> application code somewhere else can decide on precision issues
02:33:07 <merijn> EvanR: That's true if he's storing money as JSON numbers, in which case "holy fuck, don't do that!?!?!"
02:33:08 <tdammers> instance HasPrecision USD where { precision = 2 }
02:33:40 <EvanR> everything said so far sounds overengineered
02:33:56 <EvanR> except perhaps newtype Money
02:34:45 <tdammers> EvanR: my initial proposition, namely to create an intermediate format and defer the rounding to a context where the "get desired precision from system locale" effect is facilitated, isn't really overengineered, is it
02:35:10 <EvanR> i havent seen any web framework go that far
02:35:16 <EvanR> so its gotta be
02:35:29 <fr33domlover> Hello! I have a type that is a newtype wrapper of RWST on top of IO, what is the recommended way to make a default trivial instance of MonadBaseControl IO T?
02:35:30 <tdammers> this isn't a task for a web framework
02:35:32 <EvanR> well.. open source ones
02:35:54 <tdammers> currency handling is too application specific to have a place in a general-purpose web framework
02:36:17 <EvanR> they do handle currency, all over the place. just not like that
02:36:19 * pikajude envisions a Hackage package with statically defined currency conversion tables
02:36:28 <EvanR> lol
02:36:29 <pikajude> updated via cronjob once every 5 minutes
02:36:30 <tdammers> then how?
02:36:32 <cocreature> Freundlich: GeneralizedNewtypeDeriving will let you just derive the instance by reusing the instance of RWST
02:36:55 <tdammers> I suppose you're talking not-Haskell web frameworks, in which case the answer is simple: their JSON parsers are effectful
02:36:58 <saurabhnanda> so, here's the core problem: JSON sends "1.24567", what precision should it be parsed into?
02:37:06 <Itkovian> speaking about JSON, is there a simple way to override the genericToEncoding for a single field of a record type? Like say, field1 :: Either A B so I would like to get "field1" .= case field1 o of Right r -> r  Left l -> l where A and B have their own encoding derivatoins, obviously. But I need not supply this for every single field since most of them have sensible defaults
02:37:11 <EvanR> they dont try to do this
02:37:24 <fr33domlover> cocreature, yeah but MonadBaseControl is a multi param typeclass, I get an error: the class has associated types
02:37:26 <EvanR> saurabhnanda: full
02:37:29 <pikajude> saurabhnanda: none, that's a string
02:37:41 <cocreature> fr33domlover: try deriving MonadBaseControl IO
02:37:43 <tdammers> saurabhnanda: if you want the environment to determine the precision, then you have to make it such that the environment can be accessed in the parsing context
02:37:51 <pikajude> use Scientific
02:37:55 <pikajude> solution solution'd
02:38:00 <fr33domlover> cocreature, that's what I did, and then it gives the error :P
02:38:16 <tdammers> saurabhnanda: since your parsing context is Value -> Either String Decimal (or something like that), there is no environment to get that information from
02:38:16 <cocreature> fr33domlover: hm I guess if GND doesn’t work you’ll have to manually define the instance
02:38:27 <EvanR> were going out of the way to drop information that shouldnt be there when its being parsed, in a carefully decided way backed by politics
02:38:33 <cocreature> fr33domlover: you can still reuse the RWST instance in your manual definition
02:38:35 <fr33domlover> cocreature, "Can't make a derived instance of  ‘MonadBaseControl IO (Session e s)’  (even with cunning newtype deriving): the class has associated types
02:38:41 <EvanR> instead of just formatting the number a different way later
02:39:02 <tdammers> if you could change the parser API to something like: UserContext -> Value -> Either String Decimal, or Value -> ReaderT UserContext (Either String Decimal), then you could pass the context
02:39:03 <piyush-kurur> saurabhnanda: If you want to understand generics as in GHC.Generics you need to understand the types M1 , :*: and :+: that is it
02:39:04 <EvanR> and or guaranteeing you dont put improper numbers in the database
02:39:14 <fr33domlover> cocreature, how about "deriving instance"? is that recommended?
02:39:35 <cocreature> fr33domlover: if it works sure but I would expect that this fails here as well
02:39:41 <piyush-kurur> The initial section of the Haddock Documentation is quite good there
02:39:45 <fr33domlover> cocreature, thanks I'll try :)
02:39:45 <tdammers> EvanR: "just formatting the number in a different way later" is exactly my initial proposition
02:39:45 <EvanR> parser just seems like the wrong place to do any of this
02:40:01 <tdammers> EvanR: defer the conversion to a context where we can trivially get the required information
02:40:10 <EvanR> oh sure, why didnt you say so :)
02:40:18 <tdammers> I thought I did
02:42:05 <EvanR> one day programmers will be paid inversely proportional to the complexity of the solutions they implement
02:43:10 <tdammers> there is another solution btw
02:43:16 <tdammers> allow the sender to pick the precision
02:43:39 <tdammers> "amount": { "value": 123.456, "precision": 2, "currency": "USD" }
02:43:42 <saurabhnanda> so, basically don't do parsing at all... let it remain Scientific.
02:43:59 <tdammers> well, it's not really parsing, is it
02:44:03 <tdammers> it's parsing + conversion
02:44:12 <tdammers> you're adding information that's not in the input
02:44:20 <EvanR> Scientific is not my choice for this data type... but should work
02:44:24 <tdammers> you might call it stateful parsing or sth
02:44:56 <merijn> tdammers: *bzzt*
02:45:12 <merijn> tdammers: You stored currency as a floating point. Please report for mandatory flogging.
02:45:18 <EvanR> scientific is designed for numbers like 6.02e23
02:45:19 <tdammers> no I didn't
02:45:24 <tdammers> that's JSON, not javascript
02:45:35 <saurabhnanda> Aeson has no other option for monetary types
02:45:47 <saurabhnanda> Aeson/JSON
02:45:51 <tdammers> though personally I would indeed use strings, actually
02:46:06 <tdammers> anyway, gotta go
02:46:07 <merijn> tdammers: JSON numbers are floating points
02:46:12 <pikajude> i thought aeson used Scientific?
02:46:17 <bartavelle> merijn: afaik they are arbitrary precision
02:46:28 <piyush-kurur> saurabhnanda: For currencies did you have a look at Data.Fixed
02:46:31 <tdammers> the JSON spec doesn't say how they are to be stored, or whether precision loss is acceptable or not
02:46:38 <piyush-kurur> I mean for the precision part.
02:46:41 <merijn> JSON hardly has a spec >.>
02:46:42 <tdammers> it just describes the syntax
02:46:42 <EvanR> theres no NaN or infinity
02:46:59 <EvanR> its just decimal scientific notation
02:47:39 <tdammers> it's still a bad idea to use numbers in JSON to represent decimals, simply because other (non-Aeson) toolchains might operate on it, and those might choose float to represent those numbers after all
02:47:39 <EvanR> im not sure i trust javascript with these ideas but 
02:48:03 <EvanR> i think stripe puts these digits in quotes
02:48:09 <saurabhnanda> piyush-kurur: no, but even that will have the same problem. During JSON parsing, where should one get the precision from?
02:48:25 <tdammers> iow., lack of rounding errors for "floats" in Aeson is an implementation detail, just like the fact that PHP's JSON parser maintains dictionary ordering
02:48:26 <pikajude> do you have an 8-ball handy?
02:48:37 <piyush-kurur> Currencies should always have only 2 decimal points is that not?
02:48:45 <pikajude> no
02:48:46 <saurabhnanda> EvanR: even if these numbers are in quotes
02:48:49 <pikajude> some have 0
02:48:58 <saurabhnanda> during parsing one still needs to pick the precision from somewhere
02:49:35 <EvanR> saurabhnanda: tdammers suggestion two ways, include the intended precision as part of the data, and earlier, you pull up supposed proper precision from a database so you can display it properly, like timezone
02:49:42 <piyush-kurur> pikajude: I mean the precision is not more than 2 decimal points. i.e. 2.25 Rs but one cannot have 2.3333 Rs
02:49:49 <pikajude> sorry, what is the question at hand exactly
02:49:52 <EvanR> i dont understand why you want to truncate numbers during parsing
02:49:54 <pikajude> are you parsing arbitrary floating point numbers
02:49:57 <pikajude> or are you parsing currency
02:50:43 <saurabhnanda> parsing monetary values that may have different precision depending upon user-specified settings.
02:50:57 <EvanR> user settings shouldnt decide what the data is
02:51:04 <EvanR> just how to show the data
02:51:10 <pikajude> what's the limit of precision
02:51:19 <piyush-kurur> saurabhnanda: why do you want to make life more complicated than it is necessary
02:51:19 <pikajude> if you're parsing monetary values
02:51:22 <piyush-kurur> ?
02:51:49 <saurabhnanda> EvanR: say, up to 6
02:51:59 <saurabhnanda> piyush-kurur: say, up to 6 decimal places
02:52:07 <pikajude> doesn't aeson already use Scientific
02:52:13 <EvanR> yes
02:52:16 <pikajude> are you trying to write a custom JSON parser
02:52:22 <EvanR> it can have any number of decimal places
02:52:23 <piyush-kurur> why 6. Which currencies uses more that 2 digits
02:52:24 <piyush-kurur> ?
02:52:39 <pikajude> piyush-kurur: convert 1 yen to USD?
02:52:45 <saurabhnanda> you DO need variable precision when parsing monetary data. The precision used to represent an invoice amount is different than what is used to represent an FX rate.
02:53:04 <EvanR> this parsing job sounds pretty bad, where did my microcents go to?
02:53:06 <saurabhnanda> not variable precision, but differing degrees of precision
02:53:07 <EvanR> "the parser"
02:53:09 <pikajude> ok
02:53:12 <pikajude> so
02:53:17 <pikajude> are you worried that aeson cannot handle precision?
02:53:26 <EvanR> office space, sapping fractions of a penny 
02:54:17 <saurabhnanda> pikajude: I want to parse monetary data to the exact precision required for the job. Job is defined by a reader environment.
02:54:17 <EvanR> LHC reports neutrinos going faster than light because the CSV parser decided to truncate whatever numbers it saw
02:54:19 <piyush-kurur> saurabhnanda: I remember some package for this cannot recall name
02:54:21 <jared-w> Also, fractions of a cent are incredibly important. Billions of dollars can be skimmed internationally every year if you round all transactions up to the nearest whole cent and pocket the change
02:54:43 <pikajude> saurabhnanda: scientific can handle arbitrary precision
02:54:50 <pikajude> i believe it stores precision separately
02:55:08 <EvanR> scientific is integer mantissa + exponent, base 10
02:55:22 <EvanR> i.e. scientific notation
02:55:28 <saurabhnanda> okay, I've lost track of the conversation here.
02:55:30 <pikajude> yeah
02:55:39 <piyush-kurur> EvanR: Was that the technical flaw ? I thought it was more serious stuff like measurement instrument error was incorrectly caliberated
02:55:39 <pikajude> okay, so not arbitrary (maybe)
02:55:54 <EvanR> piyush-kurur: i was joking... years ago the issue was a loose cable
02:55:55 <pikajude> is there a bigint version of double
02:55:56 <jared-w> exponent is type Int, if that matters. But if it does, that's the least of your issues
02:55:58 <pikajude> bigdub
02:56:10 <saurabhnanda> are we trying to come up with the so-called financially correct solution, just because the type-system/Aeson cannot handle this kind of parsing?
02:56:23 <pikajude> i'm not sure what you mean by "cannot handle"
02:56:38 <pikajude> i guarantee you can shove any number that's going to come up as part of a financial calculation into aeson and it will come up with a result
02:56:49 <saurabhnanda> pikajude: here is what I mean by "cannot handle" - https://stackoverflow.com/questions/44516946/how-to-conditionally-parse-json-based-on-settings-in-a-reader-environment
02:57:05 <piyush-kurur> EvanR: Although the Mariner bug is pretty dumb 
02:57:20 <piyush-kurur> not as bad as cvs parse but pretty close
02:57:23 <pikajude> saurabhnanda: but that's still using Scientific, lol
02:57:36 <pikajude> just parse it, then extract the numerical data you need once you can read the settings from the environment
02:57:41 <EvanR> saurabhnanda: no, generally this is just the wrong way to do it
02:58:02 <EvanR> so the need to hookup a database into the json parser was never implemented
02:58:11 <pikajude> no
02:58:12 <pikajude> ...
02:58:17 <pikajude> there's no need to hook up a database
02:58:26 <pikajude> why do you want to put database lookup in the *parse* stage
02:58:30 <pikajude> parse it, *then* transform it
02:58:36 <saurabhnanda> EvanR: what if my datatype has a smart constructor, which needs an argument that must come from the environment? I can't write a JSON parser for it?
02:58:44 <pikajude> why does this need to be part of the parser
02:58:53 <EvanR> you do it exactly as you would have done it in ruby
02:58:56 <EvanR> or js
02:58:57 <piyush-kurur> saurabhnanda: why not keep track of the currencies all the way during calculation and do one final conversion
02:59:05 <pikajude> i think we're asking the wrong question
02:59:06 <saurabhnanda> pikajude: you're basically asking me to keep a `Value` around and transform it later. Rendering Aeson pretty useless.
02:59:10 <pikajude> why does parsing have side effects
02:59:15 <pikajude> am i though
02:59:33 <piyush-kurur> Like for example you have (1 USD + 2 INR) and I give you (42 INR it becomes 1USD + 44 INR)
02:59:36 <EvanR> in fact you could just use Values
02:59:47 <EvanR> type system will totally let you
03:00:02 <pikajude> most 
03:00:05 <pikajude> whoops
03:00:07 <saurabhnanda> the idea about Value -> CustomDataType  is exactly that. That's what Aeson does. Else Aeson should just have emitted Maps & Lists and called it a day.
03:00:16 <pikajude> most of aeson's handy parsers operate on Value anyway
03:00:21 <pikajude> what's wrong with Value
03:00:48 <pikajude> straight up, if you use aeson to parse JSON, there will exist a point in your program's execution where the numerical values are all represented as Scientific
03:00:49 <EvanR> no it should really emit Value (or other types that can be marshalled as json)
03:00:57 <EvanR> but Value is the lossless raw form of the json
03:00:58 <pikajude> if you want to convert them from Scientific to something else, you can do that whenever you want
03:01:04 <pikajude> why do you need to do it during parsing
03:01:29 <pikajude> because your datatype has a Decimal field?
03:01:50 <saurabhnanda> that's exactly what I'm trying to do. Use Aeson machinery to convert Value -> MoneyWithPrecision & back. I don't want a monetary amount with incorrect precision entering my system, only to handle all this at the point of use. JSON parsing is the system boundary. This stuff should be handled at the system boundary.
03:02:09 <pikajude> why not parameterize your datatype on the numeric type you need?
03:02:12 <EvanR> json parson cant fix your bad data
03:02:16 <EvanR> parsing*
03:02:46 <saurabhnanda> EvanR: json parsing can't fix bad data, but it can prevent bad data from coming in.
03:03:07 <piyush-kurur> saurabhnanda: where is your data coming from? YOu have control on that ?
03:03:13 <ventonegro> saurabhnanda: Parse from JSON into an intermediate data type, and THEN convert it into your final data type according to the user's precision
03:03:21 <EvanR> usually youd want that to be an error, not a silent substitution of some value
03:03:53 <saurabhnanda> EvanR: I can't do that even. Because I need the precisinon from the environment to do that as wlel
03:03:55 <ventonegro> saurabhnanda: You are making it harder than it should be
03:04:21 <piyush-kurur> ventonegro: I think I agree with your 
03:04:40 <piyush-kurur> saurabhnanda: first think of your internal data types
03:04:50 <piyush-kurur> then think about external stuff
03:05:18 <piyush-kurur> If you are confused about how to represent the currency internally I do not see much point in taking about JSON parsing
03:05:23 <ventonegro> saurabhnanda: Make the only functions that accept the intermediate data type be the conversion function, and then you are done
03:05:24 <pikajude> any reason why my proposed solution doesn't work
03:05:40 <saurabhnanda> piyush-kurur: monetary amounts are represented as Decimal. What's the confusion there?
03:05:41 <EvanR> you can pass information into a json parser action and use it
03:05:56 <EvanR> but its still not the right place to do it, imo
03:05:58 <saurabhnanda> pikajude: what was that?
03:06:00 <piyush-kurur> saurabhnanda: different currencies ?
03:06:12 <piyush-kurur> I mean 1 Usd and 1 INR ?
03:06:16 <pikajude> saurabhnanda: MoneyWithPrecision ==> MoneyWithPrecision MyNumberType
03:06:27 <saurabhnanda> piyush-kurur: data Monetary = Monetary Currency Decimal
03:06:31 <pikajude> make all your functions receive a MoneyWithPrecision Decimal
03:06:39 <pikajude> but you can parse into a MoneyWithPrecision Scientific
03:06:46 <pikajude> then you can convert it by reading the config data from the environment
03:06:56 <piyush-kurur> saurabhnanda: there is a package for monetary stuff did you have a look at it
03:07:10 <piyush-kurur> I cannot recall the name
03:07:38 <piyush-kurur> I think this is it https://hackage.haskell.org/package/safe-money
03:07:56 <saurabhnanda> all this conversion just **sounds simple in theory**. How much more boilerplate is going to get introduced with this interm data type?
03:08:09 <pikajude> roughly one more identifier per callsite
03:08:13 <pikajude> unless you decide to define a type synonym
03:08:34 <saurabhnanda> I have a record with 20 fields out of which 3 are monetary values. How do I write the JSON instances for this record type?
03:08:50 <ventonegro> saurabhnanda: Well, compare it to your current solution... Oh wait :)
03:08:54 <pikajude> kind of like the way you do now, except you add the type argument in the instance head
03:09:05 <pikajude> instance FromJSON (MoneyWithCurrency Scientific) where
03:09:07 <pikajude> and so on
03:09:22 <saurabhnanda> Is there any code out there which has used this approach in a real life app?
03:09:32 <pikajude> uhh, do you mean FromJSON instances?
03:10:01 <piyush-kurur> saurabhnanda: did you really checkout safe money?
03:10:14 <saurabhnanda> pikajude: I'll need polymorphic records for this to work, won't I?
03:10:30 <pikajude> err, yes?
03:10:32 <pikajude> is that bad?
03:10:40 <saurabhnanda> data Rec currencyType = Rec {...}
03:10:44 <saurabhnanda> yes, that's the boilerplate.
03:10:45 <pikajude> ya
03:10:49 <EvanR> thats too much
03:11:01 <pikajude> data _MoneyWithCurrency currencyType = ...; type MoneyWithCurrency = _MoneyWithCurrency Decimal
03:11:04 <pikajude> solved
03:11:16 <EvanR> if you want to use the type system at all, just make a Money type or use a package
03:11:20 <EvanR> validate the money later
03:11:26 <EvanR> when you actually can
03:11:55 <EvanR> you do NOT have to do anything with types if you dont want to, and just pass around Decimal or Data.Fixed or Scientific
03:11:58 <saurabhnanda> piyush-kurur: how will safe-money impact this?
03:12:41 <piyush-kurur> saurabhnanda: it is supposed to take care of all the computations without errors
03:12:45 <saurabhnanda> EvanR: but I can't parse  Decimal from JSON where the precision is coming from the environment.
03:12:51 <EvanR> yes you can
03:12:53 <pikajude> this is correct
03:12:56 <saurabhnanda> piyush-kurur: again, how does that matter. Does it define JSON instances?
03:13:01 <piyush-kurur> saurabhnanda: and it seems to have json parsing as well
03:13:10 <pikajude> EvanR: no they can't
03:13:15 <pikajude> fromJSON only takes the input object
03:13:18 <saurabhnanda> piyush-kurur: does it handle dealing with FX rates that can go from 2-6 deceimal places depending upon user config?
03:13:19 <pikajude> no environment available
03:13:23 <pikajude> save evil IO hackery ofc
03:13:34 <EvanR> what is this Decimal thing that seems to not work?
03:13:51 <pikajude> EvanR: its precision is environment dependent
03:13:53 <saurabhnanda> this is a HUGE limitation. And the only way to solve it seems to be another bootload of type-related boilerplate.
03:13:58 <pikajude> that info isn't available to fromJSON
03:14:00 <EvanR> dont use that
03:14:04 <piyush-kurur> saurabhnanda: It claims to at-least (Don't blame we for the consequences)(well do not take that as a negative comment)
03:14:11 <piyush-kurur> s/we/me
03:14:35 <pikajude> EvanR: whatever the right type is, it isn't Scientific
03:14:38 <EvanR> you can parse a decimal fractional number type with aeson, or leave it as is
03:14:39 <pikajude> since it's money
03:15:02 <EvanR> if Decimal is doing screwy things in the name of sophistication, dont use it
03:15:07 <piyush-kurur> pikajude: there is nothing scientific about money ;-)
03:15:11 <pikajude> ok
03:15:23 <pikajude> EvanR: doesn't solve the problem
03:15:37 <pikajude> if the precision comes from the environment, it can't be used in fromJSON
03:15:47 <pikajude> problem is this is talking about *conversion* not *parsing*
03:15:56 <pikajude> aeson will always turn a numeric literal into a Scientific
03:16:00 <EvanR> i was prepared to be ignored again by saurabhnanda but not everybody
03:16:00 <saurabhnanda> I don't want to leave it as Scientific because it has an immediate impact on the core record data-types. They immediately need to become polymorphic. One version will have Scientific for monetary fields and the other will need to have Decimal. And I will need functions to convert between these record types. MOAR BOILERPLATE.
03:16:06 <pikajude> you can't (and shouldn't) change that
03:16:08 <EvanR> im dont
03:16:11 <EvanR> im done*
03:16:25 <pikajude> finally
03:16:33 <EvanR> saurabhnanda: ... no you dont need polymorphic records
03:16:34 <pikajude> saurabhnanda: you only really need a Scientific instance for FromJSON
03:16:38 <saurabhnanda> EvanR: why not?
03:16:40 <pikajude> after that you can use the normal type
03:16:50 <EvanR> go back and read my repeated suggestion
03:17:11 <utdemir> Hey, sorry for changing the subject. With type applications, we can now write a function with signature `new :: forall n. KnownNat n => Buf n` and call it like `new @5`, without all the Proxy cruft. However, now I want to write the function `get :: forall n m. (KnownNat n, KnownNat m, CmpNat n m ~ LT) => Buf m a -> Bool`, and call it with `get @5 (new @10)`. However, GHC does not let me write it because the signature after => does not
03:17:11 <utdemir> contain `n`. Is there a way to write it?
03:17:16 <pikajude> saurabhnanda, i'd recommend ignoring, i don't think he's grasped the issue
03:17:18 <saurabhnanda> how will you write JSON instances for data LineItem = LineItem {description :: Text, amount :: Decimal}
03:17:22 <piyush-kurur> saurabhnanda: seriously you are over engineering somewhere or the other
03:17:48 <pikajude> with a polymorphic DT you only need to use two different type args, and one of them only in one place
03:17:51 <ventonegro> EvanR: I don't think anybody can change his mind at this point anymore
03:17:54 <pikajude> if you use a type synonym it won't be that hard
03:18:08 <saurabhnanda> EvanR: this? if Decimal is doing screwy things in the name of sophistication, dont use it
03:18:14 <EvanR> no
03:19:10 <saurabhnanda> ventonegro: I don't have a clear solution about how to deal with the downstream boilerplate if I leave the type as Scientific. Do you?
03:19:34 <piyush-kurur> saurabhnanda: how can you say that polymorphism (that too the parametric kind) is a boiler plate?
03:19:38 <EvanR> i think youre ignoring half of what people say, i dont really blame you since its a lot of chaos in here
03:19:46 <pikajude> yeah, i am curious about what the boilerplate is going to be
03:19:54 <pikajude> i can't envision much of it
03:19:55 <EvanR> but i dont think its a good way to proceed
03:19:58 <boj> he's been complaining about haskell boilerplate for months now, not sure you are going to change his mind
03:20:01 <ventonegro> saurabhnanda: parse -> type with scientific -> convert -> your data type
03:20:22 <saurabhnanda> the core app logic doesn't want to deal with Scientific. It want to deal only with Decimal for accuracy. Any confusion here?
03:20:29 <ventonegro> I fail to see the issue, but then again, enough for me
03:20:45 <pikajude> saurabhnanda: maybe a little bit
03:20:50 <pikajude> why would you need to write the core app logic to deal with scientific
03:21:01 <pikajude> other than the conversion function, obviously
03:21:02 <saurabhnanda> boj: yes, that's kind of true. Haskell has a LOT of boilerplate. I'm not sure why other people don't call a spade a spade.
03:21:28 <saurabhnanda> okay. so core app logic = Decimal. That's decided.
03:21:28 <EvanR> im one of the people here who would rather there be less boilerplate
03:21:33 <piyush-kurur> saurabhnanda: Haskell the way you design has a lot of boilerplate
03:21:38 <piyush-kurur> that is true
03:21:39 <pikajude> saurabhnanda: sounds like a plan
03:21:42 <saurabhnanda> Now, parsing of Decimal not possible, due to Aeson limitation. Even that's decided.
03:21:46 <pikajude> yep
03:22:10 <saurabhnanda> Which basically means, you need shitloads of functions to convert RecA Scientific -> RecA Decimal and use that at every point JSON parsing is happening.
03:22:17 <saurabhnanda> which means every frikking Servant endpoint needs that.
03:22:25 <pikajude> hmm...
03:22:25 <saurabhnanda> is this not the definition of boilerplate?
03:22:31 <EvanR> why did you decide on Decimal ?
03:22:35 <pikajude> i highly doubt that's the definition of boilerplate
03:22:39 <pikajude> also
03:22:49 <pikajude> i'm curious why you would need to write the function RecA Scientific -> RecA Decimal "shitloads" of times
03:22:51 <pikajude> it seems like once would do
03:23:15 <saurabhnanda> I have 150+ record types
03:23:22 <saurabhnanda> almost all of them have at least one monetary value in them.
03:23:32 <pikajude> writing 150 record types wasn't boilerplate in the first place?
03:23:38 <maerwald> ?
03:23:38 <EvanR> the type parameter in all the records for money type is a bad idea
03:23:48 <pikajude> hang on
03:23:50 <pikajude> why are there 150 of them
03:24:10 <saurabhnanda> pikajude: yes it was. Refer to my comment to boj above. I've been struggling with Generics to get rid of all this boilerplate for the past week now.
03:24:13 <pikajude> i mean, even ignoring that, you could write one function that works on all of them if they all derive Data, lol
03:24:26 <saurabhnanda> pikajude: 150 database tables.
03:24:36 <pikajude> oh
03:24:40 <pikajude> huh
03:25:01 <saurabhnanda> pikajude: multiply that by 2. Because if you're dealing with JSON then you have a NewLiteItem record for the create request, and LineItem record for e'thing else.
03:25:18 <pikajude> you have a REST API with a create endpoint for each of 150 database tables?
03:25:41 <saurabhnanda> EvanR: so, if type parameter is a bad idea, is the proxy/reflection idea the only possible solution left?
03:26:17 <saurabhnanda> it's so frustrating. In the app, at the time this JSON parsing is happening, the system knows EVERYTHING it needs to know about the locale. Yet, it cannot use it during parsing the request.
03:26:27 <piyush-kurur> saurabhnanda: The point is choose one reprensentation for monetary value inside your app
03:26:36 <pikajude> correct, you cannot make parsing side-effectful in haskell
03:27:11 <osa1> utdemir: either add a proxy for n or use -XAllowAmbiguousTypes and add type applications in call sites
03:27:12 <piyush-kurur> Then at the parsing part convert it into your internal representation and build
03:27:17 <piyush-kurur> what exactly is the problem
03:27:45 <saurabhnanda> piyush-kurur: how? please think about creating a data model in Haskell, where the **user specifies the precision**
03:28:05 <piyush-kurur> saurabhnanda: why does user specify the precision?
03:28:06 <pikajude> so this is Servant you said
03:28:16 <pikajude> hm
03:28:29 <pikajude> interesting
03:28:50 <EvanR> please dont be frustrated that the 3 things you put together to something something simple in a complicated way dont work
03:29:00 <EvanR> to do something simple*
03:29:12 <utdemir> osa1: Hey! Did not want to add a Proxy since it looks weird on call site (`get @5 Proxy blah`). Trying AllowAmbiguousTypes now, thank you :).
03:29:39 <piyush-kurur> saurabhnanda: you want to give your user the facility of saying: okey folks whenever I say 1 Rs I mean 42 Rs
03:29:53 <osa1> utdemir: http://lpaste.net/356256
03:30:23 <EvanR> newtype Money = Money Scientific
03:30:29 <EvanR> validate later
03:30:33 <saurabhnanda> EvanR: I'm not sure what's so complicated about what I'm doing. I can see an application of this for so many things. If you want your core app logic to deal with correct data, then you'd like to put a lot of checking in your validations. Else you aren't making bad data non-representible.
03:30:55 <EvanR> validation is good, its not the same as parsing json
03:31:12 <saurabhnanda> piyush-kurur: what does prevision have to do with 1Rs = 42Rs
03:31:27 <piyush-kurur> what exactly is precision then ?
03:31:32 <piyush-kurur> How many decimals
03:31:33 <piyush-kurur> ?
03:31:34 <utdemir> osa1: Yep, even if it sounds like the worst thing ever, AllowAmbiguousTypes works, thank you :).
03:31:35 <saurabhnanda> EvanR: later = when?
03:31:47 <EvanR> immediately
03:31:56 <saurabhnanda> piyush-kurur: digits after decimal place.
03:32:16 <EvanR> you cant hope to also make sure a request is referring to an existing person or object in the database from inside the parser
03:32:17 <piyush-kurur> saurabhnanda: why not fix it at 2 and change the currency
03:32:24 <saurabhnanda> EvanR: what do you mean when you say validate? Scientific -> Decimal conversion?
03:32:41 <EvanR> what is so great about Decimal ?
03:32:49 <saurabhnanda> piyush-kurur: ?!
03:33:05 * EvanR suggests Money newtype
03:33:17 <pikajude> i feel like there is about a 20% ratio of helpful suggestions in here at the moment
03:33:18 <piyush-kurur> saurabhnanda: I will hold back as there seems to be 2 parallel threads
03:33:39 <saurabhnanda> The "Decimal" type is mainly intended for doing financial arithmetic where the number of decimal places may not be known at compile time (e.g. for a program that handles both Yen and Dollars) and the application must not drop pennies on the floor. For instance if you have to divide $10 between three people then one of them has to get $3.34.
03:33:48 <EvanR> you could also fix it at 6 if you really wanted decimal
03:33:57 * piyush-kurur lets EvanR be the torture in charge  
03:34:14 * EvanR puts on leather mask
03:34:15 <pikajude> how do you ensure that one of them gets 3.34?
03:34:17 <pikajude> out of curiosity
03:34:24 <pikajude> do you just check for leftover pennies and add them to one person randomly?
03:35:20 <EvanR> alright
03:36:13 <EvanR> the Decimal type does have some nice Nothings when a conversion would fail, because its decimal
03:36:17 <EvanR> and because it has limited precision
03:36:32 <EvanR> but it doesnt even have a parser ?
03:37:19 <EvanR> and it has a divide operation, but no string parser
03:38:21 <saurabhnanda> EvanR: think of it this way. If after every parsing operation, I have to call another function to be able to really use the result of parsing, would that make sense? Does it fit the basic principle of DRY?
03:38:40 <saurabhnanda> EvanR: wouldn't it make sense to fuse the two functions together? 
03:38:51 <EvanR> if its validation, yes. but i see that you really want to have different currency types instead
03:39:08 * pikajude thinks
03:39:18 <pikajude> wouldn't you need to call the other function to do the conversion in your FromJSON instance anyway?
03:39:20 <EvanR> so, can you make your input data contain the appropriate stuff
03:39:22 <pikajude> what's the difference?
03:40:01 <saurabhnanda> pikajude: if it's inside FromJSON, I write it once. If it's not, I write it 150 times.
03:40:14 <saurabhnanda> EvanR: actually the currency type is the same.
03:40:16 <EvanR> someone submits a USD number, someone submits a Yen number
03:40:19 <pikajude> saurabhnanda: you use the same FromJSON instance for 150 different datatypes?
03:40:22 <EvanR> right
03:40:35 <EvanR> theres only 1 currency type?
03:40:46 <saurabhnanda> EvanR: the prevision is not at the type-level. It's at the value level.
03:40:54 <EvanR> yes i see that
03:41:14 <EvanR> but im not understanding that your API doesnt know the difference between currencies
03:41:29 <saurabhnanda> EvanR: forget that its' currency for a moment. Just assume it's an incoming number that can have a different precision for each request. But the precision needs to be represented accurately.
03:41:32 <EvanR> it only knows whether to put .00 or not when showing the money?
03:41:43 <EvanR> yes that makes sense
03:41:55 <EvanR> so you include the precision with the number because normally thats not there
03:41:57 <pikajude> how do you use the same FromJSON instance for 150 datatypes but you would have to write a separate conversion function for each of them?
03:42:00 <EvanR> 3.000000 is the same as 3
03:42:37 <EvanR> {value=3, precision=10} now you can convert it to the decimal value 3.0000000000
03:42:47 <saurabhnanda> pikajude: because the FromJON instance will be of the core type itself..... Data.Decimal
03:42:52 <pikajude> oh
03:43:14 <EvanR> well then, you can expect an object like that^
03:43:15 <saurabhnanda> EvanR: right, that would require the API client to co-operate.
03:43:34 <EvanR> well, youre the one wanting the precision be explicit
03:43:39 <saurabhnanda> EvanR: and the API client can be incorrect
03:43:50 <EvanR> how would you know if they are or arent
03:44:19 <saurabhnanda> EvanR: because I know the precision to be expected from that number. Based on the API tokens/auth being used.
03:44:40 <EvanR> the precision is a function of API token....
03:44:52 <piyush-kurur> saurabhnanda: sorry to interrupt that is a very very bad design
03:45:10 <EvanR> lots of APIs are like this, unfortunately
03:45:23 <EvanR> but its simpler if its stateless
03:45:35 <EvanR> you ask for a number-with-precision, they give you one
03:45:41 <EvanR> you ask for a UTC time, they give you one
03:45:48 <saurabhnanda> EvanR: yes, but then that's also dangerous. I'm expecting the API client to uphold a core business rule.
03:45:50 <EvanR> rather than local time
03:46:05 <piyush-kurur> saurabhnanda: do you have control over that api or are you using some third party API
03:46:06 <piyush-kurur> ?
03:46:35 <saurabhnanda> piyush-kurur: I prefer designing APIs assuming as little about the client as possible. 
03:46:53 <pikajude> but you're already using servant, which enforces a schema
03:46:53 <saurabhnanda> piyush-kurur: the API client is going to be an SPA. And it could be written by an intern next, for all I know.
03:47:04 <EvanR> in any case, you can ask for a number with precision, then during validation (that exists regardless right) you can see if they gave you precision inconsistent with their account
03:47:17 <EvanR> pain in the ass but thats what youre saying
03:47:28 <saurabhnanda> EvanR: yes, that's a possible implementation. Because validation functions already exist.
03:47:39 <EvanR> good
03:47:45 <saurabhnanda> EvanR: is this better implemented inside dig-fun?
03:48:26 <EvanR> dig-fun ?
03:48:42 <piyush-kurur> saurabhnanda: such very looks schema is a disaster. You should enforce strict scheman
03:48:50 <piyush-kurur> *schema
03:49:19 <piyush-kurur> unless of course it is some gooffy thing like some third party gateway
03:49:28 <piyush-kurur> If it is your api you should be the boss
03:50:03 <piyush-kurur> Just be sure to document it carefully
03:50:26 <saurabhnanda> the awesomely named valdation library called digestive functors.
03:50:41 <EvanR> are you using that for validation
03:50:45 <saurabhnanda> EvanR: yes
03:51:20 <EvanR> got anything positive to say about it :)
03:51:55 <EvanR> the only library i hear praised for reducing boilerplate is lens
03:52:31 <saurabhnanda> EvanR: BS boilerplate. Validations in Haskell are the absolute worst thing to deal with right now. The worst-in-class.
03:54:31 <saurabhnanda> but this still doesn't solve the problem... because it means that I can't write basic quickcheck tests to check my json instances?
03:54:37 <piyush-kurur> saurabhnanda: I will repeat once more. You are over engineering stuff. You want a goofy client app to send you carzy JSON and then expect to write complicated validation rules that involved the database, the auth token and the users pet dog and expect it to be magically easy in Haskel
03:54:43 <kqr> @hoogle mx -> (x -> m y) -> mx
03:54:43 <lambdabot> Boltzmann.Data.Types withProxy :: (a -> b) -> proxy a -> b
03:54:43 <lambdabot> Data.Proxied proxied :: (a -> b) -> proxy a -> b
03:54:43 <lambdabot> Control.Lens.Getter contramap :: (a -> b) -> f b -> f a
03:54:50 <saurabhnanda> or, unless I change the schema to have [number, precision] for every monetary type.
03:54:53 <EvanR> yes you can because you now have a simple FromJSON instance for Decimal
03:55:04 <kqr> @hoogle m a -> (a -> m y) -> m a
03:55:05 <lambdabot> Diagrams.Prelude (<*>) :: f (a -> b) -> f a -> f b
03:55:05 <lambdabot> DsMonad (<*>) :: f (a -> b) -> f a -> f b
03:55:05 <lambdabot> MonadUtils (<*>) :: f (a -> b) -> f a -> f b
03:55:10 <kqr> sorry were pretty unclear thre
03:55:17 <kqr> not quite though
03:55:23 <saurabhnanda> piyush-kurur: DB based validations are a fact of writing real-life applications. Please calm down.
03:56:14 <merijn> saurabhnanda: Honestly, the only thing I ever see you do here is complain how hard things are in Haskell. If it's so awful, why aren't you doing it in some other language?
03:56:18 <EvanR> yes theres several stages of validation, unforunately eventually it will need to check against a database for something or other
03:56:28 <piyush-kurur> saurabhnanda: each of the things you want to do are simple (except the pet dog) but put together it is a very complicated logic 
03:56:29 <saurabhnanda> merijn: because that's the only way to make it better.
03:56:39 <piyush-kurur> that is my whole point do not overengineer it
03:56:57 <merijn> If you wanna make things better, then help implement solutions, rather than telling others to implement them for you
03:57:07 <boj> amen
03:57:34 <EvanR> at least try to cooperate when getting help
03:58:18 <saurabhnanda> merijn: that's exactly what I'm doing. But there are places where I get stuck and don't have a solution. The only way to come up with real-life, this-shit-is-known-to-work solution is by building a real-world app. That is what is being done.
03:58:44 <tdammers> saurabhnanda: the matter is rather simple, actually. You have a JSON document containing a numeric value, and an environment that knows what precision to use, and you want to combine these two such that you can go from JSON -> Money while honoring the desired precision from the environment.
03:59:01 <saurabhnanda> tdammers: yes, precisely.
03:59:02 <tdammers> saurabhnanda: Aeson is not prepared to handle environments though, so you cannot do it there.
03:59:02 <piyush-kurur> One last time. (1) First fix the data types (do not worry about db and user and client api)
03:59:27 <tdammers> saurabhnanda: one solution is to modify Aeson so that it is capable of threading environments through the parser
03:59:28 <EvanR> and you cant do tests against the parser with the environment
03:59:31 <saurabhnanda> tdammers: is there any proposal to make Aeson.Parsers a Monad transformer?
03:59:42 <EvanR> oh god... 
03:59:43 <tdammers> saurabhnanda: not that I am aware of
03:59:53 <tdammers> saurabhnanda: and personally, I wouldn't go down that route
03:59:56 <piyush-kurur> saurabhnanda: sorry what?
04:00:02 <tdammers> saurabhnanda: I think the next option is better
04:00:37 <tdammers> saurabhnanda: keep the JSON parsing strictly to parsing, that is, instead of building the final data structure right away, just parse into something that accurately represents the data that is actually in the input document
04:00:53 <pikajude> which is what someone else in here suggested a good 30 minutes ago
04:01:17 <EvanR> at least were not making backward progress
04:01:19 <tdammers> saurabhnanda: and then add a processing step that massages the direct representation into the final form, in a context that *does* have access to the environment (Reader, or IO with an IORef, or whatever)
04:01:42 <saurabhnanda> tdammers: and what's the easiest way to write that processing step so that it fits well with the rest of the stuff, eg. Servant?
04:02:10 <piyush-kurur> saurabhnanda: why are you mixing thing?
04:02:12 <tdammers> saurabhnanda: IntermediateDataStructure -> IO FinalDataStructure
04:02:40 <EvanR> FinalDataStructure is after or before validation?
04:02:44 <tdammers> after
04:02:53 <saurabhnanda> tdammers: this is the exact point where the explosion of boilerplate is feared.
04:03:05 <tdammers> saurabhnanda: try it, it's not going to be so bad
04:03:06 <piyush-kurur> saurabhnanda: how so?
04:03:25 <piyush-kurur> parsing is just parsing as a Value, If I remember correctly
04:03:33 <EvanR> tdammers: they have something like 150 IntermediateDataStrcutre / FinalDataStructure pairs
04:03:35 <boj> saurabhnanda: you should spend some time trying to implement it and see if you can come up with something better
04:03:48 <piyush-kurur> Value -> Data structure is your validation
04:04:26 <saurabhnanda> tdammers: are you suggesting parsing it do a SimilarlyShapedRecordButWithScientificFields{..} or Value?
04:05:16 <tdammers> saurabhnanda: depends; if it's otherwise shaped the same entirely, and the money thing is the only thing that differs, you could parametrize it on that type and just derive a functor instance
04:05:28 <EvanR> sigh
04:05:33 <tdammers> then you can use TheDataStructure Scientific for the intermediate format, and TheDataStructure Money for the final one
04:05:35 <tdammers> but
04:05:48 <tdammers> chances are there will be other differences you want to iron out
04:05:57 <tdammers> also, wtf, 150 different data structures
04:06:05 <pikajude> oh yeah, i forgot about deriving Functor
04:06:07 <piyush-kurur> EvanR tdammers  I see an infinite loop somehre here
04:06:07 <pikajude> that would be way easier
04:06:09 <pikajude> lol
04:06:11 <EvanR> TheDataStructure71 Money
04:06:17 <EvanR> TheDataStructure72 Money
04:06:23 <EvanR> this seems like a waste of a functor instance
04:06:32 <tdammers> if there's that many data structures, TH stuff into smithereens
04:06:32 <EvanR> TheDataStructure72 Money Fruit
04:06:43 <saurabhnanda> hang on... let me make a gist with this approach... let't see where it leads
04:06:47 <pikajude> where do you think money fruit grows, anyway
04:06:52 <EvanR> next problem that crops up
04:07:16 <tdammers> or rethink your design, because it sounds like you should offload your data model and transformations to something more declarative
04:07:19 <EvanR> tdammers: generics would be good
04:07:48 <tdammers> EvanR: that could work too, I'm just more familiar with TH, and I like that I can build DSLs for my declarations freely
04:08:34 <EvanR> ive heard the 150 record types-for-some-reason story many times in here... i know one thing... there will be no reason i will do that on a project
04:09:24 <piyush-kurur> May be missed some Normal Forms in DB definitions
04:09:56 <EvanR> if anything the record types are defined in the database schema and should be generated
04:10:14 <saurabhnanda> EvanR: that is already being done, btw.
04:10:25 <EvanR> including all support crap such as what were inventing here
04:10:26 <tdammers> most likely, those 150 types are subject to change all the fucking time, and compiling them in is going to give the maintenance team a really shitty time
04:10:49 <saurabhnanda> EvanR: and we already have FOUR record types for each tbale -- RecPGRead, RecPGWrite, RecAppRead, RecAppWrite -- thanks to Opaleye.
04:10:51 <EvanR> which is why i wasnt going for that in my mind really. something more dynamic
04:10:53 <tdammers> just, you know, define a data structure that can model them all, add some run-time schema validation code and a useful transformation DSL
04:11:10 * EvanR puts opaleye on a suspected shtlist
04:11:17 <tdammers> amd then write record types for the parts of the domain logic that actually matter
04:11:44 <tdammers> because I bet your problem domain doesn't actually have 150 completely different types of entities
04:12:06 <EvanR> probably half of those are "entities"
04:12:11 <EvanR> so only 75
04:12:18 <saurabhnanda> tdammers: few top-level entities and a lot of sub-entities.
04:12:52 <saurabhnanda> try modelling an invoice in a DB schema. You'll end-up with 10, I suppose.
04:12:56 <piyush-kurur> saurabhnanda: all your RecPG* types are opaleye stuff is it not?
04:12:58 <EvanR> also, dont listen to tdammers, hes been in clojure land for some time now
04:13:07 <saurabhnanda> piyush-kurur: yes.
04:13:07 <tdammers> EvanR: you take that backc!
04:13:28 <EvanR> he may spontaneously suggest dynamic solutions
04:13:42 <EvanR> lol
04:13:58 <piyush-kurur> saurabhnanda: so those you have nothing to do with is that correct ?
04:14:10 <tdammers> EvanR: I believe I already did. I did not however suggest throwing your hands in the air and yelling "I give up, I'll just call everything a nested hashmap!"
04:14:18 <piyush-kurur> (I mean you did not generate them. Some TH Generic code did it)
04:14:38 <EvanR> no
04:14:48 <saurabhnanda> piyush-kurur: I have a lot to do with that. Spent quite some time writing TH to generate that nonsense.
04:14:50 <cocreature> tdammers: nested hashmaps are way too complicated. String is all you need
04:15:26 <EvanR> its kind of funny to consider the database scheme as a thing that is highly dynamic and subject to change, given that its the only thing in a traditional stack with a well defined, checkable signature
04:15:28 <piyush-kurur> saurabhnanda: Okey but what I mean is that it has nothing to do with your business logic
04:15:45 <saurabhnanda> piyush-kurur: no, not really.
04:16:05 <piyush-kurur> So what are the types of your business logic?
04:16:09 <EvanR> and the part of the hackage project that youd really want to be dynamically typed
04:16:20 <EvanR> haskell*
04:17:39 <piyush-kurur> saurabhnanda: you should only be designing your genuine types (i.e. the once that control your business)
04:17:45 <tdammers> cocreature: that's the clojure vs. php debate
04:18:04 <EvanR> string-as-datastructure is tcl
04:18:28 <saurabhnanda> so, essentially what is A POSSIBLE solution is -- to not have JSON instances for Decimal at all, but have them for a wrapper type, which are rendered unusable by the core app logic, due to type hackery. Then have a IsValidated instance for the wrapper type which requires the Scientific value (from Aesom) and the required precision -- to be able to construct the Decimal. And this piece of code, can probably be handled by digestive fun
04:18:29 <saurabhnanda> ctors which anyways are the monadic parsing solution in Haskell land (need to check if dig-fun can access a reader environment or not)
04:18:32 <piyush-kurur> now do you have 150 types in your business logic 
04:18:34 <piyush-kurur> ?
04:18:50 <saurabhnanda> piyush-kurur: I'm slowly getting there...
04:19:05 <saurabhnanda> piyush-kurur: have spent quite some time writing record types mapping to every single DB table.
04:19:28 <haski> hi all, i'm looking for someone whos able to tell me how to implement a read instance..
04:19:28 <EvanR> ;_;
04:19:51 <tdammers> EvanR: the issue with databases is that their type checking is 1) dynamic, and 2) cannot usually be compiled into a monolithic unit with the application code
04:19:51 <cocreature> haski: you’ll need to be a bit more specific
04:20:00 <piyush-kurur> haski: if it is simple then why not derive it
04:20:01 <piyush-kurur> ?
04:20:08 <tdammers> EvanR: IOW, as far as application code is concerned, the database schema *is* dynami
04:20:13 <EvanR> right
04:20:33 <EvanR> still funny... its like... the types failed
04:20:51 <tdammers> I take a different stance on that
04:20:53 <EvanR> otoh you could do all your work in the database... as stored procedures!
04:21:03 <tdammers> typed code on the inside, dynamic interfaces on the outside
04:21:06 <haski> Its my task to write a code which is able to transform an input like "3x^2 + x^4" to "Add(Monom(3,2), Monom(1,4))
04:21:07 <saurabhnanda> aargh.... that would mean JSON roundtripping quickchecks aren't possible.... the only solution is to change the JSON parsing to [number, precision], which forces a lot of burden on the client. 
04:21:18 <tdammers> database is internally typed, to ensure internal consistency
04:21:27 <tdammers> application code is internally typed, to ensure internal consistency
04:21:30 <EvanR> and it doesnt help haskell
04:21:45 <tdammers> but the interface between the two is dynamic, by necessity, so you will have to deal with that
04:21:58 <piyush-kurur> haski: consider writing a parser instead of Read (read types are pretty slow)
04:22:13 <tdammers> and it's at least partially a good thing, because it means we can, with some effort, be graceful on both ends, in order to decouple more safely
04:22:20 <EvanR> i question the necessity but thats probably a long other story
04:22:42 <haski> piyush-kurur: i have to write a read instance with readsPrec
04:22:47 <tdammers> it's a very practical necessity, its core being that database and application code are usually deployed separately
04:22:57 <piyush-kurur> haski: you can
04:23:21 <EvanR> but yes its dynamic and yes when im saurabhnanda, i will try something like that because screw writing 150 record types that (currently) look like my database
04:23:28 <piyush-kurur> haski: but you might want to write a parser instead as your input looks complicated
04:23:29 <tdammers> you can compile the database into the application, but then you shift the compatibility issue to the interface between the database and its storage
04:24:06 <EvanR> cloud haskell programs are deployed separately...
04:24:16 <saurabhnanda> EvanR: ?
04:24:35 <piyush-kurur> tdammers: I do not buy your argument. Once you fix the schema the internal type (haskell) should be fixed
04:24:38 <EvanR> when im in your position, that is
04:24:50 <piyush-kurur> and the derivation should be automatic (TH/Generic etc)
04:24:55 <haski> piyush-kurur i got only one simple example of a read instance und now i have to solve this task.. and its very complicated and confusing.. Thats why i need help.. maybe someone has already solved a task like this or is able to tell me how to deal with Read, lex readsPrec, and so on
04:24:56 <tdammers> piyush-kurur: database schemas evolve. don't kid yourself.
04:25:27 <piyush-kurur> tdammers: then the corresponding Haskell type should also evolve
04:25:34 <piyush-kurur> with migration scripts 
04:25:49 <tdammers> piyush-kurur: and yes, you can derive things from database schemas, except you don't want to force yourself into a situation where application and database always have to migrate in concert
04:25:50 <saurabhnanda> haski: you sure you need a read instance and not a proper parser, like attoparsec?
04:26:09 <haski> saurabhnanda yes, i am
04:26:12 <tdammers> piyush-kurur: you want a situation where there is at least one version leap of compatibility overlap
04:26:28 <saurabhnanda> tdammers: hang on... we have done exactly that. In fact there are three other projects which are solving the same problem. i.e. of generating opaleye record types based on DB schema. What's wrong with that?
04:26:48 <EvanR> heh version leap... thinking about standard web practice of deploying as soon as a pull request is accepted
04:27:00 <EvanR> as soon as CI gives a green light
04:27:07 <EvanR> breakage or not
04:27:31 <haski> saurabhnanda i attend a haskell-class, but our "teacher" could be way better .. He doesn't really explain how it works but we have to solve really complicated tasks ..
04:27:35 <tdammers> EvanR: by "version leap", I mean "the version in production now vs. the version we're deploying"; not necessarily n.0.0 vs. n+1.0.0
04:28:02 <saurabhnanda> haski: welcome to haskell-land. Where "teacher" is "real life problems and deadlines"
04:28:08 <piyush-kurur> haski: no one is going to help you with you homework
04:28:35 <tdammers> saurabhnanda: yes, that is an option; the problem is just that this doesn't guarantee any forward- or backward-compatibility, and there is no way to guarantee that the database schema does indeed match, so you're not winning all that much in term of type safety - run time crashes can still happen from trivial mistakes
04:28:39 <piyush-kurur> at least not I being one of the "teacher" who could be better ;-)
04:29:09 <haski> piyush-kurur it's not a homework.. i could skip this and wait for the proper solution on tuesday.. but i want to get a good explaination and understand how it works ..
04:29:32 <haski> piyush-kurur and that's what won't happen ..
04:29:53 <saurabhnanda> tdammers: the haskell records are being created FROM the db schema. Why won't they match?
04:30:01 <piyush-kurur> haski: start with simpler example first 
04:30:05 <EvanR> in fact people here may help you with your homework, or any other questions you have
04:30:27 <piyush-kurur> EvanR: help yes, solution no
04:30:30 <tdammers> saurabhnanda: because they are being generated at compile time, against a database running on the build server at compile time, which is in no way guaranteed to match the production server
04:30:47 <aphorisme> Is there a simple (OS independent) way of telling the program to wait for, say, 1 minute?
04:30:59 <cocreature> aphorisme: threadDelay
04:31:14 <aphorisme> oh, thanks.  : )
04:31:17 <EvanR> you dont download the schema from a random production server? :)
04:31:21 <Axman6> to be precise, that will wait for at least the time specified
04:31:57 <piyush-kurur> tdammers: it will be dangerous to do that but who does that.
04:32:06 <piyush-kurur> there should be migration scripts 
04:32:53 <piyush-kurur> Even in rails you need to do the upward, downward migration
04:32:55 <tdammers> piyush-kurur: sure, but when do they run? can you guarantee that all queries will always hit a database running the exact schema they were generated for?
04:33:11 <tdammers> you migrate your db, but the app is running
04:33:13 <saurabhnanda> tdammers: yes, already faced that issue. What's a practical solution to that problem?
04:33:33 <tdammers> saurabhnanda: write compatible SQL and compatible app code
04:33:42 <tdammers> saurabhnanda: and handle runtime failures properly
04:33:54 <piyush-kurur> tdammers: how?
04:34:00 <saurabhnanda> tdammers: compatible sql and compatible app code? say waht?
04:34:00 <EvanR> "dont mess up"
04:34:41 <tdammers> split your breaking changes into a series of mutually compatible changes
04:34:55 <piyush-kurur> tdammers: unless you are mentioning Ur/Web I donot see a way to do that cleanly
04:35:07 <piyush-kurur> the boundary is a serious problem
04:35:25 <EvanR> i like to migrate the database first when possible, and add new features that the application wont know or care about yet
04:35:37 <EvanR> then deploy the new version of the app, not necessarily immediately
04:35:42 <saurabhnanda> in compiler parlance, what's context sensitive parsing called? where some token can mean different things depending upon what has been parsed before it, or some external setting, or the phase of the moon, or whatever?
04:36:06 <tdammers> e.g., adding a column: 1. add column as NULL to schema; app code ignores; 2. add column as optional to app code; 3. change db schema from nullable to default, populating NULL columns with the default value; 4. change app code to make the field non-optional
04:36:49 <EvanR> seems like a lot of steps
04:36:57 <saurabhnanda> tdammers: (3) is dangeraous. we just faced it in production. Locks the damn table and updates every single row. For some reason explicitly UPDATEing all rows worked. But not altering default value.
04:37:17 <tdammers> saurabhnanda: yes, it could involve a full table lock
04:37:30 <EvanR> go straight to the default... the queries are using explicit columns right
04:37:39 <EvanR> app wont know new col is there
04:37:39 <tdammers> saurabhnanda: as an alternative, you can also change your app code in step 2 to always populate the field on write
04:37:55 <saurabhnanda> btw, this app<>DB syncing problem is not haskell specific.
04:37:56 <tdammers> EvanR: yeah, straight to default also works
04:38:07 <tdammers> no, definitely not - it's the same everywhere
04:38:23 <tdammers> haskellers are just a bit less likely to hand-waive correctness concerns
04:38:32 <saurabhnanda> if your app load is generally low, do whatever... no one will notice.
04:38:49 <EvanR> a broken app is broken regardless of how many people are on it
04:38:57 <saurabhnanda> if your app load is high, then either a few percentage of people will get errors (when the DB has been migrated, but new app is not live) OR you will have to take a few minutes of downtime
04:39:12 <tdammers> sure, but if you only have one user, you can give them a phonecall and ask them to not use the thing while you're updating it
04:39:51 <tdammers> oh, also, if it's high-load, you are probably running a load-balanced setup, in which case you'll want to migrate app servers one by one
04:39:53 <EvanR> updating the db shouldnt cause downtime...
04:39:54 <cocreature> better just shut it down while you’re updating :)
04:40:08 <tdammers> take one down, direct traffic to the others, upgrade, hook back up
04:40:13 <tdammers> no public-facing downtime
04:40:23 <EvanR> :thumbsup:
04:40:24 <tdammers> but you will have mixed versions running in production for some amount of time
04:40:36 <saurabhnanda> tdammers: if hot-patched like that, even then some percentage of requests will error out, due to db<>app mismatch, right?
04:41:04 <tdammers> saurabhnanda: that is exactly why you want to keep things somewhat forward- and backwards-compatible on both ends
04:41:05 <EvanR> the actual app server and webservers should be reloadable without interruption
04:41:20 <saurabhnanda> tdammers: easier said that done, no?
04:41:34 <EvanR> requests in progress end, requests becoming pending for the 1 second it takes to reload, right :)
04:41:35 <tdammers> saurabhnanda: harder than going gung-ho, but totally doable
04:41:41 <EvanR> no errors
04:41:57 <saurabhnanda> actually that's also a possible solution
04:42:05 <saurabhnanda> tell the load balancer to hang on for a couple of seconds
04:42:16 <EvanR> unicode makes it pretty easy
04:42:18 <EvanR> unicorn*
04:42:22 <saurabhnanda> take down the app servers, migrate DB, bring the app servers up again, and serve the pending requests
04:42:32 <cocreature> EvanR: emojis solve everything
04:42:42 <saurabhnanda> :)
04:42:47 <EvanR> saurabhnanda: thats the stop the world way....
04:43:00 <saurabhnanda> what else did you have in mind?
04:43:02 <EvanR> weve been discussing upgrading stuff incrementally until you go ahead and reload the app
04:43:17 <EvanR> which im saying... ideally doesnt cause interruption because "magic"
04:43:42 <cocreature> magic is almost as good as emojis
04:57:35 <saurabhnanda> cocreature: isn't this link the exact solution I need? http://newartisans.com/2017/02/a-case-of-reflection/ Apparently someone else faced the same problem with the Arbitrary intances that I'm facing right now with ToJSON/FromJSON instances
04:58:14 <saurabhnanda> the problem of threading arguments to the instance that the instance otherwise doesn't allow. And it's done via types.
04:58:41 <cocreature> saurabhnanda: that’s why I linked it but as you’ve realized yourself it is slightly complicated which is why I explained the simpler solution of using "newtype Money precision = Money Decimal"
05:00:00 <saurabhnanda> cocreature: let me try using that technique
05:03:57 <saurabhnanda> cocreature: got it to compile
05:06:35 <aib> My project (which is a series of independent .hs files with mains) requires some hackage libraries. is there a way to list them such that someone cloning the project can install them all with a single command?
05:07:39 <EvanR> you need to make a .cabal file for your project
05:07:51 <EvanR> search for "cabalize my project"
05:08:46 <aib> I was glancing through https://www.haskell.org/cabal/users-guide/developing-packages.html but couldn't find much related to dependencies
05:08:48 <aib> let me try that
05:09:06 <cocreature> there is a "build-depends" field in your cabal file
05:13:04 <aib> Hmm, okay
05:14:02 <saurabhnanda> cocreature: from your linked example, would you know how to pass `Foo s` to TH? i.e. earlier where ''Foo was being passed, can I now pass ''(Foo s)
05:15:19 <saurabhnanda> what are the different ways of creating a Language.Hsakell.TH.Syntax.Name? Especially for datatypes that are parameterised?
05:15:24 <cocreature> saurabhnanda: what is that supposed to mean? s is a polymorphic type variable.
05:16:06 <cocreature> saurabhnanda: the parameter is unrelated to the name
05:16:10 <cocreature> the name is still Foo
05:16:33 <saurabhnanda> cocreature: referring to http://newartisans.com/2017/02/a-case-of-reflection/
05:16:38 <cocreature> I’m too
05:16:48 <saurabhnanda> so earlier I had a simple type called `Foo`
05:16:56 <saurabhnanda> now with this technique it has a phantom -- `Foo s`
05:17:03 <cocreature> but the type is still called "Foo"
05:17:06 <cocreature> it just has a parameter
05:17:07 <saurabhnanda> I was earlier passing ''Foo to TH.
05:17:09 <saurabhnanda> what do I pass now?
05:17:10 <cocreature> but that’s not part of the name
05:17:58 <saurabhnanda>      • Expecting one more argument to ‘Money_’       Expected a type, but ‘Money_’ has kind ‘* -> *’     • In the first argument of ‘Maybe’, namely ‘Money_’
05:18:29 <saurabhnanda> the underlying TH needs to be evolved to take care of this?
05:18:31 <cocreature> just showing an error message is not really helpful. make some minimal example that demonstrates what you are trying to do and the problem you’re encountering
05:18:38 <cocreature> probably
05:18:40 <saurabhnanda> without the phantom, it's not a proper type, no?
05:19:21 <saurabhnanda> is there any way to get where in the TH code something is failing?
05:20:07 <cocreature> not that I know of but -ddump-splices will show you the Haskell code generated via TH which might be helpful
05:28:41 <saurabhnanda> is there any sensible way to write a JSON roundtripping tests where the record contains one field which is not roundtrippable, eg. a field that holds HTML that is automatically sanitised upon construction?
05:30:50 <ongy> saurabhnanda: if it's not sanitzied to a canonical form (which in itself sounds weird) you could write Eq instances that don't use that field
05:31:57 <saurabhnanda> ongy: yes, that's one solution. is the gEq be easily configured to do this? Or do I need to write the entire instance by hand?
05:31:59 <cocreature> or just don’t use the Eq instance and write some other function that checks for whatever kind of equivalence you’re interested in
05:32:33 <saurabhnanda> cocreature: same question -- is there a generic function that can easily be configured to check equality of all fields in a record EXCEPT one?
05:32:59 <cocreature> not that I know off
05:33:06 <ongy> saurabhnanda: not without some trickery. But if you can pass in a custom compare function (I kinda sumed the test infrastructure uses Eq) that's probably nicer
05:33:38 <saurabhnanda> I really need to spend some time understanding how to write generic code.
05:33:52 <ongy> you could do some trickery if you don't need an Eq instance on the type of the sanitized field and have it be (==) = True, but that's neither pretty, nor possible in all cases
05:34:17 <cocreature> making the Eq instance compare the sanitized values might be an option
05:34:55 <saurabhnanda> hang on... one way to do is to make the newtype wrapper for SanitizedHtml have an Eq instance which always returns True
05:35:09 <saurabhnanda> ...which is probably a can of worms
05:35:24 <cocreature> that only works if you don’t care about the Eq instance anywhere else
05:35:28 <ongy> cocreature: I imagine the html just being an example. From what I got about saurabhnanda's project something like a valid DB-key and a "get an DB key" thingy may also be a thing
05:35:53 <saurabhnanda> ongy: in this case SanitizedHtml is a real thing
05:36:20 <ongy> The only thing? I was thinking about solutions that don't care about what it is you don't want to compare
05:36:21 <saurabhnanda> data SanitizedHtml = SanitizedHtml { getSanitizedHtml :: Text } deriving (Eq, Show, Generic) 
05:36:28 <saurabhnanda> mkSanitizedHtml raw = SanitizedHtml { getSanitizedHtml = sanitizeBalance raw } 
05:36:58 <saurabhnanda> okay, I fixed it by changing the arbitrary instance
05:37:34 <ongy> if it's really sanitizeHtml I would be thinking about why it changes to be honest. Since that implies that sanitize '(sanitize x) != sanitize x' which I don't think I would want (but you may)
05:37:55 <ongy> I got that one quote on the wrong position, but I hope it's clear what I'm trying to say
05:39:22 <saurabhnanda> ongy: essentially here's what I was doing earlier ==> x => sanitize x => unwrap the constructor and compare with original x
05:39:29 <saurabhnanda> which will never be equal
05:39:43 <saurabhnanda> now, I'm just comparing (sanitize x) with (sanitize x) essentially.
05:40:00 <saurabhnanda> because the arbitrary instance itself calls mkSanitizedHtml on the random data
05:40:45 <ongy> saurabhnanda: then I probably misunderstood your problem. I thought it was something like: \x -> mkType x == (fromJson . toJson . mkType x)
05:41:29 <saurabhnanda> ongy: let it be.... this problem is sorted. anyways I'm not really bothered about this field in the overall record :)
05:42:42 <ongy> and about the previews question: if you want to do something for all fields in a Record except one, you probably have to do some TH. And last I tried that I didn't have much fun with it :(
05:42:57 <ongy> *previous
05:43:37 <ongy> oh or Generic, I think I resorted to TH because I wanted to have the field names
05:45:25 <cocreature> generic gives you field names
05:45:51 <ongy> oh it does? I haven't used them before and probably suck at research then
05:46:33 <cocreature> https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html#t:Meta
05:46:52 <saurabhnanda> ongy: if you figure out a way to grok generics, please write a Generic for Absolute Idiotic Dummies please. 
05:46:58 <cocreature> and then there is an instance of Selector for MetaSel
05:47:13 <saurabhnanda> how I wish metaprogramming in Haskell were as easy as lisp.
05:47:15 <saurabhnanda> anyways...
05:47:51 <saurabhnanda> is there a recommended way to write round-tripping tests for the DB using Quickcheck?
05:48:13 <saurabhnanda> I'm done with all the round-tripping tests for JSON. Now, what about the DB?
05:48:38 <saurabhnanda> tdammers: any recommendations here? ==> is there a recommended way to write round-tripping tests for the DB using Quickcheck?
05:49:00 <cocreature> just … write it?
05:49:06 <cocreature> I’m not sure what you’re looking for
05:51:59 <ongy> cocreature: oh taht is nice
05:52:17 <cocreature> ongy: generics-sop also has something for it.
05:52:28 <cocreature> I refuse to remember how generics without generics-sop work :)
05:52:46 <ongy> hehe
06:16:20 <Axman6> bgamari: ping
06:21:20 <mbrock> somehow, suddenly, the "Preprocessing library" stage of Cabal commands in my project are very slow...
06:36:01 <kqr> @pl \x -> f (g y x)
06:36:01 <lambdabot> f . g y
06:42:13 <kqr> @pl \x -> f (g (a b) x)
06:42:14 <lambdabot> f . g (a b)
06:42:16 <kqr> huh
06:42:25 <kqr> huh
06:43:45 <kqr> do not get it to work
06:46:22 <dasfd1235> .
06:47:35 <erisco> kqr, what did you expect? f, g, a, and b are free variables
06:47:42 <kqr> haha well the thing is
06:47:46 <kqr> i have the expression
06:48:16 <kqr> transform vec g = runST (evalStatT (stuff vec) g)
06:48:20 <kqr> definition*
06:48:25 <kqr> and I am trying to change it to
06:48:36 <kqr> transform vec = runST . evalStateT (stuff vec)
06:48:40 <kqr> but that gets me a type error
06:48:42 <kqr> while the first one works
06:48:47 <kqr> (the StatT was a typo)
06:48:48 <Axman6> runST can cause issues when doing this
06:48:49 <erisco> pastebin the error
06:49:09 <erisco> or lpaste it... there I go misappropriating trademarks
06:49:38 <Axman6> (GHC has a special case for runST $ <some ST expression> because the types for runST and ($) don't actually align)
06:50:17 <kqr> aah
06:50:22 <kqr> thanks
06:50:52 <erisco> where is $ involved?
06:51:02 <cocreature> it’s not, that’s why it doesn’t work :)
06:51:45 <Axman6> it's not, but enough people ran into the problem of not being able to write runST $ do ... that it was special cased
06:51:48 <kqr> uh i can confirm that it also doesn't work with  transform vec = runST . evalStateT $ stuff vec
06:51:48 <erisco> will a type var not instantiate to a universally quantified type?
06:52:03 <cocreature> kqr: try runST $ evalStateT …
06:52:22 <cocreature> erisco: yep, that would be impredicative polymorphism which is not supported by GHC
06:52:23 <erisco> runST :: (forall s. ST s a) -> a   so we can start there
06:52:25 <Axman6> that won't make it any more point free though, which I assume is the intention
06:52:34 <erisco> cocreature, ah right, okay
06:52:42 <cocreature> we do have an extension that claims to enable it but it’s broken :)
06:52:50 <erisco> I don't recall the issue with it but I remember the symptom
06:53:43 <erisco> so you can't use  runST for an a -> b, and that is why it doesn't work with .
07:11:08 <BernhardPosselt> hi, i was wondering how you can generalize monad transformers
07:11:19 <merijn> BernhardPosselt: What do you mean by that?
07:11:32 <BernhardPosselt> e.g. how can you combine a maybe with a list
07:11:45 <BernhardPosselt> or a maybe with a stream
07:11:51 <BernhardPosselt> or a maybe with a result
07:11:55 <BernhardPosselt> using only one generic interface
07:12:46 <lyxia> MaybeT combines maybe with whatever
07:13:02 <BernhardPosselt> is maybe the outer type?
07:13:11 <BernhardPosselt> e.g. Maybe (List a)
07:14:08 <BernhardPosselt> so if you would want to map on all elements inside the list you want to write a generic fmap that does that?
07:14:38 <BernhardPosselt> > fmap (+1) (Just [1, 3])
07:14:39 <lambdabot>  error:
07:14:40 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M780167411500...
07:14:40 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
07:15:50 <BernhardPosselt> > fmap (++ "hi") (Just ["a", "b"])
07:15:52 <lambdabot>  error:
07:15:52 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
07:15:52 <lambdabot>        Expected type: Maybe [Char]
07:16:28 <BernhardPosselt> i suppose in order to use MaybeT i need to use lift somewhere, right?
07:16:44 <jared-w> You have a Just list, so you need to unbox list out of the Just
07:17:23 <jared-w> Something like: case result of Nothing -> handle. Just -> fmap ...
07:17:27 <merijn> jared-w: For the record, unbox is already a technical term that means something else than what you're using it as, so you might wanna avoid that :)
07:17:31 <BernhardPosselt> right, but doesnt MaybeT handle that for me?
07:17:34 <Axman6> > fmap (+1) (Compose (Just [1,2]))
07:17:36 <lambdabot>  error:
07:17:36 <lambdabot>      • Data constructor not in scope: Compose :: Maybe [Integer] -> f b
07:17:36 <lambdabot>      • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
07:17:47 <Axman6> bleh
07:18:41 <jared-w> whoops, you're right. What term should I use instead?
07:19:23 <merijn> jared-w: I would just use pattern match
07:19:38 <jared-w> fair enough. No need to over complicate things I guess :p
07:20:01 <lyxia> BernhardPosselt: MaybeT m a  is  m (Maybe a)
07:20:24 <merijn> jared-w: boxed vs unboxed is the terminology used for value types vs reference types. (Think int vs Integer, if you know Java. int is unboxed, Integer is boxed)
07:23:56 <BernhardPosselt> lyxia: so basically everything that holds a maybe a
07:24:04 <BernhardPosselt> then you can decide how to apply the function to it right?
07:24:24 <BernhardPosselt> and you just need to rewrap it in the enclosing type again (using return?)
07:25:40 <erisco> BernhardPosselt, m is usually a Monad, so not usually anything
07:26:34 <BernhardPosselt> ofc
07:26:45 <BernhardPosselt> but thats the gist right?
07:27:33 <erisco> lift :: (MonadTrans t, Monad m) => m a -> t m a    return :: Monad m => a -> m a
07:27:47 <erisco> MaybeT :: m (Maybe a) -> MaybeT m a
07:28:40 <erisco> so when do we use these... the short answer is you use them when the type works
07:29:33 <erisco> lets say we are working with MaybeT IO, and we have some x :: IO String, then to get a MaybeT IO String we use lift x
07:30:19 <erisco> in other words, if we have some Monadic value which is not MaybeT then we can lift it to one
07:30:33 <BernhardPosselt> ok, so package it up in a transformer basically
07:30:45 <erisco> good for adapting existing functions to whatever transformer you're using
07:30:57 <BernhardPosselt> what if you have two monads?
07:31:01 <BernhardPosselt> ehm three*
07:31:22 <BernhardPosselt> so Maybe(List (Maybe a))
07:32:42 <erisco> MaybeT (ListT Maybe) a :: Maybe [Maybe a] -> MaybeT (ListT Maybe) a
07:33:00 <erisco> er, that is a type error
07:33:10 <BernhardPosselt> ah, so you wrap them
07:33:20 <erisco> you'd use the type  MaybeT (ListT Maybe) a
07:33:24 <BernhardPosselt> so there is a generic MonatTrans for MonadTrans?
07:33:44 <BernhardPosselt> ah right
07:33:49 <BernhardPosselt> MaybeT is a monad itself
07:34:02 <erisco> or if you want then  MaybeT Identity is equiv to Maybe
07:34:11 <cmotoche> Hello everyone. May you know why `stack repl` always recompiles all the dependencies? Is there a way to avoid that and simple compile my own code?
07:34:40 <erisco> it is a MonadTrans, Monad m => MaybeT m is a Monad
07:34:41 <shapr> What are the recommended Haskell libraries for hashing? I need one for non-crypto (bloom filters, count-min, etc) and one for crypto.
07:34:49 <cmotoche> I'm using stack-1.4.0
07:35:13 <Axman6> cmotoche: are are you calling stack repl (and how are you calling stack build/install)?
07:35:43 <Axman6> if your build flags are different between the two, the libraries will need to be recompiled
07:37:16 <erisco> ListT . MaybeT :: m (Maybe [a]) -> ListT (MaybeT m) a   this is what I was thinking of
07:38:05 <erisco> other way around... MaybeT . ListT :: m [Maybe a] -> MaybeT (ListT m) a
07:38:13 <erisco> then m can specialise to MaybeT Identity or just Maybe
07:38:42 <Axman6> shapr: well, the Hashable stuff is pretty widely used. for crypto things, cryptonite is quite popular, or the crypto-hash libraries. 
07:39:02 <cmotoche> Well, because I wanted to use the repl for running some test I did this first: `stack build --test --only-dependencies :my-test` and then I did `stack repl --test :my-test` in both cases it compiles the dependencies
07:39:12 <antiman> I was looking for libraries to read csvs and I found csv-conduit, but at the top of the file it had this "{-# LANGUAGE OverloadedStrings #-}"
07:39:13 <erisco> so, we use the constructor to adapt a definition not using transformers to one that does
07:39:15 <antiman> what does that mean
07:39:27 <glguy> shapr: hvr had these http://hackage.haskell.org/package/cryptohash-sha1
07:39:41 <erisco> this can arise when we use definitions involving the underlying monad
07:40:02 <erisco> so we do some stuff on IO String and end up with IO (Maybe String) and now we want to get back into MaybeT IO String
07:40:46 <Axman6> antiman: it's a Haskell language extension which allows you write things which are just Strings using the syntax "foo", allowing you to write Text and ByteString values without the need to call pack or the ByteString equivalent function
07:40:56 <shapr> Axman6, glguy: thanks!
07:41:02 <Axman6> > "I am not a String" :: Text
07:41:04 <lambdabot>  error:
07:41:04 <lambdabot>      Not in scope: type constructor or class ‘Text’
07:41:11 <Axman6> :(
07:41:17 <erisco> then finally, we use return in the normal way when using Monads
07:42:24 <erisco> so, lift is for adapting IO stuff that doesn't end up with IO (Maybe a), and MaybeT is for adapting IO stuff that does
07:42:31 <erisco> wlog
07:43:09 <antiman> oh nice
07:44:28 <Axman6> uh, that should have said "things which aren't just Strings"
07:44:52 <antiman> is conduit-csv a good library to use for csv files? I have come across three that seem reasonable
07:45:57 <Axman6> I usually use cassava directly, assuming your CSVs are enormous
07:46:19 <Axman6> (IIRC csv-conduit is built on cassava but I may be wrong)
07:46:27 <cocreature> antiman: do you know conduit and are you already using it in your application?
07:46:33 <cocreature> if you are it’s definitely the right choice.
07:46:39 <sm> three reasonable csv files ? hey, congrats
07:46:48 <cocreature> learning conduit just for it or even if you know it, integrating in your app might not be worth it
07:47:10 <antiman> I just finished the Learn You a Haskell for Great Good so I really have no idea
07:47:34 <Axman6> sm: that is indeed a very rare thing to find!
07:47:55 <cocreature> antiman: in that case I would probably go with cassava
07:48:17 <antiman> ok sounds like a plan
07:48:36 <antiman> the other one I saw was pipes-csv which was built on cassava
07:49:37 <erisco> when someone espouses their new csv data dump as a technical marvel I despair
07:53:11 <aphorisme> calling a `stack build --install-ghc` fails with "@(Network\HTTP\Download.hs:78:5)
07:53:12 <aphorisme> Downloading lts-8.18 build plan ...HostCannotConnect "raw.githubusercontent.com" [connect: failed (Connection timed out (WSAETIMEDOUT))]"
07:53:20 <aphorisme> has anyone an idea what can be the problem here?
07:53:59 <aphorisme> ping or using the browser to navigate to `raw.githubusercontent.com` works.
08:06:37 <_sras_> I am using resource-pool package to database connection pooling in my web app. How can I use a connection in a thread in such a way that the connection is not broken when parent thread returns it to pool?
08:07:15 <Axman6> I'm not sure what you mean
08:09:41 <c_wraith> _sras_: don't use actions that break the connection
08:10:10 <Axman6> you should be taking the connection from the pool inside the thread afaict
08:10:21 <jmnoz1> anything special needed for static compilation and binary distribution of haskell programs? what should I read that is current?
08:10:37 <c_wraith> jmnoz1: how static?  like, no links to libc?
08:10:52 <c_wraith> dynamic loading of libc, that is
08:11:00 <jmnoz1> as portable as possible I guess
08:11:04 <jmnoz1> but not absurdly so
08:11:30 <jmnoz1> I just want people to be able to download my binary and run my program on their ubuntu or whatever
08:11:31 <Axman6> from memory it's not the easiest thing in the world
08:11:34 <c_wraith> Well, you can get docker containers built on alpine linux where ghc will produce binaries with no dynamic links at all
08:11:43 <c_wraith> But if you're willing to lean on system libc it's a lot easier
08:12:26 <jmnoz1> currently my tiny api client takes >15 min to build I just want to distribute a tiny binary
08:12:38 <c_wraith> Have you tried just distributing the binary?
08:12:51 <c_wraith> ghc doesn't link to haskell code dynamically by default, iirc
08:12:55 <mbw> I have a question about managing multiple effects. Consider an mtl-style function "fun :: (MonadIO m, MonadReader MyConfig m, MonadState MyState m) => [Int] -> m Int". Now, you could also do this by defining a free or operational monad. Generally speaking, what would the representation of a function using several effects look like then? Would you use the Compose functor or something?
08:12:59 <c_wraith> so the only dynamic links will be to system libraries
08:13:01 <jmnoz1> maybe that's good enough! doh :) no I haven't
08:13:18 <jmnoz1> I can try that, thank you
08:15:34 <_sras_> Axman6: When I use forkIO, I pass a connection to the child thread. The operation in child takes some time, and after it, when trying to wrtie to the db, the connection is gone.
08:15:47 <jmnoz1> woah my thing is 51MB
08:16:09 <jmnoz1> how can I shrink my binary
08:16:18 <_sras_> c_wraith: What do you mean by "actions that break the connection" . I am only doing an insert and update operations from within the thread.
08:16:46 <Axman6> mbw: if you were using the freer(-effects) librar(ies), you would write: fun :: Members '[IO,Reader MyConfig, State Mystate] effs => [Int] -> Eff effs Int
08:17:09 <c_wraith> _sras_: then nothing should be breaking the connection, so what's the problem?
08:17:10 <zomg> jmnoz1: if you use dynamic linking iirc that will also reduce the size compared to static linking
08:17:22 <Axman6> _sras_: why aren't you taking the connection from the pool directly in that thread? 
08:17:24 <c_wraith> zomg: that's.. exactly the opposite of the goal. :P
08:17:37 <zomg> err, yeah you're right :P
08:17:59 <zomg> mixed the two
08:18:20 <c_wraith> jmnoz1: I've only seen file sizes that big if I'm linking in a library like ghc.
08:18:22 <_sras_> c_wraith: Won't the connection get disconnected when the parent returns it to the pool, and pool manager decides to disconnect it?
08:18:35 <c_wraith> _sras_: why would it?
08:18:51 <_sras_> c_wraith: I don't know. That seem to be what is happening.
08:18:52 <jmnoz1> yeah libgcc is linked in
08:18:56 <Axman6> how are you getting the connection _sras_?
08:18:59 <c_wraith> _sras_: the whole point of a pool is to not constantly connect and disconnect
08:19:14 <jmnoz1> so how do I not link that in ?
08:19:25 <Axman6> c_wraith: it is, if you use it how it is expecting to be used
08:19:25 <jmnoz1> I guess I should study the stack manual
08:20:20 <Axman6> if a connection is taken from the pool, passed to a forked thread, and then returned to the pool by the parent, then after some timout the connection pool library will destroy the resource
08:20:48 <jmnoz1> with -O2 my executable is 288M
08:22:09 <_sras_> Axman6: Yes. I am trying to do that now...
08:22:10 <Axman6> _sras_: I would like to help you but you're ignoring my questions :\
08:22:22 <Axman6> oops, spoke too soon
08:22:57 <_sras_> Axman6: No issues. I came here to see if there is a facility to do this withing the pooling manager itself.
08:23:03 <c_wraith> jmnoz1: it is expected that -O2 will make binaries bigger.  That seems like a lot bigger, though.  In the end, this is going to come down to what libraries you're compiling in.
08:23:13 <jmnoz1> actually -O2 seems to fail to build now
08:23:14 <mbw> Axman6: Generally speaking, does it make sense to use free/freer/operational if you don't need access to the AST? I find this whole topic hard to grok to be honest, since there are so many competing approaches available.
08:23:21 <Axman6> _sras_: how are you getting the connection from the Pool
08:24:17 <c_wraith> jmnoz1: though you can improve binary size (at the cost of link time) by enabling split-objs, which lets you use libraries more granularly.  I've never used it, though, so I don't know how much work it is to get going.
08:24:19 <_sras_> Axman6: Using the withResourceFunction
08:24:31 <_sras_> Axman6: Using the withResource Function
08:24:40 <jmnoz1> c_wraith: thanks
08:24:45 <Axman6> mbw: I'm not sure. there are definitely advantages to the effect model beyond having access to the AST (or, I guess that come about by having that access). you have much better control over exactly how each effect is evaluated
08:25:07 <_sras_> Axman6: It gets passed into a reader env, from where it gets accessed throughtout the app
08:25:10 <Axman6> _sras_: and you're forking a new thread inside the (a -> m b) function?
08:25:26 <_sras_> Axman6: Yes
08:25:33 <Axman6> right, that's your problem
08:26:14 <jmnoz1> i looked at https://www.fpcomplete.com/blog/2016/10/static-compilation-with-stack before but thought maybe there was something more current and with a caching strategy
08:27:23 <Axman6> as soon as that action returns, the resource will be returned, and the timer will start counting down until that resource can be destroyed. once that timeout is done, the resource will be destroyed, which in the case of a database connection mean closing that connection.
08:28:51 <Axman6> your options are to either use withResource in the forked thread, or explicitly use takeResource, pass the connection and the LocalPool to the thread, which will need to call putResource when it's done to return the connection to the pool
08:29:13 <fragamus> I'm in GHCI and I wrote a big CPU expensive expression which produces a list of tuples and bound it to a variable using "let".  I thought it would just store the results but each time I enter the variable name it seems to take time to print the tuples. What gives?
08:30:03 <dolio> fragamus: What's the type?
08:30:17 <fragamus> (Ord b, Floating b, Enum b) => [(b, b)]
08:30:23 <dolio> Well there you go.
08:30:29 <fragamus> there I go
08:30:33 <dolio> That's a function.
08:30:43 <fragamus> wtf
08:30:53 <dolio> You give it three dictionaries and it produces a list of tuples.
08:30:58 <lyxia> You've been bitten by the absence of monomorphism restriction!
08:31:34 <fragamus> OK I shall read up on that
08:31:48 <fragamus> thanks lyxia, dolio
08:31:57 <Axman6> if you give it a concrete type, it should only be computed once
08:33:10 <mbw> Axman6: I am definitely missing some literature here. From what I have seen, the ability to "switch interpreters" apparently can be done using monad transformer stacks as well, e.g. by replacing a base IO monad with Identity, though I haven't delved that deeply into this topic, again for the lack of literature. Learning monad transformers is one thing, but concerning the transition transformers -> mtl -> 
08:33:16 <mbw> free etc., the amount of available learning material seems to diminish in that order.
08:33:27 <Axman6> but because that list could be [(Float, Float)] or [(Double, Double)], or any other type which meets those constraints, it needs to recompute the result each time (and that has to happen by passing the class dictionaries in for each instantiation)
08:35:36 <Axman6> mbw: the advantage is that you can do things like use writer for logging as the app's being interpreted, instead of collecting all the values at the end. you can have a database monad which is interpreted without the need for a database at all, all this without having to change your application code at all
08:38:42 <dolio> Ed needs to actually write THC. I feel like that's the key to making free monads + interpreters actually good.
08:38:56 <dolio> Although maybe it would make the other approaches better, too.
08:39:37 <shapr> The Haskell Core ?
08:39:39 <shapr> What's THC?
08:40:27 <dolio> THC is "Turbo Haskell Compiler" or maybe "Tracing".
08:40:38 <shapr> Turbo Haskell, YEAH
08:41:01 <dolio> In any case, it's based around using a tracing JIT for most optimizations.
08:41:22 <shapr> oh, like his x86 -> x86 JIT compiler?
08:41:42 <mbw> I can see how using Writer as logger is a problem due to space leaks, but you can just use State. But if I have something like a MonadDB constraint, wouldn't defining a mock instance of this typeclass amount to the same thing?
08:41:57 <dolio> I was talking with someone, and apparently there's a way that you can write an interpreter on the JVM, where basically you interpret your program into a certain composition of runtime system primitives....
08:42:23 <dolio> And then the JVM JIT inlines a bunch of stuff, and dynamically generates the compiled version of your program automatically, because you wrote the interpreter in this certain way.
08:43:15 <dolio> So, that's the kind of thing you want when using free monads. You don't really want to be generating trees and inspecting them at runtime, you want it to all get compilied as much as possible, dynamically.
08:43:17 <shapr> I know the HotSpot JVM implemented poly-inline caching that David Unger put into Self, is that still the same JIT that the JVM uses nowadays?
08:43:48 <dolio> I don't know much about the JVM.
08:44:18 <shapr> I really enjoyed reading the poly-inline caching in Self papers.
08:44:28 <shapr> That's also why I'm trying to acquire some SPARC hardware
08:44:36 <shapr> (for free if possible :-P)
08:45:53 <dolio> I don't think the details matter, except that you might have to structure your 'partially applied interpreter' in a certain way to make sure that whatever JIT you actually use can eliminate all the interpretation overhead.
08:49:50 <_sras_> Axman6: Can I pass the (withConnection pool) function in the readers env?
08:50:37 <_sras_> Axman6: Is there any difference between passing the whole pool, and just the partially applied (withConnection pool) function?
08:51:06 <mbw> Axman6: I can see how using Writer as logger is a problem due to space leaks, but you can just use State. But if I have something like a MonadDB constraint, wouldn't defining a mock instance of this typeclass amount to the same thing? (Sorry, this is a repost, wasn't sure if you saw it.)
08:53:03 <dolio> mbw: There's basically nothing you can do with free/whatever that you can't do with the other approach.
08:53:44 <dolio> It just depends on what you consider most convenient/elegant/etc.
08:56:30 <mbw> Practically speaking, I am not afraid to refactor. Since most of the stuff I write is pure in the first place, I don't need fancy effect-handling most of the time. But this of course makes some concepts hard to learn (and remember), since I don't write web apps that deal with concurrency, data bases, html requests etc. etc. all at the same time...
09:09:41 <n_blownapart> hi if anyone has worked in "Haskell from First Principles," I'm wondering if I can get by without Stack. I had trouble using it on a 32bit machine. Or should I try to get it working for the sake of going through the book
09:13:29 <bno2_> hi
09:13:51 <bno2_> i remember there used to be a wiki page about some fake concept made to sound complicated
09:14:08 <bno2_> the equivalent of a turboencabulator but with morphisms and category theory
09:14:24 <bno2_> does anybody remeber it?
09:14:45 <dolio> Zygohistomorphic prepromorphism?
09:14:56 <bno2_> yes, thank you
09:15:02 <dolio> It's not fake, though.
09:15:06 <merijn> That's not fake though
09:15:19 <bno2_> oh ok
09:15:42 <erisco> a turboencabulator is a thing?
09:15:46 <bno2_> no
09:15:48 <jle`> yes i use it all the time it's fun stuff
09:15:51 <merijn> Just a combination of a bunch of (rarely used) terms in an even less used thing
09:15:57 <dolio> It's just a combination of a bunch of individual things with pointlessly fancy names.
09:16:19 <dolio> Also not really from category theory.
09:16:28 <erisco> they just mashed together some Greek words, prefixes, and suffixes
09:16:47 <erisco> they're trying to name things that are subtly different
09:16:48 <dolio> prepro is barely Greek, too.
09:17:23 <erisco> and if you just translate the words it isn't that crazy
09:32:33 <saurabhnanda> help with this please -- https://stackoverflow.com/questions/44572548/how-to-check-monadic-io-properties-with-tasty-quickcheck
09:48:23 <nshepperd_> saurabhnanda: what does withResource do? It looks monadic which probably means you need to put it inside the monadicIO call
09:56:51 <agent47> a
09:57:02 <agent47> Are these safe?
10:33:12 <Guest27443> Can someone please give me idea about beginner level project in haskell 
10:35:58 <sm> a guess the number game
10:36:25 <Guest27443> @sm : Something that I can add in my resume
10:36:25 * lambdabot moulds : Something that I can add in my resume into a delicous cookie, and places it in her oven
10:36:44 <Clint> o_O
10:37:08 <sm> a guess the number game in opengl
10:37:08 <Tuplanolla> Why would you put a beginner-level project into your resume, Guest27443?
10:37:29 <Guest27443> because I am a fresher
10:37:44 <Tuplanolla> What does that even mean?
10:38:04 <Sylph-DS> first year university student, I would guess?
10:38:19 <erisco> maybe a "guess the state" game in opengl
10:38:19 <Guest27443> university student 3rd year
10:38:35 <sm> Guest27443: well you've got to start somewhere, and that's a good place to start IMHO
10:39:02 <Guest27443> @sm thanks for the advice I'll start from that
10:39:02 * lambdabot smacks thanks for the advice I'll start from that about with a large trout
10:39:04 <erisco> your first work is probably going to suck so I wouldn't be banking on having it for the resume
10:40:01 <cocreature> Guest27443: writing interpreters is also often used as a beginner-level haskell project
10:40:34 <cocreature> but I’m not sure if being able to put it on your resume is a good motivation for a beginner project
10:41:29 <Guest27443> I'll try to do these things and maybe i'll get idea while doing things
10:46:19 <kamyar> Hi all
10:46:28 <kamyar> I have a question about tinyredis
10:46:39 <kamyar> I need a redis connection pool which is present in other language bindings
10:46:49 <kamyar> Sorry
10:46:54 <kamyar> Wrong Channel
10:46:55 <kamyar> Bye
10:57:00 <noijlo> Having some list xs of a type with constructors Bar Int, Baz Int and Foo String. I can get all Foos with [ x | x@(Foo _) <- xs ], how can I split the list in a nice way? Such that I get a list [[only Foos], [only Bars, Bazs,...]], I could just do it with `notElem` but is there a better way?
10:57:46 <erisco> I should hope so but I have not seen it
10:57:52 <erisco> maybe a lens thing
10:58:13 <byorgey> noijlo: write a function  isFoo  and then call  partition isFoo
10:58:48 <erisco> well yeah, but that is grody
10:58:50 <Xion___> Do you have to write it? Is there no way to reify type constructor to do it automatically?
10:58:55 * Xion___ thinks about Typeable
10:59:00 <raynold> ahh it's a wonderful day
10:59:11 <shapr> I could go for a nap, but yeah
10:59:17 <noijlo> byorgey: Thats a good idea!
11:00:09 <byorgey> Xion___: sure, there are ways to automate it.  But it's a strange thing to want to do, since the fact that you have separated out the different constructors is not reflected in the types.
11:00:48 <byorgey> In this situation I would rather e.g. write a function   partitionFoos :: [TheType] -> ([String], [Either Int Int])
11:01:12 <byorgey> where each Foo turns into a String and Bar and Baz turn into Eithers
11:01:36 <byorgey> that way you never have to worry about remembering that e.g. you have a list with only Foos in it.
11:02:13 <erisco> you'd have other options in a DT language... but maybe in Haskell you should consider using a triple of lists to begin with
11:02:36 <erisco> and three types instead of a sum
11:02:42 <byorgey> it really depends on what you want to do.
11:03:45 <noijlo> byorgey: That's a nice idea too, but in this case it's actually only parsing args. So isFoo is the go, I guess.
11:05:15 <erisco> so you change the concept from "some argument" to "an argument" and "some arguments"
11:05:45 <erisco> what I mean is, instead of a sum of arguments, you have a type per argument, and then you have a type of argument lists
11:07:18 <erisco> newtype Foo = Foo Int; newtype Bar = Bar Int; newtype Baz = Baz String; data Arguments = Arguments { foos :: [Foo], bars :: [Bar], bazs :: [Baz] }
11:09:26 <noijlo> erisco: I didn't want to seperate out the constructors, but I guess it's much cleaner like this. Cheers
11:09:49 <erisco> you can define  fooArg :: Foo -> Arguments; barArg :: Bar -> Arguments; bazArg :: Baz -> Arguments
11:10:16 <erisco> and Arguments is clearly a Monoid, so now you can write  fooArg x <> bazArg y <> bazArg z
11:12:20 <erisco> and if you really wanted to you could define a type class to give a single name for fooArg/barArg/bazArg
11:13:49 <noijlo> That's overkill I guess :)
11:14:15 <erisco> I won't charge you for using this idea
11:27:50 <noijlo> You mean like this: http://termbin.com/9wt5 ?
11:29:07 <erisco> yes, though I consider the fooArg, barArg, and bazArg functions to be important
11:30:07 <erisco> they are the way, along with mempty, you'd construct an Arguments
11:30:17 <erisco> like Set.empty, Set.singleton, and Set.union
11:32:36 <noijlo> Yeah, Set would be better than List
11:33:18 <erisco> it was an analogy for the interface. Whether you use a list or a set to define Arguments is a different matter
11:34:05 <noijlo> Like fooArg f = mempty { foos = [f] } ?
11:35:20 <noijlo> I like this idea, thanks
11:35:44 <erisco> I suppose that works, interesting
11:36:11 <noijlo> what's interesting?
11:36:21 <erisco> I wouldn't have thought to implement it that way
11:36:48 <noijlo> How else?
11:37:03 <erisco> the more pedestrian Arguments [f] [] []
11:37:55 <Tuplanolla> > () {} -- Record syntax can be used in surprising places.
11:37:55 <noijlo>  Hm didn't know, you can initialize records like that
11:37:56 <lambdabot>  ()
11:38:22 <erisco> sure. the constructors have a function type
11:55:25 <cocreature> what are some libraries that make use of the custom TypeError features in GHC 8.0?
11:55:45 <cocreature> I’m failing to use it for anything where I would like better errors so I’d like to see how other people make use of it
11:56:11 <t7> linear types, when?
11:58:44 <EvanR> cocreature the array programming paper uses a trick to get custom type errors, since it was written before ghc 8. APLicative programming with naperian functors
11:59:22 <EvanR> instead of crazy wall of type errors... "shapes dont match"
11:59:41 <cocreature> EvanR: ah I’ll take a look at this
12:00:51 <cocreature> my problem with the type errors in GHC 8 is that everytime I want a custom typeerror I want it for a unification error and not for a type family or a missing instance and I’m not sure how to encode that
12:07:38 <nschoe> Hi all, I wanted to know what the status of GHC for ARM was. I have a Raspberri Pi Zero and am about to have a Raspberry Pi 3, I wanted to know if I will be able to install GHC and compile some Haskell programs on them.
12:08:00 <nschoe> The Raspberry pi HAskel page (https://wiki.haskell.org/Raspberry_Pi) seems incomplete and somewhat obsolete (but I may be wrong).
12:08:14 <nschoe> And all the articles I can see about this are generally 2-3 years old.
12:08:47 <EvanR> cocreature: is this an existing feature? i found the tracker page for it but not the manual entry
12:09:22 <cocreature> EvanR: yes it is! https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=typeerror#custom-compile-time-errors
12:09:25 <nschoe> On my rPi Zero W (on which I installed Archlinux) I tried to install GHC or the Haskell Platform, but there are no packages, so I guess it's not supported. The rPi 3 is ARMv8, so I thought this might be better supported. Any ideas on this?
12:10:11 <cocreature> in theory it seems amazing but I seem to be too stupid to use it
12:10:36 <antiman> Is the kth order statistic algorithm different in functional languages? I am following a data analysis guide and the first mini project is to find the median of some data -- which they find by sorting. How would I apply something like median of medians, or random-select
12:10:47 <EvanR> the only examples are missing instance....
12:10:51 <cocreature> basically I’m trying to get a custom type error when the constraint https://github.com/cocreature/postgresql-named/blob/master/src/Database/PostgreSQL/Simple/FromRow/Named.hs#L50 is missing
12:11:05 <EvanR> nschoe: i am in the same boat, im about to try to set up a cross compiling environment for rpi
12:11:06 <cocreature> but I’m not sure how to do that
12:11:52 <EvanR> nschoe: theres been a lot of work to get TH (necessary for many packages) to work while cross compiling by running a demon on the rpi itself that helps the interpretation of TH
12:12:51 <nschoe> EvanR, okay, do you have any (recent) links for that?
12:12:55 <EvanR> i saw a blog post that built yesod on rpi and systematically went through about 10 issues in the process and fixed them
12:13:13 <EvanR> https://medium.com/@zw3rk/cross-compiling-yesod-to-raspberry-pi-f14de6fdbf06
12:13:20 <nschoe> EvanR, at this point I'd even settle for direct compilation on the rPi, even if not cross-compiling
12:13:33 <nschoe> EvanR, thank
12:13:58 <EvanR> well some people have managed to do that, but its kind of a craps shoot
12:14:13 <EvanR> because you either run out of memory or it takes forever
12:14:53 <nschoe> EvanR, yeah... even for relatively small projects?
12:15:01 <nschoe> I guess GHC's a heavy beast.
12:15:02 <EvanR> the project is itself is one thing
12:15:19 <EvanR> the depths of dependencies you have to compile, which probably involves lens at some point
12:15:37 <nschoe> And the nall heall breaks loose? ^^
12:16:00 <nschoe> Okay I see. I'll read and study the medium article you linked.
12:16:12 <nschoe> I really hope I can manage it. Otherwise... I'll have to resort to C++ :/
12:16:37 <EvanR> im not resorting to C++ for my project
12:16:45 <EvanR> so something is going to get managed
12:17:58 <EvanR> the guy working on the arm/rpi cross compiling technology is in here... nick started with an A...
12:18:00 <nschoe> He he, yeah I see. But unfortunately, my Haskell days are too far away for me to go too deep in this :)
12:18:17 <cocreature> angerman
12:18:28 <EvanR> angerman
12:18:51 <nschoe> I have a product to finish But I won't be shy either, I'll try to get to the bottom
12:19:59 <EvanR> if theres not much deps, then maybe on-the-device will work
12:21:15 <nschoe> I'll see, then :)
12:21:19 <nschoe> Thanks for your help :)
12:34:30 <verydeliciouscat> hello!
12:37:07 <shapr> aw, delicious cat left so soon
12:38:02 <monochrom> Stop your dirty mind of wanting to eat a cat! :)
12:38:33 <monochrom> (NSFW) shapr-eating-cat.png
12:40:46 <shapr> ???
12:41:10 <erisco> http://www.featurepics.com/StockImage/20080402/cable-technician-taking-a-bite-stock-picture-672792.jpg
12:41:29 <int-e> monochrom has a literal mind
12:42:04 <monochrom> haha erisco
12:42:18 * monochrom is very literal indeed
12:43:52 <monochrom> Just this Monday I was teaching amortized time and the accounting method. There was an instance when a certain operation had a surplus but it's harmless to ignore it and not save it up. And then I said,
12:44:40 <shapr> WHAT DID YOU SAY?
12:45:00 <monochrom> "But you're new to this so you're right to be paranoid. So I'll go by the book---literally---and save it too"
12:45:33 <monochrom> Get it? Accounting. Book. Literally. :)
12:46:31 <EvanR> shapr how did the flask talk go
12:48:19 <ongy> shapr did a flask talk?
12:49:00 <EvanR> allegedly
12:50:04 <ongy> shapr: did you describe why it's annoying to use, or actually try to get people to use it? :)
12:50:27 <erisco> and the class erupted in a roaring silence
12:50:46 <angerman> cocreature, EvanR. Ha thanks for the double ping.
12:51:21 <EvanR> unlike candyman you only have to say it twice
12:52:33 <angerman> I'm still too slow. nschoe seems to be gone already :-/
13:19:58 <leshow> stack makes binaries of my application in .stack-work/dist and /install dirs of vastly different sizes
13:20:01 <leshow> whats the difference
13:26:36 <geekosaur> I think mostly symbols?
13:28:06 <leshow> one is w/ debug symbols or something?
14:22:05 <EvanR> i sort of found out what Network.Socket does as far as exceptions go
14:22:49 <EvanR> on not-windows. If a basic socket call fails, it uses throwErrno from Foreign.C.Error 
14:23:13 <EvanR> which throws an IOError
14:25:00 <EvanR> and see theres about 20 kinds of IOError...
14:25:45 <EvanR> and heres the mapping table! https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Foreign.C.Error.html#errnoToIOError
14:25:54 <EvanR> this is like indiana jones, i found the holy grail
14:26:35 <EvanR> personal favorite NoSuchThing
14:28:01 <hpc> i like the OK has its own error number
14:28:34 <Tuplanolla> Sockets can throw almost anything, but not `EOWNERDEAD`.
14:28:35 <EvanR> EOK, just looked it up, means "no error"
14:29:06 <EvanR> i would really hate to get that exception
14:29:54 <hpc> Tuplanolla: in a field where zombies and killing children is the norm, it's nice to have something simple like a dead owner every once in a while :D
14:32:01 <moriarty> i wonder if there are any haskell apps for bitcoins
14:32:23 <EvanR> yes, several
14:32:39 <moriarty> link please?
14:32:48 <EvanR> google "haskell bitcoin"
14:34:06 <moriarty> heh i did and i only saw haskell's implementation of bitcoin
14:35:23 <EvanR> i dont know of a wallet or something no
14:35:50 <moriarty> i see, EvanR, not a wallet, more along the line of smart contracts
14:35:54 <EvanR> hold on, haskoin-wallet
14:36:30 <monochrom> I'm wonder if http://hackage.haskell.org/packages/search?terms=bitcoin has what you're looking for.
14:37:42 <moriarty> monochrom, cool thanks that works!
14:38:03 <monochrom> But I prety haskloin steak.
14:38:10 <monochrom> err, prefer!
14:38:17 <moriarty> haha :)
14:39:11 <monochrom> Oh great, so bitcoin addresses are in base 58.
14:48:57 <kadoban> It's actually a pretty decent encoding as far as encodings go.
14:50:08 <monochrom> Just being dazzled by the diverse variety of base 64, base 58, base this number, base that number...
14:50:26 <monochrom> I think I even heard of a base 63.
14:51:24 <monochrom> You would think that after base 64 and base 48 were invented a long time ago, people would just be picking from those two.
14:52:58 <monochrom> The same way everyone uses either FNV1 or FNV1a for hashing (the non-secure kind) and not bother to think up a third one.
14:53:46 <EvanR> i came up with an encoding that used 26 latin letters and all greek and cyrillic that wasnt in latin
14:53:52 <EvanR> cant remember the base
14:53:54 <monochrom> haha
14:54:01 <EvanR> it didnt go over well with... sanity
14:54:05 <hpc> you want encodings, try analyzing email professionally sometime
14:55:11 <EvanR> in the end, the number of alphabets you have is minor compared to the length of the string
14:55:30 <monochrom> I guess this is along the line of Wadler's law. Where semantics is paramount and diversity is actually needed, such as hash functions, people don't diversify; where surface appearance is paramount and diversity doesn't do you any good, such as big number encoding, people innovate like there is no tomorrow.
14:56:06 <Tuplanolla> In how many ways can you format this code?
14:56:29 <monochrom> Oh email is a lot of fun, especially how to do non-ascii in the subject line.
14:56:59 <monochrom> (Pretty much a completely independent story from MIME for the message body!)
14:59:10 <EvanR> uniformity of surface appearance, what is this dystopia
14:59:48 <monochrom> Haha
15:00:53 <monochrom> More in #haskell-offtopic
15:25:24 <lgas> hi.  does anyone know if it's possible to use lens-aeson to pull out the original raw bytes of the original records?  e.g. right now I'm filtering to a subset of records and then pulling out a tuple containing two of the fields... I'd love to add a third element to the tuple that is the raw bytes of the entire record that the first two fields came from.
15:26:34 <keenen> Hey, are there any machine learning libraries for haskell? I just finish the Miran Lipovaca book and wanted to learn about machine learning next
15:26:42 <puregreen> lgas: afaik it's not possible
15:27:01 <keenen> or should I just stick with python in that realm
15:27:06 <lgas> puregreen: bummer, thanks
15:30:21 <Tuplanolla> If I wrote a proposal for an extension that adds sound effects to GHC, do you think it would have a chance?
15:32:30 <Cale> Tuplanolla: hahaha, what would you use it for?
15:33:33 <Tuplanolla> I wouldn't have to read error messages; I could just listen to where the glass shattering sounds come from.
15:34:16 <tomleb> No one is around in #sevant, anyone has some experience with AuthProtect here ?
15:34:20 <Tuplanolla> I could also hear rewrite rules firing by the distinctive whooshing sounds.
15:34:39 <monochrom> Aim high. Have GHC speak out the error message in voice.
15:35:16 <Tuplanolla> That would be too slow and boring.
15:35:58 <monochrom> OK, have GHC speak out the error message at 20 syllables per secound in ultrasound.
15:37:53 <jle`> can we just have it scroll on the screen concurrently/overlapping each other like in The matrix
15:39:03 <monochrom> What if you have no error messages? :)
15:39:41 <Tuplanolla> That would sound like a tiny bell.
15:40:17 <monochrom> Like the way a microwave oven tells you it's done?
15:40:38 <Tuplanolla> I have it all planned out.
15:41:35 <EvanR> have ghc speak the way you would have described the mistake
15:41:45 <EvanR> actually, i would settle for it printing that out as text
15:43:58 <monochrom> I know how to combine the glass shattering sound idea with my idea.
15:44:39 <monochrom> Play the glass shattering sound, but it contains stenography of the Morse code for the error message.
15:45:07 <geekosaur> ...steganography?
15:45:17 <monochrom> Yeah
16:07:38 <lyxia> Tuplanolla: do you know about the RTS option to ring the bell when it GCs.
16:08:51 <Tuplanolla> I've heard of it actually, but the lack of bell in the terminal ruins it.
16:09:12 <EvanR> lol
16:09:26 <EvanR> that must be a very active bell
16:09:27 <pacak> breaking news - STRefs are unsafe: https://ghc.haskell.org/trac/ghc/ticket/13615#comment:41
16:10:16 <Tuplanolla> Bonus points for correct use of "breaking", pacak.
16:12:18 <glguy> pacak: My takeaway from that is that par is unsafe
16:13:07 <pacak> glguy: Hmm... Maybe when it operates on relates stuff...
16:13:10 <pacak> related
16:14:44 <glguy> par appears to be incompatible with unsafeDupablePerformIO, which is what runST is
16:15:19 <pacak> Wasn't there a paper not so long time ago proving that runST is OK?
16:16:35 <glguy> I wouldn't expect anyone has modeled enough of the runtime system and optimization passes to prove whether or not runST is safe as realized by GHC
16:17:51 <pacak> Hmm... Your thoughts about par seems useful. Can you add them to ticket?
16:18:29 <glguy> I did that 6 weeks ago
16:21:05 <pacak> par is mentioned but not directly blamed.
16:35:22 <pacak> unsafeDupablePerformIO: This version of unsafePerformIO is more efficient because it omits the check that the IO is only being performed by a single thread. 
16:35:52 <pacak> Because hey, par is no longer single thread.
16:36:13 <EvanR> so unsafeDupablePerformIO is unsafe
16:36:27 <pacak> Breaking news! Water is wet!
16:36:50 <EvanR> flabbergasting
16:36:51 <mibaz_1> Good message to log on to.
16:38:05 <c_wraith> pacak, I think you mean wetWater is wet. 
16:38:26 <Rembane> But dryWater is not.
16:38:51 <EvanR> water is a mineral on many planets including this one
16:39:13 <EvanR> answering the question of animal vegetable mineral for water!
16:41:09 <Rembane> On a few planets water is a maxeral
16:44:27 <nshepperd_> In bgamari's comment they suggest that a function is taking out a shared value in runST, modifying it and putting it back. That sure looks like a bad thing to do
16:45:19 <pacak> nshepperd_: There's a version that simply adds numbers in 100% legitimate way using STref - last comment.
16:48:26 <ab9rf> my wife had a teacher who said "miximim" for both maximum and minimum.
16:49:40 <erisco> ab9rf, I'm sorry
16:50:26 <ab9rf> i had a CS prof who had a tendency to get excited during lectures and switch to lecturing in french
16:50:59 <ab9rf> that was fairly frustrating until we figured out that she was lecturing pretty much straight from the text
16:51:00 <monochrom> Good for that prof.
16:51:22 <ab9rf> we called her the "french lady on speed"
16:51:28 <monochrom> When I speak French it's when I am unexcited, disappointed, no longer care, "c'est la vie".
16:51:29 <Zemyla> Are there any types f such that f is a Comonad and f is an Apply, but f is not a ComonadApply?
16:51:37 <ab9rf> i'm trying to remember what that class was, probably data structures
16:51:55 <barcabuona> has anybody tried `runghc -fwarn-incomplete-patterns` ?
16:52:08 <barcabuona> im really annoyed that this isnt default and im adding aliases...
16:52:17 <barcabuona> its just so important for safety
16:53:25 <Cale> barcabuona: Yeah, the defaults aren't really great
16:53:56 <pacak> barcabuona: -Wall -Werror
16:53:58 <Cale> barcabuona: and then there's -Wall, which we use, but that warns about stuff which isn't really very likely to be an issue
16:54:07 <tomleb> What's the idiomatic way of accepting only positive integers ?
16:54:20 <pacak> tomleb: Word? O_o
16:54:26 <Cale> (which then forces you to waste time making your code slightly less pretty)
16:54:38 <tomleb> pacak: I'll take a look, thanks
16:54:47 <Rembane> tomleb: filter (>0)
16:55:06 <ab9rf> what means "accepting"
16:55:48 <tomleb> ab9rf: Can only be passed non-negative integers
16:55:51 <Arcaelyx_> If anyone uses Discord, here's a temporary invite to the functional programming Discord server https://discord.gg/dahFZC
16:56:12 <tomleb> Numeric.Natural would work
16:56:20 <pacak> Arcaelyx_: Shooo
16:56:22 <ab9rf> tomleb: do you want a type that has no representation of negative integers, or do you want the function to error if passed one?
16:57:08 <tomleb> ab9rf: Using Servant, if the router cannot parse the non-negative integer, then my function never gets called
16:57:09 <ab9rf> isn't discord for like actually talking to people?
16:57:15 <tomleb> so Numeric.Natural would work
16:57:22 <tomleb> because read "-1" :: Natural failes
16:57:23 <tomleb> fails
16:57:33 <ab9rf> tomleb: yeah, then that's at least one option
16:57:42 <tomleb> Just wondering if that was the only way
16:57:49 <ab9rf> tomleb: there's never only one way
16:58:08 <tomleb> Yeah I meant more like, what's the most idiomatic haskell
16:58:30 <Maxdamantus> read (show n) :: Natural
16:58:38 <Maxdamantus> Problem solved.
16:59:08 <ab9rf> if you only want nonnegative integers, don't parse negative integers 
16:59:18 <tomleb> ab9rf: I'm not lol
16:59:30 <tomleb> It's Servant that's doing the parsing
17:00:41 <tomleb> Now gotta find a function to Natural -> Int
17:00:50 <pikajude> fromIntegral
17:01:45 <tomleb> pikajude: thanks
17:03:52 <sm> I have a trivial enum type (Status), and I wanted to count its values in the program. This works, assuming I add the Bounded and Enum typeclasses: fromEnum (maxBound :: Status) + 1. Any better way ?
17:05:18 <Koterpillar> sm: length [minBound :: Status .. maxBound] ?
17:07:11 <ab9rf> ugh
17:09:45 <ab9rf> are all Enums Bounded?
17:09:59 <kadoban> No
17:10:04 <ab9rf> thoguht so
17:10:42 <kadoban> Integer would be the cannonical example I think.
17:11:17 <pacak> One interesting question to ask - are Enums required to map values to sequential ints...
17:11:26 <pacak> or starting from 0.
17:11:27 <ab9rf> pacak: yeah, i'm looking into that now
17:11:46 <nineonine> hi there
17:11:57 <nineonine> i have this datatype 
17:12:33 <nineonine> data Regs = Regs { a :: Int, b :: Int }
17:12:37 <nineonine> and this function
17:12:46 <iqubic> Do are people's opinions on fltkhs?
17:12:52 <nineonine> getterFor :: Chat -> Regs -> Int
17:12:52 <kadoban> pacak: I don't think so, but not sure if I'm missing a law that requires it.
17:12:57 <iqubic> @hackage fltkhs
17:12:57 <lambdabot> http://hackage.haskell.org/package/fltkhs
17:13:07 <iqubic> https://www.youtube.com/watch?v=5hoQLovZBxQ
17:13:13 <nineonine> the implementation for getterFor is very lame
17:13:30 <pacak> nineonine: What's Chat?
17:13:35 <iqubic> That video cam out last may, and explains fltkhs. Do people like the library?
17:13:53 <nineonine> getterFor c = case c of 'a' -> a; 'b' -> b; _ -> const 0
17:14:00 <iqubic> s/cam/came/
17:14:00 <nineonine> sorry, that was  eant to be Char
17:14:07 <nineonine> meant*
17:14:09 <iqubic> :t const
17:14:10 <lambdabot> a -> b -> a
17:14:15 <ab9rf> the Report states that derived instances of Enum will have fromEnum 0 be the first enumerated value, up to n-1 which will be the last
17:14:16 <iqubic> :t const id
17:14:17 <lambdabot> b -> a -> a
17:14:30 <ab9rf> if you write your own Enum instance, you can do whatever you bloody well want
17:15:07 <pacak> nineonine: so value of getterFor '☭' will be 0?
17:15:12 <nineonine> yes
17:15:31 <pacak> nineonine: Why not create a separate datatype - getterable data Blah = A | B ?
17:16:01 <nineonine> how is it going to work ?
17:16:10 <ab9rf> you could perfectly well write an Enum for which fromEnum n is only valid for prime 
17:16:18 <pacak> It will be the same case statement but without _ case
17:16:23 <ab9rf> sorry, toEnum n
17:16:26 <pacak> and ghc will warn you if you add more fields.
17:16:50 <nineonine> my actual question was : can you do it somehow using Typeable and Data ?
17:19:26 <nineonine> actually Enum will work perfectly fine, thank you for suggestion !
17:20:12 <nineonine> I was just curious if Data/Typeable had some machinery that was able to do that
17:20:15 <ab9rf> that smells vageuly lensy
17:20:23 <nineonine> agreed !
17:21:09 <lyxia> you can but it's not a good idea
17:22:19 <nineonine> yeah, that was purely for self-gratification as well as educational purposes
17:22:46 <ab9rf> please clean up after yourself
17:23:06 <barcabuona> pacak: i tried wall but it was annoying. like missing signatures are an error...
17:23:12 <iqubic> I just found a legitimate use case for dependent types in the wild. fltkhs's value function.
17:23:32 <barcabuona> the weird thing is if you call runghc --fwarn-incomplete-patterns it suggests to use the right one XD
17:23:37 <barcabuona> it's a bug at this point
17:24:01 <pacak> barcabuona: Have you ever tried working on big and unfamiliar codebases? Looking to replicate a bug to report for example?
17:26:38 <erisco> much grep happened that day
17:29:20 <pacak> erisco: Actually no, but quite often that means adding type signatures and explicit imports/exports. That makes me really hate those who don't do it themselves.
17:29:26 <sm> thanks Koterpillar, that might be a little clearer
17:33:03 <iqubic> How does one get started with gtk-gi?
17:34:13 <hamishmack> iqubic: https://github.com/haskell-gi/gi-gtk-examples
17:35:38 <barcabuona> pacak: what?
17:36:21 <pacak> barcabuona: Code that produces no warnings with -Wall is good and easy to work with.
17:36:53 <lordcirth> barcabuona, why would you write functions without signatures?
17:38:00 <dmwit> less typing (both kinds) ;-)
17:43:44 <barcabuona> pacak: i understand this. but it's not always ideal. -Wall is like a pre-deploy thing to me. im just pointing out that bug
17:44:10 <barcabuona> lordcirth: i used signatures a lot in ocaml. but for minor things i already know what they will be, i dont bother
17:44:29 <barcabuona> also a one-liner very small function takes 2 lines and clutters code if it's embedded in some places
17:45:49 <lordcirth> barcabuona, it's not just for you, it also makes your type errors show up where you actually made the mistake, not 2 functions away
17:46:26 <orion> What is the most idiomatic way of accomplishing this with a series of IO actions (instead of Integers)?: concatMap (\(b, c) -> [b, c]) $ map (\a -> (a + 1, a + 2)) [1, 2, 3]
17:46:58 <lyxia> where's the IO
17:47:04 <orion> lyxia: It's not in the example I gave
17:47:08 <Koterpillar> orion: ListT IO?
17:47:16 <orion> Koterpillar: Is that in base?
17:47:30 <lyxia> I guess it's as effectful as return ().
17:48:10 <orion> For every element in a list, I want to generate two values in IO and merge them in to a single list.
17:48:34 <Koterpillar> merge values manually, I just opened ListT and it says the monad instance is invalid for most monads
17:48:42 <orion> I see.
17:49:24 <Koterpillar> (and ListT was in transformers)
17:50:48 <barcabuona> lordcirth: ah yes i did see that. but for very small functions i don't really need it
17:50:52 <lyxia> orion: traverse   then   fmap concat
17:52:58 <iqubic> :t (+ 1)
17:52:59 <lambdabot> Num a => a -> a
17:53:05 <iqubic> :t (- 1)
17:53:06 <lambdabot> Num a => a
17:53:31 <iqubic> Is it not possible to force that second one to be a function that subtracts on?
17:53:40 <lyxia> :t subtract 1
17:53:41 <lambdabot> Num a => a -> a
17:53:52 <iqubic> Is that why the subtract function exists?
17:53:55 <lyxia> yes
17:54:03 <orion> lyxia: Isn't traverse basically the same as mapM since I'm in IO>?
17:54:12 <lmapper> hi, I'm wondering if someone could have a look at something I wrote the other day
17:54:17 <lyxia> orion: it is
17:54:50 <lyxia> lmapper: what is it
17:54:52 <lmapper> I just wrote it with the abstractions i'm familiar with, but I hope to make use of something more advanced, polymorphic
17:55:24 <lmapper> right now it's just a really simple control flow framework, kind of general
17:55:33 <lmapper> i put it on lpaste
17:55:40 <lmapper> http://lpaste.net/2561197592557912064
17:56:07 <lmapper> I am not really good with typeclasses, gadt, etc yet
17:56:20 <lmapper> so I just wrote it in a somewhat simple way
17:56:51 <lyxia> making a Function type synonym is a bit much
17:57:14 <lmapper> I'm hoping to get some feedback on how to make better use of higher level abstractions
17:57:29 <iqubic> What is the name of the language extenstion I need to let me write multiple parameter typeclasses, like bifunctor?
17:58:26 <lyxia> lmapper: I would inline all the rootPort and srcPort
17:58:35 <pacak> iqubic: MultiParamTypeClasses ?
17:58:45 <iqubic> Yes, that.
17:58:49 <erisco> just do it and GHC will tell you what you need
17:59:01 <pacak> iqubic: That would be $0.50.
17:59:13 <erisco> someone spent a lot of time on those error messages
18:00:05 <lmapper> that whole section "---Testing output---" will not be that way in the final code, I'll be parsing json instead of hardcoding the connections
18:00:16 <lmapper> what did you mean by inlining?
18:01:16 <erisco> it means copy and paste the definition
18:01:47 <lmapper> I was kind of hoping to explore some options for the Value data type, to see if typeclasses or gadts would be an improvement, or if this simpler way is sufficient
18:03:33 <lyxia> lmapper: combine only works on lists whose elements all have the same type.
18:03:38 <erisco> I don't really know what the whole program is designed for, but Value by itself looks fine
18:04:28 <lyxia> lmapper: is there a situation where that's not going to be the case
18:04:37 <erisco> using type aliases is an alright intermediate to newtypes to add semantics, but when you have an alias called "Function" that doesn't seem helpful
18:05:48 <erisco> it is like having  type MyMaybe = Maybe Int   in that it doesn't add anything to my understanding
18:06:19 <erisco> whereas  type NodeName = String   is useful because now I know how this string is to be interpreted
18:06:22 <lmapper> lyxia: I'd like to allow for combinations of different types later
18:06:32 <erisco> same with PortName
18:06:41 <lmapper> yeah, I should rename Function
18:07:10 <lmapper> this is a backend, for a frontend I've already written
18:07:52 <lmapper> so the functionality might not make sense by itself at the moment
18:09:09 <lmapper> I originally tried to use Gadts but couldn't quite work it out yet
18:09:23 <erisco> I do not personally like the $ notation but otherwise your code appears good syntactically
18:10:43 <erisco> if I knew what the whole program was trying to do I could comment more, but I am too lazy to read through it
18:11:16 <erisco> not sure where GADTs become applicable
18:11:20 <lmapper> sure, I understand, thanks for having a look at it
18:11:57 <lmapper> well, right now the ports are not typesafe
18:12:12 <erisco> what does that mean to you?
18:12:45 <erisco> unless you import the black magic module you shouldn't have type safety problems
18:13:14 <boj> does anyone have an example of how to pass a cabal flag from a nix expression? i have no clue what i am looking for to achieve this
18:14:37 <lmapper> later I will have some Json code that controls what ports are connected to each other
18:15:14 <lmapper> it would be nice if I could use the type system to ensure that incompatible connections were not made
18:16:01 <lmapper> like, when "Functions" other than "combine" are used which don't operate on only one type at a time
18:16:34 <erisco> you'll have to be more specific for me... give me a term that should not type check but does
18:20:35 <lmapper> I think I'll have to develop the structure more to demonstrate that
18:49:26 <Koterpillar> I want to represent a SELECT-like query in a type-safe way. An example is: SELECT a, sum(b) as bs WHERE a > b GROUPBY b. Note that I have free (a, bs) and bound (b) variables here. Is there a library that can help me (possibly type-level sets?) or any recommended reading?
18:54:10 <boj> Koterpillar: opaleye and tisch may be worth looking at for doing type safe sql queries
18:54:33 <Koterpillar> this is not SQL
18:54:34 <pacak> groundhog, sqroll
18:54:54 <boj> Koterpillar: sorry, i meant as inspiration for what you are looking for
18:56:49 <Koterpillar> good point, thanks
20:51:32 <saurabhnanda> any help with https://stackoverflow.com/questions/44572548/how-to-check-monadic-io-properties-with-tasty-quickcheck please?
20:58:37 <glguy> saurabhnanda: Hard to say without having access to the type of withResource, but it looks like you need to push the withResource under the monadicIO
20:58:57 <glguy> monadicIO $ withResource dbPool $ \conn -> ...
21:01:35 <saurabhnanda> glguy: hang on, editing the question
21:02:20 <saurabhnanda> glguy: take a look now at https://stackoverflow.com/questions/44572548/how-to-check-monadic-io-properties-with-tasty-quickcheck
21:04:18 <saurabhnanda> glguy: added another example on the same lines, which is actually working...
21:04:29 <saurabhnanda> glguy: except that it's not a QC property but an HUnit test cae.
21:05:16 <glguy> OK, what happened when you did what I said above?
21:05:52 <saurabhnanda> trying... but I'd like to understand why testCase with the similar shape is working, but testProperty is not
21:05:53 <glguy> I'm not sure what the extra example is showing me or what part of the type error you didn't udnerstand
21:06:01 <glguy> It's a different type, so it works differently
21:06:47 <saurabhnanda> :t Test.Tasty.QuickCheck.testProperty
21:06:48 <lambdabot> error:
21:06:48 <lambdabot>     Not in scope: ‘Test.Tasty.QuickCheck.testProperty’
21:06:48 <lambdabot>     No module named ‘Test.Tasty.QuickCheck’ is imported.
21:08:01 <glguy> One is a Property and one is an Assertion, so you won't be able to extrapolate from one to the other
21:08:53 <saurabhnanda> testProperty :: Testable a => TestName -> a -> TestTree
21:09:06 <iqubic> :t contramap
21:09:08 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
21:09:18 <glguy> saurabhnanda: Let me know when you've updated the paste and error as mentioned above, though
21:09:21 <saurabhnanda> instance [safe] Testable Property  -- Defined in ‘Test.QuickCheck.Property’
21:09:32 <iqubic> How does Contramap work??
21:09:41 <glguy> saurabhnanda: That's not relevant to your misusing withResource
21:10:19 <dmwit> iqubic: Depends on `f`, of course.
21:10:21 <iqubic> Like what's the contramap instance for newtype Predicate a = Predicate {runPredicate :: a -> Bool}
21:10:37 <glguy> iqubic: Did you try clicking the source link next to that in the documentation?
21:10:50 <iqubic> Or rather Contravariant
21:10:51 <dmwit> contramap f (Predicate g) = Predicate (g . f)
21:11:02 <iqubic> I'll do that glguy
21:11:16 <dmwit> ?let newtype Predicate a = Predicate {runPredicate :: a -> Bool}
21:11:18 <lambdabot>  Defined.
21:11:25 <dmwit> :t \f (Predicate g) -> Predicate (g . f)
21:11:26 <lambdabot> (a -> t) -> Predicate t -> Predicate a
21:12:16 <saurabhnanda> glguy: please check https://stackoverflow.com/questions/44572548/how-to-check-monadic-io-properties-with-tasty-quickcheck
21:12:23 <saurabhnanda> glguy: some other error now.
21:12:49 <glguy> saurabhnanda: You accidentally the argument
21:13:20 <saurabhnanda> glguy: although, I'd really like to understand which type I'm misreading. testProperty requires a `Testable a` and `Property` has a `Testable` instance. 
21:13:32 <glguy> saurabhnanda: Properties and Assertions are not the same type, so they don't work the same, Assertion is a type synonym for IO(), so it's going to have access to IO directly
21:13:47 <glguy> saurabhnanda: and I know you know how to read the type of withResource, so this is confusing
21:14:06 <saurabhnanda> glguy: I get that. But I'm not passing them to the same function. One is being passed to testCase the other to testProperty
21:14:20 <glguy> saurabhnanda: and that's not relevant
21:14:24 <glguy> that's not where the typeerror is
21:14:55 <saurabhnanda> hang on, missed an arg
21:15:13 <glguy> yeah "glguy: saurabhnanda: You accidentally the argument"
21:15:23 <saurabhnanda> in the new approach, or the original appoach?
21:15:32 <glguy> both
21:15:36 <saurabhnanda> that's not where the typerror is, wrt new approach or original approach?
21:17:33 <saurabhnanda> glguy: edited again at https://stackoverflow.com/questions/44572548/how-to-check-monadic-io-properties-with-tasty-quickcheck
21:18:05 <glguy> saurabhnanda: Where'd this extra 'run' come from?
21:18:32 <saurabhnanda> without the run also there is some error
21:18:35 <iqubic> :t liftM
21:18:37 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
21:18:44 <iqubic> What the heck does that do?
21:19:07 <kadoban> Same thing as fmap, except for fewer types.
21:19:07 <saurabhnanda>     61   3 error           error:     • No instance for (monad-control-1.0.1.0:Control.Monad.Trans.Control.MonadBaseControl                          IO (PropertyM IO))         arising from a use of ‘withResource’     • In the expression: withResource dbPool       In a stmt of a 'do' block:         withResource dbPool         $ \ conn
21:19:25 <saurabhnanda> glguy: ^^ that's without the extra `run`
21:19:29 <glguy> that looks better
21:19:40 <iqubic> :t fmap
21:19:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:21:38 <saurabhnanda> glguy: I undertood what I was missing while reading the original types. thanks
21:22:00 <glguy> saurabhnanda: Try using pick outside withResource
21:22:01 <saurabhnanda> glguy: although,now the problem shifts to another end... unifying these types within Property is a needless chore.
21:22:30 <glguy> saurabhnanda: It seems like you're going to want to get all the PropertyM business done outside the withResource
21:22:31 <saurabhnanda> should I define a Testable instance of my own for the type of (withResource dbPool testClientDB)
21:22:38 <iqubic> What is the point of Phantom? When will you ever have an f that is both a functor, and a contravariant?
21:23:25 <iqubic> :t phanto,
21:23:26 <lambdabot> error: parse error on input ‘,’
21:23:28 <glguy> do (client :: Client) <- pick arbitrary; run $ withResource dbPool $ \conn -> do insertModel conn client; ...
21:23:29 <iqubic> :t phantom
21:23:30 <lambdabot> error: Variable not in scope: phantom
21:23:42 <glguy> monadicIO $ do (client :: Client) <- pick arbitrary; run $ withResource dbPool $ \conn -> do insertModel conn client; ...
21:23:46 <glguy> something like this
21:23:49 <iqubic> import Data.Functor.Contravariant
21:23:55 <saurabhnanda> glguy: yes, that's what I was thinking
21:24:00 <saurabhnanda> let me try coming up with something
21:24:02 <iqubic> @import Data.Functor.Contravariant
21:24:03 <lambdabot> Unknown command, try @list
21:24:09 <glguy> saurabhnanda: otherwise you can try and figure out the MonadBaseControl instance of PropertyM m
21:25:57 <saurabhnanda> at some level is this a limitation of tasty?
21:26:06 <saurabhnanda> tasty-quickcheck to be specific
21:26:14 <glguy> quickcheck more specifically
21:26:22 <saurabhnanda> because QC standalone will happily run the original property I defined
21:26:48 <glguy> The original property had a type error
21:26:57 <saurabhnanda> original property is compiling
21:27:09 <saurabhnanda> and also running on the repl standalone
21:27:17 <glguy> OK, the first one you shared in the stackoverflow had a type error
21:27:24 <glguy> I can't see your screen
21:27:33 <saurabhnanda> this ==> testClientDB conn = monadicIO $ do;   (client :: BloatedClient) <- pick arbitrary;   client_ <- run $ insertModel conn client;   QCM.assert (client == client_)
21:27:56 <saurabhnanda> isn't that the same thing on SO?
21:28:14 <glguy> No, you wrapped it in withResource
21:28:36 <glguy> (which isn't tasty's fault)
21:29:11 <saurabhnanda> the core function testClientDb is compiling. And can be run with `quickCheck (testClientDb conn)`
21:29:54 <glguy> Sure, but that's not the question, the question is how do you use withResource with that test
21:30:22 <iqubic> I really don't understand how the Divisble Class works at all.
21:30:48 <glguy> saurabhnanda: If you don't need withResource, then what you wrote will fit neatly into tasty as is
21:31:06 <saurabhnanda> I need to picj a db connection from the pool
21:31:19 <saurabhnanda> and a different connection for each test, so that the can be run in parallel on the CI server
21:31:26 <iqubic> Can someone explain to me how the Divisible Typeclass works?
21:32:09 <saurabhnanda> glguy: is there any sane way to compose withResource and monadicIO so that the result is a simple Property that tasty will accept?
21:32:20 <glguy> saurabhnanda: Sure, that's reasonable to need, it just isn't tasty's fault
21:32:49 <saurabhnanda> glguy: not a fault, but a limitation. Probably a new feature
21:33:00 <glguy> It's just not related to tasty at all
21:34:03 <glguy> The way to use withResource and PropertyM together would be to write the MonadBaseControl instance
21:34:30 <glguy> or to find one in a package, it seems like something someone else would have needed
21:34:45 <saurabhnanda> so it boils down to solving this typ error — No instance for (monadcontrol-1.0.1.0:Control.Monad.Trans.Control.MonadBaseControl IO (PropertyM IO))
21:35:14 <saurabhnanda> if PropertyM would've been a transformer, this would just be a lift away, right?
21:35:47 <glguy> PropertyM appears to be a transformer
21:35:56 <glguy> but MonadBaseControl isn't just lift
21:36:00 <saurabhnanda> checking
21:36:38 <glguy> saurabhnanda: run :: Monad m => m a -> PropertyM m a
21:38:35 <saurabhnanda> which is why I had put that extra "run" eaerlier
21:38:53 <glguy> It's why you did, it's not why you had to :)
21:40:36 <saurabhnanda> ok got something to compile
21:40:45 <saurabhnanda> but it is NOT pretty. There has to be an easier way to do this.
21:41:42 <ReinH> iqubic: Maybe https://www.youtube.com/watch?v=cB8DapKQz-I and http://yowconference.com.au/slides/yowlambdajam2015/Kmett-DiscriminationIsWrong.pdf and https://stackoverflow.com/questions/32059754/are-there-useful-applications-for-the-divisible-type-class will help.
21:41:55 <saurabhnanda> glguy: https://stackoverflow.com/a/44580953/534481
21:42:34 <glguy> saurabhnanda: Which part is not pretty? Isn't that basically exactly what you had before?
21:42:50 <glguy> with an extra withResource?
21:43:33 <saurabhnanda> the mental overhead of isolating DB access within the testing code.
21:43:43 <saurabhnanda> isn't that essentially what this is... 
21:44:08 <ReinH> The mental overhead?
21:44:44 <ReinH> It's exactly what you need to do to run your test in IO.
21:44:50 <saurabhnanda> basically we're missing some kind of combinator here
21:45:08 <ReinH> withResource is the combinator
21:45:33 <ReinH> It transforms your ResourceT action, which you can't run, into an IO action which you can run.
21:45:47 <ReinH> rather, run and withResource together.
21:46:03 <ReinH> Sorry, no, just withResource
21:46:25 <saurabhnanda> okay, let it be. I'll just file this away in my fat book of unnecessary boilerplate and move on. That book is getting thicker by the day.
21:47:01 <saurabhnanda> and on to the real debugging... the test fails!
21:47:08 <ReinH> Er, it isn't ResourceT, is it? Anyway, it's the thing you need.
21:47:18 <ReinH> Unnecessary boilerplate?
21:47:20 <saurabhnanda> and pg-simple doesn't give proper error messages.
21:47:25 <ReinH> It is necessary boilerplate.
21:47:27 <saurabhnanda> ReinH: it's a long rant. Let it be.
21:47:30 <ReinH> Obviously, since it doesn't work without it.
21:47:51 <saurabhnanda> ReinH: it's boilerplate. And my code is right now 50% boilerplate. And it's irritating me like anything.
21:48:40 <glguy> saurabhnanda: withResource is certainly not boilerplate, that's not what boilerplate is, it's defining the lifetime of a connection you're borrowing from the pool
21:48:43 <saurabhnanda> You get this error message in production. How will you debug. Heck, how will you debug this in development as well! ==> You get this error message in production. How will you debug. Heck, how will you debug this in development as well! 
21:49:02 <piyush-kurur> saurabhnanda: please stop complaining about bolierplate. The withSomething pattern is a standard idiom in haskell. It takes care of all the other boilerplate like allocating resource and freeing it, catching exceptions etc
21:49:06 <saurabhnanda> You get this error message in production. How will you debug. Heck, how will you debug this in development as well! ==>  Failed! Exception: 'SqlError {sqlState = "XX000", sqlExecStatus = FatalError, sqlErrorMsg = "Unexpected end of string", sqlErrorDetail = "", sqlErrorHint = ""}' (after 1 test): 
21:49:20 <ReinH> You actually do have to make the types line up.
21:49:34 <ReinH> If you think doing so is boilerplate then I'm afraid you've chosen the wrong language.
21:50:05 <ReinH> Well, for one thing, I would use === instead of ==
21:50:11 <ReinH> === will show you the failing case
21:50:21 <saurabhnanda> ReinH: thanks for the tip.
21:50:47 <saurabhnanda> ReinH: Couldn't match expected type ‘Bool’ with actual type ‘Property’
21:51:01 <ReinH> Ah, I guess I don't know what QCM.assert is.
21:51:27 <ReinH> And in any event it probably won't help since your == test isn't returning False, you're getting an exception.
21:51:31 <saurabhnanda> ReinH: https://www.stackage.org/haddock/nightly-2017-03-01/QuickCheck-2.9.2/Test-QuickCheck-Monadic.html#v:assert
21:51:45 <saurabhnanda> ReinH: yes, but it's a good tip nevertheless
21:52:03 <saurabhnanda> this is actually a pg-simple issue. Pathetic error messages.
21:52:06 <ReinH> Oh, yeah, assert specifically wants a Bool. You want to lift a Property to use ===.
21:53:44 <ReinH> tHmm, weird that there doesn't seem to be a way to do tha
21:53:52 <saurabhnanda> piyush-kurur: the boilerplate in this case is NOT being able to do `monadicIO $ withResource $ {... the entire test ..}` Instead WITHIN the test, the actual DB access has to be carefully isolated. What's the way to mark the entire block as, "hey this block here does DB access AND it does the Gen/Arbitrary thingie"
21:54:50 <saurabhnanda> ReinH: is there a verbose mode, which prints out arbitrary instances as they are generated
21:54:58 <glguy> saurabhnanda: You seem to have misunderstood "boilerplate"
21:55:16 <saurabhnanda> ReinH: I got the resulting SQL string from PG logs, and I have no clue how it was generated. Need to quickly check the arbitrary instance that was generated.
21:55:25 <iqubic> What does alternative do?
21:55:44 <saurabhnanda> iqubic: exactly what the name says
21:55:58 <saurabhnanda> iqubic: a <|> b <|> c-- returns the first non-failing value
21:56:14 <glguy> saurabhnanda: No, that's not whatit does in general
21:56:23 <iqubic> So, why does Alternative [] exist?
21:56:38 <iqubic> with empty = [] and <|> = (++)
21:56:43 <codygman> Does anyone cross compile Haskell to raspberry pi 3 or know how to do so? I'd like to avoid compiling directly on the my rpi3
21:56:47 <saurabhnanda> that's what it's USED for, in general. Mostly I've seen it in parsers to try to see the first parser which succeeds.
21:56:50 <glguy> iqubic: Because that makes for a perfectly lawful instance
21:57:00 <ReinH> It's a valid, useful instance.
21:57:03 <glguy> saurabhnanda: No, that's just how it works in parsers, it's not what it is in general
21:57:10 <ReinH> https://wiki.haskell.org/Typeclassopedia#Failure_and_choice:_Alternative.2C_MonadPlus.2C_ArrowPlus
21:57:18 <geekosaur> iqubic, have you played with the list monad aka nondeterminism monad yet?
21:57:18 <iqubic> When would you ever use Alternative []?
21:57:25 <iqubic> geekosaur: No.
21:57:25 <saurabhnanda> iqubic: you're trying to learn theory, or solve a real problem?
21:57:34 <iqubic> I want to learn theory
21:57:43 <saurabhnanda> iqubic: then I'm not the right guy. Listen to others.
21:57:49 <geekosaur> you should; that instance makes perfect sense in that context.
21:58:05 <ReinH> saurabhnanda: When you want to use lists to model choice, you can use <|> to combine choices.
21:58:06 <codygman> hm, looks like the apline based cross compile docker image might work: https://github.com/mitchty/alpine-linux-ghc-bootstrap
21:58:06 <iqubic> I recently watched a video on the extended functor family, and it's awesome.
21:58:13 <geekosaur> the idea being that list gives you all results that don't "fail" (produce an empty list)
21:58:21 <iqubic> Ah. I see.
21:58:47 <iqubic> Why does Newtype WrappedMonad exist?
22:00:07 <ReinH> @google why does newtype WrappedMonad exist
22:00:09 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
22:00:13 <ReinH> :(
22:00:20 <ReinH> Anyway, this is the first result https://stackoverflow.com/questions/28467955/why-wrappedmonad-and-wrappedarrow
22:01:10 <iqubic> Decidable is weird.
22:01:16 <iqubic> I'm not sure I like it.
22:01:35 <ReinH> iqubic: You might write some generic code for Alternative things. Having an instance for [] lets you reuse it.
22:01:50 <ReinH> If you're writing *for* [], you would probably just use [] and (++).
22:02:12 <ReinH> Just like you can write generic Monoid stuff and use it with lists.
22:02:13 <iqubic> lose :: (Decidable f) =>  (a -> Void) -> f a 
22:03:07 <iqubic> choose :: (Decidable f) => (a -> Either b c) -> f b -> f c -> f a
22:03:29 <iqubic> Those are the two functions in the Decidable typeclass, and they are weird.
22:03:40 <Cale> iqubic: The usual way to think of it is that Alternative is a general interface to computations which can have many results, or which can recover from failure. empty represents the computation which fails to produce a result, while <|> combines the results of computations
22:03:49 <saurabhnanda> does anyone have a clue why could Haskell => Sql query conversion be generating this as one of the values? Is this is some common mistake? '\\x22637573746f6d5f64...(goes on like this)'
22:04:13 <Cale> > do x <- [1,2,3]; y <- [1..x]; return (x,y)
22:04:15 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
22:04:22 <Cale> > do x <- [1,2,3]; y <- [1..x] <|> [10]; return (x,y)
22:04:25 <lambdabot>  [(1,1),(1,10),(2,1),(2,2),(2,10),(3,1),(3,2),(3,3),(3,10)]
22:04:47 <iqubic> Do note that Instance Divisible f => Decidable f where is the header for the Decicidable class.
22:04:56 <iqubic> That's so bizarre
22:05:15 <iqubic> Cale: where do those 10s come from?
22:05:36 <iqubic> I honsetly can't tell if decidable is a joke or not.
22:05:42 <Cale> iqubic: y is being selected from [1..x] or from [10]
22:05:43 <iqubic> It sure looks like it.
22:05:50 <Cale> It's not.
22:06:00 <ReinH> lose says "if you can prove that a is uninhabited, I will give you an f of as"
22:06:12 <ReinH> provided that the f of as contains exactly zero as
22:06:22 <iqubic> Can you think of a legitimate use for Decidable?
22:06:36 <ReinH> Yes, I linked you to them.
22:06:43 <Cale> It might help to look at the instances
22:07:13 <iqubic> Most of the instance definitions of Decidable have the function absurd being called from the lost function.
22:07:18 <iqubic> :t absurd
22:07:19 <lambdabot> Void -> a
22:07:34 <Cale> https://hackage.haskell.org/package/contravariant-1.4/docs/src/Data.Functor.Contravariant.Divisible.html#chosen
22:07:39 <piyush-kurur> saurabhnanda: being explicit about side effects and state is not boilerplate, it is "being explicit about side eddect and state". 
22:07:43 <Cale> (look around there in the source)
22:08:04 <ReinH> iqubic: Did you read the stackoverflow I linked you?
22:08:05 <piyush-kurur> some times it is unavoidable that things get a little wonky
22:08:11 <iqubic> I'm not even sure how one could provide a function of type (a -> Void) to the call of lost
22:08:11 <zomg> How would you typically approach storing a mutable state of a type such as `Account a`, where `a` could change? Ie. maybe you have a function such as `Rate a b -> Account a -> Account b` - obviously attempting to go from Account a to Account b for example in an IORef would not typecheck
22:08:26 <piyush-kurur> but then most of the cases it is wrong design of the data types involved
22:08:47 <ReinH> zomg: why does it need to be mutable?
22:08:47 <saurabhnanda> glguy: ReinH: in the withResource/monadicIO problem earlier, how do I put the entire test in a DB txn block? every DB access is wrapped in it's own withResource, which means that if my flow is ==> db access -> arbitrary/gen stuff -> db access -> arb/gen stuff -> db access -> assert ==> how do I put all of this in a single DB txn?
22:08:48 <iqubic> The only function of type a -> Void I can think of is id
22:09:14 <ReinH> id is not of type a -> Void
22:09:18 <zomg> ReinH: well, as it simulates currency exchanges (just a curiosity), it would be Account USD and then it becomes Account EUR for example
22:09:21 <iqubic> :t id
22:09:22 <lambdabot> a -> a
22:09:28 <iqubic> a is Void
22:09:28 <zomg> ReinH: and it needs to keep track of what you have :)
22:09:30 <iqubic> Done
22:09:36 <ReinH> iqubic: no, a is universally quantified
22:09:38 <ReinH> it can't be Void
22:09:51 <iqubic> So that's a rank2 type?
22:09:53 <Cale> ReinH: It's okay, id may be supplied as an argument here
22:10:20 <iqubic> How do you make a function that always returns id?
22:10:23 <iqubic> :t absurd
22:10:25 <lambdabot> Void -> a
22:10:25 <Cale> lose id :: Decidable f => f Void
22:10:31 <ReinH> Ah, right.
22:10:52 <ReinH> zomg: why does it need to be mutable?
22:10:58 <iqubic> I have no idea how one would call lost in a legitimate program.
22:11:11 <ReinH> iqubic: did you read the stackoverflow I linked you?
22:11:11 <zomg> ReinH: how else would you store the type of currency you're holding?
22:11:26 <iqubic> ReinH: can you link it again?
22:11:32 <ReinH> zomg: Same as anything else?
22:11:40 <zomg> Sorry I'm not following :p
22:12:06 <ReinH> For example, you can pass it as an argument. Or you can use State which handles the passing as an argument for you.
22:12:13 <Cale> iqubic: Note that lose is sort of a funny kind of 'zero' for the 'sum' that is choose.
22:12:46 <zomg> ReinH: yeah, but if I have something like IORef (Account USD), then attempting to store an Account EUR into that IORef doesn't work
22:13:08 <ReinH> zomg: What I'm asking is, why are you using an IORef in the first place?
22:13:16 <zomg> and unless I'm being particularly dense today State would have the same issue
22:13:57 <ReinH> Why would State have the same issue? You can change the type of your state.
22:14:12 <ReinH> And if you're passing around info in the type, why are you storing a value at all?
22:14:51 <zomg> probably because I'm biting off more than I can chew :)
22:14:55 <iqubic> See, the most useful typeclasses in the extended funtor family are bifunctor and contravariant IMO
22:15:03 <ReinH> So Account is like data Account currency = Account Int where the currency is a phantom type?
22:15:19 <iqubic> I shold also look at the various things like choice and weak, and strong.
22:15:23 <iqubic> And see how those work
22:15:33 <ReinH> iqubic: https://stackoverflow.com/questions/32059754/are-there-useful-applications-for-the-divisible-type-class
22:15:41 <glguy> saurabhnanda: I don't think that QuickCheck's PropertyM is implemented in a way that will allow you to use it inside withResource
22:15:47 <zomg> ReinH: Yeah though it uses DataKinds so you can't just shove whatever into it
22:15:58 <glguy> saurabhnanda: without using it all the way on the outside of your test harness
22:16:26 <saurabhnanda> glguy: and if I do that, it would mean using a single DB connection for all tests... which means bye-bye to parallel tests?
22:16:31 <zomg> basically it's `Account SCurrency` with `Currency = USD | EUR` and `SCurrency a` is a GADT with `SUSD = USD` and `SEUR = EUR`
22:16:44 <iqubic> I stopped reading that when I decided that I didn't understand group
22:16:59 <saurabhnanda> glguy: so, if I have to dig further, this really is a QC problem, not a tasty problem, right?
22:17:51 <glguy> saurabhnanda: It's an interaction between withResource and PropertyM
22:18:24 <ReinH> zomg: Ok, why can't you use State?
22:18:52 <zomg> ReinH: probably because I'm an idiot :) I'll try it
22:19:03 <ReinH> You can change the type of the state.
22:19:20 <saurabhnanda> glguy: right, but as a testing framework, there needs to be a sane way to do DB-oriented tests, right?
22:19:29 <saurabhnanda> glguy: ^^ wrt QuickCheck.
22:19:43 <iqubic> ReinH: Can you tell me what Group a does in that SO question?
22:19:49 <glguy> saurabhnanda: That would be a question for the database library, database support wouldn't go into quickcheck
22:20:07 <ReinH> iqubic: Did you watch the video I also linked?
22:20:14 <saurabhnanda> glguy: it could be ANY resource that needs to be acquired once, at the beginning of the test, and released at the end.
22:20:19 <iqubic> You didn't link a video.
22:20:26 <ReinH> iqubic: Yes I did.
22:20:29 <iqubic> Just a PDF and a SO question.
22:20:42 <iqubic> I don't see the video link in my backlog
22:21:08 <ReinH> There are three links
22:21:27 <ReinH> The video link is with the pdf and SO links.
22:22:26 <iqubic> Let me watch that video now, and get back to you later.
22:25:23 <piyush-kurur> saurabhnanda: can't you generate the stuff out side and use it inside the ResourceT or whatever monad you want
22:25:45 <glguy> piyush-kurur: Ah, you're thinking of "boilerplate" :)
22:26:06 <piyush-kurur> glguy: yes ;-)
22:26:41 <piyush-kurur> after chatting with saurabhnanda I started to doubt my understanding of the word "boilerplate" ;-)
22:26:43 <glguy> piyush-kurur: What you described is the current solution
22:28:31 <piyush-kurur> saurabhnanda: is it true what glguy just said. You already have a solution along that line
22:28:33 <piyush-kurur> ?
22:28:54 <saurabhnanda> piyush-kurur: the DB code and the arb/gen code are required to interleave. because the result of what is fetched from the DB decides what happens next.
22:29:20 <piyush-kurur> why should that be a problem
22:29:43 <piyush-kurur> unless the arbitrary value that you generate some how depends on the DB value, in which case it is not arbitrary at all
22:29:44 <saurabhnanda> piyush-kurur: because all DB access cannot be in the same DB txn because of the infamous boilerplate prblem.
22:30:27 <saurabhnanda> ?! the generation of the arbitrary value is guided by the preceding DB result.
22:30:27 <lambdabot> Maybe you meant: v @ ? .
22:30:42 <piyush-kurur> saurabhnanda: in what way ?
22:30:58 <saurabhnanda> does it really matter? I can give you an even simpler example.
22:31:17 <piyush-kurur> simpler example is always good
22:31:21 <saurabhnanda> in the same DB txn, create a DB table, do your testing, drop the DB table
22:31:23 <geekosaur> if you need an "Arbitrary" that is guided by something else, it is not an Arbitrary and QuickCheck is the wrong tool
22:31:56 <piyush-kurur> geekosaur: that is what I told him
22:33:05 <saurabhnanda> just go for the simpler example.... in the test, **in the same DB txn**: generate a table, insert 100 arbitrary rows, read them back, check that roundripping is fine, drop the table, end the test.
22:33:10 <iqubic> I have two Ed Kmett videos in my watch list
22:33:29 <geekosaur> iqubic, only two? :)
22:33:34 <piyush-kurur> saurabhnanda: why not write a function foo x = runDB $ do cread db; test with x; delete db
22:33:40 <piyush-kurur> and then test foo with arbitrary x
22:33:45 <iqubic> geekosaur: currently only two, yes
22:33:45 <geekosaur> saurabhnanda, yes, that's the kind of test that QuickCheck is *not* suitable for
22:34:14 <geekosaur> although you might be able to use its Arbitrary to generate values to be used in a different test harness
22:35:18 <saurabhnanda> geekosaur: hmmm... I find that hard to accept. if QC was intended to be just an arbitrary data generation tool, why have the ability to do monadic IO at all via the Test.QuickCheck.Monadic module?
22:35:41 <geekosaur> because sometimes you want to do QC's thing in a monadic context
22:35:50 <saurabhnanda> so, right now the only solution is to use it as a dump arbitrary generator
22:35:52 <saurabhnanda> *dumb
22:36:01 <geekosaur> but this is not the same as the monadic interface turning QC into a general test engine
22:36:38 <saurabhnanda> So, an HUnit test, which uses QC for generating arbitrary data internally?
22:36:46 <geekosaur> there has been talk of splitting the Arbitrary stuff into a separate package, but I don't think anything has ever been done in that direction
22:37:11 <geekosaur> because yes, sometimes you'd like Arbitrary without the rest of QC
22:37:25 <piyush-kurur> saurabhnanda: why not generate it outside as I showed you
22:37:56 <saurabhnanda> piyush-kurur: a better flow would be to wrap QC arb generation INSIDE hunit... which gives you complete control.
22:38:40 <saurabhnanda> piyush-kurur: start db txn; create table; 100 times do DB roundtriping (with the help of QC to generate the arbitrary row); drop table; end txn
22:40:19 <saurabhnanda> geekosaur: is that what you're suggesting ^^
22:40:35 <geekosaur> pretty much, yes
22:41:22 <saurabhnanda> okay... let me try that.. and also post on quickcheck Github to see if there is really no better way.
22:42:33 <geekosaur> btw the monadic QC interface is relatively new and did not exist for a long time specifically because most times you want to do tests in e.g. IO QC is the wrong tool
22:55:53 <tdammers> oh wow, the money-precision discussion still ongoing?
22:56:02 <iqubic> Looks like it.
22:56:05 <tdammers> meh
22:56:16 <iqubic> It's been going on for the past half hour.
22:56:38 <tdammers> oh no, I participated yesterday, it's been on for at least 12 hours
22:57:11 <tdammers> could have written a working solution by now, just pick one of the perfectly fine proposed solutions and run with it vOv
22:59:08 <iqubic> Was it your problem intitially?
22:59:59 <zomg> ReinH: ok I think state would work but I'm falling deeper and deeper into the pit of "all these types go over my head" =)
23:00:39 <iqubic> zomg: Just use a lens, and that'll be that.
23:00:47 <iqubic> Or rather, just make a lens
23:00:50 <zomg> lol I wish it was that simple
23:01:20 <zomg> I mean I can throw away my fancy datakinds stuff, I mean that's how the program worked to begin with
23:01:49 <zomg> but I wanted to see if I could add certain additional constraints... which seems to be basically shooting myself in the foot because I don't seem to have a sufficiently advanced understanding of all of it
23:02:13 <iqubic> Don't shoot yourself in the foot.
23:03:03 <_sras_> is there a version of "mapMaybeM" that stops as soon as it gets the first Nothing value?
23:06:53 <iqubic> :t some
23:06:54 <lambdabot> Alternative f => f a -> f [a]
23:06:57 <iqubic> :t many
23:06:59 <lambdabot> Alternative f => f a -> f [a]
23:09:56 <iqubic> :t mapMaybeM
23:09:57 <lambdabot> error:
23:09:57 <lambdabot>     • Variable not in scope: mapMaybeM
23:09:57 <lambdabot>     • Perhaps you meant one of these:
23:10:07 <iqubic> What does mapMaybeM do?
23:10:39 <iqubic> or what should it do?
23:11:25 <pacak> mapMaybe + sequence
23:11:27 <pacak> I think
23:11:47 <iqubic> Oh.
23:12:13 <iqubic> mapMaybeM f xs = catMaybes <$> mapM f xs
23:12:34 <iqubic> That's what is it does.
23:13:01 <iqubic> :t let mapMaybeM f xs = catMaybes <$> mapM f xs in mapMaybeM
23:13:02 <lambdabot> Monad f => (a1 -> f (Maybe a)) -> [a1] -> f [a]
23:14:20 <pacak> That operates on all Just values. How about stopping at first Nothing?
23:14:22 <hjulle> Why can you not declare a class instance using DataKinds with Symbol or Nat from GHC.TypeLits without enabling FlexibleInstances? Example: "class A (n :: Nat); instance A 1" gives error, but seems like a very concrete type to me.
23:15:39 <_sras_> iqubic:  mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b] Source #
23:18:02 <glguy> hjulle: I suppose technically it's right, 1 isn't a *type constructor*, but the fact that you get a warning is probably just an oversight, 1 satisfies the spirit of the restriction
23:18:40 <iqubic> pacak: What I showed was the official implementation of mapMaybeM
23:18:59 <iqubic> not the version _sras_ wanted
23:21:57 <glguy> hjulle: File an issue?
23:22:47 <glguy> hjulle: If you do, could you mention the same about Symbol literals?
23:34:55 <zomg> Hm is there any good example projects or good material to better understand the more advanced type concepts.. datakinds, gadts, etc.
23:35:33 <cocreature> zomg: richard eisenberg’s lambdaconf talk on GADTs is very good imho
23:35:50 <cocreature> zomg: https://www.youtube.com/watch?v=6snteFntvjM
23:36:01 <zomg> thanks, I'll check it out
23:36:56 <zomg> adding all these additional constraints coming from this type trickery I'm attempting seems to just... infect every piece of code it touches
23:37:18 <zomg> causing a cascade of errors that confuse me way too much =)
23:37:52 <cocreature> zomg: if you’re looking for a library that uses some of these advanced concepts, servant is a pretty good example
23:38:25 <cocreature> zomg: https://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/ explains how you can implement something like that
23:39:10 <zomg> oh that looks pretty interesting as well
23:51:52 <rabbi1> Hi all, how all #LazyProgrammers doing today?  
23:52:39 <jared-w> just finishing up my paper for quantum computing
23:53:11 <jared-w> Probably should've started writing it a bit earlier than, say, 3 hours before the deadline...
23:53:12 <pacak> rabbi1: Just finished writing a piece of javascript O_o
23:56:19 <iqubic> :t uncurry
23:56:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:58:40 <saurabhn_> is this a bug, or is my understanding about legal text values incorrect -- https://github.com/phadej/qc-instances/issues/9
23:58:41 <iqubic> :t ap
23:58:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:58:59 <iqubic> :t (<*>)
23:59:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
