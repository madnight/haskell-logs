00:00:44 <halogenandtoast> still figuring out cursors, trying to simplify my code here: https://gist.github.com/halogenandtoast/4285ebaaa39689cbb7f66b94f231f6ea
00:00:50 <halogenandtoast> this time I've included the full context
00:01:41 <cocreature> halogenandtoast: can you please make the minimal example self-contained? I don’t want to install dependencies that are completely irrelevant to the code I’m actually trying to look at
00:02:01 <halogenandtoast> sure I'll try to do that
00:03:28 <cocreature> also I’m not sure what I should be looking at. the code in the comment or the one outside?
00:03:35 <cocreature> the error message seems to be for the one in the comment
00:04:10 <halogenandtoast> cocreature: sorry yes the error is for the comment
00:04:14 <halogenandtoast> in my attempt to clean it up
00:06:21 <cocreature> the problem is probably that you are defining ids as (fromDocument xml $/ element "id") >=> attribute "id" whereas it should be fromDocument xml $/ (element "id" >=> attribute "id")
00:07:06 <halogenandtoast> cocreature: update gist for minimal imports
00:08:58 <halogenandtoast> :updated
00:09:56 <halogenandtoast> but yeah I see what you mean
00:10:07 <halogenandtoast> the axis isn't on item, it's on id
00:10:53 <cocreature> halogenandtoast: http://lpaste.net/356406 might work (at least it typechecks)
00:12:25 <cocreature> halogenandtoast: fromDocument xml $/ element "id" will give you a list of cursors but >=> expects an axis on the left hand side
00:13:15 <halogenandtoast> cocreature: that seems to work, I think I need to spend more time understanding the types of xml-conduit
00:13:24 <halogenandtoast> I think I understand what you are saying
00:13:45 <halogenandtoast> basically if I understand right (>=>) has higher precedence than ($/)
00:14:23 <halogenandtoast> so the types work there, but when I split I have the wrong types (a list of cursors instead of an axis)
00:14:42 <cocreature> halogenandtoast: precedence does not matter here. by defining "items" separately you are basically wrapping the expression in parenthesis
00:15:09 <cocreature> it’s like "let x = 1 + 1 in x * 2"
00:15:15 <cocreature> that is equivalent to (1 + 1) * 2
00:15:20 <cocreature> even if + has a lower precedence than *
00:15:54 <halogenandtoast> right, I'm not debating that
00:15:58 <halogenandtoast> I was more or less commenting on
00:15:59 <halogenandtoast> --   let ids = fromDocument xml $/ element "item" >=> attribute "id"
00:16:09 <halogenandtoast> the element "item" >=> attribute "id" part happens first
00:16:25 <halogenandtoast> whereas I was thinking the $/ part happened first
00:16:33 <cocreature> ah right
00:16:37 <halogenandtoast> which led to my mistake
00:17:28 <EvanR> technical question... in this rule for "default pattern" of untyped lambda calculus... does it literally mean the default alternative can be anywhere in the list of alternatives, not just at the end
00:17:31 <halogenandtoast> thanks so much for you help cocreature 
00:17:34 <EvanR> http://i.imgur.com/zsS04CX.png
00:17:46 <cocreature> also it might be helpful to realize that Axis is not specific to xml-conduit. it’s just a function "Cursor -> [Cursor]" so >=> is kleisli composition for the list monad
00:17:50 <halogenandtoast> every day I'm getting more and more comfortable and understanding a lot more
00:18:10 <halogenandtoast> cocreature: yeah I had read about that somewhere
00:18:23 <halogenandtoast> the word kleisli is currently in the unknown territory
00:18:27 <EvanR> come to think of it... does default: in C switch have to go at the end necessarily
00:19:29 <cocreature> halogenandtoast: f >=> g is just "\x -> concatMap g (f x)" for lists
00:19:50 <ventonegro> EvanR: If it doesn't everything below is dead code
00:20:00 <cocreature> or "\x -> g =<< (f x)" for arbitrary monads
00:20:19 <EvanR> thats what i thought, same with _ -> foo in haskell
00:20:37 <ventonegro> Sorry, I am wrong, only if you put a `break`
00:20:45 <EvanR> well right
00:21:08 <ventonegro> So a `default` in the middle of a `switch` is a kind of "run this for all cases below"
00:21:13 <EvanR> so as written... does this rule say that default could go anywhere and works retroactively
00:21:50 <halogenandtoast> cocreature: it's something I will need to play around with more to understand.
00:22:07 <halogenandtoast> This was the first time I've used >=>
00:22:08 <ski> EvanR : without more context, that's what i would guess ..
00:22:16 <halogenandtoast> once I see it a few more times I'm sure I'll get it
00:22:20 <ski> (is this from dependent Haskell ?)
00:22:44 <EvanR> yeah
00:22:53 <EvanR> page 131
00:23:34 <ventonegro> Is there a book on dependent types in Haskell?
00:23:35 <nshepperd_> EvanR: seems valid to put it anywhere https://stackoverflow.com/questions/3110088/switch-statement-must-default-be-the-last-case
00:23:59 <EvanR> yeah i remember the answer in C now
00:24:21 <EvanR> ventonegro: http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
00:24:25 <EvanR> essentially yes :)
00:24:40 <ventonegro> EvanR: Cool!
00:25:05 <ventonegro> I guess I have something to read now after the Idris book
00:25:38 <EvanR> im implementing this untyped lambda calculus, though without the parts specific to dependent haskell
00:26:46 <ventonegro> Ah, it's a book about implementing it, not using it
00:27:01 <EvanR> e := a | H | e y | case e of alts | lam e | fix e
00:27:05 <ventonegro> Out of my reach for now, I guess
00:27:23 <EvanR> there are several sections of using dependent types, and on other features of haskell
00:27:48 <ventonegro> I'll try to read as far as I can :)
00:27:53 <EvanR> i do recommend that part if youre currently in the idris book, to see what it would be like in haskell
00:28:01 <c_wraith> don't feel bad about skipping parts of it, either.
00:28:25 <c_wraith> in fact, in general with things written as research papers, don't feel bad about skipping parts.  you can always go back later.
00:28:45 <ventonegro> c_wraith: that's good advice
00:29:53 <c_wraith> reading research papers is a skill that takes practice, funny as that sounds.  I'm way out of practice right now, so I need to scan anything a bunch of times before I feel comfortable trying to get the details.
00:41:05 <ski> EvanR : section 5.6.5.3, p. 98 and figure 5.6, p. 94 mentions default alternatives
00:42:35 <EvanR> im making it shortcircuit immediately
00:43:05 <EvanR> which would not make a difference if a compiler always put the default at the en
00:43:06 <ski> it doesn't seem to imply anything about order, so i assume a default alternative can appear anywhere among the alternatives
01:08:03 <EvanR> ski: on page 82... it says "if i have a value of type Tuple Double... then i dont know the Int the Char or the Double. These are the existentials"
01:08:17 <EvanR> this seems odd to me at first glance
01:08:42 <EvanR> is this from the perspective of the type checker or
01:09:20 <Kristjan55555> Hello! Hot 33 year old male from viljandi, estonia searching for husband, send me your cunt pictures first! Tel 37253902210 email:  kristjan55555@mail.ee. I am waiting.....
01:12:49 --- mode: ChanServ set +o Cale
01:12:53 --- mode: Cale set +b *!*@82.131.38.122.cable.starman.ee
01:13:01 --- mode: Cale set -o Cale
01:13:07 <Axman6> Cale++
01:13:31 <Cale> EvanR: which book?
01:13:43 <EvanR> eisenberg thesis
01:14:10 <EvanR> yeah i see "existential" is getting a weird meaning here thoughout the section
01:14:50 <Cale> Well, sort of weird, but not really weird.
01:15:13 <Cale> They're existentially quantified *values* rather than existentially quantified types
01:16:44 <Cale> i.e. if you have a value t of type Tuple Double, then *there exists* x :: Int, y :: Char and z :: Double such that t = MkTuple x y z
01:18:00 <EvanR> and and normally youd expect to be able to deconstruct it and get the x y and z
01:18:21 <Cale> and you can
01:18:44 <EvanR> ok somehow existential gained some connotation of hiding
01:18:52 <EvanR> which isnt relevant here
01:20:55 <Cale> Yeah, when there's an existentially quantified type, then you sort of get to "find out" which type it is when you unpack the constructor, but Haskell doesn't really have any way of doing anything with that information (there's no type case) -- so it might as well be hidden.
01:21:40 <mniip> EvanR, he specifically defines what existential is
01:22:12 <mniip> #page=97
01:22:18 <Cale> (and of course, in the implementation, no runtime type information is actually stored unless you use something like Typeable)
01:22:51 <mniip> Cale, in context of the thesis that's just not tue
01:22:52 <mniip> true
01:23:13 <EvanR> erm well im on page 82
01:23:24 <mniip> it is page 82
01:23:27 <mniip> but 97 in the pdf
01:23:38 <EvanR> reading the paragraph of "existentials" (a telescope of existential bound variables)
01:23:39 <mniip> hence I explicitly used the anchor notation
01:23:56 <EvanR> existentially bound variables
01:24:10 <mniip> ". In this formulation, the term existential also includes what would normally be considered term-level arguments."
01:24:11 <EvanR> i know this paragraph exists, and my remark was "i dont get it"
01:24:25 <mniip> it's useful
01:24:31 <mniip> it generalizes well
01:25:03 <EvanR> is this specifically arguments to constructors
01:25:17 <EvanR> would you say arguments to functions are universally quantified?
01:25:33 <mniip> erm no?
01:25:34 <balor> I'm reading code that uses `sconcat` which I thought was in Data.Semigroup, but hackage suggests not (http://hackage.haskell.org/package/Semigroup-0.0.7/docs/Data-Semigroup.html). ghci states that the type is `sconcat :: Semigroup a => NonEmpty a -> a`. How can I query the module in which `sconcat` is defined?
01:25:38 <EvanR> well
01:25:46 <mniip> consider for example
01:25:49 <EvanR> sorry lost
01:26:25 <mniip> data Foo where Foo :: forall a. Foo
01:26:44 <mniip> when pattern matching on Foo, you unpack an existential type variable a
01:26:44 <EvanR> mk
01:26:56 <Cale> mniip: Oh, well, yes. In the context of that thesis, I imagine that existentially quantified types might very well be carried around at runtime.
01:27:03 <mniip> a similar thing can be said about
01:27:29 <mniip> data Foo where Foo :: (a :: k) -> Foo
01:27:42 <mniip> a is an existential term variable
01:28:04 <Cale> balor: Wrong semigroup package, you want the one called 'semigroups'
01:28:10 <mniip> or something along these lines
01:28:20 <EvanR> what does the binder for k look like
01:28:38 <mniip> doesn't really matter
01:28:41 <Cale> ... the docs seem broken for the last couple releases ...
01:28:47 <Cale> http://hackage.haskell.org/package/semigroups-0.18/docs/Data-Semigroup.html
01:28:50 <EvanR> what would a universal look like
01:29:16 <Cale> Well, it does matter...
01:29:22 <balor> Cale, thanks.
01:30:08 <mniip> data Foo a where Foo :: Foo a
01:30:08 <EvanR> yes he does mention passing types around at runtime, instead of TypeReps for the same purpose
01:30:11 <mniip> a is a universal
01:31:17 <mniip> I do wonder what he proposes to do with lifting primitive types/functions
01:31:42 <mniip> if that is somehow resolved I'd say it's just prfect
01:31:48 <jchia1> Is it possible to pattern-match on Seq like on a list?
01:32:15 <jchia1> Is that what ViewL & ViewR are for?
01:32:32 <EvanR> yes thats what its for
01:32:39 <jchia1> thanks
01:32:48 <EvanR> check out view patterns too, for extra sugar
01:40:46 <merijn> Anyone know if jfischoff hangs out here with any frequency?
01:41:05 <ski> EvanR : i see. `MkEx :: forall a b. b -> a -> Ex a' is equivalent to `forall a. (exists b. b) -> a -> Ex a' (also in plain Haskell with `ExistentialQuantification'), so the `b' bound by `forall b.' (over result type) alt. `exists b.' (over argument type) is what they refer to as an "existential" (even if one may not be able to use the `exists' formulation without uncurrying)
01:41:42 <ski> EvanR : otoh, `MkTuple :: forall a. Int -> Char -> a -> Tuple a' basically means `MkTuple :: forall a. pi (n :: Int) -> pi (c :: Char) -> pi (x :: a) -> Tuple a'. by a similar argument, `n',`c',`x' here are considered "existentials" in this sense
01:44:10 <EvanR> whats the diff between the a and b in forall a b . ....
01:44:27 <EvanR> simply that b is second?
01:44:33 <ski> they are unpacked by pattern-matching, similarly to how the implicit type argument `b' to `MkEx' is unpacked by pattern-matching
01:44:48 <ski> no, simply that `b' doesn't occur in the result type of the data constructor
01:45:03 <EvanR> o_O
01:45:13 <ski> (just like `n',`c',`x' doesn't occur in the result type of `MkTuple')
01:45:31 <EvanR> so by looking at the type of the value, we can only know a
01:45:43 <ski> right
01:46:07 <EvanR> now it makes sense from a "what we know, what we dont know" perspective again
01:46:16 <EvanR> rather than quantification
01:47:07 <ski> from the POV of the type-checker, `b' will be an unknown (a skolem) after the match. similarly with `n',`c',`x', if we match (using normal Haskell syntax, for simplicity) on `MkTuple n c x' (`a' being an implicit argument, so isn't shown explicitly in the pattern)
01:48:06 <ski> i think i might prefer referring to their "existentials" as "skolems"
01:49:02 <ski> (and instead of "universals", "metavariables" / "placeholders" / "logic variables" ? hmm)
01:50:02 <EvanR> "universals" are always irrelevant and erased,  i think it says
01:50:30 <EvanR> the connection between that and placeholders, logic variables, and "universal" eludes me
01:50:33 <lamefun> can I derive typeable automatically for every single type?
01:50:40 <ski> (in any case, in terms of logic programming, skolems are generated both by existentially quantified clauses and universally quantified goals, while logic variables are generated by universally quantified clauses and existentially quantified goals)
01:51:02 <EvanR> clauses and goals eh
01:51:14 <merijn> EvanR: *all* type variables are erased, despite being explicit in Core
01:51:20 <lamefun> I mean, why would I not derive Typeable for every type?
01:51:35 <merijn> lamefun: Because you want to stop people from doing type casing?
01:51:48 <merijn> Because type-case is bad, mmm-kay
01:51:49 <EvanR> i have a feeling existentials are not erased all the time in dependent haskell
01:51:50 <lamefun> what is type casing?
01:51:58 <EvanR> and they are literally type-casing :)
01:52:21 <EvanR> to implement type families at least
01:53:32 <lamefun> What is type casing and why is it bad?
01:53:48 <merijn> lamefun: type-casing is "instance of" checks
01:54:12 <merijn> lamefun: It's bad because it breaks the basis of "free theorems"
01:54:26 <merijn> lamefun: You know how you know exactly what "id :: a -> a" from the type?
01:54:30 <EvanR> the uses of type case in many languages is on problems which have a much better solution
01:54:46 <merijn> i.e. it "must" return it's input (or undefined, but let's assume a total language for now)
01:54:50 <EvanR> haskells type families dont count, because haskell rocks
01:55:04 <merijn> lamefun: Once you have "Typeable a => a -> a" you can't tell shit anymore about what it does
01:55:14 <merijn> Because it can do all sorts of random stuff depending on the input type
01:55:43 <merijn> EvanR: It's not the existence of better solutions. It's the fact that free theorems don't hold in the presence of typecase
01:57:08 <lamefun> merijn: then I simply won't put (Typeable a) in the list of conditions for my function and it won't affect it.
01:58:17 <merijn> lamefun: Sure, but maybe you need to restrict people from doing that for some type
01:58:17 <jakub__> Is there a lifted (%~) somewhere in Lens?
01:58:55 <EvanR> there are no free theorems anyway in other languages
01:59:16 <merijn> EvanR: "In the other mainstream languages I'm thinking" :p
02:00:02 <lamefun> For, like, 0.01% of all my types?
02:00:40 <lamefun> Is there some real-life example?
02:00:57 <jakub__> in other words, is there something like: Monad m => Setter a b s t -> (a -> m b) -> s -> m t ?
02:00:58 <merijn> Well you asked for "a" reason :)
02:01:06 <EvanR> Typeable a => a -> IO a
02:01:37 <EvanR> Typeable a => a -> IO EnterpriseSolution
02:01:58 <Mortomes|Work> EnterpriseSolutionBean
02:02:15 <ski> EvanR : clauses and goals have opposite polarity. clauses are assumed. goals are attempted to be proven
02:02:18 <ski> EvanR : the clause `forall src next dst. Path src dst <- (Edge src next,Path next dst)' means the same as `forall src dst. Path src dst <- exists next. (Edge src next,Path next dst)', regardless of whether `next' is universally quantified over the clause, or existentially over the goal body of it -- in either case it'll be a logic variable
02:03:14 <EvanR> cool
02:03:34 <lamefun> How would Typeable a => a -> IO EnterpriseSolution even work?
02:03:50 <EvanR> it begins by doing typeOf
02:04:51 <ski> (you could consider this as the (uncurried) `Cons' constructor of a "list" datatype `Path src dst' encoding proofs that there's a chain of `Edge's from `src' to `dst'. `Nil' would be the base case of the recursion : `forall vert. Path vert vert')
02:04:52 <lamefun> Or rathere, what does it even do?
02:05:20 <EvanR> right
02:05:55 <EvanR> whats the connect between that and the variables occurring during type checking
02:06:44 <lamefun> I mean, this bothers me: http://lpaste.net/5964547918634418176
02:06:56 <lamefun> All of that for a 3-value enumeration.
02:07:19 <ski> anyway, `forall's in Haskell types mean different things (to the implementor alternatively caller of an operation of said type), depending on whether it's in a result type (possibly the whole type), or an argument type. or (better), whether it's reached by following an even or odd number of `->'s to the left
02:07:27 <ski> and similarly with `exists'
02:07:46 <merijn> lamefun: I honestly wouldn't bother with: Typeable, Data, Generic, Hashable, Read, and NFData
02:07:55 <merijn> lamefun: I'd only add those if I actually need them
02:08:16 <ski> the term "skolem" refers to the type variable being an opaque unknown, as when unpacking an existential, but also as when defining a polymorphic operation
02:08:18 <merijn> So just Eq, Ord, Enum, Bounded, and Show
02:08:18 <EvanR> we need -XDeriveEveryClass
02:09:38 <EvanR> ski: totally opaque or something we can discover the identity of later
02:09:38 <ski> (while placeholder / metavariable / logic variable would apply when a polymorphic operation is used, as well as when an existential is packaged -- namely it refers to that we can instantiate it however we like)
02:10:28 <EvanR> wow ... two totally different kinds of variables!
02:10:54 <EvanR> but not really, its about how they are introduced
02:11:01 <EvanR> free variables arent really either way
02:11:26 <lamefun> EvanR: -XDerivingFamilies --- eg. deriving family Enumeration (Eq, Ord, Enum, Bounded, Read, Show, Typeable, Data, Generic, Hashable, NFData)
02:11:28 <ski> EvanR : prima facie, totally opaque. however, we can always *assume* extra information about a skolem (such as it being equal to something specific). which is what GADT matching does. matching adds extra equality assumptions
02:11:41 <lamefun> then data Answer = Yes | No | Uncertain deriving (Enumeration)
02:11:56 <lamefun> that'd be more useful
02:12:01 <lamefun> or a preprocessor like in C++
02:12:02 <EvanR> forall a . foo(a), we can choose whatever and substitute it. exists a . foo(a), a is already something and you can only move it around
02:12:23 <lamefun> C++ preprocessor = rocks!
02:12:46 <EvanR> its identity (?) its referent (?) its interpretation has already been decided
02:13:15 <EvanR> lamefun: well, you can use TH to do that, or literally the CPP
02:13:25 <ski> (but as always, those assumptions can't be conjured from nothing, they must come from some place. such as GADT. or an explicit equality constraint to the left of `=>'. just as we can always introduce a new (value) variable of whatever type we like .. but we must bind it somewhere, with `\' or `let',&c.)
02:15:43 <ski> EvanR : in terms of logic programming, the skolem / logic variable distinction is a run-time distinction. syntactically, there's just variables in the program text. in Haskell, this "run-time" happens when type-checking, but still there's syntactically speaking only plain variables
02:16:21 <lamefun> is there a TH package with common deriving cases?
02:16:41 <merijn> lamefun: Warning: TH will rather drastically slowdown compilation
02:17:16 <ski> so, yeah "but not really, its about how they are introduced" -- it's about how you can operate with the type variables, depending on whether they're bound by `forall' or `exists' (the real one), and at which polarity in a type signature/qascription the quantifier appears
02:17:23 <merijn> lamefun: Do you really need all those instances, though?
02:17:57 <lamefun> Better question: why would I not derive those instances?
02:18:28 <ski> EvanR : yes, but with `(forall a. foo(a)) -> ...' resp. `(exists a. foo(a)) -> ...', it's the opposite
02:18:59 <merijn> lamefun: Well, you're complaining it's a hassle to derive all that, but you don't seem to have a reason to actually derive all that? So it seems like you're making things painful for yourself and then asking how to make it less painful
02:19:28 <ski> with the latter, we can choose whatever. with the former, `a' will be decided/instantiated (possibly multiple times), by the operation of said type that we use
02:22:33 <EvanR> yes the "who decides" perspective
02:23:19 <EvanR> lamefun: you add the instances youre going to need, which is probably Show, maybe Eq and Ord
02:23:33 <EvanR> later you can add more if you want to ship it to some third party
02:24:18 <EvanR> and if Show were a built in thing, we would even have deriving in many cases!
02:24:56 <merijn> Anyone bored and looking for a project? :p
02:25:27 <merijn> Someone should write a convenient wrapper around the sqlite3 commandline with proper multi-line editing and maybe syntax highlighting >.>
02:26:44 <ski> anyhow, one shouldn't forget that these interpretations of said four types is flipped around also if we consider the implementor of them, rather than the user
02:27:23 <lamefun> How slow is TH?
02:27:53 <jchia1> What's a reasonable way to convert a Vector (a, b) to a Map a b? What about "fromList . toList" -- should I be concerned about inefficient creation of an intermediate list?
02:28:05 <ski> (by which i mean that when you see `forall a. foo(a)' as the whole type, you shouldn't think "ok, i can choose `a' as i please". the implementor/user dichotomy is also relevant)
02:28:11 <lamefun> Are quasiquotes slow too?
02:28:59 <jchia1> Should I use "mconcat . map singleton" instead ?
02:33:12 <EvanR> annoyance #145, if module fails to check in ghci with :r, then you cant ask for the type of foldr :)
02:33:52 <merijn> EvanR: typed hole everything until it loads!
02:33:56 <Axman6> jchia1: the former should be fine - if you know the keys are ordered there are more efficient functions for creating the map in linear time
02:34:28 <jchia1> Axman6: What functions are they?
02:35:01 <Axman6> @hoogle Data.Map.Strict.fromDictinct
02:35:01 <merijn> fromListAsc and fromListDesc or something like that
02:35:01 <lambdabot> No results found
02:35:08 <Axman6> yeah
02:36:51 <jchia1> Thanks. It's fromAscList.
02:37:05 <jchia1> @hoogle Data.Map.Strict.fromAscList
02:37:05 <lambdabot> Data.Map.Strict fromAscList :: Eq k => [(k, a)] -> Map k a
02:37:06 <lambdabot> Data.Map.Strict.Internal fromAscList :: Eq k => [(k, a)] -> Map k a
02:37:06 <lambdabot> Data.Map.Strict fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
02:39:47 <ski> @hoogle fromDistinctAscList
02:39:47 <lambdabot> Data.IntMap.Internal fromDistinctAscList :: forall a . [(Key, a)] -> IntMap a
02:39:47 <lambdabot> Data.IntMap.Lazy fromDistinctAscList :: forall a . [(Key, a)] -> IntMap a
02:39:47 <lambdabot> Data.IntMap.Strict fromDistinctAscList :: [(Key, a)] -> IntMap a
02:48:06 <merijn> Anyone know if I can somehow get esqueleto to output the SQL it's producing?
04:48:39 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
04:48:39 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Wed Apr 05 12:49:54 2017]
04:53:31 <bollu> quchen, cocreature, merijn ty guys, parser works now :D
04:53:34 <Wizek> Asked my FreeBSD+stack+happy related question here too with more info: https://stackoverflow.com/questions/44698588/haskell-freebsd-stack-happy-what-can-one-do-if-a-build-tool-in-my-case-hap
04:55:32 <bollu> is there any library / module / something to make GHC STG output "prettier"?
04:55:38 <Unhammer> anyone got any idea why ghci panics when I run a function from a module that imports a module that defines foreign C functions? https://stackoverflow.com/questions/44696563/ghci-gives-ghc-panic-when-using-foreign-c-calls
04:57:06 <merijn> Unhammer: Not sure if this is the exact issue, but by default GHCi interprets loaded code and interpreted code can do FFI
04:57:14 <merijn> Unhammer: Try using -fobject-code to load compiled code
04:57:34 <merijn> @hackage ghc-core
04:57:34 <lambdabot> http://hackage.haskell.org/package/ghc-core
04:57:41 <merijn> bollu: There's that, but it's still not great
04:58:33 <merijn> ugh
04:58:42 <bollu> merijn that is for core, AFAIK? not STG?
04:58:48 <merijn> bollu: ah...hmmm
04:58:51 <merijn> Then I dunno
04:58:56 <merijn> argh
04:58:57 <bollu> OK, ty anyway
04:59:09 <merijn> Why do all the high level APIs for SQL suck? >.<
04:59:17 <bollu> quchen the GHC output is quite different from the paper :(
04:59:34 <bollu> quchen I am naive
04:59:40 <drdo> merijn: How so?
04:59:59 <bollu> quchen I thought this would be easy :P Should have known better -_-
05:00:14 <merijn> Any recommendations for high-level bindings to SQLite that aren't trash? Or should I just write SQL directly via, like, sqlite-simple
05:00:25 <bollu> merijn opaleye?
05:00:31 <merijn> bollu: Doesn't support SQLite
05:00:35 <bollu> ah :(
05:00:55 <bollu> merijn uhh. persistent?
05:00:59 <merijn> There's opaleye-sqlite, but it's defunct (I know, because I was the one planning to revive it)
05:01:08 <bollu> xD
05:01:09 <merijn> bollu: Persistent can't do joins and esqueleto is a fucking mess
05:01:19 <bollu> merijn what do you mean "can't do joins"?
05:01:30 <merijn> I'm using persistent + esqueleto right now, which is what prompts this frustration
05:01:31 <bollu> "The default type-safe persistent API does not support joins" oh wow
05:01:48 <merijn> bollu: Persisnt can only do, like select/update/delete/insert
05:02:09 <bollu> I see
05:02:36 <bollu> merijn but, like. if you want to work on multiple tables at a time, how do you do this without using a join?
05:02:49 <merijn> So I tried esqueleto (which works on top of persistent), but 1) the API is ridiculously confusing with all the type-classes, leading to nearly impossible to figure out type errors and 2) I still can't actually write what I need
05:03:11 <bollu> I see
05:03:48 <merijn> Because the way esqueleto's DSL works it's impossible to have a variable (i.e. runtime dependent) number of joins in a query. Their solution is to use implicit inner joins, but you can "implicit inner join" the same table multiple times, like I need
05:04:16 <cocreature> merijn: sqlite-simple :P
05:04:28 <merijn> cocreature: Like I said, that's what I'm considering now
05:04:49 <merijn> cocreature: I was just wondering if there was any reasonable high-level SQL API or whether they were all a mess
05:05:25 <merijn> cocreature: Although then I'd again have to implement my own streaming interface for select :\
05:05:35 <cocreature> it’s disappointing that all high-level SQL APIs seem to be very frustrating but I’m not  willing to write my own (which will also be shitty anyway) so I’ll stick to the *-simple interfaces
05:06:10 <merijn> opaleye looked promising, but like I said, the sqlite branch is dead and I don't have much time to revive it
05:08:29 <Cale> What we've been doing for now is using a mixture of postgresql-simple and groundhog
05:09:14 <Unhammer> merijn,  -fobject-code had no effect :(
05:09:23 <Cale> Many queries end up written in postgresql-simple, but at least we get some type safety for the simplest ones.
05:10:01 <merijn> Cale: How does groundhog compared to just sqlite-simple?
05:10:34 <merijn> My datatypes aren't all the complex or interesting, so I'm not sure how much value there is to be had from groundhog
05:11:57 <merijn> Apparently there's also
05:11:59 <merijn> @hackage selda
05:11:59 <lambdabot> http://hackage.haskell.org/package/selda
05:13:57 <Cale> merijn: groundhog works better if you don't have sum types
05:14:26 <Cale> merijn: It's basically just nice to know that some queries won't need checking for runtime syntax errors.
05:15:03 <Cale> also, it can do some simple migrations for you
05:16:27 <merijn> Cale: The problem is that, not only do I not really have sum types I really only have very basic "row of values" records
05:16:37 <merijn> So, I'm not mapping to any complex data structures
05:20:15 <merijn> :\
05:20:33 <merijn> I was really hoping to not have to rip out half my code and switch to something different
05:35:18 * Axman6 quites like hasql for simple DB stuff with Postgres
05:35:23 <Axman6> likes*
05:36:12 <Axman6> selda looks interesting, and I'll need to experiment with it at some point
05:38:33 <mschristiansen> Using servant I'm receiving a ByteString body
05:38:52 <mschristiansen> ReqBody '[JSON] BS.ByteString :> Post '[JSON] (Headers '[HeaderCookie] (Maybe User))
05:39:04 <mschristiansen> Should I still leave the content type as JSON?
05:39:20 <mschristiansen> Tried with 'Raw' but that's missing a mimeType
05:41:41 <mschristiansen> OctetStream seems like the right choic
05:41:55 <ertes-w> merijn: i have moved away from database abstractions entirely for that reason
05:42:12 <Axman6> I doubt you want ByteString as the type, considering you've said it's encoded as JSON (I don't think there is a FromJSON instance for ByteString)
05:42:26 <ertes-w> merijn: i'd just write a type class that abstracts the application's data logic, and then an implementation using sqlite-simple
05:42:26 <Axman6> yeah OctecStream is probably appropriate
05:42:35 <merijn> Cale: I just noticed persistent at least has the good grace to export rawSql, which seems mostly equivalent to sqlite-simple (Text instead of Query newtype and no named substitution), so I think I'll just use that
05:42:45 <Axman6> OctetStream*
05:43:21 <merijn> ertes-w: There is no "application data logic" 90% of my application is filtering and dumping information. Which is why I moved from plain text to SQLite for data storage in the first place
05:43:25 <ertes-w> merijn: tends to be more code, but you don't run into abstraction boundaries, and you can write a more domain-specific API…  as a bonus feature you can write an STM-based instance for testing
05:43:59 <Axman6> merijn: My experiences with persistent have lead me to not want to use it again, it has too much magic that locks you into only using persistent
05:44:08 <Cale> merijn: groundhog also has something for that, but postgresql-simple is nicer (and compatible)
05:44:09 <ertes-w> merijn: well, then you might just use sqlite-simple directly without any abstraction at all =)
05:44:12 <merijn> ertes-w: yeah...that's all fine and well for people who want "solid, production, industry applications". I just want to conveniently query my benchmark results
05:44:25 <Axman6> ertes-w: sounds like the free monads approach
05:44:47 <merijn> ertes-w: Well, in hindsight yes, but I already have all the code to read in the data using persistent, so throwing persistent away means reimplementing my schema from scratch
05:44:50 <ertes-w> Axman6: not at all…  it's literally just a type class with a bunch of associated types and data operations
05:44:57 <Cale> (I expect the other *-simple libraries to be similar)
05:44:59 <merijn> Cale: postgresql is absolutely out of the question
05:45:03 <mschristiansen> Axman: correct no FromJSON instance for ByteString, octet works, but then have to set correct content-type client side
05:45:43 <merijn> Axman6: Yeah, but there's not really anything else that gives you a quick/easy way to get a schema for your haskell types that I can use
05:45:46 <Cale> merijn: Yeah, sqlite-simple has a very similar interface to postgresql-simple
05:46:02 <merijn> Axman6: And if you do know something like that, please let me know :p
05:46:04 <Axman6> ertes-w: right, but the alternative to using a class is using free monads, describe your actions, and then choose your own interpreter
05:46:07 <Cale> I would expect it'll be nicer than anything persistent/groundhog provide for writing raw queries.
05:46:33 <Axman6> merijn: I'vepersonally decided that's something that's not actually worth it in the long run.
05:46:53 <merijn> Cale: Well, persistent's rawSql appears to be literally sqlite-simple's "query", but losing named substitution and adding convenient sugar for extracting persistent datatypes
05:47:02 <ertes-w> Axman6: good idea actually…  i should look into that
05:47:05 <Axman6> I've become a fan of defining the schema in SQL, and write the SQL queries to do what's need
05:47:06 <Axman6> ed
05:47:09 <merijn> Axman6: Yes, but sometimes your application doesn't have a long run :p
05:47:20 <Axman6> then all you need is SQL :P
05:47:29 <ertes-w> Axman6: although it has one major drawback: you would have to pass your regular application monad to FreeT
05:47:40 <merijn> This Selda stuff looks promising, though
05:47:41 <ertes-w> the class-based approach doesn't need a transformer…  it's just IO
05:47:48 <Axman6> ertes-w: use free monads all the way down! =)
05:48:17 <Axman6> (unless your code is computation heavy)
05:48:19 <Cale> Ryan is working on figuring out a way to use Conal's constrained categories package to turn ordinary Haskell code into database queries (with a strange-looking database)
05:48:22 <merijn> Seems similar to opaleye (which so far seems to have the most flexible data representation for projecting rows from your schema), but with a more flexible backend from the beginning
05:48:23 <ertes-w> Axman6: then i'd quickly find myself using freer, and that's not a great solution either =)
05:48:43 <Cale> We've run into a lot of situations where we have SQL code and Haskell code which do effectively the same thing
05:48:49 <Axman6> ertes-w: http://reasonablypolymorphic.com/dont-eff-it-up/#/title does a great job of showing the advantages of this approach
05:48:57 <Axman6> what's wrong with freer?
05:48:58 <Cale> and it will be interesting to use the same code to write both :)
05:50:12 <ertes-w> Axman6: i'm aware of the advantages, but it also comes at a price: little to no library integration, more difficult handling of stacked monads and even a measurable performance penalty
05:51:15 <ertes-w> the second point is particularly annoying, because i tend to use raw IO 90% of the time and only use transformers locally
05:51:26 <Cale> merijn: The thing about Opaleye which is kind of brutal is that you're forced to fill in all the types of the fields everywhere.
05:51:32 <ertes-w> do _; evalStateT _ _; _  -- like this
05:51:55 <Axman6> ertes-w: yeah that's not a style I see being used bery often
05:53:09 <ertes-w> Axman6: i used to have "application monads", but these days i no longer use them…  it's just functions and IO with monad transformers used only locally, where they make sense
05:54:51 <merijn> Cale: I haven't used it yet, so not sure
05:54:54 <ertes-w> "application monads" suffer from the same problem that, say, "singleton classes" in OO suffer from…  an application monad wides the scope of its effects to the entire application, and i found that that non-locality makes it much more difficult to reason about my code
05:55:11 <ertes-w> s/wides/widens/
05:55:20 <merijn> Cale: My main complaint with persistent is that it's basically impossible to do simple projections and joins in their model
05:56:44 <merijn> Cale: I wonder if it'd be nicer to simply wrap sqlite-simple with a slightly smarter API that does compile time schema checking. Although I suppose that requires defining your schema in Haskell too for the API to check, which sounds like it ends up being similar to opaleye/selda
05:57:43 <merijn> The way opaleye hardcodes it's postgres backend is kinda disappointing. The SQLite branch was basically a hard copy with fixes in it, rather than opaleye being parameterised over a backend that you can pass in. The seems to be the one thing Selda is doing right from the start
05:57:45 <AWizzArd> What are Phantom Types good for? I read about https://wiki.haskell.org/Smart_constructors and saw that they allow for more type safety.
05:57:48 <AWizzArd> However, in this example there were very long type signatures. If there are just a limited number of cases, like in the examples in the wiki, one could simply define a data type Four | Five | Six | Seven to represent the types, and one can do this without Phantom Types.
05:58:37 <ertes-w> AWizzArd: you can control instance selection through phantom types
05:59:22 <Cale> merijn: Does persistent not to projections? Projections are easy in groundhog, but joins are still impossible.
05:59:24 <merijn> AWizzArd: You're right that one could define a new custom type like that in the simplest case, but with the DataKinds extension you can actually prevent that
05:59:51 <merijn> Cale: Well all operations deal with PersistEntity (complete ADTs)
06:00:17 <Cale> s/to/do/
06:00:23 <Cale> ah, okay
06:00:25 <merijn> Cale: esqueleto adds joins and an EDSL for SQL on top which has a limited form of projections, but hot damn is it painful to use
06:00:55 <sproingie> AWizzArd: https://wiki.haskell.org/Phantom_type gives a more typical motivation for phantom types, namely encoding states.
06:01:02 <merijn> AWizzArd: The problem with the most basic phantom type "data Phantom a = Phantom" is that the type variable 'a' is inferred to have type '*', so it could be Int, Bool, etc.
06:01:36 <sproingie> just ignore the comment saying liftStringFn is exported, since it completely defeats the purpose of the example
06:01:39 <merijn> AWizzArd: With DataKinds we can actually introduce new kinds in haskell, so then we can do "data Phantom (a :: MyKind) = Phantom" and then only types which belong to the kind MyKind we defined are allowed
06:02:28 <merijn> Cale: With esqueleto all values are nested like 3 layers into different ADTs "SqlQuery (SqlExpr (Value Int), SqlExpr (Value Double))", etc.
06:02:56 <merijn> Cale: And you still can't do things like variable number of JOINs and, afaict you can even SELF JOIN more than once...
06:03:36 <ertes-w> haskelldb used to be a database abstraction i could be okay with…  it has none of that ORM nonsense, just plain relational algebra combinators
06:03:55 <ertes-w> but it seems to have gone unmaintained, and also i find it a bit too complex for what it does
06:04:12 <merijn> ertes-w: Except that haskelldb has ridiculously bad performance
06:04:20 <merijn> ertes-w: opaleye builds on top of haskelldb
06:04:24 <merijn> afaict
06:04:44 <merijn> (They have their own fork of the relational combinators from haskelldb, at least)
06:04:52 <ertes-w> merijn: ah
06:04:58 <ertes-w> but apparently it's postgres-only
06:05:06 * ertes-w needs sqlite most of the time
06:05:36 <merijn> ertes-w: Same here
06:05:57 <merijn> ertes-w: There was a SQLite branch and I plan to revive it at some point (unless Selda turns out better, then I'm dropping it)
06:06:11 <merijn> ertes-w: Have a look at Selda, it looks promising and does appear to have maintained SQLite support
06:06:50 <merijn> Anyway, I'm calling it a day.
06:07:56 <AWizzArd> merijn: Okay I see. This is then something that indeed sounds interesting.
06:10:00 <merijn> AWizzArd: Whenever you define a "data Foo = Bar | Baz" you're defining a type "Foo" and values "Bar" and "Baz". With DataKinds enabled you will *also* automatically define a *kind* "Foo" which has *types* "Bar" and "Baz"
06:11:24 <jchia_> optparse-application question: How do I concisely express a Parser String or ReadM String that rejects the empty string? Is there a function that allows me to easily tag on a filtering function?
06:11:53 <jchia_> Essentially, I want something like strOption that rejects the empty string.
06:12:34 <jchia_> 'optparse-applicative'
06:14:25 <ertes-w> "Products and joins: Of course, data can be drawn from multiple tables."
06:14:30 <lyxia> jchia_: maybeReader
06:15:01 <ertes-w> hahaha…  "of course" you can…  haskell database abstractions have sucked at that for years
06:15:15 <ttoe> A question regarding the ad (automatic differentiation): is it possible to define for example a function f x y = auto a*x + auto b*y^2, where a & b are global constants (Double) and get the derivative, without having to use all the 'auto's 
06:16:02 <merijn> jchia_: You can just define your own ReadM and use that
06:16:16 <ttoe> because as i see it, i have to define my functions twice, 1. for  actually solving them numerically and 2. to differentiate
06:16:38 <jchia_> merijn: Yeah, but I was hoping for something more concise without defining a new function.
06:17:14 <ertes-w> merijn: thanks for the suggestion, it does look interesting…  i'll take a closer look, but i'm already noticing the abstraction boundaries
06:17:42 <merijn> jchia_: Eh, it's just "option (str >>= guard . not . null)" :)
06:18:17 <merijn> strOption is just "option str" and str is ReadM, which is MonadPlus
06:18:45 <ertes-w> merijn: no sqlite-specific stuff (how do i turn on WAL?  how do i use FTS?), and i'm unable to find some basic operations (where is natural join?)
06:18:49 <merijn> Although I guess this one returns (), rather than String
06:19:14 <merijn> ertes-w: Selda is parameterised over backends, so there' selda-sqlite where I would expact WAL, etc.
06:19:23 <ertes-w> merijn: it's not there
06:19:35 <merijn> hmm, you're right
06:19:51 <merijn> ertes-w: But at least that's stuff that should be easy to patch/add there
06:20:36 <ertes-w> merijn: and that's exactly the kind of technical debt i want to avoid
06:20:52 <merijn> ertes-w: How is that technical debt?
06:21:18 <merijn> ertes-w: Technical debt is generally "knowingly taking a suboptimal path claiming to fix it up later", this is merely "unimplemented"
06:22:13 <ertes-w> merijn: you may be using a more specialised variant of the term
06:22:46 <ertes-w> ah no, it seems i'm using the wrong term
06:22:47 <merijn> ertes-w: The debt part comes from having to pay each time you make changes you have to pay interest (i.e. working around your hacks)
06:23:43 <ertes-w> yeah, sorry…  i believe the correct term for what i mean is Not Invented Here
06:25:41 <ertes-w> it's the kind of debt that makes you constantly push against the abstraction boundaries, while at the same time being careful not to burst through it
06:26:48 <ertes-w> or how i learned to stop worrying and love the SQL =)
06:34:35 <mclark1129> Is it possible to compose a functions that result in different Monads?
06:36:44 <lyxia> mclark1129: What do you mean
06:37:26 <mclark1129> well I'm basically chaining a several functions that result in an Either, because they may succeed or return error messages
06:37:31 <mclark1129> So Either [String] a
06:38:01 <mclark1129> The last one however needs to perform IO, and will also return success or failure, so it's value is IO (Either [String] a)
06:38:27 <mclark1129> let me try and list out the signatures
06:38:48 <mclark1129> f = M a -> M b
06:38:59 <mclark1129> g = b -> M c
06:39:09 <mclark1129> h = c -> IO (M d)
06:39:35 <mclark1129> so I can compose f and g with >=>
06:40:20 <mclark1129> but I have no idea how to tag my last function on, short of explicit pattern matching, or some custom transform function
06:41:46 <ertes-w> :t (pure .)
06:41:47 <lambdabot> Applicative f => (a1 -> a) -> a1 -> f a
06:41:49 <ertes-w> mclark1129: ^
06:42:09 <ertes-w> ah, no…  you can't actually use that
06:42:22 <ertes-w> i think you'll need ExceptT here
06:42:33 <mclark1129> :t ExceptT
06:42:34 <lambdabot> m (Either e a) -> ExceptT e m a
06:43:14 <ertes-w> :t (ExceptT .)
06:43:15 <lambdabot> (a1 -> m (Either e a)) -> a1 -> ExceptT e m a
06:43:21 <ertes-w> mclark1129: ^
06:43:51 <ertes-w> then you can compose with (>=>)
06:44:11 <mclark1129> so > => (ExceptT . h)?
06:44:18 <bno1> what happens if I don't initialise a field in a record an then try to use it?
06:44:26 <mclark1129> >=> (ExceptT . h) rather
06:44:28 <bno1> will it behave as if it was initialised as undefined?
06:44:42 <ertes-w> bno1: yes, unless it was a strict field, in which case GHC will reject your code
06:44:49 <bno1> ok
06:47:24 <Larmbr> hi, why this form is illegal: [1..3::Sum Integer]? Have to write it like [1,2,3::Sum Integer] 
06:49:12 <pacak> > [1..3 :: Sum Integer]
06:49:14 <lambdabot>  error:
06:49:14 <lambdabot>      • No instance for (Enum (Sum Integer))
06:49:14 <lambdabot>          arising from the arithmetic sequence ‘1 .. 3 :: Sum Integer’
06:49:30 <pacak> foo .. bar means "use Enum instance and iterate from foo to bar.
06:49:46 <pacak> As lambdabot noticed - there's no Enum instance for Sum Integer.
06:50:19 <pacak> [foo .. bar] that is, [] are part of the syntax.
06:50:47 <pacak> And [1,2,3] is a list and you specify that type of 3 is Sum Integer
06:50:53 <ertes-w> > coerce Sum [1..3]
06:50:55 <lambdabot>  error:
06:50:55 <lambdabot>      • Variable not in scope: coerce :: (a0 -> Sum a0) -> [Integer] -> t
06:50:56 <lambdabot>      • Perhaps you meant one of these:
06:51:06 <ertes-w> @let import Data.Coerce
06:51:07 <lambdabot>  .L.hs:82:1: error:
06:51:07 <lambdabot>      Data.Coerce: Can't be safely imported!
06:51:07 <lambdabot>      The module itself isn't safe.
06:51:18 <pacak> > map Sum [1..10]
06:51:19 <ertes-w> err…
06:51:20 <lambdabot>  [Sum {getSum = 1},Sum {getSum = 2},Sum {getSum = 3},Sum {getSum = 4},Sum {ge...
06:51:25 <ertes-w> that was wrong anyway =)
06:51:41 <pacak> > map Sum [1..3]
06:51:43 <lambdabot>  [Sum {getSum = 1},Sum {getSum = 2},Sum {getSum = 3}]
06:51:53 <pacak> > getSum $ foldMap sum [1..3]
06:51:55 <ertes-w> coerce ([1..3] :: [Integer]) :: [Sum Integer]
06:51:55 <lambdabot>  error:
06:51:55 <lambdabot>      • Could not deduce (Enum (t0 (Sum a)))
06:51:55 <lambdabot>        from the context: (Enum (t (Sum a)),
06:51:59 <pacak> > getSum $ foldMap Sum [1..3]
06:52:01 <lambdabot>  6
06:52:02 <ertes-w> Larmbr: ^ you can do that
06:52:20 <ertes-w> Larmbr: unlike (map Sum), 'coerce' is a no-op
06:52:47 <pacak> Larmbr: ^ or don't do that if you have no ideas what are you doing. But coerce is no-op indeed.
06:52:56 <ertes-w> pacak: why not?
06:53:44 <pacak> I'm trying to avoid using constructions I don't understand.
06:54:36 <ertes-w> think of coerce as "free conversion into and out of newtype wrappers"
06:54:55 <ertes-w> "including as part of data structures"
06:56:27 <cocreature> at least for some data structures :)
06:57:13 <pacak> ertes-w: coerce (Set Int) :: Set (Down Int)
06:57:22 <Larmbr> ertes-w, thx for the info.  The error msg dis give the answer
06:57:44 <cocreature> pacak: that doesn’t work because set declares its argument as nominal
06:57:55 <pacak> cocreature: I know
06:58:47 <pacak> Larmbr: Stick to stuff you understand. Keep learning new things.
07:00:30 <ertes-w> coerce is fine, even if you don't really understand it…  worst case is that GHC will reject your code, in which case you can still resort to algorithmic conversion
07:07:33 <rpasta42> hello
07:07:48 <rpasta42> i am having trouble with cabal on ubuntu. I'm trying to install "matrix" and "either" packages
07:08:21 <rpasta42> but it's giving errors. I tried un-installing ghc and re-installing cabal platform from scratch
07:08:24 <rpasta42> but I still get errors
07:08:47 <bbaren> rpasta42: Can you paste your errors at http://lpaste.net/new/haskell ?
07:09:28 <bbaren> Or just http://lpaste.net/ , since the path doesn’t seem to be working?
07:10:12 <rpasta42> lpaste didn't work, so I made a gist: https://gist.github.com/anonymous/3d7fd0df03dd8eeadcb4dfadb56c178a
07:11:38 <ski> mclark1129 : got it to work ?
07:12:04 <mclark1129> ski: Not yet, haven't had a chance to try
07:12:28 <rpasta42> I was installing haskell platform from apt-get? Should I try purging again and install a different method?
07:12:34 <rpasta42> maybe install cabal separately?
07:13:11 <geekosaur> what version of ghc did it get you? ubuntu tends to package ghc 7.6.3 which is kinda ancient
07:13:28 <rpasta42> 7.10.3
07:16:52 <Axman6> ubuntu isn't still shipping GHC 7.6 right? that's like shipping GCC 3.6
07:18:21 <rpasta42> yes it did :p
07:18:27 <rpasta42> i'm now trying the generic linux installer
07:18:44 <Axman6> D:
07:18:52 <sproingie> if you're not going with a distro package, you may as well just use stack
07:19:23 <rpasta42> ok, I'll look into it if the haskell-platform doesn't work this time
07:31:07 <bno1> try using stack
07:31:45 <bno1> it downloads the lates ghc version 
07:33:22 <bno1> oh, I didn't read the previous message
07:34:22 <dmwit> Clint: Currently unmaintained, but somebody just volunteered by email (is it you?).
07:34:57 <Clint> dmwit: not I
07:35:44 <dmwit> The github repo should at least build.
07:35:48 <dmwit> I think.
07:36:13 <shapr> what's unmaintained?
07:36:20 <dmwit> xmonad-extras
07:36:23 <shapr> oh
07:41:28 <ertes-w> i should turn some of my xmonad stuff into a library
07:42:03 <ertes-w> i have a variant of XMonad.Actions.Volume that uses the alsa-mixer library
07:42:27 <ertes-w> although i'm planning to rewrite (or extend?) it to use pulseaudio
07:43:05 <dmwit> ertes-w: https://github.com/xmonad/xmonad-extras/commit/e8525ebe8beac9ee9cb36f655c956ee08f9d3ead
07:43:45 <dmwit> Pulse support would be nice.
07:44:40 <ertes-w> yeah, pretty similar, except mine is a bit more lensy =)
07:44:43 * mekeor had totally forgotten about xmonad-extras
07:44:47 <ertes-w> and less complete
07:44:48 <ertes-w> https://github.com/esoeylemez/config/blob/master/myxmonad/MyXMonad/Audio.hs
07:49:21 <ongy> @hackage pulseaudio
07:49:22 <lambdabot> http://hackage.haskell.org/package/pulseaudio
07:49:43 <ongy> ertes-w: if you want to do pulse, I'm happy to work on this for support
07:51:14 <ertes-w> ongy: great, thanks!  i was going to use that library, but i don't know when i'll do it
07:51:50 <ertes-w> it would be really nice if there was a way to connect an xmonad window to its corresponding pulse application
07:51:58 <ertes-w> then it would be super-convenient
07:52:28 <Kristjan55555> Hello! Hot 33 year old male from viljandi, estonia searching for wife, send me your cunt pictures first! Tel 37253902210 email:  kristjan55555@mail.ee. I am waiting.....
07:52:30 <ertes-w> one pair of key bindings to raise/lower the global volume, and one for the currently focussed application
07:53:28 <dmwit> Yeah, I doubt you're going to be able to do that sanely.
07:53:40 <ertes-w> yeah, probably not
07:54:00 <ertes-w> perhaps it would be good enough to query which applications are currently producing/consuming audio and then change the volume of those
07:54:22 <dmwit> Yeah, I've thought about doing that a few times.
07:55:21 <dmwit> But honestly when I actually need to do fine-grained volume control hitting my pavucontrol keybinding is pretty quick and easy, and gives me complete control over the effect.
07:56:33 <ertes-w> but then pavucontrol is not really convenient itself
07:56:44 <ertes-w> and most of the time i'm controlling the active application anyway
07:56:46 <ongy> it's hard for all usecases/edgecases. But for applications that run local it could be possible. I'd have to dive into the pulse api to find out if we can get a pid associated with client streams...
07:57:09 <ertes-w> ongy: no need for a PID
07:57:16 <cocreature> ongy: you can
07:57:20 <ertes-w> pulse has its own notion of application
07:57:36 <cocreature> ertes-w: but how do you know which window the application belongs to?
07:57:56 <cocreature> ongy: at least via pacmd so probably also via the api
07:58:05 <ertes-w> cocreature: ah, no, i don't think that's a good idea
07:58:12 <sproingie> hm at least the spammer got the anatomy right this time
07:58:13 <dmwit> cocreature: There is a window property that programs can optionally set to indicate their pid.
07:58:22 <dmwit> Some programs even set it.
07:58:31 <cocreature> dmwit: right but then you’re back to the pid
07:58:52 <dmwit> No choice. X certainly doesn't understand pulse applications.
08:00:42 <ertes-w> it would be good enough, if pulse consistently understood X
08:00:46 <dmwit> Plus of course there's also the issue that the PID owning the window isn't necessarily the PID producing the audio associated with that window. e.g. if I run mplayer in my terminal, the window->pid map is probably going to give me urxvt's pid, not mplayer's
08:00:47 <sproingie> Lokathor: you around?  running the sample app in hexes, but only get a grey screen, no foreground
08:01:00 <ertes-w> but regardless, it's also good enough to check for currently active pulse applications
08:01:06 <ertes-w> and control the volume of those
08:01:10 <sproingie> dmwit: this is what process groups are for.  ideally.
08:01:16 <ertes-w> then there is no need to make the connection to X
08:01:20 <sproingie> tho in practice only shells seem to use them
08:01:24 <cocreature> ertes-w: that’s probably even better since something like mpd wouldn’t work otherwise
08:01:30 <ertes-w> cocreature: exactly
08:01:54 <ertes-w> neither would mpv, if you use it for audio
08:02:11 <Lokathor> sproingie, press some keys
08:02:12 <dmwit> ertes-w: It's better in some ways and worse in others. I wouldn't be able to mix multiple streams with that approach.
08:02:26 <Lokathor> sproingie, also i'm about to leave for work so i can't offer much more help XD
08:02:29 <ertes-w> dmwit: i guess that's when pavucontrol starts making sense =)
08:02:43 <ertes-w> or another UI
08:02:50 <ertes-w> i'm not planning to create a UI
08:02:52 <dmwit> ertes-w: Yup. And it's why I just have a keybinding for pavucontrol. Does everything I need, and exposes the complexity when I need it.
08:03:21 <dmwit> I have only one complaint: I wish pavucontrol would show streams for a few minutes after they're closed.
08:03:35 <sproingie> Lokathor: aha there it goes :)
08:05:12 <sproingie> Lokathor: i'll poke around with hexes some more today now that i know it's actually working :)
08:13:53 <paolino> hi, with type Index a = In,  (42 :: Index ()) ==  (42 :: Index Bool) is not a type error
08:14:28 <paolino> *type Index a = Int
08:16:25 <sproingie> does a phantom type synonym even make sense?
08:17:00 <paolino> yes if it works :-)
08:17:12 <glguy> Why would it be a type error?
08:17:38 <paolino> because (==) => Eq a => a -> a -> Bool
08:18:20 <glguy> That's fine, when the type synonym is evaluated the types match
08:18:31 <sproingie> but Index () and index Bool would not both be a
08:18:47 <glguy> type variables aren't instantiated with type synonyms
08:18:50 <sproingie> but i think of synonyms as expanding early on, and unused type var is just lost
08:18:55 <glguy> They're instantiated with what they evaluate to
08:19:16 <sproingie> yah that's what i thought
08:20:35 <sproingie> brings me back my first question, is there any use for a type synonym like type Foo a = Bar?
08:20:40 <glguy> This is related to how you can't partially apply a type synonym, when you use one it needs to be able to expand immediately
08:21:19 <sproingie> ("synonym" is one of those words that looks misspelled the more you type it)
08:21:19 <ski> (.. `Index ()' is equal to `Index Bool', the same way `const "gronk" ()' is equal to `const "gronk" 42')
08:22:28 <paolino> so phantom types are useful only when we have constructors ?
08:22:48 <glguy> When we use data or newtype
08:23:07 <c_wraith> paolino: no, that's not true.  You can use phantom types in empty data types for type-level programming
08:23:13 <glguy> type synonyms introduce new type constructors, but they don't generate distinct types
08:23:21 <paolino> c_wraith, fine
08:24:16 * ski . o O ( `LiberalTypeSynonyms' )
08:24:30 <paolino> ok, than ghc should have warned or rejected
08:24:43 <glguy> paolino: No, everything is working correctly
08:24:46 <bno1> I'm trying to do an insert or replace function for a groundhog table that has a custom primary key. when calling extractUnique it says: "No instance for (IsUniqueKey (Key KnownUser BackendSpecific))" and "No instance for (PrimitivePersistField (Key KnownUser BackendSpecific))"
08:24:50 <sproingie> i believe "phantom" originally applied to the empty type you typically fill in the parameterized type with
08:25:12 <c_wraith> sproingie: I'm not sure what you mean by that
08:26:05 <sproingie> as in data Validated; data Unvalidated; data FormData a = Form; submit :: FormData Unvalidated
08:26:31 <paolino> glguy, syntax error ?
08:26:41 <glguy> sproingie: No, phantom isn't related to using an empty datatype, it's related to the parameter being otherwise unused in the type definition
08:26:44 <c_wraith> sproingie: the name predates adding empty data types to the language..
08:26:52 <glguy> paolino: What syntax error?
08:27:22 <paolino> well, I'm writing a non sense with type A x = B
08:27:32 <glguy> no, it's not nonsense, you just didn't know what it meant
08:28:03 <sproingie> you just don't get the effect you want with 'type'.  try 'data'
08:29:15 <paolino> sprongie I wanted to avoid the wrap/unwrap
08:30:17 <sproingie> could use newtypes, would need a different one for each tho (yuck)
08:32:58 <sproingie> multi-parameter newtypes would be nice.  seems to me that could work if they only used one of the type parameters, right?
08:33:39 <cocreature> sproingie: what do you mean by multi-parameter newtype?
08:36:25 <sproingie> er nevermind, that was unclear as could be, it already does.  i need to gc my brane.
08:36:43 <sproingie> > newtype Foo a b c = Foo (a,b)
08:36:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘newtype’
08:36:51 <sproingie> :P
08:37:40 <sproingie> even get helpful feedback from ghci:
08:37:41 <sproingie> λ> newtype Foo a b c = Foo (a, b)
08:37:42 <sproingie> type role Foo representational representational phantom
08:38:52 <sproingie> unfortunately it still hates "newtype Index a = Int"
08:39:44 <cocreature> sproingie: well that’s just missing the constructor name
08:39:52 <cocreature> newtype Index a = Index Int
08:40:10 * sproingie facepalms
08:42:32 <sproingie> there we go.  (Index 123 :: Index ()) == (Index 123 :: Index Bool) dies with the expected type error
08:42:55 <sproingie> (yes, i remembered to derive Eq)
08:46:02 <geekosaur> I feel like you'e reaching for type families instead of newtypes
08:46:24 <geekosaur> (non-associated)
08:46:43 <sproingie> probably.  i was going for an answer to paolino's problem
08:49:45 <paolino> sproingie, I'll do newtype Index (a:: Nat) = Index Int
08:50:59 <sproingie> wouldn't all Nats be the same type?
08:51:58 <glguy> In that context Nat is a kind
08:57:06 <paolino> yep, and I can write 104 :: Index 1 
09:18:59 <jchia_> If I Control.Concurrent.forkIO to create threads, and then main finishes, does the program terminate immediately or does it wait for the forked threads to finish before terminating?
09:21:37 <geekosaur> terminates immediately
09:22:44 <cocreature> it also doesn’t kill the other threads via an exception, it just dies immediately so if you’ve used something like "bracket" the finalizers won’t be run
09:28:49 <ondrejs> hello. I am using stack and want to use hspec. I've basically copied https://github.com/hspec/hspec-example, stack test runs but says "0 examples". I have the same dir/file structure in src and test folders, I have the same Spec.hs. Any ideas where to look at?
09:30:49 <MitchellSalad_> ondrejs: can you publish your whole repo?
09:32:17 <ondrejs> MitchellSalad_: not yet unfortunatelly
09:37:10 <ondrejs> MitchellSalad_: found it, spec files have to end with Spec.hs
09:53:22 <jeltsch> How can I enable sections for type operators, so that I can write something like type X = (Int ->)?
09:53:42 <johnw> for that, you must write type X = (->) Int
09:53:46 <johnw> there are no type operator sections
10:22:00 <ph88> how can i check if a list of doubles is ordered low to high ? sort it first and then compare with sorted list ?
10:22:37 <ReinH> ph88: with a fold
10:23:12 <glguy> sorted xs = and (zipWith (>=) xs (tail xs))
10:23:21 <ReinH> Or that.
10:23:23 <glguy> oh, low to high
10:23:26 <glguy> sorted xs = and (zipWith (<=) xs (tail xs))
10:23:32 <ph88> thx
10:23:32 <ReinH> @quote aztec
10:23:32 <lambdabot> alpounet says: map succ/pred is a scandinavian name generator or what? ... well, scandinavian and aztec
10:23:38 <ReinH> :(
10:23:51 <glguy> The zip`ap`tail one?
10:23:51 <ReinH> @quote zip`ap`tail
10:23:52 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
10:24:09 <ReinH> I didn't realize there would be more than one quote containing 'aztec'
10:25:19 <sproingie> olmy `ap` sennon
10:42:28 <argent0> ph88: but tail [] = error
10:42:50 <ph88> no worries :P
10:51:55 <CodeWeaverX> Greetings, programs.
10:52:42 <CodeWeaverX> Got a weird lazy stream ... misunderstanding.  I tried this:
10:52:49 <CodeWeaverX> sep = takeWhile(/="0").lines
10:52:55 <CodeWeaverX> main = liftM sep getContents >>= mapM_ putStrLn
10:53:10 <CodeWeaverX> And got a crash with a "handle semi-closed" error.
10:53:30 <glguy> getContents takes over stdin
10:53:34 <glguy> so you can't use it after that
10:53:45 <CodeWeaverX> Errr, yes, but I'm not sure why that's a problem here.
10:53:50 <CodeWeaverX> I dont' do any input after that.
10:53:54 <CodeWeaverX> That's the entire program.
10:53:55 <glguy> Did you do that in GHCi?
10:54:02 <CodeWeaverX> Yah...Oh.
10:54:07 <CodeWeaverX> The REPL.
10:54:11 <CodeWeaverX> *facepalm*
10:54:33 <CodeWeaverX> On that's hilarious.
10:56:06 <CodeWeaverX> Many thanks. :)
10:57:56 <merijn> CodeWeaverX: Also, that code can be simplified as "main = interact $ takeWhile (/="0")"
10:58:03 <merijn> eh
10:58:18 <merijn> Needs lines + unlines around takeWhile
10:58:55 <CodeWeaverX> Nice. 
11:07:06 <se-11-fish> hey, is a function with signature (a -> b) -> (m a -> m b) a kleisli arrow? since this is sort of like f -> m f 
11:09:37 <ertes-w> se-11-fish: a kleisli arrow is not (just) a function…  the signature is more reminiscent of functors
11:09:39 <ertes-w> :t fmap
11:09:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:11:40 <se-11-fish> yes, I know this is a functor. I am sort of confused similarly to this guy: https://math.stackexchange.com/questions/50129/whats-the-difference-between-an-endofunctor-and-a-morphism
11:12:06 <divVerent> Hm... "fmap fmap fmap" == "fmap . fmap", interesting
11:13:59 <ReinH> se-11-fish: A Kleisli arrow is of type a -> m b
11:14:26 <ertes-w> se-11-fish: note that kleisli arrows are basically just monads
11:14:35 <se-11-fish> ReinH, what about a -> mb -> mc ?
11:14:36 <ReinH> It is an arrow in the category where (<=<) is composition and return is id
11:14:42 <ertes-w> the (<=<) composition is called kleisli composition
11:14:53 <ReinH> se-11-fish: A Kleisli arrow is of type a -> m b
11:15:41 <ReinH> is a -> m b -> m c of type a' -> m b' for any a' and b'?
11:15:48 <ertes-w> note also a terminology confusion: what ReinH calls an arrow is the categorical arrow, but it's not the same thing as a haskell "Arrow"
11:15:58 <ReinH> remember that it is a -> (m b -> m c)
11:16:16 <ertes-w> a haskell Arrow is actually a type, not a value
11:16:59 <ReinH> Er, Arrow is a type class?
11:17:31 <Tuplanolla> Arrow or `Arrow`, ertes-w?
11:17:32 <ReinH> class Category a => Arrow a
11:17:51 <se-11-fish> :)
11:18:11 <ReinH> To further confuse things, Kleisli m is an Arrow when m is a Monad.
11:18:57 <se-11-fish> yes this sort of about relations i guess and there's a whole hierarchy induced
11:19:32 <se-11-fish> let me provide some context for the question. From Haskell documentation: "Postfix 'M' always stands for a function in the Kleisli category"
11:19:44 <ReinH> Link?
11:20:21 <se-11-fish> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html
11:20:47 <se-11-fish> and they give this example:  filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:20:52 <ReinH> where foo takes an a -> b, fooM takes an a -> m b
11:20:54 <ReinH> is what that means
11:21:09 <ReinH> where m is a Monad
11:21:13 <se-11-fish> yes, but how does that work with currying?
11:21:29 <ReinH> Why do you expect it to work differently?
11:22:16 <se-11-fish> so  they also say in the doc: "A prefix 'm' generalizes an existing function to a monadic form. Thus, for example:"
11:22:24 <se-11-fish>  msum :: MonadPlus m => [m a] -> m a
11:23:29 <se-11-fish> but "monadic form" is the same as "Kleisli category", no?
11:23:48 <ReinH> :t sum
11:23:50 <lambdabot> (Num a, Foldable t) => t a -> a
11:23:51 <ReinH> :t msum
11:23:53 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
11:23:53 <ReinH> ugh
11:24:05 <ReinH> sum :: Num a => [a] a
11:24:10 <ReinH> :t msum
11:24:12 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
11:24:19 <ReinH> sigh
11:24:37 <ReinH> monadic form means operating on `m a` instead of on `a`
11:24:49 <ReinH> sum :: Num a => [a] -> a
11:24:59 <ReinH> msum :: MonadPlus m => [m a] -> m a
11:26:53 <Tuplanolla> Here's another take of your question, se-11-fish: if you have the function `a -> m b -> m c`, which is `a -> (m b -> m c)`, it can be thought of as `a -> n (m c)`, where `n = (->) (m b)`.
11:27:04 <Tuplanolla> If `n` and `m` are monads and compose, the result is indeed a Kleisli arrow.
11:28:37 <se-11-fish> thx Tuplanolla, this is helpful
11:28:59 <Tuplanolla> I don't see how.
11:29:18 <se-11-fish> :D
11:29:26 <ReinH> a -> m b -> m c is not a Kleisli arrow in the Kleisli category formed by m
11:29:47 <se-11-fish> I am trying to figure out the algorithm behind naming a function xyzM vs mxyz :)
11:29:52 <ReinH> It is as I said
11:30:04 <ReinH> where a foo takes an a -> b, a fooM takes an a -> m b
11:30:11 <Tuplanolla> There's no formal specification for naming things, se-11-fish.
11:30:33 <ReinH> :t filter
11:30:35 <lambdabot> (a -> Bool) -> [a] -> [a]
11:30:36 <ReinH> :t filterM
11:30:37 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
11:30:41 <se-11-fish> Well, so at least an intuition which people have for that
11:30:46 <ReinH> where filter takes an a -> Bool, filterM takes an a -> m Bool
11:30:54 <Tuplanolla> There you have it.
11:31:00 <ReinH> I guess this means that we should call (=<<) fmapM
11:31:03 <ReinH> :t fmap
11:31:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:31:18 <ReinH> :t let fmapM = (=<<) in fmapM
11:31:20 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:31:54 <Tuplanolla> I guess we should rename `return` to `idM` then.
11:32:00 <ReinH> Yes.
11:32:11 <ReinH> It is, indeed, an m-shifted id.
11:34:23 <Tuplanolla> Then `join` becomes `extractM`.
11:34:42 <ReinH> Indeed.
11:34:53 <Tuplanolla> The problem with enforced conventions is that you can take them to absurd lengths like this, se-11-fish.
11:35:02 <ReinH> They aren't absurd though.
11:35:04 <divVerent> 14:29:25      se-11-fish | I am trying to figure out the algorithm behind naming a function xyzM vs mxyz :)
11:35:14 <divVerent> isn't typically mxyz for monoids?
11:35:20 <ReinH> oh, xyzM versus mxyz
11:35:33 <divVerent> like mappend
11:35:33 <ertes-w> se-11-fish: you'll develop an intuition for it by familiarising yourself with the base library
11:35:36 <se-11-fish> yes, I know I just want to understand the intuitions and dimensions in which people think about it
11:35:44 <ReinH> foo is to fooM as a -> b is to a -> m b
11:35:50 <ReinH> foo is to mfoo as a is to m a
11:36:07 <ertes-w> se-11-fish: in fact i think the 'M' suffix is mostly legacy…  personally i prefer to use 'traverse_' over 'mapM_'
11:36:14 <ertes-w> similarly 'for_' over 'forM_'
11:36:15 <divVerent> hm... I can't think of an example of the latter case now... which mfoo are you thinking of?
11:36:25 <divVerent> or is the m here Monoid? :)
11:36:33 <ReinH> and filterM only needs an Applicative constraint since filtering is context-free.
11:36:38 <divVerent> OH, MonadZero has that (mzero)
11:36:38 <ReinH> so it should be filterA.
11:36:52 <merijn> divVerent: MonadZero no longer exists, afaik
11:36:59 <divVerent> yes, was a proposal
11:37:07 <ertes-w> se-11-fish: similar with the 'm' prefix:  i prefer to use 'empty' over 'mzero' and (<|>) over 'mplus'
11:37:20 <ReinH> mconcat is for monoids while msum is for monads. :D
11:37:29 <ReinH> No one said the naming schemes had to be unambiguous.
11:37:36 <ertes-w> and asum is…  no, not for Applicative, but Alternative =)
11:37:37 <divVerent> but MonadPlus is the one that satisfies Monoid
11:37:48 <ReinH> Then again, monads are monoids so it all works out.
11:37:51 <se-11-fish> so is fmap a Kleisli arrow in some category?
11:37:55 <divVerent> which brings me to this
11:38:08 <divVerent> if a Monad is a Monoid in the Category of Endofunctors
11:38:11 <ReinH> :t fmap
11:38:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:38:15 <divVerent> why don't all Monads satisfy Monoid?
11:38:22 <geekosaur> different level
11:38:28 <ReinH> Is that of type a' -> m b' for some a', m, b' where m is a Monad?
11:38:34 <divVerent> different level sure, but that doesn't stop anyone, or does it?
11:38:45 <ReinH> A monad is a type-level monoid. Monoid is for value-level monoids.
11:38:57 <geekosaur> ^
11:39:06 <ReinH> And never the twain shall meet, expect when it does, which is not in this case.
11:39:14 <`Guest00000> they're pretty unambiguous
11:39:24 <geekosaur> and you can't (currently, at least) lift Haskell's Monoid to type level
11:39:26 <`Guest00000> mconcat relates to mappend, msum relates to mplus
11:39:46 <ReinH> '`Guest00000 yes, but that just moves the problem.
11:40:00 <ReinH> now it's mappend and mplus which are ambiguous uses of the m-prefix.
11:40:13 <divVerent> now I am checking why I can't just make any Monad satisfy Monoid at value level too :)
11:40:53 <ReinH> Because being able to join the m's does not imply being able to join the a's
11:41:10 <divVerent> hm... indeed, mzero doesn't exist in general from just the four members of Monad
11:41:36 <ReinH> That is indeed why it exists as a separate typeclass.
11:43:00 <divVerent> or actually... there is a neutral element in every Monad - the "action" a -> m a that does nothing, known as "return"
11:43:25 <divVerent> but also, that does seem that the entire Monad can't generally fulfill Monoid anyway, if anything, only the functions a -> m a
11:43:27 <ReinH> Yes, that's the type-level neutral element of the type-level monoid.
11:43:47 <divVerent> this one is also a value
11:44:01 <divVerent> but yes, I see it now
11:44:13 <divVerent> the values of type (a -> m a) in every Monad do form a Monoid
11:44:19 <divVerent> but that's not all values
11:44:43 <ReinH> Yes, they form the monoid you get when you restrict the Kleisli category to a single object, a
11:45:26 <divVerent> but if I'd want to form a Monoid out of a Monad in general, I'd need an operation that combines two m a to one m a that is associative and has a neutral element
11:46:02 <ReinH> MonadPlus m is exactly the typeclasses for m's which are monoids for arbitrary a's
11:46:06 <ReinH> like []
11:46:23 <ReinH> MonadPlus m is an a-indexed class of monoids.
11:46:55 <divVerent> well, it's only those where the author thought of actually implementing MonadPlus :)
11:47:09 <ReinH> Yes, I mean notionally.
11:47:50 <divVerent> and e.g. for IO to be MonadPlus, there'd need to be a way to implement mplus :: IO a -> IO a -> IO a, which is basically nonsense
11:48:14 <ReinH> Yeah, not every Monad is a MonadPlus, but we already said that.
11:48:22 <divVerent> not knowing anything about a, and knowing that (ignoring exceptions) each a exists, it could only be implemented by always returning the first or the second
11:48:26 <divVerent> which doesn't allow for a neutral element
11:48:33 <divVerent> right, was just trying to figure out a coutnerexample
11:48:36 <divVerent> but this one is a good one
11:48:47 <ReinH> IO is a boring counter-example because it doesn't have a denotation anyway.
11:48:59 <se-11-fish> is there a standard name for functions of type: m a -> m b ?
11:49:04 <ReinH> So it's hard to understand why it is a counter-example other than "no one knows what IO means".
11:49:08 <divVerent> while e.g. Maybe has a clear designated neutral element
11:49:17 <divVerent> that was kinda the pointr
11:49:30 <[exa]> se-11-fish: like, standard name for (>>) ?
11:49:38 <divVerent> there is little more that you can assume about IO than about a free monad
11:50:07 <Tuplanolla> @hackage mtl -- Check these for inspiration, se-11-fish.
11:50:07 <lambdabot> http://hackage.haskell.org/package/mtl -- Check these for inspiration, se-11-fish.
11:50:11 <Tuplanolla> @hackage mmorph
11:50:11 <lambdabot> http://hackage.haskell.org/package/mmorph
11:50:34 <[exa]> se-11-fish: oh sorry, wrong type :D
11:51:00 <Tuplanolla> They feature both `m a -> m b` and `m a -> n a`.
11:51:31 <ertes-w> <geekosaur> and you can't (currently, at least) lift Haskell's Monoid to type level ⇐ i yearn for the day that changes
11:51:38 <divVerent> but yes, the Either monad is also an obvious one without a definable neutral element
11:51:43 <ReinH> I don't know of a standard name for functions of type m a -> m b. Usually it's pretty clear from context.
11:51:50 <cocreature> Tuplanolla: huh? where is m a -> m b in mmorph?
11:52:01 <divVerent> now, Either String could probably receive a MonadPlus instance (it'd concatenate error messages)
11:52:07 <ReinH> divVerent: Most Monads are not MonadPlus
11:52:19 <Tuplanolla> It should be in the `ReaderT` of `mtl`, cocreature.
11:52:24 <divVerent> right, I was just trying to see what it takes in practice
11:52:27 <ReinH> base only gives 6 instances.
11:53:00 <ReinH> Either e isn't a MonadPlus because you can't create an e from thin air for return.
11:53:14 <cocreature> Tuplanolla: ah I think I misunderstood you. I thought you were saying there is a class in mmorph that uses "m a -> m b"
11:53:27 <dolio> There are only infinitely many MonadPlusses, but infinitely many Monads. :)
11:53:47 <ReinH> dolio: oh you
11:54:48 <divVerent> dolio: you're absolutely right... as there are infinitely many types a, you can construct infinitely many MonadPlus (ArrowMonad a), and infinitely many Monad (ArrowMonad a) :)
11:55:11 <ReinH> It is both true and boring. ;)
11:55:23 <ertes-w> (forall a b. m a -> m b) -> m = Void1
11:55:50 <ReinH> Some would say the best kind of true.
11:55:56 <cocreature> ertes-w: Void1?
11:55:59 <`Guest00000> http://www.luna-lang.org/
11:56:01 <cocreature> ertes-w: Proxy?
11:56:02 <ertes-w> (forall a b. m a -> m b) -> forall a. m a -> Void
11:56:06 <ertes-w> cocreature: yeah
11:56:13 <ertes-w> uh, oh yeah, not quite Void1
11:56:16 <ertes-w> but Unit
11:56:23 <`Guest00000> Luna. Visual and textual functional programming language 
11:56:26 <cocreature> that’s quite different :)
11:56:45 <ertes-w> yeah, it is…  and the latter formula is not provable =)
11:57:07 <ertes-w> but…
11:57:25 <ertes-w> (forall a b. m a -> m b) -> forall a. m a
11:57:35 <ertes-w> which is pretty much just:  m ≃ Proxy
11:58:09 <ertes-w> hmm, no, also not quite, but you get the idea
11:59:10 <cocreature> it seems like all you can say is that it’s a phantom type parameter
11:59:10 <ReinH> `Guest00000: that's cool.
11:59:32 <ertes-w> yeah
12:00:08 <ReinH> divVerent: What about Monoid e => Either e?
12:00:38 <ertes-w> cocreature: i have difficulty coming up with an example that isn't isomorphic to Proxy though
12:00:44 <robkennedy> Which of O2's optimizations are dangerous to concurrent/parallel (but not unsafe AFAIK) programs?
12:00:54 <ertes-w> first attempt:  data And1 a = False1 | True1
12:00:59 <cocreature> ertes-w: Const Int?
12:01:07 <mclark1129> So I thought I was on my way to actually understanding Monads, and then I started watching videos on Monad transformers
12:01:09 * mclark1129 cries
12:01:18 <ertes-w> cocreature: that's not quite a monad, is it?
12:01:30 <ReinH> An indexed proxy?
12:01:30 <cocreature> ertes-w: you didn’t include Monad in your type signature :P
12:01:34 <cocreature> ertes-w: but good point
12:02:18 <ertes-w> right =)
12:03:08 <ertes-w> mclark1129: don't overthink it
12:03:22 <ertes-w> mclark1129: take Monad as what it is:  a type class with certain laws
12:03:56 <[exa]> mclark1129: m1 (m2 a)  +steroids
12:04:15 <ertes-w> mclark1129: monads are monoids on steroids, so you may want to learn Monoid first =)
12:04:48 <iqubic> mclark1129: Monads are just endofuctors in the catagory of monoids. I really don't get what the issue is.
12:04:51 <dolio> I don't know that that would help.
12:05:13 <`Guest00000> somebody is already implementing my ideas D:
12:05:51 <mclark1129> Just use the Either monad?  No that's a part of Maybe!
12:06:12 <monochrom> Haha
12:06:16 <se-11-fish> :)
12:06:43 <ertes-w> mclark1129: exercise: "Either is not a monad"…  explain why
12:08:00 <mclark1129> ertes-w: Rephrased for coffee talk "I'll give you a topic.  Either is neither a monad or a monoid, discuss discuss"
12:09:52 <mclark1129> Category theory aside, what does it really mean for something to be a "computational context"?
12:09:58 <ertes-w> mclark1129: that's not a joke though…  Either is indeed not a monad, but not in any deeper sense
12:10:21 <ertes-w> there is a very simple reason why it's not
12:10:27 <mclark1129> two types?
12:10:30 <`Guest00000> mclark1129: what is the context for that phrase?
12:10:38 <mclark1129> Either a b?
12:10:50 <[exa]> kind mismatch
12:10:52 <ertes-w> mclark1129: you're on the right track
12:11:07 <ertes-w> mclark1129: Monad, as a constraint, takes an argument, like this:  Monad M
12:11:12 <`Guest00000> monad constructor
12:11:18 <ertes-w> mclark1129: what's the kind of M?
12:11:34 <mclark1129> * -> *?
12:12:44 <ertes-w> yeah
12:12:48 <ertes-w> and what's the kind of Either?
12:13:46 <mclark1129> * -> * -> *?
12:14:00 <ertes-w> yeah, so it can't be an argument to Monad
12:14:20 <mclark1129> Either [String] is a monad, whereas Either is not
12:14:25 <ertes-w> exactly
12:14:37 <ertes-w> so Either is really a family of monads, indexed by the "error" type
12:15:26 <`Guest00000> now, i must create my own LunaOS before somebody else does
12:15:44 <ertes-w> it would actually make more sense to speak of "an Either monad" rather than "the Either monad" =)
12:16:05 <`Guest00000> because in that case i lose motivation to do it, yet that LunaOS will be worse than my project
12:16:16 <greeny> reading this conversation the last 30 minutes teachs me so much about categroy theory. hearing a lecture on this topic this semester and i'm getting headache all the time
12:16:37 <athan> I'm tempted to use "-esque" as the suffix for a typeclass name, like "-able". Should I? :|
12:16:40 <jordan__> can anyone here answer me a question about heapsort?
12:16:59 <ertes-w> athan: there is also "-like"
12:17:42 <dolio> What's the prefix?
12:17:43 <athan> ertes-w: KindaSortofAFoo a =>
12:17:52 <dolio> Is it Dangeresque?
12:18:04 <jordan__> first of all you need to convert an array to a tree with heap structure, but at this point you already have sorted the elements, so what's the point of the actual algorithm?
12:18:10 <athan> Nah, I'm just contemplating an interface for Maps
12:18:16 <athan> like IntMap, HashMap, etc
12:18:22 <athan> I think I might have already actually :|
12:18:26 <ertes-w> athan: see semigroupoids
12:18:32 <athan> hrm
12:18:50 <ReinH> jordan__: converting an array to a heap *is* the algorithm.
12:18:57 <dolio> jordan__: Heap sort can be done entirely in an array. But also, heaps aren't completely sorted.
12:18:59 <athan> ertes-w: ...how?
12:18:59 <ReinH> That's what does the sorting.
12:19:07 <athan> I'm not looking for the monoid instance or anything
12:19:11 <athan> or a Foldable1
12:19:19 <ertes-w> athan: what do you need?
12:19:27 <athan> lookup, insert, delete, stuff like that
12:19:44 <cocreature> athan: it’s in lens™
12:19:45 <ReinH> The point is that inserting into a heap is faster than inserting into a list.
12:19:58 <dolio> Heaps just have the property that nodes are greater or less than their children, with no requirements between siblings and such in general.
12:20:02 <athan> cocreature: oh hm, a prism over a key?
12:20:04 <ertes-w> athan: lens has all of those
12:20:13 <ertes-w> athan: see Ix and At
12:20:20 <athan> oh wow okay
12:20:23 <athan> awesome, thank you
12:21:07 <monochrom> Permuting an array into heap form actually takes just linear time. It can't be sorted by then.
12:21:18 <cocreature> athan: it’s not a prism it’s a lens to a Maybe so you can delete
12:21:19 <ertes-w> > M.singleton 'a' 0 & at 'a' %~ maybe (Just 15) (Just . (15 +))
12:21:22 <lambdabot>  fromList [('a',15)]
12:21:26 <ertes-w> > M.singleton 'a' 0 & at 'b' %~ maybe (Just 15) (Just . (15 +))
12:21:28 <lambdabot>  fromList [('a',0),('b',15)]
12:21:57 <ertes-w> athan: 'at' is a family of lenses, while 'ix' is a family of traversals
12:22:18 <ReinH> Right, I've got it backwards. Taking the min from the heap is what does the sorting.
12:24:27 <dolio> There are heap-based algorithms where a sorted array is a valid heap structure that it's using, but even then just building the heaps doesn't guarantee it's sorted already (you have to unbuild to get all the way there in general).
12:26:21 <jordan__> https://usercontent.irccloud-cdn.com/file/F889OKiI/IMG_2766.PNG
12:26:39 <jordan__> this is a visualization of the algorithm
12:26:56 <dolio> monochrom: Oh, and in the latter, the point is that building from a sorted list takes linear time, and the array is already sorted. :P
12:27:01 <dolio> That's a special case, though.
12:27:13 <jordan__> but in step 1 you already have all elements sorted in the heap (not the last element for some reason)
12:27:52 <cocreature> jordan__: they’re not sorted. you only know that the parent is smaller than its children but you don’t know which of the children is smaller
12:28:11 <jordan__> ohh
12:28:30 <jordan__> so the order of the children is random?
12:28:48 <dolio> Typical heap sort doesn't even come close to sorting by the time the heap is built, because it moves the largest element to the front.
12:28:52 <cocreature> eh larger in that example not smaller but you get the idea
12:29:01 <jordan__> 5-->2,3 is a heap
12:29:13 <jordan__> 5-->3,2 is also a heap?
12:29:17 <[exa]> yep
12:29:30 <jordan__> ok then i understand the algorithm
12:29:57 <jordan__> thx!
12:30:22 <cocreature> jordan__: next step: implement it in Haskell :)
12:31:27 <ReinH> maybe start with fake (immutable) heap sort though.
12:37:33 <Tuplanolla> Fusing loops manually in C is increasing my Haskell appreciation more than writing Haskell does.
12:38:01 <dolio> Heapsort is kind of inconvenient to do with an actual heap-as-a-tree.
12:38:57 <dolio> I guess you could use immutable arrays.
12:40:43 <f0reclone> Hello
12:46:06 <shapr> Tuplanolla: are you welding them or soldering them?
12:47:15 <Xion_> So I'm watching a talk about freer-effects package, and it all seems wonderful because it seems to solve the common mtl problems of order, coupling, etc. My natural question is what's the catch :)
12:47:17 <f0reclone> somebody available to help me with a slight problem?
12:47:25 <shapr> f0reclone: what's the problem?
12:47:35 <Xion_> I'm guessing it's in performance since there is an actual data structure for the free monad involved that has to be interpreted.
12:47:50 <f0reclone> I've got a task at college which i try to solve since 4 hours
12:47:56 <shapr> f0reclone: what's the task?
12:47:58 <shapr> and what's the problem?
12:48:08 <f0reclone> one minute i paste it online
12:48:22 <Xion_> ( https://www.youtube.com/watch?v=gUPuWHAt6SA is the talk if you're interested)
12:48:57 <f0reclone> http://lpaste.net/356414
12:49:22 <f0reclone> I implemented the functions foldr and fmap
12:49:35 <f0reclone> but keep getting errors
12:50:03 <cocreature> does hunit have anything for asserting that a specific exception is thrown or do I need to build that myself?
12:50:28 <f0reclone> you don't need it
12:50:54 <f0reclone> they use it to check for errors
12:51:08 <cocreature> f0reclone: but I want my test to _succeed_ if an exception is thrown
12:51:55 <cocreature> hspec has `shouldThrow` for that but this project is not using hspec and I’m not going to switch to hspec just for that :)
12:51:56 <f0reclone> sorry but I can't help you with this, I'm always commenting out their tests and check manually
12:52:42 <cocreature> no worries, thanks for trying :)
12:53:57 <f0reclone> basically this is an example of nesting data structures
12:55:11 <f0reclone> there is Fancy with two Childs of FancyPart. FancyPart adds itself up until End is reached
12:55:35 <f0reclone> my Problem is that it seems like I can't reach FancyPart in the instance of Fancy
13:00:40 <fresheyeball> anyone seen this before?
13:00:42 <fresheyeball> ld: framework not found Foundation
13:00:49 <fresheyeball> when running `cabal test`?
13:00:53 <fresheyeball> on osx?
13:02:16 <ReinH> f0reclone: You have fmap' func End = End but End is not a constructor of Fancy
13:02:27 <ReinH> it is a constructor of FancyPart
13:02:55 <ReinH> There is only one constructor for Fancy, which is also called Fancy.
13:03:13 <f0reclone> so what should I call instead?
13:03:22 <f0reclone> Fancy (End, End)
13:03:25 <ReinH> so your fmap for Fancy must be fmap f (Fancy ???)
13:04:03 <ReinH> Well, fmap f (Fancy p p') where p and p' are patterns for FancyPart.
13:04:24 <ReinH> The case where both parts are End would be Fancy End End
13:04:52 <f0reclone> ok thanks
13:04:57 <f0reclone> I will try this
13:05:11 <ReinH> There are two FancyParts in Fancy and FancyPart has 2 constructors so there are 2 * 2 = 4 possible cases for Fancy.
13:05:26 <ReinH> Well no
13:05:34 <ReinH> Add has more FancyPart
13:05:46 <f0reclone> yeah its nested
13:06:07 <ReinH> So there are infinitely many possible constructors but you can cover them all by induction on FancyPart.
13:06:12 <ReinH> possible patterns, rather
13:06:33 <ReinH> since FancyPart is just [] with weird names.
13:07:11 <ReinH> And in fact, you don't have to cover them explicitly. You can write fmap for FancyPart and use it to write fmap for Fancy.
13:07:14 <ReinH> And the same goes for foldr.
13:11:07 <f0reclone> ReinH thanks for your help, I've still no clue how to fix this but thats not your fault :)
13:11:23 <ReinH> f0reclone: can you write map for []?
13:11:56 <f0reclone> yes
13:12:29 <ReinH> Then you can write it for FancyPart
13:13:06 <ReinH> let's say you have data T a = T [a] [a]. Can you write fmap for T?
13:15:43 <ReinH> fmap f (T xs ys) = ?
13:15:54 <ReinH> How can you apply f to xs and ys?
13:16:12 <f0reclone> fmap f (T xs ys) = T (fmap' f xs) (fmap' f ys)
13:17:02 <glguy> Where's fmap' coming from?
13:17:16 <mclark1129> fmap' = map?
13:17:17 <f0reclone> where fmap' f (x:xs) = (f x) fmap' f xs
13:17:30 <f0reclone> where fmap' f (x:xs) = (f x) : fmap' f xs
13:17:39 <ReinH> why not just use map?
13:17:52 <glguy> or for this exercise, just use fmap
13:17:56 <ReinH> Sure.
13:18:12 <f0reclone> i think we can use map
13:18:19 <ReinH> If we can use map, we can use fmap.
13:18:28 <ReinH> fmap for lists is map
13:18:38 <f0reclone> yes
13:18:53 <f0reclone> but in the exercise there is no list
13:19:03 <ReinH> FancyPart is your list
13:19:04 <f0reclone> only nested data types
13:19:14 <ReinH> and it can be given a Functor instance
13:19:25 <ReinH> and once it has a Functor instance, you can use fmap on it
13:20:58 <f0reclone> fmap func (Fancy a b) = Fancy ((map func a) + (map func b))
13:21:04 <ReinH> not map, fmap
13:21:11 <ReinH> you have a Functor instance, not a list.
13:21:15 <ReinH> and no +
13:21:17 <ReinH> you are not adding anything
13:21:51 <f0reclone> ok
13:21:53 <f0reclone> Fancy.hs:14:29: error:
13:21:53 <f0reclone>     * Couldn't match expected type `Fancy b'
13:21:53 <f0reclone>                   with actual type `FancyPart b -> Fancy b'
13:22:02 <ReinH> Well, I don't know what you are doing.
13:22:06 <ReinH> So I don't know why you got that error.
13:22:09 <f0reclone>  fmap func (Fancy a b) = Fancy ((fmap func a) (fmap func b))
13:22:15 <f0reclone> thats the code
13:22:18 <ReinH> You don't need the extra parens
13:22:31 <ReinH> Fancy takes two arguments, not one.
13:23:19 <ReinH> You didn't say fmap f (T xs ys = T ((fmap f xs) (fmap f ys))
13:23:30 <ReinH> Er... You didn't say fmap f (T xs ys) = T ((fmap f xs) (fmap f ys))
13:24:31 <f0reclone> ok
13:24:49 <f0reclone> so do I need to write extra functions for fmap f xs?
13:25:01 <ReinH> FancyPart needs to be an instance of Functor.
13:25:06 <ReinH> so you can use fmap on it
13:26:18 <f0reclone> instance Functor FancyPart?
13:26:34 <ReinH> instance Functor FancyPart where
13:26:39 <ReinH> and then you have to define fmap
13:27:45 <f0reclone> ok
13:32:26 <f0reclone> 	fmap func End = End
13:32:26 <f0reclone> 	fmap func (Add a b) = FancyPart Add (func a) (fmap func b)
13:32:50 <f0reclone> sorry
13:32:54 <f0reclone> here is the full code
13:32:54 <f0reclone> instance Functor FancyPart
13:32:55 <f0reclone>   where
13:32:55 <f0reclone> 	fmap func End = End
13:32:55 <f0reclone> 	fmap func (Add a b) = FancyPart Add (func a) (fmap func b)
13:33:26 <ReinH> FancyPart is not a constructor of the type FancyPArt
13:33:33 <ReinH> Its constructors are Add and End.
13:33:57 <f0reclone> thanks
13:33:59 <f0reclone> yeahhh
13:34:02 <f0reclone> it works
13:35:33 <mauke> also, don't use tabs
13:36:14 <f0reclone> yeah it's kind of an addiction from other languages
13:36:26 <ReinH> Break it.
13:36:42 <ReinH> Or you will have a Bad Time.
13:37:01 <glguy> The issue is that Haskell mandates that tabstops are 8 characters wide, and Haskell is indentation sensitive
13:37:19 <glguy> so if someone has a misconfigured editor the code will not only look bad but will look like it has a different meaning
13:37:31 <f0reclone> ok, thanks for the info
13:37:36 <f0reclone> already changed my code
13:37:43 <Sh4rPEYE> Hey. I'm having some problems installing IHaskell. I'm using MacOS beta with new clang and gcc and they have a bug, which prevents stack to install terminfo.
13:37:59 <Sh4rPEYE> Somewhere I read I need to "pass -fno-allow-editor-placeholders to CFLAGS"
13:37:59 <Sh4rPEYE> What's that and how can I do it?
13:38:10 <jared-w> oh right, I think I saw a thread like that on r/haskell. It seems the solution was to upgrade your llvm?
13:38:13 <EvanR> next haskell report version, tabs made illegal (if not why not)
13:38:22 <mauke> the real problem is that haskell doesn't care about indentation, it cares about making things line up with other things
13:38:42 <ReinH> There is a valid way to use tabs, but it is not the way that people usually use tabs.
13:38:51 <mauke> so unlike python (where you can have indent/dedent virtual tokens)
13:39:07 <jared-w> Honestly, tabs should've been made illegal a long time ago because of that
13:39:08 <EvanR> seems broken to me
13:39:10 <mauke> the only valid way to use tabs is for indentation, and haskell doesn't have that
13:39:42 <EvanR> since tabs=8 is almost logically wrong, its not going to achieve this "lining up" goal
13:42:26 <f0reclone> now working on foldr
13:45:32 <ReinH> The valid way is tabs for indentation and spaces for alignment.
13:45:38 <ReinH> I don't like it, but it does work.
13:46:31 <jared-w> That's not even just the valid way, it's literally /the/ correct way because of what tabs and spaces were originally designed for
13:47:14 <mauke> "meh"
13:47:19 <glguy> tabs are for lining stuff up when you don't use them at the beginning of the line
13:47:28 <glguy> and Haskell is both line-up and indentation sensitive
13:48:11 <glguy> and whatever tabs are for, its recommended not to use them in Haskell
13:48:40 <Xion_> You want to use spaces because you will be paid more though
13:48:43 <ReinH> All I am saying is that it is a method that will produce syntactically valid Haskell files, not that I would ever recommend anyone use it.
13:50:28 <f0reclone> instance Foldable FancyPart
13:50:28 <f0reclone>   where
13:50:29 <f0reclone>     foldr func start End = start
13:50:29 <f0reclone>     foldr func start (Add a b) = func a + foldr func start b
13:50:49 <f0reclone> can anyone tell me why this lines doesn't work?
13:50:50 <Tuplanolla> It's the `+`.
13:51:05 <f0reclone> what should i use instead?
13:51:14 <Tuplanolla> Your `func`.
13:52:46 <glguy> :t foldr
13:52:48 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:52:59 <glguy> Num doesn't feature here
13:53:01 <glguy> :t (+)
13:53:02 <lambdabot> Num a => a -> a -> a
13:53:19 <f0reclone> just changed it
13:53:20 <f0reclone> instance Foldable Fancy
13:53:20 <f0reclone>   where 
13:53:21 <f0reclone>     foldr func start (Fancy a b) = (foldr func start a) func (foldr func start b)
13:53:21 <f0reclone> 	   
13:53:21 <f0reclone> instance Foldable FancyPart
13:53:21 <f0reclone>   where
13:53:21 <f0reclone>     foldr func start End = start
13:53:21 <f0reclone>     foldr func start (Add a b) = func a func foldr func start b
13:55:26 <f0reclone> lol banned for 6 messages
13:55:44 <mauke> f0reclone: 12 alone on my screen
13:55:49 <mauke> don't paste code into IRC
13:56:00 <EvanR> @where lpaste
13:56:00 <lambdabot> http://lpaste.net/
13:56:10 <mauke> it's also in the /topic
13:56:12 <f0reclone> so I did what you said and used func instead of +
13:56:23 <mauke> no, you didn't
13:56:38 <mauke> the way you wrote it, 'func' is just another argument in there
13:57:21 <mauke> e.g. 'func a func foldr func start b' is a single function (func) with 6 separate arguments (a, func, foldr, func, start, b)
13:57:24 <mauke> that makes no sense
13:58:08 <f0reclone> foldr func start (Add a b) = (func a) func (foldr func start b)
13:58:21 <f0reclone> like this?
13:58:33 <mauke> that's func called with 3 arguments: a, func, foldr func start b
13:58:51 <mauke> you want either 'func (func a) (foldr func start b)' (prefix notation)
13:58:57 <Tuplanolla> No.
13:58:59 <mauke> wait, no
13:59:05 <mauke> that's too funky
13:59:21 <f0reclone> sorry for my dumb questions
13:59:39 <f0reclone> working for hours on this and need to upload it in 1 hour
13:59:41 <ReinH> Please decrease funk levels by 10%.
13:59:46 <Tuplanolla> You should learn the basics like function application first, f0reclone.
13:59:50 --- mode: ChanServ set +o glguy
14:00:09 <rocket_man> funkytown
14:00:10 <mauke> this is all purely syntactic, btw
14:00:22 <mauke> 'a b c' is the same as 'a (b) c' or '(a) b (c)'
14:00:39 <ReinH> a and b are both f a's for a Foldable f
14:01:00 <mauke> 'a b + c d' is different because + is not a normal identifier, it's a symbol
14:01:11 <mauke> so it actually means '(+) (a b) (c d)'
14:01:20 <ReinH> So you need to foldr both the a and the b
14:01:30 <ReinH> you can use the result of folding one as the initial value for the other
14:03:06 <f0reclone> I understand that I need to user foldr on both FancyParts
14:03:36 <f0reclone> but when I'm implementing foldr on one Fancypart I need to apply the function somehow
14:03:58 <ReinH> applying the function is the job of foldr for FancyPart
14:04:25 <ReinH> foldr f (foldr f z a) z b
14:04:25 <f0reclone> foldr func start (Add a b) = func a (foldr func start b)
14:04:51 <ReinH> Oh, you're writing foldr for FancyPart?
14:04:55 <f0reclone> yes
14:04:59 <ReinH> It's exactly foldr for lists
14:05:06 <ReinH> with the names changed to protect the innocent
14:05:50 <ReinH> @src foldr
14:05:50 <lambdabot> foldr f z []     = z
14:05:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:06:03 <ReinH> Half of that looks like what you wrote.
14:08:35 <f0reclone>     foldr _ z End     =  z
14:08:35 <f0reclone>     foldr f z (Add a b) =  f a (foldr f z b)
14:08:45 <f0reclone> just changed to my datastructure
14:08:49 <ReinH> Looks about right.
14:09:40 <f0reclone> whats about this part in fancy?
14:09:41 <f0reclone>     foldr func start (Fancy a b) = func (foldr func start a) (foldr func start b)
14:10:22 <ReinH> You can fold the a's to get a value that you can then use as the initial value when folding the b's. See above.
14:10:50 <ReinH> But that should work too.
14:11:03 <f0reclone> you mean like this
14:11:03 <f0reclone>  (foldr func (foldr func start a) b)
14:11:06 <ReinH> in fact they are equivalent
14:11:09 <ReinH> Yes.
14:11:17 <ReinH> Either way.
14:11:38 <f0reclone> Thanks
14:11:55 <ReinH> There's a free theorem of foldr and ++ that applies, I think
14:12:28 <f0reclone> :r
14:12:37 <f0reclone> sorry false console
14:13:18 <Tuplanolla> I was wondering how I could easily define this without the `reverse`.
14:13:18 <Tuplanolla> > let hcd i ndim nper = let f inext idim | idim < ndim = let (q, r) = quotRem inext (nper Array.! (ndim - 1 - idim)) in r : f q (idim + 1) | otherwise = [] in f i 0 in reverse (hcd 42 2 (Array.listArray (0, 2) [6, 8]))
14:13:19 <mauke> s/false/wrong/
14:13:20 <lambdabot>  [5,2]
14:13:25 <mauke> (german detected)
14:13:37 <ReinH> Tuplanolla: I don't think I could easily define that at all.
14:13:40 <Geraldus> Hi folks!
14:13:56 <Tuplanolla> It maps linear indices to hypercubical indices.
14:14:58 <Tuplanolla> The example is for locating the index 42 in the (6, 8)-hypercuboid.
14:15:15 <Geraldus> I need to parse efficiently quite big CSV file over HTTP connection.  I want to read its contents by chunks, parse on the fly filling a buffer of upcoming DB insertions and send progress events over web socket
14:15:36 <Geraldus> Is there any suitable CSV parser already?
14:16:05 <jle`> how about cassava-conduit ?
14:16:13 <jle`> + conduit, of course
14:16:39 <jle`> cassava-conduit integrates chunky csv parsing w/ IO with conduits
14:18:05 <rblaze> cassava-conduit or Data.Csv.Streaming. I found second one a bit more performant, but conduit may be nicer to integrate into pipeline.
14:24:04 <Geraldus> jle`: Hi buddy!  Thanks.  I didn't noticed your response and studying Stackage's search result already
14:25:33 <zomg> in terms of coding style, does it make sense to write say Ord or Num instances for data types which hold various values incl. numeric data?
14:26:09 <zomg> or would it be preferable to instead do things thru getters, (getX foo) > (getX bar) for example
14:26:19 <Tuplanolla> Nobody is probably going to bother looking at that mess, but the essence of the problem is this: I fold an index down by dividing it until the quotient reaches zero; however this does not fuse well, because it goes in the wrong direction.
14:26:50 <Tuplanolla> Am I missing something obvious here?
14:27:26 <kugys86> Hi
14:27:48 <jle`> zomg: sometimes the actual canonical Ord instnace might not make too much meaningful sense for composite data types
14:28:03 <jle`> zomg: but having a legal Ord instance, no matter how arbitrary, is useful
14:28:14 <jle`> for things like using them as keys in a Map
14:28:18 <jle`> or items in a Set
14:29:06 <zomg> jle`: ok makes sense :)
14:29:12 <Tuplanolla> Number theory ruins the day again.
14:29:25 <jle`> Num instances might be weird though
14:29:53 <zomg> yeah I didn't actually do that for any yet and probably won't because it would get too complicated for the minor convenience it would afford :P
14:30:05 <jle`> usually you can just derive Ord and be ok with it
14:30:15 <jle`> if people want specific behavior, they can use getters like what you mentioned
14:30:20 <zomg> have a few Ords for things where it's nice to be able to compare or sort certain things, where they would almost always be compared or sorted by a specific criteria
14:30:43 <jle`> yeah most of my things that I have Ord instances for I never actually directly compare
14:30:52 <zomg> heh
14:30:57 <jle`> i just have it to let them be keys in maps, etc.
14:31:06 <jle`> i guess it's sort of like Hashable in that sense
14:31:20 <zomg> yeah that's a good point, I might want to use something else than plain lists and tuples at some point with this
14:49:24 <Zemyla> Yeah, that's why Complex needs to have an Ord instance.
14:49:51 <iqubic> But what would Complex's Ord instance do?
14:50:03 <jared-w> define a well ordering of the complex numbers, obviously /s
14:52:58 <Zemyla> iqubic: Compare them like a tuple.
14:53:19 <Zemyla> The fact that Complex has no ordering consistent with its Num instance is shown by the fact that it doesn't have a Real instance.
14:53:20 <jared-w> What's weird is that Complex already has a foldable and traversable instance...
14:53:54 <EvanR> so, why do we care about consistency with the Num instance
14:54:22 <EvanR> im not sure that comes up anywhere else in haskell
14:54:42 <EvanR> iqubic: ill tell you what it would do, compare the complex number lexicographically
14:54:55 <jle`> Complex should just have an arbitrary Ord instance so you can use them as keys in a map, etc.
14:54:58 <EvanR> because Complex Double = Double :+ Double
14:55:11 <jle`> Num is an awful typeclass anyways
14:55:19 <EvanR> its not like this Complex thing has any sort of nice properties like in math
14:55:45 <jared-w> Yeah this complex data type seems to just be there "to have complex numbers" rather than trying to represent the really nice math complex numbers? Am I wrong on that?
14:56:04 <EvanR> sure
14:56:05 <jle`> well, it has useful */+/-
14:56:08 <jle`> and division
14:56:20 <EvanR> you could have a matrix of Complex Double
14:56:23 <jle`> so you could generalize a Num a => a ... etc.
14:56:27 <EvanR> unboxed even
14:56:40 <jle`> any function writen to work with any numeric type can work with Complex, so that's kinda useful
14:56:43 <jle`> in a FORTRAN kinda way
14:56:49 <jared-w> EvanR: sure what? :p
14:57:42 <Zemyla> Also, according to this one article, ZipList has a valid Alternative instance?
14:58:21 <jared-w> Zemyla: what's the article?
14:58:31 <Zemyla> https://lirias.kuleuven.be/bitstream/123456789/499951/1/main.pdf
15:00:14 <jared-w> oooh neat
15:00:34 <Zemyla> @let instance Alternative ZipList where { empty = ZipList []; (<|>) = let { go [] ys = ys; go (x:xs) ys = x:go xs (drop 1 ys) } in \(ZipList xs) (ZipList ys) -> ZipList $ go xs ys }
15:00:35 <lambdabot>  Defined.
15:04:14 <davr0s> haskel, structs..  is it possible to (template haskell ?) to automatically roll 'class HasFoo / foo accessors ... would it be restricted to the accessor having the same signature .. that would be ok IMO
15:05:19 <davr0s> just messing with haskell again.. the last time I tried it the pattern was 'wow.. wow.. wow.. ok; now i want to do something with structs.. yikes, ok i'll go back to rust,C++.'
15:05:40 <pikajude> haskell doesn't have structs
15:05:43 <pikajude> are you talking about record types
15:05:58 <davr0s> struct .. record.. whatever you call it around here
15:05:58 <Tuplanolla> Classy prisms, perhaps, davr0s?
15:06:03 <geekosaur> most of the lens packages (not just ekmett lens) come with TH glue to do that for you, assuming you mean records
15:06:06 <pikajude> what are you trying to do mate
15:06:29 <davr0s> ok, 'records' to fit in around here :)
15:07:04 <fresheyeball> Prisms of the proletariat not good enough for you eh?
15:07:09 <davr0s> i've seen how you can 'destructure' to get field access
15:07:14 <jared-w> Like geekosaur said, most of the lens implementations do have TH glue to do that sort of thing
15:07:19 <fresheyeball> Got to use those Classy prisms 
15:07:30 <pikajude> actually
15:07:38 <pikajude> couldn't you use OverloadedLabels to define getters now?
15:07:47 <pikajude> people don't do that do they
15:08:32 <jared-w> Pretty sure they don't because it's not as powerful or convenient as lenses
15:08:52 <pikajude> well you can't define lenses operating on different types with the same field name
15:08:54 <pikajude> very easily anyway
15:09:03 <geekosaur> or just because it's still new *and* everyone's waiting for the rest of OverloadedRecordFields
15:09:05 <pikajude> not without a bunch of IsFoo x instances, which are annoying to resolve when there are errors
15:09:07 <jared-w> https://www.reddit.com/r/haskell/comments/4x8tk8/overloadedlabels_considered_awesome/ 
15:09:18 <pikajude> wish we could just get tdnr
15:09:22 <jared-w> oh whoops, apparently there are issues for it :p
15:09:28 <glguy> no thanks to tndr
15:09:28 <jared-w> tndr?
15:09:39 <pikajude> type-directed name resolution
15:09:43 <pikajude> i think
15:10:21 <pikajude> it would just mean that if you use a record accessor or updater, it would determine which one you mean based on the type of the argument
15:10:21 <davr0s> lenses seemed a bit daunting, i dont need so much right now;  i think it's just this initial step of declaring a bunch of named fields.   Not so interested in mutation right now
15:10:36 <pikajude> along with a massive host of other problems that i don't know about because i've never used a language with tdnr
15:11:12 <geekosaur> yes, and it's been rejected multiple times because of the problems it causes
15:11:21 <pikajude> there you go
15:11:30 <geekosaur> but people want them anyway and will continue to demand TDNR as the only correct solution right up until they get it *and* it bites them
15:11:40 <geekosaur> then WHY DIDN'T ANYONE WARN ME yada...
15:11:49 <pikajude> i can just get started early
15:11:49 <EvanR> then thats what should happen
15:11:52 <pikajude> i demand tdnr
15:11:54 <jared-w> Are there any other solutions besides TDNR?
15:11:56 <pikajude> why didn't anyone warn me how annoying it would be
15:12:01 <davr0s> i know plain records work ok so long as the field names dont clash, right?
15:12:04 <pikajude> jared-w: not ever naming record fields the same thing
15:12:05 <EvanR> build in a self destruct into the TDNR feature for the eventuality
15:12:10 <pikajude> that's the solution
15:12:15 <pikajude> keep all your names unique
15:12:32 <jared-w> unique in the module or unique in the haskell univese? I'm not quite sure how far the uniqueness has to go
15:12:36 <EvanR> for the specific case of record fields, a record system would probably make more sense
15:12:43 <pikajude> unique as far as what else will be in scope when you want to use it
15:12:46 <pikajude> you can always manually qualify the names
15:12:47 <EvanR> than TDNR
15:13:00 <pikajude> but you cannot (without OverloadedRecordFields) define two records with a field of the same name in the same module
15:13:05 <davr0s> if i can just go one step up to:   'sharable field names so long as their accesors have the same signature' (i.e. i'm manually rolling 'class HasFoo' at the minute..)  .. that might be enough for me
15:13:08 <pikajude> you could use two in the same module, but not define them
15:13:17 <pikajude> davr0s: you can already do that
15:13:25 <pikajude> if you define the same field on different variants of an "enum type"
15:13:30 <pikajude> as long as they have the same type it will work
15:13:33 <EvanR> idiomatically, you dont want to qualify the name, just make it uniqueish
15:13:38 <pikajude> i believe it'll even work if they have different types, you just get a runtime error instead :)
15:13:53 <davr0s> let me see what it will do.. 
15:14:23 <jared-w> Wait, so if I make a record with an `id` field and stick it in a module, if anyone else ever imports that module, they can't use that name?
15:14:24 <pikajude> no, it doesn't work if they have different types, i was wrong
15:14:33 <pikajude> jared-w: they'd have to import qualified probably
15:14:39 <davr0s> I have other questions like "could a strict subset of haskell work with rust-style unique-ownership/borrows .. see 'linear lisp' "
15:14:39 <pikajude> if you don't actually use id anywhere in the module it doesn't matter
15:14:58 <pikajude> @let data Foo = Foo { a :: Int } | Bar
15:14:59 <lambdabot>  Defined.
15:15:01 <pikajude> > a Bar
15:15:03 <lambdabot>  error:
15:15:03 <lambdabot>      Ambiguous occurrence ‘a’
15:15:03 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
15:15:06 <pikajude> oh, right.
15:15:09 <pikajude> damn it
15:15:11 <EvanR> jared-w: there are several situations, the first one is "ambiguous reference id"
15:15:12 <jared-w> lol
15:15:13 <pikajude> anyway, that will throw a runtime error
15:15:19 <EvanR> ambiguous occurrence
15:15:21 <pikajude> so you just have to be careful about that
15:16:05 <jared-w> Not sure how I feel about having to be careful to avoid runtime errors in Haskell. I'm sure it's not really a huge deal because nobody's died from it so far, but it just smells a bit weird at first
15:16:29 <pikajude> haskell doesn't have wide enough adoption to kill anyone
15:18:00 <davr0s> if i just declare 2 records  with { name::String }  .. it spits out an error ('mutliple declarations of name') . i tried making a 'class HasName x..  name::x->String',   as far as I know if you just declare a record it's unconnected to that, right
15:18:03 <athan> jared-w: If you want to banish runtime errors to the forbidden realm, I suggest using something with higher concentration of thinking parts, like idris or liquid haskell
15:18:11 <pikajude> davr0s: uh huh
15:18:15 <pikajude> you can also define them in different modules
15:18:17 <pikajude> or use OverloadedRecordFields
15:18:45 <glguy> The extension would be DuplicateRecordFields
15:19:20 <pikajude> sorry
15:19:22 <pikajude> you're right
15:19:28 <pikajude> been a long time since i wrote any haskell
15:20:07 <davr0s> how do i enable an extention, (i seem to rememer 'multiparameter type classes' aswell)
15:20:22 <glguy> {-# Language DuplicateRecordFields #-}
15:20:41 <davr0s> ok found it. thanks.
15:21:40 <pikajude> isn't it all caps language
15:21:44 <pikajude> or does it not matter??
15:21:49 <glguy> No, you don't have to shout it
15:22:05 <pikajude> everyone always seems to
15:22:19 <Tuplanolla> Capital H, capital A, capital SKELL.
15:22:21 <glguy> People are learning
15:22:33 <jle`> LANGUAGE is pretty common, and my autocomplete plugin defaults to it
15:22:37 <jle`> but i've also seen 'language'
15:22:46 <pikajude> i would want to capitalize it
15:22:46 <glguy> I think people capitalize it because they don't know they don't have to
15:22:52 <pikajude> i'm pretty sure the extension names need to be capitalized properly
15:22:53 <jared-w> Mine does too. It looks more right to me because I'm used to C #DEFINE
15:22:57 <pikajude> if Language weren't, it would look very odd
15:23:15 <geekosaur> but C normally does it lowercase
15:23:26 <pikajude> yeah
15:23:26 <geekosaur> I prefer the uppercase to make it stand out a bit
15:23:28 <pikajude> i've never seen #DEFINE
15:23:37 <pikajude> they're usually bright orange in my editor so they generally stand out
15:24:00 <jle`> i like it because it reminds me of when i programmed in fortran 77
15:31:07 <user____> hello!
15:31:50 <lambdabot> Hello.
15:32:47 <user____> I'm trying to create my first project, and I'm falling at the first hurdle... I've started a project using stack, and I'd like to use the aeson library. The problem is I don't know how to add this to the project (projectname.cabal vs stack.yaml), and then how to import it in the source.. 
15:33:24 <user____> there are no obvious solutions in my google searches, no from-scratch tutorials on how to use stack to add a lib that I can find
15:33:32 <user____> any suggestions would be greatly appreciated
15:33:33 <boj> user____: you can add "aeson" to the build-depends part of your cabal file
15:33:53 <boj> user____: stack will then download that for your project, and you can import Data.Aeson as you like
15:34:32 <user____> boj: is it literally as simple as appending ', aeson' to the end of the list?
15:34:38 <boj> user____: yep!
15:34:50 <jared-w> oh whoops, in C you usually have #define CONSTANT, nvm. Either way, all caps look mostly normal to me because of C  ¯\_(ツ)_/¯
15:35:05 <glguy> user____: The first stack tutorial that came up when I googled for it has a section on adding "3rd party code" to your project: http://seanhess.github.io/2015/08/17/practical-haskell-importing-code.html I'm qualifying that result not to shame you but to disclaim how good the tutorial is
15:35:18 <glguy> I looked at the part about adding a package and it is correct
15:35:22 <hariel> so ive been struggling trying to install hoogle with stach
15:35:31 <hariel> https://pastebin.com/JdCmsc2y
15:35:35 <hariel> stack*
15:37:01 <user____> glguy: thank you for that link. I must admit I did find that result and discard it because at the time I thought I wanted stack to manage the dep
15:37:45 <glguy> user____: stack is just a wrapper around everything, it manages your particular working directory. You'll still be defining packages with the Cabal library
15:37:49 <user____> boj: thanks for the confirm
15:38:01 <user____> glguy: I see
15:38:04 <boj> user____: yep, good luck
15:38:33 <boj> admittedly the cabal/stack/Cabal-the-Library stuff is a bit confusing at first
15:39:31 <geekosaur> jares-w, even that is merely convention.
15:39:44 <geekosaur> er, typo. gg 
15:39:52 <geekosaur> jared-w
15:40:27 <hpc> boj: the terrible thing is it's a really easy to understand distinction... if something more discoverable would spell it out for people
15:40:46 <jared-w> lol. Yeah I know it's convention, but you see it almost religiously. In any case, I'm going to be using Language over LANGUAGE wherever I can. I like it better.
15:40:50 <boj> hpc: yup, agreed
15:40:58 <hpc> the Cabal package saying users should look for cabal-install would help immensely
15:41:05 <geekosaur> people remember the convention but forget why it exists
15:41:22 <geekosaur> hands up all you geezers who remember #define sun 1 :p
15:41:34 <hpc> i... what
15:41:51 <hpc> i have a feeling that's more interesting than just OS detection
15:41:56 <geekosaur> yes
15:42:18 <geekosaur> 4.2BSD code written on Vaxes liked to abbreviate the names of variables for socket address structs
15:42:31 <geekosaur> so 'sin' for Internet sockets, 'sun' for AF_UNIX sockets, etc.
15:42:34 <geekosaur> Enter SunOS.
15:43:47 <boj> geekosaur: is this a showing your age comment or are you just an os nerd that knows wild trivia?
15:43:59 <user____> see, I think I'm using it correctly after all, that link you gave me has an assignment at the very botton, and I'm trying to do just that assignment.. except that I'm trying to use aeson in the src/Lib.hs file rather than the app/Main.hs file
15:44:01 <geekosaur> we got both the uppercase and leading _ (and later, leding __) out of that one
15:44:11 <user____> I assume I'm not exposing it properly, but I'm not sure where I do that
15:44:37 <user____> adding the import to src/Lib.hs gives an error when I try to `stack build` it
15:44:38 <geekosaur> showing my age and saying why (in response to earlier comment) C #fdefine-s are generally UPPERCASE
15:45:01 <geekosaur> when there are no conventions, you can get some fairly amusing portability issues :)
15:45:01 <boj> user____: note that there is a "libary" and "executeable" section in your cabal file
15:45:18 <boj> user____: you have to add the right library to each build-depends in each section
15:45:21 <user____> boj: dow
15:45:35 <boj> geekosaur: that explains the 'saur' part of your name then :)
15:46:03 <user____> boj: yep that's solved it. thanks again!
15:47:14 <Tuplanolla> It's not a plea to get GeekOS into AUR?
15:48:05 <deech> Hi all, does anyone know how to specify a version of a build tool in stack.yaml? For instance, I'm using a older resolver but need to build the newest version of `c2hs`. 
15:48:53 <boj> deech: i suppose you'd modify the lts version in your global stack config
15:49:32 <geekosaur> does simply specifying it as an extra-dep not work? might also need a setup-depends
15:49:42 <jared-w> yeah I just modify my lts version every now and then. I'm not doing any big important stuff in stack yet where I need to care about being specific with lts versions
15:50:06 <nshepperd_> geekosaur: and delightful error messages about "int 1;" being a syntax error instead of anything comprehensible :)
15:50:18 <geekosaur> yep :)
15:50:33 <geekosaur> although it was sockaddr_un, not int
15:50:56 <geekosaur> well, struct sockaddr_un. no C++-inspired shorthanding back then :)
15:52:01 <jared-w> fascinating
15:52:35 <jared-w> I think it's important to know a decent amount of history of things like that, if for no reason than to be thankful that you never have to do that kinda nonsense anymore
15:52:53 <jared-w> (inb4 someone brings up modern embedded programming)
15:53:16 <Tuplanolla> Speak for yourself, jared-w. I have preprocessor directives clashing with dummy parameter names in OpenGL prototypes right now.
15:53:21 <geekosaur> just write it in atom :p
15:54:27 <jared-w> eh, low level graphics feels close enough to not really count, to me :p
15:54:51 <jared-w> Like sure, if you intentionally fall down that rabbit hole, you're going to find some dark and weird stuff...
15:55:07 <Tuplanolla> Sometimes it's so bad it's good.
15:56:53 <deech> geekosaur, boj: That didn't do it. I x-posted on #haskell-stack. Thanks!
16:06:36 <user____> okay I'm logging out now, thank you again for the help!
16:13:10 <davr0s> can haskell typeclasses 'overlap' / or 'inherit from eachother'  e.g. see Rust where you say trait X : Y  {}   .. applying a bound T:X  allows the use of T:Y aswell
16:16:27 <suzu> overlap - yes
16:17:12 <suzu> if you mean "if X is in typeclass Y do this thing, but if not do this other thing"
16:17:14 <sproingie> classes can inherit by using another class as a constraint, but there's no inclusion, i.e. specifying Num won't automatically give you Enum or Ord.  there's extensions that let you use a typeclass as a kind
16:17:28 <geekosaur> however the question makes me wonder if you are trying to use typeclasses for OOP; you are headed for pain, the typesystem does not work that way
16:18:31 <suzu> OverlappingInstances can be dangerous and if you need to use it you're probably trying to nail something with a shovel
16:18:48 <davr0s> i dont think i'm trying to do OOP, but what I am trying to do is get some overlapping functionality between some types, 
16:19:00 <sproingie> er i'm wrong, you do get the superclass applied automatically, i.e. if you have Monad, you get all operations on Functor too
16:19:44 <davr0s> so i have a 'vector3 type' e.g. the sort of thing you'd do as struct {x,y,z blah bah} in c++,
16:19:46 <sproingie> what is it you're trying to do?  classes may or may not be the answer
16:20:07 <davr0s> then i'm making a 'vertex' type that contains non-homogeneous data (e.g. Position, Normal, Color...)
16:20:23 <davr0s> the vector type should support vector arithmetic..
16:20:28 <sproingie> might want to see how GPipe does it
16:20:44 <davr0s> the *vertex* type should support some functions that look like vector arithmetic, but not all
16:20:59 <davr0s> e.g. 'lerp' .. it's perfectly reasonable to interpolate 2 vectors or 2 vertices
16:21:12 <davr0s> 'cross product' .. nope , only vector3 should do that..
16:21:15 <davr0s> and so on
16:21:39 <davr0s> i've got my 'vector3 etc' doing what i want
16:21:49 <jared-w> Sounds like you're trying to do OOP with functional programming, then :p
16:22:30 <jared-w> You're trying to make a set of functions that only work on certain "objects" when really, all you need to do is make functions that work /with/ certain types. 
16:23:00 <jared-w> anyway I gotta head off
16:23:18 <davr0s> hmmm.
16:23:27 <nshepperd_> davr0s: sure, you can do algebraic hierarchies with typeclasses
16:24:13 <sproingie> eh, something you can lerp sounds like linear algebra, why should that be second-class?
16:24:29 <davr0s> sproingie is that directed at me or other
16:24:33 <nshepperd_> like vector space, which supports interpolation, vs inner product space which supports sizes
16:25:17 <davr0s> my current idea is that many things are 'lerpable', but you can 'lerp' some things that you might not necaserily be able to do all the usual vector maths on
16:25:49 <Axman6> davr0s: not sure if I'm completely understanding, but classes can specify that to be an instance of them, a type must first be an instance of another class. the classic example is Ord, the class for types which can be ordered, must first define Eq for the types. so we have class Eq a where ... and then class Eq a => Ord a where
16:26:35 <davr0s> so that example 'class Eq a => Ord a where '  is basically rust  trait Ord : Eq { ...} ?
16:26:58 <sproingie> FP approach here would be to consider what makes something lerpable then: it's a vector.  doesn't matter that it's a vertex or not
16:27:12 <Axman6> if tha says "Something which implements ORd must first implement Eq" then yes
16:27:17 <Axman6> Ord*
16:27:46 <davr0s> so here i could have  'class VertexOps...'   ..   class VertexOps a => VectorOps a   -- 
16:27:58 <davr0s> Axman6 yes thats what it's saying
16:28:03 <Axman6> yep
16:28:56 <davr0s> ok let me see how that pans out. (i'm sure there's more possible r.e. a pattern here too, but i'll get on to that later)
16:28:58 <sproingie> and it's a perfectly good use of type classes
16:29:20 <sproingie> what people get in a snit about is when it goes as far as heterogeneous collections
16:29:31 <sproingie> mostly because it's a brittle half-assed way of doing it
16:31:27 <nshepperd> class AffineSpace v where { lerp :: Double -> v -> v -> v }
16:31:45 <NemesisD> is hackage's package servers exhibiting issues for anyone else?
16:32:05 <NemesisD> for instance, requests to https://hackage.fpcomplete.com/package/transformers-compat-0.5.1.4.tar.gz seem to be timing out, but only over https
16:32:16 <nshepperd> class AffineSpace v => VectorSpace v where { zero :: v; plus :: v -> v -> v; scale :: Double -> v -> v }
16:32:20 <nshepperd> etc
16:33:28 <nshepperd> you can break it down further by putting zero and plus into a "class AdditiveGroup" and making (AffineSpace v, AdditiveGroup v) => VectorSpace
16:34:05 <nshepperd> and maybe parametrize the scalar type with MultiParamTypeClasses instead of fixing it to Double
16:37:05 <EvanR_> associated type synonyms (filed under type families) is a really good way to talk about "the scalar type for my vector space type"
16:38:00 <EvanR_> (*) :: VectorSpace t => Scalar t -> t -> t
16:39:53 <EvanR_> though for real life i would settle for a single sane familiar vector space like V4 Double
16:40:06 <EvanR_> (not really a vector space but youd pretend)
16:41:17 <nshepperd> cross product is probably better off as a standalone function since it only works on V3
16:42:29 <nshepperd> unless you want to try and figure out how to write the generalized version that takes (n-1) vectors in R^n as a polymorphic function
16:43:09 <EvanR_> you could go further and formalize exterior products and stuff
16:43:28 <EvanR_> or try to
16:49:40 <davr0s> https://gist.github.com/dobkeratops/e6f4c007399c2b12e05f0f7b56d181ef  ... here's what i'm trying,  the 'rust equivalent' listed below..
16:52:34 <davr0s> current attempt  "instance VectorOps v => VertexOps v where
16:52:34 <davr0s> " .. i.e. trying to implement VertexOps functions where 'VectorOps' is supported.. tells me 'expecting one more argument to v' then tells me 'one fewer' if i provide one more lol.
16:53:12 <Logio> nshepperd, EvanR_: or even go to clifford algebras for all the jazz of having scalars and vectors in the same space
16:54:32 <davr0s> EvanR_ ah 'associated types', sure we get them in Rust, and i'd have used someting like that in C++
16:54:44 <davr0s> inner typedefs carring the template parameter etc ect
16:55:14 <nshepperd> davr0s: your VertexOps appears to be not providing a type parameter, even though VectorOps provides one?
16:55:53 <pacak> davr0s: "instance VectorOps v => VertexOps v" - that's not going to work.
16:56:05 <davr0s> yeah i've discovered it doesn't work
16:56:27 <pacak> https://hackernoon.com/typeclass-instance-selection-fea1068920e6 - maybe reading this help.
16:57:00 <davr0s> what i'm trying to say is "for any type 'v' that supports Vector Ops,  implement Vertex Ops like this : ..."
16:57:20 <pacak> davr0s: You can't say that.
16:57:36 <pacak> At least not directly.
16:57:51 <EvanR_> davr0s: im not sure thats the same thing
16:58:13 <davr0s> hmm.  i have the equivalent sort of thing in rust, i had thought rusts 'trait' system was more limited than haskell but concepts would go across 
16:58:49 <pacak> What you are saying means "There is only one possible instance for VertexOps v, and for that instance we need ..."
16:59:12 <davr0s> whatever the names of the two things..  the scenario is  'one set of functions', 'another set of functions which *may* be implemented in terms of the first, if availabl,  or implemneted completely differently otherwise'
16:59:59 <pacak> newtype
17:00:08 <nshepperd> you have a kind error, trying to using VectorOps v and VertexOps v with the same v
17:00:26 <nshepperd> but setting that aside, no you can't do that sort of "default" implementation
17:01:00 <nshepperd> you need to write an 'instance VertexOps' for whatever types you want to support it
17:02:46 <nshepperd> but you can write a function called defaultLerp that uses VectorOps, so that each such instance can be a trivial 'instance VertexOps MyType where { lerp = defaultLerp }'
17:03:44 <davr0s> if i just put the same functions in both typeclasses, i think it starts telling me 'duplication..'
17:03:54 <davr0s> i *could* just make new functions
17:03:55 <geekosaur> yes
17:04:25 <davr0s> make the 'lerp, min, max' that apply to verticse or vectors  completely different functions
17:04:36 <davr0s> vtlerp   vs vlerp  or whatever.
17:05:13 <davr0s> i can get on with 'doing stuff'..   but nonetheless I'm interested to know the possible approaches here.
17:13:00 <robkennedy> I have a module which produces fine aberrant results with `-O`, but fine results with `-O0`. More inexplicably, it produces bad results with no flags, but the correct results if I compile with `-O0 -fno-ignore-interface-pragmas -fno-omit-interface-pragmas -fsimplifier-phases=2`. What explains this behavior?
17:15:21 <nshepperd> davr0s: your comment on VectorOps is correct, by the way
17:15:51 <nshepperd> those functions are basically a combination of standard Applicative and Foldable functions
17:16:17 <nshepperd> so VectorOps f could be replaced with (Applicative f, Foldable f)
17:16:44 <davr0s> i've already seen 'Functor' / 'fmap';    liftM2 seems to ring a bell and hoogle found that for the signature
17:17:48 <davr0s> so i jsut need to implement 'Applicative, Foldable' for my vector types, and I can just talk about those?   .. (would there be anything else 'VectorOps' might imply that those dont cover.. would it be *too* general?)
17:18:17 <davr0s> i was writing things like this , "vadd v0 v1 =vbinop (+) v0 v1"
17:19:03 <EvanR_> liftA2 (+) v1 v2
17:19:33 <davr0s> ok thanks
17:19:39 <EvanR_> sometimes (+) = liftA2 (+) just works
17:19:48 <EvanR_> as part of a Num instance
17:20:08 <EvanR_> other times you want to just write liftA2 (+) everywhere
17:20:18 <davr0s> yeah i found that sort of thign sometimes, but writing out arguments seemed to help it more (telling me about constraints it could not guarantee yada yad)
17:21:08 <davr0s> i'll fudge over my 'vlerp' by just making another function name and look into this 'applicative/foldable' stuff, i figure i've more to gain from finding my way around all that.
17:21:11 <nshepperd> vbinop is just liftA2
17:21:35 <nshepperd> vreduce is basically foldr except ignoring the possibility that it could be empty
17:21:49 <nshepperd> vscalarop is fmap but in a weird format
17:30:19 <EvanR_> https://www.quora.com/How-is-state-represented-in-FRP-Can-you-have-something-like-the-state-monad-in-FP/answer/Conal-Elliott
17:30:50 <EvanR_> feels like we havent done too much FRP in here in a while
17:31:31 <MP2E> very neat answer
17:33:09 <zomg> I've heard a lot about how typeclasses are nothing like classes, however does it make sense to represent an interface of sorts with a typeclass? Eg. I have a set of APIs which all do ~roughly the same thing, and I want a way to represent the results with an associated type for each API
17:34:00 <zomg> Mainly I was thinking of some ways of making it so the types could help avoiding mixing results from different APIs. Not sure if it makes sense or not :)
17:34:19 <EvanR> well, then you need phantoms
17:34:32 <EvanR> since nothing stops two instance form using the same result type
17:35:06 <zomg> Yeah
17:35:14 <thekyriarchy> when can we be good enough for codecademy? https://twitter.com/thekyriarchy/status/877989134215692288
17:36:40 <zomg> I was thinking if something like class Api a where apiStuff :: Result a ... makes sense, with things like data ApiFoo .. instance Api ApiFoo where apiStuff = whatever
17:37:39 <zomg> What led me to consider a typeclass for this is certain apis may have extra functionality, which seems like a reasonable typeclass, (Api a) => HasMethodBar a
17:37:51 <zomg> Seems being the operative word =)
17:38:32 <EvanR> thats getting kind of inheritance yucky
17:38:52 <zomg> Yeah, I suppose it wouldn't necessarily need the constraint for Api a in that
17:39:18 <EvanR> you might want to look into extensible records, which can give more fluid record types
17:39:52 <EvanR> records being poor mans interface
17:40:17 <EvanR> record types being poor mans interface, record value being implementations
17:41:23 <zomg> Thanks - I'll look that up. What would be the reasoning for preferring that over a typeclass? That sort of stuff isn't usually included in most of the articles on this stuff
17:42:46 <EvanR> people start to go for typeclasses first because it has the word class in it, then they realize its more like an interface, and they probably stop there
17:43:08 <EvanR> many times its more practical, more flexible to use a record for the same purpose
17:43:23 <EvanR> typeclasses are implemented as invisible records
17:43:39 <EvanR> if you make them visible, you get more control
17:44:10 <Lokathor> once again someone said something to me after i went to work, and my scroll history no longer contains the message
17:44:12 <Lokathor> sadness
17:44:24 <EvanR> channel logs
17:44:47 <Lokathor> hmm
17:44:53 <Lokathor> i wonder how i open those in hexchat
17:45:13 <EvanR> probably better to keep your own logs
17:45:19 <mniip> $HOME/.config/hexchat/logs
17:46:02 <Lokathor> i wonder where the windows version of that directory is :P
17:46:09 <Lokathor> EvanR, what do you mean "my own" logs?
17:46:20 <EvanR> originally, i was talking about the logs in the topic
17:46:24 <EvanR> public logs
17:46:34 <mniip> %userhome% or %appdata%
17:47:04 <Lokathor> apppdata doesn't have an obvious directory
17:47:05 <Lokathor> hmmm
17:48:36 <mniip> Lokathor, ask in #hexchat i guess
17:49:13 <Lokathor> well, if it was really important, they'll message me again about it probably
17:51:01 <Hafydd> Lokathor: 16:02:04 <Lokathor> sproingie, also i'm about to leave for work so i can't offer much more help XD 16:03:13 <sproingie> Lokathor: aha there it goes :) 16:04:50 <sproingie> Lokathor: i'll poke around with hexes some more today now that i know it's actually working :)
17:51:21 <Lokathor> Hafydd, you're so kind
17:51:38 <Lokathor> I should make a bot that just writes down what people said when they say my name
17:53:04 <davr0s> ok I re-expressed my 'vscalarop' using 'fmap', that worked,
17:54:46 <davr0s> but for 'liftA2' ... docs tell me  "liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c"    .... and...  "class Functor f => Applicative f where"   
17:55:28 <davr0s> does that mean I have to instance 'Applicative' to get 'liftA2',  or does it generate that from 'Functor' (currently it tells me Applicative isnt' found etc etc etc)
17:55:48 <Lokathor> for liftA2 to work you need an Applicative instance, yes
17:55:59 <Lokathor> some Functors aren't valid Applicatives
17:56:13 <davr0s> ok deleting a couple of cases, it's finding liftA2.
17:56:23 <davr0s> (let me just verify that..)
17:59:55 <davr0s> hmm.   'Applicative' talks about 'sequential operations' etc etc.  is this beyond the scope of a 'vector3{x,y,z}' type.
18:00:47 <iqubic> davr0s: Is that a Doctor Who reference?
18:00:54 <davr0s> iqubic yes that is.
18:00:57 <sm> Lokathor: there's already a bot, it just needs a maintainer. http://ircbrowse.net/browse/haskell
18:01:19 <iqubic> sm: What does a bot maintainer do?
18:01:27 <Lokathor> sm yeah expand on that sentence
18:01:30 <davr0s> do I just need 'liftM2' , rather than 'liftA2' for my 'function to apply a function to every component of a pair of vectors'
18:02:10 <iqubic> davr0s: I think you want sequence
18:02:29 <sm> ircbrowse stopped logging a while back, as you can see at http://ircbrowse.net/browse/haskell?events_page=688747. Chris Done got too busy, somebody new is needed
18:02:51 <sm> sysadmin work, basically
18:02:59 <Lokathor> well, I don't want a bot that logs everything, that seems like too much
18:03:27 <iqubic> I don't like sysadmin work.
18:03:28 <Lokathor> I think I'll just make a bot in Elixir that subscribes to my usual channels on my usual servers, and then write down when it sees my name
18:03:32 <sm> you can search this one by username. But feel free to write your own :)
18:03:35 <iqubic> Blerg.
18:04:00 <Lokathor> my haskell IRC bots always have connection stability issues :/
18:04:07 <iqubic> Lokathor: How do you have a bot that subscribes to a channel? Isn't that illeagal?
18:04:08 <davr0s> now i see something called '''Traversable'
18:04:16 <sm> yep, it's not that easy
18:04:18 <sm> just think of the glory if you fixed this one for all of haskelldom!
18:04:57 <Lokathor> sm, well the socket library is supposed to report when a socket fails to read because it closed... but it doesn't >_< and I tried to make a supervisor thread that killed and restarted the socket if it took too long... but it didn't supervise right
18:04:59 <Lokathor> le sigh
18:05:19 <Lokathor> iqubic, what do you mean illegal? lambdabot is a bot in several channels, no one cares about her
18:06:35 <iqubic> How does the bot work? How do you write code that connects to a channel and parses what people say?
18:07:18 <Lokathor> oh
18:07:36 <Lokathor> well IRC can be connected to with a plain socket, and then bytes go in and out, and there's a format and all
18:07:37 <davr0s> (i see foldable has stuff for 'non-empty structures' , foldr1 foldl1, ... thats the case i needed for my fixed size vec3,vec4 i suppse..)
18:07:57 <Lokathor> there's a few RFCs covering it if you look them up
18:08:32 <Axman6> How do you google things?
18:08:39 <Axman6> I'm still not sure
18:09:00 <Lokathor> hey now
18:09:18 <Lokathor> if they'd asked about Discord the answer would be "madness lies that way" instead of "it's easy to look up"
18:09:25 <Lokathor> so there's that
18:12:13 <glguy> iqubic: The code for parsing and generating IRC messages for the client you're using is available as a library
18:13:22 <Lokathor> (it's also easy enough to write yourself if you have the time, IRC is an extremely simple format)
18:13:50 <nshepperd_> davr0s: liftA2 is the better (more general) one
18:14:05 <nshepperd_> "Sequentialness" isn't required
18:14:48 <Axman6> davr0s: iqubic has sent you down the wrong path. I'm assuming you have (Vector a, Vector a)? your question is a bit ambiguous
18:16:36 <davr0s> r.e. 'liftA2': seeking replacement for my 'vbinop (a->b->c) -> v a -> v b -> v c' which is just applying a function to components of 2 fixed-size vectors .
18:16:54 <Lokathor> that's liftA2 alright
18:17:29 <Lokathor> or.. well maybe do you want it to zip them?
18:17:33 <Lokathor> :t zipWith
18:17:34 <Axman6> yeah that looks like liftA2 (assuming that you are using a ZipList style Applicative isntance)
18:17:34 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
18:18:10 <Axman6> > zipWith (\a b -> show a ++ show b) [1..4] "abc"
18:18:12 <lambdabot>  ["1'a'","2'b'","3'c'"]
18:18:18 <Axman6> > liftA2 (\a b -> show a ++ show b) [1..4] "abc"
18:18:20 <lambdabot>  ["1'a'","1'b'","1'c'","2'a'","2'b'","2'c'","3'a'","3'b'","3'c'","4'a'","4'b'...
18:18:30 <Axman6> so, perhaps you do not want liftA2
18:18:48 <Lokathor> depends on how long you think (v c) is
18:19:05 <Axman6> yeah
18:19:16 <Axman6> davr0s: should the result be the same size as the inputs?
18:19:24 <davr0s> Axman6 yes absolutely   i know the length is fixed size; there's 3 versions -  Vec2, Vec3, Vec4 ;
18:19:36 <zomg> EvanR: thanks! I've heard the "people go for typeclasses because class..." before which was basically why I was wondering about this approach, but didn't know the rest - good stuff :)
18:19:39 <Lokathor> then you want something more like zipWith than like liftA2
18:19:40 <davr0s> e.g. '3d vector + 3d vector ->  3d vector'
18:20:03 <Axman6> ok, so you probably want a zip
18:20:24 <Axman6> (or, to make your applicative instance use the zip implementation instead of the cartesian product one)
18:20:37 <nshepperd> Axman6: these are fixed size vectors
18:20:40 <Axman6> since they're fixed size the zip one makes sense
18:20:49 <nshepperd> their Applicative instance is necessarily zippy
18:20:52 <Axman6> nshepperd: yes, in understand that
18:21:07 <Axman6> well, not necessarily
18:21:11 <nshepperd> the cartesian product one is impossible
18:21:30 <Axman6> it could be the diagonal combinations for example
18:22:46 <davr0s> zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c  ,  i see other stuff talking about lists but this isn't a generl purpose list.
18:23:55 <nshepperd> diagonal combinations?
18:25:14 <n_blownapart> hello is the recursive let the only place in which recursion happens in haskell or does it happen elsewhere?
18:25:18 <davr0s> still not sure what to implement here :)
18:25:23 <davr0s> liftA2,  zipWith
18:26:06 <davr0s> liftA2,  zipWith  ;    'Applicative' ?,   'Monad?'   ... 'Seq?'
18:28:16 <Axman6> n_blownapart: well, functions can be recursive
18:28:20 <Axman6> @src map
18:28:20 <lambdabot> map _ []     = []
18:28:21 <lambdabot> map f (x:xs) = f x : map f xs
18:29:02 <Axman6> davr0s: I'd implement Applicative where (<*>) combines elements pairwise (which means liftA2 = zipWith)
18:30:38 <n_blownapart> Axman6, ok thanks I'm reading something that defines something I never quite understood: a closure. I never got it while studying some scheme
18:30:48 <davr0s> ( here's what i have at the minute again,  https://gist.github.com/dobkeratops/6aa63bf402968d31521fbbd69dbd505c)
18:31:00 <n_blownapart> it defines it well...simply
18:31:07 <davr0s> Axman6 ok i'll try that..
18:31:12 <divVerent> .pl \ self f l -> if empty l then [] else head l : self f (tail l)
18:34:21 <davr0s> all the docs about 'Applicative' are talking about composing operations etc etc 
18:36:11 <n_blownapart> Axman6, one thing, in the lambdaBot readout what is that underscore is that part of the code?
18:39:30 <divVerent> .pf fix $ \ self f l -> if null l then [] else f(head l) : self f (tail l)
18:39:48 <divVerent> damn, how DID this work again, want to see if it notices that this is "map" :P
18:39:57 <geekosaur> "@pl"
18:40:23 <geekosaur> n_blownapart, it's a wildcard, it matches anything and doesn't bother to bind it to a name
18:40:45 <geekosaur> since in the first map case it doesn't matter what the function is, we just produce an empty list without using the function
18:41:45 <zomg> EvanR: actually just using a plain record solves another issue - being able to set apis to "test mode", eg. replacing certain functionality of the api with dummies which do nothing. Think that'd be easier to do with a record without some sort of trickery :)
18:43:13 <divVerent> @pl fix $ \ self f l -> if null l then [] else f(head l) : self f (tail l)
18:43:13 <lambdabot> fix ((ap (flip if' [] . null) .) . ap (ap . ((:) .) . (. head)) . flip flip tail . ((.) .))
18:43:18 <divVerent> yes, so much better ;)
18:43:50 <divVerent> interesting that hoogle doesn't know if'
18:43:57 <divVerent> not that it's not easy to guess how it's implemented
18:44:15 <geekosaur> it doesn't exist, nobody has updated @pl to use bool yet
18:44:30 <divVerent> @unpl fix ((ap (flip if' [] . null) .) . ap (ap . ((:) .) . (. head)) . flip flip tail . ((.) .))
18:44:31 <geekosaur> formerly it translated if ... then ... else to that just so it could keep going
18:44:31 <lambdabot> fix (\ x x0 b0 -> (return (\ b2 -> return (((:)) (x0 (head b2)) (x x0 (tail b2))) b2) x0 >>= \ x2 -> return (if' (null b0) [] x2)) b0)
18:44:39 <divVerent> gets better every time
18:45:20 <divVerent> even looks a bit like Lisp with this
18:45:42 <n_blownapart> ok thanks geekosaur I recall it is a very similar construct to Ruby
18:46:06 <davr0s> ok i have it working with 'Applicative'.  , thanks  Axman6  etc.
18:46:18 <Axman6> n_blownapart: basically it explicitly says "ignore this argument, it's not used here"
18:46:41 <divVerent> good that I don't have too much time... otherwise I'd probably take @pl and @unpl and turn them into an universal Haskell obfuscator... tell it by how much the code shall expand, and it'll use them in sequence until the code is HUEG ;)
18:46:56 <Axman6> davr0s: you should spend a wee bit of time to confirm that your applicative and functor instances abide by the laws for those classes
18:47:01 <n_blownapart> Axman6, thanks
18:47:01 <divVerent> or do @pl/@unpl eventually converge? :P
18:47:12 <geekosaur> sometimes
18:47:12 <robkennedy> I'm sort of absent lisp experience, though my team works with clojure. Am I correct in thinking that `lisp :: [a] - IO [a]`<
18:48:02 <Axman6> probably more like [Any] -> IO [Any] (and if there are exceptions, the type gets more complicated)
18:48:44 <davr0s> https://gist.github.com/dobkeratops/6aa63bf402968d31521fbbd69dbd505c
18:49:05 <robkennedy> In particular `lisp (x:xs) = f x >>= \xs' -> lisp (xs' ++ xs)
18:49:37 <davr0s> Axman6 yeah , i did get the impression looking at the docs these are intended for way more than just simple vector arithmetic, it keeps talking about composing operations yada yada
18:49:45 <robkennedy> Where the lisp action injects instructions into it's state?
18:49:51 <Axman6> possibly... I guess that depends on your evaluation model
18:50:26 <Axman6> davr0s: yes, that's definitely not their usual intent nor usage
18:51:16 <davr0s> this leads me to ask if although i was repeating 'stuff that lready exists' .. something that just handles my use case there still had utility.    
18:51:43 <davr0s> the compiler (and myself) works harder to get the same result perhaps
18:51:54 <davr0s> still it would be nice to learn all this..
18:56:15 <divVerent> love it, there's both Control.Bool and Data.Bool.Extras which subtly overlap but both have their own stuff
18:56:23 <divVerent> none of which define a FILE_NOT_FOUND :: Bool, though ;)
19:04:16 <robkennedy> Should I spread `-feager-blackholing` through libraries, or at the executable level?
19:07:15 <pacak> robkennedy: As far as I understand -feager-blackholing is not exactly free.
19:16:37 <davr0s> any thoughts on this... seems haskell's  (*) is Num a => a->a->a,    but can you do operator overloading of multiply with different types such that '*' takes 2 types and returns a 3rd .. e.g. for dimension analysis (speed * time=distance) , or other format conversions (fixed point * fixed point -> fixed point with appropriate shift..)
19:16:58 <geekosaur> no, you cannot
19:17:25 <Hafydd> You can't?
19:18:12 <Hafydd> You can't with Prelude's Num, but I believe it is possible in general.
19:18:20 <pacak> > let x * y = show (x * 2) ++ y in 10 * "hello"
19:18:22 <lambdabot>  error:
19:18:22 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘2’
19:18:22 <lambdabot>      • In the second argument of ‘(*)’, namely ‘2’
19:18:23 <geekosaur> you can *shadow* it
19:18:47 <pacak> > let x * y = show (x + 2) ++ y in 10 * "hello"
19:18:49 <lambdabot>  "12hello"
19:18:50 <geekosaur> you can't *overload* it, the only "overloading" mechanism is typeclasses and I think you might have trouble expressing that type in a typeclass
19:19:09 <pacak> ^ that's stupid, don't do that.
19:21:20 <Hafydd> https://github.com/bjornbm/dimensional/
19:24:04 <marvin2> unit libraries do exist, so it is possible one way or another. they tend to define different operators though instead of shadowing existing ones
19:29:26 <koala_man> cabal --version says I'm using version 1.18.1.5 of the Cabal library. cabal install array says "The package 'array' requires Cabal library version -any && >=1.10 but no suitable version is installed". What's up with that? 
19:36:06 <davr0s> is there a library function to find the element with the highest score by some given function,   e.g 'find the point closest to this'  ('score=1/distance to example')
19:41:12 <glguy> koala_man: That just means that your cabal-install binary was built against that version of the library, it doesn't mean you have that version of the library available now
19:42:04 <glguy> koala_man: It's uncommon not to have an array or Cabal package, did you do some deleting recently?
20:25:31 --- mode: glguy set -o glguy
20:38:52 <dfeuer> Anyone know what https://wiki.haskell.org/Typeclassopedia#Alternative_formulation exercise 2 is supposed to be about? It suggests Coapplicative or something, but the functions it requests are available for any Functor...
20:39:56 <dfeuer> Does this have to do with the comment near the top of https://hackage.haskell.org/package/distributive-0.5.2/docs/Data-Distributive.html ?
20:47:07 <zomg> Ugh, still getting json parser errors because Network.HTTP.Simple doesn't properly handle certain non 2xx response codes into errors 
20:47:27 <zomg> first it was because parseRequest, now I'm not even using that anymore and it still doesn't handle it :\
20:49:37 <zomg> apparently Cloudflare's HTTP error 525 isn't something it understands as a non-2xx code
20:54:18 <pacak> zomg: bugreport time!
20:54:58 <zomg> yeah it does look like it might be a legit issue in the lib
20:55:09 <zomg> but gonna see if I can have an easy repro case for it
21:06:39 <mnoonan_> is it reasonable to use unsafeCoerce along with phantom types, like:
21:06:52 <mnoonan_> data User = User { ..stuff.. }
21:06:56 <mnoonan_> data Sudoer
21:07:07 <mnoonan_> oops, “data User t = User {..}”
21:07:26 <mnoonan_> sudo :: User t -> Password -> Maybe (User Sudoer)
21:08:08 <mnoonan_> where “sudo user passwd”, in the good case, returns “Just (unsafeCoerce user)”?
21:08:39 <mnoonan_> I’ve never wanted unsafeCoerce before, so I’m not clear if this is the kind of thing it is intended for.
21:09:01 <peddie> mnoonan_: no
21:10:25 <mnoonan_> ok, why not? and if not, is there some other way to write my “sudo” that avoids allocating a new User?
21:11:10 <peddie> mnoonan_: why not --> that's not what unsafeCoerce is for :)
21:11:23 <peddie> mnoonan_: I'm trying to find an example presentation I saw that did this exact thing
21:11:33 <c_wraith> mnoonan_: if you're working with phantom types, try the regular old safe coerce. :)
21:12:14 <c_wraith> (which is actually quite a lot newer than unsafeCoerce)
21:12:14 <mnoonan_> c_wraith: well that sure sounds safer :)
21:12:45 <c_wraith> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Coerce.html#v:coerce
21:13:25 <c_wraith> mnoonan_: the important thing to note is that GHC creates instances of Coercible automatically if it knows it is safe to do so
21:14:58 <mnoonan_> oh nice, the Safe Zero-cost Coercions for Haskell paper explicitly mentions the phantom type use case
21:14:59 <peddie> mnoonan_: https://donsbot.wordpress.com/2007/03/10/practical-haskell-shell-scripting-with-error-handling-and-privilege-separation/ I misremembered, he's not doing the exact same thing
21:31:55 <zomg> Can Control.Concurrent.Async `async` throw exceptions besides those rethrown by `wait`?
21:32:51 <zomg> Bit of an odd thing because I have 'wait a `catches` errs' which as far as I can tell should catch the error types in `errs` but it seems an exception of those types was still thrown past it
21:35:08 <iqubic> Can pandoc be installed through Hackage?
21:35:48 <iqubic> Or do I have to get it through my package manager?
21:35:50 <peddie> iqubic: did you try `cabal install pandoc` ?
21:35:59 <iqubic> No. Does that work?
21:36:02 <peddie> or `stack install pandoc`?
21:36:37 <iqubic> Yeah, I got it too work.
21:37:07 <iqubic> And how does one use pandoc?
21:37:13 <iqubic> Is it simple or no?
21:37:32 <peddie> @google pandoc tutorial
21:37:33 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
21:37:36 <peddie> eit
21:37:48 <iqubic> peddie: @google hasn't worked for a while now.
21:37:50 <peddie> I would google "pandoc tutorial"
21:40:08 <iqubic> the official pandoc website looks it was written for beggining terminal users. 
21:40:13 <Axman6> iqubic: please, can you please please please, just once, google a question before asking it?
21:40:39 <peddie> iqubic: feel free to file a bug
21:40:44 <Axman6> google.com, the world's best IRC support channel
21:41:25 <iqubic> I'll try that Axman6.
21:41:46 <iqubic> Why does pandoc require juicypixels?
21:42:02 <Axman6> tried, and immediately failed
21:42:06 <peddie> iqubic: not knowing anything about either package, I'm going to guess it has to do with putting images in documents?
21:42:19 <iqubic> I think so.
21:42:35 <peddie> great
21:43:38 <iqubic> pandoc is a complex piece of code.
21:43:44 <iqubic> It has a million deps or so
21:49:24 <MarcelineVQ> that's a lot
21:52:44 <tomzz> is there a version of (!!) that returns a maybe? for avoiding exception handling
21:52:59 <Axman6> @hoogle [a] -> Int -> Maybe a
21:53:00 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
21:53:00 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
21:53:00 <lambdabot> CLaSH.Util indexMaybe :: [a] -> Int -> Maybe a
21:53:05 <Axman6> @more
21:53:20 <glguy> :t \i xs -> listToMaybe (drop i xs)
21:53:22 <lambdabot> Int -> [a] -> Maybe a
21:53:22 <tomzz> atMay sounds good, thank you! couldnt find it on hoogle :<
21:53:23 <dibblego> λ> :t (!!)
21:53:23 <dibblego> (!!) :: Ixed s => s -> Index s -> Maybe (IxValue s)
21:53:32 <dibblego> after deleting Prelude and fixing it ^^
21:53:40 <tomzz> :D
21:54:05 <glguy> preview . ix :: Int -> [a] -> Maybe a
21:54:08 <Axman6> aka, the ix lens
21:55:01 <zomg> Uhm, can anyone verify if Network.HTTP.Simple.httpLBS is supposed to throw exceptions for non-2xx values?
21:55:14 <zomg> The documentation seems to suggest it will
21:55:19 <zomg> But I'm not able to get it to do that :P
21:55:36 <iqubic> Why is the ix lens even a thing?
21:55:47 <Axman6> ...
21:55:50 <zomg> I just spun up a quick web server which spits out errors and regardless of what status code I return, httpLBS ignores it totally...
21:55:53 <glguy> It's not, it's a traversal
21:56:39 <Axman6> hmm, that would be quite useful for a multiset/map
21:58:47 <Axman6> (the fact it's a Traversal and not a lens or prism)
22:00:15 <glguy> Being a traversal allows it to index lists, Map, and every other type where there are some keys that don't correspond to a value
22:01:45 <glguy> zomg: What indicated that httpLBS would throw exceptions for non 2xx values?
22:04:51 <zomg> glguy: there being a function to disable that particular behavior, and parseRequest's documentation specifying requests created through it won't throw on non-2xx
22:05:54 <zomg> https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Simple.html#v:parseRequest https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Simple.html#v:setRequestIgnoreStatus
22:08:13 <glguy> so the request creation method says it *doesn't* throw exceptions and additionally there's another way not to throw them?
22:10:35 <glguy> zomg: Does this one help? https://hackage.haskell.org/package/http-client-0.5.7.0/docs/Network-HTTP-Client.html#v:parseUrlThrow
22:11:04 <zomg> You can also create requests using the IsString instance
22:11:06 <zomg> so yeah it's kinda confusing
22:11:07 <zomg> :D
22:11:37 <zomg> And yeah, that seems like it might be worth a try
22:12:46 <zomg> yep creating it through that does do what it says on the box
22:13:07 <zomg> so yeah seems like the docs are just a bit of a... work in progress
22:13:08 <zomg> :P
22:13:22 <glguy> Why, were they wrong?
22:14:07 <zomg> There's nothing that suggests it's not the default behavior and the two functions to disable the behavior seems to indicate that throwing is the default as long as you don't use the two
22:14:23 <glguy> It suggested the not throwing was the default
22:14:32 <zomg> Only if you use parseRequest
22:15:06 <zomg> It doesn't say anywhere that the IsString instance uses parseRequest (which it probably does - but I only know of it because of this challenge)
22:25:30 <halogenandtoast> took me forever to find that IsString instance
22:29:22 <halogenandtoast> It doesn't seem to call parseRequest though
22:30:44 <halogenandtoast> calls parseUrl instead
22:32:48 <zomg> it's probably the difference between accepting "http..." and "POST http..."
22:33:00 <zomg> parseRequest seems to allow you to specify the method in the string
22:33:41 <halogenandtoast> that sounds reasonable
22:34:12 <zomg> In any case seems parseUrlThrow is the variant which does throw on non-2xx's, but at least I'd have expected the documentation to be a bit less vague about it
22:34:13 <halogenandtoast> I still don't see where it sets checkStatus to something that doesn't throw
22:37:43 <halogenandtoast> but yeah parseRequest actually just takes anything from infront of the URL and sets it as the method
22:38:18 <halogenandtoast> Oh I see how parseRequest does it
22:38:39 <halogenandtoast> defaultRequest which is different than the Default of Request has checkResponse = \_ _ -> return ()
22:39:17 <halogenandtoast> But it doesn't seem like the IsString instance does that
22:39:23 <zomg> yeah it's a bit confusing that defaultRequest also ignores it by default
22:39:25 <halogenandtoast> as far as I can tell the IsString instance should throw.
22:39:40 <zomg> especially when there's a function to have a request ignore it... but no function to *not* have a request ignore it
22:39:47 <halogenandtoast> https://hackage.haskell.org/package/http-client-0.1.0.0/docs/src/Network-HTTP-Client-Request.html#line-201
22:40:08 <halogenandtoast> zomg well defaultRequest is still different from the Default
22:40:28 <zomg> heh
22:40:31 <halogenandtoast> https://hackage.haskell.org/package/http-client-0.1.0.0/docs/src/Network-HTTP-Client-Request.html#line-163
22:40:31 <MarcelineVQ> is that the version you're using?
22:41:07 <halogenandtoast> MarcelineVQ: no, I blame Google for this travesty
22:41:17 <glguy> Yeah, it's probably someone else's fault
22:41:35 <halogenandtoast> glguy: isn't it always
22:42:32 <halogenandtoast> yeah 0.5.7.0 uses parseRequest_
22:42:33 <MarcelineVQ> it's not much different for that part at least,  instance IsString Request where  fromString = parseRequest_      parseRequest_ = either throw id . parseRequest
22:42:35 <halogenandtoast> I stand corrected
22:43:20 <MarcelineVQ> er, well actully it use, it uses parseRequest, pardon me
22:43:24 <MarcelineVQ> *it is
