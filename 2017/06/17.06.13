00:00:00 <wilornel> s/id/identity/
00:00:09 <wilornel> jared-w: really?
00:00:10 <wilornel> cool!
00:00:25 <geekosaur> you still need to do that, and in the meantime a lot of code would be throwing errors and need to have that added
00:00:32 <wilornel> geekosaur: So jared-w 's fix is a pretty easy one. I don't see why backward comp is that much of an issue
00:00:45 <geekosaur> you missed AMP, I guess
00:00:52 <wilornel> so there _could_ be a wide fix and easy fix to be done?
00:00:57 <LordBrain> it adds up
00:01:05 <jared-w> It involves having literally every Monoid instance ever written have an extra line of code `instance Semigroup MyMonoid` added
00:01:06 <wilornel> A little bit like Google fixed a lot of code on Github over some period of time 
00:01:10 <LordBrain> but sure we could port everything to that
00:01:10 <geekosaur> wilornel, yes if you think a magic wans soes that to all existing code
00:01:22 <wilornel> jared-w: Just make a PR request on the most popular github repos
00:01:32 <jared-w> It's not about just fixing popular github repos
00:01:34 <wilornel> geekosaur: I 'd like to see if I can pull that off
00:01:40 <geekosaur> no, if you understand that developers do not necessarily drop everything and patch all their code because you decided they should
00:01:59 <jared-w> It's the fact that the Haskell ecosystem contains thousands of small one-off libraries that haven't been updated in 3 years
00:02:05 <wilornel> No no, I just want to try to make a lot of PRs, one for each repository
00:02:08 <wilornel> and let them OK it
00:02:21 <wilornel> (And that idea I take from https://opensource.googleblog.com/2017/03/operation-rosehub.html)
00:02:22 * jared-w puts on tinfoil hat
00:02:34 <LordBrain> protection jared?
00:02:34 <wilornel> what is AMP?
00:02:44 <geekosaur> this is a very good way to torque off a lot of developers
00:02:47 <wilornel> what's a tinfoil hat supopsed to represent?
00:02:51 <LordBrain> AMP = Applicative Monad Proposal
00:02:56 <jared-w> The other option is just to put a special case into the compiler that automatically writes the instance for any superclass of a given subclass if it isn't found
00:03:00 <LordBrain> where Applicative becomes a superclass of Monad
00:03:05 <geekosaur> Applicative-Monad Proposal, which landed in ghc 7.10 ad forced everyone to retrofit Applicative instances onto their Monads
00:03:24 <geekosaur> and the experience from which is *why* nobody is rushing into doing the same thing to Monoid
00:03:26 <jared-w> Since all you're doing is writing `instance SuperClass MySubClass` and letting the compiler figure it out anyway
00:03:42 * jared-w takes off tinfoil hat
00:03:58 <LordBrain> so what you are talking about is SMP, Semigroup Monoid Proposal, by analogy
00:04:48 <LordBrain> https://ghc.haskell.org/trac/ghc/ticket/10365
00:04:54 <wilornel> Could there not be a way for ghc to suggest a fix before compiling a library?
00:05:14 <geekosaur> sigh
00:05:34 <geekosaur> I keep forgetting this is the new world where forcing such things on people you don't know is perfectly acceptable if it's "simple enough"
00:05:59 <wilornel> Alright, I understand that things won't be that simple
00:06:11 <geekosaur> no skin of your back, so there can't possibly be anything wrong with it. problems for others? it's not your problem, it can't possibly matter
00:06:12 <wilornel> Like, when a user thinks "how can this be so complicated to develop"
00:06:30 <wilornel> What have we learned from AMP? What were the big issues?
00:06:40 <wilornel> Is there a postmorterm?
00:06:46 <wilornel> post mortem*
00:07:15 <ventonegro> Ot seems Idris learned from Haskell mistakes: Monoid must be a Semigroup and : and :: are used correctly
00:07:16 <jared-w> What we learned from AMP is that simple, painless, tiiiiiiiny little fixes...
00:07:20 <ventonegro> It seems*
00:07:21 <jared-w> *cough* blow up violently
00:07:44 <LordBrain> they are phasing it in slowly, you get warnings in 7.10.*
00:08:00 <LordBrain> i dont know if it landed in 8
00:08:00 <jared-w> ventonegro: Idris and most other "newer FP Haskell-inspired" languages get things like that correct. They learned from haskell's mistakes, after all
00:08:38 <LordBrain> well it seems like it is going to happen eventually
00:08:52 <LordBrain> so everyone should go ahead and make those semigroup instances
00:09:02 <wilornel> jared-w: how
00:09:16 <wilornel> I can't believe there was no post mortem write up on it
00:09:18 <jared-w> Keep in mind, Haskell is going to adopt Dependent Types eventually. Idris already has them
00:09:34 <LordBrain> well
00:09:41 <LordBrain> idris doesnt have type inference tho
00:09:42 <wilornel> so? What do those have to do with SMP?
00:09:51 <jared-w> oh right, I never finished that train of thought
00:09:53 <ventonegro> LordBrain: wat?
00:10:22 <jared-w> There's a ton of stuff in Haskell right now that's somewhat painful crap added on to inch it closer and closer to dependent types. Stuff like DataKinds, RankNTypes, etc
00:10:38 <ventonegro> LordBrain: Idris can even fill your holes for you bases solely on the hole type
00:10:47 <wilornel> ah.... are those issues in production code?
00:10:51 <ventonegro> based*
00:11:15 <LordBrain> last i tried idris its type inference was nearly nonexistent, everything had to be annotated, that was many years ago tho
00:11:18 <jared-w> If we just went straight for dependent types, we wouldn't need any of that.
00:11:35 <glguy> rankn is orthogonal to dependent fwiw
00:11:36 <quchen> AMP did not blow up violently.
00:11:44 <ventonegro> LordBrain: I only learned about it recently, that seems to have been fixed :)
00:11:46 <pacak> You still need to annotate all the things in idris.
00:11:51 <quchen> It’s pretty much the example for how such a thing does not blow up violently.
00:11:58 <jared-w> The more powerful a type system, the less inference is generally possible. Haskell is going to reach that without annotating tons of stuff because it's taking its sweet time getting there
00:12:07 <wilornel> quchen: Any post mortem write ups?
00:12:17 <LordBrain> well
00:12:30 <LordBrain> we have a big legacy of haskell code, we should not throw away
00:12:32 <jared-w> quchen: sorry. I should've phrased that differently. It /didn't/ blow up everywhere because everyone blew up all their steam discussing it to death and implementing it super carefully, staged, etc.
00:12:42 <quchen> wilornel: Not really. Simon Marlow spent a week migrating to 7.10 at Facebook, most of it due to the FTP.
00:12:59 <quchen> wilornel: I haven’t heard stories of hard migrations because of AMP.
00:13:06 <wilornel> It seems like there are so many things in Haskell that could be de-coupled. As we learn how to decouple things more and more, we will need to do these AMP style fixes. Is there nothing that can prevent that?
00:13:16 <ventonegro> pacak: Nope.
00:13:18 <quchen> Graham Hutton is quite bitter about it, but probably for not very good reasons.
00:13:32 <cocreature> quchen: because his book got out of date? :)
00:13:33 <quchen> He’s bitterer about FTP, and he opposes change in general.
00:13:37 <pacak> I submited maybe 20-30 MRs related to AMP to different things on hackage
00:13:46 <LordBrain> whys' that quchen ?
00:13:48 <pacak> Nothing too serious.
00:13:53 <jared-w> Not particularly. That's what happens when you make a research language and people develop real work ontop of something that isn't set in stone
00:14:18 <quchen> He thinks Haskell frequently breaks and is thus perceived as chronically unstable, which seriously hinders adoption.
00:14:20 <geekosaur> considering the recent rant about FTP on -cafe
00:14:39 <wilornel> -cafe?
00:14:43 <LordBrain> oh
00:14:46 <LordBrain> well....
00:14:50 <merijn> wilornel: The haskell-cafe mailing list
00:14:50 <geekosaur> haskell-cafe mailing list
00:14:54 <LordBrain> to some extent he's not wrong per se
00:15:04 <wilornel> thanks
00:15:12 <LordBrain> its a higher maintenance choice than going with standard c or something
00:15:15 <pacak> geekosaur: Strange people that don't understand what shape tuples are for functors.
00:15:31 <merijn> LordBrain: Are you factoring in bugfixing in that maintenance cost?
00:15:31 <quchen> Oh, that discussion again.
00:15:37 <LordBrain> no
00:15:39 <quchen> Tuples and Foldable.
00:15:42 <quchen> Exciting.
00:15:59 <jared-w> Which thread was that, geekosaur?
00:16:06 <pacak> > length (1,'a')
00:16:08 <LordBrain> its more maintenance tho due to ecosystem changes, while in c or something, you know.. there is code that just works that is ancient
00:16:08 <lambdabot>  1
00:16:16 <pacak> Looks perfectly valid to me.
00:16:18 <merijn> quchen: I compromise by being against both sides. That is, I want tuples in Foldable, but I think some things shouldn't have been moved into foldable
00:16:33 <LordBrain> c has a lot of ancient compilers too
00:16:44 <jared-w> That's because c has exactly one job
00:16:55 <jared-w> "be a portable assembly that doesn't suck too much"
00:16:56 <merijn> jared-w: And it doesn't even do that one right :D
00:16:57 <geekosaur> that's what you think
00:16:59 <LordBrain> haskell has a lot of ancient compilers i guess... but they're not source compatible a lot of hte time
00:17:06 <jared-w> It does that job /fabulously/
00:17:11 <merijn> jared-w: People who think C is portable assembly haven't looked at assembly lately
00:17:23 <wilornel> How is this wrong? "instance (Semigroup a, Monoid a) => Monoid (Identity a) where mempty = (Identity (mempty :: a))
00:17:26 <wilornel> "
00:17:42 <jared-w> C was originally designed to be portable assembly, I'm not wrong about that :p
00:17:47 <merijn> wilornel: Well, "Semigroup a, Monoid a" is redundant
00:17:52 <quchen> wilornel: The »a« in your type and the »a« in your value are different »a«.
00:17:55 <jared-w> merijn: what aspects of modern assembly are you thinking of?
00:18:07 <LordBrain> merijn, what version of base?
00:18:08 <wilornel> merijn: We are currently having a discussion on why it is necessary, no?
00:18:20 <merijn> jared-w: I'm more thinking of "C doesn't translate to assembly the way people think it does"
00:18:22 <wilornel> LordBrain: So it could be _not_ redundant?
00:18:38 <LordBrain> its not redundant in older base at least
00:18:52 <wilornel> GHC 8.0.1 ?
00:18:59 <merijn> LordBrain: Well, right now it's not redundant, just needlessly restrictive
00:19:02 <LordBrain> i'm not sure about ghc 8
00:19:03 <jared-w> oh, well that's just their fault  ¯\_(ツ)_/¯ can't expect people to have a reasonable idea of C -> Assembly if they've never learned assembly
00:19:12 <wilornel> I have base >= 4.9  && < 4.10
00:19:22 <wilornel> So I'm confused, do we or do we not need to do SMP?
00:19:24 <merijn> LordBrain: There's more Monoid instance than Semigroup and that definition means it won't work for any Monoid that isn't a Semigroup right now
00:19:29 <wilornel> If it's redundant, then SMP is not necessary...
00:19:44 <LordBrain> merijn, oh i see what you mean
00:20:07 <wilornel> How can a Monoid not be a Semigroup?
00:20:10 <merijn> wilornel: The reason Semigroup is not a superclass of Monoid is that Semigroup didn't exist in base
00:20:17 <wilornel> Yes
00:20:22 <merijn> wilornel: So defining a Semigroup instance requires you to add a dependency
00:20:31 <merijn> wilornel: So most people *only* define Monoid right now
00:20:45 <wilornel> Alright
00:20:50 <merijn> wilornel: By requiring Semigroup you're making your instance impossible for types that are currently only a Monoid, but not a Semigroup
00:21:12 <wilornel> but what if I have a Semigroup instance already and I want to make a Monoid instance that reuses that types Semigroup functions?
00:21:17 <jared-w> And even though writing a semigroup instance is really just `instance Semigroup MyMonoid`, you still need to write that line of code currently (I believe)
00:21:24 <merijn> wilornel: In the future, when Semigroup is made a superclass of Monoid, then the Semigroup restriction will be useless
00:21:40 <wilornel> But it makes more sense to define Semigroup and then Monoid ,right?
00:21:41 <LordBrain> indeed
00:21:49 <merijn> wilornel: Then you can just do "instance Monoid (Foo a) where mappend = (<>)" or whatever the Semigroup function is
00:21:55 <wilornel> yes!
00:22:03 <wilornel> Oh wait no, I still need the Semigroup
00:22:19 <LordBrain> just dont put the constraint on your instance
00:22:23 <wilornel> hmmmm
00:22:33 <merijn> wilornel: You can use Semigroup functions inside your Monoid instance, as long as the type you're defining the instance for is a Monoid
00:22:36 <merijn> eh
00:22:40 <merijn> s/Monoid/Semigroup
00:22:57 <wilornel> this gives me an error : http://paste.ubuntu.com/24847516/
00:23:16 <wilornel> "Could not deduce (Semigroup a) arising from a use of ‘<>’"
00:23:28 <jared-w> What does :t (<>) give you in ghci?
00:23:32 <jared-w> :t (<>)
00:23:33 <lambdabot> Monoid m => m -> m -> m
00:23:48 <wilornel> (<>) :: Monoid m => m -> m -> m
00:24:00 <jared-w> In my ghci it gives me a Semigroup s => s -> s -> s
00:24:03 <wilornel> if I import Data.Monoid
00:24:07 <LordBrain> inst that instance circular?
00:24:21 <LordBrain> oh
00:24:31 <wilornel> But I get "(<>) :: Semigroup a => a -> a -> a" when I import Semigroup
00:24:36 <wilornel> Alright, this was all so confusing
00:24:39 <LordBrain> <> used to imply just Monoid ont semigroup
00:24:42 <wilornel> I don't understand if we need SMP or not
00:24:54 <jared-w> There's a <> from Data.Monoid and a <> from Data.Semigroup
00:24:59 <wilornel> yes
00:25:05 <wilornel> ooooh wait
00:25:19 <LordBrain> :t mappend
00:25:20 <lambdabot> Monoid a => a -> a -> a
00:25:29 <LordBrain> what you're writing is like saying mappend = mappend
00:25:35 <LordBrain> even if you use the monoid
00:25:38 <wilornel> but I do `import Data.Semigroup; import Data.Monoid (Sum)`
00:25:38 <merijn> wilornel: Why are you trying to use Semigroup of 'a' when you already *have* a Monoid constraint on 'a'?
00:25:57 <merijn> LordBrain: It's not circular, because the <> he uses is the one on 'a' not the one on Identity 'a'
00:26:10 <wilornel> merijn: Didn't we discuss earlier that Semigroup is not a parent of Monoid yet?
00:26:19 <merijn> "mappend (Identity x) (Identity y) = Identity (mappend x y)" <- what's the issue
00:26:24 <LordBrain> i see
00:26:27 <merijn> wilornel: What does that matter? Monoid already has mappend
00:26:46 <merijn> wilornel: You're requiring 'a' to be a Monoid, so you can just use the mappend from a's Monoid
00:26:46 <quchen> Monoid even has <>, before Semigroup or not
00:27:00 <wilornel> well it's not working
00:27:00 <merijn> I don't see why you even need Semigroup here or what Semigroup has to do with anything?
00:27:15 <LordBrain> use mappend
00:27:15 <wilornel> http://paste.ubuntu.com/24847527/
00:27:17 <LordBrain> instead of <>
00:27:25 <wilornel> huh
00:27:26 <quchen> <> works just as well.
00:27:37 <wilornel> weird. it worked
00:27:38 <LordBrain> well <> needs to be qualified for him apparently
00:27:50 <wilornel> mappend = mappend
00:27:52 <LordBrain> because it thinks he means <> from Semigroup class
00:27:59 <quchen> <> is either monoidal, or a reexport of Semigoup’s operator, depending on which version you’re using. In does the same in either case.
00:28:03 <iqubic> What's the differnce between mappend and <>?
00:28:12 <merijn> iqubic: Depends, which <> ? :p
00:28:13 <jared-w> <> is infix mappend
00:28:18 <wilornel> well, I have shadowed my imports, if you look at the pastie
00:28:29 <merijn> iqubic: There's <> from Data.Monoid which is just infix mappend
00:28:38 <LordBrain> yeah but you imported Semigroup
00:28:38 <quchen> iqubic: <> used to be a synonym for mappend before Semigroup happened. How it’s its own thing in Semigroup, which is a superclass of Monoid in recent versions.
00:28:38 <iqubic> Why is Semigroup not already a superclass of Monoid?
00:28:42 <merijn> iqubic: And there's <> from Semigroup, which is different
00:28:48 <LordBrain> so your <> requires an instance
00:28:51 <iqubic> In fact, what is a semigroup?
00:28:52 <wilornel> iqubic: Didn't we talk about SMP earlier?
00:28:56 <wilornel> what??
00:29:00 <merijn> iqubic: Because Semigroup was never in base, whereas Monoid is
00:29:00 <quchen> iqubic: A Monoid without mempty is a Semigroup.
00:29:02 <jared-w> iqubic: Semigroup is a Monoid without an identity
00:29:11 <iqubic> Why is that even a thing???
00:29:16 <merijn> iqubic: Algebra
00:29:19 <wilornel> Because 
00:29:25 <wilornel> math
00:29:36 <wilornel> soooooo
00:29:40 <iqubic> It seems like it makes stuff more difficult to work with.
00:29:49 <merijn> iqubic: It can be useful, sometimes you don't have a sensible "default" element, but you do have an associative binary operation?
00:29:52 <quchen> iqubic: Semigroup can’t make stuff up, so when you see Semigroup you know it combines things, but does not invent anything.
00:29:56 <wilornel> what if you really want your type not to have an empty?
00:29:59 <LordBrain> iqubic, because sometimes there is no mempty for what you're doing...    just an associative binary operation
00:30:07 <merijn> iqubic: Well, consider "mappend" on NonEmpty (which is the non-empty list)
00:30:13 <quchen> iqubic: (Integer, max) is a semigroup, but not a Monoid, for example.
00:30:27 <wilornel> is max  a type?
00:30:33 <merijn> iqubic: Can't make NonEmpty a Monoid, because, how would you define mempty for non-empty lists?
00:30:35 <iqubic> A semigroup can't have mconcat can it.
00:30:36 <quchen> No, max is the maximum function.
00:30:38 <quchen> > max 2 5
00:30:40 <lambdabot>  5
00:30:51 <wilornel> What is (Integer, max) ?  a tuple right?
00:30:53 <merijn> iqubic: But you can define a semigroup for NonEmpty since you can clearly concat non-empty lists
00:31:03 <LordBrain> he's using math notation
00:31:16 <iqubic> wilornel: It means it's a semigroup on Integers that uses max as the combination operator
00:31:16 <quchen> wilornel: It’s not Haskell, it just means that »Integer and max together form a semigroup«.
00:31:17 <wilornel> Pointers on where I can read up on this notation?
00:31:23 <LordBrain> he paired the operation with the the set it operates on, the math definition of semigroup
00:32:05 <merijn> quchen: monoid-extras does have a max monoid with an added infinity :)
00:32:13 <iqubic> It's like (Num a, sum) can be a monoid. Or you can have (Num a, product) as a monoid.
00:32:18 <wilornel> hmmm
00:32:38 <wilornel> So Integer is a Semigroup over max
00:32:39 <quchen> Num doesn’t have to be associative ;-P
00:32:42 <wilornel> and Num a isa Monoid over sum
00:32:54 <saurabhn_> is there a haskell library which can allow me to simply check (not fix) whether an a given text is a valid/well-formed HTML?
00:33:06 <iqubic> wilornel: You can also have (Integer, min) too
00:33:09 <wilornel> ah I see, so Integer doesn't have to be a Semigroup, but over max it is a semigroup
00:33:27 <iqubic> There are multiple ways to combine data.
00:33:28 <wilornel> regex? /s
00:33:30 <quchen> And (Integer, const 17)!
00:33:36 <jared-w> I like to think of it as (data, operations)
00:33:38 <LordBrain> saurabhn_, yeah... i used something i need to look back to see what it was
00:33:49 <wilornel> quchen: but what about the value 17, is that not mempty there?
00:34:10 <jared-w> (positive numbers, +), (negative numbers, x), (Real numbers, ÷), etc
00:34:27 <LordBrain> saurabhn_, i believe HaXml has something
00:34:49 <glguy> jared-w: division isn't associative
00:35:14 <jared-w> right... m'bad. Was writing out operators and forgot to think about them :p
00:35:20 <wilornel> Can you do (Integer, {max, min}) is a Semigroup?
00:35:33 <LordBrain> https://hackage.haskell.org/package/HaXml-1.25.3/docs/Text-XML-HaXml-Validate.html
00:35:34 <iqubic> a <> b = b <> a
00:35:40 <jared-w> You'd need two semigroups, one for each operation
00:35:42 <quchen> wilornel: 17 is not mempty,
00:35:43 <quchen> ?check \x -> let _ <> _ = 17 in x <> 17 == x
00:35:45 <lambdabot>  *** Failed! Falsifiable (after 1 test):
00:35:45 <lambdabot>  0
00:35:53 <jared-w> (Integer, max), (Integer, min)
00:36:25 <iqubic> and (a <> b) <> c = a <> (b <> c)
00:36:26 <wilornel> :info check
00:36:34 <LordBrain> saurabhn_, it will let you validate arbitrary xml with a dtd, thats not quite what you asked for, but maybe good enough? you can get the dtd for xhtml 4
00:36:36 <saurabhn_> LordBrain: yes, looks like it can solve the problem. Where do I get a DTD for HTML?
00:36:46 <geekosaur> there is no :info in lambdabot
00:36:55 <wilornel> jared-w: Ah right, the same way we have Sum and Product for having Semigroups over different operations
00:37:21 <wilornel> How would we call a construct where the operation is part of a Semigroup definition in Haskell? Do we need one?
00:37:27 <LordBrain> http://www.w3.org/TR/html4/strict.dtd
00:37:35 <LordBrain> that wont let you do html 5 tho
00:37:35 <saurabhn_> is there a way to get Quickcheck or Tasty to emit TODO warnings wrt tests (stuff which still needs to be tested, etc)
00:37:37 <jared-w> Yes. That's just a haskell workaround that makes explicit what you can make implicit mathematically
00:38:05 <LordBrain> i think you need xhtml 5 dtd to do this
00:38:10 <wilornel> quchen: thanks
00:38:43 <wilornel> are there plans on making that workaround not necessary?
00:38:49 <saurabhn_> LordBrain: https://stackoverflow.com/a/15245834/534481
00:38:54 <iqubic> @check \a b c -> (a <> b) <> c == a <> (b <> c)
00:38:57 <lambdabot>  +++ OK, passed 100 tests.
00:38:59 <jared-w> Making that workaround not necessary introduces a giant host of problems
00:39:03 <iqubic> Cool that's good
00:39:11 <LordBrain> saurabhn_, yeah...
00:39:24 <iqubic> @check \a b -> a <> b == b <> a
00:39:26 <lambdabot>  +++ OK, passed 100 tests.
00:39:34 <wilornel> iqubic: I usually need to specify a type for quickcheck to check such a prop, no?
00:39:36 <jared-w> It is necessary, regardless of whether or not we write it. The question is, can we make the "workaround" implicit?
00:39:49 <iqubic> @check \a b c -> (a <> b) <> c == a <> b
00:39:50 <LordBrain> saurabhn_, is sticking to the 4.01 standard or xhtml 1 good enough ?
00:39:51 <lambdabot>  +++ OK, passed 100 tests.
00:40:00 <wilornel> jared-w: that would be part of GHC?
00:40:00 <phadej> iqubic: it defaults to ()
00:40:04 <iqubic> Oh, yeah, you do.
00:40:09 <phadej> or badly looks so
00:40:10 <wilornel> Could it be a language extension?
00:40:11 <saurabhn_> LordBrain: that's a fallback...
00:40:13 <wilornel> jared-w:  ^ 
00:40:28 <LordBrain> saurabhn_, i think haxml might have some kind of forgiving mode or something that let you do it... my mem is vague
00:40:32 <jared-w> In order to make the "workaround" implicit, you'd end up having tons of things become ambigious and the compiler wouldn't be able to figure things out
00:41:13 <jared-w> It's not really a workaround. Integers can be defined as a semigroup over several different operations. However, each is a different semigroup.
00:41:18 <phadej> @check \a b -> a <> b == b <> (a :: [Int])
00:41:20 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 11 shrinks):
00:41:20 <lambdabot>  [5,1,5,2,5] [0,-1,1,4,-5]
00:41:27 <wilornel> jared-w: Ah yes, if you think of it this way
00:41:45 <wilornel> It's just that in mathematic notation (Integer, sum) looks so nice
00:42:00 <jared-w> How do you differentiate between mappend 1 1, mappend 1 1, mappend 1 1, mappend 1 1,... (each one is a different semigroup)?
00:42:04 <LordBrain> saurabhn_, i found this, maybe it can do ya, https://hackage.haskell.org/package/html5-entity
00:42:26 <LordBrain> hmm
00:42:27 <wilornel> that's right!
00:42:30 <LordBrain> no thats just for entities
00:42:36 <wilornel> and doing `mappend [sum] 1 1` would not make sense
00:42:48 <wilornel> I mean, it would be unecessary to specify this 
00:42:53 <quchen> Idris does it this way
00:42:58 <wilornel> I mean, it would be too verbose
00:43:03 <wilornel> oh, why did noone say Idris does that?
00:43:17 <jared-w> Yeah and then in Idris you have to do M.+ and every bit of elegance you ever had got flushed down the toilet
00:43:37 <wilornel> where can I read up on that in Idris and M.+ in Idris?
00:43:38 <jared-w> (and by M.+ I mean MyModuleName.Operator)
00:43:40 <geekosaur> there's been some discussion of doing that with visible type application in Haskell
00:43:46 <quchen> wilornel: See here http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#named-implementations
00:43:55 <geekosaur> mappend @Sum ...
00:44:18 <wilornel> And you would only need to use @Sum when the type is ambiguous, right?
00:44:24 <jared-w> Which doesn't really look any better than what we have now, honestly...
00:44:24 <wilornel> thanks quchen 
00:44:44 <saurabhn_> LordBrain: that's just for HTML Entities, i.e. &something;
00:44:52 <LordBrain> yeah i saw that after posting
00:44:55 <LordBrain> sorry
00:45:04 <wilornel> Wow, I wonder when most of these issues are not going to be part of Haskell anymore
00:45:09 <saurabhn_> does the Quickcheck instance for Text generate texts of length 1? How do I make it generate longer texts?
00:45:09 <wilornel> Will another language be necessary?
00:45:11 <geekosaur> well, currently it can't be ambiguous as you can only have one instance per type; this would be about allowing multiple instances
00:45:24 <wilornel> Can these concepts be defined programatically instead of as part of the compiler?
00:45:41 <geekosaur> so instead of having to use e.g. the Sum and Product newtypes for the monoids on Integral types, you could specify that way.
00:45:48 <geekosaur> I dont know if there is a formal proposal for it or not
00:45:57 <jared-w> Sure. You can offload almost all of the compiler into the language and vice versa. It's not really about that
00:46:11 <wilornel> geekosaur: But then in the case where you do `mappend (Sum 1) (Sum 2)`, you would not need  to do `mappend @Sum (Sum 1) (Sum 2)`, right?
00:46:30 <geekosaur> the point behind this idea was making the (Sum x) go away
00:46:36 <wilornel> jared-w: interesting, I didn't know that
00:46:39 <jared-w> You would do `mappend @addition 1 2` or something like that
00:46:42 <geekosaur> "so instead of having to use..."
00:47:03 <geekosaur> maybe I should not have said anything since it seems most of it is not being read...
00:47:08 <jared-w> wilornel: look up the language Forth. Almost the entire language is built in the languae itself, not the compiler
00:47:10 <wilornel> geekosaur: but what if you have types that already are (Sum x) and don't want to do `mappend @Sum x y` every time?
00:47:26 <jared-w> geekosaur: don't worry, I'm reading it <3 
00:47:28 <geekosaur> you don't _need_ the annotation in that case, why do you care?
00:47:33 <wilornel> geekosaur: Hey hey, I'm reading it but I'm trying to understand what are the possibilities. Maybe you could link the proposal?
00:47:39 <wilornel> geekosaur: That's what I'm saying
00:47:40 <merijn> wilornel: You don't even need that
00:47:46 <merijn> > getSum $ mappend 2 5
00:47:48 <lambdabot>  7
00:47:54 <merijn> > getProduct $ mappend 2 5
00:47:56 <lambdabot>  10
00:47:58 <wilornel> woah!
00:47:59 * merijn waves hands
00:48:01 <geekosaur> the point is not that this would always be required, the point was making the ugly newtype wrappers go away
00:48:03 <merijn> Wizardry
00:48:04 <jared-w> > mappend 2 5
00:48:06 <lambdabot>  error:
00:48:06 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M793510389358...
00:48:06 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
00:48:07 <wilornel> I forgot about that 
00:48:08 <geekosaur> I don;t see why the question of both comes up
00:48:10 * wilornel awes
00:48:18 <jared-w> See? Ambigious
00:48:30 <merijn> wilornel: "instance Num a => Num (Sum a)" (and similar for Product
00:48:30 <jared-w> > getProduct $ mappend 2 5 -- no longer ambigious. Can't get product and then use the sum mappend
00:48:32 <lambdabot>  10
00:48:55 <wilornel> yes, that's great! So we don't need @Sum anymore
00:49:02 <iqubic> geSum $ mappend 2 5
00:49:09 <merijn> wilornel: By applying getSum it infers the result of mappend must be "Sum a", thus it infers the types of 2 and 5 must be "Sum 2" and "Sum 5" and everything "Just Works"
00:49:10 <iqubic> > getSum $ mappend 2 5
00:49:11 <geekosaur> only if you can reliably do that, which you can for numeric constants _only_
00:49:12 <lambdabot>  7
00:49:16 <wilornel> RE: Forth: interesting, thanks
00:49:26 <merijn> geekosaur: Well it also works for polymorphic numeric code
00:49:39 <jared-w> We would need @Sum if we didn't use Sum(1) Sum(2)
00:49:49 <wilornel> where's the proposal on @Sum? We can tell them they forgot about getSum!
00:49:52 <jared-w> But only for defining the instances, unless things were used ambigiously
00:49:57 <wilornel> getSum $ mappend 1 2
00:49:59 <geekosaur> otherwise you will soon be as confused as the new Haskell programmer who just discovered that 2 by itself is any numeric type, but (length "xx") is not
00:50:18 <jared-w> :t length 2
00:50:18 <iqubic> :t length
00:50:20 <lambdabot> error:
00:50:20 <lambdabot>     • Ambiguous type variable ‘t0’ arising from a use of ‘length’
00:50:20 <lambdabot>       prevents the constraint ‘(Foldable t0)’ from being solved.
00:50:20 <lambdabot> Foldable t => t a -> Int
00:50:24 <iqubic> :t length x
00:50:26 <lambdabot> error:
00:50:26 <lambdabot>     • Couldn't match expected type ‘[a0]’ with actual type ‘Expr’
00:50:26 <lambdabot>     • In the first argument of ‘length’, namely ‘x’
00:50:33 <iqubic> :t length "xx"
00:50:35 <lambdabot> Int
00:50:43 <iqubic> :t length 2
00:50:43 <u-ou> :t 2
00:50:44 <lambdabot> error:
00:50:44 <lambdabot>     • Ambiguous type variable ‘t0’ arising from a use of ‘length’
00:50:44 <lambdabot>       prevents the constraint ‘(Foldable t0)’ from being solved.
00:50:45 <lambdabot> Num t => t
00:50:53 <iqubic> :t length
00:50:54 <lambdabot> Foldable t => t a -> Int
00:50:58 <wilornel> interesting, I get "Variable not in scope: x :: [a0]" for `:t length x`, and nothing about Expr
00:51:11 <jared-w> :t length (2 :: Int) 
00:51:12 <lambdabot> error:
00:51:12 <lambdabot>     • Couldn't match expected type ‘[a0]’ with actual type ‘Int’
00:51:12 <lambdabot>     • In the first argument of ‘length’, namely ‘(2 :: Int)’
00:51:19 <geekosaur> wilornel, yes, lambdabot has the simple-reflect package in scope
00:51:41 <geekosaur> ghci does not, unles syou specifically installed it and import it in ~/.ghci or w/e
00:52:03 <LordBrain> saurabhn_, maybe you are stuck using shelling and running java or something
00:52:05 <jared-w> ಠ_ಠ I'm an idiot. Stared at that for a good 5 seconds before I realized why it wasn't working
00:52:17 <wilornel> Maybe I should import `simple-reflect` when writing my solutions to the exercises in Haskell Programming from First Principles? 
00:52:18 <merijn> wilornel: That's because lambdabot has simple-reflect loaded
00:52:21 <saurabhn_> LordBrain: doesn't sound too appealing :)
00:52:23 <LordBrain> validator.nu source is on github, in java
00:52:30 <merijn> wilornel: Which lets you do some neat things, but messes with the errors
00:52:46 <merijn> > foldr f z [a,b,c] :: [Expr] -- the magic of simple-reflect
00:52:48 <lambdabot>  error:
00:52:48 <lambdabot>      • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
00:52:48 <lambdabot>      • In the expression: foldr f z [a, b, c] :: [Expr]
00:52:52 <geekosaur> heh
00:52:54 <wilornel> does it not make errors clearer?
00:52:55 <merijn> heh
00:52:57 <merijn> oh, duh
00:53:03 <merijn> > foldr f z [a,b,c] :: Expr -- the magic of simple-reflect
00:53:05 <lambdabot>  f a (f b (f c z))
00:53:14 <merijn> I was thinking of map with that type
00:53:17 <wilornel> wow what!
00:53:24 <merijn> :t f
00:53:25 <lambdabot> FromExpr a => a
00:53:26 <wilornel> you wrote the same.. - oh no
00:53:32 <merijn> :t z
00:53:33 <lambdabot> Expr
00:53:45 <wilornel> that's awesome, the simple-reflect. good learning tool
00:53:46 <merijn> wilornel: A lot of fariable names are defined as Expr, which can be pretty printed
00:54:20 <merijn> wilornel: But the result is that some results prattle about Expr, like your "x" example, since 'x :: Expr' is loaded, so you get an Expr error, rather than "variable not in scope"
00:55:06 <jared-w> oooh that's neat
00:55:49 <LordBrain> saurabhn_, well, nobody's written a validator in haskell that knows html5 it seems like nor a dtd :/
00:56:01 <wilornel> thanks merijn , geekosaur , jared-w , LordBrain , iqubic , phadej , quchen , glguy! I'll go get some ingredients for some recipes
00:56:08 <wilornel> Will think about all this in the meantime
00:56:17 <wilornel> And get back to reading the book and asking questions here later!
00:58:00 <LordBrain> a dtd would be for xhtml and thats not actually what you asked for
01:00:51 <jared-w> Dumb question: How do you actually use toS from the string the string-conv package?
01:01:30 <merijn> gah
01:02:19 <merijn> jared-w: That is an awful, awful package and you should stop using it
01:02:26 <LordBrain> hehe
01:02:36 <LordBrain> i know i never found a use for it, but it doesnt look hard
01:02:49 <LordBrain> you just need a StringConv instance
01:02:50 <geekosaur> jared-w, you likely have to provide one or both of the source and destination types. but I agree with merijn; that' package is a footgun
01:02:53 <jared-w> I've never actually used it. It's in the protolude so I was curious about it  ¯\_(ツ)_/¯
01:03:27 <merijn> jared-w: It has conversions "String -> ByteString" and "ByteString -> String" which is so evil, quchen wrote a FAQ about it, just so I don't have to keep yelling at people not to >.>
01:04:34 <LordBrain> i use packUtf8 and unpackUtf8 usually... i mean if i am using bytestrings as text
01:04:40 <quchen> FBUT, it’s an FBUT, merijn 
01:04:47 <quchen> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
01:05:27 <geekosaur> provided you know it's utf8, sure. sadly I still live in a world where I regularly have to deal with iso8859-1/iso8859-15, and occasionally other iso8859 encodings
01:05:39 <geekosaur> and (as little as possible) the old mac roman-8
01:06:17 <merijn> If you *know* it's utf8, then decode it and done
01:06:19 <jared-w> oooh neat, I'll read through all of that
01:06:28 <merijn> If you don't know, find out or lose your sanity
01:06:34 <LordBrain> your world sucks
01:06:42 <geekosaur> whereas that package, no matter what it does, is going to silently do something wrong with anything above 0x7f
01:06:48 <merijn> LordBrain: Where's packUtf8 from?
01:07:07 <LordBrain> merijn its my own... but i stole it from utf8-strings... just renamed
01:07:13 <jared-w> The main reason I asked was because length ("22" :: String) works fine, but length ("22" :: Text) does not
01:07:38 <LordBrain> merijn, its also in opengl package oddly
01:07:48 <geekosaur> mono-traversable package is slightly more principled
01:08:04 <merijn> LordBrain: As long as unpackUtf8 returns an Either, it's acceptable
01:08:09 <geekosaur> (its main failure mode is that if you do the wrong thing, it silently produces extremely show code)
01:08:10 <LordBrain> but i rolled my own so i can use it outside of opengl stuff
01:08:14 <geekosaur> *slow code
01:08:39 <LordBrain> no its inverse, replacement chars
01:09:27 <LordBrain> no Either
01:10:59 <merijn> LordBrain: hmmm, borderline acceptable...
01:13:30 <nshepperd_> Which package has the one true utf8 decoder we should use
01:13:51 <jared-w> hah, "one true" is incompatible with "utf8" :p
01:14:09 <merijn> nshepperd_: text has "Data.Text.Encoding" which has most of the common ones
01:14:40 <merijn> nshepperd_: If you need more obscure encodings, use the encoding package
01:16:13 <merijn> But since basically everyone already depends on text I don't really understand all the decode wrapping packages
01:16:44 <geekosaur> everyone is convinced there's one true simple way
01:16:59 <geekosaur> that "simple, elegant, and wrong" misquote comes to mind
01:17:42 <jared-w> Kinda like the "let's write quicksort in 2 lines" haskell code?
01:17:53 <merijn> You should, however, avoid the decodeUtfX functions at the top and use either "decodeUtf8' :: ByteString -> Either UnicodeException Text" or use decodeUtf8With and explicitly specify what to do on error
01:18:09 <merijn> jared-w: To be fair, implementing mergesort instead of quicksort is actually pretty simple
01:18:19 <merijn> jared-w: Even the optimised one in base is very readable
01:18:39 <jared-w> Which makes me sad that everyone goes for the wrong quicksort instead of showing off haskell's magic with mergesort
01:18:48 <cocreature> merijn: but it doesn’t use the universal datastructure!
01:19:01 <nshepperd_> Ew, the the default decodeUtf8 function throws a pure exception
01:19:07 <jared-w> or the "sieve of erathosenes" using a worse than quadratic complexity ಠ_ಠ
01:19:23 <merijn> cocreature: True
01:19:34 <merijn> nshepperd_: Hence decodeUtfXWith
01:30:03 <LordBrain> jared, i dont have fonts installed to see your kannada eye balls, what if any package do you recommend if it is merely for this purpose?
01:31:09 <LordBrain> fonts-gubbi,fonts-knda,fonts-lohit-knda, fonts-navilu
01:31:27 <jared-w> Whatever font package installs the kannada script? Any of them will work fine
01:32:10 <LordBrain> there should be a fonts-eyeballs
01:32:15 <LordBrain> then i'd know
01:32:18 <LordBrain> thats the one
01:32:30 <jared-w> Now... Is there a reason why it's impossible to make Text have a Foldable instance?
01:33:05 <jared-w> It seems unnecessary to provide an entirely separate length, foldl, etc., all just for the Text package
01:37:53 <pacak> :t foldl
01:37:54 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
01:38:16 <pacak> @info Foldable
01:38:16 <lambdabot> Foldable
01:38:25 <pacak> Thank you lambdabot.
01:38:51 <jared-w> lol
01:39:45 <jared-w> There is no Foldable instance of Text. It seems like there should be since all of the functions are in the Text library...
01:40:19 <atodorov> hi folks, I get the following compilation error for my tests:   • Couldn't match expected type ‘IO a0’ with actual type ‘Maybe Tag’
01:40:19 <atodorov> • In the first argument of ‘shouldThrow’, ...   does this mean the function I'm testing whould return 'IO a' if I want to be able to validate that it throws an exception ? is there an easy way to verify the function throws exception without changing the return type?
01:41:40 <mniip> jared-w, Text has the wrong kind
01:42:03 <LordBrain> atodorov, i'm not sure i know what your situation is, but i think if i do, you could probalby just put a return $ in front of it
01:42:32 <LordBrain> as in return blob `shouldThrow` x, rather than blob `shouldThrow` x
01:43:14 <LordBrain> its shouldThrow that is expecting (IO a) in its first argument
01:43:49 <jared-w> mniip: what do you mean by that?
01:44:07 <atodorov> LordBrain: thanks, that seems to work. The test faile though, it expected exception wasn't raised but I guess that could be a problem with implementation
01:44:19 <mniip> jared-w, how would you write foldr
01:44:34 <merijn> jared-w: Note that Foldable wants functions that are "a -> b -> a", whereas Text can only work with "Char -> Char -> Char"
01:44:58 <mniip> merijn, I would expect Char -> b -> b?
01:45:06 <mniip> :t T.foldr
01:45:08 <lambdabot> error:
01:45:08 <lambdabot>     Not in scope: ‘T.foldr’
01:45:08 <lambdabot>     Perhaps you meant one of these:
01:45:23 <jared-w> ahh, okay, so you would need foldr1, etc?
01:45:26 <merijn> mniip: I suppose that could work, yes
01:45:55 <mniip> :t Data.Text.foldr
01:45:57 <lambdabot> (Char -> a -> a) -> a -> Data.Text.Internal.Text -> a
01:46:05 <merijn> jared-w: "Foldable t => t a" <- Foldable expects a type that accepts a type parameter, but Text doesn't
01:46:12 <merijn> mniip: I was doing foldl, though :p
01:46:16 <mniip> :t Data.Text.foldl
01:46:16 <merijn> :t Data.Text.foldl
01:46:17 <lambdabot> (a -> Char -> a) -> a -> Data.Text.Internal.Text -> a
01:46:18 <lambdabot> (a -> Char -> a) -> a -> Data.Text.Internal.Text -> a
01:46:29 <jared-w> Nice to know you two have the exact same typing speed
01:46:39 <mniip> it's the 1 versions that do Char->Char->Char
01:49:18 <jared-w> merijn: and there's no way to shoehorn Text into being foldable? I don't really think anyone would wnat that, anyway
01:49:43 <cocreature> jared-w: MonoFoldable :)
01:49:53 <mniip> data TextF (a :: *) where TextF :: Text -> TextF Char
01:50:19 <jared-w> oooh, now that looks useful
01:50:22 <mniip> but you still can't write Functor
01:50:27 <mniip> the instance I mean
01:50:35 <LordBrain> i suppose you could generalize to Storable c,Num c... hmm... not worth it
01:50:36 <jared-w> and now I come back around to mono-traversable
01:50:56 <mniip> oh Foldable has no superclass
01:51:32 <LordBrain> i think efficiency is generally considered more important than generalizing in that package
01:51:33 <merijn> ok, let's talk unboxed vectors!
01:51:55 <merijn> I have a struct of values that I want to all dump into an unboxed vector, what's the easiest approach?
01:52:07 <jared-w> Write code in C /s
01:52:22 <merijn> Storable? I don't really feel like dealing with Storable, though
01:53:02 <jared-w> You're using Data.Vector.Unboxed right?
01:53:13 <LordBrain> struct as in c struct or struct as in haskell record?
01:53:56 <merijn> LordBrain: Struct as in "I don't care", I have a couple of ints and doubles that belong together and should be inside the vector adjacently
01:54:05 <LordBrain> There's also DAta.Array.Unboxed... might be a better fit depending on the project and existing dependencies
01:54:51 <LordBrain> there's c-storable-array too.. which i think is kinda cool, but its marked as experimental
01:55:03 <quchen> merijn: Data.Vector.Storable?
01:55:22 <merijn> quchen: Yeah, that was my backup plan, but I dislike dealing with Storable instances, since they're a PITA to write :p
01:55:29 <LordBrain> oh what you're saying is the heterogenousness is the issue you want to get around?
01:55:35 <quchen> merijn: Agreed!
01:55:46 <merijn> quchen: I'm not required to be compatible with C, though so if anything else works
01:55:52 <LordBrain> as in, how to deal with the fact that your types arent homogenous in your unboxed vector
01:56:24 <merijn> LordBrain: I literally just want "struct foo { int x, y; double a, b, c; }; struct foo vector[1000];"
01:56:32 <LordBrain> there's also data.bitsyntax
01:56:33 <merijn> LordBrain: They are homogeneous
01:56:45 <merijn> Just compound values
01:57:03 <LordBrain> https://hackage.haskell.org/package/BitSyntax-0.3.2.1/docs/Data-BitSyntax.html
01:57:09 <LordBrain> might do ya
01:57:23 <cocreature> merijn: if you don’t wnat storable you could provide a Prim instance but I’m not sure if that’s any better
01:58:38 <merijn> cocreature: hmm, that'd require always accessing the entire struct, but that might not be an issue, I guess...lemme check my code
01:58:49 <LordBrain> merijn, the normal thing is to write a instance for cereal or binary
01:58:56 <merijn> LordBrain: wut
01:58:57 <LordBrain> i think
01:59:04 <LordBrain> well
01:59:06 <merijn> LordBrain: I think you're confused about what the question was
01:59:16 <merijn> cereal/binary are for parsing binary data
01:59:32 <LordBrain> meaning, you want random access
01:59:39 <LordBrain> and so serializing wont do
02:00:23 <cocreature> merijn: I guess a struct of unboxed vectors isn’t sufficient? otherwise you could just use a tuple
02:00:27 <merijn> cocreature: I think I'll do that. Seems like I always access minimum 4 of 5 fields in the struct every access
02:00:44 <merijn> cocreature: struct of unboxed vectors costs me the caching I designed for
02:00:56 <cocreature> yeah
02:01:47 <merijn> oh, wait, unboxed supports tuples already
02:02:02 <merijn> Guess I'll just turn it into a tuple then
02:02:04 <cocreature> yes but that’s a struct of vectors
02:02:06 <cocreature> iirc
02:02:12 <cocreature> or a tuple of vectors
02:02:37 <LordBrain> i hate to reveal my ignorance here, but i'm searching and its not showing up, is there a Prim class that serves as a storable alternative?
02:02:58 <merijn> cocreature: It is? That's dumb
02:03:22 <cocreature> LordBrain: https://hackage.haskell.org/package/primitive-0.6.2.0/docs/Data-Primitive-Types.html#t:Prim
02:03:46 <cocreature> merijn: if the relevant code in vector wasn’t generated via C macros or something I might be able to find it to confirm this
02:03:58 <merijn> cocreature: oh, you're right :\
02:04:10 <cocreature> merijn: also I wouldn’t necessarily say it’s bad. if you only access parts of your tuple it might even be better from a caching perspective
02:04:17 <merijn> https://github.com/haskell/vector/blob/master/internal/unbox-tuple-instances#L5-L20
02:04:33 <merijn> cocreature: Except I access 4 out of 5 fields every access
02:04:48 <cocreature> right for your usecase it’s bad :)
02:05:01 <merijn> ok, so storable it is, I guess
02:05:06 <cocreature> or Prim
02:05:25 <cocreature> but writing Prim instances is even more annoying than writing Storable instances
02:05:34 <merijn> cocreature: Exactly :p
02:06:27 <LordBrain> you can generate storable instances
02:06:38 <saurabhn_> How to conditionally parse JSON based on settings in a Reader environment? - https://stackoverflow.com/questions/44516946/how-to-conditionally-parse-json-based-on-settings-in-a-reader-environment
02:06:39 <LordBrain> using c-storable-deriving package
02:07:26 <cocreature> saurabhn_: you might want to take a look at http://newartisans.com/2017/02/a-case-of-reflection/
02:10:04 <saurabhn_> cocreature: related to my SO post or earlier QC questions?
02:10:27 <cocreature> saurabhn_: SO
02:11:14 <saurabhn_> cocreature: is the basic idea to add the precision into the data type itself?
02:12:00 <cocreature> no, read the post
02:14:42 <saurabhn_> cocreature: my mind switches off when I read reify and proxy. Trying to read now...
02:15:05 <cocreature> saurabhn_: alternatively just don’t use the FromJSON instance and use "decodeWith" instead of "decode"
02:16:44 <rydia5[m]> hiiii
02:21:57 <LordBrain> cocreature, so if i read this all right, your answer to saurabhn_ entails using Reifies and Tagged, to pass parameters to the FromJSON instance?
02:25:17 <LordBrain> instance Reifies s Int => FromJSON (Tagged s Data.Decimal.Decimal where
02:26:04 <LordBrain> that is a neat trick, if a bit unfortunate in terms of redability
02:26:11 <cocreature> LordBrain: yes, reify basically gives you a way to pass dynamic data into a typeclass instance even if the signature doesn’t allow for that. in the example in this post that’s some kind of integer in saurabhn_’s case that would be the currency
02:26:39 <cocreature> LordBrain: you get used to it but if you can avoid it you probably should :)
02:26:48 <cocreature> in this specific case I would probably just use decodeWith
02:27:08 <cocreature> but sometimes you’re forced to use a typeclass instance and then this can save you
02:27:08 <LordBrain> or a newtype
02:27:45 <cocreature> I’m not sure how a newtype allows you to dynamically select between different instances.
02:27:54 <LordBrain> he could just make an instance for (currency,Decimal) instead... no?
02:27:58 <cocreature> if the number of currencies is fixed you could do some GADT stuff
02:28:32 <LordBrain> well you construct the product when you know the currency, and you then parse the json using the product instance
02:29:05 * hackage hint 0.7.0 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.7.0 (mvdan)
02:29:10 <cocreature> yeah if there is a fixed number of currencies that works
02:29:17 <LordBrain> i guess that assumes its straightforward to convert currency to .. yeah
02:32:26 <LordBrain> if you use the trick, a good courtesy would be to comment it... as a lot of people are going to look at that and glaze over
02:33:28 <LordBrain> something like -- I'm just using Reifies & Tagged to get extra parameters to my instance, as per and put the url... heh
02:40:05 * hackage smiles 0.1.0.0 -   https://hackage.haskell.org/package/smiles-0.1.0.0 (fonturacetamum)
02:54:10 <saurabhn_> LordBrain: cocreature: here's another approach - what do you think about it? https://stackoverflow.com/questions/44516946/how-to-conditionally-parse-json-based-on-settings-in-a-reader-environment#comment76027997_44516946
02:57:57 <Itkovian> hi. I'm a bit out of my depth here. I have a function \s m f -> lift (SMM.receive s) >>= yield >> f :: (ZMQ.Receiver s, MonadIO m) =>  ZMQ.Socket s  -> t  -> ConduitM i SBS.ByteString m b     -> ConduitM i SBS.ByteString m b. In practice, the f is the function itself, so I'm looping. Now, I want to get out if an MVar a is set to something besides 0, so I thought f would contain some withMVar construct that then loop back if the value in the MVAr
02:57:57 <Itkovian>  == 0 and do a return () otherwise. But obviously, this is a no go, since withMVar executes in IO and I cannot get that to match the ConduitM ... that is expected. Any suggestions?
02:58:33 <Itkovian> The key idea here is to have something like http://zguide.zeromq.org/hs:interrupt, but then in a conduit setting.
03:08:35 * hackage text-metrics 0.3.0 - Calculate various string metrics efficiently  https://hackage.haskell.org/package/text-metrics-0.3.0 (mrkkrp)
03:41:16 <LordBrain> saurabhn_, thats equivalent to what i suggested with the tuple
03:41:30 <LordBrain> if it works for you, then go wiht it
03:42:05 <LordBrain> the reify approach is likely overkill for your needs
03:44:11 <merijn> :O
03:44:19 <merijn> GHC 8.2 will have data baking? :D
03:46:30 <srhb> What? :P
03:47:18 <merijn> srhb: That's where you dump/load binary data to/from file directly
03:47:31 <merijn> srhb: Think of mmapping a file into a struct pointer with C
03:50:56 <merijn> oh, I think he was just talking about compact regions
03:53:00 <srhb> merijn: Oh, okay.
04:15:21 <merijn> hmm, any opinions how long import lists should be linewrapped?
04:16:53 <Itkovian> merijn stylish-haskell?
04:21:22 <merijn> Itkovian: I'm not liking what I'm seeing as default there
04:22:00 <Itkovian> how long are we taling about and why not import qualified?
04:22:26 <quchen> Then don’t use the default! I use »align: group; list_align: after_alias; long_list_align: new_line_multiline«
04:22:41 <merijn> quchen: I'm not using tools to auto align anyway
04:22:53 <quchen> Okay
04:23:14 <quchen> Then I recommend you do exactly what stylish-haskell does automatically, but by hand.
04:23:16 <merijn> Itkovian: 7 or so names
04:23:37 <merijn> quchen: I don't like what stylish-haskell does, so no :p
04:23:42 <Itkovian> :)
04:23:51 <Itkovian> you can submit a PR :)
04:23:52 <quchen> Then I recommend you do exactly what stylish-haskell does automatically with my config, but by hand.
04:24:19 <merijn> quchen: No clue what your config does :p
04:25:41 <quchen> merijn: You can use stylish-haskell to find out, and then manually type its output into your editor window. That way you’re not using it, but you get the same result!
04:26:12 <quchen> Or you email me your files and I’ll send you the diff back.
04:26:25 <quchen> That way you’re only using me, not stylish-haskell.
04:26:30 <quchen> It’s like a transitive dependency.
04:26:49 <merijn> quchen: Can I make you do my other work too? :p
04:27:10 <quchen> Sure!
04:27:36 <suppi> hello, i've opened a Process using the process library and would like to send Ctrl-C (SIGINT) to the process but am unsure how to do that
04:27:49 <merijn> suppi: unix package
04:28:00 * ski . o O ( `import Mob\n  ( foo\n  , Bar\n    ( baz\n    , baz\n    )\n  , quux\n  )' )
04:28:54 <suppi> merijn, I have a ProcessHandle from createProcess but no ProcessId
04:31:06 <merijn> suppi: https://stackoverflow.com/questions/27388099/how-to-get-the-process-id-of-a-created-process-in-haskell
04:32:56 <suppi> merijn: thank you
04:45:35 * hackage siphon 0.7 - Encode and decode CSV files  https://hackage.haskell.org/package/siphon-0.7 (andrewthad)
04:46:34 * hackage hakka 0.2.0 - Minimal akka-inspired actor library  https://hackage.haskell.org/package/hakka-0.2.0 (martinrign)
04:58:19 <muzzle> hi, what's the fastest way that I can do something like [(a,b)] -> Map a [b] where I want to get all bs categorized by the as. Currently I am using HashMap (strict) from unordered-containers and do inserts with 'alter'. Is there something I can do faster?
05:01:54 <bartavelle> fromListWith (++) ?
05:01:56 <phadej> I'd do [(a, b)] -> [(a, [b])] and use fromListWith (++); maybe use dlist
05:02:18 <phadej> not sure if it's faster, but at least less code
05:02:26 <bartavelle> fromListWith (++) . map (fmap pure)
05:02:33 <merijn> Oh, look. Yet another case where the Monoid on Map is useless, but the sensible Monoid would've been amazing!
05:02:45 <muzzle> phadej that's what I did first. But it's way slower.
05:02:50 <bartavelle> merijn: aren't they adding newtypes for that ?
05:02:59 <merijn> Screw this semigroup proposal. Can we just rip out map's monoid instance and fix this grave injustice
05:03:02 <merijn> bartavelle: Still
05:03:13 <merijn> bartavelle: I've literally never encountered a use case for the current instance
05:03:27 <bartavelle> I do!
05:03:37 <merijn> bartavelle: Oh? What?
05:03:47 <bartavelle> for example implementing how hiera works, you merge maps and one has priority
05:03:57 <merijn> bartavelle: Then you can just use
05:03:58 <phadej> muzzle: I'd try `dlist` for the elements
05:04:00 <merijn> :t M.unions
05:04:01 <lambdabot> Ord k => [M.Map k a] -> M.Map k a
05:04:08 <phadej> muzzle: then they will concatenate way faster
05:04:10 <bartavelle> that is entirely true
05:04:13 <phadej> or should...
05:04:15 <quchen> merijn: I’ve used Map’s monoid and find it useful
05:04:30 <merijn> quchen: More useful than the sensible one I complained about on the mailing list?
05:04:34 <quchen> Okay, the default chocice may be arbitrary
05:04:44 <quchen> What’s that one?
05:04:58 <bartavelle> Monoid v => Monoid (Map k v) ?
05:05:06 <merijn> quchen: "instance (Ord k, Monoid v) => Monoid (Map k v)"
05:05:24 <quchen> How is that one better?
05:05:43 <bartavelle> quchen: I use that one much more often than the current one, so it would be better for me
05:05:45 <quchen> It’s also true, sure. But changing a default instance is impossible
05:05:51 <merijn> quchen: Well, the above "how do I merge does becomes "foldMap (curry M.singleton)"
05:06:18 <Gurkenglas> merijn: Shouldn't that be Semigroup?
05:06:19 <merijn> quchen: I use it with Validation to collect type errors, I use it with lists of tuples to gather up tuples per key...
05:06:32 <bartavelle> quchen: I have map newtypes in several projects I wrote too ...
05:06:37 <piyush-kurur> saurabhn_: ping
05:06:42 <quchen> unUnionMap . foldMap (\x -> UnionMap (…))
05:06:47 <Gurkenglas> merijn, it's the same problem as with intersections
05:07:12 <merijn> Gurkenglas: Until Semigroup is in base and a superclass of Monoid, it doesn't exist for me
05:07:27 <cocreature> merijn: Semigroup is already in base :)
05:07:34 <merijn> cocreature: As of which GHC?
05:07:40 <cocreature> merijn: 8.0
05:07:42 <cocreature> iirc
05:08:05 <merijn> cocreature: Not a superclass of Monoid yet, though
05:08:08 <cocreature> yeah
05:08:24 <merijn> So practically useless, given the proliferation of monoids with no Semigroup
05:08:37 <Gurkenglas> Looks like it's on its way to become that though, so we shouldn't introduce wrong instances for Map
05:08:39 <muzzle> phadej: Using alter does better than using list ++ which should be O(1) for single element lists (probably because I can skip allocating cons cells altogether).
05:08:47 <merijn> Gurkenglas: Yeah, the goal is 8.4 I believe
05:09:05 * hackage schematic 0.1.3.0 - JSON-biased spec and validation tool  https://hackage.haskell.org/package/schematic-0.1.3.0 (dredozubov)
05:09:22 <merijn> Gurkenglas: Changing that instance of Map can be trivially changed, since the Semigroup constraint makes it strictly more general
05:11:28 <Gurkenglas> "Monoid m => Monoid (M.Map k m)" could only be minor-version changed to "Semigroup m => Monoid (M.Map k m)", not "Semigroup m => Semigroup (M.Map k m)".
05:13:19 <Gurkenglas> Though I suppose whether Monoid is okay on the rhs depends on whether you want it zippy
05:13:50 <Gurkenglas> Um, uniony vs intersectiony
05:15:44 <Gurkenglas> (for uniony, mempty would be M.empty, for intersectiony, mempty would be M.full mempty, which only works with the data structure in the same way that semigroups can be turned into monoids)
05:19:24 <Gurkenglas> (And if someone ever traverses M.full mempty, you're in trouble)
05:20:12 <ilyaigpetrov> what's the difference between Integer and Integral?
05:20:40 <lyxia> ilyaigpetrov: Integer is a type. Integral is a type class.
05:21:25 <Gurkenglas> (Though I suppose full maps would still be Foldable if you only ever map monoid homomorphisms over it.)
05:21:40 <ilyaigpetrov> lyxia: what set of types does Integral typeclass includes?
05:21:49 <fragamus> edwardk I am working with Linear and need to compute a covariance matrix.  Is there anything I should be using or is it cool to just roll my own?
05:22:59 <ilyaigpetrov> lyxia: found Integer and Int, thanks for your answer
05:23:19 <lyxia> ilyaigpetrov: they are listed in the docs
05:25:32 <ilyaigpetrov> haskell-docs Integral ?
05:26:16 <phadej> muzzle: thst's why i tell you to try dlist or Endo [a]
05:28:28 <ilyaigpetrov> found via hoogle
05:56:47 <kuznero> Hi All!
05:57:07 <kuznero> Can anybody tell what is the status of Cloud Haskell?
05:59:31 <locallycompact> kuznero, what information are you after?
05:59:36 <saurabhn_> piyush-kurur: here
06:00:40 <kuznero> locallycompact: basically what is the status, how vibrant is it? There was a big hope some year ago, but now I see that last release 0.6 happened more than a year ago. So, does it worth digging into it or the idea was abandoned?
06:01:14 <locallycompact> well I don't know about active development, but I have recently picked it up and managed to make it do things
06:01:34 <locallycompact> it's the only thing in its class to my knowledge
06:01:50 <piyush-kurur> saurabhn_: Have a look at https://github.com/piyush-kurur/sample-code/blob/master/haskell/TryGen.hs
06:02:06 <locallycompact> kuznero, here is a stack thing that I put together that spins up some nodes: https://gitlab.com/locallycompact/CloudHaskellTemplate
06:02:16 <piyush-kurur> I guess that should do what you wanted of Generics
06:02:25 <kuznero> locallycompact: interesting, how is it compare to beam of erlang&otp? Is it based on the same principles? with supervisors? Is it actor-based?
06:06:43 <locallycompact> kuznero, I'm not familiar with erlang or distributed stuff in general, but a couple of days of running into walls got me to that example
06:07:16 <locallycompact> the typed channels are pretty good
06:07:28 <locallycompact> they make sense to me
06:07:51 <locallycompact> as long as you can derive Typeable and Binary on a data type you can serialize it and fling it to another node
06:08:21 <kuznero> locallycompact: I see. Thanks
06:10:41 <saurabhn_> piyush-kurur: thanks a lot! Let me pore over that and come back with questions, if any.
06:13:49 <piyush-kurur> saurabhn_: just remember that some of the stuff there is strictly not required but it helps clean up the code (in my view)
06:14:02 <piyush-kurur> You probably can get away with some simpler stuff
06:15:04 <piyush-kurur> I think you were having trouble in getting the field values for  parsing a record
06:16:47 <piyush-kurur> If you look at https://github.com/piyush-kurur/sample-code/blob/master/haskell/TryGen.hs#L70 you can see how this is done
06:16:54 <piyush-kurur> This is a standard idiom
06:18:33 <fosskers> Strange thing happening. I'm `mapM`ing through a list using `State`. Lazy State speeds up my benchmarks, but Strict State makes the function in question use much less total CPU and memory when I profile it.
06:19:25 <fosskers> You'd think the profiling results are the "real truth". If so, why do my benchmarks slow down with Strict State?
06:19:38 <piyush-kurur> fosskers: be carefull with benchmakring lazy code
06:19:52 <piyush-kurur> it might not be evalutating it fully
06:20:24 <fosskers> in this case, I'm testing some streaming code. The end result runs through criterion's `nfIO`
06:22:44 <cocreature> fosskers: show us the code :)
06:23:03 <quchen> Be careful with profiling, it changes runtime behavior
06:29:16 <fosskers> http://lpaste.net/356197
06:29:55 <fosskers> compared to the whole library, this is just one tiny function. lazy state balloons is total alloc share to 10% though
06:30:01 <fosskers> strict state brings it down to 3%
06:30:39 <merijn> Well, less memory allocation isn't necessarily faster
06:31:03 <fosskers> it brings down CPU share as well
06:31:12 <fosskers> from 1.4% to < 0.5
06:31:35 <fosskers> most of the CPU share is gobbled by my attoparsec parser, which is where I need to focus my efforts, I think
06:31:49 <fosskers> I should be able to get an order of mag faster than I am
06:32:08 <cocreature> I suspect that the strict state is forcing the whole list computation whereas the lazy state can incrementally give you back elements
06:32:22 <cocreature> might be worth trying to do it without state
06:32:49 <cocreature> also you probably want modify'
06:33:18 <fosskers> I thought so too that axing state is probably the best, but I'm pretty sure I need to maintain the order
06:33:50 <fosskers> then (at the time, yesterday) I got into debates with myself about laziness and tail recursion, and eventually stuck with the State version
06:34:06 <saurabhn_> in tasty, why is this not actually hiding all successful tests? ==>   defaultMain $ localOption (HideSuccesses True) $ tests dbPool 
06:34:29 <cocreature> > scanl' (+) [x,y,z] (a :: Expr)
06:34:30 <lambdabot>  error:
06:34:30 <lambdabot>      • Couldn't match expected type ‘[[Expr]]’ with actual type ‘Expr’
06:34:30 <lambdabot>      • In the third argument of ‘scanl'’, namely ‘(a :: Expr)’
06:34:45 <cocreature> > scanl' (+) (a :: Expr) [x,y,z]
06:34:47 <lambdabot>  [a,a + x,a + x + y,a + x + y + z]
06:34:57 <cocreature> fosskers: I think that’s exactly what you’re doing here
06:35:29 <cocreature> hm minus the last value. are you sure you intend to ignore z?
06:35:55 <fosskers> modify' gave a nice speed up
06:36:39 <fosskers> no, z shouldn't be ignored. is there a little bug there?
06:37:02 <fosskers> no doesn't look like it
06:37:17 <fosskers> or wait, perhaps there is
06:37:52 <cocreature> fosskers: for the last value in xs, you’ll get prev, call modify (n+) but then you just return prev and never look at the final value
06:38:26 <cocreature> fosskers: I’d be interested in how the scanl' version performs in your benchmark if you decide to try it out
06:38:56 <fosskers> I'm trying everything, so in it goes
06:42:47 <fosskers> holy moly
06:42:49 <fosskers> what a speed up
06:43:00 <fosskers> 50ms -> 31.9 ms
06:43:07 <cocreature> nice :)
06:43:18 <fosskers> scanl, where have you been all my haskell career?
06:43:24 <fosskers> "right here, buddy"
06:47:20 <merijn> fosskers: Got a version of your parser online somewhere?
06:48:56 <fosskers> Yes. I decided to hand-write a protobuf parser for OSM data using attoparsec and the `streaming` library's support for streamed parsing
06:49:37 <fosskers> I figured a hand-written one would be faster (and better on memory - I'm trying to parse a 35gb file eventually) than the available protobuf libs we have.
06:50:20 <merijn> fosskers: Am I right in assuming this 35GB basically consists of a large amount of relatively reasonably sized records?
06:54:20 <fosskers> that's right
06:54:37 <fosskers> https://github.com/fosskers/streaming-osm/pull/1
06:55:04 <fosskers> hence streaming
06:55:27 <fosskers> using this: https://hackage.haskell.org/package/streaming-utils-0.1.4.7/docs/Data-Attoparsec-ByteString-Streaming.html
07:02:24 <jerbome> I'm trying wrap my head around Comonad, and the only layman term analogy that I can think of is "it's a collection of item with a focus on one of the item in the collection"
07:02:47 <jerbome> this analogy works for extract, but not really for duplicate and extend
07:03:10 <jerbome> can someone ELI5 extend and duplicate ?
07:06:00 <Sweet> hello!! I have a quick question. I never defined custom operator in Haskell before, and I wonder why this fails : http://lpaste.net/356199
07:06:26 <blackdog> Sweet: usually helpful to paste the error too
07:06:28 <merijn> Sweet: Operators can't start with : :)
07:06:41 <Sweet> I get "invalid type signature: (:=:) :: ... Should be of form <variable> :: <type>"
07:06:41 <merijn> Sweet: Or rather, they can, but only if they're constructors :p
07:07:03 <Sweet> constructors ?
07:07:10 <merijn> Sweet: ':' was (arbitrarily) picked to be the "uppercase" symbol, since constructors should start with a capital letter
07:07:25 <merijn> Sweet: As in, Just, Left, etc.
07:07:38 <Sweet> woo
07:07:41 <Sweet> thanks !
07:07:53 <merijn> @let data MyList a = a ::: (MyList a) | Empty deriving (Show)
07:07:54 <lambdabot>  Defined.
07:08:03 <merijn> > 1 ::: True ::: Empty
07:08:05 <lambdabot>  error:
07:08:06 <lambdabot>      Ambiguous occurrence ‘Empty’
07:08:06 <lambdabot>      It could refer to either ‘Lens.Empty’,
07:08:11 <merijn> ah, oops...
07:08:14 <merijn> > 1 ::: True ::: L.Empty
07:08:16 <lambdabot>  error:
07:08:16 <lambdabot>      • Couldn't match expected type ‘MyList a’ with actual type ‘Bool’
07:08:16 <lambdabot>      • In the second argument of ‘(:::)’, namely ‘True’
07:08:22 <merijn> And I'm not thinking...
07:08:26 <merijn> > False ::: True ::: L.Empty
07:08:28 <lambdabot>  error:
07:08:28 <lambdabot>      • Couldn't match expected type ‘MyList Bool’
07:08:28 <lambdabot>                    with actual type ‘Bool’
07:08:36 <merijn> @undefine
07:08:36 <lambdabot> Undefined.
07:08:38 <glguy> association
07:08:45 <merijn> Yeah, mixing fixity
07:08:51 <merijn> But now I'm too lazy to fix it :p
07:08:59 <merijn> Sweet: Anyway, you get the idea :)
07:09:26 <Sweet> yes, thanks !
07:09:42 <Sweet> oh
07:09:44 <Sweet> second question
07:10:20 <Sweet> when I replace it by " (=:=),(=!=) :: a -> a -> Bool" , I get "parse error on input ','"
07:10:33 <merijn> Sweet: Inside the class?
07:10:35 <Sweet> can't you use that syntax to declare multiple functions with the same type ?
07:10:36 <Sweet> yes
07:10:54 <merijn> Sweet: I know you can *outside* a class declaration, but I'm not sure about inside...
07:12:27 <Sweet> well, that's ok !
07:12:34 <Sweet> thanks for helping =)
07:19:34 * hackage opencv-extra 0.0.0.0 - Haskell binding to OpenCV-3.x extra modules  https://hackage.haskell.org/package/opencv-extra-0.0.0.0 (RoelVanDijk)
07:20:34 * hackage coin 1.2.1 - Simple account manager  https://hackage.haskell.org/package/coin-1.2.1 (piotrborek)
07:26:30 <ckubrak> Hi guys, I'm reading LYAH and there's something I don't understand: I have a dictionary (List of tuples) and I want to find the value (snd) using a key (fst). In the book they use this function:
07:26:34 <ckubrak> findKey key xs = foldr (\(k, v) acc -> if key == k then Just v else acc) Nothing xs
07:26:56 <ckubrak> I can't understand what's the "acc"
07:27:02 <shapr> short for accumulator
07:27:18 <shapr> does that help any?
07:27:20 <ski> `acc' represents the result of the recursive call to `foldr', on the tail of the list
07:29:49 <quchen> foldr does not have an accumulator, just like map does not have an accumulator
07:29:52 <ski> (you could think of it, paired with the result of that function argument, as representing an accumulator .. if you think of it as being "passed upwards", rather than downwards. `Nothing' initializes it at the end of the list. if the list is infinite, there is no initial value, but that's ok, in case the value is found, since the evaluation order is "backwards" wrt the direction the "accumulator" is passed)
07:30:16 <ckubrak> Ok, I'm still trying to understand it. I do know how to make it entirely with recursion but I'm having a hard time with folds
07:30:40 <ski> if you have
07:31:02 <ski>   frob [    ] = ...
07:31:25 <ski>   frob (x:xs) = ..x..(frob xs)..
07:31:31 <ski> then this is equivalent to
07:31:40 <saurabhn_> does createProcess block?
07:31:53 <ski>   frob = foldr (\x acc -> ..x..(acc)..) (...)
07:32:50 <ski> the second argument to `foldr' is the base case expression. the first argument is the recursive case expression, abstracted over the first (iow current) element, and the *recursive call* on the remaining elements (the tail)
07:33:08 <exbri> Hi!
07:33:32 <exbri> I'd like to return an IO value of an element of a list. how do i do that?
07:33:35 <ski> so in your case, the `foldr'-based definition of `findKey' is equivalent to
07:33:46 <ski>   findKey key [    ] = Nothing
07:34:03 <ski>   findKey key (x:xs) = if key == k then Just v else (findKey key xs)
07:34:06 <Gurkenglas> :t fmap :: (a -> b) -> IO a -> IO b -- exbri, does this help?
07:34:08 <ski> ckubrak : makes sense ?
07:34:08 <lambdabot> (a -> b) -> IO a -> IO b
07:34:49 <ski> `acc' corresponds to the recursive call `findKey key xs' here
07:35:02 <ckubrak> Here's a simple example of foldr: foldr (||) False [True,False,...]
07:35:16 <ski> (oh, sorry, the list element should be `(k,v)', not `x' ..)
07:35:33 <exbri> Sorry, but I don't think so
07:36:00 <ski> exbri : which element ?
07:36:06 <ckubrak> I can't see where do I tell haskell that I want to "ovewrite" the Nothing with "Just v"
07:36:11 <exbri> I'm trying to get a random element of a list, and return it with the rest of the list 
07:36:21 <exbri> (the rest is also randomized)
07:39:31 <louispan> How do I get ghc or stack to print the package id of my package? eg data-blah-0.1.0.0-2Bc1y3tct4m3vdObzFSs1i
07:41:00 <ski> ckubrak : for a finite list, you can to a first approximation think of the result corresponding to the end of the list (the empty list) to be `Nothing'. then `if key == k0 then Just v0 else Nothing' (`Nothing' coming from just before) will be the result corresponding to the singleton list containing only the last element `(k0,v0)' of the list
07:41:09 <ski> ckubrak : then `if key == k1 then Just v1 else ...' will be the result for the dupleton list starting with `(k1,v1)', continuing with that singleton list, where `...' is the previously mentioned result (either `Nothing' or `Just v0')
07:41:35 <louispan> I worked it out: stack exec ghc-pkg describe <package-name>
07:41:40 <ski> ckubrak : under this understanding, you start at the end of the list, with `Nothing', and work your way back
07:42:11 <ckubrak> I think I got it
07:42:44 <ckubrak> In here:
07:42:49 <ckubrak> findKey key xs = foldr (\(k, v) acc -> if key == k then Just v else acc) Nothing xs
07:42:56 <ski> ckubrak : however, the actual order of evaluation is the reverse of this. it starts at the first element of the list, not having bothered to compute the result for the remainder of the list yet. only if the conditional expression demands it, will that be evaluated. that's how it could possibly return a result for an infinite list
07:43:12 <ckubrak> The first value that acc takes is Nothing, right?
07:45:03 <ski> depends on what you mean by "first"
07:46:16 <ski> each value of `acc' will correspond to a summary of processing a *suffix* (not prefix, as with the ordinary meaning of "accumulator") of the list
07:46:48 <ski> `Nothing' will be the value set for `acc' corresponding to the last, iow the empty, suffix
07:47:11 <ckubrak> Given the list [("a",2),("b",3)]
07:47:36 <ski> then `if key == k then Just v else acc' will compute the next (or previous, depending on how you look at it) value of `acc', if `(k,v)' is the element just preceding this suffix
07:47:50 <ski> we will have three versions of `acc' here :
07:47:57 <ski>   acc2 = Nothing
07:48:10 <ski>   acc1 : if key == "b" then Just 3 else acc2
07:48:20 <ski>   acc0 : if key == "a" then Just 2 else acc1
07:48:35 <ski> (hrm, i meant `=', not `:' there. oh well)
07:48:52 <ski> `acc0' will be the result that is returned by the `foldr' call
07:49:06 <ckubrak> acc0 = Nothing?
07:49:28 <ckubrak> Ohh
07:49:36 <ckubrak> The other way arround
07:49:50 <ski> no. i named them so that `acc0' corresponds to looking at the element at index `0' (also taking the later ones into account, because it incorporates `acc1', and `acc2' via that)
07:50:07 <ckubrak> With "at first" I meant the value of acc2
07:50:21 <ski> and `acc1' corresponds to looking at the element at index `1' (also taking the later one into account, because it incorporates `acc2')
07:51:11 <ckubrak> Then I got it. Thanks a lot!
07:51:51 <ski> and `acc2' here is "having traversed past two elements", none left. (compare with how often in C / Java / &c. you'd have an index counter which ends "pointing" to one past the last element of an array.) this is where `Nothing' is initializing the process
07:53:02 <ski> (obviously, you could rename them for yourself, `acc0' being the one being initialized, and `acc2' being the one that's being returned as eventual result -- if you prefer)
07:53:40 <ckubrak> That's the word I was looking for, initialize
07:55:26 <ski> > foldr (||) (error "never reached") ([False,True] ++ [False,False ..])
07:55:28 <lambdabot>  True
07:55:35 <ski> > foldr (||) (error "never reached") [False,False ..]
07:55:41 <lambdabot>  mueval-core: Time limit exceeded
07:55:54 <Itkovian> any idea why the first trace output is only shown once? https://gist.github.com/itkovian/6ae1328a0933cfc32dc873a022eb26cb
07:56:15 <ckubrak> Wait, why dont you give an initialization value
07:56:16 <ab9rf> heh
07:56:21 <ski> ckubrak : ^ this is intended to illustrate how in neither case, the initialization actually happens, in case of an infinite list
07:57:02 <ski> ckubrak : there is a final version of `acc', and a version just before that (having advanced one element), and a version before that. but no start/initialization
07:57:10 <ski> "it's turtles all the way down"
07:57:27 <ab9rf> which is why today's lunch will be turtle soup
07:58:22 <ckubrak> Here's what I'm missing:
07:58:35 * hackage mockery 0.3.5 - Support functions for automated testing  https://hackage.haskell.org/package/mockery-0.3.5 (SimonHengel)
07:59:04 <ckubrak> _ && True = True
07:59:19 <ski> no. it's left-biased, not right-biased
07:59:32 <ski> also, it's `(||)', not `(&&)'
07:59:51 <ckubrak> Ok, True || _ = True
07:59:57 <ski> @src (||)
07:59:57 <lambdabot> True  || _ = True
07:59:57 <lambdabot> False || x = x
08:00:00 <ski> @src (&&)
08:00:00 <lambdabot> True  && x = x
08:00:00 <lambdabot> False && _ = False
08:00:07 <ckubrak> Ohh, short circuit
08:00:10 <ski> right
08:00:12 <ckubrak> I get it
08:00:25 <ski> (same as the `if'-`then'-`else' in your `findKey' example)
08:00:35 <ckubrak> Thanks
08:00:44 <ski> if we write the result of `[False,True] ++ [False,False ..]' informally as `[False,True,False,False ..]', then the call to `foldr' here basically unfolds as
08:00:54 <ski>      foldr (||) (error "never reached") [False,True,False,False ..]
08:01:04 * hackage throwable-exceptions 0.1.0.4 - throwable-exceptions gives the exception's value constructors  https://hackage.haskell.org/package/throwable-exceptions-0.1.0.4 (aiya000)
08:01:11 <ski>   =  False || foldr (||) (error "never reached") [True,False,False ..]
08:01:16 <ski>   =  foldr (||) (error "never reached") [True,False,False ..]
08:01:27 <ski>   =  True || foldr (||) (error "never reached") [False,False ..]
08:01:35 <ski>   =  True
08:01:45 <ski> (so the "initializer" is never used here)
08:01:49 <ski> in the other case, we get
08:02:08 <ski>      foldr (||) (error "never reached") [False,False ..]
08:02:33 <ski>   =  foldr (||) (error "never reached") [False,False,False ..]
08:02:43 <ski>   =  False || foldr (||) (error "never reached") [False,False ..]
08:02:50 <ski>   =  foldr (||) (error "never reached") [False,False ..]
08:02:53 <ski>   =  ...
08:03:15 <ski> this repeats, never ends. the "initializer" is therefore not used here, either
08:03:21 <ski> ckubrak : ok ?
08:03:44 <ckubrak> Yes, thanks a lot
08:03:48 <ski> np
08:04:08 <ckubrak> It's pretty cool the way that haskell manages infinte lists
08:04:47 <ski> if you want to be able to pass a finite list, where you're not sure that you'll find the key, you'd better pass a real "terminal value" (or however one should call it), though
08:06:41 <ski> (or however that translates into the particular application of `foldr'. otoh `foldl' can never be used on infinite lists, *always* fails to terminate on them)
08:13:44 <ckubrak> ski: Just one more question why does foldr do
08:13:47 <ckubrak> map' f xs = foldr (\x acc -> f x : acc) [] xs  
08:14:04 <ckubrak> and foldl 
08:14:05 <ckubrak> elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys  
08:14:36 <ckubrak> I mean \x acc in foldr and \acc x in foldl
08:15:00 <ski> oh. that's just a convention, consider
08:15:22 <ski> > foldr f z [a,b,c]
08:15:25 <lambdabot>  f a (f b (f c z))
08:16:16 <ski> if it was `foldr (\acc x -> ..acc..x..)', then that'd give `f (f (f a c) b) a', with the elements in the opposite order
08:16:24 <ski> > foldl f z [a,b,c]
08:16:26 <lambdabot>  f (f (f z a) b) c
08:16:53 <ski> if it was `foldl (\x acc -> ..x..acc..)', then that'd give `f c (f b (f a z))', with the elements in the opposite order
08:17:10 <ski> it looks even nicer with an infix operator
08:17:25 <ski> > foldr (+) z [a,b,c]
08:17:27 <lambdabot>  a + (b + (c + z))
08:17:36 <ski> > foldl (**) z [a,b,c]
08:17:38 <lambdabot>  ((z**a)**b)**c
08:18:35 <ski> ckubrak : so, the argument ordering for the callback function to `foldr' and `foldl' was chosen to preserve the element ordering of the list, when expanded in this fashion
08:18:44 <ilyaigpetrov> It seems haskell is about "there is more than one way of doing it" -- doesn't it hurt readability?
08:19:26 <ckubrak> ski: Thanks again
08:19:30 <ski> with `foldl' we conceptually "feed" the accumulator in from the left, combining it with one element after another, as we encounter them, going over the list from left to right. the accumulator value we get at the right end is the final result
08:20:53 <ski> with `foldr', otoh, we conceptually "feed" the accumulator in from the right, combining it with one element after another, from the *left* (not right) this time, as we counter them, going over the list from right to left (*conceptually*. not in evaluation order.) the accumulator value we get at the left "end" is the final result
08:21:31 <ski> so with `foldr (\acc x -> ..acc..x..)', it's `acc x' because we combine the accumulator `acc', coming from the left, with the next element `x', on the right
08:21:56 <ski> er .. that was `foldl', not `foldr'
08:22:53 <ski> while with `foldr (\x acc -> ..x..acc..)', it's `x acc' because we combine the "previous" element `x' on the left with the "recursive result" `acc' from processing the remaining elements, coming from the left
08:23:14 <ski> ckubrak : clear enough ?
08:24:58 <ckubrak> Thanks a lot
08:28:29 <orion> How do I load a file in to ghci, but without replacing the files I already have loaded?
08:29:01 <orion> When I run `stack repl` I get my entire library, but if I run `:l tests/FooTest.hs` I only get a subset of my library.
08:29:30 <jerbome> :l + filename ? 
08:29:34 <jerbome> this works for modules
08:29:54 <glguy> :add
08:30:49 <orion> glguy: Thank you. That's exactly what I needed.
08:31:04 * hackage aeson-qq 0.8.2 - JSON quasiquoter for Haskell  https://hackage.haskell.org/package/aeson-qq-0.8.2 (SimonHengel)
08:49:53 <ThreeFx> Has anyone experienced issues with nested scopes in the `bound` library?
08:50:20 <glguy> ThreeFx: It sounds like you have
08:52:52 <Reisen> Is it possible to define an operator that 'groups' arguments, I.E,    f ? a b c ? d e ? f g h   instead of f (a b c) (d e) (f g h)
08:53:19 <glguy> Reisen: yes
08:53:47 <glguy> Reisen: See if you can figure out how to do it
08:53:57 <Reisen> It's not just ($) with a different fixity is it?
08:54:14 <glguy> try?
08:54:14 <Reisen> Feel like I'm being really naive
08:54:39 <ThreeFx> glguy: Yes, `bound` has issues deriving instances if my Expression constructor wants to utilise a nested scope
08:54:44 <kuribas> without typeclasses?
08:55:07 <glguy> kuribas: It's a good exercise to think though if you're not sure
08:55:37 <ski> (how about for `f (g a b) (h (i c d) (j e))' ?)
08:55:37 <glguy> ThreeFx: Do you have example code and error message output you could put on a paste bin?
08:55:56 <ThreeFx> glguy: I'll minimize my example
08:56:30 <kuribas> glguy: I think I got it :)
08:56:53 <kuribas> just change the fixity
08:58:45 <kuribas> > let f ! x = f x; infixl 9 ! in (,,) ! 1 ! 2 ! 3
08:58:46 <lambdabot>  error:
08:58:47 <lambdabot>      The fixity declaration for ‘!’ lacks an accompanying binding
08:59:39 <geekosaur> with BangPatterns enabled you need to write it in prefix form
09:00:54 <kuribas> > let f ? x = f x; infixl 9 ? in (,,) ? 1 ? 2 ? 3
09:00:55 <lambdabot>  (1,2,3)
09:01:18 <ThreeFx> glguy: See http://lpaste.net/356207
09:02:59 <Reisen> Seems really obvious now
09:04:39 <glguy> ThreeFx: I see. No, it doesn't appear that the TH logic supports that. You'd have to write the instance yourself. ThreeFx why did you need the outer () scope?
09:05:03 <glguy> ThreeFx: Perhaps you'd settle for:  Func (Scope (Maybe String) Expr a) as a replacement?
09:10:05 * hackage dotenv 0.3.4.0 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.3.4.0 (juanpaucar)
09:10:11 <davr0s> does haskell reserve some bits for the gc, e.g. i think i've seen some languages where an 'int' is 31 bits and bit 32 tells it if the value is a pointer or not ('boxing' ?) 
09:10:38 <davr0s> e.g. does haskell have native types like 32bit,64bit integers etc;
09:11:16 <glguy> While the Haskell standard allows for reserved bits as described, GHC does not do that. 
09:11:38 <glguy> Types like Int, Int32, Int64 are all boxed in Haskell
09:11:58 <davr0s> another random question,  last time I dabled with haskell and other functional languages I recall the 'threading macro' and |> in F#  but being told  in haskell everything is done the other way
09:12:26 <glguy> Because of Haskell's non-strict evaluate order the |> direction becomes misleading
09:16:21 <lamefun> So I was looking through random stuff about Haskell and there was a `cata` function, so I looked it up and the Haskell wiki page said something about F-algebras, so I looked up F-algebras.
09:16:51 <lamefun> I think I kind of understood, but still they look suspicious... Help? https://paste.ofcode.org/c2C53mY3VT5hHLae8x8YQN
09:17:52 <ThreeFx> glguy: I want to capture the function name and the variable name separately because it is possible to write function with the same name as an agrument. In that case the argument is captured and not the function name
09:17:55 <lamefun> Sorry for the pseudo-Haskell syntax.
09:18:15 <glguy> ThreeFx: OK, then you can use the Maybe String solution
09:18:35 <glguy> ThreeFx: Nothing is the name of the function, and Just x is the name of argument x
09:18:51 <ThreeFx> glguy: That's actually a really nice solution, hadn't thought of it. Thanks!
09:20:19 <lamefun> I mean there doesn't seem any reasonable limit on what can be an F-algebra.
09:21:49 <geekosaur> lots of things can be F-algebras, yes. that's kinda the point. just as lots of things can be monoids
09:22:02 <geekosaur> but being one means particular operations are possible on them
09:25:18 <lamefun> I mean isn't algebra that thing that's from schools with x and y and z and stuff in it? Especially my last function with meow, woof and quack, in which way is it an algebra?
09:26:03 <geekosaur> in mathematics, an algebra is much more than basic grade school algebra
09:26:08 <geekosaur> and at the same time much less :)
09:27:21 <blackdog> geekosaur: practically a koan, that
09:27:40 <geekosaur> just depends on how you are looking at it
09:28:14 <geekosaur> more widely applicable but tells you less about what you can do
09:30:19 <blackdog> geekosaur uses parametricity! it's super effective!
09:31:02 <geekosaur> I expect that's just confusing to someone whose main exposure to math is grade school level :)
09:32:36 <blackdog> yes, i'm just playing around lamefun - don't be put off :)
09:35:42 <lamefun> Are functors where eg. F(String) = Natural even allowed?
09:40:38 <lyxia> @let newtype F a = F Natural deriving Functor
09:40:40 <lambdabot>  Defined.
09:40:57 <lyxia> lamefun: ^ like that?
09:41:35 * hackage milena 0.5.1.0 - A Kafka client for Haskell.  https://hackage.haskell.org/package/milena-0.5.1.0 (adamflott)
09:44:01 <barcabuona> is there a command to display the type signature for multiple functions at once?
09:45:18 <lamefun> What an "algebra" even is then?
09:46:59 <zachk> barcabuona, :t (f1,f2,f3...) in ghci
09:47:02 <geekosaur> https://en.wikipedia.org/wiki/Algebra
09:47:09 <zachk> @type ((+),(-))
09:47:10 <lambdabot> (Num a, Num a1) => (a1 -> a1 -> a1, a -> a -> a)
09:47:35 <geekosaur> it is a _very_ broad class
09:51:16 <barcabuona> zachk: :t ((/),(=)) is an error
09:51:30 <barcabuona> ah ok
09:51:32 <barcabuona> sori
09:51:35 <barcabuona> why :t and @type?
09:51:59 <barcabuona> nah type doesnt work either tho...
09:52:16 <geekosaur> no difference in lambdabot, but there used to be a time when the ghci-like ones didn't work in /query so some people have the habit of using the longer form
09:52:58 <barcabuona> ahh ok it's a lambdambot commmand gotit
09:53:10 <barcabuona> still why doesnt :t ((/),(=)) work?
09:53:21 <geekosaur> lamefun: Mathematics likes to break things down into conceptual categories, going from the general to the more specific, each one limiting what you can do in some ways but adding new specifics
09:53:29 <geekosaur> becuase (=) is not an operator. did you mean (==)?
09:54:18 <kadoban> barcabuona: = is syntax
09:54:21 <kadoban> It has no type.
09:56:45 <barcabuona> kadoban: so + and - can be overloaded but = no?
09:57:01 <barcabuona> like if i want to make my own types and then want to use them in expressions
09:57:10 <geekosaur> since = is definition syntax, what would you overload it with?
09:57:18 <geekosaur> again, did you mean (==)?
09:57:46 <geekosaur> data Foo a = MkFoo a -- what would you "overload" this with?
09:58:29 <kadoban> barcabuona: If you indeed mean (=), then yeah you can't actually overload that in any way. You'd have to pick a different symbol. Like =: I've seen used some places.
09:58:37 <geekosaur> also reember that Haskell bindings are immutable --- there is no assignment
09:58:39 <kadoban> I also have a feeling you mean (==), but it's hard to tell.
09:59:02 <geekosaur> let a = 5 -- this is a *new* a that shadows any existing one; anything using the old binding continues to use it
10:00:06 <geekosaur> this is clearer if you use the general form instead of the do-specific one (which gets rewritten by the compiler into the general form): let <bindings> in <expression>
10:00:16 <geekosaur> let {a = 5; b = 6} in a + b
10:00:51 <barcabuona> kadoban: ah yis
10:01:17 <barcabuona> i meant ==
10:04:34 <lamefun> I'm still confused, how can something with the word "algebra" in its name have next to no constraints like that?
10:05:39 <geekosaur> '"algebra" in its name' the rest of the name *is* the constraint
10:06:29 <geekosaur> wait until you find out that the "number" you know about is also a lies-to-children :)
10:07:21 <zachk> geekosaur, how is "number" a lie to children? :) 
10:09:32 <geekosaur> zachk, say you know little more than basic arithmetic.
10:09:37 <geekosaur> then you leanr 4+7i is a number
10:10:07 <geekosaur> then you learn <5,2,7,8> is a number (quaternion)
10:10:28 <geekosaur> not to mention the generalization to matrices
10:11:25 <tdammers> and then category theory rolls around and says "hey guys, you know what..."
10:11:30 <ski> cardinals,ordinal
10:11:32 <ski> s
10:11:48 <zachk> I don't really look at them as numbers per se, at look at them as things constructed from numbers
10:12:40 <blackdog> zachk: that's probably the wrong way to look at them.
10:12:51 <geekosaur> number theory gives you the stink-eye >.>
10:13:01 * zachk pouts
10:13:14 <blackdog> it's a good way to start understanding typeclass-based design
10:13:20 <kadoban> zachk: If you consider elements of the Reals as numbers and elements of the Naturals as numbers, it seems weird to then consider the complex numbers, and other more exotic things as not numbers.
10:13:33 <blackdog> you let go of "what is this thing REALLY" and start thinking about "what needs to be defined for me to be able to do what i need?"
10:13:54 <kadoban> Just because we represent them as not ([0-9]+) seems like a pretty arbitrary reason to call them something else.
10:14:25 <zachk> well maybe complex numbers are numbers, but they seem constructed to me with an addition sign in the middle of their denotation
10:15:10 <geekosaur> they are constructed from lower order numbers, yes
10:15:18 <geekosaur> but they also behave as numbers
10:16:51 <kadoban> I haven't done a lot of abstract algebra and etc., but I've done enough to have a hard time seeing them as all that different.
10:16:59 <lamefun> But complex numbers still have many attributes of numbets: addition, subtraction, multiplication, etc. F-algebras seem to have nothing common with algebra.
10:18:00 <geekosaur> lamefun, let go of grade school
10:18:04 <lamefun> I.e. https://paste.ofcode.org/c2C53mY3VT5hHLae8x8YQN - the last one from here is completely useless, but isn't it still an F-algebra?
10:18:14 <geekosaur> you learned *one* *specific* algebra
10:18:40 <ski> modular/congruence arithmetic (aka arithmetic in `|Z / (n * |Z)', for an integer `n')
10:20:02 <lamefun> So "algebra" is like a buzzword?
10:20:28 <ski> vector spaces are a particular kind of algebra
10:20:38 <ski> groups are another
10:20:41 <ski> rings are another
10:21:34 <barcabuona> is there something like ipython or utop for haskell? the command line isn't bad but i'd like something like auto-completition and blocks of code
10:21:56 <shapr> barcabuona: https://github.com/gibiansky/IHaskell
10:21:56 <barcabuona> (i use blocks of code a lot in ipython to test small program fragments that i then incorporate into the final program)
10:22:07 <shapr> oh, you don't mean the ipython-notebook
10:22:09 <barcabuona> shapr: i tried that but assumed it was lacking
10:22:22 <ski> (directed, multi-)graphs
10:22:23 <zachk> barcabuona, leksah perhaps though its an IDE
10:22:35 * hackage http-conduit-browser 2.0.0.1 - Browser interface to the http-conduit package  https://hackage.haskell.org/package/http-conduit-browser-2.0.0.1 (MikhailKuddah)
10:22:39 <DarkClient193> good point.
10:23:46 <barcabuona> zachk: im looking for a console program. ill try recompilink ihaskell...
10:23:50 <ski> lamefun : "universal algebra" is a framework that attempts to capture a general notion, exemplified by such structure signatures. "`F'-algebras" is a more general attempt
10:24:04 <barcabuona> i think it wanted to download a full snapshot of an older version of haskell last i tried
10:24:54 <shapr> I think intero does tab/auto completion.
10:25:03 <shapr> but I've never used it outside of emacs.
10:26:25 <ski> lamefun : the signature of a monoid says that there should be one carrier, `M', and two operations `n : 1 >---> M' and `c : M * M >---> M' satisfying three laws `forall y : M. c(n(),y) = y',`forall x : M. x = c(x,n())',`forall x,y,z : M. c(c(x,y),z) = c(x,c(y,z))'
10:28:39 <ski> lamefun : in general, universal algebra allows any number of carrier sets, and each operation should go from a product of carriers (or constant sets, like scalars, or set of truth-values) to a carrier (or ..), and each law is a universally quantified equation between expressions built from variables and operations
10:31:05 <ski> lamefun : one could specify a "natural number algebra" as consisting of a carrier `N', and two operations `zero : 1 >---> N',`succ : N >---> N', subject to zero laws. an example "natural number algebra" (an instance of the signature, the "type class") would be given by `N = Bool',`zero () = False',`succ b = not b'
10:32:01 <barcabuona> does anybody who uses archlinux know why ghc is so out of date?
10:32:09 <barcabuona> like 5 months behind
10:33:29 <ski> lamefun : in the case where all operations have the same codomain, one could abbreviate the operations into a single one. like `[zero,succ] : 1 + N >---> N' (`[zero,succ]' would be `either zero succ', in Haskell)
10:34:14 <cocreature> barcabuona: I’ve send the maintainer a mail a while back and he told me that he intends to split it up into smaller packages but it’s taking longer than expected and it also often needs to be rebuild which takes up his time
10:34:16 <lamefun> https://paste.ofcode.org/HQhWV4evUTsBbsipHGVqwX - this does not go from a product of carriers at all, so this is not an F-algebra?
10:34:41 <ski> lamefun : in the general case, we get `op : ..X.. >---> X', `X' being the carrier. `..X..' being an "algebraic expression" (using product types and sum types) in the type variable `X'. this is another reason to call it "algebraic data types"
10:34:47 <cocreature> barcabuona: I kind of want something like hvr’s GHC PPA for archlinux but so far I’ve resisted the urge to make it myself :)
10:35:27 <ertes-w> barcabuona: i have a small haskell file that always exists and has a minimal module skeleton that i just open in my editor for experimentation
10:35:40 <ski> lamefun : one could allow an arbitrary expression `..X..', call it `F X', instead of just one formed by sums, products (and constants), provided `F' is a functor. this gets to `F'-algebras
10:36:38 <ertes-w> barcabuona: most of the time i just switch to its buffer, because it's already open most of the time anyway
10:36:58 <ski> lamefun : what is `N - S' ?
10:37:21 <lamefun> - is a dash
10:37:32 <lamefun> I mean F(S) = N
10:37:38 <ski> yes, but what does this type/set construction mean ?
10:37:51 <ski> oh, constantly `N'
10:37:56 <barcabuona> ocramius: ill page him as well maybe he'll hurry up. otherwise i'll either install that shit with stack (or cabal ive yet to learn) or might see if i can't just ask to update the package myself
10:38:14 <barcabuona> it's absurd ghc 5 months out of date in archlinux...
10:38:23 <ski> "should go from a product of carriers (or constant sets, like scalars, or set of truth-values)"
10:39:29 <ski> lamefun : but then `S',in `F(S) = N', could be any type, not just the type of strings ..
10:39:42 <cocreature> barcabuona: it’s trivial to update. iirc I just bumped the version number and updated the checksums
10:39:55 <ski> (unless you meant to define `F' to give `N' if fed `S', and presumably give something else when fed other input types)
10:40:39 <lamefun> does it even matter?
10:41:04 <lamefun> for the purposes of (S, a) being an F-algebra?
10:44:44 <ski> lamefun : it doesn't
10:47:23 <lamefun> So is (S, a) an F-algebra or not?
10:48:52 <ski> it is
10:50:00 <ski> `(Bool,even)' would be another `F'-algebra (assuming `F(X) = N' also when `X = Bool')
10:59:40 <lamefun> Thanks. Still suprising naming though. If F-alegbras have so few constaints and algebra is a more general category still, then what algebra even is?
11:02:32 <lamefun> Is is just a general word with no concrete definition?
11:03:35 <ski> no, `F'-algebra is a more general concept than the one in "universal algebra"
11:03:56 <ski> i'm not sure what you had in mind with "algebra" in ".. and algebra is a more general category still"
11:04:46 <ski> `F'-algebras, and "universal algebra", are both pretty concrete
11:05:09 <ski> (in terms of well-definedness)
11:19:05 <ReinH> Do you mean algebra as a theory or algebra as an object?
11:20:04 <ReinH> If 'algebra' is used to mean an object without qualification it generally refers to a unital associative algebra.
11:20:18 <barcabuona> do i use cabal or stack?
11:21:23 <ReinH> So that would be 'what algebra even is' in that sense.
11:22:52 <dmwit> barcabuona: Different folks appear to have different preferences there. You should be able to make good progress on just about any project with either choice.
11:25:08 <geekosaur> barcabuona, they're also both moving targets. recent development versions of cabal-install with the new-* verbs are currently significantly better than either old-cabal-install or stack
11:25:36 <geekosaur> and adapt better to use cases stack is not so good at, since it's a tool for repeatable builds not a general development tool
11:25:44 <geekosaur> ("it's" = stack)
11:26:11 <barcabuona> ok. so it's a mid-war. i saw some stuff on github providing instructions for both and i was unsure. i think ill use stack since it takes care of up-to-date ghc
11:26:51 <ReinH> (I think there is some dispute over whether 'algebra' implies associativity.)
11:27:00 <geekosaur> not really a war, except in the minds of some users
11:27:20 <geekosaur> they serve different purposes
11:27:23 <blackdog> geekosaur: it's kind of a war, unfortunately. every time i mention my stack-based workflow, someone from the old guard jumps on me.
11:27:35 <blackdog> geekosaur: and really, stack works fine for development too.
11:28:19 <ski> ReinH : that terminology always annoyed me :)
11:28:29 <jtaylor1> I'm getting a realgcc error when installing cabal packages on windows
11:29:07 <jtaylor1> "The application was unable to start correctly (0xc0000142)"
11:29:24 <kadoban> geekosaur: "not a general development tool" sounds fairly provocative. What are you basing that on?
11:29:24 <jtaylor1> Has anybody else encountered this?
11:29:39 <kadoban> It certainly calls itself a development tool, and people use it successfully to develop haskell projects.
11:29:40 <geekosaur> kadoban, stack's own description as a repeatable builds tool
11:29:57 <kadoban> "Stack is a cross-platform program for developing Haskell projects." https://github.com/commercialhaskell/stack
11:29:58 <geekosaur> this is something you can use in development but it's not really general development
11:30:10 <blackdog> geekosaur: "Stack is a cross-platform program for developing Haskell projects. It is aimed at Haskellers both new and experienced." is the first line of the site.
11:30:29 <kadoban> geekosaur: In what sense is it not general?
11:30:34 <blackdog> i don't think your view of this is particularly widespread.
11:30:46 <geekosaur> well, actually more snoyman's own remarks about it
11:30:48 <geekosaur> but whtever
11:31:04 <geekosaur> I guess I;m out as it is required for everyone to believe it is the ultimate build tool
11:31:14 <geekosaur> speaking of wars but real people know this war is already won
11:31:18 <geekosaur> apparently
11:32:05 <kadoban> Wat?
11:33:16 <blackdog> geekosaur: really not bashing cabal here. i haven't used it for a while, it's possible it's much better than it was - just pointing out that stack does at least an adequate job of general development.
11:33:35 <jtaylor1> Should I not bother trying to use the stack on windows? :)
11:33:48 <jtaylor1> *stack not "the stack"
11:34:28 <saurabhnanda> which haskell library will have a list of currencies?
11:34:31 <kadoban> jtaylor1: It's supposed to work on windows. A lot of haskell tools seem less-well-tested on windows though unfortunately.
11:35:22 <jtaylor1> kadoban: Stack installed a version of gcc which doesn't seem to run properly with cabal
11:35:59 <blackdog> saurabhnanda: there are two, one was better than the other - hang on.
11:36:25 <jtaylor1> Is there a way to tell stack to use a specific version of gcc?
11:37:08 <blackdog> saurabhnanda: think it's just https://hackage.haskell.org/package/currency 
11:37:21 <saurabhnanda> jtaylor1: via the LTS?
11:37:39 <kadoban> Stack installs gcc for you? Hm. Maybe it needs to on windows? Sounds weird though.
11:38:10 <saurabhnanda> blackdog: doesn't seem to have a **list** of known currencies.
11:38:15 <blackdog> saurabhnanda: yes it does.
11:38:24 <saurabhnanda> blackdog: something like https://github.com/k0001/safe-money/blob/master/src/Data/Money.hs
11:38:32 <jtaylor1> I can run `stack exec which realgcc` and it returns something in the stack bin folder
11:39:09 <blackdog> saurabhnanda: look at ISO4217Currency
11:39:13 <blackdog> https://hackage.haskell.org/package/currency-0.2.0.0/docs/src/Currency.html#ISO4217Currency
11:40:00 <blackdog> or were you looking for plaintext like "US dollars"?
11:40:12 <saurabhnanda> blackdog: something like the Money gem in Ruby
11:40:24 <saurabhnanda> blackdog: has a list of all known currencies and all the related metadata
11:40:35 <jtaylor1> saurabhnanda: sorry, but what is "LTS"? :)
11:40:51 <saurabhnanda> blackdog: numeric code, 3-char alpha code, units, sub-units, unicode-symbol, etc.
11:41:07 <saurabhnanda> jtaylor1: do you have a stack.yml file handy?
11:41:18 <jtaylor1> saurabhnanda: Yes
11:41:53 <jtaylor1> Ohh, it's like a stability level for packages
11:41:54 <jtaylor1> gotcha
11:41:58 <saurabhnanda> jtaylor1: LTS = Long Term Support Snapshot. Stack curates specific versions of almost all HAskell packages which are known to work well together. This snapshot along with a specific compiler version is called an LTS snapshot.
11:42:18 <saurabhnanda> jtaylor1: the LTS version decides which GHC version will be used.
11:42:57 <saurabhnanda> so, generally, stack.yml specifies which LTS you're using, which in-turn specifies the GHC version. 
11:43:01 <jtaylor1> saurabhnanda: so you'd suggest switching to a nightly release of ghc?
11:43:06 <jtaylor1> saurabhnanda: See if it works then
11:43:15 <saurabhnanda> jtaylor1: which version of GHC do you want to use?
11:44:10 <saurabhnanda> jtaylor1: https://www.dropbox.com/s/45vw8xz3msoum8i/Screenshot%202017-06-14%2000.16.10.png?dl=0
11:46:23 <jtaylor1> saurabhnanda: okay I'm going to upgrade to 8.18 LTS
11:46:29 <jtaylor1> saurabhnanda: Thanks
11:46:43 <saurabhnanda> jtaylor1: what're you building with Haskell?
11:46:59 <Zemyla> So what exactly are the MonadWriter laws, particularly the ones regarding listen and pass?
11:48:58 <jtaylor1> saurabhnanda: Just a hakyll static site generator, wanted to add a cabal package to it but realgcc failed
11:49:13 <jtaylor1> saurabhnanda: Hopefully this new release includes a version which works
11:49:40 <kadoban> jtaylor1: Out of curiosity, which installation method did you use for stack? Are you sure that's where gcc came from?
11:51:47 <jtaylor1> kadoban: I used the stack windows installer to install stack https://docs.haskellstack.org/en/stable/install_and_upgrade/#windows
11:52:17 <jtaylor1> kadoban: Then I created my project with the hakyll template and ran `stack install --install-ghc`
11:52:44 <jtaylor1> kadoban: This worked fine until I wanted to add a cabal package to the project and none of them would compile
11:53:04 <ski>   forall f w. pass (fmap (\() -> ((),f)) (tell w)) = tell (f w)  -- i suspect is one
11:53:04 <jtaylor1> Can you use stack to install cabal packages?
11:53:09 <kadoban> Hm. Are you sure gcc is the problem? Did you lpaste the error somewhere?
11:53:38 <jtaylor1> kadoban: I think I know what the problem was
11:53:38 <kadoban> jtaylor1: Yes, though "install cabal packages" has various meanings, so how depends on which one you mean.
11:54:12 <ski>   forall w. listen (tell w) = fmap (\() -> ((),w)) (tell w)
11:54:23 <jtaylor1> kadoban: My stack packages installed properly since they used the gcc installed with the ghc
11:54:43 <ski> (strictness details may differ, i suppose)
11:54:44 <jtaylor1> kadoban: But when I used `cabal install ...` it used my local version of gcc which must've been incompatible or old or something
11:55:23 <blueyed> I am trying to build shellcheck using cabal, but it fails to build json-0.9.1: http://sprunge.us/BORe  any pointers?
11:55:26 <kadoban> jtaylor1: Oh. I wouldn't really know about that. But what's your general goal, what were you trying to do with the cabal install thing? Are you trying to use a cabal package as a dependency in your stack project thing?
11:55:42 <kadoban> Or just install an executable, or something else maybe?
11:55:57 <jtaylor1> kadoban: I wanted to include https://github.com/meoblast001/hakyll-sass/ in my project
11:56:04 <sm> jtaylor1: they're all cabal packages. I think you meant can you use stack to install hackage packages, which aren't in stackage ? And the answer is yes (subject to the usual dependency constraints), if you mention the package's version suffix.
11:56:24 <sm> and you can install packages from github as well. It's in the stack manual
11:56:25 <jtaylor1> sm: That makes sense, thanks
11:57:03 <sm> but for github packages, you must specify them in a stack.yaml file somewhere, you can't install those from the command line
11:57:10 <kadoban> jtaylor1: You typically do that by just depending on it in your .cabal file. Then if it's in the stack resolver you're using, that's it. If it's not, you have to tell stack where to find it (or what version to use).
11:57:28 <frud> @hoogle Either a (IO b) -> IO (Either a b)
11:57:28 <lambdabot> Control.Concurrent.Async race :: IO a -> IO b -> IO (Either a b)
11:57:28 <lambdabot> Control.Lens.Prism left' :: p a b -> p (Either a c) (Either b c)
11:57:28 <lambdabot> Control.Lens.Prism right' :: p a b -> p (Either c a) (Either c b)
11:57:31 <kadoban> Yeah, if the only way to get it is a git repository, you specify that in your stack.yaml file with a certain syntax.
11:58:07 <Gurkenglas> :t sequenceA :: Either a (IO b) -> IO (Either a b) -- frud
11:58:08 <lambdabot> Either a (IO b) -> IO (Either a b)
11:58:43 <jtaylor1> kadoban: Thanks
11:58:44 <frud> Gurkenglas thanks
11:58:50 <sm> s/can't install those from/can't specify those from/
11:58:58 <Gurkenglas> frud, also if your code happens to be "sequenceA . fmap f", use "traverse f"
12:04:08 <frud> Gurkenglas it's going to take me an hour to figure out why that works...
12:06:42 <koala_man> blueyed: did you try the command it suggests?
12:29:23 <frud> @hoogle (IO (Either a b)) -> (b -> IO (Either a c)) -> IO (Either a c)
12:29:24 <lambdabot> Data.Functor.Foldable distGApo :: Functor f => (b -> f b) -> Either b (f a) -> f (Either b a)
12:29:24 <lambdabot> Agda.Utils.Monad altM1 :: Monad m => (a -> m (Either err b)) -> [a] -> m (Either err b)
12:29:24 <lambdabot> Data.Functor.Foldable elgot :: Functor f => (f a -> a) -> (b -> Either a (f b)) -> b -> a
12:35:56 <blueyed> koala_man: yes, but did not help.. "rm -rf ~/.ghc" helped though.. I guess it got interrupted before in a bad state.
12:36:04 <blueyed> s/state/moment/ ;)
13:05:21 <AWizzArd> How are Monads called that end in T? a) transformer monads?  b) transformed monads?  c) <?>
13:05:33 <AWizzArd> MaybeT - is this a transformed monad?
13:06:00 <cocreature> AWizzArd: monad transformers
13:07:27 <AWizzArd> Would it be technically correct to call them just „monads”? As they have an ordinary `instance Monad m => Monad (MaybeT m) where …` implementation.
13:07:39 <AWizzArd> Correct, but not as informative as one could be.
13:08:24 <cocreature> AWizzArd: no because MaybeT is not an instance of Monad. "MaybeT m" is for a suitable "m" (i.e. one that is an instance of Monad itself)
13:09:21 <AWizzArd> Okay, I understand.
13:09:37 <AWizzArd> A small difference, char-wise, but an important difference in semantics.
13:09:49 <cocreature> exactly
13:10:39 <AWizzArd> cocreature: typically one would want to make a transformer an instance of the MonadTrans class right? But: is this required?
13:11:09 <wizwizwizwizw> so i am thinking about writing a simple socket server in haskell
13:11:13 <cocreature> AWizzArd: required by what?
13:11:19 <wizwizwizwizw> and i'd like to not have to worry about GC latency
13:11:25 <AWizzArd> cocreature: to make a type a Monad Transformer.
13:11:52 <wizwizwizwizw> i was thinking that a way of handling this would be to split up my haskell program into several processes
13:11:52 <ski> AWizzArd : i'd say yes
13:12:04 <wizwizwizwizw> so if any one of them was undergoing a GC,
13:12:13 <ski> otherwise, what's the point of using the term "monad transformer" ?
13:12:16 <wizwizwizwizw> the others would still be available to handle messages from the socket
13:12:20 <jle`> AWizzArd: they are monad transformers
13:12:20 <Maxdamantus> I'd probably say it doesn't have to have an instance.
13:12:27 <cocreature> I’d say yes too but I haven’t seen a formal definition of what a monad transformer is so arguing about it seems pointless
13:12:30 <jle`> to answer your first question
13:12:32 <Maxdamantus> It's still a function that takes a monad and returns another monad.
13:12:36 <wizwizwizwizw> is there a name for what i'm describing? is there a common way of doing it?
13:12:36 <jle`> one way to look at them is that they are functions Monad -> Monad
13:12:57 <Maxdamantus> (given a dubious meaning of "monad" which happens to be terminologically accepted in Haskell)
13:13:02 <jle`> MaybeT is a monad transformer; it is a function Monad -> Monad
13:13:09 <jle`> :k MaybeT
13:13:10 <ski> just `instance Monad m => Monad (BlahT m) where …' doesn't buy you that much
13:13:10 <lambdabot> error:
13:13:10 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
13:13:10 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
13:13:26 <jle`> @let import Control.Monad.Maybe.Trans
13:13:27 <lambdabot>  .L.hs:61:1: error:
13:13:27 <lambdabot>      Failed to load interface for ‘Control.Monad.Maybe.Trans’
13:13:27 <lambdabot>      Perhaps you meant Control.Monad.Trans (from mtl-2.2.1)
13:13:37 <jle`> @let import Control.Monad.Trans.Maybe
13:13:38 <lambdabot>  Defined.
13:13:40 <jle`> :k MaybeT
13:13:41 <lambdabot> (* -> *) -> * -> *
13:13:50 <jle`> MaybeT :: (* -> *) -> (* -> *)
13:14:09 <jle`> give it a monad (m :: * -> *), and get out a new monad MaybeT m :: * -> *
13:14:15 <AWizzArd> Yes.
13:14:34 <AWizzArd> But when we don’t implement MonadTrans we have no lift. So what’s the point then?
13:14:41 <jle`> well
13:14:46 <jle`> lift still exists
13:14:52 <jle`> you can provide it as its own function
13:14:54 <AWizzArd> https://en.wikibooks.org/wiki/Haskell/Monad_transformers makes it sound as if this is nice to have.
13:14:54 <jle`> specifically for your type
13:15:08 <AWizzArd> The wiki writes „Technically, this is all we need; however, it is convenient to make MaybeT m an instance of a few other classes”.
13:15:24 <DrPudim> hi
13:15:24 <jle`> MaybeT would have to provide some lifting function
13:15:32 <jle`> but it can provide it outside of the MonadTrans typeclass
13:15:43 <jle`> call it liftMaybeT or something
13:15:58 <ski> jle` : yes, but not if you go `frob :: forall t. MonadTrans t => ..t..' (cf. being able to write code that is polymorphic in a monad used)
13:16:06 <jle`> yes
13:16:15 <jle`> but, how much code is there really that is polymorphic over all monad transformers
13:16:30 <ski> just `frob :: forall t. (forall m. Monad m => Monad (t m)) => ..t..' appears less useful, to me
13:16:34 <jle`> it might add a convenience there but i'm not sure if it's a real benefit in practice
13:16:50 <ski> granted
13:16:59 <jle`> well, it's a real benefit, but not as big as say, a Monad instance
13:17:09 <jle`> there's so much code polymorphic over all monads, it's kinda crazy
13:17:15 <ski> (i suppose one could compare `MonadTrans' to `Pointed' or maybe `Default')
13:17:18 <AWizzArd> Do the known and mostly used Haskell libs have some Monad Transformers that do *not* implement MonadTrans?
13:17:37 <jle`> i don't see why they would
13:17:40 <jle`> it's a no-brainer
13:17:50 <ski> perhaps, if the author didn't realize it was a monad transformer
13:17:55 <jle`> ah yes
13:18:04 <jle`> there's actually an example in 'Base' actually i believe
13:18:08 <ski> (though it seems less likely than not realizing something is a monad)
13:18:31 <jle`> AWizzArd: one huge benefit of MonadTrans is that the lifting function is already "known"
13:18:38 <jle`> you don't need to leaf through documentation
13:18:42 <jle`> it's a standardized name, essentialyl
13:19:03 <AWizzArd> Yes, and everybody would expect it if I offer some MyfooT
13:19:58 <jle`> if you say it's a monad transformer, they'd expect it to have a MonadTrans instance
13:20:05 <jle`> and they'd expect to be able to use 'lift'
13:20:17 <jle`> instead of having to leaf through the documentation to find whatever lift is named for your type
13:20:32 * ski . o O ( `climb :: forall m n. (Monad m,Monad n) => (forall a. m a -> t n a) -> (forall a. t m a -> t n a)' )
13:21:23 <jle`> ah hey yes
13:21:28 <jle`> i found some monad transformers in 'base'
13:21:34 <jle`> that don't have a MonadTrans instance
13:21:40 <jle`> well, that's not exactly base's fault, since MonadTrans isn't in base
13:21:47 <jle`> but those instances weren't provided in the transformers library either
13:22:34 <jle`> will provide karma to those who can name them
13:22:44 <jle`> my original guess was Kleisli, but the arguments are in the wrong order
13:25:17 <jle`> nvm i only found one instance in my searches
13:25:55 <barcabuona> how can i have type signatures in ghci?
13:26:09 <AWizzArd> jle`: which is it?
13:26:10 <barcabuona> annoying i can't just copy/paste between ghci and hs files :/
13:26:13 <geekosaur> on the same line with a semicolon separating it from thedefinition
13:26:19 <geekosaur> or, using mulltiline mode
13:26:39 <jle`> i could tell you but that'd take the fun away :)
13:26:40 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#multiline-input
13:30:41 <fresheyeball> Can anyone explain the accuracy of NominalDiffTime?
13:30:51 <fresheyeball> I need a difftime in milliseconds
13:31:42 <amx> i think it says picoseconds somewhere
13:31:50 <fresheyeball> amx: what is a picosecond?
13:31:53 <geekosaur> It has a precision of 10^-12 s
13:31:57 <geekosaur> right in the haddock
13:32:04 <fresheyeball> sorry I don't know what that means
13:32:07 <fresheyeball> I saw it in the haddock
13:32:15 <geekosaur> oh boy
13:32:38 <fresheyeball> oh geeze
13:32:39 <amx> 0.000000000001 seconds
13:32:39 <wespiser> or a picosecond is 1 / (10^12) of a second
13:32:40 <geekosaur> 1/1_000_000_000_000 second
13:32:45 <fresheyeball> a pico is a trillionth
13:32:47 <glguy> Any particular NominalDiffTime will only be as accurate as the inputs
13:33:07 <fresheyeball> well I should say, that is just fine
13:33:10 <fresheyeball> :)
13:33:14 <geekosaur> you migth want to learn about both scientific notation and metric scale prefixes
13:33:19 <fresheyeball> I was not aware that picoseconds was a measure
13:33:20 <geekosaur> you will encounter them fairly often
13:33:29 <fresheyeball> geekosaur: ok!
13:35:24 <barcabuona> geekosaur: thanks! it works but going back to previous line does not pull the whole block back. gonna have to get that ihaskell running or just use a file
13:35:49 <geekosaur> generally one loads a file and only uses the prompt for expressions
13:40:06 <bsima> IO (Either err b) -> (b -> IO (Either err c)) -> IO (Either err c)
13:40:17 <bsima> ^^ this is really close to (>>=) but not the same
13:40:42 <jle`> good catch
13:40:50 <bsima> what's the proper function I need for this?
13:40:52 <barcabuona> geekosaur: i see that works weel :) only possible issue maybe is looking at the code while you look at the errors
13:40:54 <zachk> bsima, could you use an EitherT if such a thing exists?
13:40:56 <jle`> you can actually achieve that behavior using the ExceptT wrapper
13:41:14 <bsima> okay I'll check out ExceptT, thanks :)
13:41:18 <jle`> ExceptT is a newtype wrapper that wraps IO (Either err b)
13:41:22 <jle`> and gives it the Monad instance you want
13:41:23 <fresheyeball> bsima: its not the same because you have Either and IO as seporate Monads
13:41:23 <bsima> hoogle didn't understand my searches
13:41:30 <jle`> ExceptT e IO a ~ IO (Either err b)
13:41:34 <fresheyeball> bsima: ExceptT will let you merge them into one Monad
13:41:50 <jle`> bsima: are you familiar with using newtype wrappers to get different instances for types?
13:41:52 <fresheyeball> then >>= will do what you are asking
13:42:04 <jle`> for example, using Product and Sum to get nice Monoid instance for numbers
13:42:04 <bsima> fresheyeball: thanks, looking at it now
13:42:08 <jle`> and All/And for Bool's
13:42:13 <jle`> and First/Last for Maybe
13:42:19 <bsima> jle`: vaguely familiar
13:42:31 <jle`> > mconcat . map Sum $ [1..10]
13:42:33 <lambdabot>  Sum {getSum = 55}
13:42:35 <bsima> i've seen the Product/Sum example, but havne't internalized it yet
13:42:36 <jle`> > mconcat . map Product $ [1..10]
13:42:38 <lambdabot>  Product {getProduct = 3628800}
13:42:53 <jle`> basically in haskell we use a trick by wrapping a type in a newtype wrapper...then we can get different typeclass instances for that type
13:43:53 <fresheyeball> \q
14:31:26 <MitchellSalad> jle`: what's the monad transformer in base?
14:37:12 <jle`> imma give people more time
14:37:54 <whoman2> what will they do with it
14:38:12 <jle`> think about what they've done
14:38:27 <whoman2> with all the distractions available to them?
14:39:03 <jle`> mhm
14:39:32 <whoman2> heh. perhaps a select few could be wise with their use of time/energy
14:41:36 <kadoban> If I'm interested in computational models useful for analyzing haskell code and algorithms written in haskell, what should I look at other than Okasaki's Purely Functional DS ?
14:45:17 <pierrot> Given the definiton 'dup x = (x, x)' what would be '(dup dup)' ?
14:45:33 <pikajude> :t let dup x = (x, x) in dup dup
14:45:34 <lambdabot> (t -> (t, t), t -> (t, t))
14:46:04 <pikajude> my guess is that it would be (t -> (t, t), t -> (t, t))
14:46:16 <jle`> if you want to brea GHC
14:46:18 <jle`> *break
14:46:25 <jle`> try dup . dup . dup . dup ...
14:46:37 <ski> kadoban : not directly releveant to the question, but Richard Bird's "Pearls of functional algorithm design" would perhaps be interesting, nonetheless
14:46:44 <jle`> since you get a type that grows exponentially
14:46:58 <kadoban> ski: Ah yes, thanks. I have and have started reading that one too.
14:47:02 <ThreeFx> I'm back with an interesting other problem (possibly a bug): Using Control.Lens.Plated and Bound seems to lead to a space leak and an infinite loop. Manually terminating the running program with Ctrl+C causes the program to exit and the correct result to be displayed however.
14:47:07 <kadoban> (and does seem quite interesting)
14:47:16 <pierrot> it's an exercise. they ask me the differences between (dup . dup) and (dup dup)
14:48:09 <pierrot> I understand the first one, but I'm not sure about the second one
14:48:25 <jle`> dup is a higher order function, so it can take a function as input
14:48:39 <ski> (iirc, it's of a somewhat similar flavor as "The fun of programming", edited by Jeremy Gibbons,Oege de Moor. but the former is more oriented towards algorithms. the latter towards various ideas : types, algorithms, problems, data structures, ..)
14:48:40 <jle`> try manually evaluating the definition of dup
14:48:46 <jle`> if dup x = (x, x)
14:48:53 <jle`> then dup dup = (dup, dup)
14:49:00 <jle`> just plug in 'dup' everywhere you see x in the body
14:49:17 <Tuplanolla> What is this? Forth?
14:49:20 <pierrot> yeah, I know, but (dup, dup) isn't the same as (dup dup)
14:49:28 <jle`> if dup x = (x, x), then dup foo = (foo, foo), dup 10 = (10, 10), dup "hello" = ("hello, "hello"0, etc.
14:49:32 <jle`> pierrot: are you sure about that
14:49:41 <ski> (knowing about "lambda" expression form for functions could be useful here)
14:49:42 <pierrot> not sure actually
14:49:47 <jle`> if i aked you what dup 10 was, what would you say it was?
14:49:53 <jle`> it'd be (10, 10)
14:49:57 <pierrot> (10, 10)
14:49:59 <pierrot> yeah
14:50:02 <jle`> if i asked you what dup "hello" was, what would you say it was?
14:50:12 <pikajude> what's dup "hip"
14:50:13 <pierrot> ah, I see
14:50:20 <jle`> and dup map = (map, map)
14:50:24 <jle`> dup id = (id, id)
14:50:27 <jle`> dup dup = (dup, dup)
14:50:29 <jle`> etc.
14:50:37 <freeside> i have dumb question. it is dumb because i feel like i must have asked this before and now i have forgotten. but, i am looking for a function of type Functor f => f (a -> b) -> a -> f b. which is to say, normally one fmaps a function over a functor; but here i have a list of functions that i want to run over a single value.
14:50:39 <kadoban> ski: Hm, never heard of that one, I'll check it out
14:50:39 <pierrot> yeah, you're right. (dup dup) is the same as (dup, dup) one you applied the function
14:50:44 <pikajude> > let dup x = (x, x) in flip (,) "hooray" $ dup "hip"
14:50:46 <lambdabot>  (("hip","hip"),"hooray")
14:51:09 <jle`> freeside: are you looking for a pre-written one
14:51:10 <pikajude> freeside: i think that's just fmap ($)
14:51:21 <jle`> or do you want to write it using functor combinators
14:51:38 <freeside> i am looking for something in a library, or something idiomatic
14:51:59 <jle`> most idiomatic thing would probably be to just write it using normal functor combinators
14:52:05 <jle`> :t \x y -> fmap ($ y) x
14:52:07 <lambdabot> Functor f => f (a -> b) -> a -> f b
14:52:16 <jle`> :t \x y -> x <*> pure y
14:52:17 <lambdabot> Applicative f => f (a -> b) -> a -> f b
14:52:33 <Tuplanolla> :t fmap . flip ($)
14:52:34 <lambdabot> Functor f => a -> f (a -> b) -> f b
14:52:45 <freeside> maybe what i want is a list comprehension.
14:52:48 <ski> it's been known as "strength", iirc
14:52:51 <ski> (also `flip')
14:53:04 <jle`> ah
14:53:39 <ski> (also cf. `Functor f => a -> f b -> f (a,b)')
14:53:45 <kadoban> I wonder what people typically use for a computational model, or do practical programmers just kind of handwave it?
14:54:08 <freeside> thanks, i will work through these suggestions.
14:54:19 <jle`> fmap ($ y) x is fine, list comprehensions is fine too if you have a list
14:54:38 <jle`> > map ($ 10) [negate, succ, pred]
14:54:39 <ski> kadoban : some kind of by-need operational semantics, probably
14:54:40 <lambdabot>  [-10,11,9]
14:54:48 <jle`> you can also use 'sequence' if you are feeling extra obfuscatey
14:54:58 <jle`> > sequence [negate, succ, pred] 10
14:55:00 <lambdabot>  [-10,11,9]
14:55:08 <jle`> sequence is exactly the original function you wanted
14:55:11 <kadoban> jle`: Nice
14:55:34 <freeside> oho
14:55:48 <freeside> thanks
14:55:52 <jle`> but if you're looking for something idiomatic, don't use sequence, heh
14:55:58 <freeside> lolwut why
14:56:14 * ski remembers reading some paper which had an explicit GC-rule for removing unused/dead heap bindings
14:56:15 <jle`> map ($ 10) [negate, succ, pred] is 10x more readable than sequence [negate, succ, pred] 10
14:56:15 <kadoban> Hehe, yeah even knowing ((->) r) exists and having used it a time or two, that one would take me a minute.
14:56:39 <kadoban> ski: I should probably read more papers and see what they use too ..
14:56:53 <ski> sadly, i don't recall the paper atm, or i'd link to it
14:57:06 <kadoban> Though most algos or DS papers are in the RAM model and using C-ish or whatever of course.
14:58:00 <freeside> okay, next question. I have a [(+1),(*2)] <*> [10,20] kind of situation, but i don't want the result to be concatted; I want the result to be [[11,20],[21,40]]
14:58:50 <kadoban> That should just be map
14:59:43 <jle`> :t \fs xs -> map (`map` xs) fs
14:59:44 <lambdabot> [a -> b] -> [a] -> [[b]]
14:59:58 <freeside> is there a predefined function that does it?
15:00:04 <jle`> probably not
15:00:16 <freeside> very well
15:00:24 <jle`> see https://twitter.com/cynede/status/435352522199285760
15:00:40 <jle`> and https://mail.haskell.org/pipermail/libraries/2012-February/017548.html
15:00:42 <Gurkenglas> I think I remember there being one... but ircbrowse is mia.
15:01:00 <kadoban> Haha, that's a nice term, "Fairbairn threshold"
15:01:02 <Tuplanolla> @hoogle f (a -> b) -> f a -> t (f b)
15:01:03 <lambdabot> Control.Lens.Iso lmap :: (a -> b) -> p b c -> p a c
15:01:03 <lambdabot> Control.Lens.Iso rmap :: (b -> c) -> p a b -> p a c
15:01:03 <lambdabot> Data.Bifunctor.Apply second :: (b -> c) -> p a b -> p a c
15:02:28 <jle`> hm
15:02:45 <jle`> > traverse map [(+1), (*2)] [10, 20]
15:02:47 <lambdabot>  [[11,21],[20,40]]
15:02:48 <ski> > [[f x | x <- [10,20]] | f <- [(1 +),(2 *)]]
15:02:50 <lambdabot>  [[11,21],[20,40]]
15:02:54 <ski> > let pam = flip map in [(1 +),(2 *)] `pam` \f -> [10,20] `pam` \x -> f x
15:02:56 <lambdabot>  [[11,21],[20,40]]
15:03:17 <jle`> :t traverse map
15:03:19 <lambdabot> Traversable t => t (a -> b) -> [a] -> t [b]
15:03:22 <jle`> :t traverse fmap
15:03:23 <lambdabot> (Functor f, Traversable t) => t (a -> b) -> f a -> t (f b)
15:03:44 <jle`> i'm kind of surprised it works
15:03:51 <Gurkenglas> Whatever I'm recalling surely won't be better than traverse fmap
15:04:28 <Gurkenglas> Where's exferenceBot? :/
15:05:36 <freeside> i think `traverse fmap` wins
15:05:41 <ski> "POSIWID" ?
15:06:02 <Tuplanolla> Ah, the first `f` was supposed to be `t`.
15:06:12 <Tuplanolla> Very good, jle`.
15:06:19 <kadoban> freeside: Somehow I don't think we've actually helped you, though you seem happy about it xD
15:06:47 <freeside> oh, i wouldn't want to see what actual help looks like
15:06:50 <freeside> this is fine
15:07:20 <freeside> the problem with haskell having such an enormous vocabulary is that i just feel like surely there must be a word for it that i just don't know yet
15:07:31 <jle`> the "real answer" here is to just use maps and list comprehensions
15:08:02 <jle`> sequence and traverse map here are sort of esoteric code obfuscation here, heh
15:08:08 <kadoban> freeside: Yes, but like in English if there's a word for it that only 3 people can understand, it's probably better to just use two words that everyone will be able to read.
15:08:10 * ertes wonders what the original question was
15:08:19 <freeside> and not knowing the idiomatic expression, if i have to make up some horrible kludge, ahem, if i have to derive the formula myself, then i am needlessly ELI5'ing myself
15:08:30 <jle`> ertes: one was [a -> b] -> a -> [b]
15:08:37 <jle`> ertes: the other was [a -> b] -> [a] -> [[b]]
15:08:56 <jle`> the first is obviously sequence, the second is obviously traverse fmap, d'oh </s>
15:09:01 <ski> (if `f x' is an involved expression, i would probably tend to favor the list comprehension or `pam' version. if it's just application, as here, `traverse' could maybe be nicer, provided one could learn to recall this usage, possibly requiring using it enough ..)
15:09:03 <freeside> obviously
15:09:22 <Gurkenglas> https://commercialhaskell.github.io/intero/ should suggest using melpa-stable with its older intero version if only Emacs 24.3 is available.
15:10:04 <jle`> i've been using flip fmap a lot recently
15:10:15 <jle`> hoping <&> might find its way into base eventually
15:10:24 <ertes> obviously, huh?
15:10:42 <ski> ("ELI5" ?)
15:10:58 <kadoban> ELI5 = explain it like I'm 5
15:11:16 <ski> oh
15:11:21 <ski> ty
15:11:26 <jle`> by 'is obviously' i mean 'can be written in an obfuscated way using'
15:11:33 <freeside> hang on, i have one last fillip.
15:11:37 <freeside> :t traverse fmap
15:11:38 <lambdabot> (Functor f, Traversable t) => t (a -> b) -> f a -> t (f b)
15:11:54 <freeside> what if i want (Functor f, Traversable t) => t (a -> b) -> f a -> f (t b)
15:12:19 <tomfb> Hey, if i have a list [Just 1, Just 2], is there a fcn that produces Just [1,2] ? thx :>
15:12:27 <jle`> tomfb: it depends on the behavior you want
15:12:37 <jle`> tomfb: sequence sill give you Just [1,2] if all of the original items are Just
15:12:42 <jle`> > sequence [Just 1, Just 2]
15:12:44 <lambdabot>  Just [1,2]
15:12:46 <ertes> flip (fmap . flip fmap)
15:12:51 <ertes> :t flip (fmap . flip fmap)
15:12:53 <lambdabot> (Functor f, Functor f1) => f1 (a -> b) -> f a -> f1 (f b)
15:12:57 <jle`> tomfb: you can also use Just . catMaybes
15:13:06 <jle`> which just "drops" the Nothings
15:13:08 <iqubic> :t catMaybes
15:13:09 <lambdabot> [Maybe a] -> [a]
15:13:09 <ertes> i like this one better =)
15:13:18 <ski> @type fmap . flip (fmap . flip ($))
15:13:19 <lambdabot> (Functor f1, Functor f) => f1 (a -> b) -> f a -> f (f1 b)
15:13:35 <barcabuona> bummerrr i just discovered where is syntactic
15:13:36 <tomfb> ok sequence looks perfect, because i jused maybe only as an example
15:13:37 <barcabuona> i hated let in
15:13:39 <barcabuona> :(
15:13:50 <tomfb> thank you! : )
15:13:58 <jle`> this is the sort of thing that sequence/Traversable was actually made for, i think
15:14:10 <iqubic> Are we trying to write [Maybe a] -> Maybe [a]?
15:14:11 <jle`> instead of what we were just doing when you walked in, heh
15:14:16 <freeside> haha
15:14:39 <Gurkenglas> tomfb, also if your code happens to be "sequenceA . fmap f", use "traverse f"
15:14:46 <iqubic> :t Just . catMaybes
15:14:48 <lambdabot> [Maybe a] -> Maybe [a]
15:14:53 <iqubic> Ah, I see
15:15:25 <ski> ertes : is that equal to jle`s ?
15:15:40 <tomfb> ok, give me a moment to play around with this
15:15:42 <jle`> tomfb: the general way to recognize an application of sequence is if you wnat to "pull out" an Applicative from inside a Traversable
15:15:49 <ertes> note that both Functor and Traversable abstract the idea of things that you can change pointwise and then reassemble, but Functor is far weaker
15:15:50 <jle`> sequence :: t (f a) -> f (t a)
15:15:56 <Gurkenglas> "Just . catMaybes" is not what he asked for for the same reason "Just . const []" isn't
15:16:05 <jle`> well
15:16:13 <jle`> it is likely something they might hav ewanted
15:16:19 <ski> freeside : where `flip (fmap . flip ($))' is the answer to your earlier question ..
15:16:21 <jle`> since catMaybes actually does something
15:16:51 <Gurkenglas> Neither function is surjective.
15:17:00 <ertes> ski: i would expect it to be, whenever fmap = fmapDefault
15:17:28 <ski> iqubic : there's two sensible versions. one gives `Nothing' only in case all elements were `Nothing'. the other gives `Nothing' as soon as an element is `Nothing'
15:17:41 <ziro``> If I have a `Maybe MyThing a` how can I get at a when pattern matching?
15:17:54 <jle`> ziro``: do you mean Maybe (MyThing a) ...?
15:18:00 <ski> ertes : hm, how's that defined ?
15:18:00 <ertes> ski: actually, no…  mine may be transposed
15:18:01 <ziro``> yeah
15:18:06 <tomfb> arg, i searched for the sequence definition on hoogle but forgot the (), so it only found container stuff
15:18:30 <ertes> > traverse fmap [(+1), (+10)] [100, 200]
15:18:31 <lambdabot>  [[101,201],[110,210]]
15:18:32 <Gurkenglas> ski, "Just . catMaybes" doesn't give Nothing if everything's Nothing o.o
15:18:59 <jle`> i just added the Just . since the original question wanted a 'Just',but it could have been an oversight :)
15:19:02 <ertes> > flip (fmap . flip fmap) [(+1), (+10)] [100, 200]
15:19:04 <lambdabot>  [[101,201],[110,210]]
15:19:12 <ski> ertes : i don't see how it could be transposed, considering the type
15:19:13 <ertes> ok, not transposed =)
15:19:16 <jle`> in this case it wasn't, but it would have been reasaonble to think that the Just was just added without being needed
15:19:23 <freeside> i'm looking for [[101,110],[201,210]]
15:19:28 <ski> Gurkenglas : exactly, hence my dismissal of it
15:20:13 <ertes> :t \fs -> fmap (flip fmap fs . ($))
15:20:14 <lambdabot> (Functor f1, Functor f) => f1 a -> f (a -> b) -> f (f1 b)
15:20:34 <ski> wanting to conform to an interface that expects `Maybe' to be returned is another thing. i was assuming wanting a stand-alone `forall a. [Maybe a] -> Maybe [a]'
15:20:46 <ertes> :t \fs -> fmap (flip fmap fs . flip ($))
15:20:47 <lambdabot> (Functor f1, Functor f) => f1 (a -> b) -> f a -> f (f1 b)
15:21:03 <ertes> ah, of course…  it can't be transposed
15:21:08 <ThreeFx> freeside: fmap (flip ($)) [100, 200] <*> [(+1), (+10)]
15:21:38 <ski> > (fmap . flip (fmap . flip ($))) [(1 +),(10 +)] [100,200]
15:21:40 <lambdabot>  [[101,110],[201,210]]
15:21:45 <freeside> wahey
15:21:51 <ski> freeside : so, what i suggested earlier
15:21:52 <ThreeFx> oh wait I forgot the nested list
15:21:54 <freeside> true
15:22:44 <ertes> freeside: do you actually need to preserve the layers?  because if not, there is (<*>)
15:22:46 <Gurkenglas> :t \fs xs -> traverse fmap (fmap (flip id) xs) fs
15:22:47 <lambdabot> (Functor f, Traversable t) => f (b1 -> b) -> t b1 -> t (f b)
15:23:01 <freeside> i do need to preserve the [[]]
15:23:08 <freeside> the <*> concats, which i don't want
15:23:13 <freeside> but look, i have found a more elegant solution
15:23:19 <freeside> doall fs xs = [ [ f x | f <- fs ] | x <- xs ]
15:23:26 <ertes> =)
15:23:48 <ertes> :t \fs xs -> [ map f xs | f <- fs ]
15:23:49 <lambdabot> [a -> b] -> [a] -> [[b]]
15:24:05 <xormor> how do I teach myself Haskell? It seems difficult except for simple math and display of characters and numbers.
15:24:12 <xormor> how do I learn Haskell?
15:24:13 <ski> ftr
15:24:14 <ski> <freeside> okay, next question. I have a [(+1),(*2)] <*> [10,20] kind of situation, but i don't want the result to be concatted; I want the result to be [[11,20],[21,40]]
15:24:33 <Tuplanolla> The same way you learn any other language, xormor.
15:24:35 <ertes> xormor: there are a few books available, and a few online courses that you can take
15:24:43 <ski> xormor : try a textbook ? perhaps read some tutorials first
15:25:07 <kadoban> xormor: http://haskellbook.com/ is how I wish I'd learned. There's other things that also seem good
15:25:14 <freeside> i have done a bunch of textbooks lately, including LYAH, Hutton, and haskellbook.com, and i have to say i preferred haskellbook.com
15:25:20 <whoman2> code code code
15:25:36 <ski> @where CIS194
15:25:37 <ertes> xormor: other than that, write an application
15:25:37 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
15:25:38 <ziro``> is it good practice to use custom `Maybe` types?
15:25:42 <ski> xormor ^
15:25:54 <ertes> ziro``: rarely
15:26:10 <ertes> ziro``: usually it just leads to inconvenient APIs
15:26:48 <Gurkenglas> lens helps, though.
15:26:58 <kadoban> ziro``: It can be sometimes, for the same reason that boolean-blindness is a thing, and possibly other reasons. But usually you don't need it.
15:27:02 <freeside> ertes: \fs xs -> [ map f xs | f <- fs ] does not do quite the same thing as fs xs = [ [ f x | f <- fs ] | x <- xs ]
15:27:23 <ziro``> thanks!
15:27:30 <ertes> freeside: ah, yes:  \fs xs -> [ map ($ x) fs | x <- xs ]
15:27:44 <ski> @where boolean-blindness
15:27:44 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
15:28:06 <ertes> kadoban: note that using a different type from Bool is not a cure for boolean blindness, but more likely a misunderstanding of the core problem
15:28:38 <ertes> Maybe actually is a cure
15:28:46 <ertes> in many cases at least
15:28:53 <iqubic> What is boolean blindness?
15:29:01 <ski> see link above ?
15:29:41 <ski> when in other languages, you use `(Bool,a)' instead of `Maybe a', then that's one simple form of boolean blindness
15:29:49 <freeside> well, i am satisfied. thank you all for lending your neurons to this problem.
15:29:57 <kadoban> ertes: It seems possible I've used the wrong term. My understanding of the core problem was that it becomes hard to figure out what True and False correspond to in terms of meaning. But the above link seems to be using a different meaning for a different pattern.
15:29:58 <freeside> i now return your neurons to you.
15:30:26 <ertes> here is a form of boolean blindness in haskell:  unless (null xs) (print (head xs))
15:30:37 <ski> you know that the boolean is supposed to tell whether the other component (or field or whatever) is to be considered or ignored. but the compiler doesn't know. and the maintainer may be confused, especially if they aren't grouped together
15:30:38 <ThreeFx> freeside: Theoretically, the garbage collector should do that for you =p
15:31:22 <ertes> kadoban: i have an explanation here: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
15:31:34 <ertes> (you can read that section in isolation)
15:31:46 <ski> with `Maybe a', there's no possibility of having an `a' value in the `Nothing' case. so the bit of information distinguishing `Nothing' from `Just' is *linked* (in the language itself) to knowing whether an `a' will be absent or present
15:31:49 <kadoban> ertes: But not fDoThingWithAStringAndASwitch "blah" True?, that's something else?
15:32:03 * kadoban reads
15:34:26 <freeside> speaking of Maybes and Bools, is it considered acceptable to implement a ternary logic using the type Maybe Bool?
15:34:36 <kadoban> ertes: Okay, yeah I guess I've been using the term incorrectly. By the way, out of curiosity, do you have strong objections to the safeHead thing? That's probably how I'd write it.
15:34:49 <ertes> kadoban: using Bool is not inherently boolean-blind, so it depends on what fDoThingWithAStringAndASwitch is…  sometimes a single bit is indeed the amount of information you need =)
15:35:04 <ertes> kadoban: no, not really
15:36:15 <kadoban> ertes: Yes but my usual problem with it is that it tends to be really confusing which thing True means, and thus I tend to use data Config = FireTheMissiles | DontFireTheMissiles  or some nonsense that doesn't require looking it up to tell what it means.
15:36:54 <kadoban> The reason I brought it up above is that IMO sometimes Maybe X has the same issue, where it's ambiguous what the X means. Though usually it's pretty clear.
15:37:00 <ertes> in that case you should perhaps abstract over missile-firing =)
15:37:10 <ertes> fBefore :: Bool -> IO ()
15:37:14 <ertes> fAfter :: IO () -> IO ()
15:37:20 <kadoban> Probably. It's not a great example, heh.
15:37:46 <ertes> sure, that happens, but then the problem is at X, not at Maybe
15:38:01 <ertes> given a clear X, Maybe X is also pretty clear
15:38:19 <ski> btw, the fact that Haskell distinguishes `Maybe a' from `Maybe (Maybe a)', but some other languages (or language libraries) doesn't distinguish a "nullable" situation from a "double nullable" situation, has been termed "domain contagion" (see e.g. the 2006-02-03 entry "Option types, optional parameters" by Riastradh at <https://mumble.net/~campbell/blag.txt>)
15:38:25 <`Guest00000> what do you do when you encounter some dead links on haskellwiki?
15:39:11 <ertes> `Guest00000: if you're registered, fix it, if not, perhaps report it on haskell-cafe
15:39:15 <kadoban> ertes: You're probably right, I can't think of a case where that's not a better fix (changing what X is).
15:39:59 <ertes> kadoban: Maybe is just (1 +) after all =)
15:40:38 <freeside> ah, i am answering my own question about ternary logic: https://rosettacode.org/wiki/Ternary_logic#Haskell
15:40:47 <ski> freeside : perhaps. if `Nothing' is treated as "failure to compute a definite answer", then i think it could be acceptable
15:41:25 <ertes> sqrt :: Double -> Either (Maybe Void, () -> ()) Double
15:41:30 <freeside> i will think about the semantics of my ternary logic to see if the monadic operators do the right thing using Maybe Bool.
15:41:56 <kadoban> ertes: Heh
15:42:36 <freeside> i suspect the Maybe monad correspnds to either Łukasiewicz logic or Kleene logic, i just don't know which yet
15:43:10 <kamyar> Hello all!
15:43:22 <kamyar> I am benchmarking Haskell code vs. Go
15:43:33 <freeside> i will think on this another day. i ate too many chocolate croissants today.
15:43:35 <kamyar> Aparently Go is faster in my case
15:43:56 <kamyar> Can u see my Haskell code and optimize it?
15:44:03 <freeside> only if you show your Go code as well
15:44:03 <ertes> kamyar: if you show us a paste of the haskell variant, we can probably give you optimisation hints
15:44:04 <Tuplanolla> As far as excuses go, that's top tier, freeside.
15:44:29 <freeside> only the best
15:45:03 <freeside> they were very good chocolate croissants. thank you Barclays Shoreditch for the top-notch catering. every co-working space should have an in-house kitchen and chef.
15:45:47 <kamyar> ertes: Here is the code: http://lpaste.net/356215
15:45:48 <kadoban> Sounds like a dangerous thing to have.
15:47:23 <kamyar> And the go code: http://lpaste.net/356216
15:47:39 <freeside> kamyar, how are you benchmarking these things?
15:48:08 <kamyar> freeside: Using ab with 200 requests 100 concurrent
15:48:47 <ertes> kamyar: how are you compiling the haskell variant, and what command line arguments are you giving it?
15:48:48 <kamyar> ab -n 2000 -c 100 -p vehice_data.json -T application/json http://127.0.0.1:8080/locations
15:49:36 <kamyar> ertes: Nothing just GHC benchmark.hs
15:49:36 <kamyar> ertes: You expect Haskell to be faster?
15:49:55 <ertes> kamyar: in general yes
15:50:11 <ertes> kamyar: compile with:  -O -threaded
15:50:25 <freeside> what timing results do you gete with Haskell vs Go for ab -n 2000 -c 100 ?
15:50:28 <kamyar> ertes: Ok. ets try
15:50:55 <ski> freeside : perhaps also cf. <https://en.wikipedia.org/wiki/Ternary_logic>,<https://web.archive.org/web/20090206013434/http://www.trinary.cc:80/>,(chapter three and four of) <https://aymara.org/biblio/html/igr/igr.html>
15:51:28 <freeside> ski: thanks, i will reduce my consumption of chocolate croissants tomorrow and apply myself with renewed focus
15:52:26 <ertes> kamyar: this may be a pathological case, but i can't imagine it…  you're using aeson, which is a very fast JSON parser/renderer, and you're using warp, which is among the fastest web servers in existence, even with lots of concurrency
15:52:47 <kamyar> ertes: GHC does not do anything and just exits
15:52:52 <kamyar> ok fixed
15:53:27 <ertes> kamyar: GHC does make's job to some extent…  just 'touch' the source code file
15:53:55 <ThreeFx> or just use -fforce-recomp
15:53:57 <kamyar> No noticeable change: 2972.09 [#/sec] (mean)
15:54:05 * ski read "exits" as "exists", pondering about existentialist (or perhaps solipsist) compilation
15:54:24 <ertes> heh
15:54:41 <kamyar> Go version: 4643.03 [#/sec] (mean)
15:54:48 <freeside> maybe you need to do -n 20000 for the thread pools to stabilize
15:54:57 <ertes> kamyar: is the go version concurrent by default?
15:55:12 <ertes> kamyar: in particular execute your program with these arguments:  +RTS -N
15:55:17 <ertes> your haskell program
15:55:26 <kamyar> Now haskell 3351.65 [#/sec] (mean)
15:56:10 <kamyar> But still I guess the difference is not aceptable
15:56:10 <kamyar> Even if Go gets faster, it should be about 10-15 %
15:56:40 <Tuplanolla> A measurement without error estimates is worthless, kamyar.
15:56:47 <ertes> kamyar: this difference is unreasonable, but i should note that i'm not familiar with two of your imports:  Data.CBOR and Database.Redis
15:57:09 * ski . o O ( <http://existentialcomics.com/comic/85> )
15:57:18 <ertes> kamyar: also one potential weakness of the haskell variant i can think of is the generic code to derive FromJSON and ToJSON
15:57:31 <freeside> is benchmarking best practice to run ab on localhost or on a different server?
15:57:51 <ertes> freeside: different server is better, in order to properly test concurrency
15:57:59 <freeside> https://www.reddit.com/r/haskell/comments/2wwbuj/announcing_bufferbuilder_encode_json_25x_faster/ claims to offer faster JSON
15:58:25 <freeside> but the json strings are presumably really tiny
15:58:41 <kamyar> ertes: I can understand that in real cases with high concurrency, Haskell will do better! But Go should not be so faster
15:58:41 <kamyar> anyway
15:59:51 <freeside> it would help to gather more datapoints and plot some sort of graph to see if you're hitting nonlinearity
16:00:16 <ertes> i doubt it
16:00:22 <freeside> it could be redis slowing down after a certain point, though to be fair that should factor out across both variants
16:00:30 <ertes> although i don't know redis very well
16:00:56 <ertes> it's supposed to be very fast for these simple key/value things, isn't it?
16:01:54 <freeside> you'd think
16:03:09 * ski . o O ( <https://ro-che.info/ccc/11> )
16:03:36 <ertes> my memory about redis is mostly limited to my attempt at setting up sensu (and it ended with me giving up) =)
16:04:05 <freeside> i have an idea. lose the JSON, switch to GET instead of POST, see what happens.
16:04:29 <ertes> or write the FromJSON/ToJSON instances yourself
16:04:34 <ertes> aeson is fast
16:04:45 <sm> I was going to suggest the same: start chopping things out until it gets fast (poor person's profiling technique)
16:04:57 <sm> or, profile it
16:05:20 <kamyar> ertes: One bad point about Haskell, to be honest, is that I have to switch from ByteString and Text or Lazy and Strict many times here
16:05:37 <freeside> kamyar, what happens if you increase -n to 20000 ?
16:05:55 <freeside> you should let the metal spin for > 1s
16:05:57 <tomleb> Is there a String to Int function in prelude ?
16:06:02 <tomleb> (A safe function)
16:06:18 <tempeh> length :)
16:06:19 <ThreeFx> tomleb: Text.Read has `readMaybe`
16:06:23 <ertes> kamyar: yes, haskell is very strict about what is text and what is raw bytes
16:06:25 <ThreeFx> tempeh: lol
16:06:34 <freeside> lol
16:06:51 <ertes> kamyar: and the lazy and strict variants are different enough that it makes sense that you need conversion there as well
16:07:00 <ertes> kamyar: although the lazy variants are usually a safe default
16:07:09 <tomleb> ThreeFx: Thanks
16:07:22 <tomleb> Why isn't there such a function for String ?
16:07:30 <sm> it would be interesting to fuzz test the two versions, you would hope to find the haskell is more correct
16:07:46 <kadoban> tomleb: That is the one for String.
16:07:47 <ThreeFx> tomleb: There is reads which does the job for you in a way
16:08:13 <ThreeFx> http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:reads
16:08:26 <kadoban> https://www.stackage.org/haddock/lts-8.18/base-4.9.1.0/Text-Read.html#v:readMaybe
16:08:36 <gehmehgeh> Why does Richard Bird us the functions "head" and "tail" in "Thinking Functionally With Haskell"? 
16:09:09 <kamyar> ertes: I guess the only language may beat Go (except C and D) is Rust
16:09:22 <gehmehgeh> s/us/use
16:09:38 <tempeh> anyone have opinions on refactoring in emacs? I use spacemacs/intero, trying to figure out how to do basic things like rename variables throughout a project
16:09:43 <tomleb> kadoban: That's exactly what I need, yeah couldn't find readMaybe because I thought he meant Data.Text.Read
16:09:46 <tomleb> Thanks
16:10:13 <kamyar> I mean in this special case
16:10:20 <ertes> kamyar: with haskell it's a matter of libraries and abstractions, but if you just do the obvious, idiomatic thing, haskell will generally work very well
16:10:24 <kadoban> Yeah, I'm not really sure why the module is called Text.Read honestly. It seems like not a great name. Maybe it came before the 'text' package stuff?
16:10:30 <sm> tempeh: M-x tags-query-replace is probably most practical
16:10:49 <lyxia> gehmehgeh: maybe it makes things simpler
16:10:52 <ertes> kamyar: note also that conversion doesn't necessarily mean computation…  a conversion is often purely semantical
16:11:58 <tempeh> sm: cool, didn't know about that, thanks. was hoping for something that understands haskell syntax though
16:12:38 <kamyar_> ertes: I guess the only language may beat Go (except C and D) is Rust 
16:12:38 <freeside> if nothing else works to get the Haskell version running faster, you could try sprinkling a few Sleep() calls through the Go version, that should help
16:12:46 <kamyar_> I mean in this special case
16:12:58 <ertes> kamyar: with haskell it's a matter of libraries and abstractions, but if you just do the obvious, idiomatic thing, haskell will generally work very well…  note also that conversion doesn't necessarily mean computation…  a conversion is often purely semantical
16:12:59 <MP2E> lol
16:13:03 <freeside> in the spirit of the above length :: String -> Int 
16:13:11 <freeside> HTH
16:14:02 <kamyar_> ertes: Thanks anyway! I have to go to bed! bye
16:14:06 <sm> kamyar: there's also the slow but powerful -OREDDIT
16:14:27 <ertes> there used to be -Odons
16:14:40 <ertes> but it doesn't seem to work anymore
16:15:20 <freeside> bam, there go all their sockets
16:15:40 <freeside> so much for -c 65536
16:16:55 <ckubrak> Am I the only one that can't get into haskell wiki?
16:17:28 <EvanR> in the spirit of "why zero is useful" we need an argument ready for when someone learns that an explicit conversion is both necessary and does nothing
16:17:40 <pacak> ckubrak: downforeveryoneorjustme.com
16:17:42 <EvanR> and asks what the point it
16:17:43 <EvanR> is
16:19:45 <ertes> i can't decide what to eat
16:20:10 <ertes> @check \b -> label (if b then "eggs" else "salad") False
16:20:12 <lambdabot>  *** Failed! Falsifiable (after 1 test and 1 shrink):
16:20:12 <lambdabot>  True salad
16:20:31 <kadoban> Apparently chocolate croissants are a good choice.
16:20:49 <ThreeFx> ertes: The german saying is "6 beer also amount to a meal"
16:20:59 <ab9rf> i've never had a true salad
16:21:05 <ertes> i don't dring bier though
16:21:12 <ertes> drink…
16:21:26 <ab9rf> nobody's perfect
16:22:01 <ertes> ThreeFx: also the people who say that look like they took it very literally =)
16:22:30 <ThreeFx> Well, pretty much, yeah ;)
16:26:42 <freeside> if you have eggs and a large quantity of oil available, i will recommend http://www.seriouseats.com/recipes/2012/02/thai-style-omelet-khai-jiao-recipe.html
16:27:14 <freeside> in the limit, one may omit all extra ingredients except a spoonful of water; deep-fry one egg at a time in at least 2cm of oil
16:27:16 <tempeh> that looks delicious
16:27:42 <freeside> let cook until well browned, then flip and cook for a few seconds, then extract and eat
16:27:58 <freeside> repeat until all the oil is gone and you are unable to think about ternary logic
16:27:59 <ertes> hah!  i think i'm gonna try that =)
16:28:27 <freeside> ideally, have a pair of tongs handy
16:32:25 <fresheyeball> No instance for (FromJSON Data.ByteString.Internal.ByteString)
16:32:27 <fresheyeball> really?
16:32:30 <fresheyeball> is this serious right now?
16:32:38 <fresheyeball> haha
16:32:38 <freeside> in the 3d array of CookingMethods * Ingredients * EthnicCuisine, "Deep Fried * Eggs" is conspicuously absent from most cuisines, i don't know why
16:36:31 <freeside> in http://lpaste.net/356215 would it have helped to explicitly precompile and constantify the CBOR_TS values around lines 48--51?
16:36:48 <freeside> or does Haskell do that already?
16:38:06 <lordcirth> freeside, most compilers will inline constants
16:40:15 <freeside> gotcha
16:45:36 <tomleb> Can anyone please help me improve? I haven't touched haskell in a while, never went past applicative (I think) in haskellbook, and I'm currently at a lost.
16:45:53 <tomleb> Here's the piece of code that I want to improve because it looks shitty + I'm sure there's a better way to do it
16:45:59 <tomleb> http://ix.io/xrx/hs
16:52:29 <Cale> tomleb: I suppose you could use MaybeT for that
16:52:35 <ski> tomleb : would it make more sense to pass an `Int64' rather than a `ByteString', letting the caller handle the read failure in some appropriate way ?
16:53:17 <tomleb> ski: No, for now it's fine to stay as ByteString imo
16:53:21 <ski> tomleb : do you want to treat all the three errors the same here. then what Cale suggested could be used to avoid the boilerplate failure case repetition
16:53:28 <tomleb> Yeah
16:53:34 <Cale> Well, he appears to be handling all the errors the same
16:53:36 <tomleb> that's pretty much what I was trying to do
16:53:40 <tomleb> but I gave up
16:53:51 <ski> iow `MaybeT Handler' rather than `Handler'
16:55:16 <tomleb> Hum 
16:55:26 <ski> (if you prefer, the interface to `lookupMod' could still use a plain `Handler', if you prefer callers not having to interact with `MaybeT'. but if caller(s) also may generate errors that you want to collate together, it might be nicest to use `MaybeT' there as well, floating the escape `runMaybeT' higher up in the call hiearchy)
16:55:43 <tomleb> Callers do generate errors
16:55:52 <tomleb> 1 error, which would also be handled the same way
16:55:55 <tomleb> So you're saying
16:55:56 <ski> that should be collated in the same way ?
16:56:00 <ski> ok
16:56:40 <ski> how's `Handler' defined ?
16:56:48 <tomleb> This 'lookupMod :: Config -> ByteString -> Handler Moderator' would become 'lookupMod :: Config -> ByteString -> MaybeT Handler Moderator' and then in the caller I have 'runMaybeT lookupMod _ _' instead of 'lookupMod _ _'?
16:57:12 <ski> tomleb : in the caller where you don't want to further propagate `runMaybeT', yes
16:57:39 <tomleb> Control.Monad.Trans.Except.ExceptT ServantErr IO
16:57:43 <tomleb> That's Handler
16:58:17 <ski> though it'd be `do mx <- runMaybeT (lookupMod _ _); case mx of Nothing -> throwError (err401 { errBody = "Permission denied." }); Just x -> ..x..'
16:58:34 <tomleb> Let me show the two functions so you get a better idea
16:59:15 <tomleb> http://ix.io/xrB/hs
16:59:33 <ski> it looks like nothing `lookupMod' calls can generate any more (in particular *other*) `ServantErr'ors
16:59:37 <glguy> tomleb: You can do this http://lpaste.net/356223
16:59:43 <ski> not sure whether that holds for callers of it as well
17:00:38 <tomleb> ski: Sorry what ?
17:00:42 <tomleb> glguy: That looks sexy
17:01:15 <ski> tomleb : no other calls to `throwError' from callers of `lookupMod'
17:01:46 <tomleb> I'm not sure to understand what you mean
17:01:49 <tomleb> :/
17:02:33 <ski> tomleb : what glguy suggested would be a way to go, if you wanted to be able to intersperse calls to actions that could throw other errors
17:02:49 <tomleb> Right
17:03:03 <ski> tomleb : but since it looks like you're only interested in `throwError (err401 { errBody = "Permission denied." })' here, the `MaybeT Handler' approach also seems reasonable
17:03:46 <tomleb> I think I'll try the MaybeT approach, if not just to get experience with it
17:03:57 <ski> i'm assuming you don't want to mess with the return type `AuthHandler Request Moderator', ior with the definition of `AuthHandler' itself
17:04:10 <tomleb> I'd prefer not indeed
17:04:31 <tomleb> Mostly because I don't grok all that stuff yet
17:04:39 <tomleb> And trying to learn everything will just make me explode
17:05:21 <ski> if so, you'll need to use `runMaybeT' in `authMod' (rather than in whoever unpacks a `AuthHandler Request Moderator' to get back `Request -> MaybeT Handler Moderator' (assuming said change))
17:08:49 <tomleb> You're saying I should go one step higher instead ? So have `runMaybeT authMod` instead of `runMaybeT lookupMod` ?
17:09:36 <ski> no, go with `runMaybeT (lookupMod _ _)', as you started
17:10:30 <tomleb> Alright, I'll do that 
17:10:32 <tomleb> brb
17:11:15 <tomleb> I think I don't understand how MaybeT works
17:11:28 <ski> i'm just saying that if you wanted to coalesce errors in `lookupMod' (and `authMod') with ones higher in the call hierarchy, you'd possibly want to move the `runMaybeT' even higher, requiring changing said return type, or `AuthHandler' itself (or at least `mkAuthHandler', or making a variant of it)
17:11:37 <tomleb> I have this in lookupMod now `mId <- R.readMaybe . C.unpack $ key`
17:11:44 <tomleb> and that doesn't seem to work
17:12:11 <ski> yeah, you need some explicit conversion (inclusion)
17:12:35 <tomleb> hum ?
17:14:58 <tomleb> So I have the `MaybeT Handler Moderator`
17:15:17 <tomleb> and I have a do { mId <- R.ReadMaybe .... }
17:16:42 <ski> something like
17:16:55 <ski>   lookupMod :: Config -> ByteString -> MaybeT Handler Moderator
17:17:12 <ski>   lookupMod config key = do
17:17:25 <ski>     uId :: Int64 <- (MaybeT . return . R.readMaybe . C.unpack) key
17:17:39 <ski>     user :: User <- liftIO . (`runSqlPool` getConfigPool config) $ do
17:17:49 <ski>       P.get (toSqlKey uId)
17:18:00 <ski>     UserModerator <- return (userStatus user)
17:18:05 <ski>     return (Moderator user)
17:19:12 <ski> (instead of `UserModerator <- return (userStatus user)', one could use `guard (userStatus user == UserModerator)', if preferred. the former variant doesn't rely on `Eq', though, so can be handy to know about)
17:19:37 <tomleb> I'm having trouble with uId :: Int64
17:20:01 <tomleb> Ah, I need ScopedTypeVariables
17:20:19 <ski> yes. that's just a style thing (but checked by the compiler, rather than your comments)
17:21:23 <ski> i just indented `P.get (toSqlKey uId)' on its own line, anticipating there possibly being several lines in that `do'-block. in your case you could just as well put it on the previous line
17:21:28 <tomleb> Why does the line beginning by user and the other one works ?
17:22:04 <ski> `MaybeT' takes care of short-circuiting, in case of an intermediate result (secretly) being `Nothing'
17:22:23 <ski> `MaybeT Handler Moderator' wraps `Handler (Maybe Moderator)'
17:22:38 <tomleb> Would I need a flip though ?
17:22:43 <tomleb> Ah no because
17:22:50 <tomleb> `runSqlPool` is infix
17:23:13 <tomleb> So it's like (+1) 2 which would be 2 + 1, correct ?
17:24:04 <tomleb> Hum
17:24:05 <ski> in fact, since you haven't used any other part of `Handler', basically `ExceptT ServantErr IO', than the `IO' part, you should be able to use `MaybeT IO' rather than `MaybeT Handler' here (and then you may drop the `liftIO', since it's a noop then)
17:24:31 <tomleb> That might help my comprehension as well
17:24:32 <ski> right, that's a cute trick i often use with `runState' and similar operations
17:24:44 <tomleb> Because I'm still a bit confused
17:24:49 <tomleb> Let me switch to MaybeT IO
17:24:56 <ski> some people prefer writing like `flip (getConfigPool config)'
17:25:29 <tomleb> Yeah I thought about flip
17:25:48 <tomleb> Do I need to lift anything if I'm just using MaybeT IO ?
17:25:49 <ski> er, i mean `flip runSqlPool (getConfigPool config)'
17:26:05 <ski> one can also consider :  runSqlPool `flip` getConfigPool config
17:26:12 <ski> (for applying on second argument)
17:26:36 <tomleb> right
17:27:16 <ski> `lift' gets you from `Handler X'/`IO X' to `MaybeT Handler X'/`MaybeT IO X'
17:27:39 <tomleb> That part I get, now trying to use MaybeT IO, I get 'Couldn't match type IO Moderator' with 'Handler Moderator'
17:28:00 <tomleb> Ok so I need the reverse of lift then ?
17:28:06 <tomleb> To go from IO X to Handler X
17:28:12 <ski> `liftIO' gets you from `IO X' to `IO X' (uselessly), or `Handler X' (or `ExceptT ServantErr IO X'), or `MaybeT Handler X'/`MaybeT IO X'
17:28:48 <tomleb> Right so it was liftIO
17:29:13 <ski> however, to get from `Maybe X' to `MaybeT Handler X'/`MaybeT IO X', i used `MaybeT . return' .. i don't recall whether there's a nicer (mnemonic, or at least memorable) shorthand name for that
17:30:22 <tomleb> Ah, and then we don't need (MaybeT . return) for the runSqlPool because of liftIO
17:31:10 <ski> `UserModerator <- return (userStatus user)' -- pattern-match failure in a `<-' will call `fail', which here will just generate a `Nothing' (causing short-circuiting / exception behaviour)
17:32:21 <ski> (using `guard' instead, it will call `empty', which will again generate `Nothing', behaving the same)
17:32:29 <wizwww> so i am thinking about writing a server in haskell and would like to avoid having to worry about GC pauses
17:32:33 <wizwww> a socket server
17:33:00 <wizwww> and i was thinking that if i could have at least a couple of separate processes, i would have the GC operate in either independently but maintain throughput
17:33:00 <tomleb> ski: So which one between the two is the most readable ? for haskellers
17:33:08 <wizwww> is there a standard way of doing this?
17:33:28 <tomleb> I think I'd be more comfortable with having guard 
17:33:59 <tomleb> ski: Oh apparently I did need a MaybeT . liftIO for the user :: User line
17:34:34 <ski> tomleb : since i don't like overusing `$' (by which i'd count most of all uses of it), i reformulated the code to avoid that (apart from the `$ do' combination, an exception). feel free to change back, if you prefer. i merely wanted to exhibit a different style, as well as not cause anguish to myself ;)
17:35:15 <tomleb> Where ?
17:35:35 <ski> in the code i displayed
17:37:01 <ski> tomleb : oh, you're quite right about the `user' line. an oversight of mine
17:37:20 <tomleb> Would 2 liftIO work instead of MaybeT ?
17:37:41 <tomleb> Let me check the type again
17:38:21 <ski> (for some reason i was momentarily thinking that `(`runSqlPool` getConfigPool config) $ do ...' had type `IO User', rather than `IO (Maybe User)' ..)
17:38:43 <ski> @type liftIO
17:38:45 <lambdabot> MonadIO m => IO a -> m a
17:39:05 <tomleb> Just for a recap and really understanding:
17:39:10 <ski> `liftIO . liftIO' is useless. the second `liftIO' there is `id :: IO a -> IO a'
17:39:45 <tomleb> runSqlPool returns 'Control.Monad.Trans.Control.MonadBaseControl IO m => m a'
17:39:58 <tomleb> I use liftIO on it
17:40:07 <tomleb> and then I'm lots
17:40:09 <tomleb> lost lol
17:40:56 <glguy> It's probably been done before, but I was messing around with a multi-arity zipWith that didn't turn out too messy http://lpaste.net/356225 (not to say that it's going to be completely efficient)
17:41:46 <ski> afaics, `(`runSqlPool` getConfigPool config) $ do P.get (toSqlKey uId)', aka `runSqlPool (P.get (toSqlKey uId)) $ getConfigPool config', has type `IO (Maybe User)' here
17:42:34 <ski> before, when you used `liftIO' on that, you got to `Handler (Maybe User)', so `mUser' got type `Maybe User' (since we're in a `do'-block for `Handler')
17:43:50 <ski> but now, when you use `MaybeT . liftIO', you get first to `Handler (Maybe User)', and then to `MaybeT Handler User', so `user' gets type `User' (since we're in a `do'-block for `MaybeT Handler')
17:44:02 <tomleb> Ok
17:44:05 <tomleb> Makes more sense now
17:44:30 <ski> .. or, if you use `MaybeT IO' rather than `MaybeT Handler', then this `liftIO' is useless, and we get to `MaybeT IO User'. otherwise basically the same
17:44:52 <tomleb> I am using MaybeT IO now
17:44:57 * ski nods
17:45:15 <ski> just clarifying the (slight) difference between that and `MaybeT Handler', here
17:45:39 <tomleb> Well I didn't realize that liftIO was useless, now I do
17:45:44 <tomleb> Thanks a ton
17:45:59 <ski> yea, i was suspecting that wasn't clear :)
17:46:23 <ski> i hope you prefer this code to the original
17:46:39 <tomleb> Oh for sure
17:47:00 <tomleb> That's way more concise, and I'm sure way easier to understand for haskellers
17:48:49 <ski> tomleb : i think if you imported `Control.Monad.Base', then `liftBase' (a generalization of `liftIO') would take you from `Maybe X' to `MaybeT Handler X'/`MaybeT IO X'
17:49:36 <ski> note that `lift' always "lifts" a single monad transformer level, so if you want to "burrow" into several layers of them, you need several `lift's
17:51:11 <ski> otoh `liftIO' (and `liftBase') always takes you from the (non-monad-transformer-generated) monad at the "base" of such a stack (`IO' in the first case, generalized to also `Maybe',`State',`Reader',`Writer',`Cont',`Identity',&c. in the second case)
17:51:20 <tomleb> Ah ok, so if I ever decide to change MaybeT for something else I don't have to change all the call to MaybeT since I'd be using liftBase ?
17:51:54 <ski> yeah .. though it's possibly not that likely here
17:52:18 <tomleb> right, just good to know in general
17:52:21 <ski> but it may be easier to read `liftBase' (with some comfortability with it), than figuring out what `MaybeT . return' does every time
17:52:25 <ski> (or not. i dunno)
17:53:16 <ski> hmm
17:54:00 <ski> actually, now that i think about it more closely, i think `liftBase' actually wouldn't help there
17:56:00 <tomleb> Would probably confuse me tbh
17:56:01 <ski> (it is a generalization of `liftIO', alright. but that doesn't mean it can take us from `Maybe X' to `MaybeT IO X'. it *can* take us from `IO X', otoh, to `MaybeT IO X'. allowing both of these with `liftBase' would be more ambiguous, a kind of ambiguity that i see `MonadBase m b' not allowing (the FD `m -> b', functional dependency, `m' determines `b'))
17:56:17 <ski> sorry for the confusion (you can tell i don't use `liftBase' that often)
17:57:32 <ski> (this perhaps also explains why i couldn't recall a name/generalization of `MaybeT . return' .. i then went and recalled the wrong module. possibly there's some module that does what i was thinking of, but i can't recall where ..)
18:00:19 <tomleb> Don't worry, there's so much to learn, not your fault if you're confusing me
18:00:26 <ski> (the module would associate `Maybe' with `MaybeT', `Either' with `ExceptT', `State' with `StateT', `Reader' with `ReaderT', &c.)
18:00:32 <tomleb> Might have asked already but
18:00:41 <tomleb> `uId :: Int64 <- (MaybeT . return . R.readMaybe . C.unpack) key`
18:00:53 <tomleb> Here R.readMaybe gives a `Maybe Int64`
18:00:57 <tomleb> Then return on that
18:01:07 <tomleb> @type return
18:01:08 <lambdabot> Monad m => a -> m a
18:01:20 <tomleb> But what would be m
18:01:22 <ski> gets `IO (Maybe Int64)' (or `IO (Handler Int64)', if you prefer)
18:01:32 <tomleb> Why IO ?
18:01:40 <tomleb> Why is it choosing IO ?
18:01:45 <ski> then `MaybeT' on that gets `MaybeT IO Int64' (or `MaybeT Handler Int64')
18:01:59 <tomleb> @type MaybeT
18:02:00 <lambdabot> m (Maybe a) -> MaybeT m a
18:02:22 <ski> because this `... <- ...' command is in a `do'-block for `MaybeT IO' (alternatively `MaybeT Handler', depending on which variant you use)
18:02:25 <tomleb> Oh so return will give IO because we have `MaybeT IO a` which is really IO (Maybe a)
18:02:51 <ski> it already knows to expect an action of type `MaybeT IO X', for some type `X', yes
18:02:56 <ski> right, exactly
18:03:12 <tomleb> Ok
18:03:15 <tomleb> Weew
18:03:57 <ski> overloading on return type may be unfamiliar from other languages
18:04:45 <ski> (though istr Ada does it. and generates a diagnostic, in case it's ambiguous, unlike C++ iiuc)
18:05:00 <functor> Hi. I'm trying to understand how channel works. When I remove the last line in http://pastebin/ why does only "hello world" gets printed?
18:06:18 <functor> eh, let me fix the link.
18:06:45 <functor> http://lpaste.net/356226#a356226
18:08:14 <functor> So if we write to the channel twice, then we'd have to read twice? I wanted to write iteratively then read all content
18:10:20 <Cale> functor: Yeah, you get back one item at a time. The items can be of any type, even types where it doesn't make sense to concatenate things together.
18:18:38 <functor> Cale: I am reading N files concurrently, each thread reads one file line by line, and I'd like to get all the lines in "one place" for processing, are channels suitable here? e.g. let every thread write a line into the channel then get all channel content.
18:21:03 <geekosaur> functor, the natural way to do it is a thread which pulls from the Chan and builds a list or whatever
18:21:55 * ski . o O ( `unsafeInterleaveIO' )
18:21:58 <geekosaur> however, unless you must absolutely have the whole result before you can do anything, you might want to make use of laziness: the worker thread pulls and processes items from the Chan as they come in
18:22:10 <Cale> functor: You really want the lines spliced together randomly?
18:22:40 * geekosaur wonders if this is an overly complex sleepsort or something >.>
18:23:06 <functor> Cale: yes the order doesn't matter.
18:23:18 <Cale> okay, then yeah, you could do that.
18:23:20 <geekosaur> or just the merge end of a multiprocess sort/merge
18:24:22 <Cale> Well, apart from the fact that Chan isn't really appropriate when you want the processing to eventually end.
18:24:34 <functor> geekosaur: well yes, I'd like the sum of a column in every line. 
18:24:54 <Cale> I'm not sure the multiple threads thing is really of any benefit here.
18:24:56 <geekosaur> you could still build that iteratively
18:25:14 <geekosaur> rather than needing the worker to block until all input is available, sum the column as records come in
18:25:15 <ab9rf> yeah, i don't understand the merits of using threads in this context
18:26:18 <Cale> functor: Why not just read the files sequentially here?
18:26:18 <functor> Cale: Why is it not approperiate, and what is then?
18:27:33 <geekosaur> if you're just reading a bunch of disk files, unless you have planned the I/O out very carefully, you will lose more overhead to threading than you would gain over just reading the files in sequence
18:27:53 <geekosaur> (note that you will also be fighting the OS if you *have* planned the I/O out that carefully)
18:29:13 <functor> geekosaur: I'm using Pipe and the data simulate a stream.
18:29:18 <geekosaur> (also: this is true in general, not just of Haskell)
18:29:39 <geekosaur> still doesn't sdound like you gain anything
18:29:56 <Cale> functor: What is it that you're computing?
18:30:10 <geekosaur> unless the Pipe-s are doing their own complex processing in which case that might benefit from threading
18:30:24 <geekosaur> but if they're just reading data, all you have done is add overhead
18:30:25 <monochrom> The disk is a bottleneck, compared to multithreading.
18:30:30 <functor> Cale: online financial market records
18:30:52 <monochrom> See also: xax-flow, min-cut
18:30:56 <monochrom> err, max-flow!
18:31:05 <geekosaur> (again, if this is a disk file. if reading network streams, it would make sense)
18:31:33 <monochrom> Hmm, network may also be slow enough.
18:31:33 <functor> geekosaur: its going to be a network stream, at the moment this is just for simulation.
18:31:50 <Cale> I don't think it necessarily makes sense for network streams either.
18:31:53 <geekosaur> ok, that makes mroe sense then. You said files and this is very definitely overkill for those
18:32:00 <Cale> Concurrency makes sense for network request handling
18:32:13 <geekosaur> that depends on where the streams are coming from
18:32:35 <monochrom> To be sure, in iTunes, when I enable "multiple simultaneous downloads", I do get more data downloaded. :)
18:32:55 <geekosaur> sadly I can't introduce you tot he customer with a long-haul network link that is, between retransmissions and just the nature of the intermediate links, really slow
18:33:40 <geekosaur> not everyone is 2 hops from the backbone
18:34:26 <functor> Alright, so far Cale & geekosaur suggested a thread which reads from the Chan as data come in. I think I'll go with that.
18:35:49 <geekosaur> I would definitely process it off the Chan as it comes in instead of wating until the end, though, especially if you only care about aggregating one column. gathering it all first is a waste of memory *and* time
18:36:11 <functor> I'll have to find a way to trigger Chan every time something is written into it. (Which is why I didn't like that you have to read every time you write).
18:36:40 <geekosaur> just read from it, the thread will block until something comes in
18:36:46 <geekosaur> that's why you do it in a worker thread
18:37:01 <functor> geekosaur: agreed. New to concurrency here and was reading about MVar and Chan. Chan looked easier so thought I'd start using it. 
18:37:05 <geekosaur> then use async or somehting to manage the threads so you can wait for the worker thread to give you the final result
18:37:54 <geekosaur> there is little reason to deal with the low level stuff unless you're trying to learn the basics of concurrency. it's a lot of extra work for no gain.
18:38:09 <geekosaur> and there are probably better ways to learn the basics of concurrency
18:38:37 <functor> but I am always curious :(
18:38:45 <geekosaur> (I don't mean basics as in "hello world", I mean basics as in "how you would design a concurrency abstraction from scratch")
18:38:50 <functor> end up wasting time reading how things work
18:39:18 <c_wraith> Just as a general note, you should probably never use a basic Chan as a queue in production software.
18:39:47 <functor> geekosaur: thats the bottom-up approach, which is great. I'm trying the top-bottom approach.
18:39:59 <c_wraith> You should always use some sort of bounded chan
18:40:01 <functor> c_wraith: not production (YET).
18:41:38 <functor> c_wraith: bounded Chan as in fixed size?
18:42:02 <c_wraith> well, maximum size.  Doesn't mean it has to use a fixed-size implementation
18:42:47 <c_wraith> Whenever you have an unbounded queue, if producers are winning the race with consumers, the system runs out of memory and dies.
18:42:51 <functor> c_wraith: when max_size mkNewChan
18:42:53 <functor> something like that
18:43:39 <c_wraith> If you have a bounded queue, producers get throttled when consumers can't keep up, but the system keeps running
18:43:51 <functor> c_wraith: so consumers should work faster
18:44:26 <functor> OK. That was another way of looking at it.
18:44:43 <c_wraith> Just like every other normative "should" in software..  yeah, the real world gets in the way.
18:45:40 <c_wraith> the term for the general concept is back-pressure
18:53:00 <functor> Cale, geekosaur & c_wraith, thanks a lot for the help.
18:54:03 <ski> monochrom : `max-flow',`min-cut' ?
18:59:00 <bluebaron> Does anyone know of some online tool where I can like, toy around with small categories or something similar to that/
19:00:44 <lyxia> what an uncommon pastime
19:08:25 * ski 's brother started to draw an exponentiation table for small finite categories, in DeluxePaint
19:12:54 <bluebaron> lyxia: I use "toy around" lightly here, haha. I don't have the tightest grasp on some of the finer aspects of Haskell's type system, and though I am aware the connection between the two has been described as bogus, I just want to verify a very surface-level understanding of some of the concepts in CT
19:12:54 <bluebaron> Right now, I just want to find the smallest category you can construct if you start from a directed [multi]graph with 3 vertices, each of which are connected to each other in both directions
19:16:00 <ski> bluebaron : if you define composition of opposite morphisms there to be identity, you get a category already, without adding any more morphisms (than the identities, of course)
19:17:27 <ski> however, the free category of that graph, adding no extra restrictions ("laws"/"relations") on the composition of those basic six morphisms, apart from (instances of) neutral element law, and associativity, would have infinitely many morphisms
19:17:54 <ski> s/free category of/free category on/
19:18:55 <bluebaron> ski: Cool, okay! That totally makes sense. As I was trying to experiment with composing them, I did kind of get the feeling that without more restrictions it would be infinite
19:19:04 <ski> (hm, in the former case, you also would need to define composition of three morphisms in a triangle to be identity, for completeness of the description)
19:19:53 <ski> bluebaron : compare with how the free monoid on a set `X' is the list monoid `[X]'
19:21:16 <ski> each inhabitant `x' of `X' "becomes" a singleton list `[x]' in `[X]'. then we add all inhabitants (turning out to be lists) to accomodate neutral element and monoid combination, subject to neutral element laws and associativity
19:22:45 <bluebaron> ski: Wow thanks, I think I actually understand that. This CT studying was actually started because I couldn't really understand the construction of a free monad in a library in PureScript I was trying to use, but these descriptions of free constructions for other objects are kind of beginning to elucidate
19:23:03 <ski> in multiplicative notation, `(1 * a) * ((b * 1) * a)' will amount to a list `[a,b,a]', interpreting `1' as the empty list, and `*' as list concatenation
19:24:00 <fosskers> hey guys
19:24:01 <ski> free constructions are nice to know about
19:24:16 <fosskers> I'm giving the types of a lib of mine common typeclass instances at the request of a user
19:24:23 <ski> it's good to be aware of that it is a relative concept, though
19:24:33 <fosskers> I've added Generic, NFData, and Hashable. Should I bother with Typeable/Data? 
19:25:05 <ski> bluebaron : do you know any group theory ? any linear algebra / vector spaces (like knowing what a linear transformation is) ?
19:25:08 <bluebaron> ski: it's basically a free-as-in-gratis way of getting a law-abiding mathematical construction from one you already have, yes?
19:25:37 <bluebaron> ski: I do know some linear algebra, mind you I took the course a couple years ago but I'd like to think I have a tentative grasp on the fundamentals still
19:26:24 <lyxia> fosskers: Typeable is automatically derived nowadays, and Data is obsolete.
19:26:42 <ski> fosskers : i'd probably add `Typeable', while already adding the others. istr hearing `Data' may become deprecated
19:27:05 <ski> oh, right, i forgot about auto. deriv.
19:27:33 <ski> bluebaron : basically, yes
19:27:44 <ski> bluebaron : "free" as in "least restrictive"
19:28:02 <ski> (and as in "gratis", yes)
19:28:05 <fosskers> thanks guys, I'll leave them out
19:28:32 <ski> bluebaron : you roughly recall what a vector space is, yes ?
19:28:51 <bluebaron> ski: Yes, I'm looking at the axioms required thereof on Wikipedia right now haha. Fairly straightforward
19:29:45 <ski> bluebaron : given a finite set `S' with `n' elements, the free (real-scalar-valued) vector space on `S' is `|R^n'
19:30:18 <ski> the inhabitants of `S' becomes the (standard/canonical) basis vectors of `|R^n'
19:31:57 <bluebaron> ski: I think I'm following you, but I don't know the syntax you're using in `|R^n'. I'm assuming ^n is a superscript n, which would make sense, but I don't know about the rest
19:33:10 <ski> `|R' would be intended to represent the set (or type, if you prefer) of real numbers
19:33:40 <bluebaron> ski: Loosely speaking though, assuming `|R` somehow gets translated to the reals (?), it's just forming a vector from the "amount" of each of the set elements, right? e.g. {red, green, blue} would yield a color space?
19:33:49 <bluebaron> ski: Ah, okay
19:34:08 <ski> yes
19:34:35 <bluebaron> ski: Is the notion of 'least restricted' well-defined?
19:35:01 <ski> the operations on vectors means that each vector in the free space will be a linear combination of (*finitely* many of) the basis vectors (the inhabitants of `S')
19:35:59 <ski> bluebaron : it is defined in terms of the CT concept of "adjunction". "free" is then defined in terms of that and "forgetful/underlying functor", which *is* a somewhat vague notion, granted
19:36:05 <ski> to have a basis `{v_i}_(i : I)' (a family of vectors `v_i', one for each `i' in an index set `I', satisfying the basis condition) for a vector space `V' *is* (assume `I' is finite with `n' elements, for now) the same as having an isomorphism between `|R^n' and `V'
19:37:33 <ski> in the forward direction, the isomorphism maps a tuple of real coefficients/scalars into the corresponding linear combination of them with the basis vectors `v_i' (for each `i')
19:38:21 <ski> in the backward direction, it maps each vector in `V' to its coordinate tuple, wrt this basis `{v_i}_(i : I)'
19:38:48 <bluebaron> ski: okay, slow down a bit, because I haven't gotten to adjuncts yet in my reading, but you're being super helpful, thanks a lot
19:39:11 <ski> yeah, the adjunction part was an aside, since you were asking about "least restricted2
19:39:14 <ski> "
19:40:16 <ski> in the general case, when `S' need not be finite, one could perhaps write the free vector space as `Free S' (given context that says that we're dealing with a vector space)
19:40:33 <ski> when `S' is finite, with `n' elements, then `Free S' is just `|R^n'
19:41:17 <ski> in general (e.g. when `S' is infinite), `Free S' will be *almost* `|R^S', aka `S -> |R'
19:42:32 <ski> the point is that vector spaces allow multiplying a vector with a scalar, and allows adding zero or two vectors together (in effect, allowing adding any *finite* number of vectors together) 
19:43:24 <ski> so, we're supposed to only "add" the vectors that we can generate from finitely many (or rather finitely deeply nested) applications of operations, from the basis vectors (inhabitants of `S')
19:43:59 <ski> so, we can't add infinitely many basis vectors together in a linear combination (possibly scaled with coefficients), even if `S' contains infinitely many elements
19:44:54 <ski> otherwise stated, we should have a function that for every basis vector in `S' gives a scalar, but only finitely many of the scalars can be non-zero
19:45:31 <ski> that's the set of functions from `S' to `|R', with "finite support". sometimes written as `|R^(S)'
19:47:03 <ski> if you're confused about the general-dimensional case, you can focus on just the finite-dimensional case, where this subtlety doesn't make a difference
19:47:32 <ski> bluebaron : following, sortof ?
19:47:53 <bluebaron> ski: I've been afk for a few minutes, I'm just catching up presently
19:48:24 * ski nods
19:50:39 <bluebaron> ski: As far as I can gather you're stating you can't have vector spaces with infinite components, because it violates the axioms in some way
19:51:13 <ski> well. vector spaces in themselves don't (in general) talk about coefficients
19:51:58 <ski> a vector space is *any* set whatsoever, coming with "scaling" and "addition", sarisfying a couple of laws
19:52:28 <ski> we can only talk about "coefficients" of a vector, *relative* to some particular basis, which we're *given*
19:52:38 <EvanR> whats the definition of an infinite vector
19:52:39 <bluebaron> ski: there's necessarily some notion of dimensionality you can extract from a given law-abiding vector space though, right?
19:53:00 <ski> (and usually, if there's any basis, there's many different bases, giving different coefficients for any single vector)
19:53:33 <ski> (it's important to distinguish clearly between a vector, and a possible coefficient tuple *representation* of it, wrt some particular basis)
19:53:49 <EvanR> the max number of different vectors that are orthogonal
19:53:58 <EvanR> which requires a normed space
19:54:13 <ski> (also, vectors should, in general, not be confused with points. but that's another point)
19:54:16 <EvanR> or err inner product
19:54:56 <ski> bluebaron : depends on whether you believe in the axiom of choice, and which basic logic you use ..
19:55:29 <bluebaron> hoof. I may be getting in over my head here lol
19:55:51 <ski> bluebaron : using classical logic, and axiom of choice, every vector space has a basis. however that does not give any hint of how to find a basis for it
19:56:33 * ski generally prefers using some kind of constructive logic, where a proof of existence gives a method of finding it
19:58:27 <bluebaron> this is unrelated to what we're talking about but arises from the same thing that brought me here: if you had a data declaration like `data Val` with nothing following it, is that valid? Is it analagous to the Void type?
19:58:59 <EvanR> bluebaron: http://i.imgur.com/gfQApHz.jpg
19:59:07 <ski> EvanR : well, afair, the definition of dimension doesn't require considering bases with orthogonal vectors
19:59:49 <bluebaron> EvanR: lol
19:59:52 <ski> bluebaron : yep (with `EmptyDataDecls', not on by default in Haskell2010)
20:00:14 <ski> (er, s/not on/now on/)
20:00:18 <ski> (also goes with `EmptyCase', *not* on by default)
20:00:20 <bluebaron> ski: I see, thanks
20:01:03 <ski> EvanR : hehe
20:02:22 <ski> bluebaron : i could say a little bit about what the adjunction between the free vector space on a set and the underlying/carrier set of a vector space works in practice ..
20:02:58 <ski> bluebaron : but i'd also like to mention a little bit about linear subspaces (sub- vector spaces)
20:03:49 <EvanR> about what the adjunction ... works ?
20:03:55 <EvanR> how
20:04:00 <bluebaron> ski: I appreciate it, but I think your efforts would be wasted--I'm still struggling with the very notion of a free monad, and though I've read more than a dozen different explanations of monads (as is obligatory) and seen them used lightly, I can tell I still don't quite grok it
20:04:07 <ski> s/what/how/
20:04:43 <ski> bluebaron : well, the idea would be to try to tie in to stuff you've already heard about, and hopefully know to some extent
20:05:00 <ski> (that's why i'm talking about vector spaces in the first place)
20:05:19 <ski> we say that `Free' is a functor from `Set', the category of sets (and total functions), to `Vect_|R', or `Vect' for short, the category of linear/vector spaces
20:05:40 <ski> (over scalars from the field `|R')
20:06:26 <bluebaron> ski: I'm just not sure the intuition I built for the course I took on linear algebra is well-suited to understanding proofs about adjoints and such, considering my intuition is firmly rooted in visuals and we were beginning to talk about the logics required to even be able to say something like 'every vector space has a dimension'
20:07:15 <ski> given a set `S', `Free S' is a vector space. also given sets `S' and `T', and a function `f : S >---> T', we can "lift" it to a function `Free f : Free S >---> Free T' (`fmap f', in Haskell notation)
20:07:16 <EvanR> you could use a 2D or 3D vector space over the reals as any visual examples you need
20:07:25 <ski> bluebaron : mhm, ok
20:08:06 <bluebaron> ski: I'm with you so far
20:08:22 <ski> `S' might here be a two-element set, `T' a three-element set. `Free S' is then `|R^2' and `Free T' is `|R^3'
20:09:29 <bluebaron> ski: yes, okay
20:09:39 <ski> `f' could be a particular way to include/identify elements of `S' (informally, "coordinate axes", or "basis vectors of `|R^2'") into `T'
20:10:32 <ski> then `Free f' will tell us how to interpret any vector in `|R^2' as a vector in `|R^3', lying in one of the three possible planes spanned by two of the basis vectors / coordinate axes
20:11:56 <ski> in case `g : T >---> S' maps two of the inhabitants of `T' / basis vectors of `|R^3' to the same in `S' / `|R^2', the remaining one separately (so a projection rather than an injection)
20:12:41 <ski> then `Free g' will tell how to project an arbitrary vector in `|R^3' into `|R^2', according to this specification for how to map basis vectors to basis vectors
20:13:39 <ski> of course, there's many more injections and projections one'd like to consider, than those that are generated by mapping basis vectors to *basis* vectors (rather than mapping them to any arbitrary vectors)
20:13:49 <ski> bluebaron : makes sense ?
20:16:08 <ski> (there's an infinite amount of planes in `|R^3', each of which being a candidate for a particular way of including `|R^2' into `|R^3'. but only three of them are of the form `Free f', for some `f'. six, if we count not just the plane subspaces, but also which basis vector maps to which basis vector)
20:17:50 <iqubic> Is there a way to require a function's input to be a list of a certain length?
20:18:07 <iqubic> Like have a funtion that only takes length 6 lists.
20:18:07 <bluebaron> iqubic: I don't think so, without dependent types
20:18:18 <iqubic> What are dependent types?
20:18:19 <bluebaron> iqubic: But you could use tuples or just plain records
20:18:47 <ski> bluebaron : in any case, returning to the idea of being able to generate injections,projections, indeed any linear transformation, by deciding, for each basis vector in the domain, to which (general, not necessarily basis) vector in the codomain it maps to
20:18:50 <iqubic> Yeah, I'm sure I could. These inputs are all of type Door
20:19:04 <iqubic> where Data Door = Open | Closed
20:19:11 <bluebaron> ski: I'm sorry, I don't get what you mean by `f' could be a particular way to include/identify elements of `S'
20:19:36 <iqubic> And I want a function that will take a large number (known to me) of Doors
20:19:39 <bluebaron> iqubic: If you know for sure you need exactly 6, then records are fine. But it's worth considering why that number is so special
20:19:55 <ski> bluebaron : let's say axes in your two-dimensional space are labeled `a' and `b' (so `S' is the set `{a,b}' then, say)
20:19:59 <EvanR> iqubic: a record, or a new type called Six a = Six a a a a a a
20:20:24 <bluebaron> ski: okay
20:20:34 <EvanR> data Six a = Six !a !a !a !a !a !a ;)
20:20:37 <ski> bluebaron : and the axes of the three-dimensional space are labeled `x',`y',`z' (so `T' is the set `{x,y,z}')
20:20:47 <bluebaron> ski: okay
20:20:47 <iqubic> Yes, but I want the amount of arguments to be varible.
20:20:56 <EvanR> eh?
20:21:13 <EvanR> in what way
20:21:16 <iqubic> I want a way to have a function with a large number of parameters.
20:21:16 <bluebaron> iqubic: What will this function be doing with this strictly-6-in-number doors?
20:21:34 <ski> bluebaron : an element of `Free S', iow `Free {a,b}' is of the form `k_a * a + k_b * b', for some scalars `k_a' and `k_b'
20:21:38 <iqubic> I'll be checking to make sure that all the doors are open.
20:21:43 <ski> and similarly for `Free T'
20:21:53 <bluebaron> iqubic: You can do that for a list of doors, without knowing how many are in there
20:21:59 <iqubic> You can?
20:22:33 <bluebaron> iqubic: If I tell you I have a list of doors, and the first one is closed, do you need to look at the rest to see if they are all open?
20:23:04 <ski> bluebaron : if we define `f' by `f a = y; f b = z', then that determines a particular way of considering `Free {a,b}', basically `|R^2', as being a (planar) subspace of `Free {x,y,z}', basically `|R^3'
20:23:10 <iqubic> bluebaron: No.
20:23:11 <zomg> When I accidentally write a function which directly plugs into foldl - unintentionally - it feels like maybe I'm learning to get better at Haskell lol
20:23:28 <EvanR> iqubic, literally what you asked for is available in packages. search for length-indexed list
20:23:41 <iqubic> Can't I just do "allOpen = all (== Open)"
20:23:54 <iqubic> provided Door derives Ord that is.
20:24:05 <EvanR> you dont need Ord for ==
20:24:13 <iqubic> No, I need eq
20:24:20 <EvanR> and you probably want an isOpen function
20:24:24 <EvanR> all isOpen
20:24:36 <ski> zomg : nice :)
20:24:51 <iqubic> What would isOpen be? "isOpen = (== Open)"?
20:24:55 <EvanR> no
20:24:59 <bluebaron> iqubic: I was leading in to how you could make a recursive function/fold over the list of doors and accumulate a boolean result, but you appear to already understand such things, apologies
20:24:59 <EvanR> defined by pattern matching
20:25:03 <ski>   isOpen Open = True
20:25:12 <ski>   isOpen Closed = False
20:25:49 <ski> (possibly using `_' if you prefer)
20:25:49 <iqubic> Right, and can I use that definition to write allClosed?
20:25:59 <ski> yes, if you want to
20:26:22 <iqubic> How would I use that particular definition of isOpen to write the function allClosed?
20:26:31 <ski> (by defining `isClosed', e.g.)
20:26:56 <EvanR> isClosed = not . isOpen, topologists everywhere groan
20:27:00 <bluebaron> ski: Okay, I get that
20:27:13 <iqubic> EvanR: why do topologist groan at that?
20:27:22 <EvanR> thatd be a side tangent
20:27:23 <bluebaron> iqubic: the concept of clopen
20:27:37 <EvanR> and off topic
20:28:36 <ski> bluebaron : let's say we have a function `f : S >---> Free T'. or `f : {a,b} >---> |R^{x,y,z}'. it tells where, in `|R^{x,y,z}', to map the two axes labelled `a' resp. `b', in `|R^{a,b}'
20:28:45 <iqubic> Ah, I see how clopen works.
20:28:59 <iqubic> My data type is literally a boolean
20:29:34 <iqubic> Wait, can't I just use "Type Door = Bool"? Or is that falling into the boolean blindness trap
20:29:37 <iqubic> ???
20:29:58 <EvanR> you will probably mix up open and closed that way
20:30:23 * EvanR opens the door "sorry the door is already false"
20:30:36 <iqubic> So I should use the data declaration?
20:30:37 <EvanR> "i thought that meant closed"
20:30:54 <EvanR> yes
20:31:20 <bluebaron> ski: got it
20:31:23 <iqubic> EvanR: This is modeling an obscure video game that I like. Using Open and Closed is the best way to illustrate this.
20:31:27 <ski> bluebaron : given this, we can define a function `g : Free S >---> Free T', or `g : |R^{a,b} >---> |R^{x,y,z}', by `g (k_a * a + k_b * b) = k_a * f a + k_n * f b' (for all scalars `k_a' and `k_b')
20:31:46 <iqubic> The game is called DROD. But that's offtopic here.
20:32:00 <iqubic> what's the name of the offtopic chat?
20:32:17 <iqubic> #haskell-offtopic?
20:32:28 <MarcelineVQ> ye
20:32:39 <ski> bluebaron : `g' tells how to interpret an arbitrary vector in `|R^{a,b}' as lying in the (planar) subspace of `|R^{x,y,z}' determined by how `g' maps the basis vectors
20:33:30 <ski> (or, just as lying somewhere in `|R^{x,y,z}' .. but it turns out it lies in such a subspace, which might help your visualization)
20:34:20 <zomg> hmm it seems like there must be some type of algorithm for solving this.. if I have a list of possible actions that can be executed in sequence,  which produce a number, I want to know the best path to the highest number
20:34:36 <zomg> what came to mind was a path finding algo but I don't think that's it because this problem doesn't have a specific goal...
20:34:42 <ski> (well, in case `f' maps `a' and `b' to parallel vectors, then it will be a linear, not planar, subspace. and in case it maps them both to the zero vector, it will be a zero-dimensional subspace, containing just the origin (zero) vector)
20:36:40 <ski> bluebaron : otoh, given `g', we can recover a definition of `f' as `f i = g (1 * i)' for `i' being any element of `{a,b}' (iow a "basis vector")
20:37:43 <anohigisavay> hi. again, i want to ask a basic question about category theory in haskell
20:37:57 <anohigisavay> i'm just reading https://en.wikibooks.org/wiki/Haskell/Category_theory
20:38:18 <ski> bluebaron : in fact, we need not bother with `Free T' as the codomain. we can take *any* vector space `V', and go from a *function* `f : S >---> V' to a *linear transformation* `g : Free S >---> V', and back again (invertible process). we don't need to know a basis of `V' for this to work
20:39:55 <anohigisavay> so given that type Int is an object in Hask category, there needs to be an identity morphism, idInt : Int -> Int
20:40:05 <anohigisavay> but there are millions of such Int -> Int functions
20:40:10 <ski> bluebaron : i'll reformulate this as going inbetween a function `f : S >---> |V|' and a linear transformation `Free S >---> V', `|V|' signifying the "underlying"/"carrier" *set* of vectors in the *vector space* `V'
20:40:24 <ski> anohigisavay : it must satisfy the neutral element laws, wrt composition
20:40:42 <bluebaron> ski: I think I need a break, but I really appreciate the length you've gone to help me with this
20:41:53 <ski> bluebaron : *this* states *exactly* that the functor `Free', and the functor `V |-> |V|', in that order, (one of them being a functor from `Set' to `Vect', the other being a functor in the opposite direction), forms an *adjunction* situation
20:41:57 <ski> bluebaron : ok
20:44:01 <ski> bluebaron : in the case of free vector spaces, there being an adjunction states exactly that a linear transformation *from* a free vector space (or, if you prefer, a vector space with a given basis) is determined by where it maps the basis vectors, and this set function mapping the basis vectors can be any old function, no restriction
20:44:09 <ski> i'm done
20:53:11 <dfeuer_> Why does lens depend on parallel?
20:53:48 <glguy> To provide Control.Parallel.Strategies.Lens
20:56:20 <glguy> I did a pass of clearing out unnecessary dependencies a few years ago, I don't remember if it was a conscious choice to leave that one behind or if I just overlooked it
20:57:28 <dfeuer> glguy: ah.
20:57:39 <dfeuer> Whatever that's for...
20:57:46 <dfeuer> (Never noticed it)
21:06:44 <glguy> dfeuer: It would be interesting to know if that module has even been imported on hackage
21:08:31 <dfeuer> glguy: that's the sort of question I have no clue how to answer.
21:08:42 <dfeuer> Also, whether it's been used in applications not on Hackage....
21:10:30 <kadoban> "Little Lens Starter Tutorial" sure does a lot of apologizing about lens ...
21:11:40 <Zemyla> Why is there no Lensable class?
21:12:17 <Zemyla> class Traversable f => Lensable f where traverseOnly :: (Functor g) => (a -> g b) -> f a -> g (f b)
21:16:30 <nshepperd> such a class would assure that values of the type contain exactly one value of its type argument
21:18:10 <nshepperd> idk, i can't really see what it would be good for
21:31:05 <dfeuer> Zemyla: good question. Is there such a thing in lens?
21:31:12 <dfeuer> Or somewhere?
21:31:24 <dfeuer> That's a pretty cool class....
21:32:00 <c_wraith> eh.  Traversable being compatible with lenses is sort of a case of convergent evolution.
21:32:20 <c_wraith> They came out of very different places.
21:35:05 <Zemyla> c_wraith: It's not really an accident, though. With an applicative, you visit and replace 0 or more `a` values; with a Functor, you visit exactly one.
21:35:42 <nshepperd> imo, the fact that the data type must contain one of its type argument kind of limits the applicability of such a type class, so you probably wouldn't write that much Lensable generic code
21:35:45 <nshepperd> but who knows
21:36:18 <nshepperd> its existence sort of makes sense though
21:37:02 <c_wraith> Zemyla: that's not the "weird" part.  The "weird" part is that they both use the exact same function representation. (Not really *that* weird because of how useful that form is - but it was approached from entirely different angles with different goals)
21:37:45 <nshepperd> it's a majestic mathematical miracle
22:00:08 <wilornel> Hey #haskell! I don't understand this Combine: http://paste.ubuntu.com/24854707/
22:00:50 <glguy> wilornel: thing is that S.Semigroup a is unused
22:00:54 <glguy> first thing*
22:01:11 <glguy> second thing is that it's using the Semigroup instances on functions, so check that one out in the haddocks
22:13:52 <xormor> I am more of a geek than a nerd. Haskell is difficult for me to understand.
22:14:02 <xormor> I understand a bit...
22:14:17 <xormor> let triple x = x * 3
22:14:19 <xormor> right?
22:14:48 <glguy> xormor: You can try stuff like this in your local GHCi to see if it does what you expected
22:15:02 <xormor> triple 3 = 3 * 3 = 9
22:15:15 <xormor> glguy, yes. I did it last night.
22:33:24 <boj> i'm trying to build a stack project under nixos and the stack --nix tooling. unfortunately one of the libraries depends on terminfo, and the build is failing due to not being able to find the native curses bindings. anyone experienced this before and have any tips?
23:03:56 <Koterpillar> Is there something like yieldMany that returns the count of yielded items? I want to avoid forcing the whole list
23:06:14 <c_wraith> Koterpillar: conduit?
23:06:30 <Koterpillar> yes
23:07:15 <c_wraith> is yieldMany defined somewhere? I don't see it
23:07:32 <Koterpillar> http://hackage.haskell.org/package/conduit-combinators-1.1.1/docs/Conduit.html#v:yieldMany
23:07:42 <Koterpillar> you get that if you import just Conduit
23:08:09 <c_wraith> not if you install just conduit. :P
23:09:19 <Koterpillar> Indeed, conduit's readme refers to it though, which was puzzling for a while
23:12:10 <c_wraith> it looks like there isn't something that does that, though it should be easy enough to write one.
23:13:09 <Koterpillar> I suppose I can feed the stream into lengthC
23:14:40 <c_wraith> ok, after looking at the implementation of yieldMany, that's probably easier. :)
23:15:57 <Koterpillar> …but I'll lose the original stream. ZipSink looks like it might be useful, but doesn't match exactly this task
23:16:30 <Koterpillar> generally I think conduit tends to ignore upstream results (rightfully - they might be terminated before the end)
23:17:02 <cocreature> writing a custom version of yieldMany doesn’t seem so bad
23:17:27 <c_wraith> it does if you want to keep the fusion optimizations...
23:17:50 <cocreature> oh right I missed that
23:18:27 <c_wraith> yeah, I did too
23:20:14 <cocreature> I really hate seeing C macros for more than ifdefs in Haskell code
23:24:44 <lambdamu> boj: In case it's still relevant: I have nix: packages: ncurses in my .stack/config.yaml, I don't use stack anymore but there is a comment that it had something to do with terminfo, maybe that helps
23:24:46 <qmm> is there a recommended way of using another package that you are working on without needing to commit the latest changes to hackage?
23:25:20 <qmm> i was thinking of maybe using a submodule and even tried using it, but i don't know how to import files from the submodule into my project
23:25:58 <lambdamu> qmm: with stack that is easy or do you use plain cabal?
23:26:32 <qmm> stack is fine
23:27:29 <qmm> lambdamu: how would you do that?
23:27:49 <qmm> i have a cabal sandbox as well. i'm currently unsure which i want to use 
23:28:56 <lambdamu> qmm: packages: location: ../your/path in your stack.yaml
23:29:08 <boj> lambdamu: i'll give that a shot, thanks
23:29:32 <lambdamu> qmm: Something like that
23:31:57 <lambdamu> qmm: https://docs.haskellstack.org/en/stable/yaml_configuration/#yaml-configuration in case my botched yaml isn't too instructive
23:32:09 <qmm> it was perfectly fine
23:32:16 <qmm> thank you for assisting me
23:36:24 <sordina> Hey Haskellers
23:36:43 <sordina> If anyone is interested in speakng at Compose :: Melbourne, we've opened our CFP
23:36:52 <sordina> http://composeconference.org/2017-melbourne/cfp
23:37:07 <sordina> Also... Anyone want to talk about list predicates in lenses
23:37:20 <sordina> Because I want some kind of 'p_traverse' function
23:37:38 <sordina> that provides a traversal for items that match a predicate
23:37:58 <sordina> Possibly this already exists, or is easy to create from existing traversals and prisms somehow?
23:39:15 <Cale> https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:filtered
23:39:30 <sordina> E.g. `over (ptraverse ((== 8) . fooid)) . _Left) (+ 1)
23:39:43 <cocreature> qmm: you can also tell stack to fetch a package from a git repo https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
23:39:47 <lambdamu> sordina: I don't think it is possible without degenerating to a Fold
23:40:06 <sordina> Cale: Thanks!
23:40:33 <Cale> sordina: The thing is that you might do something to the elements which are being traversed that invalidates the predicate
23:41:11 <sordina> Cale: That is true... theoretically problematic, but shouldn't matter for my usecase
23:41:16 <lambdamu> sordina: There is elements/elementsOf for IndexedTraversals but the predicate takes the index not the value
23:41:55 <sordina> lambdamu: Yeah, looked into that. Definitely need a predicate over the value
23:42:02 <sordina> I'll try out filtered
23:42:51 <Cale> Worth a shot, but this is the kind of thing where I usually don't regret skipping out on using lens.
23:43:42 <zomg> quchen: btw your suggestion about DataKinds worked. Although I don't think I fully understand it, I got it to do what I wanted, although it's now being a bit annoying otherwise (probably because I don't fully understand how to utilize that particular feature)
23:45:05 <quchen> zomg: :-) I had to leave right after I suggested it, glad you could make something useful with just that one-liner
23:45:49 <qmm> how do you access the src/ModuleName.hs of a project that is a git submodule and added to teh stack.yaml packages?
23:46:58 <Koterpillar> qmm: import ModuleName, provided it's exported in the submodule's cabal file, and you added it to your main cabal file
23:47:04 <cocreature> qmm: add the package to the build-depends of your project and then import ModuleName
23:47:13 <zomg> quchen: yeah it took some doing and then it accidentally started working, so... :P
23:47:29 <zomg> literally as I was about to say fuck it
23:47:30 <zomg> :D
23:48:40 <zomg> Now it's a bit like "well this particular data type has this interesting property, but none of the code really makes any use of it"
23:49:03 <zomg> but at least I'm a bit closer to understanding GADTs as well now :P
