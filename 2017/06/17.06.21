00:00:12 <centril> cocreature: oh... my top binding is a LambdaCase - i dont litter one function definition with many LambdaCase:s
00:00:16 <quchen> jared-w: Ah, you‚Äôre the HSOC student, right?
00:00:22 <quchen> I thought I recognized your name somewhere
00:00:29 <cocreature> quchen: dunno, "go c = case c of" doesn‚Äôt seem that much worse but don‚Äôt let me stop you :)
00:00:44 <quchen> cocreature: Agreed
00:00:48 <centril> cocreature: go = \case  - point free heaven
00:01:28 <quchen> Pointfree zealotry!
00:01:44 <centril> is nice!
00:02:08 <cocreature> I guess I‚Äôm just not a fan of adding too much builtin syntactic constructs and for me personally, the costs of adding yet another syntactic construct outweighs the benefits of LambdaCase 
00:02:39 <quchen> ?tell bollu Trifecta and Optparse-Applicative are probably the two major bottlenecks on the way to global prettyprinter adoption; unfortunately, there is no clean way to write an ansi-wl-pprint->anything adaptor :-/
00:02:39 <lambdabot> Consider it noted.
00:03:14 <centril> cocreature: what's the cost? does anyone use anything but GHC, and hasn't LambdaCase been around for a long time?
00:03:18 <jared-w> quchen: o snap I've been found. Yeah, I'm one of the HSOC students
00:03:24 <quchen> I think it‚Äôs straightforward and a useful syntactic addition; it doesn‚Äôt hide complexity, its meaning is immediately obvious
00:03:35 <centril> quchen: agreed
00:03:41 <cocreature> centril: it‚Äôs yet another thing you need to learn when you‚Äôre new to the language
00:03:41 <centril> and TupleSections
00:03:51 <ventonegro> Incidentally all these syntactic extensions would be simple macros in a Lisp language, but you already know that
00:03:57 <quchen> List comprehensions are much tougher in that regard, and do-notation as well while we‚Äôre at it
00:04:18 <halogenandtoast> looks like I can do this, but maybe it's not the best:        ereq <- liftIO (try $ parseRequest (T.unpack url) :: IO (Either SomeException Request))
00:04:24 <centril> cocreature: oh, I don't teach it to new hasklers ;) you've got to gradually ease people in
00:04:24 <quchen> ventonegro: Between macros and a type system, I‚Äôll take the latter, thanks
00:04:52 <centril> List comprehensions... now that's a feature I can be w/o
00:05:03 <jared-w> Honestly, list comprehensions feel way hackier than most of the other "alternative syntax" addons
00:05:13 <cocreature> centril: that doesn‚Äôt help if people start reading the source of libraries on hackage or wherever
00:05:20 <ventonegro> quchen: I didn't try to convince you otherwise, that's why I said "Incidentally..."
00:05:38 <cocreature> anyway, I don‚Äôt think we‚Äôre going to agree here, so I‚Äôll shut up :)
00:05:48 <quchen> Incidentially, most Lisp macros are simple functions in Haskell :-√æ
00:06:04 <centril> cocreature: new students should probably not throw themselves into library code on hackage... unless they fancy reading Lens, State/Reader/Except monad stacks, etc
00:06:07 <jared-w> ooohh #fite
00:06:18 <ventonegro> quchen: Yeah, but as I said, not these syntactic extensions
00:06:23 <jared-w> I like syntax extensions that add uniformity to what you should be expecting.  TupleSections are a great example of that
00:06:27 <quchen> That‚Äôs right, yeah.
00:06:36 <jared-w> OverloadedStrings is another one
00:06:40 <centril> why isn't it part of the standard yet?...
00:06:42 <quchen> Idris goes a bit further in that direction with its DSL syntax, but I‚Äôm not sold on that yet
00:06:55 <Axman6> imo, lambdacase is one of those things that people eventually run into wanting all the time, and the extension is minor enough and trivial to understand that people should feel fine using it
00:07:17 <centril> At some point, these extensions should get "merged" into the language
00:07:21 <centril> i.e... haskell report
00:07:36 <jared-w> centril: pretty much nothing is part of the standard because the standard isn't going to be updated until the next haskell report in like 2020 or something
00:07:47 <cocreature> I don‚Äôt get what the point of the haskell report is at this point.
00:07:52 <centril> cocreature: idd
00:08:00 <jared-w> For a language that feels like it's rapidly evolving, Haskell "itself" moves at a glacial speed :p
00:08:02 <Axman6> "I'm writing \x -> case x of ... all the time, is there a better way?" I used to have this thought a lot (though actually almost never use LambdaCase ü§î)
00:08:34 <centril> GHC should perhaps just unilaterally add things to the "standard"
00:08:53 <quchen> ‚Ä¶working on that‚Ä¶
00:08:56 <Axman6> "Haskell is not <this> this week" - So says SPJ
00:08:58 <centril> meaning that you don't have to do  {-# LANGUAGE ... #-} anymore
00:09:14 <cocreature> there is not any significant compiler apart from GHC atm and current Haskell code is very much written for GHC instead of the standard. you can either augment the standard making it even more unlikely that we‚Äôll get another Haskell compiler or we can just accept that Haskell is GHC Haskell and ignore the standard.
00:09:40 <centril> cocreature: ignore! ignore! ignore! :P
00:10:05 <jared-w> idk, I feel like the standard is very important for the fact that haskell is originally designed to be a research language. A full formal standard is imperative in that regard
00:10:26 <centril> jared-w: then the standard needs to move faster
00:11:00 <centril> jared-w: btw... list comprehensions feel yucky because they are antithetical to compositional programming
00:11:05 <quchen> cocreature: Counterargument, being in the standard means everyone may use it without questioning. PatternGuards are just there, while BangPatterns are not; the latter is therefore seen as ¬ªexperimental¬´ and avoided by some.
00:11:24 <quchen> cocreature: ¬ªWhich extensions are safe to use¬´ is a standard beginner question.
00:11:31 <jared-w> Also, there's definitely a lot of stuff that I /don't/ want in the standard right now
00:11:32 <quchen> Well, advanced beginner.
00:11:59 <cocreature> quchen: oh I‚Äôm not saying that we shouldn‚Äôt enable some extensions by default. I‚Äôm saying that we don‚Äôt need to update the standard to do so
00:12:13 <jared-w> UndecidableInstances, IncoherentInstances, DataKinds, TypeInType, RankNTypes. Can you imagine how ridiculous it would be if we just turned all of those on at once and baked it into the standard?
00:12:14 <centril> quchen: >> "What I wish I knew when learning haskell" >> http://dev.stephendiehl.com/hask/#the-dangerous
00:12:15 <cocreature> GHC is already deviating from the standard
00:12:25 <quchen> Meh, GHC strives to be a compiler for exactly Haskell
00:12:42 <quchen> So this time GHC is ahead of the standard, but wants to adhere to it again
00:12:50 <jared-w> Right, and it does so through pragmas. The pragmas are experimental features that may hopefully be merged into "real haskell"
00:12:51 <Geraldus> Hi folks!
00:13:07 <cocreature> quchen: I don‚Äôt see that. it seems more like people want the standard to adhere to GHC.
00:13:08 <quchen> The deviations are fairly minor, really. AMP, FTP, and the operator section business are all the things I can think of.
00:13:10 <centril> jared-w: im mostly saying that the syntactic extensions that are popular should beenabled by default
00:13:26 <jared-w> centril: which is fair. I think the problem is best solved by tooling, honestly.
00:13:44 <jared-w> We already practically cargo cult using Stack at this point
00:13:48 <quchen> cocreature: The standard has to be explicit about what it means. We can‚Äôt just say ¬ªlike what GHC does¬´ in there. Formalizing some things is very hard, if not impossible.
00:14:10 <quchen> Oh, and Num‚Äôs superclasses are also nonstandard right now.
00:14:16 <jared-w> Shouldn't be too hard to adopt a "thou shalt use this stack template which fixes the prelude, turns on some sane defaults, ..." etc
00:14:17 <centril> jared-w: I don't feel the tooling is lacking... I start writing, ghci refuses my code, says I need an extension, I add the extension, done...
00:14:35 <quchen> jared-w: That‚Äôs not what cargo cult means.
00:14:57 <centril> cargo cult ==> #rust
00:15:02 <quchen> Using Scrum because you‚Äôve read that it works on Hackernews, that‚Äôs cargo cult.
00:15:04 <cocreature> quchen: sure, I‚Äôm not saying that we shouldn‚Äôt aim for formal specs either. but I think of a standard as a fixed document which changes every 5 years at best and that just doesn‚Äôt seem useful. I‚Äôd rather have formal (or at least somewhat formal) specs for what GHC implements than for a hypothetical language that I‚Äôm not writing
00:15:20 <Geraldus> Looking at Persistent's `upsert` docs I think there is a typo.  Both `upsert` and `upsertBy` description say about uniqueness constraint.  But I bet the first one does not have such constraint.
00:15:29 <centril> cocreature: 5 year plans :P
00:15:44 <quchen> cocreature: That would be nice to have, yeah. Maybe to foreshadow the next Report even.
00:15:47 <jared-w> Cargo culting can be defined as the ritual inclusion of program structures blindly without understanding the reasons behind it, can it not?
00:16:34 <quchen> I don‚Äôt have windows in my house for cargo cult reasons, and likewise I use stack because it works really well.
00:16:36 <centril> jared-w: what is wrong with enabling DataKinds by default... ?
00:16:56 <quchen> Aaanyway, let‚Äôs not argue about tooling.
00:17:01 <quchen> Or culting.
00:17:17 <quchen> Back on topic: MultiWayIf is cool! :-)
00:17:25 <centril> Also... TypeFamilies, MultiParamTypeClasses, ...
00:17:36 <jared-w> centril: nothing. It just makes things even messier when you add in all the other dangerous extensions I put in the list. Plus, it's not something I would want in the standard at all because it's likely going to be usurped by Dependent Haskell
00:17:50 <centril> jared-w: right
00:17:53 <centril> i buy that
00:18:52 <centril> quchen: MultiWayIf is a bit meh... I very seldom find myself in a situation where I have more than 2 choices and it does not involve pattern matching
00:18:52 <jared-w> in general, if I can look 5-10 years in the future and see a pragma being "undone" or depreciated by a better/superior solution, I don't really want it in the standard. Hard enough to fix the mistakes we've already made without adding new ones
00:19:00 <centril> if it involves pattern matching, just ==> LambdaCase
00:19:18 <quchen> centril: You can pattern match in multiwayif ;-P
00:19:26 <jared-w> Small things like multiWayIf? pfh, sure, add it in.
00:19:43 <quchen> centril: I agree that it‚Äôs not useful that often, but when it is, it is very much so
00:19:49 <centril> quchen: I want  LambdaMultiWayIf  :P
00:20:04 <quchen> \if was discussed at some point already :-)
00:20:05 <jared-w> That being said, I do like to be careful with syntax because I think that syntax, notation, symbols, etc., are all very powerful tools of thought; I prefer to use the most efficient tools possible
00:20:09 <quchen> (Together with \case)
00:20:34 <centril> jared-w: Wadler's law!
00:22:22 <centril> "In any language design, the total time spent discussing a feature in this list is proportional to two raised to the power of its position. 0. Semantics 1. Syntax 2. Lexical Syntax 3. Lexical syntax of comments
00:23:35 <jared-w> Sounds about right
00:23:35 <systemfault> Might seem like a weird question but... Is there an extension that would allow me to put constraints on "data" declarations?
00:23:51 <centril> systemfault: GADTs
00:24:05 <jared-w> systemfault: what kinda constraints? Like restricting Int to be only positive numbers?
00:24:43 <quchen> systemfault: You can do it, but it‚Äôs not a good idea, so I forgot how to do it.
00:24:46 <Axman6> you can put constraints on data declarations, but you usually don't want to do this (GADTs make this not painful though)
00:25:03 <systemfault> data Foo x = Foo x .. where x should have some constraints... like Show for example
00:25:06 <centril> doing it with GADTs is fine, the other way is not so fine
00:25:08 <Axman6> data Foo a = Show a => Foo Int a works IIRC, but you don't want it
00:25:10 <jared-w> The idiomatic way to do it in haskell is to use smart constructors, I believe. Took me a bit to get used to it
00:25:28 <centril> ye, don't do what Axman6 said
00:25:31 <quchen> The idiomatic way is to not do it :-√æ
00:25:42 <systemfault> Hmm, so would you use smart constructors or GADTs?
00:25:46 <Axman6> the reason you don't want it is that every single function that uses Foo also needs a Show a constraint, even if it never calls any function from Show
00:26:04 <Axman6> systemfault: yep, those are both better alternativeds
00:26:05 <quchen> :t Data.Set.singleton id
00:26:06 <centril> systemfault: it depends ... do you have a lot of constructors? then use GADTs
00:26:07 <lambdabot> S.Set (a -> a)
00:26:11 <Axman6> s/ds/s
00:26:15 <quchen> That wouldn‚Äôt be possible if Set had an Ord constraint.
00:26:41 <centril> quchen: what is the point of constructing a non-ord Set?
00:26:50 <jared-w> Sets aren't ordered by nature
00:26:57 <Axman6> With GADTs, you can write data Foo a where Foo :: Show a => a -> Foo a
00:27:10 <quchen> The point is more that to construct a singleton set the type tells you that none of the ordering functions will be called.
00:27:20 <jared-w> A better question would be what's the point of constructing a Set that is Ordered? It's no longer a set
00:27:27 <quchen> Like a function with Applicative tells you there won‚Äôt be any binds used.
00:27:39 <systemfault> Interesting, I'll read about GADTs but from what I've just read, I should use a smart constructor if it does the job
00:27:41 <Axman6> (tangent, does this work because the Foo constructor carries the Show a constraint with it, and it is therefore in scope when pattern matching?)
00:27:57 <centril> systemfault: it depends... what is your domain? a DSL?
00:28:13 <systemfault> centril: A DSL
00:28:26 <centril> systemfault: using GADT:s can make pattern matching more exact because the type system can rule out certain impossible cases
00:28:27 <Cale> Axman6: Yeah, it implicitly packs the dictionary for Show a along with the data
00:28:34 <Cale> Axman6: and then unpacks it when matching
00:28:44 <centril> systemfault: is it an AST for a language perhaps ?
00:29:09 <Cale> Axman6: and thankfully, because instance resolution is coherent, you don't need to care which dictionary you're getting
00:29:20 <centril> and how much are you going to do tree-traversal with pattern matching... ?
00:29:21 <Axman6> Cale: I was reading http://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html the other day which lead me to understand that (but wanted to make sure that's actually what's going on)
00:29:26 <halogenandtoast> If anyone is feeling generous and wants to offer some refactoring suggestions: https://gist.github.com/halogenandtoast/c426b607eb810143884b30bdcf39aad1
00:29:41 <systemfault> centril: I have that idea of writing a asm DSL for a cpu emulator
00:29:44 <Axman6> which lead me to that udnerstanding*
00:29:51 <systemfault> centril: I'm not sure yet of what I want.
00:30:35 <boj> vvintnbcbfvkhniucfhkvrhjteguidhtnhbnhdebdtdc
00:30:37 <centril> systemfault: i'd call it an AST/language then, but quite a flat one
00:30:39 <boj> vvintnbcbfvkfbnkbhkhiugtuebdvkdhivgdjrdieikh
00:30:49 <boj> sigh
00:30:51 <systemfault> Cat alert?
00:30:55 <boj> sorry
00:31:05 <Axman6> systemfault: GADTs could be very useful there - you could use them to ensure that instructions are passed registers which are the same size, where that size is determined by some type class
00:31:13 <Axman6> boj: time to change dem passwords ? :P
00:31:23 <centril> Axman6: good point
00:31:30 <boj> just one time yubikey passwords, so no problem :P
00:31:40 <centril> systemfault: go for GADTs... you'll also learn in the process, which is always nice
00:31:56 <jared-w> I cry every time I see multiple nested do's with tons of lets and such. I know that it's necessary sometimes but it always looks absolutely ugly to me
00:32:03 <Axman6> boj: interesting - do they usually start with the same prefix?
00:32:13 <centril> jared-w: its never necessary...
00:32:15 <boj> Axman6: apparently so
00:32:18 <systemfault> centril: Thank you :)
00:32:43 <centril> jared-w: given that you can always extract things to a top level function and take stuff in as parameters
00:32:44 <jared-w> boj: I think they're seeded from something? Because the same prefix isn't /that/ long
00:33:16 <Axman6> might be an encoded timestamp or something, allowing systems to sync up
00:33:17 <boj> i honestly don't remember what occurs there anymore
00:33:34 <boj> note to self, detatch key from vm before using
00:33:45 <jared-w> centril: True, they're never necessary. Sometimes you want to have an internal function so something isn't exposed, but since you can just export only specific functions in a module... I don't even really see a large need for more than the simplest internal functions
00:34:16 <jared-w> halogenandtoast: what does your "boardy" function do?
00:34:24 <centril> halogenandtoast: my eyes... you should order imports by package, as in base, etc... and separate them with a newline
00:34:35 <centril> jared-w: I always use modules for controlling exports, never functions..
00:34:46 <centril> large functions harm testability
00:35:02 <centril> and where clauses can't be tested
00:35:19 <halogenandtoast> jared-w: SlackBox () is a type alias it basically takes an Event and performs some operation
00:35:39 <halogenandtoast> type SlackBot s = Event -> Slack s ()
00:35:49 <halogenandtoast> centril: will fix
00:35:51 <jared-w> I agree, centril. I've gotten a lot more aggressive about refactoring out my functions as I've gotten better at Haskell
00:35:53 <centril> halogenandtoast: so it is a reader monad
00:36:09 <centril> or almost
00:36:10 <jared-w> except it looks like it's doing about 20 things...
00:36:32 <centril> halogenandtoast: let format = "<@" <> bid <> "> " can be moved to a top level function
00:36:43 <jared-w> Set bid, format things, logic branching...
00:36:50 <halogenandtoast> centril: by separate them with a newline do you mean the qualified vs unqualified
00:36:58 <halogenandtoast> jared-w: bid is bot_id
00:37:06 <halogenandtoast> for slack
00:37:20 <centril> halogenandtoast: all imports
00:37:22 <centril> sec
00:37:30 <jared-w> I'm aware. You're still doing a /lot/ in your function
00:38:09 <jared-w> it's like a black hole of code that tells me nothing about what it's actually supposed to be doing because every other line is all about the imperative details
00:38:57 <halogenandtoast> jared-w: I'll work on that.
00:39:09 <jared-w> I'm almost positive boardy can be written in about 4-5 lines of code after you finish refactoring out every separate "thing" into its own function.
00:39:47 <jared-w> halogenandtoast: are you aware of the Unix philosophy? I find it's also really relevant and useful for functional programming
00:40:20 <centril> halogenandtoast: here's how I do it... https://github.com/Centril/repisodes/blob/master/Repisodes.hs
00:40:55 <jared-w> centril: very pretty
00:41:04 <halogenandtoast> jared-w: yes, sorry, I should have spent some time refactoring before actually asking, I simply got it working and asked prematurely
00:41:31 <jared-w> halogenandtoast: no problem. You asked for feedback for refactoring suggestions and you got a few :)
00:41:48 <jared-w> we're not trying to chew you out, you haven't done anything wrong
00:41:52 <halogenandtoast> jared-w: yup I'll start extracting and see if I run into  specifics
00:42:10 <centril> halogenandtoast: consider this... every part that is a small little box that does not depend on a lot of other stuff can be extracted
00:42:13 <halogenandtoast> I'm mainly concerned about the layered "return ()"
00:42:21 <centril> concern yourself with small logical units
00:42:36 <centril> halogenandtoast: oh, and never use return, always use pure
00:42:53 <halogenandtoast> centril: ok
00:43:01 <ventonegro> Why are both the bang and `seq` needed here? `force mx = do !x <- mx; x `seq` return x`
00:43:18 <jared-w> A general hint would be a) think about the Unix philosophy and how to apply it. b) every let is probably a function waiting to be made.
00:43:24 <Axman6> the should be
00:43:25 <quchen> ventonegro: That‚Äôs redundant.
00:43:48 <centril> ventonegro: i dont know, i copied it from deepseq / strict IO
00:43:59 <riaqn> Hi I'm using attoparsec to parse network protocols, what would be a good counterpart to encode?
00:44:04 <ventonegro> quchen: Thanks!
00:44:07 <ventonegro> centril: ah ha
00:44:17 <phadej> riaqn: bytestring's Builder
00:44:31 <centril> ventonegro: well, isn't that what you need to do to fully normalise a term?
00:44:33 <halogenandtoast> centril, jared-w I'll refactor and ping you, see if I can make you guys proud (not sure about the imports though :p)
00:44:41 <quchen> halogenandtoast: http://lpaste.net/7171335932405088256
00:45:18 <riaqn> phadej: great. I assume it's comparably fast to attoparsec?
00:45:28 <centril> halogenandtoast: oh also... now i noticed, you are not using Either as a monad
00:46:02 <ventonegro> centril: `seq` only gives you WHNF, but if you already used the bang...
00:46:11 <halogenandtoast> centril: ?
00:46:24 <centril> halogenandtoast: you have nested case analysis on Right
00:46:29 <centril> use Either as a monad instead
00:46:37 <centril> ventonegro: bang reduces term to ?
00:46:40 <centril> NF ?
00:47:06 <quchen> WHNF.
00:47:09 <ventonegro> "Matching an expression e against a pattern !p is done by first evaluating e (to WHNF) and then matching the result against p."
00:47:14 <ventonegro> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/bang-patterns.html
00:47:46 <quchen> f !x = e  ====  f x = x `seq` e
00:47:48 <jared-w> halogenandtoast: http://lpaste.net/356393 for your imports
00:48:24 <centril> ventonegro: so, force is supposed to evaluate the term to NF, .. does it?
00:49:07 <jared-w> centril: are those better imports? :p
00:49:08 <centril> jared-w: i'd explicitly import every needed function
00:49:26 <ventonegro> centril: Doesn't look like it, although I'm hardly an expert on lazyness
00:49:31 <centril> and put a new line between each package, and say which package it is from
00:49:33 <jared-w> oh, fair. That's really the smart way to do it, especially for more "professional" code
00:49:36 <ventonegro> Oh wait, maybe I am... :D
00:49:58 <MarcelineVQ> explicit imports are great because you can see right away what's in scope in a given module, and where it's coming from
00:50:15 <centril> :t rnf
00:50:16 <lambdabot> NFData a => a -> ()
00:50:26 <centril> ventonegro: so rnf reduces the argument to normal form
00:50:31 <jared-w> I just went through and formatted their import list with stylish-haskell. Didn't actually look at it super hard :p
00:50:39 <halogenandtoast> jared-w: I'm anti extra whitespace
00:50:45 <halogenandtoast> creates noisy diffs
00:50:52 <centril> halogenandtoast: then skip that part =)
00:51:01 <ventonegro> readability >>> diffs
00:51:19 <halogenandtoast> ventonegro: the extra white space actually makes it harder for me personally to read
00:51:31 <riaqn> BTW, seems the binary package(Binary typeclass) is not very popular for encoding nor decoding?
00:51:32 <ventonegro> halogenandtoast: I see
00:51:35 <centril> ventonegro: deepseq a b = rnf a `seq` b
00:51:41 <centril> :t deepseq
00:51:42 <lambdabot> NFData a => a -> b -> b
00:51:52 <centril> :t force
00:51:53 <lambdabot> NFData a => a -> a
00:51:57 <jared-w> halogenandtoast: the white space makes it way easier for me to read, but that's because I'm used to it. It's just the standard output of stylish-haskell. Left aliging the text is still a big improvement over your old import list
00:52:04 <centril> force x = x `deepseq` x
00:52:27 <halogenandtoast> jared-w: while I'm not dyslexic it's actually pretty common for those with dyslexia to find that harder to read too, they get caught in the "rivers"
00:52:33 <halogenandtoast> At least I hope I'm not dyslexic.
00:52:55 <ventonegro> > :t deepseq <$> putStr
00:52:57 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
00:53:12 <ventonegro> :t deepseq <$> putStr
00:53:14 <lambdabot> error:
00:53:14 <lambdabot>     ‚Ä¢ No instance for (NFData (IO ())) arising from a use of ‚Äòdeepseq‚Äô
00:53:14 <lambdabot>     ‚Ä¢ In the first argument of ‚Äò(<$>)‚Äô, namely ‚Äòdeepseq‚Äô
00:53:25 <ventonegro> :t deepseq <$> getLine
00:53:26 <jared-w> Dyslexia is on a spectrum, like most learning disorders. It's quite common to have "some level" of something, even if it's not severe enough to actually disrupt your life
00:53:26 <lambdabot> IO (b -> b)
00:53:38 <centril> rnf !_ = ()
00:54:28 <centril> deepseq !a b = () `seq` b
00:55:30 <ventonegro> :t force <$> getLine
00:55:31 <lambdabot> IO String
00:55:35 <ventonegro> hmmmm
00:55:42 <centril> so, force mx = do !x <- mx; x `seq` return x  should reduce x to NF
00:55:58 <centril> since it follows the logic of rnf + deepseq... I think...
00:56:04 <Cale> ventonegro: What's up?
00:56:29 <ventonegro> Cale: trying to come up with something that forces IO actions
00:56:30 <centril> NF / WHNF is deeply confusing
00:56:31 <MarcelineVQ> where is that defintion of force?
00:56:47 <centril> MarcelineVQ: https://github.com/Centril/repisodes/blob/master/Repisodes.hs
00:56:55 <Cale> ventonegro: The actions themselves, or their results?
00:56:56 <centril> https://github.com/Centril/repisodes/blob/master/Repisodes.hs#L66
00:57:05 <ventonegro> Cale: results
00:57:10 <jared-w> centril: what do you have against $?
00:57:11 <MarcelineVQ> oh you wrote it?
00:57:31 <halogenandtoast> centril: to use Either as a monad would I need to do runEitherT or something like that?
00:57:35 <centril> MarcelineVQ: well, I copied it somewhat from http://hackage.haskell.org/package/strict-io-0.2.1
00:58:00 <Cale> centril: It's not that complicated. An expression is in normal form if either it is a data constructor applied to expressions in normal form, or it is a lambda whose body is in normal form.
00:58:04 <centril> halogenandtoast: no, just use the monad and then match on Right at the end
00:58:24 <Cale> centril: An expression is in weak head normal form if it is a data constructor applied to any expressions at all, or if it is a lambda.
00:59:44 <Cale> The former is a more important concept from a theoretical perspective (discussing things like termination of classes of programs), the latter is more important for discussing real-world evaluators, because WHNF is all you need in order to be able to match a pattern.
00:59:47 <centril> Cale: I get that part, but taking that and understanding how rnf, deepseq, force works is more difficult
00:59:54 <Cale> ah
01:00:34 <EvanR> these dependent haskell examples are kind of amazing... they end up being simpler than other dependently typed languages... and now, with even more invisible stuff going on, the less i expect people to understand what the heck is going on when the first check it out
01:00:45 <centril> so, rnf !_ = () , how does _ get evaluated to NF?
01:01:00 <jared-w> EvanR: any examples in particular that you're thinking of?
01:01:00 <Cale> deepseq/rnf are meant to evaluate not *really* to normal form, but only through multiple constructors
01:01:15 <Cale> (i.e. it'll be normal form if we ignore the bit about lambda)
01:01:28 <EvanR> the verified STLC with small step evaluator checked against the big step evaluator
01:01:42 <EvanR> all verified because their types encode the laws of STLC
01:01:45 <centril> Cale: oh, so it is simply getting rid of multiple layers of "cons" i.e, remove one "WHNF", then another, etc. ?
01:02:05 <centril> if we see things as a list...
01:02:10 <Cale> centril: Evaluate the top level to whnf, and then each of the arguments of the constructor, and so on.
01:02:15 <EvanR> Cale: and Void
01:02:34 <Cale> EvanR: what about Void?
01:02:54 <EvanR> its an instance of NFData, implying Voids have a normal form
01:03:17 <Cale> That's fine
01:03:27 <EvanR> i know we discussed it earlier
01:04:09 <centril> Cale: so   force  (1 : 2 : 3 : []) = 1 : 2 : (3 : [])  where 3 : [] is still WHNF ?
01:04:20 <Cale> Note that terms of type Void have normal forms insofar as terms of type Integer do.
01:04:41 <centril> EvanR: if you give me a term of type Void i'll happily normalise it for you
01:04:46 <Cale> centril: Forcing an expression like that won't do much.
01:04:46 <centril> i double dare you :P
01:05:05 <centril> Cale: but is it correct?
01:05:21 <Cale> centril: Well, that whole thing is in normal form already.
01:06:02 <centril> mind, blown...
01:06:43 <Cale> It's a constructor (:), applied to things which are in normal form, 1 and (2 : 3 : [])
01:07:14 <Cale> and 2 : 3 : [] is in normal form because it's a constructor (:) applied to things in normal form, 2 and 3 : []
01:07:21 <Cale> and 3 : [] is in normal form because...
01:07:23 <Cale> you get it
01:07:26 <centril> i get it
01:08:24 <Cale> Another thing you ought to know is that you could define seq for most data types by using case to pattern match
01:08:27 <Cale> i.e.
01:08:38 <Cale> er, rather, I'll give an example
01:08:43 <Cale> for Bool, we could define
01:09:00 <Cale> seq x y = case x of False -> y; True -> y
01:09:18 <Cale> for Maybe, we could have
01:09:30 <Cale> seq x y = case x of Nothing -> y; Just _ -> y
01:09:36 <Cale> and so on
01:09:45 <centril> oh, i see
01:09:48 <centril> nice, thanks
01:09:56 <Cale> The main exception to this being that for functions, you can't do that
01:10:24 <Cale> > seq (undefined :: Integer -> Integer) 5
01:10:27 <lambdabot>  *Exception: Prelude.undefined
01:11:09 <centril> Cale: uhmm... https://wiki.haskell.org/Weak_head_normal_form
01:11:10 <Cale> Normally, there wouldn't be a way to force the evaluation of a function without doing something like applying it to a particular value
01:11:14 <centril> " a constructor (eventually applied to arguments) like True, Just (square 42) or (:) 1 "
01:11:25 <jared-w> The verifying data structures in Haskell is some deep magic, there ‡≤†_‡≤†
01:11:36 <centril> jared-w: just type hackery
01:11:37 <EvanR> > case id of _ -> 3
01:11:39 <lambdabot>  3
01:11:42 <LiaoTao> jared-w: Everything in GHC is deep magic
01:11:49 <EvanR> > case (undefined :: Int -> Int) of _ -> 3
01:11:51 <lambdabot>  3
01:12:14 <quchen> EvanR: There is a special rule for case that makes it non-strict if the pattern always matches
01:12:23 <Cale> Yeah, case at this level is too clever: you have to provide a pattern involving constructors in order to make it evaluate the scrutinee
01:12:25 <EvanR>  case (undefined :: Int -> Int) of (\_ -> _) -> 3
01:12:35 <Cale> heh
01:12:52 <EvanR> cant be denied
01:13:07 <Axman6> jared-w: its pretty cool eh?
01:13:12 <kosmikus> quchen: not really a "special" rule. Haskell surface language pattern matching supports deep patterns, and evaluates as far as needed to make the decision. in case of an always-matching pattern, that naturally means no evaluation.
01:13:20 <Cale> Right
01:13:30 <kosmikus> quchen: in Core, case supports only flat pattern matching, and it always evaluates to WHNF.
01:13:48 <Cale> Though we should be careful about what's meant by "always matching"
01:14:01 <Cale> Matching against () is different from matching against x
01:14:13 <Cale> > case undefined of () -> 1
01:14:14 <kosmikus> Cale: fair enough :)
01:14:15 <lambdabot>  *Exception: Prelude.undefined
01:14:18 <Cale> > case undefined of _ -> 1
01:14:20 <lambdabot>  1
01:14:37 <halogenandtoast> centril: jared-w: updated, although still not sure how to use either as a monad here: https://gist.github.com/halogenandtoast/c426b607eb810143884b30bdcf39aad1
01:15:07 <Cale> But yeah, patterns which are "irrefutable" don't cause evaluation, and those consist of variable patterns, wildcard patterns, and patterns that have ~ applied to them (lazy matches)
01:15:13 <centril> Cale: according to the wiki,  Any True  should be in WHNF, but you say it is NF ?
01:15:28 <Cale> centril: anything in normal form is also in weak head normal form
01:15:36 <centril> oh, right
01:15:42 <merijn> quchen: That rule is a Core rule, not a Haskell rule. At the Haskell level this is just implicit in the definition
01:16:20 <quchen> merijn: No, rule (f) in the formal semantics of pattern matching is there specifically for this case.
01:16:33 <centril> halogenandtoast: apply some eta-reductions,  messageToUser = T.isPrefixOf . userMentionFormat
01:16:41 <merijn> hmmm, I'd have to check
01:16:46 <quchen> And (i) as well.
01:16:52 <jared-w> your imports are much better, halogenandtoast
01:17:16 <jared-w> Great refactoring improvement in the code, too.
01:17:23 <quchen> kosmikus: Depends on what ¬ªspecial¬´ means I guess. I think they‚Äôre special because they‚Äôre there precisely to bridge the gap between Haskell‚Äôs lazy case and STG‚Äôs strict case.
01:17:39 <centril> yeah, well done, but make the function imports more explicit =)
01:17:55 <Cale> Who was it that was such a fan of pure again? I meant to ask about that.
01:18:04 <centril> Cale: me
01:18:05 <Cale> Seems like a strange affectation to use pure in these cases.
01:18:06 <halogenandtoast> Cale: centril
01:18:39 <halogenandtoast> My friend actually asked me while it was called "pure" and not something like "defile"
01:18:46 <halogenandtoast> as it seemed to him to do the opposite
01:18:46 <centril> Cale: my argument is: use the most general version, so that you can get an Applicative constraint instead
01:19:00 <Cale> centril: That's a moot point here though: it's not polymorphic
01:19:03 <halogenandtoast> s/while/why/
01:19:07 <centril> halogenandtoast: haha, nice one
01:19:11 <Cale> We know it's a SlackBot action that's being constructed
01:19:19 <quchen> ¬ªpure¬´ is less misleading than ¬ªreturn¬´, so that‚Äôs why I use it (exlcusively).
01:19:25 <Cale> (or IO)
01:19:31 <centril> Cale: well, if you make it a habit...
01:20:09 <Cale> I don't find return to be misleading, unless you're talking about people who don't know any Haskell, in which case it doesn't seem like the first thing they'll be confused about :)
01:20:41 <Cale> return takes a value, and produces an action which does nothing except to *ahem* return that value :)
01:20:43 <centril> halogenandtoast: well, it is a pure value you are defiling in your monad :P
01:21:02 <halogenandtoast> centril: yeah that was his point.
01:21:08 <centril> halogenandtoast: its a good point
01:21:21 <halogenandtoast> centril: for using the either monad, is that possible inside bggSearchRequest
01:21:32 <halogenandtoast> I don't see how since I'm in IO without using a transformer
01:21:33 <Cale> I might be weird, but I also don't usually *think* in terms of Applicative even when I'm using it.
01:21:37 <merijn> Not really a Haskell question, I suppose. But does anyone have a recommendation on guides on "advanced SQL"? I just realised I forgot a lot of it but most SQL tutorials are terribad
01:22:09 <jared-w> merijn: advanced SQL, afaik, is really just tons of database math
01:22:37 <cocreature> merijn: http://use-the-index-luke.com/blog/2015-02/modern-sql is nice but it‚Äôs more of an overview of features instead of a guide
01:22:44 <Cale> In the sense that I'll usually think through the behaviour of an Applicative-polymorphic thing in my head with an example of something that happens also to be a Monad. 
01:22:53 <cocreature> merijn: the later chapters of https://pgexercises.com/ also have some more advanced stuff
01:23:16 <halogenandtoast> Cale:  I hope one day to be able to discuss the differences between pure and return, for me at the moment, they are synonymous
01:23:28 <centril> halogenandtoast: what is the type of  doc ?
01:23:32 <Cale> halogenandtoast: They are pretty much synonymous anyway.
01:23:34 <merijn> jared-w: That doesn't help me write what I want, though :p
01:23:40 <kuribas> halogenandtoast: pure is more general as return?
01:23:50 <merijn> halogenandtoast: Well, they better be the same :p
01:23:54 <centril> :t pure
01:23:54 <Cale> halogenandtoast: pure is simply a little more general, but in a way which usually doesn't matter at all
01:23:55 <lambdabot> Applicative f => a -> f a
01:23:56 <centril> :t return
01:23:58 <lambdabot> Monad m => a -> m a
01:24:03 <merijn> halogenandtoast: Else your Monad and Applicative don't line up
01:24:08 <centril> Only difference is Monad / Applicative
01:24:42 <merijn> halogenandtoast: pure exists because Applicative was invented/discovered *after* Monad and wasn't a superclass of Monad, so Applicative couldn't use return and Monad couldn't use pure
01:24:48 <halogenandtoast> centril: Response is the type
01:24:53 <quchen> pure is even the default definition for return, and there is no need to ever touch that part
01:24:53 <halogenandtoast> err
01:24:58 <merijn> halogenandtoast: At this point in time pure and return are (or better be!) identical
01:25:00 <halogenandtoast> I think it:s Text
01:25:19 <Cale> quchen: Also return is the default implementation for pure
01:25:20 <Cale> :)
01:25:22 <halogenandtoast> s/Text/ByteString/
01:25:40 <quchen> Cale: Yes, I just said that :-√æ
01:25:47 <jared-w> Just out of curiosity, are return/pure ever going to be different "ideally" some time far in the future?
01:25:54 <Cale> quchen: heh
01:26:10 <Cale> Usually if I'm implementing a Monad by hand (which... sometimes happens, but not very often), I will write the Monad instance first, and use that to construct the Applicative one.
01:26:40 <quchen> jared-w: Don‚Äôt hold your breath on that. ApplicativeDo does it behind the curtains, but it‚Äôs questionable whether return will be removed from Monad in the future.
01:26:43 <Cale> You could write the Applicative instance first, and define return = pure, but then you're still stuck defining (>>=) by hand
01:26:49 <MarcelineVQ> Cale: careful if you find out you like ApplicativeDo :>
01:27:12 <Cale> MarcelineVQ: That's okay, I hate ApplicativeDo.
01:27:16 <MarcelineVQ> shucks buster
01:27:24 <quchen> Hate is a strong feeling. :-/
01:27:32 <centril> Cale: so,   force (1 : 2 : 3 : repeat 1337) == 1 : 2 : (3 : repeat 1337) where (3 : repeat 1337) is WHNF ?
01:27:39 <Cale> Yeah, maybe that's overstating it a bit :)
01:27:40 <centril> quchen: what's with the greek rho / p ?
01:27:50 <quchen> œÅ?
01:27:56 <centril> in :-p
01:28:09 <centril> oh, it wasn't rho
01:28:15 <quchen> Oh, that‚Äôs an autoreplacement I added some time ago for no good reason.
01:28:17 <jared-w> So, from a theoretical purity, monad shouldn't have return and should instead just have pure from applicative?
01:28:25 <merijn> jared-w: Yes
01:28:28 <Cale> But I think it's a confusing extension, which in cases where the distinction that it makes matters, will only make it harder to see that code is correct.
01:28:57 <jared-w> sweet. Can't wait for that ot take 7 years to land :p
01:28:57 <centril> jared-w: well, i'd also like a class Pointed f where pure :: a -> f a
01:29:10 <quchen> inb4 heated Pointed discussion
01:29:10 <merijn> I don't think it ever will
01:29:19 <merijn> Pointed doesn't have many interesting laws
01:29:21 <centril> that way, Comonad and Monad can share Pointed
01:29:44 <centril> merijn: does it have any laws ?
01:29:58 <centril> i mean, you don't have any other function to relate it to
01:30:42 <Cale> centril: force won't mix well with anything involving repeat
01:31:00 <centril> Cale: right, it is _|_
01:31:55 <centril> force (1 : 2 : 3 : lazyStuffNotBottom) == 1 : 2 : (3 : lazyStuffNotBottom) where (3 : lazyStuffNotBottom) is WHNF
01:32:20 <Cale> no, it'll be equivalent to  1 : 2 : 3 : force lazyStuffNotBottom
01:32:44 <Cale> and depending on what lazyStuffNotBottom is, it will proceed from there
01:32:54 <centril> Cale: uhmm... how ?
01:33:09 <Cale> Well, give me a definition of lazyStuffNotBottom and I'll tell you
01:33:55 <Cale> It's just going to keep evaluating everything until either the heat death of the universe, or until everything in sight is a data constructor (or a builtin, or a lambda)
01:35:09 <centril> force x  =  x `deepseq` x  =  rnf x `seq` x,  force !x = () `seq` x
01:35:25 <Cale> Where'd you get that last bit?
01:35:32 <centril> rnf !x = ()
01:35:36 <Cale> huh?
01:35:47 <Cale> That's only true for types which are relatively flat
01:35:55 <Cale> That would be an okay definition of rnf for Bool
01:35:58 <centril> oh
01:35:59 <Cale> but not for lists
01:36:25 <merijn> centril: Well, that's exactly why Pointed is considered "not very useful"
01:36:40 <centril> Cale: so, for [Int],  rnf = fmap rnf  ?
01:36:50 <Cale> not quite
01:37:24 <Cale> fmap rnf would still allow you to evaluate the list to see if it was nonempty without touching the elements
01:37:41 <Cale> e.g.
01:37:59 <centril> i.e, strict in the spine, not strict in the elements... ?
01:38:04 <Cale> map rnf (1 : _|_) -> 1 : map rnf _|_
01:38:17 <Cale> and evaluation could actually just stop there
01:38:28 <Cale> > rnf ()
01:38:30 <lambdabot>  ()
01:38:37 <Cale> okay, good it's in scope :)
01:38:52 <centril> Cale: so,  strictmap rnf
01:38:54 <Cale> > case map rnf (1 : undefined) of (x:xs) -> 0
01:38:56 <lambdabot>  0
01:38:59 <Cale> yeah
01:39:15 <centril> now i get it, and my implementation was broken
01:39:18 <centril> good good :P
01:39:39 <Cale> > case rnf (1 : undefined) of (x:xs) -> 0
01:39:41 <lambdabot>  error:
01:39:42 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò()‚Äô with actual type ‚Äò[t0]‚Äô
01:39:42 <lambdabot>      ‚Ä¢ In the pattern: x : xs
01:39:49 <Cale> oh, of course
01:39:51 <Cale> > case rnf (1 : undefined) of () -> 0
01:39:53 <lambdabot>  *Exception: Prelude.undefined
01:40:42 <Cale> btw, some things worth pointing out
01:40:47 <Cale> x `seq` x is the same thing as x
01:41:26 <Cale> (but x `deepseq` x is not)
01:41:47 <centril> Cale: so, if I use DeriveAnyClass and derive NFData, how does GHC manage to make an rnf implementation that evalutes the argument to NF?
01:41:51 <Cale> and x `seq` y `seq` z is in fact the same thing as y `seq` x `seq` z
01:42:11 <Cale> DeriveAnyClass is stupid, and will just make you an empty instance declaration
01:42:30 <Cale> and so you'll get the default method implementations defined in the class
01:42:36 <Cale> which may be incorrect
01:43:09 <centril> meh... that is the advice given, go ahead and use DeriveAnyClass
01:43:20 <centril> "Starting with GHC 7.10, the example above can be written more concisely by enabling the new DeriveAnyClass extension:"
01:43:26 <Cale> Don't, it will usually get you the wrong instance.
01:43:35 <centril> ah, good to know
01:43:37 <Cale> Well, okay, that *particular* example
01:43:54 <Cale> because the default implementation of rnf happened to be okay in that case
01:44:03 <centril> x `seq` x,  shouldn't x be in head normal form now?
01:44:07 <Cale> But if your type has any tree-like structure to it at all, then it wouldn't work
01:44:19 <jared-w> does GeneralizedNewtypeDeriving work? Or is that tackling a separate concern?
01:44:33 <Cale> centril: The definition of seq is that
01:44:34 <centril> jared-w: works
01:44:37 <Cale> seq _|_ y = _|_
01:44:44 <Cale> But seq x y = y otherwise
01:45:04 <jared-w> centril: neat. So why do we still have DeriveAnyClass then? Backwards compatibility before we came up with GND?
01:45:14 <centril> jared-w: GND only works for newtypes
01:45:31 <Cale> So when treating seq x y, the compiler just needs to ensure x is in WHNF (so that it's not _|_) before allowing you to proceed with y
01:45:35 <jared-w> riiight, because it's a newtype, durr.
01:46:13 <Cale> But in the case of x vs. (x `seq` x), if you were going to match on this expression already, you would be evaluating either one into WHNF
01:46:33 <Cale> and so saying "please evaluate x into WHNF before continuing" doesn't do anything extra
01:46:58 <Cale> and of course, seq x y doesn't have any effect before you evaluate it
01:48:30 <Cale> In a bad implementation of the language, seq x x would perhaps result in a few additional cycles vs. x, but I believe GHC will produce the same code for both.
01:49:47 <centril> halogenandtoast: what is the type of parseLBS def doc ?
01:49:50 <Cale> Semantically they're identical though: if x is _|_, then seq x x is _|_, and if not, then seq x x is x
01:50:01 <centril> halogenandtoast: you should focus on eta reduction, it will make the code nicer =)
01:50:26 <Cale> Another thing, which might blow your mind a little more is that seq x (seq y z) is the same as seq y (seq x z)
01:50:50 <centril> halogenandtoast: also, pure () is a sign that you should be using fmap at the end
01:51:21 <Cale> If either x or y were _|_, then seq x (seq y z) and seq y (seq x z) would result in _|_
01:51:29 <Cale> and if neither is, they both result in z
01:51:43 <centril> halogenandtoast: (sendMessage cid . ("https://www.boardgamegeek.com/boardgame/" <>) <$> mid
01:51:44 <Cale> So they're equivalent, and the compiler is free to replace one by the other
01:52:24 <Cale> Perhaps "seq" is a bit of a bad name for it, as this shows -- it's not really about sequencing :)
01:52:27 <centril> Cale: seems to follow logically
01:52:31 <centril> doesnt blow my mind at all
01:52:54 <Cale> Well, most people initially regard seq x y as meaning "evaluate x into WHNF, and *then* result in y"
01:52:54 <centril> Cale: unbelievably bad name
01:53:13 <Cale> and most of the time, that's a good enough approximation to what it means
01:53:23 <Cale> The compiler won't often doubt you
01:53:40 <centril> Cale: so, it says: "Evaluates its first argument to head normal form, and then returns its second argument as the result. "
01:53:43 <Cale> But it's actually allowed to evaluate y first if it wants, and then x, before resulting in y
01:53:49 <centril> the difference being WHNF and HNF
01:53:58 <centril> wtf is HNF?
01:54:00 <centril> anyways...
01:54:02 <Cale> head normal form
01:54:18 <Cale> is what rnf actually produces
01:54:20 <centril> yes, i can decipher the acronym :P
01:54:23 <Cale> (if correctly defined)
01:54:32 <centril> but what does it mean, technically ^
01:54:35 <centril> :)
01:54:36 <Cale> It's like normal form, but any lambda is in hnf
01:54:44 <Cale> er...
01:55:00 <Cale> oh, no
01:55:33 <Cale> head normal form is the silly thing
01:55:41 <Cale> heh
01:55:51 <Cale> Any constructor applied to arbitrary arguments is in head normal form
01:56:03 <Cale> and any lambda whose body is in head normal form is in head normal form
01:56:11 <Cale> So you still have to look inside lambdas
01:56:22 <Cale> But you don't have to look inside constructors
01:56:30 <centril> so, it reduces a lambda?
01:56:59 <centril> i.e, it reduces the body of a lambda...?
01:57:04 <Cale> Yeah, to reduce to HNF is weird, because you'd need to be able to reduce the body of a lambda without knowing its argument
01:57:18 <Cale> which is usually not something that real-world evaluators can attempt
01:57:23 <centril> not that weird, reduce what you can, and dont touch arguments
01:57:43 <centril> like, constants ==> constant fold, etc
01:57:45 <Cale> It's really weird if you're writing a compiler
01:58:15 <centril> I havent written a "real world" compiler yet, but I have written several compilers
01:58:29 <centril> tho mostly for imperative languages
01:58:40 <centril> which is totally different, i guess
01:58:44 <Cale> So, for instance, if you wanted to have function closures
01:58:55 <Cale> implementing your lambdas at runtime
01:59:20 <Cale> Then you need to do something similar to entering the code for the closure, but with no argument available
01:59:46 <centril> Cale: is the lambda known at compile time?
01:59:56 <Cale> Well, to some extent...
02:00:14 <centril> the arguments are not known, but is the body?
02:00:18 <Cale> Though it might capture a bunch of things in its environment
02:00:24 <Cale> The body will be known
02:00:34 <Cale> though... even that's not quite true
02:00:38 <centril> then we can constant fold the body, and inline and other magic
02:00:47 <centril> nothing weird at all
02:00:51 <Cale> the body might involve formal parameters of other lambdas that we're evaluating the body of
02:01:04 <Cale> right?
02:01:08 <centril> well, optimize what we can, don't touch the rest
02:01:25 <Cale> consider, say (\x -> map x (1 : 2 : 3 : []))
02:01:55 <centril> and then we can do some  data flow analysis, and some inlining with SCC
02:01:55 <Cale> To put this in head normal form, we need to get it to (\x -> x 1 : x 2 : x 3 : [])
02:02:18 <Cale> Now, we might be able to do that with the information that's available statically, just doing term rewriting
02:02:43 <centril> right
02:03:00 <centril> the implementation of map is known, and the list is known
02:03:02 <Cale> But at runtime, usually we want to be able to represent programs in a way which runs a little faster than repeatedly rewriting term graphs
02:03:14 <EvanR> theres optimizing and evaluating ahead of time
02:03:49 <Cale> So unless you're representing *everything* as term graphs, reduction to head normal form isn't usually something you can accomplish.
02:04:05 <EvanR> but you dont want to try evaluating stuff that might fail
02:04:20 <EvanR> so even constants cant be folded sometimes, like fromInteger 3
02:04:24 <Cale> right, usually you also don't want to carry out recursion at compile time
02:04:48 <centril> Cale: LLVM does this...
02:04:54 <Cale> So even a Haskell compiler is unlikely to optimise the body of this lambda by applying map
02:04:55 <centril> aggressively
02:05:07 <Cale> Well, there are severe limits
02:05:20 <Cale> because you can't tell if things are going to terminate
02:05:22 <centril> you can always put a recursion depth limit or something
02:05:26 <Cale> yeah
02:05:38 <centril> which is a reasonable way to constant fold
02:05:44 <Cale> and you can also have the type system / totality checking help
02:05:56 <EvanR> also you dont want to do evaluation if it means unnecessarily materializing data structures in memory
02:06:06 <Cale> (but even if you do that, you probably want the depth limit)
02:06:08 <EvanR> i often want to *un* evaluate stuff back to thunk
02:06:16 <centril> EvanR: well, that is a very difficult analysis to do
02:06:32 <centril> kinda like deciding whether or not to inline C++ functions
02:06:34 <EvanR> the default is to not evaluate until runtime, which is good :)
02:06:35 <Cale> Yeah, you're often trading time for space when you evaluate stuff earlier
02:06:54 <EvanR> and only then, lazily
02:07:54 <centril> this is very different from imperative or strict languages i guess
02:07:58 <Cale> and at runtime, reduction to HNF is a crazy thing to try to do in GHC Haskell.
02:08:31 <centril> LLVM will go ahead and agressively inline and constant fold any constant it sees
02:08:43 <Cale> Yeah, but mostly it's hosed
02:08:57 <Cale> It can't attempt to run most stuff
02:09:10 <Cale> because that stuff will tend to have effects you don't want going off at compile time :P
02:09:41 <Cale> It can handle certain bits and pieces
02:09:56 <centril> Cale: well, it does analyse what is pure and what is not
02:10:13 <halogenandtoast> centril: sorry for my lack of responses, was just hosting my company's first haskell book club meeting.
02:10:23 <Cale> nice
02:10:27 <centril> halogenandtoast: what's the company?
02:10:40 <halogenandtoast> Cookpad
02:10:50 <Cale> halogenandtoast: Are you guys using or thinking of using Haskell?
02:10:52 <centril> and where do you reside?
02:11:13 <halogenandtoast> Cale: trying to release this as a start: https://github.com/cookpad/mirin
02:11:18 <halogenandtoast> centril: I live in Tokyo
02:11:22 <centril> =)
02:12:39 <centril> halogenandtoast: MySQL or MariaDB?
02:12:52 <centril> (I don't like ORACLE)
02:13:03 <halogenandtoast> centril: aurora db
02:13:11 <centril> no idea what that is
02:13:16 <halogenandtoast> Amazon's offering
02:13:22 <centril> oh
02:13:26 <halogenandtoast> Amazon Aurora ‚Äì New MySQL-Compatible Database Engine
02:13:33 <halogenandtoast> so not Oracle
02:14:04 <halogenandtoast> I don't want to use it, I'm just trying to create as few barriers as possible to get our infra team to allow me to use Haskell.
02:14:08 <centril> InnoDB it seems
02:15:02 <centril> Try MariaDB, tho I don't know how it works on Amazon or if it does
02:15:28 <halogenandtoast> centril: I have, but infra is already using (and knows how to use) aurora.
02:15:48 <halogenandtoast> So I want to make releasing this as painless as possible, so they don't tell me no.
02:15:48 <centril> they are compatible methinks
02:16:25 <halogenandtoast> centril: I believe they are as well.
02:16:44 <centril> Cale: any idea how the state of Idris is? i really want to use dependent types, but it is super weird to use it in Haskell atm
02:16:46 <halogenandtoast> I'd use PostgreSQL if I had my way.
02:17:18 <centril> halogenandtoast: btw, safeHead is from safe, so you can just import it
02:17:25 <Cale> centril: It's okay -- it's probably about as practical as Haskell was in 2004 or so.
02:17:46 <Cale> centril: But it's good enough to play around with practical programming and dependent types.
02:17:53 <centril> I hope Rust gets HKT and dependent types soon
02:18:00 <Cale> centril: Coq and Agda are also worth looking at if you're interested
02:18:00 <halogenandtoast> centril: this one? https://hackage.haskell.org/package/safe
02:18:12 <centril> Cale: haha, Agda... noone actually runs Agda =)
02:18:23 <centril> halogenandtoast: yes
02:18:23 <Cale> centril: I would recommend bouncing between all three to some extent if you're learning dependently typed programming
02:18:37 <quchen> The Agda compiler runs Agda.
02:18:50 <Cale> because there are different resources available for all three, and while their syntaxes are all very different, the ideas are quite similar
02:19:06 <centril> Cale: nah, not learning, already had a course for "Types for Programs and Proofs" at Chalmers
02:19:11 <centril> last year
02:19:18 <Cale> Coq in particular has perhaps the best educational materials
02:19:29 <osa1> anyone know why this doesn't crash with a "Thread blocked indefinitely .." exceptions: http://lpaste.net/356396 ?
02:19:38 <osa1> exception*
02:19:50 <halogenandtoast> centril: cool thanks, good to know about that package
02:20:07 <cocreature> Cale: that depends on what you want to learn. if you want to learn how to use dependently typed programming languages for writing programs and not proofs, Coq does not have a lot in that area
02:20:09 <centril> Cale: also known as, the Church of Haskell (Chalmers)
02:20:24 <centril> quchen: Agda compiles to Haskell iirc
02:20:30 <centril> and is written in Haskell
02:20:51 <Cale> cocreature: That's true, but... the lines between those two activities are extremely blurry
02:21:17 <cocreature> Cale: sure but for Coq I think it‚Äôs pretty clear on which line it falls :)
02:21:24 <centril> was a bit weird... Coquand was one of our professors, but we used Agda in the course
02:21:31 <Cale> I don't know, CompCert is written in Coq
02:21:39 <centril> oh well, we had Ulf Norell and Coquand in the course
02:22:00 <Cale> It *is* possible, with sufficient heroism, to get actual running software built using Coq.
02:22:14 <Cale> But... there's clearly a bias toward the side of proving theorems.
02:22:33 <centril> Cale: does Coq have a codegen, to what, how?
02:23:02 <centril> also, the way Agda deals with "type classes" by using records is weird
02:23:08 <centril> not ergonomic at all
02:23:08 <cocreature> even if you‚Äôre writing actual software in Coq, you are mostly doing so because you are interested in proving all kinds of properties about it and not because you want to use dependent types in a few selected places
02:23:16 <Cale> Yeah, it contains a compiler, and there's also Haskell and iirc, OCaml program extraction.
02:23:48 <Cale> cocreature: right. For learning though, I think it's fine.
02:23:55 <cocreature> oh Coq has it‚Äôs own compiler? I‚Äôve only known about program extraction
02:24:04 <halogenandtoast> centril: btw I don't think this works (sendMessage cid . ("https://www.boardgamegeek.com/boardgame/" <>) <$> mid because that will return a Maybe
02:24:12 <halogenandtoast> which isn't what the function wants/expects.
02:24:27 <Cale> cocreature: yeah, coqc
02:24:34 <centril> I haven't written any Coq, but just reading the source code, I find Agda much easier to read
02:24:41 <centril> halogenandtoast: oh, use maybe instead
02:24:43 <centril> :t maybe
02:24:45 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:24:58 <cocreature> Cale: well, now we‚Äôre back to where I think it depends on what you want to learn :) edwin brady‚Äôs book & idris is imho a lot better for learning how to use dependent types in your normal programs than the usual resources for Coq
02:25:10 <cocreature> Cale: I thought coqc only typechecks?
02:25:20 <halogenandtoast> centril: so        maybe (pure ()) (sendMessage cid . ("https://www.boardgamegeek.com/boardgame/" <>)) mid
02:25:27 <Cale> cocreature: Nah, it generates statically compiled object code
02:25:43 <Cale> cocreature: However, I think it lacks the ability to link an actual running executable
02:25:58 <Cale> cocreature: So you're still stuck loading and running that code interactively
02:26:02 <ventonegro> Can I generate C code from Coq?
02:26:06 <centril> cocreature: Cale: tho... Agdas support for unicode is not very nice
02:26:29 <centril> what is the difference between a compiler and program extraction... ?
02:26:39 <cocreature> Cale: ah fair enough
02:26:40 <centril> halogenandtoast: seems about right, try it and see if it compiles
02:27:09 <centril> halogenandtoast: there's also the function unless and when
02:27:11 <centril> :t when
02:27:13 <lambdabot> Applicative f => Bool -> f () -> f ()
02:27:13 <centril> :t unless
02:27:14 <lambdabot> Applicative f => Bool -> f () -> f ()
02:27:38 <halogenandtoast> yeah I was trying to use when
02:27:38 <Cale> cocreature: It would be nice for someone to go the rest of the way, given how close that seems to be.
02:27:42 <halogenandtoast> just now
02:28:27 <EvanR> indexed TypeRep... amazing
02:28:28 <centril> halogenandtoast: also, try LambdaCase
02:28:28 <cocreature> Cale: not sure how useful that would be. the code would probably be terribly slow :)
02:28:55 <Cale> cocreature: It probably depends a bunch on the code!
02:29:28 <halogenandtoast> centril: where are you suggesting to use it? bggSearchRequest?
02:29:37 <Cale> cocreature: (which, as large portions of it were written using tactics, yes, probably it will be slow ;)
02:29:56 <centril> halogenandtoast: boardy, safeHead, 
02:30:05 <cocreature> Cale: I also doubt that coqc does any significant optimizations or even any optimizations at all
02:30:14 <halogenandtoast> centril: ah safeHead is gone, updated the gist again
02:30:43 <centril> halogenandtoast: also, consider moving  encoded = ... out to a top level function
02:30:52 <Cale> cocreature: I don't know the details, but the compiled code is supposed to run a whole lot faster :P
02:31:11 <centril> halogenandtoast: in general, where and let bindings are only useful to ensure that the same thing doesnt get evaluated twice
02:31:12 <Cale> cocreature: It does seem likely that it's only because it's compiled at all
02:31:21 <cocreature> Cale: I‚Äôd prefer a coqc that runs faster :P
02:32:04 <centril> halogenandtoast:  queryFromMention = T.drop . T.length userMentionFormat
02:32:09 <Cale> ventonegro: I don't know -- not directly.
02:32:37 <Cale> ventonegro: But maybe there's an ML to C compiler somewhere that would work
02:33:28 <centril> cocreature: thats okay... just throw LLVM at the C code and you get better C code
02:33:30 <halogenandtoast> centril: my internal haskell compiler says queryFromMention = T.drop . T.length userMentionFormat is going to error
02:33:53 <halogenandtoast> it did not compile in a real Haskell compiler either.
02:33:54 <centril> oh, wait
02:34:09 <centril> halogenandtoast:  queryFromMention = T.drop . T.length . userMentionFormat
02:34:21 <halogenandtoast> compiles in my internal haskell compiler
02:34:33 <centril> what is your "internal haskell compiler"? ghci ?
02:34:40 <halogenandtoast> centril: my head
02:34:46 <centril> oh, that thing
02:34:48 <centril> :P
02:34:50 <halogenandtoast> yeah
02:34:55 <cocreature> centril: you‚Äôll get better C code but without any sort of higher level optimizations, I doubt you‚Äôll get close to any language aimed at running the programs you write in it. 
02:35:09 <centril> cocreature: of course =)
02:35:26 <halogenandtoast> centril: updated the gist again, getting even better.
02:36:03 <ventonegro> Cale: MLton can compile via C, I think...
02:36:39 <cocreature> I guess what I‚Äôm trying to say is that maybe instead of turning Coq into a compiler capable of producing decent programs, it might be better to focus on generating code for a compiler that is already capable of doing so (which is pretty much the current state of affairs)
02:37:18 <ertes-w> does anyone know whether the resource-pool package is still maintained?
02:37:34 <centril> halogenandtoast: so get rid of the where in bggSearchRequest, LambdaCase the boardy function, 
02:37:39 <ertes-w> last update was in 2014, and nothing happened in the repo since then
02:37:52 <Cale> ertes-w: It... should be
02:38:14 * kuribas really wishes there was better SIMD support in ghc.  Now C/C++ is the only option...
02:38:14 <halogenandtoast> centril: what benefit does the lambda case give me there?
02:38:27 <Cale> ertes-w: We use it at Obsidian, and I expect a lot of other people do as well
02:38:45 <Cale> ertes-w: But there's probably little maintenance required.
02:38:51 <ertes-w> Cale: yeah, the yesod folks use it, too
02:39:19 <ertes-w> Cale: i'm just wondering, because bos packages seem to have gone unmaintained‚Ä¶  i wonder if bos is still around
02:39:21 <centril> :t either
02:39:23 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:39:26 <centril> halogenandtoast: ^
02:39:41 <centril> halogenandtoast: it is better style, it is more DRY as you don't repeat boardy twice
02:40:38 <Cale> ertes-w: That I don't know
02:40:41 <centril> I find the  f pat1 = ... ; f pat2 = ... ; ... ; f patN = ...;  style fugly
02:41:31 <Cale> centril: I don't always hate it -- if you're pattern matching in multiple arguments, it can be nicer than case
02:41:42 <Cale> centril: But I often agree.
02:41:49 <centril> Cale: curry $ \case ...
02:42:03 <Cale> bleh
02:42:06 <centril> :P
02:42:39 <centril> or just let your function be uncurried
02:42:45 <Cale> Also, sometimes I do like to pull out exceptional cases at the top as a separate function binding
02:43:07 <ph88^> hi guys
02:43:23 <Cale> In cases where a function proceeding accidentally in that case would be dangerous or inappropriate
02:43:35 <centril> ph88^: hi there
02:44:03 <Cale> (because when it's separated out like that, it's less likely that someone will accidentally bypass the check)
02:44:08 <halogenandtoast> centril: is this what you meant: https://gist.github.com/halogenandtoast/c426b607eb810143884b30bdcf39aad1#file-slackbot-hs-L72
02:44:16 <centril> Cale: well, the exceptional case is in the top anyways... just use a comment if it is so dangerous
02:44:29 <ph88^> could someone help me understand the trace i made? https://bpaste.net/show/5f3951520c63  some numbers are not as they expect them to be. Question is on the last line (114)
02:44:34 <centril> Cale: a comment is much better indication
02:46:10 <centril> halogenandtoast: perhaps extract  session . slackSelf . selfUserId . getId  to its own function
02:46:39 <Cale> A comment might be a good idea anyway, but I've seen some remarkably stupid things done in the face of comments
02:47:20 <Cale> Of course, someone might come along and restructure the whole function so it doesn't do the check anyway
02:47:24 <centril> Cale: there is no salvation to stupid humans except for dependent types perhaps
02:47:42 <Cale> But I like to make it a little harder to get things wrong when it's possible.
02:47:57 <Cale> Another good use case is for tracing
02:48:20 <centril> Cale: I guess that use of "normal" pattern matching is fine, but it is exceptional anyways
02:48:25 <Cale> You can have   f x y z | trace (... something that shows x, y, and z ...) False = undefined
02:48:59 <Cale> and it's easier to stick that in at the top of the definition than to rework anything existing which is going on
02:48:59 <halogenandtoast> centril: any suggestions on simplying this type signature? selfId :: (Text -> Const Text Text) -> SlackState s0 -> Const Text (SlackState s0)
02:49:18 <Cale> (and easier to remove it after)
02:49:54 <halogenandtoast> my lens knowledge is rather limited.
02:51:09 <halogenandtoast> ah maybe selfId :: Getter (SlackState ()) Text
02:51:44 <centril> halogenandtoast: oh,  LensLike' (Const Text) (SlackState s0) Text
02:51:59 <centril> but I guess Getter = LensLike' (Const ...)
02:52:28 <centril> halogenandtoast: btw... unless you are using Lens a lot, consider dropping it, because lens is a very heavy dependency
02:52:47 <halogenandtoast> centril: the slack bindings I'm using use it.
02:52:55 <centril> ok, then keep it
02:53:17 <Cale> My main concern in this case wouldn't be the use of multiple function bindings vs. case
02:53:28 <Cale> but rather the pattern  Message cid _ msg _ _ _
02:53:35 <centril> yeah, 
02:53:46 <centril> it's a record, right? so use the record names
02:53:49 <centril> for the fields
02:54:29 <Cale> Well, maybe it's not written using record syntax because it's apparently a sum type, but a refactor of the type is probably in order.
02:54:55 <centril> Cale: sum types + records are fine...
02:55:06 <Cale> Not really...
02:55:18 <Cale> Because the field extractors become partial functions
02:55:37 <Cale> If you have a sum type where some case has a lot of fields, probably it's a good idea to factor the fields out into a separate record type
02:55:51 <Cale> and then just have one field of that type in the sum
02:56:03 <centril> data Stuff = Message { cid :: Type1, ... msg :: Type2, ... } | Variant2 ...
02:56:15 <Cale> yeah ^^ that's dangerous
02:56:22 <centril> \case Message { cid, msg } -> ... ; _ -> ...
02:56:34 <Cale> Because, e.g. msg might not be a field of Variant2
02:56:38 <centril> oops, forgot a { cid, msg, ...}
02:56:57 <Cale> and then  msg (Variant2 ...)  would be a runtime exception
02:57:09 <centril> well, don't do msg on a sum type like that
02:57:16 <centril> who says you have to use the selector functions?
02:57:29 <centril> you get plenty of nice things with a record besides selector functions
02:57:40 <centril> such as Traversal'
02:57:53 <Cale> What I'd normally do is:
02:58:07 <Cale> data Stuff = StuffMessage Message | Variant2 ...
02:58:13 <Cale> and then define Message as a record type
02:58:21 <Cale> and then you get the best of both
02:58:34 <centril> data Stuff = StuffMessage { msg :: Message } | Variant2 ..
02:58:39 <EvanR> data Proxy k (a :: k) = Proxy -- it says Proxy takes both kind of type arguments... does that mean a could be a kind
02:58:42 <Cale> not that
02:58:50 <centril> Cale: I still want records everywhere because: Lens
02:58:54 <Cale> Sum types and record syntax are just terrible together
02:59:09 <Cale> If you want to define prisms or something, then fine, go ahead
02:59:25 <Cale> But don't leave the field extractor functions lying around :)
02:59:49 <ertes-w> i need an abstraction that creates a fixed number of resources concurrently using a certain IO action, and whenever i request a resource, i get one of them‚Ä¶  as soon as i use one of them, it recreates the resource
02:59:58 <ertes-w> kind of like a "keep these ready" pool
03:00:16 <ertes-w> (so not quite what resource-pool does)
03:00:25 <centril> Cale: just omit them from the exports
03:00:45 <ertes-w> any ideas?  i couldn't find anything on hackage
03:01:36 <Cale> ertes-w: Kind of like a QSem with evidence
03:01:59 <Cale> ertes-w: Oh, a BoundedChan would do it
03:02:16 <ertes-w> ah, of course, yeah
03:04:45 <Cale> ertes-w: I wonder what the best library for that is... I seem to recall a library which provided a bunch of nice variations on bounded channels
03:05:15 <ertes-w> Cale: i was going to go with TBQueue from stm
03:05:39 <Cale> ahh, cool
03:05:50 <Cale> forgot about that
03:52:38 <quchen> Cale: pipes-concurrent?
04:02:11 <Wizek> Hello. Do I suspect right that [these type errors](https://github.com/turingjump/bookkeeper/issues/6#issuecomment-310042248) are related to -XTypeFamilies, or something else perhaps?
04:03:57 <mniip> Wizek, are you writing a GADT pattern match without a type signature?
04:04:45 <Wizek> mniip, Possibly. The types of these functions are a bit over my head. I hoped GHC could infer, but apparently not, right?
04:04:58 <mniip> no, not in presence of GADTs
04:05:35 <mniip> GADT functions don't always have a single principal type, so inference is impossible
04:10:16 <Wizek> mniip, so, if only I manage to combine the type signatures of [`deleteTMapK` and `append`](https://gist.github.com/Wizek/e5883d0181ab8b7c7616fcbf62ca2e89) then it may compile, right?
04:10:56 <Wizek> (manage to combine and put it as the signature for `appendOverwrite`)
04:11:36 <Cale> quchen: Not the one I was thinking of, but that's neat
04:12:00 <mniip> Wizek, what's the type of TMap.Ext
04:12:42 <Wizek> mniip, `TMap.Ext :: TMap.Var k -> v -> TMap.Map m -> TMap.Map (k 'TMap.:-> v : m)
04:12:42 <Wizek> `
04:13:01 <mniip> dang, more indirection :v
04:14:42 <mniip> Wizek, sounds like you could just use append's type signature as-is, no?
04:15:19 <Wizek> mniip, I doubt that a bit, but giving it a try nontheless
04:15:20 <Wizek> nonetheless
04:17:55 <Wizek> hmm, [interesting](https://gist.github.com/Wizek/e5883d0181ab8b7c7616fcbf62ca2e89#file-3-hs) Seems like one of the type errors are gone
04:20:08 <mniip> does your client render markdown or something?
04:20:53 <bollu> quchen can I use prettyprinter to emit out graphviz?
04:21:35 <bollu> quchen also, unfortunate to hear about the prettyprinter -> ansi_wl_whatever thing
04:22:03 <Wizek> mniip, it doesn't. I just think it can still be a useful notation to embed links even in a plain-text environment.
04:22:27 <quchen> bollu: Sure you can emit GraphViz, if you define a SimpleDocStream -> GraphViz function
04:22:37 <newhoggy> What's the proper name for this kind of type? https://gist.github.com/newhoggy/2ff45f23ebe2e6901690553e9da4e0be
04:22:43 <bollu> quchen cool, ty. I might write an adapter for it
04:22:44 <quchen> bollu: ansi_wl_pprint is a closed system, you can‚Äôt pattern match on Doc :-(
04:22:45 <newhoggy> I want to Google it to read more about it.
04:22:48 <bollu> quchen ah, I see
04:22:53 <bollu> quchen does it not exposed Internal?
04:22:56 <quchen> Yes
04:23:09 <bollu> quchen does it not expose*
04:23:12 <quchen> bollu: You could definitely visualize a Doc as a GraphViz picture. That would be pretty cool actually.
04:23:21 <mniip> Wizek, what exactly is a Key and how does it correlate to TMap.Var?
04:23:28 <bollu> quchen yep. I'm writing a tiny imperative compiler as a hobby-hobby project
04:23:31 <quchen> Most prettyprinters are completely opaque and incompatible to each other :-/
04:23:37 <bollu> quchen so, like. I want to visualize basic blocks
04:23:43 <bollu> quchen ah, I see
04:23:59 <quchen> Visualizing basic blocks does not seem related to prettyprinting at all.
04:24:01 <cocreature> friends don‚Äôt make friends use packages that don‚Äôt expose their internals
04:24:05 <quchen> Well, single basic blocks maybe.
04:24:15 <quchen> Always expose your privates.
04:24:19 <bollu> quchen I pretty print my code inside a network of basic blocks. A function consists of basic blocks
04:24:26 <bollu> quchen anyway, that's kinda tangential. 
04:24:39 <bollu> quchen someone will have to convince kmett to use prettyprinter? : )
04:24:50 <edwardk> ?
04:25:08 <bollu> edwardk trifecta depends on ansi-wl-pprint. Can we change that to "prettyprinter"?
04:25:35 <edwardk> there was some work underway to change ansl-wl-pprint to sit on top of a more generalthing to replace annotated-wl-pprint
04:25:42 <edwardk> that would be the direction i'd prefer to go
04:26:05 <edwardk> replacing it with prettyprinter would be pretty invasive as it'd affect major users like idris
04:26:28 <quchen> edwardk: I significantly reworked the WL family, I told you about this a couple of months ago. It then got such a larger scope that I felt like it wouldn‚Äôt make a good bump to the wl-pprint, so released it as ¬ªprettyprinter¬´. It‚Äôs Text-based, annotated, offers different backends, and all the nice things. It also comes with compatibility modules for wl-pprint, ansi-wl-pprint, and annotated-wl-pprint.
04:27:04 <quchen> https://hackage.haskell.org/package/prettyprinter-1.1/docs/Data-Text-Prettyprint-Doc.html
04:27:59 <quchen> edwardk: Having Trifecta switch to it would probably help its adoption, but since Trifecta has lots of users I didn‚Äôt push for that. Likewise for Optparse-Applicative.
04:28:56 <Wizek> mniip, https://gist.github.com/Wizek/e5883d0181ab8b7c7616fcbf62ca2e89#file-4-hs, They appear to be structurally the same, only nominally different. `Key` is Bookkeper's type for keys, `TMap.Var` is Data.Type.Map's. Maybe if I wouldn't go through `unBook . Book` in `deleteTMapK` this wouldn't be a problem. I'm looking for an appropriate function now.
04:29:10 <quchen> Since you mentioned Idris, porting that wasn‚Äôt too hard ;-)
04:29:35 <quchen> (But it won‚Äôt go live because they‚Äôre switching to a different prettyprinter altogether, which supports proportional fonts and what not)
04:29:47 <bollu> quchen what's a proportional font?
04:29:56 <cocreature> bollu: one that‚Äôs not monospaced
04:30:09 <bollu> cocreature ah, I see
04:30:11 <quchen> Comic Sans, for example
04:30:18 <bollu> cocreature BTW, I do mean to get back to the LLVM stuff
04:30:25 <bollu> cocreature just that I'm facing super weird bugs in real life xD 
04:30:26 <edwardk> quchen: ah
04:30:33 <bollu> cocreature that I haven't had time to work on it.
04:30:35 <edwardk> proportional font support is interesting
04:31:00 <quchen> edwardk: It‚Äôs not Wadler/Leijen though, http://davidchristiansen.dk/drafts/final-pretty-printer-draft.pdf
04:31:20 <cocreature> bollu: no preasure. I‚Äôve also been caught up in other things
04:34:54 <phadej> quchen: decoupling width from character count shouldn't be too hard in WL either?
04:35:13 <bollu> quchen BTW, I have a parser for the "old" STG format in trifecta: https://github.com/bollu/simplexhc/blob/master/src/StgParser.hs#L209
04:35:20 <bollu> quchen do you want me to upstream it to stgi?
04:35:28 <quchen> phadej: Hmm yeah you‚Äôre right, you‚Äôd just have to have a way to measure the size of a character
04:36:08 <quchen> bollu: Which old format? GHC or the 1992 paper?
04:36:08 <phadej> quchen: do you need a character, won't it be enough to work on String?
04:36:30 <phadej> i.e. you don't ever split arguments of `string :: String -> Doc` in prettyprinting libs
04:36:30 <bollu> quchen '92 paper. Is GHC very different from it? from the times I've read -ddump-stg, it seems quite similar
04:36:41 <bollu> quchen I wouldn't mind reading GHC's exact output, because I need to do it anyway sometime
04:36:48 <quchen> phadej: Yes, that would also do. Having single characters is a small optimization. But in general you‚Äôd have to have a ¬ªText -> OpticalLength¬´ function.
04:36:58 <cocreature> measuring strings instead of characters also allows you to do ligatures and things like that
04:37:30 <quchen> The layout would have to be font-aware then, that doesn‚Äôt sound easy
04:37:33 <phadej> cocreature: yeah, there will be problems when you concatenate the strings, so the ligature is formed at glue point
04:37:41 <quchen> Anyway, the final prettyprinter can also do right alignment and things like that, I think
04:37:49 <phadej> cocreature: but it should be doable
04:38:08 <cocreature> phadej: yeah although you could also argue that ligatures not appearing when gluing things together is a feature :)
04:38:15 <phadej> cocreature: true :)
04:38:41 <bollu> quchen  are you aware of a significant difference between GHC output and '92 paper output?
04:38:45 <phadej> quchen: I guess they sacrifice the speed of greedy algorithms for more features
04:38:47 <quchen> bollu: Nope
04:38:54 <bollu> quchen yeah, so.
04:38:57 <phadej> quchen: the same as with ICFP'17 paper
04:39:04 <bollu> quchen do you want me to upstream it after testing against GHC?
04:39:09 <quchen> bollu: If you could adapt it and put it into the Parser directory of the STGi, including documentation and tests, that would be cool
04:39:15 <bollu> quchen cool
04:39:27 <quchen> bollu: Parsing GHC‚Äôs output is not a priority, because it contains lots of primops that I don‚Äôt support anyway
04:39:41 <bollu> quchen right
04:40:18 <quchen> bollu: Also add a quasiquoter so it can be written nicely, [stg92| main = {} \u {} -> ‚Ä¶ |] etc
04:40:44 <bollu> quchen hmm, OK. I haven't written a quasiquoter before.
04:40:53 <quchen> bollu: It‚Äôs super simple
04:41:09 <quchen> Well, maybe not super simple, but simple. ;-)
04:41:15 <bollu> xD
04:41:16 <bollu> OK
04:42:05 <quchen> bollu: You can pretty much copypaste the QuasiQuoter.hs module
04:42:47 <bollu> I see
04:42:49 <bollu> will do.
04:43:10 <phadej> I also like that final pretty printer work has "In future work, it would be interesting to explore an adaptation of Bernardy‚Äôs algorithm to a final pretty printe"
04:43:18 <phadej> pretty printer *paper
04:43:57 <phadej> it gives me better looking json documents :)
04:44:30 <quchen> edwardk: If you could expose the Doc type from ansi-wl-pprint somehow that would be a huge help
04:44:39 <quchen> edwardk: I‚Äôm not sure how to do this exactly though
04:44:48 <edwardk> i'm very open to patching it to expose everything in a .Internal module
04:45:16 <quchen> What I‚Äôm doing is having all logic in .Internal, and the actual module is just a projection of that
04:45:23 <edwardk> quchen: anything you want access to? just toss a patch exposing a .Internal module with it. standing rule in any of my packages
04:46:16 <quchen> edwardk: You could give me push access to ansi-wl-pprint, but I could also just do it as a pull request
04:47:34 <quchen> edwardk: Design-wise, would you agree with ¬ªmove everything to Internal, haven a reexport-only module for the general public¬´?
04:47:59 <edwardk> quchen: added
04:48:01 <edwardk> sure
04:48:01 <quchen> It‚Äôs a bit awkward because the main module is empty, but it‚Äôs the only way to expose the internals :-/
04:48:09 <edwardk> i do this as a common pattern
04:48:09 <quchen> Cool, thanks!
04:48:22 <edwardk> you have access to ansi-wl-pprint, wl-pprint-extras and wl-pprint-terminfo
04:48:41 <edwardk> do as you will if you think its non-controversial, save pull requests for stuff you think is "edgy" ;)
04:48:55 <quchen> I am now a squire in the Kingdom of Kmett! ;-)
04:49:07 <ventonegro> congrats!
04:49:17 <bollu> quchen :D
04:49:34 <mniip> hahaha
04:49:58 <edwardk> quchen: thank you for submitting to my dominion
04:50:27 <mniip> so I wonder
04:50:36 <mniip> what happens to Hask in presence of dependent types
04:50:40 <quchen> newtype Ran f g a = Ran { getRan :: forall b. f a -> (a -> g b) -> g b }
04:50:43 <quchen> Oh my it‚Äôs beginning
04:51:03 <quchen> Probably wrong, but good enough for a squire.
04:52:13 <Wizek> mniip, I tried to reconstruct deleteTMapK without `unBook . book` mimicing [`Bookkeeper.delete`][2] and I run into these type errors: https://gist.github.com/Wizek/e5883d0181ab8b7c7616fcbf62ca2e89#file-5-hs [2]: https://hackage.haskell.org/package/bookkeeper-0.2.1.1/docs/Bookkeeper-Internal.html#v:delete
04:52:19 <mniip> from what I gather eisenberg proposes that "pi a ->" is a single quantifier
04:52:35 <mniip> how does that work out with the (->) hom-profunctor?
04:53:54 <mniip> "pi (x :: a) ->" rather
04:55:48 <mniip> meh, I should catch goldfire on irc
04:55:50 <bollu> mniip pi as the HoTT pi?
04:55:54 <mniip> got lotsa questions
04:56:07 <mniip> bollu, not sure what HoTT pi is, but it's a relevant dependent quantifier
04:56:19 <bollu> mniip yeah, same thing then
05:09:16 <Wizek> mniip, Do you have some ideas about why the kinds don't line up here: https://gist.github.com/Wizek/e5883d0181ab8b7c7616fcbf62ca2e89#file-5-hs ? And/or how I could make them aligned?
05:13:51 <Myrl-saki> Where can I find the Haskell parser?
05:14:15 <cocreature> Myrl-saki: are you asking which file in GHC is responsible for parsing?
05:14:53 <ventonegro> Or looking for Happy?
05:14:59 <mniip> haha, "file"
05:14:59 <Myrl-saki> cocreature: Yeah. Other parsers are also appreciated if it produces a better AST.
05:15:26 <cocreature> Myrl-saki: if you don‚Äôt want to depend on ghc, there is haskell-src-exts
05:15:48 <cocreature> Myrl-saki: if you‚Äôre fine with a dependency on ghc you can use https://hackage.haskell.org/package/ghc-exactprint-0.5.4.0/docs/Language-Haskell-GHC-ExactPrint.html#v:parseModule
05:16:01 <Myrl-saki> cocreature: Oh right. I searched ext in base. Had a vague idea. THanks.
05:16:05 <cocreature> or figure out which functions are called by that and call the ghc api directly
05:16:15 <cocreature> Myrl-saki: haskell-src-exts in not in base
05:16:20 <cocreature> it‚Äôs a separate package
05:16:37 <Myrl-saki> cocreature: Yeah. I think I asked people here and got pointed to haskell-src-exts. I only remembered the ext part. :P
05:16:44 <Myrl-saki> (3 months ago or so?)
05:18:54 * alanz <flamebait>wonders how long before HSE is not getting new-project usage</flamebait>
05:19:30 <cocreature> alanz: well there is a cost associated with depending on the ghc API
05:19:38 <cocreature> so I don‚Äôt think haskell-src-exts is going to go away
05:20:06 <alanz> I know. But if it is your compiler, and HSE is keeping up with it extension/syntax wise
05:20:38 <alanz> It won't go away, I just wonder about people starting new projects, and the choices they make. 
05:21:03 <alanz> Its just an idle thought, no agenda.
05:22:05 <rntz> say I have some typeclass C and a type A and A implements C in two different ways. the standard way to handle this is a newtype A' wrapping A. that's fine. is there any nice way to *write* the (instance C A' where ...) that avoids having to wrap and unwrap A' all the time?
05:22:27 <mniip> rntz, coerce?
05:22:36 <mniip> :t Data.Coerce.coerce
05:22:37 <lambdabot> Coercible a b => a -> b
05:23:12 <rntz> hm, I'll take a look at that
05:23:24 <rntz> I've been finding more and more things aren't in hoogle these days - Data.Coerce doesn't seem to be there, for example
05:23:27 <rntz> is hoogle just... out of date?
05:23:34 <sproingie> very
05:23:41 <rntz> :/ is there an alternative people use?
05:23:45 <cocreature> rntz: use http://hoogle.haskell.org/
05:24:06 <sproingie> hayoo is a bit more recent
05:24:29 <rntz> ... hoogle.haskell.org is distinct from haskell.org/hoogle. that's, uh, a minefield.
05:24:50 <cocreature> I should try convincing neil to finally switch haskell.org/hoogle to the new version
05:24:53 <sproingie> that's haskell's site for you
05:25:22 <sproingie> cocreature: i'd hope that "no type search" thing is fixed first
05:25:47 <alanz> There is some explanation in here: www.haskellcast.com/episode/012-neil-mitchell-on-development-tools
05:25:48 <cocreature> sproingie: fair point, personally I never used the type search for anything
05:25:55 <sproingie> it's my main reason to use hoogle in the first place and not just googling with hackage in the terms
05:27:09 <cocreature> sproingie: also ‚Äúno type search‚Äù is not really correct. it has a type search, it‚Äôs just less advanced than the old one afaik
05:27:16 <cocreature> e.g. http://hoogle.haskell.org/?hoogle=(a%20-%3E%20b)%20-%3E%20%5Ba%5D%20-%3E%20%5Bb%5D
05:27:28 <mniip> woah
05:27:33 <mniip> even my packages are in there http://hoogle.haskell.org/?hoogle=combineSum
05:27:40 <cocreature> mniip: all of stackage is in there
05:28:25 <mniip> I should get acme-iot into stackage
05:28:26 <sproingie> http://stackage.org has a hoogle search box too
05:30:07 <rntz> hm, coerce seems to be more about runtime cost than about convenience of unwrapping
05:30:40 <rntz> by which I mean, (map deconstructor lst) and (coerce lst :: [UnwrappedType]) are about the same level of boilerplate
05:31:11 <cocreature> rntz: nothing is going to magically unwrap things for you
05:31:55 <Myrl-saki> hoogle looks weird as sans serif... http://cdn.rawgit.com/ndmitchell/hoogle/4933119f71f9c9982e02595e6e542cbe44e7496e/html/hoogle.png
05:32:17 <sproingie> just needs a different font for the lambda
05:32:38 <lyxia> rntz: If you have many arguments and their types are inferrable from their uses, you can write    mymethod = coerce $ \x y z -> ...   instead of    mymethod (A' x) (A' y) (A' z) = ...
05:32:39 <sproingie> different font entirely, really
05:32:51 <Myrl-saki> sproingie: Or we can pick serif fonts. :D
05:33:03 <cocreature> sproingie: I‚Äôm sure neil doesn‚Äôt mind a PR :P
05:33:25 <rntz> lyxia: yeah, that's effectively what I'm doing, except the types aren't entirely inferrable
05:33:34 <sproingie> honestly, both hoogle and hayoo need better names
05:33:39 <rntz> if I took out the type annotation on the call to Coerce, it yelled at me
05:33:47 <rntz> s/call to Coerce/call to coerce/
05:33:57 <sproingie> coerce doesn't make any sense without an explicit type
05:34:09 <Myrl-saki> Well.
05:34:12 <rntz> oh, wait, you're suggesting coercing the whole *function*
05:34:14 <rntz> hm.
05:34:18 <Myrl-saki> Making a zipper out of this seems harder than I thought lol
05:34:27 <Myrl-saki> Maybe I should just emulate a zipper.
05:34:48 <lyxia> rntz: or you can define the unwrapped function with an explicit signature
05:35:09 <lyxia> but you're still going to need annotations if it's polymorphic in any way
05:36:04 <mniip> 1498048186 [15:29:46] <rntz> hm, coerce seems to be more about runtime cost than about convenience of unwrapping
05:36:10 <mniip> coerce can do multiple wraps/unwraps
05:37:20 <newhoggy> new
05:40:31 <rntz> hm, coerce on functions does seem to work nicely if they're type-annotated. I think I'll just define the functions at top-level & then do "instance C A' where foo = coerce toplevelFoo; ...". thanks lyxia!
05:42:36 <sproingie> would GNTD do the trick?
05:42:55 <mniip> sproingie, they want a nominally different instance I thought
05:44:43 <sproingie> hm can one override ad-hoc the auto implementations from deriving clauses?
05:45:13 <sproingie> GNTD will make the module not Safe, but that may or may not be a problem
05:45:22 <rntz> here, none of the auto implementations would be useful anyway
05:45:28 <rntz> it's a completely different instance
05:45:49 <Cale> sproingie: By not deriving the class and instead writing an instance
05:48:46 <rntz> I guess "newtype A' = A' A deriving Foo" is roughly equivalent to "instance Foo A' where foo = coerce (foo :: ... the type of foo for A ...)"?
05:49:05 <zipper> Myrl-saki: bzzz
05:49:09 <Myrl-saki> zipper: lol
05:49:17 <sproingie> well if the instance does something different, nothing will give you that for free
05:50:23 <rntz> yeah, of course the actual code that implements the instance I'm going to have to write :)
05:50:31 <rntz> I'm just looking to avoid as much as possible of the converting-to-and-fro boilerplate
05:50:43 <rntz> anyway, coerce seems to work fine for my use case
05:50:54 <sproingie> i'm told GNTD (though not useful here) uses coerce under the covers
05:51:31 <sproingie> the docs don't say tho, just some random blog post implies it
05:53:51 <c_wraith> sproingie: to the best of my knowledge, it doesn't.  It uses the role system that is also used by coerce.
05:54:10 <c_wraith> sproingie: but GND just says "if you need this instance, use that one"
06:06:58 <jjane> Hi!
06:07:21 <jjane> I'm having a problem with Haskell IO. I have an 'a', and Haskell wants me to use an 'IO a'.
06:07:24 <jjane> Here is a pastebin:
06:07:25 <jjane> https://pastebin.com/7bt8kdM5
06:07:57 <jjane> I thought I could 'lift' the input, but that is seemingly not the case. Can anyone help?
06:08:19 <sproingie> pastebin's hilighting is ... 
06:09:03 <sproingie> contents should be just a string
06:09:09 <sproingie> contents <- hGetContents handle
06:09:28 <jjane> sproingie: the issue is with the fmap at the end
06:09:32 <jjane> the first one is fine
06:09:49 <ventonegro> jjane: they are not needed
06:10:09 <ventonegro> if you use the syntax sproingie showed you
06:10:23 <jjane> ok, let me try that
06:10:37 <sproingie> ah hm.  but jjane is right, i just got sidetracked by that noise
06:10:53 <Cale> jjane: You probably meant to use mapM rather than fmap
06:11:23 <Cale> jjane: Simply constructing a list of IO actions isn't enough -- you probably wanted to actually run each of them
06:11:38 <jjane> Cale: that helped. Thank you very much!
06:11:43 <Cale> jjane: There is a function called sequence which will stitch a list of IO actions together into a single action you can run
06:11:57 <divVerent> actually, forM_ or mapM_ probably would work best
06:12:01 <Cale> sequence [] = return [] -- if the list of actions is empty, produce an action which does nothing except to return the empty list when run
06:12:02 <divVerent> given you don't care for the () putStrLn returns
06:12:23 <Cale> sequence (x:xs) = do v <- x; -- if the list of actions is nonempty, we first run the first one
06:12:33 <divVerent> \x -> putStrLn (show x) is actually putStrLn . show
06:12:46 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs -- and then glue the rest together and run that, getting a list of the rest of the results
06:12:54 <divVerent> and putStrLn . show is also known as print
06:13:02 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and finally produce a complete list as our own result
06:13:17 <divVerent> so that last fmap line becomes: mapM_ print res
06:13:27 <Cale> In terms of sequence, we can build lots of useful things, like mapM
06:13:36 <Cale> mapM f xs = sequence (map f xs)
06:14:08 <divVerent> also, (\x -> splitOn "\n" x) can be written as (splitOn "\n")
06:14:15 <Cale> i.e. we apply the function to each of the elements of the list to get a list of actions, and we perform each of the actions in turn, collecting a list of results
06:14:53 <Cale> (there's also sequence_ and mapM_ which discard results when we don't care about them)
06:31:30 <zomg> I'm using Network.HTTP.Simple and this seems to suggest it throws an exception on non 2xx codes https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Simple.html#v:setRequestIgnoreStatus
06:31:46 <zomg> But that's not happening for me - is it a bug or am I doing something wrong?
06:32:16 <zomg> basically the request just does this `resp <- httpLBS =<< (parseRequest . unpack $ url)`
06:32:56 <cmotoche> Hello everyone. Is correct that `stack build` always recompiles all the dependencies? Is there a way to only build the files of my project?
06:33:33 <sproingie> it builds them once, same as cabal, then caches them
06:33:37 <zomg> cmotoche: at least for me it just rebuilds the files which were affected by my changes. Ie. if I only change my Main, it usually rebuilds that, but if I change my lib file which is used by other modules, it needs to rebuild them all
06:34:15 <lyxia> zomg: "Request created by this function won't cause exceptions on non-2XX response status codes." https://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Conduit.html#v:parseRequest
06:34:38 <cmotoche> Mmm then something weird is happening :-/
06:35:31 <sproingie> are these dependencies regular libraries off hackage or are they subprojects?
06:37:31 <zomg> lyxia: argh...
06:37:46 <zomg> I'd expect this from a JavaScript library
06:37:47 <sproingie> subprojects will go through a whole build, though it should still only rebuild what changed.  git dependencies can be a bit touchy and rebuild all the time
06:37:47 <zomg> :D
06:38:19 <sproingie> er, sometimes want to rebuild all the time that is
06:39:55 <sproingie> lyxia: possibly it still throws for malformed input?  the docs are pretty unclear.
06:40:29 <sproingie> tho the problem seemingly is with not throwing
06:40:58 <lyxia> possibly
06:41:09 <zomg> I don't really see what is the connection between creating a request with parseRequest and the status code of the *response*
06:41:10 <sproingie> the whole method feels a little janky
06:41:20 <zomg> that's why I totally missed it :P
06:41:23 <sproingie> s/method/function/
06:41:57 <zomg> I guess it must be some internal things with the lib with wrapping the lower level api
06:43:52 <sproingie> the special case of parsing the method out from the url, needing it to be all-caps ... convenience overload is silly
06:45:37 <Cale> sproingie: Let me know if you end up writing a better http client library in anger ;)
06:46:19 <Cale> (which supports tls)
06:46:43 <sproingie> i accidentally a http client :)
06:47:00 <lyxia> "oops"
06:47:58 * mekeor doesn't understand a sentence without a verb
06:48:26 <sproingie> not too hard to a sentence without a verb if you by context :)
06:49:49 <zomg> ITT: english
06:50:26 <Myrl-saki> I just realized how hard it is to zipper a source code.
06:50:37 <zomg> well, think that would also work in finnish but you'd have to use enough filler words to make it resemble a sentence more :P
06:50:46 <Myrl-saki> Maybe I can convert an AST to a rose tree.
06:51:49 <sproingie> rose tree ... WP is unhelpful there.  is that the only property, unbounded branches?
06:52:39 <zomg> welp, I guess I solved the parseRequest error by simply substituting it with fromString :P
06:52:56 <zomg> since I didn't actually use any of the other features of it besides just turning a string into a request
07:00:31 <sproingie> in Request.hs, fromString = parseRequest_
07:01:39 <sproingie> which is just parseRequest unwrapped, hardwiring throw as the exception
07:04:34 <sproingie> looks like not throwing is the default for Request, other request building functions install a checkResponse that throws on a non-200 
07:08:08 <heebo> hello im trying to use different functions to parse different json structures into the same types
07:08:49 <heebo> im using Aeson fromJSON 
07:10:15 <heebo> I dont know how to structure the program, i cant use typefamilies because the json should all parse to the same type, albeit from different original json structures
07:10:23 <heebo> any ideas?
07:18:30 <lyxia> do the json structures overlap, meaning that depending on how you interpret a JSON value, you may get different Haskell values?
07:19:30 <heebo> no they dont
07:20:11 <lyxia> Then you can write a parser for each format and compose them using <|>
07:20:57 <glguy> heebo: then you just won't be able to use the FromJSON class, parse them without it
07:21:01 <sproingie> specific example here: https://artyom.me/aeson#more-interesting-choices
07:21:10 <sproingie> shows you how to use the Alternative instance
07:21:18 <heebo> thanks
07:21:33 <glguy> that class is just a convenience, not required for using the library
07:22:09 <heebo> yes i think the fromJSON is tricky - im using httpJSON from http-conduit, but its making things more complex i feel
07:22:15 <sproingie> can be a very convenient convenience.  but yeah nothing necessarily wrong with peeking and using a plain 'if'
07:22:55 <glguy> sproingie: if the different json structures come from different places, if isn't needed
07:23:15 <sproingie> i assumed they might be mixed up in the same app
07:24:24 <heebo> yes i know what parser to apply ... its just that httpJSON call is trying to infer it from implementations of fromJSON
07:25:19 <heebo>  all these conveniences are bloody inconvenient
07:25:30 <sproingie> it's up to fromJSON to select the right parser
07:26:04 <heebo> sproingie: but thats driven from the return type
07:27:06 <heebo> sproingie: of which they are all the same
07:27:13 <glguy> and what determines which format you want to use?
07:28:14 <heebo> glguy: the website
07:29:04 <glguy> no like you find yourself with a json value, how do you know which format you expect it to be
07:29:28 <glguy> there are a couple of them you said, what determines how you should process this one
07:29:50 <heebo> glguy: ah .... not sure , i guess you cant
07:29:55 <sproingie> if you're overriding an existing FromJSON and just manually picking a different parser ... maybe wrap it in a newtype?  i'm not entirely sure what the current code looks like.
07:30:24 <glguy> heebo: so you want to parse something but you don't know what format it's in?
07:30:42 <glguy> but you know it's one of a couple formats?
07:31:05 <heebo> i have 3 sites, they have known json structures of books
07:31:32 <sproingie> if you're not sure which format applies when you get the json back, then all you can do is try both formats, using alternatives or just peeking
07:31:33 <heebo> i want to scrape all three sites into a Book value
07:31:52 <sproingie> (or i suppose all three formats in this case)
07:32:23 <glguy> that means if you know which site you're visiting, you know what the format is
07:32:35 <heebo> if i do httpJson "http://site1" I know I want to use parser1 say
07:32:36 <glguy> and you can pick the appropriate parser
07:32:41 <sproingie> so there are no existing FromJSON instances for Book?  then you're golden, write one fromJSON to rule them all
07:32:45 <heebo> glguy:yes
07:33:13 <heebo> but httpJson uses fromJSON to determine the parser
07:33:20 <glguy> then don't do that
07:33:54 <heebo> and fromJSON uses the same type for all 3 sites
07:34:00 <glguy> or pick different book types per json format
07:34:28 <glguy> or don't use httpJson, or write a single FromJSON instance that can parts any of the formats
07:35:17 <glguy> with different types per JSON format you can still process those all into a common type after using httpJson
07:35:40 <heebo> how by pattern matching the constructor?
07:36:03 <sproingie> that tutorial i linked covers that case i believe
07:36:14 <sproingie> (multiple constructors that is)
07:36:18 <heebo> it seems wasteful to create a massive alternative parsing structure when i know the parser that should be used
07:36:33 <sproingie> if you know ahead of time, just use different types and convert after
07:36:39 <heebo> ok ill look at it sproingie: 
07:37:45 <sproingie> the problem i usually run into is poorly-specified json that needs alternative parses, but if the formats are fixed and known ahead, you really have three different types at least as json is concerned
07:39:30 <heebo> sproingie: that is an elucidating observation
07:39:38 <heebo> thank you
07:40:15 <sproingie> then you can parse them into FooBook, BarBook, BazBook etc then convert those to a generic Book later.  which keeps everything neat and separate
07:52:48 <quchen> edwardk: Ummm the CI for ansi-wl-pprint fails for GHC <= 7.2
07:52:56 <quchen> Is that something you still want to support?
07:53:08 <edwardk> if its broken, feel free to cut it off.
07:53:30 <edwardk> i mostly care about the last 3-5 ghc releases
07:53:50 <edwardk> 3 is my floor for anything, 4 is nice, 5 is about my limit ;)
07:54:14 <sproingie> anyone done complex game rule systems like RPGs?  looking at D20/pathfinder for example, i'm struck by how much of it is defined by a small core of base mechanics, then everything else as exceptions to those mechanics.
07:54:26 <edwardk> 8.2, 8.0, 7.10, 7.8, 7.6  -- 7.6 is about as far back as i really care about, too much stuff just doesn't work before then 
08:03:37 <aphorisme> Hello! In a general abstract non-sense sense, I've structures which provide a fold (lists, trees) which enables me to "step through the them", "deconstructing" them. Is there also an opposite notion of fold which enables me to constructing such structures?
08:04:33 <ertes-w> aphorisme: unfolds a.k.a. anamorphisms
08:05:07 <ertes-w> aphorisme: the recursion-schemes library has both general folds (catamorphisms and friends) and unfolds (anamorphisms and friends)
08:05:51 <aphorisme> Nice, thanks a lot.
08:10:53 <heebo> unfold
08:11:11 <heebo> oops late to the party with that one
08:11:38 <heebo> also see the origami programming paper.... 
08:14:19 <aphorisme> heebo: by Gibbons? 
08:17:12 <byorgey> aphorisme: yes, that's the one
08:20:04 <aphorisme> Thanks.
08:23:31 <halogenandtoast> I'm a little shocked that my runEitherT works here: https://gist.github.com/halogenandtoast/274ab63eca2c16c2e75b86d68b76e4c6
08:23:45 <halogenandtoast> Is that code normal usage or am I being crazy
08:30:33 <sproingie> first pattern looks a little gnarly ... nested Eithers i guess?  otherwise looks cromulent to me
08:30:35 <glguy> halogenandtoast: Line 4 looks like a bad idea
08:31:26 <halogenandtoast> glguy: have (Right req) on the left?
08:31:32 <sproingie> line 4 being the gnarly part.  not sure what a failed match will do there.
08:31:37 <glguy> halogenandtoast: Yeah
08:31:48 <glguy> halogenandtoast: and then the two liftIO lines don't need to be inside the runEitherT
08:32:08 <glguy> and now you're down runEitherT of a hoistEither, so you don't need an EitherT
08:32:30 <glguy> Failed pattern match there just calls fail in IO
08:33:33 <halogenandtoast> glguy: without the EitherT my method looks like this: https://gist.github.com/halogenandtoast/c426b607eb810143884b30bdcf39aad1#file-slackbot-hs-L46
08:33:40 <sproingie> probably not what you want if you're otherwise handling exceptions
08:33:40 <halogenandtoast> and I didn't like the nested Either
08:33:55 <glguy> halogenandtoast: That's an improvement, but it's probably not the best you can do
08:33:59 <ph88^> could someone help me understand the trace i made? https://bpaste.net/show/5f3951520c63  some numbers are not as they expect them to be. Question is on the last line (114)
08:34:00 <glguy> halogenandtoast: Those two don't even implement the same thing
08:34:22 <halogenandtoast> glguy: interesting, they both compile, type check, and produce the expected results
08:34:29 <halogenandtoast> my expectations might be too week.
08:34:30 <glguy> halogenandtoast: then don't handle errors the same way
08:34:31 <halogenandtoast> *weak
08:34:33 <glguy> so they aren't the same
08:35:27 <glguy> halogenandtoast: It's not a good idea to catch SomeException
08:35:31 <glguy> as another issue
08:35:36 <halogenandtoast> so on error the first example won't return IO Nothing?
08:35:39 <glguy> unless you're going to immediately rethrow it
08:35:48 <glguy> halogenandtoast: correct
08:36:10 <halogenandtoast> glguy: yeah I didn't like putting SomeException, but I wanted the code to swallow anything for now.
08:36:14 <halogenandtoast> I don't care about the error
08:36:35 <glguy> That code will intercept other errors, like if the user pressed ^C or if a thread was killed
08:37:08 <glguy> pattern match failure in EitherT isn't caught by EitherT
08:39:44 <halogenandtoast> is there a better way to handle: parseRequest :: MonadThrow m => String -> m Request
08:41:51 <halogenandtoast> seems like the exception I care about is InvalidUrlException
08:42:44 <MitchellSalad_> you can call that at the type 'String -> Maybe Request' if you'd like
08:42:55 <glguy> halogenandtoast: https://gist.github.com/halogenandtoast/274ab63eca2c16c2e75b86d68b76e4c6
08:43:44 <glguy> Yeah, if the type's that flexible, not allowing it to throw an exception at all sounds nice
08:45:58 <halogenandtoast> glguy: thanks I'll try to understand what you've posted
08:46:27 <glguy> halogenandtoast: In light of the type of parseRequest we can probably make something nicer with ExceptT, actually
08:47:01 <halogenandtoast> MitchellSalad_: thanks for pointing that out
08:48:19 <halogenandtoast> glguy: what about: https://gist.github.com/halogenandtoast/274ab63eca2c16c2e75b86d68b76e4c6#gistcomment-2129058
08:48:49 <glguy> halogenandtoast: That's looking better. I'd get ride of this either (const Nothing) (headMay . bggApiItemIds)
08:49:00 <glguy> rid*
08:49:22 <glguy> listToMaybe is already in base, you don't need headMay
08:49:26 <glguy> but I'd use a case anyway
08:49:44 <halogenandtoast> just expanding out the `either`?
08:49:53 <glguy> and the headMay
08:53:20 <halogenandtoast> glguy what is the ($!)?
08:53:25 <halogenandtoast> wait I can answer that
08:53:44 <Cale> f $! x = x `seq` f x
08:54:18 <mniip> http://tcpst.net/7xk2.png
08:55:10 <sproingie> i keep getting the JustNotThatIntoYou quantifier
08:56:06 <halogenandtoast> Cale: I guess I don't understand seq and how it would be different from applying a function
08:56:12 <halogenandtoast> > (+1) $! 2
08:56:14 <lambdabot>  3
08:56:27 <sproingie> $! is just a strict $
08:56:49 <mniip> halogenandtoast, consider
08:56:51 <halogenandtoast> sproingie: that explains why I don't understand it then.
08:56:57 <mniip> > (False &&) undefined
08:56:59 <lambdabot>  False
08:57:00 <Cale> halogenandtoast: If the function doesn't necessarily pattern match on the argument, seq will ensure that the argument is evaluated anyway.
08:57:02 <mniip> > (False &&) $! undefined
08:57:04 <lambdabot>  *Exception: Prelude.undefined
08:57:13 <halogenandtoast> I see
08:57:19 <mniip> literally the only difference
08:57:37 <sproingie> $ is just application, it lets you omit parens because of precedence
08:57:40 <sproingie> f $ x = f x
08:57:52 <halogenandtoast> Now I understand perfectly
08:57:53 <Cale> (it will be evaluated up to the point of determining the outermost data constructor, or in the case of a function, it will evaluate it to the point where it becomes a lambda)
08:58:22 <halogenandtoast> so in glguy's example, what is the purpose? https://gist.github.com/halogenandtoast/274ab63eca2c16c2e75b86d68b76e4c6#gistcomment-2129049
08:58:25 <moema> Hi all, i'm reading a value from the console by calling "inpStr <- getLine". Can anyone tell me how to cast the inpStr to a selfdefined datatype?
08:58:54 <mniip> moema, cast?
08:59:02 <ph88^> moema, you can use  read  or make a parser
08:59:05 <mniip> what kind of datatype are you talking about?
08:59:37 <Cale> halogenandtoast: In that case, it'll make sure that it does enough parsing to determine if the result is Just _ or Nothing before actually returning.
08:59:51 <ph88^> moema, try to make a datatype in your code and then in ghci type    let textual = show myData      and then just type     textual     and    read textual
09:00:10 <moema> i get a string back when i call "inpStr <- getLine". i would like to cast this string to my datatype and call a function what expects this datatype
09:00:16 <halogenandtoast> Cale: hmm, is there any reason it wouldn't do that with $, I can't imagine a case.
09:00:27 <Cale> It would certainly not do that with $
09:00:34 <ph88^> moema,     myData = read inpStr
09:00:37 <Cale> It would return the entire expression unevaluated
09:00:44 <Cale> (the case expression)
09:00:52 <halogenandtoast> Cale: ah
09:01:18 <Cale> only if you pattern matched on the result would it then evaluate the case expression and actually parse
09:01:21 <dfeuer> Is there some simple way to combine cabal install --only-dep with cabal configure? They often share options like --with-ghc.
09:02:17 <halogenandtoast> Cale thanks for the explanation
09:02:28 <Cale> halogenandtoast: But it only likely affects the performance of the program and not the behaviour
09:02:43 <halogenandtoast> I think once I see it a few more times in the wild I will understand it completely, for know I have to take my 60% and roll with it.
09:02:50 <halogenandtoast> Cale: ah, interesting.
09:03:08 <halogenandtoast> I assumed it was doing something more, but that I couldn't understand it yet.
09:03:28 <Cale> halogenandtoast: For example, if *enough* of the parsing is forced to happen here, we might hope that the bytestring from the HTTP response gets garbage collected
09:04:15 <Cale> Whereas if you pass around this unevaluated case expression which contains a reference to resp, we know that it can't be GC'ed yet.
09:06:02 <halogenandtoast> thanks Cale and glguy the code is now much prettier
09:06:07 <Cale> (In fact, probably no references to resp or the response body will exist after the evaluation which is forced to happen)
09:06:34 <Cale> (but I'd have to look at parseLBS to be sure)
09:08:10 <Cale> halogenandtoast: btw, the maybe and either functions are often tempting, but I tend to avoid them because I find that upon returning to code which uses them, I often end up unfolding them into case expressions anyway
09:09:06 <centril> Cale: neh, use maybe & either, it's super nice =)
09:09:16 <Cale> If the code is mathematically the only thing that it could ever be, I'll use them
09:09:26 <Cale> But they're obnoxious to manipulate
09:09:35 <Cale> compared to a case expression
09:09:36 <centril> especially maybe, much nicer than a case
09:09:51 <centril> and pointfree, which is always nice
09:09:58 <Cale> pointfree isn't always nice
09:09:59 <centril> if you can get rid of naming the last argument
09:10:17 <Cale> It's only nice sometimes, and again, it's often harder to edit later
09:10:20 <centril> Cale: it depends on what your base combinators are
09:10:31 <glguy> No, point-free isn't something to strive for, and maybe is only nicer than a case in the simplest of cases
09:10:33 <sproingie> i like keeping it monadic, not knowing it's a Maybe or an Either until i have to
09:10:58 <Cale> Like, right here, I agree with glguy's style :)
09:12:49 <centril> sproingie: well, when you use maybe/either, it is when you are done with the monadic code, i.e: I am a typechecker, type TCComp a = TCEnv -> Either e (TCEnv, a) - all computation is done in that environment, and then, in main, either is used
09:13:16 <Cale> That case expression is full of practical details which are quite likely to be adjusted in the future, and not something to be turned into a crystalline golf ball :)
09:13:33 <sproingie> centril: right, i think we're in agreement there :)
09:13:56 <centril> Cale, glguy: for example, base lacks the combinator  (.:) = (.) . (.)
09:14:05 <Cale> good
09:14:14 <Cale> let it remain that way :)
09:14:22 <centril> noooo :/
09:14:26 <Cale> Lambda exists for a reason
09:14:58 <centril> pointfree = no need come up with names for arguments
09:15:00 <centril> ==> win
09:15:07 <Cale> and, in the cases where you really want to think of it that way, fmap . fmap is probably clearer
09:15:10 <shapr> centril: very hard for newbies to read though
09:15:28 <Cale> You don't need to try very hard at naming arguments that have a small scope
09:15:32 <sproingie> s/newbies/almost anyone/
09:15:36 <centril> shapr: that's cause they are used to imperative programming and not compositional
09:15:44 <maerwald> centril: no
09:15:55 <shapr> centril: sure, I agree. Even so, accessibility is worthwhile.
09:15:57 <sproingie> functional /= obfuscated
09:16:04 <sproingie> otherwise why name anything at all?
09:16:25 <shapr> even after I'd written a bunch of Haskell, point free code was hard to read
09:16:27 <centril> sproingie: Im not advocating obfuscated point free code...
09:16:35 <maerwald> well, I've seen people give argument single character names, because it's cooler. At that point, I agree... it's almost pointless. (pun)
09:16:39 <centril> it's not like I go to pointfree.io and let loose
09:16:50 <sproingie> the boob combinator is crazily obfuscating
09:16:58 <centril> import Data.Function.Pointless
09:17:13 <shapr> maerwald: single char var names are perfect for "wiring patterns" like map where the important part is the shape of the code rather than a significant variable name
09:17:17 <centril> sproingie: it's called the owl combinator
09:17:29 <sproingie> that's a more polite name i suppose :)
09:17:34 <Cale> Names should be shorter with frequency of occurrence, and longer with the size of their scope
09:17:56 <Cale> Perhaps c * log(size of scope / number of occurrences)
09:17:59 <maerwald> shapr: you missed the "because it's cooler" part ;)
09:18:18 <centril> Cale: yes, that sounds like a valid argument
09:18:32 <sproingie> single char var names aren't usually the problem until there's upwards of a half dozen of them in one scope
09:18:33 <shapr> maerwald: that's not important in my own code
09:18:45 <sproingie> it's the explosion of random punctuation operators
09:18:49 <centril> I generally have a rule of thumb: if I have to use flip, I stop writing pointfree
09:18:54 <centril> flip is bad
09:19:01 <centril> friends don't let other friends use flip
09:19:02 <shapr> centril: I like it with lookup
09:19:05 <Cale> sproingie: even then -- if the scope is small, probably not a problem
09:19:15 <shapr> sometimes I want to partially apply the dictionary
09:19:32 <centril> Also, code looking like: (x .) . (y .) is super hard to read
09:19:32 <Cale> sproingie: It's when the scope is large enough that you can't see how each one is defined
09:19:40 <centril> but   unary .: binary is easy
09:20:08 <Cale> I don't mind reading (f .) . g etc. so much now, but I wouldn't write it.
09:20:13 <dfeuer> centril: I don't mind  flip const, but the (equivalent) flip id is rather obnoxious.
09:20:17 <Cale> I read (f .) as fmap f
09:20:18 <ph88^> bbl
09:20:21 <sproingie> some flips are obvious
09:20:50 <dfeuer> er, sorry.
09:20:57 <dfeuer> I mean the equivalent *const id*.
09:21:23 <Cale> and then think in terms of functions as being like containers indexed by their domain
09:21:39 <sproingie> (.) = fmap
09:21:40 <centril> my toolbox is usually, (>=>), (***), (&&&), first, second, <<<, >>>, (.), (.:)
09:22:04 <Cale> Never (>=>)
09:22:11 <Cale> (<=<)
09:22:14 <centril> Always (>=>), so sweet
09:22:16 <centril> haha
09:22:36 <centril> I prefer to read left-to-right
09:22:48 <robertkennedy> > 3 :: Monad m => Int
09:22:50 <lambdabot>  error:
09:22:50 <lambdabot>      ‚Ä¢ Could not deduce (Monad m0)
09:22:50 <lambdabot>        from the context: Monad m
09:23:03 <robertkennedy> Why is that an error and not a warning?
09:23:04 <Cale> Grepping for actual occurrences of (>>=) and (>=>) in the code is an easy way to find shit that I need to delete from our codebase and replace.
09:23:13 <Cale> Well, >>= can be followed by \case
09:23:17 <Cale> But otherwise, no.
09:23:29 <glguy> robertkennedy: Try that in GHCi so that you get the whole type error
09:23:52 <centril> Cale: what's wrong with >=> ... if you have small action-producing functions, you can chain them at the end
09:23:54 <centril> super nice
09:24:00 <centril> much nicer than do-notation
09:24:02 <Cale> centril: <=< is always better
09:24:03 <dfeuer> Cale: I wonder if lamba expressions should have been written from right to left...
09:24:06 <Cale> to read
09:24:22 <centril> Cale: <=< is fine, if you use =<<
09:24:23 <dfeuer> e <- p\ =<< m
09:24:36 <Cale> yeah, and =<< is better than >>= most of the time too
09:24:43 <centril> Cale: but I like to have my lambda to the right
09:24:45 <sproingie> frankly <=< and >=> are both fine, you just follow the arrow
09:24:45 <Cale> If you're actually going to use the operator
09:24:55 <dfeuer> Which would also mean flipping case.
09:24:59 <sproingie> if you're mixing them up willy-nilly then well, you've probably got other problems
09:25:00 <Cale> If you can't use =<< comfortably, you shouldn't be using either one
09:25:10 <Cale> With one exception being \case
09:25:17 <centril> Cale: well, I use \case a lot
09:25:21 <glguy> robertkennedy: Why were you expecting that to be a warning instead of an error?
09:25:32 <dfeuer> Cale: any time you want a lambda expression there, it's easier to use >>=.
09:25:40 <centril> dfeuer: yeah
09:25:48 <Cale> dfeuer: If you want a plain lambda there, you should be using do-notation
09:25:51 <centril> I'd actually like  fmap :: f a -> (a -> b) -> f b
09:26:33 <robertkennedy> glguy: I'm not sure why the compiler cares about the spare type variable. maybe it desugars to a forall and then thinks I'm dependently typing?
09:26:37 <Cale> and if you're using do-notation, =<< and <=< read so much better
09:26:45 <dfeuer> The trouble with >>= et al is that they don't match our function appliication syntax.
09:26:46 <Cale> (and even if you're not...)
09:26:53 <centril> And I'd like an operator:  (a -> f a) -> (b -> c) -> (a -> f c)
09:27:08 <glguy> robertkennedy: To use a value the compiler knows that it's going to need to instatiate that value to some monomorphic type
09:27:11 <centril> Cale: anyways... this is splitting hairs, (<=<) is fine by me
09:27:22 <glguy> robertkennedy: But you've given the value a polytype that it won't be able to instantiate
09:27:22 <dfeuer> If we'd flipped function application syntax, maybe we'd be better off with >>=, >=>, >>>, and so on?
09:27:31 <Cale> dfeuer: yes
09:27:38 <Cale> dfeuer: also, flipped do-notation, perhaps
09:27:41 <dfeuer> Maybe that would've been better altogether,
09:27:43 <sproingie> that would be od
09:27:48 <glguy> robertkennedy: There will be no way to determine the substitution for type 'm'
09:28:02 <dfeuer> because Monad and Applicative are very left-to-right.
09:28:08 <dfeuer> I dunno.
09:28:22 <dfeuer> Every argument has a strong counter-argument.
09:28:30 <Cale> :)
09:28:32 <centril> im fine with having both (>>>), (<<<), (>=>), (<=<), (>>=), (=<<)
09:28:35 <dfeuer> So I guess we just deal with the occasional awkwardness.
09:28:55 <centril> but I'd like equivalents for (*>), (<*)
09:28:59 <sproingie> i'm a fan of a written programming language following along with the underlying writing system.  left to right, top to bottom, works for me.
09:29:04 <dfeuer> ($), (&)
09:29:19 <robertkennedy> glguy: not sure I understand why the compiler can't ignore the extra type variable, but I think I understand what you're saying
09:29:40 <glguy> robertkennedy: They aren't extra, they're being used
09:30:31 <glguy> robertkennedy: We need to be able to solve the Monad m constraint in this case but with no way to know what m is
09:30:33 <sproingie> glguy: not in that example of 3 :: Monad m => Int
09:30:54 <glguy> sproingie: Yes, m is being used right in the place where it is written
09:31:08 <Cale> altmappend (cn ^? _ConversationId_Direct >>= SP.other i) (cn ^? _ConversationId_Sidebar . _1 >>= exclusiveOther i)
09:31:22 <Cale> -- I don't care who wrote this, if I ever have to edit it, I will be upset with them
09:31:39 <mniip> sproingie, the typechecker can't tell 3 from  return () `seq` 3
09:31:42 <glguy> There's no rule that says constraints must be satisfied except if you weren't really using them in the implementation anyway
09:32:22 <centril> Cale: I'd also like a passthrough combinator, like: (<=>) f g a = do b <- f a ; _ <- g b ; pure b
09:32:34 <Cale> No you wouldn't.
09:32:34 <centril> (<=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m a)
09:33:03 <Cale> Trust me, you don't want to have to maintain code with that in it several months after you wrote it.
09:33:20 <centril> in fact, I made a little gist for combinators i love: https://gist.github.com/Centril/4b8fa94514971a101caf59fc02f90cd1
09:33:43 <cocreature> just use do notation instead of adding more combinators
09:33:47 <Cale> All of this sort of thing seems super cute until you actually go and use it, and find out what it's like to work with code that uses it
09:34:00 <sproingie> imagine how you'd compose that
09:34:00 <centril> Cale: i did use all of this =)
09:34:09 <Cale> or someone *else's* code which uses it
09:34:22 <Cale> (or your own code, after a sufficient amount of time)
09:34:32 <Cale> It's terrible
09:34:37 <centril> Cale: well, it's all about establishing a base line... I can't use this in a big project because only I know the combinators
09:34:43 <centril> Cale: the same reasoning goes for Lens
09:34:52 <mniip> :t (>>= (ap $ (>>) . ?f))
09:34:53 <lambdabot> (?f::a1 -> m a, Monad m) => (a1 -> a1 -> m b) -> a1 -> m b
09:34:55 <centril> it has too many unknown combinators
09:35:26 <mniip> :t (>>= (>>= ((>>) . ?f)))
09:35:28 <lambdabot> (?f::a1 -> m a, Monad m) => (m b -> m b -> a1) -> m b -> m b
09:35:36 <mniip> eh whatever
09:35:43 <centril> Cale: but... if more combinators were in base, like Control.Monad, and Data.Function, they'd be part of the common baseline everyone knows
09:35:51 <sproingie> and abuses
09:36:03 <glguy> centril: Being in base doesn't mean it's appropriate to obuscate code with it
09:36:07 <centril> sproingie: abuses is entirely subjective
09:37:00 <centril> glguy: well, I argue it is not obfuscation
09:37:20 <glguy> You mentioned that
09:38:20 <centril> also, if you make your combinators look similar to others that are semantically similar, it becomes more readable
09:39:03 <Cale> If I had to blindly choose between maintaining code that was written by someone who just finished really getting the lens library, and someone who had never bothered to look at it, I would bet on the second guy's code being way less painful to work on.
09:39:42 <centril> Cale: obviously true
09:39:58 <sproingie> lots of people learn by overdoing then dialing it back down 
09:40:01 <centril> Lens has an inflation of combinators
09:40:13 <Xion__> Can I select between DeriveAnyClass and GeneralizedNewtypeDeriving when I get the "defaulting to X" error on a case-by-case basis??
09:40:30 <glguy> Xion__: You will be able to in GHC 8.2, but not before
09:40:37 <Xion__> ;/
09:40:47 <glguy> Before that it's best to turn off DeriveAnyClass
09:40:51 <Cale> Xion__: My recommendation would be to turn off DeriveAnyClass
09:40:52 <mclark1129> I'm using a MultiParameter Typeclass to define a relationship between 3 types.  Is it possible to define a function that has a Type Constraint that includes all parameters?
09:41:00 <Cale> It's a very silly extension anyway
09:41:10 <mclark1129> e.g - class Aggregate a b c where --blahblahblah
09:41:17 <sproingie> and yeah the combinators in Lens are ... noisy.  can't much be helped though
09:41:20 <centril> Cale: useful for marker classes w/o functions
09:41:23 <centril> like Partial =>
09:41:39 <centril> wait, Partial takes zero types
09:41:40 <Xion__> yeah I'm not sure why we have it, let me try
09:41:45 <mclark1129> I know for a single parameter type class it would be sometihng like (Aggregate a) => a -> b
09:42:03 <mclark1129> With a MPTC is it jsut (Aggregate a b c) => a -> b -> c?
09:42:04 <Xion__> Oh perfect, turns out it was useless :)
09:42:16 <Cale> mclark1129: uh, sure? I'm not sure what the function part is about
09:42:31 <Cale> mclark1129: but yes, you use the same syntax in the constraint that you do in the class/instance head
09:42:35 <centril> mclark1129: yeah, tho, you might need injectivity in some cases depending on what the functions are
09:42:49 <centril> mclark1129: consider using associated types instead (TypeFamilies)
09:43:45 <mclark1129> I can look into TypeFamilies, although the MPTC does work in the way I expect for my particular use case.  Extreme beginner here so I can't speak to whether or not it's the most idiomatic way
09:44:03 <Cale> mclark1129: Probably you're fine with the MPTC.
09:44:09 <centril> class Aggregate a where type B a :: * ; type C a :: *; ...
09:44:34 <Cale> Associated types are somehow rarely as nice.
09:44:49 <Cale> (but sometimes they're much nicer!)
09:45:04 <centril> mclark1129: well, is it possible to have  Aggregate a b c, Aggregate a d f ?
09:45:31 <mclark1129> Possibly, but in my case probably not
09:45:45 <centril> then ==> associated types, otherwise ==> MPTC imo
09:45:56 <mclark1129> It's a DDD/CQRS scenario, so you're defining a concept that has an associated State, Command, and Event
09:46:14 <mclark1129> it would be extremely rare for any member of that triple to apply in different cases
09:46:38 <centril> mclark1129: is some type in the triple the "dominant"?
09:47:18 <mclark1129> not really no, I'm using functional dependencies as well so that the presence of one infers the others
09:47:18 <mclark1129> https://stackoverflow.com/questions/44569993/creating-generic-typeclasses-in-haskell
09:47:40 <centril> associated types buys you the ability to know that if I have type X, then if B is a associated type constructor, I can get B X
09:47:55 <sproingie> associated types start looking tempting now
09:48:24 <centril> it's a combination of type level functions + functions in a neat type class package
09:48:32 <Cale> mclark1129: What are you going to do with this class?
09:48:46 <Cale> mclark1129: Do you have code which works with an arbitrary Aggregate triple?
09:49:04 <mclark1129> Yeah
09:49:26 <Cale> Well, fair enough :)
09:49:52 <mclark1129> So for example, I would be able to write a handler that could handle Command, apply it to a State, to result in an Event
09:50:01 <centril> mclark1129: but you said it was injective, i.e b -> a, c -> a
09:50:34 <Cale> mclark1129: Without actually pattern matching?
09:50:57 <mclark1129> The definition of the pattern matching is what the person who defines the instance sets up
09:51:09 <Cale> well, okay
09:51:13 <mclark1129> Basically "When you have Command X, it results in state y"
09:51:35 <Cale> Another option you may want to consider is
09:52:08 <Cale> data Aggregate state command event = Aggregate { execute :: state -> command -> [event], apply :: state -> event -> state }
09:53:05 <Cale> But I have no idea how this is going to get used, so I can't say what would be better
09:53:40 <centril> yeah, a record like that might be nice too - tho, associated type families gives you nice type inference
09:54:33 <mclark1129> Cale I can't say which would be better either!  
09:55:11 <centril> mclark1129: use associated types if you have a dominant type in the triple, otherwise MPTCs, use records if you might have "many instances" for the same triple
09:55:42 <mclark1129> centril, Sounds like MPTCs are probably the right then for now.
09:56:26 <centril> mclark1129: might be =)
09:56:26 <mclark1129> So far it been fairly intuitive for what I'm trying to accomplish, but again coming at it as a complete novice.
09:56:47 <mclark1129> The type inference has been so good in some cases that it's felt completely magical!
09:56:58 <centril> mclark1129: three functional dependencies are a bit uncommon tho =)
09:57:16 <centril> remove the fundeps and it will get very less magical very fast
09:57:23 <mclark1129> lol
09:57:38 <mclark1129> Well part of the reason for my original question is that I'm going back to add explicit type annotations for my functions
09:57:50 <mclark1129> even though they're inferred, when I screw something up it becomes quickly difficult to track it down
09:58:10 <mclark1129> And Real World Haskell said ("You might be tempted to infer everything, dont...")
09:58:11 <Cale> mclark1129: So yeah, you'll be constraining things by  (Aggregate state command event) => ...
09:58:33 <centril> mclark1129: do note that associated type families also allow for injectivity declarations if need be
09:58:52 <mclark1129> Are type families part of vanilla haskell?
09:58:57 <Cale> mclark1129: no
09:59:03 <centril> no, and neither are MPTCs
09:59:12 <mclark1129> centril That was what scared me at first
09:59:25 <mclark1129> I'm not used to the idea of language extensions really
09:59:36 <Cale> There's a lot of stuff which is underspecified at present
09:59:37 <mclark1129> made me feel like "If this was a good idea, why didn't they put it in the language natively?"
09:59:45 <centril> {-# LANGUAGE TypeFamilies, TypeFamilyDependencies #-}
09:59:56 <Cale> But even if this stuff eventually ends up in the Haskell Report, it will probably remain as extensions to a base language
10:00:08 <Cale> It's sort of nice that it's modular
10:00:16 <centril> mclark1129: there are a lot of very nice things that are not part of vanilla haskell, because the standard moves slowly
10:00:20 <johnw> is TypeFamilyDependencies a new spelling for FunctionalDependencies?
10:00:35 <centril> johnw: it's "functional dependencies" for type families
10:00:44 <centril> FunctionalDependencies are for MPTCs
10:00:46 <mclark1129> Cale I agree now, at first it felt like I was writing code that only worked on a very specific implementation of haskell
10:00:55 <johnw> centril: cool, hadn't heard of it yet
10:01:11 <mclark1129> which felt weird, like I wasn't writing a Haskell program, I was writing a "My own special snowflake haskell that doesn't apply to anyone beyond me"
10:01:14 <centril> mclark1129: I recommend this guide, http://dev.stephendiehl.com/hask/#the-dangerous
10:01:25 <Cale> mclark1129: Well, as far as language frontends go, GHC is the only realistic option at the moment. But GHCJS is a thing -- it's very highly compatible with GHC
10:01:35 <centril> Cale: purescript ?
10:02:11 <centril> mclark1129: that is very common, Haskell is awesome for writing EDSLs
10:02:23 <centril> one of the best prototyping languages by far
10:02:42 <centril> Haskell over python any day - even beats Groovy imo
10:02:43 <mclark1129> Well I'm still very early in my journey, but it's definitely made side projects more exciting
10:03:27 <centril> mclark1129: just avoid DatatypeContexts, OverlappingInstances, IncoherentInstances, ImpredicativeTypes, AllowAmbigiousTypes and you'll be fine
10:03:43 <mclark1129> I've been trying to have my functional "Ah-ha" for many years... So far I think Haskell's helping me make a bit more progress than F#.
10:03:47 <centril> if you are really picky you can also put UndecidableInstances on your no-no list
10:03:54 <sproingie> DataTypeContexts are pretty easy to avoid, being useless in the first place
10:04:07 <centril> sproingie: yeah, just ==> GADTs
10:04:20 <centril> or smart constructors depending on context
10:04:27 <mclark1129> I definitely instinctively avoid anything that feels like "This normally wouldn't compile, but just add this extension so we'll look the other way"
10:04:45 <mclark1129> although technically that are all the extensions I suppose
10:05:01 <centril> mclark1129: no, some extensions are purely syntactic
10:05:10 <centril> such as TupleSections and LambdaCase
10:05:30 <centril> mclark1129: LambdaCase for example allows you to replace  \x -> case x of ...   with \case ...
10:06:02 <mclark1129> Well it's all still definitely cool.  It's even made me interested in category theory, seems like that would help get the most of the language.
10:06:20 <sproingie> overlapping/incoherent instances can be done case-by-case now anyway
10:06:55 <centril> I'd also probably avoid TypeApplications, cause being positional about type arguments to functions in System F is kinda brittle
10:06:56 <sproingie> instance {-# overlapping #-} Foo
10:07:12 <Cale> mclark1129: I would say CT is nice enrichment eventually, but is *mostly* a diversion from improving at Haskell.
10:07:18 <centril> sproingie: and how does the compiler pick ?
10:07:33 <sproingie> centril: same way it always does, it picks the worst one :)
10:07:57 <sproingie> stealing idris's named instances would be handy
10:08:06 <centril> sproingie: Rust allows for specialisation if a type is strictly less general than another
10:08:51 <sproingie> haskell also does it by generality, it's when you have multiple parameters that things get really hairy
10:09:31 <centril> right
10:09:59 <centril> Cale: well, CT is a nice way to find new concepts with duality and other stuff
10:10:16 <Cale> CT is a way to find the right definitions for studying new concepts
10:10:18 <centril> so as a discovery-method it is nice
10:10:41 <mclark1129> Well basically I think I fell into the "So... what is a Monad?" trap
10:10:43 <centril> Cale: I think i meant that
10:10:52 <ggVGc> mclark1129: the real question is, how useful is catergory theory to writing software
10:10:55 <ggVGc> :)
10:11:01 <sproingie> i'm thinking of doing some CT diagrams in embroidery, i bet they'd look pretty
10:11:03 <Cale> I would also recommend moving it up on your todo list if you have an interest in other areas of mathematics
10:11:15 <centril> ggVGc: kinda useful imo
10:11:20 <sproingie> mebbe a cross stitch on the wall saying "Hom Sweet Hom"
10:11:38 <Cale> The more branches of mathematics which you have familiarity with, the more fun it will be to study category theory -- but no other branches of mathematics are actually *required*
10:11:51 <centril> it starts like this... 1. some category theorist thinks of something, 2. edwardk makes a hackage package out of it, 3. you use it, 4. profit
10:12:12 <mclark1129> centril Lol
10:12:15 <Cale> https://hackage.haskell.org/package/category-printf
10:12:15 <centril> sometimes the category theorist is edwardk
10:12:26 <Cale> ^^ you might like that :)
10:12:37 <sproingie> just finished the first CT series on youtube, now i know a monad is a monoid in the category of endofunctors, and there *is* no problem :)
10:12:53 <mclark1129> sproingie Arg...
10:13:06 <centril> sproingie: also, a comonad is a comonoid in the category of endofunctors
10:13:19 <sproingie> i still need to use comonads in anger sometime
10:13:27 <mclark1129> I'm trying to follow Category Theory for Programmers, but so far it's still so abstract
10:13:39 <mclark1129> "Like what IS even code, man?  Trippy....."
10:13:43 <sproingie> mclark1129: the videos are better
10:13:57 <mclark1129> sproingie: That's what I'm watching
10:13:58 <centril> sproingie: I wanted to write "A monad is just a monoid in the category of endofunctors. What is the problem?" in my bachelors thesis in the theoretical background
10:14:03 <Cale> I laughed *so* hard while writing that category-printf library
10:14:03 <Cale> and it actually turned out surprisingly usable
10:14:20 <Kristjan55555> Hello hot 33 y male searching for husband, send me your cunt pictures first! ok....waiting..
10:14:34 --- mode: ChanServ set +o Cale
10:14:38 <maerwald> lolwat
10:14:39 --- mode: Cale set +b *!*Kristjan5@85.253.192.50.cable.starman.ee
10:14:39 --- kick: Kristjan55555 was kicked by Cale (Kristjan55555)
10:14:40 <sproingie> someone has their categories confused
10:14:48 --- mode: Cale set -o Cale
10:15:17 <centril> he was sending mixed messages
10:15:20 --- mode: ChanServ set +o glguy
10:15:21 --- mode: glguy set -b+b-o *!*Kristjan5@85.253.192.50.cable.starman.ee *!*@85.253.192.50.cable.starman.ee glguy
10:15:24 <Cale> That mask could have been better
10:15:25 <Cale> yes
10:15:26 <Cale> thanks
10:15:39 <centril> Cale: Eilenberg‚ÄìMoore categories ?
10:15:45 <centril> (co-Kleisli)
10:15:49 <DrYucatan> Does anyone know of any tools/libraries to automatically desugar Haskell source code
10:16:10 <DrYucatan> i'm trying to get some desugared do-notation for a presentation
10:16:11 <Cale> centril: no -- the category of maps W a -> b for some comonad W
10:16:35 <Cale> centril: In this case, it's the comonad (->) m (where m is a monoid)
10:16:51 <quchen> DrYucatan: Desugared Haskell code is not something you want to read. It‚Äôs not just about do-notation: desugaring also removes nested pattern in case expressions, it doesn‚Äôt have list comprehensions, it doesn‚Äôt have list literals even.
10:16:53 <centril> oh, it is just Kleisli^Op
10:17:01 <Cale> So a formatter here is essentially a function  (m -> a) -> b
10:17:03 <quchen> DrYucatan: Is there something specific you‚Äôd like to have desugared?
10:17:08 <centril> Cale: so a comonad category
10:17:16 <sproingie> if it's do-notation, lambdabot has @undo
10:17:47 <quchen> DrYucatan: There‚Äôs a pretty good case that GHC‚Äôs Core language is desugared Haskell, but it‚Äôs also a compiler IR, so not made for human consumption
10:18:10 <sproingie> Core is surprisingly easy to follow once you get past the fugly identifiers
10:18:54 <centril> quchen: I guess it depends on whether or not a desugared program should be able to get typechecked in the original grammar/AST-form or not
10:18:57 <cocreature> DrYucatan: fwiw if you only need desugared do-notation, lambdabot has an @undo command and there is probably a standalone package behind that somewhere
10:19:01 <Cale> centril: Daniel Patterson gave a talk at the NY Haskell meetup -- which had a bunch of unfortunate technical issues (slides weren't showing up properly and were really required to follow things...), but he talked about "composing continuations" to combine formatting specifiers
10:19:04 <centril> quchen: usually the answer is "no"
10:19:33 <Cale> centril: and defined a function ((String -> b) -> c) -> ((String -> a) -> b) -> (String -> a) -> c
10:19:41 <ph88^> something is going wrong with my trace, could someone have a look?  https://bpaste.net/show/5f3951520c63
10:20:06 <centril> Cale: so in (m -> a) -> b, m is the "final result", and a, b are?
10:20:10 <Cale> centril: and I was sitting there thinking "I bet that's a composition for a category we already know..."
10:20:16 <Cale> and then I figured out which
10:21:36 <Cale> Well, m is the type of string we're formatting, and a and b are sort of marking off how the type of printf would change if we appended on this format specifier
10:22:24 <Cale> It's actually easier to follow once you fold everything up and use either Cokleisli or the Format type synonym I defined
10:22:40 <centril> Cale: so m must also be the type of the final result then, no?
10:23:45 <Cale> Well, okay, so eventually we're going to end up with something of type m -> a for some type a (which might be a function type)
10:24:11 <centril> interesting
10:24:30 <Cale> Er, sorry
10:24:32 <cobreadmonster> Hello.
10:24:43 <Cale> That was backward
10:24:52 <Cale> We're going to supply something like  putStrLn  :)
10:25:00 <Cale> putStrLn :: String -> IO ()
10:25:04 <centril> wait, how do we get Monad (Cokleisli w a) but not Comonad ?
10:25:05 <Cale> if m = String, say
10:25:32 <Cale> It's just the reader
10:26:32 <Cale> Cokleisli w a ~= (->) (w a)
10:27:30 <centril> so runCokleisli :: w a -> b, w = (m ->), runCokleisli :: (m -> a) -> b ?
10:27:46 <Cale> yeah, it just unpacks the function
10:28:30 <Cale> So we apply runCokleisli to the formatter, and then supply the "printing function" as an argument to that
10:28:38 <Cale> If we supply id
10:28:45 <Cale> then we get an sprintf-like thing
10:29:00 <Cale> if we supply putStrLn, then we get a printf-like thing
10:31:10 <centril> ill have to check it out later =)
10:31:49 <Cale> So, a string literal bit, won't change the type of printf, so we have
10:31:58 <Cale> c :: Monoid m => m -> Format m a a
10:32:24 <centril> Cale: ill need to do a more in-depth reading to grep it
10:32:32 <centril> do you have a paper?
10:32:35 <centril> on it?
10:32:40 <Cale> No, haha
10:32:51 <Cale> It's kind of ridiculous
10:33:02 <Cale> Though I suppose papers have been written about sillier things
10:33:20 <centril> Cale: btw - completely unrelated...
10:33:24 <centril> what do you think of Alga?
10:33:37 <Cale> c is implicitly applied to string literals, using OverloadedStrings
10:33:39 <centril> I was a bit disappointed that weights are not discussed at all in the paper
10:33:43 <Cale> Alga?
10:34:14 <centril> Cale: https://github.com/snowleopard/alga-paper/releases/download/hs-submission/alga.pdf
10:34:25 <centril> "Algebraic Graphs with Class"
10:35:52 <Cale> I don't know about this representation of graphs...
10:37:01 <centril> Cale: elaborate?
10:37:35 <Cale> Well, first of all, how expensive is neighbours going to be?
10:37:58 <Cale> It looks expensive, and that's not an operation I would want to be expensive.
10:38:02 <centril> Cale: both outgoing and incoming or just one of those?
10:38:08 <Cale> Even just one of those
10:39:20 <Cale> The class they define for manipulating graphs looks a little more plausible, if only because you could then choose a much better representation :P
10:40:36 <centril> Cale: hmm, so outgoing is at the best case for  a -> (b,c,d,...) = a -> b + a -> c + a -> d
10:40:48 <centril> might take a long time to search
10:41:05 <DrYucatan> quchen, cocreature, thanks for the recommendation re: lambdabot
10:41:20 <centril> Cale: right, we can always use Array and get O(1) access
10:41:28 <centril> brb, food =)
10:41:50 <Cale> Data.Map is usually better overall
10:42:00 <Cale> since you want to be able to do stuff like merging them
10:42:11 <Cale> (especially if you're going to implement this interface)
10:42:37 <centril> Cale: I think there's an interface for monadic graphs
10:42:51 <centril> then we can use IO and use mutable vectors
10:45:46 <Lokathor> https://lokathor.gitbooks.io/using-haskell/content/roguelike/primer.html alright folks i've got a minimal "how to glance at haskell source" guide for non-haskellers
10:46:18 <[exa]> Hm. What's the proper name for the member of ADT structure? E.g. the underscored stuff in:  Data Tree = Branch _Tree_ _Int_ _Tree_ | Nil
10:46:22 <Lokathor> more examples will come later, it's part of a larger ongoing project, my question for the moment is if i said anything about haskell that's definitely wrong
10:46:23 <[exa]> Fields?
10:46:33 <lyxia> fields
10:46:34 <Lokathor> fields works
10:46:57 <vise890> hi all. I need to serialize some data in an old, weird format. Sometimes there is a need to have a Schema/Spec to actually encode that data. How would I design a type class to encode these constraints?
10:47:36 <Lokathor> vise890, you'll have to say more. Is the schema needed or not per type? or per serialization? or what's the deal there
10:47:48 <glguy> vise890: Where do you see typeclasses fitting in?
10:47:54 <lyxia> Lokathor: what is that, are you writing a game tutorial in Haskell?
10:48:40 <Lokathor> lyxia, yes there's a roguelike dev group "go through the tutorial" deal this summer, and i won't work in Python, so i'm doing a Haskell version, and some folks wanted to know more
10:48:42 <Lokathor> so here we are
10:48:59 <[exa]> Lokathor: goood. :]
10:49:08 <[exa]> Thanks for the fields anyway
10:53:42 <lyxia> Lokathor: I don't see anything wrong but it looks quite dense
10:55:49 <ertes-w> Lokathor: minor UX note: i had to click the text with the mouse, otherwise keyboard scrolling wouldn't work‚Ä¶  there is probably something that grabbed the keyboard focus
10:55:54 <ertes-w> (on the web page)
10:56:09 <ertes-w> (i have JS disabled via NoScript)
10:57:28 <sproingie> how does something grab the focus when you're not running js?
10:57:29 <Lokathor> ertes-w, well GitBook is doing a lot of that unfortunately for me :/
10:57:33 <Lokathor> also that
10:57:57 <Lokathor> i suspect there's more than one focus region, and without JS the default one isn't the scrollable one
10:58:31 <sproingie> much as i love noscript, i've had to take a blacklist approach to using it nowadays rather than a whitelist
10:58:32 <vise890> Lokathor: the schema is needed on a per serialization basis . it's got things like the the separator character between fields and their order
10:59:23 <Lokathor> vise890, so you want something like serializeThing :: (Serializable s) => Maybe Schema -> s -> String
10:59:46 <vise890> there are quite  a few parallels with csv here. let's say i have the value encoded as a HashMap, but i need a spec telling me in which way to write them down
11:00:18 <vise890> yes, i think we can drop the Maybe 
11:00:45 <vise890> my question is, in the implementation of Serializable for my type T, how do i then access the schema?
11:01:01 <Lokathor> ahhh, like that, hmmm
11:02:04 <Lokathor> uh, typeclass Serializable s where serializeToString :: Schema -> s -> String ?
11:02:24 <Lokathor> assuming i wrote that correctly and validly, IRC is always a little hard to tell with it being one line and all
11:04:57 <sproingie> Lokathor: focus is probably on the search box even if it's not showing up.  might be able to fix it with tab order, but i dunno about reliably
11:05:34 <vise890> i think that may work. i'm looking at https://hackage.haskell.org/package/cassava-0.5.0.0/docs/Data-Csv.html#t:ToNamedRecord and i'm gonna do some more reading, it looks like i can get some pointers there 
11:05:38 <vise890> thank yo, Lokathor: 
11:05:51 <geekosaur> sproingie, check for an ISINDEX on the search box
11:06:10 <sproingie> isindex hasn't been a useful thing since html 3.0
11:06:22 <geekosaur> btu browsers still honor it
11:06:27 <geekosaur> (annoyingly)
11:06:30 <sproingie> maybe in quirks mode
11:06:38 <Lokathor> sproingie, sadly I don't have much control over that. Most of it is just markdown files, the page generation is all dont be gitbook, or mdbook, or whatever the program is called
11:07:04 <sproingie> Lokathor: yeah that it renders at all without script is probably good enough.  having to click to focus the scrollable area is pretty standard.
11:07:57 <ertes-w> sproingie: HTML 5 has something for that
11:08:13 <ertes-w> it's the autofocus attribute IIRC
11:08:37 <sproingie> only on input boxes
11:08:39 <Unicorn_Princess> I made it to Applicative.hs in the data61 course, and I have to define the applicative instance for ExactlyOne, among others. should I be using the helper functions defined in ExactlyOne.hs (mapExactlyOne, bindExactlyOne, etc.), or just pattern-match against the ADT constructor? I mean, in this case, both are trivial, but what about when they won't be - what does the course -want- me to do?
11:09:27 <sproingie> focusing an arbitrary dom element to receive keyboard events can only be done with JS afaik
11:10:13 <Lokathor> lyxia, density is a problem, but I'm not sure that you can make a page or two describe all of how to read haskell without getting dense about it
11:10:45 <Lokathor> The actual project I want to write as fluently as possible, so I end up having to explain a lot at once in the preview page I think
11:13:18 <lyxia> Unicorn_Princess: I think you're supposed to define the instance from scratch
11:13:34 <lyxia> Unicorn_Princess: as if you had only the type declaration and nothing else
11:13:40 <Unicorn_Princess> kay, thanks
11:14:15 <lyxia> Lokathor: Okay, I'm not sure what would be a better approach.
11:14:32 <sproingie> Lokathor: is your tutorial for teaching haskell, or for showing how to build a game using haskell?
11:14:38 <sproingie> i'd suggest the latter is easier to start with
11:14:44 <Lokathor> the hope is that they'll read a real book about it once they see that it's interesting and not stuffy
11:15:11 <Lokathor> sproingie, everyone else is following a particular roguelike tutorial in Python/Javascript/etc
11:15:17 <Lokathor> I'm going along in Haskell is all
11:15:33 <Lokathor> http://www.roguebasin.com/index.php?title=Complete_Roguelike_Tutorial,_using_python%2Blibtcod is the "classic", among roguelike folks
11:15:45 <sproingie> i'm familiar with the python version of that tutorial.  it's not my favorite thing in the world.
11:16:06 <Lokathor> many deficiencies >_<
11:16:08 <Lokathor> yes
11:16:27 <kosmikus> it's cool. we need more roguelikes in Haskell :)
11:16:42 <Lokathor> but that's the summer project the subreddit is doing, so i thought i'd go along, and might as well record it
11:16:48 <sproingie> the architecture could be worse though, and there's some oversimplification made for tutorial purposes
11:17:15 <sproingie> but i don't see many people getting beyond the oversimplified design.  or if they do, they invent some half-assed entity system instead
11:17:30 <Tuplanolla> I recently wrote a physics engine for one, but then got bored and froze the project, kosmikus.
11:17:32 <Lokathor> it is a shame
11:17:40 <Lokathor> I think that ECS might have a good home in Haskell though
11:17:56 <Lokathor> not sure how else you'd best organize your creatures and items and such
11:18:08 <Lokathor> i mean maybe just some huge Vector Monster, or whatever
11:18:11 <sproingie> yes and no, you don't use surrogate ids like most entity systems do
11:18:29 <Lokathor> oh?
11:18:32 <sproingie> composition is still supremely important of course
11:19:01 <kosmikus> Tuplanolla: too bad.
11:19:05 <sm> Lokathor: nice project
11:19:26 <Tuplanolla> That happens every time, kosmikus. It's impossible for me to push a game project past the physics.
11:19:50 <Tuplanolla> Maybe after retirement...
11:19:59 <kosmikus> heh
11:20:05 <sm> "all kinds of fancyness with types"..."won't affect your compiled program's speed the slightest" - not sure about that
11:20:39 <kosmikus> sproingie: I'm obviously biased, but I'm quite impressed with what mikolaj has been doing with LambdaHack / Allure
11:20:42 <Lokathor> well your compile time goes up, but your runtime result is the same
11:20:46 <Lokathor> no?
11:20:57 <sproingie> maybe, maybe not
11:21:07 <sproingie> newtypes don't add any overhead, most other abstractions aren't free
11:21:20 <Lokathor> hmm, suppose so
11:21:34 <Lokathor> i'll repharse it a bit
11:22:35 <sproingie> a lot of other factors go into performance, i'd probably just leave that out entirely
11:22:57 <sm> "The big difference between let and do" - there is also the other kind of "let", in do, which will confuse unless you explain it
11:23:16 <Lokathor> You can do all sorts of fancyness with types, ..., and your program won't be bogged down with constant runtime type checks.
11:23:22 <Lokathor> how about that?
11:23:37 <Lokathor> with any runtime type checks.*
11:23:40 <sproingie> true enough for this purpose :)
11:24:10 <Lokathor> sm i mention a the end that you can use let within a do block
11:24:15 <Lokathor> at the*
11:25:12 <sproingie> building up from raw opengl seems a little low-level.  what about SDL?
11:25:36 <Lokathor> but then you need to carry around a spare DLL with your program :P
11:25:40 <Lokathor> one whoooooole DLL
11:26:06 <Lokathor> I mean sure you could use SDL, but Hexes is already written anyway, so that part i'm not worried about
11:27:10 <sproingie> true, i'm just thinking later stuff like sound will go smoother with SDL
11:27:27 <sproingie> not that sound is usually a priority in roguelikes
11:28:10 <Lokathor> fair point. I wrote Hexes as "curses without the C baggage", but didn't consider sound at all
11:28:41 <Tuplanolla> You mean bell?
11:29:58 <Lokathor> i mean like music :P
11:30:04 <Lokathor> I guess i'd need to use openAL or something
11:30:23 <Lokathor> whatever lets the program ship as a single binary without any data or dll files
11:30:57 <Tuplanolla> You mean pc speaker?
11:31:03 <Lokathor> sure
11:31:21 <Tuplanolla> For an authentic Rogue-like experience everything has to be terrible.
11:31:28 <sproingie> it's opengl, beeping the terminal window isn't really a thing
11:31:55 <sproingie> targeting straight gl makes a good gl demo anyway
11:32:35 <Lokathor> maybe i can just render the soundwave on the screen and let them look at the sound effects
11:33:13 <kosmikus> Tuplanolla: well, true. I'm old school. for me, roguelikes should be ascii and no sound.
11:33:29 <kosmikus> Tuplanolla: which doesn't mean that they cannot still have a physics engine though :)
11:33:56 <Lokathor> I actually know a guy who submitted a bug in nethack that got fixed in 3.6
11:34:03 <Lokathor> you could even call it a "physics engine" bug
11:34:26 <Lokathor> had to do with levitating over lava when you froze it, you'd get stuck in ice, even though you were levitating
11:34:32 <sproingie> i tried hacking on nethack for a time.  it's ... the worst C code i have ever seen.  ever.
11:34:37 <Tuplanolla> There are lots of fun discrete simulation methods in physics that could see applications in Rogue-likes.
11:34:59 <sproingie> thankfully they did at least write portable horrible C code, so it wasn't hard to compile as c++
11:35:00 <Lokathor> yeah nethack is pretty bad. Rogue isn't so bad, it's just exceedingly ancient
11:35:17 <ph88^> could someone take a look at my paste please? https://bpaste.net/show/5f3951520c63 i don't understand the flow of the data with the trace
11:35:24 <Lokathor> like, "we refuse to give full names to things that's too many bytes in the file" levels of ancient
11:35:34 <benzrf> .
11:35:45 <sproingie> i started porting some of NH's guts to modern c++ then decided this was a really bad idea
11:36:42 <sproingie> Lokathor: nethack is full of terrible naming too, short and meaningless names
11:37:01 <Lokathor> rnz is the best random method ever though
11:37:02 <sproingie> "glib" is my favorite
11:37:04 <Lokathor> let's be real about that
11:37:22 <sproingie> then there's the entire monster AI loop called "dochug"
11:37:53 <Lokathor> for all those times you want to do a chug
11:38:10 <sproingie> i was ready to chug my bottle of tequila after seeing that
11:38:25 <Lokathor> ƒâugu, they call it in esperanto
11:38:36 <sproingie> call of ƒâugu
11:39:34 <sproingie> the NH codebase is kinda fascinating archaeology though
11:40:19 <ystael> sproingie: Crawl was supposedly worse before it became Stone Soup, on account of how it was Linley Henzell's learning-C++ project.
11:40:34 <sproingie> it can't possibly be worse
11:40:37 <geekosaur> it's still pretty horrid though :)
11:40:44 <geekosaur> (dcss)
11:40:44 <Lokathor> ystael, we're talking pretty bad here
11:43:09 <ystael> Lokathor: I know roughly how bad Nethack is, I tried to read through it back in the early 90s as a learning-C project. I don't imagine it's changed too much.
11:43:22 <mclark1129> is it acceptable to use more descriptive names when using type arguments?
11:43:47 <ertes-w> mclark1129: use the same rules you use for other variables
11:43:48 <Lokathor> I tried to sit down and seriously learn how it generates dungeons once, and I gave up after a few hours because stuff was all over the place
11:43:58 <geekosaur> it is, when they're appropriate. (one issue with Haskell is enough things are generic that it's hard to come up with a better name than 'a' or 'm'...)
11:44:06 <Lokathor> mclark1129, please be as descriptive as you'd like
11:44:16 <ertes-w> mclark1129: take :: Int -> [a] -> [a]  -- there is simply no point in choosing more a verbose name here
11:44:30 <ertes-w> s/more a/a more/
11:44:53 <ertes-w> mclark1129: with types often the constraints are much more descriptive than any name could be
11:45:11 <mclark1129> Ok sounds good! I just usually see the a, b, c so I just was wondering if that convention was preferred
11:45:16 <sproingie> Lokathor: the fact that everything is scattered all over the place is the biggest problem, yeah
11:45:17 <ertes-w> f :: (UrlLike a) => [a] -> IO ()  -- again, the constraint explains it
11:45:28 <ertes-w> so little point in using a more verbose name
11:47:35 <ertes-w> mclark1129: if you're interested in an exception, look at this beauty: https://hackage.haskell.org/package/xmonad-0.13/docs/XMonad-StackSet.html
11:47:43 <sproingie> a, b, and c for generic parameters, 'm a' for a monad, 'f a' for a functor
11:47:56 <ertes-w> that one would definitely benefit from more descriptive names =)
11:48:58 <geekosaur> mostly it would benefit from being burned to the ground >.>
11:49:45 <mclark1129> ertes-w That's exactly the type of thing I'm defining now
11:50:00 <mclark1129> MyType a b c d, but a b d c play a particular function within MyType
11:50:21 <sm> (back) Lokathor: I just speed-read it, but looks good! nice quick pragmatic intro for programmers
11:50:44 <mclark1129> so rather MyType firstPurpose secondPurpose thirdPurpose is better
11:50:52 <mclark1129> (where firstPurpose actually describes its purpose)
11:51:14 <sm> I am curious to find out how digestible the haskell implementation of a real roguelike will be for your audience
11:51:30 <Lokathor> as am i, ha
11:51:32 <sm> (and me :)
11:52:05 <ertes-w> geekosaur: i was waiting for that remark =)
11:52:40 <ertes-w> geekosaur: and i would appreciate that happening
11:53:10 <ertes-w> Lokathor: is that a workshop-like thing?
11:53:45 <sproingie> > Week 1 of the project is the absolute minimal setup process. 
11:53:45 <Lokathor> yeah a lot of folks from the roguelikedev are doing it over several weeks
11:53:45 <Lokathor> https://www.reddit.com/r/roguelikedev/comments/6h4z09/roguelikedev_does_the_complete_roguelike_tutorial/
11:53:47 <lambdabot>  <hint>:1:8: error: parse error on input ‚Äòof‚Äô
11:53:59 <sproingie> i suggest you want to get that down to "Day 1"
11:54:06 <[exa]> Lokathor: did you read the nethack source?
11:54:11 <sproingie> and even on day 1, maybe rendering a single @ on the screen
11:54:16 <Lokathor> [exa], i did a bit once
11:54:22 <sproingie> gives you some confidence that things actually work
11:54:33 <geekosaur> don't know if it ever will because it'd cause so much breakage
11:54:33 <[exa]> I'd call that one "strongly antifunctional"
11:54:57 <kuribas> :q
11:55:02 <sproingie> yet nethack still acquires more patches and updates and additional depth.  it's amazing it works at all.
11:55:04 <geekosaur> otoh having received yet another bug report with ancient stuff and obviously based on the NEVER USE THIS EXAMPLE AS A REAL CONFIG config...
11:55:54 <[exa]> what I wanted to say -- Lokathor, if you manage to write nethack-style source with all the intricacies in haskell, it's going to be extremely cool. :D
11:55:55 <Lokathor> sproingie, i'm just going by what the reddit project is going. they've got bupkis in week 1 so that's what i've got. Week 2 is graphics and moving @ all at once
11:56:04 <kadoban> sproingie: Though it's not exactly a model of correctly maintained software. It went like what 11 years without a release?
11:56:06 <sproingie> Lokathor: ah, didn't know the reddit project moved that slowly
11:56:35 <ertes-w> Lokathor: ah, so your function is being That Haskell Guy/Gal =)
11:56:36 <Lokathor> i would never intentionally write nethack style source (SPJ forgive me for even the thought)
11:56:45 <[exa]> :]
11:57:07 <sproingie> in NH's defense, neither would the dev team now.  how they continue to work with such code (it's not even ansi c) is beyond me
11:57:43 <ertes-w> Lokathor: BTW, i'm pretty sure you're aware, but just in case you're not: the luminance library is really nice, and even the GPipe library is finally seeing updates again =)
11:58:43 <Lokathor> never heard of either of those
11:58:49 <Lokathor> i might check them out
11:58:49 <kadoban> sproingie: You would think that at some point a rewrite would be on the agenda, though maybe that's too hard.
11:58:51 <Lokathor> work time though
11:59:02 <ertes-w> Lokathor: GPipe even has a shader EDSL
11:59:12 <ertes-w> which is its main selling point
11:59:20 <sproingie> kadoban: i think working with the NH source is itself a game for people inclined to hack on it
11:59:27 <sproingie> the source code is the real mazes of menace
11:59:33 <kadoban> Hehe, maybe
11:59:35 <Lokathor> i like hexes because i built it myself, using knowledge i mostly got from tutorials i converted to haskell myself, so it's easy to say "you could build this too, read this to lean how"
11:59:39 <ertes-w> luminance is much more conservative: it's basically a high-level OpenGL
11:59:51 <mniip> so can someone familiar with ghc terminology answer: what's a telescope tyvar?
11:59:53 <sproingie> it was the game for me too, rewriting parts of it that is
12:00:20 <[exa]> sproingie: I'd call it "feature scattering"
12:00:32 <kadoban> sproingie: I couldn't quite get into it. I looked for a bit and ran away in horror and confusion. Though to be fair that's what happened the first time or two I tried to play nethack, and eventually I got into that.
12:00:50 <sproingie> Lokathor: Shader.hs looks really handy.  wrangling shaders is such a pain.  as is all the stateful gunk in gl.
12:00:54 <[exa]> like, some ways of player dying process are in 30 different files, something important in all of them
12:01:11 <Lokathor> as is all of GL really
12:01:13 <Lokathor> oh well
12:01:24 <sproingie> well there's barely 30 different files total and that's part of the problem
12:01:25 * ertes-w can't find hexes on hackage
12:01:48 <Lokathor> https://github.com/Lokathor/hexes github only at the moment
12:02:07 <ertes-w> ah, nice
12:03:05 <sproingie> i'd thought of sending the dev team patches just for basic cleanups, but they still want this thing compiling on 1980's-era platforms and compilers
12:03:14 <sproingie> and i just refuse to work with bad tools
12:04:55 <sproingie> so i drew the line at c++14 and posix
12:05:12 <lennyh> hit me with your coolest one liners
12:05:32 <sproingie> > fix error
12:05:34 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
12:06:46 <ertes-w> @let boolsheet f = join (liftA2 f) [False..]
12:06:46 <lambdabot>  Parse failed: Parse error: ]
12:06:53 <ertes-w> @let boolsheet f = join (liftA2 f) [False ..]
12:06:55 <lambdabot>  Defined.
12:06:59 <ertes-w> > boolsheet (&&)
12:07:01 <lambdabot>  [False,False,False,True]
12:07:40 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
12:07:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:07:59 <ertes-w> > filterM (const [False ..]) "abc"
12:08:01 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
12:08:16 <dolio> sproingie: That's pretty generous. I think edwardk is limiting himself to C++17 and the last one or two generations of Intel CPUs.
12:08:29 <Cale> > nubBy (((>1).).gcd) [2..]
12:08:31 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:09:13 <Tuplanolla> > don't $ do 42 + 13
12:09:15 <lambdabot>  error:
12:09:16 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòf0‚Äô arising from a use of ‚Äòshow_M832945939584...
12:09:16 <lambdabot>        prevents the constraint ‚Äò(Show (f0 ()))‚Äô from being solved.
12:09:24 <Cale> > replicateM 3 [0,1]
12:09:26 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
12:09:39 <sproingie> c++17 didn't add anything i had use for.  when concepts finally land in the c++ standard, i'll switch to using that
12:09:43 <Cale> (counting in binary, via the monad instance for lists)
12:10:44 <ertes-w> > "hello world!" & traverse . letter +~ 13
12:10:46 <lambdabot>  "uryyb jbeyq!"
12:11:46 <ertes-w> > "HELLO world!" & traverse . filtered isUpper . letter +~ 13
12:11:48 <lambdabot>  "URYYB world!"
12:11:50 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to be sorted first by length and then alphabetically")
12:11:52 <lambdabot>  ["a","be","by","is","of","to","and","here","then","bunch","first","words","l...
12:12:38 <mekeor> what are you doin
12:12:40 <sproingie> what kind of weird code is that, i can read that!
12:13:51 <Cale> sproingie: Figuring out how it works is worth doing :)
12:14:22 <ertes-w> > foldr (\x ~(xs, ys) -> (x:ys, xs)) mempty "Bisect me!"
12:14:24 <lambdabot>  ("Bsc e","ietm!")
12:15:02 <benzrf> why the lazy pattern o=
12:15:34 <ertes-w> benzrf: because otherwise you're strict in the recursive case, which makes it spine-strict in the whole list
12:15:47 <ertes-w> > fst (foldr (\x (xs, ys) -> (x:ys, xs)) mempty [0..])
12:15:49 <lambdabot>  *Exception: stack overflow
12:15:50 <ertes-w> > fst (foldr (\x ~(xs, ys) -> (x:ys, xs)) mempty [0..])
12:15:53 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
12:15:54 <Cale> > foldr (\x xs s -> s : xs (s + x)) (\s -> [s]) [1,2,3,4,5] 0 -- perhaps you didn't know foldr could have so many arguments
12:15:54 <benzrf> ah
12:15:56 <lambdabot>  [0,1,3,6,10,15]
12:16:27 <mniip> Cale, return
12:17:05 <Cale> mniip: From whence I came?
12:17:39 <mniip> return as in pure
12:17:40 <ertes-w> Cale: mniip is just using ancient terminology‚Ä¶  you shall be pure and never have any point!
12:18:52 <Cale> mniip: Nah, I'm not really using the Monad structure.
12:19:30 <ertes-w> :t foldr (\x xs s -> pure s <|> xs (s + x)) pure
12:19:32 <lambdabot> (Num t, Alternative f, Foldable t1) => t1 t -> t -> f t
12:19:52 <Cale> I guess you can do that
12:19:54 <bimodal> Pardon me, could someone recommend an example of a particularly well-regarded api client in haskell?
12:20:29 <bimodal> Be that in servant or w/e, I'm curious what folks think is a "good" characterizatoin of the kind of simple work that conects to simple small I/O actions for API calls.
12:20:56 <mniip> > foldr ((((:) <*>) .) . (flip (.)) . (+)) pure [1,2,3,4,5] 0
12:20:58 <lambdabot>  [0,1,3,6,10,15]
12:21:19 <mniip> I wonder what would've @pl inferred
12:21:40 <mniip> @pl foldr (\x xs s -> s : xs (s + x)) (\s -> [s])
12:21:40 <lambdabot> foldr ((ap (:) .) . flip (.) . (+)) return
12:21:48 <mniip> dammit
12:22:06 <mniip> machines stealing our jobs
12:22:37 <Cale> bimodal: If you want a gigantic collection of examples whose quality I'm not sure about, but is probably good, you could look at amazonka
12:23:14 <Cale> http://hackage.haskell.org/packages/search?terms=amazonka
12:23:34 <bimodal> Cale: Thanks, I'll look.
12:23:56 <bimodal> I'm helping someone else clean up an API reference but I'm curious if just the "grab bag of IO actions" design is still popular...
12:24:22 <Cale> It's fine
12:24:25 <Cale> It's all I would expect
12:24:44 <bimodal> The alternative I've seen is to use servant.
12:24:48 <Cale> To be honest, I'm not entirely convinced about the Servant way of doing things yet.
12:25:09 <ertes-w> sometimes with a bunch of type classes that abstract over common concepts like CRUD
12:25:12 <Cale> It seems cool to a point, but annoyingly inflexible
12:25:24 <ertes-w> but those also typically have IO actions for the most part
12:27:00 <bimodal> ertes-w: One thing I've done is make sure that there is a typeclass over a sessoin object so that it's easy to re-interpret the calls as static test results ( client code can test around a library more easily that way).
12:27:14 <Cale> The bugs which Servant's types seem to strive to prevent are not bugs that I run into in practice with value-level combinators for building APIs.
12:27:32 <bimodal> There are value-level combinators for building APIs outside of servant? 
12:27:38 <ertes-w> servant is also one of those things that pull in a giant suite of type-level extensions, and those tend to be awkward to work with
12:27:53 <Cale> Sure, like any of the routing things in one of the webserver libraries
12:28:06 <Cale> There's not as much structure on the client side
12:28:42 <Cale> because you basically only need ways to make a collection of requests independently, rather than having to deal with figuring out which request has been made and what you're going to do about it
12:29:23 <eacameron> I'm still trying to get my groove for working with lenses/records. One thing I don't like about lenses is that you need record to start with in order to start using it. That means I inevitably must use my mangled record field names for constructing the record in the first place, which is annoying. I'd rather keep everything consistent. Anyone have thoughts?
12:29:47 <ertes-w> bimodal: just today i wrote a zabbix-sender implementation at work, and it's literally just a pair of IO actions
12:29:50 <Cale> eacameron: In some cases, you can define a default record
12:29:54 <ertes-w> bimodal: really easy to learn and work with
12:29:57 <eacameron> Cale: How?
12:30:04 <bimodal> Is it preferred to write code constraining against a more generic monaderror for its return value or do people still prefer spcifying Either/Except?
12:30:04 <Cale> eacameron: using something like Data.Default
12:30:13 <Cale> You end up with stuff which looks like
12:30:23 <ertes-w> bimodal: it's not online yet, but i'm going to upload it tomorrow
12:30:24 <bimodal> (it's been 5 years since I shipped haskell someone else would use, sorry for the stacatto questions)?
12:30:26 <Cale> def & foo .~ x & bar .~ y
12:31:09 <Tuplanolla> Consider a `Monoid` instance and empty record syntax too, eacameron.
12:31:28 <eacameron> Cale: ah right. That's...ok.
12:31:32 <ertes-w> bimodal: depending on whether i expect myself to handle errors regularly i use Either or IO
12:31:33 <eacameron> Tuplanolla: Tell me more
12:31:33 <Cale> eacameron: heh, at Obsidian, all our record types are named with fields like _typeName_foo but we've gotten used to it, and don't even bother to use lenses at all most of the time
12:32:08 <eacameron> Cale: Actually it was using Reflex-DOM that got me thinking about how the lenses/records are sort of oddly inconsistent
12:32:37 <Tuplanolla> > set _Left 42 Left {} -- This is possible, eacameron.
12:32:39 <lambdabot>  Left 42
12:33:05 <ertes-w> eacameron: you may find it interesting that GHC treats identifiers starting with "_" as module-local names in the sense that it won't warn you about unused ones
12:33:08 <eacameron> Tuplanolla: Interesting! Do you still get a warning if you don't initialize all the fields?
12:33:18 <pikajude> > Left{}
12:33:20 <Cale> yes
12:33:20 <lambdabot>  Left *Exception: <interactive>:3:1-6: Missing field in record construction
12:33:22 <Tuplanolla> Unfortunately so.
12:33:27 <pikajude> why can you record construct Either?
12:33:43 <Tuplanolla> > () {} -- You can record construct anything, pikajude.
12:33:45 <lambdabot>  ()
12:33:46 <Cale> Tuplanolla: That's really not unfortunate...
12:33:54 <pikajude> why can you record construct ()?
12:34:05 <eacameron> ertes-w: I didn't know that...very interesting.
12:34:08 <mniip> wait whaaaaat
12:34:19 <bimodal> Thanks again for the answers.
12:34:27 <Unicorn_Princess> pikajude: ...a jewish pikachu?
12:34:31 <Cale> I knew you could record pattern match anything, but actually wasn't aware that it was accepted on the construction side
12:34:39 <ertes-w> eacameron: regarding your question: i tend to go with Tuplanolla's suggestion and try hard to make it a Monoid
12:34:40 <Cale> That's actually... bad
12:34:43 <pikajude> well why isn't it an error
12:34:43 <mniip> in Dependent haskell you can write something like, isJust :: (a -> Maybe a) -> Bool; isJust Just = True
12:34:49 <pikajude> () isn't a record type
12:34:56 <pikajude> makes {} sound very hacky
12:35:07 <Cale> It should be an error not to initialise fields -- the fact that it's a warning only is a travesty
12:35:30 <ertes-w> eacameron: for all the other cases i find myself using RecordWildCards regularly
12:35:33 <eacameron> ertes-w: How do I make it a monoid and leverage that?
12:35:38 <Cale> You should at least have to write an explicit error in.
12:35:44 <Cale> If that's what you want
12:36:05 <ertes-w> eacameron: well, you design your types such that they happen to be monoids, then you use 'mempty' as the starting value
12:36:12 <pikajude> @type \ x -> x {}
12:36:13 <lambdabot> error: Empty record update
12:36:17 <pikajude> ...lol
12:36:35 <pikajude> thought you liked those lambdabot 
12:36:45 <Cale> Well, it can't infer the type of x there
12:36:48 <mniip> :t Just {3}
12:36:49 <lambdabot> error: parse error on input ‚Äò3‚Äô
12:36:49 <eacameron> ertes-w: Is there an article explaining this technique?
12:36:49 <ertes-w> @let data X = X { _x1 :: Integer, _x2 :: Bool } deriving (Eq, Ord, Show)
12:36:50 <lambdabot>  Defined.
12:36:58 <mniip> ah yeah, no name
12:37:23 <sproingie> it's general "thinking in types" stuff
12:37:33 <ertes-w> @let instance Monoid X where mappend (X x1 x2) (X y1 y2) = X (x1 + y1) (x2 && y2); mempty = X 0 True
12:37:34 <lambdabot>  Defined.
12:37:56 <sproingie> could use some tutorials on general type-thinking, not sure how they'd go
12:38:09 <eacameron> ertes-w: Oh I see interesting.
12:38:13 <ertes-w> @let x1 f (X x1' x2) = (\x1 -> X x1 x2) <$> f x1'
12:38:14 <lambdabot>  Defined.
12:38:15 <sproingie> as it is now, seems something largely built up by practice
12:38:24 <eacameron> ertes-w: Is that derivable ?
12:38:24 <mniip> > (Sum 3, All False) <> (Sum 5, All True)
12:38:24 <ertes-w> > mempty & x1 .~ 5
12:38:27 <lambdabot>  (Sum {getSum = 8},All {getAll = False})
12:38:27 <lambdabot>  X {_x1 = 5, _x2 = True}
12:38:42 <ertes-w> eacameron: yeah, you can derive product monoids using the generic-deriving library
12:39:02 <eacameron> ertes-w: Wow that's pretty slick
12:39:10 <eacameron> ertes-w: I never mix records with sum types anyway
12:39:30 <ertes-w> eacameron: whenever each factor is a monoid, generic-deriving will give you a product monoid instance, but it's a bit awkward, because you may need things like Sum and All
12:39:40 <Cale> @let data StrictField = SF { strictField :: !Int }
12:39:42 <lambdabot>  Defined.
12:39:45 <Cale> > SF {}
12:39:48 <lambdabot>  error:
12:39:48 <lambdabot>      ‚Ä¢ Constructor ‚ÄòSF‚Äô does not have the required strict field(s): strictField
12:39:48 <lambdabot>      ‚Ä¢ In the expression: SF {}
12:40:24 <mniip> @let data StrictData = SD (!Int)
12:40:29 <lambdabot>  .L.hs:173:23: error:
12:40:31 <lambdabot>      ‚Ä¢ Unexpected strictness annotation: !Int
12:40:33 <lambdabot>      ‚Ä¢ In the type ‚Äò!Int‚Äô
12:40:50 <ertes-w> > (do _x1 <- pure 3; _x2 <- pure True; pure X{..}) :: Maybe X
12:40:52 <lambdabot>  error:
12:40:52 <lambdabot>      Illegal `..' in record construction
12:40:53 <lambdabot>      Use RecordWildCards to permit this
12:40:57 <mniip> huh, can't you do that
12:41:03 <mniip> @let data StrictData = SD !Int
12:41:04 <lambdabot>  Defined.
12:41:07 <ph88^> i figured out that problem i had, it's because of foldr
12:41:08 <mniip> > SD {}
12:41:11 <lambdabot>  error:
12:41:11 <lambdabot>      ‚Ä¢ Constructor ‚ÄòSD‚Äô does not have the required strict field(s)
12:41:11 <lambdabot>      ‚Ä¢ In the expression: SD {}
12:41:15 <ertes-w> eacameron: ^ if you enable RecordWildCards, you can use that, too
12:41:29 <ertes-w> makes creating explicit records a breeze most of the time
12:42:38 <ertes-w> > let _x1 = 3; _x2 = True in X{..}  -- example without a monad
12:42:38 <Cale> RecordWildCards can result in some cute-looking code, particularly with records of functions, but the shadowy nature of it makes it a very questionable extension
12:42:39 <lambdabot>  error:
12:42:40 <lambdabot>      Illegal `..' in record construction
12:42:40 <lambdabot>      Use RecordWildCards to permit this
12:42:43 <sproingie> idris's record update syntax makes me actually not want to claw my eyes out
12:43:01 <eacameron> ertes-w: Yah that's a good way too. But my complaint is that I have to still have to remember *two* field names, one for the record and one for the lenses.
12:43:06 <ertes-w> Cale: yeah, but it's just too nice to work with =)
12:43:19 <eacameron> Cale: FieldNamePuns is awesome
12:43:29 <pikajude> RecordWildCards is the extract() of Haskell
12:43:32 <pikajude> :')
12:43:42 <Cale> sproingie: I dunno, I didn't particularly want to claw my eyes out very much even before seeing Idris' syntax...
12:44:02 <sproingie> we all have our battles
12:44:20 <ertes-w> Cale: i have -W enabled everywhere, which still warns me about genuine shadowing‚Ä¶  and if RWCs really shadows something (or i fail to shadow it myself), i will almost certainly get a type error
12:44:31 <ertes-w> because it's always Y vs. X -> Y
12:44:59 <ertes-w> there is almost no room for error there
12:45:02 <sproingie> did alternative record syntaxes go by the wayside after lens took over the world?
12:45:14 <Cale> Challenge: write a program which prints 0 if RecordWildCards is off, and 1 if it's enabled.
12:46:28 <sproingie> my guess, simple matter of shadowing
12:46:31 <Cale> (this is not particularly hard)
12:47:06 <ertes-w> Cale: how would you even start?  the {..} notation is rejected when RWCs is off
12:47:51 <Cale> Oh, I suppose that's true
12:48:23 <sproingie> {-# LANGUAGE RecordWildcards #-} main = putStrLn 1
12:48:33 <Cale> heh
12:48:41 <Cale> You're halfway there!
12:49:35 <Cale> I was thinking that you could distinguish between two type class instances on the type of the record field name
12:50:05 <Cale> So, the thing which isn't hard can happen easily if you're moving code around blindly
12:50:19 <Cale> But you need the extension turned on at the module level
12:50:34 <Cale> (it just might be active in some scopes and not others)
12:50:53 <ertes-w> -W still warns about real shadowing
12:51:05 <ertes-w> so i have a hard time even coming up with a bad case
12:51:16 <ertes-w> sorry, -Wall does
12:52:03 <sproingie> is there a pragma that enables -Wall, like perl's "use warnings"?
12:52:16 <ph88^> ye
12:52:24 <ph88^> GHC_OPTIONS -Wall  or something like that
12:52:39 <Tuplanolla> You can drop the `GHC_` for common options.
12:55:52 <Cale> http://lpaste.net/356402
12:55:58 <Cale> ertes-w: ^^ :)
12:56:14 <Cale> Mind you, this is very contrived
12:56:26 <Cale> But there is no warning
12:58:41 <PyroPeter> I'm trying to refer to a type variable defined in a functions signature inside a function signature of a local function definition inside a where clause: http://lpaste.net/7024582676631781376
12:58:56 <PyroPeter> (minimal working example)
12:59:07 <Cale> PyroPeter: You want ScopedTypeVariables
12:59:16 <PyroPeter> okay, thanks :-)
12:59:28 <Cale> PyroPeter: and you want to add  "forall a. " to the start of the type signature for func
12:59:39 <Cale> i.e. func :: forall a. a -> a
12:59:54 <ertes-w> Cale: is that supposed to be a solution to your challenge?
13:00:04 <Cale> ertes-w: It's what I was thinking of when I proposed it
13:00:21 <Cale> (but I agree that the way I stated it, it was impossible)
13:00:59 <ertes-w> Cale: i don't follow TBH‚Ä¶  where does the 'x' on line 19 come from?  looks like a scope error
13:01:06 <ertes-w> ah!
13:01:10 <ertes-w> nevermind
13:01:19 <ertes-w> of course, hence the type class
13:01:32 <Cale> You're *always* shadowing something when you use RecordWildCards, and it's a shadowing that the compiler *doesn't* warn about
13:02:24 <ertes-w> yeah, you could run into trouble with that‚Ä¶  this is just a risk/utility trade-off i'm accepting, like many others =)
13:03:11 <Cale> The other thing that has made me sad about RecordWildCards in the past is that it's much harder to write source -> source transformations which work with it
13:03:48 <Cale> If you're writing a preprocessor using haskell-src-exts or something, if you wanted to know what names got bound by a pattern, you're out of luck if it involves RWC
13:04:44 <Cale> Whereas NamedFieldPuns doesn't have the same problem at least
13:05:16 <ertes-w> if haskell ever comes up with nice records, i'll be more than happy to get rid all of my RWC uses =)
13:05:26 <ertes-w> NamedFieldPuns i haven't checked out yet
13:05:39 <ertes-w> is that the new label stuff?
13:05:42 <Cale> It's similar, but you have to list the names
13:06:07 <Cale> It just unfolds x inside the {}'s to x = x
13:06:28 <ertes-w> ah, that
13:06:39 <ertes-w> can you construct with it, too?
13:07:49 <Cale> I don't know... yes
13:08:07 <ertes-w> yeah, indeed
13:08:11 <ertes-w> GHC manual says so
13:08:21 <Cale> I just tried it in ghci :)
13:08:29 <ertes-w> not sure how that's different though‚Ä¶  it allows the same kind of problem
13:09:02 <ertes-w> it's really just more verbose =)
13:09:07 <Cale> yeah, but it's different for the preprocessor :)
13:09:16 <ertes-w> good point
13:09:21 <Cale> (and for the human, you can see which names are being bound)
13:10:23 <ertes-w> i'll probably keep using RWC, because i have records with dozens of fields, each with a type prefix, and NFP would make that a lot more verbose
13:10:31 <ertes-w> i rarely use TH anyway
13:10:40 <Cale> With RWC, it's possible to change the definition of a data type in a separate module, and have code which uses it change meaning without warning -- in at least somewhat contrived cases.
13:11:04 <ertes-w> yeah, that's true‚Ä¶  i might use NFP with smaller records
13:11:43 <Cale> but yeah, on the upside, RWC is really cute for simulated OO in Haskell
13:11:52 <ph88^> i think deserve a cookie now. improved my algorithm and bring program runtime from 838,31 s to 13.02 s
13:12:07 <Cale> ph88^: nice
13:12:10 <ertes-w> i wouldn't call that OO =)
13:12:11 <kadoban> ph88^: That sounds like a nice improvement!
13:12:20 <Cale> ph88^: But no cookie until you get to 8.38 s
13:12:21 <ertes-w> ph88^: great!
13:12:27 <kadoban> Hah
13:12:48 <ertes-w> ph88^: if all else fails try -O#haskell =)
13:13:09 <ph88^> lol
13:15:25 <Cale> ertes-w: I mean, as part of doing OO, where you write functions which construct objects that consist of records of methods, and you encode all the private data in the function parameters (or in variables bound in a do-block constructing the object)
13:15:52 <Cale> You don't get subtyping, but subtyping is overrated
13:16:04 <Cale> when you can just say what the methods do in different ways :)
13:16:29 <Cale> Of course, at the same time, this is just good ol' functional programming.
13:16:37 <Cale> But we always knew they were the same thing
13:17:33 <Cale> I like to think that the real difference between traditional OO and traditional FP is the emphasis placed on coinduction vs. induction.
13:18:11 <Cale> at least, all the stuff about OO which is worth caring about
13:18:33 <Tuplanolla> Like the visitor pattern?
13:19:00 <sproingie> not all that familiar with coinduction, what would an example of that in OOP be?
13:19:31 <Cale> Tuplanolla: I mean, when you build objects, you specify your data by how they will be deconstructed (through methods), or equivalently how they will respond to messages.
13:20:03 <EvanR> thats induction
13:20:12 <Cale> That's coinduction!
13:20:32 <EvanR> *scratches head*
13:20:55 <Cale> It's clearer if you've ever programmed in a language which actually makes a distinction between the two
13:21:07 <EvanR> just idris
13:21:18 <eacameron> I prefer NamedFieldPuns much over RWC
13:21:37 <eacameron> I really don't like bring bindings into scope that have no locality
13:21:49 <MitchellSalad_> i use RWC if my accessors are prefixed by the type name
13:21:50 <EvanR> codata Stream a = MkStream a (Stream a)
13:21:57 <eacameron> I.e. that you can't know without looking somewhere else in the code/dependencies
13:22:13 <eacameron> MitchellSalad_: That seems like a good tradeoff
13:22:15 <Cale> EvanR: right, so the important thing here is that we can always take apart a Stream into an a and another Stream a
13:22:26 <EvanR> you still need to construct a stream somehow
13:23:05 <eacameron> MitchellSalad_: Using DuplicateRecordFields and NamedFieldPuns seems like it's *almost* there. It's not proper extensible records, but in the cases of pattern matching or constructing, there's no ambiguity and for other cases you use lenses. :P
13:23:09 <Cale> EvanR: and so the condition for building a Stream recursively is that recursive applications of the function have to be inside the MkStream constructor, so that you'll always know how to take it apart
13:23:24 <Cale> (I suppose I could say corecursively, but it's a bit tedious)
13:23:47 <eacameron> But that's still my complaint. I don't want to use different field names when constructing/pattern-matching than I use when using lenses
13:24:09 <eacameron> I really like Rawr's approach. Lenses are the field names with # in front.
13:24:26 <Cale> I haven't yet actually tried it, but I don't think I'm going to like DuplicateRecordFields.
13:24:35 <EvanR> yeah i see theres something going on, but i cant really identify anything clear yet
13:24:47 <Cale> EvanR: ah, I know what will help
13:24:52 <Cale> change of syntax :)
13:25:04 <Cale> http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf
13:25:10 <eacameron> The # for OverleadedFields seems like a great tradeoff because you can basically avoid all name shadowing issues
13:25:36 <Cale> look at the bottom of the third page where they use copatterns to define (>>=) :)
13:25:42 <Cale> (and return)
13:26:50 <eacameron> s/OverleadedFields/OverloadedLabels
13:27:07 <Cale> This paper defines a nice way to build functions that construct values of coinductive data types by saying how the fields of the coinductive type will act when the function is applied.
13:27:40 <MitchellSalad_> huh, I haven't tried rawr yet
13:27:54 <eacameron> MitchellSalad_: It's pretty good but compile times are horrendous
13:28:19 <MitchellSalad_> oh... that's a shame
13:28:28 <eacameron> MitchellSalad_: And it has a 8-field max
13:28:31 <EvanR> State S A is coinductive?
13:29:41 <eacameron> Has anyone tried the overloaded-records package?
13:29:51 <Cale> EvanR: yeah
13:30:48 <Cale> EvanR: well, it's simple enough that it could be either
13:31:32 <Cale> EvanR: but you might consider the important thing about a State s a is that we can apply runState to it to run it
13:31:51 <EvanR> nahnah
13:32:10 <EvanR> "destructor copatterns are useful even if no coinduction is involved"
13:32:42 <EvanR> ok i will need to read this later
13:33:06 <Cale> Right, well, if you want real examples, you'll have to look at the other bits of that paper
13:33:59 <robertkennedy> What's the correct Monad for continuation closures (I think that's what they are called), ie `type With m env = forall a. (env -> m a) -> m a`
13:34:23 <Cale> EvanR: But the general idea is that corecursion works because you can always keep taking apart coinductive things
13:34:25 <robertkennedy> Maybe not a Monad 
13:35:26 <Cale> EvanR: because they're specified in a way which ensures the projections will be available
13:37:28 <Cale> robertkennedy: Codensity
13:37:37 <Cale> https://hackage.haskell.org/package/kan-extensions-5.0.2/docs/Control-Monad-Codensity.html
13:37:57 <robertkennedy> Thanks
13:38:32 <Cale> (and it's always a Monad, even if the type function you provide isn't a functor)
13:40:13 <glguy> Example of using Codensity for wrapping up continuation based with- APIs doing FFI marshaling https://github.com/glguy/irc-core/blob/1b4477c976120ac75fc615f65c6cf0df1090fc41/src/Client/CApi.hs#L200-L246
13:40:14 <MitchellSalad_> robertkennedy: just curious, what are you using it for?
13:41:38 <MitchellSalad_> yeah, I've seen Codensity IO used like this before
13:41:43 <MitchellSalad_> as 'Managed'
13:42:22 <robertkennedy> I'm writing a concurrency layer on top of database connections / web sessions, trying to get better control over environment pools
14:09:27 <Guest43> Does anybody know how I can debug ghc internals stuff in ghci? Specifically, I want to look at an RdrName, but it doesn't have a Show instance and I can't find a show-ish function
14:17:15 <ski> Guest43 : i dunno about `RdrName', but did you try `:print'/`:sprint' (possibly after forcing it) ?
14:23:03 <Guest43> ski: Thanks! That's really nice to know about
14:28:12 <ski> Cale : oh, i haven't seen that paper before, but i'll check it now, given that i've been arguing for this for a long time .. ty
14:28:20 <ski> @where ErikPoll
14:28:20 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
14:28:20 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
14:28:20 <lambdabot> pdf>
14:29:56 <ski> brought the idea to my attention .. i don't see any of those in the references though. i suppose either there's a common ancestor paper or possibly they were not aware of this work
14:37:53 <EvanR> Cale: you can always keep taking apart go inductive things?
14:37:58 <EvanR> coinductive*
14:38:12 <EvanR> properly coinductive?
14:38:56 <ski> yes, `nu s. F s' expands to `F (nu s. F s)' which expands to `F (F (nu s. F s))', &c.
14:39:33 <EvanR> with inductive, you necessarily must eventually stop taking it apart
14:39:41 <ski> or `Nu F' expands to `F (Nu F)' expands to `F (F (Nu F))', &c., if you prefer
14:40:09 <EvanR> does stuff like Bool count as coinductive
14:40:17 <ski> with coinductive, you can keep going as far as some inductive data structure indicates
14:40:37 <ski> you could trivially represent it as `Nu (Const Bool)', but that's hardly useful
14:40:44 <EvanR> whats Nu
14:40:52 <ski> greatest fixpoint
14:41:23 <EvanR> ah
14:41:54 <ski> you can use recursion on `Nat' to decide how far to unfold a `Stream T'
14:41:59 <davr0s> there's something to overload the use of the [ ] syntax ?    is [T] in type signatures always a list though
14:42:09 <davr0s> [ ] overloading is a convenience for constructors?
14:42:47 <ski> davr0s : iirc, it's always the list type, when used where a type is expected, yes
14:43:23 <ski> (Charity has both inductive and coinductive datatypes, can only express terminating/productive programs)
14:43:28 <ski> @where Charity
14:43:28 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
14:46:50 <EvanR> nice, crayon graphics
14:50:34 <jackhill> ::hugs::
14:59:42 <ph88^> when i  take or drop from Vector Unboxed will it allocate a new vector or use pointers into the original vector ?
15:00:12 <Tuplanolla> Take note how we have researchers on the left and programmers on the right; everyone else is banished into the chasm in the middle.
15:00:32 <ph88^> oh it says in the manual "without copying"
15:02:14 <dolio> I think those are mountains.
15:03:37 <ski> the chasm is below
15:03:52 <Rembane> The ski is above us
15:04:40 <centril> regarding solving The Expression Problem - there's the tagless final representation... But my use case involves pattern matching heavily for term-rewriting... I want to use tagless final repr to re-use rewriters for different languages which have some commonalities... How do you effectively pattern match with this representation?
15:06:14 <ski> above us only charity
15:06:38 * ski . o O ( "Imagine" <http://www.schemers.org/Miscellaneous/imagine.txt> )
15:07:11 <centril> I was thinking of maintaining two classes for each constructor, one for construction and one like: class PrismMyType where oper :: Prism' repr (TField1, TField2, ..., TFieldN)
15:14:10 <bollu> @tell quchen any idea how to interpret ribbonsPerLine as 1.5? https://github.com/ghc/ghc/blame/master/compiler/utils/Pretty.hs#L990
15:14:10 <lambdabot> Consider it noted.
15:15:20 <bollu> ski (lambda (f) (lambda (x) (f x))))) <- I don't get the reference, isn't that just "apply"?
15:18:28 <Tuplanolla> That would be `(lambda (f x) (f x))` or rather the multiparameter version, bollu.
15:18:46 <bollu> ah, so this is curry?
15:19:12 <bollu> nope, can't be
15:19:18 <bollu> Tuplanolla what s it? -_^
15:19:24 <bollu> "and the world will be as _"
15:21:35 <NemesisD> i'd like to make a smart constructor for a type but because of TH and ghc stage restrictions, its impossible for me to define the smart constructor in the same module as the constructor. is there some workaround?
15:21:39 <Tuplanolla> You have `((g f) x) = (f x)`, so `g` is `delay` with an argument, bollu.
15:22:20 <NemesisD> one rough idea i could think of is to add a deprecation warning on the use of the constructor (if that's possible, and my project uses Wall Werror), but i'd need a way to permit the use of it in exactly 1 other place
15:27:16 <geekosaur> NemesisD, only true if you need to *invoke* that smart constructor in the same module, in which case put the original constructor and smart constructor in the same different module and isolate all uses outside that module
15:29:14 <geekosaur> hm, even that si not quite true. the TH cannot use a *function* (as distinct from a data definition or etc.) in the same module that defines that function
15:30:26 <NemesisD> geekosaur: the situation is that i need a newtype around a primary key that can be safecopied. the keys my db backend use aren't really safecopy-friendly but can be converted to from Int64, so i've got a newtype K = K Int64, but i want to provide a constructor that takes Key SomeTable -> Maybe K
15:30:56 <NemesisD> in other words, making it so i can only construct the newtype from a key you got from the database
15:31:31 <NemesisD> but because Key has a type parameter, there's either a module dependency cycle issue or a stage restriction issue
15:32:33 <geekosaur> that doesn't even sound like it should be TH
15:32:44 <NemesisD> the th is from declaring the database table with persistent
15:32:45 <geekosaur> (how do you know the database at compile time is the same as the one at runtime?)
15:33:46 <NemesisD> i'd basically like the compiler to help me ensure the constructor is never called except for in one designated, tested function where it is
15:36:01 <NemesisD> oh screw it ill just move my smart constructor to the first module that will accept it and add some docs
15:37:43 <ski> bollu : it's a curried (two-argument) `apply', fwiw, aka (a specialized version of) `id', which is sometimes written as `1'. perhaps that's corresponding to "one" in the original, i don't know. a bit far-fetched, maybe
15:38:20 * ski . o O ( "The Lord of the Lambdas" <http://www.anvari.org/fortune/Miscellaneous_Collections/56795_data-and-procedures-and-the-values-they-amass-higher-order-functions-to-combine-and-mix-and-match.html> )
15:40:41 <bollu> I see
15:42:05 * ski enjoys the "ALL USERS PLEASE NOTE"s at <http://fare.tunes.org/fortunes/lambda.txt>
15:51:54 <mniip> goddammit can't he ease on the typesetting http://tcpst.net/b8rk.png
15:52:39 <bollu> mniip what are you reading?
15:52:48 <mniip> dependent haskell
15:53:39 <ALoneNoMad> does anyone here have a programmers persptive 3rd edition?
15:55:20 <ski> mniip : Liquid Haskell ?
15:55:29 <mniip> nono, dependent
15:55:42 <bollu> mniip dependant types for haskell?
15:55:46 <bollu> mniip is there a book?
15:55:51 <mniip> there's a thesis
15:56:02 <mniip> http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
15:56:03 <ski> is it a rule for some kind of elaboration of (dependent) function types ?
15:56:23 * ski can guess at what some parts of it means
15:56:29 <mniip> ski, that's one of the constraint produnction rules in the dependent inference/typechecking algorithm
15:58:04 <mniip> ah better
15:58:17 <mniip> it turns haskell code into intermediate language code
15:58:30 * ski likes the section name "The twelve quantifiers of Dependent Haskell"
15:58:36 <mniip> yeah
15:58:49 <mniip> ski, http://tcpst.net/7xk2.png
16:01:49 <mniip> I just somewhat really hate the way where he comes up with a greek letter or a twiggly squiggle for every single thing
16:01:53 <mniip> can't memorize this much notation
16:04:04 <hpc> heh, twiggly squiggles
16:04:58 <c_wraith> iirc, that paper is already out of date. 
16:05:06 <ski> what would you prefer ?
16:05:28 <c_wraith> he released another paper earlier this year that updated the design. 
16:05:50 <Ferdinandvw> Hey guys. I'm having a problem with running a test of mine using stack test. The test contains a getLine, which appears to be throwing an error: "<stdin>: hGetLine: end of file". If i do a ghc --make test.hs and then run it, it works fine.
16:06:35 <Ferdinandvw> Can you not use stdin if you use stack test or something?
16:07:07 <glguy> It wouldn't make much sense for your automated test to get input from stdin
16:07:47 <mniip> c_wraith, oh? is it significant? got linky?
16:07:48 <Ferdinandvw> well I suppose so, but still. Is it not possible?
16:08:15 <glguy> Ferdinandvw: You can make an executable instead of a test if your goal is to have an interactive program
16:08:47 <Ferdinandvw> Yea, maybe I should just be doing that instead...
16:08:54 <Ferdinandvw> thanks
16:11:50 <mniip> c_wraith, http://cs.brynmawr.edu/~rae/papers/2017/dep-haskell-spec/dep-haskell-spec.pdf
16:11:51 <mniip> this?
16:11:58 <c_wraith> mniip, it is significant, I can't seem to find the link.. 
16:12:37 <c_wraith> Oh. that looks like it. 
16:17:45 <Tuplanolla> Am I wrong in thinking dependent Haskell is an incoherent mess?
16:19:23 <Tuplanolla> The extensions that play into it and the syntax you need for it just don't make sense to me.
16:30:13 <mniip> Tuplanolla, after reading richard's thesis it sorta started falling into place
16:30:18 <mniip> like, I can see how it could work
16:30:37 <mniip> c_wraith, do you happen to know why? was it flawed?
16:31:11 <Tuplanolla> I have a certain idea of what it should look like, but it doesn't look like that at all.
16:31:22 <centril> brb, ill just read the thesis
16:31:45 <mniip> Tuplanolla, care to share?
16:32:10 <Tuplanolla> Have you used Coq?
16:33:48 <mniip> yes
16:34:08 <Tuplanolla> That's the reference point then.
16:34:11 <mniip> I've also used idris and dependent haskell looks like a fairly solid superset of idris
16:34:24 <mniip> except for maybe the implicits and tactics and termination
16:34:53 <mniip> the only issue not exactly covered in the thesis is lifting of primops and thus reduction of arithmetic on primitive-kinded types and the like
16:35:11 <mniip> but we can do with inductive arithmetic
16:35:45 <robertkennedy> Whoa, got a new seg fault message: "MVAR object entered!"
16:36:14 <mniip> robertkennedy, are you using any unsafes and/or violating any invariants?
16:36:16 <pgiarrusso> mniip: sadly if Eisenberg *didn't* use such crazy Greek notation, that thing would probably be ~1000 pages. Also, PhD theses are often aimed at even fewer people than papers
16:36:36 <robertkennedy> Idk what you might mean by violating invarianta
16:36:57 <robertkennedy> I do have unpacked variables in an MVar, maybe that's it?
16:37:00 <mniip> robertkennedy, well when someone says 'this function only works if x < y and you supply x >= y'
16:37:34 <mniip> that was an improper quoting
16:37:57 <robertkennedy> Oh, then not to my knowledge. Im gonna try the old stack clean, might just be some package versioning error (hopefully)
16:38:08 <pgiarrusso> Tuplanolla: I'm sure Eisenberg knows Coq and Agda, but you have different tradeoffs. Of course adding dependent types to Haskell can't be as clean
16:38:25 <Tuplanolla> I guess I'll have to look deeper into it later.
16:39:44 <mniip> Tuplanolla, are you saying you expected haskell to be coq?
16:39:57 <mniip> can't agree with that because the purposes are different
16:40:15 <robertkennedy> I haven't ever seen this sort of error, and Google only has 35 other instances. Crazy
16:40:29 <Tuplanolla> No. I just expected a clear vision.
16:40:51 <mniip> robertkennedy, no, it looks like a hard crash
16:40:57 <mniip> is it reproducible?
16:41:23 <robertkennedy> I'll see and track it down if it is
16:42:04 <mniip> there was some flag
16:42:09 <mniip> to build with a debug rts
16:42:16 <mniip> and then enable that debug
16:42:25 <Cale> Are you using unordered-containers? :)
16:42:38 <Cale> (shot in the dark)
16:43:23 <robertkennedy> Yeah I am
16:43:32 <geekosaur> whoops...
16:43:55 <Cale> Is it easy to rip that out and use ordinary containers?
16:44:10 <Cale> If so, give it a try
16:44:15 <robertkennedy> I'll do that
16:44:21 <mniip> ah
16:44:40 <geekosaur> robertkennedy, current unordered-containers has an "optimization" that is extremely unsafe
16:44:55 <Cale> unordered-containers was doing some low-level shenanigans which triggered a GHC bug which caused memory corruption.
16:45:20 <geekosaur> is it actually a GHC bug? discussion I saw was more "ugh, that was never and will never be safe"
16:45:23 <pgiarrusso> Tuplanolla: Dependent Haskell isn't done, unlike Coq. Looking at the paper's intro doesn't suggest a lack of vision...
16:45:24 <robertkennedy> But it's the basis of aeson! I trusted it too much
16:45:40 <mniip> geekosaur, ooh can I see?
16:46:02 <davean> robertkennedy: uh, well, don't look at what it calls a hash then
16:46:09 <Cale> I don't know, tbh. I was pretty sure it would just turn out to be unordered-containers' fault, but then I heard that it was actually a GHC bug, but I haven't looked carefully for myself
16:46:34 <Tuplanolla> Retrofitting dependent types into an already-large language, however, pgiarrusso...
16:47:19 <mniip> Tuplanolla, yes but it retrofits well
16:47:24 <Cale> robertkennedy: Well, yeah, it might not be such a great thing that Aeson is using it either -- I guess don't worry too much if you're only using it for Aeson's sake?
16:47:31 <mniip> I mean, we did typeintype
16:47:33 <bollu> wow the thesis is super clean
16:47:35 * geekosaur looking through his log
16:47:35 <Cale> robertkennedy: Is your program concurrent/parallel?
16:47:35 <pgiarrusso> Tuplanolla: as any good research, it's a challenge. But the current stuff with promotions isn't better
16:47:38 <bollu> mniip thnks for the reference
16:47:39 <mniip> now just gotta do terminterm
16:47:45 <Tuplanolla> Well, that's good to hear.
16:47:48 <bollu> mniip I love how well writen it is <3
16:47:57 <mniip> bollu, it's great yes
16:48:08 <bollu> mniip are all PHD theses this well written?
16:48:16 <mniip> I wouldn't know
16:48:20 <bollu> mniip also, who is eisenberg's guide?
16:48:25 <Cale> robertkennedy: My understanding of the unordered-containers bug was that it only seemed to show up in cases where you were evaluating things in parallel, but that could be just a property of the original program we noticed the issue in.
16:48:31 <Tuplanolla> Haha! No, bollu.
16:48:34 <bollu> and, like, if I want to work in the same area, what do I do? xD (lowly undergrad checking in)
16:48:37 <mniip> TA? stephane weirich, it's written on the first page
16:48:43 <bollu> Tuplanolla I see :)
16:48:45 <bollu> ah, cool
16:48:53 <Cale> robertkennedy: and it's altogether possible that what you're seeing is totally unrelated
16:49:15 <robertkennedy> I'm doing a lot of parallel computation
16:49:33 <robertkennedy> And indeed just changed the code base to be a lot more parallel
16:49:35 <mniip> bollu, there's a thread on cafe about haskell-related masters programs I think
16:49:40 <mniip> that might be a good first step
16:49:44 <bollu> ah, cool!
16:49:46 <bollu> I shall check :)
16:49:55 <Cale> robertkennedy: hmm!
16:49:57 <bollu> mniip I'm from India, that complicates life a little bit - visas and all.
16:50:05 <mniip> as far as b.sc is concerned I am convinced it pretty much doesn't matter?
16:50:11 <mniip> bollu, I can relate
16:50:20 <bollu> mniip how so? :)
16:50:44 <mniip> I'm planning to do MS in a foreign country as well
16:50:55 <robertkennedy> Well, no worries, refactoring is easy as ctrl+h
16:51:07 <centril> bollu: Move to Gothenburg (Chalmers) | Glasgow | Cambridge
16:51:15 <bollu> centril xD
16:51:20 <bollu> mniip ahh, I see
16:51:27 <bollu> centril wish it were that easy :)
16:51:32 <pgiarrusso> bollu: not all PhD theses are this well-written, though we try, I'm writing a PhD thesis right now, but Eisenberg's great
16:51:49 <bollu> pgiarrusso I see, cool :)
16:51:59 <centril> I can always recommend the masters programme "Computer Science, Algorithms, Logic, and Languages"
16:52:07 <bollu> centril where is that?
16:53:25 <centril> bollu: http://www.chalmers.se/en/education/programmes/masters-info/Pages/Computer-Science-algorithms-languages-and-logic.aspx
16:53:29 <centril> but i am biased
16:53:33 <centril> since it is my university
16:53:43 <pgiarrusso> bollu: you're getting good tips ó in general, to do research on X, find the centers of excellence for X and go study there
16:54:13 <pgiarrusso> bollu, centril: aren't there also decent places in the Netherlands?
16:55:11 <pgiarrusso> with the Swierstras and all?
16:55:48 <centril> pgiarrusso: my bachelors thesis supervisor is from the Netherlands (Utrecht I think)
16:55:54 <centril> but now he is at Chalmers
16:56:22 <pgiarrusso> right, Utrecht is the place ó though I guess Chalmers might be better for this: aren't the Agda guys there
16:56:24 <pgiarrusso> ?
16:56:37 <centril> pgiarrusso: who isn't at Chalmers ;)
16:57:26 <pgiarrusso> centril: weeelll :-)
16:58:41 <centril> pgiarrusso: Thierry Coquand, Ulf Norell, Andreas Abel, Arne Ranta, John Hughes, Mary Sheeran, etc.
16:59:19 <geekosaur> yug. so ircbrowse didn't log ghc after february, apparently, so no public logs
16:59:41 <geekosaur> nniip, short version is that the optimization uses unsafeInsertWith which is cancer if there are multiple threads
16:59:46 <centril> pgiarrusso: now we just need to steal SPJ and Simon Marlow :P
16:59:51 <pgiarrusso> centril: OK, I'm indeed jealous
17:00:01 <mniip> aah
17:00:09 <centril> pgiarrusso: there's no need, just move here :P
17:01:17 <pgiarrusso> too late
17:01:24 <centril> ;)
17:03:44 <EvanR> is lambda of lambda calculus supposed to have originally stood for something
17:04:06 <EvanR> l = language? l = logic?
17:04:45 <EvanR> first letter not in common usage at th etime
17:06:34 <pgiarrusso> EvanR: not clearly known ó a legend claims it was a typesetting mistake, IIRC it's debunked but with no alternative explanation
17:06:50 <EvanR> haha
17:07:38 <EvanR> "what! you put the y in upside down... my magnum opus is ruined"
17:07:51 <centril> maybe ask one of Alonzo Church's doctoral students ?
17:11:20 <EvanR> are any in here? :)
17:11:32 <robertkennedy> Cale: a key piece of the program is translating json from arbitrary web apis to bson (the mongoDB storage format). Should I just write a new attoparsec parser for bson and avoid the JSON entirely? Looking for an opinion, no worries if you can't be authoritative
17:23:47 <geekosaur> mniip, https://github.com/tibbe/unordered-containers/issues/147 is the bug report on the unordered-containers thing. It was initially closed as a GHC bug because they thought lazy blackholing was somehow causing it; but forcing eager blackholing only narrows the window, it doesn't fix it.
17:23:59 <geekosaur> Cale ^^ re ghc bug
17:25:43 <geekosaur> hm, except the end (6 days ago) thinks it's a different ghc bug, with no confirmation
17:28:28 <robertkennedy> Thanks for the link geekosaur
17:28:33 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/13615 is the ghc ticket, which posits the problem is use of unsafeDupablePerformIO in situations where duplicating is not safe
17:29:11 <geekosaur> which isn't really a ghc bug; sounds more like the unsafeInlineIO mess from some months ago (aka accursedUnutterable...)
17:33:43 <ski> geekosaur : there's still <http://tunes.org/~nef/logs/haskell/>
17:34:09 <geekosaur> for #ghc?
17:35:20 <ski> oh, sorry. i assumed you were talking about #haskell
17:36:39 <ertes> robertkennedy: well, both are generic interchange formats, except that BSON is more complex than JSON
17:37:21 <ertes> robertkennedy: as an interchange format i would probably keep JSON‚Ä¶  the conversion to BSON is usually straightforward enough‚Ä¶  also note that you don't need to write a BSON implementation, as there are existing ones on hackage
17:46:07 <sproingie> EvanR: church did propose lambda calculus as a formal logic, so possibly it stood for that.  that, or it was just a convenient letter.
17:46:26 <sproingie> the typesetting thing is debunked, but he did use different syntaxes
17:47:26 <robertkennedy> ertes: the question is the result of a failure in HashMap which might be the reason my program is crashing with a "MVAR object entered!" Failure
17:51:05 <ertes> robertkennedy: are you aware of the recent bugfix?  recently a nasty concurrency bug was discovered and fixed
17:51:39 <robertkennedy> Where can I get that fix? The rest of the chat informed me of the bug
17:52:22 <ertes> it should be in the latest version, if i'm not mistaken
17:56:22 <robertkennedy> The latest (on hackage) is 0.2.8.0, from march
18:15:21 <pacak> robertkennedy: There is a  workaround on version from github.
18:15:23 <pacak> Not a fix.
18:15:36 <pacak> ertes: Not fixed.
18:16:47 <pacak> robertkennedy: Are you using fromList / fromListWith?
18:18:11 <robertkennedy> pacak: yeah, I convert a JSON object to a list of key/value pairs (no fromListWith though) in a pretty integral part of the code 
18:18:30 <pacak> robertkennedy: So... fromList?
18:18:38 <robertkennedy> Yeah
18:18:44 <pacak> robertkennedy: reimplement it using fold.
18:19:01 <robertkennedy> Will do, thanks üíØ
18:19:21 <pacak> You are welcome comrade ‚ò≠
18:20:01 <robertkennedy> foldrWithKey should work, yeah?
18:21:17 <pacak> fromList :: [(k, v)] -> HashMap k v
18:21:25 <pacak> foldrWithKey takes something else
18:21:50 <pacak> fromList and fromListWith are doing the most evil things
18:22:28 <robertkennedy> Oh, yeah you're talking about the fromList side, got mixed up, will do
18:22:40 <pacak> fromList' = foldr HashMap.insert HashMap.empty
18:22:43 <pacak> something like that
18:26:50 <ReinH> The lambda was chosen to distinguish abstraction from a construction by Whitehead and Russell represented as x^. https://math.stackexchange.com/a/64469/9175
18:27:00 <glguy> pacak: So the current state of unordered-containers is that fromList[With] is broken under which conditions? All?
18:27:30 <glguy> specifically with parallel evaluation?
18:27:36 <pacak> glguy: one on hackage - if you doing something with par and being unlucky.
18:28:22 <geekosaur> specifically with parallel evaluation, yes
18:28:30 <ReinH> So it actually has nothing to do with the letter 'l'.
18:28:39 <pacak> one on github - it seems like race condition window is small enough so existing example can't trigger bug, but bug is still there.
18:29:51 <pacak> ReinH: Wasn't it A with dot on top that got messed up in initial version of typesetting?
18:30:02 <ReinH> Not according to that link.
18:30:34 <glguy> pacak: My experience lately is that you just have to be super careful doing anything with par
18:31:45 <EvanR> if no one can observe the bug, is it still there!
18:33:04 <Axman6> like that 20+ year old bug in the linux kernel?
18:33:21 <pacak> EvanR: Existing sample can't observe it. But  it's still there.
18:36:49 <pacak> ReinH http://akivaleffert.com/papers/hat-calculus.pdf
18:36:55 <pacak> my bad, it was ^, not dot.
18:37:09 <ReinH> pacak: Yes, that's what my link said.
18:50:14 <halogenandtoast> Is there any way to run a haskell process but to disable networking for that process
18:50:35 <Axman6> that sounds more like something the OS would do
18:50:45 <halogenandtoast> i.e. I want a network request to fail without having to disable my wifi
18:50:57 <Axman6> run it in a container of com kind (docker, a jail, etc, without setting up networking)
18:50:59 <halogenandtoast> I guess I could edit my hosts file
18:51:10 <Axman6> of some kind*
18:53:33 <halogenandtoast> okay editing my hosts worked for what I wanted
19:01:05 <jaseemabid> I'm trying to define a IsString instance for my type and I get this silly error which I cannot debug. `‚ÄòfromString‚Äô is not a (visible) method of class ‚ÄòIsString‚Äô`. I can't really figure out what's happening.  
19:02:15 <pgiarrusso> jaseemabid: is fromString imported?
19:03:58 <pgiarrusso> jaseemabid: `import Data.String(IsString)` causes that error
19:04:28 <pgiarrusso> jaseemabid: while using `import Data.String(IsString(..))` also imports the fromString method
19:05:29 <jaseemabid> pgiarrusso: I didn't explicitly import anything. I was hoping to see an error on the type class rather than the function. 
19:05:42 <jaseemabid> pgiarrusso: Importing fixes the problem. Silly me! 1
19:08:10 <pgiarrusso> jaseemabid: opening a a clean ghci and doing :browse Data.String shows that IsString is not imported by default... I'm guessing you import some package that imports (and reexports) IsString but not fromString
19:08:27 <pgiarrusso> and given the import syntax, I'm sure that's easy to do
19:09:21 <geekosaur> instances can't be explicitly imported or exported
19:16:45 <fred-fri> how strict are you with validating arguments in languages with null? it feels excessive to do it on all arguments in every method, but that's the only way to fail fast and avoid latent npes...
19:17:38 <pacak> robertkennedy: Any improvements?
19:22:19 <sproingie> fred-fri: i'd say most people are pretty lax about it, thus why NPEs are so common
19:23:39 <sproingie> testing for it in args you might do in C, other languages you typically test return values instead
19:28:20 <dibblego> fred-fri: assume it doesn't exist, write library support so that this assumption never needs to be compromosied with e.g. functionaljava.org
19:30:13 <jaseemabid> pgiarrusso: Yep! Protolude maybe
19:30:49 <Clint> dmwit: is xmonad-extras dead?
19:32:15 <pgiarrusso> jaseemabid: if you find out, maybe file a gentle ticket, this seems indeed undesirable and confusing (though I might be wrong)
19:32:41 <pgiarrusso> fred-fri: machine-checked annotations (like `@Nullable`) can in principle help document what's Nullable and what isn't. I've seen them used in Android. I'm not sure they're always checked consistently though
19:34:36 <pgiarrusso> fred-fri: but for many cases I think tools *can* check this automatically and increase assurance
19:34:56 <n_blownapart> hi I'm looking at this article on desugaring. what is this code doing ? https://ptpb.pw/QC6Y
19:36:11 <sproingie> never knew one could abuse parens like that
19:36:21 <geekosaur> huh? it's just an example of using a symbol-name as a parameter
19:36:28 <sproingie> what it's doing is marvelous obfuscation
19:36:37 <geekosaur> @src on
19:36:37 <lambdabot> (*) `on` f = \x y -> f x * f y
19:37:53 <n_blownapart> so I gather that there's no reason to spend time deciphering this? 
19:38:21 <geekosaur> hm?
19:38:24 <MarcelineVQ> you should take time to understand it
19:38:35 <robertkennedy> pacak: maybe is not on unordered-collections. Converted all `HashMap.fromList` to `foldMap (uncurry HashMap.singleton)`, still got my complete runtime failure. 
19:38:48 <sproingie> it's helpful to know what it's doing in case you run across it.  i don't recommend actually doing it.
19:39:06 <n_blownapart> ok, then , er, what is it doing? I cannot read it
19:39:19 <sproingie> it's just a parameter named %
19:39:54 <geekosaur> but to use a symbol as a parameter name, it needs to be in parentheses
19:40:41 <halogenandtoast> Would it be weird to import two modules qualified with the same name. For example: import qualified Web.Spock as Spock; import qualified Web.Spock.Config as Spock
19:40:43 <geekosaur> let f z x y = x `z` y in ... -- same as let f (%) x y = x % y in ...
19:40:55 <MarcelineVQ> halogenandtoast: not weird at all
19:41:05 <geekosaur> halogenandtoast, it's commonly done in some cases. can be a problem if the modules export the same names though
19:41:21 <n_blownapart> geekosaur, thanks ! I can work with that. 
19:41:31 <halogenandtoast> Thanks MarcelineVQ geekosaur 
19:43:54 <pacak> robertkennedy: Would it be hard to try using Map instead of HashMap?
19:45:26 <pacak> robertkennedy: If that fixes the problem them you managed to replicate the problem in unordered-containers with no really unsafe code - it might be useful in debugging that ghc issue.
20:02:24 <halogenandtoast> if you were to import Aeson qualified would you import it as Aeson, or Json
20:02:40 <Clint> no
20:02:52 <halogenandtoast> I was using Json since it expressed it's purpose rather than the package name.
20:03:57 <halogenandtoast> > no == True || False
20:03:59 <lambdabot>  error:
20:03:59 <lambdabot>      ‚Ä¢ Variable not in scope: no :: Bool
20:03:59 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
20:04:41 <halogenandtoast> Clint: was there a third option I didn't mention?
20:08:15 <Clint> halogenandtoast: i'd probably go with A or Ae
20:09:18 <winter_> Dose the infotable pointer of a heap closure tagged with additional bits?
20:09:55 <winter_> The first to ask should be: does the info table aligned to some offset, say a word?
20:09:58 <halogenandtoast> Clint: hmm, I'm trying to make it obvious where functions are coming from for people not familiar with Haskell
20:10:24 <glguy> halogenandtoast: That's fine, they'll know enough Haskell to understand import lists
20:11:24 <geekosaur> winter_, that question is likely best asked in #ghc
20:11:42 <winter_> oh, thanks
20:12:20 <geekosaur> (and be prepared for weird answers, I think DATA_NEXT_TO_CODE gets involved
20:12:44 <geekosaur> er TABLES_NEXT_TO_CODE
20:19:30 <halogenandtoast> Clint: glguy thanks I'm talking to the team about it now.
20:25:22 <Sh4rPEYE> Hey! I'm solving little exercises on Rosalind and Code Wars. I want to use Stack for my dependencies, but I'm not sure, what's the best setup. I have a bunch of small individual files... Should I put them all in /src and import in /app/Main.hs? I want to specify the dependencies for them together on one place and I want to be able to call the "solution" function from each of the files.
20:32:48 <kadoban> Sh4rPEYE: When I do hackerrank/codeforces/project-euler/erdos the best setup for me seems to be a "template" file which uses the script interpreter thing, so each problem is its own executable with its own set of dependencies (specified at the top of the file), though it's usually the same set I just copy over and over.
20:33:17 <kadoban> So I just have a Template.hs file that is runnable on its own and I copy it to BlahBlahProblem4.hs and run it.
20:38:27 <Sh4rPEYE> kadoban: Oh, so you end up with ProjectEuler10.hs in which at the top is your template, which calls your specific Problem 10 code?
20:38:51 <Sh4rPEYE> What if you need to import local modules? WIll it work?
20:40:44 <kadoban> Sh4rPEYE: I have some setup code that's always in there, and some library stuff at the bottom, and then just an "answer" function that does whatever it's supposed to. I can import from hackage packages, I don't think I can do local ones. Most of the places I use this for require you to submit the code, and it always must be in a single file, so that's not a problem for me.
20:40:57 <kadoban> I can show an example, let me find one.
20:43:11 <kadoban> Sh4rPEYE: https://gist.github.com/kadoban/8ede297671b843879bbdde3ecf075a8e like this is my usual, and I fill in the "answer" function for each. I removed the imports and my usual library crap, most of it anyway.
20:43:53 <lamefun> How to make global variables?
20:44:09 <kadoban> Not sure if that'd work for everyone, I mostly do it because of requirements at the places I submit to, so if you're doing project euler you might want something that looks cleaner, like with separate modules. I don't remember how I used to do that.
20:44:17 <EvanR> lamefun: very carefully
20:44:36 <lamefun> I mean, https://hackage.haskell.org/packages/search?terms=global - all of the packages are pretty old.
20:44:43 <lamefun> Is there a maintained one?
20:45:03 <EvanR> what would the maintenance do?
20:45:23 <EvanR> they put a noinline pragma on a top level unsafe perform IO that creates an IORef
20:45:50 <EvanR> (with TH)
20:47:01 <lamefun> but surely there are pitfalls...
20:47:31 <EvanR> i havent seen any indication that anyones global variable scheme avoids all pitfalls
20:47:56 <lamefun> what pitfalls are there with global variables?
20:48:21 <Sh4rPEYE> kadoban: Rosalind requires importing a local module I wrote... I'll look into your method, maybe it'll work for me, too. Thanks
20:48:22 <EvanR> i saw in an oleg paper he doubts that thing i just mentioned, plus special compilation flags to prevent CSE etc are totally safe
20:49:01 <lamefun> papers on global variables in Haskell?
20:49:29 <EvanR> no, actually im not sure if that paper was oleg or 
20:49:42 <EvanR> but it was about an alternative to globals
20:49:58 <lamefun> I mean in any other language globals just work, no papers or anything.
20:50:12 <kadoban> Sh4rPEYE: Anytime, good luck.
20:50:14 <EvanR> IME doing what i said also just works
20:50:25 <EvanR> some libraries are based on it
20:51:13 <lamefun> Or is StateT on top of IO better?
20:51:22 <EvanR> probably not
20:51:35 <robertkennedy> pacak: sorry for the late reply, I went for a heavy happy hour to celebrate the failure in debugging. And, no, replacing HashMap uniformally would be very difficult without forking aeson. 
20:51:45 <EvanR> ReaderT over IO with a record of IORefs might be better
20:52:09 <lamefun> how is statet bad?
20:52:12 <EvanR> with a suitable swath of helper functions
20:52:25 <EvanR> StateT over IO is kind of redundant
20:52:39 <pacak> robertkennedy: I see. Lots of things use hashmap  so I really want to see this bug fixed.
20:53:00 <EvanR> ive personally only ever passed IORefs and such around explicitly in IO
20:54:12 <robertkennedy> pacak: Same. My current theory (back home now, so I won't test til tomorrow) is that I'm experiencing an unrelated bug from a data constructor with an unpacked Vector of MVars 
20:54:32 <robertkennedy> *TMVars
20:56:28 <robertkennedy> Have you ever seen the error message "MVAR object entered!"? It was a new one for me, Google didn't help
20:58:04 <pacak> I don't recall seeing this message.
20:59:29 <lamefun> why isn't there built-in syntax for noinline unsafeperformio iorefs?
21:04:01 <mniip> robertkennedy, I've seen a ton of other objects being entered
21:04:21 <EvanR> noinline unsafePerformIO IORefs is a dirty hack and no one thinks its the right way to do it
21:04:21 <mniip> but that's because I was experimenting with the RTS, runtime representations and the like
21:04:50 <EvanR> certainly shouldnt be an official part of the language
21:05:14 <glguy> lamefun: Not supporting globals is a feature
21:06:29 <robertkennedy> mniip: do you know which function would trace such a message on dump? With the all cap stylization and whatnot
21:06:55 <EvanR> MVAR all caps is talking about an internal runtime object
21:07:09 <EvanR> related to MVars
21:07:22 <NoxAeternus> Can I ask stack related question here?
21:07:22 <EvanR> time to github search ghc source code!
21:07:25 <NoxAeternus> haskell stack
21:07:37 <kadoban> NoxAeternus: Sure
21:07:53 <NoxAeternus> When I run stack setup it says at the end: ... msys2-20150512:    5.59 MiB / 31.90 MiB ( 17.53%) downloaded...Network.Socket.recvBuf: failed (Connection reset by peer (WSAECONNRESET))
21:08:29 <NoxAeternus> How do I fix it?
21:08:36 <EvanR> get better wifi
21:08:37 <lamefun> glguy: can't I just wrap ReaderT or StateT around IO?
21:09:06 <kadoban> NoxAeternus: Maybe just try again?
21:09:08 <EvanR> it does suck that it aborts the whole download, or does it?
21:09:23 <NoxAeternus> I tried it couple of times same result
21:09:40 <kadoban> That's odd. Does it error at the same part?
21:10:06 <robertkennedy> Good call that the MVAR was a rep unwords'd with "object entered!"
21:10:33 <lamefun> I mean, surely globals are supported, there's ReaderT, StateT, noinline unsafePerformIO, implicit params, I just want to know what's the best way.
21:11:12 <EvanR> explicitly passing an IORef around ?
21:11:18 <EvanR> as a first try
21:11:48 <ski> @wiki Global variables
21:11:48 <lambdabot> https://wiki.haskell.org/Global_variables
21:11:53 <ski> @wiki Top level mutable state
21:11:53 <lambdabot> https://wiki.haskell.org/Top_level_mutable_state
21:13:45 <lamefun> I've also read that implicit params are somehow bad.
21:13:57 <ski> closing over the reference could sometimes be used
21:14:02 <EvanR> the paper i was talking about was about implicit configurations
21:14:23 <EvanR> which, for its use case, is millions of times better than a global variable
21:15:09 <EvanR> not the same thing as implicit params
21:16:55 <mniip> robertkennedy, uh, it's some panic deep in the RTS
21:17:11 <mniip> MVAR object is a refernce to closure type, not the MVar datum
21:28:19 <Lokathor> ReaderT an IORef is my vote
21:28:35 <Lokathor> then you can easily upgrade it to an MVar or TVar as you go
21:28:47 <EvanR> so you want to use global variables in haskell, let me teach you some basic category theory
21:38:54 <mniip> robertkennedy, rts/StgMiscClosures.cmm
21:39:02 <mniip> INFO_TABLE(stg_MVAR_DIRTY,3,0,MVAR_DIRTY,"MVAR","MVAR") { foreign "C" barf("MVAR object entered!") never returns; }
21:39:24 <robertkennedy> I saw that, had no idea what it might mean
21:39:46 <mniip> you're not supposed to enter an MVAR object
21:40:08 <EvanR> the impossible has occurred
21:40:08 <mniip> in practice it could be anything
21:40:20 <mniip> just means that the rts had followed a wrong pointer
21:40:40 <mniip> stack corruption, out of bounds write, out of bounds read, you name it
21:41:39 <robertkennedy> Hmmm. Do you think it might be because I've unpacked a `Vector (TMVar MongoConnection)`? But I would think unpacking pointers is a okay, so maybe not
21:42:33 <glguy> What did you do to unpack it?
21:43:21 * mniip . o O (unsafeCoerce :: _ -> ())
21:43:39 <systemfault> Just want to be sure, there's nothing that would allow me to have "overloading"-like capabilities with type constructors, right?
21:43:55 <mniip> what?
21:44:02 <robertkennedy> I wrote something like `data C env = C {... , vcache :: {-# unpack #-} !(Vector (TMVar env)), ... }
21:44:04 <monochrom> What does that mean?
21:44:45 <mniip> that shouldn't cause issues
21:47:07 <robertkennedy> Yeah I didn't think so either, I'm grasping. Might just need the fresh start tomorrow. I wrote a one time python script so the issue can wait, and I've only refactored a couple of modules in our parallelism/concurrency suite today, so I think it shouldn't be too hard to pin down
21:48:46 <robertkennedy> systemfault: type families?
21:49:08 <systemfault> robertkennedy: I'm looking at that at this moment, might be what I want
21:49:16 <systemfault> robertkennedy: Thank you :)
21:51:25 <robertkennedy> Type families and associated types are awesome, though you have to use some undecidable language extension that sounds scarier than it is if you want to recurse. If you wanna see a cool talk, check out SPJ's part 4 lecture on types
21:52:40 <robertkennedy> https://youtu.be/XtogTwzcGcM
22:10:35 <robertkennedy> Appreciate advice all, I'm to bed for the night, I'll keep the chat updated 
22:24:28 <jchia1> Is there a library for getting the intersection of elements in 2 or more sorted lists/vectors/etc?
22:25:24 <jchia1> e.g. mergeIntersection [1, 2, 3] [2, 3, 4] == [2, 3]
22:31:37 <pacak> Data.Set?
22:31:44 <EvanR> hmm https://hackage.haskell.org/package/sorted-list-0.2.0.0
22:32:28 <EvanR> they seem to not have intersection(s)
22:32:59 <EvanR> lame
22:33:27 <EvanR> "If you are missing a feature, do not hesitate to ask by opening an issue at the bug-tracker."
22:34:45 <dmj`> > foldr (\a b -> S.fromList a `S.intersection` b) (S.fromList [1,2,3]) [[2,3,4]]
22:34:47 <lambdabot>  fromList [2,3]
22:35:50 <jchia1> dmj`: What's S? Data.Set? How does lambdabot know?
22:36:04 <geekosaur> @where L.hs
22:36:04 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
22:37:42 <dmj`> lambdabot is pretty all-knowing
22:44:46 <jared-w> why wouldn't a Set library not have intersections? wtf
22:46:02 <jared-w> oh whoops, totally misread the above conversation wrong
22:47:08 <halogenandtoast> Can anyone who knows about xml-conduit and/or cursors, help me figure how to do this: https://gist.github.com/halogenandtoast/4285ebaaa39689cbb7f66b94f231f6ea
22:47:52 <halogenandtoast> also jared-w I think you were helping me yesterday, you'd probably be much happier with the outcome so far: https://github.com/halogenandtoast/boardy/blob/master/app/Main.hs
22:52:04 <glguy> halogenandtoast: sortOn length is wrong
22:52:11 <glguy> That's probably not the issue, but it's not right
22:52:36 <ski> > [1,2,3] `intersect` [2,3,4]  -- not assuming ordering, multiple traversal of one list
22:52:38 <lambdabot>  [2,3]
23:02:24 <halogenandtoast> glguy: ah you are right
23:06:39 <halogenandtoast> you were right on both accounts
23:06:51 <halogenandtoast> sortOn was wrong, but also not the issue
23:16:17 <halogenandtoast> cursors seem hard :\
23:27:18 <cocreature> halogenandtoast: why are you working in the list monad here? the monadic binds result in ids and titles being of type Text instead of [Text] so zip doesn‚Äôt typecheck
23:28:23 <cocreature> halogenandtoast: if you use a "let" it typechecks
23:28:51 <halogenandtoast> it doesn't typecheck but it's closer
23:29:01 <halogenandtoast> you were right, no idea why I was doing that in the list monad
23:29:13 <cocreature> it typechecks for me
23:29:13 <halogenandtoast> I think I often don't see the whole monadic picture.
23:29:28 <halogenandtoast> Expected type: [(t0 a0, Text)] Actual type: [(Text, Text)]
23:29:33 <halogenandtoast> is what I currently get
23:29:39 <cocreature> also if you add imports and necessary extensions to the snippets here, you‚Äôre making life significantly easier for the people trying to help you
23:30:40 <cocreature> halogenandtoast: http://lpaste.net/356404 seems to work
23:31:01 <glguy> lack of imports is why I stopped at the sortOn problem
23:31:09 <halogenandtoast> I'm sorry for that
23:31:44 <halogenandtoast> I've updated the gist with the full_context https://gist.github.com/halogenandtoast/4285ebaaa39689cbb7f66b94f231f6ea
23:31:54 <halogenandtoast> I'm looking into my type error now
23:31:55 <cocreature> halogenandtoast: but it‚Äôs probably not what you want. that will use "length" on the tuple which is always 1
23:32:10 <halogenandtoast> I changed it to map snd $ sortOn (length . fst) (zip titles ids)
23:32:26 <halogenandtoast> might need to be T.length
23:32:48 <halogenandtoast> yup
23:32:49 <cocreature> right
23:32:55 <halogenandtoast> type checks now
23:34:06 <halogenandtoast> thanks cocreature and glguy 
23:35:27 <LiaoTao> You guys ever had that feeling when going back to other programming languages that they are just so verbose and filled with boiler plate?
23:35:48 <LiaoTao> Really hitting the wall here...
23:35:52 <iqubic> Yeah. Java is the worst. Gosh darn classes.
23:35:55 <halogenandtoast> LiaoTao: yes
23:36:54 <LiaoTao> It feels like it's just the wrong way to go about things when it's possible hide the grit beneath beautiful abstractions
23:37:12 <LiaoTao> #HaskellDamage
23:41:02 <EvanR> LiaoTao: i feel like haskell has a lot of boiletplate... im afraid to find out what java is like
23:41:43 <LiaoTao> EvanR: I'm only speaking from a beginner point of view, but it's undeniably cleaner at this point than either Java or C++ ever was
23:42:32 <EvanR> conceptually yeah
23:53:56 <Axman6> that's the price you have to pay to use a REAL language!
23:54:12 <Axman6> not this academic nonsense we're all wasting our time with
23:54:28 <Axman6> god I wish I could be a REAL programmer
23:54:42 <halogenandtoast> Axman6: here, have a job where I work.
23:55:30 <Axman6> how much of a programmer will I become?
23:56:21 <cocreature> Axman6: I can recommend using the ffi. you‚Äôll be debugging a lot of segfaults which is a pretty good way to become a real programmer
