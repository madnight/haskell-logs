00:21:39 <floof> Hi there! Can I crash Aeson derived parsing if it encounters a key that's not present in the record fields definition?
00:28:51 <cocreature> floof: no it should ignore additional keys
00:29:31 <cocreature> also it won’t crash either way. it will give you back Nothing on parse errors
00:30:24 <floof> cocreature: By 'crash' I mean 'fail to parse the entire object'
00:30:39 <floof> And there's no way even if I really want to?
00:31:29 <cocreature> write your own instance
00:32:26 <floof> That's the laborious option, was hoping there's a flag that I can flip
00:53:39 <ongy> ohh, I figured out why I couldn't build happy without happy. -.-
01:06:10 <mivael> hi all
01:06:34 <mivael> Is there a standard (recommended) way of doing a "partial" fold on a list?
01:07:29 <ongy> what do you mean? Only for the first N elements in the list?
01:07:47 <mivael> As an example, something which takes a list and and an integer -- and gives the sum of first several elements together with the rest of the list?
01:08:52 <ongy> > \int list -> foldl (+) int $ take 5 list
01:08:54 <lambdabot>  <Integer -> [Integer] -> Integer>
01:08:55 <mivael> ongy: yes, something like that, but I also need the rest of the list to be preserved (for further processing)
01:09:30 <ReinH> :t splitAt
01:09:31 <lambdabot> Int -> [a] -> ([a], [a])
01:10:02 <mivael> ReinH: oh, yes!  Thank you very much.  Forgot about splitAt.
01:10:20 <guest223> Is there any up to date resource for learning haskell? LYAH and RWH seem to be outdated.
01:12:46 <cocreature> @where learnhaskell
01:12:46 <lambdabot> https://github.com/bitemyapp/learnhaskell
01:12:49 <cocreature> @where haskellbook
01:12:49 <lambdabot> http://haskellbook.com
01:12:53 <cocreature> ^ guest223 
01:13:03 <guest223> Thanks.
01:13:25 <cocreature> also lyah is not that badly out of date
01:13:36 <ReinH> it's not out of date, it just isn't very good
01:13:54 <guest223> ok
01:13:57 <cocreature> it is out of date in some places
01:14:40 <cocreature> e.g. the code for State, Reader and Writer doesn’t work since they are implemented as type synonyms over their transformers
01:24:09 <ReinH> I don't think that's out of date, I think it's a simplification for teaching purposes
01:25:02 <cocreature> maybe I’m missremembering
01:28:54 <se-11-fish> Hey, asked this a few days ago but still don't get it
01:29:02 <se-11-fish> In https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad.html they say:
01:29:03 <se-11-fish> A postfix 'M' always stands for a function in the Kleisli category: The monad type constructor m is added to function results (modulo currying) and nowhere else. So, for example,
01:29:08 <se-11-fish>  filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:29:17 <se-11-fish> how is filterM a function in the Kleisli category ? 
01:29:25 <se-11-fish> it's type is of the form (a -> m b) -> (n a -> m (n a))
01:29:31 <se-11-fish> where n stands for list monad
01:29:43 <se-11-fish> shouldn't it be of a form a' -> m b' to be in the Kleisli category?
01:30:44 <ReinH> a -> m b is the function in the Kleisli category
01:30:48 <ReinH> :t filter
01:30:50 <lambdabot> (a -> Bool) -> [a] -> [a]
01:30:51 <ReinH> :t filterM
01:30:52 <eklavya> bollu: hey, I can't seem to build simplexhc using stack
01:30:53 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
01:30:56 <ReinH> look at what is different
01:31:14 <se-11-fish> in filterM 'm' is at two places
01:31:20 <se-11-fish> m bool 
01:31:23 <se-11-fish> and m [a]
01:31:33 <ReinH> It can't not be in m [a]
01:31:56 <geekosaur> se-11-fish, I think you're overthinking this
01:32:09 <se-11-fish> so filterM is not in a Kleisli category? 
01:32:25 <ReinH> It isn't saying it is
01:32:37 <lfairy> filter turns normal functions into normal functions. filterM turns kleisli functions into kleisli functions instead
01:32:38 <se-11-fish> "A postfix 'M' always stands for a function in the Kleisli category"
01:33:04 <geekosaur> yes. the function in question may not be the function the M is applied to, but a function used by it
01:33:08 <geekosaur> like the filter predicate
01:33:19 <geekosaur> a -> Bool becomes a -> m Bool
01:33:31 <geekosaur> which necessarily causes the m to show up in the result type of filterM
01:33:43 <se-11-fish> so only one argument of filterM is in the kleisli category
01:33:46 <ReinH> and [a] -> [a] becomes [a] -> m [a]
01:33:50 <se-11-fish> not filterM itself
01:33:59 <geekosaur> again you are overthinking this
01:34:01 <se-11-fish> ReinH I understand that part
01:34:18 <se-11-fish> I don't understand how this works with multiple arguments
01:34:25 <se-11-fish> where there are several m's 
01:34:56 <se-11-fish> "A postfix 'M' always stands for a function in the Kleisli category" <- this is not strictly true, yes?
01:35:52 <geekosaur> could you demonstrate why you think it is not strictly true?
01:35:57 <geekosaur> you have not done so yet
01:36:18 <se-11-fish> is filterM a function in the kleisli category or not?
01:36:34 <se-11-fish> filterM itself as a whole
01:36:59 <geekosaur> filter :: (a -> Bool) -> ([a] -> [a])
01:37:01 * ReinH sighs
01:37:11 <geekosaur> filterM :: (a -> m Bool) -> ([a] -> m [a])
01:37:19 <geekosaur> is this clearer?
01:37:37 <se-11-fish> I understand right associativity of ->
01:37:45 <geekosaur> but you are missing its import
01:38:03 <mivael> ReinH: after some thought I have a doubt regarding the splitAt approach efficiency (if used for the "partial fold")
01:38:04 <se-11-fish> still think filterM is not in the kleisli category
01:38:19 <ReinH> If you insist on interpreting this non-rigorous statement as if it were perfectly rigorous, I'll point out that it says "a function" and does not specify which.
01:38:33 <geekosaur> I already pointed that out but se-11-fish is fixated
01:38:56 <ReinH> mivael: why?
01:39:23 <ReinH> Nowhere does it say that filterM is a function in a Kleisli category.
01:40:06 <geekosaur> [25 08:32:42] <geekosaur> yes. the function in question may not be the function the M is applied to, but a function used by it [25 08:32:46] <geekosaur> like the filter predicate
01:40:33 <se-11-fish> so postfix M refers just to one of the arguments not the whole function ?
01:40:53 <ReinH> Why are you trying to rules lawyer this?
01:40:57 <ReinH> It is not a rigorous statement.
01:41:03 <geekosaur> how would you refer to just one of the arguments, if postfix M is required by law to apply to the function itself?
01:41:11 <mivael> ReinH: suppose I have a list xs of size n and n is large enough... so (splitAt (n-5)) will effectively create another large list, won't it?
01:41:37 <ReinH> mivael: splitAt is lazy.
01:41:59 <ReinH> And you have to do the equivalent of splitAt anyway.
01:43:05 <mivael> ReinH: functional equivalent, yes, but is it equivalent from efficiency point of view, I'm not sure
01:43:13 <ReinH> What is your proposed alternative?
01:44:47 <mivael> ReinH: I'm not yet sure laziness helps because the (N-5)-sized list can not be represented by a ref to the original list because they have different tails.
01:45:29 <mivael> ReinH: I will post it when it be ready as a code.
01:46:29 <ReinH> Well, splitAt fuses
01:46:50 <ReinH> so with optimization and a good consumer, I would expect GHC to avoid creating the intermediate list at all
01:47:13 <mivael> understood
01:47:17 <mivael> I will test it.
01:50:20 <EvanR> can GHC fuse stuff that acts like a list and is exactly just a list with a different pair of constructor names
01:51:05 <ReinH> If the rules are written?
01:51:23 <EvanR> ah, rules
01:51:46 <ReinH> It is not magic, it is sufficiently advanced technology. :)
01:51:56 <EvanR> its both "not magic" and "no"
01:52:07 <EvanR> instead of magic and no
02:01:28 <se-11-fish> thx for fixing my fixation ReinH, geekosaur and lfairy :)
02:01:35 <se-11-fish> :t extract
02:01:36 <lambdabot> error: Variable not in scope: extract
02:01:40 <runeks> How can I compose two constructors that both construct a type of kind *->* into a single constructor of kind *->*? I want to write an instance declaration for a nested data type of kind *->*. Is it only possible using a newtype wrapper?
02:01:45 <se-11-fish> :t join
02:01:47 <lambdabot> Monad m => m (m a) -> m a
02:02:00 <EvanR> runeks: check out type compose
02:02:32 <se-11-fish> one more thing: which extract did Tulpanolla refer to few days ago <Tuplanolla> Then `join` becomes `extractM`?
02:02:45 <EvanR> type C = A `O` B
02:03:04 <EvanR> er
02:04:07 <ReinH> The one for comonads, I suppose, but I don't see it.
02:04:34 <EvanR> newtype O f g a = O (f (g a))
02:04:59 <EvanR> G `O` F
02:05:17 <ReinH> I'm not really sure what runeks is asking.
02:06:55 <geekosaur> se-11-fish, "extract" sounds like the Comonad equivalent of Monad's "return"
02:07:00 <ReinH> If it's Compose then it could also be done with data but why would you?
02:07:38 <geekosaur> which makes the observation a bit of a CT joke, I think
02:08:30 <ReinH> but I don't think join is extractM
02:08:32 <runeks> ReinH: Say I wanted to make a Monad instance of Maybe (Either e). How would I write that?
02:08:39 <ReinH> extract :: Comonad w => w a -> a
02:08:47 <ReinH> I don't see how that becomes join
02:09:29 <ReinH> runeks: Well, for starters, the composition of monads is not necessarily a monad.
02:09:33 <geekosaur> I don't either, which is why I suspect it's a CT joke and not an actual type equivalence
02:09:39 <ReinH> If it is, you can use Compose.
02:10:05 <ReinH> geekosaur: Ah, then I guess what I'm saying is that I don't think it's a very good joke.
02:18:49 <pacak>  instance Eq Message where      m1 == m2 = fromEnum m1 == fromEnum m2 
02:18:49 <pacak> Parsec, Y U DO THIS????
02:47:06 <bollu> eklavya pong
02:47:09 <bollu> eklavya what's the error?
02:47:17 <bollu> eklavya and as I said, right now, It's just an interpreter
02:50:13 <muzzle> whats the fastest way to do something like (Foldable f) => f a -> (a -> k) -> Map k [a] ?
02:51:47 <Rembane> muzzle: Fastest as in fewest operations or as in code golf?
02:52:37 <muzzle> fastest as in fewest operations
02:52:47 <muzzle> I have an algorithm where this problem eats up most of the time
02:52:59 <muzzle> I'll post a condensed version of my current solution shortly
02:53:18 <muzzle> but It's basically folding over the Foldable and using a strict HashMap
02:53:31 <muzzle> but I wonder if I couldn't make this step faster
02:55:24 <mclaren> i just figured out you can put the haskell logo as the ghci prompt
02:56:19 <muzzle> Rembane: http://lpaste.net/356460 this is what I currently have
02:56:43 <muzzle> But this still eats up too much time imo
02:57:36 <muzzle> This is already way faster than using standard Map, sorting the foldable beforehand and even putting the foldable into a mutable Vector which i sort in place using vector-algorithms
03:00:05 <geekosaur> alter seems like the wrong tool for this
03:00:26 <muzzle> geekosaur: its faster than using lookup and then insert
03:04:07 <Rembane> muzzle: Ah, nice. If you profile this code, what parts take the most time?
03:04:30 <muzzle> alter apparently
03:04:38 <muzzle> followed by hash
03:06:27 <muzzle> Rembane: 60 percent of the spent time is used for cost centre 'f'
03:08:27 <Rembane> muzzle: Check. Is alter faster than insertWith?
03:10:18 <geekosaur> :t \toKey -> M.fromAscList . map (\(k,v) -> (toKey k,v)) . map (\xs -> (fst (head xs),map snd xs)) . groupBy ((==) `on` fst) . sortOn fst
03:10:20 <lambdabot> (Ord t, Eq k) => (t -> k) -> [(t, b)] -> M.Map k [b]
03:10:21 <muzzle> Rembane: I have to recheck but I think so
03:10:50 <Rembane> muzzle: It's an extra conditional that you don't actually use.
03:10:53 <geekosaur> hm, actually fromAscList won't fly there
03:11:14 <muzzle> geekosaur: sorting made this slower in all the ways i tried
03:11:16 <geekosaur> and of course it's a list not a Foldable
03:12:03 <muzzle> Rembane but for insert with I would have to allocate a cons cell that I don't use, right?
03:12:45 <geekosaur> muzzle, if the list is already sorted by the proto-key then you can drop the sort. if it's not then you didn't try the right ways because that alter will cost you even more
03:13:09 <muzzle> geekosaur: I'm using HashMap, so shouldn't sorting be irrelevant?
03:13:28 <geekosaur> the sort is needed for the groupBy
03:13:28 <muzzle> geekosaur: standard containers-Map seems to be slower than unordered-containers
03:13:54 <Rembane> muzzle: I can't see why you need to do that, but I haven't reached peak coffee yet.
03:14:04 <geekosaur> unordered-containers currently has a very fast and severely broken optimization, so if that is a recent determination then you potentialy have other problems
03:14:13 <geekosaur> (memory corruption with multiple threads)
03:14:45 <muzzle> Rembane: because for insert with I have to do "insertWith (++) k [x] mp", where [x] is a cons cell that's allocated but not used, right?
03:14:50 <geekosaur> also note that the groupBy combines all the sublists together beforehand so the map part is faster
03:15:00 <geekosaur> er, the Map part
03:15:20 <geekosaur> also I could fuse those two map invocations, but I think it's easier to understand this way and ghc should already fuse them
03:15:23 <muzzle> geekosaur: but sorting is slow
03:15:39 <geekosaur> and back to what I first said
03:15:50 <Rembane> muzzle: Yes indeed, that's a bother.
03:22:17 <geekosaur> I do wonder if the Foldable is costing you. also I could avoid double-sorting by using fromAscList at the price of running toKey more often, so that depends on how expensive toKey is.
03:22:40 <geekosaur> but you seem to be building a "no, you have rejected all possible optimizations, you have forced the slower route"
03:23:31 <muzzle> geekosaur: what do you mean?
03:30:04 <cocreature> geekosaur: which broken optimization in unordered-containers are you referring to?
03:40:30 <nickkuk> cocreature geekosaur: maybe this https://ghc.haskell.org/trac/ghc/ticket/13615  ?
03:45:29 <EvanR> i just discovered a book like "implementation of functional programming languages" 
03:45:45 <EvanR> a few years newer https://www.microsoft.com/en-us/research/wp-content/uploads/1992/01/student.pdf
03:46:05 <EvanR> apparently both are by SPJ
03:50:00 <cocreature> nickkuk: oh right I forgot that this bug originated in unordered-containers
03:50:10 <sedeki> EvanR yeah. I heard about it on a podcast
03:53:22 <ADG> where can I run online some code?
04:01:24 <pita> \quit
04:01:57 <cocreature> Adeon: codepad.org allows you to compile & execute Haskell code but for anything serious you really want a local setup
04:28:00 <ADG> (Java) https://github.com/adityagupta1089/Project-Euler/blob/master/src/problems/P126.java vs (Haskell) https://github.com/adityagupta1089/Project-Euler-Haskell/blob/master/src/126.hs, I tried to write similar code but runs in 0.5 sec vs 16.2 sec (-O3). Also system crashes on -prof .
04:28:20 <ADG> I guess it's strictness
04:33:48 <srhb> ADG: There is no -O3, afaik
04:34:52 <ADG> With -O2 its also same, I get no problem with -O3
04:34:59 <ADG> *while compiling
04:35:12 <srhb> ADG: Still, it is not a thing. It is equivalent to using the default optimization level.
04:36:18 <ADG> Are you able to profile it atleast?
04:37:02 <srhb> ADG: Sorry, not interested. Just wanted to let you know that -O3 is wrong. :)
04:37:10 <ADG> (y)
04:40:35 <cocreature> ADG: http://lpaste.net/356465 is already significantly faster for me but it’s still slower than the java implementation. GHC is probably not smart enough to optimize away all those lists. you could try just writing loops over a mutable vector instead
04:42:11 <ADG> yay! you're a life saver. It reduced time required drastically
04:42:24 <ADG> I'm done in 3.8 secs
04:43:00 <piyush-kurur> anyone here familiar with appveyor
04:43:01 <piyush-kurur> ?
04:43:04 <cocreature> maybe if you write the generator for the list yourself instead of relying on list comprehensions, ghc is able to optimize it away
04:44:38 <piyush-kurur> mistuke and I am trying to get raaz to build on windows@appveyor https://github.com/raaz-crypto/raaz/pull/327#issuecomment-310897375
04:44:44 <piyush-kurur> any help is appreciated
04:48:18 <seb___> I'm wondering if someone can help me something with WAI. I tried this example: http://www.yesodweb.com/book/web-application-interface#web-application-interface_resource_allocation. Basically you are modifying an variable, keeping track of requests.
04:48:50 <seb___> I then tried modifying it to: https://gist.github.com/AusCoder/a726c41e82db95d41fcd35914bd9d8b3 and it no longer works. I have no idea why.
05:01:07 <Phyx-> piyush-kurur: Hi
05:01:49 <piyush-kurur> Phyx-: Hi
05:03:19 <Phyx-> piyush-kurur: it's Mistuke btw
05:03:30 <piyush-kurur> Phyx-: guessed so
05:03:39 <piyush-kurur> Phyx-: thanks for all your effort
05:04:13 <piyush-kurur> I just asked for help, it looks like not many are familiar with appveyor
05:04:49 <Phyx-> piyush-kurur: no problem. the 32 bit one, there's only two options really, use dynamic linking/loading or just provide it a stub. the latter is just easier as without using the Win32 package the former is a bit more involved
05:05:20 <piyush-kurur> Phyx-: it looks like there is a way to get 64-bit builds See this https://ci.appveyor.com/project/TerrorJack/encoding-io/build/job/a5aq93aqxp6an1y0
05:05:51 <piyush-kurur> His appveyor.yml files also looks simplere
05:05:56 <piyush-kurur> *simpler
05:07:04 <Phyx-> piyush-kurur: ah indeed, but I suppose I should still fix the 32 bit build, don't know how many use it but we still produce the bindist afterall :)
05:07:16 <Phyx-> but for CI, the 64 bit would be far more stable
05:09:15 <piyush-kurur> Phyx-: yes we should but it is a bit irritating to have build fails. I am not sure whether appveyor supports something like allowed failures, (it supports build matrix) so we can have two builds one for 32 and one for 64
05:10:22 <Phyx-> piyush-kurur: testing both would be ideal yeah
05:10:35 <piyush-kurur> I will do one thing. Let me try the build matrix stuff. You can rebase the code once that works out
05:11:01 <Phyx-> sure, i'm just fixing the 32bit one and then will make the alloca change
05:11:05 <piyush-kurur> I will also disable the -v3 because there is a lot of nonsense that that hides the actual errors
05:11:59 <Phyx-> indeed
05:12:24 <Phyx-> -v would be a lot more useful.
05:13:31 <piyush-kurur> Okey I will keep it. currently it is -v3. Do you want it to maybe reduce the verbosity 
05:14:37 <Phyx-> yeah, just -v should be enough
05:14:57 <piyush-kurur> I guess you mean -v1
05:14:58 <piyush-kurur> ?
05:16:30 <Phyx-> no, they're not equivalent, don't know what -v actually defaults to but it's not 1.
05:16:55 <piyush-kurur> okey
05:16:59 <piyush-kurur> let me try
05:34:47 <piyush-kurur> Phyx-: I got the build matrix working. Let me also update the verbosity and I will let you know if it merged
05:38:33 <Sweet> Heyo
05:38:50 <Sweet> does anyone have experience with threepennygui ?
05:39:32 <Sweet> I'm building something with it, and so far I've avoided using FRP stuff, but it's getting tiring having to refresh the page for every little change
05:40:49 <Phyx-> piyush-kurur: cool :)
05:42:00 <Sweet> Here's my code
05:42:07 <Sweet> http://lpaste.net/7602186427106852864
05:42:17 <Sweet> http://lpaste.net/573105145894666240
05:42:58 <Sweet> I'm trying to use sinks instead of the gets but I'm having problems wrapping my head around the types required
05:43:23 <Sweet> buttons work fine but I have to refresh the page for them to work too
05:44:29 <Shockk> hello, where should I begin to try and debug an error like this, coming from stack?
05:44:38 <Shockk>  Configuring llvm-hs-4.2.0...
05:44:39 <Shockk>  Maybe.fromJust: Nothing
05:45:09 <cocreature> Shockk: ouch that looks bad. is that all the output you get?
05:45:18 <Shockk> cocreature: that's all I get even with --verbose
05:45:40 <Shockk> this is with the 64-bit windows version of stack, and I get it on cygwin, mingw64, and from cmd too
05:46:24 <Shockk> hmm I mean hang on
05:46:42 <Sweet> I think I'm just going to go with gloss :')
05:46:55 <Sweet> I'm really bad with monads and FRP..
05:47:00 <Phyx-> check Setup
05:47:03 <Shockk> cocreature: here https://gist.github.com/shockkolate/929646d61d4b10c071c3a42343cb230e
05:47:03 <cocreature> Shockk: what’s the output of "llvm-config --libs" and "llvm-config --system-libs"
05:48:11 <cocreature> yeah we haev a fromJust in Setup.hs but I’m not sure how that can triggered
05:48:19 <Shockk> https://gist.github.com/shockkolate/cabe4e3a3b2ea1e28b16b631558dfcc4
05:48:24 <Shockk> which Setup.hs?
05:48:31 <Shockk> for llvm-hs?
05:48:32 <cocreature> the one in llvm-hs
05:48:37 <Shockk> ahh right
05:48:48 <piyush-kurur> Phyx-: Now the master contains the build against both 64-bit and 32-bit builds
05:48:49 <cocreature> hm ok so apparently on windows there is no -l in front of the link flags
05:49:01 <Shockk> ..lol
05:49:05 <piyush-kurur> Phyx-: you can rebase your branch to the current master
05:49:15 <Shockk> I see
05:49:28 <cocreature> Shockk: let me push a fix
05:49:34 <Shockk> okay, thanks :D
05:49:58 <Shockk> I guess when built on windows maybe it expects to be used with vs? idk
05:50:20 <cocreature> personally I just never tested on windows since I don’t have access to a windows machine
05:50:41 <cocreature> I’m pretty sure some people tested on windows so I’m not sure why you are the first with this problem
05:51:56 <Shockk> I mean, the first thing I tried was building llvm within cygwin, but this caused issues like the following
05:51:57 <Shockk> Warning: 'extra-lib-dirs: /home/shockk/usr/llvm/lib' directory does not exist.
05:51:58 <Shockk> Warning: 'include-dirs: /home/shockk/usr/llvm/include' directory does not
05:52:26 <Shockk> so today I built llvm through vc++
05:52:29 <sproingie> my first reaction to cygwin these days is "why"?
05:52:58 <sproingie> makes an all right unix environment, but as a platform it's built on sand
05:52:59 <Phyx-> piyush-kurur: I'll rebase in a bit, just fixing the 32 bit issue
05:53:01 <cocreature> Shockk: your build still looks kind of weird. the paths look very linuxy
05:53:04 <cocreature> or unixy
05:53:48 <Phyx-> Shockk: all you really had to do is pacman -S llvm
05:53:50 <Phyx-> from msys2
05:54:27 <Shockk> cocreature: the usr\llvm stuff?
05:54:27 <Phyx-> mixing cygwin with the ghc bindist has been known to cause weird errors also
05:54:31 <cocreature> Shockk: yep
05:54:48 <Shockk> I could have called it something else but I figured that makes sense in my head
05:54:50 <sproingie> Phyx-: mixing cygwin with anything, really, especially once it touches the filesystem
05:55:00 <Phyx-> officially we don't really support cygwin anymore
05:55:03 <cocreature> Phyx-: since you’re the ghc windows expert, do you know under which circumstances -l is included in linker flags on windows?
05:55:54 <cocreature> Shockk: try https://github.com/cocreature/llvm-hs/tree/strip-link-flags
05:56:44 <Phyx-> cocreature: it's only added for any extra libraries
05:57:14 <Phyx-> cocreature: so anything from extra-libraries in cabal, or from the package configs for boot libraries
05:57:18 <cocreature> Phyx-: and llvm libraries are not “extra libraries”?
05:57:33 <Shockk> hmm okay, what do I do in order to use this instead of the published version in my code?
05:57:54 <Phyx-> cocreature: it depends on how they're specified. how do they get passed from llvm-config?
05:57:57 <cocreature> Shockk: you can either point to the git repo in your stack.yaml or you can clone the repo locally and add the path to packages in your stack.yaml
05:58:42 <cocreature> Phyx-: the thing that’s confusing me is that "llvm-config --libs" contains linker flags on linux, e.g., "-lnameoflib", while for Shockk on windows it only contains the paths
05:59:05 <cocreature> which obviously breaks our assumption that we always need to strip "-l" but I don’t quite understand why this behaves differently
05:59:24 <Phyx-> cocreature: ah, that may very well be, which llvm-config is he using?
05:59:30 <Shockk> cocreature: also llvm-config --ldflags on here prints -LIBPATH:C:\Users\shockk\usr\llvm\lib
05:59:31 <sproingie> -lfoo should work on a windows gcc port too.  assuming foo.dll is in the path somewhere
05:59:37 <Phyx-> yes
05:59:48 <Phyx-> but he compiled it with msvc
05:59:56 <Phyx-> presumably that's why llvm-config doesn't include it
06:00:04 <Phyx-> since -l isn't a valid flag there
06:00:08 <cocreature> ah ok
06:00:17 <sproingie> i imagine it's spitting out the flags in terms the gcc front-end understands.  only.
06:00:34 <sproingie> personally i'd call that a llvm bug, it should also support the cl front end
06:01:16 <Phyx-> it's not, the behaviour seems to be that llvm-config spits out flags based on the compiler that compiled it
06:01:28 <Phyx-> e.g. he compiled with msvc so it's spitting out flags for msvc
06:01:37 <cocreature> which is somewhat reasonablae
06:01:39 <cocreature> *reasonable
06:01:43 <Phyx-> my llvm-config compiled for gcc is splitting out -l fine
06:01:52 <Phyx-> $ llvm-config --libs
06:01:53 <Phyx-> -lLLVM.dll
06:02:10 <sproingie> i suppose that makes sense, the flags are specific to that compiler anyway
06:02:23 <sproingie> i was thinking in terms of recompiling with itself
06:02:51 <cocreature> llvm-config spits out the flags which were used to compile itself not the flags you need to link against it which is kind of annoying
06:02:53 <Shockk> cocreature: I'm struggling with this, do I just add location: git: https://github.com/cocreature/llvm-hs/tree/strip-link-flags, in packages:?
06:03:34 <cocreature> Shockk: take a look at https://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
06:04:11 <cocreature> you’ll need the url, the most recent commit on that branch and "subdirs: -llvm-hs"
06:05:17 <sproingie> for an extra-dep, you need the commit id and an extra-dep line with very fiddly indentation
06:05:23 <sproingie> https://github.com/chuckadams/scamp/blob/master/stack.yaml for an example
06:06:24 <Phyx-> I'd really recommend you use the llvm compiled by msys2, especially if you compiled a static version.
06:06:43 <Phyx-> currently GHC does not support C++ code compiled from msvc very well
06:06:49 <Shockk> hmm okay
06:07:02 <sproingie> have i mentioned how much i dislike the extra-dep syntax in packages?  it should have just been in the extra-deps section.
06:07:05 <Phyx-> well, GHC works fine, but GHCi won't
06:07:36 <Shockk> cocreature: also after trying that, I got "Missing C libraries:" followed by all the LLVMSomeName.lib libraries
06:08:28 <Shockk> let me grab msys2 then
06:08:55 <cocreature> Shockk: what’s the output of llvm-config --libdir?
06:08:57 <Phyx-> Shockk: if you're using stack you already have it
06:09:03 <Shockk> oh
06:09:49 <Phyx-> I'm not sure of the command, but there's a flag or something you can use to get stack to drop you to the shell
06:12:17 <Shockk> can't see anything in --help but I'd already downloaded and installed msys2 by the time you said I already have it
06:12:25 <Shockk> so that's getting llvm now
06:12:47 <Phyx-> yeah, pacman is handy
06:13:02 <sproingie> stack might bring in msys compiler, but stuff like pacman would be in the full msys2 install
06:13:04 <Shockk> I did pacman -S llvm, is this going to get the correct version?
06:13:22 <Shockk> llvm-hs uses llvm 4.0.*
06:13:42 <sproingie> that's pretty bleeding edge
06:13:55 <cocreature> well it’s the last stable release
06:14:03 <cocreature> which is a few months old by now
06:14:08 <Phyx-> afaik, stack doesn't have a custo msys2 version
06:14:10 <Shockk> right, okay
06:14:16 <sproingie> still fairly recent.  but yah should be well tested.
06:14:19 <Phyx-> stack exec -- pacman -S llvm
06:14:24 <Phyx-> should have done it
06:15:24 <Phyx-> stack exec -- sh
06:15:28 <Phyx-> should drop you to a shell
06:15:33 <sproingie> other than STACK_EXE, stack exec doesn't seem to add anything to the shell it invokes
06:15:55 <cocreature> it modifies PATH
06:17:27 <sproingie> ah, hadn't tested it inside a stack project.  makes sense.
06:17:49 <cocreature> and it sets GHC_PACKAGE_PATH and similar stuff
06:21:30 <Shockk> cocreature: I'll ping you and let you know if it works after I wrestle with issues between using like 3 different kinds of shell :(
06:22:00 <cocreature> Shockk: I’ll be gone soon so just open an issue if I don’t respond
06:22:06 <Shockk> okay
06:23:58 <davr0s> haskell array construction - assumes the array is of variable size  ?   .. so i would not instance the 'Array' typeclass for a *fixed size array*?   (i have fixed size containers holding x,y,z   x y z w  ..  i should be able to implement the indexing operator for them ( i gather that is conventionally array!index here)
06:30:46 <Shockk> Phyx-: I cleaned up the other msys2 and tried using that cmd through stack, but I get "error: target not found: llvm"
06:32:30 <Shockk> Phyx-: ah never mind, I solved it by running pacman -Sy
06:35:01 <sepakorayl> what's an easy way to deriving instances for fix types?
06:36:24 <Phyx-> Shockk: ah :)
06:36:30 <Shockk> Phyx-: lol it's too old :( it's 3.8
06:37:27 <Phyx-> Shockk: pacman -S mingw-w64-$(uname -m)-llvm
06:37:57 <Phyx-> that'll get you native 4.0
06:38:25 <Shockk> great :D
06:38:26 <Shockk> thanks
06:40:54 <Phyx-> hmm how do you use "extra-lib-dir" with a relative folder?
06:58:34 <davr0s> import  Data.Array        instance Ix i=>Array Something i e  where (!) Something... i = ...     
06:58:48 <davr0s> ^^^ i'm getting an error ,  ‘!’ is not a (visible) method of class ‘Array’ 
06:58:53 <Shockk> Phyx-: now I have a weird issue; if I run `stack exec -- ls /mingw32/bin` then I see llvm-config.exe in there
06:59:13 <Shockk> however if I do `stack exec -- /mingw32/bin/llvm-config.exe` I get
06:59:24 <Shockk> "Did not find executable at specified path: /mingw32/bin/llvm-config.exe"
06:59:59 <Shockk> I can't run `stack exec -- llvm-config` either
07:04:40 <Phyx-> Shockk: because those paths don't exist on Windows only in the shell, ls.exe is a msys2 utility so uses their msys2.dll to translate paths
07:04:47 <Phyx-> Shockk: instead do stack exec -- sh
07:04:51 <Phyx-> and run your commands from there
07:05:24 <Phyx-> or go through sh, e.g. stack exec -- sh llvm-config
07:05:34 <Shockk> hmm nope it still didn't work within there
07:06:07 <Phyx-> does stack exec -- sh drop you to a shell?
07:06:21 <Shockk> I should mention, my uname -m is x86_64 but I used i686 because the x86_64 llvm version is 3.5 in pacman 
07:06:28 <Shockk> i686 llvm is version 4.0
07:06:38 <Shockk> it does, I'm in the shell and llvm-config doesn't work there
07:06:51 <Phyx-> that won't work
07:07:03 <Phyx-> you can't load a 32 bit image in a 64 bit process
07:07:08 <Shockk> oh :(
07:07:08 <Shockk> okay
07:07:16 <Phyx-> and it's not, mingw-w64-x86_64-llvm-4.0.0-1-any.pkg.tar.xz 
07:07:18 <Phyx-> is the latest
07:07:26 <Shockk> huh
07:07:43 <Shockk> mine was showing 3.5 as the latest
07:08:10 <Phyx-> did you forget a -Sy ? if not likely the msys environment stack uses is too old and the dependency resolution is forcing 3.5
07:08:21 <Shockk> lemme try again
07:08:34 <Shockk> pretty sure I did it but don't remember
07:09:25 <Phyx-> if that's the case pacman -Syuu to upgrade all dependencies an
07:09:27 <glguy> davr0s: (!) isn't a method of the Array class, so you can't put it there
07:10:02 <Shockk> okay let me try that
07:12:16 <glguy> davr0s: Array isn't even a type class
07:13:02 <davr0s> oh ok that would explain it.
07:13:47 <davr0s> i'm looking for the typeclass that holds that operator then;  I see  a typeclass for index , Ix but where do i find the operator
07:14:47 <glguy> davr0s: start by looking at the documentation.
07:14:58 <glguy> ?hackage array
07:14:58 <lambdabot> http://hackage.haskell.org/package/array
07:16:44 <davr0s> oh hoogle tells me this:   (!) :: Ord k => Map k a -> k -> a       
07:17:42 <davr0s> ok thats not relevant either
07:17:57 <davr0s> (!) just happens to be implemented for 'Map ..'
07:18:16 <glguy> yeah, probably better to start with my link
07:18:24 <Shockk> Phyx-: lol :( I'm getting demotivated
07:18:32 <Shockk> /mingw64/bin/llvm-config: /mingw64/bin/llvm-config: cannot execute binary file
07:20:46 <davr0s> ok i saw 'IArray'  but i still get this error "instance Ix i=>IArray Vec2 i e where
07:20:46 <davr0s>   (!) (Vec2 x y) 0 = x"   --->   "(!) is not a (visible) method of IArray".
07:21:45 <davr0s> what I thought is one would be able to implement the 'typeclass'  for any array-like type
07:21:46 <acyed> Hello everyone. Forever uses (>>) to do an IO action repeatedly. Is there a version of this that uses bind? 
07:22:13 <Phyx-> Shockk: did you remove the i686 one?
07:22:23 <Shockk> ummm
07:22:34 <Shockk> maybe, maybe not, I'll let you know if I removed it after I remove it
07:22:41 <Phyx-> :)
07:22:56 <Phyx-> pacman -R should do it
07:23:38 <Shockk> done, that didn't remove the error though
07:24:19 <Phyx-> remove both
07:24:27 <Phyx-> and reinstall the 64bit one
07:24:52 <Shockk> okay, trying that
07:24:56 <Phyx-> did you modify your path before?
07:25:01 <Phyx-> when you made the msvcr one?
07:25:23 <Shockk> oh, yes, but I removed the msvc build already
07:26:11 <Phyx-> I think it's still loading a 32bit dll somewhere. so you can try strace llvm-config
07:26:16 <Phyx-> and see what ot's loading
07:26:53 <Shockk> nothing outputs from strace, but I get this message box
07:27:09 <Shockk> "The application was unable to start correctly (0xc000007b). Click OK to close the application."
07:27:45 <davr0s> hmm, it seems to let me just define (!) out in the open, (i thought an overloaded operator would need to be defined by instancing a typeclass. maybe it will complain later)
07:28:20 <Shockk> Phyx-: the output of ldd `which llvm-config` gives:  ntdll.dll, kernel32.dll, kernelbase.dll, msvcrt.dll
07:28:48 <Phyx-> Shockk: 0xc000007b is an image loading error
07:28:56 <Phyx-> it's indeed picking a 32bit image
07:29:03 <andromeda-galaxy> davr0s: did lambdabot tell you about my solution to the records problem?
07:29:05 <Shockk> right
07:29:07 <Phyx-> so you have something left from the 32 bit installs you made
07:29:12 <davr0s> andromeda-galaxy yes it did, thanks!
07:29:24 <Shockk> okay let me wipe the stack compiler install and try again
07:29:35 <Guest32833> @hoogle [a] -> [a]
07:29:35 <lambdabot> Prelude tail :: [a] -> [a]
07:29:35 <lambdabot> Prelude init :: [a] -> [a]
07:29:35 <lambdabot> Prelude reverse :: [a] -> [a]
07:29:38 <davr0s> i haven't tried it yet , i'll get onto that at imminently
07:30:15 <Guest32833> @pl (\x y -> fmap (*) x <*> y)
07:30:16 <lambdabot> (<*>) . fmap (*)
07:30:57 <andromeda-galaxy> davr0s: great!
07:32:50 <davr0s> for starters i figure i need to find out the story on Arrays in haskell, if i've understood right [T] is not for random access.
07:33:26 <andromeda-galaxy> yes, [t] is a linked list and therefore quite bad
07:33:40 <andromeda-galaxy> IIRC there are a few different libraries for array-y things, depending on what you want to do
07:34:48 <davr0s> context.. 'a vertex array'.   multi-dimensional arrays would probably be useful (shape, index),   (vertexIndex,channel),  whatever
07:40:36 <andromeda-galaxy> did you already identify an array package that you thought looked useful?
07:40:43 <andromeda-galaxy> I remember having some luck with arrays and repa in the past
07:40:56 <testing2> @pl \(u, 1) -> standardise' u
07:40:57 <lambdabot> standardise' . fst
07:41:58 <testing2> @pl \(s, t, w) -> (t, s, 1 / w)
07:41:58 <lambdabot> (line 1, column 9):
07:41:58 <lambdabot> unexpected "w"
07:41:58 <lambdabot> ambiguous use of a non associative operator
07:42:32 <testing2> @pl \a b -> a + b / 10
07:42:32 <lambdabot> (. (/ 10)) . (+)
07:43:55 <testing2> @pl \s g -> f (s +) g
07:43:55 <lambdabot> f . (+)
07:45:05 <testing2> @pl \_ te -> Neg te
07:45:06 <lambdabot> const Neg
07:47:45 <testing2> @pl \x y -> y
07:47:45 <lambdabot> const id
07:48:00 <lyxia> testing2: you can /query lambdabot
07:49:38 <Shockk> Phyx-: I wiped stack, ran stack setup again, went into its sh, ran pacman -Syuu, then pacman -S mingw-w64-$(uname -m)-llvm
07:49:47 <Shockk> I still get the same error ;/
07:49:49 <Shockk> :/ *
07:50:01 <Shockk> strace shows stuff now though
07:51:49 <Shockk> Phyx-: https://gist.github.com/shockkolate/45a84ee4fc0ab1e1269f76dc7870ad86
07:53:15 <Phyx-> Shockk: it's picking up libffi from C:\Program Files (x86)\GtkSharp\2.12\bin\libffi-6.dll
07:53:19 <Phyx-> which looks very odd
07:53:27 <Phyx-> and that's a 32 bit image
07:54:12 <testing2> @pl \te' -> Mult (f te) te'
07:54:12 <lambdabot> Mult (f te)
07:54:27 <Shockk> hm that's strange
07:54:51 <Shockk> I mean, I guess let me get rid of gtk#
07:55:03 <testing2> @pl \y -> (u * y + v, t)
07:55:03 <lambdabot> flip (,) t . (v +) . (u *)
07:55:16 <testing2> @pl \(u, d) -> (u, -d)
07:55:16 <lambdabot> (line 1, column 14):
07:55:16 <lambdabot> unexpected ","
07:55:16 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
07:55:23 <testing2> @pl (\(u, d) -> (u, -d))
07:55:24 <lambdabot> (line 1, column 15):
07:55:24 <lambdabot> unexpected ","
07:55:24 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
07:55:39 <testing2> @pl (\(u, d) -> (u, -d))
07:55:39 <lambdabot> (line 1, column 15):
07:55:39 <lambdabot> unexpected ","
07:55:39 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
07:56:24 <Shockk> Phyx-: now I get this https://gist.github.com/shockkolate/4ebfe9316f32818b11ecfcef6af725b5
07:56:29 <Shockk> no idea what's happening this time
07:56:53 <testing2> @pl \(s, t, w) -> (s ++ u, t ++ u, w)
07:56:53 <lambdabot> (line 1, column 9):
07:56:53 <lambdabot> unexpected "w"
07:56:53 <lambdabot> ambiguous use of a non associative operator
07:57:10 <testing2> @pl \u -> generateDataSubgraph ('a' : u) 1000
07:57:10 <lambdabot> flip generateDataSubgraph 1000 . ('a' :)
07:58:10 <andromeda-galaxy> testing2: please /q lambdabot, instead of asking it in the main channel
07:59:15 <pja>  /query lambdabot
07:59:40 <Phyx-> Shockk: hmm and same error? I don't see an error at the end of llvm-config
08:00:13 <Shockk> oh, that's the output up until the msgbox appears
08:00:24 <Shockk> then three threads and the process all exit with status 0xc0000135
08:00:24 <Phyx-> and what's in the box?
08:00:42 <Shockk> wait
08:00:42 <Shockk> hmmm
08:00:46 <Phyx-> yeah
08:00:50 <Phyx-> that's DLL NOT FOUND
08:00:52 <Shockk> lol why do I feel so stupid
08:01:00 <Shockk> the box is a different error message but I didn't bother to read it 
08:01:05 <Phyx-> because it now doesn't find a libffi
08:01:07 <Shockk> libffi-6.dll missing :(
08:01:20 <Shockk> hm okay
08:01:29 <Shockk> is there a pacman package to get that easily?
08:01:59 <Phyx-> pacman -S mingw-w64-$(uname -m)-libffi
08:02:30 <Shockk> yessssss
08:02:41 <Shockk> you're a true hero Phyx- 
08:02:53 <Shockk> I'm trying stack build for my project now, finally
08:03:04 <Phyx-> :)
08:12:26 <Shockk> Phyx-: great :D it works now
08:12:29 <Shockk> thanks very much
08:22:45 <Phyx-> Shockk: no problem :)
08:23:12 <Phyx-> I think stack should turn on path isolation maybe as a default, seems it would save a lot of people some trouble.
08:25:06 <Phyx-> piyush-kurur: I'll rewrite the lock stuff to use dynamic linking, that's less messy, the calls are simple anyway. but I'll have to do that tomorrow
08:51:41 <davr0s> are there any glaring *ommisions* in the haskell ecosystem (i.e. obvious slots to fill )
08:52:10 <monochrom> Uninstaller.
08:52:53 <ongy> a good way to bootstrap it
09:05:21 <juri_> all of the things written in safe haskell.
09:13:22 <cocreature> davr0s: datascience/machine learning is often cited as something that’s missing
09:13:37 <maerwald> davr0s: a formally verified compiler
09:16:03 <juri_> a self hosting haskell compiler?
09:18:23 <cocreature> juri_: so, ghc? :)
09:18:33 <pier> ciao
09:18:38 <pier> list.
09:21:36 <juri_> cocreature: GHC is self hosting? I learn something new every day. :)
09:22:40 <cocreature> juri_: sure, it’s written in Haskell and you compile GHC using GHC :)
09:23:12 <juri_> awesome. :)
09:23:14 <maerwald> davr0s: https://cakeml.org do something like that for haskell
09:23:25 <ongy> so what's the requirements to bootstrap ghc these days? :P
09:23:31 <maerwald> while at it, disallow all GHC extensions
09:23:44 <andromeda-galaxy> maerwald: what??
09:24:02 <monochrom> Not this again.
09:24:09 <juri_> as the lead developer of implicitcad, i keep my head down. there's so much in my own codebase to fix it...
09:24:33 <maerwald> andromeda-galaxy: should be hard to make a verified implementation with all GHC extensions
09:24:45 <maerwald> so you probably just want haskell
09:24:59 <maerwald> maybe even a subset 
09:25:02 <cocreature> depends on what part you want to verify
09:25:12 <cocreature> a verified compiler starting from core might not be so bad
09:25:21 <cocreature> in fact the deepspec people are working on that afaik
09:25:51 <davr0s> maerwald   "CakeML is free software. So far it is the result of about ten person years of work by an international team of six core developers "   
09:25:59 <maerwald> xD
09:26:14 <maerwald> one can dream
09:26:16 <davr0s> ok , i'll report back in 2027 
09:26:50 <monochrom> How did they arrive at the "ten person years" figure?
09:27:06 <davr0s> then again, one could argue translating a proven idea should be quicker, e.g. 'they did the experimentation, now follow their pattern..'
09:27:40 <maerwald> yes, I also think it should be a walk in the park
09:27:54 <davr0s> maerwald i guess the question would always yield an answer like that though.. Any 'small ommision' would quickly be filled... 'low hanging fruit is gone' 
09:28:35 <maerwald> well, there are a lot of things wrong with hackage (as a contribution and ecosystem platform), but fixing those will require not just code, but also politics, so...
09:28:59 <maerwald> other than that, most things we really lack are hard
09:29:12 <davr0s> i am well aware how establishing consensus can be as hard 
09:29:19 <maerwald> like... finally, a proper GUI DSL written in haskell
09:29:29 <davr0s> like with C++, there are things missing that aren't missing because they are hard, they are missing because of politics..
09:31:56 <[exa]> davr0s: about the C++, do you have some pretty example of a political decision?
09:32:00 <davr0s> seems like GUIs are really driven by platforms, each almost having it's own language (Apple -objC,swift;  Android-Java; Microsoft..C++ -> C# ) ... one thing Rust runs into is that it can't interface well with the crossplatform C++ gui (Qt) because it has different rules on naming
09:32:16 <davr0s> [exa] i have my suspicions about various things
09:32:31 <torstein> Anyone familiar with Accelerate? what's the best way to replace an index in a vector?
09:32:56 <maerwald> davr0s: it also doesn't play well with Gtk+, because of the gtk thread lifetime
09:33:02 <Phyx-> ongy: GHC 7.10+
09:33:09 <torstein> replace element at index*
09:33:15 <maerwald> you need a lot of "move environment and duplicate binding"
09:33:27 <ongy> Phyx-: oh.
09:34:01 <davr0s> maerwald yeah; what I'm getting at is you can't really just bind a gui to a language;  you have to design the GUI *around* the language.  I almost get the impression languages have been driven *by* guis, rather than vica versa.
09:34:24 <davr0s> e.g. what is Swift? ... it's what Apple devised *to still be able to use their GUI frameworks*
09:34:32 <maerwald> davr0s: not necessarily, check out diagrams (drawing DSL in haskell with different backend like cairo)
09:34:39 <Phyx-> ongy: the general policy is supporting two releases back
09:34:50 <pja> [exa]: concepts was sort of political. In that the cttee passed it & then the compiler writers went wtf? simultaneously.
09:35:00 <maerwald> davr0s: basically it would be something like wxwidgets
09:35:07 <torstein> my  current solution is "A.take (i - 1) vec ++ createVec elem ++ A.drop i vec", surely that's inefficient
09:35:11 <maerwald> which abstracts over GUI frameworks 
09:35:31 <Athas> torstein: wouldn't that be an impure operation?
09:35:57 <maerwald> davr0s: I think those are actually the things one should look at when thinking about a GUI DSL in haskell: diagrams and wxwidgets
09:35:59 <[exa]> pja: yeah, I didn't remember that one. thanks :]
09:36:09 <maerwald> and then come up with something awesome
09:36:24 <torstein> Athas: surely there's a pure way, like with standard vectors
09:36:35 <davr0s> maerwald ok, interesting.
09:36:37 <ongy> Phyx-: I was thinking about bootstrapping my own haskell environment, since I kinda dislike the packages in my distro lately, but both ghc and cabal are a bit hard to bootstrap :(
09:37:34 <Phyx-> ongy: ghc should be fairly straight forward
09:37:39 <Phyx-> cabal I haven't done in ages
09:37:55 <Phyx-> I remember there used to be a script that made it pretty painless though
09:38:02 <davr0s> 'machinelearning' ... surprising if that is not well developped?, I got the impression haskell code almost creates dependancy graphs (lazy eval)  .. and the machine-learning frameworks are about a graph of nodes 
09:38:19 <pja> ongy: ghc itself was ok in my experience, if a bit time consuming. Building a ghc cross compiler on the other hand, that was awkward :)
09:38:34 <ongy> Phyx-: the script is ok, but installs a few things into the global package cache... which I would like to avoid in favor of new-build things
09:39:27 <ongy> when I looked into building it yesterday, it failed at "need happy" so of course I wanted to build happy, which failed with cabal from git -.-
09:39:36 <ongy> ^that's ghc, not cabal
09:41:10 <cocreature> ongy: let me guess, you’re using arch and are unhappy with the decision to switch to dynamically linked libraries?
09:41:22 <ongy> cocreature: :)
09:41:43 <ongy> I could live with it, if cabal-install didn't pull in some of those
09:41:43 <cocreature> took me way too long to figure out why that update broke things
09:42:09 <ongy> I noticed, when pacman -Syu wanted to install >100 new packages, all with haskell- in their name (that was just the dependency tree of pandoc)
09:42:32 <ongy> cocreature: do you know if I can get the cabal-install boostrap.sh to not install?
09:42:32 <cocreature> I ended up building a statically linked cabal with stack, removed everything except for ghc and ghc-static and now I have a working environment again
09:42:40 <Phyx-> ongy: ah, I haven't built happy from source in a while
09:42:43 <cocreature> no idea, I’ve never tried bootstrapping cabal
09:42:54 <Phyx-> but why do you need to rebuild GHC to stop dynamic libraries?
09:43:28 <ongy> I don't. I just wanted to make a ghc-git package for aur, so I have a better reason to avoid the mess they made
09:43:40 <davr0s> i always got the impression FP should have been suitable for conditioning assets in gamedev, e.g. offline tools that take models and optimize them in various ways.. the aim being that the game runtime should be as simple as possible
09:43:49 <cocreature> yeah the problem is not so much ghc as it is the fact that the packages providing Haskell libraries and packages are dynamically linked
09:44:10 <cocreature> which means that you can’t install Haskell executables via the package manager without polluting your global package db
09:44:11 <ongy> at least they have ghc-static. But I'm not sure if I really want to rely on that staying
09:44:21 <davr0s> but all that stuff is more commonly built in the language of the tool or engine , for closer interoperability with either
09:44:26 <Phyx-> ongy: you could instead, download the ghc source tarballs
09:44:33 <davr0s> i.e. C++ plugins for 3d packages and C++ engines
09:44:36 <Phyx-> ongy: those are already preprocessed and so don't need happy and alex
09:45:51 <ongy> Phyx-: maybe I'll do that. For now I can live with ghc and ghc-static from the repos. cabal is more important, since the repo version pollutes the package db now
09:46:44 <maerwald> davr0s: also, you may want to call from other languages. If you do that in e.g. rust, that's easy. Not so much if it's in haskell.
09:47:26 <andromeda-galaxy> a slight digression: is there currently any way to use the type variable of an existential variable that is only used in a typeclass constraint on a gadt constructor? I see https://ghc.haskell.org/trac/ghc/ticket/11350 which implies that it isn't possible to do this the obvious way, but is there a reasonable workaround?
09:48:01 <davr0s> maerwald and even Rust gets the criticism - 'ok , if x/y/z library that we need is in C or C++.. and we need to bind to that.. why not just use C or C++ in the first place...'
09:48:13 <davr0s> very hard to fight momentum..
09:48:23 <maerwald> davr0s: no, I mean you write something in rust and you use that from language xyz
09:48:46 <maerwald> python, haskell, C, whatever
09:48:46 <davr0s> oh fair enough. but even then , basically the C++ interfaces have begun to get important
09:48:47 <Phyx-> how is haskell hard?
09:48:57 <davr0s> haskell needs its own runtime?
09:49:07 <davr0s> binding between langauges without their own runtimes is easier?
09:49:11 <Phyx-> which you can statically link in?
09:49:16 <Phyx-> and the whole point becomes moot?
09:49:51 <maerwald> davr0s: that's one of the reasons pijul was written in rust and not haskell afair
09:50:13 <davr0s> conversely a lot of real work these days happens across networks, which is why the web has so much more language variety than gamedev, right?
09:52:36 <Phyx-> and conversely, every language has a runtime
09:52:40 <Phyx-> even C has a runtime
09:52:45 <Phyx-> multiples infact
09:53:54 <maerwald> haskell does not have a runtime
09:54:28 <Phyx-> sure, if you want to be pedantic, GHC has one
09:54:46 <maerwald> exactly, and then we can talk about languages, which only have transpilers
09:54:54 <maerwald> so "every language has a runtime" is a bit broad
09:56:18 <Phyx-> sure, "every practical implementation of a language results in compiled binaries which contains a runtime of sorts"
09:58:02 <maerwald> is Coq not practical? :>
10:00:18 <totonk> May I ask a amature question here? What is the meaning runtime of a language?
10:00:31 <Lowl3v3l> maerwald: even coq programs need some sort of runtime, and if its just the kernel services it accesses ;)
10:02:06 <Lowl3v3l> totonk: its a collection of functions and data that need to be present for programs to run, for C programs on linux its libnc, libm , libgcc and some other little parts. it does for example handle the initialization ( global constructors come to mind), input and output of a program
10:04:17 <ongy> also threading
10:05:54 <Phyx-> and sometimes things like remote debugging, etc
10:07:22 <ongy> remote debugging? ssh and gdb? :)
10:08:02 <Phyx-> no, e.g. newlib's baremetal support for I/O forwarding
10:21:19 <Shockk> cocreature: I got llvm-hs working; but there's an issue with stack repl now
10:21:44 <Shockk> when I run stack repl within my project directory, I get unknown symbol LLVMVerifyModule
10:23:18 <cocreature> Shockk: I’m not particularly surprised about errors with regards to ghci tbh. I’ve encountered those myself sometimes but so far I haven’t been able to track down what is going wrong and how I can fix it. also cabal repl, cabal new-repl and stack ghci seem to behave differently so I’m not even sure where the problem actually is
10:23:33 <Phyx-> Shockk: can you paste the full trace?
10:23:41 <Phyx-> I think you're hitting an error I fixed for 8.2
10:23:50 <Shockk> ghc.EXE: unable to load package `llvm-hs-4.2.0'
10:23:50 <Shockk> ghc.EXE: C:\Users\shockk\dev\etch\.stack-work\install\5264c238\lib\x86_64-windows-ghc-8.0.2\llvm-hs-4.2.0-3nqRuUMPSpLBaqyeNH7jd6\HSllvm-hs-4.2.0-3nqRuUMPSpLBaqyeNH7jd6.o: unknown symbol `LLVMVerifyModule'
10:24:27 <Shockk> wait, should I run with something like --verbose?
10:24:29 <Phyx-> run it with -v3 and pastebin it :)
10:24:34 <Shockk> ah okay
10:25:05 <andromeda-galaxy> there's no way to do runtime instance search for something, is there?
10:25:07 <Shockk> invalid option -3?
10:25:22 <Phyx-> -v3
10:25:24 <Shockk> this is stack repl/ghci btw
10:25:31 <Shockk> I mean if I give -v3, it gives me that
10:25:38 <cocreature> you probably need to pass that to ghci not to stack ghci
10:25:42 <cocreature> --ghci-options=-v3
10:25:47 <Shockk> ah right thanks
10:25:49 <Phyx-> yeah, dunno how to do that
10:25:50 <Phyx-> ah :)
10:26:48 <cocreature> Phyx-: you got me interested, got a link to the issue you fixed?
10:28:47 <Eduard_Munteanu> andromeda-galaxy, in what context / for what purpose?
10:29:01 <Shockk> Phyx-: here https://gist.github.com/shockkolate/3aa9edad3fb43b4e8c48ea59ef10d68a
10:29:27 <Shockk> hardest part of that was getting the log out of vim
10:29:41 <Shockk> could just have opened it in notepad now that I think about it
10:30:33 <andromeda-galaxy> Eduard_Munteanu: actually, after another moment's thinking I'm quite sure it's not possible (b/c open-world). The context here is that I would like to basically have some class ReadT (s :: Symbol) (t :: Type) where every instance is a way of converting some explicit string s into a value of type t, and then use that to make a read instance for type t, that just tries each of those strings
10:31:08 <Phyx-> cocreature: I think he's hitting a variant of one of these three https://ghc.haskell.org/trac/ghc/ticket/13093 or https://ghc.haskell.org/trac/ghc/ticket/13113 or https://ghc.haskell.org/trac/ghc/ticket/12498 but need to see the full trace to know what it's loading
10:31:54 <cocreature> thanks!
10:38:09 <Phyx-> Shockk: unfortunately, you're hitting a compiler bug, the only workaround is to use a dynamically linked llvm
10:38:32 <Phyx-> but I'm not sure mssy2 provides one, so you'll have to compile from source using the msys2 environment
10:38:34 <Shockk> ahh right
10:39:26 <cocreature> a dynamically linked LLVM is nice anyway because the link times are significantly better than using the static libs
10:39:32 <edwardk> andromeda-galaxy: you can use template haskell to rummage through instances iirc
10:39:44 <Phyx-> it should be fairly straight forward too
10:40:02 <edwardk> andromeda-galaxy: if you're willing to put a splice where you write that function. of course it'll only have the instances in scope at the splice point
10:40:14 <Shockk> that's true, just means I can't distribute a static build of my executable, which is okay though while waiting for the bug to be fixed
10:40:51 <andromeda-galaxy> edwardk: of course, that would work. But this is going in a "library" (using it in my local XMonad) where other modules will be defining the instances of the class
10:40:52 <Eduard_Munteanu> There should be a better way of distributing self-contained executables than static builds.
10:40:54 <Phyx-> you can, the bug is only if you want to use the repl
10:41:00 <Phyx-> if you just compile it should work fine
10:41:06 <Shockk> Phyx-: oh of course
10:41:13 <Phyx-> unless you have TH code that's using the LLVM stuff
10:41:28 <Shockk> I'd prefer to stay clear of th so that's not a problem
10:41:33 <edwardk> andromeda-galaxy: then as you guessed, you're stuck. you could supply the user the template haskell splicing function though
10:41:35 <cocreature> llvm-hs contains a shitload of TH
10:41:38 <andromeda-galaxy> edwardk: I know it's probably not possible, I just wanted to check back in in case recent develpoments had changed anything
10:41:50 <andromeda-galaxy> yeah, I may have to just do that...
10:41:56 <hashpuppy> i'm learning haskell and reading about monoids and how instances should follow laws.  are these enforced anywhere?  or is it not possible to do that?  
10:41:57 <Shockk> cocreature: oh right
10:42:02 <edwardk> no recent developments have not included total abandonment of the open world principle ;)
10:42:07 <Eduard_Munteanu> hashpuppy, no
10:42:11 <Phyx-> Shockk: you can have both a static and dynamic version installed at the same time, using the repl ghci will then prefer the dynamic one and it'll work
10:42:12 <andromeda-galaxy> (the idea here was to define a class of functions + string tags that could be showed/read. Showing them is easy, reading them, not so much)
10:42:14 <edwardk> at least that anybody will admit to me
10:42:28 <Phyx-> Shockk: and at compile time we prefer the static one by default, so you'll get the behaviour you want
10:42:31 <hashpuppy> would dependent types allow you to enforce that?  (i know nothing about dependent types)
10:42:50 <Eduard_Munteanu> hashpuppy, yes. You can do it in e.g. Agda.
10:42:53 <edwardk> hashpuppy: dependent types would
10:43:02 <hashpuppy> neat.  thanks
10:43:04 <andromeda-galaxy> edwardk: ah well, was expecting that
10:43:06 <Shockk> Phyx-: oh right, that would be good; I mean, llvm-hs is set to link with static or shared llvm via a flag, do you know how I would specify a different value of this flag, for ghci?
10:43:18 <cocreature> Phyx-: I’m not so sure about that. the dynamic and static libraries can have different names (not only different endings) and which name is chosen depends on a cabal flag in llvm-hs
10:43:32 <edwardk> hashpuppy: agda/coq/idris/etc tend to enforce those laws. it can get a little bit messy as you sometimes have to decide what notion of 'equality' you mean for them
10:43:32 <Eduard_Munteanu> hashpuppy, you'd have to write a proof, though
10:43:57 <Phyx-> cocreature: the dynamic ones should expose an import library with the same name as the static versions
10:43:58 <edwardk> hashpuppy: as once you move to dependent types there are a lot of competing notions of equality worth using in different circumstances.
10:44:07 <Phyx-> cocreature: e.g. libfoo.a and libfoo.dll.a
10:44:22 <Phyx-> the name of the dll can differ, but that's what the import library is for
10:44:38 <cocreature> Phyx-: the dynamic name is always one big library while the static libraries are split up into multiple libs
10:45:03 <Phyx-> cocreature: oh you mean, llvm-config gives different values?
10:45:35 <cocreature> Phyx-: yep
10:45:58 <Phyx-> ah, hmm, no way to control which it shows?
10:46:09 <Phyx-> but yeah, then it won't be as simple
10:46:34 <cocreature> --link-shared gives me -lLLVM4.0 and --link-static gives me "-lLLVMLTO -LLLVMPasses …"
10:46:59 <cocreature> and depending on a cabal flag we switch between passing --link-shared and --link-static
10:47:12 <Phyx-> hmm fair enough, but then he can just use the flag for the repl
10:47:22 <Phyx-> and another for compile no?
10:47:38 <cocreature> sure
10:47:46 <Phyx-> Shockk: you can also try with 8.2 RC2, not sure what's fixed there already
10:47:49 <Shockk> how should I do that though?
10:48:03 <Shockk> @ the flag for the repl
10:48:30 <cocreature> Shockk: just always enable shared-llvm and when you want to build binaries that you distribute, disable the flag in your stack.yaml and enable it afterwards
10:48:40 <cocreature> you don’t want static linking during development builds either
10:48:40 <Shockk> oh okay
10:48:52 <cocreature> at least on linux, I’m not sure if the performance difference on windows is similar
10:49:05 <Shockk> I guess that's true
10:49:08 <Shockk> okay
10:49:21 <Shockk> time to build llvm for the 513th time
10:49:33 <cocreature> who doesn’t love building llvm
10:50:13 <Shockk> the best part is I build llvm basically every day at work, and it's so much slower on my home pc :/ so I'm stuck waiting for longer than my patience allows
10:50:33 <cocreature> oh what kind of work do you do?
10:50:47 <Shockk> compilery runtimey work
10:52:07 <cocreature> heh
10:52:15 <Shockk> I realize how vague that is :D
10:52:44 <Shockk> basically stuff like with llvm and opencl and stuff
10:53:01 <cocreature> sounds interesting
10:53:20 <Shockk> it's pretty fun
10:53:32 <Phyx-> the performance differnce on Windows would be even bigger
10:53:58 <Phyx-> for static libraries we have to index all the archive entries, and do so more aggressively than what the system linker would do
10:54:03 <Phyx-> due to the semantics of GHCi
10:54:20 <Phyx-> but on Linux, we cheat my making a dynamic library using the system linker, and load that
10:54:35 <Phyx-> so ld links faster, and we load a dynamic lib
10:54:49 <Phyx-> vs, loading, relocating, etc everything ourselves
10:55:04 <Shockk> interesting
10:55:30 <muzzle> If I SPECIALIZE a function in a module, will that specialized version be used in other modules?
10:57:44 <Shockk> damn, msys doesn't have ninja buld
10:57:46 <Shockk> build*
10:59:16 <sproingie> so install it
10:59:21 <sproingie> er, build it
10:59:30 <Shockk> cocreature: Phyx-: will I need the llvm dylib as well as the shader libs?
11:00:04 <Shockk> it's the cmake flag that enables linking the tools with the libLLVM shared library
11:00:36 <Shockk> s/shader/shared
11:01:09 <Phyx-> I don't follow, shared should be dynlib
11:01:10 <cocreature> Shockk: I built using "cmake .. -GNinja -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLLVM_ENABLE_ASSERTIONS=ON -DCMAKE_INSTALL_PREFIX=/home/moritz/code/llvm-4.0.0 -DLLVM_PARALLEL_LINK_JOBS=1 -DLLVM_BUILD_LLVM_DYLIB=ON -DLLVM_LINK_LLVM_DYLIB=ON -DLLVM_TARGETS_TO_BUILD=X86"
11:01:22 <Shockk> cocreature: ah right thanks
11:01:28 <Phyx-> or that :)
11:01:41 <Shockk> hmm how come BUILD_SHARED_LIBS isn't set to ON there?
11:01:42 <Phyx-> X86?
11:01:45 <Phyx-> not X86_64?
11:01:56 <cocreature> Phyx-: afaik those are the same target
11:02:08 <Shockk> Phyx-: 64-bit will be a subtarget probably
11:02:32 <geekosaur> muzzle, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#specialize-for-imported-functions
11:28:19 <SunKing2> Hi, I'm new.  Is it ok if I ask for help, after I did $cabal install hlint in Ubuntu, it says "The program 'hlint' is currently not installed"
11:28:52 <geekosaur> programs are installed to ~/.cabal/bin, you need to prepend that to $PATH
11:29:06 <SunKing2> thanks!  i'll do that :)  you are awesome :)
11:32:37 <paolino> has "fmap snd . mapAccumL (\s x -> (f s x, (f s x, x)))" a name ?
11:34:37 <cocreature> :t \f -> fmap snd . mapAccumL (\s x -> (f s x, (f s x, x)))
11:34:38 <lambdabot> Traversable t => (a -> t1 -> a) -> a -> t t1 -> t (a, t1)
11:35:21 <paolino> it happens I always use mapAccumL like that, and it dosn't make a scanl
11:37:11 <cocreature> I don’t know of a name for that but I’ve also never used it :)
11:37:49 <paolino> that's bad for my reputation :-) , how do you use mapAccumL ?
11:38:17 <cocreature> mostly I don’t :)
11:38:28 <cocreature> I just don’t seem to have a lot of things that fit the pattern
11:38:33 <cocreature> or I fail to see that they match
11:39:40 <paolino> how do you tag elements of list with an accumulated value
11:41:18 <cocreature> :t \f i xs -> zip (scanl f i xs) xs
11:41:20 <lambdabot> (a -> b -> a) -> a -> [b] -> [(a, b)]
11:41:28 <cocreature> that’s the non mapAccumL version of your code
11:41:33 <cocreature> which tbf I find significantly easier to read
11:41:58 <cocreature> but to answer your question: I just don’t find myself tagging elements of a list with an accumulated value very often
11:42:50 <cocreature> and when I do want something like that I tend to just use zip
11:43:00 <nshepperd_> I think normally i would use traverse with State. Although i have used zip/scanl like that before
11:44:01 <paolino> nshepperd_, can you share the traverse + state code ?
11:45:41 <paolino> cocreature, I will start using zip + scanl :-)
11:46:18 <cocreature> paolino: don’t let me stop you from using mapAccumL. just because I don’t use it doesn’t mean it’s bad and it might even be slightly faster :)
11:46:44 <paolino> :t \f i -> zip <*> scanl f i
11:46:45 <lambdabot> (b -> a -> b) -> b -> [a] -> [(a, b)]
11:47:48 <nshepperd_> Uh, traverse (\x -> do a <- get; put (f a x); return (a, x)) xs
11:48:07 <nshepperd_> Something like that
11:48:54 <paolino> :t traverse
11:48:56 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:49:41 <nshepperd_> More useful to do that with StateT if you're already in a monad i guess
11:52:03 <paolino> :t \f i -> traverse $ modify . f
11:52:05 <lambdabot> (MonadState s f, Traversable t) => (a -> s -> s) -> t1 -> t a -> f (t ())
11:52:52 <paolino> :t \f i -> execState . traverse $ modify . f
11:52:54 <lambdabot> error:
11:52:54 <lambdabot>     • Couldn't match type ‘[a] -> f0 [()]’ with ‘StateT s Identity a0’
11:52:54 <lambdabot>       Expected type: (a -> f0 ()) -> State s a0
11:53:11 <paolino> :t \f i -> flip execState i . traverse $ modify . f
11:53:12 <lambdabot> error:
11:53:12 <lambdabot>     • Couldn't match type ‘[a] -> f0 [()]’ with ‘StateT c Identity a0’
11:53:13 <lambdabot>       Expected type: (a -> f0 ()) -> State c a0
11:53:21 <paolino> ok I stop that
11:53:54 <paolino> thanks for the hints
12:00:09 <Soullesswaffle> Hello! I'm working on decoding a binary file format using Data.Binary.Get, and so far so good. Does anyone know of a way to repeat a function of type `Get a` n times?
12:00:24 <Soullesswaffle> repeatedly call it, I mean
12:01:15 <paolino> cocreature it's equivalent to \f i -> zip <*> tail . scanl f i
12:02:45 <lyxia> Soullesswaffle: replicateM
12:05:03 <f-a> I have installed a package (pandoc-citeproc) with cabal new-build. Had to modify the .cabal a bit (adding a custom-setup stanza). now cabal new-build hakyll chokes on pandoc-citeproc. I thought the installed version was cached?
12:07:50 <Soullesswaffle> lyxia: thanks! That's exactly it! :D
12:10:18 <nshepperd> :t fmap runState . traverse . fmap state . curry . liftA2 (,) id . uncurry
12:10:19 <lambdabot> Traversable t => (a -> s -> s) -> t a -> s -> (t (a, s), s)
12:10:25 * nshepperd will stop golfing now
12:10:43 <nshepperd> pointless golfing
12:12:05 <Shockk> cocreature: you would not believe how long I just spent trying to get llvm to actually finish the cmake configuration part
12:13:44 <Shockk> turns out I have to actually use the "MSYS Makefiles" cmake generator, and I also can't enable LLVM_LINK_LLVM_DYLIB or it causes some weird interaction with the libnames in one of the cmake files
12:14:13 <tabemann> I have a bit of a design question for making a VM that supports tail calls in haskell
12:15:04 <tabemann> the problem I have is I want the execution of each VM instruction to return both the return value of that instruction, and the number of instructions executed since the beginning of the cycle
12:15:11 <tabemann> so I can implement a watchdog
12:16:37 <tabemann> but the problem is that seems like it will interfere with implementing tail calls, because I will have to form a tuple with the return value and the watchdog timer count *after* the next instruction is executed
12:18:07 <geekosaur> sounds like StateT to me. or, given it's a VM, create an "internal" VM register to hold the count?
12:20:00 <tabemann> I think I've figured out a solution
12:20:52 <tabemann> by threading the instruction count into the code depth-wise, and having the deepest instruction return the depth value
12:36:26 <darkr0ck3t> >
13:02:26 <pikajude> so, i've written an irc bot kinda
13:02:52 <pikajude> and the way i've implemented the read -> respond loop is to just use ByteString's hGetContents on the socket
13:02:57 <pikajude> or rather, lazy ByteString
13:03:11 <mnoonan_> Are there other mainstream FP languages that can do the rank-2-types trick used by ST?
13:03:18 <pikajude> does anyone happen to know if hGetContents will throw an exception if the socket is closed
13:03:24 <pikajude> or how the program will be notified if the connection is lost
13:03:38 <tabemann> pikajude: I'd just avoid lazy IO myself
13:03:44 <geekosaur> ^
13:03:53 <geekosaur> but it should be indicated as end of string
13:03:56 <pikajude> yeah, I suspected that may be the Right Answer
13:04:02 <pikajude> it just seemed so convenient to use
13:04:13 <pikajude> should probably use io-streams or something
13:06:33 <geekosaur> pipes/conduit likely the right answer here
13:06:51 <pikajude> :o
13:07:47 <tabemann> that's probably the right answer, but I personally would end up coding an IRC bot in Haskell in the world's-greatest-imperative-language fashion myself
13:08:29 <pikajude> I used pipes but it only really seemed helpful for writing one half of the bot
13:08:33 <pikajude> the read half
13:08:43 <pikajude> the sending messages part never seemed very straightforward
13:09:50 * tabemann is finding it nice that he has been able to keep the core of his VM purely functional
13:10:14 <tabemann> (even though it itself has exceptional conditions, like when the watchdog timer for a robot times out)
13:10:31 <Welkin> tabemann: nixos?
13:10:49 <tabemann> Welkin: I'm writing a VM for genetically programmed robots which fight each other
13:12:04 <tabemann> and the robots run a very simple functional language
13:14:16 <pikajude> putting the fun back in functional!
13:14:21 <lordcirth> tabemann, that's neat!
13:14:47 <pikajude> geekosaur could you make a recommendation as to one of conduit or pipes specifically
13:15:08 <geekosaur> not really, no
13:15:14 <tabemann> it's a project I've done before, but my past implementation was non-ideal in some fashions, was in OCaml, and the robots themselves weren't purely functional
13:15:27 <cocreature> pikajude: tbh both will do the job just fine
13:15:31 <cocreature> it’s mostly a matter of taste
13:15:53 <pikajude> why are there two of them
13:16:04 <cocreature> because different people have different tastes :)
13:16:46 <pikajude> citation needed
13:17:44 <cocreature> the API provided by pipes is more restricted than the API provided by conduit which imho makes it a bit easier to understand but if you need one of the more complex features you need to use pipes-group and pipes-parse which are at least on par with conduit if not slightly more complex
13:17:55 <cocreature> personally I prefer pipes
13:22:42 <kuribas> I am looking at the swift language, but while it's a step in the right direction it's kind of meh...  I understand that lazyness and purity are still not obvious, but what's the problem with doing full type inference?
13:25:54 <kuribas> Do the people who design these languages actually know haskell and modern PL theory?
13:27:21 <Athas> kuribas: yes, but usually they have other priorities too.
13:27:33 <Athas> Such as familiarity and other ergonomic properties.
13:27:36 <pikajude> i never understood how to express a bi-directional flow with pipes
13:27:55 <pikajude> it seems really great for like, writing a compression codec or decoding a giant file or something
13:28:02 <pikajude> not as much for a bot
13:28:03 <Athas> Also, type inference is hard in the presence of subtyping.  I hear that Swift still has a few pathological cases where its (limited) type inference becomes exponential.
13:28:10 <cocreature> pikajude: bidirectional in what sense?
13:28:11 <sproingie> full inference results in nastier errors when hints aren't use
13:28:16 <sproingie> d
13:28:24 <pikajude> cocreature: well i need a stream of server messages coming from the server
13:28:28 <sproingie> swift does at least have return type polymorphism
13:28:29 <pikajude> and i also need to send a stream of client messages going the other way
13:29:01 <cocreature> pikajude: so you just have a Producer that gives you the messages from the server, a Consumer that sends your messages to the client and a Pipe over whatever monad you want that transforms those
13:29:13 <pikajude> yep
13:29:14 <cocreature> pikajude: you might be interested in the "mvc" package which wraps this pattern in a nice api
13:29:17 <pikajude> so that's one direction
13:29:21 <pikajude> what about the other direction
13:29:37 <cocreature> how is that only one direction? it covers receiving and sending messages
13:29:42 <cocreature> what is the other direction?
13:29:48 <pikajude> wait, what
13:29:51 <pikajude> what client are you talking about
13:30:08 <cocreature> Messages from Client -> Transform -> Messages to Client
13:30:09 <sproingie> swift also has a priority of gluing seamlessly with objC code, so there's some limits to obey
13:30:22 <cocreature> Producer -> Pipe -> Consumer
13:30:35 <pikajude> ok, let's back up
13:30:40 <kuribas> sproingie: so that's the reason for the strange function naming syntax?
13:30:42 <pikajude> messages from client -> transform -> messages to client
13:30:51 <pikajude> a bot wouldn't ever be sending messages to itself
13:30:53 <pikajude> that doesn't make sense
13:31:02 <cocreature> oh I thought you were implementing a server
13:31:12 <cocreature> in that case messages from server -> transform -> messages to server
13:31:16 <sproingie> kuribas: yes, though they've undone that a little bit
13:31:18 <pikajude> okay
13:31:21 <pikajude> yeah
13:31:23 <pikajude> so the "transform" part
13:31:29 <sproingie> stepped back from some of the sillier naming conventions objc imposed
13:31:42 <cocreature> the transform part is probably some kind of state machine
13:31:43 <pikajude> and if it's not a 1 to 1 mapping of server message -> client response
13:31:47 <pikajude> then it falls apart
13:31:54 <pikajude> which it won't be, because i want to implement timers for example
13:31:59 <sproingie> swift 2.0 turned all the fooWithBar: stuff into foo:bar: for starters
13:32:03 <pikajude> and send messages to the server at arbitrary times
13:32:34 <cocreature> pikajude: alright in that case you do "input events -> transform -> messages to server" and using pipes-concurrency you merge the messages from the server and your timer events
13:32:40 <pikajude> pipes-concurrency
13:32:42 <pikajude> ok
13:32:50 <pikajude> that sounds like it makes more sense
13:32:53 <cocreature> or "mvc" which wraps this exact pattern
13:33:13 <pikajude> interesting
13:33:15 <cocreature> and would allow you to combine the events using a monoid instance
13:33:25 <pikajude> neat
13:33:29 <pikajude> i want to try that then
13:33:32 <Shockk> if I'm reading stdin lazily as a ByteString, and passing this to attoparsec through something like `parseOnly (many astParser)`, how do I get this to stop on EOF?
13:33:38 <cocreature> pikajude: https://hackage.haskell.org/package/mvc-1.1.4/docs/MVC.html
13:33:43 <pikajude> thanks cocreature 
13:33:46 <pikajude> finally i understand
13:33:55 <cocreature> pikajude: the example at the top actually combines time events and messages from stdin
13:34:01 <cocreature> so it’s pretty similar to what you are describing
13:34:01 <Shockk> for example, in programs like `cat`, if I press ctrl-d, it sends EOF and cat stops reading from stdin
13:34:02 <pikajude> yeah i'm looknig at it
13:34:04 <pikajude> looking*
13:34:19 <masaeedu[m]> Sorry for just jumping in like this, but does anyone know if it's possible to "associate" value constructors from two independent types?
13:34:37 <monochrom> Shockk: "many" already does.
13:34:45 <cocreature> and if you’re not happy with mvc it’s not particularly hard to roll your own versions of this
13:34:48 <Shockk> hm, weird
13:35:39 <monochrom> In more detail, lazy Bytestring already represents "eof" as the bytestring having finite length, and "many" already considers the end of the bytestring as "eof".
13:35:53 <Shockk> monochrom: what if I'm using char8 bytestring?
13:36:01 <monochrom> Same.
13:36:04 <cocreature> it might be helpful to point out that there is no "eof" byte or char
13:36:09 <geekosaur> masaeedu[m], do you mean making a new type consisting of data constructors from other types? then no
13:36:10 <cocreature> it’s just the end of the bytestring
13:36:14 <Shockk> hmm
13:36:30 <monochrom> Yeah you probably have a lot of misconception about "eof".
13:36:34 <geekosaur> Shockk, control-D causes a zero-length read, which is how EOF from a file is indicated
13:37:00 <sproingie> ctrl-d signals the tty to close stdin
13:37:07 <geekosaur> note that of you type it in the middle of a line, you need to do so twice: the first sends the incomplete line without a final newline, the second causes an empty read
13:37:22 <masaeedu[m]> geekosaur: Like I have a `data Command = Foo String | Bar Int` etc. type, and I want to define a total function on it that returns corresponding values from `data Result = FooResult Int | BarResult` etc.
13:37:39 <monochrom> The thing you need to know is that hGetContents already does the right thing. The bytestring it returns ends. And "many" will take it from there.
13:37:42 <geekosaur> this does not actually "close" the terminal, although some C stdio libraries will pretend it does to support certain use modes
13:37:48 <monochrom> In other words your problem is elsewhere.
13:38:15 <Shockk> hmm, I'm confused though, so, my code is as follows:   print . parseOnly (many astParser) =<< hGetContents stdin
13:38:29 <Shockk> where hGetContents is from Data.ByteString.Char8 
13:38:35 <monochrom> should work
13:38:50 <Shockk> it's not :(
13:38:52 <geekosaur> aside from being strict
13:38:56 <masaeedu[m]> I've tried playing around with `DataKinds`, because it seemed like my problem was malformed, and I was mixing up the universes of types and values
13:39:14 <monochrom> The problem is elswhere. Your astParser is wrong or something.
13:39:42 <monochrom> You're using ghci which adds a complication or something. Do not trust ghci.
13:40:16 <monochrom> (To be fair, this is a complication any REPL can't avoid.)
13:40:34 <Shockk> I'm not though, I'm using stack exec 
13:40:44 <Shockk> (on my executable)
13:40:45 <geekosaur> um
13:40:46 <monochrom> (Logical conclusion: Do not trust a REPL if you're testing stdin.)
13:41:38 <geekosaur> now I am wondering if this is the hSetBuffering issue
13:41:56 <geekosaur> which is actually ghc's runtime being too clever for its own good
13:42:05 <monochrom> Ah. Then hit <return> before you hit <ctrl-d>.
13:43:22 <monochrom> Use file redirection, see what happens.
13:43:29 <Shockk> hmm okay let me see
13:45:12 <Shockk> echo asdf | etchy works, but running etchy and hitting return and ctrl-d doesn't 
13:45:28 <Shockk> typing asdf and ctrl-d or asdf + return + ctrl-d both don't work either
13:46:49 * geekosaur would switch to a different terminal, look up the controlling terminal of the program / stack, and stty -a < /dev/(whatever that terminal is)
13:46:55 <geekosaur> I bet clocal is turned off
13:47:06 <geekosaur> hm, does control-c work?
13:47:31 <geekosaur> never mind, that;s not clocal
13:48:01 <geekosaur> and clocal is the wrong flag anyway :/ sigh
13:48:13 <Shockk> I'm trying in stack exec -- sh (in msys2) and also in cygwin 
13:48:43 <Shockk> ctrl-c works in msys2, in cygwin terminating programs is horribly broken in general it seems
13:49:03 <Phyx-> technically it doesn't it just kills the process :P
13:49:27 <geekosaur> oh, windows? good luck
13:49:41 <Shockk> Phyx-: it kills it but I get the printed output from the attoparsec parser though
13:49:56 <monochrom> Windows is one more complication, and this time an unnecessary one :)
13:50:05 <geekosaur> and eight,if icanon is disabled then control-d is just another character, not EOF
13:50:14 <monochrom> But it may be ctrl-z rather than ctrl-d.
13:50:16 <geekosaur> and the stty won't work on windows
13:50:26 <Phyx-> Shockk: the console stuff on windows is using very old deprecated APIs
13:50:30 <Phyx-> so the baviour is weird
13:50:34 <geekosaur> in fact this whole thing may not work on windows, so.
13:50:35 <Shockk> ahh
13:50:42 <Shockk> also monochrom ctrl-d works in other stuff like cat
13:50:48 <Phyx-> Shockk: for 8.4 I would have rewritten the entire I/O manager
13:50:49 <monochrom> Ah OK.
13:50:54 <Phyx-> it should *just work* then
13:51:08 <Shockk> hmm okay
13:51:20 <Shockk> that sounds good
13:51:30 <Phyx-> this will fix other things like unicode output, etc
13:51:37 <monochrom> Neato.
13:51:59 <Shockk> is it a bad idea to ask "when is 8.4 coming?"?
13:52:17 <monochrom> This is so co-induction. Every time we have a problem, it is already being fixed in the version after the current release candidate. :)
13:52:19 <Phyx-> probably not for at least 6 months
13:52:57 <Shockk> monochrom: I mean, all the bugs I've hit today are already being fixed or fixed or going to be fixed
13:52:59 <Shockk> :D
13:53:08 <Shockk> it's like lazy evaluation of bug fixes
13:53:11 <Phyx-> well, I'm slowed down by the fact that I have a full time job and that getting people to review the Windows patches are hard
13:53:16 <Phyx-> :)
13:53:27 <monochrom> Need more bounty money.
13:54:11 <Phyx-> s/are hard/is hard
13:54:14 <sproingie> if you're using stack, stack breaks ctrl-d
13:54:25 <sproingie> use "stty sane" to set it back
13:55:34 <ondrejs> hello, anyone knows why Prelude does not use this general implementation of filter? https://wiki.haskell.org/Foldable_and_Traversable#Some_trickier_functions:_concatMap_and_filter
13:55:42 <Phyx-> Shockk: if you're curious, this is the code before I started merging it back into base https://github.com/Mistuke/ghc-win-io-system
13:56:00 <sproingie> :t filter
13:56:01 <lambdabot> (a -> Bool) -> [a] -> [a]
13:56:04 <Athas> ondrejs: it is slower.
13:57:10 <Athas> ondrejs: although a sufficiently smart compiler may be able to optimise it to the straightforward recursive form.
13:57:14 <sproingie> slower isn't it so much as changing the type could break existing stuff, and they didn't want to take it on for everything
13:57:19 <kuribas> Athas: unless its specialized
13:58:16 <ondrejs> Athas, sproingie: i see, thank you
13:58:17 <kuribas> Athas: it could even use a rewrite rule to provide an implementation for list.
13:58:17 <EvanR> sufficiently advanced features that resist any compiler however smart
13:59:19 <Athas> Isn't that generic solution O(n**2)?
13:59:40 <sproingie> doubt it
13:59:41 <Athas> It is if foldMap is a left-fold, I think.
13:59:48 <Athas> At least for lists.
14:01:48 <kuribas> you can do function overloading with rewrite rules, provided the types match.
14:02:29 <kuribas> the implementation should also be the same, but ghc doesn't check it.
14:04:45 <schaeferpp> hey guys, when trying to compile a hello world haskell with ghc on archlinux i get the followig linker errors: https://ghostbin.com/paste/xamk9 do you have any idea how to resolve that?
14:05:17 <geekosaur> ghc-static, or install a ghc not from arch community
14:05:25 <geekosaur> (they broke it)
14:06:03 <schaeferpp> thank you, i only tried ghc and ghc-mod so far
14:06:45 <schaeferpp> but I didn't find something in the web so far. Does a bug report exist?
14:07:44 <Shockk> out of interest, if I'm writing parsers for an AST, is it more conventional to:
14:08:13 <Shockk> 1. parse whitespace at each terminator, for example parse integer literals as skipSpace, integer, skipSpace
14:08:43 <Shockk> 2. parse whitespace around higher-level expressions, for example skipSpace, integerLiteralParser, skipSpace each time I want to parse an integer literal
14:08:51 <EvanR> too much skipSpace
14:09:06 <EvanR> skip space at the beginning of the text, then skip *after* each token
14:09:18 <monochrom> What's the difference between "integer" and "integerLiteralParser"?
14:09:21 <EvanR> then you always know youre starting some parsing context without space
14:09:32 <sproingie> bug for ghc in arch would be https://bugs.archlinux.org/?project=5&cat%5B%5D=33&string=ghc and there doesn't appear to be a bug
14:10:27 <Shockk> EvanR: hmm that makes sense; also monochrom, that first integer is just the integer parser, integerLiteralParser just puts the result of that into a value of type AST
14:11:18 <monochrom> I would do 1 plus what EvanR says.
14:11:37 <monochrom> See also my https://wiki.haskell.org/Parsing_expressions_and_statements
14:12:10 <monochrom> Oh actually it doesn't say it explicitly I guess.
14:12:46 <monochrom> You have "token level" parsers. At that level, make a habit of skipping post-spaces.
14:13:01 <Shockk> oh right
14:13:16 <monochrom> But don't worry about pre-spaces. At the outermost global level, do one "skip pre-space" at the very beginning. Then you're done.
14:13:23 <zomg> ocramius: o hai
14:13:41 <Shockk> that sounds like a good idea, thanks
14:15:15 <monochrom> The no-pre-spaces invariant ensures that whenever you need backtracking or lookahead, you are doing it on really important characters rather than silly spaces. :)
14:15:31 <ocramius> zomg: ello'
14:15:50 <EvanR> really important characters, you need those
14:16:27 <Shockk> monochrom: right, that makes sense
14:19:09 <Shockk> monochrom: so should I do the post space skipping, conceptually at the lexing stage? 
14:19:26 <monochrom> Yes.
14:19:32 <Shockk> okay, thanks very much
14:19:46 <EvanR> ive ended up doing space skipping sometimes at a high level
14:20:28 <monochrom> Here: http://lpaste.net/114582  shows what I do.
14:21:31 <EvanR> like the end of a function call might be a ')' so i skip space after that rather than have a separat parser for ')'
14:21:57 <Shockk> monochrom: huh I see
14:22:00 <Shockk> between looks very useful
14:22:43 <EvanR> in any case doing it before and after is going to be kind of useless if you think about it
14:27:08 <Phyx-> git reflog
14:27:22 <Shockk> Phyx-: at least it wasn't your passwd
14:27:54 <Phyx-> Shockk: hah, true :P
14:36:47 <tabemann> I have a very stupid question
14:37:04 <Taneb> tabemann, ask away, stupid questions are the most important kind
14:37:07 <tabemann> where do I find a simple xor for Bool types
14:37:27 <EvanR> :t xor
14:37:29 <lambdabot> Bits a => a -> a -> a
14:37:29 <Taneb> You can use (/=) (the not-equals operator)
14:37:40 <Taneb> > True /= False
14:37:43 <lambdabot>  True
14:37:48 <tabemann> I hadn't thought of using /=
14:37:54 <EvanR> > True `xor` False
14:37:56 <lambdabot>  True
14:38:01 <EvanR> nice
14:38:33 <EvanR> tabemann: xor works on Bits types, which Bool is
14:38:38 <Taneb> Oooh, I didn't realise Bool had a Bits instance
14:38:47 <Taneb> xor is in Data.Bits
14:38:47 <pavonia> > True `shiftR` 1
14:38:49 <lambdabot>  False
14:38:52 <EvanR> Bool is an instance of Bits
14:39:53 <EvanR> @index xor
14:39:53 <lambdabot> Data.Bits, Foreign, Foreign.Safe
15:25:33 <tabemann> question
15:25:43 <tabemann> how do you specifically refer to an infinite value
15:26:19 <tabemann> like GHCI will print -Infinity when I execute log 0.0... but how do I actually instantiate negative infinity in my code?
15:26:32 <EvanR> theres no constant for it predefined
15:26:38 <EvanR> you need to do this
15:26:48 <EvanR> inf = 1.0 / 0.0
15:27:37 <EvanR> > let inf = 1.0/0.0 in -inf
15:27:39 <lambdabot>  -Infinity
15:28:02 <EvanR> unless youre trying to test for infinity/
15:28:12 <tabemann> I'm making an intrinsic for log in my VM
15:28:37 <tabemann> and because it's rather, well, loosely typed and all, functions can take any number of parameters without necessarily failing
15:28:47 <EvanR> :t isInfinite
15:28:48 <tabemann> so I'm handling the case of when zero parameters are passed to log
15:28:49 <lambdabot> RealFloat a => a -> Bool
15:29:08 <tabemann> so I'm returning a placeholder value
15:29:21 <EvanR> -(1.0/0.0) would do it then
15:29:47 <EvanR> if you put that in a top level definition, it wont get recomputed each time
15:36:00 <joelburget> Anybody with experience with the indentation / indentation-trifecta packages? I'm trying to do something very simple but can't figure it out: https://github.com/joelburget/planetary/blob/tmp/src/Planetary/Support/Parser/Test.hs#L37-L53
15:36:51 <joelburget> Just using indentation levels to denote nested lists.
15:37:19 <joelburget> This is just as a test so I can use it for indentation-sensitive layout
15:38:28 <Gurkenglas> tabemann, you could return the function that takes another parameter before computing the log
15:47:25 <pikajude> is there a thing like pipes-network but which operates on Handles instead of Sockets
15:49:03 <pikajude> since connectTo returns a Handle
15:49:16 <pikajude> or should I just do what connectTo does with Network.Socket instead
15:52:08 <EvanR> normal pipes?
15:57:02 <pikajude> also
15:57:09 <pikajude> what's the difference between bytestring hGet and hGetSome
15:57:23 <pikajude> hGet doc says "up to n"
15:57:33 <pikajude> whereas hGetSome says "like hGet, but a shorter bytestring may be returned"
15:57:36 <pikajude> doesn't make sense
16:15:02 <dmwit> pikajude: I would guess hGet blocks until it gets the number of bytes you requested or EOF, while hGetSome doesn't block.
16:16:33 <Myrl-saki> I just had an idea. Given a zipper of T, create T' which is pretty much isomorphic to T, but the active element is marked.
16:17:03 <ReinH> What does it mean to mark the active element?
16:17:27 <dmwit> Perusing the source seems to confirm this, with the exception that hGetSome won't return an empty ByteString unless it's sure that's true (because it's reached EOF).
16:17:27 <Myrl-saki> ReinH: (Bool, X)
16:17:41 <ReinH> Why?
16:17:53 <Myrl-saki> ReinH: Because it's useful for rendering.
16:18:14 <Myrl-saki> ReinH: For example, which chararcter to render the cursor on.
16:18:27 <ReinH> That sounds terrible for rendering.
16:18:37 <Myrl-saki> ReinH: Why?
16:18:39 <ReinH> Why would I want to perform that check repeatedly?
16:18:51 <Myrl-saki> ReinH: WHat do you suggest then?
16:19:04 <ReinH> ... not doing that?
16:19:11 <Myrl-saki> ReinH: What. Alternative.
16:19:25 <Myrl-saki> ReinH: I'm open to other ideas.
16:21:10 <ReinH> For rendering a cursor?
16:21:19 <ReinH> Store the cursor's position?
16:21:44 <ReinH> I would prefer to use a zipper that's a vect on the left and a list on the right, which gives me the cursor position for free.
16:21:58 <ReinH> Haskell makes that annoying, though.
16:22:23 <Myrl-saki> ReinH: C&J zippers?
16:23:02 <ReinH> The usual list zippers, yes.
16:23:20 <ReinH> But with a vector on the left.
16:23:31 <ReinH> (the length-indexed list vector, not Data.Vector)
16:23:45 <ReinH> then the cursor position is always statically known
16:24:12 <Myrl-saki> ReinH: Anways, I want this to be generalizable.
16:24:32 <Myrl-saki> ReinH: I don't know what zipper type I'll be working with, but I guess I have a few ideas now.
16:24:53 <Myrl-saki> Recursive render, but use a special function for the focus.
16:27:27 <ReinH> In Idris, I use this
16:27:32 <ReinH> data Cursor : (n : Nat) -> (a : Type) -> Type
16:27:32 <ReinH>    where Curse : Bwd left a -> List a -> Cursor left a
16:27:41 <ReinH> where Bwd is a snoc vect
16:28:37 <ReinH> There's a whole family of zippers made from combinations of lists, vects, and streams. It's annoying to write them all out though and I haven't figured out how to use Idris's template-haskell equivalent to do it for me.
16:38:21 <testing3> @pl (\f x y -> fmap f x <*> y)
16:38:21 <lambdabot> ((<*>) .) . fmap
16:57:05 <ReinH> :t \f x y -> fmap f x <*> y
16:57:06 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
16:57:08 <ReinH> :t liftA2
16:57:10 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:57:41 <ReinH> That's just liftA2
17:07:05 <Fylwind-> so it seems that Arch has changed their ghc package so that only dynamic libs are included
17:07:20 <Fylwind-> this means a simple 'ghc helloworld.hs' fails with linking errors, unless '-dynamic' is explicitly given
17:07:28 <Fylwind-> is there a way to force ghc to be '-dynamic' by default?
17:10:56 <eliaslfox> This may be a newbie question
17:11:23 <eliaslfox> but is there an easy way to add an executable built by stack to your path?
17:27:55 <yushyin> Fylwind-: don't know for the -dynamic switch as the default but there is also a ghc-static package
17:30:51 <isd> Does anyone know what the computational complexity of the vector package's grow functions are? Is it basically just a realloc()? or does it do something like doubling the backing store to amortize expansions...?
17:35:16 <davr0s> I've seen the videos on the haskell 'holes' thing.. does that just work on types, 
17:35:58 <davr0s> or can sometihng similar be used to find symbols , e.g. 'write a placeholder symbol in an expression, and the compiler will list the most specific known symbols that fit that signature..'
17:37:54 <davr0s> kind of like OOP 'dot-autocomplete', but only during compile : 'dot-autocomplete' would be like saying 'object._' and it tells you all the possible symbols that can fit there ; i'm imagining the same thing using full type inference, e.g.   x = _ y z    ....   the compiler tells you valid functions that would produce the right output given those inputs
17:45:24 <Axman6> isd: Assuming you're not talking about mutable vectors, a realloc isn't safe with an immutable vector because two functions might reallow the same vector, and clobber each other (how you even write to that vector I'm not sure). Basically you must do a full copy, though I think there are optimisations to minimise the number of copies necessary (mostly through stream fusion)
17:45:51 <Axman6> if you are talking about mutable vectores, then it hsould hopefully be as simple as a realloc
17:58:33 <isd> Axman6: was thinking in terms of mutable vectors. But the amortization question was really what I was interested in, and in the worst case realloc does a full copy anyway. Basically, is grow v 1 O(length v) or amortized O(1)?
17:58:49 <isd> I'm getting the sense that it's the former.
17:59:17 <Axman6> isd: I would guess the former, if you want toaht behaviour you need to do it explicitly
17:59:27 <isd> Ok. thanks.
18:33:39 <lmapper> hi guys, I'm stuck somewhere in my understanding of how to deal with groups of functions with different numbers of parameters
18:34:29 <lmapper> I'm planning to parse a file whose contents determine which "Operation" (predefined processing function) will be called on the provided data
18:35:04 <lmapper> but these "operations" will have different numbers of parameters
18:35:32 <EvanR> theres the dynamic / untyped way, and many ways involving a type system
18:35:46 <lmapper> I've looked into GADTs, Data.Dynamic, as well as different GHC extensions like polykinds
18:36:32 <lmapper> I almost had a workable solution with Data.Dynamic, but it was a struggle to cast it back into the correct type
18:36:38 <Axman6> can you share some code?
18:36:48 <Axman6> even if it's just an idea of what you want to write?
18:37:07 <EvanR> if you want to do a dynamic, runtime-checked thing, then im not sure Dynamic is even a good way
18:37:21 <lmapper> yeah, I'll post something on lpaste
18:37:25 <pacak> Instead of thinking "How am I going to represent this shit" try to think "How am I going to consume this shit".
18:39:29 <EvanR> what is the type of a hypothetical interpreter that will apply the specified operations
18:39:49 <lmapper> http://lpaste.net/452204359132905472
18:40:13 <lmapper> the functions don't have to be represented this way, I was just trying to work out the concept
18:40:22 <EvanR> so thats not really using GADTs proper
18:40:26 <EvanR> just GADT syntax
18:40:32 <lmapper> yeah, in this case
18:40:53 <lmapper> I have a few other examples where I was attempting with actual GADTs
18:41:45 <EvanR> your genericTest there skips figuring out the type by just crashing, kind of obscuring the question
18:41:52 <Axman6> this looks far more comvoluted than it needs to be
18:42:19 <lmapper> yeah, I really want to step back and research another direction
18:42:55 <Axman6> it feels like you're reinventing pattern matching
18:43:27 <EvanR> what does each operation return?
18:44:24 <Axman6> just have a map of Operation, and pattern match on the string and then do a lookup in the map which contains Operations 
18:44:25 <lmapper> EvanR: eventually I"ll just be returning simple data types, or IO actions
18:44:30 <lmapper> http://lpaste.net/1472252615122223104
18:44:35 <lmapper> this was another test
18:44:45 <EvanR> Either SimpleDataType (IO ()) ?
18:45:12 <EvanR> "anything" is probably wrong
18:45:15 <lmapper> Axman6: yeah, I was really hoping to do that, but I'll have some Operations with different numbers of function parameters
18:45:54 <Axman6> I don't see how that's a problem, just pattern match on the operations
18:46:06 <Axman6> I'm really confused what you're trying to do and what's making it difficult
18:46:42 <lmapper> I will try to make a clearer example sometime soon
18:46:46 <EvanR> example of "operations" which have different number of parameters, data Op = Plus Int Int | Mul Int Int | Neg Int
18:47:01 <EvanR> the interpreter for this to do the operations is just a function with 3 cases
18:47:10 <Axman6> yeah
18:47:42 <pacak> Yea, just make a clever show instance for Op and pipe it into nodejs. nodejs is webscale, you can't go wrong with webscale things...
18:48:23 * Axman6 takes the whisky bottle from pacak's hand slowly
18:48:34 <EvanR> lol
18:48:56 <lmapper> speaking of the..
18:49:11 <Axman6> oh man, WhiskyRyan's timing is impeccable
18:50:29 <WhiskyRyan> ?
18:50:48 <lmapper> |it's a long story, you'd have to have been there
18:51:21 <WhiskyRyan> Oh well. 
18:51:51 <EvanR> a data structure is basically a micro programming language
18:52:37 <EvanR> a data structure with sophisticated typing rules is a micro programming language with sophisticated typing rules :)
18:53:02 <Axman6> I"m confused why there are so many strings here too
18:53:47 <EvanR> String is the programming language TCL
18:56:12 <lmapper> Here's an earlier attempt of the actual code I was working on, this is all working but I feel it's unwieldy to continue
18:56:16 <lmapper> http://lpaste.net/2202367381513175040
18:56:54 <lmapper> it's a backend for a front end which I've already written, where the nodes can be connected to each other in a gui
18:57:01 <EvanR> VectorFloat and VectorValue are interesting
18:57:37 <lmapper> I want to loop through the ports that are connected to nodes, to ports, etc, and process the "Operation" that each node defines
18:57:47 <pacak> It got node written all over the place. Must be a webscale thing.
18:58:38 <zomg> Heh, been a while since I heard of TCL... I wonder if that's still being actively used for something else than Eggdrop plugins :P
18:58:59 <pacak> VectorIntValue / VectorFloatValue are redundant since you have VectorValue
18:59:50 <pacak> zomg: expect also uses tcl
19:01:14 <EvanR> i guess bash is a more relevant example
19:02:06 <EvanR> lmapper: maybe you want to check out free monads or a variant that lets you serialize the programs
19:02:16 <lmapper> I'm hoping there's some better way to deal with Operations, right now I'm just putting all parameters in a [Value], it would be nice to be able to write them as actual haskell functions , addOp :: a -> a -> a etc...
19:03:06 <EvanR> if you want to write operations as haskell code thats another story, you might want plugins
19:03:33 <EvanR> figure out what language you want, might be haskell, might be a more targeted DSL
19:03:40 <pacak> lmapper: Can you explain your original problem?
19:04:12 <lmapper> the original problem I asked today, or the purpose of the entire system?
19:04:40 <pacak> the purpose
19:09:12 <lmapper> JSON (lists of nodes connected to ports of other nodes) -> haskell (read the "operation" label of each node recursively, evaluating each node's port inputs, and applying the haskell function that matches that string) -> something happens, or values have been calculated, etc, whatever the root node ended up with
19:09:46 <lmapper> "that string"  I mean the "operation label"
19:10:06 <lmapper> currently only "add" "toFloat" etc
19:10:26 <lmapper> (but those are just temporary placeholder functions)
19:11:29 <pacak> ports?
19:11:35 <pacak> and nodes?
19:12:13 <davr0s> struct Foo; struct State; typedef Foo (*UpdateFunction)(State*);  struct Foo { UpdateFunction f; }; <<< how to do this in haskell,    type UpdateFunction= (State)->(State,UpdateFunction) // it doesn't like that
19:13:03 <davr0s> is here something liek forward declaration (like being able to forward declare that 'Foo' is s struct here)
19:13:40 <lmapper> it's something similar to this, but for a different purpose
19:13:42 <lmapper> http://fabricengine.com/overview/easy-to-use/
19:13:47 <davr0s> i can avoid needing this of course
19:14:07 <Fylwind> davr0s: a "type" is not a fresh data type; it's just an alias ("typedef")
19:14:07 <pacak> davr0s: O_o. You don't need to declare stuff in advance in haskell unless theres's TH involved.
19:14:13 <Fylwind> davr0s: you want to use "data" or "newtype"
19:14:37 <Fylwind> "type UpdateFunction= (State)->(State,UpdateFunction)" won't work because if you expand it you'
19:14:42 <Fylwind> you'll get infinite recursion
19:15:07 <Fylwind> try: newtype UpdateFunction = UpdateFunction (State -> (State, UpdateFunction))
19:15:31 <davr0s> ok i does work, thanks.
19:15:44 <davr0s> sure i should have realiseed...  i've seen data can be mutually recursive
19:16:11 <lmapper> EvanR, I'll look into free monads, thanks
19:25:05 <lmapper> I've been stuck for a while on how to "collect" the arbitrary operations
19:25:34 <lmapper> in c it would just be an array of function pointers
19:31:05 <EvanR> it would also segfault 100 times before you get it right
19:31:20 <EvanR> but yeah, youre stuck trying to figure out how to put a bunch of stuff into an array
19:31:35 <EvanR> i found you have to stop doing that to get anything done
19:32:16 <EvanR> what are you going to do with the array, sequentially execute every operation? lookup entries by a key?
19:32:32 <lmapper> yeah, it doesn't help that I've built another version of this kind of system in c++
19:33:25 <lmapper> lookup entries (functions) from a map
19:33:47 <EvanR> what is the key type
19:34:03 <lmapper> string, or later may change to Text
19:34:14 <EvanR> that is unlikely to be well typed
19:34:58 <EvanR> if you have a map from String to X, then everything in the array must have the same interface
19:35:00 <lmapper> yes, that's true, but it's from JSON that I am generating
19:35:38 <EvanR> they dont have to be the same type behind the scenes, but they need to have a uniform interface, which is why i asked what things returned
19:36:19 <lmapper> if step away from this type of map of functions, is there another, more "haskell" way to structure this project?
19:36:28 <EvanR> good question
19:36:32 <lmapper> that's really what I'm looking to find out
19:36:51 <EvanR> please paste your project manifesto :)
19:42:03 <lmapper> I did not write a project manifesto yet, and was just building it up as I went. however, the front end gui is very close in design to this: http://docs.fabric-engine.com/FabricEngine/2.3.0/HTML/GettingStartedGuide/canvastutorials.html#first-math-formula
19:42:22 <lmapper> where arbitrary nodes have different numbers of ports
19:42:26 <EvanR> ah
19:42:36 <EvanR> do these nodes in your graph have state ?
19:43:11 <lmapper> the nodes themselves do not, they are just functions, but many will be defining IO actions
19:43:22 <EvanR> thats fine
19:43:33 <EvanR> so what it sounds like is your network is some expression
19:43:36 <lmapper> but I have no plans for state management, or creating state
19:43:43 <EvanR> when you modify it you just change the expression
19:43:58 <EvanR> later, the expression is used for something, like IO
19:45:03 <EvanR> and the links have a type that needs to match up with ports
19:46:00 <EvanR> once you construct the network and verify these link types, you shouldnt have to do dynamic checking later
19:46:35 <EvanR> the verification happens when you build or modify the network, the graph, the expression
19:49:29 <lmapper> right now the gui is not written in haskell, the gui node/port connections are saved as JSON data
19:49:41 <EvanR> you can implement this with smart constructors or with fancy GADTs
19:49:58 <lmapper> then I'll parse the JSON data to build the "haskell" backend processing node graph
19:50:01 <EvanR> thats fine because you can treat the JSON as the pile of actions to build the network
19:50:17 <EvanR> and rebuild it completely if its updated
19:51:04 <lmapper> yes, I was temporarily using a String instead of a JSON value
19:51:23 <lmapper> so that's why the function map was being looked up by a string key
19:51:40 <EvanR> so do you have a type for the possible node types
19:51:50 <EvanR> a sum type, i should say
19:52:45 <lmapper> a sum type for the possible node types... I do not
19:53:01 <mnoonan_> Would anybody mind giving me some feedback on this slide deck I’m working on? http://haskell.storm-country.com/presentation.html
19:54:10 <EvanR> does each node type have a known input/output interface
19:55:00 <lmapper> I will know beforehand, I plan to hard code that at this stage, both front end and back end
19:55:23 <EvanR> mnoonan_: nice!
19:55:37 <mnoonan_> thanks!
19:55:53 <lmapper> each node type will have different port types, and different numbers of ports, but defined already at compile time
19:55:54 <mnoonan_> work in progress, but I think it is getting close to usable
19:56:03 <EvanR> lmapper: good, so that explains how new linkage could be verified before you add it
19:56:39 <EvanR> each node interface is like, ([PortType],[PortType])
19:57:25 <EvanR> connecting a wire between node A at i and node B at j means checking the right list in A and first list in B at i and j to make sure theyre the same
19:58:24 <EvanR> and each wire in the network is conceptually a (NodeId, NodeId, Int, Int)
19:59:05 <EvanR> from a pile of such tuples you could make indexes in various directions for fast lookup
20:01:21 <lmapper> yes, the structure can be arranged this way.  Now, how do we define the behavior of the node?
20:02:17 <EvanR> its a totally separate problem right, and doesnt change these network structure
20:02:27 <lmapper> yes, totally separate problem
20:02:52 <EvanR> ok so what exactly is the behavior anyway
20:02:58 <EvanR> how do you interpret this network
20:03:24 <EvanR> in words
20:03:32 <lmapper> it's a directed acyclic graph, root node is evaluated first
20:03:55 <EvanR> evaluates to what?
20:04:28 <EvanR> sorry i have no idea what that program does :)
20:04:34 <lmapper> it evaluated it's port inputs one by one, each is evaluated to a value, like Int, Bool, Float, String, IO, etc
20:04:50 <EvanR> so wait, the root has inputs?
20:05:16 <lmapper> yes, it's like "main" :)
20:05:47 <EvanR> is this outside the wire framework
20:06:07 <lmapper> no, its just the entry point
20:06:09 <EvanR> is it like, magical input?
20:06:29 <lmapper> it's just the entry and final result
20:06:30 <EvanR> where does the input come from
20:07:09 <lmapper> it's like a tree, the leaves of the tree define the data inputs
20:07:25 <EvanR> oh, the root is at the end of the process?
20:08:05 <lmapper> we first call the root, he evaluates "trunk", "trunk" calls "branch", "branch" calls "leaf", "leaf" returns value, so now branch has a value, etc etc
20:08:09 <EvanR> this initial evaluation is going to recursively do something with the other stuff in the network
20:08:13 <lmapper> finally, root has the value he asked for
20:08:26 <lmapper> until all the inputs are evaluated
20:08:36 <lmapper> yes
20:08:44 <EvanR> are you expecting some stages of this to do IO
20:09:05 <lmapper> this is how the last lpaste works
20:09:17 <lmapper> yes, in fact, the leaves must do IO
20:09:27 <EvanR> ok
20:09:34 <lmapper> since they retrieve the data necessary to pass through the tree to the root
20:10:10 <EvanR> what happens if you encounter the same node twice, thanks to DAGness
20:10:21 <EvanR> anything special?
20:10:43 <lmapper> I can deal with that later, initially it will just be calculated twice
20:10:51 <EvanR> ok so its pure and ok
20:11:51 <EvanR> i think i see a type signature that explains the interpretation
20:12:21 <lmapper> so far, the difficult part for me has been how to "categorize" or collect all the "functions" of the nodes
20:12:52 <lmapper> since they have different numbers of "port inputs", so different numbers of "function parameters"
20:13:01 <EvanR> right
20:13:46 <EvanR> whats an example node signature
20:13:55 <EvanR> also, does each node have 1 output
20:13:59 <lmapper> Data.Dynamic works, but I also needed to supply the type of the function at that time in order to succesfully cast
20:14:08 <EvanR> Dynamic is not right here
20:14:28 <lmapper> I can settle for 1 output per node if it simplifies things
20:14:52 <lmapper> Operation1 :: Int -> Int -> Int
20:14:54 <EvanR> if its not 1, then we need to revisit what this root node is doing
20:15:03 <lmapper> Operation2 :: String -> Int
20:15:07 <EvanR> what do oyu expect out of it
20:15:36 <lmapper> Operation3 :: String -> IO [String]
20:16:11 <lmapper> along with Double, Bool, etc.  That would be enough to get started
20:16:15 <EvanR> so this is turning into simply a regular programming language
20:16:47 <EvanR> well you can parameterize each node so you can use any haskell types that match up 
20:17:05 <EvanR> instead of a collection you have a big nest
20:18:13 <lmapper> a nest?
20:18:31 <EvanR> ok, look at this... first, assume every function looks like a -> b -> ... -> IO c. the ones that dont do IO just wont use it, directly.
20:18:43 <lmapper> sure
20:20:45 <EvanR> your final answer is an IO a, for some a, right
20:20:53 <lmapper> yes
20:21:03 <EvanR> lets say you want to use op1 above to get it
20:21:28 <EvanR> and the file specifies input 1 is op2 and input 2 is also op2
20:22:14 <EvanR> the file specifies the input to the first op2 is something of type IO Int, and the input to the second op2 is something of type IO Int
20:22:43 <EvanR> if you have all 5 of these things, the final answer is just the monadic / application combination of all these things
20:22:55 <EvanR> monad / applicative / functor
20:23:27 <EvanR> liftA2 op1 (fmap in1 op2) (fmap in2 op2) :: IO Int
20:23:55 <EvanR> 1 input, fmap. 2 inputs liftA2. 3 inputs liftA3
20:25:04 <EvanR> the recursive algorithm to apply all these would need to check that the types match, and check the number to pick which liftA to use, combine the IO actions, and return it
20:26:34 <lmapper> I'm still not clear what would happen at the parsing step -> identifying which "op" to use based on the JSON
20:26:51 <EvanR> do you have an example json
20:27:33 <lmapper> your explanation looks awesome, but I will get stuck at this parsing -> choosing function step
20:28:21 <EvanR> its kind of the only step too
20:28:44 <EvanR> i dont have a basis for what the json looks like to give an example
20:30:20 <lmapper> I was temporarily parsing a string that reads "Operation1"
20:30:30 <lmapper> instead of using JSON at first
20:30:35 <EvanR> ok
20:30:59 <lmapper> but, is there a way to parse JSON that would make it all fall into place?
20:31:31 <lmapper> is that what you're describing
20:31:38 <EvanR> json is really tangential, lets start with operation 1
20:31:51 <EvanR> so you see this node is operation 1, and what, what the 2 inputs are?
20:32:03 <EvanR> as node ids?
20:32:48 <lmapper> "name" or "String", but I can give them node ids instead on the front end
20:33:02 <lmapper> right now they just have unique names
20:33:29 <lmapper> let me post the json, that will make it clearer
20:33:57 <lmapper> http://lpaste.net/8091215067036516352
20:35:07 <lmapper> this described four nodes
20:35:39 <lmapper> two connections
20:36:05 <lmapper> so there are two root nodes here
20:36:29 <lmapper> that's not important though, this is just an example I had on hand
20:37:11 <EvanR> right, ok
20:37:38 <EvanR> right, im developing the GADT right now which explains how to hook these together
20:38:05 <lmapper> so node "outputEmailTesting" has a nodeType of "SendEmail", so somehow I need to have haskell look up the operation corresponding to the "SendEmail" function, or something like that
20:38:17 <lmapper> ah, that's awesome, thanks 
20:38:22 <ReinH> EvanR: There's an argument to be made for calling fmap liftA1
20:39:22 <EvanR> yeah
20:40:18 <EvanR> lmapper: what is the output of email testing?
20:40:23 <lmapper> I have been trying to work this out for around two weeks
20:40:45 <lmapper> IO () or IO String
20:43:58 <EvanR> alright heres the piece i think you need!
20:48:53 <lmapper> cool, I'm still here
20:50:38 <EvanR> uhg... 
20:50:54 <EvanR> the neutrons didnt form. but let me show you some technology that could be used
20:51:12 <lmapper> haha its ok, it's late here too
20:51:40 <EvanR> lets say you have some specific signature hardcoded for each node type
20:52:18 <EvanR> then when you read in the untyped data, and have only strings for instance, you want to lookup else, then check that their types are compatible at runtime before combining them
20:52:25 <EvanR> you can do this with https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Type-Equality.html
20:52:59 <EvanR> the testEquality function will allow you to get a proof that two types are the same, convince ghc it makes sense, and continue
20:53:43 <EvanR> or else fail
20:54:45 <EvanR> here is a GADT which lets you represent values OR functions of any number of arguments to get a value of a certain type: https://twanvl.nl/blog/haskell/non-regular1
20:55:15 <EvanR> which is what these node signatures are. constantString :: IO String. op1 :: Int -> Int -> IO Int
20:56:40 <EvanR> by constructing a FunList step by step, you are satisfying the different types are arguments dynamically. when its Done, you can finally apply the function to all the arguments
20:57:38 <lmapper> The FunList sounds like it could work
20:57:49 <EvanR> types of arguments*
20:58:39 <tabemann> I feel bad emulating a foldrM with reversing a sequence and then feeding it into a foldM
20:58:40 <EvanR> except in this case youre not just applying the function, but (<*>)ing
20:58:55 <tabemann> because I'm using Seq values, the reversal is O(N)
20:59:24 <EvanR> two reverses?
20:59:54 <tabemann> what I mean is I'm using a foldM with reverse to emulate a foldrM because there is no foldrM
21:00:31 <tabemann> except it's more expensive than foldM because of the reverse
21:00:34 <EvanR> isnt foldM that
21:00:42 <tabemann> foldM is a left fold
21:00:49 <glguy> :t foldrM
21:00:51 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
21:01:38 <MarcelineVQ> the defintions for foldrM / foldlM are quite interesting
21:01:44 <tabemann> haha didn't know that existed
21:05:56 <lmapper> EvanR, I'm looking at Data.Type.Equality, but it's a bit outside my current haskell knowledge at the moment
21:07:22 <EvanR> as usual im noticing some funny "things that dont matter" in this problem
21:08:51 <EvanR> namely the content of the strings, all the really matters is your algorithm produces some IO action. the question still remains IO what, at the top level
21:09:08 <EvanR> if the whole is just supposed to have IO effects and not return anything, then IO ()
21:09:25 <EvanR> compileAndRunJSON :: Text -> IO ()
21:10:03 <lmapper> I can live with that
21:10:30 <EvanR> ok..
21:11:57 <ghasshee_> :i Foladable 
21:12:47 <ghasshee_> :i Foldable
21:13:35 <ghasshee_> :t foldrM
21:13:37 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
21:14:35 <EvanR> given a pile of top level haskell functions of different types... how to compose them together as directed by a list of strings... or report "sorry i cant do that" arbitrarily
21:14:52 <EvanR> is what im boiling this down to
21:18:51 <lmapper> yeah... I forced it with a Map String Dynamic , but it didn't seem like the right solution
21:18:56 <EvanR> ah with a parser
21:19:32 <EvanR> no... parser doesnt have a type that depends on the input
21:19:38 <EvanR> (without dependent types)
21:20:37 * EvanR pokes some more GADTs
21:21:58 <zomg> Custom Show instance for a data type storing credentials which hides the sensitive bits - just pretending to be secure, or perhaps a good idea? :P
21:23:23 <EvanR> something about Show makes me think it should never escape development
21:23:36 <pacak> zomg: Just pretending.
21:24:05 <pacak> Show instance supposed to generate proper haskell code that can be later pasted in or used in ghci.
21:24:10 <zomg> EvanR: yeah, just use it a lot for debug logging and stuff
21:24:34 <zomg> pacak: yeah, it's still valid but it just doesn't show what's actually in it :) at least less likely that any debug logs dump sensitive info I guess
21:25:31 <EvanR> now you cant see that info if youre debugging
21:25:59 <EvanR> a separate pretty class for log dumps makes more sense
21:27:22 <zomg> Yeah, I guess it doesn't make a huge difference. Just have any actual logging facilities use something else
21:27:40 <lmapper> well Evan, thanks very much for your help
21:28:01 <lmapper> I'm going to head to bed now
21:28:27 <lmapper> I didn't realize this was going to be such a tough problem
21:32:36 <EvanR> lmapper: still workin on it :)
21:32:51 <lmapper> ah man, I can't leave yet then
21:33:02 <EvanR> lol
21:35:51 <lmapper> It would be a shame to miss an awesome parser/gadt/type equality proof applicative that suddenly solves everything
21:36:32 <EvanR> it will probably happen, eventually
21:36:44 <EvanR> ive done this kind of thing before i realize
21:39:22 <lmapper> I've been reading and dabbling in haskell on and off for a couple of years, but this is the first actual larger thing I've tried to write
21:43:46 <EvanR> how do you know what the root is
21:43:59 <EvanR> just pick one?
21:46:43 <lmapper> for now, I can just write it directly in the json... but basically certain node types will always be "root" or "output" types
21:47:19 <lmapper> I could make a node whose only purpose is to be the root
21:48:27 <EvanR> sounds like you could just name one to be the root then
21:48:39 <lmapper> yeah, that's totally fine
21:52:19 <glguy> EvanR: what're you trying to build?
21:52:24 <zomg> well this is a fun little activity... cryptohash says "go use cryptonite" and cryptonite says "go use something else if you have no idea what you're doing"
21:52:39 <zomg> I wonder what counts as "no idea" in this case... :P
21:53:18 <EvanR> lmapper's thing that readers some json and decides how to put together a bunch of IO functions with various function types
21:53:21 <MarcelineVQ> probabaly, as a catch22, having to wonder what counts as no idea
21:53:36 <MarcelineVQ> or is that begging the question, english is hard
21:57:23 <piyush-kurur> MarcelineVQ: I think this whole point that users need to know a lot of crypto and security stuff before they can use a particular crypto library is very old school
21:58:15 <piyush-kurur> honestly you cannot expect an average developer to keep track of all the latest in crypto if all he is planning to do is an accounting software
21:59:13 <glguy> EvanR / lmapper: Is there a simple example you have in mind or could you briefly explain what the JSON file means?
21:59:29 <LiaoTao> piyush-kurur: It's a matter of degree of involvement. There is due diligence in the developer's part to ensure the software isn't affected by trivial, well-known problems
21:59:34 <LiaoTao> on*
21:59:39 <glguy> Is the set of function that are available to the system fixed?
21:59:53 <EvanR> for the sake of argument yes
22:00:00 <piyush-kurur> LiaoTao: what exactly constitute a well known problem?
22:00:03 <MarcelineVQ> hmm, if crypto matters to the task I would expect some effort in that direction yes, I agree that knowing all the parts of cryptonite is a bit much
22:00:12 <kadoban> piyush-kurur: Then that developer should not be using crypto libraries which aren't targetted to them.
22:00:17 <LiaoTao> piyush-kurur: SSLv3 f.ex.
22:00:25 <EvanR> in the json you have essentially [(String, [String])] which are what nodes names are, and what the names of their inputs are
22:00:27 <LiaoTao> Also what kadoban says
22:00:48 <EvanR> youll have the same number of inputs as arguments to the corresponding function
22:01:02 <piyush-kurur> kadoban: but crypto library writers have to be address this issue by giving high level access
22:01:06 <EvanR> as long as the types and number match up, good
22:01:10 <piyush-kurur> Otherwise we are all going the OpenSSL way
22:01:16 <kadoban> It makes sense to have crypto libraries that can do *every* cipher and hash anyone would ever want. It most certainly doesn't make sense to expose that interface to people who just want something "secure" since they're bound to accidentially pick the wacky ones.
22:01:29 <kadoban> piyush-kurur: Not every library needs to be targetted to the same users.
22:01:37 <EvanR> no input means an IO a, not a function
22:01:47 <EvanR> IO A
22:02:02 <EvanR> all the functions return IO Something
22:02:20 <glguy> EvanR: so the set of inputs is different than the result, which is always IO ()?
22:02:35 <glguy> Oh, or there are some result types beyond ()
22:02:40 <piyush-kurur> kadoban: regarding implementing all crypto primitives, I have a very different take. I believe in what I call the "one-trick pony design"
22:03:22 <kadoban> piyush-kurur: Great. So do that. But what about everyone else who might want implementations of standard ciphers they can use for specific uses?
22:03:42 <kadoban> Should that library not exist because it doesn't fit piyush-kurur's take on things?
22:03:42 <lmapper> for now we can just return IO () 
22:03:57 <piyush-kurur> kadoban: no I did not say that
22:03:59 <EvanR> glguy: the top level root would be IO (), everything else could be other types
22:04:05 <EvanR> IO Int, IO String
22:04:29 <piyush-kurur> I am saying crypto-library writers should not make it seem that using it requires some special foo
22:05:34 <glguy> EvanR / lmapper: so something along this line? http://lpaste.net/210281667531636736
22:05:35 <kadoban> So they should just pretend that crypto-naive users will always pick good ciphers and use them appropriately? That doesn't sound like a good idea.
22:05:38 <lmapper> the part I was having difficulty with is choosing the (predefined) haskell functions which correspond to what is chosen by the json configuration
22:05:53 <piyush-kurur> kadoban: the defaults should be strong
22:05:59 <piyush-kurur> that is the point
22:06:50 <LiaoTao> kadoban: Though I get your point that there should be simple interfaces with good defaults for libraries targeted at the crypto-naive developer
22:07:07 <LiaoTao> My point is also that a complete crypto-naive developer shouldn't exist
22:07:14 <LiaoTao> It's part of the job if you develop such software
22:07:14 <kadoban> LiaoTao: That is not *my* point.
22:07:29 <piyush-kurur> LiaoTao: that probably was my point
22:07:31 <LiaoTao> kadoban: Excuse the misinterpretation
22:07:46 <LiaoTao> Yes
22:08:03 <LiaoTao> Blame no coffee
22:08:07 <lmapper> glguy: I am reading your code now,
22:08:15 <kadoban> No worries
22:08:16 <EvanR> me too
22:08:19 <EvanR> i also have some code here
22:08:38 <piyush-kurur> LiaoTao: Let me give examples. 
22:09:27 <glguy> It might not make sense to split up the Result and Argument types if you're planning to chain these things together
22:09:30 <EvanR> glguy: so this works if the predefined haskell functions are filtering their inputs 
22:09:41 <EvanR> dynamic type like
22:09:47 <EvanR> they all take Arguments
22:09:53 <glguy> EvanR: The basic function don't need to do that
22:09:53 <piyush-kurur> LiaoTao: Should a library give (as the default) an encrypted authenticated mode or should it expect the users to assemple the appropriate ciphers and hmacs or whatever to build one such
22:10:02 <EvanR> basic function?
22:10:12 <glguy> EvanR: But then when we wrap those function in the Value type, we include in the wrapper some pattern matching
22:10:29 <LiaoTao> piyush-kurur: I think we are in agreement on this point - The OpenSSL way is long since deprecated
22:10:46 <piyush-kurur> LiaoTao: great
22:10:53 <EvanR> how do you get your basic functions back
22:11:01 <glguy> EvanR: You don't need them
22:11:01 <EvanR> after converting them to Value
22:11:06 <piyush-kurur> Now I want to extend it to future (not necessarily current) standards
22:11:10 <LiaoTao> piyush-kurur: Perhaps my point is, then, that we shouldn't go with extremes in either way
22:11:19 <glguy> EvanR: When you're done you case on the final value and see if it's a Result
22:11:19 <EvanR> so were perpetually checking arguments/
22:11:31 <EvanR> oh we only ever do the IO once
22:11:36 <glguy> EvanR: yes, it's going to be necessary to check arguments no matter what solution we find
22:11:53 <glguy> since we have an untyped input program
22:11:57 <EvanR> well... not every time you run the IO
22:12:02 <piyush-kurur> Say I design a secure communication protocol like noise of some thing like that. How should a library expose interface to it
22:12:11 <glguy> Right, this solution doesn't do it every time you run the IO
22:12:29 <glguy> all the arguments have been considered by the time you ever get the final IO _ action
22:12:42 <piyush-kurur> I would go by the "one trick pondy design" which is to fix a best (by current knowledge) primitives  and not give options
22:12:56 <piyush-kurur> *pony
22:13:00 <EvanR> so Finished is closing over the checked values, unwrapped
22:13:12 <piyush-kurur> what happens if this choise is broken?
22:13:29 <glguy> Let's just extend the example to wrap a function
22:14:00 <glguy> and we could just use a single Value type depending on how this JSON input is structured
22:14:03 <piyush-kurur> update the version and again fix the primitives to the ones that are not yet broken
22:14:13 <glguy> the different layers might not be relevant to the particular problem
22:17:19 <LiaoTao> piyush-kurur: That's how people are using OpenSSL more or less
22:17:29 <EvanR> wrap :: (Functionish t, IsResult (ReturnTy t)) => t -> Value ?
22:17:39 <LiaoTao> So it'd definitely simplify things
22:17:40 <piyush-kurur> LiaoTao: but the library does not say anything
22:17:50 <LiaoTao> No, I agree
22:18:03 <glguy> EvanR: I think that it would be quite easy to write such a class to make wrapping functions automatic, yes
22:18:24 <EvanR> im thinking this will work way better than what i was doing
22:18:52 <piyush-kurur> LiaoTao: We (i.e Distros) have learned it the hard way to fix the primitives 
22:19:04 <lmapper> will that work for functions with multiple parameters?
22:19:09 <piyush-kurur> All I am saying is that we should make this lesson official
22:19:09 <EvanR> yah
22:19:36 <EvanR> instance Functionish (IO a) whre ReturnTy (IO a) = IO a
22:20:14 <EvanR> instance Functionish b => Functionish (a -> b) where ReturnTy (a -> b) = ReturnTy b
22:21:04 <EvanR> though that wont totally work with my IsResult 
22:21:15 <EvanR> ReturnTy (IO a) = a
22:21:30 <glguy> annotated http://lpaste.net/210281667531636736
22:23:25 <EvanR> well now IsResult isnt necessary
22:23:59 <EvanR> or maybe it is... needs to auto know how to wrap a String or Int result
22:24:02 <piyush-kurur> LiaoTao: We know that naive string comparison is bad in security. What are libraries doing to enforce that any comparison of sensitive data are timing safe. 
22:24:15 <EvanR> or Unit
22:24:33 <piyush-kurur> I would say just exposing a timing safe comparison and expecting the users to use that is asking for disaster
22:24:53 <LiaoTao> Perhaps, but you might also consider modularity to some degree
22:25:03 <LiaoTao> Not all operations will consider sidechannel attacks viable
22:25:10 <EvanR> here is what i was doing http://lpaste.net/356480
22:25:24 <EvanR> find is where the checking is done
22:25:40 <EvanR> not really fleshed out
22:25:47 <piyush-kurur> LiaoTao: Haskell can enforce some things in types. We should use it.
22:26:01 <piyush-kurur> For example our hashes or macs should not be just bytestrings
22:26:23 <piyush-kurur> They should be opaque types that have timing safe equalities
22:26:31 <LiaoTao> I'm not qualified to make such statements, to be honest
22:26:34 <EvanR> timing safe haskell o_O
22:26:36 <LiaoTao> I see where you are coming from, though
22:27:03 <piyush-kurur> EvanR: not in general but eqaulity?
22:27:08 <piyush-kurur> *equality
22:27:28 <EvanR> predictable timing of an equality test written in haskell?
22:28:21 <piyush-kurur> EvanR: most crypto types are simple "array of bytes" things so it is possible to do that
22:29:17 <piyush-kurur> But you should not expose it as ordinary bytestrings
22:29:20 <lmapper> EvanR and glguy, thank you for sharing the examples 
22:29:44 <EvanR> im going to have to write down and remember this trick from glguy
22:29:52 <lmapper> it appears that glguy's example solves the problem, but I need to take some time to digest it
22:30:19 <glguy> EvanR: Now that we have a sketch of a simple solution, let's explore the complex one
22:30:20 <EvanR> still not totally sure how a nice wrapper will work, but the idea makes sense
22:30:26 <lmapper> I don't see where the magic happens, but it happens somewhere
22:31:39 <Axman6> piyush-kurur: IIRC that's what cryptonite does (though also lets you work with ByteStrings)
22:31:40 <EvanR> the Map is populated with tagged versions of every operation
22:32:04 <EvanR> when you use a string, you can check at runtime if it corresponds to what you need now
22:32:29 <EvanR> eventually you get an IO action or not
22:33:23 <lmapper> I see, thank you
22:34:00 <EvanR> the checking of operations is done in the operation there
22:34:08 <EvanR> the checing of argument types is done in the operation
22:34:14 <EvanR> which is a pain
22:34:25 <piyush-kurur> Axman6: I just checked that cryptonite. I guess Digest is the type for hashes
22:34:33 <EvanR> but typeclass industry could automate the wrapping, i think
22:35:00 <piyush-kurur> It looks like it is a newtype on F.UArray Word8 and derives its Eq instance
22:35:27 <piyush-kurur> I am not sure if F.UArray Word8 's equality is timing safe. May be it is
22:35:59 <LiaoTao> piyush-kurur: Although, isn't Haskell not a very good candidate for runtime behaviour analysis?
22:36:27 <EvanR> glguy: wait, does it do IO in any operation or only at the end
22:36:28 <glguy> EvanR: lmapper: http://lpaste.net/210281667531636736
22:36:33 <piyush-kurur> LiaoTao: yes those are the things that are bad about Haskell
22:36:37 <lmapper> so you are saying, the case statement in wrappedPrintInt can be resolved through typeclasses, ?
22:36:50 <LiaoTao> i.e. it's hard to reason about what actually happens without disassembling the executables and just reading the machine instructions
22:36:54 <piyush-kurur> One never knows what the adversary can learn by knowing when GC happens
22:37:00 <piyush-kurur> that is a hard problem
22:37:01 <glguy> EvanR: You can structure it however you want, more types like the first with arguments and result can limit what can be an argument or result
22:37:10 <glguy> EvanR: a single Value layer limits less
22:37:43 <glguy> EvanR: This GADT based annotation is probably closer to what you had in mind earlier
22:38:21 <EvanR> yeah
22:39:51 <EvanR> so if you have an operation like Int -> IO Int, you should be able to plug in an IO Int as an input to get an IO Int, with fmap somewhere
22:40:08 <EvanR> i just assumed everything would be IO Something and youd use <*> everywhere
22:41:02 <piyush-kurur> LiaoTao, Axman6: cryptonite is a great library. We need such a library in any ecosystem. All I am saying is that it is not using Haskell's type system to the fullest potential.
22:42:04 <LiaoTao> That may very well be the case
22:42:16 <mauke> inb4 type-level rsa
22:42:18 <LiaoTao> Why not submit patches? :)
22:42:31 <moonrunes[m]> why does group title say haskell is purely functional programming language?
22:42:48 <moonrunes[m]> what kind of joke is this?
22:43:03 <mauke> moonrunes[m]: what?
22:43:21 <moonrunes[m]> haskell isn't purely functional
22:43:25 <mauke> why not?
22:43:29 <piyush-kurur> LiaoTao: I am exploring these ideas in a library on my own. 
22:43:33 <EvanR> the Universe thing is awesome
22:43:51 <moonrunes[m]> https://chadaustin.me/2015/09/haskell-is-not-a-purely-functional-language/
22:44:03 <lmapper> yeah, I think this is the example I needed to see
22:44:05 <piyush-kurur> I did once send a patch to hs-asn1 package of vincent once
22:44:17 <glguy> EvanR: I've annotated http://lpaste.net/210281667531636736 with a fromValue and toValue
22:44:39 <mauke> moonrunes[m]: "I argue that purely-functional, while in some ways accurate"
22:44:52 <mauke> article doesn't support your claim
22:45:12 <moonrunes[m]> mauke: are you insinuating that I'm shitposting?
22:46:15 <mauke> moonrunes[m]: either that, or you stopped reading at the headline
22:46:59 <EvanR> fromValue and toValue look like Dynamic
22:47:13 <EvanR> with Universal rather than Typeable
22:47:21 <moonrunes[m]> mauke: I believe, the letter of the headline is more important than the spirit of the article
22:47:40 <glguy> EvanR: yeah, basically
22:47:51 <EvanR> well type all the things!
22:48:21 <mauke> well, I have to go
22:48:30 <mauke> moonrunes[m]: do you want me to ban you now or when I come back later?
22:48:47 <glguy> EvanR: instead of Universe you could use TypeRep if you wanted to  support all Haskell types and not a limited "universe" of them
22:49:12 <EvanR> would that simplify lmapper's task
22:49:29 <EvanR> would there be a disadvantage
22:50:19 <lmapper> it sounds like a fine idea to support all Haskell types :)
22:50:46 <glguy> EvanR: I'm stuck thinking about how to implement the function application case
22:50:49 <glguy> with TypeRep
22:51:02 <glguy> I need a moment to see if I think it's possible
22:51:02 <lmapper> the provided example is very good though.
22:51:38 * EvanR scribbles down the details of the universe pattern
22:52:18 <lmapper> well EvanR, you were right about the Data.Type.Equality
22:53:21 <EvanR> i knew there would need to be some sort of runtime test at some point, and if it involves the type system, Type Equality is probably involved
22:55:51 <lmapper> I'm getting a type deduction error when adding the universal type class to the previous code, after adding RankNTypes language extension
22:56:01 <lmapper> Could not deduce (Universal a2) arising from a use of ‘universe’
22:56:02 <lmapper>   from the context: Universal a
22:56:08 <lmapper> in fromValue
22:56:19 <EvanR> a2, a thats a clue that you didnt bring the variables into scope properly
22:56:37 <EvanR> with RankNTypes, you need to introduce type variables with an explicit forall, or its a different variable with the same name
22:56:49 <glguy> EvanR: OK, so to use Dynamic instead of the "Value" I've defined you can use : dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
22:57:22 <EvanR> i think lmapper was originally doing that
22:57:32 <glguy> EvanR: It cheats! 
22:57:41 <EvanR> oh?
22:57:44 <glguy> but it cheats in a central place so I guess it's OK
22:58:01 <lmapper> yeah, I originally had a Map String Dynamic
22:58:21 <lmapper> and had all the functions as Dynamic
22:58:57 <glguy> That's not a bad solution if you want that much flexibility
22:59:04 <lmapper> but I had to explicitly give the type signature of the function again when using fromDynamic
22:59:11 <EvanR> ok so 1. this still doesnt quite let you use IO in the leaves to get your args in the nodes before doing more IO there. so youll probably need to modify it slightly. 2. writing each multiarg function as an expansive nested Value will be annoying manually
22:59:43 <glguy> For 2 you'd want to let a typeclass drive that
23:00:34 <glguy> The universe approach means you know there's a closed set of possible types so you could write a function that consumes a Value and knows all the possible things it could be
23:02:42 <EvanR> something about it is more appealing than Dynamic 
23:05:33 <lmapper> well, this has been an intriguing excursion.  I need to go through and digest these examples.. 
23:06:24 <lmapper> thanks again glguy and EvanR
23:06:54 <lmapper> I did not expect to go to the edge of the haskell universe with this issue
23:09:47 <lmapper> good night everyone
23:11:42 <EvanR> haha
23:14:24 <sveit> (i don't mean this to be inflamatory, sincerely wondering) the best example of a serious compiler written in Haskell i know of is GHC, which has long build times. is it reasonable to take this as evidence that if compiler performance is important, haskell isn't the right choice at this stage?
23:15:52 <sveit> or are compilers one application domain where Haskell compiles to code 1-2x slower than C, and GHC is just slow due to the complexity of the language it is compiling?
23:16:23 <piyush-kurur> sveit: more like the later
23:16:57 <piyush-kurur> see for example compilers like MLton or the rather controversially named Stalin
23:17:17 <piyush-kurur> the are slow to compile because they do too many things
23:17:29 <jared-w> What haskell does is it allows for programming at an extremely high level of abstraction, yet it tries to achieve near parity with C performance. This results in a ridiculously complex compiler.
23:17:50 <pacak> jared-w: Tries? It achieves it.
23:17:54 <jared-w> With compilers you have a) performance b) compiling speed c) features. The joke is you can only pick 2
23:17:55 <EvanR> i want to know where the performance is going
23:18:11 <EvanR> we know that linking is slow
23:18:14 <moonrunes[m]> EvanR: into compiling
23:18:19 <jared-w> pacak: I meant "tries" as in that is a goal of the compiler, not that it didn't achieve that goal :)
23:18:24 <EvanR> that might be eating up most of the apparent time
23:18:25 <moonrunes[m]> it's the performance of compilation, not runtime
23:18:36 <EvanR> the linker kind of isnt even GHCs fault
23:18:55 <jared-w> Indeed, if you use the ldd linker you can get 10-100x speedup with linking times
23:19:08 <wz1000> sveit: IIRS, compilers for Purescript, Idris, Agda, Elm and Perl6 are written in Haskell.
23:19:14 <wz1000> *IIRC
23:19:27 <piyush-kurur> EvanR: naively (I am saying this because I do not know the internals) things like inlining or more generally rewrite rules could be a big performance sink
23:19:51 <jared-w> wz1000: that doesn't mean anything as far as performance goes. A compiler written in some language means nothing about how that compiler and its new language will perform
23:20:01 <cocreature> -O0 “solves” most cases where GHC is really slow
23:20:04 <EvanR> i cant imagine there no room for rewriting parts to be faster
23:20:05 <pacak> By using a smart build system you can avoid a bunch of unnecessarry compilations. By using ghcid you can avoid a lot more compilations until you actually have code that typechecks.
23:20:17 <sveit> thanks for all the responses!
23:20:19 <piyush-kurur> EvanR: I am not saying that. 
23:20:20 <cocreature> EvanR: ofc there is room but it’s a lot of work :)
23:20:33 <pacak> By using a smart build system that uses ghcid and smarter linking...
23:20:34 <cocreature> in fact 8.2 is already slightly faster than 8.0 in most cases
23:20:48 <piyush-kurur> I am just saying (in a very uninformed way) that things like rewrite rules are going to slow down compilers
23:20:49 * pacak wonders if he should publish his build script...
23:20:50 <EvanR> awesome
23:20:55 <sveit> wz1000: i know that many compilers are written in Haskell, but for the project I have in mind I'd like to prioritize build times, whereas those projects might not
23:21:16 <EvanR> i have heard of tweaks to get faster build times
23:21:19 <jared-w> sveit: If you want to prioritize build times, look at the language Go vs the Haskell language
23:21:22 <EvanR> -O0 is a funny one
23:21:33 <jared-w> Go is built from the ground up to achieve fast compile times and makes many sacrifices in order to do so
23:21:45 <pacak> sveit: What project might that be? Have you thought about using javascript? There's no compilation involved at all....
23:21:46 <cocreature> EvanR: I use -O0 for development in pretty much any language
23:21:49 <jared-w> Haskell, on the other hand, gives not a single rat's ass about compile times
23:22:14 <piyush-kurur> jared-w: and most haskellers do not give a rat ass to go ;-)
23:22:39 <LiaoTao> Well I sort of like Rust...
23:22:40 * LiaoTao hides
23:22:43 <jared-w> Fair enough :p I'm just saying, if one wants to understand how to build a blazingly fast compiler, looking at how Go achieved it is one way to do it
23:22:47 <sveit> thanks again for the responses, but i think i'm being misunderstood. i not choosing between Haskell vs another project to write an application. i know that i want to write a compiler. i do not care how long the compiler takes to compile, so I could use Haskell for it. I care about the performance of the compiler itself.
23:22:52 <pacak> https://xkcd.com/303/
23:22:57 <jared-w> Rust also suffers from slow compiler syndrome :p
23:23:29 <EvanR> one question we could perhaps settle is if #haskell gives a rats ass about compile time
23:23:34 * EvanR raises hand
23:23:41 <jared-w> sveit: the performance of a compiler is not going to be magically better because you picked one turing complete language over another
23:23:55 <sveit> i am just wondering if people with experience in Haskell already know that acheiving fast build times with a compiler written in Haskell is very hard/impractical, or just not prioritized
23:24:11 <EvanR> wait, are other compilers written in haskell slow?
23:24:16 <jared-w> That being said, Haskell tends to offer very high efficiency and performance loops with regards to correctness, speed, efficiency, etc., than most other languages
23:24:43 <piyush-kurur> sveit: like any other language you can write fast programs (compiler being one of them) or slow programs for the same problem
23:24:51 <pacak> sveit: I'm using haskell for algoritmic trading  with reaction time measured in tens of microseconds.
23:25:13 <jared-w> But the compiler that you write... its build time will not change much at all compared to C, Rust, Haskell, Go, Java, etc...
23:25:14 <piyush-kurur> and like every other language writing fast programs for certain tasks can be inherently difficult
23:25:28 <pacak> If you want to achive good performance - haskell won't stop you.
23:25:28 <wz1000> sveit: That will mainly depend on the semantics of your language.
23:25:45 <pacak> Your skills in it might though.
23:25:52 <jared-w> Haskell offers the highest correctness guarantee of those I listed, and Rust is the second. But the main point here is that the language and how you implement the compiler matter more than what language you pick to write it in
23:27:15 <sveit> ok, thanks! i guess i can be more specific though. i have only written small "toy" compilers (in Haskell in fact, but it doesn't matter). i was wondering if for larger-scale compilers that perform more optimization or typechecking the ability to directly manage memory/data structure memory layout is important, or if people here have not found that to be the bottleneck.
23:28:46 <jared-w> I don't see why that would even become a consideration because once you write the compiler, it's a binary...
23:29:00 <piyush-kurur> sveit: I would say the opposite. Often compilers involve many symbolic operations. Algebraic data types and stuff like that which are the bread and butter of Haskell can be expected to perform better and their "simulations" in a weaker language like C
23:29:26 <EvanR> haha, in haskell we have real ADTs not simulations
23:29:49 <EvanR> import Forms.Platonic
23:30:11 <jared-w> nice reference, EvanR, your references are outta control
23:30:36 <cocreature> make your compiler fast or make the code it outputs fast, choose one :)
23:30:42 <sveit> jared-w: what? of course the compiler is a binary. but it tends to be written in a programming language that might or might not be close to hardware (C vs Haskell). i am wondering if this is, practically speaking, important specifically in the domain of compiler writing
23:31:38 <piyush-kurur> sveit: the short answer is no if you know the trick of the trade
23:31:44 <sveit> cocreature: if you follow a guy named Jonathan Blow, he claims to have made a fast compiler tha toutputs very performant code
23:31:50 <jared-w> Why would that matter? Suppose you write a compiler for lambda calculus. No matter what language you write it in, it compiles lambda calculus. Your parser, and all the other steps of the compiler are written using standard bread and butter algorithms for the different stages
23:31:55 <EvanR> i noticed GHC is not using Strings or Text for the most part, but a "Fast" version of string which is a hash indexed cached blob of bytes
23:32:04 <EvanR> sounds a lot like what id expect in GCC
23:32:29 <jared-w> EvanR: Yeah, it predates ByteString and they bolted ByteString into it as much as possible, iirc
23:32:54 <cocreature> sveit: afaik he hasn’t released anything so far so I’m not sure I buy that claim. obviously there is always the option to rely on the programmer for doing optimizations so your compiler doesn’t need to
23:33:25 <EvanR> jonathan blow? braid? is a compiler person?
23:33:38 <EvanR> (currently waiting for this damned cloud to move to the left in braid)
23:33:56 <cocreature> jonathan blow went down the “everything sucks, I’m going to write my own language and compiler” road
23:33:57 <jared-w> Oh right, Jonathan Blow's compiler. Personally I don't have a whole lot of stock in that. Looks too much like hype-training on some nonsense that isn't going to hold water in the real world
23:34:19 * EvanR welcomes jonathan blow to the club
23:35:53 <sveit> well he does have an example application (a game engine) at least partially written in that language. anyway, i don't claim to know much about it, i just used it as an example of a very performant compiler that at least allegedly does some amount of optimization to a relatively complicated language
23:36:08 <cocreature> if your compiler just does a single walk over your ast and emit code it’s probably going to be quite fast but you can’t do a lot of fancy optimizations in that case
23:36:46 <EvanR> haskell does require optimizations before it becomes even remotely performant
23:37:22 <EvanR> graph reduction isnt that fast
23:37:43 <jared-w> Also, C++ is considered a cannonical example of "slow as mollasses compiling"
23:37:56 <piyush-kurur> sveit: Are you talking about the performance of the compiler or the performance of the compiled code?
23:37:58 <jared-w> But if you look at it, line by line of code, it's a pretty damn fast compiler
23:38:05 <cocreature> it’s not so bad. in my experience the difference between -O2 and -O0 is something like 3x if you’re lucky which I’ll usually happily trade for faster compile times
23:38:07 <EvanR> you could output dumb-as-hell imperative code from some other language that maps directly to what we think of as standard assembly
23:38:26 <EvanR> and it would not be as slow
23:38:55 <sveit> ok, i mean i just wanted to know if the bottleneck for large compilers is the overall algorithm or whether the details of the implementation, memory layout/cache locality, etc. (other low level details) are the main factors in performance in realistic projects, but it seems the prevailing opinion here that, for a compiler written in Haskell, the performance will indeed be limited by the algorithm and within 1-2x of an equivalent
23:38:55 <sveit> compiler written in a lower-level language.
23:39:28 <sveit> piyush-kurur: i am talking about the performance of the compiler, but in my particular case i am interested in an optimizing compiler, so there is some non-trivial stuff going on during compilation
23:40:10 <EvanR> .oO( compiler that outputs self optimizing code... starts slow then finishes the job later ) :)
23:40:11 <jared-w> Ok. You write a compiler in language A that takes language B and compiles it to machine code
23:40:12 <cocreature> sveit: Haskell also does give you a reasonable amount of control over memory layout via unboxing
23:40:33 <jared-w> The speed and properties of language A has absolutely nothing to do with language B in any way or shape or form
23:41:08 <jared-w> The performance of the compiler for language B is completely disconnected from language A in every way.
23:41:14 <LiaoTao> sveit: You can try to find some profiling results for GCC or some other compiler and see what takes the longest when compiling
23:41:18 <LiaoTao> Not sure if GHC has something similar
23:41:45 <LiaoTao> From that data it should be quite clear where your performance concerns should be placed
23:42:20 <sveit> jared-w: i've tried explaining it several times. i care about the performance of the compiler itself, which obviously can depend on language A since that is the language it is written in. i feel i have been clear on this point.
23:42:54 <jared-w> No, you haven't. What "performance" metric do you care about?
23:43:01 <unknownln> jared-w I don't understand where you're coming from - if I chose pure python over say, C++, the performance of the compiler definitely does depend on the language choice. The python one will be much slower
23:43:06 <sveit> jared-w: build times
23:43:14 <jared-w> The efficiency of the code generated by the compiler which compiles language B is completley, 100%, utterly independant of language A
23:43:34 <EvanR> were talking about build times
23:43:40 <unknownln> jared-w he doesn't care about though. He wants his compiler to compile fast
23:43:50 <jared-w> The build time of the compiler is completely, 100%, utterly indpendent of language A and relies 100% on algorithms chosen, optimizations you choose to do, and what language B is
23:43:58 <EvanR> not build time of building the compiler
23:44:05 <EvanR> haha
23:44:11 <sveit> EvanR: :)
23:45:01 <vtomole> How many LOC is GHC?
23:45:01 <jared-w> Well, I should say more like 90%... I doubt a compiler written in JavaScript will be super fast. But either way, the point stands
23:45:20 <mauke> jared-w: I think you're wrong
23:45:29 <LiaoTao> jared-w: I think it'd be wise to not give estimates
23:45:42 <LiaoTao> Clearly, Python programs are slower than C programs
23:46:06 <jared-w> That's efficiency of compiled code and not speed of compiling, though
23:46:40 <LiaoTao> If you write a compiler in C it'd compile things faster than an equivalent compiler written in Python.
23:46:42 <jared-w> sveit has said they only care about speed of compiling, which is so drastically reliant on the other factors that the choice of language A is almost entirely inconsequential
23:46:43 <mauke> turn runtime into compile time by writing your compiler in a language
23:47:11 <sveit> jared-w: if you were right that would indeed be the answer to my question, i just think you're answering the question as though the answer is obvious, which it's not to me. idiomatic, and even performance-tuned haskell is often much slower than C, for example, for numeric or bit-twiddling code.
23:47:22 <merijn> It's trivial to get fast compilation if you throw out every single optimisation
23:47:38 <mauke> merijn: it gets even faster if you throw out correctness
23:47:56 <LiaoTao> :D
23:48:04 <LiaoTao> Who cares what it does? It's fast!
23:48:05 <merijn> Define "much slower", almost every single popular language isn't doing better than Haskell
23:48:13 <merijn> mauke: Yes, I knew you know C already ;)
23:48:15 <EvanR> its gets really fast when you throw out all results!
23:48:18 <jared-w> return 4 -- my favorite compiler
23:48:34 <mauke> merijn: :-)
23:48:36 <LiaoTao> EvanR: Now you're thinking without side effects!
23:48:41 <EvanR> right
23:48:56 <EvanR> pure code is indistinguishable from nothing
23:49:02 <EvanR> should be exploited
23:49:07 <LiaoTao> Haskell Zen
23:49:24 <sveit> ok. maybe i should re-ask for clarity. my question was: i am writing a compiler. i have written small toy compilers in Haskell before, and i'd like to use it for this larger compiler (which would do optimization but minimal typechecking). my concern is that i would like fast build times, and i was wondering if people here knew whether choosing haskell means very long build times.
23:49:44 <cocreature> sveit: it doesn’t :)
23:50:00 <LiaoTao> Not necessarily, no. You _can_ make Haskell fast.
23:50:16 <pacak> sveit: Use Haskell.
23:50:32 <mauke> I've written a fast/stupid compiler in perl. I doubt haskell is going to slower
23:50:39 <sveit> ok, great, it seems like no one has serious objections :) i'll try it out. thanks for all the discussion
23:50:48 <mauke> +be
23:50:59 <merijn> sveit: It's almost like people ahve written insanely big compilers in Haskell before... ;)
23:51:05 <EvanR> i hope you werent hoping #haskell would try to disuade you from using haskell :)
23:51:23 <sveit> no, but people here usually give very realistic expectations
23:51:24 <pacak> If ghc can give me some really useful feature in exchange for compilation time twice as long -  I'll take it.
23:51:43 <jared-w> pacak: my favorite feature is this weird new-fangled thing called a "useful type system"
23:51:59 <merijn> To be fair, the type system doesn't make compilation slow
23:52:01 <EvanR> as long as i can disable it
23:52:02 <sveit> merijn: i was worried because i heard lots of grumbling about GHC build times in fact. it /does/ take longer to compile than i'd like my compiler to run, but it does do a lot of work
23:52:21 <EvanR> oh
23:52:23 <unknownln> sveit if you want some other compilers written in Haskell to compare for speed, I believe purescript's compiler is Haskell? And some others I forget
23:52:28 <merijn> sveit: Right, GHC is slow not because Haskell, but because compiling Haskell + tons of extensions is *hard*
23:52:34 <pacak> jared-w: any strict/static type system will be more useful than let's say javascript.
23:52:42 <EvanR> ghc is slow... youre talking expected build times of YOUR compiler...
23:52:44 <merijn> jared-w: Incidentally, type checking takes basically zero time
23:53:06 <jared-w> sveit: that's building the compiler for language B. The performance of that compiler is completely independent of Haskell buildtimes
23:53:09 <merijn> Pro-tip for fast development: "ghc -O0 -fno-code" for super fast typechecking :)
23:53:26 <pacak> merijn: ghcid. The same but in realtime.
23:53:28 <unknownln> Ooo thanks
23:53:30 <sveit> jared-w: i know, i am just using GHC as an example of a large compiler, written in haskell, that has long build times
23:53:40 <EvanR> i would guess your compiler will be much faster
23:53:53 <EvanR> done right
23:53:56 <pacak> ghc can be slow if you ask it to do  stupid things - like asking to derive generic instance for a data type with 10 constructors 300 fields each....
23:54:14 <jared-w> GHC has long build times because it's fighting 25+ years of cruft, changing standards, cobwebs, and so on. Plus, people do things like pacak said surprisingly often :p
23:54:20 <merijn> pacak: I use hdevtools, but yes
23:54:29 <sveit> merijn: thanks, that is basically the answer i was hoping to hear :)
23:54:55 <pacak> merijn: Yea, those as well.
23:55:08 <sveit> jared-w: ok, that's what i was hoping :)
23:55:32 <jared-w> good luck on your compiler
23:56:13 <sveit> anyway, thanks for the discussion, sound like Haskell won't box me into a build-time performance corner. as usual nothing beats actually trying it though :)
23:56:21 <pacak> (btw, that stupid generic instance was replaced with TH code that generates the same stuff - compilation time went down from ~10 minutes for a module to less than a minute.
23:57:18 <EvanR> generic is slower than TH? :(
23:57:28 <pacak> EvanR: yep.
23:57:37 <unknownln> That's quite surprising, any idea why?
23:57:40 <EvanR> why??
23:57:50 <sveit> pacak: that's terrifying, i'm shooting for build times ~ O(1) sec
23:57:59 <pacak> it's O(n^(2+ something)) to number of fields.
23:58:07 <pacak> cubic or something
23:58:15 <merijn> Yeah, large number of fields is a known issue that was being worked on
23:58:50 <pacak> sveit: for 1 line of code? for 10? 500k?
23:58:59 <mauke> "yes"
23:59:39 <cocreature> O(1) means that the code you output can’t depend on the length of the input which seems really unlikely
23:59:52 <cocreature> you can’t even parse the input in that case
23:59:58 <jared-w> Also, sveit, the O(n^(2+x)) to fields is completely irrelevant to the compiler you would be building
