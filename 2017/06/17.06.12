00:01:11 <cocreature> when I care about the indirection of [] I usually try to shove my code into an unboxed vector so that argument rarely matters for me
00:01:38 <merijn> cocreature: Arrays as universal datastructure \o/ ;)
00:01:48 <EvanR> geez
00:02:09 <EvanR> ive almost had enough with storable mutable vectors
00:02:20 <cocreature> merijn: all your cache efficiency are belong to us!
00:03:36 <merijn> Rule #1 of HPC is: arrays are the universal data structure
00:03:54 <merijn> Rule #2 of HPC: Your efficient/optimal algorithm is shit, just use an array
00:04:10 <merijn> Rule #3 of HPC: Behind every bottleneck is a new bottleneck :p
00:04:29 <merijn> Rule #4: Did I mention arrays are the universal data structure? :p
00:04:37 <cocreature> it’s bottlenecks all the way down
00:04:56 <geekosaur> the bottle is all neck
00:05:17 * EvanR instructs GHC to transparently compile all the algebraic types to arrays
00:05:46 <merijn> cocreature: I used to have some code which had turn multiple unsorted network inputs into a sorted one. Original implementation: 1 heap per network connection, incrementally build heaps as data comes in, perform a multiway merge at the end, using heap's O(1) min element
00:06:35 <merijn> The 2 orders of magnitude faster solution: Prefix each network input with the number of elements. Preallocate and array. Write unsorted data to non-overlapping segments of the array. Sort at the end.
00:06:43 <merijn> s/and array/an array
00:08:51 <merijn> An a completely unrelated note: Is there a way to make Haddock display the documentation of a re-exported module inline, rather than emitting a link to the original modules docs?
00:09:09 <merijn> (Without exhaustively listing said re-exports, that is)
00:24:05 * hackage aivika-experiment 5.0, aivika-experiment-chart 5.0, aivika-experiment-cairo 5.0, aivika-experiment-diagrams 5.0 (DavidSorokin): https://qbin.io/cq0qe487
00:34:57 <saurabhn_> how can one construct an arbitrary-length nested tuple of shape (a, (b, (c, (d, ()))). The most obvious recursive function is not type-checking. https://gist.github.com/saurabhnanda/342157315b889260c15a2152c6f02fcf
00:36:02 <jg_> which haddock version is hackage using anyway? I noticed my source output is broken on 2.17.3 (quote highlighting), looks fine on hackage though. Is there a way to change the haddock version used by stack?
00:39:25 <jg_> ah, maybe i just need to switch the binary
00:39:34 <Taneb> Is data DelayT m a = Delay (m (DelayT m a)) | Now (m a) or something like it defined anywhere
00:39:53 <dibblego> Taneb: it is almost Free
00:41:54 <Taneb> dibblego, it's closer to FreeT Identity
00:42:03 <dibblego> that's Free :)
00:42:24 <Taneb> No, FreeT f Identity is Free f
00:42:51 <dibblego> ok yeah
00:43:10 <Taneb> FreeT Identity is something else slightly and may be roughly what I want
00:54:12 <merijn> Anyone aware of a conduit library that runs a pipeline stage async/in parallel? i.e. I have elements coming in and I want to process N elements at a time and output them in whatever order processing finishes?
01:03:13 <saurabhn_> I've officially given up on getting generics to work on my own. Please help me with https://stackoverflow.com/questions/44494286/how-to-write-a-generic-function-that-can-serialise-deserialize-any-record-from-a
01:17:08 <bluebaron> Does this channel accept beginner questions about category theory or is there a better place for such things
01:18:09 <mlehmk> there is a #haskell-beginner as well, though so far I haven't seen questions rejected in here
01:18:12 <merijn> bluebaron: I always ask mine here :p Although the luck with answers depends on whether the math guys are here
01:18:30 <merijn> mlehmk: I'm pretty sure category theory is completely unsuited to #haskell-beginners :p
01:18:48 <mlehmk> looks like this is the right place then?
01:19:22 <Taneb> bluebaron, there's ##categorytheory but it's quite quiet
01:19:29 <bluebaron> So, I've been having a hard time understanding some of the most basic categories, such as Set, and I'm just now considering whether an ambiguity in English is the cause of this strife:
01:19:48 <piyush-kurur> saurabhn_: your question is not okey for the following reason. what should gMapTo foo do when foo is a record with field biz : SomeNonStringType 
01:20:58 <bluebaron> Here https://en.wikipedia.org/wiki/Category_theory it describes the morphisms in Set as functions from one set to another. Does this mean a morphism in set represents all the functions from the source set to the target set? Or are there multiple morphisms, one for all such functions?
01:20:58 <mlehmk> ahh, not category theory then?
01:21:00 <piyush-kurur> Generic makes sense if you have something to do for every type.
01:21:28 <merijn> bluebaron: Multiple morphisms, one per function
01:21:50 <merijn> bluebaron: Think about the following: How many implementations can you think of for the type "Int -> Int"?
01:22:09 <saurabhn_> piyush-kurur: from a pragmatic standpoint I'm fine if throws a runtime error. But, if a solution can provide compile-time guarantee against such an error, even that's fine.
01:22:17 <merijn> bluebaron: One thing that is left implicit in many texts (which screwed me up for a LONG time) is that morphisms have an identity
01:22:34 <merijn> bluebaron: That is, you can have many different morphisms "X -> Y"
01:22:35 <bluebaron> merijn: I'd wager |Int| ^ |Int|
01:22:42 <merijn> bluebaron: Pretty much, yes
01:22:56 <bluebaron> merijn: that much I am aware of, there is a diagram in specific that's been worrying me about this definition
01:23:15 <saurabhn_> piyush-kurur: also, if that means one has to have an instance of a typeclass called `FromMapValue` for this to work, even that's fine.
01:23:49 <saurabhn_> piyush-kurur: so, for example, if we don't have a way to convert String -> Time, then either runtime OR compiletime error -- both are acceptable solutions.
01:24:05 <bluebaron> See here: https://en.wikibooks.org/wiki/Haskell/Category_theory in the first exercise
01:24:22 <piyush-kurur> saurabhn_: generic will give you ways to destruct the type and tell you which constructor is applied and what are the components. What will you do on the components ?
01:24:40 <saurabhn_> piyush-kurur: because, in reality there will be a simple roundtrip test (quickcheck or hunit) to make sure that serialisation/deserialistion is working as expected. So, even runtime errors will get caught very easily.
01:24:55 <merijn> bluebaron: What's the worry?
01:25:36 <mniip> merijn, one thing that I felt was eluded from the texts I've read,
01:25:53 <saurabhn_> piyush-kurur: if the components are something that the generic function can handle, then is should compile, right? assuming that this is something that can be done at compile-time. Else runtime error is also fine.
01:25:57 <mniip> was the implication that morphism equalities are very important to us in a categorical context, while object equalities not so much
01:26:22 <merijn> mniip: Objects can't be equal, afaik
01:26:27 <bluebaron> merijn: I guess I haven't built up my intuition enough yet to understand how that's not a category. If A and B are types in Haskell, that is to say objects of the category Hask, then there are (to me, apparently) many such morphisms from A to B in both directions
01:26:28 <mniip> sure can
01:26:34 <mniip> just that we usually don't need them to be
01:26:40 <piyush-kurur> saurabhn_: it is not a question of errors. Let me give you an example
01:26:58 <merijn> bluebaron: Maybe I'm looking at the wrong exercise, which one are you referring too?
01:27:14 <mniip> bluebaron, what isn't a category?
01:27:14 <merijn> mniip: What's your definition of equality for an object?
01:27:19 <piyush-kurur> Let us say you want to write something like get the tree structure of the data. You can do that with a generic funtion
01:27:25 <mniip> merijn, depends on the category
01:27:36 <mniip> much like morphism equality
01:28:03 <bluebaron> merijn: "(Harder.) If we add another morphism to the above example, it fails to be a category. Why?"
01:28:15 <mniip> in Set, equality is obviously the ZF set equality
01:28:23 <merijn> bluebaron: Well, that means introducing a new <= relation, right?
01:28:35 <mniip> X = Y \iff \forall x. (x \in X \iff x \in Y)
01:28:35 <piyush-kurur> because all you are doing is checking if it is a primitive type (in which case you will create a leaf node) or if it is a constructor then a node with the constructor as the label and its children
01:28:38 <merijn> bluebaron: Except you forgot to add the corresponding transitive morphisms!
01:29:27 <merijn> mniip: But that'd mean they're equal up to isomorphism, no?
01:29:47 <mniip> set equality is stronger than categorical equality
01:29:52 <mniip> Z is not N
01:29:55 <piyush-kurur> saurabhn_: What I am saying is that your gFromMap will need some way to know how to convert a record field into your map of strings
01:29:58 <mniip> despite being equicardinal
01:30:30 <piyush-kurur> saurabhn_: As a first step therefore write a function that will just convert a generic primitive type (i.e. Int, String) etc into string
01:30:36 <mniip> R^3 is not R*R*R despite being equidimensional
01:30:58 <piyush-kurur> saurabhn_: The function can just return an error if it is not a basic type
01:31:08 <mniip> (the latter example being from Vect)
01:31:17 <saurabhn_> piyush-kurur: on a call -- might take some time to respond to your messages.
01:31:38 <piyush-kurur> saurabhn_: am going for lunch see you after than
01:31:46 <bluebaron> merijn: Hm. I'm trying to understand. My brain is probably emitting some pretty gnarly fumes, give me a second
01:32:49 <merijn> bluebaron: Suppose I add a new relation "3 <= 5", then to satisfy the composition laws we would also expect the "2 <= 5" to exist, (since "2 <= 3" exists), but we didn't add a "2 <= 5" morphism
01:33:40 <ertes-w> i really wish 'uncons' would be in Prelude
01:35:18 <bluebaron> merijn: I don't think the diagram with the f, g, and h morphisms is actually related to the partial order exercise, I think the "previous example" it's referring to is the diagram immediately preceding it that is the same but without the h morphism
01:36:44 <merijn> bluebaron: The diagram seems unrelated, yes
01:37:52 <mniip> it said "to the above example" though
01:37:55 <mniip> not "excercise"
01:38:03 <mniip> so I guess that is what was intended
01:38:53 <bluebaron> My frustration arises from my inability to see how the inclusion of the h morphism means that it fails to be a category, or rather how if in the category of Hask, morphisms are individual functions between types, this would not also be the case
01:39:43 <mniip> bluebaron, the key is that the 5 arrows pictured are supposed to be the only morphisms that exist
01:41:08 <mniip> this lets you make the observation that it is necessary that h.g = id_B
01:41:11 <mniip> for example
01:41:37 <mniip> (do you understand how that observation was made?)
01:42:42 <bluebaron> mniip: h.g = id_B? if we apply g, then h, wouldn't that be id_A?
01:43:06 <mniip> yes... indeed, I was using opposite composition order I guess
01:43:30 <mniip> yeah I was thinking of g.h
01:43:56 <bluebaron> mniip: But composition order aside, yes, I see how those are equivalent in some sense, as they both have the same source and target object
01:44:07 <mniip> they must be equal
01:44:15 <mniip> since the diagram only includes one arrow from A to A
01:45:34 <bluebaron> mniip: So there's no problem there, right? The exercise suggests the issue arises from the law of associativity not holding, and from having looked up an answer I can see how that's accurate, as h.(g.f) = h and (h.g).f = f
01:45:53 <mniip> therefore h = f
01:46:36 <mniip> which contradicts with having added another morphism
01:46:50 <mniip> there's still only 4 of them
01:47:23 <bluebaron> Okay, that makes sense, thank you for your help so far, because I think this has brought me closer to understanding, but I'm not quiiiite there yet
01:48:24 <bluebaron> So if the h morphism is indeed superfluous, then in the category of Sets, each morphism from one set to another can represent potentially many different functions?
01:49:14 <bluebaron> sorry--in the category Set
01:50:27 <mniip> no
01:50:27 <bluebaron> I'll try to come up with an example and if I can't find one that makes sense then I guess I have my answer
01:51:03 <mniip> in Set by definition each function is one morphism
01:51:10 <mniip> and vice versa
01:52:15 <EvanR> four functions from {0,1} to {0,1}
01:52:32 <EvanR> id, not, const 0, const 1
01:52:44 <mniip> (Hask has more!)
01:53:14 <EvanR> dont believe him
01:53:17 <bluebaron> EvanR: that's a really concise example of something that's confusing me
01:54:02 <bluebaron> EvanR: Those would all be functions [morphisms] with the same source and target object, and yet within the context of the Set category, they're all equivalent to id_\{0,1\}
01:54:09 <mniip> no?
01:54:11 <mniip> they are not?
01:54:15 <EvanR> theyre all different
01:54:25 <mniip> they're four different morphisms
01:54:36 <EvanR> but yeah they have the same source and target, and the source and target happen to be the same
01:54:59 <mniip> nowhere in CT it says that morphisms are same if they have the same source and target
01:55:25 <mniip> some categories have that property but only some
01:55:26 <bluebaron> mniip: my bad--I was trying to extend your "therefore h = f" earlier incorrectly I suppose
01:55:26 <EvanR> maybe youre confused by thinking of each function as a set
01:55:56 <EvanR> and "equivalent" meaning, to you, same number of elements, or something
01:55:59 <mniip> bluebaron, "therefore h = f" had a very specific proof
01:56:08 <mniip> which doesn't extend to the Bool -> Bool case
01:57:03 <mniip> bluebaron, I could draw you the next smallest category on two objects
01:57:56 <bluebaron> mniip: that might help! I appreciate your efforts
01:59:02 <mniip> dammit my touchpad just wants to draw square circles
01:59:41 <bluebaron> I really love the abstractions made possible by functional programming and I want to deeply understand the basis thereof before I really dive in. I just can't yet /see/ how categories /work/ properly, I suppose
02:00:03 <bluebaron> My intuition for them is underdeveloped and the material describing them is necessarily fairly high-level
02:00:06 <merijn> bluebaron: Is your end goal to learn math or to become better at functional programming?
02:00:35 * hackage async-timer 0.1.4.0 - Provides API for timer based execution of IO actions  https://hackage.haskell.org/package/async-timer-0.1.4.0 (mtesseract)
02:00:39 <bluebaron> I feel like those are pretty similar goals
02:00:43 <merijn> bluebaron: Nope
02:00:57 <nutzz> what does (ord a) => a -> a -> Bool mean in haskell?
02:00:59 <merijn> bluebaron: You've fallen for ridiculous misinformation
02:01:00 <bluebaron> But I would like both regardless
02:01:11 <merijn> "Haskell is based on category theory!" <- absolute bogus
02:01:59 <bluebaron> merijn: In any case, I like learning, and this level of abstraction is interesting for me. But I'm also interested in why that is bogus
02:02:01 <EvanR> bluebaron: its nice to understand things formally, or precisely. 
02:02:33 <mniip> bluebaron, http://tcpst.net/foof.png
02:02:39 <mniip> I think so at least
02:02:53 <bluebaron> nutzz: It is a type signature for a function that can take two of any type that can be ordered (it has an instance of the Ord typeclass) and returns a true or false value (a Bool)
02:02:54 <EvanR> side effects may include: detecting the slightest presence of vagueness, lack of real understanding of some phenomenon... and then in your question figure it out youll annoy your peers! mission accomplished
02:03:03 <merijn> bluebaron: Because Haskell's design is pretty solidly based on top of lambda calculus and type theory. Some abstractions have been imported from category theory, but those have been retrofitted to match haskell and have almost no resemblence to the original category theory concept
02:03:11 <bluebaron> EvanR: I agree!
02:03:25 <EvanR> s/question/quest/
02:04:17 <bluebaron> merijn: I've been reading a lot about all of those as of late, really. I took a class on programming languages and compilers last semester that was mainly in Haskell, though I've been programming since I was very young and [programming] languages have always been a special interest of mine
02:04:18 <mniip> bluebaron, oh yeah I guess I also need to specify r.r=id_A
02:04:19 <merijn> bluebaron: Don't get me wrong. I think category theory is interesting and I keep looking into it. But in terms of practical application to writing haskell it's pretty much useless until you're *well* into the expert haskell programmer stage and even then it's not the end all, be all
02:04:45 <mniip> or maybe it follows from the laws
02:04:54 <merijn> bluebaron: Ah! If your interest is programming languages (and, I'm assuming type theory, etc.) I've got a FAR more interesting and accessible thing for you :)
02:05:24 <mniip> inb4 HoTT
02:05:38 <merijn> bluebaron: Grab a copy of Pierce's "Types and Programming Languages", it starts with untyped lambda calculus and incrementally builds more complex type theories/type checkers on that
02:07:06 <merijn> bluebaron: It's written for (under)graduate students, so there's almost no required background knowledge (familiarity with lambda calculus and typed PLs is a plus, though). And halfway through that back you should know enough to implement a Haskell (Haskell2010, not all GHCs insane extensions) type checker without too much effort
02:07:18 <bluebaron> merijn: Thanks! I'll look into that for sure.
02:07:53 <bollu> quchen: ping
02:08:09 <merijn> bluebaron: If you're more interested in formal reasoning about programs (e.g. proving things correct, etc.) there's another excellent book "Software Foundations" (co-authored by the same Pierce), which goes into that.
02:08:20 <merijn> bluebaron: As a bonus the last one is free and has lots of exercises
02:08:21 <merijn> @where sf
02:08:22 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
02:08:22 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
02:08:24 <merijn> @where tapl
02:08:24 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
02:09:14 <merijn> bluebaron: There's also Bartosz' "CT for Programmers" blog series: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
02:09:21 <bluebaron> mniip: So does closure under composition mean that for any morphisms f: B->C, g:A->B there must be a /unique/ morphism h such that f.g = h?
02:09:33 <mniip> yes
02:09:35 <bollu> cocreature: dang, I wasn't at zurihac on sunday
02:09:38 <bollu> was under the weather :(
02:09:49 <mniip> . is necessarily a "function"
02:09:54 <merijn> bluebaron: Unique up to isomorphism, yes
02:10:04 <mniip> merijn, ???
02:10:06 <bluebaron> ohohoh
02:10:26 <mniip> I think that was one of the cases where "up to iso" is not right
02:10:35 <merijn> actually, lemme think
02:11:41 <merijn> Well, I suppose it depends on how means "unique"
02:11:55 <merijn> bluebaron: What do you mean by "unique" there?
02:11:59 <bluebaron> merijn: Insofar as what my interests are presently, I think I've been trying to get a better grasp on how (perhaps poorly or "bogus"-ly) category theoretical concepts have been applied to Haskell in order to have more expressive abstractions for computation
02:12:14 <bluebaron> merijn: Honestly I'm still a bit shaky on that myself, trying to grok it
02:12:51 <bluebaron> merijn: I think I downloaded a copy of Category Theory for the Working Mathematician, maybe that would have a precise specification
02:13:35 <bluebaron> merijn: When you say "unique up to isomorphism," what do you mean?
02:13:56 <EvanR> bluebaron: er, closure doesnt have anything to with uniqueness, closure means the operation gives you a result of the proper type, not same wacko other thing like sqrt(-1) does
02:14:04 <mniip> bluebaron, many things in CT happen to be unique up to a unique isomorphism
02:14:19 <EvanR> bluebaron: the uniqueness is implied by the fact that the operation is a function
02:15:09 <EvanR> composing two arrows gives you some arrow, an arrow, 1 arrow, "the" result
02:15:14 <EvanR> its not a multifunction
02:15:29 <bluebaron> EvanR: Oooooh
02:15:39 <bluebaron> EvanR: I think that may have reaaaally helped
02:15:44 <merijn> bluebaron: That's at the point of my understanding where I don't know how to adequately explain it
02:16:12 <EvanR> you dont need isomorphisms to get this particular point
02:16:16 <bluebaron> merijn: That's okay! You've helped a lot so far
02:17:00 <bluebaron> merijn: I just bookmarked that blog, looks like it'll be excellent
02:17:45 <EvanR> also note that you get *some* answer as opposed to none
02:17:51 <EvanR> unless division by zero
02:17:58 <EvanR> unLIKE... division by zero
02:18:33 <EvanR> closure is one of those things you stop explicily saying when you instead start putting types on all your operations
02:18:43 <EvanR> :t (.)
02:18:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:19:24 <EvanR> the answer has type c... saying its closed would be redundant, because if its not closed that type would be wrong
02:20:00 <EvanR> that just an example
02:20:11 <EvanR> :t mappend -- another example
02:20:13 <lambdabot> Monoid a => a -> a -> a
02:20:34 <bluebaron> I should note that a lot of this recent spur into category theory (though I've been dwelling/reading on it for some months now) came from the inability to grok Free monads
02:20:35 <EvanR> mappend is "closed in a" ... 
02:21:12 <EvanR> monads in general are pretty advanced topic in CT, it seems to me
02:21:28 <EvanR> monads in haskell are not hard
02:22:01 <bluebaron> Well, one blog post was trying to introduce them by starting out with a type that was 'the fixed point of a functor'
02:22:06 <mniip> but monoids in endofunctor categories?
02:22:52 <EvanR> fixed points is another advanced topic
02:22:57 <EvanR> in computer science
02:23:16 <bluebaron> I've already read about the Y combinator and I'm familiar with at least some basic examples in math
02:24:08 <EvanR> probably an easier way to do a free monad is to look at other free constructions first
02:24:34 <bluebaron> I was unaware of such concepts but that's a good roadmap to have 
02:26:44 <EvanR> see also universal properties... which ought to be the thing on page 1 of category theory
02:27:19 <bollu> EvanR: the natural way to describe "free X" is as the initial object in the X algebra right?
02:27:26 <bollu> in the category of X-algebras*
02:27:55 <EvanR> where X is a functor
02:28:46 <EvanR> that will give you a free thing if you can express it as an F-algebra signature
02:29:20 <bollu> yes
02:29:32 <EvanR> but theres also the free-forgetful functor adjunction
02:29:34 <bollu> but, you can express any algebra that way
02:29:36 <bollu> ah, right
02:29:41 <nutzz> how would you write a function that duplicates elements on even indexes in haskell?
02:30:45 <mniip> bluebaron, I'm trying to make a simple description of a 2-object 8-morphism category but it's escaping me :v
02:31:09 <bluebaron> nutzz: how would you write a function that removes every other element?
02:31:19 <EvanR> just draw a diagram, or a quiver !
02:31:51 <EvanR> and complete any paths
02:32:41 <bluebaron> mniip: It'd certainly be of nonzero use to me but if you'd rather be doing something else I wouldn't blame you if you gave up haha
02:33:06 <EvanR> why do you need 8 morphisms
02:33:28 <mniip> it's the smallest after 6
02:36:34 <EvanR> sounds like bluebaron should do it ;)
02:37:18 <mniip> see if you can figure out how composition works here http://tcpst.net/b8_4.png
02:37:31 <mniip> there's only one way to do it, up to relabeling
02:37:35 <EvanR> when i was mucking around with small lattices, quickcheck helped me prove it by exhaustion
02:38:18 <bollu> GHC build is breaking for me on Mac OS with apple clang: https://pastebin.com/38RWnCDz. Has anyone seen the error "error: editor placeholder in source file"?
02:38:20 <mniip> this category probably has a name
02:39:29 <merijn> bollu: Which macOS version and which GHC version?
02:39:49 <mniip> does the category used in an equalizer's limit definition have a name?
02:40:09 <mniip> this would be (1 + 1)^that
02:40:29 <mniip> errr
02:40:30 <mniip> no
02:41:17 <bollu> mero: mac OS sierra, GHC 8.0.2. clang 5.0.0
02:41:21 <bollu> merijn: &
02:41:24 <bollu> merijn: ^ damnit
02:42:10 <merijn> clang 5.0? That sounds...odd?
02:42:21 <bluebaron> mniip: okay so I'm not as far ahead as I thought I was, lol. I'm confused
02:42:26 <merijn> Or did you mean XCode?
02:42:50 <bluebaron> mniip: How is one able to tell if b_0 . a_0 is the same as r_A or id_A?
02:43:17 <mniip> if you pick one, the rest of the puzzle solves itself
02:43:36 <mniip> I think
02:43:39 <mniip> ;)
02:44:19 <EvanR> bluebaron: this is like filling in a multiplication table for a small group. there might be more than one way for a given size group
02:44:52 <EvanR> more than one way that is essentially different, and not just renaming everything
02:45:04 <mniip> for this one I think there's exactly one
02:45:07 <mniip> up to renaming
02:45:45 <EvanR> well i came up with more than one but didnt check assoc
02:46:01 <EvanR> brain overload
02:46:32 <bluebaron> EvanR: seconded
02:46:59 <EvanR> a1 . rB = a1, or a0
02:47:30 <EvanR> rB . rB = rB, or idB
02:47:52 <mniip> if a1 . rB = a1 you get a contradiction methinks
02:49:39 * EvanR gets a spreadsheet
02:49:53 <mniip> yeah I did that too
02:50:37 <bluebaron> mniip: that would imply rB = idB right?
02:50:55 <mniip> not in the obvious way
02:51:03 <EvanR> according to the diagram, rB and idB are different
02:51:16 <EvanR> maybe that is the contradiction
02:51:25 <bluebaron> that's what I thought
02:53:40 <bluebaron> ugh, it's almost 5am here. I guess I should go, lol
02:54:51 <bluebaron> thanks again for all this
02:55:09 <EvanR> me too
03:00:00 <saurabhnanda> piyush-kurur: you around? I'm back. Calls over.
03:00:13 <piyush-kurur> yeah
03:00:22 <mniip> maybe I was wrong after all
03:00:41 <EvanR> mniip: heres my table, not filled in will stuff thats not obvious http://i.imgur.com/kfVZDKz.png
03:00:50 <EvanR> with
03:00:54 <mniip> well that's the obvious part
03:01:21 <EvanR> well at least now its not just in my brain
03:01:30 <EvanR> only 18 more choices to go
03:02:29 <EvanR> hm. though this sheet doesnt help you with possible choices in each cell
03:05:03 <EvanR> heres one of my fill ins http://i.imgur.com/TO8ur0p.png
03:05:38 <saurabhnanda> piyush-kurur: so, you were explaining why it isn't possible to write that generic function
03:06:03 <EvanR> rA and rB are no-ops
03:06:18 <mniip> idempotents you mean
03:06:29 <EvanR> they dont do anything
03:06:43 <EvanR> while an idempotent might do something the first time
03:07:09 <piyush-kurur> saurabhnanda: why dont you try writing a version generic function that just converts a basic type (like Int, Double) etc to string (For all other complicated type just gives error. 
03:07:27 <piyush-kurur> saurabhnanda: this is a warmup 
03:07:44 <saurabhnanda> piyush-kurur: wound't that just be `read`?
03:08:03 <EvanR> and a/b composed are identities, they are all isomorphisms
03:08:06 <piyush-kurur> saurabhnanda: I meant using generics to do it (by pattern matching on the types)
03:08:38 <saurabhnanda> piyush-kurur: you'll be around? I might take 15-30 mins.
03:08:51 <piyush-kurur> yeah I will be around
03:09:19 <piyush-kurur> saurabhnanda: actually I guess you see where I going from here
03:09:36 <piyush-kurur> once you have written that you should be able to do the record case
03:12:46 <piyush-kurur> saurabhnanda: actually why are you poking around with generics.
03:12:47 <piyush-kurur> ?
03:12:47 <EvanR> http://i.imgur.com/5NMLDrI.png now rA and rB toggle b and a
03:13:06 <lpaste> lamefun pasted “OOP finally possible?? Is there a better syntax?” at http://lpaste.net/356178
03:13:20 <piyush-kurur> As far as I know libraries like Aeson gives you all the generic routines to generate JSON
03:15:12 <EvanR> ok i see a problem with both tables... (a0 . b0) . a1 = id . a1 = a1, but a0 . (b0 . a1) = a0 . id = a0
03:15:37 <Maxdamantus> Where did you get that magic hash from?
03:17:22 <saurabhnanda> piyush-kurur: https://www.reddit.com/r/haskell/comments/6gm9eo/ghcgenerics_is_the_modern_way_and_it_is_much/dis1y11/
03:18:54 <saurabhnanda> piyush-kurur: https://stackoverflow.com/questions/44494286/how-to-write-a-generic-function-that-can-serialise-deserialize-any-record-from-a?noredirect=1#comment75986199_44494286
03:19:10 <Maxdamantus> @hoogle a -> (a -> b) -> b
03:19:11 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:19:11 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
03:19:11 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
03:19:51 <Maxdamantus> lpaste: presumably you could just define an operator as `flip ($)` to make it .. more OOP .. arguably.
03:19:53 <EvanR> i know youre frustrated on this problem, but it does seem like youre trying to jump ahead and "just write code" before groking how to use generics for anything, however simple
03:20:31 <EvanR> i would give you guidance on how to start simple, if i knew more about generics myself
03:20:33 <cocreature> more importantly you’re trying to write code using generics that you haven’t figured out how to write manually
03:21:30 <lamefun> Maxdamantus: I don't care which side the function is at, the only thing I care about is not having to prefix all calls with type name, eg. catTalk or Cat.talk.
03:23:10 <piyush-kurur> saurabhnanda: your database engine should do it (persistant has its way of deriving table types etc) 
03:25:36 <piyush-kurur> saurabhnanda: are you trying to store it as a db row?
03:26:05 * hackage haskus-utils 0.7.0.0 - Haskus utility modules  https://hackage.haskell.org/package/haskus-utils-0.7.0.0 (SylvainHenry)
03:26:32 <piyush-kurur> Or are you trying to use int inside as a column value of a row
03:26:34 <piyush-kurur> ?
03:27:03 <piyush-kurur> s/int/in/
03:27:18 <Maxdamantus> lamefun: well, can't you just write `class Talkable a b | a -> b where talk :: a -> b`?
03:28:15 <lamefun> Yes, I know I can. It's just this doesn't need a class for every method name.
03:28:27 <Maxdamantus> Ah.
03:29:18 <saurabhn_> piyush-kurur: multiple use-cases. My current use-case it for HSTORE <> Record conversion.
03:29:43 <lamefun> And if HasMethod were in base, libraries would be able to define methods without knowing about each other.
03:33:27 <piyush-kurur> saurabhn_: HSTOR means you want to store the value as a JSON val in one of the column?
03:33:46 <piyush-kurur> why dont you generate the JSON instance using Aeson and just use that
03:34:28 <saurabhn_> piyush-kurur: nope, hstore is different from JSON. It has only one-level of text-based key-value pairs. No nesting allowed. 
03:35:26 <piyush-kurur> then why not use JSON DB?
03:35:43 <piyush-kurur> I mean I remeber that postgre allows you to store JSON values
03:36:54 <saurabhn_> piyush-kurur: already using HSTORE. Can't migrate right now due to legacy issues. 
03:37:05 <saurabhn_> piyush-kurur: other code in Rails will also have to be rewritten.
03:37:12 <piyush-kurur> okey
03:37:24 <saurabhn_> piyush-kurur: when we started with HSTORE, JSON support in PG wasn't that great.
03:37:26 <lpaste> lamefun pasted “Nice! Complex expressions work with OOP too!” at http://lpaste.net/356179
03:38:45 <saurabhn_> piyush-kurur: so, is it not possible to write this generic function, or are you helping me with a way to get this done?
03:38:54 <lamefun> Also, does the HasMethod => IsLabel instance hijack HasLabel completely, allowing no other instances?
03:39:04 <piyush-kurur> saurabhn_: it should be possible 
03:39:50 <piyush-kurur> But I do not see how you are going to handle the sum type (not on the Haskell side but on the DB side)
03:39:51 <EvanR> i was really skeptical about seriously using json as a db field
03:40:42 <EvanR> after seriously using json as a db field without any lookup fanciness, and the issues would not have been helped by the db features
03:40:48 <saurabhn_> piyush-kurur: I don't need to handle sum types in this particular use-case. Btw, I already have a nice generic function to convert Enums (sum-types with zero value constructors) to String and back. 
03:41:09 <piyush-kurur> saurabhn_: using generics ?
03:41:13 <saurabhn_> piyush-kurur: yes.
03:41:18 <saurabhn_> piyush-kurur: I didn't write it. I just copy-pasted.
03:41:45 <piyush-kurur> so you are just intersted in record types
03:41:47 <piyush-kurur> ?
03:41:59 <saurabhn_> piyush-kurur: yes -- almost everything in my app is a record type.
03:43:25 <saurabhn_> piyush-kurur: so, how should I start?
03:44:05 <piyush-kurur> If I recall correctly GHC.generics has a way to represent all elements
03:45:05 * hackage haskus-system-build 0.7.0.0 - Haskus system build tool  https://hackage.haskell.org/package/haskus-system-build-0.7.0.0 (SylvainHenry)
03:45:06 <piyush-kurur> liek for example if your type FOO = Bar Int | Biz it would do something like C1 Bar SomethingAboutInt :+: C2
03:45:09 <cocreature> ":kind! Rep MyType" can be really useful to figure out how your type and the information in it is represented in GHC generics
03:45:21 <piyush-kurur> you need to pattern match on the Representation that should be it
03:46:37 <saurabhn_> piyush-kurur: I can wrap my head around all this in the serialisation step. It's the deserialisation which is way over my head. With every single Generic library.
03:46:52 <DexterLB> hello.. I'm trying to read a file line by line, and do a fold on the lines. I have the following code (using conduit): https://bpaste.net/show/71da097492ed but what I get is this: http://rnd.qtrp.org/screenshot_2017-06-12_13-45-38.png
03:47:28 <DexterLB> why is it trying to read the entire file in memory before performing operations?
03:49:12 <cocreature> DexterLB: how many lines does your file have?
03:49:42 <merijn> Non-strict fold, maybe?
03:50:17 <DexterLB> cocreature: several billion
03:50:55 <DexterLB> merijn: ah, this fold is strict on the entire stream, not just the operation?
03:51:07 <piyush-kurur> saurabhn_: okey can you show me your serialisation code
03:51:17 <merijn> DexterLB: No, I meant: are you sure it's strict in the operation?
03:51:35 <EvanR> mniip: ok i think i hammered out the bugs http://i.imgur.com/8obYpFM.png
03:51:58 <EvanR> and i think you can change rA . rA = rA here to = idA
03:52:08 <saurabhnanda> piyush-kurur: here's my latest attempt at the deserialisation code using EOT -- https://gist.github.com/saurabhnanda/be553172e63d3b7e4fcc8fb8f25a9f93
03:52:10 <DexterLB> merijn: the documentation on Conduit.Combinator says: "A strict left fold."
03:52:14 <DexterLB> I suppose that's what it means
03:52:16 <piyush-kurur> The point is that for serialisation you need to get that unique constructor of the type so that you can build the Reptype
03:52:22 <EvanR> this is such an odd ball table... i wonder if it still has a bug
03:52:52 <saurabhnanda> here I'm stuck with how to generate an EOT representation, which is basically a `Left (a, (b, (c, ... ())))` in my case
03:53:48 <piyush-kurur> saurabhnanda: I do not see any DataType etc in Generics?
03:54:07 <saurabhnanda> piyush-kurur: this one is using generics-eot
03:55:25 <merijn> DexterLB: What's the implementation of 'f'?
03:55:47 <merijn> oh, hold on
03:56:04 <merijn> DexterLB: Why are you splitting bytestring into lines and then converting from utf8?
03:56:10 <merijn> DexterLB: That's suspicious as fuck
03:56:24 <merijn> I'm not sure whether that's the actual issue, but I'd certainly rewrite that
03:57:08 <piyush-kurur> saurabhnanda: your types are also instances of typeable is it not?
03:57:33 <saurabhnanda> piyush-kurur: I think EOT required them to be of type Generic and HasEot
03:57:34 <piyush-kurur> the point is that you need a way to get hold of the record names and constructors etc of the elemnt
03:57:43 <piyush-kurur> What is EOT?
03:58:03 <mniip> EvanR, interesting
03:58:16 <mniip> prolog is telling me...
03:58:17 <mniip> false.
03:58:21 <saurabhnanda> piyush-kurur: https://www.stackage.org/haddock/lts-8.16/generics-eot-0.2.1.1/Generics-Eot.html
03:58:45 <saurabhnanda> piyush-kurur: simplest Generics library I've found so far.
03:58:50 <DexterLB> merijn: at first I was decoding first, and then using (Co.peekForeverE Cb.lines ) to split the lines, and I thought this might be causing the problem
03:59:02 <DexterLB> merijn: but it obviously isn't
03:59:03 <merijn> DexterLB: heh
03:59:19 <merijn> DexterLB: Why are you using "Data.Conduit.Binary.lines"?
03:59:41 <merijn> DexterLB: Why aren't you decoding and then using "linesUnbounded" from Data.Conduit.Combinators?
04:00:11 <EvanR> mniip: for the whole thing or my diagram
04:00:12 <merijn> You should split textual data on textual newlines, not splitting it on the byte level
04:00:34 * hackage HaRe 0.8.4.1 - the Haskell Refactorer.  https://hackage.haskell.org/package/HaRe-0.8.4.1 (AlanZimmerman)
04:00:40 <merijn> DexterLB: And peekForeverE is certainly glowing to blow up
04:01:07 <DexterLB> merijn: that's a very good point
04:01:09 <mniip> EvanR, for the whole thing
04:01:14 <EvanR> heh
04:01:26 <mniip> however I can't get it to produce it without helping it aa lot
04:01:34 <EvanR> do you believe everything prolog says!
04:01:35 <merijn> DexterLB: What are doing with those lines?
04:01:44 <mniip> so I can't insure against my help being wrong
04:02:27 <EvanR> does my table match yours
04:03:24 <mniip> mine's transposed
04:03:24 <saurabhnanda> piyush-kurur: any pointers?
04:04:17 <EvanR> i found a bug in the table i posted
04:04:30 <EvanR> b1 . a1 . rB
04:05:23 <EvanR> lesson learned, you cant necessarily turn a random UML diagram into a category!
04:06:08 <EvanR> quickcheck out to show where your table fails
04:06:15 <EvanR> ZZZ
04:09:11 <piyush-kurur> saurabhnanda: here is an example
04:09:54 <piyush-kurur> I defined the type data Foo = Foo String Int 
04:09:59 <piyush-kurur> and here is the representatioin
04:10:36 <piyush-kurur> M1 {unM1 = M1 {unM1 = M1 {unM1 = K1 {unK1 = "help"}} :*: M1 {unM1 = K1 {unK1 = 5}}}}
04:10:36 <piyush-kurur>  
04:12:01 <piyush-kurur> So your types rep would look  like (if it has n fields M1 { unM1 = stuff here }
04:12:34 <piyush-kurur> where stuff here will look like M1 { unM1 = stuff for primitives }.
04:13:03 <bollu> saurabhnanda, piyush-kurur: what is eot in this context?
04:13:13 <piyush-kurur> now I am taking with out eot
04:13:29 <saurabhnanda> bollu: EOT is another generic library built on top of GHC.Generic
04:13:33 <bollu> ah, I see
04:13:53 <piyush-kurur> saurabhnanda: the only thing that you need is to know which record is which position 
04:13:58 <merijn> @hoogle a -> Maybe b -> Either a b
04:13:59 <lambdabot> Control.Error.Safe justErr :: e -> Maybe a -> Either e a
04:13:59 <lambdabot> Control.Error.Util note :: a -> Maybe b -> Either a b
04:13:59 <lambdabot> Data.Either.Extra maybeToEither :: a -> Maybe b -> Either a b
04:14:23 <piyush-kurur> saurabhnanda: I mean you need to know which record field is in which position
04:14:36 <piyush-kurur> So first step is to write it for primitive types
04:14:45 <piyush-kurur> that is things like Int
04:14:54 <merijn> Where is Data.Either.Extra from?
04:15:15 <piyush-kurur> @ to (2 :: Int)
04:15:29 <piyush-kurur> oops how do you get lambdabot to talk?
04:16:45 <saurabhnanda> piyush-kurur: can you do a webinar on this, but using the EOT library? I can market it and get people to pay some money to attend.
04:17:20 <piyush-kurur> saurabhnanda: sorry I do not think that is possible as I myself have to hack this
04:17:36 <piyush-kurur> generics is not something that you use daily
04:19:20 <piyush-kurur> > from (Just (2 :: Int))
04:19:22 <lambdabot>  error:
04:19:22 <lambdabot>      • Couldn't match type ‘Maybe Int’
04:19:22 <lambdabot>                       with ‘Control.Lens.Internal.Iso.Exchange a b a (Identit...
04:20:08 <piyush-kurur> > GHC.Generics.from (Just (2 :: Int))
04:20:10 <lambdabot>  error:
04:20:10 <lambdabot>      Not in scope: ‘GHC.Generics.from’
04:20:10 <lambdabot>      No module named ‘GHC.Generics’ is imported.
04:20:56 <piyush-kurur> saurabhnanda: tough luck lambdabot has no GHC.Generics imported
04:21:46 <saurabhn_> piyush-kurur: can you do a webinar on this, but using the EOT library? I can market it and get people to pay some money to attend.
04:22:35 * hackage text-short 0.1 - Memory-efficient representation of Unicode text strings  https://hackage.haskell.org/package/text-short-0.1 (HerbertValerioRiedel)
04:22:39 <piyush-kurur> saurabhn_: I already replied to you that I cannot
04:22:49 <saurabhn_> piyush-kurur: sorry, was disconnected.
04:22:50 <piyush-kurur> I will myself need to brush up the stuff
04:23:02 <piyush-kurur> generics is not something the people use often
04:23:08 <piyush-kurur> It is not difficult 
04:23:52 <piyush-kurur> just think the the record has n fields then the inner element would look like something :*: something :*: ... 
04:24:12 <piyush-kurur> the something itself would be like the junk you get from types like Int
04:24:20 <piyush-kurur> so you need to pattern match on that.
04:24:44 <piyush-kurur> The only difficult I see is that you need to look at the type and decide the order in which you need to reorient the list
04:25:06 * merijn sighs
04:25:13 <merijn> Linewrapping is hard >.>
04:33:37 * cocreature wraps merijn’s lines
04:36:33 <DexterLB> merijn: I managed to replicate the outcome with a relatively simple f: https://bpaste.net/show/eef2ce86d21b
04:36:50 <DexterLB> it appears that the leftover Text's don't get garbage collected?
04:37:21 <merijn> DexterLB: Strict fold will only be strict on the tuple, there
04:37:38 <merijn> DexterLB: So it keeps all the text in memory to compute the length
04:37:55 <merijn> Should be trivially solved using bang patterns
04:38:18 * DexterLB reads docs
04:38:44 <cocreature> > (undefined, undefined) `seq` ()
04:38:45 <lambdabot>  ()
04:38:51 <cocreature> that demonstrates the problem
04:40:02 <DexterLB> thanks! it worked
04:40:47 <cocreature> often it can also be nice to do something like "data StrictTuple a b = StrictTuple !a !b" and enforce strictness by the data structure instead of placing bang patterns when it’s used
04:41:52 <merijn> Not quite happy with this. Any suggestions how to get these lines less ugly, given that I can't really indent the case less?
04:41:55 <merijn> http://lpaste.net/7513088941164068864
04:43:04 <cocreature> merijn: use the case statement to select between totalTime and stepTime and then apply it to the various args after the case
04:43:20 <merijn> cocreature: Can't, different return types
04:43:44 <cocreature> ah ok
04:46:30 <halogenandtoast> Does anyone know if I can change the table names Yesod uses?
04:48:12 <merijn> halogenandtoast: Yes, but it's not very flexible
04:48:13 <halogenandtoast> basically I want to provide a pluralized table name
04:48:44 <merijn> halogenandtoast: Yesod normally uses persistent. You can override the table naming, but honestly, if you wanna control the table schema persistent seems less than ideal
04:48:47 <halogenandtoast> merijn: yeah I see persistUpperCase and persistLowerCase and persistWith are my options I think.
04:49:08 <halogenandtoast> merijn: is there a better database framework?
04:49:15 <merijn> halogenandtoast: https://github.com/yesodweb/persistent/wiki/Persistent-entity-syntax#changing-tablecollection-name
04:49:28 <merijn> halogenandtoast: opaleye seems nicer, imo, but it only supports Postgres
04:49:45 <halogenandtoast> merijn: that's fine, I only plan on using postgres
04:49:51 <halogenandtoast> there is no other database.
04:49:58 <merijn> halogenandtoast: Then definitely have a look at that
04:50:04 <merijn> halogenandtoast: Sure there is! SQLite!
04:50:08 <halogenandtoast> Oh true
04:50:19 <halogenandtoast> I'm fine with that answer.
04:52:22 <mniip> @tell EvanR I did a full bruteforce https://bpaste.net/show/1935a708283f
04:52:23 <lambdabot> Consider it noted.
04:53:03 <halogenandtoast> merijn: thanks for the info, I couldn't find the persistent documentation must not have googled hard enough
04:53:21 <halogenandtoast> I'll probably keep messing with persistent, but I'll definitely check out opaleye.
04:53:28 <halogenandtoast> especially if I make another spock app.
05:04:33 <mtesseract> Hi. I'm building a webservice in Haskell for which I am using the metrics package (https://hackage.haskell.org/package/metrics). I have an example program here: https://github.com/mtesseract/metrics-test/blob/master/src/Main.hs (11 lines). It marks a meter once per second, but the oneMinuteRate and the meanRate both look very strange (and very far apart also). Would have expected both number to 
05:04:39 <mtesseract> approach one (or at least, to the same number). Does anyone have experience with this package and might know what the problem might be? Thanks!
05:07:18 <clamchowder> question: f <$> [x1, x2] gives [f x1, f x2]. how do i obtain [f1 x, f2 x] if i have a list of functions and one argument?
05:07:50 <merijn> clamchowder: You can use section on ($) :)
05:07:57 <cocreature> clamchowder: ($x) <$> [f1, f2]
05:08:10 <merijn> > map ($x) [f,g,h] :: [Expr]
05:08:12 <lambdabot>  [f x,g x,h x]
05:08:28 <clamchowder> merijn, cocreature: that's cool thanks
05:08:45 <halogenandtoast> Yeah I've seen ($) show up in a lot of neat use cases.
05:08:48 <kuribas> > [f,g,h] <*> [x] :: [Expr]
05:08:50 <lambdabot>  [f x,g x,h x]
05:09:21 <quchen> > map (\ff -> ff x) [f, g, h] :: [Expr]
05:09:23 <lambdabot>  [f x,g x,h x]
05:09:29 <kuribas> :t (<*>)
05:09:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:09:39 <quchen> > [ ff x | f <- [f, g, h] ] :: [Expr]
05:09:41 <lambdabot>  error:
05:09:41 <lambdabot>      • Variable not in scope: ff :: Expr -> Expr
05:09:41 <lambdabot>      • Perhaps you meant one of these:
05:09:42 <quchen> > [ ff x | ff <- [f, g, h] ] :: [Expr]
05:09:44 <lambdabot>  [f x,g x,h x]
05:10:39 <superlinux> hello. which project of the online projects out there which  you can recommend me as a haskell beginner and who has a previous programming experience in Java and C ?
05:11:14 <clamchowder> wah so many ways of doing it
05:11:20 <superlinux> alo add that I have a day job but  I have some spare time too
05:17:26 <mniip> @tell EvanR oh of course. The category I had in mind (the first produced by the bruteforce) is the categorical product of the category from the example by the singleton category induced by the C_2 monoid
05:17:27 <lambdabot> Consider it noted.
05:27:46 <superlinux> hello. which project of the online projects out there which  you can recommend me as a haskell beginner and who has a previous programming experience in Java and C ?
05:28:42 <cocreature> superlinux: I’m not entirely sure what you’re asking for. are you looking for projects that you can contribute to?
05:29:34 <superlinux> yes....sss.. but I am still beginner in haskell but I I am also in my 30's and I know Java and C++ very well
05:30:05 <superlinux> cocreature, clear now?
05:31:02 <superlinux> I need something that gives me confidence in Haskell. I have read 11 chapters of the book learn you haskell 
05:31:29 <quchen> Write a Brainfuck interpreter.
05:31:51 <superlinux> I mean gives me self confidence when I use haskell. 
05:32:12 <quchen> Then extend it to get a HTTP Brainfuck service.
05:32:27 <quchen> Then make it scale so thousands of people can use it concurrently.
05:33:42 <cocreature> webscale brainfuck
05:34:06 <superlinux> what r you taling about? are you trolling?
05:34:42 <ab9rf> heh
05:34:44 <ab9rf> i like that project idea
05:35:14 <cocreature> superlinux: writing a brainfuck interpreter is a nice project to get started
05:36:37 <quchen> I’m not trolling. The project involves writing a parser, transforming the syntax tree, writing a state machine in a functional setting to execute it, writing a webservice, dealing with concurrency.
05:37:02 <quchen> All steps are simple, but very extensible if you like one in particular.
05:37:17 <quchen> Thinking about optimizing Brainfuck is a fairly interesting toy project, for example.
05:37:36 <quchen> Making a parser with great error messages is also something that is often useful.
05:37:57 <quchen> Concurrency is something Haskell is fairly good at.
05:38:06 <cocreature> *shakes fist at GHC’s parser errors*
05:38:20 <quchen> cocreature: Could be worse! Just think about its lexer errors 
05:38:44 <cocreature> quchen: hm maybe I’m confusing the two. I don’t remember which ones are the really horrible ones
05:39:30 <ent> I like the brainfuck project idea, maybe I need to steal it :)
05:39:57 <quchen> ent: It’s meant to be stolen :-)
05:40:07 <quchen> > let
05:40:09 <lambdabot>  <no location info>: error: not an expression: ‘let’
05:40:13 <quchen> > let ;
05:40:15 <lambdabot>  <no location info>: error: not an expression: ‘let ;’
05:40:18 <quchen> That’s a parse error.
05:40:33 <quchen> … or is it? Lambdabot does work a bit different
05:40:40 <quchen> Anyway, I find the lexer errors even worse
05:41:53 <ab9rf> my first "real" haskell project was a cgi assist program that generated jpegs parametrically
05:42:08 <ab9rf> actually might have been pngs, i forget
05:42:33 <quchen> Turns out making up a lexer error is surprisingly hard!
05:43:49 <cocreature> quchen: hm I thought there was some error that only said “parse error” and showed you the location
05:44:06 <quchen> > let foo = '
05:44:08 <lambdabot>  <hint>:1:12: error:
05:44:08 <lambdabot>      lexical error in string/character literal at end of input
05:44:26 <zomg> If I have a BankAccount { currency = USD, amount = 100 }, is there some way I could make a function `withdraw :: BankAccount -> Currency -> IO ()`, which would not typecheck if the code attempted to withdraw, say, CAD?
05:44:39 <zomg> types above only for illustrative purposes :)
05:45:09 <zomg> just messing around with some stuff, not actually doing any real banking.. I get the feeling the question warrants some kind of disclaimer I'm not moving any real money :p
05:47:06 <quchen> data BankAccount cur = BankAccount { currency :: cur, amount :: Int }
05:47:25 <quchen> And then write »withdrawUsd :: BankAccount USD -> IO ()«
05:47:35 <quchen> That won’t typecheck if you try calling it with EUR
05:48:04 <zomg> Yeah figured something like that would work, but it seems a bit clunky if I had to write several different functions for it
05:48:25 <zomg> (plus I could make a bank account with currency = Just "hello" which makes no sense)
05:49:09 <quchen> With DataKinds you could go further and require a type argument that can only be a currency
05:49:23 <quchen> But then you’re venturing into the type extension woods
05:51:38 <zomg> Thanks, I'll take a look at that :)
05:54:33 <superlinux> quchen, i thought you were trolling because of the project nasty name hehe
05:56:15 <quchen> superlinux: Brainfuck is a fairly popular esoteric programming language, you can learn it in maybe 5 minutes
05:56:23 <quchen> It’s hard to use, but computationally extremely simple
05:57:54 <sproingie> never found brainfuck very interesting.  a forth interpreter OTOH would be fun.
05:58:47 <quchen> Finding Brainfuck optimizations was quite interesting for me
05:59:12 <quchen> And then adding primops like [-] -> set-to 0
05:59:27 <quchen> And then optimizing that :-)
06:00:48 <quchen> And when you don’t like that sort of stuff, you can perfectly well use an inefficient interpreter and work with the concurrency part instead
06:01:20 <quchen> Point is, the project touches many important concepts, does not require deep knowledge about anything, but allows using it if the programmer wants to
06:03:28 <Geekingfrog> In the advent of code 2016 there was also a serie of problem with a custom language, and you had to build the interpreter (and then optimize it), with a variant where some operation would modify the program itself.
06:06:47 <sproingie> for me the best thing about brainfuck is how mainstream that name is even in fora where you wouldn't imagine people using such a word :)
06:08:12 <quchen> I’m an adult, I can say »fuck« in public.
06:08:43 <sproingie> does still raise eyebrows in some circles.  not necessarily here of course.
06:09:14 <sproingie> my favorite minimal esolang would have to be unlambda
06:09:58 <quchen> Untyped lambda calculus is also fairly simple, and even somewhat useful
06:11:05 * hackage hills 0.1.2.5 - Generate STL models from SRTM elevation data.  https://hackage.haskell.org/package/hills-0.1.2.5 (djf)
06:25:26 <Reisen> When encoding data families with aeson, it doesn't embed any type tag
06:25:30 <Reisen> When using deriveJSON
06:25:50 <Reisen> Is there a way around this, to get some kind of identifying tag in there?
06:30:26 <lyxia> what's a type tag
06:33:10 <Reisen> data Foo = Foo Int | Bar Char, encode (Foo 3) would be come {"tag": "Foo", "contents": 3}
06:33:20 <Reisen> if I deriveJSON Foo, the tag is added, but not for data families
06:34:06 <Reisen> data family Foo k; data instance Foo Int = Foo Int | Foo Char, deriveJSON for encode (Foo 3) gives me "\"3\"" instead
06:34:28 <Reisen> I guess because It's not obvious how to encode a data family into a tag name, but wondering if It's possible
06:34:49 <lyxia> Foo Int | Foo Char doesn't look very legal
06:34:55 <lyxia> the tag is the constructor name
06:35:02 <Reisen> Foo Int | Bar Char, sorry
06:35:21 <lyxia> that might be a bug
06:37:55 <Reisen> Ok no, you're right, It's fine, I'm just confusing myself a lot here
06:40:20 <Reisen> it would seems what's actually confusing me is I have some records with just one constructor
06:40:31 <Reisen> and there's no option until aeson 1.2.0.0 to force it to tag single constructors
06:40:35 <Reisen> that is annoying...
06:40:46 <Reisen> Sorry about that, my confusion
06:43:35 * hackage streaming-conduit 0.1.2.0 - Bidirectional support between the streaming and conduit libraries  https://hackage.haskell.org/package/streaming-conduit-0.1.2.0 (IvanMiljenovic)
06:51:13 <zomg> I'm quickly coming to a realization that DataKinds goes over my head in more ways than one =) Oh well, at least it was worth reading about I guess
06:53:40 <locallycompact> What do I need to enable to make a type which is basically a record of a string and a type?
06:54:14 <locallycompact> like something something { fieldStr :: String, fieldType :: `Type` }
06:55:49 <zomg> locallycompact: unless I'm completely misunderstanding, wouldn't data MyThing = MyThing { fieldStr :: String, fieldType :: WhateverType } work?
06:56:17 <locallycompact> I want to construct *with* a type
06:56:35 <zomg> ah I think I get it now :) Unfortunately I don't think I have a solution
06:56:48 <locallycompact> like String -> * -> MyThing or something
06:57:08 <lyxia> what are you going to do with that type
06:58:10 <locallycompact> I'm not sure, I'm trying to translate some bad python and I'm just experimenting with representations
06:59:33 <lyxia> That doesn't sound like a Haskell-y thing to do for sure.
06:59:38 <locallycompact> perhaps
07:00:51 <zomg> it might be helpful to understand what data this is supposed to represent
07:01:00 <Reisen> You're trying to store what type the (I assume encoded fieldStr) is right?
07:01:01 <zomg> perhaps someone can suggest a better representation then
07:01:48 <eacameron> locallycompact: You can do that with Haskell, but it's much more intense than you're probably imagining. The reason is that Haskell will expect you to work with types in a provably sound way; which is something that Python programs haven't even dreamed of. But it's non-trivial if you're unfamiliar
07:02:22 <Reisen> eacameron, what does it involve, just out of interest?
07:02:43 <locallycompact> I'm pretty familiar with Haskell
07:02:47 <eacameron> locallycompact: A slightly less intense thing to do would be use `Typeable` to basically mimic dynamic typing to some degree
07:03:08 <locallycompact> I noticed Typeable kicking about when I was playing with CloudHaskell
07:03:20 <locallycompact> what would that look like?
07:04:29 <locallycompact> What does Typeable do
07:05:44 <eacameron> locallycompact: Typeable lets you talk about types *via* a representation (TypeRep) and then safely encode data to some arbitrary format and then safely re-encode it back with type information. This is basically a type-safe way to do dynamic typing because it doesn't actually know if the conversions will succeed until runtime, but it makes sure you can't use the result of a failed conversion (which would be a crash)
07:06:40 <locallycompact> I see
07:07:39 <eacameron> locallycompact: You could actually look http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Dynamic.html
07:08:00 <eacameron> locallycompact: That's nice API around Typeable stuff to do dynamic typing
07:08:48 <eacameron> locallycompact: The alternative is to enter the realm of dependent types which Haskell is just starting to support
07:09:06 <locallycompact> dependent might be closer to what I want
07:10:04 <eacameron> locallycompact: I thought so, based on your example. But I wasn't sure if you were aware of the kind of world you'd be entering there. Don't get me wrong. It's awesome. But it's not a simple "Python -> Haskell" conversion.
07:10:43 <eacameron> Python is very, very sloppy with types and dependent typing is a whole different planet, even for many haskell programs
07:11:17 <locallycompact> hit me
07:11:43 <rom1504> done
07:12:48 <eacameron> locallycompact: Well...heh...maybe start out learning Idris and then backport those ideas to Haskell :P I hear that's the most efficient way to learn since Haskell's support is still less than ideal.
07:12:53 <ystael> locallycompact, ecameron: if the use case is essentially to support type-tagged data, would a GADT be a big enough fragment of dependent typing to solve the problem?
07:13:19 <eacameron> ystael: Good thought.
07:14:35 <locallycompact> I think so, what might my example look like in gadt?
07:15:10 <locallycompact> maybe gadt plus kindsomething?
07:15:51 <ystael> locallycompact: something like data Field a where MyTextField: Text -> Field Text
07:16:10 <ystael> (where : means ::, because I've been writing Coq :p )
07:16:35 <ystael> and then from the fact that the constructor is MyTextField you can infer that you have actually a Field Text and not a general Field a
07:16:56 <locallycompact> oh ok
07:17:01 <locallycompact> one sec
07:17:29 <muzzle> hi, I have a question about unpacking constructor fields. Would it make sense to unpack a field of a constructor that is a function?
07:17:35 * hackage buildbox 2.1.9.3 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.9.3 (BenLippmeier)
07:17:37 <eacameron> locallycompact: ystael: Yah and in fact Haskell will know that the field is Text since GADTs carry that information around.
07:18:01 <eacameron> locallycompact: Essentially if you have a finite, known set of types that you want to represent, GADT would be perfect and do what you need.
07:18:21 <locallycompact> yes that's the case
07:18:40 <eacameron> locallycompact: Perfect. GADTs is the answer then.
07:18:48 <Cale> muzzle: hmm... I don't *think* so. You're trying to avoid having a thunk which evaluates to a closure there?
07:18:56 <locallycompact> ok let me try
07:19:20 <muzzle> I use that function in an inner loop that is really performance critical
07:19:34 <eacameron> locallycompact: I should have asked that originally. In general dependent typing doesn't have that restriction but if your set of types is "open" then the work becomes more involved.
07:19:35 * hackage hasmin 0.3.2.1 - "A CSS Minifier"  https://hackage.haskell.org/package/hasmin-0.3.2.1 (contivero)
07:19:38 <muzzle> Cale and I thought using the function would maybe become a bit quicker?
07:20:51 <muzzle> Cale: As I understood it accessing an unpacked value saves me one level of pointer-indirection, right?
07:20:52 <locallycompact> yeah I see
07:21:09 <locallycompact> the python is basically a 'choice' of classes
07:21:55 <Cale> muzzle: When it makes sense to do so, yes -- usually. Sometimes it costs you having to re-box something when you'd otherwise just copy a pointer.
07:23:04 <eacameron> locallycompact: I see. GADTs are perfect if the types you're capturing really all need to be treated differently. But if they all have a common set of operations then using type classes or even just a record of functions would work well
07:24:04 <Cale> muzzle: But the case of functions is weird -- I'm not sure you'll save anything in that case. I'd have to look at the result of the compiler to be able to tell.
07:24:41 <muzzle> Cale: a difference would be visible in core, right?
07:25:10 <Cale> hmm
07:25:20 <Cale> Maybe not Core, but in cmm
07:25:39 <muzzle> Cale: how can i get at the cmm?
07:25:45 <locallycompact> hmm I confused myself
07:26:03 <Cale> -ddump-cmm
07:26:10 <locallycompact> so let's say I have a bunch of types
07:26:13 <muzzle> Cale: thank you
07:26:20 <locallycompact> data BlobType = BlobType deriving Show
07:26:20 <locallycompact> data BytesType = BytesType { size :: Integer } deriving Show
07:26:20 <locallycompact> data IntegerType = IntegerType { rangeEnum :: String } deriving Show
07:26:20 <locallycompact> data StringType = StringType deriving Show
07:26:23 <Cale> You might also want -ddump-to-file
07:26:28 <locallycompact> and then I want say
07:26:33 <locallycompact> TypeChoice to be a sum of those
07:26:38 <muzzle> Cale: I'll see if I can come up with something...
07:26:45 <locallycompact> and then in my original formulation I wanted
07:27:06 <locallycompact> Field { fieldStr :: String, fieldType :: TypeChoice }
07:27:07 <locallycompact> or something
07:27:19 <Cale> muzzle: Oh, also I don't think asking GHC to unbox the fields will do anything right now.
07:27:27 <lamefun> Is there a better syntax for OOP than this? http://lpaste.net/356178
07:28:22 <ertes-w> lamefun: what would it look like?
07:28:40 <ertes-w> also i'm not convinced that this is actually OO in any non-trivial way
07:28:48 <ertes-w> you could have achieved the same without labels
07:29:12 <bollu> I don't understand, where is #talk defined?
07:29:39 <Cale> muzzle: But I don't know, the UNPACK pragma's documentation is a bit vague
07:29:44 <lamefun> ertes-w: I don't know? Anything but having to create an instance for every method.
07:30:06 <lamefun> And what OO even is?
07:30:30 <ertes-w> lamefun: labels only really allow you to select instances using a quieter syntax
07:30:49 <ertes-w> they don't remove the need to actually write those instances
07:31:01 <bartavelle> lamefun: that is the question. However, I would expect anything that calls itself OOP to be Smalltalk, or have inheritance.
07:31:07 <lamefun> #talk :: Cat -> IO (); #talk Cat = putStrLn "Meow!"
07:31:16 <lamefun> something like that would be nice
07:33:29 <lamefun> I think it's so nice that if this existed, people would mostly stop writing normal functions and write HasMethod instances with this new syntax instead.
07:33:44 <cocreature> that’s a very strong claim
07:34:50 <lamefun> Isn't this happing in most languages that support methods/OOP already (Rust, Go, etc.)?
07:35:20 <ertes-w> lamefun: that's because FP is still a niche paradigm
07:35:22 <cocreature> but Haskell is very far from being an object oriented language
07:35:38 <lamefun> Eg. C++ can put functions outside classes, but most of the time people put them in classes anyway.
07:35:44 <cocreature> and I don’t see it becoming one anytime soon (and I wouldn’t want that)
07:35:48 <lamefun> It's not about being OOP or FP.
07:36:00 <cocreature> then why do you keep talking about OOP?
07:36:20 <ertes-w> lamefun: people love to talk about FP, but not actually use it, or at least not properly, and OOP the way it's usually used is actually counterproductive in moving to functional abstractions
07:36:35 <locallycompact> whenever you say object I get a feeling like when you drink an ashtray
07:36:40 <lamefun> It's about convenience (text.toUpper().trim().replace("x", "y")) instead of (Text.toUpper $ Text.trim $ Text.replace "x" "y" text).
07:37:07 <ystael> lamefun: you see convenience, I see the catastrophic and fundamental design error of insisting that every function has one special distinguished argument
07:37:07 <kadoban> lamefun: How is that convenient?
07:37:18 <lamefun> What FP and OOP are anyway?
07:37:19 <ertes-w> lamefun: i don't see any difference there
07:37:56 <ertes-w> it's the same code with slightly different syntax, except perhaps that the latter version uses combinators instead of built-in syntax, so i would actually find the latter even better
07:38:07 <Rotaerk_> it's conveniently like the syntax they're used to, I guess
07:38:18 <lamefun> AFAIK FP is when you can create and pass functions around as normal values, OOP is when you can associate common functions with a type.
07:38:35 <Rotaerk_> lamefun, nope, that's an oversimplification
07:38:47 <eacameron> locallycompact: Yah that would work
07:39:09 <Rotaerk_> both of those terms cover a lot of things, and the meanings differ depending on who you ask
07:40:00 <mlehmk> in functional programming you can have pure functions
07:40:13 <mlehmk> functions that do not modify any state
07:40:37 <lamefun> ystael: what special argument?
07:40:48 <mlehmk> actually, not just "can" but they just are
07:40:53 <ertes-w> mlehmk: you can have that in C and fortran, too
07:40:54 <bartavelle> lamefun: "this"
07:41:19 <mlehmk> ertes-w, not really, functions can modify state and to be pure it need discipline
07:41:47 <ystael> lamefun: as bartavelle said, the method receiver
07:41:48 <mlehmk> actually a lot in C and fortran is about modifying state
07:42:06 <lamefun> AFAIK in eg. Python you can just as well call MyClass.function(object, arg1, arg2) instead of object.function(arg1, arg2)
07:42:49 <bartavelle> lamefun: yet the first argument has to be of the type you are putting the class in, if you want to use the dot syntax
07:42:55 <Rotaerk_> that's not possible in some OO languages (as in, they *couldn't* enable you to do that)
07:43:38 <ertes-w> FP is more about using functions to abstract over behaviour, and to some extent using compositional frameworks rather than state manipulation to express systems…  things like composition and combinator style may be associated with FP…  but ultimately FP is an ambiguous term
07:46:23 <lamefun> How is having to prefix everything with `ModuleName.` better than OOP?
07:46:45 <ertes-w> that is also why OOP is inherently poisonous for FP: compositional frameworks clash with OOP's insistence to associate functions with particular arguments or even types in any special way
07:46:52 <bartavelle> lamefun: your issues are with namespaces, not OOP, and I agree that Haskell could be better on that front
07:47:16 <orion> ertes-w: "associate functions with particular arguments or even types in any special way" -- What does that mean?
07:47:43 <ertes-w> orion: x.plus(y)
07:47:48 <ertes-w> instead of x + y
07:48:04 <orion> But surely you can overload the + operator in, say, C++?
07:48:41 <bartavelle> orion: one of the argument has to be special, so that the compiler knows which function to call
07:48:43 <ertes-w> you can do that, but C++ provides no way to abstract over "classes that support +"
07:49:00 <cocreature> ertes-w: templates :P
07:49:07 <ertes-w> cocreature: that's just macros really =)
07:49:10 <ertes-w> macros can do anything
07:49:19 <dolio> I mean, in C++ you can overload + without attaching it to a class, too, if I recall correctly.
07:49:34 <orion> bartavelle: Isn't the function to be called "plus"?
07:49:36 <dolio> But that would probably be considered not part of the OO features.
07:49:49 <cocreature> ertes-w: yeah but templates trick you into thinking they’re actually a sane form of abstraction until you realize they’re just compiletime ducktyping :)
07:49:55 <orion> Isn't x.plus(y) just another way to write plus(x, y)?
07:50:00 <ertes-w> cocreature: yeah, exactly
07:50:08 <ertes-w> orion: in principle yes, in C++ no =)
07:50:13 <bartavelle> orion: there is a dynamic dispatch that depends on the type of x
07:50:36 <zomg> oh, huh, seems I accidentally managed to do what I wanted with DataKinds... I'm not even sure if I fully understand that extension, but at least it seems to do what I want not :P
07:50:43 <zomg> *now
07:50:45 <orion> Ah, I see.
07:51:35 <bartavelle> well, it could be a static dispatch
07:51:49 <bartavelle> and you can write a polymorphic 'plus(x,y)' function
07:54:34 * hackage audacity 0.0.1.2 - Interchange with the Audacity sound signal editor  https://hackage.haskell.org/package/audacity-0.0.1.2 (HenningThielemann)
07:55:42 <lamefun> So OverloadedRecordFields are going to be just for records and are not going to be extended into full OOP?
07:55:57 <ertes-w> lamefun: what is full OOP?
07:56:05 * hackage sound-collage 0.2.0.1, midi-music-box 0.0.0.4 (HenningThielemann): https://qbin.io/2vhi21u
07:56:32 <ertes-w> you will not get subtyping in haskell anytime soon, and then all that remains is awkward function application syntax =)
07:56:41 <lamefun> Simple syntax for defining methods (there's already simple syntax for calling them: http://lpaste.net/356178).
07:57:40 <ertes-w> instead of defining HasF and HasG, if they really belong together, perhaps what you really need is a proper abstraction as a type class
07:58:23 <ertes-w> but whether that's reasonable depends on *why* you need those functions on multiple types, and whether you're creating a real abstraction or just abusing haskell's type class system to get ad-hoc overloading
07:58:35 * hackage teardown 0.0.0.1 - Build composable, idempotent & transparent application cleanup sub-routines  https://hackage.haskell.org/package/teardown-0.0.0.1 (RomanGonzalez)
07:58:37 <lamefun> What are HasF and HasG?
07:58:45 <ertes-w> any "method classes"
07:59:15 <bartavelle> you can still manually create "method dictionnaries" and pass them around, which is what I do in many cases
08:01:43 <lamefun> Also, doesn't HasMethod class completely hijack IsLabel, where no additional instances can be defined without being ambiguous?
08:06:32 <lamefun> https://github.com/haskell-gi/haskell-gi already uses labels, will it be compatible with OverloadedRecordFields?
08:28:43 <James123> I am using: toRational 1.2 and I get some really big numbers. Any ideas to get round this problem? (I guess it is due to limited precision)
08:29:05 <c_wraith> James123: try 1.2 :: Rational
08:29:32 <c_wraith> > toRational 1.2
08:29:34 <lambdabot>  5404319552844595 % 4503599627370496
08:29:40 <ab9rf> 1.2 doesn't have an exact presentation in IEEE
08:29:42 <c_wraith> > 1.2 :: Rational
08:29:44 <lambdabot>  6 % 5
08:30:13 <James123> c_wraith: Hmm, this works. Thank you!
08:30:22 <c_wraith> James123: it's because when you use the expression (toRational 1.2) it defaults the expression 1.2 to Double
08:30:46 <c_wraith> James123: and then it gives you the exact fractional representation of the Double nearest to 1.2
08:31:14 <c_wraith> James123: whereas if you just use the literal 1.2 as a Rational, it never goes through Double as a representation
08:31:17 <ab9rf> > toRational 1.25
08:31:18 <lambdabot>  5 % 4
08:31:36 <dolio> > 1.2 :: Double -- the fun part
08:31:38 <lambdabot>  1.2
08:31:39 <ab9rf> 1.25 does have an exact representation in IEEE double
08:32:12 <ab9rf> :t toRational
08:32:13 <lambdabot> Real a => a -> Rational
08:32:48 <dolio> c_wraith: Can you explain that? :)
08:33:12 <ab9rf> dolio: yes, but the explanation is long, tedious, and fundamentally uninteresting
08:33:14 <c_wraith> dolio: easily.  show on Double produces the shortest decimal string that parses to the same Double value
08:34:03 <ab9rf> unless you enjoy spending hours ruminating on the vagaries of varioues representations of floating point numbers
08:36:07 <ab9rf> toRational on a Double will always yield a denominator that is a power of 2
08:36:13 <shapr> ab9rf: that's an irrational idea
08:36:31 <ab9rf> in the example above (toRational 1.2) the denonminator is 2^52
08:37:52 <James123> So I guess that I need to convert the Double to another representation, right? What function could be used?
08:38:41 <c_wraith> James123: if you want to use Rationals, just use Rationals and never touch Double
08:38:48 <ab9rf> ding ding
08:38:48 <michi7x7> > Data.Ratio.approxRational 1.2 1e-6
08:38:50 <lambdabot>  6 % 5
08:38:55 <dolio> I wonder how hard it is to adapt the printing algorithm to a rational conversion. It's been a long time since I read it.
08:40:42 <fastAndBulbous> I hate you #haskell. I came here just to torture myself because I'm about to go on a business trip stumping for a very broken android project and its just depressing seeing intelligent conversation about programming that doesn't involve mindless chatter about upcoming changes from google, reliance on precompiled 3rd party libraries written well below standards, and an infinite list of hacky 
08:40:48 <fastAndBulbous> 'solutions' copy pasted from stack overflow by ESL programmers. 
08:41:10 <fastAndBulbous> Would one hundo percent prefer to be using haskell. fml.
08:41:14 <shapr> fastAndBulbous: have you seen the android cross-compiler for ... 
08:41:17 <ab9rf> heheh
08:41:24 <shapr> fastAndBulbous: I know people are making iOS apps in Haskell too
08:41:43 <ab9rf> what i find amusing is how much my efforts to learn haskell has shaped the way i write C+
08:41:46 <ab9rf> C++
08:41:50 <fastAndBulbous> IOs is a far deeper level of hell. 
08:42:33 <shapr> fastAndBulbous: keep writing Haskell, maybe you'll end up with a job doing that!
08:42:46 <shapr> fastAndBulbous: also, what does stumping mean?
08:43:06 <fastAndBulbous> Standing on a box used for packaging soap. 
08:43:19 <ab9rf> shapr: trying to convince people to buy/invest in/not make fun of your product
08:43:20 <michi7x7> ab9rf: true, I had to write a paging-implementation for x86 for a university-course and did the level iteration using recursive template functions
08:43:28 <michi7x7> the others on the project hate me for that ^^
08:43:37 <fastAndBulbous> If you're in Founders Forum London-area please just pretend you don't recognize me. 
08:43:46 <merijn> michi7x7: Hah, others hate my template code and they don't even have to work with my template code :D
08:44:10 <michi7x7> merijn: how comes?
08:44:31 <merijn> michi7x7: It's that horrible :p
08:44:56 <michi7x7> oh ^^
08:45:05 <ab9rf> i don't claim to be good at either haskell or C++, but i think my C++ is better for my time writing bad haskell
08:45:33 <merijn> michi7x7: Witness the majesty! https://github.com/merijn/GPU-benchmarks/blob/master/TemplateConfig.hpp#L215-L234
08:45:58 <ab9rf> ha!
08:46:12 <ab9rf> i love the use of typename...
08:46:31 <ab9rf> nothing says love like a variadic template
08:46:32 <michi7x7> merijn: variadic template expansion in the middle of the arguments, are you insane? ^^
08:46:41 <merijn> ab9rf: Before the typenames it was unreadable
08:47:06 <merijn> michi7x7: You mean in the function arguments or the template arguments? :p
08:47:46 <lyxia> Are there good examples of applications of monadic parsers as opposed to merely applicative parsers?
08:47:55 <merijn> michi7x7, ab9rf: This thing only exists because C++ can infer templates on functions, but not on classes. So it's one huge hack to avoid having to write insane loads of template annotations on the uses
08:48:18 <merijn> lyxia: I assume you're familiar with monadic parsers, so are curious about examples of applicative parsers?
08:48:35 * hackage antigate 2.0.2 - Interface for antigate.com captcha recognition API  https://hackage.haskell.org/package/antigate-2.0.2 (MikhailKuddah)
08:48:37 <merijn> lyxia: Because the obvious example of a purely applicative parser would be optparse-applicative
08:48:42 <michi7x7> merijn: yeah, I know. I've used a fair bit of boost. This is still better than enable_if
08:48:50 <ab9rf> merijn: my comprehension of C++ templates is still very very limited
08:49:06 <cocreature> merijn: we’ll get template inference for classes in c++17 iirc
08:49:22 <merijn> michi7x7: oh...I have enable_if too
08:49:36 <merijn> The actual usage becomes very readable, though: https://github.com/merijn/GPU-benchmarks/blob/master/bfs/bfs.cpp#L151-L156
08:50:19 <lyxia> merijn: I'm looking for languages to parse rather than parser frameworks.
08:50:44 <merijn> lyxia: Well, the language in this case would be commandline options, I guess :p
08:50:54 <michi7x7> merijn: yeah, the only problem is the compiler errors
08:51:12 <lyxia> and examples where applicative is *not* sufficient
08:51:28 <merijn> lyxia: Anything where parsing something depends on a previous parse result
08:52:12 <zomg> I'm trying to use a `deriving instance Show a => Show (SCurrency a)` but I'm getting `Expected kind ‘Currency’, but ‘a’ has kind ‘*’`
08:52:31 <zomg> Any ideas? The code works fine as long as I don't try to derive Show, and if I manually derive Show, it also works just fine
08:52:36 <merijn> zomg: What's the definition of SCurrency?
08:52:46 <c_wraith> zomg: remove the constraint. 
08:52:47 <cocreature> zomg: try "deriving instance Show (SCurrency a)"
08:52:56 <merijn> zomg: I have a sneaking suspicion SCurrency is a GADT with a phantom type
08:52:59 <c_wraith> zomg: obvious a must be phantom if it has a datakind
08:53:11 <cocreature> a is of kind Currency in particular it’s not of kind * so it has no values. and Show only makes sense for values
08:53:24 <zomg> c_wraith's suggestion works :)
08:53:48 <zomg> removed the constraint and it works.. I was getting a different error earlier without the constraint, but it appears to work now :P
08:54:03 <lyxia> merijn: Sure, but what's a less toy example than parsing length-prefixed strings?
08:54:57 <c_wraith> zomg: the error message was trying to tell you the constraint didn't make much sense, but it was telling you in its very weird language. :)
08:55:04 <zomg> merijn: and yes I believe it is a GADT with a phantom type.. I'm still a bit hazy on how all of this works =)
08:55:05 <ab9rf> heh
08:55:28 <c_wraith> lyxia: any data format where an integer enum is used to indicate the format of the upcoming data.
08:55:31 <zomg> c_wraith: I see :) Thanks
08:56:02 <ab9rf> there's lots of those
08:56:08 <merijn> lyxia: OpenType fonts (or basically any format that consists of length-prefixed fields)
08:56:39 <merijn> lyxia: I wouldn't call length-prefixed strings a toy format, since A LOT of binary formats are length prefixed (to be efficiently parsable)
08:56:49 <merijn> lyxia: Or even length AND type prefixed
08:56:57 <c_wraith> lyxia: parsing chunked http reponses?
08:57:08 <lyxia> c_wraith: hmm you can also parse enums with Alternative, which I think is commonly included in the "applicative parser" denotation.
08:57:40 <ab9rf> ASN.1 BER uses typetags, iirc
08:57:48 <merijn> lyxia: He means an enum that determines which parser to run next
08:58:07 <merijn> I suppose you could have a completely backtracking applicative parser for that. But it'd be horribly inefficient
08:58:23 <zomg> Ah actually seems the "other error" I was getting earlier was just from deriving Read
08:58:48 <zomg> I don't really even need Read so I guess I'll just leave it out :P
08:58:57 <c_wraith> lyxia: http's Transfer-encoding: Chunked actually seems like an excellent example
08:59:09 <c_wraith> lyxia: you need to parse the delimiter out of the data stream
08:59:51 <fosskers> Hi everyone
08:59:55 <fakdsystm> Hii
08:59:58 <lyxia> basically I have a funny way of writing monadic parsers that are also printers and I'm looking for uses.
09:00:05 <fosskers> I'm using attoparsec, and I'm wondering there's a better way to skip known lengths of bytes
09:00:15 <fosskers> Better than `take`, I mean.
09:00:28 <merijn> fosskers: Yes!
09:00:33 <fosskers> `take :: Int -> Parser ByteString`
09:00:33 <merijn> fosskers: But I forget the name, lemme check
09:00:42 <fosskers> I think this is slowing my parser down (I'm using it quite a bit)
09:00:55 <lyxia> and I'm specifically targetting languages requiring more than Applicative/Alternative since that space is pretty crowded already
09:00:56 <fosskers> because I'm just ignoring whatever `take` grabbed afterward anyway
09:01:12 <ab9rf> fosskers: yeah, it's expensive to have it collect the skipped bytes if you don't care about them
09:01:24 <merijn> fosskers: hmmm, I was thinking of skip, etc. but they don't do fixed lengths
09:01:46 <dolio> As long as your grammars are allowed to be infinite, every language is 'regular'.
09:01:54 <fosskers> ab9rf, exactly. Even with laziness in the mix to help.
09:02:02 <merijn> fosskers: tbh, take is quite cheap
09:02:32 <ab9rf> is advance exposed?
09:02:41 <ab9rf> advance :: Int -> Parser ()
09:02:46 <fosskers> what if I'm taking several megabytes?
09:02:46 <cocreature> ab9rf: doesn’t look like it. I was just searching for that myself
09:02:55 <fosskers> (ignoring several mbs)
09:03:04 <lyxia> if the only actual use case is length-prefixed encodings, one might as well try to add that as a special combinator to existing solution
09:03:15 <cocreature> but the Parser constructor is exposed so you should be able to implement it
09:03:15 <merijn> fosskers: Honestly, I don't think I'd worry about it until profiling shows it's an issue
09:03:21 <cocreature> fosskers: copy the source of https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/src/Data-Attoparsec-ByteString-Internal.html#advance
09:03:37 <cocreature> and import Data.Attoparsec.Internal.Types
09:03:49 <ab9rf> cocreature: yeah, i don't see anything there that relies on unexposed features
09:04:15 <fosskers> nice, `advance` looks good
09:04:31 <cocreature> ab9rf: once the constructor is exposed there are few features that you can still hide by not exposing other things :)
09:04:44 <fosskers> I'm currently benchmarking a new lib of mine, and it seems to be going at least an order of magnitude too slow. I'm experimenting with all possible speed ups
09:05:22 <ab9rf> cocreature: i don't understand the attoparsec developer's decision on which functions to expose sometimes
09:05:27 <lamefun> Can I create global package import aliases (eg. turn Text.Megaparsec into just Megaparsec)?
09:05:57 <ab9rf> lamefun: yes
09:06:16 <fosskers> thanks guys, I'll try this
09:06:24 <cocreature> depends on what you mean by global
09:06:28 <ab9rf> import Big.Long.Package.Name as Tiny
09:06:37 <ab9rf> applies only to the current module, of course
09:07:19 <comerijn> fosskers: Unfortunate disconnect, so I missed anything else that was said, but you could also consider using binary instead of attoparsec
09:08:05 <comerijn> Because then you can just "skip :: Int -> Get ()"
09:09:08 <ReinH> you probably mean import qualified
09:09:15 <ab9rf> probably ;)
09:09:38 <ab9rf> i'm sick as a dog right now, i may say things that are completely raspberry without warning
09:09:47 <fosskers> comerijn, I did the cowboy thing I hand-wrote my own protobuf parser using atto
09:10:14 <fosskers> thinking the result would be faster than using the various `protobuf` libs
09:10:16 <comerijn> fosskers: Personally I feel binary is nicer to use for parsing binary data than attoparsec
09:10:54 <fosskers> comerijn, I'd have to rewrite everything, but I'll add it to my list of things to try
09:11:21 <ab9rf> it depends on the data you're parsing, i suppose
09:13:12 <fosskers> haha turns out adding -O2 to my lib's ghc flags did a good amount
09:13:27 <fosskers> face-palm on forgetting that
09:18:47 <barcabuona> hey guys a curiosity: can there be anyo optional parameters in a haskell function?
09:19:02 <fosskers> nope
09:19:08 <barcabuona> like in python you can have def f(a, b, **optionals)
09:19:10 <barcabuona> why not?
09:19:25 <fosskers> I suppose it's considered an anti-pattern
09:19:36 <kadoban> barcabuona: What would the type be?
09:19:48 <barcabuona> kadoban: i guess a->b-> whatever
09:20:00 <barcabuona> the optional paramters stay optional
09:20:11 <barcabuona> and partial application is allowed only on the maijn paramters
09:20:17 <barcabuona> i mean something can be figured out
09:20:23 <barcabuona> it's a pretty nifty pattern imo
09:21:03 <barcabuona> cuz you can have something like f(importanta, importantb, **whatever, very_optional=3, very_optional2=4)
09:21:22 <barcabuona> and the optionals are _within_ the function but still never exposed unless needed
09:21:43 <barcabuona> maybe the type could be something like a->b-> Maybe optionals->result
09:22:14 <barcabuona> if you wanna have non-syntax aided optional types. otherwise that maybe optional would be implicit in some other call
09:22:41 <barcabuona> just thinking about this while using python is all...sometimes some variables are very rarely modified and don't need to be in the main parameters list
09:22:49 <barcabuona> but still they need to be modified
09:23:05 <barcabuona> maybe that can be achieved today with a Maybe map
09:23:10 <barcabuona> as third parameter
09:27:46 <ab9rf> there are often better ways to accomplish that though
09:28:50 <ab9rf> an ADT or GADT would likely be one of my leading choices
09:30:15 <ab9rf> especially for optional arguments that are conditionally required
09:30:41 <ab9rf> variadic functions are generally evidence of a mistake
09:32:27 <fosskers> that indicate some problem in design
09:33:45 <ab9rf> usually an attempt to make a single function do two or more things simultaneously
09:36:08 <Cale> Well, they're pretty much equivalent to taking something like an additional list argument (sometimes with varying types of elements, but that could be accounted for with an algebraic type, if necessary.
09:36:15 <Cale> )
09:37:02 <ab9rf> Cale: not always
09:37:22 <mrkgnao> if I have l = lens get set, how do I write f . get using lens combinators?
09:37:37 <ab9rf> Cale: sometimes they're used for lists but you also see them used for "thing i might need sometimes but not always" and then you have the keyword map for "random crap that is only used in some cases"
09:38:05 * hackage csound-expression 5.2.1, csound-expression-typed 0.2.0.1 (AntonKholomiov): https://qbin.io/xheel0cs
09:38:09 <Cale> Can you provide an example? I believe that's pretty much how C implements them -- you get an additional array of the remaining arguments.
09:38:16 <Cale> ah
09:38:29 <ab9rf> Cale: you get TWO arrays, a list of untagged arguments, and a map of tagged arguments
09:38:44 <Cale> Well, some of those cases you probably wouldn't want to put up with such an ugly interface
09:38:47 <ab9rf> it's not two arrays, it's an array and a dictionary
09:38:48 <mrkgnao> I tried doing l ^. f but that does not work at all
09:38:50 <barcabuona> so basically you're saying instead of having a mapping of option string names it's better to have a datatype?
09:38:56 <barcabuona> remember these are rarely used options
09:38:56 <ab9rf> barcabuona: YES
09:39:00 <ab9rf> barcabuona: ABSOLUTELY
09:39:06 <barcabuona> the user doesn't want to know there is some weird ass datatype
09:39:08 <Cale> mrkgnao: f . view l
09:39:19 <ab9rf> barcabuona: how else are you to ensure that someone doesn't send an undefined option?
09:39:28 <barcabuona> that is true
09:39:33 <ab9rf> type safety dude
09:39:47 <ab9rf> dictionaries are no substitute for a proper ADT
09:40:02 <Cale> barcabuona: A thing we often do where I work is just to define a record type for the configuration, and then add an instance of the Default class for it
09:40:11 <ab9rf> this is the configuration pattern
09:40:12 <Cale> So you can then write  def { someField = x }
09:40:19 <ab9rf> and there's lots of examples in hackage of it
09:40:28 <barcabuona> that does mean that for every function with optional variables i would need a new data type
09:40:42 <ab9rf> barcabuona: datatypes tend to proliferate in haskell.
09:40:47 <ab9rf> barcabuona: we see this as a good thing
09:40:47 <Cale> barcabuona: yes.
09:41:04 <barcabuona> alright i'll give this a try
09:41:08 <Cale> It's not like very much code is needed to define that type :)
09:41:20 <barcabuona> thanks. of course wrap it all around a maybe. or just make a type with None
09:41:39 <ab9rf> barcabuona: or use a configuration type
09:41:40 <barcabuona> Cale: yeah but the user needs to remember 100 different types probably just to _not_ use them
09:41:55 <ab9rf> barcabuona: nah, just use a configuration builder
09:42:21 <ab9rf> stdConfig returns a basic configu, and then you have a series of exported functions that alter the config in specified ways
09:42:23 <Cale> barcabuona: You can generally assume that the user of your function knows its type
09:42:56 <Cale> Even just having a single default is usually enough.
09:43:45 <Cale> https://hackage.haskell.org/package/data-default
09:43:50 <dmwit> barcabuona: This is where the `Default` class that Cale mentioned comes in. You get *one* name (specifically, `def`) that serves as a suitable starting point for the options for *any* of your functions, even if they have different types of options.
09:44:35 <Cale> The data-default package ships with a bunch of silly instances which it probably shouldn't, but otherwise, it's a good idea.
09:44:41 <dmwit> barcabuona: Anecdotally: the diagrams package uses this pattern heavily (a fresh option type for each function), and I haven't found it cumbersome.
09:44:57 <barcabuona> ok im still a newb so it's a lot of stuff but really interesting
09:44:58 <ab9rf> pandoc uses it in several different ways
09:45:06 <barcabuona> i actually plan to try moving my scripting python skills to haskell
09:45:19 <ab9rf> ReaderOptions, WriterOptions, etc.
09:45:29 <barcabuona> just to see if some more complex problems can be easier written in a pure style
09:45:40 <ab9rf> barcabuona: my experience is yes, once you get the hang of it
09:46:07 <barcabuona> of course i don't expect haskell to replace python for everything, but it'll be nice to map everything to a type for some applications i suppose
09:46:10 <Cale> Oh, weird, also in the latest version the docs neglect to mention def somehow.
09:46:16 <barcabuona> i had a great time building an interpreter in ocaml
09:47:17 <dmwit> https://hackage.haskell.org/package/data-default-class-0.1.2.0/docs/Data-Default-Class.html gets it right
09:47:48 <Cale> Ah, interesting, they split the package
09:47:58 <dmwit> Cale: I agree, that's very weird. The "minimal complete definition: Nothing" clause also seems a bit misleading.
09:48:05 * hackage hasmin 0.3.2.2 - "A CSS Minifier"  https://hackage.haskell.org/package/hasmin-0.3.2.2 (contivero)
09:48:12 <dmwit> I mean, I understand how haddock came to that conclusion. But it's weird anyway.
09:51:43 <Cale> barcabuona: You probably could expect Haskell to replace Python fairly well for most things. Perhaps some usages of numpy/scipy wouldn't go through quite so smoothly, but that depends on what parts of that library you need.
10:14:02 <MitchellSalad> we can do data science in haskell!
10:14:10 <MitchellSalad> look how simple data exploration is https://hackage.haskell.org/package/Frames-0.1.9/docs/Frames-Exploration.html
10:14:44 <barcabuona> Cale: i use python a lot for quick shell scripts. i don't really expect haskell to beat a dynamic langauge at that game, escpecially with all the string formatting that might be needed. i do expect it to come in handy when working with some fancy algorithms though, maybe for bug squashing or simply having a more functional definition
10:15:29 <barcabuona> python has simply great support for IO for example. that's not where i expect haskell to excel
10:15:40 <maerwald> barcabuona: I agree, I feel like python beats haskell in terms of quick prototyping by far
10:15:45 <MitchellSalad> haskell actually excels at IO, believe it or not
10:15:55 <maerwald> but when I want a properly defined system, I get sick of python very quickly
10:16:52 <maerwald> MitchellSalad: it's hard to do correct system programming in haskell with all that semi-defined abstraction layers like directory, FilePath, ...
10:18:04 <maerwald> ofc you can do it right, but then you can't use half of base (and other libs)
10:18:52 <barcabuona> maerwald: i too have noticed that when a program in python grows beyond a certain point, a lot of dynamic bugs start offputting the advantage of quick prototyping
10:18:59 <dmwit> maerwald: Could you unpack that a bit? What does "correct system programming" mean, and why does it rule out base?
10:19:14 <barcabuona> instead in functional languages like ocaml i have experienced great safety for large interconnected programs
10:19:26 <barcabuona> but i dislike the ocaml stdlib so that's why i wanna try haskell
10:19:34 <barcabuona> also the datatypes seem better
10:19:34 <dmwit> Oh, I have a guess: you're talking about `type FilePath = String` instead of something system-dependent?
10:19:45 <maerwald> dmwit: yes that too
10:20:02 <maerwald> also, use of the "directory" package is very common, but it's at best semi-defined
10:20:29 <maerwald> then there are GHC Handles
10:20:35 <barcabuona> also for example sometimes it's really annoying having abstract types in a language when you're scripting. in python most options are strings. sure that is unsafe, like people stated earlier, but for quick scripts it's just perfect
10:20:49 <CuriousErnestBro> hi
10:21:18 <CuriousErnestBro> how good is "programming in haskell" by Graham Hutton for a noob in functional programming
10:22:35 <glguy> CuriousErnestBro: I thought it was good, and it gets into some neat exercises
10:24:28 <maerwald> barcabuona: theoretically you can extend python with type annotations and use pytype or mypy, but you will never get the same level of correctness as in haskell there
10:25:06 <maerwald> but I love the idea: start out dynamically typed, move to static types once your prototype is done
10:25:35 <jadrian> In linux, after adding a new directory with sty files to /usr/share/texmf/tex/latex, I recall needing to run  some command to update some index (?) 
10:25:47 <jadrian> but I forgot which 
10:25:52 <shapr> I also forget
10:26:13 <jadrian> but it is the case that I'm supposed to run something, right?
10:26:28 <jadrian> opss
10:26:33 <jadrian> sorry thought I was in latex
10:26:53 <cocreature> I wouldn’t mind a reimplementation of latex in Haskell
10:26:54 <maerwald> jadrian: texfm-update?
10:27:41 <jadrian> maerwald: have no such thing... I thought it was mkindex, but it asks me for some file name
10:28:39 <jadrian> ah
10:28:48 <jadrian> I think I found it, texhash
10:29:14 <barcabuona> maerwald: yeah i did see they added that recently. it can surely make the transition (paradigm transitions are what python excels most at imo) from dynamic typing to static much easier. but i've yet to check it out
10:30:34 <maerwald> I have not so good experience with mypy (not reliable, doesn't check a lot of things properly)... pytype seems more into "correctness", but it doesn't look as maintained as mypy and sometimes fails to build with newer python versions
10:30:50 <maerwald> (slowling moving OT here)
10:32:30 <barcabuona> it'd be interesting to see some faster python when using static typing
10:32:52 <maerwald> I want dynamically typed haskell! :P
10:33:10 * maerwald goes googling "oleg +dynamically typed haskell"
10:33:56 <michi7x7> maerwald: you sure you wan't this?
10:34:04 <maerwald> not really sure xD
10:34:23 <maerwald> everything oleg comes up with is usually nuts, but also fascinating
10:35:11 <michi7x7> maerwald: there is Data.Dynamic
10:35:16 <barcabuona> maerwald: i thought about functional dynamically typed languages...im not sure. dynamic typing is good with lots of moving parts so maybe state change makes more sense there
10:35:27 <maerwald> michi7x7: yeah, I know that one, but that's a little poor
10:35:27 <barcabuona> when you wanna keep it clean it makes sense to have static typing
10:38:49 <shapr> I'm giving a talk this evening comparing writing Python and Haskell for REST APIs.
10:39:10 <shapr> My conclusion is that Haskell is roughly 10% faster for every step, and that adds up quickly.
10:39:29 <shapr> Except at runtime, where Haskell ended taking 10% of the time Python took to process 50k requests.
10:40:35 <EvanR> so haskell is slower at processing?
10:40:41 <EvanR> taking 10% more time?
10:40:42 <shapr> Nah, 90% faster
10:40:46 <EvanR> oh
10:40:53 <EvanR> faster across the board
10:41:09 <EvanR> performance or also dev speed?
10:41:20 <shapr> 90% faster in my benchmark
10:41:27 <shapr> 10% faster for dev speed
10:42:01 <shapr> well, if you don't include the two hours I wasted when Flask was using a sqlite db I could *not* find on the filesystem. That went away after a reboot, but what the heck was that?
10:43:05 <shapr> I made roughly the same number of errors in both, but Haskell caught the problems at compile time, meaning each iteration was much faster.
10:43:25 <shapr> When Python had a problem, it was often unclear exactly what was broken, and where.
10:43:35 <shapr> Mind you, I've been writing Python for more than twenty years, and Haskell for more than fifteen years.
10:44:22 <EvanR> is that in boston or atlanta
10:44:38 <shapr> Tonight's talk is in Atlanta, 7pm at the Iron Yard
10:45:46 <shapr> EvanR: are you in atlanta?
10:45:49 <EvanR> I won't be able to make it this time, unless I rented a vehicle and started driving immediately
10:45:53 <shapr> ha
10:45:55 <EvanR> new orleans
10:45:59 <shapr> oh right!
10:46:22 <EvanR> 7PM monday is also my haskell meetup here, but I don't think its happening either, this time
10:46:31 <shapr> aw, too bad
10:46:49 <shapr> we have 16 people signed up to attend, but I don't think I have an hour of content.
10:46:55 <Mandarancio> Hi
10:46:59 <shapr> hello Mandarancio 
10:47:07 <Mandarancio> I am new to Haskell
10:47:12 <shapr> lucky you!
10:47:16 <maerwald> shapr: do you have slides?
10:47:17 <shapr> Haskell is so much fun to learn!
10:47:22 <shapr> maerwald: nah, I don't have slides
10:47:26 <Mandarancio> yes I really like it
10:47:35 <EvanR> it will be fine I'm, sure if half of them show up, you'll have plenty to randomly talk about haskell wise
10:47:35 <shapr> maerwald: I'm going to stick the source code up on the screen and talk about my experience doing this.
10:47:59 <shapr> We also don't have video recording.
10:47:59 <maerwald> well, assuming you are in the US, I probably can't attend it :P
10:47:59 <Mandarancio> I have a question about sequence_
10:48:17 <michi7x7> shapr: being a Haskell user for so long, what paradigms do you actively use? Monad-Transformers, Arrows, Lenses?
10:48:17 <Mandarancio> I write a small n body simulation with SDL rendering in haskell 
10:48:51 <Mandarancio> and I would like to know if it's possible to break the sequence_ 
10:48:57 <shapr> michi7x7: lots of lenses, monad transformers when you need them, arrows are rarely needed in my experience.
10:49:26 <shapr> I just started using lenses this past december, and why did I wait?!
10:49:36 <shapr> Mandarancio: what do you mean?
10:49:37 <maerwald> because you are fine without them :P
10:49:50 <shapr> Lenses are really useful, I'm a huge fan.
10:49:59 <Mandarancio> well I generate the infinite simulation using iterate
10:50:12 <Mandarancio> and then I use sequence_ to display it trought SDL
10:50:31 <Mandarancio> and I would like to close the simulation when the user click on the close button of the window
10:50:34 <shapr> so you want something like iterate until?
10:50:48 <maerwald> shapr: except for some really hard cases (I remember something about the Snap API), most of the time it's just "I want to do it more concise/elegant/whatever", not actual problem-solving
10:50:50 <Mandarancio> not really
10:51:00 <Mandarancio> I want the user to choose when to exit
10:51:07 <shapr> maerwald: I like elegance!
10:51:11 <maerwald> I don't
10:51:11 <Mandarancio> if he/she wants to stay up all night
10:51:18 <shapr> maerwald: ok
10:51:22 <Mandarancio> the code is here https://github.com/Mandarancio/nbodies
10:51:27 <maerwald> I like simplicity :o
10:51:50 <EvanR> youll need a crunchy loop mechanism, you keep cosuming the list (slowly, by delaying between frames), only if the exit event doesnt come, in which case just exitSuccess or dont loop
10:52:11 <EvanR> a premade SDL combinator for this would be cool, but one size doesnt fit all
10:52:28 <lyxia> or you throw an exception to kill everything
10:52:34 <ClaudiusMaximus> depending on how the gui library works, you could use IO exceptions (throwIO, or throwTo perhaps if the callback is in a different thread)
10:52:35 <Mandarancio> it's what I'm doing
10:52:44 <Mandarancio> I throw an exception
10:52:46 <ski> Mandarancio : some kind of exceptions (either `IO', or `Either'/`ExceptT' or perhaps something else) ?
10:52:47 <Mandarancio> but is ugly
10:53:10 <EvanR> with SDL, theres no callbacks, just checking for new events in a queue (and it must be called from the main thread...)
10:53:23 <EvanR> (ignoring for the moment the audio callback)
10:53:55 <ski> (perhaps one of the pipes or whatever it's called packages could be used here ..)
10:53:59 <EvanR> Mandarancio: you can use recursion to repeat the waiting + consuming + checking process
10:54:16 <EvanR> then when its time to end, dont recurse
10:54:26 <Mandarancio> EvanR: Right that could do the trick 
10:54:50 <Mandarancio> thank you very much ! It's only one weekend but the language is real fun!
10:54:53 <michi7x7> Mandarancio: (.*) = flip (*.), no? ^^
10:54:54 <EvanR> theres a lot of things in monad-loops that could do it, but itll involve checking some Bool variable with IO
10:55:20 <shapr> michi7x7: do you use lenses/arrows/transformers?
10:55:27 <Mandarancio> ooo I did not know about flip ! Thx!
10:55:41 <shapr> michi7x7: I've seen some things go badly, I will never trust implicit parameters again.
10:55:47 <michi7x7> shapr: I do use transformers and lenses, never got to understand arrows ^^
10:55:49 <Mandarancio> I go to try out the solution sudjested! thx! bye!
10:55:53 <Mandarancio> \exit
10:55:58 <shapr> Mandarancio: come back soon!
10:56:01 * shapr waves
10:58:00 <michi7x7> shapr: But I'm still just playing around with the language, never actually got to use it for a real project yet
10:58:05 * hackage git-annex 6.20170520 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20170520 (JoeyHess)
10:58:22 <merijn> michi7x7: You can save yourself the time, arrows are pretty much obsoleted
10:58:43 <shapr> michi7x7: got any small fun projects you could build?
10:59:04 <shapr> I always write my diagnostic projects in Haskell at work, because I'm just trying to find a problem
10:59:28 <shapr> I also have a deal with my team lead that I can write anything in Haskell as long as I'm willing to rewrite it in Python or Go if it goes into production.
10:59:29 <michi7x7> shapr: well, that's what I do when using Haskell: https://github.com/michi7x7/mastermind
10:59:50 <maerwald> shapr: haha
11:00:24 <kadoban> shapr: Next project: haskell -> python/go compiler then?
11:00:44 <shapr> kadoban: have you seen reconfigure.io?
11:01:05 <kadoban> No
11:01:24 <kadoban> https://reconfigure.io/ this I guess?
11:01:27 <shapr> yup
11:01:29 <michi7x7> kadoban: that would be a transpiler, no?
11:01:38 <shapr> they use Haskell to parse Go and then spit out an FPGA bitstream
11:01:39 <merijn> michi7x7: Gah!
11:01:50 <merijn> michi7x7: Never use that word again >.<
11:01:50 <kadoban> michi7x7: Yes, though I think the term is kind of useless personally.
11:02:09 <kadoban> shapr: Oh ya? Interesting.
11:02:14 <merijn> michi7x7: "A transpiler is a compiler that translates from one language to another" <- well, that's already what the term compiler means >.<
11:02:34 <merijn> Actually, compiler is strictly more general, since nothing rules out a compiler with the same language as input and output...
11:02:45 <cocreature> merijn: transpilers are what enable isomorphic javascript to be truly webscale!
11:02:55 <merijn> cocreature: You're going to give me an aneurysm
11:02:59 <kadoban> cocreature: :(
11:03:00 <shapr> isomorphic to what?
11:03:17 <michi7x7> merijn: well, but compiling from one fully featured language to another fully featured language is probably pointless enough to have a dedicated word ^^'
11:03:24 <merijn> shapr: isomorphic JS is stupid terminology for "I'm running the same code on the server and client"
11:03:32 <shapr> oh, I see
11:03:38 <maerwald> michi7x7: like ghcjs? xxD
11:03:38 <merijn> michi7x7: About 80% of all compilers, if not more, do that
11:03:40 <EvanR> ok, but missing from the obvious issues with jargon "transpiling" is that people distinguish between source code and "object code (wtf is with THAT name)"
11:03:45 <cocreature> merijn: sry :)
11:03:46 <merijn> michi7x7: And have done so for decades...
11:03:51 <koala_man> merijn: and "decompiler" should just be called "compiler"?
11:04:00 <EvanR> source to source translation is yet another thing i guess
11:04:01 <merijn> michi7x7: Most compilers I know output C or something as target language
11:04:24 <cocreature> merijn: huh? which compiler still outputs C these days?
11:04:28 <merijn> koala_man: Technically that'd constitute a compiler, imo. Although actuall decompilers do more than just translate to a higher source language
11:04:29 <EvanR> C what a terrible target
11:04:36 <maerwald> cocreature: ghc xD
11:04:39 <merijn> EvanR: It's ok-ish, at least portable
11:04:45 <EvanR> is it?
11:04:45 <merijn> maerwald: GHC hasn't output C in years
11:04:57 <kadoban> EvanR: It's not the worst idea, it's probably a good idea in terms of ability to port to new platforms.
11:04:58 <merijn> EvanR: As in, C has compilers on every hardware
11:05:12 <merijn> cocreature: Every research compiler I've ever encountered, for one
11:05:15 <EvanR> not necessarily that will make your C output actually work
11:05:26 <cocreature> merijn: ah fair enough. I was thinking about non-research compilers
11:05:36 <EvanR> youll need a different backend for each platform
11:05:36 <merijn> cocreature: Like there are many of those...
11:05:41 <kadoban> EvanR: But it has a better chance than approximately anything else.
11:05:55 <merijn> EvanR: If you have, e.g. a POSIX compatible backend you can automatically run on any POSIX machine
11:06:00 <EvanR> and the facilities in C are painful
11:06:02 <kadoban> At least anything else that every platform ever has a compiler for.
11:06:14 <EvanR> ah posix.... 
11:06:16 <merijn> EvanR: Getting things to run on any BSD + OSX + linux + solaris was very easy that way
11:06:18 <koala_man> I wanted to have GHC output C so I could compile it with instrumentation for AFL, but no such luck
11:06:24 <EvanR> i was thinking something totally else with "any machine"
11:06:43 <michi7x7> well, I know a lot of compilers use a gcc or llvm-backend, but I wouldn't know many that use C as intermediate step.
11:06:49 <michi7x7> I know vala does that, but others?
11:06:52 <merijn> koala_man: That's because GHC no longer (as in for several years)has a C backend :p
11:07:22 <merijn> michi7x7: Theres hundreds of compilers out there at universities and in companies :)
11:07:26 <maerwald> but it has llvm right?
11:07:33 <merijn> maerwald: Optional
11:07:39 <merijn> maerwald: And not trivial to get working
11:07:52 <merijn> The default (for over a decade, I think) is the native code generation of GHC
11:08:09 <cocreature> you need install the right version of LLVM. after that it’s not hard to use it.
11:08:22 <michi7x7> merijn: Does GHC need a C compiler for building?
11:08:47 <EvanR> so after thinking about it, "a compiler translates source code into object code (code in another language that you do not expect to be able to work with, but will technically work)"
11:08:52 <merijn> michi7x7: For applications? No, well not unless you're using the C FFI
11:08:55 <EvanR> also rules out transpiling as real
11:09:09 <EvanR> and also makes decompiling real
11:09:10 <cocreature> technically GHC uses the C compiler for linking by default
11:09:11 <merijn> michi7x7: The runtime has a significant amount of C code in it, but that's only when compiling GHC itself
11:09:21 <michi7x7> merijn: oh sorry, that's what I meant
11:09:28 <EvanR> "a decompiler translates object code back into source code, or attempts to"
11:09:28 <merijn> cocreature: "uses by default" /= "needs" ;)
11:09:54 <EvanR> "a transpiler is just a compiler"
11:10:34 <ab9rf> what's a cisplier?
11:10:38 <merijn> EvanR: Well, the reason I think decompiler deserves it's own word is that it's not JUST translating machine code into source code. It tries to reconstruct what the original input was. Which is a different task than converting the input to semantically equivalent code in a higher language
11:10:39 * ab9rf runs
11:11:04 <EvanR> tries to get original source code?
11:11:14 <merijn> EvanR: An approximation off
11:11:23 <merijn> EvanR: But yes
11:11:36 <EvanR> and fails
11:11:39 <merijn> EvanR: Because a direct machine code to high level language wouldn't help a reverse engineer figure out what it does
11:11:51 <michi7x7> merijn: well, but comping back to the usecase before. If you have a project written in one language and would like to continue in a different language. You would still call the tools compilers?
11:12:06 <EvanR> even on MOO which gives the exact same code except for whitespace and formatting (its outputs better whitespace and formatting than you could have wrote)
11:12:22 <EvanR> (and comments dont survive)
11:13:09 <merijn> michi7x7: I'm not sure what you mean by "continue" there :)
11:14:21 <michi7x7> merijn: Same program, including all comments, written in a different language. Because of managent decisions or problems with the current framework
11:14:43 <EvanR> now youre talking about a source to source translator
11:14:54 <EvanR> which is different from my revised definition of compiler
11:15:00 <merijn> michi7x7: I don't think the people who insist on the term "transpiler" use them for that
11:15:26 <merijn> michi7x7: Because usually people talk about things like "coffeescript" as being a transpiler
11:15:43 <EvanR> hmm
11:16:02 <maerwald> semantic discussion in #haskell surprise :P
11:16:13 <EvanR> "semantics!"
11:16:20 <maerwald> ...
11:16:29 <michi7x7> merijn: good point, let's forget the word then ^^
11:19:01 <EvanR> technical jargon discussion on freenode, that doesnt end in fits of rage
11:19:04 <EvanR> is what i see
11:19:16 <merijn> EvanR: It means my cause is just!
11:20:26 <EvanR> if you think it doesnt matter... i saw first hand julia get steered away from calling one of their features dependent types
11:20:45 * merijn sighs
11:20:47 <EvanR> by people who argued some technical nonsense argument to them
11:20:51 <EvanR> success
11:21:23 <merijn> So...anyone know how to deal with foreign keys to tables with a composite primary key in persistent?
11:21:24 <saurabhnanda> what's the idiomatic way of writing the quickcheck property? propSmtpConfigJSON :: SmtpConfig -> Bool; propSmtpConfigJSON c = (decode (encode c)) == c 
11:22:11 <MitchellSalad> that looks fine
11:22:20 <MitchellSalad> or 'decode . encode = id'
11:22:39 <MitchellSalad> well, whoops, can't write that
11:22:58 <cocreature> for a short moment I was hoping that this actually works
11:23:05 <MitchellSalad> Lol
11:23:05 <saurabhnanda> MitchellSalad: decoding results in a Maybe
11:23:27 <EvanR> fromJust . decode . encode = id
11:23:40 <EvanR> bawhahaha
11:24:18 <MitchellSalad> \c -> decode (encode c) == Just c
11:24:52 <EvanR> decode (encode c) = Just c
11:24:55 <EvanR> implicit forall yall
11:25:09 <EvanR> and then
11:25:13 <EvanR> decode . encode = Just
11:26:31 <saurabhnanda> ?!
11:26:31 <lambdabot> Maybe you meant: v @ ? .
11:28:08 <EvanR> MitchellSalad's last code seems what youd need for quickcheck
11:30:22 <saurabhnanda> okay
11:41:22 <saurabhnanda> EvanR: that doesn't seem to work
11:42:18 <saurabhnanda> EvanR: anywhere, moved away from the point-free form to make it work.
12:06:36 <t7> i want to model motion of a particle with constant acceleration but with drag/air-resistance force which is inversely proportional to the speed. Is there a way to calculate position as a function of time without iterating (numerically solving is ok)
12:09:14 <ph88^> hi all
12:10:59 <Tuplanolla> You mean directly proportional, right, t7?
12:11:19 <t7> probably 
12:11:33 <ongy> inverse would be more fun though
12:11:45 <Tuplanolla> It's a creeping flow problem and the corresponding differential equation should have a closed-form solution.
12:12:08 <Philonous> You can solve it just by separation of variables
12:12:53 <t7> its too hard
12:13:11 <t7> i think im just gonna use steering behaviors to solve my problem from another direction  
12:13:36 <Tuplanolla> You can use those keywords to find someone else's solution.
12:14:12 <Tuplanolla> @google creeping flow trajectory problem
12:14:14 <lambdabot> http://www.math.nyu.edu/faculty/childres/chpseven.PDF
12:14:14 <lambdabot> Title: Stokes flow
12:17:43 <shapr> Is there some way to get a verbose description of where an orphan instance is defined?
12:20:31 <souzh> chat http://www.midnightchat.eu/ - The Best IRC network : www.grircnet.gr
12:28:10 <Philonous> t7, wolfram alpha can solve it for you: https://www.wolframalpha.com/input/?i=solve+[dv+=+a*dt+-+k*v*dt,v]
12:34:08 <srhb> If I make a dependency range more restrictive, should I bump the C in A.B.C pvp versions? The docs only imply that it's OK to leave it alone if I "allow different dependency range"
12:35:10 <davean> srhb: You don't even need a new version for that
12:37:03 <cocreature> does generics-sop provide some kind of GADT corresponding to its typelevel metadata so that I can avoid making my pattern matches partial?
12:42:31 <srhb> davean: What if I make a change that breaks with some version of a dependency?
12:42:37 <srhb> Bump the C?
12:44:07 <Tuplanolla> Clearly we need metaversion numbers for versioning version numbers, srhb.
12:44:17 <srhb> oooh, there's a (new?) decision making graph on the pvp page!
12:44:19 <srhb> yay
12:44:24 <merijn> srhb: Where?
12:44:59 <srhb> merijn: https://pvp.haskell.org/#decision-tree
12:47:18 <shapr> Does haskell support HTCPCP?
12:48:28 <merijn> shapr: Be the change you want to see in the word!
12:49:45 <cocreature> meh now generics-sop complains about overlapping instances. I guess I’ll just stick to the term level metadata
12:59:26 <kosmikus> cocreature: feel free to send me examples. the whole design of type-level metadata can still be improved.
13:02:34 <shapr> merijn: today's random nerdsnipe was to order coffe in your language of choice, however you define "order coffee"
13:04:09 <merijn> shapr: I'd just pick a natural language ;)
13:05:50 <sm> huh, does makeLenses define a HasX instance for all the X fields ? as in https://www.fpcomplete.com/blog/2017/06/readert-design-pattern#has-typeclass-approach 
13:08:51 <cocreature> kosmikus: so the code I currently have is https://gist.github.com/cocreature/6b83466faab4099e283cf066199958d7#file-fieldbyname-hs-L27. that works fine and I think it’s also not possible to call it with an incorrect type but since I’m using value-level metadata for the pattern matches GHC doesn’t know that and complains about partial pattern matches. I thought I could get rid of that but so far I
13:08:52 <cocreature> haven’t been able to get it to work.
13:09:12 <cocreature> kosmikus: also sorry if I sounded a bit grumpy. I’ve been really happy with generics-sop for the most part so thanks for that awesome library!
13:10:46 <cocreature> I can get rid of the inner partial pattern matches by forcing a type equality of "Code a" but the ADT vs Newtype pattern match is still partial
13:13:38 <tdammers> ok, two controversial thoughts here: 1) version numbers are inherently flawed, 2) metadata is also just data
13:32:35 * hackage Only 0.1 - The 1-tuple type or single-value "collection"  https://hackage.haskell.org/package/Only-0.1 (HerbertValerioRiedel)
13:41:49 <srhb> Is it possible to override transient dependency versions in cabal?
13:41:57 <srhb> Conditionally, even.
13:42:05 <srhb> Egh, it should just be fixed upstream...
13:48:38 <fendor> when using HTF and quickcheck, how can i limit the number of tests for one property?
13:53:27 <Tuplanolla> Wait, `Only`? How is that different from `Identity`?
13:56:34 <cocreature> Tuplanolla: “This type is structurally equivalent to the Identity type, but its intent is more about serving as the anonymous 1-tuple type missing from Haskell for attaching typeclass instances.”
13:58:05 <Tuplanolla> I'm trying to think of a property where they would diverge now.
14:01:44 <dmwit> ?hackage OneTuple -- hvr
14:01:44 <lambdabot> http://hackage.haskell.org/package/OneTuple -- hvr
14:02:15 <dmwit> Also, like other tuples (but unlike Only), OneTuple is boxed.
14:09:07 <jgzhak> traverse Compose [Identity (Just 1),Identity (Just 2),Identity (Just 3)]
14:09:11 <jgzhak> this becomes
14:09:21 <jgzhak> Compose (Identity (Just [1,2,3]))
14:09:23 <jgzhak> this.
14:09:59 <jgzhak> But I am not sure what the intermittant form is like..
14:09:59 <nimo> acro: Hi all, I am trying to write a compiler for a CSS-like language in Haskell. Any recommendation for Lexer and Parser libraries?
14:10:39 <jgzhak> [] <$> Compose (Identity (Just 1)) <> Compose (Identity (Just 2)) <> Compose (identity (Just 3))??
14:13:12 <Rotaerk_> nimo, what about parsec or a variant thereof
14:16:35 <nimo> Thanks Rotaerk_. I will check out parsec. I have used OCaml's ocamllex and ocamlyacc before and am looking for similar tools in Haskell. I have heard about Alex + Happy combo, but not sure which option is better.
14:16:51 <Tuplanolla> The modern version of Parsec is Megaparsec, nimo.
14:17:26 <Rotaerk_> Tuplanolla, is that strictly true, that it's simply better than Parsec, or is it a trade-off
14:17:28 <Rotaerk_> like with attoparsec
14:17:38 <Tuplanolla> It's simply better.
14:17:43 <Rotaerk_> k
14:19:50 <kadoban> As I understand it, parsec is mostly unmaintained, thus megaparsec
14:21:53 <Tuplanolla> Hush! The term is backwards-compatible, not unmaintained.
14:22:31 <EvanR> clearly the only way to keep code from bitrotting is to write it in untyped lambda calculus
14:22:40 <Rotaerk_> lol
14:22:43 <EvanR> that hasnt be updated in like 90 years
14:23:56 <dmwit> jgzhak: "intermittent form"?
14:24:13 <kadoban> Tuplanolla: :)
14:25:14 <dmwit> jgzhak: liftA2 (:) (Compose (Identity (Just 1))) (liftA2 (:) (CIJ 2) (liftA2 (:) (CIJ 3) (pure []))))
14:25:27 <dmwit> CIJ is short for Compose+Identity+Just
14:29:55 <jgzhak> Oh, thanks dmwit
14:30:44 <jgzhak> So, I can't use fmap to reconstruct that step..
14:31:35 * hackage loup 0.0.4 - Amazon Simple Workflow Service Wrapper for Work Pools.  https://hackage.haskell.org/package/loup-0.0.4 (markfine)
14:41:38 <sm> EvanR: I hear stone tablets are better
14:42:27 <sm> I suppose mathematicians will say lambda calculus outlasts stone quite easily, but if we're talking about artifacts..
14:43:00 <Tuplanolla> Compression artifacts are forever.
14:43:07 <Tuplanolla> What a depressing thought.
14:43:59 <Cale> Tuplanolla: https://www.youtube.com/watch?v=QEzhxP-pdos
14:52:05 * hackage sdl2-compositor 1.2.0.7 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.2.0.7 (seppeljordan)
14:55:48 <barcabuona> hey guys anybody got some quick tips as to why ghci is so slow to start?
14:56:08 <barcabuona> i like to use languages in an interactive manner so i will be sticking to ghci a lost
14:56:28 <Tuplanolla> Are you using Windows, barcabuona?
14:57:34 <barcabuona> Tuplanolla: archlinux
14:57:48 <barcabuona> sometimes it just takes a whole lot of seconds to start
14:57:57 <dibblego> do you have a ~/.ghci file?
14:58:09 <barcabuona> dibblego: no
14:58:46 <duckqlz_> barcabuona: how did you install ghci?
15:00:34 * hackage extra 1.5.3 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.5.3 (NeilMitchell)
15:01:31 <Tuplanolla> The next question will be "what linker are you using" and after that I will be out of ideas.
15:01:54 <barcabuona> duckqlz_: it came in the repos
15:02:19 <barcabuona> im thinking maybe everytime ghci is updated the first startup needs to init some stuff
15:02:25 <barcabuona> and arch packages update often
15:02:45 <barcabuona> for example if i get out of ghci now and get back into it right after it's quick
15:03:09 <barcabuona> but i seem to recall this slowness thing happening even when i didn't update, but i may be wrong
15:03:42 <Tuplanolla> That's caused by caching done by the operating system.
15:09:16 <barcabuona> Tuplanolla: what do you mean? the ghci is a very big program or allocates a lot of memory at startup?
15:09:44 <monochrom> It is a big executable to load.
15:09:53 <Tuplanolla> It also likes to link lots of large objects.
15:10:09 <barcabuona> alright thanks
15:10:26 <barcabuona> i noticed because at times it would take like 2-3 seconds or more which was really noticeable
15:10:32 <barcabuona> my pc isnt at all slow
15:10:44 <monochrom> Use SSD. :)
15:10:57 <barcabuona> but when i was like "lets try ghci for this" and then started to do ghci it would take ages.
15:13:28 <barcabuona> also whats the difference between a=5 and let a =5
15:13:56 <monochrom> No longer any difference.
15:14:11 <monochrom> In older versions, the difference was "parse error" and "OK".
15:18:28 <barcabuona> alright so ill just ignore let
15:18:52 <barcabuona> except maybe let in but coming from ocaml i really like where
15:57:32 <esad> how can I match several patterns at once? case Foo, Bar -> ...
15:58:05 <monochrom> No, you'll have to separate them.
16:00:05 <esad> can they still return the same expression?
16:00:28 <lyxia> case (x, y) of (Foo, Bar) -> ...
16:01:24 <esad> sorry, I meant I need one catch all case that lists all unhandled constructors
16:01:34 <esad> I want to avoid using _ not to lose exhaustiveness check
16:02:31 <lyxia> oh. That's or-patterns, which aren't yet in Haskell. https://github.com/ghc-proposals/ghc-proposals/pull/43
16:03:05 <lyxia> (and won't be for a while)
17:13:07 <johnw> does anyone have a pointer to Lambek's 1980 paper on lambda calculus and CCCs?
17:13:13 <johnw> I can find references, but nowhere hte source
17:18:37 <EvanR> mkdir shapes. cp -r * shapes/
17:18:53 <EvanR> cp: shapes/shapes/shapes/shapes/shapes/shapes/shapes/shapes/shapes/shapes/sh... ...: name too long (not copied)
17:19:43 <EvanR> ok, it crashes half way through, now i have looks like 100 deep recursive copy of half the same files
17:20:09 <monochrom> rm -r shapes
17:20:17 <monochrom> That will end your trouble. :)
17:20:35 <EvanR> hopefully
17:20:51 <EvanR> im really surprised that happened
17:23:31 <EvanR> so if i show a list of shapes, i get [△,□,○]
17:23:47 <EvanR> can i get that to display as △□○ somehow with Show
17:24:10 <monochrom> concatMap show list
17:24:30 <EvanR> i guess i need a dedicated list-of-shape type
17:24:33 <Tuplanolla> No. Define `showList`.
17:24:37 <EvanR> oh
17:24:43 <EvanR> :t showList
17:24:44 <lambdabot> Show a => [a] -> ShowS
17:25:15 <Tuplanolla> How did you think `Show [Char]` works?
17:25:52 <EvanR> magic
17:26:18 <Clint> all haskell is magic
17:30:59 <EvanR> triangle is "\226\150\179" in utf8, not the most efficient way to send a shape i guess
17:31:37 <jbalint> any ideas how i can fix this? the code is from ~2009 https://pastebin.com/MyZcCLuN
17:31:48 <johnw> or foldMap . map show
17:32:00 <johnw> actually, just concatMap
17:32:06 <johnw> as monochrom said
17:32:21 <EvanR> right showList is more convenient turns out
17:32:57 <monochrom> Show has never been intended to be efficient.
17:34:10 <monochrom> If it were, the Show instance for Int would use only two pixels, because they have enough colours to convey 64 bits of information.
17:34:30 <EvanR> 16 million?
17:34:47 <EvanR> oh two pixels
17:35:00 <EvanR> > 2 ^ 48
17:35:02 <lambdabot>  281474976710656
17:35:02 <monochrom> As opposed to the gross possibility of thirty-something bytes for you lowly humans.
17:36:37 <EvanR> ive got one, you only need 1 16-bit sample to encode 64k different values and send it over the air as a certain kind of pop!
17:37:07 <EvanR> > 44100 * 65536
17:37:09 <lambdabot>  2890137600
17:38:28 <EvanR> er, 2 ^ (44100 * 16) possible values per second
17:47:23 <ab9rf> yes, i can distinguish #10ffdc from #09ffdc
17:47:28 <ab9rf> can't you?
18:05:05 * hackage foldl-statistics 0.1.4.5 - Statistical functions from the statistics package implemented asFolds.  https://hackage.haskell.org/package/foldl-statistics-0.1.4.5 (AlexMason)
18:06:34 <godfreygyz> hey folks
18:06:54 <tomleb> Trying to use general auth from Servant. I'm having trouble anyone got some experience ?
18:08:23 <godfreygyz> is it possible to determine whether two elements of same type equals without giving it Eq property ?
18:08:31 <Axman6> Many of us have experience with problems, but without any details we don't know if you've had your problem :)
18:08:42 <Axman6> also, #servant is a good place to ask too
18:09:12 <Axman6> godfreygyz: that can be done using Generic, but I'm not sure what that would buy you on top of just haveing an Eq instance
18:09:40 <kadoban> godfreygyz: For a specific type or types, sure, but it's pretty much just giving a different name to (==) for ones you have enough exposed about the type to implement yourself.
18:10:09 <godfreygyz> is it possible to write a function like this?
18:10:17 <godfreygyz> elem :: a -> [a] -> Bool
18:10:24 <Axman6> not generally, no
18:10:44 <Axman6> because a might be Void, for example, which has no (non-bottom) inhabitants
18:11:08 <Axman6> or it might be (a -> b) and there's no general way to test if two functions are the same
18:11:31 <godfreygyz> true
18:11:55 <godfreygyz> yeah that makes sense
18:11:59 <tomleb> Axman6: Alright thanks :p
18:12:11 <Axman6> so, you need Eq, or something like it, to constrain a to values which you can check if they are the same
18:12:12 <godfreygyz> thanks XD
18:12:25 <godfreygyz> yeah yeah
18:12:30 <Axman6> you're going to need _some_ constraint
18:12:39 <godfreygyz> you can't compare two things that are uncomparable
18:12:42 <Axman6> tomleb: what problem are you having?
18:13:05 <Axman6> godfreygyz: well, more you can't compare two things if you don't know they can be compared, and that's what Eq tells you
18:13:23 <jared-w> So... It's totally possible to write that function. Axman6 is getting at that you can't write one with that /exact/ type signature. However, you can definitely write one that conveys that idea
18:13:29 <godfreygyz> And that's the fabulous part of haskell ;)
18:14:17 <jared-w> elem is taking an item and seeing if it exists in a data structure
18:14:18 <tomleb> Axman6: #servant
18:14:39 <tomleb> I can paste it here aswell if you prefer
18:14:42 <Axman6> you could use reallyUnsafePointerEquality if you're happy for it to be non-deterministic :)
18:15:03 <EvanR> reallyUnsafePointerEquality o_O
18:15:29 <kadoban> Sounds like a good time
18:15:30 <monochrom> Don't pretend that you don't wish for it :)
18:15:47 <EvanR> hell no
18:15:51 <EvanR> had enough of that in C++
18:15:55 <godfreygyz> lol
18:15:59 <godfreygyz> what's that
18:16:00 <godfreygyz> link?
18:16:26 <godfreygyz> is that possible in haskell ?
18:17:26 <monochrom> GHC exposes it as a backdoor, but (and therefore) it comes with much weaker guarantee than you would find in imperative languages.
18:17:32 <jared-w> Anything is possible in Haskell if you throw enough Unsafe stuff at it
18:18:02 <johnw> unsafeUnsafety
18:19:28 <pikajude> bulwerLyttonHaskellFunctionNameContest
18:20:09 <nshepperd_> unsafeDoWhatIMean
18:20:23 <jared-w> unsafeDoWhatISaidAndIHopeToGodItsWhatIMeant
18:20:39 <pikajude> ok i think it's time to move this somewhere else
18:20:54 <monochrom> Yes. The acme hierarchy. :)
18:23:09 <jbalint> what is the type param here https://hackage.haskell.org/package/haskell-src-exts-1.19.1/docs/Language-Haskell-Exts-Syntax.html#g:7
18:24:50 <geekosaur> an "annotation type". looks like it's there for you to use for whatever
18:25:23 <jbalint> thx
18:26:30 <geekosaur> -- All nodes in the syntax tree are annotated with something of a user-definable data type. When parsing, this annotation will contain information about the source location that the particular node comes from.
18:27:08 <geekosaur> so when using it with the parser, l is a location defined by the parser. otherwise it's yours for whatever purpose
18:28:54 <jbalint> i see
18:31:21 <jchia1> I'm doing runST inside an IO. When some unexpected condition is encountered within the ST, I want the IO to fail. Is there a more straightforward way to express this than to make my ST return an Either String a (String for the IO error message, a for the actual value that the ST computes)? I can't just fail inside the ST.
18:32:45 <kadoban> jchia1: I don't think there's a way around that. To me that sounds like where I'd just use IO throughout though, is that a bad option for some reason?
18:34:08 <nshepperd_> ExceptT (ST s)?
18:35:50 <leshow> has anyone used system.fsnotify before?
18:35:55 <jchia1> kadoban: I suppose I could use IO uniformly. Using ST would ensure I don't do any IO while doing the ST calculations, though.
18:36:31 <leshow> https://hackage.haskell.org/package/fsnotify-0.2.1/docs/System-FSNotify.html i'm not sure what forever $ threadDelay xxxx is doing. the comment says 'sleep forever' but there's a timer
18:37:37 <EvanR> if it ever wakes up, it goes back to sleep, see docs for forever
18:37:39 <EvanR> or the source code
18:37:42 <EvanR> @src forever
18:37:42 <lambdabot> forever a = let a' = a >> a' in a'
18:37:57 <EvanR> forever a = a >> forever a
18:38:01 <leshow> if it goes back to sleep, wont it stop watching?
18:38:12 <kadoban> jchia1: Fair enough. Though unless there's a quite large amount of ST calculations, the gain seems fairly small. But then the inconvenience of  Either String a is pretty small too, I dunno.
18:38:18 <EvanR> threadDelay has nothing to do with the watches
18:38:36 <Cale> If you want a more inconvenient solution, you could always write a function whose signature looks like (Monad m) => (a -> m (r a)) -> (r a -> m a) -> (r a -> a -> m ()) -> m ...
18:38:49 <EvanR> your watch callbacks are happening in another thread entirely right
18:38:57 <Cale> well, perhaps there should be some foralls in there :)
18:38:59 <Cale> haha
18:39:03 <kadoban> leshow: The comment for watchDir says "in the background", which I assume means it's in a separate thread. Meaning this thread with the forever just isn't really involved.
18:39:09 <Axman6> leshow: that's just making sure that the main thread doesn't immediately terminate after the watchDir call (which I assume uses forkIO
18:39:28 <leshow> oh right, i see the fork call in the src
18:41:05 * hackage twitter-conduit 0.2.2.1 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.2.2.1 (TakahiroHimura)
18:41:35 <Cale> @let data RefOps r m = RefOps { newRef :: forall a. a -> m (r a), readRef :: forall a. r a -> m a, writeRef :: forall a. r a -> a -> m () }
18:41:36 <lambdabot>  Defined.
18:41:55 <Cale> @let ioRefOps = RefOps newIORef readIORef writeIORef
18:41:57 <lambdabot>  .L.hs:163:19: error:
18:41:57 <lambdabot>      • Variable not in scope: newIORef :: a -> m (r a)
18:41:57 <lambdabot>      • Perhaps you meant one of these:
18:42:29 <Cale> @let ioRefOps = RefOps (Data.IORef.newIORef) (Data.IORef.readIORef) (Data.IORef.writeIORef) -- maybe? Probably not.
18:42:30 <lambdabot>  .L.hs:164:13: error:
18:42:30 <lambdabot>      Not in scope: ‘Data.IORef.newIORef’
18:42:30 <lambdabot>      Perhaps you meant ‘Data.STRef.newSTRef’ (imported from Data.STRef)
18:42:38 <Cale> well, we can do ST :)
18:42:50 <Cale> @let stRefOps = RefOps newSTRef readSTRef writeSTRef
18:42:52 <lambdabot>  Defined.
18:42:56 <jared-w> My kingdom for local scoping within modules...
18:42:58 <Cale> :t stRefOps
18:42:59 <lambdabot> RefOps (STRef s) (ST s)
18:44:18 <Cale> @let incr :: (Monad m, Num a) => RefOps r m -> r a -> m (); incr o r = do v <- readRef o r; writeRef o r (v+1)
18:44:19 <lambdabot>  Defined.
18:44:37 <Cale> You can write code which is polymorphic in the type of references you're using like this
18:44:43 <Cale> If you really want :)
19:07:05 <iqubic> Hello folks
19:07:17 <iqubic> :t runContT
19:07:18 <lambdabot> forall k a (m :: k -> *) (r :: k). ContT r m a -> (a -> m r) -> m r
19:07:32 <iqubic> What??
19:07:35 <iqubic> How does that work
19:07:44 <iqubic> I mean, I know how that works.
19:08:25 <iqubic> I get exactly how that works.
19:08:43 <EvanR> you cant explain it
19:08:43 <iqubic> :t Free
19:08:44 <lambdabot> error: Data constructor not in scope: Free
19:08:55 <iqubic> EvanR: What do you mean I can't.
19:09:00 <EvanR> its a miracle
19:09:09 <iqubic> It's used for providing callbacks in code.
19:09:35 <EvanR> wait... you do get exactly how that works ?
19:09:43 <butter_the_buddh> ghc optimises for tail recursion right?
19:09:50 <iqubic> Yes.
19:10:17 <EvanR> do you mean to ask about tail call optimization
19:10:22 <iqubic> forever a = do a; forever a
19:10:27 <EvanR> which doesnt necessarily involve recursion
19:10:29 <iqubic> That will never overflow.
19:10:42 <iqubic> :t forever
19:10:44 <lambdabot> Applicative f => f a -> f b
19:11:10 <iqubic> :t until
19:11:11 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
19:11:17 <iqubic> :t while
19:11:18 <lambdabot> error: Variable not in scope: while
19:11:40 <EvanR> since haskell is lazy, many things you expect to use a call stack do not, including tail calls
19:11:44 <geekosaur> butter_the_buddh, that's something of a meaningless question. in one sense all calls are tail calls.
19:11:49 <iqubic> What the heck is the free monad?
19:11:54 <geekosaur> in another, there is no call stack to optimize
19:12:05 <geekosaur> there is a pattern stack which is a different thing entirely
19:12:08 <iqubic> Is there such a thing as FreeT?
19:12:23 <butter_the_buddh> geekosaur: wait what?
19:12:43 <geekosaur> Haskell evaluation is graph reduction
19:12:53 <iqubic> Oh, so it is.
19:12:56 <geekosaur> it is *not* *procedural*
19:13:01 <Clint> iqubic: at least two different implementations
19:13:02 <iqubic> It's functional
19:13:05 <butter_the_buddh> I need to read up on that
19:13:11 <iqubic> Clint: for FreeT
19:13:13 <iqubic> ??
19:13:14 <geekosaur> and everything you think you know about how code gets executed is wrong
19:13:14 <Clint> yes
19:13:30 <LordBrain> EvanR, if you're going to talk about tail call optimization, in the same sentence as lazy, you might want to put forth the caveat about build up of thunks
19:13:58 <butter_the_buddh> geekosaur: So non-tail recursive recursion doesn't use more memory than tail recursion?
19:14:03 <iqubic> Clint: What packages provide FreeT?
19:14:27 <Clint> iqubic: free, control-monad-free, transformers-free, for-free
19:14:31 <nshepperd_> @hackage free
19:14:31 <lambdabot> http://hackage.haskell.org/package/free
19:14:35 <iqubic> Why so many?
19:14:44 <geekosaur> butter_the_buddh, as there is no recursion in that sense, it can't. there is no call stack.
19:14:59 <iqubic> But more specifically, how does the FreeT Monad work?
19:15:04 <geekosaur> when reducing a graph node, it jumps to associated code, which jumps back to the reduction engine.
19:15:18 <iqubic> What does the data declaration of FreeT look like?
19:15:24 <geekosaur> the stack is a pattern scrutinee stack, which *can* use memory --- but it does so differently from a call stack
19:15:27 <iqubic> Data FreeT = ...
19:15:31 <EvanR> look it up
19:16:03 <geekosaur> "I need to reduce this node, but to do it I need to reduce this other node first, so put the first node on the pattern stack and go reduce the other node"
19:17:14 <LordBrain> even c compilers have tail call optimization these days, so its the expectation i think that there isn't a huge call stack.. so laziness actually causes a 'stack of thunks' so to speak and defies that expectation... but if you make sure its strict then it is fine... how good is strictness analysis, i dont know.
19:17:16 <geekosaur> the difference between these is why foldr doesn't cause stack overflows, which it might in a non-tail-recursive procedural implementation, but foldl can cause them if things aren't strict enough
19:18:38 <butter_the_buddh> That doesn't make a whole lot of sense to me right now but I definitely wanna read up on that concept - is there a good book about it?
19:18:55 <geekosaur> @google spineless tagless g-machine
19:18:56 <lambdabot> https://stackoverflow.com/questions/11921683/understanding-stg
19:19:05 <geekosaur> hm, not what I was looking for.
19:19:24 <LordBrain> foldr is useful butter_the_buddh when you want to possibly short circuit an operation
19:19:30 <geekosaur> the original STG paper describes how ghc's graph reduction works
19:19:32 <nshepperd_> GHC optimises tail calls by the cunning optimization of already being an architecture where you don't need to optimise tail calls
19:19:32 <Cale> Neither foldl nor foldr typically use the stack very much, but the expressions they construct may result in lots of stack usage.
19:19:37 <Cale> (in both cases)
19:20:40 <geekosaur> I should also  mention that there is something conceptually similar to a tail call in monadic expressions, which we sometimes talk about (and thus introduce confusion after telling people that tail calls aren't relevant in Haskell...)
19:20:48 <geekosaur> well, can be
19:21:08 <geekosaur> like for "forever" that was mentioned a bit earlier, which reinvokes itself
19:21:32 <butter_the_buddh> I haven't learnt about monads yet
19:21:43 <Cale> Tail recursion is still a thing, it's just that tail recursion optimisation doesn't really make sense in the context of an evaluator which works fundamentally differently and doesn't have something very recognisable as a call stack.
19:21:57 <LordBrain> these days you might as well learn applicative functor first, then go on to monad
19:21:57 <butter_the_buddh> I'm on the Higher Order Functions chapter of learn you haskell
19:23:17 <pacak> > foldl 
19:23:19 <lambdabot>  error:
19:23:19 <lambdabot>      • No instance for (Typeable b0)
19:23:19 <lambdabot>          arising from a use of ‘show_M359151423666845867822662’
19:23:23 <pacak> > foldl (+) [1..1000000]
19:23:25 <lambdabot>  error:
19:23:25 <lambdabot>      • No instance for (Typeable t0)
19:23:25 <lambdabot>          arising from a use of ‘show_M848693660665727634822673’
19:23:32 <pacak> > foldl (+) [1..1000000] 0
19:23:34 <lambdabot>  error:
19:23:34 <lambdabot>      • Could not deduce (Num (t0 [t1]))
19:23:34 <lambdabot>        from the context: (Num [t1],
19:23:46 <pacak> > foldl (+) 0 [1..1000000]
19:23:48 <lambdabot>  *Exception: stack overflow
19:23:54 <pacak> yay
19:23:55 <MarcelineVQ> :<
19:24:20 <pacak> > foldl' (+) 0 [1..1000000]
19:24:22 <lambdabot>  500000500000
19:24:30 <pacak> foldl is bad.
19:25:04 <LordBrain> does anyone have a valid use for foldl without the ' ?
19:25:43 <glguy> It's more efficient to use foldl than foldl with a data constructor as the function
19:25:58 <EvanR> i used it to fold stuff from the end of the list first
19:26:13 <EvanR> in an experiment that never worked out for different reasons
19:26:18 <glguy> and if the function argument is lazy in the first argument then it can avoid doing work
19:26:29 <Cale> LordBrain: reverse is the main example
19:26:39 <Cale> Though actually, they're not really different there
19:27:09 <Cale> because GHC isn't going to enter the constructors anyway
19:27:26 <glguy> Doesn't stop it from trying
19:27:33 <pacak> EvanR: Isn't it going to make a bunch of thunks anyway?
19:27:33 <Cale> glguy: Does it try?
19:27:41 <glguy> yeah, runs just a bit slower
19:28:04 <Cale> I seem to recall monochrom telling me that it actually doesn't, but who knows, I imagine the status of that might change between versions of GHC.
19:28:06 <EvanR> pacak: anyway?
19:28:23 <glguy> criterion could see the difference last time I tried
19:28:36 <EvanR> foldl is easier than foldr ... . reverse
19:28:43 <Cale> Also, foldl will often become equivalent to foldl' if you have -O turned on, due to strictness analysis
19:29:36 <nshepperd_> The next question is: is foldr' ever a good idea
19:29:42 <Cale> Pretty much no
19:29:49 <Cale> Not for *lists* anyway
19:30:05 <iqubic> But perhaps for other instances of Foldable?
19:31:00 <LordBrain> what? i thought foldr is very useful for short curcuits
19:31:12 <glguy> LordBrain: The question is foldr', not foldr
19:31:13 <jared-w> The rule of thumb is "lazy in the spine, strict in the leaves"
19:31:28 <LordBrain> oh
19:31:31 <jared-w> foldr' is strict in the spine, so it breaks the rule of thumb
19:31:33 <iqubic> Yeah, but a list has no leaves, just a big spine.
19:32:02 <iqubic> So don't ever use folr' for a list
19:32:07 <EvanR> > last [1, 2, 3, undefined, 4, 5]
19:32:09 <jared-w> foldl' is strict in the spine, but it goes from the "back" of the list so you have to traverse the entire list before you even start doing anything, so it ends up that you want to use foldl'
19:32:09 <lambdabot>  5
19:32:13 <EvanR> beg to differ
19:32:25 <glguy> iqubic: The list elements are the leaves
19:32:45 <jared-w> Lists have leaves, they don't have "branches"
19:33:04 <iqubic> So a list is a flat tree, that is all leaves.
19:33:12 <iqubic> Oh. I see now.
19:33:34 <glguy> It's a right-leaning tree
19:33:46 <jared-w> Right. That's why "toList" is so convenient for lots of things
19:36:00 <tombert> howdy all; I have a stream where I take binary data from FFMpeg and have it outputing to a conduit bytestring stream.  w
19:36:02 <glguy> For something like: foldl (\acc x -> x ++ acc) []   where merely seqing acc doesn't do all that much you might as well just use foldl
19:36:20 <tombert> I'm trying to send it as a response using the Wai-conduit library
19:36:40 <tombert> but I do not know how to convert my bytestring conduit to a Flush Builder conduit
19:39:07 <tombert> my code for this is here: https://pastebin.com/Ln1VcFV9
19:39:30 <mac10688> hi guys, I'm going through Simon Marlow's book about parallel and concurrent programming in haskell.
19:39:54 <mac10688> I ran a piece of code that should be ran in parallel but looking at threadscope, it doesn't appear to be parallel
19:39:55 <mac10688> http://imgur.com/a/cfbQ4
19:40:07 <mac10688> can anyone tell me if it's being ran in parallel?
19:40:18 <Axman6> how are you compiling and running the code?
19:40:56 <mac10688> thanks Axman6 I think you hit it
19:41:08 <mac10688> oh wait nvm
19:41:23 <mac10688> i'm doing ghc -)2 strat.hs -threaded -rtsopts -eventlog
19:41:32 <mac10688> -O2*
19:41:41 <leshow> +RTS -Nx
19:41:54 <leshow> when you run, will let you pick how many threads to run
19:41:58 <Axman6> (or just +RTS -N)
19:41:58 <leshow> where x in some number
19:42:18 <leshow> Axman6: how does -N pick how many threads to run?
19:42:57 <mac10688> +RTS when i compile or when I run it?
19:43:07 <Axman6> when you run
19:43:08 <LordBrain> run
19:43:38 <wespiser> hey gang, n00b question, how do I generate a crytologically secure random string in Haskell?
19:43:42 <Axman6> leshow: I believe it's just the number of cores available. the docs will probably tell you more though
19:44:01 <LordBrain> wespiser, there's options...
19:44:02 <tombert> wespiser: I usually stream from `/dev/random`
19:44:05 <mac10688> i ran it using ./strat +RTS -N2 -l
19:44:20 <Axman6> wespiser: do you need a String? or a ByteString?
19:44:37 <tombert> wespiser: https://github.com/Tombert/password_generator_2/blob/master/app/Main.hs
19:44:41 <LordBrain> wespiser, if you want it to be reproducible, then use Vincent's MonadRandom from cryptonite package, i guess.
19:44:42 <wespiser> I'm generating a token for a web server, so either will do
19:44:52 <Axman6> mac10688: I'm not sure if your parPair is right, IIRC there should probably an rseq or something in there
19:44:53 <mac10688> http://imgur.com/a/QNswV
19:45:10 <Axman6> (usually the last rpar should be rseq IIRC)
19:45:14 <wespiser> password_generator looks good, i need to make an api key for people to interact with my service
19:45:25 <LordBrain> that is if you dont mind a batteries included pacakage which brings in a lot of dependencies
19:45:40 <mac10688> Axman6, I got the code straight from a download the book told me to pull down
19:45:49 <Axman6> oh also, when printing that pair, print will try to immediately try to evaluate the first argument
19:46:18 <Axman6> yeah I may be wrong about the parPair thing
19:46:38 <mac10688> in that last imgur, is it using 2 cores now? I see a HEC 0 and a HEC 1 now
19:46:52 <mac10688> i guess HEC 0 is for some garbage collection?
19:47:04 <LordBrain> there was an earlier interface to generating cryptorandom stuff that handled the exhaustion of entropy situation better.. but Vincent wasn't convinced and rewrote it all
19:47:44 <LordBrain> but so much stuff uses Vincent's code, that its hardly worth fighting
19:47:52 <wespiser> LordBrain: entropy exhaustion is exactly what I'm worried about: i'm using randomRIO now 
19:48:31 <LordBrain> well if you are good enough with /dev/random, then what he provides will be fine
19:49:01 <Axman6> wespiser: that's not cryptographically secure at all IIRC
19:49:46 <mac10688> thanks for your help Axman6 and leshow, I feel good past this now. Just wanted to make sure I wasn't missing something
19:50:06 <wespiser> Axman6: /dev/random is not secure for generating tokens for web sessions or api keys?
19:50:32 <Axman6> randomRIO is not secure I meant
19:50:34 <LordBrain> /dev/random behaves different on bsd than linux
19:50:50 <LordBrain> i forget the ins and outs
19:50:51 <wespiser> Axman6: ah yes, thanks!
19:50:56 <Axman6> isn't /dev/urandom usually a better choice? I don't remember what the difference is though...
19:51:17 <tombert> /dev/urandom doesn't block; I think it's still considered cryptographically sound
19:51:19 <LordBrain> i forget too
19:51:30 <wespiser> yea, I'll look into this, i owe my potential users due dillegence 
19:51:34 <LordBrain> its sound, but depends on platform
19:51:37 <jared-w> It really depends on how paranoid you are about randomness
19:51:54 <tombert> I mean, the code I sent would be trivial to change to /dev/random instead of /dev/urandom
19:51:55 <Axman6> tombert: IIRC that may depend on which OS you're on
19:51:58 <jared-w> /dev/random or /dev/urandom are "sufficient" for anything not requiring security-clearance levels of security
19:52:13 <jared-w> (or for things that won't exhaust your laptop's entrophy)
19:52:34 <jared-w> For major things you'll likely want a hardware pseudorandom generator. You can buy them. That's out of the scope of most things, though :p
19:53:05 <wespiser> okay, I'm not storing state secrets, just trying to create a platform for multi armed bandits/ab tests
19:53:09 <tombert> yeah, I think that unless you're getting into, like, "I'll be arrested if this is broken" territory, /dev/random is fine
19:53:34 <LordBrain> /dev/random blocks on linux tho if it runs out of entropy
19:53:48 <wespiser> yea, the measuring stick, for me is, "is this secure enough to protect credit card info?"
19:53:55 <jared-w> eh, you're not going to run out of entrophy unless you horrifically abuse /dev/random wrong
19:54:10 <Axman6> or run an java app in docker...
19:54:14 <LordBrain> and /dev/urandom just generates more entropy, its cryptographically secure and doesnt block
19:54:23 <Axman6> (I think that's what triggered some pretty nasy behaviour anyway)
19:54:33 <wespiser> If I am abusing /dev/random, then I have a very good problem!
19:54:53 <LordBrain> depending on how your system is set up, you could run out of entropy
19:55:02 <Axman6> wespiser: I would leave protecting credit card info to others though, it's not worth the risk to do it yourself :)
19:55:09 <wespiser> okay
19:55:16 <LordBrain> i vote /dev/urandom
19:55:24 <wespiser> i'm ignorant on the topic, and its not important right now
19:56:00 <wespiser> yea, i like /dev/urandom, I can actually plug that code sample into my existing token gen code pretty well
19:56:19 <jared-w> Yup. If you don't care, just use /dev/random (easier to google). If you care, use /dev/urandom. If you have a government-level need for encryption, hire a consultant to implement encryption for you
19:56:57 <wespiser> lol, so you're saying, don't implement my own random number generator ?
19:57:10 <tombert> well, not for anything you need to be secure
19:57:14 <tombert> might be a fun project on the side
19:57:16 <jared-w> No, I'm saying don't /ever/ implement your own random number generator
19:57:33 <n_blownapart> hello I do not understand the evaluation of the lambda calculus between step d and e here: https://nopaste.me/view/4b7895e4
19:57:47 <jared-w> You need PhD levels of math to do it correctly. People spend their entire lives studying esoteric number theory to improve existing solutions by a fraction of a percent in security levels
19:57:56 <n_blownapart> there are notes that are throwing me off ^
19:58:46 <wespiser> I know a couple folks doing crypto stuff for ethereum, I'm not entirely convinced implementing your own protocols is not worth it
19:59:29 <Axman6> bleh, lambda calculus needs more syntax highlighting
19:59:43 <LordBrain> maybe those ph.ds should figure out how to make test suites while they're at it, because what? we need implementers.
19:59:50 <n_blownapart> it needs something..
20:00:09 <wespiser> jared-w: sorry, btw, that comment on roll my own was suppose to be sarcastic. I'm going with a /dev/urandom approach akin to this w/o conduit https://github.com/Tombert/password_generator_2/blob/master/app/Main.hs
20:00:17 <jared-w> good :p
20:00:39 <Axman6> n_blownapart: yeah I can't see what's happened in that step either, it feels like a mistake
20:01:18 <wespiser> i think it would be a really satisfying project to implement your own protocol for a business application, the ethereum network has opened up a ton of great jobs for Haskellers
20:01:26 <LordBrain> having very few algorithms would just make it easier for the nsa to ensure they're all backdoored
20:01:28 <n_blownapart> Axman6, thanks did you look at the notes?
20:01:30 <wespiser> by "own protocol" I mean someone elses
20:01:53 <tombert> not to belabor a point too much, but I'm going to repeat my previous query; I have an ffmpeg stream from stdout that I'm reading as a a conduit stream.  I'm trying to send it to wai-conduit, but it gives me an error saying that bytestring isn't compatible with `Flush Builder`.  How do I go about converting a binary conduit to a conduit of Flush Builder? Example code: https://pastebin.com/Ln1VcFV9
20:01:55 <n_blownapart> line 18 is throwing me off
20:02:17 <n_blownapart> https://nopaste.me/view/4b7895e4
20:02:25 <geekosaur> looked fine to me
20:03:10 <Axman6> oh actually d-e is just evaluating (λx.z)(z1)
20:03:13 <geekosaur> the z1 can't be reduced, move rightward and see (\x.z)z1 which you apply, in effect replacing z1 with z (because that is what \x.z does, consume something and reduce to z)
20:03:24 <n_blownapart> how is \x.z applied to z1?
20:03:50 <geekosaur> z1 becomes x. x is not used and z is produced, so the result of (\x.z)z1 is z
20:04:01 <LordBrain> i have an improved version of randomsound on my github if anyone wants to feed sound card noise into their entropy pool when it runs low
20:04:38 <`Guest00000> how is seq implemented for functions?
20:04:47 <Axman6> "magic"
20:04:58 <Axman6> the answer to "How is seq implemented" is "magic"
20:05:06 <Axman6> it can't be written in Haskell
20:05:20 <n_blownapart> doesn't the bound x in \x.z require an x. how can it take a z1? It can take any bound variable ?
20:05:39 <Axman6> > (\x -> z) a
20:05:40 <lambdabot>  z
20:06:04 <LordBrain> lamdabot has definitions for those symbols?
20:06:18 <Axman6> yeah
20:06:23 <Axman6> > z^4
20:06:25 <lambdabot>  z * z * (z * z)
20:06:55 <Axman6> theyr'e of type Expr, can come from... numeric? hmm, can't remember
20:06:56 <LordBrain> thats just a little misleading but okay
20:07:01 <Axman6> !hoogle Expr
20:07:04 <Axman6> @hoogle Expr
20:07:04 <lambdabot> module Text.Parsec.Expr
20:07:04 <lambdabot> module Text.ParserCombinators.Parsec.Expr
20:07:04 <lambdabot> module Text.Megaparsec.Expr
20:07:08 <geekosaur> simple-reflect
20:07:08 <Axman6> hmm
20:07:11 <Axman6> that one
20:07:19 <jared-w> I thought Seq could be written in haskell with a buncha unsafe everywhere?
20:07:20 <MarcelineVQ> LordBrain: misleading?
20:07:21 <LordBrain> :t z
20:07:21 <n_blownapart> hold on sorry I'm off. I thought if \x is going to be applied, the bound or unbound has to match (the x in this case)
20:07:22 <lambdabot> Expr
20:07:41 <geekosaur> jared-w, seq on functions are the one thing you cannot implement in haskell
20:07:42 <Axman6> n_blownapart: no, it's that the name of the argument to the function
20:07:55 <LordBrain> MarcelineVQ, well, those aren't defined by default... they wouldnt work in the newbie's program and all, thats all i mean
20:07:59 <jared-w> ahh okay, cool. TIL
20:08:01 <geekosaur> n_blownapart, no, you can choose to ignore the parameter instead of being forced to use it
20:08:11 <MarcelineVQ> LordBrain: ah
20:08:11 <Axman6> \x.a could be written as (\x -> a) in Haskell, or even (\_ -> a)
20:08:36 <n_blownapart> the explanation in the notes is lame. I cannot see how those steps are carried out
20:09:22 <Axman6> I only figured out what was happening by reading those notes :P
20:09:22 <jared-w> I find (\_ -> a) to be the most illuminating
20:09:36 <Axman6> \iamignored.a
20:09:52 <n_blownapart> -> a ?
20:09:55 <jared-w> The real issue here is that lambda calculus is absolute garbage to readwhen it's smashed together like that
20:10:09 <iqubic> TIL Seq can't be written in pure Haskell code.
20:10:23 <jared-w> \x.a means "I don't care what you give me as an argument, I'm giving you an a"
20:10:34 <n_blownapart> Well in the sicp book I could at least distinguish b/t normal and applicative order in scheme
20:10:38 <Axman6> a"but I need an argument before I can give you an a"
20:10:40 <LordBrain> Seq is not the same... as 'seq'
20:10:44 <LordBrain> heh
20:11:27 <n_blownapart> absolute garbage jared-w . do you mean to do exercises such as these with the formal notation?
20:11:31 <LordBrain> Seq a is a sequence of a, using Data.Map style structure
20:11:48 <LordBrain> nothing to do with 'seq'
20:12:11 <n_blownapart> its not worth it? the book (from first principles) makes a big deal about getting this notation
20:12:50 <Axman6> yeah the spacing of that LC is really pretty awful, makes it very hard to read
20:13:01 <mac10688> so I guess when I compile with the rtsopts flag that means I can run the program with +RTS -N2?
20:13:12 <Axman6> n_blownapart: it;s more a comment about how it is spaced out, not the notation being awful
20:13:19 <Axman6> mac10688: yep
20:13:59 <jared-w> n_blownapart: It doesn't make a big deal about getting the notation
20:14:00 <n_blownapart> Axman6, jared-w ok thanks I also find the \_ -> a helpful
20:14:01 <LordBrain> :t 'a' |-> empty
20:14:02 <lambdabot> error:
20:14:02 <lambdabot>     • Variable not in scope: (|->) :: Char -> f0 a0 -> t
20:14:02 <lambdabot>     • Perhaps you meant one of these:
20:14:25 <LordBrain> i dont know what lamdabot has in scope or doesnt
20:14:29 <jared-w> The point of the chapter is to expose you to the core underlying backbone of Haskell (it's purely lambda calculus)
20:14:32 <Axman6> LordBrain: actually, the Seq structure is quite different to the structure of Data.Map (the former being a fingertree, which is similar to the Data.Map tree, but where you pick the tree up be its edges and let the centre drop down)
20:14:42 <geekosaur> @where L.hs
20:14:42 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
20:14:44 <n_blownapart> it says that the answers are given in the first chapter only so that its certain this notation is understood. jared-w 
20:14:52 <LordBrain> they're not obth fingertrees?
20:15:04 <LordBrain> did they sued to both be fingertree?
20:15:05 <Axman6> no, Data.Map is a balanced binary tree
20:15:12 <iqubic> Wait, "\x.a" is valid haskell syntax?
20:15:19 <LordBrain> did they change it?
20:15:26 <Axman6> iqubic: no
20:15:30 <n_blownapart> its not a criticism, I'm almost home free
20:15:31 <geekosaur> iqubic, no, it is lambda calculus notation
20:15:31 <jared-w> Yeah, they're saying that to make sure you don't get lost because you're not supposed to put a ton of time into learning lambda calculus before getting started with the rest of the book
20:15:34 * hackage mvc 1.1.4 - Model-view-controller  https://hackage.haskell.org/package/mvc-1.1.4 (GabrielGonzalez)
20:15:38 <geekosaur> which is what the question was about
20:15:46 <geekosaur> a translation of haskell syntax was offered as an explanation
20:15:53 <n_blownapart> jared-w, really, thats funny
20:15:56 <geekosaur> because lambda calculus notation can be rather dense
20:16:03 <LordBrain> well technically geekosaur, its a mix, because that's a backslash rather than a lambda
20:16:09 <LordBrain> heh
20:16:23 <geekosaur> yes, but typing a lambda is annoying on here
20:16:31 <n_blownapart> how do type a lambda character in this chat?
20:16:36 <n_blownapart> you*
20:16:41 <iqubic> How can one translate "\x.a" into haskell?
20:16:42 <jared-w> Yeah. I have to explain this on the IRC quite often. I'm considering asking bitemyapp to rewrite the 1.1 section so it doesn't sound so dramatic and intense about "DONT SKIP THIS CHAPTER"
20:16:45 <Axman6> using whatever mechanism your OS provides for writing them
20:16:46 <geekosaur> depends on your client
20:16:58 <Axman6> iqubic: really? :\
20:17:04 <geekosaur> ok, everyone repeat the last 5 minutes for iqubic
20:17:05 <n_blownapart> jared-w, you're the author?
20:17:09 <iqubic> "\_ -> a" is "\x.a"?
20:17:17 <LordBrain> λ
20:17:18 <geekosaur> who never needs to read anything because irc will always do it for them
20:17:24 <LordBrain> λx.a
20:17:34 <iqubic> LordBrain: how did you type that lambda?
20:17:34 <jared-w> No, no, bitemyapp is the author. I'm just someone who's going through the book
20:17:35 * hackage hpack 0.18.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.18.0 (SimonHengel)
20:17:42 <iqubic> And what OS do you use?
20:17:50 <n_blownapart> yeah how did you type it?
20:17:53 <LordBrain> i use rfc1345.mim plugin with ibus-m17n package
20:18:01 <LordBrain> it gives you the vim digraphs
20:18:03 <Axman6> @google how to google things before asking questions
20:18:04 <lambdabot> http://www.giyf.com/
20:18:04 <lambdabot> Title: Google is your Friend
20:18:10 <LordBrain> iqubic, do you use vim?
20:18:10 <Axman6> iqubic: ^
20:19:02 <iqubic> LordBrain: I used to. I still know the keybinds though
20:19:16 <iqubic> I use Evil-Mode and Emacs now.
20:19:19 <LordBrain> in vim, you can type funky characters using control-k in insert mode followed by two keys.. rfc1345 standardized what vim offers and extended it a little, and the ibus-m17n script lets me type them anywhere.
20:19:41 <lolisa> Hi, I am reading Advanced Topics in Types and Programming Languages, on Linear Type.
20:19:43 <LordBrain> i actually dont use the vanilla one tho that comes with the package, i have a modified one
20:19:58 <lolisa> For linear array, the book use operation swap to 'destructively read'. However, it is not really safe, as you need to swap a value back in after read
20:19:59 <LordBrain> but the digraph for greek letters is usually an * following the letter
20:20:02 <jared-w> I prefer using stuff like the AltGr key on Linux
20:20:06 <LordBrain> so "l*" becomes lambda
20:20:11 <iqubic> LordBrain: How do you get the lambda to show up in IRC though?
20:20:14 <LordBrain> "a*" becomes alpha
20:20:21 <iqubic> l*
20:20:25 <LordBrain> its UTF-8
20:20:26 <lolisa> So you cant read an array with parametric type a (Array a), but you can read (Array (Some a)) by swapping a Nothing in
20:20:31 <jared-w> iqubic: Everyone has unicode enabled... So...  It works
20:21:08 <lolisa> And that's the problem: you can only get Option a, but not a! Can array provide some 'safer' interface? I guess something on FreeAlgebra, TermAlgebra will make it work
20:21:20 <iqubic> jared-w: How do you get the AltGr shortcuts to work?
20:21:38 <Axman6> this is really off topic
20:21:55 <LordBrain> iqubic, ibus is for basically allowing you to enter all sorts of foreign languages etc with your given keyboard.. its a keyboard translation program... if you install ibus-m17n, you can turn your keyboard greek if you wanted.
20:21:55 <iqubic> I know, but I want to be able to type all the symbols.
20:22:04 <iqubic> I see.
20:22:04 <Axman6> @google how to write unicode symbols in linux
20:22:05 <lambdabot> https://www.johndcook.com/blog/2008/08/18/entering-unicode-characters-in-linux/
20:22:16 <Axman6> was that so hard iqubic?
20:22:21 <LordBrain> iqubic, what os are you running?
20:22:37 <Axman6> can we at least move this to #haskell-offtopic?
20:22:38 <n_blownapart> jared-w, anyway I'm nearly done with the last example, so \x.a can be written \_-> a. ?    You can plug in anything there to drop the lambda ?
20:22:39 <jared-w> You enable them on your keyboard layout and then use the AltGr key. Look up the US-International layout. Really not super relevant for the channel though. Axman6 has a point, though; most of these questions are trivial to google
20:22:47 <glguy> Axman6: No, you made it pretty easy!
20:23:26 <jared-w> n_blownapart: You plug anything in there and then the lambda function is applied to the argument and it results in 'a'
20:23:44 <iqubic> n_blownapart: basically "\x.a" is a fuction of type "a -> b"
20:23:44 <jared-w> What you're getting at is correct, but the terminology is a little off. Doesn't matter too much, though :)
20:24:43 <jared-w> It's equivalent to the python: def function (x): return a
20:25:42 <LordBrain> in haskell, we have the prelude function const
20:25:52 <drtop> i have quite possibly a vague question, but here it is: is there an example within haskell where a single character attached at the end of a token instructs the compiler to do one thing, whereas the token is taken to mean something else if the last character isn't this symbol?
20:25:52 <jared-w> :t const
20:25:53 <lambdabot> a -> b -> a
20:25:54 <LordBrain> :src const
20:26:02 <LordBrain> @src const
20:26:02 <lambdabot> const x _ = x
20:26:06 <LordBrain> hmm
20:26:11 <n_blownapart> ok thanks kindly jared-w  et al
20:26:50 <LordBrain> const a = λx.a
20:26:59 <Axman6> drtop: you may say that # is that character, but it has a conventional meaning, rather than an actual meaning to the compiler
20:27:03 <Axman6> @src Int
20:27:03 <lambdabot> data Int = I# Int#
20:28:22 <LordBrain> on the beginning of a token we have bang patterns if enabled
20:28:40 <drtop> Axman6: thank you for that! is there anything like this in Template Haskell?
20:29:35 <Axman6> not sure
20:30:37 <n_blownapart> meant to thank you too Axman6 
20:41:15 <Axman6> n_blownapart: no worries
20:42:05 * hackage th-reify-many 0.1.7 - Recurseively reify template haskell datatype info  https://hackage.haskell.org/package/th-reify-many-0.1.7 (MichaelSloan)
20:44:51 <lmapper> hi, is there a bbs style forum that would be suitable for posting longer form questions
20:45:56 <LordBrain> some people use reddit lmapper 
20:46:57 <MarcelineVQ> unless you need longer form answers an lpaste usually suffices
20:47:48 <LordBrain> lmapper, more traditionally, there is haskell-cafe mailing list
20:47:48 <lmapper> Yeah, I often browse haskell reddit, if that's the best place I could post something there
20:49:01 <jared-w> r/haskell is usually the best place if you need some involved and longer answers
20:49:41 <LordBrain> unless you dislike reddit
20:50:08 <LordBrain> i think reddit does a lot of political shenanigans... weird stuff, turns me off
20:51:05 <lmapper> web forums are really popular in the 3d content creation world, almost all questions you'd need to ask are archived already
20:51:28 <lmapper> was just wondering if there was anything in that format for haskell
20:51:35 * hackage alerta 0.1.0.4 - Bindings to the alerta REST API  https://hackage.haskell.org/package/alerta-0.1.0.4 (MarkHopkins)
20:52:10 <lmapper> seems a lot of good information is scattered around on personal websites
20:52:28 <LordBrain> reddit seems like the best match for what you want, even tho i am conflicted about reddit generally
20:53:14 <lmapper> forums usually have a beginner's section, maybe a few other specific sections, so they're nicely focused on what you might be asking
20:53:34 <LordBrain> do they have a haskell section?
20:53:35 <lmapper> I just couldn't bring myself to post anything in reddit yet
20:54:05 <lmapper> I haven't found a haskell bbs style forum
20:55:02 <jared-w> I'm not aware that any exist. Most programming languages exist solely inside reddit, mailing lists, and the like.  ¯\_(ツ)_/¯
20:55:15 <LordBrain> you can check out voat, https://voat.co/v/haskell ... sort of a reddit-alike
20:55:24 <Axman6> personally, I hate finding answers on forums, they're usually really awful pieces of software. at least reddit makes a clear distinction between initial question, and threads of answers which build on each other
20:55:44 <LordBrain> well stack-exchange
20:55:47 <Axman6> LordBrain: isn't voat dead yet? :\
20:55:50 <LordBrain> has a lot of useful stuff
20:55:51 <jared-w> voat? ಠ_ಠ
20:56:18 <LordBrain> maybe its dead, nobody told me
20:56:19 <Axman6> r/The_Donald's favourite reddit alternative
20:56:32 <jared-w> Somehow it's not dead... can't imagine why. The only people still using it are neo nazis and the alt right
20:56:43 <LordBrain> there's another reddit-copy out there too, having trouble recalling its name
20:57:31 <lmapper> ah, well it's bedtime here, thanks guys
20:57:52 <jared-w> LordBrain: Digg? /s
20:57:57 <Axman6> heh
20:58:28 <LordBrain> digg.. hah, thats older than reddit
20:58:49 <LordBrain> does digg have forums?
20:59:13 <LordBrain> googling around i found this: https://news.ycombinator.com/
20:59:34 <LordBrain> advertised as a reddit for tech people only
21:00:59 <jared-w> oh right, that's the other one. Doesn't really have subreddits though
21:01:14 <iqubic> What's the unicode value for a lambda?
21:01:17 <jared-w> It's much more of a news aggregator than anything. No community forming
21:01:25 <jared-w> @google what's the unicode value for a lambda
21:01:27 <lambdabot> http://www.fileformat.info/info/unicode/char/3bb/index.htm
21:01:27 <lambdabot> Title: Unicode Character 'GREEK SMALL LETTER LAMDA' (U+03BB)
21:01:37 <Axman6> yeah hacker news and lobste.rs aren't really reddit alternatives in terms of functionality... also, #haskell-offtopic time I think
21:03:20 <iqubic> λ
21:03:25 <iqubic> I did a thing.
21:03:52 <iqubic> Also, I figured out how to enter unicode characters into any GTK aplication I want.
21:04:13 <LordBrain> come to #haskell-offtopic
21:04:22 <iqubic> λx.a
21:10:20 <glguy> iqubic: Are you using glirc?
21:10:54 <glguy> I didn't know if you switched back, but if you are, λ is the l* digraph, so you can type l* and then Alt-K
21:11:29 <glguy> similarly in Vim it's Ctrl-K l*
21:16:01 <iqubic> glguy: I'm still using glirc
21:16:14 <iqubic> Oh, so that works.
21:16:32 <iqubic> Does that only work with glirc?
21:16:35 <glguy> iqubic: Check out /digraphs to see all the symbols you can type that way, and you can use /grep to search that screen
21:17:29 <glguy> iqubic: It's per program, so you can use it in Vim like I mentioned, probably other programs, too
21:17:47 <iqubic> How do I convert from a symbol to it's digraph?
21:18:09 <glguy> open /digraphs and then /grep λ ; for example
21:18:37 <glguy> All the Greek letters are latin-letter '*'
21:20:24 <iqubic> 
21:20:29 <iqubic> What the heck.
21:21:24 <glguy> iqubic: That's
21:21:28 <glguy> > '\^['
21:21:30 <lambdabot>  '\ESC'
21:23:10 <iqubic> So it looks like esc to you?
21:23:23 <iqubic> I guess my font did weird things to that.
21:23:36 <glguy> It looks like a reverse-video [ to me
21:23:45 <iqubic> Me to.
21:23:58 <iqubic> that's what EC Alt-K gave me
21:24:02 <glguy> because it's the control character that can be written as ^[
21:24:06 <glguy> EC is short for Escape
21:24:13 <iqubic> Yeah, I got that
21:24:58 <iqubic> Ω
21:25:12 <glguy> probably better not to test all the characters out in #haskell though
21:26:06 <iqubic> Can I do it in a private message with Lambdabot?
21:26:17 <glguy> sure, or even just in a chat to yourself
21:26:28 <iqubic> I can chat with myself? How?
21:26:36 <iqubic> ./msg iqubic ?
21:26:39 <glguy> yeah
21:30:35 * hackage gi-gtk-hs 0.3.4.3 - A wrapper for gi-gtk, adding a few more idiomatic API parts on top  https://hackage.haskell.org/package/gi-gtk-hs-0.3.4.3 (HamishMackenzie)
21:34:56 <sophiag> i'm experiencing a very odd issue with haskell-src-exts. i built a project that uses it about a month ago and now the source isn't running in ghci. on closer examination parseExp is returning all this SrcLoc info I never had before. yet there's only been two commits within this time period and none should have changed this behavior at all :/
21:35:35 <sophiag> i use nix to handle my packages so now i'm wondering if i could have been using a super old version on LTS? or reverted to an old version? i did switch to the testing branch, which hasn't been updated in a while due to virtual box issues so am wondering if that could be it. but i'm really grasping at straws here
21:35:58 <iqubic> What is Nix?
21:36:14 <sophiag> nix is a declarative package manager
21:36:25 <sophiag> it's great for haskell development. basically replaces stack
21:36:34 <iqubic> What distro do you use sophiag?
21:36:37 <sophiag> but i'm actually using nixos, which is a whole linux distro based on it
21:36:55 <iqubic> ah, I use Gentoo and have Portage as my package manager
21:37:12 <sophiag> i would strongly recommend nix on any os
21:37:16 <Arcaelyx> Could someone help me out with this? https://ghostbin.com/paste/6p9bc
21:37:29 <sophiag> there's a great youtube video of someone on os x describing how he uses it for haskell development
21:37:30 <Arcaelyx> I'm trying to connect to PostgreSQL wth Haskell and groundhog and nothing seems to work lol.
21:37:39 <iqubic> As a replacement to portage, or in addition to?
21:37:40 <Arcaelyx> I've put the error I get all the way below.
21:37:50 <sophiag> i'm not familiar with portage
21:38:08 <iqubic> It's the Gentoo package manager.
21:38:24 <wespiser> jared-w: LordBrain: thank you for the help tonight, I got token generation from /dev/urandom integrated into my project and I'm off to bed!
21:38:47 <jared-w> no problem. Sleep tight!
21:39:04 <wespiser> jared-w: did you share this: https://github.com/Tombert/password_generator_2/blob/master/app/Main.hs
21:39:05 <sophiag> iqubic: yeah, i looked it up. looks interesting
21:39:12 <iqubic> Should I ditch my current Distro's Package Manager (Portage) in favor of nix? Or should I use the two side-by-side?
21:39:15 <wespiser> anyway, thanks a million
21:39:15 <jared-w> Nix is a replacement of portage when it comes to haskell
21:39:23 <jared-w> I personally don't use it because I use Stack
21:39:45 <iqubic> jared-w: If I want to use Nix, I should replace portage entirely?
21:39:47 <sophiag> for anyone with experience with haskell-src-exts, here's what i'm seeing now: http://lpaste.net/356187
21:39:51 <jared-w> But if I didn't use stack I'd probably use Nix
21:39:57 <sophiag> all that SrcLoc info wasn't there one month ago...
21:40:02 <jared-w> iqubic: no you can use Nix only for the stuff you want to use it with. You can use portage for everything else without issue
21:40:03 <Arcaelyx> Could someone please help me out with this? https://ghostbin.com/paste/6p9bc
21:40:22 <jared-w> What are you having trouble with?
21:40:35 <iqubic> I use stack currently. If I can get any convincing reasons to switch to Nix, then I'll do that.
21:41:06 <iqubic> But not right now, because I have a million things on my todo list
21:41:40 <Arcaelyx> jared-w: I pasted the error below.
21:41:43 <iqubic> Like, updating my system, and switching my input method to one that will let me enter unicode everywhere I want.
21:41:47 <Arcaelyx> I can't connect to the database at all.
21:42:30 <sophiag> iqubic, reasons would include: developing in containers, frequently switching machines, needing multiple dev environments (e.g. running different version of GHC), needing a package manager for emacs, replacing stack...
21:42:51 <sophiag> idk, i basically have two dot files that make up my whole world now: configuration.nix and .emacs
21:44:50 <iqubic> It might be nice to have a good package manager for Emacs, but I'm not sure I want to fully switch over just for that.
21:45:00 <jared-w> I use spacemacs anyway :p
21:45:10 <sophiag> well if that's all you need then you can use use-oackage
21:45:11 <iqubic> I also use spacemacs. Join the club
21:45:17 <sophiag> *use-package
21:46:02 <glguy> hamishmack: Are you going to upload documentation for gi-gtk-hs? Would you like me to?
21:46:37 <hamishmack> Oh does it not get built by hackage?
21:46:54 <glguy> There's no way that hackage will be able to build gi-gtk
21:47:19 <iqubic> No. Because it requires having a working copy of GTK installed, which Hackage lacks
21:48:05 * hackage oanda-rest-api 0.4.1 - Client to the OANDA REST API  https://hackage.haskell.org/package/oanda-rest-api-0.4.1 (jdreaver)
21:48:17 <hamishmack> That is unfortunate.
21:48:39 <hamishmack> glguy: If you could upload it that would be awesome.
21:48:49 <hamishmack> The docs that is
21:48:51 <iqubic> Why is it unfortunate? Haven't you known about this issue for a while now?
21:51:28 <hamishmack> iqubic: I thought it had Gtk now.
21:53:09 <glguy> hamishmack: It might have Gtk, but (conflict: requires pkg-config package gobject-introspection-1.0>=1.32, not found in the pkg-config database)
21:53:55 <hamishmack> What OS is it?
21:54:06 <glguy> dunno
21:54:41 <hamishmack> Might just need libgirepository1.0-dev installed if it is debian or ubuntu
21:57:47 <iqubic> So is NixOS the best Haskell development OS?
21:58:02 <jared-w> "best" is a strong word and is highly subjective
21:58:28 <iqubic> What even is NixOS?
21:58:37 <jared-w> I'd recommend not caring about what "best" is or what the "best" way to do things is. It's more important to learn things than worry about the best way to learn them
21:58:53 <jared-w> NixOS is a linux distro based around the Nix package manager and the concept of deterministic configuration
21:59:04 <sophiag> i would try nix first before thinking about nixos
21:59:22 <iqubic> I'm not going to switch any time soon
21:59:27 <iqubic> Not even to nix
22:00:02 <sophiag> but either way they have a decent sized learning curve so it's the kind of thing you find yourself needing a reason to use and then once you go through a bit of pain it's easier going forward
22:00:21 <dmj`> iqubic: out of curiosity, why
22:00:38 <sophiag> i'm sorry if that makes little sense...it's in the 80s here at 1:00AM and i'm feeling loopy
22:00:42 <LordBrain> i wanted to try nix years ago but there was a build issue
22:01:39 <LordBrain> after messing with it for a while, i decided it wasnt worth it
22:01:57 <LordBrain> i think it was a build issue, might have been a bug
22:02:00 <sophiag> LordBrian: how long did you mess with it?
22:02:02 <LordBrain> something
22:02:19 <LordBrain> something where i was like.. eh, i have debian, i have apt, its working, this is not worth all the headache
22:02:35 <sophiag> i did a move typical of my personality: started installing it on a new laptop two days before i had to move and leave the desktop i was using behind
22:03:02 <sophiag> the first day involved a lot of swearing but by then i had reached the sunk cost fallacy so just had to continue until it was working :p
22:03:12 <sophiag> now i can't imagine living without it
22:03:15 <LordBrain> back then it was newish, they probably worked out the kinks since...
22:03:31 <sophiag> eh...the docs are still not great tbh
22:03:44 <sophiag> and you'll be contributing to packages pretty soon if you use it
22:04:03 <sophiag> also weird hardware integration issues, but that's probably because i have a hand me down gaming laptop
22:04:22 <LordBrain> i wasnt trying nixos, just nix
22:04:29 <LordBrain> nix on debian
22:04:34 <sophiag> i think it's about the same 
22:04:39 <sophiag> as far as learning curve
22:04:41 <LordBrain> which it was advertised that i could do
22:05:14 <sophiag> i'm just running nixos on my personal machine so i don't config much other than packages
22:05:33 <sophiag> oh, and some weird stuff with desktop managers
22:05:46 <sophiag> i find most nixos folks just use xmonad
22:05:57 <sophiag> haven't made the switch yet myself although i have it installed
22:06:09 <sophiag> i have EVERYTHING installed now that i'm on nix :D
22:06:14 <LordBrain> thats too much change all at once heh
22:06:30 <iqubic> I use Xmonad on Gentoo. I like it a lot
22:07:01 <sophiag> yeah, i should ditch gnome
22:07:25 <sophiag> what's the point of window manager when you only use 2-3 windows and do everything from the command line?
22:07:40 <sophiag> 2-3 because even opening a shell outside of emacs is not a daily thing for me
22:07:42 <LordBrain> prettier fonts
22:07:55 <sophiag> nah, you can install fonts with nix!
22:07:57 <Arcaelyx> What's a good Haskell query builder?
22:08:23 <iqubic> So you like NixOS
22:08:24 <cocreature> Arcaelyx: for which db?
22:08:25 <iqubic> ??
22:08:26 <LordBrain> you mean like sql query?
22:08:30 <Arcaelyx> PostgreSQL
22:08:40 <Arcaelyx> I've been trying to use groundhog and it's been the worst.
22:08:47 <Arcaelyx> Can't even get a simple connection up and going.
22:08:56 <wilornel> In: `instance (Semigroup a, Semigroup b) => Semigroup (AccumulateBoth a b) where (AccumulateBoth (MSuccess a)) <> (AccumulateBoth (MSuccess b)) = AccumulateBoth $ MSuccess (a <> b)
22:09:05 <wilornel> `, who says a and b will be of the same type?
22:09:16 <LordBrain> you tried hdbc?
22:09:18 <wilornel> Haskell compiles this without any errors
22:09:27 <cocreature> Arcaelyx: if you’re looking for a simple solution, postgresql-simple will do the job but it will require that you write SQL strings
22:09:37 <wilornel> What if a is of type String and b is of type Product?
22:09:44 <Arcaelyx> I've only tried groundhog at the moment.
22:09:58 <cocreature> Arcaelyx: if you want more type safety there is persistent + esqeleto, opaleye and selda
22:10:14 <Arcaelyx> cocreature: What do you think of groundhog?
22:10:34 <cocreature> I’ve never used it. I mostly use postgresql-simple because I don’t have a problem with writing SQL myself
22:11:15 <kadoban> wilornel: Seems a little funny that that compiles, but yeah that should only be possible to use if a ~ b, right?
22:11:33 <Arcaelyx> Me neither, but that could make it easier to run a SQL injection no?
22:11:40 <dmj`> iqubic: nixos is great
22:11:53 <cocreature> Arcaelyx: no, postgresql-simple automatically escapes parameters
22:12:01 <iqubic> How hard is it to learn nixos?
22:12:02 <dmj`> Arcaelyx: selda is cool, pretty type-safe as well
22:12:06 <dmj`> @package selda
22:12:06 <lambdabot> http://hackage.haskell.org/package/selda
22:12:14 <Arcaelyx> I guess I'll just use Persistent at this point lol.
22:12:20 <wilornel> kadoban: that's right. let me try to quickcheck it!
22:12:26 <iqubic> Also, how hard is it to install and switch to nixos?
22:12:26 <Arcaelyx> Any good documentation links for persistent?
22:13:06 <dmj`> iqubic: it’s more so just learning that language that’s the difficult part, and how derivations are built.
22:13:14 <LordBrain> there's usually a home page link in the haddock page...
22:13:18 <sophiag> iqubic: as mentioned, it's not simple...
22:13:21 <dmj`> s/that/the
22:13:22 <LordBrain> worth checking
22:13:27 <iqubic> Ah. Do you recomend that I switch to nixos?
22:13:30 <sophiag> but there's also very little to learn
22:13:34 <iqubic> What are the benefits of nixos?
22:13:38 <kadoban> Arcaelyx: The yesod book link you should find easily seemed fine last I messed with persistent
22:13:44 <dmj`> iqubic: what OS are you on now?
22:13:49 <Arcaelyx> kadoban: Cool, thanks.
22:14:04 <LordBrain> iqubic, because your nick is iqubic, i think you should use qubes
22:14:09 <sophiag> iqubic: i went through four personal machines in three months. by the end i wanted literally everything to be plug and play. i get that with nixos
22:14:30 <wilornel> Ah well, the `instance (Semigroup a, Semigroup b) => Semigroup (AccumulateBoth a b) where (AccumulateBoth (MSuccess a)) <> (AccumulateBoth (MSuccess b)) = AccumulateBoth $ MSuccess (a <> b)
22:14:39 <iqubic> LordBrain: What is qubes?
22:14:40 <wilornel> the `semigroupAssoc :: (Eq m, Semigroup m) => m -> m -> m -> Bool
22:14:51 <cocreature> Arcaelyx: note that persistent on its own is quite limited. in particular it doesn’t support any kind of join. so you probably want to combine it with esqueleto
22:14:56 <wilornel> ` test is on m == m == m. So I can't really test quickcheck with different types
22:15:45 <LordBrain> iqubic, its basically xen hypervisor with some special glue software thrown on top, so that you run your browser in a separate virtual machine
22:15:46 <Arcaelyx> cocreature: Ah, alright. Thanks!
22:15:47 <iqubic> dmj`: I'd be switching from gentoo to nixos
22:16:13 <iqubic> is that hard to do?
22:16:15 <dmj`> iqubic: I’d recommend just starting with nix, unless you have a lot of free time, then go hog wild.
22:16:23 <kadoban> Why does wilornel's thing compile? The similar thing as a function signature doesn't of course ... a little confused.
22:16:26 <sophiag> iqubic: this would be a good watch: https://www.youtube.com/watch?v=G9yiJ7d5LeI
22:17:09 <glguy> kadoban: What part are you asking about?
22:17:10 <sophiag> it's about just nix (on os x) used for haskell dev. the guy has tons of environments set up. like one for python 2 and one for pythong 3 is a very common example
22:17:16 <wilornel> If I try to (MSuccess "foo") <> (MSuccess $ Product 2), I get `Couldn't match type 'Product Integer' with '[Char]' `
22:17:38 <wilornel> So I guess if there is a definition for (<>) between two different types, Haskell will let it go
22:17:46 <wilornel> Is that possible? To have (<>) done between two different types?
22:17:51 <iqubic> No.
22:17:56 <iqubic> :t (<>)
22:17:57 <lambdabot> Monoid m => m -> m -> m
22:18:07 <iqubic> Must be the same type as per type signature
22:18:26 <kadoban> glguy: There's type variables a and b, and it seems like a must ~ b, because a <> b is used in it, but that's not apparent from the constraints.
22:18:31 <wilornel> Ah! I see, so that's why Haskell lets it compile, kadoban 
22:18:36 <wilornel> thanks iqubic ++
22:18:53 <kadoban> Yes, but:
22:18:55 <kadoban> > let {f :: (Num a, Num b) => a -> b -> a; f a b = a + b} in f 2 3
22:18:57 <lambdabot>  error:
22:18:57 <lambdabot>      • Couldn't match expected type ‘a1’ with actual type ‘b’
22:18:57 <lambdabot>        ‘b’ is a rigid type variable bound by
22:19:05 <wilornel> hmmm
22:19:11 <glguy> kadoban: It's still the same type on both sides
22:19:19 <glguy> kadoban: That type just happens to have two type variables in it
22:19:20 <wilornel> so iqubic , why does haskell allow the following ? semigroupAssoc :: (Eq m, Semigroup m) => m -> m -> m -> Bool
22:19:25 <wilornel> the following: instance (Semigroup a, Semigroup b) => Semigroup (AccumulateBoth a b) where (AccumulateBoth (MSuccess a)) <> (AccumulateBoth (MSuccess b)) = AccumulateBoth $ MSuccess (a <> b)
22:19:49 <kadoban> glguy: But it has to know that a ~ b, right? Wouldn't that have to be represented in the constraint?
22:19:52 <glguy> wilornel: semigroupAssoc is not (<>), so it can have a different type
22:20:08 <wilornel> no no I did not mean the semigroupAssoc like
22:20:11 <wilornel> line
22:20:19 <glguy> kadoban: We haven't seen the definition of this type, have we ? AccumulateBoth
22:20:22 <LordBrain> he says a<>b at the end
22:20:35 <glguy> the 'a' and 'b' in a<>b are unrelated to the type
22:20:50 <LordBrain> indeed
22:20:52 <LordBrain> good catch
22:20:58 <wilornel> I'm confused
22:21:20 <glguy> wilornel: Can you put the code in question on lpaste please? or just show the link if it already is there
22:21:21 <kadoban> Oh, yeah maybe I'm assuming more from the definition than actually exists. *goes to test it*
22:21:22 <wilornel> So Haksell allows my Semigroup instance but not kadoban's function f
22:21:50 <LordBrain> yeah its easier to read in lpaste
22:22:10 <wilornel> (getting a 502 from lpaste.net) doing pastebin
22:22:16 <wilornel> (doing paste.ubuntu.com)
22:22:29 <wilornel> It's a the bottom: http://paste.ubuntu.com/24846974/
22:22:59 <iqubic> Nix looks complex. I think I'll be staying away from nixos
22:23:02 <glguy> wilornel: You're always combining values of the same type
22:23:34 <glguy> wilornel: Either 164 both 'a', 165 both 'b', or 166 167 not combining
22:23:40 <sophiag> iqubic: haha. it's "hard
22:23:52 <sophiag> oop.... "hard" not "complex" i'd say
22:24:10 <glguy> wilornel: or I might have had the first two cases  backward, but its the same idea
22:24:27 <wilornel> Who says a and b are the same type?
22:24:35 <glguy> no one says that
22:24:37 <glguy> oh
22:24:38 <sophiag> i should probably actually return to the entire reason i brought up using nixos...
22:24:39 <glguy> sorry,
22:24:42 <kadoban> @let data Blah = Blah (a, b)
22:24:43 <lambdabot>  .L.hs:159:19: error: Not in scope: type variable ‘a’
22:24:43 <lambdabot>  
22:24:43 <lambdabot>  .L.hs:159:22: error: Not in scope: type variable ‘b’
22:24:46 <glguy> 'a' and 'b' the types are not necessarily the same
22:24:51 <glguy> but 'a' and 'b' the values are
22:24:53 <kadoban> @let data Blah a b = Blah (a, b)
22:24:54 <lambdabot>  Defined.
22:24:55 <kadoban> @let instance (Eq a, Eq b) => Eq (Blah a b) where (Blah (a, b)) == (Blah (c, d)) = a == d && b == c
22:24:57 <lambdabot>  .L.hs:162:47: error:
22:24:57 <lambdabot>      • Couldn't match expected type ‘a’ with actual type ‘b’
22:24:57 <lambdabot>        ‘b’ is a rigid type variable bound by
22:24:59 <glguy> wilornel: This would be less confusing if you didn't reuse a and b
22:25:02 <kadoban> So that errors as I expect ^ which is nice.
22:25:06 <wilornel> ok ok, let me redefine it
22:25:23 <wilornel> I think from now on I will make it a convention for myself not to reuse the type names as variable names
22:25:28 <sophiag> i'd love if anyone could give me a sanity check on the following: http://lpaste.net/356187
22:25:39 <iqubic> what benefits does someone get from nixos?
22:25:41 <glguy> wilornel: while 'a' and 'b' make great type variables, x and y are better for values :)
22:25:51 <sophiag> i did not get all the SrcLoc info in my asts one month ago and it's tripping me out in this heat wave as to why my application is broken
22:26:04 <glguy> iqubic: You'll get better help about NixOS on a channel about it
22:26:16 <sophiag> iqubic: watch that video i linked you to!
22:26:25 <LordBrain> worth learning is not a linear function, that is w(a) + w(b) /= w(a+b).. because of opportunity cost of combined seems to be in excess of opportunity cost of either one
22:26:29 <glguy> sophiag: Are you using the same version of the package you were previously?
22:26:29 <sophiag> or remember that infomerical "set it and forget it?" it's like that
22:26:31 <wilornel> (redefining them in the whole file so it might take a minute)
22:26:55 <iqubic> sophiag: I tried watching it, but nix is too hard for me to start using.
22:27:07 <glguy> wilornel: let's look at a simpler case first?
22:27:14 <glguy> wilornel: can I show you == on Either?
22:27:38 <cocreature> sophiag: did you accidentally upgrade haskell-src-exts?
22:27:39 <sophiag> glguy: that's obviously what i started thinking, but nothing substantial has changed in the month i noticed this. but i use nix so i'm wondering ig lts either reverted to an old version or gave me an old one to begin with. i did recently switch to the unstable branch
22:28:03 <sophiag> cocreature: please see comment above
22:28:20 <LordBrain> iqubic, my understanding is you get a lot of unique environments, so you can test your code in each etc... i imagine you catch more build errors that way... i have something of a home-spun solution for doing similar on debian.
22:28:32 <wilornel> glguy: Yes I'd like to see it!
22:28:33 <sophiag> unless anyone is aware of something i'm not. i see two commits within the past month on haskell-src-exts and neither should be causing this
22:28:35 * hackage yaml-combinators 1.0.1 - YAML parsing combinators for improved validation and error reporting  https://hackage.haskell.org/package/yaml-combinators-1.0.1 (RomanCheplyaka)
22:28:36 <cocreature> sophiag: switching to the unstable branch very much sounds like you might have upgraded it. do you have a version constraint in your cabal file?
22:28:37 <glguy> wilornel: See here http://lpaste.net/9166336271323234304
22:28:51 <sophiag> cocreature: no
22:29:01 <glguy> wilornel: This is analogous to what you're doing in your file.
22:29:10 <sophiag> are you saying this sounds like current behavior?
22:29:10 <glguy> wilornel: Note that == only works on two values of the same type
22:29:18 <sophiag> it's easily testable in ghci is anyone has stack
22:29:26 <cocreature> sophiag: nix has some kind of log iirc that allows you to see what you upgraded
22:29:50 <iqubic> I'd like to see instance Eq (Either a)
22:29:57 <cocreature> sophiag: I’m going to need a bit more detail to say if that’s the current behavior but there was a pretty major update to haskell-src-exts a while back
22:30:00 <sophiag> cocreature: i'm fairly new to it. i think what would most help me is someone who uses stack checking if they get the same output
22:30:10 <cocreature> sophiag: so where’s the source? :)
22:30:17 <sophiag> cocreature: it's the SrcLoc info here: http://lpaste.net/356187
22:30:27 <glguy> wilornel: In this code note that x and y are only compared with == when the constructors match (L and R), and not otherwise
22:30:27 <wilornel> hmmm
22:30:32 <sophiag> one month ago i wasn't seeing any of that in my asts
22:30:34 <glguy> wilornel: this is what's happening in your code
22:30:44 <wilornel> yes but who says a and b are the same type?
22:30:53 <glguy> wilornel: In my code, they are not
22:30:53 <wilornel> oh wait
22:30:58 <glguy> wilornel: in your code they are not
22:31:02 <iqubic> No one says that a and b are the same types
22:31:10 <cocreature> sophiag: that looks like an upgrade from < 1.18 to >= 1.18
22:31:10 <wilornel> that x and y are the same type*
22:31:27 <glguy> wilornel: We learned that through pattern matching
22:31:31 <wilornel> equal (L String ) (L Int)
22:31:33 <sophiag> cocreature: that's ridiculously old for me to have had one month ago on stable
22:31:39 <glguy> wilornel: No, that can't happen
22:31:44 <sophiag> but then again i'm really not sure how lts and nix integrate
22:31:50 <wilornel> where can I read up on that?
22:32:03 <cocreature> sophiag: how are you building your project? using stack or using cabal + nix?
22:32:03 <glguy> wilornel: You can only pick one type to be 'a' and one to be 'b'
22:32:15 <glguy> wilornel: so in equal :: (Eq a, Eq b) => MyEither a b -> MyEither a b -> Bool    all the 'a' must be replaced by the same thing
22:32:26 <Arcaelyx> cocreature: It's import Database.Persist.Sql and not Persist.Postgresql ?
22:32:32 <sophiag> cocreature: i'm building them with just ghc. but this is a change in behavior i see in ghci
22:32:37 <glguy> wilornel: You can choose String for 'a', or you can choose Int for 'a'
22:32:47 <glguy> wilornel: but you don't get to pick both at the same time
22:32:53 <wilornel> yes aaaah!!!
22:32:54 <wilornel> I see
22:33:09 <wilornel> :t <>
22:33:10 <lambdabot> error: parse error on input ‘<>’
22:33:24 <wilornel> @:t <>
22:33:24 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
22:33:44 <wilornel> :t (<>)
22:33:45 <lambdabot> Monoid m => m -> m -> m
22:33:59 <wilornel> so this is what says that they have to be of the same type ^
22:34:01 <cocreature> Arcaelyx: yes, you can see the exposed modules when looking at the hackage page for the package https://hackage.haskell.org/package/persistent-postgresql
22:34:06 <glguy> wilornel: Yes
22:34:13 <Arcaelyx> Installing it right now.
22:34:16 <wilornel> (And you'd see something similar in the definition of (<>) for Semigroups)
22:34:17 <wilornel> good!
22:35:06 <iqubic> Why do we seems to prefer GHC? What advantages does it have over HUGS?
22:35:07 <sophiag> cocreature: are you on nix? i'm wondering if instead of trying to switch back to stable i could just add this package to my list explicitly and specify a version
22:35:07 <wilornel> I feel like it would be nice if my IDE could allow me to see the type of (<>) when I hover it in my definition of my Semigroup (AccumulateBoth a b) instance
22:35:21 <iqubic> wilornel: What IDE do you use?
22:35:49 <sophiag> iqubic: hugs ceased development quite a while ago so doesn't support a ton of stuff. plus it was always horribly slow. far too slow for production
22:35:50 <cocreature> sophiag: no I’m not. in general if you’re not using stack to pin down the versions of packages you should add version bounds to your cabal file to prevent accidentally upgrading a package
22:35:54 <wilornel> well, I use Emacs)
22:35:58 <kadoban> iqubic: Well, for one it's actually maintained.
22:36:31 <iqubic> Can't you get type at point with emacs?
22:36:34 <sophiag> cocreature: thanks. i'll go ask in #nixos. to be clear the change you suspected was in 1.18?
22:36:52 <wilornel> I didn't check if such a package exists
22:37:00 <Arcaelyx> cocreature: Keeps saying this `Failed to load interface for ‘Database.Persist.TH’`
22:37:13 <cocreature> sophiag: yeah
22:37:25 <sophiag> thanks
22:37:41 <sophiag> damn, now i'm suspicious about all kinds of weird errors being due to this :O
22:37:45 <cocreature> Arcaelyx: have you added persistent-template to your build-depends?
22:37:48 <wilornel> thanks glguy
22:38:08 <sophiag> i tried using singletons for the first time recently and had weird TH issues. maybe that's a version issue as well
22:38:10 <iqubic> I'd still like to see instance Eq (Either a)
22:38:24 <sophiag> i'm halfway to the "fuck semantic versioning" camp
22:38:40 <cocreature> sophiag: that’s fine but then you need to use something like stackage to pin down versions
22:38:47 <cocreature> sophiag: just ignoring that upgrades can break things is a bad idea
22:38:49 <Arcaelyx> Oh, no I didn't.
22:39:05 <LiaoTao> Anyone familiar with the Linear package? I'm trying to convert an IntMap of rows into a matrix, but I can't find any suitable function
22:39:15 <cocreature> Arcaelyx: in general, you can use a query like http://hoogle.haskell.org/?hoogle=Database.Persist.TH%20is%3Amodule to figure out which package a module is in
22:39:16 <sophiag> cocreature: well i need to have the nix folks explain to me how to do that inside of nix rather than cabal
22:40:20 <dmj`> sophiag: version based on the hash of nixpkgs
22:40:39 <Zemyla> Ugh, I'm running into a pain point in the Haskell numeric typeclass hierarchy.
22:40:52 <cocreature> Zemyla: only one? that’s not too bad :P
22:40:53 <sophiag> dmj`: i'm unsure what you mean
22:41:55 <iqubic> Is it possible to use emacs haskell-mode and get information for thing at point?
22:42:44 <dmj`> sophiag: your haskell package versions, and third-party deps. won’t change if you only build your project against a specific hash of nixpkgs. 
22:43:19 <sophiag> dmj': yeah i thought is shouldn't have to actually add version flags
22:43:27 <sophiag> anyway cocreature is right: https://www.stackage.org/package/haskell-src-exts
22:43:53 <sophiag> the current on lts is that far behind stackage...surely because they knew it breaks stuff :p
22:45:32 <Arcaelyx> cocreature: Where do I put the connection details?
22:45:39 <Arcaelyx> Doesn't seem to really say anywhere.
22:46:31 <cocreature> Arcaelyx: all the connection functions allow you to pass in the connection string https://hackage.haskell.org/package/persistent-postgresql-2.6.1/docs/Database-Persist-Postgresql.html
22:47:18 <Arcaelyx> So with withPostgresqlConn?
22:48:05 <cocreature> yes
22:56:10 <Zemyla> cocreature: The type of arbitrary real algebraic numbers should have a Real instance, and especially a RealFrac instance, but they can't be converted sensibly to rationals.
22:59:34 <wilornel> Hmmm... this is weird. I get an error (last line) here: http://paste.ubuntu.com/24847138/
22:59:58 <wilornel> but, in the book I am reading, I have : http://imgur.com/a/VfPb1
23:02:36 <cocreature> Zemyla: the fact that we define Real by saying it can be converted to a Rational is really silly
23:08:06 <iqubic> cocreature: x = x / 1
23:08:16 <cocreature> iqubic: what?
23:08:17 <iqubic> x = x % 1
23:08:42 <cocreature> iqubic: that doesn’t typecheck
23:08:45 <iqubic> If you divide x by 1, you get x for all real numbers x
23:09:10 <cocreature> but you don’t get a rational
23:09:34 <iqubic> You can make make it a rational. Just have (Num x) % 1
23:10:08 <cocreature> Rational requires that x is an Integer which it is not for almost all instances of Real
23:10:25 <iqubic> Oh, that is bizarre
23:11:11 <cocreature> not really, that’s how we define ℚ. what’s bizarre is that we expect reals to be converted to that
23:26:20 <Axman6> "14:10          glguy: I didn't know if you switched back, but if you are, λ is the l* digraph, so you can type l* and then Alt-K" woah, you'be blown my mind again, are there docs for this?
23:26:53 <sophiag> how do i check the version of a package? either from cli or ghci?
23:27:08 <sophiag> ghc-pkg doesn't seem to do that...
23:27:10 <glguy> sophiag: ghc-pkg list somepackage
23:27:15 <sophiag> ah ok
23:27:26 <sophiag> i was wary of it dumping a whole huge list
23:27:35 <glguy> Axman6: Maybe not?
23:28:00 <glguy> Axman6: It's listed in the /keymap
23:28:32 <cocreature> sophiag: "ghc-pkg field <packagename> version" also works
23:29:13 <jared-w> A rational should be a ratio of two integers, right?
23:29:15 <Axman6> glguy: thanks :)
23:29:41 <cocreature> jared-w: yep, that’s exactly how it’s defined in Haskell
23:29:48 <jared-w> great, good to know
23:29:51 <sophiag> cocreature: i bumped it back to 1.18.2, but ghci is still behaving the same...even when launching a new instance of emacs. there's no way i should need to reboot for this...
23:30:01 <cocreature> "type Rational = Ratio Integer"
23:30:07 <cocreature> sophiag: you need to go back to < 1.18
23:30:20 <cocreature> the change was in 1.18
23:30:29 <cocreature> sophiag: but really you should just upgrade your code to work with the new version :)
23:31:04 <glguy> Axman6: https://github.com/glguy/irc-core/wiki/Keyboard-bindings
23:31:07 <sophiag> oh really? lts nightly currently has 1.18 so i thought i had upgraded to 1.19
23:31:27 <sophiag> ugh, i better bring it to #nixos at this point. or *better*...tomorrow
23:31:47 <jared-w> cocreature: You said something about the Haskell Real definition requiring a conversion to Rational?
23:32:06 <sophiag> cocreature: the new version is nuts! i should look closer, though. there must be a flag to parse out this SrcLoc info...
23:32:26 <cocreature> jared-w: yes, see https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:toRational
23:33:08 <jared-w> But, like... why? ಠ_ಠ
23:33:09 <sophiag> it seems more likely they changed all the types their parsers return, which is frankly horrible
23:34:20 <cocreature> sophiag: previously haskell-src-exts contained two separate ASTs. one simplified AST without the SrcInfo and the other with the info. 1.18 removed the simplified AST which you seem to have used before
23:34:24 <jared-w> Did they do that for some reason so we could turn Pi into something? I don't see any reason to expect a conversion to Rational and have nothing about RealFrac
23:34:38 <sophiag> cocreature: :(
23:34:46 <sophiag> i built on a bad foundation :(
23:34:52 <cocreature> sophiag: but I’m not sure why that’s actually a problem for you?
23:35:06 <cocreature> I mean it requires some changes but if you weren’t using the SrcInfo you can just ignore it
23:35:20 <sophiag> i have a dsl that uses a ton of type casing
23:35:50 <sophiag> the type _signatures_ for a ton of my functions don't even match anymore
23:35:58 <cocreature> then change them :)
23:36:19 <sophiag> ok now i'm 100% in the fuck semantic versioning camp
23:36:35 <sophiag> the term "deprecated" has a meaning
23:37:17 <sophiag> i had pattern synonyms for the patterns that no longer exist...consider that...
23:37:45 <cocreature> well updates can break things. are you saying that you should never be allowed to make backwards-incompatible updates?
23:39:59 <sophiag> cocreature: that's what rich hickey said in his keynote last year. haha
23:40:05 <sophiag> i personally wouldn't go that far
23:40:07 <cocreature> yeah I found that really silly :)
23:40:22 <sophiag> but to be fair, many languages go way too far in the other direction
23:40:24 <sophiag> python...
23:40:32 <sophiag> soon scala
23:40:34 <jared-w> Python is totally fine
23:40:51 <jared-w> Everyone hating on Python 3 needs to give up and get over it. It's been a decade already
23:41:06 <sophiag> idk i don't even use python, but someone explained some of the changes to me recently and i thought it was nuts
23:41:25 <sophiag> probably lacking perspective on how far the versions were spaced chronologically
23:41:51 <jared-w> What happened is Python had a version 2 and then a ton of stuff was building up. Small pain points that python wanted to fix but couldn't because of backwards compatibility
23:41:57 <sophiag> anyway wrt to haskell i feel like breaking changes are  built into the idea of the language
23:42:16 <jared-w> So they decided "y'know what, screw it. Python 3 is gonna be THE change. THE breaking change. We're gonna fix all the pain points and get it over with"
23:42:22 <cocreature> at least we have types that yell at you if you forgot to update your code :)
23:42:36 <sophiag> cocreature: good point
23:42:42 <jared-w> that was in 2007 and certain people have wept and gnashed their teeth in agony ever since
23:43:11 <sophiag> but also haskell is so hard to write a decent compiler for. i feel like if that was different we would see several dialects following different styles rather than all this versioning and library hell
23:43:33 <cocreature> it’s not just “certain people”. the last time I saw stats for pypi, python 2.7 was way more popular
23:43:37 <sophiag> like, um, how about a generic map?
23:44:07 <jared-w> Now in Haskell we have tons of these small little pain points (foldable before the big foldable change), :: for types and : for lists, partial functions in prelude,  lots of "mistakes" over the years that just build up over time
23:44:29 <jared-w> We've never goen through with a hammer and fixed everything at once. But, when Haskell prime comes around, we will (probably)
23:45:07 <jared-w> That's because PyPy uses python 2.7. It was one of the biggest libraries that refused to upgrade to python 3. Eventually the community started throwing so many pitchforks that PyPY got off their ass and supported 3.x
23:45:33 <sophiag> jared-w: by haskell prime you just mean 2020? as if that will change the whole paradigm?
23:45:49 <arctictern> does anyone happen about the Lucid library (for HTML generation)?
23:46:02 <cocreature> I doubt haskell prime will change anything significantly. it will mostly adapt the standards to what we already have
23:46:11 <sophiag> ^ exactly
23:46:13 <cocreature> arctictern: asking your questions directly usually works better
23:46:50 <sophiag> i'm seriously considering trying to write my own standard library to replace prelude. i suppose that's why prelude-edsl exists
23:47:02 <jared-w> I expect that most of our pragmas will get folded into the language. I would also expect a lot of the prelude to be rewritten to best practices (removing total functions, etc)
23:47:18 <jared-w> sophiag: look at protolude and all of the alternative preludes that already exist. There's like 5-10 of them at least
23:47:25 <quchen> : vs :: is nothing anyone on Haskell prime cares about, luckily.
23:47:25 <LordBrain> removing total functions?
23:47:28 <sophiag> i would make everything a generically derived functor, applicative, foldable, and traversable. then have the functions in prelude generically dispatch over them
23:47:31 <jared-w> s/total/partial/
23:47:36 <jared-w> brain-fart :p
23:47:52 <cocreature> LordBrain: every function will just call error regardless of the input
23:48:03 <LordBrain> cocreature, :) 
23:48:07 <sophiag> make all maps function like foldMap and you'd have much less need for fusion laws
23:48:13 <LordBrain> perrrrrrfect
23:48:24 <jared-w> quchen: I care about : vs :: ಠ_ಠ (okay only a very tiny bit)
23:48:34 <LordBrain> what is : vs :: ?
23:48:48 <jared-w> : is the cannonical mathematical representation of type signature separation, not ::
23:48:57 <sophiag> jared-w: ah...of course it's stephen diehl :)
23:48:58 <LordBrain> are we talking about whether or not cons and type sig should be swapped, because if we are NO. heh.
23:49:06 <quchen> It’s purely bikeshedding.
23:49:09 <jared-w> So if Haskell were to be correct, they would use : for types and :: for lists like every other modern FP language
23:49:11 <arctictern> I'm basically trying to mimic the behavior of OverloadedStrings. For example, I can do `p_ "hello"`. But I'm trying to get something like `\x -> p_ x`, which is giving me problems. The `x` in that lambda should be a monad transformer of type `HtmlT Identity ()`.... but I'm not sure how to convert a string or text value into that
23:49:34 <sophiag> yeah, : and :: never crossed my mind
23:49:48 <LordBrain> its way better to have two colons on the type sig in haskell, because it stands out nicely, and the cons operator is fine the way it is
23:49:51 <u-ou> what about = vs ==
23:49:53 <u-ou> ;)
23:49:59 <quchen> Or != vs /=
23:50:04 <cocreature> arctictern: try providing an explicit type signature
23:50:07 <quchen> Infinite possible nonsensical suggestions yaaay
23:50:09 <sophiag> actually it should be := 
23:50:19 <jared-w> Unicode for everything like G-d intended
23:50:25 <LordBrain>  /= is superior actually ,as it is easier to type than !=
23:50:34 <quchen> On your keyboard maybe
23:50:41 <LordBrain> it doesnt require shift
23:50:44 <LordBrain> its just two keys
23:50:53 <sophiag> /= makes more sense in the context bangs are used generally
23:50:53 <u-ou> ban shift!
23:51:03 <jared-w> (on some keyboards it does require shift to type /)
23:51:13 <arctictern> cocreature i'm stupid, thanks
23:51:15 <quchen> Bangs are not used at all outside data definitions in Haskell 98
23:51:22 <LordBrain> is it != easier on your keyboard quchen ?
23:51:35 <sophiag> yes, but bangs are used in many other languages very specifically
23:51:42 <LordBrain> so
23:51:50 <LordBrain> we've been using /= since the 80s
23:52:10 <LordBrain> 90s at least...
23:52:10 <quchen> No, »we« have not, for I am part of »we« and I have not.
23:52:35 <sophiag> quchen: that's a quote fit for a tattoo
23:52:46 <LordBrain> haskell has
23:52:54 <LordBrain> and its predecessor languages
23:53:52 <LordBrain> Miranda released in 1985
23:54:41 <LordBrain> actually miranda may have used ~=
23:54:57 <LordBrain> but /= was a good idea, we should not undo it
23:55:02 <LordBrain> as weas ::
23:55:21 <wilornel> So if something is a Monoid, it is also a Semigroup, right? Why do I need to declare that a type variable be a Monoid and a Semigroup when I create an instance of a type with a type variable?
23:56:02 <LordBrain> because the class declaration for Monoid doesnt necessarily have Semigroup listed as a parent
23:56:31 <wilornel> Hmmm.. Ah! was that an issue in the past? I thought it was an issue that was supposed ti be fixed with GHC 8.0, no?
23:57:42 <geekosaur> backward compatibility foo, I think
23:57:59 <LordBrain> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#Monoid
23:58:01 <geekosaur> if you wanted to do things that way then <>/mappend would need to move to Semigroup which would likely break a lot of code
23:58:05 <LordBrain> no parents on Monoid
23:58:10 <wilornel> Hmmm
23:58:16 <LordBrain> there are other reasons than backward compat
23:58:23 <jared-w> We already have <>/mappend in Semigroup though, don't we?
23:58:33 <LordBrain> if you made Semigroup a parent, that would force all instance writers to also make semigroup instances
23:58:41 <wilornel> yeah in that case Monoid should just have Semigroup as parent and have id
23:58:59 <wilornel> LordBrain: Not when they define a Mnoid, right?
23:59:02 <jared-w> LordBrain: why would you need to make an instance for semigroup if you make one for monoid? Just drop identity and you're done
23:59:07 <geekosaur> LordBrain, that *is* the bckward compat issue
23:59:55 <wilornel> Ooooh... so jared-w , I think that in that case, if you want to define a Monoid, you would have to define a Semigroup and then define id in a monoid
23:59:57 <jared-w> A monoid can be made a semigroup with just `instance Semigroup MyMonoid` and you're done
23:59:59 <geekosaur> jared-w, the compiler needs to be told about it, there is no "do it for everything" unless you want to disallow all other Semegroup instances... which would make Semigroup kinda useless
