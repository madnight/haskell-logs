00:00:06 <mauke> it's fine, just put an upper bound on the length of your source file
00:00:15 <mauke> e.g. 2 GB
00:00:36 <cocreature> mauke: who doesn’t love doing asymptotic analysis of bounded input
00:00:45 <pacak> Also O(1) tells nothing about how fast it takes to compile stuff.
00:00:55 <jared-w> Just figure out the most complex program possible to be written in 2GB and then hard-code a loop into your compiler to make all programs take that long /s
00:00:58 <pacak> "1 year for any program" is perfectly O(1).
00:01:23 <EvanR> O in this case is, order of magnitude
00:01:26 <EvanR> heh
00:01:32 <unknownln> Ah, the "translate by hand into assembly" approach
00:01:33 <EvanR> about 10^0 seconds
00:02:46 <sveit> pacak: sorry, i meant ~O(1) sec as in physics, meaning that i would like compilation for large projects to take several seconds
00:03:25 <jared-w> physics doesn't use O notation that I'm aware of :p if they do, they do it in typical physics fashion (aka wrong)
00:03:33 <sveit> cocreature: yeah, sorry, i mean ~O(1) sec as in <~10 seconds for large codebasis
00:03:36 <[exa]> sveit: anyway, what's the reason for trying to optimize build times?
00:03:55 <EvanR> so you can quickly reconfigured xmonad!
00:04:10 <EvanR> actually, live coding heavily depends on rebuilding fast
00:04:21 <[exa]> live coding is a case for interpreters
00:04:42 <EvanR> well
00:04:50 <EvanR> haskell's interpreter poor
00:05:14 <sveit> [exa]: the nature of the problem domain. basically it is important to quickly test out algorithms/other ideas on non-trivial datasets/problem sizes, so an interpreter would be too slow
00:05:14 <EvanR> even 10 seconds is too long really for good feedback
00:05:20 <sveit> but i'd still like quick iteration
00:06:02 <[exa]> sveit: is the build parallelizable?
00:06:17 <jared-w> Sounds like you want Mathematica live graphs with Matlab data-sets :p
00:06:20 <merijn> Honestly, running on non-trivial datasets doesn't sound like the compile time is the issue, but the runtime
00:06:53 <[exa]> even more, coding-time probably still dominates both compile- and run-time
00:07:17 <merijn> See, that I don't necessarily buy
00:07:53 <merijn> I have a week plus of runtime for new versions, so it's not hard to get bottlenecked by runtime, rather than coding
00:07:59 <EvanR> different stuff matters more at different times! compile time time depends more than anything at compile time. runtime time matters more than runtime. code time depends more at code time :)
00:08:05 <[exa]> except there are changes like "let's try a different constant here and see", which is not a good science.. :]
00:08:13 <sveit> merijn: not in this particular case. i mostly mean problem sizes anyway, so tweaking the parameters of a non-trivial simulation, that when optimized takes ~1-5 secs. then compiler speed is important.
00:08:32 <jared-w> [exa]: it's totally valid science when you're trying to find the correct magic which makes p < 0.005... /s
00:08:40 <[exa]> :]
00:08:55 <EvanR> you should tweak those parameters at runtime
00:09:29 <EvanR> doesnt require retypechecking or anything
00:09:49 <merijn> EvanR: To be fair, I'm using C++ with templates, so my compile time is shit anyway xD
00:10:01 <[exa]> sveit: if you can, tweak the program to choose parameters itself. If you can't, you can probably try splitting code to smaller pieces, parallelize the builds and throw cores at it
00:10:13 <sveit> EvanR: sometimes that's not practical, like when exploring certain problem domains for the first time.
00:10:35 <EvanR> yeah im running into that right now
00:11:04 <EvanR> i keep waiting to tweak stuff and see what happens, but the refresh process is slow as hell
00:11:12 <sveit> [exa]: well i will try to get compile times to be fast first, feels ike the "right" solution. why not try? :)
00:12:02 <[exa]> sveit: it's a tradeoff, by restricting compile time you restrict amount of optimizations in the source code...
00:13:26 <merijn> EvanR: I managed to reduce it at least a bit by moving all my algorithms into dynamic libaries which I dlopen, compared with some header file hygiene this means I at least don't have to rebuild *everything* all the time
00:13:28 <sveit> [exa]: clearly. the original question was whether, in the same amount of time, i could get a lot more optimization done if i wrote the compiler in C vs Haskell. concensus seems to be no :)
00:13:56 <sveit> merijn: you use dlopen in haskell?
00:14:40 <unknownln> He's referring to his C++
00:14:41 <[exa]> sveit: in fact I have done the same thing. General rule seems to be that C compilers are faster until you pack up optimizations.
00:15:21 <[exa]> s/C compilers/compilers written in C\/C++/
00:15:30 <LiaoTao> merijn: What are you writing again?
00:15:37 <EvanR> no because you wont ever complete your compiler in C
00:15:53 <merijn> sveit: No, this is C++. Although you totally *could* do dlopen in Haskell
00:15:58 <[exa]> EvanR: +1
00:16:04 <EvanR> dlopen in haskell doesnt help
00:16:18 <EvanR> you still need to rebuild the DLL
00:16:35 <merijn> sveit: The C FFI of Haskell is super simple (well, on one condition: you have to not want to mutate structs from within Haskell)
00:17:02 <EvanR> poke all the things
00:17:09 <merijn> LiaoTao: Benchmarking GPU stuff
00:17:45 <LiaoTao> Fun
00:17:47 <merijn> Actually, even mutating structs isn't that painful, it's just the very first setup of Storable instances is a pain in the ass, so I try to avoid that cost if I don't absolutely need it :)
00:19:14 <sveit> [exa]: what do you mean, "until you pack up optimizations". you mean until you include optimizing passes in the compiler?
00:24:07 <jared-w> Basically, every single ounce of complexity you add into a compiler, you spend ounce^2 time making it bug free and performant in C++ compared to in Haskell
00:24:55 <jared-w> If your compiler is dead simple and does almost zero optimizing. Sure, why not, do it in C or C++. If your compiler is somewhat complex, save yourself the headache and do it in Haskell. It'll probably be faster, too, since you don't have to be both correct AND efficient
00:25:02 <_sras_> I am trying to write tests for a Stack web application and wondering how to access stuff from my main app into the test package?
00:25:06 <EvanR> the only reason i can imagine using C++ is, no matter what you do its performant
00:25:29 <jared-w> I've seen some pretty terrible code written in C++ that wasn't performant, though :p
00:25:37 <merijn> EvanR: Not having to worry about GC introducing noise in your benchmarks would be one.
00:25:49 <_sras_> should I have to expose the module in my main app to be able to access it from tests?
00:25:56 <jared-w> I'm talking hand written linear linked lists and data structures with memory leaks all over the place
00:26:09 <jared-w> and about 70 custom operators, half of them likely implemented wrong
00:26:21 <merijn> jared-w: Who the fuck hand writes lists in C++? >.>
00:26:37 <merijn> C++11 (or later) or GTFO :p
00:27:02 <jared-w> I had to for a school assignment, but apparently many /many/ code-bases around town still use their own rolled STD lib with their custom strings, custom LLL, custom etc... ;-;
00:27:55 <jared-w> They stay away from anything newer than g++03 due to "tons of bugs everywhere and horrible performance" (my professors words)
00:28:00 <cocreature> merijn: who the fuck uses lists in c++? after all arrays are the universal data structure :)
00:28:29 <jared-w> But muh vektorz
00:28:39 <LiaoTao> jared-w: That's insane.
00:28:42 <merijn> cocreature++ :)
00:29:02 <LiaoTao> A sane STL implementation is like what, 20 years old now?
00:29:34 <merijn> cocreature: Although SQL as secondary data structure is growing on me...I should started dumping measurements into SQLite ages ago...
00:29:50 <jared-w> Welcome to finance and old corporate :p
00:29:56 <jared-w> Somehow, they make Java look sane
00:30:01 <cocreature> merijn: yeah outsourcing work to dbs can be quite nice
00:30:18 <LiaoTao> DBs are great for...storing data!
00:30:31 <cocreature> and querying data
00:30:48 <cocreature> which is what most data is for :)
00:31:22 <merijn> cocreature: I'm also very impressed by SQLite's query optimiser. I'm not feeding it that complex queries, but the ones I'm feeding it are kinda dumb/inefficient (because reasons) and it's making them superefficient :)
00:31:29 <[exa]> sveit: yeah, mostly. Anyway, if you're doing mostly numerical computations, I'd suggest you take a look at something less brutal then haskell; simpler languages compile faster and lack of runtime can speed up your stuff a bit. E.g. Clean.
00:32:22 <EvanR> numeric clean...
00:32:31 <jared-w> wut
00:32:53 <jared-w> Simpler language, lack of runtime, Clean? No idea what you're getting at
00:33:00 <merijn> [exa]: Did you go to, like, University of Twente or something? :p
00:33:29 <EvanR> calling you out man
00:33:31 <[exa]> well Clean might be a bad example but I hoped it could fit a bit
00:33:53 <[exa]> some people here love it
00:33:57 <merijn> EvanR: Clean is pretty interesting, but Twente is litterally the only place I know where they use it :p
00:34:13 <jared-w> Clean is neat, but call a spade a spade and don't try to put it next to the shovels in the hopes that someone will use it :p
00:34:17 <merijn> Then again, people in Twente are lamenting the fact that Isabelle isn't used much anymore
00:34:26 <[exa]> :D
00:35:10 <merijn> But they get a pass for deciding Haskell is a saner language for FPGAs than C :)
00:35:58 <cocreature> C for fpgas? I thought most people use verilog or vhdl for that
00:36:19 <merijn> cocreature: All HLS (High-Level Synthesis) uses C as input language to generate verilog/vhdl from
00:36:27 <[exa]> merijn: wasn't hard decision at all, was it. :D
00:36:42 <merijn> Of course that's dumb, since the one thing C is good at is "manipulating memory" which is like the one thing FPGAs suck at :p
00:36:46 <[exa]> anyway I was actually eyeing something like this https://www.microsoft.com/en-us/research/publication/using-destination-passing-style-compile-functional-language-efficient-low-level-code/#
00:36:53 <[exa]> too bad it's not turing-complete yet
00:39:39 <merijn> Whooo! SQL via String (well, Text) concat, like a pro!
00:40:03 <EvanR> SQL injecting your GPU code
00:43:06 <merijn> hmm, so, API design question if you have a function that logically takes 2 (or more) values of the same type Foo. Do people think it's nicer to pass a record with all those values so the names disambiguate their meaning?
00:45:04 <EvanR> named params
00:45:07 <quchen> merijn: Or Tagged
00:45:12 <EvanR> (should exist)
00:45:29 <EvanR> dependent haskell will solve it!
00:45:31 <EvanR> sort of
00:47:01 <Freundlich> How about using newtype for that?
00:47:16 <merijn> Freundlich: That's a bigger hassle to use than a record would be, imo
00:47:35 <EvanR> memcpy :: Int -> pi (from :: Addr) -> pi (to :: Addr) -> IO ()
00:47:41 <Freundlich> The nice thing about newtype is that you often find out that you have to keep these values separate in other parts of the program as well.
00:48:23 <merijn> Freundlich: In this specific case I'm simply building a data structure only to immediately consume it again
00:49:20 <Freundlich> merijn: Yes, in this case newtype is probably not worth it, I think.
00:57:11 <merijn> Any good Text interpolation quasi-quoter libraries?
01:00:32 <EvanR> i cant believe acme-php doesnt have something like that
01:00:50 <merijn> EvanR: So disappointing, submit a PR! ;)
01:02:58 <phadej> merijn: you want to slice Text chunks into pattern, or do you want something more trickier?
01:03:35 <merijn> phadej: I want to dump several pieces of text into specific locations inside a chunk of Text
01:03:59 <merijn> But I think the interpolate library does what I want
01:04:12 <phadej> i.e. mconcat [ "...", v, "..." ] is a bit too tricky?
01:04:27 <merijn> phadej: The problem is readability :)
01:04:50 <merijn> phadej: See, the above remark of constructing SQL via Text concat like a pro :p
01:05:25 <quchen> merijn: To be fair, string interpolation is one of the two things I like about PHP; the other one being that constructors are called constructors
01:05:33 <merijn> phadej: I tried the obvious mconcat approach, but it's ridiculously unreadable
01:06:33 <quchen> merijn: What about Chris Done’s formatting lib?
01:06:37 <quchen> ?hackage formatting
01:06:38 <lambdabot> http://hackage.haskell.org/package/formatting
01:07:06 <quchen> merijn: More " than normal printf, but not terribly far away from it
01:07:37 <merijn> quchen: I suppose that'd work, but cabal is nearly done installing interpolate, so... :)
01:08:12 <quchen> Saving energy etc ;-)
01:08:23 <phadej> merijn: Yeah, I agree, sometimes mconcat doesnt' "scale"
01:09:05 <merijn> quchen: Plus, the quasiquoter let's me write a nice single multi-line chunk without all the need for fiddling with operators :)
01:09:42 <merijn> quchen: Unrelatedly, do you have any clue how tricky it'd be to extend the ansi wrapper of your prettyprinter with support for 256 colour terminals?
01:09:52 <ventonegro> [exa]: Thanks for the link, that paper looks very interesting
01:10:26 <quchen> merijn: I don’t know how 256 colour terminals work. Is it the same as the ANSI terminal, where there are special »set style to« sequences? If so: copypaste simple
01:10:58 <merijn> We really need a nice SQL quasi-quoter for more complex query creation. All the existing safety wrappers assume a single SQL query with only place holders for values
01:11:03 <merijn> quchen: I have no clue, tbh :)
01:12:05 <quchen> merijn: I don’t think it’s difficult to do, if that helps. But I also don’t know what »it« is exactly, so don’t quote me on that ;-)
01:12:23 <quchen> merijn: The terminal backend is a bit fiddly, since terminals are terrible at styling, but it works well
01:12:44 <merijn> quchen: I'll put it on the ever-growing list of things to do ;)
01:13:31 <quchen> merijn: FWIW it should not take you that long; maybe an hour, maybe two
01:13:45 <jared-w> ahhh, terminals
01:13:49 * jared-w cracks knuckles
01:14:32 <jared-w> Terminals use escape sequences for /everything/. 256 merely recognizes more escape sequences than "standard ansi"; the trick comes in that some terminals are formatted differently than others and thus interpret certain escape sequences differently
01:14:36 <[exa]> ventonegro: functionalist submissions to this year's oopsla are, well, extremely juicy at least
01:14:55 <merijn> quchen: Actually, as a part of my quest to start seeding this list so that it's filled enough to start advertising on, like, reddit and hopefully getting it self-sustaining, do you mind if I just that down here (https://wiki.haskell.org/Yak_shaving) with you as contact person?
01:15:06 <u-ou> hello. what's everybody talking about in here?
01:15:17 <jared-w> 24bit true color is a fuck-field of like 2-4 different implementations, all incompatible with each other. However pretty much everyone has standardized on xterm's 256 color format
01:16:05 <merijn> (I'd list myself, but I don't actually know the prettyprinter internals :p)
01:16:08 <jared-w> So yes, in theory, simple copy-paste + done should work for 256 color, quchen :)
01:17:06 <quchen> jared-w: Hooray! :-)
01:18:11 <quchen> merijn: Do you know how to write the Show instance for [a]?
01:18:23 <quchen> Think TWICE as complicated and that’s all you need :-þ
01:19:16 <jared-w> So you wrote show in pointfree style? :p
01:19:21 <merijn> quchen: Yes, but I also have a currently ever-growing list of shit that I have to implement to actually have something to write a thesis about, so that's low-priority. And actually means it sounds like exactly the kinda thing some beginner could do when they ask for suggestions for projects :p
01:19:35 <quchen> merijn: Haha
01:20:30 <merijn> Starting to feel the pressure, since my funding runs out January 1st :p
01:21:11 <jared-w> quchen: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
01:21:23 <quchen> I’ve never used a 256 color terminal, so I don’t really feel the need for having such a backend
01:21:39 <jared-w> quchen: they're fantastic. I currently have a 24-bit true color terminal :D
01:21:42 <merijn> quchen: Really? Most terminals are 256 color nowadays :p
01:22:00 <jared-w> It also supports every unicode wazoo under the sun as long as my font works for it
01:22:15 <merijn> I learned 2 years ago the only reason my OSX terminal was 16bit was due to my tmux variable accidentally being set to indicate 16 colour only
01:22:21 <merijn> eh
01:22:26 <merijn> s/16bit/256 colour
01:22:39 <merijn> actually, scratch that, the entire logic of that sentence is dumb
01:22:58 <jared-w> lol that's funny. Took me a while to learn that on my mac as well back when I had it (I knew what you meant)
01:23:16 <jared-w> I'm glad tmux lets you do true color now. And neovim too. Much goodness, many sex
01:24:13 <quchen> echo -e "\e[38;5;0x08mHello"
01:24:17 <quchen> Should this do something?
01:24:39 <quchen> The Wikipedia article is remarkably bad at giving a proper example. It’s so bad it could be from a manpage.
01:25:49 <jared-w> weird... It should, but it's not working on my computer
01:26:30 <quchen> Ah. echo -e "\e[38;5;124mHello"
01:26:37 <quchen> Hex notation is not supported it seems.
01:26:47 <jared-w> hah, that's funny. Yeah that makes sense
01:26:53 <jared-w> Nice dark red for me
01:26:53 <quchen> I guess I’ve been using a 256 color terminal all along.
01:29:01 <quchen> Aaah, ansi-terminal does not support 256 colors. In that case it might take longer to implement it.
01:29:33 <quchen> It would basically require the author to generate the escape sequences manually instead of relying on the SGR type.
01:31:10 <phz__> hey, just having a question about hackage
01:31:43 <phz__> one can upload some documentation with HTTP PUT at https://username:password@hackage.haskell.org/package/…/docs
01:31:48 <phz__> is that in clear on the network?
01:31:57 <phz__> what is the meaning of the @ before the URL?
01:32:07 <phz__> tricky way to pass HTTP parameters?
01:32:56 <merijn> HTTP basic authentication
01:33:09 <phz__> interesting
01:33:24 <merijn> phz__: As long as you use HTTPS it's fine
01:33:41 <merijn> Since they're transmitted in the HTTP headers
01:33:48 <phz__> I see
01:34:04 <phz__> thanks
01:34:52 <cocreature> cabal didn’t use https for an embarrassingly long amount of time
01:35:39 <EvanR> the url is not in a header perse, but the request isnt in plaintext
01:38:22 <merijn> If I wanna do a "stateful" map over a list, what's the simplest approach? State s?
01:38:43 <EvanR> mapAccum ?
01:38:52 <phz__> traverse?
01:38:52 <EvanR> oh, fold? oh uh
01:39:00 <phz__> traverse + State
01:39:21 <phz__> or a fold, yeah
01:39:28 <phz__> or a Writer…
01:39:29 <phz__> :P
01:39:38 <cocreature> if you want a map, scan might also be useful
01:39:43 <merijn> Yeah, but writing a fold that returns a list is annoying
01:40:34 <merijn> Basically, I need to generate a bunch of unique names so my map needs a "unique id" in addition to the map's input
01:40:41 <merijn> I don't think scan fits there
01:41:48 <jared-w> you wanna know what's neat?
01:41:55 <jared-w> full color terminals
01:45:28 <EvanR> zip with your infinite list of unique names!
01:45:46 <EvanR> everyone has one of those right
01:46:05 <merijn> EvanR: Actually...good point, I'm dumb
01:47:17 <EvanR> i wasnt really serious, im not sure how to make one of those
01:47:25 <cocreature> [1..]
01:47:30 <merijn> EvanR: eh, I'm just appending numbers
01:47:37 <merijn> So, like, cocreature said
01:48:46 <EvanR> later that day, [1..] used a second time collides
01:48:52 <quchen> Is there a standard paper about the implementation of IO in GHC?
01:49:03 <merijn> quchen: The Lazy Functional State Threads one?
01:49:04 <EvanR> tackling the awkward squad, maybe?
01:49:18 <quchen> merijn: Oh, good point, I should look at that.
01:50:28 <EvanR> you should use all even numbers, so that later you can all odds
01:50:32 <EvanR> no collisions
01:53:14 <EvanR> all powers of two, then all powers of three, then ...
01:53:32 <EvanR> in an emergency you can use 1
01:53:42 <EvanR> but only then
01:55:52 <ertes-w> is there a variant of unordered-containers that is more conservative regarding optimisations?  i need sets of texts right now, and for the time being unordered-containers is not trustworthy due to <https://github.com/tibbe/unordered-containers/issues/147> and <https://ghc.haskell.org/trac/ghc/ticket/13615>
01:56:19 <ertes-w> i need them in a highly concurrent setting with multiple OS threads
01:57:01 <pacak> ertes-w: containers.
01:57:05 <pacak> Data.Map.
01:57:47 <pacak> ertes-w: Most unsafe part of unordered containers is fromList and fromListWith - avoid them and it might just work.
01:58:27 <ertes-w> pacak: so start from mempty and insert?
01:58:34 <pacak> ertes-w: yes
02:00:03 <ertes-w> pacak: is HashSet actually even affected?
02:01:11 <pacak> ertes-w: I think so
02:01:34 <ertes-w> ok, thank you
02:01:39 <pacak> newtype HashSet a = HashSet {                             asMap :: HashMap a ()                           } deriving (Typeable)
02:01:41 <pacak> It is.
02:03:59 <ertes-w> i think i'll go with Set Text for now
02:04:09 <ertes-w> the "wrong results" in the title is really discomforting
02:06:17 <pacak> Read the text around WAT part :)
02:08:06 <merijn> ertes-w: I think is' mostly wrong results when you're using unsafeX
02:08:20 <merijn> ertes-w: So I don't see how it'd be an issue if you don't modify in parallel?
02:11:33 <pacak> merijn: No, it's wrong results when you use par. unsafeX is used by hashmap itself
02:11:39 <merijn> ah
02:11:51 <merijn> Still only applies to concurrent modification :p
02:15:43 <ertes-w> merijn: i'm not sure what "modification" even means in this context
02:16:20 <merijn> ertes-w: I mean, if your set is mostly read-only and you simply construct it sequentially in one thread it would be fine
02:16:34 <ertes-w> pacak: would you expect this to happen with concurrency?  i'm not actually using 'par'
02:16:40 <ertes-w> just forkIO
02:18:11 <pacak> If bgamari's theory is correct then to create a problem two modifications must start one GC cycle apart and second must start while first one is still running.
02:19:46 <pacak> I'm pretty sure it's achievable with forkIO as well.
02:25:05 <ertes-w> hmm…  in theory this particular use case should not suffer from the problem…  i create a giant set of texts at the start by parsing a text file, and then i query from lots of threads
02:25:43 <ertes-w> well, i'll go with Set just to be safe, and i'll keep an eye on the issue
02:26:41 <ertes-w> there is also a middle ground: bytestring-trie
02:26:59 <ertes-w> it's not a hash trie, but a trie on the text itself
02:31:09 <Unhammer> ertes-w,  may I ask what you're building?
02:32:53 <ertes-w> Unhammer: gathering, transforming and filtering monitoring data and feeding it into zabbix
02:33:41 <Unhammer> aha
02:33:54 <ertes-w> the part that uses the set of texts is the filtering part
02:35:54 <Unhammer> https://github.com/haskell-perf/sets and https://github.com/haskell-perf/dictionaries/ may be of use (though run the benchmarks yourself, readme's don't include memory tests)
02:37:43 <Unhammer> hm, wrengr has done a rewrite of bytestring-trie (https://github.com/wrengr/bytestring-trie/), would be interesting to compare performance
02:37:45 <Unhammer> "replaces the big-endian patricia trees with Bagwell's AMTs (array mapped tries), which are the precursor to the HAMTs used by the hashmap library"
02:49:06 <mivael> > let ht_func x = (head x, tail x) in ht_func [1,2,3,4,5]
02:49:08 <lambdabot>  (1,[2,3,4,5])
02:49:20 <mivael> Is is a common way to define ht_func point-free?   let ht_func = applyTuple (head, tail) ...
02:50:53 <pacak> @pl \x -> (head x, tail x)
02:50:53 <lambdabot> liftM2 (,) head tail
02:51:39 <pacak> :t head &&&  tail
02:51:40 <lambdabot> [c] -> (c, [c])
02:51:51 <pacak> :t liftM2 (,) head tail
02:51:52 <lambdabot> [a] -> (a, [a])
02:52:00 <pacak> :t (,) <$> head <*> tail
02:52:01 <lambdabot> [a] -> (a, [a])
02:52:17 <[exa]> what does @pl do?
02:52:22 <mivael> > liftM2 (,) head tail [1,2,3,4,5]
02:52:24 <lambdabot>  (1,[2,3,4,5])
02:52:30 <pacak> [exa]: Makes things worse.
02:52:37 <mivael> pacak, great!  Thanks.
02:52:40 <[exa]> kewl
02:52:54 <pacak> I suspect even unsafeCoerce :: [a] -> (a, [a]) might do.
02:53:14 <pacak> mivael: But it will explode on empty list.
02:53:39 <pacak> All those functions will
02:53:41 <mivael> pacak, yes, that what I want it to do in my context
02:54:01 <pacak> [exa]: transform arbitrary lamda expression into point free notation.
02:54:15 <[exa]> that explains the name, thanks :]
02:54:17 <pacak> @pl \a b c d -> c (a b) (d c)
02:54:17 <lambdabot> flip flip (flip id) . ((ap . ((.) .) . flip id) .)
02:54:24 <[exa]> oh lord
02:54:44 <pacak> That's how it makes things worse.
02:54:55 <zomg> Is there some function which works like Network.HTTP.Client.MultipartFormData's formDataBody, but just gives me a damn ByteString or something?
02:55:17 <zomg> Every function which generates HTTP POST bodies seems to insist on wrapping it in a RequestBody which is then a bit of a pain to get rid of...
02:55:46 <pacak> zomg: Is "damn ByteString" a newtype wrapper around regular ByteString?
02:57:53 <mniip> 1498469447 [12:30:47] <pacak> I suspect even unsafeCoerce :: [a] -> (a, [a]) might do.
02:57:56 <mniip> there's a problem
02:57:59 <zomg> pacak: yeah but you can only use it in the doomguy monad
02:58:06 <mniip> (,) is the 0th constructor while : is 1st
02:58:19 <cocreature> zomg: why do you want to get rid of it?
02:58:26 <mniip> so if the pointer is expected to be tagged, it will explode
02:59:00 <pacak> mniip: Well.... Almost.
02:59:36 <zomg> cocreature: I have to SHA256 hash the body
02:59:49 <zomg> or rather, get that hash of the body
02:59:53 <cocreature> “it will explode” is a pretty good explanation of unsafeCoerce for most use cases
03:00:20 <zomg> Eh I'll just write a function which pattern matches the body type
03:00:24 <zomg> that oughta do it :P
03:02:21 <mniip> why does ghc have to be so complex
03:03:12 <pacak> mniip: Performance. Features.
03:03:47 <mniip> yes but you don't get this kind of problem with similar features in, say, C
03:04:50 <pacak> strcpy...
03:04:52 <mniip> worst case the assembly around your inline assembly block is optimized wrong - but that is easily caught by inspection of the compiled assembly
03:05:01 <mniip> in stg you can only discover this at runtime
03:05:04 <mniip> when it explodes
03:05:15 <KtorZ> Hi all!
03:05:21 <pacak> worst case you expose all your state to anybody :)
03:05:39 <pacak> heartbleed or other stuff.
03:05:46 <mniip> pacak, all easily fixed
03:05:58 <mniip> have you ever tried to trace a pointer tagging bug?
03:06:20 <KtorZ> Does anyone feels like helping a fellow programmer with parameterized DSL and free monads :| ?
03:06:24 <pacak> mniip: Fixed once you know the problem.
03:06:38 <pacak> KtorZ: Hmm... We only program in javascript here.
03:06:50 <mniip> java script yes
03:06:55 <KtorZ> :o
03:07:06 <KtorZ> Then your souls are lost I guess
03:07:22 <pacak> mniip: I don't think I did, but I have experience debugging all sorts of strange bugs.
03:08:00 <mniip> pacak, https://ghc.haskell.org/trac/ghc/ticket/12523 it was a strange journey
03:08:44 <cocreature> the trick is to let other people fix the bugs for you
03:09:20 <mivael> > ((,,) <$> (+100) <*> (*200) <*> (/2)) 7
03:09:22 <pacak> mniip: For example you have a library (API to market data) with no sources available. You can connect and after 4 hours and some seconds  it will fail with about 30% chance. After that - it will fail next 4 hours. It produces really nice error message - "internal error". You can only have one copy running at a time. Sources are closed.
03:09:22 <lambdabot>  (107.0,1400.0,3.5)
03:10:01 <quchen> pacak: Huh?
03:10:40 <mniip> I don't think I've ever had to interface with closed source libraries
03:11:08 <mniip> except maybe transitively
03:11:40 <pacak> Turns out "internal error" - any error library encounters (as opposed to all other errors - produced by the exchange) and in  this case problem was caused by networks configuration - two network interfaces in the same LAN, identical ip address on both.
03:12:18 <pacak> race condition in ARP requests, packets incoming to wrong interface, routing derp, connection lost = internal error.
03:12:23 <pacak> Took several months.
03:12:37 <mniip> could take several hours if the library was open
03:13:07 <mniip> I do that a lot to stuff I use - just read the source when dubious about certain unspecified behaviors
03:14:54 <pacak>  instance Eq Message where      m1 == m2 = fromEnum m1 == fromEnum m2 
03:14:54 <pacak> ^ most recent WAT I've seen.
03:15:21 <pacak> Message - basically a string tagged with one of four conditions.
03:15:30 <pacak> parsesc
03:17:58 <quchen> pacak: What’s so bad about this Eq instance?
03:18:03 <quchen> It looks sensible to me
03:18:30 <pacak> quchen: Unexpected "foo" `compare` Unexpected " bar
03:18:35 <pacak> quchen: Unexpected "foo" `compare` Unexpected "bar"
03:18:39 <pacak> What should this return?
03:19:04 <quchen> Depends on the Enum instance.
03:19:32 <pacak> Enum instance can't keep arbitrary string so it keeps only tag itself
03:19:49 <pacak> So in this case result will be EQ because obviously "foo" and "bar" is the same.
03:19:55 <quchen> Then I’d say it’s a questionable Enum instance.
03:20:26 <pacak> Hmmm.... Yea, probably.
03:21:02 <pacak> mniip: interesting bug.
03:25:22 <quchen> I mean [a] is also not Enum.
03:25:27 <quchen> Or Maybe a
03:26:18 <quchen> One could write an Enum instance for Enum a => Enum [a], but I don’t think it would be very practical.
03:26:36 <pacak> Maybe a can be Enum
03:26:50 <quchen> And from/toEnum work only with Int, which covers a zero-subset of the entire [a] space.
03:27:31 <quchen> Maybe would be awkward though, since »toEnum 1 ===> Just 0« or something.
03:28:39 <pacak> There's EnumMap (basically IntMap that packs and unpacks keys into enum instance) - this makes enum instances for small datatypes useful
03:28:48 <pacak> We have Enum (a, b) in our codebase
03:50:31 <merijn> pacak: Why not just use Map in those cases?
03:55:17 <pacak> merijn: Performance
03:56:02 <pacak> Keeping a bunch of complicated datatypes as ints makes things faster.
04:15:33 <AnthonyWeis> hi , I have the following problem: I need function in which I can put some enums (and a list) and depending on the enums I get different results (basically just functions giving different results using a list).
04:15:35 <AnthonyWeis> so far so good
04:16:21 <AnthonyWeis> but the problem is that I can get different types returned (Int , list of Int etc)
04:16:36 <AnthonyWeis> so I need a wrapper type anyway ....
04:17:38 <AnthonyWeis> but my problem is that wehn I want to use the result I have to do a lot of pattern matching in functions that want to use this result (or throw an error or use the maybe monad)
04:18:24 <AnthonyWeis> my concrete question is , how would you do this ? or get rid of this "idea" all together and just offer a bunch of functions instead ?
04:20:23 <merijn> AnthonyWeis: Why do you want to do this in one single function?
04:21:18 <AnthonyWeis> because I'm making this for another persion who said he wants it this way... 
04:23:15 <AnthonyWeis> merijn: and if there is really no better way to than what I just described that I will try to convince him to get rid of this idea ....
04:23:59 <mivael> > let fstGivenEmptySnd (n, []) = n; fstGivenEmptySnd _ = undefined; in fstGivenEmptySnd (12, [])
04:24:01 <lambdabot>  12
04:24:03 <mivael> > let fstGivenEmptySnd (n, []) = n; fstGivenEmptySnd _ = undefined; in fstGivenEmptySnd (12, [4])
04:24:05 <lambdabot>  *Exception: Prelude.undefined
04:24:21 <mivael> Are there equivalent point-free ways of defining the fstGivenEmptySnd function?
04:25:30 <mivael> like "fstGivenEmptySnd = fst"  but with snd check
04:26:34 <AnthonyWeis> mivael: is it ok to use extra libs ?
04:27:24 <AnthonyWeis> mivael: or is it ok to define a seperate function ? (for if-then-else)
04:28:37 <mivael> AnthonyWeis, if the separate function is not point-free, then it is not what I'm curious about.
04:29:14 <merijn> mivael: What should it do if the snd is not empty?
04:29:49 <mivael> > let fstGivenEmptySnd (n, []) = n; fstGivenEmptySnd _ = undefined; in fstGivenEmptySnd (12, [4])
04:29:51 <lambdabot>  *Exception: Prelude.undefined
04:30:00 <mivael> merijn, exactly this
04:30:17 <mfukar> I thought lambdabot had a plugin to do exactly what mivael wants
04:30:42 <merijn> eww
04:32:25 <AnthonyWeis> mivael: the best I can think of is this
04:32:38 <AnthonyWeis> mivael: but I'm not sure it is what you want
04:32:43 <AnthonyWeis> mivael: ifM (null . snd) fst undefined
04:32:58 <AnthonyWeis> mivael: ifM comes from Control.Monad.Extra
04:37:59 <mivael> @hoogle ifM
04:37:59 <lambdabot> Control.Monad.Extra ifM :: Monad m => m Bool -> m a -> m a -> m a
04:37:59 <lambdabot> Extra ifM :: Monad m => m Bool -> m a -> m a -> m a
04:37:59 <lambdabot> Bool ifM :: Monad m => m Bool -> m a -> m a -> m a
04:38:54 <torstein> What's going on with these dependencies? apply-refact says it depends on: ghc (>=8.2.0 && <8.3)
04:39:07 <torstein> I thought we were on 8.0.2 not 8.2.0
04:40:33 <torstein> Even with nightly Stack snapshot I'm getting 8.0.2
04:40:36 <merijn> torstein: 8.2 release candidate atm
04:40:46 <merijn> torstein: Basically, it doesn't work with any released GHC
04:52:01 <mivael> > let fstWithCheck (n, []) = Just n; fstWithCheck _ = Nothing; in map fstWithCheck [(12, []), (34, [7])]
04:52:04 <lambdabot>  [Just 12,Nothing]
04:53:00 <mivael> merijn, I adapted the function to Maybe's... is it better this way?
04:54:21 <mivael> Re-stating: Are there point-free definitions of fstWithCheck?
04:56:07 <mivael> @pl let fstWithCheck (n, []) = Just n; fstWithCheck _ = Nothing; in fstWithCheck
04:56:07 <lambdabot> (line 1, column 22):
04:56:07 <lambdabot> unexpected "["
04:56:07 <lambdabot> expecting "()", natural, identifier, "_" or "("
04:58:43 <AnthonyWeis> mivael: the problem is the condition you have
05:03:55 <AnthonyWeis> afaik, when you ask lambdabot to transform it into pointfree (I don't know the command for pointfree in the irc , but you can use pointfree.io) than it will introduce if' (which is why I was asking if it is ok to define a new function) 
05:05:07 <AnthonyWeis> mivael: or use a plugin for your editor , to automatically convert to pointfree 
05:05:25 <mniip> @pl
05:05:26 <lambdabot> (line 1, column 1):
05:05:26 <lambdabot> unexpected end of input
05:05:26 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:05:38 <mniip> oops, didn't mean to invoke itt
05:05:45 <fendor> how can i force ghc to run a function for at most 30 seconds? 
05:06:09 <mniip> AnthonyWeis, you shouldn't use if' in your code
05:07:17 <AnthonyWeis> mniip: you mean in general or because he asked so ?
05:07:26 <mniip> in general
05:07:28 <mniip> it's a sign of poor judgement
05:07:45 <mniip> a sign that you just copied pointfree code because you think it's unconditionally better
05:08:31 <mniip> as for fstWithCheck,
05:09:01 <mniip> :t (pure . fst) <* (guard . isNull . snd)
05:09:02 <lambdabot> error:
05:09:02 <lambdabot>     Variable not in scope: isNull :: b -> Bool
05:09:07 <mniip> :t (pure . fst) <* (guard . null . snd)
05:09:08 <lambdabot> error:
05:09:08 <lambdabot>     • Could not deduce (Alternative f0) arising from a use of ‘guard’
05:09:09 <lambdabot>       from the context: (Applicative f, Foldable t)
05:09:17 <mniip> oh er, hm
05:09:23 <Axman6> fendor: https://hackage.haskell.org/package/base-4.9.1.0/docs/System-Timeout.html
05:09:46 <fendor> Axman6, thanks!
05:11:37 <mniip> :t runMaybeT $ MaybeT (pure . fst) <* (MaybeT (pure . null . snd) >>= guard)
05:11:39 <lambdabot> Foldable t => (a1, t a) -> Maybe a1
05:11:41 <mniip> this comes to mind
05:11:54 <mniip> maybe a bit excessive
05:12:06 <AnthonyWeis> mniip: amazing :)
05:12:35 <mniip> :t liftA2 (<*) (Just . fst) (guard . null . snd)
05:12:36 <lambdabot> Foldable t => (a1, t a) -> Maybe a1
05:12:37 <Axman6> so general though
05:12:43 <mniip> there,what I was trying the first time
05:12:57 <mniip> maybe event
05:13:01 <mniip> maybe even*
05:13:03 <raek> fendor: what did you mean by "run a function"? run an IO action or force the value of an expression? 'timeout' will do the trick for running IO actions.
05:13:07 <mniip> :t liftA2 (<*) (pure . fst) (guard . null . snd)
05:13:09 <lambdabot> (Foldable t, Alternative f) => (a1, t a) -> f a1
05:13:48 <fendor> raek, yes, IO action is fine
05:13:50 <mivael> mniip, thanks for the "guard" hint!
05:42:28 <ertes-w> (mStatErr, mStatOut) <- traverseOf both backupStat ("err", "out")  -- it's the little things that make you appreciate lenses =)
05:42:50 <bollu> :t if'
05:42:52 <lambdabot> error:
05:42:52 <lambdabot>     • Variable not in scope: if'
05:42:52 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
05:42:56 <bollu> what's if'?
05:43:10 <cocreature> ertes-w: I still have to smile everytime I see traverseOf and remember that it’s just "id"
05:43:12 <cocreature>  :)
05:43:22 <merijn> bollu: A non existent synonym for if-then-else as function
05:43:24 <ertes-w> cocreature: yeah, indeed =)
05:43:36 <ertes-w> cocreature: i still write it though, to communicate intent
05:43:40 <bollu> merijn ah. if' i t e = if i then t else e?
05:43:47 <merijn> bollu: Basically, yes
05:43:53 <cocreature> ertes-w: sure I do that too
05:46:00 <mniip> bollu, flip (flip . bool)
05:46:15 <bollu> :t bool
05:46:17 <lambdabot> a -> a -> Bool -> a
05:46:27 <bollu> mniip nice
05:46:48 <phadej> (false ~ true) -> false -> true -> Bool -> true
05:46:55 <bollu> mniip what is also disturbing to me is that I know what "bool" does by just looking at the type. God bless purity and parametricity.
05:47:05 <mniip> no you don't
05:47:10 <phadej> bollu: except you doesn't, there's quite many options
05:47:17 <mniip> there are about 4 functions of such type
05:47:26 <bollu> mniip yeah, but, the "correct" one :)
05:47:32 <mniip> two still
05:47:34 <phadej> bollu: there's two of those too :)
05:47:44 <bollu> mniip exactly 4, I think. fst, snd, true false order, false true order
05:47:48 <bollu> :)
05:47:59 <mniip> question is, which comes first?
05:48:03 <mniip> truth, or falsehood?
05:48:06 <phadej> mniip: false
05:48:15 <phadej> because Bool = False | True
05:48:15 <mniip> so, constructor order then
05:48:25 <mniip> figures
05:48:27 <phadej> yes, it's a "cata"
05:48:32 <merijn> bool is Bool-elimination
05:48:43 <merijn> So it mimic bool introduction (i.e. constructors)
06:09:27 <kuribas> > sort [False, True]
06:09:30 <lambdabot>  [False,True]
06:09:59 <kuribas> > toEnum False
06:10:01 <lambdabot>  error:
06:10:01 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Bool’
06:10:01 <lambdabot>      • In the first argument of ‘toEnum’, namely ‘False’
06:10:06 <kuribas> > fromEnum False
06:10:08 <lambdabot>  0
06:11:24 <phadej> that ordering make very much sense
06:11:49 <phadej> > (sort [False, True], sort [Nothing, Just ()], sort (Left (), Right ()))
06:11:51 <lambdabot>  error:
06:11:51 <lambdabot>      • Couldn't match expected type ‘[a]’
06:11:51 <lambdabot>                    with actual type ‘(Either () b0, Either a0 ())’
06:11:55 <phadej> > (sort [False, True], sort [Nothing, Just ()], sort (Left (), Right ()])
06:11:57 <lambdabot>  <hint>:1:70: error: parse error on input ‘]’
06:11:59 <phadej> > (sort [False, True], sort [Nothing, Just ()], sort [Left (), Right ()])
06:12:02 <lambdabot>  ([False,True],[Nothing,Just ()],[Left (),Right ()])
06:13:40 <abcdefgh> putStrLn "Hello, Haskell"
06:14:25 <Axman6> Hello, alphabet man!
06:14:49 <Axman6> (or woman, or whichever gender you'd prefer - on the internet, no one knows you're a dog)
06:15:01 <Larmbr> hi, I used in my code the qualified name Data.Foldable.length,  but got the error message:  Not in scope: ‘Data.Foldable.length’ Perhaps you meant one of these: ‘Data.Foldable.and’ (imported from Data.Foldable).....  Why?
06:15:16 <abcdefgh> Maybe Man
06:15:22 <mniip> Larmbr, is Data.Foldable imported qualified?
06:15:28 <mniip> or, imported at all
06:16:06 <phadej> probably you have `import Data.Foldable (and)` or something similar?
06:17:12 <phadej> or import qualified Data.Foldable (and) -- which is a bit confusing syntax, it imports Data.Foldable qualified with only `and` visible
06:17:23 <Larmbr> mniip, no, and I tried it also, also got the same error.
06:17:32 <abcdefgh> Hello, Axman6!
06:17:52 <Axman6> you can't just use a qualified without importing the module (this would make the life of the poor compiler writers very painful)
06:18:20 <geekosaur> other reasons include having an old enough "base" that length isn't in Data.Foldable (that is, ghc 7.8 or older)
06:18:23 <phadej> but then it won't suggest `Data.Foldable.and` either
06:18:57 <Axman6> Larmbr: can you share your code?
06:19:18 <Larmbr> mniip, I tried to import the length function explicity in import, and got this: Module ‘Data.Foldable’ does not export ‘length’
06:19:30 <mniip> ghc version?
06:20:31 <Larmbr> 7.8.4
06:20:43 <geekosaur> yes, exactly
06:20:52 <mniip> that's old-ish, possibly iy wasn't introduced back then
06:21:00 <geekosaur> it wasn'ty
06:21:04 <geekosaur> as I already said
06:21:18 <geekosaur> length was in Data.List and Prelude before ghc 7.10
06:21:43 <Larmbr> oh, I hoogle'ed it , but got no version info, how can I know exactly whether a function is exported from a module or not? Thanks
06:21:43 <mniip> andit wasn't polymorphic
06:21:55 <mniip> :browse Data.Foldable
06:22:11 <mniip> iirc
06:22:49 <geekosaur> Larmbr, use hoogle or hayoo to get he package, follow it to hackage and then select the version you have installed (as shown by "ghc-pkg list")
06:24:35 <mnoonan> If anybody has a few minutes, I'm looking for some feedback on this slide deck in progress: http://haskell.storm-country.com/presentation.html
06:25:41 <Larmbr> geekosaur, mniip, Thank you both!
06:28:59 <Axman6> mnoonan: WTFBool = PHPBool :P
06:29:06 <mnoonan> heh
06:29:24 <mnoonan> I was thinking of http://thedailywtf.com/articles/What_Is_Truth_0x3f_ :)
06:30:28 <Axman6> mnoonan: might want to give examples of values of type SomeOf, for example. developers who've never seen sum types will probably find that quite confusing (I know the first years I've taught sometimes don't get it even after a whole semester)
06:31:05 <[exa]> mnoonan: "launchMissiles" :]
06:31:37 <mnoonan> Axman6: that's a good point. this is intended for a pretty knowledgeable audience, but it couldn't hurt
06:32:56 <Axman6> (I understand you go on to show Maybe, but it's worth pointing out what that new syntax means as soon as you introduce it - also you may be able to help any C devs out by saying it's like a safe tagged union: struct tagged {enum taggedKind kind; union {int intval; double doubleval}} as the unsafe C equivalent of Either Int Double )
06:33:06 <ertes-w> type Bool = Ordering
06:33:46 <Axman6> mnoonan: you use both Text and String, I would stick to one and avoid the question
06:34:22 <mnoonan> oh, that was a mistake. I started with all Text, and then tried to edit it back to Strings for simplicity
06:35:26 <mniip> " Types are inferred, annotations are optional. "
06:35:31 <mniip> oh what a sweet lie
06:35:44 <mnoonan> aww, is it that bad? :)
06:35:54 <Axman6> no, but it's not always true
06:36:06 <Axman6> you know you're wriing fun code when that isn't the case
06:37:29 <Axman6> I think I've also run into cases where I broke things if I did write the type sig, but that's probably because I got the type wrong
06:39:13 <mniip> @let f x = f (x, x)
06:39:14 <lambdabot>  .L.hs:197:7: error:
06:39:14 <lambdabot>      Ambiguous occurrence ‘f’
06:39:14 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
06:39:21 <mniip> @let fun x = fun (x, x)
06:39:22 <lambdabot>  .L.hs:197:9: error:
06:39:22 <lambdabot>      Ambiguous occurrence ‘fun’
06:39:22 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.fun’,
06:39:42 <mniip> dammit
06:39:44 <mniip> @let hunter2 x = hunter2 (x, x)
06:39:45 <lambdabot>  .L.hs:197:1: error:
06:39:45 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ (t, t)
06:39:45 <lambdabot>        Expected type: (t, t) -> t1
06:39:53 <mniip> mnoonan, see above
06:40:05 <mniip> you can however make it compile with hunter2 :: a -> b
06:41:29 <mniip> haskell98 is compatible with HM, and HM, iirc, can infer any type except for type-changing recursion
06:42:01 <mniip> RankN adds a whole bunch of cases
06:42:08 <mniip> so does TypeInType
06:43:36 <mniip> also with TypeInType, iirc the kind inference "algorithm" as implemented right now in ghc isn't very sound or at least not mathematically proven
06:45:25 <mniip> type families can use irrelevant kind arguments in relevant positions (what should be a pi-type turns into a forall-type) and thus break kind parametericity
06:45:54 <mnoonan> all fair, but perhaps well out of scope for this presentation
06:46:05 <mniip> yes
06:46:17 <mniip> I got carried away
06:47:34 <Cale> mniip: Haskell 98 is already a fairly big department from HM, in that it supports type classes.
06:47:54 <mniip> "compatible" though, no?
06:48:14 <ventonegro> mnoonan: Are IO actions a result of laziness? Idris has them
06:48:22 <Cale> Well, you can't infer all the types any more
06:48:26 <mniip> you can implement instance resolution on top of HM
06:48:36 <Cale> yes
06:48:46 <mniip> "any more" can HM?
06:49:19 <heebo> hello is there a way to list all elems of an enum?
06:49:25 <mniip> oh I guess it can try to infer polymorphic recursion in absence of typeclasses...
06:49:26 <mnoonan> ventonegro: no, I'm thinking more that the distinction between creating and executing an IO action is clearer with laziness (I think SPJ has made a comment to the same effect, that strictness would have made "cheating" with IO too easily, and the monadic approach may not have been found)
06:49:35 <geekosaur> heebo, also derive Bounded
06:49:50 <geekosaur> > [minBound .. maxBound] :: [Bool]
06:49:52 <lambdabot>  [False,True]
06:50:13 <heebo> thanks
06:50:15 <geekosaur> heebo, although if you know the lowest one then you can probably do
06:50:29 <geekosaur> > [False ..] :: [Bool]
06:50:32 <lambdabot>  [False,True]
06:50:34 <Cale> mniip: Or it can just reject programs with polymorphic recursion
06:50:44 <ventonegro> :t enumFromTo
06:50:45 <lambdabot> Enum a => a -> a -> [a]
06:50:55 <ventonegro> :t enumFrom
06:50:57 <lambdabot> Enum a => a -> [a]
06:50:59 <Cale> (Which I believe it did originally, unless I'm mistaken)
06:51:02 <heebo> oooh 
06:51:03 <raek> > [minBound ..] :: [Bool]
06:51:05 <lambdabot>  [False,True]
06:51:14 <geekosaur> those are just the wordy forms of what I wrote
06:51:17 <heebo> i like the bounded
06:51:27 <geekosaur> enumFrom x is [x ..]
06:51:37 <heebo> oh that feeling when you get haskell to do the work for you.... so full of win!
06:51:54 <Axman6> > [minBound ..] :: [Word8]
06:51:56 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:52:03 <Cale> mniip: The way I understand it, polymorphic recursion is another thing that Haskell's type system does that HM doesn't.
06:52:11 <phadej> original HM does't have letrec
06:52:18 <mniip> oh
06:52:21 <phadej> thus polymorphic recursion is a bit out of scope
06:52:22 <mniip> yes, that would explain it
06:52:41 <heebo> so can one derive Bounded for Integer?
06:52:57 <heebo> im not going to do it btw
06:53:09 <geekosaur> no, Integer is not Bounded and you can't derive it
06:53:12 <mniip> no
06:53:16 <Axman6> > fix (\f x -> show x ++ f (x,x)) ()
06:53:18 <lambdabot>  error:
06:53:18 <lambdabot>      • Couldn't match type ‘()’ with ‘((), ())’
06:53:18 <lambdabot>        Expected type: ((), ()) -> [Char]
06:53:23 <geekosaur> what is the smallest Integer?
06:53:41 <geekosaur> (answer depends on how much VM your program can use)
06:53:47 <mniip> Integer uses unboxed types in its constructors so a deriving clause is not possible
06:54:02 <mniip> geekosaur, no, it depends on the limb size
06:54:03 <heebo> ah thanks... just wondered
06:54:19 <mniip> whether the program can store that integer is another question
06:54:54 <Axman6> 2^(8*2^30)+2^(2^30)
06:55:00 <Axman6> uh, 40
06:55:06 <geekosaur> ok, we can play pendantic and bury the real point as deeply as possible
06:55:07 <Axman6> ok, that calculation is completely wrong
06:55:12 <geekosaur> I guess that means I should not discuss it
06:55:12 <mniip> about 2^(64*(2^63-1))-1
06:55:17 <mniip> if I'm not mistaken
06:55:46 <geekosaur> (hint: the real point is _conceptual_, not details of implementation)
06:59:35 <Axman6> I wonder if there exist any implementations of sparse arbitrary precision integers - surely numbers of the form 2^n + 2^m... where the number of powers are very small are common in some domains - possibly cryptography
07:00:26 <mniip> hmm, did not realize #haskell is 5th largest channel
07:00:44 <mnoonan> in between ##linux and #bitcoin when I checked
07:01:16 <Axman6> are we still larger than #python? I remember we were a few years ago
07:01:23 <mniip> nope
07:01:29 <mniip> python is #1
07:01:38 <Axman6> hmm, maybe we weren't then
07:02:06 <geekosaur> iirc we were and #ubuntu was #1
07:02:14 <Axman6> we were definitely larger than some other large channels! (for some arbitrary definition of large, which includes channels smaller than #haskell but not much smaller)
07:02:20 <mniip> ubuntu isn't even around
07:02:23 <Axman6> yeah you might be right
07:03:20 <mniip> mnoonan, the "lots of research" slide
07:03:31 <mniip> is it supposed to be a list of research currently occuring?
07:03:50 <mniip> seems weirdly thrown together
07:04:01 <mnoonan> no.. it is just weirdly thrown together :)
07:04:06 <mnoonan> open to suggestions there
07:06:42 <mniip> what is the scope of the presentation
07:06:45 <mniip> or rather, the audience
07:07:03 <mnoonan> actually, I dislike most of the bullet-point slides in that last section. they are mainly to combate the "but nobody uses it" / "but there are no libraries" / etc kind of thoughts
07:08:05 <mnoonan> 50% CS phds, 50% developers. mostly C++, but with plenty of lisp, scheme, ocaml, secret-functional-language-X people thrown in
07:12:53 <mivael> A solution to my original question:
07:13:02 <mivael> > let fstWithCheck2 = fromJust . f; f = (<*) <$> (Just . fst) <*> (guard . null . snd)   in fstWithCheck2 <$> [ (12,[]), (34,[]), (56,[7]) ]
07:13:05 <lambdabot>  [12,34,*Exception: Maybe.fromJust: Nothing
07:13:20 <Axman6> heh
07:13:36 <mniip> that's the same as I wrote but with <$><*> instead of liftA2
07:13:44 <mivael> mniip, yes
07:14:02 <mivael> I used your suggestion.
07:14:13 <mivael> Just added fromJust for completeness.
07:16:05 <Axman6> well, incompleteness actually :P
07:16:42 <mivael> Axman6: well... okay  :)
07:18:09 <mivael> Axman6, I just need a program to exit with a nonzero exit code on wrong input, nothing more than that.
07:19:16 <Axman6> I personally would prefer a more explicit error message than that, the worst thing when running someone else's code is when it crashes with "Prelude.head: empty list!"
07:19:41 <mivael> Axman6, me too.  Generally.
07:24:25 <mivael> But as I said earlier, I have a context where absense of sensible error messages on wrong input is still okay (and even desirable because the size of source code matters).  It is enough that a program actually fails on wrong input.
07:25:28 <Axman6> > sequence [(12,[]), (34,[]), (56,[7]) ]
07:25:30 <lambdabot>  error:
07:25:30 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M690833110649...
07:25:30 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
07:26:01 <Axman6> > sequence [(12,[]), (34,[]), (56,[7::Int]) ]
07:26:03 <lambdabot>  error:
07:26:03 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M413076043021...
07:26:03 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
07:26:07 <Axman6> hmm
07:26:45 <torstein> Does anyone know if it's possible to map tuples in Accelerate? Like this: (Exp a -> Exp b) -> Exp (a, e) -> Exp (b, e)
07:30:30 <torstein> If it's possible to do: (Exp a, Exp b) -> Exp (a, b) then mapping tuples should be possible
07:32:32 <Axman6> can you use fst and snd? I can't remember how/if functions like that can be arbitrarilly lifted into Exp
07:34:16 <torstein> Axman6: Yes. I figured it out, but I have no idea at all why it works: fstMap :: (Elt a, Elt b, Elt e) => (Exp a -> Exp b) -> Exp (a, e) -> Exp (b, e); fstMap f tup = lift (f (A.fst tup), A.snd tup)
07:34:49 <Qfwfq> Has anyone written something to manage stack interpreter scripts in Emacs? Something like: an interpreter process per script, with arguments borrowed from options in the source file.
07:35:19 <torstein> lift does this: (Exp a, Exp b) -> Exp (a, b) , maybe it's using a Type Family or something
07:36:38 <Axman6> what's the type of lift?
07:38:30 <torstein> Axman6: lift :: e -> c (Plain e)
07:39:24 <Axman6> is that it? there's no class constraint?
07:39:31 <Axman6> hmm, maybe Plain is a type class
07:39:34 <Axman6> uh, type family
07:39:55 <Axman6> so won't work if there's no instance of Plain for a given e
07:41:43 <torstein> Yes that's it. Something funky is going on behind the scenes. Hard to reason about
07:42:33 <NickHu> I wondered if anyone could help me debug https://ghc.haskell.org/trac/ghc/ticket/13137
07:42:53 <NickHu> I have it on nixos when trying to use accelerate-llvm as mentioned in the ticket
07:51:49 <jchia_> I'm trying to use gitlib-3.1.1. The tutorial seems out of date: https://www.stackage.org/haddock/lts-8.20/gitlib-3.1.1/Git-Tutorial.html
07:52:09 <jchia_> The link to 'openRepository' is broken. Does someone have a working example?
07:52:30 <jchia_> withRepository' et al have a complicated type: https://www.stackage.org/haddock/lts-8.20/gitlib-3.1.1/Git-Repository.html
07:52:38 <orion> What's the average compensation for a mid-level functional programming job?
07:52:44 <orion> On the east coast.
07:52:48 <jchia_> I don't what I'm supposed to do to provide a RepositoryFactory
07:52:59 <jchia_> "I don't know"
07:53:09 <heebo> orion : it doesnt work like that
07:53:27 <heebo> some languages tend to pay more than others
07:53:58 <orion> I see.
07:54:55 <heebo> then there are some weird niche peaks and troughs, it could be calculated but it would be pretty much meaningless
07:55:47 <heebo> imho scala and spark , python ( the big data and data science , machine learning languages) are paying most at the moment
07:56:59 <heebo> haskell not so much .....
07:57:13 <orion> :<
07:57:46 <max3> can someone help me figure this line out: https://github.com/databrary/databrary/blob/1e2a94ac93aa6548db418d9dea5edf2b088a9609/Databrary/Model/Format.hs#L66
07:58:01 <AndreasK> When i looked for haskell jobs in Austria online I found a single advertisment from 3 years ago. In Total :(
07:58:06 <max3> seemingly this is some sort of syntax for caching the result of loadFormats
07:58:09 <heebo> orion: but on the positive side , theres still a strange notion that haskell developers are brainiacs
07:58:54 <heebo> so going to an interview for a crappy language like scala and saying you know haskell should put you in a positive light
07:59:11 <max3> what is $() syntax for? is that TH?
07:59:28 <heebo> you'll get paid well, but then you'd have to hack scala
08:00:46 <jchia_> I found gitlib example here using hackage reverse dependency: http://hackage.haskell.org/package/git-gpush-3.1.0.1/src/Main.hs
08:00:56 <orion> heebo: Mind if I PM you?
08:01:18 <mnoonan> max3: yes, a TH splice
08:01:19 <geekosaur> max3, yes
08:01:30 <mclark1129> I'm hoping that learning Haskell will help me write better F#
08:02:09 <glguy> writing more programs in F# will make you a better F# programmer
08:02:49 <mclark1129> For sure, but there are definitely overlapping concepts.  A lot of the stuff Scott Wlaschin posts are in F# but heavily rooted in Haskell.
08:04:53 <c_wraith> learning Haskell mostly makes you miss Haskell when using other languages.  Every day I want traverse and traverse_ in other languages...
08:05:35 <mclark1129> c_wraith: I can see that.  I'm a functional programming n00b but so far I've found Haskell the most enjoyable to try and learn.
08:06:07 <mclark1129> Like in F# you can't leverage typeclasses, so you can't really write a generalized (>>=)
08:06:49 <c_wraith> Nor do you have higher-kinded polymorphism, so you can't even say what traverse does in the type system...
08:07:00 <heebo> mclark1129: perhaps it will, or perhaps learning haskell will encourage you to try and use reimplemented core libraries to be more haskell like. This happened in the scala world with a library called Scalaz. Scalaz confuses the hell out of the scala compiler and throws up intractable stack traces.
08:07:44 <Axman6> mclark1129: any reason you need to us F#? (not a trick question, "because that's what we're using" and "we need to interface with some .Net library" are acceptable answers :))
08:08:13 <Axman6> heebo: that's mostly because Scala is broken though
08:08:29 <mclark1129> Axman6: Pretty much because I work in a .NET shop.
08:09:51 <heebo> Axman6: agreed. So maybe you will be a better programmer because you'll spend lots of time trying to patch over broken bits in your language, but it could also make you "appear" a lot worse
08:10:04 <Axman6> I don't hear a lot about F# these days. we used to hear the insane ramblings of Jon Harrop and his thinly veiled vendetta against Haskell, but not much lately
08:10:26 <mclark1129> And when I say "help me write better f#" I'm thinking mostly that Haskell forces you to be pure so I can't fall back to OO features of F# and Scala
08:11:31 <Axman6> yeah, that is a very good reason to be learning Haskell, it's much harder to resort of bad habits
08:11:36 <mclark1129> But lately I've been big into the idea of CQRS, and so far I've found the amount of boilerplate functional languages help me eliminate very encouraging.
08:11:53 <heebo> mclark1129: but if you are using a broken language its sometimes better to be idiomatic and impure
08:13:05 <mclark1129> heebo: perhaps, but at least I will know when I'm being impure
08:13:13 <heebo> :)
08:13:59 <mclark1129> I'm chronically bad about sticking to side projects when using C#
08:14:30 <mclark1129> mainly because I have to spend so much time thinking about "Hmm, what will my namespaces be?" and just setting up project boilerplate becomes cumbersome and boring.
08:15:49 <bollu> Axman6 unsafePerformIO all the things ;)
08:17:07 <c_wraith> that doesn't really work.  Though some people have been really dedicated to trying to make it work and become enraged when it doesn't.
08:17:26 <drewbert> I mostly use python.  I like it. I like haskell too, but each one makes me angry that the other is not better. 
08:17:38 <drewbert> Where is my god-language.
08:17:43 <shapr> write it!
08:17:58 <mclark1129> c_wraith: What doesn't work?
08:18:20 <Cale> drewbert: What bothers you about Haskell?
08:19:11 <Axman6> bollu: I'm gonna be a little cranky if I see even a single unsafePerformIO in the LLVM stuff you're working on ;)
08:19:20 <c_wraith> mclark1129: unsafePerformIO'ing everything. :)
08:19:29 <mclark1129> gotcha
08:19:30 <bollu> Axman6 fear not, I am a lover of purity ;)
08:19:51 <Axman6> bollu: I'm super excited by the project btw
08:20:11 <drewbert> Cale: A number of things. I don't like the way whitespace is parsed.  I don't like I poorly it lends itself to tool-assisted code completion.  I don't like that the encouraged style is so mathy and terse.  I'm not here to gripe though. I like haskell! It was just idle chatter.
08:20:12 <bollu> Axman6 that makes two of us :D thanks. I wish I could spend more time on it tbh
08:20:25 <bollu> Axman6 but I'm trying to maintain work/life so I don't get burnt out
08:20:37 <Axman6> bollu: is it just you? or are there a few of you (ie, a research project at a university)?
08:20:56 <bollu> Axman6 this is just me. There are people I talk to about it (I'm at uni), but for development it's "just me"
08:21:14 <mnoonan> bollu: what are you working on?
08:21:33 <bollu> Axman6 I work on LLVM related stuff "at work" as well (I'm an intern), so I get to "deep dive" about this which is nice
08:21:35 <Axman6> would be great to see it become an official project of some kind (with some backing so you can help support the life part of the ballance)
08:21:36 <Cale> drewbert: Was just curious whether I'd be able to offer a solution to something, but stuff about the concrete syntax, I can't really help with :)
08:21:43 <bollu> mnoonan https://pixel-druid.com/blog/announcing-simplexhc/
08:21:50 <bollu> Axman6 yes, that's true.
08:21:54 <Axman6> bollu: ah great, sounds fun
08:22:00 <bollu> Axman6 let it compile something first, then I can ask for help
08:22:23 <mnoonan> bollu: ah, cool!
08:22:24 <bollu> Axman6 thanks for the kind words :) means a lot.
08:22:26 <Axman6> pfft, spoken like a true engineer
08:22:35 <Axman6> get the money, then make it work!
08:23:12 <shapr> drewbert: are you using intero for code completion?
08:24:09 <Cale> drewbert: One thing I will say about the encouraged style in Haskell is that generally it's a good idea for identifiers to get longer the wider their scope becomes and shorter the more frequently they're used in that scope. A lot of variables in Haskell programs only scope over a single line -- it's often okay that they're a single letter in this case, because you're guaranteed to see the point where they're brought into scope. 
08:24:09 <Cale> Moreover, there are often a lot of variables whose type is so polymorphic that no really meaningful name could be given.
08:25:04 <bollu> Cale that's what I always think to myself when I read "consider a group G..." :)
08:25:11 <Axman6> drewbert: part of the reason why code completion isn't amazing is because Haskell lets you write incredibly generic code, so in almost all cases there are literally thousands of possible functions you could use somewhere. really hard for a tool to deal with that properly, but allows us to make great code
08:25:15 <bollu> Cale "it's so polymorphic you can't mname it"
08:25:16 <bollu> name*
08:26:23 <AndreasK> I would be happy if code completion would be easy to get working at all outside of "use this version of emacs with these plugins" xD
08:27:06 <Cale> Axman6: Yeah, one thing which can be envied about the whole object.method syntax is what it does for auto-completion.
08:27:41 <Axman6> Cale: I always wonder if that last statement is a bit of a cop out, but do agree with it (in fact, I believe that using more concrete names hinders thinking about things as generally as you could - foldr combiningFunc initialElement (firstElement:restOfElements) doesn't help with seeing that initialElement could in fact be something like id and the elements of the list could be functions
08:27:43 <Cale> But when you write the function first, it's harder for any tool to know what you might be after
08:28:11 <Cale> Axman6: right
08:28:45 <Axman6> const returned ignored = returned
08:28:48 <Cale> and in cases that those things are all bound on the same line, or the line above -- it's actually a good deal harder to read than  foldr f x (v:vs) or something
08:28:51 <Axman6> not sure how I feel about that
08:29:29 <Axman6> Cale: agreed
08:29:57 * Axman6 -> bed
08:30:38 <Cale> I actually feel more often than not that the identifiers in the Haskell code I work on are annoyingly *long*
08:30:51 <Cale> Of course, there's not much to do about that
08:31:38 <bollu> Cale I also dislike the default scope of fields in data declarations.
08:31:43 <bollu> global is annoying
08:31:47 <bollu> you need to prefix everything
08:31:51 <Cale> In particular, record field names sort of need to be long -- we use the _typeName_fieldName style in the codebases I work on, and that ends up resulting in rather long names sometimes.
08:32:15 <Cale> (but in exchange, we get a lot of useful template haskell automation...)
08:32:16 <bollu> yeah, exactly.
08:32:18 <bollu> exactly*
08:32:27 <mclark1129> Cale: Is that to avoid conflicts for getters?
08:32:34 <Cale> mclark1129: Not just for that
08:32:41 <Cale> But that's part of it
08:33:14 <Cale> If it was just for that, we wouldn't need such a rigid style and could use shorter prefixes
08:33:16 <AndreasK> Besides style is there a reason why fieldnames couldn't be a namespace belonging to the type?
08:33:53 <Cale> But also, various automatic bits of Template Haskell which we apply tend to want that very specific format.
08:34:01 <c_wraith> AndreasK: it breaks type inference
08:34:16 <Cale> (e.g. stuff for generating JSON marshalling code, and lenses)
08:34:39 <Cale> AndreasK: You can sort of get away with that, but it doesn't work very well.
08:34:56 <c_wraith> AndreasK: I mean, have you tried to use -XOverloadedRecordFields?  It's painful.
08:35:16 <Cale> We *really do* want those field extraction functions to be handy
08:35:43 <Cale> and have well-determined types
08:36:51 <Cale> There's this newfangled extension to try to fix the issue as well, and while I haven't yet had the chance to actually try it, I'm not really all that hopeful
08:38:10 <Cale> (OverloadedLabels, I think)
08:38:30 <AndreasK> c_wraith: I was thinking of the approach where you would write type::fieldName so it would still be unique. But then that it's pretty much the same as naming them with the type as prefix I guess
08:38:39 <AndreasK> So not all that useful
08:38:44 <Saizan> if each record type declared its own submodule containing the fields, you would have TypeName.fieldName, but there are no submodules
08:39:49 <Cale> You *can* just define each type in its own module.
08:54:04 <heebo> hello does anyone know how to detect cycles in an fgl directed graph
09:00:51 <locallycompact> is there a less mental version of writing foo = (((singleton .) .) .) . Foo
09:01:09 <locallycompact> where Foo is a four field record constructor
09:02:56 <mniip> locallycompact, some people define :::. = (.) . (.) . (.) . (.)
09:03:03 <mniip> or rather .:::
09:04:17 <dolio> \a b c d -> singleton $ Foo a b c d
09:04:48 <locallycompact> yeah looking for a point free
09:04:49 <geekosaur> ^ sometimes that's just telling you that pointfree's a bad idea
09:05:10 <dolio> You should stop looking for a point free answer. :)
09:05:15 <locallycompact> chundlebuns
09:05:16 <locallycompact> ok
09:06:29 <dolio> I think the best answer there might be: curry4 $ singleton . uncurry4 Foo
09:06:40 <dolio> But (un)curry4 doesn't exist.
09:31:47 <testing3> @pl (\(x,y)->(x,y))
09:31:47 <lambdabot> id
09:31:51 <testing3> @pl (\(x,y)->(x,y+1))
09:31:51 <lambdabot> second (1 +)
09:33:24 <testing3> @pl (\f,g,(x,y)->(f x, g y))
09:33:24 <lambdabot> (line 1, column 7):
09:33:24 <lambdabot> unexpected "("
09:33:24 <lambdabot> ambiguous use of a non associative operator
09:33:36 <testing3> @pl (\f,g,(x,y) -> (f x, g y))
09:33:36 <lambdabot> (line 1, column 7):
09:33:36 <lambdabot> unexpected "("
09:33:36 <lambdabot> ambiguous use of a non associative operator
09:33:43 <testing3> @pl (\f g (x,y) -> (f x, g y))
09:33:44 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
09:33:50 <kuribas> :t (.).(.)
09:33:51 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
09:34:10 <unknownln> Oh jesus that's certainly some code right there
09:34:59 <testing3> @pl (\f (x,y) -> (f x, y))
09:34:59 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
09:35:13 <slabity> What's a good resource for someone new to haskell, but familiar with functional programming?
09:37:12 <mclark1129> http://book.realworldhaskell.org
09:37:23 <mclark1129> http://learnyouahaskell.com/
09:39:21 <jgrey> createProcess (shell "sleep 5 && ls -la") returns immediately. is it possible to block until the shell command finishes?
09:40:29 <testing3> @pl (\u v -> f u (g v x))
09:40:30 <lambdabot> (. flip g x) . f
09:55:13 <mclark1129> I'm trying to use ExceptT, but I can't seem to import control.Monad.Except
09:55:21 <mclark1129> is that a separate package I have to install?
09:55:46 <Philonous> Yes, mtl
09:56:39 <Philonous> (That is: "mtl" is the name of the package you need add in order to import Control.Monad.Except)
09:56:47 <mclark1129> Cool, thx
10:24:40 <greymalkin> Having some serious `stack` problems I've cloned the `lenses` library and am trying to build it alongside a codebase that needs template haskell. As a result, I want to pull my `template-haskell` library back to 2.9; I've change the cabal requirements for lenses, but the build is still failing.
10:24:47 <greymalkin> http://lpaste.net/356496
10:25:33 <greymalkin> It's still trying to pull in template-haskell-2.11.1.0
10:26:09 <greymalkin> There are no other version requirements on template-haskell in my .cabal. Am I down-versioning correctly in that stack.yaml?
10:27:14 <sm> greymalkin: are you sure you fixed the template-haskell bounds in lenses.cabal ?
10:27:24 <sm> all of them, I mean
10:28:36 <greymalkin> sm, There's only two locations that it shows up, one for TH version 2.3 and below, and one for 2.4 and above; the 2.3 dependency was not triggering and the 2.4 had no upper limit, so I added <2.10.
10:29:33 <greymalkin> It's mentioned nowhere else in lenses.cabal, and the other dependencies are `mtl >= 1.1` and `base >= 4 && < 6`
10:30:00 <sm> you could paste stack build --dry-run [--debug] maybe
10:30:35 <sm> or maybe it's [--verbose]
10:31:35 <sm> or --cabal-verbose.. something that makes it explain the install plan
10:33:28 <greymalkin> http://lpaste.net/356497
10:33:55 <greymalkin> it's listing template-haskell; but does not include where else it may be coming from.
10:34:04 <greymalkin> Maybe I should restrict that to just the build for lenses...
10:35:39 <quchen> edwardk: Is there anything left in the way of a patch version bump of ansi-wl-pprint? Got an adaptor module waiting for release :-)
10:37:13 <sm> greymalkin: this looks like it should work. It thinks something is forcing use of t-h 2.11.1.0, but I'm not seeing what
10:37:44 <sm> maybe comment out t-h from the extra-deps and see what else complains
10:38:40 <greymalkin> Same complaint.
10:45:03 <glguy> greymalkin: you don't get to downgrade your template-haskell package
10:45:35 <sm> ohh.. ghc pins it ?
10:45:39 <greymalkin> glguy: Ugh. That means I need to upgrade lenses. Too much depends on my base at this point (webapp, go figure)
10:46:09 <greymalkin> That would make sense, I was just noticing something to that effect, since the git repo listed for template-haskell is just the same as for ghc
10:46:22 * sm wishes cabal/stack build plan failures were more informative
10:49:33 <greymalkin> So now the question becomes: How do I determine which version of GHC corresponds to which version of t-h... I need the ghc version for t-h 2.10 so that I can make the conditional source directory in lenses (at least, if I'm going to do this right)
10:50:05 <glguy> what needs to be conditional?
10:51:19 <glguy> https://www.haskell.org/platform/contents.html
10:53:43 <greymalkin> glguy: `lenses.cabal` has a `If impl(ghc >= 6.12)` line in it to distinguish between pre 2.4 and 2.4-and-later.
10:55:18 <greymalkin> The really ironic part is that I only need lenses because the AWS library that I've been directed to needs it.
10:56:54 <glguy> why's that ironic? (I don't know the aws libraries)
10:57:20 <greymalkin> Because I didn't want lenses, and now that I'm two days from deadline, I suddenly need to learn them.
10:57:46 <greymalkin> If I had brought them in towards the beginning of the project, I would have been better prepared to deal with this.
10:58:46 <mclark1129> Ok, I know this is so basic but I cannot seem to grasp how to use Monad Transformers
10:59:02 <mclark1129> I'm trying to do something simple like wrap IO with exception data, using ExceptT
10:59:12 <_sras_> Using stack, how can I load the "test" target in GHCI?
10:59:57 <mclark1129> if I'm doing: appendFile "test.txt" "Hello World"
11:00:11 <mclark1129> what is the correct way to wrap the resulting IO () with ExceptT?
11:01:27 <xcmw> mclark1129: liftIO
11:01:35 <quchen> Nah
11:01:44 <quchen> ExceptT . try
11:02:16 <quchen> …up to laziness shenanigans
11:02:33 <quchen> Wait, nevermind, it should work
11:04:35 <xcmw> mclark1129: If the append fails do you want it to fail in Either or IO?
11:06:08 <geekosaur> [26 18:04:13] <xcmw> mclark1129: If the append fails do you want it to fail in Either or IO?
11:06:24 <sm> greymalkin: just curious, what AWS lib depends on lenses ? that package looks pretty old & little-used
11:07:42 <mclark1129> geekosaur: Whatever is most appropriate, ultimately I want to chain operations together and pass along error messages
11:08:43 <greymalkin> sm: amazonka (and -*)
11:08:59 <xcmw> mclark1129: I think you want quchen's answer. If the append fails it will fail in either.
11:09:13 <sm> sure it's not https://hackage.haskell.org/package/lens you want ?
11:09:23 <mclark1129> xcmw: Got disconnected after asking the question ,didn't see quchen's answer.
11:09:31 <quchen> ExceptT . try
11:09:48 <quchen> try catches the IO exception in an Either, ExceptT wraps it.
11:09:58 <greymalkin> I have been using the "pretty old and little used" one for a while for some basic S3 operations, and it's been wonderful. Gave me the ability to replace it's http manager with the one given by the Yesod stack; allowed me to easily substitute my own logger... but when I started to need SNS, the honeymoon soured.
11:10:22 <guest223> As a beginner, where should I start?
11:11:06 <lyxia> greymalkin: I see them depending on lens, not lenses
11:11:32 <xcmw> guest223: http://learnyouahaskell.com/chapters or http://book.realworldhaskell.org/read/
11:11:41 <greymalkin> Well. Now. I feel dumb.
11:12:07 <sm> now everything will be better :)
11:12:21 <ReinH> @where learnhaskell
11:12:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:12:30 <quchen> guest223: Or Hutton’s book. So many choices
11:12:37 <ReinH> guest223: I would not recommend xcmw's links.
11:12:48 <ReinH> Hutton's new book is great.
11:13:03 <sm> https://leanpub.com/haskell-cookbook
11:13:13 <ReinH> I wish people would stop recommending LYAH and RWH. It's 2017, there are much better options.
11:14:19 <mnoonan> I liked the topics in RWH, it seems like an updated version would be nice to have.
11:14:34 <ReinH> I agree, but until we have one I can't recommend it.
11:14:55 <ReinH> If your first experience with Haskell is wondering why the code in your book won't compile, you're going to have a bad time.
11:15:17 <greymalkin> I have to run, but I'll check for this answer later: How did you so quickly determine that the `aws` library was "pretty old & little used" I have had terrible luck finding the right package when I need it.
11:16:37 <doyougnu> guest223: It's just like any other language. Find a good book, write code, ask the community questions
11:17:09 <lyxia> greymalkin: I think sm was talking about lenses, which was last updated two years ago.
11:17:29 <quchen> And more importantly, you need a project to practice :-)
11:17:30 <sm> greymalkin: right. I looked at the reverse deps, here: http://packdeps.haskellers.com/reverse/lenses
11:17:39 <guest223> thanks everyone
11:17:49 <quchen> But first, you’ll probably have to read at least the first few chapters of some book.
11:18:21 <sm> which I usually have set to a browser shortcut (need to set that up for firefox now)
11:18:29 <guest223> i read the starting chapters of lyah and rwh
11:19:01 <quchen> RWH is very good, but unfortunately pretty dated. The examples are still relevant, but many won’t compile anymore. It’s 10 years old, after all.
11:19:32 <quchen> I recommend revisiting it when you’re already a bit more familiar with Haskell, it’ll show you a lot of useful examples that you can understand and maybe fix up as a mental exercise.
11:20:05 <quchen> LYAH is what I started with; I thoroughly enjoyed it, but it’s not much more than an appetizer, and stops after the very basics.
11:20:30 <quchen> The other books I haven’t read; I liked that Haskell From First Principles has exercises, and Hutton’s book also has an excellent reputation.
11:20:37 <guest223> ok.
11:20:54 <guest223> i will try all of them and stick to one i like
11:20:56 <quchen> Some people also find the way of writing in LYAH annoying. (I love it.)
11:21:22 <ReinH> quchen: hello
11:21:27 <quchen> ReinH: Hello
11:23:57 <wrengr> Unhammer: fwiw, the rewrite is still in progress (hence not pushed to hackage yet). so no guarantees :)
11:33:00 <Soullesswaffle> Hi all! I'm working on decoding a binary file format using Data.Binary.Get and I've stumbled on a problem. In the file there is a location table containing the absolute offsets (from the beginning of the file) that you can go to to read further data. I would like to read all of the data into a custom data structure, but it looks like Get doesn't support seeking backwards.
11:33:35 <Soullesswaffle> This means (if I continue to use Get) I will have to read the data in a specific order according to the offsets in the location table
11:35:12 <Soullesswaffle> Building parser functions for these pieces of data is fairly straightforward, but I'm not sure how to go about calling them in a specific order that is only known at runtime, while still ending up with a completely filled out data structure
11:36:36 <lyxia> Soullesswaffle: indeed Get is not good for that.
11:37:27 <lyxia> Soullesswaffle: can't you somehow compute the order in which each section appears?
11:38:11 <max3> how is it possible that i can compile with ghc without warnings/errors but i get warnings involving pragmas with trying to ghci?
11:38:22 <max3> errors not warnings even
11:38:24 <_sras_> Using stack, how can I load the test target in ghci so that I can run the functions in the test package from ghci. I also want the stuff from my main app to be available in the test package. Does this mean I have to expose all the modules I want to test, from my main app?
11:38:34 <max3> stuff like use FlexibleInstances, MultiParamTypeClasses
11:43:42 <ReinH> Soullesswaffle: you may need to resort to take/drop into a strict bytestring, which at least is O(1).
11:45:46 <ReinH> and is the intended way to slice a bytestring according to dons.
11:46:41 <ReinH> you could also mmap
11:47:03 <sm> _sras_, try stack ghci PKG:test:TESTSUITE
11:47:11 <ReinH> you can mmap directly into a strict bytestring or storable Vector of Word8.
11:48:09 <ReinH> so you can read in the location table and then directly mmap the areas of the file.
11:48:40 <sm> _sras_: and yes, if you separate your test code from app code I think you'll need to export the testable bits somewhat)
11:48:51 <Soullesswaffle> ReinH: That sounds interesting
11:48:54 <ReinH> it depends on whether it's cheaper to read the whole file and then slice it up (with take/drop, which shares the underlying data) or mmap each individual section.
11:49:18 <ReinH> If the data is denser in the file, probably the former. If it's sparser, probably the latter.
11:49:44 <ReinH> anyway, you can't do it with binary but you do have two good choices.
11:50:43 <Soullesswaffle> ReinH: would it be possible to parse the header + fileLocationTable with Get and then switch to either of those solutions for the rest of the file?
11:52:08 <ReinH> Sure. Maybe not within a single Get action.
11:52:50 <ReinH> But no one says you have to use a single Get action to create your data type.
11:53:04 <ReinH> s/data type/value
11:53:22 <sm> _sras_: an alternative is to use doctest
11:53:38 <_sras_> sm: What is the suggested way to structure this so that there is minimum friction to write and run tests?
11:54:26 <Soullesswaffle> ReinH: Oh, this could get interesting. I guess if I parse the location table on the first pass, I could just use a new Get for each of the groups of data by skipping straight to their offsets, right?
11:54:28 <_sras_> sm: The tests I want to run is messy, have to talk to an api, database and read from files.
11:54:42 <_sras_> sm: By api I mean http api.
11:54:44 <ReinH> Soullesswaffle: maybe you write data Foo = Foo { header :: Header, LocationTable :: LocationTable, whateverElse :: whateverElse }
11:55:09 <sm> there's no quicker way to write tests than with doctest. They can use IO etc. But they run slower than other kinds of test
11:55:19 <ReinH> er, locationTable :: LocationTable
11:55:48 <sm> and they don't integrate well with other kinds of test
11:56:35 <sm> you could hunit tests (eg) right in your modules near the app code; there's some benefit to that
11:56:40 <sm> you could put
11:57:05 <ReinH> Soullesswaffle:  then let { header = runGet getHeader bytes; lt = runGet getLT bytes; } in Foo header lt (runGet getWhateverElse (drop (whateverOffset lt) bytes))
11:57:14 <sm> but most people put them under test/, and import the app code
11:58:24 <sm> personally I'd start with doctest and move to something more complicated when test running time becomes an issue
11:59:10 <ReinH> Soullesswaffle: This is basically how I parsed ROMs for an emulator I wrote. The header told me where the memory section started and I just sliced the bytestring up.
12:00:26 <Soullesswaffle> nice!
12:00:31 <ggVGc> why test? isn't that what the compiler is for?
12:00:35 <ReinH> It turned out that forcing the bytestring and coercing it into a Storable.Vector Word8 was better, but that's neither here not there.
12:16:00 <freeman42> how could someone turn into a list data read inside a replicateM? see: http://lpaste.net/356500
12:21:12 <freeman42> ah, so simple: 'inputs <- replicateM 8 getLine'
12:23:05 <pavonia> freeman42: Note that read completely crashes your program if it doesn't receive an Int, better use e.g. readMaybe
12:24:40 <freeman42> pavonia, that is good advice other kinds of programs, this one is guaranteed to not fail by the gods of whoever wrote that code :)
12:36:13 --- mode: moon.freenode.net set +o ChanServ
12:37:54 <bollu> can two modules in the same project define the same datatype?
12:38:07 <bollu> module A: data Foo = ...; module B: data Foo = ...
12:38:18 <geekosaur> yes
12:38:26 <geekosaur> to use them with both imported, you need to qualify them
12:38:53 <Shockk> hello, I have a quick attoparsec question
12:39:07 <kebertx[m]> That should be okay, but you'll have to use qualified imports
12:39:27 <Shockk> is there an equivalent function to `inClass` for attoparsec that doesn't parse range notation?
12:39:36 <geekosaur> kebertx[m], actually you dn't, if you import normally then using it unqualified is an error but qualifying by module works
12:39:51 <Shockk> for example I would like something like "a-n" to match 'a', '-', and 'n', not all the characters from a to n
12:40:47 <bollu> weird
12:41:23 <geekosaur> Shockk, "To add a literal '-' to a set, place it at the beginning or end of the string."
12:41:59 <Shockk> geekosaur: I see that, I would assume that calling that function is less efficient than calling one that doesn't parse range notation, though
12:42:35 <koala_man> Parsec has oneOf. Don't know about attoparsec
12:43:15 <Shockk> hmm actually I could just use bytestring's `elem` 
12:43:22 <teurastaja> hey im not a fluent haskeller, but im implementing binary SK combinator calculus in assembly language. im wondering what is considered a valid subsequence in a valid sequence
12:43:42 <Shockk> or I don't know, something like that
12:43:56 <teurastaja> K = 00, S = 01, application = 1
12:45:14 <mauke> expression := '00' | '01' | '1' expression expression
12:45:34 <teurastaja> say you have 11010000, wouldnt it mean ((S K) K) ?
12:45:51 <mauke> yes
12:45:53 <lingxiao> hey anyone here familiar with swift?
12:46:11 <teurastaja> wikipedia says 10000 is not a valid subsequence
12:46:35 <teurastaja> but the 1 is the 1 of 01 right?
12:48:10 <geekosaur> that's why it's not a valid subsequence, it's splitting up a valid subsequence in the middle
12:48:12 <geekosaur> 1(1(01)(00))(00)
12:48:29 <teurastaja> oh...
12:49:25 <teurastaja> do i need to make a special case for SKK = \x -> x or is SK sufficient?
12:50:38 <teurastaja> also, is it feasable to compile the iota combinator without S, K or lambda?
12:52:16 <The_Kinaesthetic> Hi
12:53:36 <The_Kinaesthetic> I have a pretty simple question. I installed a library but I'm not sure how to use it, how exactly do I figure out what it contains, or access the documentation if it's available? The library is "synthesizer-core", available on hackage.
12:54:10 <mauke> http://hackage.haskell.org/package/synthesizer-core#modules
12:54:41 <lyxia> the docs might be painful to read due to the author's naming convention though.
12:55:14 <The_Kinaesthetic> yeah I was checking through whats there but can't make too much sense out of it
12:55:29 <mauke> http://hackage.haskell.org/package/synthesizer-core-0.8.1/docs/Synthesizer-Plain-Tutorial.html
12:55:51 <The_Kinaesthetic> How'd you get to that?
12:56:14 <The_Kinaesthetic> nvm
12:56:38 <The_Kinaesthetic> How would I figure things out for something like this
12:56:38 <EvanR> teurastaja: theres only 2 patterns to look for
12:56:38 <The_Kinaesthetic> https://hackage.haskell.org/package/synthesizer-dimensional
12:56:43 <ibrahims> hello, i'm trying to use linear package but keep needing a `Point V2 Double -> V2 Double` for dot product between a point and a vector or creating a direction vector between two points. any advice? i feel like i'm missing something.
12:56:49 <teurastaja> EvanR: my saviour!
12:57:02 <mauke> The_Kinaesthetic: I read the first paragraph of http://hackage.haskell.org/package/synthesizer-core, then clicked on the link below
12:57:33 <teurastaja> EvanR: is it possible to compile iota combinator without first compiling SK or lambda?
12:57:39 <The_Kinaesthetic> mauke: Yeah I realized that seconds after lol
12:58:18 <EvanR> oh iota
12:59:05 <EvanR> the point of these combinators is that you dont have lambdas
12:59:38 <EvanR> you just need to figure out how to reduce combinations of them, or stop because you cant reduce anymore
13:00:16 <mauke> what's iota?
13:00:42 <bollu> can I define a typeclass in multiple files?
13:01:03 <EvanR> iota f = f S K
13:01:07 <bollu> define a typeclass in multiple modules in the same projet?
13:01:39 <EvanR> where S = iota (iota (iota (iota iota))
13:01:50 <EvanR> K = iota (iota (iota iota))
13:02:01 <teurastaja> can you compile iota without SK though?
13:02:08 <teurastaja> if yes, how?
13:02:12 <EvanR> S and K are defined like that
13:02:34 <mauke> that seems slightly recursive
13:02:42 <bollu> what's f?
13:02:46 <bollu> ah, any 
13:02:49 <bollu> any f*
13:03:06 <EvanR> the y in Apply x y where x is iota
13:03:32 <EvanR> iota is a constant, but the first equation is a reduction rule
13:04:02 <teurastaja> i guess i just need to separate the tail-recursive (iota iota) from (iota (iota ...)) ?
13:04:06 <EvanR> the real structure here is that of a balanced parenthetical expression
13:04:51 <teurastaja> EvanR: what equation?
13:05:02 <EvanR> iota f --> f S K
13:05:06 <mauke> S (S (S K K) (K S)) (K K)
13:05:55 <teurastaja> EvanR: but S and K are in it...
13:06:10 <EvanR> thats a definitional abbreviation for a tree of iotas
13:06:29 <EvanR> not S K calculus
13:07:00 <teurastaja> EvanR: can you be more clear?
13:07:03 <mauke> how does that ever reduce anything?
13:07:08 <mauke> doesn't it just keep growing?
13:07:28 <EvanR> i guess you need to do eager evaluation
13:07:58 <teurastaja> EvanR: can you show me an iota compiler which doesnt use either S, K or lambda?
13:08:24 <mauke> or just a sample reduction
13:08:25 <EvanR> before you can compile anything you need to be able to evaluate it at all
13:09:04 <teurastaja> say i read 1110. how do you interpret it?
13:09:42 <teurastaja> i know you can just say it equals S, but thats cheating
13:09:44 <EvanR> that must be a different language, since youre not using parenthesis
13:10:09 <EvanR> do you have a reference to the language
13:10:22 <teurastaja> EvanR: im building it...
13:10:49 <EvanR> ok so how does binary map to the parentheses tree
13:10:53 <teurastaja> all I have is an assembly translation of the SK reduction you gave me yesterday
13:11:24 <teurastaja> EvanR: just trying to extract S and K from iota
13:11:37 <EvanR> uh uh...
13:12:09 <EvanR> the definition of S and K in terms of iota are on wikipedia, supposedly, i pasted them above
13:12:10 <teurastaja> so theres never a cawse where i actually need parens is there?
13:12:26 <EvanR> they definitely use parentheses
13:12:50 <EvanR> an expression is a tree, the nodes are "app" nodes
13:13:15 <EvanR> x y x = (x y) z is different from x (y z)
13:13:47 <EvanR> in haskell, data E = Iota | App E E
13:13:47 <Unhammer> wrengr,  looking forward to it :)
13:15:03 <EvanR> ah i see the binary on here for that
13:15:45 <EvanR> 1=Iota, 0<x><y> = App x y
13:16:40 <EvanR> 1110 doesnt make any sense in this case
13:19:09 <EvanR> since reduction will replace a part of the tree in the middle, literally using a string of bits in assembly seems kind of annoying
13:19:49 <teurastaja> EvanR: pattern matching in assembly is horrendous
13:20:18 <teurastaja> but since SK calculus is so simple, its a feasible task
13:21:53 <The_Kinaesthetic> Ok. I'm quite new to haskell but I've decided that I'm never going to learn anything unless I give myself a goal, which is the whole point of learning it in the first place. That goal is to create at least at first a text parser that coverts into sound through time. 
13:22:03 <NemesisD> i've got a computation that can be resumed over multiple runs. i've got something like data Step = One | Two | Three. any suggestions for how to implement this? I suspect maybe ContT could work but i'm not sure
13:22:44 <The_Kinaesthetic> I was thinking I would need to choose now and become comfortable with whatever package actually generates the sound, but could I possibly write my implementation first and then be able to choose the sound interface so to speak later. 
13:23:22 <XorSwap> The_Kinaesthetic: like text to speech?
13:23:47 <The_Kinaesthetic> No like notation to music
13:24:10 <XorSwap> ah
13:24:14 <The_Kinaesthetic> I have a specific rhythm notation in particular that probably no one in the world uses except me and it's creator
13:24:20 <The_Kinaesthetic> and it makes writing music so much easier
13:24:44 <XorSwap> if you really wanted to go simple, you could just output binary pcm directly
13:24:54 <The_Kinaesthetic> I just want to implement it with text and have it be processed into actual sound (in the distant future I would like to make a gui)
13:25:23 <The_Kinaesthetic> XorSwap: do what now?
13:25:50 <XorSwap> like, just output bytes directly and pipe them into a program like aplay
13:26:01 <XorSwap> don't have your program actually talk to the speakers
13:26:28 <The_Kinaesthetic> hmm
13:26:29 <EvanR> teurastaja: having a hard time getting source material on iota... do you have any
13:26:35 <The_Kinaesthetic> is aplay just a audio file program?
13:26:41 <The_Kinaesthetic> is aplay just an audio file program?
13:26:47 <EvanR> https://esolangs.org/wiki/Iota this page doesnt really explain the role of s and k
13:27:10 <XorSwap> it basically just plays binary data as audio on stdin
13:27:18 <EvanR> portaudio bindings also exist
13:27:21 <EvanR> also SDL
13:27:31 <The_Kinaesthetic> Well there's a slight problem in that I would first have to make the data lol
13:27:42 <The_Kinaesthetic> That's why I would use synthesizer or csound-expression
13:27:44 <EvanR> there are csound binings to general sound, among others
13:28:33 <The_Kinaesthetic> I know how to use csound-expression at a basic level
13:28:52 <The_Kinaesthetic> so in theory I could make my code now and have it output to a csound-expression which then outputs either real time audio or a file
13:29:10 <The_Kinaesthetic> but I didn't know if I should focus on getting closer to the core or whatever
13:29:19 <The_Kinaesthetic> since that's what I presume synthesizer-core is
13:30:00 <The_Kinaesthetic> Honestly I'm so well aware of sound and how it works
13:30:00 <XorSwap> I'd say start by figuring out the data structure you want to parse into
13:30:21 <The_Kinaesthetic> that If I learned it's data implementation I could actually do as XorSwap said and just make a data file 
13:30:34 <The_Kinaesthetic> But it would be more work
13:30:42 <The_Kinaesthetic> I think...
13:32:00 <The_Kinaesthetic> Yeah I don't know what to do
13:32:04 <The_Kinaesthetic> I'm too new to all this stuff
13:33:52 <The_Kinaesthetic> I guess I'll just start with csound-expression, and then later if I realize I made the horrible decision to do that and should have done something else differently I'll just say to myself "ok that was a learning experience" and move on.
13:35:23 <EvanR> ok the semantics seem to be given literally in terms of SK combinators
13:35:37 <The_Kinaesthetic> Thanks y'all
13:35:41 <XorSwap> np
13:36:04 <The_Kinaesthetic> I need to get an irc client and come in here more often. Y'all are much friendlier than other irc experiences I've had.
13:37:16 <EvanR> haha
13:41:48 <shapr> Makes me wonder what network/channel is giving IRC a bad name.
13:42:23 <shapr> Mind you, my experiences with random people on the internet are often negative.
13:43:40 <EvanR> i can name a dozen freenode channels but wont
13:44:08 <EvanR> and freenode is one of the better networks :)
13:44:29 <bitemyapp> shapr: ##C is bad here too
13:44:40 <bitemyapp> shapr: but in general EFnet was a mess.
13:44:46 <bitemyapp> Rizon is pretty bad too.
13:45:13 <EvanR> oh well
13:45:20 <bitemyapp> Most of the OG Freenode users were EFnet refugees
13:45:33 <bitemyapp> the ##C channel there is somehow worse than the one we have here
13:46:35 <XorSwap> where could I find the implementation of prelude?
13:47:00 <bitemyapp> XorSwap: https://www.stackage.org/lts-8.20/package/base-4.9.1.0
13:47:30 <shapr> I joined freenode soon after it started, because #python on EFNet was .. intolerable
13:48:12 <Unhammer> XorSwap: you can typically click "source" from documentation to see implementations of individual functions
13:48:15 <shapr> When I joined EFNet#python I was the 12th user
13:49:03 <shapr> #python on freenode was good for awhile, we avoided the paradox of tolerance.
13:49:16 <shapr> then I got told I was being too mean, and the channel went downhill
13:49:33 <EvanR> you are pretty mean shapr 
13:49:39 <shapr> Yeah, I'm okay with that.
13:49:42 <EvanR> haha
13:49:53 <shapr> I'm intolerant towards people who pollute a community.
13:50:07 <shapr> If I have ops in that community, I warn/remove people.
13:50:10 <shapr> If I don't, I leave.
13:50:32 <shapr> Also, turns out the online gaming community 
13:50:42 <shapr>  has some extremely toxic people
13:51:11 <fnurglewitz> shapr, moba communities especially
13:51:33 <shapr> I like to think there are some online multiplayer games that don't have immature racist people attempting to offend everyone, but I'm not convinced of that.
13:52:00 <fnurglewitz> in the late 90s it was a bit different
13:52:17 <shapr> fnurglewitz: yeah, I love playing Team Fortress 2, but I cannot tolerate the players.
13:52:26 <fnurglewitz> well, try dota :)
13:52:34 <shapr> Dota is worse.
13:52:35 <fnurglewitz> try being a newbie in dota :D
13:52:39 <shapr> I tried that!
13:52:45 <shapr> Most toxic community ever!
13:52:58 <rtypo> maybe chess :p
13:53:06 <shapr> fnurglewitz: Tribes 2 had an excellent community for several years.
13:53:09 <Rembane> Go is quite alright
13:53:24 <rtypo> shapr: great game
13:53:30 <fnurglewitz> shapr, Ultima Online too
13:53:48 <fnurglewitz> even the lamers/troll were better :D
13:54:33 <EvanR> i made a backup of the html page that iota seems to be based on, almost lost to time: http://evanr.info/iota/
13:54:40 <shapr> I think the more work a subject requires, the fewer toxic people. But I could be wrong.
13:54:42 <docmoxie> I'm working on getting a package ready to upload to Hackage. It's a tool that allows you to write configs for AWS CloudFormation deploys and then run those configs using Amazonka. I notice Amazonka lives in Network.AWS...is that the best spot for what I'm describing as well?
13:55:31 <EvanR> shapr: you have to really care about something to be there
13:55:38 <EvanR> haskell is not for the faint of heart
13:55:41 <docmoxie> I ask because the package candidate feature yells at me for having "Exposed modules use unallocated top-level names"
13:56:29 <shapr> EvanR: and unlike Java and friends, it's not something with a pile of commercial/educational push.
13:56:43 <XorSwap> huh, ok I was trying to look up exactly how error works, and I got to 'raise#' in here https://www.stackage.org/haddock/lts-8.20/ghc-prim-0.5.0.0/src/GHC-Prim.html
13:56:50 <XorSwap> raise# = raise#
13:56:54 <shapr> "avoid success at all costs" - won't last much longer.
13:56:58 <XorSwap> what exactly is going on there?
13:57:00 <fnurglewitz> shapr, I think it's just a matter of "numbers"
13:57:14 <fnurglewitz> there are so many java devs that many will be assholes
13:57:35 <dmwit> XorSwap: GHC primitives are implemented in the RTS, and given a dummy implementation in a special way that lets them have Haddock documentation.
13:57:49 <shapr> I believe that, but Haskell seems to be a good filter so far. Maybe because it requires patience? or maybe our community really is that small.
13:57:58 <fnurglewitz> the community is small
13:58:07 <fnurglewitz> and "lucky" too
13:58:14 <fnurglewitz> because it really a great community
13:58:21 <fnurglewitz> there's really great people here
13:58:27 <XorSwap> shapr: still though, '1 ops, 1580 total' is pretty big for a 'nice' community
13:58:41 <fnurglewitz> I think it's related to the fact that the "gurus" here are always there for everyone
13:58:49 <shapr> fnurglewitz: that's a good point
13:59:04 <shapr> XorSwap: bad actors don't last long here, that helps
13:59:11 <shapr> And we have a pile of ops with quick reflexes.
13:59:11 <fnurglewitz> if you start out, ask "noob" questions and people treat you well anyway
13:59:21 <docmoxie> alternatively: does anyone suggest a better place to ask my question? Or is it just not that big a deal which top-level name you use?
13:59:21 <shapr> I think because we've all been there.
13:59:41 <shapr> docmoxie: Perhaps on the haskell-cafe mailing list? I don't know. Or you could just go for it and see :-)
13:59:54 <fnurglewitz> well, let's stop the OT :)
13:59:59 <fnurglewitz> since there are serious questions :P
14:00:07 <docmoxie> ok, I'll just go for it. thanks :)
14:02:58 <EvanR> i think its interesting on the unlambda page, the section of "compiling", it says "im not sure if its possible to compile unlambda, you can compile SK calculus, but we have promises"
14:03:06 <EvanR> which sounds like haskell thunks
14:03:17 <EvanR> they even mention haskell on the page! come on!
14:08:10 <EvanR> and the lazy K page says that interactive programs are a sin because input and output would have to be synchronized, and mentions haskell as a possible way to do it, but they dont refer to the right thing
14:08:45 <EvanR> you could evaluate to the church encoded equivalent of Get k, or Put c f
14:09:16 <EvanR> i dont know if this counts as synchronized
14:10:22 <lmapper> I'm looking for a function... is there something like traverseIO that would do this?
14:10:25 <lmapper> (String -> Maybe a) -> [String] -> Maybe [IO a]
14:10:32 <AWizzArd> Is there a compiler option that forces ghc to compile a program even in the presence of type errors?
14:11:02 <EvanR> yes
14:11:32 <EvanR> -fdefer-type-errors 
14:12:34 <EvanR> and its totally safe by the power of glasgowskull
14:13:20 <EvanR> https://ghc.haskell.org/trac/ghc/wiki/DeferErrorsToRuntime
14:13:37 <AWizzArd> EvanR: thx
14:26:56 <shapr> lmapper: have you tried hoogle?
14:27:09 <shapr> cause I don't know
14:28:00 <lmapper> I tried hoogle first
14:28:14 <lmapper> I'm trying to write my own traverseIO now
14:29:58 <silentcuboid> beginner in programming, doing E Meijer course on edX, following along in groovysh. How do you make the repl(?) stay at the bottom of window after doin a "run"
14:30:41 <EvanR> does that course have anything to do with haskell?
14:30:50 <silentcuboid> its in haskell
14:31:06 <EvanR> whats groovysh
14:31:30 <silentcuboid> intro to functional programming (using haskell) based on Hutton book
14:31:43 <Rembane> silentcuboid: Are you using Linux? Windows? MacOSX?
14:31:48 <silentcuboid> win
14:32:18 <Rembane> Are you using Cygwin? cmd.exe? Powershell? bash?
14:32:22 <silentcuboid> cmd
14:32:39 <silentcuboid> but launched console
14:32:43 <silentcuboid> grooveConsole
14:32:53 <silentcuboid> groovyConsole
14:32:59 <nisstyre> when I google groovysh I get stuff related to the Groovy programming language
14:33:05 <nisstyre> is that the same thing?
14:33:14 <silentcuboid> https://courses.edx.org/courses/course-v1:DelftX+FP101x+3T2015/courseware/79633017711e44c9878df4f337014766/ea7afa9c5b924b96b05951cbcff001b2/?child=first
14:33:52 <nisstyre> can't see that without logging in
14:33:56 <silentcuboid> oh sry
14:35:12 <silentcuboid> new to all of this. Maybe i should locate some more groovy-specific forums
14:35:38 <nisstyre> I'm just a bit confused about whether you're doing Haskell or not
14:35:49 <nisstyre> maybe it covers both
14:36:53 <silentcuboid> one momen
14:36:53 <silentcuboid> t
14:37:48 <silentcuboid> maybe they just switched lang for a while in a sneaky way
14:38:07 <silentcuboid> n am to fresh to notice :)
14:38:30 <silentcuboid> its probably that :)
14:39:17 <silentcuboid> "Unlike Haskell which mandates that every element in a list has the same type, Groovy..." haha
14:39:25 <silentcuboid> sry to bother
14:39:58 <EvanR> yep, sounds like groovy!
14:40:08 <EvanR> theres probably a groovy channel on freenode
14:40:11 <silentcuboid> ty
14:40:35 <EvanR> i recommend using haskell instead :)
14:41:42 <silentcuboid> thats the plan, but ill follow along the course until i get a clue
14:42:15 <silentcuboid> little bit curious about Idris without knowing much at all about programming :) just gutfeel
14:42:34 <silentcuboid> but the tuts on that presupposes Haskell, so here I go
14:44:15 <EvanR> idris is pretty far out
14:44:49 <nisstyre> you probably don't want to spend too much time thinking about Idris until you've spent some time learning Haskell or maybe SML
14:44:50 <max3> how is it possible that i can compile with ghc without warnings/errors but i get warnings involving pragmas with trying to ghci?
14:44:52 <max3> errors not warnings even
14:44:54 <max3> stuff like use FlexibleInstances, MultiParamTypeClasses
14:44:55 <EvanR> i didnt really get advanced haskell shenanigans until doing a lot of idris
14:45:26 <mud> max3: Same GHC version?
14:45:45 <max3> how could it be that they're diff versions
14:45:51 <max3> but i should check
14:46:55 <max3> mud, yes
14:47:24 <silentcuboid> thanks for remainder to keep my feet on the ground :)
14:47:52 <mud> max3: What are you doing in GHCi? ':load'ing it?
14:47:55 <max3> yes
14:48:42 <mud> Hm. Are there extensions enabled via pragmas in the file or elsewhere? I'm not really sure in what cases that would happen honestly.
14:48:59 <nisstyre> what about your .ghci file
14:49:11 <nisstyre> you can enable extensions there
14:49:31 <max3> nisstyre, but those would be for ghci not ghc right?
14:49:43 <max3> or am i misinterpreting .ghci
14:49:45 <nisstyre> oh that would be the opposite yes
14:50:17 <max3> indeed that is the case
14:50:19 <nisstyre> are you using a .cabal file?
14:50:24 <max3> there are extensions enabled in ghci
14:50:26 <lmapper> alright, I've reduced it down to:  [Maybe (IO a)] -> Maybe [IO a]
14:50:41 <max3> :set -XMultiParamTypeClasses -XFlexibleContexts -XFlexibleInstances -XScopedTypeVariables -XConstraintKinds
14:50:47 <max3> in .ghci i mean
14:50:51 <c_wraith> lmapper, that's just sequence
14:51:13 <max3> so in order to set those extensions "globally" in ghci i just "run" that command right?
14:51:23 <nisstyre> for that repl session
14:51:35 <nisstyre> .ghci gets executed each time you open the repl
14:51:48 <max3> thank you very much
14:51:48 <lmapper> c_wraith, ah, brilliant, thanks
14:52:13 <ibrahims> hello people, i'm looking into https://hackage.haskell.org/package/gjk which says it is a port from https://github.com/zaidan/elm-collision. in the readme of elm package it says `data Mink a = (a, a -> Pt -> Maybe Pt)` which makes no sense to me. if you're going to abstract over the first element of the tuple, i was wondering why bother with that and not expect a closure like `Pt -> Pt` which can be 
14:52:19 <ibrahims> constructed as `support a` instead of `(a, support)`. is there any reason for it? maybe the strictness plays a role? do you think it's alright if i do it the second way in haskell?
14:52:24 <max3> another question: template haskell is run at compile time right?
14:52:58 <nisstyre> yeah
14:53:08 <nisstyre> it gets expanded at compile time
14:54:22 <teurastaja> can you give me a definition for call-with-current-continuation using SK only?
14:54:41 <ibrahims> sorry to barge in like this. any comment is appreciated. i need to get a bit more from the algorithm and i was trying to simplify the code a bit.
14:56:22 <max3> how do i see what the th gets expanded into? i remember doing it a while ago by passing some flags to ghc 
14:58:25 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#viewing-template-haskell-generated-code -ddump-splices or -dth-dec-file (the latter top level only)
14:59:39 <max3> thank you
15:02:18 <docmoxie> @ibrahims im not sure if I totally follow your question, but the comment line 176 of that elm src seems to address it?
15:02:18 <lambdabot> Unknown command, try @list
15:03:01 <NemesisD> does *allowing* a newer version of a dependency require an A or B version bump in A.B.C or just a C bump?
15:03:11 <docmoxie> ibrahims im not sure if I totally follow your question, but the comment line 176 of that elm src seems to address it?
15:03:24 <docmoxie> *comment starting on line...
15:06:04 <monochrom> NemesisD: That depends on why you allow a newer version, no? But C bumps are backward compatible, A.B bumps are usually not (maybe always not, IANAL).
15:06:44 <NemesisD> monochrom: that dependency has a breaking change but it doesn't affect the library in question, just want to permit its use
15:06:45 <monochrom> There is also a D bump which just means bug fixes or performance improvements etc.
15:08:29 <monochrom> Well that happens all the time. base keeps moving but many people survive with base >= 3 && < 5.
15:08:41 <ibrahims> docmoxie: i don't think so but i might be missing something. does it explain the use of `(a, a -> b)` instead of `b` which seems like totally isomorphic with `\(a,b) -> b a` while `a` is parametric?
15:08:54 <monochrom> Some of them survive by conditional compilation, but boy do they survive.
15:09:41 <monochrom> So asserting "base >= 3 && < 5" is fine on the ground that you actually know all the cases.
15:09:44 <NemesisD> monochrom: the PVP docs say "depending on a newer version of another package may cause extra orphan instances to be exported and thus force a major version change.", but i'm not sure if "depending on" is distinct from "allowing"
15:09:51 <docmoxie> ibrahims yeah, I don't see a reason why you couldn't go with just `b`, but I'm a newbie
15:10:50 <ibrahims> docmoxie: thanks for looking into it though.
15:12:03 <monochrom> Do you actually get extra orphan instances?
15:12:06 <docmoxie> anyone familiar with using `stack script`? I just uploaded a package to Hackage, and Stackage has consumed it, but I assume it won't be available in an LTS release for however long that takes, so until then, I'd love to tell my script-interpreted file to just grab my library from github (or local, if I have to). anybody know if that's possible?
15:12:12 <docmoxie> ibrahims no worries
15:13:21 <docmoxie> the Stack user guide doesn't say anything about getting dependencies from elsewhere when using `stack script`...
15:14:08 <monochrom> I am sure that programmers are poor writers and they can't tell the difference between "X may cause Y and therefore Z" and "when you're doing X, if Y then Z".
15:15:06 <sm> docmoxie: I don't think that (specifying a github repo in the command line, or a stack script) possible yet. Best you can do is reference a nightly snapshot
15:15:34 <docmoxie> sm so I do have to wait until tomorrow to try this out. bummer. thanks though!
15:17:25 <sm> docmoxie: if you have the lib installed locally, it'll be usable even though not specified explicitly
15:19:28 <sm> so if you really had to I guess you could run a pre script that git clones and stack installs your package, then run the stack script to install the rest
15:20:27 <pikajude> hey, who was recommending the mvc package to me yesterday
15:20:55 <pikajude> i want to be able to send messages at arbitrary times. if I create a Controller out of a Chan with asPipe (forever $ liftIO (readChan ch) >>= yield), is that an antipattern?
15:21:08 <pikajude> i just wonder if there's a more mvc-y way to do it
15:21:45 <geekosaur> 2017 Jun 25 20:33:16 <cocreature>	pikajude: https://hackage.haskell.org/package/mvc-1.1.4/docs/MVC.html
15:22:30 <pikajude> nice
15:22:56 <docmoxie> sm the only way I've been able to get it to work is copying the haskell "script" into a subfolder of said dependency (the one I'm waiting on Stackage to pick up). Which is fine for now, since I'm just testing it...but it's kind of lame.
15:33:23 <glguy> ibrahims: What are you trying to figure out with (a, a->b) ?
15:53:26 <jle`> ibrahims: (a, a -> b) isn't isomorphic to b for a spcific 'a'
15:53:39 <jle`> so (Int, Int -> Double) isn't the same as Double
15:59:45 <EvanR> whats this the store comonad
16:00:25 <arctictern> has anyone managed to successfully create Dash documentation for a stack project, using either dash-haskell or haddocset?
16:06:27 <davr0s> can haskell use compile-time values in it's types, e.g. like C++  template<typename T,int N>  ... at the minute i'm doing anything like that with a bit of cut-paste for variations of things with 0,1,2,3,4 items
16:07:14 <davr0s> 'a 4x3 matrix' is a Matrix4<Vec3<T>>   .. rather than 'a Matrix<4,3,T>'
16:07:34 <EvanR> yep
16:07:50 <EvanR> GHC even lets you use numeric literals there
16:08:15 <EvanR> since we dont have dependent types (yet), 3 and 4 are types though, not values
16:10:59 <davr0s> the next case i enountered was 'a generic vertex type', e.g.    Vertex<position_dimensins, number of tex-coords, texcoord dimension, .. > plugging in 1 or 0 to select a certain vertex attribute
16:11:17 <davr0s> i thnk C++ handles this sort of thing quite well
16:11:37 <davr0s> but 'dependant types' would take it further?
16:11:44 <max3> can someone explain to me what the apostrophe here on the last line is doing?
16:11:46 <max3> 'makeFormat?
16:11:50 <EvanR> i dont see C++ anymore, only dependent types
16:11:53 <max3> https://github.com/databrary/databrary/blob/1e2a94ac93aa6548db418d9dea5edf2b088a9609/Databrary/Model/Format/SQL.hs#L18
16:12:21 <davr0s> EvanR what do you mean by that, you see 'dependent typed languages taking over' ?
16:12:29 <EvanR> probably not
16:12:33 <EvanR> humanity isnt ready
16:13:59 <davr0s> i see in Rust they also dont have C++ style 'plug int's into types' , but they mention 'pi types' and say that will take it further
16:14:00 <EvanR> you can define a family of types to express the various ways to format a swath of bytes which will be sent to GL
16:14:33 <pacak> max3: It's part of TemplateHaskell syntax.
16:14:43 <geekosaur> max3, it's "quoting" the name for Template Haskell
16:14:57 <geekosaur> (think like the way Lisp uses ')
16:15:01 <EvanR> there may be some work on this already, hylogen, GPipe, ...
16:16:05 <davr0s> my plan up until 1 min ago was just make a fixed set of common vertex types,   then manually roll a tagged-union for those ('VertexArrayPC [VertexC] | VertexArrayNT2 [VertexNT2]..  
16:16:23 <EvanR> that might be the more expedient way to do it
16:16:57 <davr0s> i can see it will certainly work.. the set of actually used vertex types will be small
16:17:08 <EvanR> but its not as efficient as using a blob of bytes and having the phantom types keep it straight
16:17:45 <EvanR> yes, "pi" is a real brain exploder
16:17:54 <EvanR> capital pi
16:18:06 <EvanR> also capital sigma
16:33:01 <jared-w> My hope is that 30 years from now, people will look at C and C++ the same way they look at people programming "mary had a little lamb" in binary with switches, or computers using punch cards :p
16:33:54 <EvanR> they will evolve to a "next stage" and survive
16:34:05 <EvanR> like they already have kind of
16:34:13 <davr0s> C++ has evolved quite a bit
16:34:42 <EvanR> C has lost some of its vestigial appendages
16:34:57 <davr0s> its going to get the 'concepts' .. and i'm sure it will eventually get tagged-unions
16:35:18 <EvanR> it already has tagged unions
16:35:29 <EvanR> literally struct { int tag; union....
16:35:40 <davr0s> well yes but i mean a more elegant way of doing it
16:35:58 <davr0s> where the tag and variants are explicitely connected and the langauge knows that connection
16:36:00 <jared-w> elegant and C++ don't really go together super well
16:36:12 <EvanR> that would be interesting
16:36:39 <EvanR> just jump straight to sigma types, which subsume tagged unions
16:36:46 <jared-w> I'm still really excited to see where Rust goes
16:37:23 <davr0s> i'm bouncing between c++, rust ,and now dipping my toes back into haskell, and am still undecided on some things.
16:37:25 <EvanR> C already has dependent types int foo[3] haha
16:37:37 <jared-w> I'm of the opinion that assembly is already a giant lie. C/C++ is even more of a lie. We need to get rid of the notion that a line of C translates directly to a line of assembly and translates directly to machine code. It's far too simplistic for what things already do
16:37:45 <Shockk> hopefully my lang will have dependent types in it
16:38:13 <exio4> davr0s: I wouldn't be surprised if a nicer or simpler version of boost::variant gets into the STL 
16:38:15 <davr0s> jared you're alluding to the inner complexity of modern processors, right?
16:38:40 <jared-w> Yes, absolutely. Processors have massive out of order processing, black magic optimizations, etc., out the wazoo
16:38:46 <monochrom> Tagged unions are more thorny in imperative languages because after a successful pattern matching, you are free to mutate the tag, so now what's the semantics of the rest of your code where you still access the fields that were only valid under the old tag?
16:38:50 <davr0s> what C and C++ really need is a propper immutable idea
16:39:01 <davr0s> we've got the restrict hack
16:39:03 <kadoban> monochrom: UB
16:39:24 <monochrom> I mean this kind of questions all have reasonable answers, and you probably already perceive your answers now, but people will disagree, it will be a mess.
16:39:31 <jared-w> Low level languages merely provide tons of information to the compiler about /how/ to do something. What we need is a language that provides tons of information to the compiler about exactly what is allowed to happen and be optimized
16:39:58 <EvanR> and the compiler will take a week to work 
16:40:09 <davr0s> i still think a layering approach is valid
16:40:41 <davr0s> asm <- LLVM,or C  <-  (something high level)
16:40:56 <jared-w> I mean, that's what we do now, is it not?
16:41:18 <EvanR> " a lie" is not really appropriate. because all our languages are abstract formal languages. what significance they have is yet another abstract form thing, if any
16:41:31 <EvanR> formal thing
16:41:34 <davr0s> just like we used to look at the asm output of a C compiler, i think it would be nice to look and comprehend 'whats happening in the middle' with the more complex generative things these high level languages can do
16:41:40 <EvanR> which is the whole point of interface vs implementation
16:41:59 <davr0s> e.g. with haskell i'm being told [T] might not really be a linked list, rather 'a point where a producer and a consumer meet'
16:42:16 <EvanR> even whatever electronics is happening inside of a processor "for real" is described by abstract formal electrical engineering language
16:42:33 <EvanR> and that has an interpretation in quantum physics, which is......
16:42:39 <EvanR> yet another abstract langauge
16:43:15 <davr0s> there's nothing like default values for constructors, right?
16:43:26 <monochrom> \∩/ energy bands
16:43:38 <davr0s> because varitable argument use is currying 
16:43:46 <davr0s> so haskell can't really have default args, right?
16:43:59 <EvanR> you can easily make a function that provides the default args to a constructor
16:44:08 <monochrom> OCaml proves that default arguments don't mix with currying.
16:44:10 <EvanR> and your custom args to the rest
16:44:32 <davr0s> this is a discussion they have in rust... do they add default args or currying...   they do neither.
16:44:50 <davr0s> i wonder which way that will ever go, if any
16:44:51 <EvanR> the choice is so obvious
16:45:11 <monochrom> Rust should follow games on Steam --- "community mods welcome!"
16:45:12 <EvanR> and reveals the where the designers and users are coming from in their programming experience
16:45:27 * monochrom subscribes to the "Rust currying" mod
16:45:40 <davr0s> oh has someone done it?
16:45:47 <monochrom> No, I'm just kidding!
16:46:01 <davr0s> thing is my take is that different functions suit currying or defaults
16:46:10 <XorSwap> {- LANGUAGE GarrysMod -}
16:46:11 <monochrom> Yeah certainly.
16:46:34 <davr0s> maths, list manipulation etc ..   currying obviously;   but interfacing with UI frameworks ... defaults are great
16:47:00 <EvanR> davr0s: defaults, turns out, to be really uninspiring once you look at it
16:47:31 <davr0s> the obvious idea would be to have currying and disable when you have defaults, but they say they dont want features that make libraries break backward compatibility
16:47:41 <EvanR> when you do end up, rarely, with a single function implementing your entire API and takes an XML structure for an argument, as configuration, then you want the following pattern
16:47:52 <EvanR> a monoid of configuration, which starts out fully default
16:48:01 <EvanR> but you can monoid append on custom entries
16:48:18 <EvanR> but its much nicer if you dont have that 1 giant function entry point
16:48:27 <EvanR> instead a library of combinators you can put together in cool ways
16:48:35 <EvanR> *including for GUIs*
16:48:49 <monochrom> Oh! Yeah, try the monoid idea instead, i.e., the parameter type is a monoid instance so you can <> more or fewer explicit config params.
16:49:10 <XorSwap> huh, you could have an uber complex monad that would let you program procedurally
16:49:20 <EvanR> :(
16:49:33 <EvanR> and call it common lisp
16:49:35 <XorSwap> do { a <- 1; b <- 2; while (a < b) $ do { ... } }
16:49:40 <monochrom> I think that's called Yesod? :)
16:50:07 <EvanR> nice, 1 is an action
16:50:15 <monochrom> No, it's the BASIC monad.
16:50:41 <monochrom> http://hackage.haskell.org/package/BASIC  have fear^H^H^H^H fun!
16:50:54 <EvanR> its much better if <- signifies some kind of effect in your language
16:51:01 <XorSwap> I thousht you were kidding wow
16:51:03 <EvanR> a <- 1 makes me think.. what does 1 do
16:51:31 <davr0s> do any tools in the haskell world do the equivalent of 'dot autocomplete'  with the infix backticks   e,g,  write a variable name, press ` , and a dropbox of functions that might fit appears
16:51:42 <EvanR> and if you stylistically decided 1 is the "no effect" effect, what does 2 do
16:52:05 <monochrom> I think emacs haskell-mode can do that under suitable config
16:52:15 <geekosaur> it's machine language, keep your opcode list handy :p
16:53:03 <EvanR> https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
16:53:22 <pacak> o/ Suppose you want to derive instances using generics but want to be able to let user tweak instances a bit without getting into generics code. For example logic might be
16:53:23 <pacak> (Fooable a, Fooable b) => Either a b = Left a | Right b results in code like  name "Left" <$> foo a <|> name "Right" <$> foo b
16:53:23 <pacak> how do you let user replace "Left" and "Right" with something else?
16:54:00 <EvanR> #define LEFTS_NAME "Left"
16:55:01 <monochrom> pacak: There is some deeper part of aeson that does that kind of thing. Dig around. In particular it offers several common ways to encode sum types for you to choose.
16:55:03 <geekosaur> $(makeFooMethod 'Left 'Right)
16:55:34 <monochrom> In a way that they're fairly configurable and you write minimal code manually.
16:55:43 <pacak> geekosaur: Without TH?
16:55:56 <pacak> monochrom: I'll have a look, thanks.
17:01:24 <davr0s> r.e. currying/rust ,  i think some people claim  the lambda syntax is compact enough..  |x|foo(a,x)    vs  foo(a) ... and it's more obvious that it's a function being returnred
17:03:46 <davr0s> maybe they could use the comma to request currying explicitely,    foo(a,)
17:04:52 <davr0s> then there'd be no confusion with default args.
17:09:32 <geekosaur> steal WhateverStar from perl 6. except they'd have to spell it differently. maybe underscore: foo(a, _)
17:10:41 <davr0s> that has the appeal of being able to slot in anywhere, i guess.
17:30:24 <pikajude> cocreature: i'm not sure this mvc thing will work out after all
17:51:27 <lmapper> how would one pattern match an IO Value? I have a type signature : 
17:51:31 <lmapper> aux :: [ IO Value ]-> Maybe (IO Value)
17:52:10 <lmapper> Value is a ADT, with sum type members like Finished (IO Value)
17:52:38 <lmapper> I'd like to pattern match aux like this: aux [ Finished m ] = do Just m
17:52:59 <geekosaur> you can't pattern match IO
17:53:04 <lmapper> but I am not sure how to do that when it is an [IO Value]
17:53:06 <lmapper> ah
17:53:49 <lmapper> ok I'll restructure another part then, thanks
17:54:01 <geekosaur> I don't know how you got an [IO Value] but I would use sequence to turn it into IO [Value] and then use <- in do notation, or >>=
17:55:26 <geekosaur> an IO is not a wrapper around a value, it's a promise to produce a value. >>= is how you attach something to that promise to do something with the value; its result must be another IO value (i.e. "promise")
17:59:37 <Maxdamantus> Ouch, "promise"
18:00:41 <Shockk> cocreature: I finally got around to writing a bit of llvm code and I have a new issue, potentially related
18:00:43 <lmapper> yeah, it's a bit of an awkward situation... this is actually a list of IO Value that have not been calcuated yet
18:01:31 <Shockk> cocreature: Phyx-: during linking, I get thousands of undefined references from all the libLLVMWhatever.a libraries, for what look like all the C++ symbols
18:01:42 <geekosaur> lmapper, what were you planning to do with them?
18:04:09 <davr0s> 'mapM_' ... just returns monad () .. so it's more like a 'foreach' ? i think of actually producing a collection when i head 'map' ,
18:04:11 <lmapper> here's the work in progress, I can't take credit for most of this code though, I'm working off of a sample from someone's help yesterday
18:04:16 <davr0s> 'defered foreach'
18:04:18 <lmapper> http://lpaste.net/1021221366176677888
18:05:45 <geekosaur> davr0s, the trailing _ means it discards results; you usually use it when you are mapM-ing an IO action with no result (that is, ... -> IO ())
18:05:45 <lmapper> the original sample was with non IO Value, I'm trying to extend it to allow for IO "Function"s also
18:05:58 <davr0s> geekosaur yeah thats where i'm seeing it.
18:06:54 <lmapper> the typed hole in evaluate is where "aux" goes
18:08:16 <glguy> lmapper: in the code from last night you shouldn't have needed to add  IO to Function, nor needed to add Function2
18:08:23 <davr0s> i'm tempted to make a wrapper for that swapping args, 'foreach',   i've also discovered (flip mapM_).   actually the docs seem to say 'forM_' does that,ok.
18:08:47 <mnoonan_> :t for
18:08:49 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
18:09:00 <mnoonan_> (and also for_)
18:09:03 <davr0s> ok that works
18:09:07 <mnoonan_> nicer than forM :)
18:09:45 <lmapper> ah, I did not get to the last example yet (the universe), I was trying to work with the second demo, so that I fully understand it
18:10:13 <glguy> lmapper: I don't mean anything about the universe example
18:11:24 <lmapper> today I was trying to chain the functions together, where the result of "add" took two parameters, and was passed into "printInt"
18:13:34 <lmapper> but, it's very possible I have messed up the example :)  I learned a lot going through it and trying to extend it though
18:14:15 <glguy> lmapper: If you go back to the original definition of Function you can use that to replace Function2
18:15:40 <glguy> lmapper: What do you imagine your input program looking like?
18:15:59 <glguy> I know you described it as looking like: print (40 + 40), but what's the actual input value look like?
18:19:12 <lmapper> it's a JSON with a list of nodes( Function ), and a list of connections ( output of one node connected to input of another )
18:20:43 <lmapper> so, for example, "printInt" type node will have a port, and a connection describes that this port is connected to another node's output port
18:21:36 <lmapper> so, that other node needs to be evaluated, that node has a type of "add", which will in turn evalute it's inputs
18:24:12 <lmapper> however, any of those nodes may be corresponding to a haskell function which requires IO, so I was thinking it's easiest for now, just to build the node functions with IO Value input and output
18:25:25 <lmapper> so, I was trying to extend the second demo example to account for IO and "Functions"(nodes) which call other nodes
18:26:21 <dougger> Hi there. Can anyone help with modifying how servant-client supplies query string parameters? By default, the query string parses to "id=1", but I need it to parse to "id=eq.1" in order to query a PostgREST API.
18:27:26 <Axman6> You'll probably need a custom type which instanciates HttpApiData
18:27:47 <Axman6> what type do you currently have for that query param?
18:28:08 <lmapper> for example, if later I have a node called "SendEmailAndReturnString" placed in the middle of a node graph, it requires IO, and may also have a return value that will be used downstream
18:28:35 <dougger> Right now I'm just using a string to verify that the data is being returned
18:28:36 <dougger> type GetTodo = QueryParam "todoId" String :> Get '[JSON] Todo
18:29:49 <dougger> I was thinking of a custom type but thought there might be another solution I'm overlooking
18:45:45 <hashpuppy> :k (->) shows (->) :: * -> * -> *.  i'm not sure i understand when :i (->) shows just data (->) t1 t2
18:45:46 <lambdabot> error: parse error on input ‘::’
18:46:17 <hashpuppy> can someone explain what :k (->) is showing?
18:47:04 <lmapper> glguy, I am looking through config-schema in your github, I think I saw the universe pattern in there, the parsing and value recognition seems similar to the universe pattern you showed yesterday
18:47:05 <geekosaur> there are two different (->)s
18:48:12 <geekosaur> but, :i can't say much useful about it because it's wired-in and special
18:51:14 <geekosaur> it's actually more special than either one shows
18:51:51 <geekosaur> because :k claims it accepts only kind * but it can also handle unlifted kinds (but cannot produce them)
18:52:25 <hashpuppy> so is "Maybe Int" considered a concrete type?
18:52:57 <geekosaur> hashpuppy, yes
18:53:08 <hashpuppy> oh.  thanks.  it makes sense now
18:55:46 <tomleb> So I have a list of thing I export for my module. There's one data constructor I'm trying to export but for some reason it doesn't work. How can I find all exported functions/data constructors for a given module ?
18:55:52 <tomleb> Is there a ghc command that does that
18:56:36 <geekosaur> ghci? :browse
18:59:37 <tomleb> geekosaur: Okay, so I found out that it's a 'data instance' (which I don't know yet what it is)
18:59:41 <tomleb> How do I export that ?
18:59:51 <tomleb> data instance persistent-2.6.1:Database.Persist.Class.PersistEntity.Unique
18:59:51 <tomleb>                 User
18:59:52 <tomleb>   = UniqueUsername Text
19:00:50 <tomleb> Is there anyway to export it directly or do I need to add a newtype and export the newtype 
19:01:04 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export
19:01:38 <geekosaur> (I think)
19:04:00 <tomleb> Doesn't seem to work
19:05:35 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instances
19:06:15 <geekosaur> or for that matter all of https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#import-and-export (that other link is just the last section)
19:07:44 <tomleb> 'Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.'
19:08:21 <tomleb> Anyway I'm going to sleep I'll check it out tomorrow because my brain isn't able to read anything you sent me
19:08:24 <tomleb> Thanks
19:12:00 <mnoonan_> I’ve gone down a wikipedia rabbit hole about the origins of (!!).. it looks like the operator was (!) in Miranda, which was also the array indexing operator in BCPL. But weirdly both ALGOL and C use a[i]-style indexing, so it doesn’t seem to be as simple as one single lineage..
19:15:10 <glguy> lmapper: It's related, yeah. Did you find the GHCJS-based demo for that package?
19:15:50 <lmapper> I did, config-app , right
19:16:05 <monochrom> Interesting, BCPL also did "!".
19:16:23 <glguy> lmapper: Yeah, I just didn't know if you saw it was available at https://glguy.net/config-demo
19:17:00 <mnoonan_> nonochrom: I was surprised too, it seems to be an anomaly in the ALGOL lineage
19:17:11 <mnoonan_> *monochrom 
19:17:14 <monochrom> But to a large extent, if all you have is an ASCII typewriter, everything looks like an ASCII typewriter punctuation.
19:17:29 <lmapper> yes, I found it, thanks
19:18:43 <monochrom> BASIC uses a(i) :)
19:22:06 <mnoonan_> hmm.. “BCPL ("Basic Combined Programming Language") is a procedural, imperative, and structured computer programming language designed by Martin Richards of the University of Cambridge in 1966”
19:22:14 <mnoonan_> maybe ! is just a UK device
19:24:51 <geekosaur> apparently ! was also in cpl
19:26:11 <geekosaur> hm, actually misread, trying to check further
19:26:16 <mnoonan_> oh, and another related one: in both BCPL and ML, “! foo” is a dereference of “foo”. 
19:30:01 <geekosaur> oh, no, cpl used [] but also used [] for function parameters, so arrays are a bit weird...
19:34:36 <davr0s> anyone know if there's a cleaner way to do this...   https://gist.github.com/dobkeratops/f53ac3253ce7b3629e3c95a055c01f9e
19:35:19 <davr0s> conditional stuff , IO monad.  
19:36:36 <davr0s> so I'm guessing '$='  is retuning an 'action',  i'm using '>>' to 'compose actions';  the case expression is returning one 'action' or a null action ('return ()')
19:38:03 <mnoonan_> I’m not really suggesting this is a good idea, but you can do “(,,) <$> ma <*> mw <*> mu” to get from a (Maybe a, Maybe b, Maybe c) to a Maybe (a,b,c), and then use “for” to do your inner action on the Just case.
19:38:11 <davr0s> perhaps i can make a tuple of 3 functions  (($=) gWorld) , (($=) gUpdate) , (putStrLn),
19:38:46 <davr0s> and 'pipe the output' of the call into that . ..  i'm stil half flailing around here.. i've surprised myself actually writing this code in the first place, lol.
19:38:50 <mnoonan_> e.g. something like:
19:39:13 <mnoonan_> for ((,,) <$> ma <*> mw <*> mu) $ \(a,w,u) -> do
19:39:18 <mnoonan_>     (your inner code here)
19:39:30 <mnoonan_> maybe for_
19:40:01 <davr0s> <*> 'lifts' a value and calls the rhs?      (,,)  .. is that a function for making tuples?
19:40:11 <mnoonan_> right
19:40:14 <mnoonan_> :t (,,)
19:40:15 <lambdabot> a -> b -> c -> (a, b, c)
19:40:55 <davr0s> strangely addictive.   Part of me is saying right now: "this is so ridiculously overcomplicated that you should go back to Rust ASAP".
19:41:10 <mnoonan_> just think of “f <$> x <*> y” as an idiom for calling a normal function f with some wrapped values x, y when f really expects the unwrapped versions
19:41:11 <davr0s> the other part is saying 'well the other stuff in haskell is so elegant, it's worth figuring this out..'
19:41:49 <pacak> davr0s: It might spoil you and you won't be able to program  in other languages.
19:43:27 <davr0s> i'm also wondering if this could have been done with some sort of nested  'do block',   is it possible for a 'do block' to be used 'in the Maybe monad' to do a chain of conditional things .. i.e. do the next step if true, else break..'
19:43:49 <mnoonan_> davr0s: but maybe just format it nicer and call it a day: https://gist.github.com/matt-noonan/9bc2bb812fc95d29364e0b2b6ea969cf
19:43:51 <Axman6> for_ (callUf <$> ma <*> mw <*> mu) $ \(na,nw,dbstr) -> gWorld $= Just na *> gUpdate $= Just nw *> putStrLn dbstr?
19:44:26 <pacak> davr0s: There's MaybeT...
19:44:49 <mnoonan_> Axman6: callUf is getting a non-Maybe parameter in an annoying place
19:45:00 <Axman6> oh, ew
19:45:26 <davr0s> i also wonder if i could simplify this by making the 'dbstr' a Maybe aswell,  i.e. more symetry to allow a pattern to be used
19:46:53 <mnoonan_> do you have a bunch of functions that need the gWorld, gAssets, gUpdate values and need them to be non-Nothing?
19:47:29 <davr0s> this is just happening at one point in my program; basically im building a litle wrapper to Glut , with it's annoying globals
19:47:55 <davr0s> the 'callUf' stuff is where my real program happens (i.e. i store a function there)
19:48:04 <pikajude> hey is anyone who is present very familiar with the mvc package
19:49:18 <mnoonan_> I see. then I reiterate my “nicer format and done” comment :)
19:49:21 <davr0s> mnoonan_  so basically it's just a couple of places where these are read... 'idle update' , 'display callback' 
19:49:47 <davr0s> i mean at this point i have enough to get on with writing pure code 
19:50:14 <davr0s> ok i'll mess around a little more,
19:51:17 <davr0s> there's ways to chain sequences of things returning maybes aswell?  the 'do notaiton' would work for that too ?
19:51:34 <davr0s> e.g. a chain of things which basically breaks out if there's a 'nothing'
19:52:41 <davr0s> i'm using the glut bindings ... i suppose bindings to another window/gl wrapper might allow this do be done without the horrible globals in the middle
19:54:56 <mnoonan_> davr0s: yes, MaybeT layers a Maybe effect onto some other monad
19:55:20 <mnoonan_> here’s another approach based on what Axman6 suggested: https://gist.github.com/matt-noonan/9bc2bb812fc95d29364e0b2b6ea969cf
20:31:51 <davr0s> i can probably simplify this by having one IORef (Maybe ...) actually
20:32:25 <EvanR> for what purpose
20:33:19 <davr0s> cutting down on the number of steps involved
20:33:26 <davr0s> they're all initialized together.
20:33:50 <davr0s> what i've got is extra complexity from testing that each exists..
20:33:50 <EvanR> i suspected it has something to do with initialization
20:33:50 <EvanR> Maybe isnt a very good way to do it
20:34:04 <EvanR> since youll continually need to check its still there after initialization
20:34:44 <EvanR> MVar has the built in notion of "not there yet"
20:34:56 <EvanR> newEmptyMVar :: IO (MVar a)
20:35:26 <EvanR> if the value never changes once its there, you can use IVar, which has the added benefit of being usable from pure code
20:38:08 <EvanR> and if you have a bunch of things initialized together, you could maybe avoid Vars altogether and pass in a single record
20:39:34 <davr0s> i think they will be changing, e.g. 'world' was the state that would be updated every frame (world = update (world,inputs) basically)  ,   'gUpdate' was going to work like a statemachine (e.g. calling update also returns a new update function);   'gAssets' .. could have some defered loading going on (i have in mind another 'hook' for 'loading hints' etc etc
20:40:05 <EvanR> then MVar can hold the world and be swapped out
20:40:19 <davr0s> i'll read about MVar.
20:40:21 <EvanR> and has the ability to be initially (or later) empty
20:40:40 <EvanR> if thats necessary
20:43:01 <davr0s> does that mean 'x<-readMVar  gWhatever' might fail - does it need to be in a 'MaybeT' or something to allow that
20:43:23 <davr0s> ahh 'waits until it's full..'
20:43:42 <davr0s> that might be ok, i think my situation can guarantee it's written before its read.
20:44:24 <EvanR> right
20:45:04 <EvanR> if youre planning to use the value and replace it, then you want modifyMVar
20:45:40 <EvanR> if an error occurs in the body, the original value is put back
20:52:58 <EvanR> an MVar can be empty or full. if you try to take from an empty MVar you will block until some other thread puts something there (or crash due to deadlock detection). if you try to put into a full MVar you block until some thread takes from it (or crash due to deadlock detection)
20:53:13 <EvanR> deadlock errors happen when the runtime sees youll never wake up
20:54:33 <EvanR> MVars are about halfway between the insanity of mutexes and the nirvana of software transactional memory (Control.Concurrent.STM)
21:01:18 <davr0s> EvanR ok i tried MVars.. and I managed to crash it :)  main: internal error: stg_ap_v_ret
21:01:18 <davr0s>     (GHC version 8.0.2 for x86_64_apple_darwin)
21:01:18 <davr0s>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
21:03:15 <davr0s> my use of 'modifyMVar' aparently.. works without that, let me see what else i can do..
21:06:00 <davr0s> ok it works with 'swapMVar' instead of modifyMVar.
21:36:45 <Larmbr> hi, what is the f and t is in the expression "sequenceA [[1,2,3],[4,5,6]]",  my idea is the t is "an 2-element array', f is a "3-element array", so after sequencing, it should be a 3-element array, in which each element is a 2-element array, but the result disagrees. Thanks for explaination.
21:37:37 <ongy> :t sequenceA
21:37:39 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:38:27 <ongy> those are lists not arrays. So you have list and list instead of '#-element array'
21:38:59 <Larmbr> ongy, alright, just replace the "array" with "list"
21:39:09 <ongy> > sequenceA [[1,2,3],[4,5,6]]
21:39:11 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
21:40:24 <ongy> Larmbr: you can't think in N-element lists. The standard haskell list ([]) doesn't have any such information in the type
21:41:58 <Axman6> lambdabot: if you _do_ want that behaviour, you want transpose:
21:42:06 <Axman6> >  transpose [[1,2,3],[4,5,6]]
21:42:09 <lambdabot>  [[1,4],[2,5],[3,6]]
21:44:28 <Larmbr> ongy, yep, I originally thought like this, so for this example, the type is [[a]], and after flipping f and t, the type doesn't change, and why is the result should be like ths, it can be the same, or it can be, say, [[1,4],[2,5],[3,6]].  So I think I don't get the exact idea of what f and t respectively is
21:45:51 <mauke> f = [], t = []
21:46:48 <mnoonan_> Larmbr: f and t are both []-the-list-type-constructor, but you need to understand different things about them: the Traversable instance for t, and the Applicative instance for f.
21:55:14 <unknownln> Larmbr: Not sure if this helps, but `sequenceA [[1, 2, 3], [4, 5, 6]]` is equivalent to `[[x, y] | x <- [1, 2, 3], y <- [4, 5, 6]]` lambdabot
21:55:32 <unknownln> > [[x, y] | x <- [1, 2, 3], y <- [4, 5, 6]]
21:55:35 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
21:58:09 <Larmbr> mnoonan, unknownln , thanks!
22:07:32 <Axman6> > sequenceA [[1,2,3],[4,5,6],[7,8,9]]
22:07:34 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
23:06:03 <kuznero> Hi All!
23:06:36 <kuznero> I was wondering if there are any reasonably serious production systems in cloud haskell out there?
23:06:56 <kuznero> I am eager to try it but it is not in the active development for about a year...
23:07:33 <Axman6> There was a company in NZ using it for their CI platform, but that's the only one I've heard of
23:15:44 <drjoliv> is there a log n implementation for `notElem` for sorted lists
23:16:20 <Axman6> not for lists no, that's not possible
23:16:21 <liste> drjoliv: I don't think so, lists don't support O(1) lookup
23:16:23 <kadoban> drjoliv: No, and it wouldn't really be possible for what lists are. You probably want a Data.Set perhaps.
23:16:40 <drjoliv> duh
23:17:18 <drjoliv> its not possible cause list are like linked list in haskell?
23:17:36 <kadoban> Yes, there is no fast indexing.
23:17:54 <Axman6> @src []
23:17:54 <lambdabot> data [] a = [] | a : [a]
23:17:57 <kadoban> You could do it with an array or a vector, but you'd need a library or to implement it yourself.
23:18:16 <kadoban> (implement the notElem part that is, not the array/vector itself, those exist already)
23:18:19 <Axman6> Data.Set is definitely the right choice, it gives you log n 
23:18:35 <drjoliv> whats the proper way to share code here
23:18:43 <Axman6> @where lpaste
23:18:43 <lambdabot> http://lpaste.net/
23:18:44 <drjoliv> new to irc and #haskell
23:19:08 <Axman6> drjoliv: well, you're already doing much better than many newbies who just paste their code here :)
23:21:39 <drjoliv> So check it I'm working on finding nine digit pandigital numbers 1-9  http://lpaste.net/356503
23:23:17 <drjoliv> no comments im sorry, and i'm using awful names for variables, basically iI'm trying to find a quicker way to remove numbers from the list of digits [1..9]
23:24:03 <drjoliv> remove and check and see if number has already been removed
23:25:12 <drjoliv> I'm assuming that checking if the number has been removed is a bootle neck and slowing it down
23:28:44 <drjoliv> would replacing the list with a set make it any faster
23:29:14 <Axman6> hard to tell, with a set that small it may be slower
23:29:33 <Axman6> so you're looking for a number made up from just the numbers 1-9 right>
23:29:35 <Axman6> ?
23:29:42 <drjoliv> yes
23:30:43 <Axman6> what is the full exercise? do you need a find a specific pandigital number?
23:30:49 <Axman6> (geussing this is project euler?)
23:31:28 <drjoliv> Yes sir the full exercise is finding the largest  prime that 9 pandigital
23:31:38 <drjoliv> yep problem 41
23:31:59 <Axman6> so, you might find things easier by starting with only the list of pandigital primes
23:33:18 <Axman6> can you write a function of type: [a] -> [([a],a,[a])], which would do: foo "abc" -> [("",'a',"bc"),("a",'b',"c"),("ab",'c',"")], ie, a sliding window through a given list?
23:33:41 <Axman6> (The bruteforse solution to PE problems are rarely the right choice)
23:35:31 <drjoliv> intersting I dont see it purpose, let me gaze at it deeply for a while
23:37:25 <drjoliv> Whats's another example where this sliding window function would be useful
23:37:28 <Axman6> so, that functions selects one element, and gives you all the rest of the elements - if you repeat the use of this function on the combination of the two lists, you eventually get all combinations of all element in that intial list where each value is used once
23:37:33 <ADG> isPandigital k n = length n' ==  k && all (`elem` n') (map intToDigit [1..k]) where n' = show n
23:38:08 <Axman6> if applies to [9,8,..1], you'll be able to produce all pandigital numbers, in decreasing order
23:38:50 <drjoliv> Holy smokes Axman6 thats sweet
23:39:00 <drjoliv> i can see using that in lots of places
23:39:06 <Axman6> much more fun than just bruteforce search ;)
23:39:18 <Axman6> drjoliv: you'll find the functions inits and tails useful
23:39:24 <ADG> you can also do : head . isPrime . reverse . map read $ filterM (const [True, False]) "123456789"
23:39:28 <Axman6> > inits [1..5]
23:39:31 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
23:39:33 <Axman6> > tails [1..5]
23:39:35 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
23:39:43 <ADG> >import Control.Monad
23:39:54 <ADG> > import Control.Monad
23:39:56 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
23:40:14 <Axman6> > filterM (const [True, False]) "123456789"
23:40:17 <lambdabot>  ["123456789","12345678","12345679","1234567","12345689","1234568","1234569",...
23:40:24 <Axman6> doesn;t do what you're after
23:40:37 <ADG> actually yes
23:40:58 <Axman6> (but is a useful thing to know)
23:41:07 <drjoliv> very useful
23:41:12 <Axman6> > filterM (const [False,True]) "123456789"
23:41:14 <lambdabot>  ["","9","8","89","7","79","78","789","6","69","68","689","67","679","678","6...
23:41:22 <ADG> This is my solution I wrote a long time ago
23:41:25 <ADG> https://github.com/adityagupta1089/Project-Euler-Haskell/blob/master/src/41.hs
23:41:54 <drjoliv> Im gonna copy it and come back to it later ADG
23:41:59 <drjoliv> dont wanna ruin the fun
23:42:20 <Axman6> drjoliv: so a common theme you find with PE is that brute force is just too slow, and you should try and only generate possible candidates for the search, not every single value, even if it;s obviously not a suitable candidate
23:44:09 <drjoliv> Thanks for the advice ADG
23:44:27 <drjoliv> and Axman6
23:45:15 <Axman6> good luck! let us know how you go
