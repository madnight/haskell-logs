00:00:41 <dmj`> @package streaming
00:00:41 <lambdabot> http://hackage.haskell.org/package/streaming
00:00:49 <Cale> (still not sure about upstreaming that fix, given the additional dependency and the fact that if I'd thought a bit more about it, perhaps io-streams would have been better for the snap integration...)
00:01:05 <cocreature> yeah I’ve been meaning to take a deeper look at streaming which seems to have grouping builtin instead of tyring to retrofit it
00:01:10 <Cale> But let's get snap using pipes ;)
00:01:19 <merijn> What's truly missing is a package to tie different streaming libraries together...
00:01:30 <Cale> It's usually not all that hard to tie them together by hand
00:01:32 <merijn> I prefer pipes, but like half the stuff I'm using right now is using conduit >.>
00:01:38 <Cale> But yeah, maybe something would be good
00:01:47 <cocreature> Cale: I vaguely recall some alternative to warp that’s built on pipes
00:02:00 <dmj`> hyperdrive, but still a wip
00:02:21 <cocreature> yeah it was stagnant the last time I looked at it
00:03:44 <slack1256> I can't understand pipes-parse. lens based parsing hurts my head
00:04:32 <Cale> slack1256: I used pipes-parse, but I don't remember interacting with lenses at all..
00:05:03 <Cale> oh, there is some lensy stuff in there, I see
00:05:41 <slack1256> yeah, it seemed to me "zoom"-ing the pipes was expected and encouraged
00:06:00 <Cale> It's a thing you can do, I guess
00:09:27 <Cale> slack1256: For the most part you just write an attoparsec parser or something, and use pipes-attoparsec, and then pipes-parse sort of sits in between.
00:10:36 <Cale> Maybe with enough lenses, you could write actual entire parsers with zoom and the bits that pipes-parse gives you, but meh.
00:15:40 <Sh4rPEYE> glguy: Thanks, makes sense. One more question on isomorphisms: I want to define an isoEU :: ISO (Either [()] ()) (Either [()] Void), but experiencing some problems when it comes to including the Void
00:16:11 <Sh4rPEYE> Current code (wrong): http://lpaste.net/8802622673873010688
00:16:48 <julianleviston> Ok I put this up… https://stackoverflow.com/questions/44612606/recursion-issue-when-writing-a-pretext-aware-version-of-lens-para
00:18:02 <glguy> Sh4rPEYE: where are you getting these?
00:18:41 <Sh4rPEYE> glguy: CodeWars has a nice Kata about isomorphisms. I didn't have problems with most of them, just these two I talked about
00:18:58 <glguy> Sh4rPEYE: your solution won't need to construct a Void
00:19:03 <Sh4rPEYE> http://www.codewars.com/kata/isomorphism/haskell
00:19:43 <glguy> you need to figure out why this one is possible before you can code it
00:20:15 <glguy> Sh4rPEYE: it might be helpful to break the problem into two steps
00:20:44 <glguy> isomorphisms between the two types you have and [()]
00:21:22 <glguy> once you have those, you can compose them
00:22:29 <Sh4rPEYE> ISO [()] () and ISO [()] Void?
00:22:36 <glguy> no
00:22:58 <glguy> it should be clear to you that those are not possible
00:23:12 <Sh4rPEYE> yes
00:23:28 <julianleviston> Sh4rPEYE: oh that site looks cool :)
00:23:34 <glguy> the two either typed
00:23:39 <glguy> types*
00:23:57 <Sh4rPEYE> ISO [()] (Either [()] ()) and the other one
00:23:58 <Sh4rPEYE> yep
00:24:20 <Sh4rPEYE> julianleviston: Pretty nice to grasp the basics of a language :-)
00:24:39 <julianleviston> Might suggest we use it at work
00:24:40 <Sh4rPEYE> (and, well, learn about isomorphisms)
00:24:59 <julianleviston> we’ve used exercism a bit… it’s ok
00:26:35 <julianleviston> Sh4rPEYE: dunno about its haskell coverage tho
00:27:25 <julianleviston> Ooh I hadn’t seen this page before :) http://comonad.com/reader/2009/recursion-schemes/
00:28:41 <Sh4rPEYE> Code Wars seems to have more exercises and variety
00:29:14 <julianleviston> Sh4rPEYE: yeah they seem more interesting, too
00:29:23 <julianleviston> Sh4rPEYE: hehe sorry that’s what you meant
00:29:29 <Sh4rPEYE> julianleviston: Cool link! Was looking for something like that for a while.
00:29:59 <Sh4rPEYE> (it wasn't for me, but whatever; pretty nice)
00:30:37 <julianleviston> Sh4rPEYE: it links to the category-extras package which I’d seen a bit, but I’ve only really looked at his recursion-schemes library properly and even then I was like “uhhh I need to read and learn about Fix more” :) 
00:31:17 <julianleviston> There’s also this which is nice: https://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf
00:32:29 <Sh4rPEYE> I'll look at it, julianleviston. It'll probably be too advanced for me, though.
00:33:17 <Sh4rPEYE> glguy: If I try to implement ISO [()] (Either [()] Void), I have to account for Right Void -> [()], right?
00:33:25 <julianleviston> Sh4rPEYE: I found this is pretty darn good to get one up to speed on such things: http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
00:33:48 <julianleviston> Got so much to learn & read now :)
00:36:23 <Sh4rPEYE> Yeah and there's more and more every day :-D 
00:45:19 <Sh4rPEYE> glguy: It would be something like this... But I just don't know how to go around the Void properly. http://lpaste.net/6631005059175940096
00:50:32 <the_2nd> When using Data.Vector and referencing several states of a vector after mutating it, will each reference result in a full copy? I can't see how this could be solved otherwise
00:51:44 <c_wraith> the_2nd: each "mutation" is actually a full copy (modulo the changes you make)
00:52:03 <c_wraith> the_2nd: if you want actual mutability, you need to use one of the .Mutable modules
00:55:56 <glguy> Sh4rPEYE: those were both wrong
00:56:34 <Sh4rPEYE> Oh. Seems I don't get isomorphisms yet 
00:56:41 <glguy> you're using [] twice in both iso1 and iso2
01:20:59 <Sh4rPEYE> Well, the other sole possibility is: http://lpaste.net/6631005059175940096
01:37:59 <Sh4rPEYE> (right, glguy?)
02:23:46 <dmwit> Sh4rPEYE: That's the same paste, isn't it?
02:25:34 <Sh4rPEYE> It is, but edited. And since then actually edited once more.
02:25:41 <dmwit> What is ISO?
02:25:49 <dmwit> type ISO a b = (a -> b, b -> a) -- ?
02:25:54 <Sh4rPEYE> yes
02:26:27 <dmwit> Okay. I assume there's also intended to be an invariant that if `(f, g) :: ISO a b` then `f . g = id` and `g . f = id`.
02:26:49 <Sh4rPEYE> also yes
02:27:29 <dmwit> Okay. Then for `Iso [()] (Either [()] Void)`, you might like the empty pattern-match language extenison.
02:27:35 <dmwit> I don't remember what it's called.
02:27:48 <Sh4rPEYE> I'll look it up. Never head about it, though
02:27:48 <dmwit> EmptyCase or something like that.
02:28:27 <dmwit> It would let you write `foo = (Left, f) where f (Left x) = x; f (Right v) = case v of`
02:28:38 <dmwit> No `undefined` anywhere, and all pattern matches are complete.
02:30:03 <Sh4rPEYE> Yes, it is the EmptyCase. The iso1 (now in the lpaste) is right?
02:30:53 <dmwit> Seems fine, up to quibbles about undefined's, which I assume are uninteresting for this exercise.
02:32:25 <Sh4rPEYE> I think you are one version behind. Please refresh the lpaste (there are no undefines now; is it still right?)
02:33:04 <dmwit> I believe I am not one version behind.
02:33:52 <dmwit> g (f (undefined:undefined)) = ():undefined, so it's not quite an isomorphism, see?
02:34:25 <dmwit> But that's not an interesting objection, because usually laws are only required to hold for fully-defined inputs anyway.
02:34:35 <Sh4rPEYE> Oh, that's what you meant by the quibbles
02:36:00 <dmwit> You could make it isomorphic even wrt undefined if you gave it a type like `ISO [()] (Either ((), [()]) ())` instead.
02:36:29 <dmwit> (Or `ISO [a] (Either (a, [a]) ())`, to make it more clear which `()`s are really `()`s and which are list elements.)
02:37:18 <dmwit> Hm. Well, `Maybe (a, [a])`, I guess, or you get one too many boxes for the empty-list case. =P
02:40:49 <Sh4rPEYE> Well, it works now, thanks. Theoretically we could work with undefines too, yes :-D I'm glad I didn't have to account for that, though
02:45:35 <Sh4rPEYE> And now the kata about "Algebraic Isomorphism" got unlocked, cool! :-D More headache in the morning
02:45:41 <Sh4rPEYE> https://www.codewars.com/kata/algebraic-isomorphism/train/haskell
03:41:06 <_Noble_Turk_> hi
03:42:08 <Axman6> hello!
03:54:16 <simendsjo> I'm trying to get intero to show hoogle information, but I cannot find the right functions. Running (intero-hoogle-get-worker-create) starts the process, and I can query with (intero-hoogle-blocking-query "query here"). The problem is it just returns the json. I cannot find anything which would display this in a more user-friendly fashion.
04:11:15 <MagneticDuck> https://glot.io/snippets/eqx4jtib03
04:11:31 <MagneticDuck> I can't replicate this problem on the site there, but this code will slowly consume more and more memory
04:11:54 <MagneticDuck> it can be solved by removing the `(>>) return ()`
04:12:36 <MagneticDuck> I want to replace that expression with something useful -- printing status to stdout for example -- but I can't figure out why it has this effect!
04:12:53 <MagneticDuck> (when it isn't added, the program runs with constant memory)
04:15:50 <cocreature> MagneticDuck: how are you compiling and how are you measuring memory usage? it seems to stay constant for me
04:16:17 <jw358> how do i define something like a function that will take a Proxy a and return datatypeName from it?
04:16:45 <jw358> like Proxy a -> String, datatypeName (from (undefined :: a))
04:16:50 <MagneticDuck> cocreature: oh, I just realized I'm running interpreted inside ghci
04:16:56 <MagneticDuck> that does make a difference doesn't it
04:17:15 <MagneticDuck> as for measuring memory, I'm just checking the ghci process
04:17:20 <ph88^> MagneticDuck, look at persistent memory, not virtual memory
04:17:46 <ph88^> jw358, maybe look at Data.Typeable
04:18:23 <cocreature> MagneticDuck: if you can’t reproduce it outside of ghci I woudn’t worry about it
04:18:25 <cocreature> ghci is weird
04:18:39 <jw358> can i not do it with just GHC.Generics?
04:18:47 <cocreature> I’m not sure how Typeable helps here
04:19:49 <ongy> jw358: afaik if you want to refer to the type in the signature in the body you have to use ScopedTypeVariables and make it explicit
04:19:52 <jw358> i have a type for which i don't have any values, and i just want to extract out the metadata
04:20:17 <jw358> yeah, but a simple definition like `extract (_ :: Proxy a) = datatypeName (from (undefined :: a))` doesn't work
04:20:35 <cocreature> jw358: can you show the full code and the error?
04:20:40 <jw358> well, by itself, don't know what i'd need to put in the type signature
04:20:50 <cocreature> you need to add explicit foralls
04:21:12 <cocreature> getName :: forall a. proxy a -> String; getName = datatypeName (from (undefined :: a))
04:21:14 <ongy> y'extract :: forall a. Proxy a -> String;extract = datatypeName (from (undefined :: a))' jw358
04:21:20 <cocreature> and enable ScopedTypeVariables
04:21:28 <jw358> this is really the whole thing, other than for trying out `extract :: forall a. Generic a => Proxy a -> String`
04:21:46 <cocreature> oh yeah you probably need a Generic constraint but ghc should complain if you forget that
04:22:10 <jw358>     • Couldn't match type ‘Rep a’ with ‘t0 d0 f0’
04:22:10 <jw358>       Expected type: t0 d0 f0 a0
04:22:10 <jw358>         Actual type: Rep a a0
04:22:10 <jw358>       The type variables ‘t0’, ‘d0’, ‘f0’ are ambiguous
04:23:22 <nullx002> hi all, i am unable to get ghci running on obsd.
04:23:30 <nullx002> ghc works file, compile and everything
04:23:47 <nullx002> ghci error: GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
04:23:47 <nullx002> ghc: unable to load package `ghc-prim-0.4.0.0'
04:25:26 <gehmehgeh> nullx002: I'd rather ask about that in #openbsd
04:26:13 <gehmehgeh> s/in/at
04:30:32 <cocreature> jw358: http://lpaste.net/356327 works somewhat
04:31:10 <cocreature> jw358: it doesn’t work for newtypes since I can’t figure how to add the ISing constraint for the last parameter of Metadata since that class is not exposed so I just fixed it to False
04:34:09 <jw358> i think that's fine for me
04:34:12 <jw358> let's see
04:34:36 <jw358> damn, this is pretty far down the rabbit hole already :-DD
04:39:33 <jw358> cocreature: thanks! i guess ill then have to figure out some ways to match on D1 in the caller
04:40:55 <falcon01> Anyone know how to open linux terminal and execute command.
04:41:14 <falcon01> exit
04:45:01 <falcon01> I want to create a script to open terminal and do "cat" command but terminal close after the command. 
04:45:20 <cocreature> falcon01: and you want to create that script in Haskell?
04:46:08 <falcon01> No cocreature. I want to create itfor my own, for productivity use only.
04:46:25 <cocreature> falcon01: this channel is about the Haskell programming language not about shell scripting
04:46:45 <cocreature> so if you’re not planning to write that script in Haskell you’re sadly in the wrong place :)
04:46:47 <falcon01> Oh im sorry.
04:47:17 <maerwald> he could write a DSL in haskell that outputs shell :P
04:52:28 <heebo> hi is the lens library still in Control.Lens, im seeing errors that say its failing to load the interface
04:52:57 <heebo> im using ghc 8.0.2
04:53:09 <Gurkenglas> heebo, you'll need to tell the compiler that you need the lens package. Are you working in a project or writing a single .hs file? Are you using stack?
05:06:12 <buggerme> Hello, can someone with please help me with exporting XML namespace declarations (https://en.wikipedia.org/wiki/XML_namespace#Namespace_declaration) with HXT?
05:06:23 <buggerme> For example, <root xmlns:prefix=namespace></root>
05:06:39 <buggerme> Minimal example: runX . xshow $ root [] [mkElement (mkQName "prefix" "root" "namespace") none none]
05:10:26 <torstein> Anybody familiar with Accelerate and its various libraries? I need matrix multiplication
05:13:32 <buggerme> Does anyone have experience with HXT?
05:23:45 <hlosempai> exit
05:41:54 <Sh4rPEYE> Can somebody help me with this isomorphism, please: powS :: ISO (Maybe b -> a) (a, b -> a)
05:42:18 <Sh4rPEYE> (where type ISO a b = (a -> b, b -> a))
05:47:22 <hsk3> Can I include other files from ~/.ghci  ? I want to split ~/.ghci into multiple files.
05:47:52 <hlosempai> hey guys there's a new language that will be replacing and improving everything before it fyi, it's a complete paradigm shift, out with the old and antiquated, in with the new and streamlined.
05:48:07 <hlosempai> just thought I'd give you all a heads up
05:48:13 <hlosempai> it's called javascript btw
05:48:29 <hsk3> lol wtf
05:48:58 <maerwald> awesome
05:51:19 <manek> Hello! I've got just a small question out of curiosity. Is there any simple, idiomatic way to express this function? inverseOrd = \case GT -> LT; LT -> GT; EQ -> EQ? Defining it in a concrete module seems just wrong cause it is very general
05:56:51 <boj> manek: flip compare
05:57:24 <manek> boj: no, the sig does not match
05:57:36 <maerwald> he wants Ord -> Ord
05:57:40 <maerwald> *Ordering
05:57:45 <boj> ah
05:58:10 <glguy> compare EQ
05:59:04 <manek> glguy: oh, yeah thato would work, heh
05:59:17 <manek> glguy: thanks!
05:59:20 <glguy> For idiomatic, I think that function wouldn't come up so much
05:59:38 <hpc> usually the most you see with Ordering is its Monoid instance
06:01:37 <Sh4rPEYE> glguy: I managed to solve the initial isomorphisms and now there are two more in another Kata that I again can't tackle myself. The first is this: ISO (Maybe b -> a) (a, b -> a). 
06:02:07 <glguy> Sh4rPEYE: What was your solution to the last one you shared with me?
06:03:06 <Sh4rPEYE> The final (joined up) isomorphism: http://lpaste.net/3718936822110224384
06:03:47 <Sh4rPEYE> I "encoded" the Unit into the list of units, thus dodging the Void.
06:04:00 <glguy> Sh4rPEYE: On line 8 you shouldn't need to write undefined. Are you getting Void from Data.Void ?
06:04:20 <Sh4rPEYE> Yes. I could use absurd, right?
06:04:23 <glguy> Yes
06:04:48 <Sh4rPEYE> I didn't know it was better that undefined, I'll change it
06:05:01 <glguy> Otherwise it's fine
06:05:41 <Sh4rPEYE> Yeah. What about the new one though? :-D 
06:06:36 <Sh4rPEYE> By the way, I feel I'm not grasping the isomorphisms well enough... I just think in terms of the type-golf, trying to fit in whatever I'm faced with. Is there any good article about them?
06:08:00 <glguy> It's just about coming up with a way to find a pairing for all the elements. There's no right answers
06:08:06 <glguy> There are just wrong ansewrs
06:08:30 <glguy> I don't know of any good article in particular, myself.
06:10:32 <glguy> Do you know about "typed holes"? It's very much a type-golf approach, but I think it would help you with solving the next one.
06:11:39 <glguy> Write out your two functions with explicit type signatures naming as many parameters as possible and set the definition to _. You'll get all the types of the local variables in the error message.
06:11:43 <Sh4rPEYE> Yes I do
06:16:49 <glguy> Can you show me what you have of that shape for this problem?
06:21:12 <xmorgan> @help
06:21:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:22:53 <xmorgan> pl \x y -> x y
06:24:03 <Sh4rPEYE> glguy: I don't have anything.
06:24:56 <xmorgan> @run 2+2
06:24:58 <lambdabot>  4
06:25:06 <Sh4rPEYE> I'd like to somehow acces the Maybe b to pattern match on it and also accest the whole function Maybe b -> a
06:25:22 <Sh4rPEYE> access*
06:26:14 <xmorgan> @run (\x -> 2*x*x + y)
06:26:16 <lambdabot>  <Expr -> Expr>
06:26:23 <glguy> Sh4rPEYE: OK, then write out as much as you can and fill in the gaps with _
06:26:29 <glguy> and then paste that
06:26:57 <xmorgan> @run [1..10]
06:26:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:27:45 <sbrg> > "just starting the line with > works too" -- xmorgan
06:27:47 <lambdabot>  "just starting the line with > works too"
06:27:59 * sbrg didn't even know about @run O.o
06:28:34 <hpc> it used to be that the '>' command was only whitelisted in channels
06:28:41 <hpc> so if you wanted to PM the bot you had to use @run
06:29:14 <Sh4rPEYE> glguy, http://lpaste.net/8178817835640815616
06:29:15 <sbrg> ah.
06:30:30 <Sh4rPEYE> The problem isn't really in the types, I know which types there should be (even without the holes). I don't know how to manipulate the given types so that I get what I want
06:31:43 <xmorgan> @run map (const 42) [0..3]
06:31:45 <lambdabot>  [42,42,42,42]
06:31:49 <hpc> Sh4rPEYE: if you have a recent enough ghc, you can put that into a file and run ghci on it, and get error messages for each of those '_'s
06:32:02 <Sh4rPEYE> Yep.
06:32:07 <hpc> Sh4rPEYE: they're rather verbose, but it tells you the type of each hole and what's surrounding it
06:32:30 <Sh4rPEYE> I use VSCode, so I have those even without running
06:32:31 <hpc> so we'll start with the middle hole because it's easiest
06:32:46 <Sh4rPEYE> Fine
06:32:47 <hpc> the type is (b1 -> a1), so right away you know it's of the form (\_ -> _)
06:33:01 <hpc> you can replace the hole with that and get a more detailed error message
06:33:33 <hpc> which unfortunately doesn't actually help on its own
06:33:58 <Sh4rPEYE> Indeed
06:34:28 <hpc> but now for your function parameter you have b, and somewhere in that scope you have (Maybe b -> a) which gives you the a you need
06:34:38 <hpc> so to pass the b to that function you need some other sort of (b -> Maybe b)
06:34:43 <hpc> :t Just
06:34:45 <lambdabot> a -> Maybe a
06:34:47 <hpc> and oh fancy that :D
06:34:50 <sproingie> does any IDE fill in type holes using, say, a menu?  was a little disappointed intero doesn't do that
06:35:44 <hpc> from there you get (\b -> mba (Just b))
06:35:47 <hpc> and the hole is filled
06:36:02 <Sh4rPEYE> Oh, I actually had it like that for a moment!
06:36:16 <hpc> now here's the funny thing
06:36:24 <hpc> the Applicative instance for Maybe has pure = Just
06:36:38 <hpc> so you can write \b -> mba (pure b)
06:36:47 <hpc> which is the same as (mba . pure), which you already had
06:37:05 <hpc> not sure why it wasn't working before though, probably something silly like a syntax error
06:37:54 <Sh4rPEYE> Exactly. The reason I discarded it was purely because I thought I'm "losing" some potention Nothings as arguments if I Just by default :-D So, technically it worked, no errors or anything
06:38:13 <hpc> you are
06:38:19 <hpc> that's what the other side of the tuple is for
06:38:35 <hpc> that hole is (mba Nothing)
06:38:39 <Sh4rPEYE> Oh, so that shoudl be mba Nothing
06:38:50 <hpc> and now you've captured the entire domain of mba
06:39:29 <Sh4rPEYE> Nice
06:39:48 <Sh4rPEYE> I'll try the g function now
06:39:51 <hpc> i think you'll be able to solve for g yourself now, yeah
06:40:02 <Sh4rPEYE> It should be easy enough. Thanks!
06:43:00 <Sh4rPEYE> Yeah, pretty clear.
06:43:08 <Sh4rPEYE> g :: (a, b -> a) -> (Maybe b -> a)
06:43:08 <Sh4rPEYE> g (a, ba) b = case b of
06:43:09 <Sh4rPEYE>     Nothing -> a
06:43:09 <Sh4rPEYE>     Just b -> ba b
06:43:51 <Sh4rPEYE> Thank you! It makes much sense
06:47:32 <hpc> :D :D :D
07:10:07 <Sh4rPEYE> hpc: Well, there's one more thing, quite a big one. You see, on line 221 is `trans` and my attitude of "let's golf through this" doesn't really work there. I don't know what the code means (I think it has some deep meaning - that it is the crucial point in understanding the whole point of Algebraic Isomorphisms). http://lpaste.net/8520479168322863104
07:14:56 <erisco> the want the point? you can't handle the point!
07:25:20 <hpc> Sh4rPEYE: that is a big one
07:25:47 <hpc> Sh4rPEYE: trans is the transitive property of isomorphisms (and if you read the type right, it looks a bit like function composition)
07:26:13 <hpc> in the case of plusS0, it's combining a few other isomorphisms that have already been defined
07:27:19 <hpc> what i suggest doing is splitting that definition up at each trans
07:27:25 <hpc> and then figuring out the type of each individual thing
07:27:40 <hpc> and then looking at how they combine when applied to trans
07:28:22 <hpc> once the types make sense, look at how trans is defined and make sure that makes sense
07:28:50 <hpc> and this is "proof-y" enough that for putting it all together i would just trust the typechecker
07:29:24 <hpc> if each part makes sense individually and they are being composed in a sane way, the resulting proof probably works too
07:50:05 <ertes> Sh4rPEYE: imagine that the ISO type includes not only the functions in both directions, but also a proof that the functions are indeed inverses of each other…  consider this a "contract" (because it's too expensive to require actual proof), much like the Monoid class has an associativity+identity contract attached to it
07:50:31 <ertes> Sh4rPEYE: so a value of type (ISO a b) is a proof that the types 'a' and 'b' are isomorphic, by contract
07:51:33 <ertes> then 'trans' takes an (ISO a b) and an (ISO b c) and construct an (ISO a c)…  remember that it too has to satisfy the contract
07:51:58 <ertes> therefore from a proof that A and B are isomorphic and B and C are isomorphic, it will construct a proof that A and C are isomorphic as well
07:53:36 <ertes> so 'trans' serves both as a logical implication and a composition function
07:56:04 <ertes> Sh4rPEYE: that's what hpc means by "‹proof-y› enough":  as programmers we agree to always respect the contract, so 'trans' has to respect it as well, and therefore we can trust that the (ISO a c) it returns is an actual isomorphism
07:57:05 <hpc> that's a better explanation
08:06:03 <Athas> torstein: here is one by the main Accelerate maintainer: https://mail.haskell.org/pipermail/haskell-cafe/2012-December/104990.html
08:06:44 <Athas> But I think the real Accelerate way is to link to some optimised matrix multiplication routine from cuBLAS or something.  That Accelerate matmult is likely to not be very fast.
08:11:07 <torstein> thanks!
08:14:29 <Sephi_> hi
08:15:39 <Athas> torstein: out of curiosity, what do you intend to use Accelerate for?
08:16:27 <Sh4rPEYE> ertes, hpc: Thanks you both :-) I need to wrap my head around it... And for today it's been already enough Haskell for me. Have a nice day!
08:16:44 <Sh4rPEYE> Thank you*... Ah, I'm tired
08:16:46 <torstein> Athas: simplex / linear programming
08:17:39 <ertes> Sh4rPEYE: yeah, let your subconscious work on it for a while =)
08:47:27 <vince881> ciao
08:47:52 <Gurkenglas_> In intero in emacs, projectile-regenerate-tags makes codex say "tagger not found.". What more do I need to do than stack install codex? Anyone got a link for that tutorial on how to set up intero & co.?
08:48:48 <codeiter> <
08:49:46 <Gurkenglas_> How do I get a more complete stacktrace than http://lpaste.net/4082146314953949184 ?
08:55:28 <sm> Gurkenglas: build with -prof -auto-all I think
08:56:39 <sm> no, it's: -prof -prof-auto
09:08:17 <Gurkenglas_> sm, http://lpaste.net/8178793139578863616
09:23:36 <sm> Gurkenglas_: stack install --profile will probably do it
09:28:14 <Gurkenglas_> hip only writes 8-bit bmps https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-IO.html#g:5 , and gloss only ready 24- and 32-bit bmps https://github.com/benl23x5/bmp/search?utf8=%E2%9C%93&q=ErrorUnhandledColorDepth&type= :C what do i do?
09:35:52 <Gurkenglas_> Can I tell stack to make a new executable each time I tell it to install instead of overwriting the old one?
09:41:03 <MitchellSalad> nope
09:42:44 <iqubic> :t view
09:42:45 <lambdabot> MonadReader s m => Getting a s a -> m a
09:42:55 <iqubic> What is that?
09:43:16 <iqubic> > view _1 ("Hello", "World")
09:43:17 <lambdabot>  "Hello"
09:43:25 <iqubic> Alright, that works
09:43:54 <iqubic> > over _1 (const "Goodbye") ("Hello", "World")
09:43:56 <lambdabot>  ("Goodbye","World")
09:44:09 <MitchellSalad> > view each ("Hello", " ", "World")
09:44:10 <lambdabot>  "Hello World"
09:44:16 <iqubic> Is there a setter operation?
09:44:21 <MitchellSalad> yeah, 'set'
09:44:31 <iqubic> So I don't have to pass (Const val) into over
09:45:10 <ongy> someone found lens?
09:45:15 <iqubic> > set _Just 5 (Just "Hello")
09:45:16 <lambdabot>  Just 5
09:45:25 <iqubic> ongy: I found lens
09:45:30 <iqubic> https://www.youtube.com/watch?v=cefnmjtAolY
09:45:34 <MitchellSalad> You found this? I found this.
09:45:46 <iqubic> And an Edward Kmett video explaining them real well.
09:46:16 <iqubic> Edward Kmett is the best Haskeller around.
09:47:13 * mrkgnao wishes he had an "Oleg did it first" tee to make things interesting
09:47:21 <erisco> import Haskeller.Ekmett; main = ekmett;
09:47:28 <mrkgnao> Okay, does anyone here understand Tisch well?
09:48:04 <MitchellSalad> mrkgnao: never used it but I read and understood the introductory blog post... AMA
09:48:22 <tomzz> Got a new question about structuring a project: I got an adt called "state" in the main program. this state consists of datatypes from submodules which are imported. When i pass "state" to the submodules, im not able to access the fields because all accessor fcns are not know to the submodules. importing main would result in cyclic import. My first idea was to move the definition of "state" into a file 
09:48:28 <tomzz> like "MyTypes.hs" but then again i would need to also move all types that are defined in submodules into "MyTypes.hs". But i'm not sure if i want that. Do you know of any other solution? Like importing only datatypes from a file, to avoid cyclic import error?
09:48:44 <mrkgnao> I've managed to coax it into talking to pg and doing a couple inserts and selects.
09:49:10 <tomzz> that turned out long
09:49:36 <mrkgnao> tomzz: a Foo.Bar.Types module is pretty common actually
09:49:44 <MitchellSalad> tomzz... are you thomas W? :)
09:50:06 <tomzz> MitchellSalad: no : )
09:50:07 <mrkgnao> MitchellSalad: I'm looking for a nontrivial code example, actually.
09:50:23 <MitchellSalad> mrkgnao: an example of something in particular?
09:51:59 <mrkgnao> nothing I can put a finger on, just wishing for bigger examples, or maybe a Pipes/Lens-like tutorial. the Tisch tutorial only does a bunch of SELECT ... FROM ... WHERE ... queries.
09:53:04 <tomzz> mrkgnao: k, than ill try to make a types file for every submodule, to keep stuff separated. thanks!
09:53:51 <mrkgnao> tomzz: yeah, try not to fragment things too much. having to write 20 lines of local imports at the top of every file is no fun. :)
09:54:40 <tomzz> good point
09:54:42 <mrkgnao> MitchellSalad: it's in a very trifecta-like state now, only worse
09:54:48 <erisco> eh, I use explicit imports anyways so 20 lines is nothing
09:55:02 <cocreature> mrkgnao: meaning the error messages are awesome? :)
09:55:17 <erisco> I am 34 lines of imports in a 134 line toy atm
09:55:56 <erisco> though I generally put one per line too
09:55:57 <mrkgnao> cocreature: I have type-safetied myself into a corner where I've been hacking with this library I barely understand for the whole evening and haven't triggered any errors. 
09:56:23 <mrkgnao> so, vacuously, yes
09:56:30 <erisco> explicit imports are more future-proof and also is a little note of where everything came from
09:56:39 <erisco> I don't have an IDE that tells me this readily
09:56:53 <erisco> and Hoogle/Yahoo/whatever are not complete
09:56:56 <MitchellSalad> mrkgnao: again I'm happy to help if only I knew what your problem was!
09:57:28 <mrkgnao> erisco: yes, I prefer them too. I was cautioning against having a .Types module for every module instead of the bare minimum necessary to break import cycles.
09:57:49 <erisco> oh, I see
09:58:37 <erisco> if you look at most modules they are organised by their API
09:58:41 <mrkgnao> MitchellSalad: I don't have any specific problems (right now). I just really want to read a long .lhs file :) 
09:59:05 <erisco> to use the API you will need the types and the functions, so those are generally put together
09:59:05 <mrkgnao> thanks for offering to help. I will report after invariably having confused myself in a while.
09:59:34 <MitchellSalad> ok :)
10:00:10 <erisco> then for what two sub-APIs share there is a third module they both import
10:00:48 <erisco> and then sometimes a .Core or .Internal module or modules if there is a lot of busywork to make the API work
10:02:07 <erisco> in OOP you organise by class, but keep in mind that most of the functions you use on the type are methods of the class
10:02:19 <mrkgnao> MitchellSalad: okay, I have a question. suppose I have some table Foo with, um, let's say two Int32 columns for simplicity.
10:02:54 <mrkgnao> now I know how to get each column value out, but I find myself wanting a Haskell representation of the rows.
10:03:30 <MitchellSalad> can you make a code snippet for me to start with?
10:04:03 <mrkgnao> sure. one moment.
10:05:04 <mrkgnao> http://lpaste.net/356329
10:05:57 <tomzz> erisco: thanks! i think i need to try the MyTypes.hs approach. the example i wanted to build on is much better isolated, thats why they can have local types in every submodule.
10:06:52 <mrkgnao> so should I write a new HsKnot record type (with KnotId and CreationTime fields) and write functions for HsR Knot -> HsKnot? seems awfully boilerplatey in comparison to the painless treatment of the newtypes
10:08:28 <MitchellSalad> mrkgnao: one moment, building the library. (someone just pushed a broken commit to master 6 minutes ago!)
10:09:21 <MitchellSalad> mrkgnao: Lib.Prelude? :)
10:09:33 <erisco> tomzz, you can organise another way and still come up with "here is the API" by using re-exporting
10:09:47 <MitchellSalad> mrkgnao: can you make a self-contained snippet?
10:10:10 <erisco> also common is for a package to re-export the most likely things you want in the base module
10:10:53 <erisco> you can read some modules and all they are are re-exports
10:12:55 <erisco> part of this is just from the antiquated concept of code in files
10:13:07 <erisco> probably won't ever get rid of it
10:13:28 <mrkgnao> MitchellSalad: not right now, no. I guess I'll ping you later if that's fine.
10:14:02 <mrkgnao> yeah, that's what I'm used to from the protolude template for stack init. 
10:14:05 <erisco> files impose order and adjacency whether it makes sense or not
10:14:20 <mrkgnao> erisco: lazy imports ftw
10:14:46 <erisco> and they're linear so you cannot represent all the logical adjacencies
10:15:08 <mrkgnao> MitchellSalad: will ping you in about 30 min if you
10:15:14 <mrkgnao> you're online*
10:15:17 <erisco> and because of how we read and write them we don't like them to get too big because it is annoying to scroll through it all
10:15:30 <MitchellSalad> mrkgnao: sure thing
10:15:37 <erisco> and the way build systems work is tied directly to files
10:16:00 <erisco> so, it is a quagmire we are born of and must now live in
10:16:19 <monochrom> I saw a concept graphical IDE that put each function (or class?) on its own sticky note, you freely move them around on your screen.
10:16:36 <erisco> yeah there are some people experimenting with ideas... one I saw was called "Code Bubbles"
10:17:08 <monochrom> (Also, you choose which ones to be present on screen at all.)
10:17:45 <Ulrar> Silly question, I have a list with objects, I want to apply a function to those objets. Sounds just like map, except I also want to filter those objects to remove some of them
10:17:57 <Ulrar> Is there a way to do both at the same time, or should I filter then map ?
10:18:32 <Ulrar> (I imagine there must be a way to do both at the same time, to avoid going through the list twice)
10:19:30 <manek> Hello guys! Is there any way to print yaml representation of a datatype as a single-line compact yaml using ny yaml processingl ibrary in haskell? Maybe im missing something but as I understand all libraries (like the yaml one) print yaml as multiline one :(
10:19:32 <monochrom> To reduce your work, just filter and map. (Order depends on what you actually want.)
10:20:13 <Ulrar> So there is no mapFilter function, where you could give both a predicate and a function to apply if that predicate matches
10:20:19 <Ulrar> Guess I'll code it myself then
10:20:22 <kuribas> is there a way to reduce Storable boilerplate?
10:20:41 <monochrom> Code optimization is highly likely to eliminate the intermediate list.
10:21:09 <Ulrar> monochrom: You mean I'd have filter then map, but the binary wouldn't ?
10:21:16 <monochrom> Right.
10:21:22 <Ulrar> Ah, well that's good
10:22:55 <monochrom> kuribas: Some of those hsc2hs, c2hs, etc may be able to write the code for you.
10:22:58 <barrucadu> Ulrar: There's mapMaybe
10:23:07 <barrucadu> Which isn't quite what you want
10:23:11 <barrucadu> But is pretty close
10:23:15 <kuribas> monochrom: also with code involving the C++ stl?
10:23:24 <monochrom> Ah, probably not.
10:23:26 <erisco> Ulrar, foldMap can be your mapFilter
10:24:15 <monochrom> I think we take the stance of "won't touch C++, you're just supposed to extern"C" and expose a C binding" :)
10:24:24 <erisco> > foldMap (\x -> if x `mod` 2 == 0 then [x * x] else []) [1..10]
10:24:26 <lambdabot>  [4,16,36,64,100]
10:24:39 <Ulrar> mapMaybe seems perfect, as I understand it
10:24:46 <Ulrar> why do you think it's not quite what I want barrucadu ?
10:24:50 <MitchellSalad> erisco: won't that ++ ten singleton lists?
10:25:05 <erisco> I don't think about such things :P
10:25:11 <kuribas> monochrom: that's what I did, but it takes a lot of boilerplate.  I suppose I could use c2hs into the extern c code though...
10:25:19 <monochrom> yeah
10:26:01 <erisco> > foldMap f [a,b,c]
10:26:03 <lambdabot>  error:
10:26:03 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M241750060752...
10:26:03 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
10:26:34 <erisco> hrm, I don't know what the type needs to be, can't remember
10:27:20 <geekosaur> > foldMap f [a,b,c] :: Expr
10:27:22 <lambdabot>  f a <> f b <> f c <> mempty
10:27:24 <erisco> but anyways, I think it is right-associative, so you'll get f a ++ (f b ++ (f c ++ [])))
10:28:41 <erisco> (<>) is right-associative, so yes
10:29:49 <erisco> > (catMaybes .) . foldMap
10:29:51 <lambdabot>  error:
10:29:51 <lambdabot>      • No instance for (Typeable a0)
10:29:51 <lambdabot>          arising from a use of ‘show_M339357287399592480129325’
10:29:51 <erisco> :t (catMaybes .) . foldMap
10:29:53 <lambdabot> Foldable t => (a1 -> [Maybe a]) -> t a1 -> [a]
10:30:08 <erisco> oh, right
10:30:26 <erisco> :t (catMaybes .) . foldMap . ((:[]) .)
10:30:28 <lambdabot> Foldable t => (a1 -> Maybe a) -> t a1 -> [a]
10:30:54 <erisco> :t mapMaybe
10:30:55 <lambdabot> (a -> Maybe b) -> [a] -> [b]
10:31:12 <erisco> I'll call that a win
10:31:38 <mrkgnao> MitchellSalad: ping
10:31:41 <MitchellSalad> pong
10:31:53 <mrkgnao> http://lpaste.net/356329
10:32:27 <barrucadu> Ulrar: Because I imagine a map-with-filter would be used like "mapFilter p f xs", whereas mapMaybe would be used like "mapMaybe (\x -> if p x then Just (f x) else Nothing) xs"
10:32:34 <barrucadu> It's a bit more verbose
10:33:18 <erisco> (a -> Bool) -> (a -> b) -> (a -> Maybe b)   is implementable
10:33:40 <MitchellSalad> mrkgnao: cool. so what's the problem?
10:33:51 <erisco> (a -> b) -> (b -> Bool) -> (a -> Maybe b)   or the other one
10:34:03 <erisco> the nice thing about (a -> Maybe b) is it is both of those :)
10:34:05 <Ulrar> barrucadu: Yeah, but it seems to work fine
10:34:15 <erisco> (proven by both the above being implementable!)
10:34:16 <Ulrar> I was trying it, looks okay
10:34:27 <Ulrar> So, thanks :)
10:34:33 <mrkgnao> I think I'll want to have a Haskell representation of the Knot type. Something like data HsKnot = HsKnot KnotId CreationTime.
10:35:06 <mrkgnao> is there an idiomatic way to derive it from the table spec or type/data instances, or do I have to roll my own? 
10:36:33 <MitchellSalad> hmm...
10:37:17 <MitchellSalad> well, and is HsR not this Haskell representation of the Knot type already?
10:37:36 <mrkgnao> (because the situation with the new types is Very Good)
10:37:39 <mrkgnao> um
10:38:39 <monochrom> Wait, a knot is just an ID and a creation time?!
10:40:14 <mrkgnao> monochrom: I didn't want to name the table Foo. The real thing is anyway not the math kind though, it's a pretty dumb name for something else.
10:40:28 <monochrom> Ah
10:40:46 <mrkgnao> MitchellSalad: the HsR Knot type is hard to work with, you have to use lenses
10:40:53 <mrkgnao> wait, that's what I would've done anyway
10:41:01 <mrkgnao> huh
10:41:58 <mrkgnao> monochrom: I'm actually figuring out how to talk to the DB right now. :)
10:42:37 <MitchellSalad> right, use lenses or its Generic interface
10:45:09 <MitchellSalad> nvm, its Generic instance is just for the newtype
10:46:10 <MitchellSalad> that Generic instance looks wrong, it is predicated on Generic for Record
10:46:28 <MitchellSalad> which can't exist since Record is a GADT
10:48:50 <mrkgnao> MitchellSalad: thanks!
10:49:01 <qmm> how do you reverse a tuple?
10:49:17 <qmm> is there a common method for getting the last item in a tuple?
10:50:18 <monochrom> If it's 2-tuple, there are "swap" and "snd", respectively.
10:50:23 <qmm> it isn't
10:50:36 <geekosaur> qmm, it sounds to me like you are using tuples when you shouldn't be
10:50:40 <monochrom> There is nothing for others. Extremely rare use-case.
10:50:43 <geekosaur> there is no such idiom nor can there be
10:50:51 <geekosaur> a tuple is not a funny-looking list
10:51:08 <cocreature> > lastOf each (1,2,3,4)
10:51:10 <lambdabot>  Just 4
10:51:17 <MitchellSalad> > lastOf each (1, 'a')
10:51:18 <lambdabot>  error:
10:51:18 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
10:51:18 <lambdabot>      • In the expression: 1
10:51:20 <MitchellSalad> =P
10:51:44 <geekosaur> heh, even lens can't generalize it :p
10:52:07 <MitchellSalad> you could generalize it with type families
10:52:43 <monochrom> "This is not the data structure you're looking for"
10:54:47 <qmm> :)
10:54:54 <Ulrar> So I have a type that I use only with ToJSON, so I never directly use it's accessors. Is there a way to disable the warnings "defined but not used" for those accessors ?
10:55:20 <qmm> it is a sequence of items which do not have the same type, so i thought a sequence would be appropriate
10:55:44 <qmm> i need a function which takes two sequences of items where the items aren't all the same type, and i need to append them to make one sequence
10:55:48 <geekosaur> Ulrar, start their names with an underscore
10:56:02 <geekosaur> otherwise, limiting the scope of warnings is a work in progress
10:56:04 <Ulrar> geekosaur: That works but then I get an _ in the names on the generated JSON
10:56:08 <qmm> so i thought a tuple would be appropriate, sorry*
10:56:24 <geekosaur> qmm, but a tuple is not a list and can't be accessed like one
10:57:08 <qmm> ok
10:57:33 <qmm> is there a data type besides a tuple which holds items that aren't the same type 
10:57:43 <monochrom> If you have a 10-tuple, say, and you frequently ask for its last item, that's fair, but by then you usually will have made your own named record type, so "last" is just one of your field accessors.
10:58:08 <monochrom> But if you start saying "the length varies" then it gets awkward.
10:58:17 <cocreature> there are hlists but most of the time you can and should avoid them
10:58:52 <Ulrar> Guess I'll have to define the ToJSON implem myself then
10:59:05 <MitchellSalad> yeah, here's what becomes of your poor append function... 'HList xs -> HList ys -> HList (Append xs ys)'. the complexity is better to avoid 99% of the time
10:59:12 <geekosaur> Ulrar, I think there are TH helpers that can do things like stripping underscores
10:59:21 <qmm> cocreature: i'm modeling a domain as accurately as i and others know how, and i'm trying to follow best practice, really. thank you all for giving me input on best practice!
10:59:31 <Ulrar> geekosaur: I have no idea how templating works, though :/
10:59:57 <cocreature> qmm: if you give us a bit more detail we might be able to explain how you can avoid having to use heterogenous lists
11:00:24 <ph88^> hello
11:00:38 <cocreature> qmm: it’s definitely possible that they are the right solution for your problem but most of time I’ve seen people ask for something like that, there is a better solution so I’m cautious in recommending their usage
11:00:51 <ph88^> how can i fill a vector with numbers like i would do with list [3 .. 50]  ?
11:01:12 <cocreature> :t Data.Vector.enumFromTo
11:01:13 <lambdabot> Enum a => a -> a -> Data.Vector.Vector a
11:01:16 <cocreature> ^ ph88^ 
11:01:40 <cocreature> V.fromList [3..50] probably gets optimized to the same code
11:02:18 <geekosaur> Ulrar, http://hackage.haskell.org/package/aeson-1.2.1.0/docs/Data-Aeson-TH.html $(deriveJSON defaultOptions {fieldLabelModifier = drop 1})
11:02:32 <geekosaur> oh, no, other one actually
11:02:47 <ph88^> enumFrom looks good to me
11:03:25 <geekosaur> $(deriveJSON defaultOptions {constructorTagModifier = dropWhile (== '_')} ''TheType)
11:03:36 <Ulrar> Ah, good to know
11:03:38 <Ulrar> Thanks !
11:03:42 <Ulrar> Missed that one
11:03:44 <geekosaur> so if it has leading _ then they get dropped when constructing the field name
11:07:37 <buggerme> Hi all. I asked a question earlier about adding namespace declarations to XML documents using HXT but didn't receive an answer. I have solve the problem myself using attachNsEnv. Here is an example if this is any use to anyone here: runX $ root [] [mkElement (mkQName "prefix" "name" "namespace
11:08:35 <buggerme> Hi all. I asked a question earlier about adding namespace declarations to XML documents using HXT but didn't receive an answer. I have solve the problem myself using attachNsEnv. Here is an example if this is any use to anyone here: runX $ root [] [mkElement (mkQName "prefix" "name" "namespace") none none) >>> attachNsEnv (toNsEnv [("prefix", "namespace")] >>> writeDocument [] ""
11:08:57 <ph88^> thx buggerme 
11:10:13 <ph88^> i want to do a fold. On each step i need to do a calculation with one intermediate step a to b to c. The result of the fold should be a list of c's. How can i access the b of the last iteration?
11:11:07 <nimo> Hi all, I am building an graphing app that uses Gloss as the front end, but recently I wanted to migrate the front end to some SVG library in JS, such as Snap.svg. I have heard GHCJS can allow a Haskell program to call JS functions. Anybody familiar with GhsJS, or have any other suggestions? Thanks!
11:12:03 <erisco> ph88, one sec
11:12:33 <erisco> ph88, a paramorphism
11:12:48 <ph88^> ^^
11:13:51 <erisco> ph88, with a paramorphism you have access to the last c and a, and since you have an a -> b you can get b again
11:14:15 <ph88^> calculating a -> b  is very expensive
11:15:09 <geekosaur> > foldr (\x (r,l) -> (r + x - l,x)) (z,z) [a,b,c,d] :: (Expr,Expr)
11:15:11 <lambdabot>  (z + d - z + c - d + b - c + a - b,a)
11:15:22 <erisco> does b have a zero?
11:15:57 <ph88^> b :: Data.Vector.Unboxed (Double, Double)
11:16:01 <erisco> if not you can add one as Maybe b
11:16:15 <erisco> then you can accumulate a tuple instead
11:17:02 <erisco> the zero is not always necessary but it is for lists
11:17:03 <ph88^> and replace one part of the tuple ?
11:17:17 <erisco> depends on what the constructors are for the type
11:17:25 <ph88^> which type ?
11:17:32 <erisco> the one you are folding
11:17:49 <ph88^> [Int]
11:18:18 <geekosaur> > foldr (\x (r,l) -> (r + x - l,x)) (z,y) [a,b,c,d] :: (Expr,Expr)
11:18:20 <lambdabot>  (z + d - y + c - d + b - c + a - b,a)
11:18:24 <iqubic> Can we write foldl using only foldr? I think that's possible, but I don't know how it works
11:18:48 <erisco> say for lists, then  foldr (\x (acc, b) -> case b of Just b' -> ...; Nothing -> ...) (accZero, Nothing)
11:18:59 <ph88^> why foldr not foldl ?
11:19:05 <erisco> whatever you want
11:19:09 <cocreature> iqubic: yep you can. use your favorite search engine to find out how :)
11:19:14 <ph88^> foldl is faster, no ?
11:19:21 <erisco> no
11:19:24 <cocreature> if anything you want foldl'
11:19:25 <erisco> it is different :)
11:19:36 <ph88^> i was planning on using foldl1'
11:19:51 <iqubic> Why does the order of folding matter?
11:20:03 <iqubic> Is it because a <> b /= b <> a?
11:20:05 <ph88^> so i need to  fmap Just myList   first ?
11:20:11 <iqubic> :t toList
11:20:12 <lambdabot> error:
11:20:12 <lambdabot>     Ambiguous occurrence ‘toList’
11:20:12 <lambdabot>     It could refer to either ‘F.toList’,
11:20:14 <erisco> no
11:20:17 <juri_> because lazy evaluation.
11:20:28 <iqubic> And thunks and such
11:20:49 <erisco> :t foldl1'
11:20:50 <lambdabot> (a -> a -> a) -> [a] -> a
11:21:17 <erisco> so your b and c were terms, not types, i.e. b :: a and c :: a ?
11:21:17 <ph88^> that won't work for what you were just telling me
11:21:30 <cocreature> iqubic: it’s because (a <> b) <> c is not always the same as a <> (b <> c)
11:21:45 <ph88^> eh ye i think they were terms
11:22:05 <erisco> cocreature, though I hope it is =\
11:22:06 <sproingie> <> should be associative, it's not necessarily commutative.  string concatenation for instance.
11:22:33 <erisco> perf is certainly not always the same
11:22:35 <ph88^> (\a -> let b = doCalc1 input; let c = doCalc2 a; in c)
11:22:35 <sproingie> (matrix multiplication for another)
11:22:38 <cocreature> erisco: well it definitely isn’t for all <>
11:22:45 <cocreature> well I guess I shouldn’t be using <> here
11:22:57 <cocreature> I was thinking of <> as an abstract binary operation, not Data.Monoid or Data.Semigroup
11:23:04 <erisco> ah
11:23:16 <erisco> was wondering how we already knew we were using <>
11:23:55 <ph88^> erisco, how must i not   fmap Just myList   when you input Nothing ?
11:24:06 <erisco> ph88^, well I don't know... you need to get your types sorted out and what folding function you are using
11:24:11 <erisco> otherwise I don't know what you're trying to do
11:24:29 <erisco> look again, it was a tuple
11:24:33 <sproingie> if your folding operation isn't associative, you're not going to have a good day with it
11:25:27 <ph88^> erisco, ye the snd item of the tuple
11:25:53 <cocreature> sproingie: yeah, things that are not associative suck :)
11:26:01 <erisco> :t \f z -> foldr f (z, Nothing)
11:26:02 <lambdabot> Foldable t => (a1 -> (t1, Maybe a) -> (t1, Maybe a)) -> t1 -> t a1 -> (t1, Maybe a)
11:27:25 <ph88^> right ^^
11:28:31 <ph88^> :t \f z -> foldl' (z, Nothing)
11:28:32 <lambdabot> error:
11:28:32 <lambdabot>     • Couldn't match expected type ‘b -> a -> b’
11:28:32 <lambdabot>                   with actual type ‘(t1, Maybe a0)’
11:28:42 <ph88^> :t \f z -> foldl' f (z, Nothing)
11:28:43 <lambdabot> Foldable t => ((t1, Maybe a1) -> a -> (t1, Maybe a1)) -> t1 -> t a -> (t1, Maybe a1)
11:28:56 <ph88^> ok i try it
11:30:16 <tsmish> config :: Reifies s Int => (Proxy s, Int)
11:30:16 <tsmish> config = let p = Proxy :: Proxy s0 in (p, reflect p)
11:30:27 <ph88^> erisco, what about if i do the first calculation outside of the fold ? then i don't need to branch inside on the Maybe value
11:30:35 <tsmish> Why doesn't ghc know that s0 ~ s?
11:30:49 <erisco> how are you going to do that without an element of the list?
11:31:07 <erisco> and it isn't "outside" the fold, the zero is part of the fold, that is the empty list case
11:31:08 <ph88^> i get the first element of the list and then pass the tail to the fold
11:31:30 <erisco> then you have nothing for the empty list
11:31:55 <ph88^> i think i will  error  on empty list
11:32:48 <erisco> then sure, go for it
11:35:46 <ph88^> erisco, what's the  z   in   (z, Nothing)  ?
11:36:10 <erisco> whatever you want it to be when the list is empty
11:36:39 <erisco> > foldr (+) 0 [1..5]
11:36:41 <lambdabot>  15
11:36:48 <erisco> > foldr (+) 0 []
11:36:50 <lambdabot>  0
11:36:58 <MitchellSalad> tsmish: because s isn't s0 =P
11:37:07 <erisco> > foldr f z [a,b,c] :: Expr
11:37:07 <ph88^> eh maybe i don't want a fold then ..
11:37:09 <lambdabot>  f a (f b (f c z))
11:37:17 <ph88^> if my list is length 15 i want 15 answer back
11:37:24 <ph88^> but with map i can not get the value from the last iteration
11:37:27 <cocreature> :t scanl -- ph88^ 
11:37:28 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
11:37:36 <OS-16011> hello fellow internet addicts, are we all looking forward to another long & glorious day of irc & internet browsing?
11:37:47 <cocreature> > scanl (+) 0 [0,1,2,3]
11:37:49 <lambdabot>  [0,0,1,3,6]
11:38:16 <ph88^> what about i put [] for z and then put the list in the fst of the tuple ?
11:38:22 <erisco> I don't know then. I need more information about the problem you're trying to solve
11:38:59 <erisco> well, lets not get too wild with guessing :P have some rationale
11:39:08 <tsmish> MitchellSalad, why? Judging by signature p has type Proxy s.
11:40:01 <ph88^> erisco, i'm trying to speed this up https://bpaste.net/show/1f4255d0ce23 i already thought of a new algorithm ^^
11:41:07 <MitchellSalad> tsmish: no, 'p' has the type 'Proxy s0' because that's the type you ascribed
11:41:34 <erisco> good, implement that one then
11:42:36 <erisco> the first objective of efficiency is to do less work
11:42:47 <erisco> and the second is to do the necessary work better
11:42:55 <tsmish> MitchellSalad, As I understand it, s is the only candidate for s0, because e
11:43:02 <tsmish> sorry.
11:43:36 <geekosaur> the very fact that you named the type told the compiler to not consider that possibility
11:44:02 <geekosaur> 'this is some unspecified type s0, different from the types you already know about'
11:44:07 <MitchellSalad> (though inference won't help either)
11:44:24 <monochrom> No, I think it's the other way round.
11:44:34 <MitchellSalad> you'll have to both ascribe the type 'Proxy s' and turn on ScopedTypeVariables, tsmish
11:44:42 <ph88^> map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs
11:45:18 <tsmish> I know. I tried to write it without ScopedTypeVariables. Is it possible? 
11:45:28 <MitchellSalad> nope! it's not
11:45:31 <cocreature> ph88^: foldr (\x acc -> f x : acc) [] xs will probably be better
11:45:32 <monochrom> You have coded "p :: forall s0. Proxy s0". But it is not "p :: forall s0. Reifies s0 Int => Proxy s0". Therefore, you can't use reflect on p.
11:46:03 <ph88^> cocreature, i would reverse the input list to iterate over the values in the same order, no ?
11:46:23 <cocreature> ph88^: no, try it out :)
11:46:39 <ph88^> but isn't foldr slow ?
11:46:40 <monochrom> No, I don't understand why what I said either. Nevermind.
11:46:42 <cocreature> > foldl (\acc x -> acc ++ [x]) [] [1,2,3,4]
11:46:43 <lambdabot>  [1,2,3,4]
11:46:51 <erisco> eh, not "order", but "associativity"
11:46:52 <monochrom> But you are supposed to use ScopedTypeVariables, yes.
11:46:55 <cocreature> > foldr (\x acc -> x : acc) [] [1,2,3,4]
11:46:57 <lambdabot>  [1,2,3,4]
11:46:59 <MitchellSalad> monochrom: what you said made sense
11:47:02 <cocreature> ph88^: no, why should it?
11:47:11 <cocreature> ph88^: in fact it will be significantly faster in this case
11:47:15 <glguy> tsmish: yeah, config can be implemented without scoped type variables
11:47:19 <ph88^> because you go from right to left or left right on a linked list
11:47:21 <cocreature> ph88^: repeatedly appending single elements is really slow
11:47:40 <erisco> you don't "go", you "associate"
11:47:51 <cocreature> ph88^: you might want to implement foldl and foldr yourself to see how you don’t need to walk all the way right first before you start
11:48:16 <iqubic> > foldr (\acc x -> acc ++ [x]) [] [1,2,3,4]
11:48:18 <lambdabot>  error:
11:48:18 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ [t]
11:48:18 <lambdabot>        Expected type: [t]
11:48:21 <erisco> I think being picky here might help you think about it better
11:48:26 <cocreature> if you can start lazily producing results such as in the case that I just showed you (lazily producing a list), foldr is almost always the right choice
11:48:33 <iqubic> > foldr (\acc x -> acc : [x]) [] [1,2,3,4]
11:48:35 <lambdabot>  error:
11:48:35 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ [t]
11:48:35 <lambdabot>        Expected type: [t]
11:48:50 <iqubic> > foldr (\x acc -> acc : [x]) [] [1,2,3,4]
11:48:50 <cocreature> foldl is great if you have constant size accumulators where you can’t lazily produce parts of them
11:48:51 <lambdabot>  error:
11:48:52 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ [t]
11:48:52 <lambdabot>        Expected type: [t]
11:49:01 <cocreature> but then you also really want foldl' and not foldl
11:49:20 <MitchellSalad> glguy: oh... it can?
11:49:29 <ph88^> oh it's the other way around as i thought, foldl goes from right to left, and foldr from left to right ^^
11:49:38 <glguy> config = case Proxy of p -> (p, reflect p)
11:50:02 <ph88^> https://bpaste.net/show/9726e56a8f78
11:51:03 <MitchellSalad> oh... right, he's returning the proxy
11:51:20 <glguy> tsmish: ^
11:52:16 <cocreature> ph88^: that’s more due to lazyness. if you use foldl' they will both print your debug statements front to back
11:52:45 <tsmish> glguy: wow. Another question. Why case works, but let doesn't? 
11:52:53 <ph88^> o_O
11:52:58 <glguy> tsmish: Because let generalizes types
11:53:17 <MitchellSalad> let-polymorphism
11:53:49 <ph88^> what's the difference between foldr and foldl' other than the arguments are swapped in the callback ?
11:54:12 <monochrom> Ah, if p is polymorphic, then (p, f p) the two p's do not have to have the same type.
11:54:23 <cocreature> > foldr f a [b,c,d]
11:54:25 <lambdabot>  f b (f c (f d a))
11:54:26 <MitchellSalad> the strictness that the function is applied at, and also the order the elements are traversed
11:54:28 <cocreature> > foldl f a [b,c,d]
11:54:30 <lambdabot>  f (f (f a b) c) d
11:54:35 <cocreature> ph88^: does that help?
11:54:39 <tsmish> Thanks, everyone.
11:54:40 <monochrom> Sometimes, some other context can force them to, but don't take it for granted.
11:54:48 <ph88^> no, you use foldl, i was talking about foldl'
11:55:01 <cocreature> that only changes lazyness vs strictness
11:55:09 <ph88^> > foldl' f a [b,c,d]
11:55:10 <lambdabot>  f (f (f a b) c) d
11:55:11 <cocreature> if foldl and foldl' both produce a result it will always be the same
11:56:21 <monochrom> Relatedly IIRC irrefutable pattern can do this to you too.
11:57:41 <monochrom> Ah nevermind, not about irrefutable pattern.
11:58:12 <MitchellSalad> irrefutable pattern = lazy pattern?
11:58:13 <monochrom> What I had in mind is "let (x,y) = ..." x and y are individually generalized, not in sync.
11:58:17 <monochrom> Yeah.
11:58:28 <monochrom> http://lpaste.net/352302
11:59:21 <monochrom> So for example if you write so much as "(x,y) = divMod 0 1" and kill DMR, you can very well use x for Int, y for Word.
11:59:50 <monochrom> The downsides is that if you assume that x and y have to have the same type, you lose.
12:00:13 <MitchellSalad> huh? you can't use x for Int and y for Word
12:00:36 <monochrom> You have to kill DMR to see this.
12:00:53 <MitchellSalad> what's DMR?
12:00:54 <glguy> well
12:00:55 <ph88_> is the only difference between foldl' and foldr that the arguments are swapped of the callback ?
12:00:55 <glguy> > let (x,y) = divMod 16 5 in (x :: Word, y :: Int)
12:00:57 <lambdabot>  (3,1)
12:01:01 <glguy> You don't have to disable MR to use it like that
12:01:10 <glguy> just to get a polymorphic type
12:01:36 <MitchellSalad> huh, I don't understand how that works
12:01:40 <monochrom> :)
12:01:44 <MitchellSalad> what is the type of '16' and '5' there?
12:01:50 <glguy> Num a => a
12:02:10 <MitchellSalad> and so the result is (Num a, Integral a) => (a, a), no?
12:02:24 <monochrom> No! That's the point.
12:02:36 <glguy> Well, kind of, the expression has that type
12:02:41 <glguy> but x and y don't
12:02:50 <monochrom> "by a very careful reading of the Haskell report"
12:03:17 <MitchellSalad> x, y :: Integral a => a, then?
12:03:28 <monochrom> Yes, but that's self-misleading.
12:03:49 <MitchellSalad> it is? I mean as a polytype
12:03:59 <MitchellSalad> x, y :: forall a. Integral a => a
12:04:08 <cocreature> ph88_: I really recommend that you try implementing foldl and foldr yourself. it’s not too hard but it makes it very clear how they are different
12:04:16 <monochrom> If I write "id, me :: a->a", henceforth the way I use id can divorce from the way I use me.
12:04:36 <MitchellSalad> yes, I just wrote two type sigs on one like
12:04:40 <MitchellSalad> *line
12:04:58 <monochrom> It also does not help that I used one single equation with a pattern binding "(id, me) = ..." to define them early.
12:05:04 <glguy> Oh, and I was just wrong, actually
12:05:12 <monochrom> They just get divorced. They will be.
12:05:19 <glguy> still need to turn off mr
12:05:35 <MitchellSalad> hm, I don't understand how 'divMod (16 :: Num a => a) (5 :: Num a => a)' returns '(x :: Num a => a, y :: Num a => a)'
12:05:45 <MitchellSalad> er, s/Num/Integral
12:06:03 <MitchellSalad> oh, okay now I see it 
12:06:10 <MitchellSalad> haha
12:06:10 <monochrom> I think I explained it in my paste.
12:06:16 <MitchellSalad> but is it not an impredicative type?
12:06:17 <Tuplanolla> The computation needs to be carried out twice, no?
12:06:32 <glguy> Yes, twice
12:06:43 <cocreature> ph88_: playing around with using non-associative operations for the function passed to foldl'/foldr will also help see the difference, e.g. try (-)
12:06:56 <monochrom> No, I don't think the type inference process considers (forall a. Num a => a, forall b. Num b => b) ever.
12:07:41 <monochrom> The type inference algorithm just needs to ask itself: "OK what's x's type now?", "OK what's y's type now?", separately. Never needed to consider the tuple's type.
12:07:47 <MitchellSalad> oh. so you could not return x,y with polytypes
12:07:52 <monochrom> Err, no I'm saying it wrong.
12:07:54 <MitchellSalad> you could only instantiate them locally
12:08:11 <monochrom> See my paste. I say it right there.
12:09:01 <monochrom> There is a stage of type inference without forall. Then there is a stage of adding forall.
12:10:10 <Guest23564> look my blog http://casamoney.it and earn money in page Power information.
12:10:14 <monochrom> The first stage may still consider (t, t) with Num t. But this is a stage of no forall. That t is monomorphic (for the moment). Not impredicative here.
12:10:39 <ph88_> cocreature, how can it be that at a foldr it goes like  1 - (2 - (3 - (4 - 0)))  but still it iterate list from 1 to 4 ? 4 is needed first to calculate (4 - 0)
12:10:49 <ph88_> @src foldr
12:10:49 <lambdabot> foldr f z []     = z
12:10:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:11:11 <monochrom> Then the second stage goes "oh look no one nails t, I can slap a forall on it". But it only does this to x, and to y, but never to (x,y) as a whole. So, still no need to be impredicative.
12:11:57 <cocreature> ph88_: it doesn’t immediately calculate 4-0. it just recurses and passes the result of that recursion as the second argument to f or (-) in your example
12:12:21 <cocreature> ph88_: now if you replace (-) by (:) you also immediately see how foldr is able to lazily produce results
12:12:38 <geekosaur> ph88, it goes 1 - "oh I need to recurse" 2 - "oh I need to recurse" 3 - "oh I need to recurse" 4 - 0 "pop/finish" "pop/finish" "pop/finish"
12:13:20 <ph88_> cocreature, after recursing to 4-0 .. it still needs to recurse back to calculate the rest ?
12:14:31 <geekosaur> yes because the 4-0 gives it what it needs to finish the 3-* which gives it what it needs to finish 2-*...
12:14:41 <cocreature> ph88_: if you start forcing "foldr (-) 0 [1,2,3,4]" it will look at the definition and evaluate to "1 - foldr (-) [2,3,4]"
12:14:47 <cocreature> but that’s still not the whnf of an Int
12:15:02 <ph88_> for 1..3:    1-(?), 1-(2-(?)), (1-(2-(3-0))), 3-0 = 3, 2 - 3 = -1, 1 - - 1 = 1  .. looks like 6 steps to me
12:15:22 <MitchellSalad> monochrom: that's a great paste
12:15:27 <monochrom> :)
12:15:40 <cocreature> ph88_: yeah that looks about right
12:16:13 <ph88_> then foldl should be faster
12:16:33 <cocreature> ph88_: well foldl won’t give you the same result …
12:16:53 <cocreature> and saying x is faster than y if x and y calculate different things is not very useful
12:17:06 <ph88_> but it is faster right ?
12:17:30 <MitchellSalad> monochrom: it totally messes with my intuition of polymorphic functions taking hidden type arguments
12:18:03 <MitchellSalad> in fact, I don't think you could do this trick with explicit type applications
12:18:15 <cocreature> ph88_: no, foldl will first build up ((0-2)-3-4) and then evaluate that to (-2-3)-4 and so on
12:18:32 <ph88_> but foldl' is faster than foldr ?
12:19:16 <cocreature> yes but not if you look at the number of evaluation steps
12:19:42 <ph88_> foldl' has more evaluation steps but is still faster ?
12:19:53 <geekosaur> someone appears to be microoptimizing prematurely. in particular it is not clear that conceptual steps for understanding are 1-to-1 with actual CPU actions
12:20:12 <cocreature> foldl' will force the evaluation of the intermediate results, so you never end up with ((0-2)-3)-4 but you see 0-2 evaluate that to -2, calculate -2-3, …
12:20:18 <cocreature> ph88_: it has the same number of steps
12:20:31 <cocreature> ph88_: but I agree with geekosaur. you seem to be missunderstanding some things here
12:20:48 <cocreature> try to understand what those functions do and why they are different before you think about which one is faster
12:21:53 <monochrom> geekosaur: I have seen the weaker 3rd-year CS students claiming "linear search takes O(1) time" just because someone wrote: "Step 1: Find the minimum in the list. Step 2: ..."
12:22:04 <geppettodivacin> ph88_: Usually the reason to use one over the other depends on whether your result is a small strict structure (like a number) or a large lazy structure (like a list).
12:22:12 <cocreature> monochrom: does step 2 take O(2) time?
12:22:16 <monochrom> Haha
12:22:24 <geekosaur> *snrk*
12:22:27 <geppettodivacin> It's an overgeneralization, but that's usually my deciding factor.
12:22:29 <monochrom> But anyway it's the opposite of what Haskell beginners do.
12:22:41 <geekosaur> yep
12:22:53 <ongy> monochrom: 3rd year? I feel sorry for them
12:23:19 <geppettodivacin> Having been a CS tutor at a university for the last two years... it happens.
12:23:20 <monochrom> Whereas Haskell beginners think "I dread map f . filter p, it's going to produce more lists than I like", my students are like "Oh that's just O(1) time!"
12:23:25 <MitchellSalad> monochrom: in your paste, the snippet with a type error does not actually have a type error. is there a typo?
12:23:32 <MitchellSalad> the snippet on line 43
12:23:41 <kadoban> monochrom: Well, it does in a certain computational model xD
12:23:59 <cocreature> monochrom: if you don’t force it, it’s O(1)! :)
12:24:46 <ongy> cocreature: that could involve allocation though!
12:26:02 <monochrom> MitchellSalad: I tried again. It is still a type error.
12:26:25 <cocreature> ongy: my turing machine has an infinite amount of memory and allocation is not necessary!
12:27:12 <MitchellSalad> monochrom: interesting, it's a type error on 7.10.3 but not 8.0.2!
12:27:19 <ongy> cocreature: oh right, and cashes don't exist
12:27:32 <monochrom> Eh? I'm testing on 8.0.2 too.
12:27:54 <monochrom> Don't forget the pragma.
12:27:59 <MitchellSalad> oh I didn't
12:28:35 <MitchellSalad> I think you've found a bug in the type-checking fundamentals, that's crazy!
12:29:00 <monochrom> I usually actually test my code on animals!
12:31:05 <MitchellSalad> I'm gonna test on 8.2 RC 2
12:33:05 <MitchellSalad> blah, 'random' is incompatible
12:34:08 <cocreature> MitchellSalad: huh? I’m pretty sure I’ve used random with the 8.2rc. incompatible how?
12:34:41 <MitchellSalad> monochrom: okay, the type error is back in 8.2
12:34:56 <c_wraith> what's the snippet doing this?
12:35:16 <monochrom> http://lpaste.net/352302  lines 43-47
12:36:43 <c_wraith> Oh..  Yeah, GHC has some weirdness regarding that which I avoid by explicitly specifying contexts. :)
12:36:50 <MitchellSalad> cocreature: 'array' and 'deepseq' are still deps that require base < 4.10
12:36:54 <c_wraith> It doesn't surprise me that one release did things differently.
12:38:00 <MitchellSalad> it surprises me, you'd think a program that shows a fundamental property of the type inference algorithm would exist somewhere in a regression test
12:39:14 <c_wraith> I've got the impression that GHC's test suite doesn't cover a lot of failing cases.
12:39:27 <c_wraith> There have been a lot of "this accidentally type-checks" bugs over the years
12:40:33 <MitchellSalad> for sure, all the ones I've seen have involved type families, GADTs, or some other extension
12:41:53 <MitchellSalad> NoMonomorphsmRestriction doesn't count as an extension :)
12:45:04 <hsk3> Hspec vs HUnit?
12:45:10 <hsk3> Which do you prefer and why?
12:50:21 <MitchellSalad> hunit, for the quickcheck integration
12:50:28 <MitchellSalad> also there is 'tasty'
12:55:59 <hsk3> cool
12:56:21 <cocreature> hspec and hunit are not really contradictory
12:56:41 <cocreature> hspec is a test runner + a wrapper around hunit
12:56:57 <cocreature> personally I think it’s a pretty good wrapper
12:57:29 <xmorgan> @list
12:57:30 <lambdabot> What module?  Try @listmodules for some ideas.
12:57:38 <xmorgan> @listmodule
12:57:38 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
12:57:38 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
12:57:59 <xmorgan> @type map
12:58:00 <lambdabot> (a -> b) -> [a] -> [b]
12:58:12 <cocreature> xmorgan: you can send lambdabot private messages to avoid spamming the channel
13:28:39 <tomleb> I have a `Maybe Foo` and if it is a `Just foo` and based on a condition I want to return Nothing or `Just foo`
13:28:45 <tomleb> Is there a better way to do it than
13:29:37 <tomleb> `return . listToMaybe . (filter (isNothing .  fooMaybeVar)) . maybeToList $ foo`
13:36:04 <RotaerkElibom> Hmm if you were to make a game in Haskell, and wanted manual control over memory allocation, I'm guessing you might allocate a big byte array and then "allocate" chunks of it according to your scheme
13:36:48 <RotaerkElibom> But if you were to do this, is there any way to impose types in the chunks of bytes?
13:37:01 <RotaerkElibom> On *
13:38:01 <RotaerkElibom> Kind of like casting a void* to some other pointer type
13:38:18 <Tuplanolla> That's not going to work since all kinds of things allocate.
13:39:24 <lamefun> How to escape braces {} in Cabal description: ? I want to add an example with {-# LANGUAGE Extension #-}.
13:39:28 <cocreature> if you’re really sure what you’re doing you could use something like unsafeCoerce to cast the memory but that way lies madness
13:39:46 <MitchellSalad> tomleb: do { x <- foo; guard (isNothing (fooMaybeVar x)); pure x }
13:41:33 <RotaerkElibom> Tuplanolla, not trying to control all allocation, such as what Haskell automatically does
13:41:34 <cocreature> tomleb: there is also the "witherable" package which provides filter operations for things like Maybe
13:41:57 <tomleb> MitchellSalad: Thanks
13:42:03 <tomleb> MitchellSalad: I'll try that
13:42:03 <c_wraith> RotaerkElibom, there's no sane way to use slices of a mutable buffer as values of a particular type. it will heavily mess with the way the garbage collector works. 
13:42:28 <tomleb> Coldblackice_: I'll take a look but I prefer doing it without dependencies. Alwasy good to know though
13:42:42 <RotaerkElibom> Hmm k.  What about Foreign.storable?
13:43:02 <RotaerkElibom> Just noticed that and it seems appropriate
13:43:08 <monochrom> Storable is orthogonal.
13:43:20 <Tuplanolla> You could carry around a sack of `IORef`, RotaerkElibom.
13:43:42 <c_wraith> RotaerkElibom, the way Storable works is creating a haskell value (allocation) from a memory location. 
13:43:44 <monochrom> Ah but newIORef doesn't let you designate memory either.
13:43:55 <c_wraith> RotaerkElibom, (or vise versa) 
13:45:01 <RotaerkElibom> Hmm k thanks
13:45:08 <c_wraith> RotaerkElibom, Storable is for crossing allocation subsystems. it's never going to be especially fast or efficient. 
13:45:33 <c_wraith> (but it can be safe, unless you get the instance wrong..) 
13:47:46 <c_wraith> the big things to do for memory performance is making sure your live set is as small as possible at all times. 
13:48:12 <c_wraith> and running the gc manually at appropriate times.. 
13:48:35 <c_wraith> if you care about latency rather than throughput, which most games do. 
13:49:40 <c_wraith> also, if you have a big static set and are on ghc 8.2, use compact regions to eliminate gc traversals of that static set. 
13:51:06 <c_wraith> those are a nice trick to make the gc treat your live set as smaller, in exchange for treating the whole thing as an atomic chunk of memory. 
13:53:26 <RotaerkElibom> Cool, is there a good resource for generally learning about lower level Haskell optimizations like these?
13:54:02 <RotaerkElibom> Can of course go specifically read about compact regions...
13:54:25 <c_wraith> not really. things like compact regions are too new to really be in literature anywhere. 
13:54:31 <RotaerkElibom> K
13:54:42 <RotaerkElibom> What about more fundamental stuff
13:54:59 <c_wraith> I don't know of a centralized resource. 
13:55:19 <RotaerkElibom> K
13:55:34 <cocreature> a resource on optimizing haskell would definitely be nice to have
13:57:14 <c_wraith> it would be nice to have a bunch of smaller resources somewhat like RWH, but focusing on optimizing a specific use case. 
13:58:29 <RotaerkElibom> The manual memory management tricks often done in games are done to address fragmentation (pooled allocation with fixed size chunks) and to make temporary allocations and deallocations fast (stack allocation)
13:59:20 <c_wraith> ghc does both of those in its normal allocation strategy 
13:59:30 <RotaerkElibom> Ah
14:01:56 <Unode> Is it possible to do pattern matching on a function with multiple types on the same clause?
14:02:14 <Unode> I currently have 2 patterns, but the body is the same for both
14:02:35 <tomleb> MitchellSalad: I'm not sure how to use that function. Doesn't seem to work. In your example, x is Maybe Foo, so I can't do fooMaybeVar x on it.
14:02:54 <geekosaur> Unode, no, see the or-patterns discussion on the haskell-cafe list
14:03:22 <MarcelineVQ> tomleb: what is the type of fooMaybeVar
14:03:37 <RotaerkElibom> Unode, move the body into the where clause, and use the bound name within the two cases
14:03:38 <geekosaur> https://mail.haskell.org/pipermail/haskell-cafe/2017-June/127304.html ff.
14:04:02 <Unode> RotaerkElibom: that was option (b) thanks. I'll go with that.
14:04:16 <osa1> Unode: hopefully that'll be possible one day https://github.com/ghc-proposals/ghc-proposals/pull/43 ;-)
14:04:28 <Unode> geekosaur: thanks! reading
14:04:48 <tomleb> MarcelineVQ: Maybe Bar
14:05:21 <tomleb> MarcelineVQ: `return . listToMaybe . (filter (isNothing .  fooMaybeVar)) . maybeToList $ foo`
14:05:25 <tomleb> That's the current code I have
14:05:32 <tomleb> foo is Maybe Foo
14:05:55 <tomleb> (should've written mFoo)
14:07:12 <MarcelineVQ> fooMaybeVar's type is  Foo -> Maybe Bar ?
14:08:20 <tomleb> Yeah
14:09:00 <Unode> osa1: interesting. :)
14:09:09 <MitchellSalad> tomleb: In my example, 'x' is 'Foo', not 'Maybe Foo'
14:09:13 <Unode> thanks guys for the info
14:09:14 <tomleb> So I have a `Maybe Foo` and it has a `Maybe Bar` and I want to return Nothing if either `Maybe Foo` is Nothing or `Maybe Bar` is Nothing
14:09:15 <MarcelineVQ> Is   foo >>= fooMaybeVar  appropriate then?
14:09:31 <MitchellSalad> tomleb: right - the code I gave should work
14:09:51 <tomleb> And I want to return the whole `Maybe Foo`, not `Maybe Bar`
14:10:09 <MitchellSalad> oh, I had the predicate backwards
14:10:16 <MitchellSalad> in that case, it's even simpler =)
14:10:32 <MitchellSalad> '\x -> foo x <* fooMaybeVar x'
14:10:34 <MarcelineVQ> ah you want the foo back if there's no nothings in either case
14:10:47 <tomleb> Yeah sorry I wasn't clear
14:11:00 <MitchellSalad> oh, you have a Maybe Foo, whoopsies
14:11:19 <MitchellSalad> do { x <- foo; fooMaybeVar x; pure x }
14:11:38 <tomleb> oh
14:14:31 <tomleb> MitchellSalad: That's clean, wow
14:16:09 <MitchellSalad> Even shorter - do { x <- foo; x <$ fromMaybeVar x }
14:44:40 <Unode> hum.. basic question, how does one write: http://dpaste.com/3EKFSRN in such a way that the where applies to all above?
14:45:33 <Eduard_Munteanu> Unode, you could use a case expression to pattern-match
14:46:17 <Unode> are a top-level function or a case expression the only ways to go about it?
14:47:13 <Eduard_Munteanu> Unode, you can't have where scope over all of those, no
14:47:46 <Eduard_Munteanu> There may be better ways depending on your actual code.
14:48:39 <Eduard_Munteanu> e.g. func = action . unT where action a = ...
14:48:45 <MitchellSalad> 'where' only scopes over one alternative because each alternative captures different variables independently :)
14:51:38 <joe9> Is there an aeson like library for xml? I have some data coming in as xml and I want to read to haskell data structures. With aeson, it would have just been decode.
14:52:06 <joe9> I do not have to write any boiler plate code with aeson. It would be generated automatically.
14:52:17 <joe9> using TH or generics.
14:52:31 <joe9> just want to check if there is a library that can do that for xml too.
14:53:11 <Eduard_Munteanu> joe9, not entirely sure it's possible with XML. Consider attributes vs. elements, e.g. <foo id="abc"/> vs <foo><id>abc</id</foo>
14:53:40 <joe9> Eduard_Munteanu: In my case, it is all attributes.
14:54:17 <joe9> Eduard_Munteanu: this is the data http://codepad.org/vPw4hLDW
14:54:27 <Eduard_Munteanu> I haven't seen anything like that.
14:54:58 <joe9> Eduard_Munteanu: and this is my haskell data structure http://codepad.org/yMCvQ2I9
14:55:43 <joe9> instead of writing each attribute decoding or encoding manually, I am searching for a library that would generate it( TH or generics)
15:00:12 <Eduard_Munteanu> joe9, I see some stuff on Hackage, but a bit obscure, e.g.: https://hackage.haskell.org/package/xml-tydom-conduit  https://hackage.haskell.org/package/generic-xml
15:02:34 <joe9> Eduard_Munteanu: Thanks, that should help
15:03:21 <joe9> can anyone do something about this? The modules are not showing up as links http://hackage.haskell.org/package/generic-xml
15:05:11 <Eduard_Munteanu> Actually that's really old, might not even work with modern GHC.
15:06:08 <joe9> Eduard_Munteanu: I like the xml-tydom-conduit. It is pretty cool and uses generics too.
15:16:04 <kadoban> It should be pretty hard to make ghc 8.0.2 crash because I recursed too deep, right? Or do I have that wrong? I need to write a recursive algo that'll go up to like 10^5 level deep and don't feel like figuring out how to do it explicitly with a stack.
15:16:56 <Eduard_Munteanu> At compile-time?
15:17:28 <kadoban> Runtime
15:18:04 <Eduard_Munteanu> Ok, so your program crashes, not GHC. Do you just run out of stack?
15:19:09 <kadoban> I mean in the GHC 8.0.2 version of the runtime system, do I have to worry about recursing too deep, or will that just use a lot of memory? As long as it's not going to crash because it hit some (relatively small) limit, I don't care. I haven't written the code yet, asking so I know if I can write it the easy way.
15:20:12 <geekosaur> wasn't the default stack limit removed some time ago?
15:20:13 <Eduard_Munteanu> I think things like foldr (+) 0 [1..99999999] still blow the stack.
15:20:35 <kadoban> geekosaur: I think that's a bit what I'm asking.
15:20:44 <Eduard_Munteanu> > foldr (+) 0 [1..99999]
15:20:46 <lambdabot>  4999950000
15:20:58 <Eduard_Munteanu> > foldr (+) 0 [1..9999999]
15:21:00 <lambdabot>  *Exception: stack overflow
15:21:08 <kadoban> :-/
15:21:16 <Eduard_Munteanu> Dunno what lambdabot uses though.
15:22:33 <monochrom> kadoban, the current stack limit is proportional to your RAM size.
15:23:15 <kadoban> Proportional to? Hmm.
15:23:30 <kadoban> I don't have a lot of control over the system this is going to run on, so maybe this is a bad idea.
15:23:45 <monochrom> GHC runtime stack has been growable for a decade. But it is true that only ~5 years ago they replaced the 8MB constant limit by a variable limit.
15:24:09 <monochrom> But in any case, there is always +RTS -K1000000000MB in case you need it.
15:24:34 <monochrom> (Little-known secret: the stack is a heap object.)
15:25:23 <kadoban> I can set RTS things via pragmas or something inside code, can't I? Hmm *looks*
15:26:19 <Eduard_Munteanu> (You should still write your code to perform within reasonable limits rather than escalating stack usage, though.)
15:26:22 <monochrom> See the GHC user guide for how to set RTS things at build time. But IIRC it probably involves C programming.
15:26:58 <kadoban> Eduard_Munteanu: I don't have the brain space right now to convert the algorithm.
15:27:01 <monochrom> Actually maybe not, maybe -rtsopts=??? will do.
15:27:06 <geekosaur> nope. -rtsopts -with-rtsopts="..."
15:27:07 <MarcelineVQ> hmm? you can set that via your cabal file, --rts-ops="..."
15:27:26 <monochrom> Yeah.
15:27:29 <MarcelineVQ> ^ that looks much more legit
15:27:30 <geekosaur> the former enables rtsopts at all, the latter specifies the default options
15:27:39 <monochrom> READ THE USER GUIDE!
15:29:01 <MitchellSalad> hm, can someone explain why eta reduction/expansion affects sharing?
15:29:15 <kadoban> I have weird circumstances, I can't control how it's compiled. I'll figure out if it's possible, thanks all.
15:29:18 <MarcelineVQ> kadoban: don't forget about https://wiki.haskell.org/Foldr_Foldl_Foldl'  which is really about avoiding building up chains of pattern matches that are waiting to happen
15:29:25 <MitchellSalad> I just noticed while playing around that the simple memoized fibonacci function stops memoizing if you mention its argument
15:30:22 <monochrom> Ah, then C programming will help, you can call hs_init with hardcoded (or otherwise) RTS command line arguments :)
15:30:32 <kadoban> MarcelineVQ: Ya, it's a weird imperative algorithm. I'm sure it's possible to write as a fold, but I have no brain left right now.
15:30:35 <kadoban> monochrom: Nice :)
15:30:46 <MitchellSalad> Here's what I mean: http://lpaste.net/356334
15:30:53 <MarcelineVQ> It's not about the fold, it's the idea behind the explanation of foldl'
15:31:12 <monochrom> The is so XYC problem now!
15:31:16 <monochrom> s/The/This/
15:34:54 <monochrom> MitchellSalad, it is best to assume a fairly straightforward compiler, such that if you say "f = let huge_list = ... in \x -> ...", then f 1, f 2, and f 3 share the same list, on the ground that the list is attached to f itself.
15:35:29 <monochrom> And that if you say "f x = let huge_list = ... in ..." then f 1 gets one list, f 2 gets another list, and f 3 gets yet another list.
15:35:47 <Koterpillar> If I have data Tagged (tag :: Symbol) = Tagged, what's a concise way of creating a value of type Tagged "asdf"? (Tagged :: Tagged "asdf") gets long if I need several of those per line.
15:36:29 <MitchellSalad> monochrom: okay, I think that makes sense
15:36:35 <monochrom> Now, GHC is not entirely straightforward, sometimes it does move huge_list inside or outside, behind your back, but it is a rather unpredictable thing.
15:36:42 <MitchellSalad> right
15:37:02 <MitchellSalad> I'm talking -O0
15:37:10 <monochrom> In fact, Oleg complains that it moves huge_list (or something similar) outside when he doesn't want to :)
15:38:22 <MarcelineVQ> Koterpillar: without knowing much about it, would TypeApplications simnplify your life?    Tagged @"asdf"
15:39:13 <Koterpillar> MarcelineVQ: I think it will help, let me experiment a bit
15:39:24 <JScully> hi there
15:39:24 <JScully> https://pastebin.com/TVkJrdgR
15:39:25 <MarcelineVQ> e.g.  :t Tagged @"asdf"     Tagged @"asdf" :: Tagged "asdf"
15:39:32 <JScully> why do i get a parse error (possibly incorrect indentation or mismatched brackets)
15:39:43 <JScully> on line 7 :|
15:39:54 <geekosaur> you're putting that in a file?
15:39:58 <JScully> ya
15:40:31 <geekosaur> it has to be inside a definition, or it has to be a bare definition (no "let"). haskell is like C, there are no bare expressions.
15:40:41 <JScully> alright
15:40:51 <geekosaur> ghci before 8.x requires a "let" though
15:41:12 <monochrom> Where can I download gcci so I can have a C REPL?! :)
15:41:29 <JScully> alright lets see :) thanks
15:41:50 <MarcelineVQ> monochrom: you can get an okay c++ one if you wanted to see what that was like, cling
15:41:58 <monochrom> Ah
15:42:14 <geekosaur> https://en.wikipedia.org/wiki/CINT
15:42:51 <monochrom> I guess things always exist before I think of them.
15:42:51 <geekosaur> (which also links to cling and Ch)
15:43:35 <monochrom> And then some. I was totally horrified to learn of a Java applet that emulates an x86 PC. "Now you can run Linux in your web browser!"
15:43:47 <geekosaur> there's also that c++ evalbot (written in haskell!) https://github.com/Eelis/geordi
15:44:19 <monochrom> Actually it may be just DOS because the emulation was for real mode.
15:45:13 <JScully> https://pastebin.com/wHhkPuAd
15:45:21 <JScully> hm same error, parse error on input let
15:45:27 <JScully> where do i have to put that in order to use let
15:45:27 <JScully> :|
15:45:37 <monochrom> Clearly visible misalignment.
15:45:53 <monochrom> Also missing either "do" or "in".
15:46:55 <JScully> ahh
15:46:56 <JScully> thanks
15:51:43 <JScully> can i have multiple let's ?
15:53:53 <Eduard_Munteanu> JScully, yes, but you can also define multiple things in one let
15:54:23 <Eduard_Munteanu> > let a = 1 in let b = 2 in a + b
15:54:25 <lambdabot>  3
15:54:37 <Eduard_Munteanu> > let { a = 1; b = 2 } in a + b
15:54:39 <lambdabot>  3
15:55:02 <Eduard_Munteanu> > do { let a = 1; let b = 2; a + b }
15:55:04 <lambdabot>  <hint>:1:34: error: parse error on input ‘}’
15:55:16 <JScully> thanks
15:55:22 <pacak> > let { a = 1 ; b = 1; 1 + 1 = 3 } in a + b
15:55:25 <lambdabot>  3
15:55:53 <tomleb> MitchellSalad: You were right, had to use guard, I got it wrong lol
15:56:00 <Eduard_Munteanu> With proper indentation, you don't need the { }
15:59:59 <JScully> W
16:00:05 <JScully> https://pastebin.com/EWt2gvAk i have this custom data type
16:00:12 <JScully> how can i access the members?
16:00:26 <JScully> like iterate over "new"
16:02:06 <tomleb> new state
16:02:27 <JScully> like so https://pastebin.com/HFgDJm99 ?
16:03:21 <JScully> maybe more like   show s = chart s
16:03:34 <Eduard_Munteanu> JScully, show s = show (new s)
16:03:37 <tomleb> yeah more like chart s
16:03:51 <JScully> cool !
16:10:31 <JScully> https://pastebin.com/fdgAjXEP
16:10:37 <JScully> so new s holds a list of prozess
16:10:44 <JScully> i am tryint to display them all
16:10:52 <JScully> but i am getting  Couldn't match type `[Char]' with `Char'
16:11:08 <JScully> that is line 2 in code
16:11:50 <JScully> is there a better way to get errors :D
16:11:57 <JScully> i find them hard to understand
16:13:55 <tomleb> JScully: Do you have an instance of Show defined for Prozess ?
16:14:05 <JScully> yes
16:14:14 <tomleb> then show (new state)
16:14:46 <JScully> new state holds a list
16:14:51 <tomleb> Yeah
16:15:12 <tomleb> That'll still work though
16:15:24 <JScully> https://pastebin.com/GnskTSuZ
16:15:25 <tomleb> You could also derive Show for your datatype
16:15:28 <JScully> this is what i am tryint to do
16:16:04 <tomleb> Ok so
16:16:12 <tomleb> instead of deriving show for Prozess
16:16:22 <tomleb> I'd use your display_process function
16:16:36 <tomleb> instance Show Prozess where
16:16:42 <JScully> i have to derive it though
16:16:43 <tomleb> show = display_process
16:16:44 <Cale> I wouldn't... I would always derive Show for everything.
16:17:03 <tomleb> Well I mean he seems to want to use show to display that stuff
16:17:07 <Cale> If you want to display something in a way which is not valid Haskell code, consider just keeping it out of the Show instance
16:17:24 <JScully> hm
16:17:59 <Cale> But that isn't the difficulty you're having here.
16:18:13 <Cale> JScully: You have map display_process (new s)
16:18:31 <Cale> display_process :: Prozess -> String
16:18:32 <JScully> right
16:18:32 <Cale> so
16:18:41 <Cale> map display_process :: [Prozess] -> [String]
16:18:56 <Cale> new s :: [Prozess]
16:19:12 <Cale> so:  map display_process (new s) :: [String]
16:19:24 <Cale> show needs to result in a String
16:19:30 <Cale> not a list of Strings
16:19:44 <JScully> aha
16:20:06 <JScully> so i need another function around that
16:20:09 <JScully> that concate the strings
16:20:31 <Cale> yeah
16:20:39 <JScully> something like concatenate_strings :: [String] -> String
16:21:08 <Cale> concat :: [String] -> String
16:21:12 <Cale> would make it typecheck
16:21:24 <Cale> but perhaps better would be something like intercalate " "
16:21:36 <Cale> which would put spaces in between things
16:22:53 <JScully> hm
16:24:03 <JScully> if i do another map i get a another list :|
16:25:15 <pacak> :t concatMap
16:25:16 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
16:25:17 <pacak> :t unwords
16:25:18 <lambdabot> [String] -> String
16:25:20 <pacak> :t unlines
16:25:21 <lambdabot> [String] -> String
16:26:06 <JScully> ah
16:26:45 <JScully> cool ! :D
16:38:30 <mibaz_1> Dhall is an embedded language in Haskell, correct? There's almost no info online.
16:39:06 <glguy> mibaz_1: No, I don't believe that it's embedded
16:39:49 <glguy> It's only implementation is in Haskell, but it's not embedded in Haskell's syntax.
16:41:25 <mibaz_1> glguy: I guess I meant to ask about implementation
16:42:05 <mibaz_1> Interesting. I learned about nixos the other day and was lamenting that it was dynamically typed. This could solve the problem
16:43:16 <glguy> How would it solve the problem?
16:44:17 <mibaz_1> glguy: Theres a dhall to nix compiler, it seems: https://github.com/Gabriel439/Haskell-Dhall-Nix-Library
16:45:32 <mibaz_1> I guess it means that you can write an os specification in haskell and have nix build it for you
16:45:40 <mibaz_1> which is cool
16:46:17 <glguy> It's cute, at least
16:47:51 <mibaz_1> I find your lack of faith disturbing
16:48:24 <glguy> I would think it would be a good idea to actually use it for nix development
16:48:36 <glguy> wouldn't*
16:49:48 <mibaz_1> glguy: I know nothing about nix or dhall so why is it not ideal?
16:50:12 <glguy> Making nix expressions that won't be integrated into the community or be usable by most other users?
16:51:27 <mibaz_1> Oh, I see now what you mean by "nix development". I was just talking about a desktop or something similar.
16:51:50 <glguy> I'm not that excited about the aims of the dhall language itself, and separately don't think it's a good idea to build incompatible nix expresions
16:52:15 <mibaz_1> Although I think the nix language should've been implemented in Haskell anyway. The community seems to be trying to throw a static type system on top of what they have.
16:52:37 <mibaz_1> But anyway I'm off topic. Thanks
16:52:41 <Cale> Yeah, I think the thing to do is to implement Nix as a Haskell library
16:52:51 <Cale> and then write a .nix interpreter using that
16:53:10 <Cale> So that we can take advantage of the existing nix expressions, but then write new stuff in Haskell.
16:53:19 <mibaz_1> Cale: That was my first thought, yeah.
16:54:10 <mibaz_1> But isn't that what the Dhall library is?
16:55:11 <Cale> Well, I haven't seen it before now, but dhall looks like some new programming language with its own syntax.
16:55:20 <Cale> That... is only making the problem worse
16:56:17 <mibaz_1> Cale: haha indeed. So I guess now you would compile haskell -> dhall -> nix
16:56:35 <Cale> I want to go nix -> haskell
16:56:45 <Cale> -> machine code
16:58:00 <Cale> but yeah
16:58:33 <Cale> Generating dhall code from Haskell and then compiling *that* to nix expressions seems kind of crazy.
16:58:57 <Cale> Probably about as easy just to go directly from Haskell to nix
16:59:10 <Cale> (and still doesn't seem like the right direction to me)
16:59:35 <n_blownapart> hi for me to understand something key, I guess the precedence is different in prelude. prelude also insists on a variable in decimal form. I used x = 7.0  https://ptpb.pw/M9eg  what's the difference? 
16:59:45 <mibaz_1> Cale: It's convoluted. Which is dissappointing. Had nix been a decent programming language, I would've switched from arch almost instantly
17:00:06 <mibaz_1> Cale: What is the right direction to you, if not haskell -> nix?
17:00:23 <boj> n_blownapart: your z values are different
17:00:39 <n_blownapart> really . dang hold on please
17:01:04 <geekosaur> n_blownapart, monomorphis restriction, plus ghci has to apply it per line
17:01:05 <Cale> mibaz_1: The opposite of that: Either compile nix expressions to Haskell, or just have Haskell code to interpret them
17:01:25 <Cale> mibaz_1: and then have a Haskell implementation of what it is that nix does, as a library, in which you can program the same stuff directly.
17:01:30 <geekosaur> it can't retroactively typecheck x based on how you used it in func
17:01:33 <n_blownapart> boj geekosaur ok so would you kindly put that in layman's terms?
17:01:53 <mibaz_1> Cale: Ah, got it. I concur. That sounds ideal.
17:01:54 <Cale> mibaz_1: The goal being to eventually end up with everything written in Haskell
17:02:09 <geekosaur> ??where dmr
17:02:15 <geekosaur> ?where dmr
17:02:15 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:02:18 <geekosaur> wrong bot :p
17:02:20 <Cale> But with a transition where we can reuse all the work people have put into existing .nix code
17:03:04 <geekosaur> the monomorphism restriction, in brief, says that a binding without parameters (here, x) must be given a non-polymorphic ("monomorphic") type unless explciitly specified otherwise with a type signature
17:03:16 <geekosaur> so 'let x = 7' will produce '7 :: Integer'
17:03:32 <geekosaur> which is not compatible with your use of it with (/) later
17:03:38 <Cale> It'll require someone who knows Haskell and understands well enough the details of what nix does to write something compatible.
17:03:50 <geekosaur> but if you say 'let x = 7.0' then it will use Double as the type
17:04:01 <n_blownapart> geekosaur, ok, yet in prelude, it requires to be in the form 7.0, or at least one value must be
17:04:04 <mibaz_1> Cale: I love the idea. If I was better i'd almost try.
17:04:07 <geekosaur> sorry, I meant 'x :: Integer' earlier
17:04:21 <geekosaur> also it is called ghci
17:04:34 <geekosaur> do you rename the program 'Data.Map' if you select that as the current module?
17:04:39 <mibaz_1> I haven't used nixos yet, though, so I couldn't say if the concept is worth saving.
17:04:43 <n_blownapart> but that doesn't have to do with the precedence. so we are talking about precedence right?
17:04:54 <geekosaur> it has nothing to do with precedence
17:05:19 <geekosaur> why do you believe this is precedence?
17:05:33 <n_blownapart> I'm asking, not telling :)
17:05:44 <geekosaur> it could only be precedence if this were a language that arbitrarily 'casts' numeric values, which means a language other than Haskell 
17:06:10 <n_blownapart> ok so something essential and unique to haskell is going on
17:06:16 <geekosaur> in whih case it would promote 'x :: Integer' and it still would not be precedence
17:06:28 <glguy> What's a language where this would be related to precedence?
17:06:43 <geekosaur> yes, I have no idea where precedence came from
17:06:48 <glguy> n_blownapart: What were you thinking precedence was? Could you explain it in different words?
17:06:52 <geekosaur> you are asking, yes, but you had to get the idea to ask from somewhere
17:07:33 <n_blownapart> geekosaur, I was fooling with parentheses so yeah it didn't change anything
17:07:56 <geekosaur> (a) 'let x = 7' must be given a single type because of the monomorphism restriction. (b) Because of defaulting, that type will be Integer
17:07:59 <glguy> Oh, that was just the guess for why the two different programs produced different results
17:08:27 <geekosaur> (c) you then uses it in an expression where it must be Double, because the expression involves (/) and this will force the entire expression to be Double
17:08:53 <geekosaur> (because (/) and (+) both require both parameters and result to be the same type)
17:09:19 <geekosaur> when compiling in a file, type inference can determine that x had to be Double
17:09:38 <geekosaur> when working in ghci, it cannot look forward to a line you have not typed yet to determine the single type x has to be assigned, so it uses Integer
17:10:13 <geekosaur> although, come to think of it, isn't the monomorphism restriction disabled in ghci these days?
17:10:17 <geekosaur> what ghc version is this?
17:10:35 <n_blownapart> um..
17:10:38 <geekosaur> for that matter, if you are still int hat ghci session, what does ':t x' say
17:10:49 <n_blownapart> 7.6.3
17:11:05 <geekosaur> hm, old
17:11:06 <EvanR> medium ancient
17:11:06 <n_blownapart> one moment please
17:11:22 <geekosaur> wait, I just saw a typo in your paste
17:11:28 <n_blownapart> oh thank God
17:11:28 <geekosaur> re the different result
17:11:44 <geekosaur> 'z = y * 10' vs. 'let z = x * 10'
17:11:47 <glguy> boj: pointed out the definitions were different first thing
17:12:04 <glguy> and then n_blownapart acknowledged immediately, it seemed
17:12:35 <n_blownapart> yeah that's wrong wait is that in my file? thanks hold on pls
17:12:54 <n_blownapart> glguy, I don't understand you
17:13:38 <geekosaur> that's what your paste says
17:13:47 <boj> i pointed it out in case "i am seeing wrong results" was the problem, and not some confusion about a topic with words like "monomorphism restriction" :)
17:13:54 <geekosaur> so either a typo in the file, or typo in the paste
17:13:59 <glguy> n_blownapart: I believe you, but I don't know what you didn't understand
17:14:07 <geekosaur> but I am apaarently not awake enough to be doing this so
17:22:17 <glguy> n_blownapart: There are two different things in play. 1) your answer was different (-17 vs 3) because the input programs had different definitions of 'z'
17:22:28 <glguy> 2) you needed the ".0" part because of what geekosaur was explaining
17:22:32 <pimlu> what's the difference in intuitive meaning behind the types IO [a] and IO [IO a] ?  Is there a way to "absorb" the inner IO to result in the former type somehow?
17:23:23 <glguy> pimlu: The outer 'IO [_]' part is the same, it boils down to the difference between 'a' and 'IO a'
17:24:09 <glguy> We don't know anything about the type 'a', but we know that the type 'IO a' is an IO action you can execute and that when that action finishes that it returns values with type 'a'
17:24:15 <geekosaur> :t sequenceA
17:24:16 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
17:24:35 <n_blownapart> glguy very sorry it was an error transcribing from the textbook geekosaur thanks kindly
17:24:51 <EvanR> sequenceA :: [IO a] -> IO [a]
17:25:04 <EvanR> as a specialization
17:25:33 <EvanR> join :: IO (IO a) -> IO a
17:25:43 <n_blownapart> also thank you boj
17:25:52 <glguy> (=<<) sequence :: IO [IO a] -> IO [a]
17:26:26 <geekosaur> ...although in practice you may have used 'let ... =' when you needed '<-'
17:26:39 <pimlu> I see, thanks
17:26:43 <geekosaur> but you'd still need sequence or sequenceA
17:26:59 <geekosaur> ...or maybe you needed traverse / mapM. hard to say without seeing the actual use case
17:27:02 <EvanR> was going to consider join . sequence
17:27:16 <glguy> EvanR: It'd have been: join . fmap sequence, then
17:27:39 <EvanR> oh
18:04:27 <__Myst__> Is it normal for ~/.cabal to take multiple Gigs?
18:04:33 <glguy> Yes
18:06:27 <__Myst__> can i make it not do that?
18:07:25 <geekosaur> how much of what you have installed do you actually want to have installed?
18:08:46 <__Myst__> none
18:08:52 <__Myst__> i mean
18:08:58 <__Myst__> i'm fine with keeping just what's required
18:55:45 <Zef> Hey folks; any lens experts in the house? I'm looking to build a filtered traversal over the last element of a collection; 
18:56:33 <Zef> e.g.: [1,2,3,4] & traverse . filtered even . _last +~ 10
18:56:41 <Zef> [1, 2, 3, 14]
19:01:47 <iqubic> :t &
19:01:49 <lambdabot> error: parse error on input ‘&’
19:01:54 <iqubic> :t (&)
19:01:55 <lambdabot> a -> (a -> b) -> b
19:02:14 <iqubic> :t ($)
19:02:15 <lambdabot> (a -> b) -> a -> b
19:02:23 <iqubic> @src (&)
19:02:23 <lambdabot> Source not found. Do you think like you type?
19:02:28 <iqubic> @src ($)
19:02:28 <lambdabot> f $ x = f x
19:02:43 <iqubic> x & f = f x
19:04:33 <mellowmaroon> Can someone help me with a NixOS/Hakyll problem I'm running into?
19:08:56 <tempeh> Quick stack/nix question - if I add nix: packages to a stack.yaml file, but I don't set enable: true, that can't mess up anyone's builds, right? The end user has to use --nix for that to have any effect?
19:09:38 <tempeh> If that's true I guess best practice is to include necessary additional packages under nix, but let the nix users enable it
19:13:08 <dmj`> mellowmaroon: what’s the issue
19:21:27 <iqubic> He left
19:22:03 <iqubic> Why are lenses so stupidly complex.
19:23:00 <pacak> iqubic: They are relatively simple if you understand used abstractions.
19:23:42 <iqubic> How does one create a lens?
19:24:12 <iqubic> What does a lens even do?
19:24:53 <pacak> _foo inj (Foo a) =  Foo <$> inj a
19:25:19 <iqubic> What the heck does that mean?
19:25:27 <iqubic> :t to
19:25:29 <lambdabot> (Functor f, Contravariant f, Profunctor p) => (s -> a) -> Optic' p f s a
19:25:35 <pacak> :)
19:25:42 <iqubic> 5.^to succ
19:25:46 <iqubic> > 5.^to succ
19:25:48 <lambdabot>  error:
19:25:48 <lambdabot>      • Variable not in scope: (.^) :: Integer -> Optic' p0 f0 a0 a0 -> t
19:25:48 <lambdabot>      • Perhaps you meant one of these:
19:25:52 <pacak> :)))))
19:25:57 <iqubic> What the heck
19:26:03 <iqubic> :t (.^)
19:26:04 <lambdabot> error:
19:26:04 <lambdabot>     • Variable not in scope: .^
19:26:04 <lambdabot>     • Perhaps you meant one of these:
19:26:44 <pacak> > view (to succ) 5
19:26:46 <lambdabot>  6
19:27:01 <pacak> @src view
19:27:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:27:15 <pacak> Hmm...
19:27:19 <iqubic> > 5^.to succ
19:27:21 <lambdabot>  6
19:27:36 <iqubic> > (5,6)^.to both.succ
19:27:38 <lambdabot>  error:
19:27:38 <lambdabot>      • Couldn't match type ‘a -> f b’ with ‘(Integer, Integer)’
19:27:38 <lambdabot>        Expected type: Getting
19:27:45 <iqubic> What the heck?
19:28:04 <iqubic> > (5,6)^.both.to succ
19:28:07 <lambdabot>  error:
19:28:09 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M828783044383...
19:28:11 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
19:28:32 <pacak> :t both
19:28:35 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
19:28:49 <iqubic> What the heck is that complex type signature?
19:29:09 <glguy> > (5,6) ^. both . to show
19:29:11 <lambdabot>  "56"
19:29:19 <pacak> Take a look at Bitraversable first
19:29:47 <byorgey> No, read a basic lens tutorial first.
19:29:48 <iqubic> I know what bitraversable does.
19:29:56 <iqubic> At least I think I do.
19:30:00 <pacak> Also you might want to pretend that @#$#%@#$#@$##%$ stuff doesn't exist.
19:30:24 <glguy> byorgey: only if the goal is learning
19:30:46 <iqubic> (5,6) ^. both . to succ
19:30:52 <byorgey> glguy: yes, that is an important distinction to make.
19:30:54 <iqubic> > (5,6) ^. both . to succ
19:30:56 <lambdabot>  error:
19:30:56 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M915942461172...
19:30:56 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
19:31:15 <iqubic> > bimap (succ) (5,6)
19:31:15 <glguy> iqubic: you can experiment in private message or ghci
19:31:17 <lambdabot>  error:
19:31:17 <lambdabot>      • Couldn't match expected type ‘c -> d’
19:31:17 <lambdabot>                    with actual type ‘(Integer, Integer)’
19:31:56 <iqubic> > bimap (succ) (succ) (5,6)
19:31:58 <lambdabot>  (6,7)
19:32:02 <iqubic> There we are.
19:32:14 <iqubic> Is there a way to do that in a lens like fashion?
19:35:18 <julianleviston> iqubic: both?
19:35:30 <byorgey> > over both succ (5,6)
19:35:32 <lambdabot>  (6,7)
19:35:43 <iqubic> :t over
19:35:56 <byorgey> or, more operator-y:
19:36:04 <julianleviston> iqubic:  over takes a lens and a function and does a get/set on it, effectively
19:36:08 <iqubic> I think I broke lambdabot
19:36:10 <byorgey> > (5,6) & both %~ succ
19:36:12 <lambdabot>  (6,7)
19:36:23 <glguy> Or  both +~ 1
19:36:30 <iqubic> What is the name of the get operation?
19:36:35 <iqubic> is it view?
19:36:40 <julianleviston> iqubic: for lenses, yes
19:36:43 <iqubic> What is the name of the set operation?
19:36:46 <julianleviston> iqubic: set
19:36:57 <iqubic> julianleviston: What other get operations are there?
19:36:58 <byorgey> iqubic: please go read a basic lens tutorial.
19:37:10 <julianleviston> iqubic: loads… :) do what byorgey just suggested tho :)
19:37:23 <julianleviston> iqubic: lens is **deep** and awesome :)
19:37:23 <iqubic> byorgey: Do you have one of those handy?
19:37:39 <julianleviston> iqubic: there’s on on the main Lens package page
19:38:34 <julianleviston> iqubic: http://hackage.haskell.org/package/lens
19:39:00 <iqubic> Can someone give me a simple lens to try writing? I want something to test my knowledge
19:39:26 <pacak> iqubic: When using lens - the trick is _not to use them_ when you don't need do. Recently I saw a question - how to write (b -> a -> b) -> b -> [[a]] -> b with lens. The answer was kind of ugly.
19:39:41 <pacak> On the other hand plain haskell way was
19:39:46 <pacak> :t foldl . foldl
19:39:47 <lambdabot> (Foldable t, Foldable t1) => (b -> a -> b) -> b -> t1 (t a) -> b
19:40:04 <iqubic> Cool. I like that.
19:40:23 <iqubic> So can I have a simple lens to try writing
19:40:24 <julianleviston> lenses are pretty easy to write, generally… you can use the `lens` helper, and pass it a getter and a setter… but most of the common ones you’d need (the basic ones) are already done
19:40:25 <pacak> Try making a lensy way of this function?
19:40:46 <julianleviston> iqubic: it’s best to do a tutorial where they build up lenses from scratch tho…
19:40:57 <lmapper> hi all, I've been writing some test projects, and I have been encountering the need to maintain a collection of functions with different numbers of arguments
19:41:10 <lmapper> simplified: 
19:41:14 <pacak> iqubic: https://artyom.me/lens-over-tea-1
19:41:18 <lmapper> fa :: a -> a -> a
19:41:22 <lmapper> fa a b = a
19:41:26 <lmapper> fa3 :: a -> a -> a -> a
19:41:29 <lmapper> fa3 a b c = c
19:41:32 <lmapper> lfa = [fa, fa3]
19:41:36 <iqubic> julianleviston: I've been watching this for the past hour: https://www.youtube.com/watch?v=cefnmjtAolY
19:41:58 <julianleviston> iqubic: that’s not going to help a **huge** amount IMO… 
19:42:01 <iqubic> lmapper: fa = const
19:42:02 <pacak> lmapper: What are you going to do with this collection?
19:42:04 <lmapper> however, since they're different kinds, of course they are not the same type
19:42:11 <pacak> once you have it
19:42:31 <iqubic> :t const . const
19:42:40 <julianleviston> :t const . const
19:42:41 <lambdabot> a -> b1 -> b -> a
19:42:47 <julianleviston> I wonder why lambda bot is ignoring you
19:42:57 <iqubic> What is up with lambdabot ignoring me.
19:43:08 <pacak> He refuses to talk to people who don't understand lens I suppose.
19:43:09 <lmapper> I am building a backend for various operations constructed by a gui
19:43:10 <iqubic> Is it because I used /msg with it.
19:43:12 <julianleviston> lol
19:43:29 <lmapper> those operations have varying numbers of inputs
19:43:57 <lmapper> I'd like to maintain a map of (String, Function)
19:44:22 <lmapper> but since the functions are different kinds, I cannot easily maintain a collection
19:44:45 <pacak> lmapper: Mkay. You have Function of some type, you don't know upfront. What are you going to do with it once you have it? 
19:45:14 <julianleviston> pacak: yeah, starting from the other end is a really good idea
19:45:53 <lmapper> actually, the "functions" are being written in the code, so know them upfront
19:46:05 <lmapper> but they will be chosen and arranged by the gui input
19:46:26 <iqubic> So anyone have a lens that I could write?
19:46:32 <julianleviston> iqubic: make one up yourself
19:46:51 <julianleviston> iqubic: write _1
19:46:59 <julianleviston> iqubic: (first element of a tuple)
19:46:59 <iqubic> I'm not sure how to do that.
19:47:07 <julianleviston> lmapper: I have been doing similar things in my side project… 
19:47:14 <pacak> lmapper: No. Gui asks you to run function "blah" - that corresponds to blah in your code, how are you going to execute it?
19:47:14 <julianleviston> iqubic: https://github.com/ekmett/lens/wiki/Overview
19:47:45 <julianleviston> lmapper: you can use the Interpreter monad to pull in functions from a module and evaluate things with them… that’s how I’ve been doing it.
19:47:47 <pacak> iqubic: write _fst. _1 is a bit more difficult.
19:48:08 <julianleviston> lmapper: the package is called "hint"
19:48:09 <lmapper> they are being run in IO,
19:48:29 <pacak> lmapper: They also take parameters.
19:48:30 <julianleviston> lmapper: yeah, the Interpreter monad works in IO … 
19:48:46 <pacak> Different number of them depending on function type.
19:49:00 <lmapper> I have heard that hint requires GHC to be installed on the server running the code
19:49:13 <julianleviston> lmapper: does it?
19:49:51 <julianleviston> lmapper: not sure why that would be, but I haven’t run my code outside of the context of a system that has GHC on it yet, so maybe...
19:49:52 <lmapper> I have not investigated the hint package thoroughly
19:50:03 <julianleviston> lmapper: it might be more complex than you need…
19:50:34 <lmapper> yeah, I was hoping there was a language extension I wasns't aware of that would allow collections of different kinded functions
19:51:32 <iqubic> julianleviston: my_1 f (a, b) = (,) (f a) <$> b
19:51:45 <iqubic> That has the correct type.
19:51:50 <iqubic> It is a valid lens
19:51:55 <lmapper> for now I've just been using a list as the first parameter
19:52:07 <julianleviston> lmapper: there’s heterogeneous lists… 
19:52:12 <lmapper> func :: [a] -> a
19:52:24 <julianleviston> lmapper: but TBH there are probably better ways of doing what you want
19:52:38 <Rotaerk> perhaps this is an XY problem?
19:52:48 <liurnd_> 
19:53:07 <lmapper> haha, I've read about the XY problem a few times the last few days
19:53:09 <pacak> lmapper: GADT, ADT, make them monadic actions that fetch their own parameters, etc.
19:53:16 <Rotaerk> what is it you're REALLY trying to do, for which "collection of heterogeneous functions" is the solution you have in mind
19:53:17 <lmapper> possibly
19:53:37 <julianleviston> yeah it seems like an XY problem
19:54:08 <julianleviston> lmapper: which is why it’s good to start backwards… start with what you’d do once you had this thing you’re after… then solve backwards from that, maybe.
19:55:18 <pacak> iqubic: Can you make a lens to a third element of a linked list?
19:55:30 <pacak> lmapper: There's also unsafeCoerce.
19:56:59 <lmapper> Rotaerk: I want to read a json file and run arbitrary predefined functions with arbitrary predefined inputs and outputs
19:57:35 <lmapper> that are described in the json file, which is the result of connections made in a gui by a user
19:57:36 <julianleviston> lmapper: perhaps represent them in a collection, and use a case to call them when you have the values after parsing?
19:58:02 <julianleviston> lmapper: as in… use a data type to represent them each - one value each… 
19:58:35 <Rotaerk> maybe make each set of parameters into a constructor of an ADT
19:58:39 <lmapper> julianleviston: you mean each function would be a "member" within a sum type?
19:58:45 <Rotaerk> and then write a single function that consumes that ADT
19:58:47 <lmapper> of ADT
19:58:54 <julianleviston> lmapper: no, just a represented value for them.
19:59:37 <Rotaerk> are the result types of these functions also disparate?
20:00:26 <julianleviston> lmapper: ^ very good question by Rotaerk there… and also, will they all eventually converge in some common type (like, say… String) at some point?
20:00:31 <lmapper> yes, currently I have a "generic" value type though, which is a sum ADT with members "IntType Int","FloatType Float", etc
20:01:05 <lmapper> some results will be lists, or single values
20:01:11 <Rotaerk> lmapper, could you give concrete examples of what these functions are
20:02:46 <lmapper> right now I have only tested with simple add (combine) and conversion of simple types, but I need to represent some other data structures later as I grow the system
20:04:47 <lmapper> type Operation = ([Value] -> IO (Either [String] Value))
20:04:51 <lmapper> add :: Operation
20:04:57 <lmapper> add [] = error "add :: Operation cannot combine the empty list"
20:05:02 <lmapper> add l@(IntValue x : xs) = pure $ Right $ IntValue $ foldr (\l@(IntValue x) -> (+) x ) 0 l
20:05:07 <lmapper> add l@(FloatValue x : xs) = pure $ Right $ FloatValue $ foldr (\(FloatValue x) -> (+) x ) 0.0 l
20:05:10 <lmapper> etc etc
20:05:15 <lmapper> data Value where
20:05:20 <lmapper> IntValue :: Int -> Value
20:05:24 <lmapper> FloatValue :: Float -> Value
20:05:30 <lmapper> StringValue :: String -> Value
20:05:31 <Rotaerk> lmapper, thinking perhaps you might do something like:  data Operation = Add Int Int | Negate Int | etc
20:05:33 <lmapper> etc etc
20:05:43 <Rotaerk> and then a single function that executes an operation
20:05:47 <Rotaerk> but the result type I'm unsure about
20:06:09 <lmapper> for now, I've just been reducing each result to a single value
20:06:27 <lmapper> but I'd really like to also allow for collections in the future also
20:06:43 <lmapper> as well as multiple results
20:06:49 <lmapper> of different types
20:06:57 <julianleviston> Context is to Lens as Bazaar is to Traversal, but why is it called Bazaar? lol
20:07:07 <lmapper> but, one step at a time
20:07:35 <glguy> julianleviston: It says why right there in the documentation
20:07:40 <lmapper> I will explore the operation as an ADT
20:07:53 <julianleviston> Mnemonically, a Bazaar holds many stores and you can easily add more ?
20:07:55 <julianleviston> That?
20:08:06 <glguy> Yeah
20:08:08 <julianleviston> oh dear
20:08:09 <julianleviston> ok
20:08:16 <julianleviston> lol thanks :)
20:08:59 <Rotaerk> lmapper, maybe you could actually do something like...  data Operation = Op1 Arg1_1 Arg1_2 ... Arg1_N (Result1 -> a) | Op2 Arg2_1 Arg2_2 ... Arg2_N (Result2 -> a) | ...
20:09:02 <julianleviston> I kind of love this so much.
20:09:22 <Rotaerk> i.e. you provide the args and the function that handles the result
20:09:42 <Rotaerk> data Operation a   *
20:10:20 <Rotaerk> that way each operation can have its own independent inputs and output
20:11:03 <lmapper> that's cool, that might work
20:15:21 <Rotaerk> lmapper, theoretically could even have multiple result types there, if you wanted; such as (Error1_1 -> a) (Error2_2 -> a) (Result1 -> a)
20:15:33 <Rotaerk> though maybe you wouldn't want to do that :P
20:16:04 <lmapper> yeah, I'm experimenting with some things along these lines now
20:16:28 <lmapper> thanks for the direction
20:16:45 <Rotaerk> np
20:20:34 <lmapper> another question I had was regarding pattern matching datatypes based on whether they are of a certain typeclass
20:20:49 <lmapper> for example, in:
20:20:58 <lmapper> add l@(IntValue x : xs) = pure $ Right $ IntValue $ foldr (\l@(IntValue x) -> (+) x ) 0 l
20:21:14 <lmapper> add l@(FloatValue x : xs) = pure $ Right $ FloatValue $ foldr (\(FloatValue x) -> (+) x ) 0.0 l
20:21:26 <lmapper> I'm duplicating a lot of logic there
20:22:06 <lmapper> I'd like to pattern match on whether they are of the Num type class
20:22:25 <XorSwap> is there any place I could find a sort of toy implementation of haskell's type checking algorithm?  all I can find is stuff about how types are deduced
20:22:47 <lmapper> (well, the inner value)
20:27:30 <geekosaur> @google typing haskell in haskell
20:27:31 <lambdabot> Plugin `search' failed with: connect: does not exist (No route to host)
20:27:34 <geekosaur> bah
20:28:12 <geekosaur> https://web.cecs.pdx.edu/~mpj/thih/
20:28:20 <geekosaur> XorSwap, ^
20:28:30 <geekosaur> lmapper, you cannot do typecase in Haskell
20:30:05 <XorSwap> looks like what I need thanks geekosaur 
20:31:45 <lmapper> geekosaur, thank you, I wasn't aware of that term
20:32:03 <iqubic> What the heck is the gettable typeclass?
20:32:06 <iqubic> :t coerce
20:32:15 <iqubic> lambdabot hates me
20:32:42 <iqubic> :t coerce
20:32:52 <iqubic> WTF lambdabot
20:34:17 <iqubic> Can someone else get that type for me?
20:35:15 <glguy> iqubic: GHCi is in your other terminal
20:35:37 <iqubic> How do you know that?
20:35:47 <iqubic> How do you know what I have open right now?
20:36:15 <iqubic> Because GHCi is indeed in my other terminal at this current moment
20:36:25 <iqubic> And is running in that other terminal
20:37:03 <pacak> :t coerce
20:37:04 <lambdabot> error:
20:37:04 <lambdabot>     • Variable not in scope: coerce
20:37:04 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
20:37:39 <pacak> iqubic: screen, tmux.
20:37:45 <iqubic> glguy: Do you know why lambdabot is ignoring me.
20:38:09 <iqubic> pacak: No, I have a seperate terminal in a seperate window running ghci
20:38:20 <iqubic> :t coerced
20:38:27 <pacak> iqubic: You need to earn his respect.
20:38:29 <pacak> :t coerced
20:38:30 <lambdabot> (Coercible t b, Coercible s a, Functor f, Profunctor p) => p a (f b) -> p s (f t)
20:38:36 <glguy> Yeah, so that you'd stop filling the channel with error messages and other queries that you need to do in private message and GHCi
20:39:10 <iqubic> Did you make it so that lambdabot would ignore my queries?
20:40:34 <glguy> Yeah, it's an all or nothing deal, I don't get to restrict a single channel
20:40:48 <iqubic> Oh, that sucks.
20:41:10 <iqubic> Well, I guess I'll just earn lambdabot's respect myself
20:47:12 <iqubic> glguy: I can't even use lambdabot in private msg
21:06:35 <iqubic> Is there a general purpose lens modifier? Like so I can run a function f over the target of the lens?
21:07:07 <suzu> `over`?
21:07:19 <suzu> or `modify`?
21:07:24 <Koterpillar> something with %, I think it's on the Operators page
21:07:36 <Koterpillar> http://ekmett.github.com/lens/Control-Lens-Setter.html#v:over / http://ekmett.github.com/lens/Control-Lens-Setter.html#v:-37--126-
21:07:45 <c_wraith> Over and %~ are the same function, modulo argument order
21:07:50 <c_wraith> err, over
21:07:58 <Koterpillar> iqubic: https://github.com/ekmett/lens/wiki/Operators here
21:32:21 <Opalina> FUCK NIGGERS JOIN quicktalkeh676te.onion/6697: Robin_Jadoul Guest254079[m] ertes gpampara hanDerPeder jacqueline[m] jonrh Guest262120[m] w4and0er96 SolarAquarion flout ethercrow logcat thekyriarchy__ ContessaTP leah2 clog metalrain sdothum abhixec nkhodyunya redcedar aglorei lambdabot carlosdagos anzuof dstockwell ThousandLions[m] nikolah Profpatsch carter saci[m] wagle medical rgrinberg michaelw Matthew[m] Ke Twey nurupo bogdanteleaga mich
21:32:21 <Opalina> FUCK NIGGERS JOIN quicktalkeh676te.onion/6697: Hithroc owlscientist cfoch-always kaol zomg nbouscal Meanirelli SkyPatrol sleffy ajmccluskey infinity0 obiwahn Ralith_ QuantumLogi Lex[m] thoradam sea enolan g4k qmm nlkl[m] cittatva malthe Monad[m] ClaudiusMaximus dlandau[m] Guest45262 sujeet Tazca_ osfameron justanotheruser bengt__ kian fairfieldt Rumia_ ambrosia mgaare wisn[m] jbalint idnar[m] XMunkki dgpratt Bertschneider[m] andjjj23 Fairy 
21:32:31 <nurupo> first
21:32:32 <mrkgnao> @ops
21:32:32 <lambdabot> Maybe you meant: pl oeis docs
21:32:51 <nurupo> @pl oeis docs
21:32:52 <lambdabot> oeis docs
21:32:52 <nurupo> ??
21:34:46 <mrkgnao> nurupo: that's the pointless converter
21:35:02 <mrkgnao> @pl func f g = \x -> g (f x)
21:35:02 <lambdabot> func = flip (.)
21:35:09 <nurupo> oh, sorry, thought this was #freenode
21:35:31 <mrkgnao> yeah, I don't know how to call ops on here. people are prob sleeping anyway.
21:36:25 * pacak looks outside
21:36:33 <pacak> Why would they sleep during the day?
21:37:11 <Rotaerk> flat-earther, eh?
21:37:24 * mrkgnao is outraged
21:37:57 <pacak> :)
21:38:00 <mrkgnao> I'm not too good with timezones, usually just assume people are sleeping when there's little activity
21:38:37 <mrkgnao> Just realised it's not a given that most of #haskell is from North America. Tons of Haskellers in Europe.
21:38:57 <pacak> There are some in Asia.
21:39:25 <ongy> pretty earlier over here. but at least that spambot only posted 2 messages and went away
21:39:48 <pacak> it was banned.
21:39:54 <pacak> by ircops
21:40:09 <mrkgnao> Can confirm. I'm in India.
21:40:32 <mrkgnao> I wonder what the point of spamming Tor links is anyway
21:44:08 <dibblego> You use @where ops
21:44:15 <dibblego> mrkgnao: ^^
21:44:24 <dibblego> we aren't all sleepin :)
21:46:32 <mrkgnao> dibblego: ah, I've only seen it done once
21:48:32 <geekosaur> #haskell-ops is mentioned in the /topic
21:48:49 * geekosaur should probably be asleep...
21:50:14 <halogenandtoast> How do I convince stack to rebuild a package, I changed mysql versions and the dylib is now incorrect. I tried --force-dirty but I must be using it incorrectly.
21:53:32 <halogenandtoast> okay, I might have found what I was looking for, using stack exec -- ghc-pkg unregister --force package-name
22:00:09 <halogenandtoast> okay, so, turns out I have libmysqlclient.18.dylib and something (libHSmysql) wants libmysqlclient.20.dylib
22:00:14 <halogenandtoast> is there any way to fix this?
22:00:41 <halogenandtoast> I assume this is because I've downgraded my mysql version.
22:02:28 <halogenandtoast> I'm trying `stack setup --reinstall`
22:02:58 <halogenandtoast> nope +(
22:03:02 <halogenandtoast> :(
22:03:33 <boj> halogenandtoast: you could always nuke .stack-work and rebuild
22:03:47 <halogenandtoast> boj: tried that didn't work
22:04:01 <boj> hmm, deeper problem then
22:04:10 <halogenandtoast> I've nuked .stack and am starting over
22:07:18 <halogenandtoast> well time for a coffee break while that finishes
22:09:04 <halogenandtoast> stack build
22:17:08 <halogenandtoast> solved my problem
23:02:50 <ertes> and there i thought my life had meaning, that someone had desparately needed my attention…  that some haskell event dependended on my words…  no thanks to you, sir/ma'am mass-highlight!
23:03:56 <Axman6> I wasn't even included :(
23:42:40 <halogenandtoast> Is there a way to see the code generated by quasiquotes/template haskell
23:43:16 <cocreature> how does stackage decide what gets included in an lts? I thought I needed to add my packages separately to that (even if they are in stackage nightly) but for some reason one of my packages ended up in there but other packages didn’t
23:43:36 <c_wraith> halogenandtoast: pass -ddump-splices to ghc
23:46:32 <halogenandtoast> c_wraith: turns out that isn't very readable :(
23:46:41 <halogenandtoast> not that surprising
23:47:27 <halogenandtoast> thanks for the answer though
23:47:58 <johnw> halogenandtoast: try adding: -dsuppress-idinfo -dsuppress-module-prefixes
23:48:08 <johnw> maybe even -dsuppress-uniques
23:51:25 <halogenandtoast> johnw: yeah, I was mainly trying to see if there was a way to use persistent without template haskell, so I wanted to see what it was generating
23:51:41 <halogenandtoast> but the dump-splices file isn't intellgible
23:51:45 <johnw> ah
23:52:02 <halogenandtoast> it's still neat to see
23:52:08 <johnw> I misread
23:52:39 <halogenandtoast> No problem
23:54:26 <Axman6> cocreature: I believe anyone can add a package, and that  basically makes them the maintainer as far as keeping it up to date on hackage. The info can be found in https://github.com/fpco/stackage/blob/master/build-constraints.yaml which should include who the maintainer is
23:55:31 <Axman6> s/hackage/stackage
23:56:24 <cocreature> Axman6: that’s stackage not stackage lts, right?
23:58:44 <cocreature> Axman6: to be a bit more explicit, I’m trying to figure out why llvm-hs-pure is in LTS 8 while llvm-hs is not
23:58:51 <cocreature> they’re both in stackage nightly
23:59:37 <Axman6> #haskell-stack is probably a better place to get policy advice
