00:01:42 <EvanR> huzzah...
00:01:55 <EvanR> tictactoe graphics http://i.imgur.com/rXXZgLH.png
00:02:05 <EvanR> cairo + sdl
00:02:32 <EvanR> cant be denied
00:05:03 <saurabhnanda> in GHC.Generics, can `from` be run on values only, not types? how can one expect the "shape" of a type?
00:15:04 <glguy> saurabhnanda: can you ask that in a different way?
00:15:43 <saurabhnanda> glguy: how can I run the equivalent of `data Foo = Foo {bar :: Int}; from Foo` ?
00:16:18 <glguy> I don't know what you'd expect that to mean
00:21:53 <saurabhnanda> I want a function which returns the **shape** of a data-type?
00:22:06 <wilornel> glguy: How could I import the library from the tests.hs if the library is in ./ and the tests are in ./tests/tests.hs ?
00:22:17 <saurabhnanda> `GHC.Generics.from` accepts a value. I want to be able to pass a type.
00:22:53 <glguy> and you want the shape as a value?
00:23:01 <wilornel> I have speicfied"library \n exposed-modules: Game \n hs-source-dirs: . \n ... "
00:23:41 <glguy> wilornel: your test needs to list your library in its build-depends
00:25:01 <wilornel> "cabal: Encountered missing dependencies: \n Game -any"
00:25:08 <glguy> saurabhnanda: you only need from at the value level, if you don't have a value you don't need it
00:25:36 <glguy> the name of the library isn't the name of the module
00:25:46 <saurabhnanda> glguy: right... how do I get the shape of a type as a value?
00:26:56 <EvanR> :t from
00:26:57 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
00:27:12 <EvanR> from :: Generic a => a -> Rep a x
00:27:20 <glguy> saurabhnanda: define a type class parametrized on generics types 'f' with a method :: proxy (f a) -> Shape
00:27:33 <wilornel> that was interesting!
00:27:37 <wilornel> thank you glguy!
00:28:23 <saurabhnanda> don't quite understand that... shouldn't this be in the Generics library already? How else does anything get done with Generics/
00:28:29 <glguy> saurabhnanda: you'll need the Rep type family to get the initial type to apply that method to
00:28:59 <glguy> they make a new type class for each case of things they want to make
00:29:26 <EvanR> there was some blog post which did that... was pretty good generics tutorial
00:29:35 <glguy> what are you*actually* trying to do?
00:30:20 <saurabhnanda> glguy: fill a record-type automatically from the DB based on field<>column naming conventions. Trying to reduce boilerplate.
00:31:33 <glguy> ok, you'll have class GenericFill f where fill :: f a
00:32:15 <glguy> and you'll make instances for the various generics types
00:32:37 <glguy> then you use to on that
00:33:56 <saurabhnanda> glguy: GenericFill exists?
00:34:07 <glguy> no
00:35:01 <saurabhnanda> hmm... where does one get a well-explained list of all possible M1, U1, K1 from
00:35:11 <glguy> If I want using a phone I'd be writing more
00:35:16 <saurabhnanda> I'm just copy-pasting stuff right now, without being able to understand what's going on
00:36:06 <EvanR> are your db types just records with perhaps sums in the fields
00:36:20 <saurabhnanda> EvanR: yes
00:36:28 <glguy> I'd start with the haddock
00:36:46 <saurabhnanda> haddock is too dense
00:36:56 <saurabhnanda> I've been starting at it for the past hour
00:37:13 <glguy> well it explains all of this from the top
00:47:51 <EvanR> saurabhnanda: so the datatype generic function you want might be ... :: DbResult -> f a
00:48:11 <EvanR> nope nevermind
00:53:45 <Tipsyme> Hrm
01:04:34 * hackage terminal-progress-bar 0.1.1.1 - A simple progress bar in the terminal  https://hackage.haskell.org/package/terminal-progress-bar-0.1.1.1 (RoelVanDijk)
02:06:48 <ph88^> why can't i do this fmap on line 7 ?  https://bpaste.net/show/5f32941f26a2
02:54:23 <hkei> Oh hey, I got GHC to choke on a yesod static subsite
03:13:03 <ThreeFx> Does someone else have issues installing bound-2 with stack?
03:22:58 <lyxia> ThreeFx: what issues
03:28:35 * hackage ghc-syb-utils 0.2.3.1 - Scrap Your Boilerplate utilities for the GHC API.  https://hackage.haskell.org/package/ghc-syb-utils-0.2.3.1 (ThomasSchilling)
03:29:51 <electrocat> ThreeFx: works for me, so what issue?
03:34:29 <ThreeFx> My distribution of bound is missing the `Warning.hs` file and subsequently won't build
03:37:26 <tawe> Hello Haskellers, I just started learning Haskell, search is not really helpful. Please recommend IDE that is easy and has most Haskell support
03:39:48 <ThreeFx> tawe: You can check on haskell.org/hoogle and/or install hoogle locally for looking up functions etc.
03:41:51 <ThreeFx> Otherwise, I think VS Code has some notion of haskell support. Also Atom (both with plugins)
03:42:48 <tawe> @ ThreeFx Super!
03:42:49 <fred-fri> according to the spacemacs haskell layer docs intero REPL commmands are prefixed by SPC m i, but when i press SPC m i spacemacs says SPC m i is undefined... is there something wrong with my .spacemacs config? https://gist.github.com/androidfred/3fbb19ed1056675c45345b462b6ff97a
03:44:09 <fred-fri> also, if i put the caret over eg putStrLn i can see the type correctly, but there doesn't appear to be any means to go to definition. SPC m g g appears to try to do something to do with tags, not sure what,  but nothing happens.
03:44:48 <fred-fri> apologies, i realize these are spacemacs rather than strictly speaking haskell questions but i figure this is still the channel most likely to be able to provide some assistance
03:45:25 <Gurkenglas> Traversing an infinite stream with Maybe always yields Nothing. Can I show this to the compiler in the form of the traversal giving me a Maybe Void?
03:47:12 <Gurkenglas> (I mean, never yields something that's not Nothing, so it might as well yield Nothing immediately in my book)
03:48:25 <ph88^> tawe, you can try visual studio code with interno plugin
03:49:47 <ph88^> intero *
03:49:54 <ph88^> https://marketplace.visualstudio.com/items?itemName=Vans.haskero
04:21:35 * hackage aeson 1.2.1.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.2.1.0 (AdamBergmark)
04:24:54 <Gurkenglas> How do I get "import Codec.Picture" to work outside of a project with intero in emacs?
04:26:51 <Gurkenglas> Can we replace lpaste.net and ircbrowse.net in the topic for the time being?
04:27:19 <Numericboy> Hi guys 
04:27:23 <ph88^> i found alternatives for both
04:27:25 <ph88^> hi Numericboy 
04:28:23 <Gurkenglas> ph88^, what are they? Don't leave us hanging like that :D
04:28:47 <ph88^> https://bpaste.net/ http://irclogger.com/.haskell/
04:29:19 <mniip> huh
04:29:38 <maerwald> ph88^: unfortunately, bpase has no irc bot support afais
04:30:06 <systemfault> Seriously, compiler explorer for ghc is so cool
04:30:11 <ph88^> i copy paste url myself into irc
04:30:30 <maerwald> ph88^: that's so hard ^^
04:31:24 <Gurkenglas> ph88^, can irclogger search a channel's history?
04:31:44 <ph88^> dunno, i use ctrl + f
04:32:29 <Gurkenglas> But that's only within the day :I don't you sometimes remember something relevant that was said years back?
04:32:48 <ph88^> ye
04:33:02 <ph88^> if something is relevant i put it in txt files
04:33:58 <ph88^> why can't i do this fmap on line 7 ?  https://bpaste.net/show/5f32941f26a2
04:34:18 <Gurkenglas> (the poor fellow that put his revelant txt files on lpaste)
04:34:55 <ph88^> huh ?
04:35:19 <mniip> sorry everyone but we have a suspicion that irclogger_com hasn't exactly asked for permission for any of the channels it was in
04:36:14 <Gurkenglas> So you're kicking it from all the channels it is in?
04:36:31 <maerwald> why would you need permission in the first place?
04:36:42 <maerwald> those are public channels no?
04:37:02 <Gurkenglas> ph88^, "let (values, verboseText) =" should be "(values, verboseText) <-" in a do block pretty sure
04:37:21 <sproingie> you can always assume a public irc channel is logged, but it's still rude to have dedicated logging bots without permission
04:38:06 <Gurkenglas> I thought that only went for channels that don't already have public dedicated logging bots
04:38:24 <sproingie> and perhaps there's a reason they don't have them 
04:38:40 <Gurkenglas> Right, but this one does, so one shouldn't need to ask permission
04:38:53 <sproingie> eh.  still up to the channel owner.
04:39:17 <Gurkenglas> In the same sense that they can kick anyone if they feel like it
04:39:34 <maerwald> well, I don't really care as a user where the logs come from. That's really only a matter of "do we add it to the channel topic or not?"
04:39:51 <sproingie> can always boil down to that, but it's just long-established etiquette
04:40:16 <mniip> maerwald, not really about #haskell. Other channels might have different opinions
04:40:43 <mniip> maerwald, see https://freenode.net/news/blogging-about-logging
04:42:23 <maerwald> mniip: "Be sure to provide a way for users to make comments without logging"
04:42:24 <maerwald> uhm
04:42:47 <sproingie> it's not so much the existence of the logs as the commercial exploitation
04:43:06 <mniip> sproingie, on many occasions we've seen commercial exploitation
04:43:24 <mniip> in any case it is inadverted invasion of privacy
04:43:34 <Gurkenglas> Maybe we'll get a logger that does full text search if we kick every logger that doesn't :3
04:43:50 <sproingie> meh.  just switch to gitter or slack then
04:43:56 <mniip> yeah but full text search is hard
04:44:03 <mniip> computationally
04:44:50 <sproingie> pretty easy actually.  devil is in the details, like stemming
04:45:23 <mniip> presumably you won't be satisfied by a substring search
04:45:40 <Gurkenglas> ircbrowse did it so it can't be that hard. I'd be fine with doing it locally if there was, like, a torrent of the channel logs
04:46:38 <Gurkenglas> ircbrowse iirc did a filtering of lines by whether all your words appeared in it. That was good enough for finding a relevant line from years back
04:47:13 <sproingie> i used to keep local logs for reference, found i never used them tho
04:48:01 <Gurkenglas> Mine are fractured between before I switched from my last IRC client, before my hard disk got full and after :I
04:50:20 <mniip> sproingie, I keep local logs of everything
04:50:25 <mniip> and I find them useful every so often
04:52:08 <mniip> as for haskell I have feb'14-mar'14 and jan'15-present
04:52:29 <mniip> somewhat less than, say, ircbrowse
05:03:01 <ph88^> thx Gurkenglas that was it indeed
05:03:15 <sphinxo> I'm trying to use my own main() and it's failing to find the stub for my haskell entrypoint
05:03:34 <sphinxo> ( or haskell module )
05:04:43 <ph88^> sphinxo, you wanna make a paste for that ?
05:26:54 <ThreeFx> Are the GHC rewrite rules documented anywhere? I have no idea where to search for the competing rule in an inline-rule-shadowing warning
05:27:45 <ph88^> why do i need this extra runResourceT on line 23 when i use my splitter function ?   https://bpaste.net/show/7c888a839153
05:27:55 <ph88^> if i don't do that it doesn't type check
05:49:34 <lyxia> ph88^: what's the type of getValues
05:49:38 <Gurkenglas> ph88^, maybe you can pull it out into line 17
05:51:17 <ph88^> lyxia, getValues :: (ResourceT IO) (ResumableSource (ResourceT IO) Value, Maybe T.Text)
05:51:20 <lyxia> You might use (>>=) instead of fmap
05:51:37 <lyxia> ph88^: there's a ResourceT right there
05:52:35 <Gurkenglas> (summedValuesR, valuesR, verboseText) <- runResourceT $ join $ fmap splitter getValues
05:53:06 <Gurkenglas> (summedValuesR, valuesR, verboseText) <- runResourceT $ getValues >>= splitter
05:53:27 <ph88^> how come i don't have the extra runResourceT in the case of Tdev or Mtie ?  and when i use my splitter i create an extra ResourceT  ?
05:54:20 <ph88^> the solution with >>= type checks too
05:54:44 <Gurkenglas> ph88^, you do have the extra runResourceT in lines 5, 6, 12 and 13
05:55:21 <ph88^> ye i don't understand them as well :/
05:56:23 <ph88^> Gurkenglas, to get summedValuesR i need to run 2x runResourceT on line 22 and 23 .. but to get summedValuesR i only have to run it once on line 3 and 10
05:57:00 <ph88^> line 5, 6 and 12 and 13 are even ADDITIONAL runResourceT which i will still have to do in block 16-25
05:59:07 * hackage generic-lens 0.2.0.0 - Generic data-structure operations exposed as lenses.  https://hackage.haskell.org/package/generic-lens-0.2.0.0 (kcsongor)
06:00:02 <Gurkenglas> "(summedValuesR, verboseText) <- runResourceT $ getValues >>= _1 (\r -> r $=+ accConduit $$+- CL.consume)", if you're using lens, will get rid of the one in 5
06:00:05 * hackage ghc-mod 5.8.0.0 - Happy Haskell Hacking  https://hackage.haskell.org/package/ghc-mod-5.8.0.0 (DanielG)
06:00:26 <Gurkenglas> I'm not sure how ResourceT works, but maybe you can get rid of all the runResourceTs by doing one of them in line 1
06:00:36 <ph88^> Gurkenglas, i see what you mean .. i loose an extra runResourceT when i was doing  fmap VU.fromList before   https://bpaste.net/show/e27555dfea88
06:00:58 <ph88^> not sure why the place of runResourceT changed .. but there are still the same count in each  member of the case statement
06:02:53 <ph88^> it doesn't look good .. it should be about the same resource :/
06:02:59 <ph88^> i think i messed up my code
06:04:24 <ph88^> eventually this function is called which creates this situation with the double ResourceT IO     https://bpaste.net/show/5db20d74e790
06:05:33 <ph88^> it's because of that   <-   on line 3
06:06:11 <ph88^> this situation with https://hackage.haskell.org/package/conduit-1.2.11/docs/Data-Conduit.html#t:ResumableSource  creates multiple ResourceT wrappers
06:09:27 <Gurkenglas> ph88^, can you paste the import list so I can put it into intero? (Is there some way to make it ignore unknown identifiers, and in the best case derive types for them?)
06:09:55 <ph88^> unknown identifiers what are those ?
06:10:08 <Gurkenglas> When you haven't imported something you're using
06:10:22 <ph88^> https://bpaste.net/show/bc1cc863b5db
06:10:23 <Gurkenglas> "Not in scope: "
06:10:52 <ph88^> eh maybe you can use   undefined
06:13:17 <Gurkenglas> ya but all over the place. Remaining outofscopes: https://bpaste.net/show/4c04135ec158 Perhaps I should just clone the project?
06:15:01 <ph88^> i can zip the project and e-mail it, it's not in a repository
06:16:05 * hackage opencv 0.0.0.0 - Haskell binding to OpenCV-3.x  https://hackage.haskell.org/package/opencv-0.0.0.0 (BasVanDijk)
06:16:42 <sproingie> now there's a low version
06:17:08 <ph88^> as low as they go
06:17:12 <Gurkenglas> Anyways I'm thinking of https://bpaste.net/show/95a55e6a73eb
06:17:26 <Gurkenglas> You could put it on github
06:17:44 <sproingie> eh for one project i used negative version numbers for the concept stages
06:19:26 <sproingie> i went for goofy project and milestone names in general then.  named a lot of projects after famous dead comedians.
06:20:56 <ph88^> Gurkenglas, first i want to make a github account and polish the sources
06:21:17 <Gurkenglas> Why not polish the sources after uploading the project?
06:21:41 <ph88^> cuz there are a lot of files and code that don't need to go into repository
06:21:53 <ph88^> i have for example   code_dump.hs   where i put all the code i no longer need
06:22:01 <ph88^> in case i have to go back
06:22:21 <Gurkenglas> Right, those should stay at least for the initial version
06:23:00 <Gurkenglas> You can delete them afterwards, because git will keep track of them in case you have to go back
06:24:13 <Gurkenglas> I'd put making a git for the project as the first priority unless you have sensitive data in there
06:26:10 <ph88^> i just need to implement another algorithm and then it should be finished
06:27:33 <Gurkenglas> Why not implement the algorithm after uploading the project?
06:28:00 <Gurkenglas> Think contracrastination.
06:29:45 <saurabhnanda> can someone please confirm this for me. If I'm writing a GHC.Generics function to fill-in a record field based on a DB row, based on field-naming<>column-naming conventions, I have to create a (Rep a x) value and call GHC.Generics.to on it?
06:31:04 * hackage generics-sop 0.3.1.0 - Generic Programming using True Sums of Products  https://hackage.haskell.org/package/generics-sop-0.3.1.0 (AndresLoeh)
06:31:48 <ph88^> Gurkenglas, don't want to kill the motivation when i'm so close :P
06:34:01 <ph88^> need to implement this https://bpaste.net/show/a3fe96d57a93  but i think the original is wrong so i have to review it some more
06:35:20 <ph88^> Gurkenglas, do you like rock n roll ?
06:36:39 <Gurkenglas> I have no strong feelings one way or the other. Back to Haskell.
06:36:52 <ph88^> loll :p
06:37:05 * hackage fltkhs 0.5.2.5 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.2.5 (deech)
06:45:43 <wilornel> I am working on Haskell Programming from First Principles's Section 15.12 "Better living through QuickCheck" 
06:46:34 <wilornel> I have the following piece of code : http://paste.ubuntu.com/24832241/ . and need help understanding the error :  http://paste.ubuntu.com/24832262/
06:47:02 <wilornel> It's for an exercise in the book. I almost have the exercise typed word for word, but I get this type error still
06:48:37 <c_wraith> wilornel: what do you think the error message is telling you?
06:50:22 <wilornel> That's a good question, thanks. I think that it means that I have to pass an Arbitary instance to quickCheck, and that First' String is not an Arbitrary instance
06:50:58 <c_wraith> I might nitpick on terminology a little bit, but not right now.  That's correct.
06:51:21 <c_wraith> You said you "almost" typed it word-for-word.  What did you change?  (I don't have the book)
06:51:37 <wilornel> Checking
06:51:41 <ij> A function turns an action a with its state(obtainable from ask) into a MonadIO instance. How do I write a () -> m ()? More details in this tiny paste: http://sprunge.us/WKah
06:52:03 <m0rphism> quick math question: how is the following proposition called: x = y -> f x = f y
06:52:31 <c_wraith> m0rphism: injectivity
06:52:44 <c_wraith> Oh, wait, no, injectivity is backwards
06:53:04 <c_wraith> m0rphism: nevermind.  That proposition is just "f is a function"
06:53:18 <m0rphism> I remember an Agda tutorial calling it `cong` probably for some sort of congruence
06:53:29 <cocreature> “f is a function” is usually stronger since it also requires totality
06:53:39 <wilornel> It seems to me that I got everything right. I have a definition of Maybe' which does not have anything to do with the error. Oh, well! the exercise asks us to define the Monoid (First' a) instance, and that's where they have `mempty = undefined ; mappend = undefined` and I have what I have
06:53:48 <m0rphism> c_wraith: ok, that was also my thought, I just wondered if there is a more specific name for just that property of functions
06:54:00 <m0rphism> thanks
06:54:58 <c_wraith> wilornel: Ok, then...  Does the exercise in the book expect you to be using quickcheck?  Because quickcheck needs an Arbitrary instance to work.  That's its core idea.
06:56:56 <LiaoTao> How do you do matrix operations and uniform uploading in your OpenGL code?
06:57:05 <wilornel> Is that what is meant by : "Write a Monoid instance for Maybe type which doesn't require a Monoid for the contents. Reuse the Monoid law QuickCheck properties and use them to validate the instance." ? 
06:57:40 <wilornel> and yes the exercise has `main = do { quickCheck (monoidAssoc :: FirstMappend ) ... } ` in it
06:57:43 <cocreature> m0rphism: wikipedia calls it “functional” https://en.wikipedia.org/wiki/Binary_relation#Special_types_of_binary_relations
06:58:09 <wilornel> the quote I wrote, is that what says I'm supposed to define an First' String as Arbitrary instance?
06:58:42 <c_wraith> wilornel: Hmm.  I wouldn't have read it that way initially, but it's the only way that exercise makes any sense.
06:59:00 <wilornel> let me dig through some previous usages of quickCheck I have done
06:59:42 <c_wraith> cocreature: that's a good term for that, though it may accidentally collide a bit.
07:00:54 <wilornel> I have `checkBigger :: Int -> Bool ; checkBigger x = x + 1 > x; main :: IO () ; main = do { quickCheck checkBigger }` somewhere else and it works fine
07:02:04 <m0rphism> cocreature: thanks for the link, even 4 names for the property :)
07:02:05 * hackage ghc-syb-utils 0.2.3.2 - Scrap Your Boilerplate utilities for the GHC API.  https://hackage.haskell.org/package/ghc-syb-utils-0.2.3.2 (ThomasSchilling)
07:02:40 <cocreature> m0rphism: oh right, I didn’t even see the other names :)
07:02:47 <c_wraith> wilornel: yes..  The thing about quickcheck is that it provides instances of Arbitrary for lots of types.  It doesn't provide one for your First' type, because it didn't know about that type. :)
07:02:54 <cocreature> in German “right-unique” and “left-unique” are quite common
07:03:20 <c_wraith> wilornel: That exercise only makes sense if you write your own Arbitrary instance
07:03:53 <wilornel> Aha! So First' is a newtype of Optional, which is a mock of Maybe. What if I made First' a newtype of Maybe?
07:04:29 <c_wraith> wilornel: you'd still need an Arbitrary instance, though you could use GeneralizedNewtypeDeriving to get it for free
07:04:49 <wilornel> I see, this makes sense. thank you c_wraith 
07:04:52 <m0rphism> cocreature: so "rechts-eindeutig" it is, thanks again :)
07:25:08 <MitchellSalad> can someone help me with project euler 44 =)
07:25:15 <MitchellSalad> https://projecteuler.net/problem=44
07:26:44 <Tuplanolla> Does this even require programming, MitchellSalad?
07:27:57 <MitchellSalad> yeah
07:28:05 <Tuplanolla> I can't tell offhand since number theory is strange and full of surprises.
07:28:40 <Tuplanolla> I did some 30 PE problems last year and only half of them required writing programs.
07:37:22 <Gurkenglas> MitchellSalad, once you have one such pair, the search is finite since the difference between subsequent pentagonals diverges
07:40:11 <MitchellSalad> right
07:40:33 <MitchellSalad> right now I'm trying to craft an infinite list of pairs sorted by ascending difference
07:40:59 <MitchellSalad> and then find the first one s.t. the sum is a pentagon number
07:41:20 <jg> hi, about http://lpaste.net/356162 . Where can i read about that usage of 'type'? 4.2.2. of https://www.haskell.org/definition/haskell2010.pdf doesn't mention the case where right hand side is empty
07:41:24 <MitchellSalad> but yes, i suppose i could brute-force myself to some solution somewhere, then use that as a boundary for the infinite search
07:42:59 <glguy> jg: that's an associated type, look at the TypeFamilies extension in the users guide
07:44:22 <Gurkenglas> MitchellSalad, the infinite list of pairs sorted by ascending difference could be by merging infinitely many ascending lists similarly to how Data.List's sort does it
07:44:29 <jg> thanks glguy!
07:48:04 <Gurkenglas> @let hylo phi psi = phi . fmap (hylo phi psi) . psi
07:48:05 <lambdabot>  Defined.
07:50:29 <Gurkenglas> Ah, I'll want the splits to get bigger. Scratch hylo.
07:50:52 <MitchellSalad> scratched
07:54:25 <ij> I wonder whether «stack build» uses locks. It has no problems with C-c interrupts.
07:54:58 <Tuplanolla> Check your `/tmp`, ij.
07:56:43 <Gurkenglas> MitchellSalad, http://lpaste.net/2645894055577255936
07:56:48 <Gurkenglas> Wait, lpaste is back?
07:57:33 <MitchellSalad> Gurkenglas: thanks!
07:58:17 <Gurkenglas> Argh, ys in there of course, not xs
07:58:45 <Gurkenglas> lpaste's undergoing the #haskell hug of death now, I suppose?
08:01:30 <MitchellSalad> whew, I got my infinite list of ascending differences
08:07:05 * hackage IPv6DB 0.2.1 - A RESTful Web Service for IPv6-related data  https://hackage.haskell.org/package/IPv6DB-0.2.1 (MichelBoucey)
08:35:35 * hackage fltkhs 0.5.2.6 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.2.6 (deech)
08:39:31 <lamefun> Is there any chance of improvement on this? https://paste.ofcode.org/mxFwnKLu92DF3RZUJkcKbq
08:39:51 <lamefun> Am I missing some extensions?
08:43:11 <MitchellSalad> looks fine...
08:44:48 <Tuplanolla> It looks like unnecessary emulation of another language.
08:47:20 <lamefun> Tuplanolla: how so?
08:49:50 <Tuplanolla> Pure functions like constructors and deterministic updates shouldn't require `IO`.
08:50:13 <lamefun> That's just some example code.
08:50:42 <lamefun> I mean that every time I need to import something, I need two lines: import Category.Thing (Thing) and import qualified Category.Thing as Thing
08:51:01 <lamefun> whereas in Python it's usually from category import Thing
08:51:11 <Tuplanolla> The one possible improvement is putting those on the same line.
08:51:27 <lamefun> as if the import syntax is in severe disconnect with how modules are actually used
08:51:44 <Tuplanolla> That it is, unfortunately.
08:51:47 <cocreature> you don’t seem to use the unquaified version so I think you can just drop the "import Category.Thing (Thing)"
08:52:24 <lamefun> Not in that example, but usually it's necessary.
08:52:57 <cocreature> there was a proposal for syntax that combines those two things but it got lost in discussions. it might make sense to try it again now that we have the ghc-proposals repo.
08:53:05 <cocreature> I for one would definitely welcome this
08:53:55 <lamefun> Also will there ever be methods?
08:54:27 <cocreature> methods?
08:54:56 <lamefun> like list.append(thing) in Python
08:55:08 <MitchellSalad> looks like a function to me :)
08:55:33 <lamefun> In Haskell a method would be a function associated with a type for quick access.
08:56:12 <lamefun> eg. in Python you don't need to import anything if you only care about methods of a value. Eg. you don't need import qualified Data.Map as Map to modify a map.
08:56:38 <cocreature> well python is a different language. “python does X” does not mean that Haskell should do this :)
08:57:38 <sternmull> I think in Haskell you often get away by importing the typeclasses. This way you don't have to care about what the actual type of a value is.
08:57:40 <lamefun> I think methods are the main reason people cling to OOP.
08:58:04 <lamefun> Even Rust and Go have methods.
08:59:21 <lamefun> TypeName.function value arg1 arg2 becomes just value.function arg1 arg2.
09:00:42 <lamefun> even in Haskell, https://github.com/haskell-gi/haskell-gi abuses #labels to simulate methods
09:01:00 <Logio> I would prefer just "function arg1 arg2", which is what I usually write in Haskell
09:01:03 <cocreature> I think you might be overestimating how often qualified imports are necessary. in practise there are not that many name collisions
09:01:15 <lamefun> eg. #add win button instead of Gtk.containerAdd win button
09:01:48 <MitchellSalad> lamefun: people cling to OOP for all kinds of reasons. if your point is that manipulating objects with methods are more familiar to object oriented programmers, then I'd agree... tautologically'
09:03:02 <MitchellSalad> anyways, in haskell you'll find an odd mix of naming conventions
09:03:25 <MitchellSalad> to modify an IORef, for example, you would use 'writeIORef' instead of 'IORef.write'
09:05:36 <Gurkenglas> :t Data.IORef.modifyIORef
09:05:37 <lambdabot> GHC.IORef.IORef a -> (a -> a) -> IO ()
09:06:07 <saurabhnanda> what's the relationship between GHC.Generics and Data.Typeable and Data.Data ?
09:06:33 <lamefun> IMO methods are good because you can associate common operations with a type and then use eg. `text.toUpper.trim.replace "x" "y"` instead of `Text.replace (Text.trim (Text.toUpper text)) "x" "y"`.
09:07:20 <MitchellSalad> lamefun: how about this? (toUpper . trim . replace "x") "y"
09:07:22 <Logio> lamefun: why is the "import Category.Thing (Thing)" statement necessary for you?
09:07:31 <MitchellSalad> er, messed up that last paren
09:07:41 <MitchellSalad> toUpper . trim . replace "x" "y"
09:08:21 <cocreature> it seems like what you are really looking for is type-directed overloading not methods, whatever that’s even supposed to mean in Haskell
09:08:27 <MitchellSalad> but reverse te order, haha. I butchered all that
09:08:38 <MitchellSalad> lamefun: replace "x" "y" . trim . toUpper
09:09:35 <cocreature> https://wiki.haskell.org/TypeDirectedNameResolution contains some discussion of the pros and cons
09:12:43 <lamefun> Logio: to have eg. `func :: Map x y -> Map x y` instead of `func :: Map.Map x y -> Map.Map x y`.
09:15:18 <ph88^> how can i do a fold-like operation on a Vector so i can stop folding when a certain predicate has been reached ?
09:15:22 <lamefun> How long before OverloadedRecord fields?
09:15:42 <ph88^> i want to find the min and max value and stop when a values is bigger than x
09:16:05 <Logio> lamefun: and you get name collisions with "import Category.Thing"?
09:16:46 <lamefun> Even if it isn't, what if it adds functions which conflict with mine in later versions?
09:16:52 <ph88^> or maybe i should just use filter and fold together and it will still traverse once ?
09:17:21 <Logio> lamefun: you usually rarely have to
09:17:41 <ph88^> or should i use Control.Foldl ?
09:18:51 <lamefun> import Data.Vector ; main = print (null [])
09:18:52 <Logio> lamefun: in many cases you would probably implement a type class rather than having tons of similar modules with the same methods
09:21:15 <Gurkenglas> How do I know which constructor a DynamicImage from JuicyPixels's readImage is using? Writing a handler for each feels like the wrong approach when I'm basically writing a toy
09:22:34 <ph88^> Gurkenglas, i used JuicyPixels before :D
09:23:26 <ph88^> 1 jan 2016 .. one if my first haskell codes
09:24:02 <ph88^> Gurkenglas, https://bpaste.net/show/4d43ebaa6cb6
09:24:44 <ph88^> it only handles png files from what i can remember .. but still i use dynamic image
09:24:47 <Gurkenglas> Well ya you dont need to know the constructor if you're just gonna crop
09:25:53 <ph88^> well you can put undefined for other constructors
09:26:20 <Gurkenglas> How do I tell intero to add a package to the current project's dependencies? I thought there was a thing for that
09:26:33 <ph88^> oh ye you asked that before
09:27:59 <saurabhnanda> just broadcasting these here -- https://www.reddit.com/r/haskell/comments/6gm9eo/ghcgenerics_is_the_modern_way_and_it_is_much/
09:29:25 <glguy> saurabhnanda: Did you figure out how to write your default value generator in GHC.Generics last night? 	  				 	 	 	    		  	   		  		
09:30:36 <saurabhnanda> glguy: I managed to process an existing value. Now I'm completely stuck with generating a value. Basically the equivalent of encoding works. The equivalent of decoding is too complex.
09:30:48 <ph88^> saurabhnanda, ghc.generics can not do what Typeable can afaik
09:31:00 <saurabhnanda> ph88^: but Typeable is far easier to use, no?
09:31:29 <ph88^> yeah like boats are far easier to cross some water than cars
09:31:35 <ph88^> not for the same purpose
09:31:51 <cocreature> Typeable and GHC.Generics are mostly orthogonal. Typeable gives you runtime type equality and casts. GHC.Generics give you a way to do datatype generic programming
09:32:00 <glguy> saurabhnanda: Typeable isn't related to GHC.Generics
09:32:44 <saurabhnanda> looking at http://chrisdone.com/posts/data-typeable it seems to be that I can write a generic encoder and decoder for any type using Typeable. Same thing can be done with Generics. Are they equivalent for this task?
09:33:28 <glguy> No, you can't do that with Typeable
09:33:31 <cocreature> Data.Data is the thing that allows you to do generic programming
09:33:33 <glguy> You can do that with Data
09:33:48 <saurabhnanda> so my question is around Typeable+Data vs GHC.Generic
09:34:06 <leshow> Is there a way to define Data.Map values without using a list first?
09:34:21 <glguy> leshow: Repeated inserts
09:34:53 <ph88^> saurabhnanda, the question should be Data.Data vs GHC.Generic
09:34:55 <MitchellSalad> Generic is newer and more powerful than Data
09:34:56 <leshow> will ghc fuse those inserts into a single map?
09:35:26 <saurabhnanda> MitchellSalad: how is it better? It sure isn't easier to use.
09:35:46 <leshow> Or, if I compile with -02, or something
09:35:54 <glguy> saurabhnanda: You're not really in a position to say that yet since you don't know how to use both of them
09:36:28 <MitchellSalad> saurabhnanda: well, for starters, see how they each represent data constructors
09:36:47 <MitchellSalad> with Data, you just get a 'Constr' - opaque thing with an 'Eq' and 'Show' instance. Not very exciting.
09:37:05 <ph88^> saurabhnanda, GHC.Generic should be faster by margin
09:37:21 <saurabhnanda> ph88^: big margin or small margin?
09:37:32 <ph88^> big enough for things to matter
09:37:43 <glguy> GHC.Generics can be more efficient if you're careful to use it in a way that allows the generic representation to inline and specialize away
09:37:49 <glguy> If you don't, then it won't be faster
09:38:44 <anieuwland> Hi! I'm trying to use a gi-gtk ListStore. However listStoreNew wants me to provide a [GType], but the definition of GType is: data GType :: *. I don't understand what I should give to listStoreNew?
09:39:23 <saurabhnanda> ph88^: glguy: is this really the easiest way to build data constructors with generics
09:39:27 <saurabhnanda> https://ocharles.org.uk/blog/posts/2014-04-26-constructing-generically.html
09:40:07 <MitchellSalad> anieuwland: that just means that the GType constructor(s) are hidden; you have to make one from other parts of the API
09:40:16 <saurabhnanda> also, are there any benchmarks substantiating Data vs Generic?
09:40:20 <Gurkenglas> Does stack have something to throw out old, unused stuff to free up disk space?
09:40:34 <MitchellSalad> stack clean maybe
09:40:50 <anieuwland> MitchellSalad: Oh... Okay, thanks. Now to find where those are then 
09:40:50 <ph88^> saurabhnanda, if you are going for easy than don't use GHC.Generics directly. use Lens or uniplate .. and you get stuff that works®
09:41:18 <saurabhnanda> Uniplate?
09:41:19 <glguy> saurabhnanda: That blog post is trying to be pretty clever and generate functions where needed to get extra arguments for the constructed value
09:41:33 <glguy> saurabhnanda: What you were describing last night sounded like you just wanted a to generate some default value
09:41:55 <glguy> ph88^: Those won't help to generate a value
09:42:37 <saurabhnanda> writing a generic DB encoder/decoder
09:42:39 <ph88^> https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Plated.html   https://hackage.haskell.org/package/uniplate
09:42:49 <glguy> ph88^: Correct
09:43:00 <saurabhnanda> just to clarify - uniplate can generate values easily?
09:43:03 <glguy> nope
09:43:14 <ph88^> i didn't understand your usecase
09:43:18 <ph88^> nevertheless ... keep them in mind
09:43:44 <saurabhnanda> btw, uniplate seems to be using Data/Typeable and not Generics
09:43:48 <ph88^> Gurkenglas, i made a github issue for that i think
09:44:08 <ph88^> saurabhnanda, yes .. the author wants to upgrade it to ghc.generic if only he had the time ^^
09:44:23 <saurabhnanda> so, if uniplate also can't generate a value, is there no easy way to generate a value generically in haskell/
09:44:24 <glguy> saurabhnanda: Do you know the "binary" package?
09:44:35 <saurabhnanda> glguy: yes, I know of it
09:44:46 <glguy> saurabhnanda: Both Data and Generic can generate values generically in Haskell
09:45:03 <glguy> saurabhnanda: Are you trying to make something similar to binary's Binary class with get and put?
09:45:10 <saurabhnanda> This definition makes use of the Scrap Your Boilerplate (SYB) based Uniplate implementation. The SYB implementation is compatible with the other implementations, but is slower (between 2 and 8 times) and requires some modest compiler extensions (implemented in GHC for many years). The alternative definition scheme is described towards the end of this document, in "Making Uniplate Faster". I recommend using the SYB implementation to s
09:45:11 <saurabhnanda> tart with, as it requires least work to use.
09:45:43 <saurabhnanda> glguy: I know they **can** generate values, but the only example I found https://ocharles.org.uk/blog/posts/2014-04-26-constructing-generically.html - is way too complex.
09:45:51 <saurabhnanda> glguy: I'm trying to map records to DB rows based on field<>column naming conventions
09:46:31 <glguy> saurabhnanda: What type would that have? (ignoring generics)
09:46:45 <glguy> SomeRecord -> _what_ ?
09:47:33 <glguy> saurabhnanda: and the blog post you keep referring to is doing something more complicated than you're asking for, so it's going to look complicated
09:47:49 <ph88^> saurabhnanda, https://hackage.haskell.org/package/generics-eot-0.1/docs/Generics-Eot-Tutorial.html#g:6
09:48:24 <ph88^> still don't understand the usecase but since you were talking about database maybe that comes in the direction of you want
09:48:36 <glguy> anieuwland: Are you using Glade?
09:48:44 <saurabhnanda> ph88^: aargh... I spent 4 hours figuring the first function out -- nameOfFields -- why didn't I find this earlier!
09:48:47 <anieuwland> glguy: yes I am
09:49:06 <ph88^> saurabhnanda, i know right -____-  i spend 4 months on this stuff
09:49:11 <ph88^> there is also generics sop
09:49:20 <ph88^> and other convienant packages for working with generics
09:49:25 <ph88^> nobody told me either
09:49:31 <saurabhnanda> if record is data Book = {bookName, bookIsbn, bookAuthor} then it should be able to read and write to a table with columns called (name, isbn, author) without having to write any boilerplate code.
09:49:47 <saurabhnanda> generics-sop is too complex
09:49:50 <anieuwland> glguy: partially anyway. why do you ask? 
09:49:54 <glguy> anieuwland: In my project I defined my ListStore columns in glade
09:50:01 <glguy> https://github.com/glguy/CookieCalculator/blob/master/resources/MainWindow.ui#L5-L19
09:50:18 <anieuwland> glguy: ohh that might help actually
09:50:23 <anieuwland> good idea
09:50:27 <glguy> anieuwland: and then this is how I added rows to the list store https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs#L186-L199
09:51:24 <glguy> anieuwland: Turned out like this: https://glguy.net/CookieCalculator.png
09:52:12 <anieuwland> glguy: Aha aha, so Gdk.toGValue converts it into a gvalue after which you can just use listStoreAppend?
09:52:48 <anieuwland> glguy: Very nice :) This helps a lot. The list store was really confusing me
09:53:48 <glguy> saurabhnanda: You're right about that, if GHC.Generics was too complicated, generics-sop is right out
09:54:26 <glguy> saurabhnanda: so you basically want to positionally convert a record into a tuple of matching size?
09:54:32 <glguy> saurabhnanda: How do record fields factor in?
09:54:52 <glguy> I mean how do the record field names* factor in
09:56:52 <saurabhnanda> for column names
09:56:55 <saurabhnanda> DB column names
09:57:18 <glguy> yeah, you have to explain how
09:57:40 <glguy> Are you using a database library that already has a type for these serializers
09:57:44 <glguy> like a "FromRow" class?
09:58:32 <saurabhnanda> if record is data Book = {bookName, bookIsbn, bookAuthor} then it should be able to read and write to a table with columns called (name, isbn, author) without having to write any boilerplate code.
10:00:06 <glguy> Pasting messages you're already written doesn't provide me with new information about your problem
10:00:09 <glguy> good luck
10:01:12 <saurabhnanda> glguy: I thought you missed it. What is not clear about the problem from that message?
10:08:50 <ph88^> is it for query or for return data ?
10:09:35 * hackage temporary 1.2.1 - Portable temporary file and directory support  https://hackage.haskell.org/package/temporary-1.2.1 (RomanCheplyaka)
10:09:57 <saurabhnanda> ph88^: reading data back from the DB
10:10:04 <saurabhnanda> ph88^: actually it's for both
10:10:16 <saurabhnanda> ph88^: but reading data back from the DB is where I'm getting stuck
10:13:13 <UserOO7> This happens from fresh install on osx, I've tried removing haskell-platform, ghc/ghci, cabal, stack...
10:13:13 <UserOO7> I'm Soo Lost on how to get haskell working with this simple program I wanted to write...
10:13:13 <UserOO7> http://lpaste.net/8407378123775016960
10:13:51 <cocreature> saurabhnanda: so what are the answers to glguy’s questions? are you using some db lib? if so which one? if not, what should be the type of the deserializers?
10:14:51 <saurabhnanda> using opaleye and PG-simple.
10:15:31 <cocreature> so you want to generate an instance of FromRow?
10:15:45 <TonyBravo> ?src take
10:15:46 <lambdabot> take n _      | n <= 0 = []
10:15:46 <lambdabot> take _ []              = []
10:15:46 <lambdabot> take n (x:xs)          = x : take (n-1) xs
10:16:02 <saurabhnanda> cocreature: no, I"m working on a level "above" FromRow. I'm trying to map basic PG types to my app-level types.
10:17:05 * hackage oanda-rest-api 0.4.0 - Client to the OANDA REST API  https://hackage.haskell.org/package/oanda-rest-api-0.4.0 (jdreaver)
10:17:29 <saurabhnanda> PG conversion functions go from  ByteString -> Text. I want to go from Text -> Custom ADT // OR // to be able to deserialise the Row to a record-type easily, instead of a tuple.
10:17:34 <UserOO7> no one seems to have any thoughts on my issue? I figured it would be an easy newbie (haskell) type question :-(
10:18:34 <cocreature> saurabhnanda: FromRow does not go from ByteString to Text. it goes from a Row to whatever type you are making an instance for which seems exactly like what you are describing
10:19:06 <saurabhnanda> sorry, I meant FromField.
10:19:30 <cocreature> so are you trying to generate an instance of FromRow?
10:19:53 <saurabhnanda> so, my use-case is a little more complex because of Opaleye. But UNDERSTANDING how to write a generic implementation of FromRow and ToRow for the use-case of records, will give me what I need.
10:19:59 <glguy> UserOO7: you can't reinstall base
10:21:42 <glguy> UserOO7: the package you're trying to install hasn't been updated to work for ghc 8
10:21:57 <UserOO7> okay, that makes sense to me
10:22:58 <cocreature> saurabhnanda: FromRow already has a default implementation in terms of GHC.Generics so you can either use that or if you want to figure out how it’s implemented, take a look at the source of postgresql-simple
10:23:39 <saurabhnanda> cocreature: thanks... although that makes me wonder why Opaleye makes you jump through so many hoops when Generics are available.
10:24:27 <Gurkenglas> I'm trying the example from https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image.html#g:4 but it doesn't seem to do anything
10:24:35 * hackage monad-control 1.0.2.0 - Lift control operations, like exception catching, through monad transformers  https://hackage.haskell.org/package/monad-control-1.0.2.0 (BasVanDijk)
10:24:50 <Gurkenglas> https://i.gyazo.com/dc7ddabcfcf83bba6b68841905f9bb00.png
10:25:01 <saurabhnanda> cocreature: does this look like it'll work for records out-of-the-box? https://www.stackage.org/haddock/lts-8.16/postgresql-simple-0.5.3.0/Database-PostgreSQL-Simple-FromRow.html#v:fromRow
10:26:02 <cocreature> saurabhnanda: “fromRow :: (Generic a, GFromRow (Rep a)) => RowParser a ” that’s the signature of the default implementation. so either make an empty instance for your datatype or use DeriveAnyClass and derive FromRow.
10:26:43 <anieuwland> glguy: In your code, you use  #set store iter [0..5] vals.  Which function is #set? There is no listStoreSet or treeModelSet...
10:26:55 <saurabhnanda> cocreature: found the generic implementation at https://www.stackage.org/haddock/lts-8.16/postgresql-simple-0.5.3.0/src/Database.PostgreSQL.Simple.FromRow.html#gfromRow but it doesn't seem to be bothered with column and selector names at all
10:28:42 <cocreature> saurabhnanda: it can’t. instances of FromRow can only take the position of the fields into account not their names. e.g. what would be the column name in "select 1;"?
10:29:25 <saurabhnanda> cocreature: right, so I do need a wrapper on top of this, which works for specific tables and records
10:29:38 <glguy> https://developer.gnome.org/gtk3/stable/GtkListStore.html#gtk-list-store-set
10:29:54 <Gurkenglas> (Trying someFunc again asked me what program to open the last (I think) image with, doing it again opened all three in another program. Huh.
10:29:57 <Gurkenglas> *)
10:30:03 <cocreature> saurabhnanda: you can’t write a wrapper on top of FromRow that takes names into account. where would those names come from? this info just doesn’t exist
10:30:53 <UserOO7> glguy: would you recommend downgrading ghc, or trying different lib/imports, for something simple like: http://lpaste.net/1658374859685625856
10:30:54 <saurabhnanda> cocreature: it's there in FromField
10:31:39 <saurabhnanda> cocreature: there - https://www.stackage.org/haddock/lts-8.16/postgresql-simple-0.5.3.0/Database-PostgreSQL-Simple-FromField.html#v:name
10:32:06 <saurabhnanda> cocreature: also  https://www.stackage.org/haddock/lts-8.16/postgresql-simple-0.5.3.0/Database-PostgreSQL-Simple-FromField.html#v:tableColumn
10:32:26 <glguy> UserOO7: I'd recommend using a different HTTP library that is being maintained
10:32:35 <UserOO7> Thanks
10:33:50 <UserOO7> Would you have a personal recommendation for one that can handle https and username/password (and good json parsing support builtin, if not asking for too much)
10:33:53 <UserOO7> :-)
10:34:28 <glguy> cocreature: perhaps two generically defined methods, one that produces a list of column names to inform the SQL query construction
10:34:42 <glguy> and then a positional FromRow?
10:35:18 <glguy> UserOO7: http requests aren't something I do, so I don't have a preference. maybe someone else can recommend something
10:36:19 <UserOO7> Thanks for your help glguy, at-least now i'm not beating my head against something that just will not work, hehe ;-)
10:37:00 <glguy> in absence of someone having a suggestion , I know wreq, http-client, and HTTP are all commonly used
10:43:13 <cocreature> saurabhnanda: if you show me the boilerplate for an instance of FromRow that deserializes a record by using the field names instead of the positions I might be able to help you figure out how to write that code generically
10:43:26 <UserOO7> wreq was what google threw at me yesterday, brand new to haskell and the above package looked friendlier from examples, but after you said move on started to actually look into Wreq again... hopefully it'll work this time round
11:01:12 <EvanR> it seems like saurabhnanda's issue has a good chance of being already solved, but no one can communicate to realize that
11:01:42 <EvanR> in the process im learning fragments of the current state of generics and their use in libs
11:40:44 <tdammers>  
11:45:27 <tdammers> hmm, SDL-ttf won't compile with stack
11:48:11 <EvanR> its working for me
11:48:16 <EvanR> sdl2-ttf ?
11:49:03 <tdammers> that one requires sdl >= 2.0.5, and I'd rather use the one that ships with debian stable
11:49:54 <EvanR> which is
11:50:13 <EvanR> i recall 2.0.4 -> 2.0.5 not changing very much of anything
11:50:42 <EvanR> so you might be able to put custom bounds
12:03:05 <tdammers> also I think the sdl2 API is kind of weird, SDL has a much more faithful mapping of the original SDL API
12:03:55 <EvanR> eh?
12:04:02 <EvanR> sdl 1.2 ?
12:04:49 <lpaste> tdammers pasted “cabal output trying to install SDL-ttf” at http://lpaste.net/356165
12:04:49 <tdammers> no, they both bind to sdl 2.x
12:05:05 <EvanR> ah
12:05:07 <tdammers> but the sdl2 bindings introduce a Renderer type on top of plain SDL Surfaces
12:05:18 <EvanR> yeah i recall the original SDL 2 bindings not working for some reason
12:05:38 <tdammers> drawing primitives goes through Renderer, but most other operations work on Surfaces directly
12:05:41 <tdammers> which is weird
12:05:43 <EvanR> renderer is part of the sdl 2.0 API
12:06:01 <EvanR> its a thing to emulate old style rendering without opengl
12:06:05 <EvanR> but secretly it uses opengl
12:06:20 <tdammers> basically I want stuff like fillRect: https://wiki.libsdl.org/SDL_FillRect?highlight=%28\bCategorySurface\b%29|%28CategoryEnum%29|%28CategoryStruct%29
12:06:46 <tdammers> both sdl2 and SDL have it, but sdl2 runs it through Renderer, while SDL takes a Surface
12:06:58 <EvanR> yeah, thats weird
12:07:14 <tdammers> I guess sdl2 uses this: https://wiki.libsdl.org/CategoryRender
12:07:27 <tdammers> https://wiki.libsdl.org/SDL_RenderFillRect?highlight=%28\bCategoryRender\b%29|%28CategoryEnum%29|%28CategoryStruct%29
12:07:33 * EvanR looks to see what Renderer even is
12:10:23 <EvanR> tdammers: looks like the surface-only version is also exposed in sdl2 bindings in SDL.Video.Raw
12:11:20 <EvanR> fillRect :: MonadIO m => Ptr Surface -> Ptr Rect -> Word32 -> m CInt
12:12:09 <EvanR> er SDL.Raw
12:12:35 <EvanR> https://hackage.haskell.org/package/sdl2-2.2.0/docs/SDL-Raw-Video.html
12:13:02 <jg> hi. I have a stack project & would like to generate haddock for _all_ functions, not just the exported ones for easy reading
12:15:02 <jg> oh, i see there's this --ignore-all-exports option
12:21:31 <friv> Hrmm
12:21:33 <EvanR> and i learned yesterday you can still do old school pixel plotting with the new texture api via the lockTexture unlockTexture dance
12:28:35 * hackage brick 0.18 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.18 (JonathanDaugherty)
12:45:38 <hjulle> When using ConstraintKinds, is there any way to specify what functional dependencies a constraint has? (I'm trying to write code generic over constraints that has known FunDeps)
12:46:18 <Gurkenglas> Debug.Trace should have "(a -> String) -> a -> a" variants
12:46:20 <lpaste> Hjulle revised “FunDep ConstraintKinds”: “FunDep ConstraintKinds” at http://lpaste.net/356167
12:50:42 <cocreature> hjulle: I’m not sure that makes sense. functional dependencies are a property of a class not of a single instance. can you give an example of what you are trying to do?
12:51:49 <monochrom> What is "forall c" doing there?
12:52:30 <hjulle> monochrom: oops, that c should be removed.
12:52:36 <lyxia> hjulle: in this case you could use a type family
12:54:19 <hjulle> lyxia: The problem is that I do not control the type classes, they are from an external library. And as far as I can tell there is no way to convert a class into a type family (without rewriting it and all instances)
12:56:33 <monochrom> hjulle: I see no problem. I have "instance C Int Bool", "f :: F C", and "x :: Int". I ask ":type unF f x" and get "Bool" successfully.
12:57:01 <hjulle> lyxia: Also, I'm not sure how to express them in an easy way with type families. The classes have this form: class c s t a b => A s t a b | s -> a, t -> b, s b -> t, t a -> s
12:57:45 <hjulle> I mean: class  A s t a b | s -> a, t -> b, s b -> t, t a -> s
12:58:08 <cocreature> let me guess: the external library is lens
12:58:16 <monochrom> I now also have "y = unF f x" without annotation, and I get no error, y becomes Bool inferred.
12:58:24 <hjulle> How could you guess? :P
12:58:47 <cocreature> hjulle: I’ve been stabbed a few times :)
13:00:26 <hjulle> Ok, actually, the problem is when they are not concrete types, but should still be unambigous relative to each other.
13:02:09 <hjulle> cocreature: Was that an intentional pun btw? :)
13:02:23 <cocreature> hjulle: yes :)
13:02:35 <monochrom> OK, GHC doesn't have a way to express that yet.
13:02:40 <cocreature> hjulle: wait you mean by stupid joke or the names in lens?
13:02:58 <monochrom> the "stab" part.
13:03:07 <EvanR> pun (n.) a stupid joke
13:03:08 <hjulle> Both?
13:03:18 <EvanR> pun punning
13:03:29 <cocreature> iirc it was more of an accident that lens ended up with those variables
13:03:40 <monochrom> "I have been stabbed a few times while working with s t a b"
13:04:00 <monochrom> @stab monochrom
13:04:01 * lambdabot would never hurt monochrom!
13:04:09 <Tuplanolla> I think `fgl` had `Gr a b` too.
13:04:14 <monochrom> Oh hehe. But you can try it again.
13:05:14 <monochrom> "no monochrom was harmed in the making of lambdabot"
13:14:36 <`Guest00000> everybody says "lists are deadly"
13:14:48 <Tuplanolla> When ingested, yes they are.
13:15:16 <`Guest00000> but can we optimize the actual runtime lists away in the compiler?
13:15:32 <EvanR> already happening my dude
13:15:44 <`Guest00000> nice
13:16:47 <hjulle> Google "haskell list fusion" for more info on the topic
13:17:10 <`Guest00000> so, can i generate like a big list of numbers, then write them all into a memory buffer with Ptr and IO, so that there are no actual lists at runtime?
13:17:23 <`Guest00000> and all generated numbers do directly to the buffer
13:17:25 <`Guest00000> go *
13:18:00 <EvanR> we should try that experiment and look at the core output
13:18:47 <Tuplanolla> It's at least certain that the whole list won't be around at any point.
13:19:29 <vektorweg1> should i require e.g. to supply a predicate or can i just return a infinite list? 
13:19:30 <EvanR> forM_ (take 10000 fibs) (pushFFI pptr)
13:21:02 <EvanR> and if that looks bad, chunk fibs, pick chunks, and post the chunks one after the other thorugh IO
13:21:12 <EvanR> pack chunks*
13:21:16 <EvanR> then look at the core for that
13:32:54 <hjulle> `Guest00000: If you are curious about how it is implemented, you can see it here: https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#build. Basically, all functions that constructs lists uses build and all functions that consume lists uses foldr. When the compiler sees them together, they are fused together (according to the {-# RULES -#}) and no list is created.
13:38:02 <neoncontrails> I hope this question isn't gauche. I'm constructing a somewhat large object model at runtime, and I'm trying to be a little conservative with 'pure' functions that return an entirely new object. Clojure probably isn't the right tool for the job, but I'm drawing some inspiration from wikipedia articles about this great thing you call 'applicative functors'. Are there any Python implementations of an object that 
13:38:02 <neoncontrails> satisfies the major conditions of applicative-functorness?
13:39:15 <Tuplanolla> I don't see how those concepts are related, neoncontrails.
13:41:42 <erisco> neoncontrails, Applicative is more like an interface, but static
13:42:08 <erisco> neoncontrails, it really has nothing to do with memory allocation
13:42:33 <erisco> or however else you qualify "an entirely new object"
13:42:44 <monochrom> Applicative has nothing to do with OOP.
13:43:28 <monochrom> I don't know whether someone coded it up in Python. But I know that however you code it up, Python's nature makes it unusable.
13:43:52 <monochrom> For starters, look at how anonymous functions are second class in Python.
13:45:41 <hjulle> neoncontrails: If you make sure that all operations on the object are pure, you can safely use references and shallow copy, which means that copying is fairly cheap.
13:45:47 <neoncontrails> Tuplanollo: I have my learning cap on, so it's possible I've misunderstood something. As far as I can tell the applicative functor doesn't return a brand new instance of an object, it returns an iterable and reduces it with the original object... not quite in-place, but not completely immutable either
13:47:06 <erisco> uh, either we're talking about completely different "applicative functor" or your understanding is a mile off
13:48:10 <monochrom> Not even wrong.
13:48:28 <erisco> so, applicative functors are realised by the Applicative class, in Haskell
13:48:42 <monochrom> Immutable OOP and Applicative are on two orthogonal axes.
13:49:05 <erisco> Haskell classes are unlike OOP classes but they're vaguely like interfaces, but unlike interfaces they are not types
13:49:06 <monochrom> You wouldn't even say "the x axis and the y axis are a mile apart". They are not even on the same axis.
13:49:47 <monochrom> And "iterable" would be more like Foldable than Applicative.
13:49:50 <hjulle> neoncontrails: Where did you read about it?
13:50:13 <erisco> but anyways, Applicative consists of two things: "pure" and "ap", or the latter is also named <*> in Haskell
13:50:40 <monochrom> The problem with armchair philosophy.
13:50:44 <erisco> so, if we're talking about Applicative all we're talking about is "pure" and "ap" and nothing else
13:51:56 <erisco> nothing in there about iterators or objects or other things
13:52:05 <neoncontrails> hjulle: I'm currently digging into this post, which is auspiciously illustrated with JS code: https://drboolean.gitbooks.io/mostly-adequate-guide/ch10.html#coordination-motivation
13:53:22 <erisco> "not all JavaScript" but be highly cautious of learning of functional practices and terminologies from non-functional languages
13:53:31 <monochrom> They even use wrong wording such as "two functors (of the same type)".
13:53:50 <neoncontrails> (I plan to dive into Haskell soon, but I'm not really knowledgeable enough about Haskell syntax to make sense of... most functor-related documentation)
13:53:59 <erisco> you can find functional programmers who are having a boo in JavaScript or Python or whatever, but you also have many programmers with a tepid understanding who then get a lot wrong
13:55:08 <MitchellSalad> erisco: plus "fmap"
13:55:12 <erisco> there is a tendency to scrape ideas off the surface and mangle them...
13:55:14 <ab9rf> this discussion is making my head hurt
13:55:41 <Tuplanolla> That happens every time more than two people participate, ab9rf.
13:55:43 <monochrom> Unscientific postmodern people do that all the time.
13:55:48 <MitchellSalad> though i suppose fmap = ap . pure
13:55:58 <ab9rf> Tuplanolla: well, could also be the inner ear infection i have
13:56:36 <monochrom> haha
13:56:40 <erisco> MitchellSalad, that's right, and if those are not functionally equivalent then it is wrong
13:57:07 <erisco> :t fmapDefault
13:57:08 <lambdabot> Traversable t => (a -> b) -> t a -> t b
13:57:22 <ab9rf> just some of the stuff in the last few screens bordered on incoherent
13:57:24 <erisco> oh, hm, well maybe there is an Applicative one out there
13:57:55 <monochrom> fmapDefault is a way to say that a Traversable is a Functor.
13:58:01 <ab9rf> at least to me
13:58:26 <neoncontrails> Heh. I'll ask a different question then. If you were to recommend a good starting place for someone who's pretty comfortable with the SICP branch of functional programming, but not at all familiar with the Haskell approach. Where would you recommend?
13:59:09 <monochrom> The Gentle Introduction to Haskell.
13:59:34 <monochrom> Or maybe it's called Haskell: A Gentle Introduction? I forgot.
13:59:39 <Tuplanolla> This once I'd say Learn You a Haskell, neoncontrails.
14:00:20 <hpc> the main disadvantage of LYAH is a lack of exercises
14:00:45 <hpc> other than that, it teaches concepts in the right order and is easy to read
14:00:46 <jared-w> My default recommendation is "Haskell from first principles". The main disadvantage of LYAH is that it's just not really a good learning resource; it never really was and now it's outdated on top of that
14:01:26 <MitchellSalad> I thought LYAH was good
14:01:36 <MitchellSalad> back in 2013ish when i first read it
14:01:44 <greeny> neoncontrails: Haskell from first principles is the way to go -> http://haskellbook.com/
14:01:50 <glguy> if you're going to buy something there's Programming in Haskell
14:01:51 <Tuplanolla> If you just finished SICP, you don't need much hand holding to get started.
14:02:01 <monochrom> I think it's good for people who create exercises for themselves.
14:02:02 <neoncontrails> Thanks for the recommendations, also the warnings. Has Haskell changed a lot since 2011?
14:02:14 <MitchellSalad> the fundamentals haven't changed
14:02:15 <neoncontrails> (Breaking changes, I mean)
14:02:28 <MitchellSalad> hardly any, only the FTP comes to mind
14:02:29 <monochrom> Meaning, people who are not vulnerable to the Dunning-Kruger effect.
14:02:45 <erisco> GHC is beyond the spec... has been several extensions made
14:02:59 <greeny> neoncontrails: Monads are Applicative now
14:03:02 <monochrom> But over the past decade, I horrifiedly learn how big the majority of people who are vulnerable.
14:03:54 <glguy> yes, majorities can be huge!
14:04:14 <monochrom> Well it was 51% vs 90%.
14:04:45 <ab9rf>  a stupormajority
14:06:27 <systemfault> Not being vulnerable to the Dunning-Kruger effect can be a negative thing... no?
14:06:48 <monochrom> Why?
14:07:05 <monochrom> I mean apart from the agony of living among those who are.
14:07:06 <systemfault> Because it would cause you to underestimate your habilities
14:07:09 <hjulle> What do people think about "What I wish I knew when learning haskell"? It's not really a tutorial or text book, but a lot of supplimentary tips and material.
14:07:38 <monochrom> Yeah, got to watch out for that too.
14:07:45 <erisco> I wish I knew I'd become unemployable
14:07:52 <jared-w> You can't really say that someone can be invunerable to the Dunning-Kruger effect... The point of the effect is that it's just pointing out how the human brain tends to extrapolate from incomplete information and does so fairly terribly
14:08:05 <Joe-R> why are you unemployable?
14:08:44 <monochrom> More pedantically, Dunning-Kruger already includes the experts-too-modest side. But more honestly, I was focusing on the beginners-too-confident side, so yeah.
14:08:50 <Tuplanolla> It's long enough to be unreadable and, in my experience, it's not reliable enough to serve as a reference, hjulle.
14:09:57 <erisco> Joe-R, because I now have to apply functional practices and not many jorbs afford that
14:10:07 <hjulle> I currently have a job. I write PHP code. :(
14:10:15 <ab9rf> my condolsences
14:10:24 <ab9rf> condolences
14:10:53 <ab9rf> i'm so thoroughly unemployable that i simply don't care
14:11:07 <jared-w> Haskell is the lotus from greek mythology
14:11:29 <monochrom> Wait, there is lotus in Greek mythology?!
14:11:29 <ab9rf> no harm in learning something else that will just make me that much more unemployable.
14:11:30 <neoncontrails> Are there Haskell programmers who exhibit Dunning-Krueger effects? My impression is the language is so maximally strict, only the Haskell-savvy ever make it out of compile time
14:11:31 <jared-w> Once you taste of it, you never wish to taste anything else ever again :p
14:11:53 <jared-w> neoncontrails: That's really not true. Everyone exhibits Dunning-Krueger effects at some point
14:12:30 <monochrom> Depends on how many people you include in "Haskell programmers".
14:13:05 <erisco> neoncontrails, the path from Haskell to theory and mathematics is clear, and not by accident, so really I find it easy to be humbled by how much I have yet to study
14:13:51 <EvanR> somehow the lotus comment made me think of narcissus
14:14:17 <jared-w> Well it was a common theme in greek mythology so that's not surprising :p
14:14:53 <EvanR> a bad ass industrial programmer walked by haskell and couldnt help but stop and look, and was never heard from again
14:15:20 <neoncontrails> erisco: I know exactly how you feel. I know there's a bigger picture I'm not cognizant of, but lately my google searches have been inchincg closer and closer to category theory
14:15:32 <monochrom> Let's combine the lotus thing with the narcissus thing.
14:15:50 <ab9rf> we need a seed transfornmer for that
14:16:04 * hackage sensu-run 0.1.1.3 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.1.1.3 (MitsutoshiAoe)
14:16:12 <jared-w> Mine are category theory, programming language theory, dependent types (and type theory in general), functional logic programming, etc :p
14:16:17 <monochrom> Someone with well-developed muscle one day discovered that he tasted so good he ate himself. We never heard from him since then.
14:16:26 <jadrian> jared-w: greeny: looked at haskellbook.com, things like this really put me off "Monad (SPOOKY? No.)"
14:16:33 <EvanR> lol
14:17:13 <jadrian> I don't know, maybe it's edgy and some people like edgy
14:17:23 <erisco> neoncontrails, CT is one way, a tool, and useful. Just consider that there are proof assistants like Coq which can encode and verify mathematical theorems
14:17:39 <jared-w> The haskellbook leans into slightly unprofessional levels of casual. But, keep in mind, it's written specifically for people who have never programmed before, ever. That being said, it's written well enough and it's comprehensive enough that it remains one of the best learning tools out there for starting haskell regardless of pre-existing programming knowledge
14:18:22 <monochrom> "(SPOOKY? No.)" should be reserved for a chapter on phantom types. :)
14:18:36 <ab9rf> why would monads be spooky?
14:18:42 <WhiskyRyan> Does anyone here use haskell-mode for emacs? I can get C-c C-l to work if I run inf-haskell-mode, but I can't figure out the "new" interactive-haskell-mode. The latter puts a buggy prompt in my source code? 
14:18:47 <monochrom> The monad one is better off with "(MATHY? No.)"
14:18:51 <jared-w> Because the internet has famously blown haskell way out of proportion
14:18:57 <neoncontrails> erisco: SICP at my school devoted a whole module to logic programming, I've been enamored of it at a distance ever since
14:19:05 <jadrian> sure, I get the idea, seems somewhat infantile though, and just because someone's a beginner doesn't mean they'll appreciate that approach
14:19:07 <jared-w> and particularly monads (DAE "muh burrito")
14:19:11 <jadrian> but maybe it's just me, I don't know
14:19:33 <glguy> jadrian: It sounds like it's just not targetted at you; there are other resources
14:20:04 <jadrian> glguy: true, indeed I'm sure some people will like it
14:20:09 <erisco> neoncontrails, so the connection is broad and strong... I can't think of the perfect words but CS is like the study of the mechanical elaboration of mathematics
14:20:21 <EvanR> people who have never programmed before ever but are aware of the spookiness of monads
14:20:30 <EvanR> skeptical
14:20:30 <dibblego> monads have been explained poorly, historically
14:20:32 <neoncontrails> erisco: I especially liked Friedman's "Little Logician" primer, when I ran into Datomic another 2 years later it was practically deja vu
14:20:43 <tombert> howdy all; I have a conduit stream of some data I'm processing; what's the best way to do a streaming http response?  I would prefer to use Wai but I'm not married to it
14:20:58 <monochrom> erisco: I think Turing would agree.
14:20:59 <erisco> neoncontrails, you can describe things uncomputable with mathematics but the descriptions themselves you can work with
14:21:40 <neoncontrails> I feel strangely warm and fuzzy when I think on that fact too
14:21:48 <jadrian> jared-w: indeed that's true but I don't know if the opposite reaction is necessary, talking about spookiness and what not won't make it simple any simpler, in the end what matters is how they wrote the chapter
14:21:51 <Ulrar> Mh, is there a Int -> String function somewhere ?
14:22:00 <Ulrar> Show adds quotes, it's annoying
14:22:39 <EvanR> no it doesnt
14:22:40 <bno1> Ulrar: maybe you use print instead of putStrLn when printing the string?
14:22:47 <Ulrar> I'm not printing it
14:22:58 <monochrom> show doesn't add quotes. It's ghci doing it.
14:22:58 <EvanR> > elem '\"' (show 3)
14:23:00 <lambdabot>  False
14:23:03 <bno1> print adds quotes to strings
14:23:04 <dibblego> Ulrar: it doesn't add quotes, it's the Show for String that does, when you use ghci
14:23:05 * hackage viewprof 0.0.0.3 - Text-based interactive GHC .prof viewer  https://hackage.haskell.org/package/viewprof-0.0.0.3 (MitsutoshiAoe)
14:23:06 <Ulrar> I'm using ++ to append it to an other string that get queried using http-conduit
14:23:34 <EvanR> maybe you are showing a string
14:23:37 <monochrom> Show actual code? I bet you you wrote print(show 5)
14:23:50 <Ulrar> Mh, something weird is happening then
14:23:52 <EvanR> > show (show 3)
14:23:54 <lambdabot>  "\"3\""
14:24:03 <Ulrar> monochrom: Again, I'm not printing it
14:24:10 <jadrian> dibblego: I would rephrase that to "monads have been explained poorly to programmers"
14:24:13 <monochrom> So show actual code?
14:24:13 <dibblego> > "abc" ++ show 7 ++ "def"
14:24:15 <lambdabot>  "abc7def"
14:24:24 <Ulrar> I thing the error might come from Aeson, now that I look at it
14:24:44 <jadrian> dibblego: monads were explained as well as any other categorical structure 
14:24:55 <dibblego> jadrian: the practical purpose of monads, for programming, has been explained poorly, including silly metaphors, etc
14:25:05 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
14:26:28 <hjulle> tombert: Have you tried wai-conduit? Sounds like exactly what you want. https://hackage.haskell.org/package/wai-conduit
14:27:05 * hackage optparse-generic 1.2.1 - Auto-generate a command-line parser for your datatype  https://hackage.haskell.org/package/optparse-generic-1.2.1 (GabrielGonzalez)
14:27:27 <tombert> hjulle: I tried it but I'm having a bit of trouble making the types work
14:28:12 <jadrian> dibblego: I may be biased due to my background, but as of now I'm still convinced a mathematical (algebraic) approach is the way to go 
14:28:32 <hjulle> tombert: What type does your output data have? Bytestring?
14:28:47 <dibblego> jadrian: I agree, but then there is the practical part, which is to empathise with problems that programmers typically have
14:29:35 <tombert> hjulle: yeah, bytestring
14:29:40 <dibblego> jadrian: anything but a mathematical definition is dishonest and hindering. It serves no useful purpose.
14:29:46 <jadrian> dibblego: maybe people should care about that a bit more about than they do now when teaching calculus, and a bit less than they do now when teaching monads
14:30:15 <dibblego> jadrian: I have been saying this over 10 years now, and I cry every time I see a terrible "monad tutorial", join me, we can share tissues.
14:30:45 <Joe-R> what is a good monad tutorial then?
14:30:54 <monochrom> Phil Wadler's.
14:31:09 <jared-w> jadrian: why algebraic specifically?
14:31:28 <jadrian> dibblego: plenty of informatics courses seem to inherit all the typicall engineering math (mostly centered around calculus/analysis) and to teach it in a classical fashion
14:32:11 <dibblego> jadrian: I have only taught CS at undergrad level, and I wouldn't dare talking about monads in that environment. After class discussion only.
14:32:45 <jadrian> dibblego: and then a lot of the algebra and logic, that are arguably even more fundamental, are all taught "with the programmer in mind" (which usually means, badly)
14:32:49 <dibblego> jadrian: I run a local interest group. I am doing a talk on monad transformers tomorrow night. A lot of university undergrads are coming, but on their own volition.
14:33:08 <dibblego> I hired a couple recently actually, to help me write .hs
14:33:18 <jadrian> dibblego: you wouldn't dare talking about monads, but they are probably calculating crazy integrals, think about that
14:33:30 <dmj`> @google all about monads
14:33:32 <lambdabot> https://wiki.haskell.org/All_About_Monads
14:33:55 <dibblego> jadrian: sure, I would talk about it, but after class. They're not stupid, just that the environment is not conducive to such a discussion.
14:34:40 <hjulle> tombert: Hmm, yes. responseRawSource does have a strange type. Why does it have an input?
14:35:01 <jadrian> dibblego: my point is, if it is conductive to calculating integrals, it is conductive to talk about monads. Monads are actually much simpler, they only get integrals because of a foundation of years of calculus pre-university
14:35:21 <dibblego> jadrian: I argue, they are calculating integrals *despite* the environment, not because of it.
14:35:44 <dibblego> and yes, they are talking about monads, in their own head, during class, looking forward to the sessions after class, when we can share ideas.
14:35:50 <monochrom> Integrals --- the 1st-year ones --- are more concrete than monads.
14:36:25 <monochrom> But do talk to me again when all 1st-year students have to do differentiable manifolds (the abstract nonsense one).
14:36:27 <Tuplanolla> My experience has been that students don't really learn integrals in the first four years.
14:36:28 <jadrian> monochrom: they are abstract, you make them concrete with cencrete examples
14:36:52 <monochrom> No, they only ever do one concrete example, that is, R->R functions.
14:36:53 <Tuplanolla> They only learn a bag of tricks to for finding the definite integrals of some expressions.
14:37:14 <jadrian> monochrom: ok, but then your notion of concrete is R->R
14:37:46 <monochrom> As opposed to any monad lesson which involves "forall a b. M a -> (a -> M b) -> M b" and even that M has like five different incarnations.
14:38:00 <jadrian> monochrom: that's programming, not algebra
14:38:08 <monochrom> But like I said, do talk to me again when all 1st-year students have to do differentiable manifolds (the abstract nonsense one).
14:38:38 <monochrom> The algebraic story has "forall a. M (M a) -> M a" too, and like I said, even that M is not fixed.
14:38:39 <jadrian> monochrom: in my first year I did logic
14:38:51 <jadrian> monochrom: there's forall's there
14:39:20 <jared-w> Most of my formal logic classmates sucked at logic
14:39:35 <jared-w> It takes a long time to really internalize what forall really means and how to think about quantifiers
14:40:09 <monochrom> A logic course corresponds only to a type level story (if you are to compare with Haskell say).
14:40:10 <jadrian> jared-w: again, people take years of calculus before getting to university
14:40:34 <monochrom> Whereas calculus, differentiable manifolds, and monads all have both a type level and a value level.
14:40:35 * hackage turtle 1.3.6 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.3.6 (GabrielGonzalez)
14:40:35 <jadrian> monochrom: I was talking just about an algebraic notion of monad
14:40:44 <monochrom> Yes, me too.
14:40:46 <jadrian> monochrom: so, 
14:40:48 <jadrian> opss
14:41:01 <jared-w> uhh... not sure what you're talking about. In the US system, if you're doing calculus at all you do BC calculus in senior year of high school if you're an overachiever
14:41:17 <jared-w> and then you take the second semester of calculus in college
14:41:32 <jadrian> monochrom: much like you can study groups and rings and other algebraic structures (so restricting monads to a functional setting)
14:41:49 <jared-w> I also don't know why people taking years of calculus has something to do with monads
14:42:42 <monochrom> jared-w, jadrian is using it as a proxy to measure aptitude. And I say that this fails. I have stated a reason why calculus is inherently so much easier.
14:42:48 <jadrian> jared-w: I don't know what "BC" Calculus is... regarding relation with monads, the point is you slowly internalise the concepts 
14:43:11 <tombert> hjulle: Here, I'll just send you the code I"m trying to write and maybe you can see some obvious mistake: https://hastebin.com/yemuyasozi.hs
14:43:22 <hjulle> tombert: streaming-wai seems much easier to use. You can convert from conduit to a "streaming" stream with the streaming-conduit library.
14:43:54 <jared-w> Right. Well in the american education system you have half a year of learning wtf an integral is before college... But the vast majority of college students learn integrals for the first time in college, with no slow internalizing of concepts whatsoever
14:44:00 <jadrian> monochrom: I think the main reason it is "easier" is because we study a lot of calculus pre uni, calculus in the broad sense of  the domain of R->R 
14:44:29 <monochrom> I do see CS students getting really lost in a course of groups and/or rings. (They took it as an elective because the other electives were worse.) Even math students (the ones who entered math because they planned to be highschool teachers.)
14:45:09 <jared-w> jadrian: okay, what do you mean when you say calculus? I'm failing to see how there's a lot of study of it before university. What school system are you referring to?
14:45:18 <monochrom> Well, I have stated how the additional polymorphism is an additional hurdle.
14:45:56 <jadrian> jared-w: I was bradly speaking about working with R->R functions... you do study differentiation in highschool, and before that limits
14:45:57 <tombert> hjulle: is the streaming-conduit library different than the regular conduit libary?
14:46:00 <monochrom> The typical calculus course, even the 2nd year 3D one, doesn't have the same polymorphism. Not even any polymorphism, under most teachers who don't dare to generalize.
14:46:33 <jadrian> jared-w: you don't go deep on proofs or even formal definitions, but you spend a lot of time studying R->R functions pre uni
14:46:56 <jared-w> R->R functions aren't calculus?
14:47:17 <jadrian> jared-w: yes, that's what I'm saying, you play with R->R a lot pre uni
14:47:24 <jared-w> Figuring out what y = x^2 looks like on a graph doesn't really count as calculus to me
14:48:07 <jared-w> No you were saying that people do a lot of calculus before university. Now you're changing it to people have a lot of experience with R->R, which is true, nobody generlizes to polymorphism or abstractions before then because it takes a long time to build up that intuition
14:48:17 <jadrian> monochrom: but your point is that it's different, which I agree... you claim that's more difficult, perhaps I'd say a lot of the difficulty probably comes from the fact that you first see it in a very formal setting in hard courses in uni
14:48:47 <jared-w> (which kinda proves the whole point of monads being terrible to teach to freshman because they haven't gotten 12 years of exposure to buildling blocks required to understand monads)
14:49:00 <jadrian> monochrom: perhaps if students played with such polymorphic structures pre-uni, in a less formal setting, then it would be easier
14:49:29 <monochrom> Everyone who goes into a group theory course, by choice or coercion, should be extremely well-versed with integer addition and subtraction, a good example of groups, no?
14:49:52 <jared-w> Sure. Start people out with category theory and type theory in the second grade like we do with set theory and algebra and you'd see a much better understanding of monads amongst the lucky people who don't get burned and tortured by the school education system
14:49:55 <monochrom> But does that "pre-preparation" do any good to them?
14:50:04 <jadrian> monochrom: fair point
14:50:19 <monochrom> Piaget's theory and all. The generalization is the hard part.
14:52:04 <monochrom> So my theory is to flip your theory upside down. The schools teach calculus for years because it is about the only "advanced" thing it knows how to teach.
14:52:25 <jared-w> I'd say it's even simpler than that
14:52:30 <jadrian> monochrom: jared-w: in any case, I digressed too much... my main point was, difficult as it may be, perhaps it would be better to teach monads, applicatives et al in an algebra course along with other structures
14:52:57 <jared-w> The american education system started to teach the three R's necessary for being useful in the world (reading, 'riting', 'rithmetic)
14:52:59 <hjulle> tombert: (Streaming is an alternative to pipes and conduits. streaming-conduit is a library to convert between them.)
14:53:01 <monochrom> No! Differentiable manifolds is so much more interesting!  <duck>
14:53:04 <hpc> in an algebra course i would rather they teach groups and monoids
14:53:13 <hpc> (if we're limiting ourselves to CT things)
14:53:28 <jadrian> hpc: my point was, pack all those together
14:53:33 <hjulle> tombert: What type do you expect src to have in your code?
14:53:37 <jared-w> So, math and everything else is going to be taught in a way that's most immediately applicable to working your 9-to-5 job. That means engineering math and calculator math
14:53:49 <tombert> hjulle: it should just be bytestring
14:54:23 <dibblego> yes, but is 0.02 cents the same as 0.02 dollars?
14:54:49 <tombert> hjulle: can you link me to that library?  I'm having a bit of trouble finding it
14:54:54 <dibblego> jus kiddin' sorry, carry on
14:55:04 <monochrom> jared-w: I'm going to flip your theory upside down too. People apply calculus (or merely addition) because it is the only thing they figured out. :)
14:55:53 <jared-w> Well that's quite true as well :p we had calculus and geometry in the arabic golden age. Calculus again in the 1600s from Newton and Leibniz.
14:56:10 <monochrom> Take for example, HOL4. HOL4 is an interactive prover (or rather, proof checker). It has a proof-by-tactics library.
14:56:30 <hjulle> tombert: Not just bytestring. Try writing the full type explicitly and you'll probably get better error messages.
14:57:08 <tombert> well the error appears to be that it can't convert to a Flushed Builder
14:57:26 <monochrom> Half of its tactics library is in continuation-passing style, because half of the users like it that way. (And because, really, if you use two tactics in sequence, the 2nd could use some information from the 1st.)
14:57:48 <monochrom> I learned HOL4 before I learned Haskell and monads.
14:58:01 <jared-w> We didn't even get around to accepting that negative numbers weren't black magic until past 1759 :p
14:58:25 <monochrom> Actually how I learned them is tangential.
14:58:41 <hpc> before algebra, zero was state of the art math
14:58:45 <hjulle> tombert: And what is Builder?
14:58:52 <monochrom> But anyway, you have these CPS tactics. You can re-model them by a monad, no?
14:59:11 <monochrom> But the HOL4 authors surely didn't.
14:59:30 <tombert> hjulle: bytestring builder I think
14:59:38 <monochrom> The HOL4 people applied CPS but not monad because they knew CPS but not monad.
14:59:57 <jadrian> monochrom: how don't think it's how you learn them but how you don't learn them... the biggest problem I think, is that people think monads, or more generally classes "are about programming" and they are about properties
15:00:09 <hjulle> tombert: Try :i Builder in ghci or clicking on it in the online documentation
15:00:21 <EvanR> zero does throw a wrench into a lot of things, i could imagine some crazy person arguing to accept it while literally everyone pointed out why it was ssuch a bad idea
15:01:40 <hjulle> I was talking about: http://hackage.haskell.org/package/streaming-wai and http://hackage.haskell.org/package/streaming-conduit
15:03:36 <Tuplanolla> This would be the perfect time to rag on ZFC and its position in education, but I'm too tired.
15:04:15 <monochrom> At any rate I totally agree that CS should teach monoids and Kleene algebras.
15:04:25 <jared-w> Can you give a tl;dr? That sounds interesting :p
15:04:55 <jared-w> monochrom: my CS course contains a theory of computation class which goes over basic Kleene algebras.
15:04:59 <EvanR> wow i got completely out of undergrad math without hearing about ZFC at all (in class)
15:05:06 <monochrom> Do you mean that you are against universities letting students choose electives? :)
15:05:14 <EvanR> axiom of choice came up 3 times in real analysis
15:05:24 <jared-w> wut, how?
15:05:31 <Tuplanolla> It's a bad foundation for both fostering understanding and building formal systems.
15:05:45 <monochrom> Ah. I agree.
15:05:56 <jared-w> Although, actually, to be fair... I don't really remember people going over  ZFC very well (if at all) in classes. I just know about it
15:06:19 <monochrom> "everything can be encoded as a set" is obscuring. And set theory itself is not a great formal system anyway.
15:06:21 <Tuplanolla> Especially so, because it's treated as absolute truth instead of as a historical or philosophical topic.
15:07:08 <jadrian> Tuplanolla: how do you suggest it should be done though?
15:07:08 <monochrom> If anything I think it's mathematicians' conspiracy to use set theory as a strawman argument for "see I told you, formal systems are not worth it".
15:07:54 <hjulle> tombert: Otherwise, create a builder with fromByteString in http://hackage.haskell.org/package/blaze-builder-0.4.0.1/docs/Blaze-ByteString-Builder-ByteString.html and make some decision on when to flush.
15:08:01 <monochrom> Like, if I were teaching in a theology college, and I wanted to blackmouth atheism, surely I know how to teach a course called "intro to atheism" to achieve that!
15:08:06 <Tuplanolla> I suggest a nap, jadrian.
15:08:15 <jadrian> Tuplanolla: :)
15:08:33 <Tuplanolla> It's the same as operating systems courses being about Linux and little else.
15:09:13 <monochrom> Yes, they should use Minix instead.  <duck>
15:09:14 <EvanR> jared-w: LSU is, despite its recent attempts to disguise itself, a heavy agricultural and mechanical college. even the math departments theoretical courses keep it practical, and ZFC i now know isnt
15:09:31 <jared-w> ahh, makes sense
15:09:55 <monochrom> But operating system courses do run into this practical problem of "we can't quite take apart and patch Windows, much as we'd love to".
15:10:31 <monochrom> Approximately they only have 3 choices: Minix, Linux, homebrew. I have seen all 3. Don't try the homebrew way, not worth it.
15:10:48 <jared-w> I think a lot of operating systems courses use an early version of Unix becaue it's like 6,000 lines of code?
15:10:50 <EvanR> im now impressed how much math you can do without ZFC
15:11:11 <Tuplanolla> Don't forget Oberon, monochrom.
15:11:17 <monochrom> Well, unless your predecessors have already spent 10 years on homebrew so that the cost for you is low.
15:11:21 <jared-w> Big enough to study, not a toy OS, actually able to learn stuff, but not so big you get overwhelmed like the 13+ million lines of Linux or Windows
15:11:22 <monochrom> oops
15:11:31 <Tuplanolla> For historical perspective there's also Genera.
15:12:20 <monochrom> The lectures and tutorials can discuss all the varieties. But the course project can only afford to pick one and work on it.
15:12:25 <maerwald> what's wrong with BSD
15:13:11 <monochrom> Well maybe not. I guess the course project could be 5 case studies or something.
15:13:54 <monochrom> Anyway, do be sympathetic to the OS teachers, who are under much time constraint, can't really do both breadth and depth.
15:14:37 <monochrom> At my previous university, the OS course spanned 3 terms not 1 term. That's probably somewhat better.
15:15:07 <WhiskyRyan> What is a good book for learning to make haskell programs for someone with some functional and imperative programming experience already. I want to get right into creating projects and compiling code as I go... not just play with ghci and learning the functional programming style.
15:15:36 <monochrom> Oh, then try Real World Haskell
15:16:01 <Tuplanolla> A good operating systems course would discuss how to design an operating system that meets, say, these criteria: http://www.loper-os.org/?p=284
15:16:06 <monochrom> Or haskellbook.com. While it starts from scratch, it also talks about creating projects.
15:16:44 <Tuplanolla> It has to start from hardware.
15:17:00 <hjulle> tombert: To flush between every chunk, you can use something like awaitForever (\x -> do yield . Chunk $ fromByteString x; yield Flush)
15:17:13 <WhiskyRyan> Thanks monochrom. I'lll look those up.
15:34:34 * hackage bench 1.0.5 - Command-line benchmark tool  https://hackage.haskell.org/package/bench-1.0.5 (GabrielGonzalez)
15:39:05 * hackage postgrest 0.4.2.0 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.4.2.0 (begriffs)
16:05:33 <orion> Is it possible to use stack with the LTS resolver and GHC 8.2?
16:06:22 <WhiskyRyan> Anyone know of any haskellbook offer codes? 
16:06:24 <hjulle> orion: Do you mean 8.02?
16:06:31 <hjulle> *8.0.2
16:07:27 <orion> No.
16:07:48 <Welkin> there is no GHC 8.2, so you must mean 8.0.2
16:08:13 <Welkin> if there is an LTS version of stackage for 8.0.2, then yes
16:08:16 <Welkin> if there is not, then no
16:08:41 <orion> Welkin: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.2.1
16:08:46 <geekosaur> 8.2.1 is still in prerelease, there won't even be a nightly for it much less an LTS
16:09:31 <orion> Right, but can you override the version of base LTS or nightly uses and keep everything the same?
16:10:07 <geekosaur> probably. it's not how stack is intended to be used, though, and if it breaks you likely get to keep the pieces
16:10:41 <geekosaur> and it won't help you do it, you'll be fighting it the whole way
16:11:00 <geekosaur> in particular: the compiler version is part of a release for a reason.
16:11:15 <orion> Ok.
16:13:04 <geekosaur> (I would expect anything using Typeable or anything based on it to need adjustment, for starters.)
16:18:33 <jared-w> https://gist.github.com/tfausak/a36862c53a2cc53029cab18a05788b95
16:18:47 <jared-w> Test GHC 8.2.1-rc1 with Stack.
16:19:39 <jared-w> https://www.reddit.com/r/haskell/comments/64he68/announce_ghc_821_release_candidate_1/ relevant thread. orion 
16:21:27 <jared-w> OT: I've determined that roughly 60% of the conversation on r/haskell happens whenever someone posts a "haskell sucks" thread
16:22:26 <orion> jared-w: Thanks. I found this too: https://github.com/Soostone/uri-bytestring/commit/0ae57c7d72dd16169838b8636b8866d77cf0ad6b
16:22:56 <jared-w> That's using the alternative method in one of the reddit comments
16:23:14 <jared-w> (ie, setting the resolver and compiler manually and then setting every single extra-dep manually)
16:24:02 <orion> Do you know where that datestamp came from? Is there a way to test for other valid datestamps?
16:24:56 <orion> "resolver: ghc-8.2.0.20170507"
16:26:31 <jared-w> First guess: it comes from the timestamp of ghc commits to the 8.2 rc branches on the code repo?
16:34:27 <`Guest00000> are there libraries for "enhanced functions"?  objects which can be lowered to normal functions and evaluated,  which can be created by lifting normal functions, but also have other operations defined for them apart from any composition operations
16:35:05 <`Guest00000> e. g. symbolic numeric computation
16:38:05 <monochrom> None for general purpose. We tend to tailor-make an algebraic type for each specific purpose.
16:38:23 <`Guest00000> what are ready examples?
16:38:31 <monochrom> In the case of specifically polynomial and/or power series, we tend to use list-of-coefficients.
16:38:36 * hackage morte 1.6.8 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.8 (GabrielGonzalez)
16:39:00 <monochrom> This: http://www.cs.dartmouth.edu/~doug/powser.html
16:39:57 <monochrom> The CIS 194 course also has homework having students re-do all that.
16:40:19 <monochrom> I don't know of other examples for other classes of functions.
16:40:42 <monochrom> Actually maybe I know. There are free monads.
16:41:34 <monochrom> There is a library called "free" for all free monads, and a "free-game" for one free monad specifically for interactive games.
16:42:37 <hjulle> There are plenty of libraries for explicit lambda-expressions and algebras and stuff. These can be used to express "enhanced functions".
16:42:52 <monochrom> Ah, that too.
16:43:26 <`Guest00000> thanks
16:43:56 <`Guest00000> monochrom: numerical operations on lists is funny
16:44:27 <monochrom> Well, it is really adding two power series, not adding two lists. The listness is an implementation detail.
16:44:59 <`Guest00000> that article is cool
16:46:11 <hjulle> Basically anything that has an evaluate function can be seen as an enhanced function. (E.g. most EDSLs)
16:46:12 <monochrom> A more type-disciplined way is to define your own list type so as to not confuse with standard list. data Series a = Constant a | TimesXPlus a (Series a)
16:46:46 <monochrom> Hmm, the name "TimesXPlus" is poorly chosen.
16:47:27 <`Guest00000> mmm
16:47:35 <monochrom> Better call it: a `PlusXTimes` (Series a)
16:47:36 <`Guest00000> i mean
16:47:55 <`Guest00000> i need something which  can implement certain compositions more efficiently
16:48:23 <`Guest00000> not just any operations
16:48:25 <monochrom> Ah. I don't know how to do that.
16:48:29 <`Guest00000> and which has lift as well
16:49:41 <monochrom> lift is impossible. Haskell does not let you examine code. Not even if you're settled on GHC.
16:49:45 <`Guest00000> example: Integer -> Integer "functions" which also store offset (addend) to argument and offset to result, which allows to apply "shift" operations to them a lot of times and still have O(1) evaluation
16:49:59 <hjulle> `Guest00000: What operations do you have? What kind of transformations do you want to do?
16:50:11 <`Guest00000> i just want to see any like libraries
16:52:16 <`Guest00000> monochrom: can't we just make a special constructor for lifted functions?
16:52:36 <`Guest00000> of course, using it will lower performance guarantees
16:52:45 <hjulle> `Guest00000: Profunctor is one nice abstraction for function-like objects. Free is an easy way of building expression trees which you can process.
16:53:41 <monochrom> No, GHC simply doesn't expose a special constructor for functions.
16:54:13 <`Guest00000> monochrom: in the type you lift to!
16:54:57 <hjulle> data EFunction a b = Pure (a->b) | OtherStuff
16:55:44 <monochrom> That direction has downsides such as pollution.
16:57:17 <hjulle> What kind of pollution are you talking about?
16:57:56 <monochrom> Suppose you have data Series a = Constant a | PlusXTimes a (Series a) | Unknown (a -> a)
16:58:13 <monochrom> Then the Unknown case is viral.
16:58:27 <hjulle> ah, right
16:59:42 <hjulle> data EFunction a b = EFunction (a->e) OtherStuff (x->b) or something might be better
17:01:46 <`Guest00000> monochrom: only if you try to force structure early
17:02:08 <`Guest00000> wait
17:02:13 <hjulle> But it depends on what you are trying to build and what operations you want to support. If you are building an expression tree, then having a (a->a) case might be ok, we'll just have to optimize the rest.
17:02:24 <`Guest00000> forget that
17:02:39 <monochrom> It is OK or terrible depending on your other needs.
17:04:32 <hjulle> Yes, exactly.
17:04:35 * hackage mercury-api 0.1.0.1 - Haskell binding to Mercury API for ThingMagic RFID readers  https://hackage.haskell.org/package/mercury-api-0.1.0.1 (ppelleti)
17:16:30 <sm> wow, getting started with basic json parsing should be easier
17:16:57 <`Guest00000> exact real functions have the nice property that operations on them can be defined by a simple recursive definitions without base cases. are there any other number representations with this property?
17:19:06 <sm> what's the simplest way to parse https://gist.github.com/simonmichael/60609499dcf694827e85a02a2321b06a ? I'm currently hung up on writing the FromJSON instance since the keys vary
17:21:03 <ReinH> sm: parse it into Maps?
17:22:04 <ReinH> Say, Map Text (Map Text Double)?
17:22:31 <hjulle> sm: How about data Price = BTC USD | ETH USD | LTC USD and data USD = USD Double and derive the instances? (I have not tried it)
17:22:54 <geekosaur> could also parse it to Object and pull it apart that way
17:23:28 <sm> that sounds right ReinH. The symbols aren't known in advance hjulle 
17:23:36 <hjulle> ok
17:24:22 <`Guest00000> hjulle: why not newtype for USD?
17:24:42 <pacak> `Guest00000: I suspect there might be other currencies.
17:24:43 <hjulle> forgot
17:26:24 <sm> decode json :: Maybe (Map Text (Map Text Double))) gets it parsed, at least - thanks ReinH
17:26:48 <ReinH> Sometimes return type polymorphism is magic.
17:26:58 <sm> later I'll figure out how to parse it directly to some other-shaped application type
17:27:13 <pacak> I'm pretty sure Map Text Double is not what you want.
17:27:38 <sm> no, to Decimal now 
17:27:47 <pacak> It should be either sum type USD Double | KRW Double, etc or (Text, Double).
17:28:12 <pacak> Map Text Double allows you to have multiple currencies or zero currencies.
17:28:31 * sm watches the packages and imports multiply for this quick haskell rewrite of a shell one-liner
17:29:37 <pacak> sm: haskell rewrite is less likely do something stupid. https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/issues/123
17:30:22 <sm> no FromJSON instance for Decimal
17:30:28 <sm> pacak: eh ?
17:31:00 <pacak> Just an example of what can go wrong with shell programming.
17:31:17 <sm> lol, I'm at 70 lines, not giving up
17:36:05 <hjulle> Out of curiosity, what does the script do?
17:40:29 <sm> hjulle: it's supposed to download a few cryptocurrency prices and print them in a certain format
17:40:37 <sm> here's the current progress: https://gist.github.com/simonmichael/90aa4866e255a7f3701ee43d577022f5
17:41:27 <sm> I think json in haskell is harder than it looks (and maybe json in general)
17:42:09 <hjulle> If you want quick and dirty, you can always just use plain Value objects. ;)
17:42:39 <pacak> Working with messy and unshaped data is generally harder in strictly typed languages.
17:42:57 <sm> hjulle: would you have a quick example ?
17:43:21 <hjulle> http://dev.stephendiehl.com/hask/#json
17:43:33 <sm> pacak: I don't think we should accept that
17:44:15 <sm> hjulle: great link, thank you
17:46:19 <pacak> sm: Suppose you have a json object you got from this website. In javascript you could tell foo.BTC.USD to get usd price of BTC. If foo is a bit strange - javascript will simply explode in your face. Haskell and other strictly typed languages forces you to confirm that things are what you expect them to be.
17:47:23 <sm> sure, but we should be able to easily handle unstructured data (that we expect) also
17:47:49 <pacak> Nothing stops you from doing something like let (☭) = HashMap.findDefault undefined and type foo ☭ "BTC" ☭ "USD" to get similar code...
17:47:51 <hjulle> sm: One effective library for handling unstructured data is "lens". It's a bit complex and takes a while to get used to, but you'll basically get back the oo foo.BTC.USD syntax.
17:48:03 <pacak> But it will also explode in your face.
17:48:03 <sm> and I'm sure we can, it's just not that easy to learn how
17:48:51 <pacak> Or you can use safe lookups and Maybe monad, but in this case you'll end up with a value packed in Maybe.
17:50:10 <sm> I have to leave, but this info will help me get there next time. Thanks all!
17:50:18 <hjulle> sm: Ok, it's not that complicated to use. https://hackage.haskell.org/package/lens-aeson-1.0.1/docs/Data-Aeson-Lens.html
17:50:37 <hjulle> The examples there are pretty easy
17:51:03 <sm> great, thank you
17:54:09 <`Guest00000> pacak: laughed at ☭.
18:17:37 <orion> hmm
18:19:00 <orion> I'm trying to compile the master branch on cabal-install, but certain libraries aren't building. The HTTP library complains: Setup: Encountered missing dependencies: base >=4.3.0.0 && <4.10, time >=1.1.2.3 && <1.7
18:19:25 <orion> Now, I could easily manually bump the versions, but is there a better way?
18:19:49 <pacak> --allow-newer=base
18:20:26 <orion> Ah! Excellent.
18:20:59 <orion> (This is from the bootstrap.sh script)
18:32:03 <`Guest00000> how to represent multi-valued functions?
18:32:13 <erisco> return a tuple
18:34:42 <`Guest00000> i mean numerical functions which can return 0, 1 or more numbers
18:34:46 <monochrom> A tuple or a list, depending on what you mean.
18:35:15 <monochrom> Even a custom-made algebraic type.
18:37:51 <`Guest00000> i want to take the inverse of pointwise addition of inverses of such functions efficiently
18:38:43 <`Guest00000> errr, not "such functions", "functions that i need"
18:39:52 <erisco> okay, try Map a (Set b)
18:47:10 <leshow> http://lpaste.net/356173 
18:47:29 <leshow> is there any way i can define an applicative or monad instance for Action so that i can do something like
18:47:41 <leshow> openfile <$> path action <*> mode action
18:48:29 <erisco> yes, Action is Applicative and Monad
18:49:18 <leshow> I was trying to write it but i oculdn't figure out what my pure function should return
18:49:34 <glguy> erisco: it is? What's pure ?
18:50:04 <leshow> and if i added a Nil case, that would be okay i guess
18:50:13 * erisco double checks applicative laws
18:50:25 <leshow> but if i have Encrypt f <$> a im not sure what that would be either
18:50:32 <leshow> <*> sorry
18:51:36 <glguy> erisco: I don't think it's Applicative like leshow is hoping
18:51:48 <glguy> we'd have to have it do something like promote to Encrypt if either side was Encrypt
18:51:55 <glguy> and collapse to Nil if either side was Nil
18:52:35 <leshow> maybe it would be easier if i just put an action in the Vigenere record?
18:52:47 <glguy> with pure = Decrypt
18:54:01 <leshow> I was hoping there was some way I could write it in the applicative style though
18:54:28 <erisco> I don't see an obvious law violation... would have to implement and mechanically verify to be sure
18:54:49 <erisco> I think leshow has a bigger problem though
18:54:50 <glguy> Yeah, looks like we can make one, it jsut won't be useful
18:55:00 <leshow> erisco, what's that
18:55:23 <erisco> well it sounds like you were hoping Applicative solved some other problem
18:56:24 <leshow> i just thought if i had an applicative and monad instance i could 'reach in' and get the path and mode, then and unwrap the action in do-style notation. maybe i didn't think it through though
18:56:42 <erisco> what is Action supposed to be
18:56:58 <leshow> whether you encrypt the file or decrypt the file
18:57:06 <erisco> what file?
18:57:16 <erisco> and what is Nil?
18:57:19 <leshow> get's parsed from cli
18:57:58 <erisco> what is the purpose of the type 'a' component?
18:57:59 <leshow> that was stuffed in there when i was trying to write an applicativ einstance
18:58:05 <hjulle> sm: Here is a one-liner using wreq and lens for getting and parsing the json:  Network.Wreq Control.Lens Data.Aeson.Lens> itoListOf (responseBody . members <. key "USD" . _Number) <$> get "https://min-api.cryptocompare.com/data/pricemulti?fsyms=BTC,ETH,LTC&tsyms=USD"
18:58:18 <leshow> I think perhaps just having an action field in Vigenere would be sufficient
18:58:25 <erisco> or field, whatever your terminology... I call them components
19:01:04 <erisco> maybe back to the top... we read a file path and whether to encrypt or decrypt
19:01:16 <erisco> so why don't we just have  data Action = Encrypt | Decrypt
19:01:37 <leshow> this is what i have now
19:01:38 <erisco> then  case action of Encrypt -> {- encrypt a thing -}; Decrypt -> {- decrypt a thing -}
19:01:51 <erisco> no, you have   data Action a = Encrypt a | Decrypt a | Nil
19:02:18 <leshow> I don't mean in the lpaste, I've been working on it while we've been talking, one sec
19:02:50 <erisco> I can understand if you're trying to make an edsl, a representation of an instruction to encrypt or decrypt a file
19:03:49 <erisco> then   data Action = Encrypt Vigenere | Decrypt Vigenere   or you can normalise this
19:04:15 <leshow> wow lpaste through an exception
19:04:35 <leshow> threw*
19:05:24 <hjulle> sm: Wreq has good tutorial: http://www.serpentine.com/wreq/tutorial.html
19:06:49 <leshow> http://lpaste.net/356173
19:07:01 <leshow> erisco, does that look better
19:07:27 <erisco> I don't know what a Vigenere is but seems strange to have an Action on it
19:07:43 <leshow> it's a simple cipher
19:08:15 <erisco> try and be specific
19:08:39 <erisco> you don't mean it is the algorithm or method of cipher
19:08:46 <leshow> I'm just making a small cli app that encrypts or decrypts a file
19:09:15 <erisco> I am just trying to have you pinpoint what a Vigenere is
19:09:37 <leshow> a record that holds a path and an action to be done to it
19:09:53 <erisco> before it looked like a file handle
19:10:36 <leshow> Oh. yeah. I suppose that's true
19:10:47 <erisco> okay, that's fine then, though maybe the name is odd now
19:11:13 <erisco> and I am not sure what IOMode is doing in there
19:11:17 <leshow> If you have an suggestion I'm happy to listen, I'm just learning
19:11:34 * hackage pgdl 10.8 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.8 (sifmelcara)
19:11:43 <leshow> they are both the same mode now, one will be read the other will be write eventually
19:11:57 <erisco> isn't that determined by the action?
19:12:08 <leshow> yes
19:12:18 <erisco> well then we don't need IOMode :)
19:12:38 <leshow> good point lol
19:14:28 <leshow> thanks for your help erisco 
19:14:35 <erisco> so, it is a file path (we can consider this equivalent to the contents of) and the action to encrypt or decrypt the contents using Vigenere
19:14:53 <leshow> I think it just need an Action
19:15:00 <leshow> and no Vigenere, since there isn't much there anymore
19:15:14 <erisco> okay, well, just depends on what you're trying to represent :)
19:15:50 <erisco> you can probably just read the file path and action strings and do the rest without any type defs
19:18:02 <erisco> leshow, in this circumstance I was thinking of Vigenere as a type of expression and what it means
19:19:01 <erisco> so  Vigenere "foobar.txt" Decrypt  would mean the contents of foobar.txt (which is just a string) decrypted under Vigenere
19:19:34 <erisco> once you figure that out then you write an interpreter
19:19:50 <erisco> eval :: Vigenere -> IO String
19:20:05 * hackage throwable-exceptions 0.1.0.0 - throwable-exceptions gives the exception's value constructors  https://hackage.haskell.org/package/throwable-exceptions-0.1.0.0 (aiya000)
19:20:07 * hackage tweet-hs 0.5.3.13 - Command-line tool for twitter  https://hackage.haskell.org/package/tweet-hs-0.5.3.13 (vmchale)
19:20:40 <erisco> then we can start thinking about extending this language with more operations
19:21:09 <erisco> as-is it seems a bit frivolous
19:23:05 * hackage throwable-exceptions 0.1.0.1 - throwable-exceptions gives the exception's value constructors  https://hackage.haskell.org/package/throwable-exceptions-0.1.0.1 (aiya000)
19:27:24 <leshow> erisco, isn't that what it would be with Vigenere { path::FilePath, action::Action}
19:27:35 <leshow> Vigenere "foobar.txt" Decrypt
19:28:31 <erisco> yes, the point is figuring out what it means
19:28:46 <erisco> anyone can throw some things into a constructor :)
19:29:37 <erisco> data Vigenere a where TheFile :: FilePath -> Vigenere String; Encrypt :: Vigenere String -> Vigenere String; Decrypt :: Vigenere String -> Vigenere String; Then :: Vigenere () -> Vigenere a -> Vigenere a
19:29:51 <erisco> then you can write expressions such as  Encrypt (TheFile "foo.txt") `Then` Decrypt (TheFile "bar.txt") :: Vigenere String
19:30:32 <erisco> oops I have a type error... make that   Then :: Vigenere a -> Vigenere b -> Vigenere b
19:31:32 <erisco> eval :: Vigenere a -> IO a
19:35:02 <erisco> eval (Encrypt (Decrypt x)) = eval x; eval (Decrypt (Encrypt x)) = eval x;  some nice optimisations :)
19:35:55 <erisco> can even collect the file paths and re-sequence the operations to be intelligent with file handles
19:38:35 * hackage throwable-exceptions 0.1.0.2 - throwable-exceptions gives the exception's value constructors  https://hackage.haskell.org/package/throwable-exceptions-0.1.0.2 (aiya000)
19:58:35 * hackage dejafu 0.7.0.2 - Systematic testing for Haskell concurrency.  https://hackage.haskell.org/package/dejafu-0.7.0.2 (barrucadu)
20:33:05 <XorSwap> @hoogle ap
20:33:05 <lambdabot> Control.Monad ap :: (Monad m) => m (a -> b) -> m a -> m b
20:33:05 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: (Graph gr) => gr a b -> [Node]
20:33:05 <lambdabot> Monad ap :: Monad m => m (a -> b) -> m a -> m b
20:52:10 <Jinxit> having some trouble understanding the mapMonadT functions
20:52:23 <Jinxit> in this case mapRWST, but equivalently mapWriterT
20:53:01 <Jinxit> in mapWriterT, what am i supposed to give as w' if i just want to keep the old w?
20:56:50 <Axman6> @hoogle mapWriterT
20:56:51 <lambdabot> Control.Monad.Writer.Lazy mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
20:56:51 <lambdabot> Control.Monad.Writer.Strict mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
20:56:51 <lambdabot> Control.Monad.Trans.Writer.Lazy mapWriterT :: (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
20:57:21 <Axman6> Jinxit: w can be the same as w'
20:57:47 <Axman6> if you have a function of type m (a,w) -> n (b,w) then you can use that
20:58:27 <Jinxit> Axman6: yeah i'm trying to figure out how to write that function
20:59:05 <Axman6> well that function depends on the underlying monads m and n I guess
20:59:13 <kadoban> Jinxit: Might be clearer if you go into exactly what you're trying to do. It can get a bit abstract because often you can't simply pattern match all that out, you have to fmap some other function into the Monad if you want to keep m the same, or some other weird thing if not.
20:59:29 <iqubic> What are we working on here?
20:59:33 <Jinxit> going from ExceptT e [] to Identity
20:59:38 <Jinxit> inside the RWST
21:00:07 <iqubic> I'm not sure I understand what you are trying to do.
21:00:28 <iqubic> ExceptT and RWST are two seperate Monad Transformers.
21:00:34 <Axman6> that's because you've missed most of the background iqubic
21:00:38 <iqubic> How are you combining the two?
21:00:48 <Gurkenglas> Hm. I feel like "(Monad m, Monad n) => (m a -> n b) -> m (a, w) -> n (b, w)" ought to be inhabited. Anyone got a counterexample?
21:00:52 <Axman6> Jinxit: can you give the fule types of what you have and what you want?
21:00:56 <iqubic> Axman6: I just joined a few minutes ago.
21:01:19 <Axman6> yes, I understand that
21:01:24 <iqubic> Axman6: Your comment about the underlying monads m and n is the first on I see in my backlog
21:01:40 <iqubic> I'll stay out of this conversation for now.
21:01:51 <rgrinberg> how do I decide between logict and tekmo's listt done right? I assume the only difference is performance. But I'd like to gain some intuition on which one is faster when
21:02:11 <Jinxit> Axman6: RWST r w s (ExceptT e []) a -> RWST r w s m (Either e (a, s, w))
21:02:26 <Jinxit> is what i'm trying to write
21:02:47 <Gurkenglas> Where m is []?
21:02:55 <dibblego> What is the meaning of F in System F? Related: https://math.stackexchange.com/questions/708673/girards-system-f-also-named-polymorphism
21:02:56 <iqubic> I think so.
21:03:18 <iqubic> How ever, you can't get rid of [], I don't think.
21:03:42 <Jinxit> Gurkenglas: just Monad m
21:03:58 <iqubic> Jinxit: [] is a Monad
21:04:09 <Jinxit> yes
21:04:14 <Gurkenglas> Jinxit, what happens when all lists from the argument are empty?
21:04:53 <Jinxit> specific error (e isn't actually polymorphic)
21:05:31 <iqubic> Can we see the actual error message. I suspect there might be more in the error message that we can't see.
21:05:36 <Gurkenglas> Are all lists in the argument singletons?
21:05:54 <iqubic> Also, have you tried writing this function yourself, Jinxit?
21:06:00 <Jinxit> Gurkenglas: no
21:06:19 <Jinxit> iqubic: no error message; i've gotten it to typecheck but it doesn't behave as expected
21:06:22 <Jinxit> (so yes i've tried)
21:07:02 <iqubic> Jinxit: How is it different from what you are expecting? Can I see what you've tried? Can you paste that somewhere?
21:07:38 <Gurkenglas> "mapRWST :: _ -> RWST r w s (ExceptT e []) a -> RWST r w s m (Either e (a, s, w))" would have _ be "(ExceptT e [] (a, s, w) -> m (a, s, w))", can you write such a function?
21:08:16 <Gurkenglas> ExceptT e [] (a, s, w) -> m (Either e (a, s, w), s, w), I mean
21:08:49 <iqubic> Gurkenglas: m is [] in this case? Right?
21:08:54 <Gurkenglas> iqubic, no
21:09:09 <iqubic> So where does the list go in the return value?
21:09:26 <Gurkenglas> It is dismantled by his handling
21:09:34 <iqubic> Oh, I see.
21:09:48 <iqubic> I guess I don't fully get what we're trying to do here.
21:10:11 <Jinxit> Gurkenglas: this is the part where i'm struggling, am i on the right track by using runExceptT?
21:10:36 <Gurkenglas> You're gonna have to do that at some point, yes, or or use something that does that
21:12:43 <iqubic> :t ExceptT
21:12:44 <lambdabot> m (Either e a) -> ExceptT e m a
21:12:54 <iqubic> :t runExceptT
21:12:55 <lambdabot> ExceptT e m a -> m (Either e a)
21:13:18 <iqubic> See, runExceptT unboxes the Monad Transformer for you.
21:13:20 <Axman6> (all runExceptT does it pattern match and extract the wrapped computation, which you can do yourself if you find that easier)
21:13:36 <iqubic> Yeah, that's right
21:13:43 <Axman6> iqubic: I'm pretty sure Jinxit understands that
21:14:05 <Gurkenglas> Since you know nothing about m, you're also only going to be able to do return at the end, so you're looking for "[Either e (a, s, w)] -> (Either e (a, s, w), s, w)"
21:15:08 <Axman6> that type doesn't look possible to produce without having defaults for s and w
21:15:44 <Jinxit> that's basically the issue i'm having
21:15:56 <Gurkenglas> Indeed. w usually is a Monoid, but the state will degenerate.
21:16:22 <Jinxit> i want the w from the RWST i receive as parameter
21:17:19 <Gurkenglas> Jinxit, once again, what if all lists in the argument are empty? Your Either can go to the left, but the outer "RWST r w s m" part still wants you to give it w and s
21:17:31 <Axman6> I don't think you can use mapRWST then
21:17:37 <Jinxit> ah i see
21:17:53 <Axman6> but you should be able to write this by hand
21:18:42 <Jinxit> i'm not sure how to change the transformer stack without map_T
21:19:04 <Axman6> pattern matching
21:19:38 <Axman6> :t RWST
21:19:39 <lambdabot> (r -> s -> m (a, s, w)) -> RWST r w s m a
21:20:44 <Axman6> foo (RWST f) = RWST $ \r s -> case f r s of ExceptT ... -> ...
21:21:20 <Axman6> now you have access to an r and an s... but what you do when the ExceptT also provides an r and an s I;m not sure
21:21:21 <Jinxit> oh okay
21:21:51 <iqubic> :t ContT
21:21:53 <lambdabot> forall k a (m :: k -> *) (r :: k). ((a -> m r) -> m r) -> ContT r m a
21:22:03 <Jinxit> Gurkenglas: you're right regarding w and s, i think i actualoly want `RWST r w s (ExceptT e []) a -> m (Either e (a, s, w))`, right?
21:22:04 <iqubic> GRR!!! Stupid foralls
21:22:06 <Axman6> (or in your case, multiple r's and s's because of the [])
21:22:21 <Jinxit> as say "first succeeding option"
21:22:34 <iqubic> Can someone simplify the type of ContT for me?
21:22:41 <Axman6> oh right, I meant r and w... 
21:22:45 <Axman6> ((a -> m r) -> m r) -> ContT r m a 
21:23:08 <iqubic> Jinxit: try asum to get the "first succeeding operation" from [a]
21:23:12 <iqubic> :t asum
21:23:13 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
21:23:29 <iqubic> Yeah, that'll get the first succeeding option.
21:23:35 <iqubic> @src asum
21:23:35 <lambdabot> Source not found. :(
21:23:35 * Axman6 heads to restart his server
21:24:07 <Gurkenglas> Jinxit, where's r coming from?
21:25:33 <iqubic> asum  = foldr (<|>) empty
21:25:56 <iqubic> :t let asum = foldr (<|>) empty in asum
21:25:57 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
21:26:42 <iqubic> Yeah. Usually that gets the first succeessful option.
21:27:17 <Gurkenglas> :t mapRWST (asum . runExceptT) -- It's dangerous out there, take this!
21:27:19 <lambdabot> (Control.Monad.Trans.Error.Error e, Foldable t) => RWST r w' s (ExceptT e t) b -> RWST r w' s (Either e) b
21:28:09 <iqubic> Gurkenglas: That's not quite the right type signature,
21:28:28 <Gurkenglas> It's not supposed to be, it's supposed to get him where he can take the rest :P
21:28:48 <iqubic> Ah. I see.
21:29:13 <iqubic> I'm glad I got the source for asum right on the first try. That was unexpected for me.
21:33:07 <Gurkenglas> Note that Control.Monad.Trans.Error's orphan instance for Alternative (Either e) will give you empty = Left noMsg instead of the specific error you mentioned
21:33:47 <iqubic> That's a shame
21:35:12 <iqubic> :t EitherT
21:35:13 <lambdabot> error:
21:35:13 <lambdabot>     • Data constructor not in scope: EitherT
21:35:13 <lambdabot>     • Perhaps you meant variable ‘either’ (imported from Data.Either)
21:35:14 <Gurkenglas> It's deprecated, so maybe you want to supply your own (ExceptT e [] a -> Either e a) to plug into mapRWST.
21:35:48 <Gurkenglas> (With polymorphic a that is)
21:53:59 <wilornel> Hm... I have "instance Monoid (First' a) where { mempty = First' Nada ; mappend mempty b = b ; mappend (First' (Only b)) mempty = (First' (Only b)) }"; When I do `mappend (First' (Only "\SUB")) mempty`, I get `First' Nada`.......
21:58:05 <Axman6> mappend mempty b just names the first argument "mempty"
21:58:17 <Axman6> it is not matching on something thay is the same as your definition for mempty
21:58:32 <Axman6> you explicitly need  mappend (First' Nada) b
21:58:43 <EvanR> should patterns that shadow like that be a warning
21:58:53 <geekosaur> they are, with -Wall
21:59:30 <wilornel> Axman6: That's strange, because I've done something like so before:
22:00:11 <wilornel> well, here is it again: http://paste.ubuntu.com/24839150/
22:00:19 <Axman6> you should be getting lots of warnings for that code, the second equation is never matched
22:00:47 <wilornel> I got one warning for it
22:00:51 <geekosaur> wilornel, ghci does not work like a file
22:00:52 <wilornel> what do you think of that pastie?
22:00:56 <wilornel> hmmmm
22:01:01 <Axman6> wilornel: that says "iff gets _any_ argument which is not 1 or 2, call it x, and return 5"
22:01:02 <geekosaur> it's defining a new f each time that shadows the old one
22:01:22 <wilornel> ohhhhh
22:01:22 <geekosaur> and since nothing is referencing the old one, it eventually gets gc-d
22:01:23 <EvanR> > (\x -> 5) 0
22:01:25 <lambdabot>  5
22:01:55 <Axman6> wilornel: what you're trying to do definitely does not work as you are expecting
22:01:59 <EvanR> > let x = 0 in (\x -> 5) x
22:02:01 <lambdabot>  5
22:02:02 <geekosaur> if you want to write multiple equations like that in ghci, you need to put them all on one line with semicolons, or use multiline input (:{ :})
22:02:11 <EvanR> lambda calculus comes in handy
22:02:16 <wilornel> So this is just confusing then: http://imgur.com/a/C4bzJ
22:03:50 <Axman6> those aren't defnitions, they're examples of laws which should hold true
22:04:09 <Axman6> yeah that is confusing
22:04:45 <wilornel> Alright, then I shall _properly_ pattern match
22:04:56 <wilornel> Thank you Axman6 , EvanR , geekosaur 
22:05:10 <wilornel> so the laws are very informal. They could be defined as functions
22:05:19 <geekosaur> you might want to get used to running ghci etc. with -Wall so it tells you about things like this
22:05:20 <wilornel> prop_leftAssociative 
22:05:21 <EvanR> ok
22:05:30 <wilornel> EvanR++
22:05:46 <EvanR> o_O
22:06:15 <wilornel> some channels keep counts of ++es received
22:06:33 <Axman6> @karma EvanR
22:06:33 <lambdabot> EvanR has a karma of 16
22:06:54 <EvanR> laws like (a + b) + c = a + (b + c) in haskell are kind of informal, because they are supposed to apply even when a type doesnt have an equality test
22:06:54 <wilornel> @help karma
22:06:54 <lambdabot> karma <polynick>. Return a person's karma value
22:07:05 <wilornel> @help how do I give karma
22:07:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:07:06 <EvanR> and you dont always specify whether bottom is involved
22:09:05 <EvanR> how the heck do i have 16, i only remember that command being used like 2 times
22:10:25 <Axman6> I remember someone once got shitty with me and sat there decrementing mine all night
22:10:39 <EvanR> lol
22:11:12 <EvanR> he probably got hit by a bus the next morning
22:11:14 <Axman6> I was pretty annoyed, I'd built up a decent amount by helping people
22:11:15 <EvanR> because
22:11:21 <Axman6> I hope so
22:12:05 * hackage throwable-exceptions 0.1.0.3 - throwable-exceptions gives the exception's value constructors  https://hackage.haskell.org/package/throwable-exceptions-0.1.0.3 (aiya000)
22:12:56 <EvanR> (a + b) + c = a + (b + c) might mean something like, when an instance of the LHS gets run through the semantic interpretation, what you get is indistinguishable from doing the same thing to the right
22:13:07 <EvanR> you cant observe a semantic difference
22:13:24 <EvanR> "what i care about" is equal
22:13:38 <Axman6> the results are the same
22:14:08 <Axman6> like how Set.union a b shoudl equal Set.union b a, but the actual structure isn't guaranteed to be the same
22:14:20 <EvanR> right, and "results" may include or exclude arbitrary things... like performance
22:14:29 <Axman6> yeah
22:14:51 <Axman6> and when they include performance considerations, the law might actually also be called an optimisation
22:15:54 <EvanR> Axman6++
22:23:24 <iqubic> @karma iqubic
22:23:24 <lambdabot> You have a karma of 0
22:23:33 <iqubic> Darn it. Darn it Darn it
22:23:46 <iqubic> iqubic++
22:23:49 <iqubic> @karma iqubic
22:23:49 <lambdabot> You have a karma of 0
22:24:11 <iqubic> Can't game the system it seems. Darn it. Darn it Darn it.
22:25:05 <iqubic> Basically the laws state that the LHS and the RHS are isomorphic for all intents and purposes.
22:25:17 <wilornel> iqubic++
22:25:44 <iqubic> Thanks wilornel.
22:25:46 <wilornel> the laws are stated in order for development and usage of these tools that the laws are defined for becomes easier
22:26:30 <iqubic> Also, having laws makes it easier to verify that polymorphic programs will work properly.
22:26:35 <wilornel> iqubic++
22:27:36 <EvanR> calling both sides basically isomorphic doesnt help the informality... its kind of like calling pi = 3.140000000000
22:28:31 <EvanR> extra wrong precision
22:28:33 <smallCat> Can someone explain how to access request header values in Servant?
22:29:18 <smallCat> Like... say I have a route of type "showUsers" :> Header <header-type> :> Get <return-type>
22:29:31 <smallCat> So how do I get the <header-type> value?
22:44:17 <Jinxit> Gurkenglas, Axman6: thanks again for the help, managed to get it to work now
22:54:14 <dmj`> smallCat: still there?
22:55:26 <dmj`> smallCat: Header <header-type> -> Header “header name” <header-type>
22:55:36 <dmj`> smallCat: http://lpaste.net/356176
23:13:36 <Axman6> Jinxit: great!
23:22:44 <jg_> hi all. How do i generate implementation documentation of my stack project with haddock (list all functions, not just the exported ones)?
23:25:09 <cocreature> jg_: try "stack haddock --haddock-arguments --ignore-all-exports
23:25:11 <cocreature> "
23:28:25 <jg_> which version of haddock is stack using anyway?
23:31:51 <Axman6> whatever is installed probably
23:32:10 <Axman6> it'll be using the haddock binary which is in scope (stack exec which haddock should tell you)
23:32:20 <jg_> i have haddock 2.16.1 installed via cabal install. It says i can't upgrade to 2.17.5 because of 'base' 
23:32:30 <cocreature> probably the one bundled with the GHC it uses.
23:32:53 <cocreature> unless you enable system-ghc
23:37:07 <Axman6> did you run stack install haddock?
23:38:03 <cocreature> I don’t think that should be necessary.
23:39:20 <LiaoTao> Pls halp :( How in the world does uploading data into uniforms with the high-level OpenGL bindings work?
23:40:16 <jg_> https://www.stackage.org/lts-8.17 is this 'haddock-library' the thing stack uses for 'stack haddock'? not sure why there's both 'haddock' & 'haddock-library'
23:40:47 <cocreature> jg_: have you run "stack exec which haddock" like Axman6 suggested? if so what’s the output of that?
23:41:32 <jg_> home/jg/.stack/programs/x86_64-linux/ghc-8.0.2/bin/haddock
23:41:45 <cocreature> alright so that’s the haddock that stack is using
23:42:21 <cocreature> "stack exec -- haddock --version" will tell you which version that is
23:42:29 <cocreature> probably 2.17.3
23:42:35 <jg_> yep, that's the one. Thanks
23:52:19 <EvanR> is there some benefit to defining a type like data Z = A Z | B X Z | C Y Z | D Z instead making Z a list of some other custom type
23:52:32 <EvanR> er, and | EmptyZ
23:54:50 <cocreature> EvanR: if you make the fields strict, GHC could unbox them. I don’t see a benefit if they’re lazy
23:55:04 <cocreature> (make X and Y strict not Z)
23:55:37 <EvanR> ok sure
23:56:02 <cocreature> I guess A Z is always unboxed in that sense so you loose one pointer
23:57:05 <EvanR> i kind of want to make this type... but then i see its equivalent to a list, and factoring types is usually considered nicer
23:57:25 <EvanR> and i see needing to write my own folds ...
23:57:40 <EvanR> and the Z is repetitive
23:57:59 <EvanR> didnt know about that optimization though
23:58:50 <cocreature> I would usually go for the list unless there is a strong reason for not doing so
23:59:08 <cocreature> just because I’m too lazy to reimplement half of Data.List for the custom type
