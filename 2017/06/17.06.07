00:00:00 <EvanR> its redundant
00:00:11 <iqubic> What should I do instead? Use let?
00:00:15 <EvanR> yes
00:00:22 <cocreature> huh, does "let" in do blocks really desugar to "… <- return …"?
00:00:40 <EvanR> no
00:00:45 <EvanR> it becomes a regular let
00:00:48 <cocreature> I mean for all reasonable instances of Monad it’s going to be equivalent but it’s not enforced
00:01:01 <EvanR> yeah i meant by the monad laws
00:01:04 <iqubic> Oh. Should I switch my code over to using let?
00:01:06 <cocreature> yes
00:01:26 <iqubic> I really only have to change one do block to make that change
00:01:53 <iqubic> Why do you think "let" is better than "... <- pure ...?
00:02:02 <EvanR> less code, less pointless?
00:02:15 <iqubic> Is it really less code?
00:02:20 <quchen> let performs a heap allocation, lambdas do not. So they’re not fully equivalent, but in normal programs it probably never matters.
00:02:27 <cocreature> it also makes it more clear what you’re doing
00:02:29 <EvanR> > length "let" 
00:02:31 <lambdabot>  3
00:02:35 <EvanR> > length "<- pure"
00:02:37 <lambdabot>  7
00:02:47 <iqubic> EvanR: With le you also have to use in
00:02:58 <EvanR> no you dont
00:03:00 <cocreature> for "_ <- pure _" I need to spot the "pure" to see that it doesn’t actually do anything monadic. for "let" I don’t
00:03:02 <cocreature> iqubic: not in do blocks
00:03:12 <iqubic> > length "let" ++ "in"
00:03:14 <lambdabot>  error:
00:03:14 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Int’
00:03:14 <lambdabot>      • In the first argument of ‘(++)’, namely ‘length "let"’
00:03:23 <iqubic> > length $ "let" ++ "in"
00:03:25 <EvanR> yeah, <- in your code is signaling to the reader that you might be having effects
00:03:25 <lambdabot>  5
00:03:33 <EvanR> let is signaling you are not
00:03:39 <EvanR> definitely not
00:03:41 <ahihi> I just wish "let" in do blocks would allow line breaks in the rhs
00:03:42 <quchen> Code length, a brilliant metric for quality
00:03:53 <ahihi> I've sometimes used "<- pure" because of that annoyance
00:03:54 * EvanR switches to APL
00:03:59 <quchen> Cheater!
00:04:12 <iqubic> cocreature: Why do you say I don't need "in" to go with my "let" bindings in a do block?
00:04:27 <cocreature> iqubic: because you don’t need it?
00:04:28 <EvanR> iqubic: i think you might need to read a guide on do notation
00:04:31 <iqubic> I have no idea how to use let in a do block it turns out
00:04:33 <quchen> ahihi: Line breaks are allowed in let+do.
00:04:36 <EvanR> it sounds like you never learned it
00:04:53 <iqubic> EvanR: I think I do need a do notation tutorial. Ive only learned the basics
00:04:59 <EvanR> no tutorials
00:05:20 <cocreature> ahihi: you can absolutely use line breaks in the rhs. you just need to indent properly
00:05:24 <quchen> iqubic: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#desugaring-do-notation
00:05:28 <quchen> That’s it
00:05:38 <EvanR> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
00:06:03 <matrium> glguy: I'm trying to use the CPP / __FILE__ approach but somehow the __FILE__ constant is not expanded
00:06:05 <iqubic> I only used "... <- pure ..." because It type checked and I didn't know any better
00:06:06 <EvanR> good call quchen 
00:06:35 <ahihi> cocreature: what is "properly"?
00:06:42 <cocreature> at some point quchen will have written an article for all questions asked here and we can just create a bot that links to his articles
00:06:49 <ahihi> http://lpaste.net/1716410824316157952 this is what I would expect to work
00:07:03 <quchen> cocreature: The point of writing these down is common subcomment elimination. :-)
00:07:25 <cocreature> ahihi: one space more than "y" iric
00:07:38 <iqubic> Alright, that works.
00:07:49 <cocreature> quchen: heh :)
00:07:57 <ahihi> oh.
00:07:59 <ahihi> that's... weird
00:08:09 <iqubic> I just converted my "... <- pure ..." into "let"
00:08:20 <iqubic> And it looks cleaner
00:08:40 <iqubic> how is "let" in a do block desugared?
00:08:47 <quchen> Like this, https://github.com/quchen/articles/blob/master/functions_comprehensible.md#desugaring-do-notation
00:09:25 <iqubic> Oh. I looked at that a few seconds ago and didn't even see the let part. I'm really stupid.
00:09:49 <quchen> iqubic: do notation has just these 4 rules, that’s it
00:10:13 <iqubic> So using "let" grants me the ability to use non-IO functions in a do block right?
00:10:16 <iqubic> Is that all?
00:10:30 <EvanR> it lets you bind expressions to names
00:10:35 <EvanR> they dont need to be functions
00:11:02 <iqubic> What does that mean? Doesn't "<-" also bind functions to names?
00:11:08 <EvanR> no
00:11:18 <EvanR> <- desugars to >>=
00:11:19 <quchen> let does not perform monadic actions, it just defines things
00:11:23 <iqubic> Oh. right
00:11:25 <quchen> <- performs its RHS
00:11:34 <merijn> let is just sugar for "let ... in ..."
00:11:35 <EvanR> iqubic: did you read quchen's article yet
00:11:47 <iqubic> Yeah, I read it.
00:11:55 <iqubic> It seems really simple and basic
00:12:07 <glguy> matrium: gotta turn on cpp
00:12:42 <quchen> iqubic: Good sugar should not be magic :-)
00:13:07 <iqubic> So all expressions on the RHS of "<-" must return IO a, since "<-" desugars to ">>="?
00:13:16 <quchen> Yes.
00:13:29 <iqubic> And let bindings assign names to expressions? Is that right?
00:14:12 <iqubic> Can I write "let nextLine = getLine" in a do block? Should I do that?
00:14:24 <quchen> You can do that, yes.
00:14:27 <iqubic> Where getLine is an IO action
00:14:31 <cocreature> it won’t do what you expect it to do
00:14:37 <cocreature> but you can do it
00:14:38 <quchen> That defines a synonym for getLine.
00:14:40 <quchen> It will not get a line.
00:14:49 <merijn> iqubic: My usual advice for beginners is: Avoid do-notation until it becomes simple to write the same code without do notation
00:14:57 <iqubic> cocreature: It won't actually get the line. Yeah I know that
00:15:13 <merijn> iqubic: Do notation is convenient and pleasant, but it obscures things that are important to learn
00:15:26 <iqubic> merijn: How do you expect people to do IO then? With long chains of >>= and lambdas?
00:15:58 <merijn> iqubic: Yes, it actually doesn't even look that different from do notation if you have a look at the wikibook: https://en.wikibooks.org/wiki/Haskell/do_notation
00:15:59 <iqubic> merijn: DO you expect people be able to write the desugared version fo a do block??
00:16:54 <iqubic> Well, yeah. Inserting those linebreaks makes it look like a do block for sure
00:17:17 <matrium> glguy: I think the problem was that the __FILE__ was part of a string. But how can I get the absolute file path? __FILE__ is only expanded to the project relative path
00:17:20 <merijn> iqubic: Everyone? No. Beginners? Yes. Until you learn to "see" the lambda's and lets intuitively enough
00:17:48 <merijn> matrium: This sounds suspicious, what are you trying to do?
00:17:57 <iqubic> I can see the underlying >>= and >> and lets just fine
00:18:27 <cocreature> merijn: well you probably expect everyone to _be able to_ write the desugared version of a do block. ofc you don’t have to use the desugared syntax after you’ve understood how it works.
00:19:01 <merijn> cocreature: That's what I said, no?
00:19:03 <matrium> merijn: I have a library processing a file with TH, which works fine when comiling. But when I'm running ghci in a project using the library, the relative file path can not be resolved
00:19:12 <iqubic> What do people think about using case statements in a do block?
00:19:22 <merijn> iqubic: Do it all the time
00:19:23 <cocreature> merijn: “everyone? no” sounds like you don’t expect everyone to be able to desugar do blocks
00:19:34 <iqubic> I have a statement "let maybeVal = maybe f a"
00:19:36 <merijn> cocreature: I don't expect everyone to *write* it like that
00:19:49 <merijn> matrium: Sounds like you wanna look into cabal's resource files
00:20:11 <iqubic> and then "case maybeVal of Just a ... Nothing... 
00:20:13 <merijn> matrium: You can have cabal install files at system defined paths and query the actual location on the user's system from cabal
00:20:42 <matrium> merijn: I don't need the actual file during execution. just during compile time
00:21:18 <merijn> matrium: hmmm, then I'm confused why ghci wouldn't be able to find it. Are you running it in the project root?
00:21:25 <matrium> using the library in any project with GHC is not a problem. But when starting GHCi the library is interpreted and the file can not be found
00:21:29 <\u> What's the additional features provided by Prism than Traversable?
00:22:36 <matrium> Project A is using TH to export some generated module, project B uses the exported module of A. When running GHCi in B, the interpreter can't find the resource of A
00:22:43 <iqubic> A prism is a traversal that traverses 0-1 elements only.
00:22:45 <\u> I want some arguments for a debate that `lens` is better than `lens-family`..
00:23:23 <iqubic> I'm not sure that it is.
00:23:23 <\u> lens-family seems to miss Prism
00:23:41 <iqubic> Does lens-family have iso?
00:24:10 <merijn> matrium: Are project A and B in the same directory, by any chance?
00:24:42 <dfordivam> I have a code with incomplete pattern matching, and expect the ghc to give warning/error, but it doesnt. Am I missing something here?
00:24:47 <dfordivam> http://lpaste.net/356088
00:24:47 <matrium> merijn: No, A is a project imported from github via stack
00:24:52 <merijn> dfordivam: Enable -Wall
00:25:24 <merijn> matrium: hmmm, I don't know stack, so I suspect my troubleshooting won't be all that helpful
00:25:33 <iqubic> Also, don't use a case statement there.
00:25:53 <iqubic> Use pattern matching in the LHS of the function header
00:26:14 <iqubic> so getResponse' (req1 a) = ...
00:26:15 <merijn> iqubic: I don't necessarily agree. There's a bunch of reasons not to
00:26:32 <iqubic> getResponse' (req2 a) = ...
00:26:36 <dfordivam> I tried Wall, Werror and -fwarn-incomplete-patterns but no error/warning
00:26:47 <merijn> 1) if you have a lot of cases repeatedly typing the function name is noisy 2) if you wanna share a where definition across cases you have to use case
00:27:08 <merijn> dfordivam: You're building via cabal?
00:27:13 <dfordivam> iqubic: no warning with fun level pattern matchin also
00:27:17 <dfordivam> merijn: yes
00:27:34 <iqubic> Really? Where clauses are local only to a particular function level pattern match?
00:27:42 <iqubic> dfordivam: compile with -Wall
00:27:50 <merijn> dfordivam: Assuming you added the flag to GHC-Options, did you clean/edit the file after? Else it might not recompile due to no chance :)
00:28:04 <merijn> iqubic: Yes, where clauses are local per LHS
00:28:11 <iqubic> s/chance/change
00:28:29 <merijn> iqubic: Since you might use pattern matched variables which don't exist in all branches
00:28:44 <iqubic> Haskell continues to suprise me each day
00:29:15 <dfordivam> I tried everything already that you are suggesting.. let me upload the whole code ...
00:29:16 <iqubic> Oh, right. I suppose that makes sense
00:30:56 <sphinxo> how do I name <- if cond then "j" else "v"
00:31:10 <sphinxo> where cond is of type IO Bool
00:31:12 <sphinxo> ifM?
00:31:32 <dfordivam> iqubic: here it is https://github.com/dfordivam/reflex-websocket-interface/tree/master/typeclassbased/example/server
00:31:56 <iqubic> Ah, the classic if statement in a do block predicament.
00:32:16 <sphinxo> iqubic: what are my options?
00:32:19 <iqubic> I know there's a way to do that without using ifM, but I'm not sure what that way is.
00:32:38 <EvanR> if you use lambda case you can
00:32:54 <iqubic> ask merijn, or quchen: They know the do blocks forward and back
00:32:58 <EvanR> getBool >>= \case {True -> ...; False -> ...}
00:33:04 <merijn> naah, just use >>= and bool
00:33:11 <EvanR> or bool
00:33:23 <merijn> name <- cond >>= "v" "j"
00:33:29 <merijn> eh
00:33:32 <merijn> name <- cond >>= bool "v" "j"
00:34:21 <merijn> or 'name <- bool "v" "j" =<< cond' if you prefer right to left flow into name
00:34:44 <sphinxo> awesome!
00:34:46 <sphinxo> thanks
00:39:09 <nesqi> Is there an easy way to find out which "head" that produced a "Prelude.head: empty list" in my code?
00:39:41 <EvanR> oh geez
00:39:45 <merijn> nesqi: I suppose "Yes, don't use head" is an acceptable answer? >.>
00:39:53 <EvanR> how many do you have?
00:40:09 <nesqi> maybe 10
00:40:33 <EvanR> ok, do you have 10 proofs on hand that each one does not get a [] ?
00:40:42 <EvanR> if not, start proving
00:40:57 <nesqi> Damn it... fire alarm.. have to go....
00:41:00 <EvanR> if it was like 100 heads, youd be screwed
00:41:24 <nesqi> eh.. ok. now it stopped.
00:42:06 <EvanR> you can get help from the compiler by rewriting most of your heads as case statements
00:42:41 <iqubic> Why is head such a bad thing??
00:42:53 <cocreature> iqubic: because it crashes on an empty list
00:42:55 <merijn> iqubic: Because it crashes when you're wrong :)
00:42:55 <ventonegro> > head []
00:42:57 <lambdabot>  *Exception: Prelude.head: empty list
00:43:31 <EvanR> because when it crashes, you get no indication where or why
00:43:39 <merijn> iqubic: Using head instead of pattern match is like skipping a NULL check on a pointer because you "know it's not NULL"
00:43:43 <nesqi> Hm.... so maybe I should just never use head and rewrite my code?
00:43:58 <ventonegro> nesqi: bingo
00:44:00 <iqubic> Ah.
00:44:00 <merijn> iqubic: You might be right *now*, but 1 or 2 months later you refactor the code, you are no longer right and your code crashes
00:44:32 <iqubic> If you use [] and (x:xs) as pattern matches, that's a lot better
00:44:43 <nesqi> This is code that I wrote 1-2 years ago and now I'm using it with different input.
00:44:46 <nesqi> so...
00:44:59 <merijn> nesqi: There are some justified cases for 'head' when you *know* the list is never empty, a common example would be "map head . groupBy foo" (since groupBy never produces empty lists) but those cases are few and far between
00:45:01 <cocreature> crashing can be a reasonable way to handle invalid input but you want at least a better error message
00:45:02 <nesqi> I guess I did some mistake.
00:45:36 <cocreature> nesqi: building with profiling and using "+RTS -xc" should give you a backtrace
00:46:25 <nesqi> -prof?
00:46:28 <merijn> nesqi: Hell, even if you pattern match "case l of (x:_) -> doStuffWith x; [] -> error "doStuffWith requires non-empty list!" is nicer. Because you'd still crash like now, but 2 years later it'd be easy to find out where and more importantly why
00:47:21 <cocreature> nesqi: usually you won’t use -prof manually. cabal has --enable-profiling and stack has --profiling
00:47:41 <cocreature> life would be way to easy if stack and cabal tried to be consistent where they can
00:48:15 <nesqi> hm....
00:48:16 <nesqi> CallStack (from -prof): GHC.List.CAF (<entire-module>)
00:48:24 <nesqi> not much help =)
00:48:50 <EvanR> CAF might mean it was a top level list?
00:48:51 <cocreature> maybe throw in some -fprof-auto
00:48:58 <EvanR> or it might mean it was floated 
00:49:28 <EvanR> nesqi: just replace each head with a case that crashes with a different message
00:49:53 <cocreature> we all love “error "foobar1", error "foobar2", …
00:50:05 <nesqi> oh!
00:50:14 <nesqi> It worked, got a stacktrace =)
00:50:25 <cocreature> -fprof-auto was the thing that was missing?
00:51:32 <nesqi> yes
00:53:41 <dfordivam> Does -fwarn-incomplete-patterns have the limitation that it cannot detect incomplete patterns for data defined in another package?
00:54:09 <dfordivam> I moved all the code of my project in one project and now I am getting the warning
00:54:32 <dfordivam> one cabal project
00:55:12 <cocreature> dfordivam: afaik that shouldn’t matter. are you sure you didn’t (perhaps accidentally) change anything else?
00:56:06 <dfordivam> cocreature:I double checked..
00:57:13 <dfordivam> cocreature: Here is the code https://github.com/dfordivam/reflex-websocket-interface/tree/master/ghcissue of single project
00:57:55 <dfordivam> and the separate package one here https://github.com/dfordivam/reflex-websocket-interface/tree/master/typeclassbased/example/server https://github.com/dfordivam/reflex-websocket-interface/tree/master/typeclassbased/example/shared
00:59:54 <cocreature> dfordivam: can you point to the pattern match that is causing the error?
01:00:27 <dfordivam> Main.hs:37:3: 
01:01:22 <dfordivam> cocreature:I basically move the contents of this file to Shared.hs
01:01:25 <dfordivam> https://github.com/dfordivam/reflex-websocket-interface/blob/master/typeclassbased/shared/Reflex/WebSocket/WithWebSocket/Shared.hs
01:01:41 <nesqi> I love this channel. Thank you for the help!
01:01:43 <dfordivam> cocreature:Otherwise everything is same
01:02:15 <cocreature> dfordivam: is it possible that you have to just haven’t recompiled after enabling the warnings? cabal won’t recompile files that haven’t changed if you just change warnings
01:02:44 <quchen> Huh, I just realized I completely crippled my »functions in comprehensible notation« with the commit about desugaring do-notation. Good thing I looked at it some more! Reverted & corrected.
01:04:28 <dfordivam> cocreature:Right I had to cabal clean the shared package also for this to work...
01:05:20 <cocreature> dfordivam: just to be sure I understand you correctly, it’s now working as you expect it to?
01:05:34 <dfordivam> cocreature: yes now it gives error
01:05:39 <cocreature> great
01:06:01 <dfordivam> cocreature: but it was a tricky thing to figure out
01:06:06 <cocreature> I never liked that GHC tries to be clever in not recompiling things even when you change flags
01:06:21 <cocreature> until fairly recently it didn’t even recompile if you changed optimizations
01:06:54 <dfordivam> Hmm I see so I will have to recompile all the dependencies on adding this flag...
01:24:16 <hanna> \u: rebuilding GHC solved my -nopie issue
01:31:08 * hackage quickcheck-state-machine 0.0.0 - Test monadic programs using state machine based models  https://hackage.haskell.org/package/quickcheck-state-machine-0.0.0 (stevana)
01:32:05 <osa1> I want to handle database initialization and migrations manually but use persistent & esquelete for queries. anyone have any experience in doing something like this? I'm wondering how hard it would be to keep persistent definition and schema in sync.
02:08:53 <Philonous> Why does GHC still warn about missing patterns that don't even type check, wasn't that fixed?
02:37:29 <sphinxo> I'm trying to use wreq with aeson-lens like so: (r ^. responseBody . key "id" . _Integer)
02:37:41 <sphinxo> but I'm getting No instance for (Monoid Integer) arising from a use of ‘key’
02:38:31 <sphinxo> Where is the monoid constraint coming from?
02:42:19 <MasseR> Afaik it tries to mconcat the possibly multiple results
02:42:39 <cocreature> sphinxo: the reason for the Monoid constraint is that there could be no result ond ^. still has to give you something back
02:42:44 <cocreature> sphinxo: ^? will give you a Maybe
02:45:18 <sphinxo> Ahh thanks cocreature and MasseR 
03:08:38 * hackage language-javascript 0.6.0.10 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.10 (ErikDeCastroLopo)
03:29:25 <hjulle> Is there any way to destructure the Nat kind in GHC.TypeLits as if they were Piano numbers? For example, for "class A (n :: Nat)" make the instances "instance A 0" and "instance (A n) => A (n+1)" (or similar).
03:37:42 <ertes-w> hjulle: only by explicit comparison
03:37:52 <ertes-w> and…  peano…  numbers =)
03:38:05 <hjulle> Lol, woops
03:38:30 <hjulle> ertes-w: How would you do it using explicit comparison?
03:40:52 <lyxia> you can also use overlapping instances
03:42:43 <hjulle> I'm getting problems with infinite loops when it tries to check cases where n would be less than 0, even if I have the constraints (1 <= n, KnownNat n).
03:48:12 <lyxia> hjulle: http://lpaste.net/356091
03:48:30 <lyxia> I think you need a plugin if you want to deduce 0 <= n from 1 <= n
03:48:40 <lyxia> otherwise you'll have to accumulate it in the constraints
03:49:22 <cocreature> ghc-typelits-normalize might be able to do that
03:49:33 <cocreature> although I’ve only used it for equalities I think. not sure if it handles inequalities
03:50:41 <cocreature> there is also ghc-typelits-knownnat which helps with KnownNat constraints
03:51:47 <hjulle> lyxia: aha, thanks
03:51:49 <lyxia> hmmm actually I just tried and that seems to work without plugins
03:52:32 <quchen> Has anyone else had the use case to deliver an executable in source form, all dependencies included (so it builds without internet)?
03:53:05 <quchen> Handy for example to build it in a closed system that does not have all deps (in the right version), e.g. launchpad for making Debian packages
03:53:14 <lyxia> hjulle: https://dpaste.de/weku does this compiles
03:55:16 <cocreature> quchen: launchpad does not have internet access?
03:56:19 <quchen> cocreature: Debian packages have to be buildable using only the Debian ecosystem.
03:56:34 <quchen> cocreature: It would be bad if the repos broke because Github has yet another service outage and deps can’t be pulled :-)
03:56:55 <quchen> Same for Nix, and probably every other package repo
03:56:56 <hjulle> lyxia: Using a bool like that is a great idea, since it's something that you can actually pattern match against. Thx again.
03:58:15 <cocreature> quchen: huh? nix derivations can download files and a lot of them do that. arch does the same.
03:58:26 <cocreature> but fair enough if you need that then I’m not helping so I’ll shut up :)
03:58:42 <quchen> If you want to publish stuff on Nixpkgs I don’t think you can do that
03:58:50 <quchen> Sure, individual derivations can do it
03:59:41 <cocreature> quchen: here’s an example that downloads the sources from the openjdk website https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/compilers/openjdk/8.nix
04:00:13 <quchen> Okay, I’ll just show myself out
04:00:39 <quchen> My colleague (Franz) is usually the one of us two who suffers through the Deb building pipeline. ;-)
04:01:48 <cheater> quchen: ?
04:03:50 <cocreature> quchen: going back to your original question, cabal does allow for local repositories (see http://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=repository#secure-local-repositories) so you could just download a mirror of all of hackage. but I guess you’re probably looking for something that only downloads the sources you care about
04:04:10 <quchen> I hacked together something with Stack
04:04:26 <quchen> It works and everything, but it’s just bolted on
04:53:45 <quchen> ?tell ndmitchell Hey, I’ve really liked your command API in Shake for some time now – have you considered making it its own package?
04:53:45 <lambdabot> Consider it noted.
04:54:08 <quchen> ?tell ndmitchell Whenever I use System.Process, I feel like I’m clumsily rebuilding something that would have been much easier with your API.
04:54:08 <lambdabot> Consider it noted.
04:54:25 <_sras_> Is there anyway to speed up the "Downloading index" step in fresh stack build?
05:00:37 * hackage BioHMM 1.1.7 - Libary for Hidden Markov Models in HMMER3 format.  https://hackage.haskell.org/package/BioHMM-1.1.7 (FlorianEggenhofer)
05:02:13 <cocreature> _sras_: one of the recent stack releases improved it so upgrading might help if you’re not already on the latest version but I don’t think there is anything else you can do
05:29:46 <dihuteno> does anyone know of a monadic option parsing library?
05:30:01 <merijn> dihuteno: Why specifically monadic?
05:30:03 <dihuteno> an optparse-monad, if you will
05:30:31 <dihuteno> merijn: some of my options depend on the values passed to my other options
05:30:49 <dihuteno> which I understand is not something that applicative parsers handle well
05:30:51 <merijn> dihuteno: And you can't change it to use, like, subcommands?
05:31:37 <cocreature> subcommands are often also easier to understand for users so it might be something you want to at least consider
05:31:39 <dihuteno> I'm looking into that as well, but not easily
05:31:59 <dihuteno> if there is a good monadic option parser out there it would handle it much better
05:32:03 <merijn> dihuteno: I'm not aware of any monadic commands, no
05:35:15 <cocreature> dihuteno: I don’t know of a monadic parser lib either but one option is to do some validation on the options after you’ve let optparse-applicative parse them
05:42:58 <AWizzArd> Is there a module defining helper functions for reading a Word64 from some index in a Word8 Vector?
05:46:46 <JJJollyjim__> Hi all, I'm using attoparsec and want to do something like `_ <- string "" <|> (skipWhile (\...))`
05:47:04 <JJJollyjim__> But that is an error, since string is a Parser ByteString and skipWhile is a Parser ()
05:47:23 <JJJollyjim__> Which doesn't matter to me, since I throw away the value in the do block, I just want to assert that it parses that stuff
05:47:32 <electrocat> AWizzArd: use (de)serialization stuff like 'binary'
05:47:48 <dihuteno> merijn: cocreature: thanks, I'll have to think about what I'm doing and see if I can make it work with an applicative parser
05:47:51 <electrocat> you probably need to convert the vector to bytestring though
05:48:11 <dihuteno> is the main reason monadic parsers aren't used because they don't perform as well?
05:48:22 <JJJollyjim__> (to clarify a typo, I didn't mean `string ""` but `string "abc..."`)
05:48:23 <merijn> dihuteno: No, it's because they imply ordering
05:48:31 <cocreature> JJJollyjim__: use "void (string "") <|> void (skipWhile …)"
05:48:33 <merijn> dihuteno: Commandline flags are generally unordered
05:48:44 <mauke> I don't think you need to void skipWhile
05:49:01 <mauke> :t void
05:49:02 <lambdabot> Functor f => f a -> f ()
05:49:05 <cocreature> oh right, I was too lazy to look at the types :)
05:49:10 <merijn> hmmm
05:49:24 <mauke> :t fmap (pure ())
05:49:26 <lambdabot> Functor f => f a -> f ()
05:49:32 <AWizzArd> electrocat: thx
05:49:35 <mauke> :t (*>) (pure ())
05:49:36 <lambdabot> Applicative f => f b -> f b
05:49:46 <mauke> :t (<*) (pure ())
05:49:47 <lambdabot> Applicative f => f b -> f ()
05:49:58 <mauke> obviously (<*) == fmap
05:50:04 <dihuteno> merijn: could you not make a monadic parser that pulled out the flags from any position, removed it from the arg list and passed it on to the next one?
05:50:08 <merijn> Persistent is seriously lacking in conditional inserts...I basically want to ensure an entry exists in the deb and not care whether it was added or already there
05:50:28 <merijn> dihuteno: That's messy business :)
05:50:54 <dihuteno> messy but it would allow a few neat things for flexibility
05:51:54 <cocreature> producing something like --help automatically would also be more tricky/impossible for a monadic parser
05:52:17 <cocreature> because there can be arbitrary Haskell functions embedded in your parser
05:52:24 <JJJollyjim__> Thanks mauke
05:52:54 <mauke> cocreature++
05:54:07 <cocreature> dihuteno: so if you would be willing to give up --help you could definitely build a monadic optparse library but that’s a big if
05:54:07 * hackage aeson-compat 0.3.7 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.7 (phadej)
06:02:33 <dihuteno> so I think a contrived example that might highlight what I think I need to do would be a program where I pass a string and an int as the arguments, but they could be in any order
06:03:00 <dihuteno> so "./cmd abc 10" or "./cmd 10 abc"
06:04:36 <dihuteno> parsing the first argument as a "data StringOrInt = S String | I Int" yields a particular value, but then you need to change the parser to only accept the other type of value
06:06:02 <dihuteno> is that impossible in an applicative parser or is there a messy approach you can take to make it work?
06:06:56 <dihuteno> "./cmd abc def" or "./cmd 10 11" would both be errors in this silly example
06:07:05 <cocreature> doing it in the parser is impossible but as I’ve alluded to before, you can do additional validation after you’ve got the parsed output from optparse-applicative
06:07:34 <phadej> dihuteno: foo<$>  abcP <*> intP <|> flip foo <$> intP <*> abcP
06:08:05 <cocreature> oh right *bangs head on desk*
06:09:03 <dihuteno> phadej: good point, my example isn't good enough... how about one where you can supply as many integers as you want but no two values can be the same?
06:09:13 <phadej> http://foswiki.cs.uu.nl/foswiki/pub/USCS/InterestingPapers/PermutationsJFP.pdf
06:09:29 <dihuteno> so "./cmd 1 2 3 4" is fine but "./cmd 1 2 2 4" is an error
06:09:54 <phadej> dihuteno: well, for that I'd use postprocess step
06:10:12 <phadej> i.e not use monadic parser for that.
06:10:33 <phadej> it's a bit like wanting to have well-scoped program coming out of the source-code parser
06:10:51 <phadej> parser is IMHO wrong place to do that kind of validation
06:11:19 <phadej> (or worse, well-typed!)
06:11:48 <cocreature> phadej: well-typed? I want to get the compiled asm! :)
06:12:03 <phadej> cocreature: compile <$> parse ;)
06:12:09 <cocreature> :)
06:12:38 * hackage yesod-static 1.5.3 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.3 (MichaelSnoyman)
06:12:41 <cocreature> hm but if you can enumerate the possibilities you could do it with an applicative-parser
06:13:06 <phadej> cocreature: it won't be inspectable (if you mean construct the infinite applicative parser)
06:13:20 <phadej> i.e. ./cmd --help -- what it would print
06:13:34 <cocreature> phadej: it could lazily print all options! :)
06:13:46 <phadej> cocreature: true, or say first 100 :)
06:16:18 <dihuteno> phadej: doesn't the "what would --help print?" question apply equally to using "many strArgument"?
06:17:21 <cocreature> dihuteno: no "many" is a class method so you can overwrite it
06:19:24 <merijn> hmm
06:19:29 <cocreature> hm but optparse-applicative doesn’t actually seem to do something particularly clever here
06:20:28 <merijn> Is there a more elegant thing to collect errors (when I don't care about results) than "Validation MyErr ()"?
06:22:45 <merijn> Or should I just have [MyErr] as result...
06:25:11 <aib> what am I doing wrong, searching for a parameter swapper as (a -> b -> c) -> (a -> c -> b) ?
06:25:23 <aib> err never mind
06:25:24 <cocreature> :t flip
06:25:26 <lambdabot> (a -> b -> c) -> b -> a -> c
06:25:31 <aib> *headdesk*
06:25:40 <cocreature> oh but your type signature is different
06:26:01 <cocreature> but your type signature doesn’t seem to make sense
06:26:43 <dihuteno> so what would happen if I made the optparse-applicative parser an instance of monad and then made something which solves that silly example I had above?
06:28:35 <aib> it's been a while since I've had time to practice haskell. I knew it was a stupid error, but couldn't see it :S
06:28:59 <merijn> hmmm
06:29:06 <dihuteno> no idea if this would work but "parseInts excluded = do { v <- noneOf excluded; return $ parseInts (v:excluded) ++ [v] }"
06:29:08 <merijn> Does anyone know which exceptions persistent can throw?
06:29:09 * hackage openweathermap 0.0.0 - Access data at OpenWeatherMap  https://hackage.haskell.org/package/openweathermap-0.0.0 (ip1981)
06:29:38 <aib> @pl iterate $ sum . map (^2) . (digits 10)
06:29:38 <lambdabot> iterate (sum . map (^ 2) . digits 10)
06:29:45 <aib> oh
06:30:15 <cocreature> wow a case where @pl does not make the code completely unreadable
06:30:27 <aib> I also seem to have forgotten what "point-free" means :S (I've been trying to avoid parentheses)
06:30:32 <dihuteno> could I then combine that will other parsers like "strArgument <*> parseInts []" (ignoring all the extra things you need for metavars and all that)
06:30:41 <aib> cocreature: I know, right? :)
06:35:54 <dihuteno> cocreature: merijn: phadej: hate to hassle you, but any ideas whether that might work before I go making the optparse-applicative parser an instance of Monad?
06:36:23 <dihuteno> I can't see any obvious holes in the logic myself
06:37:40 <dihuteno> other than my monadic parser would need to handle endOfInput properly, right now that one would probably fail without infinite arguments :)
06:41:24 <phadej> dihuteno: you cannot make it a Monad
06:42:18 <phadej> very briefly: it's a free applicative, for which you cannot write monad instance (it would be free monad then ;))
06:43:13 <phadej> dihuteno: e.g. if we had "argInt >>= \i -> argIntWithCheck (/= i)" what would --help print for that 
06:44:16 <phadej> or if we had "argInt >>= exactlyNStrArg"
06:45:54 <dihuteno> phadej: thanks, that actually makes it very clear
06:46:02 <dihuteno> I didn't know it was a free applicative
06:46:29 <ertes-w> @pl iterate $ \x -> sum (map (^2) (digits 10 x))
06:46:29 <lambdabot> iterate (sum . map (^ 2) . digits 10)
06:47:13 <ertes-w> @pl \x0 -> iterate (\x -> sum (map (^2) (digits 10 x))) x0
06:47:13 <lambdabot> iterate (sum . map (^ 2) . digits 10)
06:47:32 <phadej> dihuteno: virtually everything which has multiple interpretations is free something :)
06:47:56 <ertes-w> lambdabot: you're surprisingly good at this today
06:48:13 <ertes-w> kinda terrifying
06:48:24 <dihuteno> so this has three interpretations, the proper parsing, help generation and completion?
06:53:25 <phadej> dihuteno: IIRC
06:57:11 <ibwjt> :t (sequence .) . fmap
06:57:13 <lambdabot> (Monad m, Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
06:57:57 <ibwjt> :t sequence . fmap
06:57:59 <lambdabot> (Monad m, Traversable ((->) (m a1))) => (a1 -> a) -> m (m a1 -> a)
06:58:55 <phadej> @pl \f -> fmap f . sequenceA
06:58:55 <lambdabot> (. sequenceA) . fmap
06:59:02 <ibwjt> Can't really understand the dot notation
06:59:08 <phadej> :t (. sequenceA) . fmap
06:59:09 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
06:59:21 <jerbome> Hi folks, I'm a stack noob and cannot follow the quick start guide, can I ask for some help ?
06:59:57 <ibwjt> :t (join .) . fmap
06:59:57 <phadej> ibwjt: it is incomprehensible for most, when the are dots inside and outside the parentheses
06:59:58 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
07:00:09 <ibwjt> Yes those ones..
07:00:23 <ibwjt> I'm having lots of trouble with them
07:00:48 <phadej> ibwjt: and I'm quite sure I never seen them in the code on Hackage (which I have seen to quite extent)
07:01:48 <phadej> ibwjt: in other words, the fact you can, doens't mean you should :)
07:02:20 <ibwjt> But is there any very good resource or tutorial explaining them so that I can finally understand them enough?
07:03:48 <kuribas> ibwjt: f . g == \x -> f $ g x
07:04:12 <kuribas> ibwjt: it's not syntax, it's a binary operator
07:04:43 <jerbome> stack setup won't download ghc for me
07:04:58 <ibwjt> I have no problem with that but it's the both in and out dots
07:05:09 <ibwjt> that I'm having trouble
07:07:34 <ClaudiusMaximus> @unpl (f .) . g
07:07:34 <lambdabot> (\ x x0 -> f (g x x0))
07:08:23 <kuribas> ibwjt: just work it out: (join .) . fmap == \g -> (\x f -> join (f x)) (fmap g)
07:08:29 <quchen> jerbome: »Does not work« is not a description that helps us help.
07:09:05 <kuribas> == \g x -> join (fmap g x)
07:09:31 <glguy> dihuteno: for a simpler example of using a free applicative in a parsing context, check out the SectionSpecs type in https://glguy.net/config-demo
07:09:32 <jerbome> quchen: but it got your attention
07:09:57 <glguy> in that case the free structure is explicit
07:12:02 <phadej> ibwjt: all tutorials will more or like just walk you thru the individual rewrite steps
07:12:07 <phadej> like: https://gist.github.com/phadej/441edbda50b0b04190b03c0f01e8d312
07:12:16 <phadej> (sorry kuribas for spoiling :)
07:13:01 <phadej> ibwjt: doing that in the other direction is a bit more tricky, as you need to know how massage the expression so you could eta-reduce
07:13:40 <phadej> ibwjt: but it's not more difficult than moving stuff around, and applying definitions when solving physics equations
07:14:14 <ibwjt> It looks like it's easier for now if I just memorize (f . )  .g as a syntax
07:14:22 <phadej> ibwjt: no, just don't ever use it
07:14:40 <phadej> \f x -> join (fmap f x) is way more simpler
07:14:48 <phadej> if you struggle, your collegue will struggle to
07:15:52 <ibwjt> Actually, I don't understand how to reduce this: (join .) . fmap == \g -> (\x f -> join (f x)) (fmap g)
07:16:09 <ibwjt> eta reducing the lambdas
07:16:16 <ibwjt> somewhat confusing
07:16:34 <phadej> ibwjt: check my gist, I don't go thru that step at all
07:18:32 <ibwjt> it's a sound advice but still it will make feel better if I am comfortable with at least being able to decode these 
07:18:57 <phadej> ibwjt: where you have seen one?
07:19:33 <kuribas> ibwjt: (join .) == \f -> join . f == \f -> \x -> join (f x) == \f x -> join (f x)
07:19:46 <ibwjt> Haskellbook, p820, ch21 Traverable
07:19:49 <kuribas> ibwjt: it seems I switched f and x the first time though...
07:20:14 <kuribas> ibwjt: you see it's not good to leave out steps...
07:20:54 <kuribas> ibwjt: yeah, phadej's gist is much clearer
07:21:17 <ibwjt> I agree
07:21:46 <phadej> ibwjt: I checked, out of 1046942 non-empty lines of "other-haskell" code I have on my machine; there is 86 occurences of '.) .'
07:22:31 <ibwjt> that's a good stat.. 
07:24:09 <ibwjt> Thanks all for your help
07:24:40 <monad_cat> I wrote a script in Haskell that does some git automation (clone some repos, change a thing, push). I am getting an `security: createProcess: fork: resource exhausted (Resource temporarily unavailable)` error and program termination, what does this actually mean?
07:25:27 <phadej> but I guess I have to really find time and look thru haskellbook in detail
07:25:30 <phadej> it's just so huge :S
07:25:53 <sm> monad_cat: are you looping and creating many processes ?
07:26:01 <SepakoRayl> anyone read the "trees that grow" paper ?
07:26:55 <ibwjt> the problem is, a newbie like me keeps forgetting even things I already read..
07:26:59 <monad_cat> sm: yes, git clones are separate processes forked with `async` and I'm waiting for them to finish. There are also some command calls which I expect to fork new processes under the hood
07:27:07 <merijn> monad_cat: It means that your kernel/OS isn't letting you create more processes
07:27:11 <sm> https://github.com/Gabriel439/Haskell-Turtle-Library/issues/82 might be relevant (read exit code of terminated processes to force cleanup
07:27:32 <monad_cat> shouldn't haskell not fork 'real' OS processes but use internal cheap threads?
07:27:44 <ibwjt> quite hard to keep up with huge books
07:28:05 <monad_cat> and only fork as many OS-level processes as there are cores (I'm providing -N rtsops)
07:28:09 <merijn> monad_cat: If you're using System.Process to run git then that creates a new process
07:28:29 <merijn> monad_cat: Run "ulimit -a" in your shell and check what it says for "max user processes"
07:29:04 <monad_cat> merijn: yeah, I'm using System.Process :(
07:29:27 <sm> running a separate program (git) requires OS-level processes, I would think
07:29:42 <monad_cat> my process limit is 709, which should be fine (I fork ~100 processes for git clones)
07:29:44 <merijn> monad_cat: You have to when you're using existing programs like git, but the fact that Haskell uses green threads doesn't stop things like git from needing their own process
07:29:58 <monad_cat> unless System.Process leaks processes because laziness?
07:30:12 <merijn> monad_cat: Do you ever wait for the processes you spawn?
07:30:24 <merijn> monad_cat: Also, run "ps uax | grep git"
07:30:37 <merijn> monad_cat: Paste the output of that on lpaste
07:30:40 <monad_cat> yes, I do, I run a couple sequential processes
07:30:48 * merijn suspects a zombie invasion
07:30:59 <merijn> That, or git is spawning crazy helper processes
07:31:00 <monad_cat> effectively `proc "git clone" >> proc "git commit" >> proc "git push"` to use some pseudocode
07:31:14 <glguy> no, wait is a system call, not just a patience thing
07:31:19 <ibwjt> from about the Monoid chapter of the Haskellbook, almost always I had to look up other people's solutions for the exercises
07:31:20 <merijn> monad_cat: Also, are you running these operations on the same process?
07:31:21 <sm> maybe http://hackage.haskell.org/package/gitlib allows green threads
07:31:26 <merijn> eh
07:31:30 <merijn> on the same repo, I mean
07:31:47 <monad_cat> merijn: I have below 100 green threads that call at most one command at a time each
07:32:03 <merijn> monad_cat: Please show me the output of "ps uax | grep git" :)
07:32:04 <monad_cat> so if git spawns many processes itself, then this could be the issue
07:32:19 <monad_cat> merijn: 5 processes
07:32:41 <glguy> the zombies will be cleaned up when his program is liked
07:32:42 <merijn> oh, wait I suppose this is after your process exits, so that's not helpful...
07:32:43 <merijn> hmmm
07:32:47 <merijn> glguy: Yeah I just realised
07:32:59 <merijn> monad_cat: copy paste the code where you run and wait for the process
07:33:16 <merijn> Or, more likely, where you run and don't wait for the process :p
07:33:29 <mauke> "liked"?
07:33:41 <glguy> mauke: phone auto correct
07:33:53 <merijn> ha
07:34:07 * mauke likes that
07:34:21 <merijn> "alias like=nice -20"
07:34:35 <merijn> actually
07:34:39 <monad_cat> merijn https://www.irccloud.com/pastebin/87PG1GCf/
07:34:48 <merijn> Better yet: alias like="nice -n-1"
07:35:18 <merijn> monad_cat: What is readCreateProcess?
07:35:46 <merijn> oh, that's in process
07:35:49 <monad_cat> https://hackage.haskell.org/package/process-1.6.0.0/docs/System-Process.html#v:readProcess
07:35:50 <monad_cat> yeah
07:36:12 <merijn> odd, that does call wait internally
07:36:35 <monad_cat> even weirder, calling with -N1 seems to fix it
07:37:07 <ibwjt> :t (join .)
07:37:08 <merijn> monad_cat: Where do you turns this into an async?
07:37:08 <lambdabot> Monad m => (a1 -> m (m a)) -> a1 -> m a
07:37:41 <merijn> New theory: You are actually spawning a lot more threads and processes than you think :)
07:39:32 <monad_cat> merijn: there's too many layers of indirection to post here, but I'm running all the commands through `cmdInPlugin` and use something like `mapM (\something -> async $ runJob something) things >>= mapM wait` for starting the threads
07:39:54 <merijn> monad_cat: And you're sure things only contains a 100 or so elements?
07:40:26 <ibwjt> @unpl (join . )
07:40:26 <lambdabot> (\ g x -> g x >>= \ x0 -> x0)
07:40:36 <ibwjt> @unpl (f . )
07:40:36 <lambdabot> (\ g x -> f (g x))
07:41:09 <monad_cat> merijn: 268 elements to be exact, logged it now
07:41:18 <warbo> hello, I'm trying to synthesise a ~/.cabal directory, as if I'd run "cabal update", but instead taking the data from the all-cabal-hashes repo
07:41:48 <monad_cat> 2.6 times below the process limit
07:42:09 <warbo> so far I have the repo contents (foo/version/foo.cabal for all hackage projects), but my 00-index.tar doesn't seem to be acceptable by "cabal install"
07:42:25 <warbo> it's saying e.g. "cabal: There is no package named 'containers'." when I test it
07:42:33 <ibwjt> @unpl (f .) .
07:42:33 <lambdabot> <unknown>.hs:1:8:Parse error in expression: (f .) .
07:42:51 <ibwjt> @unpl (f .)
07:42:51 <lambdabot> (\ g x -> f (g x))
07:42:52 <mauke> monad_cat: have you tried strace?
07:43:05 <ibwjt> @unpl (f .) . g
07:43:05 <lambdabot> (\ x x0 -> f (g x x0))
07:43:08 * hackage n-tuple 0.0.1.1 - Homogeneous tuples of arbitrary length.  https://hackage.haskell.org/package/n-tuple-0.0.1.1 (athanclark)
07:43:12 <ibwjt> @unpl (f .) x
07:43:13 <lambdabot> (\ x0 -> f (x x0))
07:44:02 <ibwjt> @unpl (f .) . x
07:44:02 <lambdabot> (\ x0 x1 -> f (x x0 x1))
07:44:15 <reactormonk[m]> monad_cat: ulimit for number of processes was hit
07:44:44 <monad_cat> mauke: no, actually, I've never used it (slightly embarrassed :) ). How should I use it to debug this issue? 
07:45:29 <mauke> in general, strace yourprogram --options --and --stuff
07:45:32 <mauke> that logs to stderr
07:45:48 <mauke> strace -o trace.log ... to write to a file
07:45:59 <ibwjt> @unpl (f .) . g
07:45:59 <lambdabot> (\ x x0 -> f (g x x0))
07:46:02 <monad_cat> and then would it log each OS thread being spawned and killed?
07:46:03 <ibwjt> @unpl (f .) g
07:46:03 <lambdabot> (\ x -> f (g x))
07:46:11 <merijn> Actually, first question would be: Are you on an OS that has strace?
07:46:17 <mauke> good point
07:46:19 <merijn> because AFAIK only linux has strace
07:46:20 <monad_cat> merijn: OSX
07:46:20 <mauke> strace is linux specific
07:46:27 <monad_cat> but I can run it on linux as well
07:46:32 <merijn> monad_cat: Right, then strace doesn't exist ;)
07:46:33 <mauke> what's the OSX thing? dtrace?
07:46:36 <merijn> You want dtruss
07:46:50 <warbo> ah, I think I'm missing "foo/preferred-versions" files
07:46:56 <merijn> mauke: dtruss is the BSD/OSX version of strace. You could use dtrace but it's strictly more general
07:46:58 <monad_cat> my linux machine is 40 centimeters to the right, I can run it on linux as well
07:48:12 <mauke> I have no experience with dtruss
07:48:26 <ibwjt> @unpl (f .) (g x)
07:48:26 <lambdabot> (\ x0 -> f (g x x0))
07:48:47 <monad_cat> Thanks for your help everyone, I'll run strace in a couple of hours and let you know what I find
07:51:36 <ibwjt> @unpl f . g
07:51:36 <lambdabot> (\ x -> f (g x))
07:52:43 <mauke> monad_cat: probably something boring like clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fefbeb949d0) = -1 EAGAIN (Resource temporarily unavailable)
07:54:21 <monad_cat> mauke: yeah, though I need to trace the total amount of processes alive to see why the process limit was hit. It seems someone did the boilerplate already: https://stackoverflow.com/questions/4053142/how-to-track-child-process-using-strace
07:54:38 <ibwjt> @unpl (f .) . g x
07:54:38 <lambdabot> (\ x0 x1 -> f (g x x0 x1))
07:57:21 <tsahyt> Is there a library providing fold variants with the function as the last argument?
07:57:48 <tsahyt> so I could write e.g. flippedFold 0 xs $ \z x -> someStuff
07:58:15 <tsahyt> especially for the monadic variants this would be very nice
08:02:24 <ibwjt> @unpl (f .) . g
08:02:24 <lambdabot> (\ x x0 -> f (g x x0))
08:03:37 * hackage console-prompt 0.1 - console user prompts  https://hackage.haskell.org/package/console-prompt-0.1 (jlamothe)
08:10:27 <ibwjt> @unpl (f .) . g h
08:10:27 <lambdabot> (\ x x0 -> f (g h x x0))
08:10:59 <tsahyt> @hoogle Foldable t => b -> t a -> (b -> a -> b) -> b
08:10:59 <lambdabot> Prelude foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
08:10:59 <lambdabot> Data.List foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
08:10:59 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
08:11:10 <tsahyt> hm, I wish there was a way to force argument order with hoogle
08:20:21 <jle`> :t \z xs f -> foldl f z xs
08:20:23 <lambdabot> Foldable t => b -> t a -> (b -> a -> b) -> b
08:21:07 <tsahyt> jle`: I was hoping for something in a library, just to prevent having a Util module for all of these around
08:21:26 <jle`> yeah, trying to figure out what the type i'm looking for is
08:32:29 <jle`> :t \z xs -> flip execState z . forM_ xs . fmap modify
08:32:30 <lambdabot> Foldable t => s -> t a -> (a -> s -> s) -> s
08:32:51 <jle`> (don't do that)
08:34:35 <tsahyt> well that is certainly an interesting approach
08:34:44 <tsahyt> I think I'll just write a util module. monad-loops doesn't have what I want either
08:34:53 <tsahyt> I'm actually particularly interested in the monadic variants. e.g. a flipped foldlM
08:35:11 <tsahyt> :t \z xs f -> foldlM f z xs
08:35:12 <lambdabot> (Monad m, Foldable t) => b -> t a -> (b -> a -> m b) -> m b
08:36:06 <ibwjt> @unpl (join (f x)) . fmap
08:36:06 <lambdabot> (\ x0 -> (f x >>= \ x1 -> x1) (fmap x0))
08:36:19 <ibwjt> @unpl (f (g x)) . h
08:36:19 <lambdabot> (\ x0 -> f (g x) (h x0))
08:37:30 <jle`> :t \z xs -> flip execStateT z . forM_ xs . fmap modifyM
08:37:31 <lambdabot> (Foldable t, Monad m) => s -> t a -> (a -> s -> m s) -> m s
08:43:56 <TristanBKildaire> Hi all
08:53:00 <MitchellSalad> hello
08:55:23 <Iceland_jack> Hey
08:55:39 <ibwjt> It's been a good day.
08:56:01 <ibwjt> IRC is so helpful in learning..
08:56:38 * hackage attoparsec-uri 0.0.0 - URI parser / printer using attoparsec  https://hackage.haskell.org/package/attoparsec-uri-0.0.0 (athanclark)
08:57:18 <ibwjt> I love this haskell community - so helpful and kind.
08:58:29 <MitchellSalad> is that sarcasm? haha
08:58:55 <Iceland_jack> #haskell loves you back
08:59:00 <MitchellSalad> i think so too but someone was in here the other day saying exactly the opposite
08:59:02 <ibwjt> Nope. I really meant it.
09:00:36 <ibwjt> I always regret why I ask for help on IRC earlier rather than keep reading the book again and again
09:00:59 <ibwjt> It could have saved my time and headache
09:03:14 <MitchellSalad> word
09:07:35 <bollu> hello all
09:10:17 <shapr> Where can I order haskell t-shirts?
09:10:21 <shapr> hi bollu!
09:10:38 <bollu> shapr: hello :)
09:11:02 <shapr> how's code? made anything neat?
09:11:32 <bollu> shapr: still working on this - https://github.com/bollu/simplexhc
09:11:50 <bollu> shapr: I now understand way more about how haskell compiles, so that's good I guess
09:12:09 <shapr> bollu: awesome!
09:13:24 <bollu> shapr: why haskell T-shirts? fallen in love? :)
09:14:23 <shapr> mostly because my coworkers tease me that I need more Haskell t-shirts, so I figured I'd buy some.
09:14:35 <shapr> I'd even prefer paying more money to support haskell.org
09:14:46 <cocreature> shapr: go to conferences :)
09:14:56 <shapr> sensible
09:15:05 <cocreature> zurihac has tshirts
09:15:27 <Iceland_jack> 1. Submit paper to ICFP, 2. Give talk, 3. T-shirts
09:15:39 <cocreature> oh I didn’t know icfp had tshirts too
09:15:51 <bollu> cocreature: oh really? yay!
09:15:54 <Iceland_jack> 2.5 Make ICFP give out T-shirts
09:15:59 <bollu> cocreature: I didn't know zurihac has tshirts
09:16:22 <bollu> Iceland_jack: does ICFP accept papers of the form "so I had this neat idea, I did it, but performance is atrocious"? :P
09:16:32 <bollu> Iceland_jack: I have a feeling my experiment is going to work out that way
09:16:59 <cocreature> bollu: not being able to go to zurihac this year is annoying just because my 2015 zurihac tshirt is slowly starting to wear out :)
09:17:24 <bollu> cocreature: that's the universe's way of telling you to drop by :)
09:17:34 <shapr> cocreature: are you coming to ICFP this year?
09:17:35 <bollu> cocreature: OK I'll stop bugging you now about coming to zurihac
09:17:38 * hackage concurrency 1.1.2.1, tasty-dejafu 0.6.0.0, hunit-dejafu 0.6.0.0, dejafu 0.7.0.0 (barrucadu): https://qbin.io/sfk2itx
09:17:41 <bollu> shapr: where is ICFP?
09:17:49 <cocreature> shapr: sadly no
09:18:06 <cocreature> shapr: but I might go to hal and I’m planning to go to munihac assuming I have time when it takes place
09:18:06 <n_blownapart> hi a couple things about this Ackermann's problem. first, I don't know how it works in haskell. second, it's hanging with the pasted inputs. 3rd I'm getting ghc error "Illegal literal in type (use -XDataKinds to enable): 0  . this is from a tutorial. I pasted the scheme code since I fully understand how it works, thanks
09:18:10 <n_blownapart> http://lpaste.net/356099
09:18:24 <bollu> cocreature: tell me about hal and munihac?
09:18:26 <dolio> shapr: You can probably just submit designs to various t-shirt printing sites. I think that's what the darcs folks did. They don't get money from the shirts, though.
09:18:36 <cocreature> bollu: https://hal2017.softbase.org/
09:19:01 <cocreature> bollu: munihac is not yet announced but quchen assured me there will be one
09:19:02 <n_blownapart> i.e . it was hanging now, I guess yesterday I had it working insofar that it was hanging it doesn't work. 
09:19:29 <n_blownapart> ie help me fix it please
09:19:41 <bollu> cocreature: ooh neat. I'll attend as long as it's before december
09:20:03 <bollu> hm, how do I sign up for Haskell in Leipzig
09:20:47 <cocreature> you can’t signup yet
09:21:15 <cocreature> it’s not officially announced but I vaguely know henning and he asked me to come :)
09:21:33 <bollu> ah, I see
09:22:03 <cocreature> I might even hand in a talk for hal but I still need to decide on the subject :)
09:22:06 <bollu> cocreature: could you do me a favour and remind me to sign up? :) 
09:22:08 <bollu> ah, neat!
09:22:18 <cocreature> bollu: I’ll do my best :)
09:22:46 <bollu> cocreature: ty
09:22:49 <cocreature> bollu: monitoring haskell-cafe and reddit will probably also let you know about it
09:23:06 <bollu> cocreature: yep, I do use reddit.
09:23:52 <lyxia> n_blownapart: the code you pasted won't compile, how can it hang?
09:24:32 <n_blownapart> I think I changed it late last night lyxia . thanks for looking. could you help me fix it and explain vis a vis the scheme code?
09:26:33 <glguy> This isn't the appropriate channel to get help with Scheme
09:26:50 <n_blownapart> I got it to the point where it was hanging, the code had blog comments saying that it hangs with those inputs due to a bug. the output shouldn't be too huge lyxia.
09:27:23 <n_blownapart> ok ignore the scheme I remove it from the paste
09:27:29 <n_blownapart> I'll
09:28:04 <lyxia> You have some scheme code, and for some reason you have some Haskell code that's supposed to look like it
09:28:44 <n_blownapart> I removed the scheme. it was for my own benefit
09:28:44 <lyxia> but it's quite far from syntactically correct code
09:33:01 <n_blownapart> if you could help me rewrite it with (A m n) as (A 1 4) I would appreciate it lyxia. any commentary on the syntax appreciated
09:33:44 <ADG_> >  print . sum $ map (\a -> maximum $ map (\n -> (2*a*n) `mod` (a*a)) [1,3..a*a-1] :: Int) [3..1000]
09:33:46 <lambdabot>  <IO ()>
09:34:48 <ADG_> It should take 3.3e8 operations IMO, why isn't there any answer?
09:35:05 <ADG_> It took 70 seconds on my PC.
09:35:07 <lyxia> n_blownapart: it looks like you got the code from here https://stackoverflow.com/questions/16115815/ackermann-very-inefficient-with-haskell-ghc
09:35:36 <ADG_> not actually
09:36:15 <ADG_> 0.86 sec on Java
09:36:28 <ADG_> God knows how fast it'll run in C
09:37:52 <lyxia> ADG_: your algorithm is inefficient.
09:38:22 <n_blownapart> correct lyxia thanks for the help
09:38:51 <ADG_> That may be true but the difference is too large between languages
09:39:28 <lyxia> ADG_: I doubt you were running something that was really equivalent in other languages
09:39:44 <ADG_> So what do you suggest?
09:41:47 <Ulrar> By any chance, has anyone any idea about where the "fromJSONError" at the end of this comes from ? https://github.com/himura/twitter-conduit/blob/e09e42805c6065fd9e0cefee55fcdb387ccde065/Web/Twitter/Conduit/Base.hs
09:42:19 <Ulrar> Can't figure out which of those imports is the correct one, and when I google for it it seems to be in a completly unrelated package, which seems weird
09:44:41 <lyxia> ADG_: what does it look like in Java
09:45:26 <ADG_> https://github.com/adityagupta1089/Project-Euler/blob/master/src/problems/P120.java
09:45:54 <ClaudiusMaximus> ADG_: are you compiling?  are you compiling with optimisations?  your code runs in 7.6 seconds here, with  ghc-8.0.2 -O2
09:46:18 <ADG_> That is still too much
09:46:30 <Lokathor> ADG_, yeah the biggest thing that bites you when you don't know about it is that ghci is butts for speed
09:47:00 <ADG_> I was compiling without optimization giving me 70 secs
09:47:53 <Lokathor> gotta have your opts
09:48:59 <Lokathor> now, that settled, let's dig deeper into this
09:49:10 <ADG_> But even then why is it so slower? Does it actually allocated space for 1^2+2^2...1000^2~3.3e8 ints? C version without opts in .68
09:50:35 <Lokathor> don't think so
09:50:45 <Lokathor> lemme compile this in some scratch space
09:51:25 <ClaudiusMaximus> ADG_: here, running with +RTS -s  shows "21,365,395,144 bytes allocated in the heap", with "44,384 bytes maximum residency"
09:51:42 <ClaudiusMaximus> so it's generating a lot of very-short-lived garbage
09:52:45 <Lokathor> I'm getting about the same 7.4 seconds
09:54:15 <lyxia> I wonder why GHC can't fuse this
09:54:48 <n_blownapart> lyxia, hi I'm still looking for code that is *not* that stackOverflow code , for Ackermann's
09:55:01 <lyxia> n_blownapart: why
09:55:55 <lyxia> there are tons of variants in the answers
10:00:50 <ADG_> the only thing worse than this was python3 in 79
10:01:10 <ADG_> so i guess maybe its okay
10:01:14 <ADG_> *it's
10:01:23 <n_blownapart> lyxia, I'm looking at one called "simple_ack.hs" but it looks identical. I need the simplest possible solution . I don't know haskell. 
10:02:49 <lyxia> it's already as simple as it gets
10:03:32 <n_blownapart> forget it
10:07:48 <Lokathor> funnily enough
10:07:57 <Lokathor> the ST version of this seems to run ~slightly slower~
10:08:42 <ClaudiusMaximus> ADG_: i've got it down to 3.8s and no GC by translating the java, still too slow
10:09:40 <Lokathor> ClaudiusMaximus, what's yours look like?
10:10:22 <n_blownapart> lyxia, I don't understand; you say it's syntactically incorrect, it doesn't compile, and you say it's as simple as it gets. what are you referring to?
10:11:38 <Lokathor> https://pastebin.com/1tDePS6b
10:11:59 <theelous3> hi there. I'm trying to write elem with a fold and func comp, but am baffled as to where to go from here: elem''' x = foldl ( . (==x)) False
10:12:43 <theelous3> (I had a version just using a lambda, but a mate said to give it a go with ., which I'd just started looking in to.)
10:13:54 <ClaudiusMaximus> Lokathor: https://pastebin.com/DJ5xFBrB
10:14:04 <lyxia> n_blownapart: the code on SO which you say was what you had initially is as simple as it gets 
10:14:44 <Lokathor> Poor ST, being beaten out by a simple strict go-func
10:15:31 <n_blownapart> lyxia, thanks hold on please
10:19:05 <cocreature> theelous3: can you show us the version with the lambda? that might make it easier to explain how to translate that to .
10:19:16 <theelous3> elem'' x = foldl (\acc y -> if y == x then True else acc) False
10:20:08 <cocreature> theelous3: alright, can you rewrite the lambda in terms of || and without an if?
10:20:44 <theelous3> I was thinking of ||, but I need to have a way to refrence the fold's acc. I can't see a way to do that
10:21:16 <cocreature> theelous3: it’s fine to still use a lambda (for now). just try to replace the if by || as a first step
10:21:20 <theelous3> ok
10:22:15 <theelous3> elem''' x = foldl (\acc y -> acc || True) False
10:22:32 <cocreature> that’s not the same. you are no longer doing the y == x comparison
10:24:36 <theelous3> o i c. elem''' x = foldl (\acc y -> y == x || False) False
10:25:09 <kadoban> y == x || False    is the same thing as  y == x  (and now you're not using acc)
10:25:19 <cocreature> but you’re getting close :)
10:25:21 <theelous3> yeah I just realised that staring at it :P
10:25:31 <kadoban> Yes, definitely heading in the right direction
10:27:10 <ClaudiusMaximus> Lokathor: https://pastebin.com/r2LATBYP 0.65s
10:27:35 <theelous3> elem''' x = foldl (\acc y -> y == x || acc) False  <- I feel like that's closer (uses acc) but still not what you guys mean by replace "if" with "||"
10:27:59 <theelous3> kinda redundant
10:28:08 <kadoban> theelous3: That's what I expected the answer to be for that step. So if you're wrong we both are so far.
10:28:16 <theelous3> ok, well, good :D
10:28:52 <cocreature> no that’s correct but let’s use "\acc y -> acc || x == y" instead which makes it slightly easier to work with
10:29:13 <theelous3> ok, yeah. keep the acc on left for left foldin'
10:29:47 <cocreature> let’s take a look at how (.) is defined
10:29:49 <cocreature> @src (.)
10:29:49 <lambdabot> (f . g) x = f (g x)
10:29:58 <theelous3> nice bot
10:30:32 <cocreature> theelous3: do you know how to turn infix operators into prefix operators by wrapping them in parenthesis?
10:30:50 <theelous3> like, partial application?
10:30:54 <theelous3> (+2) 
10:31:00 <cocreature> you can also just use (+)
10:31:08 <theelous3> aye
10:31:11 <cocreature> (+) 1 2 is the same as 1 + 2
10:31:15 <theelous3> roger
10:31:31 <cocreature> theelous3: so try rewriting that lambda using (||) instead of using it as an infix operator
10:31:38 <theelous3> oh yeah I see
10:33:25 <theelous3> elem''' x = foldl (\acc y -> (||) (y == x) acc) False
10:34:43 <cocreature> hm this is trickier for foldl than I thought. foldr would be easier :)
10:35:05 <theelous3> they also said I might have an easier time reasoning it out with foldr, but...I didn't :P
10:35:32 <Sonolin> probably best to not worry about point free and/or infix atm
10:35:43 <theelous3> elem''' x = foldr (\y acc -> (||) acc (y == x)) False  <- foldr version
10:36:37 <theelous3> I think i got it
10:36:47 <theelous3> elem''' x = foldr ((||) . (==x)) False
10:36:56 <cocreature> that’s "\y acc -> x == y || acc"
10:37:24 <cocreature> so it’s close but not quite the version where acc is on the left of ||
10:37:42 <cocreature> you can easily fix that by placing "flip" at the right place :)
10:38:06 <theelous3> my "flip"?
10:38:12 <theelous3> just switch my ==x for x==?
10:38:15 <cocreature> :t flip
10:38:16 <lambdabot> (a -> b -> c) -> b -> a -> c
10:38:40 <cocreature> "flip" takes a function that takes two arguments and gives you back a function that takes those two arguments in a different order
10:38:41 <theelous3> oh sorry, I misread what you said. I thought you said "my flip"
10:38:43 <Lokathor> when inputs are positive, mod and rem are the same right?
10:39:16 <theelous3> so I could flip the function composed by . func composition
10:39:28 <cocreature> theelous3: in this case you can just flip (||)
10:39:39 <cocreature> so flip (||) . (==x) for the foldr version
10:39:49 <cocreature> if you want the foldl version flip all of that
10:39:55 <cocreature> i.e. flip (flip (||) . (==x))
10:40:03 <theelous3> I don't get why I'd flip ||, it's agnostic of whatever's on either side no?
10:40:20 <MitchellSalad> > True || undefined
10:40:22 <lambdabot>  True
10:40:36 <cocreature> theelous3: not quite. || is lazy. so if it’s first argument is True it doesn’t even need to look at the right argument
10:40:36 <theelous3> False || True is the same as True || False?
10:40:57 <theelous3> cocreature: how would that make a difference?
10:41:10 <theelous3> once we get a True it doesn't matter if there's another True
10:41:11 <MitchellSalad> I just showed you :)
10:41:13 <cocreature> theelous3: the second argument could be something that is expensive to compute
10:41:17 <cocreature> or it could throw an exception
10:41:26 <cocreature> MitchellSalad: you still need to show the other direction :)
10:41:32 <MitchellSalad> > undefined || True
10:41:34 <lambdabot>  *Exception: Prelude.undefined
10:42:19 <theelous3> huh, that's interesting
10:42:19 <theelous3> ok
10:43:01 <cocreature> theelous3: in the case of elem it means that it can give you back "True" without having looked at all elements if it has found the element
10:43:20 <cocreature> theelous3: if you place acc on the right side of || it will always look at all elements
10:43:54 <cocreature> > foldr (\x acc -> (x==5) || acc) False [5,undefined]
10:43:56 <lambdabot>  True
10:44:09 <cocreature> > foldr (\x acc -> acc || (x==5)) False [5,undefined]
10:44:11 <lambdabot>  *Exception: Prelude.undefined
10:44:21 <cocreature> eh I said it the wrong way around :)
10:44:26 <cocreature> but you see the difference
10:44:27 <theelous3> i gettcha though
10:44:44 <cocreature> > foldr (\x acc -> acc || (x==5)) False [5..]
10:44:47 <lambdabot>  *Exception: stack overflow
10:44:57 <cocreature> > foldr (\x acc -> (x==5) || acc) False [5..]
10:44:59 <lambdabot>  True
10:45:10 <cocreature> that’s a slightly more realistic example
10:47:16 <n_blownapart> lyxia, thanks for not spoon-feeding me. it was the uppercase function name. sorry
10:48:52 <kyclark> My problem: https://paste.ofcode.org/ZAVFJtx7UKUThhN8iyavB2
10:49:04 <kyclark> Any takers?  I’m halfway there, I think.
10:51:07 * hackage attoparsec-uri 0.0.1 - URI parser / printer using attoparsec  https://hackage.haskell.org/package/attoparsec-uri-0.0.1 (athanclark)
10:52:18 <ClaudiusMaximus> @check (\x y -> x >= 0 && y > 0 ==> mod x y == rem x y)
10:52:19 <lambdabot>  :-1:-1:Ambiguous infix expression
10:52:32 <ClaudiusMaximus> @check (\x y -> (x >= 0 && y > 0) ==> (mod x y == rem x y))
10:52:34 <lambdabot>  +++ OK, passed 100 tests.
10:52:38 <ClaudiusMaximus> Lokathor: ^^
10:52:59 <Lokathor> neato
10:53:04 <cocreature> if you want to be pedantic, mod and rem are typeclass methods so you could make an instance that doesn’t satisfy this
10:53:12 <cocreature> but for all reasonable instances that should hold
10:53:21 <Lokathor> I'm only worried about remInt#
11:02:07 <Lokathor> https://pastebin.com/0PRJhShK faster, but still not as fast as your version ClaudiusMaximus 
11:02:17 <Lokathor> i'm thinking GHC can't see optimizations it's seeing on yours
11:03:43 <cocreature> Lokathor: maybe try 8.2? I don’t have a good feeling yet for when the joinpoints optimizations are applicable but afaik they’re particularly good in those tight loops so maybe they help here
11:04:28 <merijn> hmmm, is there a way to accomodate streaming libraries like pipes/conduit/etc. without tying yourself to one of them? I have some code that takes "a -> IO b" as input (currently), but I could see people wanting to pass in some kinda of streaming code there instead. However I don't know how to accommodate that without tying myself to one of those libraries
11:04:44 <Lokathor> cocreature, gotta go to work, and i probably won't care about this when i get home :P
11:04:50 <cocreature> Lokathor: fair enough :)
11:04:54 <maerwald> 8.2?
11:04:56 <cocreature> Lokathor: I guess I’ll have to try myself :)
11:05:29 <merijn> maerwald: release candidate has been out for a while
11:05:42 <dmwit> kyclark: Have you gotten any takers?
11:05:47 <maerwald> oh, I thought I slept through and missed a release
11:05:49 <kyclark> No, still stuck.
11:06:22 <MitchellSalad> merijn: what does your function do with the 'a -> IO b'?
11:07:50 <merijn> MitchellSalad: Basically, "mapM" i.e. looping over a bunch of a's to produce b's
11:07:58 <dmwit> kyclark: Consider what recursing on `x <*> Cons a b` would do.
11:07:59 <cocreature> Lokathor: fyi, there is no significant difference with 8.2
11:08:21 <merijn> MitchellSalad: But I can imagine people wanting to consume multiple a's (rather than one) or returning multiple b's rather than one
11:08:39 <dmwit> kyclark: And yes, you'll probably need an analog of `(++)`. Compare:
11:08:39 <kyclark> dmwit: Right, I was just thinking that I’ve solve the first half, so how to get the second.
11:08:40 <dmwit> :t (:)
11:08:42 <dmwit> :t (++)
11:08:42 <lambdabot> a -> [a] -> [a]
11:08:43 <lambdabot> [a] -> [a] -> [a]
11:09:55 <merijn> MitchellSalad: But I wanna avoid tying myself to a specific streaming API, because while I prefer pipes I occasionally have to use conduit because other libraries are already using it and mixing pipes and conduit seems a bit ridiculous
11:12:05 <merijn> MitchellSalad: I thought about maybe taking "IO a -> (b -> IO ()) -> IO ()" as, but I think then I end up giving away "too much" control to enforce some of the invariants I need
11:12:21 <maerwald> merijn: very simple! just need to abstract over pipes and conduits, haha
11:12:34 <ClaudiusMaximus> Lokathor: my fast version avoids calling mod or rem at all, using (>=) and (-) with an accumulator instead of multiplication
11:14:09 <merijn> maerwald: Well, yes. Or some primitives that let me easily convert to one or the other, but I'm having a hard tim determining how
11:27:11 <kuribas`> Is there any advantage in using multiple cores in a single app?
11:27:27 <kuribas`> Isn't it better to use the cores for running apps simultanously?
11:27:52 <kadoban> kuribas`: It depends
11:28:01 <ClaudiusMaximus> kuribas`: yes, but sometimes an app can't be split into multiple separate processes
11:29:03 <kyclark> dmwit: https://paste.ofcode.org/uLHbknKLYXtA7c2Hhb6SyJ I can break the first and second bits apart, the compiler doesn’t mind, but I can’t figure how to compose them back together.
11:30:09 <EvanR> separate processes have to communicate with each other through an IPC mechanism
11:30:54 <EvanR> a single processes using multiple cores can communicate through magic cpu memory directly
11:31:25 <kuribas`> kyclark: why do you do (fmap f b) on line 44?
11:32:40 <kyclark> kuribas, as I understand, I have unpacked the function “f” from the Cons, so I can use the fmap implementation to recursively apply the function to the List.  That part seems to work.
11:33:09 <kuribas`> kyclark: what's the type of first and second?
11:34:25 <kyclark> Hmm, I think they should both be Lists.
11:34:52 <kyclark> Eventually, I should get to Nil on both Lists.
11:34:58 <kuribas`> kyclark: but you cannot Cons a list and a list.
11:35:31 <kuribas`> kyclark: right?
11:35:42 <jle`> btw, a bit of naming changes might help with the conceptual understanding.  instead of fmap f (Cons a x), try fmap f (Cons x xs)
11:36:04 <jle`> and `Cons f fs` and `Cons x xs`, perhaps
11:36:34 <kuribas`> kyclark: first and second both have type (List a), but Cons has type a -> List a -> List a, right?
11:36:37 <jle`> if you do need to pattern match on the second list
11:38:04 <kyclark> Sorry, thinking hard here.
11:38:16 <kyclark> Also furiously renaming vars
11:39:03 <MitchellSalad> merijn: hm, I'd have to see more of your api to see what you are talking about
11:39:34 <kuribas`> kyclark: if first and second both have type (List a), how can you combine them into a single (List a)?
11:41:01 <nitrix> ap :: f (a -> b) -> f a -> f b
11:41:02 <nitrix> ap :: List (a -> b) -> List a -> List b
11:42:00 <nitrix> Does it helps if you think of it as a list of functions to be applied to a list of other things?
11:42:08 <nitrix> Producing a list of results?
11:42:32 <kuribas`> nitrix: that's not where he's stuck...
11:43:36 <kyclark> “first” will produce “Cons 2 (Cons 3 Nil)”
11:43:47 <nitrix> Seems to me like that's where he is stuck. His question says how to apply "x". In his example, `x` is of type `List (a -> b)`, you wont be able to apply that on its own.
11:43:52 <kyclark> and I guess I need to insert “second” where the Nil is?  Ugh, I’m so lost.
11:44:11 <kuribas`> kyclark: and second will produce what?
11:44:23 <kyclark> Was it wrong to use the fmap?  I’m uncertain how to recurse.
11:44:32 <kuribas`> kyclark: that's fine
11:46:22 <kuribas`> kyclark: second will produce (Cons 2 (Cons 4 Nil)), right?
11:46:52 <kyclark> kuribas, yes, I think so.
11:47:24 <kuribas`> kyclark: then how to go from that to (Cons 2 (Cons 3 (Cons 2 (Cons 4 Nil))))?
11:47:25 <nitrix> I'm sure if you were to focus only on how would you concatenate two `List a`, you'd immediately see what needs to happen here.
11:47:51 <kuribas`> nitrix: thanks for spoiling it, I wanted him to find it...
11:48:19 <nitrix> One of the two lists will need to be traversed and elements cons'ed to the other so that they can merge into a single data structure.
11:49:50 <kuribas`> kyclark: so yes, you need to concatenate them, not Cons them...
11:50:26 <vimalloc> So, pretty noobish guy here. I'm doing some input validation for my stuff, working in the Data.Either monad. First thing I convert data into my data structures, which insure the type of the data is correct. Then I call several helper methods to make sure the content of the data is correct. The first function returns ```Either String MyType```, easy enough. I'm curious about the helper functions though.
11:50:28 <vimalloc> Currently they also return ```Either String MyType``` so I can keep working in the Data.Either monad, but I'm not actually changing the data in there, so I don't really care about the Right value (if this makes sense)
11:50:28 <nitrix> You'll need that Cons value constructor to perform such concatenation.
11:51:07 <nitrix> Preserving the ordering is the tricky part.
11:51:13 <vimalloc> Is there a better way to do this? Or does returning and Either and just not binding the results to anything an alright thing to do
11:52:03 <nitrix> vimalloc: Do you a code example that would clarify the question?
11:52:19 <vimalloc> Sure, I'll throw an example together on gist. Sec
11:52:51 <kyclark> nitrix, I appreciate the help. Sitting here trying to wrap my brain around this.  Might figure it out after lunch break.
11:53:53 <nitrix> kyclark: You're on the right track with the function applications and the use of fmap for the recursion. The only piece left for you to figure out is how to concatenate two Lists.
11:54:04 <mbw> Hello everyone. I have a question about the FFI chapter in Real World Haskell. They describe a binding to the pcre library and among some other stuff describe how to define a wrapper to a function "pcre *pcre_compile(args...)". The return value is a function to an opaque struct, so the function declared as foreign import has return value "IO (Ptr PCRE)", with PCRE defined as "data PCRE". The deallocation is 
11:54:10 <mbw> done via wrapping in a ForeignPtr: "newForeignPtr finalizerFree pcre_ptr", with "pcre_ptr" being the "Ptr PCRE". As it turns out, this is not entirely accurate: https://www.reddit.com/r/haskell/comments/2v6n61/malloc_free_and_ffi_even_rwh_does_it_wrong/ . The pcre library defines a pcre_free function, which (according to the header file) simply calls free(). Still, you need to make use of pcre_free(), since 
11:54:16 <mbw> the pcre library could've been compiled against a different version of glibc. So now I want to foreign import pcre_free(). Looking in the header, this is (for customization purposes) actually a function pointer: "PCRE_EXP_DECL void  (*pcre_free)(void *);". The macro should expand to extern. Taking this into account, do I need to define a FunPtr to a FunPtr??
11:54:54 <nitrix> kyclark: Normally I think people would write it as part of the Applicative instance implementation, but if it helps, feel free to make sure helper function outside to split the problem into smaller parts. Or a `where` clause.
11:55:09 <nitrix> s/sure/use of a/
12:00:41 <vimalloc> nitrix: Here's an example of what I'm currently doing, with most of the actual boring validation code ripped out: https://gist.github.com/vimalloc/8a404bb6778a417ca708d020e19f4f1b
12:01:37 <vimalloc> Wondering specifically about returning an Either in checkIslandDuplicates and checkSpaceForBridges, as the island values passed into those functions will not be changed by them
12:02:52 <nitrix> kyclark: I recommend trying it on your own. If you're stuck, I made this to guide you: http://lpaste.net/356113
12:03:10 <kyclark> Thanks!  Still working on my “combine” function
12:03:12 <nitrix> kyclark: It's a naive implementation of concat which doesn't preserve the ordering of the first list, but it has the benefit of being fairly straight forward to understand.
12:04:38 * hackage machines-bytestring 0.1.0.0 - ByteString support for machines  https://hackage.haskell.org/package/machines-bytestring-0.1.0.0 (zclod)
12:07:46 <nitrix> kyclark: While we're at it, I could mention that we also have an abstraction for things that we want to "combine" in this sort of fashion. It'll come up later and you don't have to worry about them, but: Monoids.
12:08:30 <merijn> hmmm, so no one's yet done the work to see how to conveniently support both pipes and conduit?
12:08:34 <kyclark> Right!  I’m working through the “Haskell from First Principles” and I’m on the Applicative chapter (17) which is defined as a monoidal functor.  I almost understand what those mean.  :-)
12:12:16 <nitrix> kyclark: It takes a little while to connect all the dots, but once you do and you understand them, the abstractions really do get you quite far.
12:13:00 <jle`> nitrix: your naive concat doesn't form a monoid, tho :o
12:13:45 <jle`> the actual definition of concat is ... much simpler, i think?
12:14:35 <jle`> but yeah the concat you gave isn't associative
12:15:44 <nitrix> Yeah it's flawed, I really kept it to a minimum.
12:16:19 <cocreature> @tell bollu If you want to work on llvm-hs at Zurihac, Stephen Diehl is also a maintainer and will be there so you if you need faster responses than I can deliver via IRC, he’ll probably be happy to answer your questions
12:16:19 <lambdabot> Consider it noted.
12:16:44 <nitrix> I mentioned monoid to introduce him to the more general concept early on, but I doubt that it's relevant just yet.
12:17:15 <nitrix> As I remember, the pacing in bitemyapp's book was pretty good as to when to introduce Monoid so I won't push too much :P
12:31:31 <ThreeFx> Is there a meaningful way to combine the recursion-schemes package with error handling (e.g. `Either String a`)?
12:45:48 <jle`> you could write a cataM, perhaps
12:45:53 <jle`> etc.
12:46:21 <jle`> i think it's possible using 'cata', but i was always surprised that it wasn't included
12:47:13 <jle`> for what it's worth, the less-kmetted cousin data-fix offers cataM http://hackage.haskell.org/package/data-fix-0.0.4/docs/Data-Fix.html
12:49:36 <kyclark> dmwit: I have a solution that works: https://paste.ofcode.org/gZvzPNcfixcJPFXEvSaJaS
12:49:40 <ThreeFx> jle`: Thanks, I'll check that out
12:50:51 <vimalloc> So I'm trying to do some input validation (continuation on previous question). Originally I had it like this, https://gist.github.com/vimalloc/8a404bb6778a417ca708d020e19f4f1b, so that I could use Eithers everywhere and stay in the either monad (even though the data returned by the validation methods was never being changed.
12:51:20 <vimalloc> did something similiar where I changed the validation methods to return booleans instead of eithers, and got something like this: https://gist.github.com/vimalloc/5f19d251128e7431416f1d2c5cd75ace. Would that make more sense to use in this case?
12:51:49 <vimalloc> I *think* it would, but I kinda feel like I'm fumbling around in the dark here :P
12:53:00 <lyxia> you return game and do nothing with it
12:53:00 <byorgey> kyclark: nice.  You can simplify (<*>) a bit, in the third case it is unnecessary to pattern match on the second argument as (Cons x xs).  You can just write  (<*>) (Cons f fs) xs = ...
12:53:01 <jle`> you can write a guardy combinator
12:53:11 <kyclark> And here’s another version where I’m trying to understand how to implement the Monoid: https://paste.ofcode.org/JtB9KQahDP2TnGVMH4d7TU
12:53:20 <jle`> guardEither :: Bool -> e -> Either () e
12:53:33 <byorgey> kyclark: and actually if you do it that way, you don't need the (<*>) _ Nil case either
12:53:33 <jle`> guardEther True _ = return ()
12:53:41 <jle`> guardEither False e = Left e
12:53:42 <lyxia> vimalloc: you can also use 'when'
12:53:47 <jle`> er, 'Either e ()'
12:54:14 <vimalloc> lyxia: I tried using 'when' initially, but was getting compilier errors with it. let me see what they were..
12:54:17 <byorgey> kyclark: there is a lot of duplicated code between mappend and combine, you should be able to boil that down into a single function
12:54:21 <jle`> then you can just do `guardEither "Multiple islands exist" (hasDuplicateIslands game)
12:54:35 <pikajude> ooh, duplicate islands
12:54:45 <pikajude> sounds like a horror film
12:54:47 <vimalloc> jle`: Thanks! I'll look at that :)
12:54:47 <kyclark> Oh, in that 2nd link I should have removed combine. Sorry.
12:54:57 <byorgey> kyclark: ah, ok, no worries =)
12:56:12 <atodorov> hi folks, I'm trying to export a private function from my module so I can test it. In the module I have LANGUAGE CPP pragma, then #ifdef TEST ... export the function ... #endif and in my .cabal file I have cpp-options: -DTEST under the test suite section. However something isn't working for me. When I run cabal test it fails telling me Module ‘RPM.Parse’ does not export ‘parseLead’
12:56:27 <vimalloc> lyxia: Well, I got those compilier errors cause I was stupid :P
12:56:39 <atodorov> I've been looking at the hspec-example and it looks like I'm doing the same thing as they do
12:56:41 <vimalloc> Go figure right
13:02:21 <kyclark> dmwit: Closer? https://paste.ofcode.org/My8DaXfezrHL8XgmtXHPK5  I’m not sure what I’m doing exactly with the Monoid instance.  
13:02:43 <kyclark> Anyway, thanks greatly for the help
13:08:40 <byorgey> kyclark: the Monoid instance looks perfect, except that the first two cases are unnecessary.  It doesn't hurt anything to include them though.
13:09:10 <byorgey> kyclark: and the Applicative instance looks great
13:09:54 <kyclark> If I have implemented Monoid correctly, does it mean I ought to be able to List1 ++ List2?  I’m not sure where that goes.
13:10:42 <byorgey> kyclark: no, (++) specifically works on the built-in Haskell lists
13:10:50 <byorgey> @type (++)
13:10:52 <lambdabot> [a] -> [a] -> [a]
13:11:01 <kyclark> Also, I guess you’re Brent Yorgey?  Thanks for all your material on Haskell!
13:11:07 <byorgey> kyclark: but you should be able to List1 <> List2
13:11:18 <byorgey> kyclark: that's me, and you're welcome!
13:12:14 <kyclark> Oooo, (<>) works!  Fancy.
13:12:27 <byorgey> yeah, (<>) is just a synonym for mappend
13:12:45 <Zaghie> could someone explain how (fmap . fmap) typechecks?
13:12:49 <shapr> I'd send money to byorgey's patreon
13:13:08 <MitchellSalad> Zaghie: it helps to think of fmap as returning a function (which it does)
13:13:12 <ricksanchez> hello, is it a way to make esqueleto functions easier? Now I am adding: (BaseBackend backend ~ SqlBackend, PersistUniqueRead backend, PersistQueryRead backend, IsPersistBackend backend, MonadIO m) => ReaderT backend m
13:13:13 <MitchellSalad> rather than take two args
13:13:20 <ricksanchez> but it is too long
13:13:36 <Zaghie> MitchellSalad explain?
13:13:37 <byorgey> shapr: heh, thanks.  But then I'd feel bad if I didn't create stuff regularly.
13:13:44 <MitchellSalad> ricksanchez: you can define a constraint synonym
13:13:54 <Zaghie> MitchellSalad: what do you mean?
13:14:02 <MitchellSalad> Zaghie: fmap :: Functor f => (a -> b) -> (f a -> f b)
13:14:07 <MitchellSalad> note the redundant parens
13:14:23 <shapr> byorgey: you teach on #haskell regularly
13:14:45 <ricksanchez> how can I create it? 
13:15:04 <MitchellSalad> ricksanchez: type Blah backend = (BaseBackend backend ~ SqlBackend, ...)
13:15:09 <MitchellSalad> with -XConstraintKinds
13:15:25 <Zaghie> MitchellSalad: so how does (fmap.fmap) typecheck?
13:15:36 <ricksanchez> great :) thank you
13:15:54 <Zaghie> MitchellSalad: given that
13:15:54 <MitchellSalad> Zaghie: ah, well the 'f a -> f b' output from one 'fmap' is suitable as the input to another 'fmap', no?
13:16:47 <MitchellSalad> since 'fmap' will accept an 'a -> b' for any 'a' and 'b' you want
13:17:25 <Zaghie> yes
13:17:32 <juanpaucar> Does somebody know the GHC pragma to extend a library with my own methods?
13:17:40 <Zaghie> ahh
13:17:50 <Zaghie> got it, through partial application
13:17:54 <Zaghie> right ?
13:18:04 <jle`> more like polymorphism
13:18:33 <Zaghie> solid, thanks
13:18:44 <jle`> fmapping a function "adds" fs, so fmapping an (a -> b) gives you an (f a -> f b)
13:18:55 <jle`> fmapping an (f a -> f b) gives you a g (f a) -> g (f b)
13:19:08 <jle`> if you fmap it again, you get an h (g (f a)) -> h (g (f b))
13:19:11 <jle`> you can go on forever ;D
13:19:14 <jle`> :D
13:19:18 <MitchellSalad> similar "phenomenon" w/ foldl and foldr
13:19:23 <MitchellSalad> :t foldl.foldl.foldl
13:19:24 <lambdabot> (Foldable t, Foldable t1, Foldable t2) => (b -> a -> b) -> b -> t2 (t1 (t a)) -> b
13:19:27 <MitchellSalad> :t flip foldr . flip foldr
13:19:29 <jle`> also interesting with 'liftA2'
13:19:29 <lambdabot> (Foldable t, Foldable t1) => b -> (a1 -> ((a -> b -> b) -> t a -> b) -> (a -> b -> b) -> t a -> b) -> t1 a1 -> (a -> b -> b) -> t a -> b
13:19:34 <MitchellSalad> whoops that one's wrong :P
13:19:39 <jle`> liftA2 :: (a -> b -> c) -> (f a -> f b -> f c)
13:19:40 <nitrix> jle`: Is this implementation and proof valid? http://lpaste.net/356115
13:19:54 <jle`> (liftA2 . liftA2) :: (a -> b -> c) -> (g (f a) -> g (f b) -> g (f c))
13:20:05 <jle`> it also works with 'traverse' which is pretty cute too
13:20:18 <MitchellSalad> :t (flip . foldr) . (flip . foldr)
13:20:19 <lambdabot> (Foldable t, Foldable t1) => (a -> c -> c) -> t1 (t a) -> c -> c
13:20:21 <MitchellSalad> there we go
13:20:45 <MitchellSalad> :t foldMap . foldMap
13:20:46 <lambdabot> (Foldable t, Foldable t1, Monoid m) => (a -> m) -> t1 (t a) -> m
13:21:36 <MitchellSalad> this one I can only barely follow... (.).(.)
13:23:46 <Zemyla> Why are there no plans to produce a Data1 class?
13:26:15 <jle`> Data is dead
13:26:57 <jle`> long live Generic
13:29:26 <MitchellSalad> RIP Data
13:35:22 <Zaghie> thanks MitchellSalad and jle'
13:40:22 <MitchellSalad> sure
14:07:46 <shapr> byorgey: yay typeclassopedia update! hurrah!
14:08:06 <shapr> for those who didn't know: https://byorgey.wordpress.com/2017/06/07/the-typeclassopedia-is-now-up-to-date/
14:14:31 <EvanR> "Then someone used fmap fmap fmap and my brain exploded."
14:14:36 <EvanR> ^ classic
14:15:23 <c_wraith> > fmap fmap fmap (*) (+1) 3
14:15:26 <lambdabot>  error:
14:15:26 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M67456...
14:15:26 <lambdabot>        prevents the constraint ‘(Show (f0 (a0 -> a0)))’ from being solved.
14:15:53 <c_wraith> well, I certainly don't know what I'm doing 
14:16:02 <shapr> EvanR: what's that from?
14:16:08 <EvanR> typeclassopedia
14:16:44 <bno1> > fmap (fmap (fmap (*)) (+1)) 3
14:16:46 <lambdabot>  error:
14:16:46 <lambdabot>      • Ambiguous type variables ‘f1’, ‘f0’, ‘a0’ arising from a use of ‘show_...
14:16:46 <lambdabot>        prevents the constraint ‘(Show
14:18:45 <MarcelineVQ> :t fmap fmap fmap (+1) (*) 3
14:18:47 <lambdabot> Num a => a -> a
14:20:31 <c_wraith> Oh, hah. 
14:20:47 <c_wraith> > fmap fmap fmap (*) (+1) 3 7
14:20:49 <lambdabot>  error:
14:20:49 <lambdabot>      • Could not deduce (Num t0)
14:20:49 <lambdabot>        from the context: (Num (t -> a), Num t, Num a)
14:21:13 <c_wraith> and, right.. 
14:21:28 <c_wraith> > fmap fmap fmap (+1) (*) 3 7
14:21:30 <lambdabot>  22
14:21:49 <c_wraith> ok. someone take away my fmap license. 
14:21:58 <MarcelineVQ> what did you want to to be? :>
14:22:08 <Tuplanolla> @pl (\ f -> f f f) fmap
14:22:09 <lambdabot> fmap fmap fmap
14:22:13 <c_wraith> that last one is what I really meant. 
14:22:13 <Tuplanolla> Here's one to ponder.
14:22:17 <MarcelineVQ> alrighty
14:23:05 <c_wraith> Tuplanolla, pl doesn't do any type checking. 
14:23:47 <c_wraith> Tuplanolla, so.. the fact that the input doesn't type check isn't important. :) 
14:25:44 <Tuplanolla> @let {magic :: (forall a. a -> a -> a) -> (forall a. a -> a -> a); magic = \ f -> f f f}
14:25:46 <lambdabot>  Defined.
14:25:51 <maerwald> c_wraith: but if the input typechecks, does the output also typecheck?
14:25:57 <Tuplanolla> > magic const 42 13
14:25:59 <lambdabot>  42
14:26:22 <c_wraith> Tuplanolla, sure, it works when you give it a non-inferrible type... :P
14:26:33 <Tuplanolla> That's the joke.
14:27:11 <Tuplanolla> Coming from Scheme this was actually one of the things that confused me the most.
14:27:35 <c_wraith> maerwald, there are some bugs. I think I've seen a type error. I know I've seen some semantically dodgy transformations on arithmetic expressions 
14:28:13 <c_wraith> @pl \x -> x + x
14:28:13 <lambdabot> join (+)
14:28:40 <c_wraith> hey, that's better than the (*2) it used to claim on occasion 
14:35:07 * hackage cloudi 1.7.1 - Haskell CloudI API  https://hackage.haskell.org/package/cloudi-1.7.1 (okeuday)
14:35:37 * hackage proto-lens 0.2.1.0 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.2.1.0 (JudahJacobson)
14:35:38 <manbitsdog> > map (\x -> map (+1) x) [[1], [6]]
14:35:40 <lambdabot>  [[2],[7]]
14:36:02 <manbitsdog> Is there a better way to do nested mapping
14:36:25 <lyxia> > (map . map) (+1) [[1], [6]]
14:36:25 <glguy> > map (map (1+)) [[1],[6]]
14:36:27 <lambdabot>  [[2],[7]]
14:36:28 <lambdabot>  [[2],[7]]
14:36:47 <Tuplanolla> The `fmap fmap fmap` we just talked about works too, manbitsdog.
14:36:54 <manbitsdog> Nice
14:37:07 <MarcelineVQ> Tuplanolla: :(
14:38:08 * hackage proto-lens-descriptors 0.2.1.0, proto-lens-protoc 0.2.1.0, proto-lens-combinators 0.1.0.7 (JudahJacobson): https://qbin.io/fpz7bc7z
14:39:08 * hackage proto-lens-protobuf-types 0.2.1.0 - Basic protocol buffer message types.  https://hackage.haskell.org/package/proto-lens-protobuf-types-0.2.1.0 (JudahJacobson)
14:51:23 <orzo> data families question: Can different instances provide the same accessor field that can be used as if it was just an ordinary parameterized type?
14:52:06 <lyxia> I don't think so.
14:53:08 <glguy> You'd have to make a typeclass for that
14:53:58 <orzo> oh well
14:54:04 <orzo> thanks
15:00:31 <sun[BEAM]> Sup. Anyone interested in friendly talking, flirting and Love? Join our Server: irc.ladysclub-irc.net Port 6667 / SSL 6697 Main Room #Outlaws :)
15:00:58 --- mode: ChanServ set +o glguy
15:00:58 --- mode: glguy set +b *!*@ip1f11f87f.dynamic.kabel-deutschland.de
15:00:58 --- kick: sun[BEAM] was kicked by glguy (spam)
15:01:02 --- mode: ChanServ set +q *!*@ip1f11f87f.dynamic.kabel-deutschland.de
15:01:12 --- mode: ChanServ set -q *!*@ip1f11f87f.dynamic.kabel-deutschland.de
15:01:38 * hackage sdnv 0.1.1 - Self-delimiting numeric values encoding library  https://hackage.haskell.org/package/sdnv-0.1.1 (sickmind)
15:05:21 <a3gis> Hello! I could use some help on a type-checking error. The project I am compiling was written for ghc 7.8. I am trying to compile it with ghc 8 but getting an type error. I'm wondering if there are any breaking changes that would be the cause. I pasted the error and the code of "Types.hs" on gist:https://gist.github.com/hmaurer/a4cffee8aaffa1b892579a3933f3f1e6
15:05:58 <a3gis> If you would like the full source-code I can also give you a link
15:07:15 <mauke> that's weird
15:07:20 <glguy> a3gis: use one forall, not 3
15:07:26 <glguy> forall w a b.
15:07:53 <a3gis> glguy: did ghc > 7.8 change something about that? I didn't write this code but according to the readme it compiled on ghc 7.8
15:08:07 <orzo> if i have the option either way of using newtypes or FlexibleInstances, and I know I'll never create overlapping instances, is there a good reason to prefer newtype?
15:08:08 <glguy> a3gis: If it compiled in 7.8, then something changed
15:08:18 <a3gis> also, why would 3 forall make a difference? 
15:08:23 <a3gis> thanks for the tip though, I'll try it out
15:08:51 <glguy> Because scopedtypevariables relies on a particular syntax to establish which type variables are to be scoped
15:09:06 <glguy> and 3 foralls and 1 forall are different syntaxes
15:09:14 <orzo> Basically, i have a parameterized type where one of the parameters selects the instance.  Newtype or FlexibleInstances?
15:09:30 <a3gis> glguy: oh I see; thank you :)
15:10:21 <glguy> a3gis: Alternatively you can delete the type signature on line 316
15:10:27 --- mode: glguy set -o glguy
15:11:49 <orzo> I normally try to avoid type class extensions, but I don't know if there's a good reason for FlexibleInstances
15:12:47 <a3gis> glguy: thanks, that works; that's progress! Now I am getting the same error I had on ghc 7.10, namely: https://gist.github.com/hmaurer/f27c6a1c3cfb998b9b454ef18e6ac118
15:12:52 <a3gis> glguy: could you take a look please?
15:15:54 <mbw> How can I foreign import a function pointer? That is, not do a static address import like "foreign import ccall "stdlib.h &free"", but import an actual function pointer of type void (*)(void *), to be used as a finalizer?
15:16:10 <lyxia> orzo: FlexibleInstances is fine
15:17:00 <Zaghie> what’s the best way to learn Haskell? I’m currently 700 pages into the Haskell Book but it feels isolated and non contextual from an application development perspective
15:21:59 <EvanR> wrote a program
15:22:05 <EvanR> er, zaghie write a program
15:22:28 <zaghie> yes, but what type? Any type?
15:22:34 <zaghie> which did you write?
15:23:01 <EvanR> a program to read some crappy file format and spit out a nice file format
15:23:50 <Tuplanolla> A command line utility to capitalize titles according to the Chicago Manual of Style (and other) would be useful, zaghie.
15:24:30 <zaghie> Tuplanolla: none currently exists in Haskell?
15:24:40 <Tuplanolla> None currently exist anywhere.
15:25:00 <Tuplanolla> I could use one to format some bibliographies right now.
15:25:05 <zaghie> Ha, sounds like a tough one. You tried to make one? :D
15:25:37 <Tuplanolla> I've just always done it manually, which is tedious.
15:26:26 <ClaudiusMaximus> mbw: i guess you need to import the address of the function pointer variable and peek it?
15:26:42 <Tuplanolla> Haskell with Megaparsec could be good choice for such a tool.
15:27:12 <zaghie> Tuplanolla: I’ll finish the book then look into it
15:27:46 <ClaudiusMaximus> mbw: something like this perhaps..  foreign import ccall "foo.h &foo" :: Ptr (FunPtr (Ptr a -> IO ()))
15:27:56 <mbw> ClaudiusMaximus: So I do an address import like "foreign import ccall unsafe "bla.h &fun_ptr"" and get something like Ptr... ok you beat me to it.
15:28:44 <mbw> ClaudiusMaximus: Currently the only thing I got to work was to make a wrapped_free function that calls the function pointer, so this solution would probably be cleaner
15:29:10 <ClaudiusMaximus> mbw: and then you need to peek it (using foreign.Storable) - so you need to decide when to peek it (at allocation time, or at free time)
15:32:11 <mbw> ClaudiusMaximus: I got this to compile, and it seems to run. But now according to valgrind there might be a memory leak. Hmm...
15:35:11 <mbw> Ok, I get inconsistent results with valgrind and it's probably not a memory leak. Sometimes there is some possibly lost memory, sometimes not, and it might entirely depend on when the finalizer is actually run.
15:36:39 <Ferdinandvw> Hey guys, I have a question about TH. I'm trying to write a splice that uses type information to construct a new type. But I can't figure out how to send the type information to the function that returns a Q Type.
15:36:44 <Ferdinandvw> test :: HList xs -> $(newType ?)
15:36:49 <Ferdinandvw> newType :: ? -> Q Type
15:37:04 <Ferdinandvw> I have no idea how I can pass xs to newType
15:37:27 <mbw> ClaudiusMaximus: Do you happen to know what this "foo.h &boo" actually does? Does it create a typed pointer only, or is it more involved?
15:39:34 <Ferdinandvw> Ultimately, I'd like 'newType' to receive a string as an argument. So I had tried to use typeRep within the splice, but I'm not sure whether that's possible. I couldn't get it to work at least.
15:42:00 <orzo> Ferdinandvw: is that the hlist package HList ?  I don't recommend that.  I was burned using it as the package change over time and tries to update to whatever the latest type extensions are. It's not been a stable interface at all
15:42:03 <ClaudiusMaximus> mbw: i guess it adds linker stuff so that at program startup (or maybe before) it is resolved to the correct address
15:42:31 <orzo> Ferdinandvw: you're probably better off implementing your own HList than using the package
15:42:35 <Ferdinandvw> I made my own HList
15:42:41 <orzo> oh, nm then
15:43:26 <Ferdinandvw> But I agree, for simple stuff it's better to just write it yourself than depend on another library
15:43:41 <orzo> Ferdinandvw: can't really answer your q becaues i dont know what information ? is supposed to be
15:44:03 <Ferdinandvw> well that's the thing, I'm not entirely sure myself...
15:44:03 <orzo> maybe you want to use [t| ... |] which is type Q Type
15:44:38 <Ferdinandvw> hmm, but where would I use that?
15:44:40 <mbw> ClaudiusMaximus: That makes sense. Anyway, this has been giving me trouble for a while now, and I thought the address import would require the result to be of type FunPtr. So you were of great help. Thanks!
15:44:57 <orzo> you $(newtype [t| ... |])
15:45:06 <orzo> newtype :: Q Type -> Q Type
15:45:47 <orzo> or you could make it Type -> Q Type and fmap over the [t| ... |]
15:45:48 <Ferdinandvw> how would I be able to use 'xs' within the [t|..|]?
15:46:08 <thang1> It's a shame you can't just inline a package... Although I think you can if you just download it with like stack or something?
15:47:18 <orzo> you can anti-quote within the [t|...|] using $(...) syntax
15:47:20 <kadoban> What do you mean inline a package?
15:47:30 <sm> thang1: sure, stack unpack or git clone the source and you can include those modules directly
15:47:42 <sm> import those modules
15:48:23 <thang1> right, I should've figured it would be that simple :p
15:48:31 <sm> but now you're maintaining your own fork
15:48:37 <thang1> kadoban: what sm said
15:49:00 <kadoban> Ah, yeah. You can also point at git commits with stack and etc.
15:49:03 <thang1> sm: but if you want to use something like HList and you don't care how it changes in the future and you just want how it works /now/... then that'd be a great usecase, right?
15:49:12 <sm> sure, maybe
15:49:56 <rpasta42> Hello guys, I just finished the alpha version of my first real Haskell program and was wondering if someone can take a quick glance at my code and point out any major issues
15:50:08 * hackage loup 0.0.1 - Amazon Simple Workflow Service Wrapper for Work Pools.  https://hackage.haskell.org/package/loup-0.0.1 (markfine)
15:50:14 <sm> or if you need some customisations not suitable for general use, or you can't wait for them to land upstream and become commonly available
15:50:32 <ski> Ferdinandvw : i thought `xs' was a type variable, in which case you should probably be able to use it directly inside the `[t| ... |]' quasiquotation, already ..
15:51:12 <rpasta42> I'm writing a Chess engine, and have basic support for 2-player games: https://github.com/rpasta42/ChessKell/blob/master/main.hs
15:51:30 <ski> (to my knowledge, there's no Cross-Stage Persistence with TH)
15:52:18 <Ferdinandvw> orzo: I got it to work, thanks a lot!
15:52:36 <rpasta42> In particular, I'm wondering what's a good way of doing nested if-else statements. I'm currently using pattern matching, but it seems ugly:https://github.com/rpasta42/ChessKell/blob/master/main.hs#L99
15:52:38 * hackage liveplot 0.0.1 - Liveplotting  https://hackage.haskell.org/package/liveplot-0.0.1 (srk)
15:52:53 <ski> otoh .. it's not clear to me that you'll be able to get any useful information into `newType', in this way
15:53:10 <orzo> I have a deriving (Show) clause attached to a type that has a field of type (Foo a) where a is a parameter.  For some reason it's demanding Show (Foo a) whereas if the type were just a, then it would deriving a constraint Show a for the Show instance
15:53:27 <ski> (if you don't need to inspect `xs' then there should be no problem)
15:53:30 <orzo> why not derive a Show (Foo a) constraint?
15:53:30 <thang1> rpasta42: why would you even want nested if-else statements?
15:53:56 <Ferdinandvw> ski: You were right that I could already use xs
15:53:57 <orzo> hmm. FlexibleConstraints?
15:54:22 <ski> could be. try it
15:54:28 <zachk> orzo: is it difficult to code a Show (Foo a) instance?
15:54:32 <Ferdinandvw> Although, I do have to inspect xs
15:54:44 <orzo> Foo is a type function
15:55:00 <Ferdinandvw> Can't I just use a type class inside 'newType'?
15:55:03 <zachk> not a regular typeclass?
15:55:10 <thang1> orzo: can you just add a "showable" constraint to a?
15:55:24 <rpasta42> thang1: I had a big nested if-else block in this code: https://github.com/rpasta42/ChessKell/blob/master/main.hs#L99. I mostly replaced it with 1 giant pattern match, but it seems ugly
15:55:35 <zachk> maybe Generics and GenericDeriving or something
15:55:37 <thang1> Then deriving (Show) for (Foo (a)) will just go down the ladder, confident it knows how to show 'a'
15:56:03 <rpasta42> thang1: I feel like there should be a more monadic way of doing what I'm trying to do. I already use Either monad, but I'm not sure if there's a better type for the job
15:56:10 <ski> Ferdinandvw : what if `xs' isn't determined statically in any single place in the program (perhaps even only determined dynamically, when the program is run). how could `newType' possibly get a hold of it at compile-time, for analysis, then ?
15:56:30 <rpasta42> thang1: how do you guys usually handle errors in your code? Just use Either or something more fancy?
15:56:42 * ski isn't sure what Ferdinandvw means by using a type class inside `newType'
15:56:48 <glguy> You you can use standalone deriving to specify enough of the constraints to be able to make that derived Show instance
15:56:50 <glguy> orzo: 
15:56:55 <Ferdinandvw> Hmm, I'll have to think about this for a bit.. Thanks for the help
15:57:01 <glguy> and you will need to turn on UndecidableInstances for it
15:57:14 <orzo> glguy: thanks, i'll give that a go
15:57:33 <MitchellSalad> rpasta42: The Either monad is a good place to start
15:57:34 <thang1> Really depends on the error. Everyone has their own way of handling errors. Some people never ever want to throw errors in code, some people throw errors too often, some people pass them down and blow things up in the end, some blow up immediately,  ¯\_(ツ)_/¯
15:57:44 <glguy> e.g. deriving instance Show (Foo a) => Show (Whatever a)
15:58:58 <thang1> rpasta42: it looks like you just have every single bit of error checking embedded inside a single case function inside of your giant "step" function
15:59:39 <rpasta42> thang1: is that considered a bad practice?
16:00:18 <thang1> Eh, it's necessary in some places, and it's all about taste. I personally hate any function more than about 15 lines long, but that's just me
16:00:37 <rpasta42> ok
16:01:15 <rpasta42> what do you use for packaging stuff? I tried haskell few years ago and everyone seemed to use cabal, but now everyone switching to stack?
16:01:30 <glguy> No, now it's just a mix. You still package your stuff with Cabal
16:01:33 <thang1> Right now I see about 10 lines in a single let statement, then an "in case" with another giant let statement inside that in-case and a final in case for the second level let statement
16:01:34 <rpasta42> for me cabal seems to break super often when I try to install basic packages
16:01:43 <glguy> but the question is how you go about building what you've packaged with Cabal
16:02:15 <rpasta42> I tried setting up stack, but also ran into a bunch of problems on Ubuntu
16:02:49 <thang1> Really? Did you previously install cabal and then try to use stack? I found stack completely painless on arch linux
16:02:53 <ski> rpasta42 : why all the strings in `StepFailure' ?
16:02:58 <ski> @quote stark
16:02:58 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16:03:13 <rpasta42> thang1: yes, had cabal and then stack
16:03:42 <thang1> That's probably part of the reason. If you have a few free hours someday you can try nuking stack and then nuke cabal and purge everything haskell from your system. Then install stack and it should be painless :)
16:04:15 <glguy> stack isolates itself, having other Haskell content on your computer shouldn't be too relevant
16:04:57 <rpasta42> ski: for for more descriptive errors. If a function fails with InvalidMove, we want to be able to resume playing, but if we have checkmate, then we want to finish game. But I also pass more descriptive errors like "move failure because it will put queen under check" or "that chess piece cannot move to that location"
16:06:15 <ski> rpasta42 : could you express those error conditions with algebraic data types (rather than just a string) ?
16:06:16 <Tuplanolla> Then you have the wrong version of `libc`. Then you get `libgmp` linking errors. Then you run out of `/tmp` while installing. Then you forget to enable local documentation and have to start over.
16:06:21 <thang1> What they're probably getting at is that your error types should be strong enough to be able to say those things without needing String. Something like "isInvalidMove Reason" would likely be an improvement.
16:06:27 <rpasta42> thang1: I do all my development on a server, and was thinking of going back to Arch since I'm jobless again and got more free time. Might as well remove ubuntu server :p
16:06:44 <thang1> rpasta42: that's the right attitude :p
16:06:49 <rpasta42> ski: good idea, will try that :)
16:06:57 <thang1> If you really want to suck up some free time, figure out how to use Nix on a server
16:07:55 <ski> rpasta42 : generally, it's better to put informative messages to the user in the user interface, as the last step. that way, if it turns out you need to, or it's convenient, you can pattern-match on the errors and interpret them programmatically much easier
16:07:59 <rpasta42> thang1: haha, I played around with nix few years ago when I was in high-school
16:08:32 <ski> rpasta42 : i also think you should be able to replace that `case' with `do' on the `Either StepFailure' monad
16:09:21 <rpasta42> I had a do eariler, but replaced it with a case for some dumb reason
16:09:30 <ski> perhaps using a `mapLeft' operator, to wrap error messages of different types up into a common type (`StepFailure')
16:09:40 <rpasta42> I miss being a kid. Used to skip school and code fun stuff...now I have to code fun stuff when boss isn't looking or when I'm in-between finding jobs
16:09:54 <rpasta42> ok, I'll have to look up mapLeft
16:10:47 <ski> basically, you need something of type `(e0 -> e1) -> (Either e0 a -> Either e1 a)'. should be easy to define, if it's not available easily
16:11:06 <Tuplanolla> :t lmap :: (a -> b) -> Either a c -> Either b c -> -- Isn't it this, ski?
16:11:08 <lambdabot> error:
16:11:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:11:17 <Tuplanolla> :t lmap :: (a -> b) -> Either a c -> Either b c
16:11:18 <lambdabot> error:
16:11:18 <lambdabot>     • Couldn't match type ‘b1’ with ‘a1’
16:11:18 <lambdabot>       ‘b1’ is a rigid type variable bound by
16:11:46 <rpasta42> haha, I just found Data.Either.Combinators. I basically re-wrote half the functions myself because I didn't know it already existed
16:12:18 <Tuplanolla> Oh, no. That one's contravariant.
16:13:24 <uniclown> what's the motivation for using lazy versus strict Text and ByteString implementation? Also why is the strict version the 'default' where you have to add .Lazy to use the lazy version?
16:13:38 <Tuplanolla> :t Bifunctor.first :: (a -> b) -> Either a c -> Either b c -- It's actually this.
16:13:39 <lambdabot> (a -> b) -> Either a c -> Either b c
16:14:34 <ski> Tuplanolla : for some reason, i always forget about those combinators
16:15:19 <Tuplanolla> Better than mixing them up and becoming frustrated, ski.
16:15:33 <ski> rpasta42 : there's also `mapExceptT :: (m (Either e0 a) -> n (Either e1 b)) -> (ExceptT e0 m a -> ExceptT e1 n b)' in `Control.Monad.Except' (useful if you find yourself wanting to mix in exception handling with some other monadic effect. this is a monad transformer)
16:16:17 <thang1> rpasta42: this  might be somewhat useful for your errors (It's more focused on compilers, but eh) https://github.com/jaspervdj/talks/blob/master/2017-skillsmatter-errors/slides.md
16:16:19 <rpasta42> thank you for awesome suggestions! I'm going to start incorporating them, so I'll be back in few hours/days 
16:16:41 <thang1> Definitely look at everyone else's stuff first, that's just some food for thought
16:20:50 <thang1> rpasta42: Also. At a very high level, I prefer to separate "how to do" from "what to do". So, if I have a step function that changes the game state, I'd first attempt to create it as a fairly high level function. Something like step = <ensure valid state> <do move> <return modified board>. I don't see a ton of need to completely inline that as a massive nested let when you have where clauses to do that for
16:20:52 <thang1> you.
16:22:01 <rpasta42> makes sense
16:25:01 <thang1> Also, white and black are the same exact thing. They don't have any special differences other than the fact that differnt players play them. So it feels weird to say that a function, say, isUnderCheck, is basically saying "do this to the white piece if they're white" "do the same thing if they're black, but do it to the black piece". It feels like a ton of code duplication, to me.
16:26:34 <iqubic> Let's say I want to create Monad Transformer that combines state and maybe. s -> Maybe (a, s)
16:26:45 <iqubic> what would the data type of that look like?
16:27:07 <iqubic> StateT s Maybe a?
16:27:13 <iqubic> for some s and some a?
16:27:20 <Tuplanolla> @unmtl StateT s Maybe a
16:27:21 <lambdabot> s -> Maybe (a, s)
16:27:28 <iqubic> Cool
16:27:32 <iqubic> That's what I wanted
16:27:36 <thang1> what's unmtl?
16:28:02 <iqubic> @unmtl StateT s (Either String) a
16:28:02 <lambdabot> s -> Either String (a, s)
16:28:04 <Tuplanolla> @hackage mtl
16:28:04 <lambdabot> http://hackage.haskell.org/package/mtl
16:28:17 <Tuplanolla> It's a type expander for this package, thang1.
16:29:01 <thang1> ah, got it. Thanks :) I was curious why you needed that instead of :t StateT s Maybe a
16:29:05 <thang1> :t StateT s Maybe a
16:29:07 <lambdabot> error:
16:29:07 <lambdabot>     • Couldn't match expected type ‘t0 -> Expr -> t’
16:29:07 <lambdabot>                   with actual type ‘StateT s0 m0 a0’
16:29:16 <iqubic> @unmtl ExceptT String (StateT s) a
16:29:16 <lambdabot> ExceptT String (StateT s) a
16:29:32 <iqubic> Can unmtl not deal with that?
16:29:35 <iqubic> @unmtl ExceptT String (State s) a
16:29:35 <lambdabot> ExceptT String (State s) a
16:29:59 <Tuplanolla> That transformer is from another package.
16:30:15 <iqubic> What is, ExceptT?
16:30:24 <Tuplanolla> Isn't it?
16:30:56 <glguy> iqubic: What was your question about it?
16:31:00 <thang1> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html seems to be in here
16:31:16 <thang1> glguy: @unmtl doesn't expand out ExceptT String (StateT s) a
16:31:30 <glguy> Yeah, unmtl is old and waiting for a kind soul to submit a PR
16:31:36 <iqubic> glguy: I want to know what the difference is between putting StateT on the outside vs putting ExceptT on the outside
16:31:49 <iqubic> Difference in expanded type I mean
16:31:53 <n_blownapart> hi please correct this. I attempted it with otherwise . how do I place otherwise if at all? thanks  https://paste.ee/p/TMn7q
16:32:04 <n_blownapart> its the ackermann function
16:32:33 <n_blownapart> sorry fixing indent
16:32:37 <glguy> n_blownapart: You need ... | otherwise = ack (x-1) (ack x (y-1))
16:32:37 <thang1> Why are you sticking it in the main function anyway?
16:32:46 <Tuplanolla> So it is, iqubic and thang1. You can manually expand `ExceptT e m a` to `m (Either e a)` for now.
16:32:48 <iqubic> how are StateT s (Either String) a and ExceptT String (State s) a different
16:32:58 <glguy> n_blownapart: When you have questions about broken code, please include the error message in the paste
16:33:18 <glguy> n_blownapart: You also need to line stuff up, like "ack" on lines 2 and 4
16:37:03 <n_blownapart> I know glguy thanks I'm dealing with bad wifi and lpaste site is giving 404 errors thanks a lot!
16:37:31 <glguy> n_blownapart: It's OK to use basically any other pastebin but pastebin.com if lpaste.net is failing
16:38:03 <n_blownapart> glguy, I was missing the = in otherwise = ack  ... will do on error messages
16:38:58 <n_blownapart> yeah had this https://nopaste.me/view/a5b3f793 .. If I may revisit this I have some questions glguy 
16:40:16 <n_blownapart> BTW I'm learning vim as well and having tough time. 
16:41:35 <iqubic> n_blownapart: in that latest paste you are missing an otherwise = ...
16:41:58 <n_blownapart> iqubic, thanks gl*guy pointed it out. really appreciate the help from everyone
16:46:35 <thang1> n_blownapart: learning vim is very separate from learning haskell :p unless you have a great reason to learn it, you probably shouldn't bother much
16:46:59 <thang1> (your two ack lines are still not lined up)
16:48:05 <n_blownapart> thang1, thanks hold on
16:52:42 <n_blownapart> https://nopaste.me/view/80c3f276 with correction
16:53:10 * jle` . o O ( type Const w = Compose ((,) w) Proxy )
16:56:47 <jle`> @unmtl ErrorT e (State s) a
16:56:47 <lambdabot> s -> (Either e a, s)
16:56:55 <jle`> @unmtl StateT s (Either e) a
16:56:55 <lambdabot> s -> Either e (a, s)
16:56:59 <jle`> ^ iqubic 
16:57:36 <jle`> with ExceptT e (State s) a, you get the "last good state" before the short-circuiting error happens
16:58:00 <jle`> with StateT s (Either e) a, you don't get any updated state at all if you have a short-circuiting error
16:58:11 <iqubic> Oh.
16:58:13 <iqubic> I see
16:58:27 <n_blownapart> hi this is another version of ackermann with error messages. https://nopaste.me/view/68f3fd0b
16:58:51 <iqubic> How does ErrorT give you the last good state??
16:59:02 <jle`> it's in the return type
16:59:06 <jle`> of runStateT
16:59:18 <jle`> er sorry, runState
17:00:26 <iqubic> So If there was a failiure I'd get (Left e, s)?
17:00:45 <iqubic> And with no failure I'd get (Right a, s)?
17:00:47 <jle`> runState :: State s (Either e a) -> s -> (Either e a, s)
17:00:50 <jle`> yes
17:00:57 <jle`> well, basically
17:01:08 <jle`> you're mixing type variables and values there, but yeah
17:01:15 <n_blownapart> I guess line 4 is wrong / unnecessary could you all take a look? https://nopaste.me/view/68f3fd0b
17:02:13 <iqubic> If you do it that way, otherwise should be replaced with "ack x y"
17:02:51 <n_blownapart> checking that thank you iqubic 
17:02:59 <MitchellSalad> also line 4 is unnecessary
17:03:07 <n_blownapart> ok one sec
17:03:16 <iqubic> Yeah, ack x 1 is not needed
17:03:43 <jle`> > flip runState 1 . runExceptT . sequence_ $ [modify (+1), modify (+3), throwError "boo!", modify (*10)]
17:03:45 <lambdabot>  (Left "boo!",5)
17:03:55 <jle`> > runExcept . flip runStateT 1 . sequence_ $ [modify (+1), modify (+3), throwError "boo!", modify (*10)]
17:03:58 <lambdabot>  Left "boo!"
17:04:34 <n_blownapart> iqubic, repeat that please, did you make a typo?
17:04:36 <jle`> for the first one, ExceptT e (State s) a, it does the +1 and +3 modifications to the original state
17:04:47 <iqubic> n_blownapart: No I did not.
17:04:58 <jle`> and you see (Left "boo!", 5), since 5 is the state before the short-circuiting error was thrown (1 + 1 + 3)
17:05:03 <iqubic> "otherwise" needs to be replaced with "ack x y"
17:05:08 <jle`> in the second one, all intermediate state is lost
17:05:20 <jle`> alas
17:05:21 <slack1256> a mutator thread is one that rewrites thunk to values in the heap right?
17:05:34 <iqubic> jle`: What is the type of those two computations?
17:05:41 <n_blownapart> that I'm working on. your other comment says ack x 1 is not needed?
17:05:52 <ski> iqubic : in case the state is changed incrementally, so that it may be left in a globally inconsistent state inbetween, it may make sense to make a combinator (of type `forall a. M a -> M a', `M' being your monad) which restores the state in case of exception. a kind of atomicity/transaction operator
17:06:11 <jle`> > flip runState 1 . runExceptT . sequence_ $ _
17:06:12 <iqubic> Yes. You can delete the line that starts with "ack x 1"
17:06:13 <lambdabot>  error:
17:06:13 <lambdabot>      • Found hole: _ :: [ExceptT e (StateT s Identity) a0]
17:06:13 <lambdabot>        Where: ‘e’ is a rigid type variable bound by
17:06:20 <jle`> > runExcept . flip runStateT 1 . sequence_ $ _
17:06:20 <iqubic> Cool
17:06:22 <lambdabot>  error:
17:06:22 <lambdabot>      • Found hole: _ :: [StateT s (ExceptT e Identity) a0]
17:06:22 <lambdabot>        Where: ‘s’ is a rigid type variable bound by
17:06:38 <unknownln> replace `ack (x-1) (ack x (y-1))` with `otherwise = ack (x-1) (ack x (y-1))`
17:06:46 <unknownln> I think I'm a bit late though
17:08:12 <n_blownapart> iqubic, ok that works and looks great. thanks kindly also MitchellSalad 
17:08:28 <iqubic> Cool. Always willing to help
17:08:39 <n_blownapart> THANKS
17:09:28 <slack1256> is the "nursery" different from the gen0 on the heap?
17:10:01 <iqubic> flip runState 1 . runExceptT . sequence_ $ [modify (+1), modify (+3), modify (*10)]
17:10:11 <iqubic> > flip runState 1 . runExceptT . sequence_ $ [modify (+1), modify (+3), modify (*10)]
17:10:14 <lambdabot>  (Right (),50)
17:10:33 <iqubic> runExcept . flip runStateT 1 . sequence_ $ [modify (+1), modify (+3), modify (*10)]
17:10:45 <iqubic> > runExcept . flip runStateT 1 . sequence_ $ [modify (+1), modify (+3), modify (*10)]
17:10:47 <lambdabot>  Right ((),50)
17:10:57 <iqubic> Huh? how does that work??
17:11:39 <ski> no exception
17:12:13 <ski> @type \act -> do s <- get; catchError act (\e -> do put s; throwError e)
17:12:14 <lambdabot> (MonadError e m, MonadState s m) => m b -> m b
17:13:36 <jle`> :t (runExcept . flip runStateT 1 . sequence_)
17:13:38 <lambdabot> (Foldable t, Num s) => t (StateT s (ExceptT e Identity) a) -> Either e ((), s)
17:14:31 <jle`> iqubic: runStateT :: StateT s (Either e) a -> s -> Either (e, a)
17:14:42 <jle`> er sorry, s -> Either e (a, s)
17:14:47 <iqubic> Yeah, I figured it out.
17:22:02 <iqubic> What does it even mean if a function is of type Int -> State Int [Int]?
17:23:02 <Rotaerk> iqubic, it's a stateful action (where the state is an integer) that results in a list of ints, given an int
17:23:55 <iqubic> How would you write a stateful computation?
17:24:19 <iqubic> Not the one I just came up with, but pick any stateful computation.
17:24:46 <Rotaerk> well, State s a is just a wrapper around an:  s -> (a, s)
17:24:54 <iqubic> Sure. I get that
17:25:19 <jle`> so, any s -> (a, s) can be interpreted as a stateful computation that produces a result 'a'
17:25:23 <jle`> modifying state 's'
17:25:24 <Rotaerk> so Int -> State Int [Int] is like:  Int -> Int -> ([Int], Int)
17:25:32 <Eduard_Munteanu> :t repeat <$> get :: State Int [Int]
17:25:33 <lambdabot> State Int [Int]
17:26:03 <iqubic> Eduard_Munteanu: How does that work?
17:26:27 <jle`> just match up the types
17:26:28 <Eduard_Munteanu> get :: State s s
17:26:29 <jle`> :t repeat
17:26:30 <lambdabot> a -> [a]
17:27:14 <Eduard_Munteanu> > evalState (repeat <$> get) 1
17:27:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:27:22 <Rotaerk> iqubic, get is basically just:  get s = (s, s)
17:27:34 <jle`> by the way, an 's -> s' can also be interpreted as a sateteful computation that just modifies a state
17:27:42 <Rotaerk> as in leave the state untouched and return the state as the result
17:27:47 <jle`> 'stateful computation' is really just up to your interpretation
17:28:11 <iqubic> Oh. I see.
17:28:38 <iqubic> Would it make sense to have a function of type State s a -> type?
17:28:46 <iqubic> for some s a and type?
17:28:49 <jle`> so you could interpret "(:) 1" as a stateful computation
17:29:08 <iqubic> I could??
17:29:09 <jle`> that takes a list of ints and returns a new list of ints
17:29:16 <Eduard_Munteanu> iqubic, you'd have to restrict 'type' somehow
17:29:25 <jle`> > let push1 = (:) 1 in push1 [3,4,5]
17:29:27 <lambdabot>  [1,3,4,5]
17:29:34 <jle`> push1 took [3,4,5] and returned [1,3,4,5]
17:29:50 <jle`> it "modified" something you could interpret as a state
17:30:06 <iqubic> Right.
17:30:07 <jle`> iqubic: yes, it would make sense, depending on what s, a, and type are
17:30:19 <jle`> > let f :: State s a -> Int; f _ = 10
17:30:20 <lambdabot>  <no location info>: error:
17:30:21 <lambdabot>      not an expression: ‘let f :: State s a -> Int; f _ = 10’
17:30:33 <jle`> > :t let f :: State s a -> Int; f _ = 10 in f
17:30:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
17:30:37 <iqubic> > let pop1 = head in pop1 [1,2,3,4]
17:30:38 <jle`> aw
17:30:39 <lambdabot>  1
17:30:55 <jle`> yeah, that's a state transition
17:31:11 <jle`> you can also have 'splitAt', which is like a state transition that returns an answer
17:31:18 <iqubic> Could you modify pop to be of type [a] -> State [a] a?
17:31:30 <jle`> yeah
17:31:32 <jle`> that's what 'modify' does
17:31:38 <jle`> :t modify ((:) 1)
17:31:40 <lambdabot> (Num a, MonadState [a] m) => m ()
17:31:47 <jle`> :t modify ((:) 1) :: StateT [Int] ()
17:31:48 <lambdabot> error:
17:31:48 <lambdabot>     • Expecting one more argument to ‘StateT [Int] ()’
17:31:48 <lambdabot>       Expected a type, but ‘StateT [Int] ()’ has kind ‘* -> *’
17:31:53 <jle`> :t modify ((:) 1) :: State [Int] ()
17:31:55 <lambdabot> State [Int] ()
17:32:02 <jle`> :t modify head :: State [Int] ()
17:32:04 <lambdabot> error:
17:32:04 <lambdabot>     • Couldn't match type ‘Int’ with ‘[Int]’
17:32:04 <lambdabot>       Expected type: [Int] -> [Int]
17:32:10 <jle`> sorry
17:32:25 <jle`> 'head' isn't really a state transition
17:32:27 <iqubic> :t let pop s = (head s, tail s) in pop [1,2..10]
17:32:29 <lambdabot> (Enum a, Num a) => (a, [a])
17:32:36 <jle`> mhm, my bad
17:32:42 <iqubic> :t let pop s = (head s, tail s) in pop stack
17:32:44 <lambdabot> error: Variable not in scope: stack :: [a]
17:32:47 <jle`> so 'pop' there can be wrapped in State
17:32:58 <iqubic> :t (head s, tail s)
17:33:00 <lambdabot> error:
17:33:00 <lambdabot>     • Couldn't match expected type ‘[t]’ with actual type ‘Expr’
17:33:00 <lambdabot>     • In the first argument of ‘head’, namely ‘s’
17:33:09 <Eduard_Munteanu> @src State
17:33:09 <lambdabot> type State s = StateT s Identity
17:33:09 <lambdabot> --OR
17:33:09 <lambdabot> data State s a = State { runState :: s -> (a, s) }
17:33:30 <iqubic> :t pop s = (head s, tail s) 
17:33:31 <lambdabot> error:
17:33:31 <lambdabot>     parse error on input ‘=’
17:33:31 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
17:33:36 <iqubic> :t let pop s = (head s, tail s) 
17:33:38 <lambdabot> <no location info>: error:
17:33:38 <lambdabot>     not an expression: ‘let pop s = (head s, tail s)’
17:33:39 <jle`> :t let pop s = (head s, tail s) in state pop
17:33:40 <lambdabot> MonadState [a] m => m a
17:33:47 <iqubic> Yes, that.
17:33:53 <iqubic> That is a stateful computation.
17:34:00 <jle`> well, pop is
17:34:08 <jle`> state just wrapped it up in a nice way
17:34:24 <iqubic> Might be better to wrap it in ExceptT to handle the case where the list is empty
17:34:27 <jle`> that makes it easy to manipulate 
17:35:00 <jle`> :t StateT uncons
17:35:02 <lambdabot> StateT [a] Maybe a
17:35:23 <iqubic> jle`: what is uncons
17:35:26 <iqubic> :t uncons
17:35:28 <lambdabot> [a] -> Maybe (a, [a])
17:35:31 <iqubic> Oh.
17:36:00 <jle`> > flip runStateT [1..10] $ replicateM 5 (StateT uncons) 
17:36:03 <lambdabot>  Just ([1,2,3,4,5],[6,7,8,9,10])
17:36:15 <iqubic> > flip runStateT [1..10] $ replicateM 11 (StateT uncons)
17:36:17 <lambdabot>  Nothing
17:36:18 <jle`> uncons is the actual state transition, StateT just makes it easy to manipulate them
17:36:28 <iqubic> Just as expected I get nothing.
17:36:40 <jle`> so profound 
17:36:48 <iqubic> Yeah.
17:37:20 <jle`> StateT and State etc.'s job is to let you manipulate state transitions in cute and convenient fun ways
17:37:44 <jle`> using all of those Haskell abstractions we know and love
17:38:04 <iqubic> Cool
17:38:40 <jle`> > flip runStateT [1...10] $ even <$> StateT uncons
17:38:43 <lambdabot>  error:
17:38:43 <lambdabot>      • Could not deduce (Num (Over p f c0 c0 a b))
17:38:43 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
17:39:00 <jle`> I can't even today it seems
17:39:18 <jle`> > flip runStateT [1...10] $ show <$> StateT uncons
17:39:20 <lambdabot>  error:
17:39:20 <lambdabot>      • Could not deduce (Num (Over p f c0 c0 a b))
17:39:20 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
17:39:38 <MarcelineVQ> more dots
17:39:44 <jle`> ah
17:39:48 <jle`> autocorrect
17:40:04 <jle`> > flip runStateT [1..10] $ show <$> StateT uncons
17:40:06 <lambdabot>  Just ("1",[2,3,4,5,6,7,8,9,10])
17:40:56 <iqubic> WHy do you have to use flip in that example?
17:41:30 <jle`> runStateT usually takes the StateT first and the initial state second 
17:41:36 <jle`> :t runStateT
17:41:38 <lambdabot> StateT s m a -> s -> m (a, s)
17:41:49 <jle`> I use flip to give it the initial state first
17:42:29 <iqubic> > runStateT (show <$> StateT uncons) [1..10]
17:42:31 <lambdabot>  Just ("1",[2,3,4,5,6,7,8,9,10])
17:42:34 <iqubic> I see
17:46:55 <iqubic> :t show <$> StateT uncons
17:46:57 <lambdabot> Show a => StateT [a] Maybe String
17:47:13 <iqubic> :t StateT uncons
17:47:14 <lambdabot> StateT [a] Maybe a
18:19:35 <br1_> how do i run type funcs in ghci? I'm currently writing [] :: Func Int and reading the error message
18:23:42 <thang1> bgamari: hey there! So, I got accepted after all for the haskell summer of code proposal to work on the ghc performance test suite.
18:24:13 <ski> br1 : does `:kind!' work ?
18:24:56 <br1> ski++
18:25:58 <jared-w> bgamari: hey there! So, I got accepted after all for the haskell summer of code proposal to work on the ghc performance test suite. Anything in particular that I should do in order to really start prepping for things?
18:26:02 <mbw> I have a question. Let c_f be some C-Function "void (int arg, void *out)". Depending on the value of arg, c_f will assign a result to *out. BUT: The value of arg depends the type. What would be a straightforward way to make this a little more type-safe, given that the value of arg is known at compile-time?
18:26:16 <jared-w> man I'm tired... totally didn't notice that I didn't query that :p
18:26:24 <mbw> *determines
18:28:16 <jared-w> mbw: is it possible to use some define constant instead of an int arg? You could probably do something with that for type safety...
18:29:12 * ski . o O ( GADTs,partial evaluation )
18:29:37 <mbw> jared-w: The int actually comes from a header-file, which I preprocess with hsc2hs.
18:30:19 <mbw> GADTs would've been my first idea. Then I heard about indexed monads and existentials in the context of FFIs. Oh my...
18:30:28 <jared-w> c_wraith: you would know way more about this than I do. Any suggestions?
18:30:47 <ski> "indexed monads and existentials in the context of FFIs" ?
18:31:52 <c_wraith> jared-w, I do? my only participation was years ago and minimal. 
18:32:32 <jared-w> Well, you're the resident C expert here, aren't you? :p
18:32:38 <mbw> ski: https://www.reddit.com/r/haskell/comments/2v6n61/malloc_free_and_ffi_even_rwh_does_it_wrong/ It was only 1-2 comments, but I assumed it was mentioned for a reason...
18:33:41 <verement> mbw: you may be interested in my solution to this sort of problem: https://github.com/verement/etamoo/blob/master/src/MOO/Builtins/Match.hsc#L335
18:34:01 <c_wraith> my knowledge of C is limited to "every program is full of undefined behavior, run!" 
18:34:28 <jared-w> Hmm. I must be confusing you with someone else then. Probalby because of the c_ in your name...
18:34:43 <c_wraith> the c in my name is something else. intrepid detectives have cracked the code before. :) 
18:34:52 <mbw> verement: Thanks. This pcre thing seems to be popular...
18:35:40 * jared-w types /names; sees 1,500+ nicks; gives up
18:44:54 <mbw> verement: The idea to use phantom types is pretty neat. I never used them before, so I don't think I would've come up with it easily. I have two questions though. First, what kind of names does your use of #enum result in? I normally use it like #{enum Bla, Bla , c_name = NAME}; name = c_name -- ^ Now with documentation. Secondly, why are pcre_compile and pcre_study etc. imported as "safe"? And "static"?
18:46:19 <verement> mbw: I get names like pcreConfigUtf8, pcreConfigUnicodeProperties, etc.
18:46:28 <c_wraith> mbw, anything that might block or run more than a few cycles should be imported safe
18:46:59 <Axman6> verement: have you looked at c2hs at all? looks like it makes some of the things you're doing a bit easier
18:48:00 <mbw> verement: Were you able to figure out how to add documentation without an indirection?
18:48:03 <jared-w> Axman6: anything that they don't already get with hsc2hs?
18:48:21 <mbw> c_wraith: I thought "safe" was only needed if the c-function could call back into Haskell?
18:48:46 <Axman6> c2hs is, afaik, hsc2hs++
18:48:56 <c_wraith> mbw, misleading documentation. anything imported unsafe blocks the garbage collector until it completes. 
18:49:00 <Axman6> does things like automatically create the foreign import calls
18:49:20 <mbw> jared-w: To my knowledge c2hs is more powerful than hsc2hs, like Axman6 says. But it does come with a steeper learning curve. There is a tutorial here: http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
18:49:29 <c_wraith> mbw, you should always prefer safe unless you can prove its both a performance issue and not going to make things worse. 
18:49:46 <glguy> safe is needed if you want your Haskell program to keep working while the C procedure is executing
18:50:04 <c_wraith> mbw, a call inappropriately marked unsafe can destroy concurrent throughput. 
18:50:14 <mbw> Is this important outside of a concurrent context as well?
18:51:44 <c_wraith> less so, but I never bet on code staying non-concurrent
18:51:51 <mbw> And is this documented a little more thoroughly? I don't think I got this even after reading the GHC docs.
18:51:52 <verement> mbw: I think the "static" keyword is optional. I import them "safe" because I want them to be able to run concurrently with other threads.
18:52:47 <mbw> I guess in a concurrent-contexts, a lot of "sensible defaults" have to be reconsidered.
18:52:53 <mbw> *concurrent context
18:52:56 <verement> mbw: And no, I haven't looked at trying to add documentation to the resulting symbols.
18:53:49 <mbw> verement: It's something I wanted to try just for the heck of it. Apparently c2hs has actual support for it.
18:54:01 <verement> Axman6: I don't remember if I looked at it.
18:54:44 <c_wraith> mbw, hmm. I think most of the details come from a couple blog posts and follow up discussions about them that explain exactly what is done differently with safe and unsafe calls. 
18:55:32 <mbw> Typical.
18:55:45 <butterthebuddha> Working on problem 7 -> https://wiki.haskell.org/99_questions/1_to_10
18:56:18 <verement> PCRE is a little tricky to use properly in a multithreaded environment, particularly if you make use of callbacks as I do here.
18:56:18 <butterthebuddha> I'm getting a type error when trying to print flatten (List [])
18:56:25 <c_wraith> mbw, http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
18:56:32 <jared-w> oooh is that nested list basically a rose tree?
18:56:39 <mbw> c_wraith: Thanks.
18:56:54 <mbw> verement: At least now I know I did the pcre_free thing right :)
18:57:06 <c_wraith> jared-w, it is indeed. 
18:57:09 <verement> mbw: :-)
18:57:39 <jared-w> sweet
18:57:49 <butterthebuddha> This is what I have so far -> https://pastebin.com/DTeRH1QS
18:58:54 <c_wraith> butterthebuddha, that looks right. can you include the compile error (and the code that generates it, if it's not in there)? 
18:59:11 <butterthebuddha>   print (flatten (List []))
18:59:18 <butterthebuddha> ^ That's the code that generates it
18:59:20 * jared-w guesses that the solution is to add "deriving (Show)" to the end of the data declaration
18:59:31 <mbw> If what you and ezyang have to say about safe/unsafe is true, some ffi tutorials should be edited. For instance the one on wikibooks (bindings to gsl) strongly suggests you should make unsafe the default.
18:59:47 <butterthebuddha> It works with other NestedLists though
19:00:20 <jared-w> > print []
19:00:23 <lambdabot>  <IO ()>
19:00:30 <butterthebuddha> that's the type error -> https://pastebin.com/MLQ8fpNh
19:00:39 <c_wraith> mbw, I tend to trust ezyang on matters of ghc internals. :) 
19:01:29 <mbw> And I tend to trust the HaskellWiki less and less...
19:02:47 <jared-w> I'm gonna go ahead and take these two pastes and stick them in the "terrible GHC error messages" thread
19:14:35 <butterthebuddha> So uh, anybody know the source of the error?
19:18:31 <jared-w> Try print (flatten (List ([] :: Int)))
19:19:08 <jared-w> Did that work?
19:21:19 <MarcelineVQ> that's a type error, you may have wanted  :t print (flatten (List [] :: NestedList Int))
19:23:04 <glguy> butterthebuddha: The type is ambiguous
19:23:30 <glguy> so you'll have to tell GHC what you intended it to be
19:23:35 <MarcelineVQ> that line print (flatten (List [])) wound work in ghci but not in your program most likely due to ghci having ExtendedDefaultRules turned on
19:23:40 <MarcelineVQ> *would work
19:23:51 <glguy> ?wn ambiguous
19:23:51 <lambdabot> *** "ambiguous" wn "WordNet (r) 3.0 (2006)"
19:23:52 <lambdabot> ambiguous
19:23:52 <lambdabot>     adj 1: open to two or more interpretations; or of uncertain
19:23:52 <lambdabot>            nature or significance; or (often) intended to mislead;
19:23:54 <lambdabot>            "an equivocal statement"; "the polling had a complex and
19:23:55 <lambdabot> [12 @more lines]
19:24:53 <butterthebuddha> MarcelineVQ: That didn't work ether
19:25:14 <butterthebuddha> I'm just gonna ignore this for now I don't wanna spend too much time thinking about it
19:25:32 <MarcelineVQ> It's not a solution, I'm just mentioning why it would work in ghci, glguy is offering a solution though which to to specify the type of NestedList where you use it
19:25:52 <MarcelineVQ> *which is to
19:26:15 <glguy> butterthebuddha: This is an important concept to understand , probably worth not skipping
19:26:46 <glguy> In the expression (print []), what type does [] have?
19:27:38 <butterthebuddha> glguy: This is what I have right now   print (flatten (List ([] :: NestedList Int)))
19:27:57 <glguy> butterthebuddha: Why is this wrong? ([] :: NestedList Int)
19:28:50 <butterthebuddha> glguy https://pastebin.com/DPj3pahN
19:28:58 <butterthebuddha> (I'm gonna be afk for a few minutes brb)
19:29:00 <glguy> OK, so that's a good hint
19:29:36 <glguy> butterthebuddha: When you get back ,try and read the first couple lines of the error message, you should be able to understand them
19:43:52 <butterthebuddha> glguy: So GHC is expecting a different type, not NestedList Int
19:44:13 <glguy> And what type should [] have?
19:44:33 <butterthebuddha> I don't really care is the thing
19:44:39 <butterthebuddha> It can be anything
19:44:44 <glguy> No, it can't be anything
19:44:59 <butterthebuddha> The list has to have a primitive type associated with it right
19:46:01 <glguy> The empty list, [], has to have a type [a] for some a
19:46:43 <butterthebuddha> yep
19:46:54 <glguy> So we can't assert that the type is NestedList Int, NestedList Int and [a] are different, for all a
19:47:29 <butterthebuddha> How do I capture the polymorphism of a though
19:47:53 <glguy> you don't
19:47:59 <butterthebuddha> or do I just make it a list of some typea 
19:48:02 <glguy> print doesn't take a polymorphic type
19:48:04 <butterthebuddha> Like [Integer]
19:48:22 <glguy> You can't instantiate type variables with polymorphic types
19:48:23 <glguy> :t print
19:48:25 <lambdabot> Show a => a -> IO ()
19:48:27 <iqubic> :t print
19:48:28 <lambdabot> Show a => a -> IO ()
19:48:41 <glguy> So print has a single type variable, in this case it's written as 'a'
19:48:49 <glguy> You have to pick some monomorphic type for that to be
19:48:54 <iqubic> Looks like it takes something of type a where a has an instance of show.
19:49:09 <butterthebuddha>   print (flatten (Elem 5))
19:49:14 <butterthebuddha> That works though
19:49:18 <butterthebuddha>   print (flatten (List [Elem 1, List [Elem 2, List [Elem 3, Elem 4], Elem 5]]))
19:49:21 <butterthebuddha> And so does that
19:49:22 <glguy> There's a special case for numbers
19:49:44 <butterthebuddha> I don't understand what's the difference between List [...] and List []
19:50:03 <butterthebuddha> If one works, shouldn't the other work too
19:50:08 <glguy> Your number example only worked because there's a special case for defaulting the type of numbers
19:52:39 <glguy> butterthebuddha: You can read section 4.3.4 to learn more about how numbers are special https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
19:52:52 <dibblego> looks like (NestedList ~ Tree) to me
19:54:10 <juri_> so, i have a function notPointLine :: Eq a => [a] -> Bool . I have implementations notPointLine [p1,p2], notPointLine [], and notPointLine [_]. why is the compiler telling i don't have a match for (_:_:_:_) ?
19:54:34 <glguy> because you don't. you only handled 0,1, and 2 element lists
19:55:13 <juri_> right. so how do i handle the remainder?
19:56:13 <glguy> How did you plan to handle the other cases?
19:56:36 <Rumia_>  Well "x:y:z:xs" matches 3+ lists. 
19:56:37 <juri_> by passing them back in. i really want to process the list in pairs.
20:02:11 <jared-w> juri_: In that case, for a list of size 3 you want to process the first pair and then work on the last element right? Or, to put it another way, for a list of size n+2 you want to work on the 2 and then call the function on the n part somehow
20:03:37 <juri_> yepyep.
20:05:03 <iqubic> So use pattern matching and recursion to handle the 2+ cases
20:05:41 <iqubic> What would be a simple Haskell project for me to work on.
20:06:19 <iqubic> I want to practice my Haskell skils, but I have no idea what to make.
20:07:35 <|sync|> Maybe
20:08:06 <iqubic> Data Maybe a = Nothing | Just a
20:08:39 <MarcelineVQ> make a timer
20:08:53 <|sync|> Sorry. Maybe you can find an interesting programming concept and try to implement it in Haskell. I am in a similar spot and so I've decided to just explore other interesting phenomena and practice my Haskell with it.
20:13:09 <lispre> Haskell the final choice for me to process data structure
20:13:39 <lispre> I really hate to reading the code written by others with c++
20:13:47 <slack1256> how practical is runhaskell as an interpreter? any problems with FFI and forkIO?
20:15:50 <jared-w> So, I have a question, for the protolude stack project template, why does the Main.hs import Protolude when it's also importing Lib which imports Lib.Prelude which imports Protolude?
20:16:43 <glguy> Does Lib.Prelude reexport Protolude?
20:16:46 <MarcelineVQ> at a guess: Prelude is everywhere, in the same vein Protolude probably should be
20:17:21 <jared-w> I suppose I should rephrase: Why isn't Protolude in scope because, 3 modules down, it was already imported?
20:17:30 <Axman6> lispre: welcome! let us know if we can help at all
20:20:51 <lispre> Axman6: I have to read and fix some code of c++, which is used to process the xml tree
20:21:07 <lispre> Axman6: well, it is impl so ugly
20:24:55 <Jackoe> \join #reddit
20:24:59 <Jackoe> whoops
20:25:00 <Jackoe> my mad
20:25:02 <Jackoe> *bad
20:30:01 <iqubic> So, what simple Haskell project should I work on next?
20:30:14 <MarcelineVQ> make a timer
20:30:21 <iqubic> I want to improve my Haskell Skills, but I don't know what to work on.
20:30:31 <jared-w> https://wiki.haskell.org/Yak_shaving
20:30:33 <iqubic> MarcelineVQ: Doesn't that involve Threads?
20:31:02 <iqubic> jared-w: That list is empty
20:31:08 <MarcelineVQ> If you like, it doesn't have to, you could make a timer that times when it runs and tells you the time the passed when it exits
20:31:15 <iqubic> There is nothing in the list you just gave me.
20:31:18 <juri_> i traditionally find some project, turn on all of the warnings, and proceed to try and fix stuff.
20:31:27 <jared-w> Yeah... I had something written down somewhere, darn it
20:31:52 <iqubic> juri_: What project could I fix. Do you have something for me to fix?
20:31:55 <jared-w> The stuff we talked about at one point was stuff like fixing some issues and errors in haskell projects
20:32:16 <iqubic> Oh. That might be cool to work on.
20:32:44 <juri_> i have two projects i have failed to adopt properly. :)
20:32:54 <jared-w> aha found it
20:32:58 <juri_> https://github.com/nhalford/slicer
20:33:01 <iqubic> Anything you want me to try and fix
20:33:08 <juri_> i love haskell and 3d printer stuff.
20:33:29 <jared-w> https://github.com/merijn/criterion <-- "Add ability to filter, combine, reorder, group reports from JSON file and plot those."
20:33:31 <iqubic> juri_: That looks complex
20:33:52 <iqubic> jared-w: That looks hard to work with. I know nothing about aeson
20:33:57 <jared-w> Project 2: Badger people into migrating to quchen's pretty printer instead of their own
20:34:05 <juri_> sure, but the warnings are going to be simple, to start with. :)
20:34:32 <jared-w> iqubic: it's actually not too hard, go to the project itself and merijin will tell you exactly what to do. They worked with me a little bit on talking about it
20:34:36 <iqubic> jared-w: Why is quechen's PP better
20:34:44 <pacak> http://jmespath.org/ - I want this for haskell
20:34:54 <jared-w> The Pandoc project can probably use some stuff worked on as well
20:34:56 <glguy> Badgering people to change libraries sounds like a terrible plan
20:35:08 * hackage hpack 0.17.1 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.17.1 (SimonHengel)
20:35:11 <iqubic> pacak: What is that???
20:35:23 <pacak> iqubic: query language for json
20:35:37 <jared-w> quchen's PP is really nice and it's specifically designed to be able to be 100% dropped in with just an import change and recompile
20:35:43 <iqubic> Sounds too complex to be useful
20:36:10 <iqubic> jared-w: In place of what though? Aren't there multiple PPs?
20:36:16 <jared-w> You seem super good at shooting down stuff you're not familiar with
20:36:32 <Axman6> pacak: lens should let you do all of that
20:36:47 <Axman6> the syntax will be slightly more verbose, but it makes it interoperable with everything
20:36:51 <iqubic> jared-w: I am. I should be more accepting of unfamiliar ideas.
20:37:10 <pacak> Axman6: I want foo :: String -> Value -> Value.
20:38:00 <jared-w> Man it took way too long to find this on github
20:38:00 <Axman6> I disagree
20:38:07 <jared-w> https://github.com/quchen/prettyprinter <-- this is quchen's pretty  printer
20:38:28 <iqubic> I'm not in need of a pretty printer right now though.
20:38:38 <jared-w> He has a ton of "why another prettyprinter" answers, etc
20:38:50 <iqubic> Oh. I might look at that later
20:39:06 <jared-w> Also, one of the ideas was going around to some popular libraries that use printing and submitting PRs to change their printing to the superior library of quchen's
20:39:08 <pacak> Axman6: I specifically want HTTP server that keeps big json value inside and gets random queries to perform on that structure.
20:39:37 <iqubic> So, why do people use threads ever. Single threaded applications are just fine.
20:39:48 <iqubic> pacak: Why would that be helpful??
20:40:22 <MarcelineVQ> jared-w: these are really great things to push people towards. I'm skeptic that working on libraries in order to learn the language is a good idea, but it is a good way to learn tons of other things
20:40:46 <pacak> iqubic: Because alternative is sending whole datastructure to client and doing said operation there.
20:41:12 <Axman6> iqubic: because we're not insane?
20:41:13 <glguy> jared-w: I think you're misguided about badgering people to change libraries
20:41:16 <jared-w> MarcelineVQ: I'm thinking that iqubic doesn't really need to learn more about the language as much as learn more about what they want to learn more about. Tinkering on a lot of libraries and getting familiar about the ecosystem seems like a better idea than "just read more books and implement weirder stuff"
20:41:24 <Axman6> why would people not use threads is my question.
20:41:42 <iqubic> How hard would it be to write Minesweeper in Haskell?
20:41:46 <jared-w> I could be wrong, but that's kinda what I'm seeing  ¯\_(ツ)_/¯
20:41:50 <pacak> iqubic: I do use threads.
20:41:57 <jared-w> iqubic: as hard or as easy as you want it to be, of course :p
20:41:57 <iqubic> pacak: That's good.
20:41:59 <Axman6> iqubic: as har as any other language?
20:42:11 <pacak> iqubic: Because on 40 core processor it's hard to utilize all 40 cores without using threads.
20:42:21 <iqubic> I think I'll try writing Minesweeper in Haskell.
20:42:34 <iqubic> Using Data.Array to store the current board position.
20:42:35 <glguy> jared-w: There's nothing really to be gained by switching from other pretty printing libraries to quchen's fork of wl-pprint-ansiterm
20:42:37 <MarcelineVQ> jared-w: I'm skeptic about that too, but everyone's different
20:42:53 <iqubic> I will write Minesweeper in Haskell.
20:42:59 <slack1256> iqubic: I did that once, good exercise
20:43:00 <jared-w> glguy, It's much more than a fork at this point
20:43:11 <iqubic> slack1256: I'll do it too.
20:43:14 <glguy> so you'd just be annoying people, not contributing
20:43:37 <slack1256> yes use Data.Array. when you finish "see" how easy is to start using other array representations
20:43:46 <MarcelineVQ> I still think you should write a timer. I could use a timer.
20:43:57 <jared-w> It uses Text over String, it has fuse functions, more performance, more extensible backends, minimal dependencies, annotation support, no name clashes, etc
20:43:58 <iqubic> See my main issue is: I don't know how to GUI programming in Haskell, so all my applications will be text based for now.
20:44:16 <iqubic> slack1256: What would you use to store a 2D minesweeper grid?
20:44:28 <jared-w> Also, the much more comprehensive documentation allows for easier integration of prettyprinting into other libraries and for using more advanced features
20:44:37 <Axman6> iqubic: what about web based?
20:44:42 <slack1256> I used various data types. I started with Data.Sequence
20:44:43 <pacak> iqubic: Write 3d minesweeper
20:44:45 <slack1256> the Data.Array
20:44:52 <slack1256> then STArray
20:45:04 <slack1256> all of them text based.
20:45:18 <jared-w> glguy: badgering people to switch doesn't have to be just opening blank issues. It can be as simple as a PR to use the drop-in replacements, followed by a PR or two to slowly start taking advantage of more powerful features
20:45:27 <iqubic> Axman6: I might do web based GUI, but I have no idea how to do web dev, Haskell or otherwise.
20:45:32 <glguy> Which more powerful feature?
20:45:34 <jared-w> Would that still be badgering? I feel like PRs are the least badgering form of contributing possible
20:46:09 <jared-w> glguy: annotations stand out to me. The ability to take advantage of more backends such as HTML backends also stands out to me.
20:46:10 <Axman6> haskell is the best web dev language
20:46:15 <glguy> jared-w: Annotations are not new
20:46:32 <Axman6> iqubic: "I have no idea X" is missing the word yet - of course you have no idea if you haven't tried
20:46:56 <Axman6> you're building unnecessary negative barriers mentally for yourself
20:47:13 <slack1256> does gtk-gi have a tutorial? I just see api docks
20:47:21 <slack1256> *docs
20:47:24 <jared-w> No, they're not, but they're easier to do in quchen's package. I don't believe ansi-wl-pprint has annotation support, either
20:47:37 <glguy> For example the standard pretty package has them
20:48:05 <glguy> and they're only useful if you're going to use them. It's one thing to make a PR switching packages because there's some immediate benefit
20:48:13 <glguy> but just switching because something's new isn't helpful
20:48:31 <jared-w> Is the speed benefit, usage of Text over String, and reduced dependency tree not an immediate benefit?
20:48:31 <hamishmack> slack1256: https://github.com/haskell-gi/gi-gtk-examples
20:49:03 <glguy> jared-w: Not particularly unless making a particularly large document
20:49:14 <glguy> pretty comes with ghc already
20:49:28 <glguy> There are just much better uses of time than making PRs to switch pretty-printing packages
20:49:35 <slack1256> Cool!
20:51:54 <EvanR> i kind of wish there was a pretty print to rule all pretty print libs, so people stop making a new one
20:51:58 <jared-w> Fair enough. Really, the only reason I even mentioned it was because it was on the list that someone gave me of "stuff to do when you run out of stuff to do"
20:52:13 <jared-w> EvanR: *insert xkcd 'standards' comic*
20:52:13 <EvanR> and then build that into ghci
20:52:38 <EvanR> jared-w: yes its something that, if it wasnt done in the very beginning, it can never be done
20:53:26 <jared-w> Although, I do believe quchen was somewhat interested in trying to see if he could get his printer into ghc. As it is, the standard pretty package (the one that ghc's internal pretty is based off of) is already diverged quite a lot and they're trying to bring that into alignment and replace ghc's with the standard pretty package
20:53:54 <EvanR> which one is the standard pretty print package?
20:54:05 <jared-w> https://github.com/haskell/pretty
20:54:19 <EvanR> its not on hackage?
20:54:25 <jared-w> It is
20:54:33 <jared-w> It's in base, I think
20:54:34 * EvanR looks for that link instead
20:54:44 <glguy> To be clear, I'm not arguing against using the new package, just blindly telling people to use it
20:55:16 <jared-w> ghc's internal pretty package uses FastSring over String, and does a bunch of other stuff that (in the github issues) they're trying to unravel and merge into pretty to replace ghc's pretty with the "standard pretty"
20:55:35 <EvanR> what is "ghc's pretty" ?
20:55:55 <jared-w> ghc forked the pretty package and modified it for their own usage
20:56:00 <EvanR> do we ever see that?
20:56:11 <EvanR> does it even matter what ghc uses
20:56:37 <jared-w> Internally in ghc's codebase. Every error message ghc or ghci spits out uses it. It's also used to produce the assembler code that's sent to LLVM or the lower level compilers/assemblers
20:57:35 <jared-w> One of the reasons ghc's error messages tends to suck comes from how they use the printing library and a more powerful/faster one would likely help some with fixing that
20:58:22 <jared-w> In fact, optimizing a printer for ghc itself would actually do things such as increase compile times because of how they use the printer internally. See: https://github.com/haskell/pretty/issues/44
21:00:19 <iqubic> How do I run a stack project?
21:00:47 <iqubic> Like outside of a repl that is.
21:02:37 * hackage streaming-conduit 0.1.0.0 - Bidirectional support between the streaming and conduit libraries  https://hackage.haskell.org/package/streaming-conduit-0.1.0.0 (IvanMiljenovic)
21:02:58 <EvanR> stack exec programName
21:21:53 <LordBrain> Anyone know familiar with the situation in the rts, where a foreignPtr threw an exception? Does ghc ignore it, or does it crash or ?
21:25:56 <iqubic> EvanR: When I do that stack exec, I am never prompted for input. No putStrLn fires, no getLine is called.
21:26:07 <iqubic> Do you know why that is?
21:26:50 <iqubic> Also, how does one do GUIs in Haskell? Is that hard to do.
21:27:14 <EvanR> GUIs are hard
21:27:20 <EvanR> generally
21:27:37 <EvanR> stack exec with no argument?
21:27:44 <iqubic> What I think I want to do is take my current TicTacToe game and make a web frontend for it. How hard would that be.
21:28:02 <iqubic> Also, I run "stack exec TicTacToe
21:28:32 <iqubic> with out the double quote
21:30:12 <LordBrain> things get easier as more people do them tho, as we get more library code
21:33:12 <iqubic> EvanR: What would you recomend I do for a graphical web app version of my code.
21:33:23 <iqubic> All I need to do is change the IO functions.
21:33:35 <iqubic> The back-end is already complete
21:34:12 <jared-w> The easiest option would be to whip up some javascript and make a web based front-end
21:35:40 <LordBrain> what about somethign typed, like purescript.. or that other thing whose name i forget but which is actually probably more common.
21:36:31 <EvanR> elm
21:36:34 <LordBrain> yeah elm
21:36:42 <EvanR> iqubic: ghcjs
21:36:52 <EvanR> or threepenny-gui
21:37:46 <LordBrain> "GUI" is a little bit vague isnt it... i mean what are talking about really... lots and lots of little widgets, or just a game with a menu?
21:39:33 <iqubic> The second one.
21:40:10 <iqubic> jared-w: How do you get JS and Haskell communicating with each other
21:40:47 <iqubic> Whatever mechanism I use for my GUI has to be able to interface with my Haskell code.
21:43:09 <LordBrain> i have an unfinished game library written on top of GLUT
21:43:09 <LordBrain> if you want we could collaborate
21:43:09 <LordBrain> what it gives you that GLUT doesn't, is a grid concept... where you can put sprites on at grid coordinates, and it has various supported movement types
21:43:12 <LordBrain> it also supports walking
21:43:26 <LordBrain> like having 2d characters walking around in a world that is bigger than the screen
21:45:57 <LordBrain> it does scrolling.. tho not smoothly
21:47:35 <iqubic> Nah, I'm fine.
21:48:38 <LordBrain> the thing doesnt even have a name, its sitting on my hard drive in a directory called l
21:49:01 <iqubic> LOL
21:49:25 <iqubic> So what's the simplest Haskell web GUI I can use for my TicTacToe Game
21:49:31 <LordBrain> its in a git repo tho locally, i could push to github or whatever
21:49:48 <iqubic> Or just GUI in general. Doesn't have to be a web GUI
21:50:07 <LordBrain> there's lots of options and no clear winner
21:50:15 <LordBrain> as far as i can tell
21:51:07 <MarcelineVQ> I've not used it but brick should be a simple ui start https://hackage.haskell.org/package/brick
21:51:26 <MarcelineVQ> depending on how you feel about the g in gui
21:51:57 <nshepperd> you could make some kind of haskell DSL that produces javascript, should you be looking for an infinite rabbit hole to fall down
21:53:04 <cocreature> deech has put a lot of effort into making fltkhs easy to use so that’s at least a contender
21:53:37 <LordBrain> yeah, people recommended fltkhs last time i asked a similar question
21:53:50 <cocreature> afaik the gtk bindings are also decent
21:53:58 <cocreature> and we also have wltkhs bindings
21:54:23 <LordBrain> there's wxHaskell too... that used to be a favorite.. maybe not any more tho, people dont talk about it as much
21:54:41 <cocreature> for something like tictactoe where it’s more about 2d drawing than throwing together a bunch of buttons, you could also just use nanovg
21:54:44 <nshepperd> 'gloss' package does graphics and you could build a gui on that. but it doesn't come with built in widgets like menus and stuff
21:54:56 <LordBrain> it used to be all you had was wxhaskell and gtk
21:55:16 <LordBrain> now, there's so much, nobody is really sure
21:57:43 <LordBrain> if you prefer working wiht mostly your own code and less with widget libraries, then you could go with something like GLUT or GLFW bindings
21:57:55 <iqubic> Well, I also want a way to detect where on the screen the player has clicked, so I know what square the user has selected.
21:57:58 <LordBrain> that seemed to be my preference
21:58:16 <LordBrain> glut can do that
21:58:21 <cocreature> all libs will allow you to get the screen coordinates where the player has clicked
21:58:25 <LordBrain> yeah
21:58:33 <LordBrain> there's no limitation there
21:58:35 <iqubic> Is glut simple? How does glut work?
21:58:50 <cocreature> but something like glut or nanovg won’t give you builtin button widgets and figure out automatically whether it has been clicked
21:58:59 <LordBrain> yeah, its very simple
21:59:11 <cocreature> you’ll have to do the translation from screen coordinate to “widget that has been clicked” yourself
21:59:22 <LordBrain> it does tend toward global state some
21:59:33 <LordBrain> is the only caveat..
21:59:34 <iqubic> I don't need any fancy widgets. I just need a way to draw primative shapes onto the screen and detect the X Y coords of a mouse click.
21:59:52 <LordBrain> iqubic, i'm using GLUT with rasterific and some glue code
22:00:00 * nshepperd would use gloss for something like that
22:00:10 <iqubic> Would also be nice to differentiate between left and right click too, but that's extra
22:00:22 <LordBrain> the input output stuff is super easy
22:00:28 <LordBrain> no problem
22:00:29 <iqubic> nshepperd: Why would you use gloss over glut?
22:00:39 <nshepperd> because i don't know glut lol
22:00:57 <iqubic> So it looks like the simplest options for me are gloss or glut.
22:01:20 <iqubic> I don't know either framework, so I don't know which is better
22:01:37 <LordBrain> okay, well..
22:01:40 <cocreature> try them both and see which one you like more :)
22:02:07 <cocreature> “is X better than Y” is a question to which there is usually no objective answer
22:02:16 <LordBrain> the primitives that come with glut are easy to use, but they're very code not data... so you cant stream them to a file and call that your vector graphics asset
22:02:36 <LordBrain> thats why i mixed it with rasterific
22:02:42 <iqubic> What about gloss primatives? Are those code or data?
22:04:00 <LordBrain> https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Data-Picture.html#t:Picture
22:04:09 <cocreature> or are they codata? (I’ll show myself out)
22:04:27 <LordBrain> they look more data like than gluts
22:05:16 <LordBrain> Picture is of kind * and has an instance for Data... its a bit closer to rasterific
22:06:40 <nshepperd> you can even Show it
22:06:43 <LordBrain> gluts primitives are really from the opengl package
22:07:05 <iqubic> Why is this decision so hard to make??
22:07:28 <LordBrain> they're all in IO
22:07:46 <nshepperd> try all of the options, in alphabetical order
22:07:55 <nshepperd> problem solved
22:08:56 <LordBrain> glut uses StateVar, so if you see code like $= to set everything from an IORef to some threaded state in your monad...
22:09:08 <LordBrain> heh
22:09:21 <LordBrain> it has a very imperative feel
22:09:23 <cocreature> or just choose one and stick to it. given the requirements you’ve given so far, all of them should do the job
22:09:26 <EvanR> what if there are uncountable options... use axiom of choice to get an order?
22:09:35 <LordBrain> imperative can be quick when starting out tho
22:10:18 <nshepperd> EvanR: flip an infinite dimensional quantum coin, and do all of the options in different universes simultaneously
22:12:01 <iqubic> I think I'll start with the simpler of the two
22:12:06 <iqubic> Which one is that?
22:12:09 <MarcelineVQ> I got a trans-mail from dimention 32, it turns out the right option all along was to use a lib wrapping sfml
22:12:12 <kadoban> So Data.Dependent.Sum.DSum is ... a generalization of Either, where you can have an arbitrary number of things instead of just Left/Right ? Or is there more to it?
22:12:22 <LordBrain> GLUT is easy, bindings to a c library, and its all imperative, nothing truly haskellish about it, but it's quick to learn. 
22:12:45 <EvanR> SFML...
22:12:58 <LordBrain> this is what i did first: https://wiki.haskell.org/OpenGLTutorial1
22:13:08 <iqubic> Does gloss follow the haskell paradigm?
22:13:18 <EvanR> actually yes
22:13:41 <EvanR> so does code.world
22:13:46 <nshepperd> gloss is pretty haskelly
22:13:48 <iqubic> Well, then I'll use gloss.
22:14:09 <iqubic> Anyone have a good gloss tutorial? Or shall I google that?
22:14:26 <EvanR> with gloss i was about to throw together an animation of conway life in less than <time here>
22:14:38 <EvanR> dont read a tutorial, just read the docs
22:14:55 <iqubic> Are the docs confusing?
22:15:09 <EvanR> no more questions
22:15:40 <iqubic> Well, If I'm not getting to ask questions, can I have some answers?
22:15:54 <EvanR> you ran out question credits, to get more, do something on your own for 15 minutes
22:16:03 <EvanR> its like a casino
22:16:10 <EvanR> (and parking deals)
22:16:16 <nshepperd> i didn't find the docs confusing, but that's pretty subjective
22:16:17 <iqubic> Alright then. I'll go RTFM
22:16:47 <EvanR> honestly how will anyone know if you will find the docs confusing, which youd already know if you had already done it 
22:17:07 <LordBrain> yeah, i think glut is probably the simpler of the two, but you pay for that later
22:17:08 <LordBrain> although... by pairing it up with rasterific, i've already solved that issue
22:17:25 <nshepperd> Raid The Fantastic Mansion
22:18:32 <butterthebuddha> http://imgur.com/a/kx37m
22:18:37 <butterthebuddha> Any hints I'm out of ideas
22:20:12 <iqubic> Gloss looks rather simple to use.
22:20:25 <iqubic> I think I'll stick with gloss
22:20:36 <kadoban> butterthebuddha: Well, that's 'group'. Are you trying to implement it yourself though I assume?
22:20:51 <butterthebuddha> Yep
22:21:06 <LordBrain> with gloss.. if you did wnat to use rasterific, then you have the issue of having multiple graphics primitives
22:21:06 <LordBrain> and i dont know if gloss can load .svg files
22:21:06 <LordBrain> probably not
22:21:06 <LordBrain> which means if you are using svg as assets, you end up using rasterific, and now you have double the vector primitives
22:21:07 <LordBrain> but i havent actually gone down that road, so i am not speaking from experience, its only me speculating
22:21:39 <kadoban> butterthebuddha: How far did you get? Did you get stuck at any particular place?
22:21:50 <iqubic> I'm just going to be using primative shapes.
22:22:05 <iqubic> https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Data-Picture.html#t:Picture
22:22:18 <iqubic> That's the only data I really need from gloss
22:22:35 <iqubic> And https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Interface-IO-Game.html
22:22:42 <butterthebuddha> kadoban: This is what I have right now -> https://pastebin.com/ncV46JFP it's obviously incorrect though
22:22:44 <iqubic> playIO is good too.
22:24:06 <iqubic> Though I don't understand gloss' concept of simulation steps.
22:24:41 <nshepperd> butterthebuddha: that looks pretty good, you just need to fix the a == b case
22:25:22 <EvanR> iqubic: it repeatedly calls your step at a rate you choose
22:25:29 <butterthebuddha> Mmhmm, but I'm not sure how to go from [[a]] to [[a, b]]
22:25:45 <EvanR> it iteratively updates your world data
22:26:13 <EvanR> so ex. you can make stuff animate or time out
22:26:14 <LordBrain> butterthebuddha, note your notation is wrong [[a,b]] is not a valid type... maybe you mean [(a,b)] or [[(a,b)]]
22:26:50 <butterthebuddha> No, a and b are not types - they are elements
22:27:03 <LordBrain> oh
22:27:17 <EvanR> still bad, [[x]] to [[x, y]] plz
22:27:24 <LordBrain> haha
22:27:30 <nshepperd> butterthebuddha: well, what is the result of pack (b:xs)? it should look like [[b, ...], ...]
22:28:36 <nshepperd> or, to put it plainer, (b:bs):ys
22:28:43 <nshepperd> does that help?
22:29:29 <iqubic> EvanR: If I'm not using animations can I just set that to "return world"?
22:29:51 <iqubic> And set iterations per second to 0
22:31:08 <kadoban> butterthebuddha: There's probably other ways, but consider making the type instead  pack' :: Eq a => [a] -> [a] -> [[a]]    where the first parameter is an accumulator which is either empty or a list of things that are all equal, it's the thing you're trying to "enlarge" at each step.
22:32:30 <LordBrain> just make it already and find out
22:32:31 <LordBrain> heh
22:32:32 <LordBrain> a little trial and error wont kill ya
22:32:43 <iqubic> I'll try it out later.
22:32:53 <iqubic> It's midnight here and I'm tired.
22:35:12 <iqubic> what's the difference between Graphics.Gloss.Interface.IO and Graphics.Gloss.Interface.Pure?
22:35:32 <Axman6> one lets you use IO
22:36:02 <iqubic> Actually, they both let me use IO, I think.
22:36:25 <iqubic> Look at the type of play from Pure.Game. Or at least look at the final return type.
22:36:27 <iqubic> IO ()
22:36:35 <MarcelineVQ> they both result in IO actions, but IO lets you use IO resulting functions as arguments
22:36:40 <Axman6> but your functions can't
22:36:44 <iqubic> Right, I just noticed that.
22:36:50 <Axman6> of course animate has to use IO, it's drawing to the screen
22:37:00 <iqubic> Is there a reason to use one over the other?
22:37:20 <Axman6> use pure if you don't need to use IO :\
22:37:41 <Axman6> if you're not reading from the network, or files, or something else, then you have no need for the IO version
22:38:00 <iqubic> The only IO I need the Event argument of the key handler function.
22:38:11 <iqubic> I'm not doing any other IO
22:38:13 <Axman6> Gloss takes care of that IO for you
22:39:00 <iqubic> https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Data-Picture.html How do I tell Gloss where to put my pictures?
22:39:07 <Axman6> you just provide a function which takes an event, and your game's state, and modifies it appropriately
22:39:23 <iqubic> Oh, I use translate, rotate, and scale
22:40:27 <Axman6> iqubic: can you do me a small favour, and try and answer these questions for yourself before asking them here? most of your questions for the last hour have been trivial for you to find the answer to by spending 30 seconds reading the thing you're already looking at. asking every question that comes to mind is just adding noise
22:40:39 <iqubic> I'm sorry,
22:40:41 <MarcelineVQ> alternatively https://www.google.ca/search?q=haskell+gloss+tutorial
22:41:03 <iqubic> I'll only ask questions if I have tried a bunch of options and am still getting nowhere.
22:41:07 <MarcelineVQ> gloss-examples is a result and it's a pretty good overview of things
22:45:38 <kadoban> So Data.Dependent.Sum.DSum is ... a generalization of Either, where you can have an arbitrary number of things instead of just Left/Right ? Or is there more to it? And DMap is ... is it just a Map where the value associated with each key isn't necessarily the same or something?
22:46:10 <kadoban> Kind of confused why these things have an Applicative f in there either, it doesn't seem to get mentioned much and is usually just Identity?
22:53:56 <glguy> kadoban: I don't think the Applicative part features much beyond being a bit of a hack used to get access to pure, at least in the dependent-sum package
22:56:05 <kadoban> I think I'm missing why pure would be needed :-/
22:56:19 <glguy> k ==> v = k :=> pure v
22:56:42 <glguy> If you're going to have the generalization of having it parameterized on 'f'
22:56:53 <glguy> it just allows you to write that as a convenience function
22:57:17 <glguy> Is your question "why 'f'" or "why Applicative"?
22:57:54 <kadoban> But is the Applicative somehow necessary for this magic thing to be built, or is it just some choice that instead of  Either a b, you can have Either (f a) (f b) where f is some random "containery" thing
22:58:00 <kadoban> I think that's my current confusion
22:58:54 <kadoban> Like, why isn't it just data DSum tag   instead of  data DSum tag f ?  Is the former nonsense or impossible to build or something?
22:58:55 <glguy> data DSum tag f = forall a. MkDSum (tag a) (f a) -- constructor renamed for clarity
23:01:45 <Zemyla> Okay, I have a question. Who here is familiar with the whole "Comonads into Monad Transformers" thing Edward Kmett wrote an article about earlier?
23:02:20 <kadoban> I think I understand that ^  I'm just not sure why it's not just   data DSum tag = forall a. MkDSum (tag a)  I guess? Maybe I should experiment with this more and it'll make more sense or something. I kind of barely understand GADTs, I've read about them a few times and it made sense, but never really did much in the way of exercises.
23:02:53 <glguy> sorry, got pulled away
23:03:00 <kadoban> No worries
23:03:24 <glguy> So the idea is you can have a "tag" value with no data
23:03:27 <glguy> and then pair that with some data
23:03:47 <glguy> So an example might where the tag type is "MessageType"
23:03:58 <glguy> and the 'f' type is "Message"
23:04:17 <glguy> or Identity if messages are simple
23:04:44 <glguy> the message type stands on its own, you could perhaps parse a message type and that might drive what kind of message you're going to parse next
23:05:24 <glguy> by using a GADT for the tag type you can use that to learn the type of data associated with a message by matching on the tag
23:06:18 <kadoban> I don't seem to be able to envision a case where it's not Identity or what that means different
23:07:17 <glguy> OK I can give you a very related example that we could have rewritten using DSum
23:07:39 <glguy> (I haven't needed DSum, but I've used related types and I think this example will help, and that you'll be able to see how to reformulate it in DSum
23:07:58 <glguy> http://hackage.haskell.org/package/config-schema-0.5.0.0/docs/src/Config.Schema.Spec.html#ValueSpecs
23:08:02 <glguy> newtype ValueSpecs a = MkValueSpecs { unValueSpecs :: NonEmpty (Coyoneda ValueSpec a) }
23:08:10 <glguy> Let's focus on (Coyoneda ValueSpec a)
23:08:32 <glguy> ValueSpec is a GADT, it's serving the role of the tag type in a DSum
23:08:39 <osa1> anyone know if warp's "send response" callback runs in async? does it block the handler?
23:08:48 <glguy> You can case on a ValueSpec and learn what type of thing its associated with
23:09:08 <glguy> data Coyoneda f a where
23:09:08 <glguy>   Coyoneda :: (b -> a) -> f b -> Coyoneda f a
23:09:41 <kadoban> *reading*
23:09:50 <glguy> This is a bit like:  Coyoneda f a = DSum f (-> a)
23:10:03 <glguy> We know that you can't do that with ->, but imagine a newtype
23:11:12 <glguy> In this example when we match on the f/ValueSpec, we learn that existentially quantified 'b' type
23:11:27 <glguy> which gives us a function we can use
23:11:35 <kadoban> Ohh
23:11:40 <glguy> Didn't want to store a value, wanted to store a function
23:11:47 <glguy> err
23:12:00 <glguy> Didn't want to store a value of type 'b', wanted a function of type b -> a
23:12:56 <glguy> So in DSum MyTag ((->) Int);  data MyTag a where IsInt :: MyTag Int; IsBool :: MyTag Bool
23:13:16 <glguy> as a related example of something we coudl do that isn't Identity
23:14:05 <kadoban> Okay, cool. I think that's starting to make sense. Pretty sure I'm following. Need to think on that a bit more
23:14:19 <glguy> All that said, I think DSum itself is pretty boring
23:14:30 <glguy> but it's the larger pattern that's worth thinking about
23:15:24 <kadoban> I'm mostly trying to understand some reflex code more and they tend to use these things and I get a bit brain addled once I see DSum or anything anywhere, haha. I get lost what is even going on.
23:17:30 <kadoban> Thanks again, I'm going to reread that a few times and try to experiment and get some things compiling. That's one of the first examples that I at least think is making sense to me though, that's very helpful.
23:19:53 <glguy> I'll be around if you have more questions sometime
23:40:05 <MarcelineVQ> does someone have an example of using Codensity? I hear it mentioned fairly often, reading the paper for it currently
23:44:47 <quchen> Does anyone have access to the zurihac-attendees mailing list here who could send a mail on my behalf?
23:45:01 <MarcelineVQ> ohoho, it's a bit like dlist for bind?
23:45:08 <MarcelineVQ> p. cool
23:46:03 <EvanR> wellthat made it click
23:51:13 <MarcelineVQ> ertes: were you talking about using Coyoneda for resource management?
