01:19:53 <earthy> ghe. I've *stopped* using haskell for work some 7 years ago... :)
01:22:02 <Cale> earthy: What are you working on now?
01:22:52 <Cale> LiaoTao: I started learning Haskell back around 2001-2002
01:23:46 <ertes-w> earthy: may i ask why?
01:28:53 <Cale> Yeah, 2002 is more accurate -- I remember hearing about Haskell in 2001 and reading a bit about it, but the first compiler I actually installed was GHC 5.02.something, and apparently 5.02.3 was in April 2002 and 5.02.1 was Nov 2001. I don't remember exactly what time of year it was.
01:29:33 <bollu1> quchen: ping?
01:31:58 <earthy> ertes-w: I've got a job at a C# shop
01:33:03 <earthy> (and have learned that you can write functional code in almost any language :))
01:33:40 <ij> Is compiling with nix known to be slower than stack build?
01:33:58 <earthy>  I've got a job at a C# shop
01:34:08 <earthy> https://github.com/arthurvl/snippets/blob/master/Zipper.cs
01:34:17 <earthy> there. 'scrap your zippers' in C#. :)
01:39:17 <Cale> ij: Well, if it's slower, it's mainly because you might end up building dependencies outside of Haskell-land. But most of the time in our builds is not spent waiting for nix.
01:39:58 <quchen> bollu: 
01:40:27 <quchen> bollu: What’s a hashed string?
01:41:30 <ertes-w> earthy: really?  i found that you can write functional code in almost no language, and that includes C# in particular =)
01:42:45 <ij> Cale, The non-git deps not included! ghc's each of [n of 23] just takes longer.
01:43:12 <piyush-kurur> ertes-w: I cannot write functional (in all sense of that word) in any other language too
01:43:37 <earthy> ertes-w: hey, it pays the bills, so it's functional to me :P
01:44:46 <ertes-w> earthy: yeah, i might be a bit lucky regarding the technology choices i can make =)
01:44:55 <ertes-w> haskell, nix, btrfs, …
01:46:42 * earthy nods
01:47:23 <earthy> I *could* move to haskell, but I'd have a hard time with taking along the other developers and the interns
01:47:57 <earthy> the risk/benefit ratio does not play out well
01:48:30 <quchen> Neil Mitchell has something interesting to say about that
01:48:42 <earthy> quchen: I bet he does. ;)
01:48:57 <quchen> Which comes down to that he and his team consistently wipe the floor with their internal competition
01:48:59 <ertes-w> earthy: yeah, i can imagine how difficult it would be to convert a C# shop =)
01:49:33 <phadej_> I guess C# people are so used to VS the lack of IDE is a real issue
01:49:41 <earthy> then again neil's a PhD and our interns are community college...
01:49:58 <quchen> PhD means nothing
01:50:04 <ertes-w> although at least it's not like a ruby shop…  they are used to static typing and using it as an abstraction mechanism (at least most of them are)
01:50:16 <phadej> SPJ doesn't have a PhD!
01:50:23 <quchen> He does, honorary :-)
01:50:43 <earthy> quchen: I have to disagree there. PhD means years of training
01:50:45 <phadej> quchen: :)
01:50:46 <quchen> PhD means you spent more time at uni, researching something mostly unrelated to whatever you’ll do afterwards. PhDs don’t make stupid people smart, and not having one doesn’t make smart people stupid.
01:51:12 <earthy> and as quchen states hanging around at a university
01:51:22 <earthy> (which in and of itself surrounds you with a higher percentage of smart)
01:51:40 <L4rmbr> hi, all, Just learned haskell. I was wondering if  we can implement Applicative using Moand (i.e.  to reverse the dependence). I've tried, but failed. Had difficulty transforming 1st arg of <*> (of type "f (a->b)") to "a->b"(if we can, then it is easy to get "a -> f b").  It seems this could not be done intrinsically, because Monad is a Monoidal group, which has no invertibility.  Do I misunderstand anything? Thx
01:52:13 <quchen> L4rmbr: Monoidal group? Nooonononono. We don’t do that sort of stuff. We have the terms, but nothing else from category theory.
01:52:15 <phadej> L4rmbr: hoohle for `ap`
01:52:25 <phadej> hoogle*
01:52:29 <geekosaur> :t ap
01:52:30 <lambdabot> Monad m => m (a -> b) -> m a -> m b
01:52:36 <quchen> L4rmbr: https://github.com/quchen/articles/blob/master/fbut.md#reversed-type-class-instances
01:52:37 <geekosaur> @src ap
01:52:37 <lambdabot> ap = liftM2 id
01:53:32 <geekosaur> in short, the liftM* functions were Applicative before we had Applicative
01:53:52 <geekosaur> (and liftM itself is just fmap, but Monad wasn't based on Functor so we had to "recover" it from (>>=)
01:54:08 <itsu> hi guys, can anyone help me with a question I have about Alternative and IO ? this is my problem http://lpaste.net/356374
01:55:00 <itsu> I don't understand why some of my code seems to be lazy and some other (IO) don't seem to be...
01:58:00 <geekosaur> because IO is strict, but something like `return $ trace "c1" Container ["c1"]` is only evaluated as far as the ($) at most and any further evaluation must be forced by the consumer --- which doesn't do so, because the consumer is satisfied with c1.
01:58:20 <geekosaur> and Alternative is based on Applicative, which cannot choose what to do, it must evaluate both
01:58:35 <geekosaur> (you need Monad to be able to choose what to do)
01:58:49 <quchen> itsu: liftA2 f a b evaluates both a and b.
01:59:18 <geekosaur> so the IO happens but the resulting expression doesn't get *fully* evaluated to the point that the trace happens
01:59:38 <geekosaur> you get back a lazy chunk of code that ends up being discarded
02:02:08 <itsu> geekosaur: I see your point. so would if I don't want to evaluate c2 if c1 is valid, Monad can help me ?
02:02:24 <itsu> s/would//
02:03:20 <geekosaur> sort of? liftM2 is the Monad equivalent of liftA2, but it also evaluates both. you have to use the full Monad interface, which would let you see if the first one produces a result and not compute the second
02:04:32 <geekosaur> do { a' <- a; if not (null a') then return a' else b }
02:04:49 <L4rmbr> phadej, quchen , thx. glad to know that
02:05:16 <geekosaur> it's that conditional that can't be done with Applicative / Alternative; it has to do both a and b and only afterward check if a produced something usable
02:06:59 <itsu> geekosaur: yeah, I could have that instead of `<|>`. It just seemed much much consized with the <|> way
02:07:13 <geekosaur> more concise, yes, but at a price
02:07:20 <itsu> too bad it has to evaluate both :-( 
02:07:33 <halogenandtoast> Is there a better way to write: getDomain req = Domain <$> (decodeUtf8 <$> requestHeaderHost req)
02:07:52 <ertes-w> halogenandtoast: fmap f . fmap g = fmap (f . g)
02:08:02 <halogenandtoast> oh derp
02:08:13 <itsu> But I don't see why your solution has to use the full Monad interface. how `do { a' <- a; if not (null a') then return a' else b }` is related to the Monad interface ?
02:08:23 <halogenandtoast> ertes-w: thanks for that
02:08:30 <ertes-w> halogenandtoast: use the functor axioms, luke =)
02:08:47 <geekosaur> itsu, '<-' turns into (>>=), and (>>=) is specifically what Monad has and Applicative doesn't
02:08:56 <geekosaur> it allows you to inspect the result and decide what to do based on it
02:08:57 <halogenandtoast> ertes-w: I know!
02:09:20 <halogenandtoast> I don't know why I don't immediately think of them when I'm using fmap
02:09:20 <geekosaur> Applicative doesn't have (>>=) and can;t inspect the result; it can only get the results and hand them back out for something else to inspect
02:09:28 <geekosaur> so it must run both
02:09:45 <itsu> oh ok, you meant the Monad interface for IO then. 
02:09:59 <geekosaur> right
02:11:15 <ertes-w> halogenandtoast: perhaps because you weren't using fmap, but (<$>)
02:11:29 <itsu> so if Alternative needs both result, I should stay away from it if I need lazyness right ?
02:11:52 <geekosaur> right
02:11:58 <ertes-w> halogenandtoast: f <$> (g <$> c) = f . g <$> c  -- not quite as memorable as the fmap-based composition law =)
02:12:22 <L4rmbr> quchen, https://github.com/quchen/stgi Nice projects, I like it :-)
02:12:22 <itsu> geekosaur: Thanks a lot for your help, it's much clearer in my head now ;-) 
02:12:26 <geekosaur> although, again, if you're just handing up something pure with 'return' then you may not care, as the parameter to 'return' will be lazy
02:12:34 <geekosaur> but any I/O will happen regardless
02:13:01 <itsu> I see 
02:16:19 <halogenandtoast> ertes-w: yeah true, but I'll never give up (<$>)
02:16:53 <halogenandtoast> but I think after this mistake I'm finally in a place of understanding that I won't let it happen again.
02:31:51 <tdammers> I use fmap when it feels functory, <$> when it feels applicative
02:32:05 <tdammers> (emotion-driven development, yay!)
02:34:05 * mekeor feels applicative for emotion-driven development
02:41:18 <halogenandtoast> I feel like I keep running into this situation where I nest cases on Maybe's is there a better way of handling this as well? https://gist.github.com/halogenandtoast/ba0ce64680e36cdafeb77fb52da344ae
02:41:48 <Cale> halogenandtoast: you could use MaybeT
02:42:07 <halogenandtoast> See I tried that, and I always get confused on how to chain it together
02:42:29 <halogenandtoast> so a more direct example of my problem
02:42:42 <halogenandtoast> I don't know how to get  mdomain <- getDomain <$> request to work inside of runMaybeT
02:43:35 <halogenandtoast> request is request :: MonadIO m => ActionCtxT ctx m Request
02:43:58 <halogenandtoast> getDomain :: Request -> Maybe Domain
02:44:01 <Cale> lift
02:44:23 <Cale> Er, not for that one though
02:44:36 <Cale> That's one of the things you want to eliminate the Maybe from, so MaybeT
02:44:53 <Cale> domain <- MaybeT (getDomain <$> request)
02:45:44 <halogenandtoast> ugh thanks Cale, I had been doing
02:45:51 <halogenandtoast> domain <- MaybeT . getDomain <$> request)
02:45:57 <halogenandtoast> without the ) at the end of course.
02:46:35 <mekeor> so you mixed up . and $
02:47:54 <halogenandtoast> mekeor: yeah :(
02:49:26 <Cale> halogenandtoast: https://gist.github.com/halogenandtoast/ba0ce64680e36cdafeb77fb52da344ae
02:51:53 <Cale> halogenandtoast: does that work?
02:53:53 <Cale> Ah, I see, you chopped it up differently -- that makes sense.
02:54:28 <halogenandtoast> Cale yeah your example almost worked
02:54:35 <Cale> What failed?
02:55:33 <halogenandtoast> https://gist.github.com/halogenandtoast/ba0ce64680e36cdafeb77fb52da344ae#gistcomment-2127840
02:55:58 <Cale> oh
02:56:04 <Cale> didn't mean to pattern match Just there
02:56:13 <Cale> Try it with  Entity _ redirection
02:56:29 <halogenandtoast> ah right
02:57:07 <halogenandtoast> the last rootUrl is outside the do
02:57:10 <halogenandtoast> so it's out of scope
02:57:29 <Cale> oh, yeah
02:57:31 <halogenandtoast> but that also isn't a maybe so pulling it out would probably work
02:57:41 <Cale> that should also be pulled out, yeah
02:57:56 <Cale> The thing with <|> should work, though in your case, I think what you did is probably clearer
02:59:31 <halogenandtoast> Cale: what does <|> do? The description "An associative binary operation" doesn't do much for me.
03:00:08 <halogenandtoast> I guess I could look at the source
03:00:30 <halogenandtoast> oh nvm that's in GHC base, loading that always kills my browser
03:00:50 <Cale> https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.Maybe.html#line-144
03:01:22 <halogenandtoast> ah nice
03:02:43 <halogenandtoast> Thanks for the help
03:21:36 <quchen> L4rmbr: Thanks :)
03:29:29 <lambdamu_> When we bind a C function with a void* argument or return type what makes the most sense to map void* to: Ptr (), Ptr Void or forall a. Ptr a?
03:29:42 <merijn> lambdamu_: Whichever you like
03:30:18 <Cale> lambdamu_: Often you'll want some more appropriately named Haskell type for the thing
03:30:31 <Cale> lambdamu_: it's common to write something like
03:31:05 <Cale> newtype Thing = Thing { unThing :: Ptr Thing }
03:31:32 <Cale> and then use that in place of the Ptr when importing
03:33:43 <lambdamu_> Ok so my thinking is Ptr Void is the most accurate mapping from C Semantics, but as long as () has no Storable instance Ptr () works as well without enabling stupig mistakes, Ptr a can be passed every Ptr without casting which might be convenient but notably not how it works in C
03:34:48 <lambdamu_> Cale: what is the benefit of that though?
03:35:04 <Cale> lambdamu_: Well, people use void* in C to mean pointers to lots of different sorts of stuff. Often the polymorphic thing will be a correct interpretation, because the reason that the C thing took a void* was because you're expected to pass a pointer to any number of different sorts of things
03:35:19 <Cale> lambdamu_: Type safety in working with the things on the Haskell side.
03:35:40 <Cale> (the benefit of the newtype)
03:35:46 <lambdamu_> Cale: yes but you have to cast in c, too, no?
03:36:18 <lambdamu_> (not regarding newtypes)
03:36:25 <Cale> You probably will cast, but often a C function can do its work without needing to care what type of data is pointed to by a given pointer
03:36:50 <Cale> and so people will use void* as a way of indicating that it doesn't care
03:37:07 <Cale> In situations like that, Ptr a is a good translation
03:38:29 <lambdamu_> Cale: sure, I mean that purely syntaticially c compilers will throw a warning if you try to pass uint8_t* to void* as far as I remember, but if that is what you want or not is arguable, it's nice that we have the polymorphic choice in haskell
03:38:49 <Cale> Oh, sure
03:38:55 <Cale> C doesn't actually have polymorphism
03:39:21 <Cale> But that doesn't mean C programmers don't still need it :P
03:40:58 <lambdamu_> Cale: regarding the newtype, I don't see how that is more strongly typed than the Ptr which has a phantom type after all, so it only prevents us from doing pointer casting or arithmetic, which might be what you want in a high level interface, right?
03:41:26 <Cale> Well, it also obscures the fact that the thing is a pointer at all.
03:42:01 <lambdamu_> Cale: I guess that counts as encapsulation
03:42:16 <Cale> But if you have things whose type was void* in C but they're actually supposed to be used differently and aren't really interchangeable
03:42:27 <Cale> then use of types like that can help you use the C code more correctly
03:42:34 <smallCat> Can someone help me figure out what's going on here :
03:42:42 <smallCat> http://lpaste.net/5596463049499213824
03:42:55 <lambdamu_> Cale: Ah that makes sense
03:43:33 <lambdamu_> Cale: we could still use different pointer tags to achieve the same, though
03:43:40 <Cale> smallCat: Are you sure that you have a webserver running on port 8000?
03:44:17 <Cale> lambdamu_: yes, this just creates that tag in a cute way
03:44:29 <smallCat> Well, it's supposed to be running on port 8000. (When I run "stack exec <web app name>" in another tab and then run the test suite, it works)
03:44:47 <smallCat> It's just not working when I run "stack test"
03:44:48 <Cale> lambdamu_: Note that you can also use the type Ptr Thing after making that newtype declaration :)
03:45:43 <Cale> smallCat: That error just means that the connection was refused, as if the server wasn't running
03:46:06 <lambdamu_> Cale: No fun without a little obfuscation
03:47:00 <smallCat> Cale: I know. I can't figure out why- testWithApplication is supposed to run the server and execute the test action, yes?
03:48:44 <Cale> I don't know what testWithApplication is. What's its definition?
03:49:08 <Cale> oh, it's a warp thing?
03:50:04 <Cale> oh
03:50:15 <Cale> It runs the application on a port that it gives you as an argument
03:50:22 <smallCat> It's a warp thing. Runs the given application on a free port- yeah
03:50:24 <Cale> not necessarily on port 8000
03:50:38 <Cale> So, you need to pass the port along and try to connect to it on that port
03:51:34 <smallCat> On I see
03:51:39 <smallCat> I'll try that, thanks!
04:01:08 <Gurkenglas_> I wonder why Data.Heap doesn't provide (a -> (b, [a])) -> [a] -> [b]. (Also perhaps a monadic variant)
04:12:49 <quchen> \_ _ -> []
04:12:52 <quchen> There you go.
04:14:35 <LiaoTao> const (const ([]))
04:14:54 <bollu> quchen: ping
04:15:01 <quchen> .
04:15:20 <bollu> quchen: I'd asked you a question about what you'd do if you had a hashed string to implement Pretty for :)
04:15:32 <bollu> quchen: as an aside, the laws of pretty, lol xD
04:15:36 <quchen> Yes, and I asked you back what a hashed string is
04:15:47 <bollu> quchen: ah, I see. lambdabot did not tell me that
04:15:59 <quchen> Oh, I asked it here, not via Lambdabot. Anyway
04:16:03 <bollu> quchen: it looks like GHC takes a string and hashes it, and uses this hashed value as the representation of the string
04:16:17 <quchen> So if all you have is a hash it’s hard to recreate the original string from it.
04:16:20 <bollu> quchen: ah. I just moved IRC providers (now running lounge on my server), so I may have missed it
04:16:21 <quchen> Got a link to the hash typeh
04:16:31 <bollu> quchen: I believe there's a store of hash -> string
04:16:37 <bollu> quchen: because they have a pretty instance
04:16:41 <bollu> quchen on the fastString
04:17:02 <bollu> quchen: that must know the original string somehow. Unless the hash function is invertible?
04:17:11 <quchen> Why can’t you just copy the old Pretty instance?
04:17:36 <bollu> quchen: because their Doc format has a custom sum in their sum type called "FastString"
04:17:48 <bollu> which I'm assuming does some fancy environment lookup when it comes to actually printing it out
04:18:09 <quchen> Uh. Okay, then I guess you’ll have to look at their layout algorithm
04:18:16 <quchen> I don’t know how they do it
04:18:27 <bollu> quchen https://github.com/ghc/ghc/blob/master/compiler/utils/Pretty.hs#L269
04:18:39 <bollu> quchen https://github.com/ghc/ghc/blob/master/compiler/utils/Pretty.hs#L309
04:18:47 <bollu> quchen neither do I, I'm just speculating here
04:18:58 <bollu> I won't get time to check out how they do it today either. Probably tomorrow.
04:19:16 <quchen> bollu: Doesn’t fastString contain both the hash and the original string?
04:19:52 <bollu> quchen does it? 
04:20:17 <bollu> https://github.com/ghc/ghc/blob/master/compiler/utils/FastString.hs#L180
04:20:43 <bollu> hm, is the ByteString the char* representation?
04:21:07 <quchen> uuurhhghh unsafePerformIO sighted
04:21:20 <quchen> uid <- newIORef 603979776 -- ord '$' * 0x01000000
04:21:21 <quchen> keke
04:21:43 <bollu> yeah, that's where they initialise the table
04:22:39 <quchen> bollu: Ha! https://github.com/ghc/ghc/blob/ba597c1dd1daf9643b72dc7aeace8d6b3fce84eb/compiler/utils/FastString.hs#L487
04:23:08 <bollu> quchen: xD thanks
04:23:12 <quchen> :-)
04:23:12 <bollu> quchen: I missed that.
04:23:21 <bollu> quchen: note: do not program when sleepy :)
04:23:29 <bollu> quchen: are there haddocks for all GHC modules somewhere?
04:23:31 <quchen> Are you in India?
04:23:40 <bollu> quchen: Nope, still in Zurich. I'm here till December
04:23:46 <bollu> quchen: I was debugging this yesterday night.
04:23:52 <quchen> Oh. Was just wondering what time it was where you are.
04:24:00 <quchen> Ah, I understand! :-)
04:24:35 <quchen> Yes, there are Haddocks somewhere
04:24:51 <quchen> bollu: »GHC API« https://downloads.haskell.org/~ghc/latest/docs/html/
04:25:31 <bollu> quchen: do you see something similar for FastZString?
04:26:08 <bollu> hm, I think I can just unpack
04:26:24 <bollu> ah no, "zString" does the job.
04:26:28 <quchen> :-)
04:26:34 <bollu> :t inlinePerformIO
04:26:35 <lambdabot> error: Variable not in scope: inlinePerformIO
04:26:41 <bollu> hmm, what's the semantics?
04:26:44 <quchen> bollu: https://github.com/ghc/ghc/blob/master/compiler/utils/Pretty.hs#L880
04:26:47 <bollu> of inlinePerformIO
04:26:59 <bollu> ah, ty
04:27:13 <quchen> inlinePerformIO is a somehow worse version of unsafePerformIO I think. You’d have to ask dcoutts about this. He explained the ladder of usafety to me a year ago.
04:27:30 <bollu> lol, I see
04:27:33 <bollu> "somehow worsE"
04:27:36 <bollu> what's the ladder?
04:27:44 <quchen> I forgot most of it, but it was an excellent explanation ;-) What I remember is that unsafePerformIO is relatively safe
04:27:56 <quchen> And accursedUnutterableUnsafePerformIO is the devil
04:28:07 <quchen> And then there’s something in the middle
04:28:17 <quchen> Maybe it was inlinePerformIO.
04:28:17 <dcoutts_> right, there is no inlinePerformIO, there is only accursedUnutterableUnsafePerformIO
04:28:26 <dcoutts_> which is indeed named appropriately
04:28:38 <bollu> you weren't kidding o.O
04:28:39 <quchen> Oh hey Duncan. Long time no see :-)
04:28:42 <dcoutts_> :-)
04:28:44 <bollu> :t accursedUnutterablePerformIO
04:28:45 <lambdabot> error:
04:28:45 <lambdabot>     Variable not in scope: accursedUnutterablePerformIO
04:28:50 <quchen> It’s in bytestring
04:28:52 <bollu> https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L591
04:28:54 <bollu> yeah, I found it
04:28:57 <dcoutts_> same type as unsafePerformIO
04:29:02 <bollu> I was wondering if lambdabot knew about it
04:29:07 <bollu> dcoutts_: have we met? 
04:29:15 <dcoutts_> not sure
04:29:49 <quchen> Probably not, since you’ve been in Europe since Winter only, bollu – right?
04:29:52 <bollu> either way :) what is the "tower of unsafety"
04:30:03 <bollu> quchen: uh, I've been here since.. March
04:30:04 <bollu> mid-march
04:30:15 <quchen> unsafePerformIO < inlinePerformIO < accursedUnutterableUnsasfeperformIO
04:30:17 <quchen> That’s the tower.
04:30:18 <bollu> nut yes, that is practically winter :P
04:30:22 <bollu> but*
04:30:41 <bollu> ah, I see.
04:30:44 <dcoutts_> quchen: um note that inlinePerformIO = accursedUnutterableUnsasfeperformIO
04:30:51 <bollu> inlinePerformIO guarantees inlining?
04:31:01 <quchen> dcoutts_: Is it? I thought they were different
04:31:11 <dcoutts_> no, I literally just renamed it to accursedUnutterableUnsasfeperformIO
04:31:25 <dcoutts_> you probably meant unsafeDupablePerformIO
04:31:29 <quchen> AAaaah right.
04:31:36 <bollu> quchen: https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L595
04:31:39 <quchen> Sooo unsafePerformIO has this mutex
04:31:40 <dcoutts_> that lives between unsafePerformIO and accursedUnutterableUnsasfeperformIO in the tower of unsafety
04:31:47 <bollu> explain?
04:31:58 <quchen> AccursedIO doesn’t have the mutex and the compiler can look into it and CSE it and what not
04:31:59 <dcoutts_> check the api docs, they're reasonably good
04:32:11 <quchen> dupable is non-inspectable, but does not have the mutex
04:32:15 <quchen> ...something along those lines?
04:32:29 * dcoutts_ has to disappear
04:34:16 <Gurkenglas_> What language extension do I need to do for "unrollM :: (Monad m, Ord a) => (a -> m [a]) -> [a] -> m [a] (...) where step :: Heap.MinHeap a -> m [a]" to work?
04:34:48 <quchen> scoped type variables?
04:34:55 <quchen> Assuming you want to share the »m«
04:37:49 <Engen> hey all, just checking my understanding of the different ways in which haskell can be used http://lpaste.net/356379 - does this make sense?
04:38:00 <Engen> in reference to data types*
04:38:53 <quchen> Engen: Your »GADT« is an ADT, specified with GADT syntax
04:39:05 <quchen> It’s fully equivalent to the ADT above
04:39:31 <bollu> quchen no?
04:39:39 <bollu> quchen because in the GADT, Z :: Nat Int, for example
04:39:40 <quchen> No?
04:39:56 <bollu> oh, sorry, I was mixing up the two examples
04:40:01 <quchen> Nat Int? Line 7 is what I meant
04:40:04 <bollu> right 
04:40:07 <quchen> Line 19 is a proper GADT, right.
04:40:08 <bollu> I was talking of 13
04:40:10 <bollu> yes
04:40:58 <bollu> also, "reflect values to the type level" versus "lift values to the type level" versus "unify types and kinds"?
04:41:06 <bollu> they're different ways of phrasing the same thing, yes?
04:43:30 <Engen> quchen: so my second and third definition of Nat is still an ADT?
04:44:16 <quchen> Engen: Yup. You can write that if you enable GADTSyntax, no need for GADTs.
04:45:45 <Engen> Oh ok, even the part referring to the phantom type? 
04:46:06 <quchen> That part is correct.
04:46:18 <quchen> Nat-line-12 is phantom in a.
04:51:38 <smallCat> is there any good documentation for servant-client?
04:51:50 <smallCat> The only documentation I can find is really basic
04:52:36 <LiaoTao> smallCat, Maybe, but don't hold your breath
04:52:45 <LiaoTao> Haskell has somewhat of a documentation problem in some areas
04:53:00 <smallCat> ... yeah, I noticed
04:53:32 <smallCat> I'm specifically looking at how to send tagged headers (eg: a header tagged "Cookie", etc) via servant-client function
04:55:20 <quchen> Instead of holding your breath, you should consider adding documentation as you learn about the library.
04:55:35 <quchen> It’s a valuable contribution, much more useful than some new feature.
04:56:12 <smallCat> Oh. Yeah, I think I'll do that!
04:56:12 <quchen> It can be a lot of work though, but there is no need to do it all in one go. Even for a handful of definitions it can be a tremendous help.
04:56:36 <smallCat> Mmm. I could do that.
04:57:08 <quchen> Here’s my last documentation project, https://hackage.haskell.org/package/prettyprinter-1.1/docs/Data-Text-Prettyprint-Doc.html
04:57:18 <quchen> Before it was fairly sparse.
04:57:32 <quchen> I guess Servant has similar issues, all while being significantly more complicated to use.
04:57:43 <quchen> (Or some Servant libraries, at least.)
05:06:29 <Sh4rPEYE> Hello. I'm trying  to install intero using stack, but using stack install intero throws this error: http://lpaste.net/2093542329095815168
05:06:44 <Sh4rPEYE> Seems like some bug in terminfo, but I wasn't able to look up anything online
05:08:18 <LordBrain> hmmm
05:08:49 <LordBrain> looks like the symbol <#> is meant to be an infix operator, but enabling CPP is interfering
05:09:16 <davidbarthelemy> Hi guys ! I build my own text editor. I need to choose a GUI lib but i' a little confused... What's the best GUI lib (stable, active, ...) Thx :)
05:10:59 <fendoer> Sh4rPEYE, i got a lot of such pronlems because libtinfo has been separated into several files, you should look into /var/lib if the following symbolic links exist: libtinfo.so, libtinfo.5.so and libtinfo.5.9.so
05:11:08 <fendoer> some of this may have caused your problems
05:12:18 <fendoer> Sh4rPEYE, i mean /lib, not /var/lib
05:12:50 <Sh4rPEYE> So you mean usr/lib, right?
05:14:10 <fendoer> yeah...
05:14:22 <fendoer> i always get confused with library locations...
05:14:27 <Sh4rPEYE> fendoer, in /usr/lib there isn't any link named libtinfo
05:14:45 <fendoer> ok, so it might be your problem
05:14:59 <fendoer> is there the library libncurses?
05:15:37 <Sh4rPEYE> yep, libncurses.5.4
05:16:46 <fendoer> funny, seems to be an old version
05:16:49 <fendoer> i have 5.9
05:16:58 <Sh4rPEYE> oh. how to update that?
05:17:07 <fendoer> idk, i used my package manager
05:17:28 <fendoer> it already gave me the correct version
05:17:38 <fendoer> however, it should work to create the symbolic links yourself
05:19:21 <fendoer> i described how i fixed it for me here: libtinfo.so
05:19:24 <fendoer> wrong 
05:19:28 <fendoer> https://dev.solus-project.com/T3308
05:20:24 <Sh4rPEYE> And what's your package manager? I use homebrew, but didn't install libncurses with it
05:20:54 <fendoer> eopkg, but i think your version will suffice
05:20:56 <fendoer> sudo ln -n libncurses.so.5.9 libtinfo.so.5.9
05:21:07 <codedmart> I am working on wrapping an Api that I need to use in my app. How would you model this: `Optional Object - Free-form dictionary of traits of the user, like email or name.` -> `HM.HashMap Text Value`?
05:21:37 <fendoer> of course  libncurses.so.5.9 but  libncurses.so.5.4
05:23:32 <Sh4rPEYE> Now when I know it's an old version... I couldn't sleep without updating it
05:25:28 <fendoer> seems like 6.0 is announced
05:25:36 <andreabedini> Hello! Eternal beginner here, I am working on a program to parse binary files which will have to do random IO within the file (seeking here and there). I can parse each single struct with cereal or binary just fine but I don't know how to deal with seeking. I see few options 1) just use lazy IO and pass a lazy bytestring around 2) do everything in IO 3) lose my mind because I read somewhere that you can do bidirectional
05:25:37 <andreabedini>  communication with Pipes.Core. Anyone has advice?
05:26:04 <Sh4rPEYE> I'll look it up. fendoer, it's actually libncurses.5.4, whithout "so". That's alright, right? 😃 
05:27:11 <Sh4rPEYE> Well, actually, it says : sudo ln -n libncurses.5.4 libtinfo.so.5.9 ; ln: libncurses.5.4: No such file or directory
05:27:19 <fendoer> Sh4rPEYE, probably, honestly speaking i'm not such an expert on this subject, i can't even garantuee that this is your problem, but you can try, if it does not work, just delete the symbolic link again
05:27:35 <pacak> andreabedini: iteratees, pipes, conduits - all can do io. You should also be able to map all the things into memory.
05:27:42 <fendoer> are you in the right directory?
05:28:01 <Sh4rPEYE> oh, no I'm not, ofc. As you can see, I'm not an expert either
05:29:40 <fendoer> great, so i dont have to feel embarassed either :D 
05:30:41 <piyush-kurur> anyone has sample appveyor.yaml for use in raaz? 
05:31:26 <andreabedini> pacak: thanks! but it's not just streaming, I need to read a bit, parse an offset and then jump to that offset and keep reading, so I need to tell the upstream to do a seek. Also, will I be able to not put the downstream in IO? I am not too familiar with pipes&all, although I have been reading a lot
05:31:57 <andreabedini> davidbarthelemy: I heard good things about https://hackage.haskell.org/package/brick
05:32:11 <pacak> https://hackage.haskell.org/package/mmap-0.5.9 - dunno if it works
05:32:48 <cocreature> iirc I’ve used that package at some point and it did work :)
05:33:50 <andreabedini> pacak: yes, going down that route would mean keeping everything in IO, suggestion which I might accept for it's simplicity :)
05:33:54 <andreabedini> *its ouch
05:35:04 <davidbarthelemy> thanks andreabedini  :)
05:36:07 <andreabedini> davidbarthelemy: you're welcome, it was mentioned on /r/haskell recently
05:36:25 <andreabedini> davidbarthelemy: ah! there it is https://www.reddit.com/r/haskell/comments/6i3g75/i_built_another_terminal_app/
05:37:21 <davidbarthelemy> @andreabedini looks great !! :)
05:37:21 <lambdabot> Unknown command, try @list
05:39:15 <Sh4rPEYE> LordBrain: Yes, it does. Any idea how to solve it?
05:45:54 * sm wonders how we can stop the news spam on /r/haskell, and why it increased recently
05:55:03 <quchen> Ignoring it usually helps
05:58:31 <c_wraith> sm: it comes from bots trying to build up rep mechanically for accounts that will later spam.  The best option is downvote and report as spam, as those explicitly hurt the goal of the bot.
06:00:04 <sm> will do. Though we don't seem to be having much impact on it so far
06:00:45 <c_wraith> it's a stochastic process.  The end goal being that the people running them see that /r/haskell is a place where they get downvotes instead of upvotes, and change the list of subreddits to spam
06:01:13 <sm> do you think people are looking at it , at all ?
06:01:34 <sm> I would think its automated and they probably don't baby sit it
06:02:07 <sm> does reddit allow moderation of posts ?
06:02:17 <c_wraith> as in before they show?  I believe so.
06:02:36 <c_wraith> I know it does with comments, I *think* it does with posts
06:02:44 <sm> getting it bit tired of reading about random murders when I go for some haskell news
06:02:53 <sm> s/it/a/
06:07:08 <sm> ah good, https://www.reddit.com/r/haskell/comments/6i2n0z/rhaskell_moderation_applications/ 
06:32:04 <iqubic> Is there a Haskell version of JS Promises?
06:32:07 <iqubic> I think it'd be something like Cont
06:37:46 <lyxia> iqubic: async
06:38:27 <lyxia> oh it's actually not monadic as I thought
06:42:28 <quchen> You can wrap async in ContT.
06:42:42 <quchen> withAsync, rather.
06:43:04 <quchen> And then you get all the syntax niceties :-)
06:43:44 <c_wraith> Though you really should use Codensity instead of ContT if that's all you're going for.
06:44:54 <hodapp> Codensity? that's a new one to me.
06:49:23 <c_wraith> hodapp: https://hackage.haskell.org/package/kan-extensions-5.0.2/docs/Control-Monad-Codensity.html
06:50:07 <c_wraith> hodapp: the important thing in this context is that you can use it for reinversion of control like ContT, but it's more restricted so you can't introduce all the crazy control flow ContT can
06:54:25 <quchen> I never understood codensity vs cont :-(
06:56:57 <quchen> c_wraith: Oh wait, codensity is just a forall'd ContT?
06:57:05 <c_wraith> No, it's simpler than that.
06:57:24 <quchen> runContT :: (a -> m r) -> m r
06:57:26 <c_wraith> Oh, no, I'm wrong.  Yes, that's the difference
06:57:33 <quchen> runCodensity :: forall b. (a -> m b) -> m b
06:57:41 <quchen> I see. Can you explain what difference this makes?
06:57:46 <quchen> Is there e.g. no callCC for codensity?
06:59:05 <iqubic> What does callCC do?
06:59:56 <c_wraith> quchen: well, Codensity doesn't define a MonadCont instance, so..  I'd guess you can't.  I've never tried to work through it.
07:00:15 <quchen> iqubic: Roughly speaking, it gives you an »early return«
07:01:12 <quchen> iqubic: https://github.com/quchen/articles/blob/master/cont_monad.md#special-api-function-callcc
07:05:07 <piyush-kurur> question on cabal file. If I have FFI code in a library but do not intend to provide the internal header files for other packages, do I need an install-include ?
07:13:32 <glguy> piyush-kurur: the important things are that it builds, and that sdist includes the file.
07:14:57 <piyush-kurur> glguy: okey I see. So  you are saying that just putting it in install-include ensures sdist adds it. Might equally well put in extra-source-files I guess
07:14:58 <piyush-kurur> ?
07:16:00 <glguy> yes, that's what I think. I would need to peek at the docs to be sure, but those would be my concerns
07:17:07 <piyush-kurur> glguy: thanks
07:22:26 <MitchellSalad_> will a MIN_VERSION_blah(x,y,0) pragma match version x.y?
07:22:44 <glguy> Yes
07:22:46 <MitchellSalad_> since x.y.0 > x.y, per the Ord instance
07:22:51 <MitchellSalad_> thanks
07:27:19 <quchen> MitchellSalad_: see the macros.h file in your sandbox or .stack-work
07:27:29 <quchen> MitchellSalad_: It defines all these macros, and is surprisingly readable
07:27:45 <quchen> Although I’m not sure it’s used in newer GHC versions, since GHC now generates such macros internally as well
07:28:56 <quchen> (Where »newer« means »since 8«)
07:32:39 <khanix> doesn anyone know how you can get "openBinaryFile: does not exist (No such file or directory)" from ByteString.writeFile? Shouldn't it just create the file? 
07:33:22 <Boomerang> khanix: Maybe you don't have the permission to create it where you want.
07:33:24 <MitchellSalad_> quchen: cool, thanks
07:33:42 <nshepperd> khanix: or the containing directory doesn't exist
07:33:45 <Boomerang> So it silently fails to create the file and then can't open it
07:36:04 <khanix> It was the containing directory, thanks!
07:36:17 <dmj`> khanix: { doesFileExist fileName >>= \exists -> when exists (openBinaryFile … }
07:36:45 <cocreature> dmj`: hello race condition :)
07:37:09 <dmj`> cocreature: fine, all that inside a modifyMVar_ ;) 
07:37:33 <cocreature> dmj`: how does that help if an arbitrary process can delete the file in between?
07:37:34 <ongy> dmj`: welcome to race conditions with the other processes
07:38:46 <cocreature> there are very few cases where using doesFileExist is actually a good idea
07:39:13 <ongy> just read and catch the exception. You will always race against the world otherwise in (most) IO
07:39:48 <cocreature> I wonder why the error message is so shitty. I would have thought the os gives you more info in this case?
07:40:37 <ongy> ah writeFile is probably the directory, not the actual file either way
07:40:45 <Boomerang> I would probably use something like `createDirectoryIfMissing True` (from the directory package)
07:41:50 <ongy> erm, the exception message is about the directory, not the actual file. (better wording) so that doesFileExist doesn't work that well either way
07:42:12 <ongy> Boomerang: I agree. But it can still hapen that something for some reason deletes the directory you just successfully created
07:42:43 <cocreature> it’s race conditions all the way down
07:44:50 <Boomerang> ongy: Would `atomically` from stm help in that case? Or is that only atomic from the point of view of the Haskell process?
07:45:09 <khanix> I think "does not exist (No such file or directory)" would be a lot clearer if it said "Directory does not exist"
07:45:18 <khanix> in this case*
07:45:28 <nshepperd> stm is internal. you can't do io in it anyway
07:45:41 <Boomerang> Oh yeah right :/
07:47:32 <greeny> hi. For my master project I'm writing am iterative Monad class. I'm struggling with the restricted monad problem. The iterative monad gets a input value of type 'a' and a function of 'a -> m Either (b a)'. When the result is 'b' we are done, otherwise 'a' is taken as new input. One of my instances do require this 'a' to be an instance of class Eq. The reduced code can be found here: 
07:47:33 <nshepperd> imo, your program should deal with the common case where there is no race by checking for / creating the directory first, so that you get a better error message
07:47:34 <greeny> http://lpaste.net/356381.  The problematic instance is at line 75. LineNr 87ff I tried to implement an approach by http://hsenag.livejournal.com/11803.html?nojs=1. No really working yet. Sry for the long text :(
07:48:39 <nshepperd> when you *are* racing against another process you just have to live with worse error messages
07:50:50 <mniip> greeny, does ElgotMonad make sense for only Eq types?
07:51:16 <mniip> IOW, could you add Eq to the signature of 'iteration'
07:51:24 <mniip> as defined in the typeclass
07:52:58 <greeny> mniip: That was my approach too. But my tutor means that it shouldn't be restricted, because ElgotMonads in category-theory papers aren't specified either 
07:53:29 <mniip> is ElgotMonad a categoric thing?
07:54:01 <greeny> i believe so
07:54:10 <mniip> it sounds to me your structure is simply not one then
07:56:19 <mniip> I see a heavy mention of finitariness and finite representation
07:56:56 <mniip> perhaps, after all, this notion wasn't intended, to be extended to the entire Hask?
07:57:03 <mniip> if at all possible
08:01:57 <greeny> maybe you are right. The main goal of this library is it to define an ElgotMonad instance which represent processes from a process algebra. We want to save the processes and their behavior in a set, but because processes may run endless they can't be ordable. 
08:02:37 <greeny> So our approach was to define ElgotList, which keeps track of already made iterations to prevent such loops
08:03:24 <greeny> but therefore the ElgotList needs to compare the new 'a' with every earlier one
08:04:08 <greeny> and compare needs Equality and so on...
08:04:36 <greeny> perhaps limiting ElgotMonad with Eq is the only way
08:04:48 <greeny> (which does work)
08:12:05 <zomg> Any good literature / best practices for whether you should be using custom exceptions or either or something else in your code?
08:12:28 <zomg> I know I'd *probably* use an exception in most langs for this particular case but not sure with haskell :)
08:14:38 <cocreature> zomg: almost everyone agrees that you shouldn’t throw exceptions outside of IO. whether you should be using exceptions in IO or something like ExceptT is something that not everyone agrees on. personally I use exceptions in that case most of the time
08:16:11 <ongy> ExceptT is a bit of a weird thing. Since you will probably miss *some* IO exception, so you get the ExceptT stuff (with types) and still have some exceptions you don't see in your types
08:16:24 <ongy> I like the general idea, but afaik for that reason it's not generally recommended
08:16:33 <glguy> ExceptT is nice in cases that aren't IO
08:16:55 <glguy> In the IO case it can't guarantee you've caught everything, and makes things slower
08:19:55 <[exa]> zomg: good practice is to detect unrecoverable state as soon as possible and fail sanely before you even need exceptions. anyway, what's the exact case?
08:25:22 <locallycompact> say I have a GADT like this
08:25:23 <locallycompact> https://gitlab.com/snippets/1664808
08:25:48 <locallycompact> how do I then make a list of fields where a is just one of those things
08:25:51 <locallycompact> but not necessarily homogenous
08:26:13 <glguy> locallycompact: Make another type that forgets the type parameter
08:26:26 <glguy> data SomeChoice = forall a. SomeChoice (TypeChoice a)
08:26:36 <cocreature> something like vinyl’s record type can also be useful when working with GADTs https://hackage.haskell.org/package/vinyl-0.5.3/docs/Data-Vinyl-Core.html#t:Rec
08:27:03 <cocreature> if you don’t need it to be an actual list
08:27:37 <glguy> locallycompact: You can generalize that: data Some f = forall a. Some (f a)  -- which may or may not be useful for your cast
08:30:50 <locallycompact> why might it not be useful?
08:31:09 <glguy> If you only have one case you just might not benefit from the generalization
08:31:26 <locallycompact> what's a case in this context?
08:31:35 <glguy> TypeChoice 
08:31:50 <locallycompact> but I have several
08:31:54 <glguy> If you have other types with parameters you'd like to forget, you could reuse the parameterized version
08:32:01 <locallycompact> oh ok
08:32:04 <cocreature> the great thing about pattern matching on GADTs is that you gain type info by matching on the value
08:32:20 <cocreature> oh nvm I misread what you said
08:32:26 <bollu> @tell quchen how do resolve between using prettyprinter and ansi-wl-pprint that is used by trifecta?
08:32:26 <lambdabot> Consider it noted.
08:32:31 <bollu> @tell in the context of STGi
08:32:32 <lambdabot> Consider it noted.
08:40:00 <locallycompact> glguy, how do I derive show for that Some?
08:41:12 <glguy> locallycompact: You don't derive it, you define it in terms of http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Classes.html#t:Show1 or if you're using something like dependent-sum there are other classes for that
08:41:13 <glguy> http://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-GADT-Show.html
08:41:32 <glguy> This is one of the reasons you might choose not to go that route
08:42:04 <locallycompact> I can't understand the ramifications of this
08:53:06 <tomzz> Hey! I got a general "programming pattern" question.
08:53:15 <tomzz> In an UI where widgets are composed of smaller widgets, each widget needs different values from a 'global' state (global since we need to pass it every time the main 'loop' iterates). Passing the whole state to each widget is most flexible and composes nice, but seems like a bad style. Giving a widget only what it needs ends up in a lot of refactoring when the widgets functionality increases.
08:53:29 <tomzz> Is it a question of preference or am i doing sth wrong here? thx :)
08:59:08 <erisco> what sorts of global values does a widget need?
08:59:21 <mniip> man I'd like to play with dependenthaskell :(
09:01:21 <mniip> if it only had existed
09:08:19 <ertes-w> tomzz: passing everything explicitly is where i would always start
09:09:38 <ertes-w> tomzz: when you do that, you will notice certain groups of values that are always passed together…  now you still give everything explicitly, but you no longer pass every value individually…  you create a product type for each such group
09:10:51 <ertes-w> tomzz: that way you can preserve the nice locality property that you get by passing everything explicitly, but without the unwieldiness of passing dozens of values everywhere
09:11:27 <ertes-w> tomzz: oh, and from my personal experience (you might disagree!): avoid ReaderT
09:12:12 <cocreature> ertes-w: you can take ReaderT from my cold dead hands :)
09:15:26 <ertes-w> cocreature: if you like it, use it…  my own experience is that its supposed convenience is just an illusion, because first of all it wants you to combine everything into a single global-information type…  and then all it does is to change "blah x = …" to "blah = do x <- ask; …"
09:15:34 <ertes-w> plus you start to write "liftIO" in front of everything =)
09:17:12 <cocreature> ertes-w: saying it only changes "blah x = …" to "blah = do x <- ask; …" misses the point imho: the advantage is that I don’t have to pass x down to whatever I call from "blah"
09:18:02 <ertes-w> cocreature: the cost of explicit passing (if you actually need it!) is overestimated
09:18:53 <cocreature> I don’t think arguing over this is going to get us anywhere since it’s mostly a matter of style, so I’ll stop here :)
09:19:16 <ertes-w> cocreature: sure =)
09:20:32 <dolio> Maybe you write too much IO code.
09:42:37 <manek> Hello guys! How can I check in runtime if im running 32 or 64 bit system ?
09:42:55 <manek> I was looking in hoogle but failed to find answer :/
09:44:38 <MarcelineVQ> try  ghc +RTS --info
09:44:48 <geekosaur> you can't, generally. you could check whether your program was compiled for 32 vs. 64 bit, but anything else is system dependent and sometimes the system doesn't want you to know
09:44:48 <ClaudiusMaximus> sizeOf nullPtr   perhaps
09:45:14 <geekosaur> (os x tries hard to hide the info, windows 64-bit runs 32-bit programs in a container that identifies itself as 32-bit)
09:46:24 <manek> geekosaur: oh, ok. So I've got application which is a "isntaller manager" - you can tell that you want to install a component and we need to download it for the right architecture. So the best way t odo it is to check whcih arch the installer was compiled against?
09:46:49 <tomzz> ertes-w: cocreature: thanks guys! i'll check out readerT and how to i could use product types.
09:47:19 <geekosaur> manek, probably.
09:47:42 <manek> geekosaur: however I'd love to allow this instlaler to install 64bit packages on 64 bit system evn if the installer was compiled against 32 bit. So its impossible i guess
09:47:52 <manek> geekosaur: thanks for the info! :)
09:48:08 <geekosaur> windows at  least hates you in that regard, yes
09:48:31 <cocreature> is there really no syscall on windows that lets you figure out what version of the os is installed?
09:48:32 <geekosaur> if you try to install something from WOW32, you only get access to install 32-bit tuff
09:48:41 <manek> geekosaur: I hate it mutually ;)
09:48:45 <geekosaur> cocreature, it returns information about the container
09:48:46 <geekosaur> not the host
09:48:54 <geekosaur> it's annoying
09:49:00 <manek> geekosaur: ok, thanks for the help!
09:49:05 <manek> :/
09:49:18 <cocreature> geekosaur: does https://msdn.microsoft.com/en-us/library/ms684139(v=vs.85).aspx not work?
09:49:38 <cocreature> iiuc this seems like it tells you if you’re running in that container
09:50:23 <geekosaur> it works, but you can't sanely query anything about the host, only that you're in a sandbox
09:50:43 <geekosaur> so programs that care will at that point abort and tell you to install the 64-bit version
09:50:44 <cocreature> but that sandbox is only running on 64bit, right?
09:50:54 <cocreature> so if that’s all you care about it should be sufficient
09:51:53 <geekosaur> an installer manager needs to know more, though. and, worse, cannot install 64 bit programs, only 32 bit
09:53:31 <cocreature> hm good point
10:05:11 <xa0> yo
10:05:29 <xa0> herhyyyyyyyyyyyyyytyyyyyyyyyyy
10:05:45 <xa0> test
10:05:46 <xa0> tests
10:05:48 <xa0> testtest
10:05:49 <xa0> test
10:05:49 <xa0> test
10:05:50 <xa0> et
10:05:50 <xa0> est
10:05:50 <xa0> et
10:05:51 <xa0> se
10:05:51 <xa0> s
10:05:51 <xa0> e
10:05:51 <xa0> tse
10:05:51 <xa0> t
10:05:52 <xa0> e
10:05:52 <xa0> estete
10:05:53 <xa0> e
10:06:03 <mniip> xa0, would you stop that please?
10:06:04 <xa0> es
10:06:09 <xa0> hwa
10:07:30 <glguy> cocreature: Is the llvm-hs library suitable for doing runtime code generation and execution? Can I generate some code, run that code, and get the result of running it from my Haskell program?
10:08:30 <pikajude> :/
10:09:24 <cocreature> glguy: it is! we provide bindings to LLVM’s ORC JIT. you can find a minimal example here https://github.com/llvm-hs/llvm-hs-examples/blob/master/orc/Main.hs (which, as I’ve just realized, still needs to be updated for 4.2)
10:10:07 <cocreature> glguy: stephen diehl also has a translation of the offical LLVM tutorial to llvm-hs which builds a compiler, repl and a jit for a small language
10:11:03 <cocreature> glguy: here’s the link to that tutorial https://github.com/llvm-hs/llvm-hs-kaleidoscope
10:11:14 <glguy> Thanks!
10:12:00 <cocreature> afaik accelerate-llvm which is the main backend of accelerate these days also uses llvm-hs for runtime code generation
10:16:51 <amf> anyone have an example of using pipes-attoparsec with folding over a file? i see the foldAll function, but im not sure how to combine that with my attoparsec parser
10:20:19 <cocreature> amf: typically you would just use "parsed". can you be a bit more specific in what you are trying to do?
10:21:50 <hseg> Question: Better way of writing init (tails xs) >>= \xs@(x:_) -> map (x+) xs ?
10:22:38 <hseg> i.e. get all possible sums of two elements of xs, taking into consideration the commutatitvity of +
10:23:20 <lyxia> > let xs = [1,2,3] in [x+y | x : xs <- tails xs, y <- xs]
10:23:22 <lambdabot>  [3,4,5]
10:23:44 <lyxia> > let xs = [1,2,3] in [x+y | xs@(x : _) <- tails xs, y <- xs]
10:23:46 <ClaudiusMaximus> [ x + y | x:y:_ <- tails [1,2,3] ]
10:23:46 <lambdabot>  [2,3,4,4,5,6]
10:24:14 <amf> cocreature: x <- runSafeT $ runEffect $ Pipes.Parse.evalStateT parseLine $ PSP.readFile "/tmp/blah" >-> toByteString -- parseLine is my custom parser. where in there would i make the resulting data structure (the on file format is not what i want out of it)
10:24:26 <mniip> hseg, with the diagonal or without?
10:24:30 <hseg> With.
10:25:05 <ClaudiusMaximus> oops ignore me, misread specification
10:25:19 <mniip> what lyxia said then
10:25:29 <amf> parseLine = Pipes.Attoparsec.parse myRealParser
10:25:48 <mniip> > let xs = [1,2,3] in [(x, y) | xs@(x : _) <- tails xs, y <- xs]
10:25:50 <lambdabot>  [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
10:26:45 <ClaudiusMaximus> not sure i like the shadowing there
10:27:32 <lyxia> yeah  y <- ys  looks better
10:27:45 <hseg> That's basically tails xs >>= \xs@(x:_) -> map (x+) xs. Only advantage is making use of fail=mempty in lists, right?
10:28:09 <lyxia> and the looks of list comprehension
10:28:31 <hseg> Sure. Don't like list comprehension that much, but ok.
10:29:43 <lyxia> otherwise you're right, it's not much of a change
10:29:44 <hseg> Thanks
10:30:21 <hseg> Didn't like the implicit use of fail, but then I remembered that fail=mempty here, so it's not that bad.
10:31:01 <hseg> Anyway, problem is a bit moot, since I need to get unique instances anyway. So this only gives me a constant-time speedup.
10:37:29 <cocreature> amf: so are you trying to parse a single result or do you want to get a stream of parsed results?
10:39:40 <amf> cocreature: i want to turn my file (which is just lines of data) into a single data structure after the parse. if i replace the parseLine above with foldAll i can get it to walk over the file, but i dont know how to parse then pass that to foldAll
10:40:29 <cocreature> amf: what’s wrong with the code you showed above?
10:40:57 <cocreature> I don’t think foldAll is what you’re looking for here
10:41:00 <what_the> Trying to encode this example(http://lpaste.net/2131535480947212288) in Haskell using LiquidHaskell. Have tried to do so but have failed. “computation” function should type check iff “canFlowTo (join (join l0 lo) l1) L” is “True”. “L” represent a label(i.e. an empty list, []) as defined in the following code snippets and “join" and “canFlowTo” must lift into refinement 
10:41:06 <what_the> logic(measure.)
10:41:15 <cocreature> foldAll is for interoperability with the foldl package
10:42:17 <et09> i'm trying to install taffybar via git - got all the way to runhaskell Setup install - but that throws: <command line> cannot satisfy -package-id (newline) HStringTemplate-0.8.6-KW4yEnae1XMGp4WVxw4zRh
10:42:34 <et09> however HStringTemplate-0.8.6 is installed
10:42:45 <amf> cocreature: http://lpaste.net/1384031701939781632 theres all the code. left a comment at the bottom
10:44:21 <cocreature> amf: oh so you want to parse a stream of AccountLines and then fold over those?
10:44:54 <amf> cocreature: yep. my brain is having trouble gluing different parts of pipes together
10:45:09 <cocreature> amf: I’ll make an example, give me a minute
10:45:25 <amf> this file is large and im trying to doing a streaming parse because i need to keep memory constant
10:50:39 <zomg> cocreature, ongy, glguy, [exa], sorry had to run shortly after I asked, but your responses give something to work with :) thanks
10:53:46 <cocreature> amf: try https://gist.github.com/cocreature/f08cef567027f3aae1602bec313baa17
10:59:13 <amf> cocreature: that has the desired result, but the memory usage is still 200+ MB. im guessing thats due to the print at the end
11:00:41 <cocreature> amf: try profiling. I would guess x is not sufficiently strict but I don’t have time to work through it atm to figure out where exactly the problem is
11:01:26 <cocreature> amf: deepseqing the accumulator in x might be helpful for debugging purposes
11:01:36 <amf> i can take it from here. thank you for the help!!
11:02:44 <cocreature> amf: also _xxx and _accountCPCodes could grow quite large if you’re not overwriting entries but just inserting new entries
11:02:47 <muzzle> hi, if I have a stack multi-package project with an application in one package and a library that it depends on in an other package, do the GHC flags in the apps cabal file apply to the library?
11:03:18 <torstein> Is it possible to make a division function with the type class constraint that inputs can be any Num while output can be any Fractional? Since there's no autocast, the input must possibly be converted from Int etc. to something else
11:03:29 <zomg> [exa]: it was related to http reqs btw, where it could fail with a HttpException, JSONParseException, or the JSON payload could have an error message in it, so was considering ways of unifying the handling
11:03:41 <cocreature> amf: and try the strict versions of IntMap and Map
11:04:19 <paolino> anyone using machines for data processing ?
11:04:40 <muzzle> torstein: I don't think so
11:05:16 <paolino> (the machines library)
11:05:42 <amf> cocreature: ha. strict map got it from 200MB to 80MB.
11:06:17 <amf> and now ARR_WORDS is dominating. should switch to text
11:06:24 <muzzle> torstein: you could probably do it with an Integral constraint
11:07:00 <shapr> OpenDNS is blocking lpaste.net now :-(
11:08:16 <muzzle> torstein: it also doesn't really make sense in some cases
11:08:19 <torstein> muzzle: Floats and Doubles are not part of Integral
11:09:27 <[exa]> zomg: in that case exceptions are probably reasonable (json/html combination dominates the ugliness anyway :] ). I'd actually go with something that returns (Result, [ErrorDescription]), getting a complete list of errors and possible partial result is good for debugging
11:10:13 <zomg> [exa]: yeah, that's what I was thinking as well. In case it's an HttpException, in some instances I might want to retry the request, so being able to separately handle the different exception types would seem to make sense
11:10:29 <[exa]> do you really want to combine http error messages and possible json error messages?
11:11:26 <zomg> well, it actually seems most of the time the json error occurs because of a server error
11:11:54 <zomg> occasionally the server error results in a complete timeout which produces an HttpException, but if it's not a timeout but a 502 or something, it looks like it causes a JSONParseException
11:12:09 <[exa]> oh, internets.
11:12:25 <zomg> so in both cases they're a failure of the api endpoint in some fashion
11:12:44 <[exa]> oh, you're the client side, now I get it
11:12:50 <zomg> while the error message in the payload could occur due to invalid parameters in the request, although I'd say it's unlikely since most of the reqs are going to be written into the code
11:13:12 <locallycompact> Can someone please spell out how to derive Show for this 'Some' type. I have been going round in circles for hours https://gitlab.com/snippets/1664808
11:14:12 <zomg> I could probably change it so it never attempts to even parse the JSON unless it's a 2xx :)
11:14:24 <zomg> that would most likely eliminate the chance of it receiving a json parse error
11:14:47 <zomg> (unless the api really does something dumb, which I wouldn't necessarily put beyond them)
11:14:55 <hseg> Question: How do I write traverse print $ map (\x -> map ($x) fs) xs type-safely? (Morally, fs :: [forall r. Show r => a -> r])
11:14:58 <[exa]> zomg: unless there's actual parse error, which, on the internet, will be. :]
11:15:08 <hseg> (but of course this is forbidden)
11:15:53 <hseg> I *could* cast everything to strings by postcomposing all elements of fs with show, but that gives ugly results and is annoying.
11:16:00 <zomg> [exa]: yeah, I think I might just clump http and json errors together and the error-in-payload scenario will just be another type of exception. That'll probably give me the necessary granularity without making it annoyingly complicated to deal with
11:16:40 <shapr> @seen ganesh
11:16:41 <lambdabot> gAN3$|-|
11:16:43 <shapr> :-(
11:16:55 <shapr> @seen heffalump
11:16:55 <lambdabot> heFf4Lump
11:16:57 * shapr sighs
11:17:02 <[exa]> zomg: anyway, see who should receive the error message. Exception should be a hint of what to do next, either a machine-readable retry hint, human-readable description of what must be fixed, or a clear statement that it will not do.
11:17:06 <hseg> What's @seen?
11:17:25 <geekosaur> it's being edit-corrected to @leet
11:17:39 <geekosaur> shapr was hoping for a command that shows the last time someone was active in channel
11:17:42 <shapr> I think @seen went away a long time ago
11:17:44 <sm> stupid bot :)
11:17:50 <zomg> [exa]: yeah, right now it doesn't really need to do anything but the errors are causing my timer to stop repeating so need to address it in some way before going further :P
11:18:21 <shapr> speaking of which, I wrote a bug into the very first lambdabot plugin (@quote) and I still haven't fixed it.
11:18:28 <geekosaur> yes, it was buggy and a severe memory leak iirc
11:18:32 <zomg> anyways think I'll see where the exceptions lead, I can always change it later - thanks
11:18:53 <lyxia> locallycompact: You can't derive show for Some
11:20:27 <hseg> Anyway, any ideas for my multimap :: [forall r. Show r => a -> r] -> [a] -> [String] ?
11:20:30 <locallycompact> ah I got this to work data Some f = forall b. Show (f b) => Some (f b)
11:20:30 <locallycompact> deriving instance Show (Some a)
11:28:48 <daantjie> Is it justifiable, when implementing a function, to "just follow the types"? E.g. using GHC's holes to figure out what to place there based on type. What confidence can one have that the resulting definition is correct?
11:30:07 <lyxia> It's quite usual to do.
11:31:06 <daantjie> True; but do you have to go away and prove it correct after?
11:31:42 <Gurkenglas_> It reduces the belief you should have in compilation implying correctness
11:32:46 <Gurkenglas_> If you write code manually and it happens to compile, that's evidence it's correct; if you tweak code until it compiles, it's no wonder it compiles. Incorrect code is more unlikely that correct code to be tweaked into compilation, but still, some confidence is lost.
11:33:08 <Gurkenglas_> *unlikely than correct code
11:33:14 <daantjie> I see.
11:34:11 <daantjie> So if you wanted to be sure it was correct, you'd need to come up with a proper proof -- which might be easier than figuring out the implementation.
11:34:53 <lyxia> you have to come up with the implementation either way
11:35:04 <Gurkenglas_> But if you have no intuition for the code you're writing anyway, and can't be bothered to find it, go ahead and follow the types, it's efficient compared to other forms of tweaking code until it compiles.
11:36:13 <daantjie> Yeah; I thought of this when I was reading the wikibook chapter on the 
11:36:36 <daantjie> * Cont monad, and the intuition for the types was pretty hard to get. 
11:36:53 <hseg> Question: How do I write traverse print $ map (\x -> map ($x) fs) xs type-safely? (Morally, fs :: [forall r. Show r => a -> r])
11:36:56 <hseg> I *could* cast everything to strings by postcomposing all elements of fs with show, but that gives ugly results and is annoying.
11:39:31 <Gurkenglas_> Don't you mean "fs :: [exists r. a -> (Dict (Show r), r)]"?
11:41:05 <Gurkenglas_> (Otherwise, I could choose Void for r.)
11:41:19 <hseg> Oh, right.
11:49:06 <hseg> Gurkenglas_: So... Any ideas?
11:49:53 <hseg> I know that once I've wrapped everything, I can unwrap them and show them. But that's heavyweight.
11:52:18 <lyxia> why not just return the shown String
11:52:31 <sm> shapr: aha, it's karma man
11:53:34 <lyxia> hseg: fs :: [a -> String]  ?
11:54:04 <hseg> Because that requires postcomposing everything by show and gives ugly results (" everywhere)
11:56:16 <lyxia> you're going have to use show at some point, and it's the only thing you can do with such an existential type anyway
11:56:30 <lyxia> as for ugliness I don't understand the point
11:56:54 <lyxia> are you referring to how the REPL prints results?
11:56:57 <hseg> I know, but there's a difference between writing map (show.) [f1,f2,f3,...] and [show.f1,show.f2,show.f3,...]
11:57:40 <lyxia> you can have a custom "cons" operator that composes with show while appending to the list
11:57:51 <hseg> ... You're right.
11:58:44 <hseg> And if I'm willing to cope with nested tuples, I could also use &&& followed by a final show
11:59:01 <lyxia> I admit it's not as good as "map show"
12:01:45 <lyxia> Another way is to put the functions in a tuple and use some Generics.
12:02:33 <lyxia> though it's annoying that tuples of sizes larger than 7 are not already Generic
12:03:01 <bcq> anyone willing to try reproducing this error: https://gist.github.com/brezal/691a961f5388dd4f2d20362c304a6ccc
12:03:50 <iqubic> How do GADTs work?
12:05:19 <bcq> iqubic: you might find this useful: https://wiki.haskell.org/GADTs_for_dummies
12:06:14 <MitchellSalad_> they work like magnets
12:06:25 <hseg> lyxia: yeah.
12:12:52 <iqubic> GADTs are really simple
12:12:59 <iqubic> Are they useful at all?
12:13:22 <ReinH> Yes.
12:13:49 <iqubic> Where are GADTs used?
12:17:37 <Tuplanolla> Do you accept "everywhere"?
12:17:52 <iqubic> Actually, I'll go look up GADTs on my own
12:19:21 <ggVGc> GADTs are the best when trying to get a decent breakfast
12:21:41 <mekeor> i'd like to use GPIO on a raspberry pi (v3) with haskell. can you recommend any specific package?
12:21:52 <shapr> ggVGc: wait what?
12:22:18 <shapr> mekeor: Have you tried system.RaspberryPi.GPIO?
12:22:40 <shapr> you think I'm joking, right? https://hackage.haskell.org/package/HPi
12:23:27 <mekeor> shapr: no, i didn't try yet. but there is also:
12:23:31 <mekeor> @hackage hpio
12:23:31 <lambdabot> http://hackage.haskell.org/package/hpio
12:23:37 <mekeor> @hackage gpio
12:23:37 <lambdabot> http://hackage.haskell.org/package/gpio
12:23:45 <shapr> mekeor: oh wow, have you tried them?
12:23:46 <mekeor> @hackage system-gpio
12:23:46 <lambdabot> http://hackage.haskell.org/package/system-gpio
12:23:56 <mekeor> no, that's why i'm asking
12:23:59 <mekeor> ;) :D
12:24:07 <shapr> ah, so you want to add your own so you can contribute to the confusion?
12:24:13 <mekeor> @hackage wiringPi
12:24:14 <lambdabot> http://hackage.haskell.org/package/wiringPi
12:24:22 <mekeor> :P
12:24:39 <shapr> I wish I could easily list packages that match a string or category, and have them ordered by last updated
12:24:50 <byorgey> for a minute I thought you were just illustrating how the @hackage command doesn't care whether its argument is a valid package name or not
12:24:54 <byorgey> but nope, those are all real packages =P
12:25:04 <mekeor> hahah :D
12:25:16 <mekeor> shapr: you're joking, right?
12:25:29 <mekeor> https://hackage.haskell.org/packages/search?terms=gpio
12:25:32 <hseg> I have an IntSet and want to find the least positive integer not in the set. Turns out the structures are strict and so findMin . difference (fromSet [0..]) won't do the job.
12:25:48 <shapr> mekeor: wait, when was that added?!
12:25:49 <shapr> that's great!
12:26:03 <shapr> I've been complaining about that for years, I guess somebody got tired of hearing it.
12:26:36 <hseg> Then again, I could use \s -> minimum $ filter (flip notMember s) [0..]
12:26:38 <mekeor> shapr: i think that has been existing for quite some time
12:26:50 <geekosaur> hackage2 took a while to actually get deployed, but it did get deployed
12:26:51 <shapr> In that case I'll just mark myself as unobservant.
12:27:02 <hseg> That'd be slow, but I don't care too much about efficiency.
12:27:39 <Tuplanolla> I don't see the sorting options.
12:28:46 <hseg> And of course, s/minimum/head/ due to strictness
12:29:08 <Tuplanolla> Where are they, mekeor?
12:30:05 <mekeor> Tuplanolla: who are they?
12:30:59 <EvanR> hseg: silly set structures, they shouldnt have included an efficient complement! :)
12:31:17 <lambdamu_> people who pass struct by values in their c apis and don't document pointer lifetimes should be banished from using computers
12:31:30 <Tuplanolla> Where did you find them, shapr?
12:31:46 <hseg> EvanR: :)
12:31:49 <kadoban> hseg: Can't you just use toList and take it element by element?
12:31:51 <shapr> Tuplanolla: I only saw the "date last uploaded" from the search box, not the sorting by updated date
12:31:59 <kadoban> Oh positive integer ...
12:32:04 <shapr> I guess I have to find the source for hackage2
12:32:08 <shapr> how often are updates deployed?
12:32:34 <kadoban> hseg: splitMember and then toList?
12:32:58 <kadoban> Or just split I guess is good enough
12:33:53 <hseg> kadoban: But I want the minimum of the *complement* of a finite set, which will be infinite.
12:35:20 <EvanR> seems like you want some kind of span
12:35:33 <EvanR> take while consecutive, addd 1
12:35:56 <hseg> Ended up going with head $ filter (flip I.notMember d) [0..]
12:36:12 <kadoban> hseg: Yes but can't you just look for the first gap? If you already have the IntSet I'm not sure you can do a lot better. You could I think if IntSet had a O(1) size ...
12:37:15 <hseg> I have the IntSet, and don't know how it grows - hopefully O(n^2) if my suspicions are correct.
12:38:30 <EvanR> just looking for the first gap is the whole problem
12:38:58 <EvanR> possible solution, store the gaps in an intset instead!
12:39:16 <kadoban> I kind of wonder if IntSet isn't the best thing you could possibly have. Are you doing this operation often? It's unfortunately a bit inefficient in an IntSet, though I guess not as bad as it could be.
12:39:19 <EvanR> or a Map
12:39:58 <kadoban> If it had a O(1) size thing you could do it in O(lg n) instead of O(n) worst-case, which would be pleasant. Though I'm not sure it matters for your thing of course.
12:40:02 <EvanR> when you insert into the IntSet (or if you would have), split or delete a gap by modifying the Map
12:40:50 <EvanR> (what is a O(1) size)
12:41:07 <kadoban> EvanR: If you could check the size of an IntSet in O(1)
12:41:17 <EvanR> oh
12:41:40 <kadoban> Or at least O(lg n) I suppose would be enough, though I'm not sure how you'd end up with O(lg n) size check.
12:41:52 <kadoban> Or ... no that'd give a different bound. Whatever.
12:41:56 <EvanR> you can easily track the size with a counter
12:41:57 <hseg> Nope. Basically what I'm doing is greedily constructing a Sidon set.
12:42:29 <hseg> (Sidon set = differences between pairs of elements are unique)
12:43:07 <kadoban> Ah, sounds fun
12:43:11 <hseg> So I'm keeping track of which differences I've accounted for already, and adding another element that contributes the least unaccounted for difference.
12:43:44 <hseg> For actual Sidon sets, the set of differences is O(n^2)
12:45:20 <kadoban> Ah so you're definitely doing the "what's the minimum I don't have?" check over and over then. But ... aren't the answers to those queries a strictly increasing series? So I think it doesn't matter if a particular one takes a while, as long as you don't start looking for different of 1 and then 2 and then 3, etc. every time you check.
12:46:11 <hseg> Yeah, I could cache the last added minimum and start searching from it+1
12:47:17 <hseg> Don't know how much that will help. Don't have very big test cases - planning to test n=30 tops.
12:48:31 <kadoban> Oh, then it probably doesn't matter what you do, heh.
12:50:13 <hseg> Yeah
12:59:33 <pgiarrusso> A somewhat theoretical question: some Haskell packages (like deepseq/criterion) talk about evaluating expressions to weak head normal form, or to normal form. But I guess that even "normal form" is weak
12:59:56 <pgiarrusso> because Haskell never evaluates the body of a lambda abstraction.
13:00:06 <pgiarrusso> do I miss something?
13:01:55 <kadoban> Are you asking if "normal form" exists in haskell concepts I guess? Unless I'm missing something, sure. It's just everything that's fully evaluated, couldn't be evaluated any farther.
13:02:07 <cocreature> pgiarrusso: you’re right that haskell won’t evaluate the body of a lambdas.
13:03:12 <pgiarrusso> cocreature: thanks
13:04:00 <hc> unless you do something like let a = [1, (\a -> a + 1) 2]
13:05:15 <mauke> that still doesn't evaluate under the lambda, though
13:07:12 <Sylph-DS> Hello, I have a sorting function that when I run it in ghci will return all of the elements in order as it should, but then before actually terminating the list with the ']', it freezes. Anybody have any idea what could be going on?
13:07:54 <pgiarrusso> kadoban: I just suspect that Haskell *never* produces normal forms, only *weak* normal forms, and whenever documentation says "normal form" it means "weak normal forms"
13:08:13 <Sylph-DS> Normally when something freezes I think of an infinite recursion, but then if my function infinitely recursed at any point it shouldn't return anything at all, right?
13:08:21 <EvanR> haskell does produce normal forms, the NFData class is designed for this purpose
13:08:30 <EvanR> NF stands for Normal Form
13:08:33 <kadoban> pgiarrusso: Why wouldn't (3 :: Int) be in normal form for instance?
13:09:23 <EvanR> you can also carefully construtor your data in normal form to avoid having to use NFData
13:09:25 <cocreature> Sylph-DS: Haskell’s lazyness allows it to produce parts of your result even if producing the rest results in an infinite loop
13:09:28 <pgiarrusso> kadoban: OK, let me amend to "Haskell evaluation only produces weak normal forms" (some of which happen to be normal forms)
13:10:01 <kadoban> > [1, 2, 3] ++ undefined
13:10:03 <lambdabot>  [1,2,3*Exception: Prelude.undefined
13:10:10 <cocreature> pgiarrusso: which definition of “normal form” are you working with here?
13:10:23 <EvanR> haskell evaluation only produces forms... some of which are weak head normal forms... some of which are head normal forms.. some of which are also normal forms :)
13:10:27 <kadoban> Sylph-DS: In haskell, bottom is bottom. So you could instead make a thing that runs forever instead of 'undefined' and put it there, and it'd still give you the first three items of the list.
13:10:42 <Sylph-DS> ah
13:10:43 <kadoban> pgiarrusso: Hm, I'm not sure I follow that, though it could be my own ignorance.
13:10:47 <Sylph-DS> okay
13:10:52 <pgiarrusso> EvanR: reducing to normal forms requires evaluating under lambdas. I believe that NFData's docs (and not only those) are using a debatable definition...
13:10:53 <Sylph-DS> that makes sense
13:10:54 <pgiarrusso> let me post a link
13:11:12 <EvanR> pgiarrusso: functions dont have NFData...
13:11:21 <Sylph-DS> thanks cocreature, kadoban, I think I have some idea where to look now. I guess my algorithm is trying to sort more even though it ran out of items to sort ;)
13:11:34 <pgiarrusso> EvanR: well, they happen to :-)
13:11:35 <pgiarrusso> http://www.cs.cornell.edu/courses/cs6110/2014sp/Handouts/Sestoft.pdf
13:11:51 <EvanR> oh geez
13:12:11 <EvanR> "This assumes that WHNF is equivalent to NF for functions."
13:12:17 <EvanR> for convenience
13:12:30 <EvanR> ignoring that!
13:12:41 <EvanR> NFData does produce normal form of data
13:12:50 <pgiarrusso> well, I don't get that remark indeed
13:12:52 <EvanR> functions are in some sense not data
13:13:18 <pgiarrusso> well, all the difference between normal form and weak normal form is about functions :-)
13:13:50 <EvanR> well, there is still a difference between "form" and "normal form" for not functions
13:14:21 <Sylph-DS> ah, I found it, forgot to properly match an empty-list case
13:14:23 <cocreature> often “normal form” is just used to mean that no further reduction rules can be applied. so whether a normal form needs to evaluates below lambdas depends on your reduction rules
13:14:26 <Sylph-DS> Thanks again!
13:14:39 <EvanR> anyway, i dont see the content of "only" produces _ some of which are also _
13:14:50 <cocreature> so it’s not necessarily wrong to not evaluate below lambdas
13:15:03 <pgiarrusso> cocreature: that's a fair point
13:15:39 <pgiarrusso> EvanR: well, I mean that Haskell evaluation does not try to normalize [\x . 1 + 1, \x .x] further
13:17:08 <pgiarrusso> cocreature: also, it makes less sense to talk about weak head normal form (as people do) if you never reduce under lambdas.
13:17:08 <EvanR> worry about head normal form seems to be a bureaucratic thing, like what affect does it have on programming. its a thing that doesnt matter in haskell it seems
13:17:42 <pgiarrusso> EvanR: not saying that any of you should care
13:17:45 <kadoban> Sylph-DS: Ah weird. Usually that'd crash instead of run forever, though I guess I can think of some ways it'd run forever.
13:17:51 <kadoban> Sylph-DS: Glad you found it.
13:17:56 <cocreature> pgiarrusso: how so? there is still a difference between whnf and nf for everything that’s not a function
13:18:15 <pgiarrusso> using standard mathematical terminology matters as much as calling monads monads :-)
13:18:20 <EvanR> right, "we should not care" is how i understand head normal form
13:18:37 <pgiarrusso> cocreature: yeah but if you drop "weak", drop it consistently
13:18:49 <EvanR> where is weak being dropped?
13:18:58 <vise890> hi all. what are people using for exposing simple web apis ? I'm mainly interested in performance, i don't need anything fancy
13:19:44 <pgiarrusso> EvanR: 'normal form' is what is called 'weak normal form', because it doesn't require reducing under lambdas
13:20:07 <EvanR> im lost, that doesnt seem very true
13:20:15 <EvanR> where is normal form called weak head normal form
13:20:20 <EvanR> or weak normal form
13:20:44 <pgiarrusso> EvanR: my reference is http://www.cs.cornell.edu/courses/cs6110/2014sp/Handouts/Sestoft.pdf (Sec. 6)
13:20:52 <cocreature> it seems like we’re arguing terminology without agreeing on precise definitions which is not very useful
13:21:19 <pgiarrusso> cocreature: http://www.cs.cornell.edu/courses/cs6110/2014sp/Handouts/Sestoft.pdf is for you too then :-)
13:21:54 <cocreature> pgiarrusso: oh I know the definition you’re referring to. but as I’ve said before it’s not the only definition of normal form people use
13:21:56 <EvanR> interesting handout, i never heard of weak normal form
13:22:03 <vise890> also, other question .. i have some weird, old, awful format i need to serialize to, it needs a Spec/Schema to go along with the data to serialize. How could I encode that in the type system as a class? is https://prime.haskell.org/wiki/MultiParamTypeClasses the right direction?
13:22:28 <pgiarrusso> it seems that Haskell programmers only care about weak head normal form (what's normally produced when forcing arguments) and weak normal form (produced through NFData), and drop "weak" from the latter
13:22:40 <cocreature> that’s definitely true
13:22:53 <cocreature> we can’t produce a normal form so why should we care about it
13:23:01 <pgiarrusso> in eager languages one uses just weak normal form :-)
13:24:04 <EvanR> its probably easier to call NFData normal form, because thats what its already written as, and consider the function instance a fluke
13:24:05 <cocreature> I’m still not sure what you are trying to argue for. if we agree that the definition in that paper is the correct one, then NFData is the wrong name
13:24:18 <pgiarrusso> I'm writing a paper and discussing how I use NFData, that's why I have to care
13:24:35 <cocreature> well just reference whatever definition you’re using
13:24:40 <cocreature> problem solved :)
13:24:47 <EvanR> yeah a single side remark about the NFData inconsistency should be enough
13:25:03 <dolio> NFData has an instance for functions?
13:25:04 <Zemyla_> What's the difference between normal form and weak normal form?
13:25:08 <EvanR> ... yeah...
13:25:09 <cocreature> dolio: yep
13:25:26 <cocreature> Zemyla_: seq (undefined : undefined) ()
13:25:32 <pgiarrusso> Zemyla_: weak means "you needn't reduce under lambda"
13:25:39 <cocreature> > seq (undefined : undefined) ()
13:25:41 <lambdabot>  ()
13:25:52 <cocreature> Zemyla_: whnf only evaluates to the top-most constructor
13:25:57 <pgiarrusso> > deepest (undefined: undefined) ()
13:25:59 <lambdabot>  error:
13:25:59 <lambdabot>      Variable not in scope: deepest :: [a0] -> () -> t
13:26:02 <pgiarrusso> darn
13:26:13 <pgiarrusso> > deepseq (undefined: undefined) ()
13:26:15 <lambdabot>  error:
13:26:16 <lambdabot>      Variable not in scope: deepseq :: [a0] -> () -> t
13:26:20 <cocreature> pgiarrusso: a definition that ignores data constructors is hardly a useful definition in Haskell
13:26:35 <Zemyla_> cocreature: Isn't the first one just weak head normal form?
13:26:57 <cocreature> Zemyla: oh I mentally added a "head" to your question, snry
13:26:59 <cocreature> *sry
13:27:07 <EvanR> yes im pretty confused how some of these are all also these, but then "only" these
13:27:14 <pgiarrusso> Zemyla, if you follow http://www.cs.cornell.edu/courses/cs6110/2014sp/Handouts/Sestoft.pdf, "head" is about whether you evaluate arguments to a variable
13:27:28 <cocreature> > Control.DeepSeq.deepseq (undefined : undefined) ()
13:27:30 <lambdabot>  error:
13:27:30 <lambdabot>      Not in scope: ‘Control.DeepSeq.deepseq’
13:27:30 <lambdabot>      No module named ‘Control.DeepSeq’ is imported.
13:27:37 <cocreature> huh
13:27:38 <EvanR> time to just redefine the jargon before first use
13:27:39 <bimodal> Pardon me. I'm having trouble finding a nice collection of practical examples for using traverals from lens. 
13:28:00 <Zemyla> @let import Control.DeepSeq
13:28:01 <lambdabot>  Defined.
13:28:01 <bimodal> It's tough to google on, becuase of how much collision there is and the operators don't carry through.
13:28:21 <bimodal> Are there any go-to resources people use to foist off folks like me?
13:28:38 <Tuplanolla> Microlens has some documentation, bimodal.
13:28:46 <cocreature> bimodal: are you familiar with the Traversable class?
13:29:05 <bimodal> Yes, however I'm constantly surprised by how traversals combine.
13:29:13 <pgiarrusso> EvanR: \x -> 1 + 1 is a weak (head) normal form, but not a (head) normal form (because of the 1 + 1) if that's what you ask
13:29:23 <pgiarrusso> anyway, I got sufficient answers
13:29:24 <cocreature> a Traversal is really just a generalization of Traversable
13:29:27 <bimodal> For example, I've got a [Maybe SomeStruct], I have a SomeStruct -> SomeOtherStruct.
13:29:42 <pgiarrusso> thanks cocreature for reminding me of the generic def. of normal form in this context :-)
13:29:48 <pgiarrusso> I'll shut up
13:29:53 <bimodal> I have so many cases where I need to nip and tuck the underlying structure and it's such a pain to preserve th enothings.
13:30:09 <bimodal> Or even just filtering them out for use in other stuff.
13:30:15 <pgiarrusso> deepseq (undefined: undefined) ()
13:30:15 <pgiarrusso> > deepseq (undefined: undefined) ()
13:30:17 <lambdabot>  error:
13:30:17 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘deepseq’
13:30:17 <lambdabot>        prevents the constraint ‘(NFData a0)’ from being solved.
13:31:07 <pgiarrusso> > deepseq ((undefined : undefined) :: [Int]) ()
13:31:09 <lambdabot>  *Exception: Prelude.undefined
13:31:32 <pgiarrusso> > deepest (\x -> undefined: Int) ()
13:31:34 <lambdabot>  error:
13:31:35 <lambdabot>      • Variable not in scope: deepest :: (t0 -> [a0]) -> () -> t
13:31:35 <lambdabot>      • Perhaps you meant ‘deepseq’ (imported from Control.DeepSeq)error:
13:31:35 <cocreature> yeah it only took us 5 minutes to collectively figure out how to get lambdabot to accept deepseq
13:31:52 <EvanR> > seq ((undefined : undefined) :: [Int]) ()
13:31:54 <lambdabot>  ()
13:32:03 <pgiarrusso> > deepseq (\x -> undefined: Int) ()
13:32:04 <pgiarrusso> > deepest (\x -> undefined: Int) ()
13:32:04 <pgiarrusso> > deepseq 
13:32:06 <lambdabot>  error:
13:32:06 <lambdabot>      • Data constructor not in scope: Int :: [a0]
13:32:06 <lambdabot>      • Perhaps you meant one of these:
13:32:06 <lambdabot>  error:
13:32:07 <lambdabot>      • Variable not in scope: deepest :: (t0 -> [a0]) -> () -> t
13:32:08 <lambdabot>      • Perhaps you meant ‘deepseq’ (imported from Control.DeepSeq)error:
13:32:10 <lambdabot>  error:
13:32:13 <EvanR> > force ((undefined : undefined) :: [Int])
13:32:25 <Tuplanolla> What are you doing?
13:32:57 <cocreature> EvanR: I think you’ve killed lambdabot
13:33:18 <pgiarrusso> > deepseq (\x -> undefined:: Int) ()
13:33:18 <EvanR> @botsnack
13:33:27 <lambdabot>      • No instance for (Typeable a0)
13:33:27 <lambdabot>          arising from a use of ‘show_M53057901779427511864177’
13:33:27 <lambdabot>  *Exception: Prelude.undefined
13:33:27 <lambdabot> :)
13:33:27 <lambdabot>  ()
13:33:42 <EvanR> resurrected
13:33:56 <pgiarrusso> > deepseq (\x -> undefined:: Int) ()
13:33:58 <lambdabot>  ()
13:34:06 <pgiarrusso> OK, shutting up
13:34:06 <nshepper1> Is "head normal form" even a thing that it makes sense to talk about? If you stop at the first constructor why would you not stop at the first lambda
13:36:00 <pgiarrusso> nshepper1 well, descending under lambda is necessary for optimizers (and other sorts of metaprograms)
13:37:00 <pgiarrusso> but no, I agree all of this is irrelevant to most programmers, and will shut up on the topic when questions stop :-)
13:38:01 <Wizek> Hello. I wonder, can something like the following be made to work with lenses so it returns (True, True)? `let l = ((,) <$> _1 <*> _2) in ((1,2,3) ^. l == (1,2), ((1,2,3) & l .~ (4,5)) == (4,5,3))`
13:38:31 <Wizek> without manually defining both the getter and the setter with the `lens` function.
13:41:54 <phadej> Wizek: https://stackoverflow.com/questions/36521208/how-to-make-the-product-of-two-lenses
13:45:31 <Wizek> phadej, That looks like quite what I am interested in, thank you.
13:48:00 <bimodal> I'm just so confused. toListOf (traverse . _Just) does what I expect with a [(Maybe a)]
13:48:40 <bimodal> But a traverseOf (traverse . _Just) fn lstOfMaybeAs doesn't do what I expect at all.
13:49:35 <glguy> bimodal: You'd have to tell us what you expected it to do
13:50:18 <bimodal> Well if I want to  ([Maybe a]) -> [b], I have an a -> b
13:50:42 <bimodal> toListOf gives me a [b]
13:51:10 <bimodal> I thought traverseOf was a way to map over that inside a larger traversal. But it doesn't at all.
13:51:25 <glguy> :t \f xs -> map f (catMaybes xs)
13:51:27 <lambdabot> (a -> b) -> [Maybe a] -> [b]
13:51:29 <glguy> So you're trying to write this?
13:51:43 <bimodal> I would like to throw more lenses in there :)
13:51:49 <bimodal> But yeah in essence.
13:52:10 <hseg> EvanR: kadoban: Problem is moot, since A) My test for sidon-ness was giving false positives and B) The set constructed by my method wasn't Sidon after all (60+2=31+31, but my greedy algorithm didn't take this into account and inserted 60 in a list containing 2,31).
13:52:24 <phadej> bimodal: the important point to understand is that traverseOf and over doesn't change the shape of the thing traversed/set over
13:52:31 <bimodal> Ah.
13:52:43 <bimodal> Oh actually that makes a lot more sense given the context of the types I'm seeing.
13:53:55 <phadej> so if you have fn :: a -> b
13:54:22 <phadej> do toListOf (traverse . traverse . to fn) lstOfMaybeAs
13:55:14 <glguy> doesn't even need to be traverse, folded is enough
13:55:25 <phadej> indeed
13:57:06 <bimodal> Ah, that makes much, MUCH more sense.
13:57:26 <bimodal> phadej: Thank's for phrasing it that way. I just fixed the larger statement that was troubling me.
13:58:13 <phadej> :+1:
14:12:14 <EvanR> funny Void also has a NFData instance
14:12:57 <glguy> Why funny?
14:13:28 <kadoban> Seems funny that you can fully evaluate something that can't have a value.
14:13:59 <EvanR> deepseq is like a refreshing desert of practicality in a oasis of mathematical strictness
14:14:17 <Tuplanolla> Mathematical non-strictness.
14:14:18 <suzu> that's a good thought
14:14:25 <EvanR> dont quote me on that
14:14:28 <EvanR> lol
14:14:30 <suzu> i'm gonna quote you on that
14:14:31 <glguy> It's useful in the same way that Void has a Show instance
14:14:46 <Tuplanolla> What instance doesn't `Void` have?
14:14:50 <EvanR> when you think normal form, you think "has a form whatsosever first"
14:14:50 <glguy> It's easy to provide implementations of these types given that you don't have any values of them
14:15:03 <glguy> and it's quite useful, suppose you wanted to Show an Either Void Int
14:15:04 <nshepper1> I guess deepseq is the same as seq there
14:15:07 <EvanR> right
14:15:14 <nshepper1> Which is the same as absurd
14:15:19 <kadoban> Yeah, it makes sense when you think about it, it's just kind of funny.
14:15:23 <EvanR> when you have Void embedded deep in something, you still want to do stuff
14:15:31 <EvanR> even if it makes no sense
14:16:23 <EvanR> @quote oasis
14:16:23 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:16:34 <glguy> Tuplanolla: Monoid would be on. Any class with Void in a positive position not guarded by a negative one
14:17:21 <kadoban> I wonder if Void is just an instance of everything that's the correct kind then. Is it a Num ?
14:17:32 <glguy> No, it's not a Num, either
14:17:34 <EvanR> its *not* a Monoid
14:18:10 <glguy> kadoban: You can't implement fromInteger :: Integer -> Void
14:18:12 <Tuplanolla> I see it has be in negative position in all the types.
14:18:42 <glguy> It's not enough to be in negative position, you actually have to find a value of it somewhere
14:18:49 <glguy> so having an argument of [Void] wouldn't be enough
14:19:36 <EvanR> head [] isnt an element of Void ? :)
14:19:50 <EvanR> :t head []
14:19:51 <lambdabot> a
14:19:55 <kadoban> I see. That makes a certain kind of sense I suppose.
14:20:12 <nshepper1> It is, but then you might as well just use undefined
14:20:58 <nshepper1> In which case you can give anything an instance of anything by using undefined
14:21:48 <EvanR> anything can be anythinged
14:22:18 <EvanR> Void in haskell is weird
14:22:33 <nshepper1> It's the perfect type
14:24:20 <shapr> I've heard you shouldn't stare it, it doesn't like that.
14:24:34 <Adeon> when you gaze into the void
14:24:37 <Adeon> the void gazes back
14:24:47 <shapr> :t Void
14:24:48 <lambdabot> error:
14:24:48 <lambdabot>     • Data constructor not in scope: Void
14:24:48 <lambdabot>     • Perhaps you meant one of these:
14:24:52 <EvanR> :k Void
14:24:54 <lambdabot> *
14:25:50 <EvanR> its like a black hole in the type universe
15:18:58 <johnw> EvanR: isn't it more of a white hole?
15:19:35 <EvanR> theres Void -> a, but it never really outputs anything
15:20:09 <johnw> a black hole takes in all things, but there are no functions a -> Void
15:20:11 <EvanR> a -> Void... works in haskell
15:20:14 <johnw> lol
15:20:50 <EvanR> so a -> () is the black hole
15:20:54 <johnw> yeah
15:20:55 <johnw> that's what I was thinking
15:21:11 <johnw> takes in all types, erases all information
15:27:36 <mniip> HawkingCallStack => a -> ()
15:28:45 <Tuplanolla> Coloring holes takes a certain degree of madness only physicists used to have.
15:38:26 <joncfoo> Does anyone know the motivating factor behind Hasql.Params being an instance of Contravariant?
15:39:17 <joncfoo> err, Hasql.Encoders.Params and Hasql.Encoders.Value
15:39:34 <Disavowed> Anyone have any recommendations for emacs plugins for Haskell? I guess code completion would be incredibly useful while I'm starting out, but other than that, I don't really have any requirements. 
15:57:35 <lambdamu_> Disavowed: The only reasonable choice is intero or dante
16:00:47 <Disavowed> lambdamu_: I'm so glad you intervened - I just uninstalled haskell-mode and was about to install ghc-mod
16:24:13 <nshepperd_> joncfoo: so that you can build encoders out of encoders i guess
16:26:45 <nshepperd_> Why not be a contravariant functor
16:29:05 <threshold> if i wanted 10 random characters, which library would i use besides random?
16:29:20 <erisco> cat
16:29:30 <TommyC> threshold: How random does it need to be?
16:29:32 <zachk> threshold, Data.Char
16:29:40 <zachk> perhaps...
16:30:33 <threshold> i think Data.Char will do
16:34:57 <torstein> Is anyone familiar with cyclic definition errors in accelerate? http://lpaste.net/356384
16:55:23 <EvanR> generated non trivial C code with haskell code </success baby>
17:04:58 <EvanR> ah lpaste... bad gateway?
17:05:23 <EvanR> the worst is when it loads the form, but then doesnt accept a post
17:05:33 <EvanR> its like "haha tricked you into thinking i was functional"
17:06:06 <EvanR> http://lpaste.net/356385
17:07:43 <EvanR> you can write haskell in any language!
17:17:24 <boj> vvintnbcbfvkkttvejejnhkulhceitkddtbiblgigfku
17:17:38 <boj> oops, sorry. yubikey'ed you all
17:17:48 <EvanR> a likely story
17:17:53 <MP2E> haha
17:21:39 <suzu> Disavowed: if you're using spacemacs, the haskell layer is great
17:21:47 <boj> anything more random than that would be my 2yo daughter :)
17:21:57 <suzu> plays nicely with stack and everything
17:21:59 <suzu> make sure to set the completion backend to intero, of course
17:34:40 <glguy> At least in the development version of spacemacs you can use dante now in the haskell layer
17:50:26 <ReinH> glguy: oh really? I should try that.
18:10:58 <Disavowed> suzu: I've heard good things about Spacemacs. I think you've sorted my afternoon for me. Thank you!
18:11:08 <codygman> I frequently need something like a map with a lookup function that uses isInfixOf rather than (==), are there any packages that do this already? I typically just use an association list and right "ilookup" myself.
18:12:14 <suzu> Disavowed: i use it, its loads better than vanilla emacs IMO
18:12:29 <suzu> i was also a vim user previously so it's helped a ton in the transition
18:16:12 <jared-w> codygman: would it not be easier to just rewrite the lookup function for Data.Map itself?
18:16:54 <geekosaur> only fi you know which part to index...
18:17:30 <codygman> jared-w: I'm not sure
18:18:28 <erisco> :t isInfixOf
18:18:29 <lambdabot> Eq a => [a] -> [a] -> Bool
18:18:46 <erisco> > isInfixOf "ll" "hello"
18:18:48 <lambdabot>  True
18:18:53 <erisco> > isInfixOf "ll" "llo"
18:18:55 <lambdabot>  True
18:19:09 <erisco> does it just mean one is a sub string of the other?
18:19:47 <erisco> I don't see how Map helps you here
18:19:50 <jared-w> yeah. It means one string is contained completely inside another.
18:20:32 <jared-w> What it seems that he's wanting is a <Key,Value> container where the key is itself and all of its subsets
18:20:48 <erisco> substrings
18:21:02 <jared-w> typo, m'bad
18:21:29 <erisco> :t filter . isInfixOf
18:21:30 <lambdabot> Eq a => [a] -> [[a]] -> [[a]]
18:21:40 <codygman> jared-w: I didn't think of the approach of generating a value for all subsets. I kept thinking in terms of overriding the lookup
18:21:52 <codygman> erisco: I think I used find
18:21:53 <erisco> anything wrong with just a list?
18:21:55 <codygman> :t find
18:21:56 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
18:22:05 <erisco> sure, that gives you the first one
18:23:24 <codygman> The problem I had was someone sent me a list of filenames, someone else sent me a list of filenames that were different but contained substrings of the first, and I had the values which corresponded to the second set of filenames. I needed to zip the values from that second set to the first list of filename.s
18:24:10 <glguy> The Map can help a little bit with splitLookup
18:24:21 <codygman> It was something I either needed to do manually for 100 or so items or write something up as quickly as possible. It didn't take me too long to write something, but I want to get faster at it otherwise I can't justify avoiding doing it manually ;)
18:24:32 <c_wraith> could you use a suffix trie?
18:24:42 <glguy> but it's probably better to checkout an actual prefix trie
18:25:06 <codygman> c_wraith, glguy: suffix trie/prefix trie sound like what I might really be wanting
18:25:09 <c_wraith> I thought suffix tries were more designed for this sort of search
18:25:16 <c_wraith> but maybe I'm recalling wrong
18:25:19 <erisco> but it is neither prefixes or suffixes
18:25:34 <glguy> Oh, yeah I missed the Infix part
18:25:41 <Disavowed> suzu: This sounds encouraging. Did you find it easy to customise colours and general appearance? 
18:25:43 <c_wraith> suffix trie still works
18:25:49 <c_wraith> You just do the search online
18:26:10 <c_wraith> "if I add this character, how many leaves are there now?"
18:26:52 <c_wraith> It's what makes suffix tries nice for completion suggestions
18:27:03 <erisco> Check if a string {\displaystyle P} P of length {\displaystyle m} m is a substring in {\displaystyle O(m)} O(m) time
18:27:12 <erisco> according to the wikipedia article on suffix trees
18:28:01 <erisco> I don't get how, so I'll have to read it sometime
18:28:25 <c_wraith> basically, if you don't run out of trie, you've got a substring. :)
18:28:56 <c_wraith> It's only checking for suffixes if you're checking that you're at a leaf of the trie when the string ends
18:30:18 <halogenandtoast> if you had a team of people slightly interested in Haskell, but not entirely familiar, would you write your imports like this: import Database.Persist.MySQL (MySQLConf , createMySQLPool , SqlBackend , myConnInfo , myPoolSize , runSqlPool , runSqlConn , printMigration , SqlPersistT , selectFirst , Entity(..) , (==.))
18:30:54 <c_wraith> halogenandtoast: for non-operators I'd probably use a named import, and only list imports explicitly for operators
18:31:16 <erisco> I guess for each character you can point to each occurrence in the string
18:31:20 <halogenandtoast> c_wraith: by named import, do you mean qualified?
18:31:42 <c_wraith> halogenandtoast: not necessarily.  qualified is independent of named
18:32:22 <c_wraith> halogenandtoast: qualified means you can *only* access it via the name.
18:32:26 <halogenandtoast> c_wraith: I see, I did not know you could do that.
18:32:37 <erisco> but then you'd have arbitrary branching, so that can't be it
18:32:40 * erisco *shrugs*
18:32:47 <halogenandtoast> c_wraith: thanks I'll try that
18:33:05 <halogenandtoast> well with qualified since I don't like the idea of importing it both named and unnamed
18:33:09 <c_wraith> halogenandtoast: nothing wrong with doing it qualified, of course. :)
18:35:56 <erisco> ah, okay, you're just splitting the string at each character and inserting those separately, yes? that sounds good
18:36:22 <Lokathor> is the sentence "haskell types don't exist at runtime" true? Or do you need to put ", unless you use extension X" after it or something like that?
18:36:39 <c_wraith> Lokathor: they never exist at runtime.
18:36:57 <erisco> existential type classes
18:37:02 <c_wraith> Lokathor: but...  values automatically derived from types can exist at runtime. :)
18:37:15 <glguy> No, existentially quantified types don't cause types to exist at runtime
18:37:23 <erisco> GADTs
18:37:30 <glguy> No, those don't cause types to exist at runtime
18:37:33 <c_wraith> Lokathor: you can think of a type class as a function from type -> value that the compiler solves for you.
18:37:34 <erisco> well, what are we qualifying as a type existing
18:38:04 <c_wraith> Lokathor: so there are cases where the choice of type can cause a particular value to exist at runtime.
18:38:41 <jared-w> A simple example, I believe, is "Either a | b"?
18:39:23 <c_wraith> erisco: a type "exists at runtime" (if you believe that phrase to even be coherent) if a value carries a tag indicating what type it is.
18:39:41 <glguy> In that case Typeable is effectively that
18:39:53 <c_wraith> Well..  Dynamic is closer
18:40:10 <c_wraith> But even then it's not the same.
18:40:37 <erisco> meh, it seems as you shine more light on it it makes less and less sense
18:40:42 <c_wraith> Dynamic isn't "the type is part of the value".  It's "we have two independent values, one of which was derived from the type of the other"
18:40:48 <Lokathor> Well for example, Java has types that do exist at runtime, and even though you can cast a value up it's inheritence tree for example, when you go to cast it back down it's actually checked and can throw errors if you do it wrong, and such
18:40:59 <c_wraith> But the two values can be moved away from each other.
18:41:08 <c_wraith> And you can lose the connection between them.
18:41:21 <EvanR> dont shine light on existence
18:41:27 <c_wraith> For me to say that the type exists at runtime, it must be inseparable from the value.
18:41:34 <glguy> Lokathor: Haskell doesn't have language support for that sort of checked cast
18:41:50 <glguy> You have to simulate it by carrying along a value you trust and then using an unsafe coercion
18:41:55 <erisco> but I understand it to be the question of whether extra data exists and is used at runtime which can be vaguely attributed to "making the types work"
18:41:56 <jared-w> As well as it shouldn't. Checked casts exist for entirely different reasons than something Haskell would care about
18:41:58 <Lokathor> I'm satisfied with this answer and will proceed to write my "minimal primer" using the above mentioned sentence
18:42:00 <EvanR> Dynamic is essentially what java is doing
18:42:00 <erisco> like runtime type checking
18:42:56 <EvanR> thanks to smart constructors, you cant get an invalid Dynamic
18:43:30 <c_wraith> EvanR: but you can take a Dynamic apart, getting a typerep and a value whose type is unknown.
18:43:38 <c_wraith> EvanR: you can't do that in java
18:43:59 <iqubic> What is impossible in Java?
18:44:01 <EvanR> now it sounds like types-at-runtime requires the existence of proper existential types?
18:44:12 <EvanR> i.e. the lack of types at runtime
18:44:17 <EvanR> like you cant have light without shadow or something
18:44:23 <EvanR> (something silly)
18:44:39 <c_wraith> EvanR: I'm of the opinion that "types-at-runtime" is nonsense.  You have tags at runtime.  To have those, all values must have a tag for that purpose.
18:44:42 <erisco> what does it mean for a value to exist at runtime, actually
18:44:44 <nshepperd> suffix tries are actually for infix queries. a normal trie gives you all prefixes of its contents; a suffix trie is a trie containing all suffixes of its contents. hence prefixes of suffixes = substrings ('infixes'?)
18:44:47 <erisco> seems like a reasonable question as well
18:45:06 <monochrom> runtime types has always been tagged unions --- existential if not all-out dependent sum.
18:45:13 <erisco> we know what a value and a type is just reading the program
18:45:20 <EvanR> "value" isnt really a good word for this
18:45:26 <erisco> but what is this "runtime" and what does "value" and "type" mean there
18:45:55 <erisco> can I ask if values or types exist in the binary?
18:45:58 <c_wraith> erisco: for haskell, use the graph reduction/STG model
18:46:13 <c_wraith> erisco: values are things STG models
18:46:23 <c_wraith> erisco: runtime is when graph reduction is happening
18:46:51 <EvanR> ive seen values defined as a subset of expressions that are fully reduced
18:46:53 <erisco> okay
18:47:03 <erisco> is it the same "value" we're talking about though?
18:47:06 <EvanR> in which case expressions are more fundamental
18:47:20 <c_wraith> erisco: it's the same thing I'm talking about. :)
18:47:36 <EvanR> and we use expressions to talk about types and non-types
18:48:15 <nshepperd> i'm reasonably sure 5 is a value
18:48:28 <c_wraith> nshepperd: if you enabled DataKinds, it's also a type. :)
18:48:33 <EvanR> an expression which is fully reduced
18:49:40 <EvanR> does STG's model know anything about "non-expressions" like byte arrays ?
18:50:25 <EvanR> pointers
18:50:41 <c_wraith> STG definitely has pointers.
18:51:10 <c_wraith> I don't know if it has exactly the ByteArray# primitive, but it's compatible with that idea
18:51:29 <iqubic> What's the difference between DataKinds and GADTs?
18:51:33 <EvanR> pointers as values, or as part of the machinery
18:51:40 <EvanR> guess i should read the paper
18:51:42 <erisco> iqubic, everything
18:52:00 <Axman6> they are unrelated (though can be used together)
18:52:03 <pacak> >  length "DataKinds" - length "GADTs"
18:52:04 <lambdabot>  4
18:52:06 <pacak> iqubic: 4.
18:52:14 <Axman6> pacak++
18:52:17 <jared-w> pacak: (☞ﾟヮﾟ)☞
18:52:17 <c_wraith> iqubic: DataKinds is often used with GADTs, but the concepts are entirely independent
18:52:41 <pacak> iqubic: Or did you meant Levenshtein distance?
18:52:41 <nshepperd> is there a thing like a 'kind' where the options are 'value' or 'type'
18:52:44 * Axman6 wonders if he could make his own iqubic bot, just search wikipedia for random ideas, and ask easily answerable questions about them
18:52:50 <monochrom> STG is going to make a big distinction about "I'm done evaluating this". But you don't want this distinction when discussing "does a 'value' come with its type?"
18:52:58 <nshepperd> (or 'kind', if kinds and types are different?)
18:53:05 <c_wraith> nshepperd: Not yet.  Maybe Dependent Haskell will add that. :)
18:53:08 <monochrom> And STG is not going to track types anyway, so meh.
18:53:16 <Axman6> pacak: also need to consider whether it's case sensitive LD too
18:53:36 <EvanR> now i dont know what a value is *walks down the hall*
18:53:50 * nshepperd looks for more synonyms for 'type
18:54:02 <c_wraith> nshepperd: the next one up has traditionally been called "sort"
18:54:13 <monochrom> You mean you still don't understand that terminology is context-sensitive, after all these years?
18:54:17 <c_wraith> What sort of kind is that?
18:54:25 <nshepperd> aren't sorts kinds of kinds?
18:54:27 <EvanR> i dont know what it means in the current context
18:54:38 <c_wraith> nshepperd: nah, they're types of kinds. :)
18:54:39 <Axman6> eventually, you get to snaps, crackles and pops c_wraith
18:54:40 <EvanR> context sensitive doesnt forgive meaninglessness
18:54:44 <Axman6> >_>
18:54:50 <nshepperd> i'm talking about the thing that distinguishes values, types and kinds
18:55:01 <monochrom> FWIW there are communities outside where "0-ary function" is a thing, and mathematicians can't even agree on whether the natural numbers include 0.
18:55:10 <nshepperd> such that 5 can be poly<that> because of DataKinds
18:55:22 <pacak> In Idris it's value, Type, Type:1, Type:2, etc...
18:55:35 <pacak> Turtles all the way down.
18:55:56 <EvanR> somehow Type2 seems different from "King"
18:56:08 <EvanR> "Kind"
18:56:28 <EvanR> the type universe is cumulative
18:56:44 <nshepperd> what's the sort of 5
18:56:51 <c_wraith> nshepperd: don't know a name for that.  Also, it's sort of incidental that the name 5 is usable as both a value and a type - it's not the same 5.  It's like having a type named () and a value named ().  You can't be polymorphic across them.
18:57:12 <boj> what does one with a type 5?
18:57:14 <c_wraith> nshepperd: 5 doesn't have a sort.  Even if it's a type, it has a kind, not a sort.
18:57:21 <nshepperd> right
18:57:29 <boj> does one do*
18:58:10 <c_wraith> boj: in theory, you can do things like compile-time bounds-checking.  But GHC isn't very good for that as it stands.
18:58:19 <nshepperd> but what if you could!
18:58:32 <monochrom> A cool thing I learned from a real analysis book is that you can always translate between an accumulative tower and a non-accumulative tower.
18:58:34 <c_wraith> I mean, I guess you can, if you use some of the type checker plugins
18:58:38 <erisco> that way chaos lies
18:59:07 <c_wraith> monochrom: do I need to believe in real numbers for that statement to be true?
18:59:57 <monochrom> No, because it's chapter 1 and most real analysis books' chapter 1's are just set theory boot camp.
19:00:05 <c_wraith> ah, good.
19:00:13 <monochrom> But then you need to believe in sets, yeah. :)
19:00:28 <c_wraith> I believe in non-recursive countable sets!
19:00:52 <monochrom> Because sometimes you want the type universe to be larger than a set...
19:00:54 <EvanR> this complexity book introduces sets in chapter 1... for no reason other than to use notation like NP intersect coNP
19:01:17 <nshepperd> relatedly, if 5 the value is different from 5 the type, what about Maybe the type and Maybe the kind
19:01:26 <nshepperd> if TypeInType is used?
19:01:27 <jared-w> EvanR: that makes me hurt inside
19:01:38 <erisco> also different
19:01:43 <erisco> in Haskell the levels are distinct
19:01:48 <c_wraith> erisco: not with TypeInType
19:02:06 <monochrom> No, a complexity book is likely to use sets for more purposed than that.
19:02:15 <iqubic> Axman6: I'm not a bot
19:02:16 <monochrom> s/purposed/purposes/
19:02:40 <EvanR> it doesnt... the book is quantum computing since democritus
19:03:02 <Axman6> classic bot talk
19:03:04 <nshepperd> i don't see how you can explain big-O properly without sets
19:03:06 <c_wraith> nshepperd: yeah, when you have TypeInType enabled, the types of types are types.  So the kind Maybe is the type Maybe
19:03:11 <jared-w> oh hey! Great book. I got it for my quantum computing class and forgot ot actually read it
19:03:15 <erisco> c_wraith, then I don't know what that extension does
19:03:21 <nshepperd> i guess that doesn't stop people from explaining it improperly
19:03:51 <EvanR> i skeptical of most things that "need sets" besides literally set theory
19:04:04 <nshepperd> c_wraith: cool. so with Maybe * and Maybe Int, those are the same Maybe
19:04:19 <jared-w> Usually it's "need convenient set-likey notation because the book was written by PhDs who only think in sets"
19:04:22 <erisco> c_wraith, I thought it just treated kinds as it does types which increases what can be promoted
19:04:27 <c_wraith> erisco: it chops the legs off one side of the level hierarchy so the whole thing ends up in a big muddle pile except the ground floor (values) which somehow survived unscathed
19:04:31 <erisco> so it just enables the same type machinery for kinds
19:04:36 <erisco> not that one becomes the other
19:04:46 <EvanR> the phrase "is in a set" is usually used as a euphemism for "has such and such property"
19:05:15 <jared-w> I wonder what would happen if we used categories instead of sets in those secenarios
19:05:19 <erisco> I don't get how that would work at all... hopefully I can find some docs on that one day
19:05:48 <EvanR> i dont see how thatd work
19:06:29 <monochrom> Scott Aaronson is very funny!
19:06:39 <EvanR> erisco: i started reading this paper mentioned by mniip yesterday: http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
19:06:56 <EvanR> yeah, i LOLd a lot in this book
19:07:06 <jared-w> EvanR: it'd work just fine! Just say "this category of stuff has these properties..." and so on. Just ignore the mathemeticians in the corner crying and you're fine. Sprinkle some hand-wavey pixie dust for good measure.
19:07:09 <mniip> yeah I should read it top-down
19:07:14 <Disavowed>  /lastlog suzu
19:07:15 <EvanR> not everything is a category
19:07:16 <mniip> been picking chunks out of it
19:07:18 <Disavowed> Ooops, sorry
19:07:25 <EvanR> you can trivially make any set of things with a property... a set
19:07:36 <mniip> EvanR, no!
19:07:55 <mniip> let R be a property that the property R is not satisfied
19:08:03 <jared-w> You can trivially write out set notation for a bunch of things with a property, true :p
19:08:11 <nshepperd> if it's already a set you can make it into a set :)
19:08:14 <EvanR> impredicative
19:09:05 <EvanR> youre all right, thus, the program of using sets for this purpose is already in trouble!
19:10:25 <monochrom> Type theory is more structured, yes.
19:11:19 <monochrom> Type theory is strongly typed. (Tautology of The Year.)
19:12:05 <EvanR> erisco: that paper actually begins by explaining the current state of the art in haskell shenanigan extensions
19:12:44 <Lokathor> could (\x -> 2 * x + 1) be fairly called a "function literal"? or would you always call it a lambda
19:13:02 <EvanR> its like, the missing blog post to explain GADTs datakinds fundeps type/data families etc
19:13:12 <jared-w> EvanR: which paper?
19:13:26 <jared-w> oh the eisenberg thesis?
19:13:29 <EvanR> eisenberg-thesis linked above
19:14:21 <EvanR> Lokathor: i could answer that if i knew what "literal" meant... i only know 5 and "foo" are literals
19:15:45 <erisco> okay, seems they really are the same because he explicitly says a variable can range over both
19:17:36 <erisco> so is Haskell dependently kinded? no binders afaik so I guess not
19:18:30 <erisco> oh, yes there is, with the forall
19:19:00 <EvanR> you can have (data)kinds that depend on a type
19:19:45 <erisco> data T where MkT :: ∀ k (a :: k). k → Proxy a → T  that is an example he shows
19:20:27 <erisco> yes, a kind that depends on a type
19:20:37 <erisco> that is what I meant by dependently kinded
19:20:48 <erisco> clearly demonstrated with the forall binder
19:21:14 <joe9> need some advice, please? I have a date time coming in as a series of integers, 2017 is the 1st integer, 6 - 2nd integer, 17 - 3rd integer, and so on for hours, minutes, seconds and milliseconds. I am trying to convert it to UTCTime. Any suggestions, please?
19:21:15 <iqubic> Anyone use ibus here?
19:21:28 <EvanR> thats more that just depending on a type, its depending on a kind, its polykinded
19:21:32 <joe9> It just seems wrong to format a string from all the integers and then using parseTime.
19:22:22 <codygman> any suggestions on this parsec parser?
19:22:23 <codygman> http://lpaste.net/356386
19:22:27 <joe9> I think there might be an easier option. I could try (2017 - 1970) * 365 to get the number of days, but, it ignores the leap year days.
19:22:41 <EvanR> joe9: you have a gregorian date there... use fromGregorian
19:22:50 <erisco> well apparently "type" and "kind" are now synonymous
19:22:59 <EvanR> to get a Day. the other bits can be used to create a TimeOfDay
19:23:05 <iqubic> type and kind are two seperate things.
19:23:05 <EvanR> the two combine to make a LocalTime
19:23:14 <joe9> EvanR: cool, prefect. Thanks.
19:23:41 <EvanR> you can also formulate the number of seconds past midnight and combine them into a UTCTime
19:23:44 <jared-w> joe9: how is the time coming in anyway?
19:23:54 <codygman> Since I use fromGregorian a lot I like to alias it to something short, like: dt = fromGregorian
19:24:31 <joe9> jared-w:  a bytestring, where each byte is coded. when I decode the byte, it gives me 2017, 06, and so on.
19:24:39 <joe9> jared-w: in 7 or 9 bytes.
19:24:48 <jared-w> But where are you getting the byteString from?
19:24:53 <EvanR> yeah you can construct all the data bit by bit using the ctors directly
19:25:04 <EvanR> indeed parse time is really only useful for formatted strings
19:25:28 <EvanR> a binary version might be cool though
19:25:59 <joe9> jared-w: reading it from a socket. upstream application.
19:26:28 <EvanR> wait, you get an "06" ? 
19:26:34 <EvanR> heh
19:27:31 <joe9> EvanR: perfect. Thanks.  http://codepad.org/bG3quJ9U
19:28:03 <erisco> you can't promote type classes though... bit of a problem
19:28:36 <Lokathor> so i want stack to use a package that isn't on hackage, it's on github
19:29:15 <Lokathor> http://lpaste.net/2217054765211189248 I tried to set it up like this, but stack yelled at me about stuff being done wrong
19:30:10 <EvanR> joe9: note fromGregorian things month 5 = May
19:30:40 <joe9> EvanR: yes, I noticed that. I need to add a 1 there.
19:30:48 <EvanR> or take out your - 1 ;)
19:31:04 <joe9> EvanR: yes, Thanks.
19:31:33 <EvanR> the romans didnt have 0 when they invented ISO month numbering
19:33:05 <jared-w> damn romans, ruining everything for the rest of us
19:33:19 <erisco> but to their benefit they didn't have off-by-one errors
19:34:50 <jared-w> Lokathor: I believe you need to change the git: line to git: git@github.com:Lokathor/hexes.git
19:35:04 <Zemyla> Is there an s, besides (), for which State s is a Comonad?
19:35:26 <Lokathor> jared-w, i did that at first, it just gave me authentication errors
19:35:51 <jared-w> Is your thing public?
19:36:09 * jared-w looks it up in my browser history
19:36:11 <jared-w> nvm
19:36:14 <Lokathor> jared-w, yes
19:36:23 <Lokathor> unless.... oh hmm
19:36:44 <c_wraith> Zemyla: well..  any 1 type.  Of course, they're all obviously isomorphic..
19:37:37 <Lokathor> yep, it reads it wrong if you use the ssh url, and fine if you use the https url
19:38:15 <jared-w> So git@github.com: doesn't work, but https:// does? For your stack.yaml?
19:38:28 <Lokathor> jared-w, yes
19:38:36 <Zemyla> But even something like State Bool has no comonad instance?
19:39:13 <c_wraith> Zemyla: well..  You could do something like Monoid s => State s
19:39:21 <c_wraith> Zemyla: but it would be really unnatural
19:39:32 <jared-w> Lokathor: what if you move extra-dep: true left one indent level?
19:39:56 <c_wraith> Zemyla: the key point is that you must have a distinguished value of type s
19:40:20 <Lokathor> jared-w, and used the ssh link? I mean it's downloading it fine with https. getting the source isn't the issue one bit
19:40:28 <jared-w> https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep like how this is indented in the "local dependency packages" example
19:40:49 <Lokathor> the problem is that it's compiling the git repo and also the local project all at once and then getting confused about what the main binary is and stuff
19:41:15 <jared-w> ahhh okay
19:42:22 <jared-w> Do you have your main and everything in your cabal file setup?
19:44:08 <Lokathor> yeah
19:44:22 <Lokathor> https://github.com/Lokathor/roguelike-tutorial-hs
19:44:52 <Lokathor> it builds, but it can't easily go into ghci because it thinks that it's building both hexes and the tutorial every time
19:45:18 <jared-w> hmm, that tells me that the extra-dep isn't working correctly somehow
19:47:03 <jared-w> extra-dep is supposed to tell stack to load it when ghci is started
19:47:54 <jared-w> Your stack.yaml doesn't have an extra-dep: true line in it. That'll cause ghci to try and build hexes every time you run stack ghci
19:48:56 <Lokathor> oh, er, well i haven't pushed the extra-dep bit up to github >_>
19:49:04 <Lokathor> i put it in the on disk version of course
19:49:39 <Lokathor> http://lpaste.net/2217054765211189248 this is the exact stack.yaml file currently on disk, and the error message
19:51:08 <jared-w> Move extra-dep: true left by two spaces
19:51:32 <jared-w> e in extra-dep should be on the same column as the l in location
19:52:36 <Lokathor> ah ha!
19:52:38 <jared-w> (also, the extra-dep setting message you see is just a warning. It can be ignored, but it means Stack is treating hexes.git as an internal package and thus loading it up with ghci)
19:53:03 <jared-w> yaml is simultaneously a great and terrible format ¯\_(ツ)_/¯
19:53:32 <Lokathor> oh no
19:53:39 <Lokathor> now things don't compile :/
19:53:50 <Lokathor> it thinks that all sorts of packages are missing
19:54:42 <Lokathor> http://lpaste.net/2576749566057512960
19:54:59 <joe9> I get lost with Pico usage:  :t fromIntegral ((1 :: Uni) + (100 :: Milli))  :: Pico
19:55:02 <Lokathor> my main doesn't touch them, it imports Hexes though, which does touch them
19:55:16 <joe9> Do I need a fromIntegral to convert Uni to Milli and then to Pico?
19:55:27 <Lokathor> joe9 probably
19:55:42 <EvanR> yes
19:55:56 <EvanR> actually, realToFrac
19:56:43 <joe9> ok, Thanks.
19:56:47 <EvanR> Uni seems kind of useless though
19:57:01 <EvanR> you can use fromInteger to get a Pico from an Integer
19:57:07 <jared-w> Lokathor: that looks like an exposed module setting is wrong?
19:57:58 <EvanR> use all the same numeric type if you can, for sanities sake
19:58:54 <Lokathor> jared-w,  https://github.com/Lokathor/hexes/blob/master/hexes.cabal ?
19:59:31 <joe9> EvanR:  realToFrac ((1 :: Uni) + realToFrac (10 :: Milli))  :: Milli == 11.000 :: Milli, Isn't this wrong? Should it not be: 1.010 :: Uni or 101.000 :: Milli?
19:59:33 <EvanR> if you parse byte 123 as a Pico to get 123.0, you can just divide by 1000000
19:59:42 <Lokathor> I guess, since Hexes exports things that include Vector and Linear types and stuff, I have to include those as exposed modules maybe?
20:00:09 <EvanR> er
20:00:13 <EvanR> by 1000
20:00:18 <jared-w> Lokathor: try changing your roguelike-tutorial-hs.cabal line 23 from 'hexes' to 'Hexes'
20:00:19 <EvanR> > 123 / 1000 :: Pico
20:00:21 <lambdabot>  0.123000000000
20:01:00 <EvanR> joe9: certainly seems wrong, arent you trying to get Pico ?
20:01:21 <joe9> EvanR: yes, eventually. just getting my head around the Data.Fixed usage
20:01:27 <Lokathor> jared-w, no go, "hexes" is the package name, "Hexes" is the module name
20:01:38 <jared-w> ahh right, nvm. Brain fart there
20:01:58 <EvanR> > realToFrac (0.123 :: Milli) :: Pico -- but really, going from 123.0 Pico to 0.123 is easier
20:01:59 <lambdabot>  0.123000000000
20:02:17 <EvanR> use Pico across the board
20:03:52 <jared-w> Lokathor: does stack solver do anything useful here?
20:04:14 <joe9> EvanR: I am trying to understand the usage here. For example, 1 :: Uni + 1 :: Centi == 1.1 Uni, correct?
20:04:23 <joe9> or 11 :: Centi
20:04:27 <Lokathor> jared-w, don't think so. it's ghci that's upset, not stack
20:04:28 <EvanR> ... no you cant add different types together
20:04:38 <jared-w> Lokathor: did you try it? :p
20:04:41 <Lokathor> joe9 you need to always manually convert
20:04:44 <EvanR> Uni = 0 decimal places?
20:04:56 <EvanR> > 1.1 :: Uni
20:04:58 <lambdabot>  1.0
20:05:03 <Lokathor> jared-w, you can't even use the --solver flag with "stack ghci" :P
20:05:05 <joe9> EvanR: yes, that is what Data.Fixed says.
20:05:37 <EvanR> + works only on two args of the same type
20:05:59 <jared-w> I was just gonna have you run stack solver normally to see if it noticed anything missing in your cabal file. You shouldn't have a building stack project and a failing ghci...
20:06:08 <nshepperd> Zemyla: i don't think a lawful comonad instance for State s is possible, unless s is ()
20:06:31 <joe9> EvanR: oh, ok. I have a seconds value and a milliseconds value to be stored as pico. I was just searching for shortcuts instead of doing the conversion manually.
20:06:32 <EvanR> joe9: you seem to think Uni and Centi are units.. no they are precision. 1 Uni and 1 Centi are the same "value"
20:06:44 <joe9> EvanR: oh, ok.
20:07:15 <EvanR> so you want to do this sort of calculation 
20:07:24 <nshepperd> Zemyla: the problem is extend extract = id
20:07:29 <EvanR> > 5 + 0.123 :: Pico
20:07:31 <lambdabot>  5.123000000000
20:08:08 <EvanR> the first arg is integer number of seconds (as a Pico), the second is number of ms divided by 1000 (as a Pico)
20:08:38 <joe9> oh, got it. Thanks.
20:11:38 <Lokathor> jared-w, http://lpaste.net/356387
20:12:49 <nshepperd> Zemyla: i think it's generally the case that nothing interesting is a comonad at the same time as being a monad
20:13:44 <EvanR> Data.Fixed should go on a list of "things that might wow people coming from another language, and make them consider learning more haskell thinking theyll find more wow, but otherwise wouldnt have thought thered be anything interesting enough to be worth it"
20:14:20 <EvanR> hopefully that list eventually becomes longer than the list's title
20:16:52 <nshepperd> it *is* pretty unusual for languages to let you define your own number types without them being second class citizens
20:18:53 <Zemyla> nshepperd: Streams, rose trees?
20:21:45 <Lokathor> jared-w, ohhhhhhhhh
20:21:48 <Lokathor> oh boy I solved it
20:22:26 <Lokathor> my .ghci file, copied in from another project, was trying to import those modules it said it couldn't find
20:22:32 <nshepperd> streams with the diagonal join? hmm
20:23:00 <c_wraith> nshepperd: Cofree has a completely nuts Monad instance. :)
20:23:10 <c_wraith> nshepperd: but it's law-abiding!
20:29:42 <Lokathor> what about the covfefe monad?
20:30:53 <Hafydd> Haha.
20:31:54 <systemfault> If there's a covfefe, there's the dual, the vfefe
20:32:24 <systemfault> Makes you wonder what kind of burrito it is.
20:34:17 <jared-w> haaah never would've guessed that, Lokathor. It's always the small stuff lol
20:34:39 <Lokathor> systemfault, probably a burrito that's orange and gross
20:34:56 <jared-w> For what it's worth, I have a global .ghci config that I put all my generic stuff in and then I have a per-project .ghci if I want to have a different prelude or want to load up some pragmas specially in ghci
20:48:01 <suzu> :D
20:49:35 <srpx_> When was the do-notation implemented?
20:54:22 <EvanR> "free monad" on google gives an article first result... free monads are simple
20:54:26 <EvanR> so far so good
20:54:34 <EvanR> it turns out to be in scala
20:56:35 <EvanR> and brings in coyoneda and kan extensions
20:56:38 <EvanR> in scala
21:02:00 <Cale> srpx_: Between the Haskell 1.2 and Haskell 1.3 reports
21:02:36 <Cale> There's a good few years there, so you might want to track it down further
21:02:38 <EvanR> what is the word Roll supposed to evoke in the definition of data Free f a = Pure a | Roll (f (Free f a))
21:02:50 <Cale> (between March 1992 and May 1996)
21:03:53 <EvanR> is it just a case where theres no good word to use
21:04:36 <Cale> EvanR: That's kind of true... though Effect would be an okay word to use there if you're going to call the first branch Pure
21:06:58 <dmwit> EvanR: Roll and unroll are sort of evocative words for wrapping/unwrapping of iterated things.
21:07:07 <dmwit> EvanR: e.g. loop unrolling
21:07:51 <dmwit> EvanR: You could imagine "data structure unrolling" which converted, e.g. `[a]` to `Maybe (a, Maybe (a, Maybe (a, [a])))` or something.
21:08:04 <dmwit> EvanR: This is "data structure rolling" by analogy.
21:10:18 <EvanR> ok
21:10:38 <EvanR> so busting open a Roll is unrolling, or if i didnt know better, unfolding?
21:11:44 <Cale> EvanR: best not to read too much into it, but I suppose!
21:12:38 <Cale> EvanR: It is common for f to be some data type whose constructors correspond to various "commands" which could be issued, and alongside each, contains positions for the continuation (perhaps on the right of a function arrow, if the continuation will depend on the result of the command)
21:13:05 <Cale> e.g. if we define  data StateOps s x = Put s x | Get (s -> x)
21:13:31 <EvanR> i tried to get a distilled idea of a free monad using this: data Program a = Ended a | Blocked (b -> Program a). it doesnt type check obviously, so now im thinking the free monad machinery is a slight complexity so as to work around it
21:13:59 <EvanR> this version only works if b is a constant
21:14:20 <Cale> Well, you can leave the ways in which to block up to the functor in question
21:14:22 <EvanR> and doesnt let you issue commands
21:15:30 <Cale> But yeah, you could drop Put from the thing I just defined
21:15:45 <Cale> and end up with a monad where you had a way to demand a value of type s before proceeding
21:15:55 <EvanR> data Program f a = Ended a | Blocked (f _) (_ -> Program f a)
21:16:01 <Cale> (which you might interpret as "blocking" perhaps, or "reading"
21:16:03 <Cale> )
21:16:26 <EvanR> just trying to see all avenues...
21:17:57 <EvanR> in Ended a | Blocked (f (Program f a)), what guarantees that i can eventually get a continuation?
21:19:10 <EvanR> i guess nothing
21:20:20 <EvanR> i can either have none, one, many, or none unless i have what it takes to apply a function
21:21:17 <Cale> right, and the combinations of those available depend on the choice of f
21:21:50 <EvanR> so the program may end in more than one way, Pure x or "no continuation"
21:22:47 <EvanR> so f serves to hold (or generate) the next Program
21:23:19 <EvanR> the fact that its a functor and can hold whatever is just extra generalization
21:25:03 <EvanR> sometimes i get lost when a concrete thing is replaced with a type variable
21:25:20 <EvanR> example, the machines slides, its just alphabet soup
21:28:00 <EvanR> data StateOps s x = Put s x | Get (s -> x) | forall b . Request (IO b) (b -> x) -- bwahaha
21:28:11 <Cale> sure
21:28:45 <Cale> Or even just  Request (IO x)
21:29:28 <EvanR> Something (g x)
21:29:37 <EvanR> where g is yet another functor
21:30:03 <EvanR> or another monad
21:30:10 <joe9> I cannot figure this out, I have a Word8 byte with value of 0x99, when I do 153 + 256 :: Int, I get 409 :: Int. But, when I do (fromIntegral lo) + 256 :: Int, I get 487. let lo = 0x99 :: Word8
21:31:01 <EvanR> > 0x99 + 256
21:31:03 <lambdabot>  409
21:31:14 <EvanR> oh
21:31:18 <EvanR> > 0x99 :: Word8
21:31:20 <lambdabot>  153
21:31:22 <EvanR> > 0x99
21:31:24 <lambdabot>  153
21:31:29 <EvanR> maybe no
21:31:48 <joe9> from ghci, I get 409 too.
21:31:58 <EvanR> how do you get 487
21:32:25 <joe9> but, this statement is giving me 487: return (fromIntegral lo + 256 :: Int)
21:32:30 <joe9> where lo is 0x99
21:33:19 <joe9> probably the way the promotion to Int is happening (sign extension, etc?)
21:33:22 <EvanR> change the code to (fromIntegral (lo :: Word) + 256 :: Int) and see if you are wrong
21:33:31 <EvanR> Word8 i mean
21:34:52 <EvanR> place extra type annotations to make sure you and GHC agree
21:35:34 <joe9> code: https://gist.github.com/41063d148e2af81de37478675b320788
21:35:56 <joe9> test output: http://codepad.org/nkDxkcXZ
21:36:11 <joe9> note the milliseconds, it should be 409 not 487
21:36:32 <EvanR> i suspect a plain bug somewhere after that code on 124 and whatever happens next
21:36:34 <joe9> if I return in line 121 a hardcoded 409, the ms is 409
21:37:19 <EvanR> or lo is not literally 0x99
21:38:24 <joe9> EvanR: this code: https://gist.github.com/ded74e3737aa2ad75901aa83994906be , result:  http://codepad.org/ZB4vG4fJ
21:38:30 <EvanR> > ord '\231'
21:38:32 <lambdabot>  231
21:38:41 <joe9> the only difference is on line 121
21:38:48 <EvanR> in what sense is \231 = 0x99 ?
21:39:36 <EvanR> decimal rocks!
21:40:52 <joe9> EvanR: my bad, sorry.
21:40:56 <EvanR> converting Word8 to Int cant fail or do anything weird, since Word8 is unsigned
21:42:13 <joe9> I was under the impression that \231 is the Octal 231 == 0x99 == 153
21:42:24 <joe9> &#153; | \231 | =99 |     |     | Unused
21:42:56 <joe9> It is just a word with the value of 231 decimal, not octal
21:43:12 <EvanR> its actually char 231
21:43:27 <joe9> oh
21:43:28 <EvanR> interpreted as a byte by the IsString instance of ByteString
21:43:39 <EvanR> which works since its less than 256
21:44:20 <EvanR> > ord '\257'
21:44:22 <lambdabot>  257
21:44:40 <EvanR> > "\257" :: ByteString
21:44:42 <lambdabot>  error:
21:44:42 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
21:44:42 <lambdabot>      Perhaps you meant one of these:
21:45:28 <EvanR> suffice it to say that will not be a 1-byte bytestring where the byte is 257
21:46:17 <joe9> EvanR: char 237 == same as the decimal value 237?
21:46:25 <joe9> s/237/231/
21:47:01 <EvanR> char 231 being '\231' in the quotes, 231 is a decimal number
21:47:13 <joe9> ok, Thanks.
21:48:38 <glguy> > '\o231'
21:48:39 <lambdabot>  '\153'
21:50:24 <joe9> EvanR: need another advice, please? I am able to convert the bytestring to a LocalTime. But, this bytestring is hardcoded to CST. localToUTCTimeOfDay :: TimeZone -> TimeOfDay. I am not sure how to get the TimeZone for CST. I can use Data.Time.Zones and get the TimeZone using the label  America__Chicago
21:50:34 <joe9> EvanR: Not sure if that is a good way of doing it.
21:51:04 <EvanR> there is no TimeZone for CST
21:51:13 <EvanR> not in that package
21:51:30 <EvanR> look at package timezone-series
21:51:37 <glguy> minutesToTimeZone (-6 * 60)
21:51:59 <mbeidler> Has anyone measured GHC performance over successive releases?
21:52:17 <EvanR> and also package timezone-olsen
21:52:32 <glguy> or  TimeZone (-6 * 60) False "CST"
21:52:55 <EvanR> ah, if its always a fixed offset, youre good
21:53:31 <Axman6> mbeidler: there is automatic testing of that done by the GHC team
21:53:39 <joe9> I don't think there is a fixed offset. I think there is a daylight savings time.
21:53:41 <mbeidler> I'm reading the Parallel and Concurrent Programming in Haskell book and I'm surprised at how much slower the examples are running than the times given by Simon Marlow (I'm running examples on a high-powered macbook pro).
21:53:51 <EvanR> then hardcoding CST is a bad idea
21:53:55 <srpx_> EvanR: thanks
21:53:57 <jared-w> Does anyone know why Pi is used as a quantifier in dependent haskell?
21:54:07 <srpx_> Woops, Cale *
21:54:18 <Axman6> mbeidler: https://perf.haskell.org/ghc/
21:54:28 <Axman6> mbeidler: what code are you running, and how are you compiling and running it?
21:54:30 <jared-w> It's a "relevant" paramater, but idk where relevant comes from
21:54:41 <mbeidler> Axman6: Interesting! Thanks for the link.
21:55:12 <mbeidler> Axman6: I'm using the same command-line options as in the book, -threaded -O2 for compilation and +RTS 2 when running.
21:55:42 <Axman6> +RTS -N2?
21:55:53 <mbeidler> Axman6: yeah
21:55:56 <EvanR> jared-w: dependent relevant and dependent irrelevant comes from dependent type theory, where regular function arrow is a dependent pi type that doesnt actually use the bound type variable
21:56:03 <Axman6> mbeidler: which code?
21:56:07 <mbeidler> Axman6: I copied it directly from the text.
21:56:17 <Axman6> ... what is the code :\
21:56:21 <mbeidler> Axman6: The `rpar` example specifically.
21:56:31 <Axman6> a lonk or paste perhaps?
21:56:34 <Axman6> link*
21:56:43 <EvanR> er, regular variable. Pi[x:A] B(x) is a function from A to B(x), the result type depends on the value of the argument
21:56:48 <mbeidler> Axman6: https://github.com/simonmar/parconc-examples/blob/master/rpar.hs
21:56:49 <jared-w> ahh okay, that helps. So the pi symbol comes from the fact that it's a pi type
21:56:58 <EvanR> but if the form of B doesnt use the x, its "irrelevant" and acts like a normal function type
21:57:10 <EvanR> which forall kind of is
21:58:38 <jared-w> oooh nifty
22:00:34 <jared-w> aha, so Pi types really are linked to iterative products
22:00:46 * jared-w is supposed to be an analyst
22:01:24 <EvanR> product is really confusing jargon for this
22:01:28 * jared-w is conflicted for his deep fascination with algebras ala monoids, ADTs, etc
22:02:23 <EvanR> iterative products?
22:02:29 <jared-w> Well a pi type means, roughly, (if I'm reading this article right) "for all N you can do something"
22:02:56 <EvanR> for all n:N, something(n) :)
22:03:03 <jared-w> yeah. There's the algebra of types. Sum = One | Two | Three has 3 inhabitants
22:03:13 <mbeidler> Axman6: In the book the total time for the different rpar runs is around 0.8 seconds. For me it's almost 3 seconds. Perhaps he was running them on a very powerful desktop on a pared down linux distribution or something. However, since the book is a few years old I was expecting the numbers to be more similar.
22:03:45 <jared-w> Product = Bool Bool Bool has 2*2*2 = 6 inhabitants
22:04:31 <EvanR> this is why its confusing, because Sigma[x:A] B(x) is the type of pairs where the left component comes from A and the right comes from B(x)
22:04:39 <EvanR> so thats where you get your multiplication
22:04:44 <EvanR> Pi gives you exponentiation
22:04:54 <jared-w> a PI type would have Pi[0,inf] (f : a -> b) inhabitants
22:05:24 <EvanR> A -> B has |B|^|A| inhabitants
22:05:43 <jared-w> Sigma type would be a possibly infinite enum
22:06:04 <jared-w> https://manishearth.github.io/blog/2017/03/04/what-are-sum-product-and-pi-types/
22:06:13 <jared-w> I'm down at the make_array function example
22:06:15 <EvanR> sigma does a lot
22:06:39 <EvanR> yes and people use product at least two ways when talking dependent types
22:07:09 <jared-w> The Pi one seems to basically mean a product type of an infinite number of types. Is there another way to define a Pi type?
22:07:14 <EvanR> which says to me, dont use it either way any more!
22:07:27 <EvanR> its not a product of infinite number of types
22:08:17 <EvanR> a particular pi type may only have finite number of functions in it
22:08:19 <jared-w> ah, in their example they used an unbounded integer type
22:09:12 <glguy> mbeidler: You're using "+RTS 2" ?
22:09:31 <jared-w> so they were making arrays of N number of boolean values where N went from 0 to infinity, hence the "it's a product of an infinite number of types"
22:09:42 <mbeidler> glguy: +RTS -N2
22:10:51 <glguy> mbeidler: Are those like what you're getting? http://lpaste.net/356388
22:11:21 <EvanR> jared-w: i think the idea of functions being a product (i.e. cartesian product, NxM items) comes from a concept of functions as a set of pairs
22:11:32 <EvanR> which i havent seen to be that useful in haskell
22:11:36 <jared-w> sounds right to me.
22:12:03 <jared-w> I mean, you sort of use that concept when you're pattern matching...
22:12:06 <EvanR> and its confusing because we a totally different thing called a product
22:12:24 <EvanR> its M^N vs N*M
22:12:35 <EvanR> the first one is an exponential
22:13:15 <EvanR> we should strike down "function ~ product" right now :)
22:13:55 <jared-w> I agree :p
22:14:05 <EvanR> jared-w: when you pattern match, you define 1 function, the type is talking about all possibilities
22:14:32 <EvanR> sigma is really the corresponding dependent product
22:14:39 <EvanR> its literally pairs
22:14:43 <jared-w> Right, I just meant that pattern matching looks pretty simliar to a set of pairs to me. Where you have the pattern and the other part of the pair on the equal sign
22:15:26 <glguy> mbeidler: On a modern macbook pro I get times in the neighborhood of 1.25sec printed by the program itself
22:15:31 <EvanR> well, then youll see pairs everywhere you look haha
22:16:26 <jared-w> hah, true. But, I do agree that since functions end up having exponential numbers of inhabitents, they really shouldn't be talked about with the word 'product'
22:16:44 <mbeidler> glguy: This is what I get without using  the time command: http://lpaste.net/356389
22:17:09 <glguy> mbeidler: What command did you use to compile that?
22:17:12 <EvanR> product/pairs has the structure, you can put two things together and get them back with projections. exponential/function has the structure, you can wrap something in a lambda and apply a lambda to an argument
22:17:16 <glguy> How old is the computer?
22:17:33 <mbeidler> glguy: I compiled: ghc rpar.hs -O2 -threaded
22:17:42 <jared-w> mbeidler: do you have a link to the program so I can test it on my laptop?
22:18:03 <jared-w> nvm found it
22:18:09 <glguy> My late 2012 iMac finished in 1.8s and the macbook pro was doing 1.25s
22:19:04 <glguy> Is your CPU actually idle?
22:19:16 <glguy> Maybe you're encoding video :)
22:21:48 <jared-w> I'm just compiling everything with a default stack build
22:24:50 <mbeidler> glguy: Yeah, I closed all my browser windows, made sure my CPU was idle, ran again and it was just over 3 seconds. Anyway, must just be an issue with my machine.
22:25:45 <jared-w> what processor do you have?
22:26:18 <mbeidler> 2.7 GHz Intel Core i7
22:26:18 <EvanR> comparing 1.8s to 3.1s ?
22:26:58 <jared-w> mbeidler: but, like, you're using a macbook pro? What year? Just saying "i7" is meaningless without knowing what TDP it has and what generation it is
22:27:19 <EvanR> are we trying to figure out what effect would affect the time so little? :)
22:27:53 <jared-w> A consistent 75% performance penalty isn't really small :p
22:28:02 <glguy> 1.25 vs 3
22:28:12 <mbeidler> Retina 15-inch Early 2013, 16 GB RAM
22:28:25 <EvanR> power saving features ?
22:28:37 <mbeidler> Yeah, agreed, that's why I was surprised. In the book he gets .82
22:28:47 <mbeidler> I'm plugged in and don't have power saving turned on.
22:29:53 <glguy> 1.25 was on "machdep.cpu.brand_string: Intel(R) Core(TM) i7-6920HQ CPU @ 2.90GHz" and 1.8 was on "machdep.cpu.brand_string: Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz"
22:29:56 <jared-w> So you have a ivy bridge 28W processor
22:30:23 <EvanR> more gigahertz = more time heh
22:30:59 <jared-w> HQ vs no HQ. Also 3770 vs 6920
22:31:04 <jared-w> Not even close to comparble :p
22:31:17 <glguy> Nope, that wasn' the point of the numbers
22:31:53 <jared-w> the 6920 is a 35-45W TDP 6th gen i7
22:32:11 <glguy> Those are just two CPUs I tried on for comparison
22:32:17 <systemfault> I would like to learn how to use Free Monads (Because I'm not rich :/)... I read a few articles and I think I get the idea. Is there a standard library to do that? Or a widely used one
22:32:33 <jared-w> the 3770 is a 77W intel core processor
22:32:34 <EvanR> the package free
22:32:49 <systemfault> EvanR: Thank you
22:35:14 <EvanR> 3x slowdown, maybe has to do with core usage?
22:35:28 <glguy> It's probably just a slow cpu
22:36:14 <mbeidler> Yeah, I suppose it's just a slow CPU. The numbers are pretty consistent.
22:36:18 <Axman6> systemfault: freer-effects is probably the most up to date
22:37:51 <glguy> freer-effects doesn't seem like the right place to start for developing an understanding of the "free monad"
22:37:55 <jared-w> wtf
22:38:18 <jared-w> oooooh
22:38:29 <Axman6> glguy: I didn't think that was the point?
22:38:32 <systemfault> glguy: So I should start with the "free" package first then when my understanding is better, move on to freer-effects?
22:38:54 <halogenandtoast> Does anyone know how I could access the session https://github.com/mpickering/slack-api/blob/e08c92dfa438be98247fc9137b3e052b69cb009a/src/Web/Slack/State.hs#L36 from a function of type SlackBot ()
22:39:05 <glguy> Axman6: If the point wasn't to learn about the free monad, what's the point?
22:39:21 <jared-w> mbeidler: your cpu is an ivy bridge 45W quad core processor
22:39:23 <Axman6> to find which library people use I thought :\
22:39:48 <halogenandtoast> I see there are some lenses (I want to basically get at session -> self -> userId
22:40:06 <glguy> Axman6: Waaay more people use "free" than "freer-effects"
22:42:22 <mbeidler> jared-w: But glguy has a much newer version of the i7, so that may explain the difference?
22:42:25 <Axman6> ok, well _I_ am using freer-effects because I think its interface is much nicer
22:42:46 <glguy> Doing anything cool with it?
22:43:01 <halogenandtoast> this seems close to what I want to do: view (session . slackSelf . selfUserId)
22:43:21 <Axman6> not at the moment really, but free monads look like a nice solution to a problem one of our teams is running into
22:43:22 <mbeidler> Ah, I see that in the paste glguy was using -N. I was using -N2 as in the book.
22:43:46 <Axman6> -N is usually a good default
22:43:54 <mbeidler> Using -N I'm getting 1.9, still surprised that -N2 is so much slower than the book.
22:44:06 <halogenandtoast> view (session . slackSelf . selfUserId . getId) gets the Text I want, I think, now if I can figure out how to use it in my function
22:44:10 <mbeidler> Axman6: Yes, I was only running -N2 so I could compare the numbers to the book.
22:44:30 <jared-w> mbeidler: yes, it should
22:44:51 <jared-w> In particular, your CPU doesn't support vectorizing un-aligned things and glguy's does. I'm not sure if that makes a difference here
22:45:22 <EvanR> vectorized speedup compiling haskell code ?
22:45:22 <halogenandtoast> I assume this is wrong:   bid <- view (session . slackSelf . selfUserId . getId)
22:45:58 <jared-w> Basically glguy's CPU is yours, just several years newer
22:45:58 <glguy> mbeidler: Oh, switching to -N2 makes it go faster for me :)
22:46:01 <halogenandtoast> No instance for (mtl-2.2.1:Control.Monad.Reader.Class.MonadReader (SlackState s00) (Slack ()))
22:46:25 <glguy> halogenandtoast: Try use
22:47:16 <halogenandtoast> glguy: yes thanks!
22:47:21 <halogenandtoast> Never would have figured that out
22:47:36 <Axman6> halogenandtoast: SlackBot is  Event -> Slack s () yeah? so you probably need to be providing an Event before you get a Slack s (), where you can then use 'use' to access the SlackState
22:52:30 <mbeidler> glguy: Ha. I guess I should heed his advice in the book: "The important thing is to be aware that performance is fragile, especially where parallelism is concerned."
22:54:21 <jared-w> hah
22:54:23 <jared-w> finally got it to work
22:55:00 <jared-w> I'm getting 1.74s, mbeidler
22:55:17 <mbeidler> jared-w: With +RTS -N2?
22:56:16 <jared-w> yup
22:57:04 <jared-w> 2 core 15W 6th gen i7
22:57:12 <jared-w> I have half the cache of glguy as well
22:58:05 <jared-w> and half the bus speed :p
22:59:06 <jared-w> Roughly lines up with the performance slowdown with mine vs glguy's
23:11:36 <halogenandtoast> any suggestions for an xml parsing library? xml or hxt?
23:13:20 <jared-w> Any library starting with an h is automatically the more haskelly library
23:13:43 <jared-w> (jk) haven't used either but you likely can't go wrong. Pick the one that looks easiest to do what you want in and refactor later if you chose wrong?
23:14:11 <EvanR> xml and can't go wrong in the same ... nevermind
23:22:02 <halogenandtoast> ah hxt doesn't work with text or bytestring, guess I'll use xml-conduit
23:22:51 <cocreature> halogenandtoast: fwiw I’ve found xml-conduit quite pleasant to use d)
23:22:53 <cocreature> *:)
23:23:17 <halogenandtoast> Hopefully I'll find the same.
23:48:45 <halogenandtoast> is this an incorrect usage of runExceptionT? ereq <- runExceptionT $ parseRequest (T.unpack url)
23:49:05 <halogenandtoast> parseRequest :: MonadThrow m => String -> m Request
23:52:13 <quchen> halogenandtoast: Why would it be?
23:52:57 <halogenandtoast> quchen: I don't know the answer, but I'll describe what I was trying to do, I was trying to combine my functions monad with a transformer to give me MonadThrow
23:53:53 <ventonegro> I didn't know this `if` syntax https://two-wrongs.com/on-competing-with-c-using-haskell#rf1
23:54:27 <quchen> ventonegro: This »if« syntax should be replaced by MutiwayIf instead! :-)
23:54:30 <halogenandtoast> I thought I could do that with a monad transformer
23:56:14 <jared-w> EvanR: I suppose I should've clarified that to be "Using an xml library in haskell is likely about as blissful and painless of an experience as one can expect when using that cancer of a data format"
23:56:20 <ventonegro> quchen: ah ha
23:56:32 <cocreature> multiwayif is awesome
23:57:00 <quchen> ventonegro: It’s basically a nice way of writing if with multiple, not just two, branches.
23:57:25 <ventonegro> they should have given it its proper name, `cond` *ducks*
23:57:47 <centril> cocreature: LambdaCase is even more awesome
23:58:02 <jared-w> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions I find this article pretty helpful for these kinda things
23:58:06 <centril> a bit orthogonal usecase, and a bit not
23:58:31 <cocreature> centril: surprisingly I don’t really care about LambdaCase. I’ve found that when I need LambdaCase I’m usually better off moving that lambda to a separate definition in a let/where
23:58:49 <quchen> ventonegro: http://lpaste.net/356392
23:58:59 <centril> cocreature: I loathe where bindings, top level functions all the way
23:59:00 <cocreature> ventonegro: lisper detected
23:59:08 <centril> and let bindings I use sparingly
23:59:26 <halogenandtoast> So how would someone else suggest handling No instance for (MonadThrow (Slack ()) arising from the use of parseRequest
23:59:36 <halogenandtoast> my attempt to use runExceptionT was clearly off
23:59:36 <cocreature> centril: well if you’re fine with a lambda let/where seems more appropriate but I’d still prefer a toplevel binding over lambdacase in most cases
23:59:37 <quchen> cocreature: I use LambdaCase heavily! https://github.com/quchen/prettyprinter/blob/master/prettyprinter/src/Data/Text/Prettyprint/Doc/Internal.hs#L1340
23:59:48 <ventonegro> cocreature: busted!
