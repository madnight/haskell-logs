00:48:08 * hackage regex-with-pcre 1.0.1.1, regex 1.0.1.1, regex-examples 1.0.1.1 (ChrisDornan): https://qbin.io/zv0rlvzs4
01:00:46 <Sh4rPEYE> Hello. I'm trying to make a longest common substring algorithm. Currently I use binary search to guess the length of the substring (the most naïve way would be to simply try from the longest). I have two ways of doing that - and one is inexplicably much faster than the other. Could somebody please look at the code and tell me, why is it so?
01:00:47 <Sh4rPEYE> http://lpaste.net/8950294490006945792
01:02:28 <Sh4rPEYE> For the record, the longestCommonSubstring' is the faster one.
01:04:06 <saurabhn_> still struggling with Generics. Broadcasting here for help -- https://stackoverflow.com/questions/44352002/how-to-get-an-enum-constructor-from-a-string
01:06:10 <Myrl-saki> For infinite lists, would it be sane to have `sort = filter (== minBound)`
01:06:21 <Myrl-saki> For inifnite lists with bounded elements*
01:06:43 <pikajude> what if it's [1] ++ [2,2..]
01:07:20 <Myrl-saki> pikajude: Then `print . sort' $ [1] ++ [2,2..]` -> [1,
01:07:38 <pikajude> ok
01:22:08 * hackage tasty-discover 3.0.2 - Test discovery for the tasty framework.  https://hackage.haskell.org/package/tasty-discover-3.0.2 (lwm)
02:07:38 * hackage snipcheck 0.1.0.2 - Markdown tester  https://hackage.haskell.org/package/snipcheck-0.1.0.2 (nmattia)
02:15:35 <edlinde> hi all, can someone suggest programming questions that are language agnostic in some sense but test someone's understanding of concepts like recursion
02:15:44 <edlinde> or even functional programming concepts
02:16:46 <sternmull> you could pick some simple algorithms that have the properties/concepts you care about
02:18:00 <edlinde> I need to setup some questions for a programming quiz which has to be fairly difficult :)
02:18:19 <edlinde> need some tricky questions which only a good programmer will be able to answer
02:18:41 <edlinde> people come prepared with all the standard algorithms and data structures stuff
02:18:41 <sternmull> this really depends on your understanding of a "goo programmer"
02:18:56 <sternmull> s/goo/good/
02:19:13 <LiaoTao> "How many times does this algorithm recurse when processing this data structure before finishing?"
02:19:22 <LiaoTao> "What are the results?"
02:19:24 <LiaoTao> etc.
02:19:50 <edlinde> hmm
02:21:03 <LiaoTao> edlinde: "Does this algorithm finish given this data?"
02:21:22 <LiaoTao> "What would you add to make it finish?"
02:21:47 <edlinde> LiaoTao: I like that line of reasoning... just wonder if there is some code available for this
02:21:59 <sternmull> edlinde: You could also pick a small problem that is relevant to you and ask them to solve it and explain their approach.
02:22:46 <edlinde> yeah that will happen in the interviews... at the moment they are just to be short listed with a quick exam that tests their basics
02:31:17 <butterthebuddha> Working through the CIS 194 course right now
02:31:31 <butterthebuddha> (The UPenn course)
02:31:42 <butterthebuddha> Is it safe to skip the Learn You Haskell readings?
02:31:52 <butterthebuddha> That book has too much fluff for my liking
02:32:23 <sternmull> i want a tree data structure where the leafs are chunks (like Data.Text) which allows efficient insertion/deletions at arbitrary positions while sharing as much state as possible with the original. Is there a package for something like that?
02:43:02 <ph88^> cocreature, i (again) looked at that paste you gave me, does it merge (fuse) the stream of Double's with a stream (snapshots) of the state? What is upstream and what is downstream in this case? (i refer to the description of fuseUpstream which refers to fuseBoth)
02:54:47 <cocreature> ph88^: in your specific case you could also just use .| instead of fuseUpstream. fuseUpstream would allow to also have a non-trivial return value but you are just using () anyway. and yes, it merges the stream with a snapshot of the state
02:56:49 <ph88^> cocreature, the function is not working at the moment https://bpaste.net/show/030f78c9b28c but let me try with .|
03:02:51 <ph88^> cocreature, i made this now https://bpaste.net/show/da18cbe1baef it type checks .. but i had to change evalStateC to evalStateLC .. i don't understand why this has to be lazy evaluation now (though that seems fine to me ?)
03:06:21 <ph88^> just as an exercise i tried to write that code with do-notation .. didn't get that to work :(    combine2 = await >>= \val -> maybe (return ()) (\v -> get >>= \s -> yield (v, s)) val
03:13:38 * hackage regex 1.0.1.2, regex-with-pcre 1.0.1.2, regex-examples 1.0.1.2 (ChrisDornan): https://qbin.io/y39cemm
03:18:08 * hackage servant-auth-token-persistent 0.5.1.0 - Persistent backend for servant-auth-token server  https://hackage.haskell.org/package/servant-auth-token-persistent-0.5.1.0 (NCrashed)
03:32:08 * hackage zip-archive 0.3.0.7 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.3.0.7 (JohnMacFarlane)
03:36:08 * hackage nice-html 0.2.0 - A fast and nice HTML templating library with distinct compilation/rendering phases.  https://hackage.haskell.org/package/nice-html-0.2.0 (MikeLedger)
03:37:57 <ph88^> cocreature, this is actually not what i wanted, because i get type  [(Value, AdjustSampleState)]  but i want type  ([Value], AdjustSampleState)
03:40:01 <cocreature> ph88^: I’m not following. it matched the type signature you showed. if that’s not what you want, provide the type signature for the thing you do want
03:45:56 <Myrl-saki> :t id :: Int -> Float
03:45:58 <lambdabot> error:
03:45:58 <lambdabot>     • Couldn't match type ‘Int’ with ‘Float’
03:45:58 <lambdabot>       Expected type: Int -> Float
03:46:17 <Myrl-saki> :t swap . traverse . swap
03:46:18 <lambdabot> error:
03:46:18 <lambdabot>     • Couldn't match type ‘[a0] -> f0 [b0]’ with ‘(a, b)’
03:46:18 <lambdabot>       Expected type: (a1, b1) -> (a, b)
03:47:07 <Myrl-saki> Oh wait. I misunderstood.
03:47:18 <Myrl-saki> Whoops.
03:51:08 * hackage latex-formulae-image 0.1.1.3, latex-formulae-hakyll 0.2.0.3, latex-formulae-pandoc 0.2.0.5 (LiamOConnorDavis): https://qbin.io/8yn63fqj
03:58:38 * hackage agda-snippets-hakyll 0.1.2.2, agda-snippets 2.5.2 (LiamOConnorDavis): https://qbin.io/ttxozj51j
04:00:39 <ph88^> cocreature, yes the type signature i showed was wrong :/ .. i want a stream of Double's and also i want to get the final state .. i don't need the stream of state (that i turn into a list later)
04:03:21 <lambdamu> I was wondering is it possible to get a list of exported names for some imported module via template-haskell? It seems one can get all imported module names but not a list of exports per name
04:10:51 <cocreature> ph88^: so how about https://gist.github.com/cocreature/90152dfc520513852fabed1ff129bcb0
04:11:59 <ph88^> cocreature, thanks again .. it will take some time to verify it as i'm in the middle of refactoring some code, i'll get back to you
04:29:59 <ph88^> cocreature, at the moment i'm using sourceToList with Vector.fromList this is really fast .. i think because the vector is filled as soon as new values come down from the stream. But i think if i use  consume  that i will have to traverse the list and it will be much slower
04:33:07 <ph88^> "However, sourceToList is able to produce its results lazily, which cannot be done when running a conduit pipeline in general."
04:33:09 <cocreature> ph88^: I don’t think the vector can be filled immediately in particular it can’t if your m is some monad transformer stack on top of IO (which it probably is) so without seeing a benchmark I doubt that is significantly slower
04:33:25 <cocreature> ph88^: read the next sentence. it depends on the monad
04:47:17 <jchia_1> Do I need to know category theory to understand free monads?
04:47:40 <bennofs[m]> jchia_1: no
04:49:22 <ph88^> @pl \a b c -> fmap a $ fmap b c
04:49:23 <lambdabot> (. fmap) . (.) . fmap
04:54:08 * hackage zip-archive 0.3.1 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.3.1 (JohnMacFarlane)
04:58:24 <mreh> can anyone here help me get started hacking my own Reflex project?
04:59:11 <mreh> I've followed the instructions here but I can't get the project to compile: https://github.com/reflex-frp/reflex-platform/blob/develop/HACKING.md
05:00:21 <mreh> It compiles but doesn't execute
05:24:25 <sullyj3> so, given a string which contains an html img tag, I want to extract the contents of the "src" string. In python I was storing the index after the location of 'src="', and the index of the next '"' after that, then return the string slice between those indices. I probably could translate that directly into haskell using (!!), but I think that would involve traversing the same string multiple times and be innefficient and 
05:24:25 <sullyj3> unidiomatic. Any suggestions?
05:26:16 <quchen> sullyj3: Are you trying to write a good program, or just hack a solution together?
05:26:37 <quchen> If the goal is a program, write a parser. If it’s not, use Regex.
05:27:22 <sullyj3> I'm trying to learn haskell. I could just finish writing the thing in python, but I was hoping it might be prettier/more succinct in haskell.
05:27:48 <maerwald> sullyj3: haskell is not very good for prototyping, so you have to lose some "habits" from python
05:28:19 <maerwald> a parser would be a good start as quchen said, because it's a very idiomatic thing in haskell
05:28:48 <quchen> Haskell does have Regex engines, they’re just not used very often since Regex is just not a very good way of writing safe and maintainable code
05:29:02 <maerwald> quchen: depends, most people abuse regex 
05:29:31 <quchen> No true Scotsman.
05:29:39 <maerwald> to the point that the recognizer and the input language are of different complexity
05:29:57 <sullyj3> I was hoping for something like `(takeTilMatch "\"") . (dropTilMatch "src=\"")
05:29:59 <maerwald> and then you end up saying "works most of the time" 
05:29:59 <sullyj3> `
05:31:45 <LiaoTao> sullyj3: dropWhile :: (a -> Bool) -> [a] ->[a] 
05:31:56 <LiaoTao> You could try that, I suppose
05:32:13 <quchen> That won’t work, because dropWhile matches on individual characters, not substrings.
05:32:20 <sullyj3> I'm familiar with dropWhile, but I'd have to be explicitly iterating over substrings
05:32:21 <LiaoTao> Guh
05:32:24 <LiaoTao> Nevermind then
05:32:37 <LiaoTao> Forgot he tried to parse for a substring
05:33:03 <quchen> sullyj3: You can’t make this more succinct than the Python solution, really. You can have something similar in Haskell, yes, but it wouldn’t be very idiomatic.
05:33:36 <maerwald> writing unidiomatic code makes me sad (in any language) and I get frustrated
05:33:50 <sullyj3> wait, just found breakOn :: Text -> Text -> (Text, Text) in Data.Text! yay!
05:33:58 <quchen> There’s also breakOnAll.
05:34:04 <LiaoTao> dirtyHack ('s' : 'r' : 'c' : '=' : '"' : xs) = xs 
05:34:05 <LiaoTao> :3
05:34:07 <quchen> You can use that to implement your solution, yes.
05:34:43 <sullyj3> LiaoTao, hahaha nice
05:34:58 <maerwald> LiaoTao: reminds me of pointer arithmetic and switch-case in C
05:35:00 <sullyj3> isn't there an extension for string literal pattern matching?
05:35:30 <quchen> That pattern is not a string literal, because of the trailing »xs«
05:37:45 <maerwald> he probably means something like: dirtyHack ("src" ++ xs) = ...
05:37:56 <cdornan_> quchen I would definitely recommend using regexes in Haskell -- I have found them to be highly useful
05:38:28 <maerwald> probably something you could hack up with viewPatterns or so
05:38:58 <cdornan_> packages to look at are pcre-heavy or regex
05:39:22 <sullyj3> maerwald, yep.
05:42:38 * hackage pandoc-citeproc 0.10.5 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.5 (JohnMacFarlane)
05:44:08 * hackage regex-with-pcre 1.0.1.3, regex 1.0.1.3, regex-examples 1.0.1.3 (ChrisDornan): https://qbin.io/u6jrz4aty
05:44:51 <blackdog> maerwald: if you're dealin with HTML, i would back up a step and use something that speaks HTML rather than trying to string-munge.
05:45:22 <blackdog> something like https://hackage.haskell.org/package/taggy-lens (or just taggy if you don't feel like dealing with lenses)
05:45:28 <maerwald> blackdog: hm? you probably mean sullyj3
05:47:20 <blackdog> maerwald: oh, oops. scrolled out of view :) cheers
05:49:26 <sullyj3> blackdog that looks useful for the future, thanks, but it looks like a learning investment, and I probably don't need it for my immediate task of finding missing images
05:49:50 <cdornan_> I second the recommendation to use HTML/XML hacking tools, btw
05:52:36 <blackdog> sullyj3: you might be surprised by how quickly using tools at the appropriate level pays off, but it's your code :) 
05:54:34 <sullyj3> I'm looking at the taggy docs, and struggling a bit.
05:54:49 <sullyj3> "If you want to parse a document as list of tags and go through it as some kind of stream by just picking what you need, head to Text.Taggy.Parser and take a look at Text.Taggy.Parser.taggyWith and Text.Taggy.Parser.run.
05:54:49 <sullyj3> "
05:54:59 <sullyj3> ok that sounds like what I need... *click*
05:55:17 <sullyj3> "Wow, this page is super empty"
05:55:34 <sullyj3> "The Bool lets you specify whether you want to convert HTML entities to their corresponding unicode character. (True means "yes convert")
05:55:34 <sullyj3> "
05:56:08 <Jinxit> i've imported Data.Map as Map, and now ghc is whining about map being ambiguous - shouldn't it be Map.map if i want that one?
05:56:26 <sullyj3> "ok, what's an HTML entity? Why do they have corresponding unicode characters? What are you talking about? What functions can I use on [Tag]?
05:57:31 <srk> Jinxit: you can use qualified import 
05:57:52 <srk> Jinxit: import qualified Data.Map as M
06:00:08 * hackage ginger 0.5.1.3 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.5.1.3 (TobiasDammers)
06:00:58 <Jinxit> srk: wait, then what does it do when you have 'as' without 'qualified'?
06:01:39 <srk> Jinxit: imports module and all of its contents into current context
06:01:50 <srk> Jinxit: which is why you get ambigous 'map' warnings
06:01:53 <Jinxit> oh, and the as is just a shorthand for when you need to qualify
06:01:56 <Jinxit> yeah
06:02:41 <sullyj3> also I just tried a `cabal install taggy` and the build failed: src/Text/Taggy/Renderer.hs:36:25: error:
06:02:42 <sullyj3>     • Couldn't match type ‘a0 -> MarkupM a0’ with ‘MarkupM ()’...
06:11:16 <c_wraith> sullyj3: that piece of documentation you quoted seems ok to me.  It requires you to know something about html, but it's something most people using html learn very quickly and it's something that really does impact the format of the data you're expecting.
06:11:58 <sullyj3> Yeah, I take back the bit about the entities, that was solved with a cursory google
06:12:46 <sullyj3> I'm still not happy about the fact that there are no examples of simple use cases, and I have to read different pages, without knowing what oreder to read them in from the outset.
06:13:32 <ph88^> is there an alternative to nub which is not O(n^2) ?
06:13:37 <blackdog> sullyj3: i'd usually recommend using stack rather than cabal, it tends to avoid those incompatibility problems. 
06:14:02 <blackdog> ph88^: it's called ordNub, but it's implemented in a bunch of places unfortunately
06:14:10 <blackdog> https://www.stackage.org/lts-8.16/hoogle?q=ordNub
06:14:29 <sullyj3> Like, I find out that taggyWith returns [Tag], but I have no idea what to do with that, so I have to figure out that I need to looks at the page for Data.Text.Taggy.Types, which for some reason includes the functions for get stuff out of the tags, as well as the type for the tags themselves..
06:15:21 <mreh> `Installing GHCJS (this will take a long time) ...`
06:15:58 <blackdog> sullyj3: did you have a look at the github readme?
06:16:15 <blackdog> https://github.com/alpmestan/taggy it really ought to be on the hackage page as well
06:16:49 <sullyj3> nope. thanks, that's exactly what I was looking for. It really ought.
06:17:29 <blackdog> sullyj3: agree that our discoverability is sometimes not as good as it could be. other tip - use hoogle liberally
06:17:56 <blackdog> https://www.stackage.org/lts-8.16/hoogle?q=Test.QuickCheck - if you wanted things you could do with Tag, you could run "+Taggy Tag -> a" 
06:18:17 <blackdog> the +Taggy restricts it to the Taggy package, then you're searching for a type signature "Tag -> a"
06:19:14 <sullyj3> Huh, cool. I haven't really used Stackage much. What's the difference between stackage and hackage>
06:19:15 <sullyj3> ?
06:20:02 <sullyj3> That +packagename thing is a great tip, I didn't know about that
06:20:11 <blackdog> sullyj3: so i should step carefully here - stackage is associated with stack, which is a way of avoiding some of the cabal problems you've hit.
06:20:24 <blackdog> it's not the only way, but i think it's probably the easiest.
06:20:32 <butterthebuddha> Do you stuff all your type definitions at the top of the file or just above the definition?
06:20:38 <butterthebuddha> Talking about functions here
06:20:48 <Rembane> Just above the function
06:20:52 <sullyj3> I've used stack before, I don't really like to, because it involves setting up a project when I'm usually trying to write a script.
06:20:53 <blackdog> but hoogle also exists for hackage https://www.haskell.org/hoogle/?hoogle=sort
06:20:54 <maerwald> blackdog: you can use stackage without stack
06:21:05 <blackdog> maerwald: Yes. but it's still associated with it.
06:21:11 <sullyj3> butterthebuddha definitely above the deinition
06:21:11 <maerwald> what does "associated" mean
06:21:35 <maerwald> one must be careful whether he recommends stackage or stack
06:21:36 <sullyj3> what maerwald said
06:21:36 <blackdog> sullyj3: you don't need to do that either - "stack runhaskell foo.hs" will just work, though it does bring you back to having non-isolated instances.
06:21:41 <butterthebuddha> Also, how do I print in Haskell?
06:21:44 <blackdog> the same people run it.
06:21:52 <butterthebuddha> Just wanna write some basic tests for some functions I'm working on
06:22:00 <maerwald> blackdog: well, I doubt that's relevant for most users
06:22:21 <blackdog> maerwald: it isn't, but people jump on me when i recommend stack, so i step carefully.
06:22:27 <sullyj3> blackdog so running stack runhaskell foo.hs is just using my globally cabal-installed libraries?
06:22:30 <maerwald> you're suggesting something as a solution which is not even part of the solution, which is why I find that confusing
06:23:00 <blackdog> maerwald: he explicitly asked. i was just showing stackage's hoogle because it's what i use.
06:23:25 <blackdog> sullyj3: no. it'll use stack-installed stuff. the difference there is that stack will install things from a globally curated set of packages which all compile together.
06:23:57 <blackdog> cabal will try to install the latest version that fits with what you have already, and it's possible to get into a situation where previously installed packages conflict with the thing you want to install.
06:24:13 <sullyj3> blackdog: Ohhh, ok. I didn't even know stack could do global installation. I thought it was purely a set-up-isolated-project things
06:24:57 <blackdog> sullyj3: it is remarkably versatile. you can even use it in a shebang-style script: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
06:25:09 <sullyj3> If I start stack installing random packages globally, will that conflict with my cabal installed stuff?
06:25:12 <blackdog> no.
06:25:33 <sullyj3> It'll just-work (tm)?
06:25:59 <sullyj3> oooh
06:26:04 <sullyj3> this looks pretty.
06:26:08 <sullyj3> thanks, I'm learning things
06:27:03 <blackdog> sullyj3: no worries, happy to help. eventually you'll start wanting to split things up into more isolated pieces, but for mucking around a global install is fine.
06:27:30 <blackdog> butterthebuddha: https://www.stackage.org/lts-8.16/hoogle?q=print
06:27:40 <sullyj3> Yeah, I also like globally installing stuff because I like to muck around in the repl sometimes.
06:27:46 <blackdog> butterthebuddha: which will give you something with type "print :: Show a => a -> IO ()"
06:27:59 <blackdog> sullyj3: you can get that too. just run "stack repl" in the project directory.
06:28:23 <sullyj3> is there a global repl?
06:28:48 <blackdog> yeah. stack repl, not in a stack project directory.
06:29:19 <sullyj3> cool
06:32:28 <maerwald> cabal can do the same thing
06:37:52 <ertes> yeah, but cabal-install is old…  it's too stable, too established…  too…  boring for the cool kids =)
06:40:09 <ertes> well, to be fair, most people who start using stack don't use it because it's cool, but because it's the first alternative they get presented
06:47:12 <maerwald> ertes: yes, it's mostly marketing
06:49:44 <ertes> the curation thing can be useful, but i'm not sure that's stack-bound
06:49:50 <ertes> you can probably use stackage with cabal-install
06:56:40 <hexagoxel> ertes: your shallow anti-stack rhetoric is almost as annoying as the stack fanboyism is.
06:57:29 <ertes> isn't it?  it's almost dual
07:06:19 <cocreature> hexagoxel: I almost hope one of them dies (and I don’t care which one) just so this stops
07:06:50 <cocreature> (one of stack & cabal)
07:07:24 <ertes> sorry, i'll let it go…  i'm not even that anti-stack, but it bothers me that there is rarely a fair comparison…  unfortunately fanboys/-girls are so loud that they drown everybody else
07:07:50 <lambdamu> to keep the discussion alive :D, stack does isolation by default and but shares where it can, while cabal sandboxes don't share anything across projects as far as i know 
07:08:20 <lambdamu> but yeah that people dont distinguish between stack and stackage is annoying
07:08:27 <cocreature> it’s just really annoying when everytime someone says “you can do X using tool Y” someone comes along saying that “you can do X using tool Y' way better!!!”
07:08:34 <lambdamu> stackage is by far the more valuable thing
07:08:39 <cocreature> regardless of whether they’re right or wrong. almost always it doesn’t help
07:08:50 <maerwald> cocreature: it helps to explain alternatives when done properly
07:09:05 <maerwald> lambdamu: yes
07:09:28 <cocreature> maerwald: if people are asking for alternatives then feel free to explain them but if they aren’t then just let them use what they want to use
07:09:51 <maerwald> cocreature: I am free to tell people about alternatives even when they don't ask, but if I feel it is appropriate
07:10:22 <cocreature> well ofc you are free to do so. but that doesn’t mean that it’s a good idea or helpful
07:10:22 <lambdamu> i moved on to nix and it would be cool if cabals nix-like reengineeing works out, there will probably be some confluence possible there
07:10:22 <maerwald> especially when there is an inconsistent picture about a tool
07:10:24 <zaquest> lambdamu, that's one problem i have with cabal-install, it doesn't share anything so build times are huge, cause you're bound to rebuild same package over and over again for each sandbox
07:11:06 <maerwald> and stack can handle ghc versions
07:14:46 * hexagoxel remembers more than one recent case of "stack setup" failing to work, not installing ghc without manual intervention.
07:15:41 <hexagoxel> (not from my own experience, but from people asking here)
07:16:11 <ertes> cocreature: do you think it's better to police when people can state opinions?  the reason i don't like stack has little to do with stack as a technology, but more with stack and related things (like intero, HPFFP and haskell-lang.org) as an aggressive marketing campaign that is trying to push everything else out of the market
07:16:38 <sproingie> stack's not too graceful about being interrupted.  if you stop it in the middle of installing ghc, you get a half-installed ghc
07:16:49 <sproingie> at least as of the last time i did that
07:17:03 <lambdamu> what is HPFFP?
07:17:11 <lambdamu> i wanna use it :D
07:17:19 <maerwald> xD
07:17:19 <sproingie> ertes: what market?  if there's competing ideas, let's see them.
07:17:49 <maerwald> sproingie: well, if you followed the cabal bug reports and blog posts that preceded/followed all those things, you would understand
07:18:01 <cocreature> ertes: I don’t think we need to police when they can state opinions especially since we can’t. I just don’t think expressing opinions about tool X when someone is looking for help with tool X is helpful most of the time.
07:18:16 <maerwald> cocreature: that is up to the situation
07:18:42 <cocreature> ertes: also just to be clear, I use both stack and cabal regularly so I don’t see myself belonging to either camp
07:19:02 <maerwald> neither are we
07:19:06 <sproingie> if you use stack, you use cabal anyway
07:19:09 <lpaste> jimmy pasted “Text” at http://lpaste.net/356027
07:19:11 <sullyj3> So, if I'm understanding ghc correctly, I have one part of my code that wants lazy text and one that doesn't. How do I resolve this?
07:19:16 <cocreature> sproingie: you use Cabal not cabal :)
07:19:20 <sullyj3> i'm jimmy
07:21:24 <lyxia> sullyj3: use fromStrict/toStrict
07:21:38 <sullyj3> :t fromStrict
07:21:39 <lambdabot> error:
07:21:39 <lambdabot>     • Variable not in scope: fromStrict
07:21:39 <lambdabot>     • Perhaps you meant one of these:
07:21:54 <cocreature> :t Text.fromStrict
07:21:55 <lambdabot> error:
07:21:55 <lambdabot>     Not in scope: ‘Text.fromStrict’
07:21:55 <lambdabot>     Perhaps you meant one of these:
07:22:00 <cocreature> @let import Data.Text
07:22:01 <ertes> cocreature: i understand the problem, but sometimes i just feel like stating my opinion in a sarcastic way, and it just happened to happen two days in a row
07:22:02 <lambdabot>  Defined.
07:22:04 <lyxia> @hoogle fromStrict
07:22:04 <lambdabot> Data.ByteString.Lazy fromStrict :: ByteString -> ByteString
07:22:04 <lambdabot> Data.ByteString.Lazy.Char8 fromStrict :: ByteString -> ByteString
07:22:05 <cocreature> :t Text.fromStrict
07:22:05 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
07:22:07 <lambdabot> error:
07:22:09 <lambdabot>     Not in scope: ‘Text.fromStrict’
07:22:11 <lambdabot>     Perhaps you meant one of these:
07:22:21 <cocreature> :t fromStrict
07:22:22 <lambdabot> error:
07:22:22 <lambdabot>     • Variable not in scope: fromStrict
07:22:22 <lambdabot>     • Perhaps you meant one of these:
07:22:27 <cocreature> I give up
07:22:27 <lambdamu> :t Data.Text.Lazy.fromStrict
07:22:29 <lambdabot> Text -> Data.Text.Internal.Lazy.Text
07:23:20 <ertes> :t length
07:23:22 <lambdabot> error:
07:23:22 <lambdabot>     Ambiguous occurrence ‘length’
07:23:22 <lambdabot>     It could refer to either ‘Data.List.length’,
07:23:23 <blackdog> maerwald: I really don't mind what experienced haskellers use. I'm sure there are good reasons to just use cabal too. However, it pretty reliably causes problems for newbies who are trying to concentrate on other things, and i'd rather not talk about extraneous stuff like package management.
07:23:25 <ertes> =)
07:23:45 <maerwald> blackdog: there are different experiences newcomers make with both tools
07:24:00 <ertes> blackdog: i can't confirm that
07:24:10 <blackdog> maerwald: for reference, i used cabal since it came out, i have a reasonable amount of experience with both systems.
07:24:11 <Tuplanolla> I had a worse experience with Stack myself, blackdog.
07:24:49 <blackdog> Tuplanolla: fair enough. You'd be the first person I've heard that from, though, and _every_ newbie I've taught (and there have been dozens) has complained about cabal.
07:25:03 <sullyj3> cocreature thanks haha
07:25:13 <lyxia> Many newcomers are extremely confused about .cabal vs stack.yaml files.
07:25:21 <Tuplanolla> It was very difficult to predict what Stack would do in various situations.
07:25:58 <ertes> blackdog: not from my own experience as a user (stack wasn't even around when i started), but from my experience with newcomers…  i teach haskell in an annual local workshop, and i always start with pure GHC, then with cabal-install, and apart from once (when some package broke upstream) it went smoothly
07:26:10 <Tuplanolla> That's especially annoying without a network connection or lots of storage capacity.
07:26:42 <blackdog> ertes: well, of course. Cabal wasn't around when i started :)
07:26:51 <sproingie> the packages that are cabal-installed for the workshop i'm sure are quite sympatico for the duration of the workshop
07:27:22 <ertes> blackdog: huh?  you mean you didn't know about cabal-install when you started?
07:27:23 <sproingie> maybe backpack will fix all of this
07:27:36 <blackdog> ertes: i mean i was programming in haskell for years before cabal was a thing.
07:27:45 <ertes> ah
07:28:46 <blackdog> sproingie: yes, that's exactly the point - it's the accumulation of entropy that kills you.
07:29:09 <blackdog> cabal sandbox was a big help for practitioners when it came out, but unfortunately added another thing that newbies had to know.
07:29:58 <sproingie> well, sandbox also removed a lot of things newbies would have to worry about.  or rather, relative newbies on their Nth project
07:30:12 <sproingie> i view stack the same way, rough edges and all
07:30:26 <LiaoTao> How long did it take for you guys to get productive in Haskell?
07:30:30 * LiaoTao isn't at that point yet
07:30:51 <blackdog> sproingie: yes, agreed. but i think with "stack runhaskell" and curated packages, you're much less likely to run into problems as a more-newbie-than-relative-newbie :)
07:31:04 <ertes> sproingie: the most common problem in my workshops is getting stuff installed on windows…  i'd love to run a little game programming workshop using something like gloss, but i'm afraid to take the risk, because there are almost always windows users
07:31:13 <sproingie> blackdog: oh definitely, stackage is very nice to have
07:31:46 <Tuplanolla> Gloss has worked wonderfully in our classes, where some students use Windows, ertes.
07:31:59 <Tuplanolla> Windows 10 doesn't count though.
07:32:17 <ertes> LiaoTao: a long time, but it was mostly because i've been fooling around too much…  i had learned most of the advanced concepts when i finally sat down to write an actual program, and it was incredibly difficult, because real programming takes more than just beautiful theory
07:33:31 <ertes> Tuplanolla: the problem is that i can't test it beforehand, and i constantly read about problems when people try to install stuff with foreign dependencies…  maybe it's not as bad as i imagine
07:33:38 <maerwald> I don't think you need a lot of advanced concepts to become productive at all
07:33:47 <sproingie> LiaoTao: i was doing various graph algorithms in haskell within a month or so of learning it.  never really managed to do full-size apps though, stuff like aeson and spock didn't exist then
07:34:23 <maerwald> maybe it's more the opposite
07:34:30 <Tuplanolla> For Gloss it should be sufficient to drop the appropriate library blobs into the project directory, ertes.
07:34:51 <Tuplanolla> I think there was one for FreeGLUT and one for something else.
07:35:01 <ertes> i see
07:35:55 <ertes> well, it's ok…  last time we did some web programming instead, using scotty =)
07:36:11 <sproingie> Tuplanolla: GLFW might be a better choice on windows
07:36:50 <Tuplanolla> Not using Windows would be the better choice, sproingie.
07:37:31 <sproingie> eh, depends where you're fitting your course in
07:38:19 <sproingie> tho one could always put together a VM for the course.  probably want to do that anyway
07:39:20 <ertes> i usually have between 6 and 9 hours, and i really don't want to waste two of them setting up virtualbox, getting an image to run and teaching the basics of a linux shell =)
07:39:52 <juri_> ave people install putty, and ssh into a VM?
07:40:02 <Tuplanolla> "What is SSH?"
07:40:05 <juri_> it's easy to clone a batch of VMs for a job.
07:40:09 <maerwald> ertes: what? techno stacks are cool these days
07:41:10 <maerwald> can't imagine you'd compile your haskell code without a container technology, inside your vm
07:41:28 <sproingie> if the course is bring-your-own-laptop, you make a virtual appliance, and tell them to install virtualbox before class
07:41:34 <ertes> maerwald: ironically i do that a lot =)
07:41:38 <sproingie> if you have a lab, then obvious solution is obvious
07:43:06 <ertes> sproingie: or i could just write a web app instead…  this works on windows without any extras
07:44:08 <sproingie> other than the hosting server, supporting multiple users
07:45:03 <sproingie> and stuff like gloss wouldn't be doable, unless someone goes and writes an html5 backend for it
07:47:08 * hackage scientific 0.3.4.14 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.14 (BasVanDijk)
07:48:08 <bhara_> does any body use haskell in their work here, what is it used for in production 
07:49:03 <maerwald> web apps
07:49:21 <sproingie> lots of places using it internally, e.g. facebook.  they tend not to hang out here tho.
07:49:57 <merlynfry> Could someone help me understand why this won't parse in GHCi? https://pastebin.com/4g3CT62a
07:50:02 <merlynfry> Thanks.
07:50:53 <juri_> I'm using a type reflector system to convert values in a made up language into values in haskell, but i have to use overlapping instances to handle lists VS strings. I'd like to make this safe, and not overlapping?
07:51:40 <sproingie> ghci wants definitions to be one-liners unless you use :{ and :}
07:51:53 <merlynfry> I am using :{ and :}
07:52:01 <merlynfry> It still won't parse
07:52:07 <pavonia> merlynfry: You need parentheses around x:xs
07:52:58 <merlynfry> Thank you very much :)
07:54:26 <sproingie> juri_: you might be interested in https://kseo.github.io/posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html
07:57:44 <sproingie> also a nice intro to type-level programming
08:03:32 <juri_> sproingie: exactly what i needed. :)
08:06:15 <Jinxit> pls send help, i wrangled this line until it did what i wanted, but i can't figure out how to rewrite it better http://lpaste.net/3386793497733365760
08:06:34 <bollu> quchen: ping
08:08:54 <sproingie> maybe eta-expand it a little
08:10:02 <sproingie> but eh, i can follow it, so maybe it doesn't need it
08:12:48 <Jinxit> the part i dislike is what i have to do to catch the errors
08:12:52 <Jinxit> return, Left and Right
08:13:01 <Jinxit> but idk if there's any better way to do it
08:13:19 <ertes> bhara_: i use it at work mostly where others would typically write a shell script or something like that
08:14:59 <Rembane> Jinxit: I'll take a look!
08:16:34 <Rembane> Jinxit: That's not too horrible, you can use fail and return if you don't like the words Left and Right, but it'll be the same complexity and amount of code.
08:17:04 <sproingie> Jinxit: you could maybe make it more generic with MonadExcept, but i couldn't say that'd make it any smaller
08:17:29 <danilo2> Hello guys! I've got a small, controversial question here. What are the advantages of using Data.Text over uboxed Vector of Chars? Chars handle well utf8. Moreover I need to make a lot of "slices" and Vectors allow me to do Slices O(1). I'm not processing text in any facnyc way - slices and char comparison is what I want. Why Text could suit better here?
08:17:38 <akt> bhara_: i'm using it for data crunching in a easy to use kind of way, the endusers of the applications are non-devs
08:17:57 <Rembane> danilo2: It's nicer to work with.
08:18:02 <sproingie> danilo2: not having to reinvent the dozens of useful utilities in Data.Text
08:19:08 <Tuplanolla> Sounds like you really want a rope, skip list or some other such thing, danilo2.
08:19:46 <danilo2> Rembane, sproingie : I undestand that reinventing is stupid etc. But as I said - I only need to compare some chars inside and make a LOT of slices. Making slices in Data.text is O(n) but in Vector of Chars O(1), which is much better for my use case. Is there anything else than lack of fancy text utilities that Im not thinking about ?
08:19:59 <sproingie> but if you're just processing chunks of raw data, you could get away with bytestring
08:21:25 <danilo2> Tuplanolla: interesting! Would you be so nice and elaborate a little more why Rope could be better tool here?
08:21:27 <sproingie> maybe Data.Rope would be ideal.  no idea about its quality, does look like it's implemented at a pretty low level
08:21:28 <Rembane> danilo2: My advice is: Prioritize convenience over speed until you need that performance.
08:21:47 <sproingie> hope you like your documentation in french
08:21:58 <danilo2> sproingie: its not raw data. Its a source code and I want to rememebtr some chunks of it in AST without copying the text
08:22:31 <danilo2> Rembane: I need that performance actually. But I understand why you tell so and I completely agree that convinence should normally be the priprity number 1
08:22:49 <Tuplanolla> I just base my recommendation on the observation that it tends to be, danilo2.
08:24:09 <Tuplanolla> Linear structures are almost always a bad fit for concatenative operations.
08:24:36 <Tuplanolla> File systems are a good example of this.
08:24:39 <danilo2> Tuplanolla: ok thanks! As I see Ropes are fingertrees with offsets of chunks of some data and that's very nice design overall. However I want to keep chunks of text in my custom tree (to be more precise - chunks of source code in a language's AST). 
08:25:14 <Tuplanolla> Is this read-only, danilo2?
08:26:26 <sproingie> if you truly want zero-copy you'll probably need mmap and some FFI, otherwise you're copying out of a buffer
08:27:05 <sproingie> assuming you can live with the one copy, a tree of bytestrings ought to do it
08:33:59 <danilo2> Tuplanolla: most of the time, but sometimes a small fragmetn of AST changes and its text is also affected (+ text of all the parent AST nodes)
08:34:35 <danilo2> sproingie: actually Data.Vector implements no copy splices if im not wrong
08:35:41 <sproingie> sure, i was just being overly expansive with the definition of "no copy"
08:36:12 <juri_> sproingie: ok, now to understand what you sent me... ;)
08:36:16 <Tuplanolla> I guess vector plus index set could work too, but I wouldn't bother, danilo2.
08:39:09 <danilo2> thank you guys! :)
08:39:27 <sproingie> juri_: i don't quite understand it all myself (those Proxy classes for one).  the extra method trick used in the prelude is pretty easy to follow though
08:39:58 <sproingie> though not terribly satisfying in terms of an API
08:41:07 <Ulrar> Mh, how do I create a record with a field named "data" ? It's to decode a piece of Json, I have no control over the name of that field
08:41:51 <juri_> I'm having trouble understanding that much. :)
08:43:16 <lyxia> Ulrar: If you're using the generic instances, mess with the options to convert the record field name to the JSON field name.
08:43:40 <Ulrar> lyxia: I'm justing httpJSONEither
08:43:58 <Ulrar> I've never used http-conduit before so I'm not really sure I know what I'm doing :D
08:44:58 <lyxia> Ulrar: what return type are you expecting
08:47:38 <Ulrar> lyxia: I want to define a record to represent it. It looks like that : {"data": {"token": "blah", ...}}
08:47:57 <Ulrar> I basically need to get the fields inside data, from httpJSONEither
08:48:19 <cocreature> just write a custom instance for FromJSON
08:49:21 <Ulrar> I don't need to define a record for taht ?
08:52:21 <Ulrar> Ah, I can do that by hand
08:52:23 <Ulrar> I see
08:52:24 <lyxia> You should define a type that represents your data and a FromJSON instance to convert to it, but the type doesn't have to exactly mirror the JSON schema.
08:53:59 <danilo2> Ok, I've got one more question regarding memory footprint. Why Data.Char takes 16 bytes of memory (on 64 bit system) when each char in utf32 can be encoded in just 4 bytes?
08:59:44 <Ulrar> So reading Data.Aeson's doc I see how to write the inside, but how do I tell it to look for that inside the "data" key ? The doc only seems to explain how to write a fromJSON for something that matches the record
09:01:39 <cocreature> danilo2: how are you measuring that? I think it should be something like 4bytes for the actual Char# and a pointer to it so 8+4=12 bytes on a 64bit system
09:02:23 <danilo2> cocreature: Im actually not measuring it, It's described here: https://wiki.haskell.org/GHC/Memory_Footprint
09:03:13 <cocreature> danilo2: ah yeah so it’s 1.5 words and they round up to word boundaries
09:03:21 <danilo2> cocreature: I would like to have it as 4bytes and store it in unboxed vector
09:03:27 <cocreature> danilo2: note that if you use an unboxed vector you won’t pay for the pointer
09:03:41 <cocreature> the pointer is the “box”
09:03:42 <danilo2> cocreature: that is what I'm wondering about
09:03:55 <cocreature> “unboxed” means that you don’t have that pointer
09:04:10 <danilo2> cocreature: yeah, I undestand it, however I was not sure if this table was showing boxed chars or just "Char#" s 
09:04:31 <danilo2> cocreature: great, if unbxed vectors of chars keep them in 4bytes each, thats perfect :)
09:05:07 <lyxia> Ulrar: use (.:) to access the field
09:05:36 <bitemyapp> ertes: maerwald do you really think being disruptive when someone is trying to help a new person is constructive?
09:05:38 <lyxia> Ulrar: parseJSON v = (v .: "data") >>= \v -> keepParsing v
09:05:42 <sproingie> if you're decoding a file into a vector of 4-byte chars ... you may as well just use Text
09:06:07 <bitemyapp> ertes: the hell with your opinions, the point of the conversation was to help the newbie asking a question, not for you to share your feelings and interrupt.
09:06:26 <maerwald> bitemyapp: *trying* or actually helping. Again: these are all nice theoretical questions, it depends on the situation
09:06:32 <bitemyapp> here's a situation:
09:06:38 <bitemyapp> when a new person is getting help from someone
09:06:40 <bitemyapp> don't interrupt
09:06:49 <bitemyapp> it's not complicated
09:07:01 <bitemyapp> you want to have a debate, do it on the mailing list or when it won't be disruptive
09:07:06 <maerwald> ok and so if the help is bad you still don't disrupt?
09:07:22 <bitemyapp> Good lord.
09:07:30 <maerwald> you started the theoretical questions
09:07:55 <bitemyapp> There was a new person getting help, they stopped getting help and got lost in the drift because you and ertes interrupted.
09:08:04 <bitemyapp> I'm asking you not to do that again, it's extremely self-centered.
09:09:20 <afhole> Hi there, wondering if someone can help me with a Codewars challenge to implement `isoUnMaybe :: ISO (Maybe a) (Maybe b) -> ISO a b` where `type ISO a b = (a -> b, b -> a)`
09:09:21 <bitemyapp> Cale: this is why the other channel exists.
09:10:32 <maerwald> bitemyapp: is "not disrupting" a channel policy here? If not, then I will respectfully disagree with you and say that it depends on the situation, e.g. when misinformation is spread
09:10:34 <sproingie> guessing ISO is short for Isomorphism
09:10:39 <afhole> Indeed
09:10:57 <afhole> "We will walk through what is isomorphism, and define some common isomorphism." https://www.codewars.com/kata/isomorphism/train/haskell
09:11:55 <bitemyapp> maerwald: okay, first off
09:12:01 <afhole> The reverse I could understand `isoMaybe :: ISO a b -> ISO (Maybe a) (Maybe b)`
09:12:03 <afhole> ` isoMaybe (ab, ba) = (fmap ab, fmap ba)`
09:12:03 <sproingie> well the comment is that isoUnMaybe is impossible in general, so you need only find one counterexample
09:12:11 <bitemyapp> maerwald: I was skeptical about Stack from the start because I didn't like the idea of having a split in the tool ecosystem
09:12:20 <bitemyapp> maerwald: however, I tested it with new people, and it solved a lot of problems for them.
09:12:24 <sproingie> and perhaps one working example for the spirit of the thing.  i don't know what counts for the kata
09:12:28 <bitemyapp> maerwald: further, it's proven to be extremely useful at work
09:12:45 <bitemyapp> maerwald: secondly, that you need a channel policy to behave like an adult says more about you than anyone else
09:13:01 <bitemyapp> maerwald: people getting the help they need matters more than your ego
09:13:02 <maerwald> bitemyapp: ok, the second ad hominem thing you throw to me, I'll be off then
09:13:13 <sproingie> public scolding is rarely productive
09:14:01 <Tuplanolla> Did I miss something?
09:14:07 <afhole> sproingie: I'm a bit lost to be honest - does that mean I could ignore the case where the ISO (Maybe a) (Maybe b) returns Nothing?
09:14:31 <maerwald> Tuplanolla: just a lot of ad-hominem stuff
09:15:37 <bitemyapp> Tuplanolla: a new person was getting help earlier
09:15:53 <bitemyapp> Tuplanolla: stack was mentioned, maerwald leapt in, interrupted, start debating stack with the person helping them
09:16:21 <bitemyapp> Tuplanolla: new person stopped getting help and the assistance died at that point
09:16:35 <bitemyapp> Tuplanolla: I see it here _a lot_ and it's precisely why I started a separate channel for people to get help in.
09:17:17 <brachiel> bitemyapp: what's the channel?
09:17:21 <bitemyapp> #haskell-beginners
09:17:24 <brachiel> neato
09:17:35 <bitemyapp> Not strictly for beginners per se, just focused on getting/giving help.
09:17:46 <Tuplanolla> Okay, sure. This is not just a support channel.
09:18:21 <bitemyapp> Tuplanolla: it's also not Valhalla where dead battles can be daily relived at the expense of beginners.
09:18:34 <sproingie> afhole: yeah since it returns an ISO a b and not a Maybe ISO a b, there's nothing you can do with a Nothing on either side
09:18:36 <bitemyapp> It is reprehensible that this community cares so little about helping people that need it.
09:18:42 <hpc> technically valhalla is a place of rest
09:18:45 * hpc ducks
09:19:02 * maerwald checks on wikipedia
09:19:15 <bitemyapp> the arguing can happen literally anywhere, any time, with anyone on this channel
09:19:21 <sproingie> let's have #haskell-drama where we can move this little pie fight
09:19:31 <afhole> sproingie: I'm thinking I have to call the Maybe a and Maybe b and match the Just result?
09:19:40 <bitemyapp> I am asking you to care at least a teensy bit about someone else so that you won't revisit the argument at the expense of someone getting help.
09:19:47 <lyxia> afhole: I think the point is that isoUnMaybe is not possible
09:19:54 <maerwald> well, this is exactly the aggressive marketing we talked about earlier
09:19:59 <ReinH> So, if we were to rank channel disruptions in the past 20 minutes...
09:20:13 <sproingie> afhole: sure, but if you have ISO Nothing (Just 123), then you have no value for 'a' you can return
09:20:15 <MitchellSalad> bitemyapp: Hm, I don't think of the haskell community as particularly hostile to beginners (though there are some bad actors around)
09:20:31 <MitchellSalad> however I don't lurk in IRC very often
09:20:52 <sproingie> afhole: now if it were Maybe (ISO a b), then you'd just return a Nothing
09:21:03 <bitemyapp> There's an entire separate fragment community because someone was hostile to a new person on the mailing list, are you serious?
09:21:03 <ReinH> Only one of those disruptions involved repeated ad hominem attacks
09:21:30 <Tuplanolla> You can call them insults.
09:21:34 <sproingie> afhole: honestly i don't know what it's asking you to do with it, but the comment suggests that's an expected impossible case
09:21:46 <ReinH> bitemyapp regularly shits on other communities, gets called out for it, and deletes his tweets and reddit comments. He is not a credible judge of who is hostile to people.
09:22:24 <afhole> I think it's a (Maybe a-> Maybe b) and a (Maybe b -> Maybe a) so I could call it with a Just value and match a Just that is returned
09:22:41 <MitchellSalad> bitemyapp: oh, I didn't hear about that. What is the separate fragment community?
09:22:56 <maerwald> also, I didn't even disagree that we sort of _derailed_ with that earlier disruption, but that's not because of disruption per se, so I really like to disagree that "never disrupt someone, who is trying to help". It really depends and sometimes we make mistakes and derail, yes.
09:22:57 <bitemyapp> ReinH: 1. Not in a long time 2. You really need to let go of the animus you have for me.
09:23:03 <afhole> I tried fromJust but it gets fed a nothing and crashes. Glad it's not just me confused by the instructions.
09:23:17 <bitemyapp> Also, deletes? The only time I've deleted a tweet was on Gershom's advice and that was a long time ago.
09:23:18 <afhole> It seems to want some implantation to satisfy the tests
09:23:22 <sproingie> reddit and SO would be a couple of the other communities
09:23:43 <sproingie> (in haskell-land, no idea who's "dissing" who, nor any care)
09:24:13 <MitchellSalad> sproingie: are those different communities or just different interfaces to the same community? :)
09:24:24 <ReinH> bitemyapp: Ok, how about you don't go around accusing others of not caring about people
09:24:28 <sproingie> different communities with lots of overlap
09:24:29 <Tuplanolla> I'll leave you to sort it out.
09:24:32 <Rembane> afhole: I think fmap could be useful.
09:24:35 <bitemyapp> No I mean an actual separate community but I'm not trying to put a spotlight on them.
09:24:44 <sproingie> {-# LANGUAGE IncoherentCommunities #-}
09:24:51 <bitemyapp> I think they have their own thing going and I don't want to (potentially) disrupt that
09:25:01 <quchen> bollu1: pong
09:25:21 <MitchellSalad> bitemyapp: I'm confused, heh
09:25:24 <bitemyapp> ReinH: There's a conversation to be had about what's useful and constructive
09:25:55 <bitemyapp> ReinH: however, it takes a real stretch to believe I don't care about other people. I'd give all the community stuff up and focus on doing something B2B if I didn't care.
09:25:56 <ReinH> Yes, someone should have that conversation with you.
09:26:14 <ReinH> bitemyapp: I didn't say that about you, I said you said that to someone else
09:26:15 <ReinH> which you did
09:26:17 <ReinH> a few minutes ago
09:26:38 <bitemyapp> ReinH: we can't have a constructive conversation right now, partly because you _really_ don't like me and can't keep it out of how you're talking.
09:26:54 <ReinH> Oh, there's no chance we could have a constructive conversation
09:27:03 <bitemyapp> ReinH: if you can get your hatred down a couple pegs, we could talk on the phone sometime as I think there are some unresolved issues, but here and now - there's not much point.
09:27:19 <bitemyapp> Okay, then I'll leave it here. Be well.
09:28:07 <lambdamu> There is a new separate haskell community? And we don't mention them in order to not disrupt there development?
09:28:30 <sproingie> like a lost amazon tribe of functional programmers
09:28:46 <lambdamu> intriguing
09:28:56 <afhole> I'm confused if ISO (Maybe a) (Maybe b) is (Maybe a -> Maybe b, Maybe b -> Maybe a) or Maybe (a -> b). I thought it was the former
09:29:19 <MitchellSalad> afhole: it is the former
09:29:26 <afhole> Cool
09:29:47 <ReinH> bitemyapp: you repeatedly lied about me in an attempt to defame me and directed a pack of alt-right assholes to harass me on twitter. So no, we are not going to have a nice chat and patch things up.
09:29:54 <MitchellSalad> afhole: though that isomorphism clearly doesn't exist :P
09:30:14 <sproingie> the ultimate problem is if you have a Maybe a and you pass it Nothing, there's no value of a you can yield
09:30:18 <bitemyapp> ReinH: I honestly have no idea what you're talking about
09:30:36 <afhole> That's apparently what I'm struggling with, I just can't work out what implementation the tests are expecting
09:30:38 <bitemyapp> ReinH: fact is, I haven't thought of you and didn't remember you existed until recently, there was a couple year gap there.
09:30:55 <quchen> ReinH, bitemyapp: maybe don’t do this in here :-x
09:30:57 <bitemyapp> last time would've been when you had that job where you were a scrum master and didn't really work, which was years ago
09:31:28 <sproingie> given how some other examples are using Error, i suspect it looks something like isoUnMaybe Nothing _ = error "no soup for you!"
09:31:36 <brachiel> afhole: I didnt' get the beginning of the question. codewars?
09:31:37 <sproingie> (likewise for the other arg)
09:32:03 <afhole> brachiel: Yes, an exercise to teach isomorphism https://www.codewars.com/kata/isomorphism/train/haskell
09:32:05 <bitemyapp> ReinH: If you're getting harassed by assholes on Twitter, you certainly have my sympathies as it's something I've put up with for about 3 years.
09:32:08 <MitchellSalad> bitemyapp: okay, i think you went a bit too far there, can we please end this awkward public fight?
09:32:21 <Ulrar> lyxia: Thanks ! It seems to compile, that's a good start.
09:32:33 <ReinH> Oh, it was almost exactly a year ago, but I have no intention of relitigating it with you right now.
09:32:36 <bitemyapp> MitchellSalad: I'm not trying to upset anyone, I'm speaking frankly.
09:33:00 <MitchellSalad> bitemyapp: and I too am speaking frankly when I say this fight should end now
09:33:08 <MitchellSalad> just move it to /query
09:33:26 <afhole> The args I think are not Maybes but ISO from maybe to maybe. So I think I have to call them and match the result, and maybe error if the result is nothing
09:38:09 <sproingie> there is no total function from Maybe a -> a
09:38:13 <ReinH> afhole: you're talking about the one that lifts an ISO a b to an ISO (Maybe a) (Maybe b)?
09:38:21 <ReinH> There doesn't need to be
09:38:30 <ReinH> it sends Justs to Justs and Nothing to Nothing, and vice versa
09:39:08 <ReinH> If there's an iso from a to b then there is an iso from a + 1 to b + 1 that sends 1 to itself and vice versa.
09:40:00 <sproingie> i'm looking at isoUnMaybe :: ISO (Maybe a) (Maybe b) -> ISO a b
09:40:22 <afhole> That's the one
09:40:53 <sproingie> which can't do anything in the face of Nothing.  and going by the comment, isn't supposed to
09:41:03 <quchen> That sounds absurd.
09:41:10 <sproingie> quchen: ISWYDT
09:42:56 <afhole> The best I can manage is to match the nothing and error but the tests still send it nothing so it crashes
09:43:16 <quchen> There is no Iso (Maybe a) (Maybe b).
09:44:05 <quchen> There is (Maybe a -> Maybe b, Maybe b -> Maybe a), namely (const Nothing, const Nothing), but that’s not an isomorphism.
09:44:30 <ReinH> quchen: there
09:44:42 <ReinH> quchen: there is, *given an iso a b*
09:44:45 <sproingie> you can use absurd, it'll only blow up when you try to do something with it
09:45:12 <quchen> Ah! Well then sure, you have (fmap iso, fmap osi).
09:45:15 <sproingie> but if you're matching ISO _ _ you're still fine
09:45:44 <ReinH> quchen: yes, it's a specialization of liftISO :: Functor f => ISO a b -> ISO (f a) (f b)
09:45:59 <ReinH> which is an iso because of the functor laws
09:46:25 <lyxia> isUnMaybe (f, f') = (g f f', g f' f) where g f f' a = case f a of Just b -> b ; Nothing -> fromJust (f Nothing)  -- afhole 
09:47:40 <ReinH> An ISO (Maybe a) (Maybe b) must send Nothing to Nothing because it can't discriminate members of a or b (b/c parametric polymorphism)
09:48:18 <glguy> ReinH: Well, only if that's forall a and b, but if we happen to have an iso of that form where it was consturcted with a known a and b then there wouldn't be such a restriction
09:48:40 <ReinH> isoUnMaybe :: ISO (Maybe a) (Maybe b) -> ISO a b
09:48:44 <glguy> that's fine
09:48:44 <ReinH> It is forall a b.
09:48:46 <glguy> no
09:49:01 <glguy> the forall a b is on the function, not the original creation of that argument
09:49:22 <glguy> so I could make an   Iso (Maybe Int) (Maybe Word)   and then apply that function to it
09:49:22 <lyxia> Just () <-> Nothing ; Nothing <-> Just Proxy   is a perfectly fine bijection between Maybe () and Maybe (Proxy ())
09:49:28 <glguy> the function wouldn't know that I used Int and Word
09:49:41 <ReinH> glguy: Right, caller chooses, brain fart.
09:49:57 <afhole> lyxia: Tried you suggestion but "  Couldn't match type `a' with `Maybe a'"
09:50:05 <brachiel> afhole: if you get Nothing from the Iso ab :: Maybe a -> Maybe b, for some a, then maybe ab Nothing must give a valid b, no?
09:50:18 <ReinH> glguy: I'm thinking of the rank 2 version.
09:50:30 <lyxia> afhole: ah, it should have been "case f (Just a) of" ...
09:50:31 <glguy> ReinH: Yeah, then we'd have some more restrictions, I agree
09:50:56 <lyxia> afhole: it can also be simplified because I actually don't use the second argument of g
09:51:09 <glguy> I think we should be able to write this isoUnMaybe function, actually (and lyxia might already have done so above)
09:52:09 <MitchellSalad> isoUnMaybe is partial, but would only fail if the 'Iso (Maybe a) (Maybe b)' is not actually an isomorphism
09:52:13 <lyxia> the part that may be confusing is that isUnMaybe does not have to be an isomorphism between isomorphism
09:52:18 <MitchellSalad> so using 'error' is fine here
09:52:24 <afhole> Oooh we have a winner lyxia ! `isoUnMaybe (f, f') = (g f f', g f' f) where g f f' a = case f (Just a) of Just b -> b ; Nothing -> fromJust (f Nothing)`
09:52:34 <afhole> Now I just need to try and understand it...
09:52:46 <afhole> Is it just undefined for the case where the iso returns nothing?
09:53:13 <ReinH> Let's say we send Just () <-> Nothing.
09:53:15 <jophish> What's the nicest way of importing a module for use with ghc -e
09:53:16 <glguy> There are two cases, either Nothing is isomorphic to Nothing and Just a is isomorphic to Just b
09:53:21 <glguy> so we ignore the nothings
09:53:27 <lyxia> afhole: Sorry for not letting you figure this one on your own
09:53:38 * hackage choice 0.2.1 - A solution to boolean blindness.  https://hackage.haskell.org/package/choice-0.2.1 (MathieuBoespflug)
09:53:47 <glguy> or if there is some Just a that is mapped to Nothing, we keep going to the non-nothing case, taking one more step
09:54:07 <afhole> I was close to clicking 'unlock solutions' to be honest so I think I'm still better off... Just
09:55:09 <asdf_> hi
09:55:18 <lambdabot> Hello.
09:55:26 <ReinH> glguy: So it picks a permutation that "lines up" the Nothings
09:55:28 <asdf_> hi
09:55:55 <ReinH> if we send a to Nothing and Nothing to b then we can send a to b and Nothing to Nothing
09:56:07 <Jinxit> how do you drop a part of a monad transformer stack? like going from StateT a (Except e) to StateT a Identity
09:56:30 <glguy> :t mapStateT
09:56:31 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
09:57:00 <MitchellSalad> is that the specific stack you are working with, or just an example?
09:57:01 <quchen> Jinxit: You’ll have to spell out your special case for each different combination of transformers, there is no generic way to do this
09:57:07 <MitchellSalad> it depends on the particular stack
09:57:21 <Jinxit> i'm fine with that, however it's actually an RWST and not StateT
09:57:33 <MitchellSalad> :t mapRWST
09:57:35 <lambdabot> (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
09:57:36 <Jinxit> but yeah
09:57:39 <Jinxit> i was about to say
09:57:41 <Jinxit> that seems to be a thing
09:57:43 <ReinH> glguy: am I reading that right?
09:57:49 <glguy> ReinH: yeah
09:58:15 <Jinxit> what happens if i drop the inner Except and it has an exception?
09:58:30 <Jinxit> it shouldn't in my case but i'm curious
09:58:32 <glguy> Jinxit: You'll have to handle that case yourself
09:58:44 <glguy> in the function you write as the argument to mapRWST
09:59:07 <Jinxit> aha
09:59:11 <brachiel> afhole: Nothing is just a special element of all the elements the set "Maybe a" can have. It's just weird because it has a special representation, but is not "different" from, let's say "Just 1". Every element of "Maybe a" is mapped to one elment to "Maybe b". If some Element of "Maybe a" is mapped to "Nothing", it leaves a "hole" in the set of the "Maybe b"'s. This hole is filled by what "Nothing" of "Maybe a" is mapped to.
09:59:12 <afhole> Well thanks for the assistance everyone, I think I'm in way over my head. Will try to understand lyxia's solution
09:59:16 <sproingie> i'd think if you drop the Except, you lose exceptions
09:59:19 <MitchellSalad> :t mapRWST runExceptT
09:59:21 <lambdabot> error:
09:59:21 <lambdabot>     • Couldn't match type ‘Either e (a, s, w)’ with ‘(b, s, w')’
09:59:21 <lambdabot>       Expected type: ExceptT e n (a, s, w) -> n (b, s, w')
09:59:44 <monochrom> You're looking at Except e (a, s, w) -> Identity (b, s, w') so you will handle the exception there. Maybe by using b wisely.
09:59:49 <mbw> If I want to pass a storable vector to a foreign function which modifies its arguments, and assuming I want the haskell wrapper to be referentially transparent, do I need to work with mutable arrays (because of evaluation order etc.), or would it suffice to pass a copy of the storable vector to the c function?
10:00:08 <Jinxit> yeah that's what i'll do monochrom, thanks
10:00:23 <glguy> sproingie: No, because mapRWST doesn't know anything about ExceptT. There won't be any implicit behavior
10:01:38 <glguy> sproingie: The creator of the value with type "ExceptT e (a,s,w) -> Identity (b,s,w)" will have to define the behavior for all values of that argument
10:01:53 <glguy> One way would be to choose b to be "Either e a"
10:02:17 <Jinxit> but wait, if i have this one function that's RWST .. Identity a, can i use it inside an RWST .. (Except e) a?
10:02:24 <glguy> and perhaps make up some values s and w
10:02:26 <Jinxit> i figured it would be a nice way to signal that "this can't fail"
10:02:35 <afhole> I don't even understand all of the syntax in lyxia's answer to be honest
10:02:37 <Jinxit> but maybe that's the wrong way to go about it
10:03:04 <glguy> Jinxit: sure, if you have an    RWST ... Identity a , you can make an   RWST ... (ExceptT e) a
10:03:09 <glguy> That direction is easier
10:03:26 <Jinxit> can i just use it transparently?
10:03:37 <glguy> No, but you can use mapRWST again
10:03:40 <Jinxit> ah
10:04:08 * hackage prettyprinter 1.0.1 - A modern, easy to use, well-documented, extensible prettyprinter.  https://hackage.haskell.org/package/prettyprinter-1.0.1 (quchen)
10:04:11 <Jinxit> ok i think i'm on the right track but i'll have to restructure a bit
10:04:16 <Jinxit> thanks for the help everyone
10:04:32 <monochrom> :)
10:04:41 <glguy> quchen: Yay
10:04:50 <quchen> Yay?
10:04:52 <glguy> I've been watching for the updated version
10:05:01 <quchen> glguy: What specifically?
10:05:07 <glguy> prettyprinter
10:05:15 <quchen> Should have just asked me for a quicker release if you wanted some change earlier :-)
10:05:39 <glguy> quchen: I didn't want to use up any nagging point on that :-p
10:05:44 <quchen> Hehe okay
10:05:53 <quchen> Just out of curiosity, what were you waiting for?
10:06:05 <glguy> buildreadme to not be built
10:06:16 * glguy uploads the docs with pretty source highlighting for prettyprinter
10:06:39 <quchen> OOoh.
10:06:45 <quchen> Right. Sorry again.
10:07:04 <quchen> Waaait – you’re the documentation autogenerator of Hackage??
10:07:15 <monochrom> Hahaha
10:07:26 <glguy> No, there's an automated system, but it uses the old-timey source highlighting
10:08:00 <Jinxit> this one poor guy manually 'generating' the documentation
10:08:06 <Jinxit> hackagebot writes a message
10:08:10 <Jinxit> "oh here we go again.."
10:08:24 <quchen> I hope you’re using Haddock to help you, at least! Otherwise I think it would be way too much work.
10:08:28 <quchen> Coding HTML by hand and everything
10:08:33 <glguy> Nope, hand-crafted HTML
10:08:45 <glguy> My WPM is insane
10:09:49 <quchen> I’m impressed
10:10:43 <monochrom> The line between manual and auto is blurred when Optimus Prime makes a website.
10:10:56 <glguy> Sure, he's an Autobot
10:11:00 <quchen> Woo it’s on Stackage now
10:11:36 <quchen> The update isn’t yet, though. Oh well, next weekend then
10:13:04 <quchen> I’m really glad people like it, I was fearing a tired response a la »not another one«
10:13:11 <quchen> So far feedback has been very positive
10:14:30 <glguy> quchen: Would it be possible to write:   (Doc ann -> Doc bnn) -> (Doc ann -> Doc bnn) such that the transformation was applied as a bottom-up transformation? High-level goal: data DocPart = Heading | Definition | Text; someDoc :: Doc DocPart
10:14:45 <glguy> and then I would want to turn   Doc DocPart -> Doc AnsiStuff    later
10:17:19 <quchen> Bottom up seems hard given the Doc type is really just a tree
10:17:33 <quchen> glguy: I don’t understand the goal though, could you explain it a bit more?
10:17:41 <quchen> Is this about combining documents with different kinds of annotations?
10:18:05 <glguy> I want to annotate my docs with a type that describes what high-level kind of thing the Doc is for
10:18:13 <glguy> and then later transform that to annotations about how to render it
10:18:55 <glguy> Another approach would be to pass around a record while building the doc: data Style a = Style { isHeader :: Doc a -> Doc a, isText :: Doc a -> Doc a, ... }
10:19:02 <quchen> Oh sure, that’s a good idea to do. You can use reAnnotate for that, reAnnotate :: (semantic -> presentational) -> Doc semantic -> Doc presentational
10:19:27 <glguy> Perfect, that's what I was looking for, thanks
10:19:44 <quchen> That’s what I do: Doc has semantic annotations, I then layout that to a SimpleDocStream (with semantic annotations), and only the rendering function then converts to e.g. »make keywords green«
10:20:05 <glguy> quchen: It looks like I might not be able to make values of AnsiTerminal myself
10:20:14 <quchen> Does it?
10:20:18 <quchen> Did I forget releasing that?
10:20:18 <glguy> can I only make them via definitions like 'color'?
10:20:30 <quchen> Owww. Woops! I just changed that, but did not upload it yet.
10:23:56 <quchen> glguy: That was actually intentional, but turned out to be a bad idea.
10:25:30 <quchen> Done
10:26:08 * hackage prettyprinter-ansi-terminal 1.0.1 - ANSI terminal backend for the »prettyprinter« package.  https://hackage.haskell.org/package/prettyprinter-ansi-terminal-1.0.1 (quchen)
10:27:34 <glguy> great, thanks
10:35:53 <glguy> quchen: what about (a -> Maybe b) -> Doc a -> Doc b
10:36:21 <glguy> supposing I want to not generate ANSI modes for some annotations
10:36:26 <quchen> alterAnnotations
10:36:29 <quchen> :-)
10:36:52 <quchen> Should be just below
10:37:17 <quchen> Maybe I should make that (a -> [b]) there if one wanted to add multiple annotations
10:37:20 <glguy> ok, I'll defer my questions until I'm back on my computer with haddock in front of me:)
10:37:23 <quchen> Hmmmmmm!
10:37:30 <quchen> glguy: Hah don’t worry, glad to help :-
10:37:31 <quchen> )
10:37:57 <quchen> I just added it in the last patch as well
10:42:16 <afhole> I'm scared to ask about `isoEU :: ISO (Either [()] ()) (Either [()] Void)` - presumably it's not possible to even represent () -> Void?
10:42:42 <afhole> I guess this must be partial too
10:42:54 <quchen> () -> Void does not exist, yes.
10:43:16 <ertes> afhole: you can't represent (-> Void) anything, except (Void -> Void)
10:43:50 <quchen> afhole: Logically, Void does not exist. The only functions returning a Void are those that cannot produce a value because one of their inputs can’t exist in the first place.
10:43:59 <quchen> Such as (Void -> Void), which exists.
10:44:06 <quchen> And Int -> Void -> Double -> Void.
10:44:25 <ertes> afhole: type Not a = a -> Void  -- speaking in terms of the curry-howard correspondence, if 'a' is a provable proposition (i.e. there is a value of type 'a'), then (Not a) should not be provable
10:44:52 <ertes> so if 'a' is non-empty, then (a -> Void) must be empty
10:49:53 <Ulrar> So I built and installed my library, but when I try to use it I get undefined references on the fromJSON instance of my data type, something about closure
10:50:14 <Ulrar> Any idea what that can be ? Google only seems to speak about interfacing with C++, which is not what I'm doing as far as I know
10:50:35 <cocreature> Ulrar: can you show us the full error?
10:50:39 <Ulrar> Yep
10:51:59 <Ulrar> if I manage to open the paste thingy
10:52:24 <cocreature> lpaste seems to be really slow these days if it works at all. you might want to try another paste service
10:52:27 <Ulrar> Well it won't load so I used something else
10:52:39 <Ulrar> https://paste.swordarmor.fr/2BBl
10:52:59 <ertes> github gists have reasonable haskell highlighting
10:53:24 <Ulrar> Well it's a linking error anyway
10:53:29 <sm> I guess we need to start recommending that one
10:53:30 <Ulrar> So the coloring won't matter
10:54:39 <cocreature> Ulrar: check that _all_ modules are listed in either other-modules or exposed-modules
10:55:01 <Ulrar> cocreature: In the library you mean ?
10:55:06 <Ulrar> Ah
10:55:18 <Ulrar> Okay yeah, the Types module isn't listed
10:55:22 <Ulrar> that makes sense
10:55:29 <cocreature> it’s a terrible error message tbh
10:56:06 <Ulrar> Works fine now
10:56:11 <cocreature> luckily cabal 2.0 + ghc 8.2 will provided a better one afaik and I think stack does too, at least in some cases
10:56:15 <Ulrar> Well thanks, I wouldn't have guessed taht one
10:56:34 <manbitsdog> Is there a way to -Wall on a stack build
10:56:51 <cocreature> manbitsdog: yes, add it to ghc-options in your cabal file
10:56:59 <ertes> i haven't checked, but doesn't 'cabal check' check that?
10:57:28 <cocreature> ertes: I don’t think so
10:57:50 <sproingie> i wish exposed-modules had a wildcard syntax
10:58:08 <cocreature> sproingie: hpack supports that afaik
10:58:11 <iqubic> > fmap (+1) (1,2)
10:58:13 <lambdabot>  (1,3)
10:58:20 <iqubic> Wait, what??
10:58:24 <manbitsdog> Does it show up in  log file somewhere?  
10:59:07 <sproingie> hpack is new to me.  the format looks nice.
10:59:11 <cocreature> manbitsdog: you need to explicitely pass the target to stack, e.g., "stack build libraryname". otherwise stack doesn’t show the output since the output of different targets would be interleaved
10:59:50 <manbitsdog> Got it
11:00:23 <cocreature> ertes: ftr this is the cabal issue for this https://github.com/haskell/cabal/issues/1746
11:00:34 <cocreature> I’m not quite sure why it’s still open. the PRs seem to be merged
11:00:35 <quchen> glguy: quick survey: Pretty (Doc ann) – good or bad idea?
11:00:39 <ertes> iqubic: fmap :: (a -> b) -> (c, a) -> (c, b)
11:00:57 * quchen is thinking it’s bad, because it has to traverse the entire Doc to unannotate it
11:01:02 <quchen> Pitfall without much benefit
11:01:45 <ertes> cocreature: ah
11:02:26 <ertes> i've learned that in most cases linking errors are related to missing modules in other-modules =)
11:02:33 <cocreature> quchen: -1 from me
11:02:41 <cocreature> ertes: you’ve clearly not worked enough with the FFI :)
11:02:58 <quchen> cocreature: What is -1? Keep or drop the instance?
11:03:08 <cocreature> quchen: drop it
11:03:18 <quchen> My confirmation bias likes your opinion
11:03:56 <ertes> cocreature: indeed…  i try to avoid that =)
11:05:21 <sproingie> beats linking errors in c++, caused by typos
11:05:54 <sproingie> at least the identifiers in c++ errors are demangled these days
11:06:45 <cocreature> ertes: I learned quickly that maintaining Haskell bindings for LLVM is a good way to see a lot of linker errors
11:10:03 <ertes> cocreature: there seems to be a trend to just dump all the third-party C files into the haskell project itself and let cabal compile them in order to avoid that particular issue…  not sure if it's a viable option with LLVM though
11:10:33 <cocreature> I don’t think that’s a good idea for LLVM
11:10:47 <cocreature> it’s huge
11:10:53 <Tuplanolla> Why do we have linkers in the first place?
11:11:01 <sproingie> Tuplanolla: so we can have separate compilation
11:11:11 <ertes> so that we can have linker errors
11:11:24 <Tuplanolla> That seems like a non-answer to me, sproingie.
11:11:43 <sproingie> no, that's what linkers do.  we have separate compilation, something needs to put them together
11:11:54 <sproingie> why linkers are still so farking primitive is another question
11:12:11 <Tuplanolla> It could be just another compiler stage.
11:12:21 <sproingie> it pretty much is another compiler stage
11:12:43 <sproingie> just one that's been kept more separate for hysterical raisins
11:12:44 <ertes> i don't think the trouble is with linkers, but with a lack in standards for finding and linking libraries
11:13:03 <EvanR> linkers link between output of any and all compilers of all languages
11:13:17 <sproingie> as long as those languages are C
11:13:19 <Jinxit> to return to my earlier query, it seems impossible to me to write Except e (a, s, w) -> Identity (b, s, w'); since s and w' are in the successful computation
11:13:19 <EvanR> who all use C technology except C++
11:13:28 <Jinxit> am i misunderstanding it?
11:14:07 <sproingie> b could express a failure if you wanted
11:14:26 <Jinxit> yes, replacing a with Either e a is my plan
11:14:30 <Jinxit> but what do i do with s and w?
11:14:55 <Jinxit> conjure them out of thin air just to drop them?
11:14:59 <sproingie> pass them through to the next computation, otherwise drop 'em if you don't need 'em
11:15:27 <Jinxit> but i do have to "create" them before dropping them, right?
11:16:02 <sproingie> if there's constraints on them then you'll need to to use some dummy value, otherwise unit works nicely
11:16:19 <sproingie> i'd guess there's a monoid constraint on w at least
11:16:33 <Jinxit> and s has to be the same as before
11:16:38 <Jinxit> so i guess i can get that
11:18:03 <sproingie> come to think unit works anyway, it being a very trivial monoid
11:18:26 <EvanR> very trivial
11:18:51 <EvanR> more than or equally trivial than the other trivial monoids
11:18:53 <sproingie> you could always wrap it up in a simpler type so you're not sprinkling () all over the place
11:21:20 <sproingie> (or just use a simpler type outright and convert back and forth as needed)
11:23:46 <ddellacosta> folks, I'm looking for a critique of some code if anyone has the time and inclination: https://gist.github.com/anonymous/163932887785d3c7f2904382d2dc3fd4
11:24:37 <ddellacosta> I've just started in on working through Project Euler problems as a way to practice Haskell. For this one, I was trying to think a bit about performance but I don't find my solution particularly elegant or idiomatic. I'd love to get some suggestions there.
11:24:54 <ddellacosta> (it is correct though, in terms of what it produces, it would seem)
11:25:45 <ddellacosta> in particular all the if/else in the `fibUntil'` function makes me unhappy...seems like that could be restructured somehow to be a lot cleaner
11:26:07 <sproingie> Data.Sequence seems a little overkill for PE problems
11:26:35 <ddellacosta> sproingie: that's a totally reasonable point, but part of what I'm trying to do here is also get a feel for how to understand complexity in Haskell
11:27:36 <sproingie> sure, it's a good library to know.  starting out with plain old lists might reduce some of the pain
11:28:14 <ddellacosta> I suppose--but more general it seems like using [] with `++` and `!` or whatever would still leave this relatively verbose and ugly
11:28:19 <ddellacosta> more generally*
11:29:02 <sproingie> ugly perhaps, eye of the beholder.  verbose, no.
11:29:14 <saep> > let fibs = Data.List.scanl (+) 0 (1:fibs) in sum $ Data.List.takeWhile (< 4000000) fibs
11:29:16 <lambdabot>  9227464
11:29:22 <ddellacosta> I guess when I say verbose I'm thinking of the if/else checks and whatnot
11:30:07 <saep> oh, forgot the even filter :S
11:30:18 <iqubic> How does fmap for tuples work?
11:30:21 <ddellacosta> ah! I was wondering why it was wrong in that way, saep :-D
11:30:34 <saep> > let fibs = Data.List.scanl (+) 0 (1:fibs) in sum $ Data.List.filter even $ Data.List.takeWhile (< 4000000) fibs
11:30:36 <lambdabot>  4613732
11:30:43 <sproingie> iqubic: look up the source for the Functor instance
11:30:44 <lambdamu> iqubic: it maps over the second component
11:30:49 <ddellacosta> neato. Thanks saep, will poke at that a bit
11:31:00 <iqubic> why only the second component?
11:31:10 <iqubic> why not both components?
11:31:21 <ddellacosta> saep: without digging into that too much, what is the performance like on that solution? Is it roughly O(n)?
11:31:24 <lambdamu> iqubic: well the first component need not be the same type
11:31:31 <ddellacosta> complexity I should say
11:31:47 <lambdamu> iqubic: The functor class expects a type of kind * -> *
11:31:52 <saep> ddellacosta: I think that GHC is smart enough to not actually construct a lot of the list. I did the first 76 Euler problems myself once and they ran in less than 3 seconds on an oldish i5.
11:31:53 <Tuplanolla> Try writing an instance that maps over both, iqubic.
11:32:04 <lambdamu> iqubic: (,) :: * -> * -> *
11:32:06 <sproingie> easy enough for (a,a)
11:32:17 <lambdamu> iqubic: (1,) :: * -> *
11:32:19 <Tuplanolla> It's not, sproingie.
11:32:25 <iqubic> Tuplanolla: It wouldn't work.
11:32:34 <afhole> How can I ignore the Right case of an Either? I get a warning about exhaustive pattern matching
11:32:46 <iqubic> afhole: You can't.
11:32:58 <iqubic> You have to do something with the right part
11:33:06 <ddellacosta> saep: that's exactly what I'd like to get a better grasp of; what GHC is going to clean up for me vs. what I have to be cognizant of in terms of making sure I'm not producing quadratic code accidentally, etc.
11:33:16 <ddellacosta> guess I have a ways to  go
11:34:07 <sproingie> > let fm2 f (a,b) = (f a, f b) in fm2 (+1) (3,4)
11:34:09 <lambdabot>  (4,5)
11:34:09 <lambdamu> ddellacosta: You can compute fibs in in logarithmic time even, but that has nothing to do with haskell
11:34:11 <afhole> I'm still trying to do this `isoEU :: ISO (Either [()] ()) (Either [()] Void)` isomorphism exercise. Can't work out how to satisfy the () -> Void
11:34:31 <sproingie> not quite as useful, but there it is
11:34:43 <Tuplanolla> That still won't let you write the instance directly, sproingie. You could, however, define `newtype Join f a = Join (f a a)` and have your `instance Functor (Join (,))`.
11:34:58 <ddellacosta> lambdamu by using a constant?  yeah I'm more curious about understanding how you can get the best performance out of "the usual solution"
11:35:17 <lyxia> afhole: () -> Void   is impossible without error (which you are not allowed to use here)
11:35:17 <Tuplanolla> You could try that one, iqubic.
11:35:53 <afhole> lyxia: So can I ignore that case somehow?
11:36:15 <lyxia> afhole: no you shouldn't ignore the () case
11:36:49 <iqubic> Tuplanolla: I don't want to try that. It sounds hard.
11:36:50 <lyxia> afhole: it just means that you should revise another one of your assumptions about what that function does
11:37:00 <afhole> I can't see how else to handle it other than something () -> Void which is impossible
11:37:01 <Tuplanolla> It's quite easy, iqubic.
11:37:01 <afhole> Hmm
11:37:12 <EvanR> > f () = let x = x in x
11:37:14 <lambdabot>  <hint>:1:6: error:
11:37:14 <lambdabot>      parse error on input ‘=’
11:37:14 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:37:20 <saep> ddellacosta: I learned profiling haskell programs while solving project euler problems.
11:37:20 <EvanR> didnt mean to put >
11:37:24 <iqubic> What is the definition of Join we're working with? for Join (,)
11:37:35 <Tuplanolla> I just gave you the definition.
11:37:52 <iqubic> newtype Join f a = Join (f a a)
11:37:56 <ddellacosta> saep: well then, there's more incentive for me to keep going. :-D Thanks a lot again for your solution, I'm going to learn a lot by understanding it fully.
11:37:58 <iqubic> How does that work??
11:37:59 <lambdamu> ddellacosta: https://kukuruku.co/post/the-nth-fibonacci-number-in-olog-n/ but yeah not related to learning haskell
11:38:09 <lyxia> afhole: one thing you can be sure of is that Either [()] Void has no Left. So every element (Either [()] ()) will be mapped to a Right.
11:38:22 <ddellacosta> lambdamu: neat, thanks
11:38:48 <iqubic> What I ended up doing was this: (fst size + 1, snd size + 1)
11:38:57 <iqubic> where size :: (Int, Int)
11:39:06 <iqubic> is there a cleaner way of doing that?
11:39:09 <sproingie> PE is great for playing around, but you won't find too much real-world code in the answers
11:39:11 <lyxia> afhole: uh, I mean (Either [()] Void) has no (Right _)
11:39:34 <lyxia> afhole: so every element (Either [()] ()) will be mapped to a (Left _)
11:39:38 * hackage pandoc-citeproc 0.10.5.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.5.1 (JohnMacFarlane)
11:40:14 <ddellacosta> sproingie: yeah I get that, I should add that partially I'm trying to increase my comfort with mathematics, but yeah definitely using it as a playground to build basic comfort and familiarity with Haskell
11:40:27 <ddellacosta> definitely just one part of the picture though
11:40:30 <sproingie> playing around's a good way to do that :)
11:42:02 <lyxia> afhole: If you're stuck with (Either [()] () -> Either [()] Void), you can try to think in the other direction (Either [()] Void -> Either [()] ()).
11:43:40 <Jinxit> sproingie: https://pastebin.com/LrxhJHt4 :V
11:43:44 <Jinxit> feels dumb
11:45:39 <Tuplanolla> Yes, iqubic. It's through my `Join` or the more general `Bifunctor`.
11:46:07 <iqubic> So it's a bifunctor?
11:47:38 * hackage quickcheck-instances 0.3.14 - Common quickcheck instances  https://hackage.haskell.org/package/quickcheck-instances-0.3.14 (phadej)
11:48:57 <afhole> Damn I'm confused. "expected: Right ()  but got: Left []" - how can I return Right () if the test can't supply Right Void?
11:49:42 <sproingie> Jinxit: ooh looks good.  i never did learn all the dangly bits of mtl
11:49:47 <ReinH> Either [()] Void is like the natural numbers. Either [()] () is like the natural numbers starting at 1
11:50:15 <ReinH> They correspond to n + 0 and n + 1, respectively.
11:50:34 <sproingie> i was scared of monads for years ... big stacks of monad transformers still scare me.  which i suppose accounts for the existence of RWS
11:50:55 <afhole> hmm
11:50:58 <Tuplanolla> The connection is that `instance Bifunctor f => Functor (Join f) where fmap f (Join x) = Join (join bimap f x)`, iqubic.
11:51:33 <ReinH> You can send Right () to Left [] and vice versa.
11:51:42 <Tuplanolla> So you can either say `bimap negate negate (42, 13)` or `fmap negate (Join (42, 13))`.
11:52:19 <phadej> join bimap f is clever obfuscation :)
11:52:38 * hackage timezone-olson-th 0.1.0.3 - Load TimeZoneSeries from an Olson file at compile time.  https://hackage.haskell.org/package/timezone-olson-th-0.1.0.3 (petterb)
11:52:52 <afhole> I'm so stumped
11:55:54 <ReinH> fanout f (a,b) = (f a, f b) is a useful combinator.
11:56:15 <EvanR> lpaste go down the hole...
11:57:16 <Jinxit> sproingie: yeah RWS(T) is super handy
12:00:12 <Gurkenglas> ReinH, you mean starting and 1 and 0 respectively, right?
12:00:17 <Gurkenglas> *at
12:02:25 <afhole> Still stuck at "expected: Right ()  but got: Left []" - not sure how I can produce a Right ()
12:04:24 <ski> @type \f ab -> join (***) f ab
12:04:25 <lambdabot> (b' -> c') -> (b', b') -> (c', c')
12:05:57 <cocreature> @type \f -> bimap f f
12:05:59 <lambdabot> Bifunctor p => (a -> d) -> p a a -> p d d
12:07:07 <Jinxit> so is there any reason why an Identity can't be promoted to an Except e trivially, or is it just a limitation in haskell?
12:07:46 <phadej> trivially?
12:07:47 <Tuplanolla> :t \ (Identity x) -> Right x -- Like this, Jinxit?
12:07:49 <lambdabot> Identity b -> Either a b
12:07:59 <cocreature> Jinxit: what do you mean by “trivially” here? you can write a function that does the conversion
12:08:04 <phadej> :t return .runidentity
12:08:06 <lambdabot> error:
12:08:06 <lambdabot>     • Variable not in scope: runidentity :: a1 -> a
12:08:06 <lambdabot>     • Perhaps you meant ‘runIdentity’ (imported from Control.Monad.Identity)
12:08:12 <phadej> :t return . runIdentity
12:08:13 <lambdabot> Monad m => Identity a -> m a
12:08:31 <Gurkenglas> :t Control.Monad.Morph.generalize
12:08:33 <lambdabot> Monad m => Identity a -> m a
12:08:44 <phadej> :)
12:08:52 <Gurkenglas> :t over both
12:08:54 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
12:09:03 <Tuplanolla> What are we going to do with all these options?
12:09:22 <Jinxit> i mean using an Identity function (in a transformer stack) inside an Except monad
12:09:24 <phadej> Tuplanolla: roll a dice each time we need to use one!
12:09:33 <Jinxit> without having to `generalize`
12:09:38 <Gurkenglas> Tuplanolla, he can investigate Control.Monad.Morph for more abstractions he didn't know he wanted
12:09:41 <ski> `mmorph' ?
12:09:53 <Jinxit> and that i will Gurkenglas 
12:10:00 <sproingie> mighty morphing monads
12:10:43 <lyxia> Tuplanolla: compose them all
12:11:03 <Gurkenglas> Jinxit, how would it know whether to use Identity as a left or a right?
12:11:20 <Jinxit> intuitively Right
12:11:22 <Jinxit> but i guess yeah
12:11:51 <Jinxit> i mean whatever runIdentity does for that monad feels like a good default, no?
12:12:13 <phadej> delicate balance between what could be implicit and what should be explicit
12:12:59 <phadej> Jinxit: why you have Identity in the first place, if you want to unwrap it?
12:13:30 <ski> (perhaps generic code)
12:13:38 <phadej> could you have `forall m. ... -> m a` instead of `... -> Identity a` ?
12:13:47 <phadej> forall m. Monad m =>
12:14:18 <phadej> or rather just ` ... -> a`?
12:14:59 <afhole> I wonder if this assumes I have `isoEither :: ISO a b -> ISO c d -> ISO (Either a c) (Either b d)` correctly as `isoEither (ab, ba) (cd, dc) = (bimap ab cd, bimap ba dc)`?
12:15:05 <Gurkenglas> Right, Control.Monad.Morph even says it's for when you don't want to rewrite the original code to not use Identity :3
12:16:32 <ski> <Jinxit> i mean using an Identity function (in a transformer stack) inside an Except monad
12:16:44 <Gurkenglas> afhole, if you're asking about whether type inference inserts type aliases, no
12:16:53 <ski> so i suppose it's really `... -> T Identity A', for some `T'
12:17:04 <Jinxit> to me it makes sense to represent code that can't fail in the stack as m Identity, and code that can fail as m (Except e)
12:17:06 <nshepperd> the real purpose of Identity is to substitute it into things starting with 'forall m. Monad m =>' in the first place :>
12:17:09 <Jinxit> but then i need generalize all over the place
12:17:23 <Gurkenglas> Jinxit, yep that's the usecase for "Monad m => m" instead of "Identity"
12:17:39 <afhole> Gurkenglas: Just wondering if that looks correct for the signature
12:17:39 <Jinxit> oh like that
12:18:02 <ski> Jinxit : normally you'd not write `Identity' in the result type of a type signature, explicitly
12:18:10 <Gurkenglas> Why is it even "type State s a = StateT s Identity a" instead of "type State s a = forall m. Monad m => StateT s m a"?
12:18:26 <ski> extensions ..
12:18:55 <Gurkenglas> Would anything be broken by this being changed now?
12:18:57 * ski would like to be able to have `newtype's with multiple (coherent) definitions
12:18:59 <Jinxit> hm i can kinda dig this
12:19:08 <glguy> and it's nice to have   State s a be a value that gets evaluated once
12:19:13 <Jinxit> ski: well technically it was an RWS (which has Identity in it)
12:19:19 <glguy> rather than once every time its used because it's polymorphic with a constraint
12:19:22 <Jinxit> but now i made a T version of my monad as well
12:19:25 <ski> Jinxit, *nod*
12:19:57 <ski> Jinxit : well, then your `RWS R W S' was the `T' i mentioned
12:19:59 <phadej> Gurkenglas: you want to take `T Identity a` as a parameter, but return `forall m. Monad m => T m b`
12:20:20 <Gurkenglas> Makes sense
12:20:34 <phadej> not having to deal with RankNTypes is good for type-inferencer
12:20:47 <Gurkenglas> Is that related to the above line?
12:20:52 <afhole> The tests are still expecting a Right () from a Right Void, I just don't know how to avoid that
12:20:53 <phadej> yes
12:21:41 <Gurkenglas> When the parameter takes it as a parameter, should that be Identity or forall?
12:21:41 <ski> reminds me of e.g. `mapM_ :: Monad m => (a -> m b) -> [a] -> m ()', with `b' in the argument, but `()' in the result
12:22:32 <sproingie> blahblah Right _ = Right ()
12:22:37 <ski> afhole : there should be a function of type `forall a. Void -> a' that you can use (`fmap')
12:22:51 <Gurkenglas> Reminded me of that too. In that case I would like b to be changed to be (). Let's see if I can rationalize the cognitive dissonance somehow.
12:22:54 * ski would prefer that to what sproingie suggested
12:23:07 <phadej> Gurkenglas: depends
12:23:54 <ski> Gurkenglas : there's also `forever :: Monad m => m a -> m b' where one might have first thought of `Monad m => m () -> m Void'
12:24:27 <Gurkenglas> Yep, remember that discussion, Was also on the latter side
12:25:00 <phadej> foo :: forall m. Monad m => T m a -> T m a is different from  foo :: Monad m => T Identity a -> T m a, which is simpler fversion of foo :: Monad m => (forall n. T n a) -> T m a
12:25:30 <ski> Gurkenglas : latter side ?
12:25:40 <Gurkenglas> The one advocating for `Monad m => m () -> m Void'
12:25:52 <ski> ok
12:26:06 <phadej> good thing about T Identity a, is that you can have [T Identity a]; [forall m. T m a] requires ImpredicativeTypes
12:26:41 <ski> hm, i suppose `RankNTypes' is a special case of `ImpredicativeTypes'
12:26:43 <Gurkenglas> phadej, yes, that's a nice resolution. foo :: (forall n. T n a) -> (forall m. T m a) is the one we should strive for. Is there a good reason for ImpredicativeTypes being hard?
12:26:51 <begriffs> So for real I'm not trying to troll, genuinely curious. What is the most typical convention for Haskell code: tabs vs spaces?
12:27:25 <begriffs> There's a pull request on my haskell-vim project that adjusts tab settings and I'm thinking I could review all the tab settings while I'm at it.
12:27:27 <ski> Gurkenglas : `foo :: (forall n. Monad n => T n a) -> (forall m. Monad m => T m a)' is the same as `foo :: Monad m => (forall n. T n a) -> T m a'
12:27:33 <Gurkenglas> As far as I can see, you should be able to reduce it to RankNTypes by replacing all data types by forms using (->) and (,)
12:27:37 <ski> (er, with a `Monad n =>' in the latter as well)
12:27:49 <Gurkenglas> Like replacing [a] with (forall b. (a -> b -> b) -> b -> b)
12:28:12 <EvanR> forever :: Monad m => m a -> m Void would be really bad
12:28:20 <geekosaur> Gurkenglas, I think if someone could answer that question then they wouldn't be such a PITA; either there'd be a good idea for a proper fix, or they'd just be buried
12:28:25 <Gurkenglas> ski, yes, I did that deliberately, like when you say "Functor f => (a -> b) -> (f a -> f b)" even though the latter brackets are superfluous
12:28:35 * ski nods
12:28:42 <afhole> Would someone mind reading what I have so far? I'm really not getting this. What's the pastebin of choice?
12:28:48 <geekosaur> instead there have been several attempts at fixing them, and finally giving up in favor of visible type application
12:28:48 <ski> @paste
12:28:48 <lambdabot> Haskell pastebin: http://lpaste.net/
12:28:54 <geekosaur> is lpaste working now?
12:28:55 <EvanR> lpaste.net
12:29:02 <EvanR> which hasnt been seen in a few days
12:29:07 <geekosaur> seems to have gone the same direction as other of chrisdone's projects
12:29:42 <phadej> Gurkenglas: they just doesn't work with type-inference; I'm no aware of any concise explanation why they are hard :S
12:29:49 <Gurkenglas> EvanR, why is it bad? Because people would be confused that they have to designate their main as coterminating using "main :: IO Void"?
12:29:50 <afhole> https://pastebin.com/zhYhAG9b is still failing "expected: Right ()  but got: Left []"
12:29:52 <ski> begriffs : spaces i believe are most common
12:30:16 <ReinH> Gurkenglas: I mean starting at which ever one makes sense :X
12:30:40 <EvanR> Gurkenglas: it might be more obvious that it doesnt return than m b -> m a, but the deal is, you can put a bunch of non-returning actions in the same container
12:30:41 <ski> begriffs : if you go by tabs, then : (a) only layout indent by tabs, not spaces; (b) always break line after a layout-introducing word, in case the following block has more than one line
12:31:06 <begriffs> ski: ok, spaces is what I've been using and it will require the fewest changes in this PR so sounds good. Also Haskell's indentation sensitivity might make it a good idea.
12:31:16 <EvanR> Gurkenglas: unless they all use Void
12:31:31 <Gurkenglas> "you can put a bunch of non-returning actions in the same container" huh?
12:31:35 <EvanR> yes
12:31:56 * ski normally either indents by two spaces, or by the number of spaces required to align with something particular on earlier line
12:32:01 <Gurkenglas> "did not parse", not "i disagree"
12:32:23 <ReinH> Either [()] () is equivalent to affixing an extra element to the natural numbers, which is still in bijection with the natural numbers. (Up to bottoms.)
12:32:24 <EvanR> e.g. waiting for the first of 9 threads to crashh
12:32:25 <ski> (i also indent the whole of module bodies, after `where', though i believe that's not common)
12:32:41 <EvanR> none of them return a value, so they should all unify
12:32:52 <EvanR> but you require Void, only Void will work and youd have to wrap them
12:33:10 <EvanR> which isnt really necessary
12:33:44 <Gurkenglas> I don't quite follow. Can you put this is terms of a type signature?
12:33:49 <Gurkenglas> *this in terms
12:34:28 <EvanR> async :: IO a -> Async a; waitAny :: [Async a] -> IO a
12:34:55 <Gurkenglas> Which a should that return?
12:34:58 <EvanR> now if forever returns Void, i cant put it in that list with other loops made using not forever
12:35:06 <EvanR> it will never return any a
12:35:42 <sproingie> it'll return an IO a.  which one is arbitrary
12:35:48 <EvanR> no
12:35:51 <afhole> ReinH: I'm struggling to get from that to a way of returning Right () when it's expecting  Right Void
12:35:57 <Gurkenglas> This crashes once one of the threads crash?
12:36:12 <ReinH> afhole: I'm not claiming you can do that.
12:36:14 <EvanR> yeah, you can also use a catch, waitAnyCatch 
12:36:32 <ReinH> I'm just talking about the isomorphism between Either [()] Void and Either [()] ()
12:37:02 <ReinH> Iso (Either a b) (Either c d) does not imply Iso b d
12:37:42 <Gurkenglas> So if it never returns a value, what does it do with the values it gets from a thread that finishes instead of crashing, if, as you suggest, some threads are not Async Void?
12:37:48 <ReinH> b and d can have different cardinality
12:37:54 <afhole> Indeed, I'm just struggling to come up with a partial implementation for the Left sides
12:37:58 <EvanR> the assumption is that you only have threads here that loop forever
12:37:59 <ReinH> like Void and ()
12:38:03 <EvanR> they never return
12:38:13 <ReinH> afhole: can you link the exercise again please?
12:38:14 <Gurkenglas> Then why aren't they all Async Void
12:38:33 <EvanR> because half of them were written by someone else and didnt append a useless big of hang code?
12:38:42 <EvanR> which is typed specifically as void
12:38:51 <afhole> Sure - https://www.codewars.com/kata/isomorphism/train/haskell (apologies for my ignorance and thanks for your patience :) )
12:39:14 <EvanR> so the idea of changin forevers type expands to requiring a language-wide convention on infinite loops
12:39:28 <ReinH> afhole: so what is the actual question?
12:39:31 <EvanR> and youd necessarily be putting monotype signatures for all loops
12:39:45 <EvanR> the inferencer will be "wrong" for all loops without that
12:40:11 <ReinH> afhole: to implement isoEU?
12:40:18 <phadej> (fwiw, I can imagine having `waitAny` on forever and terminating action, letting the forever loop run as long as terminating action does something; e.g. spin a spinner :)
12:40:18 <afhole> ReinH: Yes
12:40:27 <EvanR> it makes more sense for forever to go with the "null convention" of the inferencer seeing loops as forall a . a
12:40:44 <sproingie> sounds more like bottom than Void
12:40:49 <ReinH> send Right () to Left [] and send Left xs to Left (():xs)
12:40:52 <ReinH> and vice versa
12:41:00 <phadej> spoonm: forall a. a is isomorphic to Void
12:41:28 <EvanR> what, bottom is a value and Void is a type
12:41:29 <phadej> Void is useful in contravariant positons, i.e. f Void -> ...
12:41:36 <Gurkenglas> If someone else has accidentally sent their infinite loop through "fmap absurd" before giving it to you, it's a simple enough matter to "(>> crash) . void" it before using it as one of the elements for the waitAny
12:41:48 <ReinH> and a -> Void
12:42:00 <ReinH> is also useful
12:42:02 <ReinH> being negation
12:42:08 <ReinH> I'm not sure why I typed that on three lines
12:42:20 <EvanR> Gurkenglas: like i said, you would have to wrap everything. and anyone doing anything like this with anyones code not following a pointless type specialization would have to do the same thing
12:42:47 <EvanR> its extra work on everyones part
12:42:56 <phadej> I guess, it's better to try in medium-size project, and then you'll understand why it's a bad idea
12:43:03 <afhole> ReinH: For both functions in the iso?
12:43:23 <ReinH> well, when going backwards you go backwards
12:43:25 <afhole> What is a -> Void?
12:43:53 <ReinH> send Left [] to Right () and Left (() : xs) to Left xs
12:44:03 <EvanR> Gurkenglas: and while we are ok in haskell doing "pointless conversions" everywhere for numbers, there isnt even any difference semantically between forall a . a and Void
12:44:22 <EvanR> one just works in more places than the other
12:45:26 <EvanR> so i see this as unnecessarily bureaucratic
12:45:53 <afhole> ReinH: That worked, thank you! Now I just have to try to understand it...
12:46:32 <ReinH> afhole: Ok, how many elements of Either a () are there? Your answer can be in terms of a and should ignore bottoms.
12:46:52 <Gurkenglas> It's extra work only whenever someone hasn't abstracted correctly. Since "forall a . a" can be specialized to "Void", only the argument side of waitAny needs explicit conversion
12:47:26 <Gurkenglas> If Void was called the "null convention", switching to the forall version would be just as hard, but on the other side of waitAny
12:47:28 <afhole> ReinH: In vague terms a * 1 I suppose?
12:47:41 <ReinH> afhole: Yes. How many does Either a Void have?
12:47:46 <EvanR> if you have one Void and 8 forall a . a's, then i would rather convert the other way
12:47:51 <Gurkenglas> ReinH, no, not a * 1
12:48:00 <ReinH> Oh, sorry, I can't read
12:48:01 <EvanR> and if the Void person decided to do forall a . a, no one would have to do anything
12:48:09 <ReinH> In general, Either a b has a + b elements
12:48:15 <ReinH> and () has 1 element
12:48:32 <EvanR> since Void is not very popular, yes it would be a ton of work
12:48:48 <ReinH> (a, ()) has a * 1 elements
12:49:09 <ReinH> afhole: Either a () has all the elements of a and also ()
12:49:15 * ski would like `Void' being more popular
12:49:19 <EvanR> Gurkenglas: would you map them all the Void if none of them were, before sending to waitAny ?
12:49:23 <ReinH> It's popular enough in some circles.
12:49:58 <EvanR> if only forever was changed, then i would simply be "unconverting" back to forall to fix it
12:50:12 <EvanR> since i dont use forever for all loops
12:50:22 <ReinH> afhole: So Either a () includes one element that Either a Void does not: Right ()
12:50:50 <ReinH> afhole: are you familiar with set bijections?
12:51:00 <afhole> I'm afraid not
12:51:24 <afhole> Functions to and from elements?
12:51:30 <ReinH> A bijection of sets is a mapping from every element of the first set to every element of the second set that covers every element in both sets.
12:51:34 <ReinH> iow, it's one-to-one and onto
12:51:39 <EvanR> Gurkenglas: Void cant be a null convention since the inferencer doesnt assign this as the type, you have to choose it specifically
12:51:57 <ReinH> afhole: This has surprising implications for infinite sets
12:52:16 <afhole> Vague memories of injective and surjective morphisms
12:52:17 <Gurkenglas> EvanR, with "waitAny :: [Async Void] -> Async Void", "forall a. a" can be passed as an element without any conversions
12:52:21 <ReinH> for example, you can but the natural numbers and the even numbers in bijection: send n to 2n and vice versa.
12:52:21 <ski> > isRight (absurd <$> Right undefined)
12:52:23 <lambdabot>  True
12:52:24 <ski> > isRight (absurd =<< Right undefined)
12:52:26 <lambdabot>  *Exception: Prelude.undefined
12:52:41 <ReinH> You can also put [0..] and [1..] in bijection: send n to n + 1 and vice versa
12:52:53 <ReinH> Do you agree that this forms a bijection?
12:53:21 <afhole> (I have to afk now I'm afraid - real life aka dinner with the wife) Thank you so much for your help so far!
12:53:24 <ReinH> s/but/put
12:53:53 <ReinH> afhole: No worries. If you agree that [0..] and [1..] are in bijection and you note that [()] has the same number of elements as the natural numbers, you might see why we can solve the problem that way
12:53:58 <EvanR> Gurkenglas: thats... the wrong type for waitAny
12:55:19 <sproingie> gives new meaning to "crash-only"
12:55:27 <Gurkenglas> EvanR, that's what would happen if stuff started getting implemented using Void. If the combinator doesn't use Void, we obviously have to convert using fmap absurd. Do you have an example where implementing the combinator using Void leads to more than one additional conversion?
12:56:10 <EvanR> waitAny returns the answer for the first thread that finishes
12:56:40 <EvanR> and the special case where none of them finish, i give it a list of Async a
12:57:31 <Gurkenglas> (Does it crash once a thread crashes, or does it wait for a thread to finish without crashing?)
12:57:47 <EvanR> on conversions, the library author may have put in a conversion to adhere to one convention, and then the other is not using that convention and converts back
12:58:13 <EvanR> it also crashes if any crash (before returning)
12:58:37 <Gurkenglas> When would a library author have to convert in order to adhere to a convention, when all the stuff he uses adheres to convention?
12:58:53 <EvanR> never you win, everyone in the world agrees
12:59:06 <EvanR> to teh exact opposite thing were using right now
12:59:17 <EvanR> 0 work
12:59:18 <codygman> Any ideas on how I can (maybe using lens, prisms, and some sort of alternative?) get rid of this fmt/fmt2 code smell and have something that can format both StartDate and EndDate? http://lpaste.net/2439378936925257728
12:59:19 <Gurkenglas> I just mean that this wasn't one conversion per convention breach
13:00:23 <EvanR> i am assuming that the situation would be, since wre using the exact opposite convention, that before the "final revolution" happens we will be converting back and forth a lot
13:00:57 <EvanR> imagine if we decided to change the stdlib from Int to Integer
13:01:16 <EvanR> which actually youd get some real benefit from
13:01:18 <EvanR> it would be a nightmare
13:02:16 <EvanR> intermediate a to Void would be a nightmare plus what do you get out of it
13:02:26 <EvanR> a different color bikeshed
13:02:38 <sproingie> Void does stand out nicely
13:02:44 <Gurkenglas> Better error messages
13:02:51 <Gurkenglas> (More of them, that is)
13:03:33 <Gurkenglas> You notice when you accidentally information from infinity
13:03:40 <EvanR> well at least we established this isnt just a change to the type of forever
13:03:54 <sproingie> :t forever
13:03:55 <lambdabot> Applicative f => f a -> f b
13:04:22 <sproingie> mmmkay then
13:04:25 <lpaste> lyxia annotated “No title” with “to codygman (annotation)” at http://lpaste.net/2439378936925257728#a7489276534373482496
13:04:29 <EvanR> Applicative f => f () -> f Void would be even worse because you have to put in explicit conversions to ()
13:04:44 <sproingie> keep yer Unit out of my face i say :)
13:05:31 <Gurkenglas> That's just the dual! It makes you notice when you accidentally discard information.
13:06:45 <Gurkenglas> (Actually, "(>> crash) . void" sounds wrong. I'm not sure where you'd want that.)
13:07:24 * ski used `Void' to distinguish (simulated) threads that were terminating abnormally (`end :: SM Void',`spawn :: SM Void -> SM ()'), from ones that were terminating normally (`SM ()')
13:08:37 <Gurkenglas> I hope spawn forks there as opposed to conjuring a value
13:08:54 <ski> (by doing that, i managed to stomp out remaining `undefined's, so that i could be reasonably sure that it wouldn't suddenly abort)
13:09:08 <ski> it forked, yes
13:09:14 <codygman> lyxia: I have a newtype wrapped over LocalTime so I can't use formatTime directly. I suppose I could use a typeclass but I feel there's a more lightweight solution
13:09:45 <codygman> codygman: Though I guess making new instances of FormatTime isn't so bad
13:09:50 <EvanR> SM is a free monad like thing? what does end :: SM Void get you, you could just ignore it right
13:09:56 <lyxia> codygman: I unwrap the arguments as soon as they are passed in
13:10:06 <EvanR> devnull <- end; doSomething else
13:10:16 <lyxia> codygman: see line 2
13:10:23 <ski> i already said what it gave me
13:10:33 <ski> (and no, it was a CPS thing)
13:11:01 <Gurkenglas> "<EvanR> well at least we established this isnt just a change to the type of forever" <- with "waitAny :: [Async a] -> IO a" when some implement "forall b. Async b" and others "Async Void", wouldn't this just, correctly, set a to Void?
13:11:13 <codygman> lyxia: Ah, I had a feeling I was missing something... that is the simplest approach :) I also just found out I could use GeneralizedNewTypeDeriving to generate the FormatTime instances
13:11:14 <EvanR> ok
13:11:34 <codygman> lyxia: Thanks!
13:11:46 <lyxia> codygman: right that's also a solution
13:12:03 <EvanR> Gurkenglas: yes. as long as we dont have people implementing their own Void
13:12:38 <Gurkenglas> I suppose the correct way would be "type Void = forall a. a"
13:12:50 <EvanR> and if you make sure the Void, if it escapes, is correctly established in your code
13:13:11 <Gurkenglas> With "forever :: IO () -> IO (forall a. a)"
13:13:23 <ski> impredicative
13:13:28 <lyxia> what's the problem with implementing your own void
13:13:29 <EvanR> erm... type Void = forall a . a 
13:13:38 <EvanR> yeah
13:13:46 <EvanR> ImpredicativeTypes
13:14:02 <EvanR> lyxia: then you cant put Void1 and Void2 in the same container
13:14:34 <EvanR> this is turning into the old lisp "what is NULL" basically
13:14:38 <sproingie> nothing wrong with having your own unpopulated type, e.g. phantom types.  but that's not really the same use case.
13:14:41 * ski ponders implementing their own `Bool'
13:15:13 <iqubic> Why? Why would you write your own Bool?
13:15:22 <Gurkenglas> In another universe: 'I suppose the correct way would be "type Bool = a -> a -> a"'
13:15:25 <ski> sorry, that was a jest
13:15:32 <sproingie> iqubic: say you want to express two options
13:15:44 <iqubic> Gurkenglas: How would that even work?
13:15:56 <ski> iqubic : with a `forall a.'
13:16:05 <Gurkenglas> Oh, forgot the forall a.
13:16:11 <iqubic> Type Bool = a -> a -> a???
13:16:17 <iqubic> I'm not getting it at all.
13:16:18 <sproingie> if your choices are Chocolate | Vanilla, encode it that way, not as True and False
13:16:31 <sproingie> even though it's isomorphic to a bool
13:16:36 <lyxia> iqubic: Implementing a separate type helps avoiding boolean blindness
13:16:43 <iqubic> sproingie: That makes sense.
13:16:50 <Gurkenglas> iqubic, "type Bool = forall a. a -> a -> a". The two booleans would be "const" and "const id"
13:16:57 <sproingie> "boolean blindness" that's the term i was looking for
13:17:04 <ski> iqubic : `if <condition> then <consequent> else <alternate> = <condition> <consequent> <alternate>', `true = \t f -> t', `false = \t f -> f'
13:17:13 <EvanR> thats the non dependent version of boolean blindness
13:17:16 <ski> @where boolean-blindness
13:17:16 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
13:17:20 <iqubic> I though he was going to be recreating Data Bool = True | False
13:17:39 <Gurkenglas> Yes, that's what I meant.
13:17:55 <Gurkenglas> It makes about as much sense as implementing your own Void, or your own Lens type.
13:18:24 <EvanR> ah but you can make "your own" lenses without installing the library
13:18:32 <EvanR> and still be compatible
13:19:07 <Gurkenglas> The parallel world I'm talking about has Booleans hidden in this gigantic library that nobody wants to depend upon, but fortunately they defined them as "forall a. a -> a -> a" so you can define boolean values without depending on the library
13:20:28 <sproingie> not sure the picture is that dire for Void
13:20:50 <maerwald> oh man, they are still talking of Void :D
13:21:35 <iqubic> Why are you still talking about Void?
13:21:36 <sproingie> well, from void comes anything after all
13:21:57 <iqubic> What is the point of Void is Haskell?
13:22:13 <ski> what is the point of `0' in math ?
13:22:15 <sproingie> among others, expressing the concept of "can't return"
13:22:23 <Gurkenglas> They're still looking for a Void value. If they ever find one we're all out of a job.
13:22:27 <sproingie> also as a type level zero
13:22:58 <sproingie> unsafeCoerce 0 :: Void -- there you go
13:23:15 <EvanR> if you find one itll be a bug in the compiler
13:23:17 <sproingie> (try it with other numbers for segfaulty goodness)
13:23:33 <ski> that's why you should rather use `absurd :: Void -> ()' rather than `(\_ -> ()) :: Void -> ()'
13:23:41 <EvanR> (or a feature like unsafeCoerce)
13:24:35 <ski> (or i suppose i was thinking of uses of `error'. that usage of `unsafeCoerce' might "work")
13:26:00 * ski lobbies for adding `void' as a synonym of `absurd'
13:26:23 <EvanR> yes current void is badly named
13:26:26 <Gurkenglas> https://i.gyazo.com/7b880e4bf32a0d6adfbf5cc4091034c8.png wat
13:26:32 <EvanR> :t void
13:26:33 <lambdabot> Functor f => f a -> f ()
13:26:35 <maerwald> main :: IO absurd
13:27:05 <EvanR> IO StatusCode
13:27:07 <maerwald> not sure if I'd want to run that program though
13:27:10 <ski> (.. and relegating the name `void', of type `Functor f => f a -> f ()', under the `Foreign' hieararchy .. or changing it's name to `ignore' or something)
13:27:24 <sproingie> absurd isn't a type.  would have made an awesome blog title tho :)
13:28:06 <sproingie> one of my favorites is a python blog called "from __future__ import *"
13:28:12 <EvanR> absurd is a type variable
13:28:32 <sproingie> of more than one letter, that's absurd ;)
13:28:55 <maerwald> perfectly legal (I asked my lawyer)
13:28:55 * ski idly ponders adsurdness
13:29:31 <EvanR> what if you need more than 26 type variables
13:29:36 <sproingie> '
13:29:43 <EvanR> 52
13:29:45 <sproingie> ''
13:29:50 <maerwald> EvanR: enable unicode extension? :P
13:29:53 <ski> greek minuscules ?
13:30:10 <EvanR> actually i dont think you need an extension
13:30:17 <ski> (like $DEITY intended type variables to be spelled)
13:30:30 <sproingie> shame the good ones aren't alpha tho.  i want snowman and skull-and-crossbones vars
13:30:31 <maerwald> and then use chinese words as type variables (there should be 50k+)
13:30:54 <ongy> and some of them can even make sense
13:31:08 <ongy> 刀 if you need a sword variable....
13:31:41 <EvanR> :t let f :: 宗 -> 宗; f x = x in f
13:31:42 <lambdabot> ? -> ?
13:31:54 <maerwald> oh no, I shouldn't have said that :P
13:32:06 <EvanR> ?
13:32:11 <EvanR> ? ?
13:32:14 <sproingie> that was pretty hilarious
13:32:31 <ski> @type let 宗 :: 宗 -> 宗; 宗 宗 = 宗 in 宗
13:32:33 <hexagoxel> "absurd @ Blog :: Reader Void Blog"
13:32:33 <lambdabot> ? -> ?
13:32:45 <maerwald> I wonder if you can hack lambdabot with such input...
13:32:51 <hexagoxel> not sure that is a good name though..
13:33:42 <ski> (`reader absurd @ Blog' ?)
13:36:40 <hexagoxel> "forever absurd :: Void -> Blog"
13:37:28 <EvanR> the blog that cant exist
13:37:46 <sproingie> wait, that's the name of my blog (with no entries)
13:53:50 <iqubic> Is it really?
13:54:33 <sproingie> once i manage to write the first entry :)
13:54:50 <spoonm> is there a way to "alias" a data constructor, just like you can do to types with the `type' keyword?
13:55:11 <spoonm> I mean in a way I can use that alias in pattern matching
13:55:40 <sproingie> there's view patterns which are a lot like that
13:55:51 <ski> spoonm : <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms>
13:56:26 <ski> pattern guards and view patterns are also good to know about
13:58:24 <spoonm> thanks! \o/
13:59:38 * hackage text-show-instances 3.6.1 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.6.1 (ryanglscott)
14:00:59 <ReinH> Pattern synonyms?
14:02:34 <maerwald> well, if you don't care about exhaustiveness checks
14:02:55 <maerwald> or is that fixed now
14:03:25 <maerwald> https://git.haskell.org/ghc.git/commitdiff/1a3f1eebf81952accb6340252816211c7d391300 oh
14:05:52 <maerwald> well, "fixed"
14:18:36 <ij> ertes, hi. Around?
14:19:21 <ertes> ij: hi, yeah
14:19:33 <ij> Oh, I didn't notice you'd just joined due to a smart filter. 
14:20:32 <ij> ertes, So I git-cloned a repo that I cabal2nix'ed and nix-build't to build another repo that has it as deps. The other repo doesn't notice it when nix-build't.
14:24:14 <ertes> ij: you need to add it to the package set, either through an override or by creating your own package set…  the former is much simpler and the way i do it…  right now i ask you to ask in #nixos or on the nix-dev ML though, because i don't have time to help you myself
14:24:34 <ij> Ok, thanks!
14:29:02 <boobar> Is it possible to generalise type classes to use a different category to functions
14:29:33 <boobar> So I could have num defined with a bunch of arrows for example
14:30:53 <geekosaur> sort of? type-indexed typeclasses, you could start by looking at type-indexed monads (which allow things like Data.Map to be monads; ordinary Monad can't support/preserve the needed Ord instance)
14:31:22 <geekosaur> the result will not be compatible with the standard Num hierarchy, but isomorphic with and parallel to it
14:32:14 <geekosaur> the main problem is that things start to get klunky type-wise; it may be possible to hide some of that with appropriate type aliases or etc,
14:35:36 <boobar> OK I would need to reimplement the whole of num for each type
14:35:58 <Gurkenglas> https://i.gyazo.com/7b880e4bf32a0d6adfbf5cc4091034c8.png how?
14:43:41 <hexagoxel> Gurkenglas: that is roughly as safe as unsafeCoercing back and forth, which should work just as well between any two types.
14:45:10 <Gurkenglas> I would have expected absurd to give me a pattern match failure since none of the patterns apply to the given Void value. I suppose that the complete pattern match is optimized into unsafeCoerce by the compiler?
14:48:45 <Welkin> what is `absurd`?
14:48:59 <sproingie> a function you can't actually call
14:49:04 <mauke> my guess is Void -> a
14:49:13 <sproingie> (unless you backdoor it a la unsafeCoerce)
14:49:23 <glguy> Gurkenglas: once you misuse unsafeCoerce, all bets are off
14:50:35 <sproingie> https://hackage.haskell.org/package/void-0.6.1/docs/src/Data-Void.html#absurd
14:51:25 <Gurkenglas> :t fmap absurd . forever . void
14:51:27 <lambdabot> Applicative f => f a -> f b
14:51:32 <glguy> Void only has one value, bottom, so its fine for absurd to pass that argument through as the result
14:52:12 <Gurkenglas> "forall m. Monad m => m a" is to "Identity a" as "forall a. a" is to "Void"
14:52:47 <sproingie> insofar as you can't specify a in either case
14:53:08 <Gurkenglas> In the first case, that should hold for any a, right?
14:55:37 <iqubic> :t absurd
14:55:39 <lambdabot> Void -> a
14:56:02 <lyxia> Do you mean "for all a, (forall m. Monad m => m a) is isomorphic to (Identity a)" or, "(forall m a. Monad m => m a) is isomorphic to (forall a. Identity a)"
14:56:08 * hackage servant-zeppelin 0.1.0.0 - Types and definitions of servant-zeppelin combinators.  https://hackage.haskell.org/package/servant-zeppelin-0.1.0.0 (martyall)
14:56:37 <Gurkenglas> A way to technically get a value of type "forall a. a" is looping infinitely, as in "let x = x in x". This, of course, also passes as a value of type "Void". "Void" lets you talk about values that never actually exist, such as the return value of "let go = print "2" >> go in go". "absurd" lets you say that you're conjuring information from infinity, much like "const ()" lets you explicitly discard information.
14:59:12 <glguy> :t absurd
14:59:14 <lambdabot> Void -> a
14:59:15 <glguy> :t return
14:59:16 <lambdabot> Monad m => a -> m a
15:01:14 <glguy> :t return . runIdentity -- to be more specific
15:01:16 <lambdabot> Monad m => Identity a -> m a
15:07:16 <iqubic> :t negate
15:07:17 <lambdabot> Num a => a -> a
15:07:27 <iqubic> > negate 0
15:07:30 <lambdabot>  0
15:07:38 * hackage servant-zeppelin-swagger 0.1.0.0, servant-zeppelin-server 0.1.0.0, servant-zeppelin-client 0.1.0.0 (martyall): https://qbin.io/8n0dml2u
15:07:39 <iqubic> > negate 1
15:07:42 <lambdabot>  -1
15:07:51 <iqubic> > negate (-1)
15:07:53 <lambdabot>  1
15:07:58 <iqubic> Cool, that works
15:09:00 <Gurkenglas> > let myforever :: Monad m => m () -> m Void; myforever = forever; tilt :: StateT (Int, Int) (Either Int) (); tilt = StateT $ \(x, y) -> case y of 0 -> Left x; _ -> Right ((),(x+1, y-1)) in either id absurd $ (`evalStateT` (3,3)) $ forever tilt -- tilt moves a 1 from the second pair element to the first if it's possible, and aborts with the first pair element otherwise. myforever is an example of how Void can be 
15:09:01 <Gurkenglas> used to represent infinite loops - any application of forever will not lead to actual values of the monad's type parameter being returned. "(`evalState` (3,3)) $ forever tilt :: Either Int Void" lets us see that we actually have an Int at our hands, and "either id absurd" lets us tell that to the compiler - any Right values passed there will have had to get passed out of an infinite loop first.
15:09:03 <lambdabot>  6
15:10:26 <Gurkenglas> @let myforever :: Monad m => m () -> m Void; myforever = forever; tilt :: StateT (Int, Int) (Either Int) (); tilt = StateT $ \(x, y) -> case y of 0 -> Left x; _ -> Right ((),(x+1, y-1)) -- Oops, failed to actually use myforever there.
15:10:28 <lambdabot>  Defined.
15:10:45 <Gurkenglas> :t myforever tilt
15:10:46 <lambdabot> StateT (Int, Int) (Either Int) Void
15:10:56 <Gurkenglas> :t (`evalStateT` (3,3)) $ myforever tilt
15:10:58 <lambdabot> Either Int Void
15:11:39 * hackage servant-zeppelin 0.1.0.1 - Types and definitions of servant-zeppelin combinators.  https://hackage.haskell.org/package/servant-zeppelin-0.1.0.1 (martyall)
15:12:57 <iqubic> Is there a better way to write (fst a + fst b, snd a + snd b) where a :: (Int, Int) and b :: (Int, Int)?
15:13:37 <Welkin> iqubic: you could use the functions from Control.Arrow
15:13:39 * geekosaur smells arrows
15:13:46 <Welkin> or there is `on` from Data.Function that might be useful
15:13:49 <Welkin> but I hate using arrows
15:13:55 <Welkin> they are too painful to read
15:14:08 <iqubic> How would arrows help me here?
15:14:10 <iqubic> :t ***
15:14:12 <lambdabot> error: parse error on input ‘***’
15:14:17 <iqubic> :t (***)
15:14:18 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:14:20 <Tuplanolla> Now that's a biapplicative, iqubic.
15:14:35 <Welkin> lol
15:14:37 <iqubic> And how would I simplify my code? Can I even do that?
15:14:40 <Welkin> I see that now Tuplanolla 
15:14:43 <Welkin> it is biapplicative
15:15:11 <iqubic> How do I use biapplicatives?
15:15:24 <Welkin> I wouldn't bother unless you think it's really important
15:15:34 <Welkin> writing it out using pointful form is good enough
15:15:40 <iqubic> Well, I think my current code is a litle ugly.
15:15:42 <Welkin> it's at least clear what is happening
15:15:48 <Welkin> who cares about ugly?
15:15:56 <Welkin> you should care about clarity
15:16:08 * hackage servant-zeppelin 0.1.0.2, servant-zeppelin-server 0.1.0.1, servant-zeppelin-swagger 0.1.0.2, servant-zeppelin-client 0.1.0.1 (martyall): https://qbin.io/tvi5bng
15:16:19 <Welkin> code is meant to be understood, not a piece of art to stare at
15:17:09 <sproingie> if meaning is obscured, it's hard to understand
15:17:32 <Welkin> I also would not use fst and snd
15:17:35 <Welkin> use pattern matching
15:17:53 <iqubic> Welkin, That's an idea
15:17:58 <Welkin> fst and snd are almost always indicators of places where you should be using pattern matching
15:19:16 <hpc> see also: boolean blindness
15:19:44 <glguy> Ah ha, a chance to use https://github.com/glguy/lift-nary-operator ;  genericOpN @Num @(S(S Z)) (+) :: (Int,Double) -> (Int,Double) -> (Int,Double)
15:20:00 <glguy> (But no, not really a serious alternative)
15:20:05 <iqubic> I just refactored my code using pattern matching
15:20:35 <Tuplanolla> Your addition function is just `join biliftA2 (+)`, iqubic.
15:20:42 <Tuplanolla> I don't think it looks that obfuscated.
15:21:00 <iqubic> I used things like dir@(dirX, dirY) and curSpot@(curSpotX, curSpotY) instead
15:21:12 <iqubic> And that seems to work just fine.
15:21:41 <glguy> scales up, too: genericOpN @Num @(S(S(S Z))) (\x y z -> x+y+z) :: (Int,Double,Float) -> (Int,Double,Float) -> (Int,Double,Float) -> (Int,Double,Float)
15:22:08 <sproingie> :t biliftA2
15:22:09 <lambdabot> error:
15:22:10 <lambdabot>     • Variable not in scope: biliftA2
15:22:10 <lambdabot>     • Perhaps you meant ‘liftA2’ (imported from Control.Applicative)
15:22:35 <Welkin> I just watched this presentation today on point-free https://www.youtube.com/watch?v=seVSlKazsNk
15:22:48 <Welkin> "Point-Free or Die: Tacit Programming in Haskell and Beyond"
15:22:58 <Welkin> I learned a lot from it
15:24:06 <iqubic> What package is biliftA2 in?
15:24:20 <iqubic> And how does that help me with my addition problem??
15:24:37 <Welkin> it's a pattern that fits what you are trying to do, but it is not necessary to use it
15:24:38 <jadrian> hpc: the other side of the coin is abstraction
15:25:28 <sproingie> nothing wrong with hardcoding it if that's all you ever need
15:25:37 * iqubic is going to watch "Point-Free or Die"
15:25:44 <Welkin> I don't use biapplicatives because they are not well known
15:25:44 <jadrian> sproingie: that's a big if though
15:26:18 <iqubic> @pl \a b -> (fst a + fst b, snd a + snd b)
15:26:18 <lambdabot> ap (ap . ((,) .) . (. fst) . (+) . fst) ((. snd) . (+) . snd)
15:26:19 <Welkin> you can write haskell like you would write perl: make it completely incomprehensible to everyone but yourself
15:26:20 <MarcelineVQ> glguy: is there a reason to prefer @(S(S(S Z))) over @3 ?
15:26:29 <Welkin> but I prefer to make it readable to as many as possible
15:26:36 <sproingie> \ g f x y z -> g (f x y z)   ===   ( (.) ( ( (.) (.) ) (.) ) ) (.)﻿
15:26:40 <iqubic> Please don't use the point free version there. 
15:26:41 <sproingie> boobies combinator
15:26:46 <glguy> MarcelineVQ: it's easier to pattern match on S and Z
15:26:46 <Welkin> yes
15:26:52 <glguy> but the 3 is certainly nicer
15:26:52 <Welkin> the boob combinator
15:26:56 <glguy> from a user standpoint
15:26:56 <bob____> Hey guys, I'm looking for the quickest draw in Haskell for API building, people say it's Warp, but isn't Servant faster?
15:27:02 <Welkin> butthere is another name he gives it in the talk: blackbird
15:27:07 <bob____> Servant seems like much less overhead.
15:27:15 <Welkin> bob____: Servant uses Warp
15:27:19 <iqubic> @pl \a b c d e f -> a (b c d e f)
15:27:19 <lambdabot> (.) . (.) . (.) . (.)
15:27:21 <Welkin> they are totally differen things
15:27:25 <Welkin> different*
15:27:36 <Welkin> servant is a library for creating apis, warp is the web server
15:27:46 <bob____> Hmmm
15:27:51 <bob____> I think I'm misinformed.
15:28:09 <Welkin> waro is the only game in town really
15:28:22 <bob____> But for creating API's, would using just warp suffice?
15:28:23 <Welkin> everyone (and every library) seems to use it
15:28:26 <bob____> or is Servant "better" ?
15:28:36 <sproingie> servant ought to be easier, that's why it exists
15:28:36 <Welkin> warp is just the server
15:28:44 <Welkin> you need to use WAI to build on top of it
15:28:52 <Welkin> wai is extremely low level
15:28:55 <Welkin> servant is very high level
15:29:09 <bob____> From that I assume Warp + WAI is faster than Servant.
15:29:09 <Welkin> go with servant
15:29:09 <ertes> there is also snap-server, but it's part of a particular web framework, while WAI and warp are generic
15:29:12 <Welkin> it also uses wai
15:29:21 <Welkin> it's a pyramid 
15:29:28 <Welkin> servant is built on wai and warp
15:29:37 <ertes> bob____: WAI is just an API for web servers, warp is an implementation of that API
15:29:55 <bob____> You know what, I'll just use Servant, and see what's what from there.
15:29:58 <ertes> bob____: servant uses WAI, so if you build a servant app, you will most likely be using servant, WAI *and* warp at once
15:30:06 <iqubic> What's the difference between where and let?
15:30:12 <Welkin> you may end up using wai directly within servant
15:30:20 <bob____> Hmm
15:30:20 <Welkin> as I have done before to implement something that servant didn't support
15:30:27 <Welkin> it all works together
15:30:30 <Welkin> there is no choosing
15:30:42 <bob____> Right, then Servant will do.
15:30:45 <sproingie> iqubic: let comes before, where comes after.  where is just syntax sugar for let
15:30:49 <ertes> iqubic: scope and the fact that (let _ in _) is an expression
15:31:24 <Welkin> where is in scope for the entire function
15:31:40 <Welkin> let is only in scope for expression that come after it in do-notation
15:31:46 <iqubic> Oh.
15:31:54 <sproingie> hm that too.  where is usually used to define support functions
15:31:58 <iqubic> Do people recomend using @?
15:32:10 <Welkin> or for `let ... in <exp>` it is only in scope for <exp>
15:32:18 <iqubic> like dir@(dirX, dirY)
15:32:25 <iqubic> do people like the @ pattern?
15:32:25 <Welkin> iqubic: if you need to match on the entire data structure for some reason, sure
15:32:28 <MarcelineVQ> iqubic: certainly
15:32:35 <iqubic> It makes my code more readable.
15:32:44 <Welkin> then use it
15:33:03 <sproingie> @ is also sugar for inline type annotations now
15:33:21 <iqubic> I just re-wrote (fst a + fst b, snd a + snd b) to using @
15:33:29 <iqubic> and also pattern matching
15:33:42 <ertes> sproingie: well, it's not sugar…  it's just the regular syntax for it =)
15:34:01 <Welkin> in which extension?
15:34:06 <sproingie> built in
15:34:07 <iqubic> How does an inline type annotation work?
15:34:21 <Welkin> > 5 :: Int
15:34:23 <lambdabot>  5
15:34:24 <Welkin> like that
15:34:42 <iqubic> But that uses "::" and not "@"
15:34:53 <Welkin> I am not familiar with using @ for this purpose
15:35:31 <sproingie> ertes: yah got the word "sugar" on the brain lately 8-)
15:35:43 <Welkin> there are new language extensions being added all the time. I can't keep track of them all :P
15:35:56 <ertes> Welkin: TypeApplications
15:36:05 <ertes> sproingie: that sounds unhealthy ;)
15:36:16 <MarcelineVQ> iqubic: that's called TypeApplications if you wanted to search for it, but it's not something a person needs to look into when just starting out
15:36:52 <sproingie> oh right, that needs an extension, i was thinking of something else
15:38:02 <iqubic> Don't you need to use the forall. to use TypeApplications?
15:38:49 <sproingie> naw.  https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
15:40:08 <iqubic> Oh, I saw a vidoe that said you needed to add for forall. to the type signature to get TypeApplications to work
15:40:27 <iqubic> s/vidoe/video/
15:40:28 <sproingie> could have been an older implementation
15:41:44 <iqubic> Yeah. He was basically saying you can use type holes to program things easier. But that was before _ as type hole was a thing. 
15:42:50 <MarcelineVQ> ScopedTypeVariables requires the use of forall to signifiy that you want your type parameters to be scoped  https://ocharles.org.uk/blog/guest-posts/2014-12-20-scoped-type-variables.html
15:42:53 <Welkin> haskell implicitly includes a `forall` for any type variables where it makes sense
15:42:54 <sproingie> type holes are nifty.  would be even niftier if intero could fill them in like other suggestions
15:42:58 <iqubic> https://www.youtube.com/watch?v=52VsgyexS8Q
15:43:09 <iqubic> I use intero.
15:43:42 <MarcelineVQ> this video is much older than TypeApplications, which is quite new, so it wouldn't have been talking about that
15:43:47 <phz_> hey, anyone using selda?
15:43:56 <phz_> I came accross a weird problem (well, two actually)
15:43:57 <iqubic> Yeah, he's using ScopedTypeVariables
15:44:22 <phz_> first, it seems impossible to pass/retrieve primary keys (via insertWithPK for insance, since RowID is opaque)
15:44:38 <phz_> and worse, it seems I can’t have two columns marked as primary keys
15:44:39 <phz_> wtf?
15:44:45 <phz_> anyone knows how to bypass that?
15:44:48 <Welkin> o.o
15:44:55 <Welkin> why would you have two primary keys for a table?
15:45:01 <sproingie> composite key
15:45:04 <phz_> ^
15:45:06 <sproingie> possibly that's a separate type
15:45:11 <phz_> that’s very standard database design.
15:45:36 <phz_> especially when you associate values in your domain
15:49:14 <iqubic> What is intero? Why do I have it installed in Emacs?
15:49:41 <iqubic> Does it even help me??
15:50:08 <MarcelineVQ> the former question should be asked to google before here, the latter isn't answerable by people who are not you or much more information
15:50:27 <sm> iqubic: https://haskell-lang.org/intero
15:51:51 <iqubic> Oh, that's right. It gives me pop-ups with useful information, like compiler warnings. It even tells me why my code can't compile.
15:52:04 <iqubic> It spots errors in my code and alerts me to them.
15:52:13 <sproingie> looking at selda, it doesn't look like it supports composite keys
15:53:00 <phz_> yeah, that sucks
15:53:12 <phz_> even though the whole API is pretty neat
15:53:15 <phz_> that’s the caveat
15:53:16 <sproingie> it's a pretty common omission in db abstraction layers
15:57:34 <sproingie> i tend to write high level APIs in pl/pgsql and target that instead
16:01:59 <Jinxit> sproingie: like stored procedures?
16:02:47 <sproingie> yep.  base CRUD layer, then an app-specific package on top of that
16:04:06 <Jinxit> interesting style
16:04:31 <sproingie> rather old-skool, but it makes it easy to write bindings for whatever language
16:06:18 <n_blownapart> hey wondering: is there a haskell environment that is similar to DrRacket for Scheme?
16:07:07 <EvanR> if so, it better be called DrHaskell
16:08:51 <ertes> (sorry, disconnected) phz_: i tend not to use database abstractions at all, but write a type class for the application itself, then write explicit implementations for individual DBMSes…  tends to be more scalable, even though it's more upfront work
16:08:58 <sproingie> never could handle DrRacket.  some neat features but as an editor it's worse than notepad
16:09:24 <ertes> sproingie: if you use emacs, you can write racket using geiser-mode
16:09:36 <sproingie> exactly what i use
16:17:44 <slack1256> I've never used a database. Are those for when you want the resistant semantics of file in disk with the performance of having them on memory?
16:18:41 <EvanR> you will get more persistance than if you "just" put the data on in a file on disk
16:19:21 <EvanR> i just read the technical docs on SQLite, the amount of testing they put into it and "gotchas" with disk controllers they anticiate is incredible
16:19:24 <sproingie> ACID, it's what's for dinner
16:19:57 <EvanR> for instance, imagine if you wanted to put the number 4 into a file on disk
16:20:12 <EvanR> with a bunch of other numbers next to it
16:20:40 <EvanR> in order for the OS to commit this 4 to a block and then a sector, it must read the whole sector in, modify it, then write it back
16:20:41 <slack1256> ok, lets suppose I want to do that
16:20:46 <slack1256> yep
16:21:10 <EvanR> if a power failure happens in themiddle of that, then you may expect the 4 to other be there, not be there, or be messed up
16:21:37 <EvanR> but if youre paranoid, you dont really have any guarantee everything in that sector isnt also messed up
16:21:43 <davean> EvanR: Yah, you can't assume much of anything at the sector level with disks during writes
16:22:11 <EvanR> SQLite has always took that into consideration
16:22:19 <davean> Of course
16:22:26 <davean> Even ARIES did
16:22:39 <davean> (and things earlier then that)
16:22:55 <sproingie> yes, it's very old technology.  but one you can't count on in a raw filesystem
16:23:08 <davean> Depends on the raw filesystem
16:23:12 <sproingie> sure
16:23:14 <EvanR> chances are your using a file for "resistance" doesnt worry about the possibility
16:23:37 <davean> EvanR: I can't parse that
16:23:56 <pikajude> yeah that sentence doesn't make any sense
16:24:03 <davean> EvanR: But I'll say this is all some of the point of COW filesystems
16:24:15 <sproingie> autocorrect from "persistence" perhaps
16:24:19 <EvanR> first, i was talking ot slack1256 
16:24:31 <EvanR> read the question
16:24:36 <davean> I did
16:24:59 <iqubic> What are we talking about?
16:25:17 <sproingie> persistent resistance.  or resistant persistence, not sure.
16:25:43 <EvanR> second ill use more puncuation, changes are your using-a-file-for-"resistance" doesnt worry about the possibility (of powerunsafe overwrite)
16:26:01 <EvanR> uhg.. chance*
16:26:39 <ertes> slack1256: i tend to use a real database for most things these days, except for read-only things like configuration files
16:26:43 <EvanR> so, you get even more "resistance" (acid) using a database than a file
16:27:03 <sproingie> filesystems give you durability, assuming fsync doesn't lie to you.  the rest of ACID though, you still need a database
16:27:26 <EvanR> you need a database, and you need to enable its acid features...
16:27:34 <EvanR> which are usually not fully in use by default
16:27:55 <EvanR> including in SQLite
16:28:16 <sproingie> usually something fairly sane though.  serializable is a harsh mistress.
16:28:23 <sproingie> and not everyone needs it
16:28:33 <ertes> slack1256: https://sqlite.org/whentouse.html
16:28:37 <EvanR> its a different issue in SQLite
16:29:17 <EvanR> other connections can read the database one way halfway through our transaction, then another way after you commit
16:29:36 <EvanR> even if theyre inside a transaction of their own
16:29:36 <sproingie> pretty sure sqlite defaults to read committed
16:29:42 <EvanR> no
16:29:54 <ertes> sqlite defaults to serializable
16:29:58 <EvanR> no
16:30:37 <ertes> https://sqlite.org/pragma.html#pragma_read_uncommitted
16:30:46 <ertes> "The default isolation level for SQLite is SERIALIZABLE"
16:33:05 <EvanR> Because the acquisition of locks is deferred until they are needed, it is possible that another thread or process could create a separate transaction and write to the database after the BEGIN on the current thread has executed.
16:33:18 <EvanR> default behavior is begin deferred
16:33:30 <EvanR> to get somethig like serializable, you need begin exclusive
16:40:32 <EvanR> im wrong, it looks like your reads will block a writer from actually committing until youre done
16:41:10 <EvanR> so, full serialization by actual serializing
16:42:50 <EvanR> and so SQLite is even more acid by default than other SQLs
16:44:00 <sproingie> which hurts concurrency, but sqlite's use case is for embedded anyway
16:44:40 <sproingie> and largely not a problem when using WAL
16:44:45 <EvanR> ... yeah though its still pretty bad on rpi
16:58:28 <iqubic> What does chunksOf do?
17:00:04 <sproingie> :t chunksOf
17:00:05 <lambdabot> Int -> [e] -> [[e]]
17:00:23 <iqubic> So, what does it do?
17:00:24 <sproingie> seems obvious, try it out in ghci
17:00:36 <sproingie> > chunksOf 5 [1..20]
17:00:38 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
17:01:41 <iqubic> Oh, I see
17:01:59 <iqubic> > chunksOf 5 [1..20]
17:02:00 <EvanR> yes ghci is your friend
17:02:02 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
17:02:08 <iqubic> > chunksOf 4 [1..20]
17:02:10 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]
17:02:23 <sm> doh.. what's the short way to concatenate two strings, adding a separating space only if the first is non-empty ?
17:02:23 <sproingie> > chunksOf 3 [1..4]
17:02:25 <lambdabot>  [[1,2,3],[4]]
17:02:28 <sproingie> and so on
17:03:57 <Koterpillar> sm: intercalate " " . filter (not . null)
17:04:26 <EvanR> sm: i kind of want a higher order function for this a lot... it might be a Traversible gizmo... e.g. in my unfoldr for continuedFractions i used z x f 0 = x; z x f p = f p
17:04:44 <EvanR> youre asking for e x f "" = x; e x f str = f str
17:05:11 <sm> thanks
17:05:20 <EvanR> e s (++ (" " ++ s)) prefix
17:05:30 * EvanR thinks 
17:07:16 <EvanR> :t maybe
17:07:17 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:08:52 <EvanR> > let str = "bar"; pre = "foo"; full "" = Nothing; full s = Just s in maybe str (++ (" " ++ str)) (full pre)
17:08:54 <lambdabot>  "foo bar"
17:09:07 <EvanR> > let str = "bar"; pre = ""; full "" = Nothing; full s = Just s in maybe str (++ (" " ++ str)) (full pre)
17:09:09 <lambdabot>  "bar"
17:09:28 <EvanR> so the missing piece might be :: b -> Maybe b
17:09:50 <EvanR> maybe x f . full
17:14:39 <iqubic> Wait, if I have an Data.Array array indexed with (Int, Int) is the first number the amount of rows or what?
17:15:04 <iqubic> I can't tell if Data.Array arrays are row first or column first
17:16:33 <Koterpillar> Does it matter?
17:17:24 <sproingie> conventionally, it's row,column
17:17:25 <iqubic> Yeah. My printing algorithm will have to change if it's column first. In fact, much of my code will have to change.
17:17:29 <sproingie> unless you come from fortran
17:17:51 <iqubic> sproingie: It looks like it's column first for this.
17:17:55 <sproingie> "row" and "column" are just names for the two ranks
17:18:15 <iqubic> > range ((0, 0), (4, 3))
17:18:17 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
17:18:47 <iqubic> The second number is incremented first there, and that throws off my algorithm.
17:19:42 <sproingie> it's generally what you expect, given nested iteration
17:20:03 <Maxdamantus> > [(a, b) | (b, a) <- range ((0, 0), (4, 3))]
17:20:05 <lambdabot>  [(0,0),(1,0),(2,0),(3,0),(0,1),(1,1),(2,1),(3,1),(0,2),(1,2),(2,2),(3,2),(0,...
17:20:26 <iqubic> If you treat those (Int, Int) as indexes, then it's 3 rows by 4 columns the way range works.
17:20:46 <EvanR> if you treated it the other way around consistently, then ... it will work
17:20:53 <sproingie> or three flubs by four blubs
17:21:01 <Maxdamantus> > [(a, b) | (b, a) <- range ((0, 0), (3, 4))]
17:21:03 <lambdabot>  [(0,0),(1,0),(2,0),(3,0),(4,0),(0,1),(1,1),(2,1),(3,1),(4,1),(0,2),(1,2),(2,...
17:21:19 <EvanR> row and column are precisely things you made up when putting them on paper, they dont exist before hand
17:21:36 <iqubic> sproingie: What is a flub and what is a blub?
17:21:40 <sproingie> exactly
17:22:16 <Maxdamantus> it's actually 4 by 5 btw, because ranges in Haskell are silly and not the logical inclusive start exclusive end
17:22:29 <iqubic> What's that mean?
17:22:51 <EvanR> [0..2] makes sense to me
17:22:51 <Maxdamantus> it means [0..10] would have 10 elements, starting from 0
17:22:53 <sproingie> half-open intervals are handy.  python gets it right
17:23:10 <iqubic> Maxdamantus: I'm making it work for my purposes.
17:23:20 <EvanR> 0..9, 10 elements
17:23:28 <EvanR> 0 to N-1
17:23:38 <Maxdamantus> [0..-1], 0 elements
17:23:44 <iqubic> Oh, right I suppose that's a thing.
17:23:54 <EvanR> > [0..(-1)]
17:23:56 <lambdabot>  []
17:24:18 <EvanR> > [0..(1-1)]
17:24:20 <lambdabot>  [0]
17:24:25 <EvanR> :thumbsup:
17:24:40 <Maxdamantus> 1-based counting was simply a historical mistake due to lack of zero.
17:24:47 <EvanR> Fin n is numbers 0 to n - 1
17:25:05 <EvanR> an n bit number goes from 0 to 2^n - 1
17:25:24 <EvanR> if you have n things, you can number them 0 to n - 1
17:25:24 <sproingie> tho in proper notation you'd say [0..10) which pretty much stomps on any programmer's OCD triggers :)
17:25:44 <EvanR> if you want to countr from 1 you can
17:25:45 <sproingie> er, [0,10)
17:25:52 <EvanR> > [1..10] -- 10 things
17:25:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:25:57 <Maxdamantus> Wouldn't it be nicer to say "Fin n is numbers 0 to n", knowing the latter is exclusive by convention?
17:26:00 <EvanR> but thats even worse
17:26:06 <sproingie> we tend to count from 1
17:26:14 <EvanR> Maxdamantus: then you cant have Fin 0
17:26:20 <Maxdamantus> sproingie: yes, historical mistake.
17:26:22 <EvanR> which is empty
17:26:41 <sproingie> counting zero things was historically a rather trivial exercise
17:26:43 <Maxdamantus> EvanR: why not? 0 inclusive to 0 exclusive is empty.
17:26:44 <quchen> You can have Fin' n = Fin (succ n), tadaa.
17:26:45 <EvanR> i dont tend to count from 1
17:27:20 <EvanR> Maxdamantus: your convention is tedious, requiring the idea of inclusive and exclusive
17:27:42 <Maxdamantus> sproingie: well, it wasn't trivial when the standard number systems (eg, Greek, Roman) had no representation for 0
17:27:53 <EvanR> we only need one not every combination of inclusive and exclusive, for integral sequences
17:28:31 <quchen> I think it’s more common to do induction on Fin compared to asking »what’s the max value«, so »Fin n« having exactly n inhabitants seems like a good choice.
17:28:34 <Maxdamantus> sproingie: our calendar assumes 1-based counting, because the Romans didn't have 0 in their number system .. so you have weird things like that the current century/millenium started in 2001
17:28:43 <sproingie> there was a placeholder for zero, but not as a proper number.  roman numerals you did math by concatenating
17:29:01 <EvanR> much more efficient
17:29:06 <Maxdamantus> sproingie: there was no placeholder for 0
17:29:14 <sproingie> efficient when your calculator is an abacus, yes
17:29:31 <EvanR> a very long abacus
17:29:31 <quchen> The USA still uses weird placeholders to this day to count things, let’s not call the Romans silly so fast
17:29:31 <Maxdamantus> sproingie: I, II, III, IV, VI, .., IX, X, .. there's no 0
17:29:57 * EvanR tries to figure out what quchen is referring to
17:30:02 <sproingie> usually a dot.  ffs, they had the concept of "nothing"
17:30:15 <sproingie> just not a proper system for it
17:30:17 <Maxdamantus> sproingie: likewise in Greek, which is similar to the system we use today, except they used different sets of letters to denote place instead of using placeholders (because noone had thought of 0)
17:30:29 <quchen> EvanR: historically grown awkward units that people get used to in everyday calculations
17:31:01 <iqubic> Actually it is row first. I was wrong
17:31:07 <EvanR> i still dont know how people do wood working with like 0.666667 centimeters
17:32:02 <quchen> Rulers, we use rulers.
17:32:05 <iqubic> LOL
17:32:24 <EvanR> 1/3 of a centimeter is not on the ruler
17:32:31 <EvanR> but 1/3 of an inch is ;)
17:32:56 <EvanR> wait no its not :(
17:32:59 <sproingie> they still managed to build a lot of aqueducts without a zero
17:33:23 <EvanR> anyway, rulers really slow you down sometimes
17:33:30 <sproingie> slide rule yo
17:33:39 <EvanR> brain rule
17:33:51 <sproingie> jah rule
17:34:34 <EvanR> and then they pull the standard length "0.1 in" out of nowhere
17:34:49 <Maxdamantus> century: starting year; 1: 1 .. 2: 101 .. 3: 201 .. 20: 1901 .. 21: 2001
17:34:55 <Maxdamantus> how is this sensible?
17:34:56 <EvanR> gross
17:35:20 <sproingie> i still celebrated the millenium on 2000.  because everyone else did.
17:35:25 <sproingie> it's a celebration of a big round number
17:35:36 <exio4> humans love big round numbers
17:35:50 <EvanR> i changed the starting year in 1880. 1701 1801 1900 2000 2100 to modernize 
17:35:54 <Maxdamantus> But you celebrated it only 1999 years after the beginnig of year 1
17:36:14 <geekosaur> because Christianity, so there was no year 0, 1BC was followed by 1AD
17:36:18 <Maxdamantus> maybe what you were actually celebrating was 2000 years from the beginning of 1 BC
17:36:26 <EvanR> i use year 0 as 1BC
17:37:07 <EvanR> the last of the good old days
17:37:39 <sproingie> when i was a boy, our nintendo was carved from an old apple tree // and we used garden hose to connect it to our steam-powered color tv
17:39:12 <quchen> When I was a boy, our rubber boots were made of wood
17:47:45 <spoonm> when boy I a was, our homemade was grammar
17:50:10 <ertes> http://www.jkbenton.com/images/products/detail/JimBentonYodaPizza.jpg
17:56:19 <EvanR> ertes: funny and annoyingly not consistent with yoda's writers
17:58:42 <dibblego> can I dump all identifiers that a module exports?
17:59:18 <quchen> dibblego: You can use :browse in GHCi
17:59:37 <dibblego> oh yeah cheers
18:09:56 <butterthebuddha> How do I print a list of pairs of strings?
18:10:18 <butterthebuddha> main = do putStrLn (show (hanoi 2 "a" "b" "c"))
18:10:24 <butterthebuddha> ^ that doesn't print anything
18:11:12 <byorgey> butterthebuddha: how do you know it doesn't print anything?
18:11:30 <butterthebuddha> byorgey: I compiled and ran it
18:12:11 <byorgey> butterthebuddha: does it print nothing and then stop?  Or does it sit there not printing anything and you have to kill it with Ctrl-C?
18:12:32 <butterthebuddha> I have to kill with Ctrl-C
18:12:39 <pacak> butterthebuddha: "putStrLn (show blah)" is the same as print blah
18:12:47 <pacak> Ctrl-C means your program gets stuck.
18:12:50 <byorgey> butterthebuddha: OK, in that case it sounds like your 'hanoi' is wrong.  It's probably infinitely recursive.
18:13:10 <butterthebuddha> hanoi n a b c = hanoi (n - 1) a c b ++ [(a, b)] ++ hanoi (n - 1) c b a
18:13:14 <butterthebuddha> That's what I've got for my hanoi
18:13:22 <byorgey> butterthebuddha: that's good, but you need a base case.
18:13:28 <byorgey> otherwise it will never stop calling itself recursively.
18:14:21 <byorgey> hanoi 2 a b c = hanoi 1 a c b ++ ...    hanoi 1 a c b = hanoi 0 a b c ++ ...    hanoi 0 a b c = hanoi (-1) a c b ++ ...   and so on
18:14:44 <butterthebuddha> Is hanoi 0 a b c = [] good?
18:15:16 <byorgey> butterthebuddha: you tell me.  Is that the right list of instructions for moving a stack of zero disks?
18:15:29 <butterthebuddha> Seems so - move nothing because there is nothing there to move
18:15:38 <byorgey> right. very zen. =)
18:15:56 <butterthebuddha> Aight, thanks!
18:16:01 <byorgey> sure!
18:42:10 <butterthebuddha> Is there an in built function to flatten lists?
18:42:27 <kadoban> :t concat -- this?
18:42:28 <lambdabot> Foldable t => t [a] -> [a]
18:48:30 <byorgey> > concat [[1,2,3], [4,5,6], [7,8]]
18:48:32 <lambdabot>  [1,2,3,4,5,6,7,8]
18:48:49 <butterthebuddha> Turns out I didn't actually need to flatten a list, but thanks anyway
18:49:58 <EvanR> > join [[1,2,3],[4,5,6],[7,8,9]]
18:50:00 <lambdabot>  [1,2,3,4,5,6,7,8,9]
18:50:08 * hackage purescript 0.11.5 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.11.5 (PhilFreeman)
18:50:48 <pikajude> you could always use (>>= id)
18:51:15 <EvanR> delightfully esoteric
18:52:05 <verement> @src join
18:52:05 <lambdabot> join x = x >>= id
18:52:10 <pikajude> "esoteric"
19:04:00 <Koterpillar> Is there an example of using http://hackage.haskell.org/package/tinylog somewhere?
19:24:10 <manek> Hello! Could anybody explain to me why Data.Vector is indexed by Int and not by Word? Why we even allow negative indexes to be "used" ? 
19:27:29 <glguy> manek: Word isn't any better than Int, it still has lots of values that are out of range
19:27:47 <glguy> and it's more common to work with Int, which has nicer behavior with subtraction
19:28:00 <manek> glguy: it has, but it does not allow negative values and allow for 2 times more correct values
19:28:49 <glguy> It's quite uncommon that you're indexing an array with more than 2^63 elements, so the extra "correct" values are rarely helpful
19:29:18 <glguy> It's more likely that the behavior that would have lead to a negative index would just lead to a wrapped around very large index
19:29:36 <glguy> which will just make for a harder to detect issue
19:31:01 <glguy> Word is much more suited to bit-manipulation applications
19:31:17 <manek> glguy: hmm, ok, that make sense. I've never been thinking about it this way
19:43:19 <Arcaelyx> Could anyone help me with this? https://ghostbin.com/paste/rrza9
19:43:32 <Arcaelyx> Line 58 seems to be the culprite.
19:43:35 <Arcaelyx> Culprit*
19:44:10 <glguy> Arcaelyx: There don't appear to be any errors included in that paste
19:44:13 <Arcaelyx> If I return 'trades' without 'users' or vice versa, it works by making the API type only have one type.
19:45:44 <Arcaelyx> glguy: I updated the ghostbin with the error I'm getting: https://ghostbin.com/paste/rrza9
19:49:29 <glguy> Arcaelyx: Try reading this http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#more-endpoints
19:53:56 <Arcaelyx> @glguy: Thank you very much!
19:53:56 <lambdabot> Unknown command, try @list
19:54:23 <Arcaelyx> Any links on how to make it work with groundhog + postgresql? That's been making me want to rip my hair out as well.
19:56:05 <glguy> Dunno, I don't use any of servant, postgresql, or groundhog
19:56:17 <glguy> I just clicked through to the docs for server to get the above link
19:58:59 <Arcaelyx> Ah, alright.
20:29:42 <Lokathor> Hexes is now "minimally usable"
20:30:01 <Axman6> ehat is Hexes?
20:30:05 <Axman6> what*
20:30:21 <Lokathor> curse-like lib using opengl and GLFW
20:30:29 <Lokathor> https://github.com/Lokathor/hexes
20:30:45 <Lokathor> needs a ton of work to be good, but you can try it out at least
20:31:23 <Axman6> cool - any examples?
20:31:30 <Axman6> (a video would be great)
20:31:38 <Lokathor> there's a demo executable in the repo if you build it
20:32:17 <Lokathor> it was fairly well documented for a while, now the docs rate has gone down
20:34:13 <Lokathor> I'm gonna do more of the docs right now actually
20:37:11 <Koterpillar> Axman6: why does amazonka-s3-streaming use Info rather than Debug for "**** Created upload ****"?
20:37:38 <Axman6> Koterpillar: Good question. I can change that
20:37:55 <Axman6> I haven't put much thought into logging
20:37:58 <Koterpillar> amazonka says: Info Info messages supplied by the user - this level is not emitted by the library.
20:38:56 <Koterpillar> I feel like it belongs to Debug, from the other messages in amazonka
20:39:25 <Axman6> I agree
20:40:10 <tempeh> I want a simple language/config file that I can use to interact with my library. I just need to be able to create variables and call a few pre-defined functions. Is there a library that already implements something like this? It seems like it would be an easy/useful thing to write generically
20:40:45 <Lokathor> tempeh, turtle is a shell scripting style library, perhaps?
20:41:27 <tempeh> Lokathor, right - but I'd like to be able to specify which symbols are available
20:42:01 <tempeh> Like a simple DSL for building values for a library
20:42:10 <Lokathor> ah, well, that sounds less like a thing you could find ready made
20:42:17 <Axman6> Koterpillar: New version uploaded
20:42:38 * hackage amazonka-s3-streaming 0.2.0.3 - Provides conduits to upload data to S3 using the Multipart API  https://hackage.haskell.org/package/amazonka-s3-streaming-0.2.0.3 (AlexMason)
20:42:50 <Axman6> bam!
20:42:53 <Koterpillar> thank you!
20:42:54 <tempeh> Lokathor yeah, I haven't found it, but it definitely seems like it could be made general easily, so I guess I'll write it
20:43:04 <glguy> tempeh: This is what created Lua
20:43:47 <tempeh> glguy: cool. I haven't paid much attention to Lua, but I guess it is used for game scripting and stuff, and that is pretty much what I'm describing
20:44:00 <Lokathor> you can make entire games in it these days
20:44:06 <Lokathor> Love2d, and such
20:44:09 <tempeh> glguy: just seems like a simple version would be useful
20:44:14 <EvanR> it doesnt have to have anything to do with games
20:44:27 <tempeh> Just the example that game to mind
20:44:31 <EvanR> its just a way to hook something dynamic into C, which is nice in C
20:45:17 * Koterpillar is waiting for Stackage to notice
20:46:05 <tempeh> Well, guess I'll just have to write what I have in mind :)
21:29:19 <Axman6> Koterpillar: that might take a while
21:29:49 <Axman6> Koterpillar: you can add that version to your stack.yaml though, since literally nothing depends on that package it won't need to rebuild much :P
21:34:39 <Koterpillar> Axman6: I meant it being in Stackage's indices at all
21:34:49 <Koterpillar> they scan Hackage twice an hour or something like that
21:35:13 <Koterpillar> Regardless, it's made it so I've already switched :)
21:35:47 <Axman6> it'll probably be in a nightly within 24 hours, but not an LTS for possibly a week or so
21:39:53 <Koterpillar> Well, LTS still has the broken version
21:47:19 <Jinxit> http://lpaste.net/2411337348852744192 why is this not permitted?
21:47:29 <Jinxit> or rather, what's the proper way to do it?
21:47:56 <glguy> Jinxit: Match on Baz
21:48:17 <glguy> The fact that you matched on Bar above has no impact on the type of b on the last line
21:48:28 <glguy> its type remains Foo a b
21:48:34 <glguy> and Foo a b isn't Foo () b
21:49:19 <Jinxit> i see that it solves the problem, but i fail to see why
21:49:36 <glguy> Let's go the other way, why do you think what you wrote should work?
21:49:44 <Jinxit> the type of b is Foo a b, yes, but so is the type of (Baz b)
21:50:07 <Jinxit> because i'm matching on every instance that has an a
21:50:10 <Jinxit> and replacing it
21:50:10 <glguy> OK, and then you make a new value with the righyt type
21:50:30 <glguy> the matching on "every instance that has a" is irrelevant
21:50:49 <glguy> as in, Haskell doesn't car
21:50:51 <glguy> care
21:51:09 <Jinxit> and if i have many more cases without a, i have to match on each one?
21:51:16 <glguy> Yes
21:51:28 <glguy> the cases are all independent
21:51:29 <Jinxit> i think i see the logic but it's a bit clumsy
21:52:08 * hackage servant-auth-server 0.3.0.0 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.3.0.0 (mchaver)
21:52:15 <EvanR> dont repeat yourself <- not always a thing in haskell
21:52:59 <pikajude> that's a syntax error, EvanR 
21:53:04 <pikajude> you can only have one pattern on the lhs
21:53:47 <glguy> and you can't apply (not always) to a, because it's type is Bool...
21:54:15 <EvanR> :t not always
21:54:16 <lambdabot> error: Variable not in scope: always :: Bool
21:54:27 <EvanR> wait...
21:54:35 <EvanR> :t always
21:54:37 <lambdabot> error: Variable not in scope: always
21:56:26 <Koterpillar> :t \always -> not always
21:56:27 <lambdabot> Bool -> Bool
22:01:15 <Jinxit> glguy: oh, now it clicked, it's not that there's a missing case that has an a hidden in it, it's that just copying it across triggers the error
22:01:32 <Jinxit> had it backwards
22:03:26 <glguy> Right
22:21:26 <lpaste> nickkuk pasted “Type level case” at http://lpaste.net/356031
22:22:20 <nickkuk> Hello, everyone. Can you help me to implement type level case in the function withAttributes in http://lpaste.net/356031 
22:22:50 <nickkuk> As I undrestand, I need full strength of singleton types here
22:30:02 <Axman6> nickkuk: should Attributes be '[Attribute]?
22:34:44 <nickkuk> Axman6: It is easier to work with [Attribute], but if it is hard to implement, I'm not against newtype/data
22:40:12 <MarcelineVQ> Axman6: ghc can infer that [Attribute] is promoted because data constructors don't go on the right of  type ... = ...  did you mean something else by your question?
22:41:39 <MarcelineVQ> actually that's a bit silly of me to say ^^; pardon me
22:43:50 <guest_random> I've a tasty test-suite. If I run the binary generated with "--quiet" it just goes to sleep forever. If I don't pass "--quiet" everything runs just fine. The argument "--hide-successes works fine too. Any idea why "quiet" might be failing?"
22:44:59 <nshepperd> i think [Attribute] is right actually, and '[Attribute] wouldn't work
22:46:08 <nshepperd> because Attributes is supposed to have inhabitants, and [Attribute] :: * but '[Attribute] :: [*]
22:46:30 <nshepperd> weird that i never noticed that before
23:06:44 <nshepperd> nickkuk: seems like you can do it by throwing a type class at it
23:07:02 <nshepperd> class KnownAttributes attrs => WithAttributes attrs where { withAttributes :: (forall attr p1 . KnownAttribute attr => p1 attr -> a) -> p2 attrs -> [a] }
23:07:23 <nshepperd> that lets you case match on attrs, whether it is '[] or ':
23:16:41 <cocreature> I always find it slightly unsatisfying that we have to use typeclasses to recurse on type-level lists
23:26:05 <glguy> cocreature: if you don't want to use type classes use a singleton gadt
23:28:36 <jle`> don't use ad-hoc typeclasses
23:28:39 <jle`> use singletons
23:28:58 <jle`> you do'nt need the full strength of the singleton library
23:29:02 <jle`> you just need a singleton for [Attribute]
23:29:07 <jle`> which is pretty simple :)
23:29:49 <jle`> in fact, the singleton library already has a singleton for the [Attribute] kind
23:30:46 <jle`> nickkuk: if you have a SingI attrs constraint, you can get `sing :: Sing attrs`
23:30:55 <jle`> and you can pattern match on that
23:31:17 <jle`> if sing is SNil, then attrs ~ '[]
23:32:29 <jle`> if it uses the SCons constructor, then attres ~ x ': xs
23:32:31 <cocreature> glguy: yeah that’s what I usually do but singletons are also not really satisfying imho
23:32:39 <nickkuk> jle`: At now I almost done it with ad-hoc typeclasses :) But at now I will swith to your solution (if I'll understand it)
23:33:13 <cocreature> the fancy typelevel stuff just feels very much like it has been bolted on after designing the language which tbf it is :)
23:36:07 <nickkuk> jle`: do I need SingI (or any other singleton stuff) instance for AttributeType ?
23:39:57 <jle`> hm, the AttributeType constraint makes it a bit weird
23:40:06 <jle`> i didn't notice it before
23:41:11 <nickkuk> jle`: initially, one of my problem was actually AttributeType constraint
23:41:13 <jle`> can you make AttributeType a closed kind (with data kinds)?
23:41:18 <jle`> instead of an open set?
23:41:26 <nickkuk> I want it to be open
23:42:23 <jle`> i think it might be more complicated in this case unfortunately
23:42:39 <jle`> it's possible, but i'm not sure if it's worth the trouble
