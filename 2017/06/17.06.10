00:20:00 <mark777tek> #swift
01:10:53 <hoppfull>  Hello! h x y = f(g x y) can be simplified with composition: h x = f ∘ (g x). Can h be simplified further?
01:12:31 <johnw> it can be, at the cost of readability
01:12:44 <johnw> @pl \x y -> f (g x y)
01:12:44 <lambdabot> (f .) . g
01:30:10 <hoppfull> johnw: thanks!
01:44:00 <SepakoRayl> "Template Haskell relies on GHC's built-in bytecode compiler and interpreter to run the splice expressions."
01:44:47 <SepakoRayl> why is this required?
01:45:33 <SepakoRayl> Why does ghc need the bytecode compiler in order to do ast transformations?
01:47:07 <merijn> SepakoRayl: Because how else would it run the code?
01:47:13 <cocreature> SepakoRayl: because template haskell can contain arbitrary Haskell code. you can even do IO at compile time
01:47:20 <SepakoRayl> ah okay
01:47:37 <SepakoRayl> obviously
01:48:57 <SepakoRayl> just now reading more about it, forgot it uses normal monad syntax :P
02:10:51 <SepakoRayl> anyone knows how ghc keeps tract of source locations internally?
02:11:10 <SepakoRayl> does it keep all token info ?
02:30:49 <ph88^> SepakoRayl, there is a design document about ghc .. that doesn't answer your question specifically but when you are interesting in ghc you should read it
02:31:10 <SepakoRayl> that seems promising
02:36:12 <ph88^> SepakoRayl, http://www.aosabook.org/en/ghc.html
02:50:46 <ph88^> why is the actual type here ([Value], ([Value], [Value])) ??   https://bpaste.net/show/5cb62cff6130
02:53:04 <merijn> ph88^: The return value of withAccConduit has no 'm' in it, that seems wrong
02:53:29 <merijn> ph88^: It's inferring the return as taking place in the ((,) Value) monad
02:59:32 <ph88^> thx merijn i got it fixed
02:59:45 <ph88^> do you work with conduit as well ?
03:00:02 <merijn> Right now I am, but only 'cause I have too :p
03:00:31 <ph88^> lol :p
03:00:36 <ph88^> you prefer pipes ?
03:00:44 <merijn> yeah
03:01:03 <ph88^> i think there are more packages compatible with conduit .. it's convenient ^^
03:01:17 <ph88^> does pipes work with ResourceT ?
03:01:26 <merijn> No, pipes uses pipes-safe
03:01:30 <ph88^> oh ok
03:01:37 <merijn> Although I could you probably could use ResourceT?
03:01:44 <ph88^> you have to use conduit for your job ?
03:01:59 <merijn> I don't *have* to do anything :p
03:02:08 <merijn> But all the other libraries I'm using right now use conduit
03:02:18 <ph88^> :D
03:02:24 <ph88^> that's what i meant :P haha
03:05:45 <ph88^> didn't know ((,) Value) was a monad :/
03:05:58 <ph88^> they making everything monads now or what
03:12:23 <freeside> well, technically, they making everything a monoid in the category of endofunctors
03:23:59 <jle`> ph88^: it's Writer
03:24:37 <jle`> one of the first monads usually talked about when learning about monads :)
03:42:39 <bollu_> quchen:  ping
03:50:48 <LordBrain> The other day someone was looking for a disk-backed b-tree in haskell, i just published one to github...
03:51:42 <LordBrain> Unode, I think it was you
03:51:52 <LordBrain> Unode, https://github.com/jimcrayne/lmdb-bindings
04:13:35 * hackage selda-postgresql 0.1.5.0, selda-sqlite 0.1.5.0, selda 0.1.8.0 (AntonEkblad): https://qbin.io/9fpwojs6
04:36:35 * hackage variation 0.1.0.0 - nominal value with possible variations  https://hackage.haskell.org/package/variation-0.1.0.0 (cspollard)
05:02:37 <LordBrain> Saved package config file seems to be corrupt. Configuring with default flags. <-- how do i fix this cabal error?
05:02:45 <LordBrain> where is the package config file?
05:27:05 * hackage variation 0.1.1.0 - nominal value with possible variations  https://hackage.haskell.org/package/variation-0.1.1.0 (cspollard)
05:34:35 * hackage sym-plot 0.3.0 - Plot permutations; an addition to the sym package  https://hackage.haskell.org/package/sym-plot-0.3.0 (AndersClaesson)
05:52:05 * hackage haskdogs 0.5.0 - Generate tags file for Haskell project and its nearest deps  https://hackage.haskell.org/package/haskdogs-0.5.0 (SergeyMironov)
06:06:26 <ij> How does megaparsec parse? If parserA *> parserB and parserA is all-consuming, then it will never work?
06:12:56 <quchen> If parserB expects input, then no.
06:13:03 <quchen> But if parserB is e.g. »pure ()«, then yes.
06:25:05 * hackage schematic 0.1.2.0 - JSON-biased spec and validation tool  https://hackage.haskell.org/package/schematic-0.1.2.0 (dredozubov)
06:34:51 <Koln> does anyone know how I can get Hlist in with ghc 8
06:35:13 <Koln> or install an old ghc version just for using hlist?
06:38:19 <ij> I put my code in src/ and cabal has hs-source-dir is src. Problem: stack ghci cannot load modules any more.
06:39:28 <ij> «stack ghci --ghci-options -i=src»
06:47:54 <Koln> all I want
06:48:12 <Koln> is to be able to use a library that needs an older version of ghc
06:48:34 <Koln> nobody knows how to do this?
06:49:35 * hackage threepenny-editors 0.2.0.11 - Composable algebraic editors  https://hackage.haskell.org/package/threepenny-editors-0.2.0.11 (PepeIborra)
06:49:44 <cocreature> Koln: well either fix the library so it works with a newer version of ghc or downgrade ghc
06:50:27 <Koln> can I get an older version of ghc with a virtualenv or something like it?
06:51:15 <cocreature> there is nothing like virtualenv but you can just install it into some other directory and adjust PATH or pass -w to cabal
06:54:31 <cocreature> you could also use stack which manages GHC installations automatically for you
06:54:43 <ventonegro> ingkazuba01
06:54:59 <ventonegro> ooops
06:57:58 <fendor> hey, can i tell stylish haskell to be as strict as the elm `elm-format` utility?
06:59:40 <Koln> so how can I use stack to install an old ghc?
07:02:34 <Jinxit> Koln: stick it in your stack.yaml file
07:03:03 <Koln> how do I do that?
07:03:28 <Koln> I'm a total noob who just wants to write some haskell
07:04:37 <Jinxit> do you have the file?
07:04:49 <cocreature> Koln: in that case, are you sure that you want to use HList? that package is not exactly targeted at people new to Haskell
07:05:35 <Koln> yes I'm sure
07:06:12 <Koln> I have stack.yaml
07:06:30 <Koln> resolver is lts-8.17
07:06:43 <Jinxit> and there you pick whatever version you want
07:06:54 <Koln> I changed it to ghc-7.10.2
07:07:05 <Koln> now what
07:07:08 <Koln> stack setup?
07:07:35 <Jinxit> not sure tbh, try some things and i'm sure stack will yell at you to do the right thing
07:10:50 <fendor> stack build
07:10:56 <fendor> Koln, stack build
07:11:53 <Koln> base-4.8.1.0 must match >=4.9 && <4.10 (latest applicable is 4.9.1.0)
07:12:36 <cocreature> you probably want to use an lts release that comes with GHC 7.10 instead of setting your resolver to ghc-7.10.3. the latter will require that you specify everything in extra-deps
07:12:55 <cocreature> lts-6.35 is the latest lts release for GHC 7.10
07:14:32 <jsmock_>  /quit
07:22:23 <ij> Is there a megaparsec combinator that tries a parser until the first time it succeeds? Something like p' p = p <|> (anyChar *> p' p)
07:26:26 <Koln> It'
07:26:31 <Koln> s not working though
07:26:33 <Koln> The following package identifiers were not found in your indices: hlist-0.4.2.0
07:26:40 <Koln> why can;'t I just type stack install hlist
07:27:02 <c_wraith> Koln: you're describing the cabal workflow, not the stack workflow
07:27:12 <c_wraith> Koln: there's nothing wrong with just using cabal
07:27:40 <Koln> I don't want to downgrade ghc though because I"'m scared it'll break a lot of things and it'll take me hours to find a solution like it is now
07:27:52 <Koln> I just want to use hlist
07:28:11 <c_wraith> ij: it looks like you want something like dropUntil, even though that doesn't actually exist?
07:28:50 <ij> c_wraith, I guess so. I want to find the first occurrence of an expression.
07:29:17 <c_wraith> ij: you could fake it with manyTill
07:29:32 <ij> Hm, I guess so.
07:29:50 <c_wraith> oh, not really.  manyTill doesn't return the terminator
07:30:04 <c_wraith> which is the part you really want
07:30:14 <ij> "findFirst p = manyTill p *> p" maybe?
07:30:58 <c_wraith> No, that won't really work.  It looks like megaparsec doesn't have a combinator that does that.
07:31:34 <ij> Seems like a basic thing to have.
07:35:56 <fendor> how much can i customize stylish haskell for a project?
07:37:14 <epit3ch> qsdfqsdf
07:37:18 <epit3ch> qsdf
07:37:19 <epit3ch> qsdf
07:37:19 <epit3ch> sdf
07:37:20 <epit3ch> sdf
07:38:05 * hackage aivika 5.1, aivika-transformers 5.1, aivika-branches 0.2 (DavidSorokin): https://qbin.io/wub4nmmbt
07:39:49 <Jinxit> why are monad transformers (in mtl) defined as newtypes of functions of kinds?
07:40:05 * hackage aivika-distributed 0.5, aivika-lattice 0.2, aivika-realtime 0.2 (DavidSorokin): https://qbin.io/ezje5ym
07:41:43 <phadej> Jinxit: of kinds?
07:43:41 <Jinxit> type WriterT w m a :: * -> (* -> *) -> * -> *
07:43:43 <Jinxit> like that
07:43:52 <Jinxit> idk the proper terminology
07:44:09 <Jinxit> *newtype
07:44:23 <opqdonut> it just spells out the kinds explicitly
07:44:38 <opqdonut> w :: *, m :: * -> *, a :: *
07:44:43 <opqdonut> it's a stylistic thing I guess
07:44:58 <Jinxit> oh
07:45:49 <iqubic> :k RWST
07:45:50 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
07:46:02 <iqubic> WHAT???
07:47:25 <michalrus> Hey, which one is the sanest prelude, without partial functions and throwing? :)
07:47:53 <opqdonut> actually the definition is just `newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }`
07:48:04 <opqdonut> so I guess haddock shows the kind when it's complex
07:48:56 <fendor> michalrus, i'm currently using ClassyPrelude. But then you'd have to learn a lot 
07:49:08 <fendor> if you just want to get rid of partial function, use the Safe module
07:49:14 <michalrus> Up for learning!
07:49:17 <michalrus> OK. :) Thank you.
07:49:22 <opqdonut> ok it's weird, haddock shows the kind for re-exported things, but not for things that are in the module
07:49:27 <opqdonut> c.f. http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Ordering
07:49:33 <opqdonut> and http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Either
07:49:50 <Jinxit> opqdonut: thanks, i was trying to find that but got lost in the imports
07:50:12 <fendor> no problem :)
08:02:06 <Koln> I downloaded hlist
08:04:06 <Jinxit> what do you want to use hlist for anyways?
08:05:22 <ij> c_wraith, «t p = p <|> (anyChar *> t p)» works, but requires -XTypeFamilies.
08:07:49 <iqubic> How does RSWT work?
08:09:15 <opqdonut> has anyone seen `Exception encountered when parsing index tarball: TrailingJunk`?
08:09:20 <opqdonut> I get this from stack
08:09:34 <opqdonut> a build works on my laptop but not on a server
08:09:40 <byorgey> me, writing some Haddocks: "gee, I wish I could include LaTeX."  "... wait, do I possibly remember reading something about that?"  ... a few google searches later ... yay! the version of Haddock I have installed already supports it =D
08:13:57 <opqdonut> ok nuking ~/.stack might have fixed it
08:14:48 <Jinxit> iqubic: it's a reader, writer and state all at once
08:15:13 <Jinxit> meaning you can mix put/tell/get etc freely without lifting anything
08:19:13 <iqubic> How does one use the Writer monad?
08:19:29 <iqubic> Jinxit: Isn't it also a Monad Transformer?
08:19:51 <Jinxit> correct
08:20:03 <Jinxit> (there's RWS if you don't need the T)
08:20:27 <Jinxit> writer is pretty simple, it mappends a monoid when you use 'tell'
08:20:53 <Jinxit> so a Writer [String] a might be a simple logger
08:21:15 <Jinxit> where you can `tell ["message goes here"]`
08:21:48 <iqubic> What is the type of Writer?
08:22:13 <Tuplanolla> :k Writer
08:22:14 <lambdabot> * -> * -> *
08:22:34 <Tuplanolla> Did you really mean to ask that, iqubic? Maybe you should read about it first.
08:22:48 <Jinxit> that's a bit like asking the type of Maybe or Either
08:25:55 <iqubic> Well I want to know what the newtype declaration looks like for a writer
08:26:27 <monochrom> This is trivially findable on the doc.
08:26:28 <Tuplanolla> You can browse the Haddock documentation for that and more, iqubic.
08:26:47 <monochrom> As are 90% of your past questions.
08:27:27 <monochrom> The other 10%, typeclassopedia and whatnot.
08:28:04 <Tuplanolla> Even more generally, only asking questions here is not a good way to study, because answers tend to be terse, so you miss all the motivation and nuance.
08:28:35 * hackage hakyll 4.9.7.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.9.7.0 (JasperVanDerJeugt)
08:28:53 <monochrom> Actually I wouldn't mind that if the haskell.org committee would receive us$60 per answer.
08:29:47 * EvanR joins that committee real fast, then encourages iqubic to continue, then sits in the back with mint julip
08:35:48 <orion> Who is on the committee?
08:37:58 <koala_man> I created a docker image with wine and windows ghc. it's now automatically compiling .exe files on every git commit. Pretty neat.
08:39:14 <monochrom> Ah here: https://wiki.haskell.org/Haskell.org_committee
08:50:50 <Welkin> how would you describe haskell's type system on the lambda cube?
08:50:58 <Welkin> and where does hindley-milner fall?
08:51:32 <Welkin> especially now that dependent types have been partialy added
08:52:35 * hackage generic-lens 0.1.0.0 - Generic data-structure operations exposed as lenses.  https://hackage.haskell.org/package/generic-lens-0.1.0.0 (kcsongor)
08:55:55 <cocreature> Welkin: using the diagram on wikipedia, Haskell should be on the line of λω and λPω
08:57:28 <Welkin> and how does hindley-milner fit in?
08:57:29 <byorgey> although it is not actually on the line because it also has other fancy stuff like type equalities / coercions
08:58:43 <cocreature> byorgey: we need a higher-dimensional lambda cube :)
08:59:11 <byorgey> Welkin: Hindley-Milner is what you need for System F, aka λ2 on the wikipedia diagram
08:59:47 <EvanR> the lambda infinity cube, sounds like a marvel movie
08:59:58 <byorgey> and of course variants of it are used for the other systems on the top face of the lambda cube.
09:00:07 <byorgey> haha
09:00:14 <cocreature> System F has higher-rank polymorphism which HM in its original presentation doesn’t have iirc
09:00:50 <byorgey> I thought that was System Fω ?
09:01:06 <byorgey> maybe you're right though, I can rarely keep the precise details straight
09:01:07 <cocreature> hm maybe I’m confusing things
09:01:20 <cocreature> the names aren’t helping remembering what is what
09:01:29 <byorgey> no, they don't =)
09:03:02 <cocreature> various stackoverflow answers seem to suggest System F does have higher-rank polymorphism but I can’t find a definite source
09:05:13 <byorgey> maybe so.  You are definitely right that H-M does *not* have higher-rank polymorphism.  That's the key that makes it tractable.
09:05:59 <byorgey> i.e. it has 'type schemes' where foralls can only occur at the very top level, followed by a (monomorphic) type
09:07:14 <monochrom> By higher-rank polymorphism, do you mean for example (∀t. (t -> t) -> t -> t) -> Bool?
09:07:26 <lyxia> system F has higher rank polymorphism. It's the system in which you can make encodings à la Church or Scott.
09:07:28 <monochrom> (Apart from System F not having a built-in Bool.)
09:10:00 <byorgey> monochrom: yes, foralls occuring to the LHS of an arrow type
09:10:07 <byorgey> lyxia: right, good point
09:10:11 <ftz> hi
09:10:31 <monochrom> Then it's in System F. See for example Theorem For Free or TaPL
09:11:20 <byorgey> hi ftz , welcome
09:11:25 <ftz> i was hoping to get some help understanding the reader monad
09:12:00 <ftz> id appreciate any links as well
09:12:03 <byorgey> monochrom: yes, you're right
09:15:12 <byorgey> ftz: what is it you're having trouble understanding?
09:28:11 <digitalice> hello!
09:28:54 <digitalice> got a question
09:29:21 <c_wraith> so do I.  Are you discrete ice or alice's fingers?
09:29:39 <hpc> haha
09:29:57 <glguy> frostbite?
09:30:05 <c_wraith> could be that, too
09:30:19 <c_wraith> digitalice: in any case, fire away with haskell questions whenever you like :)
09:31:32 <fendor> what is a decent logger in haskell?
09:31:59 <c_wraith> if fast-logger works, it's probably your best choice
09:31:59 <digitalice> I've got a function called "valid" that receives a "status" and a "message" and returns a boolean. I would like to use ANY ... but I don't know how to pass the "status".
09:32:11 <c_wraith> But fast-logger doesn't necessarily work for all use cases
09:32:53 <digitalice> any valid status [AM, SM, AV, SV ... these are messages ...]
09:33:02 <digitalice> something like that :)
09:33:04 <c_wraith> Oh.  add parens.
09:33:12 <c_wraith> any (valid status) [...]
09:33:35 <c_wraith> that makes the partially-applied function (valid status) the first argument of any
09:33:50 <digitalice> uuhhh 
09:33:52 <digitalice> perfect
09:33:55 <digitalice> thanks c_wraith !
09:33:57 <fendor> digitalice, so, no custom messages, or what?
09:34:03 <hpc> fendor: depending on how compatible with other OSs you need to be, you might consider jumping straight to a syslog api
09:34:26 <digitalice> fendor: well, there are possible oves ... is a game :)
09:34:26 <hpc> (and depending on how high-level of an interface you want)
09:35:04 <fendor> hpc, i do not care, we are only on posix systems currently
09:35:11 <cocreature> monad-logger is also a pretty nice API around fast-logger
09:36:24 <fendor> so, monad-logger and fast-logger are easy to use and sufficiently powerful?
09:36:57 <cocreature> you haven’t told us your requirements so “sufficiently powerful” is hard to answer
09:37:37 <EvanR> definition of logger power
09:38:11 <fendor> hehe, the requirements are to have a logger which can print custom types, the logger can be turned off, and ideally shows details such as timestamps
09:38:19 <monochrom> You need to just answer "yes" because we're in the First World so everything is sufficient :)
09:39:54 <EvanR> if you have a function, for the sake of argument, of type f : String -> IO () which does the logging, and another function g : PrintCustomType a => a -> String
09:40:06 <fendor> is haskell the first world or do you mean literally first world like europe?
09:40:08 <EvanR> then f . g : PrintCustomType a => a -> IO ()
09:40:37 <monochrom> The "First World problem" kind of First World.
09:41:09 <fendor> i want more power?
09:41:18 <fendor> more food?
09:41:27 <EvanR> i see fast-logger doesnt use String though
09:41:29 <c_wraith> Tim Taylor teaches Haskell?
09:41:59 <fendor> EvanR, Text is also good
09:42:37 <EvanR> it doesnt use Text
09:42:45 <EvanR> you can log with any texty thing though
09:42:59 <fendor> good enough for me
09:43:00 <cocreature> you can even log with non texty things if you supply your own instance for ToLogStr
09:43:42 <monochrom> Oh interesting, it uses LogStr.
09:44:04 <cocreature> which is basically a bytestring builder iirc
09:44:04 <monochrom> Sometimes you just have to read the doc yourself.
09:44:11 <monochrom> Yeah.
09:44:25 <EvanR> if f : LogStr -> IO (), and h : PrintCustomType a => a -> String, and g : String -> LogStr, then f . g . h : PrintCustomType a => a -> IO ()
09:44:55 <EvanR> logging ala carte
09:46:21 <fendor> mhm... so, now i have another typeclass to implement? ^^  yeah! 
09:46:27 <James123> Can anyone explain how this works: (reverse >>= (==)) It returns true for palindrome strings I think, but I don't really get it :/
09:46:39 <EvanR> logging has nothing to do with PrintCustomType
09:46:47 <EvanR> you can find a different package for that
09:46:50 <glguy> ?unpl reverse >>= (==)
09:46:50 <lambdabot> (reverse >>= (==))
09:46:52 <cocreature> fendor: you only need to implement it if there isn’t already an instance for your type. there are instances for Text, ByteString and String
09:47:23 <fendor> cocreature, yeah you're write, thanks!
09:47:51 <EvanR> oh yeah, implement ToLogStr directly
09:48:10 <glguy> > ((f :: Expr -> Expr) >>= (g :: Expr -> Expr -> Expr)) x
09:48:12 <lambdabot>  g (f x) x
09:48:28 <cocreature> that Expr stuff still seems like magic to me
09:48:31 <glguy> James123: Using the Monad ((->) r) instance, >>= behaves like this
09:49:17 <James123> glguy: thank you, now it makes some sense
09:56:34 <Welkin> @djinn forall a. a
09:56:34 <lambdabot> -- f cannot be realized.
09:57:24 <Welkin> is the exference bot gone?
09:57:34 <Welkin> `forall a. a` is bottom, right?
09:57:52 <monochrom> Yes.
09:58:07 <Welkin> and that would be what at the value level?
09:58:13 <Welkin> it there only `undefined`?
09:59:07 <monochrom> bottom is already value level. But if you mean you're looking for concrete Haskell code, it can be undefined, error "xxx", or a loop you write yourself.
09:59:25 <Welkin> okay
10:12:04 * hackage th-abstraction 0.2.2.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.2.2.0 (EricMertens)
10:15:05 * hackage diagrams-lib 1.4.1.2 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.4.1.2 (BrentYorgey)
10:18:35 <mbw> I have a question about the usage of Phantom Types. In this article on the wiki https://wiki.haskell.org/Phantom_type, they declare "data FormData a = FormData String" (should probably be a newtype), and they do not export the data constructor. Then they proceed to show usage of different types "FormData Validated" and "FormData Unvalidated" etc. However, they do export a function "liftStringFn :: (String -> 
10:18:41 <mbw> String) -> FormData a -> FormData a", allowing you to define a function "dataToUpper = liftStringFn (map toUpper)". While it isn't possible to turn a FormData Unvalidated into a FormData Validated (since you can't pattern match), you could certainly turn a FormData Validated into something with corrupted internal state, via liftStringFn. Doesn't exporting this function defeat the whole purpose of using 
10:18:46 <EvanR> to get mouse clicks in diagrams, do you have to use GTK backend
10:18:47 <mbw> Phantom Types in this scenario?
10:18:52 <sproingie> holy wall of text batman
10:19:26 <byorgey> EvanR: no
10:19:39 <monochrom> Speaking of which, Batman Adam West just passed away.
10:19:48 <sproingie> :(
10:20:02 * EvanR retires his various adam west jokes
10:20:05 <byorgey> EvanR: my student has successfully been using diagrams + threepenny-gui (with the SVG backend) and getting mouse clicks
10:20:33 <EvanR> hmm ok
10:20:41 <EvanR> so its really not dependent on the backend
10:20:47 <byorgey> but there's nothing special about threepenny-gui.  I'm sure you could easily use reflex-dom or something like that
10:20:57 <sproingie> mbw: do you have an example that does corrupt the state?  the example should probably be revised if so
10:21:30 <mbw> sproingie I could just pass (const "") as function.
10:21:36 <byorgey> no, it's not.  As long as you can get something to tell you the coordinates of a click in pixels, you can use diagrams to transform the click back into 'diagram coordinates'
10:22:02 <mbw> sproingie: It's contrived, but just allowing users to modify this internal string willy-nilly seems kind of stupid to me.
10:22:47 <sproingie> mbw: yah presumably in real-world code you wouldn't have such open access to a validated string
10:23:08 <sproingie> not without making it unvalidated again anyway
10:23:46 <EvanR> it depends on what Validated means
10:24:04 <nshepperd_> mbw: I wouldn't say it completely defeats the point. You can at least use quickCheck to verify that the string stays valid
10:24:33 <glguy> The goal is to provide some help in keeping track of things, not to make your life harder by hiding information that you might need in another part of the code
10:25:01 <EvanR> another gripe here is the idea of Sanitization
10:25:10 <sproingie> true, validated could mean anything for a contrived example, but being able to replace it with an arbitrary string sort of defeats the purpose.  real-world, you could use a newtype and carefully constrain what works on validated strings
10:25:19 <EvanR> i have never understood how a sanitization process T -> T outputs valid data
10:25:22 <mbw> It's probably a little much to expect Phantom Types to catch all types of logic errors. If you can't define functions of type Phantom a -> Phantom a, you are just working with different types, on the other hand.
10:25:41 <EvanR> mbw: yes so theres a few problems with this page
10:25:42 <sproingie> i've used phantom types to great effect in java
10:27:30 <EvanR> also to simply return a string that has been validated, a simple smart constructor would suffice, no need for phantoms
10:27:46 <mbw> Maybe in this case of scenario you should only expose bracketed functions or something, which check that data stays valid (whatever that means here).
10:27:49 <EvanR> so we really need a better example of proper use of phantoms
10:27:52 <monochrom> sproingie: w00t!
10:28:01 <nshepperd_> Presumably you would normally write a small set of other functions with the help of liftStringFn, and then use those, rather than using direct access to the underlying string willy nilly
10:28:15 <monochrom> Oh the Java people do have this "marker interface" idea too.
10:28:27 <EvanR> right, but it says "the library exports liftStringFn"
10:28:44 <mbw> Exactly. If it was only used internally, you could presumably just pattern match.
10:29:25 <nshepperd_> "small set of other functions" doesn't mean that all those functions are necessarily internal
10:30:34 <sproingie> dataToUpper being an example of one such function that'd presumably be safe to export
10:30:46 <digitalice> another question :)
10:31:33 <digitalice> Got this type: data Mov where {AM :: Mov ; SM :: Mov ; AV :: Mov ; SV :: Mov } deriving (Eq, Show)
10:32:33 <EvanR> isomorphic to North South East West
10:32:42 <digitalice> is there any way to get a list of al items ... like list Mov returns [AM, SM, AV, SV]
10:32:55 <c_wraith> digitalice: add Enum to the deriving list
10:32:56 <sproingie> deriving Enum
10:33:07 * sproingie loses
10:33:13 <EvanR> and Bounded ?
10:33:16 <c_wraith> digitalice: then you can do [AM ..] to get them all
10:33:22 <sproingie> doesn't Enum imply Bounded?
10:33:25 <c_wraith> no
10:33:35 <c_wraith> > maxBound :: Double
10:33:37 <lambdabot>  error:
10:33:37 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘maxBound’
10:33:37 <lambdabot>      • In the expression: maxBound :: Double
10:33:43 <digitalice> sorry, I didn't get it ...
10:33:58 <EvanR> (actually i want a dedicated class that goes [AM..] but doesnt require Enum or Bounded shenanigans)
10:34:00 <c_wraith> Of course, Double's Enum instance is garbage anyway, but it exists
10:34:12 <glguy> digitalice: Note that you can write that: data Mov where AM, SM, AV, SV :: Mov
10:34:21 <Welkin> > enumFromTo 1 5
10:34:24 <sproingie> Double is technically enumerable, having limited precision
10:34:24 <lambdabot>  [1,2,3,4,5]
10:34:36 <Welkin> the ... is syntactic sugar for `enumFromTo`
10:34:39 <Welkin> it's a function
10:34:45 <digitalice> what I want is to get all the Types from that enum in a list
10:34:46 <mbw> > succ pi
10:34:48 <lambdabot>  4.141592653589793
10:34:49 <c_wraith> sproingie: sure.  it's the details of the instance are the part that are garbage
10:34:50 <EvanR> functions are technically enumerable, godel encoding
10:35:10 <sproingie> digitalice: there's only one type.  you'll get a list of type constructors, Enum gives you that for free
10:35:13 <sproingie> :i Enum
10:35:18 <Welkin> I meant ..
10:35:30 <digitalice> instead of doing any valid [AM, SM, AV, SM] ... i want to do any valid Mov
10:35:33 <Welkin> > [1..5] == 1 `enumFromTo` 5
10:35:35 <lambdabot>  True
10:35:54 <c_wraith> > [1.0, 4, .. 9] -- sproingie, this is what I mean by garbage
10:35:56 <lambdabot>  <hint>:1:10: error: parse error on input ‘..’
10:35:58 <EvanR> what would a non garbage Enum instance for Double be
10:36:01 <hpc> the fun part about Double is that it has... floating point precision
10:36:03 <c_wraith> > [1.0, 4 .. 9] -- sproingie, this is what I mean by garbage
10:36:05 <lambdabot>  [1.0,4.0,7.0,10.0]
10:36:11 <EvanR> > [3 .. 6] :: Pico
10:36:13 <lambdabot>  error:
10:36:13 <lambdabot>      • Couldn't match type ‘[Integer]’ with ‘Data.Fixed.Fixed E12’
10:36:13 <lambdabot>        Expected type: Pico
10:36:15 <EvanR> > [3 .. 6] :: [Pico]
10:36:16 <c_wraith> in what way does 10 deserve to be in that list?
10:36:17 <lambdabot>  [3.000000000000,3.000000000001,3.000000000002,3.000000000003,3.000000000004,...
10:36:20 <hpc> so you basically have something like data Nat = 1 | 2 | 3 | 4 | 8 | 10 | 12 | 16 | ...
10:36:22 <EvanR> ^ haha
10:36:57 <sproingie> c_wraith: that is pretty odd
10:37:25 <c_wraith> sproingie: it's part of the haskell spec!  One of the parts that should be changed...  :)
10:37:37 <mbw> Can you make "succ pi" behave return pi + 0.00000...1 using Data.Fixed?
10:37:52 <Welkin> how can you `succ` pi?
10:37:53 <mbw> What horrible english. I apologize.
10:37:54 <EvanR> theres no pi in Data.Fixed
10:38:03 <Welkin> it is irrational
10:38:13 <mbw> I just don't expect succ pi to return 4.15
10:38:17 <mbw> > succ pi
10:38:19 <lambdabot>  4.141592653589793
10:38:22 <Welkin> oh
10:38:23 <EvanR> it doesnt, good
10:38:39 <Welkin> > pi
10:38:41 <lambdabot>  3.141592653589793
10:38:46 <Welkin> lol what
10:39:05 <sproingie> last i looked that was pi
10:39:08 <EvanR> mysterious and astounding i know
10:39:10 <Welkin> `succ pi` doesn't even make sense
10:39:30 <ab9rf> it really doesn't
10:39:38 <monochrom> First you need pi using Data.Fixed.
10:39:42 <mbw> well we just asserted that Doubles were countable. But I didn't know succ just added 1.
10:39:52 <sproingie> :t pi
10:39:54 <lambdabot> Floating a => a
10:39:56 <EvanR> > realToFrac pi :: Centi
10:39:58 <lambdabot>  3.14
10:40:04 <EvanR> > succ (realToFrac pi :: Centi)
10:40:05 <digitalice> guys?
10:40:09 <lambdabot>  3.15
10:40:21 <cocreature> digitalice: ?
10:40:35 <ab9rf> which of your digits is named alice?
10:40:55 <sproingie> you can count anything you want at alice's restaurant
10:41:02 <digitalice> I didn't get it ... 
10:41:05 <monochrom> The predecessor of Bob. :)
10:41:13 <MarcelineVQ> why would you succ pi anyway, you should eat pi
10:41:16 <MarcelineVQ> > eat pi
10:41:17 <monochrom>  > pred bob
10:41:18 <lambdabot>  Num num 3.141592653589793
10:41:19 <digitalice> Is there any way to turn a data declaration into a list with all the items on it?
10:41:25 <c_wraith> digitalice: did you add Enum to the deriving list?
10:41:30 <EvanR> thumb, alice, index finger, bob, pinky eve
10:41:32 <Welkin> digitalice: befine an Enum instance
10:41:35 <Welkin> define*
10:41:45 <cocreature> s/define/derive/ :)
10:41:52 <digitalice> ahh good :)
10:41:54 <cocreature> defining things yourself is too much work
10:41:54 <Welkin> sure, that too
10:42:09 <Welkin> unless you want a circular definition
10:42:19 <monochrom> also Bounded, so you get to say [minBound .. maxBound]
10:42:27 <mbw> > data SomeType = A | B | C deriving (Show, Bounded, Enum)
10:42:29 <nshepperd_> > succ pi :: Pico
10:42:29 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
10:42:31 <lambdabot>  error:
10:42:31 <lambdabot>      • No instance for (Floating Pico) arising from a use of ‘pi’
10:42:31 <lambdabot>      • In the first argument of ‘succ’, namely ‘pi’
10:42:41 <mbw> :(
10:42:45 <nshepperd_> Rude
10:43:03 * EvanR wishes for deriving (FullyListed)
10:43:07 <monochrom> No pi for Pico.
10:43:10 <Welkin> @letdata A = A
10:43:10 <lambdabot> Unknown command, try @list
10:43:12 <Welkin> hm
10:43:14 <EvanR> universe :: [a]
10:43:14 <Welkin> forgot the command
10:43:18 <Welkin> @data A = A
10:43:18 <lambdabot> Unknown command, try @list
10:43:23 <monochrom> Oh wait, pico without pi would be just co, eh? :)
10:43:28 <Welkin> @define data A = A
10:43:29 <lambdabot>  Defined.
10:43:31 <Welkin> @list
10:43:31 <lambdabot> What module?  Try @listmodules for some ideas.
10:43:32 <Welkin> oh lol
10:43:43 <Welkin> @define data SomeType = A | B | C deriving (Show, Bounded, Enum)
10:43:44 <lambdabot>  .L.hs:161:17: error:
10:43:44 <lambdabot>      Multiple declarations of ‘A’
10:43:44 <lambdabot>      Declared at: .L.hs:159:10
10:43:47 <EvanR> > succ (realToFrac pi :: Pico)
10:43:48 <Welkin> lol
10:43:49 <lambdabot>  3.141592653590
10:43:50 <Welkin> @undefine
10:43:50 <lambdabot> Undefined.
10:43:53 <Welkin> @define data SomeType = A | B | C deriving (Show, Bounded, Enum)
10:43:54 <lambdabot>  Defined.
10:43:58 <sproingie> you can PM the bot
10:44:00 <mbw> Alright!
10:44:03 <Welkin> > [minBound .. maxBound] :: SomeType
10:44:05 <lambdabot>  error:
10:44:06 <lambdabot>      • Couldn't match expected type ‘SomeType’ with actual type ‘[t0]’
10:44:06 <lambdabot>      • In the expression: [minBound .. maxBound] :: SomeType
10:44:08 <nshepperd_> I think pico deserves pi as much as double does
10:44:13 <Welkin> > [minBound .. maxBound] :: [SomeType]
10:44:15 <lambdabot>  [A,B,C]
10:44:16 <orion> Does anyone know what versions of LLVM work with GHC 8.0.2?
10:44:24 <EvanR> nshepperd_: i have certainly wanted a square root....
10:44:26 <nshepperd_> They're both limited precision
10:44:51 <akt> orion: llvm 3.7
10:44:52 <monochrom> I pretty sure it's just a matter of someone bothering to code it up.
10:44:57 <akt> just got hit by this
10:45:12 <orion> akt: Hit by what?
10:45:21 <akt> im on llvm 4.0 :( 
10:45:38 <Welkin> what do you need llvm for with ghc?
10:45:40 * EvanR looks at what it would take to make Data.Fixed Floating
10:45:54 <orion> Ah. FreeBSD labeled llvm37 as "Obsolete and unmaintained upstream"
10:46:04 <sproingie> llvm linker is way faster for one
10:46:14 <EvanR> (which would again reveal the terible naming of the standard classes)
10:46:26 <mbw> orion: I'm not sure about FreeBSD, but the developers do maintain some repositories.
10:46:56 <monochrom> class Real a => Sinking a where ... :)
10:47:13 <Welkin> .ninja?
10:47:14 <sproingie> actually paying attention to my compiles, i'm shocked at how slow linking is with ghc
10:47:39 <monochrom>   sink :: a -> (); trig_function :: a -> (); dot_product :: a -> a -> ()
10:47:59 <sproingie> monochrom: these seem less than useful
10:48:09 <monochrom> It's called Sinking :)
10:48:25 <mbw> And you can make them all total.
10:48:35 <sproingie> const () is fairly total, yes
10:48:37 <orion> Is llvm a hard pre-req for building GHC?
10:48:45 <sproingie> no
10:48:51 <sproingie> some flavor of gcc is though
10:48:54 <Jinxit> so i've been trying to figure out this monad for a while, but i keep running into problems
10:48:58 <sproingie> (including clang, and by extension llvm)
10:49:00 <Jinxit> here's what i want it to do: http://lpaste.net/4636540298384637952
10:49:23 <spinus> sproingie: did you try with lld or gold linker?
10:49:40 <sproingie> i think i have to recompile to use lld
10:49:59 <sproingie> and no gold for me.  i can live with the slow compiles, i'm used to scala after all
10:50:31 <sproingie> (gold is ELF-only, so no osx)
10:51:09 <orion> Wow, FreeBSD is still on 7.10.2. :/
10:51:11 <EvanR> to create a new project, stack downloads your template
10:51:19 <EvanR> suspicious
10:51:48 <sproingie> to support multiple templates.  one hopes it caches the template at least.
10:51:58 <mrkgnao> wow, Selda is really good
10:52:05 <EvanR> and it wanted me to provide my email, name, github username...
10:52:14 <kadoban> It probably does. You can set a local file as a default template though if you like.
10:52:22 <mbw> Are you using the stack iphone app?
10:52:24 <kadoban> EvanR: All of that goes in the .cabal file
10:55:20 <digitalice> last question, i've got a function called "move" that receives a "Mov" and a "State" and returns another "State" ... I want get the list of "states" generated by a list of "moves" ... how would you guys use map there?
10:55:44 <EvanR> scanl
10:55:44 <monochrom> I wouldn't use map. I would use iterate.
10:56:04 <digitalice> I try  map move ([V,V,V,M],[M,M]) [AM, SM]
10:56:08 <monochrom> Oh, scanl, yeah.
10:56:13 <EvanR> :t scanl
10:56:15 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
10:56:23 <digitalice> ([V,V,V,M],[M,M]) is the state and [AM, SM] are the states
10:56:26 <mbw> I have one more question, this type about existential types. When you read about them, pretty soon you will find people complaining that they are used in situations where other approaches would be simpler. However, it appears to me that people keep linking to that one guy who defined an Antipattern using a particular example from XMonad. Are existentials really something to stay away from, or are people just 
10:56:28 <digitalice> scanl?
10:56:33 <mbw> exaggerating?
10:56:39 <monochrom> Yes, scanl, for the 3rd time.
10:56:49 <ReinH> so you hame move :: Mov -> State -> State and moves :: [Mov]?
10:56:53 <orion> http://haskell.inf.elte.hu/builders/ <-- Connection timed out. :(
10:56:58 <monochrom> Please don't be so fixated on map.
10:57:04 <sproingie> existential types are fine, it's the existential typeclass that's considered an antipattern
10:57:17 <EvanR> > scanl (flip ($)) 0 [(+1), (+1), (+1), (-1), (+1)]
10:57:19 <lambdabot>  error:
10:57:19 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M869654223455...
10:57:19 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
10:57:21 <ReinH> s/hame/have
10:57:28 <sproingie> though after seeing some of the alternatives to existential typeclasses, i'm not convinced it's an antipattern
10:57:39 <EvanR> > scanl (flip ($)) 0 [(+1), (+1), (+1), (subtract 1), (+1)] :: [Integer]
10:57:41 <lambdabot>  [0,1,2,3,2,3]
10:58:00 <digitalice> scanl does not seem to work
10:58:02 <sproingie> (some involve reinventing type classes by hand, some miss the point of polymorphism entirely)
10:58:11 <digitalice> scanl move ([V,V,V,M],[M,M]) [AM, SM] ?
10:58:20 <c_wraith> sproingie: well, it's exactly identical to just using a record of functions, except it forces you to create a bunch of meaningless types
10:58:57 <sproingie> c_wraith: the type glue is annoying, but hardly meaningless.  the Show example was a perfect strawman, it's trivial enough it doesn't particularly need the pattern
10:59:13 <ReinH> you can't just randomly put functions in front of move ([V,V,V,M],[M,M]) [AM, SM] and expect them to work
10:59:16 <monochrom> You may have to re-order your move arguments.
10:59:29 <monochrom> You may also have to actually study scanl.
10:59:42 <c_wraith> sproingie: no, I meant creating a new type just to get a new behavior - that's the part that invents a bunch of meaningless types
10:59:48 <monochrom> The alternative is to become a manager and order someone else to do it.
10:59:50 <ReinH> You should try learning what those functions do.
11:00:18 <EvanR> hes becoming a manager, press B to stop evolution
11:00:36 <monochrom> Financially speaking, I actually recommend the manager route. More money and less learning.
11:00:50 <monochrom> You just need "leadership" "skills".
11:01:05 <c_wraith> I keep delegating stuff I don't want to do to my managers...  I don't *want* that job. :)
11:01:23 <sproingie> ironically you're exercising the most important skill for a manager
11:01:31 <monochrom> hehe
11:01:59 <sproingie> "know what other people are good at and get them to do it"
11:02:27 <c_wraith> Delegating upward is an important skill at all levels. :)
11:02:42 <mbw> c_wraith: Could you elaborate on what you meant by what you said about creating meaningless types?
11:03:06 <sproingie> it's a good manager that knows how to redistribute pushback
11:03:53 <c_wraith> mbw: in most cases when someone is going for the existential typeclass antipattern, it's because they want a bunch of values with the same type but different behaviors.
11:03:57 <monochrom> Oh w00t, did someone said the Show strawman? :)
11:04:04 <monochrom> @quote monochrom river
11:04:04 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
11:04:04 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
11:04:04 <lambdabot> show the_boolean, show the_character, show the_integer]
11:04:40 <sproingie> .oO( map show )
11:04:48 <ReinH> you can't map show
11:04:51 <ReinH> that's the whole point
11:04:51 <sproingie> yeah exactly
11:04:52 <monochrom> but map show doesn't type-check.
11:05:02 <monochrom> Ah OK you know. :)
11:05:07 <sproingie> that's why you use the class, so you're not doing it by hand
11:05:08 <EvanR> you need a higher ranked map
11:05:12 <c_wraith> mbw: if you think you need an existential and typeclass for that, you create a bunch of types to create instances of your type class that have no other value.
11:05:17 <Tuplanolla> You need Template Haskell.
11:05:18 <ReinH> You're still doing it by hand
11:05:22 <ReinH> just a different "it"
11:05:26 <EvanR> or list
11:05:26 <sproingie> yes, once
11:05:30 <c_wraith> mbw: on the other hand, if you just use a record of functions, you only create one type
11:05:35 <ReinH> existential typeclasses don't save any work, they just move work around
11:05:37 <monochrom> No, first you need [1, True, 'x'] to type-check. map is happy.
11:05:46 <EvanR> for my next trick i will create a diagrams-based front end for my tictactoe
11:05:58 <EvanR> with stack, because it will be so easy
11:05:59 <sproingie> moving work around so you don't have to repeat it at eleventy zillion use sites is the point of high level langs
11:06:01 <monochrom> So you need higher-rank or higher-something (:)
11:06:10 <ReinH> Now you're writing [Showable 1, Showable True, Showable 'x'] instead.
11:07:03 <c_wraith> I really wish OverloadedLists desugared into a series of prepend calls instead of a fromList call
11:07:16 <monochrom> Oh haha but you can define it yourself.  cons :: Show a => a -> [Showable] -> [Showable]
11:07:31 <monochrom> Yeah that too.
11:07:49 <monochrom> Am I the only one who thinks "OverlordList"?
11:07:54 <c_wraith> yes
11:07:58 <sproingie> i agree the Showable class is pointless because there's just one operation
11:07:59 <ReinH> Yes.
11:08:09 <sproingie> and indeed it doesn't save any work there
11:08:12 <EvanR> Functor is pointless?
11:08:23 <mbw> Functor comes with laws.
11:08:26 <ReinH> An existential typeclass can always be replaced by a record
11:08:31 <monochrom> No, fmap is infinitely many operations.
11:08:49 <Tuplanolla> Don't forget `[|(1, True, 'x')|]`.
11:09:20 <ReinH> You put the results of the operations into a record and Bob is your father's brother.
11:09:50 <sproingie> 'course if i'm ever forced to write Elm, i'll have to live without type classes
11:10:04 <Welkin> sproingie: just don't use elm, use purescript
11:10:15 <sproingie> "forced" would imply lack of choice
11:10:15 <maerwald> Welkin: until the next version breaks all your code :o
11:10:30 <Welkin> maerwald: how?
11:10:34 <sproingie> beats being forced to write php anyway, that was my last attempt at a gig
11:10:45 <n_blownapart> hi line 3 to 4 reduces the right expression first, but shouldn't the left expression be reduced first? ie why is line 4 written that way? thanks https://nopaste.me/view/076d6903
11:10:51 <maerwald> Welkin: because they don't care about backwards compat
11:11:12 <Welkin> maerwald: that's fine actually, as long as it's an improvement
11:11:18 <Welkin> like the BBP
11:11:22 <maerwald> yes, so it might break all your code ;)
11:11:32 <ReinH> n_blownapart: evaluation order doesn't change the result
11:11:40 <sproingie> that's the bleeding edge for you
11:11:45 <monochrom> sproingie: Perhaps you can talk the Elm author into providing one built-in multiparam type class? Because Oleg shows that given that, you can now emulate user-defined type classes.
11:11:57 <lyxia> n_blownapart: there's a single redex in line #
11:11:59 <lyxia> 3
11:12:05 <ReinH> Whoever wrote that is using right-most evaluation.
11:12:07 <Welkin> the elm creator is the language's dictator
11:12:16 <sproingie> monochrom: i'd rather someone just forked it
11:12:18 <Welkin> which is one reason elm is terrible
11:12:23 <ReinH> sorry, innermost evaluation
11:12:25 <monochrom> hehe OK
11:12:26 <sproingie> elm is one guy's project and he's not even all that active on it
11:12:54 <n_blownapart> ReinH, so innermost is right side?
11:12:55 <maerwald> it's opensource, what's the problem
11:12:56 <Welkin> purescript runs more like haskell o.o
11:12:59 <ReinH> no, innermost is innermost
11:13:04 <Welkin> go support that community instead
11:13:19 <sproingie> lack of other communities.  code isn't the only contributing factor.
11:13:35 <n_blownapart> ReinH, please explain in regards to line 3
11:13:40 <Welkin> sproingie: I meant the purescript community runs more like haskell's
11:13:44 <ReinH> in (\x.x)(e), e is innermost.
11:13:47 <Welkin> there is no dictator
11:13:48 <lyxia> n_blownapart: (\X.Xq)(\z.zq) = (Xq)[(\z.zq)/X] = (\z.zq)q
11:13:49 <maerwald> Welkin: language-wise I find purescript even more interesting than haskell, but I don't know what I should do with the output (javascript)
11:13:58 <Welkin> maerwald: there is a C++ backend
11:14:02 <Welkin> and more are being added
11:14:07 <lyxia> n_blownapart: there's nothing to reduce on the right
11:14:18 <sproingie> purescript looks promising, yes.  the toolchain was not the greatest last i looked but it's been a while
11:14:31 <EvanR> compilin on battery power
11:14:44 <n_blownapart> lyxia, ReinH thanks kindly will ponder after lunch
11:14:51 <ReinH> n_blownapart: they're simply using a different evaluation strategy.
11:14:53 * EvanR puts on shades
11:15:00 <maerwald> Welkin: and I also don't like the feature-creep that is called GHC, how does purescript compare with that? Do they randomly add features?
11:15:10 <n_blownapart> different, meaning less conventional? ReinH 
11:15:14 <ReinH> Meaning different.
11:15:22 <Welkin> there is a purescript meetup in less than 2 hours if anyone is interested
11:15:23 <Welkin> https://gathering.purescript.org/event/8
11:15:28 <lyxia> ReinH: there's only one redex in that expression
11:15:29 <n_blownapart> ok at least I got the problem right. thanks
11:15:32 <Welkin> I have nevr been to one either, so this will be my first
11:15:36 <n_blownapart> redex?
11:15:45 <sproingie> feature creep is kind of what ghc is all about.  from the way SPJ describes it, if your extension generates compileable core, it's in.
11:15:55 <Welkin> maerwald: there are no language extensions afaik in purescript
11:16:08 <EvanR> Welkin: ... where?
11:16:10 <Welkin> some things are bult-in
11:16:16 <Welkin> EvanR: online meetup
11:16:18 <ReinH> And sorry, it's not true that evaluation order doesn't matter. It does matter because lambda calculous is non-total.
11:16:19 <Welkin> in the link
11:16:23 <lyxia> n_blownapart: reducible (sub)expression, an application with a lambda on the left.
11:16:25 <ReinH> *calculus
11:16:25 <maerwald> sproingie: yeah, and I think that's a horrible policy
11:16:30 <EvanR> online meetup...
11:16:36 <Welkin> EvanR: video conference
11:16:36 <EvanR> whodathunk
11:17:36 <lyxia> n_blownapart: it's what beta-reduction works on.
11:18:03 <monochrom> redex probably means reducible expression.
11:18:12 <sproingie> maerwald: that's why there's still a conservative standard
11:18:18 <monochrom> Oh I'm late.
11:18:24 <maerwald> sproingie: how much of hackage can you compile with that standard
11:18:33 <Welkin> lol
11:18:44 <Welkin> you can't compile anything by snoyberg
11:18:49 <n_blownapart> ok so you reduce the subexpression on the right first.
11:18:53 <n_blownapart> lyxia, 
11:18:53 <lyxia> n_blownapart: there are two lambdas, only one of which is being applied, so there is only one way to reduce that expression.
11:18:54 <EvanR> thats the great thing about standards
11:18:55 <sproingie> eh.  how much of hackage works together?  lots.
11:19:09 <lyxia> n_blownapart: the expression on the right (\z.zq) is not reducible
11:19:37 <maerwald> sproingie: the point is: there's a difference in designing features carefully, implementing them in the standard, and then adding them to the compilers
11:19:37 <monochrom> \z.zq alone isn't reducible. \x.xx alone isn't either.
11:19:51 <monochrom> But the whole of (\x.xx)(\z.zq) is. Use beta.
11:20:06 <whoman> hey guys! what is it called when we can pass around state, say in fsm update that accepts old state and returning new state, where the compiler optimises this by not allocating new object each time, only mutating parts of the state that changed? is it laziness?
11:20:10 <Welkin> it seems as thought haskell is following its original intention as a research language (even though it has found practical applications now)
11:20:17 <sproingie> i find there's more room for a happy medium when the option of extensions is provided, as opposed to none at all
11:20:23 <Welkin> which is why we have so many compiler extentions
11:20:50 <maerwald> sproingie: just adding half-working extensions, because someone had yet another fancy idea... is not what makes a well-maintained language. And you can't just escape them
11:20:57 <monochrom> whoman: It is called destructive update.
11:21:12 <leshow> I'm looking at https://wiki.haskell.org/Haskell_for_multicores and it mentions compiling with -threaded to enable binaries to be run on multiple cores. but you have to start the binary with -Nx. Is there a way to set the default number of cores while building the binary?
11:21:30 <ReinH> lyxia: Er. There are two sorts of evaluation rules: head rules and context rules. Beta reduction is a head rule. A -> A' => F A -> F A' is a context rule. The former reduces the outer lambda, the latter reduces its argument.
11:21:38 <leshow> I'm packing a binary for distrubution, and I don't expect users to set -Nx when they run it
11:21:39 <sproingie> eh.  the core language still chugs along happily
11:21:41 <whoman> monochrom, ah yes thank you! is only haskell that provides this so naturally? 
11:21:41 <geekosaur> whoman, and it is *enabled* by purity. laziness in turn enables purity in more situations than strict evaluation does
11:21:52 <ReinH> (\x.xy)(\x.xy) can be reduced in either order
11:21:53 <Welkin> purescript benefits from all the experiments done in haskell, but without any of the baggage
11:21:56 <monochrom> No, Haskell doesn't do it at all.
11:22:03 <monochrom> Mercury may do it.
11:22:05 <sproingie> and without the users
11:22:09 <ReinH> One is called normal order, the other is called application order
11:22:09 <maerwald> sproingie: the worst idea being dependent types
11:22:34 <ReinH> Sorry, applicative order
11:22:35 <lyxia> ReinH: there is only one way to beta-reduce that one expression
11:22:43 <lyxia> ReinH: \x.xy is irreducible
11:22:48 <sproingie> maerwald: dependent types being the bad idea, or the implementation in haskell?
11:22:58 <maerwald> sproingie: dependent types in haskell
11:23:09 <n_blownapart> interesting thanks. It's the first time I've learned this formal lambda notation
11:23:10 <EvanR> patiently await maerwald's standards based, properly run, got-it-right-this-time-i-swear open source project
11:23:23 <maerwald> EvanR: ?
11:23:28 <sproingie> me and dependent types are still relative strangers.  can't imagine it's pretty in ghc though
11:23:30 <Welkin> it was my perception that dependent types and the current type system in haskell were incompatible
11:23:31 <EvanR> meant to /me that
11:23:36 <Welkin> is that not the case?
11:23:43 <sproingie> but i'm noticing a lot of stuff starts ugly then gets nicer
11:23:46 <Welkin> in idris vs haskell, for example
11:23:56 <EvanR> Welkin: that started to change with TypeInType
11:24:17 <EvanR> which flattens the kind hierarchy
11:24:33 <ReinH> lyxia: ?
11:24:41 <ReinH> If it's irreducible, how is it being reduced?
11:25:06 <maerwald> sproingie: exactly, because it's added on top, it was never thought of when the language was designed. So what do we end up with? How consistent will that be? Do we even want it? Or... just stop adding non-trivial features and start a new language
11:25:23 <maerwald> MS actually did that right there with C# -> F# -> F*
11:25:28 <sproingie> new languages do get started anyway
11:25:29 <monochrom> ReinH, the whole of (\x.xx)(\z.zq) is reducible. The individual ingredients are not.
11:25:33 <c_wraith> Welkin: haskell is incompatible with theorem-proving.  But you can do dependent types without being a theorem prover
11:25:45 <ReinH> I'm talking about lines 3 and 4
11:25:47 <EvanR> dependent types in haskell ought to simplify a lot of crazy stuff you already do in haskell, or that you would have to do if you wanted to do it
11:26:08 <maerwald> the add another layer of reasoning
11:26:09 <lyxia> ReinH: It's being reduced because only the beta rule applies, not the context rule.
11:26:12 <maerwald> (and thus, complexity)
11:26:14 <EvanR> its removing layers
11:26:26 <Redrield> Anyone know what's wrong with this? https://hastebin.com/edabominal.hs (Sorry, haskell noob)
11:26:54 <maerwald> EvanR: "layer of reasoning"
11:27:15 <ReinH> How does (\x.xy)(\x.xy) evaluate to (\x.xy)(y)?
11:27:21 <EvanR> the complexity
11:27:35 <maerwald> they add a lot of complexity
11:27:37 <EvanR> to do dependent type stuff now, you need to understand pretty much every extension
11:27:44 <Gurkenglas> Redrield, "case x `rem` 3 == 0 of 0 -> ..." rather than "case x `rem` 3 of 0 -> ..." or "case x `rem` 3 == 0 of True -> ..."
11:27:47 <maerwald> EvanR: ah, you mean that
11:28:08 <maerwald> EvanR: I never used those half-assed crazy extensions anyway
11:28:10 <lyxia> ReinH: beta rule: (\x.M)N -> M[N/x]   M = xy, N = (\x.xy)
11:28:11 <monochrom> ReinH: May I rename it to (\x.xy)(\b.by)?
11:28:12 <maerwald> so I don't care about them
11:28:18 <EvanR> i gathered that, so why do you even care?
11:28:27 <monochrom> Maybe I should rename the other one.
11:28:46 <ReinH> monochrom: sure
11:28:54 <maerwald> EvanR: because it's a non-trivial feature that changes the whole concept of how you read and think about haskell code
11:29:08 <EvanR> only if you enable the extension
11:29:09 <monochrom> plug (\b.by) into x. (\b.by) y
11:29:32 <maerwald> EvanR: no, I'm not talking just about my own project
11:29:33 <ReinH> Oh.
11:29:42 <ReinH> I should drink more coffee.
11:29:42 <monochrom> ALWAYS RENAME VARIABLES
11:29:44 <maerwald> EvanR: I said "read and think about haskell code" like whomevers code
11:29:47 <Gurkenglas> So you want that stuff to not change because it might get better and then you'd find it in the code you read?
11:29:49 <EvanR> so your gripe is what other people are going to do with it?
11:29:55 <EvanR> not the language itself
11:30:03 <maerwald> sure, and eventually you will be forced to use it as well as part of an API
11:30:07 <sproingie> without extensions you don't even get multiparameter type classes
11:30:09 <ReinH> monochrom, lyxia: thanks
11:30:26 <cocreature> those evil other people just refuse to write code like I want them to
11:30:33 <kadoban> ReinH: Guessing because you didn't provide errors, but the only thing I see is that the thing you're matching on in the case is (Bool, Bool), but then you're using numbers instead in the actual branches. So use True/False instead probably.
11:30:44 <ReinH> kadoban: eh?
11:30:44 <kadoban> Redrield: ^ (sorry ReinH)
11:30:56 <Redrield> Yeha, thanks
11:31:03 <monochrom> Yeah I think this conversation is 15 minutes past its initial 5 minutes of productive point.
11:31:09 <Redrield> Figured out that the == 0 was throwing it off
11:31:10 <EvanR> massive web frameworks notwithstanding, i trust advanced haskell people with weird features more than advanced other people
11:31:44 <monochrom> GHC will have some stable extensions and some experimental ones. Some users will be bold. If you don't like it, find a more stable compiler or stable community.
11:32:24 <ab9rf> well, you show an advanced haskell person some weird thing and they'll promptly origami-fold it into the weirdest thing you've ever seen. it will be pretty, utterly incomprehensible, and utterly useless for any real purpose.
11:32:27 <monochrom> I don't deny that the inital 2 minutes of just plain stating your preference was productive.
11:32:28 <Tuplanolla> That's right, cocreature.
11:32:31 <Tuplanolla> > hell
11:32:33 <lambdabot>  Other People
11:32:38 <maerwald> EvanR: take F* for example, dependent types are part of the idea and I don't have any problem with that decision. The language tries to fits a special case
11:32:41 <monochrom> Or rather 10 seconds.
11:33:00 <sproingie> F* has the luxury of being new
11:33:15 <EvanR> now it sounds like a language criticism again... not sure
11:33:45 <EvanR> or maybe people using F* wont do anything wrong with it
11:34:38 <sproingie> "there are two kinds of languages: the ones people complain about, and the ones people don't use" --Bjarne Stroustrup
11:34:38 <maerwald> EvanR: well, when I say "haskell" I really mean "the haskell language, GHC and the ecosystem", because that is the "language" you "feel" as a programmer. So a language in that sense must be maintained properly. That goes for all parts: the spec, the compiler and even the ecosystem
11:35:05 <monochrom> I think EvanR knows.
11:35:43 <Welkin> F*? is that a new version of F#?
11:35:52 <maerwald> Welkin: no, it's something different
11:35:59 <Welkin> well, the name is bad then
11:36:03 <sproingie> it's an offshoot of F#
11:36:08 <maerwald> no
11:36:09 <Welkin> because I associate it immediately with F# and microsoft
11:36:10 <maerwald> it compiles to F#
11:36:14 <monochrom> Do they do A* in F*? :)
11:36:16 <sproingie> it is microsoft
11:36:26 <maerwald> and Ocaml and C
11:37:14 <maerwald> EvanR: point being: sometimes I think it's good to stop evolution of a language, otherwise it might degrade to something worse than it was before
11:37:30 <sproingie> don't update then
11:37:36 <maerwald> (see Scala)
11:37:43 <cocreature> Welkin: if it was the new version of f# it would obviously be called f#++
11:37:46 <Welkin> but these are not  part of the core language
11:37:52 <Welkin> these are compiler extensions
11:38:00 <sproingie> maerwald: what about scala?  dotty is dropping a lot of cruft.
11:38:32 <maerwald> sproingie: last I was exposed to it I tried to do ADTs and there are like ~100 ways you can express them, all with different gotchas and pitfalls
11:38:38 <monochrom> Am I the only one think that you really mean "stop evolution of an ecosystem"?
11:38:42 <sproingie> pascal doesn't evolve
11:39:07 <EvanR> evolution cant be stopped
11:39:11 <sproingie> maerwald: and i doubt we've seen the last of new ways to express ADT's
11:39:13 <Tuplanolla> It doesn't matter what the core language is if the way the community uses it is different enough.
11:39:17 <maerwald> EvanR: =D
11:39:22 <whoman> monochrom, geekosaur, when i was working with haskell i heavily depended on purity, laziness, destructive updates. do you guys happen to know if this is only possible in haskell?
11:39:24 <EvanR> unless you press B
11:39:27 <sproingie> evolution occurs in response to pressure
11:39:37 <maerwald> Tuplanolla: exactly
11:39:41 <leshow> with a stack project it seems you can add ghc-options in the stack.yaml or the .cabal file. Which one should be used? is there a difference
11:41:20 <sproingie> i'd say the .cabal file makes more sense for ghc-options
11:41:28 <Tuplanolla> No, whoman. GHC doesn't detect destructive updates for optimization.
11:41:43 <lambdamu> Can somebody explain why this is not considered injective, is it a heuristical limitation of GHC or is there some deeper reason?
11:41:45 <monochrom> Also I already brought up Mercury.
11:41:45 <lambdamu> type family UnPtr t = r | r -> t where UnPtr (Ptr a) = a
11:41:52 <leshow> sproingie, thanks
11:41:59 <monochrom> Err, I guess it is not Mercury, it is Clean.
11:42:09 <monochrom> Actually I think both do it.
11:42:49 <whoman> ahh really.. this whole time i thought this was optimised. im sure i read this a few years ago and why i started designing for it
11:43:01 <monochrom> Haskell in practice (meaning past and present compilers) doesn't do your kind of destructive update.
11:43:48 <digitalice> question: got this function move :: Mov -> State ->  State and a list of Mov ... I want a list of States that are generated for each Mov in my list. Can I use map there? How?
11:43:51 <whoman> i cant tell if i am hoping or asking for something impossible, too; does it make sense as a thing though? i am not too experienced with compilers
11:43:55 <monochrom> If you have a "case xs of h:t -> (h+1):t" there will be no in-place replacement of h by h+1 even after the compiler knows that h becomes unused after.
11:44:22 <sproingie> uniqueness types would be nice to have
11:45:17 <digitalice> question: got this function "move :: Mov -> State ->  State" and a list of Mov ... I want a list of States that are generated for each Mov in my list to a fixed state. Can I use map there? How?
11:45:28 <digitalice> *correction
11:45:37 <monochrom> I wouldn't call it impossible. But the Haskell people simply haven't done it.
11:45:39 <Tuplanolla> Register allocation is a restricted version of this, so it's certainly possible, whoman. Alas there are no guarantees for how well it works.
11:46:00 <ReinH> digitalice: map (mov theMov) theStates
11:46:06 <ReinH> oh, list of movs
11:46:10 <sproingie> map moveToState myMoves
11:46:34 <ReinH> map (flip move state) moves
11:46:41 <monochrom> OTOH "f :: Int -> Int; f x = f (x-1)" falls under what Tuplanolla just said. It is compiled to a tight loop of decrementing the same damn register.
11:47:09 <monochrom> And ironically it is because of non-laziness.
11:47:09 <ReinH> or map (`move` state) moves
11:47:34 <whoman> hmm. lazy eval is so so useful. okay thanks guys! im going to continue shopping for languages. but now i cant remember why i left haskell.
11:48:15 <monochrom> Lazy evaluation involves a destructive update but you're conflating two different worlds.
11:48:49 <sproingie> i left because i couldn't decipher errors involving big monad stacks and there wasn't nearly as much help then as now
11:49:01 <EvanR> i think were being too negative, can we call it a creative update
11:49:25 <sproingie> now mtl is much nicer and the community is bigger and doesn't write awful monad tutorials anymore :)
11:49:37 <digitalice> ReinH: what is move inside the flip?
11:49:42 <Welkin> sproingie: and there is freer
11:49:45 <monochrom> If I were to write an STG machine in Clean, I would consider using Clean's destructive update feature.
11:49:57 <monochrom> But this is invisible at the Haskell level.
11:50:02 <sproingie> Welkin: i still haven't learned free monads
11:50:33 <Welkin> sproingie: you don't need to understand free to use extensible effects. I think purescript is a good example
11:50:52 <monochrom> EvanR: GHC does creative update. Are you happy now? :)
11:51:31 <EvanR> in the process of destroying, you necessarily create something new
11:51:49 <EvanR> *pseudo mystic wisdom*
11:51:57 <sproingie> i imagine once ghc can generate llvm bitcode directly, it could mark references as unaliased
11:52:01 <monochrom> I don't think that's true in most people's sense.
11:52:03 <whoman> sproingie, mtl?
11:52:04 <sproingie> since ima guess c-- doesn't have 'restrict'
11:52:30 <whoman> monochrom, how come it is invisible at the haskell level, vs. clean?
11:52:32 <digitalice> ReinH: the function name hehe ... 
11:52:36 <EvanR> if you zero out a block, you created a bunch of zeros!
11:52:37 <digitalice> ReinH: thanks
11:53:06 <monochrom> Actually probably "invisible" is the wrong word.
11:53:21 <monochrom> Or maybe it's right.
11:53:32 <sproingie> whoman: monad transformer library.  it's sort of the de facto implementation of standard stuff like State and Reader
11:53:50 <whoman> sproingie, i left because making changes and refactoring to hs code was trouble
11:54:07 <monochrom> Take for a sidetracking example. I know that my compiled code is run on a pointer machine. Doesn't mean that the language actually exposes pointers to me.
11:54:11 <whoman> ahh yes yes =) ive been away a year or two.
11:54:35 <monochrom> Similarly, lazy evaluation is implemented by a destructive update. Doesn't mean that Haskell exposes destructive update to me.
11:54:44 <sproingie> whoman: there's still not any decent IDE support for that sort of thing :-/
11:55:07 <sproingie> monochrom: IORefs?
11:55:13 <whoman> ahh yes, makes sense. de-struct-ive updates i really like so much.
11:55:45 <monochrom> "upon evaluation, 3+4 is replaced by 7 in-place" is orthogonal to "old_record{f = 5} enjoys in-place update"
11:56:09 <whoman> sproingie, hmm =( in lisp for example i can make a huge change to a part of the code and it is still in "workable" form. with haskell it feels like a small change affects big parts of code, where each brick is a cornerstone
11:56:16 <monochrom> sproingie: And yet IORef's destructive update is orthogonal to lazy evaluation's.
11:56:32 <ReinH> Weird. Ease of refactoring is one of my favorite things about Haskell.
11:56:45 <EvanR> whoman: if thats true, i bet its because in lisp you used a more uniform set of types everywhere
11:56:46 <sproingie> whoman: in lisp you can also make a small change that breaks everything and is completely undetected
11:56:54 <EvanR> for example, only 1 type, the lisp dynamic type
11:57:00 <sproingie> lisp certainly has some advantages
11:57:00 <monochrom> Or do you mean pointers? But then IORef still doesn't enjoy pointer arithmetic.
11:57:02 <EvanR> in which case i expect a lot more breakage
11:57:18 <sproingie> but refactoring in lisp is not assisted in any way by the compiler
11:57:19 <whoman> i am a lot less experienced in lisp than haskell that is for sure, something i should mention about my perspective there
11:57:35 <EvanR> in haskell you can limit "doesnt matter" knock-on changes by hiding the implementing of types behind stable aliases
11:57:38 <whoman> sproingie, yeah, just editor-assist; working directly with the trees of paren-blocks
11:57:43 <sproingie> what needs to happen is for the compiler to speak to the IDE more, not just the end user.  it's gradually happening now, just slow progress
11:57:51 <ReinH> I want my language to make correct refactorings easy but I will settle for it making incorrect refactorings hard.
11:58:01 <whoman> hmm i have seen this newfangled language server thing i forget its name
11:58:02 <ReinH> That said, ease of refactoring in Haskell depends on the design of your program.
11:58:20 <ReinH> There are ways to design Haskell programs that lead to easier refactoring
11:58:31 <whoman> true
11:58:42 <ReinH> And generally this leads to better programs
11:58:50 <sproingie> type holes are a nice sort of gradual feedback mechanism, tho even intero isn't able to use its suggestions
11:58:52 <ReinH> Because ease of change is an important part of program quality
11:59:03 <sproingie> and intero's suggestions menu thing is shockingly primitive anyway
11:59:05 <EvanR> one good thing is that refactoring a lot of haskell rarely causes your program to suddenly be broken. 
11:59:22 <EvanR> but that doesnt help getting there from scratch
11:59:28 <sproingie> EvanR: you mean once you get it compiling again, right?
11:59:32 <whoman> i really like working with haskell and those monad type errors. it taught me a lot about what i thought i was doing
11:59:39 <EvanR> sure
12:00:00 <EvanR> i really dont want it to be compiling until it would work
12:00:06 <EvanR> compiling *again*
12:00:28 <sproingie> yep.  i just want those error messages consumed by my IDE so it can offer me quick-fixes
12:00:40 <whoman> hmmmmmm. 
12:01:13 <EvanR> it got pretty boring in C++ after refactoring a totally working program, getting segfaults
12:01:15 <whoman> oh that would be quite nice. visualising possible changes and suggestions, that would be interesting. one could almost do a lot of automatic design and code that way..
12:01:25 <sproingie> right now it gives excellently detailed error messages that have to be reinterpreted by humans every time
12:01:47 <sproingie> (with the exception of parse errors, those messages are still awful)
12:02:04 <whoman> heheh. i didnt want to add/remove features of my haskell project because of trying to check a clear plastic bag for holes. water and air(compiler) helps.
12:03:02 <EvanR> checking a plastic bag for holes in a vacuum metaphor, thats a new one
12:03:30 <whoman> i have a feeling ghc would need some ai and cloud stuff to have suggestions. 
12:03:39 <EvanR> people in 2998 probably know that feel
12:03:42 <ReinH> If you think that sounds like fun, try Agda.
12:04:15 <ReinH> In 20 years, humans will be writing type signatures and computers will be inferring programs.
12:04:30 <sproingie> the promise of intentional programming realized
12:04:32 <EvanR> i cant wait to wear tron costumes to work
12:04:33 <ReinH> The current situation is an unfortunate historical accident.
12:04:34 <sproingie> i'll check back in 20 years
12:04:37 <monochrom> writing? why not speaking?
12:04:59 <EvanR> not speaking, because you cant pronounce most of these type sigs
12:05:01 <sproingie> feh.  you prefer spoken directions?
12:05:25 <ReinH> monochrom: I prefer to limit myself to one unpredictable technological breakthrough at a time.
12:05:27 <monochrom> Yes, I prefer to say "sudo make me a sandwich" :)
12:06:04 <ReinH> @google Conor McBride what are types for or are they only against
12:06:05 <lambdabot> https://www.youtube.com/watch?v=3U3lV5VPmOU
12:06:14 <ReinH> Recommended viewing.
12:07:46 <cocreature> conor is awesome
12:10:11 <ReinH> Cosign.
12:11:03 <Keenen> hi, I was wondering if haskell can do similar things to apache pig. I'm pretty new to haskell on chapter 11 of "learn you a haskell for great good" but I love the language coming from a heavy scheme background
12:11:19 <sproingie> conor False False = True; conor _ _ = False
12:11:30 <sproingie> doh that's nor
12:12:02 <sproingie> conor True = (False, False) -- there
12:12:30 <EvanR> "gratuitous use of shadowing to make sure i dont use the wrong s"
12:12:31 <monochrom> yikes
12:12:33 <ReinH> conor True = [(False, False)]; conor False = ...
12:12:35 <eacameron> Does Debug.Trace.trace affect semantics in any way whatsoever? I.e. does it force thunks that would otherwise be unevaluated?
12:12:38 <whoman> ReinH, hehe! we are the computer. 
12:12:47 <ReinH> look at me, I am the compiler now
12:13:06 <monochrom> eacameron: It could. It depends on your care.
12:13:27 <eacameron> monochrom: My care?
12:13:36 <geekosaur> case, as in use case, I think
12:13:50 <monochrom> trace "hello" x doesn't cause a problem. trace y x evaluates y prematurely.
12:13:56 <monochrom> And I really mean care.
12:14:10 <monochrom> As in, are you careful? are you careless?
12:14:42 <ReinH> Where would you rate your care on a scale from careless to careful?
12:15:03 <monochrom> However, this does not mean that you must refrain from trace y x. Perhaps y doesn't matter.
12:15:14 <eacameron> monochrom: It came up when I was pondering if "trace*" could be totally removed by a CPP flag without any semantic changes to the program behavior (other than the side-effect of printing)
12:15:18 <Keenen> Oh -- I did find a library for streaming haskell on hadoop called hadron -- any have experience with this?
12:15:44 <eacameron> #ifdef NO_TRACE
12:15:51 <sproingie> particle physics gives me a hadron
12:15:57 <eacameron> trace x y = y
12:16:26 <monochrom> Actually even trace x x could be rather subtle.
12:16:35 * hackage qtah-generator 0.3.0, qtah-qt5 0.3.0, qtah-cpp-qt5 0.3.0, qtah-examples 0.3.0 (khumba): https://qbin.io/qz3olpti
12:16:37 <kadoban> You could probably replace it with a usage of seq and get closer to the same behavior? Not sure that's a good idea though.
12:16:37 <ReinH> x = _|_ => you're gonna have a bad time.
12:16:45 <sproingie> no idea about haskell in data science, scala seems to have made a few more inroads there
12:16:56 <monochrom> bottom is the least of the problem.
12:17:04 <ReinH> but is there a case where you don't "have a bad time" in development but do in production?
12:17:41 <ReinH> i.e., are there cases where evaluating x is better for your program than not evaluating x?
12:17:59 <monochrom> Is that a general question?
12:18:10 <monochrom> Because the general answer is "learn lazy evaluation for real".
12:18:14 <sproingie> i think it's specifically specific :)
12:18:25 <monochrom> OK, which x?
12:18:34 <EvanR> i did no [C tknow about hiding instance
12:18:43 <sproingie> as in "are there cases in this particular program that would be affected"
12:18:45 <EvanR> i did not know about hiding instance
12:19:00 <ReinH> monochrom: I'm talking about trace x y
12:19:08 <sproingie> monochrom: eh, i'll only get around to doing that if forced ;)
12:19:30 <eacameron> In C it's common for compilers to drop asserts, but in Haskell that's not safe because the assert my force
12:19:34 <monochrom> Sometimes it doesn't matter.
12:19:49 <Keenen> Lazy evaluation makes more sense if you implement it -- I recommend essentials of programming languages from MIT press
12:20:09 <Keenen> implementing thunks and continuations comes pretty late in the book though
12:20:26 <monochrom> Suppose you're doing let y = a+b+c in trace (show y) a + y. Then it's OK.
12:20:36 <monochrom> Probably even better, yes.
12:21:40 <sproingie> SICP has you implementing lazy evaluation in the metacircular interpreter eventually
12:22:00 <monochrom> In Haskell it is also common for compilers to drop asserts.
12:22:26 <eacameron> I think what I'm learning is that "trace" (et al) do affect thunks and therefore I'd need to either re-implement a version of trace that explicitly avoids sharing so that it's safe to elide, OR make my "dummy" trace use "seq" to properly mimic the semantics. I like the former better since I usually *think* if trace as having no effect.
12:22:52 <monochrom> "Implementing Lazy Functional Language" has to implement it right from the beginning.
12:23:07 <kadoban> eacameron: The latter sounds easier to me though, heh. But maybe I'm dumb.
12:23:17 <eacameron> kadoban: It probably is easier.
12:23:27 <Keenen> monochrom: Havent heard of that book will check it out 
12:23:32 <kadoban> But then I guess you have the problem of removing traces actually changing things, which isn't amazing.
12:23:34 <Welkin> sproingie: it does?
12:23:39 <Welkin> lazy scheme?
12:23:44 <monochrom> I think I should check the name.
12:24:10 <Keenen> although E.O.P.L is pretty nice in that you get to implement the let language through let-rec first
12:24:28 <ReinH> monochrom: so trace x y can improve performance in cases that benefit from sharing x, but then one could just share x.
12:24:29 <EvanR> ReinH: ok... im half way through this video you posted and i ahvent seen anything but "stupid haskell tricks" and some jokes
12:24:44 <ReinH> EvanR: it isn't even Haskell?
12:24:52 <sproingie> Welkin: yes, though primitives are still eager
12:24:57 <sproingie> https://mitpress.mit.edu/sicp/full-text/sicp/book/node86.html
12:25:09 <EvanR> is this the wrong video ?
12:25:14 <Welkin> sproingie: something I miss in purescript is lazy evaluation
12:25:24 <ReinH> EvanR: It's whatever google felt was lucky, let me check
12:25:24 <monochrom> Actually it is "Implementing Functional Languages". https://www.microsoft.com/en-us/research/publication/implementing-functional-languages-a-tutorial/
12:25:32 <EvanR> its nothing but conor mcbride doing shit on a repl
12:25:33 <Welkin> so I can't do parlor tricks like `let fib a b = a : fib b (a + b) in fib 0 1`
12:26:05 <ReinH> EvanR: Yeah, it's the right video. And it isn't Haskell per se, it's a McBride dialect of Haskell.
12:26:09 <monochrom> ReinH: No, the criterion is "if you will evaluate x soon anyway", i.e., if you want to be strict in x.
12:26:21 <EvanR> that explains why i didnt get hiding instance
12:26:26 <sproingie> ReinH: if it's idiom brackets, i think you get those with arrow syntax
12:26:27 <ReinH> monochrom: right
12:26:48 <EvanR> the title made me think it would be something else
12:27:16 <ReinH> EvanR: Maybe you would like this one more https://www.youtube.com/watch?v=QojLQY5H0RI&t=1091s
12:27:49 <Keenen> The real question is who thunk the word thunk
12:28:12 <sproingie> someone in the algol68 bunch i think
12:28:31 <ReinH> EvanR: I think this is the most direct he's been on the subject https://www.youtube.com/watch?v=ad4BVmPni7A
12:28:36 <EvanR> im so glad he says monad right =D
12:28:57 <Keenen> What is the right way to say monad?
12:29:08 <sproingie> "warm fuzzy thing"?
12:29:10 <monochrom> mona d
12:29:19 <Keenen> I always hear it "mo -- nad"
12:29:27 <EvanR> me too
12:29:45 <EvanR> im also glad IRC doesnt make noise
12:30:02 <monochrom> IRC doesn't make noise? hahahahah
12:30:04 <sproingie> most of irc is noise
12:30:21 <monochrom> Just look at that maerwald conversation a while ago.
12:30:30 <Keenen> so it's more "mon -- ud " then?
12:30:44 <monochrom> I don't think people really do "ud"
12:30:59 <sproingie> syllables break at the end of a long vowel, get used to it
12:31:18 <eacameron> Monad is pronounced differently if your from the Southern US.
12:31:19 <sproingie> hooked on phonics worked for me y'all
12:31:26 <eacameron> "Monade"
12:31:37 <EvanR> Le Monade
12:31:46 <Keenen> welp that's even more confusing lol
12:31:48 <monochrom> I think you shouldn't worry too much. Just pronounce it in a reasonable way.
12:31:50 <iqubic> "Mo-Nad
12:32:10 <maerwald> in chinese: muh-nah
12:32:10 <Keenen> "mon-aid"
12:32:16 <monochrom> Yes! Le Monade would be most welcome this summer. :)
12:32:23 <iqubic> I don't care how you pronounce it, just so long as I know what it is you are talking about.
12:32:42 <Keenen> so how do you pronounce monoid
12:32:49 <maerwald> like steroid
12:32:53 <iqubic> Are we talking about the right way to pronounce "monad"
12:33:01 <sproingie> when life hands you lemons, make monoids in the category of endofunctors
12:33:02 <EvanR> not anymore
12:33:16 <eacameron> When life hands you lemons, make Le Monade
12:33:35 <monochrom> :)
12:33:35 <Welkin> why are rings called rings?
12:33:39 <Welkin> and magmas called magmas?
12:33:55 <Keenen> I don't think I've heard the word monad in real life
12:34:00 <EvanR> they were names made up
12:34:01 <sproingie> coming from DF, magma is my favorite.  no problem that can't be solved with sufficient magma.
12:34:05 <Welkin> Keenen: you have if you watch anime
12:34:12 <Welkin> ergo proxy has a character called Monad
12:34:19 <Keenen> usually If I say haskell -- people think I'm saying pascal
12:34:33 <Welkin> Keenen: they sound like old people then
12:34:38 <EvanR> theres some wrong people who say hask-ELL 
12:34:39 <monochrom> I know the ring story. It began as annulus in French or German. Because they were looking at mod-n arithmetic examples, so the picture is "wall-clock arithmetic" going around a circle.
12:34:47 <sproingie> when i worked for symantec, it was bloody difficulty to talk about "semantics"
12:34:59 <Welkin> oh, I remembder reading about the name for Rings
12:35:03 <Welkin> Zahlring
12:35:04 <Welkin> or something
12:35:06 <monochrom> haha sproingie
12:35:07 <Welkin> a german name for it
12:35:56 <Welkin> I wouldn't expect anyone younger than 30 to know what pascal is
12:36:09 <maerwald> Welkin: younger than 32
12:36:09 <Welkin> unless they studied history of programming/computer science
12:36:13 <sproingie> ergo, never trust a pascal programmer
12:36:22 <monochrom> They still probably know Pascal's triangle and Pascal's wager.
12:36:22 <maerwald> is there #haskell-jokes?
12:36:27 <Keenen> I'm 21, but the place I work has alot of older phds
12:37:00 <Keenen> so they always hear it as pascal
12:37:20 <Welkin> Keenen: with or without their earhorn?
12:37:31 <Keenen> lmao
12:37:36 <sproingie> paskell
12:37:59 <monochrom> Pascal used to have its significance in Mac programming. (Like the way Objective-C has now.)
12:38:03 <sproingie> i have heard one guy pronounce haskell as "hass-CAL".  drove me bats.
12:38:09 <Welkin> lol
12:38:12 <ReinH> Are millennials really that ignorant of the history of mathematics?
12:38:21 <Welkin> how offensive to Haskell Curry
12:38:41 <Keenen> the worst part is that then they start reminiscing about pascal
12:38:46 <sproingie> i just say "like Eddie Haskell"
12:38:48 <Welkin> ReinH: everyone knows pascal's triganle/wager, but not the programming language
12:39:02 <ReinH> Hmm.
12:39:04 <Welkin> triangle*
12:39:20 <Keenen> "Back in my day we learning pascal to do x"
12:39:22 <sproingie> Wirth's Wager
12:39:23 <Keenen> im like great
12:39:41 <ab9rf> i did my share of stupid programs in pascal back in the day
12:39:45 <sproingie> (pronounced "virth's vager")
12:39:59 <monochrom> haha
12:40:07 <jadrian> ReinH: thanks, seems interest (as usual with Conor's material)
12:40:34 <sproingie> i wrote a bit of delphi, that was actually pretty pleasant compared to the c++ compilers of the day
12:40:46 <iqubic> What is Delphi?
12:40:47 <sproingie> certainly compiled a hell of a lot faster
12:40:56 <ab9rf> my boss threw a delphi box at me at one point
12:40:59 <ab9rf> i never made much use of it
12:41:01 <Welkin> http://www.haskell.edu/
12:41:03 <Keenen> ReinH: also since I am a millenial I get to blame any ignorance on society 
12:41:09 <Welkin> there is a native american group called Haskell
12:41:10 <Keenen> ReinH: right?
12:41:13 <EvanR> nice
12:41:20 <jadrian> ReinH: I'm still at the point where I have mixed feelings about this "We are thus incentivized to write precise types"
12:41:22 <sproingie> Keenen: that's ok, society blames all its ills on you :)
12:41:22 <ab9rf> Keenen: oh, we all did that, it's not a special millenial thing
12:41:24 <ReinH> What matters is that we all blame everything on each other.
12:41:39 <ab9rf> every generation blames the one before it and the one after it for everything
12:41:40 <Keenen> :>)
12:41:42 <jadrian> ReinH: the downside being reusability
12:41:45 <Welkin> old people always blame younger generations
12:41:50 <Welkin> it's been that way since the dawn of time
12:41:54 <ab9rf> middle-ages blame everyone
12:41:58 <iqubic> So are there other functional programming languages besides Haskell? If so, why do we all use Haskell?
12:41:58 <ReinH> jadrian: I don't see that.
12:42:00 <EvanR> jadrian: thats whre polymorphism comes in
12:42:05 <jadrian> ReinH: maybe there is a way to be precise in a modular fashion, but it still escapes me
12:42:07 <ab9rf> polymorphic blame
12:42:10 <EvanR> haskell code is a lot more reusable
12:42:19 <EvanR> (than C code)
12:42:24 <sproingie> i remember reading some "kids these days don't respect their elders" essay ... in latin
12:42:25 <Welkin> iqubic: there are tons, but none of the others have the ecosystem that haskell has
12:42:26 <Keenen> iqubic: scheme
12:42:27 <ReinH> By being precise about how your code is modular.
12:42:40 <ab9rf> Keenen: you'll get debate on how functional scheme is
12:42:59 <EvanR> jadrian: learning how to think in types takes practice... 
12:43:00 <iqubic> Keenen: Scheme is a Lisp. Lisps are not functional.
12:43:13 <ab9rf> i know people say scheme is functional, but it's not
12:43:13 <ReinH> Although there are real cases of loss of modularity but they're generally the result of a type system that's unable to express the kind of quantification you need.
12:43:14 <Welkin> scheme is a simple lambda calculus
12:43:15 <EvanR> but after a certain point its addictive
12:43:18 <maerwald> EvanR: calling C from any language is very easy, so one could argue against that "reusable" statement ;)
12:43:24 <ab9rf> it simply is somewhat more explicit about mutating operations
12:43:28 <cocreature> EvanR: C is pretty good at allowing you to reuse segfaults
12:43:30 <ReinH> So the problem is not that your types are too precise, it's that they're not precise enough.
12:43:35 * hackage ulid 0.1.0.0 - Implementation of ULID, lexicographically sortable unique identifiers  https://hackage.haskell.org/package/ulid-0.1.0.0 (steven777400)
12:43:38 <Welkin> there is no real definition of "functional"
12:43:38 <kadoban> You get into bad nonsense semantics wars trying to redefine what is functional and not.
12:43:44 <iqubic> maerwald: Try calling C from Java.
12:43:46 <sproingie> lisps let you be more functional without actually occupying that extreme pole
12:43:51 <EvanR> maerwald: C code that you ... just rewrote from scratch
12:43:59 <ongy> iqubic: JNI isn't that bad
12:44:01 <maerwald> iqubic: try calling haskell from... <anything>
12:44:06 <ab9rf> maerwald: heh
12:44:08 <ab9rf> meinside: real
12:44:12 <jadrian> EvanR: I'm not talking about basic hindley-milner and a few extensions
12:44:12 <ab9rf> awd
12:44:16 <ongy> maerwald: with or without some glue on the haskell side? :)
12:44:17 <ab9rf> 123d1212pou23o9ru1290481209481
12:44:24 <maerwald> ab9rf: uhm?
12:44:28 <ReinH> For example, there is a zoo of zipper data structures, where each end is a different sort of list. There are vect/vect zippers, stream/stream zippers (turing tapes), and so on. We'd like to be able to write, say, left, in a polymorphic way over them
12:44:32 <maerwald> your cat on your keyboard?
12:44:33 <Keenen> I think that it requires a functional mindset to solve problems in scheme at the very least
12:44:33 <ab9rf> my keybvoard is in rebellion
12:44:52 <EvanR> jadrian: then im not sure what you were referring to
12:45:04 <jadrian> EvanR: if you, e.g. go the "dependent" route, it gets complicated to reuse code, because structures and algorithms are tailored for your very specific purpose
12:45:11 <Welkin> from my perspective, "functional programming" is intimately linked with rich type systems
12:45:15 <ReinH> But we can't, at least not without metaprogramming techniques, with the ML implementations in (say) Agda or Idris.
12:45:18 <sproingie> i used to accidentally spam long alphanumeric strings when i bumped the yubikey i had plugged in to the laptop
12:45:28 <EvanR> jadrian: i noticed that, and part of it is no agreement on what should be reused
12:45:38 <ReinH> Or, at least, I can't. Maybe it's possible.
12:45:47 <ab9rf> mostly that was because i had a coughing fit while trying to type
12:45:53 <EvanR> someone wrote what you wrote, but called it something else
12:45:57 <ab9rf> i hate being sick
12:46:01 <sproingie> Welkin: that's a more recent perspective though
12:46:09 <Keenen> also wikipedia first line? https://en.wikipedia.org/wiki/Scheme_(programming_language)
12:46:13 <ReinH> Perhaps there's a way to do it with Pi types that carry both the new list-like and a proof of its length.
12:46:13 <ab9rf> right now i feel like i'm falling over to the right no matter how i move my head
12:46:19 <jadrian> EvanR: my problem is not just what... but how
12:46:25 <ReinH> Sigma types, sorry
12:46:30 <EvanR> jadrian: right, which goes back to what i was saying
12:46:40 <ab9rf> Keenen: don't believe everything you read in wikipedia.
12:46:47 <iqubic> Keenen: I disagree with wikipedia on that.
12:46:50 <EvanR> especially doing things like you see done in dependent types tutorials may not get you anywhere
12:46:52 <sproingie> clojure is doing a competent job at carrying along FP without static types
12:46:58 <jadrian> yeap
12:47:03 <kadoban> iqubic: ab9rf: And your definition of FP is what?
12:47:07 <ReinH> I think my point is that we don't have decades of experience working in this way to tell us how to write modular programs.
12:47:31 <ReinH> I certainly don't know how to think intuitively in dependent types.
12:47:31 <Keenen> I don't really, but I've read that scheme is functional progrmaming language in MIT press books and plenty of other places. There are alot of people smarter than me who say it is is all im saying.
12:47:43 <jadrian> ReinH: true
12:47:47 <ReinH> Maybe one day we'll all share Conor's facility.
12:47:59 <ab9rf> mRNA transfer
12:48:02 <iqubic> I don't think Scheme can have Monads.
12:48:10 <kadoban> lisps and scheme are like *the* well known FP languages. Trying to define them out of the category just seems like a shitty idea.
12:48:10 <sproingie> anything can have monads
12:48:13 <ReinH> Also we don't have decades of experience in making dependently typed programming ergonomic.
12:48:20 <ab9rf> iqubic: i'm sure it can, but they'd likely be very ugly
12:48:20 <maerwald> even java can has monads
12:48:22 <sproingie> it's whether using such monads is actually pleasant that's the question
12:48:33 <EvanR> jadrian: i have had success describing APIs in a way that lets the client code use whatever types they want, as a dependent record
12:48:34 <sproingie> without type inference you don't get too much
12:48:42 <maerwald> ReinH: good points
12:48:49 <EvanR> but im not sure if APIs are supposed to count as "reusable"
12:48:52 <sproingie> or higher-kinded types .. tho without static types that's kind of irrelevant
12:48:58 <Welkin> sproingie: all type systems are static
12:49:22 <sproingie> Welkin: static type systems with one type are things we don't tend to call "static"
12:49:33 <EvanR> but an API implementation would then be reusable
12:49:46 <ReinH> I think my point is that the current limitations of dependently typed programming are parochial. They're just there because we don't know how to do better yet.
12:50:11 <sproingie> and we won't until we screw around with them long enough to find out
12:50:27 <Welkin> sproingie: the whole set of terminology for type systems is a disaster and should be replaced with something that makes sense
12:50:29 <EvanR> to the bat idris-javascript-backend !
12:50:40 <EvanR> uhg too soon
12:50:45 <Welkin> because you get people who don't understand what "dynamically typed" really means, and that causes problems
12:50:56 <sproingie> it's consensus, really
12:51:31 <jadrian> ReinH: there another issue I think, that in many languages (haskell included) modularity is somewhat of an after thought 
12:51:47 <EvanR> i dont know
12:52:02 <EvanR> the module feature maybe, but laziness , the whole point is modularity
12:52:13 <EvanR> purity, also helps
12:52:25 <sproingie> jadrian: ML was thinking about modularity pretty early on
12:52:28 <EvanR> those werent afterthoughts
12:52:52 <sproingie> at least SML was, i suppose haskell's ancestors had already diverged some by then
12:53:00 <Keenen> speaking of what is and isn't functional -- is it possible to have a functional assembly language or functional hardware? I would think it's impossible but shrug
12:53:30 <jadrian> EvanR: true it is one form of modularity
12:53:33 <sproingie> Keenen: such hardware exists.  it's also 10x more expensive and 10x slower than commodity hardware
12:53:51 <jadrian> sproingie: yeap that was the exception I was thinking about
12:53:53 <maerwald> yeah SPJ talked about functional hardware once and said it was a dead end 
12:53:57 <EvanR> there was work getting lazy functional code to run on hardware, custom hardware
12:54:07 <jadrian> sproingie: maybe I should look into F* to see what they are doing
12:54:17 <sproingie> custom hardware is a dead end unless you have really esoteric needs
12:54:23 <maerwald> jadrian: yes, it's very nice, check out https://www.fstar-lang.org/tutorial/
12:54:24 <EvanR> one thing is that intel is too fast
12:54:45 <jadrian> maerwald: now that I think of it, F# killed modules I think, in favour of just objects
12:54:56 <jadrian> maerwald: but yes should check it out
12:55:09 <Keenen> how does that work since the architecture is so clock based 
12:55:15 <sproingie> i've been reading the connection machine paper, that was an interesting architecture.  also godawful slow tho
12:55:48 <jadrian> just starting to play with "dependent" types on Haskell, to get a better feeling for what can and can't be done
12:56:19 <sproingie> the von neumann bottleneck isn't so much a factor what with crazy fast interconnects.  we just don't know how to express things with the parallelism we really want
12:56:30 <Keenen> piplining wouldn't work right?
12:56:42 <EvanR> this is a huge question...
12:56:43 <maerwald> jadrian: it's rather awkward, why not pick a language that does it right?
12:56:43 <sproingie> we're still waiting for the mythical Sufficiently Smart Compiler
12:57:05 <jadrian> maerwald: I've done a few things in Coq and messed around with Agda
12:57:14 <systemfault> Idris <--
12:57:40 <jadrian> maerwald: right now I want to see what I could use in the "real world" sort of, in haskell
12:57:55 <jadrian> maerwald: in a (sort of) mainstream language
12:58:18 <sproingie> i'd love to learn dependent types too, but i'd want a motivating example.  something pedestrian like a game.
12:58:26 <ongy> because Haskell is totally main stream
12:58:29 <EvanR> dependent hangman
12:58:41 <sproingie> dependent roguelike or mud, maybe
12:58:41 <maerwald> sproingie: well, the standard idris example is typesafe printf, but well, uh
12:58:47 <jadrian> ongy: therefore the sort of :P
12:58:52 <Keenen> There is a book called "Real life Haskell"
12:58:53 <EvanR> guaranteed to play the rules exactly and provide exactly the right user interface
12:59:13 <sproingie> Keenen: you mean "real world haskell"?
12:59:22 <sproingie> i found RWH a very hit-and-miss proposition
12:59:34 <Keenen> yeah
12:59:45 <Keenen> my bad it's "Real World Haskell"
12:59:51 <Keenen> https://en.wikipedia.org/wiki/Real_World_Haskell
13:00:00 <ongy> maerwald: isn't that what we have formatting for? I guess the syntax is a bit far off, but still
13:00:23 <sproingie> RWH had editing problems, sample code that wouldn't compile until you added other bits much later in the chapter
13:00:25 <Keenen> It's probably a good starting place to gets some ideas on how it's used
13:01:14 <maerwald> ongy: well, that's not really printf
13:01:59 <maerwald> (not saying printf is a good idea)
13:01:59 <sm> I've failed to rediscover how to count the values of an enum type. Derive Enum and Bounded, then use (maxBound :: TheType), I thought, but that's not right, I need an int
13:02:00 <ongy> maerwald: I think it largely does the same thing. But the syntax is quite different
13:02:13 <sproingie> and the barcode scanner was, i'll admit pretty real-world, but not too motivating for me
13:02:18 <maerwald> yes, so it's not printf :P
13:02:48 <maerwald> ongy: https://www.youtube.com/watch?v=fVBck2Zngjo
13:02:52 <Keenen> sproingie: haven't read RWH yet still in LYAHGG
13:03:40 <Keenen> sproingie: Haskell for Data Analysis seems real-worldy -- you get to make a twitter recommendation engine
13:04:50 <sproingie> seems a pretty good application for FP, yah
13:05:21 <ReinH> If it's that Packt book then my advice is the same as all Packt books: Assume it is garbage until you have evidence to the contrary.
13:07:48 <sproingie> i've been doing all my learning lately at the University of YouTube
13:08:05 <Keenen> it's a packt book but I havent really seen any problems with the book
13:08:09 <Keenen> overall seems pretty good
13:08:19 <sproingie> Bartosz Milewski has some great category theory lectures on youtube
13:08:21 <Keenen> each chapter is a mini project teaching a data analysis idea
13:09:06 <Keenen> first chapter is finding the expected value and median of a data set -- and works itself up to naive bayes
13:09:44 <Keenen> the quality of the book itself is pretty bad though
13:09:55 <Keenen> the actually print I mean
13:10:09 <Keenen> flimsy and made out of cheap shit
13:10:18 <sproingie> that's packt for you
13:10:33 <Keenen> I think the oreilly books are pretty sub par aswell though
13:10:53 <Keenen> the Miran Lipovaca book is execellent though
13:11:07 <sproingie> ORA's catalog is not what it was in the 90's, that's for sure
13:11:18 <sproingie> manning pretty much took over their spot
13:11:55 <sproingie> renaissance costumes instead of animal woodcuts
13:12:20 <Keenen> The best made textbook I ever got was "The Scheme by Dbvyg" the book was just so nicely made
13:14:23 <sproingie> i like the decorative aspect of a nice bookshelf.  but paper tech books are too impractical nowadays.
13:14:48 * EvanR attempts to combine sdl2 sdl2-ttf and cairo into a dumb demo app
13:15:22 <cocreature> EvanR: hopefullly it’s at least a pretty demoapp! :)
13:15:33 <EvanR> GLFW-b and diagrams didnt seem to get there fast enough
13:20:48 <EvanR> doh... SDL backend doesnt seem to be exposed by cairo bindings
13:21:47 <EvanR> ok shouldnt matter really
13:22:05 * hackage partial-order 0.1.2.1 - Provides typeclass suitable for types admitting a partial order  https://hackage.haskell.org/package/partial-order-0.1.2.1 (mtesseract)
13:27:06 <jadrian> pastebin gets confused with quoted constructors :/ 
13:27:14 <jadrian> the syntax highlight that is
13:29:26 <jadrian> can I get a bit of feedback on this (relatively small) piece of code, with dependent pairs?  https://pastebin.com/JTidKS2R
13:29:28 <kadoban> pastebin is pretty awful, especially for haskell. Pretty much any other place is better. lpaste is good. When it's broken I tend to use gist.github.com
13:30:01 <glguy> pastebin also has ads, please avoid it for #haskell
13:30:06 <jadrian> I still need to read a fair bit more, but it maybe some feedback can give me some direction, or an idea of how much that could eb improved
13:30:14 <jadrian> glguy: oh, so what? lpaste?
13:30:24 <jadrian> oh it's up there
13:30:27 <jadrian> sorry 
13:30:45 <Lokathor> jadrian, unfortunately, lpaste is down a lot :/
13:30:50 <sproingie> gist
13:30:50 <Lokathor> but it's the best when available
13:31:25 <jadrian> http://lpaste.net/356157
13:31:32 <jadrian> oh
13:31:49 <jadrian> it worked... actually
13:32:42 <iqubic> glguy: What do you think of dpaste?
13:33:03 <iqubic> jadrian: I can't view that paste. lpaste is down.
13:33:11 <glguy> It doesn't come to mind, I don't have an opinion of it
13:33:18 <jadrian> ok I'll use gist
13:33:24 <glguy> jadrian's paste loads for me
13:33:50 <iqubic> Actually, It just loaded for me. lpaste is a bit slow today
13:33:53 <glguy> jadrian: Did you have a question about what you pasted?
13:34:04 <iqubic> What is a type family???
13:34:17 <iqubic> I don't understand type families
13:34:24 <glguy> iqubic: have you started reading about them?
13:34:50 <iqubic> Yeah.
13:35:02 <glguy> What are they?
13:35:05 <c_wraith> Have you read https://www.microsoft.com/en-us/research/publication/fun-type-functions/ ?
13:35:09 <iqubic> https://wiki.haskell.org/GHC/Type_families
13:35:14 <iqubic> glguy: Not sure.
13:35:15 <c_wraith> I still think it's the best introduction to the topic.
13:35:15 <glguy> OK, what'd you learn?
13:35:20 <c_wraith> SPJ write such great papers
13:35:24 <iqubic> glguy: I have not learned much
13:35:29 <jadrian> ok gist now :P https://gist.github.com/anonymous/1e4b7fa6274cb83750b6927477afab64
13:35:44 <iqubic> jadrian: I didn't actually need that.
13:35:59 <glguy> iqubic: Yikes, maybe try c_wraith’s link then
13:36:04 * hackage nix-derivation 1.0.0 - Parse and render *.drv files  https://hackage.haskell.org/package/nix-derivation-1.0.0 (GabrielGonzalez)
13:36:37 <iqubic> glguy: I'm reading the haskell wiki article on type families at the moment.
13:36:56 <c_wraith> iqubic: I know that academic papers don't have the best reputation for being readable and comprehensible.  But SPJ papers are usually both.
13:37:12 <iqubic> I'll look at it now.
13:37:18 <jadrian> glguy: sorry just saw your question... well any kind of feedback, i.e. whether something could be implemented in a more idiomatic fashion, whether anything looks more horrible than it should...
13:37:45 <glguy> iqubic: You need to work on forming more specific questions about what you're learning. "How does that work??" and "What is that??" aren't specific enough
13:38:17 <iqubic> glguy, I'll try that?
13:41:45 <iqubic> So c_wraith paper mentions a naive way to combine IORef and STRef operations into a type class called Mutation. 
13:42:14 <iqubic> It then mentions that the two parameter Mutation type class is too polymorphic.
13:42:36 <iqubic> Since you could declare "Mutation IO (STRef s)"
13:42:55 <iqubic> Why not just use a Fundep to avoid that issue.
13:43:25 <c_wraith> You could.  It's been shown associated types and fundeps are roughly equivalent, modulo some edge cases
13:43:50 <c_wraith> But there are big differences in how things are expressed.
13:44:32 <iqubic> What sort of differences are you refering to c_wraith?
13:45:01 <c_wraith> fundeps are written as constrained relations, very much like writing a program in prolog
13:45:27 <c_wraith> type families are written by pattern-matching on types.  They end up looking a lot like any other haskell code
13:52:33 <ph88^> i can not make much of these type errors, anyone see what i did wrong?  https://bpaste.net/show/b1cd2d8fb12c
13:53:49 <glguy> ph88^: Is this supposed to be in ()s ? prepareSJ300Ebinary2 src
13:54:10 <glguy> ph88^: and then you probably don't want return on that line
13:55:36 <ph88^> ()s  ?
13:55:59 <glguy> Yeah, you use them to group expressions
13:57:09 <ph88^> tuple you mean ?
13:57:22 <ph88^> without return i also get type errors i don't understand https://bpaste.net/show/1b0b6482b6a3
13:57:48 <ph88^> on line 10 in my paste i return a tuple, then on line 20 it says actual type is a   Maybe a0   ????
13:58:16 <Cale> ph88^: What are the arguments to fmap there?
13:58:30 <Cale> They are:
13:58:31 <ph88^> oh i need parenthesis :/
13:58:36 <Cale> yes
13:59:46 <ph88^> i think glguy was onto something when he said i don't want to return there .. but that still leaves me with that weird error about  Maybe a0
14:02:07 <Cale> ph88^: What does that error look like now? I suspect its text will have changed a bit
14:02:19 <iqubic> I like how this paper uses the words functionally dependent, and then goes one to describe type assciations.
14:03:51 <ph88^> Cale, this is the only error left ..  https://bpaste.net/show/f8e6a28e13cf
14:04:07 <Cale> ah, right
14:04:20 <glguy> ph88^: You deleted too many returns
14:04:20 <Cale> Well, the thing on the right of the "Nothing ->"
14:04:23 <Cale> is obviously a pair
14:04:32 <Cale> but you're meant to be producing an m-action
14:04:40 <Cale> So yeah, probably you want return there
14:05:26 <Cale> and then if that's still an error, we'll deal with whatever error that is :)
14:06:54 <ph88^> now it works thanks
14:07:01 <ph88^> there was still an error but i was able to fix that myself
14:07:59 <iqubic> c_wraith: You were right. That Haskell paper on type families is rather easy to read and understand.
14:08:57 <Redrield> I'm trying to run stack setup under windows subsystem, and it seems to be hanging at "Installing GHC..."
14:09:00 <Redrield> I don't know why
14:09:05 <Redrield> I have the platform and stack installed
14:09:30 <glguy> Redrield: Is it just downloading slowly?
14:09:40 <glguy> using CPU?
14:09:55 <Redrield> Well I ran the program under traditional windows, and it was way quicker, and more verbose
14:10:00 <Redrield> Also, seems to have been
14:10:13 <Redrield> Was running 60% at 3.02GHz, and was running the fan pretty intensely
14:10:18 <Redrield> But didn't seem to be progressing
14:10:18 <glguy> Oh, actually there was a ticket about stack running slowly on the linux subsystem
14:10:47 <glguy> I don't that the windows subsystem can handle the way modern GHC allocates virtual memory
14:10:52 <Redrield> :/
14:11:07 <glguy> https://github.com/Microsoft/BashOnWindows/issues/1671
14:12:00 <Jinxit> anyone feel like helping me with my custom monad? http://lpaste.net/4167692073396338688
14:12:18 <Redrield> Yet another reason to try again at installing real Linux, I guess
14:12:24 <Redrield> God damn I wish these things would just work
14:13:46 <iqubic> Jinxit: Do you have functor and applicative instances for MultiT?
14:13:53 <Jinxit> yes
14:14:14 <iqubic> Can I see those?
14:14:53 <iqubic> Also, I think you may want to employ pattern matching in the go function.
14:15:45 <Jinxit> iqubic: added
14:16:37 <iqubic> Jinxit: You'll have to give me the new url.
14:16:54 <iqubic> I can't see the functor or applicative instances there.
14:17:05 <iqubic> Wait, there they are.
14:17:14 <lyxia> I'm not sure you can make this a monad
14:17:36 <Jinxit> perhaps i've structured MultiT wrong
14:17:39 <iqubic> Why not lyxia?
14:18:10 <iqubic> Jinxit: The Newtype declaration looks fine to me.
14:20:49 <Jinxit> lyxia: i've added a usage example to the paste
14:20:56 <Jinxit> so that's the goal i've been working towards
14:21:38 <iqubic> Jinxit: Why do you need a list of (Writer [Int])?
14:22:04 * hackage unicoder 0.5.0 - Make writing in unicode easy.  https://hackage.haskell.org/package/unicoder-0.5.0 (ZankokuOkuno)
14:23:07 <Jinxit> iqubic: parallel "universes" using branch, where in every branch you only see one of the computations
14:23:51 <Zemyla> Jinxit: You can't. There's no way to write, for instance, join :: [IO [IO a]] -> [IO a].
14:25:56 <Jinxit> Zemyla: can't write (>>=) for the MultiT i wrote or can't get the functionality i want?
14:26:19 <Zemyla> You can't write a (>>=) for the MultiT.
14:26:59 <Jinxit> okay, any idea how to properly structure MultiT to do what i want?
14:30:06 <pie3> who uses vpn?
14:30:11 <pie3> which are use cases of vpn?
14:30:25 <monochrom> Wrong channel, pie3.
14:30:30 <lyxia> Jinxit: WriterT Int []
14:30:38 <monochrom> Also, this is not a redirection service.
14:30:47 <lyxia> Jinxit: WriterT [Int] []
14:32:03 <monochrom> data MultiT m a = Nil | Cons a (m (MultiT m a))
14:32:16 <monochrom> See also "ListT done right"
14:34:51 <spehn> is this good language to learn, for practically having no programming experience before, except for a hobbyist interest in python?
14:36:01 <lyxia> sure it is
14:36:21 <Henri_> might make you hate programming in other languages thoug
14:36:57 <Jinxit> monochrom: interesting, thanks
14:37:09 <monochrom> I don't think you will hate other languages. Some people do, but only half-half.
14:37:39 <monochrom> What is more certain is that you will not reuse your existing mental model for Haskell.
14:37:49 <c_wraith> I don't exactly hate other languages, but I really wish I had traverse_ and traverse everywhere
14:38:02 <Rembane> +1
14:38:14 <ReinH> spehn: I would say that the best time to learn Haskell is when you have not developed habits from other languages.
14:38:33 <spehn> i have no habits, the only language i find myself
14:38:42 <ReinH> Otherwise you will spend some time unlearning them.
14:38:42 <spehn> needing to learn is python for oscp hacking cert stuff im doing
14:38:43 <Welkin> using C or asm is so different that it shouldn't affect those
14:38:53 <Welkin> strangely I am okay with javascript and lua though
14:39:04 <Welkin> even thought I can't stand using other non-haskell-like languages
14:39:09 <spehn> besides recent python interest, i last did VB like 15 years ago
14:39:11 <spehn> when in college
14:39:21 <monochrom> You never know how many habits you have developed, until you are deprived of them. Take for example breathing.
14:39:31 <ReinH> spehn: I will also say that understanding Haskell has helped a lot when learning other languages.
14:40:44 <ReinH> It's given me a richer understanding of evaluation semantics, type systems, runtimes, garbage collection, a whole bunch of things.
14:41:08 <spehn> so basically to start out since im on win10
14:41:16 <spehn> get: https://haskell.org/platform/download/8.0.2/HaskellPlatform-8.0.2-a-full-x86_64-setup.exe
14:41:17 <spehn> ?
14:41:29 <monochrom> Yes.
14:41:39 <Henri_> Get an IDE if it's your first time.
14:41:43 <monochrom> Not the only choice, but at your stage it doesn't matter.
14:42:01 <spehn> whats a good ide/gui then
14:42:02 <spehn> besides this?
14:42:32 <ReinH> Visual Studio Code has a decent Haskell mode, as does Atom. Neither require learning an arcane editing interface (like emacs or vim).
14:43:06 <Henri_> Yeah, vim is nice to use if you plan on investing a lot of time into it.
14:43:14 <ReinH> If you happen to already know emacs or vim, though, both have good Haskell support.
14:43:29 <spehn> only thing i know in vim is :q!
14:43:30 <pie3> how elastic can be used as ifttt?
14:43:31 <spehn> heh
14:43:32 <ReinH> I don't recommend learning two difficult, unrelated things at once.
14:43:35 <djj> Hi, ... 
14:43:42 <Henri_> Yeah then don't use a modal editor
14:43:43 <pie3> intellij has haskell compiler?
14:43:43 <Gurkenglas> https://hackage.haskell.org/package/JuicyPixels-3.2.8.1/docs/Codec-Picture.html#v:readImage seems to give me one of many possible kinds of DynamicImage. Presumably which I get is deterministic. How would I know which I get given a png or jpg file?
14:43:45 <spehn> guess i can install a copy of visual studio then
14:43:49 <ReinH> pie3: This is a channel for the Haskell programming language.
14:44:23 <ReinH> spehn: I said Visual Studio Code, which is their free editor.
14:44:45 <ReinH> I'm not sure how Visual Studio support is, and I don't think you need a full IDE experience to write Haskell.
14:44:49 <spehn> interesting, didnt know microsoft had that
14:45:15 <ReinH> You can do fine with an editor with syntax highlighting and a running GHCi session.
14:45:42 <spehn> ghci?
14:45:42 <ReinH> Some rudimentary support for indentation is also nice.
14:45:49 <spehn> installde the visual studio code
14:45:50 <Henri_> If you know your way around the shell then you don't need an IDE
14:46:01 <ReinH> GHCi is the Haskell REPL.
14:46:40 <ReinH> Well, technically it's GHC's REPL.
14:46:57 <Gurkenglas> Stepping back: With what library do I get to treat a picture as a two-dimensional datastructure of pixels?
14:47:57 <ph88^> i have some code here in which i made some mistakes so i get type errors https://bpaste.net/show/a822c7f9541c   i don't understand line 85 and line 115 in the paste
14:48:15 <spehn> winghci
14:48:21 <spehn> good place to start? just trying to find a basic place
14:48:24 <spehn> to start with newbie stuff
14:48:42 <ReinH> spehn: For VS Code Haskell support, check out https://blogs.msdn.microsoft.com/uk_faculty_connection/2017/02/13/introducing-haskelly-extension-for-visual-studio-code/
14:48:43 <glguy> ph88^: The 'm' in your type signature on line 18 is unrelated to the one from the signature above
14:48:58 <glguy> ph88^: You're not using the same m, you're shadowing the old one and making a new one
14:48:59 <c_wraith> Gurkenglas: does it have to be two-dimensional? JuicyPixels gives you a Vector and the dimensions of the image..
14:49:16 <c_wraith> Gurkenglas: then you're just some arithmetic away from two-dimensional coordinates
14:49:40 <glguy> ph88^: This is why your type error says: Couldn't match type ‘m’ with ‘m2’
14:49:49 <Gurkenglas> Sounds like it's going to be gritty working with JuicyPixels if even a two-dimensional representation requires implementation on my part
14:50:54 <spehn> ok
14:50:57 <spehn> this may be good for now for me
14:51:02 <spehn> installed the haskelly plugin via ext install haskelly
14:51:20 <ReinH> spehn: Check out https://github.com/bitemyapp/learnhaskell and http://learn.hfm.io/
14:51:40 <spehn> thx, bookmarked, afk
14:51:40 <ph88^> glguy, ok but even if i don't put the explicit type signatures i still get the 2nd and 3rd error,   line 85 and 115 in my paste
14:51:57 <ReinH> It's really nice to not have to recommend LYAH any more.
14:53:30 <ph88^> glguy, this is how it looks without those type signatures https://bpaste.net/show/e0fdb1ceebd7  line 69 is similar to the error i had before ... the other error is gone for the moment
14:54:22 <ReinH> ph88^: Well, you are giving a (t, Maybe Text) but claiming that it's a Maybe Text, are you not?
14:55:32 <ph88^> ReinH, where am i giving a  (t, Maybe Text)  ?
14:55:42 <ReinH> fmap (\(continuation, sampleState) -> (continuation, Just $ sampleStateSummary sampleState)) rsrc
14:56:10 <ph88^> yes that should be  (ResumableSource (ResourceT m) Value, Maybe T.Text)
14:56:53 <ReinH> How? You're using fmap.
14:57:22 <ph88^> well rsrc should be     (ResumableSource (ResourceT m) Value, AdjustSampleState)
14:57:36 <ph88^> the i fmap that function to change second part of tuple
14:58:02 <ReinH> your fmap takes a tuple and gives a tuple
14:58:10 <ph88^> i hope so
14:58:20 <ReinH> if it's applied to a function of type (a, b) for some a, b then b must be a tuple.
14:58:33 <ReinH> er, to a value of type (a, b)
14:58:37 <ph88^> o_O
14:58:43 <ph88^> ok maybe i'm not suppose to use fmap here
14:59:00 <ReinH> fmap (\x,y) -> (x,y) applied to some f a implies that a is a tuple.
14:59:02 <ph88^> how can i pattern match on rsrc ?  .. maybe i can destructure it that way
14:59:08 <ReinH> er, missing some parens there
14:59:20 <ReinH> case, where, let
15:00:02 <ReinH> let (x,y) = rsrc in ...; case rsrc of (x,y) -> ...; ... where (x,y) = rsrc
15:00:23 <ph88^> oki
15:00:25 <ph88^> thank you rein
15:00:33 <ReinH> yw
15:00:50 <ph88^> now it type check again
15:01:11 <ph88^> it's the second time i got tripped up on fmap with tuple
15:04:19 <ReinH> Important to remember that given T a b, you can only write Functor (T a).
15:04:51 <ReinH> So you can only map over the second element of a 2-tuple.
15:06:02 <sproingie> think of the rightmost element as the "varying" part.  same intuition applies to Either
15:06:39 <monochrom> In fact, whenever you see "(X, Y)", it's really "(,) X Y"
15:06:55 <ReinH> Yeah, I should have made that explicit, thanks.
15:07:04 <monochrom> And whenever you see "P Q R X a", it's really "(P Q R X) a"
15:07:21 <monochrom> So now let B = P Q R X. You're looking at "B a".
15:08:06 <monochrom> This is why I keep saying that an aptitude for highschool algebra is a prerequisite.
15:08:27 <ReinH> At least for the symbol manipulation part of highschool algebra
15:08:36 <EvanR> algebra, the hardest part of calculus
15:08:42 <monochrom> You will not be doing quadratic formula. But you will be doing type formulas.
15:08:43 <EvanR> and haskell
15:09:14 <ReinH> Unfortunately, highschool algebra is only tenuously related to the mathematical subject known as Algebra.
15:09:17 <sproingie> i washed out on integrals in high school calculus, never got a good intuition for them
15:09:33 <sproingie> other than "area under a curve" of course
15:09:48 <monochrom> You won't need to recall differentiation until you read one of those zipper papers.
15:10:25 <ReinH> But it's still fascinating to me that ADTs are differentiable.
15:10:58 <ReinH> The unreasonable effectiveness of algebra
15:11:58 <monochrom> Overall, expect most programmers to be deficient in highschool algebra skills.
15:12:31 <sproingie> because the way it's taught is so bad that most people suppress it
15:12:33 <monochrom> Because if someone is good at it, why don't they go become a Wall Street quant and make so much more money? Why bother be a coder?
15:12:58 <ReinH> See also Lambert's Lament.
15:13:11 <ReinH> Er, Lockhart
15:13:16 <ReinH> Who is Lambert?
15:13:18 <monochrom> Similarly, expect most programmers to be deficient in documentation skills (reading or writing or exploiting). Because the good ones can make so much more money as lawyers.
15:13:21 <sproingie> i grew up hating math.  turns out i like math, i just don't like numbers.
15:14:06 <ReinH> monochrom: That implies a market efficiency that I don't believe holds in the real world.
15:14:19 <ReinH> sproingie: yes exactly
15:15:17 <ReinH> I also know lawyers that have left law and become programmers.
15:15:24 <monochrom> It doesn't have to be 100% perfectly what I said. If it's even 15% what I said, it's already enough to explain why docs on hackage mostly suck.
15:15:35 <monochrom> Also why some many prorgrammers don't RTFM.
15:15:40 <monochrom> s/some/so/
15:15:48 <ReinH> monochrom: Yeah, it makes sense as a tendency.
15:16:04 <sproingie> there's a few different paths to being a good programmer, not all of them are even in sciences
15:16:06 <ph88^> this thing with first class (IO) actions is starting to dazzle me a bit
15:16:06 <monochrom> 100% efficiency would be 100x worse than status quo.
15:16:17 <jadrian> monochrom, ReinH: I have some drafts on differentiation of ADTs, that I haven't touched in ages, where I noticed a possibly interesting pattern on polynomial expantion of some "complicated" types 
15:16:35 <EvanR> hmm, 100% market efficiency, 100% real numbers
15:16:41 <ReinH> jadrian: have you read Conor's stuff?
15:16:47 <sproingie> IO actions were easy for me to grok once i took all the monad plumbing out of the picture
15:16:55 <jadrian> ReinH: yes, it was when I was studying his papers 
15:17:03 <ReinH> Cool.
15:17:06 <sproingie> returning a list of actions to do later, that's a pattern most of us have reinvented in other languages
15:17:32 <ph88^> sproingie, ye but with fmap you can append extra actions onto it before you execute it ^^
15:17:35 <ReinH> sproingie: If people do javascript I just tell them to think about promises.
15:17:36 <jadrian> ReinH, monochrom: trying to recall, I think I used a type of "lists of lists of... possibly infinite depth of lists"
15:17:58 <sproingie> hell, IO is still difficult to explain as a monad since it involves "then the runtime does this thing behind the scenes"
15:18:02 <spehn> man, the utilities companies is gutting everyones front yards.......looks like a war zone, all because of us getting google fiber in 1 month
15:18:05 <spehn> i guess thats a good trade off lulz
15:18:14 <monochrom> Yes in fact recursive ADT gives you an infinite series. Not really algebraic anymore. It's analysis now.
15:18:23 <jadrian> ReinH, monochrom: and then applied some polynomial expansion that saw on wolfram... and the coeficients seemed interesting
15:18:40 <sproingie> ReinH: yeah, *now* it's an accessible metaphor.  explaining promises back in the day was another matter entirely
15:18:47 <kebertx[m]> I've always been curious why `succ pi` adds one instead of using the [nextafter()](http://man7.org/linux/man-pages/man3/nextafter.3.html) functions to get the next double
15:18:50 <jadrian> ReinH, monochrom: looked up the sequence and it was some known combinatorial sequence
15:18:58 <sproingie> but now you can say "pronounce >>= as 'then'"
15:19:19 <ph88^> ReinH, what's the thing with promises ? it just restructure your code, but is it an improvement over older methods ?
15:19:21 <jadrian> ReinH, monochrom: and it actually returned the number of combinations of lists up to a certain depth or something like that
15:19:23 <sproingie> (where errors take a different path, but you can gloss over that)
15:19:32 <ReinH> ph88^: The thing is that they're informal monads.
15:19:35 <Tuplanolla> I'd also like to know that, kebertx[m].
15:20:07 <monochrom> succ pi = pi+1 was an arbitration by a committee. End of story.
15:20:18 <ph88^> ReinH, but do we actually like monads ? :p
15:20:25 <ReinH> Certainly.
15:20:44 <ph88^> well i'm working with them, but i couldn't tell what's good about it
15:20:50 <monochrom> In fact, "instance Enum Double"'s existence at all was also a committee arbitration.
15:21:04 <satoru> hi all
15:21:05 <EvanR> pi + 1 does make some kind of sense...
15:21:06 <ph88^> i'm not saying they are bad either ..
15:21:19 <EvanR> succ is construed to be... (+1)
15:21:26 <jadrian> monochrom: I didn't know about an Enum Double instance...
15:21:27 <sproingie> monads don't compose well though.  they're selfish by nature.
15:21:29 <ph88^> hi satoru 
15:21:33 <ReinH> Once you begin to grok monads, you start to see them everywhere. It's just that they are usually poorly specified and ad hoc.
15:21:36 <Jinxit> monochrom: how can i do `ListT m a -> [m a]`? can't seem to find any examples of getting "all possible variants", i only see "the first successful"
15:21:37 <satoru> hru :>
15:21:53 <monochrom> Cannot.
15:21:54 <ph88^> ReinH, you're right i do see them everywhere LoL
15:21:58 <ph88^> well not everywhere
15:22:02 <ph88^> but more often than i used to
15:22:15 <Jinxit> oh, but that's what i wanted with my monad
15:22:21 <sproingie> ReinH: what's amazing is that it's javascript programmers of all people that are really getting it.  they may not know "monad" but they probably know "then-able"
15:22:28 <ReinH> The Promise API designers did not, I believe, consciously try to write a monadic interface.
15:22:32 <monochrom> On second thought I am not really sure which one you really need: ListT m a, [m a], m [a]. But you should investigate all of them.
15:22:39 <ReinH> It's just that the thing they want is perfectly described as a monad.
15:22:54 <ph88^> i'll just go ask in the javascript channel what's good about promises
15:22:55 <ReinH> And so a good design will naturally tend towards being monadic.
15:23:04 <lyxia> Jinxit: transform the list monad rather than list-transforming another monad.
15:23:15 <EvanR> i dont really believe javascript is capturing specifically monadism
15:23:18 <ReinH> They are failure monads for javascript.
15:23:31 <EvanR> maybe the IO monad ism
15:23:42 <ReinH> They are not law-abiding, but that's only because javascript lacks purity.
15:23:50 <ReinH> They are generally used in a law-abiding way.
15:23:52 <EvanR> no
15:24:00 <sproingie> nothing forces haskell monads to be law-abiding either
15:24:19 <ReinH> sproingie: The difference is that you can't use a law-abiding monad in a law-breaking way.
15:24:25 <EvanR> if you imagine a free monad program, then you could imagine interpreting it part way
15:24:30 <ReinH> (without resort to unsafe whatevers)
15:24:46 <EvanR> a javascript program interpreted part way isnt a piece of data, its a just an IO
15:24:57 <sproingie> i got enlightened to promises as monads through akka actually
15:25:01 <ph88^> ReinH, #javascript says that promises are mildly _less_ convenient than async await    .. is that something haskell could use? async await ?
15:25:11 <ReinH> async/await is do notation for javascript
15:25:16 <sproingie> for-comprehensions on futures were so amazeballs
15:25:25 <ReinH> A special case of do notation.
15:25:26 <EvanR> its a way to do haskell IO in javascript
15:25:31 <EvanR> i dont think this is a monad story
15:25:42 <sproingie> ReinH: really?  i thought it fairly hardwired async semantics.
15:25:52 <ReinH> Yes, it's a special case of do notation.
15:26:01 <monochrom> #haskell says that javascript is mildly less convenient than haskell :)
15:26:07 <ReinH> What Haskell has is do notation generalized to arbitrary monads
15:26:19 <sproingie> something special-cased that it's not generally reusable
15:26:26 <ReinH> async/await is do notation specialized to promises
15:26:38 <EvanR> haskell IO doesnt need to have anything to do with do notation, its a function thenIO with a specialization of the monad bind type, that doesnt have any laws
15:26:57 <sproingie> i wasn't aware async/await specifically desugared to anything
15:27:07 <Jinxit> lyxia: ohhhhh, now i realize what you meant by WriterT [Int] [] earlier
15:27:14 <Jinxit> this is perfect, thanks!
15:27:15 <EvanR> to me it seems like the classic jquery is a monad claim
15:27:18 <ph88^> sproingie, what's akka ? i see the website but it doesn't say what it is
15:27:19 <ReinH> By "is", I mean "can be thought of as".
15:27:20 <sproingie> whereas do-notation and scala for-comprehensions have a well-defined desugaring
15:27:32 <sproingie> ph88^: actor framework for scala
15:27:42 <ph88^> oh ok
15:27:49 <EvanR> oop is a monad... or was it a comonad
15:27:51 <pikajude> IO doesn't fulfill the monad laws?
15:27:57 <sproingie> sure it does
15:28:24 <ReinH> Maybe I should say "async/await is *like* do notation for promises", but I thought it was clear that I was speaking metaphorically.
15:28:31 <ReinH> Since, you know, javascript does not actually have do notation.
15:28:39 <ph88^> Jinxit, ye sometimes it just needs to sink in :P
15:29:05 <maerwald> ReinH: should become clearer if you mix in food metaphors
15:29:14 <hpc> ReinH: just go all in - "async/await is the cut operator for ruby blocks" :D
15:29:18 <ph88^> it's perfectly clear to me
15:29:22 <ReinH> hpc: sure
15:29:38 <sproingie> i suppose babel desugars async/await, but from what i can tell, the ES7 implementation lets the runtime assume it's for concurrency
15:30:01 <sproingie> hpc: i thought that was callCC
15:30:14 <sproingie> or as i call it, "functional goto"
15:32:42 <sproingie> i like to explain monads to imperative programmers as "overloading the semicolon operator"
15:32:49 <ph88^> LOL
15:33:18 <ReinH> it also handles failure by converting error callbacks to exceptions, iinm
15:33:34 <sproingie> the way C++ is going, it might end up doing that
15:33:40 <ReinH> sproingie: and, imo more to the point, overloading the = operator.
15:33:45 <sproingie> stroustrup is trying to push through overloading the dot operator
15:34:11 <ReinH> applicative is sufficient for an overloaded semicolon
15:34:12 <EvanR> and the nested side-effecting expression operator
15:34:21 <EvanR> x = f(readFile())
15:34:34 <EvanR> overloaded
15:35:07 <sproingie> given arbitrary side effects, applicative would be sufficient, period
15:35:35 <ph88^> in english the dot operator is overloaded to period
15:35:55 <sproingie> .
15:36:05 <whoman3> =)
15:36:26 <jadrian> I really don't know enough about "Roles" to decipher its problems with `join` as explained here https://ghc.haskell.org/trac/ghc/wiki/Roles2#join but wish I did, because the whole thing seems really odd 
15:36:46 <EvanR> overloaded literally sounds like a word has more meanings than it can handle or was designed for. 
15:37:01 <EvanR> in programming... that number is 1
15:37:12 <ph88^> overloaded can be a bit overloaded ye
15:37:27 <hpc> EvanR: haha, that makes perfect sense in retrospect
15:37:28 <EvanR> but over sounds like it could be used when its like, more than max for that word
15:37:47 <ph88^> same thing for generics
15:37:54 <jadrian> odd that any derivation would be problematic with join in the class, but not without join (given join is implicitely derived anyway via bind ) 
15:38:09 <sproingie> huh "Roles" is pretty mysterious to me too
15:38:17 <EvanR> to emphasized the 1-max in programming, coulda called it... multiloading
15:38:37 <jadrian> odd that the design of classes is being constrained by technicalities of an experimental feature
15:38:44 <EvanR> or multimeaning
15:39:25 <sproingie> "overloading" has long-established historical use even before c++
15:39:52 <whoman3> overwriting, deprecating, redirecting, forwarding
15:39:55 <EvanR> i dont care how long somethings been established, ill mock it 
15:40:09 <sproingie> mostly in terms of operators being overloaded by compilers, e.g. ints vs floats
15:40:15 <ph88^> @pl \c d -> fmap (\(a, b) -> (c a, b)) d
15:40:15 <lambdabot> fmap . (`ap` snd) . (. fst) . ((,) .)
15:40:22 <jadrian> sproingie: indeed it has, just ask any mathematician 
15:40:23 <Tuplanolla> The use in C++ actually refers to the complexity of operators overloading the programmer.
15:40:38 <ph88^> that point-free style is so not readable
15:40:51 <sproingie> that's why they call it pointless :)
15:41:01 <ph88^> .
15:42:32 <ph88^> @pl fmap (\(a, b) -> (c a, b))
15:42:32 <lambdabot> fmap (first c)
15:42:34 <ph88^> what's this first ?
15:42:47 <ph88^> ye i saw the type .. something about arrows
15:43:00 <sproingie> i got back into c++ recently, gotta say it's evolving nicely.  only thing i still hate is having to write for every permutation of const and reference
15:43:10 <ReinH> Among the incorrect reasons it is called pointless...
15:43:16 <Tuplanolla> It's a bifunctor thing, ph88.
15:43:32 <ph88^> oh ok
15:43:50 <ReinH> first f (a, b) = (f a, b)
15:44:04 <ReinH> It's exactly the shape of the thing you're fmapping
15:44:12 <Tuplanolla> More generally `first f = bimap f id`.
15:44:20 <ReinH> Yes.
15:44:34 <ReinH> I specialized it on purpose though.
15:45:13 <ReinH> bimap f g (a, b) = (f a, g b)
15:45:27 <sproingie> never could figure out programming in arrows
15:45:37 <ph88^> should i use the one from Control.Arrow or Data.Bifunctor ?
15:45:37 <ReinH> Which is why I specialized it. ;)
15:45:51 <ReinH> ph88^: I would just use \(a, b) -> (c a, b)
15:45:55 <ph88^> ok
15:45:58 <EvanR> sproingie: its just a crippled sort of symmetric monoidal category
15:46:01 <jadrian> Honestly, the problem with "overloading" and other syntactic issues, IMO is just that we still program in "plain" text.  Ideally code should be stored in some data base, and the editor provide a nice view 
15:46:02 <EvanR> whats the problem
15:46:04 <ReinH> or define first myself as above
15:46:31 <sproingie> EvanR: oh i get the basic ideas, i just can't assemble them into anything useful in my head
15:46:36 <EvanR> heh
15:46:37 <jadrian> then you could have seemingly overloaded operators which on further inspection are differentiated by extra info
15:46:44 <ReinH> Bringing in arrow or bifunctor machinery so you can write \(a, b) -> (f a, b) in a slightly different way is overkill.
15:46:48 <sproingie> meanwhile someone freakin wrote an FPS using arrows
15:46:52 <sproingie> (namely frag)
15:47:00 <EvanR> the overloading of overkill
15:47:19 <bno1> is it ok to do: '_ <- forkIO $ handler data'?
15:47:36 <ReinH> I also often write fanout f (a, b) = fanout (f a, f b) even though it's bimap f f or (&&&).
15:47:44 <ReinH> er, fanout f (a, b) = (f a, f b)
15:48:04 <ReinH> or is it (***)? This is exactly the problem.
15:48:24 <Rembane> bno1: Yes it is. What are your concerns?
15:48:36 <ReinH> (***) is pointwise, right? (f, g) *** (a, b) = (f a, g b) 
15:48:43 <barrucadu> I use "first" and "second" all the time, but "&&&" and "***" are definitely too cryptic for me
15:48:44 <bno1> the fork being ignored because the result isn't used
15:48:54 <hpc> > (f, g) *** (a, b)
15:48:56 <lambdabot>  error:
15:48:56 <lambdabot>      • Could not deduce (Arrow (,)) arising from a use of ‘***’
15:48:56 <lambdabot>        from the context: (FromExpr c, FromExpr b)
15:49:06 <ReinH> :t (***)
15:49:08 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:49:16 <hpc> doh
15:49:18 <Rembane> bno1: It will start and run. 
15:49:22 <bno1> ok, thanks
15:49:23 <ReinH> See this is what I mean.
15:49:34 <hpc> > (f *** g) (a, b)
15:49:36 <lambdabot>  error:
15:49:36 <lambdabot>      • Ambiguous type variable ‘c0’ arising from a use of ‘show_M111792472198...
15:49:36 <lambdabot>        prevents the constraint ‘(Show c0)’ from being solved.
15:49:38 <ReinH> It would help if you could write a as ~> or so
15:49:57 <hpc> > (f *** g) (a, b) :: (Expr, Expr)
15:49:59 <lambdabot>  (f a,g b)
15:50:04 <ReinH> b ~> c -> b' ~> c' -> (b, b') ~> (c, c') is nicer
15:50:06 <hpc> > (f &&& g) a :: (Expr, Expr)
15:50:08 <lambdabot>  (f a,g a)
15:50:13 <Tuplanolla> I found myself using `Control.Arrow` only for the silly combinators, so I stopped. Bifunctors and profunctors are often more suitable.
15:50:14 <hpc> there you go
15:50:20 <EvanR> in the SDL docs, specifically windowBrightness :: Window -> StateVar Float is the only thing in sight that mentions that it will throw an exception if the system runs out of memory
15:50:24 <ReinH> hpc: yeah
15:50:25 <EvanR> i find this mildly amusing
15:50:29 <ph88^> return . second (Just . headersToText)
15:50:30 <ph88^> \(values, headers) -> return (values, Just $ headersToText headers)
15:50:40 <ph88^> just looking at this .. interesting it works ^^
15:50:51 <hpc> Tuplanolla: yeah, the consensus seems to be that Arrow would be a lot better if arr was eliminated
15:51:12 <sproingie> EvanR: seems pointless to mention, most things tend to die when memory is exhausted
15:51:13 <hpc> but that would make writing longer arrow sequences difficult (like with arrow do notation)
15:51:30 <sproingie> and SDL is pretty good about catching and reporting allocation failures
15:51:36 <EvanR> sproingie: ... yes you cant really rely on anything happening.... and that one function claims to care
15:51:49 <EvanR> and its the window brightness
15:52:15 <sproingie> i bet it specifically checks and SDL doesn't
15:52:24 <sproingie> (which would be a SDL bug)
15:52:41 <EvanR> i dont bet that
15:52:45 <sproingie> or i dunno, maybe the doc writer was feeling expositive
15:53:09 <EvanR> the StateVar mechanism is a way to basically set a field in a struct
15:53:21 <EvanR> i cant imagine how it could even run out of memory doing this
15:53:44 <EvanR> i could, but it seems silly
15:54:13 <sproingie> has to allocate the boxed return value.  but yah, silly
15:56:49 <ph88^> why is there no short for
15:56:55 <ph88^> @pl fmap (first a)
15:56:55 <lambdabot> fmap (first a)
15:57:49 <Welkin> short?
15:57:56 <sproingie> 'a' is a free variable there
15:58:06 <lyxia> why would there be such a thing
15:58:06 <Welkin> :t fmap . first
15:58:08 <lambdabot> Functor f => (b -> c) -> f (b, d) -> f (c, d)
15:59:02 <EvanR> can i get fusion when converting a ByteString to IOVector Word8
15:59:04 <ReinH> I feel like fmap (first a) is well below the Fairbairn Threshold.
15:59:20 <ph88^> the what ?
15:59:24 <Welkin> what is `a` here?
15:59:50 <sproingie> in this case, an arbitrary variable
15:59:57 <Welkin> ReinH: the Berenstain Threshold
16:00:00 <ReinH> "The Fairbairn threshold is the point at which the effort of looking up or keeping track of the definition is outweighed by the effort of rederiving it or inlining it." http://mail.haskell.org/pipermail/libraries/2012-February/017548.html, first google result.
16:00:03 <sproingie> @pl fmap (first foobarblahblahblah)
16:00:03 <lambdabot> fmap (first foobarblahblahblah)
16:00:28 <ReinH> iow, short enough not to need a name and all the clearer for not having one.
16:00:54 <Welkin> so what ph88^ really means to say is `\a -> fmap (first a)`
16:01:03 <sproingie> aka fmap . first
16:01:06 <Welkin> yes
16:03:04 <EvanR> its happening again, heavy entropy encountered using ByteString from one lib as IOVector Word8 in another
16:03:10 <EvanR> brain melting
16:03:32 <Welkin> it's the Berenstain Bears again
16:03:55 <sproingie> Heavy Entropy would be a decent band name
16:04:14 <EvanR> the fact that these are the same damn object in memory, conceptually
16:04:27 <EvanR> but you cant use unsafeCoerce for various reasons
16:04:52 <EvanR> and theres no premade conversion either
16:05:19 <bluebaron> Is there a channel for the haskell book?
16:05:29 <sproingie> which book?
16:05:52 <ph88^> bluebaron, #haskell-beginners most likely
16:06:10 <bluebaron> Thank you!
16:06:49 <Welkin> the book that has the domain "haskellbook"
16:07:34 <ph88^> clever marketing
16:16:53 <orion__> Is there a way to rewrite this without using undefined/error and without traversing the list twice?: https://gist.github.com/centromere/1c33db3921810d590f150e7ac887761b
16:17:32 <EvanR> i need the foreign pointer out of a ByteString... but the Internal module refuses to show its documentation
16:18:40 <EvanR> like as punishment for my impudence, do i need to write a loop that reads and writes Word8's one by one
16:19:07 <sproingie> depends on what you do with the Word8's
16:19:18 <EvanR> convert a ByteString into an IOVector Word8
16:19:28 <sproingie> i suspect you could coax it to give you a size then pass it to C
16:19:55 <EvanR> not sure what C has to do with it
16:20:14 <sproingie> to copy over raw bytes in bulk
16:20:32 <sproingie> or ... i guess if those are boxed that's not gonna happen
16:20:45 <glguy> EvanR: There's a useAsCString you can use instea
16:20:46 <glguy> d
16:21:24 <glguy> unsafeUseAsCString :: ByteString -> (CString -> IO a) -> IO a
16:21:34 <glguy> That'll give you bracketed access to the pointer
16:21:36 <EvanR> that gives me a Ptr CChar
16:21:50 <glguy> Yeah, you'll have to cast it if you want a different type
16:22:01 <EvanR> vector wants a ForeignPtr Word8
16:22:04 <EvanR> is that castable
16:22:25 <EvanR> well, ForeignPtr a
16:23:23 <glguy> Oh, if you want to just rewrap the internal foreignpointer in a MVector constructor, you'll just have to use the Internal module
16:23:32 <EvanR> i see it goes the other way..
16:23:34 <glguy> This isn't a "supported" operation
16:23:38 <glguy> but you can do it
16:23:43 <EvanR> i dont really want to, i just want to do anything
16:23:51 <EvanR> i just hope its not a stupid loop
16:24:45 <EvanR> its like theres an air gap between SDL and Cairo
16:25:27 <ph88^> sounds like you're doing a cool project
16:26:40 <sproingie> opengl context might be a good way to glue them together ... not that i know any compatible way of getting the raw opengl context from either
16:27:10 <EvanR> ok i see
16:27:19 <EvanR> newForeignPtr_
16:27:20 <sproingie> if you can get sdl and cairo working together seamlessly, i'll worship you as a minor deity
16:27:32 <EvanR> SDL and Cairo work together seamlessly in C
16:27:50 <sproingie> not so much in other languages (i had similar problems in python)
16:27:58 <EvanR> if this works.... i want to write an arcane diagram about how
16:29:05 <sproingie> screw the diagram, just release that glue lib on hackage
16:29:28 <EvanR> theres already some sort of 0.0.1 package like that on hackage that breaks inter the Internal module
16:29:31 <ph88^> libs need diagrams too
16:29:49 <sproingie> hell yeah they do, but i'll take working code first :)
16:29:57 <sproingie> (i have a specific project that could use this)
16:30:20 <EvanR> well see how many imports you need for this in the aftermath
16:30:52 <sproingie> normally i'm usually bitching in the opposite direction, about lack of docs in existing libs
16:32:01 * sproingie .o( /nick cosproingie )
16:41:51 <EvanR> nice
16:42:11 <EvanR> i get back a mutable vector with nonsense content
16:44:24 <hpc> so you get back a mutable vector then ;)
16:44:30 <sproingie> weirdly funny that i've dealt with the same sort of problems before ... in perl
16:45:02 <sproingie> where a "just ship the bytes around" problem became a nightmare of corrupted data
16:48:24 <EvanR> what am i doing wrong http://lpaste.net/356158
16:49:33 <EvanR> fromByteString "abcd" gives back a 4-word8 vector with 4 wrong numbers, different each time, not 97 98 99 100
16:51:46 <EvanR> cast because fptr is ForeignPtr CChar, but i need a ForeignPtr Word8
16:51:46 <sproingie> changing every time sounds like you're getting a pointer back
16:52:18 <sproingie> and you're reading from the location of the pointer and not its referent
16:52:23 <sproingie> (been there done that)
16:52:33 <EvanR> oh geez, its changing every time i do V.read v 0
16:53:19 <EvanR> thats a fun source of entropy
16:54:19 <EvanR> sproingie: :t v is IOVector Word8, consistent with my type sig...
16:54:44 <EvanR> oh
16:54:47 <sproingie> the box is right, the content OTOH ...
16:54:59 <sproingie> can't get much more untyped than char *
16:55:24 <EvanR> the fptr is literally being returned
16:55:33 <EvanR> even though its invalid after the useAsCString
16:55:48 * EvanR tells haskell to make a damn copy
16:57:59 <EvanR> im not sure how to allocate the appropriate memory for this mutable vector
16:58:46 <EvanR> does it have to be pinned or ...
16:58:49 <sproingie> ya got me there
16:59:23 <c_wraith> it only needs to be pinned if you're going to hand it off to the FFI
17:00:06 <EvanR> handing it to SDL... 
17:00:25 <c_wraith> then yes, it needs to be pinned
17:00:35 <EvanR> is there a special way to get pinned?
17:01:01 <sproingie> well, certain dating sites...
17:01:06 <c_wraith> The various alloc functions in the Foreign modules.  Probably other ways.
17:01:14 <EvanR> ah so thats all pinned
17:01:22 <c_wraith> yes
17:01:38 <EvanR> i must be missing something basic about allocating a mutable vector
17:03:02 <EvanR> OK... new
17:03:16 <EvanR> then doing a memcpy
17:04:43 <c_wraith> Note that Storable vectors have different properties as far as this is concerned, if you are using them
17:05:10 <EvanR> i am
17:05:28 <c_wraith> Ok.  Allocating one of them should give you pinned memory immediately
17:05:38 <ertes> EvanR: honestly i would write a pure copying function
17:05:42 <c_wraith> Since the whole point is that you can pass them to native calls
17:05:47 <EvanR> ertes: im trying
17:05:56 <ertes> EvanR: or better: just start from Vector right away
17:06:07 <EvanR> the API literally wants a mutable storable vector of Word8
17:06:19 <EvanR> so as pure as that gets
17:07:03 <EvanR> or what did you mean
17:07:09 <ertes> EvanR: i mean via V.generate
17:07:14 <ertes> and (B.!)
17:07:27 <ertes> ugly, slow, etc.
17:07:29 <ertes> but safe
17:07:52 <EvanR> then what
17:07:52 <c_wraith> Note that accessing Storable vectors directly from the Haskell side is painful - you have to marshall a value every time you read or write
17:08:23 <EvanR> heh, i guess youre expected to use the Ptr 
17:08:26 <Welkin> c_wraith: you can wrap that up on a function
17:08:27 <ertes> EvanR: in fact my conjecture is that your current code is wrong in the sense that it drops the ForeignPtrness of the ByteString in order to create a new ForeignPtr that knows nothing about the existing one
17:08:44 <ertes> EvanR: you may be running into a classic double-free scenario:  you forget the ByteString just after converting it to Vector
17:08:53 <EvanR> my code is wrong because the fptr escapes the function
17:08:55 <ertes> then the ByteString's finaliser will run
17:09:00 <EvanR> i "forgot" to make a copy of the data
17:09:02 <c_wraith> Welkin: well no.  My point is that it's automatic in read/write calls.  You can't avoid it
17:09:19 <EvanR> nothing is allocated or freed
17:09:38 <EvanR> i cant explain how the data is different each time i read it though
17:09:45 <EvanR> i thought ByteString data was pinned
17:10:16 <EvanR> oh it got collected!
17:10:29 <c_wraith> do you need to add a call to touchForeignPtr?
17:10:29 <ertes> EvanR: yes, that's what i'm saying
17:11:01 <EvanR> currently, its looking like i dont need any foreign pointers
17:11:09 <ertes> just after the ForeignPtr is created you no longer have a reference to the ByteString (or its underlying ForeignPtr)
17:11:13 <ertes> so GC kicks in
17:11:24 <ertes> or more likely GHC writes code to collect it right away
17:11:47 <EvanR> thats kind of amazing, if you have a pointer into the heap and your data is gone, it appears to be a random byte generator
17:12:06 <EvanR> starting to understand the "accursed unutterable..."
17:12:13 <ertes> /dev/ghcrandom
17:12:29 <c_wraith> "accursed unutterable" is more to do with optimizations removing the entire operation if you're not careful
17:16:05 <ertes> EvanR: i think it may be safe to reuse the underlying ForeignPtr of the ByteString…  you should be able to get a hold of it through the internal API
17:16:22 <ertes> but if you want to be safe for sure, copy
17:16:26 <EvanR> its certainly not safe, as i demonstrated
17:16:39 <ertes> no, you didn't reuse the ForeignPtr
17:16:45 <EvanR> what?
17:17:07 <EvanR> i simply wrapped the fptr in a IOVector constructor and returned it
17:17:10 <EvanR> it broke
17:17:17 <ertes> CString is a plain Ptr
17:17:29 <ertes> you created a *new* ForeignPtr
17:17:52 <EvanR> i dont really understand what newForeignPtr_ does
17:18:06 <ertes> it creates a new ForeignPtr, which is pretty much a Ptr with a finaliser
17:18:12 <EvanR> so whats the difference
17:18:22 <c_wraith> whether you're creating an extra finalizer or not
17:18:33 <c_wraith> whether you're causing the other finalizer to be run or not
17:18:35 <EvanR> im not using finalizers for anything, ertes what are you trying to say
17:18:35 <ertes> you have a ForeignPtr fp1, which has a finaliser attached by ByteString
17:18:52 <ertes> you reduce it to a plain Ptr, which is just an integer
17:19:12 <ertes> then you create a new ForeignPtr fp2 from that Ptr, which doesn't have anything to do with fp1
17:19:35 <ertes> now the ByteString goes out of scope, together with fp1
17:19:44 <ertes> which causes the finaliser of fp1 to run
17:19:47 <EvanR> fp1 being, whats inside the ByteString ?
17:19:52 <ertes> yeah
17:20:18 <ertes> now storable Vector is also just a ForeignPtr under the hood (with length information)
17:20:27 <ertes> if you *reuse* fp1, then it should be fine
17:20:53 <EvanR> how is newForeignPt_ now labeled "unsafe" then
17:20:56 <ertes> it's a bit unsafe (beware of major version changes for either library), but it should be fine with the current versions
17:21:05 <c_wraith> EvanR: newForeignPtr_ isn't unsafe
17:21:07 <ertes> it's not unsafe
17:21:19 <EvanR> i used it, and got a pointer to something that disappeared
17:21:25 <ertes> it just doesn't know that the Ptr you give it originally came from a ForeignPtr
17:21:26 <c_wraith> that's not because you used it
17:21:38 <c_wraith> That's because you used the previous ForeignPtr incorrectly
17:21:49 <ertes> or rather you did *not* use it =)
17:21:53 <EvanR> well, i never got access to it beacuse i cant see the docs for Internal...
17:22:09 <ertes> if you can't use the internal API, you really need to make a copy
17:22:17 <EvanR> thats what im doing right now
17:22:38 <EvanR> seems to work
17:23:12 <ertes> do you need a mutable vector?
17:23:13 <EvanR> http://lpaste.net/356159
17:23:40 <EvanR> SDL requires it as an argument to createRGBSurfaceFrom
17:25:04 <EvanR> im going to write this code the other direction now for posterity
17:25:51 <ertes> yeah, looks correct to me
17:26:15 <dolio> You could have saved yourself a lot of trial and error by just looking at the Internal module source code. :P
17:26:31 <EvanR> i could have
17:26:45 <MarcelineVQ> thank you all, that was quite interesting
17:26:48 <EvanR> but i ended up not needing it
17:27:22 <ertes> EvanR: note that i believe the surface API is obsolete in SDL 2
17:27:26 <ertes> you should use Renderer + Texture
17:28:09 <EvanR> to use a Texture, you have to first create a surface
17:28:14 <EvanR> surfaces are not deprecated
17:29:35 <ertes> that's not correct…  i have drawn using only Renderer + Texture in the past, and the migration guide explicitly says that the surface API is deprecated
17:29:59 <ertes> in fact it shouldn't be used, because it will most likely use system RAM instead of video memory
17:30:23 <ertes> also the Texture API is much better anyway =)
17:30:37 <EvanR> i dont see that
17:30:46 <ertes> https://wiki.libsdl.org/MigrationGuide
17:30:47 <EvanR> i also dont see a way to load data into a texture
17:31:01 <ertes> "SDL2 still has SDL_Surface, but what you want, if possible, is the new SDL_Texture. Surfaces are always in system RAM now, and are always operated on by the CPU, so we want to get away from there."
17:31:31 <ertes> let me check…  the API is a bit weird
17:32:04 <EvanR> ... updateTexture... takes a ByteString
17:32:10 <ertes> one option is to use 'updateTexture', but for some reason it takes a ByteString
17:32:22 <ertes> but there is a way to do without ByteString…  i know that, because i've done it
17:32:40 <ertes> ah, there we go:  lockTexture + unlockTexture
17:33:25 <ertes> lockTexture gives you a Ptr, which you can either use directly (awkward), or you can go through newForeignPtr_ and unsafeFromForeignPtr0 to get an MVector
17:33:45 <ertes> now you have a storable MVector that you can modify
17:35:10 <EvanR> everything i know is wrong
17:35:38 <ertes> EvanR: here is an old example of mine that demonstrates all of that: http://lpaste.net/170277
17:36:02 <ertes> line 167 is where i draw
17:36:07 <EvanR> newForeignPtr_ on this Ptr from lockTexture is safe to use?
17:36:21 <EvanR> im kind of flaky right now on wtf happened with that
17:36:44 <ertes> yeah, that one is safe
17:36:56 <c_wraith> EvanR: well, it works best when you aren't passing it an invalid pointer. :P
17:37:06 <ertes> hehe
17:37:13 <EvanR> the Ptr from asCString is invalid??
17:37:25 <EvanR> its brand new :(
17:37:35 <ertes> it's invalid, because it forgot about the ForeignPtr it came from
17:37:44 <ertes> the Ptr from lockTexture does not originate from a ForeignPtr
17:37:46 <EvanR> during the callback to asCString ?
17:38:08 <EvanR> cant be right
17:38:12 <ertes> it would have been safe, if you only used the MVector from *within* the callback
17:38:18 <ertes> or rather the Vector
17:38:34 <EvanR> futuractively unsafe
17:39:35 <EvanR> ok that was 2 hours trying to get cairo picture on the screen wasted
17:40:49 <Welkin> just get a triangle
17:40:57 <Welkin> that's as far as I got with raw opengl
17:41:02 <Welkin> a colored triangle
17:41:06 <ertes> at least you have a rock-solid proof that GHC is amazing at memory management =)
17:41:25 <EvanR> i noticed
17:41:38 <EvanR> "aaaand its gone"
17:41:43 <c_wraith> Welkin: was each vertex a different color?
17:41:48 <Welkin> c_wraith: yes
17:41:50 <c_wraith> nice
17:42:08 <ertes> Welkin: did you use glBegin?
17:42:17 <Welkin> no
17:42:21 <Welkin> I used shaders
17:42:28 <EvanR> i want to play an opengl game made entirely a cheesy tutorial objects
17:42:29 <ertes> then nice =)
17:42:41 <EvanR> like cat on cube
17:42:52 <ertes> monkey in a pot
17:42:56 <EvanR> bump mapped teapot
17:43:31 <Welkin> suzanne the monkey
17:43:47 <Welkin> I've never loaded a model in o.o
17:43:50 <Welkin> that would be exciting
17:44:32 <michalrus> Hey, in classy-prelude, how should I do Map.fromList?
17:45:04 <Welkin> there are tons of models here that I just found https://www.blendswap.com
17:45:06 <Welkin> and lol
17:45:11 <Welkin> suzanne the monkey -- on fire!
17:45:13 <Welkin> https://www.blendswap.com/blends/view/4891
17:47:05 <lyxia> michalrus: I think you just get it from containers
17:47:27 <michalrus> OK, thanks. :)
17:48:29 <ertes> i was wondering…  how bad is the technical debt of using a different prelude?
17:48:56 <michalrus> Isn’t it the other way round? (:
17:49:01 <c_wraith> depends on how different it is.
17:49:13 <c_wraith> If it's just a lot of extra imports, no big deal
17:49:13 <Welkin> or just don't bother with the prelude
17:49:21 <Welkin> and just import directly what you need
17:49:38 <Welkin> classy-prelude uses its own weird libraries
17:49:41 <Welkin> like mono-traversable
17:50:00 <ertes> i'm thinking of preludes that actually change stuff like the class hierarchy
17:50:35 <Welkin> like some kind of hold-out from before the AMP?
17:50:42 <c_wraith> I mean, I've used an enhanced prelude that just did a bunch of imports that were used everywhere.  That was nice.  I wouldn't use something that actually did weird stuff.
17:51:04 <ertes> i would expect those to have massive interoperability issues with 99% of hackage
17:52:35 <c_wraith> Funny fact - when the group I was with did that, we didn't use an alternate prelude package or the NoImplicitPrelude extension or any special imports.  We just created a module named Prelude in the binary's package
17:53:24 <ertes> cabal uses that one, if it exists?
17:53:31 <lmapper> Hi, I've spent the better part of today trying to find a good way to call arbitrary functions from a runtime defined config schema (like json etc)
17:53:34 <c_wraith> GHC does, I think.
17:53:40 <geekosaur> ^
17:54:55 <lmapper> I've looked into Data.Reflection, etc, but not sure how to organize it yet
17:55:06 <louispan> Hi guys, I'm playing around with implementing a polymorphic variant (called Many), and I'm stuck with finding good names for operations.
17:55:06 <louispan> I have a function of type 'Many xs -> Many ys' where xs and ys are a type list of possible types, and ys is strictly larger than xs. What should I call this operation?
17:55:08 <c_wraith> I don't think Reflection is what you want anyway
17:55:09 <louispan> It's a bit like including another "sample space" of possibilities to the original sample space. Is there a word like "union" (which is too general) but with probability connotations?
17:55:23 <louispan> I find I spent half my time thinking of good names instead of coding!
17:55:41 <Welkin> louispan: just use random sequences of chinese characters
17:55:46 <iqubic> What is the Many data type even for?
17:56:20 <louispan> iqubic: I'm intending to use it in my widget library
17:56:30 <lmapper> @c_wraith Yeah, I came to realize that, but I'm not sure which direction to go
17:56:30 <lambdabot> Unknown command, try @list
17:56:41 <iqubic> @list
17:56:41 <lambdabot> What module?  Try @listmodules for some ideas.
17:56:47 <iqubic> @listmodules
17:56:47 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
17:56:47 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
17:56:54 <Welkin> @list slap
17:56:54 <lambdabot> slap provides: slap smack
17:57:00 <Welkin> @slap iqubic 
17:57:01 <lambdabot> stop telling me what to do
17:57:06 <Welkin> @smack iqubic 
17:57:06 * lambdabot karate-chops iqubic  into two equally sized halves
17:57:07 <louispan> where if I have a Foo that knows how to handle a FooAction, and a Bar that knows how to handle BarAction
17:57:20 <iqubic> Welkin: I don't like you
17:57:26 <lmapper> I'm rebuilding something I've built before in python, and was trying to find a replacement for this kind of runtime evaluation of arbitrary functions without a lot of boilerplate
17:57:40 <louispan> I want to be able to do "Foo + Bar" and get somethign that knows how to handle FooAction and BarAction 
17:57:53 <iqubic> @list unlambda
17:57:53 <lambdabot> unlambda provides: unlambda
17:57:55 <c_wraith> lmapper: the hint package might do what you want, though it's a bit... technical.  You have to be very explicit about what you want it to do or it just fails.
17:58:41 <ertes> lmapper: technically there is no other way than to actually enumerate all the functions you want to be able to call, unless you bring in GHC itself as a dependency
17:58:48 <lmapper> that's basically a ghc interpreter right
17:59:04 <ertes> lmapper: yes, hint is a high-level wrapper around the GHC API
17:59:51 <ertes> lmapper: if you don't want to have GHC as a dependency, you can probably use template haskell in some way
18:00:29 <iqubic> :t fromIntegral
18:00:31 <lambdabot> (Num b, Integral a) => a -> b
18:02:15 <c_wraith> lmapper: if you can do it, I recommend going with ertes's suggestion. :)
18:02:36 <c_wraith> using the ghc api has some unpleasant consequences.
18:02:51 <c_wraith> (like your program only running on computers with ghc installed)
18:03:02 <lmapper> I am happy to investigate, just looking for a good direction to start exploring
18:03:28 <ertes> lmapper: there is another approach: do what xmonad does: xmonad is not actually a window manager, but a library that provides a window manager framework
18:03:40 <ertes> a "configuration" is not actually a configuration file, but a program that uses xmonad as a library
18:03:51 <lmapper> @c_wraith hmmm.. that might not work then, it will need to be able to run on some arbitrary server
18:03:52 <lambdabot> Unknown command, try @list
18:03:55 <EvanR> success...
18:04:23 <c_wraith> lmapper: yeah.  See if you can use TH to automatically build a name -> function mapping at compile time instead.
18:04:58 <ertes> lmapper: caveat of that approach: it will not be JSON…  if you can live with that, it's a very easy way to do it
18:05:15 <c_wraith> ertes: it does also require ghc to be on the computer running the program again. :)
18:05:27 <c_wraith> well, if you want to make config changes, anyway
18:05:39 <ertes> c_wraith: only if you also do the built-in "configuration reload" stuff that xmonad has
18:06:05 <c_wraith> ertes: no, you need ghc to change the config at all, dynamic or not
18:06:24 <ertes> of course, but you don't need it on the target machine =)
18:06:36 <lmapper> I'd really like to get something like a plugin architecture working, where the framework doesn't have to change for additional functionality
18:07:16 <ertes> lmapper: i have a bunch of applications where i need to replace parts at run-time from time to time…  i found the easiest way to do that to be just separate programs that communicate through sockets/pipes
18:07:20 <EvanR> haskell does have some sort of dynamic loader
18:07:44 <EvanR> but if anything goes wrong, your framework is no more
18:08:02 <ertes> lmapper: i.e. back to the (unix) roots…  it's also what postfix does, and i like that kind of separation =)
18:08:33 <EvanR> its like treating your OS like the erlang VM
18:08:42 <ertes> BTW, i use s6 as the process supervisor, which works very well for this
18:08:51 <ertes> yeah, exactly
18:09:02 <lmapper> @EvanR are you referring to  dynamic library loading (c based, .so)
18:09:02 <lambdabot> Unknown command, try @list
18:09:35 <ertes> honestly i would stay away from dynamic loading of haskell libraries…  it's kinda difficult to ensure binary compatibility
18:09:56 <c_wraith> unless you use the ghc api
18:11:12 <EvanR> lmapper: yes
18:11:19 <EvanR> but not C bassed
18:11:55 <EvanR> you lose a degree of type safety, assuming you get it to work at all
18:12:15 <EvanR> so in that sense its kind of not better than another process
18:12:17 <lmapper> I probably won't go that route for now, was hoping to attempt it within the haskell language at first
18:12:34 <EvanR> the dynamic loader is exposed through haskell
18:13:29 <EvanR> i am using a separate, 15 line haskell program as a part of my project
18:13:49 <EvanR> its so working and finished, its been running non stop, doing its job, for a few weeks now
18:14:18 <EvanR> while the rest keeps rebuilding and rebooting, calling on it
18:14:29 <ertes> the separate process route is really not that bad
18:14:31 <EvanR> (but still works if that small program isnt running)
18:14:43 <ertes> you can do automatic serialisation easily in haskell
18:15:02 <ertes> in fact i would even use JSON or some other text-based format…  that makes it easy to debug as well
18:15:02 <EvanR> haha im just using getLine and pattern matching on strings
18:15:27 <lmapper> Yeah, I already have a was planning on using a JSON schema
18:15:33 <lmapper> oops
18:15:39 <ertes> also you get a taste of what high-availability programming feels like…  you need to be prepared for a process to shut down at any time =)
18:15:43 <lmapper> Yeah, I already have a JSON schema for a front end
18:16:09 <lmapper> I was hoping to call functions in haskell based on the content of the JSON
18:17:15 <lmapper> for now I can limit it to predefined functions, but it would be nice in the future if users could define additional functionality at runtime that plugged in
18:19:05 <lmapper> another issue, I was trying to maintain a collection (list, map, etc) of these functions, however the types and parameters are different
18:19:38 <lmapper> so I was looking into heterogenous collections, but apparently they are not very frequently used in haskell
18:20:05 <Cale> Perhaps you want a GADT?
18:20:12 <lmapper> so it led to an investigation into GADTs
18:20:46 <lmapper> I imagine so, however I'm still trying to grasp what exactly a gadt is
18:20:52 <Cale> We use a GADT for the requests which get sent from our frontend to the backend, indexed by the type of response expected.
18:21:35 <Cale> A GADT is like the algebraic data types you might already be familiar with, except that the type parameter can be specialised in the types of the constructors.
18:21:45 <lmapper> ok, it's good to know I'm on the right track
18:21:51 <Cale> So, for example, you can have some data constructor which produces a Request Integer
18:22:13 <Cale> and when you pattern match on a value of type  Request a
18:22:30 <Cale> and find this data constructor which must produce a Request Integer, you "discover" that a = Integer
18:22:56 <Cale> and so, for instance, if you have to produce some result of type a in response, you know that you're allowed to produce an Integer
18:23:13 <Cale> (inside that branch of the pattern match)
18:23:33 <lmapper> Does that work with constrained type classes (Num)=> etc also?
18:24:21 <Cale> If you mean what I think you do, then yes.
18:24:23 <lmapper> I tried to use Data.Dynamic today but found that I couldn't easily work with type constraints for Int and Double etc
18:25:40 <lmapper> Thanks, I'll keep investigating along these lines then
18:26:00 <lmapper> I have to go, thanks everyone for your help
18:31:05 * hackage qtah-cpp-qt5 0.3.1 - Qt bindings for Haskell - C++ library  https://hackage.haskell.org/package/qtah-cpp-qt5-0.3.1 (khumba)
18:39:54 <michalrus> c_wraith: https://ghc.haskell.org/trac/ghc/ticket/10920 :(
18:40:02 <michalrus> Did you have it solved, when using a custom Prelude?
18:41:12 <c_wraith> michalrus: Not really.  I think we may have used a custom .ghci file that loaded all the necessary files
18:42:02 <michalrus> Uh-huh… Can you have one per-project?
18:42:21 <michalrus> Yes. :]
18:42:21 <michalrus> OK
19:14:35 * hackage hedgehog 0.3 - Hedgehog will eat all your bugs.  https://hackage.haskell.org/package/hedgehog-0.3 (JacobStanley)
19:17:35 * hackage loup 0.0.3 - Amazon Simple Workflow Service Wrapper for Work Pools.  https://hackage.haskell.org/package/loup-0.0.3 (markfine)
19:27:39 <Clouth_> Hi?
19:30:15 <lambdabot> Hello.
19:41:27 <Clouth> hello
19:41:43 <Clouth> it's my frist time here
19:41:50 <Clouth> some one can help me?
19:41:57 <EvanR_> sure
19:42:02 <Clouth> hi
19:42:18 <EvanR_> first you have to ask a question
19:43:17 <Clouth> ok, how can I read a intenger from a user?
19:43:29 <EvanR_> :t readIO
19:43:30 <lambdabot> Read a => String -> IO a
19:43:58 <EvanR_> Integer is an instance of the Read class
19:44:03 <Clouth> lambdabot is a person?
19:44:06 <EvanR_> no
19:44:16 <geekosaur> but it can be operated by one
19:44:44 <Clouth> really? and it can answer my quiestions?
19:45:16 <EvanR_> in PM 
19:45:23 <Clouth> questions*
19:45:54 <Clouth> what do you mean whit PM?
19:46:12 <EvanR_> private message
19:46:44 <Clouth> ok, thanks
19:47:21 <Rotaerk_> I always wanted to be a lambdabot when I grew up, but they just had to go and automate my job
19:48:07 <Clouth> xD
19:48:29 <EvanR_> be happy they didnt automate the questions yet too
19:48:37 <glguy> When I grow up, I want to be a firetruck.
19:50:10 <Clouth> well I have a problem whit the IO type, I does not really understand how to interact whit the user, some one can explain me that?
19:50:41 <Clouth> or a good tutorial to read?
19:51:55 <EvanR_> try putStr "type a number> "
19:52:17 <EvanR_> then line <- getLine
19:52:32 <EvanR_>    then do something with line
19:52:34 <EvanR_> profit
19:55:09 <EvanR_> i would give you a link to an example main, but my internet doesnt work right now
19:59:10 <lpaste> iqubic pasted “IO example” at http://lpaste.net/356160
19:59:19 <iqubic> Something like that ought to work
19:59:30 <Clouth> thanks
19:59:57 <ertes> Clouth: to get a full understanding read this: https://www.vex.net/~trebla/haskell/IO.xhtml
19:59:58 <glguy> (show num*num) ===>  show (num*num)
20:00:28 <glguy> and then more ()s, so: putStrLn ("The square..." ++ show (num*num))
20:00:46 <ertes> Clouth: you will need it to use IO confidently
20:00:59 <glguy> iqubic: FYI you can use readLn in place of getLine and a read
20:01:06 <Clouth> well i have other question. how do you work whit haskell I mean rigth ny https://www.vex.net/~trebla/haskell/IO.xhtml
20:01:20 <EvanR_> :t readLn
20:01:21 <lambdabot> Read a => IO a
20:01:31 <Clouth> sorry
20:01:33 <iqubic> Clouth: You do know that it's spelled "with" and not "whit"?
20:01:37 <glguy> The difference is that it does the 'read'ing right away
20:01:37 <ertes> Clouth: i think you have a bunch of sentences mixed up there =)
20:02:09 <iqubic> glguy: Can I append a type annotation to readLn, like I would read?
20:02:47 <iqubic> And is said type annotation needed if the compiler can infer the type for me?
20:02:57 <EvanR_> not only that you might have to
20:03:09 <ertes> iqubic: readLn = read <$> getLine
20:03:12 <EvanR_> since the a might be ambiguous
20:03:15 <glguy> ertes: almost
20:03:22 <ertes> almost?
20:03:30 <glguy> as in not the same
20:03:42 <ertes> yeah, i got that much =)
20:03:45 <ertes> what's the difference?
20:03:56 <glguy> readLn throws an exception if reading fails
20:04:08 <ertes> ah, that's useful
20:04:10 <glguy> read <$> getLine gives you bottom
20:04:30 <EvanR_> readLn = getLine >>= readIO
20:04:49 <iqubic> What does readIO do?
20:04:59 <glguy> iqubic: read up
20:05:03 <iqubic> and is there such a thing as readLnMaybe?
20:05:09 <iqubic> That uses readMaybe
20:05:54 <glguy> no
20:06:43 <iqubic> So in that case I'd have to use getLine and readMaybe seperately, and then follow up with a case statement?
20:07:14 <iqubic> To check whether the read succeeded.
20:07:21 <EvanR_> no, youd write the function somewhere else reuse it
20:07:35 <iqubic> What function?
20:07:42 <EvanR_> the action youre describing
20:07:46 <iqubic> The readLnMaybe function?
20:08:00 <EvanR_> sure
20:08:24 <iqubic> readLnMaybe = readMaybe <*> getLine
20:08:34 <glguy> no
20:08:49 <iqubic> is there a way to make the return type of that be MaybeT IO a?
20:09:07 <glguy> :t MaybeT
20:09:08 <lambdabot> error:
20:09:08 <lambdabot>     • Data constructor not in scope: MaybeT
20:09:08 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
20:09:29 <glguy> :t Control.Monad.Trans.Maybe.MaybeT
20:09:31 <lambdabot> m (Maybe a) -> Control.Monad.Trans.Maybe.MaybeT m a
20:10:34 <iqubic> So how would I right the function of readLnMaybe :: MaybeT IO a?
20:10:44 <iqubic> s/right/write/
20:10:45 <ertes> iqubic: you can also use IO exception handling, but then it's not easy to tell parse errors from I/O errors
20:11:28 <iqubic> How does IO exception handling work? I've never fully groked exceptions in Haskell?
20:11:41 <EvanR_> :t try
20:11:42 <lambdabot> Exception e => IO a -> IO (Either e a)
20:12:12 <iqubic> Why is that not Exception e -> IO a -> ExceptT e IO a?
20:12:22 <EvanR_> Exception is a class
20:12:27 <iqubic> Why don't they use monad transformers?
20:12:35 <iqubic> Why is that not Exception e => IO a -> ExceptT e IO a?
20:12:47 <iqubic> sorry I meant to use the other type of arrow.
20:12:53 <iqubic> I mistyped.
20:13:09 <EvanR_> there is something like this in ExceptT, you asked about IO exceptions
20:13:58 <iqubic> Oh. I see.
20:14:07 <iqubic> What does Catch do?
20:14:12 <iqubic> :t catch
20:14:13 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
20:14:14 <EvanR_> time to check the docs
20:14:32 <EvanR_> Control.Exception has a lot of explanations of a lot of things
20:14:41 <ertes> iqubic: exception handling really needs to be built into IO
20:15:21 <iqubic> How good is this guide: http://book.realworldhaskell.org/read/error-handling.html ?
20:15:45 <ertes> if you would use a monad transformer, almost all I/O operations would use that monad transformer, and it would be the "de-facto IO"
20:16:09 <geekosaur> all the exception code in RWH is out of date, the exception system was redesigned between when it was written and when it actually appeared on bookshelves :/
20:16:11 <EvanR_> IOT you say
20:16:41 <iqubic> So I should not read that RWH chapter?
20:16:45 <EvanR_> that must be way i was so confused by exceptions when i read that book
20:17:07 <ertes> iqubic: the module documentation of Control.Exception is actually very good
20:17:14 <ertes> you should just read that
20:17:17 <geekosaur> yeh, extensible exceptions landed after it was written
20:18:11 <ertes> iqubic: read about Exception, SomeException, 'throwIO' and 'catch' here: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html
20:18:25 <ertes> iqubic: there is a lot more to IO exceptions, but those are the basics
20:18:41 <EvanR_> to actually recover from a certain of exception, `try` is usually easier
20:19:06 <iqubic> So the module says that SomeException is the root, but then the code says "Exception e => SomeException e".
20:19:19 <iqubic> That implies that Exception is actually the root
20:19:38 <iqubic> Oh, wait, Exception is a type class
20:19:50 <EvanR_> and SomeException is a type
20:19:52 <iqubic> SomeException is the root data type for Exception
20:20:18 <ertes> EvanR_: i tend not to recommend 'try', because in many cases it will introduce subtle async exception bugs
20:20:46 <ertes> catch* and handle* is the API to use, unless there is a good reason to use try*
20:21:04 <EvanR_> its usually easier to use ;)
20:21:22 <EvanR_> thanks to the way catch and handle are set up
20:21:58 <ertes> honestly i'd challenge that…  i doubt that in practical code there is really a real benefit in using 'try'
20:22:10 <EvanR_> if you get an async exception before, during, or after your session with try... youll crash
20:22:40 <EvanR_> since you were trying recover, thats that
20:22:49 <EvanR_> if you would rethrow, thats another story
20:24:17 <ertes> the trouble is with masking…  'catch' can distinguish between exception handling and regular program flow regions
20:24:24 <EvanR_> the same holds for using the catch family from async
20:24:49 <iqubic> Is it possible fo me to write a custom exception, and throw that?
20:24:50 <LordBrain> the topic is exceptions i see
20:25:02 <iqubic> LordBrain: It's an exceptional topic
20:25:11 <EvanR_> waiting, continuing normally, and recovering so as to continue normally should be interruptible
20:25:21 <ertes> to use 'try' safely you would have to use 'mask' explicitly, and that of course ruins the ease of 'try' to the point that it's worse than 'catch' =)
20:25:22 <geekosaur> iqubic, make a type and an Exception instance for it
20:25:24 <LordBrain> iqubic, yeah you derive the Exception class
20:25:34 <ertes> LordBrain: no, you don't derive
20:25:35 <iqubic> And is that all I need to do?
20:25:40 <LordBrain> well
20:25:44 <iqubic> I mean, you could
20:25:45 <LordBrain> i mean you use a deriving clause
20:25:51 <LordBrain> dont make a derived class
20:25:55 <ertes> data MyEx = MyEx …  deriving (Show)
20:25:58 <ertes> instance Exception MyEx
20:26:02 <LordBrain> oh
20:26:13 <LordBrain> i dont do it often, so maybe you cant use deriving?
20:26:27 <LordBrain> what happens when you use deriving?
20:26:32 <glguy> No, it's not "deriveable" without DeriveAnyClass extension
20:26:41 <ertes> you shouldn't derive it either
20:26:48 <glguy> but you shouldn’t derive it anyway, you should make an instance that implements displayException
20:27:34 <LordBrain> what happens when you use deriveanyclass and dont make that yourself?
20:27:43 <iqubic> But if the instance declaration is just "Instance Exception Foo", why can't you derive Exception?
20:27:50 <ertes> with DeriveAnyClass it's fine…  you get the same thing
20:28:16 <iqubic> Why would you need an extension to do that? Seems odd.
20:28:29 <ertes> but i recommend not to do that…  if for some reason you create an exception newtype, and you have GeneralisedNewtypeDeriving enabled, you will actually get a broken Exception instance
20:28:52 <LordBrain> iqubic, the deriving keyword used to be sugar reserved for only certain prelude classes
20:28:55 <ertes> the proper way is to write an empty instance
20:28:56 <glguy> iqubic: Because deriving clause doesn't mean "create an empty instance"
20:29:13 <glguy> and you don't want an empty instance, anyway
20:29:16 <iqubic> TIL you can derive Functor, Applicative, and Monad
20:29:17 <glguy> so it's moot
20:29:36 <ertes> iqubic: and Foldable and Traversable
20:29:44 <ertes> very useful to have those =)
20:29:47 <EvanR_> you dont want an empty Exception instance? what goes in it
20:30:15 <ertes> you may want to write your own displayException
20:30:45 <ertes> unless your exception type has an error message String anyway
20:30:48 <EvanR_> didnt even know that existed
20:30:56 <ertes> it's fairly new =)
20:31:03 <ertes> GHC 7.10 i think
20:31:16 <glguy> even if there's a String field, it's kind of sloppy to dump Haskell syntax to your user
20:31:32 <LordBrain> wellllll
20:31:34 <EvanR_> "userError"
20:31:42 <EvanR_> user: wtf?
20:31:43 <LordBrain> your user is a haskeller typically
20:31:48 <LordBrain> i mean
20:32:12 <EvanR_> whoa, Dynamic is an Exception?
20:32:26 <glguy> LordBrain: Sure, if you're your own user, then do whatever is easiest for you
20:33:13 <LordBrain> i think documentation is a higher priority than cleaning up exception display
20:33:31 <LordBrain> and since a lot of us dont get around to documentation, i should expect that most exceptions are dirty
20:34:04 <LordBrain> am i wrong?
20:34:10 <EvanR_> Void, ExitCode, lots of cool exceptions in here... for *me to use try on*
20:35:11 <EvanR_> LordBrain: well, you dont really need haskell docs for an application. but for polish youd certainly want to control what sort of crash your user would see should it happen
20:35:23 <EvanR_> and how
20:35:35 <LordBrain> i'm not so sure
20:35:54 <LordBrain> what you want is something a dev can see and fix quick
20:36:02 <EvanR_> like, chrome shows various kinds of error pages and not literally a C++ exception
20:36:03 <LordBrain> the user is just going to google it anyway
20:36:36 <EvanR_> if its really buggy and youre developing it maybe, but "for polish" you probably want something else. no user is going to show any developer
20:36:44 <iqubic> Wait, how can you have GHC only code?
20:36:51 <iqubic> Like throwTo
20:36:56 <iqubic> :t throwTo
20:36:57 <lambdabot> Exception e => GHC.Conc.Sync.ThreadId -> e -> IO ()
20:37:00 <EvanR_> or the user shouldnt have to show a developer
20:37:31 <LordBrain> i guess im thinking typically an exception reaching the user is a bug regardless
20:37:46 <EvanR_> you want to react appropriately to the top level exception
20:37:47 <LordBrain> but it all depends
20:37:57 <EvanR_> if all you know is "undefined" well, you dont have much choice
20:38:11 <EvanR_> if you want to show 5 different things, you need some information
20:38:55 <LordBrain> well if you are writing library code, lets assume, should the exceptions be user-friendly or dev-friendly? and how friendly at all?  enough to take you away from other priorities? convince me
20:39:01 <EvanR_> the dynamic type of the exception is part of that 
20:39:02 <iqubic> :t throw
20:39:03 <lambdabot> Exception e => e -> a
20:39:11 <iqubic> Where does the a come from there?
20:39:19 <monochrom> All these while you're fixated on error messages being merely strings, not even the possibility of including a picture, say.
20:39:25 <iqubic> You can't pull an a from the Void can you?
20:39:47 <EvanR_> LordBrain: sorry im assuming were writing an app!
20:40:19 <iqubic> monochrom: displayException can't show a picture
20:40:33 <EvanR_> emojis
20:41:02 <EvanR_> unfortunately, the atari bomb icon is not available
20:41:15 <iqubic> I'm still confused by the a in the type of throw
20:41:25 <EvanR_> you can read it as Void
20:41:41 <monochrom> My conclusion is that the exception is supposed to be dev-friendly only.
20:41:59 <monochrom> The dev is supposed to add a handler that actually talks to the user.
20:42:16 <LordBrain> yeah that seems more like my thinking too monochrom 
20:42:46 <monochrom> You don't even know that your exception is exposed to end-users, and what language they read.
20:42:50 <EvanR_> and hopefully puts detailed info somewhere else instead of giving it as a sheet of paper out a printer with instructions to walk it over to them, at users expense
20:43:32 <iqubic> EvanR_: Is that true? Where throw get an a from?
20:43:34 <monochrom> Indeed, internationalization anyone?
20:44:06 <EvanR_> actually
20:44:08 <EvanR_> > '💣'
20:44:10 <lambdabot>  '\128163'
20:44:23 <iqubic> EvanR_: I can't see that character
20:44:30 <EvanR_> it shows as a bomb here
20:44:40 <EvanR_> its really far in the astral plane though
20:45:18 <iqubic> I'm sure it is.
20:45:23 <EvanR_> on ATARI computers, on boot and other points you may see a number of bombs pasted across your display
20:45:25 <monochrom> such plane, so astral :)
20:45:53 <EvanR_> that meant certain death, but the number of bombs was the key to the explanation
20:45:55 <monochrom> Why did they show bomb icons?
20:46:11 <EvanR_> you have to count the bombs to know
20:46:29 <monochrom> Yeah but why not count the rabbits instead.
20:47:16 <EvanR_> probably easier to render in monochrome than a skull and crossbones, or rabbits
20:47:26 <iqubic> Bomb repersent doom and destruction and death.
20:48:03 <monochrom> They could do :( instead, even simpler.
20:48:30 <EvanR_> text would be quite small, this was real big bombs
20:48:44 <EvanR_> the size of desktop icons
20:48:46 <monochrom> Big unhappy face?
20:49:16 <EvanR_> that was mac
20:49:38 <monochrom> Yeah see, Mac got it right.
20:49:43 <iqubic> Why is try not a good thing to use?
20:49:55 <monochrom> try is the best thing to use.
20:49:58 <EvanR_> loaded question
20:50:51 <LordBrain> does try catch *all* exceptions?
20:50:59 <monochrom> Yes.
20:51:05 <iqubic> LordBrain: It can.
20:51:11 <glguy> all the exceptions of the type you are catching
20:51:16 <EvanR_> i think im going to mix metaphors and stick a number of bombs in a guru meditation as a last resort :)
20:51:17 <LordBrain> oh yes 
20:51:32 <monochrom> try and catch detect the same exceptions.
20:51:34 <LordBrain> so try is not bad, as long as you dont match it with SomeException
20:52:00 <LordBrain> well... or be wary of SomeException and make sure thats really what you mean
20:52:16 <monochrom> Could you draw a picture of a guru holding a bomb meditating?
20:52:22 <EvanR_> hehe waitCatch :: Async a -> IO (Either SomeException a)
20:52:49 <EvanR_> looks like they arent following that advance
20:52:51 <EvanR_> advice
20:53:12 <EvanR_> youll catch all exceptions whether you like it or not
20:53:27 <monochrom> No, you got it from the wrong perspective.
20:53:29 <LordBrain> well there are uses for SomeException
20:53:35 <glguy> EvanR_: The point of that function is to either get the exception that killed the async thread
20:53:39 <glguy> or the final result of the async
20:53:48 <monochrom> The thread is going to throw up whether you care about the exact exception type or not.
20:53:56 <monochrom> YOU NEED TO BE TOLD
20:54:01 <glguy> tell him, monochrom!
20:54:13 <EvanR_> it could have been written to give you Left for the e you want, or rethrow, like wait does
20:54:33 <EvanR_> and ertes's issue with async exceptions would be avoided here too
20:55:07 <monochrom> Hmm OK so use wait instead if that's what you want?
20:55:15 <iqubic> Is finally a good function to use?
20:55:16 <EvanR_> wait, and a catch?
20:55:27 <monochrom> Or maybe there is another function that does it already?
20:55:43 <MarcelineVQ> iqubic: sure
20:56:03 <EvanR_> nothings polymorphic in the exception in async
20:56:14 <iqubic> What does it do? Is it like the finally clause of a Java try catch block?
20:56:17 <MarcelineVQ> iqubic: what does it say?
20:56:24 <iqubic> It seems to be just like that.
20:56:35 <monochrom> OK, I agree it is more useful. Send a pull request.
20:57:15 <EvanR_> the type reconstruction seems to be an oddball way to control what gets caught
20:57:29 <EvanR_> that threw me for a loop when i was learning about exception handling
20:57:44 <LordBrain> hmm yeah its not intuitive
20:57:53 <monochrom> Well all emulations of OOP is going to be oddball.
20:57:54 <AminoSan> Hi
20:58:04 <EvanR_> extensible variants !
20:58:05 <iqubic> What is the point of catchJust?
20:58:25 <monochrom> Now go take a look at gtk2hs. Its type class hierarchy and existentials.
20:58:32 <MarcelineVQ> iqubic: what does it say?
20:58:57 <monochrom> Also some library that binds to Objective-C's libraries.
20:59:04 <iqubic> It seems like you could just use type annotations with regular catch, and just avoid catchJust
20:59:24 <EvanR_> objective-c is pretty oddball by itself
20:59:30 <iqubic> anyway I need to go eat dinner with the family. I'll be back later.
20:59:41 <monochrom> (Summary: It uses TH to generate the type class, the instances, the existential type, and instancing said existential type to said class.)
20:59:51 <EvanR_> o_O
20:59:58 <LordBrain> i'm not sure that exceptions are really correctly classified under the rubric of OO
20:59:59 <EvanR_> whatever works
21:00:16 <LordBrain> at least, thats not how i use the term
21:00:37 <monochrom> gtk2hs does the same thing, except by a homebrew program rather than by TH.
21:01:20 <monochrom> But still yeah, behold the widget class and the widget instances and the existential widget type that binds them all.
21:02:02 <monochrom> You kind of have to do this, at least at some low level, because that's what the underlying C interface expects.
21:02:19 <LordBrain> if i see code attached to data in a pattern where the code is like methods, i call that OO-like..
21:03:45 <monochrom> LordBrain: Exception systems tend to not use the data+procedure side of OO, but rather, the subtype side of OO.
21:04:01 <monochrom> SML's exception system does not escape this fate. 
21:04:47 <monochrom> In fact so much so that some SML programmers actually abuse its exception system for merely defining an open type hierarchy.
21:05:32 <LordBrain> there was an idea to it, i believe, a sort of theory, that everything should be data-centric... so functions should actually be attached to data... that idea is the heart of oo more than anything i think...
21:05:48 <LordBrain> not to say the word doesnt have a lot of other connotations
21:05:56 <monochrom> Well yeah but different people have different hearts.
21:07:04 <EvanR_> when a term gets as diluted as oo... you have to resort to something that stays true
21:07:13 <EvanR_> dot chains, oop means dot chains
21:07:19 <LordBrain> :)
21:07:22 <EvanR_> without spaces, unlike haskell
21:07:23 <monochrom> :)
21:07:27 <monochrom> @bot
21:07:27 <lambdabot> :)
21:07:56 <LordBrain> no EvanR, because doesnt objective c use something other than dot?
21:08:04 <EvanR_> and a program is IDE if and only if it has a play button
21:08:05 <LordBrain> those bracket things
21:08:31 <EvanR_> i honestly dont see how objective-c is oop in any way
21:08:42 <EvanR_> which is good for my theory
21:08:46 <LordBrain> i never got deep into objective c
21:08:49 <LordBrain> so i cant comment
21:09:00 <LordBrain> but my impression is it is oo
21:09:09 <EvanR_> tswhat i hear
21:09:25 <LordBrain> someone said it is small talks object system tacked onto c
21:09:38 <EvanR_> it doesnt seem like smalltalk at all
21:09:42 <LordBrain> but never learned smalltalk either
21:09:56 <LordBrain> i did a lot of c++ for a long time tho
21:09:56 <EvanR_> which doesnt have a type system
21:10:25 <LordBrain> but i've heard it argued c++ isnt really dynamic enough to be "true oo"....
21:10:37 <EvanR_> C++ has dot chains
21:10:39 <LordBrain> well it wasnt back when i was doing it
21:11:05 <EvanR_> it might be its only OOP feature
21:11:17 <LordBrain> what?
21:11:53 <EvanR_> C++ is kind of like a garbage collectorless functional language now!
21:11:54 <LordBrain> it has inheritance... even multiple inheritance and all sorts of flavors of inheritance... and encapsulation
21:12:04 <glguy> The topic of ObjC, C++, and OO aren't bad discussions, but they're offtopic in #haskell, continue it in -offtopic?
21:12:36 <EvanR_> finally, offtopic is recommended!
21:12:53 <LordBrain> as opposed to what? -blah?
21:15:28 <iqubic> Alrighty, I have dined and I am now back
21:17:50 <iqubic> Now, what's the difference between catch with a type annotation, and catchJust?
21:18:58 <iqubic> Why do we need catchJust if we have type annotations.
21:24:30 <iqubic> Well, I understand exceptions a whole lot better now.
21:26:33 <EvanR_> throwTo iqubic (toDynamic pi)
21:27:03 <c_wraith> iqubic: catchJust is for when you only want to catch a subset of exceptions of a specific type.
21:28:04 <c_wraith> iqubic: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#t:ArithException for instance - Perhaps you want to handle Overflows, but not the rest.
21:28:23 <c_wraith> iqubic: they're all the same type, so you can't distinguish them at the type level
21:31:31 <iqubic> How would you detect that something is an overflow error?
21:32:51 <iqubic> As opposed to a divideByZero error or something?
21:32:53 <ReinH> Look at the type.
21:34:25 <iqubic> How wold you inspect the type in code? How would you use catchJust to catch only Overflow errors?
21:34:41 <ReinH> Overflow is a constructor.
21:35:24 <iqubic> It is?
21:35:29 <ReinH> Look at the type.
21:35:45 <EvanR_> :t Overflow
21:35:45 <iqubic> Oh, so it is.
21:35:46 <lambdabot> ArithException
21:36:17 <iqubic> How does that help us with writing a catchJust for only Overflow errors?
21:36:19 <EvanR_> (what throw Overflow errors)
21:36:39 <ReinH> iqubic: Have you read the docs for catchJust?
21:36:56 <EvanR_> LossOfPrecision seems interesting, if was ever thrown
21:37:27 <ReinH> You give it a predicate that selects Overflow errors.
21:38:04 <iqubic> How would that predicate work?
21:38:08 <ReinH> case e of { Overflow -> Just Overflow; _ -> Nothing } or siilar
21:38:12 <ReinH> similar
21:38:19 <iqubic> Ah, that would work.
21:38:23 <iqubic> got it.
21:38:38 <AminoSan> Hi
21:39:12 <iqubic> Hello AminoSan.
21:42:54 <EvanR_> whoa. 
21:42:56 <EvanR_> :t assert
21:42:57 <lambdabot> Bool -> a -> a
21:43:16 <EvanR_> > assert False "fruit"
21:43:17 <lambdabot>  "*Exception: Assertion failed
21:43:18 <lambdabot>  CallStack (from HasCallStack):
21:43:18 <lambdabot>    assert, called at <interactive>:3:1 in interactive:Ghci1
21:43:34 <EvanR_> (it throws the sourcefile and line number)
21:44:09 <EvanR_> > error "fruit"
21:44:11 <lambdabot>  *Exception: fruit
21:44:25 <EvanR_> \o/
21:44:44 <glguy> EvanR_: Normal error has the same call stacks
21:44:51 <glguy> lambdabot just isn't showing it
21:44:57 <EvanR_> oh
21:46:20 <EvanR_> great
21:46:54 <EvanR_> so many things i heard about ghc 8, now i can experience them since stack did the installation for me on os
21:46:57 <EvanR_> osx
21:48:29 <EvanR_> :t error
21:48:30 <lambdabot> [Char] -> a
21:48:43 <EvanR_> error :: forall r. forall a. HasCallStack => [Char] -> a
21:49:02 <EvanR_> whats this r doing
21:50:28 <glguy>   forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r).
21:51:19 <glguy> So you can do stuff like: error "What does it all mean?" :: Int#
21:51:52 <EvanR_> TYPE uh uh... roles ?
21:52:11 <glguy> No, roles are to do with Generalized Newtype Deriving and parameterized data types
21:52:21 <glguy> But this is representation polymorphism
21:53:15 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#runtime-representation-polymorphism
21:55:44 <EvanR_> ok
21:55:57 <EvanR_> so this is what certain kinds were used for
21:56:25 <EvanR_> ? and ??
21:57:04 <EvanR_> or kind polymorphism didnt work on them so we have this now
21:57:15 <glguy> ? and ?? were in a similar space. They were previously for a sort of subtyping relationship of kinds to capture what you could do with the (->) type
21:58:07 <glguy> ? and ?? didn't replace the magic of (->), (->) is just silently magic now
21:58:13 <glguy> err, TYPE didn't replace*
21:58:37 <EvanR_> magic of (->)... which -> 
21:58:46 <glguy> The type (->)
21:58:56 <glguy> and the kind (->)
21:58:58 <glguy> it's all magic
21:59:01 <EvanR_> :k (->)
21:59:03 <lambdabot> * -> * -> *
21:59:10 <EvanR_> mkay
21:59:42 <EvanR_> i should make use of more magic, it gets tiring knowing all the answers
21:59:59 <c_wraith> You can make the magic unsilent by enabling the right extension
22:00:23 <glguy> c_wraith: Which extension reveals the magic of (->) ?
22:02:55 <EvanR_> We can thus say that -> has type TYPE r1 -> TYPE r2 -> TYPE 'PtrRepLifted
22:03:06 <EvanR_> oh no the magic is getting out
22:03:38 <EvanR_> is that type consistent with itself?
22:04:38 <glguy> I wasn't sure if all of the runtime reps were accepted on both sides of the ->
22:04:45 <glguy> (They might be, I'm just not sure)
22:05:01 <EvanR_> TYPE r1 -> (TYPE r2 -> TYPE 'PtrRepLifted)... 'anything' with the type of the form TYPE x can appear on either side of ->
22:05:37 <glguy> Ah, there we go :)
22:06:15 <EvanR_> position 1, check. inner position 1 check... return type check.... outer return type... check
22:06:23 <c_wraith> glguy: -fprint-explicit-runtime-reps
22:06:53 <c_wraith> That was surprisingly hard to look up, for what it's worth.
22:06:55 <glguy> c_wraith: I turned that on, but couldn't get :kind (->) to show the type
22:07:05 <glguy> err, the TYPE
22:07:38 <c_wraith> what ghc version?
22:07:44 <glguy> 8.0.2
22:07:50 <glguy> Is it perhaps changed in the 8.2.1 rc?
22:07:57 <c_wraith> http://lpaste.net/356161 is on GHC some GHC 8.2 rc
22:08:11 <glguy> (->) :: TYPE q -> TYPE r -> *
22:08:13 <glguy> yay
22:08:18 <cocreature> neat
22:08:31 <c_wraith> the filename claims it's rc2
22:08:41 <glguy> I just tried in rc2 and got the same
22:09:01 <c_wraith> well.  it appears we have the same rc2. :P
22:09:11 <EvanR_> type Type = TYPE PtrRepLifted
22:09:17 <EvanR_> type * = TYPE PtrRepLifted
22:10:53 <EvanR_> so what kinds are left
22:11:06 <EvanR_> is there only one level of *
22:11:56 <EvanR_> and now * literally means.... ptrlifted runtime rep
22:17:48 <EvanR_> is $'s magic simply that it is levity / runtime rep polymorphic
22:17:58 <EvanR_> or is there more
22:21:38 <cocreature> iirc it also has some magic for type inference with RankNTypes so you can easily use it with ST but I don’t remember the details
22:23:19 <cocreature> here are the details https://mail.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html
22:25:12 <tombert> anyone here?  I am a bit new to conduit;  I'm trying to take the command `ffmpeg -i mymovie.mp4 -f matroska -` and run it via the `shell` function;  When I try doing that, I get a runtime error: ExitFailure(-13)
22:25:52 <tombert> I"m trying to adapt this code: https://github.com/snoyberg/conduit/blob/master/PROCESS.md#conduit
22:28:30 <cocreature> tombert: can you show us the code you’re using?
22:29:06 <tombert> yeah
22:29:58 <tombert> https://hastebin.com/abolayipev.hs
22:30:04 <tombert> cocreature
22:32:27 <tombert> I'm sure I'm doing something a bit silly
22:32:36 <tombert> but I've never used conduit with console output
22:35:02 <EvanR_> "but they are all Too Jolly Complicated to live in GHC" ha
22:37:00 <EvanR_> if bas van dijk didnt notice this "should not be working but is" thing with $ in 2010, maybe no one would ever know $ is so magic
22:37:38 <EvanR_> spj: "feature not a bug"
22:38:26 <cocreature> tombert: the ExitFailure(-13) is probably coming from the last line where you are printing the exit code of ffmpeg. so ffmpeg doesn’t seem to like the arguments you’re passing to it
22:39:01 <tombert> which I'm ok with philosophically, but I ran that command in the command line and it worked fine
22:39:15 <cocreature> tombert: you might want to try printing stdout
22:39:45 <tombert> how do I go about doing that?
22:39:48 <tombert> the first argument?
22:42:42 <cocreature> tombert: try something like https://gist.github.com/cocreature/410f92423b3678f582050710f3352f13
22:45:02 <tombert> cocreature: you rock, that seems to have fixed it
22:45:12 <cocreature> tombert: when running this on my machine the error is “Unable to find a suitable output format for 'pipe:'” which seems to make sense
22:45:32 <cocreature> tombert: wait what? that shouldn’t have fixed it. it should just show you the errors from ffmpeg now
22:45:33 <tombert> yeah, I just realized that's a bit of an "undo shit for copypaste" mistake
22:45:43 <tombert> you need to have the -f matroska before the final -
22:46:02 <cocreature> ffmpeg options are black magic
22:46:19 <tombert> indeed
22:46:35 <tombert> I'm just getting proper output: <number> stuff now
22:46:38 <tombert> no errs anymore
22:46:59 <tombert> I'm not entirely sure what you did differnet
22:47:11 <cocreature> oh I just didn’t add the "-f matroska"
22:48:20 <tombert> ok, well, it's not 'err'ing anymore
22:48:25 <cocreature> great :)
22:48:33 <tombert> yeah, you are awesome, thank you so much!
22:58:10 <saurabhn_> in attoparsec, how do I match the string 'NULL' but make it return Nothing?
22:58:17 <saurabhn_> (newbie question)
22:59:49 <EvanR> so you want to do fmap (const Nothing) (string "NULL")
22:59:54 <EvanR> theres a shorthand
22:59:58 <EvanR> :t (<*)
22:59:59 <lambdabot> Applicative f => f a -> f b -> f a
23:00:02 <EvanR> :t (<$)
23:00:04 <lambdabot> Functor f => a -> f b -> f a
23:00:26 <osa1> saurabhn_: string "NULL" $> Nothing
23:01:13 <saurabhn_> https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec seems to have the following example -- (string "mouse"    >> return Mouse)
23:01:21 <saurabhn_> what's the difference?
23:01:35 <EvanR> same thing, different type class
23:02:07 <saurabhn_> okay
23:02:08 <EvanR> string "NULL" >>= const (return Nothing)
23:02:24 <saurabhn_> I can use $> OR >> right?
23:02:28 <EvanR> <$ or $> is the most concise
23:02:35 <EvanR> and general
23:03:04 <EvanR> you could also use <* or *> and pure
23:03:26 <EvanR> its bike sheddable!
23:04:04 <saurabhn_> YES
23:04:06 <saurabhn_> it worked
23:04:21 <saurabhn_> if it compiles, it works!
23:05:38 <saurabhn_> thanks!
23:14:31 <tangled_z> Hey! Anyone here use reflex-platform? 
23:14:57 <tangled_z> I'm trying to install reflex-dom-contrib but it's not allowing me to do so, and I'm not really experienced with nix so I'm not sure what's wrong
23:15:18 <glguy> Wow, like it said "I'm sorry Dave, I can't let you do that"?
23:15:51 <EvanR> i hate it when that happens
23:16:38 <tangled_z> No it's giving me an error about missing dependencies, but those dependencies are different to the dependencies on the github repo
23:17:10 <WhiskyRyan> Should I install Haskell on MacOS using the haskell-platform installer on haskell.org, stack, or homebrew?
23:17:33 <tangled_z> So presumably the nix package manager is getting an old version of the package? 
23:17:47 <glguy> Hard to guess; we can't see your screen.
23:17:52 <EvanR> WhiskyRyan: or this https://ghcformacosx.github.io/
23:18:12 <EvanR> honestly... if you have homebrew already set up... go ahead and try stack
23:20:36 <glguy> I prefer installing the GHC bindists for each version I need into my home directory, I don't install GHC at a system-wide level
23:21:01 <tangled_z> glguy: here's the output https://gist.github.com/zanzix/12ff430b179037d344992076a7a25b83
23:21:59 <WhiskyRyan> I see three options on homebrew: haskell-stack, caskroom/cask/haskell-for-mac, caskroom/cask/haskell-platform....  any recommendations? 
23:23:09 <glguy> WhiskyRyan: What are you using to learn Haskell?
23:23:55 <glguy> Haskell-for-mac is a standalone workbook environment. It's kind of in a category of its own http://haskellformac.com
23:24:19 <glguy> That would be quite an easy way to get started just trying out some Haskell, but it won't be good for making stand-alone applications and libraries
23:24:24 <WhiskyRyan> glguy: What do you mean by what am I using? My OS?
23:24:37 <glguy> Like a book, a course, an online tutorial
23:24:50 <glguy> The haskell-platform comes with stack, cabal-install, and ghc
23:25:05 <glguy> ghc's the compiler
23:25:49 <WhiskyRyan>    glguy: Oh.. I have a book
23:26:00 <glguy> Which book?
23:26:02 <tangled_z> the installation instructions are quite conflicting. the reflex-platform README says to install packages by adding them to package.nix, and the reflex-dom-contrib README says to install packages through using cabal 
23:26:27 <WhiskyRyan> glguy: LYAH
23:26:28 <tangled_z> (I normally use stack, hence my lack of familiarity with this issue)
23:27:23 <glguy> WhiskyRyan: Installing haskell-platform will give you a top-level ghci executable you can use as shown in the book
23:30:45 <WhiskyRyan> glguy: So i should brew cask haskell-platform? brew haskell-stack is a less complete package?
23:31:26 <glguy> Yeah, haskell-stack is a component of the platform
23:32:03 <WhiskyRyan> glguy: Thanks for your help.
23:39:48 <wilornel> Hey #haskell! On `cabal test`, I get "QuickCheck -any, contaiers -any, morse -any". Then, `cabal install --only-dependencies` tells me "All the requested packages are already installed:"....
23:40:09 <wilornel> So, what's going on there? It's only installing dependencies for the `executable`?
23:42:37 <wilornel> Ah.. http://blog.pangyanhan.com/haskell/2013-12-22-cabal-installing-test-dependencies.html
23:45:08 <wilornel> Any way I can import Main, the executable, in my tests?
23:46:27 <glguy> wilornel: you can move the stuff you want to test out of the executable stub and into your library
23:46:36 <glguy> then the tests can depend on that library
23:48:48 <wilornel> alrightm, working on it
23:50:33 <tangled_z> hmm, no one here uses reflex-platform? :/ 
