00:13:02 <nickkuk_> nshepperd cocreature jle`: I'm probably a bit silly, but I can't understand where to get KnownAttributes as => WithAttributes as (look at annotation in http://lpaste.net/356031)
00:14:14 <cocreature> nickkuk_: replace KnownAttributes as by WithAttributes as
00:15:07 <nickkuk_> Ok, but how to implement function withAttributes ?
00:15:59 <cocreature> nickkuk_: here’s what I came up with when I was playing with this earlier https://gist.github.com/cocreature/c53d8b81532fa330a9ca2edeca86b478
00:17:09 <nickkuk_> cocreature: I just wanted to do this ad-hoc type class invisible
00:17:41 <cocreature> nickkuk_: sorry I’m not following. what do you mean by ad-hoc type class invisible?
00:18:05 <cocreature> avoiding to use a WithAttributes constraint in the definition of withAttributes seems weird
00:18:31 <nickkuk_> <cocreature>: Ok, sorry for that :)
00:19:12 <cocreature> nickkuk_: you’re recursing using withAttributes so you need that constraint
00:21:16 <nickkuk_> cocreature: yes, I understand it now; just wanted to hide some type level stuff in library internals
01:40:38 * hackage heterocephalus 1.0.5.0 - A type-safe template engine for working with popular front end development tools  https://hackage.haskell.org/package/heterocephalus-1.0.5.0 (arowM)
01:44:12 <sphalerite> Am I right in understanding that Map a b is isomorphic to a -> Maybe b?
01:45:42 <Cale> sphalerite: Not quite. Consider for example a function such as \x -> Just x :: Integer -> Maybe Integer
01:46:21 <Cale> sphalerite: But you're right that it sort of the vague idea anyway.
01:46:23 <Cale> it's*
01:46:40 <sphalerite> Ah right, because functions can map any values while maps are always finite
01:47:05 <EvanR> theres total-map, but you still cant get as much as with a function
01:47:20 <Cale> yeah, you want just the "finitely supported" functions, i.e. those which only produce Just v for finitely many elements of the domain
01:48:09 <Cale> Also, there's a practical difference in that you're guaranteed to know which values in the domain are indeed sent to Just v for some v
01:59:50 <ejpcmac> Hello! I’m fairly new to Haskell, and I’m trying to figure how to get `stack install <x>` link dynamically the binaries it installs in ~/.local/bin/. I don’t feel too comfortable with theese so big binaries.
02:01:37 <ejpcmac> I tried to add `"*": -dynamic` in the `ghc-options` in the ~/.stack/global-project/stack.yaml, but stack keeps linking statically. Any idea?
02:13:35 <solrize> there was a package a while back that let users describe network packet formats as ascii diagrams that got parsed as haskell expressions... anyone remember what it was?  tx
02:15:10 <nickkuk_> ejpcmac: I've just tried to add "-dynamic" flag in executable ghc-options in cabal file (not in yaml) - it works
02:17:04 <lpaste> SepakoRayl pasted “Functorize” at http://lpaste.net/356038
02:19:15 <SepakoRayl> Guys any ideas? What I want is to fmap on different type parameters.
02:21:20 <SepakoRayl> Currently I am basically creating different typeclasses that mock Functor and Functor is then specialized using wrapper classes but I really wish I could somehow do this automatically.
02:24:20 <sphalerite> Is mappend for Map just defined as union? And where would this be documented? https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html I don't see anything to that effect on this page
02:25:04 <EvanR> well, it can be documented next to the instance Monoid in the haddock
02:25:19 <EvanR> but its usually not
02:25:44 <EvanR> in this case its "obviously" union
02:26:07 <EvanR> you can find out in the sources
02:26:35 <ejpcmac> nickkuk_: Where should I put it for a global configuration? In ~/.stack/global-project/.cabal ?
02:27:27 <pie__> i bet someone asks this every five minutes, but if you want to write an actually good gui in haskell what do you do
02:27:34 <pie__> afaik there arent any actually maintained gui libs
02:27:53 <EvanR> how do you write a good gui in another language?
02:27:55 <pie__> qt would probably be ones go-to choice but...
02:28:08 <EvanR> i wouldnt go to qt
02:28:09 <pie__> EvanR, by having a nice library with maintained bindings? (i guess?)
02:28:24 <pie__> sorry if i sound like im on the offensive
02:28:27 <EvanR> the issue there is C++, and is hugeness
02:28:30 <pie__> yeah
02:28:31 <EvanR> its*
02:28:52 <EvanR> ok to address your answer to my question, there are GTK bindings
02:28:59 <pie__> i just dont get what you guys do when you actaully want to do make something with respect to this
02:29:41 <EvanR> i was looking to get a more specific version of your question, and it sounds like you want a open source style desktop toolkit solution
02:29:42 <nickkuk_> ejpcmac: I didn't try do it globally.. Is it really good idea?
02:29:48 <EvanR> so theres GTK
02:29:59 <pie__> EvanR, im open to alternatives
02:30:07 <EvanR> theres a few alternatives
02:30:31 <pie__> "open source style desktop toolkit solution" what else could i have meant?
02:30:41 <EvanR> "GUI" who knows
02:31:01 <pie__> oh.
02:31:04 <EvanR> if you meant to ask about QT thats another story
02:31:46 <ejpcmac> nickkuk_: This is mainly for the packages installing binaries in ~/.local/bin. ghc-mod for example is 105Mo, which is big for a binary. It should be dynamically linked imo.
02:31:56 <EvanR> one alternative is ghcjs and a browser platform like electron or node-webkit
02:32:13 <EvanR> and some kind of FRP thingy like reflex-dom
02:32:23 <pie__> EvanR, yeah i was thinking about that though im not too fond of electron, but it might really be my best option
02:33:02 <pie__> id probably write the backend separately and use some kind of interprocess communication
02:33:12 <EvanR> another alternative is to write the GUI in native code on windows or osx or whatever target, and FFI or IPC your pure haskell to it
02:34:13 <pie__> right
02:34:24 <EvanR> supposedly people have used wxHaskell
02:34:30 <pie__> in which case you lose all the nice typey stuff :P
02:34:42 <EvanR> well, IO isnt that great there anyway
02:34:53 <pie__> well i could always use that as an excuse to try rust
02:34:55 <EvanR> you want to keep the outer shell of the program as thin as you can
02:35:23 <EvanR> also, people have used reactive-banana for toolkit programs
02:35:33 <EvanR> also, theres threepenny-gui
02:35:36 <pie__> though i doubt rust has qt bindings
02:35:49 <ejpcmac> nickkuk_: If static linking is the way to go in Haskell, let’s do it! But for binaries I use only in my own computer I find it useless to have a copy of the libraries in each binary.
02:36:09 <pie__> sorry, im being implicit, i kind of like qt because it does a lot of stuff and i have a little eperience with it, but re: im open to other stuff
02:37:12 <EvanR> https://www.reddit.com/r/haskell/comments/55t7e4/qtah_haskell_qt_bindings/
02:37:58 <pie__> ill check out the things you said
02:38:35 <pie__> there is some hype around frp but it does seem to me like the functional style might not be great for GUI stuff? (just going by the atmosphere of things)
02:39:15 <EvanR> from what i heard, anybody whos tried FRP for a gui program has liked it relative to doing GTK by hand
02:39:21 <pie__> heh
02:40:45 <EvanR> i had good experience writing a cocoa frontend in objective C and using pipe(2) to get input and spit out graphics
02:42:10 <EvanR> as far as functional style goes, toolkits just arent functional dont even try. the best you can do is dream up a nice language that is interpreted as a gui by something
02:42:35 <wilornel> Hey #haskell! I am trying out scotty right now
02:42:55 <wilornel> I have a simple `get "/" $ do { r <- getChar ; html "a" }`
02:43:20 <EvanR> one avenue on this front is "immediate mode gui" which is a C++ism, but could work in haskell
02:43:20 <wilornel> It seems like the <- wants 'Web.Scotty.Internal.Types.ActionT         Data.Text.Internal.Lazy.Text IO'. 
02:43:36 <wilornel> Is that the way monads work? Usually inside `main`, I can just do `r <- getChar` and it works
02:43:38 <pie__> EvanR, im just trying to put some effort into this because ive had enough with crappy unusable coder GUIs
02:44:05 <liste> wilornel: where do you want that char from? the console?
02:44:10 <liste> :t liftIO -- wilornel 
02:44:11 <lambdabot> MonadIO m => IO a -> m a
02:44:14 <EvanR> maybe you want to go with the browser then
02:44:27 <wilornel> ah, yeah with the console it does not make much sense
02:44:44 <nickkuk_> ejpcmac: hmm, this works for my project, but not for ghc-mod:   stack install ghc-mod --ghc-options="-dynamic"
02:44:45 <wilornel> what is a simple IO operation I could do ?
02:44:51 <nickkuk_> ejpcmac: I don't know, why
02:44:52 <wilornel> read from /dev/random
02:45:16 <liste> wilornel: you could do use putStrLn to log something to the console
02:45:38 <wilornel> put can I bind the result to r using ` r <- putStrLn "a"` ?
02:45:50 <liste> wilornel: no, there's no result
02:46:28 <wilornel> I see,, I'll try something with System.Random
02:47:08 <pie__> EvanR, ok, thanks for the advice \o/
02:48:23 <cdepillabout> What libraries would people recommend for working with regexes?  For instance, I want to write a command line application that lets the user supply a regex and then apply that regex to a file, similar to grep.  From looking on Hackage, it looks like some popular libraries are regex, regex-tdfa, regex-pcre-text, regex-do, etc.  Ideally I'd like something that supports PERL-compatible regexes.
02:48:41 <ejpcmac> nickkuk_: The documentation states it does not work with the command-line option for snapshots, so it seems normal. But it states about putting the option in the stack.yaml “setting options like this will affect your snapshot packages”, but it does not.
02:49:08 * hackage yesod-core 1.4.35 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.35 (MichaelSnoyman)
02:50:52 <cdornan_> either regex or pcre-heavy
02:51:47 <cdornan_> cdepillabout: regex or pcre-heavy for regexes
02:53:14 <cdepillabout> cdornan_: Thanks.  Do you have a recommendation between regex or pcre-heavy?
02:55:27 <cdornan_> cdepillabout: I wrote regex so I use that for myself -- I would have a look at the documentation and go with whichever you like best
02:56:40 <cdornan_> cdepillabout: do you need high prformance? Perl-style regexes? to match UTF-8 text?
02:57:07 <cdornan_> package selection will depend upon answers to those questions
02:58:18 <wilornel> Yeah, so it seems like inside a `do` block, all bindings need to respect the type of the do block?
02:58:57 <mreh> "Stack looks for packages in the directories configured in the 'packages' variable defined in your stack.yaml
02:58:57 <mreh> The current entry points to (snip)/.stack-work/downloaded/XW24gA73ppEH/ but no .cabal file could be found there."
02:59:05 <mreh> What does that mean?
02:59:58 <mreh> I specified "packages: - . ..." and it says this
03:01:28 <cdepillabout> cdornan_: In my case, I do not need high performance, but it wouldn't be bad to have.  I do need Perl-style regexes.  I do need to be able to match UTF-8 text.  I just took a look at pcre-heavy.  It looks simple enough but I'll checkout the regex library as well.
03:04:03 <cdornan_> right! performance and Perl probably indicate pcre-heavy; if UTF-8 is important then my advise is to check it out thoroughly 
03:04:48 <wilornel> Ah, is there a resource that explains to me how to go from one type of string to another? I have: "• Couldn't match expected type ‘Data.Text.Internal.Lazy.Text’ with actual type ‘bytestring-0.10.8.1:Data.ByteString.Internal.ByteString’"
03:05:25 <cdornan_> cdepillabout: as I have been finding out recently getting PCRE to work with UTF-8 is not straightforward
03:06:38 * hackage yesod-auth 1.4.17.2, yesod-test 1.5.6 (MichaelSnoyman): https://qbin.io/qugk5zl
03:07:26 <cdornan_> cdepillabout: regex with the TDFA backend works fine with UTF-8; performance is still quite decent  -- would only be an issue if regex processing is totally dominating your work
03:08:29 <cdepillabout> It looks like TDFA doesn't support PCREs?
03:13:40 <cdepillabout> cdornan_: Hmm, it looks like your regex-with-pcre package gives a nice interface around the pcre library?  I think that's basically what I want.
03:17:23 <ab9rf> \
03:18:08 * hackage typesafe-precure 0.3.1.0 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.3.1.0 (igrep)
03:19:02 <kawa_> Hi! Quick question from a newbie, on Haskell Platform, why do I get an error when I try to make a type declaration?
03:19:25 <kawa_> e.g. Prelude> removeNonUppercase :: [Char] -> [Char]  <interactive>:64:1: error:     • No instance for (Show ([Char] -> [Char]))         arising from a use of ‘print’         (maybe you haven't applied a function to enough arguments?)     • In a stmt of an interactive GHCi command: print it
03:19:33 <ab9rf> please use a pastebin for that
03:20:05 <EvanR> the error says no Show instance for function type
03:20:19 <kawa_> Yes I see that, what does it mean?
03:20:35 <EvanR> in ghci it tries to print the last value
03:20:53 <kawa_> I'm currently following: http://learnyouahaskell.com/types-and-typeclasses
03:20:53 <EvanR> but it needs Show implemented on the type to do that
03:21:05 <kawa_> Oh, so what should I type instead?
03:21:12 <EvanR> and a -> b doesnt have it
03:21:14 <kawa_> Or rather, how do you implement Show?
03:21:21 <EvanR> ah
03:21:32 <kawa_> But according to the tutorial you should always declare the type? I'm confused
03:21:53 <EvanR> instance Show MyType where show ... = ...
03:22:03 <ab9rf> can you just type type hints into ghci on the command line? i've never done that
03:22:18 <EvanR> > 5 :: Double
03:22:20 <lambdabot>  5.0
03:22:29 <ab9rf> yeah, i know you can hint a value
03:22:29 <kawa_> To be entirely honest I have no idea what i'm doing. the 5 :: Double things works though
03:22:33 <EvanR> kawa_: you dont need to always put that
03:22:41 <EvanR> > 5
03:22:43 <lambdabot>  5
03:22:51 <kawa_> How would I put it if I wanted to though?
03:22:59 <EvanR> you did it right
03:23:00 <ab9rf> hm, that kinda explains it actually
03:23:08 <EvanR> it just cant print out functions
03:23:12 <kawa_> Just confused why something that works for the tutorial doesn't work in ghci
03:23:25 <kawa_> > 5
03:23:27 <lambdabot>  5
03:23:33 <ab9rf> it tried to show "removeNonUppercase" but it's of a type for which there's no Show instance, so it complained
03:23:38 <EvanR> theres definitely a difference between typing things into ghci and putting the definitions in a source file
03:23:48 <EvanR> the tutorial probably wants you to put all this in a file
03:23:49 <kawa_> Oh, oops.
03:23:51 <ab9rf> that value hasn't been defined yet, either, but it can still decide that it can't be shown
03:24:01 <kawa_> Ah, so I have to compile it then?
03:24:12 <EvanR> well, put it in a file, then load the file in ghci
03:24:13 <ab9rf> yes, we'd normally do that in a file
03:24:19 <EvanR> when you edit it, reload it with :r
03:24:26 <kawa_> Oh cool
03:24:31 <kawa_> Thanks!
03:25:31 <EvanR> if you messed up the file somehow, :r will give you the errors
03:25:38 <alexbiehl> kawa_: you could also use multi line input in ghci: start multiline input with :{ put your definition and end with :}
03:25:39 <EvanR> which are good (tm)
03:26:33 <kawa_> Ah, thanks Alex!
03:34:33 <sphalerite> I see there's https://hackage.haskell.org/package/language-c for working with C code, is there something similar for C++?
03:35:44 <sphalerite> Or does nobody dare venture into the insanity that C++ is?
03:38:25 <xa0> why don't you make language-cpp
03:38:32 <xa0> be the guy
03:38:45 <sphalerite> But the insanity D:
03:38:55 <Myrl-saki> lol
03:40:32 <juri_> removing overlapping instances is hard.
03:43:38 * hackage typesafe-precure 0.3.1.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.3.1.1 (igrep)
03:44:50 <cocreature> sphalerite: I think we have bindings for the clang API which might be a good way to leave the insanity up to the clang guys
03:45:57 <ph88^> how do i let optparse-applicative check if an option INT is too small and give an error ?
03:46:38 * hackage HFitUI 0.1.1.0 - The library for generating a graphical interface on the web  https://hackage.haskell.org/package/HFitUI-0.1.1.0 (QSpider2017)
03:47:01 <jaspervdj> ph88^: You could use a custom ReadM which fails if the INT is too small
03:48:03 <jaspervdj> ph88^: Use `eitherReader` to create the custom one
03:48:21 <sphalerite> cocreature: oh yes, that could be useful. Thanks!
03:49:13 <pie__> EvanR, um im havint trouble installing qtah with stack
03:49:24 <ph88^> good idea jaspervdj 
03:49:25 <pie__> its complaining about not being able to satisfy dependencies...
03:49:38 <cocreature> sphalerite: there is https://hackage.haskell.org/package/clang-pure and https://hackage.haskell.org/package/LibClang but I haven’t used either so you’ll have to figure out yourself which one is better for your usecase
03:51:17 <pie__> heres the log: https://pastebin.com/raw/DF4JkD8b
03:59:21 <cocreature> pie__: are you using stack solver? that doesn’t look like a regular stack log
03:59:36 <pie__> yeah thats stack solver
03:59:45 <pie__> well i left out the other stuff but ill copy that too
04:00:04 <pie__> also lpaste is down?
04:00:36 <pie__> https://pastebin.com/raw/RBNBhPq3 , also im on nixos
04:02:21 <cocreature> pie__: I think after that error message it should try it with “soft constraints” or whatever it calls this. has this not happened?
04:03:41 <pie__> thats the whole message
04:03:59 <cocreature> are you running the newest version of stack?
04:04:42 <pie__> it says Version 1.4.0 x86_64
04:04:50 <cocreature> hm okay
04:05:25 <cocreature> not sure what’s going on here but you could just manually mess with extra-deps
04:05:39 <pie__> i tried but it blocked on directory
04:05:48 <pie__> mind you ive no idea what im doing so i mostly did what it told me to
04:06:06 <cocreature> if you show us the stack.yaml, your cabal file and the error message we might be able to help :)
04:06:07 <pie__> the wird thing is it was complaining about osmehting like needing to be between version 1.2 and 1.3 and it was 1.2.7 ....
04:08:00 <pie__> cocreature, https://pastebin.com/HdMFXq0u
04:08:14 <pie__> thats after copy-pasting in the dependencies it told me to get
04:08:43 <cocreature> pie__: add "directory-1.2.7.1" to extra-deps
04:09:08 <pie__> yay \o/
04:09:33 <pie__> i didnt do that because earlier it told me to try adding the other ones but it didnt say so for that...
04:10:25 <cocreature> pie__: the “latest applicable is X” usually means that while your current configuration doesn’t work, X would satisfy the constraints (or at least the one it’s looking at atm, I’m not sure if it considers all of them at the same time)
04:12:58 <pie__> ok
04:12:59 <pie__> thanks
04:13:15 <cocreature> pie__: you might also want to check if qtah works with process-1.5 and make a PR if it does to bump the upper bound
04:14:57 <pie__> man, nix stuff is great once you actually figure it out...
04:15:29 <pie__> all these tools just have so much machinery in them its overwelming how much you have to learn before you can even operate :I
04:15:43 <maerwald> pie__: alternatively, use simple tools :o
04:16:15 <pie__> maerwald, but then i actually have to know what im doing
04:16:25 <pie__> (oh the irony)
04:16:29 <maerwald> ...
04:16:47 <pie__> its skill trees all the way down
04:19:49 <_sras_> How can I use type applications to specify `a` in the function `fun1 :: (MonadIO m) => m a` ?
04:21:44 <cocreature> _sras_: fun1 @_ @a should work
04:23:34 <_sras_> cocreature: Yes it works.
04:23:36 <_sras_> Thanks
04:25:13 <quchen> glguy: Implemented your suggestion. I think it’s nicer.
04:26:37 <ocramz> hej all
04:29:01 <SepakoRayl> yo
04:31:32 <pie__> cocreature, awesome, it built. thanks again
04:31:37 <cocreature> pie__: np
04:32:57 <pie__> ok it built now i need to figure out how to get it to work :I
04:33:14 <ocramz> I'm a bit at a loss here; in base 4.9, why does a Semigroup instance require a Monoid instance? shouldn't it be the other way around?
04:33:37 <pie__> stack ghci gives: <command line>: can't load .so/.DLL for: /mnt/data/sync/Sync/haskell-swf/.stack-work/install/x86_64-linux-nix/lts-8.17/8.0.2/lib/x86_64-linux-ghc-8.0.2/libHSqtah-qt5-0.2.0-HFNOaiBhG8LdlW9tj8l2E-ghc8.0.2.so (libqtah.so.0: cannot open shared object file: No such file or directory)
04:34:31 <cocreature> ocramz: huh? Semigroup doesn’t have a Monoid constraint in 4.9
04:36:32 <ocramz> cocreature yes I see that; but I get this `• No instance for (Monoid (Count a))
04:36:32 <ocramz>         arising from a use of ‘Data.Semigroup.$dm<>’`
04:36:38 <ocramz> even before implementing the instance
04:37:12 <ocramz> cocreature : Count is `data Count a = Count { item :: a, num :: Int }`
04:37:23 <ocramz> I must be getting rusty
04:37:28 <maerwald> pie__: I tried qtah half an hour ago in a cabal sandbox, it installed without any trouble and I don't have borked linking
04:37:39 <pie__> :I
04:37:59 <cocreature> ocramz: I’m going to need to see some code here
04:38:10 <maerwald> afaik stack and cabal sandboxes don't interfere with each other, so you might just give that a try
04:39:06 <lpaste> ocramz pasted “No title” at http://lpaste.net/356042
04:39:17 <ocramz> cocreature ^
04:40:16 <owickstrom> ANN: I just published a blog about my explorations of tagless final style for an hspec-like testing EDSL, if anyone's interested: https://wickstrom.tech/programming/2017/06/05/tagless-final-encoding-of-a-test-language.html
04:41:04 <cic-31106> Do you think it’s possible to code a webcam streaming app for Raspberry Pi 3 in Haskell (focus for the project lies on safety; at the moment it’s planned to be in Python3)?
04:41:06 <cic-31106> What libs or modules might be helpful (similar to pygame-audio3 e.g.)?
04:42:25 <SepakoRayl> woo genifunctor seems to solve my problems
04:42:26 <cocreature> ocramz: Semigroup has a default implementation in terms of Monoid. if you provide your own it should stop complaining
04:43:13 <ocramz> aha! thanks cocreature :)
04:43:49 <cocreature> ocramz: it’s kind of confusing. I thought haddock showed the signatures of default implementations but apparently I’m wrong
04:44:04 <cocreature> oh it does
04:44:18 <cocreature> it’s just displayed so weirdly that I’ve missed it …
04:44:30 <the_2nd> How can I convert a lazy bytestring to a string?
04:44:34 <cocreature> *adds to list of things that I should fix if I have time*
04:44:43 <Iceland_jack> instance Semigroup (Count a) where (<>) = undefined
04:44:47 <cocreature> the_2nd: how is it encoded?
04:45:26 <the_2nd> cocreature, it is created with aesons "encode"
04:45:45 <ocramz> cocreature so IIUC ghc complains because one default implementation of mappend mentions Monoid?
04:46:05 <the_2nd> cocreature, https://hackage.haskell.org/package/aeson-1.2.0.0/docs/Data-Aeson.html
04:46:12 <cocreature> the_2nd: https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-Lazy-UTF8.html#v:toString
04:47:46 <cocreature> ocramz: you are not providing an implementation for <> so GHC uses the default implementation (https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Semigroup.html#Semigroup) which requires a Monoid constraint and sets <> = mappend. Count is not an instance of Monoid so GHC yells at you
04:47:56 <the_2nd> cocreature, I'm using the non utf8 import, tho
04:48:02 <the_2nd> can I still use this one?
04:48:09 <cocreature> the_2nd: yes
04:48:24 <cocreature> the_2nd: it doesn’t implement a different type. it just provides the encoding/decoding functions
04:48:29 <cocreature> and aeson encodes to utf8
04:49:00 <ocramz> aye, thanks again cocreature
04:50:00 <atodorov> hi folks, can I iterate over a list of function names (using a forM_ ) and call each one of them using the loop variable? I have a bunch of functions which accept the same number/types of parameters and in the edge case all of them will return Nothing so I'm looking for an easy way to describe the tests, instead of repeating the same block over and over again
04:50:47 <the_2nd> cocreature, working, thanks. Haskell is really great except for the string situation
04:51:23 <cocreature> the_2nd: the string situation is the main reason why I use protolude for most new projects :)
04:54:00 <cocreature> atodorov: what’s the type of the functions that you want to map?
04:54:50 <cocreature> atodorov: you probably want to use something like zipWithM instead of forM or zip your loop variables and functions first
04:55:55 <atodorov> cocreature: here's one example  findTag :: String -> [Tag] -> Maybe Tag, where Tag is a custom type
04:56:29 * ocramz : all hail Protolude
04:56:39 <lambdamu> Why defines the Storable instance for Bool 4 bytes? I was under the impression that _Bool is typically 1 byte
04:57:19 <wilornel> Ah, is there a resource that explains to me how to go from one type of string to another? I have: "• Couldn't match expected type ‘Data.Text.Internal.Lazy.Text’ with actual type ‘bytestring-0.10.8.1:Data.ByteString.Internal.ByteString’"
04:58:24 <lyxia> to go from ByteString to Text you use one of the decode functions in text
04:59:02 <cdornan_> cdepillabout (sorry got pulled) yes, that will give you Perl REs on UTF-8 and you can use it on Text too, but you will need regex-with-pcre-1.0.1.3 -- the latest -- but I am assuming you are not on Windows
05:00:10 <cdornan_> I have an issue open on PCRE with UTF-8 on Windows
05:00:18 <lyxia> wilornel: http://www.alexeyshmalko.com/2015/haskell-string-types/
05:02:11 <lyxia> atodorov: do your functions all return Maybe Tag
05:02:48 <atodorov> lyxia: not all of them, some return Mayeb String
05:03:33 <lyxia> does it matter what they return for your tests?
05:03:50 <lyxia> Maybe you only care about whether the output is a Nothing or a Just?
05:04:39 <nickkuk_> cic-31106: there is ivory edsl that do Haskell -> C. I've tried to use it to implement OpenGL application for Orange Pi PC, but it is VERY HARD to work with types from external C libraries.
05:04:40 <atodorov> lyxia: I care only if they return Nothing b/c I'm testing an edge case
05:06:05 <lyxia> atodorov: you can compose your functions with isJust so that they all have the same type
05:06:07 <cic-31106> nickkuk_: So you would rather advise me to do this particular project in Python with pygame libs?
05:08:53 <lyxia> lambdamu: encoding a Bool as an int makes interoperability with C much simpler
05:08:56 <nickkuk_> cic-31106: I haven't enough experience to advice something, just say that Ivory is hard for external libs. At now I do same application on pure Haskell + OpenGL ES + FFmpeg with hopes to compile hs RTS to ARMv7.
05:12:13 <cic-31106> nickkuk_: Thanks a lot!
05:12:32 <lambdamu> lyxia: How so? I'm having trouble right now because C thinks bool is 1 byte but haskell says 4
05:14:40 <lyxia> lambdamu: use int
05:17:09 <lyxia> perhaps they made this choice because there is no bool in older standards
05:19:09 <lambdamu> lyxia: I'd rather not fiddle with the c code im binding to
05:24:36 <lambdamu> So I made a newtype CBool, I'm not sure why don't have that in Foreign.C
05:25:41 <ab9rf> because there's no bool type in C
05:27:31 <SepakoRayl> guys any idea what "_ is not in the type environment at a reify" means? I am using the genifunctors library but I don't know much about template haskell.
05:27:33 <nickkuk_> ab9rf: there is _Bool in C99 and bool in stdbool.h
05:28:57 <ltielen> any good guides on handling exceptions/errors out there? I'm getting a weird error in my code and cant figure out whats causing it
05:29:10 <lyxia> SepakoRayl: it means that a TH function is asking for information about a type that doesn't exist
05:32:17 <geekosaur> lambdamu, because the FFI predates widespread support for stdbool in C compilers
05:32:32 <SepakoRayl> this makes no sense :(
05:33:07 <pie__> are there any tutorials for parsing binary files?
05:33:52 <SepakoRayl> ah I had to comment out the library calls
05:34:07 <SepakoRayl> now there are type errors that would not get reported
05:34:18 <ij> [x-post #nixos:] The code uses TemplateHaskell to call git to hardcode the version info. http://sprunge.us/HJXi I've added git to deps, but it still doesn't work, but it still doesn't find it. Ideas?
05:38:03 <lambdamu> ab9rf: that is wrong
05:38:54 <lambdamu> geekosaur: Sure but why not add it know to Foreign.C? I don't think that needs some special support
05:39:08 <lambdamu> s/know/now
05:39:29 <geekosaur> nobody has proposed it, and if they had added it at the time then using it would have just provoked type errors in C
05:41:39 <lambdamu> geekosaur: Maybe I'm misunderstanding, but is there anything special about the C* types apart from there Storable instance?
05:42:19 <geekosaur> yes, because the Storable implementation is the whole point
05:42:38 <geekosaur> the FFI has to know what memory layout to use to pass it to C
05:43:20 <geekosaur> specifically size which iirc is left undefined by the C standard (it's part of the ABI instead --- meaning it *must* be handled by the FFI)
05:44:50 <kuribas> I am getting: "No instance for (Data.Vector.Unboxed.Mutable.Unbox (Point Double))", but I do have instance V.Unbox a => V.Unbox (Point a) (Data.Vector.Unboxed as V).  Are these different?
05:45:18 <sproingie> i see Mutable in one and not in the other
05:46:55 <kuribas> I also have instance V.Unbox a => M.MVector V.MVector (Point a) where ...
05:48:19 <lyxia> they seem to be the same
05:49:25 <kuribas> strange ...
05:52:31 <sproingie> stab in the dark: orphan instance you forgot to import?
05:52:38 <sproingie> otherwuse dunno
05:53:42 <kuribas> no, it should be exported
05:55:07 <kuribas> it's here: https://hackage.haskell.org/package/cubicbezier-0.6.0.3/docs/Geom2D.html
05:55:23 <kuribas>  Unbox a => MVector MVector (Point a)
05:57:01 <lyxia> Are you using the right version
05:57:36 <kuribas> I think so...
06:00:09 * hackage servant-zeppelin 0.1.0.3 - Types and definitions of servant-zeppelin combinators.  https://hackage.haskell.org/package/servant-zeppelin-0.1.0.3 (martyall)
06:01:39 * hackage servant-zeppelin-swagger 0.1.0.3, servant-zeppelin-client 0.1.0.3, servant-zeppelin-server 0.1.0.3 (martyall): https://qbin.io/m9w0sdo
06:13:37 <Gurkenglas> How do I limit the memory available to ghci so leaks dont eat my machine?
06:14:06 <Gurkenglas> Wait, that's googleable. Sorry.
06:14:22 <bollu> I'm trying to understand STG
06:14:32 <bollu> specifically, how to trigger the update rule for function calls
06:14:33 <geekosaur> rts options, try ghci +RTS --help
06:14:43 <bollu> (rule 17)
06:14:48 <pacak> +RTS -M1g -RTS
06:15:14 <bollu> I want to construct an example where rule 17 occurs
06:18:14 <Gurkenglas> Ah, but how do I do it for the ghci that intero gives me? I think something that goes in a .ghci should work
06:20:52 <Gurkenglas> From stack ghci +RTS --help, it seems like a ghci command to edit the GHCRTS environment variable could work, but I see none such on https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-commands.html
06:24:05 <Gurkenglas> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-set.html might do something, but how do I correctly format the "+RTS -M2g -RTS" to be passed to :set?
06:24:18 <lyxia> it's part of the RTS options https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html
06:24:30 <lyxia> I don't think you can do that through :set
06:29:13 <lambdamu> Gurkenglas: I would try to set GHCRTS with an emacs mode hook before intero is started, after that you're out of luck I think
06:29:45 <Gurkenglas> Ooh, there's an "intero-repl-options" command. It doesn't seem to do anything though. Its description says https://i.gyazo.com/4dd6ca3d66152852f42298b2c381120e.png (it doesnt let me select that text huh)
06:31:21 <bollu> cocreature: ping
06:32:22 <lambdamu> Gurkenglas: that is not what you are looking for, but it would be easy to add customization variable for additional options, if you are willing to touch intero
06:47:09 <sproingie> Gurkenglas: you might need to set it via customize
06:47:16 <sproingie> M-x customize-group intero
06:47:46 <sproingie> wow it has no custom options.  nevermind.
06:49:04 <sproingie> oops forgot i autoloaded it.  nevermind the nevermind.  but alas it's still not a custom var.
06:49:10 <Gurkenglas> How do I abort computations running in ghci via intero in emacs? Ctrl-C doesn't work and neither does comint-quit-subjob
06:50:16 <Gurkenglas> And for some reason emacs slows hella down when one buffer contains "(Sum x, ())," for all x up to 66103
06:51:33 <sproingie> if the backend is hung up, a big hammer you could use would be intero-restart
06:52:15 <Gurkenglas> Frontend also mostly hung up at this point. Restart emacs I guess.
06:52:55 <sproingie> if triple-ESC doesn't give you the front-end back, then yah restart emacs
06:55:51 <Myrl-saki> Gurkenglas: C-g?
06:56:18 <Myrl-saki> Gurkenglas: If Emacs starts dying, I just spam C-g.
06:56:37 <sproingie> C-g is what you try first.  triple-ESC is emacs' hardwired "stop goddammit" signal
06:57:25 <sproingie> mostly good for getting out of minibuffers tho.  comint is still really good at wedging emacs hard
06:58:19 <abbradar> Hi all! I'm trying to make a type-safe "pub-sub" (a bad name for what I'm really trying to do but still) library but am stuck with partially applying type families. Not sure how to work around it and hope for some advice... Code incoming.
06:58:29 <lpaste> abbradar pasted “PubSub experiment” at http://lpaste.net/356045
06:58:52 <abbradar> The problem is that I want to partially apply Downstream and Handler -- I don't want to implement a custom Map for each of them
06:58:55 <abbradar> Is this possible?
06:59:16 <abbradar> (I know that partial application of type families isn't but maybe there is some clever trick to avoid specialized Maps)
07:02:43 <abbradar> For the record, even if I avoid using type-level tuples (making Handler a type synonym) partial application is still impossible for type synonyms
07:03:25 <geekosaur> you can defer some checks to use sites, but partial application is not possible in general
07:03:32 <geekosaur> at type level
07:03:53 <abbradar> geekosaur: you mean LiberalTypeSynonyms?
07:05:15 <lyxia> the clever trick is called defunctionalization
07:05:19 <geekosaur> abbradar, yes
07:05:55 <abbradar> geekosaur: sadly it doesn't help, yeah (use sites are not good enough)
07:06:04 <abbradar> lyxia: hm, I'm looking this up...
07:06:29 <abbradar> I see something in Data.Singletons, is this it?
07:06:36 <wilornel> Alright, I need some help understanding which variable /function is of the wrong type
07:07:26 <amf> is there a way to (outside of setting default extensions in .cabal) to turn on extensions like you can do the import Module as X trick?
07:07:46 <lambdamu> abbradar: Yeah they do that extensively
07:07:48 <amf> i know the answer is likely no, but i thought id ask in case someone came up with a clever way to do it
07:08:38 <abbradar> Hm, I think I understand the trick -- let me play with it a bit...
07:08:53 <lyxia> abbradar: here's Richard Eisenberg writing about it https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/
07:09:03 <abbradar> lyxia: awesome, thanks!
07:11:05 <lambdamu> abbradar: I was bored once and started translating the prelude to the type level, there is a lightweight example of it, http://lpaste.net/356046
07:12:00 <abbradar> lambdamu: yay, list functions! I'll most likely need those
07:12:59 <wilornel> So when the compiler says "expected type", it means the expected type of the argument, right?
07:14:01 <abbradar> wilornel: not necessarily of the argument, of anything I think
07:14:09 <abbradar> try `"aa" :: Char`
07:14:38 * hackage scientific 0.3.4.15 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.15 (BasVanDijk)
07:15:23 <wilornel> it's so confusing
07:15:38 <wilornel> Haskell types can be quite big
07:16:15 <bollu> @tell quchen I'd sent an e-mail to cafe about STG and transitions on rule 17. I was hoping you could maybe reply?
07:16:15 <lambdabot> Consider it noted.
07:17:23 <wilornel> so if I do `do { print "a" ; return "c" ; return "d"; } it should be possible, right?
07:18:18 <wilornel> so if I have `do { return (r ^. W.responseHeader "Content-Type") ; return "d" } `, it should also be possible? It's not doing anything, just running return, and then actually returning "d"
07:21:32 <abbradar> wilornel: I think you'd get something about an unused value
07:21:48 <abbradar> other than that, yes, should be possible
07:22:15 <abbradar> I think it would be desugarized to `print "a" >> return "c" >> return "d"`
07:22:55 <wilornel> alright, then what's the matter with this:
07:23:05 <abbradar> #undo do { return (r ^. W.responseHeader "Content-Type") ; return "d" }
07:23:14 <abbradar> hm, I thought it would work
07:23:28 <wilornel> http://paste.ubuntu.com/24783972/
07:23:28 <abbradar> @undo do { return (r ^. W.responseHeader "Content-Type") ; return
07:23:28 <abbradar>            "d" }
07:23:28 <lambdabot> <unknown>.hs:1:60:Parse error: EOF
07:24:10 <wilornel> it does not know what W is 
07:25:30 <abbradar> wilornel: I think you want `r <- W.get...`, not `r <- return (W.get...`
07:28:55 <wilornel> ok let me try that
07:29:18 <wilornel> it's not working
07:29:32 <wilornel> oh no, that line works fine!
07:29:41 <wilornel> the line that does not work is the one with W.responseHeader
07:30:44 <abbradar> wilornel: hm, it seems fine. what's the error message?
07:30:57 <wilornel> it's in the pastie
07:32:05 <abbradar> wilornel: the new one, it should be different now
07:32:29 <wilornel> the new one? 
07:33:03 <abbradar> when you fix `W.get`. currently you're trying to use a lens on `IO (Response a)` when it's meant for `Response a`
07:33:19 <abbradar> That's because you have not performed "get" actually (haven't taken value from IO)
07:34:02 <abbradar> `<-` does just that but `return`, hm, kills its effort. Sorry, I'm no good with explaining monads :D
07:34:20 <wilornel> wow wow yes this was unclear
07:34:25 <wilornel> so what do I want?
07:34:35 <abbradar> For example, let's consider `getChar`
07:34:38 <wilornel> The line with W.get works fine
07:34:48 <wilornel> the line with W.responseHeader is the one which does not
07:34:55 <sproingie> return would be double-wrapping it
07:35:18 <wilornel> fine I'll remove return
07:35:35 <abbradar> wilornel: Haskell is showing you the wrong line here, because it's the first line that shows actual problems
07:35:37 <wilornel>       (r ^. W.responseHeader "Content-Type")
07:35:43 <wilornel> so this ^ line returns a ByteString
07:35:53 <wilornel> hmmmm if I comment out W.responseHEader it all works
07:36:23 <abbradar> yep but then if you didn't remove the first `return` the code would actually do nothing
07:36:27 <abbradar> (no GET request)
07:36:40 <wilornel> with W.get?
07:36:51 <abbradar> because you've wrapped it with `return`
07:37:01 <wilornel> that line is fine
07:37:04 <abbradar> `return foo` would just return a wrap `foo` into a monad
07:37:08 <wilornel> yes
07:37:20 <wilornel> ok ok fine I comment out this line
07:37:24 <wilornel> I don't care about it
07:37:33 <abbradar> which one?
07:37:37 <wilornel> now I need to figure out       -- (r ^. W.responseHeader "Content-Type")
07:37:46 <wilornel> I comment out       -- r <- return (W.get "https://127.0.0.1:3000/")
07:38:06 <abbradar> try removing `return` there instead, it should work then with the second line too!
07:38:06 <wilornel> commented out*
07:38:23 <wilornel> ok ok so I don't care about the       -- r <- return (W.get "https://127.0.0.1:3000/")
07:38:28 <wilornel> because I commented out
07:38:37 <wilornel> Now I want to work with       -- (r ^. W.responseHeader "Content-Type")
07:38:44 <wilornel> commented it out *
07:39:00 <abbradar> okay, but you need to have some `r` to debug this line (if that's what you want)
07:39:06 <wilornel> ah right >.<
07:39:55 <abbradar> do { r <- W.get "foo"; a <- return (r ^. W.responseHeader "bar") } should work fine
07:40:09 <abbradar> but I think you don't even want to use `return` there, you can just use `let` instead:
07:40:22 <abbradar> do { r <- W.get "foo"; let a = r ^. W.responseHeader "bar" }
07:42:12 <wilornel> here: http://paste.ubuntu.com/24784108/
07:42:44 <abbradar> wilornel: ah, you have a monad transformer involved too
07:42:59 <wilornel> what is a monad transofmer
07:43:03 <wilornel> transformer
07:43:16 <abbradar> quick and dirty fix: `import Control.Monad.Trans.Class`, `r <- lift (W.get ...`
07:43:33 <abbradar> hmm, that's a "wrapper". it takes a monad (IO in that case) and adds additional functionality to it
07:43:53 <abbradar> I'd send you to a good article about them but I don't remember one
07:44:29 <abbradar> `lift` is a way to say "I don't care about the transformer, give me the monad that it wraps" (not actually but close enough)
07:44:41 <abbradar> transformer here comes from Scotty
07:45:47 <sproingie> think of lift as promoting one level up the monad transformer stack.  yes, lift is icky.
07:46:17 <sproingie> one of the reasons we have all-in-one stuff like RWS 
07:46:52 <peorio> Hi there, wondering if the wizard community has some wisdom to drop: I'm looking for a combination of `when` and `Maybe`. To wit: having some (Maybe Foo), I'd like idiomatically do `if (isJust x) then doSomething $ fromJust x else return (). Any ideas? I've seen some whenM, etc., but nothing convincing...
07:46:58 <sproingie> i've learned to love monads.  transformers not so much.
07:47:17 <c_wraith> peorio: I think you want traverse_
07:47:22 <c_wraith> :t traverse_
07:47:24 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
07:47:39 <c_wraith> peorio: where f = Maybe
07:47:50 <c_wraith> err, where t = Maybe
07:47:54 <c_wraith> f is whatever
07:53:14 <lyxia> peorio: pattern matching is more idiomatic than "if"   case x of Just y -> doSomething y ; Nothing -> return ()
07:56:43 <peorio> c_wraith: Many thanks! traverse_ seems right. 
07:57:07 <sproingie> pattern-matching on Maybe is typically an antipattern
07:57:26 <c_wraith> peorio: Don't forget to check instance lists for a type.  They often have a lot of gems in them.
07:57:48 <Gurkenglas> sproingie, is even maybe better than a pattern match?
07:58:31 <sproingie> it's like doing explicit recursion, there's usually some higher order thing you want instead
08:01:28 <geekosaur> disagree, because there's a key difference: direct pattern matching is strict, conbinators introduce laziness
08:01:30 <sproingie> tony morris wrote a good guide for scala.Option, but i haven't seen a haskell translation of it
08:01:45 <geekosaur> it may be true in languages that are not lazy-by-default
08:01:55 <lyxia> it's much less of an antipattern than "if isJust x"
08:02:17 <geekosaur> so this is an area where you cannot trust Scala understandings to work directly in Haskell
08:02:54 <lyxia> Pattern matching is low level but it's far from a bad practice.
08:03:21 <sproingie> obviously it's not a hard and fast rule
08:03:35 <geekosaur> in Haskell it can't be
08:03:48 <geekosaur> in Scala, pattern match and combinator have the same strictness so it likely comes down to comprehensibility
08:04:01 <geekosaur> in Haskell, laziness vs. strictness is a fundamental difference.
08:04:20 <ph88^> why do i get a type error here when i try a case on either ?   https://bpaste.net/show/779e246af06f
08:05:00 <geekosaur> ph88, because the <- 'evaluated' the Either for you
08:05:02 <geekosaur> r will always be the Right
08:05:08 <geekosaur> (a Left would have invoked fail)
08:05:51 <geekosaur> if you want to work directly with that Either instead of having the monad do it for you, use let instead of <-
08:06:03 <ph88^> oki
08:06:56 <geekosaur> or if you intended multiple levels of Either (that is, you wanted the type signature on line 3 to apply to "r" and not just the right side of the <-) then you need to put the type signature to the *left* of the <-
08:07:11 <geekosaur> and turn on ScopedTypeVariables to make it legal
08:08:13 <peorio> c_wraith: after playing a bit, traverse_ misses the mark since IO is not traversable (or I'm missing something..)
08:10:01 <Gurkenglas> IO is Applicative, not Traversable (or even Foldable). traverse_ specializes to (a -> IO ()) -> Maybe a -> IO (). For your example, you want "traverse_ doSomething x".
08:11:25 <ph88^> thx geekosaur i got it type checking now  https://bpaste.net/show/61970db3e7b8
08:12:42 <Gurkenglas> https://ro-che.info/articles/2017-06-04-universally-stateless-monads <- "The monad-control package allows to lift IO functions such as (...) allocate :: MonadResource m => IO a -> (a -> IO ()) -> m (ReleaseKey, a)" <- Does this mean it could be used to turn https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss.html#v:play into "playM :: MonadSomething IO m => Display -> Color -> Int -> m Picture 
08:12:43 <Gurkenglas> -> (Event -> m ()) -> (Float -> m ()) -> IO ()"?
08:13:06 <peorio> Gurkenglas: obv. you're right. The "f = Maybe" confused me. Thanks.
08:13:14 <Gurkenglas> *"-> m ()" of course
08:13:22 <Gurkenglas> instead of the -> IO () at the end
08:13:45 <quchen> cocreature: Have you tried the text-with-different-width a bit? How well does it work?
08:14:13 <bollu> quchen: ping
08:14:21 <quchen> bollu: pong
08:14:48 <bollu> quchen: I was trying to understand STG's rule 17
08:14:59 <bollu> quchen: can you give me a concrete STG program that triggers it?
08:15:04 <bollu> quchen: I asked this on haskell-cafe
08:15:05 <quchen> I have no idea what 17 is anymore.
08:15:12 <quchen> 18 and 19 were optimizations.
08:15:16 <bollu> quchen: yep, there's a question on cafe
08:15:19 <quchen> 17 was something umm obscure
08:15:19 <bollu> quchen: yeah
08:15:26 <quchen> STGi, help me!
08:15:30 <bollu> quchen: exactly, I'm not able to create a program that creates it :P
08:15:36 <bollu> s/creates/triggers
08:16:12 <quchen> There ought to be a test to do this
08:16:17 <quchen> Let me have a look
08:16:26 <bollu> quchen: I sent an email to cafe, so it would be cool if you would reply there, in case it helps others as well
08:16:38 <quchen> bollu: Did you read my docstring for rule 17?
08:16:59 <quchen> I think this is for programs where a lambda is produced as the result of an updatable closure
08:17:33 <bollu> quchen: how does one create a situation where that happens?
08:17:52 <quchen> Try: let x = 3 in \y -> y*x
08:18:07 <quchen> That’s just my first guess though
08:18:13 <bollu> quchen:  https://mail.haskell.org/pipermail/haskell-cafe/2017-June/127240.html
08:18:15 <bollu> hm
08:18:41 <quchen> I knew this once! Arrrr
08:20:53 <quchen> bollu: Hah! I have a test for for this
08:21:14 <quchen> https://github.com/quchen/stgi/blob/a82bc5c4f1acc2a4644344bdef1f604d330365ed/test/Testsuite/Test/Machine/Evaluate/Rules.hs#L325
08:21:55 <quchen> I really have spent more time on that project than I remember a year later now!
08:22:50 <bollu> quchen: xD thanks
08:23:09 <bollu> quchen: now tell me why that works? :P
08:23:38 <quchen> I think »flipTuple« is where it happens. It’s updatable (I write this as =>, instead of ->).
08:24:16 <quchen> So flip tuple is a CAF in the program by just looking at it. flipTuple is then forced by the »case« in line 330.
08:24:38 <quchen> But as you can see, »flipTuple« does not take any arguments – it has no free parameters
08:25:01 <quchen> So what needs to happen is that first flipTuple has to be evaluated, triggering an update, and then the result turns out to be a function
08:25:06 <quchen> And that’s what rule 17 does
08:25:12 <quchen> It’s the function update rule
08:25:21 <wilornel> thank you abbradar and sproingie 
08:25:45 <bollu> quchen: what's CAF?
08:25:54 <ZuluKing> Hey guys :) I have a quick question, how can I pattern match a complete record itself and not it's fields?
08:26:00 <quchen> bollu: »Constant Applicative Form«, a lambda form without free parameters
08:26:06 <abbradar> wilornel: you are welcome! does it work now?
08:26:09 <quchen> bollu: Something you can memoize, basically
08:26:22 <bollu> quchen: hm
08:26:32 <quchen> f x = x -- not a CAF
08:26:34 <bollu> quchen: so the rule "normalises" the function by flattening it?
08:26:36 <quchen> f = \x -> x -- CAF
08:26:54 <wilornel> abbradar: Almost!
08:27:07 <bollu> quchen: I don't understand, the former (f x = x) isn't even valid STG?
08:27:08 <wilornel> I have a [Char] and I want a Data.Text.Internal.Lazy.Text
08:27:14 <wilornel> pack does not quite do it (makes it text)
08:27:21 <menedemos> Why isn't there operator of type (b -> c) -> (a -> f b) -> a -> f c ? Writing composition with fmap is tedious and i always end up defining operator <$< = ((.).(<$>) so i can compose Functors with functions
08:27:40 <quchen> bollu: Well, the situation is this: the STG encounters a function call (in the case scrutinee), but it does not see any/enough argument frames.
08:27:53 <quchen> bollu: Instead, it finds a blocking update frame.
08:28:03 <quchen> So it performs the update, and then hops there is an argument frame beneath it.
08:28:45 <quchen> bollu: Remember that update frames are just blockers, and finding one instead of an expected return/argument frame triggers an update
08:29:15 <geekosaur> wilornel, then you need to import the pack from Data.Text.Lazy
08:29:17 <quchen> The other update rules are for returning (i.e. a return frame is expected, but there’s only an update frame); this rule is there for when an argument frame is missing.
08:29:23 <bollu> quchen: it's not that simple, right? because when we  update the function, we reduce the number of bound variables the function needs (some of them become free variables which are picked up from the update frame)
08:29:26 <geekosaur> there's a separate pack for strict and lazy Text
08:29:38 <bollu> quchen: I don't understand what that part does
08:30:00 <wilornel> And it works!!
08:30:04 <wilornel> thank you geekosaur 
08:30:32 <bollu> quchen: I will play around with your example and try to understand what is happening :)
08:30:34 <bollu> thanks for the help
08:30:41 <quchen> bollu: The function from my test is »flipTuple = \ => flip tuple«, which takes no arguments at all
08:30:51 <bollu> quchen: how do I run that example, specifically in STGi?
08:31:03 <quchen> bollu: »flipTuple = \x y -> flip tuple x y« would take arguments
08:31:50 <quchen> bollu: Copy the source into »prog« in Main.hs
08:32:28 <quchen> so it reads »prog = [stg|...|]« (and enable quasiquotes, any import the STGi’s quasiquoter module, it’s next to the parser)
08:32:34 <quchen> The run it :-)
08:32:56 <quchen> Or you can put it into ExamplePrograms.hs, which already has everything set up
08:33:18 <bollu> ah, cool :)
08:33:18 <bollu> thanks
08:33:21 <quchen> See the »implies« program, which is currently the default the STG uses when compiled without modification
08:34:04 <quchen> thanks to you for using the STGi :-)
08:35:21 <bollu> quchen: :)
08:35:25 <bollu> quchen: it's a neat reference
08:35:41 <bollu> quchen: I wish it had an interpreter mode as well
08:35:47 <quchen> Like a REPL?
08:35:58 <quchen> Yeah that would have been a lot more work unfortunately
08:35:58 <bollu> yep
08:36:02 <bollu> quchen: yeah, I know
08:36:09 <bollu> quchen: I tried making simplexhc REPLy
08:36:12 <quchen> Problem is for a useful REPL you need some sort of module system
08:36:16 <bollu> quchen: yeah
08:36:24 <bollu> quchen: I actually want to implement the GHC STG spec
08:36:31 <bollu> quchen: so I stuck to the paper notation
08:36:34 <quchen> There is a spec?
08:36:37 <bollu> quchen: I really like the STGi notation
08:36:43 <bollu> quchen: well, information syntax spec :P 
08:36:55 <bollu> quchen: I think they use whatever the paper uses + the eval/apply paper
08:37:00 <bollu> "making a fast curry"
08:37:10 <bollu> at least, that was my impression from a quick glance
08:37:14 <bollu> I could be wrong.
08:37:26 <quchen> The first paper has fairly clumsy syntax, the second (fast curry) has syntax not easily written on a keyboard
08:37:32 <quchen> So I created my own
08:37:38 <bollu> right
08:38:00 <bollu> I wanted to mimic the syntax by -ddump-stg or whatever it's called. It seemed to resemble the original syntax, so I just went with it
08:38:01 <quchen> Goal was to be as close to Haskell and the original paper as possible
08:38:05 <bollu> quchen: right
08:38:31 <bollu> quchen: would you be interested in implementing eval/apply for stgi? last I checked, it uses push/enter right?
08:38:34 <glguy> quchen: The ansi-terminal changes seem good
08:39:01 <quchen> bollu: I had a ticket open for it, but did not find out what exactly is different in eval/apply 
08:39:06 <glguy> quchen: Have you considered adding instance Traversable Doc?
08:39:12 <quchen> I read the paper multiple times and could not make sense of it
08:39:19 <quchen> glguy: Doc is not Foldable, unfortunately
08:39:20 <bollu> quchen: I see
08:39:27 <bollu> quchen: do you want to discuss this at zuriHac?
08:39:31 <bollu> quchen: try to take a crack at it? :P
08:39:35 <glguy> quchen: Oh, how come?
08:40:15 <quchen> glguy: https://github.com/quchen/prettyprinter/commit/c7881d437a3363dc2f1b68ece194741440d7f49c
08:40:17 <glguy> quchen: Oh, the Column
08:40:21 <quchen> glguy: Exactly
08:41:06 <quchen> glguy: SimpleDoc is Foldable though
08:41:10 <quchen> And traversable
08:41:38 <quchen> glguy: Folding a Doc does not really make sense anyway: you would collect all annotations, including those from alternative layouts
08:42:11 <glguy> It would just mean something different from folding the simpledocstream
08:42:39 <quchen> Right
08:42:48 <quchen> I’m not sure what it would be useful for, really.
08:42:52 <quchen> Luckily, I don’t have to worry ;-)
08:42:54 <glguy> But given that the structure of the document can vary arbitrarily due to column number then it makes sense that we can't traverse them
08:43:15 <glguy> It would be for making it possible to keep some state while transforming all of the annotations
08:43:23 <glguy> or using any number of lens operations on the annotations
08:43:45 <quchen> Hmmm. Okay, like gathering a set of all annotations used.
08:43:55 <quchen> »Is there red in any of the possible layouts«
08:44:12 <quchen> bollu: Sure, I’ll be there Thursday evening :-)
08:44:17 <bollu> quchen: it's still "Update by constructor return"
08:44:24 <bollu> quchen: isn't it from friday to sunday?
08:44:47 <quchen> Yeah but it’s a 4 hour drive that I’m not keen on doing on Friday mooooorning
08:45:27 <bollu> quchen: ah, I see
08:45:28 <glguy> quchen: Is it necessarily to have a function stored in the Doc type? How does the 'pretty' package get around this?
08:45:37 <bollu> quchen: I'll be around friday evening to sunday
08:45:47 <bollu> quchen: and thursday evening too, if there are people (?)
08:45:53 <quchen> glguy: Maybe by just not having that functionality :-s
08:46:31 <quchen> glguy: Yeah it can’t do that
08:46:32 <glguy> Oh, I didn't realize prettyprinter had extended the functionality. I thought it was mostly a modernization of the old layout package
08:46:46 <quchen> It’s based on ansi-wl-pprint
08:47:05 <quchen> Without the lambda constructors you can’t have »align«, which is very useful
08:47:08 <bollu> quchen: the example you have for rule 17 doesn't seen to use rule 17?
08:47:17 <quchen> bollu: Huh?
08:47:22 <bollu> oh wait, it is
08:47:25 <bollu> my bad :)
08:47:36 <quchen> bollu: The test checks one thing, and that’s that rule 17 is used :-þ
08:47:45 <bollu> quchen: xD
08:48:04 <bollu> quchen: imagine the horror if the test cradle were broken
08:48:24 <quchen> I’d prefer not to
08:49:55 <glguy> quchen: Next I need to make a prettyprinter-vty package
08:50:07 <bollu> does GHC not building on clang HEAD warrant a bug report?
08:50:28 <quchen> glguy: You mean to render a SimpleDoc into a VTY window? That would be cool
08:50:58 <glguy> Yeah, I should be able to annotate with vty's Attr in the same style of pp-ansi-terminal
08:52:39 <glguy> quchen: The ship has probably sailed, but this module prefix gets pretty long "Data.Text.Prettyprint.Doc"
08:52:49 <quchen> Yeah :-/
08:53:02 <quchen> I wanted it to be part of Data.Text and that’s where we landed
08:53:07 <quchen> .Render.Terminal
08:53:08 <quchen> :-x
08:53:26 <quchen> I mean it’s descriptive, but is also start looking like (half of) a Java module
08:54:14 <quchen> In reality, it’s about prettyprinting, and not about text at all! We could prettyprint to JPEG perfectly fine
08:54:18 <quchen> AAaanyway.
08:54:22 <quchen> Maybe for version 2.x :-
08:54:23 <quchen> )
08:56:58 <ReinH> quchen: that library looks cool
08:57:19 <quchen> ReinH: The prettyprinter? Thanks :-)
08:57:43 <ReinH> Nice to see something new in that space :)
08:58:01 <quchen> ReinH: Yes, because the world clearly needed another WL-prettyprinter! ;-)
08:58:20 <ReinH> I thought we had all collectively decided to stop thinking about it after Leijen.
08:58:24 * quchen secretly hopes to take over that space so we don’t have around 10 packages for the same thing anymore
08:58:59 <ReinH> Insert xkcd about standards here
08:59:02 <quchen> Problem is it is a bit of work to migrate properly, so it’s going to take some time
08:59:21 <quchen> ReinH: https://github.com/quchen/prettyprinter/releases
08:59:26 <quchen> Scroll to »official release«
09:00:15 <ReinH> Amazing.
09:00:46 <ReinH> quchen: you need some sort of feature matrix
09:00:54 <ReinH> so you can advertise all the boxes you check
09:01:06 <ReinH> make sure to conveniently omit boxes you don't check
09:01:23 <quchen> No need, I check all the boxes
09:01:24 <bollu> ReinH: [made by me   x] 
09:01:36 <ReinH> bollu: eh?
09:01:47 <bollu> ReinH: the feature matrix for a library that does nothing :P 
09:01:56 <bollu> ReinH: I'm just being stupid, don't mind me.
09:01:58 <ReinH> quchen: yes, you do, by cunning use of omitting the boxes you don't check :D
09:02:03 <bollu> ReinH: "me = quchen" in that context
09:02:13 <ReinH> bollu: oh yes jolly good
09:02:26 <bollu> quchen: I really like your way of implementing transitions. Mine is a StateT of mess.
09:02:27 <ReinH> "makes toast X"
09:02:32 <bollu> quchen: I should switch to your method
09:02:37 <ReinH> bollu: example?
09:02:50 <ReinH> quchen: there are an infinite number of features your library doesn't provide :p
09:02:53 <bollu> ReinH: https://github.com/quchen/stgi/blob/a82bc5c4f1acc2a4644344bdef1f604d330365ed/src/Stg/Machine/Evaluate/ValidTransitions.hs#L7
09:02:56 <menedemos> Why isn't there operator of type (b -> c) -> (a -> f b) -> a -> f c ? Writing composition with fmap is tedious and i always end up defining operator <$< = ((.).(<$>) so i can compose Functors with functions
09:03:05 <quchen> bollu: Mine is StateT without StateT but explicit lambdas instead ;-)
09:03:15 <bollu> quchen: yes, but I like it that way somehow xD
09:03:16 <ReinH> menedemos: isn't that fmap . fmap?
09:03:33 <bollu> ReinH: mine looks like this: https://github.com/bollu/simplexhc/blob/master/src/StgMachine.hs#L441
09:03:35 <ReinH> or flip fmap . fmap or something
09:03:41 <bollu> note to self - do NOT use lens unless you need it 
09:03:54 <ReinH> (.) is fmap, fmap is fmap
09:04:02 <menedemos> ReinH: No. It's (func <$>). functor
09:04:19 <ReinH> menedemos: but (.) is fmap
09:04:29 <Gurkenglas> bollu, returnStackEmpty <- uses returnStack null
09:04:32 <menedemos> ReinH: ReinH: No. (.) is composition
09:04:34 <bollu> I wish someone had a talk or a tool that showed you how to rewrite intermediate stuff with null
09:04:39 <ReinH> bollu: as your program increases in size, the probability of using lens tends towards 1
09:04:46 <bollu> Gurkenglas: ah
09:04:48 <bollu> Gurkenglas: thanks
09:04:50 <ReinH> menedemos: yes, and it's fmap for ((->) r)
09:05:04 <ReinH> :t fmap succ succ
09:05:05 <lambdabot> Enum b => b -> b
09:05:11 <ReinH> :t succ . succ
09:05:12 <lambdabot> Enum c => c -> c
09:05:17 <bollu> Gurkenglas: I later found out "uses" exists after googling for "project state"
09:05:36 <bollu> Gurkenglas: I've found that haskell docs are easier to navigate the more math-y you phrase things :P
09:06:14 <bollu> Gurkenglas: any nice way to rewrite this? https://github.com/bollu/simplexhc/blob/master/src/StgMachine.hs#L342
09:06:45 <Gurkenglas> bollu, heap . at (Addr count) ?~ cls
09:06:52 <Gurkenglas> *"?=", of course
09:06:54 <menedemos> ReinH: Right, i haven't thought about it that way. Still i use it to write functions like: map words . lines <$< readFile where (<$<) = ((.).($)) 
09:06:59 <bollu> hm, I see
09:07:10 <bollu> what is the vocabulary difference between ?~ and ?=?
09:07:18 <ReinH> :t (.).($)
09:07:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:07:21 <bollu> ?~ lets you remove with Nothing, I presume?
09:07:21 <lambdabot> Maybe you meant: v @ ? .
09:07:26 <bollu> which ?= says "equate" ?
09:07:39 <ReinH> :t (.)
09:07:40 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:07:51 <Gurkenglas> :t (?~)
09:07:52 <lambdabot> ASetter s t a (Maybe b) -> b -> s -> t
09:07:54 <Gurkenglas> :t (?=)
09:07:55 <lambdabot> MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
09:08:12 <bollu> hm, so it occurs within State
09:08:34 <bollu> "heap . at (Addr count) ?= Just cls" then?
09:08:42 <ReinH> Why would you use (.).($) instead of just (.)?
09:08:56 <Gurkenglas> count <- uses heap $ Addr . M.size; heap . at count ?= cls; pure count
09:08:59 <menedemos> ReinH: misspell. I meant (.).(<$>
09:09:04 <menedemos> (.).(<$>)
09:09:09 <ReinH> right, which is fmap . fmap
09:09:25 <ReinH> I like (<$$>) = fmap . fmap fwiw
09:09:26 <menedemos> ReinH: In more general sense yes
09:09:52 <menedemos> ReinH: That's the answer I needed. Thanks :)
09:09:53 <ReinH> or map words . lines . fmap readFile
09:10:18 <ReinH> often f . fmap g works nicely
09:10:37 <menedemos> ReinH: Shouldnt it be flip fmap?
09:10:47 <bollu> quchen: I like your method because it's easier to test
09:10:51 <Gurkenglas> bollu, maybeToMachineT ought to have its arguments the other way round, and then you can have maybeToMachineT err = maybe (throwError err) pure
09:10:56 <bollu> quchen: it's like you have a DSL of the operational semantics
09:11:02 <quchen> bollu: And there’s not much to gain from using StateT
09:11:05 <ReinH> (.) . (<$>) = fmap . fmap
09:11:11 <ReinH> (.) = fmap and (<$>) = fmap
09:11:19 <quchen> StateT alone is often not really more expressive than individual functions
09:11:21 <bollu> quchen: in what sense?
09:11:24 <bollu> quchen: ah
09:11:25 <menedemos> Or more like fmap (map words . lines) readFile
09:11:32 <bollu> quchen: I wanted to use it to look nicer
09:11:34 <ReinH> bollu: can you point me to a particular line in that file? I am le tired.
09:11:42 <menedemos>  fmap (map words . lines) . readFile
09:11:43 <ReinH> menedemos: right, sure
09:11:46 <menedemos> misspell again
09:11:46 <bollu> ReinH: what are you asking for, exactly?
09:11:48 <quchen> bollu: You lose knowing where exactly your state is
09:11:53 <bollu> quchen: hm, right
09:11:57 <bollu> Gurkenglas: I see
09:11:58 <ReinH> bollu: an example of whatever you're talking about :)
09:12:13 <bollu> ReinH: of the ugliness of my thing versus quchen's implementation?
09:12:20 <ReinH> of quchen's implementation
09:12:35 <ReinH> I'm not sure which thing(s) in that file you are referring to
09:12:50 <bollu> ReinH: so he collects all the rules here: https://github.com/quchen/stgi/blob/a82bc5c4f1acc2a4644344bdef1f604d330365ed/src/Stg/Machine/Evaluate.hs#L34
09:13:08 <bollu> ReinH: and picking a rule should be equivalent to folding over the results with an alternative
09:13:37 <quchen> Yup, it’s asum in line 73
09:13:39 <bollu> quchen: however, I think there is a thing in StateT that lets you take a "local" StateT and plug it into a "global" StateT
09:13:46 <quchen> foldr (<|>) empty
09:13:49 <bollu> quchen: so that way, you get the do-notation syntax
09:14:02 <bollu> quchen: but you still get fine-grained state manipulation
09:14:05 <bollu> quchen: if that makes sense?
09:15:32 <quchen> Mh yes
09:15:36 <quchen> I guess it depends on the use case
09:15:46 <quchen> I had State in there once I think, but it was far less readable
09:15:59 <quchen> The rules are complex enough
09:16:26 <quchen> And State gives you other problems, such as how do you represent that you found out in the middle of a stateful computation that the rule does not really apply
09:16:36 <bollu> quchen: the simple rules are easy, I think the updatable stuff is what makes it complex
09:16:37 <quchen> My rollback is simply returning »Nothing«
09:16:41 <bollu> quchen: right.
09:16:46 <quchen> The most complicated rule is let
09:16:50 <quchen> I think it’s 4
09:16:56 <bollu> quchen: yeah, because of letrec
09:16:57 <ReinH> that's fromMaybe (noRulesApply state) ... :)
09:17:15 <quchen> letrec is the devil, yeah
09:17:26 <Gurkenglas> bollu, and hlint gives a bunch of valid advice - ah ill just make a PR
09:17:34 <quchen> It’s not pretty right now, but believe me it was way uglier in the code
09:17:37 <bollu> quchen: it's actually _way_ easier if your language is imperative tbh
09:17:55 <bollu> quchen: I implemented it in timi, and I felt that being able to mutate stuff let me "hotwire" it easily
09:18:08 <ReinH> quchen: stgi looks very cool
09:18:28 <ReinH> I love runtime visualizations
09:18:30 <quchen> ReinH: It was my most valuable lesson in Haskell so far
09:18:43 <bollu> quchen: https://github.com/bollu/timi/blob/master/src/machine.rs#L786
09:18:53 <bollu> quchen: what was?
09:18:54 <quchen> Solved all »how does this work at runtime exactly« questions for good 
09:19:02 <quchen> Reading about, and implementing the, STG
09:19:06 <bollu> quchen: ah, agreed
09:19:17 <bollu> quchen: I believe that implementing a simper machine (TIM) actually helped me
09:19:30 <bollu> quchen: because I can sort of, switch to the simpler view when I just want to see what laziness implies
09:19:37 <bollu> quchen: and then think about STG when I want to see the other stuff
09:19:42 <ReinH> quchen: a curses visualizer in (say) brick would be cool
09:19:59 <MitchellSalad> Hm, question about stgi - does it use push/enter or eval/apply?
09:20:08 <quchen> push/enter
09:20:11 <bollu> MitchellSalad: push/enter
09:20:24 <MitchellSalad> oh
09:20:27 <ReinH> So we don't see some optimizations of the runtime itself
09:20:32 <MitchellSalad> shouldn't it use eval/apply instead :3
09:20:41 <quchen> I think the difference is only really significant when you compile it to machine code
09:20:55 <bollu> MitchellSalad: do you understand eval/apply?
09:20:58 <ReinH> My 
09:20:59 <MitchellSalad> bollu: nope
09:20:59 <ReinH> er
09:21:03 <lpaste> glguy pasted “Data.Text.Prettyprint.Doc.Render.Vty” at http://lpaste.net/356048
09:21:04 <glguy> quchen: first draft seems to work
09:21:04 <quchen> As mentioned earlier, I don’t understand eval/apply. It looks like a twist of push/enter, not something terribly different.
09:21:05 <MitchellSalad> only that it's what GHC uses
09:21:12 <quchen> glguy: That was quick!
09:21:14 <bollu> yes
09:21:20 <ReinH> My understanding is that eval/apply is an optimization of the runtime itself, not of the code being evaluated.
09:21:21 <bollu> glguy: first draft of?
09:21:33 <quchen> MitchellSalad: Sure, but I don’t think it’s so important in order to understand the STG, really
09:21:51 <quchen> MitchellSalad: The more important concepts are how the stack and laziness work
09:21:53 <MitchellSalad> quchen: i see, so flipping thru the output of stgi won't be misleading?
09:22:06 <MitchellSalad> if the goal is to understand what GHC is doing?
09:22:07 <bollu> quchen: do you want to sit down and work through eval/apply during zurihac?
09:22:08 <ReinH> It's possible that implementing eval/apply would hide some things that are optimized away in the run time
09:22:30 <phz_> hi
09:22:39 <quchen> MitchellSalad: Not at all, no. Eval/apply does function calls a bit different, but not terribly so.
09:22:43 <ReinH> phz_: Hello
09:22:56 <phz_> writing database code with selda is great yet challenging
09:22:58 <bollu> quchen: it only matters when you have a call to an unknown function, IIRC. 
09:23:00 <quchen> The details are quite technical, a bit like discussing calling conventions for a C compiler
09:23:20 <phz_> even though it’s work code, so it’s like a “real” stress-test for the library to me :)
09:23:20 <quchen> Also, eval/apply breaks the T in STG :-þ
09:23:41 <bollu> quchen: really? I don't recall that, I skimmed through the paper yesterday
09:23:54 <quchen> bollu: Read the last paragraph or so
09:23:54 <bollu> quchen: like, the runtime already tags stuff for performance, eval/apply or no, right?
09:23:58 <bollu> quchen: ah, I see
09:24:25 <bollu> can someone explain to me how to read mailing list archives? 
09:24:28 <ReinH> Hmm, has anyone implemented a ringad-based SQL thing yet?
09:24:29 <bollu> like, if I'm here: https://mail.haskell.org/pipermail/haskell-cafe/2017-June/127240.html
09:24:34 <bollu> how do I read replies to that?
09:24:40 <cocreature> bollu: pong
09:24:46 <MitchellSalad> bollu: there are none
09:25:02 <cocreature> quchen: I’ve used it since I wanted to convice you to add it and so far it’s been working just fine
09:25:05 <bollu> MitchellSalad: and if there were?
09:25:18 <MitchellSalad> there'd be a 'next message' link (or you can go up a level to see the whole thread tree)
09:25:21 <quchen> cocreature: What do you mean?
09:25:30 <bollu> cocreature: hey :) can you give me a concrete task to work on, so we can get the intrinsics?
09:25:36 <ReinH> bollu: 'Next in thread' buttons or look at the thread as a whole https://mail.haskell.org/pipermail/haskell-cafe/2017-June/thread.html#127240
09:25:38 <bollu> cocreature: so I can help with the intrinsics*
09:25:47 <cocreature> quchen: you were asking about the different width text stuff earlier
09:25:53 <quchen> cocreature: Oh, right
09:26:13 <bollu> ReinH: where is the 'next in thread'?
09:27:13 <ReinH> bollu: Ok, this interface just has 'next message'. You can look at the subject to determine whether it's in the thread or not
09:27:25 <bollu> ah, I see
09:27:26 <cocreature> bollu: write the generator that generates the ADT that lists the intrinsics and while you’re at it cleanup the parser
09:27:34 <bollu> cocreature: OK
09:27:42 <bollu> cocreature: can you please create an issue on the repo and add me as the owner?
09:27:45 <bollu> cocreature: so I can track it
09:28:27 <cocreature> bollu: sry, I’d prefer to see at least one PRs before I add you as an owner.
09:29:02 <MitchellSalad> owner of the issue =P
09:29:10 <bollu> cocreature: add me as the owner to the issue, not repo :)
09:29:27 <cocreature> oh :)
09:29:47 <ReinH> cocreature: immediately give your repo to bollu
09:29:51 <bollu> xD
09:29:53 <quchen> Free ownerships for everything, just ask cocreature!
09:30:19 <bollu> cocreature: sorry for the ambiguous phrasing -_^
09:31:32 <cocreature> bollu: np, also I’m usually quite open to giving people commit access. so once you have one or two decent PRs I’ll probably give you access anyway :)
09:32:31 <bollu> cocreature: heh, np.
09:35:29 <ReinH> quchen: regarding the browser frontend, ghcjs?
09:36:01 <bollu> ReinH, quchen: if you're going to make browser frontend for STGi
09:36:19 <bollu> I would like to discuss this, because it would be great if we could have reusable components for things most abstract machines use
09:36:21 <bollu> heaps, stacks, etc.
09:36:33 <bollu> so that way, I can use it for my implementations (simplexhc, timi), as well as STGi
09:36:46 <bollu> like, can we come up with a unified REST API + common building blocks?
09:36:56 <bollu> that would be *really* nice for anyone who's implementing abstract machines
09:36:58 <ReinH> quchen: how about you come up with an over the wire format and I'll write a react frontend
09:37:17 <ReinH> It doesn't have to be react because react is terrible, but react is also easy.
09:37:29 <bollu> ReinH: ^ what I said above? :)
09:37:33 <bollu> thoughts?
09:37:47 <ReinH> Seems ok?
09:37:53 <EvanR> easy, terrible, pick two
09:43:13 <jadrian> how do you open a module in stack repl?
09:43:28 <ReinH> stack repl is just ghci
09:44:08 <ReinH> So :m + Module.Name
09:47:27 <quchen> ReinH: That would be really cool
09:47:49 <quchen> ReinH: I don’t really care what the frontend is written in. I thought about Elm, Purescript and GHCJS
09:47:57 <quchen> But it can be Brainfuck for all I care
09:48:05 <cocreature> bollu: I can’t assign issues if you don’t have commit access, so I’ve added you to the project afterall :)
09:48:17 <quchen> My only constraint is that it can’t involve PHP
09:48:30 <jadrian> ReinH: sorry, I'd swear that wasn't working but alas it is
09:48:40 <ReinH> quchen: If it's anything but GHCJS, you can implement a wire protocol and be frontend agnostic.
09:48:57 <quchen> ReinH: Making a JSON instance for everything is not hard
09:49:03 <ReinH> you could just generate ToJSON instances generically
09:49:07 <jadrian> ReinH: oh wait 
09:49:19 <quchen> So yeah, that’s something I could do in an afternoon
09:49:38 <ReinH> quchen: what user interactions do you support?
09:49:39 <quchen> And then have the evaluator open a websocket or something
09:49:54 <ReinH> quchen: are there state changes that aren't triggered by user interaction?
09:49:56 <quchen> ReinH: Just stepping forward/backward
09:50:05 <ReinH> you might not need websockets at all
09:50:08 <jadrian> ReinH: ok, I guess you're right, this is a ghci question, but anyway... what I'd like to do is "open" a module in the sense of accessing its non-exported constructs
09:50:23 <jadrian> ReinH: is that doable?
09:50:26 <quchen> ReinH: For infinite programs you have to do things on demand, can’t render it in advance
09:50:46 <ReinH> quchen: yes, but what I'm asking is whether you need websockets, or whether state changes are driven by user interaction
09:51:07 <quchen> Technically, the STGi’s output is a list of STG states, nothing more.
09:51:11 <ReinH> can the user GET /steps/:n and receive a JSON representation of the state at n?
09:51:22 <quchen> Yes.
09:51:25 <ReinH> or /states/:n
09:51:28 <ReinH> Then that's all you needc
09:51:51 <quchen> Hm, you’re right
09:52:08 <ReinH> Give me an endpoint that sends the state over the wire for a given step number and I'll give you a web frontend.
09:52:24 <quchen> That would be truly amazing!
09:52:27 <ReinH> You don't need to push anything, so no websockets.
09:52:38 <ReinH> quchen: let's make it happen.
09:53:07 <quchen> ReinH: https://github.com/quchen/stgi/issues/13
09:53:35 <ReinH> quchen: I'd also ask for some metadata, like whether there's a next/previous state, if possible.
09:54:00 <quchen> Sure. I could also support handing out a range of states and what not.
09:54:21 <ReinH> { ..., "links": { "next" : "/states/2" } if you want to do it in a 'hypermedia' way.
09:54:23 <quchen> The toughest part is probably the prettyprinting in the frontend 
09:54:58 <ReinH> so you can hook up the next step button to the next state uri.
09:55:37 <ReinH> Otherwise you just optimistically try to go to the next step and sometimes fail. :)
09:55:48 <quchen> I’ve got to go now, but let’s talk about this again tomorrow!
09:55:56 <quchen> ReinH: The last step has an annotation »no further rules apply«
09:55:57 <ReinH> quchen: Sounds good!
09:56:05 <quchen> Anyway, that’s not our problem.
09:56:10 <ReinH> Yep.
09:56:13 <quchen> It would be really cool if we could make this happen!
09:56:19 <ReinH> I'm down.
09:56:39 <quchen> \o/
09:56:49 <quchen> Anyway, time to do something non-computer for me
09:57:08 <quchen> My hands are itching for some maltreatment in the rock gym ;-)
09:59:41 <ReinH> quchen: oh fun, I used to do a lot of that
10:01:26 <Gurkenglas> Why isn't there "<<?= :: MonadState s m => ASetter s s a (Maybe b) -> b -> m (Maybe b)"?
10:01:39 <Gurkenglas> *(<<?=)
10:04:48 <smallCat> Hey
10:05:23 <smallCat> I'm having a really weird bug. Can anyone help?
10:07:19 <mauke> smallCat: sorry, our mind readers are currently busy
10:07:25 <glguy> smallCat: Always just ask your actual question. People are watching who aren't interested in committing to answering an unknown question
10:09:46 <smallCat> Ah, sorry! So anyway, the bug is: "expected type: ConnectionPool -> Server userAPI, actual type: ConnectionPool -> Server userAPI0"
10:10:14 <smallCat> Except that the relevant section of my code is: server :: ConnectionPool -> Server userAPI
10:10:24 <glguy> smallCat: You can paste the code and error message to http://lpaste.net , it's probably related to treating type variables as though they are scoped
10:11:39 <smallCat> Okay. I posted it: http://lpaste.net/356049
10:12:03 <mauke> that's not a bug, that's a type error
10:12:29 <glguy> smallCat: It looks like you trimmed too much of the code away
10:12:53 <Gurkenglas> Can zoom work with newtype-wrapped StateTs that derive MonadState? (I have access to the newtype definition and could put in more deriving clauses or something.)
10:13:13 <smallCat> I'll re-post most of the code then?
10:13:34 <mauke> smallCat: why do you think there's a discrepancy?
10:15:10 <smallCat> Because the error message says: "Actual type: ConnectionPool -> Server userAPI0"
10:15:47 <smallCat> While my code in the relevant section is "ConnectionPool -> Server userAPI"
10:16:01 <smallCat> Like so: http://lpaste.net/356049
10:16:22 <smallCat> Tbh I can't figure out if it's a text editor issue or a haskell issue
10:16:37 <geekosaur> understanding issue, likely
10:16:50 <smallCat> How so?
10:17:11 <Akii> shouldn't it be `Server UserAPI`?
10:17:18 <mauke> smallCat: your signature is the expected type
10:17:33 <Akii> instead of `Server userAPI`
10:17:33 <mauke> the "actual type" is what the function body actually gives you
10:18:07 <smallCat> Oh I see? I'll try changing that then
10:19:23 <geekosaur> when ghc introduces a new distinct type variable (generally by tagging an 0 on the end like you see here) it usually means you did not give it enough information to relate two uses of a type
10:20:15 <geekosaur> sometimes because you expected a type function to be injective (i.e. can be run "backwards"), sometimes because you assumed a type in a type signature is in scope in the body, sometimes because you missed a functional dependency somewhere
10:20:25 <geekosaur> and sometimes just a thinko
10:20:39 <Akii> or a typo
10:20:40 <Akii> :D
10:21:00 <mauke> typ0
10:21:08 <Akii> typo0*
10:21:21 <Akii> not to be confused with typo3
10:21:23 <Zemyla> You know how indexing into Texts is O(n)?
10:21:42 <mauke> no, but it doesn't surprise me
10:22:04 <Zemyla> mauke: It's because it has to manually count characters, whether they're 2 or 4 bytes.
10:22:13 <mauke> exactly
10:22:15 <Gurkenglas> I keep finding definitions that could be refactored into one line were it not for error reporting throwing a wrench in all the pointfreedom potential. Is there a way to deal with that?
10:22:15 <Zemyla> I figured out a way to make indexing O(lg n).
10:22:38 <Zemyla> You basically include a fingertree with the text array, which counts how many characters of each size there are.
10:22:51 <c_wraith> what are you doing where random access into text has any value? 
10:23:24 <lyxia> might as well do Seq Char
10:23:27 <geekosaur> Zemyla, fine as long as maintaining the fingertree doesn't make other operations expensive enough to offset the gain
10:23:59 <mauke> I figured out a way to make indexing O(1)
10:24:05 <mbw> I think I've gotten to the point where I have to rethink how I work with Haskell. I deleted some stuff under ~/.stack/, most notably older snapshots and programs compiled with GHC 8.0.1. Unfortunately, now my vim/ghcmod setup doesn't work anymore, and I wasn't able to call hsc2hs globally anymore. So clearly I need to tweak the global project and do some other things. Since I only have a 128GB SSD, and I 
10:24:08 * hackage prettyprinter-vty 0.1.0.0 - prettyprinter backend for vty  https://hackage.haskell.org/package/prettyprinter-vty-0.1.0.0 (EricMertens)
10:24:11 <mbw> can't really afford a 50GB .stack folder with a gazillion version of each library, what should I do to not let things get out of hand? And how can I start with a clean slate again?
10:25:34 <cocreature> mbw: sticking to lts releases helps since more things can be shared
10:25:47 <c_wraith> mauke, even when considering that codepoints aren't characters, and neither of those are glyphs? 
10:25:54 <Zemyla> c_wraith: Something like this, I'm thinking https://www.schoolofhaskell.com/user/edwardk/heap-of-successes
10:26:03 <Zemyla> It works a lot better when drop is O(lg n).
10:26:58 <mauke> c_wraith: no, that's hard
10:27:11 <c_wraith> as far as I'm concerned, Unicode text is an opaque blob.
10:27:11 <kadoban> mbw: Nuke everything in ~/.stack/ except your config (probably ~/.stack/config.yaml and ~/.stack/global-project/stack.yaml, but look for others) every once in a while can free up space, but then you're going to be rebuilding stuff. GHC is kind of inherently big I think. Can you plug in a slow but bigger hard drive for this stuff?
10:29:04 <mbw> kadoban: I have a second SSD in this laptop as well, with 256GB. Unfortunately, both SSD have about 20GB free :)
10:29:23 <bollu> someone pinged me?
10:29:35 <bollu> smallCat: ping
10:30:52 <kadoban> mbw: The pain of having actually fast drives without spinning blades of death I suppose :( Not sure what to do about that except cocreature's advice sounds good, and nuking the collections every once in a while.
10:30:56 <mbw> But thanks for the advice, I will edit the various stack.yamls that lie around to share the same LTS release, and try to make vim use a ghc-mod installed with this release as well.
10:31:45 <mbw> kadoban: The problem is I kind of need SSDs. I have broken three HDDs in laptops already, by knocking it over and walking around while it's spinning etc.
10:32:22 <kadoban> Ouch. I don't think I've ever actually killed one that way, but I'm not big on laptops.
10:33:16 <mbw> I don't treat hardware with the respect it deserves.
10:34:54 * geekosaur always been pretty hard on laptops but never done that; the hd usually outlives the laptop
10:38:25 <mbw> No I'm all about weird noises when opening the lid, cracked displays and such. Makes me look badass.
10:38:45 <kadoban> Hah
10:45:50 <mbw> Ah I'm an idiot. I forgot I had modified my $PATH in the .bashrc to include the stuff I deleted.
10:48:44 <Akii> smallCat: did it work? :D
10:49:22 <smallCat> No
10:49:37 <smallCat> I'm trying to figure out why
10:51:55 <Akii> :/ http://lpaste.net/356049#line59 this needs to be Proxy UserAPI
10:54:09 <Akii> smallCat: annotated the paste but hard to help without error msgs :D
10:56:19 <SepakoRayl> why does $(return []) fix my "_ is not in the type environment at reify" error? :O
10:56:25 <smallCat> .. fuck that worked. Thanks!
10:56:32 <Akii> smallCat: :D
10:56:58 <smallCat> ... I'm now just confused as to why that didn't work when I defined userAPI as a type variable in another module (the Api module)
10:57:05 <smallCat> Using the same function
10:57:24 <glguy> smallCat: Type variables are all local to a particular type signature
10:57:52 <smallCat> So type variables can't be imported?
10:58:03 <glguy> type constructors are the things that can be exported
10:58:14 <glguy> type variables are implicitly quantified at each type signature
10:58:35 <glguy> So you can use: type UserAPI = <your type here>
10:58:40 <smallCat> I see. Thanks!
11:06:30 <lyxia> SepakoRayl: by default GHC thinks all your definitions are mutually recursive, but that doesn't work well with template haskell. top-level splices split the definitions: those above a splice cannot depend on those below, but in exchange those below may now contain inline splices that depend on those above.
11:08:57 <SepakoRayl> thanks lyxia, I just found it in the docs following a ghc bug ticket
11:18:56 <kuznero> Hi All!
11:25:12 <typedrat> Why is a function that takes and returns phantom-typed constructors unable to be given an existential type? (That is, I can't stuff it in a hole of shape `forall a b. T a -> T b`) It has no dependence on the type variable, so why doesn't that work?
11:25:54 <sternmull> I have a function that takes a data argument with a type constraint... but it seems Haskell does see that by itself (http://lpaste.net/356053). Do i really have to repeat the constraint on my functions? Is there a better way?
11:26:18 <typedrat> Imagine something like `data T a = T1 Int | T2 String` and `f (T1 i) = T2 (show i)`
11:26:52 <ReinH> sternmull: constraints on data declarations don't do what you expect
11:27:04 <ReinH> it's usually better to just write them on the functions that require them
11:28:27 <lyxia> typedrat: show an example which doesn't type check
11:28:27 <sternmull> ReinH: But isn't that utterly redundant? I expected that the constraints apply to all constructors of my data definitions and state that they apply to all values...
11:28:45 <ReinH> Yes, that's what everyone expects. Unfortunately, it doesn't work that way.
11:28:51 <mizu_no_oto> Is there a good library to use to test if a string contains a valid url as a substring?
11:29:09 <ReinH> There's some more info on that here https://stackoverflow.com/questions/12770278/typeclass-constraints-on-data-declarations
11:29:19 <sternmull> ReinH: Is there an extension that allows that?
11:29:48 <ReinH> sternmull: Type constraints on GADTs work in the way you expect
11:30:05 <mizu_no_oto> so e.g. "I saw on reddit.com/r/haskell an interesting talk on lenses" would give you back that it contains the url reddit.com/r/haskell
11:30:16 <geekosaur> sternmull, you really do want to read what was linked. it's not a "oh that's just a dumb restriction for no reason at all", and while GADTs can do what you want, it comes with a cost
11:30:38 * hackage ziptastic-core 0.2.0.3, ziptastic-client 0.3.0.3 (3noch): https://qbin.io/2b84d9u
11:30:53 <sternmull> ok, will read that
11:30:54 <mizu_no_oto> It seems that Network.URI and similar libraries will just tell you if the entire string parses as a valid URL
11:31:04 <typedrat> I don't know why the minimal example works but the full one doesn't...
11:32:30 <typedrat> Oh god I'm dumb
11:32:50 <typedrat> wait am I?
11:33:51 <ph88^> can i just put regular haskell code in a TH section ?
11:34:21 <rydia5[m]> Hello everyone
11:34:24 <rydia5[m]> My name is Rydia
11:34:28 <rydia5[m]> I'm learning Haskell
11:34:36 <ph88^> hi rydia5[m] 
11:35:10 <rydia5[m]> I'm accessing this channel via Riot which is p cool
11:35:18 <typedrat> no I definitely am dumb. I was accidentally screwing up the types with (.)
11:35:40 <rydia5[m]> It's better than screwing up types iwth (.)(.)
11:38:39 <EvanR> something is annoying me, not sure the best way to sort out. Rational is not a type of its own, its a synonym. So I cant make instances for it without extensions. I also cant make instances for Ratio Integer without extensions. Whats the appropriate thing to do
11:38:50 <EvanR> i dont see anything besides Ratio Integer making sense
11:40:28 <prooftechnique> Instances?
11:40:29 <EvanR> use extensions, write code against (Num a, Ord a, Integral a, Enum a.....) => Ratio a ?
11:40:45 <EvanR> instance Foo Rational where
11:40:46 <EvanR> illegal
11:40:59 <prooftechnique> Oh, I see
11:41:10 <prooftechnique> I was thinking of it backwards and it made no sense at all to me :D
11:41:15 <EvanR> another option is to make a newtype Q = Q Rational and generalized newtype deriving, to get an exact copy of Rational
11:41:38 * hackage text-format-heavy 0.1.1.0 - Full-weight string formatting library, analog of Python's string.format  https://hackage.haskell.org/package/text-format-heavy-0.1.1.0 (IlyaPortnov)
11:42:28 <ph88^> how can i read from a file during compile time and get a string which is then available as regular string as if i would have written it as constant in my source code ?
11:42:44 <EvanR> with the file-embed package
11:43:20 <prooftechnique> EvanR: What's wrong with TypeSynonymInstances, if your other options is going to GeneralizedNewtypeDeriving?
11:43:27 <prooftechnique> *option
11:43:30 <EvanR> thats what im asking
11:44:20 <EvanR> TypeSynonymInstances does some kind of wrong, since now type classes are distinguishing two types which are supposed to be equal
11:44:30 <EvanR> but meh
11:44:55 <Tuplanolla> That doesn't sound right.
11:45:24 <Tuplanolla> Don't you simply get an instance for the expansion of the synonym?
11:45:25 <ph88^> EvanR, i don't want to include the entire file .. i just want to read a line from it
11:45:41 <prooftechnique> It looks like an innocuous extension, all told
11:46:02 <EvanR> ok... and then i will need another extension for instance Ratio Integer
11:47:11 <ph88^> is    foo = "hello"    a declaration ?
11:47:38 <c_wraith> yes
11:47:39 <ReinH> Yes.
11:48:33 <prooftechnique> Why do you need to define your own Ratio Integer?
11:48:37 <prooftechnique> Isn't that just what Rational is?
11:48:37 <ph88^> can i do IO inside Q ?
11:48:49 <EvanR> i didnt say anything like that
11:49:14 <prooftechnique> I guess I'm not sure what you're trying to do
11:49:27 <EvanR> instance Foo Rational where
11:49:41 <EvanR> with the least b.s., most convention, dunno
11:50:20 <prooftechnique> Well, the most direct way to write it without extensions would be instance Foo (GHC.Real.Ratio integer) where
11:50:38 <EvanR> lowercase i?
11:50:40 <prooftechnique> *Integer
11:50:45 <prooftechnique> Typo
11:50:45 <EvanR> thats illegal
11:50:56 <Tuplanolla> Dubious again.
11:51:12 <EvanR> it has to be of the form instance ... => Ratio a where
11:51:21 <EvanR> er
11:51:25 <EvanR> Foo (Ratio a) 
11:52:03 <Tuplanolla> It should work if you enable `MultiParamTypeClasses`, which ought to be always on anyway.
11:52:20 <EvanR> really o_O
11:52:29 <Tuplanolla> It was either that or `FlexibleInstances`.
11:52:41 <EvanR> flexible instances makes more sense
11:53:01 <EvanR> multiparam does not work
11:53:18 <EvanR> two extensions it is
11:53:34 <Tuplanolla> It's not prescription medication.
11:54:01 <Tuplanolla> You can enable all the extensions you find even remotely useful.
11:54:26 <ReinH> Well, there are some interactions that make certain combinations contra-indicated, unless they've all been fixed by now.
11:55:05 <prooftechnique> Most of the syntax extensions seem pretty harmless, some things considered
11:55:53 <ReinH> Yes, most drug combinations are pretty harmless too.
11:56:44 <EvanR> for screwing around in haskell, pasting 9 extensions at the top of the source file is contra-indicated ;)
11:57:06 <ReinH> It's actually the new normal.
11:57:17 <EvanR> :(
11:57:23 <ReinH> Although LANGUAGE KitchenSink would be nice.
11:57:29 <Tuplanolla> We'll eventually get `GeneralizedAbstractEverything`.
11:57:46 <ReinH> That's just category theory.
11:58:27 <ph88^> why do i get here  parse error on input ‘]’     version = [d| "1.1" |]
11:58:52 <davean> when did it become new? I've always used a number of extensions. They're where the nice stuff is
11:58:54 <ph88^> same if i use  [e|   |]
11:59:04 <ph88^> hi davean 
11:59:09 <ReinH> ph88^: did you add the quasiquoter extension?
11:59:26 <EvanR> gotta enable QuasiQuotes
11:59:31 <ReinH> davean: some time after 1998.
11:59:44 <kuribas`> Why do I get: No instance for (M.Unbox (Point Double))
11:59:48 <ph88^> ReinH, no
11:59:56 <kuribas`> it's here: https://hackage.haskell.org/package/cubicbezier-0.6.0.3/docs/Geom2D.html
12:00:03 <ReinH> ph88^: You're using QuasiQuotes syntax, you need to enable the language extension.
12:00:16 <ph88^> ok
12:00:29 <ReinH> kuribas`: what is M.Unbox?
12:00:32 <EvanR> in a class, can i put a constraint on an associated type
12:00:48 <MitchellSalad> EvanR: yeah
12:00:49 <kuribas`> ReinH: Data.Vector.Unboxed.Mutable.Unbox
12:01:11 <EvanR> mkay
12:01:15 <MitchellSalad> right-o
12:01:32 <ReinH> How did you import M?
12:02:29 <kuribas`> ReinH: import qualified Data.Vector.Unboxed.Mutable as M
12:02:54 <ReinH> Then I don't know.
12:04:16 <ph88^> ReinH, now i get  Not in scope: ‘d’  is it bcz i didn't add TH extension ?
12:04:26 <ph88^> ye ok seems so ^^
12:04:28 <shapr> I found something funny in an antique hacker news article: codexon 2372 days ago <Insert Dons and the usual angry Haskell fanboy diatribes here> </satire>
12:04:30 <ph88^> different error when i add    {-# LANGUAGE TemplateHaskell #-}
12:04:54 <shapr> Funniest part about that comment is how Haskell has sneakily become an everyday subject for high end coders. It's just not a big deal anymore.
12:06:36 <EvanR> high end coders, makes me think of gold plated audio cables and fake airfoil on the back of your honda civic
12:06:39 <maerwald> shapr: https://pyos.github.io/dg/
12:06:45 <maerwald> shapr: "With Haskell's syntax but none of its type system, dg is the best way to make fans of static typing shut up already." xxD
12:06:47 <mbw> I have a question. I tried to work my way through the ffi example here ( under Advanced Topics) https://en.wikibooks.org/wiki/Haskell/FFI . Specifically, the call to "qag". This requires some preprocessing with hsc2hs, implementing of a Storable instance, etc. I am able to get this to work when I compile it (using a custom library may need tweaking LD_LIBRARY_PATH). However, when I try to invoke qag from 
12:06:54 <mbw> ghci, it fails with: "gcc: error: /tmp/ghc32361_0/ghc_5.o: No such file or directory
12:06:56 <mbw> `gcc' failed in phase `Linker'. (Exit code: 1)"
12:07:20 <mbw> Is there a reason for this behavior, or a way to get more detailed error information?
12:07:46 <ReinH> maerwald: I can't believe they didn't call them dogecedures.
12:07:49 <shapr> EvanR: By that I mean the people around me who learn new things because they want to expand their understand.
12:07:55 <ReinH> Huge missed opportunity.
12:07:58 <maerwald> heh
12:08:09 <ph88^> ReinH, how can i do IO in the Q monad ?
12:08:17 <mbw> I am doing these examples with a stack project, which has "extra-libraries:     mylib, gsl, blas".
12:09:26 <AndChat|561801> I think you can enable language extensions in the .ghci so they load automatically in ghci
12:12:22 <dmj`> ph88^: runIO 
12:14:25 <ph88^> thx
12:14:31 <itscomplex> Anyone here familiar with liquidhaskell?  I'm getting a weird error with something simple when refining a value to Nat: "The Liquid type GHC.Types.Int is inconsistent with the Haskell type GHC.Integer.Type.Integer"
12:23:30 <ph88^> how can i get a String here instead of Q Exp ?    https://bpaste.net/show/ca306988e77e
12:25:28 <hexagoxel> ph88^: are you reinventing Paths_packagename?
12:25:38 <ph88^> hexagoxel, maybe ?
12:26:32 <ph88^> seems so -___-
12:26:48 <hexagoxel> https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
12:27:32 <hexagoxel> (rather, the paragraph below)
12:28:20 <hexagoxel> ph88^: what you write there still can have a purpose, e.g. when you want to access the git commit hash.
12:28:59 <cocreature> when you want to access the git commit, you use gitrev :)
12:30:52 <hexagoxel> cocreature: btw, are those refreshed only when the module is recompiled? TH does not enforce recompilation on its own, does it?
12:31:26 <lensaesonvalue> I'm having trouble adding a key to an Aeson Value: https://codepad.org/U30T9SdV
12:32:03 <cocreature> hexagoxel: no they are refreshed when necessary. TH provides addDependentFile to declare a dependency on an external file (in this case some git config)
12:32:48 <hexagoxel> ah, that's neat  *looks closer at gitrev source*
12:35:15 <EvanR> @index swap
12:35:15 <lambdabot> Data.Tuple
12:35:37 <EvanR> haha wow this is not in prelude (anymore?)
12:36:16 <cocreature> Control.Lens is the new prelude and it has "swapped"
12:36:39 <EvanR> :t swapped
12:36:41 <lambdabot> (Functor f, Profunctor p1, Swapped p) => p1 (p b a) (f (p d c)) -> p1 (p a b) (f (p c d))
12:37:49 <EvanR> its so simple i dont even need sane letters to see it
12:38:03 <EvanR> like emojihaskell
12:38:04 <cocreature> calling things that are not profunctors "p" should be forbidden
12:38:11 <EvanR> or haskell in heiroglyphs
12:39:14 <Taneb> > let � = 1 in �
12:39:16 <lambdabot>  <hint>:1:5: error: parse error on input ‘�’
12:39:24 <Taneb> > let (�) = 1 in (�)
12:39:27 <lambdabot>  1
12:39:45 <Taneb> I... I have no idea if that's pasted correctly, my font doesn't support hieroglyphics
12:39:59 <cocreature> huh I never thought of using swapped for Either
12:41:20 <kadoban> Taneb: I think it didn't. It seems to be http://www.fileformat.info/info/unicode/char/fffd/index.htm on my end
12:41:54 <nshepperd_> Shouldn't hieroglyphics be counted as alphabetical
12:42:07 <Taneb> kadoban, darn
12:42:18 <Taneb> Interesting you can use that as an identifier though
12:42:45 <EvanR> yes
12:43:03 <EvanR> http://www.cs.rochester.edu/u/ryates/slides/TRANSACT2015-embrace-Haskell/hieroglyphs.png
12:43:20 <kadoban> > let 𓀒 = 5 in 𓀒
12:43:22 <lambdabot>  5
12:43:32 <kadoban> Though my font doesn't have that, and I have no idea wtf it looks like even
12:44:17 <Tuplanolla> Looks like a tiny lobster.
12:44:23 <kadoban> Nice
12:44:24 <nshepperd_> Ah yeah
12:44:49 <EvanR> i object to the non fixed width hieroglyphics though
12:45:04 <suzu> is that like
12:45:05 <suzu> a ray gun?
12:45:12 <mauke> EvanR: I like how the identifiers in that code make sense
12:45:28 <suzu> what are these moon runes
12:45:37 <mauke> IIRC the first one was something like meh-p
12:45:47 <Tuplanolla> Cuneiform works really well for list operations.
12:45:57 <EvanR> mauke: i wish i knew egyptian
12:46:03 <Tuplanolla> Example: http://users.jyu.fi/~sapekiis/tmp/cuneiform.png
12:46:15 <sproingie> looks like arrow syntax
12:47:12 <EvanR> ok
12:47:18 <EvanR> hawk is a, foot is b
12:47:22 <EvanR> flug is f
12:47:25 <EvanR> er slug
12:48:06 <sproingie> i dig the ghci prompt: "please"
12:48:20 <nshepperd_> An element of a hawk is a feather
12:48:40 <nshepperd_> An element of many Hawks is many feathers :p
12:50:12 <ReinH> sproingie: imagine what you could do with proper mixfix.
12:51:11 <sproingie> heck why limit it to one dimension
12:51:32 <ReinH> Yeah, I love 2d type signatures in Epigram.
12:52:22 <EvanR> finite dimensional vector space for type sigs
12:53:04 <ReinH> Maybe in 10 years we'll finally use structural / semantic editing.
12:53:31 <sproingie> the technology is only 10 years away
12:53:34 <sproingie> every 10 years that is
12:56:51 <Tuplanolla> Positive-yield nuclear fusion, high-temperature superconductors and editing text files.
12:57:11 <Tuplanolla> Got to aim high.
12:57:35 <EvanR> at least were at text-file tech level
12:57:50 <EvanR> it could be still hole punched tape
12:58:05 <cocreature> the first fusion reactor will be programmed using a structural editor
12:58:35 <EvanR> paredit?
13:01:46 <sproingie> i could never get into paredit and such.  i tend to cut and paste like william s. burroughs
13:02:12 <sproingie> makes more sense for a language that knows no text format at all.  or doesn't expose it to the user at any rate.
13:07:47 <EvanR> i know i can do type level shenanigans to track states with phantoms and singletons, but is there a quick-and-dirty thing to simply require a Bool test for something
13:07:52 <EvanR> like idris Oh and So
13:18:54 <vimalloc> I'm playing with some values in the interpreter, got an either value. Is there an easy way to extract a Right value right in ghci? (looking for something like fromJust in Data.Maybe). 
13:19:10 <EvanR> theres fromRight
13:19:17 <EvanR> Data.Either
13:19:30 <vimalloc> Don't see it here: https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Either.html
13:19:33 <EvanR> let Right x = <my stuff> too
13:19:47 <vimalloc> see isRight, but no fromRight
13:19:57 <maerwald> vimalloc: you can also just do a partial pattern match in a lambda function
13:19:58 <EvanR> hrm.
13:20:06 <jaspervdj> Does anyone know if System.Random is supposed to generate the same numbers on 32bit and 64bit machines (given the same seed)?
13:20:22 <vimalloc> maerwald: That works. Thanks! :)
13:20:56 <jaspervdj> Ah, Int32 is an instance of Random, I guess I should just use that to be safe
13:21:32 <vimalloc> I wonder why there is no fromRight or fromLeft there. I'm sure there is a really good reason for it, but it seems odd.
13:21:45 <EvanR> could have sworn fromRight, the evil partial function like fromJust was in there
13:22:00 <EvanR> but there seems to be a package or packages defining it
13:22:14 <EvanR> less trouble to just write fromRight (Right x) = x in ghci
13:22:19 <EvanR> or use pattern matching
13:22:31 <dfeuer> There should be fromRight :: b -> Either a b -> b
13:22:38 <dfeuer> fromLeft :: a -> Either a b -> a
13:22:43 <dfeuer> to match fromMaybe.
13:22:43 <maerwald> :t either undefined id
13:22:45 <lambdabot> Either a c -> c
13:22:59 <dfeuer> :t either either either
13:23:01 <lambdabot> Either (a -> c) (a -> c) -> (b -> c) -> Either a b -> c
13:24:09 <dfeuer> :t either (maybe either) (either maybe)
13:24:11 <lambdabot> error:
13:24:11 <lambdabot>     • Couldn't match type ‘Either c b’ with ‘Maybe a1’
13:24:11 <lambdabot>       Expected type: (b -> (a -> c) -> Maybe a -> c)
13:24:14 <dfeuer> Aww.
13:24:16 <maerwald> dfeuer: ?
13:24:27 <dfeuer> maerwald: sorry; being silly.
13:24:34 <maerwald> you can query lambdabot
13:24:46 <dfeuer> I am aware.
13:25:33 <maerwald> EvanR: I think I might have seen it somewhere too, but hoogle doesn't find it
13:25:49 <maerwald> some utility package for trivial things
13:27:21 <maerwald> https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Combinators.html#v:fromRight-39-
13:28:02 <maerwald> ofc, if there is something, edward has already written it
13:28:03 <maerwald> :D
13:29:05 <codedmart> With yesod in config/models how can you say to index a field?
13:32:55 <n_blownapart> Is it insane to attempt learning scheme and haskell side by side?
13:33:05 <mauke> yes
13:33:15 <Sonolin> I think its good rule of thumb to only learn 1 thing at a time
13:33:25 <EvanR> slow
13:33:30 <kadoban> Maybe a little. They're quite different languages. But it's not the worst idea ever.
13:33:33 <EvanR> +RTS -N9
13:34:10 <n_blownapart> If I'm using mostly math examples, just to see what it looks like in both langs?
13:34:41 <glguy> n_blownapart: You're been talking about doing that for a while, maybe just try it?
13:35:49 <n_blownapart> I have been glguy . because I went through sicp a bit, now I keep going back to just get the math principles, before looking at, say, a test for primality in haskell
13:44:24 <tempeh> @help
13:44:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:44:29 <tempeh> @list
13:44:29 <lambdabot> What module?  Try @listmodules for some ideas.
13:44:34 <tempeh> @listmodules
13:44:34 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
13:44:34 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
13:44:38 <glguy> tempeh: private message is the place to explore that
13:45:57 <Tuplanolla> I came to Haskell from Scheme, n_blownapart. You can do the same things in both languages in very similar ways, but the way things are usually done differ quite a bit.
13:46:46 <EvanR> so
13:46:55 <EvanR> how to zip two Maps together
13:47:42 <glguy> intersection and union
13:47:52 <glguy> and the -With variants
13:48:04 <EvanR> ah
13:48:24 <EvanR> unionWith seems right
13:52:02 <n_blownapart> Tuplanolla, thanks a lot. what about if...
13:53:01 <n_blownapart> If I keep it mostly with math stuff, do you think looking at both will screw me up? I'm trying to teach myself basic number theory
13:53:21 <Tuplanolla> The worst choice is not making your choice now.
13:53:51 <Tuplanolla> Stop worrying and get to it.
13:54:16 <n_blownapart> choosing between the two, you mean? I don't know why, but I feel torn by it.
13:54:40 <zachk> n_blownapart, I too came from scheme, and with haskell you have a nicer notation for writing formulas and a compiler to generate real binaries 
13:54:44 <maerwald> it almost sounds like you need romantic advice :P
13:55:12 <Tuplanolla> You'll know if you made the wrong choice and adjust.
13:55:40 <n_blownapart> maerwald, !! ok good call Tuplanolla thanks all
13:56:03 <n_blownapart> thanks zachk
13:56:45 <Tuplanolla> Frankly both languages are quite mediocre for number theory...
13:56:51 <maerwald> which language do you see when you close your eyes? :P
13:57:02 <zachk> n_blownapart, also the type system will let the compiler catch alot of common errors in haskell and there a functions in the haskell prelude that are 30-50 loc in scheme
13:57:46 <n_blownapart> cherished English maerwald !
13:57:51 <n_blownapart> zachk ...
13:58:15 <n_blownapart> what do mean 30-50 loc in scheme?
13:58:24 <zachk> 30 to 50 lines of code
13:58:34 <ab9rf> that's a lot of parentheses
13:58:37 <zachk> like the words function from the haskell Prelude 
14:01:08 <n_blownapart> Tuplanolla, why mediocre?
14:01:45 <zachk> you can do calculations, but it's not very easy to do proofs in either haskell or scheme
14:01:46 <kamyar> Hello guys
14:01:52 <zachk> hiya kamyar 
14:02:00 <kamyar> I have written a Haskell program
14:02:05 <Tuplanolla> You need extra libraries for simple things like factoring and they're not always very comprehensive either, n_blownapart.
14:02:06 <kamyar> it  works great
14:02:25 <kamyar> and my benchmarks shows it runs much faster than its python counterpart
14:02:34 <EvanR> actually Data.Map.Merge.Strict
14:02:36 <pikajude> congrats
14:02:39 <EvanR> this looks gold
14:02:43 <ab9rf> kamyar: that does not much surprise me
14:02:43 <n_blownapart> thanks very much ALL
14:02:55 <kamyar> But a question remains
14:03:06 <kamyar> Why the process uses just 1 thread an 1 CPU core?
14:03:12 <kamyar> while benchmarking I mean
14:03:36 <kamyar> Do I have to add special switches when build ?
14:03:40 <pikajude> you didn't use +RTS -N probably
14:03:47 <pikajude> wish it was opt-in, but
14:03:50 <pikajude> or uh, opt-out
14:04:02 <geekosaur> -with-rtsopts -rtsopts -N
14:04:04 <glguy> You have to write your program in a way to actually use multiple cores, too
14:04:17 <ab9rf> yeah, it won't just intrinsically go multithread
14:04:25 <zachk> kamyar, did you use forkIO or something similar to use multiple cores?
14:04:26 <kamyar> glguy: I thought Haskell does it automatically 
14:04:27 <ab9rf> although it's fairly easy to do
14:04:37 <geekosaur> no, Haskell does not autothread
14:04:39 <glguy> kamyar: Does what exactly?
14:05:02 <kamyar> glguy: Snce I have no side effect and global var or so Haskell can do it automatically
14:05:12 <kamyar> I studied about GHC using threads
14:05:12 <pikajude> what would it parallellize?
14:05:15 <pikajude> parallelize
14:05:20 <pikajude> spellelize
14:05:37 <ab9rf> pararalelelizize
14:06:11 <kamyar> glguy: I expected Haskell to run each user code in a CPU core concurrently
14:06:12 <ab9rf> like mississippi, except not
14:06:15 <kadoban> In principle GHC could automatically parallelize quite a bit, right? But there always seem to be tradeoffs.
14:06:24 <pikajude> well, forkIO will run things in other threads (if it can)
14:06:29 <pikajude> and the `par` combinator will also do that
14:06:32 <Tuplanolla> It can be done, but doing it such that the result runs faster than the original is an open problem, kamyar.
14:06:46 <zachk> try pmap or parMap for parallel map
14:07:15 <pikajude> if you have IO operations you want to do simultaneously, you can use the async package
14:07:19 <pikajude> i think that's what it's called
14:07:36 <kadoban> kamyar: http://chimera.labs.oreilly.com/books/1230000000929/index.html could be an interesting read for you, I found it quite enjoyable.
14:07:38 <kamyar> I have Scotty web rogram. Does Warp parallelize?
14:07:50 <pikajude> yep
14:07:56 <pikajude> all those web frameworks will
14:08:02 <pikajude> if you use the right rtsopts
14:08:25 <kadoban> Ah, yeah if you use the right framework it could very well already know how to parallelize what you wrote.
14:08:35 <kamyar> I expect Waro to expand users through cores
14:08:38 <kamyar> Warp
14:08:39 <pikajude> yeah they all spawn multiple listener threads
14:08:54 <ReinH> kamyar: See https://stackoverflow.com/questions/15005670/why-is-there-no-implicit-parallelism-in-haskell
14:10:14 <ReinH> The problem isn't knowing when to parallelize, it's knowing when *not* to paralleize.
14:11:02 <ReinH> We don't have a good general answer for "how fine-grained should parallelism be for arbitrary programs?"
14:11:31 <ReinH> It's easy to make a program *slower* by running it in parallel.
14:11:48 <kamyar> AFAIK Erlang does such thing automatically
14:11:51 <kamyar> with its actors
14:11:53 <ReinH> It does not.
14:12:19 <kamyar> Erlang runs actors in diferent cores. Does't it?
14:12:23 <ReinH> It does.
14:12:35 <ReinH> Processes are user-defined.
14:12:46 <ReinH> Erlang code is not automatically parallelized.
14:12:55 <kamyar> So it can be considered a form of automated parallelsim
14:13:11 <ReinH> If that can be considered automated parallelism, then Haskell has that too.
14:13:22 <kamyar> Erlang server side code usually uses actors, tons of them
14:13:24 <ReinH> Just like in Erlang, you define what is to be parallel and then the runtime makes it parallel.
14:13:54 <ReinH> Erlang requires developers to explicitly define process boundaries
14:13:57 <ReinH> it does not do that automatically
14:13:57 <kamyar> ReinH: No, I dont think so, since you said use x or y library
14:14:08 <ReinH> I did not say that.
14:14:19 <kamyar> ReinH: For example forkIO or so
14:14:24 <ReinH> forkIO is not a library.
14:14:32 <ab9rf> oi
14:14:41 <kamyar> ReinH: I expect WARP to spawn all my cores
14:14:49 <ReinH> forkIO is part of the standard distribution of Haskell, called 'base'.
14:14:53 <ab9rf> why d you have that expectation?
14:15:08 <kamyar> ReinH: All haskell web development guides 
14:15:17 <Gurkenglas> Is there some sort of about-as-unsafe-as-IOT Distributive instance for IO?
14:15:18 <kamyar> discourage putting WARP behind nginx or so
14:15:21 <ReinH> Are we talking about what the language does automatically or are we talking about what Warp does?
14:15:34 <ab9rf> ReinH: i think the latter although it's becoming fuzzy to me
14:15:39 <ab9rf> must be the drugs
14:15:41 <ReinH> They "all" do? Show me an example.
14:15:57 <ReinH> It should be easy to show me an example since they all do it.
14:16:09 <ab9rf> and i totally don't understand what nginx has to do with this
14:16:18 <ReinH> I'm also not sure what that has to do with whether warp is concurrent.
14:16:21 <kamyar> ReinH: They say do not use nginx or so since WARP knows how to spawn threads and cores
14:17:06 <ReinH> I'm not going to respond to "they say".
14:17:20 <Tuplanolla> He's confused because you need to tell the runtime system to use all capabilities with command-line options, ReinH aand ab9rf.
14:17:30 <kamyar> ReinH: What is ur opinion?
14:17:33 <ab9rf> Tuplanolla: i know
14:17:51 <ab9rf> Tuplanolla: but there's some underlying expectation-management issues here, i think
14:18:53 <ReinH> Putting Warp behind nginx would be redundant.
14:19:47 <kamyar> ReinH: Yes I meant so
14:20:13 <kamyar> But it is normal in Python or so
14:20:23 <kamyar> Nginx+uwsgi
14:20:48 <ReinH> Yes, because nginx provides some benefits in those cases.
14:21:06 <kamyar> ReinH: Like using async model and worker threads
14:21:08 <ReinH> Warp does not need nginx to provide those benefits in general.
14:21:15 <ReinH> Yes.
14:21:39 <kamyar> ReinH: So Warp must be able to use implicit async and worker threads
14:21:43 <ReinH> Warp is a high performance, concurrent web server. You don't need to put another high performance, concurrent web server in front of it.
14:21:50 <ReinH> I don't see how that follows at all.
14:21:56 <ReinH> Warp is *designed* to be concurrent.
14:22:07 <ReinH> Its concurrency is explicit.
14:22:12 <pikajude> nginx is a great reverse proxy though
14:22:14 <kamyar> ReinH: Let me clarify my question then
14:22:28 <ab9rf> you still have to write your app to be concurrent
14:22:50 <kamyar> I have written an web application which serves some RESTful services
14:23:21 <ReinH> Ok, let me just say a few things that might clear up some misunderstandings.
14:23:21 <kamyar> Can I be sure when deploying the application in real world production server, all my cores would be used in high hit?
14:23:43 <ab9rf> obviously not 
14:23:43 <ReinH> First, Haskell code must be written with explicit parallelism or concurrency. GHC does not make anything parallel for you.
14:23:54 <ab9rf> but there's no web platform that can make that guarantee
14:23:59 <ReinH> Second, Haskell programs must be configured to support threading when compiled and when run.
14:24:36 <ReinH> GHC does have concurrency features in the runtime, but they must be explicitly used.
14:25:26 <ReinH> This configuration is generally done in a cabal configuration file for compilation and by passing (or baking in) RTS options when run.
14:26:15 <ReinH> How efficiently your program can use your cores depends entirely on how it's written.
14:28:00 <ReinH> (well, and how it's compiled and executed)
14:29:28 <barcabuona> theoretically tho, ghc could enable automatic parallelization no?
14:29:37 <barcabuona> without excplicit code
14:29:53 <Tuplanolla> For what purpose, barcabuona?
14:29:55 <ab9rf> barcabuona: theoertically, but it would make the code run more slowly as often as it made it run faster
14:29:56 <ReinH> Yes, it's not hard to do. It's hard to do well enough to be usable.
14:30:23 <kadoban> Theoretically, sure. It's probably possible in most cases, but who knows how to do it well?
14:30:25 <barcabuona> Tuplanolla: to have a fully multithreaded program without having to use multithreading?
14:30:45 <ReinH> We don't have the technology.
14:31:11 <barcabuona> is this the same issue as view serialization?
14:31:11 <ab9rf> go invent it, you'll be faous
14:31:14 <ab9rf> famous
14:31:23 <ReinH> OTOH, it can be easier to add parallelism to Haskell than most other runtimes.
14:31:38 <ab9rf> and easier to add it correctly, too
14:32:32 <ReinH> The power to weight ratio of explicit parallelism in Haskell is pretty high.
14:32:33 <ab9rf> i killed far too many philosophers back when i was doing concurrent programming in the late 90s
14:33:08 <ReinH> Marlow's book has a lot of nice examples
14:33:39 <barcabuona> still it'd be worth a shot maybe
14:33:53 <barcabuona> even for fun
14:34:03 <ReinH> No one is stopping people from trying.
14:34:03 <kadoban> ab9rf: xD
14:34:35 <EvanR> in Data.Map.Merge.Strict, i am having trouble type checking beause of this random Applicative f 
14:34:45 <EvanR> f is ambiguous, and i dont even know why its there
14:35:58 <kadoban> EvanR: Is that the right module name? Not finding it.
14:36:11 <EvanR> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Merge-Strict.html
14:36:48 <kadoban> Weird, wonder why hayoo doesn't find that. *looks*
14:39:08 <Gurkenglas> Why does intero keep suggesting that I add {-# LANGUAGE safe #-}?
14:39:15 <kadoban> EvanR: Don't you usually just use SimpleWhenMissing and SimpleWhenMatched ? Though to be honest I'm not clear on what the f does either practically.
14:39:39 <EvanR> i just realized that and am writing large SimpleWhenMissing foo bar baz annotations into my code
14:41:51 <thang1> Gurkenglas: "Safe haskell is a new language pragma for GHC which allows you to run untrusted code on top of a trusted codebase"
14:41:56 <thang1> http://blog.ezyang.com/2012/09/common-misconceptions-about-safe-haskell/ 
14:42:01 <EvanR> curious why the f is there since its a current PITA
14:42:15 <thang1> You'll probably find a reason for why intero is asking you to add the safe pragma
14:42:34 <Rumia_> So what's the easiest way to force a Haskell tree to be a DAG, I would prefer something better than making it strict and catching out of heap exceptions. 
14:43:02 <Gurkenglas> thang1, if I apply it it can't parse that pragma. Does it mean Safe rather than safe?
14:46:32 <Rumia_> I  would expect it to need capital s "Safe".
14:47:27 <thang1> ahh yep, it's LANGUAGE Trustworthy and LANGUAGE Safe, not 'safe'
14:48:37 <thang1> No idea why intero wants 'safe' then. Have you tried reloading it?
14:49:58 <geekosaur> tbh I thought ghc parsed language pragmas case-independently...
14:51:01 <Eduard_Munteanu> Rumia_, perhaps you can label nodes with monotonically-increasing numbers and check this invariant with a breadth-first traversal.
14:52:50 <Rumia_>  Hmm. 
14:54:10 <juanpaucar> Hi, does somebody know if Hakyll has support for multilingual blogposts?
14:54:45 <jaspervdj> juanpaucar: I think the `version` stuff would be your best bet -- https://jaspervdj.be/hakyll/tutorials/06-versions.html
14:55:13 <juanpaucar> oooh jaspervdj: thanks :)
14:55:23 <jaspervdj> geekosaur: I don't think so, I always mess up capitalisation in MultiParamTypeclasses
14:55:27 <roconnor> Rumia_: I'm confused.  Every tree is a DAG.
14:56:09 <roconnor> Rumia_: or is the worry about infinite trees?
14:56:17 <ReinH> It's easy to detect cycles when *constructing* a graph by maintaining a set of seen vertices and checking for membership.
14:56:37 <Rumia_>  Roconnor: yes. 
14:57:17 <ReinH> Once you find a member, you check if its path forms a cycle.
14:58:40 <iqubic> What's the difference between a vector and an array in haskell???
14:58:43 <roconnor> Rumia_: I'm going to go out on a limb and say it is impossible to enforce finiteness of structures in Haskell.
14:58:51 <ReinH> when you insert (u,v) you check for a path from v to u
14:58:57 <ReinH> but you only need to do this if v has been seen before
14:59:02 <roconnor> And still allow arbitrary finite values.
14:59:16 <Rumia_> Yes. 
15:00:06 <ReinH> DFS/BFS will find a path from v to u.
15:00:31 <Rumia_>  Right. That makes sense. 
15:00:46 <ReinH> This is asymptotically better than doing connected components every time you insert an edge or whatever.
15:00:57 <Rumia_>  Right. 
15:01:00 <kadoban> iqubic: Typically a vector is also known as a "dynamic array", its size can change. This is true of the usual array and vector packages in haskell.
15:01:07 <Rumia_>  Thanks. 
15:01:26 <hexagoxel> what happens when you dependent-type the depth and then try to tie a knot?
15:01:30 <geekosaur> iqubic, Array is older, allows any type with an Ix instance to be used as an index, thus allowing you to specify e.g. arrays whose indices range from -5 to 5 or etc.
15:01:57 <geekosaur> Vector is newer and a bit faster but doesn't support semi-arbitrary index types like Array does
15:02:11 <roconnor> ReinH: What stops users from building infinite trees?
15:02:21 <ReinH> roconnor: a smart constructor.
15:02:22 <roconnor> with infinite vertices?
15:02:26 <ReinH> oh, infinite trees
15:02:36 <ReinH> infinite trees are not cyclic DAGs
15:02:43 <iqubic> geekosaur: can I have a 2D vector?
15:02:45 <roconnor> Rumia_'s trees are already dags.
15:02:45 <ReinH> I didn't claim to prevent infinite trees.
15:02:58 <ReinH> Yes, trees are DAGs.
15:03:00 <iqubic> and do I need to re-write my code to use Vector instead of Array?
15:03:02 <ReinH> I'm not sure where we're disagreeing.
15:03:04 <roconnor> Rumia_ asked how to make sure all trees are DAGs but trees are always dags.
15:03:05 <Rumia_> Well in my case there's a limit of total node ids.
15:03:37 <ReinH> roconnor: Since the question didn't make sense, my brain rewrite it to "avoiding cycles".
15:03:41 <ReinH> *rewrote
15:03:47 <ReinH> and then I answered that question instead.
15:03:50 <geekosaur> iqubic, as I understand it, "no" and "yes" respectively
15:03:56 <Rumia_> Which is what I meant. 
15:04:06 <geekosaur> (that is, you need to make a Vector containing Vectors, and you must rewrite)
15:04:29 <iqubic> geekosaur: I need to re-write my code??? Why??
15:04:33 <kadoban> Vectors are typically faster? That's somewhat interesting.
15:04:35 <ReinH> roconnor: This was not a conscious process :)
15:04:37 <Rumia_>  The infinite distinct nodes situation is easy to rule out. 
15:04:44 <geekosaur> different API
15:04:49 <Eduard_Munteanu> A 2D vector can be represented as a 1D vector with an easy coordinate transformation.
15:05:00 <geekosaur> Array's API is a an older design
15:05:15 <geekosaur> also supporting the various tricks Ix gives you that Vector doesn't
15:05:19 <roconnor> ReinH: heh okay.  I'll stay out of this since I have no idea what was is meant.
15:05:22 <EvanR> very smart constructor
15:05:28 <ReinH> roconnor: I mean you are entirely correct of course.
15:05:40 <iqubic> geekosaur: Is it worth the effort of rewriting my code to use Vector instead of Array?
15:05:50 <ReinH> roconnor: What you missed was that the question Rumia_ asked was not, in fact, the one they wanted answered. ;)
15:06:00 <EvanR> i heard REPA uses Array Int
15:06:07 <Eduard_Munteanu> Do they already have a Mensa chapter for those constructors? :P
15:06:15 <iqubic> What is REPA?
15:06:17 <ReinH> roconnor: And to be fair I only figured that out by accident.
15:06:29 <EvanR> https://hackage.haskell.org/package/repa
15:06:35 <geekosaur> iqubic, that I cannot tell you
15:06:54 <EvanR> regular polymorphic parallel arrays
15:06:56 <kadoban> I'm typically quite happy with the 'array' package if it matters.
15:07:25 <ReinH> If you're using Int indices, there isn't much difference. If you aren't, there's only one choice.
15:07:37 <ReinH> So the choice is either arbitrary or made for you.
15:08:22 <iqubic> I'm using (Int, Int)
15:08:41 <iqubic> Simply because I want a 2D array
15:09:08 <kadoban> Then unless arrays are giving you a particular problem, not sure why to rewrite using vector?
15:09:11 <ReinH> If the array is fixed size, you can also use a Vector and a coordinate transform like Eduard_Munteanu mentioned, but Array should be fine.
15:09:14 <ab9rf> if trees are dags, does that mean that they're made of dagwood?
15:09:25 <ReinH> They're good dags brent
15:09:35 <osfameron> ;-)
15:10:02 <iqubic> ReinH: My arrays are a fixed size.
15:10:13 <iqubic> It will be set once, and never changed.
15:10:19 <ab9rf> until it has to be
15:10:38 * hackage base-feature-macros 0.1.0.1 - Semantic CPP feature macros for base  https://hackage.haskell.org/package/base-feature-macros-0.1.0.1 (HerbertValerioRiedel)
15:11:05 <Tuplanolla> Still making that game, iqubic?
15:11:24 <Gurkenglas> codex doesn't make tags for ''Asd given tags for Asd? :/
15:11:57 <iqubic> Tuplanolla: I finished the game.
15:12:08 <iqubic> Just thinking about optimizing it.
15:13:49 <ab9rf> it's not good enough until you get the frame rate above 1000 fps
15:14:09 <pikajude> i'm fine with 144
15:14:15 <pikajude> or about 100 if it's a third-person game
15:14:44 <iqubic> ab9rf: It's a text based game
15:15:39 <pikajude> should be able to get super high fps then ideally
15:15:52 <EvanR> depends on your terminal emulator
15:15:57 <EvanR> xterm is the fastest ime
15:16:02 <pikajude> depends on your display
15:16:30 <EvanR> depends on level of videophile delusion youre on
15:16:52 <pikajude> and this is now off topic
15:17:23 <Eduard_Munteanu> Videophile, text based... choose one.
15:17:40 <EvanR> no. aalib
15:17:51 <Eduard_Munteanu> Or libcaca.
15:20:51 <thang1> EvanR: there's a terminal being written in Rust that's the fastest out there right now :p
15:21:02 <EvanR> oh geez
15:21:32 <thang1> http://blog.jwilm.io/announcing-alacritty/
15:21:32 <pikajude> it's nice, but it doesn't work on windows
15:21:37 <pikajude> and iterm is more useful on mac
15:22:06 <thang1> it's a GPU accelerated terminal using openGL
15:22:58 <thang1> Aclarity is targeting windows, osx, and linux
15:23:24 <pikajude> it's targeting osx and linux atm
15:23:36 <thang1> It's targeting all 3, it just currently doesn't have windows as it's a 0.1 release, bla bla, but still I find the project interesting and hope it does well.
15:25:34 <Gurkenglas> How do I make intero add its infered type as a signature? It suggests to do so sometimes but not always.
15:28:07 <sm> iqubic: "I finished the game." - nice! We don't hear that enough. 
15:29:00 <thang1> Yeah more often it's "aw crap, I lost The Game"
15:32:54 <sm> can we play it ?
15:41:12 <iqubic> Not right now.
15:42:04 <sm> one TUI "optimisation" I found: crank up the key repeat rate
15:42:38 * hackage mercury-api 0.1.0.0 - Haskell binding to Mercury API for ThingMagic RFID readers  https://hackage.haskell.org/package/mercury-api-0.1.0.0 (ppelleti)
15:47:24 <ph88^> how can i find out if my program is IO bound or CPU bound ?
15:48:05 <kadoban> ph88^: Easy way in general is just look at CPU usage. Are you pinning it to 100% or not?
15:48:34 <ph88^> kadoban, dunno haven't looked .. are there any specific tools to monitor the program or should i just use htop ?
15:48:52 <ab9rf> initially, os tools like (h)top are adequate
15:48:56 <thang1> htop is fine. You're not looking for super scientific exact measurements
15:49:13 <ab9rf> there are more detailed methods of instrumentation if you need more detail
15:49:19 <kadoban> For a really basic first pass that'll be fine, yeah.
15:52:38 * hackage generic-records 0.2.0.0 - Magic record operations using generics  https://hackage.haskell.org/package/generic-records-0.2.0.0 (kcsongor)
16:00:39 <ph88^> data MyData a = Foo a | Bar a | Qux a      fmap (\d -> case d of {  }) (Maybe (Foo 1))    how can i make this so that inside the case i do something to that value of i have a Foo   or  otherwise the resulting value will be Nothing ?
16:01:08 * hackage katip 0.3.1.5 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.3.1.5 (MichaelXavier)
16:02:21 <kadoban> ph88^: Well, that's not going to match the type of fmap, or follow the laws if it did.
16:02:43 <kadoban> Oh wait, maybe I misread.
16:03:12 <ph88^> ye i need to change that code around
16:03:13 <sproingie> if MyData is a functor, fmap on MyData has to return a MyData
16:03:22 <ph88^> maybe not use fmap at all ..
16:06:56 <Sonolin> yea ph88^ you can just do case on a Maybe value like `case d of (Just (Foo x)) -> ...`
16:07:14 <orzo> Having trouble googling this:  How do I unquote, or anti-quote, a haskell symbol within a [| ... |] block?
16:07:22 <bollu> @tell quchen: I now understand why we have rule 17: to simplify partial applications of functions
16:07:22 <lambdabot> Consider it noted.
16:07:25 <pikajude> like $()?
16:07:36 <pikajude> i forget what anti-quoting is
16:07:39 <orzo> pikajude: is that my answre?
16:07:39 <sproingie> splice
16:07:43 <bollu> @tell quchen: thanks for all the help! I suppose it's like learning what a monad is, you need to go through the pain yourself :P
16:07:43 <lambdabot> Consider it noted.
16:07:45 <pikajude> splicing?
16:07:47 <pikajude> use $(foo)
16:09:06 <orzo> hm, it's not working.  I actually have a [d| ... |] block and i'm trying to declare a variable within whose name was defined outside
16:09:44 <orzo> so i have name::Name and namevar = VarE name
16:09:48 <ph88^> Sonolin, it works .. but looks ugly .. Just bloat   https://bpaste.net/show/289d7e0b12ed
16:10:05 <pikajude> $(varE name)
16:10:07 <pikajude> should work
16:11:42 <orzo> hm, Invalid type signature: $(varE name) :: ...
16:12:21 <Sonolin> ph88^ I mean I guess you could use join with fmap
16:12:33 <Sonolin> but its not going to get much better IMO
16:13:20 <ph88^> hmm don't have experience with join
16:13:37 <Sonolin> @t join
16:13:37 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
16:13:54 <Sonolin> join :: Monad m => m (m a) -> m a
16:14:13 <Sonolin> join . fmap Just $ Just 5
16:14:18 <Sonolin> > join . fmap Just $ Just 5
16:14:20 <lambdabot>  Just 5
16:14:27 <Sonolin> > join . fmap (const Nothing) $ Just 5
16:14:27 <pikajude> orzo: oh, no, you can't do that
16:14:29 <lambdabot>  Nothing
16:14:32 <pikajude> you have to splice the entire type signature
16:14:45 <pikajude> oh, wait, no
16:14:47 <pikajude> varE produces an expression
16:14:50 <pikajude> is varD a thing?
16:15:02 <pikajude> oh wait, it shouldn't be var, that's preposterous
16:15:07 <pikajude> it should be $(nameD name) :: ...
16:16:37 <orzo> having trouble finding haddock for nameD.  Should i try anyway?
16:16:48 <pikajude> i hope it's real
16:17:27 <pikajude> ok, no, nameD doesn't exist
16:17:47 <pikajude> like i said originally before i corrected myself twice incorrectly, you need to splice the entire signature
16:17:54 <pikajude> i don't believe TH can handle splicing part of it
16:19:39 <glguy> pikajude: I haven't been following, but is this relevant? example :: Bool -> $([t| Bool |]); example = not
16:19:53 <pikajude> yeah
16:20:03 <pikajude> glguy: i don't think $(name) :: Foo -> Bar is valid syntax though, is it
16:20:16 <glguy> OK, no, you can't splice in a name directly
16:20:36 <orzo> alright, sucks, but thanks guys
16:20:52 <glguy> It would be: valD name [t| some -> type |]
16:21:02 <pikajude> i thought it would be sigD
16:21:06 <glguy> oh
16:21:10 <glguy> yeah, it would be that
16:21:18 * glguy goes back to work
16:21:18 <pikajude> http://hackage.haskell.org/package/template-haskell-2.11.1.0/docs/Language-Haskell-TH-Lib.html#v:sigD
16:27:38 <ph88^> kadoban, it maxes out on cpu
16:35:38 <orzo> well, now i'm trying to use this: $(varE tblname) within a [| ... |] block and it says there's no instance Language.Haskell.TH.Syntax.Lift for Name
16:35:55 <orzo> surely there's a way to embed that in there
16:36:17 <orzo> this is a String i made a Name out of
16:36:32 <orzo> so i just want to embed that String as the symbol
16:37:04 <pikajude> why not embed the name as the symbol instead
16:37:36 <orzo> i dont understand
16:37:45 <pikajude> you said you want to embed a string as a symbol
16:37:52 <orzo> yeah, but tblname :: Name
16:37:55 <pikajude> oh ok
16:37:59 <pikajude> idk, maybe paste code
16:37:59 <orzo> i'm just giving you info that i have a String
16:38:13 <orzo> so if you can tell me how to do it with a String, that would be just as good
16:38:27 <sproingie> there's a type-level symbol extension that might be handy
16:38:39 <sproingie> (or not, my TH knowledge is laughable)
16:38:39 <glguy> probably not for this though...
16:39:19 <kadoban> ph88^: Pretty good sign that it's CPU bound then, at least in the current implementation of course.
16:41:15 <glguy> I'm going to put my money down on a syntax error where the $ in the splice got pulled away from its "argument"
16:41:25 <glguy> e.g.  $(...) vs $ (...)
16:41:53 <pikajude> yeah, that's what the Lift for Name message reminds me of
16:42:00 <glguy> orzo: If you were pasted code and error messages we could just help you directly
16:42:54 <lpaste> orzo pasted “template-haskell issues” at http://lpaste.net/356057
16:43:36 <orzo> you can see on line 7 and 12, i use $(varE tblname) which is the issue
16:43:40 <orzo> i think
16:43:44 <glguy> I don't see the error message
16:45:00 <orzo> i attempted to add the error message as an annotation
16:45:50 <glguy> the error message wasn't even for the same code as pasted?
16:46:10 <orzo> it should be
16:46:20 <orzo> Database/LMDB/Macros.hs:242:26: error:
16:46:24 <orzo> that's the error i'm trying to fix
16:46:40 <glguy> The bit of code displayed in the error message doesn't match the code above it
16:47:12 <orzo> it seems to match for me
16:47:25 <orzo> error message mentions fbody <- [| unsafePerformIO
16:47:31 <orzo> which should be in my paste
16:47:39 <glguy> for example readIORef ($tblnameE)
16:47:42 <orzo> lines 6 of my paste
16:47:42 <iqubic> What's the best way to sort a Ord a  => [a]?
16:47:44 <glguy> that's not in the paste
16:47:52 <glguy> sort
16:48:06 <iqubic> :t sort
16:48:08 <lambdabot> Ord a => [a] -> [a]
16:48:19 <iqubic> Cool. What algorithm does that use?
16:48:23 <orzo> uh, guess its a different iteration, but the error is the same with but says: readIORef ($(varE tblname));
16:48:57 <orzo> should i make another annotation?
16:49:38 <Sonolin> iqubic it depends on the implementation of the Ord class for the underlying type in the list
16:49:45 <Sonolin> > sort [1,10,11,2,20,21,3,30]
16:49:47 <lambdabot>  [1,2,3,10,11,20,21,30]
16:49:53 <Sonolin> sort $ map show [1,10,11,2,20,21,3,30]
16:49:54 <orzo> i edited in the matching error
16:49:56 <dmj`> @src sort
16:49:56 <lambdabot> sort = sortBy compare
16:50:04 <Sonolin> > sort $ map show [1,10,11,2,20,21,3,30]
16:50:07 <lambdabot>  ["1","10","11","2","20","21","3","30"]
16:50:33 <iqubic> Sonolin: That's how it compares the numbers. I want to know what sorting algorithm it uses.
16:50:35 <ph88^> kadoban, you think it's time to parallelize ?
16:50:38 <Sonolin> oh nm you asked the algorithm
16:50:52 <Sonolin> well at least I'm 1 for 2 today >.>
16:53:20 <orzo> glguy: do you see the matching error now?
16:54:39 <jle`> is it too late for me to snea a MonadIO instance for Proxy into base
16:54:43 <jle`> for ghc 8.2
16:54:53 <jle`> oh, should be asking in #ghc
16:54:59 <dmj`> @src sortBy
16:54:59 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
16:54:59 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:55:39 <dmwit_> ?tell iqubic In GHC, sort is a merge sort. This is nice for laziness reasons.
16:55:39 <lambdabot> Consider it noted.
16:55:59 <dmwit> ?src MonadIO
16:56:00 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:57:07 <pikajude> class MonadIO m where liftIO :: IO a -> m a
16:57:11 <pikajude> there you go
16:57:48 <dmwit> Proxy has some really stupid instances. =P
16:59:23 <jle`> it obeys all of the laws
16:59:30 <jle`> it is a valid monad homomorphism
16:59:38 <dmwit> I wouldn't argue against having it. Stupid can be nice.
16:59:43 <ph88^> in the cabal file there is category, what are valid categories ?
17:00:15 <dmwit> ph88^: Anything goes. See http://hackage.haskell.org/packages/ for a list of things people have used in the past.
17:00:21 <dmwit> Numbers in parentheses give popularity.
17:00:37 <ph88^> oki
17:00:41 <jle`> i like the idea of Proxy as being some sort of terminal object in a category of monad homomorphisms
17:00:46 <orzo> Apparently Name implements Data, and there is a dataToExpQ function..  Maybe that could help?
17:00:52 <dmwit> ph88^: I had a list lying around somewhere with the categories sorted by popularity, let me see if I can dig it up.
17:01:04 <pikajude> @type (Proxy >>=)
17:01:05 <lambdabot> (a -> Proxy b) -> Proxy b
17:01:06 <ph88^> :P
17:01:08 <pikajude> awesome
17:01:14 <orzo> also a liftData
17:01:42 <jle`> also there needs to be a ProxyT with MonadTrans instance, which acts as a Zero in the composition of monad transformers
17:01:58 <jle`> f . ProxyT = ProxyT, ProxyT . g = ProxyT
17:02:13 <jle`> in the same way that IdentityT is a 1
17:02:48 <dmwit> ph88^: I couldn't dig it up. It's not hard to create yourself with a bit of editor macro, though.
17:03:27 <dmwit> jle`: type ProxyT m = Proxy -- ?
17:03:40 <dmwit> Oh, but you can't give a lift for that. Okay.
17:04:45 <jle`> type ProxyT = Curry Proxy
17:05:16 <dmwit> yikes
17:05:44 <orzo> glguy: maybe there's something special i have to do to enable $(...) to be interpreted?
17:06:03 <orzo> i have {-# LANGUAGE TemplateHaskell #-}
17:06:36 <jle`> data Curry :: ((s, t) -> Type) -> s -> t -> Type where Curry :: p '(a, b) -> Curry p a b
17:06:53 <jle`> @let data Curry :: ((s, t) -> Type) -> s -> t -> Type where Curry :: p '(a, b) -> Curry p a b
17:06:54 <lambdabot>  .L.hs:171:26: error: Not in scope: type constructor or class ‘Type’
17:06:54 <lambdabot>  
17:06:54 <lambdabot>  .L.hs:171:45: error: Not in scope: type constructor or class ‘Type’
17:07:02 <jle`> @let import Data.Kind
17:07:04 <lambdabot>  Defined.
17:07:05 <jle`> @let data Curry :: ((s, t) -> Type) -> s -> t -> Type where Curry :: p '(a, b) -> Curry p a b
17:07:07 <lambdabot>  Defined.
17:07:15 <jle`> :k Curry Proxy
17:07:16 <lambdabot> s -> t -> Type
17:07:18 <jle`> woo hoo
17:08:03 <jle`> @let instance MonadTrans (Curry Proxy) where lift _ = Curry Proxy
17:08:04 <lambdabot>  Defined.
17:08:05 <pikajude> curry proxy is how i order delivery food from other countries
17:08:17 <jle`> :)
17:08:36 <ph88^> hey guys, i tried to parallelize my code, but it's going slower than before, what could be wrong with it ?
17:08:57 <drewbert> ph88^: global interpreter lock
17:09:23 <ph88^> python talk ?
17:09:28 <drewbert> ph88^: sorry, bad joke
17:09:46 <dmwit> ph88^: Lots of possibilities. But one common one is to forget to add -threaded to the compile line and +RTS -N to the program run line.
17:11:45 <orzo> glguy: any chance you're still looking at my issue?
17:12:33 <pikajude> orzo: which one is line 242
17:12:51 <ph88^> dmwit, how can i give that +RTS -N as default option during compile time ?
17:13:02 <pikajude> also, why does the error message say ($tblnameE)
17:13:07 <pikajude> can anyone explain that one to me
17:14:17 <orzo> pikajude: different iterations, you should have both error messages if you refresh, the one below will show varE tblname instead
17:14:49 <pikajude> but isn't it trying to lift name'?
17:14:50 <pikajude> not tblname
17:14:53 <pikajude> that's what the error says
17:14:56 <dmwit> ph88^: Dunno. But you can override with setNumCapabilities.
17:15:11 <ph88^> ah ok
17:15:12 <ph88^> thx
17:15:13 <ph88^> ill try
17:15:17 <pikajude> orzo: tbl <- Multi (baseName name' ++ "_" ++ str) <$> newTVarIO NotStarted
17:15:19 <pikajude> that's what the problem is
17:15:22 <dmwit> ph88^: I think there is a way to specify default runtime options. Perhaps troll through the GHC manual for a bit and see if you can find it.
17:15:43 <orzo> pikajude: thanks
17:15:48 <pikajude> you're producing an AST there, but you're just putting name' in, meaning it needs to be liftable
17:15:53 <pikajude> i.e. turned from a value into the AST of that value
17:15:55 <pikajude> which Name doesn't implement
17:15:58 <dmwit> ph88^: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#setting-rts-options-at-compile-time looks like a promising heading
17:16:01 <pikajude> for hopefully obvious reasons
17:16:16 <pikajude> String, however, does implement Lift
17:17:27 <orzo> there's a liftString though
17:17:40 <pikajude> i thought String implemented Lift
17:17:46 <pikajude> if it doesn't, you can just use $(stringE myString)
17:17:53 <pikajude> but i really thought it did
17:18:05 <orzo> it's compiling now, i have a fix after you put my attention in the right place
17:18:15 <ph88^> dmwit, i found it .. but the program is even slower than before :/
17:20:00 <lyxia> maybe your program is actually not parallelizable, or your parallelization is too fine grained.
17:22:00 <ph88^> i use parMap on a list of 367 numbers .. each number is input for a function that does a lot of lookups in an Unboxed Vector
17:22:52 <lyxia> you mean output?
17:23:19 <Welkin> are there any syntax highlighters that work with purescript?
17:23:38 <Welkin> or even work properly with haskell?
17:23:52 <Welkin> I think pandoc works decently (if I remember correctly)
17:24:27 <Welkin> I'm using jekyll though, not hakyll, so I am not sure how I would hook pandoc up to it
17:25:06 <Welkin> there is a javascript solution that works very well, but it parses in real time when the page loads 
17:25:19 <lyxia> ew
17:25:26 <Welkin> this thing https://highlightjs.org/
17:25:47 <ph88^> lyxia, no i mean that my 367 numbers are an argument to a function that does those lookups .. i get from that function only 1 number back .. so i also get 367 results
17:26:52 <Welkin> it actually does a great job compared to the crap job that pygments does
17:27:19 <Welkin> maybe I'll just use this o.o
17:27:33 <lyxia> ph88^: I don't understand what you said because it sounds self-contradictory.
17:28:23 <ph88^> lyxia, i just mean   map (myFunction :: Double -> Double) [1..367]    i was parallelizing that with parMap
17:33:19 <bgrady_> join #haskell
17:34:32 <ph88^> welcome bgrady_ 
17:46:41 <ph88^> so this function takes up the main time in my program https://bpaste.net/show/98f27a726c72 i have an image here where the bigger squares take more time https://i.imgur.com/dJGikql.png   anyone a suggestion how to optimize this little piece of code ?
17:50:00 <ph88^> i'm not really sure if this is fair to measure this way .. the profile build does it in 200 seconds .. when build with all optimization it's only 13 seconds  for a small workload
17:51:04 <manek> Hello guys! :) I've got just a regular text file encoded as UTF8. What is the most performant way to read it into Unboxed.Vector Char ? I guess reading it as String and converting to Vectors is not what I'm looking for
17:52:20 <Welkin> what?
17:52:25 <Welkin> why would you do that at all?
17:52:29 <Welkin> read it as a ByteString
17:53:34 <pikajude> yeah, i can't think of a reason to do that
17:53:39 <Welkin> if you are going to process it in some way that you need to be aware of the unicode values, read it as Text
17:55:38 <manek> yeah, so basically I could use Data.ByteString.UTF8 and the "decode" function to decode Char by Char or I can use Text but then I've got double conversion - to UTF16 and then back to Char (whcihc basically is UTF32)
17:56:21 <Maxdamantus> What do you intend to do with the "UTF32"?
17:56:25 <manek> both ways seem a little overcomplicated, however the "decode" function from bytestring seems to be the nicest lookign option if it is implemented in a performant way
17:56:44 <manek> Maxdamantus: I need a buffer with fast access to different text parts
17:57:08 <Maxdamantus> ByteString gives you that.
17:57:36 <Maxdamantus> The text just happens to still be in UTF-8 instead of some other arbitrary encoding.
17:57:40 <manek> Maxdamantus: I dont think so. Bytestring allows me to access different bytes, but unicode chars can consist of several bytes
17:58:14 <Maxdamantus> unicode chars can also consist of several codepoints (or UTF-32 code units)
17:58:20 <manek> Maxdamantus: If I read UTF8 to ytestring I have to decode it to knwo the Chars and I cannot acces i-th Char in O(1), am I wrong?
17:58:35 <Maxdamantus> so Char doesn't really help with much
17:58:43 <manek> Maxdamantus: sure, but whe nI keep them in Unboxed.Vector Char I can access them in O(1)
17:59:23 <kadoban> Maxdamantus: Well, it handles a lot more text better than just using raw ByteString would at least.
17:59:25 <manek> Maxdamantus: can we assume that Haskell's Char type can keep any character?
17:59:29 <Maxdamantus> But why is it more useful to access the codepoints in O(1) than it is to access the UTF-8 code units in O(1)?
17:59:53 <Maxdamantus> manek: not for any sensible meaning of "character"
18:00:27 <manek> Maxdamantus: Ok, right. I meant any character that can be found in a program source code, assuming we support "some" unicode characters
18:00:46 <manek> Maxdamantus: (the text Im processing is a source code)
18:01:06 <Maxdamantus> > Text.pack "a\769"
18:01:08 <lambdabot>  error:
18:01:08 <lambdabot>      Not in scope: ‘Text.pack’
18:01:08 <lambdabot>      No module named ‘Text’ is imported.
18:02:43 <Maxdamantus> Anyway, the string above consists of two Chars but practically one character (á)
18:03:59 <Maxdamantus> If you're doing things like searching for substrings, that works perfectly well in UTF-8
18:04:17 <Maxdamantus> or .. at least as well as it does in [Char]s
18:04:29 <Clint> provided you normalize
18:04:39 <kadoban> manek: What operations are you doing on the text, out of curiosity? By the way I don't necessarily see a reason to avoid String for this. If I understand correctly, if you're just throwing that in a Vector, GHC will probably be able to optimize away the whole actual String part I thought.
18:04:50 <Welkin> big-o notation has nothing to do with real-world performance
18:05:07 <kadoban> It's kind of the logical equivalent of a while loop or something, in this kind of case.
18:05:20 <Welkin> I used String for a parser on humongous files
18:05:30 <Welkin> and it was more than fast enough
18:05:31 <kadoban> Welkin: It has something, but not everything to do with real-world performance.
18:05:58 <manek> kadoban: I'm mapping parts of text into visual representation of a program. By visaul representation I mean a node-based system. We currently handle it other way around, but we need to have better access here, preferably O(1) one
18:06:11 <Welkin> only optimize when you need to, never before
18:06:44 <thang1> That being said, don't lock yourself into doing things the naive way either :p
18:07:32 <manek> Welkin, thang1 : sure, but If you see that a particular part is crutial for your application and you know what way would give you performance boost, why not think about it and implement it in a better way? :)
18:08:11 <Rotaerk> optimize after you've got something working
18:08:27 <thang1> Make it work, then make it pretty, then make it fast
18:08:28 <manek> kadoban: I was wondering the same. If GHC would be wise enough to optimize it or I should go over Bytestring to get better performance and just "never" use String
18:08:55 <pacak> manek: There are cases when String is faster.
18:08:55 <Rotaerk> if you try to optimize prematurely, you risk optimizing the wrong things, or optimizing them incorrectly
18:09:01 <Rotaerk> (in the case of design optimization)
18:09:04 <sproingie> maybe you should fret about performance when you have something to actually measure
18:09:48 <Rotaerk> e.g. code brevity is something that can be optimized through abstractions; don't abstract prematurely or your abstractions may not generalize very well
18:10:07 <pacak> There's a huge overhead for  small ByteStrings, plus they are pinned so having lots of them in memory might mess up GC.
18:10:45 <sproingie> sounds like Text might be the sweet spot
18:10:51 <dmwit> manek: There is some double-encoding overhead with Text/UTF-8, but I believe there was a SoC that suggested it's smaller than you would guess at first. I would suggest using Text to begin with.
18:11:04 <kadoban> Except Text has Θ(n) indexing, and it sounds like they need indexing.
18:11:04 <sproingie> vacillating endlessly is the least optimal algorithm
18:12:43 <dmwit> Well. You could use Seq Char... =P
18:12:49 <kadoban> manek: Well, ByteString has a different meaning than String, so those aren't usually the competing alternatives for me.
18:13:03 <kadoban> Sometimes it doesn't matter, but rarely.
18:13:04 <dmwit> There's also the rope package. Not sure if it's production-ready, though.
18:15:29 <manek> Ok, thank you guys really very much for the discussion. It gave me some new light on thi topic
18:15:44 <dmwit> Oh, I see he's already considering Vector. That seems plausible, too.
18:15:52 <manek> dmwit: I know rope, I need slightly different thing here though
18:16:42 <dmwit> Probably if you want high performance, you'll have to write a decoder for your specific target type. I would shy away from that -- too easy to get it wrong.
18:16:48 <dmwit> But that's me.
18:17:14 <kadoban> I don't see a lot wrong with a Vector of Char, assuming that indexing is a very common operation. And going via String doesn't seem like an obviously bad thing to do either. It is my understanding that this is one of those cases where String isn't really a problem, though I'm having a bit of trouble formulating why or coming up with corroboration
18:17:46 * dmwit == kadoban
18:18:39 <kadoban> I *think* the really bad uses of Char are where they're large and they stick around for a long time, not just as a transit between two other things in a tight package.
18:19:51 <dmwit> Well. Traversing them is also very cache unfriendly compared to e.g. unboxed vectors. Lots of pointer lookups.
18:20:24 <dmwit> I think that is one of the big drivers of performance wins when using ByteString or Text.
18:20:59 <sproingie> how poor is the reference locality for the average String?
18:21:10 <dmwit> I think I would want to compare going ByteString -> Text -> Vector Char and ByteString -> String -> Vector Char to see which was faster experimentally.
18:21:13 <sproingie> potentially it could be all over the place, wondering what it's like in reality
18:22:32 <kadoban> dmwit: But in this case it'd probably be fused (is that the right term?) anyway and just be a tight loop, wouldn't it? At least that'd what I'd hopefully expect from GHC.
18:22:58 <dmwit> kadoban: I'd hope for similar, and experiment to see how my hopes held up. =)
18:23:05 <kadoban> Hehe, sounds like a plan then.
18:24:55 <manek> dmwit: are you planning to test it ? I'm asking just of cursiosity becauseI'm going over String now (I've got a really tight shedule now), but I'm very curious about the results too
18:25:17 <Maxdamantus> Interesting .. Data.Text internally stores its strings in UTF-16 .. wonder why
18:25:34 * Maxdamantus has never really looked much into Data.Text
18:25:37 <dmwit> manek: I am not planning to test it, just talking about what I would want to do if this were going to be a core technical decision in a product I was working on.
18:25:48 <dmwit> Maxdamantus: hysterical raisins
18:26:06 <manek> Maxdamantus: yeah, I told that above - when talking about double conversion between utf16 and 32
18:26:11 <sproingie> ICU compatibility i imagine
18:26:28 <dmwit> There was some talk of converting to internally using UTF-8, but it never went anywhere: it was deemed a lot of work for little potential performance gains (even after testing this assertion experimentally).
18:26:37 <Maxdamantus> sproingie: shouldn't have much to do with compatibility, since it's internal.
18:26:50 <manek> dmwit: oh right. I think I'm going ot test it some day. Sooner than later :)
18:26:56 <Maxdamantus> I imagine it's just to maintain historical performance characteristics.
18:27:39 * Maxdamantus thought Data.Text was invented after everyone knew UTF-16 was crazy though
18:27:44 <dmwit> (...and I think they also rightfully connected "a lot of work" with "a lot of potential for bugs".)
18:28:17 <Gurkenglas> bollu, genMachineTrace appears to trace the last state twice if there's no error, is this intended? 
18:45:47 <Gurkenglas> bollu, why does takeNArgs have error handling when you only use it once and it does the same error check at the call site?
18:52:00 <glguy> storing Text as UTF-8 internally was going to get about the same performance with smaller memory footprint
18:52:09 <glguy> and then the project ended
18:55:28 <Welkin> Does anyone know if this jekyll-pandoc extension still works?
18:55:29 <Welkin> https://github.com/mfenner/jekyll-pandoc
19:23:18 <raynold> ahh it's a wonderful day
19:38:30 <glguy> Can any of the "pretty printer" library (wl-pprint-ansi, pretty, prettyprinter, whatever) handle pretty-printing where you have two multi-line elements that you want joined horizonally?
19:39:01 <glguy> For example http://lpaste.net/8721349080745246720 The goal is for all the "entries" to be indented so that they all line up even though the content to the left has a jagged edge
19:39:50 <glguy> As a work around I'll just pre-process the document so that all of the entries are right-padded with whitespace to make it work out
19:40:09 <glguy> I'm curious, however, if there's a way to actually achieve this without pre-processing
19:42:37 <sproingie> that's basically printf's wheelhouse
19:43:25 <Welkin> wtf is a wheelhouse?
19:43:58 <pikajude> imagine a house...
19:44:23 <pacak> But with wheels...
19:44:29 <sproingie> or a house made of wheels
19:44:33 <pacak> All over the place.
19:45:32 <guardianx> so a caravan
19:47:49 <captjakk> how does one use ghcjs with stack
19:48:14 <captjakk> I'm having a lot of trouble getting "stack new project ghcjs" to work
19:48:30 <captjakk> I also can't do a regular install of ghcjs because i get put into cabal hell
19:48:50 <captjakk> which I was hoping that stack would help resolve since it sandboxes the compiler etc.
19:53:29 <glguy> sproingie: printf would require me to pre-process the input to figure out the size to pad things out to manually, right?
19:53:31 <Welkin> I use nix for ghcjs
19:53:44 <Welkin> it's too much of a pain to set up otherwise
19:54:03 <pacak> Suppose in a monadic computation you have "foo <- bar", how would you go about adding a type signature to foo (for documentatio purposes) without making a mess of formatting?
19:54:51 <glguy> pacak: foo <- bar :: M a ?
19:56:28 <lpaste> glguy pasted “for pacak” at http://lpaste.net/356061
19:56:32 <glguy> pacak: new line like that, perhaps?
19:56:34 <pacak> glguy: If bar is something long and M  is someting messy - that messes up formatting. Besides - I don't care about the monad, foo is a pure value.
19:56:54 <pacak> Yea, that looks better
19:56:57 <glguy> pacak: Maybe aligning the :: and <- in the same column
19:57:06 <captjakk> @Welkin, do you use stack for regular ghc then?
19:57:06 <lambdabot> Unknown command, try @list
19:57:09 <glguy> or not, probably is going to depend on the circumstances
19:57:26 <glguy> Yeah, I've only used GHCJS inside Nix
19:57:46 <pacak> glguy: Nice trick, thanks!
20:02:25 <Welkin> capisce: not any more, but I used to
20:02:30 <Welkin> stack works fine with ghc
20:12:42 <iqubic> So, which do I use? Array indexed with (Int, Int) or a Vector of Vectors?
20:13:08 <iqubic> I'm wondering if I should rewrite my game, and switch from Array to 2D vector
20:17:49 <iqubic> Or might I want to use REPA?
20:26:32 <Welkin> iqubic: array is probably better if you want 2 dimensions
20:26:39 <Welkin> vector is ap ain to use in more than one dimension
20:27:19 <iqubic> What about REPA?
20:27:24 <iqubic> Is that any better?
20:27:28 <Welkin> no idea about it
20:28:01 <Welkin> I thought that was for big data processing
20:28:09 <Welkin> not what you are doing
20:28:49 <iqubic> Welkin, what I'm doing is creating a TicTacToe game, and trying to store the current board position.
20:28:56 <Welkin> yeah...
20:29:06 <iqubic> Maybe REPA is not the right tool for that.
20:29:16 <Welkin> tic tac teo has a board with 9 cells
20:29:16 <Welkin> o.o
20:29:22 <Welkin> you don't need anything
20:29:29 <iqubic> I've already written the application with Array.
20:29:32 <Welkin> array vs vector makes no difference
20:29:36 <Welkin> at that scale
20:29:39 <Welkin> I would prefer array
20:30:04 <iqubic> Welkin: I made it so that I can have any board size of 1 x 1 to 1 mil x 1 mil
20:30:06 <Welkin> I'm not sure what you are asking
20:30:15 <Welkin> you wrote it and it works
20:30:42 <iqubic> I'm asking if it's worth the time and effort to switch to Vector or REPA.
20:30:49 <Welkin> micro optimizations are a waste of time, same with pushing around code for not practical purpose
20:30:51 <iqubic> I don't really think it is.
20:30:52 <Welkin> no
20:31:02 <Welkin> it's not
20:31:03 <iqubic> Alright, I'll leave my thing as it is.
20:31:34 <iqubic> This is my first big Haskell program, so I'm trying to make it as good as possible.
20:32:13 <Welkin> I would recommend another approach
20:32:17 <Welkin> write lots of programs
20:32:25 <Welkin> don't worry how good or bad they are
20:32:28 <Welkin> just keep going
20:32:40 <iqubic> In that case, this thing is done.
20:32:45 <Welkin> who will be a better programmer? The person who wrote one program, or the person who wrote 100?
20:32:54 <iqubic> I'll start on something else shortly.
20:33:16 <iqubic> What should I make next. I got little to no idea what to make next.
20:33:46 <Welkin> it's up to you
20:33:51 <Welkin> I just made things I liked
20:33:58 <Welkin> lots of web apps
20:34:19 <Welkin> started on some games with sdl and opengl (requires too much domain knowledge though)
20:34:27 <iqubic> You can make web apps with Haskell??
20:34:30 <iqubic> How??
20:34:32 <Welkin> writing a scheme interpreter is fun
20:34:34 <Welkin> lol
20:34:39 <Welkin> really? you don't know?
20:34:49 <Welkin> you can make any kind of web app
20:34:58 <iqubic> How? GHC2JS?
20:35:02 <Welkin> have you built any before?
20:35:05 <iqubic> Or Yesod? Or what
20:35:12 <Welkin> there are tons of options
20:35:23 <Welkin> but first I need to ask if you have built web apps before
20:35:27 <iqubic> Welkin, I have never made any sort of web application ever.
20:35:29 <Welkin> or know anything about http
20:35:31 <Welkin> okay
20:35:37 <Welkin> then start with scotty
20:35:51 <iqubic> I know very little about http.
20:35:57 <iqubic> What is scotty??
20:36:06 <iqubic> Is it a haskell framework, or what?
20:36:20 <sproingie> if only there were some kind of web site you could plug keywords into like "haskell" and "scotty"
20:36:32 <Welkin> http://hackage.haskell.org/package/scotty
20:36:36 <sproingie> and get relevant results and links.  that'd be miraculous
20:36:55 <iqubic> sproingie: That sounds like Bing.
20:37:10 <glguy> sproingie: Are you saying that that could be iqubic's next project? To invent that?
20:37:23 <sproingie> ya never know
20:37:38 <iqubic> I could make Google, couldn't I??
20:37:45 <glguy> iqubic: You'd get even more help if people thought you were trying to figure things out before you asked
20:38:01 <iqubic> Sorry. Sorry.
20:38:08 <Welkin> iqubic: https://github.com/scotty-web/scotty/wiki/Scotty-Tutorials-&-Examples
20:38:16 <iqubic> Thanks Welkin
20:38:47 <iqubic> You guys know that I have done no web development at all, right?
20:39:02 <sproingie> what's getting you into web dev then?
20:39:08 <iqubic> sproingie: Nothing.
20:39:30 <Welkin> iqubic: if any of those guides ever mention using a cabal sandbox, just ignore that part and use stack instead
20:39:58 <glguy> and if they say to use stack, switch back to sandbox. Keep the authors on their toes
20:39:59 <iqubic> Welkin said that he knew about web dev, and then started giving me some links to Haskell web frameworks
20:40:05 <Welkin> a simple web app can be fun and easy to build
20:40:22 <iqubic> I'd like to get into web dev. It sounds really fun.
20:40:29 <Welkin> understanding http is important though
20:40:33 <sproingie> FSVO "fun"
20:40:37 <Welkin> which is why I recommend starting with scotty
20:40:47 <Welkin> (and even learning how to use WAI directly)
20:40:55 <sproingie> there's some decent tutorials on http, or you could just read the RFC's
20:41:01 <Welkin> lol
20:41:06 <Welkin> don't read the RFCs
20:41:10 <iqubic> What is WAI?
20:41:18 <iqubic> And what is RFC?
20:41:30 <Welkin> https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
20:41:32 <iqubic> I know not these acronyms y'all be using
20:41:39 <Welkin> that's about all you need to know, some quick notes on it
20:41:51 <Welkin> iqubic: RFC is an incomprehensible document
20:42:02 <sproingie> oh BS
20:42:14 <sproingie> the average haskell doc is far denser
20:42:32 <Welkin> iqubic: WAI is a specification. Web Application Interface. It was created as a common interface for haskell libraries to interact with Warp
20:42:37 <Welkin> Warp is the web server
20:43:32 <iqubic> What the heck is Warp?
20:43:44 <Welkin> it's the most popular haskell web server
20:44:14 <Welkin> Scotty run on top of Warp and WAI
20:44:20 <Welkin> runs*
20:45:47 <Welkin> sproingie: these RFCs don't look too bad, but they are insanely long
20:46:04 <sproingie> http's in particular is, yes
20:46:09 <liurnd> +1
20:46:35 <Welkin> not meant as an introduction at all
20:46:57 <liurnd> It's more like a formal spec for a protocol.
20:47:02 <sproingie> if only
20:47:28 <liurnd> Is gRPC API for haskell stable yet?
21:02:26 <butterthebuddha> How does haskell know what the type of CustomerID and Address is in this example -> https://imgur.com/a/m93WP
21:02:44 <butterthebuddha> This is from Real World Haskell
21:03:02 <butterthebuddha> Chapter 3
21:03:54 <Sornaensis> butterthebuddha: someone defined them
21:14:27 <iqubic>  Somewhere else in the code are definitions for CustomerID and Address
21:16:16 <iqubic> How hard would it be to create Tetris in Haskell?
21:19:04 <monochrom> NP-hard I guess.
21:19:06 <kadoban> Try it and find out, it'll probably be fun. Probably not too terribly difficult.
21:19:52 <iqubic> What is P and NP hard and NP complete?
21:20:10 <Myrl-saki> They mean the same thing. /s
21:20:39 <monochrom> I don't think NP-hard means the same thing as P.
21:20:43 <iqubic> What do?
21:20:57 <monochrom> But I'm open to NP-complete meaning the same thing as P.
21:21:06 <Myrl-saki> monochrom: If P = NP, then all NP-hard problems would be P.
21:21:08 <Myrl-saki> Right?
21:21:21 <monochrom> No. s/hard/complete/
21:21:53 <Myrl-saki> "at least as hard as the hardest problems in NP".
21:21:58 <Myrl-saki> So, x >= NP?
21:22:08 <solrize> there's lots of problems even harder than NP
21:22:13 <kadoban> Myrl-saki: The halting problem is NP-hard for instance.
21:22:16 <solrize> i mean harder than anything in NP
21:22:27 <iqubic> How do we determin what difficulty a problem is?
21:22:30 <solrize> NP-hard means hardness >= anything in NP
21:22:37 <monochrom> The whole point of having two words, "hard" and "complete".
21:22:44 <Arcaelyx> Could someone help me with this? I'm trying to use groundhog with postgreSQL and I'm pretty new to Haskell
21:22:45 <Arcaelyx> https://ghostbin.com/paste/uum7s
21:23:24 <Myrl-saki> O(x!!)
21:23:59 <Myrl-saki> Wait.
21:24:04 <glguy> iqubic: If implementing Tic tac toe was fun, you might want to try the 2048 game in Haskell https://www.youtube.com/watch?v=0EG_WQEthjg You could either do it via console or graphically with the gloss package
21:24:16 <Myrl-saki> Where does O(x!) belong to?
21:24:41 <monochrom> Although, ironically, if P≠NP, then the sentence "if P=NP, then NP-hard problems are in P" is true.
21:24:41 <solrize> n**n
21:25:07 <blym> there’s 2048 in reflex: https://github.com/mightybyte/reflex-2048
21:25:15 <Myrl-saki> Oh true, because n*(n-1)*...
21:25:43 <kadoban> Myrl-saki: Asymptotic notation is not really a direct map to complexity classes, so some assumptions are required to answer the question I understood from that.
21:26:07 <Myrl-saki> kadoban: Ah.
21:26:26 <glguy> blym: That implementation just crashed my web browser o.O
21:26:44 <Myrl-saki> monochrom: Errr, principle of explosion?
21:26:57 <monochrom> Yes.
21:27:02 <glguy> or at least the process associated with the tab
21:27:09 <monochrom> n^n is not in O(n!).
21:31:30 <Arcaelyx> Could anyone help me with my problem?
21:32:38 <glguy> Arcaelyx: You'll need to specify what type recentTrades has
21:33:13 <Arcaelyx> glguy: I don't think it's failing just because of that. Can't it just do type inference?
21:33:27 <glguy> How did you expect that to work?
21:33:44 <glguy> As in explain your reasoning so we can see where it went wrong
21:36:30 <monochrom> Be prepared for the possibility of "not even wrong".
21:36:42 <Arcaelyx> glguy: I don't know lol, this is the most I've ever used Haskell.
21:36:58 <Arcaelyx> It says expected type [()] and that's what I put.
21:37:25 <Welkin> iqubic: it should be easy. I haven't written it in haskell, but I wrote one in lua
21:37:53 <Arcaelyx> Actually, just changed it to PostgreSQL IO ()
21:38:04 <Welkin> rendering might be a pain though, since the support for graphics in haskell leaves a lot to be desired
21:39:29 <glguy> Arcaelyx: I was actually suggesting you explain what type you thought recentTrades would have and why, it wasn't rhetorical. The goal would be to learn more
21:39:46 <Arcaelyx> Ah.
21:39:55 <Arcaelyx> I didn't think much about it actually lol. I'm still not familiar with types.
21:40:04 <Arcaelyx> My guess is it must've been something to do with IO
21:40:30 <glguy> OK, what did you want recentTrades to mean, then?
21:40:48 <Arcaelyx> I just want to get the data out at the moment lol.
21:41:02 <glguy> what data? in what form?
21:41:11 <Arcaelyx> A list of stock trades in this instance.
21:41:17 <Arcaelyx> It's from a VIEW
21:42:43 <glguy> So a list of LatestTrade? recentTrades :: [LatestTrade]?
21:42:54 <Arcaelyx> Yeah.
21:43:02 <Arcaelyx> That was the idea, but that seemed to fail.
21:43:13 <glguy> OK, then you'll have to write that in your program and then you'll get some new errors to figure out
21:43:29 <glguy> e.g. liftIO $ putStrLn $ "Latest trades: " ++ show (recentTrades :: [LatestTrade])
21:43:59 <glguy> There's nothing in the code as pasted that indicates what type recentTrades should have had
21:45:16 <Arcaelyx> glguy: Ah, so I was on track with my previous type signature?
21:45:37 <Arcaelyx> I get this now with that line you gave me and that as the type signature: `The last statement in a 'do' block must be an expression`
21:46:05 <glguy> Arcaelyx: You'd have to update your paste for me to know what the syntax error is
21:46:36 <glguy> perhaps you indented the liftIO line when you edited it
21:46:37 <Arcaelyx> glguy: One second.
21:47:25 <Arcaelyx> glguy: https://ghostbin.com/paste/qk346
21:47:34 <Arcaelyx> The error I get is at the bottom.
21:47:49 <glguy> Yeah, you accidentally indented line 69 while editing it
21:48:10 <glguy> currently it's being interpreted as part of line 68
21:48:28 <glguy> as though you wrote this on one line: recentTrades <- select "recent_trades" liftIO $ putStrLn $ "Latest trades: " ++ show (recentTrades :: [LatestTrade])
21:48:55 <Arcaelyx> Oh wow.
21:49:13 <Arcaelyx> Well now it seems to have compiled a bit more and I get new errors.
21:50:27 <Arcaelyx> glguy: https://ghostbin.com/paste/toh2w
21:51:40 <Arcaelyx> I'm guessing that the DB connection is failing and not returning anything to `getLatestTrades`?
21:51:49 <Arcaelyx> Which is why it returns [()] instead of [LatestTrade]?
21:51:52 <glguy> Nothing is running at this point
21:52:09 <Arcaelyx> Yeah lol.
21:52:39 <glguy> You can fix the first error by replacing your incorrect type signature "getLatestTrades :: [LatestTrade]" with the suggested replacement in the error
21:53:08 <kadoban> Arcaelyx: Anything to do with types can't have anything to do with a database connection failing (unless you're using TH, but even then ...)
21:53:14 <cocreature> it might be worth pointing out that types in Haskell are a static property. you can’t write a function that has a different type depending on runtime behavior
21:54:03 <cocreature> types are not even present at runtime
21:54:12 <Arcaelyx> kadoban: With the type Postgresql ()?
21:55:01 <kadoban> Arcaelyx: I just mean that if you're getting a type error, it can't have anything to do with a database connection error. For the reasons cocreature more eloquently stated.
21:55:10 <glguy> Arcaelyx: This probably isn't a good library to start with if you don't know much Haskell yet
21:55:19 <glguy> It's not particularly simple
21:55:34 <Arcaelyx> glguy: It's at a new gig, I have no choice lol.
21:56:55 <Arcaelyx> kadoban: I see.
21:56:59 <Arcaelyx> Makes sense.
21:57:24 <determinant> hi everyone, I'm new to Haskell. After doing Haskell 99 and understanding what Monad is, I somewhat feel unclear about what kind of practice and document I should go for next. I wonder how I could learn the idioms for some applications relevant to systems building, which means state mutation happens all the time. Should I learn some packages in Control.Monad? I'm confused by so many different packages with
21:57:27 <determinant> similar names... Thanks!
21:58:27 <LiaoTao> determinant: The state monad and state transformer are good bets
21:58:58 <cocreature> determinant: personally, I found it very helpful to just tackle some simple “realworld” problems (i.e., not project euler or other math problems). you can always come here and ask for suggestions on how to improve your code
22:00:52 <Arcaelyx> glguy: Doesn't seem to be working still, I removed it from the function lol.
22:01:08 <determinant> cocreature: what problem, for example? :)
22:01:13 <determinant> LiaoTao: thnx!
22:01:37 <monochrom> What is "systems building"?
22:02:04 <determinant> monochrom: oh, implementing distributed systems, for instance
22:02:08 <Arcaelyx> glguy: https://ghostbin.com/paste/s3gnw
22:02:48 <determinant> monochrom: I'm a graduate system working on systems. So I hope in the future it is possible to use FP boost my productivity. ;)
22:02:59 <monochrom> That sounds like message passing dominates and not so much about state.
22:03:00 <determinant> *graduate student
22:03:03 <cocreature> determinant: one of the first things I build when I was learning Haskell was an executable that read a database of xkcds and sorted them by their dimensions (I was doing the layout for some online magazine at the time and we were using xkcds to fill empty space)
22:03:36 <LiaoTao> cocreature: That sounds pretty cool
22:03:42 <determinant> monochrom: but in the end, even if you use msg passing, you still need to maintain internal states, for the protocol.
22:03:46 <LiaoTao> Do you have the finished product somewhere? :)
22:04:18 <determinant> cocreature: that sounds like a very cute example
22:04:25 <monochrom> Internal state can manifest as parameter passing rather than mutable variables.
22:04:33 <cocreature> LiaoTao: I probably still have it lying around somewhere (although not public) but it was very specific to the database of unused xkcds so you can’t really use it for anything else anyway
22:04:50 <LiaoTao> I meant that I wanted to see what it looked like :D
22:04:59 <LiaoTao> The code seems pretty straightforward
22:05:09 <cocreature> LiaoTao: oh it looked absolutely terrible. I knew very little Haskell at the time :)
22:05:25 <cocreature> but it was a good way to get started
22:05:51 <determinant> monochrom: but usually some part of the logic is naturally imperative. (maybe it could also be the case that I should change my way of thinking)
22:05:55 <monochrom> Suppose you will keep sending me messages, and upon receiving one message from you, I am to "change" "internal" "state" to True or False based on the parity of the length of your message.
22:06:34 <determinant> monochrom: yeah..but there has to be some shared environment in which your functions are able to read values from and write to
22:06:49 <monochrom> I will code like this: myloop b = do { msg <- recv; if odd (length msg) then myloop True else myloop False }
22:07:38 <pacak> myloop (odd $ length msg)....
22:07:56 <monochrom> Well yeah but not a fan of keeping that thunk around.
22:08:47 <pacak> $! $!
22:09:08 <LiaoTao>  . $ . $ . $ . $ . $ . $
22:09:11 <monochrom> myloop $! odd $! length $! msg  for good measure?
22:09:55 <glguy> I expect you're joking, but: myloop $! odd $ length $ msg  -- only the first was needed
22:09:59 <monochrom> If your internal state is a hash table, then it qualifies as naturally imperative.
22:10:06 <determinant> monochrom: however, the reality is, in the end you need to introduce something similar to IO Monad (or State Monad) to maintain some shared environment that survives through messages..
22:10:16 <monochrom> Otherwise, I think you're underestimating the expressive power of parameter passing.
22:10:57 <LiaoTao> do { you <- like $ nakes }?
22:10:57 <determinant> monochrom: maybe..I'm not sure..
22:10:59 <cocreature> determinant: it might be worth pointing out that Haskell does allow for mutable state and when you’re using multiple threads you probably need it somewhere. it just forces you to make it explicit
22:11:13 <determinant> cocreature: yeah..
22:11:26 <determinant> cocreature: I just wonder what the typical packages are
22:11:38 <determinant> cocreature: or the pattern/idiom that I should leanr
22:11:41 <determinant> *learn
22:12:07 <determinant> cocreature: now I can only guess I probably need to go over State and Reader/Writer..
22:12:31 <determinant> cocreature: but I got confused by a bunch of things with similar names, with strict/lazy...
22:13:21 <cocreature> determinant: not necessarily, I never user Writer and I rarely use State. I do use ReaderT but even that is far from being essential to my programs
22:13:24 <monochrom> The name "State" is already misleading.
22:13:43 <glguy> State, Reader, nor Writer will allow you to do anything you can't do without them
22:13:53 <monochrom> You will soon find that it is no state at all. For example updates are invisible from another thread.
22:14:31 <monochrom> The fact remains that it uses parameter passing again to give you an illusion. You are not getting out of this bwhahahaha.
22:14:44 <Lokathor> is it better to try and bolt some thread safety on top of a thing that's fundamentally not thread safe, and take a speed hit for it
22:14:59 <Lokathor> or just admit that things aren't thread safe and never really will be, and use the IORef instead of the MVar
22:16:53 <monochrom> It is better to provide both and let someone else worry about which one to choose. :)
22:17:39 <Lokathor> hmm
22:17:44 <Lokathor> how would you suggest to "provide both"?
22:17:56 <determinant> glguy: so they are different from IO
22:18:06 <monochrom> Two modules, each exporting a different API.
22:18:24 <Lokathor> oh my gosh :P
22:18:35 <determinant> monochrom: i see...
22:18:47 <determinant> monochrom: Ah...purity, purity
22:18:59 <determinant> so what about STMonad?
22:19:10 <determinant> I guess it is special
22:19:22 <monochrom> Now, IORef is not an illusion. It is real mutable. But it's also ten times slower than parameter passing.
22:19:50 <Lokathor> monochrom, in my case paramater passing is not an option. Sorry, I didn't see that my question could be interpreted as being related to the above discussion
22:20:18 <Lokathor> for correctness, a reference type of some sort must be used (IORef, MVar, even Ptr could do I guess)
22:20:21 <Lokathor> in my case
22:21:12 <monochrom> No no, I have always been keeping the two discussions separate.
22:23:15 <Lokathor> in my case, newtype Hexes a = Hexes (ReaderT (??? HexesData) IO a)
22:23:34 <Lokathor> and right now those ?? are MVar
22:23:52 <monochrom> IIRC IORef is a bit faster, yes.
22:24:13 <monochrom> And there is atomicModifyIORef for multi-threading purpose.
22:28:36 <monochrom> I have a mutli-threaded program using an IORef (Map X Y). Inserts and deletes are via atomicModifyIORef only. An astonishingly simple way to get sequential consistency. Who needs lock-free concurrent mutable binary search trees? :)
22:29:20 <Lokathor> but is atomicModifyIORef (possibly with the ') faster or slower or the same as withMVar_ I wonder
22:29:48 <monochrom> I will bet on atomicModifyIORef being faster.
22:30:07 <monochrom> It is pretty close to compare-and-swap.
22:30:31 <monochrom> withMVar is really a takeMVar and a putMVar.
22:30:48 <monochrom> I would bet twice as slow.
22:32:20 <Lokathor> well that's cool
22:32:26 <Lokathor> I'll use IORef for now
22:32:38 <Lokathor> probably easier to say "not thread safe!" and then later say "okay now there's some safety"
22:33:07 <monochrom> The time when you ditch IORef is when "I need to update two or more IORefs as one single atomic transaction".
22:33:17 <Lokathor> well i never need to do that
22:36:10 <Lokathor> honestly, the modifications probably don't need to be atomic at all
22:36:15 <Lokathor> only one thread should be doing drawing
22:36:25 <Lokathor> but for now it can be atomicIORef instead of MVar
22:37:10 <nshepperd> when you need to update two or more i guess you go to stm
22:37:23 <monochrom> Ah, when will they have globalThermoNuclearModifyIORef? :)
22:38:08 <Lokathor> the main problem i have is that there's, say, 80x24 grid cells, and each might get as many as 3 updates within a frame (bg, fg, tile) and all that adds up a lot
22:38:10 <nshepperd> maybe you want MVars if you ever need to take value, do an io action, replace value
22:38:19 <monochrom> Yeah, STM or build your own locking mechanism, depending on which one you think is faster for your kind of contention.
22:38:26 <Lokathor> so what i should really do is provide a thing where you pass in a function and it does it all once in ST or something, i suppose
23:16:33 <solrize> there was a package a while back that let users describe network packet formats as ascii diagrams that got parsed as haskell expressions... anyone remember what it was?  tx
23:17:24 <Lokathor> https://github.com/ScrambledEggsOnToast/needle ?
23:38:55 <slack1256> for one off scripts, what alternative exists to .cabal files?
23:39:10 <nshepperd> solrize: i see this blog post https://potentiallang.wordpress.com/2010/07/02/quasi-quoting-ascii-art-to-define-data-structures/ but i don't remember there being an actual package
23:39:24 <solrize> thanks, looking
23:39:51 <solrize> yeah, i think that's the one i saw.  i spent a while googling and couldn't find it, so thanks!!!
23:42:38 * hackage wolf 0.3.17 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.17 (markfine)
23:47:57 <cocreature> slack1256: stack has a "script" command that you can use for this. I can’t find it in the docs but https://github.com/commercialhaskell/stack/pull/2992 should get you started
23:48:03 <MarcelineVQ> the docs are https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
23:57:09 <cocreature> ah seems like the search function was failing me
