00:03:31 <Guest33778> what's the best way to write tests for a function IO (), which prints out to stdout? I'm trying to pick a suitable tasty ingredient, but can't seem to find one.
00:06:01 <systemfault> I'm still a noob but I've been looking at free monads the last 3 days and they seem like a good way to make any IO function testable. Not 100% sure though...
00:06:47 <LiaoTao> Excuse me for asking a stupid question, but what do you guys mean when you say "test" and "testable"?
00:06:57 <rgrinberg> is there a way to write a kind signature for a type alias?
00:07:02 <EvanR> you could make any IO function not IO, which is a good way to make it testable
00:07:15 <rgrinberg> kind of like how you can do it with for data if you're using gadt syntax
00:08:46 <Guest33778> LiaoTao: It's a function that prints a bunch of things; in a sense it's the "constant" function that always prints the same thing. (Yes, this sounds silly, but there's a good use case.)
00:08:59 <Guest33778> The test would make sure that it indeed prints the same thing.
00:09:44 <Guest33778> simple example: foo = print 2
00:09:54 <EvanR> thats not a function
00:10:08 <Guest33778> how would I write a Tasty test case to make sure this always prints "2" to stdout
00:10:10 <Guest33778> sure it is
00:10:15 <EvanR> :t print 2
00:10:17 <lambdabot> IO ()
00:10:22 <EvanR> no ->
00:10:39 <EvanR> figuring out what were working with is a good start for figuring out how to test stuff
00:10:51 <Guest33778> ok, let me ask that way: What's the Tasty way of testing a IO () value
00:10:59 <LiaoTao> :D
00:11:08 <Guest33778> that it's effect is the same every single tie
00:11:11 <Guest33778> time
00:12:52 <EvanR> so theres tasty-golden
00:13:28 <Guest33778> EvanR: Indeed; but that that one seems to only supports the case when the IO action actually creates the gold file
00:14:07 <Guest33778> I found a workaround, but it's not reliably working: Using the silently package: https://hackage.haskell.org/package/silently
00:14:16 <gonz_> Do people run a lot of build bots and such that pull every package on hackage to build it?
00:14:19 <Guest33778> it allows you to capture the "stdout" of an IO () action
00:14:31 <Guest33778> but when used with tasty, it arbitrarily fails at times
00:14:33 <EvanR> generally IO effects cant be intercepted and analyzed, they can be anything and do anything
00:14:46 <Cale> Guest33778: For testing IO actions, usually you just test the entire application.
00:14:50 <Guest33778> EvanR: Quite right. I'm interested in what it prints on stdout.
00:15:00 <Cale> (Externally)
00:15:21 <EvanR> so there might be a testsuite specifically to test stdout...
00:15:35 <Guest33778> doctest, for instance, doesn't have this problem. It can handle IO () functions just fine
00:15:52 <Cale> If you want to test more of what the IO action is doing, consider how you might be able to split it into a part which does most of the work without carrying out any I/O, and a part which actually does the I/O required.
00:15:57 <EvanR> silently reminds me of PHP output buffering shenanigans
00:16:03 <EvanR> the horror
00:16:05 <Guest33778> essentially I need something like "doctest" plugin for "tasty"
00:16:09 <systemfault> Ew
00:16:45 <Guest33778> silently is pretty awesome actually; and it does the job. it's just that when you use it within Tasty, it arbitrarily fails to capture the stdout
00:16:57 <EvanR> sounds awesome :(
00:17:05 <Guest33778> not for this use case
00:17:13 <Guest33778> but for one-shot cases, it does the job
00:18:02 <Cale> Guest33778: One thing you could do in order to facilitate testing is to pass a function as an argument which you'll use in place of putStrLn, and then that gives you the ability to pass something which, say, updates an IORef instead.
00:19:04 <EvanR> alternative logger
00:19:30 <Cale> If you want to go overboard, you could abstract over all sorts of different effects, and have a record of functions parameterised over a choice of monad.
00:20:15 <Guest33778> Cale: I was hoping for a simpler solution that didn't require any mods
00:21:30 <Cale> But yeah, IO actions don't really expose any way to redirect their output. It would be kind of nice.
00:22:30 <EvanR> this silently thing does *something* not sure how
00:22:33 <Guest33778> Cale: silently package does that
00:22:50 <Guest33778> but I found that if you use it part of a test suite it's not very reliable
00:22:55 <EvanR> but its apparently pretty fragile
00:23:13 <Guest33778> it duplicates the handle and redirects to a file, which chokes upon heavy usage
00:23:24 <Cale> That thing looks jankier than any code I'd bother testing.
00:23:27 <EvanR> o_O
00:24:15 <Guest33778> EvanR: I think it chokes only under heavy usage
00:24:24 <EvanR> i dont get that
00:24:25 <Guest33778> for one-shot cases, it works pretty well actually
00:24:47 <EvanR> like, it has a maximum throughput before it acts incorrectly?
00:25:04 <EvanR> what would cause that
00:25:11 <Guest33778> there's probably some race condition in the hDuplicate calls
00:25:17 <EvanR> :(
00:25:18 <Guest33778> as it travels through the FFI
00:25:30 <Guest33778> under repeated usage, it seems to croak
00:27:46 <EvanR> you can redirect output of the program and test that
00:30:33 <Guest33778> turn the function into a standalone program?
00:30:55 <EvanR> it certainly has the right type
00:31:01 <Guest33778> it sure does
00:31:03 <EvanR> IO ()
00:31:38 <EvanR> would work assuming it doesnt rely on spooky global variables or something
00:31:55 <Guest33778> feels like there must be an easier way
00:32:15 <EvanR> im not that surprised by IO's inflexibility
00:32:23 <EvanR> its IO
00:32:31 <Guest33778> is there a way to create a pipe perhaps, and hook it up to a different function that captures it's stdin?
00:33:07 <EvanR> sure, fork a child process... arrange the pipes
00:33:38 <EvanR> System.Process
00:34:32 <Guest33778> yeah, that might work
00:38:03 <hjulle> Is there any way to learn what type a subexpression has after defaulting? (in ghci)
00:40:35 <EvanR> > :t 3 `asAppliedTo` show
00:40:38 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:40:38 <EvanR> :t 3 `asAppliedTo` show
00:40:39 <lambdabot> (Show a, Num ((a -> String) -> b)) => (a -> String) -> b
00:40:48 <EvanR> heh
00:40:54 <hjulle> I tried using f (x :: _), but got ab ambigous type error (while just f x) worked
00:41:11 <merijn> EvanR: Are you sure you didn't reverse the arguments?
00:41:23 <EvanR> :t show `asAppliedTo` 3
00:41:25 <lambdabot> (Num a, Show a) => a -> String
00:41:47 <EvanR> not really what i was going for
00:41:53 <hjulle> EvanR: Where is that function?
00:42:06 <EvanR> @index asAppliedTo
00:42:06 <lambdabot> bzzt
00:42:22 <EvanR> :t asAppliedTo
00:42:24 <lambdabot> (a -> b) -> a -> a -> b
00:42:59 <EvanR> @src asAppliedTo
00:43:00 <lambdabot> f `asAppliedTo` a = f where _ = f a
00:43:00 <lambdabot> infixl 0 `asAppliedTo`
00:43:31 <EvanR> since that gets generalized its not really getting the defaulting
00:44:34 <merijn> hmm, are there any good plotting libraries for Haskell?
00:45:34 <hjulle> EvanR: Thanks, that worked
00:46:24 <hjulle> merijn: Chart is pretty good
00:46:31 <c_wraith> does diagrams count?
00:46:40 <hjulle> https://github.com/timbod7/haskell-chart/wiki
00:48:21 <hjulle> Chart can use diagrams as a backend.
00:48:37 <gonz_> Does anyone know if using the `sliced` lens for vectors and combining it with `%~` for changing the slice in the vector should inherently be much worse than just using the standard ways of updating the vector?
00:48:58 <gonz_> I find that the "execute this function on that slice" idiom makes for really nice looking code
00:49:30 <gonz_> But I'm running out of memory trying to lens into a vector of a million elements and changing them with a function that depends on the current value.
00:49:53 <merijn> c_wraith: Maybe? I haven't looked at it yet, but I'm looking if there's some "fool-proof" stuff, since someone is asking me "hey, if I wanna get back into programming I need to work on something I can relate to", so she wants to work on processing/plotting measurement data from experiments. After having done that in Python for the past year, I honestly can't recomend that, so I'm trying to evaluate if I 
00:50:00 <merijn> can get away with just tricking her into learning Haskell :p
00:50:11 <c_wraith> gonz_: only millions?  That shouldn't run you out of memory, unless you're keeping a bunch of slightly-modified copies around at once.
00:50:30 <merijn> But some of the...more Haskelly libraries might be a bit to intimidating if someone wants to get productive fast :p
00:51:03 <c_wraith> ah.  diagrams is pretty haskelly
00:51:04 <gonz_> c_wraith: That's the thing, I'm folding a series of instructions that will all return a new vector and I have about 300 of these instructions.
00:51:23 <c_wraith> gonz_: you probably aren't using a strict-enough fold
00:51:26 <hjulle> merijn: I definitely recommend chart in that case.
00:51:37 <EvanR> code.world is graphical and easy to start with
00:51:37 <merijn> hjulle: Yeah, I've been thinking about transitioning my own code to Chart before.
00:51:46 <EvanR> but isnt charts either
00:51:53 <gonz_> c_wraith: I wrote a version of this before I knew about lenses and it doesn't really have any memory issues (and executes efficiently, as well).
00:52:13 <c_wraith> gonz_: there's nothing wrong with not using lenses. :)
00:52:13 <gonz_> I'm wondering now if there's an overhead to `%~` when slicing the list.
00:53:21 <merijn> EvanR: Well, she's kicking my ass at SHENZHEN I/O, so it doesn't have to be to graphical and simple :p I'm more interested in maximising the short-medium term profitability of learning for her. Which is one of the reasons Python isn't completely ruled out yet
00:53:38 <c_wraith> merijn: how about R?
00:53:40 <hjulle> gonz_: You might want to ask at #lens. You will not get an answer as quickly, but people there know more about the library and its internals.
00:53:51 <c_wraith> err, #haskell-lens
00:54:08 <merijn> c_wraith: That was another candidate I had in mind, yeah. (Although I guess this is more -offtopic material now :p)
00:54:24 <c_wraith> anyway, sliced is a pretty boring lens.  I doubt the combination of sliced and %~ is your problem
00:54:37 <c_wraith> I'm pretty sure the problem is an algorithm that does too much copying.
00:54:42 <merijn> gonz_: How big is your vector? Is it mutable?
00:54:58 <c_wraith> Possibly that you accidentally slipped into using because lens made it look easy
00:56:33 <hjulle> gonz_: If you can post a simplified version of the code with and without lens, we might be able to spot the problem.
00:56:52 <gonz_> merijn: A million elements, not very big. I know it's not a problem with the size of it or the data it contains.
00:57:41 <merijn> gonz_: Yeah, I'm more thinking whether you might be inadvertently modifying it a lot and keep lots of copies around
01:12:55 <ADG> I have a list [(f x y .., 1) | x<- [..], y<-[...], ...]
01:13:09 <ADG> I want to get an array out of it?
01:13:48 <ADG> something like for(int x..) { for(int y...) { ... cnt[f(x,y,...)++] .. }}
01:14:35 <merijn> ADG: Depending on the exact usecase I would probably use either IntMap or Vector
01:14:57 <gonz_> merijn: Interestingly, I have a `toggle` operation that is defined differently for different types and for Bool I set it to `not`, because it made sense. When I actually defined it literally as `toggle True = False`, etc., it's no longer having memory issues.
01:15:20 <gonz_> I would've thought that `not` was exactly the same operation.
01:15:50 <ADG> basically IntMap would be O(min(32,n))? & Vector O(n)?, something like arrays in imperitive languages like O(1)?
01:16:47 <merijn> gonz_: !
01:16:57 <merijn> gonz_: I suspect excessive laziness
01:17:26 <merijn> ADG: Mutable vectors exist, which you can update imperatively
01:17:37 <Cale> merijn, gonz_: Of course, not is a strict function too...
01:18:10 <Cale> not is defined just like that:
01:18:11 <merijn> Cale: Yeah, but he mentions "defined differently for different types" <- maybe one is non-strict
01:18:13 <Cale> @src not
01:18:13 <lambdabot> not True  = False
01:18:13 <lambdabot> not False = True
01:18:17 <Cale> ah, maybe
01:18:41 <gonz_> That's exactly what I thought, which is why `toggle` for Bool was exactly that.
01:18:44 <merijn> ADG: Although your example of the double for loops looks like a scan, so should be possible to do without those too
01:18:51 <gonz_> I just set it to `not` because it made sense.
01:19:00 <gonz_> But having changed it, I'm not seeing any memory issues any more.
01:19:04 <gonz_> So I honestly don't know what to think.
01:19:08 <merijn> gonz_: Simple debug step: enable -XBangPatterns and add a ! to the argument of your toggle implementation
01:19:20 <Cale> ADG: Could you perhaps give more information about what you're computing? There are a lot of different array types available in Haskell, which are good for different things.
01:19:26 <geekosaur> but doing the pattern match directly will be strict, while setting it to 'not' introduces laziness, no?
01:19:33 <ADG> see https://github.com/adityagupta1089/Project-Euler-Haskell/blob/master/src/126.hs
01:19:33 <Cale> geekosaur: no
01:20:37 <Cale> A function is strict if f _|_ = _|_
01:20:48 <Cale> not is strict
01:20:53 <Cale> If f = not, then f is strict
01:21:47 <mrijkeboer> What is the reason that Data.ByteString has a `breakSubstring` function, but Data.ByteString.Lazy not?
01:22:55 <merijn> mrijkeboer: I'd guess efficiency reasons?
01:23:30 <Cale> I'd guess someone just didn't write the lazy bytestring equivalent...
01:24:32 <merijn> That's also an option
01:24:57 <merijn> mrijkeboer: If you don't care too much about your memory usage you could just use toStrict and use the breakSubstring from the strict one
01:26:38 <mrijkeboer> merijn: I found out that Data.ByteString.Lazy didn't have a breakSubstring function because I'm modifying some code to use lazy bytestrings instead of strict ones, because of memory issues...
01:26:41 <EvanR> what is "subject reduction"
01:26:52 <merijn> mrijkeboer: ah...
01:28:17 <merijn> mrijkeboer: What do you wanna do with the split parts?
01:28:38 <merijn> mrijkeboer: In general, can you describe roughly what the code is doing
01:30:05 <mrijkeboer> merijn: I'm splitting the bytestring into lines by line separator (e.g. "\r\n").
01:30:29 <merijn> mrijkeboer: ok, yes, you just need to switch to pipes/conduit
01:30:44 <merijn> because breakSubstring is a dumb way of doing that :)
01:31:22 <EvanR> splitting a lazy bytestring by "\r\n" shouldnt be considered dumb
01:32:19 <mrijkeboer> merijn: My input is a lazy bytestring (Servant) and my next stage expects a bytestring...
01:32:20 <EvanR> it sounds well defined and potentially efficient and working for infinite bytestrings
01:32:58 <mrijkeboer> EvanR: I thought so too.
01:33:18 <EvanR> you can write it yourself using toChunks, ???, fromChunks
01:33:41 <EvanR> operating a stream of strict bytestrings
01:33:55 <merijn> mrijkeboer: Your next stage is expecting individual lines, yes?
01:34:07 <EvanR> or dont put it back together
01:34:28 <merijn> mrijkeboer: stream processing large inputs by splitting into chunks and feeding it into a "next stage" is the exact thing pipes and conduit were designed for
01:34:47 <mrijkeboer> merijn: indeed. It expects a single line and I call it with fmap/mapM...
01:35:54 <merijn> mrijkeboer: Like I said, this sounds like the exact these libraries were designed for. And I find it hard to believe no one has implemented a pipes/conduit wrapper for servant yet
01:36:44 <mrijkeboer> EvanR: that would be possible, but a little inconvenient when one chunk has the "\r" part and the next chunk has "\n".
01:37:49 <merijn> mrijkeboer: That's why you use toChunks to get strict chunks, use conduit/pipes to repack those chunks into individual lines that you stream into your own code
01:38:25 <merijn> hell
01:38:37 <merijn> pipes-bytestring has a lazy ByteString to pipes function already :)
01:39:00 <mrijkeboer> merijn: sorry I never used conduit/pipes, need to get up to speed.
01:39:02 <bollu> should I use effects rather than using MTL just to learn it?
01:39:12 <bollu> or is it not as "drop in" as I believe it to be?
01:39:32 <bollu> extensible-effects is the "de facto" effects package, yeah?
01:39:52 <osa1> bollu: freer is much better in a lot of ways
01:40:02 <osa1> bollu: see also github/osa1/free-er
01:40:13 <osa1> bollu: also github.com/ixpertaSolutions/freer-effects
01:40:18 <bollu> osa1 in what ways? quick blaze through?
01:40:28 <osa1> bollu: read the freer paper
01:40:47 <osa1> bollu: also read the effect implementations
01:40:48 <bollu> osa1 my stack of "to read" is pretty large right now xD
01:40:55 <bollu> I've read the extensible effects paper
01:41:01 <osa1> bollu: just compare effects implemented in extensible-effects and freer then
01:41:05 <bollu> I see
01:41:09 <bollu> OK, ty
01:41:16 <bollu> osa1 can you give me a hackage link>?
01:41:52 <osa1> bollu: start with this http://hackage.haskell.org/package/freer but the development has stopped and it has some problems. my implementation is better in some ways and I also have examples but that package is not on hackage
01:41:58 <osa1> not sure about ixperta one
01:43:25 <bollu> argh
01:43:26 <bollu> OK
01:43:29 <osa1> bollu: I'd suggest quickly skimming through the paper. skip implementation details, just read the motivation and improvements over extensible-effects
01:43:36 <bollu> osa1
01:43:37 <bollu> OK
01:43:49 <bollu> this one, right? http://okmij.org/ftp/Haskell/extensible/more.pdf
01:44:06 <osa1> yep
01:44:38 <bollu> OK, cool
01:45:23 <bollu> I absolutely hate all of you :P my stack of "to read" is never going to get to 0.
01:45:35 <osa1> as it should be :-P
01:45:58 <Rembane> It's the Tao of academics.
01:47:05 <merijn> bollu: pffft, you hadn't given up on "read stack zero"? :p
01:50:49 <bollu> osa1, so I should use "freer"?
01:51:12 <bollu> well, to be fair, on this project, I don't even need effects. I literally only need "State"
01:51:16 <bollu> maybe this is overkill
01:51:17 <EvanR> mrijkeboer: yeah it doesnt seem entirely trivial to implement, but the algorithm is what it is
01:51:20 <bollu> but fuck it, let's do this.
01:51:44 <EvanR> it should be in the library!
01:51:55 <EvanR> Cale: this copatterns paper is amazing
01:52:05 <osa1> bollu: start with freer because even though it has problems that won't be fixed (which are fixed in my implementation) it's on hackage and even on some LTSs
01:52:26 <mrijkeboer> EvanR: indeed
01:52:26 <bollu> EvanR what's copatterns?
01:52:33 <EvanR> http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf (if anybody else is interested)
01:52:34 <osa1> bollu: one problem with freer is that if you want to implement your own effects you need to know at least a little bit about the implementation
01:52:40 <bollu> I see
01:53:08 <osa1> bollu: so if you want to continue with it you should implement it yourself at least as an exercise. on the way you'll also understand the tradeoffs etc. and pick one of the implementation or go with your own
01:53:09 <EvanR> mrijkeboer: cred op, write it and submit pull request :)
01:53:24 <bollu> right
01:53:36 <bollu> osa1 I just want "st ate". literallty
01:53:40 <bollu> state*
01:53:55 <osa1> bollu: then use transformers + mtl
01:54:03 <bollu> but I wanted to use interesting things :)
01:54:06 <EvanR> and actually, you do want to put it back together because theres no telling when the next \r\n or whatever sep will occur
01:54:07 <osa1> or just pass IORef State
01:54:22 <bollu> osa1 I think I'll use mtl, and then rewrite it using freer over the weekend once this works.
01:54:54 <bollu> I have a general design question: is there a good alternative for a "builder" abstraction in the functional world? Specifically, for those who use LLVM. the "IRBuilder"
01:56:03 <bollu> The problem is that I need to have a notion of "current focused basic block"
01:56:09 <bollu> which is exactly what State lets you do
01:56:18 <bollu> read and write to the "currently focused basic block"
01:56:34 <bollu> but, it feels unsatisfying: like I'm just rewriting the imperative idea
02:02:01 <EvanR> bollu: "currently focused" sounds like zippers
02:02:09 <bollu> EvanR hm yes
02:02:19 <bollu> EvanR you're right, what I have a list "zipper like"
02:02:31 <bollu> EvanR I need a notion of a zipper that can choose to be "unfocused"
02:02:36 <bollu> Maybe  ListZipper?
02:02:38 <bollu> that may work
02:02:42 <bollu> no, that's incorrect
02:02:52 <bollu> Maybe (List a) (ListZipper a)
02:02:56 <bollu> Either*
02:03:13 <EvanR> your List is focused at the beginning....
02:04:07 <bollu> hm yes xD
02:04:31 <EvanR> if it was another data structure, maybe theres something else you can do
02:04:35 <bollu> EvanR no, I need it to focus on a "sentinel"
02:04:37 <bollu> it is a list
02:04:48 <EvanR> but if its a list, you cant really deny its a zipper
02:05:24 <bollu> unfocused l = Zipper [] [] l?
02:05:26 <bollu> I suppose
02:05:44 <EvanR> LLVM, maybe theres a more advanced way to describe what youre doing
02:06:07 <EvanR> like, are you inserting stuff in the middle of stuff
02:06:19 <EvanR> and having to reshuffle absolute positions
02:07:23 <bollu> yes, but I don't want all that
02:07:29 <bollu> I just want a simple builder
02:07:37 <bollu> I gave the LLVM thing as an example
02:10:33 <EvanR> builder as in, a thing you can append to
02:15:06 <EvanR> i wrote "stringly normalizing" accidentally, now im wondering what that would be
02:16:45 <phz_> hey, what is the difference between a type family and a data family?
02:16:54 <bollu> EvanR not just append
02:17:00 <bollu> EvanR I have a collection of things I can append to
02:17:12 <bollu> EvanR and then I need a way to "focus" between these different things"
02:17:23 <bollu> EvanR : Zipper (Writer r) or something like that
02:20:06 <raek> EvanR: sounds like those scripting languages where all data is implicitly converted back to strings after each operation
02:26:09 <merijn> ugh...the Storable API is a mess of historical mistakes :\
02:49:39 <merijn> Semi-relatedly: Is there some convenient function for timing operations? (i.e., not criterion, because that means I have to lift out the code I wanna time and I only care about ballpark anyway)
02:51:26 <osa1> merijn: I often want something like this. currently I do `getCurrentTime` + diffUTCTime etc. which are really annoying to use.
02:51:33 <osa1> so if you find a better solution let me know :-)
02:51:51 <merijn> osa1: I was thinking of implementing something bracket like, I guess
02:53:10 <merijn> osa1: oh, https://hackage.haskell.org/package/timeit-1.0.0.0/docs/System-TimeIt.html :)
03:06:04 <[exa]> Hm guys, how do different ADT variants actually look from the inside or in the memory?
03:06:25 <[exa]> I always thought it's something like an union with an extra mark
03:07:31 <[exa]> like (extremely roughtly):   data T = T1 Int | T2 String   -->  T = struct { enum {T1,T2} type; union {int a; string b;}; };
03:08:54 <osa1> merijn: yeah I'd seen this but I didn't like the API (currentlya t a meeting)
03:14:14 <quchen> [exa]: Yup, it’s like a C union
03:14:38 <Philonous> Only if the fields are unpacked, no?
03:15:07 <[exa]> quchen: is there a good or common name for the "enum {T1,T2} type" ?
03:15:29 <[exa]> (was it "tagged union", so probably an union tag?)
03:22:46 <whald> hi! i'm having trouble with a program heavily relying on conduit. it simply stops making progress while transferring a largish (~20MB) file over a TCP socket, with no indication of what's going wrong. i have a self-contained example of what i'm doing here:
03:22:52 <whald> http://lpaste.net/356526
03:23:44 <whald> but sadly it does not reproduce the problematic behaviour, yet it illustrates what i'm doing to some extent. the problem only occurs on FreeBSD and only when using the threaded runtime.
03:24:47 <whald> when running with +RTS -Dg, the last few lines of output are always like this: http://lpaste.net/356527
03:25:18 <whald> then nothing happens anymore. could anyone lend me a hand in debugging this?
03:29:27 <JScully> hello ! :) can someone explain what <+> is ? i dont understand the definition here https://www.haskell.org/hoogle/?hoogle=%3C%2B%3E
03:29:50 <[exa]> whald: it stops all at once, or continuously?
03:30:25 <[exa]> whald: also, can you simulate the server by something provably reliable (netcat? httpd?)
03:30:29 <ventonegro> JScully: it's mappend for arrows, it seems
03:30:43 <JScully> what does that mean? :|
03:30:50 <[exa]> aappend.
03:30:53 <[exa]> :]
03:31:06 <ventonegro> JScully: Do you know what a monoid is?
03:31:17 <JScully> no :|
03:31:24 <whald> [exa], what do you mean with continuously? i mean it's completely dead on that connection (there's also a web UI served via websockets, those still work, it's only that one connection that's dead)
03:31:59 <whald> [exa], and yes, i'm using "nc -l -p 5555 > /dev/null" as a "sink" for the connection
03:32:11 <ventonegro> JScully: Learn about monoids first, then it will become obvious
03:32:21 <JScully> alright
03:32:23 <[exa]> whald: like, transfer rate going slowly down to zero, or transfer just stopping in the middle?
03:32:43 <[exa]> in the first case it's buffering, in the other case it's most probably bad polling
03:32:57 <whald> [exa], it completely stuck at once, no observable slowdown before that
03:33:15 <ventonegro> JScully: https://wiki.haskell.org/Monoid
03:35:10 <[exa]> whald: if you have the client isolated, I'd suggest to run it in strace to see whether conduit doesn't stop polling or something
03:35:39 <osa1> merijn: I really like Rust's std::time::Instant API. you get current time using Instant::now() and then .elapsed() method gives you the duration between initialization and now. return type is Duration which allows you to get numbers in microseconds, seconds etc.
03:35:43 <whald> [exa], strace is a good idea, i'll try that. thanks.
03:37:48 <[exa]> whald: strace -f helps for multi-threaded stuff (not sure whether forkIO actually forks)
03:38:25 <whald> [exa], it only happens on FreeBSD, so i'll have to use truss or the like there
03:39:58 <[exa]> oh so, then it's most probably polling :]
03:41:11 <Philonous> osa1, Wouldn't getCurrentTime and elapsed from = (`diffUTCTime` from) <$> getCurrentTime do the same?
03:42:02 <Philonous> [exa], forkIO doesn't for an OS thread
03:42:08 <osa1> Philonous: probably, but NominalDiffTime API is terrible. I've done it a dozen of times and I still can't tell off the top of my head how to get microseconds from it.
03:42:36 <zomg> osa1: good to know I didn't find it hard to use just because I'm not a super pro haskell user
03:42:39 <zomg> :P
03:43:53 <Philonous> [exa], (neither does forkOS btw, despite the name )
03:44:31 <Philonous> doesn't fork*
03:45:12 <merijn> osa1: I actually wrote my own timing thing for C++, it's kinda cool. Can do timings even for latencies of like 10s of nanoseconds :)
03:46:17 <[exa]> Philonous: good to know, thanks
03:46:31 <osa1> yeah implementing that is actually a good exercise, you learn about all the different kinds of clocks etc.
03:46:49 <merijn> osa1: Actually, I could avoid all of that, due to C++11 <3
03:46:55 <dramforever> > toRational nominalDay
03:46:57 <lambdabot>  error:
03:46:58 <lambdabot>      Variable not in scope: nominalDay :: Integer
03:46:59 <osa1> oh, you cheated :-P
03:47:12 <dramforever> > toRational Data.Time.Clock.nominalDay
03:47:15 <lambdabot>  error:
03:47:15 <lambdabot>      Not in scope: ‘Data.Time.Clock.nominalDay’
03:47:15 <lambdabot>      No module named ‘Data.Time.Clock’ is imported.
03:48:09 <merijn> osa1: std::chrono comes with 3 builtin clocks. system_clock, steady_clock and high_resolution_clock, so I just use the latter and rely on the C++ stdlib for being correct :p
03:48:57 <dramforever> osa1: Anyway, FYI there's 'Real NominalDiffTime' in the instance list so you can use realToFrac
03:48:58 <osa1> ahh what did I expect? of course C++ exposes all the low-level details :-) I'm mostly a C programmer outside of Haskell so all I know is libc and POSIX
03:49:01 <dramforever> :t realToFrac
03:49:03 <lambdabot> (Fractional b, Real a) => a -> b
03:49:21 <dramforever> so you can get double/fixed/whatever
03:49:49 <osa1> dramforever: I know there are ways, but the API is not nice IMHO. I shouldn't go through fractional types for timing stuff, the OS gives you all you need in integral types already.
03:50:11 <merijn> osa1: Honestly, I used to be all "no C++", but C++11/14 are far saner tools than C, tbh
03:50:42 <dramforever> osa1: What do you mean?
03:51:07 <dramforever> Oh you want those functions to take picoseconds or fixed point numbers?
03:52:02 <quchen> [exa]: Tagged union, yes. A C union is multiple data written in the same place. If you pair that up with a tag which kind of data was written, you get a sum type.
03:52:53 <quchen> [exa]: It’s like if you’d do (Int, a) in Haskell, with accessors like »get (1, x) = unsafeCoerce x :: String; get (2, x) = unsafeCoerce x :: Bool« and so on
03:53:12 <osa1> dramforever: I mean tm (see `man time.h`) etc. already gives you elapsed time in integers, I don't want to convert those to floats/doubles and then to integers again just because time library doesn't expose those integers to me.
03:53:21 <quchen> With all the safety guarantees of unsafeCoerce :-)
03:53:31 <JScully>  * Variable not in scope: (<+>) :: Bool -> Bool -> t
03:53:35 <JScully> :|
03:54:25 <osa1> dramforever: instead I should be able to get elapsed time in nanoseconds/microseconds/whatever without losing any more precision because of conversions to floating points
03:54:35 <dramforever> Oh that
03:54:37 <dramforever> you don't
03:55:17 <osa1> how?
03:55:19 <dramforever> You can convert to this Fixed thingy (namely Pico) https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Fixed.html
03:55:19 <merijn> hmm
03:55:37 <dramforever> Or this Rational https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Ratio.html
03:55:48 <osa1> so I first convert to Fixed then to Int ?
03:56:11 <merijn> Anyone here have experienced with Vectors of Vectors?
03:56:12 <dramforever> to be fair you could just round it
03:56:40 <merijn> Specifically, is there an easy to pass, e.g., "Vector (Vector Double)" to C code that expects "double **"?
03:57:40 <dramforever> Yes to Fixed then Int
03:59:27 <osa1> dramforever: docs say "Conversion functions will treat it as seconds" so I'm not sure if that'd work
04:02:24 <dramforever> > 1.123456789012345 :: Pico
04:02:26 <lambdabot>  1.123456789012
04:02:37 <Philonous> osa1, diffTimeToPicoseconds gives you an Integer
04:02:54 <Philonous> And doesn't seem to do any conversion
04:02:54 <dramforever> No such thing for NominalDiffTime
04:03:16 <Philonous> Oh wait, DiffTime and NominalDiffTime 
04:03:21 <osa1> dramforever: diffUTCTime gives you NominalDiffTime
04:03:35 <osa1> Philonous: that won't work because diffUTCTime gives you NominalDiffTime1
04:03:43 <Philonous> Yes, I realized
04:03:43 <dramforever> osa1: Treated as seconds, precision to 1e-12
04:04:03 <osa1> OK that makes sense if that's actually how it's implemented
04:04:10 <dramforever> if you would believe me http://hackage.haskell.org/package/time-1.8.0.2/docs/src/Data-Time-Clock-Internal-NominalDiffTime.html#line-66
04:04:19 <dramforever> s/would/won't/
04:05:36 <dramforever> sweet there's an optimization rule there so you don't pay too much cost
04:05:37 <osa1> dramforever: which method should I look for to get a Pico?
04:05:53 <dramforever> realToFrac
04:06:17 <dramforever> You should remember it, it's your friend converting between whatever-point numbers
04:06:34 <osa1> dramforever: nice, thanks
04:06:38 <dramforever> and while we're at it fromIntegral is your ultimate integer conversion friend
04:07:30 <dramforever> and it's realToFrac so it takes some 'a' with instance 'Real a', and fromIntegral takes 'Integral a'
04:07:43 <dramforever> kinda obvious, but then it's easy to miss...
04:08:52 <JScully> does anyone know what kind of circuit this is http://i.imgur.com/5qb0581.png?
04:10:01 <JScully> where I are inputs, O are outputs
04:13:08 <dramforever> half adder
04:15:13 <JScully> thanks
04:15:21 <JScully> no idea how to come up with that :|
04:15:26 <JScully> but i appreciate your input :D
04:15:43 <dramforever> and it's off topic, you probably posted in a wrong channel
04:17:18 <renzhi> is it possible to turn off, even if temporarily, tls certficate verification in stack?
04:28:15 <JScully> so the code i am looking at is working but again i am wondering what it represents :| http://i.imgur.com/qXQ6XHT.png
04:29:03 <JScully> line 15,16 seems to be a fulladder
04:29:32 <JScully> they symbol in line 17 represents an XOR
04:38:42 <Qze> I'm not sure if this is something that can be answered quickly, but what exactly does derive do? A quick google search didn't help me much, but maybe I overlooked something (english isn't my naitive language, so maybe some words I didn't know, I just don't know the term for it)
04:43:07 <dramforever> you mean deriving? That's just writing instances for you
04:45:57 <JScully> why can i put this into ghci line by line but not load as a .hs file? https://pastebin.com/H0qSP5pj
04:46:02 <JScully> parse error (possibly incorrect indentation or mismatched brackets)
04:47:10 <dramforever> remove that 'let' and you'll be good
04:47:53 <dramforever> as for why... because GHCi and Haskell programs work differently
04:48:10 <dramforever> GHCi takes expressions, 'let stuff = thing', and 'result <- action'
04:48:24 <dramforever> nowadays they take 'guy = Person foo bar' too
04:49:51 <JScully> ahh i see
04:50:09 <JScully> i am trying to build and andGate https://pastebin.com/eS5JUFHB
04:51:16 <ventonegro> JScully: I'd guess that halfadder and <+> were defined somewhere else in the same codebase
04:51:26 <JScully> ventonegro thats right
04:51:31 <dramforever> Bool -> Bool -> Bool
04:51:41 <dramforever> that needs to be a function
04:52:44 <JScully> hm yes
04:52:55 <JScully> i dont know how i get variables i can work with :|
04:53:05 <jle`> Qze: if you mean the deriving keyword in haskell, the haskell report (the language spec) is a good description :)
04:53:25 <jle`> JScully: try writing a function
04:53:37 <jle`> are you familiar with defining functions in haskell?
04:53:42 <jle`> foo x = x * 2
04:53:43 <jle`> etc.?
04:53:53 <JScully> basically yes but the task here is, well data Gate = Gate (Bool -> Bool -> Bool) is given
04:54:01 <JScully> now i have to complete "let gateAnd = ..."
04:54:09 <JScully> where i have to write the implementation for "..."
04:54:15 <jle`> what do you want ... to be?
04:54:24 <jle`> gateAnd = "hello"
04:54:42 <dramforever> You got 'Gate (...)', that part's right
04:54:49 <jle`> do you want it to be the logical "and" function, wrapped in Gate?
04:54:51 <JScully> build and andGate using the data type provided
04:54:59 <jle`> if so, just do gateAnd = Gate (put the logical "and" function in here)
04:55:06 <jle`> now you just need to write the logical and function
04:55:08 <jle`> and then put it there
04:55:26 <JScully> so i have to write an extra function?
04:55:26 <jle`> logicalAnd True True = True
04:55:30 <jle`> well
04:55:35 <jle`> you have to give it a function
04:55:39 <jle`> since...it expects a function
04:55:47 <jle`> you can give the built-in one
04:55:54 <JScully> let gateAnd = Gate (a && b, a && c, c && b)
04:55:56 <jle`> gateAnd = Gate (&&)
04:55:58 <JScully> something like this :|
04:56:03 <jle`> (&&) is your logical and function
04:56:07 <jle`> and you can give it to Gate
04:56:17 <JScully> i understand
04:56:20 <jle`> alternatively you can write yuor own logical 'and' function from scratch
04:56:28 <JScully> but how do i name the variables i could work with
04:56:29 <jle`> but if you're allowed to, best to just use (&&)
04:56:35 <jle`> what variables do you mean?
04:56:47 <jle`> "gateAnd = Gate (&&)" should be fine
04:57:03 <dramforever> if you have a function like:
04:57:06 <dramforever> logicAnd x y = ...
04:57:11 <dramforever> Then you've got x and y to work with
04:57:13 <jle`> Gate expects a (Bool -> Bool -> Bool), and (&&) is a perfectly fine (Bool -> Bool -> Bool)
04:57:31 <jle`> in fact it's probably one of my favorite Bool -> Bool -> Bool's
04:57:41 <ventonegro> JScully: This looks like homework, so... If you skipped some previous ones, it would be wise to rewind a little
04:57:47 <jle`> it's like, in the top 4
04:57:58 <ventonegro> JScully: Just trying to be helpful, honestly
04:58:07 <dramforever> yeah
04:58:44 <dramforever> JScully: it does look like either you or the tutorial/whatever you're working with is missing things...
04:59:32 <ventonegro> JScully: I'm saying that because creating functions with variables is lesson 0. You cannot go very far without this knowledge. By far, I mean not at all.
04:59:48 <JScully> how can i use gateAnd then?
05:00:00 <jle`> what do you want to do with it?
05:00:25 <jle`> you can write a function that applies a Gate to two Bool's
05:00:30 <JScully> test it with different inputs
05:00:33 <jle`> runGate :: Gate -> Bool -> Bool -> Bool
05:00:38 <jle`> runGate (Gate f) x y = f x y
05:00:46 <jle`> and then you can `runGate gateAnd True False`
05:00:56 <jle`> `runGate gateAnd False False`, `runGate gateAnd True True`
05:00:58 <jle`> etc.
05:01:11 <jle`> don't read my definition of runGate, if you want to figure out how to write it on your own hehe
05:01:13 <jle`> sorry
05:01:17 <dramforever> that's not very good...
05:01:37 <JScully> i see thanks
05:01:46 <JScully> i wrote functions before but never worked with custom data types
05:01:49 <JScully> that really confused me
05:02:12 <jle`> yeah, it's also kinda confusing here because the constructor and type for Gate are the same
05:02:45 <jle`> but you'll get used to it
05:03:08 <jle`> better might have been data Gate = GateWithFunc (Bool -> Bool -> Bool)
05:03:15 <jle`> then runGate (GateWithFunc f) x y = f x y
05:03:30 <ventonegro> JScully: in `data Gate = Gate (...)` the first Gate is the name of a new type, that second gate is a constructor (function) that gives you a way of building values of that type
05:03:42 <whald> regarding my program which does not work on FreeBSD w/ threaded runtime, i finally could produce a tiny program which reliably shows the behaviour: http://lpaste.net/356530
05:04:07 <ventonegro> JScully: The names don't need to match: `data Gate = MkGate (...)`
05:04:11 <whald> the trick was to also read from the socket (although the netcat endpoint does not actually send any data back)
05:05:23 <ventonegro> JScully: These constructor functors are created by Haskell for you, and they work line a container in other programming languages in that they "hold" their arguments for future use
05:05:35 <JScully> thanks
05:05:41 <JScully> i am aware of constructors :|
05:06:00 <JScully> functinonal programming is just sooo different
05:06:21 <JScully> runGate (Gate f) x y = f x y why do i need a (Gate f)
05:06:25 <whald> if I understand the truss output for the program correctly, the socket will be unable to keep up with the data fed to it at some point, giving "Resource temporarily unavailable" and that's it: http://lpaste.net/356529 -- do you have an opinion about this, [exa] ?
05:06:34 <JScully> why couldn it  do ust runGate f x y = f x y
05:06:49 <JScully> is this some type of casting? :|
05:06:53 <ventonegro> JScully: that's how you get the value back from the constructor
05:07:30 <JScully> ah
05:08:15 <jle`> JScully: it's cause runGate :: Gate -> Bool -> Bool -> Bool
05:08:20 <jle`> 'Gate' is not a function
05:08:27 <jle`> so you can't just do runGate g x y = g x y
05:08:37 <jle`> if the first argument is a Gate, you can't just apply it, ince it's not a function
05:08:45 <jle`> however, it does "contain" a function that you can pattern match to access
05:08:48 <ventonegro> JScully: http://learnyouahaskell.com/syntax-in-functions#pattern-matching
05:09:07 <jle`> runGate f x y = f x y is fine if runGate :: (Bool -> Bool -> Bool) -> Bool -> Bool -> Bool
05:09:44 <dramforever> I doubt if teaching Haskell 101 here would be effective...
05:09:53 <JScully> I understand
05:09:54 <ventonegro> dramforever: Indeed
05:09:58 <dramforever> But maybe you're just confused
05:10:04 <dramforever> In which case it does help
05:10:24 <JScully> yes it helped, thanks
05:10:29 <dramforever> I'm confused about the stuff /= I don't know the stuff
05:14:34 <[exa]> Is there some rigorous automated approach to convert simple functions to monads? Example usage: I have some non-monadic functions that happily call each other and compute something, and I want one to print out "gah" when it's called. So I rewrite it to something like `putStrLn "gah" >> return (original value)` and would like that the compiler would do the same thing with functions that call it (and 
05:14:40 <[exa]> recursively).
05:16:12 <Maxdamantus> By "monads", do you mean IO actions?
05:17:39 <Maxdamantus> or at least elements in some monad, rather than monads themselves.
05:18:01 <Maxdamantus> there is pretty much a systematic way to do it.
05:18:09 <jle`> [exa]: well, you can easily write a higher-order function 'foo x = putStrLn "gay" >> return x'
05:18:14 <jle`> sorry, *gah
05:18:32 <jle`> in fact, foo x = x <$ putStrLn "gah"
05:19:49 <Maxdamantus> eg, for starters, `a b` turns into `ap a b`
05:20:04 <[exa]> jle`: good point with <$ thanks
05:20:24 <[exa]> Maxdamantus: general monads would be cooler, but it's for io, yes
05:20:27 <Maxdamantus> so that means `a b c` becomes `ap (ap a b) c`
05:20:54 <dramforever> I'm afraid automated not that easy...
05:21:10 <dramforever> The first question you would ask, and ask really hard is that: do you really need to do that?
05:21:29 <JScully> now if i want to compare gates, i could do something like instance Eq Gate where.. right?
05:21:44 <dramforever> yes
05:21:53 <[exa]> dramforever: currently I'm forcing the programmer do that, feels like writing boilerplate
05:22:21 <JScully> but then i'd need to name the input variables in order to create my implementation
05:22:27 <JScully> do ihave to defined it in my data type?
05:23:53 <dramforever> Nah you just do something like: Gate f == Gate g = ... compare those two here ...
05:24:02 <[exa]> JScully: this is a good reading to get you through: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
05:24:19 <JScully> ok thanks :)
05:24:24 <JScully> got to read that first
05:24:40 <dramforever> [exa]: Actually you *might* like this: http://hackage.haskell.org/package/each
05:25:06 <[exa]> JScully: I guess there's the exact example with Eq somewhere in the middle
05:25:16 <dramforever> it's template haskell RIP compilation times
05:25:41 <dramforever> And it's a bit limited in what it can handle
05:25:44 <[exa]> don't worry I'm writing worse stuff than TH
05:25:50 <JScully> thanks^
05:26:36 <dramforever> [exa]: I only got the basic syntaxes, so it might not handle your stuffs well
05:27:43 <[exa]> whoa it's your work, goood
05:27:57 <dramforever> send feature requests :)
05:27:58 <[exa]> yes, it's basically what I wanted, thanks
05:28:22 <xelus47> doesn't haskell have an interactive shell?
05:28:35 <dramforever> Warning: could make you angry when it doesn't support your thing
05:28:40 <earthy> xelus47: ghci
05:29:32 <[exa]> dramforever: btw could you elaborate on the limitations? I understand not all syntax is supported
05:30:38 <[exa]> but that doesn't limit me, I actually have the input monomorphized and lifted to single level binding group, abstractions/where/let disallowed, etc.
05:30:53 <dramforever> It doesn't handle where clauses
05:31:00 <dramforever> 'let's are sequential
05:31:05 <xelus47> earthy: ah turns out I already had that installed lol (comes with ghc?)
05:31:54 <[exa]> dramforever: "Parameters to lambda functions may not be used impurely." ?
05:32:12 <dramforever> That example should explain it
05:33:03 <dramforever> it can't change a lambda from a -> b to a -> IO b
05:33:03 <merijn> hmmm, anyone know how I could make Conduit's foldMap strict?
05:33:10 <dramforever> because, well, I don't really know what that means
05:33:55 <[exa]> why not just put return$ there btw?
05:35:00 <[exa]> anyway I guess I get the reason, thanks a lot!
05:35:07 <ADG> problem with type signature : getX :: Ratio Int -> Ratio Double;  getX y = (sqrt(1+5*y*y+2*y)-1-y)/(2*y)
05:36:26 <[exa]> sqrt can produce ratio?
05:36:27 <dramforever> [exa]: FYI I didn't handle do-notation and list comprehensions
05:36:45 <[exa]> dramforever: those are simple actually, desugared for my case
05:37:13 <ADG> oh yes I should do floor
05:37:49 <[exa]> ADG: If you have Ratio Double, you can just "ratio-ize" it by dividing by 1, you don't lose precision then
05:38:46 <[exa]> like, say, (sqrt(..)-1-y) :% (2*y)
05:38:56 * [exa] not an expert on ratio syntax
05:40:21 <[exa]> Also I somehow remember that "Ratio Double" should not work because ratios must be integral, but it might be just me.
05:41:27 <merijn> I just had a genius idea...
05:42:05 <dramforever> I *think* it was late at night when I did the 'let' thingy and I didn't bother sorting let bindings into components at the time
05:42:20 <merijn> "newtype Strict a = Strict { getStrict :: a }; instance Monoid a => Monoid (Strict a) where mappend (Strict x) (Strict y) = x `seq` y `seq` Strict (mappend x y)"
05:43:33 <dramforever> merijn: that's not how it works I think...
05:43:52 <merijn> Instantly halves the time of foldMap when I do "foldMap (Strict . Sum)" vs "foldMap Sum"
05:44:17 <merijn> dramforever: Why wouldn't that work according to you?
05:44:23 <[exa]> merijn: well, that's extremely strict
05:44:47 <dramforever> Say mappend is (+) for Int, (+) is already strict in both args, so your 'x `seq` y `seq` Strict (mappend x y)' does nothing more than 'Strict (mappend x y)'
05:45:00 <dramforever> I think
05:45:34 <dramforever> but now you've said that...
05:45:37 <merijn> dramforever: By that logic "foldl (+) 0" doesn't leak memory
05:45:53 <merijn> dramforever: (+) might be strict, but it doesn't force the arguments until the result is forced
05:46:08 <merijn> dramforever: foldMap doesn't force it's argument while it's running either
05:46:18 <merijn> The mappend on Strict *does*
05:46:33 <dramforever> strange
05:46:40 <dramforever> I think I'm missing something here
05:47:14 <merijn> dramforever: (+) still builds up thunks, it only evaluates it's argument when it's result is evaluated
05:47:16 <barrucadu> If `x` or `y` is a thunk, then pattern matching on the `Strict` in `mappend` will force that thunk
05:47:51 <dramforever> it's a newtype
05:48:00 <merijn> dramforever: How is that relevant?
05:48:20 <dramforever> pattern matching on a newtype doesn't cause it to be evaluated
05:49:22 <[exa]> merijn: any guess on whether the thunks build up inside or outside of Sum?
05:49:30 <kuribas> dramforever: but seq does?
05:50:00 <dramforever> seq causes both to be evaluated if you evaluate the whole thing
05:50:02 <merijn> dramforever: The thunk needs to be evaluated to compute "Strict x", and that forces x via seq
05:50:34 <dramforever> @let newtype Thing = Thing Int
05:50:35 <lambdabot>  Defined.
05:50:50 <dramforever> > case undefined of Thing _ -> "I'm legit confused"
05:50:52 <lambdabot>  "I'm legit confused"
05:51:42 <cocreature> merijn: you’ll still loose over foldl' since foldMap is implemented via foldr for [] iirc
05:51:47 <quchen> merijn: Your Strict mappend does not force its arguments when it’s not forced itself
05:51:58 <quchen> Your thunk will be (mappend x y)
05:52:00 <merijn> cocreature: Yeah, I noticed
05:52:20 <merijn> cocreature: It's like 22x slower than foldl over a vector
05:52:44 <cocreature> that reminds me that I still need to make some proposal to change sum and product to use foldl'
05:53:02 <dramforever> seriously, what
05:53:03 <quchen> b-b-but lazy nats!
05:54:00 <merijn> Sadly my C FFI code is dramatically faster than the pure haskell, although I'm not sure why...
05:54:07 <dramforever> You just *cannot* make foldl super strict, right?
05:54:31 <kuribas> it needs to be lazy for some special cases
05:54:42 <quchen> What’s »super strict«?
05:54:48 <barrucadu> @let instance Monoid Thing where mempty = Thing 0; mappend (Thing x) (Thing y) = x `seq` y `seq` Thing x
05:54:49 <lambdabot>  Defined.
05:54:56 <merijn> I guess I'll just use Conduit.foldl rather than Conduit.foldMap
05:54:57 <barrucadu> > Thing 3 `mappend` Thing undefined
05:54:59 <lambdabot>  error:
05:54:59 <lambdabot>      • No instance for (Show Thing)
05:54:59 <lambdabot>          arising from a use of ‘show_M174618698090175773723640’
05:55:02 <barrucadu> Whoops
05:55:24 <barrucadu> > Thing 3 `mappend` Thing undefined
05:55:27 <lambdabot>  *Exception: Prelude.undefined
05:55:29 <barrucadu> Looks strict to me
05:55:42 <barrucadu> @let instance Monoid Thing where mempty = Thing 0; mappend (Thing x) (Thing y) = Thing x
05:55:43 <quchen> Yup.
05:55:44 <lambdabot>  .L.hs:161:10: error:
05:55:44 <lambdabot>      Duplicate instance declarations:
05:55:44 <lambdabot>        instance [safe] Monoid Thing -- Defined at .L.hs:161:10
05:55:45 <barrucadu> > Thing 3 `mappend` Thing undefined
05:55:48 <lambdabot>  *Exception: Prelude.undefined
05:55:50 <barrucadu> Ah, can't change the instance
05:56:33 <quchen> It will still overflow if you use it in foldl.
05:56:50 <quchen> (Like +, and for exactly the same reasons.)
05:57:04 <merijn> ugh...looks like conduit is also adding a non-trivial amount of overhead :\
05:57:10 <dramforever> hmm
05:57:21 * dramforever is still confused
05:57:45 <barrucadu> `case undefined `seq` Thing 3 of Thing _ -> "hello world"` works, `case undefined `seq` Thing 3 of Thing x -> x` gives undefined
05:58:07 <dramforever> yep
05:58:07 * merijn sighs
05:58:09 <kuribas> > foldl (\a x -> if (x == 0) then [] else x:a) [] [undefined, 2, 0, 3, 4]
05:58:09 <barrucadu> So it appears that pattern matching on the constructor doesn't cause evaluation, but trying to actually use the wrapped value does
05:58:11 <lambdabot>  [4,3]
05:58:11 <quchen> Yes, because in the second case the failable pattern requires the scrutinee to be evaluated.
05:58:14 <kuribas> > foldl' (\a x -> if (x == 0) then [] else x:a) [] [undefined, 2, 0, 3, 4]
05:58:16 <lambdabot>  *Exception: Prelude.undefined
05:58:17 <merijn> 2 orders of magnitude slower in pure Haskell :\
05:59:06 <dramforever> that's why I thought 'x `seq` y `seq` Strict (mappend x y)' doesn't help if 'mappend' is already strict in both args
05:59:35 <cocreature> dramforever: I think you’re right here
05:59:51 <merijn> It's doing *something*, though even if not what I intended
05:59:59 <dramforever> So there must be something else
06:00:01 <merijn> Because my runtime dropped from 36s to 22s
06:00:44 <JScully> hm it did not help me so far because the example is using value contructors
06:00:46 <cocreature> are we talking about the Num instance of Int or something else?
06:00:54 <JScully> whic can be used inside where...
06:01:10 <dramforever> Could be a subtle fengshui change?
06:01:13 <kuribas> merijn: what are you trying to do?
06:02:15 <merijn> kuribas: I have decision tree that I need to evaluate for a large (several million) number of datapoints. I had a C implementation, I'm trying to get the Haskell version up to snuff, but so far Haskell + vector is losing badly to C FFI
06:03:02 <merijn> kuribas: We're talking a 2 orders of magnitude hit *minimum*
06:03:02 <dramforever> vector for the tree?
06:03:11 <merijn> dramforever: The tree is a vector, yes
06:03:20 <kuribas> merijn: perhaps the C code is using SIMD?
06:03:28 <merijn> kuribas: Doubt it, not very SIMD amenable
06:04:52 <kuribas> merijn: using unboxed vectors I suppose?
06:04:57 <merijn> Storable
06:06:49 <kuribas> I would expect just some constant decrease in performance.
06:07:02 <merijn> Me too, hence confusion
06:07:34 <dramforever> what does profiling say?
06:07:43 <kuribas> also compare the core and assembly output
06:08:05 <merijn> hmmm, lemme try one thing
06:08:32 <merijn> dramforever: Haven't profiled yet. There's a lot of slow/messy code around it which makes it hard
06:08:48 <dramforever> uhh
06:08:56 <kuribas> or perheaps overhead from marshalling storable?
06:09:02 <merijn> oh, I think I have an idea
06:10:42 <merijn> ugh...I wonder if I'm getting fucked over by Vector using Int for indexing...
06:11:54 <infandum> In a stack.yaml file, I can link to a local package in the "packages" key, so I can fork a repository and have it as a git submodule in my program to link to under my control. How can I do that in a *.cabal file?
06:12:02 <merijn> These are the C and Haskell implementations: http://lpaste.net/37934615742119936
06:12:32 <merijn> Since Vector demands Int for indexing I end up having to fromIntegral every value, I wonder if that's slowing me down
06:13:44 <merijn> But I don't see how I can avoid that...
06:14:34 <merijn> I could switch to my datatype to Int, but that'd screw with locality
06:17:36 <merijn> Running the Haskell version inside a conduit loop takes about 2s, the C version in a conduit takes about 2.5s, but using Vector.foldM' to run the predictor directly ends up taking 0.95s for Haskell, but 0.03s for the C version
06:19:27 <[exa]> merijn: tried to measure # of allocator calls?
06:21:10 <kuribas> merijn: I wonder if it isn't just overhead from storable.
06:21:19 <kuribas> merijn: like the adress calculations.
06:21:21 <merijn> kuribas: Could be, but that'd suck
06:21:43 <merijn> kuribas: I can try hardcoding those, I suppose
06:22:02 <kuribas> merijn: but they "should" inline properly.
06:22:24 <dramforever> I would really hope that it's not allocating a new Node for every call
06:23:01 <dramforever> will the optimizer change that into a 'go' function taking 4 arguments?
06:26:45 <kuribas> I wonder how binary+bytestring would compare.
06:27:34 <merijn> kuribas: Why would you expect that to be better? That doesn't allow random access
06:28:19 <kuribas> you can index into the bytestring manually, but you'll still need to convert to a haskell type...
06:28:53 <merijn> I don't see why that would be faster, though
06:28:55 <dramforever> Yeah it worked, no Nodes created
06:31:56 <kuribas> merijn: what does the core and assembly say?
06:32:12 <dramforever> Why is it cracking a Vector open every time, though?
06:32:44 <merijn> kuribas: I haven't looked at those yet, since this code is embedded in a large other body of code and not easily lifted out (since I wouldn't have access to my dataset then)
06:32:53 <merijn> dramforever: What do you mean?
06:33:35 <dramforever> Core has this *inside* the loop: case w_s8L3 of _ { Vector dt_a7TS dt1_a7TT dt2_a7TU ->
06:36:57 <merijn> ohohoh! Interesting
06:36:59 <dramforever> merijn: ^ that's the only boxed thing I can find there
06:37:14 <merijn> Hardcoding the sizeof offsets is a pretty big win
06:37:15 <dramforever> the rest are all nicely #-ified
06:37:50 <merijn> So, here's where it gets interesting
06:38:38 <merijn> I have a conduit returning queries from SQL. My very first test was just dumping all the SQL data into a Vector, then looping over the vector to run the predictions
06:38:45 <dramforever> how come?
06:39:03 <dramforever> I see stuff like 'readInt32OffAddr# (plusAddr# a_a87F 8#)' everywhere
06:39:29 <dramforever> was that not enough-inlined?
06:40:29 <merijn> And the C versions is much faster than the Haskell when running over the Vector. However, running both in a conduit directly over the data I see two things: C is only negligibly faster than Haskell. And both computation loops are half the time it takes to build the vector in the first place
06:41:31 <tfc[m]> hi there. i am running some http conduit code within a runResourceT block. i generally don't want any return value from it, but i also want to catch if anything bad happened inbetween. can anyone help me? runResourceT seems to swallow all exceptions. https://pastebin.com/Ju2HvZGb
06:43:08 <fosskers> hi all
06:43:16 <fosskers> I have the type: newtype Tile p r a = Tile { _array :: Array r DIM2 a }
06:43:22 <fosskers> which wraps the `Array` type from the `repa` library.
06:43:27 <fosskers> But I'd like to hide the `r`: newtype Tile p a = Tile { _array :: Array ? DIM2 a }
06:43:33 <fosskers> because it's a detail I'd like to hide from the user. Unfortunately, that `r` can change between repa operations.
06:43:38 <fosskers> Most of the time it's `D` ("delayed representation")
06:43:43 <fosskers> but when the data is first created, it's `U` ("unboxed vector") or `V` ("boxed vector").
06:43:48 <fosskers> Is there a way for me to hide the `r` as I'd like, but allow it to vary naturally internally without affecting typechecking with my wrapper `Tile` type?
06:44:03 <merijn> dramforever: hmm, actually across multiple runs the difference seems to disappear. Then again it's all rather noisy data
06:44:50 <kuribas> so haskell is saved?
06:45:07 <merijn> dramforever: At least when directly streaming over the data the Haskell version doesn't lose too much to C (roughly the same runtime). So even though the C version *can* beat it in a tight inner-loop, it's irrelevant, since the tight inner-loop takes more time to setup than streaming directly to either C or Haskell does
06:45:50 <dramforever> well, that's pretty nice
06:46:30 <merijn> Although I still think Haskell needs a nicer Storable infrastructure :p
06:46:46 <dramforever> and you didn't use unsafeIndex
06:47:12 <merijn> oooh...I hear the sound of more speed
06:47:15 <dramforever> or did you just turn them off with a flag?
06:47:53 <mniip_> I hear the rumble of disabled optimizations, out of bound accesses and misaligned pointers. In the distance, sirens
06:48:02 <merijn> mniip_: pffft
06:48:09 <merijn> misaligned pointers are irrelevant on x86/x64
06:48:28 <merijn> Unsafe is just code for "Gotta go fast!"
06:48:49 <dramforever> you can preprocess the tree to see if all the branches are in bounds
06:48:54 <merijn> Gotta "foreign import ccall unsafe" too ;)
06:48:54 <mniip_> it's not the speed that kills you
06:49:04 <dramforever> then it doesn't matter as much
06:49:08 <merijn> dramforever: The branches are in bounds.
06:49:20 <merijn> dramforever: I'm *generating* the tree, so I know their valid
06:49:29 <merijn> s/their/they're
06:49:34 <dramforever> :)
06:49:44 <dramforever> it depends
06:50:08 <merijn> If they're not valid I have bigger issues...
06:50:10 <dramforever> I might actually do the check so I sleep better
06:50:45 <merijn> dramforever: I wanna run this stuff on a couple 100k datapoints a few hundred times and want preferably results that finish as soon as I hit enter :p
06:51:15 <merijn> CPU cycles matter!
06:51:26 <mniip_> so I've been thinking,
06:51:28 <dramforever> It really depends.
06:51:29 <merijn> He said, right before the binary segfaulted ;)
06:51:50 <dramforever> getting 'error "big issue!"' is much better than segfault
06:51:52 <merijn> oh...
06:51:58 <merijn> I know why it segfaulted >.>
06:52:01 <mniip_> does it make sense to have a FOL theory with comprehension but not membership
06:52:13 <merijn> Accidentally deleted a touch on the foreign pointer
06:53:00 <merijn> This wouldn't have happened with linear types!
06:53:12 <mniip_> where you can always say forall (X in C). P(X), but (X in C) as a predicate is not always available
06:53:15 <dramforever> So it was the C part segfaulted?
06:53:22 <dramforever> s/part/version that/
06:53:38 <merijn> dramforever: No, but I'm converting a ByteString to Vector via it's ForeignPtr in completely unsafe ways :p
06:53:50 <merijn> dramforever: So I need to ensure the ForeignPtr stays alive while my vector is :)
06:54:03 <dramforever> ah yep
06:54:10 <merijn> dramforever: But while deleting dead code I deleted the touchForeignPtr too :)
06:55:46 <merijn> Whoo...now I'm slightly beating the C conduit
06:56:03 <halogenandtoast> If I have a list of functions (not fixed length) and I want to thread a value through them all, what is the way to do that. Guess I want something that is [a -> a] -> a -> a
06:56:09 <halogenandtoast> Didn't see anything on hayoo immediately
06:56:16 <quchen> :t foldr (.) id
06:56:17 <lambdabot> Foldable t => t (b -> b) -> b -> b
06:56:23 <Philonous> Is hackage down?
06:56:27 <halogenandtoast> quchen: that looks about right
06:56:28 <dramforever> merijn: how many dimensions are there?
06:56:29 <halogenandtoast> thanks!
06:56:43 <merijn> dramforever: Varies
06:56:52 <dramforever> Roughly?
06:57:13 <merijn> dramforever: Probably won't ever exceed 100. Most likely the main cases will have 5-30
06:58:40 <kuribas> merijn: if C is faster, why not just use it?
06:58:53 <dramforever> I was thinking, maybe we could just keep partitioning the data
06:59:22 <merijn> kuribas: Well, it's not faster when I'm processing my input data stream directly
06:59:37 <dramforever> but we would probably spend too much time shuffling the data around
06:59:46 <kuribas> so SQL is the bottleneck?
06:59:51 <merijn> kuribas: Conduit of 115k items from SQL is taking 18s with my pure Haskell conduit, vs 21s with the conduit calling out to Haskell
07:00:56 <merijn> kuribas: Not entirely, since the Haskell version is slightly faster
07:01:13 <dramforever> partition (<= threshold), recurse to both sides, and after everything's done write the results back
07:01:52 <dramforever> I dunno what that would be
07:01:54 <merijn> dramforever: I'm not sure what you mean?
07:02:06 <merijn> What would the point of recursing to both sides be?
07:02:27 <kuribas> merijn: slightly isn't really relevant.
07:02:56 <dramforever> well, some of your data goes to the left branch, and some to the right
07:03:23 <merijn> kuribas: Well, it's relevant in that keeping all the processing inside haskell makes it simpler tomodify, since I have a single representation
07:03:41 <kuribas> right
07:04:10 <Grisha> Hi everyone
07:04:23 <merijn> kuribas: I'm moving a bunch of python + C to haskell (because python sucks and generating C from python also sucks). So I needed to validate using Haskell wouldn't significantly slow me down
07:04:25 <dramforever> So you don't need to follow tree branches for every data point, but then you need to shuffle the data around quite a lot
07:04:38 <merijn> kuribas: And then I got sidetracked fiddling to make the Haskell stuff as fast as the C bit
07:04:44 <Grisha> I’m parsing de-serializing JSON with the help of Aeson, but have as a complication that integers are quoted too
07:04:55 <Grisha> is there a quick way to overcome that?
07:05:03 <dramforever> merijn: Oh wait your thing *has* to be streaming right?
07:05:16 <Grisha> basically Aeson gives up trying to parse an Int out of “123” (quoted)
07:05:28 <merijn> dramforever: Well, it doesn't *have* to be. But Sorting 115k datapoints is likely going to cost more time than it gains
07:05:39 <dramforever> true...
07:05:48 <dramforever> with so many dimensions
07:05:58 <davr0s> just thinking about GC and rendering,    https://gist.github.com/dobkeratops/26b8ea7d070182d67b6a54fe4d630551     i'm wondering how much control/efficiency is possible in haskell  r.e. this kind of situation
07:06:07 <merijn> dramforever: As evidenced by the fact that just dumping them all to a vector is slower than processing the stream directly
07:06:10 <lyxia> Grisha: you'll have to write a separate parser
07:06:14 <quchen> Grisha: You can write your own parser for integer-looking strings, »fromJSON >>= \str -> case readMaybe str of Nothing -> fail "string isn’t an Int"; Just i -> pure i«
07:06:18 <dramforever> merijn: uh oh then
07:06:52 <Grisha> lyxia, quchen: like I suspected, thanks
07:06:52 <merijn> dramforever: Dumping to a vector cost 30-50s, processing the stream as it comes in is down to ~20s :)
07:06:53 <Philonous> Grisha, You can either replace the Ints in your data structure with a newtype and write To/FromJSON instances that handle strings or manually write To/FromJSON instances for your type 
07:07:15 <merijn> dramforever: So, even the C version only taking 0.03s on the vector, I still lose converting first. I don't see sorting improving the situation :p
07:07:35 <dramforever> You must have got a really small tree
07:07:47 <merijn> dramforever: ~8k nodes
07:08:07 <dramforever> comparing that to 100k data points
07:08:13 <dramforever> with like 5~30 dimensions each
07:08:20 <Grisha> lyxia, quchen, Philonous: I tried the approach mentioned in Aeson docs by expressing parseJSON through withObject, but my other fields are optional, i.e. of Maybe X types and that doesn’t mix well
07:08:27 <merijn> dramforever: You don't compare in all datapoints and you don't visit nearly all nodes
07:08:38 <merijn> dramforever: The question is: How deep is the tree :p
07:09:10 <dramforever> Uh, I was talking about speculations on why dumping to a vector is slow
07:09:13 <quchen> Grisha: I don’t understand – do you have an example JSON structure?
07:09:17 <merijn> dramforever: ah
07:09:18 <quchen> Preferrably minimal :-)
07:09:57 <merijn> dramforever: I think the problem is that a Vector of Vector introduces a lot of allocations, and it slows down GC (since it has a large live set)
07:10:04 <whald> does anyone know what happened to Type.Reflection.typeRepFingerprint with the current GHC devl version? i'd like to compile hashable which tries to import it, but it's not there. :-/
07:10:12 <Grisha> {“name”: “Grisha”, “no_of_fingers”: “10”, “job”: “lazyBastard”}, “job” being optional
07:10:13 <merijn> dramforever: Streaming I only allocate 1 small vector per element which gets GCed right away
07:10:36 <dramforever> Yes, that's what I was talking about :)
07:10:36 <dolio> I heard Vector.
07:10:42 <dramforever> So, yeah
07:11:00 <Grisha> quchen: https://hackage.haskell.org/package/aeson-1.2.1.0/docs/Data-Aeson.html
07:11:12 <Grisha> quchen: there is an example starting with `data Coord`
07:11:28 <Grisha> it does work indeed, but suppose that we have y :: Maybe Double instead
07:11:39 <merijn> dolio: Yes, I was fiddling with getting my Haskell port of C code as fast as possible: http://lpaste.net/37934615742119936
07:11:58 <Grisha> then the specified instance of FromJSON through `withObject` wouldn’t work
07:12:02 <merijn> "Unsafe all the things!", etc.
07:12:17 <quchen> Grisha: Have you seen the .:? function? It’s there for possibly-absent values
07:12:31 <Grisha> quchen: nopes, thank you
07:14:38 <quchen> Grisha: Something like this, http://lpaste.net/356534
07:15:06 <quchen> Where Person :: Text -> Int -> Maybe Text -> Person
07:16:07 <Grisha> Thanks a lot!
07:16:10 <Grisha> I’m trying it out
07:18:04 <freeside> hey, i have a dumb question. i *think* i know what is going on, but i'd like to be sure: in `let Ok e = pExp (myLexer s)` is the `Ok e` a destructuring of the value returned by pExp, into a data constructor `Ok` and whatever its argument is, `e`?
07:18:27 <merijn> freeside: yeah
07:18:44 <freeside> righto
07:19:09 <freeside> and so it's the same thing as pattern matching in a function definition
07:19:13 <Grisha> quchen: where exactly do you cast String to Int?
07:19:31 <freeside> what happens if pExp returns an `Err e` instead of an `Ok e`?
07:19:50 <dolio> merijn: Yeah, ! does bounds checking, I think.
07:19:50 <merijn> freeside: You crash :p
07:20:07 <merijn> dolio: I switched to unsafeIndex now, that shaved off a bit of time
07:20:34 <quchen> Grisha: readMaybe :: Read a => String -> Maybe a
07:20:43 <freeside> so a better way of writing that code would be something involving a case statement, yeah?
07:20:45 <quchen> Grisha: Here »a« is »Int«
07:20:50 <Grisha> quchen: I see, thanks a lot!
07:20:59 <quchen> Grisha: It’s a safe version of »read«
07:21:03 <Grisha> got it
07:21:05 <Grisha> great
07:21:16 <quchen> Grisha: There is a »?« too much in my code, but you’ll find it when you compile ;-)
07:21:44 <Grisha> quchen: just before “no_of_fingers"
07:21:46 <Grisha> right?
07:21:55 <quchen> Yup :-)
07:22:04 <quchen> Assuming that field is always there
07:23:30 <dolio> merijn: It's not clear to me whether GHC will be able to avoid building the Nodes, which is probably the biggest performance loss.
07:23:53 <Grisha> quchen: it compiles but doesn’t parse yet ;-)
07:24:30 <quchen> EEek
07:24:36 <quchen> Hmm.
07:24:49 <merijn> dolio: dramforever looked at the Core and said it didn't construct them
07:25:00 <merijn> dolio: But I don't know how to write this without going through something like Node
07:25:11 <dolio> Right, of course.
07:25:17 <Grisha> quchen: works if I comment out the type conversion code
07:25:23 <Grisha> i.e. .:? works
07:25:30 <merijn> You could maintain 1 Vector per value, but that'd defeat all the locality you get from this version
07:30:00 <davr0s> is there an operator which is 'fmap' backwards, (i made one but does one exist already?)
07:30:23 <merijn> I think I've seen <&> somewhere
07:30:27 <merijn> @hooge (<&>)
07:30:27 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
07:30:28 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
07:30:28 <lambdabot> Lens.Micro (<&>) :: Functor f => f a -> (a -> b) -> f b
07:30:31 <kadoban> davr0s: <&> I think it might be in lens and elsewhere
07:30:35 <davr0s> .. what would be most intuitive symbol for it
07:30:49 <Grisha> davr0s: pamf
07:30:58 <kadoban> xD
07:30:59 <shapr> ha!
07:30:59 <davr0s> i had in mind that it was more like piping, hence i wanted to make it look like an arrow going form left to right
07:31:01 <shapr> bashism!
07:31:03 <merijn> davr0s: Well, & is in base as "flip ($)" so <&> makes sense as "flip (<&>)"
07:31:24 <davr0s> $>>   to make it look like fmap <$>
07:31:35 <davr0s> something like that perhaps.
07:31:42 <freeside> elm uses |> iirc
07:31:44 <kadoban> davr0s: Arrows are going to start to remind me of $> or something, which is ... not right
07:31:49 <sproingie> purescript uses >>>
07:32:28 <sproingie> which actually ought to work in haskell too
07:32:29 <davr0s> i think |> makes me think of something simpler i.e. what it is in F#?
07:32:37 <maksim_> what do you guys think of f# compared to haskell?
07:32:43 <sproingie> i think it's |> in f# also
07:33:13 <freeside> yeah, elm stole |> from F#
07:33:14 <quchen> Grisha: http://lpaste.net/356535
07:33:20 <merijn> maksim_: F# is basically ocaml, so worse than Haskell, but if the choice is getting paid to do ocaml/F# or paid to do C, I would probably pick ocaml/F# :p
07:33:21 <davr0s>     (|>)     a -> b ->  b a      vs   (flip ($))  m a   ->  (a->b) ->  m b
07:33:29 <maksim_> merijn, worse how?
07:33:51 <merijn> maksim_: Not pure, lacking some of the fancy stuff GHC keeps improving every release, etc.
07:33:51 <Grisha> quchen: thanks a lot!
07:34:09 <maksim_> not pure is an advantage in my opinion. fancy stuff like what?
07:34:14 <c_wraith> maksim_, F# is a fine language for using .NET but it definitely is short of haskell in flexibility and power. 
07:34:32 <angryMonk> Kinda has a point there.
07:34:34 <freeside> all languages suck.
07:34:36 <quchen> First time I’ve used »stack script« and I must say it’s pretty neat
07:34:40 <sproingie> not an advantage in mine, i can add impurity to a pure language, i can't demand purity from an impure one
07:34:50 <merijn> sproingie++
07:34:52 <sproingie> well i can, but the compiler won't help me
07:34:57 <angryMonk> Also, F# syntax is a bit weird to look at when you're used to Haskell.
07:35:13 <davr0s> freeside maybe every language does one thing very badly and one thing very well 
07:35:20 <angryMonk> it's like uncanny valley - so close but it throws you off a bit)
07:35:42 <Hafydd> Counterexample: PHP does nothing well.
07:35:50 <freeside> i recently enjoyed http://wwwusers.di.uniroma1.it/~lpara/LETTURE/wadler-angry.pdf
07:35:59 <quchen> Hafydd: It’s really good at being consistent at doing that though
07:36:01 <sproingie> my choice these days is get paid to do PHP or don't get paid to write haskell
07:36:27 <freeside> er, http://homepages.inf.ed.ac.uk/wadler/papers/how-and-why/how-and-why.pdf may be more readable
07:36:54 <sproingie> idris can generate PHP output, so maybe i'll look into that ;)
07:36:56 <angryMonk> freeside, thanks.
07:37:18 <Hafydd> But why would choose to generated PHP!?
07:37:23 <sproingie> i mean, the php backend was written on a dare as a joke
07:37:26 <xelus47> why does this give an error? "NUMBER :: Integer"
07:37:30 <Hafydd> Oh...
07:37:35 <sproingie> but then again that has to be the most charitable explanation of PHP itself
07:37:41 <Hafydd> Hahah.
07:37:44 <merijn> xelus47: Starts with a capital letter, so must be a constructor
07:37:50 <xelus47> :P
07:38:26 <sproingie> as for why i'd use it: writing wordpress plugins
07:38:35 <xelus47> merijn: ty it works
07:38:54 <angryMonk> xelus47, if you really need it to be all caps, begin it with an underscore
07:39:00 <angryMonk> _NUMBER
07:39:02 <Grisha> quchen: tada!
07:39:13 <xelus47> angryMonk: it's now called "nUMBER"
07:39:17 <Grisha> quchen: now it does parse too
07:39:22 <angryMonk> sure that works too
07:40:47 <Grisha> quchen: I forgot to replace “no_of_fingers” by the actual name of the field in my code :~)
07:40:48 <sproingie> the restriction on uppercase identifiers really puts a crimp in my writing LOLSKELL
07:40:57 <davr0s> i wonder if error messages could be improved by specifying frequently mis-used functions e.g.    'this is what the signature of X is not, and if this matches better in the place it's found, give this error message'
07:41:07 <davr0s> i'm thinking of 'the wrong arrow'
07:41:13 <quchen> Grisha: The parse error should have mentioned that, no? »unrecognized field fingerbla«
07:41:17 <xelus47> :quit
07:41:44 <Grisha> quchen: unfortunately it doesn’t
07:41:52 <Grisha> `decode` just returns Nothing
07:41:53 <angryMonk> davr0s, do go on
07:42:18 <angryMonk> so function errors based on commonly misused type signature?
07:42:27 <davr0s> yes,
07:43:02 <angryMonk> like 6^(3.4) would say "Exponent is _____ when it should be Int"
07:43:12 <quchen> Grisha: Oh! Use eitherDecode!
07:43:13 <davr0s> yeah,  
07:43:14 <freeside> if one can do type inference based on code, why not code inference based on types?
07:43:16 <sproingie> SPJ has an interesting paper (going by the abstract) on improving error messages
07:43:19 <sproingie> https://www.microsoft.com/en-us/research/publication/diagnosing-type-errors-class/
07:43:28 <quchen> Grisha: or was it decodeEither? Anyway, it includes a small error message
07:43:40 <davr0s> so imagine if you could explicitely write somethign in the library: an alternate signature to test, and a specific error message to give  if it works 'better' than what the user tried.
07:43:42 <lyxia> freeside: Type classes do that somewhat.
07:43:46 <sproingie> well not so much improving the messages as identifying the most likely cause
07:43:50 <Grisha> quchen: will do, now just playing around
07:44:06 <sproingie> (which seems a short step to improving the messages)
07:44:35 <lyxia> freeside: also, http://hackage.haskell.org/package/djinn
07:45:11 <sproingie> freeside: idris and agda can infer implementations from types.  maybe that'll happen for dependent haskell
07:46:04 <davr0s> <$>::f a -> (a -> b) -> f b =>    error 'maybe you meant ... <&>'
07:46:08 <sproingie> tho it seems more a matter of decent IDE support nowadays
07:47:04 <davr0s> you could load the simplest arrow to type with a load of those
07:47:33 <davr0s> e.g. ask  >>  to also test the signatures of >>= >=>   etc etc .. and tell you which one fitted better
07:47:34 <freeside> nod nod
07:48:13 <sproingie> i'd like it if the code entry UI were more advanced than Notepad and didn't lead me to writing such typos in the first place
07:48:20 <davr0s> of course the combinations would explode, so this is only going to be useful for small incremental changes
07:48:43 <davr0s> i'm not really thinking of typos, more 'the user really didn't remember which was the right arrow'
07:49:07 <sproingie> it's the types that tell you that though
07:49:36 <davr0s> hah typos vs TYPEos
07:50:02 <sproingie> i tend to write in statically typoed languages
07:50:25 <freeside> haha
07:54:51 <antoine1> hi
07:55:01 <freeside> hi
07:55:14 <quchen> Idris and Agda have trouble inferring the types of values though, which is something Haskell has on them. (There are good reasons they can’t, but still.)
07:55:30 <antoine1> litle question:
07:55:36 <antoine1> * little
07:55:47 <angryMonk> > putStrLn "Hello, antoine1"
07:55:49 <lambdabot>  <IO ()>
07:56:02 <freeside> is a little question a questino?
07:56:08 <angryMonk> yes
07:56:12 <antoine1> questino?
07:56:12 <angryMonk> absolutely yes
07:56:45 <angryMonk> So what's your questino, antoine1>
07:56:55 <antoine1> x <- getLine
07:57:02 <antoine1> case x of …
07:57:22 <antoine1> is it possible to translate it in the >>= notation?
07:57:51 <kuribas> you want lambda-case
07:58:05 <antoine1> because, it should, the do notation being sintaxic sugar for >>=
07:58:11 <antoine1> * syntaxic
07:58:33 <quchen> antoine1: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#desugaring-do-notation
07:58:34 <kuribas> antoine1: getLine (\x -> case x of _ ...)
07:58:51 <kuribas> antoine1: erm getLine >>= (\x -> case x of _ ...)
07:58:56 <angryMonk> antoine1, you're looking for desugaring do statements.
07:59:09 <antoine1> kuribas, hum, yeah, I guess so, ’cause case of won’t work
07:59:13 <antoine1> or case () of
07:59:22 <antoine1> the types won’t be right
07:59:30 <angryMonk> well, think of it this way
07:59:53 <antoine1> I was trying to shorten, and test if my understanding was right
08:00:07 <angryMonk> would you try to stuff a case a of into a bind directly?
08:00:48 <angryMonk> write a function that acts on x and then do whatever you were doing earlier
08:00:57 <antoine1> well, I tried `… >>= case of`
08:01:05 <antoine1> could have worked ¯\_(ツ)_/¯
08:01:10 <antoine1> (i guess)
08:01:13 <sproingie> @undo do { x <- 123; print x; }
08:01:13 <lambdabot> 123 >>= \ x -> print x
08:01:40 <nshepperd_> There's an extension for that
08:01:47 <nshepperd_> LambdaCase
08:02:30 <nshepperd_> getLine >>= \case { ... }
08:02:52 <TheFlash> preciso de ajuda alguem pode me ajudar
08:03:00 <TheFlash> comandos  demirc
08:03:21 <antoine1> or with a partially applied function `getLine >>= case (compare x) of …`
08:03:23 <glguy> TheFlash: This is an English language channel.
08:03:44 <antoine1> mi español es muy malo
08:03:47 <TheFlash> portuguese  please
08:03:57 <sproingie> not here
08:03:58 <nshepperd_> :t \case { x -> x + 1 }
08:03:59 <glguy> TheFlash: Sorry, English only.
08:04:00 <lambdabot> Num a => a -> a
08:04:14 <angryMonk> ummm, can we stick to English since we all know it?
08:04:52 <antoine1> that’s why his spanish was strange…
08:05:04 <antoine1> it wasn’t spanish…
08:05:15 <asridaran> I have a question on category laws. Can someone tell me how the identity & composition laws help maintain the functor instance?
08:05:48 <quchen> asridaran: The functor laws help maintain the Functor instance.
08:06:19 <TheFlash> Me ajudar chama noreservado que falo doqalguem podeere preciso
08:06:22 <lyxia> What do you mean by "maintain"?
08:06:23 <asridaran> @quchen: Ya but how? how to they guarantee it? i am not able to understand it
08:06:23 <lambdabot> Unknown command, try @list
08:06:26 <glguy> Este é apenas um canal de língua inglesa.
08:06:32 <glguy> This is an english language channel only
08:06:48 <TheFlash> Me ajudar chama noreservado que falo doqalguem podeere preciso
08:06:55 <asridaran> lets say for example, the functor instance of list has fmap defined as: fmap g (x:xs) = g x : g x : fmap g xs
08:06:56 --- mode: ChanServ set +q *!*@132.255.94.2
08:07:08 --- mode: ChanServ set +o glguy
08:07:24 <asridaran> here still the functor remains the same. i.e list
08:07:36 <asridaran> so the context is the same . isnt it?
08:07:47 <c_wraith> asridaran: they mean you can't define it as fmap _ _ = []
08:08:03 <antoine1> Thanks all, I’ll try that plugin
08:08:29 <c_wraith> asridaran: and you can't define it as fmap f (x:xs) = f x : f x: : fmap f xs ; fmap _ [] = []
08:08:39 <asridaran> well yeah. you are correct. but then what does it means to say the functor context is preserved? does that mean the number of elements in the list in this case is same?
08:08:47 --- mode: glguy set -qo *!*@132.255.94.2 glguy
08:08:51 <c_wraith> asridaran: in the case of list, that's what it means.
08:09:09 <c_wraith> asridaran: it's kind of vague terminology.  The precise specification is only what the laws actually saw
08:09:15 <asridaran> ok. then can u generalize it in any context as to what it means to preserve the context
08:09:25 <c_wraith> asridaran: every "explanation" is fuzzy and non-precise
08:10:14 <asridaran> ya. i am not able to wrap my head around a defined statement that holds good for all functors. i am basically having a question as to why specific laws have been chosen
08:10:30 <asridaran> for any category in general
08:10:31 <sproingie> fmap is that which replicates the arrows from the source to the target category of the functor (probably not using proper terms there).  so it's just part of the definition of functors that those arrows remain within the same category
08:11:12 <nshepperd_> the context is the part that distinguishes a value m from "pure x" for some x
08:11:47 <nshepperd_> Or something :p
08:12:11 <asridaran> let me ask my qn in another way. why id & composition has been chosen as laws for functor and not associativity or commutativity
08:13:38 <sproingie> identity and composition are just the basic axioms.  associativity arises naturally from the composition law
08:13:58 <lyxia> what does commutativity mean for a functor?
08:14:23 <nshepperd_> Identity and composition are the same laws that functors have in category theory
08:16:21 <lyxia> asridaran: I would say it the other way around. Things that satisfy identity and composition laws happen to be common and useful, thus we gave them an name arbitrarily, "functor".
08:17:11 <asridaran> @lyxia: hmmm this makes it more interesting because all the explanations I have read so far talks about the category and then the law
08:17:11 <lambdabot> Unknown command, try @list
08:17:14 <c_wraith> asridaran: good abstractions are chosen based on usefulness and broad applicability. the concept of a functor from category theory has withstood the test of time to stand up as a good abstraction.  The Functor class is one translation of that concept into programming.
08:17:56 <asridaran> ya then my question is why those laws are used for the functor in category theory? may be i need to read category theory to find it out
08:17:56 <c_wraith> asridaran: One thing Haskell users have a tendency to do is raid the history of math looking for good abstractions and seeing how well they suit programming.
08:18:10 <asridaran> ya. agree that
08:18:20 <sproingie> axioms are chosen pretty much arbitrarily
08:18:25 <c_wraith> asridaran: it turns out a lot of category theory suits programming very well.  the Functor class is one thing pulled from there.
08:18:58 <asridaran> @sproingie: I refuse to believe that. There must be some proof as to why those axioms are chosen
08:18:58 <lambdabot> Unknown command, try @list
08:19:10 <sproingie> asridaran: if there were a proof they wouldn't be axioms
08:19:12 <c_wraith> (Math is a particularly juicy target to raid for abstractions, as math is basically the study of abstractions.)
08:19:25 <sproingie> and CT is about as abstract as it gets
08:20:10 <sproingie> justification of axioms comes from the consistency of the logic that arises.  any further than that and you're talking epistemology.
08:20:18 <asridaran> sorry. i just googled the meaning for axioms and i get your point. but i am trying to understand the reasoning behind why those axioms are chosen for each categories
08:20:19 <nshepperd_> Well, they are kind of the obvious axioms for a category homomorphism
08:21:39 <mnoonan> asridaran: it usually helps to find some conrete motivating examples. usually the axioms come from generalizing several concrete cases.
08:21:51 <c_wraith> asridaran: you seem to have mistaken math for a science searching for reasons.  Math is an art searching for beauty.  Ideas in math succeed if other mathematicians like them.
08:22:30 <c_wraith> oh, he vanished.
08:23:09 <quchen> Math is like art? Like, with a purpose?
08:23:09 <asridaran> sorry got disconnected
08:23:13 <quchen> ;-)
08:23:15 <asridaran> did i miss anything?
08:24:23 <nshepperd_> Math is like art but with the power to destroy planets
08:24:27 <dolio> The functor axioms are chosen so that functors preserve operations on categories.
08:25:05 <dolio> Because they are supposed to be structure preserving maps between categories.
08:25:41 <aijony> nshepperd_: I thought we agreed math wasn't science?
08:26:08 <quchen> Science also doesn’t allow you to destroy planets. That’s engineering.
08:26:37 <quchen> See http://static.neatorama.com/images/2008-12/mad-scientist-mad-engineers.jpg
08:27:21 <nshepperd_> Heh
08:27:52 <aijony> Can we program the mad death ray in mad Haskell?  
08:28:02 <sproingie> madskell
08:28:20 <nshepperd_> {-# language MadHaskell #-}
08:29:34 <quchen> inlinePerformIO!
08:32:00 <sproingie> unsafeOverturnAxiom
08:37:20 <Hafydd> unsafeDestroyEarth
08:40:38 <Unode> unsafeIWin
08:49:16 <mniip_> Hafydd, nonono
08:49:20 <mniip_> unsafeLaunchMissiles
08:49:38 <Hafydd> unsafeUnLaunchMissiles
08:49:59 <mniip_> do { undo; }
09:08:11 <davr0s> can't find anything in hoogle, does haskell have something like this ,  https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or      unwrap_or  (Just x) _ = x ;  unwrap_or Nothing y = y
09:10:00 <dolio> fromMaybe
09:10:16 <brynedwardz> :t fromMaybe
09:10:18 <lambdabot> a -> Maybe a -> a
09:10:28 <davr0s> i guess for piping the order would be batter the other way round compared to rust
09:11:04 <davr0s> ah, as it is in fromMaybe , fair enough
09:14:12 <Unicorn_Princess> what's that function that comes in handy when working with 2-tuples, that's (a -> b) -> (a, c) -> (b, c) or something similar? hoogle gives me mapFst, but I vaguely recall something else. tho I could be mistaken
09:14:29 <lyxia> Unicorn_Princess: Data.Bifunctor
09:15:16 <kadoban> Yeah, that's "first", though the one lambdabot has is the one from Arrow. Which will also work, but usually less general in the way people want.
09:15:21 <lyxia> :t Data.Bifunctor.first
09:15:22 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
09:16:56 <Unicorn_Princess> huh. I'm not having any luck finding that with hoogle
09:19:19 <Unicorn_Princess> ah, got it
09:19:36 <Unicorn_Princess> +bifunctors did it, not +Data.Bifunctor
09:20:06 <dolio> hoogle must be really out of date.
09:20:41 <lyxia> http://hoogle.haskell.org/?hoogle=first has it
09:22:17 <Unicorn_Princess> hah, but https://www.haskell.org/hoogle/?hoogle=first doesn't. well, not the bifunctor one
09:22:30 <Unicorn_Princess> so uh, which hoogle -should- I use?
09:22:48 <dolio> Is hoogle.haskell.org running a separate service from haskell.org/hoogle?
09:23:44 <funrep> is there any nice way to map backwards in a list and using the next item (ie next in left direction) when calculating the result? scanr1 is *almost* what i want, but i need to somehow insert the "next" item to the last item (ie head of the list)
09:25:19 <funrep> ie: `foo (\x y -> x + y) 0 [1,2,1] = [1,3,2]
09:25:27 <dolio> Oh, hoogle.haskell.org says it's an alpha.
09:26:42 <kadoban> funrep: That was not a very good example :-/
09:26:44 <Unicorn_Princess> funrep: like use adjacent elements of the list in your function? dunno about nice, but you can zip the list with an offset copy of itself
09:26:55 <lyxia> Unicorn_Princess: At the moment there isn't one search engine that subsumes all the other
09:30:07 <funrep> kadoban: sorry
09:30:18 <funrep> Unicorn_Princess: that would work
09:30:38 <funrep> donno if it would be nicer than manual recursion but at least less code
09:32:58 <mclark1129_> So when you're talking about Monad stacks, and you say "IO is always at the bottom of the stack" is that IO (m a) or m (IO a)?
09:33:36 <lyxia> It's monad transformer stacks
09:33:48 <lyxia> t1 (t2 (t3 IO)) a
09:34:29 <mclark1129_> lyxia: But I can roughly equate a transformer stack to "monad wrapped in monad wrapped in monad" right?
09:34:56 <lyxia> For example    State s IO a   is neither of the form   IO (m a)   nor    m (IO a)
09:35:17 <sproingie> "State s" is of the form "m"
09:35:24 <lyxia> StateT
09:35:27 <sproingie> monads only ever take one type argument
09:36:02 <sproingie> another example, Either isn't a monad, but "Either Foo" is
09:36:03 <lyxia> (ReaderT r IO a) is (r -> IO a)   (so, m (IO a))     but     (MaybeT IO a) is (IO (Maybe a))
09:36:37 <lyxia> sproingie: sure, but that's not what I meant, I meant StateT because I'm talking about transformers
09:36:56 <sproingie> ah
09:37:09 <mclark1129_> lyxia: So it depends on the implementation of each transformer?
09:37:17 <lyxia> mclark1129_: yes
09:37:28 <mclark1129_> One thing that keeps being repeated is "IO is always at the bottom of the stack"
09:37:39 <mclark1129_> while i'm trying to grasp transformers
09:38:00 <lyxia> t1 (t2 (t3 IO)) a    <- this is the shape of a "stack"
09:38:08 <sproingie> these days you don't need to care where IO is in the stack, you just use liftIO
09:38:30 <mclark1129_> sproingie: Fair enough, I'm just more trying to understand it at a conceptual level
09:38:54 <sproingie> sure.  knowing that also helps in deciphering type errors.
09:41:01 <mclark1129_> :t MaybeT IO
09:41:02 <lambdabot> error:
09:41:02 <lambdabot>     • Data constructor not in scope: MaybeT :: t0 -> t
09:41:02 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
09:41:08 <mclark1129_> :t MaybeT.IO
09:41:10 <lambdabot> error:
09:41:10 <lambdabot>     Not in scope: data constructor ‘MaybeT.IO’
09:41:10 <lambdabot>     No module named ‘MaybeT’ is imported.
09:41:46 <mclark1129_> Note to self: Just run your tests in your local GHCI so no one can see how little you really get at this point :)
09:44:30 <max3> so how do i figure out why i'm getting ExitFailure (-11)
09:45:34 <sproingie> what's giving you that error?
09:45:52 <max3> data-dword i think
09:46:25 <max3> yes data-dword
09:46:37 <max3> data-dword-0.3.1.1
09:46:54 <sproingie> try the -v flag to whatever you're building with (cabal, stack)
09:47:16 <sproingie> possibly even need -v2 or -v3
09:48:01 <max3> linker fails
09:48:07 <sproingie> exit code -11 is bad though, that usually means a segfault
09:48:20 <max3> gcc fails
09:49:41 <sproingie> what ghc version?  could be generating bad object files.
09:50:22 <max3> Glasgow Haskell Compiler, Version 7.10.3, stage 2 booted by GHC version 7.10.2
09:50:29 <max3> distributed with haskell platform on my distro
09:50:39 <max3> ghc-7.10.3-be5219aceb0976c913043e27d1693295
09:51:50 <sproingie> it's partly gcc's fault, might ultimately be ghc's.  not sure what to do with the platform tho.
09:52:03 <max3> this is crazy painful
09:52:14 <max3> i don't think i've ever had a smooth cabal install experience
09:52:27 <sproingie> my golden hammer when big distributions like this fail is to use stack
09:55:41 <sproingie> stack update && stack setup --install-ghc
09:55:48 <max3> i can't use stack
09:55:57 <sproingie> it's part of the haskell platform
09:56:02 <max3> yes i realize that
09:56:08 <max3> but i can't use it
09:56:09 <sproingie> well your platform is broken
09:56:13 <sproingie> so you can't really use that either
09:56:13 <max3> i agree
09:57:05 <MarcelineVQ> is  your exitfailure is at runtime?
09:57:27 <max3> compile
09:57:53 <sproingie> i would at least use stack and the resolver for 7.10 to determine whether it's related to the ghc version or not
09:58:03 <max3> i have a stack version working
09:58:06 <max3> production uses cabal
09:58:16 <max3> and i'm not going to migrate prod right now
09:58:25 <max3> i'm just trying to reproduce prod so i can develop
10:00:06 <freeside> just give up and develop on production! all the best startups are doing it.
10:00:27 <cocreature> note that during compilation you might run Haskell code via Setup.hs and TH so the segfault might not be in the compiler itself
10:00:32 <freeside> call it "zero-lag continuous integration"
10:00:43 <max3> freeside, this is exactly what i've been doing
10:01:18 <sproingie> are you using a cabal sandbox?
10:01:31 <max3> no
10:01:52 <sproingie> then your configuration depends on the entire history of your using the platform
10:01:58 <max3> yes i realize that
10:02:26 <sproingie> try building it with a sandbox.  might need a fresh install, not sure what cabal sandbox does for existing libs
10:02:49 <freeside> i am a big fan of nix, you feel like a born-again sysadmin
10:03:27 <sproingie> nix seems to be like stack writ large to the whole OS
10:03:47 <sm> I wish I could just use ctags in IDEA, but can't find a plugin for it. Anybody know of one ?
10:03:53 <sproingie> unfortunately it's not stable on osx and a nonstarter on windows
10:04:50 <sproingie> IDEA does its own pretty aggressive indexing, tends to blow ctags out of the water
10:05:19 <sproingie> just double-tap shift for a free-form search
10:06:47 <freeside> i've been pretty satisfied with nix on osx, i managed to get a whole ghc 7.4.2 system running and thus recover from years of bitrot
10:07:53 <max3> sproingie, if jetbrains had a haskell ide
10:07:56 <max3> *if only
10:08:18 <sproingie> they have a decent plugin
10:08:26 <max3> which one?
10:08:34 <sproingie> just search the plugins for haskell
10:08:40 <sproingie> there's an intero-based one
10:08:46 <max3> yes there are several. i could never figure out which one actually worked
10:09:15 <sproingie> couldn't tell you there, last i did haskell in intellij there were few choices and none of them were good
10:09:28 <sproingie> i hear tell the intero one is not bad
10:09:28 <max3> "they have a decent plugin" ?
10:09:57 <sproingie> intero is of course stack-based
10:10:38 <sproingie> how about that, nix installed without incident on my box
10:13:48 <freeside> yay
10:15:10 <mniip_> hmm, where's our resident mathematician Cale ...
10:16:26 <Cale> mniip_: hi, I'm in a meeting atm -- be done soon
10:18:48 <Gurkenglas> What lens oneliner turns [1,2,3] into [[2,2,3],[1,3,3],[1,2,4]]?
10:19:10 <mniip_> const  [[2,2,3],[1,3,3],[1,2,4]]
10:19:17 <MarcelineVQ> oh you :>
10:19:42 <Gurkenglas> What lens oneliner would I be probable to see given the above question?
10:19:50 <Gurkenglas> *"to want to see" dammit
10:20:44 <mniip_> one sec, I saw something just like that the other day
10:22:49 <NemesisD> looking for some design advice. i've got a very simple linear series of steps, denoated by data Step = One | Two | ..., i'm looking to write a little DSL that looks like step One doStep1; step Two doStep2, when interpreted i need to be able to see the next step if there is one
10:23:51 <NemesisD> ultimately, this DSL allows 2 things: to be able to "fast forward" to a certain step based on some external condition and to update some state in-between steps. is this a sensible use case for a free monad?
10:24:19 <NemesisD> is there a better pattern to use than a free monad?
10:26:32 <mniip_> Gurkenglas, something related to holesOf or contextsOf
10:26:36 <cocreature> NemesisD: a free monad requires a functor, what would your functor be in this case?
10:27:45 <Gurkenglas> :t map (Control.Comonad.Representable.Store.peeks (+1)) . holesOf traverse $ [1,2,3] -- there we go
10:27:47 <lambdabot> Num s => [[s]]
10:28:17 <cocreature> :t holesOf
10:28:21 <lambdabot> Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Control.Lens.Internal.Context.Pretext p a a t]
10:28:29 <cocreature> I guess I better read the docs oO
10:29:23 <MitchellSalad> operational doesnt!
10:29:23 <MitchellSalad> nor freer
10:29:23 <MitchellSalad> Gurkenglas: Control.Lens.Plated
10:30:05 <Cale> mniip_: hello
10:30:42 <Gurkenglas> MitchellSalad, I am honored that you think I could come up with that line within 73 seconds of first hearing of Control.Lens.Plated :P
10:30:52 <mniip_> Gurkenglas, map (Control.Comonad.Representable.Store.peeks (+1)) . holesOf each
10:30:55 <mniip_> or something like that
10:31:01 <NemesisD> cocreature, MitchellSalad i'm not sure. thinking about it, i really don't need or want the full power of binding results of previous computations in future computations. the only "method" of this dsl is step and its type is effectively f ()
10:31:10 <mniip_> oh
10:31:11 <mniip_> huh
10:31:58 <docmoxie> anybody here use Haskero? I've followed the installation instructions to the letter, but I'm getting all kinds of "Failed to load interface" and "Couldn't guess that module name. Does it exist?" errors. The project builds just fine on the command line...
10:32:03 <mniip_> Cale, I could get any answer from ##math, question is about the foundations of category theory
10:32:19 <NemesisD> i think i want a data structure that looks like data Steps = Step StepNumber (IO ()) Steps | Done
10:32:52 <mniip_> Cale, has modern CT decided on how categories are implemented in mathematics?
10:33:04 <Cale> mniip_: What do you mean by that?
10:33:21 <mniip_> formal definition of a category
10:33:23 <NemesisD> i guess i'm really just looking for a pretty way to assemble that data structure, perhaps this is a profane use of free monads
10:33:49 <cocreature> NemesisD: if you don’t need the full power of a free monad I would just use whatever custom structure fits what you need
10:33:50 <Cale> mniip_: There are lots of ways.
10:34:12 <mniip_> Cale, filter out those that don't support Set
10:34:22 <mniip_> and those that don't support Cat
10:34:51 <NemesisD> cocreature: yeah, that sounds about right, but for the sake of "readability" a linear sequence of actions is a lot nicer to look at than Steps One one (Steps Two two Done)
10:34:53 <Cale> mniip_: Set and Cat being what exactly? :)
10:35:18 <mniip_> category of all sets. Category of all locally small cagtegories
10:36:10 <mniip_> it seems that much of the math folk defines categories in terms of classes
10:36:19 <Cale> Sure, you can do that
10:36:22 <cocreature> NemesisD: you might be able to just operate in some kind of state monad to get new step numbers automatically. do you have some examples of the kind of programs that you’d like to write?
10:36:27 <mniip_> I asumme, von-Nouman-Bernays-Godel classes
10:37:04 <Cale> Yeah, which are pretty much just predicates on sets
10:37:30 <NemesisD> cocreature: this monad basically does wiring. your DSL would be step One oneImpl; step Two twoImpl;, when evaluated, elsewhere I save what step we're on. if I have to resume, I could traverse the structure to the last step we were on
10:37:52 <mniip_> I initially had an idea of implementing CT as its very own FOL theory
10:38:02 <Cale> mniip_: Nobody ever bothers to actually formalise anything in ZFC and FOL though, so it's a bit of a moot point how the details actually occur.
10:38:06 <Cale> Oh, there's that too.
10:38:14 <mniip_> where category, object, morphism are just sorts in the signature
10:38:19 <NemesisD> cocreature: also, when going from One to Two, it will save its state and use its knowledge of the step number its on when doing so
10:38:40 <Cale> There's a first order theory of categories, where you have a ternary relation symbol for f . g = h
10:38:58 <mniip_> Cale, do you think it's a good idea?
10:39:19 <Cale> It's basically as bad as ZFC is.
10:39:35 <mniip_> No, I mean, a field of mathematics that explains mind-boggling concepts,
10:39:36 <Cale> If not somewhat worse
10:39:38 <cocreature> NemesisD: so you just have a list of steps and they include their position in the list? seems like you can just have the user write [Step] and then zip that with [0..] and you have all you want
10:39:40 <mniip_> yet hand-waves the basic definitions
10:39:55 <edwardk> > map (Control.Comonad.Representable.Store.peeks (+1)) . holesOf traverse $ [1,2,3]
10:39:57 <lambdabot>  error:
10:39:57 <lambdabot>      Not in scope: ‘Control.Comonad.Representable.Store.peeks’
10:39:57 <lambdabot>      No module named ‘Control.Comonad.Representable.Store’ is imported.
10:40:01 <cocreature> NemesisD: if you want do notation instead of lists you could use some kind of writer monad
10:40:06 <Cale> mniip_: It's not really a big deal -- when you actually go to formalise things, it doesn't ever turn out to be much of a problem.
10:40:08 <mniip_> edwardk, I couldn't import it safely
10:40:13 <edwardk> ah
10:40:25 <mniip_> Cale, well it depends
10:40:29 <mniip_> what if we want CAT
10:40:33 <mniip_> the category of all categories
10:40:40 <NemesisD> cocreature: approximately, though i'm not actually using step numbers like One | Two | Three, they are more like Setup | DoSomeThing | DoAnotherThing | Cleanup
10:40:42 <edwardk> [[2,2,3],[1,3,3],[1,2,4]]
10:40:50 <Cale> mniip_: The smart way to do this stuff is with universe levels
10:40:51 <edwardk> ok, so updating each hole in turn. that makes sense.
10:40:58 <Cale> mniip_: If you care about such things
10:41:25 <Cale> mniip_: CAT won't tend to be an object in itself.
10:41:44 <Cale> mniip_: So you might want yet another level of categories, in which CAT is an object, right?
10:41:49 <mniip_> nah
10:41:54 <Cale> Why not? :)
10:41:57 <mniip_> I'm talking about a selfcontaining CAT
10:42:13 <dolio> Do you want a set of all sets, too?
10:42:13 <Cale> Oh, well then, you'll likely end up with inconsistency.
10:42:14 <mniip_> the problem with CAT is that when we have a category, intuitively, removing some objects and relevant morphisms from a category, forms a yet another category
10:42:23 <mniip_> and thus you have russell's paradox
10:42:34 <edwardk> mniip_: cat is the category of small categories. cat isn't small
10:42:44 <mniip_> edwardk, Cat is. I'm talking about CAT
10:42:50 <Cale> mniip_: He wanted a category of all large categories
10:42:53 <Cale> oops
10:42:55 <Cale> edwardk: *
10:42:56 <edwardk> ah
10:43:04 <mniip_> Muller (2001) calls it CAT at least
10:43:08 <NemesisD> cocreature: so maybe like newtype StatesM a = StatesM (Writer States a), then i add step :: StepNumber -> StatesM (), then runStatesM :: StatesM a -> IO a just extracts the States from writer then interprets it?
10:43:10 <edwardk> then you need _C_A_T_ to contain CAT :)
10:43:19 <edwardk> and you can try to shout louder than that to contain the next one
10:43:21 <dolio> You might be able to do it some other way.
10:43:30 <dolio> Does new foundations have a set of all sets?
10:43:54 <eitan> no
10:43:54 <mniip_> one interesting thing I came up with,
10:43:59 <cocreature> NemesisD: yeah
10:44:10 <mniip_> is a FOL theory where you have comprehension but not \in
10:44:25 <mniip_> where 'forall (X in C)' is a quantifier but (X in C) is not a predicate
10:44:39 <mniip_> or, well, not a universally available predicate
10:44:51 <mniip_> that should disallow constructing russell's paradox
10:44:53 <dolio> I suppose it's kind of meaningless to talk about a 'set of all sets' when you're not allowed to talk about the set being in itself.
10:45:35 <mniip_> in category theory we often don't care about specific objects of categories but merely about their proprties
10:46:03 <Cale> mniip_: In a stratified type theory, all these issues become easy, because you just define categories in the natural way, parameterised by a universe level, and then you'll easily have a Cat 1 of all Cat 0's, and so on. They pull off more or less the same trick, but with more awkwardness, inside ZFC using Grothendieck universes
10:46:03 <mniip_> so how do we expect 'C \in Ob(C)' to make sense for arbitrary C where object equality might not even be defined
10:46:08 <NemesisD> cocreature: i'll give it a try, thanks! i seem to frequently come across these needs for wanting a very basic DSL and to take care of the plumbing in one place, so maybe i'll be able to carry this idea with me if it works out
10:46:37 <Cale> mniip_: Well, I say "inside ZFC", but really I mean "in an extension of ZFC"
10:46:38 <mniip_> Cale, still you can't construct Cat_omega
10:46:55 <Cale> mniip_: Depends on what universes you assume
10:46:57 <mniip_> or, well, perhaps you can, but there will always be a higher ordinal
10:48:23 <eitan> behold the definition of a 4-category and tremble: http://math.ucr.edu/home/baez/trimble/tetracategories.html
10:49:41 <mniip_> ohhhh
10:49:57 <mniip_> we need a system-F-sorted first order logic
10:50:10 <sproingie> eitan: i'd love to see the diagram for it
10:50:19 <mniip_> where some combinators are "too parameteric" to be used
10:50:28 <sproingie> oh there are some sketched ones
10:50:28 <Cale> mniip_: First order logic actually sucks a whole lot for actually formalising much mathematics.
10:50:52 <Cale> mniip_: It's not even so much that ZFC is bad for explicit formalisation, but that FOL is unusable.
10:51:05 <sproingie> i've had this odd idea of doing category diagrams as art.  i'm thinking embroidery.
10:51:07 <eitan> those are commuting diagrams for 4-dimensional associahedra laws
10:51:20 * mniip_ . o O ( dependent sorts )
10:51:29 <geekosaur> I feel like Kurt Gödel is laughing at your foolish attempts at consistency >.>
10:52:19 <AX3L> Why does building libraries suck so much on haskell? for example, when xss-sanitize is pulled as a dependency it doesn't build but when downloaded and built separately it builds fine. Now, I Trifecta doesn't build with the helpful error message "ExitFailure -11". Building with verbose output does not tell me anything more either. Even building C code from twenty years ago is easier. 
10:52:29 <mniip_> geekosaur, we've already figured that out with zeroth order logic
10:52:33 <Cale> AX3L: what?
10:52:44 <sproingie> there goes that segfault error again
10:53:00 <sproingie> my pat answer: the platform is broken, use stack
10:53:24 <mniip_> geekosaur, we're looking at what things follow from what, not what things are universally true
10:53:52 <sproingie> AX3L: --verbose=3 should get you closer to seeing what created the segfault.  last time it was the linker.
10:54:01 <mniip_> brb
10:54:14 <AX3L> Thanks for the tip, I'll try that. 
10:54:21 <sproingie> seeing is one thing, fixing is another.  perusing SO, some have reported success by just reinstalling the haskell platform
10:54:38 <sproingie> the moral of the story is the bit rot that accumulates from using global cabal-install eventually leads to total breakage
10:54:53 <Cale> AX3L: What are you trying to build? If you want, I can try myself and see if I run into the same issue
10:55:09 <sm> AX3L: -11 probably means you ran out of memory. Software often fails to report that condition with a clear message, unfortunately
10:55:47 <sm> watch it with top to see
10:55:52 <sproingie> if it faulted in gcc, that's usually good at checking for OOM at least
10:55:56 <AX3L> I have this problem even in a cabal sandbox. I was trying to build Idris, which requires trifecta, now I am trying to build trifecta on its own, trying to see if that makes it work better.
10:56:20 <AX3L> I have 16GB of RAM, I'd be surprised if it ran out of memory.
10:56:35 <sm> so would I then, but no harm in checking
10:56:36 <geekosaur> binutils ld is a horrid memory hog
10:56:38 <sproingie> sm: i was thinking OOM too, but whenever people have run into that, they do fine with a fresh install
10:56:48 <AX3L> https://github.com/ekmett/trifecta
10:56:55 <Cale> AX3L: which Idris?
10:57:07 <Cale> AX3L: Just the one on hackage?
10:57:38 <AX3L> Cale: https://github.com/idris-lang/Idris-dev
10:59:27 <Cale> AX3L: Okay, building. I'll let you know how it goes.
10:59:36 <AX3L> Thanks for the help.
11:01:37 <Cale> AX3L: (For the record, what I'm doing to get all the deps is just using reflex-platform's work-on script to drop into a shell with ghc and the appropriate packages, and I'm just using cabal configure && cabal build, because the machine I'm on doesn't have much Haskell stuff installed globally)
11:03:45 <Cale> linking...
11:04:32 <Cale> and now it's building various other executables, having finished building the idris compiler itself
11:04:46 <ReinH> AX3L: what platform?
11:05:22 <Cale> and now idris is building its standard libraries
11:06:26 <AX3L> Fedora 25
11:06:59 <Cale> AX3L: So if you want to try what I'm doing, grab https://github.com/reflex-frp/reflex-platform (develop), and then from the directory you clone that into, do  ./work-on ghc /path/to/Idris-dev
11:07:28 <Cale> and it'll download lots of stuff and drop you into a shell with everything needed to build Idris-dev
11:08:46 <Cale> okay, my build finished successfully
11:10:33 <mniip-> Cale, what do you propose instead of FOL?
11:11:10 <Cale> mniip-: Most type theories are way nicer if you actually want to formalise a nontrivial amount of stuff for real.
11:11:39 <Cale> e.g. use Coq or Agda or something like that
11:11:43 <mniip-> Er?
11:12:21 <ReinH> mniip-: I'll vote for HoTT if you're on the market for mathematical foundations.
11:12:43 <Cale> Yeah, HoTT is pretty nice, and it can live inside Coq and Agda fairly comfortably :)
11:12:54 <mniip-> Ok, I have much to learn it seems
11:12:57 <ReinH> I've done a bit with Agda-HoTT. It's nice.
11:13:12 <sproingie> mniip-: i get that feeling every time i join this channel :)
11:13:20 <mniip-> I've never questioned the foundations of TT
11:13:33 <ReinH> The HoTT book is very accessible.
11:13:42 <sproingie> could someone expand the acronym?
11:13:49 <Cale> Homotopy Type Theory
11:13:53 <mniip-> Homotopt Type Theory
11:14:03 <ReinH> Hot To Trot.
11:14:24 <ReinH> Hmm I may be incorrect.
11:14:45 <mniip-> Anyway, do typesystems exist on the same level as FOL?
11:14:49 <sproingie> wow the book isn't even exhorbitantly expensive
11:14:56 <ReinH> sproingie: It's free.
11:14:58 <Cale> mniip-: Yeah, they're basically logics
11:15:18 <mniip-> That explains
11:15:54 <sproingie> oh just saw.  one more for my ~/Documents/CS folder
11:16:05 <mniip-> How does c-h iso fit into this picture?
11:16:16 <Cale> mniip-: The difference between a type theory and a pure logic is that you have terms which encode information about the proof that was used to conclude something
11:17:10 <ReinH> mniip-: The... usual way? Types are propositions, terms are proofs.
11:18:10 <Cale> Universally quantified statements turn into Pi types, existentially quantified statements turn into sigma types
11:18:32 <heebo> hello does stack install make my locally compiled package libraries available to other projects?
11:19:44 <glguy> heebo: Packages built as part of the "resolver" are shared across uses of that resolver
11:19:45 <sproingie> heebo: they'll be "available" as in they'll be in the stack cache, but other projects won't see them unless they specify a dependency
11:19:46 <kadoban> heebo: Not typically. 'stack install' is for executables, which it builds and copies to ~/.local/bin/   If you want to use a library as a dependency in another thing, you specify it in the .cabal file in that other thing, and then if necessary (if it's not in the resolver) you also specify where to find it in the stack.yaml
11:20:06 <ReinH> So: yes, maybe, or no.
11:20:19 <ReinH> We've got you covered.
11:20:30 <heebo> sproingie:thanks thats what i want
11:22:48 <sproingie> if you have an extra-dep that's a git dependency, each project will stick a local copy in .stack-work, i think
11:23:20 <docmoxie> for anyone who's curious (and future Googlers) I solved my issue with Haskero (well, Intero really). You have to set your `intero-targets` to cover your test-suite as well. By default, it's only set to cover the lib.
11:23:26 <max3> okay still getting segfault after trying some stuff
11:23:32 <max3> anyone see in all of thise why that might be
11:23:33 <max3> https://pastebin.com/si5QwBgC
11:25:47 <mniip-> Cale, yes, but
11:25:59 <sproingie> wonder if the gold linker would help here
11:26:08 <mniip-> It's an iso between two logics then?
11:26:37 <ReinH> max3: Well, ghc segfaulted on 'data-dword-0.3.1.1 failed during the building phase. The exception was:'
11:26:42 <ReinH> Recommend trying to install it directly.
11:26:46 <max3> yes i know it's dword
11:26:53 <heebo> kadoban: ah yes im having issues still, the package i want to use isnt on stackage, so im building it myself, i downloaded and did a stack init and i can build locally, but i still need to make it available to my other project
11:27:06 <geekosaur> gcc running the linker, yes. would also suspect trying gld is a good idea
11:27:08 <geekosaur> er gold
11:27:10 <max3> ReinH, data-dword segfaults on its own
11:27:25 <ReinH> Well, at least that isolates the problem.
11:27:29 <max3> geekosaur, how do i make gcc use instead of ld
11:27:33 <max3> *use gold
11:27:39 <sproingie> it could be memory.  how much ram does your virtualbox have?
11:27:45 <kadoban> heebo: The typical way would be to move that one into a subdir of the thing you want to use it in, and then you specify it in the stack.yaml
11:28:00 <kadoban> You can also refer to it via git (on github or elsewhere) or a few other options.
11:28:00 <max3> sproingie, 8gb
11:28:45 <glguy> heebo: Is the package on Hackage?
11:28:48 <MarcelineVQ> heebo: https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
11:28:55 <heebo> kadoban:thanks
11:29:00 <sproingie> should be plenty.  dunno, ghc bug isn't out of the question.
11:29:09 <max3> using gold doesn't help
11:29:18 <max3> (setting env LD=ld.gold
11:29:19 <max3> )
11:29:25 <sproingie> i think there's more to it
11:29:41 <max3> this is happening because i did a new cabal freeze
11:29:49 <max3> the old cabal lock file is giving me cabal hell issues
11:30:13 <sproingie> that's why i don't use cabal-install.  not that stack is good about cleaning up locks either.
11:35:38 <mniip-> HoTT it is then
11:35:56 <mniip-> Does HoTT require topoly knowledge
11:36:11 <mniip-> Topology
11:39:13 <sproingie> i'm following the book all right so far and i know zilch about topology
11:42:26 <max3> this doesn't make sense to me
11:42:26 <max3> https://pastebin.com/wKrZefCV
11:42:40 <max3> range-set-list requires semigroups < 0.19
11:43:11 <max3> the lock file sets semigroups ==0.18.1
11:43:55 <sproingie> which is < 0.19
11:44:12 <max3> yes and hence my confusion
11:44:26 <cocreature> something is forcing semigroups==0.18.3
11:45:07 <sproingie> exact dependency versions upstream are the root of suffering
11:45:20 <max3> it says range-set-list
11:45:28 <max3> is forcing
11:45:36 <max3> line 7
11:45:44 <AX3L> Cale, sm, sproingie: Thanks for helping me before, I had a meeting I completly forgot about and had to quick run off. I think it's working now
11:46:17 <sproingie> yay! :)
11:47:19 <max3> cocreature, the question is why range-set-list is forcing 0.18.3
11:47:44 <Cale> AX3L: nice -- did you use reflex-platform to build it?
11:49:31 <max3> is there a way to get stack to generate lock file?
11:52:04 <cocreature> max3: is that all the output you get from cabal?
11:52:35 <max3> basically https://pastebin.com/pZTid0KS
11:53:18 <cocreature> max3: are you building in a clean sandbox? if you’ve already installed range-set-list with a different version of semigroups that will probably result in this error
11:53:31 <max3> i'm not building in a sandbox
11:53:36 <max3> but i guess i should be
11:53:47 <cocreature> building without sandboxes leads to madness :)
11:53:56 <max3> yes but i live in sparta so
11:54:53 <max3> lol in the sandbox i get a different dependency issue
11:54:58 <max3> but i'm familiar with this one actually
12:08:02 <sproingie> come back with your build artifact or on it
12:18:55 <Atomic_e_knq> sup
12:19:06 <Gurkenglas> I wonder if https://codereview.stackexchange.com/a/166904/84131 can be done with a single use of holesOf
12:19:44 <Gurkenglas> The later holes would need to be applicable even after earlier ones have been peeked
12:26:19 <jared-w> haha. I'm reading the mailing list on why $ is right associative
12:26:27 <jared-w> like clockwork, 4 messages in, people start talking about :: vs :
12:27:31 <geekosaur> the reason is basically that it lets you do something like putStrLn $ complex expression without an extra set of parens
12:28:00 <jared-w> oh yeah, I'm aware. I just like to read the flames and comments by people on why such and such is a certain way
12:28:02 <geekosaur> or see how xmonad's layout specifications work: layoutModifier param param $ layoutModifier param $ list of layouts
12:29:07 <jared-w> If I'm reading this right, you can always replace a $ b $ --- $ n with a . b . --- $ n
12:30:45 <cocreature> personally I prefer (a . b . c) x over a . b . c $ x
12:32:10 <jared-w> That does look nicer to me. Especially since I'm used to thinking of $ as parens replacements and would intuitively think of a . b . c $ x as a . b . c (x)
12:32:11 <Gurkenglas> Can we get Control.Comonad.Representable.Store trusted by lambdabot? Control.Lens is trusted and provides holesOf which produces Pretexts that you need peek, pos, etc. to consume
12:32:45 <edwardk> oh boy another trust/safety hunt
12:32:53 <edwardk> i always love these
12:32:58 <Gurkenglas> jared, it is parens replacements, but both ways: a . b . c $ x -> (a . b . c) (x)
12:34:21 <Gurkenglas> Why do you need to explicitly trust libraries, when you could just add unsafe modules using letlpaste?
12:34:46 <jared-w> what's "trusting" anyway? Does that mean it's just included by default in lambdabot?
12:35:04 <jared-w> Gurkenglas: makes sense; somehow it never clicked that the parens went both ways.
12:35:05 <Gurkenglas> @let import Control.Comonad.Representable.Store
12:35:06 <lambdabot>  .L.hs:49:1: error:
12:35:06 <lambdabot>      Control.Comonad.Representable.Store: Can't be safely imported!
12:35:06 <lambdabot>      The module itself isn't safe.
12:35:26 <geekosaur> jared-w, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe_haskell.html
12:35:50 <edwardk> jared-w: lambdabot uses SafeHaskell to determine if its okay to import something
12:35:53 <geekosaur> specifically 'Trust and Safe Haskell Modes' within
12:35:57 <jared-w> ahh, so it is related to Safe Haskell
12:36:08 <edwardk> unfortunately the current design of safehaskell makes maintaining code in a safehaskell compliant manner almost impossible at scale
12:36:50 <edwardk> I have to magically guess how the cross product of every version of every dependency i have will deal with safety and if it _improves_ my users get warnings
12:36:57 <edwardk> (even for versions that aren't released yet)
12:37:30 <jared-w> That... sounds terrifying
12:37:46 <edwardk> i'm thinking i'm going to start turning on Trustworthy if any version of a dependency i use is flagged unsafe, and then disable the stupid warning.
12:38:05 <edwardk> (assuming of course that i only use safe parts of it)
12:38:29 <edwardk> jared-w: for a while there roughly 95% of my maintenance efforts went into fighting safehaskell
12:38:32 <edwardk> i stopped
12:39:16 <edwardk> the current situation with the warning is better in some ways than the _old_ way which was to build and then build haddocks and literally have to check the upper right hand corner of the haddock for a module to know if you screwed up
12:39:20 <edwardk> but only barely
12:39:40 <edwardk> it still requires you to know the cross product of your dependencies and if they improve to Safe from Unsafe then you get whacked
12:39:40 <jared-w> yeah that's just way too much time. I can't imagine sinking that much effort into doing that.
12:39:53 <edwardk> and things like using Coercible drag you _down_ to unsafe to get better semantics
12:40:00 <n_blownapart> hi with drop why would we need 'drop 9 "Curry is awesome" ' to have "awesome" returned? drop 8 returns the space: " awesome" .. I thought we began with 0, so drop 8 would be sufficient
12:40:11 <edwardk> so these safety levels flail around as folks optimize their code
12:40:24 <jared-w> :| that's even worse. Has there been any effort towards improving safe and making it actually usable at scale?
12:40:47 <edwardk> jared-w: the improvement we have was the reaction tot he last issue i filed on the topic
12:40:51 <Gurkenglas> n_blownapart, drop 0 should be id
12:40:51 <edwardk> i just stopped trying after that
12:41:06 <n_blownapart> sorry?
12:41:26 <edwardk> n_blownapart: drop n . drop m = drop (n + m) -- assuming n and m are positive. drop 0 is the identity function, it does nothing
12:41:30 <geekosaur> dropping 0 items does nothing
12:41:30 <edwardk> > drop 0 "hi"
12:41:32 <lambdabot>  "hi"
12:41:33 <max3> okay now i'm getting ExitFailure 1 in a sandbox on haskell-src-exts-1.17.1
12:41:43 <edwardk> er not positive, non-negative.
12:41:49 <geekosaur> you're fenceposting :)
12:42:05 <n_blownapart> but we're counting from 0 as the first char dropped, is what I meant Gurkenglas 
12:42:20 <geekosaur> again, fenceposting
12:42:29 <edwardk> we're dropping 0 characters. drop 1 drops the first char.
12:42:39 <jared-w> > drop 0 [1..10] -- I drop zero characters, not the 0th elment of the array
12:42:40 <geekosaur> it doesn't matter whether you start from 0, 1, or -36. 'drop 1' drops one item
12:42:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:42:42 <edwardk> its the # of characters to drop
12:43:18 <Gurkenglas> You thought we'd count "1 characters dropped, 2 characters dropped, etc." but actually we start at 0: "0 characters dropped, 1 characters dropped, 2 characters dropped, etc."
12:43:43 <sproingie> > drop -1 "hi"
12:43:45 <lambdabot>  error:
12:43:45 <lambdabot>      • No instance for (Typeable a0)
12:43:45 <lambdabot>          arising from a use of ‘show_M127272854145975360032394’
12:43:46 <n_blownapart> oh ok so we're not counting the zero spot . thanks, is that good design ?
12:43:50 <edwardk> take n xs ++ drop n xs = xs -- we want to have it produce the input list, take 0 xs = [] -- takes zero elements
12:43:54 <sproingie> damn negative literals
12:43:55 <edwardk> n_blownapart: yes
12:44:03 <jared-w> n_blownapart: you're thinking of indices in an array
12:44:15 <jared-w> that's different than the semantics of dropping elements
12:44:19 <geekosaur> ^
12:44:28 <MP2E> .. this isn't array indexes, why would drop 0 drop an element? :)  As an argument for drop 0 doing nothing, look at the way drop is implemented
12:44:31 <geekosaur> it's not an index, it is a count
12:45:02 <geekosaur> if we had a version that worked by index, it'd be called dropTo or something
12:45:18 <Gurkenglas> "<n_blownapart> oh ok so we're not counting the zero spot . thanks, is that good design ?" <- We are counting the 0, we're just counting it on both sides
12:45:22 <edwardk> take 0 xs = []; take n [] = []; take n (x:xs) = x : take (n-1) xs -- is the obvious inductive definition. drop is 'rest'
12:46:03 <edwardk> drop 0 xs = xs; drop n [] = []; drop n (x:xs) = drop (n-1) xs
12:46:34 <edwardk> er drop is the rest
12:46:49 <n_blownapart> I've been working on fibonacci numbers lately, so ....
12:46:51 <edwardk> the two of those concatenate to get the original, and it makes sense to talk about taking or dropping 0 things
12:47:11 <sproingie> turns out zero is pretty useful :)
12:47:41 <edwardk> anyways, having a 'trivial'
12:47:48 <edwardk>  base case here is important for many uses
12:47:59 <n_blownapart> yes I see. I'm trying to remember if 'pop' in ruby counts the 0 as the first element
12:48:36 <n_blownapart> thanks !
12:49:03 <jared-w> Don't most languages just say stack.pop() rather than .pop(index)?
12:49:07 <edwardk> well, here it is more like popping n times, taking the remainder. when n is zero you pop zero times
12:50:17 <n_blownapart> sorry what did you mean by drop is 'rest' edwardk 
12:50:25 <jared-w> heh, the array.drop(n) in Ruby works the same way as the haskell one
12:50:34 <edwardk> drop is the rest of the list after taking the first n elements
12:50:53 <edwardk> > (take 4 "hello", drop 4 "hello")
12:50:55 <lambdabot>  ("hell","o")
12:51:05 <edwardk> > take 4 "hello" ++ drop 4 "hello"
12:51:07 <lambdabot>  "hello"
12:51:11 <jared-w> So if you have a list [1..5] and you `drop 2` you're left with the "xs" (rest) of the list
12:51:33 <jared-w> > (drop 1 "hello") == (tail "hello")
12:51:35 <lambdabot>  True
12:51:43 <edwardk> jared-w: drop 1 is a slightly more defined tail
12:51:47 <edwardk> > tail ""
12:51:49 <lambdabot>  "*Exception: Prelude.tail: empty list
12:51:50 <edwardk> > drop 1 ""
12:51:52 <lambdabot>  ""
12:51:53 <n_blownapart> ok thanks. like I said I have been doing various fibonacci exercises
12:52:09 <glguy> How many fibonacci exercises are there?
12:52:23 <jared-w> edwardk: right, definitely didn't mean to say they were /exactly/ the same, but they share a very similar concept for sure
12:52:34 <edwardk> glguy: the number of them grows rapidly, like the number of rabbits...
12:52:42 <n_blownapart> glguy, one's with lame's theorem and binet's
12:52:56 <n_blownapart> in SCHEME har har
12:53:21 <jared-w> ooh, using ; for list cons instead of : or ::. Now that's guaranteed to ignite tons of salt and flaming
12:53:40 <sproingie> ocaml does that
12:53:51 <edwardk> n_blownapart: a couple of fun fibonacci articles i wrote a ways back:
12:53:53 <edwardk> https://www.schoolofhaskell.com/user/edwardk/fibonacci/leonardo
12:54:01 <edwardk> https://www.schoolofhaskell.com/user/edwardk/fibonacci/search
12:54:04 <jared-w> Pretty sure ocaml uses :: for lists and : for types and doesn't use semicolons for lists at all
12:54:20 <n_blownapart> edwardk, Cool! I hope I can work them out
12:54:22 <ongy> edwardk fibonacci? Does it have funny types like s t a b?
12:54:22 <edwardk> n_blownapart: while it is on your mind
12:55:07 <edwardk> ongy: i stuck with a b c d rather than s t a b in that =)
12:55:08 <Gurkenglas> Can you "traverse" a list of holes such that latter holes respect peeks done to earlier holes?
12:56:23 <edwardk> Gurkenglas: so that you only touch each hole once? removing it from a list or something?
12:56:40 <n_blownapart> if anyone wants to see this clusterf*ck from sicp https://ptpb.pw/iZk0
12:56:46 <Gurkenglas> Yep. Here's the code to replace https://codereview.stackexchange.com/a/166904/84131
12:56:47 <edwardk> Gurkenglas: the stuff dfeuer and others were doing for well-typed applicative sorting sort of fits that idea anyways
12:57:25 <Gurkenglas> apropos, why applicative sorting when partsOf traverse %~ sort exists?
12:57:25 <n_blownapart> that problem led me to give up sicp ^^
12:57:53 <edwardk> Gurkenglas: because they could guarantee that they didn't have to use anything partial in the middle
12:58:23 <edwardk> its more a thought exercise than a practical concern
12:58:25 <dfeuer> Gurkenglas: it was mostly an exercise in seeing how far the types could go.
12:58:38 <edwardk> i was rather impressed they made it work
12:58:51 <dfeuer> However, there were some fairly interesting results, I thought.
12:58:59 <edwardk> in general you get into the same situation with traversals in terms of funlists, etc.
12:59:03 <jared-w> applicative sorting?
12:59:31 <jared-w> n_blownapart: what is this actually doing?
12:59:35 <edwardk> jared-w: http://elvishjerricco.github.io/2017/03/23/applicative-sorting.html and then  https://gist.github.com/treeowl/73a5464a8345d5716208a70ab1e4c5a9
12:59:45 <dfeuer> edwardk: did you ever figure out those Functor/Applicative/Monad instances for the  Mazzoli bind-like thingy?
12:59:51 <edwardk> i think there were some more followups
13:00:05 <dfeuer> There was another followup.
13:00:17 <dfeuer> Someone did cool stuff with a type checker plugin and lots of different heaps.
13:00:31 <edwardk> dfeuer: i have a version with an unsafeCoerce in the bitonic category, but i still find it unsatisfying
13:00:45 <edwardk> dfeuer: yeah
13:00:50 <dfeuer> edwardk: I don't know what that even means. What's the unsatisfying thing?
13:00:59 <edwardk> unsafeCoerce
13:01:07 <dfeuer> (TBH, I don't quite understand the issues in play there yet...)
13:01:14 <edwardk> if i had a better encoding of the category i could maybe avoid the need for it
13:01:23 <edwardk> er bicyclic monoid
13:01:24 <sproingie> n_blownapart: one problem with sicp in racket is having to switch everything to using mcons
13:01:31 <edwardk> bitonic is the guy who brought up the issue to me =)
13:01:51 <dfeuer> edwardk: can you show me that?
13:01:56 <bitonic> bicyclic modal always cracks me up
13:01:59 <edwardk> anyways the bicyclic category i'm using is a variant on the bicyclic semigroup
13:02:01 <bitonic> Monoid
13:02:12 <dfeuer> What's that mean?
13:02:24 <sproingie> bitonic: my favorite electronic term is "bistable multivibrator"
13:02:27 <edwardk> https://en.wikipedia.org/wiki/Bicyclic_semigroup
13:03:05 <dfeuer> This is very off-topic, but does anyone know how to set the user limit for number of processes?
13:03:10 <dfeuer> (In Linux)
13:03:15 <edwardk> data B = B !Int !Int   where the left Int represents unmatched closing parens, and the right Int represents unmatched opening parens. so each B x y is )^x (^y
13:03:27 <edwardk> mempty = B 0 0
13:03:28 <n_blownapart> sproingie, it's a bit above me. I did learn some math in the process but it took me 7 months to do 2/3 of the first chapter...algebraic proofs in the 1st chapter
13:03:58 <sproingie> dfeuer: https://stackoverflow.com/questions/9361816/maximum-number-of-processes-in-linux
13:04:09 <edwardk> mappend (B a b) (B c d) = case compare b c of { LT -> B (a + c - b) d; EQ -> B a d; GT -> B (d + b - c) }
13:04:12 <sproingie> two different answers depending on whether you're looking for a hard limit or soft one
13:04:13 <edwardk> with that, you can do things like
13:04:31 <edwardk> check for balanced parens by folding over an input string and checking if the result is B 0 0
13:04:43 <edwardk> i think dan piponi wrote a blog post forever ago
13:05:16 <edwardk> with the environments that bitonic wrote up you can show they form of form of bicyclic monoid.. but its type indexed. so its really a bicyclic category
13:05:30 <ongy> dfeuer: ulimit or if possible cgroups
13:05:44 <edwardk> and the 'closing' parens have variable assignments in them
13:06:20 <edwardk> so if it was untyped you'd have something like data B = B (Seq Exp) !Int  -- and you'd use drops and appends to maintain the left hand value
13:06:24 <geekosaur> dfeuer, ulimit -u (number of processes)
13:06:41 <edwardk> however, here its uglier because you change the number of variables being referenced as you move left in the sequence, etc.
13:07:09 <edwardk> anyways, i want a well typed drop that drops n variables off the left hand side of the sequence that can only refer to variables deeper in the sequence
13:07:27 <edwardk> but such a drop goes from log n time to log^2 n time without an unsafecoerce using data.sequence
13:07:47 <edwardk> (or a reflection-without-remorse-style thristed/type-aligned data.sequence)
13:08:10 <edwardk> whereas with an unsafecoerce i can make it have the right asymptotics
13:08:32 <edwardk> i'd like to find a structure that has the right asymptotics for 'type aligned drop'
13:08:51 <edwardk> but i don't yet know how to get that and maintain the other properties i want
13:09:45 <edwardk> i can do it if i just index everything with a natural number, but it works out much better for the monad if it behaves like bitonic's version rather than have me separate out all the Just's into a separate 'Fin n' case in the var construction
13:10:22 <edwardk> anyways, i'm kinda okay with shipping a version with the unsafecoerce i suppose
13:10:27 <edwardk> i just need to package it up nicely
13:11:13 <edwardk> i've been a bit distracted by trying to use circuit minimization stuff to speed up some parsing tools
13:11:15 <jared-w> So, a drop that's well typed and only refers to variables deeper in the sequence? What does that mean?
13:11:19 <edwardk> er.. it'll make sense eventually =)
13:11:36 <edwardk> jared-w: you need to read http://mazzo.li/posts/suspension.html
13:11:37 <jared-w> circuit minmization and graph reducing. The holy grail :p
13:11:50 <jared-w> woo, calculus! Thanks for the link :)
13:13:20 <max3> does Setup.hs not play with sandboxes?
13:13:25 <max3> cabal sandboxes
13:13:26 <dfeuer> edwardk: I think unsafeCoerce may be the best you can do. Unary naturals are slow....
13:13:45 <edwardk> dfeuer: i'm willing to use type level naturals and the constraints library tricks to re-associate sums
13:14:12 <dfeuer> sproingie: I have no idea. I just know that running firefox and chrome and then trying to do some other random thing I got a nasty error telling me I couldn't make any more processes...
13:15:39 <dfeuer> edwardk: I don't know that particular trick, but okay... I was just referring to the fact that   data Foo a = End a | Succ !(Foo a), and anything like it, can be represented efficiently with unsafeCoerce.
13:16:14 <geekosaur> dfeuer, that's actually a bit odd, the per-user process limit is usually pretty high 
13:16:33 <dfeuer> geekosaur: that SO question linked above suggests there's a thread limit too?
13:16:36 <Gurkenglas> holesOf gives me a way to fill holes in a structure in parallel. Can it be done sequentially?
13:16:36 <geekosaur> max3, it should, or sandboxes wouldn't work at all
13:16:37 <jared-w> yeah... look at your htop and see how many processes you're running
13:16:55 <max3> geekosaur, https://github.com/databrary/databrary/blob/master/dev#L12
13:17:16 <max3> places setup inside dist/setup/ and hence it does see the packages in my sandbox
13:17:24 <jared-w> I have 95 tasks and 514 threads running right now on my computer
13:17:36 <dfeuer> jared-w: I have 219 tasks and 983 threads.
13:17:37 <sproingie> the default limit is several thousand
13:17:44 <max3> 99 tasks but a thread ain't one
13:17:52 <dfeuer> But I don't know how many I had before I restarted firefox....
13:18:29 <geekosaur> dfeuer, hm, yes, processes vs. threads is a bit weird on Linux
13:18:56 <sproingie> the kernel limit only counts processes
13:19:06 <geekosaur> and newer firefox uses lots more processes
13:19:14 <dfeuer> geekosaur: many many....
13:19:20 <suppi> is there a version of Data.Map.delete that also returns whether it deleted or not?
13:19:41 <jared-w> dfeuer: as many as you set in the processes limit
13:19:53 <dfeuer> sproingie: there's a /proc/sys/kernel/threads-max, but I can't seem to actually change it.
13:20:02 <jared-w> Firefox isn't multi process by default, but it tries to be if you have the right plugins and such
13:20:20 <dfeuer> And I dunno if fthreads-max has to do with it either; probably not.
13:20:24 <sproingie> dfeuer: probably a sysctl to do it
13:20:42 <jared-w> anyway, google chrome has 1 process per tab. Firefox has at least one thread per tab and I have like 30 processes for firefox myself because I usually have tons of tabs
13:21:28 <dfeuer> Anyway, those limits and how to set them look liike black magic to me.
13:21:38 <sproingie> might not be firefox, see if you've got some other runaway process.  also, it could just be misreporting the error.
13:22:16 <Maxdamantus> Chrome doesn't use one process per tab btw
13:22:16 <dfeuer> edwardk: you also seemed a bit stuck on the Functor/Applicative/Monoid instances. Those didn't look very obvious to me, but I didn't dig deep.
13:22:43 <edwardk> dfeuer: i figured out the encoding of them, i just got distracted
13:22:49 <sproingie> most stuff in linux you set with sysctl nowadays, but it's still kinda hodgepodge.  standard sysadmin methodology is to search stackoverflow
13:22:55 <Gurkenglas> suppi, Data.Map.alterF (,Nothing) will return a Maybe of the old value and the new map
13:23:27 <Maxdamantus> in some cases it's kind of coerced into sharing a process because of shared global objects, in others I think it just shares anyway.
13:23:38 <sproingie> should be a global sysctl.conf somewhere (probably /etc) where you can put your persistent sysctl settings
13:23:40 <edwardk> ultimately you can look at the substitution morphisms as a subset of the kleisli ones, then view the whole thing through the reflection without remorse lens
13:23:47 <max3> stumped https://pastebin.com/BpBPrjkt
13:23:57 <max3> Setup doesn't see packages in cabal sandbox
13:24:09 <dfeuer> sproingie: I'll give it a sht.
13:24:45 <geekosaur> max3, to do things inside the sandbox you need to do them through cabal
13:24:46 <dfeuer> edwardk: subset because you can only substitute in things of thhe right type or something?
13:24:49 <jared-w> Weird. I thought chrome used one process per tab... anyway. Idk, have you tried restarting your system? That's usually my goto fix for things like that :p
13:25:08 <geekosaur> cabal exec ./Setup.hs -- configure --user -f -devel
13:25:10 <mivael_> hello all
13:25:15 <max3> geekosaur, :) thank you
13:25:15 <dfeuer> jared-w: that is a most annoying fix, although I do need to do it sometime soon to apply kernel updates.
13:25:17 <MP2E> what is goto? we use the continuation monad, here! /s :)
13:25:28 <geekosaur> neither cabal nor stack sandboxes are not recognized by the compiler directly
13:25:44 <wespiser> hey, a really cool paper on proof checking machine learning systems just came out: https://arxiv.org/pdf/1706.08605.pdf, is there anything like this in Haskell?
13:25:46 <geekosaur> or by the Cabal library that both the compiler and a compiled Setup use
13:25:47 <Gurkenglas> Why doesn't lambdabot see alterF?
13:25:56 <jared-w> dfeuer: applying kernel updates? Yeah that probably will fix a lot of things if you've updated the kernel but not restarted yet
13:26:16 <edwardk> dfeuer: you can view Env a b  as a subset of the morphisms a -> Exp b
13:26:40 <max3> cabal: The program './Setup' is required but it could not be found.
13:27:08 <dfeuer> edwardk: only a subset because it only distinguishes by ==?
13:27:10 <max3> maybe i should put Setup in the sandbox bin
13:27:20 <geekosaur> max3, sorry, the trailing .hs was habit and wrong here
13:27:25 <edwardk> but Env a b only allows a very limited set of changes to the type 'a' to get b, putting on or taking off levels of 'Just' as a delta of sorts
13:27:29 <max3> without .hs it doesn't either
13:27:35 <dfeuer> Oh, right, that.
13:27:45 <dfeuer> Forgot what we were talking about.
13:27:55 <max3> geekosaur, haha now it doesn't see any of the packages
13:28:00 <mivael_> Does someone know if list equivalence operator exist in Haskell?  I mean like (==) :: [a] -> [b] -> Bool, but returns True iff both lists really refer to the same list...
13:28:08 <dfeuer> edwardk: Env a b doesn't actually do any non-trivial mapping, right?
13:28:19 <max3> https://pastebin.com/3QQpwTG1
13:28:40 <mivael_> sorry my misprint:  (==) :: [a] -> [a] -> Bool
13:28:43 <edwardk> it adds stuff to the front for the Cons nodes and removes stuff for the weakens
13:28:55 <edwardk> in a way that corresponds with )'s and ('s in the bicyclic monoid
13:29:03 <suppi> Gurkenglas: thanks, i went with `alterF (maybe (False, Nothing) ((True,) . pure))` but that works too
13:29:09 <dfeuer> mivael_: well, there's reallyUnsafePtrEquality#, but you have to know that True means equal and False means "no information".
13:29:26 <geekosaur> Gurkenglas, where is alterF from?
13:29:31 <geekosaur> hayoo isn't seeing it either
13:29:36 <suppi> Data.Map
13:29:44 <suppi> http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html#v:alter
13:29:44 <Gurkenglas> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html#v:alterF
13:29:50 <suppi> heh
13:29:51 <geekosaur> hint: this may mean you are looking for a newer version than is deployed
13:30:02 <suppi> woops, below that.
13:30:14 <dfeuer> edwardk: in the original, the actual maupping was in CanonicalEnv, yeah?
13:30:23 <edwardk> yeah
13:30:33 <edwardk> he had a rather complicated interaction between the two
13:30:37 <geekosaur> mivael_, in general asking for address equivalence is both unsafe and usually means you are thinking about it wrong
13:30:40 <Gurkenglas> That's what I thought, but then https://hackage.haskell.org/package/containers-0.5.10.2/changelog says Aug 2016 and the random ghci I had fired up also didnt see it
13:30:53 <edwardk> i'm normalizing it to a concatenation of a bunch of conses (the sequence) onto a bunch of weakenings
13:31:01 <edwardk> and then normalizing to preserve that invariant
13:31:17 <dfeuer> Whereas you have a bunch of types with completely incomprehensible names....
13:31:33 <edwardk> they only had to mean something to me ;)
13:31:55 <edwardk> W is weakening E is extension
13:32:12 <dfeuer> But your mapping is in the .... E? Susp?
13:32:34 <dfeuer> I can't see the forest for the trees.
13:32:41 <edwardk> oh wow the code on github is old
13:32:47 <geekosaur> Gurkenglas, fwiw my ghc 8.0.2 has containers-0.5.7.1
13:32:52 <edwardk> data Env f a b where Env :: Q (E f) a b -> Q W b c -> Env f a c
13:33:09 <edwardk> We have a sequence of extensions followed by a sequence of weakenings
13:33:10 <dfeuer> edwardk: if you have new code, you should probably upload it before your computer falls out the window.
13:33:18 <edwardk> dfeuer: =P
13:33:29 <edwardk> i have code in snippets not in that repos format
13:33:48 <edwardk> i wrote it at zurihac in the few moments i was allowed to sit and not talk to people
13:34:03 <dfeuer> Well, I'd like to see it if you get a chance to stick it somewhere...
13:34:15 <edwardk> sure
13:34:21 <mivael_> geekosaur: I understand.  I wanted to avoid defining Eq instance for my custom data type because I never actually need to compare them for equality.  I only compare lists of them.  I feel uneasy defining the instance because I'm loosing a guarantee that the lists will never be compared by their values.
13:35:01 <angryMonk> Hi there, I have a semi-interesting question for y'all
13:35:34 <angryMonk> how do i add a new data constructor to a data definition (probably via TH)
13:35:40 <dfeuer> mivael_: that's not a sensible guarantee.
13:35:41 <mivael_> dfeuer, thank you!  I'm looking for a safe way, though.
13:35:58 <mivael_> dfeuer: I would argue.
13:36:04 <dfeuer> If you can compare lists of them, then I can compare individual ones.
13:36:08 <edwardk> https://www.irccloud.com/pastebin/KdvpGI7h/
13:36:16 <dfeuer> same x y = [x] == [y]
13:36:23 <edwardk> dfeuer: ^- snippet using the separate list and no type safety
13:36:31 <angryMonk> wait, what are y'all talking about?
13:36:54 <geekosaur> angryMonk, once you have a data declaration, you cannot add constructors after the fact
13:37:03 <geekosaur> not via TH, not any other way
13:37:22 <angryMonk> damn
13:37:33 <jared-w> You can, of course, add a constructor by changing the actual definition...
13:37:43 <dfeuer> Or you can wrap the type up in another.
13:37:55 <mivael_> dfeuer: generally yes.  That's why I would like to have a "special" list comparison, which uses the idea of lists mutability to check for lists equality.
13:38:02 <dfeuer> Foo' a = Foo (Foo a) | SomethingElse ....
13:38:07 <jared-w> MyBool = True | False | WTF -- totally fine
13:38:12 <mivael_> s/mutability/immutability/  :)
13:38:21 <dfeuer> mivael_: you are using words, but they are not making sense.
13:38:23 <angryMonk> well, I'm trying to make it super easy for a programmer to define a new type
13:38:41 <angryMonk> hmmmm
13:38:47 <Gurkenglas> Can you fill the holes in a structure one after the other?
13:38:47 <WinchellsM> Does anyone know of any good analytics libraries to sync a Haskell application up to a dashboard (looks like there are several options online: flurry, mixpanel, etc.) to see how people are using your Desktop application?
13:38:53 <jared-w> It's already as easy as it can get in Haskell, though? newtype MyType, data MyData... etc
13:39:25 <sproingie> types are not extensible, type *classes* however are
13:39:28 <dfeuer> Gurkenglas: isn't that just traverse?
13:39:47 <sproingie> well the class itself can't be extended but you can make new instances any time
13:40:02 <jared-w> mivael_: why would you actually want to compare lists to see if they're the /same/ one? Like, what are you trying to accomplish by doing so?
13:40:38 <angryMonk> wait
13:40:46 <angryMonk> i can't add to a data type
13:40:52 <sproingie> i find i only need object identity when i'm using mutable state
13:40:57 <angryMonk> but I can define new types, right?
13:41:05 <sproingie> naturally
13:41:05 <mivael__> jared-w: trying to implement a two-pointers algorithm (without using indices but "rest of list" references
13:41:33 <Gurkenglas> dfeuer, I was trying to shrink the problem description, maybe I went too far. Or maybe not. Here's the code to remove the repeated holesOf from: https://codereview.stackexchange.com/a/166904/84131
13:41:35 <angryMonk> so just make a program that works on one type and make type NewBoy = OldBoy
13:41:39 <angryMonk> huh
13:41:51 <geekosaur> angryMonk, yes. note that this requires wrapping the old in a new constructor, if you are doing it to "extend" an existing type: data WTFBool = RBool Bool | FileNotFound
13:42:00 <jared-w> mivael__: right... So you're trying to shoehorn an imperative algorithm into a functional language and are trying to abuse certain imperative features searching for efficiency you might not even need
13:42:02 <sproingie> sure but that just creates a new name for OldBoy, it doesn't create an actual new type
13:42:19 <jared-w> mivael__: out of curiosity, which algorithm is it?
13:42:23 <geekosaur> (the one without RBool will compile but not do what you want)
13:42:36 <sproingie> there is however newtype which can wrap an existing type in a genuinely new type.  and the cool thing about newtype is it's free at runtime
13:42:53 <mivael__> jared-w: I don't think the algorithm is really imperative... just a minute...
13:43:05 <angryMonk> sproingie, yeah you're rightabout newtype, my bad
13:43:26 <angryMonk> geekosaur: didn't follow
13:44:01 <geekosaur> data WTFBool = Bool | FileNotFound -- this Bool is not the same as the Bool *type*, it is a new *data constructor*.
13:44:12 <angryMonk> right
13:44:14 <jared-w> There's 3 ways to do types in Haskell. type, newtype, and data.
13:44:49 <jared-w> 1) type MyBool = Bool. This is just an alias, think of it as "temporarily renaming Bool"; it does nothing useful except renaming for functions. Even error messages will say "Bool" instead of "MyBool"
13:45:04 <sproingie> newtype used to be annoying to use what with all the wrapping and unwrapping, now you can just make it derive whatever it wraps, minus whatever class you're changing the behavior for
13:45:36 <rborch> noob question: I want to add to each element of a list of strings its index as part of the string, so that i can print it out as a list of options on the cli. For example: ["a", "b"] -> ["(0) a", ["(1) b"]. I came up with this solution: http://lpaste.net/356537  However, for such a simple task, this solution looks a bit overcomplicated. Any suggest
13:45:36 <rborch> ions?
13:46:43 <sproingie> "ions" would make a good name for an option parsing lib :)
13:48:09 <dfeuer> mivael__: the trouble is that a Haskell list doesn't really capture the idea of sharing very well. Is   cycle [1] the same as cycle [1,1]? What about repeat 1? Well, they're represented differently in memory, but the only way to discover that is using unsafe features (or in the last case, seeing whether you eventually run out of time/memory trying to look at the whole thing).
13:48:35 <dfeuer> mivael__: to do that sort of thing *right*, you need to represent the graph you're looking at much more explicitly.
13:48:40 <angryMonk> geekosaur, sproinge: I'm sorry I'm leaving.
13:48:44 <dfeuer> See things like fgl.
13:48:51 <angryMonk> Got to go, I'd hate to cut you off
13:49:00 <angryMonk> Thanks for the help!
13:49:03 <sproingie> np, come on back sometime
13:50:19 * jared-w is now in the "left associativity $ and $! camp"
13:51:19 <dolio> You decided you wanted to be disappointed forever with the rest of us?
13:51:20 <MarcelineVQ> then the next step is to determine what expressions are made nicer by right associativity
13:51:37 <sproingie> doesn't matter what associativity you give it, someone will mis-parse it when they read it
13:51:54 <dfeuer> edwardk: I don't understand enough of what this whole thing is about to even grok the untyped version properly.
13:52:17 <dfeuer> MarcelineVQ: runST $ blah $ blah
13:52:27 <dfeuer> Which would have to be written  runST (blah blah)
13:52:39 <dfeuer> (for two different values of blah)
13:52:40 <glguy> *should have to be*
13:52:40 <jared-w> dfeuer: that's basically me whenever he starts talking about anything. However, I read it all and absorb it so that in a few years whenever I reach the right stage of enlightenment, all the wires in my brain get connected properly :)
13:52:58 <jared-w> dolio: why not? I'm a perpetually disappointed kinda guy
13:53:04 <dolio> :)
13:53:17 <mivael__> jared-w: so called "two pointers method" is used to solve specific types of algorithmic problems...  An example of such problem is this one: https://www.codechef.com/problems/MAXSEGM
13:53:25 <jared-w> Although to be fair, the camp I'm /really/ in is that $ is a stupid symbol to use for this kinda thing anyway
13:53:46 <jared-w> I like triangles much better |> <|  although the ascii ones are kinda stupid
13:54:06 <sproingie> |> is compose in a couple different languages
13:54:28 <jared-w> which is where I got the idea for |> instead of $
13:54:44 <mivael__> jared-w: I can also post a link to my C++ solution to this problem if you are interested in this method itself (my haskell solution is not yet ready).
13:55:15 <jared-w> Sure, why not
13:56:07 <mivael__> jared-w: https://www.codechef.com/viewsolution/14338164
13:56:25 <dfeuer> mivael__: I don't see any lists in that problem.
13:56:53 <jared-w> dfeuer: they're using arrays, that's the cannonical C list structure for this kinda problem
13:57:13 <mivael__> dfeuer: you mean you are sure it should not be implemented using lists?
13:57:22 <torstein_> how can I eta reduce this? tup3 a b c = lift $ (,,) a b c
13:57:22 <jared-w> In haskell I would start with a list of tuples (W_i, C_i)
13:57:37 <jared-w> @pl tup3 a b c = lift $ (,,) a b c
13:57:37 <lambdabot> tup3 = ((lift .) .) . (,,)
13:57:56 <torstein_> okay so not much clearer
13:58:04 <dfeuer> mivael__: no, I didn't say that.
13:58:15 <jared-w> nope :). I personally like (a,b,c) better
13:58:29 <mivael__> jared-w: the list of tuples is exactly what I'm trying to use in my implementation
13:58:43 <MarcelineVQ> which lift is that
13:58:44 <geekosaur> yeh, the $ is hiding that there are extra parentheses meaning more work needed
13:59:42 <jared-w> You need to find a unique range with the maximum sum. You can probably do some ungodly list comprehension for this
14:00:14 <mivael__> jared-w: ungoldly?
14:00:26 <edwardk> dfeuer: https://www.iro.umontreal.ca/~monnier/HOR-2016.pdf is the best introduction to the topic
14:00:45 <edwardk> there they don't merge environments but rely on a beta' rule
14:00:45 <jared-w> Well, it'd be pretty ugly to turn all of that into a oneliner list comprehension and it's not really the best way to solve that problem at all
14:00:57 <dfeuer> Thanks, edwardk.
14:01:00 <edwardk> but it starts with the basic idea and builds
14:01:16 <torstein_> MarcelineVQ: accelerate
14:01:17 <edwardk> it really helped clarify things for me
14:01:56 <dfeuer> I'll take a look. Perhaps a few code comments about what each thing is supposed to represent could be useful though?
14:02:37 <jared-w> mivael__: https://lettier.github.io/posts/2016-04-14-max-subarray-in-haskell.html does this help you at all?
14:03:16 <edwardk> dfeuer: probably
14:03:55 <edwardk> basically the stuff in an "Env" which is really a delta-environment of some sort is a bunch of references to stuff later in the environment or to free variables.
14:03:59 <jared-w> hmm... actually I'm not really sure I like that code
14:04:13 <edwardk> so if i have a term consed at the front it can only refer to stuff later in the current fragment of an environment
14:04:47 <mivael__> jared-w, dfeuer: I did like an idea to use the same basic algorithm (I do not see it as imperative but maybe I wrong), but I did not like the idea to carry indices through all my implementation.  Thus I tried to use list references as "pointers" and 'tail' for moving those pointers forward.  I thought that it is a safe way to do considering lists immutability in Haskel -- until the compiler advised me to define Eq instance for my tuples.
14:04:52 <edwardk> the trick is maintaining the invariant that bitonic is so careful to do that those substitutions happen before it is accessed
14:05:22 <dfeuer> mivael__: I think tracking indices makes a lot more sense.....
14:07:29 <jared-w> Tracking indices makes a lot more sense. What you're trying to do is track indices through the hardware instead of software (something C programerms are fond of), but you can't really do that in a language like Haskell
14:08:48 <jared-w> https://patternsinfp.wordpress.com/2011/05/05/horners-rule/ looks like what you want, somewhat
14:10:22 <mivael__> jared-w: that you for both links!  I'm looking through the first one...
14:10:29 <jared-w> And lastly, code with comments: https://bonsaicode.wordpress.com/2010/12/03/programming-praxis-maximum-sum-subsequence/
14:11:02 <jared-w> mivael__: I would probably only briefly look at it and then probably look at it last. I tend to accidentally list links in reverse order of usefulness :p
14:11:04 <mivael__> jared-w: dfeuer: that you for your advises!  I understood that I was wrong to throw indices out of my implementation.
14:11:16 <mivael__> s/that you/thank you/
14:12:18 <dfeuer> No problem, mivael__. BTW, you may want to start out by putting the indices in explicitly: zip [0..] xs = [(0,x0), (1,x1), ..., (n, xn)]
14:12:33 <jared-w> mivael__: it's not really that you were "throwing" them out, you were just trying to use implicit hardware concepts of indices rather than explicit tuple indices. Hardware implicit things just don't really work super well in Haskell :)
14:12:39 <Gurkenglas> Can https://codereview.stackexchange.com/a/166904/84131 be rewritten without recursion or at least without repeated holesOf?
14:13:17 * ertes is thinking about writing a monitoring system in haskell, after having tried so many, and none of them would really fit
14:13:59 <jared-w> ertes: what kinda monitoring system?
14:14:23 <ertes> jared-w: dynamic infrastructure monitoring
14:14:46 <ertes> lots of servers, each with lots of containers
14:15:23 <jared-w> Off topic: mivael__ your C++ code is kinda painful to look at. It's /very/ C style
14:15:52 <dfeuer> Gurkenglas: thinking.
14:18:10 <dfeuer> Gurkenglas: well, there surely should be a way. To begin with, you can maintain the "hole state" along with the board state.
14:21:43 <mivael__> jared-w: maybe it is :)   Sorry for that, it is a common thing in competitive programming contexts.
14:22:21 <jared-w> no no it's totally fine, it happens a lot. People try to learn new tools by using familiar exercises; that's how you /should/ learn, it just doesn't come as naturally when learning a new way of thinking (ie, Haskell)
14:22:42 <jared-w> whoops, wrong reply :p
14:22:51 <jfischoff> ertes: what have you tried?
14:23:09 <rborch> anyone? http://lpaste.net/8489596433614241792
14:23:11 <jared-w> mivael__: yeah, it makes sense in competitive programming... it just hurts my eyes a bit. I like shiny tools :)
14:23:16 <jfischoff> I sometimes think the same … and then I remember I have only really used graphite personally
14:23:21 <rborch> i reformatted and commented my previous question
14:24:06 <jfischoff> oh crazy, my apartments wifi blocks lpaste
14:24:33 <jared-w> lol what, seriously? That's so odd
14:24:42 <geekosaur> I'm not surprised. a fair amount of the recent instability of lpaste is overload due to it not having spam protection
14:24:47 <geekosaur> which has also gotten it onto blacklists
14:24:55 <jared-w> ahh, that's a shame
14:25:09 <mivael__> jfischoff: same at my work, by the way
14:25:28 <jared-w> jfischoff: http://i.imgur.com/aa9UjJc.png
14:25:29 <geekosaur> someone needs to adopt it and beef it up with antispam measures, then get it removed from the various blacklists
14:25:33 <mivael__> "non-business site" or something like that...
14:25:48 <jfischoff> my name in print
14:26:08 <jared-w> the second link is just the non commented version of the add_indices
14:26:10 <mivael__> dfeuer: thank you for the zip hint
14:26:25 <dfeuer> You're welcome.
14:26:29 <mivael__> jared-w: the last link you provided is awesome!
14:26:32 <rborch> posted it on pastebin, too, if lpaste does not work: https://pastebin.com/49pgmj4Q
14:26:37 <mivael__> thank you all
14:27:06 <jfischoff> lambdabot: 1+1
14:27:13 <jared-w> > 1 + 1
14:27:15 <lambdabot>  2
14:27:18 <jfischoff> right
14:27:27 <jfischoff> jeez 
14:27:35 <jfischoff> been away for a while
14:27:56 <jared-w> you can also /query lambdabot > code
14:28:01 <jfischoff> > zip [0 .. ] [“a”, “b”]
14:28:02 <lambdabot>  <hint>:1:14: error: lexical error at character '\8220'
14:28:15 <geekosaur> "smart" quotes :(
14:28:21 <jfischoff> smh
14:28:28 <jared-w> > zip [0..] ["a","b"]
14:28:30 <lambdabot>  [(0,"a"),(1,"b")]
14:28:54 <jared-w> > show $ zip [0..] ["a","b"] -- no idea if this would actually work
14:28:56 <lambdabot>  "[(0,\"a\"),(1,\"b\")]"
14:29:13 <Gurkenglas> :t concat . zipWith (\idx name -> "(" ++ show idx ++ ") " ++ name) [1..] -- rborch
14:29:14 <lambdabot> [[Char]] -> [Char]
14:29:18 <jared-w>  ¯\_(ツ)_/¯ I'm a magician
14:29:44 <jfischoff> rborch: look at Gurkenglas' answer
14:30:27 <Gurkenglas> dfeuer, what do you mean by hole state? Each hole is only used once, and would you derive the next hole from the previous?
14:31:37 <rborch> Gurkenglas, much better, thank you!
14:31:43 <dfeuer> Gurkenglas: I just mean that you don't need to find all the holes each time. You already know where they are. Suppose you have an array instead of a list representing the board. Then the hole state could be a list of indices showing whwere the holes are. Right? Wrong?
14:32:04 <jared-w> rborch: also, if you're not married to that exact formatting, you can get [(0,a),(1,b),...] with just zip [0..] ["a","b"]
14:32:06 <rborch> (i think this is actually the second time you helped me out)
14:32:20 <jared-w> and the show function will print that out just fine
14:32:35 <ertes> jfischoff: i have tried: consul, monit, netdata, sensu, zabbix
14:32:52 <ertes> jfischoff: consul was the most promising one, and i'd most likely take that one as an inspiration
14:32:55 <rborch> ok, thank you, too, jared-w
14:33:31 <Gurkenglas> dfeuer, sure, sounds like a list of lenses instead of a list of holes
14:34:11 <ertes> jfischoff: and zabbix was about the worst piece of s…oftware i had the displeasure of trying to use for a good few years
14:34:21 <dfeuer> Gurkenglas: I think you could do that. 
14:34:32 <jfischoff> how those compare to netdata, prometheus, influxDB and graphite. js but seriously, are those examples in the same class as the ones you listed? 
14:36:06 <ertes> jfischoff: netdata is on the list, but i would consider it (along with graphite) to be less of an infrastructure monitoring/reporting solution, and more of something the admin would actively watch to see load distribution, etc.
14:36:34 <ertes> netdata is really good at that actually
14:36:59 <jfischoff> what is the difference?
14:37:02 <jfischoff> well 
14:37:09 <jfischoff> I guess there is not alerting?
14:37:13 <Gurkenglas> Hmm. "backtrack = auf foo (traverse . traverse . filtered (==E)) bar"?
14:37:14 <jfischoff> s/not/no
14:37:23 <ertes> jfischoff: there is, but it's rather basic
14:37:33 <ertes> the other ones i have no experience with
14:38:55 <jfischoff> but is that why you considered less of a monitoring solution and more of something for watching?
14:39:21 <jared-w> I think it's really a scale difference. If you're an admin over <50 computers, you can probably get away with manual watching of a lot of stuff
14:39:52 <jared-w> If you're an admin over >1,000 computers, machines, printers, yadda yadda. You really want all the automation, monitoring, watching, analysis, heavy-lifting, etc., you can get
14:40:06 <rborch> jared-w
14:40:07 <rborch> jared-w
14:40:07 <rborch> jared-w, may i ask what irc client you are using (i took a look at your screenshot)? Or is this nice little window on the right just a feature of your window manager?
14:40:10 <ertes> jfischoff: well, let's define what those terms mean first: if you define monitoring to be about presenting graphs (CPU load, etc.) and watching to be more about waking me up at 3 AM, then yes, i want watching
14:40:16 <rborch> sry
14:40:25 <rborch> failed pasting your name
14:40:35 <ertes> jared-w: 50 is a huge number…  you probably want to have automated monitoring at much smaller scales
14:40:56 <jared-w> ertes: fair, adjust that number however. Hopefully the idea is still correct? :p
14:41:26 <jared-w> rborch: np. I'm using weechat. It's in a terminal. The buttons on the bottom of the terminal are different windows because I'm using a terminal multiplexer called tmux
14:41:39 <Sylph-DS> Hello, what would be the recommend way to format a floating point number into a string? I found printf online but what if I don't want to print it (right away)?
14:41:50 <rborch> jared-w: thx
14:42:07 <jared-w> The window itself is spawned with my window manager, bspwm, using a nifty little hack with xdo to make it floating, a certain size and position, and "sticky" across my desktops
14:42:38 <jared-w> I can also hide and show the window non-destructively with a keybind
14:42:38 <sproingie> i imagine printf has a sprintf function?
14:42:51 <ertes> jared-w: well, consider this: you have a certain contract, and monitoring is really watching whether you're in danger of breaching it…  with that in mind, i think you should have automated monitoring even with a single server =)
14:42:51 <rborch> jared-w: ok, so i was right, that there is some magic involved^^
14:43:00 <geekosaur> sproingie, printf is polymorphic
14:43:07 <geekosaur> aklthough using printf is a bit of a smell
14:43:11 <sproingie> ok a polymorphic sprintf
14:43:36 <geekosaur> :t printf "%d" (minBound :: Int) :: String
14:43:37 <lambdabot> String
14:43:43 <geekosaur> :t printf "%d" (minBound :: Int) :: IO ()
14:43:44 <lambdabot> IO ()
14:43:45 <jfischoff> I rolled my own PagerDuty alerting to go with graphite :p. Which exposed some issues in graphites design. It tends not to return the most recent data reliably which is terrible for alerting.
14:43:52 <sproingie> oh that kind of polymorphic
14:44:04 <ertes> Sylph-DS: beside printf there is also a load of functions in the Numeric module
14:44:08 <dfeuer> Gurkenglas: I haven't thought this through very far, but what happens if you represent the holes by a type variable, and then traverse the board in something like [] or LogicT?
14:44:22 <Sylph-DS> ertes, okay let me have a look at those
14:44:27 <jared-w> jfischoff: I just read your "has" pattern article. Great stuff
14:44:36 <ertes> Sylph-DS: if you need to format multiple things, those are likely more efficient and also slightly saner than printf
14:44:36 <dfeuer> data Square a = X | O | Var a
14:44:41 <jfischoff> jared-w: ah great thanks!
14:44:45 <Sylph-DS> thanks ertes, sproingie, geekosaur
14:44:48 <geekosaur> the Printftype typclass is moderately evil :)
14:44:59 <sproingie> it's doing evil things
14:45:03 <dfeuer> geekosaur: why evil?
14:45:07 <ertes> Sylph-DS: on the other hand printf is *really* convenient and also more versatile =)
14:45:24 <ertes> > printf "%+8.3f" (pi :: Double) :: String
14:45:27 <lambdabot>  "  +3.142"
14:45:29 <dfeuer> What's that package called that does type-safe printf stuff?
14:45:30 <jared-w> the data.String.Conv library is completely evil :)
14:45:54 <geekosaur> dfeuer, kinda plays havoc with type inference, for one. partial application is painful and requires type annotations, for another
14:46:13 <jared-w> dfeuer: you're probably looking for printf-safe?
14:46:15 <jfischoff> ertes: what I want to do is create a Haskell starter project that has all these (monitoring, logging, load balancing, real time configuration ... etc) already setup. So it would be like a Haskell plus starter one could just deploy to AWS.
14:46:35 <jared-w> Although there is also a formatting package and other misc solutions
14:46:52 <jfischoff> A whole bunch of Haskell orgs are writing the same code that isn't really what makes their respective companies interesting
14:46:57 <ertes> Sylph-DS: note that printf is not as unsafe as C's variant of printf: you will not get a memory violation, but a run-time exception, if you use it wrongly
14:47:01 <jfischoff> it would be nice to work together
14:47:36 <phz_> argh I hate that issue
14:47:43 <jared-w> Also you're so nice to metafunctor lol
14:47:50 <ertes> jfischoff: i would also at distributivity to the mix, similar to consul
14:47:55 <ertes> jfischoff: that's really a killer feature
14:48:10 <sproingie> that'd be nice.  whipping together robust microservices in java was a breeze with dropwizard, the same kind of packaging in a haskell app would be awesome
14:48:13 <ertes> jfischoff: in fact consul comes really close to what you just said
14:48:19 <Gurkenglas> Huh, is LogicT ListT done right? I like this formulation more than the other ones. dfeuer, "represent the holes by a type variable"?
14:48:19 <jared-w> ertes: but does that make it /web-scale/?  /s
14:48:28 <jfischoff> consul is like etcd and zookeeper right?
14:48:30 <Sylph-DS> haha
14:48:31 <Sylph-DS> well
14:48:51 <rborch> ok, thanks to everyone, I'm leaving. Bye
14:48:53 <jared-w> sproingie: I gotta give it to Java. As much as I hate using their language, it's such a pain to use that absolutely amazing tooling has developed around it lol
14:49:21 <jfischoff> yeah so such a mixed blessing
14:49:30 <dfeuer> Gurkenglas: well, LogicT is one concept of that, I think? There are several notions of what ListT shsould have been!
14:49:35 <Sylph-DS> don't take this the wrong way, but if the commonly used function for float formatting is printf, what the hell are we doing? C gets off on being stuck with 40 year old legacy, what's our excuse?
14:49:39 <sproingie> ecosystem counts for a lot.  for devs who want to get an app together, more so than the benefits of the language itself
14:49:59 <ertes> jfischoff: it also has a combined monitoring and service discovery concept, e.g. if a machine enters the failed state, it will be removed from the DNS server in real time
14:50:04 <sproingie> Sylph-DS: there's nothing wrong with the idea of a format string for converting other thigs to strings
14:50:14 <jfischoff> ertes: interesting
14:50:39 <sproingie> a port of lisp's FORMAT might be strictly more powerful, but it's full of boondoggles that shouldn't be lumped in with string formatting
14:50:53 <Sylph-DS> sproingie, my problem is with the function name, more than anything
14:51:06 <sproingie> meh.  people ask "where's printf for haskell" and there it is.
14:51:20 <sproingie> it doesnt suffer from format string attacks at any rate
14:51:24 <ertes> jfischoff: and it's distributed by default, so there is never a single point of failure
14:51:55 <dfeuer> Gurkenglas: what I meant is that you can make the holes more hole-like. I guess I really mean   data FinalSquare = X | O   data Square a = Final FinalSquare | Var a.
14:52:10 <ertes> jfischoff: so you too thought of writing something like that?
14:52:19 <jfischoff> ertes: yeah I think those are others are like that too.
14:52:29 <dfeuer> The idea is that you traverse an array of Square () to get an array of Square FinalSquare,
14:52:40 <dfeuer> which you can then smash to an array of FinalSquare.
14:52:41 <jared-w> I'm not surprised that I'm not alone in having a sysadmin background here :)
14:52:43 <dfeuer> Or something like that.
14:52:57 <dfeuer> I'm being fuzzy because I haven't thought it through.
14:53:50 <ertes> Sylph-DS: i think there are mainly two options: format strings or combinators…  it's kinda like the regex vs. parser combinators situation
14:54:04 <jfischoff> ertes: I've thought about putting together a starter project that includes provisioning those things with the proper integrations in Haskell webserver. Plus some other stuff that I think is important, like nice infra for integration tests and fast db tests. Zero downtime deploys ... basically all the things I think are good ideas to do early that people wait on.
14:54:10 <jared-w> And Haskell looooves its parsers. Can't blame 'em
14:54:35 <jared-w> Most of the time people use regex over parsers because the language support for parsers is lacking. It's amusing that haskell is the other way around
14:55:17 <jared-w> jfischoff: so by starter project you mean something like a container box you can use with (insert container solution)?
14:55:21 <ertes> jfischoff: i'm still reluctant, because there are a lot of missing libraries…  for example we don't have any good libraries for discovery and election
14:55:41 <jfischoff> the census configuration systems like consul are useful for supporting things like feature flags and other real time options. Stuff like this never makes it many Haskell projects because many are so overwhelmed with the basics they never get there. Also all this stuff is outside the haskell ecosystem
14:56:06 <jfischoff> jared-w: yeah.
14:56:51 <jfischoff> it's fine it's outside the haskell ecosystem fwiw ... we should still use them
14:56:51 <ertes> jfischoff: yeah, exactly…  another reason i'm reluctant is that it's hard to convince my employer to pay me for that =)
14:57:30 <jfischoff> yeah no one thinks it is worth it to do, but it you started with those things you would be confused how to work without them
14:58:18 <ertes> well, actually my employer is rather open-minded, but this project would be rather huge, and it would be really difficult to sell haskell in that area
14:58:51 <Sylph-DS> ertes, I don't mind format strings (I come from C++ mostly, and the C++ solution is not much better), but I have a somewhat allergic reaction to a function with "print" in it that doesn't actually print anything. Especially in a language like haskell where we try to keep function side effects like printing as separate as possible.
14:59:06 <ertes> "all of this stuff exists in go, why would you use haskell?"
14:59:33 <jared-w> "go is terrible" wasn't the right answer?
14:59:35 <sproingie> there's a printf for c++ that uses variadic templates instead of varargs.  it's nifty.
14:59:47 <MP2E> hahah
15:00:11 <jared-w> "keep in mind, we ARE a Java shop. 'x is terrible' is not a valid excuse here"
15:00:19 <ertes> Sylph-DS: i've learned that "print" in programming has nothing to do with ink and paper =)
15:00:36 <ertes> and you can make it "print", if you want
15:00:38 <sproingie> "why use haskell?  before you can get my answer, you need to check whether i sent you an error instead.  yes, for every question."
15:00:43 <ertes> :t printf "blah" :: IO ()
15:00:44 <lambdabot> IO ()
15:01:06 <jfischoff> I think two selling points of Haskell are: easy to refactor and good concurrency support. Maybe believe that go has good concurrency support but STM is really in class by itself. Same with Haskell's ability to support refactoring with confidence. Business like being able to refactor because they can change their mind and quickly make changes. 
15:01:12 <Sylph-DS> Well, in C's printf it does mean that.
15:01:30 <ertes> jared-w: explain why to someone who isn't mainly a programmer
15:01:43 <jared-w> Well if I was giving a serious answer...
15:02:38 <ertes> Sylph-DS: well, i guess the proper name in haskell for the String variant would be "showf", but then you would need separate type classes
15:02:45 <maerwald> the main thing about a language isn't so much what language properties there are (that's maybe 30% of the deal)... the rest is: how does the community use the language?
15:03:21 <jared-w> I would say that Go was designed to solve a specific problem and to fit a very certain culture. It's ugly, verbose, and works for Google because Google designed it. That means it's naturally a terrible tool to use for most problems. Haskell, on the other hand, is very robust and its strengths play well to the problem domain of monitoring. Rather than fighting Go's weaknesses, it's better to exploit Haskell's
15:03:23 <MP2E> even explaining why go is bad to programmers can be difficult
15:03:23 <jared-w> strengths.
15:03:31 * JuanDaugherty heard maerwald went over to Rust
15:03:59 <sproingie> MP2E: i dunno, the exception handling model in go is pretty much an immediate turn-off
15:04:05 <MP2E> 'but it's google! and it was made by the creators of C! and it's "web-scale"!' :P
15:04:08 <MP2E> yeah
15:04:13 <maerwald> JuanDaugherty: I just raged because gdb and valgrind are semi-broken there and you cannot interface easily with C functions without huge unsafe blocks that can screw up your whole stack without the compiler knowing anything about it (say: memory safety, haha)
15:04:29 <jared-w> Then depending on how they answer, I'd pursue certain lines of argument: Concurrency, refactoring, safety, speec, etc... as warranted.
15:04:30 <JuanDaugherty> ah
15:04:38 <sproingie> i get that structured exceptions have their problems.  i get that go doesn't necessarily want to use monads.  but i'm baffled every time i hear go devs actually *defend* the current idiom for checking errors
15:04:54 <EvanR> jfischoff: curious what is good about go's concurrency?
15:05:05 <maerwald> EvanR: it has a neat keyword for it
15:05:14 <EvanR> is it like java's keyword?
15:05:17 <jared-w> EvanR: it's green threads and works decently well for what google uses it for
15:05:36 <maerwald> EvanR: and the language mascot is more awesome, so clearly...
15:05:41 <ertes> i have a pretty clear idea about what kind of argument i need in my situation, which is why i was able to sell haskell for quite a few tasks already…  but selling it for a new monitoring system is almost impossible
15:05:46 <sproingie> so go's inculcated this attitude of "the people in charge of go know what's best for us and everything else is unnecessary"
15:05:47 <jared-w> Really, go was designed to fit Google's culture. Google has an /incredibly/ conservative coding culture because they're so big they want to stay as safe as possible code wise
15:06:00 <sproingie> jared-w: interface {} doesn't seem the road to safety
15:06:23 <ertes> there are too many existing solutions, and a considerable lack of library support in haskell
15:06:25 <sproingie> i guess intention and execution are different things
15:06:26 <Sylph-DS> Hmm, right. Well, I think ima use the Numeric.ShowFFloat function instead. Thanks again guys and/or girls.
15:06:43 <EvanR> ok
15:06:44 <sproingie> if go reflects google's culture, i can't imagine wanting to write code there
15:06:51 <MP2E> ^
15:06:53 <jared-w> sproingie: were you referring to my reply to EvanR about go's concurrency?
15:07:04 <MP2E> if the culture represents the language, it sounds unremarkable and bland :P
15:07:10 <ertes> Sylph-DS: here is one data point: i use printf a lot =)
15:07:18 <maerwald> JuanDaugherty: also, when they try to map C APIs like gtk+, they end up with very weird decisions (e.g. about lifetime of callback functions) that bite you int he a** every time. So mapping C APIs to rust isn't even that easy. I'd say even more difficult than in haskell, because in haskell your program just crashes with gtk+.
15:07:25 * JuanDaugherty dreams of being a coddled factotum at the googleplex
15:07:27 <sproingie> jared-w: no, the "safe as possible" thing.  but then there's empty interfaces, which is like casting from Object
15:07:31 <Sylph-DS> ertes, looking at the Numeric functions, I don't blame you ;)
15:07:37 <ertes> Sylph-DS: perhaps the perfect variant would pass the format string as a type argument rather than a value argument
15:07:46 <jfischoff> EvanR: I think people like it's syntax for creating and waiting for threads
15:07:53 <jared-w> They literally encourage copy & paste over generics... No I don't really want to code at google either. Google hires /massive/ amounts of code monkeys. The only fun part of google is working in the research stuff
15:07:54 <ertes> Sylph-DS: that way everything would be static
15:08:07 <EvanR> https://ro-che.info/ccc/28
15:08:31 <sproingie> whereas facebook appears to be encouraging a rather different culture
15:08:31 <ertes> Sylph-DS: printf (Proxy :: Proxy "Blah: %s") 15  -- type error, because 15 :/: String
15:08:37 <JuanDaugherty> maerwald, i'm sure hs doesn't hold your temporary defection against you
15:08:44 <jared-w> oooh, sproingie, I meant "safe as possible" as in tried and trusted methodologies. Sort of like why using pure C is the "safe and correct" choice for the very conservative linux kernel
15:09:00 <ertes> Sylph-DS: it would also remove the need to parse a format string at run-time…  it would be parsed at compile time
15:09:05 <sproingie> not even talking about FB's haskell use, they push stuff like flow all the way down to the code monkeys
15:09:23 <jared-w> sproingie: It's different mindsets. Google isn't about code, google is about selling ads
15:09:25 <maerwald> JuanDaugherty: actually, rust is way better for system programming than haskell will ever be. It's just that mapping C frameworks properly really requires more thought.
15:09:40 <jared-w> Facebook is about using and collecting information
15:09:45 <sproingie> jared-w: yah i got it, but the bit with C is it's established.  why invent a *new* language with such awulness.
15:09:48 <ertes> facebook is definitely going in the right direction at the technology front, much more so than google
15:10:09 <jared-w> One encourages a very safe "guaranteed money" system, the other encourages a "fastest moving with least mistakes" system
15:10:17 <maerwald> let's all sign on for facebook then
15:10:31 <sproingie> it's not so much that go is backwards, it's that it's actively *hostile* to modernity
15:10:39 <JuanDaugherty> is there anything that makes using haste or ghcjs really worth the bother?
15:10:50 <sproingie> ghcjs, sure, take a look at reflex
15:10:53 <maerwald> sproingie: they could have just used D instead of inventing Go lol
15:11:02 <ertes> JuanDaugherty: with GHCJS you get almost full GHC haskell
15:11:03 <jared-w> Well, it was designed to be "C done right" and C is supposed to be portable assembly. So if you think of Go as a "portable web-friendly assembly" all the sudden, everything clicks
15:11:07 <sproingie> naw, D has way too many useful features
15:11:10 <ertes> JuanDaugherty: including concurrency!
15:11:12 <maerwald> haha
15:11:13 <JuanDaugherty> i did will revisit, ok remember now, meh thing
15:11:36 <jared-w> The problem is they made Go and then /didn't/ make a high level language on top of it, so now everyone's trying to write high level code in a primitive language...
15:11:42 <ertes> jared-w: go is not "C done right", go is "C done again"
15:11:54 * JuanDaugherty liked haste better from what I saw and it actually has better reviews but seems less active/vital
15:12:05 <jared-w> ertes: I should rephrase. Right, in this case, means "fits google's use case more exactly"
15:12:10 <sproingie> i can get structured exceptions in C with setjmp/longjmp and some macros.  not go.
15:12:22 <maerwald> HDD (hype-driven development), that's it
15:12:33 <jared-w> Google cares about build times, no pauses in garbage collector, etc
15:12:37 <maerwald> I think it was just invented to motivate programmers
15:12:45 <maerwald> "we have a new language, it's awesome, code faster"
15:12:48 <maerwald> - "ok!"
15:12:59 <sproingie> they failed on the GC pause front, that's for sure
15:13:22 <jared-w> I thought their pause times were excellent? Isn't that why that one company switched from Haskell to Go?
15:13:30 <ertes> jared-w: right, and i suppose going with rust would not fit google's business model, because they can't just slap a "made by google!!!!!" on its cover
15:13:42 <sproingie> haskell isn't exactly the shining star of gc times, no
15:13:50 <ertes> go is a marketing project more than a programming language
15:14:06 <maerwald> ertes: I don't know why anyone would want to write web crap in rust, but I mean... people do it in javascript too (which is basically assembly)
15:14:07 <jared-w> Well Rust is designed for something entirely different. Rust is "let's make a system programming language that's 100% memory safe"
15:14:12 <jared-w> everything else Rust can do is coincidential
15:14:34 <maerwald> at least they did error handling right
15:14:36 <ertes> maerwald: i would consider go to be a level below rust in terms of abstraction
15:14:51 <jared-w> Go is "let's make the assembly language backbone for google's code infrastructure that fits our usage, needs, and wants"
15:15:08 <jared-w> everything else Go can do is also coincidential :p
15:15:21 <sproingie> i can't blame google so much as the culture boosting it
15:15:21 <jared-w> (the list of things Rust can coincidentially do is far higher than the list of things Go can do...)
15:15:35 <maerwald> in haskell I can have Either, but I can still have random unchecked exceptions I will never know of
15:15:45 <maerwald> or I just catch them all and break the RTS
15:15:46 <jared-w> sproingie: idk, to me, the culture comes from google... But yeah, it really feels like a huge culture problem to me
15:16:03 <pikajude> does pipes have a convenience function for \ foo -> forever (await >>= foo)
15:16:47 <maerwald> ertes: not sure about that. Traits are surely nice, but
15:17:17 <sproingie> anyway, a haskell project skeleton with out-of-the-box support for the basics like monitoring and metrics, that would be a gas
15:17:46 <maerwald> ertes: unless you consider the macro system a good method for abstraction, lol
15:18:28 * maerwald sees weird TH code in his dreams
15:18:41 * maerwald writes an RFC to ban TH
15:18:46 * sproingie sees TH errors in his nightmares
15:19:10 <torstein_> Say I'm doing a long, pure calculation resulting in Either String Result. The calculation may fail at multiple points, but only succeed at the end. Using Either seems a bit awkward since combining Rights will never happen in practice. Is there anything better?
15:19:11 <maerwald> oh how I like swift: macros? f* o*
15:19:39 <maerwald> but then again, the rest of the language is boring
15:20:07 <sproingie> more innovative than go anyway
15:20:42 <ertes> maerwald: anything with parametric polymorphism is one level above go
15:20:50 <ertes> even the most basic form of it
15:20:50 <Rembane> torstein_: How is the combining of the rights awkward?
15:21:09 <sproingie> you mean if you have a single Right then that'll be what's returned?
15:21:15 <sproingie> possible you want an Alternative instance
15:21:49 <ertes> torstein_: instance Monad (Either e)
15:22:09 <sproingie> if you never need to combine, you don't need a monad
15:22:10 <ertes> > do x <- Right 5; y <- Right 7; z <- Right 11; pure (x + y + z)
15:22:12 <lambdabot>  Right 23
15:22:47 <ertes> "the calculation may fail at multiple points"
15:22:48 <torstein_> Yes there will only ever be one successful Right, so combining is not necessary. If the computation fails it should short-circuit. 
15:22:54 <EvanR> at each point that it could fail, you combine the "pure" calculation with the Either monad instance
15:23:14 <EvanR> if theres 3, then youll have 3 >>='s
15:23:24 <ertes> torstein_: then what do you mean by "can fail at multiple points"?
15:23:25 <EvanR> the rest is outside the Either monad and Right wraps the whole thing
15:23:30 <sproingie> i suppose you could use ContT to explicitly short-circuit.  dangerous ground to tread tho.
15:23:44 <maerwald> ertes: interface{} :P
15:23:47 <ertes> why would you use ContT to short-circuit, if you have Either anyway?
15:24:03 <EvanR> ContT is wrong here
15:24:11 <EvanR> Either is right
15:24:15 <ertes> the Monad instance of Either does exactly that: short-circuiting
15:24:22 <sproingie> true, Left will short circuit anyway
15:24:32 <sproingie> and if you never combine Rights, then well, don't :)
15:24:39 <EvanR> you dont need to use Either at literally every step, just the specific locations it could short circuit
15:26:49 <ertes> @let isqrt n = foldr (\(s, r) go -> case compare s n of EQ -> Right r; GT -> Left "No integer square root"; LT -> go) (Left "spacetime inconsistency") . iterate (\(s, r) -> (s + 2*r + 1, r + 1)) (0, 0)
15:26:50 <lambdabot>  .L.hs:177:9: error:
15:26:50 <lambdabot>      • Couldn't match expected type ‘a -> t0 (a1, b)’
15:26:50 <lambdabot>                    with actual type ‘[(Integer, Integer)]’
15:27:11 <ertes> @let isqrt n = foldr (\(s, r) go -> case compare s n of EQ -> Right r; GT -> Left "No integer square root"; LT -> go) (Left "spacetime inconsistency") (iterate (\(s, r) -> (s + 2*r + 1, r + 1)) (0, 0))
15:27:13 <lambdabot>  Defined.
15:27:20 <ertes> > isqrt 16
15:27:22 <lambdabot>  Right 4
15:27:24 <ertes> > isqrt 16 >>= isqrt
15:27:26 <lambdabot>  Right 2
15:27:32 <ertes> > isqrt 4 >>= isqrt
15:27:34 <lambdabot>  Left "No integer square root"
15:27:43 <ertes> > isqrt 3 >>= isqrt
15:27:45 <lambdabot>  Left "No integer square root"
15:27:55 <ertes> short-circuits
15:28:27 <EvanR> i think torstein_ knows how it works, but was doubting the plan of using Rights everywhere
15:28:41 <EvanR> which i agree with
15:29:06 <torstein_> Using Rights everywhere is no good; I do checks underway to detect errors
15:29:23 <EvanR> how often?
15:29:26 <MarcelineVQ> You'll want to share your code at this point.
15:29:39 <torstein_> 2-4
15:29:44 <EvanR> heh...
15:29:46 <ertes> torstein_: what do you mean by "everywhere"?  you only use it at failure points
15:29:50 <EvanR> 2-4 megahertz? :)
15:30:07 <EvanR> lpaste code 
15:30:59 <torstein_> Yeah so a feasible solution is to use the monad instance to short-circuit the Eithers and just ignore the arguments, e.g. "err1 >>= \_ -> err2 >>= ...", though that would suggest the existence of something made for that task
15:31:03 <sproingie> there's MonadError if you're not inclined to hardwire it to Either
15:31:10 <ertes> torstein_: do let …; x <- Right (failurePoint1 …); let …; y <- Right (failurePoint2 x …); …; pure (finalResult x y …)
15:31:44 <ertes> torstein_: there is also the Last monoid
15:31:54 <ertes> no, scratch that
15:32:18 <ertes> i would go with Either (or Maybe)
15:33:23 <EvanR> what on earth
15:33:23 <ertes> torstein_: think of do-blocks as Either comprehensions and use 'guard' to encode the predicates
15:33:43 <EvanR> so far we havent seen any evidence that you are doing something different from a standard Either situation
15:34:00 <EvanR> you do not need Right around every function application
15:34:07 <jared-w> lpaste the code, torstein_ :p
15:34:45 <EvanR> err1 >>= \_ -> err2 makes no sense
15:35:17 <torstein_> It's coming jared-w, gotta clean it up
15:35:23 <torstein_> http://lpaste.net/356539
15:35:24 <EvanR> youd at least do err1 >> err2 :)
15:35:31 <EvanR> and if its all like that, its a monoid not a monad
15:35:38 <ertes> @let mx <?> e = either (\_ -> Left e) Right mx
15:35:40 <lambdabot>  Defined.
15:35:50 <maerwald> in rust I just use the error-chain crate, abuse the '?' operator after every Result (equivalent of Either) type to unwrap or return from the function with the error propagated. And I get to keep the type information of all the different errors, unlike MonadThrow or so. And I know there are _no_ uncatched exceptions whatsoever.
15:35:54 <maerwald> what a bliss
15:36:11 <ertes> > do x <- isqrt 9; guard (even x) <?> "Square root is odd"; pure (3 + x)
15:36:13 <lambdabot>  error:
15:36:13 <lambdabot>      • Could not deduce (Control.Monad.Trans.Error.Error a10)
15:36:13 <lambdabot>          arising from a use of ‘guard’
15:36:53 <ertes> great…
15:37:15 <ertes> > do x <- isqrt 9; unless (even x) (Left "Square root is odd"); pure (3 + x)
15:37:17 <lambdabot>  Left "Square root is odd"
15:37:23 <ertes> > do x <- isqrt 16; unless (even x) (Left "Square root is odd"); pure (3 + x)
15:37:25 <lambdabot>  Right 7
15:37:26 <EvanR> maerwald: division by zero?
15:37:35 <ertes> torstein_: ^
15:38:20 <maerwald> EvanR: ?
15:38:40 <maerwald> I think that is just a compiler warning
15:38:43 <EvanR> in your code that has no uncatched exceptions whatsoever, what if you added a division
15:38:53 <EvanR> you get a compiler warning?
15:38:59 <maerwald> I do in my editor yes
15:39:06 <EvanR> how do you get rid of the error?
15:39:09 <EvanR> er warning
15:39:15 <maerwald> you stop dividing by zero?
15:39:41 <EvanR> a division by a variable numskull
15:40:10 <unknownln> Anyone know if there's an easy way to append two matrices in the linear library? Looking for a function `f` that'd let me do like `f (left :: V 4 (V 4 Int)) (right :: V 4 (V 4 Int)) :: V 4 (V 8 Int)`
15:40:25 <unknownln> Right now I'm just manually appending the vectors
15:40:59 <EvanR> i have a feeling that if you end up dividing by zero, your program crashes even though it has no uncaught exceptions
15:41:05 <unknownln> (As in the underlying Data.Vector vectors)
15:41:08 <EvanR> unfortunately
15:41:58 <pikajude> pipes-concurrency is so much nicer than what i was using!
15:42:01 <pikajude> too bad you have to performGC
15:42:27 <EvanR> is that how you fixed your issue earlier?
15:42:32 <torstein_> ertes: Doing everything in the Either monad is a bit awkard syntacticly because only the minority of codelines can result in Lefts. And using Eithers for points that may never succeed only fail seem a bit awkward since you have  need to define  "Right undefined"
15:42:43 <maerwald> EvanR: there are tons of ways your rust program crashes without exceptions, e.g. incomplete pattern matching
15:42:48 <pikajude> hang on, why would you use Right undefined
15:42:56 <pikajude> that seems very wrong
15:43:09 <torstein_> pikajude: err1 >> err2 >> result
15:43:12 <maerwald> but you have guarantees about _exceptions_, which you do not have in haskell
15:43:14 <ertes> torstein_: Right ()
15:43:29 <torstein_> that's better .
15:43:31 <pikajude> why would it ever be Right undefined
15:43:40 <ertes> torstein_: it's not that awkward in practice…  it's really just 'let' blocks between conditions
15:43:40 <EvanR> because haskell counts these other problems as exceptions
15:43:54 <ertes> torstein_: just try it
15:43:57 <EvanR> signals from unix are converted to exceptions
15:43:58 <maerwald> no, because GHC doesn't know whether you catched them all or not
15:44:12 <EvanR> when you use Either, you know
15:44:35 <maerwald> if you want to break everything and catch ALL of them including GHC internal stuff
15:44:36 <maerwald> do so
15:44:53 <maerwald> otherwise you rely on documentation which is mostly incomplete 
15:45:38 <EvanR> the comparison between rust's modes-of-crashing and haskell doesnt seem exactly proper
15:45:45 <maerwald> there is no such thing as "oh, it could be wraped in Either or it could be an uncatched exception" in rust. There is no exception.
15:46:01 <pikajude> uhh
15:46:03 <pikajude> except for panic
15:46:08 <maerwald> that's a different level of reasoning you cannot argue away
15:46:13 <EvanR> both crash outside your supposed plan
15:46:17 <maerwald> panics != exceptions
15:46:35 <pikajude> i actually don't know what rust exposes for async exceptions
15:46:40 <pikajude> but you really can't just ignore them
15:47:10 <EvanR> rust doesnt statically prohibit your crashing
15:47:21 <maerwald> I am talking about exceptions
15:47:24 <EvanR> or even inform you of the possibility at compile time
15:48:10 <EvanR> how many specific definitions of exceptions are we using simultaneously?
15:48:44 <maerwald> I think you are just trying very hard to like the broken exception model of GHC, which allows really no proper way to know whether you catched all relevant exceptions or not
15:48:47 <EvanR> going to bet on 2
15:48:56 <maerwald> you look at the docs and realize there are 3 missing at some point
15:48:59 <EvanR> relevant exceptions
15:49:26 <maerwald> yes, because it also exposes GHC/RTS internal stuff as exceptions
15:49:27 <EvanR> i would like to know what those are too
15:49:34 <pikajude> what do you mean by RTS internal stuff
15:49:38 <EvanR> like what?
15:49:52 <EvanR> when you catch an exception type, thats the only exceptions youll catch
15:50:17 <EvanR> are you saying internal stuff is relevant?
15:50:51 <maerwald> I am saying you never know when you catched all exceptions (for the 4th time, minus the RTS stuff you don't care about, because you cannot handle those)
15:50:53 <EvanR> also no i dont like any of these exception systems
15:51:06 <pikajude> well, you keep saying that
15:51:10 <EvanR> all exceptions?
15:51:15 <pikajude> but it still doesn't really make sense
15:51:17 <MarcelineVQ> unknownln: does linear support > V4 ?
15:51:18 <pikajude> you can catch SomeException
15:51:20 <EvanR> nevermind i dont understand what youre saying at all
15:51:23 <pikajude> and that will handle all exceptions that can be thrown
15:51:30 <maerwald> EvanR: yes, you don't
15:51:41 <EvanR> maerwald already denied the relevance of SomeExceptions
15:51:53 <MarcelineVQ> unknownln: oop I see that's not what you wrote sorry
15:52:05 <pikajude> then you catch SomeException or AsyncException
15:52:09 <maerwald> putting words into my mouth now
15:52:11 <pikajude> that will handle all possible exceptions
15:53:19 <EvanR> somehow rust redefine some crashing phenomena to exactly coincide with what you dont care about, is my current theory
15:53:48 <EvanR> which is really lucky
15:54:10 <maerwald> my theory is you don't have done rust at all, so you don't get the difference of not having exceptions at all and not being forced to catch arbitrary exception types and check where you need to catch them or if you forgot to convert them to Either somewhere
15:54:21 <codygman_> I have a list of indexes where i need to insert a delimiter into a bytestring. I'm using Char8.splitWith currently but getting poor performance. Can/should i be using bytestring builder?
15:54:29 <pikajude> how do you catch UserInterrupt in rust maerwald 
15:54:30 <EvanR> it works like C
15:54:50 <EvanR> so you have the illusion you handled everything
15:55:05 <ertes> codygman_: either that or lazy ByteString
15:55:27 <maerwald> "it works like C" can really only come from someone who has not done any rust :P
15:55:31 <ertes> codygman_: depending on your use case the latter may perform better or worse
15:56:01 <EvanR> my entire line of questioning is for the purpose of getting you to explain how it works
15:56:18 <EvanR> but now i gave up
15:56:38 <ertes> maerwald: what would be the equivalent to a monadic Either or Maybe in rust?
15:56:38 <EvanR> now we can go back to haskell ignorance
15:56:47 <maerwald> ertes: Result<T, E>
15:57:14 <ertes> maerwald: does it provide the same monadic semantics as (>>=) for Either/Maybe?
15:57:14 <maerwald> and Result is used consistently for exceptions everywhere
15:57:23 <maerwald> there are functions that do the same, yes
15:57:32 <maerwald> not operators though
15:57:42 <ertes> maerwald: are they convenient to use?  e.g. is there something like do-notation?
15:58:08 <maerwald> there is no do-notation but they are convenient to use via syntax sugar like '?' or the 'try!' or 'bail!' macros
15:58:18 <EvanR> how do you convert between different universes of E
15:58:20 <unknownln> MarcelineVQ yeah, it supports linears or arbitrary length with the `V` type and DataKinds
15:58:25 <ertes> maerwald: sounds good enough
15:58:27 <maerwald> EvanR: see error-chain crate
15:58:29 <unknownln> Err, supports vectors
15:58:31 <ertes> case closed =)
15:58:50 <MarcelineVQ> unknownln: yep thank you, playing with them atm to see if there's any leads
15:59:40 <unknownln> Awesome
15:59:59 <ertes> maerwald: and i guess since rust is strict and relies on side effects, you can get away with using that everywhere…  is that accurate?
16:00:06 <EvanR> now i see where we were supposed to be earlier, we want standard libraries and such to use Either instead of IO exceptions
16:00:11 <MarcelineVQ> of course if we use the magical words, edwardk , the answer may magically appear all on its own. especially when coupled with the question: [is there] an easy way to append two matrices in the linear library? Looking for a function `f` that'd let me do like `f (left :: V 4 (V 4 Int)) (right :: V 4 (V 4 Int)) :: V 4 (V 8 Int)`
16:00:13 <maerwald> ertes: yeah
16:00:35 <edwardk> MarcelineVQ: use Product
16:00:59 <edwardk> Product V4 V4 likely works as another vector space ;)
16:01:08 <ertes> EvanR, maerwald: then i think comparing haskell and rust is not really fair anyway…  they are just too different, and you will never find agreement
16:01:13 <edwardk> i don't remember if i went through all the trouble to make it work perfectly
16:01:44 <MarcelineVQ> edwardk: thank you for the prompt response and helpeful lead, have a look for that unknownln
16:01:49 <EvanR> the word exceptions is now overloaded, what do you call the phenomena like timeouts, signals, threadkilled
16:01:51 <ertes> i do see why rust's approach is good enough *in rust*
16:02:01 <maerwald> ertes: exactly, but since I've done a similar thing in both languages (e.g. file system operations), I can safely say it's way more annoying in haskell, just from the "reasoning" perspective about exceptions
16:02:10 <EvanR> earlier exceptions was limited to library-controlled-error-results
16:02:12 <edwardk> as for working with V 4 + V 4 -> V 8 directly, you can always pattern match and reconstruct the V constructor
16:02:16 <edwardk> and just append as vectors
16:02:25 <edwardk> but then ensuring the invariant is entirely on you
16:02:36 <ertes> maerwald: i agree…  IO exceptions are kinda awkward, and i can imagine that rust has learned from haskell's failures
16:02:46 <MarcelineVQ> neaot, sounds like they were going that route currently and were hoping it was already implemented
16:03:06 <EvanR> certain uses of exceptions in IO is annoying like *some* file operations
16:03:25 <maerwald> whether you can technically force similar behavior (if you are lucky and are not forced into huge frameworks) in haskell... I don't really care, because it's not practical
16:03:56 <EvanR> it sounds like you just want Either to be more conventional
16:03:58 <unknownln> yeah edwardk that's what the code is doing now, but as you say it puts it on me to ensure the lengths are what I say they are
16:04:11 <EvanR> not practical because no one will ever do that
16:04:26 <ertes> EvanR: try to write code that retries after a network timeout, but fails in every other case
16:04:37 <edwardk> you can of course give such a combinator a concrete type like append :: V n a -> V m a -> V (n + m) a -- but then you need to use something like Data.Constraint.Nat to generate the KnownNat instance for (n + m)
16:04:47 <maerwald> EvanR: and so we still have foo : Int -> IO() -- and have to look up the documentation in order to know what can fail there ;)
16:04:53 <EvanR> well i just went and got all the exceptions from the network module last week
16:04:54 <edwardk> unknownln: i have no objection to adding an append or appendV combinator to linear
16:05:07 <EvanR> yes theyre totally undocumnted
16:05:10 <edwardk> and giving it that type
16:05:27 <EvanR> maerwald: if anything
16:05:34 <edwardk> but you'd still need to use Data.Constraint.Nat to generate the KnownNat (n + m) instance from (KnownNat n, KnownNat m)
16:05:49 <ertes> EvanR: all the exceptions from the network module?  which ones?
16:05:54 <EvanR> yep
16:06:09 <EvanR> there are about 20
16:06:14 <edwardk> https://github.com/ekmett/constraints/blob/master/src/Data/Constraint/Nat.hs#L107
16:06:16 <EvanR> its like the holy grail
16:06:24 <maerwald> EvanR: no imagine, you have an operator that says "unwrap this value or raturn Left(Err) -- whatever type that Err is and WITHOUT losing it... and even being able to _chain_ errors and keep all their type information... without messing with the Either type?!
16:06:30 <maerwald> ok, we have that in rust already :P
16:06:31 <edwardk> that can produce the KnownNat you'd need in order to actually use that appending
16:07:01 <ertes> EvanR: and if i'm not mistaken none of them is about "timeouts", one of the most essential failures in a network scenario
16:07:12 <unknownln> I'll look into it later when I get home; I've never actually done any type level programming with DataKinds so should be interesting
16:07:13 <maerwald> like chain 3 errors of different types together and just have them propagated, get a traceback in the end and being able to pattern match on all of it... wtf, yes, I want that
16:07:13 <EvanR> there is
16:07:28 <edwardk> also the Linear.V type works with arbitrary Reifies, not KnownNat directly, so you can't concatenate _any_ such V n this way only when the kind of n is Nat.
16:07:39 <EvanR> traceback, yeah i wonder how that would work in haskell
16:07:44 <maerwald> heh
16:07:55 <EvanR> my stack of specific gripes your having is now 4 deep
16:08:07 <EvanR> tracebacks is another tangent thuogh
16:08:14 <ertes> i don't mind IO exceptions per se…  they do their job…  but the landscape of errors is completely disconnected from the real world
16:08:19 <sproingie> clearly we need a GripeT to properly define such a stack
16:08:29 <ertes> and exception documentation is also seriously lacking
16:08:46 <EvanR> 1. Either is not conventional for many libs including standard IO 2. Either with different error universes is not composable really
16:08:50 <unknownln> Alright. I guess that's different from stuff like vector-matrix multiplication since in that case it just takes the output size type from one of the inputs?
16:08:51 <maerwald> ertes: I test exceptions in my packages and document all of them :P
16:08:55 <ertes> i found myself unwrapping IOError to get at errno values that might not even be there in the first place, just to tell certain failures from others
16:08:58 <EvanR> 1.41 documentation
16:08:58 <maerwald> it looks weird though
16:09:31 <maerwald> I don't even know why I did that... like, testing exceptions, why would you even do that. But it felt right.
16:09:33 <EvanR> ertes: also, you probably want to introduce your own timeout at the same time!
16:10:19 <ertes> EvanR: while that one is actually easy enough (System.Timeout + -threaded), why would you do that?  you would set the desired timeout on the socket in the first place =)
16:10:55 <EvanR> set a timeout on the socket?
16:11:00 <EvanR> what universe are oyu in
16:11:13 <unknownln> Thanks edwardk!
16:11:14 <sproingie> timeout on a socket only covers things like connect
16:11:43 <ertes> EvanR: https://hackage.haskell.org/package/network-2.6.3.2/docs/Network-Socket.html#g:9
16:11:55 <ertes> see e.g. RecvTimeOut and SendTimeOut
16:12:22 <EvanR> OS specific features i guess
16:12:30 <ertes> sproingie: hmm?  does it?
16:12:37 <Geraldus> @type map
16:12:39 <lambdabot> (a -> b) -> [a] -> [b]
16:12:52 <ertes> at least RecvTimeOut should cover actual receiving
16:13:22 <EvanR> i would rather apply System.Timeout than mess with that stuff
16:13:25 <Geraldus> @pl dec t = join $ readMaybe . T.unpack <$> look t
16:13:25 <lambdabot> dec = join . (readMaybe . T.unpack <$>) . look
16:13:36 <EvanR> just give me a "perfect" socket and ill mess with it externally
16:13:44 <maerwald> EvanR: however, if you are writing "unsafe" code in rust (you have to if you interface with C libs etc.)... you get even LESS guarantees than you would in equivalent C code. That is so confusing. Your whole stack explodes and your return address is overwritten by a type transformation and rust doesn't care. I don't have those problems in haskell :P
16:13:52 <maerwald> calling C stuff is actually not that hard in haskell
16:13:56 <sproingie> oh right, the connect timeout stuff is for nonblocking, that's a different thing
16:14:18 <ertes> EvanR: me too, actually
16:14:34 <EvanR> reacting to the other ends decision to time you out or not, thats something you need to deal with
16:14:41 <Geraldus> @pl dec t = readMaybe =<< T.unpack <$> look t
16:14:41 <lambdabot> dec = (readMaybe =<<) . (T.unpack <$>) . look
16:14:45 <EvanR> and theres an exception for that!
16:15:42 <mniip> Huh, whoever said they had no problems with the hott book whilst knowing "zilch" about topology...
16:15:48 <EvanR> exceptional is probably the wrong name for all these things that could happen doing networking
16:15:56 <mniip> ...I got stuck on page 2
16:16:07 <EvanR> page 2 probably mentions fibrations
16:16:32 * ertes still hasn't read all of the HoTT book
16:16:48 <EvanR> thats a sticky bit youll need to reverse engineer from wolfram
16:17:10 <EvanR> literally because the hott book considers them in reverse
16:17:14 <sproingie> mniip: that was me.  it didn't take me long to run into some weird terminology.  it doesn't go that deep into it for a while
16:17:21 <ertes> BTW, i have found a proof assistant that i seem to like so far, but haven't done anything deep with it yet: lean
16:17:28 <ertes> lean2 even supports HoTT
16:17:42 <mniip> Sp
16:17:47 <jared-w> oooh HoTT
16:17:55 <jared-w> so hot right now  (☞ﾟヮﾟ)☞
16:18:04 <EvanR> no thats cubical
16:18:23 <ertes> (i'll probably go with lean3 and classical type theory though)
16:18:32 <MP2E> been meaning to read that book at some point :)
16:18:49 <jared-w> what's the difference between lean, lean2, lean3?
16:18:58 <ertes> ((that sounds weird, doesn't it?  "classical" and "type theory" are kinda contradictory)) =)
16:19:26 <ertes> jared-w: good question…  i always go with the newer stuff =)
16:19:28 <mniip> sproingie, when they started bombarding with "homotopy", " homology" and "infty-groupoids", is when I went from "I understand" to "uh, I guess, if you say so"
16:19:45 <EvanR> homotopy is kind of important
16:19:48 <EvanR> in that book :)
16:19:57 <EvanR> no homology though
16:20:03 <ertes> mniip: all the infinity-groupoid stuff is kinda: "just go with it"
16:20:11 <mniip> Ehh
16:20:18 <mniip> Doesn't sound rigid
16:20:23 <EvanR> inf-groupoid isnt hard
16:20:27 <ertes> it isn't rigid
16:20:32 <ertes> at least that's my understanding
16:20:41 <mniip> I came for rigid formalization of foundations of mathematics
16:20:50 <lambdamu_> As far as I know there isn't a agreed upon definition of (weak) infinity groupoid
16:21:06 <lambdamu_> So that certainly isn't rigid (yet)
16:21:37 <EvanR> mniip: theres not 1 thing in the book, theres at least 3 unrelated things going on: homotopy type theory, higher inductive types, and "what happens if you use one or more of these axioms"
16:21:47 <mniip> Damn. Does math even exist
16:21:53 <ertes> mniip: everything is fine, if your infinity-groupoids are…  what's it called when at a finite morphism level it collapses into all-refls?
16:21:53 <EvanR> the foundation part uses all of the above at once
16:22:19 <EvanR> without a single framework to explain it all
16:22:28 <EvanR> because HITs doesnt have one, in the book
16:22:34 <mniip> Can I read that book if I don't know what a homotopy is?
16:22:48 <Welkin> homotopy type theory?
16:22:49 <lambdamu_> The point of the HOTT book is explicitly informal use of homotopy type theory not foundational in the classical sense
16:23:00 <EvanR> no because ill tell you right now, its a continuous function from the interval to paths in a space
16:23:13 <ertes> i'll just call it "finite-dimensional" for now
16:23:24 <mniip> What's a continuous function
16:23:34 <mniip> (Outside of calculus)
16:24:01 <mniip> What's a space
16:24:01 <EvanR> one answer is from topology
16:24:14 <mniip> But I don't know topology
16:24:19 <EvanR> the other answer is "any function in this formalism is continuous by definition"
16:24:53 <EvanR> in the book, a space is a type
16:25:04 <ertes> and "continuous" in that context usually means "computable"
16:25:04 <EvanR> any type in this formalism is a space
16:25:42 <Welkin> a continuous function can be thought of a function that is defined for all inputs, right>
16:25:45 <Welkin> ?
16:26:04 <jared-w> Depends
16:26:16 <sproingie> that's a total function
16:26:19 <EvanR> a hard ass would say if its not defined somewhere its not really a function
16:26:25 <ertes> Welkin: not just defined, but computable/decidable…  a computer can actually "run" it
16:27:09 <jared-w> if we're going for the standard algebra-you-learned-in-high-school answer, then yeah, a continuous function is f : R -> R for some power of R :p
16:27:35 <EvanR> in high school many f : R -> R are not continuous
16:27:48 <Welkin> hyperbolic functions, lol
16:27:53 <jared-w> right... I went too handwavy with that
16:27:56 <jared-w> m'bad
16:28:29 <ertes> the idea is: continuity in topology is defined by certain laws, and computability satisfies those laws with a certain topology
16:28:35 <EvanR> in the hott book, a discontinuous function from R to R would give you the limited principle of omniscience
16:29:19 <EvanR> or, a non constant function from R to Bool
16:29:28 <sproingie> continuous function is when an infinitesimal change to the input results in infinitesimal change to the output
16:29:47 <sproingie> the Batman Curve would be a discontinuous function :)
16:29:50 <ertes> sproingie: that's a special case that doesn't apply (or even make sense) here
16:31:33 <jared-w> Isn't it not even a real function?
16:31:41 <mniip> sproingie, I'm not willing to handwave that definition by analogy
16:33:34 <EvanR> when you keep following "what continuity is" backward, you end up at the functor laws
16:33:53 <EvanR> whatever you care about is preserved by the function/functor
16:33:56 <sproingie> not turtles?
16:34:20 <EvanR> what you care about is encoded in topology by the chosen topology
16:35:15 <EvanR> what you care about in category theory is encoded by the chosen source and destination categories
16:35:25 <unknownln> sproingie: it's Functors all the way down
16:35:54 <EvanR> what you care about in type theory is encoded by the induction principle for your source type
16:37:07 <EvanR> in hott what you care about is the preservation of equality
16:37:23 <EvanR> f(3/4) = f(6/8)
16:37:35 <EvanR> in the destination
16:37:53 <EvanR> and you care about the preservation of higher equalities
16:47:50 <EvanR> mniip anyway you dont really need that to grok a homotopy, just imagine a path smoothly moving from somewhere in a space to somewhere else without breaking
16:51:09 <jared-w> dumb question, what's the difference between a Sum type and a Union type?
16:52:25 <davean> a union doesn't store multiple values, but maybe you mean product?
16:53:13 <jared-w> No I meant union type. I saw a few examples where Union and Sum was used interchangeably and then a comment where someone said that was incorrect and they were not interchangeable
16:53:16 <EvanR> a union type connotes a type system based on set theory
16:53:31 <EvanR> so the whole universe of types is a set
16:53:50 <EvanR> and then Number and String are two disjoint subsets of this set
16:54:07 <EvanR> Number | String is the union of the subsets
16:54:12 <EvanR> and is a valid type
16:54:51 <EvanR> a function expecting Number | String accepts numbers... or strings
16:55:01 <jared-w> gotcha. And the different from Sum types mostly arises from a set theory based type system vs a non set theory based type system?
16:55:13 <EvanR> sum corresponds to discriminated union
16:55:23 <EvanR> so its tagged
16:55:31 <jared-w> ahh, okay
16:55:41 <hpc> would a concise way of phrasing it be, Union Int Int = Int, Either Int Int /= Int?
16:55:42 <EvanR> String | String isnt different from String
16:55:52 <EvanR> String + String is
16:56:23 <jared-w> that makes more sense
16:56:55 <lambdamu_> sum type = disjoint union
16:57:14 <jared-w> It was confusing me for a sec because sum type's logical equivalent is or under the CH correspondence
16:57:30 <EvanR> but haskells type system really isnt like set theory at all so union doesnt really make sense
16:57:33 <jared-w> and people were typing out union types as | which is hardwired in my brain as an "or"
16:58:29 <EvanR> it barely makes sense in javascript or whatever thing people want unions in
16:58:51 <ertes> jared-w: |{1,2} ∨ {2,3}| = 3; |{1,2} + {2,3}| = 4
16:59:25 <lambdamu_> They are neat in C, but I usually throw a tag in, so theres the sum again
16:59:27 <EvanR> V is disjunction not union!
17:00:10 <jared-w> yeah, can't really see non tagged unions making sense...
17:00:12 <ertes> i didn't want to look up how to type the union symbol, so i just used the closest thing =)
17:00:20 <jared-w> U <-- what's this then? :p
17:00:24 <EvanR> union
17:00:33 <ertes> jared-w: they do make sense in set theory, and you can establish them in type theory, but it takes some effort
17:00:52 <jared-w> ertes: well sure, of course they make sense as they're mathematically sound and you do want them
17:00:55 <EvanR> yes if you develop a set theory inside type theory
17:00:59 <ertes> jared-w: unions in type theory aren't unions of *types*, but unions of *predicates*
17:01:16 <jared-w> I meant more "I can't see why you would use them in programming in prefference to sum types"
17:01:19 <ertes> Even : ℕ → Type
17:01:25 <ertes> Odd : ℕ → Type
17:01:47 <ertes> Union : (a → Type) → (a → Type) → a → Type
17:01:50 <jared-w> You couldn't figure out how to type the union symbol but you got the Nat symbol and unicode arrows? lol
17:02:00 <ertes> i have those xmodmapped =)
17:02:10 <jared-w> Fair enoough :) I need to do that too
17:02:31 * EvanR xmodmapps all math operators that are pretty much identical to regular letters like V and U
17:03:54 <ertes> this is kinda "set theory embedded in type theory", but it's not quite the same
17:04:19 <ertes> especially if by "set theory" you mean ZFC
17:04:33 <jared-w> Intersection types look pretty neat though
17:04:42 <EvanR> a union is a thing between subsets (of the same global set)
17:05:10 <ertes> jared-w: Union P Q x = Either (P x) (Q x); Intersection P Q x = (P x, Q x)
17:05:20 <EvanR> if you want to make sums into unions you need a way to know when two elements of the sum are equal
17:05:21 <jared-w> although I'm thinking intersection types are the set equivalent of product types for type theory?
17:05:43 <EvanR> no
17:05:50 <ertes> jared-w: no, product types send two types to the cartesian product type
17:06:03 <jared-w> ahh okay. Probably should've read past the first paragraph before guessing
17:06:28 <ertes> intersections send two predicates to the logical "and", which just happens to be the cartesian product of both predicates applied to the element in question
17:06:49 <ertes> remember: unions and intersections operate on predicates
17:07:48 <EvanR> this usage of union and intersection is not very set like
17:07:56 <EvanR> its not an operation on subsets
17:08:08 <EvanR> youre just forming the disjunction and conjunction
17:08:12 <ertes> EvanR: a predicate can be interpreted as a subset
17:08:23 <ertes> the main difference is that you need to be explicit about the universe
17:08:27 <EvanR> you did it wrong
17:08:30 <ertes> you will always have subsets of *something*
17:08:45 <EvanR> since the result of union isnt in the same set as the subsets were
17:08:59 <EvanR> if you care about that, you end up with type theory
17:09:07 <ertes> i don't understand
17:09:22 <EvanR> Either A B is really a different kind of set from A or B
17:09:42 <ertes> i don't think i have used Either like that
17:10:05 <ertes> example:
17:10:21 <ertes> OneTwo : ℕ → Type  -- corresponds to {1, 2}
17:10:27 <ertes> TwoThree : ℕ → Type  -- corresponds to {2, 3}
17:10:40 <ertes> Union OneTwo TwoThree : ℕ → Type  -- corresponds to {1, 2, 3}
17:11:02 <jollygood2> why does x / 2 give me No instance for (Fractional Int) arising from a use of `/'?
17:11:24 <colonelj> x / 2.0
17:11:40 <ertes> jollygood2: you need to convert to a fractional type, if you want to use (/)
17:11:40 <EvanR> man thats out of my league, treating (N -> Type) as a type of its own
17:12:08 <EvanR> \t -> Either (P t) (Q t) being an element of its own
17:12:14 <EvanR> with a "family of types" type
17:12:15 <ertes> jollygood2: there are also 'div' and 'quot', which are integer division, which you can do on Int
17:12:45 <jollygood2> thanks, div is what i wanted
17:12:51 <ertes> EvanR: (ℕ → Type) is the type of predicates on natural numbers…  you have probably seen it a million times
17:12:52 <geekosaur> jollygood2, I would expect that to work as written, actually
17:13:06 <jollygood2> geekosaur me too
17:13:08 <geekosaur> however if 2 has been constrianed to Int then it won't
17:13:27 <jollygood2> x is int
17:13:28 <jollygood2> Int
17:13:36 <geekosaur> oh, yes, that would do it too
17:13:37 <EvanR> im checking out instead of hand waving higher types at this point
17:13:55 <geekosaur> (/) requires Fractional constraint, Int doesn't have it
17:14:04 <ertes> EvanR: example (not any particular language):  data Even : ℕ → Type where EvenZ : Even 0; EvenSS : Even n → Even (S (S n))
17:14:13 <colonelj> ertes: in the language I'm designing sets of numbers are basically first class
17:14:35 <EvanR> finite sets?
17:14:37 <ertes> EvanR: you can encode elements of that type using Sigma
17:14:42 <colonelj> either finite or infinite
17:14:51 <ertes> EvanR: Sigma ℕ Even  -- the type of even natural numbers
17:14:52 <EvanR> subfinite ? :)
17:15:00 <colonelj> I don't even know what that is
17:15:03 <EvanR> hehe
17:15:17 <EvanR> ertes: yes, sigma is what i would identify as the subset type
17:15:30 <jollygood2> colonelj x / 2.0 did not work either
17:15:31 <EvanR> global type, predicate
17:15:51 <colonelj> jollygood2: (fromInteger x) / 2.0
17:15:58 <ertes> EvanR: Sigma makes a "subset"/"predicate" a concrete type that has values of the particular subset, but in order to operate on the subsets themselves you need the actual predicates
17:16:19 <EvanR> N -> Type though isnt what im calling "a subset type"
17:16:31 <colonelj> isn't that a partial function?
17:16:38 <EvanR> (x:N, P(x)) yes
17:16:41 <ertes> EvanR: consider it a "subset constructor", if you want =)
17:17:20 <ertes> i believe you can define the entirety of ZF in terms of these predicate types
17:17:43 <EvanR> you have a perfectly valid axiom of choice too :)
17:17:51 <colonelj> my language has refinement types so you can just write ?(2 % 0 =)
17:18:17 <ertes> EvanR: i don't think so, unless you require that each predicate is also decidable
17:18:24 <EvanR> (t:Type, t) -> Pi[t:Type] -> t
17:18:38 <jollygood2> thanks
17:18:47 <EvanR> er thats not exactly right
17:18:56 <jollygood2> there is fst, snd, is there trd?
17:19:23 <EvanR> ertes: see type theoretic axiom of choice
17:19:24 <colonelj> jollygood2: fst and snd are for pairs only
17:20:11 <jollygood2> this doesn't seem to work? (\(_,_,x) -> x)
17:20:32 <colonelj> it should work
17:20:43 <ertes> EvanR: i think you're referring to an axiom of choice for *types*
17:21:29 <ertes> EvanR: i have trouble imagining an axiom of choice for types that isn't just the identity function =)
17:21:35 <EvanR> (Pi[x:A] Sig[y:B] R(x,y)) -> (Sig[f:A->B] Pi[x:A] R(x,f(x)))
17:21:36 <jollygood2> you're right, i had error elsewhere
17:21:55 <EvanR> R : A -> B -> Type
17:22:17 <ertes> i need to rewrite that to more familiar syntax
17:23:20 <ertes> ((x : A) → Sigma B (R x)) → Sigma (A → B) (λ f → (x : A) → R x (f x))
17:23:42 <mniip> EvanR: handwaving
17:23:48 <EvanR> if you have an inhabited type B then you can have a function from A to B satisfying any property 
17:24:38 <EvanR> the proof is trivial but not the identity function
17:25:07 <EvanR> i think martin lof established this way back when
17:25:17 <EvanR> its a proof not an axiom in this context
17:26:08 <jared-w> Just out of curiosity, EvanR, what syntax do you use when you're writing stuff like that out?
17:26:46 <EvanR> bastardized dependent type syntax
17:27:17 <EvanR> its shorter than idris longer than agda
17:27:24 <jared-w> ahh gotcha
17:27:35 <ertes> shorter than idris, longer than agda?  is that even possible?
17:27:48 <ertes> let me spell this out in agda…
17:28:29 <jared-w> totally not surprised you use agda, ertes. I think it's the unicode :p
17:28:37 <EvanR> my use of parentheses might even make is shorter than agda, if you replace pi and sigma with one greek letter
17:28:49 <ertes> ∀ {a b r} {A : Set a} {B : Set b} {R : A → B → Set r} → (∀ x → Sigma B (R x)) → Sigma (A → B) (λ f → ∀ x → R x (f x))
17:28:59 <ertes> this is the shortest way i can think of to write it in agda =)
17:29:01 <EvanR> you can totally use sigma in agda
17:29:22 <EvanR> and screw universes
17:29:40 <ertes> jared-w: i'm actually trying to find an alternative to agda…  lean looks promising
17:29:53 <ertes> except for the amazing emacs mode agda is not nice to work with
17:30:01 <jared-w> What's wrong with agda?
17:31:10 <ertes> jared-w: agda wants you to spell out…  *everything*
17:31:14 <ertes> every tiny detail
17:31:23 <EvanR> it has implicits but you can never omit them
17:31:34 <EvanR> defeating the purpose!
17:31:37 <jared-w> Right... Absolutely zero inference or anything useful. Gotcha, that would be a pain in the ass
17:32:12 <ertes> jared-w: try to define functors in agda, and you will have six universe variables, and even though you could make them implicit, agda practically forces you to make them explicit anyway, because it gets confused later on when you want to actually *use* functors
17:32:35 <EvanR> when you state the functor law, F(f . g) = F(f) . F(g), the requires almost of page of explaining what is implicitly going on
17:32:51 <EvanR> well it gets to be a page when you do natural transformations
17:33:14 <ertes> jared-w: or try to use equational reasoning with arithmetic properties…  rearranging parentheses in an equation using 'assoc' is a kind of pleasure you won't get in any BDSM studio
17:33:27 <EvanR> in some sense, that is pretty cool because all the implicit stuff is what makes math inscrutible i think
17:34:18 <EvanR> ertes: rearrangement of parens is like... the entirely of proofs in category theory :)
17:34:27 <EvanR> entirety
17:34:54 <ertes> jared-w: note that this is something ARITH in HOL light can figure out on its own *completely*
17:35:28 <ertes> pages long equational reasoning that you need to do in painful detail could be done automatically
17:35:42 <EvanR> what if computeres were so smart they give the answer "trivial" to all questions :)
17:36:06 <jared-w> right, and the inability of Agda to do so is basically either an ill thought out design choice since all of that busy work can be done by computers, I'm guessing?
17:36:44 <EvanR> to be fair, implementing type theory is a different project from making artificial intelligence to do type theory for you
17:36:58 <ReinH> If you want a tactics-based solver, why are you using Agda?
17:37:15 <jared-w> but muh unicode...
17:37:30 <ertes> jared-w: i think agda's goals are just different…  i wouldn't call agda a practical proof assistant, but more of an idealised dependently typed logic to experiment with
17:38:46 <EvanR> its interesting that its dependent pattern matching feature causes non trivial interactions with the idealized type theory
17:39:00 <EvanR> that gives you extra power 
17:39:09 <EvanR> beyond what you were trying to have
17:39:22 <jared-w> really? That's interesting
17:39:38 <EvanR> yes, its possible to prove extra stuff, not necessarily what you wanted to
17:40:00 <jared-w> ertes: that's fair. I can appreciate idealized environments. It would be nice if it was idealized but also tried to have some inference and automation as well
17:40:17 <EvanR> it does have some inference and automation
17:40:19 <jared-w> One of the most appealing things to me about richer type systems is how much heavy lifting the language can do /for/ me
17:40:22 <EvanR> the emacs mode 
17:40:32 <ertes> jared-w: they're trying (for example it has something similar to type classes now), but it's not good enough
17:40:42 <jared-w> But you still have to write out pages of manual and tedious proofs for things that should be automatic
17:40:57 <EvanR> it lets you use implicit dependent records like type classes
17:41:24 <ertes> the main difference is that these days you can write 'assoc' instead of 'ℕ+-assoc' and 'ℤ*-assoc' =)
17:41:28 <EvanR> the fact that you can control it like that makes it less automatic than haskell
17:41:40 <jared-w> that's interesting. I don't know enough about it to have an opinion on those but it's an intriguing concept to me
17:42:06 <EvanR> haskell only allows 1 instance per type, so a lot can be automated
17:42:20 <ertes> i once tried to use the inference mechanism to infer algebraic rewrites, so you could just say "arith", and it would figure out the necessary rearrangements using assoc, comm, distrib, etc.
17:42:21 <ertes> but i failed
17:42:53 <ertes> agda is something worth learning, but not really worth using in practice
17:43:04 <jared-w> Seems like it
17:43:08 <jollygood2> what about idris?
17:43:14 <jared-w> Has the language not been updated since 2014?
17:43:14 <EvanR> not a theorem prover
17:43:30 <jared-w> jollygood2: Idris tries to be a "general purpose language that has dependent types"
17:43:44 <EvanR> they deleted their tactics that they had
17:43:51 <ertes> jollygood2: idris, beside not being a consistent logic, is also not much of a proof assistant…  consider it a programming language rather than proof assistant
17:43:52 <jollygood2> jared-w and did it succeed?
17:43:55 <EvanR> that were mostly undocumented
17:44:05 <jared-w> So I think Idris is the one to watch. Often, being forced to come up with highly economic and efficient ways of going about things allows for the more elegant solution to come to light
17:44:31 <ertes> i don't think idris will become a proper proof assistant any time soon…  that's not its focus
17:44:51 <EvanR> now idris is even better than tactics, you can program your own tactics with elab reflection!
17:44:54 <jollygood2> i mean did it succeed in being a general purpose language with dependent types
17:44:54 <jared-w> jollygood2: so far, so good. It's not got the following and community that Haskell has, but I wouldn't say it's terrible to program in. I'd say it has largely succeeded in its initial goals
17:45:34 <EvanR> jollygood2: its a research thing entirely, it will never succeed, according to edwinb
17:45:37 <ertes> jollygood2: it's still on its way…  there are economical reasons not to use it, but the technology is quite elegant
17:45:53 <jared-w> So far there are two main choices to make when creating dependent typed languages: a) give up the idea of turing completness and become a proof assistant. b) give up the idea of a sound type system and gain turing completness
17:46:11 <ertes> not sure whether/when it will get there, but i'm pretty sure you will be using haskell in the next few years
17:46:14 <EvanR> the type system in idris is supposed to be sound
17:46:18 <EvanR> modulo bugs
17:46:22 <ertes> unless you want to become an early adopter
17:46:30 <jared-w> Idris, Haskell, etc., are all chosing option b. Agda chose option a. That makes agda mostly useless for "real world programming" but, Agda isn't trying to be a language, it's a proof assistant
17:46:42 <EvanR> idris isnt unsound like haskell
17:47:14 <ertes> i think agda is not really a proof assistant…  it's really just a logic with an automatic type checker =)
17:47:21 <jared-w> hmm... I don't think I meant "sound", but there's some other tradeoff that Idris made in order to be turing complete and not total like Agda is
17:47:37 <EvanR> it is total if you want it to be
17:47:46 <EvanR> you need to explicitly disable totality
17:47:51 <jollygood2> the thing I mind about haskell, that I assume idris improves, is incomplete functions. head crashing instead of returning Maybe a. does idris force you to make head return Maybe a or similar?
17:48:14 <EvanR> no, not Maybe
17:48:24 <ertes> jollygood2: you can choose to mark functions as total, but the totality checker is not very sophisticated
17:48:28 <EvanR> head head : (l : List a) -> {auto ok : NonEmpty l} -> a
17:48:33 <EvanR> head : (l : List a) -> {auto ok : NonEmpty l} -> a
17:48:42 <jared-w> Checking if a function is incomplete means you also need to verify that it's total
17:48:48 <jared-w> Which is basically equivalent to the halting problem
17:48:49 <ertes> jollygood2: you might have a hard time convincing idris that your function is actually total
17:49:04 <Axman6> to be fair, we have good tools to avoid writing that sort of code, and it doesn't take long to find out which prelude functions are dangerous (and almost all of them are better written with explicit pattern matching or a catamorphism anyway)
17:49:14 <EvanR> you might have to do crazy contortions to convince your code is total, just like agda
17:49:29 <ertes> yeah, i don't think totality bugs are really that problematic
17:49:43 <jared-w> Honestly, I've never seen it come up
17:50:02 <jared-w> The only reason it seems like such a big deal is there's a few "big" partial functions in the prelude
17:50:03 <ertes> it only matters if you want to have proofs along with regular program code
17:50:20 <EvanR> when i use head in haskell, it almost always ends up crashing :)
17:50:31 <shadowdao> lol
17:50:35 <EvanR> because thats the one thing in my code that can, and murphys law
17:50:54 <jared-w> So beginners write `head lst` and then get runtime errors if the list is empty and freak out because the language "isn't supposed to have runtime errors"
17:51:11 <ertes> 'head' also means that you really need to go to the boolean oculist
17:51:22 <ertes> you might have caught boolean blindness
17:51:52 <jared-w> If we just junked all of the partial functions in the prelude and replaced them with total functions, people would probably never ever really think  partial vs total was this big deal again ¯\_(ツ)_/¯
17:52:12 <EvanR> head and division dont have good total versions in haskell
17:52:47 <EvanR> division doesnt have a good totally version at all :)
17:52:55 <ertes> recip :: (Fractional a) => a -> Maybe a
17:53:09 <EvanR> Maybe is crap 
17:53:11 <jared-w> > 5 recip 10
17:53:13 <lambdabot>  error:
17:53:13 <lambdabot>      • Could not deduce (Fractional a0)
17:53:13 <lambdabot>        from the context: (Num ((a -> a) -> t -> t1), Num t, Fractional a)
17:53:19 <jared-w> wew nice talk
17:53:28 <jared-w> > 5.0 recip 10.0
17:53:30 <lambdabot>  error:
17:53:30 <lambdabot>      • Could not deduce (Fractional t0)
17:53:30 <lambdabot>        from the context: (Fractional ((a -> a) -> t -> t1),
17:53:32 <EvanR> recip is unary
17:53:39 <jared-w> oh, durr
17:53:40 <lambdamu_> It's also nice how "Prelude.head: empty list" gives no indication where the head in question was called, that is kind of embarassing
17:53:43 <ertes> > recip 3 :: Rational
17:53:45 <lambdabot>  1 % 3
17:54:06 <jollygood2> does idris refuse to compile if you have incomplete pattern matches? and does it have anything like undefine/error?
17:54:08 <jared-w> lambdamu_: I blame that on terrible eerror messages in haskell in general :p
17:54:16 <EvanR> jollygood2: yes, no
17:54:34 <EvanR> instead of undefined or error you put a hole, ?foo
17:54:37 <jollygood2> so you couldn't write a reasonable head :: [a] -> a in idris. 
17:54:42 <lambdamu_> jared-w: It's just stupid if you pattern match you get a source location
17:54:45 <ertes> _foo
17:54:52 <ertes> ah, in idris
17:54:54 <EvanR> jollygood2: this is head in idris head : (l : List a) -> {auto ok : NonEmpty l} -> a
17:55:13 <EvanR> head (x :: _) = x
17:55:20 <EvanR> then it doesnt complain
17:55:59 <jared-w> Anyway, I was gonna ask. Why is Maybe crap?
17:56:05 <EvanR> (:: there is cons, not has type)
17:56:21 <jollygood2> so it has different type for a list that can be empty and lists that need to have at least one element?
17:56:35 <jollygood2> or is this when dependent typing kicks in
17:56:53 <EvanR> jared-w: if already know zero is not possible, you would do a runtime check to see if something that is impossible occurs, then have to do something in the impossible case which has no good course of action
17:56:53 <jollygood2> (should probably ask in idris channel not in here)
17:57:17 <EvanR> jollygood2: no same list type, you have to have evidence its not empty though
17:57:26 <EvanR> yes dependent types
17:57:26 <jared-w> The overlap is so large you're  probably talking to the same people anyway /s
17:57:42 <jared-w> overlap in the idris/haskell communities*
17:57:54 <jollygood2> yeah
17:58:10 <glguy> Whether or not that's true, this is the wrong channel for Idris discussion
17:58:11 <EvanR> NonEmpty is a predicate not a data type
17:58:33 <jared-w> glguy: we're talking about how Maybe sucks, though
17:58:42 <EvanR> glguy is right
17:59:00 <EvanR> however we could become right if we talk about dependent haskell!
17:59:13 <jared-w> wooo! *boards DH hype train*
17:59:20 <EvanR> all aboard
17:59:25 <jared-w> new topic: DH vs Idris /s
18:00:32 <jared-w> Also, I didn't quite follow why you would do a runtime check to see if something that is impossible occurs, or why that means Maybe is crap
18:00:45 <EvanR> jared-w: that is what returning Maybe from recip would do
18:01:00 <jared-w> oh right, because of needing to pattern match
18:01:02 <EvanR> if your algorithm would never do recip on a zero
18:01:14 <EvanR> what are you supposed to do with Nothing
18:01:25 <jared-w> er, case match or pattern match? I think I used the wrong terminology there
18:02:12 <jared-w> EvanR: true, Maybe is a nonsensical option in the case of division
18:02:12 <EvanR> what you really want is to reify the fact that you know its not zero, and use that to convince the language recip is ok without bothering with the zero case, and dont even check
18:02:59 <EvanR> its just the next level of high level language translating to unsafe lower language in ways that are safe, thanks to the type system
18:03:43 <EvanR> where you get that non zero evidence though is non trivial
18:03:58 <EvanR> or could be
18:05:25 <EvanR> jared-w: heres another case where a check is wrong, if you have a bytestring type with a known encoding. every place you use it may fail if its encoded wrong, but you only want to verify this at the beginning, not everywhere. Ascii text is a good example
18:06:09 <EvanR> we have smart constructors for this, but we wouldnt need a brand new string type if we had dependent types
18:06:13 <jared-w> Right, makes sense. When you have nothing logical or correct to do with the "wrong usage"  you don't want to even bother dealing with it; just verify you have the right data in the first place
18:06:55 <EvanR> exactly!
18:07:55 <jared-w> So that's definitely a win for dependent types if you don't even need smart constructors. Are there things you can do with smart constructors that you can't with dependent types?
18:09:27 <EvanR> no, this basic usage of an indexed predicate subsumes smart constructors
18:09:40 <jared-w> I thought so
18:09:45 <EvanR> every smart constructor becomes the sigma type (x:A, P(x))
18:10:37 <EvanR> er, the wrapper type becomes that, the constructor becomes the code that gives you the P(x)
18:11:43 <jared-w> right :)
18:12:57 <EvanR> safeHead :: [a] -> Maybe a starts to look like monochrom's safeFromJust :: Maybe a -> Maybe a :)
18:13:25 <jared-w> safeFromJust?
18:13:39 <EvanR> safely access a Maybe value!
18:13:45 <jared-w> So it performs an unsafe head if you have the list and does nothing otherwise?
18:13:54 <EvanR> lol
18:14:17 <jared-w> ohh, never mind
18:17:45 <jared-w> I'm looking up the CH correspondence to understand it better. When people say 'programs', does a function in haskell count as a program?
18:19:24 <EvanR> they probably mean expressions to be evaluated
18:19:53 <EvanR> so (\x y -> x) is one, and is already evaluated
18:20:38 <EvanR> a term of some type, thats a program
18:23:06 <EvanR> if the type is A -> B, which corresponds to "A implies B", a function is what you would need to show A -> B is inhabited
18:23:29 <jared-w> right, that's what I thought
18:23:32 <jared-w> thanks
18:24:06 <EvanR> if the type is LT 3 4, then the "program" needed isnt a function, but something else
18:24:20 <EvanR> a proof that 3 is less than 4
18:24:31 <Henri_> Can anyone help me understand why this monad instance doesn't work?
18:24:32 <Henri_> https://pastebin.com/WGn0w3wB
18:24:40 <Henri_> I really feel like it should
18:24:47 <jared-w> Does it obey the laws?
18:24:58 <Henri_> Yes it just doesn't compile
18:25:02 <Henri_> And I don't understand why
18:25:04 <EvanR> you cant define a monad via =<<
18:25:10 <EvanR> you need to use >>=
18:25:14 <Henri_> It's bind
18:25:18 <Henri_> Just different order
18:25:25 <EvanR> you need to use the other order
18:25:31 <Henri_> I'm going through a course that defines monad itself
18:25:33 <glguy> Henri_: When you have questions about an error message you should include the message in your paste
18:25:42 <glguy> Also try not to use pastebins that have ads, like pastebin.com
18:25:53 <EvanR> https://pastebin.com/raw/WGn0w3wB
18:25:56 <EvanR> hehe
18:26:16 <Henri_> For comparison this instance works: https://github.com/tonymorris/fp-course/blob/master/src/Course/StateT.hs
18:26:18 <jared-w> bam, bamboozled
18:26:29 <Henri_> Line 227
18:26:39 <Henri_> I'll get the error message one sec
18:26:50 <EvanR> ah
18:26:58 <EvanR> tonymorris's code is using NoImplicitPrelude
18:26:58 <jared-w> https://github.com/tonymorris/fp-course/blob/master/src/Course/StateT.hs#L227  -- You can just say #L227 to link to that line
18:27:18 <EvanR> this is a different kind of Monad class
18:27:20 <jared-w> And so they probably have their own monad definition which allows =<<
18:27:25 <Henri_> Yeah theyd o
18:27:35 <jared-w> Might want to use that one if you're doing it for a course :)
18:28:57 <lyxia> Henri_: think about the type of a and the type of the whole right hand side
18:29:09 <Henri_> https://paste.ee/p/7QbnE
18:29:12 <Henri_> Here's the error
18:29:14 <Henri_> Okay
18:29:56 <Henri_> The type of the right hand side is f (Optional a)
18:30:04 <Henri_> So the type of a' should be Optional a
18:30:11 <Henri_> And then I pattern match against that to get a
18:30:34 <Henri_> And then I plug a into a function with type a -> OptionalT f (Optional b)
18:31:33 <glguy> Henri_: The RHS of "f =<< (OptionalT a) = ..." has type "OptionalT f b" (for some b)
18:32:08 <glguy> The outer most function in your RHS is (=<<), so it's being used at the type you're trying to define
18:32:35 <Henri_> Ohhh
18:32:36 <glguy> and because it's being used at that type we know that 'a :: OptionalT f a'
18:33:53 <Henri_> In the error message it says a has type Actual type: f (Optional a)
18:34:04 <glguy> Right, and that's the first problem
18:34:10 <Henri_> So wouldn't that use f's monad instance?
18:34:20 <glguy> No, that means that there's a mismatch
18:34:26 <glguy> so it's wrong
18:34:45 <glguy> It can't have both the type  f (Optional a)  and also  OptionalT f a
18:35:24 <Henri_> I see
18:35:32 <Henri_> That makes sense
18:36:55 <Henri_> Because then the function =<< would have the signature (a -> OptionalT f b) -> f (Optional a) -> OptionalT f b
18:36:59 <Henri_> which doesn't make any sense
18:37:24 <Henri_> Thanks for the help
18:45:48 <joncfoo> I'm unfamiliar with pretty printers and was wondering if there was a simple way to stitch two blocks of text alongside each other
18:52:17 <glguy> joncfoo: If you're using a particular pretty-printing library you should mention which.
18:52:26 <glguy> Or are you asking if any such library can do that?
18:52:30 <joncfoo> I'm not using any particular one at the moment
18:52:40 <joncfoo> looking for recommendations
18:52:54 <joncfoo> I have Text types if that helps
18:53:30 <Squarism> concat $ fmap (\(a,b) -> a ++ " | " ++ b) $ zip (lines text1) (lines text2)
18:53:31 <Squarism> ?
18:54:08 <glguy> Squarism: That implementation would work if all the lines in text1 were the same length, and there were the same number of lines
18:54:09 <Squarism> (...but needs fix for non equal num of rows)
18:54:12 <glguy> but that's a lot of assumptions
18:54:20 <joncfoo> yea, I don't have equal length
18:54:28 <glguy> joncfoo: I don't know how to do that in any of the prettyprinting libraries
18:54:31 <joncfoo> or number of lines
18:55:13 <joncfoo> ok no worries. time to delve into hackage docs
18:58:25 <glguy> joncfoo: If you do find a way, be sure to share it in the channel here. I don't think it's supported in any of the common libraries
18:58:34 <glguy> but I'd love to hear that I'm wrong
19:01:08 <joncfoo> sure will do
19:08:47 <jared-w> I think in order to properly do that sort of thing, you'd end up creating a virtual layout and then printing to that layout
19:09:25 <jared-w> It's basically asking for a multi-column block of two different pieces of text, which is pretty hard to do well generically
19:13:05 <ClaudiusMaximus> https://hackage.haskell.org/package/table-layout perhaps (not used it myself)
19:14:50 <jared-w> That looks pretty much like what joncfoo wants, I think
19:15:34 <jared-w> Just gotta get rid of the borders
19:16:18 <jared-w> gridString seems pretty much what's wanted
19:19:26 <joncfoo> thanks! I'll have a look
19:27:04 <jared-w> The more I learn about fmap and functors the more I like 'em
19:27:25 <jared-w> applicative and other cool toys too
19:30:46 <colluphid> Has anyone tried Idris? Is ther any significant benefit?
19:31:24 <colonelj> dependent types
19:31:28 <jared-w> Different tools for different projects. Neither is "worse" than the other and benfit is often subjective with regards to "what aspect" of "benefit" we're looking at
19:32:37 <jared-w> https://deque.blog/2017/06/14/10-things-idris-improved-over-haskell/ Here's a blog post that's slightly controversial :p
19:33:01 <jared-w> And some of the benefits listed I see as drawbacks
19:33:07 <colluphid> thanks
19:33:25 <colonelj> RankNTypes 4eva
19:33:41 <jared-w> Dependent types are far more powerful than RankNTypes
19:34:04 <jared-w> You also don't need RankN for dependent types
19:35:37 <colonelj> GADTs tho
19:36:02 <jared-w> Also not necessary for dependent types, don't really have anything to do with them, and are completely orthogonal to both dependent types and RankNTypes
19:36:13 <jared-w> They are, indeed, cool
19:36:54 <colonelj> I thought they were taken from dependently typed languages
19:37:45 <jared-w> All they do is allow you to write down the types of the constructors
19:37:56 <colonelj> depenntly typed shit isn't so useful without GADTs
19:38:16 <colonelj> like how would you even do something simple like append two indexed lists without GADTs?
19:38:38 <jared-w> True. Dependently typed languages definitely wanted GADTs. GADTs are useful in non dependently typed languages, however, and have been around for a while
19:43:42 <jared-w> The earliest version of GADTs were described in a 1994 paper. They were introduced in 2003 to programming languages as extensions to ML and Haskell type systems
20:12:27 <codygman> Any better suggestions for an appendAt function for bytestrings? http://lpaste.net/356542
20:13:23 <glguy> why did you use all those !s ?
20:14:36 <codygman> glguy: Based upon the guess that it will be better for those things to be strict
20:15:35 <glguy> codygman: None of those have any effect; the function was already strict in all of the things you added ! to
20:16:32 <codygman> glguy: Oh, yeah I forgot that pattern matching with (x,y) forces strictness. Right?
20:16:37 <glguy> no
20:23:09 <glguy> Oh, actually it makes it slightly more strict in the appendBS argument, but not for any performance benefit
20:24:17 <glguy> err, nope, still strict in all of it. You can work back from the result of the function
20:25:03 <glguy> <> evaluates both of its arguments
20:34:48 <mniip> Can't wrap my head around HoTT
20:36:32 <mniip> Is it not the case that pi (p :: x = y). p = refl
20:37:16 <mniip> Due to recursion/induction on the equality type
20:37:40 <glguy> mniip: Are you reading about UIP?
20:38:01 <mniip> What's that stand for?
20:39:05 <glguy> uniqueness of identity
20:39:24 <glguy> or relatedly axiom K, I believe
20:40:08 <mniip> I've tried reading the hott book top down
20:40:31 <ReinH> I recommend left-to-right.
20:40:37 <mniip> I've reached the definition of isSet and I don't understand it
20:40:54 <mniip> I see it as a tautology
20:41:37 <mniip> glguy, perpaps we're thinking about different "K" axioms?
20:41:59 <ReinH> mniip: It is a tautology in set theory
20:42:07 <ReinH> Where, unsurprisingly, things are sets.
20:42:17 <ReinH> In HoTT, equality relationships carry more information.
20:42:24 <ReinH> So it is not always the case that p = q
20:42:41 <mniip> but it is always the case that p = refl
20:43:02 <ReinH> Is it?
20:43:09 <mniip> And transitively, p = q
20:43:12 <glguy> mniip: Whether or not that is the case depends on the logic you're working in
20:43:15 <mniip> One sec,
20:44:41 <glguy> mniip: What you wrote doesn't actually appear to be well-typed
20:46:36 <mniip> pi (A :: U). pi (x, y :: A). pi (p :: x = y). p = refl_x
20:47:10 <glguy> mniip: You can't use refl_x at type x = y
20:47:13 <glguy> it has type x=x
20:48:26 <ReinH> For reference, isSet A = (x y : A) (p q : x ≡ y) → p ≡ q
20:50:44 <glguy> mniip: This is related to the axiom K I mentioned earlier
20:52:37 <mniip> k : a -> b -> a?
20:52:48 <glguy> No, that's combinator K, not axiom
20:52:56 <mniip> I thought...
20:53:23 <ReinH> axiom K is the one Agda's {-# OPTIONS --without-K #-} removes :)
20:53:36 <mniip> I've read that, yes
20:53:51 <ReinH> Axiom K is the principle of uniqueness of identity proofs. So you can see why you'd want to work without it here.
20:53:56 <mniip> I have no idea what K is if not this
20:54:38 <glguy> Using the definition of isSet given by ReinH, allSets : ∀ {a} (A : Set a) → isSet A , trivially checks with with axiom K enabled, and doesn't without
20:54:47 <ReinH> If you want isSet to not be tautological, you need to drop Axiom K.
20:55:47 <glguy> Disabling it frees you up to model logics where equality is more interesting that just being a single refl inhabitant
20:55:58 <ReinH> e.g., HoTT
20:56:22 <ReinH> Arguably, one of the motivations for HoTT is to make isSet not tautological
20:59:54 <ReinH> The main feature of HoTT is that it interprets the type x ≡ y as *paths* from x to y.
21:01:19 <jared-w> which, iirc, lets you use all the fancy topology tools we've developed to define different types of equalities and reason about more complex equalities, right?
21:03:14 <ReinH> The paths are what let us capture the informal practice of reasoning "up to isomorphism" in a formal setting, i.e., the univalence axiom.
21:03:45 <ReinH> and gives us functional extensionality for free
21:03:55 <ReinH> well, as a consequence of UA
21:05:17 <ReinH> The problem is that UA is incompatible with dependent pattern a la McBride, which requires axiom K, so a way had to be found to drop K without dropping dependent pattern matching.
21:05:36 <ReinH> That's https://lirias.kuleuven.be/bitstream/123456789/452283/2/icfp14-cockxA.pdf
21:06:13 <ReinH> Er, dependent pattern *matching* a la McBride.
21:06:47 <ReinH> So we can use --without-K and write our HoTT proofs in Agda.
21:08:21 <ReinH> Well, we can write them without avoiding pattern matching.
21:18:10 <jared-w> neat
21:18:23 <jared-w> Most of that went way over my head but I'll read the paper and hopefully it'll stick better :p
21:24:47 <mniip> I wish I could BAKE
21:30:43 <jared-w> What did you try to make, mniip?
21:41:23 <mniip> jared-w, a dependently typed proof
21:48:19 <jared-w> ahh
21:48:27 * jared-w totally has food on the mind, apparently
21:49:24 <mniip> Hmm indeed
21:49:43 <mniip> I don't think my proof structure quite works
21:51:44 <pacak> mniip: Let's use rubber duck debugging.
21:51:55 <pacak> Start explaining what you are trying to do :)
21:52:25 <mniip> That's a pain on mobile
21:52:48 <pacak> :(
21:52:56 <pacak> Later then :)
21:54:00 <mniip> But basically, to prove pi (a, y : A). pi (p, q : a =_A y). p =_(a =_A y) q
21:56:35 <mniip> I've tried \(a : A) -> ind'_=_A(a, \(y : A) (p : a =_A y) -> pi (q : a =_A y). p = q)
21:57:23 <mniip> But that leaves a subgoal of:  pi (q : a = a). refl_a = q
21:57:46 <mniip> Which I thought ind_= was intended to prove
21:57:51 <mniip> But apparently not
22:00:56 <mniip> Man it's been a while since I've done types on paper
22:01:44 <MarcelineVQ> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Semigroup.html#t:Option  When the docs say "Option is effectively Maybe with a better instance of Monoid, built off of an underlying Semigroup instead of an underlying Monoid." What do they mean by better? I'm having difficulty determining an actual difference. Is it solely that the Option Monoid involves Semigroup and the Maybe Monoid doesn't?
22:02:30 <Lokathor> isn't there a package that has mutable reference types that are based on vectors and stuff so you can have unboxed references?
22:03:00 <MarcelineVQ> is an unboxed reference a pointer?
22:03:40 <Lokathor> rather, a reference to an unboxed value
22:03:54 <ReinH> MarcelineVQ: Better in that the usual Monoid instance for Maybe has a spurious Monoid constraint.
22:04:07 <Lokathor> i can't remember the name of the package, but it basically newtyped over single element mutable vectors to make them look like reference types
22:04:26 <ReinH> You don't need Monoid m => Monoid (Maybe m), you only need SemiGroup m => Monoid (Maybe m)
22:05:30 <ReinH> If you use Nothing as your identity element then you forget about mempty :: m anyway, since there can only be one identity element.
22:06:54 <MarcelineVQ> ReinH: thank you
22:16:32 <mniip> ReinH, it is true, thought, that pi (x : A). (pi (p : x = x). p = refl_x -> 0) -> 0
22:16:35 <mniip> Right?
22:17:08 <mniip> No wait,
22:17:38 <mniip> pi (x : A). (sigma (p : x = x). p = refl_x -> 0) -> 0
22:20:13 <ReinH> mniip: I don't know.
22:21:13 <mniip> While there might be judgmentally inequal equalities, a propositionally inequal equality is a contradiction
22:27:44 <dramforever> *Can* you even *talk* about things being 'judgmentally inequal'?
22:42:48 <jared-w> ahh
22:43:25 <jared-w> nvm, ReinH was faster
22:45:47 <jared-w> But yeah, Option has a semigroup instance defined by copying Maybe's (through coerce) and their monoid instance is a "proper" one
22:50:35 <jared-w> Question: How dangerous would it be to change Maybe to the correct one?
22:50:57 <kadoban> Anyone use haskell on codeforces? It seems like they're using safe haskell in a pretty annoying way and I'm trying to come up with good arguments for them to fix it ... there's no mutable arrays available, no ST, no Data.Vector, etc. :-/
22:52:50 <ongy> jared-w: once Semigroup => Monoid is mandatory, probably not particularily dangerous (unless it changes behavior)
22:53:40 <jared-w> ongy: well once Semigroup => Monoid is mandatory, there will be exactly zero risk in correcting Maybe. Anything that would've broken or changed behavior no longer compiles because it doesn't have a Semigroup instance
22:54:47 <jared-w> (and to that end, since Monoid is a strict superset of Semigroup, I don't see how Semigroup can't be automatically derived from Monoid instances...)
22:56:57 <jared-w> kadoban: how does leetcode's haskell abilities hold up? Can you use mutable arrays, ST, Data.Vector, etc?
22:57:21 <kadoban> jared-w: I don't use that place :-/ On hackerrank you can use mutable arrays and ST and etc. and quite a bit, it's pretty good there.
22:58:25 <kadoban> I'm not really sure what they're gaining by disallowing ST and etc. I mean they let you run unrestricted IO (at the language level anyway), so they must be doing a VM or limiting I/O at the OS level or something for sanity regardless.
22:58:45 <jared-w> Can you give me a random code snippet that includes a selection of valid "unsafe" stuff that you wanted to use? I'll test it out on leetCode real quick
22:59:30 <jared-w> oh nvm, leetcode doesn't have haskell support yet :|
22:59:51 <kadoban> https://gist.github.com/kadoban/6049d086a75a05b3c9ec04e94e768f84
22:59:53 <kadoban> Oh
23:00:01 <kadoban> Yeah I guess that answers that part then, heh.
23:00:08 <jared-w> I got confused because there's a decent amount of results for leetcode answers in haskell... lol
23:00:25 * jared-w looks at gist
23:00:37 <jared-w> Well I guess that's all I really need to test...
23:01:02 <kadoban> Yeah, I mean I don't see how they could let you import them but still break them. On codeforces just that breaks, and a few other modules.
23:03:24 <jared-w> What kinda excuses are they giving for not allowing full Haskell?
23:04:08 <kadoban> I haven't found a public explanation, I'm trying to write an argument that they can and should fix this. I don't really know anything about safe haskell though so it's a bit hard, looking up wtf it's supposed to do so I can argue it's useless here.
23:04:57 <jared-w> Safe Haskell makes a bunch of really strong guarantees that are supposed to allow for unsafe code to be securely included in a trusted code base
23:04:59 <kadoban> It's also disallowing extensions like GND, which is also tedious and annoying ...
23:05:28 <kadoban> jared-w: Right. But if you're just going to allow IO anyway, it's not really doing much, right?
23:05:32 <jared-w> It's for enforcing strict type safety at compile time and compiling and executing untrusted code
23:05:39 <jared-w> the first one is useless, the second one is important
23:05:58 <jared-w> But if you're already allowing IO, you've already lost, as far as I'm concerned
23:06:23 <kadoban> Like they just compile and run the program you give them, so main :: IO () is already more than they're preventing, so I'm just kind of confused.
23:06:26 <kadoban> Okay, thanks for confirming
23:06:30 <jared-w> You can ping edwardk if you want to listen to an entertaining rant about how useless Safe is and how much of a nightmare it is to actualy make your code safe from a library writer perspective
23:06:53 <kadoban> Lol, that's unfortunate. I thought it sounded like a good-ish idea in general.
23:07:05 <jared-w> It's a great idea, it just needs to be significantly reworked
23:07:53 <jared-w> for example, all of template haskell is disabled, and when writing libraries you have to make sure you don't promote unsafe code to safe code for anyone who might use your library. But you have to check the cartesian product of every single possible version of libraries that can compile with your code, things like that
23:08:36 <kadoban> Ohh that. I'm trying to understand that now, how all that works. A bit confused what Trustworthy means or does, etc.
23:11:04 <jared-w> Here let me pull up the rant
23:11:08 <jared-w> http://lpaste.net/2695832306047778816
23:11:42 <jared-w> (Someone wanted to import an unsafe module into lambdabot and couldn't, thus prompting the rant)
23:12:36 <kadoban> Ah, fun. Yeah that does sound like a mess
23:13:07 <jared-w> As a result, anyone who wants to keep their sanity as a developer does not bother making their code Safe
23:13:27 <jared-w> => almost all really useful and shiny things in haskell are unsafe
23:14:09 <jared-w> Also, culturally, haskell is a research first language. Thus the language "proper" moves at glacial speed, while the development of the language is quite rapid through things like pragmas
23:15:12 <jared-w> So, while it makes sense to restrict to a "sane subset" in Haskell and turn off language extensions, they are mandatory in Haskell to having idiomatic, performant, and efficient code. Turning all of that off is equivalent to dumping people into C++03
23:15:19 <mniip> I should write a lambdaer bot
23:15:27 <jared-w> and expecting them to use that instead of C++17
23:16:05 <mniip> I have a pretty good sandbox thingy that is working
23:16:09 <jared-w> s/C++03/C++98/
23:16:30 <jared-w> kadoban: that should give you the nice starting point to your "pls make haskell not suck on this website" argument
23:16:53 <kadoban> Yeah, it sounds like a good base, thanks :)
23:16:59 <jared-w> mniip: lambdaer?
23:17:18 <jared-w> like lambda but more more awesomer? maybe even lambda++? /s
23:17:42 <mniip> We have the lambdaest bots
23:18:22 <jared-w> We have the best bots, the best. Ask anyone. We have the best--and I mean the absolute best--bots here anywhere
23:19:36 <mniip> If you're interested, /msg yalb %hs "foo"
23:23:14 <mniip> Hm, can't get rts to honor ulimits
23:25:26 <cocreature> mniip: did you set hard or soft limits?
23:25:45 <mniip> hard
23:26:21 <cocreature> huh, my understanding was that this is enforced by the kernel so I’m not sure how the rts can just ignore that
23:26:31 <mniip> I'm running under 1G hard RLIM_AS, with -M400M -K200M -V0
23:26:33 <cocreature> and even for soft limits I would be surprised if it deliberately changes them
23:26:39 <mniip> Still manages to die
23:26:58 <mniip> No like
23:27:04 <mniip> "malloc: failed on request for 72 bytes; message: newInCall
23:28:04 <mniip> And that's for trivial tasks too
23:29:19 <cocreature> what do you expect it to do if you allocate more than 400mb?
23:29:46 <mniip> Say "heap exhausted" like it usually does
23:30:04 <mniip> Not die from a random xmalloc abort
23:31:11 <mniip> Hmm, is ghci code running on the same rts as the interpreted code
23:31:24 <mniip> Should be
23:31:40 <haisheng> hi, does anyone have idea about which following function is stricter? f x = length [head x]; g x = length (tail x)
23:31:48 <haisheng> it's from https://en.wikibooks.org/wiki/Haskell/Laziness
23:32:01 <haisheng> I thought they are equally strict..
23:32:04 <cocreature> mniip: are you sure you’re passing the option actually to ghci and not ot stack or cabal?
23:32:32 <mniip> yes
23:33:14 <kadoban> haisheng: Well, g will evaluate more of the spine of the list once its used. f really only looks at the first (:) it finds and that's it
23:33:24 <cocreature> > length (head (undefined : undefined))
23:33:27 <lambdabot>  *Exception: Prelude.undefined
23:33:31 <cocreature> > length [(head (undefined : undefined))]
23:33:33 <lambdabot>  1
23:33:40 <cocreature> > length (tail (undefined : undefined))
23:33:42 <lambdabot>  *Exception: Prelude.undefined
23:33:53 <mniip> .../ghc -dynload deploy --interactive -v0 -ghci-script .../init -ignore-dot-ghci +RTS -M400M -V0 -C0 -K200M
23:34:57 <haisheng> oh,, g needs to evaluate the 2nd thunk (of :) thus it is stricter?
23:35:31 <kadoban> haisheng: g actually evaluates the entire spine of the list, since it has to know the length of the tail
23:36:09 <cocreature> mniip: what happens if you drastically reduce the options to -M and -K? maybe it’s counting wrong for some reason. ghci -M1M dies immediately as I would expect it to so that option doesn’t seem to be completely broken :)
23:36:23 <haisheng> kadoban: make sense now! thanks!
23:37:47 <mniip> ghc: panic! (the 'impossible' happened); (GHC version 8.3.20170519 for x86_64-unknown-linux):; heap overflow; Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug
23:38:10 <cocreature> oO
23:38:26 <cocreature> does this happen with 8.0.2 as well?
23:39:16 <mniip> No idea, I have a fairly peculiar configure optionset
23:40:50 <mniip> (Imagine a chroot without a chroot)
23:51:04 <jared-w> nested chroots?
23:57:34 <ReinH> Or, as I like to call them, yo dawg chroots
23:59:49 <jared-w> It's an older meme, but it checks out
