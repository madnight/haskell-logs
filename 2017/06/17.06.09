00:01:13 <cocreature> :t span -- if you already know how to implement that you can easily implement Axman6’s groupOne function using that
00:01:14 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
00:01:59 <butterthebuddha> What exactly does that function do
00:02:13 <butterthebuddha> span, that is?
00:02:18 <Axman6> > span (< 5) [1..10]
00:02:20 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
00:02:36 <cocreature> > span (<5) ([1..10] ++ [1..4])
00:02:38 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10,1,2,3,4])
00:02:38 <Axman6> > span even [2,4,3,4,5,6]
00:02:41 <lambdabot>  ([2,4],[3,4,5,6])
00:03:12 <Axman6> it splits a list into two parts, the first being as many elements that the predicate returned true for before returning false
00:03:19 <Axman6> > span (<11) [1..10]
00:03:20 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[])
00:04:41 <lpaste> SepakoRayl pasted “Patterns” at http://lpaste.net/356136
00:05:40 <butterthebuddha> How do I pattern match on a function?
00:05:45 <cocreature> SepakoRayl: that seems to work. so what is your question? :)
00:05:54 <EvanR> butterthebuddha: you cant!
00:06:03 <SepakoRayl> I am trying to work with a parameterized Test
00:06:17 <EvanR> functions arent made of constructors
00:06:21 <SepakoRayl> but then I am having trouble writing / instancing the typeclass
00:06:36 <cocreature> parametrized in the sense of "data Test a = Test a"?
00:06:57 <EvanR> if it would make sense for a function to be made of constructors, then you could define your own function-like type, with constructors and pattern match on them
00:07:15 <SepakoRayl> cocreature yes
00:07:26 <cocreature> SepakoRayl: what would the newtypes look like in that case?
00:07:56 <cocreature> SepakoRayl: it might be helpful if you show the code that you’d like to write but are having problems with
00:09:13 <SepakoRayl> uh ok let me try
00:10:05 * hackage optparse-applicative 0.14.0.0 - Utilities and combinators for parsing command line options  https://hackage.haskell.org/package/optparse-applicative-0.14.0.0 (huw)
00:10:32 <Lerz> s
00:10:54 <cocreature> oh that looks like a pretty neat release of optparse-applicative
00:11:07 <cocreature> support for Text and suggestions on typos
00:11:44 <Cale> nice!
00:24:06 <zaghie> yes
00:25:22 <butterthebuddha> cocreature: this look good? https://pastebin.com/D5V8YRkX
00:28:57 <butterthebuddha> The lambda should actually probably always evaluate to False
00:30:39 <merijn> Does GHC expose any primitives for inspecting how many threads are running & blocked, or some other way to estimate whether you're currently IO or compute bound?
00:34:32 <SepakoRayl> if I have a type class "class Test a b ...." is it possible to instance something like "instance class Test (Wrapper b) b" ?
00:34:49 <SepakoRayl> excuse the grammar typo :P
00:35:07 <merijn> SepakoRayl: Sure
00:48:26 <lpaste> SepakoRayl pasted “Patterns'” at http://lpaste.net/356137
00:48:53 <SepakoRayl> this for instance, I can't make to work.
00:49:33 <SepakoRayl> it's probably something obvious but I have just yesterday dived into all these extensions
00:51:51 <merijn> SepakoRayl: "Ambiguous type variable ‘a0’ arising from a pattern" <- this is code for "I dunno wtf this type is supposed to be"
00:52:14 <merijn> SepakoRayl: Specifically, your class could produce whatever instance you write and print takes anything with a show instance
00:52:57 <merijn> SepakoRayl: So GHC knows two things: 1) this type has an instance "NodeConv (Wrapper String) a" 2) this type has an instance "Show a"
00:53:10 <merijn> SepakoRayl: However, that doesn't tell GHC *what* 'a' should be specifically
00:53:21 <merijn> And how can it print it/show it if it doesn't know what it is
00:54:03 <SepakoRayl> I intended the instance to be NodeConv (Wrapper String) (String, String)
00:54:13 <merijn> SepakoRayl: Yes, but GHC doesn't know that
00:55:34 <merijn> actually, the more I stare at this, the more confused I get by what you're trying to do
00:56:37 <SepakoRayl> that should just print Wrapper (Node ("test", "test)). Just learning the extensions for now, it doesn't really do anything useful.
00:57:49 <SepakoRayl> what seems weird to me is that the only instance is of the form NodeConv (Wrapper a) (a, a).
00:57:56 <SepakoRayl> if ghc deduces a = String
01:00:00 <SepakoRayl> ah I got it
01:01:36 <SepakoRayl> using functional dependencies should fix that, I think
01:02:26 <merijn> SepakoRayl: On a higher level, what are you hoping to accomplish with this wrapper class? Because it's almost certainly not a great idea
01:03:20 <obsoleteToe> New here..
01:03:43 <Cale> obsoleteToe: Hello! Feel free to ask any questions you might have about Haskell.
01:03:49 <SepakoRayl> ok here goes. The answer shows what I have till now. https://stackoverflow.com/questions/44366489/deriving-extensions-with-multiparameter-types
01:04:27 <obsoleteToe> @cale, thank you..
01:04:28 <lambdabot> Unknown command, try @list
01:04:31 <SepakoRayl> I basically want to be able to use patterns for all of these since whatever I do I just wrap/unwrap them
01:04:49 <merijn> SepakoRayl: Why do you wanna parameterise, e.g. intConst?
01:04:57 <merijn> SepakoRayl: Why not hardcode it to, like, Integer?
01:06:21 <SepakoRayl> I want to use the Ast types as building blocks. Later on I may want say add a default type to intConsts
01:07:57 <SepakoRayl> but then again I don't want to write the same patterns for each constructor for each newtype
01:08:03 <ij> ertes, I managed to compile my executable with nix, but didn't try dockerizing it yet.
01:08:30 <SepakoRayl> and this is what I was trying to do but perhaps I can't
01:08:40 <ij> ertes, TemplateHaskell needed git, but adding git to deps failed, because git != pkgs.git in that case.
01:11:48 <SepakoRayl> basically all the patterns are the same in structure but the types won't work out.
01:13:29 <SepakoRayl> or perhaps I can make them do, thhis is what I am trying to do with the examples
01:14:40 <Axman6> SepakoRayl: I haven't been following along closely, but you may find this paper useful: https://arxiv.org/abs/1610.04799
01:14:57 <SepakoRayl> I read that
01:15:08 <SepakoRayl> I have two versions of the compiler currently
01:15:16 <SepakoRayl> one is reqritten following the paper
01:17:01 <SepakoRayl> if I managed to solve this issue the current approach would have the benefit of being able to add Functor, Traversable and Foldable instances using the genifunctors library which has a few benefits.
01:17:16 <tiny_test> I'm looking for a HList implementation with "remove" function that removes all occurances of a given type, anyone know a library with this function?
01:17:52 <SepakoRayl> without getting into the details it allows for an applicative interface in the ast conversion between compiler stages
01:19:15 <SepakoRayl> I can't do that with trees that grows before the ast does not expose the annotation types
01:19:19 <SepakoRayl> because*
01:23:05 <bollu> smallCat: ping
01:25:15 <SepakoRayl> woah I think functional dependencies completely solve my problem
01:47:21 <cocreature> SepakoRayl: if you expect your code to work for all newtypes, why not just write it for Node and then convert from/to your newtypes?
01:52:06 <SepakoRayl> I can but at this point I have a line of conversions for each function that looks almost the same save for different constructor names
01:52:56 <SepakoRayl> so I said maybe I can do this with patterns
01:53:25 <SepakoRayl> it's nothing I really have to do
02:02:47 <vektor> Hey everyone! So I got a weird memory leak in my app. So I can call https://github.com/vektordev/GP/blob/master/src/GRPPool.hs#L193-L221 this function with first parameter (iteration count) 1 and it works. I can call it with two and on some pools it will sometimes crash (out of memory [RAM])
02:03:17 <merijn> vektor: Step 1) Profile memory usage :)
02:03:32 <vektor> I can however also call it with one iteration, exit the application, reload it and apply another iteration.
02:04:15 <vektor> merijn: Kinda hard in my case. It's a batch application with a huge CPU footprint. I'm trying to pin the leak down to one of the steps of an iteration, but fail because of that oddity.
02:04:35 * hackage BioHMM 1.1.8 - Libary for Hidden Markov Models in HMMER3 format.  https://hackage.haskell.org/package/BioHMM-1.1.8 (FlorianEggenhofer)
02:04:54 <merijn> vektor: Why does that make profiling hard?
02:04:59 <vektor> (i.e. with profiling enabled it will kinda run really long before I see results)
02:05:16 <vektor> So it will take really long to crash or even alloc a lot of ram when I use a -prof build
02:05:18 <merijn> vektor: You can enable/disable profiling at runtime, afaik
02:05:39 <Axman6> I don't think that's true...
02:05:58 <merijn> Axman6: Then why does GHC.Profiling export "startProfTimer" and "stopProfTimer"?
02:06:33 <vektor> So my plan forward was to try and fix this memory weirdness there. I mean, there's no reason why it would crash if I do 2 iterations at once and work if I do them separately, right?
02:06:46 <vektor> Then I can pinpoint the leak much easier.
02:06:51 <Axman6> merijn: who knows, they have no docs
02:07:22 <merijn> Axman6: Be the change you wanna see in the world ;)
02:07:33 <vektor> :D
02:07:55 <merijn> If vektor is willing to figure out if/how they work and document it for the rest of us :)
02:09:04 <vektor> I don't think I'm quite qualified for that. I'm severely lacking in haskell debug/profiling skills.
02:09:26 <Axman6> well those functions are implemented in C, so should be easy ;)
02:09:48 <Axman6> merijn: the names of those functions to not imply to me they turn profiling on and off though
02:09:53 <merijn> vektor: This is how you *get* debug/profiling skills ;)
02:09:56 <cocreature> https://stackoverflow.com/questions/24714502/exclude-overheads-while-haskell-profiling seems to suggest you can at least use it to disable time statistics but not alloc statistics
02:09:59 <vektor> :D
02:10:13 <Axman6> since profiling builds are still separate builds from normal builds
02:10:48 <cocreature> Axman6: sure but turning off the recording should at least remove some of the overhead
02:11:06 <merijn> Axman6: Sure, you need to build with profiling, but you can turn of the actual operations
02:11:15 <vektor> Can anyone tell me I'm not taking crazy pills here btw? My iterate function really shouldn't crash more, the more iterations I make it do at once, right?
02:11:23 <Axman6> right, if that's what that does, then that sounds useful :)
02:11:49 <merijn> vektor: Well, if you're leaking memory then it might :p
02:11:57 <merijn> vektor: And since it crashes with out of memory...
02:12:32 <vektor> Wait, I thought leaking memory was always by way of thunks, no?
02:12:50 <merijn> vektor: Also, high five for joining me in the club of cool people who've done evolutionary algorithms in Haskell ;)
02:13:05 <vektor> :)
02:13:23 <merijn> vektor: If you allocate and never free an array inside a loop, that'd constitute a leak too
02:14:06 <vektor> I don't think I'm doing that. I mean my pool data structure grows with each iteration, but only so much.
02:14:46 <vektor> Do-notation will be reduced to tail recursion if applicable, right?
02:15:28 <merijn> tail recursion is irrelevant in haskell
02:15:33 <Axman6> depends on what you've written, which monad etc
02:16:04 <vektor> IO
02:16:20 <merijn> Honestly, my current suspicion is that zipTreeWith is too lazy
02:16:49 <merijn> Leading to a huge population
02:16:50 <vektor> It really is something, yeah :D
02:17:11 <merijn> vektor: Ghetto hack to check if that helps: Just deepseq the entire thing
02:17:19 <vektor> Haha, will try
02:17:25 <merijn> If it stops crashing then you know you should make the zip stricter
02:21:09 <saurabhnanda> I'm completely stumped by "constraint is no smaller than the instance head" -- it's just not making sense to me. Why can't I say, if a type has an instance of typeclass X, then here is how you can generically figure out an instance for typeclass Y?
02:32:49 <nshepperd_> saurabhnanda: constraints have to be smaller than the instance head so that the compiler can be sure that constraint solving will terminate
02:33:27 <saurabhnanda> what does that really mean? and WHY is that restriction there?
02:34:24 <nshepperd_> You can turn off the restriction with UndecidableInstances
02:35:03 <nshepperd_> It's there because we want constraint solving to terminate
02:35:38 <nshepperd_> Because having the compiler loop forever is bad ux
02:36:18 <AWizzArd> Are toInteger and fromInteger actually doing any work in case that the “conversion” requires no new memory? Or is it just satisfying the types so that I can compile without an error?
02:36:40 <AWizzArd> A toInteger on a Word8 for example, and then calling a FN that expects an Int via fromInteger
02:36:59 <Axman6> you might want to look at fromIntegral
02:37:18 <nshepperd_> I'm not sure how exactly "smaller" is defined, but for instance "a" is smaller than "Foo a"
02:37:26 <saurabhnanda> nshepperd_: that doesn't always work. It results in tons of overlapping instances
02:38:01 <Axman6> isn't this problem why the default implementations exist?
02:38:29 <nshepperd_> So an instance like "Thing a => Thing (Foo a)" is allowed
02:39:21 <nshepperd_> saurabhnanda: overlapping instances are a different problem...
02:41:18 <saurabhnanda> nshepperd_: for me theyre' completely correlated. I turn on UndecidableInstances and am left with a 30 OverlappingInstances
02:41:47 <Axman6> would the default implementation stuff on https://wiki.haskell.org/GHC.Generics be useful (search for "default put")?
02:41:58 <nshepperd_> "instance Foo a => Bar a" doesn't say "for any type with instance Foo a, make me an instance Bar a"
02:43:01 <saurabhnanda> nshepperd_: how do I express that idea in Haskell? That's exactly what I want. If a type has an instance of type-class `a`, then here's how you can get an instance of type-class `b`
02:43:28 <saurabhnanda> Axman6: checking
02:43:36 <Axman6> what is the point of typeclass b if anything that can be in a is also in b?
02:43:45 <CSRaghunandan> \
02:43:58 <nshepperd_> It says, "for any type a, it has an instance Bar a if and only if it has an   instance Foo a"
02:45:07 <merijn> Anyone here use MonadLogger? Know how it should be used in a multi-threaded scenario?
02:45:11 <saurabhnanda> Axman6: I have not written `b` -- I'm being forced to use it.
02:45:31 <nshepperd_> saurabhnanda: well, you can enable OverlappingInstances, but that is bad..
02:46:01 <saurabhnanda> merijn: my hack for that -- use a LogId and make sure that every log puts that in the log file to allow you to tie related logs together. Ended up doing that for multi-threaded logging in Servant.
02:46:15 <nshepperd_> Or you can make a newtype wrapper, that lets you explicitly say that you want the instance generated from class a
02:46:15 <saurabhnanda> s/every log/every log statement
02:47:38 <saurabhnanda> nshepperd_: Axman6: I'll explain a little more. If a type has an instance of typeclass MyDBField, then it carries ALL the information required to generate ToJSON/FromJSON instance, and ToField/FromField instances. But how do I tell Haskell that?
02:47:47 <pavonia> nshepperd_: How is "if A then B" and "B iff A" semantically different in this particular case?
02:48:10 <merijn> pavonia: In the first case B doesn't imply A
02:48:39 <pavonia> I understnad the difference in general but not in this instance deriving case
02:48:40 <saurabhnanda> I don't want to site and write 8 lines of redundant instance declarations for every single type in my app. It's frustrating. Makes everything seem so dumb.
02:48:59 <merijn> saurabhnanda: Why do you have so many classes to begin with?
02:49:30 <pavonia> Or to ask it another way, when is "for any type with instance Foo a, make me an instance Bar a" not true?
02:49:42 <saurabhnanda> merijn: so many types. and so many classes because every library wants me to define it -- eg. ToJSON, FromJSON, FromField, QueryRunnerColumnDefault , Default Constant 
02:50:47 <saurabhnanda> every external interface in Haskell ends up with a bunch of typeclasses. Right now, it's DB & JSON. Tomorrow it will be ToHTML/FromHTML (for Lucid), then god knows, might be ToRedis/FromRedis
02:51:00 <nshepperd_> pavonia: the intended semantics of "make me an instance of Bar a" is that it only applies to the types such that Foo a.
02:52:32 <pavonia> But there is no difference in the result?
02:53:31 <nshepperd_> pavonia: the way instances actually work is, if there *isn't* an instance Foo a, you have just asserted that there is no instance Bar a either
02:53:50 <saurabhnanda> is there any way to avoid this typeclass related boilerplate?
02:55:03 <pavonia> nshepperd_: Is this what the compiler assumes?
02:55:48 <nshepperd_> That's why the compiler complains about overlapping instances, basically...
02:59:00 <pavonia> Ah, I think I know what you mean then
03:02:24 <nshepperd_> saurabhnanda: instead of giving your types ToJson instances directly, you could define a newtype wrapper and give that the instance
03:02:31 <MasseR> Is there a term for something like `(f a -> g b) -> f a -> g b` or `(f a -> g a) -> f a -> g a`? Something like a more general listToMaybe
03:02:38 <saurabhnanda> nshepperd_: how exactly?
03:04:11 <nshepperd_> newtype WrappedField a = WrappedField a; instance MyDBField a => ToJson (WrappedField a) and so on
03:04:40 <lyxia> MasseR: uh,   id :: (f a -> g b) -> f a -> g b
03:04:46 <nshepperd_> Then you can apply the wrapped whenever you need to marshal to/from json or whatever
03:06:00 <nshepperd_> Or you could just bite the bullet at copy/paste the instances for each of your types
03:06:11 <MasseR> lyxia: From category?
03:06:19 <MasseR> With some instance?
03:06:44 <Gurkenglas> MasseR, no from Prelude with the only implementation of id :: a -> a
03:07:16 <saurabhnanda> nshepperd_: how is this an acceptable situation in language design?
03:07:23 <MasseR> Oh,right of course
03:07:28 <saurabhnanda> nshepperd_: is this something that haskell-prime can solve for next version of Haskell?
03:14:02 <nshepperd_> That would require that someone has a concrete plan for how to improve this
03:15:33 <nshepperd_> I can imagine having custom default instances of some kind so that adding each instance would be one line
03:16:51 <saurabhnanda> https://mail.haskell.org/pipermail/haskell-prime/2017-June/004283.html
03:18:08 * hackage foundation 0.0.10 - Alternative prelude with batteries and no dependencies  https://hackage.haskell.org/package/foundation-0.0.10 (VincentHanquez)
03:19:39 <quchen> bollu: ping
03:20:27 <quchen> Well I guess there’s lunch soon anyway. I need a random LLVM file generator for benchmarking the prettyprinter on a million lines or so.
03:21:05 <nshepperd_> saurabhnanda: you can certainly define a function like defaultFromField so that your instances would just be "instance FromField State where fromField = defaultFromField". So you don't have to copy the whole definition
03:27:06 <saurabhnanda> nshepperd_: again... just a fig-leaf. the boilerplate is still there.
03:27:59 <saurabhnanda> nshepperd_: btw, that's what I'm doing in my real app... but this is painful. I shudder to think of the busy-work I'll have to do when I need to bring lucid into the picture... 500+ new instances to be defined
03:31:05 <phz_> hey peeps, using servant here
03:31:24 <phz_> I have a big webapp written with servant + servant-server + a shit load of other stuff
03:31:43 <phz_> I wrote a CSV importer with cassavo to manually import data that you would usually post via the API
03:31:47 <phz_> how can I manually call the endpoint?
03:31:51 <phz_> I fail to find hsow
03:31:52 <phz_> how*
03:32:18 <phz_> because the serve function reacts to HTTP request, it doesn’t let me “hit the endpoints” as I wish
03:33:55 <phz_> hm, there’s the runHandler function
03:36:48 <paolino> hi, is it correct that writeChan is unsafe ?
03:37:40 <paolino> for multiple threads can use it concurrently ?
03:38:03 <Ferdirand> hello #haskell, what's the proper way, with megaparsec, to parse a grammar that looks like "{ s; s; s; e }", where s can be a superset of e ?  
03:38:52 <Ferdirand> if i do "(try s `endBy` semicolon) >> e" it does not work, because the try s succeeds at parsing the e, and then it fails on the missing ;
03:39:57 <Ferdirand> it looks to me like i need a modified endBy with the try inside ?
03:41:18 <paolino> try $ s `endBy` semicolon ?
03:44:04 <rios> \query lambdabot
03:44:12 <AWizzArd> I have a Data.IntMap instance. How can I find out how many elements (key/value pairs) it holds?
03:45:44 <AWizzArd> Data.IntMap.Strict that is.
03:49:06 <lyxia> there's a size function
03:49:22 <lyxia> http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-IntMap-Strict.html#v:size
03:50:11 <AWizzArd> Ah true, size works.
03:50:12 <AWizzArd> Thx.
03:54:23 <Ferdirand> paolino: that does not work. I'm not sure I understand try well enough to explain it.
03:55:35 <Ferdirand> if i define: tryEndBy p sep = many (try (p <* sep)), it works
03:55:45 <Ferdirand> but i'm unsure of the underlying implications
03:56:11 <NextHendrix> "the implication"
03:57:55 <Ferdirand> NextHendrix: which means ? horrible backtracking behaviour ?
04:20:24 <ertes> ij: i have no experience with non-haskell dependencies…  you would have to ask in #nixos or, even better, on nix-dev about those
04:22:17 <ertes> ij: dockerising is surprisingly easy, but it's not really documented right now…  i learned it by reading source code comments: https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/docker/default.nix#L356
04:22:48 <ij> ertes, The non-haskell dep issue is under control now. :)
04:23:00 <ertes> ah, great =)
04:24:30 <ertes> ij: basically, if 'pkgs' is nixpkgs, you call pkgs.dockerTools.buildImage { name = "blah"; tag = "0.0"; config.Cmd = ["${myPackage}/bin/mypackage"]; }
04:25:33 <ertes> where, if myPackage is a haskell package, it most likely looks like this:  myPackage = pkgs.haskellPackages.callPackage <my-src/my-package> {};
04:26:54 <ertes> ij: there is one caveat: haskell packages have a *massive* closure right now, so if you do it like this, you will get huge images that include GHC
04:26:57 <piyush-kurur> saurabhnanda: mucking around with Undecidable instances can be a disaster
04:27:04 <ertes> ij: luckily there is a solution
04:27:29 <piyush-kurur> if you have control over the type class you may consider using default Instances
04:28:41 <ij> ertes, Static compiling?
04:29:30 <ertes> ij: that would be one option, yeah
04:29:54 <ij> ertes, There's another one?
04:31:11 <ertes> ij: ideally GHC is turned into a multi-output derivation, but it hasn't been done yet…  the other option is to use a fix-up-wrapper that bakes the dependencies into the executable post-build
04:31:45 <ertes> i can show you the code (it's a one-liner), but you have to be patient, until my git pull is finished =)
04:32:01 <ij> ertes, How would the multi-output derivation work roughly?
04:32:32 <ertes> ij: it creates multiple paths in the store with individual dependencies
04:32:53 <ertes> now pulling in a GHC core library only pulls in that output and only that one's closure
04:33:19 <ertes> ("now" being "when it's done")
04:46:03 * merijn sighs
04:46:16 <merijn> "Thread blocked indefinitely on MVar"...so helpful...
04:50:45 <saurabhnanda> piyush-kurur: isn't this a real problem btw? the problem of typeclass boilerplate?
04:52:11 <piyush-kurur> saurabhnanda: yes much like halting problem is a problem
04:52:19 <piyush-kurur> not much you can do
04:52:22 <saurabhnanda> piyush-kurur: how is this of the same class?
04:52:44 <piyush-kurur> because your typechecker might end up looping
04:53:10 <piyush-kurur> it needs a way to ensure that you are doing well formed derivation
04:53:51 <saurabhnanda> piyush-kurur: THAT is my real problem? Is there a pragmatic solution which we (= compiler devs) are  not even looking at because its not the perfect mathematically correct solution?
04:54:55 <piyush-kurur> UndecidableInstances gives you exactly that
04:55:07 <piyush-kurur> but most of the time if you use it you end up in diaster
04:56:24 <piyush-kurur> saurabhnanda: if you use any of the proof assistants you can see a similar problem even for functions
04:56:31 <piyush-kurur> and data types
04:56:49 <piyush-kurur> You will need them to be total (inductive in the case of types)
04:57:51 <saurabhnanda> I can see the logic of how the instance can be decided, why can't the compiler see it?
04:59:20 <piyush-kurur> saurabhnanda: we are not there yet but may be in a few years Machine learning with solve that problem ;-)
04:59:32 <saurabhnanda> how is this a problem of that scale?
05:00:02 <piyush-kurur> you are asking compilers to decide termination of certain computations?
05:00:07 <piyush-kurur> that is halting problem
05:02:38 <saurabhnanda> HOW is this that problem? That is what I can't understand.
05:03:46 <piyush-kurur> What happens when you enable UndecidableInstances and compile?
05:03:54 <piyush-kurur> does it terminate or not?
05:04:04 <drdo> It's undecidable!
05:06:39 <saurabhnanda> compiler need an instance of typeclass X, it sees if that data type is a direct instance of that typeclass, if it is, then it uses that, else it uses a bunch of specificity based rules to find something.
05:06:49 <saurabhnanda> how is that an undecidable problem?
05:07:04 <saurabhnanda> and even if it is, the compiler can spend 2 mins try and then throw an error
05:07:40 <piyush-kurur> What if it has two options of deriving the same type class? Then how does it choose?
05:08:01 <saurabhnanda> it doesnt -- it throws an error.
05:08:10 <saurabhnanda> but if it doesn't, then it should work, right
05:08:28 <piyush-kurur> enable Undecidable instances and see what you get
05:08:40 <saurabhnanda> why are we making life tougher for programmers for the off-chance that the compiler might not find one exact typeclass instance during compile-time (NOT program runtime)
05:08:59 <saurabhnanda> if required, the programmer can add a manual type annotation to help the compiler decide which instance to use.
05:10:03 <saurabhnanda> piyush-kurur: "if X is an instance of typeclass A, then here is how it is also an instance of typeclass B" -- once this rule is defined, what CAN go wrong in type-class instance resolution?
05:10:21 <mniip> having two of such
05:10:38 <mniip> the same overlapping basically
05:11:11 <saurabhnanda> mniip: and in that case, the compiler can throw an error... and ask the programmer for manual annotations... just how when regular type-inference fails.
05:11:22 <piyush-kurur> saurabhnanda: you are not answering my question. What happend when you enabled UndecidableInstances?
05:11:35 <saurabhnanda> piyush-kurur: 30+ overlapping instance errors.
05:11:37 <mniip> saurabhnanda, well about as much can be achieved with a newtype
05:12:04 <piyush-kurur> How is the poor compiler supposed to choose from those overlapping instances ?
05:12:10 <saurabhnanda> mniip: no, right now I need to define a newtype for every single type that I want to use this for (and there are MANY) vs giving a type annotation for the few cases that result in overlaps.
05:12:30 <saurabhnanda> piyush-kurur: through my rule.... right now there is no way to express this idea in Haskell, is there?
05:12:36 <mniip> you can define a generic newtype
05:12:46 <mniip> heck - even 'newtype N a = N a' will do
05:13:17 <mniip> I mean look at e.g the Down newtype
05:13:17 <saurabhnanda> mniip: why? why more boilerplate? why is every problem in Haskell solved with more type related boilerplate? How is this acceptable?
05:13:32 <merijn> saurabhnanda: Patches welcome
05:13:47 <mniip> uh yes
05:13:50 <mniip> kind of
05:13:57 <saurabhnanda> merijn: I can't submit a patch, but I can make a monetary contribution to someone else who can solve this problem. 
05:14:01 <mniip> to a point where the boilerplate goes into a library
05:14:08 <piyush-kurur> saurabhnanda: You are looking for some way to say use this derification instead of that (to avoid overlappint)
05:14:13 <saurabhnanda> mniip: *this* particular boilerplate cannot go into a library.
05:14:14 <mniip> and that's how programming works
05:14:33 <mniip> I guess XY problem
05:14:41 <ertes> ij: if 'pkgs' is nixpkgs, you can apply pkgs.haskell.lib.justStaticExecutables to the haskell package, before you hand it to pkgs.haskellPackages.callPackage
05:14:53 <saurabhnanda> mniip: please tell me how to move this into a library -- https://mail.haskell.org/pipermail/haskell-prime/2017-June/004283.html -- I'll do that and move on with life.
05:15:25 <ertes> ij: that takes care of making haskell library linking static for executables
05:16:09 <saurabhnanda> piyush-kurur: I'm looking for a way to express this idea -- if a type is an instance of typeclass X, then here is a way to automatically get an instance of typeclass Y
05:16:21 <mniip> saurabhnanda, like I said, XY problem
05:16:28 <saurabhnanda> mniip: what is that
05:17:23 <ertes> saurabhnanda: one's actual problem is X, but instead of explaining that problem one asks about a non-fitting solution Y
05:17:50 <Xion_> You can do   instance (X a) => Y a where    of course.
05:18:01 <saurabhnanda> ertes: does that imply my question is not the original question?
05:18:15 <ertes> saurabhnanda: i don't know, i haven't read the backlog
05:18:23 <saurabhnanda> Xion_: that doesn't work with all the suggested extensions turned on
05:18:44 <ertes> saurabhnanda: it's a bad instance anyway
05:19:02 <ertes> saurabhnanda: that instance is an instance for *all* types
05:19:08 <piyush-kurur> saurabhnanda: you turned on UndecidableInstances and got 300 overlapping instances what does that mean ?
05:19:46 <saurabhnanda> piyush-kurur: giving you a gist on github, please wait
05:20:09 <saurabhnanda> ertes: and that's the original problem I'm trying to solve ... if a type is an instance of typeclass X, then here is a way to automatically get an instance of typeclass Y -- there is no way to express this idea in Haskell
05:20:11 <piyush-kurur> okey but answer my question 
05:21:18 <piyush-kurur> saurabhnanda: what do you learn from the fact that there are 300+ overlapping instances ?
05:22:08 <saurabhnanda> piyush-kurur: https://gist.github.com/saurabhnanda/edbe9b03e2e8180b2c78830ec226b250
05:23:54 <piyush-kurur> saurabhnanda: well the error message is saying exactly why it is having a problem
05:24:13 <piyush-kurur> How are you going to resolve the FromJSON of Int64 ?
05:24:26 <piyush-kurur> Which of the multiple instances should the compiler choose?
05:25:51 <ertes> saurabhnanda: no, that's not the actual problem…  an actual problem is related to a particular solution you're writing
05:26:29 <ertes> saurabhnanda: this is a meta-problem, and one that is better left unsolved
05:27:01 <ertes> you can have that instance with enough extensions, but it doesn't behave the way you seem to think it does
05:27:49 <ertes> again:  instance (C a) => D a  -- this is an instance *for all* 'a'
05:27:58 <ertes> not just for those 'a' that have an instance (C a)
05:28:36 <saurabhnanda> ertes: I understand that now, but my question is why should the idea that I'm proposing be unsolvable in Haskell. I understand that the correct sytax implies something else, but can a new syntax imply something completely different?
05:30:04 <piyush-kurur> saurabhnanda: how should the compiler resolve when there are multiple instances ?
05:30:09 <piyush-kurur> applicable
05:30:34 <piyush-kurur> there is no correct solution here
05:30:59 <piyush-kurur> The fact that you ended up triggering overlapping instances means that you have a problem in the design
05:31:20 <ertes> saurabhnanda: i can't tell you why exactly this is a bad idea, but if you explain the actual problem you're trying to solve, we can surely provide a cleaner alternative
05:32:16 <saurabhnanda> piyush-kurur: so two levels of problems here
05:34:07 <saurabhnanda> first is, that the current syntax expresses a different idea which may be resulting in these overlapping instances. That's a limitation of the language.
05:34:28 <saurabhnanda> second is, can there be a new syntax, which helps one express this idea? If no, why not?
05:34:33 <piyush-kurur> saurabhnanda: wrong
05:34:38 <piyush-kurur> it is not a syntax issue
05:34:53 <piyush-kurur> it is a semantics issue on how typeclasses should be resolved
05:35:44 <piyush-kurur> Think of it like this. Suppose you have an expression ...(show y)...
05:36:05 <piyush-kurur> the compiler needs to figure out which show is to be used at that point.
05:36:25 <piyush-kurur> For which it needs to search the instances which match the types of y
05:36:43 <ertes> saurabhnanda: the syntax expresses exactly what's going on…  you're just assuming a different instance resolution semantics
05:36:57 <piyush-kurur> when there are overlapping instances (potentially doing different things) how is going to know which "show" to use
05:37:02 <SepakoRayl> guys, has anyone worked with the pretty-show package?
05:37:24 <ertes> instance (C a) => D a  -- any usage of D's members will still cause the constraint to be checked
05:37:56 <saurabhnanda> (please continue -- wrt syntax I meant that the current syntax expresses a certain meaning)
05:37:59 <ertes> in other words the "=>" should not be read as "an instance of this implies an instance of that", but more like: "the instance to the right depends on the instances to the left"
05:38:08 <ertes> it's a dependency arrow, not an implication arrow
05:38:09 <sproingie> i wish instances were named, then you could tell it which instance to use
05:38:49 <piyush-kurur> sproingie: agda's instance arguments do something like that
05:38:51 <sproingie> i suppose there's newtypes, but that's not entirely satisfying
05:39:07 <Xion_> Or type tags.
05:39:38 <ertes> sproingie: named instances aren't really better…  they are inconvenient in a different way, unless there is still a mechanism for unnamed/"default" instances
05:39:50 <saurabhnanda> ertes: I understand that now. That was the first problem that I was referring to. I can't understand why we can't have a "<=" operator which means that "if instance of X, then here is how you get instance of Y"
05:39:58 <piyush-kurur> although in a agda like setting sometimes you need to give explicity the instances that you are talking about
05:40:14 <saurabhnanda> piyush-kurur: why are manual type annotations in the case of overlapping instances an unaccpetable solution to this problem?
05:40:34 <piyush-kurur> saurabhnanda: manual type annotation of what?
05:40:48 <saurabhnanda> ertes: exactly. if no overlaps, then no need for extra type annotations, if overlap then you need to specify which instance to use.
05:40:55 <saurabhnanda> piyush-kurur: about which instance to use.
05:41:09 <sproingie> currently not possible
05:41:27 <ertes> saurabhnanda: idris has something like that, i think
05:41:59 <piyush-kurur> saurabhnanda: that is what is available in agda (well agda does not have type classed but instance arguments)
05:42:22 <saurabhnanda> so, this IS a solvable problem, but haskell does NOT solve it. Therefore, am I right to submit this idea to haskell-prime?
05:42:37 <saurabhnanda> does this deliver better programmer UX?
05:42:48 * sproingie twitches
05:42:48 <saurabhnanda> does this move the language forward in terms of productivity?
05:43:06 <piyush-kurur> saurabhnanda: there will be otherplaces you will complain then about having to explicitly say which instance you use
05:43:19 <merijn> haskell-prime is mostly about standardising things that are already implemented, not new changes
05:43:40 <saurabhnanda> piyush-kurur: but type annotation is required only if there are overlaps. How will this be a worse situation than the current situation?
05:43:49 <sproingie> suggesting it as an extension will, far as i know, meet a receptive audience who will say "cool, go ahead and implement it"
05:43:56 <ertes> saurabhnanda: you can submit it, but it would be a massive language change, and that's a hard sell…  they couldn't even bring themselves to get FlexibleContexts or even just TupleSections into the standard for h2010 =)
05:44:06 <ertes> haskell is an annoyingly slow changer
05:44:32 <saurabhnanda> all the haskell goodness is killed by two and two things alone -- boilerplate and records.
05:44:43 <saurabhnanda> it just KILLS all the joy of building anything in Haskell.
05:44:43 <merijn> says you
05:45:00 <ertes> personally i would make half of GHC's extension catalog standard
05:45:13 <sproingie> *all* the joy, eh?  to me the record problems are a wart but not a deal-breaker
05:45:16 <saurabhnanda> merijn: why, you have a longer list?
05:45:21 <piyush-kurur> saurabhnanda: If you have Module A in which there is no overlap but Module B in which there is an overlap and where you choose the one that is not in A then what?
05:45:30 <merijn> saurabhnanda: No, I rarely have boilerplate or record issues
05:45:41 <piyush-kurur> So the same type will have on instance in A and another in B
05:45:43 <merijn> records are a minor wart, boilerplate I never really have issues with, tbh
05:46:07 <saurabhnanda> sproingie: how do yo solve this problem? web API takes a record with 10 fields, saves it to DB and the resulting record has those 10 fields PLUS 8 extra fields. How many record types and related boilerplate do you need?
05:46:10 <ertes> yeah, boilerplate hasn't been a problem for me either
05:46:14 <piyush-kurur> and when you mix them missiles will be launched
05:46:18 <sproingie> ocaml and elm both have pretty nice record update syntax.  elm's could be stolen pretty easily, but lens is currently the big winner
05:46:34 <ertes> records…  well, i just wish we had ad-hoc overloading
05:46:43 <ertes> but i just prefix the field names, and that's it
05:46:46 <merijn> ertes: Rowtype polymorphism!
05:47:01 <merijn> My solution is to stay the hell away of anything "web" :p
05:47:14 <piyush-kurur> merijn: yes Row polymorphism would be great
05:47:15 <saurabhnanda> ertes: that's not it. Because then you create lenses and you STILL end up with https://www.reddit.com/r/haskell/comments/6edvz7/practical_problem_how_do_you_avoid_having_to/?utm_content=title&utm_medium=user&utm_source=reddit
05:47:25 <ertes> merijn: or that, but simply adding ad-hoc overloading would be good enough for a lot of problems, including disambiguating imports
05:47:37 <saurabhnanda> piyush-kurur: didn't completely understand the question.
05:48:01 <sproingie> i thought there already were overloaded labels in ghc
05:48:15 <saurabhnanda> is there like a bleeding edge, Get Shit Done Haskell somewhere? Or is that basically OCaml or Purescript?
05:48:15 <piyush-kurur> saurabhnanda: Say there is a type Foo which has a unique instance in A but multiple overlapping instances in B
05:48:23 <merijn> saurabhnanda: hah
05:48:36 <piyush-kurur> this can happen because A might not be importing some module that B imports
05:48:37 <merijn> saurabhnanda: Do you honestly think OCaml has *less* issues than Haskell?
05:48:47 <saurabhnanda> piyush-kurur: let me rephrase my understanding -- type Foo has an instance of typeclass A, and two possibly overlapping insnaces of typeclass B?
05:48:53 <merijn> saurabhnanda: If anything OCaml is going to be *less* Get Shit Done
05:48:56 <sproingie> i'd humbly suggest that if you can't get shit done in language Foo, perhaps you really ought to use another language
05:48:57 <piyush-kurur> No no
05:49:12 <sproingie> i can't get shit done in any language these days, so it's all a wash :)
05:49:30 <ertes> wait…  arrow notation supports leaving off the "-<" part?
05:49:53 <piyush-kurur> I meant type (okey let me change the notation) T is instance of class C uniquely in Module M1 and in an overlapping in module M2 
05:50:00 <piyush-kurur> then what do you do ?
05:50:34 <mnoonan_> merijn: is there a trip report to that effect out there somewhere? I’m attempting to get some Haskell uptake at work, and a recurring pushback theme is “well, if we’re going to go in that direction, maybe ocaml is less risky?”
05:50:40 <sproingie> i do wish import could control visibility of instances just to make them behave like everything else
05:50:54 <sproingie> again, would need names
05:50:54 <saurabhnanda> piyush-kurur: module M1 has an instance of class C for type T; module M2 ALSO has an instance of class C for type T -- is that what you mean?
05:50:54 <ertes> saurabhnanda: those definitions look like they would fit nicely into a type class
05:51:06 <merijn> mnoonan_: I don't think so. But it boils down to "haskell has a far more active and larger community"
05:51:08 <piyush-kurur> No no
05:51:19 <merijn> mnoonan_: I mean, OCaml has basically Jane Street and, well, that's it
05:51:22 <ertes> saurabhnanda: not themselves, but just abstract over the differences and write a type class, then just write a single 'fetchById'
05:51:32 <saurabhnanda> ertes: which definitions?
05:51:39 <merijn> mnoonan_: Although, honestly, depending on what you're using now, I'd settle for OCaml if that gets things changed now
05:51:44 <saurabhnanda> piyush-kurur: aaargh!
05:51:44 <mnoonan_> merijn: that’s been my approach so far (though I’m not sure I’ve even convinced anybody on that yet, despite the stats seeming pretty clear)
05:51:46 <sproingie> ocaml is a fine language.  it does have its own warts of course.
05:51:47 <piyush-kurur> in M1 due to the way it imported other modules T has a unique instance 
05:52:11 <piyush-kurur> Where has in M2 due to the way it imported other modules T has multiple overlapping instances of C
05:52:38 <piyush-kurur> then what is your solution when some other module M3 combines M1 and M2
05:53:02 <sproingie> purescript is also fairly exciting, after the letdown of elm
05:53:46 <piyush-kurur> In fact coming to think of it it is fairly bad even if M3 did not import M1 and M2
05:54:01 <saurabhnanda> piyush-kurur: then the code where T is using and a an instance of C is required, needs to provide an explicity annotation
05:54:17 <mnoonan_> merijn: the part I’m currently slated to modernize is in a off-brand scheme dialect, so it’s true that anything would be an improvement to maintainability.
05:54:21 <piyush-kurur> both M1 and M2 uses instances of T
05:54:34 <piyush-kurur> in M1 it will automatically resolve
05:54:43 <saurabhnanda> piyush-kurur: yes, what's the problem?
05:54:51 <piyush-kurur> in M2 you will need to give an annotation
05:55:10 <piyush-kurur> What if you gave an annotation in M2 that is not consistent with the default one choosen in M1
05:55:40 <piyush-kurur> the same type for the same class behaves differently in two different modules
05:56:15 <piyush-kurur> smells like python to me
05:57:25 <sproingie> unless you're doing strange things with ABC's, i doubt this would crop up in python
05:58:14 <saurabhnanda> piyush-kurur: firstly, if my super-exciting proposal is implemented, then the definition of overlapping will not be what you're probably assuming right now. "class (A x) => (B x)" is NOT what we are talking about. it's "class (A x) //> (B x)" is what we are talking about. and in this case overlaps are possible only if we have "class (C x) //> (B x)"  
05:59:26 <sproingie> what's //> ?
05:59:40 <piyush-kurur> Overlapping instances is a problem always because you are resolve in different ways in different parts of the code
05:59:44 <piyush-kurur> that will be a nightmare
06:00:07 <saurabhnanda> sproingie: my new super-intelligent operator :) 
06:00:33 <saurabhnanda> piyush-kurur: okay, now I see your point. Partially.
06:01:44 <saurabhnanda> let me think about this more.
06:01:48 <piyush-kurur> saurabhnanda: the other solution to modularity is structures as in ML
06:01:57 <saurabhnanda> btw, what's the best way to solve this boilerplate for me and move on with life, right now?
06:02:15 <piyush-kurur> saurabhnanda: link to the actual code ?
06:05:29 <saurabhnanda> piyush-kurur: https://gist.github.com/saurabhnanda/edbe9b03e2e8180b2c78830ec226b250#file-original-code-hs
06:05:37 <saurabhnanda> piyush-kurur: file called 'original-code.hs'
06:06:32 <saurabhnanda> piyush-kurur: and this is the boilerplate I'm trying to remove -- https://gist.github.com/saurabhnanda/edbe9b03e2e8180b2c78830ec226b250#file-original-code-hs-L62-L77
06:06:37 <Gurkenglas> Can Control.Lens.TH give me lenses for "data Foo = Foo String Int"-type definitions?
06:07:11 <piyush-kurur> saurabhnanda: https://news.ycombinator.com/item?id=10300213 for some of the similar discussion and see what can go wrong if there is no coherence in type instances
06:09:27 <piyush-kurur> saurabhnanda: exactly which class there is the culprit
06:10:11 <saurabhnanda> piyush-kurur: the new code that I've shared doesn't have any overlapping instances, etc. This is my original problem. Trying to remove that boilerplate. I have 30+ types for which I have to do this. What's a possible solution for me?
06:12:30 <piyush-kurur> You do not want to define those individual FromJSONs, ToJSONs  etc 
06:12:31 <piyush-kurur> ?
06:13:18 <saurabhnanda> yes
06:13:34 <saurabhnanda> this will only grow by a factor of n x m (n = types, m = type-classes)
06:13:56 <piyush-kurur> If you are using Aeson then I though if you derive Typeable (or was it something else) then you can just used an  instance FromJSON
06:13:59 <saurabhnanda> every single interface in haskell requires typeclasses -- DB, JSON, Serialize, HTML, etc
06:15:53 <piyush-kurur> But I do not see how you are solving it by having a super mega class
06:16:48 <hariel> wheres the stack directory on windows
06:17:11 <piyush-kurur> saurabhnanda: If i understand you correctly for all the types that you have you want to define DB, JSON, Serialse etc ? 
06:17:24 <saurabhnanda> yes
06:17:44 <saurabhnanda> using special rules that depend on the shape of the type -- those rules I can define via Generics -- managed to figure that much out.
06:18:10 <piyush-kurur> this could be a fit case of template haskell 
06:19:38 <saurabhnanda> piyush-kurur: and how I wish write TH was as simple as writing lisp macros.
06:20:32 <merijn> What's hard about TH?
06:20:43 <saurabhnanda> piyush-kurur: anyways, basically TH is the answer to all boilerplate reduction in Haskell. I'm slowly understanding why Yesod is build the way it is. that's the only way to get things done in Haskell.
06:21:01 <saurabhnanda> merijn: comapred to lisp macros?
06:21:12 <merijn> Compared to any meta-programming tool
06:22:19 <piyush-kurur> saurabhnanda: TH is the answer to certain kinds of boilerplate reduction in Haskell. The others are reduced (compared to C C++ etc) via having just flexible type system. 
06:22:25 <piyush-kurur> ;-)
06:22:53 <saurabhnanda> merijn: I can compare to lisp macros -- and it's probably 10x more complex than lisp macros.
06:23:04 <merijn> saurabhnanda: In what way?
06:23:27 <saurabhnanda> merijn: "getting shit done... fast" way :)
06:23:53 <saurabhnanda> merijn: kinda hard to explain... the whole building the AST by hand in Haskell
06:24:23 <piyush-kurur> saurabhnanda: and when shit hits the fan, spend life time cleaning up
06:25:11 <saurabhnanda> piyush-kurur: not really... because in lisp you have macro-expand... easily see what the macro expanded to ... fix your bug, and move on
06:25:22 <saurabhnanda> TH doesn't allow to inspect the expansions very easily
06:25:34 <merijn> saurabhnanda: You don't build the AST by hand, you just write regular code and quasi-quote it into an AST
06:25:47 <saurabhnanda> you gotta do a complete build with -ddump-splices and see what was generated after sifting through piles of nonsense.
06:27:27 <piyush-kurur> saurabhnanda: but your case is pretty simple TH
06:28:10 <saurabhnanda> actually let me try simply generating the actual code and splicing it in via a quasi-quoter... might be by pragmatic solution right there.
06:29:07 <piyush-kurur> @type ppr
06:29:09 <lambdabot> error: Variable not in scope: ppr
06:29:33 <piyush-kurur> @type Language.Haskell.TH.ppr
06:29:34 <lambdabot> Language.Haskell.TH.Ppr.Ppr a => a -> Language.Haskell.TH.PprLib.Doc
06:29:36 <merijn> hmmm, no persistent examples connecting to multiple databases simultaenouslY?
06:30:37 <piyush-kurur> saurabhnanda: to print simple TH code you can use the Language.Haskell.TH.ppr function 
06:31:35 <saurabhnanda> merijn: did you figure out using logger in multi-threaded env? what's the solution you used?
06:32:13 <merijn> saurabhnanda: I'm just logging to stderr in parallel for now
06:32:22 <merijn> I might use a dedicated logging thread in the future
06:33:39 <merijn> It's a bit annoying that there's no "SqlBackend -> SqlReadBackend" to turn a backend read only :\
06:34:35 <opqdonut> can you just unsafeCoerce it?-)
06:36:12 <merijn> oh, actually I probably can
06:36:30 <merijn> But I might not even need to
06:37:48 <quchen> ?tell ReinH First draft of a simple JSON API is here: http://lpaste.net/774650433334411264
06:37:48 <lambdabot> Consider it noted.
06:38:28 <quchen> ?tell ReinH Most things that are not STG AST are in JSON format; STG AST itself is pre-rendered as HTML with semantic class annotations. Is that something you can work with?
06:38:28 <lambdabot> Consider it noted.
06:39:22 <quchen> ?tell ReinH I’ve added you as a collaborator on Github in case you want to develop it there :-)
06:39:22 <lambdabot> Consider it noted.
06:46:35 * hackage versions 3.1.0.1 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.1.0.1 (fosskers)
06:53:46 <merijn> opqdonut: ugh, constructor is not exported, so I can coerce it. unsafeCoerce should work, but that's not very future proof
06:56:01 <merijn> Which is unfortunate. I wanna run a bunch of queries and mark it as read-only from then on, but that's not possible
07:04:17 <saurabhnanda> if I have to create a type which encapsulates: (a) the underlying core type, (b) the default value, and (c) a field name (string) from which this value has to be read -- to be later used in generic programming to build serialisation/deserialisation interfaces -- what's a good building block?
07:06:15 <mekeor> ima noob and i dunno if i got you correctly but why not something like:   data Encapsule t = Encapsulated { value :: t, defaultValue :: t, fieldName :: t }
07:06:24 <mekeor> saurabhnanda: ^
07:07:20 <saurabhnanda> hmmm, won't work in the next step
07:22:11 * hackage hakyll 4.9.6.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.9.6.0 (JasperVanDerJeugt)
07:37:08 * hackage conduit 1.2.11 - Streaming data processing library.  https://hackage.haskell.org/package/conduit-1.2.11 (MichaelSnoyman)
07:37:34 * hackage dejafu 0.7.0.1 - Systematic testing for Haskell concurrency.  https://hackage.haskell.org/package/dejafu-0.7.0.1 (barrucadu)
07:44:21 <SepakoRayl> these patterns are so much nicer than wrapper functions.
07:44:32 <orion> Value is to Type as Type is to Kind. Type is to Kind as Kind is to ???
07:44:53 <lyxia> Sort?
07:47:19 <opqdonut> as Kind is to Kind
07:47:25 <opqdonut> IIRC, in Haskell currently
07:47:31 <sproingie> sorts in some languages, kinds in haskell
07:47:54 <cocreature> it’s types all the way up
07:47:59 <cocreature> (sadly not)
07:48:05 <cocreature> (yet)
07:49:18 <vonivgol> hello all
07:49:34 <orion> Is there a mathematical difference between Values and Types? In other words, if you can solve a puzzle on the value level, can you solve that same puzzle on the type level, for all puzzles?
07:49:46 <sproingie> grand unified system would be what, associated values?  where types are particular symbols?
07:50:07 <sproingie> or does there always have to be some kind of distinction to be meaningful?
07:50:42 <vonivgol> I've got problem with installing one package using cabal. It says: "Unsupported extension: DeriveAnyClass". What should I do?
07:50:59 <tdammers> I need some lens fu
07:50:59 <cocreature> vonivgol: which version of GHC are you using?
07:51:13 <sproingie> upgrade ghc.  the package really should have given a version constraint, so it's a bug in the package
07:51:22 <tdammers> I have a function that takes a lens and does stuff in a MonadState
07:51:27 <vonivgol> I use 7.8.4
07:51:56 <tdammers> doThing :: MonadState Blah m => Lens' Blah Foo -> m ()
07:52:34 <tdammers> but now I have a lens like Lens' Blah [Foo], and I want to run doThing on every element of the list of Foos
07:53:12 <sproingie> i think DeriveAnyClass is 8.0
07:53:33 <tdammers> so I gues what I need is Lens' a [b] -> Lens' a b; or, alternatively, Lens' a [b] -> [Lens' a b]
07:53:55 <vonivgol> Ok, I'll update my old ghc...
07:54:12 <sproingie> might send a bug report to the package maintainer too
08:02:39 <orion> I have the following types: data Foo = A | B | C, data A, data B, data C, data Bar a. I have the following function: mkBar :: BarClass a => Foo -> Bar a. Is what I want to do impossible?
08:03:34 <lyxia> What do you want to do
08:03:52 <tdammers> orion: depends what you want. If you want to select a different a based on the value of Foo, then no, you can't do that
08:05:26 <orion> I use aeson to parse a file, e.g. "{"foo": "A"}. I wrote a FromJSON instance to take me from ByteString -> Foo. I want to call a function such as mkBar to construct a Bar.
08:06:22 <orion> The type attached to Bar is directly dependent on the value from the JSON file.
08:06:41 <orion> I've done some reading, and I found edwardk's reflection library, but it seems a bit esoteric.
08:06:45 <tdammers> a function cannot change its return type based on input values
08:06:56 <c_wraith> orion: you can use an existential and a GADT instead
08:07:08 <orion> tdammers: But it has a dictionary because of the class constraint.
08:07:08 <tdammers> that's because Haskell is not a dependently-typed language, i.e., types cannot depend on values
08:07:32 <c_wraith> orion: http://lpaste.net/355742 for example
08:07:35 <tdammers> you can either have data Bar = BarA A | BarB B | BarC C
08:07:48 <c_wraith> orion: that's a trivial case of parsing a value whose type depends on the parser
08:07:55 <tdammers> or you can have data SomeFoo = SomeFoo { unFoo :: forall a. a }
08:07:59 <c_wraith> err, whose type depends on the data
08:08:40 <orion> c_wraith: I recall doing this in the past, but I'm wondering if there is a more modern way, such as the reflection library.
08:09:22 <c_wraith> orion: everything about that is harder.  :)  If you want simpler...  wait for Dependent Haskell to give us better tools to describe the types involved.
08:09:57 <orion> c_wraith: In your paste, would you consider the GADT to be a form of "type erasure", or is that the wrong term?
08:10:22 <c_wraith> orion: the existential is more like type erasure.  The GADT allows recovery of the type at runtime.
08:10:52 <orion> I see. My understanding is that Haskell never keeps track of types at runtime. Is that true?
08:11:14 <c_wraith> Yes.  But it's misleading. :)
08:11:48 <c_wraith> GADTs allow you to say "well if this constructor matches, we know the type must be this, so type checking can proceed given that knowledge"
08:12:24 <c_wraith> The types don't exist at runtime.  But the branches allow things with different compile-time types, as long as they all fit together the right way at the end.
08:12:41 <orion> I see.
08:26:35 * hackage th-abstraction 0.2.0.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.2.0.0 (EricMertens)
08:27:35 * hackage BioHMM 1.2.0 - Libary for Hidden Markov Models in HMMER3 format.  https://hackage.haskell.org/package/BioHMM-1.2.0 (FlorianEggenhofer)
08:29:18 <sproingie> hidden markov models eh?  strange how antispam and bioinformatics overlap.
08:29:44 <sproingie> both about discovering patterns in long strings i guess
08:31:39 <sproingie> runtime isn't typed, but if you're using type classes it does pass around dictionaries in a rather OOP late-binding fashion
08:32:39 <maerwald> almost OT: anyone good with PROMELA/SPIN? Can't even find an IRC channel for that. I'd guess if anyone likes formal methods, it should be haskellers
08:36:50 <sproingie> seems the forum at http://spinroot.com/fluxbb/ would be the best place to look
08:38:09 <maerwald> except you can't register there
08:38:39 <sproingie> dunno then
08:41:34 <vonivgol> I finally installed telegram-api package using cabal! Thank you so much <3
09:02:55 <mac10688> It bugs me when people write a little bit of C code in their haskell apps. I can understand that some languages are faster than others, but if haskell is so slow that they feel the need to write some c worries me
09:03:37 <Athas> mac10688: Haskell is indeed slow for some things.  But often the C is for glue to C libraries.
09:04:08 <glguy> mac10688: It should worry you that it worries you
09:08:25 <ongy> playing around with raw memory stuff in haskell can be, weird
09:08:48 <ongy> so sometimes it's just easier. Though I'm used to doing the "C in haskell" stuff
09:10:18 <c_wraith> Also, note that some libraries add C-- primops for direct memory access.  C-- is not C.
09:14:34 <sproingie> long as the OS is in C, there's going to be C glue
09:15:40 <mac10688> thanks for the comments guys, I was wondering what other thoughts were
09:15:44 <sproingie> (and if it's not in C, it had better have a really good ABI)
09:16:04 <orion> How difficult would it be to make a new POSIX standard based on Haskell instead of C?
09:16:15 <ongy> sproingie: well, syscalls aren't even C calling convention
09:16:26 <mac10688> I think since I don't know much C, I'll try to use Rust when possible
09:16:31 <mac10688> that would be a dream of mine
09:16:34 <c_wraith> orion: well - it might be easier to relocate Mt. Everest to Canada.
09:16:34 <sproingie> ongy: true, but that's an example of a well-established ABI
09:17:05 <sproingie> though arguably not a very good one
09:17:22 <ongy> it's hardware dependant, isn't it?
09:18:13 <ongy> orion: There's a lot of RTS baggage to any haskell api you want to be integrated into non haskell applications, so that's probably a bad idea. even for people that like haskell for what it's good at
09:18:26 <sproingie> hardware dependent and lacking a reasonable abstraction on top, unless you're talking microkernels
09:19:18 <orion> ongy: What if you assume that every single application running on the OS is written in Haskell?
09:19:37 <ongy> orion: then it's about your specific OS and you don't need posix :)
09:20:00 <orion> heh, alright
09:20:14 <sproingie> assuming your apps expose everything in the OS, which is unlikely
09:20:38 <freeside> moo.
09:21:05 <sproingie> μ
09:21:37 <ongy> we'd first have to properly define OS boundaries
09:23:01 <sproingie> posix is pretty much tied to C.  i wouldn't want a haskell-specific standard either, just one based on better types
09:24:16 <sproingie> but then yeah, boundaries.  you'd want something much smaller than posix.
09:26:04 <ReinH> mac10688: How do you know that the C in question is there because Haskell is too slow?
09:26:43 <ReinH> @tell quchen Fantastic, I'll take a look this weekend!
09:26:43 <lambdabot> Consider it noted.
09:30:16 <exbri> Hi! Is anyone here willing to answer some questions about Data Structures? 
09:30:43 <freeside> answer: no, you don't need to create a new monad
09:31:07 <kc235> Does anyone know if it's possible to install haskell-platform in an alternate partition with yum (restricted sudo).
09:31:08 <cocreature> exbri: asking your question directly usually works better
09:31:21 <exbri> ok
09:32:43 <sproingie> kc235: should work as well as any other yum package, sure
09:32:59 <sproingie> kc235: though these days we tend to prefer stack over H-P
09:33:39 <sproingie> and stack requires no special permissions
09:34:15 <exbri> i have a structure data B-tree a = Nil j Block fleftmost :: B-tree a; block :: [(a; B-tree a)]g deriving (Show; Eq), which i need to represent in haskell. I have defined inB-Tree to create this structure, now i need to define outB-Tree. The problem is I don't know how to express the list of (a,BTree a) in the out function.
09:34:19 <kc235> What is stack at the risk of sounding stupid
09:34:46 <sproingie> something like rvm or nvm, but for haskell
09:35:00 <sproingie> curl -sSL https://get.haskellstack.org/ | sh
09:35:20 <kc235> oh gotcha
09:35:23 <cocreature> it’s a lot more than rvm or nvm. it manages GHC installations but it also builds projects
09:35:58 <kc235> Will have to see if that package is available here at work. I know the haskell-platform is mirrored
09:35:59 <c_wraith> I'm not a fan of stack.  I guess it could be ok for building applications, but it's awful for building libraries.  It encourages you to release libraries with broken version dependencies without ever noticing the problem.
09:36:02 <sproingie> for installation purposes it's analogous.  also supercedes the cabal tool suite, or aims to
09:36:16 <sproingie> stack is definitely a work in progress.  handles installations fine though.
09:36:57 <sproingie> c_wraith: stack in fact encourages dependencies that work with stackage version.  so it's kind of the exact opposite of that claim.
09:37:30 <c_wraith> sproingie: then why do so many packages that say "best installed with stack" utterly fail to work with cabal due to incorrect version bounds?
09:37:35 <sproingie> libraries used to break all the time because they had dependency graphs that were snowflakes
09:37:39 <SepakoRayl> exbri, can you use lpaste and I can look at it
09:37:40 <sproingie> that's not the case on stackage
09:37:47 <cocreature> sproingie: as long as you use that stackage snapshot. hackage doesn’t know which stackage snapshot you used locally after you’ve uploaded your package
09:37:50 <c_wraith> Right, but why would I use stackage?
09:38:02 <sproingie> c_wraith: probably because your cabal setup is a snowflake too.  that's the point of stack is to avoid that
09:38:26 <sproingie> you use stackage when you use stack. you opt out of it by adding extra-deps to stack.yaml
09:39:04 <sproingie> i agree hackage doesn't know enough about stackage
09:39:09 <kc235> I dont think the stack package is available to me
09:39:15 <kc235> at least at work
09:39:24 <sproingie> so don't use a package, use the installer script
09:39:37 <cocreature> kc235: you don’t need to be root to install it. you can just download a standalone binary
09:40:01 <kc235> we have a company intranet
09:40:06 <sproingie> there is a yum package for stack if you want, have to add the repo yourself
09:40:16 <kc235> we can only use things mirrored on the intranet
09:40:23 <sproingie> then your company is fucking stupid
09:40:35 <kc235> you aren't wrong
09:40:49 <sproingie> what you have isn't really a technical problem then
09:40:58 <freeside> why not mirror lts?
09:41:07 <sproingie> or just use the shell installer, it's not like they can stop you
09:41:23 <sproingie> if they threaten you for it, again not a problem solveable with tech
09:41:47 <sproingie> it all installs in $HOME anyway
09:41:50 <exbri> SepakoRayl http://lpaste.net/356145
09:42:23 <exbri> i can provide some of the already defined catamorphisms we were given
09:43:03 <exbri> the definition of outB-Tree was written by me but I'm sure it's wrong
09:43:43 <kc235> the thing that's really annoying is part of the haskell compiler package is installed by default on the vm, but it's outdated and doesn't have libraries like Data.Containers
09:44:18 <kc235> and the hackage mirror seems to be down indefinitely
09:44:31 <kc235> internal mirror
09:48:03 <sproingie> hackage should get cracking on a better mirroring story
09:48:52 <sproingie> stackage seems no better there
09:49:46 <cocreature> hackage just got a better story for mirrors. what are you still missing?
09:50:12 <sproingie> the word 'mirror' on the hackage home page.  preferably attached to "how to create a mirror"
09:50:21 <sproingie> 'rsync' would also work
09:51:15 <cocreature> fair enough. better docs would definitely be good
09:54:15 <SepakoRayl> soz was afk
09:55:25 <exbri> I sent you a private msg, dunno how that works here
10:33:29 --- mode: ChanServ set +o cocreature
10:34:54 <ph88^> is there syntax for     bla <- action  ;   case bla of ..     so that i can skip the  <- part ?
10:35:06 <johnw> action >>= \case ...
10:36:09 <geekosaur> requires LambdaCase extension
10:36:18 --- mode: ChanServ set -o cocreature
10:36:36 <johnw> I like not naming things that don't need names
10:37:00 <EvanR> idris case !action of
10:37:40 <ph88^> what comes after \case  ?
10:37:46 <EvanR> newline
10:37:50 <ph88^> oh
10:37:53 <johnw> \case Nothing -> ...; Just x -> ...
10:40:10 <ph88^> it's great johnw, cleans up the code a lot
10:41:18 <ph88^> when i have a conduit and i want to split it into two different outputs, is it better to use two continuation conduits or just use a tuple ?
10:57:05 * hackage yaml-union 0.0.2 - Read multiple yaml-files and override fields recursively  https://hackage.haskell.org/package/yaml-union-0.0.2 (michelk)
10:57:23 <qmm> liquid haskell isn't built on top of ghc, is it?
10:57:51 <johnw> qmm: what do you mean?
10:58:14 <qmm> i am wrong, it does build for an older ghc
10:58:38 <EvanR> builds on top of, builds for
10:59:19 <qmm> it would be nice to have totality checking. i was looking into this just now and came across liquid haskell
11:09:21 <orion> Hmm, I just came across this GHC error: "My brain just exploded I can't handle pattern bindings for existential or GADT data constructors."
11:09:51 <byorgey> orion: congratulations, you just gained 1024 XP
11:10:18 <byorgey> incidentally, it is SPJ's brain that is exploding, not GHC's
11:11:04 <shapr> byorgey: ha!
11:11:21 <byorgey> orion: the solution is to rewrite (possibly using a helper function) so that you pattern-match in a function definition rather than using a let
11:12:09 <byorgey> an explicit 'case' works too
11:13:32 <ReinH> byorgey: ah, a nice round number
11:13:49 <byorgey> this has to do with lazy vs strict pattern matching.  There is a nice explanation at https://stackoverflow.com/questions/23531566/odd-ghc-error-message-my-brain-just-exploded
11:13:55 <byorgey> ReinH: =)
11:14:04 * hackage google-oauth2-jwt 0.2.2 - Get a signed JWT for Google Service Accounts  https://hackage.haskell.org/package/google-oauth2-jwt-0.2.2 (MichelBoucey)
11:14:33 <qmm> is this the recommended method of using markdown in literate haskell? https://github.com/sol/markdown-unlit i came across this work as well, https://ghc.haskell.org/trac/ghc/wiki/LiterateMarkdown except i don't know if it's merged into ghc
11:14:48 <EvanR> i wish that answer didnt complicate things by talking about dictionary passing
11:15:21 * shapr passes a dictionary on the highway
11:28:37 * hackage wolf 0.3.18 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.18 (markfine)
11:29:59 <orion> byorgey: I used an explicit case, but now I'm getting a skolem error: https://gist.github.com/centromere/82cb9f0952a34da85469a8b40cf8ad95
11:31:24 <cocreature> orion: what type do you expect the case expression to have?
11:31:42 <n_blownapart> hi is this a good definition of x <- xs  ? I had no idea it was referring to epsilon. A bit confused about this and car/cdr written like this x:xs  thanks   http://lpaste.net/356146
11:33:05 <monochrom> Yes.
11:33:36 <ab9rf> more or less, yes
11:33:40 <yamadapc> I'm trying to compile HaXml on windows with Stack, but I get "lexical error in string/character literal at character '\r'", has anybody faced this issue when compiling on Windows and knows of a solution? I'm using cygwin but I don't know anything about it
11:34:19 <yamadapc> Ah, appveyor build fails too https://ci.appveyor.com/project/yamadapc/jats2tex
11:35:02 <geekosaur> sounds to me like the source files need to have unix-style newlines instead of windows-style
11:36:15 <monochrom> That is strange. Why would a program on Windows hate to see \r ? :)
11:36:28 <ab9rf> monochrom: cygwin pretends not to be windows
11:36:35 <monochrom> ah
11:36:39 <ab9rf> my guess is that someone used notepad on a file 
11:37:42 <geekosaur> yes, that exactly
11:37:53 <monochrom> But GHC is happy about \r , even when on Windows.
11:37:58 <geekosaur> cygwin aggressively pretends to be linux (and aggravatingly fails)
11:38:06 <yamadapc> Both fail though
11:38:44 <nshepperd_> Even Linux shouldn't fail on \r though... It's just whitespace
11:38:47 <byorgey> orion: right, you cannot let existentially quantified type variables escape.
11:39:14 <byorgey> The last time one escaped, it destroyed several city blocks.  The cleanup cost several billion, not to mention all the memories that had to be altered
11:39:18 <monochrom> I am going to bet on the opposite. Someone is adding even more \r's before handing the file to GHC. That means GHC is seeing \n\r\r
11:39:26 <yamadapc> Command Prompt & CygWin.. I'm looking at the source now; it's on http://hackage.haskell.org/package/HaXml-1.25.3/docs/src/Text-XML-HaXml-Wrappers.html
11:40:52 <geekosaur> that should still be whitespace, arguably. But I am wondering precisely *what* is throwing
11:41:07 <geekosaur> also, well, ghc is sometimes not very consistent for some reason
11:41:49 <yamadapc> 34:47
11:41:53 <yamadapc> throws
11:41:59 <yamadapc> that's line:column?
11:47:49 <yamadapc> :P
11:48:28 <yamadapc> the error is on the 'r' in "putStrLn $ "See http://projects.haskell.or[<-This 'r']g/HaXml"
11:48:50 <yamadapc> ah, it's not
11:49:03 <yamadapc> mm... ok, I'll keep trying here
11:50:15 <yamadapc> thanks
11:51:47 <pavonia> yamadapc: What's the error?
11:52:29 <yamadapc> "lexical error in string/character literal at character '\r'"
11:52:47 <yamadapc> Happens on appveyor too, https://ci.appveyor.com/project/yamadapc/jats2tex
11:53:49 <EvanR> > '\r'
11:53:51 <lambdabot>  '\r'
11:54:06 <yamadapc> >       putStrLn $ "See http://projects.haskell.org/HaXml" 
11:54:06 <EvanR> note the \
11:54:08 <lambdabot>  <IO ()>
11:54:24 <yamadapc> I don't understand?
11:54:38 <EvanR> > chr 114
11:54:40 <lambdabot>  'r'
11:54:43 <EvanR> > chr 13
11:54:45 <lambdabot>  '\r'
11:54:54 <EvanR> \r is carriage return
11:56:09 <EvanR> from the steampunk era when computers whizzed back and forth on metal rails !
11:56:20 <pavonia> The problem seem to be at "VERSION"
11:56:53 <yamadapc> preprocessor maybe
11:56:59 <pavonia> Yeah
11:57:15 * jared-w wrote a messaging app in java in 24 hours because of procrastination
11:57:23 <jared-w> aww yiss, finals week, gotta love it
11:58:32 <yamadapc> I've never seen this usage
11:58:43 <roconnor> I take it no one actually uses cabal-test-quickcheck because it is broken (in nixpkgs)
12:09:24 <ph88^> when i make a conduit that yields tuples and i don't use one of the two elements, will it still cost performance or not ?
12:13:38 <SepakoRayl> should I earn yesod ?
12:13:58 <SepakoRayl> learn
12:13:59 <tempeh> yeah, ask your boss for wages in yesod
12:14:11 <tempeh> oh i don't know about learning it
12:14:52 <athan> one monad to rule them all, one monad to bind them
12:16:00 <orion> byorgey: 'd' is existential because of "forall" correct?
12:16:02 <yamadapc> ah
12:16:17 <tempeh> im very comfortable with monads, but I never use the kleisli >=> operator
12:16:35 <SepakoRayl> it's one of those things I always wanted to learn but I don't prioritize
12:16:53 <jared-w> tempeh: all the operators
12:16:54 <tempeh> it just occured to me in the shower that that's what people refer to with the 'monads are monoids in the category of endofunctors' talk
12:17:00 <tempeh> suddenly all is clear
12:17:09 <jared-w> Haskell is perl reborn, but stronger and more mathy /s
12:17:23 <tempeh> i feel like >=> might be better to teach than >>=
12:18:09 <monochrom> I think think anyone knows what "perl reborn" means. (Including the speaker.)
12:18:52 <monochrom> But you can rightfully critique me for "does it have to mean anything? it just has to sound cool".
12:19:07 <dolio> That's actually not what the monoid thing means.
12:19:46 <tempeh> really?
12:19:50 <dolio> Really.
12:20:09 <dolio> (>=>) is from Kleisli arrows forming a category.
12:20:47 <jared-w> iirc >>= is haskell specific and >=> has specific category theory background?
12:20:48 <tempeh> it seems like (>=>) as composition and return as the identity exactly forms a monoid over (a -> m b), which can be considered endofunctors right?
12:20:49 <dolio> (>=>) is composition.
12:21:51 <dolio> return doesn't have type (a -> m b) unless a = b.
12:22:23 <tempeh> yeah, but it has to have a = b to be an identity for >=>
12:22:41 <dolio> And the 'functor' part is the m, not the arrow.
12:23:28 <tempeh> yeah, that is a point i was confused about, but i assumed it was just a translation from category theory version of functor
12:23:45 <tempeh> but i guess ill have to actually read about it instead of postulating :)
12:24:07 <monochrom> It is intuitively analogous to monoid, but "intuitively" and "analogous" are seldom precise or reliable.
12:24:21 <dolio> What you're seeing is a category.
12:24:51 <dolio> Because categories are like monoids with types on the things you can compose together.
12:25:16 <mac10688> I just got my wisdom teeth pulled an hour ago. I'm still feeling the anesthesia but I think I'm good enough to look at haskell
12:25:47 <dolio> And monoids are like categories with only one type.
12:26:13 <tempeh> that makes a lot of sense, i guess in a monoid either order of composition would be valid
12:26:55 <tempeh> so it's a category over a -> m b, and a -> m b is kleisli arrow? is that right?
12:27:06 <dolio> The two things are related, of course. The fact that monads are monoids is what allows the Kleisli arrows to form a category.
12:27:51 <tempeh> right, because they both use join
12:27:52 <tempeh> i see
12:29:20 <dolio> The monoid thing is that you have multiplication M.M => M and unit I => M.
12:29:28 <dolio> The first is join and the second is return.
12:30:09 <byorgey> orion: no, 'd' is existential because it does not show up as a type argument to the data type.  'forall' with a constructor is one possible syntax to encode that.  GADTs is another.
12:30:50 <byorgey> e.g.   data Foo where  Bar :: d -> (d -> Int) -> Foo     -- here 'd' is existentially quantified, because it does not show up as an argument to Foo
12:30:58 <tempeh> right. nice. thanks dolio, you're very clear
12:33:37 <monochrom> No no, it is more subtle than that. "newtype X = MkX (forall t. (t -> t) -> (t -> t))" is also a case of t not showing up in "X", but this one is universal not existential.
12:34:35 <monochrom> What you need is to contrast "MkX :: (forall t. etc) -> X" vs "Bar :: forall d. etc -> Foo"
12:35:54 <monochrom> And the logic rule that "forall d. <stuff here> -> Foo" is equivalent to "(exists d. <stuff here>) -> Foo" when d doesn't appear in "Foo".
12:40:31 <n_blownapart> ab9rf, monochrom thanks for response earlier.. sorry I left my desk
12:41:02 <monochrom> You're welcome.
12:47:38 <n_blownapart> monochrom the "learn you a haskell" book sort of just assumes you know that stuff. they introduced xs without really explaining it. it's like car/cdr in scheme isn't it? it is interesting that <- is a epsilon symbol.
12:48:49 <kadoban> xs, used the normal way, is just a name. There's nothing to introduce. Are you talking about in a pattern like (x:xs) ?
12:49:20 <kadoban> The part that gives that any meaning is the (:), which is one of the list constructors, that's here being pattern matched/destructed.
12:54:39 <Zemyla> You know, I wish IntSet had a complement function.
12:55:17 <n_blownapart> yeah kadoban it is the full car / cdr. x is the car, right?
12:55:43 <n_blownapart> I found lists in scheme quite hard to keep track of. 
12:56:10 <n_blownapart> I got about halfway through "The little schemer"
12:57:12 <Zemyla> n_blownapart: I read The Little Schemer when I was 12. It wasn't that hard.
12:57:55 <n_blownapart> I read it at age 54. Perhaps you don't understand Zemyla 
12:58:18 <dolio> Maybe it's easier for 12 year olds to understand.
12:58:18 <Zemyla> Ahh, okay.
12:58:28 <Tuplanolla> Is there anything confusing besides the `(x . y)` syntax?
13:01:13 <ab9rf> i remember being a bit weirded out that the cdr could countain a non-list
13:01:20 <ab9rf> but i learned lisp when i was 12
13:01:48 <n_blownapart> when I was 12 I was playing in the woods all day every day :)
13:01:57 <ab9rf> might have been 11
13:02:01 <ab9rf> or even 13
13:02:12 <ab9rf> kinda fuzzy, that was more than a few years ago
13:03:34 * hackage tttool 1.7.0.3 - Working with files for the Tiptoi® pen  https://hackage.haskell.org/package/tttool-1.7.0.3 (JoachimBreitner)
13:06:43 <n_blownapart> I guess what I should have asked is, if xs is just a name, why would it be chosen in an example to an entry-level book on haskell, if it's a constructor? ab9rf 
13:07:35 <n_blownapart> et al
13:08:17 <ab9rf> n_blownapart: it's customary in haskell to use x:xs, y:ys, etc. for pattern matches that work to deconstruct the head of a list
13:08:44 <ab9rf> more generally, if you have one x, you have many xs
13:08:56 <ab9rf> which is where the "s" comes from.
13:12:53 <n_blownapart> ab9rf, thanks so cons is the opposite of deconstructing the head.. you are adding -- pushing -- an element, to the cdr?
13:13:31 <n_blownapart> or does deconstructing the head have more meanings than that?
13:14:10 <AerialBoundaries> if I have `f x y`, am I actually saying apply f to x, and apply x to y? And then because of left association, we apply f to x first and get a function which we're able to apply to y? In other words, does a space between values always denote function application?
13:15:29 <duckqlz_> f x y is a curried function
13:15:32 <duckqlz_> currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.
13:15:52 <Tuplanolla> > mod(42)13 -- You can do without the spaces too, AerialBoundaries.
13:15:54 <lambdabot>  3
13:17:46 <AerialBoundaries> What I mean is, is there some special syntactic sugaring at work when I give multiple arguments, or is it just normal parenthesizing?
13:19:51 <Tuplanolla> It's business as usual, AerialBoundaries.
13:19:56 <AerialBoundaries> great :)
13:20:18 <Eduard_Munteanu> AerialBoundaries, application associates like f x y z = ((f x) y) z
13:20:33 <AerialBoundaries> got it
13:20:58 <Tuplanolla> This is directly related to why the type `a -> b -> c` also associates `a -> (b -> c)`. See if you can prove how, AerialBoundaries.
13:23:05 <AerialBoundaries> f x y translates to (f x) y, so we apply f to x of type a, that returns a function which takes y of type b and gives us a c.
13:23:22 <duckqlz_> Haskell is syntactic sugaring for lambda calculus which means a function with 2 haskell expressions (E,F) which translate to lambda expressions (E'&F') then E * F reduces to ((* E') F')
13:23:51 <Tuplanolla> Perhaps that's a bit trivial, but it's good to notice.
13:24:33 <AerialBoundaries> Tuplanolla: my question actually came about after seeing that grouping in the type definition
13:24:43 <AerialBoundaries> in the text I'm reading
13:25:08 <SepakoRayl> λ
13:36:23 <ReinH> "Haskell is syntactic sugaring for lambda calculus"... uh, no?
13:37:21 <ReinH> I guess maybe you could say that Haskell is syntactic sugaring for System FC, but I don't see how that's helpful either.
13:37:57 <ReinH> The Haskell report simply defined f x y = (f x) y, and a -> b -> c = a -> (b  -> c)
13:44:06 <SepakoRayl> is there a list with allowed unicode syntax?
13:44:21 <glguy> SepakoRayl: did you look up the extension in the GHC users guide?
13:45:36 <geekosaur> also keep in mind that the extension only covers syntax the compiler needs to know about. quite a lot can be done in modules (and there should be a few such modules on hackage already)
13:46:04 <SepakoRayl> was it always extensions?
13:46:11 <geekosaur> so for example there is no need to bake operator ≥ into the extension, it's just (≥ = (>=)(
13:46:12 <geekosaur> er
13:46:43 <geekosaur> > let (≥) = (>=) in 5 ≥ 6
13:46:45 <lambdabot>  False
13:46:57 <SepakoRayl> I recalled some symbols working without any
13:46:58 <monochrom> There exists a rich, sophisticated lambda calculus such that Haskell is syntax sugar for that. Proof: Let that calculus be Haskell itself. :)
13:47:02 <SepakoRayl> I guess it's just my memory failing me
13:47:23 <geekosaur> SepakoRayl, there are other ways to get the same effect. there are for example lots of Haskell ligature fonts
13:47:59 <geekosaur> so editors show ≥ but this is accomplished by defining a ligature ≥ for >=
13:48:09 <geekosaur> the compiler doesnt need to know about this, only the editor does
13:48:15 <monochrom> [1, 2, 3] is already unicode syntax. :)
13:48:37 * monochrom mistakes today for Degenerate Tautology Day!
13:50:20 <Tuplanolla> What makes tautologies degenerate? Duplicate eigenvalues?
13:50:59 <johnw> clearly what makes a tautology degenerate is that it is a degenerate tautology
13:51:00 <duckqlz_> ^ lol
13:52:45 <monochrom> Tuplanolla: I think the "degenerate" part is subjective, but usually most people have pretty good consensus.
13:53:15 <monochrom> For example "[1,2,3] is already unicode syntax :)" is pretty widely agree to be degenerate, I would think.
13:56:27 <ReinH> monochrom: No there isn’t. Proof: let “no there isn’t” mean “yes there is”.
13:57:33 <Tuplanolla> I do wonder if category theory provides a suitable generalization of eigenvalues that's applicable to logical formulas now.
13:58:06 <ReinH> Fira Code is my favorite ligature font and it’s open source, fwiw.
14:00:18 * glguy uses said font for programming
14:01:12 <monochrom> ligature font for programming?!
14:01:25 <pikajude> oh yeah, that's the thing now
14:01:36 <monochrom> So that when you write shell scripts, "fi" looks better? :)
14:01:43 <pikajude> not those ligatures
14:01:45 <pikajude> joining => for example
14:01:49 <monochrom> Oh, that.
14:01:58 <monochrom> But won't hurt to add "fi" too :)
14:02:04 <pikajude> it might hurt a little bit
14:02:06 <geekosaur> someone probably has
14:02:13 <Tuplanolla> The ones I've seen don't join things consistently.
14:02:52 <pikajude> but, they do join them inconsistently
14:03:07 <geekosaur> the big problem with ligature fonts is many editors/toolkits don't bother loading the per-character ligature tables, but use defaults
14:03:46 <glguy> example: http://imgur.com/a/z5V1H
14:03:46 <Tuplanolla> Take `>>`, `>=`, `=>`, `>>>`, `>>=` and `>=>` as an example.
14:05:13 <glguy> The nice thing about ligature fonts is you get the pretty arrows without actually adding unicode syntax to your source file. This way the people who don't want it won't see it
14:06:26 <monochrom> This is interesting, how a computer represents a ligature font, and how an algorithm looks it up and uses it.
14:06:51 <ReinH> It’s probably Keith
14:06:54 <monochrom> Although, the answer may just be "just KMP it"
14:06:58 <ReinH> Uh, thanks autocorrect.
14:07:03 <monochrom> :)
14:07:12 <ReinH> It’s probably Knuth’s fault.
14:07:21 <ReinH> Also, typical Keith.
14:07:39 <monochrom> For a moment I thought you were naming a Minion. :)
14:07:51 <ReinH> I would never.
14:08:14 <ReinH> For one thing, that would involve knowing their names.
14:08:48 <nitrix> Melee minions, Caster minions, Super minions.
14:08:56 <nitrix> heh
14:10:31 <madsa> anyone know of a well maintained ssh client library for haskell?
14:10:38 <madsa> found a few things but they are all outdated
14:19:34 * hackage memory 0.14.6 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.14.6 (VincentHanquez)
14:25:00 <duckqlz_> madsa: I've used the SSH package but only for simple connections (https://hackage.haskell.org/package/ssh)
14:26:51 <madsa> thanks, I'll try it, it hasn't been updated in a couple years but hopefully it will do what I need
14:47:27 <lpaste> xorswap pasted “what I would like to do” at http://lpaste.net/5970168763809529856
14:47:34 <XorSwap> oh hey it's in here
14:47:56 <XorSwap> so imperitive pleb here trying to learn monads by example
14:48:43 <XorSwap> I want to make a random number monad, I've got a RandState type, a get :: RandState -> Int, and a next RandState -> RandState
14:49:08 <XorSwap> how would I go about using that to make an example like http://lpaste.net/5970168763809529856 work?
14:49:52 <monochrom> You need to define a type for your new monad.
14:55:48 <monochrom> Go to typeclassopedia, read about "State", that will give you some inspiration.
14:58:17 <Tuplanolla> The type of the function using existing definitions could be `(RandomGen g, Random a) => State g (a, a, a)`, XorSwap.
14:59:21 <Tuplanolla> With that you'd have `rand = state (randomR (a, b))`.
14:59:47 <XorSwap> ok so the ideomatic approach wouldn't be to make a new monad from scratch here
15:05:04 <monochrom> I don't agree.
15:05:52 <monochrom> You will not want to make it simply State and present it as is to users. Wrong API.
15:06:40 <monochrom> You will want to expose only an API that provides "rand", no more no less.
15:07:10 <monochrom> The internal implementation could be written afresh, or could reuse but hide State.
15:07:40 <monochrom> At any rate my point is you will not want to expose State's "put" and "get". Wrong API.
15:08:13 <fresheyeball> behold! for I have an annoying problem of unfathomable vagueness
15:08:14 <monochrom> Also, I don't think it's useful now to shoehorn RandState into RandomGen. There is no gain.
15:08:34 <fresheyeball> I see how type level lists provide a nice interface for extensible products
15:08:59 <fresheyeball> that is much nicer than nested tuple
15:09:08 <monochrom> I don't think it is extensible. I think it is restrictive instead.
15:09:22 <fresheyeball> is there a type level thing that provide extensible coproducts?
15:09:41 <fresheyeball> in a way that is nicer than nestable Eithers?
15:13:18 <lpaste> xorswap pasted “It typechecks, but threeRandomNumbers has a very complicated type” at http://lpaste.net/356148
15:13:37 <XorSwap> StateT RandState Data.Functor.Identity.Identity (Int, Int, Int)
15:14:21 <geekosaur> aka State RandState (Int,Int,Int)
15:14:39 <XorSwap> ah ok
15:15:03 <fresheyeball> anyone? I think a type level thing that provide exensible coproducts would be neat beyond all neatnesses
15:15:47 <EvanR> fresheyeball: yes
15:15:49 <fresheyeball> right now I could have lots of Either nesting, which sucks and also retains heirachical information I don't need
15:15:58 <monochrom> If I understand you correctly, type level list also gets you extensible coproduct.
15:15:58 <EvanR> called extensible variants
15:16:12 <fresheyeball> monochrom: how so?
15:16:15 <XorSwap> so now if I wanted to retrieve three ints, (x,y,z) = threeRandomNumbers wouldn't work
15:16:32 <monochrom> consider execState
15:16:40 <EvanR> liftA3 (,,) randomNumber
15:16:54 <fresheyeball> monochrom: ok no I see it now
15:16:58 <fresheyeball> AAAA!!!!!
15:17:09 <fresheyeball> type level lists are more useful than expected!
15:17:10 <geekosaur> or if you are in a State RandState action, try: (x,y,z) <- threeRandomNumbers
15:17:50 <MitchellSalad> data Union xs where; UZ :: x -> Union (x:xs); US :: Union xs -> Union (x:xs)
15:17:51 <geekosaur> (generally, if you need to resort to evalState or execState, you are not making use of what State offers you)
15:18:02 <MitchellSalad> there's your extensible union
15:23:54 <XorSwap> ahh runState is what I'm looking for
15:24:34 <XorSwap> thanks guys
15:25:21 <joncfoo> Within Spock, how can I get access to the Wai Request?
15:27:28 <joncfoo> I'm trying to get a hold of the server protocol scheme + hostname + port information dynamically
15:29:43 <taktoa> fresheyeball: https://hackage.haskell.org/package/union-0.1.1.1/docs/Data-Union.html
15:30:07 <kyclark> I’m trying to learn how to write a Monadic instance of an Either type.  In https://paste.ofcode.org/GH28H4D8QdDxuRc6X2bbUp, I show that I can write a Functor for a simple Identity, but my method doesn’t transfer to my Sum type.  I include the compilation error. I cannot figure how to fix this.
15:30:15 <taktoa> fresheyeball: if that module doesn't make sense to you, read up on https://hackage.haskell.org/package/vinyl
15:32:04 <tempeh> kyclark: f can only have one type, but a and b can have different types
15:32:59 <tempeh> kyclark: f can only be a function of the left type, or the right type, but not both
15:33:39 <tempeh> first type or second type, in your case
15:34:39 <tempeh> try writing out the type signature of fmap specialized to Sum a b
15:35:03 <monochrom> You will have to settle for "fmap f (First a) = First a".
15:35:26 <monochrom> This is analogous to Maybe.
15:36:10 <glguy> either?
15:36:54 <monochrom> "This is analogous to Either" would be begging the question.
15:38:07 <freeside> kyclark may have timed out.
15:38:30 <kyclark> Sorry, I’m back
15:38:58 <freeside> while you were away, important clues were dispensed
15:39:02 <monochrom> You will have to settle for "fmap f (First a) = First a". This is analogous to Maybe.
15:39:20 <kyclark> My connection dropped.  
15:39:29 <kyclark> And apply f to Second?
15:39:43 <monochrom> Yes, f is only useful for Second.
15:40:05 * hackage th-abstraction 0.2.1.0 - Nicer interface for reified information about data types  https://hackage.haskell.org/package/th-abstraction-0.2.1.0 (EricMertens)
15:40:10 <kyclark> I tried it the other way and it didnt’ work.  Is this because (Sum a) is in the definition?
15:40:34 <glguy> Yes, the type you're writing the Functor instance for is (Sum a)
15:40:35 <monochrom> works for me
15:40:48 <freeside> so Left cases are basically a passthrough -- the convention is to put errors in Left, and propagate them.
15:41:12 <glguy> :t fmap
15:41:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:41:37 <glguy> so if we substitute the type Sum x for f, we get   (a -> b) -> Sum x a -> Sum x b
15:44:44 <kyclark> To extend this to Applicative: https://paste.ofcode.org/sq2RvmyZey7DqxM5YpnbfB
15:45:20 <kyclark> Have I got that correct?  pure = Second, I think that makes sense, but both the “f” and value need to be Seconds.  So just ignore everything else?
15:45:51 <glguy> kyclark: No, you can't ignore everything else, you'll have to do something with it
15:45:58 <monochrom> Yes for the first question. No for the second question.
15:46:40 <monochrom> There are very good and obvious "the default thing to do" when you see a "First".
15:46:44 <kyclark> OK, dang it, have to leave, but I’ll keep working on this.  Thanks for the insights.
15:57:26 <ij> With hspec, should I commit the compiled cabal file into vcs?
15:58:05 <MarcelineVQ> hpack?
15:58:13 <MarcelineVQ> I sure would
15:58:30 <ij> hpack, yes, sorry
15:58:37 <MarcelineVQ> At least, if you intend it to be shared
15:58:57 <MarcelineVQ> *for your repo to be shared
16:00:00 <glguy> You should work under the assumption that people won't be using the hpack file, unless you're the only one using it
16:00:30 <ij> Alright!
16:21:34 * hackage singleton-dict 0.1.0.0 - Typelevel balanced search trees via a singletonized Data.Map  https://hackage.haskell.org/package/singleton-dict-0.1.0.0 (ArieMiddelkoop)
16:22:34 <Xion__> When you change a dependency to a newer version in .cabal, how do you make stack update it rather than returning an error from `stack build`?
16:23:42 <tempeh> I'd have thought stack build would work, but maybe stack clean first?
16:24:19 <MarcelineVQ> what's the error
16:26:17 <Xion__> optparse-applicative: needed (>=0.14), 0.13.2.0 found (latest applicable is 0.14.0.0)
16:26:41 <Xion__> I refined optparse-applicative dep to be >= 0.14 since I wanted to use the Text parsers
16:27:12 <geekosaur> that usually means you;re getting it from a resolver which contains 0.13.2.0
16:27:39 <MarcelineVQ> lts resolvers don't currently have that version, you'll need to add them to your extra-deps section in your stack.yaml, or run  stack solver --update-config  to have stack figure it out
16:27:39 <geekosaur> you'd need to specify it in stack.yaml to override the resolver
16:28:09 <Xion__> Yeah just tried the latest lts, same thing.
16:29:50 <Xion__> Seems like extra-deps is the way to go
16:30:19 <jaseemabid> I was trying to understand how Haskell's Core (https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-8.0.1/CoreSyn.html) works, and I don't quite get what happens with the 'Bind'. Is there any simpler/detailed explanation available? 
16:30:20 <MarcelineVQ> this is the syntax for adding a version yourself, https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
16:34:34 * hackage non-empty-zipper 0.1.0.8 - The Zipper for NonEmpty  https://hackage.haskell.org/package/non-empty-zipper-0.1.0.8 (fresheyeball)
16:39:36 <unclechu> hey guys, how do i specify OS-conditions in the hpack? like i do in cabal: `if os(linux) hs-source-dirs:    src/linux`?
16:39:48 <jaseemabid> Here is the quick reference to the definition of bind. https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-8.0.1/src/CoreSyn.html#Bind. 
16:39:48 <jaseemabid> The core is defined as 'data Expr b = ...' instead of `data Expr = ...` to accommodate the `b` for Bind. It seems like an important decision and I see just 2 lines of docs for it. 
16:40:23 <iqubic> Hello folks.
16:40:36 <iqubic> What the heck is an Endofunctor?
16:41:05 <EvanR> iqubic i made a tictactoe tabulator you might find interesting http://codepad.org/rX5J1AeC
16:41:39 <iqubic> EvanR: What does that do?
16:41:50 <EvanR> exercise for the reader
16:42:32 <dmj`> iqubic: it’s a functor from one category back to the same category, I think all functors in Hask are endo.
16:43:09 <ij> Hmm, I did the the package.yaml with src/, test/ directories and `stack ghci` cannot import my modules any more.
16:43:10 <iqubic> EvanR: Does that take a board and return it's rows as [String]?
16:43:18 <EvanR> yes
16:43:42 <iqubic> Why is board of type Cell -> Maybe Mark?
16:43:46 <iqubic> How does that work?
16:43:54 <EvanR> thats the trick
16:44:36 <EvanR> markBoard cell mark board x = if cell==x then Just mark else board x
16:44:40 <EvanR> blankBoard _ = Nothing
16:44:53 <geekosaur> jaseemabid, in general you want to read the Commentary: https://ghc.haskell.org/trac/ghc/wiki/Commentary
16:44:58 <EvanR> no arrays were harmed in the making of this tictactoe
16:45:27 <iqubic> EvanR: Why not store the board as an Array?
16:45:36 <Xion__> MarcelineVQ: I just run `stack solver --update-config` and it seems to have worked.
16:45:37 <EvanR> because this is 10 lines of haskell?
16:45:47 <iqubic> And it just works?
16:45:49 <EvanR> could be less if i use list comprehension
16:45:56 <monochrom> Wouldn't it be nice if one day we got to say "no cycles were spent to solve this NP-complete problem" :)
16:46:15 <geekosaur> jaseemabid, for this, you want to look for "Binder" in https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
16:46:25 <EvanR> iqubic: what do you thin
16:46:38 <iqubic> I might need to re-write my TicTacToe implementation is what I think
16:47:13 <iqubic> How do you create a board if "Type Board = Cell -> Maybe Mark"?
16:47:47 <unclechu> i found answer for my question about conditions in hpack in readme: https://github.com/sol/hpack
16:47:48 <EvanR> see blankBoard above
16:47:50 <EvanR> and markBoard
16:48:38 <iqubic> How do you retrieve a cell from that board?
16:48:48 <iqubic> What would the Board function do?
16:48:52 <EvanR> type Board = Cell -> Maybe Mark
16:49:05 <iqubic> Yes, but how do you get that function?
16:49:15 <EvanR> see blankBoard and markBoard above
16:49:32 <iqubic> I have.
16:49:49 <EvanR> ok
16:50:02 <iqubic> Can you give me an example of constructing a board.
16:50:09 <EvanR> blankBoard
16:50:17 <EvanR> its a blank board
16:50:26 <EvanR> its so simple it hurts!
16:50:30 <iqubic> Ah, wait, that's a type synonym, and not a Data declaration
16:50:37 <EvanR> yes
16:50:37 <monochrom> No, it's so simple it's void.
16:51:51 <iqubic> Why does markBoard have so many arguments?
16:52:05 <EvanR> markBoard :: Cell -> Mark -> Board -> Board
16:52:10 <jaseemabid> geekosaur: Thank you so much. This might get me somewhere. 
16:52:37 <iqubic> But that's not of type Cell -> Maybe Mark.
16:52:45 <iqubic> That can't be a board then.
16:52:48 <EvanR> it returns that
16:53:56 <orion> I have a pure function f that I want to run ~1000 times with slightly varing inputs. I want all the results to be serialized to a file via Aeson. Currently I am using list comprehension syntax: results = [ f x | x <- xs ]; writeFile "results.json" . encode $ results. Is there a more efficient way of doing this?
16:55:24 <monochrom> I think it's as good as it gets, unless you sidestep aeson and write your own json producer customized to your actually type.
16:56:06 <ij> Why wouldn't this parse "foo #(1)"? skipMany anyChar *> char '#' *> (between (char '(') (char ')') (escaped ")"))
16:56:31 <glguy> Because you skipMany'd the whole thing
16:56:55 <monochrom> skipMany anyChar eats everything up. Do not expect a later char'#' will cause backtracking.
16:57:34 <monochrom> People do not appreciate how complex it is to support "a simple regex like .*x.*"
16:58:29 <EvanR> > elem 'x' "supercalifragilisticexbialidocious"
16:58:31 <lambdabot>  True
16:59:25 <EvanR> i support that
16:59:29 <pikajude> that's not how you spell it
16:59:33 <EvanR> :(
17:02:26 <monochrom> You may find manyTill to be useful.
17:02:36 * hackage lens 4.15.3 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.15.3 (EricMertens)
17:05:23 <AWizzArd> type vs. newtype. Why is String just an alias for [Char] and not a newtype instead?
17:05:49 <monochrom> I don't know. Probably people want the convenience.
17:06:14 <monochrom> Could you list the benefits of going newtype?
17:06:17 <EvanR> a million years ago, you couldnt use list syntax for newtypes
17:06:51 <EvanR> a million years from now, String will be an alias for Text instead
17:07:10 <AWizzArd> monochrom: I would think in general (not just with String) it offers more safety.
17:07:33 <monochrom> What safety do you have in mind?
17:07:46 <EvanR> how often do you handle a list of Char which is not considered a String? (my tictactoe tabulator not withstanding)
17:08:13 <monochrom> And you can't stay general. The string story is very different from many other scenerios.
17:08:59 <AWizzArd> I wonder more about type vs newtype in a more genel way, in a scenario where we talk about simple types.
17:09:02 <EvanR> each list should be a different newtype?
17:09:05 <AWizzArd> type Age = Int
17:09:22 <AWizzArd> type Path = String
17:09:23 <monochrom> See, age is not string.
17:09:39 <pikajude> "how old are you?" "January."
17:09:44 <EvanR> Path is another story
17:09:49 <AWizzArd> Why shouldn’t those be newtypes?
17:10:01 <EvanR> String and Path should both be different abstract types
17:10:40 <monochrom> Your initial question was not about age and file path. Moving goalpost detected.
17:11:10 <AWizzArd> String was just one example.
17:11:35 <monochrom> Stop defending. Retract your intial question.
17:11:35 <EvanR> of
17:12:08 <AWizzArd> I see code on BitBucket or Github and find lots of type X = Int there and just wonder what the advantages are of using type.
17:12:22 <monochrom> If you think you can speak generally, the only thing to be said is "generally, do the right thing".
17:13:09 <monochrom> Some of those are bad, some others are good. You can't stay general.
17:13:49 <AWizzArd> monochrom: you mentioned convenience. What convenience do I give up when making something a newtype?
17:13:54 <monochrom> Also read about XY problems.
17:14:42 <monochrom> Code up something useful that uses "newtype Age = AgeOf Int". You will see.
17:15:25 <geekosaur> safety and expressiveness are often at cross purposes
17:15:36 <AWizzArd> hmm
17:16:16 <monochrom> Have you coded up anything?
17:16:19 <geekosaur> monochrom's example is a good one: you either have to constantly wrap and unwrap it (or use helpers that do so), or for some things you can make it a typeclass instance... which will lose you some of that safety
17:16:50 <geekosaur> (Num is a *really* good example of that with respect to Age, if you need to do math on them)
17:17:04 <AWizzArd> monochrom: a bit yes, but I am still learning a lot. Don’t know though why this is of interest. 
17:17:14 <geekosaur> (ad note that if you want something like "give me the average Age of ...", you must do math on them)
17:17:28 <monochrom> It is actually not clear to me what is the purpose of, say, "let me add the age of Sally and the age of Robert".
17:17:42 <iqubic> If I write "Type Age = a" Can I write a num instance for that?
17:17:56 <monochrom> Apart from the colloquial usage of "the two of you are 120 years old together, stop acting like kids"
17:18:09 <AWizzArd> Okay I see.
17:18:16 <AWizzArd> Yes, that makes sense.
17:18:19 <bno1> monochrom: statistics?
17:18:29 <monochrom> The interest to me is that I have no patience talking to armchair philosophers.
17:18:37 <geekosaur> not for a "type", they are not distinct. that Age would use the original type's Num instance.
17:19:06 <iqubic> Ah, that might actually work for me.
17:19:46 <geekosaur> with newtype you can specify your own instances... and then discover that the automatic wrapping of numeric literals in fromInteger and the type checker's attempts to make types conform will lead to surprising Num instances being picked sometimes
17:19:57 <geekosaur> and your safety has just gone seriously Weird
17:20:03 <monochrom> Ah bno1, you're right.
17:20:18 <iqubic> can you call this function ever?
17:20:21 <geekosaur> yes, that's why I mentioned "give me the average Age of..." earlier
17:20:21 <iqubic> :t absurd
17:20:23 <AWizzArd> geekosaur: also a good point, thanks
17:20:24 <lambdabot> Void -> a
17:21:15 <geekosaur> iqubic, not normally. there are ways to force it, which are not recommended unless you understand exactly what you are doing
17:21:45 <monochrom> either absurd sin :: Either Void Double -> Double
17:22:55 <monochrom> But I still like "the two of you are 120 years old together" :)
17:24:11 <bno1> I would use newtype if I wanted to cherry pick the instances of an already existing type
17:26:21 <geekosaur> until one is 110 and the other is 10
17:27:10 <EvanR> iqubic well, the test for win condition doesnt seem to be any easier 
17:27:47 <monochrom> This is a good time to advocate my https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html :)
17:29:07 <bno1> For example in a software that must provide high reliability I wouldn't want to use normal Int operations wich might overflow. I could create a newtype SafeInt and write safe functions for operating with it but forward some instances of Int for example Show or Hashable
17:30:44 <monochrom> Oh don't you love import Data.Proxy(Proxy(Proxy))
17:31:00 <monochrom> On the verge of "Buffalo buffalo buffalo..."
17:31:30 <bno1> never worked with that
17:32:57 <hpc> monochrom: someday i hope to import Data.Data(Data(Data))
17:33:05 <monochrom> hehe
17:33:32 <hpc> http://4.bp.blogspot.com/-IPn6jenkr_A/TrS9N3KaIAI/AAAAAAAAAf0/Ds09PEh7KMo/s1600/FistfulData.jpg
17:37:50 <monochrom> neato
17:38:02 <bno1> https://wiki.haskell.org/Phantom_type
17:38:06 <bno1> wow this is really useful
17:38:35 <monochrom> YES!
17:59:59 <jared-w> monochrom: nice link about the ordering stuff
18:00:36 <jared-w>  > "we can represent all of Haskell98 classes + functional dependencies with only one, predefined type class" -- ಠ_ಠ
18:25:05 * hackage concrete-haskell 0.1.0.7 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.7 (TomLippincott)
18:51:47 <CodeWeaver_> Greetings.
18:54:08 <CodeWeaver_> Anybody tried to cabal install stream-fusion lately?  I get a conflict on MonadPlus.  
18:58:15 <XorSwap> CodeWeaver_: no conflict for me
18:58:52 <Gurkenglas> tdammers, make the "doThing :: MonadState Foo m => m ()" and use "zoom lensblahfoo doThing" to do the thing (except that I think the mtl-style type signature for doThing there would make zoom not work, you'd need Zoom constraints or the actual monad stack you're using)
18:59:20 <Gurkenglas> Then you can use "zoom (lensblahlistoffoos . traverse) doThing" to do the thing for each target of the traversal in the brackets
18:59:56 <CodeWeaver_> .... how odd.
19:00:27 <CodeWeaver_> I'm on ghc 8.0.1, and the error on a clean sandbox is:
19:01:11 <CodeWeaver_> Control/Monad/Stream.hs:136:10: error:     Ambiguous occurrence ‘MonadPlus’     It could refer to either ‘GHC.Base.MonadPlus’,
19:01:18 <CodeWeaver_> ...and additional stuff.
19:01:43 <CodeWeaver_> GHC.Base has the other definition apparently.
19:02:52 <glguy> CodeWeaver_: That package was uploaded in 2013 and has a "optimistic" upperbound
19:03:13 <CodeWeaver_> Ah, okay, well, then, .. uh....
19:03:18 <glguy> CodeWeaver_: You don't need to use it anymore
19:03:24 <CodeWeaver_> ...is there a more modern package? 
19:03:31 <CodeWeaver_> Or has it been rolled into mainline?
19:04:13 <geekosaur> it was a testbed for the stream fusion stuff, yeh
19:04:18 <geekosaur> long since rolled in
19:04:21 <CodeWeaver_> Neat.
19:04:38 <CodeWeaver_> Was that... documented anywhere?  Beacause as a newbie.. or a recurrently revisiting the language semi-newbie....
19:04:42 <CodeWeaver_> ...that doesn't seem obvious.
19:05:52 <glguy> CodeWeaver_: Presumably it's in the GHC release notes from when it was added
19:06:44 <CodeWeaver_> ..alright.  That... makes it difficult to distinguish what's been mainlined vs what's been abandoned.  But at least i know that about stream fusion then.
19:07:02 <CodeWeaver_> Cabal packages may need a deprecation warning or something...
19:07:07 <geekosaur> we have a way to deprecate packages, but it postdates that and nobody went back and applied it
19:07:17 <CodeWeaver_> Noted.
19:07:46 <CodeWeaver_> Trying to get back into the language. :)
19:10:17 <glguy> Well, you're in the right place for questions, then.
19:10:36 <CodeWeaver_> I may have.. a lot of retro-newb questions like that.
19:10:49 <CodeWeaver_> I've been fighting a plethora of such minor problems.
19:11:10 <CodeWeaver_> Love the language, not... totally fond of cabal hell.
19:11:19 <glguy> That's not really a thing any more
19:11:28 <CodeWeaver_> Oh?
19:12:12 <glguy> We have a pretty active set of trustees that add bounds to packages that are missing them
19:12:17 <CodeWeaver_> Given that I just ran into a problem, I'd disagree.  Documentation-wise its was not clear until I asked that question what my problem was.
19:12:35 <CodeWeaver_> I mean, I"m glad there's an effort, don't get me wrong.
19:12:48 <glguy> Maybe you're definition is simply quite inclusive as to what "cabal hell" means
19:12:56 <CodeWeaver_> MIght be so.
19:13:22 <CodeWeaver_> I'm already fighting similar problems on openGL, so.  We'll see. But I'm glad this place exists.
19:13:23 <monochrom> cabal hell is like paradise.
19:13:32 <CodeWeaver_> *snort*
19:13:38 <monochrom> everyone means a completely different thing by it.
19:14:14 <glguy> I had some cabal hell driving home today
19:14:21 <monochrom> If you bring a friend to a curry place, one of you will call it curry paradise, the other spice hell.
19:14:56 <CodeWeaver_> I suppose that's great for people who get off on fighting version issues.  I don't.
19:15:26 <CodeWeaver_> But my immediate problems are modest.  openGL can wait until later.
19:54:05 * hackage concrete-haskell 0.1.0.8 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.8 (TomLippincott)
20:05:13 <glguy> What's the difference when new-build says it's building (lib) vs when it says (all, legacy fallback) ?
20:05:51 <ezyang> legacy fallback means that the library is using a custom setup 
20:06:05 <ezyang> so we can't build it per component, we have to build it all at once 
20:08:21 <glguy> Is there anything packages with custom scripts can do to restore component builds?
20:08:55 <glguy> Or is that simply not necessary?
20:15:27 <glguy> ezyang: Did your blog go down?
20:26:27 <ezyang> looks down  uh oh 
21:15:55 <zenAndroid> test
21:17:17 <ezyang> glguy: Back now 
21:20:32 <wespiser> hello, i'm using Configurator to read some db config stuff, if I build that into a stack project, where/how to i set it up so my config file is found by my compiled exectuable?
21:21:35 <zenAndroid> @help
21:21:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:21:47 <zenAndroid> list
21:21:56 <zenAndroid> help list
21:22:08 <zenAndroid> @list
21:22:08 <lambdabot> What module?  Try @listmodules for some ideas.
21:22:24 <MarcelineVQ> did you have a question? :>
21:22:53 <Eduard_Munteanu> zenAndroid, lambdabot can be queried privately if you want to play with it
21:22:57 <zenAndroid> Oh, no lol, i think wespiser has a question though ..
21:23:15 <zenAndroid> Ah ok sorry yeah i was worrited of disrupting the chat
21:23:35 <wespiser> its a basic question
21:24:15 <wespiser> not a particularly challenging one, but one whose answer is important 
21:29:34 <wespiser> hmmm, while I'm here: I'm building a web server in Haskell. My work experience is all in Scotty, and it seems like everyone is using that in production. Is this consistent with your experience?
21:39:19 <johnw> wespiser: "it seems like everyone"? you mean, the people at your work?
21:39:56 <wespiser> yes, people I know running Haskell in production
21:40:01 <wespiser> its a pretty small sample
21:40:06 <johnw> I've only ever known one group to use scotty in production
21:40:11 <johnw> though I'm sure it's capable
21:40:21 <wespiser> what are they using?
21:40:32 <johnw> Mostly I hear people using servant, snap, yesod, or just WAI applications on warp (which I believe scotty is)
21:40:45 <wespiser> yea, scotty is build on top of warp
21:40:55 <Eduard_Munteanu> All of them are, really.
21:41:40 <wespiser> servant looks really interesting, it would be nice if there were more examples/tutorials out there
21:43:27 <Eduard_Munteanu> These serve different purposes, though. Servant is more of an API backend solution for modern, JS-heavy, single-page apps, while Yesod and Snap are more suited to traditional web sites. In fact, you can use both in the same project.
21:45:28 <wespiser> yea, I'm running a single page JS/scotty, so it was between that and Servant
21:46:41 <nak_> can someone explain to me the two values `s` and `a` in State monad
21:46:46 <nak_> why is there two values
21:47:27 <wespiser> are you familiar with the Reader monad?
21:47:41 <nak_> i'm not
21:47:56 <Eduard_Munteanu> nak_, one is the type of the state, the other is the type of the answer provided by the action.
21:48:15 <wespiser> anyway, what the state monad allows you to do is: given a state s, run some calculations to get a modified state, s', and some value, a
21:48:17 <nak_> mostly Maybe, Either, and Cont so far
21:48:33 <Eduard_Munteanu> For example, an action returning the current state has to has this type: State s s
21:50:19 <nak_> ok so like if we had (State Foo Bar)... i don't see why we need the ability to keep track of two types
21:50:59 <nak_> Foo is the type of the "current state" and Bar is the type of the answer provided by the action...
21:51:31 <nak_> is this anything like fold how it takes a function (b -> a -> b) ?
21:51:52 <Eduard_Munteanu> Consider   put :: s -> State s ()   which changes the state to the provided value, but doesn't return anything worthwhile.
21:51:55 <nak_> accumulator, currentValue, return nextAccumulator
21:52:34 <nak_> ok so put just writes a new state but discards the any potential action result
21:53:18 <nak_> the two values still don't make sense to me. how is this different than just using Identity monad over a tuple of values?
21:53:20 <Eduard_Munteanu> > runState (do { x <- get; put (x + 1); return (2 * x) }) 3
21:53:23 <lambdabot>  (6,4)
21:54:59 <Eduard_Munteanu> nak_, Identity only lets you work with values in scope. You can't write separate actions which work with an implicit state.
21:56:06 <Eduard_Munteanu> In other words, you'd have to track the state manually and pass it around.
21:56:14 <nak_> ok so s is the current state... but i don't get a then
21:56:41 <nak_> why do we care about a? is it ever useful as the result of a computation?
21:56:47 <nak_> (i assume it must be)
21:58:24 <Eduard_Munteanu> nak_, because not all State actions have the same answer type. Some return the stored state, others return (), others compute something based on the state
21:58:31 <nak_> Eduard_Munteanu: if you were to bind another action, how would you "read" the value of the last returned action?
21:59:03 <Eduard_Munteanu> nak_, have you seen the example above?
21:59:10 <nak_> yeah
21:59:25 <nak_> `x <- get` will read the state
21:59:43 <nak_> which is `3` initially
21:59:57 <nak_> `put (x + 1)` writes new state: 4
22:00:13 <Eduard_Munteanu> get :: State s s, put :: s -> State s (), return :: a -> State s a
22:00:51 <iqubic> :t curry
22:00:53 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:00:54 <Eduard_Munteanu> Note they all have the same state type, that can't change.
22:01:01 <iqubic> :t uncurry
22:01:03 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:01:06 <Eduard_Munteanu> Only the answer type does.
22:01:32 <iqubic> > uncurry (+) (1,100)
22:01:34 <lambdabot>  101
22:01:45 <iqubic> That did just what I expected it to.
22:01:51 <nak_> iqubic: ^_^
22:01:55 <iqubic> Why are curry and uncurry even a thing?
22:02:15 <nak_> huh
22:02:24 <iqubic> @src curry
22:02:24 <lambdabot> curry f x y = f (x, y)
22:02:29 <nak_> they transform function signatures
22:02:42 <iqubic> @src uncurry
22:02:42 <lambdabot> uncurry f p = f (fst p) (snd p)
22:03:02 <Eduard_Munteanu> However, in order for State to be general enough, it must be able to track different kinds of state.
22:03:08 <nak_> or: uncurry f (x,y) = f x y
22:03:41 <iqubic> @check uncurry . curry == id
22:03:42 <Eduard_Munteanu> You might need   type IntState a = State Int a   but others would need some other state.
22:03:43 <nak_> Eduard_Munteanu: so `s` is always the expected type, like the return of a fold?
22:03:43 <lambdabot>  error:
22:03:44 <lambdabot>  • No instance for (Eq (((a0, b0) -> c0) -> (a0, b0) -> c0)) arising from a u...
22:04:11 <iqubic> @check \x -> (uncurry . curry) x == id
22:04:14 <lambdabot>  error:
22:04:14 <lambdabot>  • No instance for (Typeable a0) arising from a use of ‘myquickcheck’ • In th...
22:04:21 <iqubic> @check \x -> uncurry . curry x == id
22:04:24 <lambdabot>  error:
22:04:24 <lambdabot>  • No instance for (Typeable a0) arising from a use of ‘myquickcheck’ • In th...
22:04:27 <MarcelineVQ> easy now
22:04:40 <nak_> iqubic: you can /msg lambdabot directly
22:04:43 <iqubic> Well, looks like quickcheck doesn't like that.
22:04:50 <MarcelineVQ> if you check with lambdabot in private first you look really cool when you get it first try in public :>
22:04:50 <Eduard_Munteanu> nak_, you can pick the state type, but it must be the same throughout chained actions
22:04:55 <nak_> iqubic: well it's not correct
22:05:01 <MarcelineVQ> but you're comparing functions which can be a little tough
22:05:09 <iqubic> Yeah, I know.
22:06:28 <nak_> Eduard_Munteanu: so there's no way to read the value from the last action ?
22:06:40 <iqubic> Is that right though? Does curry . uncurry == id?
22:06:57 <nak_> iqubic: no
22:07:09 <iqubic> Can I see a counter-example?
22:07:19 <Eduard_Munteanu> nak_, runState will run a State action and return the answer along with the final state
22:07:42 <MarcelineVQ> nak_: you sure?
22:08:05 <Eduard_Munteanu> :t runState
22:08:07 <lambdabot> State s a -> s -> (a, s)
22:09:04 <nak_> :t (uncurry . curry)
22:09:06 <lambdabot> ((a, b) -> c) -> (a, b) -> c
22:09:07 <nak_> iqubic: ^
22:09:39 <nak_> i suppose that's an identity
22:09:54 <nak_> but it's definitely not the same as a -> a
22:10:24 <nak_> now i'm second guessing myself, MarcelineVQ !
22:10:25 <EvanR> its a specializtion of a -> a
22:10:46 <EvanR> a = (a2,b) -> c
22:10:52 <MarcelineVQ> nak_: how about this, is id equivalent to  uncurry . curry ?
22:11:01 <augur> nak_: its not the same, but it's provably a sub-function of the a -> a functions :)
22:11:14 <EvanR> a sub function...
22:11:18 <augur> oh shit i ruined MarcelineVQ's question D:
22:11:20 <nak_> Eduard_Munteanu: thank you for your help; i'm going to keep reading up on it to see if i can develop more of an intuition for it's use
22:11:20 <nak_> its* use – i think i'm just getting hung up on teh details
22:12:12 <EvanR> sub function sounds just technical enough to convince people haskell supports them ;)
22:14:18 <johnw> I think sub-function makes sense, in the same vein as subobject or subcategory
22:14:27 <johnw> { f : a -> a | P f }
22:14:37 <johnw> subtype fits this pattern, and subset
22:15:04 <EvanR> theres only one function of type a -> a
22:15:20 <AminoSan> hi
22:15:20 <EvanR> whats P
22:15:25 <johnw> EvanR: not in Haskell
22:15:28 <AminoSan> anyone in here root droids>
22:15:42 <johnw> id, error "foo", error "bar", undefined, unsafeCoerce, coerce, etc. etc.
22:15:56 <johnw> oh, not coerce, n/m
22:16:14 <EvanR> some of thse arent functions
22:16:15 <johnw> AminoSan: wrong channel I think
22:16:43 <johnw> EvanR: throw in some 'const' invocations
22:16:44 <AminoSan> yeah I raelize this 
22:16:55 <AminoSan> but it doesnt make my question any less valid
22:17:05 <johnw> AminoSan: it makes it less valid here :)
22:17:05 <EvanR> yeah it does
22:17:10 <Cale> AminoSan: If you have a question about Haskell, we'd be happy to answer you
22:17:59 <EvanR> johnw: any case, { f : a -> a | P f } seems more like a subset of functions rather than a subfunction (which sounds like itself is a function)
22:18:15 <EvanR> whats a sub function
22:18:16 <johnw> EvanR: I see your point now
22:18:27 <johnw> I was thinking in terms of sets of functions
22:18:31 <Cale> johnw: I would expect it to mean something like f: A -> B is a subfunction of g: C -> D when there exist monomorphisms (or inclusions?) A -> C and B -> D making the square commute.
22:18:51 <johnw> Cale: makes sense
22:18:55 <nak_> AminoSan: whether your question is "valid" is up for debate, but it's certainly off-topic ^_^
22:19:09 <EvanR> k
22:19:41 <EvanR> its a function from a subdomain to a subrange
22:19:52 <nak_> > Abuse of the Continuation monad can produce code that is impossible to understand and maintain.
22:19:54 <lambdabot>  <hint>:1:7: error: parse error on input ‘of’
22:20:02 <nak_> LOL, i think the All About Monads article needs some updates...
22:20:22 <Cale> nak_: That is no less true today than it was then.
22:20:26 <EvanR> continuations have more power and more potential for confusion than goto
22:21:01 <nak_> Cale: oh i didn't mean for those two statements to be linked; though i see how you inferred that 
22:21:14 <nak_> Cale: i was hoping to see more use of shift/reset in the examples
22:21:16 <Cale> Yeah, it's basically goto, except without forward jumps, but with first class labels that you can pass around and return additional values to.
22:21:32 <EvanR>  > im angry about something. today is friday!
22:22:10 <Cale> EvanR: Are you angry that it's not Saturday yet where you are?
22:22:33 <EvanR> its not tomorrow until you go to sleep (tm)
22:23:05 <AminoSan> I love you guys
22:25:13 <nak_> so i'm looking at the MonadTrans instances; sometimes the transformer keeps the "base" monad on the outside, other times it wraps the other monad on the outside
22:25:22 <nak_> that seems ... inconsistent. and annoying
22:26:38 <nak_> ContT Foo will make Cont (Foo a), but EitherT Foo will make Foo (Either a)
22:26:47 <nak_> well that's not perfectly correct, but you get my point, i think
22:26:54 <johnw> nak_: I think it depends on whether the construct you're relating to the monad is traversable or distributive
22:27:06 <johnw> because not every combination N (M a) forms a monad
22:27:24 <johnw> so it depends on what you know about 'N' which constructions will work
22:27:40 <johnw> there are papers on this, if you have a deeper interest
22:28:08 <johnw> it's also something I know a friend has been chewing on
22:28:12 <Cale> nak_: Monad transformers are monads which are defined in terms of another monad -- there are lots of different ways you might do that in general. So long as you can define some function  lift :: (Monad m) => m a -> T m a  (which satisfies a couple easy laws) then your type constructor T can be a monad transformer.
22:28:57 <nak_> Cale: is that the only requirement to make the transformer?
22:29:36 <nak_> (besides implementing Monad too, i mean)
22:29:50 <Cale> Yeah, well, I neglected to say what the laws were
22:29:52 <johnw> (T m -> m) at the endofunctor level needs to be a "monad morphism", that's all that is needed
22:30:05 <johnw> (another way of saying what Cale said)
22:30:06 <Cale> lift (return v) = return v
22:30:37 <Cale> lift (x >>= f) = lift x >>= lift . f
22:30:39 <EvanR> i know theres NoImplicitPrelude, but is there a way to to a particular module as a prelude (no explicit import to use it)
22:30:48 <EvanR> to pick*
22:33:37 <nak_> cale interesting
22:35:44 <augur> EvanR, johnw: sub-function as in, relationally, one is a subset of the other
22:35:56 <nak_> so if I have m, an EitherT e Foo a, and i (m >>= f), what is the expected type of f ?
22:36:45 <nak_> my guess is : (a -> EitherT e Foo a)
22:36:57 <nak_> my guess is : (a -> EitherT e Foo b) *
22:37:10 <EvanR> oh geez... sub-thing as syntactic sugar for subset if everything were a set
22:37:12 <nak_> f* now i don't know
22:37:31 <EvanR> 3 is a subnumber of 4 (in certain encodings)
22:38:09 <EvanR> pi is a subnumber of i
22:38:36 <johnw> augur: in the set theory sense of a subset of the set of pairs that describes f?
22:38:55 <johnw> or in the sense Cale described?
22:39:41 <nak_> :t (>>=)
22:39:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:40:09 <augur> johnw: set theoretic but also Cale-ish :)
22:40:36 <nak_> ok so in the case of monad transformers, m is just like (\a -> EitherT e Foo a)
22:41:03 <augur> Cale's version is a category-theoretic version of the set-theoretic statement
22:41:32 <nak_> so that means that `f` would need the type (a -> Either e Foo a)
22:42:57 <EvanR> i understood cales to be basically, a function from a subset of the domain to a subset of the codomain
22:43:21 <EvanR> now its not set theoretic or category theoretic and we can go home!
22:44:02 <EvanR> though im still not sure if it relates to the prior convo
23:04:49 <EvanR> erm
23:04:55 <EvanR> :t errorWithoutStackTrace
23:04:56 <lambdabot> [Char] -> a
23:05:13 <EvanR> > errorWithoutStackTrace "fruitcake"
23:05:15 <lambdabot>  *Exception: fruitcake
23:06:57 <EvanR> why is this a thing
23:10:52 <MarcelineVQ> at a guess maybe it avoids having to carry around HasCallstack
23:13:07 <MarcelineVQ> iirc HasCallstack causes an implicit parameter to be in scope that has to be accounted for which can impact performance when profiling, not sure if it does when not profiling
23:13:56 <MarcelineVQ> hmm yeah it matters when not profiling too, http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
23:18:15 <EvanR> i started a clojure guide-like pile of haskell functions and non-functions
23:18:48 <EvanR> ... but theres 200 in prelude not including constructors, before i even get to the 10 modules i always import...
23:19:05 <EvanR> man haskell has a lot of words in it
23:19:23 * EvanR leaves to program in untyped lambda calculus
