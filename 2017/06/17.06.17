02:43:37 <ph88^> this algorithm is really slow https://bpaste.net/show/72f3139236fb anyone wanna give it some thought with me how to speed it up ?
03:06:00 <sbrg> ph88^: Did you try the profiler to see where it's doing all the work?
03:29:00 <ondrejs> hi, I want to pick a lens using some condition (`if something then lens1 else lens2`) but that doesn't typecheck -- is there a way to make it typecheck or some generally better solution? Thank you
03:31:56 <julianleviston> ondrejs: are the lenses the same type?
03:32:26 <julianleviston> ondrejs: or do you maybe perhaps want a Prism rather than a Lens?
03:32:52 <julianleviston> ondrejs: I’m guessing they’re not the same type, otherwise it **would** typecheck
03:34:23 <julianleviston> ondrejs: if you say some more about how / where you’re going to use the lens, it might be helpful
03:35:07 <ondrejs> julianleviston: yes, one works on lists of something, the other on lists of something else. The usage is exactly `lens (L.handleListEvent event) state`
03:35:44 <ondrejs> julianleviston: where state is some record with `listA` and `listB`
03:35:45 <julianleviston> ondrejs: can you coerce the lists to be the same and then map them later if need be?
03:36:23 <julianleviston> ondrejs: the main problem is haskell doesn’t let a value be two types at the same time (and therefore a function can’t return two different types)
03:36:30 <ondrejs> julianleviston: technically yes but I'd prefer not to
03:36:41 <julianleviston> ondrejs: however, if you can return a product type of them, then it’ll work fine
03:37:23 <julianleviston> ondrejs: that sounds like you want a prism to me.
03:37:45 <ondrejs> julianleviston: I'm using microlens :-(
03:37:58 <julianleviston> ondrejs: Ah, I don’t know microlens
03:38:07 <Gurkenglas> ondrejs, are "something" and "something else" related like Char and Int or like 'Left "asd"' and 'Right 0' in Either String Int?
03:38:24 <ondrejs> julianleviston: the key point is it doesn't have prisms
03:38:31 <julianleviston> ondrejs: I realised :)
03:39:10 <ondrejs> Gurkenglas: I guess not, one is a List of Strings and the other is a List of a custom data structure
03:39:42 <julianleviston> ondrejs: I wonder if you could defer your lens creation until the use-point
03:40:08 <Gurkenglas> The usage is exactly `lens (L.handleListEvent event) state` <- are those the lens-constructing combinator from the lens library and the state-monad-action-constructor from StateT?
03:40:59 <ondrejs> Gurkenglas: oh that's not a good naming on my part, no state is a custom data struct and lens is just a passed argument (the lens I want to select with if)
03:41:15 <ondrejs> julianleviston: I don't understand that, how does one do that?
03:41:28 <ondrejs> Gurkenglas: * no, state is ...
03:41:49 <julianleviston> ondrejs: state is the s in the normal lens typesignature I’m guessing
03:42:36 <ondrejs> julianleviston: precisely, the type is `Lens' State (L.List () a)` where a is the single thing that changes
03:42:42 <julianleviston> ondrejs: well you seem to want to conditionally pick a lens based on something, as you’ve said. I’m guessing you’ll then use it for something. At the point where you use it, maybe THAT is the place to do the conditional stuff.
03:43:22 <Gurkenglas> ondrejs, I guess that you're implementing a function that is polymorphic in what the list is made of, and that it is passed a boolean parameter that says which of the two list contents you're supposed to handle that time?
03:43:29 <ph88^> sbrg, not yet, but just by looking at the code i can tell you where all the times goes :P
03:43:49 <ondrejs> julianleviston, Gurkenglas: oh, that's a very good idea
03:43:52 <Gurkenglas> ondrejs, instead of the boolean, pass the lens it's supposed to use.
03:45:00 <ondrejs> Gurkenglas: I'm trying to pass the lens, just can't pick it... But I'll do the `if` before the use of lenses and that will work probably
03:45:42 <julianleviston> ondrejs: yeah, push the conditional to the last possible point, then you might find that the “resultant” value from **using** the lens is a single type, so your problem will go away
03:46:00 <julianleviston> ondrejs: (a single type in both clauses of the conditional)
03:47:00 <julianleviston> ondrejs: it’s a bit annoying, that restriction, but it saves us, because it lets us type check things, and that’s a pretty big win in terms of consistency and being able to change things without impact in other parts of programs, consistency, understanding what’s going on (reasoning about programs), etc.
03:49:22 <ondrejs> julianleviston, Gurkenglas: works like a charm now, thank you very much
03:49:31 <julianleviston> ondrejs: awesome!
03:52:26 <julianleviston> Gurkenglas: ooh I wonder if you can help me with my plated/Context question...
03:55:31 <julianleviston> Gurkenglas: I’ve been trying to understand if the contexts and function from (referenced in Control.Lens.Plated) does what I need, which is like a list of lenses of all of the sub-parts of a piece of AST in a super simple grammar I’ve defined… it has type contexts :: Plated a => a -> [Context a a a] and I really don’t understand Context, other than I know I can call pos on it and it’ll return the focus… 
03:55:50 <julianleviston> ( oops… “contexts function”, not “contexts and function”)
03:58:07 <julianleviston> Gurkenglas: trouble is, if they **are** lenslike things, I’m not entirely sure how I do a “set” or an “over” on them. Those functions don’t appear to work… there’s a function called “peek” which seems to modify them, but not in ways I understand…  it’s something using a ComonadStore and I don’t really get it
03:58:55 <julianleviston> (sorry should say “apply pos to it” rather than “call pos on it”)
03:58:59 <Gurkenglas> julianleviston, "contexts :: Plated a => a -> [Context a a a]" "Return a list of all of the editable contexts for every location in the structure, recursively." and "data Context a b t" says "A Context is like a Lens that has already been applied to a some structure."
03:59:11 <julianleviston> yeah...
03:59:53 <Gurkenglas> So, I suppose that means we should be able to get the value out without needing to supply the s, and to set the value without needing to supply the s
04:00:16 <Gurkenglas> That's the two things we get if we unpack the "Context (b -> t) a" constructor
04:00:36 <julianleviston> so if I do map pos (contexts myAst) it’ll give me a list of all the sub-structures, which is good… (that’s the get part)
04:00:41 <julianleviston> but I have no idea how to do the set.
04:00:48 <julianleviston> or an “over” equivalent
04:00:56 <julianleviston> they appear to act a bit like lenses… 
04:01:13 <Gurkenglas> data Context says cloneLens uses it, so let's look in it's source *looks* "cloneLens l afb s = runPretext (l sell s) afb"
04:01:46 <julianleviston> hehe I’ve been bashing around in these repos for the last month or so on and off
04:04:14 <Gurkenglas> data Context lied, cloneLens uses Pretext
04:05:11 <Gurkenglas> The trivial way to use the set from the Context is to match the Context with "Context btot _" and have btot as the b -> t
04:05:49 <Gurkenglas> brb
04:06:08 <julianleviston> maybe… I’ve noticed some of the things are interchangeable and there are things like LensLike which are looser.
04:06:42 <julianleviston> I’m not sure what btot is, by the way?
04:07:47 <julianleviston> oh lol… b to t. gotcha :) pattern matching the function out of it.
04:08:33 <julianleviston> Pretext: This is a generalized form of Context that can be repeatedly cloned with less impact on its performance, and which permits the use of an arbitrary Conjoined Profunctor
04:08:44 <ph88^> i used to use this command to build with profiling    stack build --profile --fast --ghc-options="-j -auto-all +RTS -A128m -n2m"    however now i get this message:   RTS options are disabled. Link with -rtsopts to enable them.     what could be wrong here ?
04:10:55 <julianleviston> ph88^: I don’t know, this is just a guess, but it sounds like when it was compiled it wasn’t compiled with the RTS option linking “on”.
04:11:38 <julianleviston> ph88^: hm… https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/runtime-control.html#rts-opts-cmdline
04:11:53 <ph88^> i found a solution now
04:12:01 <julianleviston> ph88^: oh what was it?
04:12:06 <julianleviston> not using quotes?
04:12:06 <ph88^> if i first do    stack clean    and then use the exact same command it recompiles and it works
04:12:20 <ph88^> no the command is good .. i used it many times before
04:12:39 <ph88^> but for some reason   stack had compiled a wrong version before and didn't recompile when i did    stack build
04:12:59 <julianleviston> ohhhh you have to compile the file with -rtsopts on, then pass the rts flags to the program when you run it?
04:13:02 <ph88^> not sure how it got into this state that i had to do   stack clean
04:13:11 <julianleviston> Ah, so that stuff is being passed to GHC.
04:13:15 <julianleviston> gotcha
04:13:22 <ph88^> i do these two commands:
04:13:23 <ph88^> stack build --profile --fast --ghc-options="-j -auto-all +RTS -A128m -n2m -RTS"
04:13:26 <ph88^> stack exec -- bowtie +RTS -p
04:13:40 <ph88^> they always work .. except now they didn't work .. then i did stack clean and then it worked again
04:13:46 <julianleviston> sweet!
04:14:09 <ph88^> yes but i don't understand how stack got into a state of having compiled something wrong and then not wanting to recompile
04:14:16 <julianleviston> the more I use Haskell, the more it’s just amazingly cool
04:14:39 <ph88^> true
04:14:48 <ph88^> did you do profiling ?
04:14:51 <ph88^> that's the command you can use
04:14:58 <ph88^> there is also a good program with it to visualize
04:15:00 <ph88^> profiteur
04:15:02 <ph88^> it makes nice html pages
04:15:17 <julianleviston> ph88^: haha no I’ve never done it. If you read the concurrency book, though, it’s got loads of stuff about that in there. I mean to go back to that book and re-read it again
04:15:49 <ph88^> i've read a bit about it and used parMap in some places
04:16:01 <ph88^> you don't always get a speed up
04:16:22 <ph88^> use /usr/bin/time  to time your program
04:16:31 <ph88^> or criterion benchmarks
04:20:52 <julianleviston> Gurkenglas: oh wow… I worked out how to do it, the type signatures of peek were throwing me, is all… I just do peek newVal aContext and it works :) ZOMG thanks for helping me by talking to me about it <3 :)
04:21:14 <zyhn> would anyone mind looking at this quick and tell me what I'm missing? http://lpaste.net/356306
04:23:17 <julianleviston> I still need an over, but I can make my own, hopefully it’s not too inefficient
04:23:57 <julianleviston> zyhn: ooh that looks interesting
04:24:53 <zyhn> i'm using stack lts-818 (GHC 8.0.2) if that helps
04:25:59 <cocreature> zyhn: hm worksforme™. are you sure you have recompiled after adding the TemplateHaskell pragma?
04:28:33 <zyhn> yes I definitely saved.... but just to make sure i closed and reopened the file... and it turns out emacs bugged and wasn't showing the entire buffer
04:29:02 <zyhn> all is well now, thanks
04:29:25 <julianleviston> woo :)
04:31:39 <ongy> emacs is such a nice environment. if only it had a good editor :)
04:44:57 <julianleviston> I wonder if contexts are composable in some way
04:45:34 <julianleviston> I kind of want a paramorphism (Lens.para), but rather than values, I’d like it to provide Contexts connected to the original values
04:46:46 <julianleviston> original value*
04:48:10 <julianleviston> Ah… contextsOnOf, if I knew how to build a traversal that focussed on only one level… I guess that’s what `plate` is...
04:48:19 <cocreature> that’s exactly what plate is :)
04:48:24 <julianleviston> :) yay
04:48:56 <julianleviston> Except… I’d want to use para to successively focus on each… which I *think* could do, tho it wouldn’t keep the original context… hmmm
04:49:29 <julianleviston> oh… wait I think I’ve got it
04:50:44 <julianleviston> in any case, I’ll have more of a think and it feels like I’m on the right track :)
04:51:01 <julianleviston> the sources for Control.Lens.Plated are helping enormously
04:54:02 <cocreature> Control.Lens.Plated is one of those things that I keep forgetting about and after being really annoyed that I had to write a lot of boring boilerplate I remember that it exists and can replace all of it by two lines of plated
05:00:31 <Sh4rPEYE> I have a StateT newtype like this: newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }
05:00:31 <Sh4rPEYE> Can I implement fmap more simply than this: fmap f (StateT ma) = StateT $ \s -> fmap (\(x,y) -> (f x, y)) (ma s)
05:00:59 <dibblego> \s -> fmap (\(x,y) -> (f x, y)) (ma s)
05:01:04 <dibblego> fmap (\(x,y) -> (f x, y)) . ma
05:01:53 <Tuplanolla> Then `fmap (first f) . ma`.
05:02:09 <Sh4rPEYE> Oh, that's the thing from Arrows
05:02:22 <Tuplanolla> More generally from bifunctors.
05:03:05 <Tuplanolla> :t Bi.first
05:03:06 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
05:03:52 <dibblego> fmap (_1 %~ f) . ma
05:03:54 <Sh4rPEYE> Oh, I see
05:04:10 <Sh4rPEYE> Whoa and what'ß that supposed to be? :-D
05:04:17 <Tuplanolla> Lens magic.
05:05:29 <Sh4rPEYE> I guess I'll go with first. Monad Transformers are enough for the day, lenses would probably kill me 
05:25:10 <hanso> hello
05:29:09 <ph88^> hi hanso 
05:30:39 <hanso> ph88 where are you from?
05:33:07 <ph88^> europe
05:33:29 <hanso> oh nice country :D i'm from germany 
05:35:47 <ph88^> cool
05:35:56 <ph88^> you know algorithms and haskell ? 
05:36:48 <hanso> no i'm all new to this 
05:37:06 <ph88^> you started making your first program ?
05:37:32 <hanso> nah just joined a random channel :D
05:38:10 <ph88^> you wanna get started with haskell ?
05:39:04 <hanso> what can i program with haskell?
05:40:10 <ph88^> just about everything except for systems programming i would say
05:41:50 <jophish> I wonder if there exists some kind of accumulating state applicative
05:41:56 <jophish> where the state can only be appended to 
05:42:13 <cocreature> jophish: Writer?
05:42:20 <jophish> Yeah, perhaps
05:42:38 <jophish> And this state could be queried in the computation
05:43:02 <jophish> but some property of the mutating function (append only) makes an applicative interface possible
05:43:15 <jophish> the result would be the fixed point of this function over the state
05:43:45 <jophish> I'm not *entirely* sure I've worked out exactly what I want here
05:45:40 <jophish> cocreature: Write doesn't necessarily allow this (the fixed point to not diverge)
05:45:45 <jophish> Writer*
05:45:53 <jophish> coz it can use any monoid
05:46:11 <jophish> but I've done simimlar things by just using `:`
05:46:30 <ph88^> cant you just use an accumulator with fold ?
05:46:40 <jophish> heh, it might end up like that
05:46:56 <jophish> allow me to explain the base problem, perhaps there is a nicer solution!
05:47:45 <jophish> I've currently got a program built using Control.Monad.Operational, however I'd like to inspect and optimize these programs, and the monadic nature of them makes this very difficult (impossible)
05:48:00 <jophish> So I'd like to switch over to using Control.Applicative.Operational
05:48:20 <jophish> However the code which constructs these programs lives in State
05:49:00 <jophish> Each instruction has a product, and state is used to increment a counter, numbering each output
05:49:30 <jophish> This allows the outputs to be shared by later instructions
05:49:51 <jophish> as they can just query the Map held by State with the number the output was given when it was created
05:50:20 <jophish> I don't think that there's anything fundamentally monadic about this structure, the actual numbers don't matter (aside from their uniqueness)
05:51:01 <jophish> And the program construction doens't depend on the output of the instructions (apart from the number)
05:51:25 <jophish> Perhaps I could construct this monadically, and then lower it to an applicative
05:51:43 <cocreature> just use a regular old ADT for your instructions and create it in State Unique
05:53:07 <jophish> well, it'd going to end in Monad Operational at the end of the day because it's so darn useful!
05:53:10 <jophish> it's*
05:53:27 <jophish> cocreature: That might be the best way to construct these though
05:53:36 <alanz> So, half a million lines more of haskell in Debian stretch vs jessie. http://sources.debian.net/stats/stretch/ and http://sources.debian.net/stats/jessie/
05:53:39 <cocreature> fair enough, I never really got anything big out of operational
05:54:01 <jophish> We've got quite a fancy neural network library written using it :)
05:54:06 <jophish> I hope to be able to open source it soon
05:54:21 <jophish> It's really quite cool, all the tensors are sized at the type level
05:54:52 <jophish> It's very safe to use, but the typechecker pleasing overhead it burdensome
05:54:56 <cocreature> adding sizes to the type level seems pretty orthogonal to using operational, no?
05:55:10 <jophish> Oh yes, that was just an aside :)
06:00:16 <jophish> cocreature: I got quite excited for a second: https://hackage.haskell.org/package/applicative-extras-0.1.4/docs/Control-Applicative-State.html
06:00:38 <jophish> I suppose that's from before Applicative was a superclass of monad
06:01:27 <cocreature> heh yeah, that package hasn’t been updated in 8 years
07:14:27 <falcon01> exi
07:35:22 <Sh4rPEYE> Is this valid code? I.e. can I assume the "Just" on the last line?
07:35:22 <Sh4rPEYE> maybeExcite :: MaybeT IO String
07:35:23 <Sh4rPEYE> maybeExcite = MaybeT $ do
07:35:23 <Sh4rPEYE>   v <- getLine
07:35:25 <Sh4rPEYE>   guard $ isValid v
07:35:25 <Sh4rPEYE>   Just <$> return v
07:38:33 <Sh4rPEYE> It throws an exception if the string is not valid... But I guess I'd rather want to get Nothing
07:40:45 <EvanR> :t MaybeT
07:40:47 <lambdabot> error:
07:40:47 <lambdabot>     • Data constructor not in scope: MaybeT
07:40:47 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
07:40:50 <cocreature> Sh4rPEYE: you probably want something like do v <- liftIO getLine; guard (isValid v); return v
07:41:01 <Tuplanolla> :t do {v <- liftIO getLine; guard (null v); pure v}
07:41:02 <lambdabot> (Alternative m, MonadIO m) => m String
07:41:11 <Tuplanolla> This is a generalization of it, Sh4rPEYE.
07:41:32 <Tuplanolla> (I replaced `isValid` with `null` for lambdabot.)
07:41:45 <cocreature> it’s not really a generalization. it does something different
07:42:04 <Sh4rPEYE> The point of interest lies at liftIO anyway
07:42:11 <cocreature> but it’s probably what Sh4rPEYE  intended to do :)
07:42:38 <Tuplanolla> Yes, cocreature. I was referring to the type `MaybeT IO String`.
07:44:06 <Sh4rPEYE> So I... get some IO String, lift it to MaybeT IO String, strip it from MaybeT and so v is IO String and the do-block is in MaybeT monad? 
07:44:47 <Welkin> Sh4rPEYE: do you understand how do-notation desugars into bind and lambdas?
07:44:51 <Sh4rPEYE> Yes
07:45:12 <Welkin> then you answered your own question
07:45:15 <Tuplanolla> :t liftIO -- You embed the `IO` layer into the `MaybeT` there, Sh4rPEYE.
07:45:17 <lambdabot> MonadIO m => IO a -> m a
07:45:53 <Welkin> you cannot "escape" a monad from within bind
07:47:13 <Sh4rPEYE> I'm not trying to say that (I think). I'm in the MaybeT monad from the start, because I use its bind, not the IO's.
07:47:30 <Sh4rPEYE> Because before I use bind, I embed the IO String in MAybeT
07:47:49 <cocreature> right
07:47:54 <Tuplanolla> Yes, but `v :: String` there.
07:49:20 <Sh4rPEYE> Oh. The MaybeT's bind then "skips" both structures, Maybe and IO (in this case), right?
07:49:34 <Welkin> :t MaybeT
07:49:35 <lambdabot> error:
07:49:35 <lambdabot>     • Data constructor not in scope: MaybeT
07:49:35 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
07:50:06 <Sh4rPEYE> It's data MAybeT m a = MaybeT {getMaybe :: m (Maybe a)}
07:50:40 <Tuplanolla> Not quite, Sh4rPEYE. Check the type of `liftIO` for your example.
07:51:00 <Welkin> http://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Maybe.html#v:-62--62--61-
07:51:07 <Welkin> (>>=) :: MaybeT m a -> (a -> MaybeT m b) -> MaybeT m b
07:51:46 <Welkin> `MaybeT IO` is your monad here
07:52:21 <Welkin> transformers are quite confusing
07:52:33 <Welkin> I found extensible effects (in purescript) more intuitive
07:52:42 <Sh4rPEYE> Oh, sure. The instance is for (MaybeT m)
07:53:15 <Sh4rPEYE> Now it makes better sense; the bind just does away with one monad as always :-D
07:53:50 <Tuplanolla> The trick is that `MonadIO m => IO a -> m a` specializes to `IO a -> MaybeT IO a` thanks to the instance `MonadIO m => MonadIO (MaybeT m)`, Sh4rPEYE.
07:54:52 <eacameron> Is there a summary somewhere where I can learn about the various tools for making records not suck in Haskell? Using OverloadedRecordFields, or something?
07:55:17 <Welkin> eacameron: use lens
07:56:06 <Welkin> there are extensions for making it better, but they are not ready for real use yet from what I have heard
07:56:11 <eacameron> Welkin: There's only one thing about lens that I don't like: creating a brand now object of some type. It's not nearly as convenient as record creation syntax.
07:56:12 <Sh4rPEYE> Tuplanolla: I think I understand. Can I think about that like this: If I liftIO an IO String "Hello", will I get IO (Just "Hello")?
07:56:39 <Tuplanolla> No?
07:58:27 <Sh4rPEYE> Damn. Wanted to somehow visualize lifting
07:59:20 <Tuplanolla> :t \ f x -> liftIO $ f x -- Does this help?
07:59:22 <lambdabot> MonadIO m => (t -> IO a) -> t -> m a
08:00:34 <Tuplanolla> It says that if your monad stack `m` has an `IO` capability, you can run an `IO` computation anywhere inside it.
08:01:23 <Tuplanolla> You just need to push it through `liftIO` first.
08:02:17 <monochrom> If you're using MaybeT, you get MaybeT IO String
08:02:35 <`Guest00000> i want a big article about all existing exact real representations
08:02:36 <Welkin> `liftIO` uses `lift` as many times as it needs to in order to get to the `IO` layer, otherwise you would need to count your `lift`s yourself
08:03:21 <monochrom> "IO (Just "Hello")" is conflating types with values. You don't speak like "Either (Left 4) (Right False)".
08:03:46 <EvanR> `Guest00000: i found a paper reviewing several
08:05:15 <eacameron> Oh nice, RecordPuns looks like a nice extension that I've wanted before but didn't know existed.
08:06:26 <eacameron> NamedFieldPuns, rather
08:07:19 <`Guest00000> eacameron: why not review all GHC exts in the GHC user guide then
08:07:34 <c_wraith> because the user guide is thousands of pages long
08:07:34 <eacameron> `Guest00000: That's exactly what I'm doing.
08:08:03 <eacameron> Rather, I'm starting with Stephen Diehl's convenient table
08:08:11 <EvanR> read the finite manual
08:08:34 <`Guest00000> c_wraith: that doesn't directly motivate it yet
08:09:10 <`Guest00000> it doesn't imply that the GHC exts section in it is very long
08:09:25 <tomleb> My project compiles with `stack ghci` but not `stack build`, why ?
08:09:28 <codeiter> > 
08:09:30 <lambdabot>  <no location info>: error: not an expression: ‘’
08:13:44 <lyxia> tomleb: is there an error message
08:15:28 <tomleb> lyxia: parse error on input ‘<-’
08:15:28 <tomleb>     Perhaps this statement should be within a 'do' block?
08:16:50 <lyxia> I don't know. Can you paste your code?
08:17:13 <tomleb> lyxia: http://ix.io/xC7/hs
08:18:21 <monochrom> I think you need your "mModerator ..." and "case ..." to be more indented.
08:18:22 <lyxia> try indenting the block lines 4-10 more
08:19:16 <monochrom> It is strange that there is a way to compile it at all.
08:19:17 <tomleb> Yup that was as simple as that, I feel dumb, thanks
08:19:26 <tomleb> Why ?
08:19:32 <tomleb> You mean it shouldn't compile at all ?
08:19:39 <monochrom> "My project compiles with `stack ghci`"
08:19:44 <monochrom> Right.
08:20:27 <lyxia> hmmm I can't reproduce that error here
08:21:22 <monochrom> Is this something where -XHaskell98 vs -XHaskell2010 would make a difference?
08:21:38 <nbro> Why isn’t Haskell smart in this situation: [n | n <- [0..], n `mod` 2 /= 0, n < 100]?
08:21:52 <lyxia> tomleb: what version of GHC are you on
08:21:58 <monochrom> Because Haskell is just a programming language, not a theorem prover?
08:22:05 <tomleb> lyxia: That's a very good question
08:22:25 <lyxia> nbro: it's also not about being smart, but correct.
08:22:26 <tomleb> How do I find out ?
08:22:28 <tomleb> Using stack
08:22:38 <nbro> monochrom: what’s difficult to implement in: [n | n <- [0..], n `mod` 2 /= 0, n < 100] to make it behave smartly?
08:22:48 <EvanR> the halting problem
08:23:13 <nbro> EvanR: why?
08:23:22 <lyxia> tomleb: stack ghc -- --version
08:23:31 <monochrom> I don't think this one is difficult. I do think it is this way because Haskell is intended to be just a programming language, the computer follows a very simple-minded semantics.
08:23:31 <EvanR> why is it difficult?
08:23:35 <nbro> why is the halting problem related to that condition in the list comprehension?
08:24:06 <mekeor> will this library for accessing GPIO pins on a Raspberry Pi work on Raspberry Pi version 3, too? https://github.com/WJWH/HPi
08:24:09 <monochrom> FWIW try "if undefined then () else ()" some time.
08:24:13 <lyxia> monochrom: you are right about Haskell98 vs 2010
08:24:15 <tomleb> lyxia: The Glorious Glasgow Haskell Compilation System, version 8.0.2
08:24:18 <EvanR> if by smart you mean get a finite list, because the halting problem is equivalent to asking if an arbitrary list program produces a finite list
08:24:23 <monochrom> \∩/
08:25:17 <EvanR> the problem has the worst possible (?) computational complexity, undecidable
08:25:22 <Tuplanolla> List comprehensions are just syntax for `do` blocks that are just syntax for binds, so GHC would either have to perform crap analysis or no analysis at all, nbro.
08:25:28 <cggong> I have a file that I would like to read repeatedly line by line. Is it possible to write an analogue of getLine, say like getLineFromMyFile :: IO String, such that if I sequence two such IO actions, I get two successive lines, rather than get the first line over and over again? 
08:25:35 <nbro> EvanR: the halting problem is undecidable in the general case, not in this one. In this one you could implement an algorithm that produces a finite list
08:25:42 <mniip> EvanR, that
08:25:45 <mniip> 's not the worst
08:25:45 <EvanR> what is this case?
08:25:54 <mniip> the worst is unknown whether decidable
08:25:55 <lyxia> tomleb: it seems your ghc is being run with -XHaskell2010 which has different indentation rules than the default Haskell98.
08:26:00 <EvanR> heh
08:26:06 <nbro> EvanR: it’s a very specific case
08:26:17 <EvanR> exactly what you wrote?
08:26:18 <Tuplanolla> If you want said crap analysis, rewrite rules should get you there, nbro.
08:26:19 <mniip> nbro, where would you draw the line
08:26:20 <barrucadu> nbro: If GHC gave a finite list in this case, it would be wrong.  Optimisations should not change the semantics of a program.
08:26:25 <monochrom> No! -XHaskell2010 is the default.
08:26:26 <mniip> between specific cases and aa general case
08:26:28 <tomleb> lyxia: yeah well I do have Haskell2010 in my cabal file
08:26:49 <barrucadu> Here you are saying "for every element of this infinite list, if it meets these two conditions, give me it."  That computation simply cannot terminate.
08:26:52 <lyxia> tomleb: but usually we don't notice the difference
08:26:56 <tomleb> Isn't that what people are using ?
08:27:01 <lyxia> tomleb: because these lines should really be indented more
08:27:13 <lyxia> tomleb: it is.
08:27:18 <EvanR> in that sense giving a finite list would be dumb not smart
08:27:26 <EvanR> since it doesnt follow the rules we already know
08:27:47 <nbro> But my question is: why limiting the implementation of features of Haskell to Haskell?
08:27:58 <mniip> it's not limiting
08:27:59 <barrucadu> The only reasonable way to get a finite list would be to add some sort of takeWhile syntax to list comprehensions
08:28:02 <monochrom> nbro, patches welcome.
08:28:02 <mniip> you can work around it easily
08:28:14 <EvanR> there are projects that implement a different compiler backend, so you get different semantics for haskell
08:28:25 <Tuplanolla> As an added bonus: if you give it the signature `[Int]`, you'll eventually get an exception, nbro.
08:28:32 <nbro> barrucadu: why would it be wrong?
08:28:38 <lyxia> monochrom: it's not a default to me if I'm outside a project
08:28:43 <mniip> Tuplanolla, will you?
08:28:48 <Tuplanolla> > succ maxBound :: Int
08:28:49 <mniip> succ maxBound = minBound
08:28:50 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
08:28:50 <barrucadu> nbro: Because it would not match the rules for desugaring list comprehensions
08:28:52 <mniip> oh
08:29:16 <mniip> > [maxBound .. minBound] :: [Int]
08:29:17 <EvanR> i did not know that succ maxBound would do that
08:29:18 <lambdabot>  []
08:29:24 <mniip> > [maxBound .. ] :: [Int]
08:29:26 <lambdabot>  [9223372036854775807]
08:29:27 <EvanR> > succ maxBound :: Bool
08:29:29 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
08:30:53 <erisco> :t succ
08:30:55 <lambdabot> Enum a => a -> a
08:31:09 <barrucadu> nbro: For it to br "right", the rules for list comprehensions in the Haskell Report would need to specify where apparently-infinite computations should terminate.  And that will never satisfy everyone, as there's always a more clever analysis you can implement to get one or two more cases.
08:31:14 <barrucadu> *to be
08:31:43 <EvanR> you can certainly design a different language or a different semantics for the same syntax
08:31:58 <tomleb> I asked in #servant and no answer, is there a way to have an AuthProtect use a value of a QueryParam ?
08:32:10 <EvanR> the original question i thought certainly would be answered by "because you werent there to opine on the design of haskell"
08:32:37 <monochrom> nbro: https://plus.google.com/u/0/102208456519922110915/posts/DZsZ6mvA4T6 will make you happy again.
08:35:55 <spinus> is it possible to throw custom error message in hspec so I can read what's wrong in the terminal? Or is there any other way to generate custom feedback?
08:37:17 <cocreature> spinus: https://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html#v:expectationFailure
08:38:27 <spinus> cocreature: thank you
08:49:29 <Sh4rPEYE> I'm writing a little game, which asks a player to guess a number and keeps track of his score using StateT + IO. How I can run the state-keeping "game" function from the main function repeatedly, and if the user types "exit", show him the final score?
08:51:14 <benzrf> Sh4rPEYE: what do you have so far?
08:52:03 <sm> go Sh4rPEYE!
08:53:12 <Sh4rPEYE> Actually, just this: http://lpaste.net/7957555710554800128
08:53:55 <Sh4rPEYE> (it's a variation of Morra. Player and PC pick 1 or 2, and if the final sum is even player wins, otherwise PC wins)
08:53:57 <hjulle> How do you see which extensions are currently enabled in GHCi?
08:57:18 <glguy> :showi language
08:59:13 <duckqlz> hjulle: there are a bunch of show commands which appead at the bottom of the help screen (:? or :h)
09:00:01 <c_wraith> why is that the only one that's :showi instead of :show?
09:02:28 <geekosaur> it's the most common one you'd want different between compiled and interactive
09:02:54 <c_wraith> Do any of the :show commands make any sense in non-interactive contexts?
09:02:58 <Sh4rPEYE> benzrf: I can't get it to work, so even the play function is wrong.
09:03:00 <geekosaur> also the only one that differs between the two by default
09:03:00 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#setting-options-for-interactive-evaluation-only
09:04:08 <c_wraith> Oh, I see.  The other case is still interpreting in ghci, just not line-by-line
09:04:13 <xman> hi all, can one tell me a source from where book are possible to get?
09:04:14 <glguy> c_wraith: There's actually both a ":show language" and ":showi language" version
09:04:14 <xman> http://www.springer.com/gb/book/9783319527444#aboutAuthors
09:04:16 <xman> I need this book
09:05:08 <c_wraith> xman: I think that's about things like flight control english, which is not really english - it consists of a fixed set of phrases that happen to contain english words.
09:05:28 <glguy> xman: This channel is about Haskell Programming
09:07:15 <zomg> xman: the book store would be a pretty good place to start
09:07:37 <zomg> also, to be more on topic of the channel - the topic of that book reminds me of Domain-Driven Design somewhat
09:09:26 <xman> c_wraith: I need to get this book from somehwer e:(
09:09:39 <c_wraith> xman: well, this isn't the place.
09:09:50 <xman> zomg:?
09:10:02 <xman> c_wraith: I know, but here are inteligent ppl :)
09:10:09 <zomg> xman: there's literally a button to buy the book on the page you linked
09:12:01 <xman> zomg: I am  poor
09:12:05 <xman> zomg: I am  poor student
09:12:17 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.109.193.163.36
09:12:54 <Sh4rPEYE> I'd wager a third of this channel are students
09:13:15 <Welkin> o.o
09:14:27 <Welkin> lol zomg
09:15:41 <ongy> I'd wager a decent university has the book in the library
09:16:20 <Sh4rPEYE> Or not? I see some simple question arise quite often... I though many ppl are here to get help learning Haskell, myself included.
09:16:20 <Sh4rPEYE> I didn't mean any offense. The rest here are genial Haskellers. (@Welkin)
09:17:37 <Welkin> Sh4rPEYE: I was a student when I started learning haskell
09:18:08 <Welkin> I know there are students here, but not sure how many
09:18:28 <ongy> probably less students than people that just idle 24/7
09:18:29 <Welkin> some people come in for homework help (or rather to ask us to do their homework for them)
09:21:10 <ongy> when I still had to do haskell homework, I was in an irc channel with my tutor/TA. hehe
09:23:00 <Welkin> you are lucky to have done haskell homework
09:23:07 <Welkin> I never got the opportunity
09:26:38 <ongy> to be honest, I'm really happy I got forced to do haskell
09:26:44 <ongy> otherwise I would have given up after 2 weeks
09:26:47 <ongy> when I had to get my head around IO
09:33:06 <torstein> say I have: data Optimization = Min [Double] | Max [Double]; Is there a way to get the list of doubles out w/o pattern matching? Can I derive something or construct the data type another way?
09:33:39 <mniip> you could use a helper function
09:33:54 <torstein> I know, but is there another way?
09:34:02 <torstein> Seems a bit clunky
09:34:05 <mniip> or use a datum similar to 'data Optimization = Optimization { isMax :: Bool, whatever :: [Double] }
09:34:06 <mniip> '
09:37:14 <EvanR> the idiomatic way would be to make a helper function
09:38:10 <EvanR> everything is based on pattern matching everywhere (except record accessors, even then you can use pattern matching to good effect)
09:38:55 <Sh4rPEYE> This is my Morra implementation: http://lpaste.net/7957555710554800128
09:38:55 <Sh4rPEYE> Any way to make it nicer?
09:39:48 <pikajude> what the hell is "foundation"
09:39:52 <pikajude> is it another prelude replacement package
09:40:48 <glguy> ?hackage foundation
09:41:05 <glguy> Oh, well anyway: http://hackage.haskell.org/package/foundation read the top
09:41:37 <pikajude> oh look, a custom prelude package
09:41:49 <glguy> Mostly its a dependency you get to build if you're still using cryptonite
09:41:58 <pikajude> i see
09:42:05 <pikajude> i've never seen it before but it showed up in my nix build
09:42:15 <pikajude> thought it was a recently reintroduced dependency of something
10:01:21 <tsmish> Sh4rPEYE: I think you can use execStateT instead of runStateT
10:01:57 <`Guest00000> shR314
10:09:33 <Xion_> I keep hearing about free monads here and there. Is there a straightforward introduction to the topic somewhere?
10:11:59 <cocreature> pikajude: it might be worth noting that foundation is different from most other custom preludes in that it’s not just a bunch of reexports but it actually includes a fair amount of new stuff, e.g., replacements for vector, text and bytestring
10:12:08 <cocreature> whether that’s a good or a bad thing is up for debate :)
10:16:29 <torstein> Xion_: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html  or   https://www.youtube.com/watch?v=gUPuWHAt6SA
10:18:40 <Xion_> Great, thanks
10:24:08 <quchen> ReinH: You’re awesome
10:24:26 <quchen> ReinH: I’m not sure why there is no function type information included in the JSON, maybe because I decided to skip it.
10:25:06 <quchen> But that output is quite pretty already! I gave you push access to the repo, feel free to push your work there!
10:27:13 <quchen> ReinH: Hmm no, I think I’m including blackhole information in the output
10:28:21 <quchen> https://github.com/quchen/stgi/blob/db5eb9d5ce08875a836d3674f9fe9c28fad2b058/app/ReactFrontendMain.hs#L101
10:30:20 <quchen> ReinH: Maybe I gave you an outdated dump? Running the react executable target should give you a better version, if so
10:30:54 <quchen> ReinH: Oooh, I see, you’re annotating heap entries of globals with their global name right after the »blackhole«. That’s cool.
10:32:47 <quchen> ReinH: I think I understand what you meant now. I *am* including »blackhole«, but I am not including »Fun/Thunk/Con«. That’s correct. The latter is actually irrelevant to the STG’s execution, and purely for displaying purposes. I’ll add it in a new commit, since, well, you’re building a frontend :-D
10:33:15 <Welkin> quchen: it looks like you are talking to yourself o.o
10:33:53 <quchen> Eeechhhoooooo
10:33:54 <geekosaur> one of those clients that doesn't distinguish private vs. public well enough
10:33:56 <quchen> <nothing comes back>
10:33:58 <unknownln> What'd be the best way to get a local copy of the docs for all packages in a stackage LTS?
10:34:40 <unknownln> Built them all manually, or is there a prebuilt download I can grab somewhere?
10:36:01 <unknownln> The intent being that I can view it offline later without having to predict specifically which packages I'll need the docs for
10:52:19 <orion> Does anyone know why I would be getting this error with stack?: In the dependencies for Cabal-1.24.2.0: base must match >=4.5 && <5, but the stack configuration has no specified version (latest applicable is 4.9.1.0)
10:52:33 <orion> It makes no sense because 4.9 is clearly within the bounds >=4.5 && <5.
10:53:49 <geekosaur> it's just a poor error message, the real problem is "stack configuration has no specified version" which suggests something is wrong with the resolver config
10:54:27 <orion> The project's stack.yaml file?
10:54:46 <geekosaur> likely yes
10:56:25 <acyed> So I'm working my way through the book Haskell Programming and I'm at the hangman game. randomRIO is used to produce random numbers with the type IO a. When I try and save the value into a variable, it produces a new random number every time it's called. I think I understand that IO a is an action, and I've stored that action, so this all makes sense. But how do I extract the value from the action
10:56:25 <acyed> ? I don't want a new number every time I use my variable 
10:57:42 <orion> geekosaur: Does this look invalid to you?: https://gist.github.com/centromere/45e0f6774f66126cd5216a7314249ec3
10:57:43 <geekosaur> you need to use <-, not let =
10:59:39 <quchen> acyed: do { random <- randomRIO (1,10); print random }
10:59:39 <quchen> acyed: <- performs an IO action
10:59:39 <quchen> And binds its result to the left-hand side
10:59:39 <quchen> cake <- recipeToMakeCake
11:01:14 <geekosaur> orion, seems okay to me, but stack apparently disagrees
11:01:26 <geekosaur> 'stack solver' might be something to try at this point
11:02:01 <geekosaur> otherwise I think you need someone who knows more about stack than I do. all I can see is that 'stack configuration has no specified version' sounds like stack is very confused about something
11:02:43 <orion> I actually blew away both ~/.stack and .stack-work/ and am trying over.
11:02:55 <orion> trying again*
11:04:44 <orion> geekosaur: "No changes needed to stack.yaml"
11:04:45 <orion> :(
11:05:00 <pikajude> :(
11:06:08 <kadoban> orion: What is the actual thing you're running, in what context? And what's the error?
11:06:35 <orion> kadoban: I'm running "stack build --haddock" from the root of my project directory.
11:06:44 <orion> The error is as I pasted above.
11:08:38 <kadoban> That's usually the error you get when your resolver (or extra deps) don't have the dependency you've specified in .cabal, so you have to add it to stack.yaml. But it doesn't make sense with base, every resolver has base in it I think.
11:09:39 <kadoban> The "latest applicable" part means what's on hackage essentially. It's meant as assistance if you want to add that to your extra-deps easily
11:09:49 <kadoban> But again, don't think that makes sense with base, so I have no idea.
11:13:08 <orion> I do not get the error when I specify --no-haddock-deps
11:13:14 <Gurkenglas> How do I tell stack to rename my project? I named it identically to the package it's supposed to work with...
11:14:39 <qqwy`> Good day, everyone!
11:14:41 <acyed> Ok, so I've played around with the random with <-. It stays the same inside the do block. Is there a way to get the random number out of the do block? For instance, let x = do { rand <- randomRIO (0,10); return rand } such that x is static?
11:16:26 <qqwy`> acyed: What are you trying to accomplish? IIRC You either need to pass out the new seed value of the random number generator, or instead use one of the functions that generates an infinite list of random numbers within the desired range.
11:16:39 <quchen> acyed: Nope, if you perform an IO action in something, you have done something in IO, thus your end result is in IO. But you can do pure computations inside IO, for example »do { r <- randomIO; print (r * 2) }
11:19:21 <qqwy`> I have a quick question for the professionals: I want a list of all datatypes ever constructed/published on Cabal that implemend `Ord`. Is there a way to look this up?
11:19:46 <quchen> Do you mean Hackage instead of Cabal? I don’t think so.
11:20:31 <qqwy`> Yes, I mean Hackage*
11:20:43 <mniip> I don't think hackage offers such a service so you'll have to do it on your own
11:20:47 <mniip> from source tarballs
11:21:46 <Tuplanolla> That's going to be tricky business, because instances can be written manually, derived, standalone-derived, generated by CPP or generated by TH.
11:23:43 <Tuplanolla> There is also the issue of distinguishing exported and internal instances, which involves settling conflicting orphans.
11:26:10 <qqwy`> Thank you :-)
11:26:34 <qqwy`> I thought I read somewhere that a list of that was kept somewhere, i.e. managed by Hoogle or something
11:26:49 <qqwy`> But indeed, that would miss things that TemplateHaskell and the likes would provide.
11:27:23 <Tuplanolla> Looking at the `base` instances kept in the type class documentation is usually enough.
11:27:39 <qqwy`> Not that it's about that directly; rather I am just trying to find as many things that implement 'Typeclass X' to further my understanding of what kind of structures allow what kind of typeclasses.
11:27:44 <ongy> you could try to search through all the haddock generated documentation, but that's probably not a complete list either (but should catch the TH stuff)
11:28:24 <Tuplanolla> Open up the Haddocks for `Data.Ord` and look at the instance list, qqwy.
11:31:54 <qqwy`> Thank you, Tuplanolla
11:34:42 <qqwy`>  
11:34:42 <qqwy`> Gah, I am trying to convince the author of Elixir to consider adding a comparision typeclass (in Elixir terms: a Protocol) to the language, but I have been unable to convince him so far that every datatype having its own way+API of doing comparisons isn't good enough.
11:35:40 <qqwy`> I'm not sure what other arguments I can bring to the table
11:36:15 <qqwy`> I have the feeling it's my argumentative prowess that are lacking, rather than my reasoning being off
11:36:33 <qqwy`>  
11:36:33 <qqwy`> It feels a little bit like the 'why would you need a Monoid if you can just fold using 0 and (+) to sum?'-type argument
11:40:40 <EvanR> actually i noticed that lenses would be really nice in elixir
11:41:15 <EvanR> lets make a haskell-like syntax sugar which compiles to elixir, which compiles to erlang, ...
11:41:34 <EvanR> throw in a proper type system while were at it
11:42:19 <EvanR> Lazy + Elixir = 
11:42:24 <EvanR> Elazer
11:42:31 <qqwy`> Wonderful naming :-)
11:42:33 <Rembane_> Haxir!
11:42:38 <qqwy`> Yes, lenses would be a wonderful thing
11:43:15 <qqwy`> And a proper type system on top of the BEAM would be absolutely amazing
11:45:37 <qqwy`> Most of the things I'd like to change in Elixir are actually things I know about from Haskell, such as the fact that working with `Enum` in Elixir will always revert your container data type into a list; In Haskell terms: In Elixir, `map` is built on top of `Foldable` and therefore not a true map. 
11:46:30 <EvanR> not sure i understand "in elixir map is build on top of Foldable"
11:46:51 * EvanR checks iex for how this works
11:47:42 <ongy> qqwy`: so it's 'Foldable f => (a -> b) -> f a -> [b]'?
11:48:00 <qqwy`> ongy: Yes, exactly
11:49:15 <EvanR> ah map, not %{}
11:49:28 <qqwy`> Try to run this in IEx: `my_hashmap = %{a: 1, b: 2}; id = fn x -> x end; Enum.map(my_hashmap, id)`
11:49:42 <EvanR> so map doesnt work like Functor
11:49:48 <EvanR> ruby had the same issue and is silly
11:50:16 <qqwy`> Yep. this is something that is based on how Ruby does it
11:50:35 <qqwy`> And indeed, it is silly
11:50:43 <EvanR> you might be able to change that
11:50:55 <EvanR> like get <whoever the heck> to literally change the library
11:51:25 <qqwy`> Well, 'changing' it would mean creating a backwards-incompatible change that will most probably break 98% of the libraries out there, since mapping, sorting, etc. are such common procedures.
11:51:38 <EvanR> theres almost no libraries
11:51:54 <EvanR> the only thing people care about is the web server and test-suite-of-the-week
11:52:18 <EvanR> haskell broke stuff on a regular basis for the better
11:52:24 <qqwy`> But I definitely think we need proper Functor and Traversable implementations.
11:52:30 <EvanR> elixir is a little baby and needs to continue
11:52:39 <EvanR> breaking stuff for the better
11:52:41 <glguy> Sounds like a good topic for a channel about Elixer
11:53:24 * EvanR volunteers qqwy` to do this
11:53:33 <qqwy`> glguy: Sorry for hyjacking this channel a little ^^'
11:54:17 <nullx002> ,hi all
11:54:29 <qqwy`> EvanR: You will find that the maintainers of Elixir are very friendly and open to discussion, but very hard to convince (for better or worse).
11:54:33 <nullx002> i have some problem running ghci on openbsd
11:54:33 <qqwy`> Hello, nullx002
11:55:06 <nullx002> ghc compiles ok qqwy` but ghci errors: ghc: unable to load package `ghc-prim-0.4.0.0'
11:55:07 <maerwald> qqwy`: as they should be (it's a language)
11:55:12 <maerwald> not just a tool
11:55:36 <qqwy`> Yes, I agree, maerwald :-)
11:55:43 <nullx002> ghc-pkg list shows it is there and configed properly
11:56:06 * EvanR needs to go back to forgetting anything but haskell exists
11:56:16 <EvanR> its just too sad
11:56:19 <Gurkenglas> Intero seems to be stuck at "Booting up intero (building dependencies: progress: 0/2)". What do I do? (It was already once done, but this time the project contains dependencies hip and lens)
11:56:35 <nullx002> while ghc compiles ok even on emacs haskell-mode too..
11:58:22 <nullx002> anyone experienced this? is it a problem with bsd? do ghci work on openbsd?
11:58:36 <nullx002> i have heard it is not working on all platforms..
11:59:54 <qqwy`> EvanR: It's not like Haskell does not have any flaws. And it also is not like 'flaws' are inherently a bad thing: Every language takes trade-offs, which means that it becomes better at certain kinds of things.
12:00:14 <Gurkenglas> Apperently stack build is also stuck, and this time it tells me hip's the culprit. What do I do when "hip-1.5.3.0: build" seems not to terminate?
12:00:33 <Gurkenglas> (Also with two dependencies, so I suppose this isn't an intero question anymore)
12:07:37 <hsk3> ~/.ghci is run automatically on GHCi launch. How do I manually run a file from GHCi? I'm looking for something like this:   :run_file ~/boom_file
12:11:34 <ongy> hsk3: if you have a main in there and want it to exit afterwards there's runhaskell
12:11:53 <ongy> if you want to have a ghci session that has the module loaded try ghci ~/boom_file
12:12:34 <simendsjo> `stack exec` takes a long time on my computer. Running the program directly takes 0.005 total time, while using stack exec takes 1.599 seconds. Is there something wrong with my setup?
12:14:01 <dmj`> hsk3: Prelude> :load Main.hs
12:14:16 <dmj`> Ok, modules loaded: Main
12:16:12 <dmj`> simendsjo: ‘stack exec Main.hs -v’ will show you what stack is doing behind the scenes, which probably includes network requests. 
12:20:49 <simendsjo> dmj`: It doesn't time everything. Looks like it does a lot of lookups on ghc and ghc-pkg which sums up to quite a bit. Not sure if I can do anything about it though.
12:29:39 <Sh4rPEYE> If somebody feels like it (maybe wants to relax a bit), he can look on my implementation of simple Morra game I just posted on CodeReview: https://codereview.stackexchange.com/questions/166045/the-morra-game-implementation-in-haskell
12:30:46 <Tuplanolla> I can immediately tell it could be improved, because everything happens inside `IO`, Sh4rPEYE.
12:32:04 <Tuplanolla> Consider what changes you'd make if you had to, say, suspend and resume ongoing games or run multiple games in parallel.
12:35:33 <orion> I want to execute a program and attach to its stdin/stdout. What libraries/modules should I look in to?
12:35:49 <monochrom> Sh4rPEYE, if I could talk you into following my http://www.vex.net/~trebla/haskell/cont.xhtml#yield , there is no need for StateT IO at all.
12:36:35 <monochrom> orion: Look for stuff in System.Process, there's got to one that helps you.
12:37:18 <monochrom> I combine System.Process and async to test my students' programs with timeouts.
12:41:02 <orion> monochrom: Thanks.
12:46:32 <glguy> monochrom: have any of them attempted to catch the timeout exception?
12:47:04 <Tuplanolla> Can't do that from a separate process, glguy.
12:47:33 <glguy> oh I completely misread the message
12:47:45 <monochrom> :)
12:48:16 <geekosaur> they can, in the sense that if the timeout sends a normal process terminate signal that can be caught. of course if it uses SIGKILL or equivalent, glwt
12:48:30 <glguy> they could double fork in their program?
12:49:08 <glguy> create a new process group?
12:49:12 <Tuplanolla> You have pretty high expectations of students.
12:49:17 <geekosaur> heh
12:49:22 <glguy> yeah, I was one
12:49:31 <geekosaur> Tuplanolla, you'd be surprised how clever students can get when circumventing restrictions
12:49:58 <monochrom> On the bright side, their programs are Java programs. That's very limiting on signals, if at all.
12:49:59 <Tuplanolla> I used to do that, but I soon had more interesting things to do.
12:50:13 <monochrom> However, rest assured that I don't even count on that.
12:51:12 <monochrom> I use async's "race" function between the student job and my threadDelay job. When Judgment Day comes, my "race" is not going to care that they intercept SIGTERM.
12:51:48 <ongy> monochrom: how do you restrict them to not fork out?
12:52:28 <monochrom> I do forkIO a thread for "sigterm; wait for it to die" just for the environmentally friendly act of reducing zombies.
12:52:31 <glguy> ongy: by deducting points
12:52:38 <monochrom> :)
12:52:52 <monochrom> I do have a TA quickly glance over their code to see their algorithms.
12:53:12 <ongy> ahh
12:53:16 <monochrom> Really, the timeout is just an anti-infinite-loop heuristic.
12:53:31 <ongy> we have fun with automatically executing students code.
12:53:51 <monochrom> Someone still has to mentally determine "does this look like a linear-time algorithm?" because my test cases are small.
12:54:19 <ongy> just write a function that tests for you!
12:54:48 <ongy> or tell them to supply a machine checkable proof
12:54:49 <monochrom> What you should be asking me is "With whose access privilege do you run their criminal programs! Can they read your solution you store in the same account!"
12:55:21 <ongy> monochrom: we run them as root... :) local namespace root though
12:55:57 <ongy> but we should probably go to one of the other channels if we want to continue this, since it's a bit far from haskell
13:15:25 <hsk3> Is it possible to include another file from ~/.ghci ?
13:15:42 <hsk3> so i can split ~/.ghci into more than one file
13:16:08 <br1> are there magic singleton/proxys defined for symbol lits?
13:16:35 <orion> Is there any easy way to compare two SomeFooTypes for equality if they are GADTs with existentials?
13:17:07 <orion> My naive implementation does not work: (WrapFooType a) == (WrapFooType b) = a == b
13:18:08 <glguy> orion: Do you understand why what you wrote can't work?
13:18:20 <orion> Given that the type information is discarded, I'm thinking that this is impossible, since there's no way to reliably know that they have the same type.
13:18:36 <glguy> Correct
13:18:47 <orion> Darn. :/
13:19:08 <glguy> orion: You could add Typeable into the mix, depending on what you're trying to accomplish
13:21:04 <orion> I have a map: fooMap :: [(String, SomeFooType)] and I want to derive a Show instance for SomeFooType: show = fromMaybe "unknown" . flip lookup (map swap fooMap)
13:21:42 <glguy> that doesn't typecheck
13:21:48 <glguy> err, nevermind
13:22:25 <orion> To accomplish this I need an Eq instance for SomeFooType.
13:23:07 <orion> I'm not certain how I would use Typeable.
13:24:27 <glguy> Add the Typeable constraint in the same way as you added the Eq one
13:25:38 <orion> I never added an Eq constraint.
13:26:09 <glguy> Then how did you figure (WrapFooType a) == (WrapFooType b) = a == b  had any chance at all of working?
13:26:33 <glguy> Not only do you not know if the two types are equal, you don't even know if they can be compared for equality?
13:26:37 <orion> Oh, I tried that, realized it's impossible, then deleted it.
13:28:14 <orion> Ok, done.
13:36:11 <orion> I'm not sure how to proceed. It's not clear to me how I would get a TypeRep, since it operates on Proxies only.
13:38:15 <glguy> Then there are a couple of good exercises here. One is to figure out how to get a TypeRep, the other is to figure out how to use operations from Data.Typeable to compare two values for equality. You don't need any TypeReps to do it
13:38:42 <glguy> Since you have a value with type 'a', you could easily be able to get one of type 'Proxy a'
13:40:20 <Lokathor> EvanR, it's a July 17th miracle! http://lpaste.net/356311
13:40:31 <orion> Well, I know how to get a TypeRep, but it doesn't seem useful since type information is erased.
13:41:20 <glguy> orion: It's useful, but you dont even need a TypeRep in the first place
13:41:31 <orion> tyConName . typeRepTyCon . typeOf $ x == "SomeFooType"
13:41:42 <glguy> No, tyConName isn't part of the solution
13:41:46 <orion> hmm
13:42:43 <glguy> What you're doing isn't a good idea in general, but if you're going to pursue it it's going to be good spending some time figuring out how to implement this eq function
13:43:07 <orion> Would it be better to use Data.Dynamic?
13:43:35 <glguy> no
13:44:22 <orion> I can't completely scrap the GADT/existential in favor of Dynamic?
13:45:01 <palo> How do you avoid shadowing functions, is there some nice standard way like start the function variable with an underscore or something ? 
13:45:27 <palo> I'm talking about a function argument name is a function that I import.
13:45:45 <palo> but the names sometimes are really the best way to describe it.
13:46:19 <geekosaur> leading underscore has other effects (notably, disables "unused" warnings)
13:46:23 <Lokathor> palo, be more verbose in the variable name, generally
13:46:25 <geekosaur> and can trigger typed holes
13:46:44 <Lokathor> new becomes newVals, or whatever
13:47:42 <glguy> orion: Not if you want to compare any two of these things for equality
13:48:25 <palo> Ok thanks for the input, I think I'll go with the verbose way of varialbe naming 
13:49:34 <`Guest00000> are there examples of Control.Category.Category used in nonstandard way, e. g. where arrows are not directly representing computations, e. g. where kind isn't *?
13:50:00 <`Guest00000> also, are invertible functions actually used somewhere?
13:50:17 <hpc>  Category k ((:~:) k)
13:50:22 <hpc> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Type-Equality.html#t::-126-:
13:50:58 <hpc> oh, where the kind isn't *
13:51:11 <hpc> well, i guess that kind-polymorphic instance still counts?
13:51:39 * hpc reflexively read "nonstandard" in the context of Category to mean "doesn't use (->)"
13:54:25 <`Guest00000> well, that too
13:54:38 <`Guest00000> "well, i guess that kind-polymorphic instance still counts?" no, it isn't concrete
13:56:50 <`Guest00000> but, um
13:57:23 <`Guest00000> by "used" i mean methods of the typeclass are used
13:57:54 <`Guest00000> is there real code which calls (.) and id of Category * ((:~:) *)?
14:10:41 <jle`> `Guest00000: well, (.) and id are useful combinators in and of themselves for (:~:)
14:10:57 <jle`> they are used all the time for code dealing with (:~:)
14:11:08 <jle`> they just might not be refered to using their Control.Category instance
14:11:20 <orion> glguy: This is a difficult problem. eqT looks promising.
14:11:26 <jle`> just like how we tend to use 'map' over fmap for lists
14:12:22 <jle`> `Guest00000: for example, you could write 'id' instead of Refl, but people still tend to just use 'Refl'
14:13:47 <jle`> one reason why you don't see to much Control.Category code "in the wild" is because there just isn't that many useful functions you could write polymorphi over all Category instance
14:14:08 <jle`> contrast that to Monad, where you have very very many monad-polymorphic functions that are useful
14:14:39 <jle`> so 'id' and (.) are usually very useful for their instances, but you don't often see people exploring them as the 'canonical way' to access it
14:14:52 <jle`> s/exploring/exporting
14:15:53 <pierrot> Hi. Suppose I have a function f :: Int->Int->Int, and a pair of lists ls1 :: [Int] and ls2 :: [Int]. I want to get the list that results from applying f to each element of ls2 with the n-th element of ls1 as first parameter. How would I do that?
14:16:20 <jle`> what is 'n'
14:16:25 <jle`> is that a parameter?
14:16:45 <pierrot> the element of ls1 at position n
14:16:50 <jle`> then you can just do map (f (ls1 !! n) ls2)
14:16:53 <EvanR> map (f (ls1 !! n)) ls2 
14:17:05 <jle`> yes, but where does '' come from
14:17:11 <jle`> *where does 'n' come from
14:17:15 <jle`> is it something the usuer provides?
14:17:18 <EvanR> i think your parens are wrong
14:17:23 <jle`> ty
14:17:44 <jle`> :t \f xs ys n -> map (f (xs !! n)) ys
14:17:45 <lambdabot> (t -> a -> b) -> [t] -> [a] -> Int -> [b]
14:18:05 <jle`> note here that !! is zero-indexed, so if 0 is given for n, that's the first item in xs
14:18:30 <EvanR> the first one is the "zeroth" element :)
14:18:39 <jle`> ;D
14:18:53 <EvanR> zeroth, 1th, 2th, 3th
14:19:11 <torstein> Is Accelerate lazy? What if I only need one column in the result of a matrix multiplication?
14:19:52 <ongy> 0th, 1nd, 2rd, 3th and so forth?
14:20:12 <EvanR> nice
14:20:13 <jle`> *fourth
14:20:43 <torstein> ongy: That's right, need the k'th column
14:20:48 <jle`> unless you are making a reference to the noble programming language
14:23:32 <Cale> jle`: hahaha
14:24:06 <glguy> orion: just use cast
14:24:50 <pierrot> I don't find a way to explain this in English :/ so I'll try in mathematical language. I have a function f : ZxZ -> Z, and two vectors of integers, ls1 = (a1,...,an) and ls2 = (b1,..., bm). What I want is to construct ls3 = (c1,...,cp) where ci = f(ai,bi), for all i=1,...,p where p = min(n,m)
14:25:14 <EvanR> :t zipWith
14:25:15 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
14:25:41 <EvanR> (Z -> Z -> Z) -> [Z] -> [Z] -> [Z]
14:26:05 <EvanR> > zipWith (*) [1,2,3] [4,5,6,7]
14:26:07 <lambdabot>  [4,10,18]
14:26:17 <pierrot> Cool. Thanks, EvanR :)
14:26:37 <`Guest00000> zipWidth
14:26:53 <`Guest00000> > zipWith undefined [] (error "a")
14:26:55 <lambdabot>  []
14:27:03 <`Guest00000> > zipWith undefined (error "a") []
14:27:05 <lambdabot>  *Exception: a
14:27:49 <EvanR> > zipWith (*) [1,2,3] [4,5,6,undefined]
14:27:51 <lambdabot>  [4,10,18]
14:27:58 <EvanR> > zipWith (*) [1,2,3, undefined] [4,5,6]
14:28:00 <lambdabot>  [4,10,18]
14:28:00 <pierrot> so it's just zipWith f ls1 ls2 ?
14:28:08 <EvanR> yeah
14:28:25 <jle`> pierrot: well,how about showing an example?
14:28:44 <jle`> what if f was (+), ls1 was [1,2,3], and ls2 was [10,20,30] ?
14:29:04 <jle`> what would the answer you want be?
14:29:25 <jle`> if it's [11,22,33], then you probably want zipWith
14:29:34 <pierrot> yeah, it is
14:30:21 <pierrot> I don't show an example because the types are much more complicated that Int
14:30:30 <pierrot> but in essence, the problem is the one I described above
14:30:43 <pierrot> and can be expressed in simple words
14:30:50 <iqubic> Hello, is this the Haskell channel?
14:31:08 <iqubic> Just trying to make sure that my auto join proccess worked.
14:31:20 <jle`> an examplewith simpler types would help clarify any ambiguity with your english description :)
14:31:27 <geekosaur> iqubic, yes this is #haskell
14:31:45 <`Guest00000> > let fib = zipWith (+) (0:1:fib) (1:fib) in fib
14:31:47 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
14:31:48 <jle`> pierrot: and also, witness the magic of parametric parametricity :)
14:32:00 <jle`> pierrot: if we give you a function that works for all types, then it's a function that will work for Z
14:32:10 <`Guest00000> wtf does parametric parametricity mean?
14:32:17 <jle`> one of the neat features of haskell's type system
14:32:25 <Tuplanolla> Parametric polymorphism.
14:32:25 <EvanR> parametric parametricity is parametric
14:32:31 <jle`> haha, thank you
14:32:39 <jle`> yes parametric polymorphism
14:32:44 <Tuplanolla> Your name is better.
14:32:49 * geekosaur admits to wondering about that
14:32:53 <geekosaur> seemed rather meta
14:33:17 <EvanR> or redundant
14:33:25 <jle`> if your function is polymorphic, and behaves as you expect with Int, there's a good chance that it'll behave as you expect with Z
14:34:20 <pierrot> jle`: yeah, that's awesome :)
14:34:25 <Gurkenglas> How do I pass a picture from hip to gloss?
14:34:32 <Athas> torstein: Accelerate is strict.
14:34:47 <Athas> Data-parallelism and laziness mixes poorly.
14:38:15 <torstein> Athas: I figured. Have any idea of to get a column out of a 2-D matrix? Their listed examples in the docs don't work (e.g. slice (use mat) (lift (Z :. 2 :. All)))
14:39:30 <Athas> torstein: sorry, I mostly have a read-only relationship with Accelerate.
14:39:45 <torstein> https://pastebin.com/QYStcTJQ
14:40:48 <jle`> torstein: looking at the error, it's something that typically comes about if your types are ambiguous
14:40:57 <jle`> see line 21
14:41:02 <Athas> Try an explicit type annotation for the result of the slice.
14:41:07 <jle`> try giving your things type annotations
14:41:36 <Athas> Can it deduce a reasonable type for 'mat'?
14:41:46 <Athas> (I.e. what is the output of ':t mat'?)
14:43:47 <torstein> mat   :: (Elt e, Shape ((Z :. head1) :. head), Num head1, Num head,  Num e, Enum e) =>  Array ((Z :. head1) :. head) e
14:44:14 <determinant> I got compilation error in implementing a 2D STArray: https://pastebin.com/5NhvqYd8. Could anybody explain this error?
14:44:28 <torstein> It is possible to annotate mat like this: mat :: Array DIM2 Int, but it gets me no further
14:44:52 <jle`> what is the error after doing that?
14:44:57 <determinant> Why can't ghc match s1 with s..and if it leaks out the thread s, what is the possible scenario?
14:45:33 <geekosaur> forM_ is missing because you need to import Control.Monad
14:45:37 <torstein> After annotating mat: https://pastebin.com/bjPtERYP
14:46:02 <geekosaur> and s *can't* leak; that's the problem. its type is completely unknown outside of its scope so there is no way anything else can match it
14:46:31 <Cale> determinant: Well, first solve the import issue by importing Control.Monad
14:46:33 <determinant> geekosaur: yeah. my bad about forM_ things. I just forgot to copy those lines.
14:46:55 <jle`> determinant: the problem is probably from your type signature on line 9
14:47:05 <jle`> wht happens when you leave it out
14:47:25 <jle`> torstein: it does get you pretty far :)
14:47:27 <jle`> you solved one of the problems
14:47:31 <Cale> You'll need ScopedTypeVariables if you want to give explicit type signatures containing the s type variable like that
14:47:45 <jle`> torstein: now annotate the result of slice
14:48:04 <Cale> and you'll need to explicitly quantify the type variables in your top level signature (i.e. "forall s. ...") for ScopedTypeVariables to work
14:48:08 <geekosaur> waut
14:48:15 <torstein> jle`: I did try: https://pastebin.com/7y5LXjft
14:48:30 <geekosaur> oh, no, I just cant read, those aren't separate equations for the same function...
14:48:34 <determinant> https://pastebin.com/vBUxiEfL
14:49:07 <jle`> determinant: same issue with the type annotation on line 6
14:49:09 <determinant> it looks like line 25 can work. But if I try to nest the STArray, I get the error. (those commented lines)
14:49:16 <Cale> determinant: Also, try lpaste.net -- pastebin's Haskell syntax highlighting sucks...
14:49:59 <buglebudabey> hey i'm trying to run my stack project and when i run the command it says that permission is denied?
14:50:09 <jle`> also what is the error
14:50:40 <jle`> er, that question was directed at determinant , but it could also apply to buglebudabey 's question as well :)
14:50:42 <geekosaur> buglebudabey, how are you running it?
14:51:00 <determinant> jle`: what I don't understand is the listToArray works with arrayToList..but if I try to improve the idea by nesting it I get an error..
14:51:06 <buglebudabey> geekosaur stack run [input file]
14:51:37 <Cale> determinant: Oh, by the way, you know that you can use (Int, Int) as the index type for an STUArray, right?
14:51:42 <ReinH> Er... stack run is not a valid stack command.
14:51:45 <jle`> determinant: what's the new error?
14:51:59 <Cale> but let's figure out what's going on anyway
14:51:59 <jle`> buglebudabey: you might have a stack-run script in your PATH
14:52:16 <buglebudabey> geekosaur i built my project then tried stack exec [executable name] [input file] but it said the executable file didn't exist, shouldnt stack build have taken care of that for me?
14:52:19 <jle`> andd it might not be set to be an executable
14:52:33 <ReinH> buglebudabey: what is this 'input file' argument?
14:52:36 <determinant> updated: http://lpaste.net/2982449754476118016
14:52:49 <ReinH> Either way, stack run is not what you want.
14:52:56 <jle`> buglebudabey: ah, stack exec "blah blah" just runs the command "blah blah" in a shell 
14:53:03 <jle`> barrucadu: it doesn't magically refer to executables
14:53:07 <jle`> * buglebudabey 
14:53:17 <jle`> er, it doesn't magically refer to executables in your project
14:53:27 <Cale> determinant: http://lpaste.net/356315
14:53:29 <Cale> ^^ fixed
14:53:33 <jle`> if you use 'stack build', that just builds your executable, biut it doesn't put it in PATH or anything
14:53:38 <Cale> It was just the in-place type signatures messing things up
14:53:38 <ReinH> well, if you consider modifying the path to be magical
14:53:38 <buglebudabey> ok so if i have a stack project and want to run it and input a file into the program with a command line arg, what should i do
14:53:45 <jle`> you can use 'stack install'
14:53:53 <buglebudabey> jle` where can i find the executable then
14:53:55 <geekosaur> jle1, buglebudabey: but stack exec should find it once built
14:54:04 <ReinH> buglebudabey: what was the stack exec error?
14:54:07 <jle`> oh, does it?
14:54:11 <ReinH> Forget about "stack run".
14:54:12 <geekosaur> (it adds the location of the executable to $PATH)
14:54:19 <jle`> ah i didn't realize that
14:54:22 <Cale> determinant: When you give a type signature like that, all the type variables in it are implicitly forall'ed, at the top of the signature.
14:55:03 <determinant> Cale: I see...Thanks a lot!
14:55:11 <buglebudabey> ReinH  http://lpaste.net/2259786013314383872
14:55:37 <ReinH> buglebudabey: And do you have an executable section in your cabal file called core-compiler?
14:55:37 <determinant> Cale: so the only place that I don't get implicit "forall" is the function signature?
14:55:40 <monochrom> core-compiler is hardcore  <duck>
14:56:11 <Cale> determinant: Well, the only place you don't get implicit forall is when you turn on ScopedTypeVariables, and then explicitly forall that variable at an outer scope
14:56:19 <monochrom> determinant, you get "forall" there too, but that's a place where it is good not bad.
14:56:19 <buglebudabey> ReinH whoops
14:56:21 <jle`> buglebudabey: is your executable called core-compiler?
14:56:41 <buglebudabey> got it guys, thanks XD
14:56:47 <monochrom> The issue is not "forall is bad". The issue is "sometimes I don't mean forall".
14:57:06 <jle`> buglebudabey: but yeah, if you're using a stack-run script, you need to chmod u+x it
14:57:11 <jle`> to let it be an executable
14:57:42 <Cale> determinant: http://lpaste.net/356316
14:57:49 <buglebudabey> ok jle` noted, yeah i was using stack exec at first but when it didn't work i tried stack run because i was just grasping at straws
14:57:50 <monochrom> Although, my first sentence did make the mistake my second sentence talked about.
14:58:07 <jle`> ah yeah
14:58:21 <Cale> determinant: Now when we use the 's' in those type annotations, it'll refer to the same s as the one in the top level signature.
14:58:44 <jle`> stack does that thing that git does, where if you do "stack foo" , it searches for an executable "stack-foo" in PATH
14:58:47 <jle`> and runs that
14:59:38 <Cale> determinant: But yeah, depending on what you're doing, you might find it more convenient just to use STUArray (Int, Int) Bool :)
15:00:49 <determinant> Cale: You are right! I ignored that fact that I could use (Int, Int) as index. :)
15:01:15 <Cale> You should also be aware of
15:01:18 <Cale> newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
15:01:20 <determinant> Cale: I see. So the implicit forall appears too early so I got two different "s" in the end, is that correct?
15:01:26 <Cale> yeah
15:01:49 <determinant> Cale: thanks again!
15:02:06 <Cale> It was saying "hey, this thing needs to be polymorphic because I have this annotation here which says it ought to be, but it's not polymorphic, the s here matches the one from the outer scope"
15:02:33 <determinant> Cale: yeah. I'm new to Haskell, especially those Arrays. I think newListArray basically does what I need.
15:02:46 <determinant> Cale: I see.
15:03:30 <determinant> Cale: maybe the compiler could be more informative on this, such as, provides with types with final "forall"s.
15:03:37 <Cale> and of course, it's hard for the compiler to express that in a way which is easy for a human to understand, because the variables are named the same thing in the code, and the compiler is arbitrarily renaming them to try to keep them separate...
15:03:45 <Cale> yeah
15:04:18 <Cale> Unfortunately, forall isn't even a proper part of the language unless you turn on some extensions, so it will avoid showing you those with the extensions turned off.
15:04:19 <determinant> Cale: that's true..
15:05:51 <EvanR> thats funny thinking of forall as not even really in the language
15:06:22 <monochrom> 1990's thinking.
15:07:12 <hsk3> Is it possible to include another file from ~/.ghci ? (So I can split ~/.ghci into more than one file.)
15:07:12 <bsamorim> Hello, haskell community!
15:07:24 <bsamorim> Is anyone here familiar with parsec?
15:07:31 <monochrom> Plus, if you aim to ban rank-n polymorphism, the easiest way is to syntactically forbid forall.
15:07:58 <hsk3> bsamorim not much, but this talk is great: https://www.youtube.com/watch?v=r_Enynu_TV0
15:08:09 <Cale> bsamorim: I am
15:08:11 <hsk3> really helped me understand parsec (but i forgot most of it now)
15:08:13 <monochrom> Sapir and Whorf would be proud.
15:08:17 <bsamorim> hsk3: thanks, dude!
15:08:24 <Gurkenglas> Does "stack new" enable -Wall? If not, how do I enable it after the fact project-wide?
15:08:26 <bsamorim> I'm viewing it right now
15:08:37 <hsk3> :)
15:08:49 <Cale> btw, I would usually recommend Attoparsec now if you're starting out writing parsers
15:08:50 <bsamorim> Cale: do you think one could go about doing some _heavy_ parsing without knowledge of monads?
15:09:13 <Cale> bsamorim: Yes, in fact, I recommend doing so as part of learning what the monad abstraction is about
15:09:19 <monochrom> https://github.com/JakeWheat/intro_to_parsing is a pretty good parsec tutorial, if you find that video is wrongly paced.
15:09:29 <Cale> bsamorim: Parsers are a *really* good example of a monad, in a way that Maybe is not.
15:09:43 <monochrom> All videos are wrongly paced.
15:09:45 <bsamorim> Cale: Thanks! That encouraged me
15:09:52 <bsamorim> monochrom: hehe ok, thanks a lot!
15:10:00 <tomzz> Hey, you know of a version of (!!) that returns a maybe instead of throwing an error? cant find anything on hoogle and data.maybe data.list docs. Thx : )
15:10:00 <Cale> bsamorim: and you need to understand a bunch of examples of monads before you'll have any chance of really getting what the abstraction is for
15:10:14 <hsk3> The way he uses *> and <* operators from Applicative is really cool IIRC.
15:10:25 <bsamorim> "Up Next: Simon Peyton Jones - Haskell is useless"
15:10:27 <hsk3> I didn't even know Applicative had those operators.
15:10:37 <hsk3> but turns out they're useful in parsing
15:10:42 <EvanR> ive seen every monad example in haskell and i still dont know what monads are really
15:10:53 <buglebudabey> is there any way to see why building the haddock documentation on hackage might have failed? i'm looking at the build reports and can't see anything to do with haddock and my project
15:11:01 <monochrom> "Static" text (and diagrams) has the advantage of letting you dynamically pace yourself.
15:11:05 <bsamorim> Cale: What i've heard through the grapevine is that one couldn't really understand monads without knowing a bit about category theory
15:11:09 <Cale> tomzz: That deserves to exist moreso than (!!) does
15:11:18 <monochrom> "Dynamic" video is statically paced.
15:11:25 <Cale> bsamorim: That's untrue. You can understand how monads work in Haskell without knowing any category theory.
15:12:05 <bsamorim> Cale: Your words fill my haskell-hungry heart with hope! thanks
15:12:45 <monochrom> But you do want to know about Applicative.
15:13:14 <bsamorim> monochrom: Ok, thanks!
15:13:19 <Cale> bsamorim: You might eventually want to pick up a bit of category theory if you're interested in other areas of mathematics, or just as a sort of enrichment. But the generalisation isn't needed most of the time.
15:13:45 <tomzz> Cale: sry my english is bad, does that mean: it should exist but doesnt?
15:13:51 <monochrom> You have about 0.5 probability of finding Applicative easier than Monad, 0.5 the other way round.
15:14:09 <Cale> tomzz: Well, it's not in the base library at least. It might be in some package on Hackage somewhere.
15:14:19 <tomzz> thx ! : )
15:14:39 <bsamorim> Cale: actually, perhaps it would be best if you (or anyone) could kindly tell me if parsec is appropriate for my project:
15:14:49 <bsamorim> (i'll be brief, I swear)
15:14:59 <Cale> tomzz: http://hackage.haskell.org/package/safe-0.3.14/docs/Safe.html -- it's here as "atMay"
15:15:14 <monochrom> Pig Latin.
15:15:34 <torstein> Uhh... Anyone know how to do matrix multiplication with Accelerate?
15:15:42 <EvanR> good way to double the number of haskell function words available
15:16:09 <bsamorim> Basically, "kuniri" (the name of the project) would extract basic information from source code in arbitrary languages (e.g., a list of all the classes, their superclasses, methods, etc)....
15:16:32 <Cale> bsamorim: btw, I would usually recommend Attoparsec to most people these days. Parsec forces you to care about whether parsers might eat one character before failing (at which point backtracking isn't an option). Attoparsec is very similar, but it allows backtracking arbitrarily.
15:16:56 <bsamorim> Ideally, to introduce support to new languages, one would just have to input its bnf grammar
15:17:50 <tomzz> cool, never seen that package before. thank you
15:18:04 <Cale> I don't know whether there are libraries which turn BNF into Parsec or other sorts of combinator parsers.
15:18:51 <bsamorim> Cale: Aww ok, so it wouldn't be a quasi-direct conversion, as it would if I were using, say, yacc?
15:18:54 <Tuplanolla> Your program will end up looking like the grammar.
15:19:23 <Tuplanolla> Only negations are difficult to express for context-free languages.
15:19:30 <EvanR> if you want a parser generator, theres happy
15:19:36 <monochrom> Tuplanolla, I think the goal is to have the grammar in a config file instead.
15:19:38 <Cale> bsamorim: Well, Parsec and these other parser combinator libraries give you parsers that are first class Haskell values, and operations for composing simple parsers together into more complex ones.
15:20:01 <Cale> bsamorim: They don't take input in some funny language like yacc does, they just let you write your parser directly in Haskell.
15:20:31 <EvanR> you can generate a parser from a data structure
15:20:39 <EvanR> you have to write the generator
15:20:44 <Cale> bsamorim: Now, you could parse some sort of BNF, and use that to construct a Parsec Parser
15:20:58 <Cale> But I don't know if anyone's actually done that
15:21:04 <bsamorim> Cale: Yeah, it's really easier if I just shut up and look at the recommended videos/tutorials...thanks a lot for your help!
15:21:14 <bsamorim> EvanR: what do you mean by that?
15:21:31 <Cale> He means the same as what I just said, pretty much
15:21:37 <EvanR> same thing
15:21:45 <Cale> You build up some data structure by parsing BNF
15:21:58 <Cale> then translate that data structure into a parser for the language that the BNF described
15:22:14 <monochrom> Oh! Grammatical Framework. But may be an overkill.
15:22:23 <Cale> Yeah
15:22:40 <Cale> It might be better just to have the users of the project write "configuration" which is in Haskell
15:22:45 <Cale> Similar to what XMonad does :)
15:23:11 <monochrom> Best way to cause people to create new IRC channels
15:23:49 <bsamorim> Cale: yeah, there are some politcs involved in the project, that would sort of make it hard for me to convince everybody to switch the interface to haskell code...... :(
15:24:12 <EvanR> politics oriented programming paradigm!
15:24:28 <bsamorim> EvanR: hahahahaha yeah, sorta like that!
15:24:54 <Tuplanolla> Are we reinventing ANTLR here?
15:25:10 <samtay> Anyone offer a quick lens solution? I'm wondering if there is a lens-idiomatic way to accomplish `[(1,3), (2,1), (4,0)] ^. to (fmap snd)`, which results in [3,1,0]
15:25:39 <EvanR> as flexible as haskell is for programming, its syntax can be rather verbose and untargeted for some "configuration" situations
15:25:40 <Cale> samtay: What's wrong with just writing fmap snd?
15:25:46 <samtay> something involving a traversal with _2  that is equivalent to ` ^. to (fmap snd) `
15:25:54 <samtay> just my own edification is all
15:26:19 <Cale> What type should the thing have?
15:26:34 <bsamorim> Tuplanolla: hahahah perhaps! My brain's parser-package-heap is sort of overflowing
15:26:37 <Cale> You want a Traversal which traverses the second components of a list of pairs?
15:26:45 <samtay> tried a lot of combinations of each, ix, ^.., _2, etc... kinda flailing though.
15:27:04 <EvanR> reverse golfing
15:27:16 <samtay> yea
15:27:29 <samtay> the type looks simple on its own:
15:27:31 <samtay> (^. to (fmap snd)) :: Functor f => f (a, b) -> f b
15:27:34 <Cale> samtay: traverse . traverse ?
15:27:54 <c_wraith> > traverse %~ snd
15:27:56 <lambdabot>  error:
15:27:56 <lambdabot>      • No instance for (Typeable a0)
15:27:56 <lambdabot>          arising from a use of ‘show_M59787296700096716634080’
15:28:08 <Tuplanolla> > toListOf (each . _2) [(1, 3), (2, 1), (4, 0)]
15:28:10 <lambdabot>  [3,1,0]
15:28:18 <samtay> ahhhhhhhh i wasn't composing...
15:28:23 <Cale> > toListOf (traverse . traverse) [(1, 3), (2, 1), (4, 0)]
15:28:24 <c_wraith> > traverse %~ snd $ [(1,'a'),(2,'b')]
15:28:25 <lambdabot>  [3,1,0]
15:28:26 <samtay> i was using (each _2) that doesn't even make sense huh
15:28:27 <lambdabot>  "ab"
15:28:34 <samtay> nice
15:28:56 <Cale> You traverse the list, which gives you the pairs, and then you traverse each pair, which gives you the second part
15:29:04 <Cale> You could also use _2 of course
15:29:38 <Cale> What is each? I haven't used that one
15:29:40 <Cale> :t each
15:29:41 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
15:29:47 <Cale> huh
15:29:48 <Cale> okay
15:30:15 <c_wraith> > (1,2) & each %~ show
15:30:17 <lambdabot>  ("1","2")
15:30:23 <c_wraith> Cale: that's mostly what each is for
15:30:32 <Cale> Yeah, I guess it's just a "traverse whatever the heck"
15:30:40 <dredozubov_> each is like super overloaded traverse
15:31:09 <Cale> I'll stick to using stuff that actually means something :P
15:31:15 <dredozubov_> it can traverse tuple in unexpected ways
15:31:30 <dredozubov_> that's why i usually stick to traverse
15:35:15 <jle`> each is pretty much MonoTraversable
15:36:10 <jle`> oh i suppose it is even more polymorphic
15:36:18 <tomzz> can you use traverse on tuples?
15:36:23 <jle`> you can
15:36:31 <Cale> tomzz: yeah, it traverses the last component
15:36:32 <EvanR> > ('a',1) & each %~ show
15:36:34 <lambdabot>  error:
15:36:34 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
15:36:34 <lambdabot>      • In the expression: 1
15:36:37 <jle`> > traverse Just (1, '3')
15:36:39 <lambdabot>  Just (1,'3')
15:36:52 <c_wraith> > traverse (Just . (+1)) (1, 2)
15:36:53 <lambdabot>  Just (1,3)
15:37:05 <jle`> ok yes my example might have been a bit misleading
15:37:17 <jle`> > traverse (\x -> [x-1,x,x+1]) ('a', 4)
15:37:19 <lambdabot>  [('a',3),('a',4),('a',5)]
15:37:37 <tomzz> ah ok, but doesnt work on ntuple?
15:37:40 <tomzz> like each does
15:37:47 <jle`> well
15:37:49 <Cale> It should work on larger tuples as well
15:37:49 <jle`> it's different than each
15:37:50 <c_wraith> No, it actually has a type that means something. :)
15:37:57 <jle`> it could work in ntuples, but the instances aren't in base for some reason
15:38:08 <Cale> It would just traverse the last component of the tuple.
15:38:25 <jle`> yes, if it did, it would work on arbitrary n-tuples where it traverses the last item in the tuple
15:38:40 <jle`> each is the same, for what it's worth --- each tuple has its own ad-hoc instance
15:38:42 <Cale> You should generally think of pairs as being like labelled containers for a single element. The first component is the label, and the second component is the thing actually contained.
15:38:43 <tomzz> is the reason that this isnt in stdlib that its a bit awkward to explain typewise?
15:38:58 <jle`> i think it's just not used often enough for people to care
15:39:04 <tomzz> k
15:39:15 <c_wraith> tomzz: nah, the types are easy.  easier than explaining the Monad instance for ((->) r), for instance. :)
15:39:15 <jle`> and there are things in base that are much much more awkward to explain ttypwise, heh
15:39:15 <Cale> Yeah, nobody uses triples or larger tuples very much anyway
15:39:32 <jle`> traversing (x,y,z) is really the same as traversing ((x,y) z)
15:39:38 <jle`> the instance would behave the same way
15:39:51 <jle`> working with big uples in haskell anyways is ad-hoc
15:40:05 <jle`> 'each' works by giving each tuple type its own individual traversal
15:40:05 <samtay> the syntax is really convenient when I'm representing "coordinates" like (x,y) though.. so I end up in these situations when really a Functor instance doesn't make quite as much sense (that is, no reason the y should be special compared to x)
15:40:10 <Cale> Usually if you would have a triple or more, you really just ought to be defining a new data type.
15:40:26 <samtay> so I should really use a custom DT but tuples are convenient. shrug
15:40:41 <c_wraith> samtay: or use the linear package, which happens to have nice lenses too. :)
15:40:56 <Cale> samtay: It's not convenient at the type level though
15:41:12 <Cale> samtay: At least, I find something about writing (Double, Double) a bit annoying
15:41:12 <samtay> no its not, i agree. i'm doing bad things over here
15:41:24 <Cale> and (Double, Double, Double) is right out :)
15:41:25 <jle`> just use Join (,) Double
15:41:34 <jle`>  </s>
15:41:47 <jle`> but yeah, V2 is a nice type
15:41:59 <c_wraith> If I remember history correctly, at least some of lens was written in order to make linear work better
15:42:10 <iqubic> :t join (,)
15:42:11 <lambdabot> b -> (b, b)
15:42:16 <samtay> i'll check it out, almost done with this little pet project though so might more effort to swap then i'd like
15:42:19 <iqubic> How the heck does that work?
15:42:24 <iqubic> :t delta
15:42:25 <EvanR> Double^2 type syntax
15:42:25 <lambdabot> error: Variable not in scope: delta
15:42:30 <jle`> iqubic: just plug in the types
15:42:33 <c_wraith> iqubic: first, figure out what instance of Monad join is using.
15:42:33 <iqubic> I will.
15:42:40 <iqubic> :t join
15:42:41 <lambdabot> Monad m => m (m a) -> m a
15:42:53 <EvanR> a^n vector of n a's
15:43:01 <iqubic> It's using monad of (,) right?
15:43:05 <jle`> not quite
15:43:09 <jle`> the first argument is (,)
15:43:13 <c_wraith> :t (,)
15:43:15 <lambdabot> a -> b -> (a, b)
15:43:27 <c_wraith> what's the top-level type constructor in that?
15:43:37 <samtay> oh damn linear looks sweet. and i did all those rotation functions myself haha
15:43:45 <iqubic> Is it using the monad ((->) r)?
15:44:02 <mniip> what makes you think so?
15:44:04 <c_wraith> iqubic: is it?  (yes, it is, but figure out why)
15:44:47 <iqubic> Because (,) is not a concrete type, but "a -> b -> (a,b)" is a concrete type.
15:45:09 <iqubic> :k (,)
15:45:10 <lambdabot> * -> * -> *
15:45:12 <jle`> "concrete type" doesn't really mean anything
15:45:20 <jle`> but also only * -> *'s can be monads
15:45:23 <iqubic> :K a -> b -> (a, b)
15:45:28 <iqubic> :k a -> b -> (a, b)
15:45:29 <lambdabot> error: Not in scope: type variable ‘a’
15:45:29 <lambdabot> error: Not in scope: type variable ‘b’
15:45:29 <lambdabot> error: Not in scope: type variable ‘a’
15:45:35 <jle`> and you aren't using  (,) as a type here, you're using it as a function :O
15:45:35 <c_wraith> iqubic: it's really just about syntax.  Match types together.
15:45:47 <jle`> it might be easier to rewrite a -> b -> (a, b) as:
15:46:03 <iqubic> (a -> b) -> (a, b)
15:46:21 <iqubic> or not that. but a -> (a -> (a, b))
15:46:26 <jle`> ((->) a) (((->) b) (a, b)
15:46:30 <jle`> )
15:46:56 <alhariel> 'might be easier'
15:47:03 <dredozubov_> jle`: i like this, it's like a one-liner explanaition
15:47:46 <dredozubov_> :t join
15:47:47 <lambdabot> Monad m => m (m a) -> m a
15:47:49 <jle`> ((->) a) ( ((->) b) (a, b) )   -- then there's reallonly one way to match that up with m (m c)
15:48:04 <jle`>    m   ( m  (a, b) )
15:48:07 <dredozubov_> there's one m in `m (m a)`
15:48:20 <dredozubov_> the inner one and the outer one must be the same
15:48:39 <dredozubov_> so the ((->) a) is the only answer for a type inference
15:49:04 <dredozubov_> and it follows exactly from the type of (,)
15:49:23 <iqubic> jle`: That looks like lisp when you write it that way
15:49:37 <jle`> lisp is a little more conenient
15:49:47 <jle`> it doesn'tforce you to surround opertors in parentheses when you use them prefix
15:49:53 <jle`> operators are prefix by default
15:50:04 <iqubic> So the arrow is a function?
15:50:14 <iqubic> :t (->)
15:50:15 <lambdabot> error: parse error on input ‘->’
15:50:17 <c_wraith> It's a type
15:50:23 <iqubic> :k (->)
15:50:25 <lambdabot> * -> * -> *
15:50:36 <iqubic> :k (->) a
15:50:38 <lambdabot> error: Not in scope: type variable ‘a’
15:50:45 <jle`> iqubic: a -> b is just syntactic sugar for (->) a b
15:50:47 <iqubic> :k (->) Int 
15:50:48 <lambdabot> * -> *
15:50:52 <jle`> just like 1 + 2 is syntactic sugar for (+) 1 2
15:50:53 <iqubic> I see. 
15:50:58 <iqubic> Yeah, I get it.
15:51:03 <dredozubov_> a -> b => (->) a b 
15:51:23 <dredozubov_> (a ->) is not valid haskell, so it should be expressed as ((->) a)
15:55:09 <iqubic> I get it.
15:55:16 <iqubic> That makes a lot of sense.
15:55:44 <iqubic> But why does (m (m a)) force the a and the b to be the same in join (,)
15:55:44 <c_wraith> So then look at the type of join
15:55:47 <c_wraith> :t join
15:55:48 <lambdabot> Monad m => m (m a) -> m a
15:55:54 <iqubic> :t join (,)
15:55:56 <lambdabot> b -> (b, b)
15:56:07 <c_wraith> The important part here is join's type now
15:56:50 <iqubic> It takes monad wrapped in a the same monad, and unwraps the outer monad
15:56:59 <iqubic> join x = x >>= id
15:57:07 <c_wraith> what is m, in this case?
15:57:22 <iqubic> m is ((->) a)
15:57:38 <iqubic> Oh, so of course a must be the same as b
15:57:38 <c_wraith> Notice how that `a' is part of `m'?
15:57:43 <c_wraith> Yes, exactly
15:58:04 <iqubic> It has to be, because join needs the same type ((->) a) in both m's
15:58:12 <iqubic> I see.
15:58:21 <iqubic> You could also write: 
15:58:29 <iqubic> delta a = (a, a)
15:58:46 <iqubic> :t let delta a = (a, a) in delta
15:58:47 <lambdabot> t -> (t, t)
15:58:54 <iqubic> :t join (,)
15:58:55 <lambdabot> b -> (b, b)
15:59:08 <iqubic> It's the same type.
15:59:24 <c_wraith> for what it's worth, I'd write it that way these days.  It's not as clever, but it's a lot simpler. :)
15:59:29 <iqubic> And the delta version is a lot easier to understand in my opinion.
15:59:42 <iqubic> c_wraith: You write the delta function over join (,)
15:59:47 <c_wraith> yes
16:01:19 <c_wraith> unless someone is asking me for an unreadable one-liner and that's a small portion of it. :)
16:09:46 <jle`> i too prefer (\x -> (x, x)) over join (,)
16:10:44 <jle`> @let data Join f a = Join { getJoin :: f a a } deriving (Show, Functor)
16:10:46 <lambdabot>  .L.hs:165:31: error:
16:10:46 <lambdabot>      • Can't make a derived instance of ‘Functor (Join f)’:
16:10:46 <lambdabot>          Constructor ‘Join’ must use the type variable only as the last argum...
16:10:59 <osa1> anyone know why Async isn't an instance of Alternative?
16:11:01 <jle`> aw
16:11:39 <jle`> @let data Join f a = Join { getJoin :: f a a } deriving Show; instance Bifunctor f => Functor (Join f) where fmap f = Join . bimap f f . getJoin
16:11:40 <lambdabot>  .L.hs:165:24: error:
16:11:41 <lambdabot>      • No instance for (Show (f a a))
16:11:41 <lambdabot>          arising from the first field of ‘Join’ (type ‘f a a’)
16:12:22 <jle`> huh
16:12:32 <jle`> @let data Join f a = Join { getJoin :: f a a } deriving Show
16:12:33 <lambdabot>  .L.hs:165:24: error:
16:12:34 <lambdabot>      • No instance for (Show (f a a))
16:12:34 <lambdabot>          arising from the first field of ‘Join’ (type ‘f a a’)
16:12:40 <jle`> i guss deriving isn't smart enough for that?
16:13:10 <jle`> @let data Join f a = Join { getJoin :: f a a}; deriving instance Show (f a a) => Show (Join f a)
16:13:11 <lambdabot>  Defined.
16:13:22 <Tuplanolla> Usually `newtype`, jle`.
16:13:45 <jle`> hm, would it be able to derive Show for that?
16:13:56 <Tuplanolla> With `GeneralizedNewtypeDeriving`? Maybe.
16:14:03 <jle`> that would be the wrong instance
16:14:10 <felixphew> does anyone know how to get the ID of a newly added row in HDBC?
16:14:35 <jle`> @let instance Bifunctor f => Functor (Join f) where fmap f = Join . bimap f f . getJoin
16:14:36 <lambdabot>  Defined.
16:14:51 <jle`> > (*2) <$> Join (3,5)
16:14:52 <lambdabot>  Join {getJoin = (6,10)}
16:15:35 <Tuplanolla> The definition is even nicer as `fmap f = Join . join bimap f . getJoin`.
16:15:45 <jle`> cute :)
16:32:28 <iqubic> That looks great.
16:33:31 <iqubic> I love that.
16:52:59 <n_blownapart> hello how do we separate print arguments in main, i.e.   ' main = print $ func1 x y  __  func2 a b 
16:53:47 <n_blownapart> or is that a indentation issue?
16:55:03 <geekosaur> parentheses?
16:55:11 <geekosaur> (func1 x y)
16:55:46 <erisco> :t print
16:55:48 <lambdabot> Show a => a -> IO ()
16:55:52 <erisco> it only takes one
16:57:07 <n_blownapart> erisco it only takes one ? thanks, I could have sworn I used a symbol to separate various print args like $ or ; or something
16:57:28 <n_blownapart> :t print
16:57:29 <lambdabot> Show a => a -> IO ()
16:58:18 <erisco> main = do print x; print y   perhaps?
17:03:47 <n_blownapart> do takes a semiColon, thats it...thanks erisco
17:04:30 <n_blownapart> erisco the $ symbol does what there? I can't get a straight answer online
17:05:14 <geekosaur> function application with very low precedence, so it acts like parentheses around the things on both sides
17:05:15 <monochrom> It is function application. f$x = f x.
17:05:20 <geekosaur> (print) (func1 x y)
17:06:22 <monochrom> print cannot take multiple arguments. No amount of $ can bribe it to.
17:07:55 <monochrom> But if you see "print $ a $ b $ c" it is still not multiple arguments, it is one single argument: print (a (b c))
17:10:12 <n_blownapart> monochrom, geekosaur so you can use multiple $'s
17:10:29 <boj> one could do "print (a, b, c)" i suppose
17:10:34 <monochrom> I don't know what that means, apart from random musing.
17:10:55 <monochrom> Yes, I can use multiple $'s. I can also write infinite loops too. But why.
17:11:34 <geekosaur> n_blownapart, you can't usefully use them to make a "print" function that takes one parameter magically take several
17:13:29 <monochrom> print $ (,,) $ a $ b $ c
17:13:36 <n_blownapart> so if you have two separate functions written for , say, learning purposes, how would you print both doing a single build?
17:13:55 <monochrom> Firstly I wouldn't even call them functions.
17:14:12 <monochrom> Secondly "print 1 >> print 2" exists.
17:14:54 <boj> may be helpful to explain what you'd call them instead, and what ">>" is
17:15:03 <monochrom> values.
17:16:07 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml explains >>
17:18:10 <n_blownapart> monochrom, thanks, this is all I'm trying to do. I assume the parentheses are not needed
17:18:15 <n_blownapart> https://nopaste.me/view/affdd5b8
17:19:18 <n_blownapart> please edit that into more standard approach
17:20:07 <n_blownapart> it won't compile as is
17:20:33 <lamefun> Why is there no wx in LTS Haskell?
17:20:52 <monochrom> How do I edit it?
17:21:11 <monochrom> I have adblock. Does that matter?
17:21:54 <boj> n_blownapart: http://lpaste.net/356318
17:22:19 <boj> n_blownapart: you can put things on separate lines in a do block
17:23:14 <boj> n_blownapart: ignore the $ operator for the time being, it tends to be confusing at first
17:25:08 <n_blownapart> boj - thanks, yes I'll run with that. monochrom yeah thanks sometimes lpaste won't load so I use that pastebin that doesn't have an edit mode thanks ALL
17:25:27 <boj> n_blownapart: good luck :)
17:25:31 <n_blownapart> pax
17:26:24 <n_blownapart> refheap was a cool pastebin but it went flop
17:28:47 <monochrom> The recent cool pastebin I ran into recently is ptpb.pw. It's cooler than lpaste because it hands you a UUID privately that you can use to mutate or delete. It also has a web api so you can use curl on the command line.
17:36:47 <begriffs> I asked this a while ago but forgot the answer. Why do hackage packages often use versions with four numbers, like A.B.C.D? Using three - major, minor, patch - seems more in line with semantic versioning.
17:37:27 <geekosaur> major is two components, like with ghc itself (and linux kernel, etc.)
17:37:48 <geekosaur> or rather, it can be
17:37:59 <geekosaur> not everyone does it that way but it's supported
17:38:00 <begriffs> Is one of the two major version numbers more of a vanity version, and the other reflects breaking changes?
17:38:16 <n_blownapart> monochrom, thanks for the tip
17:40:52 <begriffs> I'm thinking of getting rid of the leading zero for the next version of my own package, going from 0.4.2.0 to 4.3.0 when new features are added. Anything to watch out for in this jump? I'm guessing cabal etc will be OK, just seeing it as an increased version.
17:42:32 <geekosaur> there's also some weirdness like the HTTP package using 4000.maj.min.pat because early versions before there was a versioning policy were by date (yyyy.mm.dd)
17:43:41 <boj> begriffs: technically the first number separate the difference between different packages. like sdl vs. sdl2, gpg vs gpg2
17:44:32 <geekosaur> not always. like, linux uses this versioning and 3.0 was just because Linus decided there had been enough 2.x releases
17:44:53 <geekosaur> 4.0 may have used the same logic
17:45:10 <n_blownapart> monochrom, I just tried ptpb.pw 's curl tool . that is so convenient. thanks !
17:45:31 <begriffs> boj: oh, so a change in that first big number should actually mean a change of package entirely. I'm guessing this is how configurator-ng vs configurator should have been.
17:46:28 <geekosaur> ghc8 revved the first number because of all the work that went in to support the first stage of dependent haskell (specifically type and kind unification)
17:46:45 <geekosaur> so for ghc it's sort of a 'super-major'
17:48:46 <begriffs> Hm, but theoretically a bump of a major (not super-major) could still indicate big changes. But I can see that the super major is a signal of fundamental changes, not just any breaking change.
17:48:57 <boj> begriffs: https://pvp.haskell.org/faq/
17:49:30 <boj> i think the community is 50/50 on pvp vs semver, so it really doesn't matter
17:51:42 <begriffs> boj: great link, thanks.
18:21:18 <eacameron> I have this and GHC is not happy: func :: (DefaultOrdered r) => IO r -> ... -> IO ()
18:21:29 <eacameron> func has a where clause
18:21:42 <eacameron> where header = headerOrder (undefined :: r)
18:22:24 <eacameron> "headerOrder" is the method of DefaultOrdered in the sig and it takes some unevaluated argument of that type (probably should use Proxy, but it doesn't).
18:22:37 <eacameron> Any how, even with ScopedTypeVariables, GHC tells me that it can't figure this out
18:22:52 <eacameron> It basically thinks that the undefined is of some other type, a0, that is not ~ r
18:22:55 <geekosaur> you need more than ScopedTypeVariables
18:23:20 <geekosaur> you must also 'declare' r as being scoped. func :: forall r. (DefaultOrdered r) => IO r -> ... -> IO ()
18:23:32 <eacameron> geekosaur: You don't say!
18:24:23 <eacameron> geekosaur: Is that strictly true of all uses of ScopedTypeVariables, when you want to refer to a type deeper in the definition?
18:24:30 <eacameron> I'm baffled I've never hit this before
18:24:40 <geekosaur> yes
18:26:07 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#declaration-type-signatures "A declaration type signature that has explicit quantification (using forall) brings into scope the explicitly-quantified type variables, in the definition of the named function."
18:27:21 <jchia_1> eacameron: If you use "func (x1 :: IO r) ... = ...", it will also bring type variable r into scope, avoiding the need for explicit quantification. Maybe that's how you avoided using explicit quantification before?
18:27:40 <eacameron> jchia_1: Aha! Yes that's precisely it!
18:30:04 <eacameron> geekosaur: jchia_1: I am very glad I didn't just give up and find another route. It works now the way I wanted. Thank you!
18:30:16 <EvanR> the forall thing and scoped type vars, number N thing on the list of things i wish i knew while learning haskell
18:30:39 <boj> this conversation just taught me >.<
18:30:54 <EvanR> ^
18:32:39 <eacameron> EvanR: You know, this could be an improvement to GHC error messages possibly. If it notices you are declaring something with the same type variable as a parent signature, but it isn't the same, it could tell you what to try
18:33:28 <geekosaur> it would be interesting to see how often that fires inappropriately... because that would be evidence toward maybe getting scoped type variables to be the default
18:33:31 <EvanR> right... it seems unlikely you were trying to use the same type variable in a variety of ways
18:34:22 <geekosaur> (The whole reason for this extension+forall (or pattern-signatures which is *another* extension hidden inside STV) is because they were afraid of breaking H'98 programs that reused the type variable)
18:35:23 <EvanR> when i first tried to use 'a' in annotations and it didnt work, i found it highly unintuitive
18:35:28 <jchia_1> eacameron: I learned early on by trial and error that using "func (x :: IO r) .. =" would bring r into scope, and I just do that whenever I wanted to refer to a type variable in the function body. Later, for whatever reason, I read the docs and learned that I could also use explicit quantification.
18:36:17 <EvanR> i didnt even know about func (x :: IO r)
18:37:12 <eacameron> jchia_1: I think I have the same story, except that I always used it in some lambda where the type of the whole function was not written out. In this case, it was a top-level function and I wouldn't dream of annotating the arguments that way.
18:37:59 <geekosaur> back in ghc 6.4 that was its own extension (PatternSignatures)
18:38:37 <geekosaur> ...but it wasn't considered very useful without ScopedTypeVariables so it got folded in
18:42:44 <whitaker> :q
18:56:41 <eacameron> geekosaur: EvanR: jchia_1: FTR: https://github.com/bollu/hask-error-messages-catalog/pull/3
19:22:03 <julianleviston> Given the definition of Pretext at https://hackage.haskell.org/package/lens-4.15.2/docs/src/Control.Lens.Internal.Context.html#Pretext how would I go about constructing a Pretext that focusses on the whole of a structure?
19:31:32 <lambdamu_> cabal is nuts, it compiles everything, everytime
19:39:32 <julianleviston> I can pretty easily create a context. I’ll see if that will match. I’m assuming it won’t… I wonder how I could convert a Context into a Pretext
19:40:54 <julianleviston> nah.
19:42:37 <Gurkenglas> :t \l s -> Pretext $ \atofb -> l atofb s -- I don't get why this doesn't work, or why f is claimed to escape its scope here
19:42:39 <lambdabot> error:
19:42:39 <lambdabot>     • Couldn't match expected type ‘p a (f b) -> t1 -> f t’
19:42:39 <lambdabot>                   with actual type ‘t2’
19:43:29 <Gurkenglas> :t (.) Pretext . flip -- Or why this gives a different error, when it's just pl'd
19:43:30 <julianleviston> is it because f has kind * -> * ? (no idea)
19:43:30 <lambdabot> error:
19:43:30 <lambdabot>     • Couldn't match type ‘a2 -> c’
19:43:30 <lambdabot>                      with ‘forall (f :: * -> *). Functor f => p a (f b) -> f t’
19:43:54 <julianleviston> I should probably look up Profunctor, I guess
19:45:00 <julianleviston> Pretext is a generalised Context  blah blah arbitrary Conjoined Profunctor. I think I understood Profunctor at least a bit a while ago, but no idea what a conjoined one is :)
19:46:04 <julianleviston> I can get a Context just fine that does what I want if I do this: Context id value (where value is the thing I want the context to focus on the whole of), but that doesn’t help because I’m trying to plug it into a place that needs a Pretext.
19:47:31 <julianleviston> I thought maybe I could use sell, but I don’t really understand that function
19:59:50 <julianleviston> Gurkenglas: is it because it’s using a rank 2 type?
20:00:01 <julianleviston> newtype Pretext p a b t = Pretext { runPretext :: forall f. Functor f => p a (f b) -> f t }
20:00:42 <Gurkenglas> Well, yes, escaping a scope is only possible when there's a forall involved, but that doesn't explain to me how that's happening here
20:01:09 <julianleviston> weirdly when I ask GHCI what the type is… it’s this: Control.Lens.Internal.Context.Pretext  :: (forall (f :: * -> *). Functor f => p a (f b) -> f t) -> Control.Le\ns.Internal.Context.Pretext p a b t
20:01:25 <julianleviston> ah ok
20:02:03 <julianleviston> are all functors not of kind * -> * ?
20:12:08 <julianleviston> I’m going to read this https://www.schoolofhaskell.com/user/tel/pretext-by-experiments-and-guesses
20:25:28 <glguy> julianleviston: Conjoined is basically everything that Indexed i and (->) have in common. it basically means "function"
20:30:16 <eacameron> Whatever became of that proposal (or pre-proposal) to add scoped imports to GHC?
20:31:09 <julianleviston> glguy: oh cool
20:31:24 <julianleviston> I’m finding this kind of opaque
20:36:03 <iqubic> Hello wonderful people of the Haskell realm
20:36:20 <julianleviston> So it feels like I should be able to use experiment to build a Pretext from my value
20:38:49 <dmj`> iqubic: o/ :)
20:38:56 <julianleviston> whoa Control.Lens.Internal.Context.Pretext ($ val) 
20:39:06 <julianleviston> that’s what I wanted… but I have no idea why it works. lol
20:39:20 <julianleviston> all good… back to the EK readings :)
20:39:57 <Gurkenglas> julianleviston, if that's all you coulda just used sell
20:40:08 <julianleviston> that’s what I thought, but sell doesn’t work
20:40:14 <Gurkenglas> :t [\val -> Pretext ($ val), sell]
20:40:15 <lambdabot> [t -> Pretext (->) t b b]
20:40:51 <julianleviston> I still have to check this works ok… whoa I don’t understand that at all
20:41:44 <julianleviston> :t sell
20:41:45 <lambdabot> Sellable p w => p a (w a b b)
20:42:21 <julianleviston> When I use it in my program ghci complains when reloading the file 
20:42:33 <geekosaur> ...sell da wabbit?
20:42:41 <pikajude> Killable p w?
20:42:43 <geekosaur> (it's getting late here...)
20:47:08 <iqubic> What does the ($ val) do?
20:47:59 <monochrom> Recall "section syntax", for example (* 4).
20:48:56 <iqubic> :t ($ Maybe 3)
20:48:57 <lambdabot> error:
20:48:58 <lambdabot>     • Data constructor not in scope: Maybe :: Integer -> a
20:48:58 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
20:49:03 <iqubic> :t ($ Just 3)
20:49:05 <lambdabot> Num a => (Maybe a -> b) -> b
20:49:22 <iqubic> :t \a -> ($ a)
20:49:24 <lambdabot> a -> (a -> b) -> b
20:49:44 <iqubic> I don't understand that. It takes a function, and applies it?
20:49:52 <geekosaur> yes
20:49:53 <julianleviston> yep
20:49:54 <monochrom> Try it!
20:50:05 <iqubic> Why is that ever helpful?
20:50:17 <monochrom> You saw one usage, I thought.
20:50:18 <julianleviston> if you need a value-applying function
20:50:33 <iqubic> Like what?
20:52:17 <pikajude> if there's a situation where you need to pass a function that gets applied to a value to something
20:52:20 <pikajude> that's when you use it
20:52:40 <julianleviston> > map ($ 2095) [id, (+20), (+40)]
20:52:42 <lambdabot>  [2095,2115,2135]
20:52:44 <pikajude> :t \x -> fmap ($ x)
20:52:46 <lambdabot> Functor f => a -> f (a -> b) -> f b
20:52:54 <pikajude> look, it's sort of like <*>
20:52:56 <pikajude> but not really
20:53:52 <monochrom> It is like (<*> pure 4) :)
20:54:17 <pikajude> right, but only if x is 4
20:55:08 <julianleviston> iqubic You know map - it lets you do apply a single function to many different values. This lets you apply many different functions to one single value. There’s lots of uses of it. Once I built a thing that would arbitrarily operate on data depending on what was given to it… you could pass in chains of “processing” functions to it, and it’d fold the original value down to a single value that’d been processe
20:55:08 <julianleviston> Needed to use ($ val) for this.
20:56:19 <julianleviston> iqubic: granted it’s not as useful as map/fmap, tho :)
20:56:26 <julianleviston> (not as commonly-used, I should say)
20:56:35 <zqvt8> hi, is it possible to have a function that I can pass either pass individual arguments or a list?
20:56:51 <pikajude> if you write two different functions
20:56:53 <pikajude> yes
20:56:54 <julianleviston> zqvt8: not really
20:57:18 <zqvt8> oh okay. I had hoped I could do a function like 'foo a b c' that I can also pass a three parameter list instead
20:57:22 <ertes> zqvt8: if the number of arguments is not specified, write a list function
20:57:24 <pikajude> nop
20:57:31 <pikajude> we don't have a splat operator here
20:57:37 <pikajude> you could fake one with template haskell though :')
20:58:15 <ertes> zqvt8: that doesn't really make sense in haskell, unless you use some really fancy type system features, and i strongly recommend not doing that
20:58:28 <julianleviston> zqvt8: you could move the “parametricity” into a type, though… 
20:58:40 <pikajude> technically printf kind of does this. but printf sucks
20:58:45 <zqvt8> I'm relatively new, that sounds scary :o while on the topic, if I use a short list, what is the most idiomatic / best way to use the arguments, just the '!!' operator?
20:58:50 <ertes> zqvt8: but also by more primitive logical reasoning: if your function takes a variable number of arguments, it really takes a single list
20:58:53 <pikajude> pattern match
20:59:06 <pikajude> why do you have a list that you're trying to get specific items out of
20:59:07 <julianleviston> zqvt8: what are you trying to do?
20:59:33 <julianleviston> pikajude: (probably becuase we just told him to use a list for variable arguments lol)
20:59:47 <pikajude> we said no such thing
20:59:51 <ertes> i did =)
20:59:53 <julianleviston> pikajude: we kinda did.
20:59:56 <pikajude> ertes did
21:00:00 <pikajude> i'm not associating myself with ertes
21:00:09 <pikajude> your mileage may vary
21:00:25 <julianleviston> pikajude: collectively, we’re the help interface, so we’re all in this together :)
21:00:44 <julianleviston> pikajude: associated or not :)
21:01:47 <zqvt8> julianleviston: reading some values line by line from a textfile (so I have them as a list) and then call a function on those values
21:01:51 <julianleviston> zqvt8: your function might take 3 arguments, and you might want to make some of them optional. In this case, use the optional data type: Maybe.
21:02:09 <pikajude> oh so
21:02:11 <julianleviston> zqvt8:  oh… that sounds reasonable… just pass them in as a list.
21:02:14 <pikajude> you're using getLines or something
21:02:21 <pikajude> what are you doing with them
21:02:27 <ertes> zqvt8: what's the usage pattern on the individual lines?  do individual lines have different purposes?
21:02:40 <julianleviston> ertes: good question!
21:02:45 <iqubic> :t traverse
21:02:47 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:02:48 <pikajude> good job ertes 
21:02:56 <zqvt8> putting them into a polynomial function as the parameters
21:02:58 <iqubic> How the heck does that work?
21:03:03 <iqubic> :t foldr
21:03:05 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:03:23 <zqvt8> fold only works if I do the same thing on every value right? That's no good for a mathematical function
21:03:27 <julianleviston> iqubic: it’s easier if we specialise the Traversable part to list
21:03:32 <pikajude> it's a list of numbers?
21:03:35 <zqvt8> yes
21:03:41 <ertes> zqvt8: that pattern makes them pretty much equal-purpose…  you should take a list and transform it
21:03:47 <iqubic> julianleviston: Yeah. I want to know how traverse works.
21:03:56 <julianleviston> iqubic: do you know how recursion works?
21:03:58 <pikajude> case mapMaybe readMay myLines of [num1,num2,num3] -> ...; _ -> error "wrong number of args"
21:03:59 <ertes> zqvt8: you will find 'zipWith' and 'sum' useful
21:04:07 <pikajude> or that
21:04:12 <julianleviston> iqubic:  and polymorphic types?
21:04:24 <iqubic> julianleviston: I do indeed undersandt recursion and polymorphic types
21:04:48 <julianleviston> iqubic:  sweet! and Typeclasses and Functor and Applicative?
21:04:54 <iqubic> Yes.
21:04:58 <julianleviston> okey dokey
21:05:02 <iqubic> I know what all of those are.
21:05:12 <pikajude> > traverse id [Just 1, Just 2, Just 3]
21:05:15 <lambdabot>  Just [1,2,3]
21:05:22 <pikajude> i think traverse id === sequence
21:05:31 <iqubic> :t sequence
21:05:33 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
21:05:40 <pikajude> well, sequenceA
21:05:42 <pikajude> :t sequenceA
21:05:44 <pikajude> same thing
21:05:44 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:06:05 <iqubic> traverse id == sequence
21:06:26 <iqubic> @check \a -> traverse id a == sequenceA a
21:06:27 * ertes . o ( traverse id = sequenceA )
21:06:28 <lambdabot>  error:
21:06:29 <lambdabot>  • Ambiguous type variables ‘t0’, ‘f0’, ‘a0’ arising from a use of ‘myquickch...
21:06:41 <iqubic> @check (\a -> traverse id a == sequenceA a)
21:06:43 <lambdabot>  error:
21:06:43 <lambdabot>  • Ambiguous type variables ‘t0’, ‘f0’, ‘a0’ arising from a use of ‘myquickch...
21:06:48 <pikajude> > traverse (\ n -> guard (even n) >> Just n) [2,4,6]
21:06:50 <lambdabot>  Just [2,4,6]
21:06:53 <pikajude> > traverse (\ n -> guard (even n) >> Just n) [2,4,5]
21:06:55 <lambdabot>  Nothing
21:07:17 <ertes> @check \xs -> traverse id xs == sequenceA (xs :: [Maybe Integer])
21:07:19 <lambdabot>  +++ OK, passed 100 tests.
21:07:50 <julianleviston> iqubic: it’s a good idea to pick concrete types to understand it… so pick a traversable and pick an applicative, and specialise it… like this:
21:07:51 <julianleviston> :t traverse :: (a -> Maybe b) -> [a] -> Maybe [b]
21:07:53 <lambdabot> (a -> Maybe b) -> [a] -> Maybe [b]
21:08:12 <julianleviston> iqubic: does that make it easier to understand for that case?
21:09:39 <julianleviston> iqubic: it’s very general, so it helps to try out different ones IMO.
21:11:20 <iqubic> Yeah I understand that.
21:11:25 <julianleviston> iqubic: generally, though, it goes over a structure (a “Traversable” t) and applies a function that does some applicative thing to each item of the structure’s contents, which may have the effect of transforming the structure in the process, or at least putting it into an applicative context
22:13:34 <exio4> I need a really simple website, a static html/js/css site + a few dynamic webpages which will generate PDF(s) based on data sent by that static site, which libraries would you recommend?
22:23:12 <eliaslfox> >
22:32:49 <julianleviston> exio4: simple is pretty subjective… there are known solutions that are “easier” to implement in other languages than Haskell
22:38:51 <exio4> julianleviston: the dynamic code is already written in Haskell, I simply need to add a web UI to it :) 
22:39:19 <julianleviston> exio4: I’m not sure what you mean by dynamic, but sure. Use Snap then.
22:39:24 <exio4> julianleviston: (it's generating PDF(s) and pictures based on data, a few variables can be tweaked, though)
22:39:24 <julianleviston> exio4:  or Yesod.
22:39:48 <cocreature> exio4: "scotty" is one of the simplest web frameworks we have in Haskell
22:40:12 <exio4> julianleviston: dynamic as generated computationally based on data given the user? 
22:40:12 <julianleviston> cocreature: yeah :) was just about to mention that. It’s built on the same premise as the Ruby webserver "Sinatra".
22:40:21 <exio4> I'll check scotty 
22:40:55 <cocreature> any web framework should do but something like yesod might be a bit overkill
22:41:01 <eliaslfox> What do you guys think of servant?
22:41:02 <julianleviston> exio4: but, I’d hesitate to use the word “simply” with web frameworks.
22:41:14 <exio4> yeah, I only know yesod but it's ... quite a beast for this :)
22:41:19 <julianleviston> eliaslfox: I’ve never used it but from what I’ve seen it’s pretty nice for building APIs.
22:41:32 <cocreature> eliaslfox: I’ve used it a bit and so far I’m quite happy with it
22:42:31 <eliaslfox> Thank you :)
22:42:47 <exio4> julianleviston: I didn't use simple/simply on the web framework :)
22:44:15 <julianleviston> exio4: sorry I must have read it wrong. You wrote “I simply need to add a web UI to it :)” and I was suggesting that adding a web UI isn’t ever particularly simple. :) All good.
22:44:48 <julianleviston> exio4:  or at least, it’s often not a simple task.
22:46:06 <julianleviston> exio4: just preparing you in case you come to it with high expectations of easiness and it turns out more difficult than you imagine is all hehe :)
22:46:43 <exio4> julianleviston: it's just some HTML/CSS/basic JS for this situation, the hard part is in the server and Haskell makes it easy :)
22:47:53 <julianleviston> exio4: cool
22:52:17 <Sh4rPEYE> How would one write an isoUnMaybe such that: isoUnMaybe :: ISO (Maybe a) (Maybe b) -> ISO a b
22:52:30 <Sh4rPEYE> Where ISO a b = (a -> b, b -> a)
22:53:18 <Sh4rPEYE> I tried this, but it isn't right: http://lpaste.net/1666490617003245568
22:53:41 <glguy> you shouldn't be using unsafe Coerce
22:54:31 <glguy> you don't get to assume that Nothing is unused
22:56:11 <cocreature> Sh4rPEYE: I can make an ISO (Maybe ()) (Maybe ()) that maps Nothing to Just () and Just () to Nothing
22:56:24 <fred-fri> apologies for bringing up something that must have been brought up a million times before, but: web frameworks. scotty seems to be the minimalist framwork with the most momentum behind it right now, but it doesn't have typesafe routing, which seems like a huge overlook
22:56:47 <glguy> you can implement this iso operation, just not like pasted
22:57:00 <fred-fri> i'm surprised that not all web frameworks have typesafe routing
22:57:28 <cocreature> fred-fri: Spock is somewhat similar to scotty but includes typesafe routing
22:57:53 <fred-fri> cocreature: does spock use template haskell? i'd like to avoid frameworks that rely on template haskell if i can
22:57:59 <cocreature> no it doesn’t
22:58:17 <fred-fri> happstack seems like a good framework but unless i'm mistaken happstack does use template haskell, and so does yesod...
22:58:28 <fred-fri> i'll take a closer look at spock then
22:58:46 <cocreature> servant also has typesafe routing and doesn’t use TH but it requires knowledge of a fair amount of Haskell extensions
23:00:43 <julianleviston> fred-fri: I got the impression happstack wasn’t maintained. Is that not the case?
23:00:50 <fred-fri> cocreature: based on my limited research servant seems like it's more libraries than a framework. which is good if you know what you're doing, but as a beginner i'd like something a bit more opinionated with appropriate monads etc out of the box
23:01:04 <fred-fri> julianleviston: a lot of the frameworks don't appear to be terribly maintained
23:01:14 <fred-fri> just another complicating factor :)
23:01:19 <julianleviston> fred-fri: hm that’s not my impression. There are only two frameworks anyway aren’t there?
23:01:23 <Sh4rPEYE> cocreature: True. No idea how to implement this better, though
23:01:25 <cocreature> fred-fri: I don’t think it’s less of a framework than scotty
23:01:25 <julianleviston> fred-fri: yesod and snap?
23:02:32 <fred-fri> julianleviston: there are countless frameworks, this article has a bunch and it's not exhaustive https://wiki.haskell.org/Web/Frameworks
23:03:07 <julianleviston> fred-fri: they’re not really frameworks tho…(my point)
23:05:01 <Sh4rPEYE> glguy: I know I can, but I can't manage to do it
23:05:25 <glguy> can you do it in English
23:05:54 <fred-fri> cocreature: what are the main differences between servant and spock in your opinion? and which would you recommend to someone who just wants to write a POST user that writes to db, in order to familiarize myself with web dev in haskell?
23:07:20 <glguy> Sh4rPEYE: I'm not sure if you don't understand the operation itself or how to implement it in Haskell
23:08:42 <cocreature> fred-fri: the main idea behind servant is to put a complete description of your API at the typelevel which means that a lot of errors can be caught statically. however, doing so is not trivial and you often will pay in the quality of compiletime errors for it. so for someone starting out with Haskell I would recommend Spock or even scotty (you can always move to something with typesafe-routing after you’ve
23:08:44 <cocreature> mastered that)
23:10:01 <fred-fri> cocreature: thanks for that assessment, much appreciated. i think ill start with spock then.
23:10:38 <dmj`> cocreature: servant should be getting better error messages thanks to TypeError
23:11:06 <fred-fri> to what degree if any do spock and servant rely on template haskell? i'd like to avoid template haskell if possible
23:11:08 <cocreature> dmj`: I recall an issue about that but iirc not much work has happened in that area so far
23:11:20 <cocreature> fred-fri: as I’ve said before neither of them relies on TH
23:11:45 <fred-fri> sorry i'm an idiot i missed when you said that, thanks
23:11:49 <Sh4rPEYE> glguy: I think the operation itself. 
23:11:52 <julianleviston> fred-fri: only yesod needs TH, really. Unless you count Lens’ usage of it for generating state accessing lenses
23:12:05 <cocreature> dmj`: also TypeError only works for very specific errors so I have my doubts that it will significantly improve the errors overall. but I’m happy to be proved wrong here :)
23:12:39 <glguy> Sh4rPEYE: OK. Why do you think it's possible to do this?
23:13:42 <dmj`> cocreature: true, one obvious mistake many newcomers make is forgetting  Capture takes a Symbol. TypeError couldn’t really account for this since we cannot pattern match on it. 
23:14:21 <dmj`> data Capture (name :: Symbol) (a :: *), where name is purely for documentation purposes
23:14:39 <dmj`> it’s almost better to ignore the type error altogether and just compare the definitions of the types, with what was written
23:15:23 <fred-fri> different subject: i've been reading up a bit on actors, stm and other means to handle concurrency. i understand the domain of actors and stm are not the same, but still... while stm is obviously a great way to handle concurrency it does put the onus on the programmer to atomically lock the right resources and do the right things, whereas actors seems to be more forgiving in that aspect. is this correct?
23:16:25 <fred-fri> or does stm force everything you interact with inside an stm block to be atomically locked? so that you get that basic guarantee out of the box so to speak?
23:16:47 <julianleviston> There’s a bug in my “Pretext-aware Lens.para implementation”, but I can’t for the life of me tell what it is. If anyone would be so kind as to run their eye over, I’d be pretty grateful: http://lpaste.net/570087991498768384
23:17:12 <julianleviston> The example of the error is at the end
23:20:21 <merijn> fred-fri: huh, why does stm require the programmer to lock things?
23:20:36 <merijn> fred-fri: The entire point of STM is to not have to bother with locks
23:21:27 <glguy> Sh4rPEYE: http://lpaste.net/356324
23:26:05 <cocreature> dmj`: I wish there was a better story for providing custom type errors for unification errors.
23:27:34 <Sh4rPEYE> glguy: Yes, came up with similar solution: http://lpaste.net/2679519139789275136
23:27:56 <Sh4rPEYE> glguy: For the record, how'd you answer "Why do you think it's possible?"
23:29:24 <Cale> fred-fri: Everything which happens in a transaction is automatically transactional -- inside a transaction, you can imagine that the entire rest of the system is stopped -- in general it won't be really, but the program will work as if this is the case.
23:29:36 <glguy> I think it's possible because either the two nothings must both be mapped to each other and all the justs are mapped to justs
23:29:58 <glguy> or both the nothings are mapped to justs
23:30:18 <glguy> and some pair of justs are mapped to nothings
23:30:26 <Cale> fred-fri: There are a bunch of different implementations which will get you that behaviour -- the one presently in GHC is optimistic, in that it just runs the transaction, and then when it's about to commit, it locks everything that was read, and ensures that it still has the same value as it did when it was read.
23:30:52 <fred-fri> i see
23:31:15 <glguy> so I need to handle those two cases
23:32:12 <glguy> otherwise there's an error, a component of an isomorphism must be injective
23:33:48 <Cale> fred-fri: actually, I don't recall if there were separate locks or a single global lock for transactions being committed (that's viable because transaction logs won't typically require taking the lock for very long)
23:34:34 <Cale> But anyway, all the locking is part of the implementation, and not something that the programmer can manipulate directly.
23:35:40 <fred-fri> Cale: for some reason my impression was that stm put a larger onus on the developer not to mess up that it actually does
23:35:48 <glguy> Sh4rPEYE: a higher level justification is that if Maybe a and Maybe b are isomorphic, then they have the same number of elements, and if we remove one element from each (the nothing) they still have the same number of elements
23:36:05 <fred-fri> irrespective of whether behind the scenes stm uses global or more granular locks, as long as the developer doesn't have to worry too much about it that's all good i guess
23:37:14 <julianleviston> fred-fri: maybe you’re thinking of manual locking?
23:37:23 <Cale> fred-fri: With this optimistic implementation, you can still get into situations where you write a transaction which reads a lot of things and takes a long time, and then it never actually gets to commit because the things it read keep getting trampled by fast-running transactions on other threads.
23:37:54 <fred-fri> Cale: yes i read that one of the potential pitfalls of stm is that if you're too greedy about resources it can cause starvation issues
23:37:59 <boj> fred-fri: i suppose you are referring to keeping track of everything you need to wrap in 'atomically' for a transaction, but it's not really that much thinking overhead
23:38:19 <merijn> STM implementations in other languages have required a lot of manual stuff, which is why they never took off
23:38:29 <Cale> But yeah, this is something which could actually be solved by the STM implementation itself.
23:38:42 <merijn> fred-fri: Purity + Haskell's type system eliminates a need for a lot of the most tedious stuff that's stopped STM from taking off
23:39:05 <Cale> Oh, right, I'm also talking about STM *in Haskell*, where it is a much better idea than it is in languages where you have effects everywhere.
23:39:06 <julianleviston> I thought the Clojure implementation was pretty bood
23:39:20 <julianleviston> bood = good :)
23:39:30 <fred-fri> actors seem to be more popular than stm in other languages yes... but actors seem to be significantly more complex than stm
23:39:32 <merijn> julianleviston: STM implementations in other language are good, in terms of implementation. They just suck to use :p
23:39:48 <julianleviston> merijn: I didn’t mind using Clojure’s much at all
23:40:14 <julianleviston> merijn: though it depends a bit. I’d say Haskell’s is a lot easier. 
23:40:38 <julianleviston> fred-fri: just checking you’re aware we have actor-like things, too
23:41:18 <fred-fri> julianleviston: yes i am but i see little reason to use actors in haskell given stm
23:41:37 <julianleviston> fred-fri: distributed parrallelism?
23:41:40 <Cale> Actors also really suffer from the same problem of shared memory that these things are aimed at solving -- though they suffer it at a larger scale: the way that an actor responds to messages effectively makes it abstractly like a big shared memory cell.
23:41:41 <fred-fri> the main justification would be distribution yes
23:42:09 <Cale> It would be interesting to see a system which used actors, but had a way to do transactional communication between multiple actors
23:42:26 <fred-fri> but in smaller program running on a single machine stm seems an easier choice than actors
23:42:32 <julianleviston> fred-fri: I think the general consensus is that there’s no one concurrency & parallelism solution that is magic and works for every use case, real world requirements need multiple stories for this
23:42:47 <julianleviston> fred-fri: yeah, totally.
23:43:00 <julianleviston> fred-fri: actors aren’t a good fit for single machine concurrency IMO
23:43:13 <fred-fri> julianleviston: clearly you havent read java concurrency in practice. tldr java and manually keeping tracks of manual locks is the end of history for concurrency.
23:43:17 <julianleviston> fred-fri: depends on what sharing strategy you need, really
23:43:38 <julianleviston> fred-fri: lol yeah, I know.
23:43:48 <julianleviston> fred-fri: but I haven’t read it.
23:44:18 <fred-fri> i'm exaggerating. but it's funny how good the software industry is at ignoring solutions that have been known for decades.
23:45:15 <merijn> fred-fri: tbh, I think concurrency is one of the areas Haskell really shines
23:45:16 <Cale> fred-fri: The main thing which makes concurrency in Haskell less horrible than in other languages is the ability to control which parts of the program can perform which effects though.
23:45:42 <merijn> fred-fri: I mostly write concurrent imperative Haskell (IO everywhere) and it's awesome
23:45:43 <Cale> fred-fri: and that requires most of the deviation which makes Haskell a bit of a challenge for imperative programmers :)
23:46:18 <julianleviston> “What do you mean I can’t write to the logfile in the middle of a map?!” ;-) hehe
23:46:34 <fred-fri> i'm a java dev and mostly write simpler crud apps, but i've interviewed at a few places that focus heavily on concurrency and their interview processes invariably involve questions about how to solve a given situation using manual locks because that's how they roll. they didn't like when my answer was to just NOT do that but instead look at actors, stm instead (depending on the context)
23:46:44 <ongy> merijn: how does it mkae things better when you do IO everywhere? honest question
23:47:11 <merijn> ongy: Still got a type system, advanced libraries for parallelism/concurrency, etc.
23:47:26 <ongy> yea, I love the type system
23:47:33 <merijn> ongy: When 80% of your code is parallelising stuff over channels and running external processes you have to be in IO
23:47:33 <cocreature> there are just not that many libraries with somewhat decent type systems and decent concurrency
23:47:43 <fred-fri> i guess it's not fun to be a tech lead or cto and be told by interview candidates that their whole system is fundamentally flawed and they haven't done their research
23:47:44 <cocreature> s/libraries/languages/
23:47:53 <Rotaerk> haskell's not about not-doing-IO anyway
23:47:54 <ongy> merijn: aren't you usually searchign for things around POSIX? Shouldn't the haskell libraries be a better fit?
23:47:56 <`Guest00000> mapM though
23:47:58 <julianleviston> fred-fri: yeah, that might not be the way to get a job :)
23:48:55 <merijn> ongy: hmm? I'm currently rewriting a bunch of python data-munging into Haskell, and that's all Haskell
23:49:18 <ongy> fred-fri: is manual look real manual, or those "secure sections" I forget the keyword...
23:49:32 <merijn> But it involves lots of file reading (IO), lots of dumping stuff into database (IO), lots of threading to make things run in parallel (more IO)
23:50:05 <ongy> merijn: sounds like fun. Have you benchmarked part of it yet? If it's running well, is it public somehwer? I need to get a bit better with judging performance in haskell
23:50:24 <merijn> ongy: Not really, since my metric is "runs fast enough"
23:50:27 <ongy> oh that sort of stuff, I was expecting numpy
23:50:48 <ongy> with those kind of applications the speed will probably be "whatever the IO decides to do" either way
23:51:07 <merijn> ongy: I'm actually sticking with python for the machine learning since I don't have a replacement for the machine learning library I'm using, despite it being shit
23:51:08 <cocreature> ongy: well especially with IO concurrency can make a big difference
23:51:47 <merijn> ongy: After training/learning in python I'm dumping the result vector back to Haskell and then using Haskell to compute my predictions, since the python performance is shit
23:52:20 <cocreature> merijn really seems to like python
23:52:34 <merijn> cocreature: I really, really don't :(
23:52:44 <dioxylin> Does haskell have any way to interface directly to .NET 4.5+ (and if it's maintained)?
23:53:06 <merijn> dioxylin: Don't think so. But you could use C FFI on both sides?
23:53:10 <fred-fri> isn't a good feature of haskell that rather than doing incremental IO (as imperative languages kind of encourage you to do by default) in haskell by default you can build up the whole IO sequence you want to do and then execute it in one go at the end?
23:53:46 <merijn> Oh, for the record: pipes/conduits are groundbreaking and I don't think people appreciate how much...
23:53:49 <cocreature> merijn: btw I stopped being lazy and opened a trac ticket for the ADOPT pragma if you want to follow the discussions (so far none have happened :)) https://ghc.haskell.org/trac/ghc/ticket/13841
23:53:55 <dioxylin> merijn: Perhaps, but at that rate, I'd probably just write a .NET console program to go through the hassle or just write the C# program myself.  I find F# troublesome to learn :/
23:54:27 <dioxylin> (brb making haskell .NET ffi)
23:54:47 <merijn> I was talking with some people about stream processing languages, and they were complaining how difficult it is. And here I've been thinking that turning anything into a stream-processing task was trivial due to Haskell :p
23:54:51 <julianleviston> merijn: ooh why’s that? are they not simliar to CSP?
23:55:46 <ongy> seems like I have to try conduit/pipes at some point
23:55:48 <merijn> julianleviston: pipes/conduit? Not really (or not at all) since they're not concurrent
23:55:53 <ongy> right after learning lense...
23:56:03 <cocreature> ongy: you don’t need lenses for conduit or pipes :)
23:56:03 <merijn> ongy: conduit and pipes are probably easier
23:56:08 <merijn> And IMO more useful
23:56:25 <ongy> cocreature: I didn't expect to, but lense is sitting on the todo list for way to long now
23:56:33 <cocreature> if you want the real challenge use pipes-parse and suffer the pain from pipes and lens at the same time
23:57:11 <Cale> Well, the basics of lenses are pretty easy... it's just that the lens library has gotten to the point that it's really hard to know what to focus on and the types are all crazy because of the abstractions being taken as far as they can go.
23:57:15 <merijn> They're basically "I have an attoparsec parser that parses a line of text" and "I have 2 million lines of text", use one trivial line of library to get a thing that streamingly parses the file line by line and processes one result a t atime
23:58:00 <Cale> Yeah, pipes is really nice when you have a problem that's well suited to it.
23:58:22 <julianleviston> merijn: streamingly is such a cool word :)
23:58:32 <Cale> The types are kind of absurd, but what it gives you works very well.
23:59:08 <cocreature> I’ve gotten used to the types in pipes itself but I still need to look up things for pipes-group quite often
23:59:54 <Cale> I forked the websockets package to solve a concurrency bug that it had under high load, and ended up solving the problem by ripping out its ad-hoc streams and replacing them with pipes.
23:59:54 <merijn> Pipes can be...confusing at time...but it does what it does really well
