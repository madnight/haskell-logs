00:08:08 <EvanR> i take back my astonishment at ghc not being able to work with low ram
00:08:24 <EvanR> this C++ program cant compile with 2G of ram
00:09:04 <Rembane> The astonishment club got a new member. Which compiler is it?
00:09:17 <EvanR> ubuntu g++
00:09:43 <spoonm> have you tried clang++?
00:11:14 <cocreature> EvanR: comilation or linking?
00:11:22 <EvanR> kill cc1plus
00:11:24 <EvanR> killed
00:11:37 <spoonm> brutal
00:11:37 <EvanR> a single file
00:11:49 <EvanR> heavily boosted im sure
00:12:20 <spoonm> still linked with all the libraries it uses
00:13:27 <Lokathor> EvanR, the very first person i send the demo to, and their version of OpenGL doesn't work somehow with what I wrote :P
00:14:20 <Rembane> Lokathor: Are they running Intel and you are running Nvidia or ARM?
00:14:34 <Lokathor> could be, could be
00:14:50 <merijn> Ah! Welcome to the wonderful world of shitty GPU tooling! :)
00:15:24 <thang1> eh, it's not that GPU tooling is /terrible/ it's that GPU people haven't invented a language more general than assembly yet. Give 'em a few years to write GPU-C /s
00:15:37 <Lokathor> i have, it seems, NVIDIA GeForce GTX 460
00:15:38 <merijn> thang1: We already have GPU-C++ :)
00:15:55 <Lokathor> it's haskell + GLSL I guess
00:16:18 <merijn> thang1: You just have to make sure you don't use non-NVidia, but if you do GPGPU you're using NVidia anyway :p
00:16:21 <Lokathor> all i can think is that the GLSL failed to compile on their machine? but it's pretty basic
00:16:58 <cocreature> merijn: but I want to run your high performance gpgpu code on my integrated intel chip oO
00:17:00 <Rembane> I hope for Vulkan!
00:17:16 <merijn> cocreature: It wouldn't be high performance if you ran it on Intel ;)
00:17:36 <thang1> I don't even care about vulkan. I don't care who the hell manages to do it, I want a universal API/language I can write GPU code in to compile to any GPU
00:17:45 <EvanR> clang++ did it in 3 seconds O_o
00:17:47 <cocreature> merijn: it’s very fast. I can run nethack at 60fps
00:17:59 <halogena1dtoast> cocreature: lol
00:18:10 <merijn> Mine can run nethack significantly faster ;)
00:18:12 <thang1> It's /terrible/ how utterly broken anything graphics related is. Horribly written patches, horribly mangled and utterly crap everything all over the place. It's a wonder graphics even work at all ಠ_ಠ
00:18:16 <EvanR> spoonm: youre a genius of some sort
00:18:24 <thang1> EvanR: nice. Clang based god
00:18:33 <Lokathor> cocreature, my library can cycle background and foreground colors in 80x24 at 60fps!
00:18:40 <spoonm> lol EvanR 
00:19:00 <cocreature> Lokathor: woah!
00:19:01 <merijn> thang1: Honestly, the vendors are getting their act together, but a lot of the game companies produce very broken code and the GPU drivers are "fixed" to workaround them >.>
00:19:12 <EvanR> and how you can use 2G of ram so fast i cant figure out
00:19:38 <EvanR> Lokathor: does it have indexed palette color cycling!
00:20:35 <Lokathor> EvanR, the tiles are indexed from the tileset with a Word8, the colors are allowed to be the full GLfloat range
00:20:53 <thang1> merijn: Honestly, this drives me up the wall
00:21:21 <thang1> I hear over and over again how you submit your game to the GPU vendor who tinkers around for 3 months with their hidden library dev tools and then gives you back some mysterious patches and omg +75% performance
00:21:47 <thang1> It apparently originated from giving game developers super high level APIs so they had no idea which code paths would result in the magically vectorized code they needed
00:22:13 <cocreature> mylittlegpu - performance is magic
00:22:31 <Lokathor> ugh, what
00:22:41 <merijn> cocreature: "mylittlegpu - performance is only tangentially related to what you think is fast"
00:22:44 <Lokathor> my program depends on winsock32.dll somehow :/
00:23:02 <Rembane> Oldschool
00:23:13 <Lokathor> it doesn't use network!
00:23:40 <Lokathor> unless somehow the fact that one of the libs could potentially download something make those libs depend on that and so my program depends on it?
00:23:42 <Lokathor> goofy
00:23:49 <thang1> Lokathor: is it a graphics library? You could be magically pulling in some stuff from a graphics thing that's abusing sockets for async
00:24:34 <cocreature> merijn: but now it’s no longer a pun on mylittlepony!
00:24:42 <EvanR> Lokathor: are you "remembering" to only do opengl in one thread, the main thread or the thread that has the context "made current"
00:25:28 <Lokathor> thang1, it's all built from GLFW and gl... also Linear, Vector, nothing too weird I think
00:25:30 <EvanR> since opengl uses thread local state (??), it causes weird interactions with normal haskell concurrency which may switch OS threads willy nilly
00:25:40 <Lokathor> https://github.com/Lokathor/hexes/blob/master/hexes.cabal
00:26:14 <Lokathor> EvanR, I sent them a build that would print out errors and stuff, and it was a program link error!
00:26:27 <thang1> Weird...
00:26:28 <EvanR> oh it wont even link, well not im less surprised
00:26:35 <EvanR> the linker flags are probably different on their system
00:26:36 <Lokathor> no in the shader program i mean
00:26:43 <EvanR> im even less amazed
00:27:00 <thang1> You want me to clone and try to compile on my linux system with intel gpu?
00:27:07 <EvanR> the top line in the shader is probably a comment referring to the version of the shader language?
00:27:11 <Lokathor> vertex shader:
00:27:11 <Lokathor>     out vec3 fragmentForeground;    fragment shader:     in vec4 fragmentForeground;
00:27:17 <EvanR> if not, there should be
00:27:20 <Lokathor> :P
00:27:29 <Lokathor> my gpu allows such a mistake, i guess theirs does not
00:27:34 <EvanR> right
00:27:58 <EvanR> worse, the version you write that makes it work depends ontheir driver and hardware
00:28:17 <EvanR> even if the language itself is the same across the board
00:28:45 <Lokathor> i'm using 330
00:28:48 <EvanR> so 3D engines go out of there way to modify the shader source before compiling based on collected information
00:29:09 <EvanR> yeah 330 works for me, and one other number works for me, but every other number fails to build on my macbook air
00:29:24 <EvanR> and putting no number, doesnt work
00:29:39 <Lokathor> i think putting no number makes it think it's 110
00:29:52 <EvanR> well, 110 doesnt work for me
00:30:12 <EvanR> how i learned to stop worrying and love modern GL
00:30:40 <LiaoTao> EvanR: Having to modify your shader source programatically is one of the reasons I stopped with OpenGL :D
00:31:04 <LiaoTao> It's just so tedious
00:31:24 <EvanR> i thought self modifying code was fun and exotic
00:31:52 <Lokathor> if NASA can live debug a lisp shell running inside the mars rover, you can edit your shaders before you compile them
00:32:02 <LiaoTao> Lokathor: :(
00:32:13 <LiaoTao> But no one is paying me
00:32:14 <Lokathor> thang1, https://github.com/Lokathor/hexes feel free to try the demo yourself. Right now it just pulses funny colors
00:32:37 <EvanR> F modifying shaders...
00:36:56 <Lokathor> so does Haskell have an automatic destruction ability when things go "out of scope"?
00:37:23 <merijn> Lokathor: You are probably looking for ForeignPtr
00:37:41 <EvanR> theres the bracket pattern
00:37:45 <merijn> Lokathor: Note that that doesn't fire until the GC fires, so it's not immediately when something goes out of scope
00:37:58 <EvanR> its also not necessarily ever
00:38:05 <EvanR> i.e. if you exit the program first
00:38:06 <Lokathor> ah well, it's not a big deal
00:38:07 <johnw> Lokathor: there is the bracket pattern, for providing explicit scoping
00:38:29 <merijn> EvanR: *nothing* will guarantee destructors in case of program exit
00:38:57 <EvanR> if you use bracket, you wont go to "next line" and exit before you do the clean up
00:39:04 <EvanR> with finalizer, you will
00:39:16 <Lokathor> I was just thinking, that I've got these handy newtypes for VertexArrayObjects and VertexBufferObjects and so forth, and if they could clean themselves up automatically without the user of them doing anything that'd be nifty
00:39:20 <merijn> EvanR: Bracket will still not run if your program gets killed
00:39:28 <EvanR> not what im talking about
00:39:31 <merijn> Lokathor: ForeignPtr will probably work
00:39:31 <Lokathor> Rust would let you, and that's about the only thing Rust has better than Haskell
00:39:43 <Lokathor> they've sure got a lot worse in the way of callbacks, ho ho ho!
00:40:07 <merijn> Lokathor: They don't have any guarantees. But what I saw from ezyang's explanation they run pretty quickly after something goes out of scope
00:40:17 <merijn> Lokathor: So if you're not resource constrained it should be fine
00:40:35 <EvanR> for garbage collecting foreign objects that dont really need to be, if youre exiting, its fine
00:40:36 <merijn> EvanR: I meant that "if something *has* to be cleaned up before the program exits, you're boned anyway"
00:40:51 <Lokathor> well i think keeping it in a ForeignPtr would be overkill
00:41:08 <Lokathor> i'll just not worry about it
00:41:09 <merijn> EvanR: Since most resources are freed when the program exits
00:41:11 <EvanR> youre completely ignoring the "destroy out of scope" pattern which Lokathor accidentally referring to
00:41:24 <merijn> Lokathor: overkill in what sense?
00:41:27 <EvanR> which is ok since he wasnt talking about that
00:41:29 <capisce> would you need linear types for that?
00:41:36 <merijn> capisce: For what?
00:42:11 <Lokathor> merijn, well, every single use of the value would now need to read back the pointer.
00:42:12 <capisce> ensure some cleanup happens for some handles
00:42:21 <capisce> file handles, etc
00:42:26 <Lokathor> normally it's just an Int32 or whatever kind of value that you're passing around
00:42:36 <merijn> capisce: Even in cases of program exit you mean? Or just "when stuff goes out of scope"?
00:42:44 <capisce> not talking about program exit
00:42:49 <capisce> within a certain scope
00:42:57 <Lokathor> capisce, you can use a function called bracket
00:43:02 <Lokathor> for any type
00:43:11 <capisce> right
00:43:16 <merijn> capisce: The difference with linear types and, e.g., ForeignPtr is that linear types can guarantee the destructor is ran *immediately*
00:43:19 <felixphew> which of Haskell's regex libraries support ? for lazy (as in non-greedy)?
00:43:32 <capisce> but you can still call a constructor and forget to call the destructor
00:43:46 <Lokathor> yeah
00:43:46 <merijn> capisce: ForeignPtr will run a destructor whenever the resource is GCed, but that might happen some time after the thing goes out of scope (if GC never runs)
00:44:17 <Lokathor> merijn, well, in the case of using OpenGL, it's probably a safe bet to run GC frequently
00:44:23 <merijn> capisce: ForeignPtr will auto-run the (user-provided) destructor when the pointer goes out of scope
00:44:26 <Lokathor> right after you're done drawing, while you're waiting to flip
00:44:45 <merijn> Lokathor: Like I said, I don't think ForeignPtr would be a real problem here
00:45:04 <merijn> capisce: So it does rule out the "forget to call it case"
00:45:19 <merijn> capisce: But it doesn't allow you to check you don't accidentally keep something alive
00:45:35 <Lokathor> merijn, but that's a whole extra pointer read! think of the waste! :P
00:46:09 <felixphew> the wiki said that regex-tdfa did, but I'm still getting an error
00:49:11 <Lokathor> honestly even if it did work perfectly, Buffer objects cleaning themselves up just because they went out of scope is probably not what you want a lot of the time
00:50:37 <thang1> wewwwww lad firefox decided to spike my entire computer after I started compiling Lokathor's code. That was a fun 15 minutes waiting for my computer to get around to recognizing the kill keyboard shortcut :p 
00:50:38 <EvanR> you probably dont want to clean them up at all in your situation
00:50:53 <EvanR> Lokathor: since your scene is so static, you just want to update whatever buffer objects you already have
00:51:03 <Lokathor> EvanR, yeah pretty much
00:51:07 <EvanR> which you shouldnt be doing since the geometry isnt changin?
00:51:34 <EvanR> ah no theres other info
00:51:45 <Lokathor> the VBO gets new data each frame since the vertex data includes what texture locations to use
00:56:34 <Akii> felixphew did you see my gist attempt? :D
00:56:51 <felixphew> Akii: no, I didn't
00:57:01 <Akii> https://gist.github.com/Akii/de87f5bdc24bf2af147015d15986ef78
00:57:01 <felixphew> do you have a link?
00:57:17 <felixphew> Oh!
00:57:27 <Akii> doesn't work yet tho; was my first go at parsers
00:57:27 <felixphew> This is not what I expected, but thank you!
00:59:18 <thang1> Lokathor: I get the same linker error
00:59:37 <thang1> Program Link Error: error: vertex shader output `fragmentForeground' declared as type `vec3', but fragment shader input declared as type `vec4'
00:59:47 <Lokathor> ah, yes
00:59:57 <Lokathor> if you pull the latest from github it should have the fix
01:00:09 <Lokathor> hopefully firefox won't lock your system this time
01:00:43 <thang1> lol that was unrelated. Firefox was acting up prior and was taking up like 5 gigs of ram for some odd reason and I should've restarted it way earlier
01:01:00 <thang1> yup, the fix worked
01:01:26 <thang1> seeing a bunch of random symbols on the screen but it's pretty lookin
01:01:49 <thang1> I'm assuming the symbols are the render output of every character terminals can print?
01:02:12 <Lokathor> yeah it just cycles through the Word8 range over and over
01:02:24 <Lokathor> since there's more than 256 spaces in an 80x24 window
01:03:02 <Lokathor> the font data is in a png in the folder there, but note that the current build style embeds the image into the binary so you don't end up depending on that picture being there
01:03:03 <thang1> Right on. Nice code. I like how it's properly identified as floating so my tiling window manager doesn't try to full screen it
01:03:31 <Lokathor> "floating"? I'm guessing GLFW is doing some magic there, I didn't do much in terms of specifying window info
01:03:55 <thang1> All you did was define that the window had to have a specified size
01:03:57 <Lokathor> ohhh, yeah, because GLFW can make a window not be resizable, it's probably doing that
01:03:59 <Lokathor> yeah
01:04:33 <thang1> You can say "this window should ALWAYS BE FLOATING POPUP but it can be whatever size you want. Please do the needful and I suggest size x by y"
01:04:52 <thang1> but most programmers are lazy and just go "eh it's a popup, maybe, sorta kinda, eh fuck it just spawn a window"
01:05:08 <Lokathor> GLFW.windowHint (GLFW.WindowHint'Resizable False)
01:05:12 <Lokathor> that's all i did XD
01:05:27 <thang1> so I get huge bloated and funky resized windows that are tiled in instead of treated correctly as popups :p
01:05:46 <thang1> Nah that's literally all you need to do, it's just that most people don't even bother to set window hints
01:05:56 <Lokathor> well that's pretty lazy of them
01:06:16 <thang1> Oh you've got no idea lol
01:06:22 <Lokathor> hmmm
01:06:37 <thang1> I searched for "accessability guideline compatible wordpress blog themes" on wordpress's website
01:06:52 <thang1> went from like 10,000+ themes or something to 12
01:07:08 <Lokathor> since opengl can only be used from the main thread, it... would be maybe reasonable to restrict all draw commands to the main thread?
01:07:10 <LiaoTao> thang1: To be fair, being compatible with accessibility guidelines is non-trivial
01:07:20 <LiaoTao> Almost didn't pass my web design course because of it :D
01:07:20 <Lokathor> then I could use IORef and not MVar for holding my state and go ~even faster~
01:07:37 <thang1> All you gotta do is just have a contrast ratio of font to bg of 3 or higher and have non useless tags so that screen readers aren't useless
01:08:03 <thang1> There's more stuff but wordpress doesn't really check for that when you say "accessable" iirc :p
01:08:59 <thang1> I wish accessability didn't make it so hard for websites to look good. I saw the standard accessible website by the us gov. Some 90s geocities level trash website that looks like ass ;-;
01:10:02 <EvanR> Lokathor: its not strictly required to be in the main thread, GLFW makeContextCurrent
01:10:27 <Lokathor> but would you have to write to a new set of buffers and all that?
01:10:37 <Lokathor> I'm not up to the part in the book where they talk about threading >_<
01:10:45 <EvanR> i dont have much experience making context current
01:10:55 <EvanR> but you do need to use a forkOS
01:11:03 <Lokathor> oh right
01:11:06 <LiaoTao> thang1: That's very true
01:11:23 <LiaoTao> Probably another reason why no one follows the guidelines
01:11:45 <Lokathor> it's like 1% less user friendly, but just saying "always draw with the main thread gosh" isn't too restrictive i think
01:11:55 <Lokathor> i'll keep it in mind as a possibility
01:12:38 * hackage mongoDB 2.3.0 - Driver (client) for MongoDB, a free, scalable, fast, documentDBMS  https://hackage.haskell.org/package/mongoDB-2.3.0 (VictorDenisov)
01:12:48 <Lokathor> mongoDB is webscale
01:14:01 <EvanR> true
01:14:48 <EvanR> sdl2 lets you make context current too, but then pulls a "event handling must happen in the main thread period" so its like...
01:21:46 <Lokathor> yeah my library docs already say "please don't call GLFW or gl directly while using this library or you might break things, this is your only warning"
01:23:51 <EvanR> the singleton pattern
01:23:57 <EvanR> there can be only on GLFW
01:24:15 <EvanR> (but in the underlying drivers... you can have as many gl contexts as you want)
01:24:35 <Lokathor> true
01:24:50 <Lokathor> GLFW-b does a good effort to make GLFW thread-safer, but there's still a lot of limits
01:25:18 <Lokathor> thang1, I don't even have any examples of ogl that don't use Resizable False, come to think of it. The first tutorial I used had it and i've always copied it forward
01:26:07 <Lokathor> EvanR, I read a great suggestion: instead of IORef, make your program state Storable and just use a Ptr :P
01:26:50 <EvanR> glxgears is resiable
01:27:31 <EvanR> everything Storable and using only Ptr a is even worse than lisp
01:27:39 <Lokathor> GLFW has a callback for viewport size changes
01:27:54 <EvanR> in terms of type-directed-development
01:27:56 <Lokathor> but in my current case the math goes insane if the size doesn't stay fixed
01:28:22 <Lokathor> oh you'd still have a type on the Ptr
01:28:32 <EvanR> hehe, in my cocoa GUI test all the dimensions were relative to some parameters, which were relative to... eventually the window dimensions
01:28:33 <Lokathor> it's just Ptr Foo instead of IORef Foo
01:28:38 * hackage haddock 2.17.5 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-2.17.5 (alexbiehl)
01:28:45 <EvanR> and since the drawing was all vector graphics, it just worked
01:28:52 <Lokathor> neato
01:29:21 <EvanR> many video games in a window are resizable
01:29:22 <Lokathor> I wanna get hexes into a "usable 0.1" type of state and then learn more OGL stuff
01:29:59 <Lokathor> i'm not saying never resize, i'm just saying that the math for hexes gets annoying if you allow resizes
01:30:39 <Lokathor> right now, cellWidth == tileWidth, and i'd have to go fix up a lot of places and stuff if they became separated
01:30:56 <EvanR> you live you learn
01:31:32 <Lokathor> yeah
01:31:33 <EvanR> when two things you thought were the same arent, when two things you think are different, really arent
01:31:41 <Lokathor> being able to zoom x0.5 or x2 would be nice
01:32:08 <EvanR> vector graphics for glyphs!?!?
01:32:25 <Lokathor> ogl can automatically scale textures up and down, so why not?
01:32:40 <EvanR> that will result is crappier results
01:32:51 <EvanR> since its bilinear scaling
01:33:16 <Lokathor> i thought there were two modes you could pick
01:33:24 <EvanR> if the shader output the perfect form at a different rez, that is better
01:33:31 <Lokathor> and anyway, x0.5 on 8 by 16 pixel tiles might be too small to see anything useful either way :P
01:33:45 <EvanR> yes there are a few, and they all dont look as good as vector
01:34:03 <EvanR> unless its pixel art then you want no filtering
01:34:19 <Lokathor> Yeah if you're using this as a tile engine you probably have tile graphics
01:34:40 <EvanR> you can procedurally generate tiles from a shader ;)
01:34:44 <Lokathor> ~some day i may add additional tile layers to the system~
01:34:47 <Lokathor> oooooh
01:34:59 <Lokathor> i got a regular old RPGMaker in the works
01:36:11 <EvanR> hehe http://www.formz.com/manuals/renderzonerendering/!SSL!/WebHelp/_2_0-2_2/paver_examples_opt.jpg
01:36:46 <EvanR> https://s-media-cache-ak0.pinimg.com/736x/52/51/84/5251841d903e54305272d3ce10b6508b.jpg
01:37:30 <Lokathor> tiling tiles!
01:37:40 <EvanR> a lot of textures nowadays arent made by an artist but by someone with a shader and sliders for params
01:38:04 <EvanR> and they look better when you zoom in or out than with filtering
01:43:56 <thang1> okay dumb question
01:44:53 <thang1> if I have a type First' a which is a wrapper around a type Maybe a, how do I write a quickcheck arbitrary instance for that?
01:45:33 <EvanR> Gen is a Functor right
01:45:50 <Lokathor> https://github.com/jfischoff/are-mutable-references-in-haskell-fast i don't know how to quite run this on windows
01:46:13 <Lokathor> but i would be interested in knowing if the Unboxed Mutable Vector is the same speed as a Storable Mutable Vector version
01:46:19 <EvanR> fmap your way to glory
01:47:45 <ongy> Lokathor: first, install a proper OS :P. To be more serious, setup.sh should work as setup.bat if you set up PATH so the shell finds stack
01:47:54 <thang1> Gen is a Monad, Functor, Applicative, or Testable. so yeah, functor
01:48:07 <ongy> compile and run has a few paths in there. windows uses \ as path separator, so you will have to edit a few more things
01:48:21 <Lokathor> ongy, the setup ran fine
01:48:28 <Lokathor> i could figure it out tomorrow probably
01:48:36 <Lokathor> 245am is a bad time to fix shell scripts
01:48:54 <ongy> eh, sounds like a fun fing to do before bed
01:49:29 <thang1> ^ me every time
01:49:29 <merijn> Lokathor: Any time is a badtime to fix shell scripts :p
01:49:52 <ongy> don't remind me...
01:50:01 <Lokathor> hey i got the pulsing colored text window going
01:50:05 <Lokathor> we'll call that a good day
01:50:09 <thang1> your setup.sh is 3 lines of code
01:50:19 <thang1> really? Just make a batch file and call it a day
01:50:57 <felixphew> which regex library would you recommend?
01:51:17 <felixphew> in particular, which ones support the lazy quantifier "?"
01:51:36 <liste> felixphew: I'd recommend a parser combinator library
01:51:58 <liste> unless there's some very specific need for regex
01:52:17 <thang1> Open up notepad. Type: @echo off \n <commands go here>, save as setup.bat, push to git. Done
01:52:38 <felixphew> liste: I'm having a hard time making parsec understand the type of syntax I want to parse
01:52:56 <felixphew> the first line is the hard part
01:53:03 <felixphew> and I have a working regex
01:53:09 <felixphew> ^(.+?)(?: \(([\w .:-]{2,})\))?(?: \(([MF])\))?(?: @ ([\w '-]+?))? *$
01:53:18 <thang1> good god ಠ_ಠ
01:53:31 <felixphew> yeah, not fun
01:53:37 <liste> yeah, a parsec parser would be much more readable
01:56:54 <bollu> @quchen: ping
01:56:54 <lambdabot> Unknown command, try @list
01:57:02 <bollu> quchen: https://github.com/quchen/stgi/pull/96 typo :)
01:57:46 <quchen> bollu: Merged :-)
02:14:30 <bollu> can I do IO within Tasty?
02:14:33 <bollu> Tasty + HUnit
02:15:33 <bollu> I want to run some external programs and check that they run fine
02:15:35 <bollu> is this posible?
02:15:39 <bollu> possible*
02:15:50 <bollu> at minimum, I need to read from files
02:15:57 <Philonous> HUnit assertions are just IO actions 
02:15:59 <Philonous> So yes, you can
02:16:14 <bollu> ah, neat. I did not see that
02:21:39 <sternmull> I have a value that is a Data.Sequence.Seq in a field and want to write a function that operates on the first three elements. I think i should use viewl and :< but don't find a way. Example: http://lpaste.net/355977
02:22:41 <felixphew> I hope no-one minds me asking lots of questions about parsec - here goes:
02:24:10 <felixphew> is there a good, idionatic way to sequentially chain a bunch of different parsers and return a list of their results?
02:24:46 <pacak> :t sequence
02:24:48 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:25:17 <jle`> be aware that with sequence, the whole resulting parser will fail if any of the individual ones fail
02:25:25 <Philonous> :t sequence :: forall m. Monad m => [m a] -> m [a] 
02:25:27 <lambdabot> error: Not in scope: type variable ‘a’
02:25:27 <lambdabot> error: Not in scope: type variable ‘a’
02:25:36 <Philonous> :t sequence :: forall a m. Monad m => [m a] -> m [a] 
02:25:37 <lambdabot> Monad m => [m a] -> m [a]
02:25:45 <jle`> :t sequence `asAppliedTo` []
02:25:46 <lambdabot> Monad m => [m a] -> m [a]
02:26:39 <jle`> :t traverse optional
02:26:41 <lambdabot> (Alternative f, Traversable t) => t (f a) -> f (t (Maybe a))
02:31:20 <Eduard_Munteanu> sternmull, you viewl and pattern-match the result
02:32:54 <Eduard_Munteanu> e.g. case viewl xs of { EmptyL -> ...; x :< xs' -> case viewl xs' of { ... } }
02:33:18 <Eduard_Munteanu> Alternatively, you can take the first three elements and convert to a list.
02:33:57 <juhp> quchen: yes I am
02:34:21 <Eduard_Munteanu> With view patterns it's sometimes nice to write stuff like   f (viewl -> x :< xs) = ...
02:34:48 <sternmull> Eduard_Munteanu: So there is no way without a second case expression?
02:35:18 <Eduard_Munteanu> sternmull, not really, unless you convert to a list.
02:36:19 <sternmull> Eduard_Munteanu: No, i want to go without a list. Thank you.
02:36:30 <Eduard_Munteanu> sternmull, view patterns may let you write   f (viewl -> x :< (viewl -> y :< (viewl -> z :< rest)))
02:36:54 <quchen> juhp: I think you disabled the wrong package yesterday – not the prettyprinter ANSI compatibility module is broken, but the normal one
02:37:03 <quchen> juhp: Are you sure the ANSI is the problem?
02:37:15 <quchen> s/yesterday/8 hours ago/
02:37:17 <juhp> ah yes seems so
02:37:28 <quchen> In any case, I published a new version that should fix the issues
02:37:31 <juhp> where are you btw?
02:37:42 <quchen> Physically? Munich, UTC+2
02:38:15 <juhp> ah okay
02:38:19 <sternmull> Eduard_Munteanu: That "->" in your example is some kind of "anonymous" case expression?
02:38:34 <quchen> I accidentially published the prerelease under a wrong version on Hackage, so the local tests ran, but pulling in the dependency from Hackage yielded a wrong version
02:39:06 <Eduard_Munteanu> sternmull, it's part of the ViewPatterns extension, it lets you pattern-match on an argument after applying a function to it.
02:39:24 <sternmull> ah, ok
02:41:20 <Eduard_Munteanu> function (f -> pattern)  is  \x -> case f x of pattern -> ...
02:46:06 <bollu> quchen: do you know who else from IRC is attending ZuriHac?
02:47:56 <quchen> edwardk is coming, but that’s no surprise (since he’s a speaker and, well, he’s always there)
02:48:11 <quchen> I think Stephen Diehl is coming as well (sdiehl?)
02:48:14 <bollu> quchen: ah, I see :)
02:48:16 <bollu> quchen: yep
02:48:29 <bollu> quchen: that should be interesting, I want to talk to him about haskell and compilers
02:48:30 <quchen> bitonic probably too, Simon Meier, Jasper (jaspervdj)
02:48:41 <bollu> I see
02:48:55 <quchen> I’m sure there will be a lot of people from the IRC around
02:49:05 <bollu> cool, that should be fun
02:49:19 <quchen> Definitely!
02:49:28 <quchen> ZuriHac is usually one of the highlights of my Haskell year
02:49:56 <bollu> hehe, cool! Unfortunately, this is probably my only large haskell convention in a while :(
02:49:57 <bollu> (and first)
02:50:26 <juhp> quchen: ah right - thanks for fixing
02:50:41 <juhp> I will be at Zurihac too
02:50:54 <quchen> juhp: It’s been a while since I’ve done this – what’s the timeline for inclusion into LTS?
02:51:09 <quchen> juhp: Once it builds on Nightly, is the next step adding it to the next LTS revisions?
02:51:14 <bollu> if you have files  that you need with your test cases, can you ask stack / cabal to keep them side-by-side with your test executable?
02:51:34 <quchen> bollu: You can add extra-source-files
02:51:41 <quchen> Typically done for the readme
02:51:50 <quchen> Those will be put into the sdist along with everything else
02:52:44 <bollu> extra-source-files: filename list
02:52:51 <bollu> any change I can give a glob directory?
02:53:13 <bitonic> I will surely be at zurihac
02:53:18 <quchen> bollu: Nope :-/
02:53:19 <juhp> quchen: you can either wait for lts9 or request adding it to lts8 etc
02:53:22 <bollu> ah, dang
02:53:42 <quchen> juhp: The ticket for LTS < 9 is open. I was just wondering whether the broken build interfered with that ticket.
02:54:00 <quchen> cf https://github.com/fpco/lts-haskell/issues/57
02:54:10 <juhp> quchen: ah right cool - then hopefully soonish :)
02:54:24 <quchen> juhp: Is that just a reminder for you to add it manually?
02:54:30 <juhp> next lts build might happen this weekend
02:54:35 <juhp> yep
02:54:45 <quchen> I see. Alright, thanks!
02:55:13 <juhp> sure
02:56:08 <bollu> quchen: this is for tests
02:57:23 * ventonegro will attend ZuriHac as well
02:58:31 <bollu> I want some extra source files bundled with tests
03:04:40 <ADG_> How can I use the array in getMinPathSum here : https://github.com/adityagupta1089/Project-Euler-Haskell/blob/master/src/81.hs
03:05:02 <ADG_> I mean I am trying to solve this (https://projecteuler.net/problem=81) using dynamic programming
03:05:30 <ADG_> So dp[x][y] = array[x][y]+min(dp[x+1][y], dp[x][y+1])
03:06:16 <Gurkenglas> ADG_, minPathSum will blow up into an exponential amount of calls to minPathSum
03:06:51 <felixphew> what's the Parsec approach to regex's "lazy" quantifier? (i.e. the minimum match such that the following parts succeed)?
03:06:53 <ADG_> Ah, I meant minPathSums ! instead of minPathSum !
03:07:46 <Gurkenglas> I would use the memoize package for this instead of inventing a data structure and tying a loop each time I want to memoize something
03:08:54 <ADG_> How would I do that
03:10:13 <Gurkenglas> Import https://hackage.haskell.org/package/memoize-0.8.1/docs/Data-Function-Memoize.html , minPathSum arr = memoFix2 $ \f x y -> arr !! x !! y + f (x+1) y + f x (y+1)
03:11:30 <Gurkenglas> (Note that most of the time would now be eaten up in the !! calls.)
03:14:55 <felixphew> in other words, how do I translate this: http://regexr.com/3g2ta into Parsec
03:19:54 <ADG_> what is difference between memoize2 and memoFix2
03:20:44 <Gurkenglas> ADG_, in order to define minPathSum using memoize2, you would have to call minPathSum within minPathSum, which results in exponential blowup
03:21:00 <Gurkenglas> memoFix2 tries to look up recursive calls in the memoization datastructure
03:22:11 <ADG_> so something without recursiveness may be done with memoize2
03:22:21 <Gurkenglas> yep
03:22:58 <ADG_> and something like fibonacci with memoFix2
03:23:05 <ADG_> or memoFix1
03:42:41 <kuribas> what is the right thing to do when the input for a function isn't in the domain?
03:43:23 <kuribas> For example the function expects Int < 2 && > -2.  Should it crash with an error, or handle it gracefully?
03:44:36 <ab9rf> kuribas: those are good choices.
03:45:26 <kuribas> maybe handle it gracefully, but show a warning with unsafePerformIO?
03:45:34 <ab9rf> ugh
03:46:16 <ab9rf> yes, it's always nice when something emits random crap from god knows where
03:47:06 <merijn> kuribas: Definitely not that
03:47:12 <sternmull> make a unsafe version that simply crashes and (if required) a safe version that returns an Either?
03:47:18 <ab9rf> honestly, i'd use a Maybe return
03:47:19 <merijn> kuribas: If you want to show warnings, go for proper logging all around
03:47:31 <ab9rf> if you want to do logging, use a proper logging mechanism
03:47:37 <kuribas> ok, so better have a debug flag, to crash when debug is enabled, handle gracefull otherwise?
03:47:53 <merijn> kuribas: Why not always handle gracefully?
03:48:22 <ab9rf> why not just use either Maybe (return Nothing if out of scope) or Either, like a good person?
03:48:23 <kuribas> merijn: because then the program looks fine, but may send bad values to the function?
03:48:41 <ab9rf> and let the caller handle errors
03:49:01 <kuribas> ab9rf: ugh no.  I dislike maybe for programmer errors.
03:49:19 <merijn> kuribas: Then wrap with newtype?
03:49:23 <merijn> Force bounds checking
03:49:30 <ab9rf> yeah, you don't have to use Maybe, you can use any wrapped type
03:49:42 <merijn> Why does it take Int in the firt place if it can only be 3 options?
03:50:04 <merijn> kuribas: What do the -1, 0, and 1 represent?
03:50:14 <kuribas> merijn: directions
03:50:32 <merijn> kuribas: So why not make a Direction ADT?
03:51:09 <kuribas> merijn: I have the contour of an image, the difference between two pixels should be between -1 and 1.
03:51:36 <merijn> That's not really a reason why the function shouldn't take an ADT, though
03:52:30 <kuribas> hm okey, I need to look into it...
04:01:59 <ertes-w> kuribas: i tend to use Maybe anyway and then write an "unsafe" variant
04:02:15 <ertes-w> neverFailMaybe :: A -> Maybe B
04:02:41 <kuribas> ertes-w: the only way it can fail is if there is a bug in the other code...
04:02:46 -RSSBot[thekyriar(nebrssb_60@gateway/shell/matrix.org/x-fygzyyaoesjivepw)- Planet Haskell posted a new article: Why I lift ( http://www.snoyman.com/blog/2017/06/why-i-lift )
04:02:48 <ertes-w> neverFail = maybe (error "I failed anyway, because my programmer sucks") id . neverFailMaybe
04:03:04 <ertes-w> kuribas: ^ like that
04:03:25 <kuribas> ok
04:03:36 <ertes-w> the idea is that you can use neverFailMaybe for debugging
04:03:42 <ertes-w> and in production you use neverFail
04:04:28 <ertes-w> (in fact most of the time it doesn't even pay off to define neverFail explicitly)
04:21:18 <bollu> can I create a test group in HUnit based on IO
04:22:12 <quchen> bollu: What do you mean with group? Assertions in HUnit are simply IO actions, you can just >> them
04:23:16 <bollu> quchen: no, I want to create a test group's list of tests by reading files
04:24:05 <bollu> :t testCase
04:24:06 <lambdabot> error: Variable not in scope: testCase
04:24:22 <bollu> hm, I guess WithResource is what I need
04:24:55 <quchen> bollu: Is that from Tasty?
04:25:05 <quchen> Tasty can do this, I haven’t used HUnit alone yet.
04:26:15 <bollu> yep, it's from Taty
04:26:20 <bollu> Tasty*
04:36:32 <locallycompact> Hi, I'm having trouble getting the basic example from the cloudhaskell docs to work: http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.3.3/docs/Control-Distributed-Process-Backend-SimpleLocalnet.html
04:36:35 <locallycompact> it says
04:36:45 <locallycompact> which should then output:
04:36:45 <locallycompact> Slaves: [nid://localhost:8083:0,nid://localhost:8082:0,nid://localhost:8081:0,nid://localhost:8080:0]
04:36:50 <locallycompact> but I just get Slaves: []
04:37:01 <locallycompact> and also says
04:37:02 <locallycompact> "If you try the above example and the master process cannot find any slaves, then it might be that your firewall settings do not allow for UDP multicast (in particular, the default iptables on some Linux distributions might not allow it)."
04:37:29 <locallycompact> but I don't know how to correct for that, ifconfig seems to indicate it has multicast
04:39:39 <earthy> locallycompact: check your iptables
04:39:50 <earthy> they don't show up in ifconfig
04:40:10 <earthy> iptables -L
04:41:05 <locallycompact> no mention of multicast there
04:41:55 <locallycompact> earthy, how do I correct?
04:42:51 <locallycompact> is this right? https://gist.github.com/juliojsb/00e3bb086fd4e0472dbe
04:44:56 <locallycompact> hmm that had no effect
04:47:07 <locallycompact> earthy, can you give me anything to run?
04:47:25 <matrium1> what's the reason for Data.Set to not have a functor instance?
04:48:45 <ertes-w> is there something like the 'appar' library, but for Text?
04:49:00 <ertes-w> i.e. a very small parser library
04:49:22 <locallycompact> matrium1, elements of Set have to be of typeclass Ord for implementation reasons
04:49:32 <locallycompact> matrium1, otherwise lookups are very slow
04:49:47 <ertes-w> bonus points, if it supports streaming
04:53:08 <matrium1>  locallycompact: and how does affect it's functor instance?  I mean there is a Set.map. Why not just define instance Funtor Data.Set where fmap = map
04:53:24 <matrium1> *how does this
04:53:38 <sternmull> ertes-w: Can't you encode your text as utf-8 and then use Appar.LazyByteString?
04:54:01 <locallycompact> matrium1, they're not the same type signature
04:54:14 <locallycompact> Set.map :: Ord b => (a -> b) -> Set a -> Set b
04:54:24 <locallycompact> fmap :: (a -> b) -> f a -> f b
04:54:35 <locallycompact> fmap makes no such constraint on b's interface
04:54:57 <ertes-w> sternmull: i chose to go with attoparsec now
04:55:01 <matrium1> locallycompact: ah! now I see. Thanks!
04:55:07 <ertes-w> sternmull: mostly because it can do streaming
05:09:35 <fendor> when using HTF, can i have multiple test files, for example ATest.hs and BTest.hs?
05:10:23 <ab9rf> it is somewhat spoily
05:10:25 <ab9rf> oops
05:10:27 <ab9rf> sowwy
05:13:38 * hackage feature-flipper 0.2.0.1 - A minimally obtrusive feature flag library  https://hackage.haskell.org/package/feature-flipper-0.2.0.1 (toddmohney)
05:15:38 * hackage feature-flipper-postgres 0.1.0.1 - A minimally obtrusive feature flag library  https://hackage.haskell.org/package/feature-flipper-postgres-0.1.0.1 (toddmohney)
05:23:15 <earthy> locallycompact: sorry, at work and out of ideas for helping you with iptables (it's been a while since I last did that stuff in anger)
05:45:29 <matrium1> how can I derive a type class instance  for all types that are instance of another typeclass? something like "forall Car a => Drivable a where drive = driveCar"
05:46:40 <mauke> you can't
05:49:12 <bollu> mauke: ? instance Car a => Drivable a where drive = driveCar
05:49:44 <mauke> that is an instance for all types
05:49:59 <bollu> I'm sorry, what?
05:50:09 <mauke> you can't have any other instances, then
05:50:09 <bollu> I don't understand what you mean by "that is an instance for all types"
05:50:16 <bollu> sure
05:50:28 <bollu> but that doesn't mean "you can't"
05:50:32 <bollu> just that you're locked in
05:51:00 <mauke> this instance covers all types
05:51:06 <mauke> it's not what matrium1 asked for
05:51:44 <ContessaTP> I think mauke is talking about type 'a'
05:51:55 <ContessaTP> wait no
05:52:03 <ContessaTP> nvm
05:56:33 <bollu> mauke: can you clarify?
05:56:53 <mauke> what's unclear?
05:57:19 <matrium1> So I can just say that is something is a Car it must be Drivble "class Drivable a => Car a" and not that Car a entails Drivable a
05:57:32 <matrium1> *is = if
05:59:02 <merijn> matrium1: Making something a superclass like that will force people that define an instance of Car to define an instance of Drivable. However, usage of "Drivable" and "Car" sounds like inheritance, which is something that typeclasses aren't good at mimicking...
05:59:08 * hackage streaming-commons 0.1.18 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.18 (MichaelSnoyman)
06:23:27 <makalu> how do I get network HostPreference from a non-static string? 'read' doesn't work and I can't use overloadedstrings with dynamic strings.
06:24:02 <merijn> makalu: OverloadedStrings just uses the IsString class
06:24:10 <merijn> makalu: So you can just use fromString
06:24:11 <makalu> I'll just use fromString?
06:24:12 <merijn> :t fromString
06:24:14 <lambdabot> IsString a => String -> a
06:24:15 <makalu> ok thanks
06:24:24 <makalu> it's not total of course
06:24:39 <merijn> makalu: Is there no other conversion function?
06:24:53 <makalu> I haven't seen any yet
06:25:38 * hackage logging-facade 0.3.0 - Simple logging abstraction that allows multiple back-ends  https://hackage.haskell.org/package/logging-facade-0.3.0 (SimonHengel)
06:25:59 <makalu> sorry, it's from warp. network uses strings.
06:28:10 <quchen> What’s the difference between -ignore-package and -hide-package in GHC?
06:28:49 <makalu> oh it actually is total. The result is 'Host "mystring"' for arbitrary strings. I guess you'll get an exception later when opening a socket.
06:29:12 <quchen> Nevermind, the user’s guide has a detailed section that I overlooked.
06:34:08 * hackage show-prettyprint 0.1.2.1 - Robust prettyprinter for output of auto-generated Showinstances  https://hackage.haskell.org/package/show-prettyprint-0.1.2.1 (quchen)
06:49:08 * hackage hspec-snap 1.0.0.2 - A library for testing with Hspec and the Snap Web Framework  https://hackage.haskell.org/package/hspec-snap-1.0.0.2 (DanielPatterson)
07:00:28 <np356> Hello, I have quit my job today. I'm a developer with ~10 years of experience. Primarily in c++, algos, machine learning, math, and recently haskell. I live in Berlin. Anyone hiring?
07:01:35 <merijn> np356: If you're willing to move, I think Standard Chartered is always hiring :p
07:02:07 <np356> nope. just bought a flat in Berlin. It doesn't have to be 100% haskell. I just know where the people I want to work with hang out :)
07:28:10 <wz1000> If I have two records that are defined equivalently, but the field names are different, would unsafeCoerce still work?
07:29:00 <zomg> I should try applying to some haskell jobs before I actually need to find a job. Because it would be interesting to do something else than JavaScript and such for a change, but I have no idea if I'm really good enough at Haskell :p
07:32:33 <Xion_> Is there a lot of Haskell jobs around?
07:33:23 <shapr> I get a bunch of Haskell job spam from various recruiters.
07:34:35 <shapr> I get about 25 Haskell jobs in my inbox any given week, but I doubt all the recruiters have found me. I also hear of more jobs floating around the community.
07:36:07 <Rembane> shapr: How do you get them? Have you written the word Shibboleth on your LinkedIn presentation?
07:36:44 <merijn> wz1000: "It Depends(TM)"
07:36:48 <shapr> no, but there are four or five functional programming job recruiter websites and I signed up for one
07:37:00 <Rembane> Ah. Cool.
07:37:24 <merijn> Haskellers.com, follow big Haskell figures on twitter (they retweet job openings)
07:37:28 <Xion_> I got AdWords for Jane Street everytime I look for something Haskell-related
07:37:40 <merijn> haskell-cafe and r/haskell get job openings sometimes
07:37:57 <merijn> Jane Street is ocaml, but if you like strongly typed FP, that's still good
07:38:07 <merijn> Xion_: I would say there's more jobs than it seems
07:38:27 <shapr> I mean, it's harder to find a Haskell job opening than a Java job opening.
07:38:34 <merijn> Xion_: I got an email from a Barclays recruiter that they're starting a Haskell group in London, so many banks
07:38:53 <merijn> I think a lot of Haskell recruitment goes via word-of-mouth/networking, not so much recruiting websites
07:38:58 <Xion_> merijn: Seems like London is a popular Haskell hub apparently
07:39:00 <shapr> Yeah, several startups in san fran want Haskell coders.
07:39:09 <shapr> Several in Boston also want Haskell
07:39:27 <shapr> And there are Haskell jobs in the Stockholm area
07:39:38 <shapr> I haven't seen any here in Atlanta
07:40:08 <Xion_> I remember there was at least one startup using Haskell in Zurich when I lived there
07:40:30 <shapr> yeah, I don't know where the multiple Haskell blockchain startups are located.
07:40:46 <np356> Any remote jobs. I don't want to move from Berlin
07:40:48 <np356> ?
07:40:50 <raek> shapr: I've heard about Functor in Stockholm. do you know of any other companies?
07:41:31 <shapr> raek: I've heard of some others, but I don't remember the names. I think one of them was a game company, even
07:41:54 <raek> okay. thanks anyway.
07:42:16 <capisce> np356: https://weworkremotely.com/jobs/search?utf8=%E2%9C%93&term=haskell
07:42:25 <capisce> np356: https://remoteok.io/remote-haskell-jobs
07:43:23 <shapr> raek: aer du svensk?
07:43:32 <shapr> oh duh, whois infor
07:43:51 <raek> shapr: yep. Linköping.
07:44:17 <shapr> jaså, jag är från USA, men bodde i Sverige flera år
07:44:21 <wz1000> np356: https://wire.softgarden.io/job/1022440?l=en
07:44:27 <wz1000> I saw that on reddit a few days ago
07:44:46 <shapr> and my Swedish has mostly rusted away
07:45:46 <shapr> I got to meet DrSyzygy recently when he came to a math conference in Atlanta. We talked about group theory and Haskell in mostly Swedish.
07:46:05 <capisce> seems there's #haskell.se and #haskell.scandinavian if you want to talk about Haskell in Swedish
07:47:18 <wz1000> np356: Also http://www.tweag.io/posts/2017-05-18-hiring-technical-evangelist.html
08:04:12 <peddie> np356: takt is remote-friendly last I heard
08:16:40 <akr`> Hello
08:17:06 <akr`> How bad of an idea is it to be calling performGC after every request on your website?
08:17:16 <tempeh> Hi Everyone! Has anyone used Ed Kmett's library 'sparse' for sparse matrices? Is it productive-worthy?
08:17:18 <akr`> and is it okay to call performGC from different threads
08:19:41 <dmwit> Forcing a GC can be a good idea if latency is an issue for you. I would want a decision like that to be driven by some experimental data, though.
08:20:08 * hackage show-prettyprint 0.2 - Robust prettyprinter for output of auto-generated Showinstances  https://hackage.haskell.org/package/show-prettyprint-0.2 (quchen)
08:20:15 <akr`> dmwit: do you know if it's okay to be calling performGC from different threads at the same time?
08:20:44 <dmwit> That should be fine.
08:20:54 <c_wraith> I would try to avoid it, though
08:21:07 <c_wraith> Not because it would cause problems, but because most of the time it would cause double-GC
08:21:13 <dmwit> performGC will probably block all other threads from running until it finishes, though.
08:21:20 <akr`> interesting
08:21:27 <dmwit> Which... is probably what you're trying to avoid.
08:21:30 <c_wraith> and since GC time is proportional to the live data set, running it twice is not faster than running it once.
08:21:42 <c_wraith> Err, the second time isn't faster than the first time
08:22:33 <akr`> I'm getting some random crashes and freezes on the server, this is probably unrelated to calling performGC after each request, right?
08:22:48 <dmwit> Perhaps have a single thread that's in charge of calling performGC. Notify it when requests start and stop, and only performGC when there are no outstanding requests.
08:23:23 <dmwit> Calling performGC should not cause crashes and freezes.
08:23:52 <c_wraith> historically, the parallel GC has actually had some crash bugs.
08:23:58 <akr`> hmm
08:24:00 <c_wraith> It's worth disabling to see if that improves things
08:24:03 <akr`> so this is on GHC 6.12
08:24:15 <c_wraith> that's a pretty historical version of ghc.  :P
08:24:22 <akr`> yeah :(
08:24:31 <c_wraith> try disabling parallel GC
08:24:34 <dmwit> Oh, wow. 6.12 is like 7 years old
08:24:55 <ongy> people still get 6.12 to build?
08:25:25 <akr`> if you manage to set it up right
08:25:32 <akr`> (ideally in a docker container)
08:25:37 <c_wraith> you download it prebuilt and use your frozen package lists...
08:26:07 <akr`> thanks for the help, I'll try disabling it then
08:30:08 * hackage servant-snap 0.7.3 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.7.3 (imalsogreg)
08:33:26 <fresheyeball> anyone out there know a way to convert a Networ.URI.URI to a URI.ByteString.URIRef ?
08:33:32 <fresheyeball> or do I just need to write the function?
08:37:06 <ab9rf> don't think anyone has written that
08:37:19 <edwardk> tempeh it is mostly a proof of concept. i wouldnt put it in production
08:37:32 <ab9rf> they're different moduels that serve the same purpose, and they do it slightrly differently
08:37:37 <edwardk> it shows how that kind of multiplication kernel works
08:38:30 <edwardk> if your matrices are sufficiently sparse it can be faster than anything else, but how sparse that has to be is quite a high bar to clear
08:40:57 <tempeh> edwardk: okay, thanks. I bet I'm sparse enough, but I'll keep it abstracted to switch it out if need be. Unless you know of any alternatives that you'd recommend using in production
08:41:46 <fresheyeball> ab9rf: ok then
08:42:53 <edwardk> i wrote it to explore a funny morton order table join / matrix multiplier i figured out, then sort of forgot about it
08:43:10 <edwardk> be warned it is mostly unsupported. i dont even know how much of it is there
08:44:00 <tempeh> ok. yeah, looks like it's still on vector < 11 and transformers < 5
08:51:18 <fresheyeball> what is NFData ?
08:53:09 <cocreature> fergusnoble: NFData is a typeclass for evaluating things to normal form, i.e., fully evaluating them
08:53:16 <cocreature> eh ^ fresheyeball 
08:53:29 <fresheyeball> oic
08:53:30 <fresheyeball> neat!
08:53:44 <fresheyeball> so thats why there are deepSeqs in there
09:01:21 <kuribas> @hoogle a -> (a -> Bool) -> Maybe a
09:01:22 <lambdabot> Control.Monad.Plus partial :: (a -> Bool) -> a -> Maybe a
09:01:22 <lambdabot> Agda.Utils.Maybe filterMaybe :: (a -> Bool) -> a -> Maybe a
09:01:22 <lambdabot> Agda.Utils.Maybe.Strict filterMaybe :: (a -> Bool) -> a -> Maybe a
09:02:18 <kuribas> @hoogle a -> Bool -> Maybe a
09:02:19 <lambdabot> Data.Maybe.HT toMaybe :: Bool -> a -> Maybe a
09:02:19 <lambdabot> Text.XML.HXT.DOM.Util toMaybe :: Bool -> a -> Maybe a
09:02:19 <lambdabot> Data.Microformats2.Parser.Util if' :: Bool -> Maybe a -> Maybe a
09:02:29 <edwardk>  a <$ guard (f a)
09:03:05 <kuribas> right, thanks!
09:03:35 <NextHendrix> hi guys, i have a function that runs replicateM a bunch of times, then it returns an enormous list of lists
09:04:05 <edwardk> nexthendrix what are you doing with the list of lists
09:04:08 <NextHendrix> is there a way to get it to like, sum the lists as it goes along instead of at the en
09:04:24 <NextHendrix> sum <$> transpose list
09:04:35 <NextHendrix> basically a straight sum
09:04:56 <NextHendrix> [a, b, c] and [x, y, z] -> [a + x, b + y, c + z]
09:05:37 <NextHendrix> that huge list of lists is pretty ugly to transpose and sum, and pretty memory fat
09:05:50 <kuribas> so zipWith2 (+)?
09:06:00 <edwardk> so your "state" is this big list of lists and you want to compute the first summand then move to the next lazily?
09:07:22 <NextHendrix> yes
09:07:55 <c_wraith> You probably need to abandon replicateM
09:07:59 <NextHendrix> the function that generates each sublist is a separate thing, although the number of times replicateM runs is dependent on input also
09:07:59 <edwardk> does convertig from [[a]] to [ZipList a] and using foldr (liftA2 (+)) (pure 0)   get you your answer?
09:08:15 <NextHendrix> well my solution works its just really slow
09:08:17 <c_wraith> because replicateM is cute, but usually a memory problem
09:08:45 <edwardk> or foldr1 (zipWith (+)) if you know there is at least one list i suppose
09:09:08 <NextHendrix> here's the code https://ptpb.pw/5Ej2/hs
09:10:28 <kuribas> c_wraith: is replicate better?
09:10:48 <edwardk> kuribas: not really
09:11:19 <edwardk> next hendrix: how does the performance compare with
09:11:56 <NextHendrix> some inputs end up with like 10000 sublists, each sublist with 30000 ints
09:12:04 <kuribas> like foldr (liftA2 (zipWith2 (+))) (pure 0) (replicate n)
09:12:07 <edwardk> maximum $ foldr1 (zipWith (+)) nList
09:12:55 <edwardk> just focusing on your transposition problem to start
09:13:18 <NextHendrix> edwardk: btw thanks for the help with state the other day, i disappeared because i fell asleep so apologies
09:13:22 <NextHendrix> i got it in the end
09:13:32 <edwardk> nexthendrix np i also wandered away
09:15:24 <edwardk> i apologize for any notational quirks in my replies yesterday. was typing on my phone
09:15:35 <NextHendrix> yeah i was wondering about that
09:15:49 <NextHendrix> worked it out just said it out loud
09:16:07 <edwardk> yeah
09:16:13 <hexagoxel> merijn: you linked me to a gist for HList/Fun/apply a couple days ago. What you had there is an "hUncurry"; do you perchance have "hCurry" as well lying around somewhere, in a version that compiles with ghc-8?
09:16:45 <edwardk> this is why when i email, etc i try to use fixed width fonts for variable names, etc
09:17:07 <edwardk> otherwise talking about code is quite difficult with short variable names
09:18:08 <edwardk> hcurry takes a function taking an hlist and makes a fully curried form of it?
09:19:15 <kuribas> :t \n m -> foldl' (liftA2 (zipWith (+))) (pure $ repeat 0) (replicate n m)
09:19:16 <lambdabot> (Num c, Applicative f) => Int -> f [c] -> f [c]
09:19:18 <edwardk> i probably have code lying around for the various hlist/vinyl style curries
09:19:47 <kuribas> edwardk: wouldn't that work?
09:20:51 <edwardk> kuribas: i switched to foldr1/foldl1' to avoid the extra run of 0s
09:21:18 <edwardk> i didnt bother parsing the replicate machinery above
09:21:28 <kuribas> :t \n m -> foldl1' (liftA2 (zipWith (+))) (replicate n m)
09:21:29 <lambdabot> (Num c, Applicative f) => Int -> f [c] -> f [c]
09:21:32 <edwardk> but if you just inlined it, then likely
09:21:42 <NextHendrix> edwardk: foldr/zipwith version seems to be about 20% slower 
09:21:51 <edwardk> nexthendrix good to know
09:22:10 <NextHendrix> i have a massive sample input file that takes a while to run 
09:22:48 <edwardk> not sure how to work smarter without better data structures
09:22:52 <kuribas> foldr may be accumulating thunks, try foldl1' ?
09:22:58 <edwardk> yeah
09:23:27 <NextHendrix> ok, i'll give it a shot and then go back and rethink my solution
09:24:28 <edwardk> if that doesnt help you might consider having the replicates build a vector rather than a list or something? just to get some locality of reference
09:25:12 <edwardk> overall it sounds like your problem is "i need to compute a lot of stuff, and that takes time" :)
09:25:19 <NextHendrix> yah seems silly to keep going from a normal list to a DList with every step
09:25:27 <NextHendrix> lol
09:25:39 <NextHendrix> ok i'll go think smarter about it, cheers guys
09:26:32 <edwardk> round tripping to/from dlists repeatedly is a very bad idea
09:26:55 <NextHendrix> well initially i was doing `list1 ++ list2 ++ list3`
09:27:01 <NextHendrix> which i also hear is a bad idea
09:27:03 <edwardk> every round trip incurs a cost of walking the entire list so far if you append after
09:27:33 <nshepperd_> Make a loop that does zipWith (+) and deepseq at each step
09:28:03 <edwardk> you need cheap drop take and append. consider Seq
09:28:39 <edwardk> deepseqing repeatedly can be dangerous if you arent careful not to transitiviely repeatedly deepseq the same things
09:29:04 <NextHendrix> having a look at seq
09:29:24 <edwardk> data.sequence Seq not the seq function obviously
09:29:27 <nshepperd_> deepseqing would be cheaper on a unboxed vector or something
09:29:36 <edwardk> i state that becuase deepSeq somehow came up
09:30:34 <edwardk> anyways drop/take/append are all log(min(k,n-k)) there
09:30:57 <edwardk> constants suck but compare to repeated dlisting?
09:31:03 <edwardk> er compared to
09:33:08 <edwardk> in getN you can share the work to compute words
09:33:20 <edwardk> by naming a temporary variable
09:34:12 <edwardk> but that runs once and isnt critical path
09:35:19 <edwardk> oh and i misread doList it isnt recursive
09:35:27 <edwardk> so the dlist stuff may well be fine
09:39:40 <kuribas> nshepperd deepseq wouldn't be necessary on an unboxed vector?
09:42:41 <ertes-w> if i use pattern-matching on Text via OverloadedStrings, it's linear in the number of patterns, right?  or does it do any optimisations like prefix matching?
09:43:00 <ertes-w> i would expect it to rewrite it to a bunch of (==)
09:45:11 <edwardk> ertes thats about all you're going to ge.  ghc knows nothing about Text, so it cant make an efficient parser
09:45:16 <edwardk> er get
09:45:42 <ertes-w> edwardk: yeah, i thought perhaps the text library has some rewrite rules for that, but it would probably be difficult to engineer
09:46:06 <edwardk> rewrite rules dont really have a way to talk about multiple cases in a case statement
09:46:19 <edwardk> case is an opaque blob there
09:46:51 <ertes-w> edwardk: any follow-up on my question about kan-extensions?  the question was whether it would make sense to add some extra stuff to Control.Monad.Codensity or an extra module for things like exceptions
09:47:05 <edwardk> missed the question
09:47:14 <ertes-w> like:  cBracket o c = Codensity (bracket o c)
09:47:22 <edwardk> hrmm
09:47:33 <edwardk> he semantics of that are kinda weird
09:47:47 <edwardk> becuase of codensity style backtracking
09:47:55 <ertes-w> backtracking?
09:48:09 <edwardk> you can't callCc but you can timetravel back
09:48:12 <ertes-w> you mean reusing a continuation?
09:48:15 <edwardk> let me dig up an example
09:48:16 <edwardk> yeah
09:48:21 <ertes-w> ah, yeah, makes sense
09:49:10 <ertes-w> well, i would call it branching rather than backtracking, then i have a clear mental image of how it works
09:49:16 <edwardk>  https://mail.haskell.org/pipermail/haskell-cafe/2010-January/071729.html
09:49:44 <edwardk> there is me using Codensity STM to reason about if a variable will be used in the fuure
09:49:46 <edwardk> er future
09:51:14 <ertes-w> edwardk: so would you say "no", or would you say: "it needs to be documented carefully"?
09:51:17 <edwardk> but anyways it sounds like you're already expecting these semantics
09:51:24 <ertes-w> yeah, i am
09:51:30 <edwardk> i'd say needs to be documented carefully
09:52:05 <ertes-w> edwardk: the reason i ask is that i'd create a PR…  if the answer would be "no", i'd create a separate package
09:52:14 <edwardk> heh
09:52:20 <edwardk> a pr is welcome
09:52:55 <ertes-w> alright =)
09:52:58 <ertes-w> i'll use the lens style of Control.Exception.Codensity
09:53:58 <edwardk> well, you can probably add the methods directly to the module if you document them and they have decorated names
09:54:18 <ertes-w> alright
09:54:25 <edwardk> using the exceptions package rather than C.E would be welcome
09:54:35 <edwardk> that way it works over more monads
09:54:44 <ertes-w> yeah, i'll do that
09:55:39 <ertes-w> base 4.17 change log: merged exceptions, kan-extensions, monad-control and pandoc into base
09:55:59 <Clint> :-O
09:56:17 <ertes-w> base 5.0 change log: "base is deprecated…  use lens"
10:01:29 <kadoban> Hah
10:07:19 <Guest61508> With Stack, is there any way to specify the output folder for the compiled binaries? The regular .stack-work is annoyingly deep and has stuff I don't want in it
10:08:04 <Guest61508> I couldn't find anything in the docs
10:08:52 <NextHendrix> stack install will put bins in ~/.local/bin
10:09:53 <NextHendrix> also `stack exec <name>` will run binaries from anywhere in the project dir
10:11:10 <Guest61508> I'm wanting to make a package for deploying, so neither of those are all that helpful
10:12:15 <kadoban> You can programatically get the directory, with 'stack path' with some argument, if that helps.
10:14:24 <Guest61508> I didn't know about that, that looks useful enough
10:14:27 <Guest61508> Thanks
10:14:57 <MitchellSalad_> Codensity STM to branch on future TVar reads... that's a new one =O
10:15:15 <MitchellSalad_> it breaks my poor brain
10:21:01 <ertes-w> MitchellSalad_: it's really simple, if you rewire your brain into CPS thinking
10:21:15 <c_wraith> it's just continuations over mutable updates... 
10:21:24 <ertes-w> MitchellSalad_: Codensity is really just a restricted form of ContT
10:21:50 <shapr> How do I rewire my brain into CPS thinking?
10:21:53 <shapr> Is there a guide?
10:21:58 <ertes-w> shapr: use it
10:22:03 <shapr> ok then
10:22:10 <MitchellSalad_> ertes-w: yeah I know, ContT breaks my brain as well :)
10:22:15 <ertes-w> shapr: start by using Codensity for resource management =)
10:22:30 <shapr> ok, is there a guide for that?
10:22:32 <ertes-w> @let import Control.Monad.Codensity
10:22:33 <lambdabot>  Defined.
10:22:38 * hackage th-desugar 1.7 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.7 (RichardEisenberg)
10:22:42 <shapr> Everytime someone points me to comonad.com I start to cry
10:22:47 <ertes-w> @let cBracket o c = Codensity (bracket o c)
10:22:48 <lambdabot>  Defined.
10:22:51 <ertes-w> :t cBracket
10:22:52 <lambdabot> IO a -> (a -> IO b) -> Codensity IO a
10:23:17 <ertes-w> shapr: takes "open" and "close" actions and returns the resource…  will be freed when the Codensity finishes
10:23:25 <shapr> is this the "with" from Python?
10:23:38 <ertes-w> it's the 'allocate' from ResourceT
10:23:38 * hackage singletons 2.3 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.3 (RichardEisenberg)
10:23:55 <ertes-w> (except that ResourceT uses an actual data structure for resource management, while Codensity uses CPS)
10:24:03 <Tuplanolla> I was about to ask what's the difference between `Codensity` and `ResourceT`, ertes-w.
10:24:06 <shapr> wow, that was MUCH simpler than I expected
10:24:27 <Tuplanolla> At least `ResourceT` does reference counting.
10:25:01 <ertes-w> shapr: think about it:  Codensity (\k -> …)  -- k is the future of the action…  k is everything that follows after this action…  so what happens if you do something *after* the future?
10:25:19 <ertes-w> Codensity (\k -> k () `finally` putStrLn "After the future.")
10:26:01 <MitchellSalad_> hrm...
10:26:09 <Rotaerk> you are my codensity !
10:26:37 <MitchellSalad_> ertes-w: and if you bind that to another thingy, what order do the after-the-future continuations run in?
10:26:44 <ertes-w> @let cFinally c = Codensity (\k -> k () `finally` c)
10:26:45 <lambdabot>  Defined.
10:26:46 <ertes-w> :t cFinally
10:26:47 <lambdabot> IO b -> Codensity IO ()
10:26:50 <shapr> Rotaerk: I'm gonna say that to my girlfriend today.
10:26:54 <Rotaerk> heh
10:27:01 <ertes-w> now cFinally is a way to "register" an IO action that should run *after* the lowerCodensity block
10:27:15 <shapr> Rotaerk: do you have a twitter account?
10:27:18 <ertes-w> MitchellSalad_: in reverse order of "registration"
10:27:20 <Rotaerk> nope
10:27:23 <shapr> aw, ok
10:27:23 <MitchellSalad_> ah, that makes sense
10:27:38 <ertes-w> uh, no
10:27:57 <shapr> ertes-w: wow that's cool, are there already blog posts on this kind of thing?
10:27:58 <ertes-w> uh, it's a matter of perspective =)
10:28:04 <shapr> I'd enjoy comparing it to python's "with"
10:28:26 <MitchellSalad_> shapr: i think gabriel gonzales has blogged about Managed a few times
10:28:29 <ertes-w> shapr: gabriel gonzalez has probably written something
10:28:51 <shapr> aha: http://www.haskellforall.com/2013/06/the-resource-applicative.html
10:28:55 <ertes-w> his 'managed' library is basically (Codensity IO) with the constructor hidden, so that you can't construct certain branching effects
10:29:36 <MarcelineVQ> ertes-w: got a similar talk for machines? :>
10:30:34 <ertes-w> MarcelineVQ: hmm?
10:30:51 <ertes-w> MarcelineVQ: a machine sales pitch?
10:30:55 <ertes-w> *machines
10:31:12 <MarcelineVQ> yeah if you have one
10:31:55 <ertes-w> MarcelineVQ: i'd say that machines can do branching, but that would be pointless, because i've never actually used that feature =)
10:32:34 <ertes-w> MarcelineVQ: here is one: you know how the 'free' library has a clear separation between church encoding (for efficiency) and algebraic encoding (for layer-by-layer inspection)?
10:32:52 <MarcelineVQ> not intimately but I follow you
10:33:00 <ertes-w> 'machines' does the same for stream processors
10:33:10 <ertes-w> that's the PlanT vs. MachineT deal
10:33:47 <MitchellSalad_> ertes-w: so do you use Codensity for anything besides inverting control of resource allocation functions?
10:34:06 <MitchellSalad_> seems useful but I don't often acquire so many resources that growing down-and-to-the-right is unmanageable
10:35:06 <ertes-w> MitchellSalad_: on some occasions i have used it's branching effect, but most of the time resource management is the only thing i use it for
10:35:32 <MitchellSalad_> how do you use its branching effect?
10:35:34 <ertes-w> MitchellSalad_: Codensity is particularly useful when the resource size is variable
10:35:52 <MitchellSalad_> ah, that's true
10:36:23 <ertes-w> as <- traverse (Codensity . withAsync) […]
10:36:24 <ertes-w> something like that
10:36:29 <MitchellSalad_> yeah, i gotcha
10:36:37 <ertes-w> that's incredibly useful (and incredibly ugly without Codensity)
10:36:43 <MitchellSalad_> indeed
10:38:17 <ertes-w> MitchellSalad_: you use the continuation multiple times
10:38:39 <ertes-w> :t Codensity (\k -> k () >> k ())
10:38:40 <lambdabot> Monad m => Codensity m ()
10:38:51 <ertes-w> everything after this action will run twice
10:38:57 <ertes-w> much like in a list monad
10:40:43 <MitchellSalad_> yah...
10:40:59 <ertes-w> @let forEach xs = Codensity (\k -> foldr1 (\x go -> k x >> go) xs)
10:41:00 <lambdabot>  .L.hs:179:32: error:
10:41:00 <lambdabot>      • Couldn't match expected type ‘m b’ with actual type ‘a’
10:41:00 <lambdabot>          because type variable ‘b’ would escape its scope
10:41:19 <ertes-w> you get the idea (the continuation *must* be used, but it can be used as often as you want)
10:41:19 <MitchellSalad_> gotta end with 'k', since it's polymorphic in the return type =P
10:41:40 <MitchellSalad_> yeah I get the idea, I'm just curious how people use this beast
10:42:30 <MitchellSalad_> using the continuation multiple times is not that interesting IMO
10:42:50 <ertes-w> it is, once you combine it with "after effects" =)
10:43:17 <MitchellSalad_> so, in edwardk
10:43:29 <MitchellSalad_> 's example, he does use 'k' twice, but in different <|> branches...
10:43:42 <MitchellSalad_> what "after effects"? :)
10:44:01 <ertes-w> :t cFinally
10:44:03 <lambdabot> IO b -> Codensity IO ()
10:44:04 <ertes-w> ^ that
10:45:33 <nshepperd> @let cChoose xs = Codensity (\k -> foldr (<|>) empty (map k xs))
10:45:35 <lambdabot>  Defined.
10:45:40 <nshepperd> :t cChoose
10:45:41 <lambdabot> Alternative m => [a] -> Codensity m a
10:46:15 <MitchellSalad_> that's the list monad
10:46:21 <MitchellSalad_> wearing a funny hat
10:46:27 <nshepperd> hehe
10:47:13 <MitchellSalad_> ertes-w: so how would you combine cFinally with multiple invocations to 'k' to get something "interesting"?
10:50:10 <ertes-w> MitchellSalad_: cFinally "knows" that it's in a branch…  if you use it below/"after" a branch, it will actually work correctly
10:50:25 <ertes-w> something that isn't easy to encode with a list transformer
10:50:55 <ertes-w> and yeah (<|>) can be useful, too
10:51:13 <ertes-w> for example you can use it for parsers…  if something is found in the input here, we request that it will also be followed by something
10:51:17 <jakub> does there exist a tutorial on how to use quickcheck together with cabal test-suite?
10:52:28 <ertes-w> MitchellSalad_: inParens o c = Codensity (\k -> (char o *> k () <* char c))
10:52:57 <ertes-w> here comes the interesting part:  inParens '(' ')' <|> inParens '{' '}'
10:53:12 <ertes-w> everything that follows inParens is either in (parens) or {braces}
10:53:53 <tempeh> anyone think a reddit comment bot version of lambdabot would get some use? thought it might be a fun project
10:54:08 <pikajude> what would it do
10:54:19 <ertes-w> MitchellSalad_: (<|>) is defined like this:  Codensity f1 <|> Codensity f2 = Codensity (\k -> f1 k <|> f2 k)
10:54:46 <tempeh> same thing it does here. maybe it keeps some state throughout comment threads
10:55:07 <ibrahims> hello, is there a way to listen for document keyboard events with reflex?
10:56:02 <ertes-w> ibrahims: if you don't get an answer here, ask in #reflex-frp
10:56:12 <adamCS> ibrahims: Yes, I think so.  That question is better asked in #reflex-frp.  And if you look back over the history there, I think you'l find an answer.
10:56:22 <ibrahims> thank you!
10:56:39 <ertes-w> ibrahims: (minor nitpick: that's a reflex-dom question, not a reflex question) =)
10:57:06 <ibrahims> haha :) good to know.
10:57:29 <saylu> Hey folks -- I'm trying to build `cairo` and getting some odd failures. I'd appreciate if anyone could take a quick look -- I've documented what's going on here:
10:57:30 <saylu> https://stackoverflow.com/questions/44314060/haskell-stack-nix-build-fails-requiring-pkg-config-0-9-0-and-cairo-1
10:59:41 <MitchellSalad_> ertes-w: interesting example, though it doesn't really look like a parsec parser, for example. ('inParens :: Char -> Char -> Parser ()' ... versus the more familiar 'inParens :: Char -> Char -> Parser a -> Parser a')
10:59:51 <Unode> @let import Data.Conduit.Combinators as CC
10:59:52 <lambdabot>  .L.hs:84:1: error:
10:59:52 <lambdabot>      Failed to load interface for ‘Data.Conduit.Combinators’
10:59:52 <lambdabot>      Use -v to see a list of the files searched for.
11:00:31 <ertes-w> MitchellSalad_: let me write a small example
11:00:36 <MitchellSalad_> sure =D
11:00:48 <Unode> Can someone clarify how to use the 's' argument in the signature of (for instance): CC.mapAccumWhile :: Monad m => (a -> s -> Either s (s, b)) -> s -> ConduitM a b m s
11:01:10 <MitchellSalad_> I get how it works, I just meant that the "combinator" version of inParens has a far more intuitive type
11:01:29 <MitchellSalad_> it clearly modifies the input parser, rather than looking like a weird no-op line that magically affects the remainder of the do-block
11:01:55 <Unode> I'm having difficulties understanding this because most fusion arguments expect something like: ConduitM a b m ()
11:02:39 <Unode> in other words, I don't what functions I can add after a CC.mapAccumWhile
11:03:14 <cocreature> Unode: the last parameter of ConduitM is the thing that you get out of the ConduitM once “it has finished executing”
11:03:15 <MitchellSalad_> Unode: you could 'void' the result
11:03:45 <cocreature> Unode: e.g. if you execute the conduit using "runConduit" you’ll get that value back
11:03:45 <MitchellSalad_> 'void (CC.mapAccumWhile step initial)' :: ConduitM a b m ()
11:04:05 <ertes-w> MitchellSalad_: yeah, you really need to get into the codense comindset, and that can require a bit of ncentration the first few times =)
11:04:09 <Unode> cocreature: that's the tricky part, even the simplest case I managed to write doesn't validate the types.
11:04:13 <Unode> Let me paste the full code
11:07:29 <hexagoxel> is there a HList library that works on ghc-8?
11:10:56 <Unode> cocreature: http://dpaste.com/3NWHT06 something like this
11:11:41 <Unode> http://dpaste.com/06B6HGT with proper haskell highlight.
11:12:01 <Unode> and pardon the messy imports
11:12:13 <cocreature> Unode: what’s the error?
11:12:57 <MitchellSalad_> it's that the action isn't 'IO ()'
11:13:13 <MitchellSalad_> so just ignore the resulting Int :)
11:13:17 <cocreature> that’s definitely one error but I’m not sure if that’s the only one
11:13:41 <Unode> http://dpaste.com/0QY88ER with the errors
11:14:40 <Unode> MitchellSalad_: how do I go about ignoring the Int?
11:15:04 <MitchellSalad_> oh, there's a more complicated error in there... hrm, gonna have to dig around conduit for a bit
11:15:11 <cocreature> Unode: what do you hope to achieve with mapAccumWhile here? you’re just using a pure function and ignoring the result (or rather you’re not explicitely ignoring it) so it doesn’t seem to do anything useful
11:15:24 <MitchellSalad_> that too
11:16:02 <MitchellSalad_> if by "result" you mean the ByteStrings
11:16:15 <cocreature> yes and the Int
11:16:30 <Unode> cocreature: this started as me trying to group chunks together. I then thought that I could use mapAccumWhile and tried to use it, failed and realized my understanding of the conduit arguments was still limited so I went after that first.
11:16:43 <Unode> The initial problem is (grabbing the full code):
11:17:24 <cocreature> Unode: ConduitM a b m r consumes a stream of "a"s, outputs a stream of "b"s and when it’s finished it will give you back an "r"
11:18:14 <cocreature> Unode: using runConduit requires that there are no unconnected inputs and outputs. this means the input has to be () and the output has to be Void
11:19:12 <cocreature> Unode: but mapAccumL is producing outputs that are not connected to anything so that’s why you’re getting the error
11:19:37 <cocreature> Unode: In addition to that you are ignoring the result value but you could just throw that away using "void" or even change the type signature of "main".
11:19:55 <cocreature> Unode: but using mapAccum and ignoring outputs and the result is a useless operation
11:20:12 <cocreature> in the same sense that running a pure function and ignoring it’s result is useless
11:20:25 <Unode> http://dpaste.com/205BMKS the full code but incomplete.
11:21:35 <Unode> The intention is to read 4 lines at a time from the given input file, check the size of these 4 lines (in bytes) and if above a given value, increment 'ix' which would send the data to a different output file (sink)
11:22:33 <MitchellSalad_> can you paste the type errors as well?
11:22:40 <cocreature> what is GHC supposed to do after “ByteCodeGen”? I was trying to add servant-auth to my project and now GHC seems to just hang (literally for minutes) after that phase https://gist.github.com/cocreature/55ee4cd1c1a3481cc0f5099934056c83
11:22:47 <Unode> MitchellSalad_: one moment
11:22:55 <cocreature> the file still contains holes so it shouldn’t even compile
11:23:38 <Unode> http://dpaste.com/1K5YHZS
11:24:08 <Unode> cocreature: yes, it doesn't but I don't know how to fill the gaps.
11:24:52 <Lokathor> just wondering
11:25:34 <Unode> cocreature: mostly if I drop the use of mapAccumWhile things work, but then I get 4 lines on each file, which is not exactly what I want.
11:25:35 <Lokathor> if you have to apply a series of 1 location at a time updates to a vector, would mapping a series of transform funcs that only actaully transform the location in question over and over be effective?
11:25:39 <Lokathor> with fusion, and such
11:26:29 <Lokathor> oops, looks like there's already what i want in here, (//)
11:28:21 <Unode> http://dpaste.com/3E8EFX3 is a working version with 4 lines per output
11:31:44 <pie_> where can i buy haskell flavored koolaid
11:31:52 <maerwald> only illegaly
11:32:04 <maerwald> ask your local dealer
11:32:07 <MitchellSalad_> Unode: that code doesn't compile
11:32:26 <Unode> MitchellSalad_: the last one?
11:32:38 <MitchellSalad_> ya
11:32:55 <Unode> odd, works here. Let me repaste.
11:33:01 <MitchellSalad_> sorry, my fault, clipboard fail
11:33:15 <cocreature> Unode: so the the thing that you want to change is that it only outputs those 4 lines if the size is above a given value? what should it do if that isn’t the case? should it combine multiple groups of 4 lines until their combined size is over the threshold or should it just throw them away?
11:34:05 <Unode> MitchellSalad_:  http://dpaste.com/12E8A3R
11:34:35 <Unode> I'm also doing block copy which leaves trailing spaces.
11:36:36 <Unode> cocreature: what I want to get at is 1) read 4 lines at a time - 2) compute the size of the 4 lines and accumulate - 3) if accumulated is larger than a given value start writing to a new file
11:37:16 <Unode> cocreature: no line should be thrown away, which makes me think that mapAccumWhile isn't the right function for the job, but that was me trying to find a way.
11:37:58 <MitchellSalad_> Unode: Your monad stack could include 'State', as in 'ConduitM a b (StateT IO) r'
11:38:20 <MitchellSalad_> err, with a state in there
11:38:29 <cocreature> Unode: mapAccum doesn’t work because it requires that you can emit something at each iteration. the “wait until I have reached a certain size” does not work here
11:38:42 <Unode> MitchellSalad_: I'm still not familiar with State, but I take it that would just replace the accumulator I was trying to get at?
11:40:29 <Unode> cocreature: I tought the 'emit' would be the Either returning Right. But I didn't get how this Either gets used 'outside' the function. The function itself is still in the pipeline so... this is one of the missing points.
11:41:07 <Unode> cocreature: can you rephrase 'emit' into other words? I mean, would would this look like?
11:41:16 <cocreature> Unode: but you need to return Right at every step, returning Left means it stops.
11:41:36 <Unode> and stopping means the pipeline ends right?
11:41:47 <cocreature> Unode: a conduit takes a stream of input values and outputs a stream of output values. my “emit” I mean outputting a single output value
11:42:18 <cocreature> it stops the mapAccum conduit and (.|) takes care of stopping everything
11:42:25 <Unode> cocreature: so if I managed to get mapAccum working (types matching and compiling) I would end up with 1 file only?
11:43:08 <cocreature> well it depends on what you mean by “working”. implementing the semantics that you want is just not possible with mapAccum
11:43:19 <cocreature> you could either return garbage or you could exit early
11:43:26 <cocreature> neither of which seems like a good idea
11:44:42 <Unode> ok so lets put the initial goal aside so as to make sure I understand that 'r' in the type definition. So 'r' is only used/returned by the runConduit function, correct?
11:45:02 <MitchellSalad_> Unode: not quite
11:45:03 <Unode> or runConduitRes in this case
11:45:19 <cocreature> the "r" is the return value that you get once your conduit has finished executing
11:45:37 <cocreature> runConduit is one way to access it but you can also just combine conduits using do notation and get the return value that way
11:46:05 <cocreature> gnah, I can’t even check if I can reproduce my bug using 8.2 because servant is not compatible with 8.2
11:46:07 <cocreature> *sigh*
11:46:20 <Unode> ok I'm not familiar with the do syntax in this context but I think I get the idea.
11:46:36 <MitchellSalad_> Unode: You are familiar with do-notation in general, yeah?
11:46:46 <cocreature> Unode: you’re already using it in splitC' :)
11:47:04 <cocreature> e.g. C.peek
11:47:11 <cocreature> r is Maybe a in that case
11:47:54 <Unode> So if as part of my pipeline, more than one step produces a result, does that mean .| is the wrong operator? I noticed there's fuseBoth which I managed to get to work in one case but I didn't give it enough attention to understand what was happening to the different 'r's
11:48:21 <Unode> MitchellSalad_: I get the gist of it. So yes but a shaky one. Needs more practice.
11:48:43 <cocreature> a .| b only typechecks when a returns (), i.e., only has a trivial return value
11:48:54 <MitchellSalad_> Unode: it depends on exactly what sort of "pipeline" (program) you are trying to put together
11:49:33 <MitchellSalad_> Unode: A 'ConduitM a b m r' is a value that represents the ability to do four things...
11:49:55 <Unode> cocreature: right, in the splitC' case, I don't fully understand what happens with the output of CC.take 4. There's the indentation but I think it's misleading there.
11:50:22 <MitchellSalad_> 1) receive 'a's from some anonymous upstream, 2) emit 'b's to some anonymous downstream, 3) perform any arbitrary 'm' computation, and 4) stop doing all of that forever by making exactly one 'r'
11:50:51 <Unode> emit == yield ?
11:51:05 <MitchellSalad_> You can stitch together pipelines "vertically" (one consumes what the other emits), or "horizontally" (when one ends with an 'r', the next begins)
11:51:09 <MitchellSalad_> yah, emit = yield
11:51:54 <Unode> ok the vertical I understand. The horizontal... do you mean different pipelines/conduits ?
11:52:20 <MitchellSalad_> Say you have one 'Conduit A B IO Int'
11:52:54 <MitchellSalad_> and a function that, when given an 'Int', returns a 'Conduit A B IO ()'
11:53:11 <Unode> ok
11:53:30 <MitchellSalad_> you can compose them into one super-conduit that runs the first one until it's exhausted (and gives back an Int), then using this Int as input to the function that returns another conduit of the same type
11:53:41 <MitchellSalad_> (That's just >>=)
11:54:00 <Unode> o.k. I need to digest that.
11:54:10 <MitchellSalad_> now you've got a 'Conduit A B IO ()' in your hands, and no one has to know that it was secretly constructed using two smaller conduits
11:54:22 <Unode> I see
11:54:51 <MitchellSalad_> oops, I wrote 'Conduit' where I mean 'ConduitM'
11:55:13 <cocreature> I find the Conduit type synonym really confusing
11:55:18 <cocreature> it still has an "m" argument
11:55:33 <Unode> ConduitM for monadic I guess
11:55:42 <MitchellSalad_> I don't even remember what it is, I've never actually used Conduit :P
11:55:43 <cocreature> but Conduit is just as monadic
11:55:47 <cocreature> MitchellSalad_: me neither :P
11:55:53 <MitchellSalad_> but the basics are all the same as Pipes which I've used a bit
11:56:02 <cocreature> MitchellSalad_: we’re obviously the right people to answer condiut questions :)
11:56:13 <MitchellSalad_> obviously!
11:56:15 <johnw> i've used conduit a fair bit
11:56:17 <johnw> what was the question?
11:56:34 <Unode> Coming from the python world I kind of read this as async and generators (yield).
11:56:53 <Unode> hi johnw, the work-in-progress code: http://dpaste.com/12E8A3R
11:57:31 <MitchellSalad_> cocreature: where is the Conduit type alias?
11:57:42 <johnw> Unode: ok, and the question?
11:57:46 <cocreature> MitchellSalad_: https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#t:Conduit
11:58:05 <Unode> the goal is to read a file 4 lines at a time, keep track of the size (in bytes) of the lines read and if a given number is reached, close the sink and start writing to another file.
11:58:11 <cocreature> MitchellSalad_: I mean I get what it does, that’s easy. I just find the naming really weird
11:58:12 <MitchellSalad_> oh, right at the top. Whoa that's weird. Moves around the type variables... wat
11:58:21 <johnw> Unode: yes, that should be fairly easy to do with conduit
11:58:26 <cocreature> it moves around the type variables and sets r to ()
11:58:43 <Unode> johnw: the question was what the 'r' in 'ConduitM a b m r' was all about and why couldn't I get it to work with mapAccumWhile.
11:58:50 <johnw> r is the final result
11:59:07 <johnw> also, you'll want your sink to be part of your state here, not something you connect to via the pipeline
11:59:27 <johnw> you can't disassemble and reassemble the pipeline at runtime like that
11:59:28 <Unode> yeah that's more or less what MitchellSalad_ was hinting at.
11:59:35 <johnw> but you can feed data to an arbitrary sink functionally
11:59:36 <Unode> ok
11:59:56 <johnw> in your case, r is probably going to be ()
12:00:24 <Unode> johnw: the code I pasted uses that to increment the sink name (basename ++ show index) which currently happens every 4 lines.
12:00:44 <johnw> I don't think you can "use" 'r' for something
12:00:49 <johnw> if you have an 'r', it means your pipeline has ended
12:01:06 <johnw> it's like the exit code from a process
12:01:32 <Unode> johnw: ok that actually makes sense. So in other words, mapAccum and mapAccumWhile can only be final steps in a pipeline?
12:02:16 <johnw> based on their type, they can be intermediate
12:02:16 <MitchellSalad_> johnw: you can "use" r in >>=, :P
12:02:18 <Unode> CC.mapAccumWhile :: Monad m => (a -> s -> Either s (s, b)) -> s -> ConduitM a b m s
12:02:24 <johnw> they just give you the option of short-circuiting the pipeline
12:02:37 <johnw> MitchellSalad_: I meant, use it "within" the pipeline that produces it
12:02:54 -RSSBot[thekyriar(nebrssb60@gateway/shell/matrix.org/x-bxlxnjsyczjfyfmn)- Planet Haskell posted a new article: Lambdaman meets Spider-Moy ( http://wadler.blogspot.com/2017/06/lambdaman-meets-spider-moy.html )
12:02:55 -RSSBot[thekyriar(nebrssb60@gateway/shell/matrix.org/x-bxlxnjsyczjfyfmn)- Planet Haskell posted a new article: PureScript/React Front-End Developer at CollegeVine (Full-time) ( https://functionaljobs.com/jobs/9018-purescript-react-front-end-developer-at-collegevine )
12:03:11 <Unode> johnw: so you can't CC.mapAccumWhile func acc .| something_else right?
12:03:17 <johnw> sure you can
12:03:26 <johnw> as long as no one returns Left s, your pipeline will keep on going
12:05:02 <kadoban> Is that bot thing going to be sticking around? :-/
12:05:18 <Unode> johnw: I didn't manage to figure out how. The type signatures failed because mapAccumWhile was returning type C.ConduitM B.ByteString B.ByteString m1 Int where C.ConduitM B.ByteString B.ByteString m1 () was expected.
12:05:43 <johnw> Unode: just use void on it
12:05:57 <johnw> void <$> myAccumValue
12:05:57 <Unode> johnw: Don't know what that means (still a newbie)
12:06:04 <johnw> it's a monadic action
12:06:10 <johnw> you can bind and ignore the result, to make the types match
12:06:40 <Unode> johnw: where you this go? as part of the pipeline?
12:06:45 <johnw> sure
12:06:59 <Unode> can you show an example? I don't really see it.
12:07:06 <johnw> (void (CC.mapAccumWhile func acc))
12:07:37 <Unode> lets say: C.lines .| C.unlinesAscii .| CC.mapAccumWhile func acc ...?
12:08:11 <Unode> instead do: C.lines .| C.unlinesAscii .| void (CC.mapAccumWhile func acc) ...?
12:08:21 <johnw> yep
12:08:28 <johnw> if all you really need is to change the result type
12:09:53 <Unode> I see it now f a -> f ()
12:10:18 <Unode> I did search (hoogle) for ConduitM a b m r -> ConduitM a b m () but no luck there.
12:11:11 <Unode> ok thanks, I think I have enough to keep going further. Thanks MitchellSalad_ cocreature and johnw .
12:12:02 <Unode> I'll paste the result once I get it, or more questions if I get stuck again :)
12:12:12 <Unode> thanks again!
12:13:49 <MitchellSalad_> no problem!
12:16:37 <LAZAR> how can i turn an expression into point free notation?
12:16:46 <LAZAR> (automatically)
12:16:48 <maerwald> LAZAR: ?
12:16:56 <johnw> you can use @pl
12:17:00 <johnw> usually via /query lambdabot
12:17:03 <LAZAR> well there has been some way to use the bot here
12:17:08 <LAZAR> ah thanks
12:17:11 <maerwald> don't use @pl if you can't figure it out by yourself
12:17:25 <LAZAR> can you give an example?
12:17:39 <LAZAR> before i spam the whole channel by wrong bot commands
12:17:50 <maerwald> query the bot
12:17:57 <MitchellSalad_> @pl \x -> f (g x)
12:17:57 <lambdabot> f . g
12:18:45 <LAZAR> @pl  \x -> map (2*) [1..10]
12:18:45 <lambdabot> const (map (2 *) [1..10])
12:18:52 <LAZAR> interesting
12:19:26 <LAZAR> @pl  \x -> map (x*) [1..10]
12:19:27 <lambdabot> flip map [1..10] . (*)
12:19:57 <LAZAR> isnt [1..10] technically a parameter? even if constant
12:20:17 <MitchellSalad_> nope!
12:20:28 <LAZAR> why is it not?
12:21:55 <MitchellSalad_> heh, I keep trying to say why not and all I can come up with are tautologies. It's not a parameter to the function because it's not a parameter to the function
12:22:30 <LAZAR> well isnt anything in a point free expression a function?
12:22:33 <MitchellSalad_> no matter what 'x' you pass to the function, it always maps over [1..10]
12:22:36 <LAZAR> xD
12:22:42 <MitchellSalad_> hmm?
12:23:00 <LAZAR> MitchellSalad_: thats true its not a variable or parameter but a constant... are constants allowed in point free?
12:23:29 <LAZAR> @pl  \x -> mapM_ print [1..10]
12:23:29 <lambdabot> const (mapM_ print [1..10])
12:23:51 <LAZAR> @pl  \x -> f (g (h x))
12:23:51 <lambdabot> f . g . h
12:24:00 <johnw> LAZAR: /query lambdabot is your friend :)
12:24:14 <LAZAR> Whats the diff between query and @pl?
12:24:25 <johnw> you say @pl inside the /query
12:24:31 <johnw> it keeps it private between you and lambdabot
12:24:36 <peacememories> hi everyone. does anyone use a haskell formatter other than stylish-haskell? i think it does too little to enforce style, i'd rather have something of the calibre of elm-format
12:24:40 <LAZAR> oh lol im sorry
12:24:45 <maerwald> LAZAR: look up an IRC tutorial
12:26:35 <lambdamu_> peacememories: there is hindent which use on some projects and recently brittany which looks good, too
12:26:56 <peacememories> lambdamu_ thanks, i'll look into those :)
12:47:57 <TommyC> Hello, so I've made an InnerProduct class and I think it meets all the requirements of an inner product but I'm wondering if anybody can give me a specific inner product to test?
13:30:38 * hackage hackernews 1.2.0.0 - API for Hacker News  https://hackage.haskell.org/package/hackernews-1.2.0.0 (DavidJohnson)
13:52:32 <Tuplanolla> Is lpaste down?
13:53:43 <brachiel> Tuplanolla: looks down for me
13:57:32 <dmwit> TommyC: The question as it stands is a bit vague.
13:57:55 <dmwit> TommyC: You could walk down https://en.wikipedia.org/wiki/Inner_product_space#Examples for example...
14:31:40 <Philonous> EvanR, Thanks for your book recommendation, it's exactly what I was looking for :)
14:48:30 <TommyC> dmwit: thank you
14:50:21 <orion> In attoparsec the docs (https://www.stackage.org/haddock/lts-8.16/attoparsec-0.13.1.0/Data-Attoparsec-ByteString-Char8.html#v:manyTill-39-) say the following: "(Note the overlapping parsers anyChar and string "-->". While this will work, it is not very efficient, as it will cause a lot of backtracking.)"
14:50:49 <orion> What is a more efficient way to implement scanning for comments, as opposed to what they did in the docs?: simpleComment   = string "<!--" *> manyTill' anyChar (string "-->")
14:58:38 <c_wraith> it will only cause backtracking if you have a lot of '-' characters in the input. 
14:59:58 <c_wraith> and to really do better, you should separate lexing from parsing. 
15:06:35 <orion> Is it frowned upon to do lexing within a Parser?
15:08:45 <Krimson_Soul> Hai
15:09:02 <glguy> orion: It better to do it separately if the language allows
15:09:17 <Krimson_Soul> Hello everyone
15:09:27 <Krimson_Soul> Found my first chat
15:09:36 <orion> glguy: Currently I have a Parser Foo, inside of which I do, say: foo <- anyChar `manyTill'` (char '_'), then case foo of "Blah" -> return Blah
15:10:15 <glguy> Krimson_Soul: Cool. What're you doing with Haskell?
15:10:19 <orion> It works, but is it a code smell?
15:10:39 <Krimson_Soul> I have no idea tbh
15:10:48 <glguy> orion: I don't know, I mostly refuse to use that term
15:11:01 <Krimson_Soul> I've never used a site like this and I have no idea why I'm here either
15:11:03 <Krimson_Soul> lmao
15:11:19 <glguy> Krimson_Soul: OK, well if you decide to learn Haskell feel free to come back with questions
15:11:20 <Drakonis[m]> code smell? i saw that on hacker news
15:11:40 <Drakonis[m]> HN is weird
15:11:50 <Krimson_Soul> Okie thank you
15:12:38 <Krimson_Soul> Actually here's one: what is this chat and why is it popular?
15:13:42 <glguy> Krimson_Soul: I'm for the Haskell programming language. YOu can learn more here https://www.haskell.org/ . It's popular because it's a popular language and people like to discuss it.
15:14:01 <Krimson_Soul> ohhhhhh
15:14:24 <Drakonis[m]> buddy, its irc on freenode
15:14:50 <Drakonis[m]> popular channels are either distros or languages
15:15:09 <Drakonis[m]> and other operating systems
15:16:30 <Krimson_Soul> So basically this is a chat made for the discussion and teaching of the haskell computer language? 
15:17:28 <glguy> Yes.
15:17:36 <Krimson_Soul> Coolio
15:18:18 <Krimson_Soul> I had actually looked up chats with the context of memes and yeah this is it
15:18:40 <Krimson_Soul> So I guess I shouldn't be here after all
15:21:54 <EvanR> not unless you want your mind blown
15:22:03 <EvanR> on a regular basis
15:22:31 <Krimson_Soul> I want my mind blown
15:22:37 <Krimson_Soul> Go ahead, surprise me
15:23:05 <n_blownapart> Krimson_Soul, starfish and coffee
15:23:08 <EvanR> > 2 + 2
15:23:10 <lambdabot>  4
15:23:23 <user23432> regarding parametricity; I know the id function is parametric, but also isn't a function that returns the memory address?
15:23:40 <user23432> *fully parametric
15:23:47 <Drakonis[m]> visit the wiki
15:23:57 <Drakonis[m]> it has a page on blowing minds
15:24:20 <Drakonis[m]> https://wiki.haskell.org/Blow_your_mind
15:26:05 <Krimson_Soul> Dragon which wiki?
15:26:16 <Drakonis[m]> see this
15:26:39 <Drakonis[m]> i'll let that slide because its the inspiration
15:27:01 <user23432> I am reading the haskell book and got to the section on parametricity
15:27:14 <user23432> hence wondering if a memory address function counts
15:27:22 <Drakonis[m]> see the link 5 lines above
15:27:54 <EvanR> returns the memory address of what
15:28:07 <user23432> EvanR: of the object in memory
15:28:16 <user23432> you pass a type in, it gives you the address of the object
15:28:18 <EvanR> do you mean, pure?
15:28:20 <user23432> you could pass anything int
15:28:21 <user23432> *in
15:28:30 <EvanR> rather than parametric
15:29:11 <EvanR> the type of a function that can do that would be something like memoryAddr :: IsLocated a => a -> MemoryAddr
15:29:16 <EvanR> not a -> a
15:29:17 <user23432> I mean parametric polymorphism
15:29:22 <user23432> as opposed to ad-hoic
15:29:25 <user23432> *hoc
15:29:43 <EvanR> the IsLocated constraint there makes it ad hoc
15:30:13 <exio4> user23432: if you have a function f : ∀a. a -> Word64, you can't do something different for every type or so
15:31:42 <EvanR> a function Int -> Word64 which returns different things for the same Int value would not be an actual function
15:31:49 <EvanR> is another issue with this idea
15:32:53 <EvanR> f(2) = 0x000000194fc38 right now, f(2) = 0x000000184384cea9 perhaps later
15:33:02 <EvanR> not a very good function
15:35:09 <EvanR> i am led to believe that this function does not work "any type a" but only on type "memory objects"
15:36:52 <hanna> Has it ever been proposed to add [] as a defaultable type for a Foldable constraint?
15:37:06 <hanna> Just ran into the issue where (c :: Char) `elem` "foobar" fails typechecking out of the box with OverloadedStrings
15:37:12 <hanna> because `elem` is Foldable-polymorphic
15:37:37 <EvanR> OverloadedStrings tends to cause that
15:37:51 <hanna> thing is that this is a regression because `elem` used to be []-specific
15:38:10 <EvanR> youre trying to overload strings, but make String the default
15:38:31 <hanna> Essentially, yes
15:38:37 <EvanR> i can see someone taking issue with that
15:38:49 <EvanR> because they want Text to be the default
15:39:01 <hanna> Defaulting rules only apply when GHC can't solve a constraint due to ambiguous type variables
15:39:11 <EvanR> right
15:39:17 <hanna> So adding them seems like a harmless operation to me since they can't break existing code, they can only make strictly more programs compile out of the box
15:39:37 <hanna> in this case I'm specifically targeting `elem` which used to be list-specific
15:39:37 <EvanR> OverloadedStrings when enable would break existing code
15:39:38 * hackage libvorbis 0.1.0.2 - Haskell binding for libvorbis, for decoding Ogg Vorbis audio files  https://hackage.haskell.org/package/libvorbis-0.1.0.2 (StephenBlackheath)
15:39:41 <hanna> OverloadedStrings is a red herring
15:39:54 <n_blownapart> what's the dead easiest way to get haskell syntax-highlighting and some basic features in vim?
15:39:58 <hanna> If I was using overloadedstrings with Text, I would be using T.elem and not Prelude.elem
15:40:03 <hanna> because Text is also not Foldable
15:40:21 <Tuplanolla> The default settings, n_blownapart?
15:40:29 <Tuplanolla> Just `syntax on`.
15:40:37 <Krimson_Soul> memes
15:40:42 <Krimson_Soul> mem
15:40:44 <Krimson_Soul> me
15:40:46 <Krimson_Soul> m
15:40:48 <Krimson_Soul> me
15:40:50 <Krimson_Soul> mem
15:40:52 <Krimson_Soul> meme
15:40:59 <hanna> It just seems like adding a default Foldable [] rule would have made the prelude generalization of Foldable functions a bit less likely to break stuff
15:41:00 --- mode: ChanServ set +o johnw
15:41:00 --- mode: johnw set +b *!43e741c3@gateway/web/freenode/ip.67.231.65.195
15:41:00 --- kick: Krimson_Soul was kicked by johnw (Kicked)
15:41:00 --- mode: johnw set -o johnw
15:41:12 <hanna> generalization of list functions *
15:41:35 <EvanR> :t (undefined :: Char) `elem` 'f':'o':'o':'b':'a':'r':[]
15:41:36 <lambdabot> Bool
15:41:48 <EvanR> seems like an overloadedstrings issue
15:42:08 <EvanR> :t elem
15:42:10 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
15:43:07 <n_blownapart> Tuplanolla, I tried hard to use haskell vim now , and the author is helping me with an issue. meantime, can one set up neovim/vim-haskell easily? I don't anything about vim except some basic navigation 
15:43:21 <n_blownapart> *know
15:43:27 <Tuplanolla> I use it without any extensions, n_blownapart.
15:43:32 <EvanR> if you enable vim syntax at all, it will highlight haskell
15:43:55 <hanna> EvanR: I still think OverloadedStrings is a red herring
15:43:59 <Tuplanolla> All Vim does is become unreliable when you add things to it.
15:44:04 <hanna> The fundamental issue is that `elem` used to force [] but no longer does
15:44:13 <hanna> (The same issue could happen with OverloadedLists, to name an example)
15:44:20 <EvanR> if you put a list variable there... it would work
15:44:40 <EvanR> but "foo" isnt one,,,, because...
15:44:54 <n_blownapart> cool EvanR Tuplanolla could you just list a few commands for a barebones vim, like coloring, indenting, etc? I'm assuming there are commands beginning with ':'
15:45:08 <EvanR> there are, but you want them in your .vimrc
15:45:19 <lpaste> glguy pasted “fixes for vim haskell syntax highlighting” at http://lpaste.net/355980
15:45:23 <hanna> EvanR: Pretend I restated my question without mentioning the example at all
15:45:30 <glguy> If you're getting your vim setup, fix your syntax highlighting too ^
15:45:34 <EvanR> do you have a better example
15:45:36 <duckqlz> http://www.stephendiehl.com/posts/vim_2016.html <= Great reference for vim and haskell I usually use this link to set up a new box
15:45:46 <hanna> EvanR: Not off hand, since this is the one I ran into
15:45:55 <hanna> but I know I've run into such things before
15:46:21 <EvanR> i havent, but i usually put top level type sigs
15:46:34 <n_blownapart> glguy, et al thanks !
15:47:30 <mbw> Hello everybody. I am trying to fight my way through the gtk2hs tutorial http://www.muitovar.com/gtk2hs/chap4-5.html . Unfortunately, it addresses gtk+2, not gtk+3, so the examples need a little tweaking. The one I posted I can't get to work however. Two problems: "dialogGetUpper" is mentioned in the haddocks, but does not appear to exist. I think I have to use dialogGetContentArea. Furthermore, the line 
15:47:37 <mbw> with boxPackStart doesn't work: No instance for BoxClass Widget. So, what do I need to do here?
15:47:56 <n_blownapart> glguy, so that just all gets pasted into .vimrc ?
15:48:25 <glguy> n_blownapart: That's a diff. The original is in /usr/local (for me) but I override it by making a fixed version in ~/.vim/syntax/haskell.vim
15:48:54 <lpaste> glguy annotated “fixes for vim haskell syntax highlighting” with “fixed version” at http://lpaste.net/355980#a355982
15:49:11 <glguy> http://lpaste.net/raw/355982
15:49:19 <n_blownapart> So you just copy that into .vimrc over the default? sorry, I am not very tech savvy
15:49:23 <EvanR> n_blownapart: that customizes the syntax hilighting, you still need to configure vim to do any highlighting at all... the command is :syntax on, no : needed in .vimrc though
15:49:24 <n_blownapart> glguy, 
15:50:48 <n_blownapart> ok EvanR glguy so just paste that annotated fix and do :syntax on
15:50:52 <n_blownapart> thanks!
15:52:19 <n_blownapart> sorry glguy do I use the raw version?
15:52:53 <glguy> Do you understand what the "raw" version is?
15:53:53 <glguy> The raw version is just the pasted text and none of the surrouding web page
15:54:12 <n_blownapart> yeah there's no formatting, got it thanks
15:54:45 <n_blownapart> really appreciate it
15:57:17 <user23432> EvanR: but aren't all types memory object types?
15:57:46 <n_blownapart> ok so I installed vim again. in my home directory's hidden files I have two files: .vim and vimrc in red, which appear to be symlinks. Is this correct? .viminfo is an actual file glguy EvanR 
15:58:00 <user23432> and I thought parametricity had to do with contraints on the parameters, not whether or not a function returned a different value for the same input
15:59:07 <user23432> now that I think about it any function that takes any value, ignores the parameters and either returns nothing or some constant value would also be parametrically polymorphic
15:59:14 <user23432> unless I am missing something
15:59:47 <user23432> in other words as I currently understand it the polymorphism has nothing to do with the return types
15:59:54 <EvanR> user23432: no
16:00:38 <EvanR> user23432: a fully polymorphic function has no constraints, i.e. the forall
16:01:10 <EvanR> a function can return two different values for the same input, so you dont even get to the question if its got a polymorphic type
16:01:20 <EvanR> a function CANT return... two different values for the same input
16:01:44 <EvanR> also a function cant return nothing, it has to return something
16:01:52 <EvanR> and youre right, this function is polymorphic
16:01:58 <EvanR> const x y = y
16:02:03 <EvanR> :t const
16:02:05 <lambdabot> a -> b -> a
16:02:10 <EvanR> oh dang... const x y = x
16:02:21 <EvanR> i mean to say
16:02:31 <EvanR> alwaysZero = const 0
16:02:33 <EvanR> :t const 0
16:02:34 <lambdabot> Num a => b -> a
16:02:43 <EvanR> :t const 'x'
16:02:44 <lambdabot> b -> Char
16:02:49 <mbw> Does anybody know something about gtk3?
16:02:51 <user23432> right, polymorphic just meaning it has no constraints on the parameter types
16:03:05 <EvanR> parametrically polymorphic, at least
16:03:09 <user23432> yes
16:03:41 <user23432> but a function that has no constraints on the parameters but always returns false should also be polymorphic
16:03:58 <EvanR> :t const False
16:04:00 <lambdabot> b -> Bool
16:04:04 <EvanR> yes
16:04:05 <user23432> unless polymoyphism has something to do with the return values
16:04:48 <iqubic> What's the difference between putStrLn and print?
16:04:58 <glguy> ?src print
16:04:59 <lambdabot> print x = putStrLn (show x)
16:05:34 <pikajude> looks like the characters "(show )"
16:06:05 <EvanR> user23432: parametric, works on any type. ex. id, const False, etc
16:06:05 <iqubic> So, print doesn't expand escape sequences?
16:06:13 <pikajude> what does that mean
16:07:13 <iqubic> Like if I have the string "Hello\n Line 2" print doesn't put in any new line characters at all.
16:07:26 <EvanR> because
16:07:26 <pikajude> well, no
16:07:32 <EvanR> > show "Hello\b Line 2"
16:07:34 <lambdabot>  "\"Hello\\b Line 2\""
16:07:36 <pikajude> if you "show" a string it converts it into the string literal
16:09:11 <user23432> EvanR: yes, thank you for your help
16:09:13 <glguy> The *string literal* "x\\y" is the syntax for the string value: x\y
16:09:43 <glguy> where that x\y is literally 3 characters, there's no notion of escape sequences in string values
16:09:55 <iqubic> So if I want to take a [String] and print each element on a seperate line, what should I do?
16:10:03 <glguy> escape sequences are part of the string literal syntax 
16:10:05 <iqubic> putStrLn . unlines?
16:10:07 <pikajude> iqubic: mapM_ putStrLn
16:10:12 <pikajude> or that
16:10:18 <pikajude> either will work
16:10:20 <EvanR> mapM_ print
16:10:37 <pikajude> i believe mapM_ will be a bit faster since unlines has to create a new String value
16:10:41 <iqubic> but not print . unlines, as I was trying earlier.
16:10:55 <pikajude> yeah, that's probably not a great idea
16:11:08 <glguy> print . unlines would print the syntax for a string literal that would evaluate to the value of the argument
16:11:18 <iqubic> I know.
16:11:27 <EvanR> er misread, thought iqubic wanted to show each character on a separate line
16:11:29 <iqubic> At first I though my ghci was broken.
16:12:29 <iqubic> But then I found that putStrLn . unlines would work.
16:14:07 <iqubic> so if I have [String] which is better: putStrln . unlines, or mapM_ print or mapM_ putStrLn?
16:14:24 <glguy> Those aren't the same, so you need to decide which behavior you want first
16:14:57 <iqubic> What is different about them?
16:15:09 <glguy> That was the whole conversation so far
16:15:15 <iqubic> Oh. right.
16:15:22 <hpc> mapM_ print and mapM_ putStrLn are exactly as equal as print and putStrLn ;)
16:15:28 <iqubic> I want to use putStrLn only.
16:15:40 <iqubic> Forget that I had included print in there.
16:15:58 <hpc> this will probably sound extremely silly
16:16:07 <hpc> but are you trying to print one block of text that's organized by line
16:16:14 <hpc> or are you printing lines one after the other?
16:16:30 <iqubic> I'm trying to print a Tic-Tac-Toe board.
16:16:42 <hpc> use unlines
16:16:52 <iqubic> why do say that?
16:16:55 <hpc> it says "i am printing a single thing, and this is how i am formatting it"
16:17:18 <hpc> mapM_ putStrLn says "i am operating on numerous things, and printing is the thing i want done to them"
16:17:30 <iqubic> Yeah, I'll use unlines.
16:18:00 <hpc> (this is a subtle application of a fuzzy principle i made up for myself based on making code look like what it does)
16:18:13 <hpc> (i have gotten a lot of mileage out of it)
16:18:41 <Sonolin> +1
16:18:46 <Sonolin> haskell sure makes that easy too :)
16:19:11 <hpc> yeah
16:19:41 <hpc> i have tried explaining it in the past and people look at me like i am an impressionist or something
16:19:52 <hpc> it's a hard thing to explain
16:20:34 <Sonolin> yea for sure
16:21:27 <Sonolin> the annoyance is compounded by the fact in haskell land, most tutorials use the obscure/generic functions more than their counterparts
16:22:52 <hpc> i... have mixed feelings on that
16:23:04 <hpc> i like to err on the side of polymorphism, but i also like to write code that lives entirely in IO
16:23:36 <hpc> maybe building up from monomorphic to polymorphic is the way to teach best?
16:24:00 <hpc> teach concat first, then a few chapters later go "oh by the way, now you can use join"
16:24:44 <iqubic> :t concat
16:24:46 <lambdabot> Foldable t => t [a] -> [a]
16:24:54 <iqubic> :t join
16:24:55 <lambdabot> Monad m => m (m a) -> m a
16:24:56 <EvanR> the russians are winning the cold war, teach lens first
16:25:23 <EvanR> skip the bullshit
16:25:26 <hpc> haha
16:26:21 <hpc> i could go for something that teaches lens in an easier form than reading the haddock
16:28:31 <dmwit> hpc: Try "lenses over tea". Hit the sweet spot for me.
16:29:04 <dmwit> s/es//
16:30:03 <glguy> These are the slides from when I presented the topic https://glguy.net/LensTalk.pdf
16:30:55 * glguy wonders if we recorded that one
16:32:51 <hpc> ooh
16:35:17 <Sonolin> yea lens over tea is great
16:36:26 <hpc> i should get a website up again for haskell stuff
16:36:36 <pikajude> h.pc
16:36:49 <Eduard_Munteanu> To what extent are Haskell exceptions necessary versus transformers-based exceptions? Any discussion I should have a look at?
16:36:56 <pikajude> in IO
16:37:02 <pikajude> also async exceptions
16:37:06 <Tuplanolla> Thanks for the `pkg-config` flashbacks, pikajude.
16:37:13 <pikajude> i'm sorry Tuplanolla 
16:38:19 <monochrom> Oh w00t bourne-again Haskell Weekly News
16:38:21 <Eduard_Munteanu> Well, most IO exceptions can be dealt with by transformers. Things in pure code seem to need special treatment, though.
16:38:36 <pikajude> i don't know what you mean by dealt with by transformers
16:38:40 <pikajude> maybe i misunderstood the question
16:39:31 <Eduard_Munteanu> Let's say  IO (Either e Result) vs IO Result
16:39:34 <mbw> Does anyone know how to get the gtk2hs example found in the tutorial http://www.muitovar.com/gtk2hs/chap4-5.html to work with the gtk3 bindings? According to the documentation, the "upper part" of a Dialog should be a VBox and the getter would be dialogGetUpper. However, this function doesn't exist, only dialogGetContentArea, which unfortunately only returns a Widget, so now I'm stuck.
16:40:17 <Eduard_Munteanu> To what extent is the throw/catch machinery in GHC really necessary?
16:40:42 <Eduard_Munteanu> (assuming IO could be redesigned)
16:40:50 <pikajude> oh, you're asking about the design of the runtime itself
16:40:53 <monochrom> To the extent that getLine throws IOException rather than use ExceptT.
16:41:08 <pikajude> i can't think of a way offhand to deal with async exceptions
16:41:15 <pikajude> other than making *every single expression* return Either AsyncException a
16:41:38 <Tuplanolla> The problem is that anything may fail at anytime, Eduard_Munteanu.
16:41:48 <pikajude> hi
16:41:48 <Eduard_Munteanu> Hm, yeah, that looks like an issue.
16:41:50 <pikajude> whoops
16:42:16 <monochrom> Does ExceptT have a story for "block exceptions while running a handler"?
16:42:33 <pikajude> yeah, it has mask
16:42:38 <pikajude> at least, i remember it having mask
16:42:56 <hamishmack> mbw: I strongly recomend using gi-gtk instead of the gtk3 package
16:43:25 <hamishmack> mbw: You can see examples of dialogGetContentArea here https://github.com/haskell-gi/gi-gtk-examples/search?utf8=%E2%9C%93&q=dialogGetContentArea&type=
16:45:09 <hamishmack> mbw: If you do use the gtk3 package, I think you can use castToBox to convert the widget into a Box
16:45:11 <Eduard_Munteanu> I wonder if undefineds could be a whole class of exceptions instead.
16:45:24 <ertes> Eduard_Munteanu: every IO action can throw an exception
16:45:30 <ertes> so you would have that Either everywhere
16:45:35 <pikajude> nuh uh, "return ()" can't
16:45:39 <ertes> right
16:45:44 <ertes> every non-trivial IO action
16:45:47 <pikajude> sure
16:45:49 <pikajude> details
16:45:54 <Tuplanolla> Why not, pikajude?
16:46:00 <ertes> Tuplanolla: laws
16:46:03 <pikajude> Tuplanolla: because I said it couldn't
16:46:55 <Tuplanolla> Explain.
16:48:58 <mbw> hamishmach: Are gi-gtk and haskell-gi the same thing? Also, is there some documentation? I chose to use gtk2hs because there are at least some tutorials to get started with and it does come with haddocks... Also, thanks for the advice about the downcast
16:49:16 <Tuplanolla> My understanding was that the runtime system can give you `ENOMEM` or `EIO` at any point.
16:49:21 <nshepperd> does "return ()" allocate? if so, it can throw an async exception :)
16:49:22 <Eduard_Munteanu> I'm thinking   throw :: Exception e => e -> a   could handle exceptions for pure code
16:49:33 <Gurkenglas> In emacs with intero, using init-goto-tag on a word defined in some library does show me the source where it's defined, but trying again in there doesn't work because intero isn't booted and when it tries I get http://lpaste.net/5979333635608674304
16:49:35 <pikajude> surely GHC has a static instance of () hanging around
16:49:43 <glguy> mbw: gi-gtk has haddocks
16:50:03 <hamishmack> All the packages starting with gi- use haskell-gi to generate bindings
16:51:02 <Eduard_Munteanu> Someone should make a gobject-based library called Joe.
16:51:50 <Eduard_Munteanu> Would be fun to bind to.
16:51:51 <mbw> Ok so as an "end-user" I should use gi-gtk, not haskell-gi?
16:52:16 <Eduard_Munteanu> mbw, yes
16:52:35 <glguy> mbw: I've got a small gi-gtk project if you're interested in examples https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs
16:53:11 <mbw> glguy: Thank you very much, I shall have a look at it.
16:54:17 <mbw> Generally speaking, are there major differences in design philosophy between gtk3 and gi-gtk? Or stated differently, would it be dangerous to port gtk2hs tutorial examples for learning purposes?
16:55:01 <n_blownapart> glguy you still on?
16:55:43 <n_blownapart> do I use that syntax.vim file exactly as you have it for the decent barebones features?
16:55:59 <Eduard_Munteanu> Well, both are straightforward bindings to GTK, not much Haskell koolaid in there.
16:56:11 <glguy> That's just a minor fix to the normal syntax highlighting vim supplies for haskell, n_blownapart.
16:56:34 <glguy> gi-gtk is a low-level binding, gtk2hs tries to be a little higher level
16:56:58 <n_blownapart> thanks one moment
16:57:00 <glguy> which means that some stuff isn't exposed that you need and other stuff is wrong, and when its wrong it's hard to work around
16:57:41 <Eduard_Munteanu> You should probably have one tab open for the original GTK documentation.
16:58:02 <hamishmack> haskell-gi takes advantage of the fact that GObject introspection data is available so all the bindings are generated
16:58:54 <n_blownapart> let b:current_syntax = "haskell"   --  that last line, if that's the main switch, why do we need :syntax on for each session? glguy 
16:59:25 <glguy> n_blownapart: The syntax file has basically nothing to do with your normal settings
16:59:52 <hamishmack> There are some high level bits of Gtk2Hs that have been ported to gi-gtk and are in gi-gtk-hs
17:00:06 <n_blownapart> how do I set the syntax provided by the file on permanently?
17:00:07 <mbw> oh bow
17:00:09 <mbw> choices
17:00:13 <mbw> *boy
17:00:36 <jle`> anyone know how i can increase the history in my ghci commands
17:00:37 <hamishmack> Also most of the gtk2hs demos have been ported https://github.com/haskell-gi/gi-gtk-examples
17:01:08 <n_blownapart> glguy,  ^^
17:01:38 <mbw> If people talk about gtk in this context, what exactly do they mean? After all there's gtk/gtk+/etc.
17:01:45 <mbw> (I'm new...)
17:02:07 <hamishmack> probably Gtk+
17:02:17 <hamishmack> The C library
17:02:34 <dmwit> n_blownapart: Put `:syntax on` in your `.vimrc`, probably.
17:02:54 <monochrom> jle`: If you can find the user guide for haskeline, it's probably there.
17:03:02 <mbw> Is the C library object oriented? At first I thought it was C++, since the type signatures keep mentioning "self".
17:03:05 <EvanR> does haskell-gi come with cairo bindings
17:03:19 <mbw> Which I thought was a this pointer or something
17:03:24 <n_blownapart> << d*mwit   dmwit
17:03:39 <n_blownapart> thanks
17:03:44 <glguy> The C++ bindings are GTKmm
17:03:44 <EvanR> mbw: gtk is a short form of the projects name, gtk+
17:03:49 <monochrom> Yes I do think that gtk+ emulates OOP in C.
17:03:50 <n_blownapart> very noob I
17:04:11 <Eduard_Munteanu> n_blownapart, if 'syntax on' in ~/.vimrc isn't enough you can use vim autocommands to configure based on file extension
17:04:30 <EvanR> self is a pointer to a record of "my" instance data
17:04:32 <jle`> monochrom: thanks!
17:04:42 <EvanR> to a struct
17:04:48 <Eduard_Munteanu> e.g. au BufRead *.hs set ts=4
17:04:59 <glguy> .hs ts is 8
17:05:31 <Gurkenglas> How do I get intero to work within the ~\stack\indices\Hackage\packages that init-intero-goto-definition sends me to?
17:05:37 <mbw> Ok. One more thing, does gi-gtk work with Glade as well?
17:05:58 <Eduard_Munteanu> It should work with UIs defined with Glade, yes.
17:06:04 <jle`> ah, its default is 100 lines
17:06:05 <jle`> no wonder so short
17:06:07 <glguy> mbw: The project I shared with you uses Glade and includes a module to make it easy to use glade via GHC.Generics
17:06:35 <mbw> That's good news.
17:06:46 <hamishmack> mbw: Here is an example https://github.com/haskell-gi/gi-gtk-examples/tree/master/gtkbuilder
17:07:18 <glguy> https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs#L61-L62
17:09:50 <glguy> The record fields just have to match the names in the glade file: effHChipsOutput :: Gtk.Label
17:10:01 <ertes> Tuplanolla: the explanation is actually rather difficult without precise semantics for IO, but here is an intuition:  (pure () >> c = c), so any exception thrown by (pure () >> c) was really thrown by c
17:10:58 <Tuplanolla> Is `pure ()` guaranteed to not generate any code if there's no `c`, ertes?
17:11:02 <n_blownapart> Eduard_Munteanu, thanks I'm not sure what that means, really learning from square 1 after Atom and various graphical editors
17:11:08 <ertes> Tuplanolla: nope
17:11:44 <Tuplanolla> Thus I remain paranoid.
17:11:46 <dmwit> ertes: What about an out-of-memory exception?
17:11:52 <glguy> mbw: It comes out looking like this: https://glguy.net/CookieCalculator.png
17:11:53 <ertes> Tuplanolla: in particular a standalone (pure ()), when executed, *will* generate code
17:12:04 <glguy> mbw: and you can open the .ui file with your glade-3 application
17:12:10 <ertes> dmwit: not sure
17:12:27 <dmwit> me neither
17:12:38 <Eduard_Munteanu> I've been using vim a long time, though I really wish we had a nice graphical structural editor by now. :(
17:12:44 <ertes> i guess it depends on whether there is allocation happening
17:13:11 <EvanR> "does the guarantee hold even in the face of an out-of-memory exception" sorry what was the question?
17:13:27 <ertes> also i guess most laws assume an infinite amount of memory
17:13:28 <monochrom> For async exceptions, "pure () >> c" is the wrong level to look at. (Can it happen to >> to?)
17:13:32 <nshepperd_> (pure () >> c) = c isn't true when it comes to execution time, so
17:13:40 <hamishmack> glguy: Have you tried generating MyGtkApp with from the .ui file with template haskell?
17:13:51 <mbw> glguy: I really haven't done much with glade just yet, since I wanted to learn the basics first. So I can't really tell what kind of boilerplate it is you get to avoid by using generics?
17:13:59 <glguy> hamishmack: I haven't, but that sounds like a nice idea, too
17:14:04 <dmwit> EvanR: The question was, can `pure () >> c` throw any exceptions that `c` doesn't throw?
17:14:11 <Tuplanolla> It's a follow-up of my remark that "the runtime system can give you `ENOMEM` or `EIO` at any point", EvanR and dmwit.
17:14:38 <ertes> much like most laws assume that hardware isn't made by intel
17:15:02 <glguy> mbw: you can look at the generics code here, you'd need one of these for every record field: https://github.com/glguy/CookieCalculator/blob/master/gui/AutoBuilder.hs#L40-L45
17:15:07 <dmwit> Most laws ignore exceptions entirely. So we're really in exceptional territory.
17:15:57 <Eduard_Munteanu> I'm beginning to think nulls really are the right thing, conceptually.
17:15:57 <EvanR> it was supposed to be a bad joke
17:16:59 <mbw> glguy: I tried grokking Generics once, but found that tutorials/papers (or whatever I tried to learn it with, it's been a while) are outdated since the API keeps changing. How did you learn it?
17:17:00 <monochrom> () is pre-defined (in compiled code). pure() won't allocate.
17:17:15 <glguy> mbw: The API hasn't really changed in many years
17:17:24 <mbw> huh
17:17:35 <monochrom> But "does pure() become a non-zero piece of asm code" is context-dependent.
17:17:44 <monochrom> Because code optimization is.
17:17:45 <glguy> It's basically the same as it was when released
17:18:29 <glguy> It changed very early on by getting rid of the distinction between recursive occurences of fields and nonrecursive ones
17:18:35 <mbw> Ok this is weird. I remember trying to work through examples that used type constructors that didn't exist...
17:18:37 <glguy> but that was a backward compatible change
17:19:02 <glguy> You probably needed to turn on the TypeOperators extension
17:19:10 <glguy> or to import the module
17:19:13 <glguy> GHC.Generics
17:20:33 <mbw> If it's true that the API is as stable as you say, I probably did some stupid mistake like that.
17:20:36 <nshepperd_> You could have an explicit IO action for handling async exceptions. asyncExceptionsSinceLastCall :: IO [Exception]. But that would be terrible
17:20:44 <n_blownapart> very sorry glguy ... so I set :syntax on in .vimrc. your file is syntax.vim , sitting in $HOME/.vim/syntax/   .   That's it right?
17:21:19 <glguy> nope, it was ~/.vim/syntax/haskell.vim
17:21:45 <monochrom> Yeah, Traversable f => IO (f Exception) is better  <duck>
17:21:46 <glguy> You can just not worry about it, though, the standard copy is still usable
17:21:51 <ertes> it doesn't really matter too much whether (pure ()) is free…  what matters is whether it could throw an exception in "regular operation" (no hardware failure, enough RAM), and that depends mostly on whether it allocates
17:21:53 <glguy> I was just throwing that out there for the regulars
17:22:48 <n_blownapart> ok you mean no need to change the file name but I can for good practice? glguy 
17:23:03 <glguy> You have to change the name for it to work
17:23:15 <n_blownapart> excellent. thanks kindly
17:24:18 <mbw> Alright, again thanks for your help glguy and hamishmack. I'll try using gi-gtk now.
17:24:21 <ertes> do v <- newIORef False; (writeIORef v True >> pure ()) `onException` (readIORef v >>= print)  -- could you ever observe an exception that prints True?
17:24:45 <Eduard_Munteanu> data IO a = Action (RealIO a) | forall e. Exception e => Throw e | Catch (forall e. Exception e => e -> a) (IO a)
17:26:36 <Eduard_Munteanu> That looks stupid though.
17:27:21 <dmwit> monochrom: I'm proposing that `(>>)` produces a thunk that allocates when it gets forced, not that `()` causes allocation.
17:27:34 <monochrom> Yeah, it doesn't answer any question (apart from nice types), it just shovels all behavourial questions under the run time.
17:27:59 <dmwit> monochrom: Also I don't think it's clear that "() is pre-defined" lets you conclude "pure() won't allocate".
17:30:05 <Eduard_Munteanu> If you really have 'pure () >> c' somewhere, why couldn't a RULE cut it down to just 'c'?
17:30:13 <pacak> > pure () :: Maybe ()
17:30:15 <lambdabot>  Just ()
17:30:18 <dmwit> RULEs can do anything.
17:32:26 <monochrom> dmwit, the way I settle all those questions is to ghc -O -ddump-simpl -ddump-prep -ddump-opt-cmm -ddump-asm -ddump-to-file -dsuppress-all
17:32:44 <n_blownapart> now for my next trick, I'm going to learn Haskell side by side with Scheme.
17:33:05 <dmwit> computer experimental science
17:33:18 <monochrom> And the empirical result is that all of "pure () >>" disappears.
17:33:21 <ertes> Eduard_Munteanu: while (pure () >>) doesn't come up too often, something like (>> pure ()) comes up all the time, and in most cases in a non-trivial (i.e. not easily rewritable) way
17:33:38 <n_blownapart> Scheme is dmwit ?
17:34:06 <n_blownapart> or my trick?
17:34:11 <dmwit> n_blownapart: No, I was enjoying monochrom's appeal to GHC.
17:34:17 <Eduard_Munteanu> Hm, yeah, I was just considering   (if condition then launchMissiles else pure ()) >> c
17:34:50 <Eduard_Munteanu> It can be rewritten, but it's not trivial.
17:35:23 <mbw> I tried making a new stack project with gi-gtk as dependency. However, building of haskell-gi failed with "The pkg-config package
17:35:26 <mbw>     'gobject-introspection-1.0' version >=1.32 is required but it could not be
17:35:29 <mbw>     found.
17:35:30 <n_blownapart> anyone think I should *not* try to learn both together? noob here who knows a bit of Scheme
17:35:48 <monochrom> Well, I can test that too.
17:35:49 <dmwit> mbw: Don't forget to install the -dev (or -devel if on Fedora) version of gtk.
17:36:09 <dmwit> mbw: And presumably gobject-introspection, if your package manager offers that.
17:38:40 <hamishmack> mbw: on Fedora it is gobject-introspection-devel Ubuntu it is libgirepository1.0-dev on Arch Linux you need both gobject-introspection gobject-introspection-runtime
17:39:15 <mbw> urgh it turns out tab completion is more helpful than using apt-cache search
17:39:19 <barrucadu> ertes: Based on the very unreliable technique of running your "do v <- ..." code concurrently with a call to "killThread" 10,000 times: yes, sometimes it prints True
17:40:09 <monochrom> GHC core turns your example into "if condition then launchMissiles >> c else c"
17:40:12 <barrucadu> Which matches what I'd expect, I'm sure (although I can't remember the test case now) I had an issue when writing my concurrency-testing library which needed me to make return/pure pre-emptable by exceptions in order to match the behaviour of GHC
17:40:38 <mbw> Thanks dmwit, hamishmack.
17:40:48 <monochrom> The exact code I used is: main = getLine >>= \x -> (if null x then putStrLn x else pure ()) >> putStrLn ""
17:42:25 <Eduard_Munteanu> Hm.
17:43:03 <monochrom> You can object that I used a very short c, that maybe GHC won't duplicate code like this if c is really long.
17:43:53 <nshepperd> i guess, because 1. you need the ghc exception stuff to handle async exceptions and 2. exceptions in pure code are basically indistinguishable from async, you can't really do any better than having the ghc throw/catch stuff in there
17:46:48 <nshepperd> given that, it's really a matter of whether you prefer to use the ghc exception stuff *only* for async exceptions and have readFile path :: IO (Either IOError String) or whatever
17:48:21 <nshepperd> you can make IO a nice type as well, but that doesn't really do anything
17:48:25 <ertes> confirming that IO is indeed a weird pseudo-monad
17:49:06 <monochrom> "funny :: IO a -> IO (); funny = (>> pure())" gets compiled to: \ a s -> case a s of (# s', _ #) -> (# s', () )
17:49:35 <monochrom> where s and s' are the infamous State# RealWorld phantom values.
17:49:39 <nshepperd> it could be a free monad with Catch constructors and so on, but all that means is that the rts would do something different to send async exceptions to the right place
17:49:43 <monochrom> So no thunk no allocation.
17:50:02 <monochrom> Also, the last ) should be #)
17:51:16 <monochrom> But if you actuall use funny somewhere, I'm pretty sure inlining kicks in and kills even the mention of ().
17:51:43 <duckqlz> does using "error" in a function cause it to lose its purity?
17:52:05 <Eduard_Munteanu> monochrom, is that with any -O?
17:52:14 <monochrom> Yes, I always use -O
17:52:27 <monochrom> ghc -O -ddump-simpl -ddump-prep -ddump-opt-cmm -ddump-asm -ddump-to-file -dsuppress-all
17:53:15 <nshepperd> duckqlz: nah. though you'll find that no-one agrees on what "purity" even is
17:53:38 <monochrom> If you use -O0, you get to retain all the goodness of explicit >> and explicit >>= and explicit funcalls and whatnot.
17:53:44 <EvanR> idris runtime is interesting for responding to hard exceptions by just dying
17:53:59 <EvanR> since you should have proved that to be impossible
17:54:25 <EvanR> there is nothing else but something like Either
17:55:58 <EvanR> duckqlz: bottom is encoded into the meaning of haskell programs
17:56:13 <EvanR> error "foo" gives you direct access to that
17:56:46 <EvanR> "feature not a bug"
18:00:30 <EvanR> since IO doesnt come with a default meaning, here we are again playing philosophers
18:00:35 <monochrom> Oh now this is cute. main = getLine >>= \x -> (if null x then putStrLn x else pure ()) >> funny (putStrLn "")
18:00:42 <monochrom> (funny as defined before)
18:02:18 <monochrom> The Core code goes like, for each case, ending with "case hPutStr2 stdout [] True s of (# s', _ #) -> (# s", () #)"
18:02:38 <monochrom> meaning the compiler doesn't know that putStrLn's () equals pure()'s ().
18:03:38 <EvanR> s, s', s"?
18:03:47 <EvanR> that is cute
18:03:48 <monochrom> No.
18:04:02 <monochrom> Err ahh, my typo. s' again.
18:04:16 <EvanR> oh
18:05:47 <monochrom> However, "main >> main" is going to lose the intermediate ().
18:06:10 <monochrom> So, context-dependent!
18:07:21 <duckqlz> EvanR: Thanks ! 
18:09:28 <monochrom> The compiler doesn't know that () is unique and reusable, but it surely knows dataflow analysis and dead-code removal.
18:10:05 <EvanR> shouldnt it know that () is unique and reusable
18:10:14 <monochrom> And with the latter, some allocation points, even some interruptible points, can totally disappear.
18:10:34 <monochrom> "Send a pull request!"
18:11:11 <Axman6> something of type () is not necessarilly () though, it may never terminate
18:11:28 <Axman6> :t fix (\a -> a) :: ()
18:11:29 <lambdabot> ()
18:11:32 <monochrom> Sure, but that's beside the point.
18:11:37 <EvanR> () the value i mean
18:11:45 <Axman6> yeah I missed the beginning of the discussion
18:15:48 <monochrom> Oh interesting, putStrLn s = hPutStr2 stdout s True; putStr s = hPutStr2 stdout s False
18:17:30 <EvanR> what is that
18:18:12 <monochrom> Haskell code. :)
18:19:14 <EvanR> whats the True False indicating
18:19:32 <Axman6> flush line perhaps?
18:19:38 <Axman6> or, at elast add end of line?
18:19:45 <monochrom> putStrLn vs putStr? Did you see?
18:19:50 <Axman6> least*
18:20:11 <iqubic> What's the best way to validate user input?
18:20:23 <monochrom> The best way is to parse.
18:20:25 <Axman6> ask them to be really careful
18:20:32 <Axman6> :)
18:20:36 <iqubic> Axman6: you stink
18:20:50 <Axman6> Trust is important, you should build trust between yourself and the users
18:20:54 <monochrom> The other extreme is to declare that all inputs are valid.
18:21:03 <iqubic> monochrom: I can't do that.
18:21:16 <Axman6> but parsers are also a good way to ensure that textual user input matches a grammar
18:21:58 <iqubic> See I ask the user to input an integer between 0-2 inclusive. I want to keep asking until I get a valid number.
18:22:25 <monochrom> "validate input" has basically disappeared from my vocabulary ever since I came to Haskell and learned to think in terms of parsing input. Just write a bloody parser to bloody parse the input. How hard is that?
18:22:38 <iqubic> It's not that hard.
18:22:57 <EvanR> indeed, and then you start to see the job of getting meaningful input out of a json post as parsing even when its already been parsed once
18:23:06 <EvanR> at least once
18:23:13 <Axman6> for a simple thing like that, a simple loop and using readMaybe will work well
18:23:16 <monochrom> And retrospectively all I read from textbooks about "validate input" is just trying to say parsing without saying the exact word "parsing".
18:23:38 <monochrom> "check that the input string consists of 0-9's only" that's parsing.
18:23:41 <Axman6> (where readMaybe is a parser you don't need to write yourself)
18:23:56 <EvanR> because validation connotes giving you the original data and a Bool
18:24:09 <EvanR> parsing gives you something else, or Nothing
18:24:21 <louispan> Is there a polymorphic variant library that supports ghc 8.0 besides https://hackage.haskell.org/package/union? HList (https://hackage.haskell.org/package/HList-0.4.1.0/docs/Data-HList-Variant.html) unfortunately doesn't support ghc 8.0
18:24:23 <iqubic> How do I write a loop that will keep asking for input until I get some input that is valid
18:24:25 <EvanR> but the second one is better
18:24:35 <kadoban> getNum = do {putStrLn "Feed me"; x <- readMay <$> getLine; if isNotValid x then putStrLn "nope" >> getNum else return x}
18:24:41 <Axman6> iqubic: can you write a function of the type isValid :: String -> Bool?
18:24:55 <iqubic> Yeah, I think so.
18:25:25 <iqubic> But actually I want to write a function of the type parse :: String -> Maybe Int
18:25:36 <EvanR> \o/
18:25:38 <monochrom> That's exactly readMaybe
18:25:45 <Axman6> then you can write: getValisInput :: IO Int; getValidInput = do {l <- getLine; if isValid l then return l else getValidInput}
18:25:58 <monochrom> "readMay", though, is pig latin :)
18:26:11 <Axman6> > readMaybe "1" :: Maybe Int
18:26:13 <lambdabot>  error:
18:26:13 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Int
18:26:22 <Axman6> @hoogle readMay
18:26:22 <lambdabot> Safe readMay :: Read a => String -> Maybe a
18:26:22 <lambdabot> BasicPrelude readMay :: Read a => Text -> Maybe a
18:26:22 <lambdabot> ClassyPrelude readMay :: (Element c ~ Char, MonoFoldable c, Read a) => c -> Maybe a
18:26:25 <monochrom> It's in Text.Read
18:26:34 <kadoban> I always forget where readMaybe lives or that it's in base.
18:26:40 <Axman6> yeah
18:27:04 <iqubic> monochrom: I want to make sure the input is between 0-2 inclusive as well as being an Int
18:27:06 <monochrom> PigLatinPrelude
18:27:21 <iqubic> @import Text.Read
18:27:21 <lambdabot> Unknown command, try @list
18:27:26 <iqubic> import Text.Read
18:27:26 <monochrom> Sure, so combine readMaybe with extra code.
18:28:12 <EvanR> case input of { "0" -> Just 0; "1" -> Just 1; "2" -> Just 2; _ -> Nothing }
18:28:38 <iqubic> EvanR: that works. I suppose.
18:28:46 <EvanR> parsed
18:29:02 <EvanR> its so dumb it just might work
18:29:34 <iqubic> But I want to have it parmeratized. As in parseInput :: Int -> String -> Maybe Int
18:29:51 <monochrom> You know enough Haskell by now to do that yourself too.
18:29:53 <iqubic> where input must be between 0 and first int inclusive
18:29:54 <kadoban> Sounds like a good exercise.
18:36:01 <iqubic> got it.
18:36:55 <lpaste> iqubic pasted “Parse Input” at http://lpaste.net/355984
18:37:24 <iqubic> Yeah, that'll make sure that the number given is between 0 - size inclusive
18:38:29 <iqubic> At least I think it will. I need to test that.
18:38:45 <kadoban> Yeah, testing looks like a good idea, though it's essentially the right idea.
18:39:24 <dmj`> iqubic: guard would be nice to use here
18:39:39 <iqubic> Does it?
18:39:46 <iqubic> How does guard work?
18:39:52 <dmj`> :t guard
18:39:53 <lambdabot> Alternative f => Bool -> f ()
18:40:35 <iqubic> Also, my code that I just submitted fails.
18:40:43 <dmj`> > Just “foo” >>= \foo -> guard (length foo == 3)
18:40:45 <lambdabot>  <hint>:1:6: error: lexical error at character '\8220'
18:41:06 <iqubic> Wait, I have my comparisons backwards
18:41:15 <iqubic> fixed that.
18:41:56 <dmj`> > Just 3 >>= \x -> guard (x == 4) >> pure x
18:41:58 <lambdabot>  Nothing
18:42:02 <dmj`> > Just 3 >>= \x -> guard (x == 3) >> pure x
18:42:04 <lambdabot>  Just 3
18:43:13 <iqubic> How do I use guard for my thing?
18:44:21 <dmj`> parseInput size input =  maybeNum >>= \num -> guard (0 <= num && num >= size) >> pure num
18:45:26 <dmj`> iqubic: You might want to consider readEither though, since it will return why a parse failed
18:48:30 <EvanR> f : (n : N) -> (s : String) -> Dec (m : Fin (n + 1), show m = s)
18:49:28 <EvanR> the same task's question and test encoded as a dependent type
18:49:33 <iqubic> EvanR: What are you doing
18:49:49 <EvanR> if it compiles, its right ;)
18:51:50 <EvanR> in which case just having it do the right thing isnt enough, it must also yield evidence that the parser parsed the right thing, and that if it fails that it failed because it would have failed the test, show m = s
18:52:36 <iqubic> What do I need to import to use the guard function?
18:52:46 <dmj`> Control.Monad probably
18:52:52 <monochrom> Control.Monad
18:52:53 <iqubic> and how does your code work dmj`?
18:53:31 <iqubic> parseInput size input =  maybeNum >>= \num -> guard (0 <= num && num >= size) >> pure num
18:53:41 <dmj`> @src guard
18:53:41 <lambdabot> guard True  = pure ()
18:53:41 <lambdabot> guard False = empty
18:54:31 <iqubic> Oh, I see how that works.
18:54:54 <dmj`> empty in this case is Nothing
18:55:51 <iqubic> It is indeed.
18:56:06 <iqubic> Now I can add that into my game loop. 
18:56:17 <iqubic> But first I need to work on win detection.
18:56:24 <dmj`> desugard, guard False >> pure num == empty >> pure num == Nothing >> pure num == Nothing >>= \_ -> Just num
18:56:29 <dmj`> desugared*
18:58:06 <dmj`> per the Monad instance we know, Nothing >>= _ = Nothing. So that’s how it works.
18:58:51 <dmj`> > Nothing >>= \_ -> Just 4
18:58:53 <lambdabot>  Nothing
18:59:15 <iqubic> I got you.
19:00:23 <dmj`> cool
19:02:41 <Why_> Hello?
19:02:59 <iqubic> Hey
19:03:32 <Why_> I'm a beginner and was hoping to get a little help
19:03:58 <iqubic> Go ahead. Ask some questions
19:04:22 <Why_> So I was trying to define a monad
19:04:40 <iqubic> For what?
19:04:54 <Why_> is there a way to specify that the function should be a->a?
19:05:10 <iqubic> What function are you talking about?
19:05:22 <iqubic> A monad is not a function.
19:05:32 <Why_> https://pastebin.com/UyMkRFZR
19:05:37 <Why_> heres the code
19:05:53 <iqubic> That seems fine.
19:06:04 <iqubic> What function needs to be a -> a?
19:06:16 <Why_> the compiler is complaining that (f x) is type SD b
19:06:37 <Why_> I'm thinking that it doesn't know that I want f :: a->a
19:06:40 <iqubic> Oh, yeah. It is.
19:06:41 <dmj`> f :: (a -> SD b) -> SD b
19:07:10 <dmj`> (f y) :: SD b, you’re applying (a -> SD b) to a
19:07:36 <iqubic> Why_: have you created functor and applicative instances for this data type??
19:07:57 <Why_> is there a way to specify that f should be a->a or something so it works?
19:08:12 <iqubic> No.
19:08:14 <Why_> No, I've only got what I've posted
19:08:23 <iqubic> Why_: That's one issue.
19:08:38 <iqubic> You need a functor and an applicative instance for this.
19:08:44 <dmj`> Why_: f has to be of type Monad m => (a -> m b) -> m b
19:10:00 <Why_> I think the compiler has inferred that, dmj`. Its complaining because its "Next a a", not "Next a b"
19:10:08 <dmj`> instance Functor SD where fmap f (Init x) = Init (f x); fmap f (Next x y) = Next (f x) (f y)
19:10:33 <glguy> If you're definine a Monad instance, then you can just derive fmap = liftM
19:11:05 <Why_> god, I have no idea what I'm doing lol
19:11:20 <glguy> Why_: Why are you trying to write a Monad instance for this type?
19:11:35 <Why_> The motivation for making this was to preserve the initial input in a series of computations
19:12:17 <iqubic> There are easier ways to do that. You don't need a monad for that.
19:12:33 <Why_> I think theres another way, but at this point, I'm just trying to make this work for understanding
19:12:35 <glguy> Why_: The monad instance you have in mind here is just not valid
19:12:42 <Why_> ah, ok
19:12:56 <Why_> does it violate the laws in some way?
19:13:15 <iqubic> No. It won't even type check.
19:13:21 <glguy> First of all, it's just not type correct, so no, it doesn't
19:13:32 <glguy> But what you seem to be trying to do and what you're describing won't make for a valid monad instance
19:13:33 <iqubic> there is no way to make this compile as a monad.
19:14:10 <iqubic> Why can't you just use the state monad?
19:14:42 <iqubic> Then just package up the result as a tuple.
19:15:02 <Why_> yeah, thats what I thought of as the other waay
19:15:10 <alviprofluvium> Is there a way to show only the decimals of a Floating instance if its not and integer?
19:15:20 <Why_> I'm just trying to learn how this stuff works =\
19:18:22 <Why_> so you don't want to first convert the float to an int?
19:21:05 <lpaste> glguy pasted “Why_'s SD type's Monad instance” at http://lpaste.net/355985
19:23:04 <glguy> alviprofluvium: I don't think there's a function in base 'f' where   f 1.0 = "1" and f 1.5 = "1.5"
19:23:16 <glguy> You can write one, of course
19:23:47 <Why_> lpaste: wow, thanks, I'll get on reading that
19:25:47 <alviprofluvium> glguy: thanks, I will
19:26:05 <Why_> wait, thats a bot huh.. I should be thanking glguy lol
19:37:00 <mbw> Where are the original gtk2hs examples the gi-gtk ones (https://github.com/haskell-gi/gi-gtk-examples) have been ported from?
19:38:04 <mbw> sorry
19:38:12 <mbw> found it
19:43:02 <drakonis> yo
19:43:14 <drakonis> how's haskell doing in libraries?
19:47:22 <peddie> drakonis: http://hackage.haskell.org/packages/
19:48:00 <drakonis> not quite what i asked
19:48:01 <peddie> drakonis: is there some particular thing you want a library for?
19:48:01 <drakonis> i suppose
19:48:14 <drakonis> math libraries really
19:48:45 <drakonis> for the complex stuff
19:49:18 <peddie> what problem are you solving?  I want to help you find something, but that's not very specific
19:50:20 <drakonis> just checking things right now, getting started
19:50:33 <drakonis> getting my feet wet and looking at what's available compared to other languages
19:50:43 <drakonis> nothing too specific yet
19:50:46 <duckqlz> drakonis: Haskell is 27 years old so it is "doing" good with libraries lol
19:50:56 <drakonis> data communications stuff really
19:51:31 <drakonis> python is 25 years old and it has many more libraries
19:51:44 <peddie> drakonis: I've used https://hackage.haskell.org/package/hmatrix-gsl a fair amount and find it pretty handy in my line of work
19:51:48 <peddie> for example
19:52:30 <peddie> also https://hackage.haskell.org/package/dynobud for doing big (especially dynamic) optimization problems
19:53:01 <peddie> I think people find the `ad` package handy
19:53:16 <peddie> there are tensorflow bindings if that's the kind of maths you're interested in
19:53:35 <peddie> no bindings to SUNDIALS yet, unfortunately
19:54:18 <peddie> drakonis: it's decent for a lot of maths stuff (at least the numerical things I care about).  python definitely has way more libraries for this kind of stuff
19:54:50 <drakonis> haskell seems to lend a lot more towards math stuff i suppose
19:54:52 <peddie> drakonis: it's pretty straightforward to call between Haskell and C in either direction, so a few times when I've had a problem, I've just written bindings to a C library
19:54:52 <drakonis> looking at it
19:56:27 <peddie> eh, I dunno, excellent language design and numerical computing haven't been correlated for the most part
19:57:34 <peddie> but I certainly find writing numerical stuff in haskell a lot more pleasant than in python
19:59:59 <drakonis> that's the whole point i'm picking up haskell
20:00:08 <drakonis> fun~~
20:05:04 <drakonis> really needs more libraries to draw people in
20:05:14 <drakonis> also libraries for making video games in haskell
20:05:17 <peddie> drakonis: what do you have in mind?
20:05:48 <peddie> drakonis: you might check out https://github.com/ekmett/quine 
20:06:07 <drakonis> oh wow that looks great
20:07:04 <drakonis> i mean, perhaps not extremely complex stuff for starters but something simple like text based libraries
20:07:09 <drakonis> a roguelike in haskell
20:07:29 <peddie> @hackage brick   this perhaps?
20:07:29 <lambdabot> http://hackage.haskell.org/package/brick   this perhaps?
20:07:30 <drakonis> oh that does exist
20:07:43 <drakonis> https://hackage.haskell.org/package/LambdaHack this actually
20:07:45 <drakonis> but it is fairly complete
20:07:49 <drakonis> would use brick for that though
20:07:59 <peddie> are you going to write a video game in haskell?
20:08:04 <drakonis> i'd like to try
20:08:04 <glguy> drakonis: If you're interested in hacking on text apps, and are an IRC users, you might poke at my IRC client
20:08:32 <drakonis> hmm
20:08:45 <drakonis> i'm okay with anything that lets me become a better programmer
20:09:15 <peddie> reckon you joined the right channel; stick around :)
20:11:38 <peddie> drakonis: I think there's a #haskell-game channel
20:11:45 <peddie> might be more focused on video game stuff
20:12:05 <drakonis> i'll just do some regular stuff before going into games
20:12:10 <drakonis> gotta learn how to work the basics first
20:12:18 <peddie> good point
20:12:30 <peddie> are you following a textbook?
20:12:33 <drakonis> nope
20:13:16 <peddie> if you're looking for some guidance to get through the basics, I'd definitely recommend the CIS194 course materials from UPenn
20:13:19 <peddie> @where cis194
20:13:19 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
20:13:28 <drakonis> huh
20:13:56 <drakonis> neat
20:14:27 <iqubic> Is there a way to go from Maybe a to a?
20:14:41 <peddie> :t maybe
20:14:42 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:14:49 <peddie> :t fromMaybe
20:14:50 <lambdabot> a -> Maybe a -> a
20:14:52 <drakonis> haskell also seems really good to smarten up re: math
20:15:12 <drakonis> because i haven't been doing too hot with some concepts because i am absolutely terrible with listening without executing
20:17:52 <peddie> drakonis: I guess it depends on the branch of maths.  you may not get a whole lot of enlightenment about e.g. multivariable calculus
20:18:31 <drakonis> of course not
20:18:43 <peddie> (or you might, if you play with `ad` ;)
20:18:45 <drakonis> haw
20:18:49 <drakonis> ad ey?
20:18:53 <peddie> @hackage ad
20:18:54 <lambdabot> http://hackage.haskell.org/package/ad
20:19:24 <drakonis> hot
20:19:42 <EvanR> im doing multivariable calculus right here
20:19:47 <EvanR> *in haskell*
20:21:06 <peddie> drakonis: by the way, there are more learning materials available, many of them free:
20:21:09 <peddie> @where learnhaskell
20:21:10 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:21:22 <peddie> but I'd definitely start with CIS194
20:28:29 <drakonis> there's the haskell book thing in there huh
20:28:44 <drakonis> a little terribly expensive for me though
20:29:00 <peddie> drakonis: yeah, there are a few textbooks available, there's also "Programming in Haskell"
20:31:24 <peddie> I guess start with the free materials and see whether you feel the need for a textbook?
20:31:59 <drakonis> i'll do
20:32:01 <drakonis> gonna get some rest
20:32:08 <peddie> adios, hope to see you around
20:40:45 <iqubic> I have learned all my Haskell from free resources online.
20:40:55 <iqubic> Now I'm doing more and more complex stuff
20:44:58 <iqubic> I have now got most of the IO done for my TicTacToe game.
20:45:37 <iqubic> I'm loving Haskell's method of IO.
20:46:00 <iqubic> Monadic IO is awesome
20:57:02 <EvanR> the awesome part is that IO actions are values, not statements
20:57:38 <EvanR> you can process them inside the language
21:17:16 <iqubic> I know that. I have been doing just that in my TicTacToe IO
21:50:07 <cocreature> I was amazed when I first realized that this means that you can just write IO actions to an MVar and send it to another thread
21:57:47 <peddie> haskell is such a fantastic imperative language
21:58:27 <sm> cocreature: huh, really ?
21:58:38 <cocreature> sm: sure
21:59:10 <cocreature> sm: basically you get the “command pattern” for free (if you don’t need to restrict or inspect the commands)
22:05:27 <halogenandtoast> peddie: I've been reading CIS194, it doesn't seem very comprehensive.
22:06:03 <peddie> halogenandtoast: it's not comprehensive; it's an introductory course
22:06:42 <halogenandtoast> Fair enough. I definitely can't see how it was a 12 week ordeal.
22:07:25 <halogenandtoast> But maybe all the content isn't available
22:07:41 <halogenandtoast> I've been enjoying Graham's book as a good introduction
22:08:04 <MarcelineVQ> it's a 12 week ordeal, when combined with having to do other courses at the same time
22:08:15 <peddie> halogenandtoast: it's targeted at undergrads and doesn't assume much
22:08:26 <peddie> halogenandtoast: I think those are the actual course materials, but if you understand what's covered well enough that CIS194 doesn't help, consider maybe going through the NICTA course or CS240h?
22:08:26 <Axman6> I'm currently in the middle of running the Data61 FP course (formerly NICTA FP course), which covers most of what CIS194 does in a 3 day course. It's pretty intense
22:08:34 <halogenandtoast> Maybe being an undergrad is easier these days :p
22:08:52 <Axman6> peddie: Data61 course*
22:09:01 <peddie> oops
22:09:13 <peddie> CSIRO course :P
22:09:18 <Axman6> Nah
22:09:33 <Axman6> Data61 (a part of CSIRO) course
22:09:38 <halogenandtoast> Axman6: 3 days might be much, but I could see CIS194 being a 2 to 3 week course.
22:09:43 <peddie> Axman6: I'm just teasing :)
22:09:50 <peddie> halogenandtoast: anyway, there are plenty of other free materials if you want something more advanced or aggressive
22:10:00 <Axman6> halogenandtoast: yeah that would be a good speed for it probably (I've never taken it)
22:10:04 <halogenandtoast> peddie: always
22:10:39 <peddie> halogenandtoast: https://github.com/data61/fp-course http://www.scs.stanford.edu/14sp-cs240h/
22:10:55 <halogenandtoast> peddie: yup have those both open now and bookmarked for later.
22:15:08 <halogenandtoast> thanks for the suggestions
22:16:23 <peddie> halogenandtoast: have fun :)
22:18:10 <halogenandtoast> heh well, it might not be helpful for me, but I've been gathering resources for my coworkers.
22:18:51 <halogenandtoast> So I have to read them to make sure they're useful :D
22:19:20 <MarcelineVQ> mm, buy them http://haskellbook.com/
22:19:43 <halogenandtoast> MarcelineVQ: I did
22:20:34 <MarcelineVQ> shucks son you're done then, that's the full story of what concepts you need to know haskell
22:22:39 <halogenandtoast> Yeah I should finish reading it. I think I started at version 0.6 something and made it to chapter 14
22:23:05 <jle`> man the containers in stackage is so old
22:23:11 <halogenandtoast> It was part of a Book club, but then I moved :(
22:23:13 <jle`> apparently it's because ghc still uses an old containers
22:23:27 <cocreature> jle`: yep and if you upgrade it you a) rebuild everything and b) you break things like intero
22:23:32 <cocreature> it’s really annoying
22:23:44 <jle`> i'm trying to rebuild everything with a new version at the moment
22:23:56 <cocreature> I hope you don’t use intero :)
22:23:57 <jle`> but yeah i guess i can just give up with things that use the ghc api
22:24:09 <jle`> i wonder if there are any plans by the #ghc team to bump up containers
22:24:13 <jle`> for 8.2 maybe
22:24:18 <cocreature> 8.2 already contains a newer version
22:24:32 <jle`> oh nice
22:24:59 <cocreature> rc2 seems to have 0.5.10.2 which is the newest release
22:25:03 <jle`> ah yeah it looks like it uses 0.5.10.2
22:25:14 <jle`> oops too slow
22:25:50 <cocreature> it’s kind of annoying that now that containers is actively being developed again, we’ll keep running into this problem
22:26:41 <cocreature> don’t get me wrong, I’m really happy that it is being developed. I just wish it was possible to upgrade it without breaking everything using the GHC API
22:31:46 <kooty[m]> monochrom:
22:53:14 <jle`> neat, just refactored a complicated huge function to just a sumOf (blah.blah.blah)
23:15:33 <MarcelineVQ> jle`: what was it? the sumOf example in the lens docs is pretty interesting
23:33:08 * hackage htlset 0.1.0.0 - Heterogenous Set  https://hackage.haskell.org/package/htlset-0.1.0.0 (kelemzol)
23:49:16 <halogenandtoast> Does anyone know of anywhere online where I can find fellow Haskell developers who want to pair on random things?
23:49:41 <halogenandtoast> In a more directed manner (I could tweet, etc., but perhaps there is a better venue)
23:53:07 <gxt> halogenandtoast: If you just want to solve random problems for the sake of practice, maybe try https://www.codewars.com/
23:57:08 * hackage wolf 0.3.15 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.15 (markfine)
23:58:18 <halogenandtoast> gxt: kind of, I want to pair with people
