00:00:04 <cocreature> alright, I’ll move there. thanks
00:03:26 <piyush-kurur> any one looking for hacking into a real project I am happy to get more eyes on the raaz codebase
00:03:51 <piyush-kurur> help with documentation and developer notes are also good
00:04:06 <piyush-kurur> https://github.com/raaz-crypto/
00:08:57 <halogenandtoast> piyush-kurur: are there any simple tasks you want help with?
00:09:35 <halogenandtoast> I guess documentation and developer notes, but code-wise
00:13:09 <piyush-kurur> halogenandtoast: if you use windows then some porting of memory locking and system entropy would be good
00:13:31 <piyush-kurur> also may be help with setup of some CI for Windows builds
00:13:52 <piyush-kurur> the task is not too difficult
00:14:22 <piyush-kurur> just that one needs windows :-( 
00:17:56 <piyush-kurur> I have just marked the two issues above as "easy" in the issue tracker
00:19:18 <halogenandtoast> ah sorry, osx user :(
00:20:05 <piyush-kurur> halogenandtoast: on osx we currently use /dev/urandom for system entropy
00:20:29 <piyush-kurur> if it has a better entropy source (e.g. arc4random on bsd) you can contribute that
00:21:00 <halogenandtoast> I think there is arc4random_uniform
00:21:32 <piyush-kurur> halogenandtoast: has it moved to chacha20 like the one on NetBSD and OpenBSD
00:22:04 <piyush-kurur> if it has, then we should move to that.
00:22:35 <piyush-kurur> I tried building raaz on OpenBSD but the haskell enviroment there has some bugs (cabal does not work)
00:22:59 <piyush-kurur> also as far as I see it stack is not available either.
00:23:14 <piyush-kurur> So in general I need help with non-linux systems
00:24:21 <halogenandtoast> I don't know what chacha20 is
00:24:40 <halogenandtoast> but I don't think it does
00:24:42 <piyush-kurur> chacha20 is a stream cipher due to Daniel Bernstein
00:25:38 <halogenandtoast> right, the man pages seem to imply that it doesn't use that.
00:25:43 <halogenandtoast> by not mentioning it.
00:26:08 <piyush-kurur> yeah so this is the old RC4 based one I gues (arc4 name comes form rc4)
00:28:40 <piyush-kurur> but OpenBSD guys did not change the name but gave a twist arc4random = A replacement Call for random
00:32:51 <piyush-kurur> halogenandtoast: other tasks involve review of the C code implementing the primitives
00:33:16 <piyush-kurur> I admit it is a  bit boring but it needs to be done at some point of time by some one 
00:35:06 <ongy> piyush-kurur: any reason you reimplement the crypto? Or just to save on dependencies?
00:36:22 <piyush-kurur> ongy:  the primitives you mean or the entire library?
00:36:39 <ongy> crypto primitives and modes
00:37:30 <piyush-kurur> https://cse.iitk.ac.in/users/ppk/posts/2016-07-30-Why-another-cryptolibrary.html
00:38:09 <piyush-kurur> I re-implemented the low level primitive to gell well with the design at the haskell level
00:38:48 <piyush-kurur> For example, At the C level, primitives do not take of maintaining the context (they support only block level operation) 
00:39:01 <piyush-kurur> all the other adjustments are done at the haskell layer
00:39:08 <halogenandtoast> Anyone do anything in particular for handling database migrations?
00:39:47 <piyush-kurur> ongy: I am also attempting to put types every where all the way from the lowest level to the highest level
00:42:57 <ongy> so you want any mode implementation to be on the haskell side?
00:43:47 <piyush-kurur> ongy: As of now I have only implemented CBC mode of AES 
00:44:08 <piyush-kurur> I have been taking a lazy approach to primitives
00:44:15 <piyush-kurur> implementing the easiest ones first 
00:44:38 <piyush-kurur> that is way you see that I have not bothered to continue with AES CTR etc
00:45:21 <piyush-kurur> currently we have sha1, sha2, chacha20, prg based on chacha20  and blake is in the process of being integrated
00:47:37 <ongy> the question still stands :) I'm mainly asking because I have some wrapper code for AF_ALG on linux. But it was intended for something that's on hold for unknown time, and if you are interested I'd make it public
00:47:54 <piyush-kurur> For Version I my target is to have one encrypted authenticated mode (chacha20-poly-1305), couple of hash functions, a signature scheme (ed25519) a key exchange scheme (X25519)
00:48:13 <piyush-kurur> If blake2 comes in then I might also have argon for password hashing
00:49:23 <piyush-kurur> ongy: what is AF_ALG?
00:49:54 <piyush-kurur> okey got it
00:49:56 <ongy> kernel crypto api over sockets
00:50:56 <piyush-kurur> ongy: of course make it public if you do not have issues. 
00:51:07 <piyush-kurur> If nothing else I can have a look at it
00:52:07 <piyush-kurur> currently my aim is mostly to get the primitives and api correct
00:52:26 <piyush-kurur> actual protocols will come in other package
00:52:54 <piyush-kurur> Although I am not sure whether I will support something like TLS due to how complicated its.  
00:53:07 <piyush-kurur> Might go for Noise or SSH first
00:56:03 <ongy> AF_ALG doesn't do TLS or SSH, it provides AES (as block cipher if you want) or with modes (including GCM if you want). Though I haven't done enough to do the EDAD
00:56:40 <piyush-kurur> ongy: As I understand it it does it at the kernel level 
00:56:44 <piyush-kurur> is that correct
00:57:09 <piyush-kurur> In any case, it is possible to integrate other implementations into raaz 
00:57:51 <ongy> mhh, it does it in the kernel, which doesn't imply anything special for crypto code. But it gives you access to any hardware implementations and has (hopefully) good generic implementations
00:59:25 <piyush-kurur> I think its integration would be a test on how pluggable the design is so I am excited
01:00:23 <ertes-w> is there a way to show a Rational in decimal notation with a max. precision?
01:00:36 <piyush-kurur> You can see the current AES-CBC integration here https://github.com/piyush-kurur/raaz/blob/master/Raaz/Cipher/AES/CBC/Implementation/CPortable.hs
01:00:53 <ertes-w> or should i go through Data.Fixed or Scientific?
01:01:08 <piyush-kurur> ertes-w: I was about to suggest the Data.Fixed 
01:03:24 <ongy> piyush-kurur: https://github.com/Ongy/af_alg-hs
01:03:25 <ertes-w> piyush-kurur: yeah…  i wish HasResolution had instances for Nat
01:05:30 <piyush-kurur> ongy: thanks will have a look
01:09:44 <piyush-kurur> ongy: does it make sense to have a separate repo where you expose the AF_ALG as "implementations" in the Raaz sense 
01:10:19 <piyush-kurur> I would think that is the best option as AF_ALG seems specific to Linux kernel
01:10:56 <piyush-kurur> okey folks need to go an grad some dinner
01:11:03 <piyush-kurur> s/dinner/lunch
01:11:38 <ongy> yea it is. and it's probably better to expose it over it's own package. but I don't think I will get around making this a proper package soon. Just wanted to push the idea. Since I think it's the easiest way (on linux) to use accelerated implementations (afaik bsd has something similar as /dev/crypto btw.)
02:01:03 <se-11-fish> hey, I've got a question about naming
02:01:09 <se-11-fish> sometimes people put 'M' suffix at the end of the function
02:01:14 <se-11-fish> f.e. bindM, returnM, mapM. 
02:01:24 <se-11-fish> These are just regular bind, return, map functions but we stress that the return type is monadic, right?
02:01:34 <tsahyt> not just the return type
02:01:36 <tsahyt> :t map
02:01:38 <lambdabot> (a -> b) -> [a] -> [b]
02:01:39 <tsahyt> :t mapM
02:01:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:01:51 <tsahyt> the function passed to it can be monadic
02:02:28 <se-11-fish> but then there's map and mapM both (and then the second one means traverse rather than map) 
02:03:24 <tsahyt> you're right, mapM == traverse, but with a stronger constraint
02:03:49 <tsahyt> but traverse also just maps a monadic function over a traversable
02:04:25 <tsahyt> I've never seen returnM or bindM anywhere
02:08:05 <tsahyt> se-11-fish: note that mapM used to have a slightly different type. it used to be (a -> m b) -> [a] -> m [b]. It got abstracted to arbitrary Traversables with the FTP iirc
02:09:45 <ongy> some things also exist for legacy reasons. Like liftM, which isn't needed anymore (outside of "lazy" instance definitions)
02:09:47 <tsahyt> the reason that both traverse and mapM exist is historical really. mapM came first afaik, the Traversable class came much later. now we have both.
02:10:55 <se-11-fish> I am from F#. I see it in various libs (returnM, foldM, etc) and here Scott uses the suffix f.e. https://fsharpforfunandprofit.com/posts/monadster/
02:11:00 <se-11-fish>  Thought this is common in haskell too
02:11:49 <se-11-fish> so in haskell are there any other common functions where 'M' suffix is used (apart from mapM) ?
02:11:54 <ertes-w> is there a library to query the system uptime?  none of the clocks from the 'clock' library are specified to be system uptime specifically
02:12:07 <tsahyt> se-11-fish: bind is (>>=) and return is just return, or pure. those are always monadic, there's no reason why there should be a suffix to it. there are functions with monadic version though, and they often have an M suffix. e.g. foldlM, foldrM, filterM, etc.
02:13:00 <boj> se-11-fish: also note the mapM_ (underbar) variations, which drop the result
02:13:01 <ongy> ertes-w: os restrictions?
02:15:23 <se-11-fish> :t filterM
02:15:25 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
02:15:28 <se-11-fish> :t filter
02:15:29 <lambdabot> (a -> Bool) -> [a] -> [a]
02:16:11 <tsahyt> note that filterM isn't generalized to traversables because it also needs to reconstruct the list as it goes
02:16:35 <tsahyt> so this can't be implemented in terms of some traversal
02:17:53 <quchen> traverse also needs to reconstruct the list as it goes. The key difference is that filterM has to conditionally reconstruct it.
02:18:28 <tsahyt> hm yeah I worded that badly
02:19:14 <se-11-fish> ok so the convention seems to be to use 'M' to differentiate between a normal function and monadic one (but it's not usually used for functions that are monadic and don't have 'normal' counterparts) 
02:20:06 <se-11-fish> :t map
02:20:07 <lambdabot> (a -> b) -> [a] -> [b]
02:20:10 <se-11-fish> :t mapM
02:20:12 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:20:43 <ertes-w> ongy: has to work on linux
02:20:44 <tsahyt> does lambdabot do type applications already?
02:20:53 <se-11-fish> except this gets me a little confused, but you say it's historic
02:21:02 <tsahyt> :t mapM @[]
02:21:04 <lambdabot> error:
02:21:04 <lambdabot>     Pattern syntax in expression context: mapM@[]
02:21:04 <lambdabot>     Did you mean to enable TypeApplications?
02:21:09 <tsahyt> well, it kinda does
02:21:10 <ertes-w> ongy: no further restrictions
02:21:22 <tsahyt> it should really be enabled
02:21:38 <ongy> ertes-w: read /proc/uptime then. That's what the uptime utility does (strace to the rescue!)
02:22:31 <kadoban> se-11-fish: Well, some of the old stuff still gets used. There's not really anything wrong with it, it's just a bit odd because we have twoish names for essentially the same thing, often with one a tad more general than the other.
02:23:25 <ertes-w> ongy: do you happen to know what the numbers mean?  the first component seems to be the uptime in seconds
02:23:35 <ongy> ertes-w: https://www.centos.org/docs/5/html/5.1/Deployment_Guide/s2-proc-uptime.html
02:24:11 <ertes-w> ongy: thanks a lot!
02:24:47 <ertes-w> err
02:25:00 <ertes-w> % cat /proc/uptime
02:25:01 <ertes-w> 3590.57 12229.89
02:25:05 <ertes-w> that…  doesn't really make sense
02:25:26 <ertes-w> my system seems super-lazy =)
02:25:46 <ertes-w> to the point that it breaks the laws of physics =)
02:26:43 <kadoban> Maybe one is counted per-core and the other not? *trying to make it fit anything possible*
02:26:44 <geekosaur> how old is the kernel?
02:27:05 * geekosaur recalls there being a (roughly) 49-day wraparound bug at one point
02:27:53 <geekosaur> which might not have been fixed by making the counter larger but instead by handling the wraparound without panic()ing, or something
02:28:19 <ertes-w> Linux elara 4.11.2 #1-NixOS SMP Sat May 20 12:50:04 UTC 2017 x86_64 GNU/Linux
02:28:21 <ertes-w> not very old
02:28:45 <ertes-w> kadoban's conjecture is the most plausible
02:28:56 <cspollard> I have some locations set in my stack.yaml that point to git commits on github
02:29:16 <cspollard> for some reason they randomly get re-checked-out when I "stack build"
02:29:23 <cspollard> does anyone else see this behavior or know how to fix it?
02:30:06 <cspollard> this happens almost every time for some packages
02:30:11 <cspollard> and only seldom for others...
02:30:15 <geekosaur> mm, actually canreproduce here and system is >49 days up. so yes, possibly cores
02:31:45 <ertes-w> geekosaur: i rebooted today, so if that bug exists, it's long from being visible here
02:32:17 <ertes-w> (kinda funny that we still get those 32-bit bugs)
02:33:05 <ertes-w> (kinda stupid that C has 32-bit int even on 64-bit platforms)
02:34:49 <ongy> and that's why you use long long
02:35:06 <ertes-w> or int64_t
02:36:31 <ertes-w> even long long is underspecified, and i bet when we get 256-bit systems, …
02:36:56 <ertes-w> … nevermind…  if we still use C when we get 256 bit systems, we should really revisit our goals as the human race
02:38:09 <phadej> well, with simd we have 256bit systems
02:38:11 <geekosaur> well, arguably the kernel might want to go with 32 bit just to avoid needing a critical section around the update on a 32-bit system
02:38:11 <phadej> today
02:38:13 <phadej> and we use C :)
02:38:20 <geekosaur> or having to do things differently on 32 vs. 64 bit
02:39:05 <phadej> (I don't think that having more than 64bit pointers will be needed any time soon)
02:39:14 <geekosaur> also pretty sure we will still use C for some things. one would hope those things don't include application development, but it's still a good idea for device drivers and such
02:39:15 <phadej> 64bit address space it is
02:39:32 <phadej> geekosaur: i tend to disagree
02:39:52 <phadej> e.g. C++ or Rust is already an improvement
02:39:54 <ertes-w> geekosaur: having int 32 bits on 32-bit systems is fine
02:40:17 <geekosaur> C++ is not suitable for low level device driver development
02:40:26 <geekosaur> Rust, I'm still taking a wait and see approach
02:40:27 <ertes-w> geekosaur: hmm?  why not?
02:40:33 <dysfun> sure it is
02:40:39 <ertes-w> C++ seems fine to me
02:41:03 <dysfun> not quite the way you program userspace c++, but it'll do the job
02:41:15 <geekosaur> using only the C subset of C++ is using C
02:41:24 <dysfun> no, you need not restrict yourself to C
02:41:26 <ertes-w> geekosaur: you can use more than the C subset
02:41:26 <geekosaur> and trying to kid yourself about it
02:41:36 <ertes-w> e.g. templates to get parametric polymorphism
02:41:53 <dysfun> there is clearly an entire rabbit hole under c++ you have not dived into, you lucky thing
02:42:44 <geekosaur> I would be rather leery of using templates any time I have to worry about time constraints, unless I am very very carefully verifying what it expands to
02:42:57 <geekosaur> at which point I might as well just write it out and avoid the extra checking
02:43:10 <ongy> if we want to continue the language discussion, we should probably move to one of the haskell-* channels
02:43:11 <dysfun> it's not just templates
02:43:14 <ertes-w> that's why i find golang so stupid…  it could have been a major improvement over C by adding abstraction capabilities that C needs desparately (IMO), but for some reason it hasn't done that
02:44:24 <ertes-w> → #haskell-offtopic
02:48:59 <Unhammer> I'm connecting from linux with 32-bit wchar_t to a windows thing that writes 16-bit wchar_t's into a pointer I pass in, so can't use peekCWString etc. (since then e.g. what should be [48,49,48,48,48] is read as [3211312,3145776,48,…garbage…])
02:50:10 <geekosaur> you'll need to unmarshal it yourself as Word16s and reconstruct the string. you may need text-icu for that to deal with any surrogate pairs
02:50:17 <Unhammer> figured I could send a Ptr Int16 and then perhaps convert that to Int32 and then run the regular conversion operation, or is there something built-in?
02:50:17 <Unhammer> but I can't even https://www.haskell.org/hoogle/?hoogle=Int16%20%2D%3E%20Int32
02:51:03 <geekosaur> :t fromIntegral
02:51:05 <lambdabot> (Num b, Integral a) => a -> b
02:51:17 <geekosaur> but again, surrogate pairs; you do not want to just convert to Word32
02:51:37 <Unhammer> (or, I'm assuming naive Int16→Int32 will work as long as it's simply UCS-2, probably breaks for high bits like most things =P)
02:51:37 <Unhammer> oh :/
02:52:33 <geekosaur> that's the worst part, it's not simply 'high bit', there are specific ranges that are used to encode larger codepoints
02:52:55 <Unhammer> peekCWString must do something about them too though?
02:54:16 <Unhammer> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Foreign.C.String.html#cWcharsToChars
02:54:16 <Unhammer> hm
02:55:43 <Unhammer> ok, but Word16 is the right type for the array at least
02:55:44 <Unhammer> because Int16 is signed, I see
02:56:32 <geekosaur> Unhammer, only on unix, I think, since wchar_t is 32 bit. and even on windows I'm not sure it does, Windows is all too often an afterthought :/
02:59:55 <Unhammer> Well, the type used in strings shouldn't ever be signed, right?
03:05:32 <locallycompact> how do I use parsec to grab things between braces? this doesn't work
03:05:34 <locallycompact> print $ parse (between (char '{') (char '}') (many1 anyChar)) "" "{foo}"
03:06:18 <quchen> locallycompact: (many1 anyChar) consumes »foo}«, and then you don’t have a closing brace left.
03:06:37 <quchen> locallycompact: Have a look at »manyTill«.
03:11:41 <locallycompact> like this? 
03:11:44 <locallycompact>   print $ parse (between (char '{') (char '}') $ manyTill anyChar (char '}')) "" "{foo}"
03:11:47 <locallycompact> that doesn't work
03:15:22 <quchen> Don’t use between
03:15:37 <quchen> char '{' *> manyTill anyChar (char '}')
03:43:35 <jakub_> i've been using cabal detailed test-suite but it bothers me that whenever my code-under-test emits "error" the suite fails with "no parse" and I have precisely zero information on why that happened.. what can I do about it? (suppose getting rid of all invocations of "error" the proper way is not exactly the best solution for me at the moment)
03:46:35 <boj> jakub_: error just halts execution with a message. if you don't want that behavior you will want to remove it
03:47:33 <jakub_> boj: I get that, I still don't see why the test "framework" cannot produce a meaningful message instead of rather useless "no parse"
03:48:00 <boj> i see. what "framework" are you using?
03:48:05 <jakub_> boj: i.e. the freaking error message and possibly the std(out|err) produce thusfar
03:48:40 <jakub_> boj: I am using cabal test-suite type: detailed-0.9
03:51:02 <boj> i have admittedly never used that before, sorry :/
03:51:16 <jakub_> boj: no problem, what are the alternatives
03:51:29 <boj> jakub_: hspec is fairly nice
03:52:05 <boj> jakub_: quickcheck to supplement. others use something called tasty, and there's boring old hunit
03:52:52 <boj> you can get much more meaningful errors out of any of those
03:54:10 <jakub_> boj: these are morelike unit test frameworks right? I currently have complex scenarios that I need to check (i.e. rather large setup of context) would any of those be suitable?
03:55:01 <piyush-kurur> here is a question regarding copyright. Currently the copyright on raaz is held by me. I feel that it is in some sense unfair as there are other contributors to the project. What is the best way to give credit to their effor?
03:55:04 <boj> jakub_: if you are using detailed to attempt that now then i think any would suffice
03:57:15 <jakub_> boj: imagine I have a piece of code that attempts to solve an undecidable problem, I suspect I don't really want to use quickcheck there, instead I know about scenarios when the code succeeds, so I handcraft the input and check the expected output...
03:58:25 <boj> piyush-kurur: since it's bsd3 simply add them to the license with names/dates contributed?
03:58:48 <ertes-w> jakub_: undecidable?  that means you can't decide it…  that means you can't test it…
03:58:55 <boj> yeah..
03:59:28 <boj> the point of any testing is to take any known input and get an expected output, even if it's just "success" or "fail"
04:05:16 <piyush-kurur> boj: just listing them as git shortlog ? Would that be sufficient?
04:06:56 <geekosaur> jakub_, what do you do if you are expecting JSON and in the middle of it it has an error message? that's essentially what you are doing to the test suite. it's not going to be able to deal.
04:07:15 <jakub_> ertes-w: undecidable means you cannot hope to have an answer to all inputs in finite time, doesn't mean you cannot think of a test that checks input output on instances that you know apriory to terminate
04:07:26 <geekosaur> frameworks like tasty "don't have this problem" because the test framework is baked into your test orogram and aborts when the program does
04:07:35 <boj> piyush-kurur: i am no copyright lawyer, but if you are simply aiming to give credit that should work. maybe add a CONTRIBUTORS file to your repo
04:08:14 <ertes-w> jakub_: then you're testing a decidable subproblem =)
04:09:36 <jakub_> ertes-w: well you aren't testing any problem, you are testing a program and as inputs you allow only decidable things, but at least I have a hard time imagining how to force quickcheck to focus on the decidable fragment ;)
04:10:18 <piyush-kurur> boj: thanks, I have no love left for lawyers particularly the copyright ones. Yes my aim is mostly to give credit otherwise I give a damn about copyright
04:10:59 <locallycompact> when I have a function like this parseQueryExpr here, how do I lift that into a parsec combinator and make all the things line up? https://hackage.haskell.org/package/simple-sql-parser-0.4.2/docs/Language-SQL-SimpleSQL-Parser.html
04:11:05 <ertes-w> jakub_: if you can decide whether the problem is decidable before deciding it, you can use (==>)
04:11:07 <locallycompact> like how do I turn that into a Parser QueryExpr
04:11:21 <ertes-w> @check False ==> False
04:11:23 <lambdabot>  *** Gave up! Passed only 0 tests.
04:11:24 <jakub_> geekosaur: I am just asking how to use something that does not expect a JSON then (I understand where the no parse comes from, it just does not give an excuse for not displaying the cause... the framework has access to the output of the code-under-test, so why cannot it display that along with something less ugly then "no parse"
04:11:47 <ertes-w> @check \x -> even x ==> mod x 2 == 0
04:11:49 <lambdabot>  error:
04:11:49 <lambdabot>  • Ambiguous type variable ‘prop0’ arising from a use of ‘myquickcheck’ preve...
04:11:54 <ertes-w> @check \x -> even x ==> mod (x :: Integer) 2 == 0
04:11:56 <lambdabot>  error:
04:11:56 <lambdabot>  • No instance for (STestable Integer) arising from a use of ‘==>’ • In the f...
04:12:12 <ertes-w> what?
04:12:16 <ertes-w> @check \x -> even x ==> (mod (x :: Integer) 2 == 0)
04:12:18 <lambdabot>  +++ OK, passed 100 tests.
04:12:19 <ertes-w> ah
04:12:23 <ertes-w> jakub_: ^ like that
04:12:55 <jakub_> ertes-w: I cannot decide anything :) i just have a bunch of scenarios that I know from real life that work, and I want to assert that my code produces the correct answer as long as it terminates, if it doesn't terminate I don't really care whether the test diverges or timeouts at this stage
04:13:31 <ertes-w> jakub_: you can test specific instances with quickcheck, if that's all you have
04:13:38 <ertes-w> @check 5^2 == 25
04:13:39 <lambdabot>  +++ OK, passed 100 tests.
04:13:52 <ertes-w> there is also a way to tell it not to generate 100 tests
04:14:26 <ertes-w> @check once (5^2 == 25)
04:14:28 <lambdabot>  error:
04:14:28 <lambdabot>  Variable not in scope: once :: Bool -> prop0
04:14:29 <jakub_> ertes-w: alright, I will try to use quickcheck then (I hope i can avoid running the test 100times :) because my tests take fair amount of time to finish)
04:14:49 <ertes-w> @check Test.QuickCheck.once (5^2 == 25)
04:14:51 <lambdabot>  error:
04:14:52 <lambdabot>  Not in scope: ‘Test.QuickCheck.once’ No module named ‘Test.QuickCheck’ is im...
04:15:01 <ertes-w> jakub_: just use 'once' like that
04:15:24 <jakub_> ertes-w: how would you use quickcheck with cabal?
04:15:37 <jakub_> (what is the proper way)
04:15:58 <ertes-w> jakub_: i would use tasty + QuickCheck with a test-suite section
04:16:42 <ertes-w> jakub_: https://github.com/esoeylemez/skeleton/blob/skeleton/skeleton.cabal#L66
04:17:15 <jakub_> ertes-w: thanks a lot
04:17:41 <ertes-w> jakub_: note: this is *my* way…  the *proper* way is up to debate =)
04:17:52 <jakub_> ertes-w: noted :)
04:58:23 <davr0s> anyone around?
04:59:04 <srhb> davr0s: Lots of people. Just ask. :)
04:59:38 <davr0s> basic syntax.. how do you write constraints for more than one type-parameter,
05:00:18 <srhb> davr0s: (Constraint1, Constraint2, ..., ConstraintN) => ...
05:00:36 <davr0s> e.g.    lerp v0 v1 f  = (v1-v0)*v1+f    ..   lerp:: Num a =>  a->a->a->a  .. but i want v0,v1 to be one type, and f to be another
05:00:57 <davr0s> ok i'll try that..
05:01:51 <davr0s> lerp::(Num a,Num f)=> a->a->f->a         ?
05:01:51 <srhb> davr0s: That won't work still, though, because those operators only accept the same type for both arguments.
05:01:58 <srhb> :t (+_
05:01:59 <lambdabot> error:
05:02:00 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:02:00 <srhb> :t (+)
05:02:01 <lambdabot> Num a => a -> a -> a
05:02:10 <srhb> davr0s: So both sides must have the same type.
05:02:24 <davr0s> ok,
05:02:29 <kuribas> To use the ffi, do I always need to make a dynamic library?
05:03:28 <kuribas> or at least for ghci?
05:04:23 <ongy> unless you recompile your ghci, probably
05:04:30 <nitrix> kuribas: ghci -L. -lfoo
05:04:45 <davr0s> basically what i'm trying to write is the equivalent of this in C++:   template<typename A, typename F>  auto lerp(const A& a, const A& b, const A& f) { return (b-a)*f+a; }
05:05:01 <kuribas> nitrix: foo is a library?
05:05:22 <nitrix> kuribas: libfoo presumably. Have you tried that?
05:05:40 <kuribas> nitrix: I have an object file I need to load...
05:06:09 <davr0s> will i need 'multiparameter typeclasses' etc  to get  multiplication of 'a' and 'f' yielding 'somethign else
05:06:21 <kuribas> "Loading temp shared object failed: /tmp/ghc5713_0/libghc_1.so: undefined symbol: __gxx_personality_v0"
05:07:21 <kuribas> also: ghc: panic! (the 'impossible' happened)
05:07:33 <cocreature> kuribas: you need a c++ lib for that to  work (probably stdc++)
05:09:27 <kuribas> cocreature: ah great, that worked!
05:17:51 <srhb> davr0s: No, you'll just need to convert to the same type on both sides.
05:18:54 <davr0s> what I'm trying to acheive is the ability to plug in overloads , actually saying 'Num' is wrong;  it should be 'anything multiplyable'  ,   e.g.   being able to (lerp point point float)
05:19:13 <davr0s> e.g. in C++ i'd just have   operator*(Point, float)
05:19:31 <davr0s> actually more detail than that,    point-point = offset,     offset*float->offset,    point+offset -> point
05:21:49 <bollu1> quchen: ping
05:23:13 <quchen> bollu: hi
05:25:15 <bollu> quchen: what's the equivalent of ($+$) in prettyprinter? 
05:25:48 <bollu> quchen: that is, force into a new line, don't overlap horizontally even if possible
05:26:05 <osa1> async's poll and wait are useful but I wish we had a `waitTimeout` for killing the thread + returning Nothing on timeout. currently I do something like `timeout t (wait thr) >>= \case Nothing -> do { kill thr; return default } ...`
05:27:23 <quchen> bollu: What do you mean with »don’t overlap horizontally«?
05:28:18 <orion> osa1: That sounds useful. Do you think the author would be receptive to a pull request?
05:28:27 <bollu> Prelude Text.PrettyPrint>    text "hi" $+$  (text "there")
05:28:27 <bollu> hi
05:28:27 <bollu> there
05:28:27 <bollu> Prelude Text.PrettyPrint>    text "hi" $$  (text "there")
05:28:27 <bollu> hi
05:28:27 <bollu> there
05:28:31 <bollu> quchen: whoops
05:28:37 <bollu> quchen: but well, that's the difference^
05:28:44 <bollu> argh, wait.
05:28:47 <quchen> The difference is nothing ;-)
05:29:20 <bollu> quchen: http://lpaste.net/356340
05:29:41 <bollu> quchen: if there is enough space that it can be pushed up without overlapping, then $$ will allow it, $+$ won't
05:30:20 <osa1> orion: I don't know, that's one of the dozens of functions in our `Utils.hs` :-P
05:31:03 <osa1> orion: I think it depends on whether there's enough interest for such a functions but I'd certainly be happy to create a PR and see it merged
05:31:36 <quchen> bollu: Hmmm.
05:31:38 <osa1> also a version in the library may be slightly better. I think there may be enough space between `wait` and `cancel` here for the thread to return.
05:32:45 <quchen> bollu: Well, the short answer is that prettyprinter does not have that as a builtin. I’m wondering how to recreate it though.
05:32:57 <quchen> bollu: flatAlt would be one way, but it’s a sledgehammer.
05:33:07 <bollu> quchen: I don't know how much not having this would affect GHC. bgamari: for now, if ($+$) = $$, will anything break?
05:33:25 <bollu> quchen: prettyprinter doesn't have $$, right?
05:33:31 <quchen> Yes.
05:33:35 <bollu> bgamari: $$ = $+$, sorry
05:33:40 <bollu> right.
05:33:40 <quchen> $$ is »insert newline«, right?
05:33:46 <quchen> a $$ b = a <> line <> b
05:33:58 <bollu> that's ($+$) from what I understand
05:34:08 <bollu> ($$) tries to squeeze stuff horizontally if space permits.
05:34:48 <bollu> squeeze along the vertical* is probably a clearer way of putting it.
05:36:12 <quchen> bollu: I assume »fillBreak« is also subtly different to what you want?
05:36:37 <quchen> I think you can recreate a similar behavior with it though
05:38:55 <bollu> > $$ lhs rhs = fillBreak (getLength lhs) rhs
05:38:57 <lambdabot>  <hint>:1:1: error: parse error on input ‘$$’
05:38:58 <bollu> right?
05:39:02 <bollu> but then, what is "getLength"?
05:40:49 <jakub_> ertes-w: running the same test with quickcheck seems a lot slower, it still prints "passed 100 tests" after modifying the property with "once" am I really running the same test once or 100times? how can I tell (my test lives in IO, might that cause some overhead? currently I do: once $ monadicIO $ assert =<< run ( ... )
05:43:12 <bollu> quchen: ping?
05:43:37 <bollu> quchen: can I use width for this?
05:44:01 <buggerme> Hello. Can anyone help with fnv1Hash? https://www.stackage.org/haddock/lts-8.19/memory-0.14.6/Data-ByteArray-Hash.html#v:fnv1Hash
05:44:21 <bollu> hm no
05:44:26 <bollu> I'm speaking nonsense.
05:45:00 <buggerme> This should work right: fnv1Hash "abc"
05:46:01 <ertes-w> jakub_: weird…  does the same for me
05:46:29 <ertes-w> jakub_: sorry, i don't know why that happens…  perhaps consider using HUnit for that kind of test
05:47:01 <jakub_> ertes-w: ok, so you too think this should behave differently, i am not going crazy :)?
05:48:37 <ertes-w> jakub_: yeah, i would expect it to test only once
05:48:47 <quchen> bollu: Yes, you can use width for that
05:49:07 <quchen> bollu: width doc (\w -> …) produces doc, and gives you its width
05:49:18 <bollu> right, but what I wrote won't quite work, I think
05:49:26 <bollu> inside the …, that is
05:51:54 <quchen> Hmm, tough one
05:53:36 <jakub_> how can I run one test per monadic property with quickcheck? (simple: `once . monadicIO $ assert =<< run ( print "test" >> return True )` doesn't work)
05:54:11 <quchen> bollu: I’m not sure this »overlaps to the left« is something easily recreated. Line breaks are usually made/undone based on reaching too far to the right.
05:54:33 <quchen> bollu: How about you define $+$ = $$ and see how bad the breakage is?
05:54:41 <bollu> quchen: yeah, I'm just doing that now. Let
05:54:46 <bollu> Let's see what happens
05:54:57 <bollu> quchen: how do encode 0-width stuff?
05:55:02 <bollu> :t zeroWidthText
05:55:03 <lambdabot> String -> Doc
05:55:08 <bollu> ^
05:55:37 <quchen> ..?
05:55:44 <quchen> const emptyDoc?
05:55:59 <bollu> hm, but that won't print the string in the output will it?
05:56:18 <bollu> I believe zeroWidthText actually does emit the string at the end, but the algorithm thinks of it as 0-width
05:56:21 <quchen> Hah, then it sounds like cocreature’s problem: have a piece of text and tell the layouter how long it is
05:56:24 <bollu> I suspect they use it for ASCII color codes
05:56:28 <bollu> yes :P 
05:56:46 <bollu> is that not possible?
05:56:47 <quchen> That doesn’t sound like a good idea for color codes
05:56:53 <quchen> Yes, it is
05:56:58 <quchen> But I don’t think it’s a good idea
05:57:05 <bollu> step 1. recreate functionality :)
05:57:12 <bollu> step 2. *rework* functionality
05:57:30 <bollu> quchen: I want to keep the first patch as non-functional change as possible.
05:57:31 <ertes-w> jakub_: quickcheck doesn't really have a concept of compound tests…  you should use a test framework, if you have multiple tests
05:57:51 <quchen> You should annotate the Doc with semantic annotations, such as »keyword«, and then make keywords e.g. red in the renderer. Doc should not know about redness, ever.
05:58:05 <bollu> right, understood
05:58:18 <quchen> bollu: For a hacky version, you can import Doc.Internal and use the Text constructor directly.
05:58:26 <ertes-w> jakub_: all quickcheck gives you is a bunch of TH-based convenience functions, but those do little more than to just write a (traverse_ quickCheck) for you
05:58:31 <bollu>    Pretty.zeroWidthText (Col.renderColour col)
05:58:32 <quchen> It has a field that stores the length of the contained text.
05:58:36 <bollu> ah, OK. ty
05:58:46 <bollu> yeah, they use it for colors. That's a snippet from GHC
05:58:52 <quchen> It should be safe to use, but it should also feel hacky, because it is. :-)
05:58:53 <lyxia> buggerme: you need a type annotation if you're using OverloadedStrings
05:59:23 <bollu> quchen: I will probably keep bugging you for a while :) thanks for the help.
05:59:24 <quchen> bollu: I suggest you create your zeroWidthText function and deprecate it immediately so you don’t forget that part.
05:59:29 <bollu> yep
05:59:39 <bollu> quchen: sidenote - how does one mark a function as deprecated?
06:00:04 <ertes-w> jakub_: have a look at frameworks like hspec, tasty and test-framework
06:00:05 <quchen> There’s a GHC flag to do this, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#warning-and-deprecated-pragmas
06:00:11 <jakub_> ertes-w: this is not really a compound test, or at least the problem is not in it being compound
06:00:21 <ertes-w> jakub_: i use tasty
06:01:21 <bollu> cool, thanks!
06:01:27 <ertes-w> jakub_: i mean: quickCheck really only tests a single property…  if you need to test multiple properties, you should use a framework =)
06:02:11 <jakub_> ertes-w: i am not at the stage of testing multiple properties, i am trying to test a monadic action, once, not 100times
06:02:28 <ertes-w> jakub_: doing that pays off very quickly: you get a nice command line interface, concurrently running tests, nicely formatted output and proper error handling
06:03:00 <ertes-w> ah, then i misunderstood
06:03:35 <ertes-w> jakub_: yeah, as noted i don't know why that happens…  i would expect it to run once…  HUnit is specifically made for those one-shot assertion-based tests, so perhaps use that instead of QuickCheck
06:04:13 <jakub_> ertes-w: i will, but now it bothers me why i cannot do it with quickcheck :D
06:05:28 <ertes-w> jakub_: if you want an answer, report it as a bug =)
06:09:04 <bollu> quchen: can you show me an example file?
06:09:47 <bollu> quchen: I placed it both at the top of the file, and right after the module exports: Module Pretty (…) {-# DEPRECATED … #-} where
06:09:54 <bollu> got compile errors on both?
06:12:17 <quchen> bollu: Put it right at the definition site, just like you would with INLINE
06:12:56 <quchen> bollu: Deprecating whole modules is done at the very top, but definitions are deprecated at their ummm definition
06:13:30 <bollu> ah, I see :)
06:14:51 <bollu> ty
06:21:04 <jakub_> ertes-w: it was a bug in QC 2.9, it seems to work in QC 2.10
06:22:02 <ertes-w> ah
06:33:28 <marinelli> hi everyone
06:33:53 <marinelli> I've a question about the machines library
06:33:56 <ADG> I am getting this problem that missing packacges, how to fix them: https://hastebin.com/agiyezosek.sql
06:35:18 <Axman6> marinelli: would you like to share it? :)
06:35:34 <ADG> I saw this but I don;t use cabal: https://stackoverflow.com/questions/7961604/fixing-issues-noted-by-ghc-pkg-check
06:36:27 <marinelli> q: how would you put a delay for the await combinator?
06:41:10 <ertes-w> marinelli: you mean an actual sleep?
06:41:47 <marinelli> a machine awaiting for something in input, could block the computation. it would interesting to build a machine that, after a certain amount of time awaiting for something in input, could yield a default value in output
06:42:10 <marinelli> ertes-w: a sort of timeout
06:42:51 <ertes-w> marinelli: an 'await' will only ever return when a corresponding 'yield' is executed
06:43:02 <ertes-w> marinelli: so you have to encode that delay in the producer
06:43:05 <ertes-w> s/delay/timeout/
06:43:32 <ertes-w> marinelli: you can use System.Timeout in most simple cases
06:43:56 <Unhammer> should it be possible to use C foreign functions from ghci?
06:44:10 <Unhammer> if I set LD_LIBRARY_PATH to where the .so file is and use '-l' ?
06:44:16 <Unhammer> (as in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extra-libraries )
06:44:43 <Unhammer> because I'm getting
06:44:45 <Unhammer> ghc: panic! (the 'impossible' happened)
06:44:49 <Unhammer>         Loading temp shared object failed: /tmp/ghc27736_0/libghc_13.so: undefined symbol: SQLDriverConnectW
06:45:07 <Unhammer> (where SQLDriverConnectW is defined in that lib)
06:46:07 <marinelli> yeah, exactly, I was having a look at System.Timeout.timeout
06:46:23 <kuribas> Unhammer: I just had the exact same question :)
06:46:51 <kuribas> Unhammer: yes, start ghci with the modules you need to load, like ghci -lmylib myobject.o
06:46:57 <kuribas> Unhammer: the order matters
06:47:24 <ertes-w> marinelli: of course you can only timeout a raw IO action, but as i said: in simple cases that might be enough
06:47:31 <Unhammer> I don't have a myobject.o that I know of though …
06:47:42 <kuribas> Unhammer: it was just an example
06:47:45 <Unhammer> LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu/odbc/ stack exec ghci -- -ltdsodbc
06:47:47 <Unhammer> is what I'm doing
06:47:47 <kuribas> Unhammer: you can have only libraries
06:47:57 <ertes-w> marinelli: if you need something more sophisticated, you need to use actual concurrency instead of coroutines a la machines…  or a hybrid of both like the 'concurrent-machines' library
06:48:13 <Unhammer> (if I leave off the LD_LIBRARY_PATH, it can't find the lib, so it's obviously doing something right)
06:48:52 <marinelli> ertes-w: I was also investigating the use of concurrent-machines, but without success :-)
06:49:39 <noobst> learning me a haskell trying to run some examples that contain function signatures eg: `lucky :: (Integral a) => a -> String` but this will produce error in the REPL
06:50:01 <noobst> is it not meant to be run?
06:50:27 <cocreature> noobst: can you be a bit more specific? what exactly did you type in the repl and what was the error you got?
06:50:45 <noobst> typed:  lucky :: (Integral a) => a -> String
06:50:59 <kuribas> Unhammer: try giving the whole path on ghci?
06:51:10 <cocreature> noobst: you need the definition of the function as well not only the type signature
06:51:11 <ertes-w> marinelli: is 'timeout' not good enough for your use case?
06:51:32 <kuribas> Unhammer: also are you sure that function isn't in another library?
06:51:57 <noobst> cocreature: but how am i meant to run both lines as a statement? i'm running the first example from this page: http://learnyouahaskell.com/syntax-in-functions
06:51:59 <Unhammer> $ objdump -T /usr/lib/x86_64-linux-gnu/odbc/libtdsodbc.so|grep SQLDriverConnectW
06:52:01 <Unhammer> 0000000000012f20 g    DF .text  0000000000000021  Base        SQLDriverConnectW
06:52:09 <osa1> ugh.. I was wondering why my "interruptable" annotation was causing compiler errors.. turns out it's "interruptible", not "interruptable"
06:52:25 <Unhammer> ghci fails if I give the whole path for -l
06:52:32 <cocreature> noobst: you can enter multiline mode with :{ and when you’re done with the definition enter :}
06:53:59 <kuribas> Unhammer: give the path with -L/the/path ?
06:54:07 <cocreature> noobst: but for learning purposes I would recommend just typing definitions in a Haskell file and then loading that in ghci via ":l FileName.hs". ghci behaves slightly different than ghc does when you compile your program and these differences can be confusing when you’re starting out
06:55:45 <noobst> cocreature: yes your suggestion works. i think the author's intent is to type the examples out in a file and either :l or :r and then interactively call the functions
06:55:51 <noobst> cocreature: and thanks :)
06:56:24 <racketschemer> Hello, what is the difference between an IORef and a StateVar?
06:56:27 <kuribas> Unhammer: stack exec ghci -- -L/usr/lib/x86_64-linux-gnu/odbc/ -ltdsodbc
06:57:04 <Unhammer> didn't hepl :/
06:57:10 <Unhammer> thought that was path to .h files?
06:57:13 <Unhammer> -L that is
06:58:18 <kuribas> no
06:58:58 <Unhammer> ok, I see by including -L I can leave off the LD_LIBRARY_PATH without it complaining about not finding the fn
06:59:16 <Unhammer> still fails as soon as I try to actually run a function
07:01:02 <MitchellSalad> racketschemer: a StateVar is a pair of a getter and setter in IO
07:01:23 <MitchellSalad> you can certainly do that with IORefs, and much more, too, like compare them for equality
07:01:51 <MitchellSalad> but other types like foreign pointers fit the StateVar API
07:02:26 <racketschemer> OK, thanx!
07:11:16 <MitchellSalad> sure!
07:12:31 <marinelli> ertes-w: https://imgur.com/a/HIyJu this is a schema of what I'm modelling
07:13:05 <marinelli> ...and all the streams depend on time
07:15:05 <ertes-w> marinelli: do you need time as a stream input?  i mean: couldn't you just use time/getCurrentTime or clock/getTime from within the consumer?
07:15:24 <marinelli> in other words, I would like to have a machine that do a computation on the stream A, and this computation should depend on a state and another stream
07:15:57 <ertes-w> yeah, so far that's nothing special…  need more info =)
07:16:28 <marinelli> with "all the streams depend on time" I mean that I do not know if I will find something and when inside it
07:17:43 <ertes-w> ah
07:18:21 <ertes-w> marinelli: could you explain your application?
07:18:30 <ertes-w> that would make it easier to suggest a good solution
07:47:59 <marinelli> ertes-w: imagine you want to process an input stream S1 of integers with a machine A. inside this machine, there's a boolean state. this state is updated independently by a second machine B that has in input a second stream S2 of booleans, every time it receives a new boolean value it updates the state. the computation that you want to execute on the first input stream S1 is the following: if the current state is true you want to ad
07:54:20 <ertes-w> marinelli: your message got cut off after "if the current state is true you want to ad"
07:55:11 <ertes-w> IRC has a classic 80's line length limit to round off the awfulness of IRC
07:56:16 <marinelli> ertes-w: I think is something related with your client
07:56:42 <merijn> marinelli: No, it's an issue with your client. There is a maximum size on the server side
07:56:49 <ertes-w> marinelli: no, even if your client displays the full message, the server cuts it off, and everyone else sees only a prefix of it
07:56:52 <merijn> Most clients auto split messages into multiple ones
07:56:53 <marinelli> is it?!
07:57:00 <merijn> Yours apparently doesn't
07:57:11 <marinelli> I'm using webchat.freenode.net
07:57:12 <marinelli> sigh
07:57:18 <ertes-w> marinelli: welcome to IRC =)
07:57:27 <ertes-w> the worst protocol since telnet
07:57:34 <merijn> ertes-w: pfft
07:57:40 <merijn> IRC isn't that bad
07:57:41 <marinelli> yeah, I know, I spent years over it
07:57:51 <merijn> There's like a million worse protocolswq
07:58:13 <ertes-w> merijn: that doesn't make IRC "not that bad" =)
07:58:23 <merijn> ertes-w: You said "worst"
07:58:24 <quchen> Unexpected T_PAAMAYIM_NEKUDOTAYAM
07:58:40 <ertes-w> merijn: since telnet =P
07:58:41 <quchen> There you go, the worst protocol. (Keep the typo.)
07:58:45 <merijn> ertes-w: Since, I would argue the majority of protocols is *worse* than IRC, that's clearly false
08:01:39 <marinelli> ertes-w: https://imgur.com/a/XoN0F
08:02:14 <marinelli> :-)
08:02:39 <ertes-w> marinelli: hah!  well, do you have a way to push the state to the haskell program?
08:02:57 <ertes-w> then all you need is an MVar/TVar
08:03:44 <marinelli> yes, MVar was my personal choice
08:03:46 <ertes-w> marinelli: for example you can build a very small RPC server into your program using e.g. scotty or even servant
08:04:14 <ertes-w> if that's not possible, you can still use the MVar approach by writing a separate poller thread
08:04:27 <ertes-w> in any case the state should probably not be an input stream, but just a consumer effect
08:05:27 <marinelli> well, I would like to update the state using the values from the stream B
08:09:49 <ertes-w> marinelli: ah…  i misunderstood your architecture
08:10:00 <ertes-w> well, to me it seems like the two machines are mostly unrelated
08:10:10 <mrkgnao> does anyone remember what package it was that wrapped variables in such a way that accesses would be counted/logged?
08:10:14 <mrkgnao> (ofc unsafely)
08:10:29 <mrkgnao> I think it was a nomeata package, but I'm not sure.
08:11:01 <ertes-w> mrkgnao: Debug.Trace?
08:12:08 <ertes-w> marinelli: i think the two machines shouldn't be connected at all…  they should run concurrently and share an MVar/TVar/…
08:12:52 <marinelli> ertes-w: exactly, they are not related
08:13:39 <mrkgnao> ertes-w: no, it provided some kind of wrapper. somewhat vaguely like a symbolic variable, but you could access all kinds of funny heap information.
08:14:43 <marinelli> ertes-w: ok, so I can create two completely distinct machines
08:15:30 <OS-16011> hello fellow internet addicts, are we all looking forward to another long & glorious day of irc, internet browsing, sipping coffee, satiating our ocd addiction to technology?
08:16:23 <ertes-w> mrkgnao: well, you might be able to find it through the reverse dependencies of ghc-heap-view
08:16:45 <ertes-w> mrkgnao: most packages that provide access to the heap do it through that package
08:16:55 <marinelli> ertes-w: with "run concurrently" you mean using two different threads
08:17:05 <ertes-w> marinelli: yeah
08:17:41 <ertes-w> marinelli: the async library is useful for that
08:18:37 <marinelli> ertes-w: yeah, perfect. I'm reading now the source code of concurrent-machines, in that case concurrent means running concurrently all the machines of a pipeline chain
08:19:37 <ertes-w> marinelli: in that case you wouldn't even use concurrent-machines, but just plain concurrency with two runTs
08:19:43 <ertes-w> running concurrently
08:20:06 <marinelli> ertes-w: yeah yeah, exactly. perfect
08:20:57 <marinelli> anyway, the machines library and all of its relatives need a paper that explains better their meanings :-)
08:23:29 <ertes-w> or a blog post =)
08:23:42 <ertes-w> papers tend to be loooong and dryyyyy =)
08:25:56 <mrkgnao> ertes-w: good idea, thank you.
09:04:24 <mrkgnao> @pl flip ap (flip (.))
09:04:25 <lambdabot> (`ap` flip (.))
09:04:32 <mrkgnao> :t ap
09:04:32 <Sh4rPEYE> Hey. Could somebody please look at this? 
09:04:33 <Sh4rPEYE> http://lpaste.net/5990022314559799296
09:04:33 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:06:48 <Sh4rPEYE> Oh, never mind
09:48:31 <steven_is_false> How would I interpret the propositions in this post as types https://math.stackexchange.com/a/2328390/239001 ?
09:48:50 <steven_is_false> I think I want data Odd f a = forall b. Id (f b) (b -> a) and newtype Odder f a = Id2 (forall b. (a-> b) -> f b)
09:49:10 <steven_is_false> But I'm not sure I understand them.
09:50:16 <mniip> steven_is_false, Odd is called Coyoneda
09:51:01 <steven_is_false> mniip: Thanks.
09:51:30 <mniip> not sure about Odder. as far as I can tell it's not Yoneda
09:51:37 <mniip> or is it
09:52:14 <mniip> yeah no
09:52:26 <mniip> Yoneda is for contravariant functors
09:52:29 <steven_is_false> mniip: It is https://hackage.haskell.org/package/kan-extensions-5.0.2/docs/Data-Functor-Yoneda.html
09:52:58 <mniip> oh oops I was looking at Data.Functor.Contravariant.Yoneda
09:53:21 <mniip> didn't realize there was two of both
09:54:56 <steven_is_false> So the yoneda/coyoneda stuff can be interpreted to mean that a set is equal to the intersection of all its supersets or the union of all its subsets?
09:56:24 <mniip> er?
09:57:01 <steven_is_false> mniip: I originally got down this root by thinking about logical propositions https://math.stackexchange.com/questions/2328080/is-it-the-case-that-a-proposition-is-equal-to-the-product-of-all-propositions-im/2328390#2328390
09:57:51 <steven_is_false> Has anyone ever used Coyoneda or Yoneda in real applications? 
09:58:03 <steven_is_false> The only possible use I can imagine are for CPS style optimizations.
09:58:50 <steven_is_false> mniip: Anyway thanks.
09:59:22 <fluffypoodle789> Hi
09:59:54 <fluffypoodle789> Sup
10:18:20 <lamefun_> Why is callCC :: ((a -> m b) -> m a) -> m a instead of ((forall b. a -> m b) -> m a) -> m a ?
10:19:59 <Akii> sorry for the buzzword but anyone using pipes/conduit/machines to build "reactive streams"?
10:20:17 <dolio> Rank-2/n types weren't very well established back when the class with callCC was made.
10:20:31 <MitchellSalad> that is the more correct type, lamefun_ 
10:25:27 <lamefun_> How is it more correct? Can't I just do this just as safely? http://lpaste.net/4992215542417850368
10:27:13 <lamefun_> To wrap the escape function immediately I mean.
10:27:36 <paolino_> hi I'd like to use Data.Machine.Wye , is there an example around ?
10:27:46 <MitchellSalad> It's more correct in the sense that the existing version of callCC will give you a type error in cases that it needn't
10:28:02 <MitchellSalad> e.g. using the same current continuation at two different result types
10:30:04 <lamefun_> Why can't forall b. simply be added?
10:31:36 <MitchellSalad> it would be a breaking change, also I'm not sure if transformers is trying to remain haskell '98
10:32:37 <lamefun_> Why would they try to remain Haskell 98 in 2017 O_o?
10:32:50 <cocreature> Akii: can you explain what exactly you mean by a “reactive stream”? buzzwords have the problem that more often than not there is no clear definition
10:33:05 <MitchellSalad> lamefun_: why not?
10:34:11 <Akii> cocreature: one second
10:35:00 <lamefun_> Is there a more modern transformer library?
10:35:31 <Cale> Not really.
10:35:50 <MitchellSalad> yeah, mtl or monads-tf
10:36:00 <MitchellSalad> but they don't have the rank 3 callCC
10:36:14 <lamefun_> I mean just modern ContT. StateT and others are OK.
10:36:16 <Cale> Those depend on transformers don't they?
10:36:27 <MitchellSalad> ya, but they're more modern :)
10:36:36 <Cale> I suppose
10:36:44 <Cale> They just add the MonadX type classes
10:36:56 <cocreature> lamefun_: how would a more modern StateT look like?
10:37:00 <dolio> mtl predates every other monad library that people use.
10:37:06 <Cale> transformers only contains the definition of the types and the basic operations
10:37:46 <MitchellSalad> speaking of which, why was the instance for 'MonadCont (StateT m)' given the non-law-abiding version of callCC?!
10:37:57 <Cale> transformers is just the part of mtl which can be done in Haskell 98, pretty much
10:38:16 <Cale> MitchellSalad: oh?
10:38:31 <Akii> cocreature: first of all, my problem. I've a program that does GC a lot while idling. The more stuff I pump into my pipes the more GC it does, constantly, all the time.
10:38:45 <Cale> I imagine the reason is "nobody thought about it, because confusing"
10:39:05 <dolio> Which instance is it?
10:39:10 <MitchellSalad> someone definitely thought of it; transformers gives both versions =P
10:39:16 <MitchellSalad> liftCallCC and liftCallCC'
10:39:35 <dolio> Is it the one that makes State Cont the same as Cont State?
10:39:46 <MitchellSalad> dolio: no, that's the law-abiding version
10:40:08 <Cale> https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control.Monad.Cont.Class.html
10:40:09 <dolio> Why is that law abiding/
10:40:10 <MitchellSalad> I might have that backwards actually
10:40:22 <MitchellSalad> yeah, I do
10:40:30 <MitchellSalad> State Cont and Cont State both persist state changes thru a callCC
10:40:35 <Cale> https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.State.Lazy.html#liftCallCC
10:40:54 <Akii> cocreature: so what I do is basically have a source of events coming from the DB, then some processing, finally a fold. Long running fold of course, there for actually a scan. Conceptually a fold though.
10:40:56 <MitchellSalad> whereas to satisfy the "uniformity property", State Cont should roll back state changes
10:40:57 <dolio> Anyhow, I think the reason was that someone thought that control effects rolling back the state was 'weird' at some point way back.
10:41:08 <dolio> Because it doesn't happen in Scheme.
10:41:33 <dolio> So they picked the instance that behaves like Scheme, even though you can already get it by reversing the transformer order.
10:42:05 <Cale> That seems plausible
10:42:14 <Cale> But silly
10:42:18 <dolio> Yeah.
10:43:29 <Cale> and it'll probably screw up someone's stuff to change it now
10:43:59 <MitchellSalad> @unmtl ContT r (State s) a
10:43:59 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
10:43:59 <dolio> I don't know, I'm kind of skeptical about that.
10:44:01 <cocreature> Akii: I’m still not seeing where reactive streams come in or what the problem is you’re trying to solve. that GC happens if you allocate things which you are probably doing by puming things into your pipes seems pretty natural
10:44:03 <Cale> Though honestly, how often do people really use ContT
10:44:06 <MitchellSalad> @unmtl StateT s (Cont r) a
10:44:06 <lambdabot> s -> (a -> s -> r) -> r
10:44:39 <MitchellSalad> are those isomorphic? *squint*
10:44:49 <dolio> No.
10:44:54 <mniip> no
10:45:04 <MitchellSalad> because?
10:45:16 <mniip> they're different monads
10:45:41 <MitchellSalad> but callCC and get/put/modify behave the same for each
10:45:46 <mniip> the latter has a global state shared beteween continuations
10:45:54 <Akii> cocreature: okay forget about the reactive part; it's just a stream. My problem with the GC is that it does it constantly, currently needs around half a CPU for nothing.
10:46:00 <mniip> the former does the opposite - everything has a local state
10:46:17 <MitchellSalad> i think you have that backwards, mnipp?
10:46:26 <mniip> hmm, maybe
10:46:45 <mniip> my understanding of Cont is mediocre at best, left alone ContT
10:46:57 <cocreature> Akii: it’s hard to tell what causes GC without seeing your program or at least parts of it
10:47:15 <dolio> MitchellSalad: Well, one thing I mentioned is that in one order you get a choice of which behavior to pick, and in the other you don't.
10:47:16 <cocreature> Akii: you might also want to take a look at https://inner-haven.net/posts/2017-05-08-speed-up-haskell-programs-weird-trick.html
10:47:44 <dolio> The fact that you picked the behavior that corresponds to the no-choice version doesn't mean you didn't have a choice.
10:47:52 <MitchellSalad> dolio: right, but assuming liftCallCC' does not exist - are they the same monad stack?
10:47:59 <dolio> It does exist.
10:48:10 <MitchellSalad> I know, haha
10:48:11 <lamefun_> So this is sane? http://lpaste.net/1028436859694350336
10:48:21 <MitchellSalad> I mean do State and Cont commute in the same way that Reader/Writer/State all commute?
10:48:39 <dolio> Not sure. I guess.
10:48:49 <MitchellSalad> I think the answer is definitely no but I couldn't explain why at the moment
10:49:31 <MitchellSalad> Cale: never
10:50:07 <dolio> MitchellSalad: I mean, if you pick r = (r, s) for the latter, then you get the type of the former.
10:50:12 <osa1> the C program `int main() { sleep(100); return 0 }` waits 100 seconds before returning, but Haskell program `foreign import ccall "sleep" CUInt -> IO (); main = sleep 100; return ()` returns immediately. any ideas why?
10:50:17 <Cale> MitchellSalad: A funny thing is that Cont on its own is kind of "the same thing" for many purposes.
10:50:41 <haldean> hey all. is there something in base that takes a list of monadic values and returns the first "successful" one? under the maybe monad, for example, it would return the first item in the list that was Just x, or if all were nothing, it would return Nothing
10:50:55 <Cale> In that you're producing a result of type r in the end, which might as well be some type of action.
10:51:07 <lamefun_> Why is Cont there if it is never used?
10:51:19 <Cale> I've used Cont, but not ContT
10:51:19 <MitchellSalad> Cale: yeah, I think of a lone Cont as Identity
10:51:25 <MitchellSalad> but ContT fries my brain
10:51:38 <Cale> > runCont . sequence . map cont
10:51:40 <lambdabot>  error:
10:51:40 <lambdabot>      • No instance for (Typeable a0)
10:51:40 <lambdabot>          arising from a use of ‘show_M844194642805964679531229’
10:51:41 <Cale> :t runCont . sequence . map cont
10:51:43 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
10:51:58 <Cale> ^^ basically, I've only ever used Cont for this sort of trick
10:52:20 <MitchellSalad> neat
10:52:38 <Cale> haldean: msum
10:52:41 <Cale> :t msum
10:52:42 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
10:52:56 <haldean> Cale: thank you!
10:52:58 <Cale> there's probably a name for the "Alternative" version of that
10:53:03 <MitchellSalad> :t asum
10:53:04 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:53:19 <Cale> ah, good :)
10:53:33 <cocreature> osa1: huh interesting. sadly I don’t know the answer to your question
10:53:59 <Akii> cocreature: thanks for the link! That does significantly reduce cpu usage (of course). What I basically do is a ton of record updates. Much garbage. What I don't understand is that once I'm done catching up (producing garbage) all thread should yield waiting for new events.
10:54:09 <Cale> It's still so weird to me that Foldable is so pervasive now
10:54:23 <Cale> I'm always surprised to see it still
10:54:23 <geekosaur> osa1, because C isn't firing an itimer every 0.01s
10:54:48 <Akii> so this stream comes to an end after 3 seconds, after I cought up on the 120k events or so I have. It should be doing nothing yet GC is very busy :D
10:54:49 <MitchellSalad> Cale: why's that?
10:54:52 <geekosaur> and sleep() uses alarm() and catches the next SIGALRM to come in, which will be the itimer
10:55:50 <Cale> MitchellSalad: I guess because Foldable wasn't very commonly used prior to this -- at least in my code.
10:56:51 <geekosaur> osa1, try it with +RTS -V0
10:57:59 <osa1> geekosaur: that seems to work although I'm not sure what it did
10:58:08 <geekosaur> it disabvled the itimer
10:58:28 <MitchellSalad> Cont/State weirdness: http://lpaste.net/356354
10:58:54 <cocreature> Akii: sorry without seeing the code I really can’t help you here. I guess you could try profiling and see if that helps you figure out what is being allocated
10:59:10 <osa1> geekosaur: do you know what parts of RTS code are relevant? I want to take a look
10:59:12 <geekosaur> this is something you do sometimes have to deal with, in particular the itimer plays badly with some versions of systemd-networkd
10:59:53 <Akii> cocreature: I could give you access on gitlab if you want
10:59:58 <Akii> eeer bitbucket
11:00:00 <geekosaur> osa1, no. I'm basically explaining the RTS -V docs to you :)
11:00:08 <Akii> there are clearly too many git services out there :D
11:00:24 <osa1> geekosaur: I'm actually trying to debug a code that uses a blocking FFI call, do you know any better way for this? sleep() seems too fragile because of this itimer stuff and I don't want to use -V0 without understanding the implications
11:00:30 <Cale> MitchellSalad: That last example... how does that typecheck?
11:00:44 <cocreature> Akii: try reducing it to a somewhat minimal example that you can publicly share
11:00:50 <MitchellSalad> oh, I edited the paste
11:00:58 <Cale> oh
11:01:03 <Cale> okay, cool
11:01:13 <Akii> cocreature: I'll try, might take a while
11:01:20 <Akii> thanks though! :D
11:01:31 <geekosaur> osa1, I don't actually know what is happening, the default *should* be 'safe' and not 'interruptible' but the itimer is apparently still running anyway. I don't know why; this is probably a question for #ghc
11:02:18 <Cale> MitchellSalad: Well, the third example is now just what the "correct" instance would do.
11:03:06 <Cale> It's actually quite sad, now that I think about it more, that this isn't what happens.
11:03:25 <geekosaur> -V0 changes thread scheduling (all threads run until their next allocation instead of being preemptible) and changes gc behavior slightly (iirc, allocations always have to check if a gc is needed instead of skipping it if there's room in the nursery and the timer hasn't counted enough)
11:03:26 <Cale> It agrees with other applications of StateT, e.g. with []
11:03:54 <osa1> geekosaur: it seems like -V0 completely disabled the scheduler...
11:04:15 <osa1> oh just saw your message. yeah my threads don't do any allocations maybe that's the reason
11:04:19 <geekosaur> then your code isn't doing enough allocations :)
11:05:11 <MitchellSalad> yeah, I'm not seeing why the instance uses liftCallCC'
11:05:23 <geekosaur> I suppose you could try using a C wrapper that saves and restores the itimer around the actual call, but I'd want to talk with an RTS expert first (again, #ghc is your best bet)
11:05:28 <MitchellSalad> if it didn't, and you wanted a "global" state, you could put State inside of Cont
11:05:29 <Cale> Well, it's probably for the reason dolio mentioned.
11:05:48 <Cale> That someone thought it was "weird" for the state to roll back.
11:06:03 <Cale> But it's very natural if you've ever used StateT s []
11:06:04 <MitchellSalad> why, though? Writer rolls back, for example (because it has to)
11:06:09 <dolio> It's definitely the reason. One of the earliest papers on monad transformers has a bit in it saying, "this rollback behavior is weird."
11:06:14 <osa1> geekosaur: could you name some itimer-related libc/system call functions? not sure which man pages to look at
11:06:29 <geekosaur> 'man 2 setitimer'
11:06:54 <osa1> thanks
11:07:02 <dolio> Well, that's not a quote.
11:07:09 <dolio> It's a paraphrase.
11:08:09 <MitchellSalad> > runCont (runWriterT (callCC (\k -> tell [5] >> k ()))) id
11:08:11 <lambdabot>  ((),[])
11:08:13 <geekosaur> oh, I know why it's still running, other threads will still be running and need it
11:08:22 <geekosaur> so turning it off would be problematic for other threads
11:08:38 <MitchellSalad> > runCont (runStateT (callCC (\k -> put [5] >> k ())) []) id
11:08:40 <lambdabot>  ((),[5])
11:08:45 <geekosaur> basically you need to rethink this because the API you are calling is not going to play well with multiple threads
11:08:54 <Cale> > runCont (runWriterT (liftCallCC' callCC (\k -> tell [5] >> k ()))) id
11:08:56 <lambdabot>  error:
11:08:56 <lambdabot>      Variable not in scope:
11:08:56 <lambdabot>        liftCallCC'
11:09:23 <Cale> @let import Control.Monad.Trans.State (liftCallCC, liftCallCC')
11:09:24 <lambdabot>  Defined.
11:09:27 <Cale> > runCont (runWriterT (liftCallCC' callCC (\k -> tell [5] >> k ()))) id
11:09:29 <lambdabot>  error:
11:09:29 <lambdabot>      • Couldn't match expected type ‘WriterT
11:09:29 <lambdabot>                                        w (ContT (a, w) Identity) a’
11:09:36 <Cale> oh, derp
11:09:39 <Cale> @undefine
11:09:39 <lambdabot> Undefined.
11:09:45 <osa1> geekosaur: I don't think (although I can't verify) FFI functions I'm calling are actually calling sleep()-like functions, I'm just trying to emulate a blocking FFI call here
11:10:07 <geekosaur> yes, and it needs to be aware that it is not the sole owner of the process
11:10:13 <osa1> geekosaur: for some reason I can't interrupt my "interruptible" FFI calls in my main program that I'm trying to debug
11:10:23 <geekosaur> part of the reason I know about this is I diagnosed a similar bug in dbus
11:10:35 <osa1> geekosaur: is it to avoid messing with signal handlers?
11:10:37 <geekosaur> which caused systemd-networkd to malfunction under some circumstances
11:10:47 <dolio> I guess they don't say it's weird, but they refer to the roll-back as "debugging semantics" and the one that gets used as "usual semantics".
11:10:57 <dolio> So that's kind of a bias.
11:11:20 <geekosaur> osa1, if it blocks, it is "sleep()-like"
11:11:40 <geekosaur> this is one of the corners of multithreaded programming that C programmers often get wrong (see above about dbus)
11:11:51 <dolio> And they choose the "usual" semantics instead of debug.
11:11:52 <lamefun_> I thought and thought and still can't think of a reason why http://lpaste.net/1028436859694350336 would not be sane. If the statement after cont a is reached, isn't it clearly a bug in the MonadCont implementation of that particluar monad?
11:11:56 <torstein> I have a function which takes an array of numbers (IsNum a) and which should return an array of Floats.. Is that possible in Accelerate? Maybe it's the same as in vanilla haskell. I can't do fromIntegral because inputs might be floats, and for some reason I get that "Module Accelerate does not export 'toFloating'"
11:12:33 <MitchellSalad> developing an intuition for ContT is really hard!
11:12:42 <torstein> I want to do this: http://lpaste.net/356357
11:13:21 <MitchellSalad> I suppose the only reason to use ContT is for callCC, yes? Otherwise if you're just trying to reassociate binds / invert control, you'd use codensity?
11:13:22 <dolio> lamefun_: Why don't you pick b=Void?
11:13:26 <geekosaur> osa1, there are things that are per thread and things that are per process. C programmers often think the per-process stuff is per thread, which leads to this kind of bug
11:13:33 <Athas> torstein: what about toRational?
11:14:03 <cocreature> torstein: are you sure you’re using the right version of accelerate (i.e. one that contains toFloating)
11:14:05 <torstein> Athas: same error: Accelerate does not export toRational
11:14:15 <cocreature> torstein: the module is called Data.Array.Accelerate
11:14:16 <osa1> geekosaur: to be more specific, I'm trying to interrupt curl's curl_easy_perform(). I think curl would get it right but I'm not sure
11:14:36 <lamefun_> dolio: so that the cont function can be used anywhere, not just in places that expect Void.
11:14:46 <dolio> You can turn a Void into anything else.
11:14:48 <torstein> cocreature: Yes, that's the package I'm using 
11:15:05 <cocreature> torstein: that’s not a package, that’s the module you need to import.
11:15:21 <torstein> yes that's the one I'm importing
11:15:30 <Athas> torstein: toRational is in Prelude.
11:15:34 <cocreature> torstein: your error message claims you are importing "Accelerate"?
11:15:38 <lamefun_> How can I turn Void into anything?
11:15:38 <Athas> But Accelerate defines a Real instance for Exp.
11:15:40 <cocreature> not Data.Array.Accelerate
11:15:56 <torstein> cocreature: No I just abbreviated
11:16:00 <MitchellSalad> :t absurd
11:16:01 <lambdabot> Void -> a
11:16:07 <cocreature> torstein: which version of accelerate are you using?
11:16:13 <MitchellSalad> lamefun_: like that
11:16:32 <lamefun_> But isn't it the same behavior? Crash if reached?
11:16:47 <MitchellSalad> yeah
11:17:12 <ReinH> What idiot called it absurd and not exFalso
11:17:21 <torstein> cocreature: accelerate 0.15.1.0
11:17:31 <Akii> cocreature: that's pretty much the gist of it http://lpaste.net/356358
11:17:44 <glguy> ReinH: Probably someone who specifically wanted to lower you to name calling?
11:18:18 <cocreature> torstein: "toFloating" is only be in 1.0 so you need to upgrade
11:18:50 <ReinH> glguy: Sorry, "what idiot" is a meme, not an actual claim that someone was an idiot.
11:18:51 <lamefun_> If I replace forall void. with Void, won't callCC users have to use absurd (cont a) all the time? The point of my function is to make callCC more convenient, not less.
11:18:53 <Athas> Oh my.  Didn't Accelerate use to just define Num instances and the like?  Did this change in 1.0?
11:19:17 <MitchellSalad> ReinH: I thought it was a joke because ed kmett is the author =P
11:19:41 <ReinH> MitchellSalad: I thought it went without saying that Ed is not an idiot and I don't think he is an idiot.
11:19:56 <MitchellSalad> that's why it was an obvious joke!
11:20:06 <ickabob> Hi /#haskell, I'm trying to better understand the GHCs Haskell RTS.  I have a program that does some non-trivial FFI and I'm hoping to step through the linked C source /w debug symbols via GDB after establishing an environment w/ GHCI. I've read on the GHC's Trac Wiki that GHC's RTS is implemented in C and as such makes debugging any Haskell source difficult..but breaking on linked C code should be 
11:20:09 <lamefun_> I mean, if callCC was made before RankNTypes, shoudldn't it ideally have been callCC :: ((a -> m Void) -> m a) -> m a?
11:20:09 <ReinH> Not obvious enough, I guess.
11:20:12 <ickabob> achievable.  Not knowing much about the relationship between GHC and GHCI, am I traveling down a dead end trying to set up my pre FFI environment with GHCI?  It seems everytime I try to attach to my running GHC RTS with GDB, GHCI is blocked, and I can't evaluate the IO expressions to trigger the FFI code.
11:20:27 <MitchellSalad> lamefun_: your version of callCC is fine, yes - error should never be called
11:20:28 <Akii> I post some code and now freenode starts garbage collecting..
11:20:32 <ReinH> Also I think absurd predates Ed and is probably folklore at this point
11:20:44 <ReinH> But I also don't think whoever originally named it was an idiot.
11:20:48 <dolio>  callCC was defined before Void was commonly used.
11:21:16 <ReinH> It was probably first used in a private communication by Tarski or something
11:21:20 <cocreature> Akii: what kind of streaming framework is that using? I don’t know of any which includes SinkT
11:21:27 <adamCS> hamishmack: And ignore my second question.  I can just set reload to a different point and not deal with my browser spawning.
11:21:33 <dolio> Also there isn't a lot of advantage to explicitly saying Void there, because any caller can instantiate the type with b to Void.
11:21:36 <ReinH> Tarski was a well known idiot, of course.
11:21:41 <adamCS> sorry! Wrong channel.
11:21:41 <geekosaur> osa1, https://curl.haxx.se/libcurl/c/CURLOPT_NOSIGNAL.html
11:22:03 <Akii> cocreature: machines, although that SinkT is my doing - see updated lpaste
11:22:08 <geekosaur> which implies that you need to use that in multithreaded programs that also use timers (which means any Haskell program)
11:22:14 <MitchellSalad> now I'm imagining an agitated programmer with a Void in his code. "This value is patently ABSURD!"
11:22:14 <Akii> cocreature: had the same implemented in pipes; same result
11:22:19 <osa1> geekosaur: WOW
11:22:28 <ReinH> MitchellSalad: "It should not be!"
11:22:38 <cocreature> Akii: sorry I don’t know machines
11:22:42 <MitchellSalad> This functor... is VACUOUS!
11:22:48 <osa1> I can't believe curl actually handled signals... it's supposed to be called from all kinds of languages with different runtimes, right?
11:23:00 <geekosaur> curl uses signals for timeouts
11:23:00 <Akii> cocreature: pretend it's pipes; the issue is in my code not the library
11:23:31 <geekosaur> which means that it will handle timeouts less well with that set, in much the same way your threads didn't get scheduled with +RTS -V0
11:23:57 <osa1> I don't use curl's timeouts (instead use timers in Haskell) so that's fine
11:24:06 <geekosaur> but timers are per process and there is no per-thread timer mechanism so there isn't much to be done about it
11:24:16 <osa1> actually the reason why I'm interrupting curl is exactly this
11:24:50 <osa1> I want to handle timeouts in my application and I can't tell curl what will the timeout be, I'll just know it when it happen in the application and at that point I should be able to stop curl thread
11:26:31 <Cale> That was odd
11:26:49 <slack1256> was there an easy way to derive lenses without depending on lens?
11:26:53 <Cale> anyway, yeah, looks like they don't provide the same sort of liftCallCC' for Writer at all
11:27:15 <Eduard_Munteanu> slack1256, there are minimalistic lens packages which are lens-compatible.
11:27:52 <Eduard_Munteanu> slack1256, you can also split the lenses into a diffferent package, if you want to.
11:29:39 <ReinH> slack1256: Lenses can't be derived. They can be generated with Template Haskell, but that requires the lens package.
11:29:40 <MitchellSalad> Cale: yeah, if you peek at the implementation for liftCallCC you'll see there's no opportunity to "save" what's been written
11:29:54 <MitchellSalad> unlike for StateT
11:30:02 <iqubic>  slack1256: Edward Kmett has optimized his libraries to the point where you don't need to depend on them
11:30:08 <iqubic> Lens is just a type
11:30:10 <ReinH> Lens types can be implemented with Functor
11:30:15 <slack1256> ReinH: yeah, wrong term.
11:30:27 <ReinH> So you don't need to depend on the package to define them
11:31:29 <ReinH> See https://github.com/ekmett/lens/wiki/How-can-I-write-lenses-without-depending-on-lens%3F
11:31:38 <MitchellSalad> So, what are 'shiftT' and 'resetT' used for in Haskell?
11:31:59 <slack1256> iqubic: I got a certain objection on that way of implementing lens. Basically you have to know "how" to implement "lens-the-type" instead of using a function that given a constructor and modifier does it for you
11:32:11 <slack1256> it kind of goes against abstraction for the end user
11:32:27 <ReinH> slack1256: You can use such functions, but then you depend on lens.
11:32:31 <MitchellSalad> slack1256: true, but the benefit is the OO hierarchy :)
11:32:33 <slack1256> exactly!
11:32:46 <MitchellSalad> if you hide the internals, you couldn't compose optics with different powers
11:32:50 <ReinH> slack1256: So your objection is what?
11:33:17 <ReinH> If you want to implement it using generic types in the prelude, you have to implement it using generic types in the prelude.
11:33:34 <ReinH> If you want to implement them with special smart constructors, you have to import those constructors.
11:33:49 <ReinH> Maybe someone could publish a library of lens constructors that doesn't depend on lens
11:33:51 <Cale> I assumed the question was about whether there's a package providing TH code for constructing lenses for a data type
11:33:59 <Cale> (separate from the lens package)
11:34:12 <slack1256> microlens-th seems to be that package
11:34:45 <dfeuer> Does Andrew Thaddeus Martin hang out here? If so, does anyone know his nick?
11:35:00 <Cale> slack1256: yeah, that looks like it
11:35:02 <ReinH> If lens was implemented in a different way, it probably wouldn't be possible to define lenses without requiring lens.
11:35:09 <slack1256> ideally I would import lens, if that didn't carry 20+ other packages (which does for good reasons).
11:35:33 <cocreature> the funny thing about microlens is that a lot of packages using it transitively depend on lens as well
11:35:40 <ReinH> I think the lens constructors that don't have dependencies should be factored out of and then depended on by lens
11:35:42 <dfeuer> The big question in my mind is whether the Van Laarhoven style is more sensical or the profunctor style.
11:36:01 <dfeuer> I don't know enough about either, but the latter seems more compact somehow.
11:36:01 <slack1256> if I don't want to do that, I basically have to know how Van-Laarhoven are implemented
11:36:12 <Cale> slack1256: You ought to know that anyway
11:36:21 <slack1256> I shouldn't
11:36:22 <dfeuer> A lens is a function from a transformation to a transformation.
11:36:37 <dfeuer> That seems fundamental to what a lens is.
11:36:44 <dfeuer> So I'm okay with an "open" representation.
11:36:46 <ReinH> I don't think having to know how something is constructed in order to be able to constructed is an onerous requirement.[
11:36:51 <ReinH> *construct it
11:37:16 <slack1256> having to know how to construct it to use it freely is what bothers me
11:37:35 <ReinH> You don't. You can use combinators. You just have to import them.
11:37:56 <Cale> Lenses are just functions forall f. (a -> f b) -> (s -> f t) -- such functions can be useful even if you have no other machinery around to help use them
11:38:11 <iqubic> What is the differnece between Van-Laarhoven and Profunctor lens repersentations?
11:38:12 <ReinH> Cale: I'm reminded that %%~ is just id
11:38:41 <MitchellSalad> i think indexed profunctor lenses are much less hacky than indexed VL lenses
11:39:06 <slack1256> Cale: that isn't the whole story was you have some kind of "sub-classing", which is kind of esoteric in haskell 
11:39:24 <ReinH> sub-classing?
11:39:25 <Cale> slack1256: I don't know what people mean by "sub-classing"
11:39:38 <adamCS> iqubic: Profunctor lenses are more like "forall p. Profunctor p => p a b -> p s t"
11:39:43 <torstein> Say I have  a module which mostly uses functions from Accelerate, to such a degree that I want prelude functions to be prefixed P.funcName while accelerate functions are preferred if there's no prefix. Is that possible?
11:39:46 <ReinH> Is this a reference to the lattice of type classes?
11:39:56 <MitchellSalad> passing a Lens to a function that expects a Traversal, for example
11:39:57 <Gurkenglas_> Cale, superclassing in negative position
11:40:01 <iqubic> Cale: Instance (Functor f) => Applicative f where.
11:40:04 <Cale> Gurkenglas_: heh
11:40:20 <slack1256> Applicative f => Functor f and thus all folds are some kind of getter and stuff
11:40:23 <adamCS> And the various prism, traversal comes from different additional constraints on profunctor (Strong, Choice, Traversing)
11:40:28 <slack1256> (I got it wrong) 
11:40:47 <Cale> slack1256: Oh, you're talking about traversals?
11:40:54 <ReinH> "sub-classing" is not esoteric. It is common-place.
11:41:04 <ReinH> It's all over the Prelude and base.
11:41:04 <iqubic> How can something be both contravariant and functor at the same time?
11:41:17 <MitchellSalad> iqubic: phantom :)
11:41:18 <Cale> Traversals are just functions  forall f. Applicative f => (a -> f b) -> (s -> f t)
11:41:27 <Cale> which means that lenses are a special case of that, sure
11:41:42 <Cale> (because every Applicative is also a Functor)
11:41:50 <iqubic> Sure. A lens is a single target traversal
11:41:58 <slack1256> cool, microlens does what I want
11:42:10 <slack1256> sorry to fire and run, I got classes now.
11:42:13 <slack1256> See ya
11:42:14 <iqubic> What is phantom?
11:42:28 <iqubic> Can I see a valid definition for phantom?
11:42:29 <MitchellSalad> a phantom type variable can be both covariant and contravariant
11:42:35 <Gurkenglas_> iqubic, all f that are Functor and Contravariant are isomorphic to Const r for some r
11:42:41 <MitchellSalad> data Const r a = Const r
11:42:55 <geekosaur> iqubic, a phantom type variable is one that does not occur in values, only in types
11:42:56 <iqubic> Wait, why is that?
11:43:01 <Cale> microlens unfortunately exports a bunch of the line-noise generating junk from lens :)
11:43:05 <ReinH> data Proxy a = Proxy
11:43:14 <bollu> dang, quchen isn't around.
11:43:25 <ReinH> bollu: I suggest @tell-ing him.
11:43:25 <geekosaur> so for example in Right 5 :: Either String Int, String is phantom --- tye type has to match, but the value doesn;t have a String in it
11:43:35 <bollu> @tell quchen: if you have a hashed string, how would you implement "Pretty" for it?
11:43:35 <lambdabot> Consider it noted.
11:43:39 <ReinH> I also wish he would just idle.
11:44:12 <iqubic> and how is a phantom type both covariant and contravariant?
11:44:24 <Cale> But at least it's somewhat more conservative about which infix operators it provides
11:44:36 <Cale> If I did it, I would have made them not be infix
11:44:47 <ReinH> instance Functor Proxy where fmap _ Proxy = Proxy; instance Cofunctor Proxy where cofmap _ Proxy = Proxy
11:45:08 <Eduard_Munteanu> Another name for that is invariant.
11:45:48 <ReinH> It's a covariant functor because the type variable doesn't appear in negative position and it's a contravariant functor because it doesn't appear in positive position.
11:45:58 <AWizzArd> I like that SPJ quote, about Haskell being the World’s finest imperative programming language. After some months of studying Haskell I am really believing this now :-)
11:46:04 <glguy> Eduard_Munteanu: Another name for what?
11:46:15 <iqubic> ReinH: There is no type variable to match against.
11:46:17 <Eduard_Munteanu> glguy, invariant = contravariant + covariant
11:46:28 <ReinH> iqubic: I don't know what you mean.
11:46:41 <Gurkenglas_> iqubic, Const r is contravariant and covariant, and you can see the other direction implemented at http://hackage.haskell.org/package/lens-4.15.3/docs/src/Control.Lens.Getter.html#to
11:46:44 <ReinH> There is a type variable. data Proxy a = Proxy
11:47:03 <iqubic> ReinH: You can't pattern match on a proxy and get out a value for a.
11:47:03 <dolio> Eduard_Munteanu: That's not what I would expect "invariant" to me.
11:47:06 <dolio> Mean, even.
11:47:23 <glguy> Eduard_Munteanu: invariant are cases that are neither covariant or contravariant, though
11:47:23 <Eduard_Munteanu> Hm. I thought I've seen that somewhere.
11:47:35 <ReinH> iqubic: That's true, but also doesn't disprove my statement.
11:47:41 <iqubic> No, it doesn't
11:47:46 <ReinH> I didn't say anything about values of type a.
11:47:57 <Eduard_Munteanu> Actually, what you say makes more sense, sorry.
11:48:17 <Cale> AWizzArd: yeah -- when I first started learning Haskell and its interesting features, I kept thinking "Perhaps it would be interesting to see an imperative language with feature X", but then I found out that such a language already exists with all such features.
11:48:47 <glguy> The type can either use its parameter in positions that are: only positive, only negative, both postive and negative, or neither positive nor negative.
11:49:01 <ReinH> contravariant + covariant is sometimes called bivariant
11:49:34 <Gurkenglas_> I've heard "f is invariant under g" and "f is covariant under g" to stand for "for all x, f x = f (g x)" and "for all x, g (f x) = f (g x)"
11:50:53 <ReinH> Well, whoever said that should come up with their own terms and stop stealing ours. :p
11:50:56 <Cale> Gurkenglas_: You're more likely to hear "f commutes with g" for the latter
11:51:15 <Gurkenglas_> From that source, where the nose in an image is is covariant under rotation, scaling, translation, etc. and how many noses there are is invariant under those.
11:51:57 <Cale> and I would expect "f is g-invariant", but "invariant under g" is understandable.
11:52:00 <ReinH> Yeah, I think that's just overloading.
12:03:56 <osa1> geekosaur: I still can't interrupt the curl call ;-(
12:04:01 <osa1> *sigh*
12:05:04 <torstein> I'm having some difficulties getting number types lined up. Can anyone take a look? Problem 1: http://lpaste.net/356361   problem 2:  http://lpaste.net/356360
12:18:08 <Bepo> @help
12:18:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:18:18 <Bepo> @list
12:18:18 <lambdabot> What module?  Try @listmodules for some ideas.
12:21:19 <Sylph-DS> hello, not entirely sure this is the right place to ask, but here goes anyway. I installed the generic linux dist of the Haskell platform, but I want to install a different version through my package manager, so I want to uninstall this version I have now. Anybody know how to go about that?
12:22:02 <dolio> How did you install it? `make install`?
12:22:19 <Sylph-DS> I ran the install script
12:22:26 <Sylph-DS> not improbable that it does a make install
12:23:29 <Sylph-DS> hmm, well, if there isn't some automagic way to do it I can try and disect the install script I guess
12:23:38 <Sylph-DS> but I was hoping there was a better way ;)
12:25:09 <osa1> geekosaur: if you're interested, here's a reproducer: http://lpaste.net/765101754667761664 the server is blocking 10 seconds before returning empty response. this program is suppsed to block 1 second but it instead blocks 10 seconds.
12:26:00 <dolio> Yeah, I don't know. I would probably find where it got installed and delete it.
12:26:25 <geekosaur> osa1, I think you have things at cross purposes here
12:26:48 <geekosaur> if you leave signals enabled, you can interrupt it but it won't know the difference between its own alarms and the ghc runtime's
12:27:13 <geekosaur> if you disable them, you can't interrupt FFI calls because the only way to do that is for the process to send itself a signal
12:28:06 <geekosaur> at this point I would seriously suggest you want to have curl in a subprocess --- maybe even just shelling out to the curl binary --- and time it out by killProcess-ing it
12:28:20 <osa1> geekosaur: why does it need to handle any signals? I'm not using any timeout options
12:28:43 <makalu> I have a string such as "Zimmerman-Graef & M\252ller & Co.KG". \252 is ü in Latin-1. Any idea on how to convert these \blah things to UTF?
12:28:51 <geekosaur> becuase they don't provide two different curl backends one for timeouts and the other for not?
12:29:12 <osa1> geekosaur: I mean, it could only install signal handlers if timeouts are enabled
12:29:27 <geekosaur> it would still be interrupted by the ghc timer, and would die
12:29:39 <geekosaur> or rather will abort back to haskell exactly the way you were seeing
12:29:56 <geekosaur> the only way to handle that is *install* signal handlers and have them resume the operation
12:31:32 <geekosaur> osa1, the way you are thinking about this is precisely why so many C libraries are unusable in the presence of timers... you think things magically Just Work, but they do not and can not, it has to be actively managed
12:35:25 <Athas> torstein: import qualified Prelude as P
12:35:55 <osa1> so unless I disable GHC's timer (not sure if this is possible) the thread will get signals. these signals will either interrupt the thread (if signal handler is not installed) or curl's signal handler will run. did I get this part right geekosaur?
12:36:18 <geekosaur> if you disable ghc's timer, your other threads will not context switch
12:37:08 <osa1> right so the thread will get signals no matter what. what I don't understand is why this program doesn't terminate in one second when I disable curl's signal handler
12:38:41 <tomfb> Is there an easy way to pass a tuple to a function as 2 parameters, like unpacking in e.g. python? with my current knowledge i only come up with  fcn (fst tup) (snd tup).
12:39:19 <geekosaur> osa1, because curl must assume any signal it receives in that mode was intended for something else
12:39:25 <geekosaur> so it ignores the signal and restarts
12:39:42 <haski> hi all, i'm new in haskell and trying learn to develop some "easy" codes.. I've a question: is there a way to print a value of a "variable" to the console within an "let ... in" - Statement
12:40:34 <geekosaur> you are still not understanding this. signals affect the whole process. threads cannot have their own signals or their own signal handlers, and shared use of signals is very difficult. signals are really the wrong tool for this kind of thing, but they're all POSIX offers
12:42:08 <dedgrant> tomfb: See uncurry: https://www.stackage.org/haddock/lts-8.19/base-4.9.1.0/Prelude.html#v:uncurry
12:42:21 <dedgrant> uncurry (\x y -> x + y) (5,10)
12:42:26 <dedgrant> > uncurry (\x y -> x + y) (5,10)
12:42:28 <lambdabot>  15
12:43:09 <tomfb> dedgrant: sweet! thank you : )
12:45:55 <haski> hi all, i'm new in haskell and trying learn to develop some "easy" codes.. I've a question: is there a way to print a value of a "variable" to the console within an "let ... in" - Statement
12:46:56 <dedgrant> haski: print
12:47:12 <geekosaur> dedgrant, let-in implies pure code
12:47:23 <geekosaur> haski, take a look at the Debug.Trace module
12:47:59 <haski> dedgrant: Can you tell me how to use print? for example print ( x + 2) ?
12:49:33 <dedgrant> haski: That's right. Any value with a Show typeclass instance will work. https://www.stackage.org/haddock/lts-8.19/base-4.9.1.0/Prelude.html#v:print
12:49:35 <Cale> haski: that should work. Note that print gives you a value of type IO (), which is a value that represents the action of printing the thing on the screen
12:50:14 <haski> thanks guys! i'll check it!
12:50:18 <Cale> haski: If you give such a thing to ghci, it will run it for you immediately, or in a compiled program, 'main' will need to be an IO action.
12:51:10 <Cale> (but merely constructing the IO action doesn't do anything on its own)
13:09:42 <makalu> I have a string with a unicode escape sequence like foo\u00f5blah. How can I replace \u00f5 with õ?
13:10:01 <lmapper> hi all, thanks to some help here yesterday I managed to construct a storage and retrival method for some arbitrary functions
13:10:14 <lmapper> but I ended up having to use Data.Dynamic
13:10:50 <infandum> I don't completely understand backpack. Why use backpack (say, for different string types), when you can just use a typeclass?
13:10:52 <lmapper> it's working, but I'm hoping there's a more elegant way to structure it
13:11:10 <lmapper> would anyone care to have a look at it
13:11:35 <lmapper> it's just a toy example at the moment
13:12:58 <sm> makalu: it should display that way when you "putStrLn" it, eg
13:13:08 <geekosaur> look again, it's not a haskell escape
13:13:26 <geekosaur> that is, it's not the result of using show
13:13:55 <glguy> makalu: You write a function on Strings that implements the syntax you have in mind
13:14:20 <makalu> I thought that maybe it's some kind of standard notation but it's pretty difficult to google :)
13:14:47 <osa1> geekosaur: I'm still not entirely understanding how to use curl reliably in this context. either way (with and without signal handlers) it's a problem. what am I missing?
13:14:52 <makalu> it's in a JSON response but I don't have documentation of the service
13:15:17 <geekosaur> osa1, I suggested running it in a subprocess. I'm afraid it's about the only option you have
13:15:37 <artf22> hay
13:15:41 <lmapper> I have posted it on lpaste
13:15:44 <lmapper> http://lpaste.net/2356356506129006592
13:16:13 <artf22> I was just looking for someone used stagefright recently
13:16:35 <artf22> does anyone know how to
13:16:42 <makalu> it seems to be Java unicode escape sequence http://javajee.com/unicode-escapes-in-java
13:17:00 <dolio> infandum: Strings have the sort of API/usage that lends itself to being parameterized once on an entire module level more nicely.
13:18:39 <dolio> Huge API surface, which makes for an annoying type class, and most programs don't want to use many different string types at once, making the more granular overloading not necessary.
13:18:43 <sm> makalu: ok, the answer may be that you can convert such encoding to haskell's by replacing the \u's with \x, so eg putStrLn "\x00f5" -> õ
13:18:50 <geekosaur> makalu, how are you decoding this JSON? I think aeson handles translating those escapes automatically
13:19:07 <artf22> is anyone available at moment
13:19:11 <artf22> ?
13:19:13 <dolio> And you also don't need to get all the string types to agree on a common type class to implement.
13:19:36 <geekosaur> artf22, is that a Haskell program?
13:19:37 <makalu> aeson does something confusing. It replaces them with \x where x is the Latin-1 code (?)
13:20:06 <infandum> dolio: How would a large type class be any different than a large backpack module?
13:20:10 <geekosaur> that sounds like you are looking at the output with show, which will expand most things that way
13:20:26 <geekosaur> use putStrLn instead of show or print
13:21:15 <geekosaur> > show "õ"
13:21:17 <lambdabot>  "\"\\245\""
13:21:47 <dolio> In fact, you don't even need a canonical string module. You can just define the API that your program expects from strings, and as long as all the string types implement those functions, you can use them.
13:21:49 <geekosaur> > text "õ"
13:21:50 <infandum> dolio: If the idea is to switch out one implementation for another, you need to have all of the string types agree anyway, right?
13:21:51 <lambdabot>  õ
13:21:58 <dolio> Instead of trying to figure out the common API to put in a type class.
13:22:28 <infandum> dolio: Okay, that makes a little more sense. Like, I would not have to make ANOTHER api, I could just use one implementation.
13:23:15 <geekosaur> oh
13:23:19 <geekosaur> > "õ"
13:23:21 <lambdabot>  "\245"
13:24:21 <makalu> geekosaur you are correct. I used show on my resulting record but the show instance was derived so the string fields went through show before putStrLn. Thank you!
13:25:05 <chewzerita> @pl loop a = a >> loop a
13:25:05 <lambdabot> loop = fix (ap (>>))
13:25:54 <zomg> hm, is it not safe to do divisions and such with Scientific numbers?
13:26:28 <zomg> -1 / 1.5 where both values are Scientific hangs the program with 100% CPU use, while just doing -1 / 1.5 in GHCI works just fine..
13:26:55 <zomg> (but if I cast those values into Scientific in GHCI it'll also freeze)
13:28:08 <geekosaur> zomg, http://hackage.haskell.org/package/scientific-0.3.4.15/docs/Data-Scientific.html#g:4
13:28:49 <geekosaur> the result is a repeating decimal, scientific can't handle those directly
13:29:03 <zomg> ah of course
13:29:22 <zomg> yeah I figured there might've been something like that going on but missed that in the docs
13:29:24 <geekosaur> "WARNING: Although Scientific is an instance of Fractional, the methods are only partially defined! Specifically recip and / will diverge (i.e. loop and consume all space) when their outputs have an infinite decimal expansion. fromRational will diverge when the input Rational has an infinite decimal expansion. Consider using fromRationalRepetend for these rationals which will detect the repetition and indicate where it starts."
13:29:26 <zomg> thanks
13:29:41 <kadoban> You may want Rational instead unless ... well there's other stuff you need to do that aren't rationals.
13:29:58 <zomg> yeah I'm just gonna convert it with toRealFloat since I don't need the precision with this particular operation
13:30:02 <zomg> I was just being lazy I guess :P
13:32:26 <ab9rf> hwh
13:33:44 <zomg> kadoban: yeah I was trying to be careful about storing currency values
13:37:12 <dolio> Maybe you could try Data.Fixed.
13:39:17 <zomg> yeah that could work, I don't really need the arbitrary precision
13:45:59 <jared-w> I feel like someone should make a currency number type to solve most of these issues...
13:46:33 <jared-w> the best way to handle anything money related is to outsource the crap out of it (eg Square for CCs)
13:47:55 <kuribas`> I am getting: *** Error in `./outlinePoly': double free or corruption (fasttop): 0x00000000018421c0 ***
13:48:18 <kuribas`> I have a ffi binding using Data.Vector.Storable.
13:50:38 <kuribas`> http://paste.lisp.org/display/349104
13:50:48 <kuribas`> Any idea what may cause it?
13:52:43 <kuribas`> hm, it may be simply from the C++ code...
13:52:54 <glguy> kuribas`: Those last two lines don't look so good
13:53:29 <kuribas`> glguy: it returns a storable vector from a c buffer
13:54:36 <kuribas`> here's the c code: http://paste.lisp.org/display/349104#1
13:55:09 <glguy> Well whether or not this code is OK, the reason I wrote that wasn't right
13:55:39 <kuribas`> glguy: I think it's just the library I bound to that trashes on wrong inputs.
13:56:21 <kuribas`> glguy: And my binding is fine...
13:57:00 <dolio> kuribas`: Are you creating two vectors with the same underlying pointer, maybe?
13:57:36 <kuribas`> dolio: no, just one.
14:01:35 <dolio> Yeah, that would be pretty hard to do, I guess.
14:02:40 <zomg> jared-w: yeah, I'm just playing around with some cryptocurrency stuff :) Otherwise I'd just use something like Stripe
14:05:09 <glguy> kuribas`: Should your implementation of deleteTriangles be using detete[] ?
14:06:06 <kuribas`> glguy: where did you see that?
14:06:19 <glguy> bottom of http://paste.lisp.org/display/349104#1
14:06:47 <kuribas`> glguy: I see "delete"?
14:06:53 <glguy> Yeah, isn't that a mistake?
14:07:02 <dolio> The unsafeForeignPtrToPtr part seems kind of suspicious, too.
14:08:31 <kuribas`> glguy: no, because it comes from c++ code.
14:08:47 <glguy> kuribas`: Right, you allocated that array in C++ with new[]
14:08:53 <kuribas`> glguy: yeah
14:08:59 <glguy> so you need to delete it with delete[]
14:09:49 <glguy> dolio: Yeah, that seems wrong, it turns those into Ptrs and uses them afterward
14:10:17 <glguy> but doesn't touch the foreign pointer after using them as ptrs
14:11:09 <dolio> Right. It touches before, but I think the point of touching is to do it at the part where you still want the pointer to be live.
14:11:17 <dolio> Artificial GC reachability.
14:12:24 <kuribas`> dolio: I need to touch the pointers earlier?
14:12:39 <dolio> It's hard to tell in my head if those pointers are getting re-created as foreign pointers or something, though.
14:12:44 <dolio> kuribas`: No, later if anything.
14:12:57 <dolio> I think touching the pointers does nothing if something else uses them later in the code.
14:13:22 <kuribas`> that makes sense...
14:13:25 <glguy> kuribas`: Even better would be to not use unsafeForeignPtrToPtr at all
14:14:34 <kuribas`> right...
14:14:58 <glguy> withForeignPtr handles all of this for you
14:15:02 <kuribas`> glguy: is delete[] different from delete?
14:15:08 <glguy> kuribas`: Yes
14:15:17 <kuribas`> glguy: yes, but I have a vector of vectors
14:15:51 <glguy> kuribas`: That's fine
14:17:27 <ph88^> how to read this type?   ((a0, t1) -> (a0, t0) -> a0, t2)
14:18:21 <ph88^> oh i meant to create a tuple but forgot parenthesis ^^
14:18:32 <glguy> runContT . Data.Vector.mapM (ContT . withForeignPtr)
14:18:32 <glguy>   :: Vector (ForeignPtr a) -> (Vector (Ptr a) -> IO r) -> IO r -- for example
14:20:18 <fosskers> Hey all. It's my second session on trying to optimize this library that I'm working on. Last time I managed to bring the time down by half, but my target is order-of-magnitude. I've exhausted my immediate list of "things to try"
14:20:51 <geekosaur> ph88^, something that takes two 2-tuples and produces a 2-tuple; the first component has the same type throughout, the second component (by parametricity) is unused
14:21:05 <glguy> Or for fun using stuff from lens:
14:21:06 <glguy> alaf ContT traverse withForeignPtr :: Vector (ForeignPtr a) -> (Vector (Ptr a) -> IO r) -> IO r
14:21:10 <fosskers> i.e.: -O2, inlining, strict `many1` (it's a parser), `scanl`
14:21:20 <fosskers> StrictData doesn't help me, unfortunately
14:21:25 <exio4> fosskers: where's the code?
14:21:29 <fosskers> I'm wondering what else to attempt
14:21:58 <geekosaur> (because the second element doesn't have any relationship between its types, it can't be used)
14:22:32 <fosskers> exio4, https://github.com/fosskers/streaming-osm/pull/1
14:23:05 <kuribas`> glguy: great, I didn't think of that...
14:24:05 <fosskers> It's a hand-written Protobuf parser for parsing OpenStreetMap data, which I then feed through the `streaming` lib
14:24:25 <fosskers> `streaming` has integration with attoparsec, so it seems like a good fit
14:24:56 <fosskers> the bottleneck doesn't seem to be the streaming (so switching to another streaming lib wouldn't help), it's the parser.
14:25:02 <jared-w> Why'd you change the  import from B to Q?
14:25:40 <fosskers> jared-w, it's the original authors practice 
14:25:52 <jared-w> ah, gotcha.
14:26:00 <fosskers> I suppose to reserve `B` for actual `bytestring`
14:26:55 <fosskers> I wonder if inlining the parsers themselves would do much
14:27:07 <jared-w> Have you tried testing by removing inlines? That is, is every inline justified by a measurable increase in performance, or were they just added in the hopes that it would increase speed?
14:27:25 <fosskers> jared-w, probably the latter
14:27:42 <jared-w> I'd test that, then. Sometimes inlines can really slow down performance
14:28:16 <fosskers> `varint` for instance is a big cost center. it's also generic, which I know slows things down. inlining specializes, right?
14:28:42 <fosskers> I think that was my primary motivation for the initial round of inlines
14:28:44 <jared-w> inlining takes a function and pastes it inside everywhere it's defined
14:29:01 <exio4> fosskers: varint is a big cost center because it's used everywhere, I would say :)
14:29:02 <fosskers> right, and I though it also specializes to the call type
14:29:11 <exio4> fosskers: do you have the results of profiling?
14:29:14 <fosskers> i do
14:29:24 <fosskers> both benchmarks and profiling
14:29:33 <exio4> can you post them?
14:29:35 <fosskers> sure
14:29:43 <fosskers> -p or -pa output?
14:30:23 <jared-w> Have you gotten rid of all of the lazy bytestrings and used streaming-bytestring?
14:31:06 <exio4> fosskers: -p
14:32:05 <fosskers> jared-w, yeah that shouldn't be the issue
14:32:21 <osa1> geekosaur: I found a simpler solution. it turns out curl is calling CURLOPT_PROGRESSFUNCTION callback often enough so I used it to read an IORef for stop signals and returning a positive value which tells curl to stop.
14:33:14 <jared-w> It doesn't appear that streaming-bytestring has any fusing functions. I'm assuming that's not important? (Or I'm reading the documentation wrong)
14:34:22 <fosskers> the attoparsec integration from `streaming-utils` is where the magic happens
14:38:53 <fosskers> exio4, may be hard to read, given the line wrapping: https://pastebin.com/SDHSymrH
14:39:13 <fosskers> I also had to cut off the last 30% or so, since it exceeded 512kb and pastebin has rules.
14:41:39 <jared-w> Just hit the "raw" button: https://pastebin.com/raw/SDHSymrH
14:42:25 <fosskers> ^ yeah that'll do it
14:42:49 <exio4> fosskers: I have no idea, sorry :/
14:42:59 <fosskers> np, thanks for taking a look
14:43:12 <fosskers> Are there any obvious things? Compiler flags I'm missing?
14:43:33 <fosskers> Like "Oh hey duh you forgot -fmake-it-go-fast"
14:43:43 <fosskers> al la, GC options etc
14:43:47 <jared-w> I don't think you're going to squeeze any magical low hanging fruit out of things like that at this point
14:43:55 <fosskers> damn :S
14:44:27 <exio4> fosskers: but maybe you can implement a few specialized varint(s) and use some RULES to avoid all that (apparently) expensive code? 
14:44:28 <jared-w> "the fastest code is that which is never written or never run"; you'll likely have to figure out a way to do less if you want much faster performance
14:46:49 <fosskers> exio4, jared-w i will try both those
14:48:20 <exio4> fosskers: also, couldn't foldr' (on foldBytes) might be an issue? maybe a tail-recursive version could be faster?
14:48:44 <Ste1891> Hey.  I'm trying to work out how to use Sound.OpenAL to play samples from WAV files and have run into a problem generating a buffer name.  The documentation says type Buffer is an instance of GenerateableObjectName, so I tried using genObjectNames.
14:48:48 <Ste1891> I got a "No instance for GenerateableObjectName Buffer" error, because it turns out the instance declaration is inside a hidden module called Sound.OpenAL.AL.BufferInternal.  This seems to contradict the documentation and I can't find any explanation there as to how one should do this.
14:49:45 <Ste1891> Am I perhaps missing something here?
14:52:06 <fosskers> exio4, could catch, trying that
14:52:26 <geekosaur> that sounds broken actually, it should be implicit because instances are always global
14:54:35 <Ste1891> OK.  Do you know of any sensible way I could unhide it (i.e. without having to hack and rebuild the library myself)?
14:55:13 <geekosaur> I think you did not understand what I said, but I still don't understand what's going on here
14:55:20 <geekosaur> it should not *need* to be unhidden
14:55:48 <fosskers> exio4, https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString.html#foldr%27
14:56:12 <fosskers> there's some hacks there, heh
14:56:14 <geekosaur> but you might try importing Data.ObjectName
14:56:38 <exio4> fosskers: ok, nevermind :P
15:01:11 <Ste1891> Oh, I get that and I've already imported Data.ObjectName into my Main module.  The problem appears to be that importing Sound.OpenAL.AL does not bring the required instance into scope.
15:01:31 <geekosaur> except that it should
15:01:49 <geekosaur> which makes me wonder... what version of the OpenAL package do you have installed?
15:02:38 <geekosaur> instances are not things you can import or export, if something --- visible or not --- that gets linked in (as BufferInternal must, else Buffer could not be) defines the instance, it will be present
15:04:47 <Ste1891> I've got the latest version, 1.7.0.4.
15:07:37 <geekosaur> looks to me like it should work :/
15:08:14 <Ste1891> OK, maybe it is broken.  I can't see how the developer could have not found this in testing though.  You can't do anything useful with the library without generating buffers.
15:08:47 <geekosaur> the example/test program just opens and closes a device, no buffers
15:09:20 <glguy> ickabob: What gdb commands were you trying with GHCi and your C code?
15:09:39 <glguy> ickabob: I made a tiny example and was able to step through things with lldb and ghci
15:09:58 <geekosaur> we handled that in -beginners; they didn't know attaching to a process in gdb stops it and you need to 'cont' it
15:10:05 <glguy> ah
15:10:14 <glguy> I see your answer now :)
15:10:29 <Ste1891> Yeah, but to make sound come out of a speaker I'm pretty sure you need to use them.
15:11:43 <geekosaur> Ste1891, at this point I can only suggest email to svenpanne@gmail.com
15:12:20 <geekosaur> I checked for the usual issues (like forgetting to include internal modules in other-modules) but it looks ok to me
15:12:42 <geekosaur> beyond that I don't know enough about what's going on to help
15:13:34 <Ste1891> OK, thanks for having a look though.  I'm amazed it's apparently not me missing something for once.
15:29:47 <kuribas`> glguy: I managed to implement it with typed holes.  I don't really understand it though...
15:29:57 <kuribas`> glguy: I never though ContT would be actually useful.
15:32:18 <hpc> it has its moments
15:42:18 <pierrot> Hi. Given a list l::[Int], how can I get a list such that for each position, the corresponding element is the sum of all the elements are before that position? Suppose h is that function, then for example h [5,3,21,4] = [5,8,29,33]
15:42:58 <pierrot> the sum of all the elements (that) are (...) *
15:44:37 <mniip> pierrot, scanl (+) 0
15:44:44 <glguy> > scanl1 (+) [5,3,21,4]
15:44:44 <mniip> rather, the tail of that
15:44:46 <lambdabot>  [5,8,29,33]
15:44:52 <mniip> that works too
15:45:25 <mniip> > scanl1 undefined []
15:45:27 <lambdabot>  []
15:45:30 <mniip> ooh nice
15:45:52 <mniip> definitely use scanl1 then
15:46:21 <zomg> ug, have to be careful - was querying a database for "latest" of something, and then saving something else into the same table
15:46:21 <juri_> and now i've read an entire wikipedia article on the square root of three. haskell is doing bad things to me.
15:46:42 <zomg> so of course thanks to haskell being lazy, the latest of something ended up being the one that I saved, which was only supposed to be saved after comparing it to the previous latest :P
15:47:37 <sbrg> zomg: that really doesn't sound like something that should be caused by laziness. what database and library are you using?
15:47:41 <mniip> > zipWith (-) `ap` (0:) [5,8,29,33]
15:47:43 <lambdabot>  error:
15:47:43 <lambdabot>      • Couldn't match expected type ‘[Integer -> b]’
15:47:43 <lambdabot>                    with actual type ‘[Integer] -> [Integer] -> [Integer]’
15:48:01 <mniip> > (zipWith (-) `ap` (0:)) [5,8,29,33]
15:48:02 <lambdabot>  [5,3,21,4]
15:48:06 <mniip> \o/
15:48:26 <pierrot> mniip: thanks
15:48:55 <zomg> sbrg: postgresql-simple. Not 100% sure tbh, I'm still seeing some erratic behavior.
15:49:36 <zomg> I mean considering IO is lazy I thought that was something that's possible, since the operations done on neither set of values actually depended on the specific order
15:49:51 <monochrom> But IO is not lazy.
15:50:14 <zomg> Either I must've been dreaming or it was changed? :P
15:50:14 <monochrom> putStrLn "hello" won't be procrastinated just because you aren't looking.
15:50:19 <geekosaur> not by default at least
15:50:24 <monochrom> Dreaming.
15:50:35 <mniip> IO effects aren't lazy
15:50:35 <geekosaur> you are thinking of getContents which does evil behind the scenes. most I/O is not doing that evil
15:50:41 <geekosaur> (unsafeInterleaveIO)
15:50:43 <mniip> IO very much can return thunks though
15:50:46 <monochrom> Even a getLine won't be procrastinated just because you don't use its answer.
15:51:37 <zomg> Yeah I suspect it was something that I used at some point which for whatever reason was behaving in that way
15:51:48 <zomg> and that's where I got that misconception then
15:51:48 <monochrom> Confirmation bias is a very powerful way to ignore obvious facts.
15:52:23 <zomg> it's possible I just remember the circumstances wrong since I had a long break from using haskell =)
15:52:24 <mniip> petition: unsafeGetContents
15:53:37 <glguy> Is that the version that permanently gets the contents, overwriting as it goes?
15:55:41 <Tuplanolla> :t unsafeSafeDo -- How about this?
15:55:42 <lambdabot> IO a -> IO a
15:56:50 <sbrg> what the ..
16:09:34 <zomg> Ok good, the erratic behavior stopped
16:09:40 <zomg> ...after I fixed my over-complicated SQL query
16:09:41 <zomg> :p
16:16:12 <orion> How long does it usually take to run `stack solver`?
16:24:14 <iqubic> orion: A few seconds.
16:26:07 <orion> Hmm. I executed it from my home directory, and it seems it recursively searched >1.7 TB of files for cabal files.
16:26:16 <orion> No wonder it was taking so long.
16:26:34 <exio4> orion: are you benchmarking stack? :P
16:26:44 <monochrom> Haha
16:26:51 <orion> heh
16:27:12 <monochrom> How did you manage to get it to search so many files?
16:27:23 <orion> monochrom: By running it from my home directory.
16:27:37 <orion> All I want to do is install a binary. Apparently it's not straightforward.
16:27:39 <monochrom> Oh, just "stack solver". That sounds bad.
16:28:24 <monochrom> Yeah, my impression is stack default behaviour doesn't have "this is not a project sandbox" in mind.
16:28:43 <threshold> is tehre a way to say data Foo = [Bar] ?
16:28:47 <kadoban> orion: Typically 'stack install thing', or if that's broken you can do 'stack unpack thing' and then go into that directory and fix whatever is necessary or do solver.
16:28:56 <orion> It creates an implicit global project: Writing implicit global project config file to: /usr/home/foo/.stack/global-project/stack.yaml
16:29:20 <kadoban> monochrom: Not sure solver makes any sense without a package. So it's more ... it did what it was told, no?
16:29:32 <geekosaur> threshold, maybe you want 'type' instead of 'data'?
16:29:44 <monochrom> True. I don't know stack.
16:31:33 <threshold> thanks geekosaur 
16:32:05 <threshold> i think i have created a circular dependency here: data Foo = A Bar | B Bar | C Bar | D ; type D = [Foo]
16:32:13 <geekosaur> you have not
16:32:28 <geekosaur> the first is a data constructor, the second is a type constructor
16:32:37 <monochrom> The two "D"s are distinct. Unrelated.
16:33:15 <geekosaur> data Maybe a = Nothing | Just a -- Maybe is a type constructor, Nothing and Just are data constructors. Maybe 5 is nonsense, Just Int is nonsense
16:33:40 <monochrom> What is Bar anyway?
16:34:01 <geekosaur> (at your level at least; Haskell can get 'interesting' if you enable the right extensions...)
16:34:48 <geekosaur> but those extensions won't change the fact that you have a type Foo one of whose data constructors is a D, and a distinct type constructor D
16:35:00 <threshold> i wan A Bar, B Bar, and C Bar to just be lists that are distinct from one another
16:35:17 <threshold> A [...], B [...], C [...]
16:35:39 <monochrom> What go into those lists?
16:35:40 <geekosaur> I would consider refactoring that, to be honest. depends on what you are going to do with it, though
16:35:43 <threshold> or i'm thinking of making Foo an instance of IsList
16:36:08 <monochrom> Why bring in IsList aka fake list when you can use real lists?
16:37:23 <threshold> monochrom: i'm still deciding what goes into the lists. it will be a list of data types that somehow are related. i haven't thought it through yet
16:37:49 <threshold> monochrom: because i want to name the lists and add extra functionality to the lists
16:38:26 <threshold> i'm open to not doing it this way
16:39:54 <threshold> maybe i should  try type A = [Bar]; type B = [Bar]; type C = [Bar]; until i have run into problems
16:40:12 <monochrom> Then A, B, C are interchangeable.
16:45:43 <threshold> i need to sit down and think about this. i _think_ i need a way for users of the module to create their own data types. i want them to be able to say that "foo" = MyTypeName 
16:46:05 <threshold> "bar" = MyOtherType 
16:46:29 <threshold> MyTypeName and MyOtherType would be the same type though
16:46:38 <threshold> they would have different strings associated with them
16:46:58 <threshold> maybe i need a map where the key is the custom made type name
16:49:53 <threshold> i don't want to spam this channel with this kind of conversation, should i use #haskell-in-depth?
16:54:32 <isheff> Question about OverlappingInstances:
16:54:32 <isheff> If I try to compile:
16:54:32 <isheff> class C a where
16:54:32 <isheff>   f :: a -> a
16:54:32 <isheff> class D a where
16:54:33 <isheff>   g :: a -> a
16:54:33 <isheff> instance C Int where
16:54:34 <isheff>   f = (1+)
16:54:34 <isheff> instance {-# OVERLAPPABLE #-} D a where
16:57:19 <torstein> I'm having some difficulties getting number types lined up. Can anyone take a look? Problem 1: http://lpaste.net/356361   problem 2:  http://lpaste.net/356360
16:58:35 <geekosaur> @paste -- isheff
16:58:35 <lambdabot> Haskell pastebin: http://lpaste.net/
16:58:44 <geekosaur> whoops, sigyn got 'em
16:59:33 <glguy> mniip: Do you happen to know if Sigyn merely disconnects the user in that case or if the user is also blocked from reconnecting?
17:00:06 <mniip> both
17:00:09 <mniip> I'll go fix it...
17:02:22 <isheff> I have a question about OverlappingInstances
17:02:48 <glguy> isheff: You need to use a pastebin service for presenting code
17:02:51 <mniip> isheff, try using a pastebin next time
17:02:57 <isheff> got it
17:03:16 <glguy> http://lpaste.net is the standard service
17:03:37 <mniip> it seems down-ish currently?
17:03:57 <glguy> Well, any will do, it's reliability varies these days
17:04:18 <mniip> very laggy and no irc feedback
17:04:28 <mniip> atm
17:04:31 <isheff> yeah, it's crazy slow
17:04:45 <isheff> example at https://pastebin.com/uNBV4chq
17:05:31 <isheff> It would seem to me that my final instance declaration should apply exactly when g is given an instance of C for input, but the compiler can't seem to figure that out, so it proclaims a duplicate instances error.
17:05:52 <isheff> I'm not sure if this is considered a bug, or just not behaving the way I expected...
17:06:10 <geekosaur> just not behaving as you expect
17:06:22 <thomasd> hey, has anyone ever seen "error in RTS option -O2: size outside allowed range (4096 - 18446744073709551615)"?
17:06:31 <geekosaur> contexts (anything before a =>) do not play a part in instance resolution
17:06:36 <thomasd> when running a program compiled with -02?
17:07:00 <geekosaur> thomasd, that sounds like -O2 also got added to -with-rtsopts
17:07:12 <thomasd> so that's not the correct way to do it?
17:07:30 <geekosaur> no? it's telling the compiler how to compile the code, it has nothing to do with the runtime
17:07:31 <thomasd> if I have a cabal file and want to compile with -02, how should I specify that in ghc-options?
17:07:41 <geekosaur> just as -O2
17:07:45 <glguy> thomasd: Are you accidentally writing zero-two?
17:07:55 <geekosaur> but don't make the typo you;ve repeated here twice of 0 instead of uppercase-O
17:07:57 <thomasd> nah, pretty sure Oh-2
17:08:11 <thomasd> yeah, my bad. thanks guys, I'll try that
17:14:28 <isheff> geekosaur: If you don't mind my asking, why aren't contexts considered in instance resolution? Is there some reason that leads to ambiguity?
17:19:36 <monochrom> My fringe theory: Compilers should take -O2 to mean less optimization, -O1 to mean more, because O(2) is slower than O(1). :)
17:20:08 <lordcirth> monochrom, but in CS, O(2) = O(1)
17:20:22 <geekosaur> glaaah. lovely time for the cellmodem to take a dump..
17:20:27 <monochrom> <-- just recovered from creating a midterm that contains big-O.
17:20:40 <kadoban> Heh, fun
17:21:39 <geekosaur> isheff, I don't know if anyone responded, but under the open world assumption (anyone can define their own typeclass instances and link against your module later, so the compiler cannot possibly know all possible instances available.
17:22:10 <isheff> geekosaur: thanks, that makes sense.
17:22:37 <geekosaur> heh, that was only half of hte answer, but I guess the rest was obvious
17:23:10 <jared-w> )
17:23:38 <geekosaur> even with restrictions like this, while I wwas looking for a better explanation I ran across an ezyang post about how it's still possible to trick the compiler into picking the wrong instance, without any extensions or etc.
17:27:21 <jakehehrlich> How would one go about calculating the combinatorial species of morphisms on a space? For starters given a set A say I want to consider the set theoretic functions from A -> A. How would I do that with this: https://hackage.haskell.org/package/species-0.4/docs/Math-Combinatorics-Species-AST.html 
17:50:09 <canichedog> yo, i have a question about those 3 scripts : https://hastebin.com/pegarakono.hs. each one of those scripts have a syntaxic or type issue, and id like to know what they are to confirm what i found
17:50:49 <canichedog> dw its just 3 lines definitions each
17:53:12 <Rotaerk> canichedog, [a] is syntax sugar for a:[]
17:53:29 <Rotaerk> canichedog, is this homework, btw?
17:54:00 <canichedog> its an old exam im trying to do by myself to train for an incoming exam
17:54:09 <canichedog> i have my own answers
17:54:10 <iqubic> The zip function looks wring
17:54:19 <iqubic> *wrong
17:54:22 <canichedog> but since i dont have a correction, id like to know if what i got is right
17:54:47 <Rotaerk> iqubic, they're all wrong
17:54:50 <canichedog> and yea those 3 functions are wrong
17:55:00 <iqubic> What is iter?
17:55:11 <canichedog> i guess the second one is wrong because there arent parenthesis around the anonymous function
17:55:13 <Rotaerk> hoogle itt, iqubic 
17:55:16 <Rotaerk> it *
17:55:36 <iqubic> canichedog: It's fine to exclude parenthesis in that case
17:55:45 <Rotaerk> canichedog, [a] is syntax sugar for a:[], for all a
17:55:50 <canichedog> and the third one is because the x doesnt have any meaning
17:55:50 <Rotaerk> even if a = x:xs
17:56:49 <canichedog> is the [x:xs] argument on the zip function normal btw
17:56:57 <Rotaerk> that's what I'm pointing out
17:57:01 <canichedog> seems strange to have that form into the definition of a list
17:57:11 <Rotaerk> x:xs is a list
17:57:16 <Rotaerk> wrapping it in [] makes it a list of lists
17:57:17 <canichedog> o k
17:57:30 <iqubic> canichedog: THe arguments provided to the zip function look right
17:57:41 <canichedog> yea english isnt my native language so forgive me if im a bit slow to understand haha
17:57:46 <jared-w> it should be (x:xs) (y:ys). Specifically, the : part is making it a list
17:57:54 <canichedog> yup, as i thought
17:58:19 <jared-w> so [a] is a list containing 'a', a:b:c:[] == [a,b,c], [a:b:c] == [[a,b,c]]
17:58:19 <iqubic> And then the Right Hand Side of the third pattern match of zip is wrong
17:58:32 <iqubic> zip is a recursive function.
17:58:59 <jared-w> So you need to actually call zip in order to recurse
17:59:13 <iqubic> Yeah.
17:59:27 <canichedog> oh yeah, i didnt really think about whether the algorithm is wrong 
17:59:33 <canichedog> but you're right 
17:59:55 <iqubic> What you should do is take the first element of each list, which you do. And then you should zip the remainder of both lists.
17:59:55 <jared-w> So what are you trying to do with the iter in script 2?
18:00:11 <canichedog> i guess the aim is to apply a function n times
18:00:26 <jared-w> you guess?
18:00:46 <canichedog> i thought the syntaxic issue stems from the fact that there's 4 arguments given on the second line @second script
18:01:08 <jared-w> well yes, that's a bit of an issue considering that's definitely impossible
18:01:22 <jared-w> (you can't declare a function to have two arguments and then give it four)
18:01:23 <canichedog> yeah i mean, iter does that
18:01:28 <canichedog> forget the "i guess" part haha
18:01:28 <jared-w> :t iter
18:01:30 <lambdabot> error: Variable not in scope: iter
18:01:46 <EvanR_> ah but you thats not true
18:02:06 <jared-w> It's supposed to apply a function n amount of times, you say?
18:02:11 <EvanR_> > let f x y = \z w -> z in f 'a' 'b' 'c' 'd'
18:02:13 <lambdabot>  'c'
18:02:29 <Rotaerk> cheater
18:02:41 <canichedog> yup jared
18:02:46 <geekosaur> or just a kreator >.>
18:02:48 <jared-w> EvanR_: I feel like that's just being overly pendantic at htis point :p
18:03:20 <canichedog> also, did you see whats wrong with the isSingleton definition?
18:03:32 <canichedog> is my guess that x doesnt have any reference true?
18:03:41 <EvanR_> jared-w: it does come up a lot
18:03:44 <marvin2> let f x y = \z w -> z in f 'a' 'b' 'c' 'd' <- what does that prove to be untrue?
18:03:58 <EvanR_> "you cant declare a function to take 2 args and give it 4
18:04:11 <EvanR_> this actually is done a lot with function-related instances
18:04:13 <marvin2> you can't. your function takes one argument
18:04:14 <geekosaur> it's not even the only way to do it :)
18:04:19 <EvanR_> well there you go
18:04:26 <jared-w> I believe "go functions" are the common idiom to do this thing with :p
18:04:34 <Rotaerk> geekosaur, hurhur
18:04:38 <marvin2> so technically "you cant declare a function to take 2 args and give it 4" is still true =)
18:04:46 <EvanR_> eyeroll!
18:05:15 <jared-w> and, had I been thinking slightly more about that, I would've pointed that out... Right alongside marvin2's pooint :p
18:05:20 <EvanR_> im glad ghc doesnt think this way when reporting "maybe you applied the function to too many / too few arguments"
18:05:25 <jared-w> canichedog: your singleton function is saying this
18:05:47 <jared-w> "I am given a list (xs)... if xs is some random variable I don't know nanything about, then true. Otherwise, false"
18:06:14 <canichedog> yup thats what i understood
18:06:27 <jared-w> actually it doesn't even say that, because there's no comparison with xs anywhere in there
18:06:32 <Rotaerk> "maybe you applied a non-function result of the function resulting from the function resulting from the function f"
18:06:58 <canichedog> if i had to correct this, i wouldve written isSingleton x:xs instead
18:07:17 <canichedog> and put on the first guard expression | [] = True
18:07:25 <canichedog> | otherwise = False
18:07:41 <jared-w> I would've just written isSingleton xs = length xs == 1
18:07:49 <canichedog> or that ye
18:08:13 <canichedog> yea i wouldve done that, but im trying to correct whats on the question, as ugly as it is
18:08:20 <c_wraith> > id const id () 7 -- id is a function that takes 1 argument... 
18:08:22 <lambdabot>  7
18:08:25 <jared-w> why would x:xs work and xs not?
18:09:19 <canichedog> because the definition aims to check if xs is a singleton
18:09:39 <canichedog> if i put x:xs on the argument, aka deleting the head of xs
18:09:44 <canichedog> and it returns []
18:09:51 <canichedog> then its a singleton
18:10:07 <jared-w> (x:xs) doesn't delete a head, it assigns x as the head of a list and xs as the tail of the list through pattern matching
18:10:17 <canichedog> oh
18:10:30 <canichedog> so the operation doesnt apply when given as an argument?
18:10:32 <iqubic> But if the tail is [], then you have a singleton
18:10:35 <EvanR_> detaches a head :)
18:10:50 <jared-w> No, just because you have a pattern match doesn't mean you've done anything.
18:10:54 <iqubic> singleton (x:xs) = xs == []
18:10:59 <iqubic> There you go.
18:11:03 <canichedog> aite
18:11:12 <EvanR_> yurg iqubic 
18:11:18 <EvanR_> singleton [x] = 
18:11:21 <EvanR_> singleton [x] = True
18:11:27 <EvanR_> singleton _ = False
18:11:30 <canichedog> yeah sorry its p late here, my brain isnt fully functionnal atm heh
18:11:49 <iqubic> What is the type of that function EvanR_? a -> Bool?
18:11:57 <EvanR_> [a] -> Bool
18:12:03 <canichedog> [a] -> Bool
18:12:31 <iqubic> But doesn't _ eat everything?
18:12:42 <iqubic> Can't it be type a -> Bool?
18:12:45 <jared-w> _ is a pattern match for anything
18:12:52 <iqubic> yes it is.
18:12:58 <EvanR_> the other clause has a pattern [x] in it
18:13:04 <jared-w> It doesn't eat anything. Pattern matches don't eat things :p
18:13:22 <EvanR_> that makes the function take a list
18:13:26 <iqubic> And the other pattern match [a] determines the type?
18:13:29 <mniip> in terms of linear types _ would indeed consume a thing
18:13:50 <canichedog> ok i think thats it for my questions on the hastebin
18:13:50 <mniip> iqubic, think of it as "constraining" the type rather than determining it
18:13:56 <canichedog> one last question before i go to bed
18:13:59 <mniip> there can be multiple independent constraints
18:14:00 <canichedog> what does $ means in haskell
18:14:09 <canichedog> ik its a syntaxic sugar but idk for what
18:14:11 <mniip> canichedog, it's the "apply" operator
18:14:14 <EvanR_> @src ($)
18:14:14 <lambdabot> f $ x = f x
18:14:15 <mniip> f $ x = f x
18:14:24 <canichedog> o k
18:14:26 <jared-w> canichedog: the "morally correct" hand-waving is that it's parenthesis
18:14:31 <johnw> o k = o $ k
18:14:38 <EvanR_> its low precedence function application
18:14:42 <jared-w> f (a b c) == f $ a b c 
18:14:43 <canichedog> haha knew someone would make that joke johnw :p
18:14:53 <canichedog> i see
18:15:09 <EvanR_> dont over use it
18:15:16 <geekosaur> normal function application is highest precedence (except for record update syntax). ($) is lowest precedence, so it acts a bit like parentheses around both sides
18:16:00 <geekosaur> it's also sometimes useful when mapping function application over something, since using "id" is a bit confusing
18:16:12 <canichedog> ok!
18:16:22 <canichedog> well thats all i wanted to know
18:16:23 <geekosaur> > map ($ 5) [succ, pred]
18:16:25 <lambdabot>  [6,4]
18:16:26 <canichedog> thanks guys
18:16:38 <EvanR_> haha using id for that
18:16:43 <canichedog> cya
18:16:49 <jared-w> canichedog: you're probably going to need to figure out Script 2 a bit more
18:16:59 <jared-w> darn, he quit right before I sent that. Oh well
18:17:39 <jared-w> geekosaur: honestly that usage of $ is still pretty weird to me
18:18:15 <geekosaur> and \f -> f 5 seems a bit verbose :)
18:18:58 <iqubic> Why do you say you can do the same thing with id?
18:19:12 <jared-w> > map (id 5) [succ, pred]
18:19:14 <lambdabot>  error:
18:19:14 <lambdabot>      • Could not deduce (Enum a0)
18:19:14 <lambdabot>        from the context: (Enum a, Num ((a -> a) -> b))
18:19:43 <EvanR_> (\_ -> id _ 5)
18:19:48 <EvanR_> :t flip id 5
18:19:48 <jared-w> > map (`id` 5) [succ, pred] -- typo
18:19:49 <lambdabot> Num b => (b -> c) -> c
18:19:50 <lambdabot>  [6,4]
18:19:53 <EvanR_> haha 
18:20:06 <EvanR_> oh wow didnt know (`id` 5) would work
18:20:08 <iqubic> Why does id have to be infix there?
18:20:16 <EvanR_> it doesnt
18:20:16 <geekosaur> so you don't have to use flip
18:20:29 <jared-w> > map (flip id 5) [succ, pred] -- flip is cancer
18:20:31 <lambdabot>  [6,4]
18:20:36 <EvanR_> you could flip id, an operation in of itself is a brain exploder
18:20:37 <geekosaur> could say "flip id 5" instead but flip is yeucch
18:21:04 <geekosaur> :t ($)
18:21:06 <lambdabot> (a -> b) -> a -> b
18:21:09 <geekosaur> :t id
18:21:11 <iqubic> `id` 5 has the same signature as ($ 5)
18:21:11 <lambdabot> a -> a
18:21:20 <iqubic> And I find that to weird.
18:21:21 <EvanR_> flip "takes a function of 2 arguments and flips the arguments" which makes no sense according to what we said earlier
18:21:28 <EvanR_> as all functions including id take 1
18:21:34 <geekosaur> instantiate 'a' as 'a0 -> b0' and id :: (a0 -> b0) -> a0 -> b0
18:21:48 <iqubic> flip f x y = f y x
18:21:58 <iqubic> I get how flip id works.
18:22:12 <iqubic> id x y = x y
18:22:22 <jared-w> reverseList = foldl (flip (:)) [] -- Do you get this? :p
18:22:32 <iqubic> No. Not at all
18:22:43 <jared-w> That's why nobody likes flip
18:22:53 <jared-w> Makes it too easy to write clever unreadable nonsense
18:23:10 <iqubic> Oh, wait, now I get what that is doing.
18:23:15 <iqubic> Let me guess.
18:23:29 <iqubic> getList = foldr (flip (:)) []
18:23:39 <iqubic> It returns the same list you started with.
18:23:39 <Rotaerk> I don't mind flip if it's just being used to define a named function that's the flipped form of another
18:23:41 <jared-w> anyway flip (:) means a : b -> b : a and you go all the way down the list using foldl and construct a new list starting from the empty list (base case)
18:23:52 <Rotaerk> but embedding it into larger expressions does make it less approachable
18:24:20 <iqubic> I like "flip const" a lot better that "const id" even though they do the exact same thing
18:24:39 <jared-w> funny, I like const id much better
18:24:52 <iqubic> Why is that jared-w?
18:25:46 <jared-w> oh whoops, I was thinking of something else for some reason. I like flip const better for most cases
18:26:03 <jared-w> Going back to what Rotaerk said about not minding flip if it's just used to define a function that's the flipped form of another
18:26:24 <jared-w> I'd probably just make a const' = flip const function myself
18:26:39 <iqubic> And sometimes I really do want a function that ignores the first argument and just gives the second
18:27:04 <Rotaerk> thing is, I prefer functions to be named such that in english grammar, the function is a verb acting on the first argument, and the rest of the arguments just provide further details
18:27:19 <Rotaerk> :t elem
18:27:20 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
18:27:28 <EvanR_> nice verb
18:27:50 <Rotaerk> "isElem" might be more appropriate :P
18:27:54 <EvanR_> is that like "google it"
18:28:04 <Rotaerk> but if I flipped it, I'd call it "isElemOf"
18:28:04 <iqubic> Yes.
18:28:25 <dibblego> @type elemOf
18:28:25 <EvanR_> yes less common Bool functions should be "isFoo"
18:28:27 <lambdabot> Eq a => Getting Any s a -> a -> s -> Bool
18:28:35 <jared-w> :t bool
18:28:37 <lambdabot> a -> a -> Bool -> a
18:28:48 <jared-w> I still think bool is about the worst name ever for a function with that signature
18:28:58 <Rotaerk> of course, when dealing with abstract things, naming gets hard
18:29:02 <EvanR_> thats different since its not returning Bool
18:29:07 <Rotaerk> so what I described above eventually falls apart
18:29:22 <EvanR_> yep naming makes almost no sense in math :)
18:29:51 <iqubic> Why do you have to use Getting there? what are you getting?
18:29:58 <Rotaerk> jared-w, it makes sense, sortof, because it's a function-based encoding of the bool type
18:30:07 <Rotaerk> (I forget what that's called ...)
18:30:11 <EvanR_> it only makes sense give the other destructor names
18:30:19 <jared-w> Rotaerk: case analysis?
18:30:23 <EvanR_> maybe, either, void
18:30:33 <EvanR_> foldr :)
18:30:55 <EvanR_> but these are still kind of weird names
18:31:28 <geekosaur> iqubic, Getting is half of a lens
18:31:40 <geekosaur> (the other half is a Setting)
18:31:40 <Rotaerk> it's a function saying ... how do you represent a Bool as an a
18:32:01 <Rotaerk> maybe is a function that represents a Maybe as an a
18:32:06 <Rotaerk> etc
18:32:11 <kadoban> jared-w: It's in analogy to maybe and either and etc.
18:32:15 <kadoban> Yeah, that ^
18:32:34 <Rotaerk> you could make similar functions for all the ADTs
18:32:35 <iqubic> geekosaur: I know that.
18:32:46 <geekosaur> then what is your confusion?
18:32:48 <jared-w> Right. I understand that, I still think the name is pretty dumb. It's something you have to internalize blindly rather than intuitively grasp from the function name
18:33:06 <iqubic> geekosaur: I don't understand what you are Getting in the isFoo function.
18:33:15 <jared-w> But, eh, it's something abstract enough that you can't really name it somethnig useful  ¯\_(ツ)_/¯
18:33:41 <geekosaur> that was't isFoo, it was elemOf
18:34:20 <iqubic> Why does the type of isElemOf require a Getting Any s a as the first parameter?
18:34:22 <torstein>   I'm having trouble getting the type signatures right with the new version of Accelerate... : http://lpaste.net/356368
18:37:17 <iqubic> What does the Any newtype wrapper look like?
18:41:08 <pacak> @src Any
18:41:08 <lambdabot> newtype Any = Any { getAny :: Bool }
18:41:38 <pacak> All interesting bits are in it's Monoid instance.
18:41:57 <iqubic> what is the Monoid instance?
18:42:04 <iqubic> mempty = true
18:42:11 <pacak> Nope.
18:42:29 <iqubic> What is it then?
18:42:41 <pacak> Take a look at the source yourself. It's somewhere there.
18:42:57 <iqubic> I don't understand newtype wrappers as well as I should
18:44:27 <pacak> iqubic: What Monoid instances for Bool can you imagine?
18:45:07 <iqubic> I can imagine using True and Or.
18:45:16 <iqubic> as well as False and And
18:45:27 <pacak> o_O
18:45:32 <pacak> Are you suuuuuure?
18:45:33 <iqubic> or rather True goes with Or
18:45:33 <monochrom> \∩/
18:45:47 <pacak> Mkay. And which one is correct?
18:45:50 <iqubic> I can't type correctly today
18:46:02 <iqubic> True with And
18:46:11 <iqubic> False with Or
18:46:18 <iqubic> Or I don't really know.
18:46:34 <pacak> So two instances. True+And and False+Or.
18:46:52 <iqubic> Or those the two instances?
18:47:04 <iqubic> Yes, I suppose they are
18:47:07 <pacak> How many instances one datatype can have?
18:47:14 <iqubic> All uses True+And
18:47:23 <iqubic> Any uses False+Or
18:47:41 * monochrom giggles evilly at pacak
18:47:57 <iqubic> and you need newtype wrappers because Instance Monoid Bool can't have definitions for both options
18:48:02 <pacak> monochrom: I'll teach him newtypes even if it kills him!
18:48:07 <iqubic> It's like Sum and Product
18:48:20 <monochrom> pacak: I mean this: https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html
18:48:21 <EvanR_> this is like haskell bootcamp drills
18:48:34 <iqubic> Newtype Sum = Sum {getSum :: a}
18:48:55 <EvanR_> list the monoid instances for Bool and give me replicate 100 pushups
18:49:08 <pacak> iqubic: Now you understand why there's Any?
18:49:11 <iqubic> Yes.
18:49:24 <iqubic> For the same reason that Sum and Product exist.
18:49:45 <iqubic> Because there are multiple valid monoid instances for those datatypes
18:50:48 <iqubic> And Ord+Bounded has two valid monoids. Min and Max
18:51:06 <pacak> monochrom: That looks like a very perverted way of writing "Down"...
18:51:19 <iqubic> What is "Down"?
18:51:23 <monochrom> No! I think Down is perverted instead.
18:51:28 <pacak> iqubic: What is Down?
18:51:41 <monochrom> Mine is closer to SML's functoring programming. I like it more.
18:51:48 <monochrom> OK, that's inventor bias, but meh.
18:51:53 <pacak> iqubic: Do some research and tell us.
18:52:20 <pacak> iqubic: hint: it's a newtype.
18:52:21 <EvanR_> this is where iqubic immediately explains that they already know what it is
18:52:30 <EvanR_> right after asking what it is
18:52:41 <iqubic> Is this the right thing? https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Ord.html#t:Down
18:52:51 <iqubic> Not entirely sure at this point
18:52:56 <pacak> iqubic: Yep. Why do we need it?
18:53:42 <iqubic> To reverse the sort order without writing multiple ord instances for the same datatype
18:53:59 <pacak> Nice.
18:54:17 <pacak> Do you have any other newtype/instance related question you'd like to answer to us?
18:54:19 <EvanR> more like, youre not allowed to have multiple Ord instances for the same datatype
18:54:35 * iqubic can read documentantion correctly
18:54:37 <EvanR> the haskell gods have deemed it
18:55:02 <geekosaur> torstein, did you look at the documentation for Acc?
18:55:10 <iqubic> pacak: Why can't a newtype declaration have multiple constructors
18:55:11 <iqubic> ?
18:56:03 <pacak> iqubic: newtype exists only on compile time. At runtime it's representation matches underlying type.
18:56:31 <iqubic> And, furthermore, why don't those newtype wrappers use the Data keyword instead?
18:56:54 <EvanR> they mean different things
18:57:04 <iqubic> They do?
18:57:06 <EvanR> yep
18:57:14 <iqubic> How so?
18:57:28 <EvanR> data Identity a = Identity a puts a wrapper around the a
18:57:51 <EvanR> if you use newtype, it doesnt
18:57:56 <iqubic> Oh.
18:58:07 <pacak> > Identity undefined `seq` ()
18:58:07 <EvanR> at runtime itll be just the a
18:58:09 <lambdabot>  *Exception: Prelude.undefined
18:58:13 <torstein> geekosaur: Yes, I did. I'm not sure why I'm getting errors now, since it worked before I upgraded from accelerate 0.15 to 1.0
18:58:18 <iqubic> So you can't pattern match on newtypes?
18:58:21 <pacak> @src Identity
18:58:21 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
18:58:24 <EvanR> you can
18:58:30 <pacak> > Just undefined `seq` ()
18:58:32 <lambdabot>  ()
18:58:49 <EvanR> Identity is actually a newtype, but you could have use data, but it wouldnt be less efficient
18:58:58 <EvanR> er
18:59:12 <EvanR> arglebargle glopglyf
18:59:15 <pharpend> Stack question (perhaps not the right channel)
18:59:44 <pharpend> I have a program installed with "stack install X"
18:59:51 <pharpend> and I want to update to the latest version
19:00:01 <iqubic> Did EvanR break?
19:00:08 <EvanR> yes ignore me
19:00:10 <pharpend> so I tried "stack install hindent-5.2.3"
19:00:36 <pharpend> one sec pasting the error message
19:01:03 <pharpend> http://lpaste.net/356369
19:01:14 <geekosaur> torstein, from what I am seeing you need to 'lift' stuff to the GPU, or lower it back to the CPU with e.g. 'use'
19:02:03 <pharpend> I understand what the error means
19:02:42 <geekosaur> you'll want to use --solver or specify an lts or nightly that contains an appropriate version of haskell-src-exts
19:02:48 <pharpend> I'm hoping there's a way to install the new version of hindent in such a manner that stack will also upgrade all packages that depend on the old version of haskell-src-estx
19:03:00 <pharpend> geekosaur: let me try that
19:04:09 <pharpend> geekosaur: could you give me a command to run
19:04:17 <pharpend> I can't find any command that takes --solver as an option
19:04:47 <pharpend> ah --resolver
19:04:55 <iqubic> Nope.
19:05:05 <iqubic> Try Stack-solver
19:05:17 <geekosaur> that option is how you'd specify a resolver to use, yes. --solver may only work within an actual package
19:05:21 <pharpend> geekosaur: thanks, now compiling
19:05:43 <geekosaur> and 'install' doesn't track what it does, so the idea of reinstalling everything outside of a project doesn't really exist
19:05:53 <pharpend> geekosaur: I think you mean "stack solver", which picks a stackage snapshot in a project
19:05:56 <geekosaur> ('install' perhaps should be called 'deploy')
19:06:10 <pharpend> geekosaur: I wish there was a stack equivalent of apt-get upgrade
19:06:13 <geekosaur> no, there's a --solver but it's only applicable in a project
19:06:21 <pharpend> I see
19:07:09 <geekosaur> you're in the global context and there is no stack.yaml to apply it to, and it doesn't know what else is "installed" --- it does not keep a package registry of executables to be upgraded
19:08:01 <torstein> geekosaur: the input the function is already 'use'd. Their own example in the documentation of Acc gives the same error (with accelerate 1.0.0) https://hackage.haskell.org/package/accelerate-1.0.0.0/docs/Data-Array-Accelerate.html#t:Acc
19:10:08 <geekosaur> torstein, I went poking in accelerate-examples and it showed things like (lift :+ (constant 5)) and such to get "normal" operations into the GPU. beyond that, I don't know
20:29:13 <Engen> hey everyone, I'm just currently trying to get my head around GADTs in haskell and wanted to run through some example code to see if my understanding was correct http://lpaste.net/3206678331869102080
20:31:15 <Engen> line 12 is a declaration of a data type Nat which is either Z or S Nat. Is this saying Nat can either be a Z or S Nat? or are these constructors that need to be given arguments? 
20:31:33 <Axman6> Engen: the usual type for headV would be headV :: Vec (S n) a -> a
20:32:19 <mniip> Engen, that's a regular datatype declaration, are you familiar with those?
20:32:22 <Axman6> Engen: that's just a norman Haskell data structure, nothing special about it. is says that Nat can be Z, or SZ, or S (S Z) etc
20:34:29 <Axman6> S Z*
20:35:08 <Engen> mniip: yes I am, it's just that when GADTs get thrown into the picture I'm always second guessing myself as to what is affected and what isn't 
20:35:45 <EvanR> Nat using GADT syntax (but not using any GADT-specific features, i.e. weird type variables in the result type) http://lpaste.net/356370
20:36:08 <EvanR> now its clear that S is a function that takes an argument
20:36:49 <mniip> man the type-level syntax is a mess
20:37:23 <Engen> for example, I've previously defined data BinaryTree = Branch Integer BinaryTree BinaryTree | Leaf and I can understand that Branch is an object that holds an integer and two other BinaryTree objects but S Nat, I can't figure it out 
20:37:55 <EvanR> S holds a Nat
20:38:07 <Engen> where as Z is just a Nat?
20:38:08 <EvanR> namely, its predecessor
20:38:15 <EvanR> Z is just a Nat
20:38:18 <mniip> it's literally the same as the example you just provided
20:38:35 <Engen> yeah I know, I'm just comparing the two
20:38:47 <Engen> oh ok that makes sense 
20:38:57 <EvanR> yeah BinaryTree is a branching version of Nat
20:39:06 <EvanR> oh ... it holds an Integer payload, nevermind
20:39:07 <Axman6> Nat is just two constrcutors, Z :: Nat and S :: Nat -> Nat
20:39:26 <EvanR> for giggles, rewrite your BinaryTree in GADT syntax
20:39:48 <Axman6> (and then track its exact layout in the type!)
20:40:10 <EvanR> thatll be the three star addendum exercise
20:40:35 <Engen> one step at a time... 
20:40:48 <mniip> I don't suppose anything could be done to haskell to unify the, what, 3 ways we have of denoting function types/kinds?
20:40:58 <mniip> breaking syntax is no small deal...
20:41:43 <Engen> ok so then the two type family defnitions are definitions we make so we add and multiply with new newly made Nat type
20:42:17 <mniip> Engen, more correctly, the newly made Nat kind
20:42:28 <mniip> they are type families, and they operate at type level
20:42:33 <EvanR> this is another story, you are probably using Nat as a promoted type, in the domain of DataKinds
20:42:46 <mniip> due to DataKinds, we have a new kind Nat
20:42:58 <mniip> with a type Z and a type constructor S
20:43:08 <EvanR> now Z is a type of kind Nat and S Z is another (different) type of kind Nat
20:44:31 <EvanR> since haskell is silly and doesnt let you just use Nat values in types directly
20:45:24 <Engen> so it goes kind -> type -> data (not literally but I'm trying to see the heirarchy) 
20:45:45 <mniip> sort-of
20:45:47 <EvanR> its like this
20:45:51 <EvanR> value : type
20:45:56 <EvanR>      type : kind
20:46:11 <EvanR> and after promotion
20:46:34 <EvanR>      value-as-type : type-as-kind
20:47:02 <EvanR> and after -XDependentTypes
20:47:04 <EvanR> who knows
20:47:18 <mniip> well, let's start with TypeInType
20:47:26 <mniip> where kind = type
20:47:38 <mniip> :p
20:47:44 <EvanR> which collapses the universe into a blackhole 
20:49:39 <Engen> so because of us creating our own kind, we also need to define operations we can perform on this kind, namely + and *
20:50:28 <EvanR> type families are operations defined on types, so you can + two types to get a type
20:50:29 <Engen> which is what's done. type family (+) takes two objects of kind Nat and produces something of kind Nat
20:50:51 <Engen> similarly with the multiplication operation 
20:51:04 <Engen> oh so it's type, not kind
20:51:43 <EvanR> i guess it depends on what "defined on" means... could go either way
20:52:18 <Engen> in the instances of dealing with the types, why does line 15 not use (S m) but line 16 uses (S n) and again not (S m)?
20:52:27 <EvanR> division is defined on numbers... "Number" could be a type
20:52:43 <EvanR> but i wouldnt say division is defined on types
20:53:40 <EvanR> line 15 and 16 are defining addition
20:54:04 <EvanR> whether and where you put S depends on what you think addition is supposed to do :)
20:54:18 <Engen> yes, but why is the use of (S var) inconsistent with... oh boy
20:54:26 <EvanR> with what
20:54:38 <MarcelineVQ> inconsistent?
20:55:12 <lamefun_> Is it possible to abberviate deriving-lists? To shorten eg. http://lpaste.net/5964547918634418176
20:55:14 <Engen> why is it not type instance Z + (S m) = m and type instance (S n) + (S m) = S (n + m) ?
20:55:32 <EvanR> you wrote "zero + (number after m) = m"
20:55:33 <lamefun_> (have I missed any class)?
20:55:42 <EvanR> i.e. adding zero actually subtracts 1
20:56:18 <Engen> sorry, type instance Z + (S m) = (S m)
20:56:21 <MarcelineVQ> Engen: What is this exercise from?
20:56:32 <EvanR> your section equation is just wrong
20:56:43 <EvanR> (n+1) + (m+1) = n + m + 1
20:57:29 <Engen> MarcelineVQ: intro to haskell review exercises for school 
20:57:31 <EvanR> Z + (S m) = (S m) is right but doesnt answer what happens in case of Z + Z
20:57:49 <EvanR> m stands for any Nat, not just successors
20:57:52 <Engen> oh I see now, S is a successor 'function' to it's own kind 
20:58:15 <MarcelineVQ> really, intro? interesting, this is considered advanced or at least mid stuff
20:58:18 <EvanR> S is the famous successor operation
20:59:18 <iqubic> What are we talking about here?
20:59:25 <Engen> MarcelineVQ: some other guy said the same thing on here a couple weeks ago when I was again in need of aid 
20:59:37 <EvanR> iqubic: http://lpaste.net/3206678331869102080
20:59:44 <MarcelineVQ> Engen: ehe, well I'm not trying to discourage you at all I just find that interesting
21:00:07 <mniip> MarcelineVQ, next thing they'll be teaching monad transformers in preschool
21:00:23 <iqubic> What is a type operator? And what are Generalize Algerbraic Data Types?
21:00:24 <MarcelineVQ> iqubic: the start of dependently-typed haskell
21:00:51 <mniip> er what
21:01:04 <iqubic> Is that file an example of dependetly typed Haskell?
21:01:10 <mniip> no
21:01:31 <mniip> dependently typed haskell doesn't exist yet
21:01:37 <mniip> though it will farily soon
21:01:55 <EvanR> its an example of faking dependent types to an extent
21:01:56 <iqubic> Will there be a new version of GHC?
21:02:15 <mniip> yes
21:02:37 <iqubic> Is it possible to use Stack to manage GHC versions?
21:02:41 <iqubic> How does that work?
21:02:41 <Engen> EvanR: alright I understand what they've done. Z (nothing) + m (something) = m (something), (S n) (successor of n) + m (something) = S (n + m) (successor of those two added together) ((if any of this is incorrect please slap me silly))
21:02:58 <EvanR> thats right
21:03:12 <pacak> It's kind of possible to write dependently typed programs in haskell already, but it's ugly and slow.
21:03:25 <Axman6> iqubic: stack will install whichever GHC versions ae needed by the specified LTS/nightly
21:03:30 <MarcelineVQ> iqubic: that question can be answered by learning how stack works
21:03:45 <iqubic> So when GHC updates, stack will pull in the new version?
21:03:50 <Axman6> no
21:03:59 <Engen> and so the whole premise of defining our Nat kind was so that we could have a type-safe implementation of a vector (Vec)
21:04:01 <mniip> pacak, singletons?
21:04:08 <pacak> mniip: yep
21:04:15 <EvanR> its so you can use numbers in the types of stuff
21:04:16 <mniip> I guess
21:04:26 <EvanR> Vect is one use-case
21:04:27 <mniip> goldfire references it in his thesis
21:04:39 <Axman6> each snapshot is tied to a specific GHC version. once a new snapshot exists which uses GHC 8.2 for example, then Stack will download and install it if necessary
21:05:07 <Axman6> if you have a package which uses that new snapshot*
21:05:34 <Axman6> iqubic: the stack documents are pretty clear about how this all works
21:06:01 <EvanR> its not just about type safety, the information in the type of Vect is informative for readers, and being able to express more stuff in the types can help you design your system
21:07:05 <Engen> yeah, I understand that's the whole point of using GADTs and kinds, but how the code is actually doing is what I've been struggling to understand 
21:07:26 <EvanR> it helps to play around with stuff in the repl
21:08:04 <Axman6> Engen: you might (eventually) find this post really intersting once you get a good handle on this GADT stuff, I found it fascinating (though didn't understand 100% of the details): http://doisinkidney.com/posts/2017-04-23-verifying-data-structures-in-haskell-lhs.html
21:08:12 <EvanR> like :t VCons 'a' (VCons 'b' VNil)
21:08:27 <Engen> so Vec has two components, n :: Nat which defines the size of the vector as a type, and a, which is something of some type we don't know nor care about 
21:08:52 <Axman6> Engen: well, a is the type of things contained in the vector (like the a in [a])
21:08:53 <mniip> EvanR, are you familiar with the 12 arrows of dependent haskell :p
21:08:56 <EvanR> n tracks the length of the vector
21:09:19 <EvanR> by the way its cleverly used in the GADT definition
21:09:43 <Axman6> Engen: also, make sure that in your sentense you wrote, you read "n :: Nat" as "n has kind Nat", in this case
21:09:45 <iqubic> Axman6: What if my code requires a later version of GHC than any of the dependecies I'm pulling in.
21:10:02 <Axman6> I don't know what you mean
21:10:24 <iqubic> What if I want to use dependent types, but none of my project deps require that?
21:10:30 <EvanR> mniip: nope
21:10:45 <iqubic> I mean, when those are officially a thing
21:11:34 <Axman6> old code hopefully should compile with newer GHCs. but this is one of the problems stackage aims to help with, all packages in a snapshot are known to a) compile with the specified GHC for the snapshot and b) there aren't version conflicts within a snapshot
21:11:36 <Engen> Axman6: noted
21:11:57 <EvanR> Engen: VCons 'a' (VCons 'b' VNil) will end up with the type Vec (S (S Z)) Char, aka Vec 2 Char
21:12:23 <mniip> EvanR, http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf#page=74
21:12:28 <EvanR> because VNil has type Vec 0 Char, and each Cons adds 1
21:13:36 <EvanR> this example of dependent types is so overused ...
21:14:17 <EvanR> mniip: what in the world o_O
21:14:39 <mniip> (hmm, am I getting this right, dependent types are reuqired once you need a relevant dependent type)
21:15:04 <mniip> EvanR, it kind of makes sense if you look at it
21:15:10 <Engen> EvanR: I'm confused. VNil :: Vec Z a follows the structure of Vec (n :: Nat) a but VCons takes something of type a first then a vector 
21:15:21 <mniip> modern haskell has 3 of those quantifiers
21:15:35 <mniip> and one more can be implicitly observed in type families
21:15:39 <EvanR> Engen: yes VNil is a constant, VCons takes 2 arguments, like regular list (:)
21:16:01 <EvanR> not none of the arguments anywhere are actually *numbers*
21:16:03 <EvanR> note*
21:16:05 <mniip> any sort of kind-polymorphism is not actually 'forall' but 'pi'
21:16:23 <EvanR> the numbers are completely at the type level, they dont exist during runtime
21:16:43 <EvanR> which means to detect the number at runtime, youll need shenanigans
21:17:07 <EvanR> if you wanted to
21:17:36 <Engen> yep, I understand that and yeah I understand it now - basically to instantiate a vector with say 'a' you'd always base it off VNil 
21:18:00 <EvanR> to construct a list you must begin with an empty list, which is available "for free"
21:18:09 <EvanR> to cons, you need a list to cons onto
21:18:18 <Engen> I also understand that my terminology for referring to terms is probably very all over the place and I apologise for this
21:18:24 <EvanR> its inductive like that
21:18:34 <Engen> yep
21:19:47 <EvanR> bonus question... does this Vec thing prohibit infinite lists
21:19:51 <Engen> and so is that why in headV, appendV and concatV, they don't ever refer to the type of the vector, but merely the contents?
21:20:18 <Engen> hmm, I can't think of any reason why it would
21:20:40 <EvanR> they do refer to the type
21:20:44 <EvanR> in the type sig
21:21:02 <Engen> in that yes, but line 30 for example, getting the head of the vector
21:21:16 <EvanR> thats normal looking code
21:21:29 <EvanR> except its missing a case for empty list
21:21:40 <EvanR> (because its impossible as-typed)
21:22:00 <EvanR> oh no!
21:22:13 <EvanR> headV :: Vec n a -> a, its not stopping empty lists!
21:22:50 <Engen> x is referring to n, which is the size of the vector as defined by the type, and a is the contents
21:22:58 <EvanR> x is not referring to n
21:23:11 <Engen> ok, that exactly is where I'm confused, why?
21:23:27 <EvanR> remember numbers arent stored anywhere in this structure
21:23:45 <EvanR> x is the first arg to VCons
21:25:08 <Engen> to VCons... isn't line 30 vanilla haskell in that we give headV a (VCons x xs) object and it'll do what the function is defined to do?
21:25:09 <Axman6> VCons :: a -> Vec n a -> Vec (S n) a
21:25:33 <Axman6> so a VCons contains one a, and a vector of n a's
21:26:12 <EvanR> Engen: look again, youre mixing up value and type level expressions
21:26:39 <Axman6> Engen: sure, but it's not actually what you want, because if you pass in a Nil, you'll get a pattern match failure - what you really want is a safe head, which ensures you can always get the head, ie, that the length is at least 1 (or (S n) for any n)
21:28:17 <Axman6> so the usual type would be: headV :: Vec (S n) a -> a - this means that we only need to match on the VCons constructor, because it is the only value of tyoe Vec which has (S n) - Nil has type Vec Z a, which doesn't match Vec (S n) a
21:29:37 <EvanR> does ghc somehow check this case isnt needed?
21:29:53 <EvanR> so as not to warn
21:30:33 <mniip> yes
21:30:59 <mniip> GADT pattern matches that are ill-typed aren't considered missing
21:31:09 <Engen> what I'm confused about is why we're constructing a Vector as an argument to headV
21:31:33 <pacak> Not in 7.10...
21:31:34 <EvanR> you asked a question?
21:31:53 <c_wraith> Engen: are you talking about pattern-matching?
21:32:26 <Engen> is headV (Vcons x xs) constructing a new Vector as an argument or is headV looking at a Vector that's already been pre-defined?
21:32:28 <mniip> oh huh
21:32:33 <mniip> I'm on 8.3 :s
21:32:45 <EvanR> mniip: are we really going be typing ∏
21:32:55 <c_wraith> Engen: you should learn about pattern-matching before getting to GADTs
21:33:18 <Engen> c_wraith: I know what pattern matching is
21:33:26 <Engen> I'll just draw it out
21:33:32 <mniip> EvanR, see Appendix A
21:33:33 <EvanR> its not consturctor a new vector
21:33:46 <c_wraith> Engen: I suspect you don't, if you're asking why a pattern match is constructing something.
21:34:32 <EvanR> ya im not sure what level of familiarity to assume anymore after that question!
21:35:36 <Engen> http://wklej.org/hash/1e426e12980/
21:35:37 <pacak> mniip: I'd love to move but there's a performance regression somewhere around 7.10.2.... That's still there in 8.2.
21:36:06 <Axman6> Engen: looks ike there's some haskell fundamentals you need to learn before jumping into GADTs :)
21:36:10 <mniip> pacak, tell me more about it?
21:36:12 <c_wraith> Engen: pattern matches deconstruct the value arguments to a constructor, not the type arguments
21:36:38 <EvanR> i can see how it can be confusing, they both have 2 arguments
21:36:50 <EvanR> but its a totally different 2, of different sorts entirely
21:37:08 <EvanR> Vec n a is a type, n is a type, a is a type
21:37:20 <EvanR> VCons x xs is a value, x is a value, xs is a value
21:37:32 <EvanR> x :: a
21:37:37 <EvanR> xs :: Vec n a
21:37:59 <EvanR> nothing is of type n here
21:40:24 <pacak> mniip: There's about 150k lines of code and one of performance metrics is about twice as slow. The problem is it should be more or less no-op.
21:40:45 <pacak> I wonder if I should take a look at it once more...
21:41:48 <Engen> EvanR: alright, it makes sense
21:42:38 <EvanR> actually, i dont think theres any sane value of type n for any Nat n
21:43:01 <EvanR> like 3 = S (S (S Z)) is just a type, no values
21:43:37 <Engen> since you can only get the head of a vector that's been constructed, we know that the head of a vector is always going to be the first argument to VCons 
21:43:57 <EvanR> VNil has no head...
21:43:58 <mniip> pacak, no I'm legit interested
21:44:36 <Engen> EvanR: except VNil*** which is why it's not there at all :) 
21:44:36 <EvanR> your code will allow me to do headV VNil
21:44:37 * Axman6 is also curious
21:44:46 <EvanR> which will crash
21:45:22 <EvanR> totally avoidable if you change your code!
21:45:26 <mniip> I've seen the ghc wiki mention something called fltkhs had a quadruple regression but I couldn't compile it
21:45:43 <iqubic> What is quadrouple regression?
21:46:00 <pacak> iqubic: Like a regular regression but quadruple.
21:46:22 <iqubic> I don't know what a regular regression is.
21:46:40 <mniip> [context-free regression]
21:46:46 <EvanR> perl compatible regression?
21:46:57 <pacak> linear regression?
21:47:01 <boj> i get the feelign iqubic is a bot
21:47:08 <mniip> arithmetic regression
21:47:17 <EvanR> that would explain a few things
21:47:19 <Engen> EvanR: too correct you are
21:48:00 <EvanR> putting a proper type on operations like headV is kind of the whole point of Vec
21:48:09 <iqubic> I am not a bot.
21:48:18 <Axman6> That's what all the bots say
21:48:20 <Axman6> @bot
21:48:20 <lambdabot> :)
21:48:22 <lambdabot> That's what a bot would say.
21:48:27 <iqubic> I am not a bot.
21:48:41 <iqubic> How shall I prove that I am not a bot?
21:48:51 <iqubic> Would you like to try the turing test?
21:48:54 <EvanR> dont check this box [ ]
21:48:56 <Axman6> anyone got a spare turing test laying around?
21:49:15 <iqubic> EvanR: [ ] Done.
21:49:21 <iqubic> I didn't check the box
21:49:25 <Axman6> who is lambdabot's current handler anyway?
21:49:45 <Axman6> EvanR: classic response from a bot using machine learning. well done, you caught it!
21:50:00 <pacak> mniip: It's our trading system so for obvious reasons code is not avaiable. But it reveals a bunch of strange behaviours in ghc. For example if in a datatype with 200+ fields you add forall a. a field and put () in there - a lot of things are suddenly by 5% faster.
21:50:31 <Axman6> pacak: Can you write a "One weird trick" article about that please?
21:50:41 <Axman6> also... 200+ fields? :'(
21:50:51 <EvanR> i know, were all doomed
21:51:20 <pacak> Axman6: A bunch of historical reasons :)
21:51:40 <mniip> you could make a list of reasons
21:51:53 <iqubic> Like wanting to test the limits of GHC
21:51:54 <mniip> :)
21:52:03 <cocreature> mniip: would that list have 200+ items?
21:52:09 <EvanR> his number of fields are over 2000
21:52:19 <iqubic> It's over 9000!!!
21:52:29 <Engen> thanks to everyone's input so far - the help is truly appreciated 
21:52:43 <pacak> I'd love to write an article except that at the moment I have no ideas why it makes a difference. Well... I do know why - ghc transfers them around either as a reference or by spilling it into stack, but why  would it do that - it's a mystery.
21:52:52 <EvanR> meanwhile javascript and languages who think records = string tables are laughing their ass off as ghc
21:53:54 <pacak> Javascript quizz. You can check if something is a string in javascript by doing (typeof foo === typeof "string"). How can you check if something is an array?
21:54:08 <EvanR> offtopic
21:54:20 <Axman6> by calling it's toString method and checking it starts with '['
21:54:22 <Axman6> >_>
21:54:26 <EvanR> ([]).apply('toString', foo) 
21:54:37 <LiaoTao> Javascript is disgusting.
21:54:46 <pacak> Array.isArray(foo)
21:54:54 <pacak> It is :(
21:55:17 <Axman6> hey, that's not nice, some languages are born without enough oxygen
21:55:28 <iqubic> pacak: Does JS treat Strings as Arrays of Char?
21:55:29 <LiaoTao> Always keep going back because of HTML5 goodness, always get disgusted within a few hours and just stop
21:55:40 <EvanR> iqubic: you can ask #javascript !
21:55:47 <iqubic> EvanR: I might do that.
21:55:48 <Axman6> and google
21:55:52 <iqubic> LOL
21:55:55 <pacak> iqubic: No.
21:56:03 <iqubic> Way to be a buzzkill.
21:56:06 <Axman6> they will get mad if you don't ask google first actually
21:56:27 <iqubic> Now I don't get the pleasure of asking google my question
21:56:29 <Axman6> because people get mad when people ask questions without any attempt to answer it for themselves first
21:56:34 <EvanR> yes your googlable questioning is unusually tolerated here
21:56:37 <iqubic> Thanks a lot pacak!!! GRRR
21:57:14 <EvanR> so many questions asked here cant be googled ...
21:57:25 <Axman6> "what is <>"
21:57:32 <EvanR> haha
21:57:40 <EvanR> $
21:57:50 <Axman6> "what is ."
21:58:25 <pacak> Axman6: Actually google gives answer for <>
21:58:33 <MP2E> "how to use $" :P
21:58:33 <glguy> Actually, if I search for "haskell <>" I get an answer as the first hit in Google
21:59:00 <LiaoTao> Google used to be terrible for queries like that until someone wised up at HQ
21:59:32 <Engen> that's actually a lot of the trouble I've been having with this course, every time I try and google something advanced I end up at some thesis or conference paper which is way over my head 
21:59:58 <Axman6> yeah generally assing "haskell" to the beginning of a query sorts google out
22:00:02 <Axman6> iqubic: hint hint
22:00:09 <pacak> Q: Google, what is "catamorphism"?
22:00:09 <pacak> A: Did you mean "best cat videos"?
22:00:15 <iqubic> Thank you.
22:01:06 <pikajude> didn't catamorphism happen in one of those animorphs books?
22:01:10 <iqubic> Searching "What is <>" gives me a bunch sql related stuff
22:01:43 <LiaoTao> Actually, what is "<>"?
22:01:53 <pacak> LiaoTao: mappend
22:01:57 <EvanR> visual basic for not equals
22:01:59 <LiaoTao> Ahaa
22:02:12 <iqubic> wait, EvanR is that true?
22:02:28 <EvanR> at some point in history
22:02:43 <iqubic> LiaoTao: m <> n = mappend m n
22:02:56 <LiaoTao> pacak: iqubic: Goti t
22:02:58 <iqubic> Given that m and n are valid Monoids
22:02:58 <LiaoTao> Got it*
22:02:59 <LiaoTao> Thanks
22:03:07 <LiaoTao> Didn't know it had a shorthand
22:03:27 <iqubic> The infix version shows up in a lot of places.
22:03:35 <iqubic> It's quicker to write
22:03:37 <EvanR> unforunately, not in Prelude
22:03:52 <iqubic> Is Monoid in Prelude?
22:04:07 <EvanR> it actually wasnt even anywhere when i first started haskell
22:04:20 <EvanR> you defined <> yourself
22:04:26 <iqubic> EvanR: How long have you been Haskelling?
22:05:26 <EvanR> 8 years
22:05:32 <iqubic> So in VB "x <> y" means x is greater than y, or x is less than y. It's a check for inequality
22:06:08 <pacak> iqubic: in brainfuck it's noop.
22:06:34 <iqubic> Yeah, most stuff in BF is noop
22:06:52 <LiaoTao> VB, another horrid language.
22:06:56 <LiaoTao> :(
22:07:05 <iqubic> It has eight operators, right? BF?
22:07:33 <pacak> iqubic: That's all you need.
22:07:50 <iqubic> I've always wanted to make a BF interperter in Haskell, but I've never known where to start
22:08:03 <ongy> EvanR: really? I thought you are here for longer... when I started out you were one of the people here that idled around and helped a lot already
22:08:29 <ongy> mhh, I guess that's still 6 years of doing haskell... Right I'm new haha
22:09:27 <LiaoTao> Any old Gods in here?
22:09:38 <LiaoTao> GHC beta came out in 1991, after all :)
22:11:27 <geekosaur> "only" 10 years here :)
22:13:48 <LiaoTao> geekosaur: That's quite firmly into the "Before it was cool" period
22:13:49 <LiaoTao> Respect
22:14:01 <LiaoTao> Although Haskell was always cool
22:14:13 <EvanR> haskell was cool before it was cool
22:14:16 <EvanR> beat that
22:14:34 <johnw> and before it was cool, there was a theory that said that when it came to be, it would be cool
22:17:30 <MarcelineVQ> haskell wasn't cool at first but it turned out later on that between cold and hot there was a common pattern that could be generalized
22:27:22 <Axman6> pretty sure I'm at about 10 years too
