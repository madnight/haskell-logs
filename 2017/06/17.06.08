00:01:38 * hackage streaming-conduit 0.1.1.0 - Bidirectional support between the streaming and conduit libraries  https://hackage.haskell.org/package/streaming-conduit-0.1.1.0 (IvanMiljenovic)
00:08:56 <Axman6> MarcelineVQ: there was a good talk at LambdaJam about continuation based transformations, video isn't up yet though
00:12:21 <MarcelineVQ> neato
00:13:38 * hackage prettyprinter 1.1 - A modern, easy to use, well-documented, extensible prettyprinter.  https://hackage.haskell.org/package/prettyprinter-1.1 (quchen)
00:49:00 <merijn> eh, am I missing something or does cryptonite not expose a way to turn a Digest into a ByteString?
00:49:03 <merijn> https://hackage.haskell.org/package/cryptonite-0.23/docs/Crypto-Hash.html#t:Digest
00:55:44 <cocreature> merijn: the ByteArrayAccess instance should allow you to do that but I’m not sure if there is a convenient wrapper for it
00:56:00 <merijn> cocreature: Apparently it's "convert"
00:56:16 <merijn> cocreature: I really hate all this obnoxious typeclassing in some corners of the ecosystem
00:56:45 <cocreature> merijn: yeah it can definitely be annoying.
00:57:27 <merijn> I used Yesod for a bit, but there was way too much "where the fuck is this obscure typeclass documented" for my tastes
00:57:44 <cocreature> merijn: but given that vincent is working on foundation I can see why he wants to typeclass all of this.
00:58:59 <merijn> No clue what foundation is :)
00:59:55 <cocreature> it’s a kitchen sink lib that among other things provides replacements for ByteString and Text
01:00:56 <cocreature> oh an Vector
01:02:58 <cocreature> it does have some nice things but so far I’m far from being sold on it
01:08:51 <merijn> cocreature: Well, this is all research "use at your own risk" code, so IDGAF about the dependency footprint. As long as it works for me and I don't have to reinvent too much it's someone else's problem :p
01:09:59 <jared-w> merijn: sup
01:11:02 <jared-w> So the yak shaving page on haskellwiki hasn't been touched yet...
01:13:52 <merijn> jared-w: Yeah, I've been doing a bunch of yak shaving myself because it was blocking my actual work. I need to somehow manage to get some critical mass of tasks that aren't actually blocking me :p
01:13:53 <jared-w> cocreature: is foundation a prelude alternative?
01:14:41 <jared-w> Ahh, I gotcha. I've definitely had that happen to me before, it's not really fun. At least it's pretty easy to know what to do next? lol
01:15:03 <merijn> And some of the yak shaving I'm thinking of might be a bit too intimidating for beginners
01:15:48 <jared-w> quchen: your readme might benefit from an explicit "why should a library switch their printer with mine" section (or a "why making a PR to other libraries to sub out their printer with mine isn't just wasting their time")
01:16:14 <merijn> jared-w: One thing I'd love to see is an ADOPT pragma to selectively silence orphan instance warnings, but that would require modifying the GHC parser, which is a can of worms :)
01:17:10 <jared-w> Also, I forget... I've been looking at pretty's library on github. Apparently ghc's internal pretty version has diverged significantly and there's some work on merging ghc's and the upstream one back together. Were you looking to have your prettyprinter replace ghc's pretty at some point?
01:17:30 <jared-w> I thought I remembered some discussion on that last time we talked about that library, but I could be wrong :p
01:17:33 <merijn> jared-w: There was some discussion about that on the mailing list
01:17:48 <jared-w> oooh mailing list. Probably should get in the habit of checking that...
01:17:51 <merijn> jared-w: But one of the issues is that would pull in additional dependencies for GHC, limiting users of the GHC API
01:17:56 <quchen> jared-w: Bringing Text into GHC is a piece of work, but backporting to String should not be a problem
01:18:39 <jared-w> One of the issues of ghc's pretty vs upstream pretty is actually that ghc's version uses the internal FastString because String is so slow. Using ByteString or something like that would also work
01:18:51 <merijn> quchen: The true solution would be to make it datatype polymorphic and allow people to use "prettyprinter-text" and "prettyprinter-string" as different backends ;)
01:19:14 <merijn> quchen: That way you could drop the text dependency in the main library
01:20:04 <jared-w> likely with a prettyprinter FastString or ByteString backend as well, for the ghc printer. GHC also uses the printer to print out the entire assembly, so an extremely quick unlimited-bandwith-optimized special case was also requested on the pretty github
01:20:13 <jared-w> https://github.com/haskell/pretty/issues/44
01:21:09 <jared-w> merijn: why would an adopt pragma necessitate modifying the parser? (or is that the case for any pragma at all?)
01:21:11 <quchen> I haven’t optimized it for this use case. I printed sizeable outputs without problems, but I imagine GHC has fairly specific requirements.
01:21:23 <merijn> like, just have a "data Builder a = Builder { concat :: a -> a -> a; ... }" and have "prettyWith :: Builder a -> Doc -> a" and have all the specific operation in wrapper libraries that export prettyString, etc. Then GHC could even keep using their FastString with that interface
01:22:09 <merijn> jared-w: Well, you have to recognise it's a PRAGMA, not a regular comment. OTOH, people could look at how RULE/INLINE are implemented in the parser
01:22:26 <jared-w> quchen: half a million lines of haskell, converted into assembler code, and then printed out and piped into an assembler... :p
01:23:14 <quchen> That’s not really my intended use case :-þ
01:23:29 <jared-w> But don't you want it FASSTTTTT?! ಠ_ಠ
01:23:31 <merijn> quchen: Although I suppose such a change would immediately break backwards compatibility within one version :p
01:24:08 * hackage alerta 0.1.0.0 - Bindings to the alerta REST API  https://hackage.haskell.org/package/alerta-0.1.0.0 (MarkHopkins)
01:24:29 <quchen> I don’t want it to be super fast bad enough to spend a lot of time benchmarking it in the first place.
01:24:32 <jared-w> merijn: what if you had a data Builder and then exported a default cookie-cutter builder that kept prior "working" behavior?/ Then you don't break compatibility
01:24:37 <quchen> Maybe when I’m in the mood
01:26:04 <jared-w> In the case of GHC's definition of "fast", fast for them involves using FastString (basically byteString with a few shiny addons) and a "cheap" AST with a set of interpreters so that you do as close to zero backtracking or layout as possible. Pretty niche use case tbh
01:27:09 <jared-w> tbh it feels like they're sorta abusing a prettyprinter at that point if they're just spitting out "non pretty" code, but eh  ¯\_(ツ)_/¯
01:32:53 <SepakoRayl> hey guys I asked yesterday but it seems I had a network error and I was disconnected when I did. Uh has anyone read https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf? What's the point of using type families as described?
01:34:10 <alanz> SepakoRayl: it allows you to separately define the type for each extension point in each constructor, based on a single index parameter to the type as a whole
01:34:37 <Athas> It means you can get away with one type parameter instead of many.
01:35:16 <SepakoRayl> ah thought so I figured we could just pass them as type parameters and then make a type synonym or something
01:36:31 <Athas> Sure, but you'll have a _lot_ of type parameters, and whenever you add another one, you have to fix all existing uses of the type.
01:41:18 <SepakoRayl> can't we just use a type alias everywhere else? This way only the definition changes.
01:46:01 <SepakoRayl> Ah but then you have to change all other aliases
01:51:27 <jared-w> Hmm... 
01:52:50 <jared-w> Protolude has a head function that's implemented in terms of foldr and returns a maybe. However, I can't use that head function on Text. The Data.Text library, on the other hand, has a head function specifically for Text. Is there any way to generalize the two into one function? Or does haskell not have that level of abstraction possible?
01:54:35 <haskman> @jared-w you probably want mono-traversable package
01:54:35 <lambdabot> Unknown command, try @list
01:55:03 <merijn> jared-w: You could make a typeclassed head with an associated type to accomplish that, but the question is whether it's worth the effort
01:55:27 <merijn> jared-w: Typeclassed functions rarely improve things all that much and they make the errors and documentation a pain in the neck
01:58:19 <jared-w> Right, I figured that would be the case. Typeclasses are great, but abusing them to overload functions can get a bit much :p
01:58:36 <quchen> jaspervdj: I hate mailing lists. They all, without exception, suck and make me angry. Not even printers are that bad. :-C Here is what happens when I click the invitation link: https://imgur.com/a/WDjD4
01:59:13 <quchen> jaspervdj: Just send my mail instead of inviting me to the group or I’ll lose my sanity :-s
01:59:26 <jared-w> lol
01:59:27 <jaspervdj> quchen: I don't really hate mailing lists in general, but I do hate google groups :-)
01:59:46 <jared-w> Mailing lists are great, google groups are a sin upon mailing lists
01:59:47 <quchen> I hate Google Groups in particular. It’s bad even according to mailing list standards.
01:59:52 <jaspervdj> quchen: I sent the mail for you but I'll still trying to add you in case anyone tries to get in touch
02:00:07 <quchen> jaspervdj: Ah, I see.
02:00:34 <quchen> Just include my private mail, dluposchainsky at googles mail service (which doesn’t such from a UX perspecitive, good job Google)
02:00:35 * hackage alerta 0.1.0.1 - Bindings to the alerta REST API  https://hackage.haskell.org/package/alerta-0.1.0.1 (MarkHopkins)
02:03:14 <xfix_> So, I started learning Haskell, and I noticed something weird.
02:03:26 <xfix_> I declared two functions, `let square = (^2)` and `let square' x = x^2`.
02:03:46 <xfix_> The type of first one is `Integer -> Integer`, while the second one is `Num a => a -> a`. Why is that?
02:04:25 <jle`> @where dmr
02:04:26 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:04:51 <xfix_> Thanks :).
02:05:01 <jle`> no problem :)
02:05:18 <jle`> in short, it's a compiler heuristic/rule that benefits performance in most cases
02:05:51 <jle`> but it's indeed unintuitive when you first notice it
02:08:35 * hackage located-monad-logger 0.1.1.0 - Location-aware logging without Template Haskell  https://hackage.haskell.org/package/located-monad-logger-0.1.1.0 (pavelkogan)
02:16:30 <jared-w> jle`: what's the mnemonic for "dmr"?
02:16:57 <Saizan> dreaded monomorphism restriction
02:17:09 <jared-w> lol, dreaded, gotcha
02:18:11 <merijn> It should be the AMR, Adored Monomorphism Restriction
02:19:07 <quchen-mobile> Dreaded MR. 
02:19:21 <quchen-mobile> Devilish MR. 
02:19:29 <jared-w> Dashing MR
02:19:34 <quchen-mobile> Devious MR. 
02:19:45 <Xion_> It's almost as bad as DMV.
02:19:53 <jared-w> "Driving Muh Vehicle"
02:20:23 <nanoz> why the hell java 8 started with lamda expression (why the idea of FP) :'?
02:20:44 <jared-w> nanoz: I've got no idea what you're asking
02:21:00 <Xion_> Should it have started with monad transformers?
02:21:30 <jared-w> If you want to know why Java 8 has lambda functions at all then that's easy. Lambda functions and several other functional paradigms are extremely useful when operating with "streams" which Java 8 is very big on.
02:21:38 <zaghie> Finally understood functors - mindblown.
02:22:12 <merijn> zaghie: Time to move onto Applicative Functors ;)
02:22:13 <Xion_> Yep streams aka iterators aka LINQ aka Traversables/Foldables
02:22:28 <merijn> Xion_: LINQ is more akin to MonadComprehensions, I think?
02:22:36 <jared-w> Java 8 uses Streams and composable functional style functions in order to manipulate data. It's part of the overall progression that Java has had for a while. Going from for loops to for (item : container) to iterators to streams.
02:22:37 <zaghie> merijn: haha gonna do that tomorrow :D 
02:22:43 <Xion_> merijn: It has both the fluent/chained and comprehension/SQL syntax
02:23:20 <nanoz> i work on java so i didnt get why OO language need fp 
02:23:32 <nanoz> thanks jared-w 
02:25:03 <Xion_> Yesterday I read that comonads are OOP. So it's all artificial distinction anyway!
02:25:08 <jared-w> Don't think of it as fp. Java doesn't really have fp. It borrows some ideas from FP but, really, it's not FP at all
02:25:14 <quchen-mobile> A lambda is a oneliner, a strategy pattern is a boom chapter. That's why. 
02:25:29 <Xion_> Heh, basically.
02:25:29 <quchen-mobile> Book*
02:25:40 <merijn> Does attoparsec have a platform aware newline parser?
02:25:44 <jared-w> all of the functional stuff in Java deals with Traversable and Foldable concepts of containers
02:25:57 <merijn> i.e. \n vs \r vs \r\n ?
02:26:15 <jared-w> ಠ_ಠ I get emacs crashing whenever I type 'o' in normal mode... what a great way to ruin my productivity at 3am
02:26:28 <Xion_> It's a hint you should go to sleep
02:26:32 <merijn> oh, I'm blind
02:26:40 <merijn> I was look for eol, instead of endOfLine
02:27:34 <jared-w>  ¯\_(ツ)_/¯ it started working. Only needed to restart emacs like 4 times. No biggie
02:28:06 <jared-w> merijn: I do that kinda thing all the time. It's amazing how good the brain is at thinking of the wrong name for something :p
02:28:31 <merijn> Next question, for the persistent users: AFAICT runSqlPool runs stuff in a single transaction. Is there a convenient way to split things into individual transactions when using, e.g. conduit to stream stuff?
02:29:26 <jared-w> Hmm... To my uneducated mind, the postfix "pool" seems to suggest "cram all this stuff into noe transaction"
02:29:35 * hackage d-bus 0.1.7 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.7 (PhilippBalzarek)
02:29:37 <jared-w> Is there not a runSqlIndividual or runSql function that doesn't do that?
02:30:33 * jared-w is unreasonably excited at figuring out how to make LaTeX use normal quotes smartly
02:32:23 <merijn> All the examples/documentation of persistent show everything running in a single block, but that seems to end up in a single transaction which is not ideal
02:34:25 <felixphew> is there a more compact way of writing f 'S':'t':'a':'r':'t':xs = something?
02:34:41 <felixphew> or is pattern matching the start of strings not a done thing?
02:34:56 <bennofs> :t startsWith
02:34:57 <lambdabot> Eq a => [a] -> Splitter a
02:35:00 <bennofs> :o
02:35:08 <bennofs> :t isPrefixOf
02:35:09 <lambdabot> Eq a => [a] -> [a] -> Bool
02:35:17 <quchen-mobile> :t isPrefixOf
02:35:18 <felixphew> I mean for pattern matching though
02:35:19 <lambdabot> Eq a => [a] -> [a] -> Bool
02:35:31 <jared-w> Pattern matching should be used for a very simple and almost atomic concept. If you need something more complex than that, just use a function 
02:35:38 <bennofs> felixphew: f xs | "Start" `isPrefixOf` xs = ...
02:35:59 <felixphew> bennofs: thanks for reminding me that guards are a thing
02:35:59 <ski>   f (stripPrefix "Start" -> Just xs) = ..xs..
02:36:05 <bennofs> although that means you have to drop the chars at the beginning of xs manually if you need the remaining part...
02:36:12 <bennofs> :t stripPrefix
02:36:13 <jared-w> the above translates to "if Start is the prefix of the string, then..."
02:36:13 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
02:36:16 <bennofs> oh
02:36:32 <bennofs> f xs | Just suffix <- stripPrefix "Start" xs = ... even better
02:36:35 <jared-w> merijn: 
02:36:42 <jared-w> does runSqlConn do what you want?
02:37:02 <ski> bennofs : felixphew's `xs' was the suffix, not the whole list ..
02:37:31 <jared-w> It's the same as runSqlPool except the backend is just a "backend -> m a" instead of a "Pool backend -> m a"
02:37:32 * ski doesn't really agree with "Pattern matching should be used for a very simple and almost atomic concept."
02:37:36 <felixphew> yes, I was ideally looking for a way to do f (x:xs) but with x being a list rather than an item
02:37:57 <felixphew> obviously I can just write it the way I did, but for a long string that's pretty ugly
02:38:21 <ski> (otoh, disjointness, exhaustiveness and injectivity are important)
02:38:33 <bennofs> felixphew: well either use ViewPatterns like ski showed or if you don't want to rely on that extension use PatternGuards like f xs | Just suffix <- stripPrefix "Start" xs = ...
02:38:54 <ski> fwiw, in Mercury, you can write (the equivalent of) `f ("Start" ++ xs) = ..xs..'
02:39:25 <jared-w> ski: This is also possible in curry :p
02:39:28 <merijn> jared-w: Then you end up continuously opening a new connection to the DB, which is kinda wasteful and annoying
02:39:46 <ski> (in Erlang as well, but there it's a special case for `++', not a general feature)
02:39:56 <ski> jared-w : wouldn't surprise me :)
02:40:28 <felixphew> is there some reason why we couldn't have that (as syntactic sugar) in Haskell?
02:40:34 * hackage transient 0.5.6 - composing programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.5.6 (AlbertoCorona)
02:40:48 <merijn> jared-w: The problem is that, e.g. insert expects "ReaderT backend m (Key record) Source #"
02:41:04 <merijn> jared-w: Which doesn't seem to play nicely with a pool
02:41:09 <jared-w> felixphew: it's a hell of a lot more than syntactic sugar, which is the problem.
02:41:48 <jared-w> For example: (lst ++ [e]) = e -- equivalent to 'last element of list'
02:42:19 <felixphew> yes, I'm not saying it's straightforward
02:42:24 <jared-w> would require an entire logical programming backend to satisfy arbritrary logical constraints on the rhs of an equation, given arbritrary free variables on the lhs of the equation
02:42:45 <ski> felixphew : see <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms>. but i believe one may need to introduce modes (a la Mercury), for full generality
02:42:49 <jared-w> You'd end up embedding all of Prolog into the language. Which, coincidentially, languages such as Curry do just that; they're functional logic languages
02:43:02 <cocreature> if I understand felixphew he is only asking for the case where the first argument to ++ is statically known, right?
02:43:23 <felixphew> well that's the only case that I, personally need
02:43:35 <cocreature> that would technically be simple to implement but it’s unsatisfying to have such a special case
02:43:45 <felixphew> not that a more general availability of ++ in patterns wouldn't be great, but I can see it being a difficult task
02:44:05 <felixphew> because there would obviously be unsolvable uses of ++ that the compiler would need to find
02:44:09 <cocreature> I’m not sure I actually want a more general version of ++. that would fundamentally change what pattern matching in Haskell means
02:44:25 <felixphew> like f (xs ++ ys) is obviously not going to work
02:44:48 <jared-w> Right, and by the time you get to that point you're really embedding a full narrowing strategy, logical constraint anlysis, etc., into pattern matching and basically it isn't really pattern matching anymore :p
02:44:48 <ski> unless `xs' is already bound
02:45:07 <jared-w> xs could be bound to [1..] could it not?
02:45:33 <felixphew> yep, now I'm seeing how big the can of worms I've opened is
02:45:38 <ski> yes, but then `stripPrefix xs' also doesn't terminate, unless there's a mismatch
02:45:43 <felixphew> forget I asked :-P
02:46:07 <ski> cocreature : fundamentally change how ?
02:46:53 <cocreature> ski: there are multiple possibilities for how a pattern can match
02:47:17 <ski> (afaiu, the declarative meaning would still be the same, but the operational meaning would be extended to more cases)
02:47:18 <cocreature> e.g. xs ++ ys can match [1,2] with [] ++ [1,2], [1] ++ [2] and [1,2] ++ []
02:48:03 <ski> yes, but obviously the compiler could then simply be made to refuse to compile such ambiguous (non-injective) matches
02:48:42 <felixphew> it would have to
02:49:02 <ski> (which was why i mentioned disjointness, exhaustiveness, and injectivity before .. and also modes (and then determinisms would be needed. maybe instantiation states as well, not sure))
02:49:50 <ski> felixphew : .. unless one could be sure that it wouldn't matter which choice was made, since all of them would lead to the same end result (fsvo end)
02:50:52 <ski> (in Mercury, there's a `promise_equivalent_solutions' construct for this, that introduces a proof obligation on the programmer. in the case where you only want to know whether there's a solution or not, you don't need this, though)
02:51:11 <jared-w> ski: if the compiler was made to refuse such cases, your matching would be reduced to trivial cases and would essentially be useless
02:51:35 * hackage alerta 0.1.0.2 - Bindings to the alerta REST API  https://hackage.haskell.org/package/alerta-0.1.0.2 (MarkHopkins)
02:51:47 <felixphew> it would still provide several useful cases
02:51:53 <ski> i don't think reducing to only semi-deterministic cases would be that useless
02:52:19 <felixphew> being able to do [x,y,z]:xs instead of x:y:z:xs would be handy on its own
02:52:29 <jared-w> Sure, but then you're memorizing useful cases rather than gaining an intuition for how you can construct logical constraints to match on
02:52:47 <ski> memorizing ?
02:54:33 <jared-w> I mean, why should [x,y,z]:xs work and x++xs not work? Why should one obvoiusly semi-deterministic case work but another seemingly semi-determinstic case not work? (xs++[e]++ys appears semi deterministic at first glance)
02:55:02 <ski> well, in my mind, `x++xs' should work, if `x' is already bound
02:55:46 <jared-w> But how do you know it's bound? And how would the compiler know?
02:55:52 <ski> perhaps also in case (only) `xs' is bound, but that would be harder to achieve without some laying on hands, i think
02:56:05 <cocreature> ski: but now you can’t allow shadowing anymore
02:56:20 <merijn> jared-w: I think I have a solution "runSql = ReaderT . runSqlPool" which basically gives you "ReaderT SqlBackend m a -> ReaderT (Pool SqlBackend) m a"
02:56:28 <ski> cocreature : yes, i believe that's the main stumbling stone here
02:56:32 <jared-w> x++xs could be [] ++ xs, x0 ++ rest, [x0,x1] ++ rest, ... 
02:56:35 * hackage transient-universe 0.4.5 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.4.5 (AlbertoCorona)
02:56:38 <ski> (i was waiting for someone to mention that :)
02:56:40 <merijn> jared-w: Which combined with "withSqlPool" and runReaderT works out
02:56:58 <jared-w> merijn: ooh neat. I never would've thought of that
02:57:01 <cocreature> ski: and tbh that’s never going to happen so we’re back to only allowing constants
02:57:37 <ski> in Oz, there's an annotation to (iirc) allow matching on an already-in-scope variable. one could adopt such a convention
02:57:37 <merijn> jared-w: It's a bit unobvious...everyone else seems to define a local "runSql" function with 'let' and pass that around, but that's a PITA
02:58:14 <jared-w> Seems like if it's that common to do some ugly let passing, there should be some sort of function in the library that does this for you...
02:58:29 <ski> jared-w : in any case, the compiler would keep track of the instantiation state of variables
02:58:55 <jared-w> And the human would somehow learn to? :p
02:59:21 <jared-w> To me, it's not enough that it should be possible for the compiler, it should be easy and intuitive for the human (if possible)
02:59:25 <ski> programmers in logic programming languages do it all the time
02:59:51 <cocreature> ski: guess why logic programming languages are not popular :P
02:59:57 <jared-w> Well sure, but logic programming languages don't have coddled and special-cased constructs, they can use the full power of logic programming
03:00:24 <mantasg> Hi guys, I'm trying to manually write Aeson FromJSON implementation but I'm getting "`parseJSON' is not a (visible) method of class `FromJSON'". I've literaly copy/pasted the example from documentation. Can anybody help me with that?
03:01:22 <ski> (but yes, that's a valid concern. but one that i happen to think isn't that much of a problem, with some practice. and explicit mode (or injectivity,&c. if you prefer) declarations, at least for top-level declarations)
03:01:29 <jared-w> xs++ys is just fine in logic languages because of narrowing strategies. As a programmer, I don't have to figure out what's possible in "this language" I just have to figure out what's possible "in logic"
03:01:31 <lyxia> mantasg: can you paste your code
03:02:27 <lyxia> mantasg: have you imported Data.Aeson
03:02:44 <ski> jared-w : yes. often it's enough to reason about it declaratively/logically. the mode and determinism checker will yell if there's a problem, that needs to be reasoned at the operational/procedural level
03:03:08 <jared-w> I find that much easier because it's consistent. Much like I can expect any mathematical concept (such as squareRoot) to behave the same across languages, I can expect logical constructions to behave the same across languages. But, if there's some arbritrary subset of logic allowed in the pattern matching... it just breaks the whole reason for expanding pattern matching into the logical realm, for me
03:04:40 <ski> cocreature : well, i'd like to think that one reason is that they are even a bit farther away from your typical imperative language .. so that it's a somewhat bigger upfront cost for someone who's only familiar with imperative programming to learn about it ..
03:05:18 <jared-w> which is why I would find it horribly limiting if a language allowed [x,y,z]++ys but not xs++ys. They're the same thing, logically, so somehow some arbritrary subset of what is possible in logic is being chosen as the cannonical truth for that particular part of the language and at that point I'm not using logic programming, I'm memorizing that language's idiosyncrasy
03:05:21 <mantasg> lyxia, I've copied the example from documentation: https://pastebin.com/Vtfmj1cU
03:06:34 <jared-w> Does .: need lens or does Data.Aeson have their own .: operator?
03:06:37 <ski> jared-w : i hear you. otoh, "some arbritrary subset of what is possible in logic is being chosen" already in logic programming languages (Horn clauses, Hereditarily Harrop Formulae, &c.)
03:06:58 <lyxia> mantasg: it compiles just fine here
03:07:23 <jared-w> ski: I'd counter with "at least I can wikipedia that particular branch of logic and see the formally written rules and derivations and what not for it" :p
03:07:41 <jared-w> So I wouldn't really call those "arbritrary subsets" at that point...
03:07:42 <ski> why can't i abbreviate the facts `foo(a). foo(b). foo(c).' as `maplist(foo,[a,b,c]).', e.g. ?
03:07:57 <mantasg> lyxia, yes thanks. I've found the problem 
03:08:24 <jared-w> mantasg: what was it?
03:08:43 <jared-w> ski: I'm not sure. I'm probably missing what you're getting at; can you elaborate a tad?
03:09:02 <mantasg> a bit embarassing: In my full code I had: import Data.Aeson (ToJSON, FromJSON)
03:09:07 <mantasg> without parseJSON
03:09:35 <jared-w> hah, don't worry I've definitely done that before
03:10:12 <ski> why can't i say `L = [(_,4),(_,9),(_,25)],all [X,Y] ( member((X,Y),L) => square(X,Y) )' and expect eight solutions, starting with `L = [(2,4),(3,9),(5,25)]' ? (i implemented a prototype that can do this)
03:10:55 <mantasg> Yeah, the compiler message makes sense but can mislead a bit in such situation :)
03:11:48 <jared-w> In Haskell?
03:11:51 <ski> jared-w : you can't "abbreviate" clauses (without going into macro (`term_expansion',`goal_expansion') territory). but logically you should be able to .. at least if you could declare certain predicates to be *equivalences* (closed-world assumption) (preferably selectively)
03:11:51 <cocreature> ski: use an SMT solver :P
03:12:06 <ski> cocreature : in a programming language :)
03:12:18 <jared-w> ahh, okay, now I get what you're saying
03:14:23 <ski> (my prototype cutely allowed backtracking itself to be backtracked .. &c. for as many levels as necessary. implemented with a potentially unboundedly deep continuation monad transformer stack, with `IO' or `ST' at the bottom, for implementing logic variables)
03:14:46 <jared-w> impressive
03:14:51 <jared-w> I'm guessing it wasn't super fast? :p
03:16:04 <jared-w> I think the only real reason abbreviation of clauses isn't possible in most languages now is speed concerns, potential difficulties in deciding expansions, and that most languages don't have any explicit keywords for abbreviations?
03:16:13 <ski> that was not the intent of the prototype, no. it was a project for a course
03:18:01 <ski> one could distinguish between compile-time expansions (basically macro, or staged programming, or partial deduction, territory), and run-time ones, which i suppose was what i had in mind
03:19:28 <jared-w> that's really interesting
03:19:46 <ski> for the latter, one would need either to add a directive for declaring a predicate to be closed, or to add a symbol for equivalences, e.g. `<=>'
03:19:50 <jared-w> Was it a full language that you implemented? 
03:20:02 <cocreature> ski: one of the things that I find really annoying about logic programming or rather the way it’s presented is that a lot of the examples used to explain why it’s great can just as conveniently be solved using an SMT solver from whatever language you’re already using
03:20:38 <smallCat> is there a way to implement session-based authentication using the Servant library?
03:21:04 <cocreature> smallCat: you probably want to take a look at https://github.com/plow-technologies/servant-auth#readme
03:21:32 <cocreature> smallCat: specifically the authentication via cookies
03:21:41 <ski> jared-w : embedding into Haskell, so no parser, no static checking of its own, apart from what it borrowed. a proof-of-concept
03:22:41 <jared-w> nice. So it was just a thin layer on top of haskell, then?
03:22:49 <jared-w> Or more like an EDSL?
03:22:50 <ski> cocreature : well, a theorem prover isn't as predictable in the resources needed
03:23:50 <ski> the latter. Seres and Spivey has a paper about implementing logic variables in Haskell. Koen Claessen has an update on that, with typed logic variables (also based on `ST', so more efficient). my prototype was based on the latter
03:24:04 <bollu> smallCat: ping
03:24:05 <cocreature> ski: oh sure, I’m not trying to say that there aren’t advantages to using a logic programming language. I just think most of the standard examples are particularly bad at demonstrating them. but that seems to be a common theme in introductory examples. the standard Haskell “qucksort” is even more silly
03:24:31 <bollu> quchen: where exactly in Bellevue is the meeting?
03:24:46 <quchen> bollu: Just by the lake
03:24:51 <bollu> ah, OK :) 
03:24:51 <quchen> So we can put our feet in :-)
03:25:09 <bollu> quchen: I'm new, is the lake visible from Bellevue? xD
03:25:35 <quchen> Bellevue is that part of the river’s shore
03:25:39 <quchen> (I think)
03:25:42 <bollu> hm, I see
03:25:45 <bollu> anyway, I'll be there
03:25:56 <ski> cocreature : someone in ##prolog has used it to keep track of different services that should be brought up upon boot, with interdependencies and fallbacks. i suspect an SMT solver wouldn't help that much with that
03:25:56 <quchen> If you look at the map you’ll see a 20km long lake, it’s hard to miss :-þ
03:26:00 <bollu> xD
03:26:29 <bollu> ski: I've heard that a logic language needs to eventually learn the solver details to express anything non-trivial?
03:26:33 <bollu> how true is that?
03:27:25 <jared-w> quchen: you're in Seattle area? Nice. I love that lake
03:27:42 <quchen> Nope, different continent
03:27:48 <jared-w> darn
03:27:53 <ski> well, i don't know that much about how state-of-the-art theorem provers work internally
03:27:55 <jared-w> Well I'm sure your lake is pretty too
03:28:42 <ski> i know there's been some work along the lines of bringing concepts and techniques from that world over to logic programming (PTTP by Stickel, &c.)
03:29:00 <cocreature> smt solvers are great. you rename your variables and suddenly they’re unable to solve a problem that they could previously solve in less than a second
03:29:20 <jared-w> Logic languages don't have that problem :p
03:29:26 <bollu> cocreature: wait what?
03:29:38 <ski> bollu : but even plain Prolog (with all warts) goes a long way, for many programming tasks, i'd say
03:29:46 <bollu> smallCat: did you hit up on a solution? 
03:29:48 <bollu> ski: I see
03:29:57 <bollu> ski: any place you'd recommend picking Prolog up from?
03:30:10 <bollu> ski: like, what's something interesting you can build with prolog?
03:30:37 <jared-w> You can build your mind's logical faculties that's what ಠ_ಠ
03:30:40 <cocreature> bollu: I saw that with Z3 iirc. apparently they sort variables by name or something like that and some heuristic was no longer triggered
03:31:01 <ski> hm, perhaps "The Art of Prolog" by Sterling and Shapiro. or perhaps "Prolog: Programming for Artificial Intelligence" by Ivan Bratko, if that's your cup of tea
03:31:05 <smallCat> bollu : yeah!
03:31:40 <bollu> cocreature: WTF
03:31:40 <ski> "The Craft of Prolog" by Richard A. O'Keefe is a good second book
03:31:55 <bollu> Prolog: Programming for Artificial Intelligence seems sweet
03:32:08 <bollu> I hate this channel sometimes, my "to read" list is never ending :]
03:32:11 <cocreature> bollu: well sorting by name is just as good as sorting by anything else. you’ll always come up with some way to break it :)
03:32:49 <jared-w> I read somewhere that Imperitive programming models actions. Functional programming models reasoning. Logical programming models knowledge. I think that's fairly accurate
03:33:04 * hackage alerta 0.1.0.3 - Bindings to the alerta REST API  https://hackage.haskell.org/package/alerta-0.1.0.3 (MarkHopkins)
03:34:02 <bollu> ski: have you seen the minikarnen stuff?
03:34:07 <bollu> "write you a logic engine"
03:34:08 <bollu> seems fetching
03:34:22 <bollu> kanren*
03:34:25 <ski> bollu : note that Prolog is old, and has lots of flaws and warts. but most of the introductory material is in terms of Prolog. so even if you'd like to learn Mercury (which also has functions, static typing, parametric polymorphism, existentials, type classes, mode&determinism&inst checking, a module system, a compiler generating efficient code, &c.), i'd still suggest starting with Prolog
03:34:25 <bollu> http://minikanren.org/
03:34:31 <hjulle___> Where does ghc search for installed packages? Is there any way to add ~/home/hjulle/.nix-profile/lib/ghc-8.0.2/package.conf.d/ to that path?
03:34:34 <bollu> ski: I see
03:34:35 <bollu> ski: ty
03:34:50 <ski> bollu : i've seen it, but haven't looked at it in detail
03:34:54 <jared-w> hjulle___: are you using stack or cabal?
03:35:00 <ski> there's also Oz, used by the (interesting) book CTM
03:35:04 <ski> @where CTM
03:35:04 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
03:35:06 <bollu> ski: my current list of possible topics for independent study at college are: 1. okasaki, 2. logic based programming, 3. type theory, 
03:35:14 <bollu> 4. software foundations
03:35:24 <jared-w> Oooh, pretty similar to mine.
03:35:24 <hjulle___> jared-w: nix
03:35:48 <jared-w> bollu: check out logic functional programming as well (ala Mercury or especially Curry)
03:35:50 <hjulle___> jared-w: But it shouldn't matter? The config options are for ghc and ghci?
03:35:58 <bollu> jared-w: I need to know logic first
03:36:19 <jared-w> It does matter if you're not using Nix
03:36:29 <ski> bollu : "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> might be interesting re Prolog vs. Mercury
03:36:36 <jared-w> But what exactly are you trying to configure anyway?
03:36:44 <butterthebuddha> Hey guys, I'm having trouble with problem 9 here -> https://wiki.haskell.org/99_questions/1_to_10
03:37:12 <butterthebuddha> What I've got so far https://pastebin.com/etW8Wx3N
03:37:26 <butterthebuddha> my a == b case is wrong
03:37:37 <ski> (there's also an SML variant, Alice ML, compiling to the same engine as Oz. it has quite some interesting extra features, like passing modules over the wire, remote-code execution, futures, &c.)
03:38:28 <ski> bollu : i should also mention that if you look into logic programming, you should at least dip your toes a bit in constraint logic programming as well, to get a feel for what it is about, and what it's good for
03:38:33 <ski> (imho)
03:38:47 <hjulle___> jared-w: How would you do it for stack?
03:38:58 <ski> bollu : .. sorry if i'm adding to that list of your :)
03:39:04 <ski> s
03:39:40 <bollu> ski: indeed :P
03:39:52 <ski> (there's also a #mercury channel here, with one of the compiler developers in there)
03:40:52 <hjulle___> jared-w: I want to include the packagages that are installed to my user profile. They are not registered in the global registry, so I'd like to add that path to the search path. How does stack and cabal do it?
03:41:50 <hjulle___> I.e. how does stack&cabal tell ghc that there is an additional path to search for installed packages in?
03:42:18 <ski> (perhaps i should clarify that Oz is, at the core, a logic programming language (without disjunction/backtracking), but with several layers atop for adding support for different paradigms (explained in the book CTM). one interesting thing there is what they call declarative concurrency, threads communicating via dataflow (really logic) variables, but without race conditions (unless you use explicit extra constructs for that))
03:43:27 <quchen> hjulle___: You can add package paths to GHC via some flag
03:43:37 <ski> (bollu : by 4, do you mean the book ?)
03:43:48 <quchen> hjulle___: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#packages
03:44:23 <bollu> ski: when did I say 4?
03:44:38 <bollu> ski: yes, book 4
03:44:44 <bollu> ski: on my list of books to read
03:45:21 <ski> @where SF
03:45:22 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
03:45:22 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
03:45:44 <bollu> yes, I've read some ofit
03:45:50 <bollu> till chapter.. 5 IIRC
03:45:54 <bollu> but that was mostly Coq, no real logic
03:46:02 <bollu> was still super cool
03:46:05 <bollu> especially list theorems
03:47:51 * ski nods
03:55:41 <quchen> ReinH: I’ll hack something together at ZuriHac I think. The example programs should be fairly good in terms of showing how the generated AST looks like I think.
04:11:34 <merijn> ugh
04:11:57 <merijn> I like Template Haskell, but sometimes people make an incomprehensible mess of things...
04:14:06 <merijn> Anyone know if Persistent has some simple way to reuse the primary key of a datatype as a uniqueness constraint?
04:29:16 <sphinxo> Is there any symbols for concatinating text?
04:29:51 <merijn> <>
04:29:54 <merijn> Text is a Monoid
04:30:37 <sphinxo> ahh of course :|
04:35:55 <cocreature> Data.text also has "append" if you prefer a name over a symbol
04:36:49 <sphinxo> yeah I wanted to avoid that and also not use mconcat with a list
04:37:00 <sphinxo> which is what I was doing ( using the monoid instance )
04:37:23 <quchen> ?tell ReinH A bit hard to read in HTML form, but http://lpaste.net/356128 is the zipWith Fibonacci program :-) Source: https://github.com/quchen/stgi/blob/d9174ab28abf67514e72d4d6073c4b792134e612/src/Stg/ExamplePrograms.hs#L229
04:37:23 <lambdabot> Consider it noted.
04:37:46 <quchen> Took 15 minutes to write. Hooray new prettyprinter :-)
04:37:55 <quchen> ?tell ReinH Took 15 minutes to write. Hooray new prettyprinter :-)
04:37:55 <lambdabot> Consider it noted.
04:42:18 <ski> quchen : missing `zero : one :' in the comment ?
04:42:41 <quchen> ski: That’s right
04:42:54 <quchen> Pull request? ;-)
04:47:45 <SepakoRayl> not sure if this was sent (having a few network issues) but is there some way to constrain type families?
04:48:08 <merijn> SepakoRayl: Can you give more info about what you wanna do?
04:48:10 <sphinxo> given the json [{ "t": 1}, {"t": 2}] how can I extract out to [1,2] ( using aeson lens )
04:49:31 <SepakoRayl> say I have a type family XExample z and a data ExampleX z = ExampleX (XExample z) Int
04:49:47 <sphinxo> some traversal + key?
04:49:56 <SepakoRayl> I would like to derive Show for ExampleX but then I must somehow constrain XExample z to be showable
04:55:28 <phadej> sphinxo: yes, values . key "t"
04:55:42 <ski> SepakoRayl : try standalone deriving ?
04:56:24 <ski>   deriving instance Show (XExample z) => Show (ExampleX z)
04:57:23 <merijn> @hoogle Eq a => a -> [a] -> [[a]]
04:57:23 <lambdabot> Data.List (\\) :: (Eq a) => [a] -> [a] -> [a]
04:57:24 <lambdabot> Data.List union :: (Eq a) => [a] -> [a] -> [a]
04:57:24 <lambdabot> Data.List intersect :: (Eq a) => [a] -> [a] -> [a]
04:57:34 <merijn> hmmm, there's no multiway split in base?
04:58:14 <phadej> merijn: probably everything is left for `split` package
04:59:29 <SepakoRayl> wasn't aware of StandaloneDeriving
04:59:40 <SepakoRayl> does that also require FlexibleContexts?
04:59:58 <merijn> SepakoRayl: Not unless your instance requires it
05:00:18 <ski> hmm .. is there a way to require a type class instance of a data or type family to be present, under given constraints on the indices, where when making an instance of the family, you're also required to give the implementation of the type class instance, for that family instance ?
05:00:56 <ski> (and where the type class have been declared separately, so that you can't simply use an associated type inside it)
05:01:27 <phadej> I was just asking why not associated type
05:02:01 <phadej> except if you make another class, to define the type family
05:02:14 <merijn> phadej: Associated types are type families, so what'd the point be?
05:03:50 <phadej> merijn: good question. The GHC is a bit funny as it let's talk about "AssociatedType a" without requireing "Enclosing a =>"
05:03:52 <ski> (in SepakoRayl's example, possibly one'd like `instance family Show z => Show (XExample z)' to be required of instances of the family .. hmm)
05:04:16 <merijn> phadej: That's because associated types are just syntactic sugar for type families
05:04:30 <merijn> phadej: Hell, they'd be useless if you couldn't use them outside the class/instance
05:04:50 <phadej> ski: you cannot do that, you can always write `XExample z` for any `z`
05:05:08 <phadej> ski: and it might, or might not reduce
05:05:50 * ski doesn't follow
05:07:07 <mathk> @pl \num -> go (div num 10) (mod num 10 : acc)
05:07:07 <lambdabot> ap (go . flip div 10) ((: acc) . flip mod 10)
05:07:31 <phadej> merijn: I think you mix closed and open type families; I personally agree with richard eisenberg at least on that there is some design flaw
05:07:52 <phadej> e.g. that we can have open type families without a class
05:11:45 <phadej> ski: I'd write another class for that, `class Show (XExample z) => XExampleC z where { type Example z :: * } 
05:12:19 <phadej> ski: I guess you want Show instance on the *result* of type family, not its argument; though that's possible too
05:20:04 <sphinxo> why am I sometimes getting Couldn't match type ‘[Char]’ with ‘Text’
05:20:08 <sphinxo> eg: "repository:" <> name <> ":pull" is fine
05:20:26 <merijn> sphinxo: Because those two things are Strings, not Text
05:20:32 <sphinxo> oh wait
05:20:42 <merijn> Unless you enable OverloadedStrings :p
05:20:48 <sphinxo> which I have
05:21:00 <merijn> sphinxo: Where does name come from?
05:21:10 <sphinxo> name is text
05:22:00 <sphinxo> maybe string <> text is fine but text <> string is not
05:22:14 <sphinxo> hmm
05:22:15 <merijn> sphinxo: Is your String a literal?
05:22:22 * merijn suspects not
05:22:23 <sphinxo> yeah
05:22:29 <sphinxo> oh in this case
05:22:31 <sphinxo> not
05:22:40 <merijn> sphinxo: OverloadedString only works on literals
05:22:47 <merijn> It doesn't magically convert strings in general
05:23:00 <merijn> Use
05:23:04 <merijn> :t Data.Text.pack
05:23:05 <lambdabot> String -> Data.Text.Internal.Text
05:24:49 <sphinxo> Thanks!
05:29:04 * hackage zerobin 1.5.2 - Post to 0bin services  https://hackage.haskell.org/package/zerobin-1.5.2 (ip1981)
05:38:31 <juri_> i am creating two lists, based on running filter against a list, and placing items that match a function in one list, and items that do not match in a second (by passing filter (not . function)). is there a better way to do this, without traversing the list twice?
05:42:08 <ClaudiusMaximus> > partition even [1..10]
05:42:10 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
05:43:12 <juri_> yay. thanks. :)
05:55:04 <spoonm> I don't get this: if I run this program with `runhaskell test.hs', it behaves as expected: prints the line, waits for input, reads, etc.
05:55:20 <spoonm> but if I compile it with ghc and then run it, it waits for input, prints the first line and then the rest
05:55:23 <spoonm> http://ix.io/wIL
05:57:51 <merijn> spoonm: stdout is linebuffered
05:58:01 <spoonm> oh wow
05:58:09 <merijn> spoonm: It only prints if you either write a newline or explicitly flush
05:58:18 <merijn> @hooge hFlush
05:58:18 <lambdabot> System.IO hFlush :: Handle -> IO ()
05:58:18 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
05:58:18 <lambdabot> Sound.File.Sndfile hFlush :: Handle -> IO ()
05:58:33 <spoonm> does runhaskell do that for me by default?
05:58:54 <merijn> spoonm: It might, or maybe it's due to forwarding input in some funky way
05:59:03 <merijn> The latter seems more likely
05:59:30 <spoonm> thanks, didn't know about that
06:00:56 <shanko> Guys, how can i filter by Id using selectList from yesod? i receive the id i wan't in the route
06:02:03 <fendor> is there a library for websocket testing? 
06:02:57 <fendor> for example mocking?
06:21:35 * merijn just uses sarcasm for mocking
06:22:00 <Akii> haha
06:28:43 <fendor> merijn, i dont see how sarcasm should help me :P 
06:30:29 * Iceland_jack wants a sarcastic type checker
06:31:09 <ventonegro> "You obviously though that would type check, huh?"
06:31:15 <ventonegro> thought*
06:31:54 <Iceland_jack> "No instance for 'Num Ordering' but hey I'm sure it made soo much sense in your head."
06:32:07 <Akii> xD
06:32:19 <Iceland_jack> "Maybe I made a unification mistake let me check.. ..nope"
06:32:46 <Iceland_jack> You could have sarcastic mode.. a disappointed SPJ mode
06:33:22 <juri_> Expected type: [[a1]] Actual type [[a]] . Sucks to be you!
06:33:51 <Akii> language extension, this should be a thing
06:33:59 <Akii> opt in sarcastic compile errors
06:36:32 <byorgey> there was the GHC bug where it deleted your source file if it didn't type check.  I suppose that's way beyond sarcasm though.
06:36:57 <ventonegro> harsh
06:37:36 <Iceland_jack> Only on Windows I believe so you deserve it
06:37:47 * Iceland_jack using Windows ..
06:37:50 <Akii> byorgey: that's just playing Haskell on hardcore difficulty
06:38:18 <fendor> Akii, more like nightmare
06:38:51 <Akii> pretty sure some people wouldn't even notice
06:39:14 <amx> wtf of the day: one module can "import Servant" just fine, the other one throws a Failed to load interface for ‘Servant’ tantrum. 
06:39:23 <fendor> however, is there also a way to test websocket code automatically?
06:40:02 <Akii> amx: normal stack setup? If so, app/ src/ and test/ have different dependencies
06:40:19 <Iceland_jack> Akii: I would notice.. every 2 seconds
06:40:23 <merijn> Is there a predefined combinator for "foldl (<|>) empty" somewhere?
06:40:29 <amx> cabal 1.24.2.0, it's all in src/, tried recreating sandbox and cabal clean
06:40:33 <Iceland_jack> :t foldl (<|>) empty
06:40:35 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
06:40:36 <Iceland_jack> :t asum
06:40:37 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
06:41:07 <merijn> Ah, asum
06:41:17 <Iceland_jack> :t asumOf
06:41:19 <lambdabot> Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a
06:41:26 <merijn> :t asum
06:41:27 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
06:41:34 <Iceland_jack> :t asumOf both
06:41:36 <lambdabot> (Data.Bitraversable.Bitraversable r, Alternative f) => r (f a) (f a) -> f a
06:41:36 <merijn> Crazy people and their lens for everything...
06:42:09 <Iceland_jack> crazy like a fox
06:57:34 * hackage zeromq4-conduit 0.1.0.0 - Conduit wrapper around zeromq4-haskell  https://hackage.haskell.org/package/zeromq4-conduit-0.1.0.0 (AndyGeorges)
06:59:59 <cocreature> merijn: btw since you asked yesterday about packages abstracting over pipes and conduit. "streaming" can easily be converted from and to pipes (https://hackage.haskell.org/package/streaming-utils-0.1.4.7/docs/Streaming-Pipes.html) and conduit (https://hackage.haskell.org/package/streaming-conduit-0.1.1.0/docs/Streaming-Conduit.html) the latter is new which is why I didn’t mention it yesterday :)
07:01:16 <fendor> ok, if no one wants to answer, can someone give me a hint to test impure code?
07:01:35 <Iceland_jack> fendor: Test.QuickCheck.Monadic is a start
07:01:44 <Iceland_jack> https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Monadic.html
07:01:46 <fendor> Iceland_jack, thanks!
07:01:49 <Iceland_jack> tell me if the docs needs improving
07:01:55 <cocreature> or just regular hspec or whatever test library you like
07:02:10 <fendor> any of this is also applicable on websockets?
07:02:45 <merijn> cocreature: I'm more wondering how I could easily do that myself
07:03:08 <cocreature> merijn: just write your library for "streaming" and let others use the conversions
07:04:04 <merijn> cocreature: I'd prefer not to have a dependency on any streaming library at all
07:04:15 <cocreature> fair enough
07:09:42 <sphinxo> How should I check for the existance of a certain char in Text?
07:09:51 <sphinxo> or rather how should I 
07:10:02 * sphinxo speaks nonsense
07:10:11 <sphinxo> filter?
07:10:21 <sphinxo> elem
07:10:23 <merijn> any
07:10:43 <merijn> :t \c -> T.any (==c)
07:10:44 <lambdabot> error:
07:10:44 <lambdabot>     Not in scope: ‘T.any’
07:10:44 <lambdabot>     Perhaps you meant ‘F.any’ (imported from Data.Foldable)
07:10:50 <sphinxo> infixOf?
07:10:52 <merijn> :t \c -> Data.Text.any (==c)
07:10:53 <lambdabot> Char -> Data.Text.Internal.Text -> Bool
07:11:23 <sphinxo> Thanks!
07:19:59 <fendor> :t Data.Text.any
07:20:01 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> Bool
07:20:34 * hackage HsOpenSSL 0.11.4.9 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.4.9 (VladimirShabanov)
07:22:34 <sphinxo> hmm, so why does "[{\"digest\": \"string\"}]" ^.. values . key "digest" . _String
07:22:51 <sphinxo> return [Text] yet
07:23:47 <sphinxo>  key "layers" . values . key "digest" . _String returns Text
07:24:30 <joeyh> trying to remember the name of a library that detects race conditions by reordering concurrent actions, or something like that
07:24:37 <sphinxo> hmmm
07:24:50 <glguy> because you used ^..
07:25:03 <shapr> joeyh: quickcheck-state-machine? 
07:25:14 <sphinxo> :| still learning lenses
07:25:20 <sphinxo> that makes a lot of sense
07:25:44 <joeyh> something like that.. I seem to remember it using a custom monad, but memory is fuzzy
07:26:30 <cocreature> dejafu also does something like that but I’ve never used it
07:26:36 <shapr> I think quickcheck-state-machine is recent
07:27:02 <joeyh> it was dejafu! thanks
07:27:53 <shapr> wow, that's a great name
07:40:04 * hackage spake2 0.2.0 - Implementation of the SPAKE2 Password-Authenticated Key Exchange algorithm  https://hackage.haskell.org/package/spake2-0.2.0 (jml)
07:43:58 <Reisen> Is it possible to define an instance of aeson's "FromJSON", where the encoded value doesn't contain the constructor?
07:44:24 <Reisen> I.E, given '{"value": True}', I'm wondering if I could define an instance that is capable of resolving Either (Either Bool Int) Char
07:44:41 <Reisen> I'm guessing I'd have to guarantee that any type appears only once in the either's
07:46:11 <lyxia> sure you can
07:46:14 <byorgey> Reisen: you could certainly make an instance of FromJSON (Either (Either Bool Int) Char) which could handle that.  I suppose the question is whether you want to code each such instance by hand or if you had something more general in mind.
07:46:41 <Reisen> I'm thinking about something more general, where I could build a `instance (FromJSON a, FromJSON b) => FromJSON (Either a b) where`
07:46:49 <Reisen> Such that I don't have to hardcode the Either, maybe it's many levels deep
07:47:06 <Reisen> Looking at he aeson def it works purely by checking for "Left"/"Right" strings
07:47:27 <byorgey> Sure, for that I think you would need more constraints, like  Typeable a, Typeable b for starters
07:47:45 <cocreature> I don’t think you need those. just try parsing an a first and if that fails parse a b
07:48:00 <cocreature> <|> is probably going to be helpful
07:48:04 <byorgey> oh, good point.
07:48:38 <cocreature> :t \v -> Left <$> parseJSON <|> Right <$> parseJSON
07:48:39 <lambdabot> error: Variable not in scope: parseJSON :: f a
07:48:39 <lambdabot> error: Variable not in scope: parseJSON :: f b
07:48:55 <cocreature> :t \v -> Left <$> Data.Aeson.parseJSON v <|> Right <$> Data.Aeson.parseJSON v
07:48:56 <lambdabot> (aeson-1.1.1.0:Data.Aeson.Types.FromJSON.FromJSON b, aeson-1.1.1.0:Data.Aeson.Types.FromJSON.FromJSON a) => aeson-1.1.1.0:Data.Aeson.Types.Internal.Value -> aeson-1.1.1.0:Data.Aeson.Types.Internal.
07:48:57 <lambdabot> Parser (Either a b)
07:49:14 <Reisen> Hmm
07:54:07 <ezyang> Hmm, Stack doesn't seem to be able to build and install threadscope on OS X :( 
07:54:38 <merijn> ezyang: I was enver able to build threadscope in OSX, which makes me sad...
07:55:05 <merijn> Does cabal automatically add -fprof-auto when you configure with --enable-profiling or do I need to do that manually?
07:55:40 <cocreature> merijn: I think fprof-auto is the default but there is also a profiling-detail flag to control cost centres
07:56:26 <cocreature> hm exported-functions is the default
07:56:36 <cocreature> that’s not equivalent to fprof-auto iirc
07:57:26 <cocreature> --profiling-detail=all-functions is fprof-auto
07:58:42 <Reisen> That turned out to be _way_ easier to do than I expected
07:58:46 <Reisen> Thanks cocreature
07:59:56 <MitchellSalad> is 'freer' the flagship "freer monads, more extensible effects" library?
08:02:18 <rpasta42> hey guys. What's the suggested process for setting up Haskell on Ubuntu? Install from apt? or Haskell website? Should I install haskell platform first, and then stack?
08:02:32 <rpasta42> or install stack without cabal?
08:02:52 <MitchellSalad> the platform comes with stack these days
08:03:18 <SepakoRayl> is there any way to defined mutual recursive datatypes in ghci ?
08:03:26 <MitchellSalad> i have stack installed w/o the platform, and thus no global 'ghc' (slightly annoying sometimes)
08:04:00 <Cale> SepakoRayl: Put the declaration all on one line, but if you're doing anything like that, seriously, put it in a file. :)
08:04:18 <SepakoRayl> ah that was obvious
08:04:27 <MitchellSalad> SepakoRayl: multi-line syntax :{ }:
08:04:49 <MitchellSalad> :{ :}*
08:10:36 <sphinxo> Couldn't match expected type ‘ByteString’ with actual type ‘Data.ByteString.Lazy.Internal.ByteString’ ?
08:11:40 <geekosaur> you have a lazy ByteString, it wants a strict one
08:12:37 <Cale> I still think it was a mistake to name them both ByteString
08:13:28 <geekosaur> also not helping is people always want types to be reported "simply" like the first one, which obscures the problem in a case like this
08:24:42 <fendor> no one ever tried to test websockets?
08:26:27 <Cale> fendor: Hi
08:27:04 <Cale> You have a question about websockets in Haskell?
08:28:21 <fendor> yes, i want to be able to write unit tests for an application that uses websockets
08:28:32 <fendor> and hi :) 
08:28:32 <Cale> ah
08:29:58 <Cale> You can use the 'websockets' library on Hackage to write clients as well as servers.
08:30:31 <fendor> but that wouldnt be unit tests
08:30:47 <fendor> someone claimed, that i might be able to mock webscoket connections via quickcheck
08:31:13 <Cale> Well, maybe everything except the actual websocket part
08:31:35 <fendor> so, no mocking possible of a connection?
08:31:35 <Cale> The encoding and decoding of the stuff you're sending over the websocket, you could do that with quickCheck
08:31:50 <Cale> I don't really understand what it would mean to "mock" that, apart from actually doing it.
08:32:43 <Cale> I guess there's a little work involved in encoding/decoding the websocket protocol itself that could be quickCheck tested.
08:33:30 <fendor> well, for example, i have something like this: Connection -> IO MyMessage
08:33:53 <fendor> and now i want to test that a valid message can be decoded 
08:34:03 <fendor> how can i test a function like this?
08:34:12 <Cale> The most bug-prone aspect of the websockets library though is the concurrency (and I'm not sure if it still does, but a while back I found it *did* indeed have a concurrency bug which mostly only showed up under high load)
08:34:20 <fendor> or is this function just poorly designed and should refactored?
08:34:40 <fendor> Cale, lucky for me, this is just a project for university :D 
08:36:11 <Cale> (I "fixed" the bug, but my solution in anger was a bit aggressive -- I ripped out its Stream type and replaced it with pipes. I'm not sure about upstreaming that. :)
08:36:48 <fendor> haha, well, if it works better ;) 
08:36:53 <Cale> fendor: If you can factor that into something like a function Connection -> IO ByteString and a function ByteString -> MyMessage
08:37:02 <Cale> then the latter part is much easier to test
08:37:47 <fendor> right, but then i would avoid testing the impure code which is the real interesting part
08:37:57 <fendor> since it is the point of the most mistakes
08:38:06 <fendor> and most painful mistakes
08:38:31 <cocreature> but if you mock the impure parts of your impure code, what is left that you actually want to test?
08:39:06 <Cale> Yeah, if you want to actually test the I/O, that amounts to building a test client
08:39:17 <cocreature> which is a reasonable thing to do
08:39:23 <cocreature> it’s just something different than mocking
08:40:13 <fendor> ok, i see your reasoning, so extract every pure element of the impure part, unit test the pure functions and integration test the impure
08:40:27 <cocreature> at least that’s what I do
08:40:38 <cocreature> and often it also makes it easier to reason about your code if you separate it like that
08:41:21 <fendor> sounds reasonable
08:42:51 <fendor> a friend of mine suggested to introduce a new typeclass which exposes the functions required for our use cases. Then do an implementation for a real connection and then add another implementation which just pattern matches on messages
08:43:29 <fendor> would you think this is reasonable as well? 
08:43:30 <ertes-w> fendor: reasonable pattern…  i do the same for databases: one STM-based implementation for testing, one sqlite/postgres-based implementation for production
08:44:23 <sphinxo> fendor: ( www.parsonsmatt.org/2016/07/14/rank_n_classy_limited_effects.html ) this might be helpful
08:44:25 <fendor> so, maybe the ideal testing environment would be a mix of both? more refactoring and introducing the new typeclass?
08:57:04 <david1236> hey guys.. i have a basic question about the monadic operator >>
08:57:29 <Iceland_jack> go ahead david1236
08:57:40 <geekosaur> you get answers faster when you actually ask the question
08:58:31 <Iceland_jack> @src (>>)
08:58:31 <lambdabot> m >> k = m >>= \_ -> k
08:58:56 <david1236> i know that >> means that we ignore the result of the first operation and return the result of the second one, e.g. ["1"] >> ["2"] will return ["2"]. Now what i am struggling with is, why does this not hold when the first result is an empty list e.g. [] >> ["2"] will return []
08:59:11 <david1236> [] >> ["2"]
08:59:15 <andy_wfc> Is there's a haskell equivalent to F#'s |> ignore? I'm having trouble find the right syntax for an IO operation where I don't care about the result. I want to throw some bytes at a file and then just call the next function regardless of what happened with the IO
08:59:18 <geekosaur> because it's not quite that simple
08:59:20 <Iceland_jack> david1236: Does this surprise you?
08:59:22 <cocreature> [1,2] >> [2]
08:59:24 <Iceland_jack> > Nothing >> Just "2"
08:59:24 <cocreature> > [1,2] >> [2]
08:59:26 <lambdabot>  Nothing
08:59:27 <lambdabot>  [2,2]
08:59:48 <david1236> well, it surprises me in that fact, that i have learnt that it usually returns the 2nd result
08:59:51 <geekosaur> :t (*>)
08:59:53 <lambdabot> Applicative f => f a -> f b -> f b
08:59:54 <cocreature> andy_wfc: sounds like >> if you’re talking about IO operations
08:59:56 <david1236> so why is it a special case if the first one is an empty list
09:00:01 <geekosaur> it's not
09:00:11 <geekosaur> (>>) involves two things: values, and actions
09:00:37 <geekosaur> in the list monad, [] is both "no values" and "no actions"; since there are no actions, there  is nothing to do with the right hand side
09:01:08 <geekosaur> (>>) ignores _values_ but still performs _actions_
09:01:18 <Cale> uhhh
09:01:25 <geekosaur> yes, this is an oversimplificatio
09:01:27 <geekosaur> n
09:01:33 <Cale> I'm not sure I like that characterisation. [] is still an "action" of the list monad.
09:01:53 <david1236> i see
09:02:08 <Iceland_jack> david1236: You can view the empty list as a form of failure
09:02:26 <geekosaur> this *is* an oversimplification, and it's really only applicable to how the list monad works
09:02:28 <Cale> It has a very definite effect as well, if you're thinking in terms of nondeterminism: it aborts that branch of the computation.
09:02:29 <david1236> yes that's what i am using the empty list for in my exercise
09:02:40 <david1236> but i couldn't figure out why this behaviour was like this
09:02:52 <Cale> > do x <- [1,2,3,4]; if even x then [] else [()]; return x
09:02:53 <david1236> yes cale that's what happens, i saw that
09:02:54 <lambdabot>  [1,3]
09:02:55 <geekosaur> which gets to the deeper point that how these things behave is up to the specific implementation
09:02:56 <ski> `>>' performs the effects of the left action, ignoring result, "then" performs the effects of the right action (yielding the same result as that one)
09:03:02 <david1236> but i want to understand
09:03:27 <Iceland_jack> david1236: Did you know that (>>=) @[] is the same as flipped concatMap?
09:03:28 <david1236> so if there is nothing to perform on the right hand
09:03:33 <david1236> it will abort and deliver [] ?
09:03:40 <geekosaur> the reason lists do this is because they represent computations with indeterminacy, where some "actions"/subcomputations may fail (produce an empty list) but you want the rest to continue
09:03:45 <Cale> > do x <- [1,2,3,4]; y <- if even x then [] else [()]; return (x,y)
09:03:47 <lambdabot>  [(1,()),(3,())]
09:03:49 <david1236> Iceland_jack: no :(
09:03:55 <ski> the meaning of "effect", and even "then", depends on the monad in question (in your case the list monad, where "effect" means "potentially multiple (or zero) results" and "then" corresponds to "nesting loops" or "trying all alternatives")
09:03:56 <Cale> david1236: ^^ have a look at that
09:04:00 <Iceland_jack> david1236: Try understanding concatMap
09:04:05 <Iceland_jack> and see how (>>) relates to it
09:04:08 <Iceland_jack> :t flip concatMap
09:04:10 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
09:04:11 <Iceland_jack> :t (>>=)
09:04:12 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:04:29 <geekosaur> andy_wfc, did you catch my pointing out (*>) around all of this?
09:05:06 <Iceland_jack> > concatMap (\a -> [a,a,a]) "Abc"
09:05:08 <lambdabot>  "AAAbbbccc"
09:05:10 <ski> david1236 : it's similar, for the list monad, to having nested loops. in case the outer loop runs through its body zero times (because the left argument to `>>' was the empty list), the inner loop (the right argument) won't be tried at all
09:05:14 <Iceland_jack> > concatMap (\a -> [toUpper a,a,toLower a]) "Abc"
09:05:16 <lambdabot>  "AAaBbbCcc"
09:05:27 <Iceland_jack> > "Abc" >>= \a -> [a,a,a]
09:05:28 <andy_wfc> geekosaur: yes. I'm still getting cryptic errors from runghc though. possibly because nesting of different IO ops
09:05:30 <lambdabot>  "AAAbbbccc"
09:05:59 <geekosaur> andy_wfc, then you should prepare a minimal example and show us both it and the resulting errors
09:06:01 <geekosaur> @paste
09:06:01 <lambdabot> Haskell pastebin: http://lpaste.net/
09:06:07 <david1236> ski: that's a nice way to think of it and helps to clear the sky a bit
09:06:13 <geekosaur> or use gist.github.com if there are multiple files
09:06:41 * Iceland_jack . o O ( clear the sky .. )
09:06:55 <david1236> Iceland_jack: i knew concatMap but i don't see the relation to >>
09:07:11 <david1236> that's a saying in my native language, it means that things get more clear for one
09:07:35 <ski> david1236 : for other monads, the meaning of "effect" and "sequencing" (*not* necessarily related to order of computation !) will be different. `Maybe' encodes "possibly no result" (so one or zero results, as opposed to zero or more results for the list monad)
09:07:37 <andy_wfc> http://lpaste.net/356130 this does what I want if I remote the writeFile line
09:07:38 <geekosaur> 'clear the air' is a bit more common variant in English
09:07:55 <Iceland_jack> Geekingfrog: I just thought it was funny as a reply to ski
09:07:58 <Iceland_jack> david1236: Well imagine concatMapping over the empty list
09:08:10 <Iceland_jack> > concatMap undefined []
09:08:12 <lambdabot>  []
09:08:17 <Iceland_jack> > concat (map undefined [])
09:08:19 <lambdabot>  []
09:08:20 <Iceland_jack> > concat []
09:08:22 <lambdabot>  []
09:08:45 <david1236> i see, there are no values, so there is nothing to operate on i guess?!
09:08:47 <Iceland_jack> Completely ignores "what to do" with the elements of the list
09:08:49 <Iceland_jack> exactly!
09:09:08 <Iceland_jack> > [] >> undefined
09:09:10 <lambdabot>  []
09:09:18 <david1236> i think my view on >> was very wrong
09:09:20 <ski> david1236 : then there's monads encoding threading multiple (successive) versions of state through a computation, percolating exceptions "upwards" towards handlers, distributing an "environment" (think configuration) "downwards" (only), parsing, &c.
09:10:00 <david1236> ski: yeah, i am using it for parsing at the moment
09:10:16 <Iceland_jack> If you are familiar with list comprehensions
09:10:19 <Iceland_jack> > [ y | x <- [], y <- [1,2,3,4] ]
09:10:21 <lambdabot>  []
09:10:42 <ski> (or even `_ <- []')
09:10:56 <Iceland_jack> Yes
09:11:00 <david1236> Iceland_jack: yes, list comprehensions are nothing new to me, but i thought that since the result of the previous computation doesn't matter for the second one, it is not necessary to even compute something
09:11:01 <Iceland_jack> even better
09:11:33 <Iceland_jack> The *value* of the previous computations gets ignored
09:11:48 <sphinxo> Could someone please review this code? https://git.io/vHPQp I'm wondering how I can pass around say the auth token and the image name implicitly 
09:11:57 <Iceland_jack> This is exactly like for Maybe (think of the empty list as Nothing, and the singleton list [a] as (Just a))
09:11:58 <dolio> It's not necessary to compute the elements, but it's necessary to compute how many elements.
09:12:06 <sphinxo> I don't really want to put them as optionals in config
09:12:10 <david1236> in list comprehension there is nothing to bind the variable x to, so i guess that's why it results in an empty list. since i thought in a >> b  a is nowhere bound in the context of b it doesn't matter
09:12:11 <ski> david1236 : that's similar to saying that a parser that first matches on a keyword (but produces no intermediate result from that), and then parses (say) an expression, should be the same as just parsing the expression
09:12:27 <Iceland_jack> > Nothing >> Just 666
09:12:29 <lambdabot>  Nothing
09:12:31 <sphinxo> since I don't want to have to care about checking if they are set every time I want to use them
09:12:54 <sphinxo> perhaps I can have 2 different states that I transition between?
09:13:14 <Cale> david1236: You can still imagine that you're picking an element of a, and then an element of b
09:13:16 <ski> david1236 : even though the result of the action that's performed/executed is discarded, its *effects* are not discarded. same thing for the list monad. not yielding any result is an effect in this case (as is yielding multiple results)
09:13:24 <Cale> > [1,2,3] >> [4,5]
09:13:26 <lambdabot>  [4,5,4,5,4,5]
09:13:38 <Iceland_jack> > [undefined, undefined, undefined] >> "AB"
09:13:39 <sphinxo> also looking for general cleanup/hygiene kind of things
09:13:40 <lambdabot>  "ABABAB"
09:13:52 <Iceland_jack> putting too fine a point on it:
09:13:52 <Iceland_jack> > [undefined, undefined, undefined, undefined] >> "AB"
09:13:54 <lambdabot>  "ABABABAB"
09:14:04 <Cale> Note that 4 and 5 appear three times each here, because you're picking an element of [1,2,3], and then, regardless of what that element was, picking an element of [4,5]
09:14:28 <Cale> > [] >> [4,5]
09:14:30 <lambdabot>  []
09:15:05 <Iceland_jack> david1236: Before I head home from work, consider the singleton list [x]
09:15:23 <dolio> ski, david1236: Note, in 'do print 5 ; print 6' it's not necessary to print 5 to know that you have to print 6, but people would be upset if print 5 didn't happen.
09:15:45 <Iceland_jack> It is the "identity" list, think why this is the case
09:15:55 <Iceland_jack> > [undefined] >> "This should be returned unchanged"
09:15:57 <lambdabot>  "This should be returned unchanged"
09:16:00 <david1236> because it's returning the same value
09:16:01 * ski would have mentioned an I/O example if david1236 had made clear they had encountered `IO' :)
09:16:02 <david1236> like * 1
09:16:11 <david1236> yes i see
09:16:30 <david1236> and [] is like the null element of mulitplication so to say
09:16:54 <ski> as Iceland_jack is saying, `return x' represents an action that actually performs no effects when executed. it just yields `x' as result
09:17:06 <ski> in the list case, `return x' is `[x]'
09:17:17 <david1236> yes, it just wraps the value into the typeconstructor right
09:17:23 <ski> in the parser case, it's a parser which always succeeds, without consuming any input tokens
09:17:27 <phz_> hey, using cassava
09:17:29 <david1236> yes exactly
09:17:34 <phz_> the CSV I have is encoded in a single line 
09:17:36 <Iceland_jack> david1236: Consider how simple the definition of 'return @[]' is
09:17:37 <david1236> that's also what we've learnt
09:17:48 <phz_> the parser file with endOfInput, I guess the line buffer is not large enough
09:17:50 <phz_> how can I change that?
09:18:25 <Iceland_jack> david1236: if you didn't know better you might skip past (return a = [a]) as a trivial, uninteresting definition
09:18:41 <ski> (in the state case, it's a state transformer which doesn't change the state which was gotten as input, directly putting it as the output state)
09:19:09 <david1236> yes i see
09:19:52 <Iceland_jack> david1236: You might also think, (return a = [a]) seems arbitrary, could it also be (return a = [a,a,a])"
09:20:27 <ski> it's essential that `return' on the left and right of monadic sequencing acts as a no-op, a "neutral element" (like `0' for `+', or `1' for `*', or `[]' for `++', &c.)
09:20:41 <david1236> could it ?
09:20:51 <Iceland_jack> david1236: No, it is constrained by the laws
09:20:54 <david1236> that make's sense to me ski
09:21:07 <ski> this means that we can refactor monadic "sequences" in the "obvious" way
09:21:13 <Iceland_jack> but there are other definitions if you want something slightly weaker than Monad
09:21:23 <Iceland_jack> pure a = a:pure a
09:21:26 <Iceland_jack> (infinite list of a's)
09:21:47 <david1236> i see, we learnt this as streams
09:21:49 <Iceland_jack> I'll head home from work, happy Haskelling david1236
09:21:57 <david1236> thank you Iceland_jack
09:22:07 <david1236> also thank you ski and Cale
09:22:25 <Iceland_jack> david1236: You can choose (return a = [a,a,a]) if you know the list is always of length 3
09:22:40 <ski> (that, and the fact that monadic sequencing is also "associative", the grouping doesn't matter (like `(xs ++ ys) ++ zs = xs ++ (ys ++ zs)'), only the sequencing may matter. for some monads, even the sequencing is of little import (just like the sequencing in `x + y + z' doesn't matter, addition is "commutative"))
09:22:47 <SepakoRayl> is ti possible to use a type family application in a class instance using any extensions?
09:23:06 <david1236> i see
09:23:22 <Iceland_jack> SepakoRayl: Use a data type / universe and then evaluate it using associated type families, that's one way
09:23:38 <Iceland_jack> You cannot directly do what you ask
09:24:09 <ski> Iceland_jack : but then you need a different definition of `>>' (as i'm sure you know)
09:24:38 <Iceland_jack> Yes your definitions (return, (>>), (>>=)) must agree
09:26:09 <SepakoRayl> I have a pattern GreaterThan :: (Preset (XCond z)) => Expr z -> Expr z -> Cond z. I would like to make it bidirectional by being able to specify a default value for each family instance. I went with typeclasses but the instance is apparently illegal.
09:27:11 * ski isn't that happy about such bidi patterns ..
09:28:16 <SepakoRayl> :/
09:30:38 <SepakoRayl> Iceland_jack would you mind to clarify? I have only been messing with type families for the past few hours.
09:31:24 * ski also isn't sure how to help with the question, possibly wouldn't know even given concrete code
09:33:43 <ski> (how does constraints on defined pattern constructors work ? input in case they mention a type variable in the result type, and output otherwise ?)
09:38:02 <ski> oh i see, it says `pattern P :: CReq => CProv => t1 -> t2 -> ... -> tN -> t'
09:40:31 <ski> .. i wonder how that interacts with using type synonyms whose definientia involves `=>', in the pattern synonym type signatures
09:41:39 <SepakoRayl> :/
09:43:45 <_sras_> I have a stack of Monads 'A' consisting of a Reader, Logger and Except. Now I want another Monad 'B' that wraps this whole stack and I want the call stack that looks like  (do; A;  A; A ; (runB  newEnv $ do B B B). I want all the operations of Monad A available from within Monad B, and in addition to that, access to the new environment, `newEnv`.
09:44:04 <_sras_> What is the optimal way to do this?
09:52:16 <nak_> æ/close
09:53:48 <MitchellSalad> _sras_: mtl is not great here due to the fundep preventing multiple MonadReader constraints
09:54:02 <MitchellSalad> is the new env in B meant to be accessed via 'ask'?
09:55:54 <_sras_> MitchellSalad: Not required. It can be some other function. I have already implemented this using a new monad that duplicate the reader monads structure. I am just wondering if it is really required to do that....
09:59:14 <MitchellSalad> _sras_: well, you could run B with a tuple environment, and thus re-use ReaderT
10:00:00 <MitchellSalad> is 'A' a concrete monad stack or a pile of mtl constraints?
10:00:55 <_sras_> MitchellSalad: A concrete monad stack..
10:02:06 <MitchellSalad> then you could use 'runB :: Y -> ReaderT (X, Y) m -> ReaderT (X, Y) m' to run 'B' things in 'A'
10:02:20 <MitchellSalad> er, typo, result should be 'ReaderT X m'
10:06:16 <torstein> _sras_, if the type arguments to the same monads are different (e.g. Reader Int and Reader Bool) then you can use free monads and do "i :: Int <- ask; b :: Bool <- ask"
10:07:19 <torstein> I'm not very experienced in the subject but you might find this video helpful: https://www.youtube.com/watch?v=gUPuWHAt6SA
10:07:24 <MitchellSalad> heh, don't do that
10:08:20 <cocreature> you can also combine MitchellSalad’s approach with classy lenses quite nicely
10:09:00 <torstein> MitchellSalad, why not
10:09:49 <MitchellSalad> torstein: only because moving to extensible effects is ill-advised for a beginner, or hell, an expert
10:10:04 <MitchellSalad> there are other ways of skirting the fundep issue (such as simply running in a different MonadReader)
10:10:11 <geekosaur> extensible headaches
10:10:58 <MitchellSalad> libraries like monad-classes/ether are alternative approaches
10:11:06 <MitchellSalad> eff is just about the last thing i would reach for =P
10:14:33 <MitchellSalad> cocreature: classy lenses?
10:16:25 <merijn> hmmm
10:17:04 <dolio> I actually think that having references that are resolved by their type is a bad idea.
10:17:49 * ski nods
10:19:33 <matrium> hi, is it possible to get all failed alternatives from attoparsec when the parser fails?
10:21:48 <wz1000> fmap (fmap f) xs, fmap f <$> xs, (f <$>) <$> xs or fmap f `fmap` xs?
10:22:01 <mbw> Have XEmptyDataDecls been subsumed in Haskell2010? The extension is still mentioned in the GHC docs, and from what I can see it is not marked as deprecated. Still, I can declare "data Void" just fine without it...
10:22:31 <Cale> I believe that extension was one of the ones which is switched on by default in Haskell 2010
10:23:09 <ski> wz1000 : how about `(fmap . fmap) f xs' ?
10:23:09 <mbw> Cale: Are default extensions a language thing or GHC specific?
10:23:24 <Cale> mbw: They're a language thing
10:23:45 <cocreature> MitchellSalad: https://www.youtube.com/watch?v=GZPup5Iuaqw is a pretty good explanation of that technique
10:24:26 <wz1000> ski: fmap fmap fmap f xs
10:24:41 <geekosaur> mbw, I recall that being added in H2010
10:25:02 <Cale> mbw: Language extensions were originally a GHC thing, but Haskell 2010 documented the pragma, as well as the names of a bunch of extensions, and named some of them as being part of Haskell 2010.
10:25:35 <Cale> That was one of the few things the H2010 report actually did vs. H98
10:25:37 <cocreature> MitchellSalad: basically the idea is that instead of trying to do (MonadReader a m, MonadReader b m, …) you do (MonadReader env m, HasA env, HasB env, …) and the HasX classes give you a lens from env to X
10:25:44 <ski> wz1000 : i wouldn't type that
10:26:35 <ski> (hm, and `EmptyCase' ?)
10:26:35 <mbw> Alright, thank you very much.
10:27:13 <dolio> Is EmptyCase separate?
10:27:26 <geekosaur> 	|	data [context =>] simpletype [= constrs] [deriving]
10:27:35 <geekosaur> note the constructors are optional in H2010
10:27:38 <dolio> I guess it is.
10:27:39 <glguy> Yes, EmptyCase is newer, and not in Haskell 2010
10:28:17 <Cale> lexp	→	case exp of { alts }
10:28:17 <Cale> alts	→	alt1 ; … ; altn	    (n ≥ 1)
10:28:25 <geekosaur> "This declaration introduces a new type constructor T with zero or more constituent data constructors K1, …, Kn."
10:28:26 <Cale> (In the 2010 report)
10:28:28 <sphinxo> Best way to call libc functions from haskell?
10:28:36 <geekosaur> no extension needed to get the "zero" vs. H98's "one"
10:28:43 <Cale> sphinxo: Foreign import them? What are you looking to call?
10:29:05 <sphinxo> a whole bunch of stuff
10:29:17 <Cale> sphinxo: A lot of stuff I would expect shouldn't need to be imported, because there's already some equivalent on the Haskell side.
10:29:30 <cocreature> the "unix" package might be relevant
10:29:30 <merijn> sphinxo: So, I assume based on this that you already know C, object files, linking, etc.?
10:29:47 <sphinxo> yeah, I was wondering if there was a wrapper package but I couldn't find anything
10:30:05 <merijn> sphinxo: It's almost trivial to directly call C from GHC haskell, read Chapter 8 (the FFI chapter) of the Haskell 2010 report
10:30:26 <mbw> geekosaur, Cale: What exactly did you type? It shows up in a weird way in irssi for me...
10:30:43 <merijn> sphinxo: Basically, as long as you don't want to 1) modify structs from within Haskell or 2) pass structs by value, it's all easy-peasy
10:30:45 <cocreature> the ffi chapter is the only part of the Haskell report that I actually take a look somewhat regularly
10:30:46 <geekosaur> I copy-pasted from the Haskell 2010 report
10:31:00 <geekosaur> so did Cale
10:31:01 * ski suspects it's the tab characters which turned out weird
10:31:12 <geekosaur> and Cale's has embedded tabs
10:31:15 <sphinxo> thanks
10:31:19 <Cale> Or the ... and >=
10:31:24 <Cale> which were unicode
10:31:29 <geekosaur> oh yes, arrows too
10:31:32 <Cale> and the arrows, yeah
10:32:23 <SepakoRayl> `Interestinting, this is allowed : class Test t where; type TTest t; empty :: t -> Test t; but with an empty :: Test t , it's not.
10:32:42 <merijn> Quick question: Can I get a profiled binary to output absolute time spent in a given cost centre, rather than percentages?
10:32:44 <mbw> I always thought language standard documents as being something scary that you only have to look at as a last resort
10:32:54 <Cale> cocreature: Yeah, it's perhaps the most pleasant to read part of the Report -- it was written with the intent of being a tutorial at the same time as specifying things, originally as an addendum to the Haskell 98 report.
10:32:58 <merijn> Because comparing percentages across different versions is hard
10:33:15 <geekosaur> mbw, they're useful in cases like this one where you want to know if something is actually part of the standard instead of being an extension
10:33:22 <ski> SepakoRayl : because `TTest' is an associated type synonym, rather than an associated data type. the latter are required to be injective, the former not
10:33:33 <ski> er, `Test', not `TTest'
10:33:37 <geekosaur> however, there's also the FFI bit, because the Report's FFI chapter is close to the only documentation on it'
10:34:15 <mbw> Yeah I had to learn that the hard way the past few days.
10:34:17 <Cale> merijn: I really really wish that you could just get a machine-readable dump of everything and build your own stats and presentation of it.
10:34:20 <geekosaur> ...well, the only *reliable* documentation. as per discussion last night, there's a lot of outright incorrect information about the FFI (including, apparently, the discussion in the wikibook)
10:34:23 <ski> SepakoRayl : if `Test Int = String' and `Test Double = String', then if you use `empty' with type `String', it has no idea whether `t' should be `Int' or `Double' (or something else). that's what lack of injectivity causes
10:34:26 <cocreature> Cale: I don’t even care about the tutorial part. the main reason why I take a look at it is because the GHC user guide is only written as a diff with respect to the report on that topic
10:34:46 <Cale> cocreature: ah
10:34:52 <merijn> sphinxo: Example for reference: Just two lines to be able to call my handwritten C code from Haskell: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L283-L287
10:35:05 <merijn> Cale: So...that's a no?
10:35:19 <sphinxo> nice
10:35:29 <ski> SepakoRayl : in the `empty :: t -> Test t' case, even though `t' couldn't be determined from the result type of the calling context, it can still be recovered from the argument type, so that's still allowed
10:35:32 <Cale> merijn: I don't know.
10:35:33 <geekosaur> sphinxo, you might consider the inline-c package
10:35:45 <Cale> merijn: I don't recall ever seeing a way to do that particular thing though.
10:35:54 <merijn> Cale: Bummer...I'm trying to see whether I indeed managed to speedup (and if so how much) my code
10:35:59 <geekosaur> which uses quasiquoters to build FFI stubs and declarations for you
10:36:13 <SepakoRayl> ah i get it
10:36:24 <SepakoRayl> it makes sense
10:37:08 <ski> SepakoRayl : `Test' being injective means that, for all `t0' and `t1', if `Test t0 = Test t1', then `t0 = t1'
10:37:14 <Cale> merijn: The other thing which upsets me is that ever since the new cost-centre stack treatment that happened back around 2010 or so, the time/alloc profiler results are in many cases far too granular.
10:38:10 <merijn> Cale: Yeah, I had issues with that too
10:38:13 <Cale> merijn: I have an example of a couple profiles of the same project from back around then where the "before" profile was sensible and a few kilobytes, and the "after" profile was 16 megabytes, and totally useless.
10:38:24 <ski> (that could be expressed in a single formula as `forall t0 t1. Test t0 = Test t1 => t0 = t1')
10:38:29 <merijn> Cale: Then I realised a magic trick: ":g/.*0.0    0.0$/d" :p
10:38:36 <Cale> haha
10:38:41 <Cale> Yeah, that would help some
10:38:47 <ski> SepakoRayl : another way to say that is that for each `u', there can be at most one `t' such that `u = Test t' (`forall u. unique t. u = Test t')
10:38:48 <merijn> Cale: It helps *a lot*
10:39:22 <Cale> But also, costs you might want to attribute to the same thing end up being split between many different lines, and it's hard to figure out what's important.
10:39:27 <sphinxo> What's an idiomatic way to convert between some enum and bitflags
10:40:01 <sphinxo> just have any old function and then fold over with .|.
10:40:01 <ski> SepakoRayl : incidentally, FDs, like in `class C a b c d | a b -> c' can also be explained in terms of `unique', the FD here expressing that `forall a b. unique c. exists d. C a b c d'
10:40:28 <merijn> Is there a nice hashing library somewhere? I found cryptonite and cryptonite-conduit so I can compute a hash streaming, but it appears to be *stupid* slow
10:41:08 <Cale> sphinxo: Yeah, typically I would just bite the bullet and write a function with a case expression in it that said what each constructor corresponded to
10:41:09 <merijn> I'm trying cryptohash-sha256 now, simply relying on lazy BS for streaming
10:42:14 <SepakoRayl> thanks ski, much appreciated
10:42:16 <Cale> sphinxo: You *can* use deriving Enum and write something which does a shiftL 1 (fromEnum x)
10:42:47 <sphinxo> ahh
10:43:13 <Cale> sphinxo: That might be a little too clever for its own good though.
10:43:48 <Cale> e.g. if say some bit is not meant to be used, that won't work
10:44:14 <Cale> and you're relying on the order of the constructors in the data declaration to line up with the order of the bits from least to most significant.
10:44:25 * ski . o O ( `data Foo = ... | Unused0 | Unused1 | ... | Unused2 | ...' )
10:44:43 <Cale> yeah, I suppose you could just invent data constructors for those unused bits :)
10:46:07 <Cale> merijn: Maybe the OpenSSL binding?
10:46:53 <ski> harder if you want to treat some spans of bits as encoding something more involved (like three bits denoting an `Int3', or four bits denoting a decimal digit, &c.)
10:47:24 <ski> (well, i suppose i had `Word3' in mind, actually)
10:47:59 <Cale> merijn: Just one confusing thing to note about using HsOpenSSL: make sure you withOpenSSL, or else the functions which are supposed to give you access to the digests will fail.
10:49:37 <Cale> (This is because of a weirdness in OpenSSL itself, where it avoids indexing the available digests/ciphers/etc. until you explicitly tell it to.)
10:50:12 <Cale> http://hackage.haskell.org/package/HsOpenSSL-0.11.4.9/docs/OpenSSL-EVP-Digest.html
10:57:06 <merijn> Cale: hmmm, lemme try
11:00:01 <spinus> if I have 3 data types, each has "type" field and each is deriving FromJSON, what is the best way to parse object and return one of 3 data types corresponding to "type" field?
11:02:56 <Cale> spinus: I would probably invent some single data type with constructors for each of the options
11:03:07 <Cale> spinus: You could use nested Either, but that's ugly
11:03:47 * ski . o O ( lightweight variants / cotuples )
11:04:14 <Cale> Yeah, if we had those, they'd be a solid option ;)
11:04:43 <spinus> Cale: yeah, I started thinking about nesting either and I'm keeping it as last options
11:04:52 <Cale> Why is it always coproducts that get initially overlooked?
11:06:11 <dolio> Coproducts are nasty.
11:06:11 * ski amalgamates products
11:06:16 <spinus> Cale: I think I'm going into the direction you mentioned, I have "data AnyType = T1 Type1 | T2 Type2" where Type1 and Type2 are other "data" and they parse correctly. I'm trying to write now parseJSON for AnyType, is that's the way?
11:06:42 <Cale> spinus: yep
11:06:45 <dolio> Much harder to deal with than products.
11:07:16 <merijn> Cale: Turns out all the options are roughly the same speed. OpenSSL being only barely faster. So maybe I'm just hitting the disk/memory bandwidth limit
11:09:49 <spinus> Cale: thanks
11:10:06 <ph88^> what should i put here for m ?   https://bpaste.net/show/24375bcd2b07
11:11:28 <Cale> ph88^: the name checkForDeviceSettings makes me suspect that it produces an IO action and not an Either
11:11:31 <merijn> Cale: Actually, simply switching the hashing function might be more beneficial. Supposedly SHA512 is 1.6x faster than SHA256
11:11:45 <merijn> Cale: Maybe one of the other digests is even faster
11:11:48 <Cale> ph88^: Or at least an action in some monad capable of doing IO
11:11:54 <ReinH> @tell quchen Excellent news!
11:11:54 <lambdabot> Consider it noted.
11:12:51 <cocreature> merijn: if you care about speed, blake2 might also be a good option
11:13:23 <ReinH> merijn: what kind of hashing do you want?
11:14:05 <merijn> ReinH: Just fingerprinting files
11:14:07 <ReinH> Because performance is generally an anti-goal of hashing for crypto.
11:14:14 <ph88^> Cale, checkForDeviceSettings  type checks itself .. it's only in combination with the code below it that it's going wrong .. but actually i was doubting if i had the implementation of checkForDeviceSettings right .. so i will paste it as well https://bpaste.net/show/dd455855ba2a
11:14:28 <merijn> ReinH: No, performance is only an anti-goal for password hashing
11:14:34 <ph88^> merijn, maybe take sha3
11:14:45 <merijn> ReinH: For literally ever other use, hashes are supposed to be fast
11:14:57 <Cale> ph88^: That's... really weird, but okay
11:14:59 <merijn> These are the ones I could easily plug in: https://hackage.haskell.org/package/cryptonite-0.23/docs/Crypto-Hash-Algorithms.html
11:15:01 <ReinH> That's why I said 'for crypto'.
11:15:28 <merijn> ReinH: Authenticating messages also is crypto and hashing and you want those to be fast
11:15:29 <ph88^> Cale, i don't feel quite right about that function as well .. maybe we could talk a little bit about how i structure my code ?
11:16:01 <ph88^> merijn, there is a stackoverflow question for suggestion algo's for fingerprinting
11:16:16 <merijn> heh, actually, maybe I should just use MD5
11:16:52 <cocreature> merijn: blake2 claims to be faster than md5 while not being shitty
11:16:56 <ReinH> Ok, let's say "any uses where brute force is a threat", the point is: you just want a fast hash, you don't care whether it's designed for crypto or not.
11:17:20 <merijn> cocreature: I'll compare them both
11:17:23 <ph88^> you want a fast hash with little chance for collision
11:17:36 <ph88^> merijn, and safe file length too
11:17:45 <Cale> ph88^: So, I would probably expect checkForDeviceSettings to actually *do* some I/O
11:17:47 <ReinH> Yes, but not in the same way that you care about collisions in cryto uses. For instance, MD5 is probably fine.
11:18:04 <merijn> ph88^: Honestly, collision chance is mostly irrelevant since I'm not dealing with adversarial input
11:18:24 <ReinH> Even some naive xor scheme would probably be fine.
11:18:29 <Cale> ph88^: But that's not what happens. It looks at ver, and then decides whether to produce Left of an IO action which will print the version, or
11:18:36 <ph88^> Cale, when i do some IO   IO ()   how do i get the settings back ?
11:19:14 <Cale> it produces Right applied to return of a big tuple of things, some of which are IO actions
11:19:56 <Cale> That return could be the return for any monad, given only this context (e.g. list would be fine)
11:20:06 <ReinH> merijn: I mean, why not use CRC32 if your primary concern is performance?
11:20:33 <ph88^> Cale, i don't understand the last thing you said
11:20:38 <Cale> okay
11:21:11 <Cale> So, one thing which is very important to understand and keep track of is the difference between an action in some monad like IO, and its result.
11:21:44 <ph88^> a big tuple of things, some of which are IO actions ... in my tuple i don't see IO anywhere .. how can there be IO actions in the tuple ?
11:21:57 <Cale> A value of type IO String is not very much like a String at all. A good analogy for it is that the difference between IO String and String is like the difference between /bin/ls and a list of files in your home directory
11:22:20 <Cale> IO actions are first class values, you can put them in data structures and pass them around
11:22:51 <Cale> They describe how to do various things related to I/O, and, if executed, can cause your computer to do anything that computers can normally do :)
11:23:02 <merijn> First class IO is like the best thing about haskell :)
11:23:28 <Cale> But simply *evaluating* them does nothing -- much as opening /bin/ls in a hex editor wouldn't cause a list of files in your home directory to accidentally be printed.
11:24:22 <ReinH> merijn: CRC32 is probably twice as fast as MD5 and even competitive with a well-constructed xor algorithm.
11:24:38 <Cale> (Evaluation being the process of reducing expressions to values usually for the purposes of pattern matching.)
11:24:59 <merijn> ReinH: Do you know a good streaming implementation in Haskell?
11:25:01 <ReinH> wait, no, just kidding. xor is slow and I can't read numbers.
11:25:11 <Cale> ph88^: For any value v, there is an action  return v  which does nothing, except to have v as its result when executed.
11:25:15 <ph88^> Cale, i got that .. but i think for that tuple it needs to do IO to make the tuple
11:25:15 <ReinH> md5 and sha1 are probably going to have similar performance
11:25:34 <Cale> ph88^: Nope -- the way you wrote it, it doesn't.
11:25:34 <ReinH> @hackage digest
11:25:35 <lambdabot> http://hackage.haskell.org/package/digest
11:25:40 <ReinH> Has one, I can't speak to whether it's any good.
11:26:01 <ReinH> It does support streaming.
11:26:01 <Cale> ph88^: For example, if you look at src
11:26:08 <Cale>       src = case fin of
11:26:09 <Cale>         Nothing    -> CB.sourceHandle stdin `catchC` \ex -> throw $ CE $ "Input stream error: " ++ ioe_description ex
11:26:09 <Cale>         Just input -> CB.sourceFile input   `catchC` \ex -> throw $ CE $ "Input file error: " ++ ioe_description ex
11:26:22 <Cale> (btw, use throwIO over throw whenever you can)
11:26:42 <ph88^> why use throwIO ?
11:27:02 <ReinH> merijn: Practically, I would imagine a good sha1 algorithm will win out just by virtue of being more popular and thus more likely to be well optimized?
11:27:05 <ongy> merijn: what are your platform constraints?
11:27:18 <Cale> Because throwIO throws an exception when *executed*, in sequence with other IO actions, making the exception easy to potentially catch
11:27:30 <ReinH> s/algorithm/implementation
11:27:35 <merijn> ongy: 64bit linux and OSX, anything else is optional
11:27:49 <ReinH> If it's good enough for git [TM]
11:28:02 <ph88^> ok
11:28:04 <Cale> throw does it when *evaluated*, which, if you use it at an IO type, will be at some point before it's executed, but possibly much earlier than you expected, based on the whims of the compiler.
11:28:19 <ph88^> ok
11:28:21 <Cale> and it's much harder to catch an exception thrown that way
11:28:40 <Cale> (because you need to have a mental model of how evaluation is taking place, which usually doesn't matter)
11:29:28 <ph88^> ok ill make note
11:29:42 <merijn> ongy: I have to go, if you have any recommendations, just @tell me via lambdabot :)
11:29:48 <ongy> merijn: not sure about osx, on linux there's AF_ALG, which could be easy enough to wrap
11:29:48 <Cale> okay, so this is a sort of complicated example to illustrate this with, let me make a simpler one
11:29:56 <Cale> ph88^: Suppose we write
11:29:59 <Cale> main = do
11:30:05 <Cale>   let foo = getLine
11:30:14 <Cale>   print "hello!"
11:30:23 <Cale> ph88^: What does this program do?
11:30:30 <ReinH> merijn: also consider asking yourself WWDJBD 
11:30:35 <ph88^> print hello
11:30:44 <matrium> hi, I have an (MonadState s t m, MonadIO m) but can't figure out how to build/run the matching monad stack 
11:30:45 <Cale> ph88^: and it doesn't get a line of text from the user, right?
11:30:52 <ph88^> ya
11:30:58 <ph88^> unused variable foo
11:31:01 <Cale> right
11:31:08 <ReinH> matrium: Only concrete m can be 'run'.
11:31:10 <Cale> Now, if we'd written:
11:31:12 <ongy> DJB? wouldn't it be osmething like SPJ for haskell?
11:31:12 <Cale> main = do
11:31:15 <Cale>   foo <- getLine
11:31:19 <Cale>   print "hello!"
11:31:37 <ph88^> i think compiler optimize foo away and online print hello
11:31:40 <ReinH> ongy: for choosing a hashing function? I'm going to go with djb over spj.
11:31:47 <Cale> ph88^: No, it's nothing to do with optimisation.
11:32:13 <Cale> ph88^: It's dealing with what the program itself means. The compiler will pretty much never change the meaning of your program with an optimisation.
11:32:22 <ph88^> oh ok
11:32:34 <matrium> ReinH: I was trying to use StateT, because it has a MonadState and MonadIO instance
11:32:35 <Cale> ph88^: When you write let foo = getLine, you're defining the action foo to be *equal* to the action getLine
11:32:41 <ph88^> ye
11:32:54 <Cale> ph88^: You're not defining it to be the result of executing getLine
11:33:01 <Cale> For instance, you might try this:
11:33:03 <Cale> main = do
11:33:06 <Cale>   let foo = getLine
11:33:13 <Cale>   x <- foo
11:33:16 <ReinH> StateT s m only has a MonadIO instance of m does.
11:33:16 <Cale>   print x
11:33:22 <ReinH> s/of/if
11:33:35 <ReinH> So if you have StateT s IO, we can answer that.
11:33:39 <Cale> ph88^: foo and getLine are interchangeable
11:33:44 <Guest53226> Hey guys, I solved a small task from the haskellbook but I doubt that it was written in the best way. I will give a link what I wrote and then explain what I missed
11:33:45 <ReinH> If it's StateT s (ReaderT r IO), the answer is different.
11:33:48 <ReinH> It dependson what m is.
11:34:57 <Cale> ph88^: But when we write  x <- getLine  -- that's a very different thing
11:35:21 <Cale> ph88^: It means "please execute the action getLine, and call whatever its result was x"
11:35:28 <ph88^> ok
11:35:34 <ph88^> i think i got that part
11:35:36 <Cale> ph88^: Since getLine :: IO String, then x :: String
11:36:04 <Cale> Whereas when we had  let foo = getLine  we'd end up with foo :: IO String
11:36:11 <Cale> because foo is literally the same thing as getLine then
11:36:28 <slacknatcher48> If I got two threads and only one need to perform gc, when they stop, will the two perform gc or just the one that triggered it?
11:36:57 <Guest53226> how do I get out the value out of Maybe if I do not use pattern matching, I am using the "maybe" function but is there like a better way?
11:37:19 <ph88^> Cale, maybe i should tell you the problem i'm trying to solve ?
11:37:22 <Cale> ph88^: So this is the thing which is going on with checkForDeviceSettings -- I think you mean to be carrying out all these actions and obtaining their results, but instead, you're defining a bunch of actions, tupling them together, and returning that.
11:37:24 <Tuplanolla> :t fromMaybe -- This, Guest53226?
11:37:26 <lambdabot> a -> Maybe a -> a
11:38:03 <matrium> ReinH: it's (StateT s IO t)
11:38:19 <Guest53226> Tuplanolla I do not have fromMaybe
11:38:59 <matrium> ReinH: ok, got it! I was still using runState instead of runStateT
11:39:08 <Tuplanolla> Sure you do, Guest53226. Just import it.
11:39:15 <Guest53226> which module 
11:39:30 <ongy> Data.Maybe
11:39:39 <Cale> ph88^: Oh, looking at it, maybe I'm not entirely correct: some of these bits and pieces don't appear to involve IO
11:39:41 <ongy> @hoogle fromMaybe -- this can also help with such questions
11:39:42 <lambdabot> Prelude undefined :: forall (r :: RuntimeRep) . forall (a :: TYPE r) . HasCallStack => a
11:39:42 <lambdabot> Text.Printf errorShortFormat :: a
11:39:42 <lambdabot> Text.Printf errorMissingArgument :: a
11:39:45 <slacknatcher48> better explained. Does filling the nursery makes a gc on all threads or just the one filled?
11:39:50 <ongy> or not, thanks lambdabot
11:40:02 <ongy> @index fromMaybe
11:40:03 <lambdabot> Data.Maybe
11:40:05 <ongy> ah that one
11:40:06 <ph88^> Cale, when i execute all these actions immediately i will get a chain of functions https://bpaste.net/show/23dabfc63a7f this way i loose overview in my program what calls what .. i like to have one function where i can see on high level what happens in the program. Now this is hidden too much, because each function calls the next one on the end
11:53:42 <ReinH> I mean, "each function calls the next one on the end" is a good description of how functional programming works.
11:56:06 <Guest53226> thanks Tuplanolla
11:56:08 <Guest53226> it worked
11:57:39 <SepakoRayl> is it possible to export patterns ?
11:58:06 <c_wraith> if you're using the PatternSynonym extension, yes
11:58:37 <geekosaur> SepakoRayl, you may need to use https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-namespaces-in-import-export
11:58:54 <ph88^> ReinH, but the program is getting complicated
11:59:53 <SepakoRayl> thanks geekosaur!
12:03:23 <vimalloc> Design question. I've been putting helper methods that are only used by one function into the where block of said function, so that you can visually see that they are coupled and not polute the namespace. Is that considered good practice?
12:04:40 <cocreature> vimalloc: I would say yes. one downside of that is that you can’t write tests for the helper methods or play around with them in ghci
12:04:59 <cocreature> so once they reach the point where they should be tested you probably want to move them out of the where clasue
12:05:00 <johnw> vimalloc: I like doing that too, when it makes sense
12:05:01 <cocreature> *clause
12:05:27 <vimalloc> Good point with the tests. Thanks guys  :)
12:25:12 <mark__> I'm trying to understand flip and . better.  Right now, mod 137 10 gives 7 (as expected), but flip . mod $ 10 137 is failing to compile.  Can someone explain to me why this is?
12:25:54 <twanvl> flip . mod $ 10 137 means the same thing as (flip . mod) (10 137)
12:26:09 <twanvl> so you are trying to use 10 as a function
12:26:46 <mark__> So just flip . mod 10 137 should work?
12:27:08 <ongy> mark__: flip mod 10 137
12:27:41 <mark__> ooooh ok thanks
12:27:42 <ongy> flip . mod 10 137 is flip (mod 10) 137
12:28:34 <mark__> Thanks, for some reason I was thinking flip did (a b) -> (b a), and wasn't viewing it as a HOF
12:28:44 <ongy> :t flip
12:28:45 <lambdabot> (a -> b -> c) -> b -> a -> c
12:40:24 <MitchellSalad> ongy: how do you get that 'flip . mod 10 137' is 'flip (mod 10) 137'?
12:41:45 <ongy> erm, experience? I'm pretty sure I used it like that before
12:42:02 <Tuplanolla> Dubious.
12:42:47 <ongy> I know. I also know it's about operator precedence, but I can't explain them, since I'm not too solid on those
12:43:06 <ongy> :t (.)
12:43:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:43:23 <mark__> :i (.)
12:43:24 <nshepperd_> flip . mod 10 137 is a type error
12:43:49 <Tuplanolla> That parses `((.) flip) ((mod 10) 137)`.
12:44:03 <nshepperd_> Unless you've got a weird Num instance in scope :p
12:45:10 <ongy> I wasn't claiming it works
12:45:33 <ongy> Tuplanolla: well, you skipped the hard part, which would explain why it parses like that
12:45:53 <Tuplanolla> Not really, ongy. You split on `.` first.
12:45:53 <nshepperd_> (flip . mod) 10 137 is also a type error, but in a different way
12:46:45 <mark__> function application is precedence 10, right?
12:46:52 <MitchellSalad> ongy: still, how do you get that 'f . g x y' = 'f (g x) y'?
12:47:25 <kadoban> mark__: It's higher than any operator precedence can be at least, only thing higher than it is record syntax.
12:51:33 <mark__> Ok, now I have myFunc x = flip mod 10 . div x, and I'm trying to make it point-free.  I know I can't just drop the x on both side, because it's currently parsed as flip mod 10 . (div x).  What can I do to try to make this pointfree?
12:51:35 <ongy> MitchellSalad: I think I got that one wrong
12:52:50 <Tuplanolla> @pl myFunc x = flip mod 10 . div x -- This will probably look terrible.
12:52:51 <lambdabot> myFunc = (flip mod 10 .) . div
12:53:37 <Tuplanolla> @let (.:) = fmap fmap fmap -- This is sometimes defined for this purpose, mark__.
12:53:39 <lambdabot>  Defined.
12:54:04 <Tuplanolla> :t flip mod 10 .: div -- It allows saying this.
12:54:05 <lambdabot> Integral b => b -> b -> b
12:54:57 <mark__> Oh, I haven't started learning functors yet.  Should I put understanding this off until I get there?  I'm just working through Haskell from First Principles right now
12:55:27 <Tuplanolla> Not really, mark__. It's a generalization of the owl operator `(.) . (.)`.
12:55:56 <nshepperd_> Usually, if it's not obvious how to make something point free, that's a good sign that you shouldn't :p
12:56:30 <ski> (partly a specious generalization)
12:56:46 <nshepperd_> f .: g = (\x y -> f (g x y))
12:56:58 <Tuplanolla> > negate .: Just (42, 13) -- It's just a deeper map.
12:57:00 <lambdabot>  Just (42,-13)
12:57:13 <nshepperd_> It's just composition with a two argument function
12:58:37 * ski . o O ( curriedly two argument function )
13:00:02 <BernhardPosselt> (+ 3) <$> Some 3
13:00:10 <BernhardPosselt> > (+ 3) <$> Some 3
13:00:12 <lambdabot>  error:
13:00:13 <lambdabot>      • Data constructor not in scope: Some :: Integer -> f b
13:00:13 <lambdabot>      • Perhaps you meant variable ‘some’ (imported from Control.Applicative)
13:00:19 <ongy> it's Just in haskell
13:00:20 <BernhardPosselt> > (+ 3) <$> (Some 3)
13:00:22 <lambdabot>  error:
13:00:22 <lambdabot>      • Data constructor not in scope: Some :: Integer -> f b
13:00:22 <lambdabot>      • Perhaps you meant variable ‘some’ (imported from Control.Applicative)
13:00:23 <BernhardPosselt> ah right :D
13:00:27 <BernhardPosselt> > (+ 3) <$> (Just 3)
13:00:30 <lambdabot>  Just 6
13:00:33 <BernhardPosselt> ah ok
13:00:46 <BernhardPosselt> so <$> is like <*> without the container
13:01:19 <ph88^> BernhardPosselt, <$> works on function and value, <*> works function on function
13:02:06 <BernhardPosselt> > (+) <$> (Just 3)
13:02:08 <lambdabot>  Just <Integer -> Integer>
13:02:19 <glguy> BernhardPosselt: Yes, in the one case the arguments have types:  (a->b) and f a, in the other f(a->b) and f a, but Functor and Applicative are more general than "containers"
13:03:17 <BernhardPosselt> right, i just simplified it :)
13:05:04 <BernhardPosselt> btw, i find most infix functions to be extremely confusing
13:08:14 <EvanR> i tend to not use <$> at all
13:08:37 <BernhardPosselt> > fmap (+) (Just 3)
13:08:39 <lambdabot>  Just <Integer -> Integer>
13:08:46 <BernhardPosselt> that one instead?
13:08:53 <EvanR> :t fmap (+1) (Just 3)
13:08:54 <ongy> EvanR: what do you use? fmap $ ... $ ...
13:08:54 <lambdabot> Num b => Maybe b
13:09:02 <EvanR> $ ???
13:09:10 <EvanR> fmap (f . g . h) more like
13:09:27 <EvanR> or liftA2
13:09:39 <ongy> :t liftA2
13:09:40 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:09:54 <EvanR> > liftA2 (+) (Just 3) (Just 2)
13:09:56 <lambdabot>  Just 5
13:10:42 <ongy> I like the infix stuff, but luckily I can't tell anyone how they write their code
13:11:14 <BernhardPosselt> its probably nice for point free style but when learning the language its super confusing
13:11:15 <EvanR> ill do q `divMod` d but thats about it
13:11:41 <BernhardPosselt> its impossible to decipher because its all just symbols
13:11:44 <Tuplanolla> I much prefer `lens` without the operators too.
13:11:56 <EvanR> operator overload
13:12:58 <Tuplanolla> In other languages programmers overload operators; in Haskell operators overload programmers.
13:13:15 <EvanR> the issue is the familiarity, a guy on the street may approve of ++ but not <$>, a haskeller will approve of <$> but not *@!/ probably
13:14:13 <geekosaur> until they start using lens >.>
13:14:37 <ongy> perl people will approve ~=
13:14:49 <BernhardPosselt> perl is dead for a reason :D
13:14:50 <EvanR> lens has 4 character operators?
13:15:24 <ongy> :t (>.>)
13:15:26 <lambdabot> error:
13:15:26 <lambdabot>     • Variable not in scope: >.>
13:15:26 <lambdabot>     • Perhaps you meant one of these:
13:16:03 <ongy> is the hoogle website (hoogle.haskell.org) down?
13:16:20 <BernhardPosselt> is that a real operator?
13:16:33 <BernhardPosselt> what about 
13:16:40 <BernhardPosselt> :t (>.<)
13:16:41 <lambdabot> error:
13:16:41 <lambdabot>     • Variable not in scope: >.<
13:16:41 <lambdabot>     • Perhaps you meant one of these:
13:16:43 <ongy> probably somewhere, but I think it was meant as a smiley here
13:17:00 <EvanR> @where downforeveryone
13:17:00 <lambdabot> I know nothing about downforeveryone.
13:17:14 <Tuplanolla> @index (<<//~)
13:17:14 <lambdabot> bzzt
13:17:24 <Tuplanolla> You know it's in there, lambdabot.
13:17:26 <geekosaur> lambdabot does int import all of hackage
13:17:34 <geekosaur> *does not
13:17:41 <Tuplanolla> :t (<<//~)
13:17:42 <lambdabot> Fractional a => LensLike' ((,) a) s a -> a -> s -> (a, s)
13:18:11 <geekosaur> and @index is limited to a subset of the libraries distributed with ghc
13:18:49 <Tuplanolla> It's a shame everything doesn't have a beautifully complete mathematical theory behind it.
13:21:03 <louispan> Random maths glossary question. Is there a word that is the opposite of "projection"?
13:21:28 <louispan> That is, given a subset of something, possibly get to the larger thing.
13:21:39 <EvanR> injection!
13:21:48 <Tuplanolla> Injection or the other one I forget...
13:21:50 <louispan> Ah, thank you.
13:21:53 <EvanR> embedding?
13:21:55 <mnoonan> louispan: "lift", sometimes
13:22:16 <louispan> I'm trying to find a word that describes what the Prism does in the other direction.
13:22:19 <mnoonan> or "section"
13:22:46 <louispan> I'll use Injection :)
13:22:56 <Tuplanolla> That was it, EvanR.
13:23:30 <mnoonan> section specifically means an f that satisfies pi . f == id, if that makes sense in your case
13:24:19 <EvanR> > ((2,) . snd) (2, 9)
13:24:21 <lambdabot>  (2,9)
13:24:26 <EvanR> > ((2,) . snd) (2, 33)
13:24:28 <lambdabot>  (2,33)
13:24:32 <EvanR> > ((2,) . snd) (2, 'a')
13:24:33 <lambdabot>  (2,'a')
13:24:40 <EvanR> guess this is backwards
13:26:06 <louispan> > ((3,) . snd) (2, 'a')
13:26:08 <lambdabot>  (3,'a')
13:27:20 <mnoonan> if snd is your projection, then anything of the form \x -> (f x, x) is a section
13:27:20 <louispan> let me read up on section. Thanks for all the suggestions everyone!
13:28:10 <ski> > ((,) . (1 +)) `uncurry` (2,'a')
13:28:12 <lambdabot>  (3,'a')
13:28:51 <EvanR> > (snd . (3,)) 'a'
13:28:58 <lambdabot>  'a'
13:31:01 <louispan> mnoonan: Thanks for the \x -> (f x, x) example. I couldn't think of anything to fit pi. f == id
13:31:30 <mnoonan> sure.. it's taking me back to my differential geometry days :)
14:40:40 <andrei_> is     "if a then b else c"     in WHNF ?
14:40:47 <glguy> no
14:41:03 <andrei_> how do we know that it is not in WHNF?
14:41:29 <glguy> It's not one of the 3 cases as seen at https://wiki.haskell.org/Weak_head_normal_form
14:41:30 <EvanR> its not a lambda or a constructor
14:42:18 <EvanR> it desugars to case a of {False -> b; True -> c}
14:42:40 <glguy> (flip your True/False)
14:42:45 <EvanR> oh
14:42:58 <EvanR> it desugars to case a of {True -> b; False -> c}
14:44:08 * hackage RSA 2.3.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  https://hackage.haskell.org/package/RSA-2.3.0 (AdamWick)
14:45:53 <andrei_> Thank you, EvanR ,  from where did you learn this ?
14:46:08 <EvanR> from that link glguy posted
14:46:53 <andrei_> I mean, about how if..then desugars ?
14:47:28 <glguy> andrei_: It's specified in the Haskell Report
14:47:37 <andrei_> Thank you!
14:48:01 <glguy> If you haven't looked through the Haskell Report, you should. It's like like some language standards documents only meant to be read by implementors
14:48:04 <EvanR> http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
14:48:13 <glguy> It's not like*
14:57:20 <ab9rf> only parts of it are that way :)
14:57:32 <EvanR> i think im missing something basic here. how do you make a type like Either a b, but in some places you can constrain it to be Left or Right
14:57:53 <EvanR> Either DefLeft a b, Either DefRight a b, Either dontcare a b
14:58:09 <ab9rf> do what?
14:58:24 <glguy> EvanR: If you want to exclude Left, use: Either Void a
14:58:33 <glguy> to exclude Right use Either a Void
14:59:30 <EvanR> and, i cant change the a or b
14:59:34 <glguy> then no
15:04:32 <EvanR> hmmm ask for Either (L a) (R b), then my other functions take either L a, or R b, or Either a b
15:04:43 <EvanR> L and R are simple newtype wrappers
15:05:29 <glguy> Or, your functions take a, b, or Either  a b?
15:05:42 <EvanR> yep i sound redundant to myself
15:05:54 <EvanR> guess i need to get the question right
15:11:50 <hexagoxel> EvanR: you can try the full dependent-type route and use GADT + lifted phantom type, and then you get into some mess where you either can't unify Lefts and Rights anymore, or where you have more than two type-level-flags so they start to share semantics which is ugly too..
15:11:53 <monochrom> Ah GHC foils my cunning plan. I was trying to do "data X (t :: X) = A | B" so that I could have punning types "X A" and "X B" but meh, GHC doesn't like "defined and used in the same recursive group"
15:12:41 <monochrom> So anyway, have two types L and R. Then use GADT: data E t a b where Lef :: a -> E L a b; Rig :: b -> E R a b.
15:14:01 <EvanR> thats probably the basic thing i was missing
15:14:14 <hexagoxel> you still can have data EFlag = L | R and lift that; not that it has much effect on what you can express on top of that.
15:14:54 <hexagoxel> data E (eflag :: EFlag) a b where ..
15:15:00 <monochrom> Yeah.
15:15:27 <monochrom> Much more self-documenting and less arbitrary.
15:18:03 <monochrom> Too bad "data X (t :: X) = A | B" is not allowed. Not even "data X t where A :: X A; B :: X B". Would have been so nice to write "Lef 5 :: E Lef Int b"
15:18:41 * ski was thinking of the latter
15:18:44 <monochrom> Time to write another mad-scientist post to haskell-cafe for this!
15:19:48 * ski idly recalls trying to use a function in its own (dependently) typed signature
15:20:05 <monochrom> :)
15:31:24 <mbw> I have a question about RankNTypes. Say I have a function "mkIdsFrom :: (forall a. a -> a) -> (Int -> Int, Bool -> Bool)" with "mkIdsFrom f = (f, f)". Then a function "boolId :: Bool -> Bool" can be defined as "boolId = snd (mkIdsFrom id)". However, "boolId = snd . mkIdsFrom $ id" does not typecheck. Why is that?
15:32:58 <monochrom> Does "snd . mkIdsFrom" typecheck?
15:34:11 <mbw> monochrom: It does not. Couldn't match type ‘a’ with ‘forall a1. a1 -> a1’.
15:34:20 <ski> mbw : `a' in `(.) :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)' isn't allowed to be instantiated to a universal type (`forall a. a -> a') (impredicative instantiation)
15:35:11 <mbw> The only thing I know about impredicative polymorphism is that GHC doesn't support it.
15:35:21 <ski> aye
15:35:41 <mbw> So the problem lies in the type of (.)?
15:36:31 <Tuplanolla> The only thing I know about quantum computing is that GHC doesn't support it.
15:37:23 <mbw> Tuplanolla: I know it's a lazy answer. I keep trying to grok the papers and failing to do so.
15:38:01 <Tuplanolla> I think that's a great answer to many things I don't care about right now.
15:38:48 <EvanR> mbw: snd (mkIdsFrom id) works? then yes
15:38:48 <mbw> Still, you probably care about RankNTypes...
15:39:05 <EvanR> problem is in .
15:39:26 <EvanR> and i noticed the same thing happening in idris, converting things to use . dont always work like youd expect from basic haskell
15:39:52 <EvanR> unfortunately!
15:39:52 <Tuplanolla> To only study what the GHC gods deem worthy, for everything else is vain.
15:40:32 <mbw> It becomes pretty clear if you write "boolId = snd `compose` mkIdsFrom $ id" where compose = undefined".
15:40:46 <mbw> Identity.hs|19 col 24 error| • Cannot instantiate unification variable ‘t0’$                                                             
15:40:49 <mbw>   2 ||   with a type involving foralls:$
15:40:51 <mbw>   3 ||     (forall a. a -> a) -> (IntId, BoolId)$
15:40:54 <mbw>   4 ||     GHC doesn't yet support impredicative polymorphism$
15:40:56 <EvanR> also what is this function supposed to even do
15:40:56 <mbw>   5 || • In the second argument of ‘compose’, namely ‘mkIdsFrom’$
15:40:59 <mbw>   6 ||   In the expression: snd `compose` mkIdsFrom$
15:41:01 <mbw>   7 ||   In the expression: snd `compose` mkIdsFrom $ id$
15:41:04 <EvanR> aaaaah
15:41:17 <mbw> EvenR: Obviously nothing useful.
15:41:32 <EvanR> understood
17:18:40 * hackage sensu-run 0.1.1 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.1.1 (MitsutoshiAoe)
17:42:36 <AMD> hi
17:45:06 <AMD> hi
17:54:13 <zaghie> anyone here learn haskell by reading book(s)?
17:54:22 <zaghie> *learnt
17:55:15 <Axman6> that's definitely one of the ways many people have used to help them learn Haskell
17:55:42 <zaghie> any books in particular? 
17:56:21 <sm> there are lots now, with different strengths. haskell tutorial and cookbook is a nice light one
17:57:29 <sm> programming in haskell is a nice medium one. haskell programming from first principles is a nice heavy one. 
17:57:41 <zaghie> nice nice thanks
17:58:37 <Axman6> From what I've read of http://haskellbook.com I was very impressed
17:59:38 <zaghie> thanks
18:18:52 <GGuy> Hi, if there a special name for maps that are the inverse of each other? f1 :: a -> b, f2 :: b -> a, where f2 (f1 a) == a
18:19:38 <slack1256> inverse function would fit
18:21:47 <slack1256> on a thread, what is a synchronization point? Is it whenever it allocates or generally yield?
18:41:51 <jared-w> out of 7 irc chat tabs I've got open like 5 of them are Haskell/FP related. I like my life
18:42:37 <Welkin> that's it?
18:42:37 <Welkin> why not all 7?
18:43:40 <glguy> jared-w: Maybe it's time to make your IRC client Haskell/FP related, too!
18:47:03 <jared-w> But... muh neckbeard status from using CLI clients...
18:47:29 <glguy> Yeah, a CLI client
18:49:22 <slack1256> glguy: any plans for a gui on glirc2?
18:49:40 <jared-w> Besides, we all know haskell sucks at GUI anyway. Still, though, I don't know of any plans for a haskell irc client?
18:51:17 <glguy> slack1256: No, I don't want to use a GUI client
18:52:46 <slack1256> I got some branches with gtk2hs widgets plus glirc2. Yet the ncurses Images are too central to the code to decouple it freely
18:55:01 <slack1256> on the stop-the-world phase, when do other threads stop? when they try to allocate?
18:56:13 <Welkin> or you could build it in html and use webkit-gtk or electron
18:56:42 <EvanR> if theres node-webkit, there should be haskell-webkit
18:57:41 <Welkin> I thought about building an irc client in purescript and using electron or webkit-gtk
18:58:11 <slack1256> why do it on the browser? is it easier than desktop toolkits?
18:58:17 <slack1256> or is it more declarative?
18:59:01 <EvanR> web tech has an overload of graphical and UI related features
18:59:12 <EvanR> its almost not recognizable as programming
18:59:33 <EvanR> if you are found trying to write code to do something, you wil be considered to be doing something wrong
18:59:37 <Welkin> slack1256: because the tooling is better than anything else
18:59:50 <Welkin> desktop ui libraries suck compared to it
19:00:10 <slack1256> really?
19:00:24 <EvanR> both worlds have different kinds of "this is just stupid" GUI development issues
19:00:42 <EvanR> theyve really diverged in the universe of ad-hoc GUI solutions
19:11:18 <ReinH> GGuy: yes, "isomorphism".
19:11:48 <glguy> isomorphism would need f1 (f2 a) == a, also
19:12:01 <ReinH> Well, if... Yes.
19:12:41 <slack1256> then retraction or right inverse
19:12:47 <mbw> I have another question about RankNTypes. Given that they are useful in the context of "not leaking resources", we could redefine "withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r" as "withFile' :: FilePath -> IOMode -> (forall s. Handle' s -> IO r) -> IO r", with "newtype Handle' s = Handle' Handle". A function "leakHandle = withFile' "somewhere" ReadMode $ \handle -> return handle" will then 
19:12:54 <mbw> refuse to compile. Why isn't it done this way?
19:13:19 <ReinH> I've heard this called a split morphism or a section/ retraction pair.
19:13:20 <glguy> mbw: What's the type of hPutStr in that model?
19:14:27 <mbw> glguy: I didn't think redesigning the API all the way through. Would defining hPutStr be a problem?
19:14:51 <glguy> mbw: Well, maybe it's not, let's see what you have in mind for it
19:15:26 <glguy> mbw, make sure that it prohibits me from doing this: withFile' somepath WriteMode (\h -> return (hPutStr' h)) :: IO (String -> IO ())
19:15:34 <ReinH> https://en.m.wikipedia.org/wiki/Section_(category_theory)
19:15:54 <mbw> Ok I'll try.
19:16:52 <glguy> mbw: If you're intersted in this idea you might like  http://okmij.org/ftp/Haskell/regions.html
19:17:54 <alhariel> what am i supposed to do when cabal cannot resolve dependencies?
19:18:31 <glguy> either "cabal update" or ask the package authors to fix their version bounds
19:19:28 <glguy> alhariel: What're you trying to build
19:19:36 <alhariel> yesod
19:19:55 <glguy> Oh, yesod is so hard to build they made a separate build tool to build it
19:20:04 <alhariel> lol
19:20:09 <mbw> glguy: They have probably given this way more thought than me.
19:20:19 <Welkin> lol
19:20:26 <alhariel> its rejecting persistent-template
19:20:27 <Welkin> use stack to install yesod
19:20:38 <Welkin> always o.o
19:21:07 <alhariel> yeah i was trying to follow the quick start but then it was failing to build the 'network' package
19:21:23 <glguy> Windows?
19:21:31 <alhariel> sadly
19:21:47 <glguy> The best way to get network on Windows in general is from your Haskell Platform install
19:21:55 <glguy> except that you're building yesod, so you'll get it from stack
19:22:10 <Ford_Prefect> slack1256: EvanR: I think the GNOME world is trying to pick up some of the better parts of the web (CSS theming, dynamic inspection/editing of the widget tree, ...)
19:22:15 <mbw> If I understand correctly, the problem is that the evaluation of the IO action could be deferred, it being eventually doing some work while using a handle that refers to an already closed file?
19:22:24 <glguy> mbw: Right
19:22:35 <Ford_Prefect> And garetexe has been doing some pretty good work around the haskell-gi stuff
19:22:44 <glguy> mbw: This is why both STRefs and ST itself are indexed by the same phantom type parameter
19:22:50 <alhariel> yeah i was doing 'stack build' and it was failing to build 'network'
19:23:07 <alhariel> i did 'cabal install network' and it worked fine
19:23:21 <alhariel> but then failed again when i tried 'stack build'
19:23:34 <glguy> cabal install'd things are separate from stack
19:24:18 <alhariel> i see
19:24:40 <alhariel> would this work better from a clean install?
19:25:08 <glguy> alhariel: Before you start deleting things, you can put all the information about what you're trying to do on a pastebin like http://lpaste.net
19:25:22 <glguy> things like your stack.yaml and the terminal output
19:25:41 <mbw> glguy: Have my previous messages been sent? I just experienced some lag+reconnect.
19:26:26 <glguy> mbw: Check the log: http://tunes.org/~nef/logs/haskell/17.06.08
19:26:32 <glguy> it will show what messages we've seen
19:26:46 <glguy> I don't know what messages I've missed :)
19:27:50 <mbw> Yeah I just didn't see your reply.
19:28:39 <mbw> If lazy eval is a problem, wouldn't this example http://chrisdone.com/posts/rankntypes be problematic as well, assuming they relied on closing the database connection in withConnection?
19:28:55 <mbw> They don't do it in the example.
19:29:29 <glguy> mbw: No, the inner type is (DB c), not IO
19:29:57 <glguy> query :: Connection c -> String -> DB c [String]
19:30:06 <glguy> instead of the problematic: query :: Connection c -> String -> IO [String]
19:30:51 <sphinxo> why am I getting  unshare: invalid argument (Invalid argument)
19:31:05 <sphinxo> ( paste incoming )
19:31:18 <sphinxo> ( trying to use the ffi )
19:32:32 <mbw> To be honest I don't get it 100%, since it's a little concise.
19:33:02 <glguy> mbw: let's strip it down to these two:
19:33:14 <glguy> doStuff :: Resource a -> IO ()
19:33:20 <sphinxo> when calling unshare with  [PID, Network, Mount, UTC, CGroup, IPC, User] why doI get invalid argument at runtime? http://lpaste.net/3674853440992837632
19:33:23 <glguy> doStuff :: Resource a -> Limited a ()
19:34:17 <glguy> mbw: Observe that (doStuff r :: IO ()) in one case and (doStuff r :: Limited a ()) in the other
19:34:28 <glguy> so in the IO case we lost the type that was providing region safety
19:34:34 <glguy> and in the Limited case we still have it
19:34:49 <mbw> ok.
19:34:52 <geekosaur> EINVAL An invalid bit was specified in flags.
19:35:42 <sphinxo> hmm ok
19:36:27 <alhariel> https://pastebin.com/DPRmu8cW
19:36:35 <sphinxo> what am I missing? http://man7.org/linux/man-pages/man2/unshare.2.html
19:36:56 <sphinxo> is it the way I'm .|.ing them?
19:37:07 <alhariel> this is the log of the installation attempt of network package
19:37:30 <alhariel> after running 'stack build', following the yesod quick start guide
19:37:56 <slack1256> I am amazed by the quality of the docs on ghc/rts
19:37:59 <geekosaur> sphinxo, what kernel are you running?
19:38:09 <glguy> alhariel: What does your stack.yaml look like? What command did you run?
19:38:09 <sphinxo> 4.10.13-1
19:38:38 <sphinxo> so after 3.8 and 4.6
19:39:24 <glguy> sphinxo: How about removing bits until you figure out exactly which one is the problem
19:40:17 <alhariel> i feel dumb now -.-
19:40:20 <geekosaur> oh, I see. CLONE_NEWPID implies CLONE_THREAD and this will always fail
19:40:37 <geekosaur> because even the "non-threaded" runtime has multiple OS threads for use by the I/O manager
19:40:44 <alhariel> i skipped a step in the tutorial
19:41:14 <geekosaur> and CLONE_THREAD cannot be undone with unshare() if there are multiple OS threads
19:42:18 <geekosaur> likewise CLONE_NEWUSER
19:42:32 <geekosaur> so, you can;t use either of those from ghc
19:42:37 <sphinxo> hmm
19:43:17 <geekosaur> unless you provide your own main() and call it from there before hs_init()
19:45:17 <sphinxo> ok thanks!
19:47:27 <wespiser> is there a better way to create a session id for a web server than: mapM (\_ -> randomRIO ('a', 'z')) ([1..1000] :: [Int]) ?
19:47:29 <wespiser> thanks!
19:48:27 <glguy> Maybe not for your session idea, but be aware that what you wrote can be simplified to:  replicateM 1000 (randomRIO ('a', 'z'))
19:48:52 <wespiser> yea, thanks
19:49:05 <wespiser> i'm looking to make sure my tokens are securely random
19:50:10 <orion> So, in Data.ByteArray there is a type called "Bytes". An instance of Ord exists for this type, but the comparison starts in the lower area of memory and works its way up (big endian). I want to compare numbers represented in little endian, but all I have is this instance.
19:50:35 <orion> Is it logically sound to invert the comparison?
19:51:08 <orion> So, if the big endian comparison function returns LT I will return GT, and if it returns GT I will return LT.
19:51:42 <glguy> wespiser: 1000 characters is too much. The StdGen you'd be getting those random numbers from is only two 32-bit ints
19:51:46 <michi7x7> orion: no, not sound
19:52:15 <glguy> and isn't a good source of cryptographically strong random numbers
19:52:47 <orion> michi7x7: Certainly it would be sound to reverse both and then perform the comparison, right?
19:53:05 * hackage hoppy-generator 0.3.3, hoppy-runtime 0.3.1 (khumba): https://qbin.io/cj34n58
19:53:31 <michi7x7> orion: you can check byte for byte, but you have to take equality into account
19:53:52 <michi7x7> orion: hm no, you can't check byte by byte
19:54:53 <michi7x7> ecept you start from the big end (right) and work backwards
19:55:12 <orion> michi7x7: The implementation I am working with is as follows: http://hackage.haskell.org/package/memory-0.14.5/docs/src/Data-ByteArray-Bytes.html#line-131
19:55:17 <orion> "bytesCompare"
19:55:35 * hackage versions 3.1.0 - Types and parsers for software version numbers.  https://hackage.haskell.org/package/versions-3.1.0 (fosskers)
19:56:36 <wespiser> glguy: thanks
19:56:42 <wespiser> i'll look for a better library
19:57:12 <wespiser> i can't have people possibly guessing, or the potential for collisions
20:00:58 <mbw> glguy: Would a better type signature be "withFile :: FilePath -> IOMode -> (forall s. Handle' s -> HandleIO s a) -> IO a" ? HandleIO would be a corresponding phantom type. However, I still can write code that gives back IO (String -> IO ()) with that...
20:01:52 <glguy> mbw: yeah, that'd work better. hPutStr :: Handle' s -> String -> HandleIO s ()   then
20:02:03 <mbw> Ah.
20:03:23 <mbw> Ok, now the code doesn't typecheck anymore, in the positive sense.
20:04:37 <mbw> So I guess these kinds of functions are left like that because a lot of code that relies on returning IO a would break?
20:05:04 * hackage hoppy-docs 0.3.2 - C++ FFI generator - Documentation  https://hackage.haskell.org/package/hoppy-docs-0.3.2 (khumba)
20:06:25 <glguy> mbw: Yeah, these kinds of things are both inconvenient to use and infect lots of other code
20:06:26 <mbw> (Well it's probably way more subtle, after all pipes/conduit exist...)
20:07:44 <mbw> Remembering back to my initial troubles with ST s and type inference, I can see why this might be a problem, especially for a beginner.
20:10:14 <mbw> Still, thanks for your guidance. RankNTypes are not really easy to grok if the only thing people use to explain it with are Church encode lists and applying functions to pairs...
20:12:28 <LiaoTao> http://www.arcadianvisions.com/blog/2013/introducing-vinyl-gl.html
20:12:34 <LiaoTao> Is this still the way things are done?
20:12:38 <LiaoTao> 4 years have passed after all
20:23:39 <sveit> the normal ContT has signature runContT :: (a -> m r) -> m r, but it is possible to implement something that at least appears to usable, but with the type in the "wrong" direction, newtype WContT m r a = runWContT :: (m a -> r) -> r, and implement a Monad instance for (Monad m, r ~ m b). I have done so here: https://pastebin.com/FuthbrwN . is there an interpretation of this version of ContT? is it just silly for some reason (not
20:23:40 <sveit> law-abiding) or counter-intuitive in some way?
20:24:06 <sveit> at the very least one can implement (as I have done in the paste) Cont in terms of WContT Identity
20:25:26 <`Guest00000> sveit: does it typecheck?
20:25:45 <sveit> yep, i can load that file into GHCI
20:26:48 <sveit> and even run examples programs, for example { f :: Cont' r Int; f = wCallCC $ \k -> k 3 >> k 4; runCont' f show } does what you expect
20:27:37 <sophiag> i'm watching a short talk where richard eisenberg introdudce singletons and am a bit confused about a type instance where he uses a type level conditional: type instance NextEven n = If (IsEven n) n (Succ n)
20:27:37 <sophiag>  
20:28:19 <sophiag> i assume this is from another type family i just haven't haven't defined?
20:38:23 <butterthebuddha> Hey peeps, need some assistance with problem 9 here: https://wiki.haskell.org/99_questions/1_to_10
20:38:28 <butterthebuddha> this is what I have so far: https://pastebin.com/Wi68KAfN
20:40:12 <sphinxo> geekosaur: how do I provide my own main?
20:40:42 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#using-your-own-main
20:40:53 <sphinxo> ahh thanks
20:42:17 <`Guest00000> butterthebuddha: you don't keep state for whether we are inside a group now
20:42:21 <`Guest00000> and you need to do it
20:45:28 <butterthebuddha> `Guest00000: What's "it"?
20:45:36 <`Guest00000> keep state
20:46:24 <butterthebuddha> How though?
20:46:28 <sphinxo> geekosaur: How can I get cabal to compile and use my main.c?
20:47:53 <sphinxo> ( if that's possible )
20:50:01 <geekosaur> that I don't know
20:50:17 <butterthebuddha> `Guest00000: some help here?
20:50:40 <sphinxo> so makefiles will probably be my solution
20:51:51 <`Guest00000> butterthebuddha: forget about state, i'm wrong
20:52:22 <`Guest00000> you need to recurse on remainder of the input list first
20:53:00 <sphinxo> with the inline-c package will I have the same problem?
20:53:39 <`Guest00000> then use that result to construct your result
20:53:57 <geekosaur> sphinxo, inline-c cannot run something before the Haskell main, so yes
20:54:42 <geekosaur> that said, you might solve two problems at once and use a wrapper C program to run the Haskell program, which will be pid 1 in the new namespace which is probably what you intended
20:55:09 <sphinxo> hmm
20:55:44 <geekosaur> (you *did* see that little detail, right? that your program does not move into the new pid namespace, but instead the next new process it creates is pid 1 of the new namespace?)
20:56:09 <sphinxo> yes
20:56:13 <sveit> sorry to bump, but here: https://pastebin.com/FuthbrwN I implemented a "wrong-way" ContT, where the type is (m a -> r) -> r instead of (a -> m r) -> m r (to implement Monad i require r ~ m b). I guess this is strictly more restrictive, but, is there some intuition for this "wrong-way" transformer? some reason it's a good or bad idea? I can at least implement Cont in terms of this ContT
21:04:16 <dibblego> sveit: you might be interested in first, Kleisli and its relationship to ContT and then Cokleisli which relates to your accidental implementation.
21:05:29 <`Guest00000> comonad?
21:05:44 <`Guest00000> but m is monad
21:06:39 <edwardk> w (a -> r) -> r    for a comonad w is a comonad-to-monad transformer of a sort
21:07:19 <edwardk> sveit: have you checked the monad laws for your "wrong way" cont yet?
21:08:44 <edwardk> sveit: you can replace join . fmap ...  with (>>= ...) in your >>= implementation
21:09:52 <alhariel> @glguy so now this is what im getting https://pastebin.com/6TCZW80B
21:09:52 <lambdabot> Unknown command, try @list
21:10:53 <edwardk> sveit: implementing Cont in terms of the monad you show is just a type specialization. implementing ContT in terms of Cont is also a form of type specialization, ContT borrows its "monadness" from Cont by picking r = m r' then just has to show that lift is sensible. In your case you need to prove all the monad laws all over by just using the monad laws on 'm'
21:12:00 <sphinxo> geekosaur: how do I call my haskell main from my c entrypoint after calling hs_init?
21:12:35 <sphinxo> include Main_stub ?
21:12:55 <sveit> dibblego: category theory is on my reading list, but i think at my stage it would help me more to think of this in a slightly more down-to-earth way, probably just in terms of the monad laws and concrete behavior of this monad.
21:13:19 <sveit> dibblego: i'm actually trying to use this exercise to get some more intuition for monads from specific examples before i dive in
21:13:47 <sveit> edwardk: thanks for looking! i'll check the monad laws explicitly now. it seems to me like they should hold intuitively though
21:14:06 <edwardk> it seems to me quite the opposite. i expect to see the monad laws fail here
21:15:09 <sveit> edwardk: sure, implement Cont from ContT is just type specialization, but isn't that true for all the Monad ~ MonadT Identity transformations?
21:15:14 <geekosaur> sphinxo, instead of having an exported top level name Main.main, you have it under some other name with a foreign export declaration. then you #include the stub generated for it and call it from C
21:15:30 <edwardk> sveit: what i mean by that is that it doesn't actually tell you anything
21:15:40 <sphinxo> ahh awesome thanks for all your help!
21:15:59 <geekosaur> you can't call the C-side function "main" because C is using that, and it's jusyt confusing to have that be the Haskell entry point but I suppose you could do it if you insisted
21:16:21 <sphinxo> don't you mean the haskell side function?
21:16:59 <geekosaur> that is "Haskell entry point"
21:17:05 <sphinxo> ahh
21:17:34 <edwardk> ContT isn't surprising given Cont. Cont isn't surprising given ContT. Your definition doesn't follow from either of them though and the constructions that I know that give rise to ReaderT, WriterT, StateT, etc. don't motivate the ad hoc placement of the 'm' in your type
21:18:59 <edwardk> The monad you have here is basically Compose (Cont r) m -- but now you need a general purpose distributive law to motivate getting the 'm's next to each other.
21:19:17 <edwardk> and a reason to assume that is well behaved with respect to the monad 'm'
21:20:00 <sveit> edwardk: actually that's sort of what i was trying to understand. why there might be "canonical" types for monad transformers. it's sort of intuitive, for example, that StateT should havetype s -> m (a, s), not s -> (m a, s), since StateT should "perturb" m, but I don't have a similar intuition for ContT
21:20:13 <edwardk> what i mean by 'getting the 'm's next to each other. join :: Sveit (Sveit m) a -> Sveit m  a    needs to take that Cont r (m (Cont r (m a)) -> Cont r (m a)
21:20:22 <sveit> are any of these constructions that you mention not very formal?
21:21:12 <`Guest00000> i actually needed something like that "wrong" ContT in something... i can't remember
21:21:23 <edwardk> sveit: StateT s m a takes s -> m (a, s) because if you have any adjunction F -| G then GF is not only a monad, but GMF is also a monad. This works because of preservation of limits/colimits: we can pull (->) one way through any functor in haskell and (,) another way.
21:22:01 <edwardk> readert and writerT are both specializations of that, the ability to preserve limits/colimits
21:22:22 <edwardk> to get universal distributive laws that let you move them past any monad in one direction or the other
21:22:32 <edwardk> i can always turn (e, m a) -> m (e, a)
21:22:49 <edwardk> i can always turn m (e -> a) into e -> m a
21:23:37 <edwardk> combined these facts let me move m's together inside stateT
21:24:41 <Axman6> what is BinaryBlob?
21:24:43 <Axman6> whoops
21:24:49 <glguy> alhariel: That's not an error I've ever seen. You're using a build tool I tend not to use with a web framework I avoid on an OS I wouldn't want to develop on ^_^ Maybe someone else has seen "Segmentation fault/access violation in generated code" using yesod on Windows?
21:25:30 <sphinxo> I can't seem to #include the haskell stubs
21:26:16 <sphinxo> ( section in my package.yml http://lpaste.net/8280747833460523008 ) ( using hpack )
21:26:55 <glguy> Using hpack is another way to limit the set of people who can help you
21:27:01 <sphinxo> haha ok
21:27:27 <sphinxo> I don't think it matters in this case
21:29:57 <edwardk> sveit: the formalities are where my intuitions come from here
21:31:32 <sphinxo> ok here's the generated cabal section + my c main http://lpaste.net/8280747833460523008
21:31:59 <sphinxo> I have a file called Entrypoint.hs inside src/ with a method called entrypoint
21:37:26 <butterthebuddha> `Guest00000: isn't that what I'm doing? recursing on the remainder and using that to build the result?
21:41:22 <smallCat> Can someone help me figure out the issue here: https://pastebin.com/jMD3f80K
21:41:36 <smallCat> I'm trying to build a webapp using Servant for the routing
21:41:53 <smallCat> And it's giving me a type issue that I can't figure out
21:42:06 <`Guest00000> smallCat: you are a small cat
21:42:33 <`Guest00000> butterthebuddha: ahh, that phrase isn't useful
21:42:48 <butterthebuddha> What I'm having trouble with is that
21:42:53 <butterthebuddha> I'm concatenating two lists
21:43:03 <butterthebuddha> While I really need to concatenate the last member of a list in a special case
21:43:10 <jle`> ghc has literally been building on my linux-subsystem-on-windows box the entire day
21:43:26 <`Guest00000> but i'm going to say again that you need to preserve state of in-or-out-of-group
21:43:29 <jle`> i wonder how much time i have left
21:43:56 <sveit> edwardk: thanks! i was trying to get my head around some of the more complicated transformers without the tools of category theory, but it seems like "understanding" StateT and similar transformers is going to have to be enough. just for fun, i'm still checking the monad laws for my "wrong" ContT though. 
21:44:03 <`Guest00000> but not in recursive call, but in constructing result
21:44:12 <butterthebuddha> `Guest00000 yeah recursion wouldn't work if I did that
21:44:56 <`Guest00000> and you need to revise 'which' remainder of the input you use
21:45:00 <`Guest00000> for the recursive call
21:45:15 <butterthebuddha> Uhhh
21:45:30 <butterthebuddha> Not sure what oyu mean by that
21:45:33 <butterthebuddha> you *
21:45:35 <edwardk> sveit: for what it is worth it is worth exploring why (e, m a) isn't a monad, and why m (e -> a) isn't a monad as well. the reasoning is quite similar
21:45:37 <`Guest00000> "that phrase isn't useful" i meant my phrase about recursing on the remainder
21:46:03 <`Guest00000> butterthebuddha: with lists you've got plenty of remainders
21:46:12 <edwardk> similary why state is s -> m (a, s)    and not m (s -> (a, s)) or s -> (m a, s)    all follow from the same playing with limits
21:46:19 <butterthebuddha> `Guest00000 what's a remained int he context of lists?
21:46:19 <edwardk> ContT is actually a bit of a weird beast
21:46:49 <cocreature> smallCat: try using "(indexHandler :<|> loginHandler) :<|> …". that should match the way your types associate
21:47:18 <`Guest00000> butterthebuddha: with lists you recurse on their tails, right? so, lists' tails are remainders
21:47:21 <lpaste> glguy pasted “c-based main for sphinxo” at http://lpaste.net/8651141195977719808
21:47:26 <sveit> edwardk: but at least i can easily convince myself that s -> m (a, s) gives me the behavior i "want" :) 
21:47:35 <sveit> independently of limits
21:47:45 <butterthebuddha> Right. So don't I only have one "remainder" with each recursive call?
21:47:58 <sveit> btw is it true that (m >>= k . pure) = k (m a) for all monads?
21:48:20 <jle`> depends on what 'a' is
21:48:28 <`Guest00000> butterthebuddha: look closely to "a:b:xs"
21:48:39 <edwardk> sveit: that doesn't type check
21:48:53 <`Guest00000> what do you see?
21:49:00 <butterthebuddha> xs is the remainder?
21:49:01 <sveit> wait sorry, that is nonsense
21:49:05 <edwardk> m on the left is a monad, on the right it is a function =)
21:49:06 <smallCat> cocreature : oh... I think I got the issue. Thanks!
21:49:13 <`Guest00000> butterthebuddha: one of them
21:49:16 <`Guest00000> find the other
21:49:45 <sveit> i meant does (ma >>= k . pure) = k ma 
21:49:52 <butterthebuddha> b
21:50:14 <`Guest00000> butterthebuddha: no, b can't be a remainder of the list, it's its element
21:50:19 <butterthebuddha> the empty list?
21:50:41 <`Guest00000> butterthebuddha: where do you see the empty list?
21:50:56 <`Guest00000> the empty list is only at the end of list structure
21:51:05 <butterthebuddha> I mean it technically is a remainder idk
21:51:11 <butterthebuddha> What's the other remainder?
21:51:24 <`Guest00000> butterthebuddha: hint:  a:(b:xs)
21:51:42 <butterthebuddha> Okay, b:xs is also a remainder
21:51:53 <`Guest00000> yep, you need to use it
21:51:59 <glguy> sphinxo: Use this one instead, lpaste is failing $ cat *.cabal
21:52:12 <glguy> https://paste.fedoraproject.org/paste/kZCaIp5sNeCZPKVbTRyf-V5M1UNdIGYhyRLivL9gydE=
21:52:44 <iqubic> I like dpaste.
21:52:45 <`Guest00000> and remember that you can pattern-match more than once inside a function body
21:52:46 <sveit> edwardk: ok, so my "wrong" ContT fails the "m >>= return" law for m = []. Thanks!
21:52:58 <edwardk> there ya go
21:53:01 <iqubic> What is ContT?
21:53:18 <iqubic> I mean what is the Cont Monad?
21:53:21 <edwardk> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
21:53:22 <sveit> newtype ContT m r a = ContT { runContT :: (a -> m r) -> m r }
21:53:22 <iqubic> What does that do?
21:54:22 <iqubic> What does the Cont monad do?
21:54:36 <dibblego> what do you think it does?
21:54:54 <iqubic> I think it allows for failed computations to continue.
21:55:00 <edwardk> it lets you capture the 'rest of the computation' and call it later, or even multiple times, or skip it entirely supplying your own 'r'.
21:55:21 <iqubic> What does the basic Cont data type look like?
21:55:32 <dibblego> cancel the (r) in the above, that is Cont
21:55:39 <dibblego> er, the (m)
21:55:48 <edwardk> same thing without the m
21:56:01 <iqubic> Data Cont r a = (a -> r) -> r?
21:56:07 <dibblego> yes that'll do
21:56:14 <dibblego> try this
21:56:18 <dibblego> open ghci and type :info Cont
21:56:25 <iqubic> And how does that capture the rest of the Computation?
21:56:33 <dibblego> try this, open ghci and type :info Cont
21:56:44 <iqubic> @index COnt
21:56:44 <lambdabot> bzzt
21:56:47 <iqubic> @index Cont
21:56:47 <lambdabot> Control.Monad.Trans.Cont
21:57:04 <dibblego> tell me when you've got ghci open, then I'll tell you the next thing to do
21:57:56 <iqubic> I got ghci open.
21:58:07 <edwardk> Cont r a represents a computation that knows how to convert (a -> r) will compute an r. it may call your 'continuation' (the (a -> r) argument) any number of times to get useful 'r's, it may ignore it completely.
21:58:19 <dibblego> now type this, import Control.Monad.Cont
21:58:23 <dibblego> press ENTER
21:58:29 <dibblego> after that, type this, :info Cont
21:58:38 <dibblego> then press ENTER again
21:58:41 <edwardk> if you go into a language like javascript and ask yourself, 'how would i program if there wasn't a return keyword' you'd have to pass the function for what to do next as an extra argument to every function
21:58:54 <edwardk> function square(x) { return x*x; } -- would have to become
21:59:09 <edwardk> function square(x, k) { k(x*x); }
21:59:18 <EvanR> unfortunately i dont think iqubic knows javascript
21:59:19 <edwardk> then you'd adapt your coding style accordingly
21:59:23 <edwardk> this is 'continuation passing style'
21:59:25 <sveit> edwardk: just wondering, how did you "know" that my type would fail the monad laws? it fails on the second law because (m >>= k . pure) /= k m, which at first glance seems like a "reasonable" equality to me (and holds for some monads)
21:59:26 <iqubic> dibblego: Cont is defined as ContT with the identity Monad
21:59:30 <EvanR> but thats a good analogy
21:59:42 <iqubic> EvanR: I know the basics of JS
21:59:45 <dibblego> iqubic: Correct! so that answers the question, "what does it (Cont) do?"
22:00:01 <iqubic> dibblego: It does??
22:00:11 <dibblego> iqubic: using :info is an exceptionally useful way to answer questions of the form, "what is it?" or "what does it do?"
22:00:12 <EvanR> i kind of wish CPS worked in javascript
22:00:25 <EvanR> (it will crash with "too much recursion")
22:00:37 <dibblego> iqubic: yes, by being defined with Identity, you can immediately infer that it is the same as ContT with the (m) cancelled
22:00:41 <edwardk> evanr: sure, you get about 1000 stack frames before the stack blows because it doesn't do tail call optimization
22:00:53 <glguy> so make those frames count!
22:01:03 <iqubic> So can I get an example of when ContT would be useful?
22:01:04 <glguy> Write loooooong function bodies
22:01:08 <EvanR> between its callback hell and CPS im not sure CPS is worse
22:01:31 <edwardk> so, just like in scala, don't use it for long running computations, or manually trampoline ;)
22:01:45 <dibblego> or, just don't use scala
22:01:49 <iqubic> It seems that every JS function I've looked at is either a callback funtion, or requires a callback function
22:02:00 <pacak> I wish JS never existed.
22:02:02 <`Guest00000> i have never used the commands :info, :type and :kind in GHCi except trying them once
22:02:13 <edwardk> iqubic: Cont is basically a way to program with callbacks but have it come out in "natural" style.
22:02:24 <iqubic> Some functions are both a callback, and require other callbacks
22:02:40 <iqubic> edwardk: I think I understand. Can I see an example in code?
22:02:43 <`Guest00000> and then using the short forms :i, :t and :k afterwards
22:02:48 <EvanR> because it originally didnt have the notion of threads or coroutines
22:02:57 <EvanR> now it has both, but its stuck with callbacks anyway
22:03:14 <iqubic> What is a coroutine?
22:03:20 <EvanR> another story
22:03:49 <edwardk> iqubic: say you need to wait for a result of a computation from a callback. you can write a Cont(T) action that captures the current continuation and passes it to (or even as) the callback to a function.
22:04:19 <edwardk> "captures the current continuation" is a fancy way of saying, it has direct access to 'k' in the example above as an argument, and can do anything it wants with the function of 'what to do next'
22:04:20 <iqubic> I don't understand
22:05:01 <edwardk> function square(x,return_) { return_(x*x); } --- rather than return x*x; -- 'return_' is a first class object you can do whatever the heck you want to, you can return it, pass it to someone else, etc.
22:05:16 <iqubic> http://www.haskellforall.com/2012/12/the-continuation-monad.html
22:05:23 <iqubic> I see.
22:05:30 <edwardk> iqubic: start there
22:05:58 <`Guest00000> iqubic: coroutine is thing which has "yield" instead of "return", and after you call it you have the result AND the suspended continuation thing, which when called resumes execution immediately after the "yield"
22:05:58 <iqubic> return_ is like the (a -> r) and x*x is like the r
22:06:40 <iqubic> `Guest00000: dose Haskell have anything like that??
22:06:54 <iqubic> Isn't that just Cont(T)?
22:07:05 <edwardk> iqubic: "x*x" is like the 'a' basically
22:07:18 <c_wraith> coroutines are actually more limited than continuations
22:07:34 <iqubic> But what's the (a -> r) the entire square function?
22:08:09 <edwardk> square :: Num a => a -> Cont r a; square x = return (x *x)
22:08:21 <edwardk> the monad takes care of plumbing around 'k' for you
22:08:26 <iqubic> I see.
22:08:38 <iqubic> How do you call that callback function?
22:08:56 <`Guest00000> iqubic: in IO sense, i think it's possible to write; in the pure sense, with purity and laziness, it's just Writer [m]
22:09:21 <`Guest00000> where m is the return type for coroutine
22:09:30 <edwardk> iqubic: you can write your Cont action manually that captures 'k' by using the Cont constructor
22:09:35 <edwardk> or you can bend your brain around
22:09:37 <edwardk> :t Control.Monad.Trans.Cont.callCC
22:09:39 <lambdabot> forall k b a (m :: k -> *) (r :: k). ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
22:09:49 <`Guest00000> foralls make it worse
22:09:57 <iqubic> `Guest00000: I want to learn Cont first. Then other stuff
22:10:07 <`Guest00000> okay
22:10:12 <edwardk> technically foralls make it better, because it needs a rank3 type to be fully correct ;)
22:10:22 <edwardk> the one shown there isn't as good as it could be
22:11:04 <iqubic> That's a rank3 type?? Why?
22:11:37 <iqubic> Finding the rank of a RankN type confuses me.
22:12:02 <edwardk> iqubic: the better version would be rank3
22:12:23 <edwardk> ((forall b. a -> ContT r m b) -> ContT r m a) -> ContT r m a
22:13:01 <edwardk> that lets' you capture the current continuation and use it for any type 'b' you want chosen later on, choosing potentially many times
22:13:24 <edwardk> the type in transformers/mtl is too simple to allow that
22:13:50 <iqubic> Ah.
22:14:04 <iqubic> I like the unitAttack example here: http://www.haskellforall.com/2012/12/the-continuation-monad.html
22:14:53 <iqubic> Where you can supply whatever function you like to run after the unit attack has been successfully done.
22:14:53 <mewop> hi
22:14:57 <sveit> edwardk: sorry to bother you a second time. could you say how you "knew" (what your intuition was) that my wrong ContT would fail the monad laws? thanks for all your help!
22:15:47 <edwardk> sveit: we can't in general do double negation elimination in haskell
22:16:03 <edwardk> and that was a red flag for me
22:16:11 <edwardk> the obvious way to implement join would require it
22:17:10 <edwardk> between that and the understanding of how hom transforms colimits to limits in the first argument, but the fact that that relationship doesn't flip coming back, it looked broken
22:17:47 <edwardk> neither was particularly rigorous, and i'd have been pleasantly surprised to be proven wrong, but i very much didn't expect to be
22:18:54 <edwardk> after playing with the pieces here for a while you get a sense for the ways that they might allow themselves to fit together
22:21:06 <`Guest00000> not having tail call optimization in ANY language sucks
22:21:20 <iqubic> How is ContT different from currying and partial application.
22:21:22 <iqubic> ??
22:21:33 <isd> Hey all. So, it's possible to define Applicative and Functor instances just using >>= and return. Is there an off-the-shelf package that just does that somewhere? would be nice to avoid the boilerplate.
22:21:33 <iqubic> `Guest00000: You must HATE lua then.
22:21:53 <glguy> Lua has tail calls
22:21:53 <pacak> :t ap
22:21:55 <lambdabot> Monad m => m (a -> b) -> m a -> m b
22:22:05 <edwardk> sveit: an example. if you tweak your definition a bit, it becomes forall r. (m a -> r) -> r  -- THAT works, because you can show this is basically Yoneda Identity (m a) which is isomorphic to m a
22:22:05 <iqubic> glguy: No it doesn't
22:22:11 <glguy> Yes it does
22:22:20 <`Guest00000> iqubic: what, does it have tail call anti-optimization?
22:22:27 <pacak> isd: (<*>) = ap, pure = return, fmap = something simple
22:23:01 <iqubic> https://www.lua.org/pil/6.3.html I stand corrected
22:23:18 <edwardk> sveit: the lack of universal quantification is what trips you up here, that provides the distinction between yoneda/codensity/ran style things and cont style things
22:23:22 <isd> Didn't know about app thanks
22:23:22 <iqubic> But Lua arrays are 1-index which is super weird.
22:24:41 <EvanR> N and N+ are isomorphic so we shouldnt care! ?
22:24:58 <edwardk> evanr: yes =)
22:25:02 <EvanR> arrays in haskell could be 1-indexed
22:25:03 <isd> fmap would just be pure f <*> x. But is that the best we can do? I know there are language extensions that make e.g. deriving more powerful. It would be nice not to have to type out the definitions (short though they are) each time
22:25:21 <edwardk> evanr: haskell arrays are ridiculously over-engineered.
22:25:21 <pacak> iqubic: Weird things.... I'm writing one more parser for market data right now. Instead of using increments of 0.01 they use 0.015625, because why not. 1-indexed arrays is not the worst thing ever.
22:25:26 <EvanR> haha
22:25:33 <yushyin> iqubic: afaik lua does not have 'arrays' it’s just a table like structure you can start at 'key' 0 if you like
22:26:10 <glguy> Lua tables have an array portion internally
22:26:11 <iqubic> yushyin: https://www.lua.org/pil/11.1.html
22:26:24 <glguy> Unfortunately Lua is off-topic here
22:26:30 <iqubic> Lua official documents beg to differ
22:26:35 <edwardk> The first thing i do when i go to reach for anything from the array package is stop, slap myself really hard and then decide whether or not to continue with vector or the ones from primitive
22:27:30 <edwardk> if i need slicing, i take vectors, if i don't i use primitive =P
22:27:40 <EvanR> if edk is calling something overengineered... steer clear
22:27:47 <iqubic> edwardk: I used array in a TicTacToe game I made recently. Worked rather well
22:27:48 <edwardk> EvanR: =P
22:28:04 <edwardk> there are exceptions that prove every rule
22:28:14 <glguy> edwardk: I want to elaborate the primitive package to have more of the vector operations, even if they have to copy more often
22:28:36 <edwardk> glguy: i'm pretty sure dolio wouldn't object. he took a crapload of instances for array from me a while back
22:28:54 <iqubic> edwardk: A Vector of Vectors might have been better for my game
22:29:01 <iqubic> edwardk: Are you a GHC programmer
22:29:07 <iqubic> Like you actually work on GHC?
22:29:18 <iqubic> And Haskell base files?
22:29:23 <edwardk> i mostly work on libraries and try to take ghc itself as given
22:29:28 <edwardk> base is one of those libraries
22:29:38 <iqubic> But you work on Base. That's so cool
22:29:43 <pacak> iqubic: He maintains like a half of hackage.
22:29:48 <iqubic> How hard is that?
22:30:02 <iqubic> Half of Hackage is too much Hackage to handle.
22:30:17 <edwardk> iqubic: to be honest? it is a bit of a political nightmare, because everyone has a different opinion on just about anything that affects base
22:30:57 <edwardk> i tend to prefer working on my own libraries because there i can pretty much do whatever i want and the community will adapt. when working on core libraries stuff i try to be a lot more diplomatic and consensus-seeking
22:31:13 <iqubic> What's a Kleisli arrow?
22:31:17 <iqubic> :t >=>
22:31:19 <lambdabot> error: parse error on input ‘>=>’
22:31:21 <iqubic> :t (>=>)
22:31:23 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:31:38 <iqubic> Oh, it's like composition for a monad
22:32:24 <iqubic> @src (>=>)
22:32:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:32:28 <c_wraith> iqubic: Kleisli arrows are exactly equivalent to monads.
22:32:29 <iqubic> Darn it
22:32:40 <edwardk> :t Control.Arrow.Kleisli
22:32:41 <lambdabot> (a -> m b) -> Kleisli m a b
22:32:56 <iqubic> c_wraith: Can you write the implementation for >=> then?
22:34:05 <c_wraith> :t \f g x -> f x >>= g
22:34:07 <lambdabot> Monad m => (t -> m a) -> (a -> m b) -> t -> m b
22:34:25 <pacak> @pl \f g x -> f x >>= g
22:34:25 <lambdabot> flip . ((>>=) .)
22:34:30 <pacak> o_O
22:34:37 * hackage loup 0.0.2 - Amazon Simple Workflow Service Wrapper for Work Pools.  https://hackage.haskell.org/package/loup-0.0.2 (markfine)
22:34:47 <pacak> Ugh.
22:34:55 <iqubic> @pl \x y -> y
22:34:55 <lambdabot> const id
22:35:04 <iqubic> @pl \x y -> x
22:35:04 <lambdabot> const
22:35:05 <sveit> edwardk: thanks a lot! it's going to take me some time to parse the bulk of your explanations, but the double negation comment makes sense.
22:35:08 <iqubic> What?
22:35:30 <iqubic> why is it not suggesting "flip const" for one of those?
22:35:35 <c_wraith> iqubic: for extra fun, think about flip id
22:35:50 <iqubic> :t id
22:35:51 <lambdabot> a -> a
22:35:56 <iqubic> :t flip id
22:35:57 <lambdabot> b -> (b -> c) -> c
22:36:08 <iqubic> What???
22:36:12 <MarcelineVQ> :>
22:36:12 <iqubic> :t flip
22:36:13 <lambdabot> (a -> b -> c) -> b -> a -> c
22:36:41 <iqubic> Id doesn't even fit the signature of a -> b -> c
22:36:48 <iqubic> :t const id
22:36:50 <lambdabot> b -> a -> a
22:36:53 <edwardk> sure it does
22:36:57 <iqubic> :t flip const
22:36:58 <lambdabot> b -> c -> c
22:37:08 <edwardk> a -> (b -> c)     for id to have that type a = b -> c
22:37:08 <nshepperd> :t id :: a -> b -> c
22:37:09 <lambdabot> error:
22:37:10 <lambdabot>     • Couldn't match type ‘a1’ with ‘b1 -> c1’
22:37:10 <lambdabot>       ‘a1’ is a rigid type variable bound by
22:37:22 <iqubic> @check const id == flip const
22:37:24 <lambdabot>  error:
22:37:25 <lambdabot>  • No instance for (Eq (b0 -> a0 -> a0)) arising from a use of ‘==’ (maybe yo...
22:37:47 <iqubic> How do I tell lambabot to do a quickcheck test?
22:37:49 <edwardk> so flip (id :: (b -> c) -> b -> c) :: b -> (b -> c) -> c
22:38:25 <iqubic> @check
22:38:25 <lambdabot>  <unknown>.hs:1:1:Parse error: EOF
22:38:37 <iqubic> @check "a" == "a"
22:38:38 <edwardk> anyways, off to start my day.
22:38:40 <lambdabot>  +++ OK, passed 100 tests.
22:38:41 <edwardk> have fun =)
22:39:23 <iqubic> @check \a -> const id a == flip const a
22:39:26 <lambdabot>  error:
22:39:26 <lambdabot>  • No instance for (Eq (a0 -> a0)) arising from a use of ‘==’ (maybe you have...
22:39:37 <iqubic> Why can't I get that quickcheck test to work?
22:39:47 <pacak> iqubic: You can have a conversation in lambdabot in private.
22:39:54 <glguy> Because of the error message that was printed afterward
22:39:55 <EvanR> you need to come up with better questions
22:39:58 <pacak> There's no Eq instance for functions.
22:40:34 <iqubic> pacak: How would you write that quickcheck test.
22:40:54 <iqubic> I want to check if "flip const == const id"
22:42:12 <nshepperd> two functions are equal if they are equal at every argument
22:42:31 <pacak> You test by applying both functions to some value
22:42:41 <pacak> And compare results
22:42:44 <nshepperd> @check (\(a :: Int) (b :: Int) -> flip const a b == const id a b)
22:42:44 <lambdabot>  <unknown>.hs:1:14:ScopedTypeVariables language extension is not enabled. Ple...
22:42:54 <nshepperd> >:|
22:43:14 <EvanR> alright who wrote <unknown>.hs
22:43:14 <iqubic> @check \a b -> const id a b == flip const a b
22:43:16 <lambdabot>  +++ OK, passed 100 tests.
22:43:17 <nshepperd> lambdabot, Ple...
22:43:26 <iqubic> I got it to work
22:43:28 <iqubic> @check \a b -> const id a b == flip const a b
22:43:31 <lambdabot>  +++ OK, passed 100 tests.
22:43:50 <nshepperd> iqubic: lol, i bet that's default a and b to () though
22:43:56 <EvanR> i was about to say
22:44:05 <nshepperd> @check \a b -> const id a b == const a b
22:44:07 <lambdabot>  +++ OK, passed 100 tests.
22:44:15 <nshepperd> :)
22:44:26 <nshepperd> @check \a b -> a == b
22:44:28 <lambdabot>  +++ OK, passed 100 tests.
22:44:50 <pacak> iqubic: Try to manually expand definitions of flip and const them simplify stuff.
22:44:55 <iqubic> @check \a b -> const id (a+1) (b+2) == flip const (a+1) (b+2)
22:44:57 <lambdabot>  +++ OK, passed 100 tests.
22:45:00 <EvanR> @check \s1 s2 -> read s1 == read s2
22:45:02 <lambdabot>  *** Failed! Exception: 'Prelude.read: no parse' (after 1 test):
22:45:02 <lambdabot>  "" ""
22:45:09 <EvanR> aw
22:45:21 <iqubic> That must have made a and b numbers
22:45:39 <EvanR> read about defaulting
22:45:43 <iqubic> I just had quickcheck add 1 to a and 2 to b
22:45:53 <iqubic> You can't do () + 1
22:45:58 <iqubic> > () + 1
22:46:00 <lambdabot>  error:
22:46:00 <lambdabot>      • No instance for (Num ()) arising from a use of ‘+’
22:46:00 <lambdabot>      • In the expression: () + 1
22:46:10 <iqubic> > () + 2
22:46:11 <EvanR> () isnt a Num
22:46:12 <lambdabot>  error:
22:46:12 <lambdabot>      • No instance for (Num ()) arising from a use of ‘+’
22:46:12 <lambdabot>      • In the expression: () + 2
22:46:19 <iqubic> EvanR: My point exactly
22:46:36 <nshepperd> http://www.alexeyshmalko.com/2014/haskell-defaulting-rules/
22:46:42 <iqubic> If () is not a num, then it is an invalid input for my quickcheck test
22:46:47 <iqubic> @check \a b -> const id (a+1) (b+2) == flip const (a+1) (b+2)
22:46:49 <lambdabot>  +++ OK, passed 100 tests.
22:47:14 <iqubic> It *can't* have defaulted to () there
22:47:28 <EvanR> that seems clear
22:48:05 <iqubic> I used addition to get around the ScopedTypeVariable not being enabled limitation
22:48:38 <nshepperd> @check \a b -> const id a b == flip const (a :: Int) (b :: Int) -- you could just do this too
22:48:40 <lambdabot>  <hint>:1:109: error:
22:48:40 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
22:48:54 <nshepperd> sigh
22:48:56 <iqubic> nshepperd: Apparently you can't
22:49:19 <nshepperd> @check \a b -> const id a b == flip const (a :: Int) (b :: Int)
22:49:21 <lambdabot>  +++ OK, passed 100 tests.
22:49:42 <EvanR> what
22:49:55 <glguy> didn't like the -- comment
22:50:13 <iqubic> Alright, why does const id ignore the first argument?
22:50:39 <iqubic> And how does flip id work?
22:50:42 <iqubic> :t flip id
22:50:43 <lambdabot> b -> (b -> c) -> c
22:50:58 <iqubic> > flip id 1
22:51:00 <lambdabot>  error:
22:51:01 <lambdabot>      • No instance for (Typeable c0)
22:51:01 <lambdabot>          arising from a use of ‘show_M724477383279912043732294’
22:51:05 <EvanR> have you looked at any of these functions code
22:51:09 <iqubic> > flip id 1 (+1)
22:51:11 <lambdabot>  2
22:51:14 <nshepperd> iqubic: write out the definition of const, and apply it to int
22:51:16 <iqubic> What???
22:51:30 <iqubic> How does that work?
22:51:40 <EvanR> > id (+1) 1
22:51:43 <lambdabot>  2
22:51:44 <iqubic> flip id is postfix function application?
22:52:04 <EvanR> id just returns its argument
22:52:16 <iqubic> So what does flip id do?
22:52:24 <EvanR> flip id 1 (+1) = ((flip id) 1) (+1)
22:52:32 <EvanR> you tell me
22:52:38 <iqubic> :t id
22:52:39 <lambdabot> a -> a
22:52:54 <iqubic> You can't flip that. It's only being applied to one thing.
22:53:02 <nshepperd> :t id :: (a -> b) -> (a -> b)
22:53:04 <lambdabot> (a -> b) -> a -> b
22:53:14 <nshepperd> what do you get when you flip that
22:53:25 <EvanR> i can flip it and i will
22:53:26 <iqubic> a -> (a -> b) -> b
22:53:27 <Maxdamantus> id f a = f a; flip id f a = id a f
22:53:51 <iqubic> const a b = b
22:54:02 <iqubic> :t let const a b = b in const
22:54:03 <lambdabot> t1 -> t -> t
22:54:08 <iqubic> :t const
22:54:10 <lambdabot> a -> b -> a
22:54:15 <iqubic> :t let const a b = a in const
22:54:16 <lambdabot> t1 -> t -> t1
22:54:18 <iqubic> There we are
22:54:39 <iqubic> Now let a be id
22:54:48 <iqubic> :t const id
22:54:49 <lambdabot> b -> a -> a
22:55:24 <iqubic> I don't understant const id at all.
22:55:31 <EvanR> think about it a little
22:55:36 <pacak> @src const
22:55:36 <lambdabot> const x _ = x
22:55:38 <pacak> @src id
22:55:38 <lambdabot> id x = x
22:55:51 <EvanR> use the @src command a lot, in a PM
22:55:54 <pacak> const id _unused = id
22:56:18 <iqubic> pacak: That's right.
22:56:39 <iqubic> and then it gets turned into id _unused???
22:57:05 <nshepperd> const id _ x = id x
22:57:11 <nshepperd> const id _ x = x
22:57:14 <nshepperd> tada
22:57:56 <iqubic> const id _ x = (const id _) x = id x = x
22:57:59 <pacak> iqubic: unused stays unused
22:57:59 <iqubic> There we are.
22:58:11 <iqubic> Yeah, I got it.
22:58:45 <iqubic> I didn't realize that forall a b. a -> b -> a meant that a and/or b could be a function
22:58:52 <nshepperd> i wanted to make a pun about iqubic flipping out but we've stopped talking about flip
22:58:57 <EvanR> forall is serious
22:59:03 <EvanR> A -> B is a type sp
22:59:03 <iqubic> It really is.
22:59:07 <EvanR> so*
22:59:16 <EvanR> thats a possible a
22:59:37 <iqubic> It is indeed
23:00:13 <EvanR> also, A -> B -> C is a type
23:00:14 <iqubic> This weird. I like these types of proofs
23:00:31 <EvanR> its -> all the way down
23:00:34 <iqubic> I still find "flip const" easier to read than "const id"
23:00:54 <iqubic> It conveys the meaning of the function a lot better for me
23:01:05 * Axman6 agrees
23:01:38 <iqubic> flip f x y = f y x
23:01:44 <iqubic> Is that correct?
23:01:50 <iqubic> @src flip
23:01:50 <lambdabot> flip f x y = f y x
23:03:32 <iqubic> Thank you all for showing me how weird Haskell can get.
23:03:43 <orion> In general, is it possible to define a function which is polymorphic in its result but monomorphic in its arguments?
23:03:51 <iqubic> However it is 1 in the morning here, so I have to sleep.
23:03:56 <edwardk> :t error
23:03:57 <lambdabot> [Char] -> a
23:04:00 <edwardk> ^- orion
23:04:13 <iqubic> What?
23:04:19 <EvanR> but it has to crash or freeze
23:04:41 <orion> Ah, darn.
23:04:42 <EvanR> it cant extract a value of any type you want from the vacuum
23:04:54 <jdavis> What's the right way to install haskell? Do I install cabal and have that manage everything? Or do I install haskell-platform and let ubuntu manage the packages?
23:05:08 <edwardk> :t forever (putStrLn "hello")
23:05:09 <lambdabot> IO b
23:05:28 <iqubic> :t 
23:05:29 <lambdabot> <no location info>: error: not an expression: ‘’
23:05:31 <EvanR> of course if its some data type, it can work
23:05:33 <EvanR> :t Nothing
23:05:34 <lambdabot> Maybe a
23:05:51 <iqubic> :t \a -> forever (putStrLn a)
23:05:52 <lambdabot> String -> IO b
23:05:58 <iqubic> There we are.
23:06:01 <EvanR> haha
23:06:04 <EvanR> what
23:06:09 <EvanR> oh, String
23:07:08 <iqubic> see also:
23:07:15 <iqubic> :t absurd
23:07:17 <lambdabot> Void -> a
23:07:38 <EvanR> that not only must crash or freeze, it cant even ever run
23:07:48 <iqubic> Why can't that run??
23:07:55 <EvanR> you need to pass it a Void
23:08:40 <iqubic> How can you tell if a ContT continuation has been fully evaluated, and there are no more holes?
23:09:59 <iqubic> :t let run c = runContT c absurd in run
23:10:01 <lambdabot> forall k (r :: k) (m :: k -> *). ContT r m Void -> m r
23:10:13 <iqubic> Stupid foralls
23:10:47 <iqubic> but that only accepts ContT operations with no more callbacks to be performed
23:12:09 <jdavis> I found haskell stack, but it looks like it wants to install as root. Is there a non-superuser way to install haskell stack?
23:13:11 <cocreature> jdavis: you should be able to just manually download it from https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2 and place it somewhere in your path
23:13:20 <cocreature> e.g. ~/.local/bin
23:13:34 <orion> If you need to (en|de)code types to/from JSON, does the information in this article still apply?: http://aaronlevin.ca/post/111871447488/using-dataproxy-to-encode-types-in-your-json
23:13:49 <orion> Or, is there a more modern way of achieving the same result?
23:15:46 <nshepperd> jdavis: normally, I install only ghc and cabal/stack from distro repos, and let cabal/stack manage the rest
23:18:56 <nshepperd> orion: mempty is 'monomorphic' in its arguments, if you don't consider typeclass dictionaries as arguments
23:20:54 <jdavis> nshepperd: thanks, I'll do that.
23:28:10 <EvanR> > let (x, y) = (y+1, 2) in (x,y)
23:28:12 <lambdabot>  (3,2)
23:28:15 <EvanR> nice
23:28:52 <Cale> > let (evens, odds) = (0 : map (+1) odds, map (+1) evens) in (take 5 evens, take 5 odds)
23:28:54 <lambdabot>  ([0,2,4,6,8],[1,3,5,7,9])
23:29:34 <EvanR> stupid haskell tricks
23:30:44 <u-ou> heh
23:30:52 <cocreature> tie all the knots
23:31:53 <Maxdamantus> Write it properly. Stop being lazy.
23:32:16 <Cale> @let loeb x = xs where xs = fmap ($ x) xs
23:32:17 <lambdabot>  .L.hs:167:14: error:
23:32:17 <lambdabot>      • Occurs check: cannot construct the infinite type: b ~ a -> b
23:32:17 <lambdabot>        Expected type: f (a -> b)
23:32:37 <Cale> @let loeb x = xs where xs = fmap ($ xs) x
23:32:38 <lambdabot>  Defined.
23:32:40 <Cale> oops :)
23:33:57 <Cale> > loeb [const 10, length, liftA2 (+) (!! 0) (!! 1)]
23:33:59 <lambdabot>  [10,3,13]
23:34:19 <SepakoRayl> yo
23:34:24 <Cale> hey
23:36:21 <SepakoRayl> I was thinking
23:36:39 <SepakoRayl> ViewPatters allow us to cal functions in patterns
23:36:44 <orion> nshepperd: Are you saying that if you have a typeclass restriction on a function, you can meaningfully do something like foo :: Foo a => String -> Bar a?
23:36:53 <SepakoRayl> and PatternSynonyms require patterns
23:38:10 <SepakoRayl> is it possible to mix these two so that I can write "constructor patterns" so that I can pattern match wrapper types without wrapping/unwrapping them ?
23:39:22 <SepakoRayl> it seems doable but I can't quite write the type class / instances without getting ambiguity warnings
23:39:24 <cocreature> SepakoRayl: it is! take a look at the Seq example https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms#Uni-directionalpattern-onlysynonyms
23:39:51 <cocreature> wait typeclass instances? what do ViewPatterns and PatternSynonyms have to do with typeclass instances?
23:41:28 <nshepperd> orion: sure
23:44:21 <SepakoRayl> I have a parameterized data type, which is intended to be wrapped in newtypes. I would like to write constructor patterns that would use a typeclass' wrap/unwrap  functions so that I can reuse them for all newtypes.
23:45:46 <cocreature> SepakoRayl: I’m not sure how you expect this to work. how would GHC know which newtype you want if you pattern match?
23:47:27 <glguy> pattern synonyms, view patterns, type classes
23:48:02 <SepakoRayl> give me a minute
23:54:03 <LiaoTao> 1
23:54:07 <LiaoTao> Whoops
23:54:09 <cocreature> 2
23:54:20 <EvanR> 4
23:55:26 <butterthebuddha> Urggh I still can't figure this one out (problem 9 https://wiki.haskell.org/99_questions/1_to_10) and it's making my head hurt
23:56:26 <cocreature> butterthebuddha: do you already have some code that we can look at?
23:56:29 <LiaoTao> You're allowed to use Prelude functions?
23:56:47 <cocreature> that exercise makes little sense if you’re allowed to use Prelude functions :)
23:56:53 <butterthebuddha> https://pastebin.com/9txGmWDP
23:57:03 <LiaoTao> Well maybe it's to familiarize yourself with Prelude
23:57:06 <LiaoTao> :)
23:57:07 <Axman6> butterthebuddha: can you writer a function of type: groupOne :: Eq a => a -> [a] -> ([a],[a]) which takes all the values equal to the first argument from the front of the list?
23:57:18 <cocreature> actually it’s not even in the Prelude. you need to import Data.List
23:57:43 <Axman6> (actually, that type isn't as great as it could be)
23:59:00 <Axman6> butterthebuddha: I would definitely be splitting this into two functions though - one which takes as many values as it can which are equal to a certain value, and another which calls that on the rest of the list until it is empty
23:59:34 <Axman6> trying to make it work using a single function can be done, but it's easier if you split it into smaller pieces
