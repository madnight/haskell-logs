00:00:00 <EvanR> debuggers proper, arent these really only used in C
00:00:06 <EvanR> if at all
00:00:30 <Lokathor> EvanR, C, C++, Java, C#
00:00:31 <Lokathor> possibly more
00:00:37 <EvanR> actually ghci has this built in debugger which never gets any mention
00:00:44 <Lokathor> cocreature, https://www.reddit.com/r/roguelikedev/comments/6evu5c/what_engine_do_you_use_and_why/didz7gc/
00:01:02 <Lokathor> EvanR, yeah but that's not really quite like the "set a break point" debugging most people think of, as i recall
00:01:43 <EvanR> it actually is
00:02:16 <Lokathor> hmm
00:02:59 <Lokathor> oh my
00:03:02 <Lokathor> how nice
00:07:12 <Lokathor> https://hackage.haskell.org/package/derive-storable-0.1.0.6/docs/Foreign-Storable-Generic.html so I've never used Generics before. Does this module let me just put Storable into the derive list of a thing and it all works out?
00:09:04 <cocreature> Lokathor: the readme has an example https://github.com/mkloczko/derive-storable/
00:09:52 <Lokathor> dag, i think my data type doesn't qualify
00:10:08 <Lokathor> oh it does!
00:10:20 <Lokathor> GLFW.Window is Generic
00:10:45 <Lokathor> oh, but it's not got the best performance anyway
00:10:46 <Lokathor> oh well
00:12:27 <EvanR> youre going to Store a GLFW Window?
00:13:12 <Lokathor> it was not the plan to store them between program runs
00:13:17 <Lokathor> that part is foolish, obviously
00:13:58 <EvanR> GLFWindow is an opaque object
00:14:25 <EvanR> even in C it would be foolish, even without restarting the program
00:14:47 <Lokathor> yeah but i bet internally the Haskell value you have is just some pointer bytes that we could serialize and deserialize just fine
00:15:16 <EvanR> the haskell value has a Ptr which is that GLFWindow which is a pointer
00:15:27 <EvanR> probably not expecting to store the pointer itself
00:15:34 <Lokathor> EvanR, right now the entire set of program state is behind an MVar, but since OGL and GLFW don't do mult-threaded that well in the first place, i was considering dropping threadding support within the graphics and storing it all in a Ptr
00:16:12 <EvanR> why ?
00:16:46 <EvanR> and "store things in a Ptr" sounds wrong
00:16:48 <Lokathor> to make it so that instead of supporting just IO callbacks it supports Hexes callbacks, I need to do some juggling between GLFW and Hexes
00:17:37 <EvanR> doesnt compute
00:17:40 <Lokathor> https://github.com/Lokathor/hexes/blob/master/src/Hexes/Internal/GLFW.hs#L111
00:19:48 <cocreature> Lokathor: if you can make a MonadBaseControl instance for Hexes, you can use https://hackage.haskell.org/package/lifted-base-0.2.3.11/docs/Control-Exception-Lifted.html#v:bracket
00:21:06 <Lokathor> I'm not concerned about exceptions so much, I'm concerned about the callback that you set being able to access the latest data when it does run. So a reference of some form is needed, MVar, IORef, Ptr, etc
00:21:28 <Lokathor> though i will look into the monad base control thing, i've heard of this before
00:21:41 <cocreature> it’s a rabbit hole that you might not want to go down :)
00:22:06 <Lokathor> someone wrote it for me when i did a concurrent console lib, let me use lifted async
00:22:08 <Lokathor> it was nifty
00:22:57 <EvanR> i think MonadBaseControl is the last bastion of transformer devices before you swear off all transformers
00:23:09 <cocreature> using the lifted-* packages is pretty reasonable. using monad-control itself (which is the library behind the lifted-* packages) is … weird?
00:23:10 <Lokathor> !!!
00:23:15 <Lokathor> it was you cocreature !!
00:23:18 <Lokathor> you wrote it!
00:23:22 <cocreature> Lokathor: I did?
00:23:25 <Lokathor> https://github.com/Lokathor/galaxy-break/blob/master/src/ConcurrentConsole.hs#L60
00:23:41 <cocreature> huh, I don’t even remember that
00:23:55 <Lokathor> the commit says i last touched the files in Feb
00:24:19 <Lokathor> i gave up on that lib because when i looked into how to make it run on linux things seemed to get insane fast
00:24:57 <cocreature> Lokathor: it seems somewhat similar to https://hackage.haskell.org/package/concurrent-output
00:25:17 <Lokathor> oh, yeah, i remember seeing this gif before
00:25:28 <Lokathor> but this package is unix only :P
00:25:44 <cocreature> heh, I’m sure they wouldn’t mind a PR adding windows-support :)
00:26:28 <Lokathor> the hardest part is reading 1 character of input at a time
00:27:03 <Lokathor> you have to activate special terminal modes, the details of which are system dependent and annoying
00:27:31 <Lokathor> anyway, Hexes will hopefully be a fully cross platform and fully useful IO system
00:27:48 <EvanR> 1 character of input at a time?
00:28:20 <EvanR> that might be why its hard, because you dont get characters necessarily
00:28:21 <Lokathor> EvanR, under normal operations the process doesn't get data one character at a time, the console system buffers it up and doesn't send it to your process until the user hits enter
00:28:22 <cocreature> can’t you just turn of all buffering and then you get 1 character at a time?
00:28:44 <EvanR> i mean, in a terminal, you get a sequence of control codes
00:28:53 <cocreature> i.e. hSetBuffering stdin NoBuffering
00:28:54 <ongy> it requires some terminal sepcific control stuff, but I think libterminfo was made exactly to do that
00:29:13 <Lokathor> cocreature, that does not do it ;P trust me I tried that one
00:29:20 <ongy> it's not in the buffers inside your application, but everything outside
00:29:24 <cocreature> Lokathor: hm okay
00:29:25 <Lokathor> yeah
00:29:48 <Lokathor> cocreature, the terminal process itself literally won't give the data to your process until the user presses enter without a special mode set
00:30:02 <Lokathor> so you just see a blank stdin the whole time
00:30:21 <EvanR> hGet stdin 1
00:30:32 <EvanR> yeah and that
00:30:44 <laserpants> Is there no Hashable instance for Text?
00:30:45 <Lokathor> EvanR, regarding the "not always a character" stuff, that too. I was reading key events and then extracting the ascii info
00:30:49 <EvanR> and once you activate that mode, you arent just getting Chars or even Ascii
00:31:38 <cocreature> laserpants: the haddocks show an instance for both lazy and strict Text, what makes you think there is none?
00:31:45 <EvanR> i assume you tried curses and hated it
00:31:53 <Lokathor> EvanR, right, what you're getting on windows is INPUT_RECORD values :3
00:32:16 <Lokathor> EvanR, I tried valiantly to make curses work on windows, but it doesn't seem to want to work with cmd.exe (perhaps cygwin, but i didn't consider that too viable)
00:32:35 <laserpants> cocreature: I am getting an error     No instance for (Hashable Text) arising from a use of ‘M.member’ .. but I think there is something weird going on in my code.
00:32:38 <EvanR> windows is the new hairshirt platform
00:33:13 <Lokathor> EvanR, if you're willing to abstract over using curses on linux and then ansi-terminal and Win32 native calls on windows, you could make a nifty deal maybe
00:33:19 <Lokathor> I decided to go with GLFW+OpenGL
00:33:30 <EvanR> probably for the best
00:33:38 <Lokathor> https://github.com/Lokathor/galaxy-break/blob/master/src/ConcurrentConsole/Win32.hs#L50
00:33:56 <cocreature> laserpants: some minimal example would be helpful but you can try to import "Data.Hashable". maybe the instance is not in scope for some weird reason
00:34:08 <cocreature> which should be impossible since this is not an orphan instance but you never know
00:35:34 <Lokathor> EvanR, oh it accepts input by the way! It's "interactive", in that if you press a key it'll repeat that key's glyph across the whole grid. while also pulsing eye shattering colors the whole time
00:36:38 <EvanR> jelly
00:36:47 <cocreature> Lokathor: do you have some kind of demo of hexes?
00:37:24 <Lokathor> yes, the repo is up to date at the moment, https://github.com/Lokathor/hexes 
00:37:31 <Lokathor> stack build && stack exec demo
00:37:49 <Lokathor> feel free to open up Main.hs and make the colors not eye shattering before you run it :P
00:37:55 * cocreature starts building
00:39:07 <cocreature> Lokathor: btw you already depend on "lens" transitively so using microlens doesn’t actually decrease your dependency footprint. it increases it
00:39:16 <Lokathor> oh no!
00:39:29 <Lokathor> do i? I suppose edk uses lens in gl or something
00:39:33 <Lokathor> i'll move that around i guess
00:40:13 <cocreature> that seems to be the case for a lot of packages that use microlens. they try to stay small and forget that they already depend transitively on lens
00:40:17 <laserpants> cocreature: It happens when I do this: `data X = X { y :: M.HashMap Text Text }; let x = X M.empty; M.member "v" (y x)`
00:40:37 <cocreature> laserpants: in ghci? otherwise that’s a syntax error
00:40:47 <cocreature> laserpants: also how did you import M
00:40:52 <laserpants> yes in the repl
00:40:59 <cocreature> and which version of hashable are you using
00:41:05 <laserpants> `import qualified Data.HashMap.Strict as M`
00:41:31 <cocreature> Lokathor: you’re ignoring my keyboard layout! :)
00:41:56 <Lokathor> I'm accepting a GLFW key value and switching on that
00:41:59 <laserpants> cocreature: I think I'll start a fresh sandbox and try from there maybe
00:42:03 <Lokathor> if GLFW doesn't report properly I can't do much about it :/
00:42:24 <EvanR> Lokathor: in these toolkits, theres a distinction between keyboard key and the letters someones trying to type
00:42:38 <cocreature> the former is sometimes called “keycode”
00:42:41 <EvanR> even to the point of 'a' vs 'A' (shift-a)
00:42:45 <Lokathor> right, i'm not using scancode
00:42:57 <EvanR> scancode is even more raw
00:42:58 <Lokathor> well, i am ignoring modifier keys
00:43:06 <EvanR> you dont have to worry about modifiers
00:43:20 <EvanR> theres a way to detect what text they are trying to type
00:43:25 <Lokathor> https://hackage.haskell.org/package/GLFW-b-1.4.8.1/docs/Graphics-UI-GLFW.html#t:Key this type
00:43:32 <Lokathor> oh, yes, i could also use that callback instead
00:44:09 <Lokathor> setKeyCallback vs setCharCallback
00:44:23 <EvanR> GLFW setCharCallback
00:44:30 <Lokathor> yeah
00:44:46 <EvanR> http://www.glfw.org/docs/latest/input_guide.html#input_char
00:45:10 <Lokathor> yes I know :P I actually added all of the docs in their latest pull request myself :P
00:45:26 <EvanR> in more fully featured toolkits it also hooks into input methods which can be used to type chinese, etc
00:45:35 <EvanR> incredibly useful for rogue likes
00:46:10 <Lokathor> you mean more featured than GLFW?
00:46:55 <EvanR> yes
00:47:14 <Lokathor> ah, can't be helped i guess
01:13:11 <EvanR> im parsing through extensive, adhocly formatted server logs generated by java
01:13:55 <EvanR> with haskell. its going pretty good, but i realize... man ive never seen so much error log info from haskell ;)
01:14:37 <EvanR> doesnt support it, doesnt crash you be the judge
01:17:12 <Lokathor> > undefined :: Int
01:17:14 <lambdabot>  *Exception: Prelude.undefined
01:17:24 <Lokathor> yep, short error messages indeed
01:32:09 <EvanR> Lokathor: error, undefined is an Int
01:32:28 <EvanR> as opposed to "not a function" js message
01:34:53 <Lokathor> what I love is when you have an error in your event handling code in swing
01:35:17 <Lokathor> because swing does a thing so that the swing thread doesn't die, and so it keeps taking in events, crashing out with error messages, over and over
01:49:56 <EvanR> uhg
01:57:39 <Lokathor> OR
01:57:45 <Lokathor> maybe it was just because Eclipse did some magic
01:57:49 <Lokathor> who's to say?
02:07:11 * hackage utility-ht 0.0.14 - Various small helper functions for Lists, Maybes, Tuples, Functions  https://hackage.haskell.org/package/utility-ht-0.0.14 (HenningThielemann)
02:08:38 * hackage explicit-exception 0.1.9 - Exceptions which are explicit in the type signature.  https://hackage.haskell.org/package/explicit-exception-0.1.9 (HenningThielemann)
02:10:54 * hackage xml-basic 0.1.2, tagchup 0.4.1 (HenningThielemann): https://qbin.io/530iqix
02:48:38 * hackage haskell-gi-base 0.20.3 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.20.3 (inaki)
02:48:50 <ph88^> i'm trying to use Data.Conduit.Lift.runStateC but i can't get it quite right, could someone take a look?  https://bpaste.net/show/7e3b2623c6d8
03:02:13 * hackage haskell-gi 0.20.2 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.20.2 (inaki)
03:04:38 <cocreature> ph88: are Time and Value type synonyms for Double?
03:04:52 <cocreature> otherwise the type signatures you are showing us at the top don’t make any sense
04:02:25 <kuribas> @hoogle (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
04:02:26 <lambdabot> Data.Tuple.Lazy zipWithPair :: (a -> c -> e, b -> d -> f) -> (a, b) -> (c, d) -> (e, f)
04:02:26 <lambdabot> Data.Tuple.Strict zipWithPair :: (a -> c -> e, b -> d -> f) -> (a, b) -> (c, d) -> (e, f)
04:02:26 <lambdabot> Control.Compose (***#) :: (a -> b -> c) -> (a' -> b' -> c') -> (a, a') -> (b, b') -> (c, c')
04:08:49 <slack1256> reading about the IO manager, why do we implement blocking call on top of non blocking ones? the whole rts seems to be non-blocking
04:10:39 * hackage beeminder-api 1.0 - Bindings to the beeminder.com JSON API  https://hackage.haskell.org/package/beeminder-api-1.0 (RobinGreen)
04:11:02 <Gurkenglas> lens should have zipWithOf for the just hoogled case.
04:11:14 <int-e> slack1256: not sure what your question is; what would you do instead?
04:11:54 <cocreature> slack1256: note that the rts takes care of running other haskell threads while one thread is blocking
04:12:23 <cocreature> so you get the simplicity of working with blocking IO without the downside of actually blocking other things from happening
04:12:57 <Gurkenglas> And Data.Distributive should implement zipWith because that's safe but afaic requires partial functions to implement. Also should have instances for tuples like Each does.
04:16:40 <slack1256> cocreature: I just know well haskell , what does it happen in other languages? On C i think that If I got two thread and one block on IO, the other keeps running, same as haskell
04:16:57 <slack1256> or is it because C threads are at kernel level and haskell ones are usermode or green ones?
04:28:51 <sternmull> slack1256: Yes, its about "heavy weight" kernel level threads and lightweight user mode threads. You shouldn't start hundreds of threads in C (takes much memory and puts pressure on the scheduler) but you can launch hundreds of threads in haskell without such problems because the rts knows how to efficiently schedule between them and map their activities to a sensible number of native threads.
04:29:14 <cocreature> switching between OS threads is also more expensive than switching between user mode threads
04:31:08 <c_wraith> I think when the new IO manager was being written, they tested with hundreds of thousands of sleeping threads.  (Then a short time after it was tweaked to work better with hundreds of threads performing heavy IO as well)
04:31:38 * hackage nice-html 0.1.0.0 - A fast and nice HTML templating library with distinct compilation/rendering phases.  https://hackage.haskell.org/package/nice-html-0.1.0.0 (MikeLedger)
04:45:26 <ph88^> i'm trying to use Data.Conduit.Lift.runStateC but i can't get it quite right, could someone take a look?  https://bpaste.net/show/7e3b2623c6d8
04:45:38 * hackage hoggl 0.2.0.0 - Bindings to the Toggl.com REST API  https://hackage.haskell.org/package/hoggl-0.2.0.0 (RobinGreen)
04:46:21 <ertes> i have applications with hundreds of thousands of threads that run smoothly
04:47:02 <capisce> simultaneously?
04:48:15 <ertes> depending on the application i would expect between 0.1%-10% of them to be awake at the same time…  the rest is waiting for data from an FD, or for an MVar, or for a timer, or for an STM transaction
04:49:20 <ertes> and BTW, i have to say it again:  the 'concurrent-machines' library has been very useful yesterday…  i'll certainly use it again =)
04:50:03 <capisce> is that more efficient than using epoll / kqueue?
04:50:49 <capisce> I guess the majority aren't waiting on FDs
04:58:00 <c_wraith> capisce: and the ones that are waiting on FDs are using epoll/kqueue
04:59:32 <ugophill> hi
05:00:09 <c_wraith> Hello
05:00:38 <ugophill> i need help with a swf dump someone can?
05:00:58 <c_wraith> is that a haskell question?
05:01:31 <ugophill> maybe security is a better channel for ask...
05:04:38 <ertes> capisce: it *is* epoll/kqueue
05:04:56 <ertes> capisce: and the ones that aren't are handled by the RTS itself
05:06:58 <ertes> capisce: you know the old saying: "the compiler probably writes better assembly code than you"…  i believe that the same is true for memory management, concurrency and parallelism – most of the time
05:07:09 <capisce> ertes: great :)
05:22:21 <mikeplus64> is there anything for servant equivalent to yesod-auth's GoogleEmail2? it's so painfully easy to integrate auth into a yesod app -- but i'd really like to use servant for every other reason
05:32:38 * hackage stm-lifted 0.1.1.0 - Software Transactional Memory lifted to MonadIO  https://hackage.haskell.org/package/stm-lifted-0.1.1.0 (MaksymilianOwsianny)
05:34:42 <ph88^> ertes, what are you doing with concurrent machines? and what are they?
05:48:54 <ertes> ph88^: you know stream processing abstractions like conduit and pipes?
05:49:21 <ertes> those where stream processors are first-class values
05:53:17 <cocreature> ph88^: you still haven’t answered my earlier question of whether Time and Value are type synonyms for Double but assuming that’s true you probably want something like https://gist.github.com/cocreature/bfb8bb2e6e74e1023cfd1c9964fcdbd7 instead of runStateC
05:57:38 * hackage sort 1.0.0.0 - A Haskell sorting toolkit  https://hackage.haskell.org/package/sort-1.0.0.0 (ChrisDornan)
05:58:05 <cocreature> ertes: concurrent-machines does look cool, I guess I need to look deeper into machines at some point
05:59:28 <ertes> cocreature: yeah, i have switched to it for all new applications (from pipes)
06:00:00 <cocreature> ertes: what’s are the main benefits over pipes for you?
06:01:21 <ertes> cocreature: for me personally it just resonates with me as a 'free' user…  there is an explicit split between church-encoded stream processors and algebraically encoded composition, so it's very easy to reason about efficiency, even with nested loops
06:01:40 <ertes> cocreature: there are also some more advanced features like multiplexing, but i don't really use those myself
06:02:14 <ertes> PlanT is to MachineT what FT is to FreeT
06:03:04 <cocreature> okay, thanks
06:06:58 <ertes> in contrast most of the efficiency of 'pipes' comes from clever rewrite rules (rewriting composition to 'for', etc.), which to me is always a minus, if there is a way to do it by construction…  and it doesn't always work out: sometimes there will be an extra cost to having inner loops
06:07:50 <cocreature> yeah it just hasn’t been a problem for me in practise so I’ve been lazy and haven’t really looked at machines :)
06:09:00 <ertes> another feature of machines is: nice error messages =)
06:09:19 <cocreature> error messages for what?
06:09:31 <ertes> i can never remember the order of all those Proxy arguments
06:09:48 <cocreature> ah, I’ve actually remembered them by now :)
06:09:59 <ertes> heh
06:10:53 <ertes> i've never used the upstream communication stuff that pipes has, so it's really just unnecessary complexity…  and if i ever do need it, i'll most likely use 'free' instead
06:10:54 <cocreature> it’s not too bad a comes before b and the ' version comes before the non-' version. and the non-' version is the one that you use if you don’t use the bidirectional features
06:15:20 <sproingie> meaningful argument names, what a thought
06:15:30 <ertes> sure…  i'm actually used to lots of type arguments (type-level records would be nice for these cases)
06:16:13 <cocreature> sproingie: I don’t see how you would give them meaningful names here. sure you could use them in the type synonym but that still wouldn’t help in error messages
06:17:28 <sproingie> i've always wondered how hard it would really be for compiler messages to use the synonym
06:17:51 <ezyang> osa1 had a patch to do this but it had some perf problems 
06:17:58 <sproingie> at runtime?
06:18:00 <ezyang> I think he fixed it but it may have fallen off the wagon 
06:18:04 <ezyang> compiler perf 
06:18:09 <ertes> Proxy up-send down-recv up-recv down-send m r
06:19:19 <cocreature> it would be cool if one could use custom type errors on unification errors
06:19:33 <ertes> aren't they working on something?
06:19:39 <cocreature> currently you can only use them in type families and type classes iirc
06:19:53 <cocreature> so using them in pipes seems hard
06:22:45 <sproingie> newtypes work pretty well for friendlier errors, but that makes the source itself less friendly
06:25:54 <ertes> yeah, some libraries would lose a lot of their appeal, if they switched to newtypes, not to mention the extra implementation cost for deriving/rewriting all the instances
06:25:59 <ertes> most notably lens
06:26:29 <sproingie> yah, it seems more useful for encapsulating a Monad Stack Of Doom, as someone suggested to me earlier
06:26:34 <`Guest00000> why doesn't Data.ByteString.Lazy export hGetContentsN but exports hGetContents?
06:26:56 <`Guest00000> where hGetContentsN sets chunk size
06:28:27 <ertes> `Guest00000: you should probably use stream processing instead of lazy input
06:29:08 <`Guest00000> ertes: why?
06:29:17 <ertes> `Guest00000: since that's available and usually a better choice, there doesn't seem to be much of a need for an extended lazy input API
06:29:38 * hackage nice-html 0.1.1 - A fast and nice HTML templating library with distinct compilation/rendering phases.  https://hackage.haskell.org/package/nice-html-0.1.1 (MikeLedger)
06:30:00 <`Guest00000> ertes: but what if i want simplicity?
06:30:08 <ertes> `Guest00000: because lazy input is problematic: resource usage, including the underlying FD, is bound to garbage-collection, and there is no predictable way to handle errors
06:30:22 <ertes> `Guest00000: stream processing *is* simple…  just try it =)
06:30:23 <sproingie> lazy input is only simple until it isn't
06:30:42 <sproingie> space leaks are not always simple things to find
06:30:58 <ertes> `Guest00000: (despite what i said earlier) i recommend that you give the 'pipes' library a shot
06:31:19 <ertes> `Guest00000: https://hackage.haskell.org/package/pipes-4.3.4/docs/Pipes-Tutorial.html
06:33:25 <ertes> `Guest00000: the 'hGetSome' function does exactly what you want: https://hackage.haskell.org/package/pipes-bytestring-2.1.4/docs/Pipes-ByteString.html#v:hGetSome
06:38:11 <`Guest00000> too complex
06:38:30 <`Guest00000> i don't mean simple to use
06:38:39 <`Guest00000> although that's good
06:38:44 <`Guest00000> i mean simple in itself
06:39:41 <ertes> `Guest00000: you mean conceptual complexity?
06:39:59 <`Guest00000> probably
06:40:33 <ertes> `Guest00000: it's the kind of complexity that is there anyway, but that you swipe under the rug when you use lazy input…  i strongly suggest that you learn it anyway
06:41:01 <`Guest00000> i may learn it sooner or later
06:41:05 <`Guest00000> but i need this right now
06:41:15 <ertes> `Guest00000: if you tell me what languages you're already familiar with, i can probably tell you what the concept is in its terms…  you might find that useful
06:55:32 <mbw> Hello everybody, after reporting a possible gi-gtk bug yesterday, the author asked me to check out if his fix worked https://github.com/haskell-gi/haskell-gi/issues/104 . However, I'm new. I guess I have to git clone, and then use cabal sandbox init or something. Is there a way to do this with stack, via an external dependency or something? I don't see a stack.yaml.
06:56:07 <sproingie> mbw: clone it then stack init
06:56:14 <ertes> mbw: clone it, switch to the directory, type:  cabal sandbox init && cabal install
06:56:33 <mbw> Now I have to choose!
06:57:04 <sproingie> cabal sandbox will do fine for that too
06:57:36 <sproingie> ends up doing pretty much the same thing
06:58:02 <mbw> So stack init is just some kind of convencience wrapper?
06:58:39 <ertes> mbw: cabal-install and stack are competing solutions…  if in doubt, flip a coin
06:58:40 <sproingie> stack is itself a wrapper over cabal when it comes to builds.  does its own dependency solving afiak
07:00:00 <mbw> I usually use stack, but I feel like I really have to stop procrastinating and learn cabal as well...
07:00:12 <mbw> But I'm lazy...
07:00:27 <sphinxo> mbw: why might you also need to learn cabal when you have stack?
07:00:33 <ertes> mbw: cabal-install is a simpler tool, which comes at the expense of not having some of stack's features
07:00:34 <fnurglewitz> haskell is lazy too
07:00:44 <sproingie> sphinxo: you can't use stack without cabal
07:01:02 <ertes> mbw: cabal-install does have some features of its own like that it's not inherently project-bound
07:01:08 <mbw> sphinxo: Also, sometimes you get cabal backend errors.
07:01:21 <sphinxo> ahh
07:01:27 <sproingie> stack install outside of any project is global as well
07:01:27 <ertes> mbw: and note that there is a difference between cabal and cabal-install…  the latter is the command line utility
07:01:32 <ertes> both cabal-install and stack use cabal
07:01:39 <sphinxo> I look forward to never having to deal with those
07:01:55 <sproingie> if you never build software, you'll never have to use them
07:01:57 <cocreature> the new-build stuff in cabal is actually pretty good
07:02:04 <ertes> does stack actually require cabal-install?
07:02:09 <cocreature> no
07:02:14 <ertes> thought so
07:02:14 <sproingie> nope.  does require cabal itself tho
07:02:17 <cocreature> it can use it but it’s optional
07:02:24 <ertes> yeah, it really should require cabal =)
07:02:49 * ertes has never used stack
07:03:30 <mbw> It's ok to be oldschool.
07:03:41 <ertes> mbw: i'm not old-school…  i use nix
07:03:50 <ertes> another competing solution =)
07:03:59 <mbw> yay
07:04:06 <mbw> We definitely need more of those :)
07:04:15 <sproingie> more complementary than competing
07:04:30 <ertes> sproingie: nix definitely competes with both cabal-install and stack
07:05:01 <sproingie> stack can make use of nix
07:05:17 <sproingie> nix on osx is not very smooth.  and nonexistent on windows.
07:05:26 <ertes> yes, but that's not really "nix for haskell"…  it's "stack with nix for some extra stuff"
07:05:42 <cocreature> real programmers just use makefiles
07:05:49 <ertes> yeah, sure…  on windows i'd probably use cabal-install
07:06:07 <mbw> I feel xkcd jokes incoming
07:06:12 <byorgey> real programmers just stare at the naked hard drive until the bits conform to their will
07:06:33 <sproingie> ah, that's what i've been doing these last few years
07:07:04 <ertes> cabal-install's new-build brings many of nix' features to cabal-install…  but i haven't really tried it yet
07:10:54 <mbw> Ok, stack init does not work.
07:11:51 <cocreature> “does not work” is not a sufficient description if you expect people to help you
07:13:39 <mbw> You're correct. It's missing some dependencies: basic-prelude, gi-gst, gi-webkit2. I tried stack init --solver and stack init --resolver=nightly-2017-06-02 as well. Now I'm going to try the cabal commands
07:23:50 <mbw> Btw do people usually specify a "j=x" argument when building projects, or can that result in ghc using too much memory?
07:24:57 <mbw> Since from my experience it uses about 1GB when using a single core, at least that's what I saw more than once.
07:26:16 <mbw> Ok now I think I do need help: cabal: Error: some packages failed to install:
07:26:17 <mbw> haskell-gi-0.20.2 depends on pretty-show-1.6.12 which failed to install.
07:26:17 <mbw> pretty-show-1.6.12 failed during the configure step. The exception was:
07:26:33 <mbw> ExitFailure 1
07:29:44 <mbw> pretty-show _might_ not be needed for me, since I think I read before from the stack output that gi-gst is needed for the examples. Unfortunately I don't see a configuration flag that lets me not build this.
07:30:35 <sproingie> wonder why pretty-show isn't working
07:31:14 <ph88^> cocreature, i didn't see your question. Maybe i was not highlighted or i was not logged onto irc with this client (i'm also logged in on another computer)
07:31:22 <mbw> Running cabal install again, it appears that I need to install "happy".
07:32:17 <mbw> Ok, stack install happy did the trick.
07:33:46 <ph88^> cocreature, Time and Value are Doubles ye. Thanks for the code. Why would that code work and the idea i had with runStateC doesn't work? I find that ghc tells me other types than the documentation so i don't know why that is different :(
07:36:58 <cocreature> ph88^: it doesn’t tell you other types than the docs. I think you confused Conduit and ConduitM. Conduit is just a type synonym for ConduitM which sets the last parameter to () and for some reason switches the order of the type parameters
07:37:28 <sproingie> for further currying perhaps
07:37:31 <`Guest00000> i just need a serialization library which can start returning a value before processing whole input with a simple API like Binary
07:37:42 <cocreature> sproingie: you can’t partially apply type synonyms
07:38:14 <sproingie> cocreature: oh yah ... ¯\_(ツ)_/¯ 
07:38:29 <cocreature> I have no idea what the purpose of that type synonym even is
07:38:36 <cocreature> the name is weird since it’s just as monadic as ConduitM
07:38:38 <sproingie> possibly it was the original type
07:38:46 <sproingie> and remains for compatibility?
07:38:46 <cocreature> and reordering the type parameters is really confusing
07:38:54 <cocreature> ah I guess that could be it
07:39:28 <ph88^> cocreature, why do i get () as first element of the tuple ((), myState) when i use runStateC ? according to the docs  r  should go there, why is r () ?    runStateC :: Monad m => s -> ConduitM i o (StateT s m) r -> ConduitM i o m (r, s)
07:41:01 <cocreature> ph88^: Conduit is a type synonym for ConduitM which sets r to () so if the evalC version has type Conduit … r is ()
07:41:19 <ph88^> hhmm ok
07:41:31 <jchia_1> c_wraith: Thanks for your help with this 2 weeks ago: http://lpaste.net/355704. I think I've figured out how to get the answer using the 'holes' approach.
07:41:44 <mbw> Now after having installed the library, how can I proceed and test my previously crashy example with it? Since with the cabal sandbox it should be installed lokally, right? Do I need to make a new project using cabal or stack and include it as a local dependency? Or start messing around in the project's test folder?
07:43:01 <sproingie> easiest way i found was to fork it on github and point stack at it
07:43:31 <sproingie> should be doable with cabal too, i just never bothered learning
07:43:53 <c_wraith> jchia_1: hmm.  I always just implement these things directly instead of trying to figure out how to stack combinators. :)
07:44:43 <mbw> sproingie: The master branch on github should already contain the fix, so I don't think I would need to fork it?
07:44:44 <jchia_1> c_wraith: What does 'directly' mean in the case of the example in the lpaste?
07:45:08 <c_wraith> jchia_1: I just use Applicative functions to make the type work, rather than combining lenses
07:45:27 <sproingie> example of adding a git dependency: https://gist.github.com/chuckadams/dfcb26212a732c5181490a13f1c625a8
07:46:04 <sproingie> and yah you don't need the fork if the fix is already in there
07:47:27 <mbw> sproingie: I'm not sure if I'm not mixing things up, but I'll try the git dependency thing.
07:50:13 <mbw> sproingie: How do I determine the path I need to put there? Is it just the project url terminated with ".git"?
07:50:47 <sproingie> mbw: yah, and you can get the commit hash from the commit history
07:52:10 <sproingie> github doesn't even require the .git at the end
07:53:36 <slack1256> foreign import ccall unsafe "math.h sin" csin :: CInt -> CDouble works. Should it fail at runtime?
07:53:53 <slack1256> how does ghc match between CTypes and headers types in C?
07:54:04 <int-e> slack1256: it does not.
07:54:31 <slack1256> I the programmer have to ensure that right?
07:54:45 <int-e> slack1256: afaiui, ghc assumes a C abi, and if you give a wrong C type, you can expect segfaults at runtime.
07:55:17 <mbw> No extra-dep setting found for package at URL:
07:55:17 <mbw> https://github.com/haskell-gi/haskell-gi.git
07:55:17 <mbw> This is usually a mistake, external packages should typically
07:55:20 <mbw> be treated as extra-deps to avoid spurious test case failures.
07:55:21 <int-e> (though not in this case, I guess, you'll just get more or less random values)
07:55:28 <mbw> sproingie: Is this normal?
07:55:48 <slack1256> I thought C had no standard abi
07:56:14 <sproingie> mbw: add that extra-dep line as well, indented at the same level as the location: line
07:56:18 <int-e> slack1256: But most platforms do.
07:56:42 <mbw> Ah, the extra-dep:true . I forgot that one.
07:56:44 <mbw> :/
07:56:46 <sproingie> for max readability i suppose extra-dep should come before location
07:56:51 <slack1256> oh, you mean it does the right thing on linux, bsd, win32 etc
07:56:55 <sproingie> yaml is awfulness
07:57:20 <int-e> slack1256: these days the task is (mostly?) delegated to libffi, which is designed for this purpose.
07:57:32 <mbw> I'll do that as soon as it is done building everything yet again.
07:58:08 * hackage atom-basic 0.2.5 - Basic Atom feed construction  https://hackage.haskell.org/package/atom-basic-0.2.5 (cbaatz)
07:58:30 <slack1256> libffi is this C library? https://en.wikipedia.org/wiki/Libffi 
07:58:54 <int-e> slack1256: that's the thing, yes
07:58:54 <sproingie> the same
07:59:10 <int-e> (I say mostly because ghc contained home-grown support for x86 (windows, linux) and trampolines and I am not sure whether some of that isn't still in use.
07:59:14 <int-e> )
07:59:16 <mbw> I thought people used inline-c or whatever it's called?
08:00:01 <sproingie> inline-c would be some kind of source level thing, libffi takes care of the runtime marshaling
08:00:17 <int-e> mbw: well, ghc's FFI (and RTS too) certainly does not; inline-c builds on top of the FFI.
08:00:27 <sproingie> didn't know ghc even used libffi.  that's good to know.
08:01:44 <mbw> Ah, so libffi is not an end-user thing then?
08:01:52 <sproingie> not particularly
08:02:20 <int-e> no, it's more of a language implementer's thing
08:02:29 <slack1256> int-e: IIRC they started to use libffi submodules in the main tree. I guess no more homegrown solutions
08:04:02 <mbw> sproingie: "Unrecognized field in PackageGitLocation: extra-dep." Maybe the format has changed?
08:04:47 <int-e> slack1256: well the homegrown code in rts/{Adjustor.c,AdjustorAsm.S,StgCRunAsm.S} is still around; as I said, I don't know whether it's used.
08:04:58 <sproingie> mbw: outdent it so it's at the same level as the location: line
08:05:14 <sproingie> (yaml sucks)
08:05:16 <mbw> Yeah I didn't do that...
08:05:53 <slack1256> oh
08:06:11 <mbw> Where exactly does this yaml format come from? It's not stack specific, right?
08:06:18 <c_wraith> yaml comes from ruby
08:06:24 <sproingie> as do many other bad ideas
08:06:38 <megaTherion> thought that yaml preceedes ruby
08:06:46 <mbw> Is it an acronym for "yet another meta language" or something?
08:06:56 <sproingie> markup i think
08:07:02 <c_wraith> yaml is notable for allowing arbitrary code execution in ruby if you use all of its features
08:07:02 <slack1256> maybe not, but it should be!
08:07:18 <c_wraith> Isn't that a wonderful feature?
08:07:19 <sproingie> it was some glue-sniffer's "XML sux, it's too enterprisey" thing.
08:07:28 <sproingie> ok sometimes it's actually a nice format.  in this case, not
08:07:46 <sproingie> there's a reason perl switched package metadata from yaml to json
08:07:55 <sproingie> (tho it supports both)
08:07:58 <c_wraith> It's a nice format when it's used for exactly the same things you could use json for if you were really strict with your formatting
08:08:57 <sproingie> when you mix arrays and dicts at various levels of nesting like stack.yaml is doing, yaml is especially atrocious
08:09:09 <mbw> Is it easier to parse than json? There must be a reason why snoyberg chose to use it.
08:09:16 <sproingie> it's much much much harder to parse
08:09:26 <sproingie> only thing worse to parse is markdown
08:09:33 <c_wraith> In fairness, every text format is bad at that.  You need a tree-based editor to make that sane.
08:09:41 <lpaste> ericdwhite pasted “Style” at http://lpaste.net/356016
08:10:13 <ericdwhite> Hi I'm looking for some feedback on the above.  I'm not happy with the inner let, and all the fmaps.
08:11:03 <sproingie> you can actually embed arbitrary json in yaml, but yaml parsers all tend to screw it up if your json has any linebreaks
08:11:48 <sproingie> one problem with json is it doesn't allow for comments
08:13:33 <mbw> That sounds like it could be problematic in a human-readable/editable context.
08:14:33 <sproingie> it is.  missing explanatory comments is bad enough, not being able to comment out sections is worse
08:14:53 <sproingie> much as i hate yaml, it's probably the best commodity format for this sort of thing
08:15:24 <c_wraith> if only there was a sane subset of yaml where you could throw out all the bad features.
08:15:41 <sproingie> c_wraith: too bad comments is also one of those features
08:15:56 <mbw> But the arbitrary code execution "feature" should be a problem with ruby only?
08:16:29 <sproingie> any parser still using slyck gets what it deserves
08:16:30 <mbw> Unless you consider that to be a good thing, of course.
08:16:32 <c_wraith> It's a really indirect thing..  It was hidden inside an interaction between rails an yaml itself.
08:16:47 <jchia_1> I've been using Haskell on a real project for almost a year. I started the project from scratch last year and it now has 7k LOC. I think I have a good understanding of things like Functors, Applicatives, Monads, monad transformers. However, I find myself looking up haddocks in a browser constantly while writing code because I can't remember the type signature for commonly-used functions like Map.lookup, Data.Maybe.maybe, and even foldl'
08:16:47 <jchia_1> . I don't remember that there is fromStrict but no toLazy. How do you guys remember these things? Do you just consciously try to memorize the type signatures?
08:16:53 <MarcelineVQ> c_wraith: What would you name that subset?
08:17:22 <sproingie> MarcelineVQ: json
08:17:24 <c_wraith> yaml lets you specify a class and its arguments for initializing a value.  Someone noted a class in rails that would eval the string it is initialized with
08:17:46 <slack1256> jchia_1: local hoogle instance, really easy to set up
08:18:00 <jchia_1> slack1256: You mean local hoogle from the shell?
08:18:04 <slack1256> yep
08:18:13 <sproingie> c_wraith: oh i was thinking of slyck, which was replete with buffer overruns
08:18:32 <c_wraith> So really, it's mostly an "eval is dumb and you're dumb for using it" problem...  But YAML made it easy to access it from weird directions.
08:18:36 <sproingie> slyck was the basis for a lot of parsers including in ruby, perl, and python
08:18:46 <slack1256> then $ hoogle ":: ByteString -> ByteString"
08:19:18 <sproingie> yaml has all kinds of silly ill-considered features, nothing supports them all
08:19:54 <c_wraith> Honestly, I'd like the subset of yaml that is strings, numbers, booleans, dictionaries, arrays, and comments.
08:20:40 <sproingie> that's all that most support, plus maybe the standard header
08:21:06 <akt> how about something like toml?
08:21:07 <sproingie> (which i suppose is just another type of comment)
08:21:30 <c_wraith> akt: I haven't used it much, but the fact that cargo chose it is a big plus
08:21:33 <glguy> https://glguy.net/config-demo I use this now instead of YAML
08:21:56 <sproingie> yay another snowflake format
08:22:13 <akt> likewise, only played with it when toying with rust but seemed pretty basic (in a good way)
08:22:17 <slack1256> Although it is a valid complain that lazy and strict ByteString got the same type name :-(
08:22:19 <sproingie> tho with haskell, config as code works pretty well
08:23:36 <mbw> sproingie: Ok I don't thing I'm doing it right. The commit that is supposed to fix things is this: https://github.com/haskell-gi/haskell-gi/commit/91b59f4bf7300bb3100c3755a8f67275bb325d1f . So I added this to my stack.yaml: 
08:23:40 <mbw> packages:
08:23:42 <mbw> - '.'
08:23:45 <mbw> - location:
08:23:47 <mbw>     git: https://github.com/haskell-gi/haskell-gi.git
08:23:50 <mbw>     commit: 91b59f4bf7300bb3100c3755a8f67275bb325d1f
08:23:52 <mbw>   extra-dep: true
08:23:57 <glguy> bad mbw
08:24:03 <mbw> ?
08:24:07 <sproingie> mbw: that looks right
08:24:44 <mbw> But I guess I have to tweak something else as well, since the bug persists.
08:25:26 <sproingie> try stack clean && stack build
08:25:36 <mbw> Specifically, stack expects me to add gi-gtk to the build-depends, and then it uses the old version probably.
08:26:30 <sproingie> hm, it always picked up the new dep for me, but that's because the old one didn't even build
08:26:53 <mbw> sproingie: cleaning and rebuilding did something, now it's building haskell-gi again. Maybe this was it.
08:27:17 <MarcelineVQ> maybe, sometimes it'll rebuild git things just because it feels like it
08:27:28 <MarcelineVQ> at least a version or two ago it did
08:27:59 <sproingie> should cache it like any other package, but i dunno the innards of stack
08:29:37 <mbw> I just know that "quickly trying out if it works" isn't a thing.
08:30:18 <mbw> Even c++ is compiled faster.
08:31:23 <sproingie> ghc will probably never be lightning fast.  incremental rebuilds are your friend.
08:31:31 <sproingie> (tho not your laptop battery's friend)
08:32:51 <sproingie> if linking is slow, try the llvm backend, it's supposed to be much faster
08:34:10 <mbw> The standard verbosity level doesn't really tell you which stage it is in. Unless copy/register involves linkage.
08:36:26 <sproingie> pretty sure it's the compile stage.  honestly link time's never been a problem for me tho
08:38:40 <sproingie> but i'm used to slow compiles in general, coming from scala.  tho with scala i just have a window open with sbt ~build
08:39:01 <glguy> c_wraith: Given what you're looking for I hope you'll check out that link
08:47:06 <MarcelineVQ> glguy, c_wraith: it's pretty neat :>
08:49:03 <ertes> GHC's slowness doesn't bother me, as i do my development work using the interpreter
08:49:22 <ertes> i used to have compilation in my development cycle, but i'd never go back to that
08:50:31 <sproingie> ide like intero has pretty good turnaround.  only need a full compile when building a final artifact.
08:51:28 <maerwald> ide?
08:51:57 <glguy> you know, like they have in March
08:52:13 <ertes> maerwald: intero is emacs' haskell-mode hardcoded to use stack
08:52:24 <maerwald> yeah
08:52:24 <ertes> and haskell-mode is an IDE
08:52:35 <ertes> (in the usual sense of the word)
08:53:14 <maerwald> not sure if that is the usual sense, but I get what you mean
08:53:36 <mbw> sproingie: I still get the bug, so apparently I'm still doing something wrong, or the bug persists. What other ways of screwing things up are there for me to consider?
08:54:55 <mbw> First things first I need a way to confirm that I am really using the most recent versions of the libraries. Unfortunately I don't thing ldd is helpful here.
08:55:03 <ertes> (IIRC intero even forces you to have a cabalised, stackified project…  it won't load a standalone haskell file)
08:55:19 <sproingie> mbw: maybe it is still using the old version for whatever reason.  if the version has been bumped up, try hardwiring that exact version
08:55:55 <sproingie> ertes: it works fine with standalone haskell files actually
08:56:16 <sproingie> it just isn't much more than haskell-mode at that point of course
08:56:25 <ertes> ah, ok
08:56:36 <ertes> i wonder what "much more" would be anyway =)
08:57:08 <sproingie> just being stack-aware mostly.  it also has a tweaked ghci it uses for the backend
08:57:18 <ab9rf> btw, every month has an ides, not just march
08:57:18 <maerwald> ertes: do you know if it _really_ requires stack (in a technical sense) or is that just some superficial hardwiring?
08:57:19 <ertes> haskell-mode is stack-aware, too
08:57:49 <maerwald> I wonder if I could just fork it and remove the stack pieces 
08:57:52 <sproingie> ab9rf: historically speaking, march's is a bit more stabby
08:57:54 <ertes> maerwald: nope, sorry
08:58:18 <mbw> Ok now it's building everything again, which will probably take another half hour. This is not very productive.
08:58:45 <sproingie> maerwald: ghc-mod would probably be what you're looking for then
08:58:52 <maerwald> huh?
08:59:25 <ertes> mbw: BTW, nix uses a remote build cache managed by CI, so i rarely compile haskell packages that aren't my own
08:59:35 <sproingie> ghc-mod being a different ide support thing, with interfaces for vim and emacs
08:59:43 <maerwald> I know
08:59:59 <sproingie> what's nice about intero is how it installs itself
09:00:54 <mbw> ertes: Since I don't have any experience with nix or TravisCI, is there a lot of initial learning involved if I want to try these things out?
09:01:25 <ertes> mbw: s/TravisCI/hydra/, and yes, there is a learning curve…  not on the level of haskell itself, but you definitely need to learn it
09:02:10 <sproingie> i'd love to learn more nix.  macos doesn't seem the best environment to learn it tho.
09:02:11 <mbw> So CI /= TravisCI, and they address different problems?
09:02:31 <sproingie> CI = Continuous Integration.  Travis is a CI product
09:02:53 <ertes> sproingie: i don't know if it still sucks, but you can try it out, and if it doesn't work well enough, just delete /nix
09:03:09 <ertes> mbw: they address the same problem, but hydra is nix-specific
09:03:19 <ertes> it understands nix-specific concepts
09:03:31 <sproingie> ertes: have tried it, didn't work out well either time, deleted /nix 
09:04:18 <sproingie> can't really blame nix, the obstacles to making it work are all apple's doing
09:04:25 <ertes> sproingie: alternatively leave it there and become a contributor, if you have the time…  we need more macOS users =)
09:04:35 <sproingie> nix is really made for an OS that can be built from scratch, and this is increasingly untrue for osx
09:04:48 <ertes> ah, yeah, there's that
09:05:30 <ertes> i guess by the time this is solved, it will also (be able to) get windows support
09:06:26 <glguy> I had some success using Nix to build a project with ghcjs on macOS, but the success was largely due to dmj` knowing what he was doing
09:07:29 <Eduard_Munteanu> What's keeping ghcjs from being merged into mainline, by the way?
09:07:40 <Gurkenglas> How do I get a tags table for intero's init-intero-goto-definition without being in a project?
09:08:30 <Eduard_Munteanu> It would be really great if the stock ghc could compile for both targets.
09:11:01 <ertes> one advantage of having a separate GHCJS is an independent release cycle
09:11:24 <sproingie> the main thing with nix is that i have no use case for it.  at my old job, certainly.  currently, no.
09:11:54 <Gurkenglas> The times I want that is when I am writing a top-level .hs script, and when I'm in ~\stack\indices\Hackage\packages because init-intero-goto-definition sent me there through the tags table projectile-regenerate-tags generated for a project
09:13:36 <ertes> sproingie: even if you don't do deployment/CI, nix can be handy:  not having to compile third-party libraries is a huge time saver, and the ability to quickly test a package with multiple compilers is also very useful
09:14:00 <ertes> for example i usually test my libraries with the most recent two GHC major versions before release
09:14:07 <sproingie> it certainly has appeal for devops and build farms, sure
09:14:22 <sproingie> and as a package manager, it's kinda like ports taken to the next level
09:14:47 <ertes> yeah…  NixOS is pretty much "gentoo done right" =)
09:17:52 <mbw> Is NixOS also usable in the context of languages like C,C++?
09:18:35 <mbw> Alright, I give up. Can't get this supposedly fixed version of gi-gtk to work.
09:18:36 <sproingie> you'd use it to set up a c++ dev environment.  or several.
09:20:06 <ertes> mbw: nix is (NixOS is an OS built on nix)
09:20:17 <sproingie> nix is sort of the confluence of vagrant (user-space only) and ports/pkgsrc, tied together by a real config language
09:20:41 <iqubic> I use Gentoo, and I don't have any issues with it.
09:20:53 <Gurkenglas> Ooh, acme-everything is useful in order to create a global tags table for emacs (intero) :)
09:21:25 <defstryker> hello
09:21:25 <sproingie> with gentoo you have just the one system in its current configuration.  with nix you have a whole tree of them
09:22:27 <sproingie> Gurkenglas: you should write up a blog post about it
09:23:15 <Gurkenglas> Maybe a PR to https://github.com/cydparser/demo-emacs-haskell/blob/master/demo.org#jump-to-dependency-definitions for getting M-. running everywhere
09:23:32 <Gurkenglas> Lets first see if I can even build acme-everything.
09:23:47 <sproingie> i'd be amazed if it built cleanly
09:24:12 <sproingie> but then again that's what stackage is about
09:24:38 <Gurkenglas> Is there an acme-stackage or something?
09:25:04 <ertes> iqubic: try to change your USE flags
09:25:24 <Gurkenglas> --omit-packages happily told me that it omitted acme-everything :3
09:26:20 <Gurkenglas> (stack script only works for packages in stackage anyway, right?)
09:26:39 <defstryker> what's the difference between foldr and foldr1 ? I tried hoogle but I drew blanks...
09:26:59 <sproingie> foldr1 takes the initial item from the head of the list
09:27:13 <sproingie> and isn't safe in that it'll throw an exception on an empty list
09:28:03 <defstryker> ahhh so like doesn't check for a null base case?
09:28:45 <sproingie> it checks, it just doesn't have any way to gracefully handle it
09:29:06 <defstryker> hmmm thanks!
09:29:29 <cocreature> this also means that your accumulator type has to be the same as the type of your elements
09:29:30 <cocreature> :t foldr
09:29:32 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:29:32 <cocreature> :t foldr1
09:29:34 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
09:30:39 <emmanuel_erc> defstryker: you could write a safe version of foldr1 by wrapping your accumulator in a Maybe.
09:31:28 <defstryker> actually I'm totally fresh to haskell and just starting out... 
09:31:34 <emmanuel_erc> I see.
09:31:39 <defstryker> I ran into this while trying project-euler
09:32:58 <Gurkenglas> How do I make a project that depends on all stackage?
09:33:07 <sproingie> i forget if MonadFail is a proper thing now.  if so, it could be made to fail in a proper fashion.  looks like right now it just barfs in the ugliest way possible, errorWithoutStackTrace
09:37:03 <ertes> defstryker: exercise: write foldr1 in terms of foldr
09:37:38 <defstryker> ertes: thanks, i'll start on it asap :D
09:40:20 <roconnor> Is there a language extension that lets me write the functor ((->) a) as (a ->) ?
09:40:32 <sproingie> https://github.com/fpco/stackage/blob/master/build-constraints.yaml would be a good place to start
09:40:42 <sproingie> Gurkenglas: ^
09:40:50 <cocreature> roconnor: sadly there isn’t (afaik)
09:40:52 <MarcelineVQ> roconnor: I'm not aware of type operator sections, let me know if you find something though
09:41:58 <cocreature> i wonder if there are actually problems in implementing this or if just nobody has bothered doing so
09:42:43 <ertes> i bet they'd make ArrowSections instead of just making a general solution that also includes (,) =)
09:42:53 <Gurkenglas> Hm. I wonder how many gigs of my hard disk I should free up in order to try to build all stackage.
09:43:54 <sproingie> a few, it's probably not that big.  might need a spare eon if you're building on a laptop
09:45:05 <sproingie> i used to mirror cpan, whole thing is <5 gigs
09:47:14 <exypnos> would anyone mind pointing me in the direction of a library for generating/playing sounds with haskell? in particular, looking to play pure sine waves. 
09:48:34 <Gurkenglas> aloiscochard, oh, you made codex. Can codex make a global tags file so I can use it in stack scripts and the ~\stack\indices\Hackage\packages the codex tags files send me to?
09:49:15 <Gurkenglas> exypnos, honk
09:50:38 * hackage text-format-heavy 0.1.0.0 - Full-weight string formatting library, analog of Python's string.format  https://hackage.haskell.org/package/text-format-heavy-0.1.0.0 (IlyaPortnov)
09:51:04 <exypnos> gurkenglas, not exactly what I was looking for, something closer to C's portaudio would be ideal
09:52:07 <sproingie> honk is really primitive.  maybe synthesizer-core
09:53:16 <sproingie> or possibly one of the interfaces to external synths like supercollider
09:53:29 <Eduard_Munteanu> exypnos, you can use SDL and do your own synthesis. In fact, you can just output the samples and have another program play them
09:55:03 <sproingie> if you want sounds for games, i'd suggest openAL.  for noodling around with a synth, supercollider is fun
09:55:23 <exypnos> just synth noodling right now, will check out supercollider
09:56:37 <sproingie> never used haskell's SC bindings but apparently there's more than one
09:56:58 <Gurkenglas> Why doesn't it find Sound.Honk? https://i.gyazo.com/78ec2d3a427c2e6dc7716b1acd01a88a.png
09:57:35 <sproingie> try --package honk  (lowercase)
09:57:37 <Eduard_Munteanu> > let s = 44100 in map (\x -> sin (880 * x / s)) [1..3 * s]
09:57:39 <lambdabot>  [1.9953324268851973e-2,3.989870362709982e-2,5.982819632760246e-2,7.973386694...
09:58:29 <Eduard_Munteanu> Er, 0 ..
09:58:54 <Eduard_Munteanu> That should generate 3 seconds of a 440 Hz tone.
09:59:08 * hackage gi-gtk 3.0.15 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.15 (inaki)
09:59:28 <Eduard_Munteanu> In signed float 44100 Hz mono format.
10:23:04 <cocreature> isn’t that missing a π somewhere?
10:26:47 <iqubic> Let's say I have a [[Int]] and two [Int]. How do I combine them into a single [[Int]]?
10:27:07 <cocreature> iqubic: how do you want to combine them?
10:27:19 <sproingie> [list1, list2]
10:27:28 <cocreature> not on a Haskell level but what’s the operation that you want to perform
10:28:08 * hackage path-io 1.3.0 - Interface to ‘directory’ package for users of ‘path’  https://hackage.haskell.org/package/path-io-1.3.0 (mrkkrp)
10:28:18 <iqubic> I want to add the two [Int] to the end of the [[Int]]
10:28:52 <iqubic> Or the start, if that would be the easiest.
10:29:10 <sproingie> cons 'em
10:29:14 <sproingie> :t (:)
10:29:15 <lambdabot> a -> [a] -> [a]
10:29:23 <iqubic> Well, that works.
10:29:50 <EvanR> list1:list2:theListOfLists
10:30:16 <iqubic> Except I just realized that I have two ListsOfLists.
10:30:32 <cocreature> concat them using ++
10:30:34 <cocreature> :t (++)
10:30:35 <lambdabot> [a] -> [a] -> [a]
10:30:46 <iqubic> And I want to append the contents of one ListOfLists to the other, then do the consing
10:31:20 <sproingie> ++ first, then :
10:31:39 <iqubic> Got it.
10:32:00 <sproingie> > [[1,2,3]] ++ [[4,5,6]]
10:32:02 <lambdabot>  [[1,2,3],[4,5,6]]
10:32:53 <iqubic> That's what I want
10:34:05 <iqubic> What package is asum in?
10:34:07 <iqubic> :t asum
10:34:08 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:34:14 <cocreature> base
10:34:16 <sproingie> @hoogle asum
10:34:16 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
10:34:17 <lambdabot> Data.Conduit.Combinators asum :: (Monad m, Alternative f) => Consumer (f a) m (f a)
10:34:17 <lambdabot> CorePrelude asum :: (Foldable t, Alternative f) => t (f a) -> f a
10:34:31 <iqubic> So I have to import Data.Foldable?
10:34:40 <cocreature> yes
10:34:40 <sproingie> not now
10:34:48 <sproingie> well maybe for asum
10:35:01 <cocreature> at least in 8.0 it’s not in the prelude
10:35:10 <iqubic> :t any
10:35:11 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
10:35:46 <iqubic> :t none
10:35:47 <lambdabot> Foldable f => (a -> Bool) -> f a -> Bool
10:36:04 <iqubic> Or those just the logical not of each other?
10:36:21 <mniip> @src none
10:36:22 <lambdabot> Source not found. Are you typing with your feet?
10:36:23 <iqubic> s/or/are/
10:36:46 <mniip> maybe
10:37:09 <cocreature> yes, see https://hackage.haskell.org/package/lens-4.15.2/docs/src/Control.Lens.Indexed.html#none
10:37:24 <Gurkenglas> @check \f x -> any (f :: Int -> Bool) (x :: [Int]) == not (none f x)
10:37:27 <lambdabot>  +++ OK, passed 100 tests.
10:38:01 <mniip> @check \f x -> all (f :: Int -> Bool) (x :: [Int]) == not (none f x)
10:38:04 <lambdabot>  *** Failed! Falsifiable (after 1 test):
10:38:04 <lambdabot>  <Int -> Bool> []
10:38:10 <mniip> hah
10:38:37 <cocreature> @check \f x -> all (f :: Int -> Bool) (x :: [Int]) == none (not . f) x
10:38:40 <portnov> de Morgane is our all
10:38:40 <lambdabot>  +++ OK, passed 100 tests.
10:39:00 <Gurkenglas> @check \f x -> all f (x :: [Int]) == none f x
10:39:03 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 1 shrink):
10:39:03 <lambdabot>  <Int -> Bool> [3]
10:39:03 <iqubic> fst spot == snd spot is the same as uncurry (==) spot?
10:39:09 <iqubic> Is that right?
10:39:12 <mniip> no
10:39:18 <mniip> hmm
10:39:19 <mniip> yes
10:39:32 <iqubic> Can you write a @check thing to test it?
10:39:52 <mniip> that kind of is by definition of 'uncurry'
10:39:55 <cocreature> @check \x -> ((fst x :: Int) == snd x) == uncurry (==) x
10:39:57 <lambdabot>  +++ OK, passed 100 tests.
10:40:03 <mniip> @src uncurry
10:40:03 <lambdabot> uncurry f p = f (fst p) (snd p)
10:40:15 <iqubic> Oh. I see
10:40:15 <mniip> substitute f=(==)
10:41:18 <Gurkenglas> "*** Failed! Falsifiable (after 4 tests and 1 shrink):" <- I wonder what the second and third test were.
10:41:33 <Gurkenglas> Oh, different fs with x = []. Duh.
10:43:09 <Gurkenglas> I wonder if we could make a quickcheck thing that tries to give us an implementation of any given value that it cannot falsify.
10:44:02 <sproingie> sounds like djinn
10:44:31 <Gurkenglas> Yes, but using arbitrary and coarbitrary. Like exference, but very unlikely to produce something useful.
10:45:58 <Gurkenglas> (It would just memoize any functions it's told to approximate as far as quickcheck would test, right?)
10:46:35 <bno1> hunit or hspec?
10:47:42 <cocreature> bno1: hspec is just a wrapper around hunit so it’s not really an or question but personally I think it’s a very good wrapper and it also includes a lot of other useful stuff
10:47:52 <bno1> great
10:47:56 <Gurkenglas> Ah, not an implementation of an explicitly given value, but an implementation that satisfies a given quickcheck property.
10:48:16 <WarzoneCommand> question: I've implemented some algorithm, and now I'm trying to speed it up. I've profiled it, and fixed some things that cut the running time in half or so. Now I don't really see anything "weird" anymore based on the prof output, yet I'm guessing it should still be possible to improve the running time. Are there some general guidelines that could help me figure out where I can best spend my time
10:48:23 <WarzoneCommand>  to speed up my implementation?
10:49:32 <Gurkenglas> I would try making it shorter (and accidentally slower) until it becomes obvious that another library has already implemented what I'm doing faster
10:49:32 <cocreature> WarzoneCommand: post the code here, wait until someone figures out how to improve your code and then spend your time there :P
10:49:37 <EvanR> https://wiki.haskell.org/Performance
10:49:51 <Tuplanolla> @google haskell worker wrapper transformation
10:49:53 <lambdabot> https://wiki.haskell.org/Worker_wrapper
10:50:02 <Tuplanolla> This as well.
10:50:18 <Gurkenglas> That's so mechanical, why doesn't the compiler do it automatically?
10:50:21 <sproingie> hm that performance page should maybe mention something about fusion
10:50:48 <WarzoneCommand> well, in general "the code" may be quite big. But the main algorithm is here: https://github.com/noinia/hgeometry/blob/master/src/Algorithms/Geometry/LineSegmentIntersection/BentleyOttmann.hs 
10:50:49 <Tuplanolla> Sometimes the tricks make performance worse, Gurkenglas.
10:52:00 <n_blownapart> hello sorry in stack I keep getting this same error, and the compiler seems to disappear -- what to do to prevent this? thanks https://nopaste.me/view/3c7be3de
10:52:05 <mbw> I'd like to thank the people who gave me some advice earlier today about my struggles with cabal/stack/git. After talking to the maintainer of gi-gtk again, a fixed version is now on hackage as well.
10:52:31 <cocreature> n_blownapart: have you tried doing what it tells you, i.e., run "stack setup"?
10:52:38 * hackage haskell-gettext 0.1.1.0 - GetText runtime library implementation in pure Haskell  https://hackage.haskell.org/package/haskell-gettext-0.1.1.0 (IlyaPortnov)
10:52:53 <n_blownapart> cocreature, that takes over 5 minutes 
10:52:59 <n_blownapart> what is causing it?
10:53:11 <cocreature> n_blownapart: it’s downloading GHC which is quite large
10:53:12 <sproingie> mbw: you'll probably need to wait a day for it to land on stackage though
10:53:37 <n_blownapart> yeah but I've had it working fine, then I start getting errors (giant ones)
10:54:07 <bno1> is there a way to get the current line number and file, like C's __LINE__ and __FILE__ defines? I know I can use GHC.Stack but it's non-portable and needs -prof
10:54:12 <sproingie> n_blownapart: well let's see those errors then
10:54:39 <EvanR> bno1: yes there is TH for that
10:55:01 <mbw> sproingie: Just adding it to the extra-deps in the stack.yaml file does the trick, and of course you need to hardwire the version in the .cabal file (but maybe you don't even need to do that, I'm not sure).
10:55:02 <geekosaur> bno1, if you enable the CPP extension you can use those
10:55:28 <cocreature> mbw: you don’t need to hardwire versions in your cabal file
10:55:42 <bno1> geekosaur: it would work if i wrap that cpp code in a function?
10:55:49 <bno1> EvanR: i'll check it out, thanks
10:55:55 <geekosaur> the same way it would work in C
10:56:17 <n_blownapart> one moment thanks sproingie 
10:56:18 <mbw> cocreature: Good to know, this makes this all the more convenient.
10:56:21 <geekosaur> i.e. they expand in place to String literals, they do not give you a caller trace
10:56:47 <mbw> Anyway, according to the author, doing things by foot using cabal is not trivial in the case of the gtk bindings.
10:56:52 <Rotaerk> hmm... https://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array-MArray.html
10:56:54 <sproingie> i remember someone had a weird problem with making __LINE__ work.  turned out to be something weird i can't remember
10:56:58 <Gurkenglas> WarzoneCommand, is general code review also ok? I have a general hunch that you're doing a left fold instead of a right fold, meaning that you could pass the ss out of the recursion instead of passing it in
10:57:00 <n_blownapart> how does one show previous error messages in a linux term?
10:57:07 <Rotaerk> why does the documentation for the MArray class not list all the methods?
10:57:26 <Rotaerk> it mentions getNumElements, unsafeRead, unsafeWrite under the "minimal complete definition", but not under Methods
10:57:35 <EvanR> n_blownapart: scroll up
10:57:44 <EvanR> perhaps shift page up
10:57:54 <sproingie> or scroll wheel on most terms
10:58:26 <WarzoneCommand> Gurkenglas: sure
10:58:49 <n_blownapart> sorry EvanR I lost it. I interrupted it, it hung the terminal
10:59:25 <EvanR> it would would help to know what on earth you are doing in a terminal
10:59:33 <EvanR> e.g. shift page up totally fails in vim
10:59:40 <EvanR> and less
10:59:59 <n_blownapart> sorry hold on EvanR my skills are quite limited
11:00:32 <geekosaur> sproingie, a common gotcha with CPP extension is Haskell allows ' (and with MagicHash, #) in identifiers and this confuses cpp
11:00:44 <geekosaur> because they are *not* identifier characters in C
11:01:13 <mbw> I think "#" may be used for some of the more fance cpp string handling capabilities.
11:01:19 <mbw> *fancy
11:01:38 <geekosaur> anyway the usual problem is something like: foo' = ... __LINE__ ...
11:01:40 <WarzoneCommand> Gurkenglas: in which function do you mean specifically? In general it's a sweep line algo that uses a min priority Queue to drive the sweep 
11:01:56 <geekosaur> but cpp is dumb and started parsing a multicharacter (char) at the ', so never expands __LINE__
11:02:23 <mbw> nevermind, what I wrote is just wrong
11:03:00 <WarzoneCommand> (i.e. the interesting stuff is mostly happening in the 'sweep' and 'handle' functions) 
11:03:03 <geekosaur> the # stuff is limited in traditional cpp, it's token pasting in ANSI cpp
11:03:03 <sproingie> geekosaur: ah that was it
11:03:09 <n_blownapart> If I forget to build , and go straight to "$ stack exec fibonacci-exe" will that break things? 
11:03:22 <geekosaur> but we (try to) disable ANSI mode because it's even more tightly tied to C syntax and a lot of Haskell syntax confuses it
11:03:30 <n_blownapart> that's what caused the long error
11:03:51 <sproingie> n_blownapart: stack exec will build if it's out of date
11:04:03 <sproingie> yay, it's at least as smart as make :)
11:04:31 <n_blownapart> It looked like it started to build , then started looking for indices, and I knew I had the same problem I did the other day sproingie 
11:04:50 <geekosaur> (cpphs, on the other hand, adds the ANSI token pasting while retaining as much as possible Haskell compatibility)
11:06:08 <sproingie> i've seen some really clever stuff done with token-pasting in cpp.  'course i prefer languages where such clever usage of blunt tools isn't necessary
11:07:28 <Tuplanolla> At least CPP doesn't have `\expandafter`.
11:07:46 <geekosaur> heh heh
11:07:52 <n_blownapart> sproingie, any advice re: above amigo?
11:08:12 <sproingie> n_blownapart: did you paste the error somewhere?
11:08:21 <n_blownapart> I can't find it
11:08:35 <n_blownapart> I controlled c to interrupt
11:09:01 <sproingie> can't help much if i can't see
11:09:03 <geekosaur> I did see your question about scrollback. you could redo the build with stderr redirected to file (stack build ... 2>errfile)
11:10:02 <n_blownapart> Geekosaur just reading about that. is that the precise command with the ... ?
11:10:18 <Gurkenglas> WarzoneCommand, app is liftA2
11:10:18 <n_blownapart> no I get it
11:10:33 <geekosaur> most terminals support some kind of scrolling, try ctrl+pgup/pgdn
11:10:51 <geekosaur> the "2>errfile" is what redirects the errors
11:11:01 <sproingie> stack build 2>errorfile 2>&1
11:11:20 <sproingie> er, stack build >errorfile 2>&1
11:11:24 <geekosaur> (I just noticed my terminal doesn't support ctrl-pgup/dn, it switches tabs instead. "yay" linux consistency...)
11:11:27 <sproingie> may as well get all the output
11:11:33 <geekosaur> yes
11:11:44 <Tuplanolla> It's usually Shift, geekosaur.
11:13:01 <Gurkenglas> wait it isnt. wtf brain. sorry WarzoneCommand.
11:13:27 <geekosaur> oh, hm. I actually do keyboard scroll rarely enough (and almost always on text console) either I got that wrong or x terminals don't (any more? I do recall some complaints) use the console ones
11:13:39 <n_blownapart> thanks, I can't seem to scroll up. it linux debian
11:13:44 <WarzoneCommand> np
11:13:49 <sproingie> i wish irssi worked with the scroll wheel
11:14:02 <sproingie> probably a plugin somewhere for that
11:14:20 <n_blownapart> I'm trying to learn irssi  all these conveniences ...
11:14:28 <n_blownapart> NOT
11:14:34 <geekosaur> n_blownapart, I just used shift-pgup to scroll in mate-terminal, other vte-based terminals will be similar (gnome-terminal, xfce4-terminal) but urxvt/xterm may differ
11:14:41 <WarzoneCommand> it's something of type: Applicative f => (a -> b -> f c) -> f a -> f b -> f c 
11:15:04 <geekosaur> in xterm you can ctrl-middleclick and enable the scrollbar
11:15:11 <Tuplanolla> The virtual terminal I assumed he referred to by "Linux term" also does that, geekosaur.
11:15:26 <geekosaur> also, you may need to go into terminal settings and specify a scrollback buffer 
11:15:51 <n_blownapart> geekosaur, thanks no worky
11:17:53 <n_blownapart> geekosaur, yeah I'm going to define a very large buffer thanks
11:18:09 <n_blownapart> If my files look like this : ~/haskell/fibonacci/app, is it wrong to build / exec from the app directory. should I go back to the project folder?
11:18:13 <Gurkenglas> WarzoneCommand, nah f is Monad
11:19:27 <Gurkenglas> Weird that isClosedStart complains about incomplete pattern matches, the custom patterns you defined seem at first glance to make LineSegment s e cover everything. WarzoneCommand, you can pull the isClosed out of isClosedStart and handle could be made nonrecursive by having sweep call handle, get back the new eq and ss and accumulate the reports
11:19:35 <int-e> n_blownapart: inside irssi, pgup and pgdown should work for scrolling inside a window
11:20:32 <roconnor> glguy: your version of myIterA in http://lpaste.net/356001 has a less general type signature than iterA from Control.Monad.Free. :/
11:21:19 <glguy> roconnor: Yeah, that was the second version where I was specifically just trying to operate on natural transformations specifically
11:21:34 <glguy> -specifically
11:21:44 <roconnor> It feels more right though.
11:22:11 <n_blownapart> thank you int-e, my problem is in the cli 
11:23:16 <roconnor> glguy: its like in lens where you pass in lenes, which are polymorphic values and only instantiate them at one instance.
11:23:40 <roconnor> glguy: so the infered signature is more general, but you never use that generality.
11:23:47 <roconnor> and if you do, you are probably doing it wrong.
11:24:05 <glguy> Sure, the more general type seems more convenient
11:24:35 <flounders> n_blownapart: I use tmux for that, but your virtual terminal should support it too.
11:26:10 <kamyar> I have a complicated question ! Please help:
11:26:33 <kamyar> I have made an application using Scotty
11:26:48 <WarzoneCommand> Gurkenglas: yeah I also don't really understand why it complains about those pattern matches 
11:27:18 <kamyar> The application conects to database using Groundhog
11:27:28 <kamyar> It works great! But..
11:27:32 <n_blownapart> so when I go to my home directory to do "$ stack setup" , I get this https://nopaste.me/view/58d074f1  So where do I do the setup ?
11:27:43 <kamyar> I need to bind my Sql Connection life-time to my web request
11:27:57 <kamyar> Actually I need to open a connection for each web request
11:27:57 <sproingie> do stack setup in the stack project
11:28:06 <sproingie> stack setup --install-ghc
11:28:43 <kamyar> that is, if multiple functions must be run within a request life-time, and each of them uses sql connection, all of them must be using the same cnnection form the main pool
11:28:57 <flounders> n_blownapart: You should be doing it in the folder your project is located in if you don't want to use the global stack.yaml.
11:29:01 <kamyar> I have already used connection pool
11:29:08 <sproingie> actually "stack build --install-ghc" should work too
11:29:15 <kamyar> What should I do? Do I have t use MVar or TVar?
11:29:43 <n_blownapart> flounders, sproingie can't I just do it once in my haskell folder or from $HOME ?
11:30:22 <geekosaur> to download it, yes, but it still has to get hooked into your project somehow
11:30:45 <flounders> n_blownapart: What stack does is provide you a snapshot of packages that work well together and that includes with GHC. So different projects may use different GHC versions which is why you do it per project.
11:31:04 <geekosaur> if your project has its own stack.yaml then you also need to do the stack setup there to tell it to use that ghc
11:31:13 <sproingie> n_blownapart: if the project expects a different ghc version, you have to install it
11:31:36 <sproingie> also, just "stack build" should build things, no need to add the project name
11:31:48 <n_blownapart> no directed to you good people, but that is nuts for a beginner. isn't there some sort of default ?
11:32:34 <n_blownapart> I'm just doing like fibonacci and a test for primality
11:32:44 <sproingie> there's a default for each resolver, yes.  if it's a newly created project, it should be using the default resolver
11:32:44 <n_blownapart> simple math ditties
11:32:56 <EvanR> you do not need stack for this
11:33:18 <sproingie> stack isn't necessary, but it's good to learn the stack toolchain anyway
11:33:28 <EvanR> *in order to do a fib test* 
11:33:49 <sproingie> #!/usr/bin/env stack oughta do the job then
11:33:59 <sproingie> (or just throw it into ghci)
11:34:00 <n_blownapart> complicated, thanks. so if I just delete fibonacci and make a new proj, then I don't need to install the compiler again in that apparently botched folder?
11:34:05 <EvanR> theres something to be said for, even if its old version, ruby interpreter is just there
11:34:08 <EvanR> and you can just type into it
11:34:16 <sproingie> if it installed once before, it'll be cached
11:34:24 <sproingie> (in ~/.stack)
11:34:54 <n_blownapart> ruby? yeah ruby and scheme environments are a lot easier to work with.
11:35:17 <sproingie> stack is a lot like nvm/rvm
11:35:23 <EvanR> well no, when you get into production ruby its kind of insane
11:35:35 <EvanR> point is you dont have to get into that to just try something like a fib test
11:35:48 <n_blownapart> so re: my above question, just delete the proj and make a fresh one?
11:36:09 <Eduard_Munteanu> kamyar, I think you can define your own connection pool which closes the connection and opens a new one when it is returned to the pool
11:36:19 <sproingie> or just don't bother with a project and use ghci for noodling around
11:36:39 <kamyar> Eduard_Munteanu: The problem is not pooling
11:36:48 <n_blownapart> ok I think I can cheat and just delete the problematic one. thanks ALL
11:41:40 <sproingie> i just wish there was a way to tell cabal "expose all the things"
11:43:51 <n_blownapart> sproingie, EvanR geez I just somehow inadvertently found the error message https://nopaste.me/view/777a18d3
11:44:28 <n_blownapart> if flounders cares to look ^
11:45:12 <EvanR> reading helps
11:45:14 <sproingie> well that's a new one on me
11:45:49 <sproingie> if i saw that one i'd probably just nuke ~/.stack
11:46:02 <jophish> Thanks edwardk!
11:46:10 <jophish> (for merging the changes to half)
11:46:17 <cocreature> is that actually problematic? maybe it has some sort of fallback cache
11:46:19 <n_blownapart> yeah that one just says to me, stack and haskell are for genius types only
11:46:48 <sproingie> stack is still fairly new
11:46:50 <n_blownapart> EvanR, sorry what do you mean?
11:47:03 * geekosaur wonders if the old index is still being updated. also, why isn;t this using stack's version which certainly *is* being updated
11:47:03 <Tuplanolla> System administration requires a tolerance to pain, not intelligence, n_blownapart.
11:47:15 <n_blownapart> thats funny
11:47:25 <Tuplanolla> It's true.
11:47:45 <cocreature> geekosaur: they switched from their gitbased mirror to hackage security a while back iirc
11:47:53 <n_blownapart> I just like math and was directed to check out haskell
11:48:10 <n_blownapart> *encouraged
11:48:11 <geekosaur> hm. but isn't 00-index the *pre-*security index?
11:48:14 <sproingie> i still need to find where stack-run is doing stty -icanon in order to set it back.  right now i just have a wrapper script doing that
11:48:33 <cocreature> n_blownapart: are you running the newest version of stack?
11:48:36 <geekosaur> sproingie, there's a bug open about that
11:48:52 <cocreature> n_blownapart: also what happens if you don’t interrupt that build in the middle and instead just let it continue until it finishes?
11:49:06 <geekosaur> its not, strictly speaking, stack's fault; it disables buffering, at some point ghc's base library started conflating that with tty modes
11:49:23 <n_blownapart> cocreature, yeah I just there was something more fundamentally wrong so I interrupted
11:49:48 <n_blownapart> I had done stack setup a few times, on a slow wireless in colombia
11:49:48 <cocreature> n_blownapart: just to be sure you might want to run "stack upgrade"
11:49:56 <n_blownapart> the other day
11:50:12 <sproingie> geekosaur: i figured the bug might be deeper, ISTR running into similar problems with the conduit examples
11:50:15 <n_blownapart> thanks I think its upToDate
11:50:26 <sproingie> though i probably ran those using stack too
11:51:10 <sproingie> n_blownapart: ah, if it was interrupted in the middle, it might have corrupted stuff in ~/.stack.  i'd try rm -rf ~/.stack and do stack setup again
11:52:03 <n_blownapart> sproingie, so manually delete .stack and essentially reinstall stack with setup?
11:52:22 <flounders> n_blownapart: If you are doing just simple exploration in the language using just base, you should be fine using the system's GHC.
11:52:38 * hackage nice-html 0.1.2 - A fast and nice HTML templating library with distinct compilation/rendering phases.  https://hackage.haskell.org/package/nice-html-0.1.2 (MikeLedger)
11:52:39 <sproingie> well you still have stack, you'd be reinstalling stackage
11:52:42 <edwardk> jophish: sorry i took so long
11:53:03 <n_blownapart> ok thanks I might as well learn the version control or whatever you call it
11:53:11 <geekosaur> also note that ~/.stack-work may be more relevant than ~/.stack
11:53:27 <sproingie> .stack-work is a subdir of individual projects afaik
11:53:36 <n_blownapart> geekosaur, you mean delete both?
11:53:52 <sproingie> you can safely delete both.  long as you have stack, it can reinstall everything it needs.
11:53:58 <geekosaur> I would be hesitant to just wipe out .stack. even if it turns out you need to do so, there are some things you might want to preserve
11:54:08 <geekosaur> (like settings for the global project)
11:54:10 <n_blownapart> geez
11:54:21 <flounders> Considering he is getting started, I don't think there is much to preserve.
11:54:23 <sproingie> i'd imagine anyone changing their global settings is already familiar :)
11:55:03 <n_blownapart> ok I'll delete both, do $ stack setup, and read War and Peace
11:55:22 <sproingie> eh, doesn't take that long.  try it with ghcjs sometime.
12:02:47 <jophish> no problem :)
12:03:20 <EvanR> deleting everything and reinstalling... sounds like a familiar hell
12:04:41 <n_blownapart> yep. one more thing, to repost this : If my files look like this : ~/haskell/fibonacci/app, is it wrong to build / exec from the app directory. should I go back to the project folder?
12:05:01 <sproingie> you probably want to run stack from the project root
12:05:23 <sproingie> tho if it works from a subdir, then it's probably smart enough that it doesn't matter
12:05:48 <n_blownapart> thanks sproingie sometimes it seems like I can only run commands from one or another. odd, that
12:06:10 <sproingie> everything should work from the root
12:06:24 <n_blownapart> thanks
12:09:08 * hackage propellor 4.0.4 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-4.0.4 (JoeyHess)
12:10:29 <Eduard_Munteanu> I should try propellor sometime. I wonder how it compares to more traditional CfMSes.
12:10:36 <pavonia> In the language-javascript package, does anyone know how to convert a string literal into a parsed Haskell string? I.e., for "\"foo\\u003F\"" I want the result to be "foo?", not just (JSStringLiteral "\"foo\\u003F\"") again
12:11:08 * hackage system-locale 0.2.0.0 - Get system locales  https://hackage.haskell.org/package/system-locale-0.2.0.0 (cocreature)
12:13:12 <EvanR> > text "\"foo\\u003F\""
12:13:14 <lambdabot>  "foo\u003F"
12:13:39 <Eduard_Munteanu> pavonia, have you tried renderToText?
12:14:14 <Eduard_Munteanu> https://hackage.haskell.org/package/language-javascript-0.6.0.9/docs/src/Language-JavaScript-Pretty-Printer.html
12:14:22 <pavonia> Eduard_Munteanu: Yes, that just gives the same thing as a Text
12:14:31 <EvanR> it seems like theres literally a backslash there
12:15:18 <EvanR> in the js code
12:15:57 <Eduard_Munteanu> In the decoded AST.
12:16:20 <EvanR> somebodys got something wrong somewhere
12:17:27 <pavonia> Why I do is (parseUsing Grammar.parseExpression "\"foo\\u003F\"" "") and the result is (Right (JSAstExpression (JSStringLiteral _ "\"foo\\u003F\"") _))
12:17:30 <EvanR> > text (text "\"foo\\u003F\"")
12:17:33 <lambdabot>  error:
12:17:33 <lambdabot>      • Couldn't match type ‘Doc’ with ‘[Char]’
12:17:33 <lambdabot>        Expected type: String
12:17:59 <pavonia> I expect a parser to actually give the parsed string literal, not the same thing as the input
12:18:18 <Eduard_Munteanu> pavonia, why aten't you giving it unicode?
12:18:24 <Eduard_Munteanu> *aren't
12:19:16 <Eduard_Munteanu> > "foo\u003F"
12:19:17 <pavonia> I'm trying to convert from this AST to another, I have not influence on what input is to be parsed
12:19:19 <lambdabot>  <hint>:1:6: error:
12:19:19 <lambdabot>      lexical error in string/character literal at character 'u'
12:19:32 <EvanR> foo("foo\u003f") seems like should be something like Apply (StrLit "foo\\u003f")
12:19:50 <EvanR> Apply <expr for foo> (StrLn "foo\\u003f")
12:19:56 <EvanR> Lit
12:20:13 <EvanR> because this is syntax not semantics
12:20:35 <EvanR> if you reduced it during parsing, you couldnt put the js code back
12:20:41 <pavonia> It even keeps the quote chararcter, which feels just plain wrong to me for a parser
12:20:53 <EvanR> because js string literals are either "foo" or 'foo'
12:21:37 <EvanR> its wrong for a js to haskell converter
12:21:51 <EvanR> but thats another step
12:22:03 <pavonia> So I need another package to actually parse the already parsed input?
12:22:43 <glguy> The language-lua parser does the same thing, the parser preserves the original string literal syntax so that you can round-trip it through the pretty-printer, and then I have another module for decoding string literals to string values
12:23:08 <EvanR> its parsers all the way up
12:23:43 <sproingie> some convenience functions would have been nice, to be sure.  but that'd make the package less orthogonal
12:25:56 <sproingie> then again it already depends on text
12:29:57 <pavonia> Oh well, that package already has a module for string conversion but it's not exposed
12:30:12 <EvanR> the minutia of how to convert js string literals to "strings" seems like ... should be in language-javascript
12:33:53 <glguy> pavonia: That seems like an oversight that the module wasn't exposed
12:34:32 <glguy> The definitions aren't even used in the package itself
12:35:38 * hackage ether 0.5.1.0 - Monad transformers and classes  https://hackage.haskell.org/package/ether-0.5.1.0 (int_index)
12:35:54 <glguy> pavonia: https://github.com/erikd/language-javascript/issues/61
12:36:18 <pavonia> glguy: On the other hand, I don't see a function in there removing the outer quotes
12:36:40 <pavonia> Nice, thanks
12:37:12 <glguy> pavonia: That's probably worth filing as another issue. Knowledge of how to strip quotes would be an appropriate function for that module
12:55:43 <MitchellSalad> to whomever: thoughts on 'gl' vs 'GLUT' vs ??? - helping teach a haskell newbie and he wants to do some graphics stuff
12:56:00 <MitchellSalad> to make frogger/pacman type games
12:56:40 <Tuplanolla> There are nice layers on top of GLUT called `gloss` and `not-gloss`, MitchellSalad.
12:57:12 <Tuplanolla> They're quite limited in what they can do, but don't require you to care about any details either.
12:57:38 <EvanR> oh, not-gloss eh
13:06:11 <EvanR> nice it can do 3D
13:06:20 <EvanR> and has more text
13:25:16 <iqubic> :t uncurry
13:25:18 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:25:20 <ReinH> gl is raw OpenGL bindings
13:25:43 <ReinH> glut is a higher level "utility toolkit"
13:26:02 <ReinH> so it's an apples to oranges comparison
13:29:15 <ReinH> Note that the original glut isn't open source and the Haskell glut package actually attempts to use freeglut instead if available.
13:30:31 <imalison> is there a way to `read` into a Data.Dynamic as the type of a TypeRep?
13:32:30 <lyxia> no
13:33:01 <lyxia> You need a Read constraint, which a TypeRep does not provide.
13:34:11 <pikajude> and frankly, that would be preposterous!
13:34:25 <imalison> pikajude: why?
13:35:40 * hexagoxel cannot make sense of "type of a TypeRep"
13:36:21 <imalison> hexagoxel: I meant as the type represented by the type rep
13:36:22 <pikajude> the type of a TypeRep would be *, right
13:36:34 <pikajude> err, no, that's the type of TypeRep
13:36:35 <imalison> well thats a kind
13:36:37 <pikajude> the type of a TypeRep is TypeRep
13:36:43 <pikajude> imalison: there's no difference now though
13:37:01 <hexagoxel> (TypeReps from rank1dynamic are Binary though)
13:37:57 <geekosaur> imalison, TypeRep does not provide what you want. Generics *might*, but in general that kind of dynamic programming is not really Haskell's strong spot
13:39:43 <imalison> geekosaur: its definitely possible to do this, as I was able to do it with my own "TypeRep" that held on to the proxy value and added a read constraint
13:40:29 <geekosaur> right, but that's not stock TypeRep. and it's why I pointed to Generics which provides more tools on top of TypeRep
13:41:06 <hexagoxel> imalison: are you looking to serialize Dynamics?
13:41:11 <geekosaur> also in 8.2 TypeRep will be type-indexed which will enable it to keep track of more stuff itself
13:45:10 <EvanR> if i am using rational numbers as part of a simulation, and due to whatever influence these rationals keep getting more complex because something gets introduced that doesnt factor right
13:45:16 <MitchellSalad> Tuplanolla: thanks!
13:45:33 <EvanR> is there some standard mechanism to "round" them in a nice way
13:46:37 <EvanR> dyadic rationals or something
13:46:40 <monochrom> Convert to continued fraction, truncate, convert back to rational.
13:46:44 <EvanR> ah
13:47:21 <monochrom> Of course, the "convert to" and "truncate" can be done in one swoop, i.e., while coverting, stop early.
13:47:26 <EvanR> the time has come to get into continued fractions. this was not taught in school
13:50:30 <ertes> @let ratTrunc d x = liftA2 (%) ((`div` d) . numerator) ((`div` d) . denominator)
13:50:32 <lambdabot>  Defined.
13:51:02 <monochrom> Why is x unused? :)
13:51:08 <ertes> whoops
13:51:09 <ertes> @undef
13:51:09 <lambdabot> Undefined.
13:51:12 <ertes> @let ratTrunc d = liftA2 (%) ((`div` d) . numerator) ((`div` d) . denominator)
13:51:13 <lambdabot>  Defined.
13:51:25 <EvanR> does that do the same thing as what monochrom said
13:51:39 <monochrom> No.
13:51:43 <EvanR> ok
13:51:59 <ertes> EvanR: no, mine does a much dumber thing
13:52:06 <ertes> > fromRational (ratTrunc 10 1.572) :: Double
13:52:07 <EvanR> getting the continued fraction of a rational seems to be a right fold
13:52:08 <lambdabot>  1.56
13:52:13 <monochrom> To be fair, I don't really know. Haven't proved or disproved.
13:52:26 <ertes> (divide precision roughly by 10)
13:52:29 * EvanR thinks very hard
13:52:31 <ertes> tends towards 0
13:52:40 <imalison> hexagoxel: well im reading so sort of deserialzing, yes
13:52:53 <ertes> err, no…  tends towards non-sense =)
13:52:55 <monochrom> But truncating continued fractions is well-understood, i.e., people know how much you're dropping.
13:53:32 <imalison> geekosaur: ah thats good to know, have those changes already been made?
13:53:48 <EvanR> or an unfoldr
13:53:53 <ertes> > map fromRational (iterate (ratTrunc 10) 1.526385) :: Double
13:53:55 <lambdabot>  error:
13:53:56 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘[Double]’
13:53:56 <lambdabot>      • In the expression:
13:54:02 <ertes> > map fromRational (iterate (ratTrunc 10) 1.526385) :: [Double]
13:54:04 <lambdabot>  [1.526385,1.52635,1.526,1.52,1.5,*Exception: Ratio has zero denominator
13:54:13 <geekosaur> imalison, 8.2.1 is in second release candidate
13:54:24 <geekosaur> hopefully will be released later this month
13:54:38 <geekosaur> you can try installing the C and look at the new docs
13:54:43 <geekosaur> er, installing the RC
13:55:57 <imalison>   [13:53]
13:55:58 <imalison> ERC> geekosaur: yeah seems like theres a bunch here about it as well https://ghc.haskell.org/trac/ghc/wiki/Typeable
13:58:38 * hackage quickcheck-instances 0.3.13 - Common quickcheck instances  https://hackage.haskell.org/package/quickcheck-instances-0.3.13 (phadej)
14:00:02 <EvanR> > unfoldr (\x -> let (i,r) = properFraction x in if r == 0 then Nothing else Just (i, recip r)) (415 % 93)
14:00:04 <lambdabot>  [4,2,6]
14:00:10 <EvanR> should be [4,2,6,7] :(
14:01:37 <EvanR> > unfoldr (\x -> if x == 0 then Nothing else let (i,r) = properFraction x in Just (i, recip r)) (415 % 93)
14:01:39 <lambdabot>  [4,2,6,7*Exception: Ratio has zero denominator
14:01:54 <EvanR> almost
14:02:20 <ertes> > fromRational (415 % 93) :: Double
14:02:23 <lambdabot>  4.462365591397849
14:02:46 <EvanR> right, whats cool about continued fractions is you get a more compact representation of the fractions content
14:02:52 <EvanR> 4 2 6 7
14:03:16 <EvanR> well, potentially, if its content isnt very much
14:04:42 <EvanR> > unfoldr (\x -> if x == 0 then Nothing else let (i,r) = properFraction x in Just (i, if r == 0 then 0 else recip r)) (415 % 93)
14:04:44 <lambdabot>  [4,2,6,7]
14:04:45 <ertes> > 4 + recip (2 + recip (6 + recip 7)) :: Rational
14:04:47 <lambdabot>  415 % 93
14:05:35 <EvanR> > unfoldr (\x -> if x == 0 then Nothing else let (i,r) = properFraction x in Just (i, if r == 0 then 0 else recip r)) (355 % 113)
14:05:37 <lambdabot>  [3,7,16]
14:06:59 <iqubic> :t unfoldr
14:07:01 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:07:19 <byorgey> > take 20 $ unfoldr (\x -> if x == 0 then Nothing else let (i,r) = properFraction x in Just (i, if r == 0 then 0 else recip r)) (exp 1)
14:07:21 <lambdabot>  [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1]
14:07:49 <EvanR> heh
14:07:54 <byorgey> =)
14:08:04 <byorgey> > take 20 $ unfoldr (\x -> if x == 0 then Nothing else let (i,r) = properFraction x in Just (i, if r == 0 then 0 else recip r)) (sqrt 2)
14:08:06 <lambdabot>  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
14:08:09 <EvanR> e looks like an IQ test
14:08:14 <byorgey> hehe
14:09:27 <EvanR> haskell reigns
14:09:44 <byorgey> > take 5 $ unfoldr (\x -> if x == 0 then Nothing else let (i,r) = properFraction x in Just (i, if r == 0 then 0 else recip r)) pi  -- this is why 355 % 113 is such a good approximation for pi
14:09:46 <lambdabot>  [3,7,15,1,292]
14:10:22 * EvanR thinks about the relationship between 16 and 15,1,292
14:10:45 <EvanR> if any
14:10:55 <byorgey> there is
14:11:49 <EvanR> so are these truncations the "best" approximations of rationals?
14:11:58 <byorgey> 1/292 is very small, so if we just treat it as zero, we get  1/(15 + 1/(1 + 1/292)) ~ 1/(15 + 1/(1 + 0)) ~ 1/16
14:12:15 <EvanR> ah 15 + 1
14:12:24 <byorgey> EvanR: yes, in fact, they are.  They are called "convergents".
14:13:11 <EvanR> \o/
14:13:21 <byorgey> if you measure the quality of a rational approximation as the ratio of the error to the size of the denominator
14:14:43 <byorgey> so the reason 355 % 113 is a quite good approximation is that the next term of the continued fraction is large, so the denominator goes up a lot but the approximation does not get much closer
14:15:04 <EvanR> > 355 / 113
14:15:06 <lambdabot>  3.1415929203539825
14:15:43 <EvanR> > unfoldr (\x -> if x == 0 then Nothing else let (i,r) = properFraction x in Just (i, if r == 0 then 0 else recip r)) (314 % 100)
14:15:45 <lambdabot>  [3,7,7]
14:15:52 <EvanR> weak
14:16:27 <byorgey> > 3 + 1/(7 + 1/(15 + 1/(1 + 1/292)))  -- this is closer to pi, but...
14:16:29 <lambdabot>  3.1415926530119025
14:16:40 <byorgey> > 3 + 1/(7 + 1/(15 + 1/(1 + 1/292))) :: Rational   -- it has a very large denominator
14:16:42 <lambdabot>  103993 % 33102
14:16:56 <byorgey> (relative to the increase in accuracy)
14:17:17 <EvanR> pi's expansion seems to be oddball compared to e and sqrt 2
14:18:12 <byorgey> indeed.  I don't remember the details but I think there are open questions relating to how random/well-distributed/etc. the terms of pi's continued fraction are
14:18:52 <EvanR> what lens do you need to look through to see a pattern in pi
14:19:06 <byorgey> ...write it in base pi?
14:19:13 <EvanR> besides that!
14:19:16 <EvanR> no cheating
14:19:20 <Tuplanolla> Circular?
14:19:28 <EvanR> lol
14:19:33 <ertes> EvanR: the zeta function
14:19:42 <EvanR> oh?
14:21:08 <Gurkenglas> EvanR, base 16 https://www.math.hmc.edu/funfacts/ffiles/20010.5.shtml
14:21:23 <ertes> EvanR: https://en.wikipedia.org/wiki/Particular_values_of_the_Riemann_zeta_function#Even_positive_integers
14:23:29 <EvanR> BPP formula
14:23:39 <EvanR> surprising
14:24:05 <ertes> EvanR: the zeta function even relates the prime numbers to π
14:24:11 <EvanR> these zeta function values not so much
14:25:57 <ryantrinkle> is there a way with WAI to combine two staticApp's, such that 400s and such will fall through from one to the next?
14:26:04 <ryantrinkle> (or any kind of apps)
14:27:37 <ertes> ryantrinkle: a middleware can transform apps in arbitrary ways, so it's at least technically possible
14:27:59 <ryantrinkle> ertes: that's what i figured, but i'm just surprised it isn't available off the shelf
14:29:35 <ertes> ryantrinkle: i guess WAI considers itself too low-level
14:29:47 <ryantrinkle> ertes: ah
14:30:12 <ertes> but yeah, no technical reason…  i wouldn't be surprised, if a patch for that would be merged
14:35:38 * hackage pinch 0.3.2.0 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.3.2.0 (abhinav)
14:40:21 <iqubic> I'm having trouble with Haskell Arrays.
14:40:37 <iqubic> And Data.Array
14:40:54 <iqubic> I have an array indexed by (Int, Int)
14:41:16 <iqubic> so basically a 2D array
14:41:33 <iqubic> and I want to get all the rows of this array in a List of Lists.
14:41:52 <iqubic> Is that possible?
14:42:53 <EvanR> you could use fmap
14:43:17 <EvanR> to go from Array (Int,Int) a to Array Int [a]
14:43:23 <iqubic> How will that help me?
14:43:28 <EvanR> er no
14:43:32 <iqubic> How can that help me?
14:43:34 <EvanR> you have to use ixmap
14:43:40 <EvanR> since the index type changes
14:43:55 <EvanR> well once you do the above move, you can convert the result to a list
14:43:59 <EvanR> which wil be a [[a]]
14:44:06 <iqubic> Can I see an example?
14:44:34 <Tuplanolla> That's terrible advice. Just use a list comprehension.
14:45:04 <iqubic> Currently what I have is this: getByPredicate p state = map snd $ filter (not . p . fst) (assocs state)
14:45:07 <EvanR> huh
14:45:13 <iqubic> But that really doesn't work.
14:45:45 <ertes> iqubic: first of all: what do you need the list of lists for?
14:45:45 <iqubic> It's supposed to get the element at any position whose index satifies p
14:46:02 <EvanR> yeah my way wont work, envermind
14:46:06 <iqubic> ertes: I'm making a TicTacToe game.
14:46:19 <iqubic> And I need some way to do win detection.
14:46:52 <ertes> iqubic: ah
14:47:05 <iqubic> I have a function that takes a single row and tells me if that row contains a 3 in a row, and which person has that row.
14:47:42 <ertes> iqubic: so by "row" you need any properly aligned three cells, right?
14:47:58 <iqubic> yes.
14:48:03 <iqubic> That is correct.
14:48:30 <EvanR> you can make a list of all indexes that denote three inline cells
14:48:37 <EvanR> a list of list of indexes
14:48:46 <EvanR> then check each against the array
14:48:53 <ertes> iqubic: the easy method is to first write a list of all horizontal rows, then all vertical rows, then all diagonal ones, then concatenate the three
14:49:22 <EvanR> the answer is "X won, O won, or noone won"
14:49:25 <iqubic> And how do I check that against my array indexed by (Int, Int)
14:49:26 <EvanR> for each 
14:49:51 <EvanR> [(0,0), (1,1), (2,2)] is an example "row"
14:49:55 <ertes> iqubic: EvanR's way is also good:  make a list of lists of indices, then use two layers of 'map' to turn it into a list of rows
14:50:24 <ertes> (a row being a list of cell contents)
14:50:49 <iqubic> Can I see an example?
14:51:02 <EvanR> map (board !) allRows
14:51:17 <EvanR> er, map (map (board !))
14:51:46 <iqubic> How will applying map twice work?
14:51:57 <EvanR> since the argument is a list of lists
14:53:12 <iqubic> Can't I just create a list of (Int, Int) and use Map only once? Or will that not work?
14:53:16 <ertes> iqubic: let xs be a list of lists of stuff, then (map f xs) maps over the elements of that list, which are lists of stuff
14:53:33 <EvanR> each test is on multipeple cells
14:53:37 <EvanR> multiple
14:54:12 <EvanR> each turn you will test all possible places a win condition could be
14:54:33 <EvanR> a "place" is a list of 3 indexes
14:54:41 <EvanR> of all test results, at most 1 is a win
14:55:54 <EvanR> the elements of map (map (!)) allPlaces will be lists of marks, which you pass to your test function you mentioned
14:56:08 <EvanR> er, map (map (board !))
14:56:18 <iqubic> So how do I take a [[(Int, Int)]] and map the (Int, Int) into their corresponding elements?
14:56:28 <EvanR> with map (map (board !))
14:56:33 <iqubic> Oh. I see.
14:57:58 <EvanR> and now i see what Tuplanolla was saying, if you wanted a slice from an array, you would map (board!) over the list of indeces in that slice which could be easily specified with a list comprehension
14:58:58 <iqubic> Is that simpler
14:58:59 <iqubic> ?
14:59:07 <EvanR> its exactly the same
14:59:26 <ertes> it's a more broken down solution
14:59:34 <iqubic> But is the code easier to read?
14:59:41 <ertes> generating the indices is a non-trivial problem in itself
14:59:47 <EvanR> this question is funny
14:59:59 <EvanR> why dont you write the code and see?
15:00:03 <iqubic> ertes: How should I generate the indices?
15:00:24 <ertes> iqubic: first try to see a pattern, then encode that pattern using list comprehensions
15:00:39 <ertes> iqubic: start by writing a list comprehension for all horizontal rows
15:01:05 <iqubic> I'm not sure how to do that.
15:01:17 <ertes> have you used list comprehensions?
15:01:23 <Tuplanolla> You'd check winners on the diagonal with `(null . drop 1 . group) [board ! (i, i) | i <- [1 .. boardSize]]`, iqubic and EvanR.
15:01:42 <Tuplanolla> Rows and columns would work similarly.
15:02:00 <iqubic> Tuplanolla: what does that code do?
15:02:03 <EvanR> huh
15:02:16 <Tuplanolla> This is reusable if you abstract over the sets to draw from.
15:02:35 <EvanR> iqubic: have you look at list comprehensions yet
15:02:42 <EvanR> if not, do that
15:02:48 <iqubic> I know how list comprehensions work.
15:02:53 <EvanR> use ghci to experiment
15:03:11 <iqubic> What does (null . drop 1 . group) do?
15:03:38 <EvanR> do you know how function composition works
15:04:02 <Tuplanolla> Try each one in turn, iqubic.
15:04:28 <iqubic> EvanR: I do understand how function composition works
15:04:35 <EvanR> do you konw how group works
15:05:29 <iqubic> No.
15:05:37 <iqubic> I have no idea what group is doing there.
15:05:38 <EvanR> check it out in ghci
15:05:45 <EvanR> first with the type, then experiments
15:06:00 <glguy> other than asking in IRC, do you know how you could figure out what it does?
15:06:24 <iqubic> :t group
15:06:25 <lambdabot> Eq a => [a] -> [[a]]
15:06:39 <iqubic> I see what group does.
15:06:42 <MitchellSalad> > group [1,2,2,3,3,3,2,2,1]
15:06:44 <lambdabot>  [[1],[2,2],[3,3,3],[2,2],[1]]
15:06:59 <EvanR> do you know what drop 1 does
15:07:02 <EvanR> etc, etc, etc
15:07:11 <EvanR> this process has a limit
15:07:34 <iqubic> I get what drop 1 does.
15:07:38 <EvanR> ok
15:07:50 <EvanR> by the fied point theorem, you now know what the whole thing does
15:08:14 <iqubic> (null . drop 1 . group) checks to see if the entire list is the same.
15:09:20 <ertes> iqubic: nope…  do you *really* know what 'group' does?
15:09:38 <ertes> you can't really know it by looking at the type alone
15:09:49 <MitchellSalad> ertes: ?? What he said is correct
15:09:52 <EvanR> i think that was right
15:10:10 <ertes> oh
15:10:27 <MitchellSalad> ertes: do you *really* know what 'group' does?
15:10:38 <MitchellSalad> =P
15:10:46 <ertes> sorry, i read that wrong =)
15:10:54 <EvanR> *do* *you* really *know* *what* *'group'* *does*
15:11:13 <ertes> *do you really know what 'group' does?*
15:11:15 <Tuplanolla> The point is that your solution will be simpler if you treat both players equally and perform your geometry in the index space, iqubic.
15:11:34 <iqubic> Tuplanolla: I do treat both players the same.
15:12:04 <iqubic> I have a function that will test a row of 3. What I need is a way to get the proper rows of three.
15:12:41 <EvanR> we pretty much gave you all the code verbatim at this point
15:12:51 <EvanR> besides typing it in, all thats left for you to do is understand it
15:13:03 <Tuplanolla> For the indices `i` and `j` you have the identity diagonal on `i == j`, the exchange diagonal on `i == n - j` (for length `n`), rows on `i == k` (for some `k`) and columns on `j == k` (for some `k`).
15:13:20 <Tuplanolla> What you want is the simplest generating function to produce these rules.
15:14:21 <iqubic> Yeah I do.
15:20:18 <iqubic> SO I have this: rows = [(0,i) | i <- [0,1..size]] but that only generates a single row.
15:20:46 <iqubic> I want to generate rows from 0 to size. Because I have a square board.
15:20:58 <Tuplanolla> You can nest list comprehensions.
15:21:13 <iqubic> How will that help me?
15:21:29 <Tuplanolla> To get more than a single row.
15:22:51 <Cale> > let size = 3 in [[(i,j) | j <- [0..size]] | i <- [0..size]]
15:22:53 <lambdabot>  [[(0,0),(0,1),(0,2),(0,3)],[(1,0),(1,1),(1,2),(1,3)],[(2,0),(2,1),(2,2),(2,3...
15:23:46 <iqubic> I see.
15:24:01 <EvanR> you should try these things yourself in ghci
15:24:40 <iqubic> I will.
15:24:50 <iqubic> Is it fine to fail?
15:27:33 <ertes> @let cell x y f w = fmap back (f ms) where ms | testBit w iSet = Just (testBit w iVal) | otherwise = Nothing; iSet = 2*(3*y + x); iVal = succ iSet; back Nothing = clearBit (clearBit w iSet) iVal; back (Just b) = (if b then setBit else clearBit) (setBit w iSet) iVal
15:27:34 <lambdabot>  Defined.
15:27:45 <ertes> :t cell
15:27:46 <lambdabot> (Bits b, Functor f) => Int -> Int -> (Maybe Bool -> f (Maybe Bool)) -> b -> f b
15:28:11 <iqubic> What is that?
15:28:25 <ertes> a lens into a tic-tac-toe board =)
15:28:45 <ab9rf> heh
15:29:09 <ab9rf> ertes: two-dimensional only, i suppose
15:29:23 <ertes> ab9rf: it's easy enough to generalise that
15:29:34 <ab9rf> i like genrealized tic-tac-toe
15:29:41 <ab9rf> there's some great theorems in that space
15:29:53 <ertes> have you tried solving rubik's hypercube?  (there is an implementation of that)
15:30:04 <ab9rf> once a long time ago, it was confusing
15:30:12 <jadrian> I know that context restrictions in data declarations are depretacted, but this makes the behaviour of class data declarations weird no?
15:30:29 <iqubic> What I'm making is a TicTacToe game with an n by n board.
15:30:58 <ertes> ab9rf: learn the heise method for the regular 3D cube…  you can generalise the technique of commutators and conjugates to 4D
15:31:06 <ab9rf> ertes: nothing that applies to solving a regular cube applies to a hypercube. solving the ultracube is actually closer
15:31:17 <ertes> ab9rf: ^
15:31:25 <ab9rf> aside from the basic idea of commutators and conjugates, sure
15:31:30 <ab9rf> that's universal though
15:31:52 <ab9rf> there's a dimensional parity ting that i only vaguely understand 
15:34:02 <EvanR> what is an ultracube
15:34:12 <ab9rf> 5D
15:34:26 <iqubic> so how do I get the other the diagonal?
15:34:47 <iqubic> the diagonal where (i,j) i /= j
15:34:55 <EvanR> how do you "flip" a number between 0 and n-1
15:35:29 <iqubic> I'm not sure how.
15:35:45 <EvanR> 0 -> 2, 1 -> 1, 2 -> 0
15:35:54 <EvanR> with arithmetic
15:36:30 <iqubic> that's just n - number
15:36:31 <jadrian> so if I have `class C t where data D t`  I would really expect D to have a context restriction
15:36:36 <EvanR> ok
15:37:26 <EvanR> you put contexts on type signatures, not data definitions
15:37:54 <jadrian> EvanR: I could half swallow that argument before we had functions on types
15:38:20 <jadrian> EvanR: once you have type families the rational escapes me
15:38:26 <EvanR> its still the case
15:38:40 <jadrian> I know it is, it just doesn't seem to make sense
15:39:00 <EvanR> a constraint ends up being a runtime dictionary argument
15:39:11 <jadrian> yes
15:39:23 <EvanR> type families are completely at compile time and theres no type level type classes
15:39:27 <jadrian> but not only that
15:39:45 <mniip> type families turn into equality constraints/coercions
15:39:52 <mniip> which are erased
15:40:30 <lpaste> iqubic pasted “Lines of n” at http://lpaste.net/356022
15:41:06 <iqubic> How do I take those lists and turn them into a single [[(Int, Int)]]
15:41:17 <jadrian> but classes do more than that, they also provide for compile time checks
15:41:33 <ReinH> iqubic: ++ them together?
15:42:09 <iqubic> ReinH, will that work?
15:42:25 <ReinH> why wouldn't it?
15:42:39 <iqubic> I have two [[(Int, Int)]] and two [(Int, Int)] 
15:42:46 <jadrian> and these compile time checks, impose useful restrictions on what is valid code
15:43:16 <iqubic> And I want to concatenate the two [[(Int, Int)]] and then append the [(Int, Int)]
15:43:17 <ReinH> why are some of them [[]] and the others []?
15:43:34 <iqubic> Because that's the easiest way to generate the lists.
15:43:45 <ReinH> so... concat the [[]] first?
15:43:47 <jadrian> right now if I have `class C t where data D t` nothing stops me from applying D to a t without an instance of C
15:44:00 <ReinH> er, join
15:44:07 <ReinH> to flatten them
15:44:11 <iqubic> It's the indexes of the lines of a TicTacToe board.
15:44:25 <iqubic> And I want to keep each line seperate.
15:45:01 <ReinH> join rows ++ join cols ++ diagUL ++ diagUR?
15:45:31 <iqubic> What does join do?
15:45:41 <iqubic> :t join
15:45:42 <lambdabot> Monad m => m (m a) -> m a
15:45:49 <jadrian> I know there's been quite a bit of debate about the usefulness of "stuckness" with respect to type families
15:45:52 <ReinH> > join [[1,2],[3,4]]
15:45:54 <lambdabot>  [1,2,3,4]
15:45:57 <ReinH> in this case, it flattens the list once
15:45:58 <jadrian> and how some people consider it wrong behaviour
15:46:01 <iqubic> Nope, I don't want to flatten the lists.
15:46:11 <ReinH> Ok
15:46:30 <ReinH> rows ++ cols ++ [diagUL] ++ [diagUR]?
15:46:32 <jadrian> if one at least could have context restrictions from familes declared in classes, then we'd have a way to constrain that behaviour
15:46:55 <iqubic> ReinH: That's closer to what I want.
15:47:06 <ReinH> If you're checking for a win condition, why not just check the cells themselves?
15:47:10 <ReinH> rather than returning indices
15:48:21 <iqubic> I'm going to get the cells once I have the indices, and then I'll be checking those.
15:48:34 <ReinH> Yes, what I'm asking is why the extra step?
15:49:12 <iqubic> Because that's what Tuplanolla said I should do.
15:49:27 <Tuplanolla> No.
15:49:47 <iqubic> What did you say I should do?
15:50:12 <Tuplanolla> I quite clearly used `!` inside the list comprehension.
15:50:47 <iqubic> Oh. How would that help me?
15:51:03 <Tuplanolla> You don't need to wrangle index lists if you index immediately.
15:52:31 <ReinH> :t zipWith drop [0..]
15:52:32 <lambdabot> [[a]] -> [[a]]
15:52:55 <iqubic> :t zipWith
15:52:55 <ReinH> > zipWith drop [0..] [[1,2,3],[4,5,6],[7,8,9]]
15:52:56 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
15:52:57 <lambdabot>  [[1,2,3],[5,6],[9]]
15:53:07 <iqubic> :t
15:53:12 <iqubic> :t drop
15:53:13 <lambdabot> Int -> [a] -> [a]
15:53:27 <ReinH> > map head $ zipWith drop [0..] [[1,2,3],[4,5,6],[7,8,9]]
15:53:29 <lambdabot>  [1,5,9]
15:53:50 <iqubic> What are you doing?
15:54:04 <ReinH> > map head $ zipWith drop [0..] (map reverse [[1,2,3],[4,5,6],[7,8,9]])
15:54:06 <lambdabot>  [3,5,7]
15:54:13 <ReinH> getting the diagonal elements directly
15:54:48 <iqubic> But I don't have a [[elem]]
15:54:48 <ab9rf> heh
15:54:57 <iqubic> what I have is a Data.Array array
15:55:04 <ReinH> For tic-tac-toe?
15:55:07 <ReinH> It's 3x3.
15:55:20 <nshepperd_> EvanR: but with GADTs and associated type families we have constraints like (a ~ b) that have nothing to do with type class dictionaries
15:55:33 <iqubic> I have a TicTacToe game that's going to be n by n
15:56:07 <ReinH> How big can n be?
15:56:18 <iqubic> n is an Int in my program.
15:56:28 <ab9rf> well, the game gets uninteresting past 11
15:56:43 <iqubic> It does?
15:56:43 <Jinxit> isn't tic-tac-toe on n x n boards either trivial or unwinnable?
15:56:47 <Jinxit> past 3
15:56:49 <ReinH> >maxbound :: Int
15:56:56 <ReinH> > maxbound :: Int
15:56:58 <lambdabot>  error:
15:56:58 <lambdabot>      • Variable not in scope: maxbound :: Int
15:56:58 <lambdabot>      • Perhaps you meant ‘maxBound’ (imported from Prelude)
15:57:07 <ab9rf> Jinxit: it depends on whatyou define as a wiunning condition
15:57:15 <ReinH> anyway, do you expect people to play on 2 million x 2 million boards?
15:57:21 <Jinxit> yeah i meant trivial for 3, unwinnable for n
15:57:24 <Jinxit> in a row
15:57:33 <iqubic> ReinH: No I don't
15:57:40 <ab9rf> if you need n in a row in an n by n grid, it's a first player win for n=1 and n=2, and a draw for n>=3 although there's no proof for n=6 i think
15:57:43 <ReinH> Then how big can n be?
15:58:18 <ab9rf> for one of 6 and 7 there's a proof that it's a draw but no known strategy, and for the other it's not proven that it's a draw but generally believed to be
15:58:38 <ab9rf> for n>=11 there is a generalized drawing strategy that applies for all n 11 or larger
15:58:38 * hackage tasty-discover 3.0.0 - Test discovery for the tasty framework.  https://hackage.haskell.org/package/tasty-discover-3.0.0 (lwm)
15:58:45 <ReinH> anyway, I don't see why rows ++ cols ++ [dialUL] ++ [dialUR] doesn't work
15:58:51 <ReinH> assuming you actually index the array
15:58:54 <Jinxit> feels like we should be able to prove it by exhaustion on those sizes
15:59:04 <Jinxit> given a few GPUs
15:59:45 <iqubic> See I would make it so that my program make requires n in a row on an m x m board, but I don't know how to get all the diagonals.
15:59:54 <iqubic> Just the two major diagonals.
16:00:26 <ab9rf> for m-in-a-row less than n, and for nonsquare boards, the analysis is far more complicated
16:00:37 <ab9rf> 21-by-21 with 5 in a row is a major unsolved problem :)
16:00:52 <iqubic> ab9rf, I'm just doing square boards for now.
16:01:09 <Jinxit> iqubic: just increase the x and y index by 1 for each step
16:01:28 <iqubic> But really, how do I retrieve the diagonals, all of them?
16:01:37 <Jinxit> do it by hand on paper
16:01:48 <Jinxit> might help you figure it out
16:02:08 <ReinH> Generating every n-length row, column, and diagonal is inefficient
16:02:15 <iqubic> The thing is, some diagonals are longer than others, which might be an issue
16:02:29 <ab9rf> ah, it's n>=9 and higher that fall under Hales-Jewitt
16:02:31 <Jinxit> you can stop early
16:02:34 <ab9rf> http://www.weijima.com/index.php?option=com_content&view=article&id=11
16:02:38 <Tuplanolla> For a large board you should use neighbor search instead, iqubic.
16:02:38 * hackage data-msgpack 0.0.10 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.10 (iphydf)
16:02:41 <ReinH> I'd use an algorithm similar to capture detection for chess
16:02:52 <ReinH> or connected components that only checks in straight lines
16:03:11 <ReinH> and short circuits
16:03:11 <iqubic> Tuplanolla: How does a neighbor search work, and is that hard to do in Haskell?
16:03:28 <Tuplanolla> ReinH has some keywords for you, iqubic.
16:04:01 <Jinxit> searching outwards from the most recently placed piece is pretty clever
16:04:19 <ReinH> Jinxit: yes exactly
16:04:41 <ab9rf> if you assume that the most recent move was made on a board that was not already winning, that's a safe bet
16:04:57 <ReinH> ab9rf: which we can prove by induction ;)
16:05:12 <Tuplanolla> ...which we can encode into our types, ab9rf?
16:05:29 <iqubic> I guess I can try searching only around the most recently played square.
16:05:54 <ab9rf> Tuplanolla: that's an intriguing proposal, i'm not sure how to do it though
16:06:59 <ReinH> You could use a bitboard and mask and get it done in a few dozen &s
16:07:26 <teurastaja> hey how do you print all pi's digits?
16:07:33 <iqubic> ReinH, there are 3 states for each cell. X | O | Blank.
16:07:44 <ReinH> iqubic: Yes, so you need two bit boards, one for each player
16:07:56 <ReinH> Just like chess
16:08:04 <teurastaja> if i type pi i only get a few digits
16:08:19 <ReinH> > pi
16:08:20 <iqubic> But that would require me to re-write most of my program.
16:08:21 <lambdabot>  3.141592653589793
16:08:30 <teurastaja> i want more digits
16:08:32 <ReinH> :t pi
16:08:34 <lambdabot> Floating a => a
16:08:43 <ReinH> Then you'll need to use a different representation
16:08:48 <ReinH> > pi :: CReal
16:08:50 <lambdabot>  3.1415926535897932384626433832795028841972
16:09:08 <ReinH> will be as precise and as slow as you want
16:09:25 <teurastaja> how big?
16:09:39 <ReinH> you decide
16:09:52 <teurastaja> i dont have CReal
16:10:03 <iqubic> So if I use a pair of Bit boards, how would I store my game position?
16:10:52 <ReinH> Xs on one board, Os on the other
16:11:04 <ReinH> :info CReal
16:11:22 <ReinH> teurastaja: you can install the numbers or exact-real package
16:11:35 <ReinH> iqubic: one board for Xs, another for Os
16:11:51 <ReinH> This actually scales nicely for very large boards
16:12:09 <iqubic> But what data type do I use to store a bit board?
16:12:15 <ReinH> Word of some sort
16:12:32 <iqubic> Can I still use my (Int, Int) Array?
16:13:08 <ReinH> bitboards can replace or be used in addition to another representation
16:13:24 <ReinH> it's easy enough to make an interface for bitboards that looks like (Int,Int) Array
16:13:58 <iqubic> I'll use a bit board in addition to my other implementation. I don't want to re-write my display function right now.
16:14:06 <ReinH> Ok
16:14:35 <iqubic> I think It'd be really hard to re-write my display function to use bit boards.
16:14:54 <ReinH> If your board is too large for a single Word64, you can use a storable Vector64 and store squares in some ordering, and you don't have to check the entire game space for a win, just the local area around the last move
16:15:11 <ReinH> Which means looking up at most 4 sub-boards
16:15:41 <iqubic> Why is this so complex??
16:15:48 <ReinH> I'm not saying you have to do it this way
16:16:01 <ReinH> It's just a nice solution that has a lot of nice properties
16:16:30 <ReinH> you can store the sub-boards in morton order to improve cache efficiency of lookups, since the boards you need are more likely to be near each other.
16:16:57 <ReinH> or maybe some other space-filling path would be better, but the point is that you can actually do this which is cool
16:17:31 <ReinH> so that you actually could do this efficiently for a 2 million x 2 million board
16:17:42 <ReinH> but you can just use your array if you want
16:18:01 <iqubic> What would be easiest for me to do?
16:18:33 <ReinH> Easiest? Probably an exhaustive search of every possible winning position that contains the last move.
16:18:54 <iqubic> That sounds hard.
16:19:04 <ReinH> It's easy to write. It isn't very efficient.
16:19:15 <Tuplanolla> I think the neighbor search would be the easiest.
16:19:27 <ReinH> if you need 5 in a row, you query the 9x9 sub-board near the last move for every possible winning position
16:19:38 <ReinH> centered on the last move, rather
16:20:15 <ReinH> Tuplanolla: neighbor search is annoying because you might be in the middle of a sequence when you start
16:20:25 <ReinH> so you have to go in one direction and then potentially reverse while keeping count
16:20:51 <ReinH> just generating every 5-length sequence that contains the starting position is probably easier
16:20:53 <Tuplanolla> You just fit each of the four possibilities and measure their lengths.
16:21:15 <iqubic> How will that work Tuplanolla
16:22:07 <ReinH> let's say you start at (5,5). You check (say) (4,4) and it's marked. You check (3,3) and it isn't, so you check (6,6) and so on. When you either stop or get to 5, you have either not won or won.
16:22:21 <Tuplanolla> Like this, iqubic: Assume we're on X. Move left until you find a not-X. Repeat right. Sum the traveled distances.
16:22:22 <ReinH> you do that for each of the 4 directions
16:24:11 <ReinH> (btw the bitboard idea also works well for game of life)
16:24:16 <ReinH> where the scale does matter
16:25:34 <ReinH> the only problem is that it's dense, so it wastes a lot of space
16:25:43 <Tuplanolla> This doesn't work if you board is periodic or some sheared lattice either, but we aren't there yet.
16:26:06 <ReinH> Tuplanolla: sure it does, you just need to separate the notion of neighborhood from the notion of topology
16:26:19 <ReinH> like edwardk's cellular automata thing
16:26:56 <Tuplanolla> That'd be fun to play.
16:26:58 <ReinH> Tuplanolla: it's fun ridiculously over-designing tic-tac-toe algorithms
16:27:08 * hackage parsers 0.12.5 - Parsing combinators  https://hackage.haskell.org/package/parsers-0.12.5 (ryanglscott)
16:27:16 <ab9rf> ReinH: well, you should be able to handle arbitrary board topologies
16:27:37 <ab9rf> what, you want the board imbedded into a hypertorus?
16:27:43 <ReinH> "but what if people want to play on a 2^32x2^32 board?"
16:28:01 <Tuplanolla> I did once make a prototype for playing Tic-Tac-Toe in a crystal (in the physics sense), but visualizing it was so annoying I stopped.
16:28:11 <ab9rf> heh
16:28:27 <ReinH> ab9rf: https://www.schoolofhaskell.com/user/edwardk/cellular-automata/part-3
16:29:12 <ReinH> heh
16:29:29 <ab9rf> ReinH: back in the 1980s i worked on a geometric visualization project for doing embedding on arbitrary differentiable surfaces
16:29:59 <Tuplanolla> I found a picture of it: http://tuplanolla.no-ip.org/tmp/de-fect-toe.png
16:30:00 <ab9rf> steve did most of the hard stuff, i wrote the chunk that handled the differentiation
16:30:30 <ReinH> Tuplanolla: a friend of mine did her thesis on cellular automata with small world properties
16:30:40 <ReinH> basically wormholes
16:32:49 <Tuplanolla> If you want that idea to work, you need 3d Voronoi cell generation and polytope slicing, both of which are really annoying to implement.
16:35:09 <ab9rf> Tuplanolla: ugh, yes, i've run into that problem in some other projects i've worked on 
16:35:26 <ab9rf> Tuplanolla: optimal radio reception coverage plans
16:36:12 <ab9rf> that project quickly descended into a voronoi mess
16:36:21 <Tuplanolla> Physics ruins the day again.
16:37:15 <ab9rf> it's bad enough that determining if a radio at point A can talk to a radio at point B is nontrivial
16:37:33 <ab9rf> there is an algoritm but it's expensive
16:37:49 <ab9rf> and requires terrain mapping data at a fairly high resolution
16:38:11 <ab9rf> the only viable algorithm is a chunk of inscrutable fortran written in the 1960s
16:38:56 <ab9rf> i've gone through it several times and still do not understand the transformation it does on the elevation data in the course of computing path loss
16:51:42 <jetz> what's the meaning of ::: in a function signature?
16:53:02 <hpc> it's an identifier, not syntax
16:53:06 <hpc> so you might be able to hoogle it
16:53:22 <jetz> hmm
16:53:25 <hpc> huh, and there's quite a few results: http://hoogle.haskell.org/?hoogle=%28%3A%3A%3A%29
16:54:17 <jetz> https://www.haskell.org/hoogle/?hoogle=%28%3A%3A%3A%29
16:54:20 <jetz> I guess I used the wrong hoogle
16:54:52 <jetz> so ... it's a lot of things
16:55:26 <hpc> the one i am currently using is still under development, technically
16:55:37 <hpc> though it has for a while so i am not sure if it's stable now or what
16:55:47 <hpc> anyhoo it has slightly better results for obscure things
16:56:51 <jetz> okay
16:56:56 <jetz> this is where I encountered it: https://github.com/wireapp/wire-server/blob/develop/services/cannon/src/Cannon/API.hs#L123
16:57:36 <jetz> and it seems to be decomposed in the next line
16:58:23 <H3X__> i found this on the web:  Types like t ::: Type -> ... indicate polymorphism, with the triple colon denoting that the value of this type parameter should be inferred at uses. 
16:58:23 <jetz> more context: I'm quite new to haskell
16:59:38 <jetz> hmm, okay
17:01:31 <H3X__> never seen it before myself though (newbie too)
17:03:38 * hackage tasty-discover 3.0.1 - Test discovery for the tasty framework.  https://hackage.haskell.org/package/tasty-discover-3.0.1 (lwm)
17:04:56 <jetz> it sounds like it's specifying which types it accepts for that argument?
17:05:33 <jetz> like a logical or operator
17:06:08 * hackage trifecta 1.7 - A modern parser combinator library with convenient diagnostics  https://hackage.haskell.org/package/trifecta-1.7 (ryanglscott)
17:06:34 <jetz> no, that's definitely wrong
17:20:44 <jetz> IntelliJ is too dumb to tell me which package it's getting the definition of (:::) from -_-
17:21:57 <jetz> I *think* it's for heterogeneous lists
17:26:35 <doyougnu> Here is the hoogle output from spacemacs mode on (:::) => 
17:26:35 <doyougnu> Data.Monoid.MList type (:::) a l = (Option a, l)
17:26:36 <doyougnu> Yi.MiniBuffer newtype (:::) t doc
17:26:36 <doyougnu> Data.Predicate data (:::) a b
17:26:40 <doyougnu> Data.Predicate (:::) :: a -> b -> (:::) a b
17:26:44 <doyougnu> Generics.RepLib.RepAux (:::) :: a -> R a -> Typed a
17:26:45 <doyougnu> Imm.Prelude type (:::) a b = (a, b)
17:26:46 <doyougnu> Data.OverloadedRecords type (:::) (l :: Symbol) (a :: *) = '(l, a)
17:35:38 * hackage timezone-series 0.1.8 - Enhanced timezone handling for Data.Time  https://hackage.haskell.org/package/timezone-series-0.1.8 (YitzGale)
17:55:05 <julianleviston> Reading Chris Done’s data-typeable article and I came across the following fragment, but how does that list of [Nothing,Just] exist? DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]} http://chrisdone.com/posts/data-typeable
17:56:51 <julianleviston> mmm…. ok, they must just be printing like that… Data.Data.dataTypeConstrs :: Data.Data.DataType -> [Data.Data.Constr]
17:57:25 <julianleviston> Constr is actually a 5-field data constructor. Ok.
17:57:52 <monochrom> Yeah, it's the Show instance printing just a "meaningful name"
17:59:00 <mizu_no_oto> Is it possible to produce results  productively/lazily with Wreq?  In particular, I'm trying to consume the Twitter streaming API, which returns a series of newline-delimited json objects for as long as you're connected to it.
17:59:16 <mizu_no_oto> Or is there another library I should be looking at?
18:00:32 <quchen> mizu_no_oto: Doesn’t wreq give you a lazy bytestring?
18:00:37 <glguy> or should you be using Twitter?
18:00:57 <julianleviston> monochrom: yeah, cool :) thanks.
18:01:01 <glguy> lazy ByteString doesn't mean lazy loading
18:01:19 <quchen> No, but it sounds like it could
18:03:25 <julianleviston> mizu_no_oto: is something like https://hackage.haskell.org/package/twitter-conduit going to be useful?
18:05:13 <n_blownapart> if anyone is still interested in my stack installation plight, I removed stack and tried to install the debian package haskellplatform. I got this error. please see first and last lines: "you have held broken packages"
18:05:18 <mizu_no_oto> quchen: It does.  But "L.split (BS.c2w '\r') . view responseBody <$> getWith oauthToken "https://stream.twitter.com/1.1/statuses/sample.json"" just hangs in ghci.
18:05:33 <n_blownapart> https://nopaste.me/view/aef25520
18:05:42 <mizu_no_oto> instead of printing out a list in a productive way
18:12:08 * hackage timezone-olson 0.1.8 - A pure Haskell parser and renderer for binary Olson timezone files  https://hackage.haskell.org/package/timezone-olson-0.1.8 (YitzGale)
18:13:18 <mizu_no_oto> julianleviston: it looks like that doesn't expose the firehose or sample endpoints.
18:14:50 <mizu_no_oto> What's interesting is that both the firehose and sample endpoints are commented out in the export list in https://github.com/himura/twitter-conduit/blob/master/Web/Twitter/Conduit/Stream.hs, so I'm not sure what the story is, there.
18:27:19 <julianleviston> mizu_no_oto: there’s something called twitter_hs I think that might be better, but you wanted streaming, so...
18:28:51 <julianleviston> sorry hs-twitter https://hackage.haskell.org/package/hs-twitter
18:30:11 <mizu_no_oto> julianlevision: I'm trying to consume twitter's streaming API; I don't require a streaming library per se, just the ability to produce and consume incremental results (which could just be as simple as consuming a lazily produced list).
18:30:57 <mizu_no_oto> Basically, I need to be able to process the data before the connection closes and while there's still more data coming in.
18:34:14 <mizu_no_oto> It looks like hs-twitter is primarily for posting tweets or manipulating a user's profile; not consuming the streaming API (which sends you either 1% or 100% of the tweets, in real time as people tweet them)
18:47:47 <isovector> is it possible to get an equivalent type sig to compile? `entity :: Iso' Entity (forall e. IsEntity e => e)`
18:47:57 <isovector> i get a warning about impredicative polymorphism
18:48:55 <blackdog> mizu_no_oto: i've used twitter-conduit for this before.
18:49:35 <julianleviston> mizu_no_oto: so this doesn’t do what you want? https://github.com/himura/twitter-conduit/blob/master/Web/Twitter/Conduit/Stream.hs#L57
18:49:42 <lyxia> isovector: are you sure   IsEntity e => Iso' Entity e   is not sufficient for your needs
18:50:24 <isovector> lyxia: yeah, `Entity` is an existentalized GADT over that constraint
18:50:30 <julianleviston> mizu_no_oto: consuming twitter’s streaming API **does** require a streaming library, I’d say.
18:51:34 <lyxia> isovector: then even with impredicative polymorphism what you wrote wouldn't work, you're equating an existential type with an universal one.
18:51:57 <mbw> What is GHC (nopie)?
18:51:58 <isovector> so i have an `Iso` between `Entity` and the existentalized constrained `e`, and i also have a `Prism' Entity e` -- but that prism isn't helpful :(
18:53:34 <mbw> I did an OS upgrade, an suddenly stack wouldn't build anymore and asked me to invoke it with "--install ghc". Now it is installing this nopie thing?
18:53:37 <isovector> lyxia: is there something else I can do here? i have a list of existentialized things, with constraints on the existentialism that give me prisms for each thing
18:54:09 <mbw> Portal jokes aside, is this something special?
18:55:31 <lyxia> isovector: What for?
18:56:42 <geekosaur> mbw, recent ubuntu needs a version of ghc modified to turn off position-independent executables, which are default on
18:57:00 <geekosaur> ...and if it's not turned off then stuff refuses to load or run. (security related but not very)
18:57:08 <mniip> isovector, you can't write a function 'Entity -> (IsEntity e => e)'
18:57:18 <geekosaur> I think ghc 8.2 makes this unnecessary, but older versions need it
18:57:31 <mbw> geekosaur: So currently no dynamic linking for me?
18:57:37 <geekosaur> er?
18:57:51 <mbw> I thought fpic was necessary for that.
18:57:54 <geekosaur> this is not related to dynamic linking
18:57:59 <isovector> lyxia: trying to keep a heterogeneous collection of things, and use a typeclass to provide prisms X Y and Z, which if they match indicate the thing contained has functionality X Y or Z
18:58:54 <geekosaur> it's related to ASLR (address space layout randomization)
18:59:23 <mbw> Ok I think I can deal with that.
18:59:40 <geekosaur> which is a security thing that some business and governmental entities require, but in practice stops only a tiny handful of attacks
19:00:32 <geekosaur> and in ghc < 8.2 (possibly < 8.0? don't recall) ASLR breaks ghc's heap management
19:01:17 <geekosaur> and causes ghci's (not ghc's! except in TH) dynamic loader to fail in bizarre ways
19:02:09 <geekosaur> (mostly because it does about 90% of the job of the system linker and falls on its face if it encounters the rest. attempts to use the system linker have generally met with problems)
19:02:38 <mbw> So are the canonical folks doing some (more) non-standard stuff, since it appears to be os specific?
19:02:40 <lyxia> isovector: can you show actual code? I also don't want to encourage using what currently sounds like an antipattern.
19:03:00 <geekosaur> it'll be in next debian stable
19:03:25 <geekosaur> remember that ubuntu is more or less debian testing
19:03:41 <mbw> Yeah I notice that time and again...
19:03:55 <geekosaur> (with canonical addons, sure, but usually things show up in ubuntu and then the next debian stable)
19:04:58 * geekosaur has a sneaking suspicion testing doesn't get as well tested as it used to because everyone knows ubuntu'll be testing it for them...
19:06:49 <mbw> But what exactly caused it to break? I was using a stack-installed 8.0.2 before the OS upgrade, after all.
19:07:49 <mbw> But then maybe I was using nopie the whole time and didn't notice...
19:08:53 <geekosaur> what exactly was the upgrade?
19:09:33 * geekosaur would have to dig archives to see exactly which ubuntu version slipped default-PIE/prep for ASLR in
19:09:48 <mbw> From 16.04 to 16.10. So there's still one more to go...
19:10:08 <geekosaur> 16.10 sounds right for default PIE actually
19:10:54 <geekosaur> anyway you're not the only one, you're just later than many of the others; this hit during 8.0.2 RC iirc and caused major headaches
19:11:12 <geekosaur> hm, no, 8.0.1 even
19:11:24 <glguy> the issue is just that the defaults changed
19:11:50 <glguy> so ghc though it was getting one thing when not specifying a flash and got another
19:12:11 <glguy> a flag*
19:12:39 <mbw> So the gcc hardening propagated to ld, which causes issues with ghc?
19:13:15 <mbw> Since I thought code generation was independent of gcc by now.
19:17:54 <mbw> Feel free to tell me if this question is incredibly stupid :/
19:18:16 <julianleviston> lpaste is down
19:18:19 <exio4> mbw: no question is stupid!
19:19:04 <mbw> exio4: I asked a lot of questions today, so statistically, some have to be :)
19:20:04 <julianleviston> “it’s useful to ask any actual question we may have” may be a better way to phrase that :)
19:20:58 <julianleviston> asking questions that don’t fit stack overflow there are quickly shot down, for example
19:21:13 <julianleviston> So the form seems to matter quite a bit.
19:21:22 <iqubic> :t min
19:21:24 <lambdabot> Ord a => a -> a -> a
19:21:29 <mbw> Even good ones are closed as off-topic, unfortunately.
19:21:31 <iqubic> :t max
19:21:33 <lambdabot> Ord a => a -> a -> a
19:25:18 <iqubic> Does Int have an Ord instance?
19:26:09 <iqubic> :t unfoldl
19:26:11 <lambdabot> error:
19:26:11 <lambdabot>     • Variable not in scope: unfoldl
19:26:11 <lambdabot>     • Perhaps you meant one of these:
19:26:16 <iqubic> :t unfoldr
19:26:17 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:26:29 <mbw> Holy smokes. I just noticed that my small gtk toy programs are ~30MB in size.
19:26:40 <julianleviston> I have a question: https://gist.github.com/JulianLeviston/4c60dbe99d88160a41459efa40ec2efd#file-syntaxlensing-hs-L43
19:26:55 <julianleviston> (The question is the linked-to line in that file, which has the code in it relating to the question)
19:27:39 <julianleviston> It’s about lensing and folding or traversing with Data.Data.Lens and scrap your boilerplate stuff
19:28:20 <julianleviston> iqubic: yeah, it does
19:28:42 <julianleviston> > (1 :: Int) < (2 :: Int)
19:28:44 <lambdabot>  True
19:30:13 <geekosaur> mbw, I think that improves in 8.2. before that, things like bindings force everything to be loaded, and the way to disable that stresses linkers so severely that it's only done when building base. (split-objs). The new split-sections support is supposed to allow that without the severe linker overhead; it may still default off in 8.2 but it should be possible to turn on sanely, and will hopefully be default in later ghc
19:30:34 <julianleviston> mwb:I think I just asked a bad question :)
19:34:30 <athan> hmm... has anyone here conteplated a constant-space hashset, which drops old entries?
19:34:31 <mbw> geekosaur: Is this all just off the top of your head or is there some compendium of these kind of things somewhere on the ghc wiki, beside the issue list? 
19:34:38 <athan> or is this what hyperloglog is for?
19:34:54 <geekosaur> mbw, mostly from following #ghc
19:35:21 <geekosaur> you may get some of it from the release status pages e.g. https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.2.1
19:35:45 <geekosaur> unfortnately those mostly make you read tickets to find out what they're talking about...
19:36:12 <lyxia> julianleviston: I don't think contexts works here because you can't really inspect a Context to see the corresponding path to a value.
19:36:24 <iqubic> What are we talking about??
19:36:25 <julianleviston> lyxia: ah ok… 
19:36:35 <mbw> Well it's probably also hard to judge whether something is majorly relevant unless you encounter these problems yourself.
19:37:03 <julianleviston> lyxia: I only just started looking at the Plated part of lens like a week ago after someone recommended it on stack overflow
19:38:23 <julianleviston> lyxia: AFAIK, Context *is* an applied Lens kind of thing of some kind… no?
19:38:42 <lyxia> yes
19:39:36 <julianleviston> lyxia: ideally I guess I’d to fold over the full EExp Int for each item in that contexts list and have the Fold maintain a list of its path to that point, (another context) and then == them… but I have no idea if that’s possible.
19:39:49 <julianleviston> lyxia: is that a Traversal?
19:40:25 <julianleviston> lyxia: maybe a monadic traversal that uses state to keep track of the context so far? I don’t know. These things are still super new to me
19:41:38 <lyxia> I don't think lens is going to be useful here
19:42:01 <lyxia> Just use good old recursion.
19:42:09 <julianleviston> Nah, has to be generic
19:42:26 <julianleviston> I can easily do it for this specific case with normal recursion. That’s easy.
19:42:44 <julianleviston> But what I’m writing is something that will work over text of arbitrarily specified grammars
19:43:13 <julianleviston> lyxia: and AFAICS that’s exactly what Data.Data.Lens does… let’s you scrap writing your own traversal code manually, right?
19:43:16 <lyxia> I'd be looking at recursion-schemes instead then
19:43:44 <julianleviston> oh nice… http://blog.sumtypeofway.com/recursion-schemes-part-iii-folds-in-context/
19:43:56 <julianleviston> that sounds like what I want.
19:44:38 <lyxia> Plated does a lot of things, but not all things.
19:45:20 <julianleviston> lyxia: it was really good for my first problem: how to generically pull every sub expression out (ie universeOf uniplate)
19:46:01 <julianleviston> This article is cool… thanks lyxia
19:46:05 <lyxia> there are other ways to write generic recursive functions
19:46:21 <lyxia> I prefer GHC.Generics
19:46:35 <glguy> :t para
19:46:36 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
19:47:18 <julianleviston> Ooh
19:47:41 <julianleviston> I don’t think GHC generics fits here (I looked into that a while ago), tho happy to be mistaken
19:52:54 <lyxia> I think it does.
19:53:58 <julianleviston> glguy: I can use para to do what I want :)
19:54:29 <mbw> geekosaur: So what I got from an old dons post on SO, split-objs creates one object file per top-level function, which is indeed pretty crazy for something like gi-gtk or lens or whatever. But why is this kind of methodology necessary? And why are the ffi bindings so problematic with respect to executable size?
19:54:35 <julianleviston> glguy: I **think** … I’d have to check it on a larger structure
19:55:15 <lyxia> but I stand corrected about Plated in lens not being sufficient.
19:55:34 <geekosaur> mbw: at this point you'll have to ask ghc devs. I follow discussions, I don't know internals *that* well
19:56:36 <mbw> Ok no problem. For what it's worth, "-dynamic" reduces it to 31K.
19:56:48 <mbw> I should use that more often....
19:57:26 <n_blownapart> hi, without stack, when I run this through ghc it doesn't like the traceShowId on line 19. anyone tell me how I can use a trace here if at all? https://github.com/varreli/haskell/blob/master/prime-factors/app/prime-factors.hs
19:58:11 <geekosaur> what is "doesn't like"?
20:00:17 <n_blownapart> geekosaur, thanks : https://nopaste.me/view/d8351e97
20:01:02 <geekosaur> traceShow is not traceShowId
20:01:03 <lpaste> glguy pasted “ugly but first draft working...” at http://lpaste.net/356023
20:02:12 <geekosaur> traceShowId :: Show a => a -> a # Like traceShow but returns the shown value instead of a third value.
20:02:26 <geekosaur> traceShow :: Show a => a -> b -> b # Like trace, but uses show on the argument to convert it to a String.
20:02:52 <julianleviston> glguy: haha thank you :) I’m on the path to that :)
20:03:40 <julianleviston> glguy: knew there would be a much better way to do that substring index function! pfxIndex x y = fromJust (findIndex (x `isPrefixOf`) (tails y)) awesome
20:04:25 <glguy> I think to do that in a less garbage way you'd want to use the Data instance to actually derive a way to show the data type
20:04:26 <julianleviston> glguy: can I please have your brain? :)
20:04:30 <glguy> so that you'd know the format
20:04:43 <glguy> rather than assuming how Show works in searching for substring indexes like this
20:05:40 <julianleviston> yeah, that’s what I was after… but I was prepared to go with a hacky substring thing in the meantime… still, felt like there should definitely be a more elegant way to do with, but I have no clue how to make it aware of the entire context… 
20:05:46 <n_blownapart> geekosaur, sorry neither works in ghc but I was running it through stack ghci
20:06:17 <geekosaur> and not even a ghc version much less a full error message in sight
20:06:34 <julianleviston> glguy: sort of a context-sensitive fold. That’s why I was wondering if a Fold might be good.
20:06:44 <julianleviston> foldM with state?
20:06:48 <n_blownapart> sorry that was lost on me geekosaur 
20:07:14 <geekosaur> I clearly have every ghc version and every stack version installed and can run regressions until I can identify your problem, like everyone else does
20:07:36 <geekosaur> you have provided pretty much no information to help with diagnosis.
20:08:28 <n_blownapart> sorry that's the error message I got with both traceShow and traceShowId
20:08:42 <julianleviston> n_blownapart: what versions of things are you using, tho
20:08:58 <n_blownapart> 7.6.3 ghc 
20:09:29 <athan> What would be a good constant-space HashSet (something with `elem`)?
20:09:56 <athan> er - something which prunes old ones efficiently? :D
20:10:28 <geekosaur> i guarantee that is not the same error message because I pasted both synopses in channel and they have different parameters
20:11:22 <julianleviston> glguy: TIL that you can say x => y => instead of (x, y) => for constraints!
20:11:39 <geekosaur> and no, "close enough" is not close enough.
20:12:07 <n_blownapart> thanks kindly geekosaur julianleviston I need to look at it fresh tomorrow . I'm new, I can barely read haskell
20:12:10 <geekosaur> but since you have finally provided a compiler version: per https://downloads.haskell.org/~ghc/6.8.3/docs/html/libraries/base/Debug-Trace.html you do not have either traceShow or traceShowId with that version
20:12:34 <geekosaur> n_blownapart, that is fine but is also why you need to provide *full* information
20:12:41 <geekosaur> not provide part of it and make others guess
20:12:47 <geekosaur> or asusme you know which part is important
20:13:10 <n_blownapart> oh that helps thanks. I really hope I can get stack working tomorrow it has been a rough day with it.
20:13:36 <MarcelineVQ> not 7.6.3? https://downloads.haskell.org/~ghc/7.6.3/docs/html/libraries/base/Debug-Trace.html
20:14:08 <geekosaur> er. sigh
20:14:31 <geekosaur> I think my point still stands but I also think I'm through for tonight, maybe I am too tired to read people's minds
20:14:56 <n_blownapart> geekosaur, I'm a noob, thanks for your tolerance
20:16:07 <julianleviston> n_blownapart: we’re all noobs. 
20:16:24 <n_blownapart> I'm an alt-noob
20:16:50 <n_blownapart> goodnight
20:16:52 <julianleviston> n_blownapart: if you can be tolerant of others non-tolerance, you’ll learn quickly :)
20:17:13 <n_blownapart> thanks cool ! julianleviston 
20:17:15 <julianleviston> n_blownapart: sorry you’re having a rough time of it (but we all are)
20:17:35 * glguy is having a normal time of it
20:17:59 <julianleviston> glguy: we all are :)
20:20:01 <julianleviston> glguy: so can I pick your brain as to how you learned equational reasoning?
20:20:53 <julianleviston> glguy: guess that’s a pretty silly question.
20:23:02 <significance> How can I show that the associativity law for monads is equivalent to  (f >=> g) >=> h  =  f >=> (g >=> h)?
20:26:10 <significance> in other words, how can I show that the "standard" and the Kleisli operator versions of the monad laws are equivalent?
20:31:03 <mniip> significance, prove one from another
20:31:06 <mniip> and vice versa
20:31:19 <significance> mniip: I'll give that a shot -- thank you!
21:37:23 <guest_random> q
22:37:28 <qmm> newtype P = P Float ; newtype D = D Integer; data Foo = P D ; foo :: Foo -> Integer -- now how to extract the Integer from D?
22:40:59 <Hafydd> qmm: did you mean to use the symbol "P" for both the types P and Foo?
22:41:18 <Hafydd> For their constructors.
22:43:27 <glguy> qmm: with case
22:43:54 <glguy> pattern matching more specifically
22:47:16 <julianleviston> I just read bananas, lenses, envelopes and barbed wire… guh… need to read that about 10 more times
23:07:06 <qmm> glguy: i did. i was hoping for an example, but i will look further. i do have one more question
23:09:54 <qmm> is it possible to say data Bar = Baz Boo Quz | Baz Quz | Boo Quz | Quz -- i know this isn't valid, but i'm trying to say that a valid Bar may contain Baz and Boo, but a Qux is necessary
23:11:08 <cocreature> data Bar = Foo Quz Other; data Other = Boo | Baz
23:12:50 <qmm> cocreature: what is the Foo for?
23:13:20 <qmm> what does Foo represent?
23:13:32 <cocreature> qmm: that’s the name of the constructor of Bar
23:13:44 <cocreature> I guess "data Bar = Bar Quz Other" might be easier
23:16:29 <qmm> with data Others = Boo | Baz  and  data Bar = Bar Qux Others;  Bar Qux Boo is valid, Bar Qux Baz is valid, but i want to say Bar Baz Boo Quz
23:16:32 <qmm> also
23:17:32 <cocreature> use "These Boo Baz" instead of Others. https://hackage.haskell.org/package/these-0.7.3/docs/Data-These.html#t:These
23:21:13 <significance> Is there a function like Data.List.groupBy that doesn't worry about whether elements are contiguous?
23:21:30 <cocreature> significance: just sort first
23:22:02 <significance> cocreature: thank you! there's nothing cleaner than doing a groupBy . sortBy?
23:22:45 <cocreature> significance: I don’t know of anything. if you find yourself doing that more than once, define your own wrapper for it
23:22:48 <kadoban> You could abstract it I suppose, but I don't think there's a common name for it.
23:23:44 <significance> the problem I'm trying to solve is if I have a list of 2-tuples with integral second terms, I want to group them by the first item and then sum over the second item within each group
23:24:20 <significance> should I just do a groupBy . sortBy, then map a foldr over the sublists?
23:26:35 <cocreature> not sure why you would want to use foldr. there is already a "sum" function. and if you want to implement "sum" yourself you should be using foldl' instead of foldr
23:26:47 <cocreature> but apart from that this seems like a reasonable solution
23:43:52 <jchia_1> There's a function that uses Proxy to pass type information and I'm trying to remove the use of Proxy with TypeApplications. However, the new code fails to compile and GHC suggests enabling AllowAmbiguousTypes. How cautious should I be about turning on this extension? http://lpaste.net/356024
23:44:16 <jchia_1> Particularly, I'm trying to get rid of a Proxy (rd, ss) argument.
23:45:25 <glguy> enable the suggested extension
