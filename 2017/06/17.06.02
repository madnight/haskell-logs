00:00:10 <halogenandtoast> Different goals.
00:10:38 <osa1> can persistent-sqlite log sql queries being executed? I'm using `wrapConnection conn logger` but my logger is not being called on queries
00:14:17 <halogenandtoast> osa1: I'm checking to see if my setup logs
00:15:05 <halogenandtoast> osa1: I get loggin: [Debug#SQL] SELECT "id", "name", "age" FROM "person" ORDER BY "id"; []
00:15:59 <halogenandtoast> I'm not using wrapConnection though, I'm just using   pool <- runStdoutLoggingT $ createSqlitePool "api.db" 5
00:16:11 <osa1> hmmm
00:16:28 <halogenandtoast> I also have this
00:16:28 <halogenandtoast> runSQL action = runQuery $ \conn -> runStdoutLoggingT $ runSqlConn action conn
00:16:32 <halogenandtoast> to run queries
00:17:31 <osa1> hmm I didn't know about runStdoutLoggingT, that should probably do it for me without making the whole logging stuff working, thanks
00:17:53 <halogenandtoast> ah no problem, as long as you want it to stdout (and not configurable) it works well enough
00:19:16 <osa1> for my current debugging task it should be fine although for another problem we're having right now we may need to log all queries to a file.
00:19:45 <halogenandtoast> osa1: I suggest reading: https://hackage.haskell.org/package/monad-logger-0.3.24/docs/Control-Monad-Logger.html
00:20:00 <halogenandtoast> you can use runFileLoggingT for that
00:20:17 <osa1> nice
00:21:26 <osa1> halogenandtoast: have you ever had problems with persistent sqlite backend when running multiple queries in parallel?
00:21:43 <halogenandtoast> I've only used the sqlite backend locally
00:21:59 <halogenandtoast> so I haven't tried anything fancy
00:22:46 <osa1> OK. I'm getting SQLite3 misuse errors (followed by a segfault) when running queries in parallel.
00:23:53 <halogenandtoast> ouch
00:26:06 <halogenandtoast> osa1: did you create a pool?
00:26:23 <halogenandtoast> If you don't have a pool you might not be able to handle parallel queries very well
00:27:00 <osa1> halogenandtoast: I just do `open` + `wrapConnection`
00:27:13 <halogenandtoast> hmm
00:27:13 <osa1> so no I'm not creating a pool manually
00:27:16 <Squarism> when i just began with haskell i thought to myself it would be a great "enterpise-software"/spring+java replacment. I proposed that here but got beaten down with "the we would need a haskell-spring first" by someone. The more i use haskell the more i feel that he could be wrong. 
00:27:23 <halogenandtoast> that could be a problem
00:27:55 <Squarism> so, am i naive in thinking it could be a good replacement? What would be the biggest problems?
00:27:59 <osa1> hmm I should read a bit about pools I guess
00:28:34 <halogenandtoast> osa1: see createSqlitePool
00:28:55 <halogenandtoast> in Database.Persist.Sqlite
00:29:34 <halogenandtoast> I could be entirely wrong, but at a cursory glance, I would assume this to be the problem
00:30:13 <osa1> halogenandtoast: documentation is lacking.. what is this pool thing for? are concurrent queries using a single SqlBackend not supported?
00:30:45 <halogenandtoast> osa1: see https://en.wikipedia.org/wiki/Connection_pool
00:30:58 <osa1> I know what a pool is, I don't know why is it needed here
00:33:12 <halogenandtoast> From Sqlite3 documentation
00:33:13 <halogenandtoast> Multi-thread. In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.
00:33:30 <osa1> ohh
00:33:33 <osa1> link?
00:33:36 <osa1> that's my problem then
00:33:37 <halogenandtoast> http://www.sqlite.org/threadsafe.html
00:35:00 <halogenandtoast> So if your poolsize matches your thread pool size, then you *should* be safe
00:35:27 <osa1> hmm so this is a bit weird because if I had a SqlBackend for a postgres server for example I might not need a pool, right? so persistent does not make your code sql-backend-agnostic
00:35:51 <osa1> or maybe all sql backends require pooling for thread-safe querying
00:35:55 <halogenandtoast> osa1: I run a lot of rails apps and if I don't use a database pool size that matches my thread size I run into problems
00:35:58 <halogenandtoast> same with MySQL
00:36:08 <osa1> ahh
00:36:55 <Habib> Hey, guys. Does anyone know of any material on higher order function argument pattern matching? I know that's confusing, so let me illustrate with an example:
00:37:05 <osa1> so this is probably well established but it's completely new to me. I'd expect "thread-safe" in this context to mean using single handle for concurrent queries
00:37:28 <halogenandtoast> osa1: right, I don't think that is possible
00:37:48 <halogenandtoast> I mean it might be, but I haven't encountered it in the common wild.
00:38:06 <halogenandtoast> Who knows what grad school students are up to these days.
00:38:10 <osa1> got it.. thanks halogenandtoast
00:38:11 <osa1> heh
00:38:19 <halogenandtoast> No problem osa1!
00:38:26 <Habib> I've got a function that takes a function of (Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived) and returns a function of exactly the same type. It's a middleware that takes an application and modifies it.
00:39:09 <johnw> osa1: I guess you found the "lite"
00:39:42 <halogenandtoast> johnw: I don't think it's an Sqlite problem, I could be wrong, but I've had this problem with postgres
00:39:51 <Habib> Apparently, it's possible to do `middleware function request responder = …` and function would be the type of the whole function, request :: Request, and responder :: Response -> IO ResponseReceived
00:40:00 <halogenandtoast> when people set the database pool size to a different number than the thread pool size
00:40:02 <Habib> Does anyone know what I'm talking about?
00:40:13 <johnw> Habib: I do, but I don't know yet what you want to do
00:41:23 <ertes-w> osa1: sqlite has one nasty habit: when you run a writing query while the database is locked, it will not block…  instead it will fail, and you need to be prepared to handle that case
00:41:46 <halogenandtoast> ertes-w: ouch
00:41:55 <Habib> Well, I want to query some of the arguments of the function that's passed in to the function I'm defining. I'm not having any trouble with it, but I didn't even know it was possible to define functions like that and I'm just looking for any material on it, because it doesn't seem to be legal from what I can tell, but it's in example code, and it works for me.
00:41:57 <ertes-w> osa1: you can reduce the number of times this happens by switching to WAL mode
00:42:03 <Habib> johnw: ^
00:42:08 <ertes-w> osa1: but it can still happen, and you need to handle it
00:42:13 <osa1> ertes-w: is that something persistent-sqlite's pool doesn't solve?
00:42:30 <ertes-w> osa1: it's something a pool makes *worse*
00:42:36 <osa1> ugh
00:42:46 <johnw> Habib: now you've lost me; what do you mean by "query some of the arguments"?
00:43:10 <ertes-w> osa1: if you have lots of readers, you should use as many pool connections as you have OS threads
00:43:10 <Habib> I just mean to pass them as arguments to other functions.
00:43:18 <Habib> Nothing special.
00:43:33 <osa1> ertes-w: what about: I use a singe connection and handle locking in my app (e.g. using a MVar Connection) ?
00:43:33 <Habib> I'm more interested in the syntax than anything.
00:43:40 <johnw> you want access to the Response value that the responder will receive?
00:43:44 <ertes-w> osa1: but if you do a lot of writing, you should only use one connection and handle lock failure
00:44:05 <ertes-w> osa1: that's not good enough, unless you assume that no other process will ever write to the database
00:44:09 <johnw> Habib: maybe it would help if you showed me the code you have now, and what you want to write
00:44:24 <ertes-w> osa1: handling failure is really the only option
00:44:29 <halogenandtoast> ertes-w: could you just implement a mailbox queue?
00:44:43 <halogenandtoast> on top of the writing connection
00:44:52 <halogenandtoast> *just*
00:45:26 <ertes-w> really, just handle lock failure =)
00:45:29 <halogenandtoast> by mailbox, I mean like erlangs mailboxes
00:45:49 <osa1> ertes-w: I'm guessing that's `ErrorLocked` in persistent-sqlite ?
00:46:34 <ertes-w> note that sqlite is capable of concurrency, especially concurrent reading, and you can also get very good concurrent writing by switching to WAL mode
00:46:55 <ertes-w> better don't use an "sqlite thread" with a mailbox
00:47:04 <ertes-w> osa1: not sure
00:48:10 <lpaste> Habib pasted “pattern matching higher order function arguments” at http://lpaste.net/355988
00:48:24 <Habib> johnw: ^
00:49:33 <johnw> ah
00:49:51 <johnw> I don't know of any feature like that, no
00:50:08 <Habib> Okay, thanks anyway.
00:50:42 <Habib> I mean, it works, but I just don't understand why. None of the places I learnt Haskell from taught that, and no documentation of it seems to exist.
00:50:57 <johnw> it's a view pattern
00:51:04 <johnw> or, it looks like one
00:51:10 <Habib> What do you mean?
00:51:31 <johnw> when you say "it works"
00:51:32 <Habib> Huh, looking at the GHC page for view patterns now. Thanks.
00:51:34 <johnw> what exactly are you referring to?
00:51:59 <Habib> I mean, the function compiles, it runs, it prints the types of the expressions as shown in the comment of the lpaste.
00:52:16 <johnw> your app@(\... ... -> ...) thing?
00:52:23 <Habib> No, no, the top version.
00:52:28 <johnw> oh yeah, the top one is standard
00:52:36 <johnw> functions are first class
00:52:42 <johnw> that's not a view pattern
00:52:51 <johnw> nor is the other one; it just looks like a bit like one (the second thing)
00:52:53 <Habib> Right, but the arguments of those functions aren't usually passed in with them.
00:53:06 <Habib> I know about higher-order functions, that's not the issue.
00:53:19 <johnw> "but the arguments of those functions aren't usually passed in with them" <-- what do you mean?
00:53:30 <johnw> I see a function of 3 arguments, receiving three arguments
00:53:52 <johnw> do you mean, you're not used to seeing the pattern of a function that receives a function and the arguments it can use to call that function?
00:53:54 <Habib> No, the function receives one argument, which is itself a function of two arguments.
00:54:09 <johnw> myMiddleware is a 3 argument function
00:54:09 <Habib> Yes, basically.
00:54:16 <Habib> Doesn't look that way to me.
00:54:34 <johnw> the first argument is a function taking  2 arguments, the second argument is a Request, and the third argument is a function taking one argument
00:55:02 <Habib> Once again, proving how much of an idiot I am.
00:55:24 <Habib> I compartmentalised the last bit as one whole value, mentally encapsulating it in brackets.
00:55:28 <johnw> i'm not sure this is an indictment of intelligence, just familiarity
00:56:02 <Habib> Yes, I'm being facetious. What I mean is that I had a brain fart.
00:56:07 <johnw> :)
00:57:42 <Habib> Okay, so now I really want to do what I thought was happening there.
00:57:56 <Habib> Or do I?
00:58:50 <jle`> is there some (t a, b) -> t (a, b) that's convenient anywhere
00:58:53 <jle`> for Traversable t
00:58:57 <Habib> How can I get access to the Request value of the function that's passed in instead of the second argument?
00:58:57 <jle`> er, for Functor t
00:59:04 <johnw> jle`: you could always swap, fmap, then swap back
00:59:09 <johnw> i think tuple swapping is pretty cheap
00:59:21 <jle`> i'm just used to using sequence :: (a, t b) -> t (a, b)
00:59:29 <jle`> i wonder if there's a similar thing for the first part
00:59:30 <johnw> fmap swap . sequence . swap
00:59:38 <johnw> no, not in the stdlib
00:59:45 <Habib> I'm writing a middleware which is essentially an Application -> Application, and Application is essentially `Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived`
01:01:01 <jle`> huh there's not even a helper function in Data.Bitravertsable for it
01:01:48 <johnw> jle`: maybe lens can do it
01:01:58 <jle`> sequenceOf _1
01:02:20 <jle`> > sequenceOf _1 (Just 3, 'a')
01:02:20 <Xion_> Habib: Why not just Application:: Request -> IO Response?
01:02:22 <lambdabot>  Just (3,'a')
01:02:23 <jle`> neat
01:02:26 <jle`> thanks
01:02:36 <johnw> > (Just 5, 6) & _1 %%~ id
01:02:38 <lambdabot>  Just (5,6)
01:02:40 <johnw> another way of saying the same thing
01:02:48 <Habib> Xion_: it wasn't my decision. It's the standard WAI Application.
01:03:12 <johnw> Xion_: middleware is an application transformer, where an application is defined by that function type
01:05:22 <Habib> johnw: so when I'm writing a middleware, I'm conceptualising it as a function of Application -> Application, because that's what the `type Middleware =`. So I'm trying to write the middleware in a way that looks like I'm merely modifying the original application. I don't quite understand why I should be working with the second argument Request, instead of working with the inner Request of the first Application argument.
01:06:16 <johnw> Habib: that second argument Request becomes the argument to the application you're transforming
01:06:33 <merijn> I would say that it *is* the argument, not becomes
01:06:44 <johnw> you're writing a function that *receives* an application and a future request, and then you're supposed to do what you want, maybe calling the earlier application with that request or some modified form of it
01:07:10 <johnw> well, I wouldn't say *is* because you have no obligation to pass it through
01:07:17 <Habib> Yes, I just got it like a second before you said it :). I've been puzzling over it for maybe half an hour.
01:07:24 <johnw> cool
01:08:57 <johnw> I have to say, the "zen of higher-order functions" is sometimes insufficiently appreciated, and devishly hard to master
01:09:01 <Habib> I was trapped in the mindset of "I'm modifying the application in the same way that I modify monads, so I need to pass the application to another function or something, but then that's just recursive"
01:09:29 <Habib> Whoops, move that closing quote mark to before the last comma.
01:11:23 <Habib> I think a better way to think of it, even though it's less technically accurate, is like an application that takes an application, *then* its arguments. Of course, the type definition for application means it can't actually take itself, but it's useful to think of this function that way.
01:12:02 <Habib> I would write the function as if I were writing an Application, except I also have the old application with me to pass everything through if I needed to.
01:12:53 <merijn> Habib: Right, it's a very useful pattern when writing transformers like this
01:13:59 <merijn> Habib: Usually when you have an alias like 'Application' which is a function people tend to get stuck on "I should return an 'Application'!" they forget that it's irrelevant whether the input of 'Application' is consumed by "their" function or a "returned function", since from a curried perspective, there's no difference between the two :)
01:15:26 <Habib> Yes, that's exactly where I got trapped. The type system is amazing, and it's actually pretty simple, but it's easy to get hung up on something that shouldn't really matter sometimes.
01:15:42 <halogenandtoast> Habib: yup
01:16:29 <johnw> merijn: are you still in SF area these days?
01:16:33 <Habib>  But I feel so much more proficient with it in the course of working with more stuff. Now, I usually instinctively know what types I'm passing around much more often.
01:16:33 <halogenandtoast> when I used this the other day, I was reminded of that: type Form x = Html -> MForm (HandlerT App IO) (FormResult x, Widget)
01:16:50 <merijn> johnw: Naah, haven't been since December 2014 :p
01:17:05 <johnw> it's too bad, since now I live not far from where you were :(
01:17:52 <merijn> johnw: That was only an internship for 6 months, now I'm back in NL and blissfully trying to ignore the fact that I should probably start getting started with my thesis ;)
01:18:33 <johnw> are you coming to the DeepSpec summer school?
01:18:43 <johnw> not sure if there will be much Haskell there though
01:19:32 <riaqn> as I understand it, it would be just Coq and some C or other imperative languages.
01:19:41 <johnw> yeah, maybe so
01:19:55 <merijn> Hadn't heard of it before, so no ;) I'm not sure if I'll go to a summer school this year. Like I said, I should finish up enough experiments for a final publication and starting my thesis
01:20:17 <merijn> I only have until January 1st before I'm out of a job :p
01:22:23 <halogenandtoast> Has anyone been to the workshops at lambdaconf, I'm considering trying to go next year.
01:22:34 <johnw> I haven't, no
01:23:28 <merijn> I think my supervisor was ok with paying for me to go to ICFP despite not having a publication, though :)
01:24:03 <halogenandtoast> was that in Tokyo last year?
01:24:34 <halogenandtoast> oh Nara
01:25:03 <merijn> Yeah, hence why I didn't go, a bit expensive :p
01:25:12 <merijn> UK is a bit more affordable, travel-wise ;)
01:25:26 <johnw> merijn: see you in Sep?
01:25:42 <halogenandtoast> I might consider going. My company has an office "close" to there
01:26:13 <halogenandtoast> about 2 hours away
01:27:26 <merijn> johnw: It's going to be a busy month >.> ICFP is early september, I was going to take vacation and visit a friend in Edinburgh in the 2nd-3rd week of September and then, if I'm lucky and my paper gets accepted, I have to go to MASCOTS in Canada...
01:30:08 <johnw> night, merijn, all
01:30:45 <merijn> And on a completely different topic, since every is submitting useless syntax proposals to Haskell Prime, I'm going to propose replacing the dot in "forall x y z ." with a two character symbol instead...
01:31:53 <halogenandtoast> merijn: sounds reasonable
01:32:10 <halogenandtoast> I vote for :}
01:34:00 <merijn> Clearly the current symbol doesn't align nicely: http://lpaste.net/284318524233482240
01:34:40 <merijn> Incidentally, this is why I oppose changing type annotations to use ':' (which is a stupid proposal for backwards compatability and sanity reasons too), you can't align the :: with => and -> nicely anymore :p
01:34:48 <halogenandtoast> lol
01:35:49 <halogenandtoast> Personally I like the nekudotayim paamayim style
01:36:03 <halogenandtoast> err other way around
01:36:03 <halogenandtoast> Paamayim Nekudotayim
01:43:25 <halogenandtoast> merijn: Are there any examples of great things that previously came out of Haskell Prime?
01:43:54 <merijn> halogenandtoast: Haskell Prime isn't about great new things. It's (mostly) about standardising existing things
01:43:58 <jle`> is there a non-empty Set type?
01:44:52 <merijn> jle`: Doubt it
01:45:18 <rootnode> isn't there Data.NonEmpty.Set?
01:45:23 <halogenandtoast> https://hackage.haskell.org/package/mono-traversable-1.0.2/docs/Data-NonNull.html
01:45:32 <halogenandtoast> jle`: what about that
01:45:44 <cocreature> haskell prime is in a tough spot. either they standardize large parts of ghc that are in use today making it really hard to create alternative implementation and thereby defeating the purpose of having a standard or they don’t and nobody will care about the standard
01:46:33 <halogenandtoast> not at all a set, sorry
01:46:50 <merijn> cocreature: There's a bunch of extensions that aren't too involved and really should go in
01:47:15 <jle`> hm, NonNull (Set a), neat
01:47:17 <mniip> merijn, any of them useful/widely used?
01:47:58 <mniip> for me the KitchenSink appears to be exactly those typechecker extensions that make haskell so impossibly hard to implement
01:47:59 <cocreature> merijn: sure. what I was trying to say is that if you don’t also add some of the more involved extensions that are in use, the standard will still be about as irrelevant as it is today
01:48:01 <jle`> mniip: i support this
01:48:04 <jle`> er, merijn 
01:48:10 <jle`> regarding :}
01:48:14 <merijn> mniip: I was looking it up
01:48:22 <merijn> Heh
01:48:37 <merijn> GHC manual still lists Pattern Guards as extension, should probably be changed
01:49:12 <mniip> oh btw
01:49:22 <mniip> one thing I don't understand about pragmas
01:49:25 <mniip> and extensions
01:49:34 <mniip> why does GHC not ignore those it doesn't understand
01:49:38 <mniip> would be kinda logical
01:49:57 <halogenandtoast> If I want to go to a conference for Haskell that mainly features workshops/training which would be the one to attend?
01:50:14 <Xion_> Does Haskell have pragmas?
01:50:25 <halogenandtoast> Xion_: it does with the CPP language extension
01:50:34 <Xion_> Ah, obviously.
01:50:48 <Xion_> If they are not ignored when unknown that's not very CPP then :)
01:51:23 <halogenandtoast> but in GHC, Pragmas all take the form {-# word ... #-} 
01:51:39 <halogenandtoast>  any pragma encountered with an unrecognised word is ignored. 
01:52:30 <cocreature> mniip: why should it? if I say that my code requires an extension I want GHC to yell at me if it doesn’t support it. otherwise you end up in weird situations where you just have a typo in your pragma or get weird compile errors
01:52:44 <Xion_> {-# MINMAL (<^|^>) #-} -- doesn't seem like a good idea to just ignore unknowns
01:53:21 <mniip> yes but that kind of is how compatibility works in other languages, no? via redundancy
01:54:19 <cocreature> mniip: but it’s not redundant. adding an extension can change behavior in various ways. silently ignoring the request to do so seems like a weird thing to do
01:55:00 <kuribas> How do I extract a point from friday?  This gives a syntax error : "(\ Z :. y :. x -> undefined)"
01:55:45 <merijn> There's a bunch of really obvious syntactic extensions that really should go in: BinaryLiterals, NumDecimals, TupleSections, MonadFail, GADTSyntax, NamedFieldPuns, StandaloneDeriving, InstanceSigs. Others that should go in, imo: ViewPatterns, DeriveGeneric/Functor/Foldable/Traversable/Typeable/Lift, PatternSynonyms, MultiParamTypeclasses, FlexibleContexts/FlexibleInstances, DefaultSignatures, 
01:56:27 <merijn> I would love to see TypeFamilies, GADTs, and FunDeps, but those are more controversial
01:56:43 <merijn> Since GADTs brings in ExistentialQuantification which I think is on shaky definition ground
01:56:48 <kuribas> merijn: they are withheld for compatibility with other compilers?
01:57:19 <cocreature> the mysterious other Haskell compilers
01:57:35 <brynedwards> Are there any downsides to ScopedTypeVariables?
01:57:38 <merijn> oh
01:57:46 <merijn> ScopedTypeVariables <-- that should also go in
01:57:55 <merijn> brynedwards: Not really
01:58:11 <halogenandtoast> I love NamedFieldPuns
01:58:31 <merijn> brynedwards: Well, you have to invent new type variable names in you where bindings, that's about it :p
01:58:47 <cocreature> you only have to do that if you add explicit foralls
01:58:54 <merijn> I'd like ConstraintKinds too
01:59:45 <cocreature> don’t forget OverloadedStrings
01:59:48 <merijn> oh, obvious syntactic extensions, part 2: KindSignatures
02:00:07 <merijn> I'd like to see RankN too, but again, shaky theoretical foundations
02:00:08 <merijn> cocreature: No
02:00:16 <merijn> cocreature: I don't think I'd like all OverloadedX on by default
02:00:23 <jle`> is TupleSections something that would be fitting for a standard
02:00:33 <jle`> i can see both sides of the argument
02:00:35 <merijn> cocreature: It encourages way too much partial use
02:00:43 <merijn> jle`: Why wouldn't it be?
02:00:52 <jle`> well
02:00:53 <merijn> jle`: It's an imminently sensible thing
02:00:55 <jle`> (,) is inherently magic
02:00:56 <halogenandtoast> Also for "other" haskell compilers, there is ETA
02:00:59 <cocreature> merijn: but there needs to be at least so me way to enable it. not supporting that extension will make your compiler unusable
02:01:01 <halogenandtoast> which I think is a fork of 7
02:01:05 <jle`> tuple sections just is extra magic
02:01:06 <halogenandtoast> 7.4.6 methinks
02:01:23 <merijn> jle`: You can just desugar it to a lambda, so the implementation of (,) is irrelevant
02:01:27 <jle`> tuple sections is a special-casing of a special-casing
02:01:30 <cocreature> then again I also don’t think we’ll get another Haskell compiler anytime soon so I’m not sure what exactly the purpose of Haskell prime is in the first place
02:01:32 <merijn> halogenandtoast: More relevantly, there's UHC
02:01:34 <mniip> merijn, GADTSyntax?
02:01:41 <jle`> not the implementation of (,), but the syntax token ','
02:01:49 <merijn> mniip: Let's you write non-GADTs using GADT syntax
02:02:02 <jle`> , is treated as a special case already, so TupleSections is a special casing of a special case
02:02:11 <merijn> mniip: "data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a"
02:02:20 <mniip> yeah I figure
02:02:25 <merijn> mniip: I think beginners would understand ADTs far better with that notation
02:02:32 <jle`> let it be stated that i am in favor of TupleSections being standard, but i can how adding it would complicate haskell syntax further
02:02:36 <mniip> oh yeah one thing about what Prime could do
02:02:43 <ventonegro> There is always the Scheme route of a "small" and a "big" standards
02:02:54 <mniip> add AMP/FTP to the report
02:03:01 <ventonegro> Although the "big" one is not finished yet
02:03:28 <merijn> oh
02:03:32 <merijn> BangPatterns too
02:03:44 <merijn> mniip: I already said AMP, I think FTP is...not necessarily ideal
02:03:58 <merijn> I don't quite agree with a lot of stuff that was moved into Foldable
02:04:27 <halogenandtoast> merijn: is that actually used?
02:04:39 <halogenandtoast> I haven't seen any updates in a while
02:04:47 <mniip> merijn, why not
02:04:48 <halogenandtoast> I figured Hugs might be more relevant than that
02:04:55 <merijn> halogenandtoast: There's a whole research group working on it
02:05:06 <mniip> you can provide efficient implementations or you can defer to defaults
02:05:07 <merijn> halogenandtoast: It is 100% certainly more maintained than Hugs
02:05:08 <halogenandtoast> Well that doesn't mean anything to me.
02:05:18 <merijn> halogenandtoast: "Actually used", not so much
02:05:34 <cocreature> I don’t even know what the selling point of uhc is
02:05:40 <merijn> They do all of Haskell2010 and a number of GHC extensions
02:05:52 <halogenandtoast> Research groups in language development are typically running jokes
02:06:07 <mniip> halogenandtoast, well, this is haskell
02:06:10 <kuribas> ventonegro: the monopoly of ghc over other compilers is a big benefit of haskell over scheme.
02:06:14 <merijn> cocreature: It doesn't have a selling point, it is a proof of concept for attribute grammars
02:06:28 <cocreature> fair enough
02:06:46 <merijn> Well, they have a JS and JVM implementation, apparently
02:07:28 <halogenandtoast> I was planning ons pending my weekend writing a Haskell implementation in Ruby, mainly because I hate myself.
02:07:53 <halogenandtoast> So my version might be the next big thing
02:08:23 <ventonegro> kuribas: indeed
02:08:41 <merijn> halogenandtoast: Why not write on in Haskell? Sounds far more pleasant >.>
02:08:56 <cocreature> just write it in asm
02:09:28 <halogenandtoast> merijn: can't I just use System.Eval.Haskell for that/
02:09:40 <merijn> That's not a compiler :p
02:10:00 <halogenandtoast> I said implementation
02:10:01 <halogenandtoast> not compiler
02:10:09 <merijn> fair enough
02:10:34 * ertes-w has tried writing a program using the 'turtle' library…  now is rolling back to just using 'process' and 'kan-extensions'
02:10:35 <halogenandtoast> I've tried writing compilers, I get all the way to code generation and fail miserably.
02:10:58 <cocreature> halogenandtoast: just emit llvm :)
02:11:00 <halogenandtoast> Then I try using llvm so I don't have to do that
02:11:12 <halogenandtoast> but llvm is like learning an entirely new language
02:11:17 <halogenandtoast> and I haven't figured it out yet.
02:11:33 <Geekingfrog> Is there a way to continue composing lens to get into a may after a map lookup? myMap ^.at "foo" -> returns a Maybe a, I'd like to apply more lens on the a
02:11:51 <Geekingfrog> (note, I'm a lens noob)
02:11:55 <ertes-w> Geekingfrog: _Just
02:12:12 <ventonegro> halogenandtoast: you've probably already seen this, but: http://www.stephendiehl.com/llvm/
02:12:21 <ertes-w> but you can only use (^.), if 'a' (or whatever is the final point type) is a monoid
02:12:40 <halogenandtoast> ventonegro: I might have at some point, but I had forgotten, thanks for the reminder.
02:13:09 <Geekingfrog> ertes-w: neat, thanks
02:13:47 <Geekingfrog> ventonegro: useful to know. Unfortunately it's not the case here
02:13:51 <cocreature> at "key" . _Just should be equivalent to ix "key"
02:14:18 <ventonegro> Geekingfrog: ?
02:14:48 <Geekingfrog> ventonegro: sorry, mistype the name -_-' forget my message
02:14:58 <ventonegro> Geekingfrog: no problem :)
02:20:14 <Geekingfrog> Grmbl, item ^.at "foo" returns me (Just a) but since my a isn't a monoid, item ^.at "foo" ._Just doesn't work /o\ I have a lens to turn it into a monoid though (a ^. myLens -> b where b is a hashmap)
02:21:12 <Geekingfrog> fmap (^. myLens) (item ^.at "foo") works but isn't quite as convenient as I'd like
02:21:30 <halogenandtoast> Geekingfrog: inline that fmap like a champ!
02:21:55 <halogenandtoast> I guess I don't mean inline
02:22:08 <Geekingfrog> Like `fmap` or <$> ?
02:22:20 <halogenandtoast> (^. myLens) <$> (item ^.at "foo")
02:22:29 <halogenandtoast> I just have a thing for <$>
02:22:46 <ertes-w> Geekingfrog: _Just is a proper traversal, so if you compose with it, the whole thing becomes a proper traversal
02:23:01 <ertes-w> (^.) only works on lenses, or on traversals that point at a monoid
02:23:43 <ertes-w> [("hello ", 0), ("world", 1)] ^. traverse . _1
02:23:45 <ertes-w> > [("hello ", 0), ("world", 1)] ^. traverse . _1
02:23:47 <lambdabot>  "hello world"
02:27:08 <jle`> Geekingfrog: ^. doesn't quite work here as you have it since it looks like you're building a getter on a, but that isn't possible
02:27:12 <jle`> since it's Maybe
02:27:34 <jle`> you can build a "Maybe getter", which "might" get an a
02:27:38 <jle`> using ^?
02:28:29 <jle`> you can imagine ^. being used in situations where you for sure will find a single 'a' target, and ^? for use in situations where you might fail in finding your 'a' target
02:28:30 <Geekingfrog> ertes-w: The problem is I'm dealing with something similar to json (amazonka dynamodb values actually), so each value can be a bunch of different things.
02:28:39 <jle`> Geekingfrog: so you can do item ^? ix "foo"
02:28:51 <Xion_> :t flip fmap
02:28:52 <Geekingfrog> jle`: no, that doesn't typecheck
02:28:52 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:28:54 <jle`> or item ^? ix "foo" . _Just . stuff
02:29:08 <jle`> what's the error?
02:29:32 <jle`> > [(1,2),(3,4),(5,6)] ^? ix 2 . _1
02:29:34 <lambdabot>  Just 5
02:29:41 <Geekingfrog> oh wait, ^?ix "foo" works
02:29:47 <jle`> > [(1,2),(3,4),(5,6)] ^? at 2 . _Just . _1
02:29:49 <Geekingfrog> It gives me the same thing as ^.at "foo"
02:29:50 <lambdabot>  error:
02:29:50 <lambdabot>      • Could not deduce (Num t0)
02:29:50 <lambdabot>        from the context: (Num t1, Num t, At [(t1, t)])
02:30:21 <jle`> Geekingfrog: yeah, ^? is for targets that can "fail"
02:30:25 <jle`> ix 2 is "failable"
02:30:50 <jle`> but at "foo" always finds its Just/Nothing target
02:31:51 <Geekingfrog> oh, woot! I can do item ^?ix "foo" . myLens .ix "bar"
02:32:10 <Geekingfrog> okay, I'm going to let that sink for a bit and try to understand what's going on exactly
02:32:18 <Geekingfrog> Thanks for the help ertes-w and jle` 
02:32:25 <jle`> mhm. the fundamental difference is that, since ix "foo" can fail, you have to switch from ^. to ^?
02:32:39 <jle`> you can even use ^.., to get a just of all matching targets.
02:33:06 <jle`> (and the list will be empty if nothing matches)
02:33:50 <jle`> if any component in your chain can fail, then the entire chain can potentially fai
02:34:35 <Geekingfrog> mmm, at the end I end up with (Just (Just "qux")), is there a way to avoid a last ._Just to join the two ?
02:35:10 <Geekingfrog> item ^?ix "foo" . myLens .ix "bar" . myOtherLens -> Just (Just "qux")
02:35:34 <jle`> it might be because myOtherLens is a lens into a Maybe
02:35:41 <Geekingfrog> yes
02:35:50 <jle`> so you can use _Just to look into the 'a' in that Maybe
02:36:00 <Geekingfrog> Okay, that's fine.
02:36:09 <jle`> or 'traverse'/'folded'
03:05:25 <vbCrLf> Hey, does anyone have experience with GHC and -fllvm on Windows? Seems like it looks for "opt.exe" and "llc.exe" but these files do not exist in the LLVM installation directory (I used the 3.7 installer from the official website)
03:30:18 <lpaste> hexagoxel pasted “Can this be simplified? (caution, typelevel hackery)” at http://lpaste.net/355989
03:33:25 <hexagoxel> (it is not even typelevel, really.. more like "types on the value level")
03:39:23 <Philonous> I don't know what you use it for, but having to explicitbly pass Dicts seems inconvenient 
03:41:42 <Philonous> Although once you just add them as constraints I find it hard to imagine a case where you have c a and c a => Typeable a but not Typeable a 
03:42:40 <hexagoxel> Philonous: i can return a Dict before i fully apply a function that returns the constrained value.
03:42:47 <Gurkenglas> "f $~ d = case d of Dict -> f" produces http://lpaste.net/9195425285955125248 . Why does type inference not seem to work here?
03:43:03 <hexagoxel> i don't see a way to get that without manually handling the Dict.
03:49:11 <Gurkenglas> TypeApplications doesn't work in intero?
03:50:23 <Gurkenglas> ("-- stack --resolver lts-8.16 script" specifies https://www.stackage.org/lts-8.16 which says it's on ghc-8.0.2 and https://ghc.haskell.org/trac/ghc/wiki/TypeApplication says 8.0 supports it)
03:51:20 <hexagoxel> Gurkenglas: what error do you get?
03:51:33 <Gurkenglas> "Unsupported extension: TypeApplications (intero)"
03:51:49 <Gurkenglas> The same one when I enter an extension name that doesn't exist
03:52:35 <Gurkenglas> (and (intero) is at the end of all flycheck errors from intero)
04:06:53 <lpaste> hexagoxel pasted “is this possible?” at http://lpaste.net/355990
04:42:03 <lpaste> hexagoxel revised “is this possible?”: “is this possible?” at http://lpaste.net/355990
04:44:44 <Gurkenglas> How do I get a tags table for intero's init-intero-goto-definition without being in a project?
05:05:21 <raek> let's build a dysfunctional programming language with detonational semantics.
05:17:47 <ab9rf> boom
05:18:12 <ab9rf> raek: i think that's already been done, many times
05:20:15 <pookleblinky> I'm running stack setup. It keeps downloading, hits a point where it freezes, then after a while starts redownloading. Highest it has gotten was 67% before hanging for a minute then starting over
05:20:49 <ADG_> how to use memoFix2 on interdependent functions f, g and h : https://github.com/adityagupta1089/Project-Euler-Haskell/blob/master/src/82.hs
05:21:28 <pookleblinky> Now it is hanging on 3.5MB, once again. Is this just due to high traffic on a server not meant for it?
05:21:50 <ab9rf> what sort of network connection do you have?
05:22:05 <ab9rf> i've never had a problem with stack downlading stuff, but i have really good connectivity
05:22:36 <pookleblinky> Everything else is working perfectly. Stack setup is for some reason timing out on reaching the server
05:24:29 <ertes-w> detonational semanics?
05:24:44 <pookleblinky> ghc-8.0.2:    3.50 MiB / 107.55 MiB (  3.26%) downloaded...recv: resource vanished (Connection reset by peer)
05:25:00 <ab9rf> ertes-w: wile e. coyote's favorite
05:25:08 <pookleblinky> Just got this ^ after a lag of 2 minutes 
05:25:31 <pookleblinky> I'll try again later today, maybe there's just a high load or something.
05:25:36 <ab9rf> pookleblinky: this is likely yhour network connection
05:26:23 <ab9rf> i've seen this many time on people with chintzy connections: they're fine when they download small files, but a large file triggers soe sort of poorly-implemented throttle in their ISPs stack and the download farts off
05:26:28 <pookleblinky> 64 bytes from lga25s41-in-f14.1e100.net (216.58.219.238): icmp_seq=1 ttl=56 time=37.3 ms
05:26:34 <pookleblinky> Network's fine
05:26:42 <ab9rf> pookleblinky: that doesn't prove anything
05:26:51 <ab9rf> pookleblinky: trust me, i'm a network engineer.
05:27:24 <ab9rf> could even be a bug in a stateful inspecting firewall, seen that with cheap consumer-grade gateway devices
05:28:14 <ab9rf> is there a way to manually download files and tell stack to use a local copy?
05:28:53 <ertes-w> well, if semantics cause a detonation i wouldn't call the language dysfunctional…  i'd call it python
05:29:02 <ab9rf> heh
05:29:51 <pookleblinky> ab9rf: I'm thinking of doing that
05:49:28 <pookleblinky> ab9rf: I just manually plopped the tarball into the expected location, no problem downloading it outside of stack
05:50:04 <pookleblinky> Now to see how to stack setup with this pre-existing tarball instead of trying to download another
05:59:46 <fendor> when setting up stack with stack setup, where does stack look for libgmp?
06:16:07 <sternmull> is anyone using sublimetext 3? I start it with ghc and ghci in my PATH and it can't find those binaries. Although launching ghci from its builtin python console works fine. So somehow the repl and haskell plugin in sublime are ignoring or messing up the PATH... and i have no idea what is going on.
06:33:43 <krokodil_> I don't get it. Why `class C [a] [b]` doesn't require FlexibleInstances but `class C a [b]` does?
06:35:46 <krokodil_> sorry, I meant `instance C [a] [b]` vs `instance C a [b]` of course
06:35:55 <krokodil_> `instance C a b` also requires FlexibleInstances
06:36:20 <ertes-w> acowley_away: concurrent-machines is a great library…  thanks!
06:37:06 <glguy> flexible instances waives the requirement that each parameter be a type constructor applied to zero or more variables
06:37:27 <ertes-w> just saved me a ton of work for coordinating a complicated producer/worker graph
06:37:30 <glguy> so [a] is ok, a is not
06:37:54 <cocreature> a simpler example would be "class C a" "instance C a"
06:38:36 <krokodil_> cocreature: yep, requires FlexibleInstances as well
06:39:08 <krokodil_> thru trial and error I found that instance head must be either a concrete type, or a type of kind * -> * applied to a type variable
06:39:38 <glguy> the error message tells you the rule
06:40:06 <cocreature> it might also be worth pointing out that enabling FlexibleInstances is mostly harmless
06:40:07 <krokodil_> glguy: ok, but how is Int of the form (T a1 .. an)
06:40:10 <cocreature> I don’t even think about it
06:40:13 <cocreature> krokodil_: n = 0
06:40:20 <krokodil_> cocreature: dude, duh
06:40:43 <glguy> type constructor Int, no variables
06:41:17 <glguy> [a] is type constructor [] , one variable
06:41:44 <glguy> the rule doesn't have to do with kinds, but the kinds must match
06:43:53 <krokodil_> glguy: cocreature thanks, it's all clear now :)
06:45:00 <saurabhnanda> probably a random question -- how do I view a type-level list in the REPL? Why is `:k SOP.Code Bool` working? But why am I unable to evaluate and print it on the REPL?
06:47:14 <glguy> use kind!
06:48:07 <glguy> like :kind! Some Type
06:52:37 <shapr> be kind!
06:53:28 <Rembane> Be higher kind!
06:53:53 <ertes-w> incoming rave
06:55:15 <ertes-w> haskell has become kind of a second nature over the years, but i just realised that i can't imagine having written this in any other language…  not even those with proper concurrency support…  so yeah, i haven't had this enthusiasm over haskell in quite a while =)
06:55:33 * sm higher-fives ertes-w 
06:55:47 <Akii> lol
06:55:47 <shapr> ascii rave in Haskell https://slab.org/asciirave/ built by yaxu
06:55:49 * ertes-w cohigher-cofives
06:57:07 <ertes-w> kinda missed the actual "rave" part…
06:57:11 <sm> ertes-w: what're you writing ?
06:57:48 <ertes-w> sm: i'm moving a lot of data from various sources into zabbix trapper items
06:57:58 <cocreature> ertes-w: there are other languages with proper concurrency support? :P
06:58:01 <sm> (nice t shirt slogan, Rembane)
06:58:16 <Rembane> sm: Thank you!
06:58:25 <Athas> cocreature: Erlang!
06:58:39 <cocreature> Athas: ah good point, I can’t argue with that :)
06:59:46 <ertes-w> well, erlang's concurrency is quite different…  the two are surprisingly hard to compare
07:00:13 <ertes-w> i'm not using the actor model here, which is pretty much hard-coded into erlang
07:00:51 <ertes-w> and i'm using STM heavily, which is…  let's face it…  haskell is the only language that has useful STM
07:01:13 * sm wonders if zabbix is better than nagios
07:01:25 <ertes-w> sm: better than nagios it is, but that doesn't really mean much
07:01:31 <ertes-w> i don't like it
07:01:46 <sm> zabbix ?
07:01:53 <ertes-w> i'm hoping to move to a consul-based setup at some point
07:01:55 <ertes-w> yeah
07:01:59 <sm> ok, good to know
07:02:45 <ertes-w> sm: given a choice between nagios and zabbix i'd definitely choose zabbix
07:03:07 * sm is already on nagios but wouldn't mind something nicer
07:03:29 <ertes-w> if you want something really nice, check out consul
07:04:33 <fozworth> Hi all! I'm the editor of Haskell Weekly. I realized I haven't been posting them here, so here's yesterday's issue: https://haskellweekly.news/issues/57.html
07:04:41 <sm> not to get too off topic, but its home page scared me off.. DNS ? looks like something for big enterprises
07:04:43 <ertes-w> if you want something that is nice and still somewhat comparable to nagios/zabbix, there is sensu, but i'm not going to invest more time into that kind server/agent of model
07:05:28 <ertes-w> sm: no, not necessarily…  it just scales very well
07:06:52 <sm> I hadn't discovered sensu, thanks for that
07:07:36 <ertes-w> sm: it's super-complicated to set up though
07:08:06 <pookleblinky> Hm, I'm getting the error that stack is running out of space trying to unpack the ghc. setting TMPDIR to a tmp on a disc with 1.8tb free, hasn't worked.
07:08:08 <ertes-w> for a serious setup you need at least three components, and ideally they want to run on different hosts:  RabbitMQ, redis and sensu itself
07:08:24 <ertes-w> sm: happy to discuss this further in #haskell-offtopic, if you want =)
07:08:25 <pookleblinky> I'm using crouton on a chromebook, ram is heavily limited.
07:14:08 * hackage tagchup 0.4.0.6 - alternative package for processing of tag soups  https://hackage.haskell.org/package/tagchup-0.4.0.6 (HenningThielemann)
07:15:15 <pookleblinky> As far as I can tell, there's not much I can do to manually configure it, make, and then plop it into ~/.stack/blah where it's expected (without lots of yakshaving the executability of external media)
07:15:19 <sm> pookleblinky: maybe -v will show where it's doing stuff ?
07:15:57 <sm> the destination of the ghc is ~/.stack probably
07:17:01 <pookleblinky> sm: it's firmly attempting to download into ~/.stack despite my changing $STACK_ROOT to the external drive. It attempts to use my ram-bound /tmp despite changing TMPDIR to a tmp on the external drive
07:18:18 <sm> strange. Maybe the stack issue tracker has something about this
07:19:07 <pookleblinky> Right now I've got an unpacked ghc-8.0.2 on my external drive, 1.8tb in which to work with it, and I can't seem to figure out how to get stack to use this location rather than the extremely limited space in ~/.stack, no matter how I change env variables for it to do so
07:19:45 <phadej> change $HOME :)
07:19:52 <sm> ln -s /Volumes/BigDisk ~/.stack :)
07:19:57 <phadej> or that
07:20:04 <pookleblinky> sm: There's a couple issues similar to this, but I haven't found one specific to trying this in a crouton chroot
07:21:13 <pookleblinky> phadej: I thought of making a symlink this way, but I found an existing ticket for such a symlink not altering the tmp behaviour.
07:21:48 <pookleblinky> as far as I can tell, that works perfectly *after* stack's installed a local ghc into ~/.stack
07:24:48 <sm> ln -s /Volumes/BigDisk /tmp 
07:25:04 <sm> time to get medieval on that sucker
07:25:09 <ongy> sm: that creates /tmp/BigDisk
07:25:22 <ongy> mount -t bind <-- if you have sufficient permissions
07:25:48 <sm> true
07:26:20 <Phillemann> Is there a function that compares two lists and returns a structure indicating which elements are differing, which were added and which were removed (when going from list "a" to list "b")?
07:26:58 <c_wraith> not in base.
07:27:05 <c_wraith> maybe in some other libraries
07:27:10 <Phillemann> Hm, it's just three calls to (\\) when I think about it, but what if I don't want to use the Eq instance but a custom comparison function?
07:27:21 <Phillemann> s/three/n/
07:27:40 <c_wraith> are you treating these lists as multisets, or does order matter too?
07:28:01 <Phillemann> Order does not matter and there are no duplicates.
07:28:22 <ongy> then you can use the set difference \\ (iirc) twice
07:30:57 <smallCat_> Hello, everyone?
07:31:14 <ongy> Hello smallCat_
07:31:42 <smallCat_> I kinda have a question
07:31:52 <ongy> just ask, someone will probably answer
07:31:56 <smallCat_> Does anyone know of a book on dependency parsing in Haskell?
07:32:13 <smallCat_> (Not the paper Dependency Grammars in Haskell- I have that one)
07:32:43 <c_wraith> I don't even know what dependency parsing is
07:33:47 <smallCat_> It's a syntactic parsing technique - in natural language processing
07:34:23 <c_wraith> Hmm.  Do you know where the name came from?
07:34:37 <smallCat_> Hmm?
07:34:44 <smallCat_> Dependency parsing?
07:34:54 <c_wraith> yeah
07:35:16 <c_wraith> Anyway, I obviously don't know of any books on the topic, but I can tell you there are a *lot* of NLP packages on hackage.  Maybe some of them use it.
07:36:24 <smallCat_> It's because of the method of parsing- a dependency tree of a sentence divides it into "heads" that are modified by "dependents"
07:37:18 <smallCat_> Like- a dependency tree of "he ate a cat" would have "ate" as a head and "he","a cat" as dependents (ie: child nodes)
07:38:30 <smallCat_> So basically, I'm looking into possibly building a parser using haskell? And one of my NLP profs mentioned a book on this topic, so I'm trying to search for it
07:38:55 <c_wraith> That's a neat topic.  I hope someone can help you out. :)
07:39:28 <saurabhnanda> anyone with generics-sop experience?
07:39:37 <c_wraith> For what it's worth, you might try asking again in 3-4 hours.  You get a lot more west coast US people paying attention that that time of day.
07:39:49 <smallCat_> I'll try that, thanks!
07:41:42 <saurabhnanda> c_wraith: was that for me?
07:41:48 <c_wraith> No
07:42:27 <merijn> smallCat_: Or try the haskell-cafe mailing list/reddit
07:42:42 <merijn> smallCat_: Those are more asynchronous so more likely to catch that 1 person who knows
07:42:59 <smallCat_> I'll do that!
07:44:14 <ertes-w> "he ate a cat"…  what a lovely example
07:44:38 <rom1504> don't eat them
07:44:51 <smallCat_> Sorry :P I'm a little weird when sleep deprived
07:45:16 <saurabhnanda> wrt generics-sop, can I get the count of NS n-ary structure? For example (S (Z Nil)) should be 1; (S (S (Z Nil))) should be 2; and so on...
07:45:18 <c_wraith> I just assumed the referent of "he" was "ALF"
07:47:01 <saurabhnanda> got it -- hindex
07:54:12 <ertes-w> that…  wasn't meant to be sarcastic…  i found it quite heart-warming
07:55:53 <ab9rf> c_wraith: wow, you just dated yourself :)
07:56:22 <c_wraith> ab9rf: amusingly, I never watched ALF.  I just have a friend who's obsessed with it....  Who's younger than I am.
07:58:07 <c_wraith> ab9rf: But it means I get to say I have over 30 years experience programming!
07:58:25 <shapr> yay!
07:58:41 <ab9rf> c_wraith: heh. in one year i get to start claiming _40_ years experience programming :)
07:59:13 <Rembane> ab9rf: How did you program 40 years in one year?
07:59:17 <c_wraith> ab9rf: I haven't even been alive 40 years. :P  (you might, from this, infer that I started programming very young)
07:59:37 <ab9rf> Rembane: parallel processig on multiple cores
08:00:44 <ab9rf> c_wraith: well, i started when i was nine
08:01:01 <Rembane> ab9rf: Cunning!
08:01:06 <c_wraith> ab9rf: yeah, what took you so long? :P
08:01:34 <ab9rf> there weren't a lot of computers prior to 1978 that someone under ten could easily gain access to
08:02:00 <c_wraith> details. :)
08:02:02 <ab9rf> i did sorta program a computer in 1972, but that was really more of a calculator
08:02:29 <codedmart> Is it possible in this gist to do something like `type AllDocType = BuildDocTypes <> BidDocTypes` -> https://gist.github.com/codedmart/dea56e3b689e1d5efe5ff673a0c65fdf#file-main-hs-L34-L40
08:03:36 <raynold> ahh it's a wonderful day
08:04:16 <shapr> mmm, code
08:04:53 <shapr> Even better, Haskell code!
08:06:21 <mniip> c_wraith, haha
08:06:25 <mniip> I started at 8...
08:06:36 <cocreature> codedmart: does the order matter? just appending BidDocTypes would lead to a different order
08:06:56 <codedmart> cocreature: No order does not matter.
08:07:10 <ongy> first line of code, or first thing that actually made sense in the end?
08:07:19 <mniip> ongy, both?
08:07:29 <codedmart> Is it possible to combine `type`'s?
08:07:48 <ongy> then you either had an easier time to get into it, or more help...
08:08:01 <cocreature> codedmart: you can use TypeFamilies which are basically a restricted form of typelevel functions
08:08:08 <mniip> well, I started with pascal
08:08:17 <ongy> it actually took me until we learned the basics in school (simple loops/arrays etc.) until I got to a point where I could do it for private/fun stuff
08:08:18 <mniip> I started with simple numeric or graphical programs
08:08:31 <codedmart> cocreature: I have `TypeFamilies` enabled. I just have not used so this is new to me.
08:08:42 <mniip> well I think it took me under a year before I could do stuff on my own
08:08:52 <mniip> I had a book on the language too
08:09:09 <ongy> I tried with the internet. But I'm probably a few years younger
08:09:15 <mniip> well, yeah, there was someone who helped me initially, explained the basics ands tuff
08:09:30 <mniip> but from then on I did most of it myself
08:09:36 <c_wraith> mniip: I am one of the few people who survived what Djikstra (iirc) believed to the greatest preventer of ability to program - learning BASIC as my first language.
08:10:18 <mniip> I think I was ... 11? maybe? when I wrote my first 5 kloc program
08:10:46 <Taneb> Didn't Dijkstra suggest that computer science students shouldn't be allowed to touch computers
08:10:51 <mniip> though, pascal's verbosity kinda undermines that achievement
08:10:53 <hexagoxel> codedmart: see HAppendListR from package HList
08:11:56 <ongy> I don't think I have anything with 5kloc till today
08:12:33 <cocreature> codedmart: I don’t really know of a good introduction to type families but here’s a minimal example that implements the type-level version of ++ to get you started http://lpaste.net/355999
08:13:35 <shapr> I started coding at 11, on a Timex Sinclair TS1000
08:13:37 <daniel_adeyemo> hi
08:14:17 <shapr> good morning daniel_adeyemo!
08:15:04 <shapr> now I want to buy a TS1000 to put on my desk at work
08:15:36 <mniip> shapr, heh, I was using a Pentinum 4... I still have it somewhere
08:15:48 <mniip> the harddrive died tho
08:16:21 <codedmart> cocreature: Thanks for the example. I will try and read up on it more.
08:16:30 <codedmart> @hexagoxel Thanks for the link.
08:16:30 <lambdabot> Unknown command, try @list
08:19:41 <ddellacosta> are there any data structures readily available in Haskell that give me O(1) append as well as O(1) index lookup? Doesn't seem like Array or Vector fit the bill, but I also can't figure out what amortized complexity is for Array operations based on the docs
08:20:08 <ddellacosta> and maybe Vector gives me O(1) append somehow, but I only saw O(n) for append I think
08:21:08 * hackage irc-core 2.3.0 - IRC core library for glirc  https://hackage.haskell.org/package/irc-core-2.3.0 (EricMertens)
08:22:08 * hackage config-schema 0.5.0.0 - Schema definitions for the config-value package  https://hackage.haskell.org/package/config-schema-0.5.0.0 (EricMertens)
08:22:10 <shapr> ddellacosta: you can get a good balance with the finger trees in data.sequence, but I don't remember the exact complexity; I'm sure it's higher than O(1)
08:22:25 <ddellacosta> yeah I mean, mostly I'm trying to avoid O(n) here
08:22:29 <codedmart> @cocreature Is that example you gave supplied somewhere already?
08:22:29 <lambdabot> Unknown command, try @list
08:22:36 <ddellacosta> thanks shapr, will take a look
08:23:08 <cocreature> codedmart: probably but I’m not sure where. I’ve lost track which of the various type-level list packages works with modern GHCs and is actively maintained
08:23:26 <codedmart> OK thanks again!
08:23:38 <ddellacosta> I'm also trying to think about whether or not I can structure the algorithm differently to simply return stuff in the right order, that may end up being The Right Way
08:24:12 <cocreature> ddellacosta: if you’re fine with living in ST or IO https://hackage.haskell.org/package/dynamic-mvector-0.1.0.5/docs/Data-Vector-Mutable-Dynamic.html should give you amortized O(1) append and O(1) lookup
08:24:39 <ddellacosta> cocreature: thanks! I'm relatively new to Haskell so I don't think to look in places like that--will take a look
08:25:01 <shapr> ddellacosta: One of the Advent of Code 2016 problems was designed to overwhelm the complexity of your data structure operations, Data.Sequence did all the craziness in a reasonable amount of time.
08:25:11 <ddellacosta> ah neat
08:25:38 * hackage glirc 2.22 - Console IRC client  https://hackage.haskell.org/package/glirc-2.22 (EricMertens)
08:26:17 <ddellacosta> yeah looks like lookup is O(log(min(i,n-i))), which probably makes a hell of a lot more sense if you understand the underpinnings...will read up on this. Verry interesting
08:28:21 <shapr> ddellacosta: my python friends nearly collapsed in tears trying to solve that problem with lists. Anyway, finger trees have a pile of good points: http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
08:29:27 <ddellacosta> shapr: haha...yeah I've heard of them but never really investigated. Very cool how many use-cases they seem to have... "can serve as a sequence, priority queue, search tree, priority search queue and more."
08:30:02 <shapr> and they mostly have excellent complexity for all the operations
08:30:15 <ab9rf> when all yuou have is a hammer, everything looks like a nail
08:30:26 <shapr> Happily, finger trees are multitools
08:30:51 <ddellacosta> kinda wild...I do wonder what they are bad at, where they fall over. I haven't grokked them well enough yet to see
08:31:14 <c_wraith> ddellacosta: they don't have the best constant factors.  Specialized structures will often beat them for specific use cases.
08:31:27 <ddellacosta> makes sense c_wraith
08:31:34 <tsahyt> @hoogle Either a b -> ExceptT a m b
08:31:34 <lambdabot> Control.Monad.Except ExceptT :: m (Either e a) -> ExceptT e a
08:31:34 <lambdabot> Intro ExceptT :: m (Either e a) -> ExceptT e a
08:31:34 <lambdabot> Control.Monad.Except runExceptT :: ExceptT e m a -> m (Either e a)
08:33:13 <cocreature> tsahyt: it’s called hoistEither in "errors"
08:33:41 <tsahyt> it's also in the either package
08:33:43 <tsahyt> but for EitherT
08:33:53 <tsahyt> when would I use EitherT over ExceptT and vice versa?
08:36:11 <cocreature> never, EitherT is mostly there because at one point ExceptT had a silly constraint at some point iirc
08:36:37 <glguy> EitherT was an alternative to ErrorT
08:36:52 <glguy> and then EitherT was integrated into transformers as ExceptT
08:37:16 <tsahyt> so ExceptT is always the way to go now? ErrorT is deprecated iirc
08:37:18 <glguy> EitherT now exists mostly for legacy purposes, there's old code that uses it still
08:37:27 <tsahyt> okay
08:37:27 <glguy> ErrorT and ExceptT are just different
08:37:30 <cocreature> ah ErrorT was the one  with the constraint
08:37:33 <glguy> Use the one that does what you want
08:39:57 <Jinxit> are there any good key-value stores that can do some sort of fuzzy matching? i mostly want to find 1-1 matches, but occasionally i want a conditional match that can return several results
08:40:25 <ezyang> what kind of conditional match? 
08:40:43 <Jinxit> Key -> Bool
08:41:10 <ab9rf> so arbitrary?
08:41:17 <Jinxit> i think so yeah
08:41:24 <Jinxit> i guess i have no option but going through all keys
08:41:29 <ab9rf> yup
08:41:43 <Jinxit> maybe i can restructure my problem
08:41:44 <ab9rf> if you want to do a constrained search, you need to constrain the types of searches you can do
08:41:45 <Jinxit> thanks
08:41:48 <Jinxit> yeah
09:02:10 <ReinH> A column-oriented database would make a full column scan more performant, but it will still be awful.
09:04:31 <Jinxit> i realized i can match on a part of the key, which then would have a list of entries
09:04:39 <Jinxit> makes it significantly better
09:07:34 <roconnor> Academic question:  How would you implement Control.Monad.Free.iterA using Control.Monad.Free.foldFree?
09:15:38 <matrium> hi, is there a better way to walk (follow labeled edges) an fgl graph than filtering for the right label in the list of sucessors?
09:16:08 * hackage haskell-gettext 0.1.0.0 - GetText runtime library implementation in pure Haskell  https://hackage.haskell.org/package/haskell-gettext-0.1.0.0 (IlyaPortnov)
09:16:12 <ReinH> iterM phi (Free f) = phi (iterM phi <$> f)
09:16:24 <ReinH> Oh, iterA
09:16:36 <ReinH> it's the same, different constraint
09:16:46 <ReinH> foldFree f (Free as) = f as >>= foldFree f
09:17:10 <sm> haskell-gettext, nice
09:17:25 <sm> hey, it's a new hackage bot
09:17:46 <byorgey> ReinH: I don't think that answers roconnor's question.
09:18:31 <ReinH> It wasn't intended to
09:18:38 <ReinH> I'm just providing some context
09:19:39 <oop_dependent> Hello, I am learining haskell... I have a problem reading library code that does not https://wiki.haskell.org/Import_modules_properly ... is there any editor that that can help me?
09:19:52 <glguy> roconnor: My initial take is that you won't be able to, because you'll have no way to build a value of type (forall x. f x -> m x) as demanded by foldFree
09:19:59 <ReinH> oop_dependent: what sort of problem?
09:20:15 <sm> oop_dependent: you can load the module in ghci and use :i SYMBOL
09:20:44 <oop_dependent> I never understand where the operators come from
09:20:49 <sm> also, if a symbol isn't defined in the file or project you can search for it with hoogle
09:21:04 <glguy> we'd have to transform the  (f (p a) -> p a) we have somehow to a  (forall x. f x -> ...) knowing only that Functor f
09:21:06 <sm> these are easier than setting up an IDE to give that information, usually
09:21:17 <matrium> I'm looking for something like "Graph gr => gr a b -> Node -> b -> [Node]", but the closest thing is "lsuc :: Graph gr => gr a b -> Node -> [(Node, b)]" which requires a filtering on the whole list
09:21:50 <glguy> There are trivial monads m that we could do that for, but that would require forgetting too much
09:21:57 <ReinH> glguy: it's worse than that
09:22:12 <ReinH> iterA :: (Applicative p, Functor f) => (f (p a) -> p a) -> Free f a -> p a 
09:22:34 <ReinH> the natural transformation is fp ~> p but it's a Free f, not a Free f (p a))
09:22:49 <roconnor> glguy: since foldFee is the defining property of FreeMonad, I think it has to be possible.
09:23:05 <oop_dependent> sm: ok, that is what i do... but it is really time consuming... I would like to at least get the module name and the type inside the editor window...
09:23:11 <byorgey> could we pick m cleverly somehow so we can ignore the x's and pack all the relevant information into the m structure?
09:23:24 <glguy> roconnor: You're thining there's a clever enough choice of 'm' then to make it work out?
09:23:32 <roconnor> I think so.
09:24:02 <sm> oop_dependent: it's not that slow, you can define a browser shortcut so it's eg open browser tab, "ho SYMBOL"
09:24:10 <ReinH> But... m is already fixed at p?
09:24:13 <glguy> no
09:24:27 <sm> oop_dependent: which editor(s) are you already using for haskell ?
09:24:27 <byorgey> ReinH: no, we'd have to postcompose with something to extract the p
09:24:33 <glguy> You can write   \f x -> fixup (foldFree (something f) x
09:24:38 <ReinH> Ok.
09:24:55 <roconnor> yep, fixup is okay to use.
09:25:30 <oop_dependent> sm: vim, neovim, atom... I'm doing experiments to find the best one... atom seems close to the best IMHO
09:25:55 <ReinH> well, fixup can be f itself, then we have iterM phi <$> f = f as >>= foldFree f
09:26:12 <ReinH> (or iterA, equivalently)
09:26:16 <portnov> >> For this resource the content-type was expected to be application/x-tar, rather than binary/octet-stream
09:26:18 <portnov> eeh
09:27:19 <ReinH> er, phi itself
09:27:25 <ReinH> in this case
09:27:49 <sm> oop_dependent: for local symbols, be sure to set up tags (eg with hasktag)
09:28:00 <sm> hasktags
09:28:44 <roconnor> ReinH: :D  iterA phi (foldFree id)  
09:28:51 <ReinH> My brain doesn't appear to be working, but can't we just convert fmap to >>=?
09:28:52 <ReinH> Right
09:29:09 <roconnor> ReinH: Let's try making fixup non-recursive.
09:29:33 <roconnor> only recursive thing allowed is foldFree.
09:29:37 <ReinH> hmm
09:30:59 <oop_dependent> It would be nice to have a beautyfier tool that rewrites all imports (and the code itself) making them qualified (or explicit), check-pvp just complains, has no option to "fix the code"
09:31:03 <oop_dependent> sm^^
09:31:11 <ReinH> oop_dependent: there's stylish-haskell
09:31:14 <ReinH> and hindent
09:31:21 <monochrom> Oh! That reminds me. ghc -ddump-minimal-imports
09:31:25 <ReinH> which cooperate nicely to format your code and imports
09:31:48 <monochrom> Let me double-check the actual spelling
09:31:48 <ReinH> well, it won't rewrite imports
09:32:16 <monochrom> I spelt it right.
09:32:24 <sm> oop_dependent: I think you can find such a thing on hackage
09:32:24 <oop_dependent> Ok, ghc -ddump-minimal-imports does that, monochrom?
09:33:02 <monochrom> It outputs a file that has highly restricted imports.
09:33:21 <sm> once you get familiar with common libs, this may become less of a problem
09:33:58 <oop_dependent> sm: you are right
09:34:00 <monochrom> It doesn't mutate the original file. Nothing does.
09:34:25 <monochrom> (Except a bug a long time ago that erased erroneous files...)
09:34:27 <oop_dependent> sm: but this entry barrier adds up to the pile of things to learn at the beginning
09:35:01 <roconnor> glguy: ReinH:  I'm thinking of m being something like (Cont (p a))
09:35:53 <glguy> Or just Codensity?
09:36:18 <ReinH> Pour some Kan extension on it.
09:36:40 <sm> oop_dependent: yes
09:37:15 <roconnor> glguy: ReinH: given (f :: f (p a) -> p a) you can make \fx -> Cont (\k -> f (fmap fx k))
09:37:29 <roconnor> glguy: ReinH: given (f :: f (p a) -> p a) you can make \fx -> Cont (\k -> f (fmap fx k)) :: forall x. f x -> Cont (p a) x)
09:37:45 <sm> import syntax is not too helpful here, and the tools do not yet compensate
09:38:37 <roconnor> But this isn't a solution.  Just hinting that we can turn f (p a) -> p a into a natural transformation.
09:38:50 <monochrom> What you need is some of those technologies showed in big-budget Hollywood movies only. :)
09:38:58 <ReinH> A lot of work has been put into editor tooling for Haskell, but there's still a lot of work to be done.
09:39:18 <monochrom> You stand in a large room with wall-size screens and a dozen minions taking your orders.
09:39:40 <oop_dependent> monochrom, sm: http://gbacon.blogspot.it/2009/06/cleaning-up-your-haskell-imports.html talks about ghc -ddump-minimal-imports
09:40:11 <monochrom> You just have to say "what is that *> thingie there?" and a minion is responsible for operating the computer to display a hover window showing its information.
09:40:18 <ReinH> -ddump-minimal-imports could be automated, for instance
09:40:40 <roconnor> ReinH: hmm a Kan extensions does seem like a good idea.
09:40:50 <ReinH> roconnor: lol did you think I was joking? :D
09:40:50 <byorgey> roconnor: why isn't that a solution?
09:41:12 <ReinH> Kan extensions are ALWAYS a good idea.
09:41:19 <roconnor> byorgey: you end up with Cont (p a) a out the end instead of (p a)
09:41:32 <monochrom> And then you say "who wrote it?!" and the computer (again operated by your minions) will show the author's mugshot, driver's license, passport, and satelite images of where they live. :)
09:41:54 <ReinH> git background-check
09:42:10 <byorgey> roconnor: yes, but isn't that isomorphic to  (a -> p a) -> p a  ?  just apply that to 'pure'
09:42:22 <roconnor> byorgey: ah yes I forgot about pure!
09:42:49 <sm> @remember FAQ How to find symbol definitions ? Search in file, search in project, set up editor tags eg with hasktags, use :i in ghci, search hoogle with browser shortcut or editor plugin
09:42:49 <lambdabot> Done.
09:43:15 <roconnor> byorgey: This is great.  IterA only uses pure and not (<*>), same as the solution here.
09:43:25 <byorgey> ah, indeed
09:43:29 <roconnor> byorgey: the types check so it must be correct.
09:43:34 <byorgey> right =)
09:46:15 <roconnor> glguy: ReinH: so a solution seems to be IterA f m = runCont (foldFree (\fx -> Cont (\k -> f (fmap k fx))) m) pure
09:46:50 <monochrom> @quote FAQ
09:46:50 <lambdabot> FAQ says: When asking for help, give details such as platform, GHC version, cabal or stack, exact command line, source code, full output, urls. If it's long, paste at http://lpaste.net
09:47:23 <monochrom> @quote FAQ How to find symbol definitions
09:47:23 <lambdabot> FAQ says: How to find symbol definitions ? Search in file, search in project, set up editor tags eg with hasktags, use :i in ghci, search hoogle with browser shortcut or editor plugin
09:47:32 <monochrom> Oh interesting.
09:47:48 <monochrom> Oh nevermind, it works that way.
09:47:58 <sm> @faq help
09:47:58 <lambdabot> https://wiki.haskell.org/FAQ
09:48:03 <sm> ack
09:48:12 <sm> huh
09:48:19 <monochrom> Now I'm so tempted to have FAQ say something funny :)
09:48:54 <ReinH> roconnor: So basically yoneda? :D
09:48:56 <sm> please don't send it off the rails just yet :)
09:49:00 <sm> @quote FAQ help
09:49:00 <lambdabot> FAQ says: Let's start a haskell faq. Commands help: "@quote FAQ question", "@remember FAQ question ? answer", "@forget FAQ question ? answer". To see all: run @quote repeatedly/grep #haskell logs
09:49:00 <lambdabot> for "@remember FAQ"/contribute a lambdabot patch.
09:49:28 <roconnor> ReinH: I don't see the use of id, but sure, everything is yoneda.
09:49:30 <lpaste> glguy pasted “myIterA” at http://lpaste.net/356001
09:49:41 <glguy> roconnor: How about this one, captures the natural transformations better
09:49:55 <ReinH> roconnor: in the boring "continuation passing is yoneda embedding" way.
09:51:27 <roconnor> glguy: ah yes.  Basically the same as mine (but it sort of has to be).  Codensity seems way more appropriate than Cont (p a) a.
09:52:43 <sm> so, https://wiki.haskell.org/FAQ does exist, that's good
09:53:33 <sm> the portal sites seem to have kept that secret pretty well
09:53:45 <ciao> ciao
09:53:49 <ciao> !lista
09:54:13 <ReinH> And Codensity is, of course, a Kan extension ;)
09:54:36 <roconnor> ta da
09:56:01 <ReinH> Now I guess we can ask if this is a size preserving transformation
09:59:18 <bno1> hi
09:59:29 <bno1> so System.Event was replaced by GHC.Event, is it stable?
09:59:48 <bno1> because I tried making a basic client/server with it and sometimes it hangs and does nothing, sometimes it works
10:00:20 <ReinH> bno1: GHC.Event is for internal GHC usage
10:00:32 <ReinH> It says so on the tin.
10:01:28 <bno1> ah
10:01:45 <bno1> I checked the wiki page about epoll and I realised I didn't read the first line "GHC's IO manager has been rewritten to use epoll/kqueue/poll, which should mean all the forkIO examples will run faster than they did in this benchmark."
10:05:14 <EvanR> you can also ffi to unix and use those directly
10:05:42 <EvanR> https://hackage.haskell.org/package/epoll-0.2.2/docs/System-Linux-Epoll-Base.html
10:06:01 <EvanR> i hate that this is called "polling" :(
10:06:25 <bno1> nice
10:07:45 <Athas> So, what's the savvy Haskeller's library for parsing (simple) binary files nowadays?
10:08:02 <EvanR> attoparsec
10:08:23 <ReinH> Why would you use attoparsec to parse a binary file? Why not use binary or cereal?
10:08:47 <EvanR> cereal seems to have lost popularity
10:08:52 <monochrom> attoparsec has a better incremental story
10:09:02 <glguy> What's the better story?
10:09:04 <Athas> I don't need incremental parsing.
10:09:20 <Athas> Data.Binary looks it's for serialisation, but I need to parse an already-defined format.
10:09:39 <EvanR> maybe theres a hackage package for that format
10:09:47 <Athas> There is not.
10:09:49 <monochrom> binary can parse, too.
10:10:11 <Athas> I think maybe Data.Binary.Get/Put is what I need.
10:10:19 <glguy> all of binary, attoparsec, and cereal do incremental chunk parsing now
10:10:23 <ongy> iirc the main difference between binary and cereal these days is if they default to lazy or "normal" bytestrings
10:11:05 <monochrom> binary does? Now I have to check again
10:11:59 <cocreature> I think even the cereal author said that you should use binary
10:12:16 <glguy> not quite
10:12:18 <Athas> Is plain Data.byteString lazy or strict?
10:12:20 <monochrom> OK it does, Decoder and runGetIncremental
10:12:20 <glguy> the binary author said you should use binary
10:13:09 <glguy> There aren't many differences now, one is that the Binary Double and Float instances are inefficient and the cereal ones aren't, and it's hard to change the binary one for legacy reasaons
10:13:23 <monochrom> Anyway, "deserialisation" and "input validation" are just synonyms of "parsing" because some people are afraid of that word.
10:14:04 <Athas> glguy: don't they just read the IEEE binary format?
10:14:10 <glguy> cereal does, yes
10:14:15 <Athas> That's what I need.
10:15:43 <EvanR> yes you need a separate package to get binary to that float format
10:15:52 <EvanR> to read that
10:16:21 <cocreature> no you don’t. "getDoublele/getDoublebe" are iee754
10:19:04 <EvanR> ok, data-binary-ieee754 just has additionally the 16 bit version, and might be faster, going by what glguy  said
10:19:56 <cocreature> I think glguy is referring to the default instance you get via the Binary class
10:20:08 <glguy> yeah
10:36:16 <Athas> Wow, Data.Binary has a really nice interface.  I've never really done binary parsing before.
10:36:26 <Athas> Guess it's really much like any other parser combinator library.
10:45:03 <actualHuman_462> Ok, this is a fairly stupid question - But is there any particular reason I'd need to be afraid of making, say, 30,000 copies of a ForeignPtr?
10:47:11 <actualHuman_462> I'm just sort of curious as to whether or not the FFI actually cares, or if it's all just an Int representing a memory address under the hood anyway
10:48:49 <monochrom> If you're still at the level of "it's just one address underneath" then you haven't known ForeignPtr.
10:49:14 <monochrom> Ptr would be just one address, yes. Not so simple for ForeignPtr.
10:55:09 <actualHuman_462> Hrm, ok, thanks, that's an important distinction
10:56:27 <c_wraith> unrelated question: is Ptr lifted? 
10:57:13 <c_wraith> I guess it must be, as IO (Ptr a) is a common type. 
10:58:43 <jophish> c_wraith: https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Ptr.html#Ptr
10:59:07 <kamyar> Hello friends
10:59:10 <spoonm> hey
10:59:13 <jophish> hi kamyar 
10:59:37 <c_wraith> so Addr# is the unlifted type. 
10:59:42 <kamyar> I am using Data.CBOR in a package but as the author has warned it is not production ready: It is too slow!
10:59:49 <jophish> looks like it
11:00:05 <kamyar> Now wanna replace it with msgpack but not Aeson since it is slow!
11:00:06 <jophish> thoughtpolice: ^
11:00:17 <spoonm> is it implied that `a' implements the `Eq' typeclass if it implements the `Ord' typeclass?
11:00:27 <kamyar> PLease help me how I can substitute my CBOR code with MessagePack alternative
11:00:37 <jophish> kamyar: We replaced lots of slow Aeson stuff with CBOR and got a large speedup
11:00:55 <kamyar> jophish: Which CBOR lib u used?
11:00:58 <thoughtpolice> kamyar: What cbor package are you using? This one? http://hackage.haskell.org/package/CBOR
11:01:42 <jophish> kamyar: well-typed/binary-serialise-cbor (on github)
11:01:58 <thoughtpolice> kamyar: We have a good one that has not yet been released and is very, very fast: https://github.com/well-typed/binary-serialise-cbor/. It uses CBOR as the underlying format, but that's more of the storage format detail
11:02:37 <thoughtpolice> (It's a general library and you could in theory target something like MsgPack, with the way it's designed). There are a few missing spots, but it's seen a lot of production use.
11:07:15 <kamyar> thoughtpolice: Yes! That one! Although I am not sure the slow part is that or Aeson
11:09:30 <Sonolin> spoonm: yup - if you take a look at ":i Ord" in ghci you'll see there's a constraint on Eq
11:09:41 <spoonm> Sonolin: ah cool, thanks
11:14:18 <thoughtpolice> kamyar: 'CBOR' is built on 'binary', so while I can't tell you what the slow part of your app is, I can at least say: binary-serialise-cbor will, at minimum, be multiple times more efficient (time/space), in pretty much every use case.
11:15:06 <kamyar> thoughtpolice: U mean I replace CBOR package with github alternative?
11:15:31 <thoughtpolice> kamyar: Yes, but it depends on exactly what you're using it for, to be honest.
11:15:49 <kamyar> thoughtpolice: How fast Aeson is for Json serialization?
11:15:56 <thoughtpolice> kamyar: If you need strict CBOR RFC compliance (e.g. interop, because you need to talk CBOR to some other program), there may be a few things missing, but we could probably add them. You can construct CBOR terms manually. If you just need a way of serializing Haskell data, it's already extremely well suited for that, too.
11:16:01 <kamyar> thoughtpolice: Is there any other faster alternative?
11:17:00 <thoughtpolice> e.g. you just want to write a Haskell type to disk and read it back? binary-serialise-cbor is better than both binary AND aeson.
11:17:07 <kamyar> thoughtpolice: Here is my cide: http://lpaste.net/356004
11:17:11 <thoughtpolice> kamyar: There are some faster alternatives but none of them are as popular and I think I only know of some hand-crafted alternatives for specific cases.
11:17:42 <kamyar> thoughtpolice: No! I get data from RESTful web service client and save in binary format in redis
11:18:12 <kamyar> thoughtpolice: Now I am slow! I guess that is from Aeson OR CBOR
11:18:19 <kamyar> thoughtpolice: Apparently redis is fast enough
11:18:24 <thoughtpolice> kamyar: Ah, OK. So you don't need to *talk* CBOR to anything else -- you just want to stuff binary blobs in Redis and read them back in your Haskell program, correct?
11:18:45 <kamyar> thoughtpolice: Exactly
11:19:28 <thoughtpolice> kamyar: Yes, then binary-serialise-cbor is probably going to be close to an order of magnitude faster, more memory efficient, and it will result in less bloated applications! So I'd suggest you switch. It's also very easy to use.
11:19:52 <kamyar> thoughtpolice: See my code part and say how
11:20:14 <hanna> What function :: Char -> Bool does the string Show instance use to decide whether to print a character “as-is” or whether to escape it (either via named escape e.g. \DEL or via numeric code e.g. \148)?
11:20:25 <hanna> And does this function exist in a conveniently named form?
11:20:33 <thoughtpolice> kamyar: For example, with that 'data Location ... deriving (Show, Generic)', you can just add '... deriving (Show, Generic, Serialise)'. Now you have an instance and can serialise it.
11:20:44 <hanna> ah, seems like it could be isPrint
11:20:45 <kamyar> thoughtpolice: What about Aeson for JSON? is another faster JSON serilaizer/deserializer
11:20:47 <thoughtpolice> kamyar: Then you can use the 'serialise' and 'deserialiseOrFail' functions inside this module: https://github.com/well-typed/binary-serialise-cbor/blob/master/src/Data/Binary/Serialise/CBOR.hs
11:20:49 <thoughtpolice> You're done!
11:21:23 <thoughtpolice> No need to hand construct the raw CBOR map type or anything like that. You will get an instance and CBOR type generated for you automatically.
11:21:32 <kamyar> thoughtpolice: Got the word. What about my other question?
11:21:38 <hanna> Hmm no, isPrint 'ä' is True but 'ä' shows as '\228'
11:22:27 <thoughtpolice> kamyar: I'm afraid off the top of my head I don't know of one. I might be able to find the one I was thinking of.
11:23:08 <kamyar> thoughtpolice: I am just profiling my code. It is not so complicated! Just read JSON and save CBOR.
11:29:13 <hexagoxel> hanna: looking at chr <$> [0..1000] it seems that 32-127 is as-is, excluding \ (and current delimiter).
11:29:37 <hexagoxel> not sure where/if that is specified somewhere.
11:30:19 <hanna> I guess I could use isPrint && isAscii
11:30:40 <hexagoxel> eh, 32-126
11:31:05 <roconnor> hanna: check out the source for showLitChar in GHC.Show
11:31:39 <roconnor> hanna: I'm not sure that the specific characters are espaced is portable.
11:34:10 <EvanR> can i use tagsoup to validate HTML
11:34:28 <EvanR> (also waiting to see what monochrom has to say about this)
11:35:18 <NeverDie_> T
11:35:20 <roconnor> > char [14, 72]
11:35:22 <lambdabot>  error:
11:35:22 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Integer]’
11:35:22 <lambdabot>      • In the first argument of ‘char’, namely ‘[14, 72]’
11:35:29 <roconnor> > char <$> [14, 72]
11:35:31 <lambdabot>  error:
11:35:31 <lambdabot>      • No instance for (Num Char) arising from the literal ‘14’
11:35:31 <lambdabot>      • In the expression: 14
11:36:05 <roconnor> > chr <$> [14, 72]
11:36:07 <lambdabot>  "\SO\&H"
11:36:10 <monochrom> Haha
11:36:40 <roconnor> hanna: which characters are espaced is context senstive.
11:36:50 <monochrom> Think of tagsoup as just the tokenization stage.
11:36:52 <roconnor> > "\&H"
11:36:54 <lambdabot>  "H"
11:37:07 <roconnor> > "\&W"
11:37:08 <lambdabot>  "W"
11:37:20 <EvanR> whats the next stage
11:37:41 <monochrom> Check the rules about when can tags happen and not happen.
11:37:51 <monochrom> I.e., check the actual HTML rules.
11:38:04 <EvanR> is there are standard package for this
11:38:40 <monochrom> Yes. There are a whole bunch of HTML parsers on hackage. Some use tagsoup, some don't.
11:39:06 <EvanR> thats whats great about standards
11:39:39 <roconnor> > chr <$> [135, 55]
11:39:41 <lambdabot>  "\135\&7"
11:39:55 <pikajude> > '\&'
11:39:57 <lambdabot>  <hint>:1:3: error:
11:39:57 <lambdabot>      lexical error in string/character literal at character '&'
11:39:58 <pikajude> :o
11:40:05 <roconnor> > '\&&'
11:40:07 <lambdabot>  <hint>:1:3: error:
11:40:07 <lambdabot>      lexical error in string/character literal at character '&'
11:40:27 <roconnor> > '\&7'
11:40:29 <lambdabot>  <hint>:1:3: error:
11:40:30 <lambdabot>      lexical error in string/character literal at character '&'
11:40:34 <EvanR> heh \&7
11:40:34 <roconnor> wow
11:40:47 * EvanR tries to remember what that means
11:40:58 <mniip> \& is ""
11:41:05 <pikajude> \& is parse error
11:41:07 <roconnor> > "\&"
11:41:08 <EvanR> > "\&7"
11:41:09 <lambdabot>  ""
11:41:10 <lambdabot>  "7"
11:41:19 <mniip> "\135\&7" means "\1357"
11:41:27 <mniip> except, it's clear that these are 2 characters
11:41:28 <roconnor> > isNull "\&"
11:41:29 <lambdabot>  error:
11:41:29 <lambdabot>      Variable not in scope: isNull :: [Char] -> t
11:41:31 <mniip> \135 and 7
11:41:42 <roconnor> > null "\&"
11:41:44 <lambdabot>  True
11:41:56 <EvanR> > "\1357"
11:41:58 <lambdabot>  "\1357"
11:42:03 <pikajude> in haskell, you never have to check if something == null
11:42:04 <EvanR> :thumbsup:
11:42:06 <mniip> > "\135\&7" == ['\135', '7']
11:42:08 <lambdabot>  True
11:42:20 <pikajude> because you can't check for equality on functions
11:42:41 <pikajude> such a beautiful way to solve the problem
11:42:44 <monochrom> :)
11:42:51 <actualHuman_462> > head []
11:42:52 <lambdabot>  *Exception: Prelude.head: empty list
11:43:44 <EvanR> you never have to check if isNull is null because you cant check for equality on functions...
11:43:56 <pikajude> isn't that what i just said
11:43:58 * EvanR freezes up in an infinite loop
11:45:17 <roconnor> EvanR: I think pikajude comes from another language where null doesn't mean nil.
11:45:21 <MarcelineVQ> I'm still confused, the example was 135 and 55 not 135 and 7
11:45:39 <monochrom> What another language? :)
11:45:42 <EvanR> > chr 7
11:45:43 <roconnor> > ord '7'
11:45:44 <lambdabot>  '\a'
11:45:45 <lambdabot>  55
11:45:47 <EvanR> > chr 55
11:45:49 <lambdabot>  '7'
11:45:50 <pikajude> null only means nil in ruby
11:45:59 <MarcelineVQ> oop :>
11:46:01 <EvanR> ruby is nil
11:46:24 <roconnor> pikajude: In haskell apparently null means [] which is nil in other languages (i.e. lisp).
11:46:34 <EvanR> null [] means True
11:46:37 <pikajude> no, in haskell null means "is it empty?"
11:46:49 <actualHuman_462> I like that I never have to say if (!obj == null) {then obj.method()} , but it's not so much that this concept doesn't exist in Haskell at all, as it is that Haskell makes the process of handling it more explicit and less painful. The Haskell equivalent of == null is a pattern match on the representation of an empty value, bnut you still have to spend code and thought checking to see that something might not exist
11:47:09 <EvanR> is the runtime object for () the same as for []
11:47:19 <EvanR> (resurrecting a lisp debate)
11:47:27 <roconnor> EvanR: probably.
11:47:30 <EvanR> haha
11:47:38 <roconnor> Though it is implementaiton dependent.
11:47:43 <monochrom> null = \case [] -> True; _ -> False.  Therefore, null is not [].
11:48:09 <pikajude> in many languages, null is 0x0
11:48:10 <monochrom> Conclusion: Only monochrom understands the joke.
11:48:13 <pikajude> thanks monochrom 
11:48:16 <pikajude> i tried
11:48:30 <EvanR> what is NULL really
11:48:35 <EvanR> "nothing" 
11:48:36 <EvanR> ok good
11:48:37 <roconnor> pikajude: ha ha you got me!
11:49:05 <pikajude> roconnor: the joke was just that the common pattern "if (foo !== null)" doesn't work in haskell because you can't test for equality with null because it's a function
11:49:31 <EvanR> i dont think you read my reimagining of your statement correctly
11:49:39 <pikajude> i didn't read it
11:49:41 <EvanR> ok
11:49:54 <roconnor> pikajude: right, and I was trying to run isNull, obviously checking if something is equal to the null function.
11:49:58 <pikajude> oh
11:50:05 <EvanR> the first step is isNull isnt defined
11:50:27 <EvanR> in haskell you dont check null == undefined because ...
11:51:22 <ph88^> is there a maybe verion of Control.Monad.when ?
11:51:31 <pikajude> just forM_
11:51:35 <roconnor> Heh, Escardo says you can decide if a function is equal to the null function or not. =)
11:51:42 <pikajude> forM_ maybeAThing $ \ aThing -> ...
11:51:46 <pikajude> that's my favorite pattern
11:52:00 <EvanR> roconnor: this i gotta see
11:52:07 <ph88^> thx pikachu
11:52:19 <pikajude> pika pika, etc.
11:57:08 * hackage hnormalise 0.3.3.0 - Log message normalisation tool producing structured JSON messages  https://hackage.haskell.org/package/hnormalise-0.3.3.0 (AndyGeorges)
11:58:22 <EvanR> so when looking for "haskell HTML parsing" people seem to gravitate to tagsoup, which we just established is not really there
11:59:03 <EvanR> for a command line html validator, people gravitate to node.js, which pisses me off so much i decided to do it haskell
11:59:40 <EvanR> tagsoup is certainly giving me a soup of tags, which i already knew i had
11:59:59 <EvanR> but does that mean theyre opening and closing correctly
12:01:14 <cocreature> EvanR: I thought one of the main selling points of tagsoup is that it can handle broken html to a certain amount
12:01:36 <EvanR> it is
12:02:05 <EvanR> what if you would prefer not to accidentally be shipping broken html
12:02:08 <geekosaur> in fact one of those brokens is specifically not checking tag open/close
12:02:20 <geekosaur> because of broken html generators that get it wrong
12:02:35 <EvanR> i know, this state of affairs is infuriating to me
12:03:35 <monochrom> It is a sick world.
12:04:06 <geekosaur> (well, more precisely it will tolerate -but not try to fix, because that is madness- swapped or mismatched closes, like <b><i>foo</p></b> which a broken generator thought would close both the b and the i
12:04:15 <monochrom> When people mean parsing, they don't say "parsing", they say "validation".
12:04:16 <geekosaur> ...in the wrong place)
12:04:19 <ph88^> pikajude, how can i combine that with a Bool ?   so when i have  True && Just a    i want to do something if anything else i want to do nothing
12:04:35 <monochrom> And when people finally don't mean parsing, for example when they just mean scavenging, now they say "parsing".
12:04:55 <monochrom> So when people say "I use tagsoup to parse HTML" they likely mean scavenging.
12:05:02 <pikajude> ph88^: you can't
12:05:11 <cocreature> real programmers just use regex to parse html
12:05:14 <monochrom> For example they don't care that it's really HTML, they're just looking for a table.
12:05:23 <ph88^> pikajude, ok ^^
12:05:27 <EvanR> we can close the time loop by using scavenging to mean the original usage of parsing
12:05:28 <ph88^> i'll be back later
12:05:35 <roconnor> EvanR: something like isNull f = Data.Searchable.forevery list (\l -> f l == null l) where list = (Data.Searchable.singleton []) `Data.Searchable.union` do {l <- list; c <- foldr (\x y -> Data.Searchable.singleton x `Data.Searchable.union` y) (Data.Searchable.singleton '\0') ['\1'..maxBound]; return (c:l)}
12:06:51 * EvanR continues to validate for a way to check HTML in haskell
12:08:23 <EvanR> HXT seems to be based on Arrow
12:08:24 * geekosaur notes the confusion about "parsing" is roughly similar to that about "sorting", which means something very different in common speech
12:09:09 <EvanR> sorting: filtering
12:09:14 <EvanR> sorting: partitioning, grouping
12:09:22 <geekosaur> yep
12:09:26 <EvanR> sorting: ordering
12:09:59 <EvanR> who are we to calling arbitrarily one of them sorting
12:10:08 <EvanR> sort now means nothing!
12:10:21 <Tuplanolla> Let's sort it out in the backyard.
12:10:30 * EvanR iconoclasms all the things
12:10:36 <geekosaur> technical jargon exists for a reason. it's also distinct from common usage for a reason
12:11:11 <EvanR> its fun to come out of the jargon basement and decode what people are talking about
12:11:15 <monochrom> I am actually no longer sure about that reason.
12:12:17 <monochrom> Because in practice two groups of people will choose two different technical words for the same darn thing.
12:12:47 <EvanR> or the same word for two different things
12:12:51 <monochrom> And they also tend to choose really long words, like "validation".
12:13:05 <EvanR> referential transparency
12:13:13 <geekosaur> that's just context-localized communication idiolect colliding with in-group/out-group. which is par for humans :)
12:13:20 <monochrom> At which point it begins to look like self-congratulation rather than technical communication.
12:13:49 <geekosaur> no, just dumb bald apes getting too far ahead of themselves >.>
12:14:39 <geekosaur> (note, there's very good reason to expect this is only currently limited to humans because we have no other examples of life forms with sufficiently advanced cognition to run into this kind of conflict...)
12:15:44 <EvanR> thing is, i learned of the sorting conflict from a group who used sorting to mean all three things
12:15:55 <EvanR> how did they function
12:16:03 <geekosaur> context
12:16:06 <EvanR> lol
12:16:14 <ongy> 3 meanings?
12:16:15 <monochrom> Don't get me wrong. I came from math. I know the value of having the word "group" to refer to a very specific suite of axioms.
12:16:31 <EvanR> ongy: scroll up
12:16:44 <geekosaur> many English words have more meanings than that :)
12:18:39 <monochrom> What I actually see is that the mathematicians are doing fine. They can get themselves to agree on terminology. They don't tend to use glorifying words. They do seem to be honestly trying to set up techincal vocabulary.
12:19:20 <geekosaur> look a couple centuries back before committing to that one :)
12:19:38 <geekosaur> or even less (notably, our old friend "monad" :)
12:20:13 <EvanR> were monads originally from leibniz 
12:20:17 <EvanR> or the word monad
12:20:25 <EvanR> where the heck did he pull that word from
12:20:51 <geekosaur> @quote geekosaur monad
12:20:51 <lambdabot> geekosaur says: so fwiw it looks like [Mac Lane] introduced it in _Categories for the Working Mathematician_, and his terminology note doesn't explain why he picked "monad", but perhaps can be
12:20:51 <lambdabot> understood to imply a sort of cross between "monoid" and "triad". (p.138 at http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf)
12:20:59 <monochrom> Whereas the programmer "technologists" seem to make up artificial, unnecessary distinctions and choose impressive-sounding words. I can't help but see it as a turf war and dignity war.
12:21:09 <geekosaur> (so I don't have to dig it up again :)
12:21:29 <EvanR> yeah, triads
12:21:31 <geekosaur> the terminology note does indicate MacLane hated the existing terms for the concept
12:21:50 <monochrom> Oh, yeah, "triple" is just too generic.
12:22:21 <monochrom> A monoid is a triple too, you know. (carrier, identity, operator)
12:23:09 <EvanR> or is it a pentaple, carrier, identity, operator, law1, law2
12:23:12 <geekosaur> yep, MacLane's problem as I read it is existing terms either went with "triple" without specifying more precisely, or with "monoid" without specifying more precisely
12:25:41 <Tuplanolla> On a related note it annoys me every time someone says "a grammar is an ordered quadruple".
12:26:11 <Hijiri> Question for anyone familiar with GPipe: Isn't it a problem that PrimitiveArray, VertexArray, etc don't have a context type variable? since they could escape into a different context
12:26:33 <Tuplanolla> Why should I care about the representation of choice?
12:27:16 <EvanR> a (one-tape) Turing machine can be formally defined as a 7-tuple (Q,Gamma,b,Sigma,delta,q_0,F) where
12:29:59 <EvanR> there are 7 pieces of data, but emphasizing a tuple hre is like window decorations
12:31:02 <geekosaur> it's just a claim "these are somehow related"
12:31:21 <Tuplanolla> How about "a grammar consists of" then?
12:31:22 <geekosaur> and/or a container to carry said relateds around
12:32:06 <geekosaur> same, 'quadruple' is '4-tuple' (or the Turing machine could have used 'septuple' instead)
12:32:21 <geekosaur> "we're making an arbitrary relationship between whatsits"
12:32:23 <EvanR> does the orderedness matter really?
12:32:30 <geekosaur> which is more or less how Haskell programmers use tuples :)
12:32:32 <monochrom> No, it is the difference between using a tuple and using a record type.
12:32:47 <EvanR> an unordered record type even
12:32:59 <Tuplanolla> The way it's worded makes it seem like they want to emphasize how every quadruple is a grammar.
12:33:07 <geekosaur> and yes, 'ordered' is more like record type, but math doesn't generally talk about record types
12:33:11 <geekosaur> not to me
12:33:37 <geekosaur> but then I'm thinking in general-math-think when interpeting n-tuple there, not programmer think
12:34:21 <Tuplanolla> Maybe category-think would have you use a product instead.
12:34:22 <geekosaur> in a certain sense, using 'n-tuple' there in math is _disclaiming_ any other special relationship, not emphasizing it
12:35:17 <geekosaur> or you can read it as: is a subset of n-tuples defined by...
12:40:16 <monochrom> Using tuples is just the logical conclusion of the "everything can be encoded as a set" mentality.
12:40:55 <Tuplanolla> Funnily enough any of the encodings they use cannot be decoded without extra information.
12:42:36 <monochrom> Don't get me wrong. I don't avoid sets all the time.
12:42:52 <geekosaur> yes, this stuff is more akin to untyped lambda calculus than Haskell
12:42:53 <ph88^> what's the difference between Source and Producer in Conduit ?
12:43:34 <monochrom> When I teach directed graphs, I do say: a set of vertices, a set of edges, each edge is a 2-tuple.
12:43:45 <geekosaur> notationally at least. because they don't expect you to run the notation backwards; that's programmer-think not math-think
12:44:36 <monochrom> But I don't slap (V, E) on top of that. Clarity trumps fitting everything into set theory. You know the set of vertices, you know the set of edges, you're done.
12:44:44 <EvanR> a graph is a 4-tuple, (V, E, d0 : E -> V, d1 : E -> V) ;)
12:46:22 <EvanR> which is different because you may have more than one edge between two vs
12:46:38 <EvanR> because why the hell not
12:46:43 <Itkovian> If I have a TCPServer (from Data.Conduit) running, how do I make sure that when I get a SIGTERM, I can avoid reading/accepting any more data and at the same time guarantee the rest of the conduit will process whatever is in the pipeline up to that pint? Any ideas?
12:47:20 <Itkovian> The key point is that I do not wish to lose information, if possible, so the data is not recv'ed from the socket.
12:47:45 <codygman_> I was surprised to find out there was no Enum instance for LocalTime or UTCTime. Any reason for that?
12:47:55 <EvanR> both are fractional
12:48:12 <EvanR> LocalTime maybe not literally Fractional, but has a fractional topology
12:48:42 <EvanR> so any Enum for it would have to act like Double which is kind of silly
12:49:07 <EvanR> also Enum requires a notion of "zero" toEnum 0. UTCTime doesnt have that
12:49:37 <stevenxl> Hi folks. If I have stack installed. Is it useful for install binaries (cabal?) globally, or is it more about managing projects? 
12:49:58 <EvanR> since LocalTime is made of a Day and a number of seconds, neither does LocalTime, because Day has no notion of zero
12:50:39 <geekosaur> stevenxl, more about managing projects, but you can do simple deployments with 'stack install' (to, by default, ~/.local/bin)
12:50:59 <codygman_> EvanR: Maybe silly, but being able to do this with day would be helpful: [fromGregorian 2017 5 1 .. fromGregorian 2017 5 20]
12:51:11 <geekosaur> system management isn't stack's thing; it expects you to use a package manager or deployment manager for stuff like that
12:51:38 <Tuplanolla> At what increments, codygman_?
12:51:39 <stevenxl> geekosaur: Thank you. I'm trying to get Snap framework up and running and the directions on the website say to use cabal <yada yada>, but I don't have that. So I guess I'll go download it. 
12:52:08 <EvanR> codygman_: fromGregorian gives you a Day, not LocalTime or UTCTime
12:52:34 <EvanR> and Day is Enum
12:52:34 <stevenxl> I hope I can download it as a stand-alone, because Haskell Book says not to install haskell platform. (Yes, I am confused).
12:52:37 <EvanR> (despite what i said)
12:52:44 <codygman_> EvanR: right, i didn't want to write out LocalTime from my phone lol
12:53:04 <EvanR> heh, well turns out you can do what you just wrote
12:53:20 <sm> stevenxl: but yes, stack is useful for installing binaries such as cabal-install
12:53:31 <codygman_> My use case was generating per hour LocalTime s over a few days
12:53:41 <codygman_> So 72 total
12:53:53 <EvanR> right... it makes sense that "hour" not be the default though
12:53:55 <geekosaur> stevenxl, you're running into a collision between general haskell projects and haskellbook's "stack is your new god" mentality.
12:54:13 <EvanR> you could write a newtype and Enum instance for hour-based enumeration of localtime
12:54:18 <geekosaur> codygman_, how do you expect that to work around DST changes?
12:54:52 <codygman_> EvanR: that sounds promising
12:54:54 <stevenxl> geekosaur: Yes. I am. And there's no "download cabal" button. Is the solution if I just want cabal, not haskell platform, to download source, build, and put it in the search path?
12:55:00 <EvanR> localtime has no notion of DST, it will just work
12:55:02 <stevenxl> sm: tried 'stack install cabal', no go.
12:55:11 <EvanR> all hours and unique and existing
12:55:15 <sm> it's "stack install cabal-install"
12:55:17 <EvanR> are unique and existing
12:55:25 <codygman_> geekosaur: undecided, probably out of scope and I'd just use LocalTime
12:55:40 <EvanR> yep
12:55:49 <stevenxl> sm: thank you - I'm trying it now.
12:56:03 <ab9rf> i love dealing with clocks
12:56:20 * EvanR shakes fist at einstein
12:56:31 <EvanR> and Dali
12:59:31 <codygman_> geekosaur: I'm curious how you would handle DST actually
13:00:02 <stevenxl> sm: that worked fine it seems. even says that the executable was copied to .local/bin
13:00:12 <geekosaur> well. if you are actually going solely by hours and dont care about days, you don't have to.
13:00:16 <sm> that's right, you should add that directory to your $PATH
13:00:53 <stevenxl> I think it's there already. 
13:00:57 <EvanR> codygman_: by enumerating LocalTimes, you are living in a world where DST and timezones do not exist
13:00:57 <geekosaur> if you also require the hours to be related to days, (a) most programmers don't and weird things can happen around DST changes (b) handling it is generally annoying/sometimes painful
13:01:41 <EvanR> calendar days have no notion of time of day, and time of day has no notion of time zones or calendars or politics
13:01:49 <EvanR> so when you combine them, you have a perfect model
13:01:58 <EvanR> but not of any particular country
13:02:32 <EvanR> from there you can put a layer on top
13:02:56 <EvanR> for any paritcular choice of TimeZoneSeries you can decide if that hour is either non existent, remove it, or has been duplicated and so is ambiguous
13:03:14 <EvanR> if its ambiguous, your application might get away with just removing it too
13:03:31 <sm> and for the record, to install snap with stack directly it's: stack install snap --resolver=nightly-2017-01-17
13:03:38 <EvanR> putting in two versions of 2AM into your app might be full featured but people might think its rather insane
13:05:18 <EvanR> after you do this, you can map back and forth between your enumeration and UTCTime
13:05:26 <EvanR> (if you wanted to)
13:07:01 <ph88^> could anyone take a look at this paste? hhttps://bpaste.net/show/0c6f9a4deaf7  i'm confused about the types
13:08:52 <ph88^> eh that's a leading h too much  https://bpaste.net/show/0c6f9a4deaf7
13:13:33 <desperek> should i learn haskell?
13:13:50 <raek> desperek: yes.
13:14:12 <desperek> raek, i am not like into these `pc' programs
13:14:13 <desperek> like
13:14:18 <desperek> i programmed mostly on web
13:14:42 <doyougnu> desperek: I don't think that matters. Learning Haskell will help with whatever programming you do
13:15:43 <mnoonan> So I have this program with a C API that can load .so files as plugins, and I'm working on writing Haskell plugins for it.
13:15:51 <Zaghie> could someone please explain this: newtype Mem s a =      Mem {        runMem :: s -> (a,s)     }  instance Monoid a => Monoid (Mem s a) where      mempty = Mem $ (\s -> (mempty,s))       mappend (Mem {runMem = f}) (Mem {runMem = g}) =          Mem $ (\x -> let                      (u,q) = f x                     (v,w) = g q                     in                     (u <> v,w))                              f' = Mem $ (\s -> ("hi",s+1
13:15:53 <mnoonan> Right now, I've got it building properly
13:16:18 <mnoonan> But I can't load my Haskell plugin in GHCI, because it can't find the API symbols it needs
13:16:54 <ab9rf> could you put that into a proper pastebin? it looks like so much linenoise in chat
13:17:10 <mnoonan> Is there any way to make this work other than somehow turning all of GHCi into a plugin that runs under the host program?
13:17:30 <ab9rf> haskell plugin to ghci?
13:17:34 <Zaghie> newtype Mem s a =      Mem {        runMem :: s -> (a,s)     }  instance Monoid a => Monoid (Mem s a) where      mempty = Mem $ (\s -> (mempty,s))       mappend (Mem {runMem = f}) (Mem {runMem = g}) =          Mem $ (\x -> let                      (u,q) = f x                     (v,w) = g q                     in                     (u <> v,w))                              f' = Mem $ (\s -> ("hi",s+1))
13:18:00 <ddellacosta> Zaghie: probably want to use a pastie
13:18:13 <ab9rf> Zaghie: look at /topic
13:18:15 <sm> @quote FAQ paste site
13:18:15 <lambdabot> FAQ says: Paste long things at a paste site. http://lpaste.net highlights and lints haskell and announces to this channel.
13:18:47 <ab9rf> mnoonan: it sounds like you want to make haskell code callable from C code
13:18:58 <ab9rf> mnoonan: this is doable but nontrivial
13:19:31 <Zaghie> Thanks
13:19:32 <mnoonan> ab9rf: I've already got it so that the host program can load the haskell .so and run it, and the haskell .so can call back into the host API
13:19:53 <Zaghie> just put it on the paste eute
13:19:56 <Zaghie> *site
13:20:18 <mnoonan> I was hoping to add the ability to tinker around with C host program + Haskell plugin in GHCi too, but I can't figure out how
13:20:28 <Zaghie> http://lpaste.net/356005
13:21:14 <ph88^> desperek, learn elm first before haskell .. it will be fun and easier to get into haskell later
13:21:22 <ddellacosta> so Zaghie there's a lot to explain there, potentially--what in particular are you struggling with?
13:21:51 <Zaghie> ddellacosta , I'm struggling with the mempty and Mappend operations
13:21:52 <ph88^> desperek, or purescript is closer to haskell
13:21:53 <ab9rf> mnoonan: there's no way for ghci to have access to the same runtime that the haskell loaded library is runnig in when it's invoked as a DLL
13:22:21 <ab9rf> i don't understand how mempty can be defined in terms of mempty
13:22:26 <ddellacosta> Zaghie: like, what they are actually doing, or what? Can you drill into that a bit more?
13:22:27 <ab9rf> surely that can't be right
13:22:52 <Zaghie> ddellacosta : especially the mappend. What is mappend doing? How is mempty used to define mempty?
13:23:35 <Zaghie> ddellacosta : and the type definition -  is that record syntax? . hope that's clearer?
13:23:36 <ab9rf> hm, actually that might make sense
13:24:23 <ddellacosta> Zaghie: I'm not sure I can answer all of that very well (hint to more experienced folks in the channel!) but yeah that seems more clear to me in terms of what you're asking
13:25:14 <Zaghie> ddellacosta, any help will be appreciated. Also, any more experienced folks who can explain : http://lpaste.net/356005
13:26:10 <glguy> ab9rf, Zaghie: Two different mempties are being used
13:26:11 <tput> mempty specialized to the Mem type is being defined in terms of mempty specialized to the 'a' type.
13:26:22 <lpaste> hexagoxel annotated “Zaghie” with “Zaghie (annotation)” at http://lpaste.net/356005#a356006
13:26:37 <ab9rf> glguy: thank you, that makes so much more sense now
13:26:41 <glguy> instance Monoid a => Monoid (Mem s a) where  mempty = Mem $ (\s -> (mempty,s))  -- mempty at the type  Mem s a   is being defined,  separately the one at time 'a' is being used
13:27:09 <Zaghie> glguy explain?
13:27:19 <Zaghie> lpaste : could you explain the annotations?
13:27:24 <ab9rf> in my defense, i'm thoroughly quite sick
13:27:24 <hexagoxel> Zaghie: it always feels strange to communicate in type sigs only, but they might help your understanding :)
13:27:30 <glguy> Zaghie: mempty is a typeclass method, it's defined separate for every time that it's used at
13:27:40 <byorgey> what are folks doing for testing with GHC 8.2 on travis-ci?  I'm using hvr/multi-ghc-travis of course, but my builds always fail on haddock because the most recent release of haddock requires base-4.9
13:27:46 <glguy> for every type *
13:27:56 <hexagoxel> Zaghie: i just added type signatures in a couple places
13:28:15 <Zaghie> glguy, yes. but how can it be defined in terms of itself?
13:28:20 <ab9rf> Zaghie: it's not
13:28:20 <glguy> Zaghie: It's not
13:28:24 <Zaghie> hexagoxel : thanks 
13:28:32 <ddellacosta> Zaghie: the point is that it's assuming that whatever `a` is, it has its own `mempty` operation
13:28:34 <sm> Zaghie: the second mempty on line 7 is of type a; that type is something other than a Mem, presumably. It will be inferred depending on your code
13:28:37 <ab9rf> the mempty in the definition is a different mempty
13:29:08 <glguy> Zaghie: There are various implementations of mempty like [], Nothing, const mempty
13:29:17 <glguy> which gets used is determined by types
13:29:24 <Zaghie> sm ddellacosta ab9rf , I get it thanks -  that makes sense :) . What of the mappend?
13:29:25 <ab9rf> it will be the mempty applicable to type a
13:29:36 <ab9rf> the mappend is a straightforward chaining, as far as i can tell
13:30:19 <Zaghie> ab9rf , so it's like a fold?
13:30:27 <glguy> Zaghie: Where are you getting this code from?
13:30:41 <ddellacosta> haha, yeah that was my next question glguy
13:30:42 <ab9rf> what is this supposed to do?
13:30:49 <Zaghie> it's a solution to an exercise in the Haskell book
13:30:59 <sm> mappend combines two Mems, by combining the "a" they return (u and v). <> is the generic "combine" operation for a Monoid, which u and v are
13:31:08 <Zaghie> it just defines a Monad Instance for the Mem type
13:31:23 <Zaghie> sm thanks
13:31:27 <Zaghie> it all makes sense now
13:31:31 <glguy> If there's a Monad instance, then these two operations should have been defined in terms of the monad operations
13:31:44 <Zaghie> the typeclasses really help
13:31:47 <Zaghie> **Monoid
13:31:47 <glguy> then you could first understand the simpler monad instance
13:31:50 <sm> (and <> is just mappend, but infix)
13:32:02 <Zaghie> sorry mixed them up. thanks sm
13:33:15 <glguy> Zaghie: is the book actually sprinkling all these uses of $ in ?
13:33:33 <Zaghie> glguy , nope that was me
13:33:41 <ab9rf> that $ in mempty is superfluous
13:33:51 <glguy> all of them in the paste should be removed
13:33:54 <Zaghie> ahh wait it's from the book in the testMem
13:33:55 <monochrom> @quote monochrom \$
13:33:56 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
13:33:58 <Zaghie> ok
13:34:00 <monochrom> @quote monochrom \$
13:34:00 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
13:34:07 <ab9rf> geg
13:34:16 <ddellacosta> I always wondered how you said that
13:34:17 <Zaghie> whats geg?
13:34:39 <ab9rf> it's what you get when my fingers are off by one when i try to type heh
13:34:57 <Zaghie> lmao 
13:35:06 <monochrom> @quote monochrom \$.*love
13:35:07 <lambdabot> monochrom says: $ can't buy you love, but it can buy you function application
13:35:52 <ab9rf> glguy: not fond of shotgunning dollar signs into code at random, are you?
13:36:25 <glguy> I think they stem from confusion about function application
13:36:44 <hexagoxel> well either the $ is redundant, or the parentheses around the lambda are.
13:36:50 <sm> is lpaste.net really slow right now ?
13:36:51 <glguy> But remember if you're writing some code and it doesn't have enough $ for you, you can always prefix a few on the front of a function application, too
13:36:56 <hexagoxel> sm: yep
13:36:57 <glguy> ($) ($) ($) ($) f x
13:37:10 <ab9rf> moneycode
13:37:22 <sm> how can we fix it I wonder
13:37:42 <monochrom> Cloud LPaste
13:37:42 <Zaghie> what’s the most challenging Haskell concept to understand?
13:37:56 <ab9rf> burritos
13:37:58 <monochrom> Types.
13:37:59 <sm> that's a fun question :)
13:38:34 <hexagoxel> the usefulness of TypeInType
13:38:37 <sm> package installation ? 
13:38:38 <monochrom> Nostagia: Before there was cloud computing, there was Usenet.
13:38:38 <Zaghie> lol I don’t think anyone really knows what a Monad is - at leastr I don’t
13:38:41 <hexagoxel> sm: heh
13:38:49 <ab9rf> monads are easy
13:39:08 <ddellacosta> Zaghie: to try to answer your question seriously, I think the most challenging concept to understand varies from person to person, and has a lot to do with where you're coming from
13:39:08 <Zaghie> and what’s TemplateHaskell?  and does anyone actuallt makje websites in Haskell?
13:39:08 <ab9rf> just don't let anyone try to tell you that they're anything at all like a burrito
13:39:28 <Zaghie> ab9rf : lol
13:39:28 <Sonolin> Zaphie check out https://www.youtube.com/watch?v=ZhuHCtR3xq8
13:39:31 <Sonolin> if you haven't yet
13:39:56 <Zaghie> Sonolin : I will :)
13:40:08 <ab9rf> Zaghie: i used to haev a personal wiki that was implemented entirely in haskell
13:40:10 <Sonolin> it was the only thing to get monads through my thick skull :)
13:40:13 <Sonolin> took like 2-3 watches though 
13:40:16 <EvanR> "what a monad is not"
13:40:20 <sm> Zaghie: which things to learn when 
13:40:28 <EvanR> a sadly unconstructive state of affairs
13:40:36 <ab9rf> heh
13:40:45 <Zaghie> sm : that’s a good point -  the Haskell docs are a bit hard to follow at times
13:40:49 <ab9rf> yes, defining something by telling you what it's not isn't useful
13:41:00 <sm> they are all over the place
13:41:13 <Zaghie> Sonolin: i’ll look at em
13:41:23 <sm> they are really good, but not easy to navigate
13:41:29 <Zaghie> sm : are they by open source contributors?
13:41:46 <sm> mostly, yes
13:41:51 <Zaghie> the packages on Hoogle also, but hey, I’m not complaining :D
13:42:18 <ph88^> i made a small test case on a very small function to show my problem with the types   https://bpaste.net/show/7e3b2623c6d8  i think the types are not as they should be in the manual, what's going on ?
13:42:44 <monochrom> No, I disagree. We need more "___ is not ___".
13:43:13 <monochrom> Read up on "confirmation bias".
13:43:18 <EvanR> well
13:43:24 <ab9rf> well, that is a good point, i suppose
13:43:40 <EvanR> at least a monad is not a foo, paired with evidence to why not
13:43:41 <monochrom> Even for basic things like AVL trees, you need to be aware of both examples and counter-examples.
13:43:43 <ab9rf> of course, i don't really know what a monad is, i just use them
13:43:58 <Zaghie> ab9rf : lmao
13:44:07 <EvanR> a monad is not a burrito, we know that. but the claim is that its LIKE a burrito, now what
13:44:30 <sm> hmm, seems lpaste has stopped linting also
13:44:30 <ab9rf> EvanR: i assume that means whoever wrote that article was hungry at the time and really wanted a burrito
13:45:20 <EvanR> we need an argument for why its not even like a burrito, and the work required for this makes the whole situation suck
13:45:43 <ab9rf> and now i want a burrito, and i just ate
13:46:05 <hexagoxel> longer question around Dynamic/HList/manual Dict handling: https://gist.github.com/lspitzner/f8d3eac8c94138e9863a133a42818a96 (asked slightly shorter version half a day ago.)
13:46:13 <ab9rf> also, if they're like a burrito, what is the monadic equivalent of a cilantro pocket?
13:50:39 <Hafydd> If Monads are burritos, what are (more generally) Applicative functors?
13:50:48 <Jinxit> so i'm in an RWST monad, and i want to run a list of computations [RWST ..] but i want all of them to run using the current state as their initialization
13:50:56 <Jinxit> sort-of backtracking between each computation
13:51:05 <Zaghie> what us RWST?
13:51:07 <Zaghie> *is
13:51:22 <Jinxit> reader-writer-state-transformer monad
13:51:32 <monochrom> Hafydd: Consider http://currito.com/ :)
13:51:34 <Jinxit> encapsulates all the above into one monad
13:51:45 <monochrom> Curried burrito because <*> :)
13:51:50 <Hafydd> Haha.
13:52:30 <sm> Jinxit: s <- getstate, forM_ computations $ \c -> runstate s c ?
13:53:09 <sm> s <- getstate, results <- forM computations $ \c -> runstate s c, rather
13:53:35 <Jinxit> yeah that works, was wondering if there's a smoother way
13:53:53 <Jinxit> like local for reader
13:55:40 <Jinxit> sm: wait, doesn't this modify the original state?
13:55:50 <Jinxit> since it's inside the monad
13:57:32 <ab9rf> only with respect to the result of each computation
13:57:46 <hexagoxel> Jinxit: the RWSTs are the same? you just want to "reset state" after each inner action?
13:58:01 <ab9rf> results will be a list of monadic values, each with its own version of the state
13:59:35 <Jinxit> hexagoxel: correct
14:01:03 <hexagoxel> Jinxit: how about "freeze m = s <- get; m; put s" -> "computations `forM_` freeze"
14:02:24 <hexagoxel> eh, freeze m = do ..
14:03:36 <EvanR> hrm in attoparsec... looking for a way to skip until a parser succeeds
14:03:48 <EvanR> manyTill returns a list, but i dont want the list
14:03:59 <ab9rf> EvanR: like discard byte suntil a parser succeeds?
14:04:11 <EvanR> sure discard the byte, because i can get it back with match 
14:04:18 <Jinxit> that handles state nicely, but what about the writer part? how can i be sure it doesn't "leak" to the outer computation?
14:04:26 <Jinxit> this is the part i find the most confusing about monads
14:04:49 <hexagoxel> ah, so not just "reset state" :)
14:05:02 <EvanR> skipTill :: Parser a -> Parser ()
14:05:05 <Jinxit> yeah i wasn't 100% clear
14:05:30 <hexagoxel> Jinxit: wait, but what do you get out then? if you discard the results, and all effects?
14:05:33 <EvanR> match :: Parser a -> Parser (ByteString, a)
14:05:48 <ab9rf> EvanR: probvably soething like p <|> anyWord p
14:05:49 <hexagoxel> or did you not mean to forM_?
14:05:53 <ab9rf> EvanR: probvably soething like p <|> anyWord >> P
14:05:57 <ab9rf> gah
14:06:04 <Jinxit> hexagoxel: i want the writer output as values, but i don't want it to affect the outer monad
14:06:16 <ab9rf> you might need some parentheses or something inthat
14:06:16 <EvanR> hmm
14:06:33 <EvanR> sweet
14:06:47 <ab9rf> EvanR: if p fails, it backtracks, does anyWord, which always succeeds except at end of input, and then tries p again
14:07:06 <EvanR> and then >> return ()
14:07:35 <monochrom> That sounds like very expensive backtracking.
14:07:43 <ab9rf> so skipUntil p = p <|> anyWord *> (skipUntil p)
14:07:51 <ab9rf> monochrom: depends on how expensive p is
14:08:03 <EvanR> p will be a timestamp parser
14:08:34 <ab9rf> attoparsec doesn't have a good wway to do a lookahead match
14:08:41 <monochrom> No, I think it is proportional to the skipped length.
14:08:57 <EvanR> the skipped length is expected to be big
14:09:06 <hexagoxel> Jinxit: then, waht sm said. s <- get; computations `forM` \comp -> do { (_s, w) <- lift $ runRWST comp; tell w }
14:09:12 <ab9rf> monochrom: why?
14:09:24 <hexagoxel> ah, not tell
14:09:24 <EvanR> and then i will get all the skipped blob with match
14:09:32 <hexagoxel> s/tell/pure/
14:09:34 <Jinxit> return instead of tell?
14:09:36 <Jinxit> yeah
14:09:36 <EvanR> so it makes sense that it will save it all
14:09:40 <Jinxit> i'll give it a shot
14:09:55 <ab9rf> EvanR: manyTill might do what you want
14:10:04 <EvanR> it builds a list of bytes though
14:10:10 <ab9rf> just discard it
14:10:14 <EvanR> erm
14:10:16 <hexagoxel> Jinxit: i assume you still want to run in the same underlying m, so you need that runRWST/lift combo.
14:10:27 <ab9rf> the compiler might realize that and not actually construct the list :)
14:10:33 <EvanR> that seems far fetched
14:10:41 <monochrom> I see, not proportional to the skipped length. Just p's cost.
14:11:08 <ab9rf> monochrom: that's my take on it. you;'ll be backtracking p at each point when it fails
14:11:14 <Jinxit> hexagoxel: see this is the part that confuses me, if it runs in the underlying m, does it not propagate any `tell` calls to the top?
14:11:15 <ab9rf> but anyword never fails (except at end of input)
14:12:29 <monochrom> Also, the compiler is still not smart enough to omit the list.
14:13:20 <EvanR> can i also avoid consuming the part that p matches
14:13:33 <ab9rf> EvanR: not that i know of
14:13:38 <EvanR> or i guess i should return its result
14:13:57 <EvanR> i have this
14:13:58 <EvanR> skipUntil p = p <|> (anyWord8 >> skipUntil p)
14:14:16 <ab9rf> that should return whatever p matches
14:14:44 <EvanR> and match (skipUntil p) should return what comes before, and including what p matches
14:14:53 <EvanR> which is annoying
14:14:57 <ab9rf> yeah
14:15:19 <EvanR> hmm
14:15:25 <ab9rf> the bytestring in match's return will include the bytes matched by p as well as those skipped
14:15:33 <Jinxit> hexagoxel: but at the same time i want the Except (which is the T in my RWST) to bubble up
14:15:48 <hexagoxel> Jinxit: lift will lift `m` actions into the `RWST r w s m`. and just `m` actions can't `tell`.
14:16:13 <EvanR> how about this crazy plan, try p, detect if it succeeds, act like it fails, but save the result, then terminate the skip
14:16:22 <EvanR> haha
14:16:47 <ab9rf> EvanR: i don't know how to make attoparsec backtrack and then succeed
14:17:31 <EvanR> or more directly, terminate the skip when p succeeds, but dont consume what p consumes
14:17:48 <EvanR> then use p normally to get the result
14:17:52 <ab9rf> yeah, idon't know how to make it not consume something it matches
14:17:55 <ab9rf> only something it doesn't match
14:18:05 <EvanR> well theres try
14:18:10 <ab9rf> the only way to make attoparsec to backgrack that i know if is for it to fail
14:18:21 <EvanR> p >> fail
14:18:41 <EvanR> the tricky bit is distinguishing fail fail and fail success
14:18:56 <ab9rf> i suppose you could try wrapping it in a state monad and stashing the result there
14:19:04 <EvanR> i dont care about the result
14:19:10 <EvanR> just the consumption effect
14:19:18 <ab9rf> ah. true.
14:19:43 <EvanR> im kind of sad all this is necessary for this kind of operation
14:20:04 <EvanR> give me the blob up to some place the parser succeeds
14:20:06 <ab9rf> EvanR: i was trying to do somethning very similar not long ago and couldn't find a good way to do it
14:21:02 <ab9rf> it's trivial in megaparsec, of course
14:21:09 <EvanR> oh?
14:21:15 <ab9rf> lookAhead p
14:21:28 <ab9rf> lookAhead succeeds if p matches, without consuming tokens
14:21:45 <ab9rf> you may have to use try
14:22:11 <ab9rf> in case p consumes input before failing
14:22:36 <ab9rf> i've used lookahead in Parsec for real parsers, and it works. haven't used it in MegaParsec but it should be the same
14:22:51 <EvanR> can i get the input up to p
14:23:20 <ab9rf> for that i'd still use manyTill
14:23:57 <EvanR> yes... 
14:24:04 <ab9rf> in megaparsec you can do manyTill with a lookahead parser as the end parser. kinda expensive, though
14:24:10 <ab9rf> attoparsec doesn't support this, as far as i know
14:24:15 <EvanR> a list of 100000 Word8 which i want to put right back in a ByteString
14:24:54 <Eduard_Munteanu> It's a bit funny how attoparsec has automatic backtracking given its reputation of being unfriendly and fast.
14:24:54 <EvanR> not looking like megaparsec is right for this
14:25:09 <ab9rf> yeah, that does rather suck
14:25:27 <EvanR> its unfriendly and motionless at the moment
14:25:30 <ab9rf> well, you could always write your own manyTill 
14:25:44 <EvanR> in which library
14:25:57 <EvanR> if attoparsec, thats what im trying to do
14:26:08 * hackage profiterole 0.1 - Restructure GHC profile reports  https://hackage.haskell.org/package/profiterole-0.1 (NeilMitchell)
14:26:13 <ab9rf> i was thinking attoparsec
14:26:16 <glguy> attoparsec doesn't have full backtracking, it shortcuts as soon as an alternative succeeds
14:26:16 <Zemyla> Would you be able to describe a free MonadPlus with the following type: newtype FMP f a = FMP { runFMP :: forall r. Monoid r => (a -> r) -> (f r -> r) -> r }?
14:26:21 <Jinxit> hexagoxel: it compiles, thanks. i'll poke you again if it behaves strangely :)
14:26:54 <iqubic> How does Data.List.Split splitWhen handle consecutive elements that match the predicate?
14:27:00 <EvanR> magic :: Parser a -> Parser (ByteString, a)
14:27:04 <glguy> iqubic: What happened when you tried it?
14:27:06 <iqubic> :t splitWhen
14:27:08 <lambdabot> (a -> Bool) -> [a] -> [[a]]
14:27:13 <EvanR> where ByteString does not include what parser consumed
14:27:28 <iqubic> > splitWhen (<0) [1,3,-4,5,7,-9,0,2]
14:27:31 <lambdabot>  [[1,3],[5,7],[0,2]]
14:27:42 <EvanR> because, detecting where that is is... this entirely problem
14:27:52 <iqubic> > splitWhen (<0) [1,3,-4,-8,5,7,-9,-6,0,2]
14:27:54 <lambdabot>  [[1,3],[],[5,7],[],[0,2]]
14:28:07 <iqubic> Why do I get some empty lists there?
14:28:50 <byorgey> iqubic: those are the segments in between the separators.  e.g. the first list is the list of all the elements between -4 and -8
14:28:58 <ab9rf> ah, wait
14:29:28 <iqubic> byorgey: I need a fuction that is the exact same, but contains no empty lists.
14:29:45 <ab9rf> hm, wut
14:29:45 <iqubic> > splitWhen (<0) [1,3,-4,,-3,-2,-8,5,7,-9,-6,0,2]
14:29:47 <lambdabot>  <hint>:1:24: error: parse error on input ‘,’
14:29:53 <iqubic> > splitWhen (<0) [1,3,-4,-3,-2,-8,5,7,-9,-6,0,2]
14:29:54 <prooftechnique> :t splitWhen
14:29:55 <lambdabot> (a -> Bool) -> [a] -> [[a]]
14:29:56 <lambdabot>  [[1,3],[],[],[],[5,7],[],[0,2]]
14:30:23 <ab9rf> EvanR: there's a lookAhead in attoparsec but it's not documented
14:30:32 <iqubic> I want a fuction that gives me the same kind of result, minus the empty lists.
14:31:01 <EvanR> ab9rf: ok. so ... using match inside the match... i can get the input consumed while parsing the `a`, then subtract that length from the full bytestring
14:31:04 <byorgey> > (split . dropInnerBlanks . dropDelims . whenElt) (<0) [1,3,-4,,-3,-2,-8,5,7,-9,-6,0,2]
14:31:06 <lambdabot>  <hint>:1:63: error: parse error on input ‘,’
14:31:08 <ab9rf> lookAhead :: Parser i a -> Parser i a
14:31:16 <byorgey> > (split . dropInnerBlanks . dropDelims . whenElt) (<0) [1,3,-4,-3,-2,-8,5,7,-9,-6,0,2]
14:31:18 <lambdabot>  [[1,3],[5,7],[0,2]]
14:31:23 <prooftechnique> Hmm. The docs for splitWhen say there shouldn't be those empty lists
14:31:27 <ab9rf> EvanR: that might work
14:31:29 <byorgey> iqubic: ^^^
14:31:38 <prooftechnique> https://hackage.haskell.org/package/split-0.2.3.2/docs/Data-List-Split.html#v:splitWhen
14:31:58 <byorgey> prooftechnique: why do you think the documentation says that?
14:32:19 <prooftechnique> > let f = split . dropDelims . whenElt in f [1,3,-4,5,7,-9,0,2]
14:32:21 <lambdabot>  error:
14:32:21 <lambdabot>      • Couldn't match expected type ‘a -> Bool’
14:32:21 <lambdabot>                    with actual type ‘[Integer]’
14:32:25 <ab9rf> EvanR: lookAhead calls runParser recursively, it looks like
14:32:38 <prooftechnique> byorgey: Because it gives that example and the expected output
14:32:48 <byorgey> prooftechnique: that example has no consecutive delimiters
14:33:04 <byorgey> it is not the same example
14:33:18 <prooftechnique> Oh, fair
14:33:41 <ab9rf> EvanR: there is a general lookAhead for attoparsec in Data.Attoparsec.Combinator
14:33:47 <prooftechnique> > let f = split . dropDelims . whenElt in f (<0) [1,3,-4,5,7,-9,0,2]
14:33:49 <lambdabot>  [[1,3],[5,7],[0,2]]
14:33:52 <iqubic> :t filter
14:33:54 <lambdabot> (a -> Bool) -> [a] -> [a]
14:34:00 <iqubic> :t null
14:34:02 <lambdabot> Foldable t => t a -> Bool
14:34:21 <EvanR> ab9rf: im not sure how to use it
14:34:50 <EvanR> (lookAhead p) <|> (anyWord8 >> this p) ?
14:35:32 <iqubic> > filter (not . null) $ splitWhen (<0) [1,3,-4,-3,-1,-2,5,7,-9,-3,-3,-3,0,2]
14:35:34 <lambdabot>  [[1,3],[5,7],[0,2]]
14:35:41 <iqubic> That also works.
14:35:52 <ab9rf> skipUntil p = (lookAhead p) <|> (amyWord8 *> lookAhead p)
14:36:36 <iqubic> Is my method of removing empty lists after a splitWhen any better than: (split . dropInnerBlanks . dropDelims . whenElt)?
14:36:41 <EvanR> that doesnt recurse
14:37:53 <ab9rf> my bad
14:37:59 <ab9rf> the last call is skipUntil p
14:38:02 <juri_> i swear, some days programming in haskell is like trying to understand your way out of a paper bag.
14:38:19 <ab9rf> then yhou use match on skipUntil to get the bytes matches without having to accumulate them in a list
14:38:24 <monochrom> Just paper bag? :)
14:38:25 <ab9rf> and finally match p
14:39:09 <ab9rf> do (bytes, _) <- match (skipUntil p); blah <- p; return (bytes, blah)
14:39:26 <prooftechnique> iqubic: I'm not sure about the details of the Splitter type, and I also don't know what your measure for "better" is
14:39:45 <ab9rf> i'm sure someone knows how to monadically comnbine those with some clever operator i don't remember, instead of using do notation :)
14:39:50 <monochrom> Will you also say that unsafePerformIO is a double-edged sword that you use to cut your way out? :)
14:39:55 <ab9rf> hah
14:40:08 <ab9rf> i've never been in a paper bag so i can't comment
14:40:30 <monochrom> (Just watched King Arthur so I'm still thinking of swords. And Excalibre.)
14:40:44 <ab9rf> monochrom: the problem is that you might cut the bag in more than once place simultaneously :)
14:42:31 <ab9rf> juri_: anyhow, that's just a symptom of the fact that the abstractions in haskell are perhaps a bit harder to grasp than those in most other programming languages
14:42:59 <EvanR> ab9rf: this doesnt seem to work...
14:43:04 <ab9rf> EvanR: drat
14:43:07 <EvanR> ill paste the code
14:44:54 <EvanR> lookAhead or not doesnt make a difference to my test... http://lpaste.net/356008
14:45:17 <EvanR> oh i never used skipUntil...
14:45:56 <EvanR> ok it works!
14:46:16 <EvanR> so the cost of lookAhead should be construed as the cost of running a sub parser
14:46:32 <ab9rf> yes, lookAhead actually recursively invokes runParser
14:46:33 <EvanR> beginning with the current input location
14:46:56 <EvanR> and thats for each byte
14:46:59 <ab9rf> yup
14:47:24 <EvanR> yeesh
14:47:32 <ab9rf> EvanR: you mightr benefit from using one of the fast skippers if you can write a predicate for the first character of p
14:48:00 <EvanR> the first character will be a digit, but that doesnt mean its the beginning of a matching pattern
14:48:16 <EvanR> unfortunately
14:48:22 <ab9rf> syure, but tat least you'll consume data somewhat faster
14:48:38 <EvanR> there will be a lot of digits leading up to this pattern ;)
14:48:54 <ab9rf> (skip isDigit) will result in fewer calls to lookAhead than (anyWord8) will
14:49:02 <EvanR> ah
14:49:11 <ab9rf> or rather skip (not isDigit) i guess
14:49:12 <EvanR> i wouldnt have to do anything special to handle the skippage
14:49:21 <ab9rf> yeah, match deals with that
14:50:38 * hackage regex-pcre-text 0.94.0.0 - Text-based PCRE API for regex-base  https://hackage.haskell.org/package/regex-pcre-text-0.94.0.0 (ChrisDornan)
14:53:49 <ab9rf> there's probably some additional complications here but nmeh
15:02:38 * hackage weeder 0.1.5 - Detect dead code  https://hackage.haskell.org/package/weeder-0.1.5 (NeilMitchell)
15:17:56 <EvanR> heh... how does one successfully parse both "2000" and "2000whatever" as 2000
15:18:23 <EvanR> it hangs on "2000" waiting for more input
15:20:18 <monochrom> Use eof.
15:21:26 <EvanR> endOfInput ?
15:21:50 <monochrom> You have "eof" in attoparsec, don't you?
15:22:03 <monochrom> Is it called endOfInput?
15:22:12 <monochrom> I don't know. It has something.
15:22:17 <EvanR> yes, doesnt work ;)
15:22:31 <EvanR> parseTest (decimal >> endOfInput) "2000"
15:22:34 <EvanR> Partial _
15:23:34 <EvanR> i think decimal is taking priority, expecting more input
15:23:37 <prooftechnique> EvanR: I think you have to give it `empty` to indicate that you're done
15:23:47 <EvanR> ah
15:25:39 <EvanR> that kind of makes parseTest less useful
15:26:09 <EvanR> since it prints out "Partial _" to stdio... no oppotunity to use the continuation
15:28:21 <monochrom> yeah that's strange.
15:28:48 <ab9rf> i thought parseTest dealt with partials, but i guess not
15:28:56 <prooftechnique> Have you tried parseOnly?
15:29:46 <tosun> I am currently compiling Haskell programs to GHC Core. If the program uses a Prelude function, let's say map WLOG, the resulting program simply refers to the name map. Is it possible to include the definition of map in the Core program? This is what I am doing to get Core currently: http://lpaste.net/356009.
15:30:17 <prooftechnique> Oh, actually, does parseTest (decimal <* endOfInput) "2000" work?
15:31:38 * hackage jsaddle 0.9.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.9.0.0 (HamishMackenzie)
15:32:39 * hackage jsaddle-warp 0.9.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-warp-0.9.0.0 (HamishMackenzie)
15:33:03 <prooftechnique> Hmm. It does not
15:33:38 * hackage jsaddle-webkit2gtk 0.9.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-webkit2gtk-0.9.0.0 (HamishMackenzie)
15:35:08 * hackage jsaddle-webkitgtk 0.9.0.0, jsaddle-wkwebview 0.9.0.0 (HamishMackenzie): https://qbin.io/thwhmdt
15:38:21 <EvanR> ab9rf: http://lpaste.net/356010
15:40:08 * hackage jsaddle-clib 0.9.0.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-clib-0.9.0.0 (HamishMackenzie)
15:42:38 * hackage jsaddle-dom 0.9.0.0, ghcjs-dom-jsffi 0.9.0.0 (HamishMackenzie): https://qbin.io/gox412rx
15:44:08 * hackage ghcjs-dom-jsaddle 0.9.0.0, ghcjs-dom 0.9.0.0 (HamishMackenzie): https://qbin.io/guobjd0
15:45:01 <prooftechnique> EvanR: I guess just adding \n or a space to the end of the Text makes parseTest do what you'd expect. Still weird and unexpected.
15:48:23 <Squarism> when i was ultragreen i created this type : http://lpaste.net/356011 - there are some obvious issues with it, like "Board" is shared by all and it would be alot more readable with record syntax. Now this refactoring would be huge. Anyone have a good advice on making the refactoring simpler?
15:50:42 <Squarism> the "Board" part would require a wrapper type that kept that field, and the phase part would go in a field too. Like Wrapper { board::Board, phase :: GamePhase } ... but that would be quite an extensive rewrite
15:53:42 <dedgrant_> Hi all. Anyone here know anything about the status of the jupyter ihaskell kernel?
16:05:07 <spoonm> as in? whether it's still maintained or...?
16:08:15 <Squarism> dedgrant_, have you tried http://www.tweag.io/projects
16:08:39 <EvanR> prooftechnique: in my case that didnt not even help due to my parser
16:09:00 <EvanR> a wrapper for parse that auto feeds "" would be more convenient
16:10:01 <prooftechnique> I mean, there's parseOnly if you just want to throw away additional text
16:10:29 <dedgrant_> Squarism: No, are you pointing out some workbook alternative?
16:11:01 <EvanR> yeah good enuf
16:13:40 <ttt> test ignore 1
16:17:32 <Squarism> dedgrant_, not sure what you mean (not native english speaker). Im just looking for tips/ideas on how to make this refactoring non huge
16:19:39 <slack1256> Is there a blogpost that explain the interaction between green threads, non blocking IO (rts) and upsides?
16:20:08 <lpaste> mbw pasted “Crashy” at http://lpaste.net/5609628468586217472
16:21:11 <mbw> Could somebody confirm that this crashes for them with runtime error "internal error: stg_ap_v_ret"? According to the GHC wiki, this should be reported, but maybe I am doing stupid things again.
16:21:39 <prooftechnique> Squarism: That type looks pretty ugly. Maybe change it to data GamePhase = GamePhase { board :: Board, phase :: Phase } and then reformulate each of your phases as separate types with a common interface?
16:21:54 <mbw> Needs gi-gtk, haskell-gi-base, text.
16:22:30 <mbw> The crash happens if you click on the button a few times.
16:22:58 <Squarism> prooftechnique, exactly. The problem is all the writing it will require (all places i use these constructors)
16:23:07 <prooftechnique> It looks like they all fit under BadOrGamePhase except for the Finished state, so it might at least clean things up
16:24:13 <guest_random> test
16:24:17 <prooftechnique> If you make a bunch of separate types, are you going to need to do any replacements?
16:25:24 <Squarism> prooftechnique, i have lots of : case gamePhase of ; BlaBlaPhase board x y f -> .... 
16:25:55 <Squarism> or : myFkn (SomePhase board x y z ) =
16:26:23 <Squarism> as i said.. i was a mega noob when constructing that type
16:27:26 <prooftechnique> The case goes from gamePhase to `phase gamePhase`
16:28:47 <prooftechnique> And the SomePhase thing turns into `(GamePhase board (SomePhase x y z))` or something like that
16:30:03 <Squarism> when you say " It looks like they all fit under BadOrGamePhase " what do you mean exactly. I see it as all constructors share a function from <X> onto BadOrGamePhase. Dont know how i could do an abstraction of that?
16:30:52 <prooftechnique> Type family, maybe?
16:30:54 <Squarism> prooftechnique, yeah sure. But i have like 10 such uses for each phase in code + tests. Lots of typing
16:30:56 <prooftechnique> https://wiki.haskell.org/GHC/Type_families
16:31:19 <prooftechnique> You're not gonna cut your way out of this web without a bunch of typing
16:31:33 <Squarism> haha
16:33:01 <Squarism> thanks for the feedback!
16:36:55 <mbw> Could somebody please have a look at this gi-gtk example: http://lpaste.net/5609628468586217472 . This will create a clickable button with a label, and crashes if you click it twice. Doesn't matter if it's compiled or interpreted, or if the callback function is anonymous or top-level. According to the GHC wiki, the runtime error "internal error: stg_ap_v_ret" should be reported, but since I have no idea what 
16:37:01 <mbw> I'm doing, I am yet unsure whether I should do that.
16:38:46 <prooftechnique> https://ghc.haskell.org/trac/ghc/ticket/12168
16:38:50 <prooftechnique> Looks related, mbw
16:39:04 <dedgrant_> spoonm: Oh I missed your reply above regarding ihaskell. Specifically: I went back to try.jupyter.org to find the IHaskell jupyter kernel used there has been broken for quite a while. Is anyone using this? Is it dead? Can I contribute to fixing it in any way?
16:39:28 <dedgrant_> Not finding any obvious points of contact.
16:39:32 <spoonm> this is the repo I got when I looked up what you said: https://github.com/gibiansky/IHaskell
16:39:53 <spoonm> if that's not broken, maybe they're using an outdated version or having server-side problems
16:40:56 <dedgrant_> spoonm: Perhaps. Specific issue logged by dabro: https://github.com/gibiansky/IHaskell/issues/703 in nov 2016.
16:41:21 <spoonm> rip
16:41:34 <dedgrant_> Ah well. I will leave a reply there.
16:44:05 <mbw> prooftechnique: At first glance, they are related only by name. Specifically, this bug seems to concern building gi-gtk itself and can't be reduced to a specific example and the error is a different one.
16:45:04 <hamishmack> mbw: Definitely file add that as an in issue in https://github.com/haskell-gi/haskell-gi/issues
16:46:36 <prooftechnique> Yeah, sorry, I googled for stg_ap_v_ret and gi-gtk and I think it shot me off to the wrong ticket
16:46:55 <mbw> hamishmack: Ok, will do.
16:47:20 <mbw> prooftechnique: From what I saw, stg_ap_v_ret seems to be among the more exotic ones.
16:47:43 <prooftechnique> Yeah, looks like an out-of-bounds unsafeWrite or something wacky like that
16:48:59 <prooftechnique> Hmm. Or it could be anything unsafe. :thinking_face:
16:49:16 <mbw> hamishmack: Is this automatic signal connecting stuff supposed to be supported? The links mentioning "Module" (I guess this is gmodule related?) in the docs don't seem to go anywhere: https://hackage.haskell.org/package/gi-gtk-3.0.14/docs/GI-Gtk-Objects-Builder.html#v:builderConnectSignals
16:49:48 <romand> greetings! Num typeclass requires Eq, yet if I want to compare smth Num, I get "Could not deduce (Eq a)…" error. Why?
16:50:51 <mbw> I _might_ be convinced that it is a better idea to more clearly separate Presentation Layer and Signal Handling, so maybe not all is bad :)
16:50:59 <hamishmack> mbw: You might be breaking new ground.  I am not sure I do not use glade myself.
16:51:19 <monochrom> romand: That was old. Num doesn't require Eq anymore. Add an explicit Eq constraint.
16:51:47 <mbw> hamishmack: Seriously? I thought all the cool kids did, since it's supposedly more productive.
16:52:08 <EvanR> im not aware of many real projects using glade
16:52:37 <mbw> So the generally agreed-on solution is to do things by hand?
16:52:45 <EvanR> in C? of course
16:53:15 <romand> monochrom: oh, I see. thanks!
16:55:08 * hackage wolf 0.3.16 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.16 (markfine)
16:56:26 <mbw> Ok, maybe I am going the wrong way about this. I just want to be able to "slap together" a gui, if needed. From what I read, Gtk bindings were most mature, FRP still experimental, yada yada. Is this advice outdated? 
16:57:24 <EvanR> slap together a gui... well there is threepenny-gui
16:57:49 <EvanR> which is based on browser tech, the king of "slapping stuff together"
16:58:54 <EvanR> i should start making a spreadsheet to list how to "slap together a gui" in language x
16:58:58 <mbw> I looked at that, but didn't know where to begin. Since I don't have any experience with this kind of stuff, I kind of need some introductory material...
16:59:19 <EvanR> as i understand it, you run your program and it spits out a URL
16:59:26 <EvanR> then you navigate to that URL
17:00:08 <mbw> But you can't create the gui itself in a point&click manner, right?
17:00:25 <EvanR> no and that generally doesnt really work outside visual basic
17:00:26 <malice`> Hi, anyone with gentoo in here?
17:00:33 <thang1> Even most web stuff isn't point and click :p that's java
17:00:42 <malice`> I am trying to install stack and I have this compilation error at dev-haskell/connection: http://ix.io/w9m
17:00:43 <thang1> EvanR: Java has some decent solutions for GUI created GUI, I think
17:00:45 <malice`> any ideas how to fix it?
17:00:52 <EvanR> hmm yeah java
17:01:13 <mbw> I saw a colleague of mine do that kind of stuff with Delphi
17:02:00 <EvanR> GUI programming is stuck in the dark ages, or is web based and stuck in an alternate history dark ages
17:02:00 <mbw> Also, I think even C++ people can do it with qt
17:02:21 <EvanR> well, as you can see, there is glade for gtk+ in C
17:03:03 <EvanR> also dont think many real projects use point and click gui building for much, qt or not
17:04:00 <EvanR> i suspect its a combination of inflexibility, struggling as much with the extra tools as with the bare library (in addition to the bare library)
17:04:01 <mbw> Ok, but most "real projects" are created by a team, and there are higher standards in a professional setting.
17:04:06 <spoonm> cli is superior
17:04:38 <EvanR> back in the day, it only took 1 person to make a cool graphical program
17:04:53 <thang1> Most real projects are made with quick mockups followed by polished final. Can't do have your design team do quick mockups in code; they're designers not programmers :p
17:05:08 <EvanR> look at the haskell "environment" called manatee, based on GTK
17:05:22 <EvanR> somehow it was build completely from scratch by one pereson... manatee
17:06:44 <hamishmack> mbw: I think reflex-platform is worh a look https://github.com/reflex-frp/reflex-platform
17:06:57 <EvanR> mbw: if youre unfamiliar with the underlying tech of all these suggestions, then maybe before doing the haskell version you go learn the normal version: gtk+ in C, web programming, etc
17:07:25 <EvanR> so you dont have to learn multiple crazy systems at the same time
17:10:45 <thang1> and, I assure you, if it even potentially involves graphics in any way shape or form, it's crazy
17:11:24 <mbw> EvanR: I was working my way through a gtk+ book, translating the examples.
17:11:41 <mbw> But really, I am not looking to become a gui pro.
17:11:49 <mbw> Just to be clear, I hate GUIs.
17:12:03 <mbw> Or rather, using them
17:12:23 <mbw> But still I thought knowing a view basics couldn't hurt.
17:12:48 <thang1> mbw: look up MVC paradigm
17:14:06 <EvanR> reactive banana can be used for GUIs
17:14:25 <EvanR> im not sure youd call it experimental
17:15:44 <mbw> This is all starting to become the same mess as when I was comparing different ways of handling multi-dimensional arrays in Haskell.
17:16:31 <EvanR> the difference is the GUIs are a mess anywhere you go
17:16:57 <EvanR> perhaps some system has a favorite, premade working GUI framework, like Java
17:17:00 <EvanR> haskell doesnt
17:17:30 <mbw> Yeah I'm not blaming anybody.
17:17:33 <EvanR> and i dont think it should go that right
17:17:48 <EvanR> go that route
17:18:08 * hackage test-fixture 0.5.0.1 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.5.0.1 (lexi_lambda)
17:18:42 <mbw> Don't get me wrong, I chose to invest time into learning Haskell _because_ there is not this "There should be only one way to do it" philosophy, like in that other language.
17:19:02 <johnw> are you saying we're like Perl in that regard? ;)
17:19:32 <mbw> When it comes to funny operators, yes.
17:19:33 <EvanR> i would like to think haskell has a spirit of experimentation
17:23:00 <mbw> Yeah, but it never stops. Be it parsing, pretty-printing, web-client programming, multi-dimensional arrays, guis, at some point you want to be able to "get started" and not have to feel like a complete idiot again :)
17:23:26 <juri_> i like feeling like an idiot. ;)
17:23:32 <juri_> it's such a change...
17:24:05 <mbw> Yeah but idiots don't get enough sleep.
17:25:24 <EvanR> if i go back to ruby on rails and try to "just get started" ... ill feel like an idiot for other reasons
17:25:56 <EvanR> damned whereever you go
17:28:01 <EvanR> i do think that most bindings for existing frameworks you find in haskell will basically require you already understand it in the terms of the world it came from
17:28:18 <EvanR> and you wont find anything in haskell to help with it
17:28:29 <EvanR> unfortunately
17:28:41 <mbw> That's not so good...
17:28:44 <EvanR> to get anything done you basically need to know everything!
17:29:13 <mbw> You have got to be a mathematician...
17:29:32 <geekosaur> "to write a Haskell program, you must first invent the universe"
17:30:53 <EvanR> so you want to write hello world in haskell, let me show you some basic category theory
17:30:57 <pikajude> this is left as an exercise to the reader
17:31:01 <mbw> lol
17:33:08 * hackage regex-with-pcre 1.0.1.0 - Toolkit for regex-base  https://hackage.haskell.org/package/regex-with-pcre-1.0.1.0 (ChrisDornan)
17:33:28 <mbw> Still, I'm sure even an imperative library like gtk can become flexible, given the ways you can handle functions and ways to compose them in Haskell. Maybe even some aspects of mvc fall out naturally, given the distinction between pure and effectful functions...
17:33:51 <mbw> I have no way of telling until I get past toy examples.
17:34:02 <mbw> And compiler bugs.
17:36:13 <EvanR> youd think
17:36:26 <EvanR> but we still dont have a functional picture of OpenGL
17:36:35 <EvanR> or GTK+
17:36:48 <EvanR> we have nice languages backed by them though
17:38:15 <mbw> It's really already an improvement if you can reduce boilerplate by sequencing/mapMing around a little, and making things a little more typesafe.
17:39:08 * hackage regex 1.0.1.0, regex-examples 1.0.1.0 (ChrisDornan): https://qbin.io/ssi9fde
17:39:52 <mbw> That there isn't a functional picture might be a good thing, this kind of stuff needs time. How many mistakes were made in the early ages of OOP after all, just because everything had to be made to fit into the paradigm.
17:44:17 <EvanR> for what its worth, haskell really has a good base of primitives to build on
17:44:58 <EvanR> and you can bridge to world as-it-is via the FFI, in all its glory
17:45:26 <EvanR> or try to create something new and perfect
17:52:20 <mbw> I wonder if Haskell2020 will remove FFI support for C++. As far as I know, there is supposed to be support according the the language report.
17:53:02 <EvanR> not sure how much these standards even matter
17:53:03 <johnw> remove?  you mean we have it now?
17:53:56 <EvanR> C++ support surely increase the barrier to implementing haskell
17:54:09 <EvanR> and the barrier seems kind of extreme already
17:55:18 <johnw> yeah, I don't think that needs to be in the report
17:55:27 <mbw> As long as the way name mangling is supposed to work is not part of the standard or at least consistent between compilers, C++ support will remain a pipe dream.
17:55:31 <johnw> having C is enough to link to nearly anything
17:55:53 <johnw> also, any C++ support will always be an extreme subset anyway
17:56:32 <mbw> Exactly, since there's way too many features to deal with.
17:58:37 <glguy> the Haskell standard doesn't promise c++ support, it just reserves the calling convention name
18:01:07 <mbw> So there's no need to change anything I guess.
18:07:11 <geekosaur> c++11 actually made the mangling part of the platform spec, which is why g++ and clang++ can interoperate except where licensing stupidity gets in the way (e.g. macs / *bsd which refuse to support the gpl3 libstdc++ needed for g++ c++11 support)
18:13:04 <mbw> geekosaur: Thanks for mentioning that, I should probably stop spreading an old wives' tale :)
18:13:41 <EvanR> any word on what causes lpaste's 504 gateway timeouts
18:15:44 <EvanR> besides gremlins
18:17:26 <hanna> What would it take for GHC to be able to infer a Foo (s :: Bool) constraint from an environment containing Foo True and Foo False instances?
18:17:42 <hanna> Clearly the entire space of Bool is “mapped” by instances
18:17:53 <hanna> But I still need to explicitly plumb it through my program (possibly involving existentials)
18:18:43 <Lokathor> rust support!
18:19:59 <Lokathor> in the haskell report i mean
18:20:14 <hanna> basically I want to get rid of all the Foo s => constraints on my constructors and type signatures
18:20:29 <hanna> (Using it with a GADT that's specialized by s)
18:20:53 <hanna> It almost seems like a limited form of dependent typing, or perhaps some form of “closed type class”
18:21:16 <hanna> where GHC can provably know that the function is defined for all values of `s`
18:22:39 <hanna> i.e. I want to write a function foo :: proxy (s :: Bool) -> SomeValue without a constraint on ‘s’
18:27:08 <hanna> I know of the `singleton` representative value trick but writing singletons by hand is also annoying; I'm just wondering if perhaps in 2017 we didn't have a better way already
18:33:29 <EvanR> hanna: doesnt the type family allow a kind signature
18:33:46 <EvanR> so True and False really are the only possible types
18:34:03 <hanna> both classes and type families do
18:34:04 <EvanR> if not, True False and () would all be valid instances
18:34:32 <hanna> It was implicit in my question that Foo :: Bool -> Constraint
18:34:34 <hanna> perhaps I should have stated that
18:34:43 <EvanR> oh its a class
18:35:18 <hanna> Hmm, maybe I could actually use a type family to reduce it to a constraint that GHC can always solve?
18:36:03 <EvanR> if you remove the signature completely, then that will make GHC do inference
18:36:19 <EvanR> but writing the wrong one i dont think will work
18:36:28 <hanna> GHC can trivially solve KnownSymbol (s :: Symbol), right? So I lift my foo :: Bool -> String into a Foo :: Bool -> Symbol I can use KnownSymbol (Foo s) without requiring it on my context
18:36:30 <hanna> I think
18:37:17 <EvanR> Foo :: 'Bool -> Symbol ?
18:37:37 <hanna> Right
18:37:40 <EvanR> and Foo :: 'Bool -> Constraint
18:38:00 <hanna> Sorry I was re-using the Foo name
18:38:11 <EvanR> im making sure youre using '
18:38:16 <hanna> For the Constraint version I was assuming Foo resolved to a typeclass containing a foo :: proxy s -> String
18:38:24 <hanna> hence the Constraint
18:38:43 <hanna> but by using Symbol I could get rid of the class altogether and use KnownSymbol to “lower” it to the value level
18:38:53 <hanna> at least in theory
18:39:06 <EvanR> originally, making sure you put actual kind signatures, otherwise how else would GHC know True and False are the only possible types, in the best case scenario
18:46:50 <hanna> ah, nope, doesn't work: No instance for (KnownSymbol (Foo s)); even though it kind-checks: Foo :: Bool -> Symbol
18:47:06 <hanna> Seems like even GHC *needs* to know what symbol it's dealing with at compile time
18:47:31 <hanna> Makes sense, I mean the opposite would require my function somehow magically inserting the right code based on the type it's instantiated as
18:48:06 <hanna> which while it works in principle in this example certainly breaks down in cases involving less-closed types
18:49:14 <hanna> Hmm I think it's probably best to just work around the issue by using explicit GADT constructors; basically my problem is that I have a newtype Foo (s :: Bool); but I could turn it into a GADT with two constructors: one for True and one for False
18:49:52 <hanna> Then pattern matching on the constructor will bring the right constraint (and thus instance) into scope
18:50:56 <EvanR> and this is easier than singletons?
18:52:56 <hanna> in this case actually yes, because it involves changing a different part of the code
18:53:04 <hanna> I guess the method is similar to singletons anyway
19:15:28 <codygman> I have a Monad Transformer base don StateT that looks like: type Acct = ST.StateT AcctState IO     Using lens how can I look at the AcctSTate part? I thought I could simply use: zoom _AcctState $ acctStateField %= f but that didn't seem to work
19:16:54 <ReinH> The AcctState part? The whole state is AcctState...
19:17:49 <ReinH> if acctStateField is a lens for AcctState, you should just be able to do acctStateField %= f
19:18:53 <codygman> ReinH: Oh, I thought I needed to use a prism to access AcctState and then "use acctStateField".
19:19:44 <EvanR> is there a database of haskell verbs, including everything used in lens which were carefully chosen to avoid ecosystem collisions
19:19:55 <ReinH> %= is a Setter that works with MonadState
19:19:56 <EvanR> curious to see whats left ;)
19:20:02 <ReinH> :t (%=)
19:20:04 <lambdabot> MonadState s m => ASetter s s a b -> (a -> b) -> m ()
19:20:10 <ReinH> Ok, it's ASetter.
19:20:23 <ReinH> or rather it works with ASetter
19:20:33 <ReinH> which can be a typical lens
19:23:17 <ReinH> For example,
19:23:19 <ReinH> > (1,2) &~ do _1 %= succ
19:23:22 <lambdabot>  (2,2)
19:23:29 <ReinH> (
19:23:48 <ReinH> er, (&~) is just flip evalState, or execState, I can never remember which is which
19:26:11 <codygman> ReinH: That didn't quite work for me, I'm preparing a paste with my example
19:26:25 <codygman> hm lpaste seems down
19:27:50 <codygman> ReinH: Here is my code and my non-working attempt to modify Options inside of my State: http://codepad.org/xtQwYZpr
19:28:54 <ReinH> Ok, did you try doing what I said??
19:29:09 <ReinH> sorry for the double ?, I'm not incredulous I just have a sticky key
19:29:29 <ReinH> you don't need the use or the opts
19:29:51 <ReinH> you should just need currentOptions %= = params "someparam" .~ ["some", "values"]
19:29:59 <ReinH> the lens goes on the left of the %=
19:30:32 <ReinH> er, %= not %= =
19:34:38 <codygman> ReinH: That gave a precedence error. I tried 'currentOptions %= set (params "someparam") ["some", "values"]' and got Expected type: ASetter Wreq.Options Wreq.Options a0 [[Char]]; Actual type: Wreq.Options -> Wreq.Options -> Wreq.Options 
19:34:55 <ReinH> why are you using set?
19:35:03 <codygman> ReinH: Oh, good point
19:35:32 <ReinH> currentOptions %= (params "someparam" .~ ["some", "values"])
19:35:45 <ReinH> %= and .~ probably have the same precedence
19:35:53 <glguy> currentOptions . params "someparam" .= ["some", "values"]
19:36:07 <ReinH> or that
19:36:12 <ReinH> would be better
19:38:43 <codygman> glguy: Didn't work, but I know I should probably be using .= now. Here is the code+error: http://codepad.org/7gn75j1q
19:39:47 <glguy> params :: Lens' Options [(Text, Text)]
19:40:17 <glguy> Do you know about this? http://hackage.haskell.org/package/wreq-0.5.0.1/docs/Network-Wreq-Lens.html#v:params
19:40:40 <glguy> all these lenses are listed with description and the type signature
19:41:15 <codygman> glguy: I do, I'll glance over them again and try to figure out the types though.
19:41:50 <glguy> You'll need to understand the types to be able to use things like param and params and .= etc
19:42:08 <codygman> I understand how to use params to modify a simple Options, I just don't understand how the types should fit together once I introduce the state monad transformer.
19:42:46 <glguy> What's wrong this this part: params "someparam"
19:43:46 <codygman> glguy: Oh! I meant to use param instead of params.
19:44:22 <codygman> glguy: in which case your usage works.
19:44:32 <codygman> for it to work with params
19:44:45 <codygman> I would need to provide a list of text pairs
19:44:50 <glguy> yes
19:45:05 <glguy> That wasn't my usage, I was just fixing the mixing of %= and .~
19:45:08 * hackage regex-pcre-text 0.94.0.1 - Text-based PCRE API for regex-base  https://hackage.haskell.org/package/regex-pcre-text-0.94.0.1 (ChrisDornan)
19:45:17 <codygman> glguy: Oh alright
20:05:58 <EvanR> isnt that cute... echo "foo!" is a shell command error
20:06:14 <EvanR> echo "foo\!" echos foo\!
20:07:20 <c_wraith> just keep inserting backslashes until it works. :)
20:07:38 <guardianx> lol
20:07:40 <EvanR> 4 \ did not work
20:08:03 <ab9rf> hack and slash
20:11:52 <ab9rf> which shell are you abusing?
20:13:10 <Clint> EvanR: echo 'foo!'
20:14:03 <EvanR> worked
20:19:22 <geekosaur> unset histchars
20:19:42 <geekosaur> ...maybe... bash is :( 
20:19:56 <EvanR> didnt work
20:20:52 <exio4> EvanR: ! is a special character, it is about previous commands
20:21:00 <EvanR> right
20:21:11 <Squarism> cant i pattern match an empty set?
20:21:22 <Squarism> in a function signature
20:21:23 <exio4> EvanR: or events, or something, don't really remember, so you have to use '!' :p
20:21:24 <Squarism> ?
20:21:50 <EvanR> no, only an empty list
20:21:57 <EvanR> empty Set is not a constructor
20:22:14 <monochrom> What is an empty set?
20:23:06 <Squarism> they can be constructed atleast
20:23:11 <geekosaur> oh, you need epxlicitly empty
20:23:14 <geekosaur> histchars=''
20:23:21 <monochrom> And what is an empty set doing in a function signature?
20:23:45 <Squarism> the callee was sloopy and created it
20:23:47 * geekosaur nukes history expansion by default... but in zsh
20:24:10 * monochrom quits this monologue.
20:24:18 <Squarism> geekosaur, what is that?
20:24:33 <geekosaur> turning off special handling of ! for EvanR 
20:24:47 <EvanR> worked
20:24:54 <geekosaur> (also of ^ as first character on a line if you've ever run into that)
20:27:08 <Squarism> monochrom, maybe its bad to pass around empty sets. But if they are that bad maybe the type itself shouldnt allow them to be created?
20:28:12 <monochrom> I am sorry I asked.
20:34:34 <HasNoob> Is higher level mathematics a must to become a very good haskell programmer?
20:35:17 <EvanR> or is it just a consequence
20:35:30 <glguy> HasNoob: No
20:35:37 <atondwal[m]> HasNoob: not at all
20:36:33 <EvanR> welcome atondwal[m] how did you know about this question before you joined
20:37:10 <HasNoob> yeah solve the mystery atondwal
20:37:20 <pikajude> probably livefeed of irclogger
20:37:37 <atondwal[m]> Hmm, I think it's strangeness of the matrix/irc transport
20:37:39 <glguy> The matrix bridge shows history when you join
20:38:11 <EvanR> seas of the internet be rough these days
20:39:07 <atondwal[m]> I was already in the channel on matrix when the question was asked
20:39:36 <glguy> Oh and it syncs users lazily on chat
20:39:47 <atondwal[m]> Yeah, probably
20:39:54 <EvanR> spooky
20:40:01 <HasNoob> Awesome
20:40:18 <EvanR> no you dont need to know very advanced math
20:40:33 <EvanR> but like any programming language knowing any math will help that much more
20:40:53 <HasNoob> how much math are we talking about?
20:41:10 <EvanR> today some students were talking about "discrete math"
20:41:13 <atondwal[m]> And it does make it easier to use math, if you so wish
20:41:43 <EvanR> the arithmetic of integers definitely comes up, at least for me
20:42:09 <HasNoob> ok
20:42:10 <EvanR> in haskell, the ability to substitute things for variables in an expression, thats how you predict what it will do
20:42:59 <geekosaur> Squarism, it is possible that an empty list will work in a pattern match if OverloadedLists is enabled
20:43:00 <jle`> HasNoob: like, it'd help to know enough math to know what numbers are between 1 and 10
20:43:02 <EvanR> > let x = 2 in x + x
20:43:05 <lambdabot>  4
20:43:06 <jle`> so you can do things like [1..10]
20:43:15 <jle`> using lists like [1..10] is pretty common in haskell
20:43:44 <jle`> and so it's nice to know that between 1 and 10, you have the numbers 2, 3, 4, 5, 6, 7, 8, and 9
20:43:47 <HasNoob> yes I know that much :)
20:43:54 <jle`> but if you ever forget, you can always just ask ghc, as well
20:43:56 <jle`> > [1..10]
20:43:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:44:26 <jle`> "off by one" errors are also a lot less common in haskell than in other languages, so it can be said that haskell requires even less arithmetic/math than most languages
20:45:08 <jle`> in C and related languages, pointer arithmetic is a daily reality
20:45:15 <jle`> not so much in haskell
20:45:39 <EvanR> haskell has these simple, almost for granted, math ideas. but many languages dont so you have to change gears
20:46:27 <Squarism> geekosaur, it might actually have worked - but the type checking got totally what when i enabled that on this particular file it seems
20:46:29 <EvanR> like x + x, whatever x is, cant cause email to be sent
20:46:43 <EvanR> why would it
20:46:54 <geekosaur> Squarism, that's the bad part of OverloadedLists, yes
20:47:05 <Squarism> i found a way though - ViewPatterns
20:47:18 <geekosaur> yes, that was going to be my next suggestion
20:52:38 * hackage zifter-cabal 0.0.0.2, zifter-stack 0.0.0.4 (Norfair): https://qbin.io/97ane50z
21:03:52 <EvanR> i know there are named pipes to make effectively bounded queues using the filesystem, but is there a way to use a file instead to get an unbounded queue, one writer, one reader
21:05:24 <geekosaur> not very reliably or performantly
21:05:50 * geekosaur suddenly remembers v7 multiplex files, something thankfully never perpetrated on later unixoids
21:07:27 <geekosaur> in theory you could treat a file as a circular buffer. but you'll have to synchronize writer and reader via some other shared resource (e.g. shared memory) and handle wrapping yourself; the filesystem won't.
21:07:48 <EvanR> ah it didnt think of that
21:08:23 <EvanR> no wrapping wont work... because if you decide to wrap, then reading slows down, you run into your own tail like nibbles
21:08:42 <geekosaur> synchronization here means making sure the reader knows where the current write point is and making sure the writer doesn't overwrite what the reader is reading, yeh
21:08:48 <geekosaur> it's not worth the effort generally
21:10:09 <geekosaur> mm, you could also in theory use an AF_UNIX/AF_LOCAL socket and try to set the buffering so it would block with too much stuff queued
21:10:17 <EvanR> i know there are hip wheel reinventions based on things like redis, *-db, even node.js... now im wondering what is the simplest distillation 
21:11:13 <EvanR> blocking with too much stuff can be accomplished using named pipes
21:11:41 <geekosaur> aside from not being able to configure it, yes
21:11:50 <EvanR> however, i cant peek at the contents of a named pipe is one issue, another is blocking on write will potentially miss things im trying to write
21:12:18 <EvanR> from tail -F
21:13:34 <EvanR> man this is all too complicated
21:15:00 <Tertiary> If I have some existential type, A = forall a. B a => C a, is there a way to write a function to pull a out of its container?
21:15:03 <Tertiary> I'm not trying to to have the type escape the container, and will only use the functions available to class B, but I can't see a way to make GHC stop thinking the type escapes its scope
21:15:07 <Tertiary> I just don't want to pattern match it every time
21:15:47 <EvanR> does the result of these operations involve the type a
21:16:30 <EvanR> the B ops
21:17:14 <geekosaur> Tertiary, you might provide some code...
21:17:18 <Tertiary> Yes, mostly as input
21:17:19 <glguy> Tertiary: No, but you can case on it and use the value inside the alternative that matched it
21:17:24 <EvanR> the result
21:17:45 <EvanR> mostly as input, ill take this as a no
21:18:19 <EvanR> then the only way to make wrappers to do these operations without pattern matching is to provide a higher ranked polymorphic function to deal with the result
21:18:32 <glguy> Or you can write: useA :: (forall x. B x => x -> a) -> A -> a; useA f (C x) = f x
21:18:48 <EvanR> like this
21:19:07 <EvanR> well that only works if the result doesnt use `a`
21:19:12 <EvanR> original a
21:25:26 <Tertiary> glguy: So I would have to always accept the function on B I want to use as part of the input? I guess that's better than nothing
21:26:08 <EvanR> not always, if the result of the operations dont involve a
21:26:35 <EvanR> then you can make a wrapper that doesnt take a polymorphic function
21:29:06 <Tertiary> You mean a wrapper around one of the functions on B, right?
21:30:28 <EvanR> one for each function
21:30:44 <EvanR> where possible
21:31:22 <Tertiary> Makes sense. Thanks
22:20:47 <iqubic> Hello.
22:21:25 <iqubic> I need a function that will give me the first Just value of a list, or Nothing if there are no Just values in said list.
22:21:48 <iqubic> findFirstJust :: [Maybe a] -> Maybe a
22:22:16 <MarcelineVQ> > asum [Nothing, Just 3, Nothing]
22:22:18 <lambdabot>  Just 3
22:26:18 <Lokathor> :t asum
22:26:19 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
22:26:23 <Lokathor> nice
22:26:49 <EvanR> i was pretty sure there was a "touch" command somewhere in these file modules
22:27:01 <EvanR> @hoogle touchFile
22:27:02 <lambdabot> System.Posix.Files touchFile :: FilePath -> IO ()
22:27:02 <lambdabot> System.Posix.Files.ByteString touchFile :: RawFilePath -> IO ()
22:27:02 <lambdabot> System.PosixCompat.Files touchFile :: FilePath -> IO ()
22:27:05 <EvanR> ok
22:27:24 <Lokathor> can you install a finalizer action within ExceptT?
22:27:27 <Lokathor> it doesn't... seem so
22:29:13 <EvanR> a finalizer... all ExceptT basically does is what Either monad does
22:29:44 <iqubic> MarcelineVQ: How does asum work?
22:29:56 <Lokathor> right, but i want to have something run in both the Right and Left cases
22:30:11 <Lokathor> https://pastebin.com/H5b37GTK example, glDeleteShader v needs to run once v exists no matter how the computation finishes, and the same for glDeleteShader f once f exists
22:30:24 <iqubic> > asum $ replicate 10 Nothing
22:30:26 <EvanR> ah youre trying to wrap OpenGL without using IO exceptions
22:30:27 <lambdabot>  Nothing
22:30:34 <EvanR> for some reason
22:30:41 <iqubic> asum does exactly what I want it too.
22:30:51 <Lokathor> EvanR, well I could also do that I guess
22:31:20 <Lokathor> the error log comes back as a string, so I just used String
22:31:21 <MarcelineVQ> Lokathor: fmap either ?
22:32:53 <Lokathor> I'm not seeing where I would put that
22:33:04 <iqubic> How does asum work? What exactly is it doing??
22:33:30 <iqubic> > asum $ replicate 10 Left "Failed"
22:33:33 <lambdabot>  error:
22:33:33 <lambdabot>      • Couldn't match expected type ‘[Char] -> [f a]’
22:33:33 <lambdabot>                    with actual type ‘[a0 -> Either a0 b0]’
22:33:42 <iqubic> > asum $ replicate 10 $ Left "Failed"
22:33:45 <lambdabot>  Left ""
22:34:06 <iqubic> Where did my error message go?
22:34:08 <EvanR> Lokathor: if this was some other language, are you really going to install a finalizer from inside of some catch-wrapped thing
22:34:23 <EvanR> i runs-no-matter-what clause for the catch
22:34:33 <EvanR> from *inside* the action somewhere
22:34:48 <EvanR> what on earth
22:35:09 <MarcelineVQ> Lokathor: well I was thinking something like  :t \f1 f2 -> fmap (either f1 f2) . runExceptT
22:35:10 <EvanR> to put a runs no matter what clause, you put that in the same place as the catch
22:35:18 <Lokathor> EvanR, i just want it to discard the shader value no matter how it returns, so that spare shader values aren't building up
22:35:24 <EvanR> runExceptT ... >> that
22:35:40 <Rotaerk> > asum $ replicate 3 $ Right "Blah"
22:35:42 <Lokathor> once you compile the program, you can immediately delete the shader, you don't need to also keep the shaders arond while you have the program
22:35:43 <lambdabot>  error:
22:35:43 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M805208891744...
22:35:43 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
22:36:04 <EvanR> are you trying to attach finalizers to the shader object
22:36:16 <Lokathor> perhaps "finalizer" is the wrong term here
22:37:14 <Lokathor> I just want it to call glDeleteShader v before returning if v has been bound. Now I know you can do that with a huge manual case analysis
22:37:22 <Lokathor> but it seems like there should be a slicker way
22:37:27 <EvanR> ... attach a finalizer?
22:37:54 <EvanR> or use a withShaderObject bracket?
22:38:36 <Lokathor> oh dag i forgot that foreignptr has a literal thing called "finalizer", which is probably what i made you think of
22:38:37 <Lokathor> sorry
22:38:50 <EvanR> not just ForeignPtr
22:38:58 <EvanR> you can attach a finalizer to any "object"
22:38:59 <Lokathor> well the shader values are just raw Int32 values, they're not behind pointers
22:39:10 <EvanR> you can still do it
22:39:18 <Lokathor> what module in what package does that?
22:39:31 <EvanR> by putting that Int32 value in a thing that is suceptible to finalization
22:39:49 <EvanR> it depends on how you do it
22:39:51 <MarcelineVQ> iqubic: best to look at the source for asum, and the Maybe instance of Alternative
22:40:13 <EvanR> but if you have a well defined control point to execute delete, then a bracket is probably better
22:40:56 <EvanR> but if you do this uniformly for all your opengl object numbers, it could save headache across the board
22:41:03 <EvanR> finalizers i mean
22:41:43 <iqubic> How are we doing OpenGL programming in Haskell?
22:42:07 <jle`> Traversing/wander is a rather ad-hoc typeclass
22:42:27 <jle`> seems like just a way to shoehorn traversals into profunctor optics
22:42:29 <jle`> oh well
22:42:41 <EvanR> iqubic: very carefully
22:43:27 <Lokathor> :t either
22:43:29 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
22:45:03 <Lokathor> EvanR, https://pastebin.com/0FeXkXps like this
22:45:34 <Lokathor> but like, i just assumed that there was a less ugly way to do that
22:47:25 <EvanR> yeah youre not really using Monad instance of Either
22:47:35 <Lokathor> i know it's such a shame
22:47:57 <EvanR> let me check how i did it
22:48:08 <Lokathor> i'd love to do the plain exit early thing, but that leaks shader ids
22:48:46 <EvanR> https://hackage.haskell.org/package/lowgl-0.4.0.1/docs/src/Graphics-GL-Low-Shader.html#newProgram
22:49:20 <EvanR> this uses exceptions to exit, which are then caught in newProgramSafe
22:49:25 <EvanR> which returns an Either
22:49:31 <EvanR> but only when the error comes from the shader process
22:49:56 <Lokathor> looks like... you never call glDeleteShader if the error is thrown though?
22:50:42 <EvanR> youre right, its totally broken. and i see exactly where a "withShader" bracket would go
22:51:15 <Lokathor> yeah exactly
22:51:17 <EvanR> the bracket pattern, you take a lambda that uses the allocated thing, and when it finishes, exception or other wise, cleans up
22:51:23 <EvanR> do that ;)
22:51:46 <Lokathor> I had the same problem this whole time, until I went to write a program compiler in rust
22:51:53 <Lokathor> and then i was like "oh... oh no..."
22:51:56 <EvanR> alloca is already doing that once, might as well do like romans
23:04:20 <Lokathor> ugh
23:04:36 <Lokathor> i don't think it ends up looking any better with bracket compared to plain case matching
23:07:53 <EvanR> it probably does
23:08:07 <Lokathor> my brain cannot collapse the branches cleanly right now
23:08:23 <Lokathor> so the (a -> IO b) step is just as long as before
23:08:49 <EvanR> you begin after = with a bracket to load the shader
23:09:04 <EvanR> the next line is in the lambda (and i would use 2 spaces not 4)
23:09:25 <EvanR> you would not have the first Left e case because you use Either properly
23:09:27 <Lokathor> i've used bracket before and all, but right now my brain is just not capabale of this type jiggery
23:09:32 <EvanR> then you open another one to get the other shader
23:10:05 <EvanR> then you link program and return  ShaderProgram p
23:10:16 <EvanR> deleting and error handling are handled by the bracket
23:10:30 <EvanR> seems to collapse into 3 lines of code
23:10:51 <Lokathor> you are a haskell wizard
23:11:07 <EvanR> no, i dont even know profunctor optics
23:12:39 <Lokathor> what's the oneliner for, Either String GLuint -> IO () that does the delete properly
23:13:11 <Lokathor> can you just fmap glDeleteShader into the either? that doesn't sound like it works
23:13:17 <cocreature> const (pure ()) (sry I’ll show myself out)
23:13:32 <EvanR> withShader :: ShType -> Src -> (GLuint -> Either String a) -> Either String a
23:13:43 <EvanR> as long as you get the types right... everything else follows!
23:13:45 <Lokathor> cocreature, failure, "that does the delete properly" was a requirement
23:14:07 <cocreature> Lokathor: it deletes everything it creates properly!
23:14:17 <EvanR> i dont know if fmap glDelete shader is a proper implementation of bracket, but seems unlikely
23:14:35 <Lokathor> it gives you Either String (IO ()) anyway
23:14:38 <Lokathor> not good
23:14:49 <EvanR> sorry i didnt include io
23:15:04 <EvanR> withShader :: ShType -> Src -> (GLuint -> IO (Either String a)) -> IO (Either String a)
23:15:29 <Lokathor> right, i know the type signature, but until i see source on that i literally cannot put it in my prograwm because my brain is not seeing it
23:15:44 <EvanR> well, ill type it into github because lpaste is down
23:16:06 <Lokathor> EvanR, you're so smart you forget how not smart some of us are some of the time <3
23:16:29 <EvanR> or maybe im just not paid enough to do it for you!
23:16:42 <EvanR> but doing it anyway, so hold on
23:19:48 <EvanR> mmkay
23:19:50 <EvanR> https://gist.github.com/evanrinehart/688cdbb2dc8f4f86281d34de5d899e37
23:21:48 <cocreature> note that this is not safe in the presence of async exceptions
23:22:13 <Lokathor> cocreature, i don't think that most of opengl is safe in the presence of async execptions
23:22:21 <EvanR> finally isnt ?
23:23:02 <Lokathor> EvanR, *reads* but they didn't use bracket like they said! :P
23:23:07 <cocreature> EvanR: finally is but you could get an exception between "loadShader" and "finally"
23:23:25 <cocreature> Lokathor: finally is a special case of bracket :)
23:23:37 <cocreature> :t bracket
23:23:38 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
23:23:40 <cocreature> :t finally
23:23:42 <lambdabot> IO a -> IO b -> IO a
23:24:01 <Lokathor> yes, and all, but i was trying to use literal bracket, not a form of bracket, and having that trouble :P
23:24:06 <EvanR> Lokathor: i was saying you make a bracket-like function... but
23:24:08 <cocreature> :t \c f -> bracket (pure ()) (const c) (const f)
23:24:10 <lambdabot> IO b -> IO c -> IO c
23:24:20 <EvanR> i apparently did it wrong
23:24:24 <cocreature> eh I flipped argument but you get the idea
23:25:23 <EvanR> how do you have to do it, mask, unmask when doing loadShader, then unmask when you do action?
23:26:10 <cocreature> usually you only unmask when running the action
23:26:34 <\u> Which HList library is preferred for GHC 8?
23:26:35 <cocreature> the source of "bracket" itself is a good example of how to do this properly https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Control.Exception.Base.html#bracket
23:27:00 <Lokathor> EvanR, i thought you were going to do it like, bracket (loadShader ty src) (releaseThing) (innerThing)
23:27:22 <Lokathor> i was struggling to make releaseThing be short and sweet instead of a big long thing
23:27:33 <EvanR> no
23:27:43 <EvanR> i meant like how alloca works
23:28:30 <Lokathor> aw dag
23:28:41 <Lokathor> now i gotta go update like, a whole pile of tutorial files
23:29:09 <EvanR> usually people wait until a few minutes after they finish some task before making a tutorial about it, not months before they finish the project ;)
23:29:26 <Lokathor> i wrote the sections as i completed each one
23:29:47 <EvanR> then what are we doing modifying completed sections
23:30:10 <Lokathor> because lesson 1 has the faulty code in it, and lessons 2 through 6 just copy that part forward
23:30:15 <Lokathor> 2 through 7
23:30:26 <ab9rf> oops
23:30:29 <Lokathor> yep
23:30:39 <ab9rf> forward error propagation
23:30:48 <EvanR> the tutorial paradox
23:31:16 <ab9rf> i love how intellj taunts me with how long it's been since i last committed to VCS
23:32:46 <EvanR> Lokathor: i updated my code to protect against async exceptions, in addition to your normal exceptions https://gist.github.com/evanrinehart/688cdbb2dc8f4f86281d34de5d899e37
23:33:27 <EvanR> but probably using bracket somehow would avoid having to do this
23:33:54 <Lokathor> i'll give that another go in a moment, once i've fixed up my files
23:34:00 <EvanR> this time, referring to Control.Exception.bracket
23:36:39 <cocreature> hm I wonder if masking twice does anything weird
23:37:56 <glguy> If exceptions are already masked , then it doesn't do anything
23:38:00 <glguy> and restore doesn't restore them
23:38:15 <cocreature> ok so it behaves as you would expect
23:38:30 <EvanR> heh... i read the paper on this, and still dont know what to expect
23:39:50 <cocreature> EvanR: have you read the section in simon marlow’s book on this? that made it click for me
23:40:05 <glguy> I added a local /dumpheap command to my IRC client today. It used the ghc-heap-view package. You could dump a pretty version of the program state with thunks preserved. I was curious to see what things looked like while running
23:40:16 <EvanR> no
23:40:23 <ab9rf> glguy: that sounds interesting
23:40:34 <ab9rf> glguy: i might have to actually change irc client for the first time in about 10 years
23:40:52 <ab9rf> it was hard to give up IRCII
23:40:52 <cocreature> EvanR: http://chimera.labs.oreilly.com/books/1230000000929/ch09.html#sec_mask
23:41:05 <MarcelineVQ> the fun stuff is when you need uninterruptibleMask to make things work the way you want
23:42:35 <cocreature> MarcelineVQ: luckily I’ve never been in that situation or perhaps not so luckily I have not realized that I’ve been in it :)
23:43:18 <MarcelineVQ> I ran into it during file operations when a lib I was using was pretty sure it should do errors one way and I was pretty sure my idea was better, in the end I'm not sure who was right but at least I had the option
23:43:53 <MarcelineVQ> I needed it for file cleanup specifically
23:44:16 <ab9rf> i really dislike people who typeset purple text against a dark background
23:44:35 <ab9rf> contrast is a good thing, people, do not squander it lightly
23:44:39 <glguy> ab9rf: Well you don't have to commit to switching just to try it out. Let me know if you ever have any questions if you do some day.
23:44:48 <ab9rf> oh, and by the way, GET OFF MY LAWN
23:46:38 * cocreature starts running around ab9rf’s lawn
23:46:58 <ab9rf> i can remember when people used to ask me how i could read all that small text on my screen
23:47:05 <ab9rf> and now i can't read all the small text on my screen anymore
23:49:58 <EvanR> cocreature: it is just as i remember, mind bendingly subtle. how a solution with 4 levels of gotchas could be a solution ...
23:50:29 <EvanR> its like the universe ignored the 0 1 infinity rule
23:50:38 <cocreature> EvanR: hm I find it surprisingly simple but that’s probably just stockholm syndrome
23:51:37 <cocreature> and usually you can just use "bracket" and avoid having to think about this
23:52:08 <EvanR> 1. mask blocks async exceptions. 2. unless the thread does an operation which may block indefinitely. 3. unless that operation wouldnt actually block. 4. also you can unmask to allow exceptions within a region. 5. unless someone is already masking you from outside. 6. uninterruptible mask ;)
23:52:35 <EvanR> not sure if thats everything
23:53:01 <ab9rf> i got everyting of that except the last bit
23:53:07 <EvanR> also, exceptions thrown to your thread by yourself ignores all of the above
23:53:08 <ab9rf> don't understand uninterruptible mask yet
23:53:35 <EvanR> we almost need UML to get this straight
23:53:48 <ab9rf> the rest made perfect sense though
23:54:39 <EvanR> any rule followed by unless is tricky imo
23:54:40 <ab9rf> you can tell by the corpses of all the dead philosphers in my lab that i've spent too much time on concurrency issues, although admittedly not recently
23:54:59 <EvanR> i prefer a positive rule rather than a sequence of negations
23:55:14 <ab9rf> mmm
23:55:35 <ab9rf> i went to law school, i'm happy with nested inverting exceptions :)
23:55:50 <EvanR> i bet you are
23:56:21 <EvanR> think of it like strict vs lazy
23:56:35 <EvanR> if you see the first step in the above sequence only, youre wrong
23:56:47 <Lokathor> https://gist.github.com/Lokathor/819162f7f8213b2b5e2385a5cc765adb EvanR so here we go, one problem: you're stuck at IO not MonadIO
23:56:54 <EvanR> youre only right if you go all the way to the last ultimate rule 
23:56:59 <Lokathor> unless you use the crazy lifted bracket thing from whatever extension package that i'm sure exists
23:57:12 <EvanR> omg
23:57:23 <cocreature> monad-control
23:57:31 <glguy> IO
23:57:40 <EvanR> IOMG
23:58:14 <cocreature> I’m disappointed that hoogle doesn’t turn up anything for iomg
23:58:16 <EvanR> Lokathor: put liftIO around the whole thing
23:58:36 <Lokathor> yes but you can't make the actions that you pass in MonadIO that way, that's the tricky bit
23:58:36 <EvanR> forgot about crazy monads happening around the time you are compiling a shader
23:58:44 <EvanR> forget*
23:58:52 <Lokathor> hey man i love me my monads!
23:58:58 <EvanR> fuckem
23:59:03 <Lokathor> a guy asked me about how much I use debugging in my normal workflow today
23:59:10 <Lokathor> i was like, "my language... doesn't support that..."
23:59:22 <ab9rf> the project i've been working on got a lot simpler through the creative use of a monad
23:59:28 <ab9rf> well, creative for me.
23:59:35 <ab9rf> it's probably a trivial use for most people :)
23:59:36 <cocreature> Lokathor: you should have said “my language doesn’t support making mistakes” :P
23:59:50 <Lokathor> the project i'm working on got a lot simpler when i stuffed it all behind an MVar
