00:10:20 <paolino> hi, I have this error: http://lpaste.net/357174
00:12:47 <paolino> in the specific the 2 Text are coming from Data.Aeson and Data.Time as dependency
00:15:25 <Lokathor> paolino, looks like you dependency graph is messed up
00:16:14 <paolino> Lokathor, any hint on how to proceed ?
00:16:30 <Lokathor> paolino, how are you currently building the project/
00:16:31 <Lokathor> ?
00:17:45 <paolino> loading at ghci
00:17:49 <Lokathor> ah ha
00:18:06 <Lokathor> i'd consider switching to cabal or stack, and having them start ghci
00:18:14 <paolino> ok
00:18:17 <Lokathor> they'll ensure a consistent set of versions
00:20:35 <paolino> probably it's a nix issue
01:03:42 <cocreature> you need to somehow get nix to build aeson and time against the same version of text
01:03:54 <cocreature> but I’m not a nix user so I sadly can’t tell you how to do that
01:10:05 <mbrock> paolino: are your dependencies all installed via Nix?
01:19:04 * hackagebot doctest 0.12.0 – Test interactive Haskell examples – https://hackage.haskell.org/package/doctest
01:20:01 <paolino> mbrock: I solved it, I was using cabal install with reflex-platform which create the issue, thanks
01:33:08 <phz_> hey, is there a Rust-like include_bytes! in Haskell?
01:33:12 <phz_> with QuasiQuotes, I guess?
01:33:15 <phz_> I’m pretty sure there is
01:35:05 <merijn> phz_: Yeah, but I don't remember where
01:35:23 <merijn> @hackage include-file
01:35:23 <lambdabot> http://hackage.haskell.org/package/include-file
01:35:25 <merijn> that?
01:35:44 <phz_> seems like
01:36:03 <merijn> Or you could use ld to generate an object file and use the FFI for finding it's symbols
01:39:36 <Squarism> I have an HVect of some type. Can i somehow get a list of type names or constructors from it? 
01:39:59 <merijn> Squarism: Well, you'll probably have to clarify what a HVect is first?
01:40:30 <Squarism> https://hackage.haskell.org/package/hvect-0.4.0.0/docs/Data-HVect.html#t:Rep
01:41:18 <phz_> anyone has ever used turtle or shelly?
01:41:31 <merijn> Squarism: What are you trying to do with it?
01:41:35 <phz_> I especially look for a library that would have some kind of operators to unix pipe programs
01:41:56 <halogenandtoast> Does 8.2.1 have OverloadedRecordFields turned on by default now?
01:42:07 <Squarism> ive gathered its a vector like structure that allows mixing types. So its type is the concatenation of all types in it.
01:44:26 <Squarism> merijn, the HVect's describe method signatures. I want to use them to create client api's in a foreign langauge. So i want to write signatures by iterating over the types in these HVects
01:44:43 <halogenandtoast> I can't seem to be able to enable it and if I try to enable the extension I see `Unsupported extension: OverloadedRecordFields`
01:45:20 <merijn> Squarism: Right, so you have functions with a specific type and want them to accept HVect's that happen to have the right types inside?
01:45:33 <peddie> halogenandtoast: http://haskell.1045720.n5.nabble.com/OverloadedRecordFields-in-GHC-8-2-1-rc2-td5857972.html
01:46:15 <halogenandtoast> peddie: thanks!
01:46:17 <fr33domlover> Hello! In my library I have a function that takes a unique build ID passed from the application, which in turn should generate it uniquely when it builds (e.g. gen random integer using TH). Is there a way I can generate it myself in the libary without asking the library user to give me one?
01:46:38 <merijn> fr33domlover: How unique are we talking?
01:47:09 <fr33domlover> merijn, say like a build timestamp
01:47:36 <fr33domlover> it can be e.g. UUID generated from current time etc.
01:47:40 <merijn> fr33domlover: So your library should get that as input from users of your library?
01:48:32 <fr33domlover> merijn, or generate it by itself,but if my library uses TH for that, then the ID only gets updated when the *library* is rebuilt and not when the application is
01:48:34 <Cale> 128 bits of entropy should be unique enough for anyone
01:48:53 <Cale> :)
01:48:53 <Squarism> merijn, actually not really. I do use them like that already. But i want to use these HVects to "autogenerate code" like print "myFkn (arg1:A1,arg2:A2,...,argN:AN)"
01:50:39 <Cale> Squarism: I would probably start by making a new type class, and starting with instances for '[] and for (t ': ts)
01:51:05 <Cale> Squarism: that do whatever the thing is that you want to do with the HVect's type
01:51:30 <Squarism> ah ok
01:52:02 <Cale> You really have a completely separate operation for every list of types
02:22:34 * mbrock makes a typeclass to parameterize the basic word type of his stack machine and accidentally makes the program twice as slow...
02:22:46 * mbrock rebuilds a lot of dependencies with profiling enabled...
02:31:23 <cocreature> mbrock: INLINABLE all the things and hope ghc specializes them for you :)
02:31:33 <gallais> Hi, we're getting a weird cabal "internal error when reading package index" out of the blue in our builds. Only happens with ghc 7.8.4 (everything works fine with 7.10.3, 8.0.2, etc.). Anyone have any clue what the problem may be? http://lpaste.net/357187
02:31:46 <mbrock> cocreature: ah, I just got tired of waiting for profiling build and started adding SPECIALIZE...
02:31:57 <mbrock> cocreature: I've never used any of these optimization pragmas
02:45:30 <merijn> mbrock: Do you have a small known number of values you expect to work fast?
02:47:01 <merijn> mbrock: Pro-tip, set "library-profiling: True" in ~/.cabal/config to always build profiling versions when compiling libraries. That makes initial builds take slightly longer, but it means you never have to take a significant time to enable profiling (since you'll already have profiling versions)
02:51:16 <mbrock> merijn: roughly, I now have "class Machine t where { data Word t; someOpX :: Word t -> Word t; ...etc... }" and then an "instance Machine Concrete where { newtype Word t = C Word32; ...etc... }"
02:51:39 <merijn> mbrock: Yeah, I was wondering for how many different words you wanted it to work :)
02:52:23 <mbrock> not many, Byte and Word and a couple of other types that should be less important
02:52:39 <mbrock> and yeah I should be in the habit of building profiling libraries :)
02:53:04 <merijn> mbrock: Yeah, then just enumerating with specialise sounds like the simplest start :)
02:55:51 <phz_> hey
02:55:58 <phz_> what is _the_ book for a newcomer to Haskell?
02:56:06 <phz_> I linked LYAH but I now it’s starting to get old
02:56:14 <phz_> (though it’s a definitev good first read for someone coming from C++)
02:56:26 <merijn> phz_: Haskell Book seems to be the thing now
02:56:42 <mbrock> I just tried with specialize on the "inner loop", my arithmetic helpers, etc, and got a very modest speedup. It would be really sweet if I could get it almost as fast as the unabstract version. But I'll wait to try profiling instead of guessing, hehe
02:57:19 <phz_> merijn: is it free?
02:57:20 <merijn> I'm not sure I quite agree with some of the ordering of chapters for a "from first principles" book, but it's ok for existing programmers, I think
02:57:23 <merijn> phz_: No
02:57:30 <phz_> merijn: damn then
02:57:53 <phz_> oh the one from bitemyapp and agrumatonic?
02:57:58 <phz_> argumatonic
02:57:59 <merijn> phz_: Yeah
02:58:45 <phz_> any other link?
02:58:51 <phz_> what about RWH?
02:59:05 <merijn> Real World Haskell is rather dated and was never that good to begin with
02:59:12 <phz_> ok
02:59:14 <phz_> not that then
02:59:16 <merijn> It never really explains the language properly, glossing over lots of details
02:59:23 <phz_> I guess I should point to Gabriel Gonzales articles as well
02:59:27 <merijn> Honestly, I'm not aware of any free book I'd consider good
02:59:32 <phz_> like you could have invented monads and stuff
02:59:42 <phz_> merijn: it’s for trainee or newcomers at my work
02:59:49 <phz_> when we have new people aboard
02:59:58 <phz_> I’m just adding some references to our README
03:01:05 <renzhi> LYAH is pretty good, and as phz_ said, it's getting old. Sometimes it gets a bit annoying, coz it keeps repeating certain things
03:05:06 <merijn> Honestly, LYAH isn't really good. It deserves a lot of historical credit for being the first "accessible" Haskell thing (hell, I learned with it), but it's not good. It skips lots of important details, is repetitive in other things and just generally dated
03:09:41 <ventonegro> phz_: If it's for the workplace, can't you afford a couple copies of "Haskell From First Principles"? Although I don't know sharing would work with ebooks
03:13:52 <phz_> ventonegro: good question
03:36:59 <fizbin> Is it possible to define something locally to an instance definition? I have a handful of constants that I'd like to re-use between the "peek" and "poke" methods in my Storable instance, and I'd like if possible to only write them once.
03:41:05 <osa1> fizbin: no, closest thing is a top-level definition
03:43:26 <fizbin> Okay, in general are there any ideas on how to reduce duplication in http://lpaste.net/357190 without a top-level definition?
03:46:24 <lyxia> Is reading misaligned words allowed?
03:46:38 <merijn> fizbin: Well, not related to your question, but why pass "sizeof undefined" rather than just the argument from the record?
03:46:57 <osa1> fizbin: hsc2hs might help https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/utils.html#writing-haskell-interfaces-to-c-code-hsc2hs
03:47:03 <osa1> with the offset calculations
03:49:16 <fizbin> merijn: True, I could. I'd changed it to use "undefined" while I was trying to find a way to separate that out (so I wouldn't have an instance locally)
03:49:48 <fizbin> lyxia: Yes, this particular record is stored in C with #pragma "packed"
03:50:20 <fizbin> Also, in general on modern intel chips unaligned reads aren't even slow any more.
03:51:52 <fizbin> I suppose it wouldn't be so bad to have one top-level definition that was a tuple of the offsets.
03:57:18 <ertes-w> ehlo
03:59:40 <osa1> I remember doing unaligned reads back when I was working on my own compiler and IIRC it worked fine. unaligned SP was causing segfaults though.
04:00:21 <merijn> osa1: It works fine IFF you run on x86 and it's integer types
04:03:39 <e> unaligned access works on some platforms sometimes. it's often a bit slow
04:04:08 <merijn> e: It works on all Intel CPUs (well, the ones still in use) with zero slowdown
04:04:19 <merijn> Presumably all AMD too
04:04:24 <merijn> Won't work on ARM, though
04:04:32 <e> you can enable it on some ARMs
04:05:47 <e> i don't know a lot about x86 physical addressing; won't there be unaligned addresses that require two loads?
04:06:24 <fizbin> http://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/
04:06:49 <merijn> e: I tested it (with some huge multi-GB arrays) after noticing the code I worked on was doing unaligned accesses. Found zero slowdown there
04:07:23 <e> fair enough
04:07:43 <merijn> e: Worst I can think of is SIMD not firing, but that only applies if you code does SIMD
04:08:27 <e> or superscalar-ing not happening
04:08:31 <lyxia> fizbin: interesting, thanks
04:08:45 <e> i don't know many ISA details about things that aren't ARM though
04:09:17 <merijn> But you should just not do unaligned accesses anyway
04:30:49 <mikeplus32> for very devious purposes i want to seq all available typeclass dictionaries for a specific type -- is there any way to instantiate a specific typeclasses instances (any and all, not preserving the type) to attempt this?
04:31:28 <mikeplus32> like, evilMagic :: Proxy c -> [Dict c]
04:32:28 <mikeplus32> oh wait, data Dict1 c where Dict1 :: c x => Proxy x -> Proxy c -> Dict1 c; evilMagic :: Proxy c -> [Dict1 c]
04:33:30 <Squarism> what makes it possible to use functions as patterns in functions ive seen this: foo (a :&: b) = ... , where foo is a instance definition and (:&:) was defined on a data type 
04:35:35 <tsahyt> does anyone know which latex package is being used in papers to pretty print "haskell" code?
04:38:09 <tsahyt> for things like stating typeclass laws etc
04:39:00 <hjt> tsahyt : i don't know but i would also like to know
04:39:56 <Squarism>  tsahyt : pandoc?
04:41:20 <tsahyt> umm no that doesn't seem to do what I want, that just does syntax highlighting on the code
04:41:25 <tsahyt> let me see if I can find an example
04:42:33 <tsahyt> http://www.staff.city.ac.uk/~ross/papers/notation.pdf
04:42:43 <tsahyt> like in the code fragments here
04:44:16 <bvad> Is the `foo^.bar.baz` preferable `foo ^. bar . baz`? It seems odd to me that infix operators are usually used surrounded by spaces except for the ones from lens
04:44:25 <merijn> tsahyt: lhs2TeX ?
04:44:54 <tsahyt> is that the only way? I'd prefer to write tex directly using a suitable package
04:45:02 <toddWannaCode> Hey umm noob getting started with haskell, do I need to install anything else beside stack?
04:45:04 <hjt> minted + fancyvrb
04:45:08 <merijn> tsahyt: With lhs2TeX you do write tex directly
04:45:15 <bvad> toddWannaCode: to do what? :)
04:45:26 <merijn> tsahyt: lhs2tex just preprocesses the non-TeX parts of your lhs file
04:45:32 <tsahyt> merijn: kinda, I write lhs files
04:45:43 <tsahyt> I'll look into it
04:45:43 <toddWannaCode> Well just to learn atm
04:45:46 <hjt> tsahyt even just fancyvrb actually
04:45:55 <merijn> tsahyt: lhs places no restriction on the non-code content of a files
04:46:21 <bvad> toddWannaCode: Then no, stack will install the rest for you 
04:46:27 <merijn> tsahyt: And literate haskell understands \begin{code} and \end{code} to indicate code blocks
04:46:38 <toddWannaCode> Ah okay. Thanks. :D
04:46:47 <merijn> tsahyt: So lhs2TeX just takes a valid TeX file, and typesets all the code blocks it finds the pretty way
04:47:01 <tsahyt> merijn: okay, I'll check it out
04:47:30 <bvad> toddWannaCode: #haskell-beginners might be of interest to you, a lot of questions asked and answered there :) 
04:47:56 <merijn> tsahyt: https://www.andres-loeh.de/lhs2tex/
04:49:23 <toddWannaCode> Oh I didn't know about that channel. Thanks. 
04:54:57 <Cale> toddWannaCode: It's basically a quieter version of this channel though. Beginners are very welcome here.
04:55:26 <Cale> (I still can't stand how that channel is named)
04:56:59 * hackagebot tzdata 0.1.20170320.0 – Time zone database (as files and as a module) – https://hackage.haskell.org/package/tzdata
04:57:00 * hackagebot haxl 0.5.1.0 – A Haskell library for efficient, concurrent, and concise data access. – https://hackage.haskell.org/package/haxl
05:10:41 <fizbin> @djinn Maybe (t1, t) -> Maybe (t1, [t])
05:10:41 <lambdabot> Error: Undefined type []
05:10:59 <fizbin> Anyone know why @djinn doesn't know about [] ?
05:11:29 <rain1> i think its hard to do recursive types
05:12:09 <rain1> so they didnt include them
05:12:24 <Cale> Yeah, the decidable logic which it uses is decidable because there's no recursion
05:12:35 <Cale> (in part, at least)
05:17:47 <ertes-w> well, in principle djinn could handle recursive types, it just couldn't handle induction
05:18:08 <ertes-w> so it would have to have a recursion limit
05:18:45 <ertes-w> in fact it could even handle induction in certain cases, but it's not implemented
05:34:30 * hackagebot aeson-flowtyped 0.7.1 – Create Flow type definitions from Haskell data types. – https://hackage.haskell.org/package/aeson-flowtyped
05:34:59 <tabaqui> how can I export all symbols from my module expect for some?
05:35:24 <tabaqui> like module Foo (hiding foo) where
05:41:34 <lyxia> You can put the implementation of module X in an X.Internal module, in module X you import X.Internal hiding (foo), and reexport X.Internal.
05:44:26 <tabaqui> hmm, not much elegant
05:45:32 <tabaqui> I hope devs received this feature request in the past
05:46:41 * hackagebot autoexporter 1.1.2 – Automatically re-export modules. – https://hackage.haskell.org/package/autoexporter
05:46:41 * hackagebot tz 0.1.3.0 – Efficient time zone handling – https://hackage.haskell.org/package/tz
05:50:57 <fr33domlover> Hello! is there a way / is it good practice to make this splice a TExp and if yes, how? runIO randomIO >>= litE . integerL
05:51:12 <fr33domlover> as is, it's Q Exp
05:51:25 <fr33domlover> Whose type would be: Num a => a
05:52:45 * hackagebot camfort 0.903 – CamFort - Cambridge Fortran infrastructure – https://hackage.haskell.org/package/camfort
05:53:02 <merijn> fr33domlover: You're splicing it using $(), yeah?
05:55:05 <fr33domlover> merijn, yes
05:55:36 <merijn> fr33domlover: You need $$() for typed template haskell splices
05:55:58 <fr33domlover> merijn, (1) I'm not sure what the TEXP benefits are, specifically for me now (2) idk how to safely make a TExp without [|| ||]
05:56:07 <merijn> fr33domlover: Some examples (ab)using Typed TH here: https://github.com/merijn/validated-literals
05:56:26 <gallais> In case anyone is in the same situation: I think I've found the problem with the cabal internal error: https://github.com/haskell/cabal/issues/4624
05:56:37 <merijn> fr33domlover: Regular TH can end up producing code with type errors (which will then fail to compile)
05:56:58 <merijn> fr33domlover: Typed TH won't end up producing code with type errors and you can abuse it to sneak type specific information into the generated code
05:57:45 <fr33domlover> merijn, I don't want to abuse though :P
05:58:12 <fr33domlover> Just give it the correct typed exp type:
05:58:33 <fr33domlover> Num a -> TExp a
05:58:38 <fr33domlover> (I think)
05:58:48 <fr33domlover> oops I mean this: Num a -> TExpQ a
06:01:42 <merijn> "Num a => TExpQ a", surely?
06:03:14 <fr33domlover> merijn, yes oops
06:03:31 <fr33domlover> merijn, running on little sleep sorry ^_^
06:05:08 <fr33domlover> My use case is trivial, merijn, but should I prefer TExp now as a general good practice?
06:05:23 <fr33domlover> If yes, how to I safely make the TExp
06:05:46 <fr33domlover> There is to litTE for example, only litE :P
06:08:59 * hackagebot rattletrap 2.5.2 – Parse and generate Rocket League replays. – https://hackage.haskell.org/package/rattletrap
06:09:17 <glguy> you make TExp with the [||   ||] syntax
06:09:19 <kuribas> can ghc compîle in parallel, like make -j4?
06:09:45 <kuribas> or cabal?
06:09:57 <glguy> no, it's not necessary to use TExp
06:10:36 <fr33domlover> glguy, yeah but how do I make my splice a TExpQ
06:10:52 <fr33domlover>  runIO randomIO >>= litE . integerL
06:12:47 <glguy> fr33domlover: I don't think you can do that
06:14:38 <gallais> kuribas: cf. "jobs" in .cabal/config
06:15:08 <srhb> kuribas: Or just -j4
06:15:26 <srhb> (meaning four modules in parallel)
06:15:28 <kuribas> right
06:15:59 <kuribas> I am trying to make a mingw cross-compiler, but I am getting this: http://paste.lisp.org/display/351648
06:19:10 * hackagebot postgresql-simple-queue 0.5.0.1 – A PostgreSQL backed queue – https://hackage.haskell.org/package/postgresql-simple-queue
06:41:52 <kuribas> guess building a crosscompiler isn't possible...
06:45:59 <mlehmk> kuribas, are you using mingw or mingw64?
06:46:05 <kuribas> mingw64
06:46:09 <[exa]> kuribas: did you try forcing -lkernel32 by hand?
06:46:26 <kuribas> yes
06:46:45 <mlehmk> the errors hint that the libraries you use are unicode, while you try to build the project ansi
06:48:21 <max3> does ghc-pkg ship with ghc?
06:48:48 <kuribas> hm, I have the mingw binutils twice, perhaps that's part of the problem...
06:49:00 <kuribas> (one from mint, one from a source install)
06:49:02 <mlehmk> also, discarded .text.... mmmh
06:49:55 <mlehmk> I wonder why that section would be discarded
06:50:14 <kuribas> mlehmk: perhaps because I have conflicing versions now?
06:52:04 <kuribas> mlehmk: I installed mxe
06:53:51 <mlehmk> ohh, I just found out, it might also be caused by a missing "#include <windows.h>"
06:54:27 <mlehmk> but that doesn't make any sense
06:55:48 <kuribas> mlehmk: it's probably because I had two versions of mingw64 installed
06:56:03 <ongy> Anfang des Jahres wurde die zuständige Behördenleiterin Maria Ågren ohne Angabe von Gründen entlassen und mit einer Strafe von 70.000 schwedischen Kronen (etwa 7.300 Euro) belegt. Die Oppositionsparteien fordern im Parlament nun Aufklärung.
06:56:09 <kuribas> configure doesn't seem to accept --with-ld=i686-w64-mingw32.static-ld 
06:56:10 <ongy> argh, sorry, accidental paste -.-
06:58:04 <kuribas> idk why mxe uses a .static postfix
07:03:42 * hackagebot simple-logger 0.0.4 – A very simple but efficient logging framework – https://hackage.haskell.org/package/simple-logger
07:04:42 <kuribas> mlehmk: configure just ignores my --with-ld=  etc...
07:11:49 * hackagebot stack 1.5.0 – The Haskell Tool Stack – https://hackage.haskell.org/package/stack
07:18:52 <sm> \o/
07:20:51 <ventonegro> all rejoice
07:22:06 <butterthebuddha> How do you guys "discover" functions
07:22:17 <ventonegro> butterthebuddha: Hoogle
07:22:36 <butterthebuddha> That's a creative name
07:23:13 <butterthebuddha> Is there a list of most often used functions that I should be aware of?
07:23:52 <merijn> I don't think there's such a list
07:23:57 <kuribas> butterthebuddha: the prelude
07:24:12 <merijn> butterthebuddha: Usually checking Prelude, base, searching Hoogle and asking here is how I find stuff
07:24:20 <jstolarek> I just tried installing stack 1.5.0 with a clean installation of GHC 8.2.1 and cabal can't resolve dependencies
07:24:35 <kuribas> butterthebuddha: and also Data.List, Data.Maybe, Data.Either, Control.Monad, Control.Applicative, etc...
07:24:50 <merijn> jstolarek: Well, 8.2 is only just released, I wouldn't be surprised if lots of stuff is still broken/disallowing base 4.10
07:24:59 <butterthebuddha> btw guys, is real world haskell outdated?
07:25:08 <merijn> butterthebuddha: A bit
07:25:15 <butterthebuddha> what should I watch out for?
07:25:45 <merijn> butterthebuddha: The high level advice/explanation still holds, but not all code samples might compile without some tweaking/fixing
07:26:05 <butterthebuddha> What about learn you a haskell?
07:26:25 <jstolarek> actually, I can't get any version of stack to install with 8.2.1. Oh well
07:26:28 <merijn> butterthebuddha: i.e. the Parsec chapter's code might not compile directly, but the explanation of how to write parsers with it still applies to newer parsec versions
07:27:03 <butterthebuddha> So the first few chapters shuold be fine right?
07:27:51 <kuribas> butterthebuddha: everything is fine, but there are many advances that aren't in there.
07:32:06 <mnoonan_> butterthebuddha: hoogle is awesome, once you get used to the idea.  “I have a list of ‘Maybe Int’ and I want to only keep the ones that are ‘Just n’, and strip away the Just constructor..” … so you pull up the hoogle page and do:
07:32:13 <mnoonan_> @hoogle [Maybe Int] -> [Int]
07:32:13 <lambdabot> Boltzmann.Data.Oracle maxDegree :: [Maybe Int] -> Maybe Int
07:32:13 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
07:32:13 <lambdabot> Agda.Utils.List (!!!) :: [a] -> Int -> Maybe a
07:32:35 <mnoonan_> well, that didn’t give me what I expected :)
07:32:37 <kuribas> @hoogle [Maybe a] -> [a]
07:32:37 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:32:37 <lambdabot> Data.List.HT takeWhileJust :: [Maybe a] -> [a]
07:32:37 <lambdabot> Text.XML.HaXml.XmlContent.Parser catMaybes :: [Maybe a] -> [a]
07:33:21 <mnoonan_> the actual hoogle page will generalize your [Maybe Int] -> [Int], and catMaybes is the first hit there
07:33:45 <kuribas> it's a good idea to generalize the type signature.
07:33:57 <kuribas> use the most general 
07:34:26 <mnoonan_> agreed, but for learning purposes its nice to not have to think about that.
07:35:32 <kuribas> mnoonan_: I think hoogle shows the more specific ones first.
07:37:58 <zxcv> can learning prolog helps in haskell
07:39:44 <quchen> Not really.
07:40:43 <kuribas> perhaps to understand unification?
07:41:12 <dolio> Everyone should learn some prolog, though. Or something similar.
07:41:21 <dolio> Maybe something better than prolog.
07:41:30 <kuribas> curry :)
07:41:38 <ventonegro> minikanren
07:43:42 <zxcv> dolio: can you please tell me what is something better than prolog that you are refering to?
07:44:19 <byorgey> kuribas: use the *most* general??  The most general generalization of  [Maybe Int] -> [Int]  is   forall a. a
07:44:22 <merijn> All I remember about PROLOG is even more thorough confusion then when I was learning ocaml
07:44:38 <kuribas> byorgey: well, preserving the semantics...
07:44:57 <merijn> kuribas: How do you know it preserves semantics to go from Int to a there?
07:44:57 <byorgey> kuribas: but how do you know if you are preserving the semantics?
07:45:14 <kuribas> I suppose you know when looking for it?
07:45:26 <byorgey> I agree generalizing the type is probably a good idea, but there must be a lot of heuristics that go into deciding exactly how much to generalize
07:46:08 <dolio> zxcv: Well, I think curry and minikanren were suggestions. There's also lambda prolog (which sounds similar, but I've heard it's better) and Mercury.
07:46:10 <kuribas> right, the most general might not exist...
07:46:35 <dolio> Also twelf and lolli.
07:47:10 <zxcv> dolio: ok, thank you 
07:47:13 <dolio> Although I don't know if I'd recommend twelf, since you might not notice that it's like prolog unless you already know prolog.
07:47:19 <kuribas> byorgey: but if the value of the Int parameter isn't used in the semantics, you may as well replace it with a type variable...
07:48:12 <byorgey> kuribas: agreed.  But we are talking about the situation where all you enter into hoogle is  [Maybe Int] -> [Int].  Hoogle can't possibly know, just from that, whether you intend for the values of the Ints to be used in the semantics
07:49:01 <kuribas> byorgey: yes, then wouldn't it make more sense to use a type-variable here?
07:49:16 <byorgey> but maybe you were just talking about whether you, as a human, ought to generalize the type signature to [Maybe a] -> [a].  In which case I wholeheartedly agree.
07:50:08 <kuribas> byorgey: right, that's what I meant
07:50:44 <kuribas> but then again a more general function might not exist.
07:52:42 <hvr> ...anyone here experienced w/ acid-state?
07:57:48 <f-a> reading control.lens.tutorial:
07:57:54 <f-a> type Getting b a b  = (b -> Const b b) -> (a -> Const b a)
07:57:54 <f-a> -- ... equivalent to: (b ->       b  ) -> (a ->       b  )
07:57:55 <f-a> -- ... equivalent to:                     (a ->       b  )
07:58:21 <f-a> It is not clear how you can go from (b -> b) -> (a -> b) to (a -> b)?
07:58:35 <kmelva> trying to make a super simple terminal using haskell-gi and gi-vte, but I'm stuck right at the beginning. Can't get past this Overlapping instances problem. Here's the code and the error: https://gist.github.com/kmelva/7b3d55cde3d0bf61940f95e2ffc4d1f2
08:00:44 <ertes-w> f-a: where did you find that?
08:01:01 <f-a> hello ertes-w http://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html
08:02:00 <byorgey> @type \ab bb a -> bb (ab a)
08:02:01 <lambdabot> (t2 -> t1) -> (t1 -> t) -> t2 -> t
08:02:18 <byorgey> @type \bbab a -> bbab id a
08:02:20 <lambdabot> ((a -> a) -> t1 -> t) -> t1 -> t
08:02:26 <int-e> f-a: just pass the identity function as the b -> b argument
08:02:47 <ertes-w> f-a: look above that
08:02:47 <lyxia> it's not an equivalence though
08:03:01 <int-e> (you can encode a bit more in (b -> b) -> (a -> b) than into (a -> b) alone.)
08:03:07 <ertes-w> f-a: ah, nevermind
08:04:30 <ertes-w> f-a: i don't know what the author means by "equivalent" there…  the types are certainly not equivalent, unless 'b' is fully polymorphic, in which case they are trivially equivalent
08:04:59 <f-a> ertes-w: but there is no forall b. b -> b here, right?
08:05:11 <ertes-w> correct…  the types are bound by Getting
08:05:43 <byorgey> I think it actually is an equivalence, by parametricity
08:05:52 <int-e> f-a: you may get away with arguing that there's only one function of type  (forall b. ((b -> b) -> (a -> b)) -> (a -> b)).
08:05:58 <butterthebuddha> Why are functions like head and tail partial instead of using the Maybe type?
08:06:02 <phadej> you have to think about Getter a b = forall r. Getting r a b
08:06:26 <byorgey> one direction is obviously the identity. In the other direction you get   g  --->  (\h -> h . g id)
08:06:35 <ertes-w> byorgey: by parametricity they are different by a factor of ℕ
08:06:37 <f-a> byorgey: I suspect convenienve and history
08:06:44 <f-a> ... butterthebuddha , I meant
08:07:03 <byorgey> ertes-w: can you expand on that?
08:07:22 <byorgey> oh, wait, I see
08:07:22 <ertes-w> byorgey: the (b -> b) can be applied arbitrarily many times before returning the result
08:07:39 <phadej> or not.., hmm
08:08:11 <ertes-w> but parametricity isn't really relevant either, because if the types are polymorphic, both types are empty
08:08:19 <butterthebuddha> f-a: hmm?
08:08:19 <byorgey> ertes-w: right
08:08:46 <ertes-w> that…  of course does make them equivalent =)
08:08:56 <byorgey> haha
08:09:21 <byorgey> no, you're right though, it is supposed to be for some given, fixed choice of a and b,  not for the types   forall a b. (b -> b) -> (a -> b) or whatever
08:09:31 <byorgey> which are indeed empty
08:09:45 <f-a> butterthebuddha: historical artifact. You start with partial functions, then develop 'Maybe', but then a bazillion of lines of code use old `head`, and you leave it like it is.
08:09:58 <butterthebuddha> Ah that makes sense
08:10:12 <mnoonan_> butterthebuddha: it’s just a historical wart in Prelude. there are some alternate preludes that remove the wart, and define ‘head :: [a] -> Maybe a’ etc
08:10:31 <f-a> just pattern match on stuff instead of using head is a sensible choice
08:11:08 <merijn> mnoonan_: The problem is that that safe head won't suffice in some scenarios
08:11:17 <merijn> f-a: ^^
08:11:33 <mnoonan_> merijn: hmm, why not?
08:11:39 <merijn> mnoonan_, f-a: Classical example would be "map head . groupBy foo"
08:12:07 <merijn> mnoonan_: groupBy returns a list of non-empty lists, so you can use head to find a representative element of every group
08:12:32 <merijn> Something similar cannot easily be written via Maybe or pattern matching
08:12:45 <phadej> type Getter s a = forall r. Getting r s a = forall r. (a -> Const r a) -> (s -> Const r s) = forall r. (a -> r) -> (s -> r)
08:12:48 <phadej> -- Yoneda digression:
08:12:48 <phadej> ah
08:12:51 <mnoonan_> merijn: I’m not sure I find that very persuasive. you’re pushing the burden of proof into an informal spec instead of representing it directly
08:12:53 <phadej> forall x. (a -> x) -> f x ≅ f a
08:12:55 <phadej> -- = (s -> a)
08:13:07 <phadej> ^ https://gist.github.com/phadej/84474c4b598b1346766049a1c4ee92c1
08:13:27 <ertes-w> butterthebuddha: a safe 'head' can be easily obtained using 'foldr'
08:13:32 <ertes-w> butterthebuddha: i do that quite a lot
08:13:54 <ertes-w> :t foldr (\x _ -> print x) (putStrLn "No head.")
08:13:56 <lambdabot> (Show a, Foldable t) => t a -> IO ()
08:14:15 <dolio> Yeah, that's why I feel like 'safeHead' is kind of useless.
08:14:18 <byorgey> phadej: aha
08:14:47 <f-a> I see
08:15:01 <dolio> Uses of it will be more verbose than foldr or case directly, unless you happen to need to send a Maybe to something else.
08:15:12 <ertes-w> 'head' is useful in some boolean-blind scenarios, where using non-empty lists or otherwise constructively proving the existence of the head is too cumbersome
08:15:29 <f-a> seems a risky proposition on non textbook examples though, the day you mess up you are greeted by a "Prelude: empty list"
08:15:45 <byorgey> there is already a safe head in Prelude. it is called listToMaybe.
08:16:00 <dolio> Is that in the prelude?
08:16:01 <byorgey> that name does a much better job indicating when it is actually useful.
08:16:03 <byorgey> yes.
08:16:08 <ertes-w> byorgey: it lives in Data.Maybe though, which i personally rarely import
08:16:09 <byorgey> well, maybe not
08:16:10 <nshepperd_> When you use safeHead you would usually need to pattern match on the Maybe, in which case you might as well have pattern matched the original list...
08:16:12 <phadej> it's in Data.Maybe, not exported from Prelude
08:16:26 <byorgey> Yeah, I forgot I have a bunch of modules imported in my .ghci
08:16:40 <merijn> byorgey: Join the club ;)
08:17:40 * hackagebot duckling 0.1.2.0 – A Haskell library for parsing text into structured data. – https://hackage.haskell.org/package/duckling
08:17:52 <dolio> foldMap Just isn't much longer. Is that in the prelude now?
08:18:01 <phadej> > (preview folded "", preview folded "foo")
08:18:04 <lambdabot>  (Nothing,Just 'f')
08:18:15 <glguy> :t foldMap Just
08:18:17 <lambdabot> (Monoid a, Foldable t) => t a -> Maybe a
08:18:19 <phadej> dolio: that's different
08:18:48 <phadej> > foldMap Just ["foo", "bar"]
08:18:51 <lambdabot>  Just "foobar"
08:18:54 <dolio> Oh, my bad.
08:19:03 <dolio> You need to go through First, so it's terrible.
08:20:00 <phadej> you can pretend to be Conor McBride
08:20:02 <phadej> > alaf First foldMap Just "foobar"
08:20:05 <lambdabot>  Just 'f'
08:20:17 <dolio> Yeah, but alaf isn't in the prelude.
08:20:23 <phadej> :)
08:20:32 <Franciman> Hi, I have from C this structure: struct Data { int Min; int Max; } and this function Data f(); . I want to call f from haskell, What should its return type be?
08:21:01 <phadej> dolio: well, libraries are there to be installed and used
08:21:02 <Franciman> ops sorry: Data f(int); *
08:22:58 <jstolarek> http://lpaste.net/357192
08:23:11 <jstolarek> just got this error from stack setup. Halp?
08:23:22 <dolio> Franciman: I don't think you can directly wrap a function that returns a struct.
08:24:04 <jstolarek> is this a problem with remote resources or something wrong with my setup?
08:24:36 <glguy> Franciman: You'll need to wrap that in C so that it doesn't return a struct and then you can import the wrapper
08:25:03 <Franciman> glguy, wrap it, in which sense?
08:25:10 <glguy> Franciman: in a new C function
08:25:24 <Franciman> returning what?
08:25:28 <dolio> A pointer.
08:25:37 <glguy> using pointers to get multiple results out, C style
08:26:04 <Franciman> oh, you mean I had better return an array?
08:26:11 <glguy> nope
08:26:19 <dolio> Oh, glguy means pass an out parameter.
08:26:28 <Franciman> ah, an out parameter, ok
08:26:35 <Franciman> ok thanks
08:26:51 <glguy> Yeah, that :)
08:26:58 <sm> jstolarek: probably an intermittent outage
08:27:17 <Franciman> if instead I had Data *f();
08:27:18 <Franciman> ?
08:27:25 <Franciman> so I get an array of Data
08:27:35 <Franciman> is it always better to use out params or something else?
08:27:39 <glguy> Franciman: That's OK, but now you need to remember to deallocate them
08:28:22 <glguy> and you can use hsc2hs to help generate marshaling code for that struct
08:28:23 <Franciman> glguy, but now how do I represent Data in haskell?
08:28:34 <Franciman> oh understood
08:28:46 <Franciman> so now I get a Ptr MarshaledData
08:28:48 <Franciman> in haskell, right?
08:28:59 <Franciman> and I can use Foreign.Marshal.Array stuff to access single Datas?
08:29:02 <mauke> data Data = MkData { dataMin, dataMax :: CInt }
08:29:09 <mauke> uh, what?
08:29:11 <dolio> You'd need a Haskell type and a Storable instance that matches the layout that you will get in the pointer, I imagine.
08:29:21 <mauke> I thought we were talking about a single struct value
08:29:43 <Franciman> an array of them
08:30:36 <Franciman> mauke, for data Data = MkData { ... } would I still need the Storable instance? (If the result were just a pointer to a single struct value) ?
08:30:55 <glguy> Franciman: You only need the Storable instance if you care to read/write the values inside the struct
08:31:05 <Franciman> I do
08:31:48 <Franciman> so, doing a recap. If I have Data *f(int); returning a single Data
08:31:53 <Franciman> I still need to Storable instance
08:31:55 <Franciman> right?
08:32:34 <mauke> I recommend you don't have Data *f(int)
08:32:40 <dolio> If you want to see the ints in Haskell, yes. If you're just moving pointers around, no.
08:33:01 <Franciman> mauke, better the out params?
08:33:44 <mauke> yeah
08:33:58 <Franciman> ok, very well. Thank you all for the help
08:37:52 <fendor> hey guys, i'm using the repa library for 2d-convolution. While the execution time of the known-to-compile time kernel is really good, the dynamic own is terribly slow. Does someone have experience with this problem and can suggest alternatives?
08:38:52 * hackagebot optparse-version 0.1.0.0 – <i>Added by shmish111, Tue Jul 25 15:31:36 UTC 2017.</i> – https://hackage.haskell.org/package/optparse-version
08:42:00 <fendor> in other words, can someone help me with a performance issue with the repa library?
08:42:27 <kuribas`> fendor: if you just need speed, the fastest way would be to use a C library.
08:42:34 <kuribas`> using SSE or the GPU.
08:44:00 <fendor> kuribas`, i'm aware, but i do not need just speed. This part of a paper, and I'm supposed to compare haskell and C, and for the first comparisons, it does not make sense to compare C to a langauge that immediately calls C
08:45:13 <fendor> it is ok, if it is simply not possible to perform better than C in this case, I'm just asking
08:45:18 <kuribas`> fendor: is it this one?  http://hackage.haskell.org/package/repa-algorithms-3.4.1.1/docs/Data-Array-Repa-Algorithms-Convolve.html
08:45:32 <fendor> but exactly
08:45:38 <fendor> *exactly
08:45:41 <kuribas`> fendor: it will likely be much slower.
08:45:51 <fendor> it is, by a factor of about 180
08:46:14 <erisco> turn around, the solution is behind you
08:46:28 <fendor> it actually is so slow on one execution... that I'm starting to think that i did something wrong
08:46:52 <fendor> erisco, behind me is just a booksehlf
08:47:05 <kuribas`> fendor: is the C code your own?
08:47:11 <erisco> read between the boards
08:47:28 <fendor> kuribas`, yes it is
08:47:56 <fendor> erisco, Java 7?
08:48:14 <erisco> bingo, you need more factories
08:48:22 <fendor> guessed so
08:48:51 <fendor> objects will fix everything
08:49:51 * hackagebot optparse-version 0.2.0.0 – <i>Added by shmish111, Tue Jul 25 15:43:42 UTC 2017.</i> – https://hackage.haskell.org/package/optparse-version
08:49:54 <kuribas`> fendor: you want to see if haskell on the gpu is faster than C on the CPU?
08:50:57 <fendor> does haskell use the gpu with this library? 0.o
08:51:53 <ezyang> repa doens't gpu. You shoudl look at Accelerate for that 
08:53:28 <fendor> kuribas`, was that a suggestion? well, no, it would be only interesting if c uses the gpu, too. I have to at least claim that the results are somehow comparable
08:53:42 <kuribas`> fendor: if the c compiler translates to SIMD instructions, you cannot beat that in haskell.  Otherwise you can get similar performance with unboxed mutable vectors.
08:53:45 <fendor> ezyang, wasn't able to compile that library
08:54:14 <frerich> Is anybody here familiar with Darcs? I just applied a patch to a Darcs repository (locally) and would like to contribute the patch back upstream. Is there a standard procedure for this, e.g. do I just do 'darcs diff > foo.patch' and send that? Or is there a nicer way (e.g. in Git you'd typically do a commit and then use 'git format-patch')?
08:54:42 <fendor> kuribas`, repa uses unboxed values and the optimized library beats c easily, i was just asking myself, if there is some way to accelerate the dynamic version as well
08:55:05 <kuribas`> oh right
08:55:50 <dolio> frerich: darcs send is how you prepare a patch to be applied to another repository.
08:56:04 <fendor> maybe i got to explain, there are two versions, one that knows the kernel during compile time. This version is heavily optimized in haskell and there exist several papers which are very good readings. But if the kernel is not known during compile time, i have to use the linked library, which is slower by the factor of about 180
08:56:15 <frerich> dolio: Aaah, 'send'... thanks, that looks good!
08:56:56 <fendor> i wanted to know, if someone knows of easy improvements, or why it performs so poorly, although the problem instance isn't that big
08:57:56 * hackagebot optparse-version 0.3.0.0 – <i>Added by shmish111, Tue Jul 25 15:50:21 UTC 2017.</i> – https://hackage.haskell.org/package/optparse-version
08:58:26 <kuribas`> fendor: I don't know repa well, but you could look if your datatype is properly specialized.
09:00:00 <sm> frerich: and if the upstream repo is on darcshub, there are other ways
09:00:01 <fendor> kuribas`, it is a `Array DIM2 Double`, in both cases as required, i don't know how I could improve the performance
09:00:13 <fendor> *i mean datatypes
09:00:29 <dolio> fendor: What does it mean to not "know the kernel" and "use the linked library"?
09:01:02 <kuribas`> by kernel you mean the convolution kernel right?
09:01:07 <fendor> dolio, know the kernel: the kernel which is applied on an image is known when compiling. 
09:01:27 <fendor> correct, i know, the term is rather confusing and used in too many contexts
09:01:51 <fendor> dolio, the linked library: https://hackage.haskell.org/package/repa-algorithms-3.4.1.1/docs/Data-Array-Repa-Algorithms-Convolve.html
09:02:20 <fendor> dolio, because there is an implementation in the base package and in this extra package "repa-algorithms"
09:03:23 <dolio> Oh, "linked library" meaning the library you linked to.
09:04:48 <fendor> dolio, yes, sorry if that was unclear. as you can see, i'm rather clumsy to express myself (e.g. my english is terrible)
09:05:17 <dolio> fendor: Is the "kernel" the thing called the "stencil" in those docs?
09:05:39 <fendor> dolio, yes
09:07:19 <dolio> fendor: Where is the convolution in the repa package you're comparing it to?
09:08:17 <fendor> dolio, https://hackage.haskell.org/package/repa-3.4.1.2/docs/Data-Array-Repa-Stencil-Dim2.html
09:16:47 <kuribas`> fendor you can inspect the core, and compare the assembly output
09:18:02 <fendor> kuribas`, I'm not qualified for this, I can't read assembly i any way
09:18:43 <fendor> * in any way
09:19:05 <whoman> fendor, sometimes a comparison is enough to shine some light
09:19:10 <whoman> **contrast 
09:21:11 <dolio> fendor: It's hard for me to tell, since I don't really understand what the code is doing. The code does look quite different, though.
09:21:27 <dolio> Like, in the overall approach.
09:21:49 <fendor> dolio, yeah, that's weird, and especially the perofrmance difference is insane
09:22:28 <dolio> The in-repa version has a potentially more efficient representation of 'what to do with stuff outside the kernel' for instance.
09:23:20 <dolio> And I'm not sure if the fact that the repa-algorithms version uses an arbitrary function has bad effects for every item in the array, for instance.
09:24:16 <fendor> dolio, you are right... maybe it would be possible to change the quasi quoter implementation to just generate the appropiate functions?
09:25:11 <fendor> but i honestly love the TODO's in the code :D "this probably doesn't work for stencils who's extents are even."
09:26:26 <dolio> fendor: I don't really understand repa, either.
09:26:37 <cloudhead> hey does anyone have example code for the cryptonite library?
09:27:20 <dolio> Anyhow, returning the result as a bunch of disjoint regions seems a lot different than returning the result as a whole 2D region.
09:28:42 * hackagebot snowtify 0.1.0.1 – snowtify send your result of `stack build` (`stack test`) to notify-daemon… – https://hackage.haskell.org/package/snowtify
09:28:42 * hackagebot HsOpenSSL 0.11.4.10 – Partial OpenSSL binding for Haskell – https://hackage.haskell.org/package/HsOpenSSL
09:29:13 <fendor> dolio, you're absolutely right, i should probably write to the library authors for aid, shouldn't I?
09:29:45 <dolio> fendor: Probably. :)
09:30:18 <fendor> dolio, great :D should I just write an email, or is there any chance to catch 'em here?
09:32:57 <kuribas`> fendor: I am not aware of any repa authors here...
09:33:11 <fendor> what a pity :(
09:33:35 <kuribas`> write an email to be sure
09:36:44 <fendor> kuribas`, thanks, I will do this!
09:37:33 <fendor> thanks to everyone for your time!
09:48:59 <cloudhead> hey, does anyone have experience with cryptonite? especially Crypto.PubKey.*
09:53:11 <glguy> cloudhead: You're getting much closer to a specific question about the library!
09:55:14 <vktec> cloudhead: A good rule to follow on IRC: don't ask to ask
09:57:05 <whoman> unless somehow that is one's main question.. =P
09:57:13 <cloudhead> :D
09:57:52 <cloudhead> ok good point, I wanted to pick someone's brain but will be back and ask a more specific question
10:05:13 * hackagebot language-c-quote 0.12.1 – C/CUDA/OpenCL/Objective-C quasiquoting library. – https://hackage.haskell.org/package/language-c-quote
10:09:27 <vagrant-> hello all, is there a haskell library which provides a mutable vector that supports O(1) append and subslicing? I think vector provides the second but not the first, and dynamic-mvector provides the first but not the second :\
10:09:38 <tippenein> I'm trying to sort from a ListT STM - http://lpaste.net/357195
10:10:34 <tippenein> I've picked this problem up again but I wasn't able to sort it when I tried before. Maybe I need to ditch ListT, but I'm not very knowledgeable with performant structures
10:14:21 <c_wraith> ListT STM isn't actually a monad, if that matters.. 
10:15:27 <c_wraith> vagrant-, is there a data structure anywhere that provides those properties? 
10:16:00 <Athas> fendor: do you have examples of Repa beating C?
10:17:45 <vagrant-> c_wraith: an array?
10:18:24 <c_wraith> vagrant-, those certainly do not have O(1) append 
10:18:34 <vagrant-> c_wraith: amortized, sure they do
10:18:53 <kuribas`> c_wraith: a c++ vector
10:19:02 <vagrant-> ^ yes
10:19:08 <c_wraith> vagrant-, amortized is very different. you can do the exact same thing in Haskell. 
10:19:10 <vagrant-> note that I said mutable
10:19:22 <c_wraith> mutable does not imply amortized timing. 
10:19:29 <vagrant-> c_wraith: fantastic! So, then my question was is there a library that provides it
10:20:02 <c_wraith> probably. 
10:20:12 <kuribas`> c_wraith: immutable append would be O(n)
10:20:15 <vagrant-> c_wraith: in the sense that a single append operation might require an allocation and copy (which takes O(n)) but over time it works out to O(1)
10:20:39 <vagrant-> this is true for pretty much every mainstream imperative language (python, C++, java arraylists etc)
10:20:50 <c_wraith> I understand what amortized timing and mutability are. 
10:21:07 <vagrant-> I know haskell has mutable vectors but looking at the definition of `grow` it looks like it always does a copy... but maybe I'm mistaken
10:21:26 <c_wraith> but if you don't specify you're looking for amortized timing, I'm not going to lie about timing. 
10:21:36 <vagrant-> c_wraith: ok, let's move beyond that then
10:23:10 <c_wraith> for what it's worth, Vector itself does not provide this. though I think you could hack it in, now that ByteArray# knows how big it is. 
10:23:13 <rain1> what data structure can implement this ? the array with fast append and slice
10:23:14 <ReinH> This is much easier if you're willing to accept a log factor increase in timing.
10:23:43 <ReinH> Which, for many use cases, is effectively a constant factor.
10:23:49 <c_wraith> but I'd look at hackage to see if anyone has just wrapped vector 
10:24:53 <vagrant-> I could try an immutable structure but the application does not require it and it's less efficient...
10:25:12 <ReinH> Is it though?
10:25:17 <ReinH> I mean, in practice.
10:25:27 <vagrant-> Depending on the application, of course
10:25:37 <kuribas`> vagrant-: that's only true if it's a bottleneck
10:25:43 <ReinH> And in Haskell, you generally want to find a reason you need mutability, not a reason you need immutability.
10:25:58 <tippenein> I'm not sure what you're hinting at about ListT STM not being a monad. I'm just fiddling  at this point
10:26:05 <vagrant-> OK, let's just pretend that I know that that's what I need, because that's not really the question that I'm asking...
10:26:06 <rain1> im just curious about the data structures i never heard of anything thath lets you append in o(1) like that
10:26:32 <ReinH> rain1: C++ vectors have *amortized* constant time append because they only reallocate occasionally.
10:27:14 <kuribas`> rain1: you reallocate a multiple of the original size when needed.
10:27:26 <ReinH> Or some scaling factor, yes.
10:27:30 <ongy> which can give ugly delay spikes from time to time
10:27:30 <rain1> but dont you still have to copy the second vectors content?
10:27:44 <ReinH> rain1: only when you reallocate
10:28:13 <ReinH> ongy: Yeah, amortized structures are often a bad fit for hard real-time applications for this reason
10:28:29 <ReinH> you'd rather it be slower with a known, consistent timing
10:28:33 <ongy> that's what amortized is. the idea is you "pay" some constant factor in each append, so you have payed for the copy when it occurs
10:28:39 <ReinH> than usually much faster and occasionally much slower
10:28:51 <vagrant-> rain1: typically a vector will have a "capacity" which is larger than the actual number of elements in the array. copying is only necessary when appending to a vector when the capacity is maxed out. The new vector will have e.g. double the capacity of the old
10:29:02 <ReinH> Yeah, I like the way Okasaki describes it.
10:29:33 <rain1> vagrant-: but if you appenend [a,b,c] (wich had capacity 100 say) with [x,y,z], dont you hav et ocpy x y and z into the first vectors extra capacity? I get that you dont' have to realloc yet
10:29:39 <kuribas`> still memory copy is very fast
10:29:47 <ongy> I've had a course where they taught this stuff, then I read the Okasaki book, and was wondering how much of the course was based on it :)
10:29:49 <kuribas`> however allocation isn't...
10:29:59 <rain1> i agree memcopy is fast but it's still O(n)
10:30:32 <ReinH> Yes, no one is saying otherwise
10:30:32 <vagrant-> rain1: yes, when you resize the underlying array that typically requires a copy (although there might be clever workarounds).
10:30:40 <jedai> rain1: when they say append they mean one element to the end
10:30:53 <rain1> oh okay
10:30:54 <jedai> rain1: they're not speaking about concatenation
10:31:30 <rain1> i was thinking of ++ type append, i usually call just adding one element at the end snoc or push :P
10:32:19 <vagrant-> rain1: i write python at work so 'append' is part of my vocabulary ;)
10:32:36 <vagrant-> a JS dev would probably say push I guess :)
10:32:47 <ongy> append in O(1) would be nice. But I guess the only way is doing some mmap magic. Which has horrible constraints
10:33:43 <ReinH> In C++ it's called push_back iirc
10:34:25 <Athas> O(1) append and subslicing is pretty easy if you can live with non-O(1) indexing.
10:34:27 <ongy> because push_front is also a thing.
10:35:42 <ongy> Athas: how do you get O(1) subslicing wihtout O(1) index?
10:36:09 <ongy> just add start/end index into the structure and call it done?
10:36:15 <Athas> ongy: you don't need to produce a value when slicing.  You can just save the slice offsets, and then resolve when once the index operation comes knocking.
10:36:17 <Athas> Yeah.
10:36:33 <Athas> But your indexing can become really expensive.
10:36:41 <ongy> so you access will be O(some random thing depending on where your slice is from)? :)
10:37:35 <rain1> when you interleave slicing with appending things get crazy
10:38:47 <Athas> ongy: yes!
10:39:01 <ongy> fun!
10:39:15 <vktec> The GHC documentation for the -threaded option lists benefits for the threaded runtime but no disadvantages. What are they? If there are none, why not use the threaded runtime by default?
10:39:18 <kuribas`> Wouldn't you just need Slicable a = Original (MutableVector a) | Sliced Int Int (Slicable a)
10:39:20 <Athas> But maybe that's what you want.  You could also have some "flatten" operation that guarantees that the next index will be O(1) (or O(n*log(n))).
10:39:22 <ongy> but this reminds me of when I thought I'm smarter than GHC and tried to optimize something with vectors, and things got slower than the list implementation I had earlier...
10:39:27 <Athas> It would be user-controlled amortisation!
10:39:40 <ReinH> O(1) everything is easy: first, you must allocate the universe.
10:39:41 <Athas> kuribas`: yes, and then similar things for concat.
10:39:51 <Athas> vktec: threaded GC can be slow.
10:40:03 <vktec> Athas: Ah, okay
10:40:10 <Athas> Actually, the threaded RTS in general is slightly slower than the non-threaded one.
10:40:18 <Athas> Although I think the difference is negligible.
10:40:29 <Franciman> when are LinearTypes planned to be released?
10:40:44 <ongy> when you are heavy on IO it's probably even faster. Since the non-threaded GHC does some annoying things (I at least think threaded avoids)
10:40:45 <vktec> That seems odd; multithreaded programs being slower than singlethreaded ones
10:41:11 <geekosaur> er? that's normal
10:41:20 <geekosaur> multithreaded implies locking/mutexes
10:41:26 <Athas> vktec: parallelisation always comes with overhead.
10:41:26 <vktec> True
10:41:40 <Athas> That's why parallelising functional programs turns out to be not that much easier than imperative languages.
10:41:47 <Athas> (Assuming you want them to run fast.)
10:42:05 <kuribas`> Athas: but concat would copy Sliced into Original.
10:42:19 <Athas> kuribas`: oh, mutable, sure.
10:42:31 <Athas> Although that might require allocation and copying, which is not O(1).
10:42:42 <kuribas`> Athas: sure
10:43:31 <ongy> and things explode when you try to remove an element
10:43:31 <cocreature> vktec: all that being said, most people would agree that the threaded runtime should be the default and the reason why it’s not, is mostly that nobody has bothered to push the change through
10:44:18 <kuribas`> ongy: not really
10:44:39 <kuribas`> ongy: the sliced vector would just shrink as well.
10:45:07 <ongy> which is totally expected for slices to happen :)
10:47:34 <kuribas`> the joy of mutability
10:49:43 <kuribas`> ongy: isn't a slice supposed to follow the original vector?
10:50:36 <vktec> cocreature: Fair enough
10:51:04 <ongy> I thought slices are supposed to be viewed as independant, but I've only used slicing in haskell and rust so far, so I may be off. Both of those have a certain sense of immutability by default
10:52:08 <nak> can someone explain to me how haskell lazily reverses a list ?
10:52:21 <nak> by asking for the first item of the reversed list, that's the last item of the input list
10:52:43 <kuribas`> nak: reverse is not lazy in the spine of the list.
10:52:44 <geekosaur> actually reverse is an example of something that is (spine-)strict
10:52:44 <nak> O(n) time to get the first item of the reversed list no matter what, ... right ?
10:53:02 <geekosaur> but to get to the end of a list, you do not need to evaluate the items inside the list, only the (:) constructors
10:53:07 <geekosaur> so in that sense it can still be lazy
10:53:08 <kuribas`> nak: right
10:53:42 <nak> so i'm reading about the Queue here: http://www.toves.org/books/persist/
10:53:51 <cocreature> > head (reverse [undefined, undefined, 1]) -- that illustrates what geekosaur is referring to
10:53:53 <lambdabot>  1
10:54:06 <nak> the Queue implementation is using `last` and `reverse` which require 0(n) time ... that seems really bad, doesn't it ?
10:55:03 <ReinH> This is another amortized operation.
10:55:41 <ReinH> You only do this when the front half of the queue is empty.
10:55:43 <cocreature> that’s true for the call to "reverse" but not for the call to "last"
10:55:51 <nak> ReinH: because it only happens in that one scenario
10:55:53 <nak> ok
10:56:02 <cocreature> repeadetly calling peekFront will just be slow
10:56:18 <cocreature> now you could fix this if you are fine with updating the queue representation in peekFront
10:56:22 <cocreature> but the implementation here doesn’t
10:56:43 <ReinH> persistent structures and peaking don't go together
10:57:09 <ongy> at least not for amortized costs
10:57:20 <ReinH> you can't amortize peeking.
10:57:29 <ReinH> but you can with a mutable structure.
10:57:55 <ongy> peeking in gernal and persistent structures work pretty well imo. Since peek doesn't modify :)
10:58:07 <nak> ReinH: so basically this structure is optimized for enqueueing, and then peeking while dequeueing
10:58:21 <nak> a mixture of enqueue, peek, dequeue, enqueue, peek .. would be less than optimal
10:58:23 <ReinH> this structure is optimized for queueing and dequeueing and not for peeking.
10:58:40 <ReinH> peeking an unbalanced structure is always pessimal
10:58:45 <nak> ReinH: i don't understand how you get an item from the queue then ?
10:58:49 <ongy> ah, I don't remember, did the Okasaki book provide a solution for how amortized works when things "branch" off from the point before the costs needs to be payed?
10:58:51 <ReinH> (i.e., one with an empty front half)
10:59:20 <ReinH> nak: the implementation is weird. Usually, you have dequeue :: Queue a -> (a, Queue a), possibly with a Maybe involved.
10:59:36 <nak> ah ok, that makes more sense
11:00:05 <nak> same thing with stackpop :: Stack a -> (a, Stack a)  ?
11:00:06 <ReinH> @unmtl State s a
11:00:06 <lambdabot> s -> (a, s)
11:00:13 <nak> ooooo
11:01:13 * hackagebot cryptol 2.5.0 – Cryptol: The Language of Cryptography – https://hackage.haskell.org/package/cryptol
11:01:31 <nak> ReinH: ok thanks that makes more sense
11:02:09 <ReinH> Yeah. You usually want to know what the element you popped is rather than just throwing it away.
11:02:53 <ongy> or implement the peek more efficint, so you can just peek it before you dequeue
11:03:09 <ongy> *at least
11:04:35 <tippenein> I've gotten the sort working, but I need to remove an unsafePerform and perhaps speed it up: https://github.com/dimroc/etl-language-comparison/pull/34/files#diff-56ea02af3f43981011d2a874c25669eaR66
11:05:04 <tippenein> maybe a streaming foldl' would help and I don't think the unsafePerform is actually necessary
11:05:25 <ReinH> tippenein: if you're already in IO, why unsafePerformIO at all?
11:05:53 <trigone> hi, can i use quickcheck for IO functions too? doesn't seem possible but then i barely scratched the surface of quickcheck. how do you test code that is strongly side-effect oriented? say if you have functions creating/modifying/deleting files/folder, is there a library to safely create dummy files/folder to test things on?
11:06:08 <ReinH> just use <- instead of let
11:06:35 <tippenein> ReinH: totally right. I just did writeFile ... =<< sorted and removed the unsafePerform
11:06:40 <ReinH> trigone: Try to extract a pure core and test that and test as little IO as possible.
11:06:57 <ReinH> For example, the pure core could give a list of file actions as a result.
11:07:11 <ReinH> [Delete 'foo.txt', Create 'bar.txt' contents, etc]
11:07:49 <ReinH> If actions need access to the results of previous actions, you can use a free monad.
11:09:02 <dolio> quickcheck does have some kind of IO stuff, I think.
11:09:11 <dolio> I've never used it, though.
11:09:15 <ReinH> dolio: I'm sure that's true. It also doesn't change my answer. :D
11:09:28 <dolio> Yeah.
11:10:01 <cocreature> here is a quickcheck-io package
11:10:01 <ReinH> Once you test that Delete deletes and Create creates, you no longer need to perform IO to test a sequence of deletes and creates.
11:10:27 <trigone> ReinH: hm... that's a great idea actually. i was thinking that it'd be cool to be able to "simulate IO" and apply it to fake folders, fake files... this method mostly does that.
11:10:28 <ReinH> Your tests will be faster and your system will be better designed.
11:10:44 <ReinH> This is exactly the "free monad interpreter" pattern.
11:11:02 <ReinH> Except sometimes you don't need to use previous results, so you can just use the "free monoid interpreter" pattern.
11:12:30 <trigone> ReinH: there's one tiny problem however, the program is a loop reading blocks of files and doing something block by block. if it does not do the thing directly and stores the information away to be done after the whole loop ended, i'm not sure it'll be as fast, since it'll have to save big parts of the file as parameter...
11:13:18 <mnoonan_> trigone: you may be saved by laziness (though as far as I know there usually is *some* performance hit for free monads)
11:13:21 <ReinH> There's no reason for it to take any more space than a direct implementation in IO.
11:13:51 <ReinH> Well, modulo the space it takes to construct the free monad action, which is quite small.
11:14:03 <ReinH> You certainly don't need to hold file contents in memory longer than you would otherwise.
11:14:21 <ReinH> The thing doing the IO is still the IO action. You are just changing the way the IO action is constructed.
11:15:03 <monochrom> I'm wondering if you're conflating independent things just because they both use memory.
11:15:10 <ReinH> monochrom: me or trigone?
11:15:15 <monochrom> trigone.
11:15:18 <ReinH> Ok
11:15:27 <trigone> ReinH: hm really? technically the IO action can just be something like "write this parameter here, wherever here may be". if i read the whole file before doing anything, it'll have to go back where things must be done a second time... no?
11:15:51 <trigone> monochrom: independent things?
11:15:52 <ReinH> Why do you think you have to read the whole file before doing anything?
11:15:54 <monochrom> If you intend to keep file content in memory for a while, it will take memory whether you do IO or getContents or free monad or C.
11:16:02 <setre> what is develMain and where is it documented? is it part of cabal? stack?
11:16:41 <monochrom> Free monad will use some memory but it is indepenent of file size.
11:16:47 <kadoban> setre: Never heard of that
11:17:09 <monochrom> And not using free monad does not eliminate memory used for file content.
11:17:16 <trigone> ReinH: i think i get the intuition of the free monad. i probably forgot about laziness.
11:17:21 <ReinH> The free monad doesn't do any reading or writing.
11:17:29 <ReinH> Your interpretation of it creates an IO action which does reading or writing.
11:18:16 <ReinH> so you might have something like = do { contents <- Read "file.txt"; Write "file2.txt" contents; }
11:18:24 <ReinH> Read and Write don't perform and IO
11:18:42 <ReinH> s/and/any
11:19:26 <ReinH> They're just codes for the IO operations performed when you convert it to an IO action and GHC executes that action.
11:19:39 <trigone> ReinH: yes, i understand
11:19:42 <ReinH> The thing doing the reading is still, say, readFile.
11:20:07 <ReinH> And when that free monad action is interpreted, the contents read from readFile are passed directly to, say, writeFile.
11:20:13 <ReinH> Just like if you had written the IO action yourself.
11:20:31 <ReinH> The only extra cost is a pattern match on Read and Write.
11:20:35 <trigone> ReinH: i had the bad intuition that all the test (branching, aka if/else) code needed to be executed first, and therefore i had to read the whole file first before writing anything on it
11:20:47 <ReinH> Ah, no.
11:21:21 <trigone> ReinH: the free monad is really great. how did people do before having it?
11:21:23 <ReinH> interpreting the free monad action determines the outcome of interpreting the free monad action.
11:21:35 <ReinH> They did similar things without having the vocabulary to talk about it.
11:22:19 <mnoonan_> trigone: the laziness is the special sauce. it doesn’t get enough credit in the free monad pattern :)
11:22:19 <trigone> ReinH: well that would have been a hassle for beginners
11:25:13 <trigone> mnoonan_: what's laziness specifically enabling? i don't doubt what you said, i'm just not sure to see things properly
11:25:51 <trigone> btw, is the free monad a kind of recursive transformer or something? just by curiosity
11:26:06 <monochrom> recursive type. no transformer.
11:26:32 <trigone> monochrom: k
11:26:39 <monochrom> I think you should cook up an example use of free monad, and then I can point out where the laziness kicks in.
11:26:39 <mnoonan_> trigone: like if you want to model reading a line of input from the user, then execute action X or Y depending on what the user selected. Without laziness, you’d have to build up something that included both possible effects. then later, when the interpreter runs, you’d select one.
11:26:54 <mnoonan_> with laziness, you can interleave the interpreter’s evaluation with the construction of the model
11:27:19 <mnoonan_> (or rather, all that is handled by normal evaluation and you don’t have to do anything special)
11:30:01 <mnoonan_> so your free monad computation looks like ReadLine >>= (\input -> {thunk}), and you’re done until the interpreter does something with ReadLine. then you can take the input read by the interpreter and get the next step of the computation out. 
11:33:20 <J55> hey
11:34:24 <trigone> mnoonan_: ok, i understand :)
11:37:54 <trigone> actually, i don't see how i could use the free monad to test if my IO action will do what i want. how can it possibly yield the whole list of IO actions that will be performed without executing any IO?
11:38:51 <trigone> hm... unless i create a fake VirtualIO, with fake file handles that i control, and so on?
11:38:56 <jared-w> Isn't the free monad used to get introspection into the program itself? So you can use it to analyze how the IO would behave in a property test sort of way?
11:39:08 <trigone> and then i can test the state of the "virtual real world" before and after?
11:39:15 <davean> trigone: you can interprite something to symbolic actions, and then you can SEPERATELY interprite it to IO
11:39:25 <jared-w> ¯\_(ツ)_/¯ I barely understand monads, so free monads are still a bit beyond me
11:39:30 <davean> Use the free implimentation to generate an IO action
11:41:01 <trigone> davean: yeah but then it means that to get the whole list (to test the whole program's actions), if an IO action requires execution of the previous IO action to work, how can i possibly have even a symbolic version of it without executing any IO code? unless, as i said, i control the IO code myself, with a fake IO type
11:41:26 <mnoonan_> jared-w: you can’t use them to do static analysis of your action, so you maybe can’t quite get the kind of program analysis you might be thinking of
11:41:52 <trigone> actually, it must already exist, right? a fake IO library where you're the one to build fake file values, etc?
11:42:06 <davean> trigone: Free is a type
11:42:27 <trigone> davean: yes?
11:42:43 <davean> So that answers your question
11:43:09 <trigone> davean: well in your head, which is great, but since my head is a second head from yours...
11:43:10 <jared-w> mnoonan_: that makes sense. I thought what I was saying wasn't quite right :p
11:43:32 <davean> trigone: "14:39:08 davean Use the free implimentation to generate an IO action"
11:43:42 <davean> trigone: Free is a type, thus it isn't IO
11:43:50 <davean> because IO is a different type
11:44:14 <davean> So your question isn't well formed
11:44:33 <davean> See?
11:44:35 <trigone> davean: i was actually thinking of Free IO (), but i don't think it's the right type, since it amounts to a free monadic value built by the IO, instead of the opposite
11:44:38 <mnoonan_> jared-w: it’s a little less clear whether you can do it for applicatives though.. I think Haxl does an analysis of the applicative it builds up in order to batch queries together, but iirc there is some disagreement about whether or not Haxl is a law-abiding Applicative.
11:45:06 <davean> trigone: even then the same applies
11:45:29 <mnoonan_> jared-w: but anyway, that points to where the issue is: for applicative, you’re always building up a computation of some fixed shape. but for monad, a result earlier on can affect the “shape” of the computation later.
11:45:34 <trigone> davean: i still don't get to which question of mine your cryptic comment answers
11:46:28 <davean> Fine
11:46:40 <trigone> mnoonan_: yes, so if i want to test IO code without executing any IO code, i gotta fake the whole IO type, right? creating an interpreter that tests the program over a fake real world i can thereafter compare, right?
11:47:10 <mnoonan_> trigone: right. except that’s obviously not going to go well :)
11:47:22 <mnoonan_> so instead you just make something more like a DSL
11:47:29 <anna12> can one tell me webpage from where I can download books for free
11:47:37 <jared-w> https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/ trigone is this useful at all?
11:47:42 <mnoonan_> e.g. if you’re going to do file IO, you just have some basic file actions and interpretations for those actions in IO
11:48:22 <mnoonan_> which also has the advantage that your type is telling you more precise information about your computation, instead of just using the big bag-of-side-effects IO type.
11:48:35 <mauke> anna12: what does that have to do with haskell?
11:48:48 <anna12> here are smart ppl
11:48:50 <anna12> :)
11:48:51 <monochrom> The code-to-natural-language ratio of this conversation is too high to be non-cryptic and non-speculative.
11:49:22 <monochrom> Also, by "natural-language" I mean an euphemism for BSing.
11:49:52 <monochrom> Like I already said: <monochrom> I think you should cook up an example use of free monad, and then I can point out where the laziness kicks in.
11:50:21 <monochrom> It's time to move your fingering exercise from IRC to editor. (Or piano is also good.)
11:51:06 <jared-w> http://teh.id.au/posts/2017/07/15/state-machine-testing/index.html this also looked really fascinating to me, trigone 
11:51:14 <minn> How do I derive lenses with user-supplied Alex/Happy types (e.g., AlexUserState)? Alex in particular complains about lexical errors in the source file.
11:51:50 <trigone> monochrom: except i'm still completely confused over how i'm supposed to use the free monad here. just give me the type of the free monadic value i'm supposed to end up with (before interpretation)? is it Free IO () or not?
11:52:02 <glguy> minn: The best way to get help with code and errors is to put them on a pastebin along with your question
11:52:07 <trigone> jared-w: that sounds really intetresting, thanks for those links!
11:52:20 <monochrom> Well you should have explicitly asked for code snippets in the first place.
11:52:36 <jared-w> no problem!
11:52:42 <monochrom> It is not going to be Free IO.
11:52:53 <trigone> mnoonan_: why did you say "its not going to end well"?
11:53:31 <mnoonan_> trigone: well, how much would you want to be paid to make an accurate mock of everything in IO?
11:53:36 <monochrom> Define your own ADT like this: data X r = Get (Char -> r) | Put Char r.
11:53:38 <ertes-w> trigone: (Free IO) is the "delimited IO" monad…  it's like IO, but has "breakpoints"
11:53:45 <monochrom> Then you try Free X ()
11:53:50 <trigone> mnoonan_: i didn't say all of IO, just what i need ^^
11:53:55 <bollu> has anyone seen this?     Not in scope: ‘Debug.trace’
11:54:05 * mnoonan_ is jumping on the monochrom bandwagon
11:54:07 <monochrom> Actually, data X r = Get (Char -> r) | Put Char r deriving Functor.
11:55:03 <ertes-w> trigone: from the interpreter's point of view (Free F) is a monad of F-encoded actions, where each individual action returns "the rest of the program to interpret"
11:55:34 <ertes-w> trigone: now if F = IO, then the individual actions are completely opaque, and the only way to access "the rest of the program" is to perform the IO action
11:55:43 <trigone> ertes-w: breakpoints? like in debuggers?
11:55:44 <lyxia> bollu: there's a module called Debug.Trace
11:55:52 <ertes-w> trigone: pretty much
11:55:55 <bollu> lyxia yes, I want to import it
11:55:59 <bollu> it's not letting me import it
11:56:45 <trigone> ertes-w: hm i see, the free monad is there to make manual the evaluation of the IO actions instead of ending up with one IO action you can only execute all at once
11:56:53 <monochrom> There is a difference between practicing Chess and talking about Chess. You're talking about Chess right now. The best possible outcome is you will be a great spectator the next time a human world champion plays a computer world champion. But you will be unable to play Chess yourself.
11:56:56 <ertes-w> trigone: Free (putStrLn "Hello!" >> pure (Free (putStrLn "Hello again!" >> pure (Pure 15))))
11:57:06 <bollu> lyxia this line: https://github.com/bollu/simplexhc/blob/master/src/IRToLLVM.hs#L3
11:57:16 <trigone> ertes-w: it's like having a list of IO actions and folding it with (>>) exactly as much as you want.
11:57:20 <ertes-w> trigone: the interpreter first sees (Free c), where (c :: IO (Free IO Integer))
11:57:36 <ertes-w> this action will (after printing "Hello!") return the rest of the program
11:57:51 <ertes-w> this program can then be fed into the interpreter recursively
11:58:01 <monochrom> At this point you're like someone who have recently memorized the rules and you are already engaging a conversation on strategies like "control the centre", and you haven't even had the experience of 10 games to actually know what that means.
11:58:17 <mnoonan_> bollu: isn’t it just “trace” or “Debug.Trace.trace"?
11:58:23 <ertes-w> and yes, exactly…  free monads are very similar to free monoids…  they are basically "lists", except that they are more like chains (and can actually be tree-shaped, if your F allows it)
11:58:45 <bollu> mnoonan_ yes
11:58:51 <bollu> mnoonan_ wait what?
11:59:11 <mnoonan_> bollu: you have “Debug.trace"
11:59:14 <trigone> ertes-w: nice :) anyway, as you said and i thought so, it's clearly not what i needed for my current task :) but it's very interesting at any rate. i wonder if there is a breakpoint implementation in say, ghci, that would use that (but then i'm not sure you can rewrite an IO a into Free IO a, even when plunging into the guts of haskell)
11:59:39 <bollu> mnoonan_ yes, because it's a module?
11:59:44 <bollu> mnoonan_ or am I missing simething?
11:59:57 <lyxia> bollu: you wrote Debug.trace with a small t at first, which is confusing.
12:00:08 <bollu> ah, my bad
12:00:14 <bollu> hence me pointing to the source: https://github.com/bollu/simplexhc/blob/master/src/IRToLLVM.hs#L4
12:00:14 <ertes-w> trigone: no (Free IO) is more like breakpoints as an abstraction (non-magical), not as a debugging tool (highly magical)
12:00:35 <mnoonan_> bollu: line 273
12:00:42 <lyxia> bollu: how are you building it? My GHC doesn't say "not in scope" when it can't find a module...
12:01:10 <lyxia> mnoonan_++
12:01:16 <bollu> oh my god, you're right
12:01:22 <bollu> holy shit, what a useless error message xD
12:01:29 <bollu> I should catalogue this in my list of error messages
12:02:14 <trigone> monochrom: actually no, i'm like someone who barely remembers the rule and doesn't even know what i'm supposed to go for, which will make my chess game the equivalent of randomly trying to do stuff and checking if i won somehow...
12:02:52 <lyxia> bollu: but it probably did not point to line 4... did it
12:04:00 <trigone> ertes-w: such a shame... :) but maybe there'd be a way for a program to evaluate a haskell IO do-block, and instead of building an IO a, it'd be building a Free IO a?
12:05:26 <bollu> lyxia it did
12:05:31 <bollu> lyxia hence "what a useless message" :)
12:05:42 <bollu> lyxia worse, I'm not able to repro the error message
12:06:52 <anna12> can one tell me webpage from where I can download books for free
12:06:55 <trigone> monochrom: thanks for the snippets earlier :) i'm not sure i totally understand everything. for example, why is the Put constructor not something like Put Char ()?
12:07:32 <monochrom> The () will appear in Free X ().
12:07:58 <monochrom> But you're supposed to do your own experimentation.
12:08:00 <icassina> anyone familiar with stack and ~/.stack/config.yaml? I'm trying to set 'system-ghc: true' there so that in newly created stack.yaml files (i.e. with stack init or stack new) that option is actually in the project's configuration by default
12:08:01 <trigone> monochrom: hm, but the Put constructor is not supposed to allow arbitrary return type, right?
12:08:35 <bollu> cocreature ping
12:08:36 <trigone> since it's the equivalent of putChar :: IO () , or whaever it's called
12:08:43 <bollu> cocreature is it possible to disable verifyModule in llvm-hs?
12:08:53 <bollu> because it fails at an assert, but I want to see the incorrect IR
12:09:32 <monochrom> You're going to use Free X, not X alone.
12:11:12 <monochrom> Perhaps next time I'll use an art class analogy.
12:11:48 <trigone> monochrom: hm... right, i know that, but if Put Char r is the symbolical/virtual equivalent of putChar, then it'd be like having putChar :: IO r, which is plain weird, since it's not supposed to return anything... right?
12:12:47 <monochrom> "You have started discussions on how van Gogh uses layouts and how Picaso uses colours, and yet you haven't even made a pencil sketch yourself. And you go on to discuss with experts the merits and demerits of perspective projection..."
12:13:56 <Nixenos> hi guyz, i want to start with haskell, which books do you recommend?
12:14:53 <cocreature> bollu: just don’t call it?
12:15:59 <trigone> monochrom: sigh. i understand the sentiment, but in my case, to start coding without knowing what i'm going to do is a bad idea. i forget to take a step back and will take 5 hours trying to make something impossible work, even as in 5 minutes of a priori reflection i could have seen that.
12:16:44 <monochrom> There are many tutorials on free monads on the web. 90% of them actually start with my X under different names.
12:16:54 <erisco> or you will spend 5 hours planning your work and in the first 5 minutes discover the obvious thing you didn't think of
12:17:27 <monochrom> And you are conflating educated planning with speculative planning.
12:17:55 <trigone> erisco: there's a good middle ground...
12:18:37 <monochrom> When a scientist makes a plan, I know that their plan will have payoffs, even if the plan runs into unexpected events.
12:18:51 <dolio> trigone: What is the data type definition of `Free f a`?
12:18:55 <monochrom> When a superstituous person makes a plan, I know that they're better off learning science first.
12:18:55 <bollu> cocreature I'm not calling it, but it looks like moduleLLVMAssembly internally does?
12:18:59 <bollu> cocreature I'm not sure
12:19:15 <bollu> cocreature if I have a pure module (from llvm-hs-pure), can I print the IR even if it is faulty IR?
12:19:39 <trigone> monochrom: so why don't you explain to me why it's not Put Char (), why my intuition is wrong, instead of saying "tutorials do that, just accept it and you'll understand when you're older"
12:20:04 <mnoonan_> trigone: a good middle ground might be to start with making a DSL monad for a specific case or two, then seeing how they can jointly generalize to Free
12:20:07 <monochrom> Because I am not paid?
12:20:07 <dolio> Why don't you go read a tutorial instead of asking monochrom to interactively provide you with a tutorial?
12:20:08 <trigone> dolio: Free f a = Pure a | Free (f (Free f a)), from memory
12:20:10 <bollu> actually maybe it's withModuleFromAST that's running the verifier, I haven't checked.
12:20:26 <dolio> The written tutorial will probably be better. :)
12:20:28 <dolio> (No offense.)
12:20:34 <monochrom> My consultation rate is cdn$4000 per month, minimum spending cdn$4000.
12:20:45 <AndreasK> Is there a fancy way to collect all valid values from a list of MonadPlus/Alternative actions?
12:21:07 <erisco> really? I'll keep that in mind monochrom :P
12:21:09 <cocreature> bollu: I’m pretty sure it doesn’t call verifyModule. https://github.com/llvm-hs/llvm-hs-pretty can sometimes help with printing invalid IR.
12:21:33 <bollu> cocreature oh, ty for the link :)
12:21:40 <lyxia> AndreasK: is that asum
12:22:01 <AndreasK> lyxia: asum collects all values up to the first mzero
12:22:13 <erisco> trigone, is staring at an empty editor and not knowing what to type intimidating? I am not sure why you hesitate to start trying things
12:22:33 <AndreasK> lyxia: Well empty for asum, mzero for msum
12:22:49 <dolio> Also cheaper, apparently.
12:22:53 <lyxia> (to me they're the same)
12:23:04 <monochrom> You are also probably conflating education with rhetorics.
12:23:26 <lyxia> > asum [Just 0, Just 1]
12:23:29 <lambdabot>  Just 0
12:23:33 <monochrom> In a debate I'm obliged to list evidence in support of my claims and answer every question.
12:23:43 <monochrom> But this is not a debate.
12:23:47 <sm> @remember FAQ What are some good books for learning haskell ? Haskell Tutorial And Cookbook (HTAC), Programming In Haskell (PIH), Programming In Haskell (PIH)
12:23:47 <lambdabot> Done.
12:24:02 <sm> Nixenos: ^^
12:24:11 <lyxia> AndreasK: Do you want  [Just 0,Nothing,Just 1]  to map to  Just [0,1]
12:24:12 <monochrom> In learning you are obliged to make discoveries. The teach is not obliged to give out the solution.
12:24:19 <sm> ack
12:24:39 <lyxia> AndreasK: [Nothing]  to  Just []  ?
12:24:54 <AndreasK> lyxia: Yes (Not with Maybe but thats the idea)
12:24:55 <trigone> ok nevermind. you could all just have said "you're asking too many questions." i mean this IRC is at least half composed of people asking questions and others answering. sure, i ended up with asking a great many open-ended questions. if nobody wants to answer me, no problem, but since i don't force anyone i don't think it's fair you end up telling me i try to exploit you or force you to teach me or something.
12:25:26 <AndreasK> lyxia: Just seemed like something there would already be a function for somewhere
12:25:37 <nshepperd_> trigone: notice that Put Char r is equivalent to Put Char (() -> r)
12:25:43 <sm> @quote FAQ some good books
12:25:43 <lambdabot> FAQ says: What are some good books for learning haskell ? Haskell Tutorial And Cookbook (HTAC), Programming In Haskell (PIH), Haskell Programming From First Principles (HPFFP)
12:26:33 <lyxia> AndreasK: doesn't look like anything to me
12:26:41 <nshepperd_> trigone: compare to the definition of Get (which is supposed to return a Char)
12:27:38 <monochrom> No, you are conflating empty Q&A with Socratic Q&A.
12:28:09 <monochrom> I refuse to do empty Q&A but it does not mean I refuse to do all kinds of Q&A.
12:28:09 <erisco> trigone, I don't know what your original problem is. I am just curious about the motivations...
12:28:23 <monochrom> I do Socratic Q&A but you won't participate.
12:28:46 <erisco> trigone, is it that you originally had a problem which you felt you understood well but now are being guided into territory you are not comfortable with?
12:28:57 <minn> I'm having some trouble using the lens library with Alex. The same problem occurs when I run Alex independently. Am I doing something wrong? This is the core of my problem: http://lpaste.net/357200
12:29:22 <monochrom> Once again I already made my offer "you code up an example, then I'll point out where laziness kicks in". It's a free offer and no one took it.
12:29:43 <trigone> nshepperd_: hm... actually i don't get it, sorry. but i keep trying :) just tell me, how is the function in Get supposed to be used at interpretation time?
12:29:47 <dolio> The original question was "how do I check properties of IO?"
12:29:53 <erisco> trigone, I experience that often when I have an idea that seems clear but after explaining it to others I am referred to theories that I do not understand
12:30:27 <erisco> trigone, and it seems dissonant to have a clear idea in my head and yet accept that this confusing theory is actually what I need to know instead
12:30:44 <mnoonan_> trigone: I’m happy to work through it with you, if you want to start without Free by directly making a GetChar / PutChar DSL
12:30:57 <trigone> erisco: my original problem was: how to test too-heavily IO code without, well having to built actual files, and so on (which i did but although not too complex it would require itself a bit of testing, and that becomes a loop :P)
12:31:16 <dolio> What I'm not sure has been adequately conveyed is that the answer being presented is: "you should not be trying to check properties of IO at all."
12:31:42 <dolio> You should not try to model IO with a free monad, you should try to model the logical structure of your program, and test things about it.
12:32:27 <trigone> dolio: really? so far i thought were were trying to build an abstract VirtualIO that could either be transformed into IO, or that could be used in pure code to simulate reliably what would happen if the code was real IO
12:32:28 <dolio> The logical structure will be interpreted into IO things, but you don't have to mimic exactly what the IO will do.
12:33:20 <trigone> dolio: i see... maybe...
12:33:20 <dolio> I mean, it's a little unclear, because you never said what about IO you wanted to test.
12:33:42 <erisco> trigone, ah, and I bet the suggestion was to construct some sort of eDSL which is interpreted to do the IO actions
12:34:24 <dolio> But presumably it's not something like, "writing 'hi' to a file results in a file with 'hi' in it."
12:34:45 <nshepperd_> In most cases the correct engineering answer is to make your code less IO infested :)
12:35:03 <nshepperd_> Separate the business logic from the IO
12:35:13 <trigone> IO operations: read a block of two files, test them one against the other, write on the block, possibly continue. theoretically i can have a pure function here for each block, but i'd still prefer having the certainty that comes with trying the whole program and checking the final result...
12:35:22 <whoman> correct meta-engineering answer is to make your code someone else's code
12:35:26 <erisco> trigone, it is easy to get started with eDSLs because you can make them arbitrarily simple :)
12:35:27 <trigone> erisco: well yeah, is that such a bad idea?
12:35:37 <nshepperd_> whoman: hah!
12:35:39 <erisco> no, it is exactly what I would have said, heh
12:35:48 <trigone> erisco: ok ^^
12:35:49 <ongy> nshepperd_: want to help me with that? :) (I hate that suggestion, but I mostly do IO heavy stuff...)
12:35:57 <trigone> what's the e in eDSL?
12:36:07 <erisco> embedded, i.e. a language in a language
12:36:20 <trigone> ok thk :)
12:36:49 <erisco> there is another way, and this is usually done, is to have an interface which you instantiate with either the real version or the fake version
12:37:24 <trigone> erisco: yeah, i saw that in jared-w's link, monad-mock https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/
12:38:08 <erisco> what I have done in real applications is simply gather all the IO stuff we do in a list and make that an interface
12:38:27 <trigone> a list as in a haskell list?
12:38:44 <erisco> it isn't that sophisticated but I found in the applications I worked on the interface remained small
12:39:10 <nshepperd_> If you're just doing operations on local files it might be easier to just build an integration test that runs the program in a sandbox (like a shell script or whatever)
12:39:18 <erisco> no, just conceptually a list of all the high level IO actions we had to do
12:39:31 <nshepperd_> Rather than fiddling with mock virtual filesystems
12:39:38 <trigone> erisco: hm yeah :) and you used typeclasses then?
12:39:39 <erisco> like "upload a file" and "save this to disk" and "delete this record" and so on
12:40:09 <monochrom> ReinH had a [Delete 'foo.txt', Create 'bar.txt' contents, etc] example in the beginning.
12:40:22 <trigone> nshepperd_: well i'd do that if i knew how to use sandboxes... at my level i think it's easier to create an eDSL than to learn how sandboxes in stack/whatever work...
12:40:38 <monochrom> Free monads came up only because eventually you may need dependent effects.
12:40:44 <nshepperd_> Ah, by sandbox i just mean a temporary folder
12:40:58 <nshepperd_> Nothing to do with cabal sandboxes
12:41:10 <erisco> trigone, I only wish to use Haskell professionally :P but an equivalent might be type classes if you use conditional compilation to select instances
12:41:56 <erisco> otherwise you can make it a record (a data type) and pass it around... say with Reader
12:42:17 <trigone> nshepperd_: hm well i did that already... but it's a bit... dunno
12:42:33 <erisco> I am noticing Haskell programs tend to have their master Monad type which contains all these bits and bobs
12:42:37 <trigone> erisco: i didn't get what you meant with "only wish to use ..."
12:42:59 <dolio> trigone: Personally, for an example like that, I'd probably suggest getting comfortable with not interleaving the IO part with the 'compare blocks' part, and expecting to test the whole mess. But that's just me.
12:43:14 <erisco> trigone, I haven't written software professionally with Haskell, so no, I have not used type classes for this, but it should be possible with conditional compilation to select instances
12:44:12 <bollu> do I get a cookie for using RankNTypes practically my first time in haskell-life? :)
12:44:14 <monochrom> No, don't use conditional compilation, use multiple parameter type class to select instances.
12:44:14 <erisco> the eDSL solution is possibly more effort but much more robust
12:44:39 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html
12:44:51 <trigone> dolio: yeah... but even if the pure code works, the IO code, although simple, will remain mostly untested, and therefore, i'll only know my program works exactly as i want in an indirect way... but maybe i'm just a bit paranoid...
12:46:17 <erisco> monochrom, that is probably a better idea. maybe depends on how much you love build systems :P
12:46:30 <MichaelBurge> Is there a sort function that allows you to specify a swap function?
12:46:41 <monochrom> Oh actually I think the best is to combine both.
12:46:57 <trigone> monochrom: how so?
12:48:27 <mnoonan_> trigone: look at this for step 1 of getting to free monads: https://repl.it/JiE6/0
12:49:03 <monochrom> Heh "we hate modals too".
12:49:48 <erisco> I hate IRC messages
12:51:01 <monochrom> MichaelBurge: What would your swap function do?
12:51:08 <erisco> that'll be the new meme Microsoft uses to spam my desktop... "We hate ads too, but try out our new Internet Explorer!"
12:51:44 <erisco> we can relate because we both hate what you are doing, aw
12:51:52 <MichaelBurge> monochrom: Suppose you have a disassembly, where instructions have labeled. When simplifying, you may reorder instructions. However, labels should remain the same.
12:52:13 <MichaelBurge> monochrom: So swapping two instructions should swap the operands, but not the associated labels.
12:52:52 <trigone> mnoonan_: thanks a lot! i understand better the MyIO content, it's built on recursion
12:53:03 <monochrom> Then I don't know how to do it.
12:53:30 <erisco> MichaelBurge, what I don't understand is then why instructions and labels are not part of the same object you are sorting
12:53:53 <trigone> mnoonan_: this recursive pattern does look a lot like a free monad (with Return being akin to Pure etc), but then i'm wondering when exactly i'd end up adding the free monad?
12:54:17 <mnoonan_> trigone: if you do this monad dsl thing a few times like in my example, you find that you’re just writing the same boilerplate over and over
12:54:25 <mnoonan_> Free just abstracts the boilerplate
12:55:03 <trigone> mnoonan_: hm i see... i'll try abstracting the Free monad then. thanks again :)
12:55:32 <mnoonan_> no problem.. it’s a rainy day off for me here :)
12:55:33 <erisco> MichaelBurge, you have a list of objects and you sort them. The algorithm may not even involve swaps. So can you provide more detail on what you mean other than sorting a list of objects?
12:57:28 <trigone> mnoonan_: :)
12:58:49 <davr0s> https://www.tweag.io/posts/2017-03-13-linear-types.html thoughts on this ... ETA, capabilities
12:59:03 <MichaelBurge> erisco: It's okay to constrain the algorithm to require a 'Swappable' constraint, and for its output to be equivalent to e.g. Bubblesort that uses the given swap.
12:59:41 <erisco> okay, so there are a lot of pieces to this suddenly
12:59:43 <trigone> ok, tell me if i'm wrong: from Put Char (MyIO t) you end up with (Put Char t) precisely because the t will be using in the free monad, replaced by (Free MyIO t2) in Free (MyIO (Free MyIO t2)), right?
13:00:10 <dolio> trigone: Yes.
13:00:49 <trigone> dolio: thx :) it's pretty neat
13:01:33 <erisco> MichaelBurge, let me step back for a moment... what are the objects you are sorting?
13:02:21 <trigone> labelling question: how would you name the non-recursive MyIO type, and how would you name the type Free MyIO t (if you needed a synonym; it's not really necessary but it could be nice nonetheless i guess)
13:02:44 <MichaelBurge> erisco: They are annotated statements in a syntax tree, with rules for maintaining the annotations when reordered.
13:03:10 <ReinH> trigone: One common pattern is to name the generating functor FooF for the free Foo monad.
13:03:16 <MichaelBurge> erisco: Don't worry about it too much. I'll just write e.g. Bubblesort like I described for now. Was just wondering if there was something off-the-shelf
13:03:18 <ReinH> Look at the examples in the free package, for instance.
13:03:20 <monochrom> Base functor and the free monad induced/obtained/whatever from the base functor.
13:03:50 <erisco> MichaelBurge, okay, just I am having a difficult time understanding you. If you said the objects were integers then I would understand
13:03:51 <trigone> ReinH: so 'd end up with Free MyIOF t ?
13:04:08 <trigone> oh no wait, the free Foo monad
13:04:11 <ReinH> type MyIO = Free MyIOF, yeah.
13:04:14 <erisco> MichaelBurge, or if you said the objects were labeled statements, then I'd understand, but I do not understand the whole of what you described
13:04:34 <ReinH> trigone: Again, check out the free examples, particularly the teletype machine.
13:04:48 <trigone> ReinH: ok, got it. :) teletype? what's that?
13:04:54 <erisco> MichaelBurge, the point of sorting is you have some domain of objects, such as the natural numbers, and some ordering relation on them, and the goal is to find the list such that yadda yadda...
13:04:59 <ReinH> A machine that reads and prints stuff to a screen.
13:05:27 <erisco> MichaelBurge, so to establish your problem as a sorting problem you should be able to describe it in those terms
13:05:38 <trigone> oh you mean some tutorials implement a virtual teletype using the free monad?
13:06:00 <erisco> if there are extra pieces to it then you have not distilled it to a sorting problem yet, but maybe one is hiding if you can simplify something else first
13:06:31 <trigone> can you speak of "the free monad" when arguably there are as many as there are functors? at least i think so. are there any restrictions on what functor can be used to build a monad Free f?
13:06:44 <trigone> (when i said can you speak i meant can anyone speak)
13:07:29 <MichaelBurge> erisco: It's not a classic sorting problem, since the resulting list could contain completely new objects, none of which were in the old list.
13:07:33 <ReinH> The list is the free monoid (almost), but there are many types of list.
13:07:42 <ReinH> There is one free monad, but many types of free monad.
13:07:44 * hackagebot propellor 4.5.1 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
13:07:58 <MichaelBurge> erisco: For an example, consider sorting [(Int, Int)], where the first Int is the 'offset' and the second Int is the 'original offset'.
13:08:19 <trigone> ReinH: i see... i think
13:08:33 <erisco> MichaelBurge, offsets from what?
13:09:00 <MichaelBurge> erisco: From 0. They are an ordering on the list. But you also want to remember the original order of the list
13:09:27 <erisco> but you have the original list
13:09:45 <ReinH> Free f a is a family of monads indexed by f
13:09:59 <ReinH> [a] is a family of lists indexed by a
13:10:42 <erisco> > (\x -> (x, sort x)) [2,1,3]  -- if I may be so simplistic
13:10:44 <lambdabot>  ([2,1,3],[1,2,3])
13:11:50 <trigone> can you use the symbol single quote with types and type variables too?
13:12:30 <monochrom> MichaelBurge: How do you feel about: unzip, sort the 2nd list, zip.
13:12:45 <trigone> ReinH: hm... so Free itself is sort of a monad constructor, right? with functor constraint on its parameter ofc
13:13:22 <trigone> > let f :: t -> t'; f a = undefined
13:13:25 <lambdabot>  <no location info>: error:
13:13:25 <lambdabot>      not an expression: ‘let f :: t -> t'; f a = undefined’
13:13:44 <trigone> > let f :: Int -> t'; f 0 = undefined
13:13:46 <lambdabot>  <no location info>: error:
13:13:46 <lambdabot>      not an expression: ‘let f :: Int -> t'; f 0 = undefined’
13:13:54 <trigone> > let f :: Int -> t'; f 0 = undefined in f 0
13:13:57 <lambdabot>  *Exception: Prelude.undefined
13:18:20 <mnoonan_> ReinH: that’s sort of a nonstandard way to phrase it, isn’t it? e.g. you don’t talk about “the free group” (usually), but rather “the free group on X” for some set X
13:18:49 <mnoonan_> “the free monad over the functor F” is more in line with that
13:18:49 <trigone> when using an eDSL as the functor for Free f, i don't need to write an applicative and monad instance for f, do i? cuz i'm wondering what i'm supposed to put for pure/return, since i ejected the Return constructor when i transformed the eDSL to use the Free Monad's recursion.
13:19:25 <mnoonan_> trigone: right, that’s all handled by the Free construction already.
13:19:49 <trigone> mnoonan_: i agree. i think what's lacking is to name the technology of using the abstraction of the/a free monad.
13:20:22 <trigone> mnoonan_: k thx
13:21:36 * hackagebot stratosphere 0.7.0 – EDSL for AWS CloudFormation – https://hackage.haskell.org/package/stratosphere
13:25:47 <trigone> mnoonan_: from myGetChar = GetChar Return, should i write myGetChar = Free $ GetChar Pure?
13:27:00 * hackagebot network-transport 0.5.2 – Network abstraction layer – https://hackage.haskell.org/package/network-transport
13:27:22 <monochrom> Yes.
13:27:29 <monochrom> Does it type-check?
13:28:23 <trigone> monochrom: i'm in the middle of modifying the code, so i have yet to test the part already written. but yeah i should try
13:29:11 <monochrom> I think you can just go to the ghci prompt and ask "@type Free $ GetChar Pure"
13:30:56 <trigone> monochrom: well yeah but i have to comment out the rest of the not-yet-modified code first (which i just did). i'm working with mnoonan_'s code, changing it to include the use of Free
13:31:12 <monochrom> Ah true
13:31:32 <erisco> trigone, yeah, we all have to deal with that :)
13:32:29 <trigone> erisco: such a shame there's no syntax to say "rest of document is comment". that'd already be much simpler :) at least there are block comments so not everything is lost
13:32:43 <erisco> most of my programs in progress look like code mangroves in a sea of comments
13:33:16 <erisco> don't say that or you'll get all the vim and emacs people talking about their keystrokes
13:34:53 <dedgrant> This is where I hope eventually a notion of semantic views work out, things like lighttable demonstrated early on that cross-cut some simple notion of code under observation.
13:35:25 <trigone> erisco: well i do use vim, though relatively close to the vanilla version (cuz so far i haven't taken the time to learn more vim extensions)
13:36:08 <trigone> dedgrant: you mean dynamic GHC analysis of the code included in the editor?
13:36:32 <trigone> how can i set the editor in ghci in a permanent way?
13:37:33 <trigone> and does it expect one name of one program or potentially a whole command with options, etc?
13:37:56 <dedgrant> I guess analysis, insofar as it means complrehension of dependencies, for some notion of dependencies? :O It is a generally difficult problem. Gets easier the more constrained the domain is ofc.
13:40:43 <dedgrant> trigone, one approach is to create a .ghci file to persist options.
13:41:41 <trigone> dedgrant: where would i put it? at any rate for my question, apparently it can be tied to having a $EDITOR variable set, which i thought i had, but didn't
13:41:50 <dedgrant> https://downloads.haskell.org/~ghc/8.2.1-rc3/docs/html/users_guide/ghci.html#the-ghci-files
13:42:12 <trigone> dedgrant: cool thx
13:42:14 <joelnc> Hi there. Would anyone be willing to help this newbie with the State monad? I'm struggling with  a very specific use case: type checking an AST. 
13:42:49 <erisco> I know I have it bookmarked but I cannot remember the name now... a functional PL (inspired by Haskell) with an IDE that featured projective editing, and I think real time evaluation
13:43:11 <erisco> their nick starts with a capital "P" I think...
13:43:23 <dedgrant> projective editing.. that's an interesting phrase
13:43:37 <[exa]> joelnc: actually quite reasonable usage. What's the problem
13:43:56 <erisco> dedgrant, long story short is you edit ASTs instead of text
13:44:11 <joelnc> exa: is there any way for me to send you direct messages?  to avoid spamming this chat
13:44:42 <dedgrant> Rings a bell. I think I caught a video demonstration of something like that on youtube last year.
13:44:47 <[exa]> please pastebin instead of spamming, and well this also lets other help you
13:45:19 <davr0s> does anyone here use idris, what is it like?
13:45:42 <trigone> erisco: what's projective editing?
13:46:07 <erisco> dedgrant, sure, people have been working on it... such as JetBrain's MPS but that's a somewhat strange realm at the moment
13:46:34 <erisco> it is the intersection of all things PL from syntax to assembly
13:46:51 <kadoban> I'm hoping projective editing means that thing in movies where it's a hologram that you control by waving your arms about like a psycho.
13:47:22 <erisco> trigone, see "long story short" I sent to dedgrant
13:47:25 <[exa]> debugging by pinch on screen? finally?
13:47:31 <akfp> Which parser / lexer library supports tokenization from large dictionaries - parsing through something like a trie that they compile to?
13:47:49 <glguy> davr0s: There's a whole channel for discussing Idris. This one's for Haskell
13:48:02 <skiddieproof> Is there a github for lambdabot?
13:48:05 <byorgey> erisco: Perhaps you're thinking of Peaker?  I can't recall the name of their project
13:48:16 <erisco> byorgey, yes, Peaker, thanks
13:48:43 <skiddieproof> *(is it lambdabot or lambdadot?)
13:48:58 <joelnc> @exa: I have more of a higher level question rather than broken code. I have an AST that I'm trying to type check. I want to express some form of tree traversal such that the return value for each node is a type check result (OK or Error), together with some type checking context derived from the subtree rooted at that node
13:49:33 <geekosaur> https://github.com/lambdabot/ (multiple repos)
13:49:41 <[exa]> joelnc: there's actually brilliant reading on that topic, with an example and so
13:49:50 <byorgey> joelnc: sounds reasonable.  I don't see how the state monad would help you with that.
13:50:01 <[exa]> joelnc: https://web.cecs.pdx.edu/~mpj/thih/thih.pdf THIH
13:50:06 <joelnc> @exa I would like to somehow propagate the context and errors from lower level nodes to higher level nodes
13:50:06 <lambdabot> Maybe you meant: vera eval
13:51:01 <joelnc> thanks for the link, ill take a look
13:51:09 <trigone> joelnc: the @ is used to do command stuff. just use the name of people without @ and they'll be pinged
13:51:18 <[exa]> joelnc: THIH uses the type inference monad (see section 10) to store the state of "current substitution" (basically the same as the substitution in hindley-milner systems which I guess you're implementing)
13:51:22 <trigone> you have autocompletion on tabs
13:51:29 <trigone> i mean using the tab key
13:51:38 <joelnc> trigone: thanks
13:51:42 <[exa]> yeah @ is for twitterds
13:51:44 <[exa]> :D
13:51:59 <trigone> [exa]: lol
13:52:06 <joelnc> exa: haha i'm an all-around newbie (IRC and haskell)
13:52:12 <erisco> like 2D programming languages I think it is a fad, i.e. something most people will try and fall out of
13:52:23 <trigone> [exa]: did you add brackets to avoid being pinged? cuz it's slightly harder :)
13:52:52 <erisco> it has plenty of benefits but none seem significant enough to move people away from editing text
13:52:54 <trigone> erisco: 2d? well it's already 2d, otherwise we'd only write on one single line...
13:52:54 <byorgey> joelnc: what do you mean by "type checking context derived from the subtree"?  What kind of information will be in the type checking context?
13:53:02 <[exa]> trigone: no, it looked cool when I was playing quake3 and someone has already registered bracket-less exa
13:53:14 <[exa]> *tada* here I am
13:53:19 <trigone> [exa]: ok ^^
13:53:35 <erisco> trigone, that is deceptive :) your editor is merely rendering \n or \r\n a particular way. In fact, your editor is a projectional editor of text :P
13:53:59 <trigone> erisco: everything on disk is linear, so technically...
13:54:16 <[exa]> trigone: good that you pointed that out though; I just discovered that irssi can autocomplete "ex" to [exa] even without the bracket
13:54:40 <trigone> [exa]: well with me i end up with exferenceBot 
13:54:47 <joelnc> byorgey: by context I mean facts and requirements derived from that subtree (fact: class C has a constructor taking (int, int); requirement: class D must have a field of type double)
13:54:48 <erisco> trigone, haha, well, I suppose a text editor does let you assume some 2-dimensionality
13:55:17 <trigone> erisco: so, what would be a "really fakely 2d text file/editor" then?
13:55:45 <[exa]> joelnc: you can implicitly store context in the "current substitution" and only return the actual type of the expression. "Context" in this form is called "Assumptions" in THIH
13:55:48 <byorgey> joelnc: OK, got it, makes sense.  In that case yes, I think the thing [exa] linked will be a useful reference
13:55:54 <joelnc> byorgey: conceptually,the result of the type check is either OK or Error, but that ontext gets carried around
13:55:56 <erisco> trigone, the linearity I refer to is mostly seen in the left-to-right and top-to-bottom reading
13:56:31 <joelnc> byorgey: and I also want errors to be propagated upwards without manually checking every time: if error then return error, else ...
13:56:39 <trigone> erisco: er... and you'd like two dimensions even for one line of text? and two dimensions across the whole document? that'd make 4d wouldn't it?
13:56:41 <erisco> trigone, this does not apply between definitions with languages that have multi pass compilers (or whatever fancy n decades old tech)
13:56:41 <trigone> ^^
13:57:25 <erisco> if you look at a 2D programming language it does not have nearly the same rigor in left-to-right or top-to-bottom
13:57:25 <[exa]> joelnc: THIH uses monadic fail for errors (which is roughly an exception thrown) but I suggest you'd try to use MonadFail which gives a bit more flexibility
13:57:34 <erisco> rather you are following lines about the place
13:58:10 <trigone> erisco: oh i understand
13:58:48 <trigone> erisco: well at this rate, better have a non-dimensional space where you can put things and link them together in all directions (basically, a mind map or somethingq
13:58:49 <joelnc> exa: thanks, I haven't come across MonadFail so far. I'll take a look
13:59:03 <[exa]> joelnc: aaaaaaaaaand a suggestion --- in fact, if you're writing a compiler, you _don't_ want to terminate on the first error (because the programmers like a complete list of problems)
13:59:56 <erisco> well that's the kind of editors people have been experimenting with... you still have your left-to-right and top-to-bottom text but only within a definition, since that is the only place it matters nowadays
13:59:59 <joelnc> exa: yes, indeed, but I was already struggling with the fail on error strategy so I was leaving that for later :p
14:00:23 <erisco> you could imagine even breaking the linearity of let/in expressions and where blocks in Haskell
14:00:49 <[exa]> joelnc: usually it's best as with parsing errors; if there's an error, try to fix it just so that you can continue, and add it to the list (and fail before next step)
14:01:12 <trigone> erisco: yeah, i thought about that too. i think it could rise powerfully, but i'm not sure people will have the right ideas and will make the right implementations...
14:01:13 <[exa]> joelnc: what language are you checking anyway?
14:01:58 <trigone> erisco: and it more or less requires additional step to transform non-linear text into something that existing compilers can chew
14:02:19 <joelnc> exa: a small, toy OOP language. investigating into doing a type check in a 100% bottom-up manner 
14:02:49 <erisco> I think the problem is that not enough people care about it... like I said, it is certainly a problem but the magnitude of the problem is questionable
14:03:05 <erisco> I know about it and I am still editing text and not really thinking about it :P
14:03:19 <joelnc> exa: as in, no class table, no information passed downwards in the tree
14:03:47 <erisco> one of those situations where the cure is worse than the disease
14:04:18 <jaseemabid> I've a State + Error transformer stack. How can I run a stateful computation within another stateful computation with localized state? I dont want the inner computation to be able to modify the state of the outer computation.  
14:05:18 * hackagebot hledger-diff 0.2.0.10 – Compares the transactions in two ledger files. – https://hackage.haskell.org/package/hledger-diff
14:05:34 <jaseemabid> I want something like `withState`, but localized. I could use a get to get old state, run the computation and restore it later with a put; but I'm looking for a more idiomatic approach if any. 
14:05:38 <[exa]> joelnc: that sounds cool then. Maybe you'll have trouble with overloading, but nothing fatal
14:06:40 <trigone> erisco: yet maybe it's the kind of thing you get used to but once you try the solution you can never come back. tons of people out there are happy coding in OO languages, but personally it was already a chore before haskell, and now it's even worse ^^
14:07:24 <joelnc> exa: yeah, the idea is to start with a toy language and eventually add more and more features till a 100% bottom-up type checker looks feasible for a full blown OP language
14:08:13 <erisco> jaseemabid, maybe something such as  get >>= lift . runStateT e   where e is your local expression?
14:08:50 <[exa]> joelnc: if you'd go theoretical, there's a paper called 'overloading is np-hard' somewhere
14:09:15 <trigone> has nobody tried gathering the results of hayoo and hoogle? they're complementary in a weird way (sometimes one has functions the other knows not)
14:09:24 <[exa]> joelnc: https://link.springer.com/chapter/10.1007/978-3-642-29485-3_13 this one. It gives a nice view of the boundary
14:09:37 <trigone> what's an OP language?
14:09:49 <joelnc> trigone: I mean't OOP
14:09:57 <joelnc> trigone: but probably OO language makes more sense
14:10:22 <joelnc> exa: that looks encouraging xD
14:10:25 <trigone> joelnc: why do you try making an OO language?
14:10:41 <trigone> just by curiosity
14:10:52 <[exa]> objects are cool
14:11:02 <[exa]> easily tangible
14:11:13 <erisco> [exa], I had a Microsoft engineer inform me that overloading is equivalent to boolean satisfiability and thus that is why they couldn't accept my feature request for TypeScript =\
14:11:19 <joelnc> trigone: it's not about the OO language, anyway. it's about the type checker
14:11:26 <[exa]> erisco: lol, seriously
14:11:37 <trigone> joelnc: yeah, my question was off-topi
14:12:53 <[exa]> erisco: (typescript doesn't do overloading?!)
14:13:38 <erisco> it does but it is restricted in various ways. I was suggesting to strengthen the inference because the weakness was requiring too many annotations for my functional code
14:14:10 <trigone> [exa]: i guess if one does not try making everything an object unduely... it's usually the big issue, esp with languages that barely allow you to create anything outside of classes. ofc, that's slightly another story with smalltalk/js prototype OO. although i admit i never coded in smalltalk, dunno if you can make non-method functions
14:14:47 <trigone> typescript is a js metadialect?
14:15:18 <erisco> it is a superlanguage... javascript with types as the name implies
14:15:47 <[exa]> joelnc: well the moral of the paper is that the actual restrictions that make overloading NP-C are not very hard to satisfy (except for Haskell)
14:16:13 <erisco> though honestly I have seen better concepts from our locals such as Inferno ... obviously not to the spit and polish of TypeScript but they've got a whole team
14:16:36 <erisco> Inferno is made by... sinelaw iirc
14:16:53 <[exa]> trigone: I never coded in any "object" language as well (I don't count C++ because that's portable assembly on steroids)
14:17:49 <erisco> well, I have programmed in OO, and either I am ignorant or there just isn't all that much to talk about in comparison to what we have here
14:18:19 <trigone> erisco: don't ask that to OO defenders
14:18:42 <[exa]> trigone: but the point is that objects are simple to grasp, they have boundaries and so, and modelling after their behavior is quite beneficial for having well-arranged programs. Until it stands in the way of execution pipeline and simplicity.
14:18:52 <joelnc> exa: regarding how to write this on haskell. if I had a function typeCheck :: ASTNode -> XX, what would XX be? something like Monad TI ?
14:19:48 <joelnc> exa: I currently have something like: ASTNode -> State TypeCheckContext TypeCheckResult
14:19:58 <[exa]> joelnc: yeah, that's it
14:21:03 <trigone> [exa]: i think objects get shitty from the moment you try using classes. otherwise they're mostly record syntax anyway. and, i'm not sure how prototype OO works in immutable situations...
14:21:04 <erisco> based on the classes I have had the whole thing is more about a method of solving problems, i.e. a way to think about things
14:21:28 <erisco> which is why, for example, they have design patterns as a meta concept rather than as part of the language
14:21:43 <joelnc> exa: but i consistently need to do: if (recursive call returned type check error) return error else continue typechecking
14:21:47 <[exa]> trigone: and well, imagining that functions are objects is the weird case. Same as doing ontologies of stuff (observe that all oop languages that gone terribly wrong try to pretend that there are ontologies)
14:21:54 <trigone> erisco: which makes it terribly hard to grasp and define
14:22:28 <trigone> what's the def on an ontology in your context?
14:23:08 <[exa]> trigone: hierarchy maybe
14:23:23 <erisco> what I like about FP is that the abstract concepts get turned into actual things
14:23:26 <[exa]> joelnc: how do you recognize an error from TypeCheckResult?
14:23:29 <trigone> but yeah, functions as objects is their way to implement functions as first-class values, more or less... it does is weird. you end up with a notion of object that just means "data and functions you can only call on that type".
14:23:59 <trigone> [exa]: you mean hierarchies of classes, etc?
14:24:01 <erisco> there is lots floating about in the conceptual space still and always will be, but the goal seems to be to get the abstraction itself into the language as a thing
14:24:03 <EvanR> twist ending, actual things are abstract
14:24:04 <[exa]> trigone: yep
14:24:09 <[exa]> EvanR: +1
14:24:12 <trigone> erisco: FP is magic
14:24:40 <erisco> EvanR, shh I have only read part way!
14:24:43 <jaseemabid> @erisco. I don't completely get it. Here is a sample snippet. http://lpaste.net/357201 The last function doesn't compile. Can you please take a look?
14:24:43 <lambdabot> Unknown command, try @list
14:24:52 <jaseemabid> erisco, I don't completely get it. Here is a sample snippet. http://lpaste.net/357201 The last function doesn't compile. Can you please take a look?
14:25:06 <trigone> what do you mean by actual things are abstract?
14:25:54 <jaseemabid> erisco, I'm having trouble wrapping the value back into the Monad transformer stack.
14:25:56 <[exa]> joelnc: you can handle the errors with simple if's. do   result <- recursiveCall  ;  if isError result then return Error "recirsively failed" else do ....
14:25:57 <EvanR> what do i mean by abstract
14:26:03 <erisco> jaseemabid, I am looking
14:26:46 <erisco> jaseemabid, are you writing a text adventure game set in Middle Earth?
14:26:46 <[exa]> joelnc: second possibility is to make your own monad that can handle the errors itself (saves you lots of ifs in the code), simplest such example is the Maybe or Either monad
14:27:32 <jaseemabid> erisco, ha ha. No. I'm working on a toy compiler. The name? :)
14:27:43 <[exa]> runOlifant  -->  omg everyone runnn
14:28:24 <joelnc> exa: yeah, exactly what I'm after. after going through LYAH I got the idea that for a series of computations of a maybe, you don"t need to check if it's Nothing every time. the monad handles that for you
14:28:51 <joelnc> exa: i was just wondering if I need to write my own monad to get the same
14:28:57 <erisco> jaseemabid, I don't think you followed what I suggested too carefully
14:29:02 <EvanR> trigone: feynmann inside-of-a-brick-theory... dijkstra "purpose of abstraction" quote
14:29:28 <joelnc> exa: or if this is easily expressible with existing, standard monads (either + state or something of sorts)
14:29:46 <trigone> jaseemabid: first, to simplify, you have (r <- return $ x), and that's equivalent to (let r = x). at any rate, the error is apparently, r in (return $ r) is type Except Error a, and you want to return an a as per your function signature
14:29:47 <[exa]> joelnc: there's some possibility in auto-composing the monads using transformers (see e.g. StateT, no idea if there's MaybeT)
14:30:23 <priewienv> Or?
14:30:36 <trigone> jaseemabid: somehow you gotta transform your (r :: Except Error a) into (sth :: a)
14:30:47 <trigone> before returning it
14:32:16 <trigone> but yeah lol seriously what's the meaning of "Olifant"?
14:32:37 <EvanR> [exa]: yeah there is a MaybeT
14:32:39 <[exa]> joelnc: anyway, if you want the error to terminate the compilation and give some info, I wildly guess: EitherT (State TypeCheckerState) Result
14:32:40 <erisco> they are the not elephants from Middle Earth
14:32:40 <jaseemabid> trigone, Its a fancy looking horn. There is a wikipedia page :P 
14:33:20 <joelnc> exa: thanks, it looks like MaybeT exists. i really have no idea how monad combination/transformation works, so I guess i need to learn a bit more about that before moving forward
14:33:25 <jaseemabid> erisco, I'm looking at the sample code you first send me. Let me try to digest this 
14:33:25 <[exa]> great
14:33:49 <joelnc> exa: thanks ill try out that guess then
14:34:50 <EvanR> transformers are kind of OK as a backend implementation of a custom monad, but using them directly for things is like... blech
14:35:12 <trigone> EvanR: you mean it's better hiding them with type synonyms and newtypes?
14:35:24 <[exa]> joelnc: transformers are pretty straightforward -- monads have one type parameter for what they 'return', monad transformers are 'monads in monads' -- first type parameter is the name of the contained monad, second is the return type (that gets fed to the contained monad internally)
14:35:30 <EvanR> not just hiding them, but providing a nice interface to your monad
14:36:07 <EvanR> get put ask tell are like... low level assembly language, painful for anything but the simplest tasks
14:36:35 <trigone> EvanR: true
14:36:51 <jaseemabid> erisco, The type signature is a bit too generic and cryptic. I'm trying to make it concrete to clarify things. 
14:36:59 <[exa]> EvanR: actually not that blech structurally IMO, but lifting all the code to the correct level sucks
14:37:05 <joelnc> exa: thanks for the intro. damn, getting fluent in haskell is a bitch :p 
14:37:11 <EvanR> pretty blech
14:37:19 <joelnc> exa: thanks for all your help dude/gal!
14:37:25 <erisco> what about Monad m => StateT s m a -> StateT s m (a, s) is there not to understand? ;)
14:37:33 <[exa]> joelnc: welcome :D
14:37:34 <trigone> jaseemabid: did you read what i said earlier about your code?
14:37:45 <joelnc> exa: very appreciated
14:38:08 <erisco> just look at the parts of the term individually and from that you can probably figure out what it is doing
14:40:02 <EvanR> erisco: transformers, simple things made complex
14:40:16 <[exa]> EvanR: get/ask tell/put is a good point, I never remember which one is which
14:40:27 <trigone> https://xkcd.com/1336/
14:42:50 <trigone> thanks everyone for all the help, see ya :)
14:44:29 <MichaelBurge> Is there a reason they couldn't put get/ask both in Reader, and put/tell both in Writer, and make Reader,Writer imply State?
14:45:19 <[exa]> well, in this view State is Writer loopbacked to Reader
14:45:57 <[exa]> which is one loopback more than what the programmer actually defined
14:46:51 <MichaelBurge> I suppose the RWS monad would be a counterexample to that
14:47:12 <kadoban> MichaelBurge: Reader + Writer is not actually the same thing as State, though perhaps I'm just missing something in the question.
14:47:26 <[exa]> MichaelBurge: yeah, possibly. It was a wild guess. :]
14:48:33 <geekosaur> mostly that they are manipulating separate things, and combining them is only what you'd want in some cases
14:49:35 <Tuplanolla> In my experience it has been useful to peel `StateT` off the stack while keeping `ReaderT` in it as soon as concurrency gets involved.
14:50:11 <MichaelBurge> kadoban: Isn't it? The monoid would be something like "a <> b = b", although maybe you would use functions so mempty = id.
14:51:34 <erisco> EvanR, well it is certainly when the program stops being fun for me
14:51:58 <jaseemabid> erisco, `localized computation st =  lift $ runStateT (runOlifant computation) st` is a lot more closer to what I want. The type signature `localized :: MonadTrans t => Olifant s a -> s -> t (Except Error) (a, s)` suggests that this will work for any transformer. Can I limit it specifically to the same  Olifant transformer? I'd love to keep the types simpler. 
14:52:30 <erisco> jaseemabid, why the st parameter?
14:53:37 <erisco> jaseemabid, and yes, if a general type fits then a more specific type does as well
14:53:59 <erisco> this is why you're writing Haskell and not C++
14:54:02 * erisco *snickers*
14:55:36 <jaseemabid> erisco, You are right. I can drop st and run in the current state. That's what I do most of the times. 
14:56:03 <erisco> jaseemabid, what is why I used "get", to use the current state
14:56:54 <erisco> this seems like a definition that should already be out there... but I dunno
14:57:12 <jaseemabid> `localized :: (MonadTrans t, MonadState s (t (Except Error))) => Olifant s a -> t (Except Error) (a, s)` is a very readable and obvious type signature imo.
14:57:24 <jaseemabid> I mean _not_ 
14:58:10 <jaseemabid> And probably the first time I couldn't fit a type in a single line.  
14:58:31 <trigone> hi, i was thinking about fake filesystem interfaces to make test suites for IO code. and i was thinking, why not have a set of functions guarranteeing (for the most part) zero side effect once the whole computation is done? eg, it'd create a file but would automatically destroy it once the process would be done (a sort of temporaryFile thing). does this kind of function already exist?
14:58:37 <erisco> specialise t then, you are allowed to
14:59:34 <erisco> trigone, you were gone for 16 minutes
14:59:45 <trigone> I'd use arrows and the typeclass Legolas to get rid of that pesky Olifant... (sorry couldn't help it)
14:59:49 <erisco> but, hello again
14:59:58 <trigone> erisco: well yeah i'm not entirely amnesiac yet
15:00:30 <trigone> erisco: but it's useful you play chronometer :P
15:00:34 <jaseemabid> trigone, Can you point me to something I can read?  
15:00:59 <trigone> jaseemabid: what?
15:01:29 <erisco> trigone, that is not something you can guarantee unless the operating system is designed to guarantee it
15:02:08 <jaseemabid> trigone, >  I'd use arrows and the typeclass Legolas to get rid of that pesky Olifant. Can you explain this please?
15:02:34 <trigone> erisco: i know, but it's not more dangerous than creating and destroying files in haskell: you can never tell what could happen in the meantime, but it's reasonably safe for test suites in a folder you know you won't touch while it gets executed. i'm not speaking using it for professional work
15:03:20 <erisco> well, that is rigorous enough for most professional work ;)
15:03:22 <trigone> jaseemabid: well it's called a joke... did you watch Lord Of the Rings 3 or not?
15:03:38 <trigone> erisco: what?
15:04:21 <vimalloc> linux has mktemp, bet that could be used in haskell some way or another.
15:05:07 <erisco> I learned in my short time as a sys admin that a linux server disk can fill because temp files are not deleted until a reboot...
15:05:36 <akfp> trigone: just create a file and immediately delete it.  you can still use it, and it will be deleted when the process dies.
15:05:55 <trigone> vimalloc: yeah but do i need to complicate my life? it's not like i care if the folder's metadata is changed or whatever else. all i'd do is make sure that if i create a file for a test, it gets destroyed no matter what. i can make some myself but if that already exists somewhere...
15:06:03 <trigone> akfp: not sure what you mean...
15:06:41 <ab9rf> note that all mktemp on linux does is open the file, then deletes it.
15:07:02 <erisco> oh, that makes sense...
15:07:03 <trigone> erisco: yeah there are big problems sometimes with /tmp. i separate it on another partition for that (mind you i don't know what'd happen if that partition gets filled entirely either...)
15:07:32 <ab9rf> the file remains on disk because the inode usage count includes the number of times the file is open, and so the file remains on disk (but not in directory) until all handles pointing to it are closed, at which point it is deleted, or at least scheduled for deletion.
15:07:37 <erisco> so is the inode gone but the descriptor still exists? how does that work?
15:07:49 <ab9rf> no, the directoiry entry is gone but the inode still exists.
15:08:01 <erisco> oh, okay, cool
15:08:28 <jaseemabid> trigone, Oh shit. /me hides
15:08:28 <erisco> by descriptor I meant handle... can't remember all the jargon
15:08:30 <trigone> ab9rf: didn't know you could delete a file currently in use... but, if i modify said file, won't i end up creating a new copy of it?
15:08:41 <erisco> a handle identifies a descriptor?
15:09:12 <trigone> erisco: a haskell file handle also stores where you are in the file, etc.
15:09:30 <erisco> pretty sure that is an OS thing, not a Haskell thing
15:09:30 <ab9rf> trigone: deleting a file on linux is just removing a pointer to it from a directory. doing that decrements the inode's reference count, and if that reaches zero the inode, and the file storage allocated for it, are deleted.
15:09:40 <geekosaur> actually a handle is an application construct wrapping an OS descriptor
15:09:49 <ab9rf> trigone: opening a file also increments its reference count, once for each time its open
15:10:11 <erisco> the OS has to know where you are in the file to have the appropriate part of the file loaded to memory
15:10:14 <trigone> ab9rf: ok i get it
15:10:29 <ab9rf> in the linux runtime for haskell, handles encapsulate descriptors, which are what the kernel uses to refere to open files
15:10:45 <trigone> ab9rf: once it's deleted, is there a way to increment the inode's reference count, essentially reviving the file?
15:10:55 <ab9rf> trigone: no, once it's gone it's gone
15:11:12 <erisco> I hear there is this table where all the inodes live...
15:11:21 <trigone> ab9rf: and when you write in the file, you write on disk but soon the file location will be lost?
15:11:44 <ab9rf> however, as long as the inode count remains above zero, you could mknod a new directory ewntry pointing to it, and thus "revive" a persistent reference to the file.
15:11:54 <erisco> whether the OS writes to disk or not I think is an OSism
15:12:01 <trigone> ab9rf: hm ok...
15:12:09 <ab9rf> trigone: as long as at elast one process retains an open descriptor to the ifle, its storage will remain allocated.
15:12:20 <erisco> it is managing the disk, it is loading stuff to memory, you're asking the OS to write stuff to the file, it does whatever it feels like
15:12:38 <trigone> ab9rf: but if i try to check the file before the process frees it, it's not visible to filesys browsers?
15:12:40 <ab9rf> you can read and write on the same descriptor in linux, and you can also clone descriptor (dup, dup2)
15:12:43 <erisco> which includes buffering your writes in memory until it feels like they should be put to disk
15:12:58 <ab9rf> the OS is free to defer writes to disk if it wants
15:12:59 <geekosaur> in general you can't attach a new name if the only existing reference is a file descriptor
15:13:00 <erisco> though they give you a "flush" command or something
15:13:19 <geekosaur> also note that a symbolic link doesn't count as a reference
15:13:21 <trigone> erisco: yeah but i'll need to read the file before leaving it fall into the abyss. after all i do want to check what my IO actions do.
15:13:22 <ab9rf> geekosaur: it's posisble in linux, but it's not "normal" behavior.
15:13:52 <erisco> trigone, if your premise is that the files are gone when your process ends then your process has to remain running to look at the files
15:14:04 <ab9rf> geekosaur: you can use fstat to get the major/minor dev and inode, then use mknod to make a directory entry with the same inode
15:14:11 <akfp> trigone: linux has a slew of inode-based file system operations which are far more powerful than what posix gives you.
15:14:26 <ab9rf> actually pobably stat, rather than fstat
15:14:27 <trigone> akfp: are they accessible from haskell?
15:14:33 <akfp> for example you can keep a deleted directory handle and then attach files to it.
15:14:46 <geekosaur> ab9rf, fstat because stat requires a path
15:14:53 <ab9rf> trigone: yes, but you might have to make your own FFI interface, dunno ho wmuch o the system call space has been fully FFIed
15:15:01 <trigone> akfp: with hard links, or you mean the files will be lost too?
15:15:02 <ab9rf> geekosaur: yeah, it's been a decade since i did any of this crazy stuff
15:15:27 <trigone> ab9rf: that sounds exponentially more complicated than creating and deleting things myself ^^
15:15:36 <ab9rf> trigone: shrug.
15:15:44 <ab9rf> trigone: it's also platform-specific.
15:15:52 <trigone> ab9rf: for me at least :)
15:15:53 <akfp> trigone: for every posix call such as open, stat, etc. there are system calls in linux called openat, statat, in general *at system calls take a file descriptor as base instead of a path.
15:16:04 <erisco> the uses of "exponentially" are becoming exponentially more inaccurate ;)
15:16:19 <ab9rf> erisco: harmonic dissonance
15:16:51 <trigone> akfp: you mean, linux has stuff to modify files that don't have a path?
15:16:54 <trigone> (anymore)
15:16:56 <ab9rf> trigone: yes
15:17:06 <trigone> ab9rf: and it's only for the case of temporary files?
15:17:18 <trigone> i mean, for what else is it useful?
15:17:27 <akfp> trigone: you can create your own detached file system
15:17:40 <akfp> trigone: it elimiates a lot of security races
15:17:48 <geekosaur> trigone, it can be used to pass filesystem contexts around that would otherwise be invisible
15:18:08 <ab9rf> it also means that you have essentially complete control ove r who can access your filesystem space.
15:18:37 <geekosaur> for example, an unprivileged process would not be able to access a directory under a directory that doesn't grant non-root search access
15:19:23 <trigone> ab9rf: hm.... but how to avoid things being deallocated once you reboot? if you say files without a path get flushed once they're not used anymore?
15:19:30 <geekosaur> but if you pass that process a file descriptor opened by a root process, it can use that to access it. this could be via fork/setuid/exec, or by passing it over an AF_UNIX socket (this is why file descriptor passing is called SCM_RIGHTS)
15:19:52 <trigone> btw, for my own question regarding temporary files, there's an actual library for it https://hackage.haskell.org/package/temporary-1.2.1/docs/src/System-IO-Temp.html#withTempFile
15:20:52 * hackagebot yesod-auth-hmac-keccak 0.0.0.3 – An account authentication plugin for yesod with encrypted token transfer. – https://hackage.haskell.org/package/yesod-auth-hmac-keccak
15:21:21 <ab9rf> trigone: oh, they'll be deallocated on reboot. that's part of the point.
15:21:54 <trigone> ok that's beyond absurd. whoever made that library... is it me or having a function writing on files use String as the type for the content to write a very bad idea?
15:22:03 <trigone> ab9rf: hm ok
15:22:28 <ab9rf> the nice thing is that you can pass a detached tree to a process and it can continue to access it even after a setuid or chroot.
15:22:32 <geekosaur> trigone, so all of System.IO in base is a bad idea?
15:23:26 <cloudhead> hey, anyone know how to encrypt/decrypt a bytestring with cryptonite's Crypto.PubKey.Curve25519? The docs aren't helpful..
15:23:29 <trigone> geekosaur: well if i use bytestrings i usually use the write functions from bytestrings. here i don't have that luxury unless there's already a version implemented for bytestrings
15:23:42 <akfp> trigone: yes it's a bad thing, but it's probably because we don't have Text in base.
15:23:58 <ab9rf> trigone: surely you can compose the required function
15:24:15 <trigone> geekosaur: and i don't think i'm the only one to think that [Char] as standard string is bad, esp if you want to write a giga-sized file...
15:24:31 <geekosaur> regardless, that is what is.
15:25:10 <ab9rf> [Char] has the merit of being simple :)
15:25:14 <trigone> ab9rf: maybe... but i don't get why everyone doesn't use typeclasses to deal with strings...
15:25:24 <akfp> trigone: if you look at the library, it's only one convenience function that actually writes data.  probably somewhat of a wart, but path handling is based on String so I can see why the author didn't want to add dependencies just for one function.
15:25:28 <ab9rf> i prefer to be explicit about my string representations
15:25:55 <akfp> trigone: it's because the Prelude is bad.  Use protolude.
15:25:56 <trigone> ab9rf: well when there's no question on what type is preferrable, sure
15:26:06 <borsec> can someone please tell me why the first method works, and not the second? https://justpaste.it/19cl1
15:26:10 <geekosaur> and it seems wrong to me to penalize a library because it tried to stick to bootlib dependencies
15:26:50 <geekosaur> borsec, what do you believe a Map.Map is?
15:27:11 <ab9rf> borsec: because Map.Map isn't (->)
15:27:24 <borsec> I am not completely sure, but from what I am reading I thought it would be (->)
15:27:42 <Tuplanolla> Stop reading that, borsec.
15:27:53 <trigone> geekosaur: so basically, there's no point trying to avoid the warts of haskell bc they're too standard, so might as well keep them for the end of times... yay
15:27:55 <geekosaur> no. ahtough depending on what you are reading, it may be understandable --- because it is talking about a different thing than a Haskell Map
15:28:11 <borsec> Oh i see, thank you! can you please tell me what it actually is?
15:28:13 <ab9rf> you know, i understand where you're coming from there
15:28:33 <ab9rf> a Map in Haskell is a finite data structure that store arbitrary maps
15:28:36 <trigone> akfp: i heard there was tons of different preludes... is protolude the best according to you? if so why?
15:28:38 <ab9rf> it is not a mathematically-defined mapping
15:29:18 <borsec> ab9rf, so it is like a finite set that stores maps?
15:29:30 <ab9rf> borsec: at least Map.Map is, yes
15:29:34 <akfp> trigone: yes because it only focuses on fixing the specific warts, such as eliminating String.
15:29:36 <geekosaur> borsec, there are mathenatical descriptions of functions which call them mappings from something to something else. this is not the same as a Map, which is a data collection, except on a conceptual level.
15:30:02 <geekosaur> trigone, the place to fix base is not an add-on library.
15:30:06 <trigone> akfp: does it include additional stuff?
15:30:08 <ab9rf> in theory, i suppose you could write a variation on Map that embodied a functionally-defined map
15:30:28 <geekosaur> base *does* change, this is not the way to do it
15:31:27 <geekosaur> (and part of the problem with changing base in this regard is, neither Text nor ByteString is the correct answer in all cases. String isn't ideal for either but can be coerced into serving both; this is much more painful with either Text or ByteString
15:31:48 <ab9rf> also ByteString is conceptually a different type than String
15:31:58 <ab9rf> String is a list of characters, bytestring is a list of bytes
15:32:00 <ab9rf> bytes are not characters
15:32:03 <geekosaur> so now you need either parallel text and binary interfaces, or typeclass cleverness like various alternative preludes offer --- and both have their own fairly major warts
15:32:31 <trigone> geekosaur: but packing and unpacking has a non-negligible cost, has it not?
15:32:33 <ab9rf> don't use Strings to hold bytes, ever. that is always wrong.
15:32:39 <akfp> trigone: semigroup, text, bytestring, bifunctor, semiring(haven't used that).  but only things that you typically want to use anyways.  I mostly add aeson to that mix for my own prelude.
15:32:41 <trigone> ab9rf: didn't plan on
15:33:41 * hackagebot SSTG 0.1.0.4 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
15:33:48 <akfp> trigone: the author is pretty strict on adding stuff. it's mostly about generalizing overly specific stuff.  the thing is that the Haskell Prelude is partially made to be friendly in a teaching context and that is at odds with professional use.
15:34:16 <skiddieproof> By chance, anyone online aware of attempts to port lambdabot to a discord server?
15:34:22 <ab9rf> yeah, haskell was never really designed for high-performance professional use, that just sort of happend
15:34:34 <trigone> akfp: cool. and as for default-imported stuff (you know, the Prelude module itself)? more goodies you nearly always need? cuz sometimes i feel like importing from Monad or Applicative is pretty absurd, but maybe i'm wrong...
15:34:48 <trigone> ab9rf: better that than the opposite though
15:35:05 <dmj`> cocreature: ping
15:36:04 <akfp> trigone: I suggest you put all your haskell code in one big megarepo.  there you can easily create your own prelude by using protolude as a starting point and adding the missing pieces.  that's what it is (also) designed for.
15:36:39 <phadej> akfp: like http://docs.futurice.com/haskell-mega-repo/futurice-prelude-1/Futurice-Prelude-Internal.html ? :)
15:36:54 <geekosaur> skiddieproof, there was a past attempt to make lambdabot more protocol-neutral. it failed pretty badly iirc.
15:37:05 <trigone> yummy future rice...
15:37:25 <geekosaur> while it looks like IRC is just a plugin, in fact it and IRC-specific behaviors are wired pretty deeply
15:37:54 <trigone> akfp: by any chance would you know good tutorials to learn from scratch how to use repos?
15:38:00 <akfp> phadej: exactly :-)
15:38:25 <phadej> and in fact, stack and cabal have their internal preludes
15:38:46 <akfp> trigone: a megarepo is just the name of a (git) repo with (typically) subdirectories that are individual packages.
15:39:02 <deceract> Are there any first-order semantic differences between 'data' and 'newtype'? Newtypes may have only one parameter and the corresponding constructors/accessors are stripped during compilation, but until then compilation, from what I can tell, 'data' and 'newtype' declarations are virtually synonymous. Is that the case?
15:39:20 <phadej> deceract: newtype has the same representation
15:39:46 <trigone> akfp: hm so i suppose i gotta learn version control...  once i have a custom prelude of mine, how do i install it as accessible dependency by GHC?
15:39:51 <geekosaur> deceract, newtype has support for partial exposure of typeclasses of the wrapped type, data would make you do so manually
15:40:35 <geekosaur> (that is, GeneralizedNewtypeDeriving)
15:40:39 <deceract> GeneralizedNewtypeDeriving, you mean?
15:40:55 <deceract> phadej: Would you mind elaborating a bit?
15:41:20 <akfp> trigone: eh.. not using version control is like deep water diving without an oxygen tank
15:41:31 <trigone> (i suppose GeneralizedNewtypeDeriving was a homage to java...)
15:42:06 <akfp> trigone: https://github.com/yesodweb/yesod/blob/master/stack.yaml is really all there is to a megarepo - a list of subdirectories.
15:42:08 <trigone> akfp: yeah i know ^^ i have yet to take the time to learn that...
15:43:05 <lyxia> @let data D a = D a
15:43:07 <lambdabot>  Defined.
15:43:12 <trigone> akfp: k... so i'll have to dive into stack too, to know how to install locally my own packages...
15:43:30 <lyxia> > let f (D _) = () in f undefined
15:43:33 <lambdabot>  *Exception: Prelude.undefined
15:43:36 <lyxia> > let f (Identity _) = () in f undefined
15:43:38 <lambdabot>  ()
15:43:55 <lyxia> deceract: ^
15:44:29 <rembo10> Hey, how can I decode a just a part of json into a data structue using aeson?
15:44:33 <trigone> lyxia: Identity is a newtype?
15:44:40 <lyxia> it is
15:44:44 <trigone> k thx
15:44:45 <deceract> Perhaps haskell should have first-class awareness of newtypes. The GeneralizedNewtypeDeriving helps, but it also, I think, demonstrates that the lack of first-order awareness of the distinction between newtypes and data declarations is problematic (or at least a nuisance). No?
15:44:46 <rembo10> I can get it as a Value, just not sure how to get it into my data type
15:45:27 <geekosaur> deceract, er, what?
15:45:27 <lyxia> deceract: how is it a nuisance
15:45:30 <akfp> trigone: https://haskell-lang.org/get-started is pretty good, but I'd suggest spacemacs as editor today, and then their docs does not give an intro to git.  github has lots of help on using git though :-)
15:45:42 <deceract> What if newtype declarations automatically/implicitly came with some kind of Isomorphism class constraint?
15:45:57 <lyxia> they do. See Data.Coercible.
15:45:57 <geekosaur> deceract, it's called Coercible
15:46:24 <dolio> How does that solve the same problem as GND?
15:46:25 <geekosaur> butm the *point* of newtype is to hide behaviors of the underlying type so you can replace them, without adding overhead
15:46:28 <trigone> akfp: thanks, i'll look into it :)
15:46:47 <geekosaur> and the point of GND is to be able to hide only *some* of those behaviors
15:47:34 <geekosaur> case in point: there are two newtypes Sum and Product, which provide different Monoid instances over any type with an Integral instance
15:48:09 <trigone> gotta go, thanks everyone, have a good day/night :)
15:48:11 <geekosaur> because (addition,0) and (multiplication,1) are both Monoids and neither can be considered the One True Monoid for suh types
15:48:13 <deceract> geekosaur: But does Coercible represent an isomorphism?
15:48:37 <deceract> I see the pattern "X . f . runX" fairly often with newtypes.
15:48:48 <dolio> It is stronger than an isomorphism.
15:49:01 <deceract> dolio: How's that?
15:49:09 <Filthy_Causual> @pl \(x,y) -> (f x, f  y)
15:49:09 <lambdabot> f *** f
15:49:14 <dolio> It indicates that the representation is identical.
15:50:24 <deceract> Is the revese coercion also possible? They're represented by the same type, but doesn't the type system still distinguish them?
15:51:02 <deceract> *reverse (Starbucks = cold fingers = typos)
15:52:13 <sam2_> hello, can I enlist someone's help to report a GHC bug? The GHC Trac doesn't seem to like me for some reason. It's a regression in 8.2 from 8.0, where ApplicativeDo with literal patterns is making GHC eat (apparently unbounded?) memory. Here's the reproducer: http://lpaste.net/357202
15:53:25 <dolio> sam2_: The d there is correct?
15:53:48 <sam2_> dolio: 8.0 fails with useful errors. 8.2 just sits there until it runs out of memory
15:53:56 <dolio> Weird.
15:54:26 <geekosaur> deceract, Coercible works in both directions
15:54:38 <cheater> if you have a large data structure and would like to write a module with functions that will filter it in different ways, what would you call that module?
15:54:41 <deceract> Anyway, I was wondering if it were possible for haskell to recognize that newtypes represent an isomorphism of types so that some kind of "conjugate" function would work form them. Something like "conjugate :: Iso m n => (m -> m) -> n -> n" and then "conjugate h" instead of "X . h . runX".
15:54:48 <sam2_> anyway, I would be much obliged if someone would open a ticket in the GHC Trac for this, since I don't seem to be able to
15:55:05 <cheater> filter and maybe manipulate
15:55:09 <Tuplanolla> Lenses have `ala` for this, deceract.
15:55:41 <Tuplanolla> :t ala -- Examples are probably more useful than this.
15:55:43 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
15:56:04 <cheater> my only idea is "Tools" but that's cheesy and non-descriptive
15:56:26 <geekosaur> deceract, there's a conflict here between type correctness and performance, and the point of Coercible is to give you both. what is _not_ wanted is arbitrary ignoring of types.
15:56:59 <Filthy_Causual> cheater: "Filters"?
15:57:12 <cheater> that sounds weird too
15:57:21 <cheater> i'm sure there's something people use for this generally
15:57:35 <Filthy_Causual> I don't think so.
15:57:44 <bollu> can I get a "continuation trace" in haskell from an "error" call?
15:57:47 <lyxia> deceract: "conjugate" is "coerce"
15:59:15 <Filthy_Causual> :t coerce
15:59:17 <lambdabot> error:
15:59:17 <lambdabot>     • Variable not in scope: coerce
15:59:17 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
15:59:42 <cheater> does "Query" sound fine?
16:00:30 <geekosaur> :t Data.Coerce.coerce
16:00:32 <lambdabot> Coercible a b => a -> b
16:00:39 <akfp> cheater: any aggregation?
16:01:29 <cloudhead> anyone know how I can convert a cryptonite Crypto.PubKey.ECC.ECDSA PublicKey to/from ByteString?
16:11:51 <akfp> cloudhead: you could probably use something like https://github.com/CIFASIS/hs-certificate-x509/blob/master/Data/X509/PublicKey.hs#L160 - it's for RSA, but the key is mostly Integers.
16:13:17 <akfp> or https://github.com/vincenthz/hs-certificate/blob/master/x509/Data/X509/PublicKey.hs#L98
16:13:37 <deceract> Thanks, lyxia and geekosaur. Your responses helped to point me to ghc.haskell.org/trac/ghc/wiki/Roles#Coercible.
16:14:07 <deceract> Thanks to Tuplanolla too.
16:14:28 <cheater> akfp: maybe
16:14:37 <cloudhead> akfp: thanks, I was hoping there'd be a ByteArrayAccess instance or something
16:14:46 <madknight> is there such "(a -> b -> c) -> f a -> b -> f c" a function?
16:15:19 <cheater> akfp: why?
16:16:10 <kzhang> madknight liftM2
16:16:50 <geekosaur> not quite
16:16:55 <kadoban> kzhang: That has an extra f on the b
16:17:01 <madknight> kzhang: no thats  (a -> b -> c) -> f a -> f b -> f c
16:17:20 <kzhang> madknight: Right, didn't see that
16:18:22 <sam2_> madknight: assuming f is a Monad (or Applicative), liftM2 is what you want. You can turn any b into an f b with return.
16:18:24 <madknight> kzhang: currently i use liftA2 (or liftM2) and pure b to make it working, but i thought maybe i dont need to lift b into the context if a function exist that i asked for
16:19:10 <Tuplanolla> A functor suffices, madknight.
16:20:35 <akfp> cheater: if you're doing aggregation there are concepts like analysis, aggregation, cube.  it you're not, you're maybe a filter, subset, sample.  query is both aggregation and not aggregation.
16:21:24 <sam2_> madknight: I don't think there's a ready-made combinator with that type. Depending on how much of the code you have control over, you might try re-ordering the arguments to b -> a -> c and seeing if that reads better
16:21:26 <Tuplanolla> :t flip . fmap .: flip -- Like this, madknight.
16:21:27 <lambdabot> Functor f => (a1 -> a -> b) -> f a1 -> a -> f b
16:22:22 <kzhang> madknight: I've never seen one in standard libraries.
16:23:03 <cheater> akfp: ok
16:23:10 <madknight> Tuplanolla: interesting okay, i often use <$> instead of `fmap` can i somehow combine flip with infix notation?
16:23:34 <Tuplanolla> That's going to be unpleasant, madknight.
16:24:15 <crobbins_> madknight: i think classyprelude (or some library) define (<%>) = flip fmap 
16:24:58 <madknight> crobbins_: okay and is that okay to use or is it to fancy?
16:25:24 <Tuplanolla> I'd rethink my constituents if I was you, madknight.
16:25:34 <akfp> madknight: not ok!
16:25:56 <MarcelineVQ> What's the matter with flip fmap?
16:26:04 <glguy> (\f fa b -> f <$> fa ?? b) :: Functor f => (a -> b -> c) -> f a -> b -> f c
16:26:41 <MarcelineVQ> Oh not quite flip fmap
16:27:11 <crobbins_> https://stackoverflow.com/questions/1678104/anyone-ever-flip
16:27:38 <crobbins_> oh looks like it's lens, and it defines it as <&>
16:27:38 <crobbins_> http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Operators.html#v:-60--38--62-
16:27:52 <ab9rf> lens has operators for all sorts of things
16:28:35 <kzhang> Too many operators could be a problem
16:29:19 <crobbins_> how about pamf = flip fmap
16:29:34 <crobbins_> then you can `pamf` without operators
16:29:44 <akfp> crobbins_: much better imo
16:29:55 <glguy> Yeah, now you just need to know two ways to flip fmap
16:29:57 <madknight> i use http://pointfree.io/ and if it suggests to many flips and dots i skip it, however sometimes its really useful i think
16:30:30 <glguy> madknight: the number of two many flips is near 1
16:30:35 <glguy> madknight: the number of too many flips is near 1
16:31:21 <madknight> glguy: two is my maximum :)
16:31:44 <crobbins_> i dunno though i've used <%> before where it just seems to compose a bit better
16:32:00 <crobbins_> depending on what you are doing
16:32:28 <crobbins_> can't we just argue about `f . g . h $ x` vs. `f $ g $ h $ x` instead?
16:32:56 <akfp> but for = flip map,  forM = flip mapM, so ffor = flip fmap
16:32:59 <eelster> Aren't they different?
16:33:04 <ReinH> :t flip flip
16:33:05 <lambdabot> b -> (a -> b -> c) -> a -> c
16:33:18 <glguy> akfp: No, for /= flip fmap
16:33:35 <glguy> akfp: No, for /= flip map * 
16:34:35 * hackagebot propellor 4.5.2 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
16:36:45 <exio4> @type for
16:36:46 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
16:40:59 <deceract> Kan extensions (or an approximation of them, given the language/context) seem to be prevalent in functional programming. Are there any standard examples of Kan lifts being used?
16:41:41 <madknight> hmm pretty long lifted filter "recentItem today = filter (\y -> fromMaybe False $ liftA2 isRecent (liftA2 timeDiffDays (itPubDate y) (pure today)) (pure (-100)))"
16:42:40 <pacak> Something tells me this line can be simplified a bit
16:44:22 <madknight> pacak: thats also what my intuition tells me, but there you can see all that liftA2 and pure thing
16:47:55 <pacak> mapMaybe, guard...
16:48:01 <glguy> madknight: http://lpaste.net/6767675913581625344
16:48:43 <pacak> I'd swap d and today and get rid of (-100)
16:50:04 <pacak> mapMaybe (\y -> do { d <- itPubDate y ; guard (isRecent (diffTimeDays today d) 100) ; return y)
16:50:24 <madknight> glguy: that looks much better, somehow i tend to write long lines
16:51:09 <pacak> Hmm.... forgot }  somewhere
16:52:40 <madknight> pacak: do { ... } allows me to write do notation in pure functions?
16:53:26 <glguy> pure functions, aka functions
16:53:41 <geekosaur> madknight, do translates to uses of
16:53:43 <glguy> doesn't even have to be a function to use do notation
16:53:44 <geekosaur> :t (>>=)
16:53:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:54:22 <geekosaur> but there are ways (generally involving a single expression) where it does nothing, and as such "can be used"
16:54:43 <pacak> madknight: Monads are not just about launching missiles, they can be used for pure stuff as well.
16:54:52 <geekosaur> also, there are Monads other than IO, in which case it can be useful. (do has nothing to do with purity.)
16:55:09 <pacak> Maybe, [], State...
16:55:18 <geekosaur> IO is impure.
16:56:04 <ReinH> I would guess that IO is not impure in the way most people think it is impure.
16:56:23 <madknight> as a general advise is it better to keep Maybe around by lifting and resolve it later or should i resolve it as soon as possible (since the lpaste solution does so)
16:56:37 <geekosaur> true, but most newcomers are already confused abut the whole thing
16:57:52 <ReinH> You should keep it around at least until you can do so something with Nothing.
16:58:00 <ReinH> Beyond that, it is hard to say.
17:00:05 <madknight> alright thx, i'll go to bed now, good night everyone
17:00:26 <monochrom> Blanket questions beget tautological answers. Handle a "Nothing" when and only when you know the default or alternative.
17:00:45 <monochrom> Debug your program when and only when it needs debugging.
17:00:48 <monochrom> etc etc
17:00:51 <pacak> :t mplus
17:00:53 <lambdabot> MonadPlus m => m a -> m a -> m a
17:01:02 <pacak> :t (<|>)
17:01:03 <lambdabot> Alternative f => f a -> f a -> f a
17:01:05 <monochrom> Use Haskell when and only when Haskell is the best choice.
17:06:25 <madgen> Hello, I'm trying to track down a typeclass instance that is visible to Stack but not to Cabal
17:07:54 <madgen> In particular meets1 function from lattices package that relies on Foldable1 class (defined in semigroupoid package) for its arguments and I used it with a list which should be an error, but Stack manages to find an instance for it while cabal fails.
17:08:20 <madgen> Any tips on how I might track this down to its source?
17:08:42 <sam2_> madgen: is this with cabal sandboxes, or the global/user package databases?
17:08:57 <madgen> cabal sandbox
17:10:32 <sam2_> madgen: if you know which package the instance is defined in, you can get the versions with 'cabal sandbox hc-pkg list' and... whatever the Stack analogue of that is
17:10:58 <madgen> Which package the instance is defined in is exactly what I am searching for
17:11:24 <monochrom> If you can get a ghci prompt, ":info Foldable1" may help.
17:11:51 <monochrom> Or ":info []"
17:11:54 <sam2_> alternatively, try defining an overlapping instance of it yourself and GHC should complain about it with a good hint
17:12:02 <madgen> monochrom: aha, that's a good idea. let me try that 
17:12:35 <madgen> sam2_: so is this!
17:17:32 * hackagebot numhask 0.0.8 – A numeric prelude – https://hackage.haskell.org/package/numhask
17:21:11 <madgen> sam2_: It doesn't complain when I define an overlapping instance. I'm guessing that means Foldable1 instance is defined on a typeclass list is an instance of
17:22:00 <sam2_> madgen: is your overlapping instance visible at the use site?
17:22:09 <Welkin> god damn
17:22:12 <madgen> sam2_: yup
17:22:12 <deceract> Has anyone ever had an opportunity to use edwardk's Kan lift code? I ask because I've read a few things recently that made me curious about their use in everyday software. golem.ph.utexas.ed/category/2009/06/kan_lifts.html, where David Corfield asked why Kan lifts were generally ignored; and "Type Theory and Homotopy", where Awodey mentioned, if I understand correctly (though I probably don't), that model
17:22:14 <deceract> categories were related to factorization systems with _trivial_ cofibrations.
17:22:19 <Welkin> even getting the parconc examples to compile in a huge pain
17:22:27 <Welkin> I have to use ghc 7.8.4
17:22:32 <Welkin> stackage lts 1.x
17:22:34 <Welkin> o.o
17:22:45 <deceract> Maybe a different forum would be better suited for this question, but I thought maybe some of you might know or be interested.
17:22:52 <Welkin> it would be nice if someone updated them for 8.x
17:23:26 <sam2_> madgen: odd. Is your module using OverlappingInstances and/or IncoherentInstances?
17:24:32 <madgen> sam2_: Nope.
17:25:29 <sam2_> huh. I didn't think that could happen. If checking :info doesn't reveal the culprit, you might have to bisect your imports.
17:25:56 <Welkin> ~/.nix-profile/bin/cabal: streamingProcess: runInteractiveProcess: exec: resource exhausted (Argument list too long)
17:25:59 <Welkin> WHAY
17:26:02 <Welkin> WHAT
17:26:24 <Welkin> cabal just gave up...
17:29:19 <madgen> sam2_: :info didn't produce anything useful for either of them :/
17:30:27 <Welkin> oh, there is a much newer version straight from github
17:30:34 <Welkin> the book needs to be updated to reflect that O.o
17:33:02 <madgen> sam2_: thanks for the help!
17:33:06 <sam2_> madgen: if your Cabal and Stack sandboxes aren't very different, maybe you can diff them and narrow down the possibilities?
17:34:27 <sam2_> or possibly pass --ghc-option=-v to cabal/stack build and looking at the precise packages loaded by GHC in each case
17:36:32 <madgen> sam2_: I found the culprit!
17:37:01 <sam2_> hurrah! Please file a bug as well, since Foldable1 [] should not exist
17:38:07 <madgen> sam2_: It wasn't a instance import issue. lattices library changed meets1 signature from [a] -> a to Foldable1 f => f a -> a in a MINOR release! I only guarded for a major release.
17:39:06 <madgen> sam2_: This new version has not made it to Stackage yet, so it works on stack. Hackage, however, has the latest version, hence breaking everything while pulling the dependencies.
17:39:24 <dolio> I think that's probably a major bump, by the rules.
17:39:36 <sam2_> was it 1.5 -> 1.6?
17:39:50 <crucify_me> xx
17:39:56 <sam2_> in Haskell-land, that's considered a 'major' bump, confusingly enough
17:40:07 <madgen> sam2_: Oh dear...
17:40:17 <geekosaur> just as with the linux kernel
17:40:36 <geekosaur> both patterns exist
17:40:47 <madgen> sam2_: so only changes in z in x.y.z are meant to be backwards compatible
17:41:08 <crucify_me> << anyone object to my favorite moniker?
17:41:21 <sam2_> it suffices to say that version numbers and backwards/forwards compatibility are complicated and have had a lot of words written about them
17:41:23 <dolio> Depends what exactly you mean by, 'backwards compatible,' but yes.
17:41:50 <monochrom> I support having two numbers for major change. This gives you room for the subjective divide between "conceptually, stylistically, paradigmly major change" and "just technically major change".
17:42:07 <madgen> It is entirely my fault then :/ Sorry for wasting everyone's time
17:42:24 <dolio> Minor revisions can export new symbols that might cause problems if you aren't really careful about your imports.
17:43:22 <Welkin> what is the stack equivalent of `cabal run program`?
17:43:37 <EvanR> needs more stratification, colonel change, major change, general change
17:44:17 <EvanR> maybe i got the majority order mixed up
17:44:22 <monochrom> No! We need finer-grain divisions of the minor changes.
17:44:43 <sam2_> so long as private changes are on the least important rung, I think it still works
17:45:17 <monochrom> harmonic, melodic, natural
17:45:38 <EvanR> other extreme, you only get 3. version 0, version 1, and version infinity
17:45:46 <EvanR> better use them wisely
17:46:24 <dolio> Just a single number seems increasingly popular.
17:46:34 <Welkin> Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2: The program 'alex' is required but
17:46:36 <Welkin> it could not be found
17:46:39 <Welkin> any help with that?
17:46:49 <Welkin> (using stack to build parconc-examples)
17:47:00 <monochrom> No, do it like Java, have two number systems in parallel. Also Windows versions.
17:47:03 <Welkin> I thought stack took care of installing alex and other dependencies
17:47:16 <boj> Welkin: they aren't app dependencies, they are separate executables
17:47:31 <boj> Welkin: you need to "stack install alex happy" separately
17:47:47 <sam2_> Welkin: alex there is being invoked as a.. yes, what boj said. Install it somehow (stack, cabal, distro package manager) and make sure it's in your PATH
17:48:16 <Welkin> I have a weird setup where cabal is installed via nix
17:48:28 <Welkin> not sure if that will break anything
17:48:35 <Welkin> unless stack uses a private version of cabal
17:48:39 <sam2_> or maybe you don't need to do the PATH munging and stack does the right thing for you, if you install it in the sandbox where it's going to be used?
17:48:52 <Welkin> I'm still getting the same error
17:48:56 <Welkin> even after I installed alex
17:49:35 <dolio> monochrom: Can we also prevent people from downloading old versions unless they give us their e-mail and agree to probably be spammed?
17:49:59 <geekosaur> that'll be a bad plan for as long as debian and rhel exist >.>
17:50:12 <Welkin> maybe I need to add them to my path
17:50:49 <monochrom> Hrm that depends on whether you've already signed up for GPL.
17:51:08 <deceract> I'm new to irc. Are /msg and /query private? Do they only work if the other person's currently online? Also, I'm still learning the norms on this channel; is messaging someone out of the blue ok, or is an invitation necessary?
17:51:19 <monochrom> Actually IANAL so I don't even know whether GPL allows it, forbids this, or stay ambiguous.
17:51:46 <geekosaur> deceract, /msg and /query are private and require the other person to be online; consider freenode's memoserv for someone who's offline
17:52:20 <deceract> Much obliged, geekosaur.
17:52:21 <monochrom> Oh freenode has memoserv too.
17:52:43 <monochrom> The logical conclusion is logical. freenode originated from Compuserv. :)
17:52:45 <geekosaur> also, freenode defaults to blocking them when the sender is not registered with nickserv and the recipient has not specifically enabled unregistered senders
17:53:41 <geekosaur> it's considered polite to ask in public before messaging in private, but individuals vary as to whether they are ok with it or not
17:53:55 <geekosaur> er, with messaging without asking first
17:55:14 <Welkin> or use lambdabot's @tell
17:55:31 <dolio> Probably don't, though. :P
17:56:01 <deceract> That makes sense. I was hoping to ask edwardk about his kan-extensions library, but I'll probably wait till I see him here. (Or maybe bartosz instead, but I don't know his nick.)
17:56:20 <dolio> It's possible I could answer the question.
17:56:36 <dolio> If it's quick.
17:56:48 <Welkin> god damn it o.o
17:56:53 <Welkin> I keep getting the same error
17:57:06 <Welkin> "Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2: The program 'alex' is required but it could not be found"
17:57:13 <Welkin> looks like a nix hash or something
17:57:24 <Welkin> I removed cabal-install from my nix store
17:57:24 <deceract> dolio: Ok, cool. It's an open-ended question. I was just wondering about the paucity of Kan lifts in haskell relative to kan extensions.
17:57:45 <deceract> Are kan lifts used in standard haskell code that you're aware of?
17:58:29 <dolio> Not much. The problem with lifts is they don't always exist, but extensions do.
17:59:26 <deceract> Do Kan lifts and extensions relate to the homotopy lifting/extension principle at all?
17:59:29 <dolio> And I think it might be that whenever a lift exists, it's a case where it's also an extension (because it's part of an adjunction).
17:59:45 <dolio> Heh, probably.
18:00:26 <deceract> *property, rather
18:00:29 <dolio> I mean, at least in that they are special cases of lifting/extension diagrams, I'm sure they're related.
18:01:09 <dolio> Extension is when you have two arrows going out of the same place, and you want to find an arrow that goes between their two end points.
18:01:26 <dolio> Lifting is when you have two arrows going into the same place.
18:01:43 <dolio> Kan extensions/lifts are like that.
18:01:53 <dolio> And I think the homotopy properties are also like that.
18:03:04 <deceract> I think I've read in a couple places that Kan lifts don't always exist. Are there specific characteristics of Hask that makes that the case?
18:05:36 <dolio> I'm not sure. However, if you go look at the page on Kan lifts, you'll note that there's no general (co)end formula.
18:06:13 <dolio> The (co)end formula for extensions means you can write it down in terms of forall/exists for all the cases you want in Haskell.
18:06:45 <Welkin> I keep getting the same error
18:06:47 <Welkin> what the hell
18:06:50 <Filthy_Causual> So when are (co)ends more like traces and when are they more like foralls?
18:07:02 <Welkin> why have I run into so much trouble lately with building haskell packages???
18:07:18 <Welkin> it says alex cannot be found, but I just installed it and it is on my path
18:08:06 <dolio> Kind of the reason they don't exist is because they're on the wrong side of the composition.
18:09:07 <joeyh> > Data.Typeable.cast "foo" :: Maybe Int
18:09:09 <lambdabot>  Nothing
18:09:24 <joeyh> I'm puzzled how that works, given that String and Int lack Typeable instances
18:09:30 <dolio> When you need to come up with R such that R . f is like g, it's easy for R to do aribtrary manipulations of f.
18:09:41 <deceract> dolio: "the page on Kan lifts" -- I've been looking online, but I'm not sure what page you mean specifically.
18:10:06 <dolio> But lifts require f . R to be like g, but R goes inside the f.
18:10:19 <dolio> Oh sorry, the nlab page: https://ncatlab.org/nlab/show/Kan+lift
18:11:14 <dolio> So you can come up with easy examples where no matter what you pick for R, it won't work out.
18:11:26 <geekosaur> Welkin: stack exec env | grep PATH
18:11:30 <dolio> Like f x = () and g x = empty.
18:12:02 <dolio> If you need `f . R => g`
18:12:24 <dolio> Anyhow, I have to go.
18:12:56 <Welkin> geekosaur: I already nuked everything. I'm trying to reinstall. It will take probably 30 minutes o.o
18:13:04 <Welkin> this is really frustrating though
18:13:05 <deceract> dolio: thanks!!
18:13:09 <dolio> No problem.
18:13:26 <Welkin> recently I have been having far too much trouble just getting things to build
18:13:43 <Welkin> whether it is with nix or stack
18:15:12 <Welkin> does stack use its won cabal or the one on the path?
18:15:14 <Welkin> own*
18:15:31 <Welkin> because it looked like it was using the one installed by nix (and the cabal library from nix)
18:15:56 <sam2_> I have the impression that stack doesn't use cabal-the-executable at all
18:16:13 <lamefun> How is this module "dilemma" usually resolved? http://lpaste.net/2546856129820884992
18:16:14 <Welkin> that's right
18:16:18 <Welkin> it uses the Cabal library
18:17:10 <geekosaur> sam2_, actually iirc it uses it in 'stack solver' under some circumstances
18:17:25 <joeyh> aha, ghc only passes the auto-derived Typeable to functions that need them
18:17:55 <geekosaur> joeyh, more precisely to those that declare it. or, put otherwise, => looks a bit like -> for a reason
18:18:29 <joeyh> yep
18:27:29 <crucify_me> @src not
18:27:29 <lambdabot> not True  = False
18:27:29 <lambdabot> not False = True
18:30:29 <Welkin> geekosaur: I still get the same error
18:30:40 <Welkin> and runningyour command shows that it is on my path
18:31:10 <geekosaur> oy
18:31:26 <geekosaur> I think you need someone who knows more about whats going on (and has stack installed...)
18:31:37 <Welkin> `Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2: The program 'alex' is required but it could not be found` is the relevant error
18:31:38 <geekosaur> maybe look around for MarcelineVQ 
18:32:20 <geekosaur> alternately the way it is testing for it is the problem (e.g. trying a --version option that doesn't produce the output it expects)
18:32:39 <Welkin> is there a stack channel?
18:33:02 <geekosaur> #haskell-stack but most people tend to end up asking here anywya
18:34:08 <Welkin> geekosaur: if you don't use stack, what do you use? nix?
18:34:42 <geekosaur> cabal new-* when I need it. have an experimental nix setup but don't use it for a lot yet
18:42:57 <butterthebuddha> https://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
18:43:05 <butterthebuddha> Anyone got any tips for getting me started with exercise 1?
18:44:51 <Welkin> wtf O.o
18:45:15 <Welkin> I added `build-tools: alex` to the .cabal and it worked, even though it complained about `build-tools` being an unknown field
18:45:31 <monochrom> haha
18:45:57 <geekosaur> ...what version of Cabal are you uysing that it didn't know build-tools?
18:46:51 <erisco> butterthebuddha, step 1 is to solve the problem with any implementation. step 2 is to look at what you've got and to find equivalences which are shorter
18:47:04 <butterthebuddha> I'm stuck on step 1 rn
18:47:36 <Welkin> okay... it guess it didn't realy work
18:47:43 <Welkin> the executables are busted
18:47:46 <erisco> that is funny that the prof likes code golfing
18:47:58 <Welkin> geekosaur: 1.24.2
18:48:23 <Welkin> geekosaur: do I need to add `build-tools` to each executable stanza? Or at the top-level?
18:48:49 <Welkin> I run `stack exec sudoku11 and I get `sudoku1: user error (Pattern match failure in do expression at sudoku1.hs:9:3-5)`
18:50:10 <erisco> butterthebuddha, I can speculate they like the idea of code golfing for two reasons... 1) it encourages you to try and solve the problem in different ways to find a shorter one, 2) it encourages you to identify functions that are already in the standard library for you to use
18:50:34 <geekosaur> where is this sudoku1.hs ?
18:50:53 <Welkin> https://github.com/simonmar/parconc-examples
18:52:07 <Welkin> oh... wtf
18:52:13 <Welkin> I have to feed it data?
18:52:16 <Welkin> from where
18:54:14 <Welkin> okay... it look like for those I need to give it the text files present
18:56:18 <chominist[m]> Do I need an invite for the functional programming slack team?
18:56:24 <chominist[m]> fpchat.com is down
18:59:05 <ditadi> l
19:01:27 <erisco> who are the functional programming slack team?
19:02:01 <Axman6> I feel Slack would be an awful tool for such a large number of people
19:02:12 <EvanR> sounds like an action figure lineup
19:02:37 <erisco> a team of FPers in slacks?
19:02:40 <Welkin> open source slack channels kind of suck
19:02:44 <Welkin> I remember the elm channel
19:02:48 <Welkin> it wasn't much use
19:03:10 <Welkin> it had something like 5,000 users, but no one really talked
19:03:19 <Axman6> yeah I've joined a few and they don;t work. IRC is the way to go
19:03:22 <Welkin> slack for work is incredibly nice
19:03:51 <Axman6> aye
19:03:58 <Axman6> I'm on 11 slack teams though :\
19:04:09 <Axman6> and the slack app is awfully wasteful
19:04:14 <erisco> ah ha... there have been so many me too's that I forgot what slack was
19:04:52 <monochrom> Wait, they call you "a team" even when you barely know each know and you're just there to lurk?
19:05:29 <Axman6> slack is designed for teams, it doesn't work well for the IRC usecase
19:10:41 <meme> hello
19:11:42 <ditzy> hello! I'm a relative novice and struggling with a type signature. I'm hoping someone here can help
19:12:20 <ditzy> I am trying to write a function that takes a String and depending on the contents returns a different instance of a particular class, let's call it Route
19:13:02 <ditzy> I tried `(Route r) -> String -> r` but when I call the function I get a compiler error that the type isn't clear
19:13:39 <ditzy> I eventually came to the idea that I might need to use a forall somewhere in there, but I'm struggling to understand how to use forall correctly :T
19:14:43 <Squarism> Asking here also just to make sure its impossible. Is it possible to decompose a type-level list at runtime into a list of some serializable type-identifier? 
19:14:44 <ditzy> by the way, I think I understand why the type signature I tried didn't work. And my guess about forall is based on the reading I've done about forall, but I definitely don't know how to employ it correctly
19:22:21 <exio4> ditzy: are you sure that's what you want? you might be trying to use Haskell typeclasses like OO classes
19:22:38 <geekosaur> ditzy, you can't do that because the result type is controlled by the caller, not by your function
19:23:02 <exio4> geekosaur: that's what exists. o (forall x. x -> r) -> r is for :p
19:23:09 <exio4> why*
19:23:32 <ditzy> exio4: I am sure of truly nothing, haha. I have been doing a lot of OOP lately, so it's very possible I'm confused. I've also never made a class before, and have tried to every so often when I try haskell again, but yeah it might not be right here
19:23:34 <exio4> uh, I cannot write meaningful sentences at this time of the day, ignore that :)
19:24:23 <geekosaur> haskell is not OO. typeclasses are a thing, but they are not OOP classes and trying to use them that way will generally just get you into unsolvable type conundrums
19:25:02 <ditzy> no, I know that, and I've used classes enough to be comfortable with the general idea. I think this was a case of me wanting to do a thing first, and wondering if type classes could solve it
19:26:49 <ditzy> I'm basically doing a routing like thing, where there are multiple functions that go together for a single route
19:27:18 <ditzy> that's why I wanted to use a type class, so I can add instances when new routes come up and I wouldn't have to change any other code to accommodate the new instance
19:27:32 <ditzy> but that's a bit more advanced than anything I've ever done in haskell
19:29:23 <sam2_> Squarism: if I understand your question right, it's very possible
19:29:47 <Squarism> sam2_, oh ok? How
19:30:41 <sam2_> Squarism: the idea is that you have a GADT that has exactly one value per type (not counting bottoms), and then a class with a method to get that singleton value. You might need to play some games to get the type to appear in the right place, depending on how you're doing it
19:33:42 <Squarism> sam2_, does it work without have actual values in the list? Just the type-level list type of the list itself? 
19:34:13 <sam2_> Squarism: the elements in the type-level list will presumably have to be singleton-isable themselves
19:35:25 <Squarism> sam2_, https://hackage.haskell.org/package/hvect-0.4.0.0/docs/Data-HVect.html#t:Rep this is the "list" id like to decompose - note it doesnt have values themselves - just types
19:37:39 <sam2_> Squarism: it will depend on the kind that's going into the type-level list. If it's * (i.e., types), you're out of luck, but if it's naturals or symbols, that's perfectly workable
19:38:47 <geekosaur> ...and the type level list is :: [*], soooo
19:39:36 <sam2_> huh, I thought it was polykinded for a moment. You're right.
19:42:54 <Squarism> thanks for trying!
19:46:05 <MarcelineVQ> geekosaur: thanks for thinking of me, I'm not sure what all is involved in stack solver's workings though
19:46:38 <geekosaur> this wasn't abotu solver, actually, it was about stack not being able to find alex
19:47:01 <geekosaur> when it was installed and on $PATH (as in, the $PATH visible via stack exec)
19:47:45 <MichaelBurge> Is there something that generates a lens for all values of a type a on a sum type b? Ex. All of the Ints on data X = A Int Int | B [Int]
19:48:00 <MarcelineVQ> I see, beyond looking with  stack exec -- which alex  I'm not sure what would be reasonable. It's possible I'll run into this issue shortly and find out though, given that I've expunged all my pacman ghc relevant packages
19:48:22 <MichaelBurge> Control.Lens.Plated seems to have the machinery for doing it automatically with a Data/Typeable instance, though it's mainly for self-recursive types
19:54:10 <glguy> > toListOf template ([ Left (1,2), Right [3,4,5] ] :: [Either (Int,Int) [Int]]) :: [Int]
19:54:12 <lambdabot>  [1,2,3,4,5]
19:55:24 <sam2_> Squarism: I don't actually think it's totally hopeless. Is http://lpaste.net/357205 something like what you were hoping to do?
19:55:37 <MarcelineVQ> geekosaur: Was Welkin trying to build https://github.com/simonmar/parconc-examples do you know?
19:56:08 <geekosaur> I assume, but they only mentioned that later so ??
19:56:23 <MichaelBurge> Yeah, that looks like the one. Very powerful library - it seems to have just about everything, and it all composes together nicely.
19:56:56 <geekosaur> only after I asked where the file they were getting a runtime pattern match failure came from. kinda hard to debug anything when they leave out the details...
19:57:18 <MarcelineVQ> I've just tried a build and get the alex failure so we'll assume that's the one, now to figure out the solution
19:57:31 <Squarism> sam2_, wow thanks.. ill look into it.
20:02:24 <sam2_> Squarism: definitely not impossible. http://lpaste.net/357206 does more or less what you originally asked, I think; it does all depend on what you're putting in the type-level list, and whether you're able to have this kind of constraint
20:03:07 <Filthy_Causual> So why would "k0 = g 2 k0" and "k1 = fix (g 2)" behave differently?
20:03:24 <Filthy_Causual> (namely the second just hangs.)
20:05:50 <Filthy_Causual> Oh, never mind.
20:05:56 <Squarism> sam2_, just got the first example running. Need to dwelve into it. Im merely a haskell noob
20:06:24 <MarcelineVQ> geekosaur:  build-tools: alex, happy  is enough to complete the build, I'll make a PR
20:10:55 <Axman6> Filthy_Causual: I'm curious to know what the resolution to your question was, since the former is essentially the definition of fix
20:12:31 <Filthy_Causual> I had a homespun definition of fix that was fix f = let x = fix f in x, which uh..is fix id for all f. >.<
20:13:14 <geekosaur> "oops"
20:13:14 <Axman6> yeah :)
20:18:41 <nimbus[m]> Hey all - bored and exploring new tech things tonight. I'm new to Matrix/Riot, and I've never tried Haskell.
20:19:21 <nimbus[m]> I've heard a lot about it. Does anyone have a link on hand for a good tour of it?
20:19:47 <MarcelineVQ> @tell Welkin https://github.com/simonmar/parconc-examples/pull/22
20:19:47 <lambdabot> Consider it noted.
20:20:09 <jle`> nimbus[m]: for the super brief tour, there's the interactive repl on haskell.org
20:20:29 <nimbus[m]> thanks jle`
20:20:36 <jle`> for something a bit more in-depth there is the LYAH book and the Haskell from First Principles book (which is non-free)
20:21:04 <nimbus[m]> jle`: thank you for the recommendations. I'll check that out.
20:21:18 <jle`> this readme also has a lot of nice beginner resources https://github.com/bitemyapp/learnhaskell
20:21:36 <jle`> no problem! happy haskelling :)
20:21:37 <ReinH> I would not call LYAH "in-depth".
20:21:44 <ReinH> I would, in fact, call it the opposite.
20:21:57 <Axman6> nimbus[m]: what's Matrix/Riot?
20:22:02 <jle`> i realized the irony after i said so, but, 
20:22:03 <nimbus[m]> I appreciate the resources jle`
20:22:14 <jle`> it is slightly more in-depth than the haskell.org demo
20:22:19 <ReinH> jle`: I believe the phrase I've used in the past is "woefully inadequate".
20:22:34 <jle`> but yes it is probabably comparing the depth of a dry parking lot vs. a shrinking puddle
20:22:49 <geekosaur> "2-hour movie trailer" was monochrom's assessment iirc
20:22:56 <ReinH> The courses that link recommends are much more in-depth.
20:23:02 <Welkin> ReinH: I just received Hutton's new haskell book
20:23:04 <ReinH> And also free. Well, the course notes are free.
20:23:05 <jle`> yes, they're actual learning resources
20:23:24 <ReinH> Welkin: Nice.
20:23:56 <ReinH> geekosaur: I'll buy that.
20:24:45 <Welkin> @tell MarcelineVQ thanks for the PR. Did you just test it locally?
20:24:45 <lambdabot> Consider it noted.
20:24:49 <Squarism> sam2_, ok.. it seems to do what i want for that type you provide in the example. Im a little confused on how i apply it on an example value. 
20:24:54 <MarcelineVQ> Welkin: yes
20:25:11 <Squarism> sam2_, like i have a value s :: Data.HVect.Rep '[GHC.Int.Int64, String]
20:25:20 <Squarism> sam2_, how would i apply it on that?
20:25:47 <macrover> ls
20:26:32 <nshepperd> Axman6: some kind of new chat thing which can apparently interface with irc
20:26:33 <MarcelineVQ> Welkin: travis doens't seem to like it, not sure why, it's a petty basic cabal setting afaik :<  we'll see where the PR goes, in the mean time adding those two should work for you
20:27:33 * hackagebot dhall 1.5.0 – A configuration language guaranteed to terminate – https://hackage.haskell.org/package/dhall
20:27:38 <MarcelineVQ> geeze, my client must be having a stroke, it could't find you when I sent that tell, or I​ wouldn't have used a tell
20:28:51 <Welkin> MarcelineVQ: I added `build-tools: alex` to the top-level (not the executable stanzas) and it complained that it didn't recognize that property, but it worked anyway
20:28:55 <geekosaur> they joined a few minutes before you sent it, and a few minutes after you reported you were going to send a PR
20:29:14 <Welkin> MarcelineVQ: I wasn't online for the last 30-40 minutes
20:29:29 <Axman6> nshepperd: oh, ok
20:30:04 <nimbus[m]> jle`: That first link you sent me - is it interpreting haskell within JS, or is it sending the requests to server-side haskell and getting the response
20:30:58 <MarcelineVQ> Welkin: ehe you were when I sent the tell though, just client shenanigans I guess
20:31:53 <test_123> anybody tried ghc-mod with 8.2.1 yet; doesn't compile out-of-the box, alas
20:32:30 <MarcelineVQ> hmm, I wonder if it fell back to a different Cabal version when it didn't recognize that stanza, if it can, that's not where that goes and I'd expect it to be an error to have it there
20:33:21 <MarcelineVQ> error as in a "parse error, full stop"
20:45:26 <jle`> nimbus[m]: i think it's sending it to a server (from what i know of its history)
20:47:19 <nimbus[m]> jle`: I've been doing mostly C++ (not C with objects), PHP(ewwww), Ruby, JS, etc for a long while. Haskell reminds me a lot of scheme. Fun stuff - thanks for the links
20:47:24 <nimbus[m]> refreshing
20:48:20 <nimbus[m]> I like C++ - not trying to start a language war - but I'm enjoying the change of pace and really see what all the buzz about Haskell is.
20:48:40 <nimbus[m]> I'm going to do my next few pet projects in Haskell in it.
20:48:49 <nimbus[m]> errr... that sentence made no sense :-p
20:48:58 <nimbus[m]> I'm going to do my next few pet projects in Haskell to learn it
20:50:01 <MarcelineVQ> nimbus[m]: awesome, lets us know how it goes or if you have questions
20:50:49 <nimbus[m]> Thanks MarcelineVQ. Will do.
20:50:54 <jle`> nimbus[m]: haskell and scheme are kind of similar on the surface, but when you look deeper, their strength comes from very different things 
20:51:13 <jle`> they're both "functional languages", but there's still a very wide variety within that large umbrella
20:51:37 <nimbus[m]> Oh I'm sure. I've done very little with functional programming (aside from the approximation you can make with functors in C++)
20:51:41 <jle`> but i think they seem similar to many because most people don't venture into functional programming very often
20:51:58 <nimbus[m]> And I spent a whopping 2 weeks on scheme in a 200 level CS programming languages course
20:52:13 <nimbus[m]> Some Prolog (does that count as functional?)
20:52:23 <jle`> most people wouldn't count it i think
20:52:36 <jle`> oh yeah, interesting you bring up functors in c++
20:52:56 <jle`> one of the hardest parts about learning haskell is trying to bring in your previous programming knowledge and programming instincts into it
20:53:08 <jle`> and it...throws you off a bit, heh
20:53:16 <nimbus[m]> Yes, jle`  - I didn't pretend to think I was correct in comparing the two.
20:53:25 <jle`> yeah, i know you weren't, heh
20:53:37 <jle`> but just saying because Functor is a common term in Haskell, and also a term in C++, and they mean different things
20:53:43 <jle`> so you might encounter a lot of those things
20:53:44 <nimbus[m]> Yes - if I hadn't ventured into procedural programming much I'd think C, C++, Java, Javascript, Actionscript, etc were super similar
20:54:10 <nimbus[m]> haha, I didn't know that about the term Functor
20:54:13 <jle`> but yeah, expect to feel a lot of weird feelings of vertigo from it :)
20:54:18 <nimbus[m]> Yeah that would throw me off for a bit without warning
20:54:34 <nimbus[m]> Thanks for the heads up
20:54:41 <jle`> even "variable" in haskell means something different than it does in imperative languages haha
20:54:48 <jle`> no problem!
20:54:53 <nimbus[m]> oh dear
20:55:00 <nimbus[m]> So basically, take nothing for granted
20:55:41 <jle`> heh.  yeah, or just be aware of the things you're unconsciously bringing with you
20:55:49 * jle` realizes that that is an oxymoron
20:55:58 <nimbus[m]> haha
20:56:23 <nimbus[m]> Oh, I just realized that this is an IRC channel with a matrix proxy in front of it
20:56:30 <nimbus[m]> interesting. Didn't know one could do that
20:56:43 <nimbus[m]> If you're interested I just found out about it. matrix.org
20:56:59 <nimbus[m]> My first time using it.
20:59:22 <nimbus[m]> btw, jle` - it's evaluating the haskell server-side
21:00:50 <jle`> ah, yeah :)  that would probably make the most sense
21:01:00 <jle`> i don't think there's a js haskell interpreter out there at the moment
21:01:16 <nimbus[m]> Well I'll see you all soon - I don't have as much time to experiment with new languages as I'd like, but I think I'll be playing with Haskell, so thanks for the help, jle` and for the invite MarcelineVQ .
21:01:27 <jle`> no problem, and have fun!
21:01:52 <nimbus[m]> jle`: the line gets blurry. With nacl and pnacl you can convert C code (even huge libraries) to asm.js
21:02:14 <nimbus[m]> So a haskell interpreter written in C could probably be made client-side in a browser without changing any code
21:02:55 <nimbus[m]> the unreal engine and a lot of other fairly large complex projects have been made to run in a browser at near native speeds.
21:02:58 <nimbus[m]> Crazy!
21:03:13 <nimbus[m]> Alright - good night!
21:03:23 <jle`> night!
21:04:15 <butterthebuddha> Guys any tips for the first exercise on here -https://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
21:06:53 <nshepperd> haskell variables are variable in the sense that it can be a different value each time the... expression (context? line of code?) is reached, the same as in imperative languages
21:07:12 <nshepperd> but not in the sense that you can modify them
21:07:57 <jle`> in imperative languages, a variable is (among other things) a mutable box of sorts, and program flow involves successive modifications of the box to achieve a desired result
21:08:10 <jle`> so it's inherently tied to sequentual executation i think, as a concept
21:08:41 <jle`> haskell variables are variables in the math sense...they're parts of an expression you can freely 'vary'
21:09:08 <nshepperd> > let foo = (\x -> let y = 2 * x in (x, y)) in (foo 2, foo 3)
21:09:10 <lambdabot>  ((2,4),(3,6))
21:09:46 <nshepperd> in the first instance y is 4, in the second it is 6
21:10:12 <jle`> yeah, 'foo 2' and 'foo 3' are different things, because we vary one of the parts of the expression
21:10:32 <nshepperd> i guess that's 'variable' ‾\(o.o)/‾
21:11:02 <jle`> heh, yes, that's why mathemeticians called them variables before CS people ever arrived on the scene
21:11:27 <jle`> but the imperative variable's existential justification is in its purpose in sequential modification i believe, in the context of an imperative algorithm
21:12:00 <jle`> an imperative variable is a thing that you can use to manage state over the course of your program
21:12:30 <jle`> s/can use/use
21:13:35 <jle`> maybe what haskell calls 'variables' is what other languages call 'parameters'
21:13:38 <nshepperd> i think a c++ programmer would probably say something like "int foo(int x) { const int y = 2 * x; return x + y }" contains a variable called y, but maybe there would be holy wars over the terminology there
21:15:23 <jle`> we wouldn't even call that a variable in haskell, heh
21:15:41 <jle`> so maybe the things that c++ calls variables is a superset of what we'd call variables in haskell
21:15:53 <edwardk> Deceract: we don't use Kan lifts in haskell because they don't exist in general
21:15:55 <jle`> that is, if 'x' is considered a variable
21:16:21 <nshepperd> well, that is the closest thing to haskell-style let bindings
21:16:25 <nshepperd> 'const' variables
21:16:47 <Welkin> that's still not the same
21:16:57 <nshepperd> forgetting the whole laziness issue
21:17:04 <Welkin> const variables are only constant in the reference
21:17:08 <butterthebuddha> Can I get the index of the element using filter?
21:17:11 <Welkin> the object they refer to can be modified
21:17:22 <jle`> yeah this isn't anything that i don't agree with; just saying that 'variable' in haskell means something very different than 'variable' in the imperative sense, or in c++
21:17:24 <Welkin> butterthebuddha: yes, if you write your own fold
21:17:29 <jle`> butterthebuddha: you can zip [1..]
21:17:30 <cheater> i would like to fold over a list, and while doing that i would like to build up two Map's and finally return them. How can I do this in a pure way?
21:17:33 <jle`> er, zip [0..]
21:17:52 <jle`> cheater: without knowing any more details, it sounds like you just want a fold
21:17:55 <ReinH> however you do it will be a pure way
21:18:04 <Welkin> cheater: keep the Maps in your accumulator value and insert into them
21:18:18 <cheater> right, but will subsequent inserting be somehow inefficient?
21:18:28 <jle`> Map is optimized for this
21:18:28 <Welkin> cheater: no
21:18:33 <jle`> being a persistent data structure
21:18:48 <Welkin> a lot of people seem to assume that immutable data is somehow inefficent
21:18:53 <kadoban> cheater: There is also Data.Map.fromList and variants of that that are usually nice.
21:18:58 <Welkin> that couldn't be further from the truth for anything other than arrays
21:20:06 <cheater> kadoban: i need to make three maps actually, not two. wouldn't fromList have to scan over the list multiple times?
21:20:27 <kadoban> cheater: Yes
21:20:36 <cheater> i would like to scan only once
21:20:39 <cheater> i guess it's fold for me then
21:20:43 <kadoban> But that could still be preferable. Creating 3 maps at once sounds like it could be a bit of a mess.
21:20:50 <Welkin> cheater: you are optimizing prematurely
21:20:57 <cheater> Welkin: i don't assume anything about immutable data, i assume everything is inefficient, this way i'm fair to everyone
21:21:18 <Welkin> just write something that actually works
21:21:31 <Welkin> then make it better if (and only if) you need to
21:21:36 <cheater> that's what i'm doing right now
21:22:11 <Welkin> I didn't see any code
21:22:42 <jle`> in the end, data structures are efficient for the operations they are optimized for, and possibly inefficient for the ones they aren't
21:22:55 <jle`> immutable/persistent insertions is one operation that Data.Map is especially optimized for
21:22:55 <cheater> Welkin: i appreciate your hussle
21:22:58 <cheater> :)
21:23:53 <ReinH> :t (***)
21:23:55 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:24:06 <nshepperd> why would scanning only once be important?
21:24:36 <ReinH> constant factors matter?
21:24:38 <kadoban> If the list is huge it could be, but then you'd probably want to do just about anything except create 3 maps usually.
21:25:38 * hackagebot dhall-nix 1.0.5 – Dhall to Nix compiler – https://hackage.haskell.org/package/dhall-nix
21:26:28 <nshepperd> if the list is huge and the output is smaller than the input you could save memory
21:27:28 <kadoban> Yes. That's just a bit specific.
21:27:28 <jle`> also if you scan twice it prevents GHC from garbage collecting the list
21:27:39 <jle`> if you only scan once then GHC can do it in constant-memory
21:27:40 <ReinH> or fusing
21:27:43 <jle`> and never even allocate the list
21:28:10 <ReinH> I would expect a fold over a list being generated by a good producer to be fused.
21:28:26 <ReinH> both foldr and foldl are good consumers
21:28:26 <jle`> so scanning twice might require the entire list to held in memory, but scanning once might never allocate any list at all
21:28:31 <kadoban> Ya, fusion would be good.
21:30:18 <dmj`> cocreature: ping
21:30:20 <ReinH> one clean option is to take advantage of the Monoid instance for maps and the one for tuples by mapping each item into a tuple of singleton maps and then `fold`ing
21:31:01 <ReinH> A combinator can help: keyed f a = singleton (f a) a
21:32:44 * hackagebot dhall-json 1.0.4 – Compile Dhall to JSON or YAML – https://hackage.haskell.org/package/dhall-json
21:39:50 * hackagebot dhall-bash 1.0.3 – Compile Dhall to Bash – https://hackage.haskell.org/package/dhall-bash
21:42:26 <kadoban> ReinH: (<>) probably just uses union, right? That might be bad. The docs say that union is O(n+m).
21:42:50 <jle`> that's the same as repeated insertions
21:43:52 <ReinH> No, union is O(m*log(n/m + 1)), m <= n
21:44:05 <kadoban> Oh, I'm probably looking at the old ones again.
21:44:26 <ReinH> insert is O(log n)
21:44:34 <ReinH> Now, what happens when one of the maps is of size 1?
21:44:43 <ReinH> to the complexity of union
21:45:13 <kadoban> jle`: Well, I guess it depends how literally I'm supposed to take the O(m+n) one. That sounds a lot like it'd be O(n^2) to build one via union.
21:45:27 <kadoban> ReinH: I have no complaint with the new documented bound, ya that one is good.
21:46:04 <ReinH> Ok
21:46:19 <kadoban> Should have checked the new docs, I really gotta change my lookup thing.
21:46:34 <ReinH> There's a chrome plugin that will tell you when the page you are looking at is not the latest
21:46:48 <ReinH> and give you a link to the latest
21:47:18 <jle`> i just set (current) haddocks as a search engine in chrome so i type `_h containers`
21:47:23 <kadoban> That sonuds fancy, probably wouldn't help me much though, despite this specific instance where it would have.
21:50:32 <ReinH> Right, probably not helpful except for when it is helpful
22:08:13 * hackagebot dhall-text 1.0.1 – Template text using Dhall – https://hackage.haskell.org/package/dhall-text
22:10:08 <Lokathor> :t [(1*),(2*)]
22:10:10 <lambdabot> Num a => [a -> a]
22:10:10 <orzo> are pastes announced?
22:10:21 <Lokathor> orzo, not lately
22:10:27 <Lokathor> :t (\(a:b:[]) -> (a,b)) [(1*),(2*)]
22:10:29 <lambdabot> Num a => (a -> a, a -> a)
22:10:32 <Axman6> they are if you select a channel
22:10:36 <Axman6> or, they used to be anyway
22:10:55 <orzo> I'm trying to understand how to use async-pool properly.  Could somehow have a look at this? http://lpaste.net/357207
22:11:16 <Lokathor> > let (a:b:[]) = [(1*),(2*)] in (a (5 :: Float), b (5 :: Int))
22:11:18 <lambdabot>  (5.0,10)
22:11:21 <orzo> Why does throwsBlocked throw an exception?
22:11:25 <Lokathor> so how does this work
22:11:53 <Lokathor> doesn't it have to select the same Num instance for both parts of the tuple?
22:12:49 <jle`> let polymorphism
22:13:02 <geekosaur> :t let x@(a:b:[]) = [(1*),(2*)] in x
22:13:03 <lambdabot> Num a => [a -> a]
22:13:14 <geekosaur> :t let x@(a:b:[]) = [(1*),(2*)] in a
22:13:16 <lambdabot> Num a => a -> a
22:13:20 <orzo> !seen johnw
22:13:41 <jle`> Lokathor: (a:b:[]) = [(1*),(2*)]  defines two polymorphic functions
22:14:02 <jle`> note that case statements don't have the same polymorphism in haskell
22:14:02 <Lokathor> but it reported Num a => (a -> a, a -> a), so should it be Num a, Num b => ...
22:14:27 <orzo> My code is throwing ThreadBlocked.  I'm trying to understand why
22:14:36 <jle`> > case [(1*),(2*)] of (a:b:[]) -> (a (5 :: Float), b (5 :: Int))
22:14:38 <lambdabot>  error:
22:14:38 <lambdabot>      • Couldn't match expected type ‘Float’ with actual type ‘Int’
22:14:38 <lambdabot>      • In the first argument of ‘b’, namely ‘(5 :: Int)’
22:15:02 <Lokathor> hmm
22:15:05 <Lokathor> how interesting
22:15:12 <Axman6> remember the functions must be the same type
22:15:15 <Axman6> in a list
22:15:42 <Lazersmoke> http://lpaste.net/357210
22:15:45 <Lokathor> so since the tuple pulled them out of the list, they can stay polymorphic for longer, and since they're out of the list, they can select their own instances now?
22:16:33 <geekosaur> I think this is controlled by MonoLocalBinds and it may be turned off in lb? so yes
22:16:41 <jle`> Lokathor: i think the entire binding is a polymorphic thing
22:16:53 <Axman6> :t let (a:b:[]) = [(1*),(2*)] in (a (5 :: Float), b (5 :: Int), a, b)
22:16:55 <lambdabot> (Num a, Num a1) => (Float, Int, a1 -> a1, a -> a)
22:17:06 <Axman6> hmm, interesting
22:17:38 <Lazersmoke> I feel like the constraints should still be inside the tuple, though
22:17:44 <jle`> so for the (a, b) example, the tuple itself is polymorphic, and you're using the fst of the Float-tuple and snd of the Int-tuple
22:18:07 <Lazersmoke> does GHCi just lift them out for display purposes?
22:18:21 <ReinH> jle`: case statements have exactly the same generality as non-recursive let bindings
22:18:22 <jle`> no, the constraints are outside of the tuple
22:18:30 <ReinH> since non-recursive let bindings desugar to case statements
22:19:13 <jle`> so how come the examples i gave behaved differently?
22:19:20 <ReinH> let p = e1 in e0 desugars to case e1 of ~p -> e0 when no variables in p are free in e1
22:19:26 <ReinH> At least, that's what the report says.
22:19:34 <jle`> > case [(1*),(2*)] of ~(a:b:[]) -> (a (5 :: Float), b (5 :: Int))
22:19:36 <lambdabot>  error:
22:19:36 <lambdabot>      • Couldn't match expected type ‘Float’ with actual type ‘Int’
22:19:36 <lambdabot>      • In the first argument of ‘b’, namely ‘(5 :: Int)’
22:20:19 <Lazersmoke> why does it float the forall/constraint out then? `(1*) :: forall a. Num a => a -> a`, so why doesn't `Identity (1*) :: Identity (forall a. Num a => a -> a)` and instead `Identity (1*) :: forall a. Num a => Identity (a -> a)`?
22:20:53 <jle`> :t Identity
22:20:54 <lambdabot> a -> Identity a
22:21:14 <ReinH> jle`: Hmm. https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12
22:21:41 <Lazersmoke> Identity is just `data Identity a = Identity a` or similar
22:21:51 <orzo> Is my paste a bug in async-pool and I should just give up on it? http://lpaste.net/357207
22:22:02 <ReinH> Oh, "This translation does not preserve the static semantics because the use of case precludes a fully polymorphic typing of the bound variables."
22:22:06 <ReinH> Fair play.
22:22:24 <Lazersmoke> question is, why don't constructors preserve polymorphism inside of them?
22:22:41 <ReinH> So let generalization does not apply to the case desugaring.
22:24:43 <jle`> Lazersmoke: feels like it'd be a hindley-milner thing
22:25:03 <lyxia> orzo: it may be a bug yes
22:25:16 <jle`> since hindley-milner is able to deal with the types of functions like Identity :: a -> Identity a 
22:25:22 <jle`> being applied to (forall b. b), for instance
22:26:02 <jle`> remember that `Identity x` is the application of a function to a value
22:27:06 <jle`> but at the same time, forall a. a -> (forall b. b -> X) is indeed the same as forall a b. a -> (b -> X)
22:27:22 <lyxia> Lazersmoke: It makes type inference tricky to allow polymorphic types as argument to type constructors, because then an expression may have many incompatible types.
22:28:22 * hackagebot sbp 2.2.9 – SwiftNav's SBP Library – https://hackage.haskell.org/package/sbp
22:30:27 <Lazersmoke> couldn't you just reorganize the types into normal form/when you infer, infer in normal form (normal form = big lambdas first, big lambdas in same order as first appearance of the tyvar)?
22:30:58 <Lazersmoke> or can you not do that if you don't know the full types up front?
22:36:28 <Maxdamantus> > let (a:b:[]) = [(1*),(2*)] in (a (5 :: Float), b (5 :: Int), a (5 :: Int), b (5 :: Float))
22:36:30 <lambdabot>  (5.0,10,5,10.0)
22:36:45 <Maxdamantus> as I suspected.
22:37:06 <jle`> all according to keikaku
22:37:59 <Maxdamantus> but I suspect this is due to nomonomorphismrestriction.
22:38:20 <Maxdamantus> Well, can always get around that.
22:38:58 <angerman> so we have something like <:> ? I often want do do something like (:) x <$> y, and x <:> y seems appropriate?
22:39:24 <jle`> nobody stopping you
22:39:26 <jle`> :)
22:39:34 <jle`> @let (<:>) = liftA2 (:)
22:39:35 <lambdabot>  Defined.
22:39:37 <angerman> jle`: ha, but maybe someone else already did?
22:39:42 <erisco> maybe you want idiom brackets
22:39:45 <jle`> ah sorry, i misread your post
22:39:54 <jle`> *message
22:40:14 <angerman> erisco: do I, I'm not so certain.
22:40:30 <angerman> :t (<:>)
22:40:31 <lambdabot> Applicative f => f a -> f [a] -> f [a]
22:40:53 <jle`> > Just 1 <:> Just [2,3,4]
22:40:55 <lambdabot>  Just [1,2,3,4]
22:41:05 <angerman> jle`: yea, but that's not what I want :)
22:41:09 <jle`> i don't think it's commonly used enough to require its own name, and especially an operator name
22:41:12 <erisco> yeah, because then you just write [i| x : xs |]
22:41:17 <angerman> > (:) 1 <$> Just [2,3,4]
22:41:19 <lambdabot>  Just [1,2,3,4]
22:41:32 <jle`> ah you wanted fmap . (:)
22:41:42 <erisco> oh I misread too
22:41:52 <jle`> yeah, i don't think that it's commonly used enough to require its own name
22:42:06 <jle`> and new operators are especially bad
22:42:26 <angerman> Alright, I'll stick with (:) x <$> y then.
22:42:30 <lyxia> Lazersmoke: indeed the question is how do you know in what order to put the lambdas for type inference
22:42:33 <jle`> the fairnbarn threshold arguments applied here, and doubly so with operators
22:42:37 <jle`> angerman: it'd probably use (x:) <$> y
22:42:49 <jle`> `(:) x <$> y` was admittedly a bit confusing to me
22:43:03 <angerman> jle`: ahh right. but that becomes harder to read if x is "long".
22:43:04 <jle`> and apparently to other parties as well
22:43:22 <angerman> jle`: yea, I guess we just saw that ;-)
22:44:11 <jle`> s/it'd/i'd
22:44:53 <wally1337> Is there much advantage to using haskell over say C?
22:44:58 <erisco> [i| pure x : xs |]  you can still do that, though
22:45:04 <jle`> wally1337: i would argue yes
22:45:12 <angerman> `(ArchiveEntry name time own grp mode st_size file :) <$> getGNUArchEntries extInfo` or `(:) (ArchiveEntry name time own grp mode st_size file) <$> getGNUArchEntries extInfo`? Which is more readable?
22:45:13 <erisco> I think? I don't know the in's and out's of it
22:45:42 <wally1337> jle` but doesn't haskell just boil down to C then machine code, so why not just use C?
22:45:57 <angerman> wally1337: it doesn't.
22:46:01 <jle`> wally1337: doesn't a car just boil down to metal and wheels
22:46:02 <kadoban> wally1337: Then why not just use the machine code? (also it doesn't)
22:46:05 <jle`> wy not just use metal and wheels
22:46:29 <jle`> wally1337: also, i assume you are using an IRC client right now to talk on this chat
22:46:35 <erisco> https://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/Control-Applicative-QQ-Idiom.html "does not apply to nested applications" so yes, you could do that
22:46:37 <jle`> why not just use telnet and the IRC protocol by hand? :)
22:46:53 <jle`> PRIVMSG #haskell like this
22:47:07 <glguy> jle`: because it's annoying to have to manually respond to all the PINGs in time
22:47:22 <ReinH> You use electricity? How curious.
22:47:31 <erisco> no no, the question wally1337 is why you stopped at C and not machine code
22:47:44 <erisco> you acknowledge C turns into machine code so why did you go back up to C?
22:48:03 <wally1337> Why would anyone use machine code anymore, C seems to be the sweet point
22:48:10 <erisco> why
22:48:12 <angerman> wally1337: haskell allows you to give the compiler a lot more knowledge about your program, much more than what C offers, and thus the compiler can use that knowledge to generate better machine code than what a C compiler ever could.
22:48:12 <jle`> hm, what sweet point do you mean?
22:48:33 <jle`> wally1337: it sounds like you are saying that C is a good balance between two competing forces, but what competing forces are you talking about?
22:49:05 <jle`> wally1337: to answer your original question, haskell offers big advantages in maintainability and productivity when writing code, productivity when refactoring and debugging code
22:49:33 <jle`> and much more guaruntees of compile-time program correctness
22:49:41 <ReinH> I find it hard to believe that anyone seriously holds this position. 
22:49:42 <angerman> erisco: yea that would be `(:) <$> pure x <*> xs`, I believe :)
22:49:44 <jle`> much more opportunities for safe code-reuse
22:50:01 <wally1337> Awesome then, I might have to dive in to it.
22:50:33 <kadoban> wally1337: C doesn't have a very good ability to abstract things, and the abstractions it does have tend to be dangerous and thin. IMO there's little reason to use it for most types of programs. The benefits it does have have very little to do with everyday programming in the vast majority of contexts.
22:51:08 <wally1337> What's a good dive in point for Haskell ( a good tutorial etc?)
22:51:09 <erisco> angerman, well it will be pure (:) <*> pure x <*> xs but it is all the same as (:) x <$> xs
22:51:36 <angerman> erisco: right.
22:51:45 <geekosaur> @where learnhaskell
22:51:45 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:51:51 <geekosaur> wally1337, ^
22:52:01 <kadoban> wally1337: I quite like http://haskellbook.com/
22:53:34 <erisco> I have never seen such a rapid turnaround from reductionism
22:54:08 <wally1337> Is it any good for AI?
22:54:28 <erisco> Haskell is a general purpose language, so sure
22:54:32 <MarcelineVQ> it's getting there, ML specifically, there's a library called grenade seeing some love
22:54:48 <kadoban> That's a good question. Being good for AI is probably about the libraries available more than anything.
22:54:58 <jle`> for AI you might run into some ecosystem issues
23:01:44 <wally1337> Isn't the functional programming paradigm more suited to ML/AI?
23:02:58 <jared-w> Functional programming is more declarative and mathematically based by nature, but I don't really see any reason that would intrinsically suit it for ML/AI
23:03:00 <glguy> It might be faster to try learning a bit than to guess about it
23:03:07 <[exa]> wally1337: that was logic programming afaik
23:03:18 <Axman6> Functional Programming is well suited to programming
23:03:32 <[exa]> wally1337: not to ML though
23:03:43 <[exa]> +1 Axman6
23:04:18 <Axman6> in the past there's been a lot of AI done in languages like lisp, but that's not because lisp is inherently well suited to AI
23:05:02 <kadoban> wally1337: I think that thought comes from lisps being historically quite commonly used in AI.
23:24:41 <zomg> anyone remember off the top of their heads if Pandoc projects tend to have files named in a certain way?
23:24:58 <zomg> I've misplaced files for one of my Pandoc things and I spent an hour looking for it... :D
23:25:22 <zomg> of course I checked the obvious ones like *.md for the entire damn PC but no luck
23:34:20 <Axman6> mine have usually been .md
23:34:40 <Axman6> but, I've never really had a pandoc "project".
23:48:48 <zomg> yeah project sounds too fancy :P it was just an md file that I converted into pdf
23:49:00 <zomg> but forget if pandoc produced any intermediary files or anything along the way
23:49:49 <Axman6> Not if you don't tell it to (or use LaTeX as an intermediate language or something)
23:51:21 <zomg> ok that's what I thought, thanks
23:52:26 <slack1256> easiest way to put some haskell on android?
23:52:42 <slack1256> java shims? webui with ghcjs?
23:53:00 <zomg> get job at google, work your way up to management, order them to add haskell support
23:53:23 <Axman6> before they kill off android because no one knows how to build it
23:53:29 <zomg> but yeah web ui would probably be easiest at least in terms that you don't actually need to compile any haskell targeting android specifically :P
23:53:55 <slack1256> I tried, but they didn't want to give me a H1b :-(
23:54:09 <Axman6> jerks
23:54:25 <slack1256> OK. web path it is then
23:57:35 <dbousamra> Hi all. I have 2 EitherT's. I want to run the first effect, ignoring the error (or success), and then run the 2nd and use that result. How do I combine them? What is the function?
23:58:56 <wz1000> dbousamra: runEitherT e1 >> e2 
23:59:14 <slack1256> dbousamra: you have `EitherT e1 (EitherT e2) a` or two different EitherT?
23:59:31 <slack1256> wz1000: that will not ignore an error on the first either
23:59:38 <wz1000> it will
23:59:55 <jle`> it might not typechecking, depending on dbousamra actually is saying
23:59:57 <wz1000> sorry, you need a lift
