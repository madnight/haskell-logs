00:00:37 <jle`> hm, i lie
00:00:53 <jle`> `MaybeT g` requires a Monad constraint on 'g' to give it an Alternative instance
00:01:06 <jle`> cause it short-circuits effects based on the result of g
00:01:51 <jle`> `ListT g` gives you an Alternative instance with only Alternative g but everyone knows ListT is bad or something
00:02:18 <jle`> *only Applicative g
00:02:58 <jle`> hm, ListT's Applicative instance is lawful, at least
00:03:04 <jle`> maybe only the Monad part of ListT is "bad"
00:04:40 <jle`> so maybe the Alternative instance ain't so bad either
00:22:37 <akagetsu01> morning o/
00:39:24 <Enamex> Is there any special procedure I need to step through to rename a Haskell project (managed by stack/cabal)?
00:39:48 <merijn> Enamex: You mean just locally, or one that's been released on Hackage?
00:40:02 <Enamex> Locally
00:40:58 <merijn> Enamex: Dunno about stack, but for cabal it's just a matter of renaming the cabal file and the package name inside it (actually, I even think renaming the cabal file is optional)
00:43:02 <geekosaur> if you are renaming directories, cabal and ghc files will likely need to be edited. stack may do this for you but may need some prodding
00:43:05 <bjarke> 2 /nick bvad
00:43:09 <bjarke> whoops 
00:43:33 <bvad> morning akagetsu01 o/
00:46:21 <Enamex> It requires that the package name and .cabal filename match exactly (also in case)
00:46:25 <geekosaur> (where by prodding I mean some variant of "stack clean". becuse ghc does like its full path names)
00:47:26 <Enamex> `stack clean` didn't do it sadly
00:47:38 <Enamex> Changing all occurences in .cabal manually did, though
00:49:06 <merijn> So...this hobbes thing is looking neat, anyone else have a look yet?
00:50:31 <Enamex> What's Hobbes?
00:52:04 <merijn> Enamex: A Haskell inspired "language, embedded compiler, and runtime for efficient dynamic expression evaluation, data storage and analysis" that Morgan-Stanley has apparently been working on
00:52:36 <Enamex> Knew I heard about this very recently but google didn't find anything that rang a bell
00:56:22 <statusbot> Maintenance update: Hackage going down, NOW! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/596c6bf049fc987f480003bf
00:58:07 <jle`> excited for this minor feature deployment
01:00:15 <cocreature> it would be nice to know what the feature is :)
01:00:16 * srhb cries
01:00:18 <srhb> My docs!
01:00:20 <srhb> :-P
01:00:27 <merijn> cocreature: I just asked hvr in #hackage :p
01:00:34 <merijn> cocreature: No answer yet, though :)
01:01:02 <statusbot> Maintenance update: Hackage up & fully operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/596c6bf049fc987f480003bf
01:01:06 <cocreature> merijn: huh? I’m in #hackage and I don’t see you asking
01:01:17 <srhb> Oh, that was fast, up again.
01:01:49 <geekosaur> they got confused, they're in #haskell-infrastructure
01:02:18 <cocreature> there are too many haskell channels
01:03:11 <merijn> cocreature: eh, haskell-infrastructure :)
01:18:30 <ertes-w> helo
01:25:05 <ertes-w> i said HELO
01:25:21 <ventonegro> OLEH
01:25:24 <mfukar> this isn't an SMTP server
01:33:04 <delYsid> Bah, haskell-mode is so trying to be far too much intelligent.
01:33:50 <ertes-w> delYsid: at what?
01:34:15 <delYsid> At being an emacs-mode :-)
01:46:56 <ertes-w> delYsid: i read that as criticism =)
02:49:04 <tdammers> as far as software goes, dumb and obedient is better than trying to be smart but failing at it
02:52:34 * hackagebot unboxed-ref 0.4.0.0 – Fast unboxed references for ST and IO monad – https://hackage.haskell.org/package/unboxed-ref
02:52:41 <geekosaur> amein v'amein
02:57:38 <CrackedCracker> hello. I feel retarded a little bit seems the question seems trivial, but i fail to answer it. At the very end of this section (https://en.wikibooks.org/wiki/Haskell/Monad_transformers#Implementing_lift) there is an exercise (the first one). After giving it some thought, it still seems to me that the answer would be that the only reason why it isn't possible is the lack of universal alias for constructor, but this seems to simple to be true. May I 
02:57:38 <CrackedCracker> ask for a hint from you?
02:58:15 <CrackedCracker> oh, missed "as" in the first sentence
02:58:47 <geekosaur> someone's spillchucker didn't think 'whereas' is a word...
02:59:55 <ongy> spellchucker? that was good timing for a typo
03:00:20 <geekosaur> CrackedCracker, it's not just that; there's no rule saying that there is only _one_ such constructor. (Consider the free monad.)
03:00:47 <geekosaur> ongy, that's sort of a deliberate "typo" intended to highlight the shortcomings of spell checkers
03:01:01 <mniip> that question doesn't sound good to me
03:01:31 <mniip> I mean, I'm not sure I see the intended answer and what utility would such an answer have
03:02:46 <CrackedCracker> geekosaur, thanks, understood
03:03:50 <Enamex_> Why are the logical binding operators right associative in Haskell?
03:03:52 <Enamex_> http://kevincantu.org/code/operators.html
03:04:27 <mniip> Enamex, because that better suits laziness
03:04:29 <MarcelineVQ> becuse when you evaluate outside-in it lets you short circuit
03:05:09 <mniip> MarcelineVQ, with left association you can do that as well
03:05:15 <mniip> but there's extra hoops to jump through
03:05:24 <Enamex> This feels like the confusion I had with foldr/foldl. Getting back to that in a while...
03:05:35 <Enamex> mniip: How?
03:06:04 <mniip> to evaluate True || (x || y) it suffices to enter the outer ||
03:06:16 <mniip> it will evaluate True and return a result immediately
03:06:42 <mniip> (True || x) || y on the other hand, the outer || will have to return an application of the inner ||
03:07:03 <mniip> (...(True || a) || b...) || z takes linear time
03:07:23 <mniip> whereas True || (a || (... || z)...) takes constant time
03:10:53 <Enamex> I guess it's cause, intuitively, I see the inner parenthetical and that has the priority. It never occurs to me that the language needs to worry about the outer expressions before evaluating the inner expressions
03:11:23 <mniip> a lazy language does exactly that
03:11:30 <Enamex> But deferred evaluation means that we really only have the outer expression. That's our thunk.
03:11:35 <mniip> a call by value language evaluates the inner expresisons first
03:12:10 <Enamex> then how does a lazy language does exactly that?
03:13:07 <geekosaur> examine outer expression; see that an inner expression needs to be evaluated, push outer on pattern stack and evaluate inner
03:13:11 <Enamex> Wait. Cause the left associative expression doesn't know that the whole chain up is of the same operator. Or something like that.
03:13:11 <geekosaur> repeat as deeply as needed
03:13:52 <geekosaur> where 'needs to be evaluated' means to WHNF: to a lambda or a constructor
03:19:17 <Sornaensis> guys I did it
03:20:29 <cocreature> congratulations
03:20:47 <mniip> ngratulations
03:23:07 <Sornaensis> thank you
03:23:29 <Cale> Enamex: Yeah, when you have an expression like f (g (h x)), what happens is that first f is evaluated enough that it's a lambda (which for most functions doesn't involve doing much), and then the body of f is entered, with its parameter bound to the as-yet-unevaluated expression g (h x).
03:24:06 <Cale> Enamex: Apart from the "figure out which function f is" bit, this doesn't make use of the stack.
03:25:03 <Cale> Now, f might immediately pattern match on its argument, in which case, that pattern match will wait on the stack while g (h x) gets evaluated enough to match one of the patterns
03:26:15 <Cale> But it might also just choose to discard the g (h x), or it might include it as part of its result without matching on it
03:27:23 * hackagebot persistable-record 0.5.0.2 – Binding between SQL database values and haskell records. – https://hackage.haskell.org/package/persistable-record
03:28:56 <Cale> Enamex: still here?
03:29:04 <Cale> @src foldl
03:29:04 <lambdabot> foldl f z []     = z
03:29:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:29:13 <Enamex> Cale: Yupe :)
03:29:15 <Enamex> *Yup
03:29:21 <Cale> ^^ you might notice that foldl does nothing but apply itself to new arguments until it reaches the end of the list
03:29:49 <Cale> f never gets to do anything until it's done traversing the entire list
03:30:53 <Cale> (or at the very least, it can't convince the foldl to stop, even if we did evaluate the (f z x) subexpression earlier than we needed to)
03:30:58 <Cale> @src foldr
03:30:58 <lambdabot> foldr f z []     = z
03:30:58 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:31:09 <Cale> By contrast, foldr immediately passes control to f
03:31:24 <Cale> Only if f pattern matches on its second argument will the foldr proceed any further
03:32:06 <Cale> So this lets us do things like process infinite lists
03:32:19 <Cale> > foldr (\x xs -> 2*x : xs) [] [0..]
03:32:21 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
03:32:43 <mniip> the ability to do that ^ does not follow from what you said though
03:32:51 <mniip> try
03:33:18 <Cale> It kind of does :)
03:33:19 <mniip> > foldr (\x xs -> if x < 5 then x:xs else []) [] [0..]
03:33:21 <lambdabot>  [0,1,2,3,4]
03:33:58 <Cale> > foldr (\x r -> if x > 100 then Just x else r) Nothing [0..]
03:34:00 <lambdabot>  Just 101
03:34:36 <Cale> That's perhaps the simplest sort of example -- just bailing out immediately
03:35:07 <mniip> fun part: once Just 101 is produced it doesn't traverse 100 stack frames back
03:35:51 <Cale> correct, because there are no stack frames for the function entries, only pattern matches
03:36:26 <pacak> I wanted to ask a question, but by the time I finished typing it I already knew the answer. Thank you guys for your help. http://i.imgur.com/4ysHjNl.gifv
03:36:29 <Cale> (and, well, there are a few other things, but pretty much pattern matches)
03:36:39 <pacak> (it worked)
03:37:31 <Cale> pacak: Loading Ready Run is great :)
03:37:34 <Enamex> Pattern matches as in deferred expressions that may get asked to present a final value?
03:37:46 <Enamex> That's incredible, all in all. Thanks so much.
03:38:46 <Cale> Enamex: Pattern matches as in case expressions
03:39:46 * hackagebot relational-query 0.9.2.1 – Typeful, Modular, Relational, algebraic query engine – https://hackage.haskell.org/package/relational-query
03:39:46 <Enamex> Am I correct to read foldl that it has to traverse the list ->, then it has to evaluate the value of the last function application (cause it doesn't recurse anymore and returns just z), which needs the application of the previous call and so on. So it's like -> to end, <- to beginning (of unevaluated nested function calls) then -> to end (as the calls get evaluated)?
03:40:07 <pacak> (the answer was - you don't need transformers to compose functors, in your case Foo a is Compose Maybe t a)
03:40:17 <Cale> Enamex: I don't quite understand that description
03:40:21 <Enamex> Cale: You mentioned it alongside 'stack frames' so I thought you were referring to something in the implementation.
03:40:24 <Cale> Let me just write you out an example
03:40:33 <Cale> foldl (+) 0 [1,2,3]
03:40:40 <Cale> -> foldl (+) (0 + 1) [2,3]
03:40:48 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
03:40:59 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
03:41:08 <Cale> -> ((0 + 1) + 2) + 3
03:41:52 <Cale> Up to this point, the stack hasn't been used at all (given that the list we passed to foldl was already evaluated, so foldl's match on [] or (x:xs) was able to finish immediately
03:42:08 <Cale> But now, the outermost (+) is going to happen
03:42:54 <Cale> Without looking at the details of the source code of (+) (it's implemented with primitive operations anyway), we can imagine that it's going to need to pattern match on both its arguments in general
03:43:21 <Cale> So, the pattern match inside (+) will wait on the stack while its left argument gets evaluated.
03:43:31 <Cale> So now we evaluate (0 + 1) + 2
03:43:51 <Cale> and similarly, the pattern match in the outermost (+) there will wait on the stack while we evaluate 0 + 1
03:44:03 <Cale> and 0 + 1 will evaluate to 1
03:44:09 <Cale> and then 1 + 2 will evaluate to 3
03:44:15 <Cale> and 3 + 3 will evaluate to 6
03:46:20 <Cale> Enamex: Make sense?
03:47:05 <Cale> Enamex: When evaluation is outermost-first, you don't need to put something on the stack when you apply a function because the result of the function application is going to the same place as the result of the whole expression.
03:50:19 <Cale> Now, this will be affected by the subtlety that evaluation in GHC isn't quite this straightforward -- especially if you have -O turned on, it will often force the evaluation of subexpressions earlier, whenever it can prove that it absolutely must need them.
03:51:01 <Cale> But to a first approximation, just pretending it's lazy evaluation will usually do. :)
03:53:57 <Enamex> foldr was quite easy to visualize. foldl not as seemly :T
03:54:12 <Enamex> Cale: but yeah that makes a lot of sense
03:54:20 <Enamex> Thanks a lot :D
03:54:23 <Cale> no problem
04:07:16 <ertes-w> Enamex: you might find it useful to write foldl in terms of foldr
04:09:43 <Enamex> I'll try that in a bit.
04:17:24 <kuribas> > foldr (⊕) 0 [3, 2, 1]
04:17:26 <lambdabot>  3 ⊕ (2 ⊕ (1 ⊕ 0))
04:17:48 <kuribas> > foldl (⊕) 0 [1, 2, 3]
04:17:50 <lambdabot>  ((0 ⊕ 1) ⊕ 2) ⊕ 3
04:20:32 * hackagebot relational-schemas 0.1.3.4 – RDBMSs' schema templates for relational-query – https://hackage.haskell.org/package/relational-schemas
04:23:36 <nullx002> hi
04:23:42 <nullx002> GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
04:23:42 <nullx002> ghc: unable to load package `ghc-prim-0.4.0.0'
04:24:06 <nullx002> while ghc hello.hs compiles ok but ghci doesn't work
04:34:02 <nullx002> anybody?
04:34:17 <Cale> nullx002: That's a rather old version of ghc
04:34:35 <Cale> But... it looks like it's installed incorrectly
04:35:07 <phadej> or then it's related to runtime linker
04:35:30 <phadej> (e.g. Arch Linux bugtracker has such errors)
04:37:10 <phadej> also windows & os x break things so old GHC stop working :S we need more info to be able to help
04:38:42 * hackagebot relational-query-HDBC 0.6.1.2 – HDBC instance of relational-query and typed query interface for HDBC – https://hackage.haskell.org/package/relational-query-HDBC
04:42:28 <nullx002> phadej: i am on bsd
04:42:38 <cocreature> which bsd?
04:42:40 <nullx002> so have that version available
04:42:43 <nullx002> openbsd
04:43:24 <nullx002> could it be path problem?
04:43:37 <nullx002> it is /usr/local/lib/ghc/
04:44:22 <nullx002> i tried ports for stack but it is not compiling
04:44:33 <nullx002> cabal is working ok.
04:44:42 <nullx002> everything is good just ghci throws that error
04:44:50 <lumimies> Hi, I've got a question about pipes: how can I do: Producer x (ReaderT a (ReaderT b m)) () -> Producer x (ReaderT b (ReaderT a m)) () ?
04:45:23 <lumimies> Switch around the transformers in the monad the pipe is over, that is
04:45:47 <cocreature> lumimies: do you know how to write a function "ReaderT a (ReaderT b m) r -> ReaderT b (ReaderT a b m) r"?
04:47:02 * hackagebot relational-query-HDBC 0.6.2.1 – HDBC instance of relational-query and typed query interface for HDBC – https://hackage.haskell.org/package/relational-query-HDBC
04:48:02 <lumimies> cocreature: I think I can manage that
04:48:19 <lumimies> cocreature: It's basically flip though :P
04:48:45 <cocreature> yeah it’s similar
04:49:06 <cocreature> lumimies: so write that function and then use hoist https://hackage.haskell.org/package/mmorph-1.1.0/docs/Control-Monad-Morph.html#v:hoist
04:49:13 <cocreature> and you’ll have one that operates on Producer
04:51:15 <lumimies> cocreature: Thanks!
04:53:51 * hackagebot persistable-types-HDBC-pg 0.0.1.5 – HDBC and Relational-Record instances of PostgreSQL extended types – https://hackage.haskell.org/package/persistable-types-HDBC-pg
04:58:54 <nullx002> where is ghc-prim is it part of ghc binary?
05:02:32 <nullx002> is it a dynamically loaded library?
05:05:07 <Enamex> ertes-w: No luck so far
05:08:15 <ertes-w> Enamex: http://ertes.eu/tutorial/foldr.html#stateful-folds
05:13:11 <nullx002> ghci is working on amd64 but not on i386... 
05:19:54 <Axman6> lumimies: looks a lot like applying traverse to the monadic parameter to the producer
05:20:06 <Axman6> or, more like sequence
05:20:22 <Cale> lumimies: I would tend to want to ask why that matters.
05:20:25 <Axman6> :t sequence :: ReaderT a (ReaderT b IO) c
05:20:26 <lambdabot> error:
05:20:27 <lambdabot>     • Couldn't match expected type ‘ReaderT a1 (ReaderT b1 IO) c1’
05:20:27 <lambdabot>                   with actual type ‘[m0 a0] -> m0 [a0]’
05:20:45 <Cale> i.e. Why do you want this operation in the first place?
05:20:46 <Axman6> :t sequence `asAppliedTo` (undefined :: ReaderT a (ReaderT b IO) c)
05:20:48 <lambdabot> (Monad m, Traversable (ReaderT a1 (ReaderT b IO))) => ReaderT a1 (ReaderT b IO) (m a) -> m (ReaderT a1 (ReaderT b IO) a)
05:20:56 <Cale> It looks really suspicious to me! :)
05:21:16 <Axman6> hmm, maybe not
05:22:15 <cocreature> even ReaderT a (ReaderT b IO) c is kind of a weird type since most of our typeclass machinery only works nicely if there is only one reader
05:22:23 <cocreature> otherwise you end up having to manually lift and annoying stuff like that
05:22:32 <cocreature> ReaderT (a,b) IO c is usually a lot nicer to work with
05:23:08 <Cale> nullx002: On linux, my ghc-prim is at /usr/local/lib/ghc-8.0.2/ghc-prim-0.5.0.0/ which is a directory containing a couple of .a files for static linking, and a .so for dynamic linking.
05:25:03 <Cale> cocreature, lumimies: Another thing I would generally recommend is rather than using ask (or other mtl class operations) directly, invent a type class containing operations which are meaningful in your application, and write instances for that
05:25:50 <Cale> (Of course, you implement the reader-y ones in terms of ask, if that's what you're doing)
05:26:17 <cocreature> most of my uses of reader are simple enough that I don’t think making up a new type class is worth the effort
05:26:23 <cocreature> but yeah for more complex uses that makes sense
05:26:31 <lumimies> Cale: You're right, I've got a sticky monad stack going. And I'm clearing it up, just as you say
05:27:15 <Cale> I dislike the term "monad stack" because if you have to think of a stack of monads being built up successively by various transformers, rather than just the monad which is the end result, you are doing something wrong
05:29:35 <ertes-w> much like "sin (exp (x^2))" is not a stack of values, but a sequence of transformations of a value
05:30:15 <ertes-w> you don't say "sin on top of exp on top of square on top of 2"…  you say "sin of exp of square of 2"
05:30:29 <Cale> and you would usually just think of it as some number
05:31:41 <petercommand> monad stack is an effect stack just like (sin . exp) is a transformation stack
05:32:11 <lumimies> Cale: I'm trying to use Mongo and Sqlite at the same time, and the libraries both have some expectations from me
05:32:56 <DollyDuplex> so apparently i'm too dumb to use parsec. when i do: parse (notFollowedBy $ char 'x') "" "x"   -- then it says "unexpected 'x' in column 2", when it's clearly in column 1. i'm probably missing a fixup function ('try'?) somewhere, yeah?
05:37:52 <lyxia> DollyDuplex: you're doing fine
05:38:10 <lyxia> it's just a consequence of the implementation of notFollowedBy
05:38:26 <lyxia> which throws an error *after* successfully parsing x
05:39:06 <DollyDuplex> i was afraid of that... so there's really nothing to be done?
05:42:25 <DollyDuplex> you'd think it would keep the original position on record for error reporting purposes, but i guess i'll have to run with it
05:42:47 <DollyDuplex> of course if they ever "fix" this, my unit tests will fail ;)
05:42:59 <lyxia> you might want to open an issue about this
05:43:20 <DollyDuplex> hmm, i suppose
05:43:34 <cocreature> parsec development is pretty much dead afaik so that probably won’t help
05:43:41 <cocreature> it looks like megaparsec correctly reports column 1
05:43:47 <lyxia> Isn't there a combinator for the current position though?
05:43:48 <cocreature> so you could consider switching
05:45:41 <DollyDuplex> hmm, looking at the source, notFollowedBy is pretty much a one-liner. i suppose i could just roll my own version of that one function :P
05:46:15 <Enamex> ertes-w: I don't get what's happening at `append2`
05:46:46 <ertes-w> Enamex: you may have to start earlier in the tutorial…  it explains a very specific method to derive folds
05:46:58 <ertes-w> Enamex: in fact you may just want to start at the top
05:47:18 <Enamex> Oh. I thought you linked to that part specifically
05:48:03 <Enamex> Just in case though, what does your convention here mean:
05:48:04 <Enamex> append xs ys = foldr _f _z xs
05:48:07 <ertes-w> Enamex: i did, but if you're not familiar with the way equational reasoning is used, you should start earlier =)
05:48:43 <ertes-w> Enamex: this is an equation with two unknowns
05:48:55 <ertes-w> Enamex: the unknowns are always with a leading underscore
05:51:24 <Enamex> Oh I see
05:54:48 <mniip> how would you shuffle a deck of cards in haskell for a toy program
05:54:58 <mniip> should I use the IO random or pass seeds around?
05:55:25 <EvanR> download the shuffle package :)
05:55:35 <mniip> nu
05:56:24 <EvanR> a way to write random programs that didnt involve monads or careful generator management would be nice
05:58:23 <Cale> EvanR: What would that look like?
05:58:25 <cocreature> write random programs using … MAGIC!
05:58:48 <pacak> https://xkcd.com/221/
05:58:49 <Entroacceptor> random = 4 or unsafePerformIO :D
05:59:17 <mniip> I was considering unsafeperformio
05:59:42 <cocreature> and then you screw up unsafePerformIO and your prng be evaluated only once and you have the same random number everywhere
05:59:44 <mniip> let it inline so that all numbers are fours
05:59:46 <Entroacceptor> Or just generate a list of random numbers at the start and pass it around
06:00:01 <mniip> btw
06:00:03 <Cale> cocreature: moreover, that number happens to be 4
06:00:19 <mniip> I brought up forall-exists telescopes earlier
06:00:33 <mniip> I was reminded about the "game" analogy in theorem proofs
06:01:01 <mniip> and realized that in game theory, a strategy is just a possibly unbounded telescope
06:01:23 <mniip> could be defined with an inductive existential
06:01:45 <cocreature> Cale: well 4 is guaranteed to be random so in that case it’s not a problem. but it could also be something completely wrong like 5!
06:06:39 <Cale> Annoying puzzle: find a value we can pass to mkStdGen so that the first Integer result produced by 'random' is 4.
06:08:35 <mniip> @check \x -> fst (random (mkStdGen x)) /= 4
06:08:37 <lambdabot>  +++ OK, passed 100 tests.
06:08:42 <mniip> I conjecture there is no such number
06:09:04 <Entroacceptor> TDD has spoken.
06:09:09 <MarcelineVQ> 100 tests aught to be good enough for anybody
06:10:31 <mniip> lambdabot can't find any
06:13:48 <clamchowder> Question: in ghci I can type
06:14:06 <clamchowder> > 5 / 6 :: Ratio Int
06:14:08 <lambdabot>  5 % 6
06:14:40 <clamchowder> but with the following i get an error:
06:14:51 <clamchowder> > (5 :: Int) / (6 :: Int) :: Ratio Int
06:14:53 <lambdabot>  error:
06:14:53 <lambdabot>      • Couldn't match expected type ‘Ratio Int’ with actual type ‘Int’
06:14:53 <lambdabot>      • In the expression: (5 :: Int) / (6 :: Int) :: Ratio Int
06:14:55 <clamchowder> Why?
06:15:39 <Sampuka> > (5 :: Num) / (6 :: Num) :: Ratio Int
06:15:41 <lambdabot>  error:
06:15:41 <lambdabot>      • Expecting one more argument to ‘Num’
06:15:41 <lambdabot>        Expected a type, but ‘Num’ has kind ‘* -> Constraint’
06:15:51 <Sampuka> ohehm
06:16:04 <mniip> clamchowder, such is the type of /
06:16:04 <Cale> Num isn't a type
06:16:22 <mniip> clamchowder, (/) :: Fractional a => a -> a -> a
06:16:28 <MarcelineVQ> Interesting that the error isn't that you're using  /  with Int, in your first example your numeric literals are polymorphic so it's fine
06:16:47 <mniip> clamchowder, you insist on a ~ Int, which breaks because Int is not Fractional
06:17:11 <mniip> as MarcelineVQ describes, in the first example 5 :: Ratio Int
06:17:39 <mniip> :t _ / _ :: Ratio Int
06:17:40 <lambdabot> error:
06:17:40 <lambdabot>     • Found hole: _ :: Ratio Int
06:17:40 <lambdabot>     • In the first argument of ‘(/)’, namely ‘_’
06:18:26 <clamchowder> OK I get it thanks :)
06:19:09 <clamchowder> > (5 :: Int) % (6 :: Int) :: Ratio Int
06:19:11 <lambdabot>  5 % 6
06:19:46 <clamchowder> so I should have used % instaed of /
06:21:00 <max3> how do i test if a project type checks without compiling? i remember seeing that somewhere
06:21:02 <mniip> that works because
06:21:04 <mniip> :t (%)
06:21:05 <lambdabot> Integral a => a -> a -> Ratio a
06:21:46 <clamchowder> mniip: Yup
06:23:23 <cocreature> max3: ghc has an -fno-code option to skip any code generation
06:23:39 <max3> ie TH or do you mean binary?
06:24:11 <cocreature> theoretically it shouldn’t skip TH. practically it’s currently broken and doesn’t work with TH :/
06:24:40 <max3> lol well then that's out
06:25:09 <cocreature> so if you’re using TH then there is not really any way to skip code generation afaik
06:26:13 <max3> when you say code what do you mean
06:26:22 <max3> actual lexemes or assembly?
06:26:32 <cocreature> assembly
06:26:46 <Enamex> There's also a bunch of other flags -C, -c and -S that could maybe do something but I can't get 'em to work
06:27:13 <Enamex> And someone had reocmmended using ghcid for checking instead
06:27:49 <max3> man compilation speeds are a pain
06:28:08 <cocreature> -O0 already helps a lot
06:28:19 <MarcelineVQ> should try ghcid if you haven't tried it before, it's kind of amazing
06:28:23 <cocreature> and yeah ghcid is pretty convenient
06:29:24 <max3> interesting
06:29:29 <max3> i will indeed try it
06:29:54 <cocreature> it’s not much more than ghci + autoreload but it’s surprisingly nice to use
06:30:05 <max3> i mean it's basically webpack dev server :)
06:30:08 <MarcelineVQ> I like it because it 'just works'
06:30:10 <max3> which is very nice
06:30:56 <cocreature> MarcelineVQ: you’d be surprised by how good I am at breaking ghci and thereby also ghcid :)
06:31:08 <merijn> MarcelineVQ: It doesn't seem to support a way to, e.g. query the type of an expression?
06:31:35 <MarcelineVQ> it's not especially interactive, you can pop in a  :: _  where you need to though
06:32:46 <toad__> How can i figure out what version of "directory" e.g. System.Directory that I have installed? some of the functions in the docs doesn't seem to available for me
06:33:19 <max3> haskell would be great if the ergonomics were just a tiny bit better and then there would be more contributors and then everything would be wonderful
06:33:23 <Cale> ghc-pkg list directory
06:33:28 <cocreature> toad__: ghc-pkg field directory version
06:33:44 <cocreature> make sure to wrap that in cabal exec or stack exec if you’re using sandboxes or stack
06:34:37 <toad__> "stack exec --" worked. I'm surprised that creating symlinks is not supported with ghc 8.0.2 ...
06:34:41 <max3> (nix v. cabal sandbox v. stack being one of them problems)
06:34:50 <merijn> MarcelineVQ: That doesn't help trying to figure out what specific identifiers are, though :)
06:35:07 <merijn> max3: You forgot cabal new-build
06:35:16 <max3> what the hell is that
06:35:23 <barrucadu> It's like cabal build but newer
06:35:46 <max3> lol
06:35:58 <Cale> toad__: You can probably do that using the unix package.
06:37:01 <merijn> max3: Basically, the future replacement of "cabal build" which uses Nix-style package management
06:37:04 <cocreature> directory should also be upgradable and not be tied to your ghc version iirc
06:37:14 <cocreature> at least as long as you don’t depend on the ghc package itself
06:37:17 <merijn> max3: So You won't have to mess around with sandboxes anymore and things "just work"
06:37:24 <werner___> Hi, when trying to use lambdacube-gl with stack, I run into a bunch of these: https://paste.gnome.org/pneomtzyq Where do I add that -fPIC option? Adding it to my ghc-options in the stack.yaml seems to have no effect.
06:37:29 <max3> that's like the promise of fusion
06:37:31 <cocreature> merijn: except all tooling which is now broken and doesn’t work :)
06:37:35 <merijn> max3: It needs a bit of work to fix up all the tooling to support it, though ;)
06:37:37 <max3> in the next thing "things will just work"
06:37:52 <merijn> cocreature: Well, I figure if I get enough people to be into new-build, someone will fix it :p
06:38:04 <merijn> cocreature: My attempts have so far failed and I can't invest more time into fixing it :)
06:39:22 <cocreature> merijn: crap so my plan to get you to fix the tooling for me failed
06:40:51 <merijn> cocreature: I invested about 1.5 weeks into fixing hdevtools and another week or so working with dxg to get ghc-mod to work. I didn't manage and I have a paper deadline + end of phd looming ahead, so I can't invest more time:)
06:41:16 <cocreature> merijn: so just finish that phd fast and then you have lots of time to fix this for me!
06:46:57 <jonge> hi there. does stack provide some flag that i can check globally, so that ALL haskell libraries are built both as static and dynamic?
06:47:12 <jonge> ..so that i can switch between static/dynamic builds for different paps
06:47:13 <jonge> *apps
06:50:49 <max3> why am i getting these errors on loading into ghci?
06:50:50 <max3> https://apaste.info/Ar4L
06:51:38 <Axman6> have you included the packages those modules come from in your cabal file?
06:51:42 <Axman6> and are they isntalled?
06:51:55 <ertes-w> mniip: i would pass shuffled decks around
06:52:25 <ertes-w> mniip: if you need to shuffle deeper within the code i would pass a shuffling action around
06:52:45 <ertes-w> mniip: f :: (Monad m) => m (Seq Card) -> m Y
06:53:28 <lumina_> Hi people, I have a question regarding classy-prelude library: How to build a Set? I tried to do `fromList [1, 2, 3] :: Set Int` but it says "No instance for (IsSequence (Set Int))"
06:54:10 <max3> Axman6, well i can do cabal build successfully
06:54:37 <Axman6> hmm, do you need to add -package Foo -package Bar to get ghci to use them?
06:54:43 <Axman6> alternatively, cabal repl should work
06:55:07 <max3> nope
06:55:17 <max3> same errors
06:55:26 <Axman6> no idea then
06:55:40 <Gurkenglas> mniip, Control.Monad.Random.Class lets you limit IO to the parts of it needed for randomness. 
06:56:08 <Enamex> Can I view the source of a function I defined in GHCi somehow?
06:59:07 <cocreature> Enamex: no
06:59:57 <lumina_> answering my own question regarding building a Set: turned out there is a function `setFromList` that does what I need.
07:01:14 <cocreature> max3: do you get the same errors when trying to use -package or when trying to use cabal repl? you really should be using cabal repl in this case
07:01:29 <max3> well i was trying to use ghcid
07:02:02 <cocreature> ghcid can use cabal repl
07:02:17 <cocreature> but try to get cabal repl working first and then you can figure out how to get ghcid working
07:03:02 <max3> cabal repl gives me a different set of "cannot find module"
07:03:28 <max3> https://apaste.info/iY4e
07:03:48 <cocreature> have you tried doing what it tells you to do? :)
07:04:04 <max3> sure i considered doing that
07:04:08 <max3> but why does cabal build work?
07:04:59 <max3> those things are in my .cabal though
07:05:01 <max3> https://github.com/databrary/databrary/blob/master/databrary.cabal
07:05:08 <max3> e.g. range-set-list
07:05:11 <max3> blaze-html
07:05:43 <cocreature> ah it’s probably picking up the wrong target
07:05:48 <cocreature> try "cabal repl databrary"
07:05:48 <max3> yes
07:06:01 <max3> lol
07:06:05 <max3> fPIC error
07:06:44 <max3> https://apaste.info/LemB
07:08:00 <cocreature> getting ghci to work with foreign libraries is always a pain ime :/
07:08:39 <max3> cabal build --ghc-options=-fPIC
07:08:40 <max3> desn't fix
07:08:50 <max3> cabal repl databrary gives me the same error
07:09:30 <mniip> does state have a sort of 'local' combinator like reader does?
07:13:36 <petercommand> mniip: by default, I don't think so, but it should be easy to create one
07:19:25 <hallllooo> Hi, hope someone can shed some light for me, I'm trying to fix someone elses code, i have the following snippet, but I keep getting 'last statement in a do must be an expression' 
07:19:28 <hallllooo> cx :: Parser
07:19:31 <hallllooo> cx = do dd <- code3
07:19:33 <hallllooo>             do dde <- cw
07:19:36 <hallllooo>                 digit
07:19:38 <hallllooo>                 ddd <- many (do digit)
07:19:41 <hallllooo>                     q <- cy
07:19:43 <hallllooo>                     return (q : "ss")
07:19:46 <hallllooo> Any ideas? 
07:19:48 <Axman6> :'(
07:19:52 <glguy> hallllooo: use a pastebin
07:19:55 <Axman6> please do not paste code into irc
07:20:00 <hallllooo> oh i do apollogise
07:20:09 <hallllooo> sorry
07:20:10 <Axman6> @where lpaste
07:20:10 <lambdabot> http://lpaste.net/
07:20:12 <hallllooo> thanks
07:20:27 <hallllooo> sorry, what a faux pas, i'm new, sorry again
07:20:40 <Axman6> that code looks quite broken, the the indentation is all over the place
07:20:46 <Axman6> and lots of redundant do's
07:20:47 <hallllooo> http://lpaste.net/356981
07:20:50 <[exa]> hallllooo: looks more like indentation problem
07:21:15 <hallllooo> oh right, thanks, it's indentation! 
07:21:29 <hallllooo> i did mess around a bit with that but didn'\t get it to work, will try again
07:21:31 <[exa]> hallllooo: I'd start with squashing all of it to one do block and see
07:21:55 <Axman6> hallllooo: refrash that page, I've made an annotated version which hopefully works
07:22:00 <Axman6> refresh*
07:22:46 <hallllooo> hey that got it !much appreciated
07:22:56 <hallllooo> thanks Axman6 
07:22:57 <hallllooo> and all
07:28:42 <Axman6> no worries
07:39:29 <tefter> ghc in Arch still can't compile hello world ;p
07:40:48 <tefter> Failed to read "target word size" value "@TargetWordSize@" this is error I get when trying to compile ghc devel snap
07:40:57 <Enamex> Is there someway to have GHCi print the inferred types of subexpressions?
07:41:24 <[exa]> Enamex: maybe assign type :: _ to the subexpression
07:42:04 <Enamex> I tried that. It gives an error and the message isn't very helpful
07:42:16 <yushyin> tefter: works for me
07:42:19 <Enamex> Ah, there's something about "partial type signatures"
07:42:21 <yushyin> tefter: echo 'main = putStrLn "Hello World"' > hw.hs && ghc -dynamic hw.hs && ./hw
07:44:17 <Enamex> It doesn't tell me which is which
07:44:43 <srhb> Enamex: Which is which? 
07:45:18 <srhb> Enamex: If you have multiple, you can name the holes _foo _bar etc.
07:45:48 <Enamex> It shows warnings for finding "type wildcards". I have several in my signature. It mentions "standing for" a certain inferred type but doesn't say which hole it is talking about
07:45:53 <Enamex> Oh
07:48:05 <Enamex> OK. Something that passes without any typing doesn't pass when I add some 'holes'. I think I'm misunderstanding this hole business
07:48:54 <srhb> Enamex: Example?
07:49:18 <Enamex> foldr (\(x::_x) (more::_more) (ys::_ys) -> x : more ys)
07:49:25 <Enamex> foldr (\(x) (more) (ys) -> x : more ys)
07:49:30 <Enamex> > foldr (\(x::_x) (more::_more) (ys::_ys) -> x : more ys)
07:49:32 <lambdabot>  error:
07:49:32 <lambdabot>      • Couldn't match expected type ‘_ys -> [_x]’
07:49:32 <lambdabot>                    with actual type ‘_more’
07:49:43 <Enamex> > :t foldr (\(x) (more) (ys) -> x : more ys)
07:49:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:49:55 <Enamex> > foldr (\(x) (more) (ys) -> x : more ys)
07:49:57 <lambdabot>  error:
07:49:57 <lambdabot>      • No instance for (Typeable t0)
07:49:57 <lambdabot>          arising from a use of ‘show_M727924101885740392930419’
07:50:21 <Enamex> Um. lambdabot is...
07:50:27 <srhb> Different. ;-P
07:50:33 <tefter> hm what's bout dynamic?
07:51:21 <tefter> but cabal does not works anyway
07:51:28 <tefter> cannot find dependencies
07:52:11 <srhb> Enamex: I think you're inadvertently constraining the type too much here, which isn't exactly obvious. It would probably be easier to use regular holes here
07:52:22 <tefter> with -static it fails
07:52:29 <tefter> with dynamic it passes
07:52:41 <Enamex> srhb: Regular holes?
07:53:00 <Enamex> I wonder how. Shouldn't a type name just match whatever comes its way?
07:54:13 <yushyin> tefter: I installed a local ghc with stack for static compilations
07:54:40 <srhb> Enamex: Yes, but if they are constrained, going from Num a => a to Int for instance, you're losing polymorphism
07:54:55 <srhb> Enamex: I'm not sure to be honest.
07:55:39 <Enamex> > :t foldr (\(x::_x) (more) (ys::_ys) -> x : more ys)
07:55:41 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:55:49 <Enamex> > foldr (\(x::_x) (more) (ys::_ys) -> x : more ys)
07:55:51 <lambdabot>  error:
07:55:51 <lambdabot>      • No instance for (Typeable _ys0)
07:55:51 <lambdabot>          arising from a use of ‘show_M461995946465200749630571’
07:56:12 <Enamex> Sigh. OK. This one that doesn't run on lambdabot at least doesn't error on my side
07:57:41 <tefter> yushun I don't use stack
07:57:48 <tefter> cabal is broken currently
07:57:52 <tefter> and ghc as well
07:58:10 <tefter> also I can't compile devel snapshot any more
07:58:31 <tefter> latest update to gcc breaks older ghc as well
07:58:41 <tefter> so I am lost now
08:00:36 <max3> lol why is that compiling with cabal build --ghc-options=-fPIC and then cabal build --ghc-options=-fno-code gives me linking errors
08:01:13 <srhb> Enamex: In general, and this might not help you in this case, I try to do something like this locally: let foo :: _x _more _ys; foo x more ys = x : more ys in foldr foo -- of course, this is still a type error
08:01:14 <max3> https://apaste.info/hMzJ
08:01:42 <srhb> er
08:01:55 <srhb> Enamex: Forgot some arrows in that type signature :P
08:02:06 <max3> man what a mess
08:02:38 <yushyin> tefter: separating developer stuff from the regular packages needed for the binaries in the repositories is the best option you have right now and thus using stack is one way you can go
08:04:31 <tefter> ok I lookup stack, seems only way to do it currently ;)
08:06:03 <yushyin> having stack manage serveral ghc versions is useful anyway imho
08:21:48 <ertes-w> Enamex: honestly i usually just write ":: ()"
08:22:22 <ertes-w> to which GHC responds: "YOU SUCK!  THE REAL TYPE IS …, YOU IDIOT!"
08:27:26 <mniip> ertes-w, uhhh
08:28:05 <Enamex> I wish it did...
08:28:39 <ertes-w> well, ok, it's usually more polite…  this is something you might hear from tsunderebot
08:28:41 <ertes-w> *lambdabot
08:29:43 <Enamex> > id :: ()
08:29:45 <lambdabot>  error:
08:29:45 <lambdabot>      • Couldn't match expected type ‘()’ with actual type ‘a0 -> a0’
08:29:45 <lambdabot>      • Probable cause: ‘id’ is applied to too few arguments
08:30:13 <barrucadu> I'm a fan of the ':: ()' approach as well, it's pretty handy
08:30:51 <barrucadu> I sometimes also stick '()'s in the place of function argument types, when I'm not really sure what the type of that argument should be, but where I know something about the rest of the type
08:32:11 <Enamex> GHCi really needs some quality of life stuff
08:32:44 <Enamex> Like sane multi-line mode and a history of definition source that can be recalled somehow (for the latest binding)
08:33:09 <srhb> Enamex: Maybe something like jupyter would be to your liking?
08:33:20 <srhb> (I would love for ghci to do this, too, though!)
08:33:26 <Enamex> There's a Jupyter interface for GHCi?
08:33:28 <Enamex> !!?
08:33:32 <srhb> For Haskell, at least.
08:33:37 <srhb> I assume that's the same thing.
08:33:40 <srhb> (I haven't used it)
08:36:43 <sbrg> Enamex: yep. 
08:37:06 <ent> is there a nice way of turning a :: (IO a, IO b) into a IO (a, b)?
08:37:06 <sbrg> https://github.com/gibiansky/IHaskell
08:38:26 <Enamex> Trying it now: https://try.jupyter.org/
08:38:43 <Enamex> It's taking waaay too long just to output `id 3`
08:38:56 <Enamex> I don't mean to say that it has actually succeeded yet
08:39:21 <srhb> ent: Sequence both actions from the tuple, return to a tuple.
08:39:22 <sbrg> probably works much better locally.
08:40:44 <ent> hmm
08:42:00 <srhb> ent: sequenceTuple (ioa, iob) = do { a <- ioa; b <- iob; return (a, b) }
08:42:37 <jle`> ent: i usually do something like liftA2 (,) ioa ioab
08:42:41 <jle`> or (,) <$> ioa <*> iob
08:42:50 <ertes-w> :t sequenceOf both
08:42:52 <lambdabot> (Monad m, Data.Bitraversable.Bitraversable r) => r (m b) (m b) -> m (r b b)
08:43:08 <jle`> only works if 'a' and 'b' are the same i think
08:43:20 <jle`> (sequenceOf both, that is)
08:43:20 <ertes-w> oh, indeed
08:43:24 <ertes-w> :t bisequenceA
08:43:25 <max3> what in the world is the point of this 
08:43:25 <lambdabot> error:
08:43:25 <lambdabot>     • Variable not in scope: bisequenceA
08:43:25 <lambdabot>     • Perhaps you meant one of these:
08:43:26 <max3> https://apaste.info/gf8I
08:43:28 <ent> well, they actually are for me 
08:43:31 <ertes-w> :t Data.Bifunctor.bisequenceA
08:43:32 <ent> so I'll try that :)
08:43:32 <lambdabot> error:
08:43:32 <lambdabot>     Not in scope: ‘Data.Bifunctor.bisequenceA’
08:43:32 <lambdabot>     No module named ‘Data.Bifunctor’ is imported.
08:43:33 <max3> *could be the point of this
08:43:39 <ent> thanks!
08:43:48 <ertes-w> oh, Bitraversable is not in base yet
08:44:04 <jle`> max3: what do you mean exactly?
08:44:06 <jle`> the typeclass?
08:44:11 <max3> no that instance
08:44:18 <jle`> it seems like a useful instance
08:44:22 <ertes-w> ent: the bifunctors package provides Bifoldable and Bitraversable, along with bisequenceA_ and bisequenceA resp.
08:44:39 <max3> jle` it seems like just a wrapper
08:44:48 <jle`> a wrapper in what sense?
08:45:16 <max3> r produces a response and i need to use it in places where i use ResponseData instances
08:47:09 <jle`> 'r' is a thing that can produce a Response if given a Status and ResponseHeader
08:47:29 <max3> yes i understand that
08:47:50 <jle`> so a (Status -> ResponseHeader -> Response) is a perfectly good instance
08:48:23 <max3> you mean 'r' in the definition of the class
08:48:43 <jle`> yes
08:48:50 <max3> it's the most generic instance
08:48:59 <jle`> not sure what you mean by generic
08:49:03 <jle`> but it's the simplest instance
08:49:04 <max3> (Status -> ResponseHeader -> Response) is the most general
08:49:05 <max3> yes
08:49:06 <max3> that
08:49:18 <jle`> simple instances are useful
08:49:24 <max3> yes i don't see how
08:49:50 <max3> it seems like a tautology
08:50:12 <jle`> do you know about MonadReader
08:50:17 <max3> (Status -> ResponseHeader -> Response) satisfies the "contract" of the instance because it (Status -> ResponseHeader -> Response) is the contract
08:50:22 <max3> no
08:50:39 <Enamex> I'
08:50:54 <Enamex> Getting "recompile with -fPIC" error when trying to install everything needed for IHaskell
08:50:55 <max3> sorry. contract of the class
08:51:15 <jle`> max3: another way of looking at it is a general "HasX" pattern
08:51:28 <jle`> class HasX a where getX :: a -> X
08:51:42 <jle`> where an instance of HasX "contains" an X
08:51:47 <jle`> it might contain other things too
08:51:53 <jle`> but being an instance lets you get an X
08:51:53 <max3> yes that is similar i agree
08:52:16 <max3> yes but we're pure so this (Status -> ResponseHeader -> Response) doesn't do anything else
08:52:17 <jle`> so if a function is polymorphic over all HasX's, you can give it anything that is an instance of HasX/has an X in some way
08:52:21 <max3> it doesn't have "other" things
08:52:21 <jle`> and it can work with it
08:52:45 <jle`> so i have a a function foo :: HasX a => a -> Int
08:52:51 <jle`> foo should work over anything that has an X, right?
08:52:53 <max3> yes i understand that
08:53:06 <jle`> so....wouldn't it be useful to just be able to give it an X?
08:53:19 <jle`> doesn't it make sense for X to have an instance of HasX ?
08:54:10 <jle`> suppose i export a foo from my module and a user wants to use it and give it an X
08:54:25 <max3> yea i just got it
08:54:32 <jle`> but i did not provide an instance of HasX for X, for some reason
08:54:36 <jle`> that user would get pretty upset at me
08:54:49 <max3> yes now it makes sense
08:54:53 <jle`> "i have an X and foo should be able to use it, why don't you give an instance of HasX for X?"
08:55:10 <jle`> "well you see, it's way too simple of an instance"
08:55:10 <max3> but i guess my feeling was something like shouldn't that be automatically inferred or something
08:55:26 <max3> akin to duck typing
08:55:40 <jle`> shouldn't what be automatically inferred?
08:55:45 <jle`> the instance?
08:55:58 <max3> yes
08:56:26 <jle`> well...instances don't automatically get defined in haskell
08:56:31 <jle`> you usually have to write them yourself
08:56:36 <jle`> or use some sort of explicit deriving mechanism
08:56:57 <jle`> haskell doesn't have a mechanism for automatically writing instances if you don't ask for it
08:57:11 <jle`> usually it's not what you'd want anyway...
08:57:39 <jle`> in haskell we like to ask for our instances
08:57:45 <max3> that's probably true
08:57:51 <max3> thank you for the explanation
08:57:54 <jle`> no problem
08:58:03 <jle`> it's similar to something like java, where interfaces don't get automatically implemented
08:58:37 <jle`> you'll have to say that something is an instance of an interface, at the very least
09:08:04 <horrorcheck> Does anyone know how to make the "Ok, modules loaded:" line in ghci not appear, or be abbreviated?
09:08:29 <horrorcheck> This project I'm working on has a tooooon of modules and it takes up like the whole screen
09:08:30 <Enamex> New error:
09:08:33 <Enamex> The pkg-config package 'libzmq'     version >=4.0 && <5.0 is required but it could not be found.
09:12:13 <ertes-w> horrorcheck: but only when you start GHCi, no?
09:12:28 <ertes-w> not when you reload
09:13:44 <horrorcheck> ertes-w: no it happens on reload to, since upgrading to ghc 8
09:13:48 <horrorcheck> *too
09:14:04 <ertes-w> horrorcheck: which editor do you use?
09:14:39 <horrorcheck> emacs, but I tend to use ghci in the terminal by itself
09:14:56 <horrorcheck> not integrated into emacs
09:15:42 <ertes-w> horrorcheck: if you were to use it, haskell-interactive-mode would relay such messages to the message area of emacs, so you can see the loading progress, but it doesn't clutter your interaction buffer
09:16:09 <ertes-w> it also has some clever error handling, such that once you fix an error, it disappears from the interaction buffer
09:16:26 <horrorcheck> hmmm
09:16:58 <horrorcheck> I don't know if I'm ready to change my whole development workflow over this 
09:17:00 <horrorcheck> haha
09:17:27 <ertes-w> you change it from "switch window, :r, enter" to "C-c C-l" =)
09:17:40 <Enamex> Is there a way to tell Stack to tell cabal to 'reorder-goals'
09:17:55 <ertes-w> and you switch from going to line nubers to M-x next-error RET =)
09:18:10 <horrorcheck> ertes-w: thanks I'll try it out
09:19:10 <horrorcheck> I still think there ought to be a way to tell ghci not to list every module it loaded on every reload though 
09:23:48 <mnoonan> horrorcheck: I'm not sure exactly what this corresponds to, but it looks like setting verbosity to 0 might do it? https://github.com/ghc/ghc/blob/ccb849f8ea39582d2cfc5c045abe9768992dccb6/ghc/GHCi/UI.hs#L1801
09:25:30 <horrorcheck> mnoonan: that looks promising!
09:26:48 <mnoonan> actually, maybe not.. that's only getting the number of modules, not the actual names. but maybe you can find something nearby..
09:28:13 <max3> how does throw work? e.g. `unsafeResult = throw . Result` does this define a function that can throw or does it throw a wrapped result?
09:31:33 <ertes-w> > let f = throw . userError in f `seq` ()
09:31:35 <lambdabot>  ()
09:31:39 <ertes-w> > let f = throw . userError in f () `seq` ()
09:31:41 <lambdabot>  error:
09:31:41 <lambdabot>      • Couldn't match type ‘()’ with ‘[Char]’
09:31:41 <lambdabot>        Expected type: String
09:31:43 <ertes-w> > let f = throw . userError in f "" `seq` ()
09:31:45 <lambdabot>  *Exception: user error
09:31:47 <jle`> `unsafeResult x` is a bottom that, when evaluated, will raise a runtime exception (Result x)
09:31:55 <ertes-w> max3: it's a function that throws
09:31:58 <jle`> basically like 'undefined'
09:32:03 <ertes-w> max3: throw = const undefined
09:32:07 <jle`> ^
09:32:20 <jle`> > fst (4, undefined)
09:32:22 <lambdabot>  4
09:32:25 <ertes-w> but not:  throw = undefined
09:32:34 <max3> i don't understand why it would be named unsafeResult
09:32:41 <max3> instead of resultException
09:32:41 <jle`> me neither
09:32:43 <max3> or something
09:32:53 <max3> above it is `result = liftIO . throwIO . Result`
09:32:58 <ertes-w> max3: the proper name would be 'result'
09:33:13 <max3> i don't understand why? it's an exception and nothing else?
09:33:18 <ertes-w> it's a partial function
09:33:27 <jle`> note that throwIO is differen than throw
09:33:42 <ertes-w> there is no semantic difference between (throw x) and undefined, for all x
09:33:44 <max3> jle` yes i understand that but it throws as well in pure code
09:33:46 <jle`> throwIO returns a non-bottom value and is total; the semantics are a bit different
09:33:58 <jle`> throwIO returns a well-defined, non-bottom IO action
09:34:08 <jle`> throw x is basically undefined
09:34:18 <max3> ertes-w, okay it's a partial function that when applied and run throws
09:34:32 <max3> is that correct?
09:34:46 <jle`> *when evaluated
09:34:49 <ertes-w> max3: yes, although you should really consider it to be bottom
09:34:58 <ertes-w> the "throw" aspect is secondary
09:35:31 <ertes-w> in particular there is no way to know *where* the actual throwing will happen, unless you're in full control of pattern-matching on the result
09:35:35 <ertes-w> (or forcing it through 'seq')
09:35:51 <ertes-w> semantically (throw x) is really just an infinite loop
09:36:07 <max3> jle`, yes evaluated thank you. ertes-w what i mean is that when either result or unsafeResult are evaluated i will get "exceptional" behavior
09:36:23 <Enamex> horrorcheck: Further, imported modules appear as part of the prompt arrow. This gets really long fast
09:36:35 <max3> why are these two functions not called resultBottom or something
09:36:40 <max3> these aren't results i can use
09:36:44 <max3> unless result == bottom
09:36:54 <max3> like end of the world result
09:36:59 <ertes-w> max3: why is 'head' not called 'unsafeHead'?
09:37:13 <max3> head gives you the head of a list
09:37:20 <ertes-w> and what if the list is empty?
09:37:31 <max3> i'm asking: do these functions ever produce anything but bottom?
09:37:44 <jle`> if you want us to help understand the motivation, it might help to explain where you got these functions from
09:38:00 <ertes-w> sounds like attoparsec
09:38:03 <max3> https://github.com/databrary/databrary/blob/master/Databrary/Action/Response.hs
09:38:10 <max3> bottom of the page lol
09:38:47 <ReinH> Enamex: easy to fix with a .ghci file
09:38:53 <ertes-w> max3: for all f (throw . f) will be bottom
09:39:00 <cht> `flip const === const id`. Is this part of a more general pattern? `const` being some sort of homomorphismy thing? 
09:39:04 <max3> ertes-w, yes i get that
09:39:23 <max3> hence the difference between `head` and `result`
09:39:40 <ertes-w> max3: the difference isn't really that big…  both are partial functions
09:39:45 <Enamex> Does a web client for IRC exist that keeps history? Or is this channel logged somewhere?
09:39:52 <ertes-w> max3: (head []) might as well be an infinite loop
09:40:04 <ertes-w> and so might (throw x) for any x
09:40:15 <max3> ertes-w, result has a codomain of cardinality 1: {bottom}
09:40:21 <nshepperd_> "unsafeResult" is certainly a weird name there
09:40:28 <max3> err that's not relevant sorry
09:40:37 <nshepperd_> It should be called throwResult or something
09:40:47 <ertes-w> max3: the point is: it *is* a result…  it just happens to be bottom
09:40:48 <max3> where is result defined?
09:40:55 <ertes-w> remember that all types in haskell are lifted
09:41:06 <max3> i don't know that so it's tough to remember
09:41:40 <jle`> it looks like the library is using exceptions as some warped form of control flow
09:41:55 <horrorcheck> Enamex: I learned a while back that you can `:set prompt` to whatever you want, and that helped with the "modules listed in prompt" problem
09:41:58 <jle`> well, exceptions are control flow, but the library is using them in an unconventional way
09:42:04 <max3> lol why am i not surprised 
09:42:21 <horrorcheck> Enamex: I was hoping there was something just as helpful for the "Ok" message
09:42:59 <nshepperd_> Ah, yeah. "runResult = handle (return . resultResponse)" what the heck
09:43:10 <ReinH> jle`: "exceptions should not be used as control flow" is a hard rule to enforce. "removing exception handling should not change the result of a successful program execution" is easier.
09:43:11 <max3> nshepperd_, i'm quoting you
09:43:14 <nshepperd_> Just use contT already
09:43:40 <ReinH> iow using exceptions to handle expected cases is what is bad
09:43:43 <jle`> i am in the school that believes that the value of exceptions is chiefly as control flow
09:44:01 <max3> btw
09:44:06 <max3> pointfree code
09:44:08 <max3> is an abomination 
09:44:12 <ReinH> max3: it is not
09:44:14 <jle`> well
09:44:19 <ReinH>  pointfree code is useful for reasoning about composition
09:44:20 <jle`> code can be an abomination
09:44:26 <ReinH> being able to reason about composition is very valuable in haskell
09:44:27 <jle`> point-free or non-point-free is irrelevant
09:44:34 <jle`> sometimes pointfree code is more readable, sometimes it isn't
09:44:52 <ReinH> there are lots of cases where you *don't* want to reason about composition: you instead want to reason about application.
09:44:57 <nshepperd_> We're all abominations
09:45:01 <ReinH> And in those cases, using pointfree code is counter-productive.
09:45:02 <max3> i'm firmly in the camp that enabling programmers to shoot themselves in the foot is a mistake in the design of the language
09:45:07 <jle`> pointfree is a tool that is useful in specific narrow situations
09:45:19 <ReinH> max3: Ok, but that has nothing to do with pointfree code.
09:45:26 <max3> yes it does
09:45:29 <ReinH> No, it does not.
09:45:47 <nshepperd_> I don't think there's any language that can stop you from creating unreadable code
09:45:54 <jle`> > map (*2) [1..10]
09:45:56 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
09:46:01 <max3> it clearly does: pointfree code as a feature/notion is something that enables programmers to shoot themselves in the foot
09:46:03 <jle`> > map negate [1..10]
09:46:05 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
09:46:13 <ReinH> max3: You're just restating your premise.
09:46:13 <jle`> max3: pretty much every concept can be abused
09:46:24 <ReinH> Anything offered without evidence can be dismissed without evidence
09:46:27 <ReinH> So, again: no it does not.
09:46:34 <jle`> max3: what you said applies to literally everything ever
09:46:50 <ReinH> I have lots of experience that tells me that pointfree code is good and useful.
09:47:01 <ReinH> So until you present evidence to the contrary, I am going to ignore your claim.
09:47:05 <jle`> point-free is not a goal in and of itself
09:47:14 <jle`> it's nice in some situations and not nice in others
09:47:17 <jle`> just like...literally everything ever
09:47:44 <ReinH> if statements allow programmers to shoot themselves in the foot
09:47:58 <jle`> programming allows programmers to shoot themselves in the foot
09:47:59 <ReinH> I can easily write if shouldDoThing then dontDoThing else doThing
09:48:01 <ReinH> ban if statements
09:48:11 <ReinH> That is exactly as reasonable as your statement.
09:48:25 <max3> indeed they do but since we know we need conditionals and loops and declaration for turing completeness it goes without saying that that's outside the scope of the design of a language
09:48:35 <jle`> max3: your vendetta isn't really against pointfree code, it's against unreadable code
09:48:38 <ReinH> No it doesn't.
09:48:56 <ReinH> Not every language needs Turing Completeness.
09:49:00 <max3> jle`, my ire is directed at "expressive for the sake of expressive"
09:49:08 <ReinH> In fact, Turing Completeness is a source of many problems.
09:49:19 <jle`> max3: point-free for the sake of point-free is never a good idea
09:49:21 <tabaqui> does haskell have other metaprogramming techinques besides templates?
09:49:22 <jle`> nobody thinks it is :o
09:49:24 <ReinH> So maybe we should consider Turing Completeness to be an abomination.
09:49:38 <jle`> max3: expressiveness for the sake of expressiveness is also not a good idea
09:49:47 <ReinH> But you still haven't presented any evidence that pointfree is bad.
09:49:54 <ReinH> You've just repeated your claim using slightly different wording.
09:50:02 <ReinH> And I am going to continue to not take it seriously until you do.
09:50:07 <jle`> max3: so your vendetta is really just against "expressiveness for the sake of expressiveness"...and not against point-free code
09:50:09 <tabaqui> I'm thinking about creating dsl for client-server system
09:50:20 <max3> ReinH, if we're assessing pointfree as a language feature, not reasoning tool
09:50:23 <max3> then i have not
09:50:32 <tabaqui> and want to write the one code to rule them all
09:50:34 <ReinH> All language features are reasoning tools.
09:50:38 <ReinH> That's why they exist.
09:50:48 <ReinH> You can't separate the two.
09:50:51 <max3> okay "mr i write code to solve philosophy paradoxes"
09:50:57 <ReinH> What?
09:51:02 <ReinH> That's just ad hominem. 
09:51:03 <ReinH> Do better.
09:51:03 <max3> *philosophical paradoxes 
09:51:16 <max3> "All language features are reasoning tools"
09:51:17 <max3> is facile
09:51:18 <ReinH> And a straw man to boot.
09:51:23 <Enamex> point-free style has taught me to philosophize and accept occasional glazed eyes
09:51:28 <ReinH> LOL
09:51:56 <ReinH> You can't present evidence for your argument and you call mine facile.
09:51:57 <max3> yes i sit at my computer all day and reason
09:51:59 <ReinH> Bad troll is bad.
09:52:22 <ReinH> This argument is a waste of time. I'm done with it.
09:52:22 <max3> what kind of evidence should i present? how about empirical? how many languages admit pointfree style?
09:52:27 <jle`> max3: in any case it seems like you're confusing point-free code with a style that emphasizes expressiveness for the sake of expressiveness
09:52:34 <jle`> most languages allow you to write point-free code
09:52:38 <jle`> most modern languages at least
09:52:46 <max3> you mean via lambdas?
09:52:49 <jle`> no
09:53:01 <jle`> even without lambas
09:53:04 <jle`> *lambdas
09:53:07 <max3> i'm not familiar with another language that allows partial application or currying 
09:53:21 <max3> or composition in the same way that haskell does
09:53:36 <jle`> C, python, ruby, etc.
09:53:44 <jle`> javascript
09:53:48 <max3> show me a pointfree function in python
09:54:01 <max3> just so i understand what you're implying
09:54:48 <jle`> you can write a composition function
09:54:58 <jle`> that takes two functions and returns a third function that is the two composed together
09:55:42 <ReinH> jle`: why are you even accepting the premise that "other languages don't do it" is a reason that a feature in Haskell is bad?
09:55:43 <max3> yes that's true and that indeed would be an abomination 
09:55:55 <max3> f(g,h)(x,y)
09:56:12 <ReinH> max3: Go read Bird's Pearls book and get back to us.
09:56:16 <ReinH> This discussion is pointless.
09:56:21 <max3> i thought you were done with this debate?
09:56:22 <jle`> wanted to say that point-free code is not a "language feature"
09:56:30 <jle`> it's something useful i some cases and not useful in others
09:56:47 <ReinH> max3: You are a troll and I want you to stop trolling.
09:57:00 <ReinH> It's disrupting the channel.
09:57:02 <jle`> in some situations, obviously point-free adds nothing to readability or good code
09:57:06 <jle`> in some situations, it adds a lot
09:57:16 <max3> i'm not a troll i made a comment and you decided to inveigh 
09:57:23 <jle`> > map negate [1..10]      -- one succinct situation where point-free code adds to readability
09:57:25 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
09:57:45 <max3> but that's an expression not a function
09:57:51 <jle`> 'negate' is a function
09:57:51 <ReinH> what
09:57:54 <jle`> i'm using it in point-free style
09:58:06 <jle`> contrasted to, say, map (\x -> negate x) [1..10]
09:58:45 <max3> `f = map negate` is what i'm talking about in particular 
09:58:51 <cocreature> huh, I always thought that point-free only refers to the definition of functions not to their use
09:58:57 <max3> yes
09:59:04 <ReinH> "pointfree is an abomination" is a trollish comment intended to start a useless, bad faith discussion. It has succeeded. You are a troll.
09:59:44 <jle`> yeah, i'm defining the function i'm using to pass in to 'map'
09:59:48 <tabaqui> pss, dudes, do you want to talk about meta-programming?
09:59:52 <max3> lol
09:59:53 <ReinH> tabaqui: sure
09:59:58 <tabaqui> great!
10:00:01 <jle`> i could chose to pass in 'negate' to map, or i could pass in (\x -> negate x)
10:00:19 <ReinH> tabaqui: what's the question?
10:00:20 <tabaqui> ReinH: do you know any other techniques besides of templates?
10:00:35 <tabaqui> I want to write client-server aplication with one code base
10:00:47 <max3> jle`, yes i understand. i agree with you in that instance it's much clearer
10:00:49 <tabaqui> actually, I intend to implement my own dsl
10:01:01 <ReinH> Template Haskell and the C++ preprocessor.
10:01:19 <tabaqui> and hide separation "server/client" inside
10:01:25 <jle`> max3: then your problem isn't with point-free code.  your problem is with unreadable code
10:01:32 <ReinH> tabaqui: I'm not sure why that requires metaprogramming.
10:01:48 <ReinH> jle`: Actually, I think their problem is with faulty generalizations.
10:01:51 <max3> i'm not a fundamentalist. of course in the most tame uses it's fine
10:01:54 <ahihi> "f = map negate" seems far from unreadable though
10:01:59 <jle`> max3: everyone agrees with you there
10:02:12 <jle`> with everything, tame usage is always fine
10:02:19 <ReinH> Bad things are bad, news at 11.
10:02:28 <tabaqui> ReinH: I do not want to write different main files
10:02:33 <max3> yes i'm extrapolating to something broader: if a feature is more often abused than not then it is a bug not a feature
10:02:36 <jle`> "when used badly, things are bad.  when used well, things are good"
10:02:38 <ReinH> tabaqui: That doesn't seem like a worthwhile goal, but sure.
10:02:45 <ReinH> Then you'd probably want some sort of metaprogramming.
10:02:48 <cocreature> for GHC f = map negate and f xs = map negate xs are also not the same thing
10:03:10 <max3> cocreature, how are they different?
10:03:11 <ReinH> tabaqui: Although even then you can probably do a lot by passing in an option that selects an interpreter for a free monad or something similar.
10:03:14 <tabaqui> It would be great to use one source with code-generation for different sides
10:03:27 <ReinH> I disagree that clients and servers are similar enough that they can be unified by judicious use of metaprogramming though.
10:03:35 <cocreature> ghc only considers functions for inlining if they are fully applied and what fully applied means depends on how they are defined
10:03:44 <cocreature> f = map negate is always fully applied
10:03:54 <cocreature> f xs = map negate xs is only fully applied if the argument is present
10:04:01 <tabaqui> ReinH: well, more precisely - I want to describe application login in one place
10:04:05 <ReinH> cocreature: This is true, but it's also a parochial problem with GHC and not a problem with Haskell per se.
10:04:15 <tabaqui> *logic
10:04:35 <cocreature> ReinH: sure but we don’t have any significant compilers apart from GHC so it’s a useful thing to keep in mind :)
10:04:50 <ReinH> In platonic haskell, f = map negate and f xs = map negate xs are equal.
10:04:51 <cocreature> at least not any compilers that are significant for people not working at standard chartered :)
10:04:53 <mnoonan> shell scripts use pointfree style extensively
10:05:01 <ReinH> as is f = \xs -> map negate xs
10:05:30 <ReinH> So, we are agreed: pointfree is good when it is good and bad when it is bad.
10:05:54 <ReinH> cocreature: Yes, but this is also a parochial problem that only affects, say, almost all 
10:05:56 <ReinH> humans on earth
10:06:13 <ReinH> I am concerned with the perfect Haskell that exists only in the mind.
10:07:10 <jle`> @remember ReinH So, we are agreed: pointfree is good when it is good and bad when it is bad.
10:07:10 <lambdabot> Good to know.
10:07:12 <cocreature> ReinH: fair enough, I prefer talking about things I can actually use :)
10:07:31 <ReinH> cocreature: :)
10:07:50 <ReinH> jle`: something something monochrom's tautologies
10:08:38 <jle`> why does lambdabot have a girl19 command
10:08:52 <cocreature> and then 90% of the time I ignore what I’m using and pretend the language I’m working with doesn’t have ⊥
10:09:25 <sveit> what is the preferred library/set of libraries for generating C code?
10:09:38 <ReinH> generating C code in what way?
10:09:46 <jle`> @yhjulwwiefzojcbxybbruweejw
10:09:47 <lambdabot> "\"#$%&'()*+,\""
10:09:48 <jle`>  
10:09:50 <jle`> why
10:09:51 <ReinH> Using Haskell as a DSL to generate C?
10:10:17 <cocreature> if you just want an AST and a pretty printer, language-c is what you’re looking for
10:10:31 <ReinH> i.e., something like copilot?
10:10:43 <jle`> is ivory still a thing?
10:10:51 <ReinH> or atom? or ivory?
10:11:11 <cocreature> jle`: there was a hackage release in april, so probably yes
10:11:32 <raynold> ahh it's a wonderful day
10:12:03 <sveit> well the project i have in mind is just generating a small struct and some methods, so probably DSL isn't necessary
10:12:45 <sveit> i guess language-c is the way to go. but just out of interest, for DSL are atom/copilot/ivory libraries for compiling DSL -> C?
10:12:54 <sveit> or are they DSLs that are compiled down to C?
10:13:04 <jle`> ivory is a dsl for specifying C code in haskell
10:15:22 <ReinH> It is hard to find info about atom the pacakge because of the namespace collision with atom the editor :/
10:15:43 <HallaSurvivor> I'm starting fresh, and I'm curious as to installing ghc nowadays?
10:15:55 <HallaSurvivor> Is it ok to have a regular installation? Or should I manage ghc with stack?
10:16:07 <wayne> hi
10:16:16 <sveit> for learning purposes, do you guys know why ivory doesn't use language-C?
10:16:46 <jle`> language-c is for embedding C code in haskell, right?
10:16:50 <wayne> i'm considering running a haskell intro workshop soon...does anyone know of any resources to help get attendees set up with environments?
10:16:50 <ReinH> But basically, atom is an EDSL that emits C for embedded hard real-time systems.
10:17:13 <jle`> if i were to design a C EDSL, i'd write an edsl that generates an AST for C code
10:17:15 <wayne> anything that ensures that they won't have to waste ~30 mins setting up GHC and stack deps would be amazing
10:17:17 <ReinH> "Language C is a haskell library for the analysis and generation of C code."
10:17:28 <wayne> if not, i was just thinking about creating a VM image or something
10:17:30 <jle`> i wouldn't be concerned about having my c code interop with haskell
10:17:36 <ReinH> It's possible that ivory predates language-c.
10:17:48 <jle`> oh then yes language-c seems like something i would be using
10:18:11 <ReinH> wayne: I would suggest using stack and stackage for the lowest-friction path to building Haskell programs on a variety of platforms.
10:18:38 <ReinH> They can either spend 30 minutes setting up stack or they can spend 30 mintues setting up Docker, or etc.
10:18:47 <ReinH> There's no free lunch here. They have to configure their machines somehow.
10:18:50 <wayne> ReinH: that was my first approach, but the possible bottlenecks may be network speeds and weak ultrabook processors
10:19:02 <wayne> yeah and you make a good point that setting up that environment itself is tiring
10:19:09 <wayne> i was looking at webIDEs but none of them seem robust enough
10:19:30 <ReinH> Maybe Haskell Platform is closer to a turnkey solution, but it also has its own issues.
10:19:44 <ReinH> You're basically trading time setting up an environment now for time debugging cabal hell later.
10:20:15 <ReinH> Stack at least has the benefit of being mostly idle wait time.
10:20:19 <ReinH> Waiting for GHC to install, etc.
10:20:22 <ReinH> Not actively configuring stuff.
10:20:40 <wayne> that's a good way to put it. maybe i can come up with some filler content while that machines chug on stack
10:20:53 <ReinH> They can downloada project the day before and run stack setup and go eat dinner or w/e.
10:21:11 <jle`> optimizing for doing simple stuff right away and dealing abstraction breakage later sounds like something that 'stack' would be ideal for
10:21:25 <jle`> *dealing with
10:21:28 <wayne> i wish we could get them to do that haha
10:21:54 <sveit> jle`, ReinH: thanks! do you know of general resources for compiling Haskell DSLs?
10:22:07 <wayne> i'll check out haskell platform more, thanks for the tip!
10:22:09 <jle`> compiling as in using dsl's to generate code?
10:22:09 <sveit> learning resources*
10:22:12 <ReinH> wayne: Yeah, I've been involved in enough similar things to know that there's really no alternative to allowing a couple hours on the first day for getting everyone's environment running.
10:22:17 <jle`> or compiling as in 'ghc' ?
10:22:25 <ReinH> If your program is a 2 hour workshop then godspeed.
10:22:40 <wayne> we have 3 hours, but it's still cutting it close
10:22:47 <jle`> you could give everyone a shared hosted environment
10:22:49 <jle`> if you have the resources
10:22:50 <ReinH> sveit: No, only specific resources for specific libraries.
10:22:51 <wayne> i doubt we'll even get to functors
10:23:03 <ReinH> sveit: language-c is the closest thing to a general resource for emitting C.
10:23:08 <jle`> i was in a nix workshop the other day that used nix to generate environments for everyone
10:23:15 <wayne> yeah was thinking of a shared hosted environment + remote desktop, but then they wouldn't have it on their machines to hack at home
10:23:17 <jle`> on a server to log in
10:23:24 <mnoonan> wayne: you could set up a jupyter server with an ihaskell kernel
10:23:40 <mnoonan> that doesn't solve your "hack at home" issue, of course
10:23:59 <sveit> jle`: i guess both. design of DSLs in the first place and good ways of embedding them into Haskell, and then compiling to another language if desired (or run in Haskell, i.e. compiled by GHC)
10:24:05 <ReinH> wayne: If you provide simple, detailed instructions beforehand you will get about 40% of people to set up their environments before they arrive.
10:24:28 <wayne> thanks for all the suggestions. i'll write about my experiences either way, especially if i figure out something that could be useful
10:24:45 <ReinH> The other 60% will be split between people who didn't bother and people who got stuck at some place you didn't predict them getting stuck because you have a lot more ambient knowledge about troubleshooting such systems than they do.
10:25:38 <ReinH> But as always, if you don't have expectations then you can't be disappointed. :D
10:26:03 <wayne> hah, yeah. if it weren't so patronizing maybe i'd consider having them compile a Main.hs and pasting the contents to complete their registration
10:26:09 <wayne> i.e., the output
10:26:45 <ReinH> Then you'll just get lower turnout.
10:28:00 <jle`> wayne: alternatively you could try one of those online web-based haskell compilers/workspaces
10:28:26 <jle`> like FPComplete
10:28:33 <ReinH> Ooh like FP Complete's... oh... wah wah
10:28:53 <ReinH> Haven't they killed that all off by now?
10:28:57 <wayne> i think they've changed their mission statement like 5 times
10:28:59 <jle`> yeah i was going to...check
10:29:01 <wayne> but i still wish them well!
10:29:07 <ahihi> installing stack and running stack setup takes less than 5 minutes on my ultrabook
10:29:10 <wayne> a tough job they have
10:29:33 <ReinH> It's hard to make a living as a amorphous blob in the Enterprise Haskell market.
10:29:34 <wayne> ahihi: but pulling in the libs to write a spock app or something does take quite a while
10:29:35 <jle`> it took me a good whole day on my windows w/ ubuntu subsystem
10:29:37 <ReinH> *an
10:30:20 <jle`> but to be fair, that's sort of not a good sample point to base things off of
10:30:28 <wayne> fwiw, not a complaint so much as an observation. i think stack is great
10:31:07 <jle`> 10 minute filler might be good enough while things install
10:31:11 <jle`> tell them to install everything at once, heh
10:44:15 <Unicorn_Princess> I finished https://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html , and got to Course.StateT in https://github.com/data61/fp-course , and now I kinda wanna make a simple 2d game as a practice/fun project - how bad of an idea is this, vs. continuing the data61 course?
10:45:59 <srhb> Unicorn_Princess: I think it sounds fine. gloss is pretty easy to get into for some simple games.
10:46:22 <koala_man> I don't think that trying to write something is ever a bad idea
10:54:42 <WarzoneCommand> I'm planning on writing some small GUI application, think of something like a simple (vector-based) drawing application. i.e. the main interactions will be with geometric components on a 2D canvas. Any reccommendations on what GUI library/framework to look at for that? 
10:56:37 <WarzoneCommand> s.t. that can run in a browser would be nice, but I'm not willing to have to boot a VM or install half an OS (looking at you reflex-DOM) to do so 
10:58:24 <Unicorn_Princess> all I know is gloss is supposedly okay for 2D graphics
11:08:02 <srhb> Unicorn_Princess: It's mostly a conceptual thing really.
11:08:41 <srhb> Unicorn_Princess: I wouldn't do any "real" graphics with it, but it's great for learning to move stuff around the screen in a more or less functional way before tackling how to deal with more complicated graphics libraries.
11:12:07 <benjwadams> Hello.  For a project I'm on, the client wants to create arbitrary numerical expressions and be able to run them.  I am using python for most of the project, but raw eval would obviously be a disaster
11:13:01 <c_wraith> benjwadams: parser + interpreter, same as any other language
11:13:02 <benjwadams> it's a bit of of a stretch, but can you run only pure functions in haskell and disable IO
11:13:23 <benjwadams> ok, so you'd need to define the grammar completely?
11:13:36 <mnoonan> benjwadams: you're probably better off with Python's ast, inspect, and writing a decorator (a la numpy)
11:14:19 <Athas> benjwadams: yes, you can (with great care and Safe Haskell), but would you generate and compile a Haskell program at runtime?
11:14:49 <Athas> You can look at how lambdabot works, but I think this is overkill.
11:15:11 <mnoonan> oh, sorry, 'numba' not 'numpy'
11:15:16 <benjwadams> More or less, I want to just be able to run these user defined functions against a time series and see if they fail some threshold, i.e. "sin(b)/2c > d"
11:16:17 <benjwadams> so basically I ought to be looking at parser libs, correct?
11:16:34 <benjwadams> I thought that was more or less the approach I'd have to take.
11:19:07 <Athas> benjwadams: yes, I think it is saner to define a grammar for math expressions and write a small evaluator.
11:20:50 <ReinH> A possibly-sensible half measure would be to derive Read for the AST and related types.
11:21:14 <benjwadams> mnoonan: I know this is #haskell, so maybe kinda OT, but i think you may have actually meant numexpr
11:21:52 <benjwadams> which, looking at the docs now, actually seems to cover my use case fairly well
11:21:52 <ReinH> But defining a language and a grammar and implementing a parser would be the most robust solution.
11:22:30 <mnoonan> benjwadams, hmm, I'm not familiar with that. I'm thinking of this kind of thing: http://dev.stephendiehl.com/numpile/
11:23:41 <mnoonan> (bonus #haskell relevance via stephen diehl's website :)
11:25:17 <ReinH> I love that a talk on "LLVM Optimized Python at the Harvard-Smithsonian Center for Astrophysics" is a reasonable thing to have happen.
11:26:10 <Athas> Strapping rockets to a pig.
11:40:00 <Frenchiie> I am trying to understand monad from the following source: http://adit.io/posts/2013-06-10-three-useful-monads.html#the-writer-monad  It states that the code(just above) is no longer a pure function because of side effects. I don’t understand how adding more functions inside that function where each one returns a log along with a value causes side effects and as a result makes the function un-pure.
11:40:12 <Frenchiie> From wikipedia it says that side effects in relation to impure functions are changes in state that do not depend on the function inputs. A few examples that come to mind is either a global mutable variable or a randomized result being fetched inside a function.
11:40:25 <Frenchiie> However if you look at finalValue 1. it does not take any input 2. Its result is based strictly on the static input to the half function which is 8 and where the second call to half is based on the returned result from half 8. This will always be the same.
11:40:31 <Frenchiie> Am i misunderstanding this or is the example that demonstrates monad poorly written?
11:40:54 <glguy> Frenchiie: The Monad typeclass doesn't do anything to make your functions "impure"
11:41:28 <Frenchiie> glguy: i was not trying to imply that
11:41:57 <Frenchiie> just confused on why he seems to think that function is impure 
11:42:09 <Frenchiie> and how monad is a good example in this case
11:42:19 <glguy> The function remains pure
11:42:38 <glguy> I don't see the word pure when I follow your URL
11:43:28 <mnoonan> "side-effect" is much less well-defined than "pure", I think
11:43:57 <mnoonan> you could say \x -> (x+7, "hi") is the (+7) function, plus a "side-effect"..
11:44:31 <mnoonan> that's kind of the sense in which Writer involves side-effects.
11:44:44 <glguy> You can decide to think about this as modeling a side-effect, It's not doing anything outside of a normal Haskell, however
11:46:06 <geekosaur> Frenchiie, I think the point being made is that >>= adds behavior that is not evident simply from the context in which it is used
11:46:14 <Frenchiie> mnoonan: wikipedia says " Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming."
11:46:39 <geekosaur> that behavior may be pure, but as it's not explicitly written out but instead hidden in the monad's return and >>= it is a "side effect" of sorts
11:46:56 <glguy> Frenchiie: Writer doesn't introduce any actual side-effects. You're right that the function remains a pure function
11:47:14 <mnoonan> ^ I like how geekosaur is describing it
11:47:30 <Frenchiie> glguy: but aren't monads used for handling side-effects?
11:47:36 <geekosaur> no
11:47:53 <geekosaur> IO would be side effecting even without the Monad. all the Monad does is add sequencing.
11:48:14 <geekosaur> and all that is is a funny-looking State monad
11:49:26 <mnoonan> Frenchiie, are you comfortable with Maybe as a monad?
11:49:27 <geekosaur> (it doesn't even have to be "funny-looking", that's just a ghc implementation choice to make it easier for it to remove the part that enforces sequencing once it gets to code generation, since by that point it is not needed any more)
11:49:46 <lambdamu_> We don't have an (obvious) way to interact with values of the IO type outside of it's functor/applicative/monad interfaces, so I can see why people think monads and IO have some kind of special relationship
11:49:50 <Tuplanolla> How about the medicinal analogy: it's a side-effect if you didn't intend to have it.
11:50:30 <Frenchiie> so there is no relationship between monads and side-effects?
11:50:55 <glguy> No. Monad is just an interface shared by many different types
11:50:55 <geekosaur> what you are calling a side effect, at least
11:51:02 <geekosaur> but, ^ that
11:51:21 <glguy> IO itself has effects, and IO happens to also have a Monad instance
11:51:23 <geekosaur> it's a convenient interface that happens to describe a bunch of otherwise dissimilar operations
11:51:50 <geekosaur> it's IO (and ST and STM) that are side effecting, not Monad. they also happen to fit the Monad interface.
11:52:05 <mnoonan> It's true enough to say "computations that can mutate state" form a monad; and in addition, so do many other things.
11:52:21 <lambdamu_> Frenchiie: Think of side-effects as something but not everything that can be handled conveniently by monad interfaces
11:52:49 <lambdamu_> Frenchiie: but I'm not sure there is a universal agreement on what a side-effect is, so this is not a precise statement
11:53:11 <Frenchiie> for me a side-effect is an external or none-static variable that has a relationship to a function where the same inputs won't produce the same outputs for a function.
11:53:24 <Frenchiie> the term variable is broad here
11:53:40 <Frenchiie> and this causes a function to be impure
11:53:56 <geekosaur> we already have a probkem with your terminology
11:54:24 <lambdamu_> Frenchiie: I think you would have it easier if you consider that side-effects can be implemented without causing impurity
11:54:55 <Frenchiie> lambdamu_: i thought that was the point of monads but seems i'm really wrong haha.
11:55:02 <geekosaur> strictly speaking, State monad code as written has something that would qualify as a side effect as you described it, since the state 'variable' is not explicitly mentioned. yet the code is pure; purity has a specific meaning here that is not up for discussion or alteration.
11:55:10 <Frenchiie> guess i need to dig deeper into this on my own.
11:55:13 <mnoonan> Frenchiie, would you consider printf("hi") to be a side-effect under that definition?
11:55:24 <geekosaur> while the code appears to have non-local effects, when you unwrap the monad there are none
11:55:27 <Frenchiie> mnoonan: no because the result will always be the same, won't it?
11:55:33 <lambdamu_> Frenchiie: Lets clear it up, what exactly were you told monads do?
11:56:06 <ongy> Frenchiie: can always result int a SIGPIPE.
11:56:19 <geekosaur> lambdabot, they're reading wikipedia's entry about monads
11:56:29 <mnoonan> Frenchiie, I agree (given that definition), but I also think printing stuff is clearly a side-effect of whatever your actual computation is. So to me, that's some evidence that the notion of "side-effect" should be wider.
11:57:01 <geekosaur> it's wikipedia, so how precise it is in its terminology may be up to discussion. but trying to interpret what it says according to *different* terminology conventions will get you in trouble
11:57:41 <geekosaur> and that seems to be what's happening here? they brought their own definitions of 'purity' and 'side effect' to the table and are trying to interpret wikipedia's, and Haskell's, use of them according to those
11:57:58 <mnoonan> or: if a checksum function is supposed to validate your credit card number checksum, but also exfiltrates your number to the internet.. that's a side effect I'd care about :)
11:58:23 <Frenchiie> lambdamu_: this url says that the code has side effects(which i understood to mean that the function is impure due to internal or external non-static factors) and that monads help at keeping your function pure http://adit.io/posts/2013-06-10-three-useful-monads.html#the-writer-monad
11:58:26 <geekosaur> https://xkcd.com/1860/
11:58:46 <Frenchiie> but it seems like my understanding is not right at all
11:58:50 <geekosaur> it's not indeed
11:59:19 <lambdamu_> Frenchiie: Ok so basically you equate "a function has side-effects" with "the function is impure"
11:59:30 <geekosaur> monads help you shorten code by letting you move stuff that needs to be done all the time out of your direct code 
11:59:32 <Frenchiie> lambdamu_: yes
11:59:34 <lambdamu_> Frenchiie: In haskell at least we do not equate those things
12:00:55 <Frenchiie> lambdamu_: so this wikipedia section doesn't apply to haskell? https://en.wikipedia.org/wiki/Functional_programming#Pure_functions
12:00:58 <geekosaur> one characterization of Monad is "a programmable semicolon": it can do something extra at the separator between "steps" of some operation
12:01:24 <geekosaur> Frenchiie, your definition of "side effect" is what's wrong
12:02:21 <Frenchiie> geekosaur: my definition is that side effects are changes in state that do not depend on the function inputs. Is that wrong?
12:02:31 <fendor> hey, is it possible to derive for a newtype all typeclasses that its content defines? For example, if i newtype a map, what would be the best way to define functions that work on my new type the same way as it does for a map?
12:02:59 <Frenchiie> and my definition of a pure function is one that only depends on it's input ie. for input 1,2 the result will always be 3.
12:03:21 <Frenchiie> the two seem very related.
12:03:26 <geekosaur> [17 18:52:50] <Frenchiie> for me a side-effect is an external or none-static variable that has a relationship to a function where the same inputs won't produce the same outputs for a function.
12:03:29 <geekosaur> is this no longer true?
12:04:09 <lambdamu_> Frenchiie: Well it's not wrong for some definition of side-effect, if you equate side-effects with impurity, then monads provide a convenient interface to types that *model* those side-effects *purely*
12:04:42 <Tuplanolla> Defining side effects seems a bit like defining art.
12:04:47 <geekosaur> monads _do not_ do that. they can produce things that _look_ like that is happening, but it is not
12:07:59 <mnoonan> Frenchiie, check out the description on the C++ "pure" attribute in gcc here: https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html#index-g_t_0040code_007bconst_007d-function-attribute-2507
12:08:34 <mnoonan> a key aspect is that the function should be subject to common subexpression elimination there, so you could replace "y = f() + f()" with "x = f(); y = x + x;"
12:08:40 <Frenchiie> geekosaur: when i said "an external or none-static variable(broadly speaking)" i mean't that as something that changes in state
12:08:59 <Frenchiie> geekosaur: and how it relates to a function trying to use it
12:09:16 <mnoonan> this is much stricter than the notion of side-effect that you're thinking of
12:10:04 <Frenchiie> geekosaur: maybe i'm not wording it well enough but i do believe a side effect to be what wikipedia says "side effects are changes in state that do not depend on the function inputs"
12:10:41 <Frenchiie> and to me side effects when used by a function makes it not pure anymore
12:12:14 <lambdamu_> Frenchiie: what about this function "fun x = modify (+x) :: Int -> State Int"?
12:12:36 <lambdamu_> Frenchiie: sorry "fun x = modify (+x) :: Int -> State Int Int"
12:12:40 <Frenchiie> then that url says that monad are great for side effects. however i don't see a side effect in that function. 
12:14:42 <johncc3_> Hi all. A strange question maybe (I gotthe IRC info from the Graphviz site): Does anyone know what is going on with GraphViz? I can't register - the site supposedly sent me several mails, but they did not arrive.
12:15:48 <johncc3_> (Also, their server - research.att.com - seems to be down too, though the webpage is still up)
12:15:53 <cocreature> johncc3_: you got the haskell irc channel from graphviz?
12:15:58 <cocreature> that seems … weird
12:16:55 <johncc3_> cocreature, From the Graphviz page on the haskell site.
12:17:11 <cocreature> johncc3_: can you be a bit more specific, which page are you talking about?
12:17:19 <geekosaur> sounds like an out of date wiki page
12:17:33 <johncc3_> cocreature, http://projects.haskell.org/graphviz/links.html
12:18:23 <cocreature> johncc3_: ok so why are you trying to register for something?
12:19:47 <vimalloc> I've read that you should avoid doing manual recursion when possible and stick to higher level abstractions. I have a function that I build with either manual recursion or with 'takeWhile', 'iterate', and 'find'. I find the manual recursive version to be much easier to read (but maybe that's just cause I'm new to functional programming). 
12:19:49 <johncc3_> I'm trying to get to ask a question about GraphViz, but there do not seem to be any way to contact them at the moment, not registering, not via the 'Contact' form, or any other form I could think of
12:20:23 <cocreature> johncc3_: just open an issue on the github repo https://github.com/ivan-m/graphviz
12:20:38 <geekosaur> the original authors are no longer involved with graphviz, and research.att.com is gone
12:21:13 <geekosaur> ...talking about the upstream C library, not the Gaskell binding
12:21:15 <geekosaur> *Haskell
12:21:21 <kadoban> vimalloc: Could be because you're not used to it, yeah. Or it could just be an unusual function, or therec ould be a better way to write it. You could put it on lpaste.net if you want comments
12:21:26 <cocreature> the “contact information” page has an email address of the current author but if there’s an issue tracker that’s preferable
12:21:59 <johncc3_> cocreature, Great - hadn't seen reference to github! Thanks.
12:22:28 <cocreature> johncc3_: note that this is for the haskell bindings to graphviz, not for graphviz itself
12:24:03 <schmidt73> So I'm trying to modify my .cabal file in my sandboxed project to add in other modules, but I keep getting the error: "Parse of field 'other-modules' failed."
12:24:04 <vimalloc> kadoban: Thx. It looks like this currently: http://lpaste.net/7284360633909248000. The first way just keeps looping over things until it finds what it is looking for, the second way generates a list of all things first (with iterate and takeWhile), then uses find to grab what I want.
12:24:16 <schmidt73> I thought it might have to do with spaces/tabs but I'm only using spaces
12:24:47 <vimalloc> To me the first way is much easier to parse, but input would be awesome :)
12:24:56 <johncc3_> cocreature, Seems the official graphviz page on github is https://github.com/ellson/graphviz
12:25:18 <geekosaur> schmidt73, can you lpaste the cabal file?
12:25:21 <geekosaur> @paste
12:25:21 <lambdabot> Haskell pastebin: http://lpaste.net/
12:25:50 <schmidt73> geekosaur, also should I be using sandbox init with regular init to create the .cabal file?
12:26:49 <schmidt73> http://lpaste.net/356987
12:27:17 <geekosaur> schmidt73, sandbox init is a different operation unrelated to cabal init. you would do the sandbox init first to create a sandbox, then create / work with the cabal file in it
12:28:03 <schmidt73> Oh so I did sandbox init initially
12:28:08 <dogui> I'm using vim and looking at GHC sources. After running `make tags` I'm getting `Tags file not sorted`. Does anyone know what I'm doing wrong? :)
12:28:10 <schmidt73> I want to create everything in a sandbox preferably
12:28:12 <geekosaur> ok, your problem there is that it wants a module name not a source file
12:28:21 <schmidt73> But that didn't do anything really
12:28:30 <geekosaur> other-modules: Data.Foo.Internal, MyModule
12:28:31 <schmidt73> So I did cabal init to get Setup.hs, Main.hs and rest of stuff
12:28:42 <schmidt73> Oh
12:31:02 <schmidt73> Thanks geekosaur
12:31:54 <dogui> managed to make tags work when setting `:set ignorecase`.. but I'd prefer to not do that, really..
12:33:58 <geekosaur> dogui, did you see the note at https://ghc.haskell.org/trac/ghc/wiki/Building/StandardTargets#Topleveltargets ?
12:35:10 <geekosaur> (Unicode locales generally sort case-independently; tags is an old interface and expects strict ASCII collation.)
12:35:12 <dogui> geekosaur: I hadn't :) thanks! Still finding my way around here..
12:53:03 * jared-w is hyped that I finally finished moving into the new apartment, got the internet setup, and can sit down to do some work again
12:54:03 <anieuwland> Hey guys! I'm trying to use the bindings haskell-gi to Gtk and I walked into some types that I don't understand
12:54:27 <jared-w> Which types?
12:55:18 <anieuwland> I'm supposed to set a callback with the type " Ptr () -> IO Widget ". This callback will receive an custom data type and create a gtk widget out of it
12:55:48 <anieuwland> But I don't understand how Ptr () can be anything like say... data Cookie = Delicous Int String
12:56:19 <jared-w> Do you understand what the () is doing?
12:56:42 <anieuwland> Not really
12:57:20 <jared-w> How about the Ptr? Haskell-gi is working with GTK through the FFI (foreign function interface) so Ptr is referring to an actual machine pointer
12:59:12 <anieuwland> Yes indeed. So I understand how pointers work in general, but my experience has mostly been with Java
12:59:12 <anieuwland> So I mostly see Ptr as a way of bridging the gap to C
12:59:12 <anieuwland> Then I vaguely understand that in Ptr a, the a is there to disambiguate Ptr from other instances
12:59:12 <anieuwland> But I don't get how Ptr () can be anything then, or how it can point to a Haskell data type
12:59:42 <geekosaur> do you know C? if you do, Ptr () is (void *)
13:00:27 <geekosaur> and, I'm not sure this is intended for what you are doing, it sounds like a way to make an arbitrary C-created widget into a gi-accessible widget
13:01:10 <anieuwland> Well, this is the gtk function I'm trying to use: https://developer.gnome.org/gtk3/stable/GtkFlowBox.html#gtk-flow-box-bind-model
13:01:29 <anieuwland> It enables me to just set a model and then gtk will take care of creating widgets from entries in that model
13:02:01 <anieuwland> One parameter is GtkFlowBoxCreateWidgetFunc create_widget_func, which is bound to in Haskell as type FlowBoxCreateWidgetFunc = Ptr () -> IO Widget
13:02:13 <anieuwland> ( https://hackage.haskell.org/package/gi-gtk-3.0.14/docs/GI-Gtk-Callbacks.html#t:FlowBoxCreateWidgetFunc )
13:02:51 <jared-w> And since () can pretty much be thought of as Haskell's equivalent of a C-language 'void', I'd expect Ptr () to be a pointer to whatever the hell I want it to be (eg void*)
13:02:55 <geekosaur> ok, so it's pretty much directly (void *) meaning "I accept anything you give me"
13:03:11 <anieuwland> Ahaaaaaaaaaaa
13:03:33 <anieuwland> In that case, the actual question is then, how do I turn Ptr () into Cookie?
13:03:37 <geekosaur> basically a C-style untyped interface
13:03:44 <ongy> and the way it's anything else will be http://hackage.haskell.org/package/base-4.9.1.0/docs/Foreign-Ptr.html#v:castPtr but that's pretty much C-style pointer casting. So you have to know what to cast to, and you have to make sure that's valid
13:03:48 <anieuwland> I see, I see
13:04:54 <anieuwland> So I would need to define my own instance Ptr Cookie? (Sorry for the silly Cookie-example)
13:05:36 <anieuwland> hmm
13:06:31 <ongy> Ptr takes a type as argument to create another type. So casting to Ptr Cookie should work (provided Cookie is in scope) the question is, if it's going to help
13:06:46 <geekosaur> this requires a little cleverness. you want a Storable instance for Cookie, which will let you talk about Ptr Cookie and pass it to C
13:06:56 <jle`> is there any typeclass people use that would let me delete items from tuples
13:07:00 <jle`> generically
13:08:38 <jared-w> Hmm... idk, I fee like if you need a generic way to manipulate tuples in Haskell, you're no longer really talking about tuples?
13:08:45 <jle`> akin to those ad-hoc Field1/Field2/etc. typeclasses
13:08:48 <anieuwland> hmm, haven't worked with Storable yet. Let me see
13:09:18 <jle`> it's just that this api gives me a 4-tuple as a result and i just want three of the items
13:09:28 <jle`> maybe two
13:09:30 <jle`> :o
13:09:31 <Unicorn_Princess> how can I make stack build using multiple threads?
13:10:06 <geekosaur> generally you can;t because ghc can't, because of hidden dependencies on e.g. interface files
13:10:17 <Unicorn_Princess> :S
13:10:30 <Unicorn_Princess> that's pretty terrible
13:10:41 <jared-w> jle`: Make a new tuple out of the 4-tuple using only some of the items?
13:10:42 <Tuplanolla> I'd imagine there would be a way to use `both` to view the `Field2` part of the tuple, jle`.
13:11:01 <jle`> jared-w: yes that is probably the disciplined way
13:11:16 <jle`> but i wanted to be lazy and avoid pattern matching
13:11:21 <jle`> and picking names for the fields
13:11:23 <jle`> ew
13:11:38 <Tuplanolla> > (view _1 &&& view _2) (1, 2, 3, 4) -- Something like this.
13:11:40 <lambdabot>  (1,2)
13:12:04 <jle`> > ((,,) <$> view _1 <*> view _2 <*> view _4) (1,2,3,4)
13:12:07 <lambdabot>  (1,2,4)
13:12:17 <geekosaur> well. in theory it could build each module with a separate ghc (process nstead of thread parallel), but the overhead of each individual ghc is higher than the gain from parallel build
13:12:18 <jle`> at that point i might as well just pattern match i guess
13:12:44 <jared-w> jle`: but then you don't get to show off your 1337 lens skills
13:12:48 <Tuplanolla> Is there a clean way to compose lenses "in parallel"?
13:12:57 <geekosaur> and ghc devs' experimentation indicated that threads don't help and actually make things worse because of contention for ghc's global state (mostly over module interface information)
13:13:48 <jared-w> Huh... interesting. Makes sense, though
13:14:25 <geekosaur> Unicorn_Princess, uf you are looking for a faster build, try --ghc-options '+RTS -A128M -RTS'
13:14:53 <geekosaur> ghc defaults to a fairly small initial heap and small heap growths, and this turns out to cost a fair amount of extra time spent reallocating
13:16:08 <Gurkenglas> jle`, http://hackage.haskell.org/package/tuple-lenses-0.1.0.2/docs/Data-Tuple-Lens.html#v:_124
13:16:15 <jared-w> Is there any reasons that default hasn't been changed, geekosaur?
13:16:33 <geekosaur> jared-w, they only became aware of it in the run-up to ghc 8.2
13:16:54 <geekosaur> it's a priority for 8.4, if I understand correctly
13:17:06 <jle`> Gurkenglas: haha
13:17:25 <geekosaur> the usual assumption is the runtime handles this well enough on its own... welp
13:17:44 <Unicorn_Princess> how come stack can't build in parallel? according to https://stackoverflow.com/questions/7854487/parallel-cabal-builds , cabal can, and ghc too, or am I mistaken?
13:17:46 <geekosaur> possibly 64 bit ghcs in particular should just bump the default limit in the runtime
13:18:26 <jared-w> Unicorn_Princess: I don't think -j actually is parallel, it's just using multiple cores in cabal
13:18:49 <Unicorn_Princess> uh, what's the difference between using multiple cores, and being parallel?
13:19:06 <geekosaur> "You might want to add to your answer this doesn't speed up the installation of a single package - it just installs multiple packages at the same time. Therefore cabal install -j mypackage will not bring any benefit, only cabal install -j package1 package2 will."
13:19:22 <geekosaur> in the comments to the top answer
13:19:58 <geekosaur> when stack is building multiple packages, it's usually as dependencies, so there's often a dependency that requires one be built before the other
13:20:01 <Unicorn_Princess> huh. ok, lets say I have some huge haskell project I want to build, and a fancy new 16 core cpu - what's the status, is it gonna burn only 1 core?
13:20:11 <jared-w> Parallel has this mental implication of efficiency. Using multiple cores makes no guarantee to that; it's more honest. Also, what geekosaur said :p
13:21:07 <geekosaur> the second answer on that page gives more information and pointers about why ghc is not itself parallel enabled
13:21:48 <geekosaur> but it's basically what I said earlier: the overhead of mutexing in-common data is higher than the gain
13:22:34 <geekosaur> since interface information for a module changes when it is (re)compiled (which is also why ghc has such ridiculous versioning constraints; the interface information is part of the binary interface and must match exactly)
13:23:00 <jared-w> Honestly, I'm not really sure how to really and truly take advantage of parallelization in GHC better without almost rewriting the thing. It's written in a fairly imperative style of Haskell (not sure how much difference that makes?)
13:23:39 <jared-w> It might also be an inherent "flaw" in the module design and innermost design implementations of Haskell in general? I haven't looked a ton into that, but I see modules as a common "pain point" for things like this
13:24:38 <bitemyapp> geekosaur: I tested those ghc-options, no perceptible difference on rebuilding a library
13:24:42 <EvanR> someone decided separate compilation is a thing to want
13:25:00 <bitemyapp> I make a whitespace modification to a 2-4kloc types module and rebuild, it was 155 seconds vs. 153 seconds.
13:25:34 <bitemyapp> but I might've used the arguments incorrectly.
13:26:08 <geekosaur> I might also have spcified them incorrectly, I tried to stack-friendly them but I don't really know what I am doing there :/
13:26:18 <mizu_no_oto> Unicorn_Princess: `cabal install --dependencies-only -j15` should run much faster, but rebuilding your project probably won't be much faster.
13:26:22 <bitemyapp> stack build vs. stack build --ghc-options '+RTS -A128M -RTS'
13:26:37 <geekosaur> ghc:   -A<size> Sets the minimum allocation area size (default 512k) Egs: -A1m -A10k
13:26:42 <bitemyapp> mmhmm
13:26:58 <geekosaur> 512k's kinda miserably small for ghc
13:27:06 <bitemyapp> I knew your thing was right and I'm pretty sure Stack passed them on correctly as I use ghc-options semi-regularly via the command line and Stack's yaml file.
13:27:16 <bitemyapp> I'm just sad it doesn't make my stuff faster :(
13:27:22 <bitemyapp> It's a gnarly build for me.
13:27:28 <geekosaur> I should also mention they discovered an explosion in typechecker memory usage during 8.2 release and they are poking at that for 8.4
13:27:42 <bitemyapp> oh yeah I'm not using GHC 8.2 here
13:27:46 <bitemyapp> I think it's 8.0
13:27:48 <geekosaur> if that's involved in your test then heap tweaks won't help much unless you want to use gigabytes
13:28:02 <geekosaur> apparently the explosion goes back to 7.8 or something
13:28:07 <bitemyapp> egads
13:28:28 <bitemyapp> it's a 5.5 kloc file, I really need to find out why it chugs the compiler so badly.
13:28:44 <bitemyapp> I am guessing Generics, but I cannot say for sure.
13:29:03 <ongy> why do you even have a 5.5k loc file? Shouldn't that be split at some point?
13:29:14 * bitemyapp shrugs
13:29:24 <jared-w> I've heard some of the ways of deriving Generics are much more intensive than others... I'd say that's likely a potential cause?
13:29:27 <bitemyapp> Didn't matter? Nobody imports this module by itself.
13:29:54 <bitemyapp> It just makes working on the code more annoying if you have to jump between modules, but so do nasty compile times, so at some point compile time ergonomics are going to win out here.
13:30:07 <bitemyapp> jared-w: that's been my guess for awhile now.
13:30:34 <geekosaur> in any case these things are known but were discovered too late for 8.2, so they're priorities for 8.4
13:31:00 <geekosaur> (8.2 already being a couple months behind schedule)
13:31:36 <Athas> Does that mean 8.4 will have a shorter cycle?
13:32:00 <Athas> Out of curiosity, what delayed GHC 8.2?
13:32:03 <jared-w> ¯\_(ツ)_/¯ 8.4 also has some big stuff planned for it, so who knows
13:32:43 <jared-w> Athas: 8.2, iirc, was originally just a "bug fixes, improvements, streamlining, etc" milestone for GHC. Then they added in Backpack and a few other cool stuff.
13:33:19 <jared-w> The problem with making a bug fix build is that there's never an end to bugs and improvements, so if you're not super rigorous about saying "we're only doing X" it's really easy to add too much to your plate :p (I'm just guessing this is what happened)
13:33:23 <Athas> Yes, I remember being confused at the first 8.2 RC announcement, since it only mentioned new features!
13:33:40 <Athas> I think the latter ones mentioned compile time improvements more prominently.
13:36:36 <WhereIsMySpoon_> Hi, I'm trying to follow https://github.com/jano017/Discord.hs and it says to add discord-hs to my build-depends
13:36:38 <WhereIsMySpoon_> what does that actually mean
13:37:13 <WhereIsMySpoon_> https://gist.github.com/anonymous/5c9d694ce18ebfaaf8ed69a9a2c21ec8
13:37:15 <WhereIsMySpoon_> thats it so far
13:37:17 <WhereIsMySpoon_> its just been generate
13:38:04 <anieuwland> Is there any other way to marshal Ptr () to a Haskell data type? I looked at Storable but I fear my own data type is too complex for it. It uses lists for example...
13:38:35 <geekosaur> WhereIsMySpoon_, build-depends: base >= 4.7 && < 5, discord-hs
13:38:49 <WhereIsMySpoon_> geekosaur: o right, its just comma separated 
13:38:50 <WhereIsMySpoon_> thanks!
13:38:52 <geekosaur> possibly with a version constraint on discord-hs in case its interface changes in the future
13:39:16 <WhereIsMySpoon_> ill worry about that later
13:39:19 <geekosaur> anieuwland, there's hsc2hs to generate them but it's moderately painful
13:39:52 <geekosaur> also c2hs but that works from a description of the C type
13:40:22 <anieuwland> the data type I want it to cast to isn't defined in C though, but in Haskell
13:40:29 <WhereIsMySpoon_> now to find out how to use cabal to download dependencies and shit :P
13:40:36 <anieuwland> Or is that hsc2hs?
13:40:46 <geekosaur> that's hsc2hs
13:40:55 <EvanR> anieuwland: you want to convert a complex C data structure into a haskell value?
13:41:21 <speak> Hi, doing a small website exercise. Any input for this test run, just reading a flatfile that has links listed in url|title notion: https://paste.xinu.at/nSJj/
13:41:26 <anieuwland> EvanR: No, I have a haskell data type that goes through a C library (gtk) and comes back as a Ptr (). I want to cast it back to its Haskell data type
13:41:46 <EvanR> im not sure how thats possible
13:41:48 <speak> readUrlsFromFile is the function in question. I'm sure it screams noob
13:42:03 <EvanR> unless its essentially what i said
13:42:34 <EvanR> gtk is handling pointers into GHC's heap? doesnt sound right
13:42:38 <anieuwland> Okay, wait, no
13:43:16 <anieuwland> I want to pass a callback function to gtk with the type signature of Ptr () -> ...
13:43:22 <geekosaur> EvanR, anieuwland, what happens here is you have a Storable instance somehow for the Haskell type, so when it is passed to C it is rebuilt into a C data value which is passed on
13:43:48 <geekosaur> then when you get it back, it needs to be unmarshaled back into a Haskell type, which again the Storable instance handles.
13:43:56 <anieuwland> Then my data type will passed as the first parameter to that callback, but I need to convert it to satisfy Haskell's type checker
13:44:09 <anieuwland> Yes, what geekosaur said :)
13:44:13 <geekosaur> Ptr SomeType tells the FFI to use SomeType's Storable instance for this
13:44:42 <geekosaur> so, given that Storable istance, all you'd need to do here is castPtr to tell it the generic pointer is actually a pointer to the Haskell data
13:44:43 <EvanR> ok everyone agrees
13:44:54 <EvanR> just no one agrees each other is saying the same thing
13:44:55 <geekosaur> the question is, getting that Storable instance
13:45:41 <EvanR> i dont see a complex C type with multiple objects connected by pointers being Storable, but you could do it via multiple uses of Storable methods
13:47:59 <anieuwland> I think you're right, in that I'm not sure now whetehr we're saying the same thing :p
13:48:42 <anieuwland> The type is originally defined in Haskell. It has a string (list of chars) and a third party Haskell object
13:48:48 <EvanR> are you unsure about the () in Ptr () ?
13:48:55 <EvanR> that can be arbitrarily casted to whatever you want
13:49:01 <EvanR> using castPtr
13:49:09 <anieuwland> Indeed
13:49:12 <anieuwland> But I don't know how
13:49:17 <EvanR> :t castPtr
13:49:19 <lambdabot> error: Variable not in scope: castPtr
13:49:44 <geekosaur> :t Foreign.Ptr.castPtr
13:49:45 <lambdabot> GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
13:49:51 <anieuwland> Say I have data Cookie = Cookie String Bool
13:50:05 <geekosaur> this is C++'s reinterpret_cast, i.e. it just tells it a pointer to a is really a pointer to b
13:50:06 <anieuwland> castPtr must be Ptr () -> Ptr Cookie
13:50:21 <EvanR> thatll work
13:50:28 <EvanR> but youll need a type annotation somewhere
13:50:30 <geekosaur> which is what you need when yoy get a (void *) aka Ptr () and need to use it at the actual Haskell type instead of the untyped C type
13:50:49 <EvanR> let ptr' = castPtr ptr :: Ptr Cookie in ...
13:51:02 <EvanR> warning, highly unsafe
13:51:30 <geekosaur> Ptr is used when working with C, how is it ever safe? :p
13:51:34 <anieuwland> :p
13:51:46 <geekosaur> Ptr means 'entering segfault land, travel at your own risk'
13:51:47 <anieuwland> EvanR: wait, I'm not sure I understand
13:52:08 <EvanR> if ptr :: Ptr (), then castPtr ptr could have type Ptr Cookie if you wanted
13:52:24 <EvanR> the a and b in the type of castPtr are whatever two types you want
13:52:36 <anieuwland> Don't I need to define an instance Storable Cookie to do that?
13:52:47 <EvanR> if you want to peek and poke Ptr Cookie, yes
13:53:07 <EvanR> to e.g. get a Cookie
13:53:08 <anieuwland> Can I just say ptr' = castPtr :: Ptr () -> Ptr Cookie?
13:53:19 <EvanR> thats... not what you want though
13:53:29 <EvanR> ptr' is now a function, not a pointer
13:53:55 <AWizzArd> If you have to estimate this by your experience: what is easier to graps? Arrows or free monads? Which should be studied first?
13:54:16 <geekosaur> AWizzArd, free monads
13:54:19 <anieuwland> Okay, so renamed it'd be caster = castPtr :: Ptr () -> Ptr Cookie
13:54:31 <jle`> i don't think the two concepts really belong in the same category
13:54:32 <AWizzArd> geekosaur: do you have a link to the „best” free monad tutorial?
13:54:34 <EvanR> mySpecializedCast = castPtr :: Ptr () -> Ptr Cookie, ok sure
13:54:35 <jle`> arrows is a typeclass
13:54:37 <anieuwland> And caster ptr would actually turn into a Cookie?
13:54:41 <EvanR> its a bit roundabout
13:54:50 <jle`> the free monad is a specific abstract data type
13:54:51 <geekosaur> Arrows are an older abstraction that is of limited use these days outside some FRP frameworks; it turned out to be Profunctor + Applicative
13:54:56 <AWizzArd> jle`: they can be totally different concepts, but some things are easier to understand than others.
13:55:09 <anieuwland> EvanR: ...and this works, relatively reliably? Not doubting you, just a bit apprehensive :p
13:55:22 <EvanR> what does "works" mean ?
13:55:28 <jle`> yeah, but "understanding" them is kind of a different question
13:55:34 <geekosaur> anieuwland, insofar as you trust gtk to do what you told it
13:55:43 <jle`> but yes, to answer your actual question, you should learn free monads
13:55:48 <jle`> arrows aren't really in use anymore
13:55:56 <anieuwland> Is it like the equivalent of casting in Java, like String s = (String) object;?
13:55:58 <EvanR> im not really not sure how a linked list from C can be Storable
13:55:59 <AWizzArd> jle`: do you have a link to some good tutorial about free monads?
13:56:13 <jle`> Arrow is a very very niche abstraction at best, and an outdated abstraction at worst
13:56:21 <geekosaur> anieuwland, in that context yes
13:56:23 <anieuwland> EvanR, geekosaur: Works as in compiles and does not crash, generally 
13:56:32 <EvanR> compiles yes
13:56:36 <EvanR> does not crash, thats up to you
13:56:41 <anieuwland> Hahaha
13:56:42 <geekosaur> "casting" is somewhat overloaded; C++ breaks up the different kinds of casts, and this is reinterpret_cast
13:56:46 <anieuwland> Yes, I feared so :(
13:56:48 <jle`> there isn't any reason to study Arrow unless you actually are working with a library that offers an Arrow API
13:56:55 <jle`> and in that case you don't even need to 'understand' Arrow
13:57:05 <jle`> you need to understand the functions for the data type that they export
13:57:09 <geekosaur> there's an addiitonal issue in that you likely need to ensure the data being passed to C is in pinned memory
13:57:23 <AWizzArd> jle`: okay I see. So I will study them later and do the free monads first.
13:57:28 <geekosaur> because gtk just stores the pointer, so the pointed-to memory must be persistent
13:57:40 <geekosaur> for this, you may want to look at Foreign.ForeignPtr
13:57:44 <jle`> there is no need to study Arrow in and of itself
13:57:45 <EvanR> is that what anieuwland is trying to do?
13:57:55 <geekosaur> EvanR, yes
13:58:07 * EvanR readjusts context
13:58:07 <jle`> learning arrow for the sake of learning arrow is like learning a dead language in case you somehow end up in a city that only speaks it
13:58:20 <geekosaur> that's what the gtk API anieuwland wants to use does
13:58:25 <anieuwland> geekosaur, EvanR: Oh dear, we're getting into poitner territory I'm unfamiliar with
13:58:34 <AWizzArd> jle`: it is mentioned on some Haskell websites. So for a broad understanding, and also to know a bit more about the history of Haskell, I would like to study them at some point.
13:58:36 <anieuwland> The difference between ForeignPtr and Ptr...
13:58:49 <EvanR> same thing but ForeignPtr has finalizers
13:58:53 <AWizzArd> But knowing that they are mostly outdated nowadays helps to priotize.
13:59:03 <jle`> AWizzArd: you can study it for historical purposes, but don't expect any practical or theoretical benefit :)
13:59:11 <EvanR> the docs explain it all
13:59:12 <AWizzArd> jle`: yes good
13:59:30 <anieuwland> okay
13:59:32 <AWizzArd> But about those free monads again – any suggestions/links to good tutorials? Google brings up some. I would like to start with a very good one.
13:59:38 <jle`> anyway the source that i "got" free monad from was reading through these stack overflow answers
13:59:40 <jle`> https://stackoverflow.com/questions/13352205/what-are-free-monads
13:59:53 <Tuplanolla> Well, conal_ has put `Arrow` without `arr` into good use, AWizzArd.
14:00:10 <AWizzArd> jle`: good tip, thx. Will have a look at that one.
14:00:11 <EvanR> monad tutorials are like sex, better when free
14:00:31 <anieuwland> EvanR, geekosaur: Thanks guys. I'm not sure yet if I've found _the_ solution and I might need to readjust my approach, but at least I got much farther (Y) 
14:00:37 <jle`> this isn't a too bad introduction to the common "free monad itnerpreter pattern" too, https://softwareengineering.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
14:01:17 <jle`> i actually have never run into a good use for the free monad other than using the "interpreter pattern"
14:01:31 <EvanR> i thought that was the same thing
14:01:50 <EvanR> like, you cant use a free monad other than by interpreting 
14:02:04 <jle`> well, for a loose definition of "interpreting"
14:02:19 <EvanR> yep!
14:02:34 <EvanR> whats a strict one :)
14:02:37 <jle`> but by interpreter here i mean the interpreted-language sort of interpreting
14:02:46 <EvanR> which is... 
14:02:46 <jle`> DSL kinda thing
14:03:15 <EvanR> its kind of like a strict definition of free thing
14:03:37 <EvanR> which side of an adjuction is the free one which is forgetful
14:03:54 <EvanR> its colloquial
14:04:10 <EvanR> what kind of functions are strict interpreters, which are loose
14:04:32 <jle`> well, you "use" Free f by using `iterM :: (f (m a) -> m a) -> Free f a -> m a` ... provide an (f (m a) -> m a) to 'execute' all of the sequential layers of the Free f a
14:04:51 <jle`> and a common thing to do is have 'f (m a)' represent actions to execute
14:04:53 <jle`> in monad m
14:05:03 <EvanR> yeah ive definitely done other things
14:05:05 <jle`> like, have your 'f' represent IO actions or database actions and stuff
14:05:15 <EvanR> i dont always interpret as another monad
14:05:52 <jle`> but yeah, i mean to say that this pattern is the "interpreter pattern" -- make a Functor f whose constructors represent actions in some executable context
14:05:58 <EvanR> unless everything is IO by transitivity
14:06:14 <jle`> and by using Free you get the ability to sequence your actions "for free"
14:06:29 <jle`> and also the ability to swap out the executable context by passing in different (f (m a) -> m a)'s to iterM
14:07:12 <jle`> so like, most applications of Free that i've seen or used have been basically this interpreter pattern, where the functor represents actions to be executed
14:08:41 <jle`> so when people say "Free is useful", sometimes they conflate it with "the interpreter pattern is useful"
14:09:46 <EvanR> i guess it gets tough to see the trees from the "the function pattern" sometimes
14:11:41 <bash0r> Hi everybody, a few hours ago I came across ((->) a) and obviously the reader monad. I'd like to learn more about this issue.
14:13:46 <c_wraith> bash0r: what's the issue?
14:19:26 <bash0r> I have this question on Stack Overflow: https://stackoverflow.com/questions/45153035/any-level-of-implicit-parameter-dispatch-with-help-of-the-monadic-interface-on
14:20:11 <bash0r> It's mainly about the behavior of the monadic interface which allows us to bring the result of arbitary computations on the very same parameter with different results.
14:20:34 <EvanR> it helps to implement Reader yourself
14:20:48 <bash0r> I understand what they do and why they do.
14:21:04 <bash0r> It's just like (>>=) resembles a let binding with implicit parameter passing.
14:22:06 <bash0r> I'm more interested in the highler level constructs which are now formed. E.g. making a pure function act stateful on a function [String] -> [String] like I constructed in the question on Stack Overflow.
14:29:14 <EvanR> that is just supplying the current state in addition to returning an updated state
14:29:28 <EvanR> along with whatever other inputs
14:29:51 <bash0r> So my question on Stack Overflow is actually dumb and I should take it down.
14:29:52 <bash0r> Right?
14:31:04 <EvanR> i just looked at it, its tough to follow
14:31:41 <erisco> let me look at it
14:31:52 <erisco> SO moderator in the house
14:31:52 <jle`> bash0r: type Reader = (->)
14:31:53 <bash0r> Sorry, it's hard to find words for things you don't know. I didn't had any contact with Reader or ((->) a), yet.
14:31:56 <EvanR> if you want to look at some other resources on monads, then you can look at the original monad paper
14:32:00 <jle`> bash0r: ask = id
14:32:11 <jle`> bash0r: asks = id
14:32:17 <bash0r> Monads are well known to me.
14:32:24 <jle`> bash0r: runReader = ($)
14:32:24 <bash0r> It's just this particular instance.
14:32:24 <EvanR> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
14:32:39 <cht> If I have my isomorphisms right, it doesn't matter what order you compose WriterT and StateT in. I was kinda surprised by this sense I was told to be super careful about order in a monad stack. Is there any way to tell exactly when order doesn't matter? Or just somewhere to read about this? 
14:32:45 <EvanR> what is your specific question about Reader ?
14:33:07 <EvanR> that is something i checked the page to find out, and didnt
14:33:15 <jle`> cht: usually you can just look at the isomorphic types
14:33:25 <jle`> and, for the monads in transformers, that's just what the newtype wrappers wrap
14:33:37 <erisco> has to be this one, yes? https://stackoverflow.com/q/45153035/260584
14:33:37 <jle`> @unmtl WriterT w (State s) a
14:33:37 <lambdabot> s -> (a, w, s)
14:33:39 <bash0r> I guess (>>=) resembles somewhat of a let binding with implicit parameter passing.
14:33:48 <jle`> @unmtl StateT s (Writer w) a
14:33:48 <lambdabot> s -> (a, s, w)
14:34:05 <bash0r> erisco: yes, exactly this one.
14:34:11 <shirt> @botsnack
14:34:11 <lambdabot> :)
14:34:14 <AWizzArd> What is the Haskell equivalent to Clojure’s Transducers?
14:34:49 <EvanR> theres a blog post about that...
14:35:03 <EvanR> a transducer is a reducer transformer
14:35:10 <AWizzArd> I found two posts about a Haskell implementation of Transducers.
14:35:21 <EvanR> http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/
14:35:30 <AWizzArd> But one blog mentioned that such techniques are in use in statically typed functional programming languages since two decades.
14:36:03 <AWizzArd> Yes, this one: the techniques are two decades old in the Haskell community
14:36:05 <EvanR> type Reducer a r = r -> a -> r
14:36:23 <EvanR> and to make a transformer of this, you need higher rank types
14:36:34 <AWizzArd> So, I wonder if there is some lib that is regularily used. Outside of this blog post.
14:37:10 <EvanR> clojure transducers exploits them in some way to use mutable references
14:37:25 <EvanR> which doesnt really apply in haskell
14:39:01 <erisco> bash0r, I can tell you that your question is not a good fit for Stack Overflow
14:41:00 <erisco> bash0r, q1 is not clear because, given any of your conclusions, it is a question of if the code works or doesn't work
14:41:08 <erisco> actually let me tell you in private message
14:41:10 <EvanR> AWizzArd: maybe check out the foldl package
14:42:12 <AWizzArd> EvanR: in Clojure some of the transducer functions return stateful transducers. State, which under the hood, gets mutated.
14:42:56 <EvanR> to get a performance boost right, its still pure?
14:43:02 <AWizzArd> https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj#L4240  for example
14:43:18 <AWizzArd> Outside callers don’t see the mutation. In Haskell one would maybe use ST.
14:44:07 <EvanR> right, though i dont think it would work as such
14:44:11 <AWizzArd> Basically transducers bring a few advantages. Performance: you can compose them but you have to traverse the structure still only once. Haskell doesn’t need this, because it has fusion.
14:44:32 <AWizzArd> But they abstract the input and output structures away.
14:45:07 <AWizzArd> I don’t know if Foldable is the same. If it were, then there would be no need for the lengthy blog posts.
14:45:35 <EvanR> the foldl package is about composing folds sort of like the transducers-in-hasklel post
14:46:32 <EvanR> i got the feeling transducers in clojure were a specific trick to deal with some idiosyncracies of clojure
14:46:48 <EvanR> and get more performance
14:47:48 <erisco> Hasklel would be a good blog name
14:47:56 <AWizzArd> The performance thing is true. If we take ordinary loops in Common Lisp, Java, Python, etc – if we want to run over a seq of user ids to fetch users, then map over those to collect their first names and then loop over those to measure their lengths then with loops we would again and again traverse the seqs.
14:48:21 <EvanR> yeah p. bad
14:48:22 <AWizzArd> In Clojure this is done lazily, so only one traversal. But there are intermediate objects, the lazy thunks.
14:48:39 <AWizzArd> In Haskell too. But thanks to fusion they go often away, if I understand this correctly.
14:49:28 <AWizzArd> However, one of the core points of transducers is that they don’t care what the input type is. It can be lists, sets, maps, streams, etc. Same with output.
14:49:37 <EvanR> if you traverse a list in two ways, i do think youll end up not only traversing it twice but ending up with a large list in memory
14:50:00 <EvanR> instead of lazily consuming it
14:50:00 <erisco> huh, I didn't think of that...
14:50:16 <EvanR> fusion helps if you chain list processing functions together 
14:50:45 <AWizzArd> Yes. You can have different functions that each map/filter/fold and compose them. This is okay.
14:50:56 <AWizzArd> With ordinary loops from most imperative langs this would be expensive.
14:51:03 <erisco> yeah you are either paying for memory or for constructing the list again with multiple traversals
14:51:04 <AWizzArd> So loops don’t compose.
14:51:23 <AWizzArd> With lazy seqs there’s only one traversal, but there will be intermediate thunks.
14:51:36 <erisco> I was thinking that the memory access pattern is moot most of the time, but now obviously that isn't the significant matter
14:51:40 <AWizzArd> In my understanding fusion is removing those. There will be just one.
14:52:09 <AWizzArd> And importantly: Transducers just care about the computation. +3. If it adds this to elements of a list that’s fine, but it can also be some other structure.
14:54:24 <AWizzArd> EvanR: how can we take every n-th element out of a structure in Haskell?
14:54:49 <EvanR> "a structure" ?
14:55:03 <EvanR> or a list
14:55:16 <AWizzArd> Something like a list. But it can be also a hashmap, a tree, a set, a vector, etc.
14:55:23 <EvanR> i beg to differ
14:55:36 <EvanR> for instance hashmap is "unordered"
14:55:52 <EvanR> whats the nth element of a tree?
14:56:02 <AWizzArd> An ordered map ten.
14:56:14 <EvanR> clojure seems to think things make sense by default
14:56:25 <plugin_> I wonder if any type-wizards can advise:  I'm trying to encode a type-level graph via a GADT and a typeclass constraint but I can't seem to fold over the resultant graph because of scoping issues.   Gist here: https://gist.github.com/o1lo01ol1o/020b372608183f4ba4e591078a514c7e
14:56:45 <AWizzArd> EvanR: I guess the point is that it should also work for other things than just lists.
14:56:55 <EvanR> AWizzArd: well, you create a list of the thing you want to do this to, and use the list version
14:57:14 <EvanR> theres Foldable
14:57:29 <AWizzArd> Yes, and Traversable. I was already thinking of these.
14:57:36 <EvanR> it might skip the list stp
14:57:51 <AWizzArd> But if it were that easy, why would that guy write this long post and implement transducers in Haskell?
14:58:20 <AWizzArd> And especially the statement at the end, that this is done since two decades in Haskell is what confuses me I guess.
14:58:22 <EvanR> its because transducers got a lot of attention among clojure people only, and at some point someone said haskell couldnt do it because of the type system
14:58:41 <EvanR> thus you have an attempt to understand them in haskell terms 
14:58:53 <AWizzArd> EvanR: yeah, I think Hickey motivated this a little bit, because he mentioned that he would be curious to see how a statically typed lang would tackle this.
14:59:57 <EvanR> but its either missing the original point or we surpass the use cases with other patterns
15:00:59 <AWizzArd> EvanR: I will probably have to contact the author and ask what he meant by that statement in the conclusion.
15:01:12 <EvanR> the existential or higher ranked type for the transformer is interesting in its own right, so im glad that happened
15:01:28 <EvanR> with the basic type system you couldnt do it
15:02:22 <AWizzArd> Although I didn’t understand that part yet.
15:02:37 <AWizzArd> Those ranked types are still confusing. I know it has to do with the forall thing.
15:03:33 <EvanR> higher ranked polymorphism, allows you to delay the choice of type
15:04:06 <EvanR> pass a function into a function "as-is" even if its polymorphic, dont have to pick the type now
15:04:40 <AWizzArd> EvanR: can you provide a small example where Rank-1 is shown, where the type has to be picked „now”?
15:04:47 <EvanR> they say the callee picks the type, in the case of rank 2
15:05:03 <EvanR> map (+1) [1,2,3]
15:05:08 <AWizzArd> And in rank 1 the callER picks the type?
15:05:18 <EvanR> yeah
15:05:36 <EvanR> in that case the type of map is determined "by me"
15:05:46 <EvanR> to be (Int -> Int) -> [Int] -> [Int]
15:06:06 <AWizzArd> I agree.
15:06:37 <EvanR> in the code for map, they dont have a choice
15:06:50 <EvanR> its any type
15:06:59 <EvanR> the function that is, its (a -> b)
15:07:13 <EvanR> so they cant use information about a or b
15:07:31 <AWizzArd> And what is a smallish example for Rank-2?
15:07:34 <monochrom> Rank-2 example is like: fm :: (forall a. a -> [a]) -> ([Int], [Bool]); fm g = (g 5, g False)
15:07:58 <monochrom> So fm is the one picking a=what, and in fact it picks two usages.
15:08:43 <AWizzArd> monochrom: it can „reuse” the type a and give it another meaning.
15:08:50 <monochrom> You the user, OTOH, cannot. You really have to give me (replicate 5) or something. You cannot give me "\x -> if x=0 then [] else [x,x,x]".
15:08:51 <AWizzArd> Another concrete type.
15:08:56 <EvanR> it reuses the type forall a . a -> [a]
15:09:07 <EvanR> it respecializes it
15:09:38 <monochrom> Now, even for fm2 :: (forall a. a->[a]) -> [Int]; fm2 g = g 10
15:09:46 <EvanR> the end result of all this is i can sanely get away with omitting type variables in my newtypes :)
15:09:51 <AWizzArd> Without the type signature, without the forall the `a` would have to be the same, not one time Int and the other time Bool
15:09:52 <EvanR> thats the weird way i understand it
15:09:59 <monochrom> you still cannot give me  "\x -> if x=0 then [] else [x,x,x]". Even if you know I'm just going to do a=Int.
15:10:28 <EvanR> AWizzArd: not only does it have to be the same, it has to be *anything*, from your perspective
15:10:39 <EvanR> its an unknown
15:15:56 <monochrom> Programming is a dialetic class struggle between the caller and the callee.
15:17:07 <monochrom> With rank-n parametric polymorphism, the "rank-n" and "polymorphism" parts say that the caller instantiates some type variables, and the callee instantiates the others, depending on where the "forall"s appear.
15:17:41 <EvanR> doesnt it alternate?
15:17:45 <monochrom> And the "parametric" part means: If you are not the instantiator, then you are never told what the other side has chosen. Not even during run time.
15:18:02 <monochrom> Your code, if you provide any, must work in the blind.
15:18:30 <monochrom> Cannot even say "I'll wait until run time to ask whether the other guy chose Int". No one will answer you.
15:19:36 <EvanR> no typecase for you
15:20:00 <monochrom> So typical OOP dissatisfies the "parametric" part because they let you ask "instanceof".
15:20:44 <monochrom> Or alternatively, you shouldn't even analogize and compare.
15:21:30 <monochrom> There is some merit in "don't consider classes to be types".
15:23:45 <monochrom> Sometimes parametricity gets into the way. It's pretty restrictive. When you find it a good idea to ask "what's the run-time type?", we have the Typeable class.
15:31:27 <EvanR> "what is a class really"
15:36:40 * hackagebot config-ini 0.1.2.1 – A library for simple INI-based configuration files. – https://hackage.haskell.org/package/config-ini
15:58:57 <steven_is_false> Does the binomial theorem have an interpretation in type theory?
15:59:15 <steven_is_false> We can define sum types as a + b = forall c. (a -> c) -> (b -> c) -> c
15:59:38 <steven_is_false> It'd be interesting if a similar thing could be done for existentials with forall c. c /\ (c -> a + b)
15:59:50 <steven_is_false> But that needs a binomial theorem equivalent
16:00:55 <steven_is_false> Sorry I meant exists c. c /\ (c -> a + b)
16:03:42 <Tuplanolla> I don't see how the binomial theorem plays into this, steven_is_false.
16:04:12 <steven_is_false> Tuplanolla: c -> a + b is similar to the numerical exponent (a + b)^c which expands according to the binomial theorem
16:04:57 <Tuplanolla> Oh, that way.
16:05:59 <EvanR> if you do type algebra to construct type- real numbers, then you have a whole new meaning to "pi type"
16:08:02 * hackagebot concrete-haskell 0.1.0.9 – Library for the Concrete data format. – https://hackage.haskell.org/package/concrete-haskell
16:22:11 <steven_is_false> Is there a haskell library that implements the unordered tuple type described in https://byorgey.wordpress.com/2012/08/24/unordered-tuples-and-type-algebra/
16:22:31 <tac-tics> If I'm getting an exception, is there a way I can compile to have the runtime spit out the file and lineno the exception was thrown?
16:27:09 <geekosaur> tac-tics, you have to annotate things with a HasCallStack constraint
16:27:31 <tac-tics> I was hoping there would be something that wouldn't involve me editing the code :(
16:27:34 <tac-tics> oh well
16:28:18 <geekosaur> the feature is still in flux, some -f to automatically add that constraint to all bindings might happen in the future
16:28:20 <tac-tics> Unrelated: Is there a flag to have stack/ghc use fewer than all the cores? My laptop is coming to a crawl, and I think that might be why.
16:29:06 <geekosaur> that's not why; they're using memory not cpu, you're likely swapping. and 90% chance it's the linker although a memory blowup in the typechecker was recently discovered (too late to fix for 8.2)
16:29:49 <tac-tics> could be
16:30:54 <geekosaur> neither stack nor ghc does much with threads by default; stack wouldn't benefit and ghc would at minimum need to be redesigned from scratch (and even that might not help because it needs to track and update data dependencies)
16:41:06 <jle`> @tell steven_is_false the binomial theorem can be directly applied to type polynomials in a straightofrward way
16:41:06 <lambdabot> Consider it noted.
16:48:31 <slack1256> should I know how gobject is structured on C before using gtk-gi?
16:48:53 <slack1256> seems a 1:1 translation of the api. So the "intended" tutorial must be the C tutorial, right?
18:09:03 <ReinH> join #ruby-lang
18:09:06 <ReinH> Woops.
18:09:14 <ReinH> I wanted to see how the other half lives.
18:12:19 <geekosaur> "Thank you sir, may I have another"
18:20:54 <zwild> Woops
18:21:35 <zwild> Other half lives are in #java.
18:23:30 <EvanR> wouldve though other half of #ruby-lang was in #ruby
18:27:05 <arctictern> is there a function to test whether a number is between a range?
18:27:42 <MarcelineVQ> Data.Ix has in inRange I think
18:27:47 <EvanR> :t inRange
18:27:49 <lambdabot> Ix a => (a, a) -> a -> Bool
18:28:02 <arctictern> ah thank you 
18:28:22 <arctictern> should've hoogled both possible type orders
18:28:32 <erisco> y `elem` [x..z]    ... don't actually do that
18:29:12 <EvanR> at least its lazy!
18:30:17 <arctictern> i'll use (not . null . filter (==y)) [x..z] instead
18:31:20 <c_wraith> That seems like a bad choice if x and z are more than about 3 apart
18:32:12 <jle`> arctictern: i think that's the same thing as y `elem`
18:32:54 <arctictern> oh i was kidding haha. sorry for the confusion
18:33:15 <jle`> > 5 `S.member` S.f
18:33:17 <lambdabot>  error:
18:33:17 <lambdabot>      Not in scope: ‘S.f’
18:33:17 <lambdabot>      No module named ‘S’ is imported.
18:33:36 <jle`> > 5 `S.member` S.fromList [1..10]
18:33:38 <lambdabot>  True
18:33:44 <jle`> > 5 `S.member` S.fromList [1..4]
18:33:46 <lambdabot>  False
18:34:07 <jle`> it...doesn't work for Double/Float
18:34:11 <jle`> heh
18:34:37 <jle`> well, you'll get some false negatives
18:34:44 <jle`> ...and some false positives too
18:34:47 <erisco> just need more memory
18:35:13 <jle`> yup, start with a Set of all representable doubles
18:35:21 <jle`> then filter it for items in between the range
18:35:29 <jle`> and then use S.member
18:35:45 <erisco> the mathematician's day is done
18:36:12 <jle`> actually Set's representation is optimized for filtering for things between a range
18:36:14 <Axman6> > between (I# l) (I# h) (I# n) = isTrue# (l <=# n `andI#` l <=# h) -- #performance matters, always use hashes
18:36:15 <lambdabot>  <hint>:1:30: error:
18:36:15 <lambdabot>      parse error on input ‘=’
18:36:16 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:36:20 <jle`> so this is definitely an awesome idea
18:38:10 <jle`> how big is Double? two words?
18:38:26 <erisco> 64 bits I hope
18:38:29 <EvanR> 80!
18:38:35 <EvanR> just in case
18:38:40 <Rotaerk> "double" is just one word !
18:38:49 <jle`> :p
18:38:52 <NextHendrix> lol u guys
18:39:02 <Axman6> > length . words $ "double" -- confirmed
18:39:04 <lambdabot>  1
18:39:08 <slack1256> It is machine specific
18:39:17 <Axman6> double is one big
18:39:24 <EvanR> 16 bits = word. 8 bits = byte. 12 bits = syllable
18:39:46 <Axman6> I was pretty sure Double was defined to be an IEEE-754 double precision floating point number
18:40:21 <c_wraith> yes, but words are machine specific
18:40:37 <c_wraith> On some systems, Double is two words, on some systems it's one word
18:40:47 <Axman6> right, this is true
18:40:57 <c_wraith> You can probably find other cases, too
18:41:14 <jle`> @let allDoubles = S.fromList (unsafeCoerce <$> [minBound .. (maxBound :: Word64)])
18:41:14 <erisco> it should not be platform dependent... Haskell Language Report 2010 "... Double should cover IEEE double-precision."
18:41:15 <lambdabot>  Defined.
18:41:38 <erisco> and that is a 64 bit standard
18:41:46 <EvanR> should cover
18:41:49 <EvanR> as in , open cover?
18:43:21 <schmidt73> Do any of you guys know the best way to write the type: data ParserT s m a = ParserT { runParserT :: s -> Either ParseError m (a, s) }
18:43:47 <erisco> looks like a good way to write it to me
18:43:50 <schmidt73> Right Now I'm trying to represent error with Either and monadic action with m, but it isn't work
18:44:08 <schmidt73>  • Expecting one fewer argument to ‘Either ParseError m’
18:44:08 <schmidt73>       Expected kind ‘* -> *’, but ‘Either ParseError m’ has kind ‘*’
18:44:09 <jle`> @let inRangeDouble l h x = S.member x . snd . S.split l . fst . S.split h $ allDoubles
18:44:11 <lambdabot>  Defined.
18:44:14 <jle`> there
18:44:14 <erisco> oh, that's too many args to Either
18:44:25 <schmidt73> But m (s, a) is one type
18:44:36 <c_wraith> schmidt73: you need some parens
18:44:39 <erisco> Either ParseError m (a, s)  that's three args to Either
18:44:42 <jle`> finding if a Double is in a range, by generating a Set of all possible Doubles, filtering the set for doubles within the range, and tehn checking of the item is in the number
18:44:44 <slack1256> then put parenthesis. But it will not do what you want (probably)
18:44:55 <schmidt73> I tried parens :/
18:44:59 <erisco> Either ParseError (m (a, s))   that's two args to Either
18:45:09 <erisco> m (Either ParseError (a, s))   so is that
18:45:11 <jle`> if you want ParserT to be a monad transformer
18:45:17 <jle`> you need to do m (Either ParseError (a, s))
18:45:19 <jle`> yes
18:45:28 <jle`> you can't write a MonadTrans for the m being on the inside
18:45:36 <schmidt73> Oh better idea
18:45:41 <schmidt73> Thanks!
18:45:44 <erisco> EitherT ParseError m (a, s)  seems more likely
18:45:50 <jle`> they are the same type
18:45:53 <schmidt73> Also is it cheating to write (<*>) = ap
18:45:54 <schmidt73> ?
18:45:58 <slack1256> nah
18:46:01 <jle`> schmidt73: nah, it's actually the only reason 'ap' exists
18:46:15 <jle`> well, you have to define >>= and return first of course
18:46:34 <schmidt73> I feel like I could do it with only applicative but I'm trouble
18:46:41 <schmidt73> I was gonna leave that to figure out later
18:46:43 <jle`> you need Monad
18:46:45 <jle`> on 'm'
18:46:57 <schmidt73> It's impossible without it?
18:47:03 <jle`> oh, yes, if you want to do (<*>) = ap, you need to write the Monad instance
18:47:03 <pacak> o/
18:47:03 <pacak> Suppose I have a function f :: a -> b -> c and I know that for any a I use b -> c will be the same. Are there any ways to make ghc to cache b -> c without resorting to unsafePerformIO or other stupid tricks?
18:47:18 <jle`> yes, you can't write an Applicative instance for your type with only an Applicative constraint on m'
18:47:28 <schmidt73> jle` I mean I think I can write the Applicative instane by hand
18:47:35 <jle`> ah yeah
18:47:35 <schmidt73> without Monad m constraint
18:47:48 <jle`> pacak: look at those memoizer libraries
18:47:56 <jle`> like data-memocombinators
18:48:10 <jle`> oh wait, for all 'a', b -> c will be the same?
18:48:16 <pacak> Right.
18:48:21 <pacak> And 'a's are different
18:48:22 <jle`> why does it even have a parameter then?
18:48:35 <jle`> schmidt73: if you want to write an Applicative instance for that type, 'm' needs a Monad constraint
18:48:40 <jle`> but
18:48:42 <jle`> don't take my word for it
18:48:46 <jle`> try it first :)
18:48:49 <jle`> it'll be a good learning experience
18:49:17 <pacak> amongst other things a contains database schema. b contains database record.
18:49:22 <pacak> c - stuff I want to extract.
18:49:44 <jle`> well if you don't ever inspect the value of 'a' you can just have f :: b -> c
18:50:02 <pacak> I need to inspect a at least once - to get schema
18:59:53 <schmidt73> jle` thanks for letting me know my efforts are fruitless, I tried for a few hours earlier today and couldn't figure it out
19:27:44 <torstein> io monad can shortcircuit an or statement, right? like if first part is true, io actions necessary to determine second part wont be executed, even if strict?
19:28:38 <glguy> You could write a such an action. That's not how the normal || works
19:29:09 <EvanR> hmmm. what about <|>
19:29:30 <glguy> orM mx my = do x <- mx; if x then return True else my
19:29:48 <EvanR> oh <|> doesnt react to Bools
19:33:56 <ReinH> torstein: liftM2 (||) will not short-circuit, if that's what you're asking.
19:34:16 <monochrom> Nonstrictness does not manifest in IO.
19:34:31 <monochrom> Actually even my sentence is oversimplification.
19:35:37 <monochrom> In Haskell you will have to seperate evaluation from execution, unlike most languages. And then it will clear up.
19:37:00 <monochrom> Meaning, the question "when is x+y evaluated?" and the question "when does getLine stop and wait for your input" become unrelated.
19:37:42 <monochrom> Unlike other languages where "parseInt(getLine()) + parseInt(getLine())" is a mess.
19:38:21 <monochrom> and therefore also "simpler" for a perverse sense of "simpler".
19:39:22 <monochrom> In fact, so "simple" that it is not equal to (\x -> x + x) (parseInt(getLine()). Very simple, eh?
19:39:23 <c_wraith> I wanted to write a recursive-descent parser in C once.  Lots of cases were just "call this function with the results of these two functions as arguments".  I couldn't write that as one-liners, because C doesn't define what order the two functions get called in in that case, but it *really* matters for a recursive descent parser.
19:39:52 <monochrom> Oh yeah that too.
19:41:17 <monochrom> But most people sideline that by nailing one compiler version and possibly also finding an incantation of optimization flags that end in the order they want.
19:41:34 <monochrom> Then they go on to praise "C is so powerful!"
19:42:35 <monochrom> And congratulate themselves for achievement unlocked and license to look down upon other programmers do stay sane.
19:42:53 <monochrom> s/ do / who /
19:43:44 <torstein> this should work though, since readFile is lazy?: http://lpaste.net/356994
19:43:45 <monochrom> A few years ago I also ran into a few people who didn't even know that this is implementation-dependent territory. Simply because they only know to test it on one compiler.
19:44:43 <c_wraith> torstein: "work" in some sense.  It potentially leaks file handles, depending on whether finalizers are run in a timely fashion.  Or at all.
19:45:01 <monochrom> That is evil. It is also a lot more convoluted then you think.
19:45:22 <c_wraith> Remember - never count on finalizers even being run.
19:45:23 <monochrom> Namely, if reading will happen, the reading will not happen at "return" time.
19:45:59 <monochrom> Namely, suppose my main goes: main = eqFiles >> putStrLn "bye"
19:46:06 <monochrom> Then no reading will happen.
19:46:31 <torstein> yeah, I understand the files won't be compared until the IO Bool is bound
19:46:44 <ReinH> Not bound.
19:46:44 <monochrom> Or suppose my main goes: main = eqFiles >>= \b -> putStrLn "hi" >> print b
19:47:15 <monochrom> Then (assuming f1_time == f2_time), reading will happen at "print b" time.
19:47:20 <ReinH> Scrutinized.
19:47:34 <ReinH> Well, the reading.
19:47:39 <monochrom> "bound" is wrong, is what I'm saying.
19:47:45 <ReinH> Yes.
19:47:56 <ReinH> I am agreeing, is what I'm saying.
19:48:15 <monochrom> Yeah I'm responding to torstein's "until ... is bound"
19:48:28 <EvanR> "when" is an interesting location in haskell
19:48:57 <monochrom> "bound" time is the "\b" in my code. Reading does not happen at that point.
19:49:11 <torstein> i see
19:49:20 <ReinH> It helps to reason about causality.
19:49:30 <monochrom> Please simply give up readFile. (OK, unless your program logic is trivial.)
19:50:00 <ReinH> From which you can recover timing.
19:50:08 <torstein> cause of lazyness or String?
19:50:21 <monochrom> (I mean, I use it too. But it's simply "decodeJSON <$> readFile xxx". No or, no but.)
19:50:23 <EvanR> bring in alternative relativities makes it seem like you have to do this on a regular basis in haskell, rather than it being an idiosyncracy of readFile
19:50:31 <ReinH> unsafeInterleaveIO makes this a bit harder than usual.
19:50:47 <monochrom> No? Because of all the unpredictability I have been saying all along?
19:50:58 <monochrom> Because you predicted the wrong reading time?
19:51:11 <monochrom> And it is not just you, it's 90% of Haskell programmers?
19:51:52 <ReinH> monochrom: are you asking?
19:52:03 <monochrom> Rhetorical questions.
19:52:26 <monochrom> I was responding to "cause of lazyness or String?"
19:55:17 <monochrom> To some extent you can say "it doesn't hurt me. it's read-only! who cares when the reading happens."
19:55:58 <monochrom> But one day you will want to read then delete. In that very specific order.
19:56:48 <monochrom> Or you want the program to finish reading, then you manually unplug the USB flash stick.
19:57:44 <monochrom> which is what I did today at the photocopier to print quizzes for my TAs.
19:58:07 <EvanR> or you have a hack to launch missiles whenever something reads the file
19:58:15 <EvanR> bwahahaa
19:59:22 <monochrom> A rare occasion to celebrate "thank God the photocopier software is not written in Haskell [by a beginner who likes readFile]", eh?
20:00:03 <EvanR> the name of that action... man
20:00:26 <EvanR> i wish they invented "readFile" and "slickCleverReadFile" the second one is what we have
20:01:04 <EvanR> the longer name punishes you for being slick and clever
20:01:09 <monochrom> Well this shows that even the Haskell Committee thought it was a good idea.
20:02:11 <monochrom> I made up the 90% figure. But I'm sure some intermediate value theorem assures us that it was the right number at some point of time in the past.
20:02:51 <monochrom> Behold the power of fictional statistics combined with real analysis.
20:05:10 <erisco> monochrom, only holds for continuous functions, sorry
20:05:24 <monochrom> Ah.
20:05:45 <monochrom> Busted. :)
20:22:05 <ReinH> I think you mean imaginary statistics.
20:25:49 <ReinH> monochrom: perhaps the percentage is at most 90% and keeps increasing.
20:32:22 <c_wraith> 90% and rising
20:34:01 <ReinH> I was trying to invoke the monotone convergence theorem.
21:27:36 <jaseemabid> I wanna tell you about a story in which laziness completely screwed up my parsec parser, but you all probably know it anyway.  
21:48:50 <jle`> @tell schmidt73 no problem, telling people that their efforts are fruitless is why i'm here :)
21:48:50 <lambdabot> Consider it noted.
21:59:16 <minn> Is it possible to match EOF explicitly in an Alex rule?
21:59:42 <minn> (Or do you need to examine the Alex result?)
22:04:19 <EvanR> EOF from a lexer?
22:04:40 <EvanR> cant you just literally put an EOF token at the end if you wanted :)
22:04:50 <EvanR> thats the only place it could be
22:05:31 <slack1256> reading some okasaki. Amortized analysis is concerned with running time of sequence of operation. This sequence is of the same operation a bunch of time or is a randon permutation of operations?
22:06:28 <c_wraith> slack1256: in the case of persistent data structures, it's about *any* sequence of operations
22:08:06 <c_wraith> slack1256: the queue example he starts with is a good one.
22:08:21 <minn> EvanR: Unfortunately, I need to release state on EOF. I can do this in the lexing loop (matching on AlexEOF), but it would be nicer to encode in in the lexer rules.
22:08:37 <slack1256> I guess it all depends of how good the invariant you choose is
22:08:40 <c_wraith> slack1256: the traditional functional double-list queue has bad performance if used in a persistent setting in just the wrong way
22:09:19 <c_wraith> slack1256: he approaches how to fix that issue by improving performance for any sequence of operations
22:09:33 <c_wraith> well.  improving worst cases
22:09:48 <c_wraith> the double-list queue is faster when it's used non-persistently
23:27:18 <Lokathor> http://lpaste.net/356996 gosh willikers is the demand for lenses high in this situation
23:30:05 <jared-w> Lokathor: ahh... that sticky in-between where you're dealing with code complex to really benefit from lenses, but can't guarantee the people following your tuorial would be able to grok lenses as anything other than magic ascii vomit which fixes the problem in a tenth of the code? :p
23:30:46 <Lokathor> oh i've already fed them the magic vomit several times already
23:31:36 <Lokathor> "this is a fold situation, read the wiki page if you want to know how folds are different, or just trust that we're doing a foldl' and it's the correct style for this situation"
23:37:17 <jared-w> lol I getcha. Perhaps a note about how folds are just a way to abstract out a common recursion pattern? That's easy enough to grasp. But yeah... lenses... Even saying "they're like functional getters and setters" really doesn't prepare people for the ascii vomit lenses are capable of :p
23:37:25 <jared-w> (gotta go to bed, I'll talk later)
23:39:55 <cocreature> you could still make a function updatePos :: (Int, Int) -> (Int, Int) and then use "createLocation = updatePos (creatLocation oldPlayer)" to make the data flow a bit clearer without introducing lenses
23:41:00 <cocreature> or even a toplevel Direction -> (Int, Int) -> (Int, Int) to make it clear that it doesn’t depend on anything but the direction
23:41:12 <zipper> Is map reduce not just folding?
23:41:34 <Lokathor> cocreature, introducing lensese _is the point_ though :3
23:42:12 <Lokathor> not every guide should be a 101 guide. Some guides should show you a kick flip even if you're not entirely ready to do a kickflip yourself
23:42:45 <cocreature> Lokathor: ah ok. it might still be a good idea to first get the code in that shape and then show how lenses allow you to use "over" to simplify this
23:43:31 <Lokathor> hmmmmmmm
23:43:33 <cocreature> zipper: it’s a combination of map, fold and groupBy
23:43:44 <Lokathor> i'm not sure how the function you suggest would work honestly
23:44:00 <Lokathor> https://github.com/Lokathor/roguelike-tutorial-hs/blob/master/app/Main.hs you can view the full context if you like
23:44:37 <cocreature> updatePos (x, y) = case dir of East -> (x + 1, y); West -> (x - 1, y); North -> (x, y + 1); South -> (x, y - 1)
23:45:03 <Lokathor> i kinda have that tho
23:45:03 <Lokathor> ?
23:45:31 <cocreature> no you don’t have that function. you have a bunch of let statements
23:46:08 <Lokathor> so you're saying updatePos would be a function defined within bumpPlayer?
23:46:25 <EvanR> that function looks pretty useful on its own
23:46:43 <cocreature> yeah I would probably make it a toplevel function
23:46:52 <Lokathor> yeah I should make Location its own type with a shifting function to shift in the directions
23:47:05 <Lokathor> cocreature, but then it can't be (Int,Int) -> (Int,Int), at least
23:47:18 <cocreature> 084039       cocreature │ or even a toplevel Direction -> (Int, Int) -> (Int, Int) to make it clear that it doesn’t depend on anything but the direction
23:47:27 <EvanR> if Location is isomorphic to (Int,Int), then it doesnt matter
23:47:39 <EvanR> theres Isos
23:47:58 <Lokathor> EvanR, yeah it'd be iso
23:48:05 <cocreature> my point is that you should first transform your code to use that function and then show how lenses can be used to further simplify it
23:48:13 <Lokathor> but then we can call it x and y not 1 and 2
23:48:15 <cocreature> the step from a bunch of let statements to lenses is too big
23:48:35 <Lokathor> ah, well, yes
23:48:51 <EvanR> also V2 Int
23:48:57 <Lokathor> i was just going to use a lens to update the player's position
23:49:07 <Lokathor> leave all that calculation and adjustment the same
23:49:42 <Lokathor> EvanR, I was thinking data Location = Location !Int !Int and then letting GHC unpack 'em
23:49:43 <cocreature> but if you are going to use "over creatLocation", you are going to need that separate function instead of a bunch of let statements
23:49:52 <Lokathor> sure
23:50:06 <EvanR> you achieved true enlightenment when your code has become nothing but top level functions all 1 line long (and less than 80 wide). or perhaps just when your code has become nothing
23:50:31 <cocreature> when your code has become nothing you have become a manager and other people write the code for you :)
23:50:40 <EvanR> rest my case
23:50:56 <Lokathor> does this code have the budda-nature?
23:50:58 <Lokathor> no, it does not
23:51:23 <EvanR> https://www.willamette.edu/~fruehr/haskell/evolution.html
23:51:29 <Lokathor> yes
23:52:50 <EvanR> combinatory haskell programmer
23:52:55 <Lokathor> see also: typing the technical interview
23:55:05 <EvanR> oh god... ive fallen too far down this list
23:55:44 <EvanR> ok good i dont understand hylomorphisms
23:55:46 <cocreature> I think I’m back on the way up on that list
23:56:20 <MarcelineVQ> Me too, about at "Another junior Haskell programmer"
23:56:43 <MarcelineVQ> witha  dash of Beginning graduate Haskell programmer
23:57:12 <jle`> hi
23:57:13 <Lokathor> i think to think i'm Senior
23:57:17 <cocreature> I’m unreasonably annoyed by the missing bang pattern in "Accumulating Haskell programmer"
23:57:30 <Athas> Accumulating all those thunks!
23:57:32 <jle`> what's a nice way to check if a haskell program is running in an interactive shell or not
23:57:48 <cocreature> MarcelineVQ: foldr? that should be foldl'!
23:58:00 <MarcelineVQ> cocreature: ohmy
23:58:16 <jle`> should i check if PS1 is defined as an environment variable
23:58:21 <jle`> that doesn't sound very portable
