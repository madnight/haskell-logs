00:00:25 <colonelj> Axman6 or hanna maybe, anyway it doesn't matter
00:00:25 <EvanR> what i was saying was really... man this is worse than ruby :)
00:00:45 <colonelj> but yeah you literally have to put HasCallStack everywhere if you want full call stacks
00:00:59 <EvanR> its pretty intrusive
00:01:12 <EvanR> but im amazed we even have this, considering theres no such thing as a call stack in haskell
00:02:26 <EvanR> so im a little concerned by the confusion this feature may cause when future people try to use it
00:02:38 <johnw> jchia: indeed, if you want updates as you've suggested, making the indirection explicit will be necessary
00:02:55 <hanna> jchia: if you need to represent a graph, especially mutable, then you need to use explicit handles, yes
00:03:04 <hanna> if you just need to represent a tree, you could get away with Job1
00:03:15 <colonelj> there isn't any way I can write the Haskell code to be an AST expression or something I can print is there???
00:03:28 <colonelj> it'd be really nice if I could actually show what the assertion is
00:04:05 <colonelj> I guess it wouldn't work because you need a closure from the calling function :S
00:04:38 <colonelj> not saying there isn't magic for that too
00:04:48 <colonelj> this isn't python though I suppose
00:05:05 <halogenandtoast> Can anyone explain to me what is happening here in ghci? https://gist.github.com/halogenandtoast/ba855af0bf0856bed8f50d5585cc0503
00:05:24 <hanna> colonelj: I mean you could try using TH
00:05:56 <kadoban> halogenandtoast: What's :t f ?
00:06:16 <EvanR> yeah there is some TH floating around to dump as much info as the context allows at the point of an error
00:06:20 <colonelj> hanna: it'd be worth it I think
00:06:55 <EvanR> which would behoove you to do
00:06:57 <colonelj> don't suppose anyone knows how to do TH
00:07:32 <EvanR> a future you!
00:07:41 <EvanR> crystal ball says
00:08:08 <halogenandtoast> kadoban: f :: (Monad m, Num a) => m a
00:08:27 <colonelj> yeah probably
00:09:43 <colonelj> some help would be good
00:09:49 <EvanR> the possibility of your program crashing despite your proof-on-paper that it cant.... and requiring all this second guessing... is part of the intoxication of fancier type systems to prevent it!
00:10:56 <kadoban> halogenandtoast: Hm, right. Interesting. I wouldn't think that'd actually work.
00:11:07 <halogenandtoast> kadoban: me either... it's black magic
00:11:10 <kadoban> Is that defaulting at work I guess? I wonder what Monad instances those even are.
00:11:47 <halogenandtoast> kadoban: for just f, my guess is IO
00:12:02 <kadoban> Maybe ((->) r) and IO ?
00:12:06 <jchia> johnw, hanna: Thanks
00:13:50 <EvanR> colonelj: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell
00:14:01 <colonelj> "Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module." that's a weird restriction
00:14:18 <mivael> > let showF = ($ "") . showFFloat (Just 2) in showF 34.5
00:14:20 <lambdabot>  "34.50"
00:14:36 <mivael> Is it a common way of formatting floats in haskell?
00:15:14 <c_wraith> colonelj: it's the quickest/simplest hack to prevent circular dependencies between a splice and the value it produces
00:15:31 <c_wraith> colonelj: hardly elegant, but very easy to understand
00:15:46 <halogenandtoast> kadoban: yeah that's my guess for f 4
00:15:51 <halogenandtoast> just pure weirdness though
00:16:01 <kadoban> I really couldn't have guessed that output of ghci ...
00:16:11 <kadoban> I guess it sorta makes sense, almost? (not really)
00:16:44 <c_wraith> halogenandtoast: that's just standard ghci defaulting.
00:17:31 <EvanR> colonelj: ime you can get by fine by putting needed functions in another module
00:17:55 <c_wraith> halogenandtoast: if an expression produces a polymorphic value that can unify with Show a => IO a, it will perform that unification, execute the action, and show the resulting a value
00:17:59 <EvanR> you could imagine the insanity of using functions in "this module" that you are currently manipulating
00:18:16 <EvanR> this module is false
00:18:28 <c_wraith> halogenandtoast: so when you use it as just f, it monomorphizes to IO Integer
00:18:57 <colonelj> I think I should commit before trying converting all my ensures to Template Haskell :D
00:19:39 <signalsea> in a paper by ralph hinze he writes "fold( - ) is natural in (B,b), that is, as an arrow in Alg(F)" I'm confused by this. what are the two functors being mediated by fold( - ) as a natural transformation here?
00:20:28 <hanna> colonelj: here's a proof of concept
00:20:33 <hanna> https://0x0.st/0xU.txt
00:20:35 <c_wraith> halogenandtoast: In the other case, you're using f as a function.  So it monomorphizes m to ((->) Integer), resulting in f having the type Integer -> Integer
00:20:45 <hanna> you can use it like $(assert [| condition goes here |])
00:20:55 <hanna> can't figure out a way to get rid of the $() so I guess you'll have to live with that
00:21:09 <c_wraith> halogenandtoast: in the ((->) a) Monad instance, return = const
00:21:10 <hanna> and of course, you can also use a better pretty-printer, and ideally also throw some HasCallstack in there
00:21:14 <hanna> but that's left as an exercise to the reader
00:21:58 <halogenandtoast> thanks c_wraith  and kadoban 
00:23:35 <colonelj> hanna: I don't quite understand it... why do you need to 'fmap show' and why is there a quote around the case of?
00:23:55 <hanna> colonelj: [| source code |] generates an ADT of the contents
00:24:05 <hanna> inside the Q monad
00:24:26 <hanna> assert :: Q Exp -> Q Exp, it takes an expression and modifies it
00:24:42 <hanna> $(something :: Q Exp) takes an expression and splices it into that place in the code
00:24:54 <colonelj> I know that part
00:24:54 <hanna> so writing $([| haskell source code |]) is a no-op
00:25:08 <colonelj> yeah I think you didn't write it the way I expected
00:25:18 <hanna> yeah who knows, my TH is very rusty
00:25:35 <hanna> there are probably better ways to write this
00:25:35 <colonelj> I want to actually execute the code inside the assert
00:25:37 <EvanR> im thinking Q Exp is "quoted expression"
00:25:46 <colonelj> yeah
00:25:53 <colonelj> :t assert
00:25:54 <lambdabot> Bool -> a -> a
00:26:16 <colonelj> umm so how come the Exp doesn't express its type...
00:26:17 <hanna> colonelj: well what this TH does is basically transform `condition` into `(case condition of True -> error "condition"; _ -> id)`
00:26:21 <hanna> which is basically what you want, no?
00:26:30 <EvanR> but... Q is really a monad that lets you do cool stuff to produce expressions
00:26:44 <EvanR> and types, and other stuff
00:26:52 <hanna> the function I wanted to write was assert :: Q Exp -> a -> a
00:26:55 <hanna> but this can't be done, I think :(
00:27:16 <colonelj> why not?
00:27:24 <hanna> can't escape out of Q
00:27:34 <colonelj> isn't that what $ does?
00:27:43 <hanna> I mean yes, but
00:27:58 <EvanR> in the $( ) you have to put a Q Exp
00:28:06 <colonelj> yeah that's the input
00:28:35 <EvanR> its a program to run, generate an Exp, which is sliced in at the spot
00:28:45 <colonelj> yes
00:29:04 <hanna> you can't reference the runtime parameter `qexp` inside a splice
00:29:05 <EvanR> so thats why Q Exp -> a -> a wont work, wrong type
00:29:21 <hanna> assert qexp = $([| case $qexp of False -> undefined; _ -> id |])
00:29:28 <hanna> this runs foul of the GHC stage restriction
00:29:48 <colonelj> why are you quoting the case statement
00:30:27 <hanna> well same deal
00:30:30 <hanna> assert qexp = case $qexp of False -> undefined; _ -> id
00:30:32 <hanna> same restriction
00:30:56 <EvanR> its illogical :)
00:31:02 <hanna> it's not illogical
00:31:07 <hanna> the haskell compiler does not run at runtime :)
00:31:10 <colonelj> :t (\qexp v -> case $qexp of False -> undefined; _ -> v)
00:31:11 <lambdabot> error:
00:31:11 <lambdabot>     parse error on input ‘$’
00:31:11 <lambdabot>     Perhaps you intended to use TemplateHaskell
00:31:22 <hanna> well to be fair what you could do is require this function to be inlined
00:31:28 <hanna> and then do the resolution locally
00:31:34 <colonelj> that sounds good
00:31:38 <hanna> but GHC doesn't do that because effort
00:32:16 <colonelj> EvanR: what's illogical about what I'm trying to do?
00:32:19 <tdammers> GHC doesn't do that because inlining isn't always beneficial; it's a tradeoff, and using a heuristic for deciding which way to trade is tricky
00:32:35 <EvanR> hanna: yes what would happen at runtime when the input Q doesnt produce a Bool
00:32:53 <hanna> exactly
00:33:01 <colonelj> is there any way to make sure it produces a Bool?
00:33:21 <EvanR> have more expressive types on the form of haskell syntax
00:33:29 <hanna> EvanR: I wonder: what would _actually_ happen if you unsafePerformIO . runQ?
00:33:29 <tdammers> colonelj: yes, the compiler already does that for you - if you use it on a qexpr that isn't of type Bool, it won't compile
00:33:44 <mivael> Is Numeric.showFFloat (and alike) is a function people generally use in Haskell for floating point number formatting?
00:34:01 <hanna> it's more complicated than that, the generated code can depend on locally scoped variables - this environment is carried inside the Q monad
00:34:12 <hanna> but you need to splice it in the local location in order for the Q monad to see the locally scoped variables
00:34:24 <colonelj> A typed expression splice can occur in place of an expression; the spliced expression must have type Q (TExp a)
00:34:28 <hanna> wait so what would _actually_ happen if you unsafePerformIO . runQ? :p
00:34:31 <colonelj> so I want a Q (TExp Bool)??
00:34:39 <mivael> s/is a function/a function/
00:34:48 <EvanR> colonelj: there you go... i thought something like existed :)
00:35:14 <EvanR> regular Exp would work though, since youre compiling the result of the TH before running it anyway
00:35:24 <EvanR> itll detect a bad program
00:35:58 <colonelj> you were just saying it wouldn't work..
00:36:02 <tdammers> mivael: I haven't seen it used in the wild much; AFAIK, printf is the go-to function for this kind of stuff
00:36:16 <EvanR> colonelj: we were talking hypothetically about violating stage restrictions
00:36:26 <colonelj> I don't know what those are :)
00:36:48 <hanna> hmm even if you unsafePerformIO, all you could do is get the String description the expression
00:36:54 <hanna> which wouldn't help you actually generate code that references this bool
00:36:57 <hanna> oh well
00:37:22 <colonelj> nope I don't understand the problem here
00:37:34 <colonelj> A typed expression splice is written $$x
00:37:41 <tdammers> stage restrictions are restrictions in GHC that limit what you can do in what stage of compilation
00:37:50 <EvanR> thats not going to help you generate new code at runtime
00:38:12 <mivael> tdammers, thank you.
00:38:50 <tdammers> for example, a function you call in a TH splice cannot be defined locally, because that would require compiling the module in which it is defined, which requires running the TH in it, which requires the module to already be compiled
00:39:31 <EvanR> or to exist, so you can interpret it. the issue is it may not exist yet
00:39:42 <EvanR> since you didnt look at the rest of the TH
00:39:53 <tdammers> or that, yes
00:39:54 <hanna> in this case, assert :: Q Exp -> a -> a would require the compiled version of `assert` to reference source code that it receives after it's compiled
00:40:06 <hanna> which is clearly bizarre
00:40:48 <tdammers> I have a hunch that it would be possible in theory to solve this by splitting modules up for compilation, applying the staging restrictions per top-level definition instead of per-module, but that would get messy real fast
00:41:13 <colonelj> hanna: how is it different from passing in a function?
00:41:23 <EvanR> a future version of GHC may be able to time travel and get access to future code generated at runtime, so it can fulfill its own prophesy
00:42:23 * hackagebot miso 0.1.2.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
00:42:28 <colonelj> so is there not something in template haskell that could treat this like a macro and basically force inline it so it can compile?
00:42:29 <hanna> colonelj: you're passing literal haskell source code - where does this source code end up in the generated code?
00:42:30 <EvanR> 8.6 maybe
00:42:56 <hanna> colonelj: the proper way to do this with TH would be $(assert [| condition |])
00:42:58 <colonelj> hanna: where do lambdas end up?
00:43:01 <hanna> I was just thinking about ways to possibly avoid the $()
00:43:08 <colonelj> hanna: ok
00:43:20 <EvanR> lambdas end up nowhere
00:43:28 <colonelj> they get compiled
00:43:36 <EvanR> GHC heavily mangles your code
00:43:54 <hanna> more directly, lambdas end up in the place they're written - just like normal haskell source code
00:45:40 <EvanR> i didnt really get LISP macros until i did TH, because its fairly easy to identify what syntax is and what isnt
00:45:55 <colonelj> do I want ensure :: Q (TExpr Bool) -> Q (TExpr (t -> t))
00:46:00 <EvanR> where as LISP explanations tend to pretend everything is anything
00:46:28 <colonelj> I'd like things to be typed for reasons of sanity
00:46:43 <hanna> TH exprs are type checked when they're spliced
00:46:52 <tdammers> EvanR: that's funny - I didn't really get TH until I started using lisp macros :D
00:47:01 <EvanR> o_O
00:47:24 <colonelj> hehe
00:47:25 <hanna> but I assume you can also do that, yes
00:47:29 <tdammers> anyway, you don't need to time travel to make the staging restriction more gentle
00:47:55 <EvanR> seems like you could easily get into a dependency loop
00:48:11 <tdammers> yes, but the required limitation to avoid that can be smaller
00:48:11 <hanna> hmm no actually you can't use TExp with TH natively
00:48:48 <hanna> I have no idea where TExps even come from
00:48:53 <tdammers> you could do something like split at every top-level splice, and process the chunks sequentially
00:49:16 <tdammers> then the only restriction you need is that things cannot depend on stuff defined in chunks further down the file
00:49:49 <EvanR> defined by, or using TH further down
00:49:55 <colonelj> A typed expression quotation is written as [|| ... ||]
00:49:57 <EvanR> or further up
00:50:07 <tdammers> no, further up would be fine
00:50:20 <hanna> ah
00:50:25 <tdammers> further up is already compiled by the time you hit the splice
00:50:31 <hanna> so you'd need to write $$(assert [|| condition ||]) for no benefit? :D
00:50:36 <EvanR> if f is defined normally, but uses TH that references g, and g is defined normally, but uses TH that references f
00:50:49 <tdammers> I don't know enough about GHC internals to judge whether this would be feasible though
00:51:01 <EvanR> neither could complete
00:51:09 <hanna> GHC already does some further-down stuff; you can reference a function that was generated in a TH splice only below that point iirc
00:51:13 <colonelj> hanna: are you sure there's no benefit?
00:51:15 <hanna> actually that may be relaxed these days
00:51:17 <tdammers> correct; but either f is defined before being used in TH, or g is
00:51:23 <tdammers> so one of them would trivially fail
00:51:24 <hanna> colonelj: What do you hope to gain from type checking this trivial function?
00:51:53 <colonelj> I guess I should just treat it like a macro and not care about types
00:52:02 <EvanR> so it fails in a different way
00:52:06 <tdammers> yes
00:52:22 <tdammers> but defining f normally, and then using it in TH further down in the same module, *would* work
00:52:43 <tdammers> right now, it doesn't, because functions used in TH must be imported, not defined locally
01:03:57 <asdaljlsd> ?
01:04:16 <asdaljlsd> do tell python to stay the fuck off my computer befores we kills more of you?
01:04:22 <asdaljlsd> gg
01:05:33 <colonelj> LSD is a wonderful drug
01:06:03 <EvanR> stuff like that puts the channel in a supercritical state, anyone who says anything begins the boiling process!
01:06:35 <colonelj> boil and bubble, toil and trouble
01:18:22 * hackagebot FontyFruity 0.5.3.3 – A true type file format loader – https://hackage.haskell.org/package/FontyFruity
01:18:29 <tdammers> fun fact: the witches are the only characters in Macbeth to not speak in pentameter
01:18:57 <merijn> ok, so I have a (monadic) loop with some state and I want the state to persist over/through exceptions, what's the way to go?
01:19:53 <merijn> Just a naive recursion of "State -> m State" doesn't really work, since I'll lose my current state when an exception gets thrown
01:20:14 <EvanR> runState inside the loop!
01:20:34 <cocreature> write your state to an ioref
01:20:41 <merijn> EvanR: runState won't return a state if it gets killed midway through
01:20:52 <EvanR> you keep your current state
01:20:59 <merijn> EvanR: I don't want that
01:21:00 <EvanR> oh, async exceptions?
01:21:10 <merijn> EvanR: No, IO exceptions
01:21:21 <merijn> EvanR: I want the "last known state before the exception"
01:21:35 <EvanR> IO code, IO exceptions, ... IORefs
01:22:11 <merijn> cocreature: Actually, that's pretty obvious. In fact, the surrounding code already uses IORef (although currently it's not even using that, so I was planning to rip that out...)
01:23:26 <merijn> Incidentally, is there a MVar variant that has "force overwrite" function?
01:23:53 <merijn> (Since my state is potentially non-existent maybe an MVar makes more sense than IORef)
01:24:11 <EvanR> something like swapMVar_ hehe
01:24:44 <merijn> I suppose I could use IORef with Maybe
01:25:47 <EvanR> if you need to detect the non existence yeah
01:26:01 <EvanR> otherwise IORef that initially holds an undefined
01:26:49 <ski> @hoogle SampleVar
01:26:49 <lambdabot> module Control.Concurrent.MSampleVar
01:26:49 <lambdabot> Control.Concurrent.MSampleVar data MSampleVar a
01:27:01 <merijn> This code is making me realise that unfortunately Haskell doesn't rule out spaghetti code...
01:27:20 <EvanR> maybe you need a dedicated spaghetti monad
01:28:13 <merijn> It's also making me realise that people who say "passing arguments explicitly is better than Reader!" are talking nonsense >.<
01:28:38 <dramforever> Whoa
01:28:40 <EvanR> can you split it up into a bunch of async threads
01:28:54 <merijn> EvanR: There is no multi-threading
01:29:05 <EvanR> for organizational purposes
01:29:23 <EvanR> and since youre worried about exceptions
01:30:00 <merijn> EvanR: It's just a single-threaded loop that (currently) is passing like 2-3 different functions into basically every other function to call potential error handling
01:30:29 <merijn> EvanR: I figure I can massively simplify things by just moving the error handling to a single exception handler and just having all the functions simply calling throwIO to abort
01:31:14 <merijn> dramforever: With reader I could adjust one type, and fix type errors. With explicit argument passing I'm having to do manual deadcode analysis to figure out which functions are actually using the stuff passed everywhere...
01:32:02 <EvanR> stuff is passed everywhere manually without being needed everywhre, does sound out of the ordinary
01:32:58 <merijn> EvanR: If you go through 5 functions and they all need to pass argument just because one of the possible control flows in one of the leaves needs it it makes everything a lot more complicated than just having ReaderT
01:33:20 <dramforever> Is that why OOP is so popular?
01:33:47 <EvanR> one interpretation of OOP is... global variables locally
01:34:14 <dramforever> Another is 'ReaderT X IO'
01:34:37 <merijn> dramforever: I don't see the issue with ReaderT X IO if X isn't mutable?
01:35:09 <EvanR> or X could be
01:35:09 <trigone> hi! i was observing that many types need one function to be a pseudo-constructor and build the type values with the right rules, usually for efficiency purposes. is there by any chance a typeclass for this kind of pseudoconstructor? mind you i'm not sure if here polymorphism would be useful ever, but the similarity made me wonder
01:35:13 <dramforever> Even if it's mutable, it doesn't sound too bad
01:35:16 <EvanR> could contain IORefs
01:35:39 <merijn> EvanR: Sure, but if you have a lot of ReaderT IORef then I start getting suspicious :)
01:35:47 <EvanR> you just need to set up a family of actions to read and write your "globals"
01:35:47 <dramforever> I mean, when I say OOP I don't mean 'that bastard paradigm'
01:36:08 <dramforever> So there isn't really an issu
01:36:11 <merijn> trigone: There's not really a way to generalise that, so I don't think a typeclass would be helpful
01:36:15 <colonelj> hanna: there's a pprint function in Template Haskell
01:36:25 <colonelj> gives much more readable output ;)
01:36:41 <colonelj> still a bit messy though because it gives fully qualified names for everything
01:37:30 <EvanR> merijn: me too
01:38:02 <cocreature> trigone: in general a typeclass for X is only useful if you can write code that knows nothing about the type except that it’s an instance of the class. I don’t see how you would write useful code knowing only that there is some kind of pseudo-constructor
01:38:22 <colonelj> oh noez HasCallStack is no longer working!
01:38:27 <trigone> cocreature: yeah that's why i said i was not sure it could ever be useful...
01:38:34 <EvanR> but its like... for a given situation where a body of code all looks like ReaderT X IO, it may take 6 months and a grant from the national science foundation to figure out a more appropriate language for the situation
01:39:46 <colonelj> I just realised, it doesn't need to, since it already is getting the callstack at the right place
01:39:54 <colonelj> like a macro
01:47:59 <colonelj> ensureQ :: ExpQ -> ExpQ
01:47:59 <colonelj> ensureQ cq = do
01:47:59 <colonelj>     msg <- (\expr -> "ensure (" ++ pprint expr ++ ") failed") <$> cq
01:48:00 <colonelj>     [| if $cq then id else error msg |]
01:48:17 <colonelj> works a charm
01:48:39 <EvanR> does it? if so, thats pretty cool
01:49:08 <colonelj> I'm still keeping the original 'ensure' that works like 'assert' since there's limitations on what stuff you can do within a quote
01:49:25 <colonelj> but I managed to convert all the assertions I had up to now
01:49:44 <EvanR> youre writing the failure checking code inside of a quotation?
01:50:29 <colonelj> you have to do $(ensureQ [|condition code goes here|])
01:50:45 <colonelj> so 7 extra characters compared to the basic ensure
01:50:57 <colonelj> no wait 5
01:52:41 <colonelj> it's not really any different to what hanna suggested originally
01:52:58 <colonelj> but the use of pprint is definitely better
01:53:31 <EvanR> is it worth all that
01:53:46 <EvanR> the line number isnt enough?
01:54:36 <colonelj> if you're giving the app to an end user without the source code then this is definitely preferrable
01:54:38 <EvanR> i guess if you deploy your program and then modify the code, it wont help
01:54:51 <colonelj> and that
01:55:46 <trigone> how can i use stack to make a library, as in, there's no executable to speak of?
01:55:57 <colonelj> sample output: AgentOptimization: ensure ((Data.Vector.Storable.head GHC.Base.$ Bits.unTimeSeries fcfs_1627591252) `Bits.approxEqual` calc_cf_1627591257) failed
01:56:35 <cocreature> trigone: use a library section instead of the executable section in your cabal file
01:57:05 <trigone> cocreature: there are both, must i erase the executable section?
01:57:11 <cocreature> trigone: yep
01:57:21 <trigone> kay thanks cocreature 
01:57:54 <trigone> actually, is there a way to comment in a cabal file, so i can revert if i want?
01:58:16 <EvanR> source version control?
01:58:44 <trigone> EvanR: you mean like git?
01:58:48 <EvanR> yeah
01:58:51 <cocreature> comments in cabal files follow the syntax of Haskell comments
01:59:02 <trigone> cocreature: k thanks.
01:59:15 <trigone> EvanR: well i started recently but i barely know much of it
01:59:21 <EvanR> short term, medium term, long term, much better than leaving everything commented out forever just in case
02:00:12 <trigone> EvanR: what do you mean short, medium, long term?
02:00:33 <EvanR> the time frames to get benefit out of version control
02:02:42 * hackagebot madlang 2.3.2.0 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
02:08:10 <trigone> EvanR: yeah, i just have to learn how to use git. anybody got an extensive-enough tutorial on how to use git, including synch with the online hub?
02:08:24 <merijn> The GHC package docs aren't on hackage?
02:10:39 <EvanR> trigone: the site github has a lot of docs on it, its very popular "online hub". though i learned by reading the various docs that come with git
02:10:57 <merijn> Honestly I would recommend Mercurial over Git any day if you're new to distributed version control
02:11:01 <merijn> Much easier to learn
02:11:16 <EvanR> "extensive-enough tutorial" = the actual docs and guides it comes with
02:11:39 <EvanR> eventually learning git will get you jobs :)
02:12:12 <merijn> EvanR: No it won't, you can just be like me and keep using Mercurial because it has bidirectional conversion for git anyway :p
02:12:29 <EvanR> thats hilarious
02:12:35 <merijn> EvanR: I've been collaborating with colleagues/companies using git and dumping stuff on github with mercurial for the past 7 years
02:12:47 <EvanR> reminds me of svn-bridge
02:13:10 <merijn> EvanR: The only issues I'm aware of are: roundtripping through git loses file move info, because git doesn't store those
02:13:23 <merijn> EvanR: And I'm unsure if/how it handles octomerges, because mercurial doesn't support those
02:13:31 <merijn> Then again, I've never seen in octo-merge in the wild
02:13:38 <EvanR> i have
02:13:56 <merijn> EvanR: Where? linux kernel?
02:13:57 <EvanR> i was a git nazi at some point
02:14:02 <EvanR> so i used octo merges
02:14:20 <merijn> tbh, I think lack of octo-merges is probably a good thing anyway, since they're insane
02:14:51 <EvanR> probably no one on that project that looks at the history (who does that anyway...) will know what that is
02:15:14 <EvanR> wait a minute why are we talking about *not darcs* ! :)
02:15:51 <merijn> EvanR: Because darcs doesn't interoperate with git :p
02:16:00 <EvanR> i rest my case
02:16:24 <merijn> EvanR: Network lock-in doesn't make it any less awful :)
02:16:37 <trigone> okay... as an external observer i remain relatively indecisive...
02:16:52 <EvanR> git rules the market roost right now
02:17:14 <EvanR> because linus torvals, the biggest nerd celeb, wrote it
02:18:09 <merijn> trigone: Git is the most popular, but is famous for it's obtuse and confusing command line interface and generally making you feel dumb. Mercurial is, in a technical sense, similar to git in many ways. But it has an easier to learn interface, better built-in help, etc.
02:18:24 <EvanR> it was a clone of mercurial, i think
02:18:33 <merijn> EvanR: No, but same inspiration
02:18:50 <merijn> EvanR: Both git and mercurial were implemented by linux kernel devs trying to replace linux' use of Perforce
02:19:02 <EvanR> what, the encyclopedic git man pages arent good enough for ya!
02:19:38 <merijn> trigone: So, I recommend mercurial to beginners because: 1) I'm selfish and increased adoption decreases my need to switch to git 2) it can interoperate with git, and 3) it's easier to learn
02:19:55 <merijn> trigone: Either one is better than nothing, though :)
02:20:02 <Myrl-saki> merijn: SVN.
02:20:07 <merijn> trigone: Here's a good Mercurial intro: http://hginit.com/
02:20:14 <merijn> Myrl-saki: Get out! >.<
02:21:49 <trigone> okay i think i'll try both a bit and see which fits my foot :)
02:21:53 <EvanR> i recall before git became god, bazaar-ng was the then-current hotness
02:22:12 <trigone> thanks at any rate. what's bazaar-ng?
02:22:26 <EvanR> yet another version control better than CVS
02:22:46 <Tuplanolla> Git is good as long as you don't try to understand it or look at its source code.
02:23:07 <trigone> Tuplanolla: well i did not intend on doing so. unless it's written in haskell :P
02:23:33 <merijn> Tuplanolla: Or try any workflow other than simple "push/pull/commit" :p
02:23:49 <EvanR> unless youre me
02:24:08 <Tuplanolla> Add merges across local branches to that and we're set, merijn.
02:24:10 <EvanR> but no one could ever understand what i did 
02:24:32 <merijn> trigone: Before git there was a whole mess of distributed version control systems, including bazaar
02:24:40 <merijn> trigone: There's also Fossil, these days
02:24:41 <EvanR> trigone: for haskelly version control... darcs!
02:24:51 <merijn> Oh, and darcs, yes
02:25:09 <trigone> yeah i heard of darcs but i also heard it was not really as ... powerful?
02:25:34 <merijn> Anyway, to repeat my earlier question, anyone know where I can find the haddocks for the GHC library?
02:25:39 <EvanR> more powerful, not as linus torvalds
02:26:03 <trigone> EvanR: well you lost me in metaphors
02:26:18 <EvanR> darcs is not as high performance, as i understand it
02:26:39 <EvanR> so might not work for a linux kernel 
02:27:21 <tabaqui> unix-2.7.2.1
02:27:25 <tabaqui> System.Posix.Process
02:27:34 <tabaqui> inconsistent behavior of getAnyProcessStatus
02:27:38 <Tuplanolla> They should come with GHC, merijn. They just go into another directory.
02:27:48 <ertes-w> trigone: if you're going to learn git i *strongly* recommend checking out "advanced" tutorials right away
02:28:07 <tabaqui> if there is not child processes, then exception is raised
02:28:11 <trigone> ertes-w: to avoid bad beginner tutorials?
02:28:21 <ertes-w> trigone: to remove the black box around git
02:28:31 <tabaqui> while on my linux system, it's not
02:28:37 <trigone> ertes-w: k
02:28:51 <trigone> EvanR: work for a linux kernel, you mean building one?
02:29:02 <EvanR> keeping the history
02:29:09 <merijn> Tuplanolla: Any clue where? I can't find them locally or online
02:29:29 <ertes-w> trigone: understanding how git works on lower levels is really helpful…  otherwise git is very confusing and will often exhibit counter-intuitive behaviour that you simply can't explain without those details
02:29:41 <Tuplanolla> Try `find "$HOME/.stack" -name CmmType.html`, merijn.
02:29:41 <btk> There is pretty cool book on git: https://git-scm.com/book/en/v2
02:29:53 <trigone> EvanR: yeah but i mean, you meant if i were to write a linux kernel, right?
02:30:06 <merijn> Tuplanolla: I don't use stack, so that seems unlikely to work :p
02:30:08 <Tuplanolla> Replace `.stack` with `.cabal` if you're into that, merijn.
02:30:13 <EvanR> if your project ended up being as complex and big as that
02:30:17 <merijn> Tuplanolla: But someone in #ghc linked me an online version
02:30:27 <EvanR> with 10000s of collaborators
02:30:43 <EvanR> i actually dont know if it would really matter to be honest
02:30:43 <trigone> ertes-w: k thanks for the tip :)
02:30:55 <merijn> Anyway, I would like to point out that the git discussion (by now) is probably off topic and and fodder for, well, -offtopic ;)
02:30:58 <Tuplanolla> Searching through the installation directory of GHC might also get you there, merijn.
02:31:01 <ertes-w> BTW, there is also pijul, which is basically darcs done right, but it's pretty much in its infancy right now
02:32:01 <ertes-w> i don't think it's really usable yet, unless you're comfortable doing all version control operations on the command line…  i'm not =)
02:32:18 <EvanR> theres another way? o_O
02:32:26 <merijn> ertes-w: How else do you do things? >.>
02:32:53 <ertes-w> EvanR, merijn: take a look at magit…  i mean…  don't read about it, but just watch a video
02:33:11 <merijn> ertes-w: Well, since I've avoid git, I think can skip that :p
02:33:14 <EvanR> does not compute
02:34:06 <ertes-w> merijn: darcsum is kinda similar to magit, but for darcs…  unfortunately it's *too* similar to magit in that sometimes it forgets that darcs is not git
02:35:45 <colonelj> trigone: I have a little mini description of Git I wrote if you're interested
02:35:50 <colonelj> it's mainly aimed at people who know SVN
02:37:10 <trigone> colonelj: well i know nothing of SVC or version control stuff in general... think i'll get it?
02:37:21 <trigone> if so sure i'm intereste
02:37:22 <trigone> d
02:37:31 <colonelj> I can't remember how accessible it is
02:38:20 <trigone> colonelj: well just give it away then and i'll try it and tell you :)
02:38:21 <colonelj> the workflow with GitHub or something though is basically the same as any other way of using it
02:40:12 <colonelj> do you know any paste site that guarantees word wrap because it's not wrapped :P
02:40:28 <colonelj> I made a Wiki markup version of this but I lost it :(
02:40:34 <colonelj> took a while to do
02:42:17 <ertes-w> colonelj: gist.github.com supports markdown
02:42:35 <ertes-w> just pick a file name ending with ".md"
02:43:21 <colonelj> I'm not rewriting this into Markdown though it would take too long
02:43:40 <colonelj> I'm also annoyed because I don't even have the latest edit I made of the text version
02:44:16 <hanna> did you check your git tutorial into git
02:44:43 <colonelj> nah lol
02:44:55 <colonelj> I wish I'd just put it on github or something
02:45:28 <colonelj> trigone: here's the unreadably un-wordwrapped version maybe you can copy it into a text editor
02:45:31 <colonelj> http://lpaste.net/1501723448051761152
02:46:03 <colonelj> actually maybe not being word wrapped isn't a bad thing since it makes it easier to see the list of commands
02:46:58 <colonelj> I left the haskell syntax highlighting on lol so it looks nice 'n' funky
02:47:06 <trigone> colonelj: sure, thanks! you know if you look at the raw version, it's automatically word-wrapped, at least in my browser
02:49:21 <colonelj> oh, true
02:49:34 <colonelj> that solves that problem then
02:50:06 <tabaqui> fine
02:50:07 <colonelj> it's a pain in the arse to markdown this stuff because I want to keep the commands copy and pasteable
02:50:10 <tabaqui> still unix-2.7
02:50:23 <tabaqui> signal handlers behavior different way
02:50:39 <tabaqui> I can Catch some signal, but cannot CatchInfo it
02:52:22 <trigone> colonelj: on first scanning i think i lack the most basic vocabulary (branches, etc) to be able to use it, but once i get a bit more knowledgeable in general in version control stuff, i'll read it again :)
02:53:09 <Myrl-saki> So...
02:53:55 <colonelj> trigone: branches are pretty fundamental to how Git works
02:54:25 <colonelj> I actually explain it in the document as "In Git however, a branch is very lightweight; in fact it is just a reference to some commit inside the Git repository."
02:54:35 <freeside> https://xkcd.com/1597/
02:55:29 <colonelj> freeside: I have a section on how to recover from file corruption as well
02:55:40 <colonelj> it's at the end
02:56:06 <freeside> you've got to be careful with git because it's powerful. and power corrupts.
02:56:13 <trigone> colonelj: yeah, everything's clear now, a branch is a reference to a commit!... what's a commit?
02:56:44 <freeside> a node in the evolving state diagram of your repo
02:57:23 <colonelj> yeah commits are in SVN so I didn't bother explaining that
02:57:31 <colonelj> a commit is just a current state of all your files
02:57:32 <trigone> freeside: a git's power is always dangerous
02:57:46 <colonelj> with some metadata like author, date etc.
02:57:48 <trigone> colonelj: a snapshot?
02:57:58 <colonelj> yeah
02:58:05 <trigone> so why the concept of branch?
02:58:17 <colonelj> branches point to particular commits and give them names
02:58:30 <EvanR> commits have parent commits that go back in time
02:58:34 <trigone> colonelj: then they change their diapers?
02:58:38 <colonelj> otherwise a commit is just referred to by some 235db23523a352a blah number
02:58:44 <EvanR> you can have multiple alternate histories to work on things separately
02:58:52 <EvanR> so you need branches to know where youre at
02:58:58 <trigone> i don't really get the purpose, it's a bit of a circle so far...
02:59:03 <trigone> to me i mean
02:59:24 <EvanR> two people can work on separate features at once
02:59:29 <EvanR> without clobbering each other
02:59:37 <colonelj> it's probably better to have this discussion in a different channel... like #git
02:59:37 <EvanR> eventually they would merge of course
02:59:53 <EvanR> git thee hence!
03:00:11 <trigone> EvanR: so the whole thing is, as i've read somewhere, a DAG?
03:00:16 <EvanR> yes
03:00:25 <colonelj> the direction is time
03:00:39 <colonelj> time doesn't go backwards so there are no cycles
03:00:46 <trigone> and a branch is a fork from some node onwards?
03:00:52 <colonelj> no branches aren't forks
03:01:06 <colonelj> they're just references to a particular commit
03:01:22 <EvanR> the docs have nice pictures for all this
03:01:29 <merijn> See, and this is why git is a huge mess of confusion :)
03:01:29 <EvanR> even the man pages have ascii diagrams
03:01:30 <trigone> so, the branch is the latest commit of a fork?
03:01:45 <colonelj> yeah, you could say that
03:01:52 <colonelj> but it doesn't have to be the latest commit
03:01:56 <merijn> trigone: I warned you! ;)
03:01:56 <EvanR> fork is a thing github made up
03:02:06 <EvanR> not git jargon
03:02:21 <trigone> merijn: i know :P but i am fearless (for now)
03:02:34 <colonelj> the only mention of fork in my document is when I was talking about MSYS2 and MinGW-64
03:02:54 <trigone> yeah but all those facts are not useful when you don't get the big picture...
03:03:03 <EvanR> its really not haskell specific
03:04:19 <trigone> i'm reading some tutorial for beginners. i think it'll help me learn what a version control sys is for
03:04:31 <colonelj> it's for... version... control
03:04:49 <EvanR> for stuff like not having to comment out every version of your code "just in case you want to revert"
03:05:30 <colonelj> I don't know how anyone who writes code can get by without version control
03:05:45 <EvanR> same way people write code without a type system :)
03:05:48 <trigone> lol i do get that, but i don't know yet how that functionality is actually implemented
03:05:48 <jophish> hvr: Hi, I'm expipiplus1 on github. Just letting you know that I'll get round to that PR eventually!
03:06:09 <btk> trigone: it just keeps track of your changes history. You can imagine it as storing multiple versions of your code
03:06:11 <colonelj> trigone: you really don't want to know how Git is implemented, it's a mess of perl scripts
03:06:16 <EvanR> you can find out how its implemented in #git
03:06:19 <EvanR> or by reading docs
03:06:32 <colonelj> you really don't need to know how it works, you just use it
03:06:55 <trigone> colonelj: no, i don't want to get how it's implemented under the hood. i just want to know how to drive the car because "it's a thing that changes your location" does not help me avoid trees
03:07:02 <EvanR> if youre like me, then you do really need to know how it works :)
03:07:22 <colonelj> there aren't any trees... except the one that stores all your commits
03:07:25 <AndreasK> It's worth knowing that it's based on a graph where commits are nodes
03:07:29 <EvanR> so you can confuse and frustrate coworkers with octomerges
03:07:30 <colonelj> you don't need to avoid it
03:07:36 <AndreasK> But otherwise I dont thing git internals help for understanding usage
03:07:58 <colonelj> I can't remember if I've ever used octomerge
03:08:09 <EvanR> why the hell not
03:08:27 <EvanR> dont answer that
03:08:29 <trigone> please do let me learn how to use the pedals then you'll start talking about drifting and nitro
03:08:31 <colonelj> it doesn't seem normal to have multiple things to merge at the same time unless you have multiple people working at the same time
03:08:35 <colonelj> normally I'm working on my own
03:08:37 <EvanR> lol
03:09:00 <EvanR> yes i use git a lot with collaborators
03:09:08 <AndreasK> Why is unicode on windows such a shitshow :(
03:09:36 <AndreasK> Even the localized output of make contains mangled characters
03:10:03 <colonelj> trigone: try this in an empty directory: git init \ vi README.txt \ git add README.txt \ git commit -m "Added README" \ git log
03:10:13 <freeside> you read a "choose your own adventure" book on your own, but you still need to track where you are in the state graph so you can undo.
03:10:44 <freeside> you might be bugfixing in one thread and documenting in another and adding an experimental feature in a third.
03:11:01 <EvanR> or you download the premade maps off gameFAQs
03:11:01 <colonelj> then do: rm README.txt \ git reset --hard
03:11:26 <colonelj> then your file miraculously reappears
03:11:41 <freeside> as a matter of notational style might i propose >> instead of \ lol
03:11:56 <trigone> colonelj: you should play at the magic theatre
03:12:07 <EvanR> trigone: this stuff really is not that hard to follow on the main guides if you just read them. this isnt really the place for a detailed on-the-spot tutorial
03:12:15 <freeside> although ; is actually correct
03:12:27 <colonelj> freeside: you and your monadic semicolons
03:12:32 <trigone> EvanR: i never asked one, you all keep telling me stuff i can't possibly get yet
03:12:45 <EvanR> well we need to stop
03:12:50 <trigone> :P
03:12:56 <colonelj> go to #git if you want
03:13:11 <colonelj> no one's talking in there anyway
03:13:30 <trigone> at #git?
03:13:39 <colonelj> yeah
03:13:45 <trigone> then why would i want to go where nobody is?
03:13:50 <colonelj> I'm there
03:14:07 <EvanR> trigone: because topics
03:14:23 <Phyx-> AndreasK: because make, like all gnu tools, use an 8 bit encoding for unicode chars
03:15:02 <trigone> EvanR: i get that, but colonelj seemed to imply nobody would answer me there
03:15:11 <EvanR> no 
03:15:20 <trigone> k
03:15:45 <EvanR> more like he will answer you there
03:16:01 <colonelj> it's full of people just very silent ones
03:16:24 <trigone> is there a channel for hg? at the risk of becoming a pariah, i do think i'll start with it, esp given i'm always alone on projects so far and my projects are very small
03:16:36 <EvanR> sure
03:16:43 <colonelj> pfft just use git
03:16:49 <trigone> colonelj: ok...
03:16:50 <EvanR> just use haskell!
03:16:52 <trigone> colonelj: lol
03:17:03 <colonelj> which dialect of Haskell?
03:17:11 <colonelj> I seem to be using a different one for nearly every file
03:17:21 <trigone> how many dialects are there?
03:17:42 <trigone> i know there's the 2010 thingy but i don't know why it's supposed to be different
03:18:03 <colonelj> I mean all the extensions that you have to enable to do anything useful
03:18:07 <EvanR> the standards exist to make ghc feel better about being the only implementation
03:18:11 <colonelj> Haskell2010 is pretty minimal
03:18:45 <EvanR> you can enable them all at once with a single flag! :)
03:18:54 <colonelj> it's deprecated though
03:19:13 <colonelj> they probably realised it was getting out of hand
03:19:43 <trigone> wait, haskell2010 is deprecated? in favor of 98?
03:19:57 <colonelj> no the magic flag to turn everything on is deprecated
03:19:58 <EvanR> that would be hilarious
03:19:58 <trigone> EvanR: what do you mean with standards ...?
03:20:03 <trigone> ah ok
03:20:03 <EvanR> haskell98
03:20:06 <EvanR> haskll2010
03:20:20 <colonelj> the two standards that I can't say I've ever cared about
03:20:27 <trigone> so, diff haskell98 haskell2010 = ?
03:20:31 <colonelj> most languages the standards are actually useful documents
03:20:37 <EvanR> in 1998 there were other haskell implementations
03:20:43 <colonelj> yeah the diff is very little from what I've heard
03:21:11 <trigone> okay... and 2010 is special to ghc?
03:21:21 <EvanR> not really
03:21:43 <trigone> pff i'm lost
03:22:04 <EvanR> to answer the original question, theres only 1 dialect of haskell
03:22:12 <EvanR> GHC haskell
03:22:16 <colonelj> trying to standardise haskell seems fairly pointless
03:22:46 <EvanR> well... everyone likes standards
03:23:01 <colonelj> I like them but I don't see the point in it for haskell it's so out of control
03:23:09 <jophish> I've found the standard very useful
03:23:11 <EvanR> youll find people criticizing language X, including haskell curiously, for having no standard
03:23:30 <EvanR> out of control haha
03:23:59 <colonelj> I wouldn't want to use a Haskell2010 only compiler
03:24:05 <colonelj> would be pretty much useless
03:24:13 <EvanR> would you rather implement GHC or haskell2010 :)
03:24:24 <colonelj> GHC honestly
03:24:24 <EvanR> if someone made you
03:24:35 <colonelj> I wouldn't use it if I did haskell2010
03:24:43 <colonelj> kinda takes the fun out of it
03:24:45 <EvanR> well thats not nec the point
03:25:13 <colonelj> I think the programming language I'm designing is already quite complex even compared to haskell
03:26:17 <colonelj> do you know much about Idris?
03:26:28 <colonelj> I wanna try it out sometime
03:26:28 <EvanR> yeah
03:27:13 <EvanR> i welcome our new dependently typed overlords
03:27:22 <colonelj> version 1.0
03:27:30 <colonelj> the time is nigh
03:27:50 <colonelj> before then it was just a reference to Ivor the Engine
03:28:23 <AWizzArd> a) newtype UserID = UserId Text    vs. phantom type    b) newtype Id a = Id Text
03:28:44 <AWizzArd> Is b) the more useful one here, because it can serve as a template for constructing lots of ID types?
03:29:10 <colonelj> well it's obviously more general so I guess so
03:29:22 <EvanR> the one thing you can do with it, get a Text would only need to be implemented once
03:29:57 <EvanR> but you will need a bunch of singletons to keep them straight
03:30:04 <EvanR> so ultimately the same amount of code?
03:30:04 <colonelj> newtype Id a = Id { getID :: Text }
03:30:21 <trigone> i hear left and right about "dependently typed". it's apparently impossible in haskell. is it so? is it that good, does it cause performance issues?
03:30:34 <colonelj> it causes undecidability in the type system
03:30:43 <EvanR> not entirely true
03:30:52 <trigone> colonelj: which is good or bad? does not seem good
03:30:58 <EvanR> or accurate, depending on what you mean
03:31:05 <colonelj> it's bad if you don't want to write out all the types manually
03:31:23 <EvanR> colonelj meant to say, apparently, that type inference is undecidable
03:31:32 <trigone> colonelj: personally i'm writing many signatures. helps me code right but then i'm a relative beginner
03:31:40 <EvanR> but you write your types out in haskell anyway. further, most of your work in a DT setting is in the types anyway
03:32:03 <EvanR> it wouldnt even make sense not to put most top level sigs
03:32:12 <trigone> EvanR: as for perfs?
03:32:14 <freeside> https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
03:32:21 <trigone> EvanR: some seem to do so but bleh
03:32:38 <EvanR> see that blog post for the latest on when were getting full dependent types
03:32:42 <AndreasK> Phyx-: It works fine in a utf8 powershell, not in a utf8 msys shell for some reason though
03:32:58 <EvanR> but for a while now people have been faking it in haskell regardless of lack of full dependent types
03:33:29 <EvanR> what are perfs ?
03:33:45 <trigone> can anyone give me an example of "dependent types"
03:34:01 <EvanR> the classic example is the length-indexed list type
03:34:13 <trigone> EvanR: well since it's an additional and clearly abstract thing, i'm wondering if there is a risk of repercussions on the practical side
03:34:18 <EvanR> data Vect :: Nat -> Type -> Type where
03:34:26 <EvanR>   Nil :: Vect 0 a
03:34:48 <EvanR>   Cons :: a -> Vect n a -> Vect (n+1) a
03:34:51 <trigone> a trade off abstraction/efficiency, which haskell has it rather low, which is good :)
03:35:07 <EvanR> so [1,2,3] :: Vect 3 Int
03:35:14 <colonelj> trigone: dependent types don't have any overhead, they're all removed at compile time
03:35:15 <EvanR> the size is in the type
03:35:26 <trigone> EvanR: is that not like "type family" or something? 
03:35:35 <EvanR> no
03:35:36 <trigone> colonelj: good to know
03:35:42 <colonelj> trigone: type families are functions from types to types
03:35:50 <colonelj> trigone: dependent types have functions from values to type
03:35:52 <EvanR> you could say its an indexed family of types
03:36:02 <EvanR> indexed by a number
03:36:08 <trigone> and (n+1) does not imply a function between types?
03:36:13 <EvanR> where as [a] is a type parameterized by a type
03:36:16 <AWizzArd> I found readMaybe in Text.Read.  Is there a readMaybe that will accept junk and return the number until the first non-digit item? So that    readMaybe "20xyz" :: Maybe Int    will still return 20?
03:36:21 <freeside> if you're willing to move your brain sideways to a different language for a moment, https://www.grammaticalframework.org/doc/tutorial/gf-tutorial.html#toc110 has a very practical introduction involving lamps and fans.
03:36:31 <EvanR> trigone: not in this case no, n+1 is a number
03:36:48 <trigone> hmm... it's like replacing part of the name of a type by a number? making Vector0, Vector1, ...
03:36:55 <EvanR> no
03:37:09 <quchen> > reads "123xyz" :: [(Int, String)] -- AWizzArd 
03:37:10 <lambdabot>  [(123,"xyz")]
03:37:11 <EvanR> you understand Maybe Int ?
03:37:26 <trigone> EvanR: sure...
03:37:43 <freeside> such a function should be named zeroday: https://news.ycombinator.com/item?id=14681377
03:38:03 <EvanR> Maybe is not a full type yet, you have to apply it to a Type to get a Type
03:38:24 <EvanR> Vect :: Nat -> Type -> Type is the same way, but it takes 2 arguments, one Nat and one Type
03:38:39 <trigone> i'm with you so far
03:38:54 <EvanR> Vect 3 Int is the type of lists of 3 ints
03:39:08 <trigone> yes ok
03:39:19 <EvanR> the dependent part is that 3 isnt a type
03:39:24 <EvanR> its a value
03:39:35 <AWizzArd> quchen: thx
03:39:36 <EvanR> this expands to a helluva lot
03:39:44 <EvanR> but Vect is the only real example we usually are given
03:39:50 * EvanR reads freeside's link
03:40:05 <colonelj> trigone: think about a dependently typed matrix
03:40:11 <colonelj> say Mat m n
03:40:15 <colonelj> m rows and n columns
03:40:26 <colonelj> Mat m n t rather
03:40:36 <colonelj> so t is the type of each element
03:40:45 <colonelj> you can express matrix multiplication as
03:41:15 <colonelj> Mat x y -> Mat y z -> Mat x z
03:41:21 <AWizzArd> Is there also some version of reads for which   reads "20" :: [(String, Int, String)]  => [("", 20, "")]?
03:41:24 <colonelj> Mat x y t -> Mat y z t -> Mat x z t
03:41:38 <quchen> trigone: Another very practical example: Haskell has [a] and NonEmpty a, both of them are lists, except NonEmpty has at least one element. With dependent types, we could just write down »list, but with at least one element«, and have both use the same list representation. Since Haskell can’t do that, we have to create separate types for both of them (and thus separate functions!).
03:41:40 <trigone> colonelj: yeah i get all that, there was a tutorial that was doing it using ... GADTs and maybe type families. though it was clunky
03:41:45 <AndreasK> Phyx-: Turns out make supports utf8 fine. The GUI of mintty just sets the locale as en_GB@UTF-8 instead of en_GN.UTF-8 which breaks it
03:42:15 <EvanR> trigone: yes currently we have Nat as a DataKind... its klunky
03:42:20 <EvanR> and 3 really is a type
03:42:23 <EvanR> not a value
03:42:25 <trigone> quchen: it's like adding metadata to types and using it to check even more at the type level
03:42:26 <EvanR> super klunky
03:43:23 <quchen> trigone: Doesn’t have to be metadata. It’s really like adding another argument to a function.
03:44:00 <EvanR> you can think of it as metadata that is accessible to the type checker
03:44:04 <freeside> a type that knows something about its inhabitants
03:44:05 <quchen> trigone: Type-safe printf for example uses the format string to calculate the type of »printf <str>«.
03:44:18 <freeside> that something has the semantics of a constraint
03:44:41 <quchen> printf "%s" :: String -> String; printf "%d% :: Int -> String
03:44:55 <trigone> quchen: yes, the idea of metadata is subjective. but the length or dimension of some vector could be seen as "additional data useful on the side" rather than "the reason why we built a vector". you always create a vector because you want to put things in it, not because you need to put a "length = 3" data thingy
03:45:17 <quchen> trigone: Sure, in the vector example it’s metadata.
03:45:24 <EvanR> sometimes you do need it to be length 3
03:45:35 <EvanR> but it doesnt need to be a literal 3
03:45:38 <EvanR> it can be a formula
03:45:39 <trigone> quchen: especially, if it gets erased after typechecking then it's not really the data that the program runs on
03:46:00 <EvanR> concat :: Vect m a -> Vect n a -> Vect (m + n) a
03:46:05 <EvanR> see
03:46:10 <colonelj> trigone: by that argument all types are metadata
03:46:25 <quchen> trigone: Well, Haskell also erases its types during compilation, so types themselves are metadata already.
03:46:29 <colonelj> is there a dynamically typed haskell? :P
03:46:44 <quchen> Data.Dynamic
03:46:46 <colonelj> -XIgnoreAllTheTypes
03:46:52 <EvanR> haskell has type safe dynamic types!
03:46:55 <freeside> the cool thing about type theory is that you get a very structured way to talk about meta-meta-data.
03:46:55 <trigone> colonelj: well sure i know... let me think because there must be a way that i'm not wrong
03:46:58 <EvanR> with type-indexed Typeable
03:47:16 <colonelj> freeside: don't forget about the meta-meta-metadata
03:47:51 <freeside> imho, it all goes back to the set-theoretic vs type-theoretic responses to Russell's paradox
03:48:04 <EvanR> trigone: you really have to sit down and try something with dependent types to get it... its just too weird :)
03:48:16 <freeside> what do you think of the lights and fans example?
03:48:22 <trigone> EvanR: honestly i get your examples fine so far
03:48:36 <EvanR> even the version with + in it ?
03:49:30 <trigone> well sure. the typechecker will only allow a result with the proper type. i don't remember how it's implemented mind you...
03:49:30 <EvanR> also yes, that page is good, though goes pretty far past that example
03:49:41 <merijn> ugh...that annoying feeling where you unsure to continue your quest to refactor/update a codebase or just rewrite it...
03:50:16 <colonelj> merijn: refactoring and rewriting are pretty much the same
03:50:17 <EvanR> trigone: the concrete length of lists is not always known at compile time
03:50:29 <colonelj> merijn: stop thinking and just get on with it!
03:50:36 <EvanR> so the checker will need to check... stuff like m + n
03:50:46 <EvanR> against whatever m and n are
03:50:54 <EvanR> which could be other formulas
03:51:18 <EvanR> and unify with other types thats might not be numbers either
03:51:50 <trigone> EvanR: ok, that makes more sense. in short the typechecker does nothing more than checking that all the functions' types align
03:52:04 <EvanR> people have ben demanding stuff like this for a while, and dependent types delivers it. but ...
03:52:39 <trigone> EvanR: is it practical in terms of applied programming?
03:53:00 <trigone> and i don't say that with an a priori, i went to haskell bc its abstract tools seemed much more reasonable for coding
03:53:14 <EvanR> trigone: it checks that types align, after performing computation at the type level, because it doesnt know how to solve arbitrary mathematical problems to prove things do actually align
03:53:16 <colonelj> trigone: generally dependent typed stuff takes more effort, just like having more complicated types
03:53:35 <EvanR> its up to you to help it align
03:53:37 <colonelj> using phantom types and whatever
03:53:39 <trigone> colonelj: but is it effort that helps the rest of the coding?
03:53:57 <colonelj> trigone: it helps you detect bugs at compile time
03:54:07 <trigone> EvanR: well like with everything related to types, right?
03:54:35 <trigone> colonelj: yeah but i'm questioning how it translate to the part of code not in the type system: is it blind to all this?
03:54:36 <EvanR> well, i think youre on board with dependent types :)
03:54:45 <colonelj> trigone: pretty much yes
03:55:15 <colonelj> usually the dependent types end up being longer than the actual code
03:55:38 <colonelj> especially in my language because I have slightly more verbose syntax for types stuff
03:55:48 <trigone> cool, that does seem good. still it means so much will be rewritten: head, (!!), etc. that will make even more duplicates for the sake of keeping old stuff working... :/
03:56:09 <trigone> colonelj: verbosity kills
03:56:28 <colonelj> colonelj: well you can ignore the types if you want
03:56:33 <EvanR> nothing needs to be rewritten for dependent haskell
03:56:42 <merijn> hmmm, async doesn't propagate exception down to async threads forked from it, no?
03:56:43 <EvanR> its an optional extension, you dont need to use it
03:56:54 <EvanR> merijn: not by default
03:56:54 <colonelj> EvanR: doesn't that kinda defeat the point?
03:57:03 <EvanR> no?
03:57:06 <trigone> EvanR: no but while using a version of head with special dependent types, won't it need rewriting at the signature level?
03:57:10 <merijn> EvanR: I don't see a way how to do it optionally either
03:57:39 <colonelj> you can't guarantee totality without having correct signatures
03:57:46 <merijn> EvanR: Well, maybe hand-writing something using STM, but then I might as well do it myself to begin with.
03:58:27 <EvanR> merijn: you want all children from a parent to get the same exception as the parent?
03:58:51 <merijn> EvanR: That'd work, yeah
03:59:00 <EvanR> use withAsync
03:59:49 <EvanR> though, they might only get ThreadKilled
03:59:58 <merijn> EvanR: I'm not quite sure if that works if I keep calling it recursively
04:00:27 <EvanR> it does build up yeah
04:00:35 <trigone> when you think about it, types look a lot like commenting what your code does and having a computer check it works all together (and that it reasonably fits the rest of the code)
04:00:41 <merijn> EvanR: Yeah, that's gonna be a problem in an infinite loop ;)
04:01:06 <EvanR> you can use link to add a dependency after the fact
04:01:18 <EvanR> but theres a window
04:01:27 <merijn> EvanR: Basically, I wanna fork threads for incoming socket connections and then kill every thread in one fell swoop when my main thread exits
04:01:58 <EvanR> *the* main thread?
04:03:12 <freeside> if these are userspace threads why not just kill the process and let the OS sort them out
04:03:26 <merijn> EvanR: hmm, actually, maybe I'm trying to do things the wrong way here...
04:04:24 <colonelj>  merijn: I usually do clean shutdown by always using timed I/O and having a global variable to stop everything
04:04:43 <EvanR> controlled shutdown, what a myth!
04:04:47 <colonelj> it's not
04:05:12 <colonelj> that's why you shouldn't poll forever
04:05:24 <EvanR> do not agree
04:05:24 <merijn> eh, screw it, I'll just keep the loop single-threaded
04:05:57 <colonelj> anything that takes infinite time isn't good
04:06:08 <EvanR> when its concurrent programming, its good
04:06:17 <EvanR> C style timeout loops are crap
04:06:29 <colonelj> they're not they work great
04:06:34 <EvanR> not in haskell
04:06:53 <freeside> fight, fight
04:07:08 <freeside> this question shall be decided in Trial by Combat
04:07:58 <colonelj> it's alright if you can box up exceptions into your futures
04:08:05 <Cale> It's possible to use async to clean up threads.
04:08:11 <EvanR> async does that
04:08:18 <freeside> merijn: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent.html suggests your problem is already solved ... ?
04:08:30 <freeside> In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is "daemonic threads").
04:08:46 <EvanR> yes the main thread dying will end everything
04:08:47 <colonelj> ew
04:08:53 <colonelj> horrible way to end a program
04:09:08 <colonelj> your logging thread won't finish logging or anything
04:09:21 <EvanR> you should flush your log before doing this
04:09:29 <EvanR> and other files because its not done for you
04:09:52 <colonelj> the main thread should be the last one to complete
04:10:02 <freeside> crash-only design suggests that all log writes should flush themselves.
04:10:19 <EvanR> that would help
04:10:37 <EvanR> but still doesnt guarantee youll get everything
04:10:57 <freeside> if the server crashes, your threads are toast anyway
04:11:05 <EvanR> yep
04:11:17 <EvanR> controlled shutdown ends up being a large what/why
04:11:45 <EvanR> we know how is impossible
04:12:13 <Cale> async's cancel will block until the thread that the Async refers to has ended.
04:12:48 <Cale> So if you want to do that sort of cleanup, you can have your main thread iterate through a bunch of Asyncs before it finishes, and cancel them all.
04:13:03 <freeside> at which point one has reinvented Erlang lol
04:13:18 <EvanR> you reinventd erlang after doing a lot more than this
04:13:54 <EvanR> having to do with all the stuff that needs to happen during normal operation and were NOT trying to shut it all down
04:14:05 <Cale> I would think 'link' is more characteristic of Erlang :)
04:14:13 <Cale> https://hackage.haskell.org/package/async-2.1.1.1/docs/Control-Concurrent-Async.html#v:link
04:14:40 <EvanR> yeah async lets you get erlang-like pretty fast
04:20:31 <EvanR> unless i missed a preexisting function in there, you could be able to get something like `async' but which safely `link's you to the child automatically with a clever mask
04:20:58 <EvanR> instead of async then link
04:21:15 <EvanR> (since withAsync wont really work in an infinite loop)
04:22:04 <EvanR> no STM or MVars shenanigans required
04:22:19 <colonelj> I'm thinking in my language not to give the programmer any control over threads and just letting the runtime do what it wants
04:22:44 <colonelj> and use empirical measurements to measure progress and see if some computation needs more threads
04:22:57 <EvanR> automatic parallelization eh
04:23:03 <colonelj> yeaaa
04:23:15 <EvanR> entirely missing the point of concurrent programming patterns
04:23:25 <colonelj> like what
04:23:41 <EvanR> which have not much to do with parallelism
04:23:49 <EvanR> the whole erlang thing
04:23:57 <barrucadu> Concurrency is a handy way to structure programs, I tend to think of it as a design pattern.
04:24:16 <colonelj> my language is transaction based, between transactions you have concurrencty
04:24:31 <colonelj> no need to define locks or any of that crap
04:25:08 <EvanR> yes STM lets you treat all your variables as being transactional together
04:25:18 <EvanR> but wouldnt really amount to much if you couldnt use threads
04:26:18 * hackagebot simple-logging 0.1.0.0 – Logging effect to plug into the simple-effects framework – https://hackage.haskell.org/package/simple-logging
04:33:02 <kuribas> Does haskell have undefined behaviour, like C?
04:42:19 <merijn> kuribas: Well, bottom seems like it'd qualify, but I think everything else is defined
04:42:20 <quchen> kuribas: I don’t think so.
04:42:22 <Axman6> not that I can think of. I believe things like overflow is defined
04:43:04 <quchen> kuribas: There are undefined things in the Haskell Report, but none that allow the compiler to do anything. For example, seq’s evaluation order is not specified, to be chosen by the implementation.
04:43:55 <kuribas> quchen: yeah, only the implementation is undefined, not the semantics right?
04:43:57 <Maxdamantus> I think bottom is quite different to UB.
04:44:15 <quchen> merijn: Bottom isn’t undefined behavior – it’s the least defined value of something, but it is a proper value
04:44:39 <Maxdamantus> I imagine the closest would be unsafe* functions.
04:45:00 <Maxdamantus> (which might not actually exist)
04:45:07 <quchen> I think unsafePerformIO is standard
04:45:23 <merijn> yeah, in the FFI section
04:45:32 <Maxdamantus> It's specified, but not required.
04:45:39 <Maxdamantus> (iirc, FFI is optional)
04:46:54 <quchen> A C for(;;) loop also has value ⊥, but it would be wrong for a compiler to wipe your harddrive when it encounters one
04:47:13 <merijn> quchen: Define "wrong"
04:47:22 <merijn> It wouldn't stop being standards compliant because of that
04:47:41 <Axman6> just morally corrupt
04:48:08 * Maxdamantus doesn't like considering bottom to be a value.
04:48:19 <merijn> In crypto circles I saw a proposal for a "maximally malicious standard compliant compiler", so you'd prove things wrt to said maximally malicious compiler
04:48:32 <quchen> Haha okay
04:48:53 <kuribas> gcc used to run programs like nethack when encountering some undefined behaviour.
04:49:22 <quchen> A maximally malicious Haskell compiler couldn’t do much wrong I think.
04:49:48 <Axman6> there was that one time where it would delete your file if it didn't typecheck though...
04:50:06 <Maxdamantus> It doesn't seem infeasible for UB in C to actually do things like wipe your harddrive.
04:50:14 <Maxdamantus> (in an implementation like gcc)
04:50:15 <EvanR> bottom is a lack of value, lack of anything!
04:50:28 <Maxdamantus> UB is what lets the compiler make assumptions about the code.
04:50:58 <trigone> hi, i'm reading this tutorial on hg, and it says it uses hard links to make clone of repositories. how then does it prevent a change in a file on one copy to be repercuted on the other copy, given basically they share the same file on hardware?
04:51:18 <Maxdamantus> The source code is not allowed to induce UB, so the compiler is allowed to make assumptions based on that.
04:51:34 <Axman6> trigone: probably by using copy on write
04:51:47 <Axman6> trigone: (also, this is a kinda odd place to be asking that :)
04:52:00 <EvanR> very odd
04:52:04 <Maxdamantus> if those assumptions are broken, maybe you'll end up copying the wrong pointer or something and end up passing "rm -rf /*" to system(3)
04:52:13 <trigone> Axman6: yeah i know but we spoke offtopic of it at length previously so i thought i could survive the shame
04:54:06 <merijn> trigone: It hardlinks the repository files, not the checked out files
04:56:33 <Maxdamantus> I like the optimisation gcc had where it would turn something like `int a[20] = ..; for(int x = 0; x <= 20; x++) a[x] = 0;` into an infinite loop.
04:57:24 <Maxdamantus> because it could assume that `x < 20` because otherwise the code would induce UB by assigning to `a[x]`
04:57:56 <Maxdamantus> and `x < 20` means you can replace `x <= 20` with `1`
04:58:34 <Maxdamantus> and you can omit the loop body because the loop never exits so any code afterwards doesn't care about the state of `a`
05:02:07 <Maxdamantus> Well, to be precise, it can assume that `x < 20` before the loop body (ie, at the point in time where that condition is evaluated)
05:02:32 <Myrl-saki> Maxdamantus: Inifnite loops are undefined behavior though.
05:02:53 <absence> is ghc 8.2 taking longer than usual in RC stage? the mailling list is pretty quiet about it
05:03:22 <quchen> Infinite loops have defined behavior: they loop forever.
05:03:34 <quchen> MAX_INT+1 has undefined behavior.
05:03:41 <quchen> Semantics: do whatever
05:03:54 <colonelj> trigone: I reuploaded my git instructions with word wrapping http://lpaste.net/2165566534057984000
05:04:12 <EvanR> funny that we take "looping" for granted like its clearly defined as something
05:04:18 <EvanR> in any context
05:04:48 <EvanR> i assume looping somehow corresponds to something in C virtual machine
05:04:55 <colonelj> it's defined as returning to the same instruction pointer repeatedly
05:05:12 <EvanR> thats not a thing in pedantic C
05:05:23 <EvanR> or haskell
05:06:08 <colonelj> it's a low level description
05:06:32 <EvanR> even at a low level its a funny word for what its doing
05:06:44 <EvanR> in math you might call it a cycle
05:06:48 <EvanR> and so, cycling
05:07:12 <EvanR> but a cycle has some substance to it
05:07:22 <EvanR> and an "infinite unproductive loop" doesnt
05:07:29 <colonelj> I think my definition is fine
05:07:33 <colonelj> loops can be productive or not
05:07:43 <colonelj> 10 PRINT "HELLO" 20 GOTO 10
05:07:52 <colonelj> that's a productive loop
05:08:00 <EvanR> more often than not "its looping" here means not productive
05:08:15 <colonelj> what about a real eval LOOP?
05:08:27 <quchen> EvanR: An infinite loop is the identity of the Concurrentpy Alternative :-þ
05:09:47 <EvanR> like, repeat 1 is not considered looping, its an infinite list. indistinguishable from a heap object loop or a really really long list
05:10:03 <EvanR> let x = x in x ... is suddenly "looping" 
05:10:22 <EvanR> nevermind i will not question the obvious anymore
05:10:28 <Tuplanolla> Don't say "it's defined" when it's not defined, colonelj.
05:11:13 <Tuplanolla> The C standard does not even use concepts such as instruction, stack or heap.
05:11:38 <colonelj> when did I say that
05:12:22 <Tuplanolla> A few minutes ago: "it's defined as returning to the same instruction pointer repeatedly".
05:12:47 <colonelj> yeah, at the machine level
05:13:01 <colonelj> the program has to be stored somewhere
05:13:01 <EvanR> actually that definition doesnt really work
05:13:24 <merijn> colonelj: The C standard doesn't have a machine level
05:13:43 <colonelj> look it's not supposed to be a rigorous definition, quit complaining and come up with your own
05:13:45 <merijn> Nothing says C has to compile to machine instructions
05:13:49 <EvanR> since you can return to a particular place in the program without having any looping behavior from the higher level
05:13:58 <colonelj> I think it well describes what a loop is practically
05:14:11 <colonelj> that's why I used the example of a read eval loop
05:14:15 <Tuplanolla> Haskell, huh.
05:14:18 <colonelj> showing that those kind of loops do exist
05:14:21 <Axman6> I wonder if CERN's CINT actually compiles to machine code or just interprets everything
05:15:19 <Axman6> (apparently it's not maintained by CERN anymore)
05:16:15 <EvanR> is that goolge or some fancyass company that is located on a road called infinite loop
05:16:24 <EvanR> google*
05:17:03 <Axman6> Apple
05:17:09 <EvanR> ah
05:17:20 <EvanR> makes more sense
05:18:17 <Maxdamantus> > let x = x in x
05:18:23 <lambdabot>  mueval-core: Time limit exceeded
05:18:33 <EvanR> it wont <<loop>> because its not compiling
05:18:36 <Axman6> that's the definition of like 90% of GHC.Prim >_<
05:18:38 <Maxdamantus> Hm, I think GHC might only show the "<<loop>>" thing when compiling
05:18:39 <Maxdamantus> yeah.
05:19:39 <EvanR> loops are like... incredibly folkloreish... theyre not in the semantics or even in the syntax
05:19:41 <merijn> And even then only sometimes
05:20:02 <EvanR> and everyone knows what they are, seemingly
05:20:04 <merijn> <<loop>> is just a courtesy "hey, I happened to notice this was looping"
05:20:23 <merijn> There's plenty of ways to get an infinite loop where GHC doesn't notice
05:20:51 <bno1> otherwise it would solve the halting problem
05:21:07 <EvanR> i would be ok with that
05:21:08 <Axman6> yeah, and Haskell ain't no Agda
05:21:14 <hpc> <<loop>> also only appears if you use the non-threaded runtime
05:21:53 <cocreature> hpc: huh, that explains why I haven’t seen it in a while :)
05:22:11 <Myrl-saki> Oh cool.
05:22:23 <Maxdamantus> Maybe someone should submit a bug saying that GHC should be able to determine when a program will never halt.
05:22:25 <Myrl-saki> New article: GHC solves the halting prolbem.
05:22:30 <Myrl-saki> Maxdamantus: lmao
05:22:47 <hpc> cocreature: with the threaded runtime, there's a possibility of another thread breaking the loop
05:23:16 <EvanR> how
05:23:20 <hpc> er, and more importantly the possibility of two threads evaluating the same thing
05:23:21 <Axman6> it can detect what that is impossible too though
05:23:36 <Axman6> (and you get the blocked indefinitely on MVar error for examepl)
05:23:41 <Axman6> example*
05:23:47 <hpc> in the non-threaded runtime, evaluating a thunk turns it into a black hole that prints <<loop>>
05:23:53 <hpc> in the threaded runtime, that is instead a 
05:24:04 <hpc> a "grey hole" which just waits for something else to finish evaluating it first
05:24:30 <EvanR> not sure how that would break the loop
05:25:07 <EvanR> but i see how it would prevent deciding to give up and show <<loop>>
05:25:18 <hpc> threads can kill other threads
05:25:26 <hpc> or throw async exceptions
05:25:48 <cocreature> well ghc could check if other threads have references to the threadid
05:25:56 <EvanR> if you could somehow detect a <<loop>> might as well die now and save them the trouble?
05:26:07 <EvanR> it already kills you for other reasons... now
05:26:12 <cocreature> although if you take ffi into account you can probably get the threadid directly from the rts so it doesn’t help
05:27:12 * hackagebot data-diverse 0.5.0.0 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
05:27:24 <EvanR> i didnt think there was a way to get all the existing ThreadIds
05:28:13 <cocreature> the rts needs to know about them so there should be at least some undocumented unsupported way to get them
05:28:39 <EvanR> i sort of hope not :)
05:29:49 <Axman6> quit = getAllThreadIds >>= mapM_ (flip throwTo KillThread)
05:31:07 <EvanR> haha
05:31:32 <EvanR> and "you" are like number 6 in that list, out of 50, and it makes no sense
05:31:37 <Axman6> russian roulette, because it might kill itself first!
05:31:50 <bno1> lol
05:32:13 <EvanR> good basis for a gruesome thought experiment though
05:32:30 <Axman6> s/quit/nonDeterministiclyFuckYourApp/
05:35:35 <grmp> hi all! do you know if there is some simple examples to link a Windows manifest file in a cabal package?
05:36:51 <grmp> in order to point to the right version of comctl32.dll
05:38:00 <grmp> I'm trying to use haskell-libui (https://github.com/beijaflor-io/haskell-libui)
05:38:47 <grmp> the examples compile but I have an "TaskDialog entry point error"
05:39:23 <colonelj> I think there's a windows tool you can use to embed a manifest into an .exe
05:39:39 <colonelj> but yeah I had a similar problem with Rust and there wasn't really a good solution
05:41:28 <grmp> ok, there is a manifest trick in ghc sources to bypass UAC but "far too complex for me"
05:44:20 <grmp> here in maybeCreateManifest: https://github.com/ghc/ghc/blob/22b917eeb1d101cf0b6af2c94826446e4e2f2cdb/compiler/main/DriverPipeline.hs
05:49:17 <grmp> seems to be Mage.exe (Manifest Generation and Editing) in .NET SDK
05:50:08 <grmp> I will try it as soon as possible, thanks you in advance
05:50:47 <grmp> (I was searching for a custom Setup.hs way)
05:59:27 * hackagebot simple-logging 0.2.0.0 – Logging effect to plug into the simple-effects framework – https://hackage.haskell.org/package/simple-logging
06:05:10 <freeside> right, so have we achieved consensus, then?
06:05:31 <Axman6> some say we have, others disagree
06:07:08 <freeside> haha
06:07:23 <cocreature> as long as the majority agrees it’s fine
06:07:55 <freeside> and those who don't agree? fork 'em.
06:08:14 <Axman6> so, was there some context to your question?
06:09:18 <freeside> nope, just your average non sequitur
06:15:00 <haskell-herbert> Hello guys i am working with the hackage package Data.Tree and i am having some issues to fold over rose trees. Is there anybody who is willing to help me
06:16:04 <cocreature> haskell-herbert: just asking your actual question and sticking around for a bit usually works better :)
06:20:06 <haskell-herbert> cocreature: i got a tree like this: https://pastebin.com/01RVMCBJ and i want extract a subtree by specifying an Int value
06:20:22 <haskell-herbert> i thought doing this with a fold should be possible
06:21:23 <lyxia> A fold will forget the tree structure
06:23:36 <haskell-herbert> what is wrong with this approach: https://pastebin.com/7c0zac1g
06:24:24 <haskell-herbert> this snippet should extract the subtree at 4
06:25:00 <haskell-herbert> and if 4 is not contained in this tree the accumulator is returned
06:25:48 <lyxia> does it typecheck
06:25:54 <haskell-herbert> no
06:26:07 <haskell-herbert> but what did i do wrong 
06:26:30 <cocreature> :t foldr
06:26:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:26:37 <cocreature> now substitute Tree for t
06:26:54 <cocreature> and Int for a
06:27:02 <cocreature> then f will be of type (Int -> b -> b)
06:27:13 <cocreature> but your f takes a "Tree Int" as it’s first argument
06:27:17 <cocreature> so it doesn’t typecheck
06:28:29 <haskell-herbert> ok i see
06:28:57 <haskell-herbert> i cant process the tree structure in the function of a fold?
06:29:13 <haskell-herbert> do you have any ideas how to extract a subtree out of this structure
06:29:25 <cocreature> just write a recursive function
06:29:28 <freeside> the sculpture is already inside the marble.
06:31:06 <ezyang> piyush-kurur: pong 
06:31:29 <piyush-kurur> ezyang: I wanted to know more about compact regions
06:31:52 <ezyang> what would you like to know? 
06:32:04 <piyush-kurur> As i understand it it is to stash some permanent data for programs
06:32:18 <piyush-kurur> and gc is guranteed to not touch it ?
06:32:37 <ezyang> yep, in the sense that it won't traverse it 
06:32:50 <piyush-kurur> will it move it around?
06:33:05 <ezyang> nope 
06:33:27 <piyush-kurur> looks like an attractive way to store pure haskell values in locked memory
06:33:33 <locallycompact> How do you use the monad functions in the body of an arrow block?
06:33:49 <locallycompact> like if I have say
06:33:52 <locallycompact> rofl :: Kleisli (RWS Config [String] State) Int String
06:33:56 <piyush-kurur> I am looking at it from the perspective of crypto applications
06:34:06 <locallycompact> rofl = proc x -> do
06:34:08 <haskell-herbert> cocreature: i tried to write a recursive function aswell but i got stuck
06:34:09 <locallycompact>   f <- ask
06:34:10 <locallycompact> doesn't work
06:34:27 <wz1000> Is there a safe way to turn a FastString into Text without going through String?
06:34:48 <haskell-herbert> this is what i came up with https://pastebin.com/2EYgZqZu
06:34:54 <ezyang> piyush-kurur: Maybe. You'd still have to arrange for a block to go on locked memory 
06:35:29 <piyush-kurur> ezyang: that is where I was thinking of having something like a locked variant of compact
06:36:07 <piyush-kurur> it might be quite useful for crypto
06:37:33 <lyxia> locallycompact: you can turn ask into an arrow with (Kleisli (const ask))
06:38:33 <locallycompact> like f -< Kleisli (const ask) ?
06:38:33 * hackagebot protocol-buffers 2.4.1 – Parse Google Protocol Buffer specifications – https://hackage.haskell.org/package/protocol-buffers
06:38:45 <piyush-kurur> all that is probably needed (apart from the compact implementation) is to have a way to lock and unlock when the region is no more needed
06:38:49 <locallycompact> no that doesn't work
06:39:23 <piyush-kurur> ezyang: let me know if you think it is feasible, in which case I can contribute code for it
06:40:00 <ezyang> The big question is whether or not you can make the block manager play with locked memory 
06:40:03 <ezyang> How does that API work? 
06:41:20 <piyush-kurur> ezyang: consider the following situation, read password as bytestring, use it to decrypt something
06:41:34 <lyxia> locallycompact: I don't know, I don't use arrow notation
06:41:40 <piyush-kurur> the problem is the read password will return a pure haskell value that is not really locked
06:42:08 <lyxia> locallycompact: but I would expect "Kleisli (const ask)" to appear somewhere
06:42:13 <ezyang> piyush-kurur: Yeah, achieving E2E security here seems difficult 
06:42:18 <ezyang> (with the compact mechanism) 
06:42:38 <piyush-kurur> I was thinking of a variant of compact not compact itself
06:43:43 <piyush-kurur> ezyang: I will have a look at your paper and see if there is some concrete thing I can propose 
06:44:26 <ezyang> sure 
06:45:10 <ezyang> that's what it's for :) 
06:45:32 <piyush-kurur> ezyang: might need your help though
06:45:43 <piyush-kurur> s/might/will
06:48:39 <osa1> wtf our server just crashed in test environment because of an uninitialized record field in warp-tls-3.2.2. I don't understand how not initializing a field is a warning rather than an error
06:48:57 <osa1> turns out that bug is fixed in warp-tls-3.2.3 (but not mentioned in the changelog so you have to figure that part yourself)
06:49:31 <Athas> I agree that this seems like a misfeature.
06:49:36 <Athas> I wonder about the justification.
06:49:56 <Athas> You could always just pass 'undefined' (or some other bottom value) if you really knew those fields were not important.
06:50:00 <osa1> we can make that warning an error with ghc 8.2 but it'll take a long time for us to upgrade to ghc 8.2
06:51:30 <osa1> + it'll take a looooong time for the library devs to enable that flag
06:52:04 <osa1> Haskell's billion dollar mistake
06:55:10 <sproingie> what ghc needs is a way to turn specific warnings into errors
06:56:05 <sproingie> bully that it did so for record fields, but 8.2 didn't add that for arbitrary warnings, did it?
06:58:04 * hackagebot hnormalise 0.4.2.0 – Log message normalisation tool producing structured JSON messages – https://hackage.haskell.org/package/hnormalise
06:58:33 <osa1> sproingie: I think it did
06:58:45 <osa1> although I can't find the flag for that right now
06:59:26 <mmx_> test
07:00:12 <Athas> osa1: that's overdoing it a little.  More like Haskell's pizza-and-a-coke mistake.
07:00:39 <osa1> Athas: well it annoyed me a great deal :-P
07:01:17 <Athas> Just like getting your order screwed up at a pizza place!
07:01:53 <mnoonan> it's pretty bad, it breaks the "make a change then patch up compilation errors until it builds" style of refactoring
07:03:06 <osa1> mnoonan: +10000000000 exactly this
07:03:22 <osa1> that is quite important part of my everyday workflow
07:03:40 <osa1> change types, follow compile errors
07:03:46 <shapr> yeah, me too
07:03:55 <sproingie> laziness sort of creates the $1B mistake in the type system.  sorta.
07:04:02 <osa1> if our code base was warning-free maybe that'd be OK but we already have dozens of warnings so a new warning usually not seen until it's too late
07:06:10 <sproingie> i'm the OCD sort that tries to eliminate all warnings
07:07:10 <shapr> me too, but I also set -fno-warn-missing-signatures when I'm writing code I'll use to teach others.
07:07:53 <sproingie> sensible
07:09:12 <sproingie> if it's a warning i just can't avoid, i'll specifically disable it.  in c++ projects, -Weverything will generate oodles of spurious warnings.
07:10:06 <Athas> shapr: why don't you want signatures in teaching code?
07:10:24 <shapr> Athas: because non-Haskell people rarely find them helpful.
07:10:24 <mmx_> Hey I was wondering if someone could give me a little push in the right direction.. coming from an OOP background, trying to wrap my head around Haskell, what is the idiomatic way to do a factory-like function such as selecting/creating a database driver (that conforms to the IDatabase interface) based on dynamic user input
07:11:06 <shapr> Athas: I've given roughly one Haskell talk every other month the past coupla years, mostly to non-Haskell people. 
07:11:24 <sproingie> sometimes you only have so much room on a slide
07:11:41 <shapr> The questions they ask have implied that they ignore the type signature and read the function definition to try to figure out what's being done.
07:11:45 <Athas> sproingie: type inference was invented so you could fit more code into a paper!
07:11:51 <shapr> ha, I like it!
07:12:15 <sproingie> @quote Athas type inference was invented so you could fit more code into a paper
07:12:15 <lambdabot> No quotes match. Whoa.
07:12:21 <sproingie> @remember Athas type inference was invented so you could fit more code into a paper
07:12:21 <lambdabot> Done.
07:12:24 <shapr> yay!
07:14:35 <locallycompact> mmx_, I would say firstly your 'IDatabase' whatsit should be a typeclass that extends Monad
07:14:45 <locallycompact> (probably)
07:15:08 <locallycompact> actually, extends MonadIO
07:15:45 <locallycompact> mmx_, here's something that might look a bit similar https://hackage.haskell.org/package/selda-0.1.9.0/docs/Database-Selda.html#t:MonadSelda
07:16:14 <sproingie> as for selecting specific drivers based on user input at runtime, i'm thinking maybe ReaderT IO
07:17:14 * hackagebot simple-logging 0.2.0.1 – Logging effect to plug into the simple-effects framework – https://hackage.haskell.org/package/simple-logging
07:18:11 <sproingie> er "ReaderT DatabaseDriver IO ()" in full.  or maybe just "String -> IO DatabaseDriver"
07:18:27 <sproingie> depends how much DI you need i guess
07:19:50 * sproingie should stop typing to others til he stops confusing himself
07:27:33 <lambdamu> Can someone write a function like this: Monad m => (m.. a0 -> m.. a1 -> .. -> m.. r) -> m a0 -> m a1 -> .. -> m r
07:27:41 <mmx_> Hmm I'm always on the verge of (not) getting monads ;) .. does everything need to be a monad? It feels like a wall of complexity I can't get through
07:28:00 <lambdamu> where m.. is zero or more m that is e.g. m (m a) or just a
07:28:27 <mnoonan> mmx_: you could just have an IDatabase record that consists of the functions needed to interact with the DB, and your factory just returns one of those based on the user input
07:29:07 <sproingie> not everything needs to be monads.  in fact, too many things are monads.
07:31:38 <mmx_> mnoonan: that would be the OOP way (right?), which (somehow) makes perfect sense, but is also not the FP way if I understand every OOP vs FP article on the web correctly (yes I've read them all ;)
07:33:05 <mnoonan> mmx_: It's kind of like emulating OOP in some ways, but it's more flexible. You just have a normal datatype full of functions, which you can then manipulate freely
07:33:30 <mnoonan> e.g. writing a function "withLogger :: IDatabase -> IDatabase" that takes each of those functions and wraps logging around it
07:33:33 <hanna> The defining property of OOP for me is subtyping relationships
07:33:39 <sproingie> OOP isn't completely inimical to FP, it's trying to recreate OO type systems in functional languages that gets you
07:34:43 <hanna> emulating OOP, to me, involves simulating subtyping / inheritance
07:35:01 <hanna> anything else I wouldn't describe as OOP - in fact using a collection of functions to define your things is a *very* functional way of doing things
07:35:03 <sproingie> thus the whole existential type class antipattern
07:35:10 <hanna> yes
07:35:56 <sproingie> ... for which i've never found an adequate alternative offered for non-trivial examples.  different gripe.
07:36:03 <hanna> instead of forall t. Thing (t, t -> Foo, t -> Bar, t -> Bat, String -> t -> t) you can just use data Thing = (Foo, Bar, Bat, String -> Thing)
07:36:11 <hanna> (hand-waving the syntax a bit)
07:37:07 <hanna> existential types are useful when the things you want to “pack” in them are type classes
07:37:21 <hanna> if only so you can avoid the boilerplate of having to enumerate the type class
07:37:26 <hanna> that's what it boils down to for me
07:37:32 <sproingie> for the Drawable example i guess one could look at how gloss does it.  not sure what gloss does actually.
07:37:51 <mmx_> Yes see this is where I get confused.. I agree with OOP = subtyping i.e. using an interface that can have any hidden implementation, plus passing that as behaviour (like a record of functions). But then sproingie mentions it's an antipattern :(
07:37:54 <hanna> gloss IMO captures the sheer essence of a functional API
07:38:59 <hanna> runThing :: s -> (Input -> s -> s) -> (s -> Output) -> (TimeDelta -> s -> s) -> IO ()
07:39:16 <hanna> ‘s’ is whatever state you want it to be
07:39:45 <hanna> the parametric polymorphism makes it very clear to you what's being done and when, while also allowing you to use whatever internal representation you want
07:39:52 <sproingie> mmx_: using a record of functions isn't the antipattern, it's using primarily type classes to achieve the effect
07:39:56 <hanna> or rather: the parametric polymorphism makes it clear what gloss *isn't* doing
07:40:04 <sproingie> the record of functions is in fact the alternative to typeclass abuse
07:41:00 <hanna> type classes are useful when your set of values and the set of interfaces they implement are very unsystematic
07:41:21 <hanna> if you only have one interface or only one value, you don't need type classes
07:41:26 <sproingie> weirdly i was told it's the opposite, you use them when you have a proper algebra of types
07:41:53 <sproingie> thus why stuff like Monoid is ok, Drawable and other *-able stuff is a smell
07:43:05 <hanna> in the case of Drawable, the issue is that you only have one instance: drawing the thing
07:43:08 <hanna> interface*
07:43:33 <sproingie> yeah, when there's only one operation, the class is pointless
07:43:35 <hanna> although you can also use e.g. a record of Maybe functions
07:43:47 <hanna> sproingie: rather: when there's only one relevant class
07:43:59 <Gurkenglas> How hard would it be to write a version of memoize that uses cache strategies to save on space?
07:44:10 <sproingie> hanna: hm yah that's better phrasing
07:44:35 <hanna> type classes are also useful when the set of interfaces something implements needs to be statically known
07:44:43 <hanna> for example if you want to prevent draw InvisibleWidget
07:45:02 <hanna> whereas doing e.g. invisibleWidget = Widget { draw = Nothing } that would be forced to be a runtime error
07:45:22 <hanna> of course for widget specifically you can also use { draw = return () } :p
07:45:40 <hanna> I don't really like the `widget` examples anyway
07:45:46 <hanna> people have too different ideas of what a widget is and what it needs to be
07:45:50 <hanna> and do
07:45:59 <hanna> that probably depends highly on what kind of UI you're actually designing
07:46:09 <sproingie> one could reasonably want a widget system with invisible widgets in one context and forbidding them in another
07:46:27 <sproingie> type classes would fulfill that nicely
07:47:45 <sproingie> (the reverse is what comes to mind actually, invisible widgets only containing other invisibles)
07:48:49 <freeside> i would like a set of all widgets which are not members of themselves, please
07:49:38 <sproingie> instance Invisible PinkUnicorn
07:50:24 <hanna> https://github.com/vimus/vimus/blob/4a127f469d989757dc00742175cb21394e0c747a/src/Vimus/Type.hs good old widget existential :D
07:50:31 <hanna> classic example
07:51:21 <sproingie> has this resulted in real problems?
07:51:53 <hanna> I don't remember
07:52:20 <hanna> probably just more code being written than necessary
07:52:24 <hanna> the code being less portable than necessary
07:52:32 <sproingie> i get a *sense* of why AnyFooable is bad, but if something's called an antipattern, it really needs motivating reasons.  or de-motivating as the case may be
07:52:39 <hanna> and it probably being slower than necessary, but I'll withhold judgement on that
07:53:02 <hanna> well the de-motivating reason is pretty much just that it's more cumbersome to work with, that's about it, I think
07:53:29 <Athas> At some point, passing around dictionaries explicitly is just easier.
07:53:40 <hanna> also facilitates un-code-sharing, since you can easily reuse “factories” for common primitives if you have a generic record of functions whereas doing the same with a class requires more boilerplate
07:53:43 <Athas> Doesn't require as many language extensions and is conceptually simpler.
07:54:05 <hanna> obviously it works
07:54:09 <hanna> and compiles in code that runs
07:54:22 <hanna> and is strictly equivalent in power
07:57:05 <sproingie> flexibility seems a compelling argument, you can create new widget types without needing a new class
07:57:46 <sproingie> then again that's not so good if you need to enforce invariants (one of the motivating reasons for OOP classes)
07:58:46 * hackagebot universum 0.5 – Custom prelude used in Serokell – https://hackage.haskell.org/package/universum
08:00:59 <hanna> sproingie: another problem that commonly comes up is the extension problem
08:01:20 <hanna> using a record of operations makes it difficult to add new operations, but easy to add new widgets
08:01:29 <Tuplanolla> Expression problem, no?
08:01:36 <hanna> oh, probably
08:02:06 <hanna> using an ADT of widgets makes it easy to add new operations, but difficult to add new widgets
08:02:18 <hanna> and there are some approaches that address both, but in haskell none really feel nice
08:02:51 <hanna> type classes and data types are both open classes though
08:03:28 <hanna> so if you have data TextWidget; data LineWidget and data ImageWidget plus class Renderable, class Clickable etc. as your primitive operations, you can extend in both directions
08:04:00 <hanna> the problem is that collapsing this down to an existential requires closing the set of classes you quantify over
08:04:21 <hanna> and not collapsing it down to an existential makes it difficult to deal with arbitrary widgets in a polymorphic way (e.g. storing them somewhere)
08:04:28 <sproingie> which would seem to be the opposite of the intent of making AnyRenderable
08:05:36 <mmx_> I thought type classes where a kind of solution to the expression problem.. which in my mind probably mostly works with parametric polymorphism where you get the keep the concrete types. But when passing an interface (or dictionary), you know nothing except the interface, so you lose the concrete type, including all other type classes or interfaces it may implement
08:06:17 <sproingie> i guess i'm just irked over the whole issue after learning Elm, which discards type classes and offers *nothing* as an alternative
08:06:53 <sproingie> records were almost a solution but it doesn't make it
08:06:55 <hanna> oh yes, elm, the language of no website
08:07:25 <sproingie> elm-lang.org?  or do you mean running no sites?
08:07:41 <hanna> use Ur instead :D
08:07:46 <hanna> sproingie: yes, elm-lang.org is a blank page here
08:08:01 <sproingie> renders fine for me.  your browser done borked
08:08:07 <hanna> try disabling javascript
08:08:18 <sproingie> well duh.  purescript won't work too well either.
08:08:34 <hanna> the point is that elm needs javascript to render _any_ content, even plain old text pages
08:08:55 <hanna> that in itself is an antipattern and if it's a fundamental design goal of a website DSL it can safely be discarded IMHO
08:09:37 <sproingie> that's hardly elm's most egregious fault though
08:11:02 <hanna> fortunately, it statically prevents me from having to learn about any of its others :)
08:11:37 <hanna> On the other hand, it generates some fantastically efficient websites! My browser renders them with extremely low overhead
08:11:46 <sproingie> well, i'd say you're confusing the language with the library, but not much difference in elm
08:12:00 <hanna> fair enough, although I consider elm a DSL
08:12:11 <hanna> and therefore the integration forms part of the language
08:12:49 <hanna> (just like I also consider the implementation part of the language for languages with only one relevant implementation)
08:13:33 <sproingie> someone should fork elm and call it PINE.  may as well recycle whole series of software names :)
08:13:48 <Athas> Wow, you're not kidding, the only child of <body> on elm-lang.org is a <script> tag.
08:14:02 <ystael> "Ur: because web programming wasn't hard enough yet"
08:14:12 <sproingie> which you'll find is similar for sites running on react or angular
08:15:43 <Athas> I guess it is not a problem for "web applications", but the Elm website is more of a document.
08:15:59 <sproingie> someone should have at least written up a <noscript> to show *something*
08:17:17 <Boomerang> I think they are working on some kind of server side rendering for Elm, so maybe you won't have an empty page in the future when you disable javascript (they are still in alpha releases of their compiler)
08:17:59 <sproingie> so yeah on one hand i think web apps take a step back in terms of content presentation, but on another, i don't see why the hardwired browser implementation should be the only game in town
08:22:27 <colonelj> not this whole "I don't have javascript enabled and I can't see anything" crap again, I had this on another channel
08:22:56 <freeside> i think it is a fair assumption that if you are planning to learn Elm you do not have ideological objections to javascript
08:23:02 <colonelj> <noscript>Enable Javascript to use this website, you plonker.</noscript>
08:23:21 <hanna> to which the correct reaction is to close the tab
08:23:22 <colonelj> I don't know if I'm using noscript correctly, I'm no web developer
08:23:54 <hpc> whenever i see those, i read it as <noscript>i don't know how browsers work</noscript>
08:24:08 <hanna> <noscript>I oppose the free web</noscript>
08:24:10 <hanna> anyway offtopic
08:24:53 <colonelj> well it's related to haskell spin-offs of elm and purescript particularly
08:26:15 <ph88^> how do i get a percentage of Just in a list of [Maybe a] ?
08:26:30 <hanna> using a fold
08:26:44 <ph88^> oh ok, thought maybe there was some applicative
08:26:51 <hanna> there is an applicative Fold
08:27:39 <tdammers> the naive solution is to count the Justs and count all items, divide one by the other and multiply by 100
08:28:25 <hanna> That's also an antipattern
08:28:34 <hanna> sum list / length list
08:28:41 <hanna> this breaks streaming
08:28:45 <tdammers> correct
08:28:48 <tdammers> hence, "naive"
08:29:22 <colonelj> hanna: what's the correct way to do it =/
08:29:26 <colonelj> I did that in my code
08:29:33 <hanna> colonelj: using a fold :)
08:29:41 <colonelj> how do you get the length as well
08:29:50 <sproingie> use a running average
08:29:59 <colonelj> wait I was using Data.Vector and friends length, isn't that O(1)
08:30:22 <tdammers> you write a fold where you accumulate two values in tandem: one of them increments by 1 unconditionally, the other increments only on Just
08:30:31 <colonelj> yea that's kinda tedious
08:30:38 <sproingie> my brane isn't working enough to remember how to write a running average.  or yah could pass around an accumulator.
08:30:56 <tdammers> that *is* how you write a running average
08:31:06 <colonelj> yeah :[
08:31:07 <hanna> goodAvg xs = s / l where (s, l) = foldr (\(s,l) x -> (s+x, l)) (0,0) xs -- this would be the naive way of doing it with a fold
08:31:22 <hanna> but there are also libraries that can help make this composable
08:31:29 <ph88^> if you have Data.Vector it should be faster to do   sum vec / length vec
08:31:40 <colonelj> of course
08:32:03 <tdammers> don't think it'll be faster; you still have to traverse the vector for summing
08:32:09 <tdammers> so it's probably about the same
08:32:40 <hanna> Vectors already break streaming (apart from streaming Vector -> Vector updates, of course)
08:32:55 <freeside> sum vec / length vec -- #ForFutureOptimization
08:33:05 <colonelj> yeah it's purely an optimization
08:33:14 <hanna> there are packages like http://hackage.haskell.org/package/foldl-1.3.0
08:33:19 <colonelj> though you should just write "average vec" probably
08:34:16 <colonelj> ok "mean vec" whatever
08:34:31 <hanna> with this you could write goodAvg = fold $ do s <- F.sum; l <- F.length; return (s / fromIntegral l)
08:34:38 <hanna> or something like that at any rate
08:34:50 <hanna> (which of course has a definition - F.mean)
08:36:48 <dmj`> does stackage have an IRC?
08:36:57 <dmj`> channel
08:37:13 <colonelj> it does now
08:37:53 <mmx_> Thanks for the discussion guys.. so I guess the underlying 'problem' of factory functions is actually the expression-problem (which may be the reason I haven't seen any such use in articles about haskell)
08:38:07 <srhb> dmj`: Stack does, #haskell-stack, I imagine that's an appropriate place for Stackage things as well
08:38:09 <mmx_> Now i have to go cook dinner
08:38:30 <freeside> http://koerbitz.me/posts/Solving-the-Expression-Problem-in-Haskell-and-Java.html
08:38:44 <dmj`> srhb: ah, perfect, thanks
08:38:59 <colonelj> mmx_: what's wrong with factory functions... I made a factory function in a record
08:39:36 <hanna> in ph88^'s case you could replace F.sum by premap (\case Just _ -> 1; Nothing -> 0) F.sum
08:40:54 <sproingie> colonelj: i don't think he's referring to them as being the problem per se, but the problem of using them or not
08:41:37 <mmx_> colonelj: not so much wrong, but it seems FP/haskell is more centered around parametric polymorphism instead of existensials (record of functions)
08:42:05 <colonelj> oh yeah it doesn't let you have impredicative polymorphism
08:42:22 <sproingie> does in some cases but i'm told it's broken
08:42:40 <mmx_> but if I understand correctly, that means you always need to know the concrete type, which factories deliberately want to hide
08:42:49 <hanna> the expression problem has an even more elegant solution in haskell with GADTs
08:42:58 <colonelj> can't you feed the type at the top level and have a typeclass context on it?
08:43:19 <hanna> where you can constraint the types of your expressions
08:43:48 <colonelj> oh yeah you need to use GADTs to get it to work
08:44:16 <sproingie> the set of GADT constructors is closed though
08:44:19 <hanna> hmm actually the traditional way of doing that violates the operation extension part
08:44:23 <sproingie> ye olde expression problem again
08:44:33 <hanna> err the data type extension part*
08:44:53 <colonelj> how, you can make more instances of the typeclass?
08:45:02 <sproingie> i'm running into this design problem with my experiments in pathfinder/D20 rules in haskell
08:45:34 <sproingie> i should probably be committing git branches with my aborted experiments rather than rolling them back
08:46:03 <hanna> I'm referring to the design of doing data Expr (t :: *) where Lit :: a -> Expr a; Ap :: Expr (a -> b) -> Expr a -> Expr b; Print :: Expr String -> Expr () 
08:46:15 <hanna> but this requires a central `Expr` type
08:46:52 <sproingie> right, and you don't get to add constructors.  though for that case, you probably don't need more
08:47:11 <sproingie> widgets are a more motivating example for extensibility
08:47:29 <hanna> you could do uh
08:47:52 <sproingie> if you can boil down widgets to a closed set of primitives however...
08:47:54 <hanna> data Lit a = Lit a;  data Add l r = Add (l Int) (r Int); data Print s = Print (s String)
08:47:56 <hanna> maybe that would work?
08:48:38 <hanna> Breaks down for `Ap` though
08:50:04 <hanna> I guess in this example it would have to be data Add x y r where Add :: x Int -> y Int -> Add x y Int
08:50:05 <sproingie> when i do OOP, i end up writing Actors.  when i do FP, i end up writing DSLs
08:50:50 <sproingie> next obvious step is actors speaking a DSL to each other :)
08:51:04 <sproingie> (which i suppose is already the case but it's all ad hoc)
08:58:02 <Phyx-> grmp: we use windres to embed the manifest files we create, these manifest will be used for dynamic linking support as well, so make sure you don't replace but amend them when you add yours.
08:58:33 <Phyx-> grmp: there is a ticket files to allow users to easily specify extra manifest options to include, but I haven't had a thought about that yet
08:58:40 <Phyx-> filed*
08:59:14 <hanna> freeside: https://0x0.st/0gM.txt taadaa
08:59:18 <hanna> ported to type-safe GADTs
08:59:21 <hanna> surprisingly trivial
09:00:46 <hanna> although of course the downside of this approach is that the representation becomes part of the type signature
09:00:52 <hanna> which is a non-negligible downside
09:08:47 <grmp> \who
09:09:06 <grmp> oops
09:10:04 <moet> shot in the dark, but does anybody know how to convert a repa `Array U ...` to `Array F ...`?
09:10:37 <moet> does it require manual allocation of a foreign pointer buffer, copying the data, and then a ptr cast?
09:12:07 <hanna> moet: doesn't `copyP` do this sort of stuff?
09:13:17 <hanna> in fact looking at the details I'm pretty sure it does
09:14:09 <moet> hannah: oooh, it does appear to! thanks!
09:23:15 <fosskers> Am I crazy? Do we not have a  built-in binary-search tree type?
09:24:03 <sproingie> "built in"?  why whould it be?
09:24:04 <hanna> fosskers: Map k v
09:24:11 <hanna> Set v
09:24:43 <fosskers> `Map` doesn't quite do it for my use case
09:24:49 <sproingie> what is your use case?
09:24:53 <hanna> ^
09:26:53 <hanna> re: earlier expression problem, I think the reality of the situation is that you have to pick any two out of (extensible data, extensible operations, monomorphic representation)
09:27:14 <hanna> solving both extension axis requires giving up the use of consistent/simple type signatures
09:28:37 <fosskers> actually yeah, I'll have to roll something custom because I realize my traveral logic is fairly specific
09:28:45 <ski> ("monomorphic representation" ?)
09:28:54 <hanna> ski: “can be put in a list”
09:29:32 <hanna> I guess that's sort of inherent to the fact that putting something in a list requires agreeing on some common property
09:29:32 <mnoonan> Wadler proposed a solution to the expression problem in the same note where he defined the phrase, but I've never sat down to understand it.
09:29:53 <mnoonan> Does it hold water? I assume there is some problem with the proposed solution, since the Expression Problem lives on..
09:29:57 <mnoonan> http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt
09:30:56 <sproingie> for sticking in a list ... HLists perhaps?
09:31:19 <sproingie> sure throws out simple type signatures
09:31:59 <hanna> I guess in practice you can use existentials to abstract away the representation where you no longer care about it
09:32:36 <mizu_no_oto> fosskers: what kind of problem are you trying to solve?
09:33:36 <hanna> for example evalAll :: [exists rep. Eval rep => rep a] -> IO [a]
09:36:06 <sproingie> do dependent types offer any innovations in this area?
09:36:29 <ssarah> is there an easy way to read and write to stdout?
09:36:42 <ssarah> im trying to do hackerrank challenged in haskell instead of python
09:37:00 <ssarah> and that part is kind of hard compared to python
09:37:05 <sproingie> putStrLn and readLn?
09:37:10 <kadoban> ssarah: "interact", there's a Data.Text version you should likely use
09:37:40 <[exa]> ssarah: maybe define the way you would like it "easier"
09:38:54 <sproingie> if hackerrank lets you use haskell, i imagine it has limited IO operations, so you'd want to see what's actually usable
09:39:45 <sproingie> interact should probably work though
09:40:53 * hackagebot eventloop 0.8.2.5 – A different take on an IO system. Based on Amanda's IO loop, this eventloop… – https://hackage.haskell.org/package/eventloop
09:42:07 <iffraff> hi can someone point me to a room where people might discuss rxjs ( reactivex )
09:43:17 <sproingie>  /msg alis list *rxjs*
09:44:58 <ssarah> [exa], in python i just go x=input() and print(f(x))
09:45:19 <ssarah> that's pretty easy
09:45:48 <[exa]> ssarah: side effects of the program (which input() is) have to be contained in some structure that can describe the change
09:45:49 <sproingie> haskell demands a little more purity
09:45:57 <iffraff> sproingie: thank you for that command.  It doesn't return any, so I guess is there a more general functional programming group here?  
09:46:56 <ssarah> [exa] that stuff with the do 's ?
09:47:10 <[exa]> iffraff: actually chances are that there's no such thing for rxjs. Maybe ask in #javascript, I kindof guess that you actually want something more related to js than to functional programming
09:47:13 <sproingie> iffraff: for rxjs, #javascript would probably know.  FP in general, i don't think there's one
09:47:24 <bollu> I have a common pattern in my code where I iterate over the keys of a particular map
09:47:30 <bollu> can I give this a name with patternsynonyms?
09:47:34 <[exa]> ssarah: yeah kindof :] Lemme point you to some reading
09:47:46 <sproingie> i'm a little surprised there isn't a #rxjs
09:48:11 <iffraff> thanks, it's 1 in a 100 in js who are using it.  so it's pretty bleak.  thought I'd check though.
09:48:12 <bollu> if I have data Foo = { map :: Map Key Value, bar :: Bar}, can I have a pattern like usesKeysAndBar (FooWithKeys keys bar) = ..
09:48:15 <bollu> or something like that?
09:48:28 <[exa]> ssarah: this is good: http://learnyouahaskell.com/input-and-output
09:48:28 <bollu> I want to expose 2 "derived" record fields
09:48:32 <iffraff> there actually is one $reactivex but there's like 8 people in it
09:48:38 <sproingie> #angular probably could tell you rxjs stuff, afaik angular2 uses it
09:49:16 <[exa]> ssarah: anyway, a general method to convert a "normal" function to IO-capable (monadic) function is this:
09:49:44 <jared-w> You might have better luck on a gitter or some other more hipster-chat chatroom, actually. JS communities seem all about the hype stuff, so :p
09:49:52 <[exa]> let's say you have:  f x = some x (input!)
09:50:43 <lyxia> bollu: where are the values
09:50:48 <[exa]> ssarah: instead you explicitly tear out the input (to provide some ordering) and return the rest: f x = do  in <- readLn ; return (some x in)
09:50:58 <sproingie> oh yah slack or gitter would definitely have something
09:51:00 <bollu> lyxia which values?
09:51:13 <sproingie> gitter has an irc bridge but it's awful
09:51:42 <jared-w> I used it once; it sucked
09:51:53 <lyxia> bollu: FooWithKeys keys bar   <-  what happened to the "Value" part of the map
09:52:02 <sproingie> TBH part of it is irc's fault
09:52:13 <[exa]> ssarah: the "bad" thing is that your 'f' now needs to be monadized as well, so you must call it in the do block, and if you want its return value, you need to bind it using: retval <- f
09:53:32 <ssarah> damnit
09:53:37 <[exa]> ssarah: the point of the whole 'do' construction is to bring the ordering to the execution of operations, which you implicitly code in python using semicolons/newlines
09:53:54 <jared-w> Oh yeah, IRC is a piece of crud that's been showing its age for a long long time
09:54:04 <[exa]> ssarah: anyway, what's the challenge about?
09:54:14 <lyxia> bollu: http://lpaste.net/356705
09:54:20 <bollu> lyxia I don't care, I want to match only on the views
09:54:42 <bollu> lyxia right, but if my record has like, 10 other fields, I wanted access to the other 10
09:54:51 <bollu> lyxia which is annoying if I package it up into a tuple :]
09:55:04 <ssarah> oh, the challenges are usually easy, and i had to learn haskell in college, it's that it always seems easier to do in python
09:55:09 <ssarah> special the input output part
09:55:22 <bollu> lyxia so I don
09:55:22 <lyxia> bollu: just use a view pattern for the one field then
09:55:23 <ssarah> i thought i was doing something wrong
09:55:30 <sproingie> python has a very high whip-it-up factor
09:55:42 <bollu> lyxia can you show me an example where a function takes the keys and, say, the third member of the record?
09:56:00 <lyxia> bollu: Foo (Map.keys -> keys) bar bas bat bau bav baw bax bay baz
09:56:07 <[exa]> ssarah: the hidden functionality of semicolons is hard to forget right. :D
09:56:22 <sproingie> monads are overloadable semicolons :)
09:56:30 <bollu> lyxia ah, I see
09:56:38 <ssarah> [exa], yep
09:56:40 <bollu> lyxia hm
09:56:50 <[exa]> ssarah: anyway, using the above monadization and probably reading the link I posted I guess you can convert python to haskell easily
09:57:09 <bollu> lyxia can I say Foo { mapField = (Map.keys -> keys), bar=baralias, ... } ?
09:57:19 <bollu> lyxia I'd like to "record field match" with viewPatterns
09:57:20 <ReinH> Applicatives are overloadable semicolons. Monads are overloadable assignment. :)
09:57:39 <[exa]> ssarah: still a common way to solve this stuff is to read all the data first, save it to some tangible container (list?) and run some map/fold on that to get the result
09:57:41 <bollu> ReinH oh god, that's so disgusting that is actually makes sense
09:57:58 <ReinH> *> is semicolon with side-effects. >>= is assignment with side-effects.
09:58:09 <[exa]> ReinH: do you have a good name for >> ?
09:58:16 <[exa]> like, >>= is bind
09:58:17 <sproingie> "side effects"
09:58:47 <Cale> ReinH: What would semicolon without side effects be?
09:58:54 <lyxia> bollu: yes
09:58:56 <ReinH> Cale: boring.
09:58:59 <bollu> Cale ;;;
09:59:00 <Cale> I don't know if I like calling >>= "assignment"
09:59:01 <[exa]> and *> is now semicolon
09:59:01 <bollu> Cale :)
09:59:09 <ReinH> Cale: <-, really
09:59:09 <bollu> lyxia cool! thanks 
09:59:11 <sproingie> Cale: well, it is pronounced "bind", so ...
09:59:23 <Cale> Well, assignment normally *replaces* the contents of some location in memory
09:59:31 <ReinH> <- is = with side effects.
09:59:48 <ReinH> Or maybe :=
09:59:49 <Cale> Whereas <- will bind an entirely new variable.
09:59:59 <ReinH> Yes, that is one of the side effects :D
10:00:07 <Cale> Er...
10:00:07 <sproingie> or shadow an existing one
10:00:12 <ReinH> Joking.
10:00:21 <ReinH> Anyway, the point is that Applicative is enough for ;
10:00:25 <ReinH> Monad gives you <-
10:00:29 <Cale> Well, yeah, if a variable of the same name was in scope, it will be shadowed
10:00:38 <ReinH> Which is "thing that is like assignment but not really assignment" with side effects
10:00:51 <Cale> haha
10:00:55 <sproingie> the analogy starts to fall down with, say, the List monad
10:01:14 <ReinH> The side effect is that it takes on multiple values.
10:01:14 <sproingie> then <- is more like a loop
10:01:25 <[exa]> sproingie: prolog has semicolons as well :]
10:01:31 <sproingie> which yeah i suppose is effectful
10:01:44 <sproingie> depending what you do with it
10:02:09 <ReinH> fsvo "side effect", which is already how we're all using it anyway
10:02:27 <bollu> can we not always make it rigorous by bijecting the object at hand with the correct choice of free monad + suitable interpreter?
10:02:39 <sproingie> unsafePerformIO -- there's your side effects :)
10:03:09 <ReinH> An unsafePerformIO usage with observable side effects is a bug :)
10:04:14 <sproingie> unsafeLaunchMissiles
10:04:19 <hanna> I think I'd rather leap to describe monad as “overloadable control flow / code flow”, but that's all the monad-bikeshedding you'll get out of me
10:04:27 <jared-w> unsafePressTheRedButton
10:04:48 <jared-w> I think I'd describe monad as a monoid in the category of endofunctors /s
10:05:00 <sproingie> what's the problem?
10:05:36 <ReinH> I personally like to describe Monad as a typeclass with two members and three laws.
10:06:10 <ReinH> I am not quite sure whether I prefer those members to be pure and bind or pure and join. Or whether I prefer to describe Applicative first and borrow its pure.
10:06:32 <ReinH> It's also easier to describe the laws using >=> than >>=
10:07:27 <sproingie> pure and bind or fmap and join, right?
10:07:55 <sproingie> one intuition seems to work better for some monads, and the other for others
10:08:06 <ReinH> no, you need pure either way
10:08:13 <jared-w> the haskell book went for Applicative -> Monad for what it's worth
10:08:24 <ReinH> The usual CT definition is with pure and join, which I quite like.
10:08:55 <ReinH> jared-w: Yeah, if you have the time I prefer to start at the bottom of the lattice and work my way up
10:09:00 <jared-w> >=> is also commutative so the laws look super similar (if not practically identical) to applicative's
10:09:05 <sproingie> flatMap seems to be the standard way of looking at it in other languages
10:09:13 <ReinH> >=> is not commutative
10:09:18 <ReinH> >=> is associative
10:09:26 <jared-w> er, that's what I meant, m'bad
10:09:47 <ReinH> >=> and pure form a monoid, which gives Monad its laws.
10:10:01 <ReinH> so those laws are that >=> is associative and that pure is neutral wrt >=>
10:10:26 <Cale> It's possibly weird, but I actually prefer the name "return" to "pure"
10:10:39 <jared-w> Which feels much more elegant and neater to write than the traditional 3 laws
10:10:41 <sproingie> i'm not a great fan of either TBH
10:10:56 <jared-w> Cale: *cough* heretic
10:10:58 <Cale> At least so long as we're thinking of the values of type M t as computations producing results of type t
10:11:13 <Cale> return v is then just the action which... returns v
10:11:16 <sproingie> "yield" perhaps?
10:11:23 <ReinH> >>= is really just there for do notation
10:11:24 <jared-w> "compute"?
10:11:36 <ReinH> it is not a very elegant way to define a monad, at least conceptually
10:11:53 <Cale> I don't think it's that bad
10:11:58 <ReinH> Cale: Then by your own logic, it should be called produce. ;)
10:12:18 * sproingie jumps up and down.  "yield"!
10:12:23 <ReinH> It's often nice in practice, especially for the sort of computational monads we tend to use for... computing.
10:12:26 <ggVGc> are  humans monoids
10:12:45 <sproingie> depends on the category
10:12:50 <jared-w> ggVGc: no, there's no neutral identity you can combine with humans
10:12:54 <dolio> I'm not sure saying (>=>) and pure form a monoid is good enough.
10:13:04 <ReinH> dolio: what is missing?
10:13:04 <Cale> sproingie: That word already has a meaning elsewhere of emitting some result while remembering the place in the computation so that you can resume later where you left off.
10:13:11 <mnoonan> combining (me + you) + other gives a different genetic mix than me + (you + other)
10:13:16 <sproingie> Cale: "return" is similarly overloaded
10:13:24 <Cale> sproingie: If you use pipes, it defines a yield that has that meaning.
10:13:26 <dolio> ReinH: They form a category, not a monoid, and I don't think talking about the monoid is enough to recover the category.
10:13:48 <jared-w> dolio: technically, it's sufficient. It's like saying "a monad is a monid in the category of endofunctors"; it's a completely sufficient but entirely unilluminating definition unless one has the necessary background to understand it
10:13:55 <Cale> I suppose if we were starting from scratch, "yield" wouldn't be so bad either.
10:13:56 <ReinH> Right, if I want it to be a monoid then I should use the actual monoid, my bad
10:14:16 <jared-w> oh, that's what you were getting at, nvm
10:14:21 <ReinH> i.e., fmap join . join = join . fmap join
10:14:26 <dolio> jared-w: The 'monoid in the category of endofunctors' is not talking about (>=>) and pure.
10:14:28 <ReinH> or however you say it
10:14:52 <jared-w> dolio: yeah I got a wire or two crossed and misread what you were getting at, m'bad
10:14:53 <ReinH> (m . m) . m = m . (m . m)
10:15:02 <sproingie> >=> is still a useful intuition when thinking in composition, >>= if you like to think in terms of a pipeline
10:15:58 <ReinH> dolio: The Kleisli category is a free construction, right? So the category laws for >=> and return are implied by the Monad laws?
10:16:03 <Cale> Yeah, if you look at what a monoid in the category of sets is, it's a set M, which comes equipped with some special element of M, the identity, which we can regard as a function eta: 1 -> M (where 1 here is a one-element set), and a multiplication mu: M x M -> M
10:16:31 <ReinH> sproingie: >>= is application. It's often useful to think about computation, and it's often useful to think about application. Richard Bird talks about this.
10:16:48 <Cale> In the category of endofunctors, a monad is some endofunctor M equipped with some natural transformations eta: 1 -> M (where 1 is the identity functor), and mu: M . M -> M
10:17:18 <Cale> and if you write down the laws in terms of eta and mu, they're analogous
10:17:29 <sproingie> i should read more Bird.  spendy books tho.
10:17:30 <ReinH> dolio: I guess what I'm asking is: is proving the laws for the Kleisli category of M equivalent to proving that M is a monad?
10:17:45 <dolio> ReinH: Yes.
10:17:53 <ReinH> dolio: Ok, good, thanks.
10:18:41 <ReinH> Right, it's free M-algebras. That's what I was trying to get at above.
10:18:58 <dolio> I'm just not sure that works if you switch to monoids, which would be sections over a particular object.
10:19:12 <ReinH> No, no, my use of monoid there was just a mental typo.
10:19:16 <dolio> Oh, okay.
10:19:39 <ReinH> I meant to say the category laws for >=> and pure.
10:20:23 <sproingie> thinko
10:37:32 <jared-w> http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&lang=ghc&id=1 does anyone know why the haskell one is so slow compared to Java here?
10:38:08 <johnw> ReinH: alternatively, you can prove the laws for the Eilenberg-Moore category, whose objects are all M-Algebras
10:38:21 <sproingie> jared-w: laziness possibly
10:38:45 <jared-w> sproingie: a strict tree is required, with strict branches
10:39:01 <sproingie> ah, didn't see the bangs
10:41:33 <sproingie> being a gc benchmark, well, java does have some super nice gc
10:42:30 <jared-w> true, Java's GC is world class. I suppose it makes sense that Haskell's is twice as slow in that case
10:42:46 <sproingie> and haskell's gc was painfully bad not that long ago
10:42:59 <sproingie> so getting to 50% is not too shabby
10:43:00 <johnw> for a free, research GC, it's not half bad
10:43:17 <johnw> Java had a multitude of GCs available, each tuned for different areas (like real-time computing, etc)
10:43:21 <johnw> has*
10:43:25 <sproingie> still does
10:43:33 <jared-w> and they're improving the GC again in Java 9 by quite a bit
10:43:56 <johnw> when we pay the GHC team millions of dollars a year, I predict better performance :)
10:44:42 <jared-w> That and dense regions(?), linear types, and other goodies should help out as well
10:44:45 <Lokathor> http://lpaste.net/356706 so can someone tell me what the type of the inner do-block is?
10:45:00 <johnw> yes, I'm eager to play with the new linear types; installing 8.2-rc2 in another window as we speak
10:45:04 <cocreature> jared-w: dense regions?
10:45:11 <cocreature> johnw: linear types are not in 8.2-rc2
10:45:14 <Lokathor> because I'm using MonadRandom stuff, and ST stuff, all at the same time, and I'm foggy on what type GHC thinks I'm using
10:45:16 <sproingie> the benchmark could perhaps use compact regions?
10:45:16 <johnw> OH NOES!
10:45:26 <johnw> sorrow is mine
10:45:26 <jared-w> ahh, compact regions, that's what I meant
10:45:31 <cocreature> johnw: if we’re lucky we’ll get them in 8.4
10:45:50 <Lokathor> because i'm not explicitly calling lift at any point, is the confusing part
10:45:54 <johnw> way to ruin a haskellers day, take away a feature he was within minutes of using...
10:46:15 <cocreature> johnw: you just need to build the right branch instead of 8.2 :)
10:46:20 <johnw> ah, ok
10:46:31 <jared-w> There's a wip linear types branch iirc
10:46:34 <cocreature> johnw: https://github.com/tweag/ghc/tree/linear-types
10:46:57 <johnw> ok, i'll setup Nix to build yet another GHC environment based on that branch
10:47:20 <Cale> johnw: What are you doing with linear types?
10:47:28 <johnw> nothing yet
10:47:37 <cocreature> gotta build them all
10:48:01 <ssarah> can i run the main of files inside ghci? or do i have to use runghc file ?
10:48:09 <cocreature> ssarah: :main
10:48:23 <johnw> I'd like to use them to optimize when bytestring buffers can be reused, by knowing when sharing is not happening
10:48:58 <johnw> i.e., an append, with enough memory left in buffer 1, should feel free to just copy in the contents of buffer 2, since neither of the previous versions can be referenced again
10:49:44 <jared-w> Embedding resource knowledge into types is pretty nifty with the non-obvious optimizations you can make
10:49:50 <Cale> It'll be interesting to see how often we can actually get stuff like that to happen in real code.
10:50:02 <johnw> Cale: same here :)
10:50:19 <ssarah> cocreature, ty
10:50:23 <jared-w> A lot of Rust is slower than it "could" be because it has to do a lot of safety copying and moving around due to how its borrow checking is implemented
10:50:25 <johnw> if linear types makes this sort of optimizations easy to do, then huge win for optimizing certain immutable functional programs
10:51:10 <jared-w> "real" linear types in Rust could help a lot with that, but most linear type systems don't have a nice way of composing, iirc
10:51:20 <johnw> for a given function foo, even if the input is immutable, and the output is immutable, maybe the internal temporary bytestrings don't need to be at all
10:51:58 <johnw> using linear types with an internal-only helper function should then let me fuse away temporaries in an explicit fashion, even when GHC can't see it, without resorting to complex tricks
10:52:41 <johnw> at least, that's my hope
10:52:47 <jared-w> johnw: seems like a similar optimization to transactions in databases. Large "atomic" operations aren't really atomic, but can be treated as such. Hopefully that lets us play around with immutability in an even looser and still morally correct fashion :p
10:52:48 <lambdamu> Lokathor: It should be "RandT (ST s) g (Vector a)"
10:53:03 <johnw> I know how I'd do this in an explicit refinement architecture, where I can statically analyze data flows
10:53:17 <lambdamu> Lokathor: err "RandT g (ST s) (Vector a)"
10:53:18 <Lokathor> well I thought that, but the RandT constructor isn't public so... does GHC just not care?
10:53:19 <johnw> jared-w: yes!
10:53:19 <Cale> My main worry is with how far these linearity constraints end up propagating -- it might end up making things quite awkward.
10:53:39 <johnw> Cale: I would hope that users of 'foo' would be unaware of my use of linearity as an implementation strategy
10:53:51 <lambdamu> Lokathor: well runRandT can consume a RandT, no matter how it was constructed
10:54:05 <johnw> I just want to tell GHC: hey, once I pass 'temp1' to this function, i'll never use it again, promise
10:54:13 <jared-w> johnw: depending on the implementation, it'll leak out everywhere, which is unfortunate.
10:54:16 <Lokathor> Cale, Linear types will be released for GHC on October 31st and they'll propagate all the way ~to your graaaave~
10:54:25 <lambdamu> Lokathor: The RandT is a type, not a value constructor even if there is one with the same name
10:54:30 <Cale> Lokathor: exactly.
10:55:03 <johnw> now you guys make me want to build this branch just to demo for Cale... sniped!
10:55:22 <Lokathor> lambdamu, alright, I guess that makes sense in a way
10:55:48 <Cale> johnw: I suppose if the ByteStrings in question are entirely created and consumed locally, it might work out just fine.
10:56:17 <johnw> yes
10:56:32 <johnw> that's the only case I'm thinking of at the moment: internal temporaries
10:56:57 <jared-w> http://edsko.net/2017/01/08/linearity-in-haskell/ ahhh, this is what I was looking for. Has anyone read this?
10:57:01 <johnw> otherwise, I require my caller to prove to me that she never uses the input bytestring again, which will force linearity to propagate everywhere
10:58:01 * hackagebot onpartitions 0.1.0.0 – partition lenses – https://hackage.haskell.org/package/onpartitions
10:58:01 * hackagebot clash-multisignal 0.2.0.0 – <i>Added by ralu, Wed Jul 5 17:40:46 UTC 2017.</i> – https://hackage.haskell.org/package/clash-multisignal
10:59:00 <jle`> is there a nice bounded priority queue implementation anywhere
10:59:18 <sproingie> i hear "local temporaries" and my mind goes to ST.  does ghc do any specific optimizations around ST?
10:59:47 <Lokathor> it lets you actually overwrite old values, for one
11:00:12 <ReinH> johnw: yeah, the Kleisli category is the full subcategory of free algebras of the EM cat, right?
11:00:26 <jared-w> sproingie: I don't know if it does. The first immediate thing I can think of is how difficult it would be to optimize generically for anything you can do with ST
11:01:05 <johnw> ReinH: hmm.. not sure; where are the free algebras in Kleisli?
11:01:07 <lambdamu> Lokathor: Alternatively, you can think of the do block as (MonadRandom g m, PrimMonad m) => m (Vector a)
11:01:13 <jared-w> jle`: does this work? https://hackage.haskell.org/package/pqueue
11:01:43 <jle`> jared-w: it's not really optimized for bounded behavior, but i guess i could "take" the top n items after inserting them
11:01:47 <Lokathor> lambdamu, I was thinking more like that, but wasn't sure where the concrete type came from
11:02:01 <Lokathor> or if GHC could just frankestein together a type for me somehow, given enough instances
11:02:10 <Lokathor> i mean the code runs and all
11:02:13 <sproingie> -XFrankenTypes
11:04:01 <jared-w> If anything, there are way too many priority queue implementations on hackage...
11:05:14 <cocreature> jle`: last I checked psqueues was one of the better packages for priority queues but it doesn’t have specific support for bounded queues iirc
11:06:26 <lambdamu> Lokathor: runRandT needs a RandT g m a so it unifies to (MonadRandom g (RandT g m), PrimMonad (RandT g m)) => RandT g m a 
11:06:44 <jle`> hm can't seem to find any bounded functionality or a 'take'
11:06:45 <lambdamu> Lokathor: which works because of PrimMonad m => PrimMonad (RandT s m)
11:07:13 <lambdamu> Lokathor: and (RandomGen g, Monad m) => MonadRandom (RandT g m) of course
11:07:31 <jle`> maybe i can write my own insert
11:07:51 <Lokathor> lambdamu, excellent
11:08:59 <lambdamu> Lokathor: It also adds the constrain PrimMonad m to the context, which gets satisfied by runST
11:10:18 <jared-w> oooh so bounded just means it can have no more than x items in the queue. I was thinking something different. Yeah I'd just write my own insert in that case, jle`, unless you're going to be inserting a /ton/ and the overhead might be somewhat significent
11:11:41 <jle`> why is there a 'k' key type in psqueues?
11:13:17 <jared-w> Fast insertion, deletion and lookup is what the docs say  ¯\_(ツ)_/¯
11:13:52 <jle`> i suppose it's useful if you want to detect loops in a graph search maybe
11:14:05 <jared-w> There's also an IntPSQ p v where the key is already made for you with an int 
11:14:17 <jle`> yes but for that you have to generate unique Int's for every insert
11:15:25 <lambdamu> jle`: Otherwise you need a unique k, no?
11:15:32 <jared-w> for IntPSQ I don't think you do? You have a priority of type v, value of type v. There's no k anywhere
11:15:45 <jle`> jared-w: insert :: Int -> p -> v -> IntQueue p v
11:15:48 <jared-w> oh nvm I'm dumb
11:15:52 <jared-w> I was looking for k not Int
11:15:53 <jle`> lambdamu: yeah, just saying that you can't ignore the key
11:16:38 <jared-w> HashPSQ is like the int one but uses any hashable datatype as the key.
11:19:12 <jared-w> Although, I must confess, I find it odd that the haskell psqueues require a key
11:20:11 <dmwit> Surely if there's no key it's just a pqueue.
11:20:15 <geekosaur> ^
11:20:23 <jared-w> https://www.cs.ox.ac.uk/ralf.hinze/publications/ICFP01.pdf this is the paper everything in the library is based on  ¯\_(ツ)_/¯
11:20:33 <geekosaur> the key *might* be the same as the priority, but might not
11:21:14 <jared-w> ahh, right. The search part necessitates the key, gotcha.
11:21:22 <jle`> psqueues has both a key, a priority, and a value
11:21:34 <dmwit> e.g. psqueues often support an operation to insert a key it already knows with a new priority, and will overwrite the old priority if the new one is higher.
11:22:26 <jle`> so it's basically like a Map k (p, v), except with the ability to pop the minimum 'p'
11:22:38 <geekosaur> yes
11:22:38 <dmwit> For example, in a graph search algorithm, you might find a new, better (=lower priority) path (=value) to get to a node you've already found (=key).
11:22:55 <jared-w> gotcha, makes sense. And you need just a bounded priority queue, jle`? So would that library work for you then?
11:23:08 <jle`> it doesn't have any support for bounded inserts/merges
11:23:18 <geekosaur> another example is that a psqueue is the correct way to implement something like linux nscd (priority = timestamp, key = host/user/...-name)
11:23:33 <jle`> ah, yes
11:23:43 <jle`> oh yeah, the 's' stands for search
11:23:46 <jle`> ofc
11:24:46 <dmwit> jle`: Stupid question: can you not build bounded insertion on top of the existing primitives?
11:24:56 <dmwit> e.g. insert, check size, if too large pop one bad-priority item?
11:25:40 <dmwit> Ah, these don't support popping both a bad-priority and a good-priority item.
11:25:44 <dmwit> Okay. =)
11:26:45 <jared-w> I mean, you can, but your insert will have a check conditional, grab the size, drop, and insert. You're potentially doing like 2-3 things in a single insert. It depends on how often you need to insert
11:26:48 <dmwit> If you don't need the "search" part, I'd be tempted to suggest `Data.Map`. It does offer `minView` and `maxView`.
11:26:59 <jared-w> dmwit: the Ord one has a deleteMin
11:27:11 <ReinH> johnw: all of them
11:27:27 <ReinH> it is the EM category restricted to those algebras which are free
11:28:00 <dmwit> jared-w: It needs both deleteMin and deleteMax to be useful in the way I suggested. (deleteMin for dropping stuff during insertion; deleteMax for using stuff when you're ready to consume elements from the queue; or vice versa)
11:28:09 <jared-w> although I would probably benchmark deleting + inserting with the alterMin function (which changes the element with minimum priority to an entirely new element
11:28:20 <ReinH> From nlab, "Given a monad T on some category 𝒞, then its Kleisli category is the full subcategory of the Eilenberg–Moore category of T, hence the category of T-algebras, on those that are free T-algebras (free T T-modules)."
11:28:30 <johnw> excellent
11:28:35 <ReinH> s/T T-modules/T-modules
11:28:36 <johnw> nlab is your friend
11:28:44 <ReinH> Sometimes.
11:28:53 <johnw> I have a local mirror, if you want
11:28:54 <merijn> johnw: That very, very confusing friend who tends to ramble at times...
11:28:57 <ReinH> But sometimes I can read the page for a concept I already think I know and be totally confused.
11:29:14 <johnw> merijn: lol
11:31:14 <jle`> dmwit: huh that might work
11:31:41 <jared-w> jle`: I can't find a way to get a max priority item out of the queu, though
11:31:51 <johnw> I also found a plugin for Firefox that renders MathML locally, making nlab pages nice and readable fully offline
11:32:04 <jle`> well a `Map k v` can be used as a priority queue with both minvew and maxview
11:32:33 <merijn> hmm, I forgot, was there a name for "foldr (<|>) empty"?
11:32:34 <jared-w> Yeah I'd probably just use Map since you don't need the searching
11:32:44 <dmwit> :t asum
11:32:46 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
11:32:49 <merijn> dmwit: Cheers
11:33:04 <jared-w> :t foldr (<|>) empty
11:33:05 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
11:33:12 <jared-w> neat
11:33:31 <jared-w> now if only there was a way to search by the type of something... :p
11:33:32 <johnw> @src asum
11:33:32 <lambdabot> Source not found. Wrong!  You cheating scum!
11:33:42 <jared-w> shh, lambdabot, it ok
11:34:00 <dmwit> ?. hoogle type foldr (<|>) empty
11:34:02 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
11:34:02 <lambdabot> CorePrelude asum :: (Foldable t, Alternative f) => t (f a) -> f a
11:34:02 <lambdabot> Control.Applicative.Alternative asum :: (Foldable t, Alternative f) => t (f a) -> f a
11:34:07 <dmwit> yay
11:34:27 <jared-w> the alpha version of hoogle needs to hurry up with the type search :(
11:39:34 <guest223> :t putStrLn
11:39:36 <lambdabot> String -> IO ()
11:42:02 <cocreature> jared-w: it actually finds asum http://hoogle.haskell.org/?hoogle=(Foldable%20t%2C%20Alternative%20f)%20%3D%3E%20t%20(f%20a)%20-%3E%20f%20a :)
11:45:19 <ReinH> johnw: Oh, cool.
11:48:40 <merijn> Is there a convenient total Map somewhere?
11:49:01 <merijn> Or maybe I should just use Map and !....
11:49:12 <johnw> https://hackage.haskell.org/package/total-map?
11:49:28 <johnw> I totally didn't just submit your question to Google...
11:49:33 <freeside> haha
11:49:42 <cocreature> who would do such a thing, that’s absurd
11:49:53 <merijn> johnw: Yeah, I just realised that ! in Map is probably just as good and I already need containers anyway
11:55:34 <merijn> Incidentally, it's amazing how you don't appreciate your tooling until you break it...
11:55:54 * johnw runs off to break his tooling so that he'll appreciate it more
11:56:35 <merijn> johnw: I switched to cabal new-build, only to learn that hdevtools doesn't work with it yet. So I've taken it upon myself to fix hdevtools, however I have to do so without hdevtools because, well, it's broken >.>
11:56:48 <merijn> And it's an utter pain in the ass...I wonder how I ever wrote Haskell in the past...
11:57:23 <johnw> I gave up on keeping hdevtools working long, long ago
11:57:37 <johnw> now I just use GHC as my syntax checker, and it's fast enough
11:57:38 <Athas> I haven't heard about hdevtools before.
11:57:38 <merijn> johnw: I realised I can actually make it a lot simpler
11:57:56 <johnw> Athas: keeps a compiler resident so that syntax checking is blindingly fast
11:57:57 <merijn> johnw: But GHC isn't as easy to autorun
11:58:12 <johnw> merijn: i do it through Emacs, flycheck
11:58:25 <Athas> johnw: literally only syntax checking, or also type checking?
11:58:31 <merijn> johnw: I use syntastic in vim, which integrates nicely with hdevtools, not to mention I can query types
11:58:33 <johnw> both
11:58:36 <Athas> I use intero, which runs ghci in the background.  It is pretty resource-intensive.
11:58:40 <merijn> Athas: Type checking + querying the type of an expression
11:58:55 <Athas> How can it be faster than having ghci in the background?
11:58:58 <merijn> johnw: But yeah, the source is a mess
11:59:07 <merijn> Athas: I suspect it's pretty much the same
11:59:16 <merijn> Athas: However, I don't know any vim plugins that work via ghci
11:59:24 <Athas> I wish ghci wasn't ridiculously memory-intensive...
11:59:39 <Athas> Oh, right.  I use intero for Emacs - everything Just Works.
11:59:55 <Athas> It is so nice not to have to fiddle with everything anymore.
11:59:56 <freeside> how long did it take to get intero Just Working?
12:00:13 <freeside> trying to estimate how big a pile of yak fur to expect
12:00:33 <merijn> Athas: Well, hdevtools has been working for like 2+ years for me, until I had to go and switch to cabal HEAD and new-build :p
12:00:43 <jared-w> Well intero just worked for me without any nonsense
12:01:01 <Athas> freeside: five minutes or so, but that was all disabling my previous haskell-mode cruft.
12:01:04 <jared-w> The only thing I had to muck around with was adding a line of code to my emacs stuff to make intero also load up HLint
12:01:20 <freeside> gosh, i will try that.
12:01:27 <Athas> I think intero is strongly tied to stack, though.
12:01:30 <jared-w> Is there anything hdevtools does that intero + HLint doesn't?
12:01:48 <Athas> Although intero also works fine when I just open a random .hs file somewhere for experiments.
12:01:53 <merijn> jared-w: Work with vim :p
12:01:54 <jared-w> Athas: intero requires stack. You probably "can" get it working, but why would you put yourself through that kinda suffering. Look into Dante
12:02:24 <Athas> jared-w: totally agreed; Stack is the best thing to happen to Haskell since multi-parameter type classes.  But I know some people still prefer Cabal.
12:02:29 <jared-w> merijn: I use spacemacs :p I loved vim for a long long time but org mode finally won me over. I still keep a solid neovim setup though
12:03:00 <jared-w> Athas: Dante is a Stack clone that works with cabal as well. It's packaged inside of spacemacs's haskell layer as an alternative to intero. Pretty seamless to switch between them I believe
12:03:04 <merijn> jared-w: neovim and spacemacs are both no gos, since I can't reliably use either everywhere
12:03:46 <jared-w> merijn: Why do you need to use them "everywhere"? For me, neovim is what I use everywhere because my nvimrc is close enough to a vimrc that I can just if/else any incompatibilities and plugins if I really cared enough
12:04:02 <merijn> jared-w: Because I frequently test and develop on machines that are not my desktop
12:04:09 * shapr hops cheerfully
12:04:10 <Athas> merijn works in some kind of dystopic cluster environment.
12:04:29 <shapr> Have I mentioned how much I enjoy using conal's checkers package?
12:04:52 <jared-w> shapr: Is that the package for using quickCheck? I love it
12:04:53 <johnw> shapr: nice, hadn't heard of it
12:05:03 <simendsjo> /
12:05:45 <jared-w> I got introduced to it in the haskell book and it blew my mind. Two lines of code to automatically test that you wrote an implementation of something correctly? (within checking reason) damn nice
12:06:38 <shapr> jared-w: yeah, it's great!
12:08:13 <mnoonan> Athas: do you also edit C++? I have some weird problem with Intero across several emacs versions, where the whole session locks up if I open a .cpp/.hpp file.
12:09:14 <Athas> mnoonan: can't say I've noticed that, but I rarely open .cpp files.
12:10:07 <mnoonan> it may well be intero + something else being the problem, but I've only figured out the intero half of the blame.
12:21:41 <jared-w> Hmm...
12:22:03 <jared-w> So, is haskell gonna get first class modules?
12:24:51 <c_wraith> sort of. it's getting a backpack, which has a similar use case. 
12:25:35 <cocreature> I’m not sure I’d call backpack first class
12:28:22 <c_wraith> ok, it has some similar use cases 
12:29:22 <cocreature> depending on your definition of “first class” there are very few languages with first class module systems
12:29:44 <cocreature> there is 1ml but apart from that I can’t recall any
12:33:32 <dolio> I think OCaml has something they call first class modules now.
12:35:15 <jared-w> Yeah I've been looking more at backpack. I think it'll probably be fine for haskell, or at least a very solid stepping stone
12:36:13 <Tuplanolla> How first-class are we talking about, dolio?
12:37:01 <dolio> Tuplanolla: I don't know. I haven't looked at the feature myself. But I think it's related to their implementation of GADTs.
12:37:26 <dolio> I.E. a GADT is a type that contains a module with an equality in it, or something.
12:37:29 <Tuplanolla> I've always wanted to see how it should be done, but not enough to study a language in depth with the risk of being disappointed, dolio.
12:38:09 <dfeuer> dolio: does https://github.com/haskell/vector/issues/178 look sensible enough to pursue?
12:40:04 <jared-w> Tuplanolla: True first class modules are in SML
12:40:34 <jared-w> I think OCaml's module system is either as first class as SML or very close
12:40:56 <Tuplanolla> Where can I find an explanation that doesn't assume I already know all of OCaml, jared-w?
12:40:57 <dolio> SML is not first class modules.
12:41:04 <jared-w> Really?
12:41:08 <dfeuer> IIRC, MOSML has first-class modules.
12:41:13 <Tuplanolla> When I tried to put first-class modules into my own toy language, dependency checking became undecidable, file path searching became exponential and I became agitated.
12:41:15 <dfeuer> But I don't know if that's still around.
12:41:42 <dfeuer> Does Racket have first-class modules?
12:41:45 <jared-w> https://existentialtype.wordpress.com/2011/04/16/modules-matter-most/
12:41:54 <dolio> The 'first class' part is usually used to mean that modules are values of the language.
12:42:27 <dolio> In SML, the modules are like a meta system around the types and values of the language.
12:42:53 <jared-w> ahh right, they're not perfectly first class, but rather they have a module meta language
12:43:29 <Tuplanolla> That sounds like a disgusting compromise to me, jared-w.
12:43:32 <dolio> I think Alice also had first class modules.
12:44:07 <jared-w> OCaml certainly claims to have first class modules
12:44:17 <dolio> Because the whole gimmick of that language was that you could deserialize a module from the network, I believe.
12:44:59 <jared-w> https://stackoverflow.com/questions/15584848/whats-the-difference-if-any-between-standard-mls-module-system-and-ocaml-mod
12:45:22 <jared-w> According to this: Moscow ML and Alice ML are the two SML implementations with first class modules
12:45:51 <jared-w> Moscow ML is the only one with recursive modules, however; both MOML and AML have nested signatures, higher order functors, and module sharing
12:47:36 <dolio> dfeuer: If you can verify that it seems to work sensibly, I'm fine with adding the instance.
12:47:59 <jared-w> https://people.mpi-sws.org/~dreyer/courses/modules/f-ing.pdf I think this is likely pretty approachable? Haven't read it yet, but the abstract says it's simple :p
12:48:12 <dolio> The Alice use case is kind of why you'd want them in Haskell, as well.
12:48:36 <dolio> So you could have `IO MyModule`, which does some side effects to set up a module that you then open and use.
12:49:16 <Tuplanolla> How would that harmonize with compilation, dolio?
12:49:43 <dfeuer> All right, dolio. I'll try to work up a proper implementation. The hardest bit is really going to be testing that the strictness properties are exactly right.
12:50:17 <dolio> I don't know.
12:50:18 <Tuplanolla> Would you have to package the compiler with the executable just in case instantiating the module required some runtime information?
12:50:30 <dolio> Maybe just the linker.
12:50:48 <dolio> Actually, I don't know that that would even be necessary.
12:51:27 <jared-w> Not with backpack, I believe
12:52:33 <Saizan> Tuplanolla: you're just passing a bundle of functions around man, it being a module just means it packages types and maybe something about scope, but all that is forgotten at runtime
12:52:40 <jared-w> You have a module with just the types, the "interface" so to speak. Then there's one that acts as a wrapper around existing libraries that pulls in the types and 'implements' the interface. End users use the pre-instantated one
12:53:23 <jared-w> So all the end user cares about is they have a "head" function that gets the first charcter of a "string"; they don't care which string it is, it works on whichever one they're using.
12:54:04 <jared-w> http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/
12:54:49 <dolio> Yeah, I mean, you can compile your first class modules to F_w or something. If you agree to that, there's nothing too mysterious about having them appear inside IO.
12:55:08 <Tuplanolla> Okay, sure.
12:56:32 <Tuplanolla> A more practical concern, then, is how imports should be handled. We currently represent them as static sets, but surely they could be computed by arbitrary functions if modules were first-class.
12:57:00 <dolio> Why?
12:57:13 <Tuplanolla> ...because we can?
12:58:12 <dolio> Like, you could say the same thing about records. But you don't get to compute code for working with records from values just because records are values.
12:58:43 <Tuplanolla> I don't know where to draw the line.
12:59:17 <dolio> You can use different record fields in different branches of a function, say, but you could do that with modules that allow you to locally open, regardless of whether they're first class.
13:01:40 <dolio> What you're talking about sounds more like dependent types. Computing the type of the module (the exports you need) from a value.
13:01:48 <dolio> Which is separate from modules being values.
13:02:21 <dolio> Or at least, computing it in a more arbitrary way.
13:02:39 <Tuplanolla> I need to meditate over this.
13:03:11 <jared-w> In fact, first class module systems have no relation to dependent types and do not encode nor enable them
13:04:32 <dolio> Like, `if b then m # foo else m # bar` has `m :: {foo, bar | r}` rather than `m :: if b then {foo | r} else {bar | s}`
13:21:23 <freeside> woot, i got intero working
13:22:09 <jared-w> nice
13:24:22 <wilornel> How do I search for ((->) r) in hoogle? 
13:25:22 <jared-w> http://hoogle.haskell.org/?hoogle=((-%3E)%20r) <-- does that not work?
13:27:41 <cocreature> wilornel: what results do you expect to see for that? all functions?
13:28:41 <Athas> jared-w: MosML definitely does not have first-class modules.
13:28:50 <wilornel> jared-w: For some reason I was gettting: https://www.haskell.org/hoogle/?hoogle=%28%28-%3E%29+r%29
13:29:06 <Athas> (I work with the maintainer and read the source recently.)
13:29:17 <wilornel> cocreature: I was hoping that would help me find https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#%3C%2A%3E
13:29:45 <Athas> freeside: was it much work?
13:30:56 <cocreature> wilornel: I’m not sure why you think your search query will show that
13:31:24 <cocreature> wilornel: if you want to find <*> search for http://hoogle.haskell.org/?hoogle=Applicative%20f%20%3D%3E%20f%20(a%20-%3E%20b)%20-%3E%20f%20a%20-%3E%20f%20b
13:32:35 <jared-w> Athas: the stack overflow link said they had first class modules  ¯\_(ツ)_/¯  good to know they don't
13:32:39 <dmwit> ?src (->) (<*>)
13:32:39 <lambdabot> (<*>) f g x = f x (g x)
13:33:06 <johnw> didn't know lambdabot could do that
13:33:09 <johnw> ?src Maybe (<*>)
13:33:09 <lambdabot> (<*>) = ap
13:33:15 <johnw> cheater
13:33:18 <dmwit> Unlike most other type constructors, I don't think there's a documentation location for (->) that lists its instances. =(
13:33:32 <johnw> true
13:33:37 <johnw> hard to search for
13:34:14 <dmwit> wilornel: (This commentary is aimed at you, by the way.)
13:40:00 <Hijiri> I'm using smtlib2, how do I get an expression for an untyped variable?
13:40:16 <Hijiri> just, something like String -> SMT b (Expr b t)
13:40:28 <Hijiri> Or would I need to rely on the specific backend to do something like that
13:41:21 <Athas> jared-w: and first-class modules and recursive modules are not necessarily a good thing!  Nontermination in the module system...
13:42:09 <Athas> I don't think Backpack has anything like that.
13:45:37 <Hijiri> I think I'm just going to use simple-smt, since the appeal of smtlib2 looks like the typedness in the first place
13:48:40 <johnw> I wonder why even bother with an AST for smtlib2
13:49:07 <johnw> since it's all just lists of atoms referring to symbols
13:49:24 <jared-w> Athas: that would be fairly interesting... What's the use case for recursive modules anyway? It just seems somewhat ridiculous
13:52:01 <Athas> jared-w: you can use it to express polymorphic recursion, I guess, which is otherwise not permitted in Standard ML.
13:52:28 <Athas> I hear they are also necessary if you want modular implicits (sort of type classes built on a module system).
13:52:37 <dolio> Seems like overkill for that.
13:52:45 <dolio> (The polymorphic recursion part.)
13:53:48 <Athas> There is probably a reason why only MosML supports it.
13:54:22 <Athas> It also has the "interesting" property that misuse of recursive modules (such as non-well-founded recursion) results in exceptions being thrown at run-time.
13:55:39 <dolio> Supports recursive modules, or polymorphic recursion?
13:55:45 * jared-w just found out about oregon programming languages summer school
13:55:46 <Athas> Recursive modules.
13:56:00 <jared-w> looks amazing; why did I never find out about this until now? o.O
13:56:02 <Athas> Polymorphic recursion has its issues, but I think Haskell shows that it's no big deal.
13:56:08 <Athas> jared-w: it is great.  I went a few years ago.
13:56:27 <jared-w> Is it free or something? I can't see any information about how to apply to it...
13:57:03 <hpc> Athas: more than that, every so often i have to go back and read up on polymorphic recursion to remind myself of why it is special at all
13:57:16 <jared-w> Athas: I live in Portland so it's very close to me. I'm really surprised PSU has absolutely no information about it that I can see. Hell, I couldn't really find any information about it until I randomly went through R.Harper's blog and stumbled on upon a random mention to it
13:57:26 <Athas> jared-w: it is not free, no.
13:57:37 <dolio> It's pretty special if you don't want to have type annotations.
13:57:42 <Cale> You can watch all the lectures online for free though
13:58:18 <Athas> Part of the reason to go to OPLSS is to meet other PL people, though.
13:59:32 <jared-w> Cale: didn't know that either :p
13:59:50 <jared-w> Athas: right, and that's mainly why I'd want to go. Plus, I'm very hard of hearing so watching lectures online is almost guaranteed a no-go for me
14:00:21 <Athas> As I remember, OPLSS was not that expensive as summer schools go (housing and transport was by far the largest expenditures).
14:00:49 <Athas> Looks like it was $230 in 2015.
14:01:03 <Athas> For students, that is.  $330 for post-docs and industry guys.
14:01:07 <jared-w> Yeah I have tons of friends in the area so housing and transport is basically free for me. I'm just sad I didn't know about OPLSS until now... I've got to wait an entire year for it now since it's about to end *sigh*
14:01:19 <jared-w> Definitely penciling it in for next year, though!
14:01:40 <jared-w> Also I'm doing the HSOC so it all worked out, but still :p
14:02:23 <Athas> Let's hope that Bob Harper presents again.  He's probably my favorite PL theorist.
14:12:31 <jared-w> I have like 35 tabs opened because I basically just dumped his entire blog into my browser. He's a great writer
14:17:06 <johnw> I liked the Harper lecture I was in at OPLSS; except that I spent just 5 seconds daydreaming, and when I woke up again the board was filled with diagrams and we we're talking about fibrations. When a second again he said, "Ok, this is the identity function..."
14:21:36 <jared-w> haha I've had that problem before sometimes
14:22:48 <jared-w> I'm twice cursed: ADHD-C and deafness. I can't hear and get easily distracted which makes it very easy to lose the train of conversation. Of course, once that train of conversation is lost, being (mostly) deaf makes it nigh impossible to pick it back up...
14:24:05 <johnw> yeah, I never recovered in that Harper lecture; so stay on your toes!
14:25:08 <hpc> was this one of those "harper filled a whitebard with math, there were no survivors" kind of things, or just bad timing?
14:25:37 <johnw> a mixture; I don't think anyone came out unscathed
14:26:05 <johnw> you can relive the carnage here: https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html
14:26:13 <johnw> (Type Theory Foundations lecture)
14:26:51 <hpc> ah, nott
14:26:53 <hpc> er, hott
14:27:14 * hackagebot protocol-buffers 2.4.2 – Parse Google Protocol Buffer specifications – https://hackage.haskell.org/package/protocol-buffers
14:27:19 <johnw> too hott to handle
14:27:25 <Tuplanolla> We tried the one-day for Coq thing around here as well. Carnage is a good description.
14:27:35 <hpc> i wish the university i went to had anything that good
14:27:38 <hpc> i learned prolog and yacc
14:28:21 <johnw> ah well, linear-types branch build failed
14:29:18 <orion> Is there a function in base which can do: [ [X,Y], [X, Y], [X] ] --> [ [X, X, X], [X, Y, X], [Y, X, X], [Y, Y, X] ] ?
14:29:39 <jared-w> johnw: what failed?
14:29:53 <johnw> jared-w: oops, I closed the window; some part of the Haddock build
14:30:20 <johnw> let me build again
14:30:32 <johnw> jared-w: https://gist.github.com/3620a3841b60d939852634354f13cdae
14:30:33 <jared-w> are you missing the sphynx packages for generating documentation?
14:30:52 <johnw> this is phase2 trying to build the final compiler; I guess I can just use phase2 for now
14:31:44 <jared-w> out of curiosity, how'd you put up that gist so fast?
14:31:53 <ski> > sequence [[x,y],[x,y],[x]]
14:31:55 <lambdabot>  [[x,x,x],[x,y,x],[y,x,x],[y,y,x]]
14:31:56 <ReinH> orion: sequence?
14:32:01 <johnw> when I copy to the clipboard, and C-y inside my ERC window, it auto-gists whatever large thing I was about to paste
14:32:07 <ReinH> ski: :(
14:32:20 <jared-w> ERC?
14:32:24 <johnw> Emacs IRC client
14:32:29 <jared-w> ahh got it. That's kinda neat
14:32:44 <johnw> jared-w: the code is here: https://github.com/jwiegley/erc-yank
14:33:00 <jared-w> I use weechat and I'm far too married to it to move to an emacs irc :p
14:33:35 <johnw> so, under the hood this uses the CLI ruby tool "gist", so you could probably hook up something similar
14:34:03 <jared-w> Anyway, I'd pop into #ghc and see if they can tell you more about the error
14:34:27 <johnw> i'll probably send a message to boespflug, since it's his branch
14:38:38 <jared-w> sounds good
14:39:38 * hackagebot propellor 4.1.0 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
15:01:41 <absence> is ghc 8.2 taking longer than usual in RC stage? the mailling list is pretty quiet about it
15:03:34 <assderp> ay
15:04:20 <jared-w> absence: 8.2 is coming out with backpack and with improved deriving strategies, I think, so it might make sense to take a bit longer than normal
15:05:03 <geekosaur> I think the current blocking issue is ARM support
15:05:25 <geekosaur> (and the past several releases have been delayed on platform issues --- ARM, Macs, Windows, ...)
15:06:18 <dhalgren> thought they wanted to make 8.2 a stabilization release. but seems to have ended up with rather significant new features
15:07:15 <johnw> "I know, let's have a stabilization release! and... add dependent types maybe?"
15:07:23 <dhalgren> :)
15:10:02 <hpc> it's perfectly stable if you don't use the features
15:21:58 * hackagebot tweet-hs 0.6.1.2 – Command-line tool for twitter – https://hackage.haskell.org/package/tweet-hs
15:21:58 * hackagebot propellor 4.2.0 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
15:27:06 <skiddieproof> I am trying to install cabal and am getting the error "Failed to load interface for 'System.Posix', Perhaps you haven't installed the "dyn" libraries for package `unix-2.7.2.1@un...`" How do I install this package without cabal?
15:27:41 <koala_man> how are you installing cabal? 
15:28:42 <skiddieproof> from binary, using the command 'runhaskell Setup configure'
15:29:02 <skiddieproof> at least that is the first command, and where the error happens
15:29:56 <tempeh> how do you write a Functor instance for 'data X a = Y a | Z
15:30:13 <tempeh> without enumerating all of the constructors
15:31:22 <johnw> deriving Functor
15:31:24 <Clint> tempeh: why do you want to write one?
15:31:31 <johnw> {-# LANGUAGE DeriveFunctor #-}
15:31:39 <cheater> johnw: ?
15:31:44 <tempeh> can't derive functor in this case
15:31:51 <koala_man> skiddieproof: "the cabal-install tarball contains a bootstrap.sh script which downloads and installs all the dependencies." Are you using bootstrap.sh?
15:32:21 <tempeh> Clint: this is a minimal example, my case is much more complicated
15:32:24 <johnw> tempeh: works here
15:32:40 <johnw> ah, so your example is not representative of your question?
15:32:57 <johnw> then it's ok if my answer is not relevant either :)
15:33:02 <tempeh> i guess not. let's say no deriving
15:33:08 <tempeh> yeah, sorry
15:33:14 <johnw> then you get to enumerate constructors
15:33:42 <tempeh> that's actually the only way? that's a major problem if I have, say 100 constructors that don't have 'a'
15:34:02 <geekosaur> that's actually the only way
15:34:03 <johnw> yep
15:34:05 <Clint> and why can't you derive?
15:34:09 <johnw> because you need to reconstruct at the new type
15:34:13 <tempeh> ouch
15:34:16 <johnw> Z :: X a /= Z :: X b
15:34:34 <johnw> I wonder if "coerce" would work here
15:34:39 <johnw> _ -> coerce x
15:34:47 <johnw> since it's purely a type distinction, not a value distinction
15:34:49 <tempeh> can't derive because it's actually a newtype that rearranges the parameters of another type
15:35:11 <tempeh> yeah, i might try something like coerce
15:35:15 <Clint> ...
15:35:23 <geekosaur> i,i don't drink and derive
15:36:38 <tempeh> Clint: is that not a good reason?
15:36:44 <Clint> you have a newtype with 100 constructors?
15:37:57 <tempeh> haha nope. i have a type with many constructors that derives Functor on some parameter, and a newtype wrapping that type that needs Functor on a different parameter
15:38:02 <tempeh> pretty frustrating
15:38:48 <tempeh> might have to derive a bifunctor or something
15:59:54 <c_wraith> tempeh, Bifunctor is nice. lens is also a solution to that kind of problem, from a bit of a different direction. 
16:02:16 <tempeh> c_wraith: can you generate lenses to do that sort of thing?
16:03:42 <c_wraith> tempeh, you don't get automatic selection of lenses from context, the way you get fmap automatically from context. but you can certainly write lenses that have the effect of mapping over all appearances of a type variable within a structure 
16:04:28 <c_wraith> tempeh, you might have to write it manually instead of deriving it, but.. I do that anyway, since it compiles so much faster.. 
16:11:20 <tempeh> c_wraith okay cool, i may try that
16:15:46 <ski> matching on `Z', it ought to realize that the input has type `forall a. X a', rather than `X a' (for the given `a')
16:16:46 <tempeh> it sure would be nice if it did
16:17:16 <iqubic> Hello folks. I am back.
16:17:47 <jared-w> welcome back
16:17:51 <ski> (so `fmap _ x@Z = x' ought to work)
16:21:09 <ReinH> c_wraith: well, you can have typeclass'd lenses, like the ones makeClassy creates.
16:21:43 <c_wraith> ReinH, yeah, but even then you still have to provide *some* name for it. 
16:21:51 <ReinH> Well yes.
16:22:30 <ReinH> But that's how typeclasses work in general anyway, so maybe I'm missing the point
16:36:34 <dmwit> tempeh: I mean, you can `fmap f (Y v) = Y (f v); fmap f x = unsafeCoerce x`. But you lose all the fun things the compiler can do for you like checking that you didn't forget a pattern.
16:38:09 <dmwit> tempeh: Is it possible to move the enumeration into a separate data type and redefine like `data Enum = A | B | C; data X a = Y a | Z Enum`? Then you get the best of both worlds, since `fmap f (Y v) = Y (f v); fmap f (Z v) = Z v` are the only two cases needed and the compiler will still know everything it needs to to give you fun warnings and do completeness checks and stuff.
16:42:00 <jared-w> Should we make a KitchenSink pragma so edwardk only needs to write one line of pragmas instead of 27? Thoughts?
16:42:21 <edwardk> i'd still write the 27 ;)
16:42:26 <edwardk> i like being explicit about what i'm using
16:42:50 <edwardk> each extension tends to come with some kind of negative aspect
16:43:02 <dmwit> jared-w: We've tried -fglasgow-exts. It's not worth it.
16:43:28 <jared-w> And the ones that don't are usually fairly trivial syntactical sugar changes. Of course, I wasn't being anywhere near serious... :p
16:43:38 <dmwit> Either the flag changes meaning between releases, which sucks for developers who actually care about supporting multiple compilers, or it grows stale.
16:44:09 <ski> .. hm, i thought that if you used "polymorphic variants" (light-weight variants) in OCaml with a default pattern, it'd get a type not including all the variants you matched before .. but when i tried it (in 3.12.1), it doesn't seem to work
16:45:02 <jared-w> Definitely. It's especially a problem because /most/ of the trickier extensions that are used (especially the ones people like to write unreadable witchcraft in) tend to target type level programming features which would all be subsumed with dependent haskell
16:45:29 <jared-w> (in my current understanding, anyway)
17:14:32 <felixphew> what's a good way to go from ByteString to Word64 (big-endian)?
17:14:59 <felixphew> going the other direction is easy with ByteString.Builder
17:15:15 <felixphew> so basically the inverse of toStrict . toLazyByteString . word64BE
17:20:32 <pacak> fold
17:22:57 <ReinH> Or use binary
17:30:09 <orion> How can I generalize this for all N?: foo x = do a1 <- [...]; a2 <- [...]; ...; aN <- [...]; guard (f a1 + f a2 + ... + f aN < x); return [a1, a2, ..., aN]
17:32:05 <orion> In other words, how can I pass "N" as a parameter to foo?
17:34:07 <danilo2> Hello guys! Is it somehow possible to use Aeson / any other related library to parse a JSON file and "update" a record? I've got record with some fields set and jsut want to alter the fields that are mentioned in JSON description
17:38:09 <johnw> sure, that's not too hard at all using lens-aeson
17:38:17 <johnw> read it in, update the field, write it back out
17:43:54 <danilo2> johnw: I'm looking for some automated workflow here. I don't want to manually create code for each field (I've got a big amount of fields and nested strucutres to be updated here)
17:44:13 <danilo2> johnw: however, Ijust found https://hackage.haskell.org/package/aeson-diff-1.1.0.2/docs/Data-Aeson-Diff.html#t:Operation
17:44:41 <danilo2> johnw: which might do what I want. If I have a structure I can convert it to JSON then parse the "diff" , apply the diff and convert it back
17:44:47 <danilo2> then I've got what I want I think
17:51:28 <johnw> if all you want to do is JSON surgery, why use Haskell?
17:51:35 <johnw> I think jq could do this
18:05:12 <danilo2> johnw: I dont do json surgery. Ive got json interface for setting configuration of a program
18:17:10 * hackagebot propellor 4.3.0 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
18:20:48 <deceract> @type fmap
18:20:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:23:25 <Axman6> danilo2: lens-aeson can certainly be used to do what you want
18:28:56 <danilo2> Axman6: thank you! :) Im just wondering now if it would give any benefits over using aeson-diff. Using the diffs I can achive what I want in 4 lines without any custom functions, however to have highly tailored error messagesmaybe I would need to move over something more custom in the future and then aeson-lens seems like a perfect fit
19:24:36 <jared-w> I gotta admit, I have an almost masochistic enjoyment of reading Bob Harper shit on haskell
19:29:54 <cuddly[m]> jared-w: wtf
19:30:56 <jared-w> What? I like reading about the weaknesses and problem areas of things I enjoy. It forces me out of the lovey-dovey "x is perfect" mindset and makes me consider things I wouldn't otherwise think about, angles I wouldn't normally pursue, and worldviews that don't naturally align with mine
19:40:21 <pacak> jared-w: link?
20:03:18 <jared-w> half of his blog?
20:03:33 <jared-w> https://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/  <-- prompted my particular statement in this case
20:05:53 <geekosaur> not that haskellers don't also complain about exceptions...
20:05:57 <jared-w> Of course, there's things such as "haskell is incapable of proper inductive data types", "laziness is the wrong default", "real ML modules are way better than Haskell's", and so on (not actual quotes)
20:10:03 <jared-w> But yeah, haskellers do also complain about exceptions. I haven't really seen a haskeller give /that/ particular complaint about htem, however
20:20:34 <glguy> The problem with stuff Harper writes is that instead of writing that article to point out a (now resolved) problem with the Typeable class, he knowing uses that to attack the exception class
20:20:41 <glguy> knowingly*
20:21:47 <glguy> It comes across as rather dishonest
20:27:09 <jared-w> Well it was last updated at 2012... Was it dishonest at that point in time? A few people pointed out how he was exploiting a problem in Typeable; he justified that by saying that the implementation of exceptions forced having Typable. Or, rather, the main point was that user-defined typed exceptions in pure code are unsound
20:28:38 <jared-w> (of course I'm just parroting here. I have no real expertise here; I'm just interested in the reality of a situation)
20:30:02 <glguy> Yes, it was dishonest at the time
20:30:08 <glguy> I was just mentioning that it was since resolved
20:30:35 <orion> What is the current state of exceptions now? Should I just use the safe-exceptions package and call it a day?
20:30:50 <glguy> the main point was a red herring, a bit of furthering an agenda on the topic of exceptions
20:31:19 <glguy> So sure, read his stuff, but assume that it's not trying to teach you, but to sway you
20:31:43 <felixphew> what's the shortest way to cast a Word8 to a Word64?
20:31:55 <glguy> fromIntegral
20:31:58 <felixphew> (I hope it's not fromInteger . toInteger
20:32:09 <felixphew> aah
20:32:11 <felixphew> thanks
20:32:43 <skiddieproof> glguy: why go through the trouble of swaying people, whats Harpers motive?
20:33:06 <jared-w> right, that's fair; I definitely get that vibe from his stuff anyway. I think the exception thing was mostly related to something that comes up if you make all the design choices that ML does; they fit together in ML but don't necessairly mandate that Haskell's methodology is "wrong" because it comes from different design choices
20:33:14 <glguy> You're asking why people troll on the Internet?
20:33:52 <glguy> They do it for fun or to advance themselves or their prefered technology or for any number of reasons
20:34:32 <jared-w> skiddieproof: He's a teacher, a PL theorist, and highly opinionated on the best way to x (eg he's a SML fanboy). Nothing wrong with that, to me, especially since he's fairly open about it and what he's trying to accomplish  ¯\_(ツ)_/¯
20:35:19 <skiddieproof> glguy: haha, yeah I guess. I have seen some of his stuff on OOP and got the impression he was somewhat of a crusader
20:35:20 <jared-w> Dijkstra was similarly highly opinionated about certain things and about the best way to teach CS, though I'll stop the comparison there :p
20:37:25 <jared-w> Things that I (so far) agree with include: I like a language model of computation more than a machine model; I like a strong type system over a "dynamic" one; I think OOP is almost always the wrong way to go about things (and enjoy Dijkstra's ranting about it and Java as well); I think a functional language is a superior, if not the best, way to introduce programming to beginners.
20:38:33 <jared-w> But, a lot of his other crusading seems to be on minutae like a "dislike" of HoTT, strict > lazy, $lang_feature in ML is the RITEWAY(tm) to do something, etc., so...  ¯\_(ツ)_/¯
20:40:16 <skiddieproof> thanks for sharing :)
20:42:32 * jared-w waits for someone smarter to smash me over the head with an "actually, you're wrong"
20:46:27 <orion> https://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1012.html <-- does Haskell fit nicely into the "postulational" method?
20:46:43 <jared-w> dijkstra!
20:47:47 <jared-w> What Dijkstra is talking about here is, very roughly speaking, "declarative" vs "imperative" programming; I use scare quotes here because declarative and imperative are really tricky terms to be formally precise about.
20:48:48 <jared-w> Another way to think about it is that the postulational method is the linguistic computational analysis of programming and the operational method is the machine model computational analysis of programming
20:49:00 <jle`> felixphew: that's exactly what it is
20:49:24 <jle`> felixphew: but there might be some rewrite rules to optimize fromIntegral for that case
20:49:57 <jared-w> where linguistic analysis might proceed by way of some sort of lambda calculus, machine analysis will define some ideal machine roughly based on a turing machine and go from there.
20:50:46 <orion> What other models of computation are there besides lambda calculus and a Turing machine?
20:51:53 <jared-w> Since Haskell *is* a lambda calculus, and Haskell's entire computational model is the lambda calculus reducing/evaluating (not sure which is "proper-est" terminology) step, it makes sense to say that Haskell is fairly ideally close to what Dijkstra mentions as the postulational method. That being said, it's not 100% perfect
20:52:19 <Axman6> of course it's not perfect
20:52:47 <Axman6> that article is insane btw, is writing " typeOf _ = typeOf (undefined :: ErrorCall)" even allowed these days? I though typeable could only be derived
20:52:55 <jared-w> orion: There's really only the linguistic computational model and the machine computational model. Both are, of course, equivalent.
20:53:11 <Axman6> but if you do write that, you're clearly being malicious, and it's possible to be malicious in any language
20:53:12 <jared-w> Axman6: that was the fix to prevent Typable abuse that glguy mentioned
20:53:50 <jared-w> I think the main point Harper was really getting at is that a typed exception system, in a 100% pure language, that allows user-defined types, is unsound.
20:54:23 <Axman6> this is likely one of the reasons exceptions in Haskell are extremely rare
20:55:10 <jared-w> Right. They're very common in ML because of their module system, the fact that they are dynamic, and the fact that ML does not shove all side effects into the IO monad and it allows benign effects (ie exceptions)
20:56:49 <jared-w> But since Typable is only allowed to be derived, in essence, you don't "have" user defined types in the typed exception system. So, it's allowed to be typed and yet pretend it behaves much like a dynamic exception system (similar to ML). A continuation, I believe, of the "Morally fast and loose" reasoning that Haskell tends to idiomatically exploit in favor of usability over unrealistic ideology
20:57:10 <jared-w> (all this is just my current understanding, of course...)
20:58:50 <Axman6> not sure what you mean by "you don't "have" user defined types in the typed exception system", you can definitely define your own exception types
21:01:29 <Axman6> but we don't because we have better mechanisms
21:01:56 <jared-w> Typable, as I understand it, is the runtime representation of a type. Since it can only be derived, the compiler can always make sure that it's derived "correctly" and thus the peril of a user-defined type (that is, being unsound from human error) is avoided. So, the compiler can pretend that the exception types are dynamic and cast willy nilly because it will never cast invalidly. Sort of how `data Nat a =
21:01:58 <jared-w> Zero | Succ Nat` is technically not inductive because of the presence of bottom but you can "loosely reason" that it is because bottom "doesn't exist" and that loose reasoning is morally "correct" in Haskell.
21:03:03 <jared-w> Axman6: he proposes an alternative mechanism and attempts to pursuade (using an unfair example) that his is superior; coincidentially, it's how his favorite language does things...
21:04:27 <Axman6> this guy just reads like Jon Harrop. malicious vested interests instead of trying to provoke positive outcomes and positive change
21:05:53 <jared-w> Hmm... who's Jon Harrop?
21:05:57 <Axman6> (Jon's anti-haskell writings are purely so that he can help people discover his F# consulting business)
21:06:49 <jared-w> ahh right
21:07:34 <Axman6> you'll find him on forums all over the net, and on his own blog, vehemently bashing Haskell, because his business interests somewhat revolve around Haskell's failure (haven't seen much of him lately, I hope his business failed, because his attitude was just an awful think to have inthe wider software community)
21:08:25 <jared-w> "Thankfully this problem is now starting to dissolve away with functional languages like ... F# being used for real work but for many years the predominantly-smug-weenies dominated the functional scene, making it hard for people to get real solutions to their real problems" - Harrop
21:08:47 <Axman6> yeah, that sort of nonsense
21:09:49 <jared-w> It's fairly well known that you need a good 25 years for research to trickle down to "real languages"; hence why the concepts of the late 70s-late 80s are finally hitting everywhere. Now (almost) every language has map, filter, some sort of generics, yadda yadda. 
21:10:11 <Axman6> *cough* go *cough*
21:10:22 <Axman6> they're going to need more than 40 years I think
21:10:24 <jared-w> Makes for a great "our brand new language which reinvents (poorly) haskell+25-years-later is better cause its newer" argument, though
21:10:43 <jared-w> pffh, Go purposely slid back to the early 60s in terms of PL design; drives me nuts.
21:11:02 <Axman6> for no real benefit either
21:11:30 <jared-w> Nah man, didn't you hear, that compiler ees wihked fast, and muh green threads n low latency GC bro /s
21:11:31 <Axman6> "It's easy to learn" is, imo, a really a misfeature, because it usually comes at the cost of expressiveness
21:12:38 <jared-w> You can learn all of brainfuck in half an hour, why isn't it being used by Big Programmer? It's a conspiracy to get you to learn Design Anti-Patterns, I tell ya
21:13:33 <orion> Axman6: Regarding Go: https://twitter.com/snoyberg/status/882255351382462464
21:14:12 <skiddieproof> brainfuck is suprisingly expressive, with a single line of code you can overload the '+' operator to make you rethink your life
21:14:28 <jared-w> Anyway, I like reading through Harper's blog since he's at least intelligent and fairly decent about not being outright flaming and toxic with how he approaches things. Sure, he's shilling his interests, but he's not *too* biased. It's a "read once every 8 months, if that" for me anyway
21:15:52 <Axman6> orion: yeah, I even liked that tweet :)
21:16:00 <jared-w> note to self, stop saying anyway so often :p
21:16:32 <Axman6> how are you going to do that anyway?
21:17:44 <jared-w> I'm trying to change my general language patterns because some of them are needlessly giving the impression of dismissal or condensending attitudes. For example, I often say things like "so... (question), anyway?" which sounds way more condensending than I intend to come off as
21:19:20 <jared-w> But yeah, I saw that thread on reddit
21:19:23 <jared-w> https://www.reddit.com/r/rust/comments/5penft/parallelizing_enjarify_in_go_and_rust/
21:19:43 <jared-w> C++ also allows 0-width spaces in variable names and I'm honestly not sure which is worse...
21:24:08 <pacak> > let ᐸElementTᐳ = 2 in let (☭) = (+) in ᐸElementTᐳ ☭ 3
21:24:10 <lambdabot>  5
21:24:19 <skiddieproof> Due to Poe's law, I cant tell if the mumbo about Canadian Aboriginal Syllabics is true or satire
21:24:41 <jared-w> Oh that is actually true, see the reddit link
21:25:00 <pacak> https://en.wikipedia.org/wiki/Canadian_Aboriginal_syllabics
21:25:10 <jared-w> pacak: is that a hammer and sickle, comrade?
21:25:19 <pacak> jared-w: da.
21:25:59 <jared-w> noice. Brb rebinding my lambda
21:29:17 <skiddieproof> Maybe Go is Ken Thompson's way of 'putting an exaust port in the death-star that is google' so to speak
21:31:32 <Lokathor> does mapM_ have any optimization
21:31:42 <Lokathor> like, should i build the list that i pass to it in a specific way
21:31:55 <c_wraith> well, it doesn't construct and then throw away the list mapM creates..
21:32:29 <Lokathor> http://lpaste.net/356709 is my use case
21:32:41 <pacak> @src mapM_
21:32:41 <lambdabot> mapM_ f as = sequence_ (map f as)
21:32:51 <pacak> @src sequence_
21:32:52 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:33:12 <Lokathor> a ha, so i guess it will fuse a bit
21:33:38 <c_wraith> If you trust @src
21:33:41 <c_wraith> which is sketchy
21:33:46 <c_wraith> :t mapM_
21:33:47 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
21:33:57 <c_wraith> since its implementation has the wrong type..  :)
21:34:13 <Lokathor> oh no!
21:34:28 <c_wraith> mapM_ is part of foldable now
21:37:03 <jared-w> I wish I could have the -> in a lambda be replaced with ↦
21:39:28 <systemfault> :t traverse_
21:39:30 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
21:40:16 <pacak> Prelude> :set -XUnicodeSyntax 
21:40:16 <pacak> Prelude> (\x → x + 3) 10
21:40:16 <pacak> 13
21:40:22 <pacak> jared-w: Don't.
21:41:41 <jared-w> no that's just the unicode rightarrow, I wanted |->. Is that not more mathematically correct?
21:48:42 <Axman6> it's just notation, there's no standard in maths for anything, just convention
21:49:02 <Axman6> '.' could be considered more correct
21:49:12 <Axman6> \x.x+x
22:00:26 <jared-w> true
22:13:21 <moet> i'm a little confused about slicing in repa.. the example http://hackage.haskell.org/package/repa-3.4.1.2/docs/Data-Array-Repa.html#g:8 shows `Any` being used as part of a shape, but `Any` takes a shape as type-index
22:22:42 <moet> from poking more at the examples, it seems `Any` allows you to extract a dimension which isn't the first dimension .. i guess
22:22:47 <ongy> jared-w: there's a unicode character extension to GHC, not sure if you can give that one custom chars aswell (but I generally wouldn't recommend using it)
22:25:26 * slack1256 still wonders how total allocation can be on the order of gigabytes for haskell programs
22:25:53 <jared-w> slack1256: probably makes a lot more sense once you forget everything you know about "allocation" and learn what it means in the Haskell sense
22:26:35 <jared-w> ongy: nah I don't use that, I use dynamic character replacement in emacs. It's basically a visual syntactic sugar that disappears temporarily when I move my cursor over text. Really nice for doing stuff like replacing 'or' with `^` and so on
22:26:43 <jared-w> or with `v`, rather...
22:27:14 <moet> still confused about how to slice the first dimension w/o specfying `:. All :. All` for all subsequent dimensions
22:27:18 <moet> but moving on for now
22:28:22 <slack1256> if only there was a standard source for knowing what allocation means "in the haskell sense"
22:28:42 <jared-w> The haskell report, I'm guessing?
22:31:03 <slack1256> nah, this is and implementation report concert. Haskell report is about semantics
22:31:20 <jared-w> moet: does slice arr (Any :. (1::Int) :. All) not work?
22:32:31 <jared-w> slack1256: are you grabbing the allocation amount through the weigh package?
22:33:19 <slack1256> +RTS -s --RTS. I am pretty sure of what allocation means on the context of the haskell rts
22:33:49 <slack1256> What I cannot believe is the order of magnitude. I would think it is among hundreds of megabytes, not on the gigabytes
22:33:56 <jared-w> Try out the weigh package, you might see a different number.
22:34:55 <slack1256> ok
22:35:24 <jared-w> +RTS -p is fairly useful and might be shorter to get what you want
22:35:31 <jared-w> https://www.fpcomplete.com/blog/2016/05/weigh-package <-- goes into more detail about the weigh package
22:37:51 <lambdamu_> slack1256: I'm not sure what your workload is but gigabytes of total allocation isn't unusual
22:38:44 <moet> jared-w: i'm not sure
22:39:08 <moet> jared-w: i can't even find clear docs describing what the order of dimensions in a shape imply
22:39:28 <moet> sorry just getting a little frustrated. i'll experiment some more and come back if i have questions
22:39:40 <dramforever> Is this right? For immutable data, 'total allocation' basically means 'data created'
22:40:01 <dramforever> 'GC'd data created'
22:40:33 <slack1256> yes
22:41:23 <slack1256> although for example, if you have a map, and modify only a single key, the total allocation would be the size of 2 of such maps
22:41:36 <dramforever> oh?
22:41:44 <dramforever> it shouldn't be
22:41:46 <cocreature> huh? I don’t think that’s true
22:41:49 <slack1256> even though in the heap is represented as the same map with only a key pointer different
22:41:54 <jared-w> moet: np, I've never looked at the package before so I'd imagine the typical haskell-level-documentation isn't super helpful at times :p
22:42:04 <dramforever> most likely O(log size)
22:44:02 <slack1256> what I don't know is if the copying gc means the allocation arena is added in size on the total alloc
23:04:49 <smallCat> Hello
23:05:05 <smallCat> Is there anyone here who's worked with the Grammatical Framework toolset?
23:05:24 <smallCat> I'm looking into it for a project, and I could do with some help
23:06:24 <Lokathor> mfw they claim to be a Haskell newbie, but their code has the imports all lined up like a pro would do
23:07:00 <jared-w> Does just running HLint on the codebase work? That's how I align my imports :p
23:07:06 <glguy> smallCat: your best shot at getting any help is to ask the actual questions
23:08:24 * Axman6 has stylish-haskell run by default on save
23:08:37 <smallCat> I want to know if there is language-specific documentation for the Resource Grammar libraries, and if so how to access it 
23:09:00 <smallCat> But GF is slightly obscure, so I thought I'd generally ask first if anyone knew about GF
23:12:41 <moet> hrm. so i got the repa library to slice the way i wanted to.. unfortunately the arrays (images) are upside down.. hah. i wonder where i screwed up
23:14:01 <moet> i'll paste about repa to explain what i learned
23:14:50 <dramforever> didn't read about context, but... sometimes images are stored upside down
23:15:19 <jared-w> Axman6: I should probably do that too, for now I just use the default spacemacs binding and it works pretty good
23:17:27 <moet> dramforever: hmm.. that might be the case. ty
23:17:32 <saylu> Hey folks! I've got an issue with hoauth2 I just cannot figure out. I can get an access token for Google's services via OAuth2, but I simply cannot refresh the token. The hoauth2 example without refreshing works fine when I build it locally, but I can't get their version with refreshing to work either.
23:17:36 <saylu> Tearing my hair out over this one
23:17:46 <saylu> I've written up exactly what's going on with logging here:
23:17:56 <moet> ah, no it seems to be that the image-writing library regards 0,0 as the bottom left instead of the top left
23:18:04 <saylu> http://lpaste.net/8912843431747780608
23:18:04 <dramforever> exactly
23:18:09 <saylu> Would love any help you guys have to offer
23:20:12 <moet> dramforever: well i guess it depends on which orientation you think of as correct :)
23:20:28 <moet> or rightside-up, rather
23:23:21 <saylu> It seems that hoauth2 is receiving a JSON payload with exactly the access token I need, except it's then trying to decode it as a URL instead of as JSON. I don't know if I should try and write my own function to handle this or if I'm making some glaring error.
23:23:53 <saylu> `hoauth2.HttpClient.parseResponseString/Could not decode URL: {\n \"access_token\": \"ya2...wTXsX`
23:39:13 <muzzle> hi
23:39:37 <muzzle> can anyone give me some pointers about the performance impact of using typeclasses?
23:39:46 <lambdamu_> saylu: I know nothing about oauth but I would recursively inline the definition of fetchRefreshToken and inspect the intermediate results, parseResponseFlexible tries parseResponseJSON and parseResponeString which apparently both fail
23:40:10 <muzzle> From what I can tell, a function with a generic argument under a typeclass constraint adds an additional Int# argument in the core. But I don't really understand what this is used for
23:40:15 <Axman6> muzzle: there aren't really general pointers to give, it depends hoo you're using them
23:40:55 <saylu> lambdamu_: Not sure what recursively inlining means, looking that up :p But you're right, I've found that there's a parse error with the JSON and now I'm trying to track down why it's happening
23:41:05 <Axman6> how*
23:41:09 <muzzle> the thing with the additional function argument just got me wondering
23:41:20 <muzzle> doesn't haskell have complete type erasure?
23:41:36 <muzzle> so all type class related questions have to be resolved at compile time?
23:41:52 <lambdamu_> saylu: I just mean to replace the function call with the defintion provided the needed functions are exported
23:42:16 <saylu> Got it.
23:42:28 <saylu> I've done that and tracked the failure back to a point where it simply relies on this function:
23:42:31 <saylu> `eitherDecode`
23:42:54 <saylu> So relying on a fromJSON instance
23:43:52 <saylu> `newtype AccessToken = AccessToken { atoken :: Text } deriving (Show, FromJSON, ToJSON)`
23:43:53 <saylu> i see
23:44:03 <saylu> it comes down to this. It's expecting just `Text` but it's getting an object.
23:45:06 <[exa]> muzzle: full monomorphization is certainly a good option, but I'm not sure Haskell does that. There's the thing called "dictionary typeclasses" that was used for compiling overloaded code; my best guess is that it's still used sometimes/somewhere
23:46:33 <lambdamu_> saylu: Yeah access_token seems to belong the OAuth2Token type returned by fetchAccessToken
23:46:50 <[exa]> muzzle: in fact full monomorphisation is described in section 4.7 here: web.mit.edu/ghc/old.ghc/programatica/tools.old/semantics/Overloading/Related/p109-hall.pdf
23:46:55 <[exa]> so maybe it does. :]
23:47:43 <ReinH> saylu: sounds like you shouldn't derive FromJSON then.
23:50:35 <saylu> ReinH: lambdamu_: I'm not :p
23:50:39 <saylu> The library author is.
23:51:23 <ReinH> You can write your own data type that contains an AccessToken and write a FromJSON for it.
23:51:32 <ReinH> Or you can decode it using lenses
