00:00:21 <Lokathor> in this case, the ideal is that it's eventually finalized into a library module that's as blazing as possible, and then just left alone like that
00:00:36 <dysfun> well you wouldn't want to prematurely optimise, would you?
00:00:43 <Lokathor> however, i have to bring the old "normal version" up to speed so that it can be the baseline in the benchmarking process
00:01:02 <erisco> here we are with these good ideas and this lousy hardware adds all this unnecessary work to it
00:01:21 <Lokathor> i know it's terrible
00:01:34 <Lokathor> dysfun, funny you should mention, i do have several benchmarks from the old version
00:01:37 <Lokathor> http://lokathor.github.io/ludolib/
00:02:03 <Lokathor> keep in mind that ~10 things will use FOV per turn, and a turn hopefully stays under 16ms, and there's a lot of other things besides FOV as well
00:02:19 <Lokathor> so perhaps FOV might end up even being cached by location once per dungeon, and just eat up all the RAM in the world
00:03:53 <Lokathor> actually many more than 10 things might use FOV, but we can expect 10 to be "normal" perhaps i should say
00:04:23 <Lokathor> might just have to keep ranges very low i guess
00:08:06 * hackagebot viewprof 0.0.0.5 – Text-based interactive GHC .prof viewer – https://hackage.haskell.org/package/viewprof
00:08:17 <MarcelineVQ> or a different approach, like using flow fields instead of ray collisions, or something, dunno what you're using that just comes to mind, and I'm not entirely sure what I​ mean by it since it's usually more for pathfinding than what's in a field of view
00:08:47 <MarcelineVQ> but I tend to imagine line of sight as a pathing problem
00:08:58 <erisco> how do you use a field of view?
00:09:26 <erisco> also, 10 is not usually a concerning number of things
00:11:26 <erisco> oh, determining if one object has line of sight to another?
00:11:49 <Lokathor> erisco, 
00:11:55 <Lokathor> yes it's for line of sight
00:12:12 <Lokathor> but 10 * 3ms is already over budget you see :/
00:12:40 <erisco> 3ms? what? this must be quite the complex scene
00:13:12 <Lokathor> http://lokathor.github.io/ludolib/ "Crowded, range 20"
00:13:16 <Lokathor> all in the 3ms range
00:13:38 <Lokathor> Now, the technique itself isn't entirely the fastest, but it is artifact free
00:14:28 <erisco> what does "crowded" mean?
00:15:08 <Lokathor> ah, i picked a bunch of random locations that block vision within a range 50 space
00:15:15 <Lokathor> and then just used that as a test set marked "crowded"
00:15:28 <erisco> are you using ray casting?
00:15:28 <Lokathor> https://github.com/Lokathor/ludolib/blob/master/bench/Bench.hs
00:16:15 <Lokathor> nope
00:16:22 <Lokathor> Precise Permissive FOV
00:16:44 <Lokathor> raycasting might be much faster
00:17:01 <erisco> there is a reason games approximate ;) but I am unfamiliar with this method
00:17:20 <Lokathor> this PPFOV doesn't approximate at all :P
00:17:25 <Lokathor> so no artifacts, but also slow
00:17:36 <erisco> if we were interesting a line with various shapes then I'd be asking just how many intersections we're doing in the "crowded" scene
00:17:50 <erisco> if that was high then I'd be asking what kind of spatial partitioning is being used
00:18:18 <erisco> then I'd finally suggest adjusting how the game works so we don't have this problem :P
00:18:35 <Lokathor> computeFOV :: (Location -> Bool) -> Int -> Location -> Set Location
00:18:48 <Lokathor> so, "no spatial partitioning really, it's just checking a vector probably"
00:18:57 <Lokathor> though in the benchmarks it's checking a Data.Set
00:19:11 <erisco> ray casting is particularly good in games that run on a grid
00:19:22 <erisco> so either a cell blocks line of sight or it doesn't
00:19:25 <Lokathor> roguelikes are almost always on a grid
00:19:35 <Lokathor> an yes, ppfov is the same, block or not per grid cell
00:19:43 <erisco> makes it easy to break the line into segments and figure out what lines you need
00:20:06 <Lokathor> i tried to do quadrants at a time using parMap but the overhead killed it
00:20:26 <Lokathor> though, maybe each *creature's* fov would be big enough to make gains
00:20:29 <Lokathor> hmm
00:22:09 <erisco> oh I see, there are cases where choosing corners doesn't work
00:24:00 <erisco> I don't know what algorithm you are using, but my first suspicion is that you can begin with a corner, or the centre, doesn't really matter, and try to go to the same relative spot on the target
00:24:12 <Lokathor> uhm, not quite
00:24:35 <Lokathor> http://www.roguebasin.com/index.php?title=Precise_Permissive_Field_of_View unfortunately the images are down at the moment
00:24:43 <Lokathor> but it describes it all in words
00:24:55 <erisco> yeah I was looking at that
00:25:22 <erisco> but I'd think you can assess the first intervening object and find the lines that look past it
00:25:38 <erisco> and so on until there are no such lines or you see the target
00:25:59 <Lokathor> well this isn't just line of sight, it's every possible target
00:26:04 <Lokathor> so it's n^2 just to start
00:26:05 <erisco> or you can render the scene and see if the target is visible :P
00:26:33 <Lokathor> it's for 2d ascii tiles! can't cheat and let the GPU handle it
00:26:39 <quchen> bollu: Any news on the codegen front?
00:27:15 <erisco> sure you can, you can come up with the extra dimension
00:27:33 <erisco> it just needs a unit height
00:27:48 <Lokathor> i think it's too late at night to try working that :3
00:28:03 <erisco> hey, parallel processing is where it is at ;)
00:28:55 <erisco> https://youtu.be/-P28LKWTzrI?t=1m12s
00:35:31 <erisco> Lokathor, at any rate, you need a faster algorithm
00:35:46 <erisco> this isn't a Haskell problem, this is a choice of algorithm problem
00:35:49 <Lokathor> yeah, can only go so fast
00:37:52 <tdammers> there's a bit of a gray area, where writing the same algorithm in one way or another may or may not have the compiler optimize it into a simpler one
00:38:22 <Lokathor> the STU version is manually unboxed Int# values and ST :P
00:39:25 <erisco> you're orders of magnitude out of where you need to be with this
00:39:42 <Lokathor> if i stick to range 10 it's fine
00:39:49 <Lokathor> which, in a dungeon, is probably fine
00:42:35 <erisco> I dunno, I think you can solve this without too much trouble just by adjusting the ray based on what it collides with
00:43:24 <Lokathor> if this were raycasting, yes
00:43:50 <erisco> yeah, well, why not use it
00:44:25 <Lokathor> even if i also did raycasting, i'd still want the fastest ppfov available to me as well
00:44:52 <erisco> I think you can do it precisely with ray casting too
00:49:09 <erisco> it'd be easy to draw my idea for you but I am not sure how to explain it in words... it isn't a formal algorithm yet
00:49:15 <ventonegro> git diff
00:49:18 <ventonegro> ooops
00:50:40 <erisco> but the number of rays you need would be something like the distance between the two objects in grid cells (as the crow flies, rounded up)
00:52:16 <erisco> as far as the quadratic growth is concerned... have you heard of portals?
00:54:26 <EvanR> its interesting the theory of "dont worry, we will simply optimize the hell of <module>, since its modular, we can spend the time optimizing it"
00:54:34 <EvanR> the hell out of*
00:54:49 <EvanR> instead of just using a dumb abstraction
00:55:22 <EvanR> when nothing is abstract, looks like fortran, the modules arent really helping!
00:55:33 <erisco> Lokathor, I think I can convey it in one diagram... let me find a place to put it...
00:56:33 * hackagebot ploton 0.3.0.0 – A useful cli tool to draw figures – https://hackage.haskell.org/package/ploton
00:59:00 <erisco> Lokathor, can you see this? http://imgur.com/I9ppa15
01:01:20 <merijn> erisco: I remember a presentation by Vavle on Left 4 Dead AI that was using similar ray casting (adjusting based on collision) so it should be sensible
01:01:58 <erisco> right, well the first thing is that if there is a LoS then it is within the red square
01:03:02 <erisco> I am not sure precisely how you find the purple lines, but it represents some projection
01:03:20 <erisco> there is some maximum profile of the target you can see from anywhere in the source
01:03:46 <erisco> this is just determined by the geometry and positions of the target and source, none of the intervening objects
01:04:22 <erisco> so, having this, you then narrow the bounds based on what you're running into
01:04:43 <erisco> so on the top red line, for example, we hit something and we know we can't go any further up
01:04:53 <erisco> so the only option to look around the object is to go down
01:04:59 <erisco> the bound becomes smaller
01:05:45 <erisco> and we wiggle these lines closer together (adjusting both or just one, doesn't matter) until we either run out of options or we fine a LoS
01:06:11 <EvanR> then suddenly, everything in the room becomes psychic and puts on blindfold
01:06:13 <erisco> so we're only going to need as many rays as objects we could possibly run into
01:06:37 <erisco> which is something like the number of cells in the box, which is something like just the distance between the two objects in cells
01:06:44 <erisco> because the objects themselves are a cell large
01:07:31 <EvanR> modern dooms will not slow down when you walk into the room containing like 500 enemies
01:07:40 <EvanR> and they all get mad
01:08:05 <erisco> keep in mind that you can solve a line for any two points but not any three, and that is relevant for your line wiggling
01:08:09 <EvanR> as i understand it they optimized the original source
01:08:36 <erisco> say you start adjusting the bottom red line, then you'll find that after clearing the first obstacle that you're now out of bounds
01:08:52 <erisco> so you have to both clear the first obstacle and stay within bounds, so you pick another point on the purple line on the S
01:08:57 <erisco> which you can solve
01:09:18 <EvanR> and nethacks environment is a subset of doom
01:10:10 <erisco> so just solve how to find this profile between two objects and then devise the correct way to wiggle the boundaries and you're done :P
01:12:07 <EvanR> upgrade your roguelike to support duke3d-style weird overlapping spatial zones!
01:12:20 <EvanR> then figure out line of site 
01:14:18 <erisco> just to show how quickly this can work, here I have added the next two lines if we wiggle from the bottom http://imgur.com/a1S2bGc
01:14:34 <erisco> the first line is the dark orange where we find it is outside of the boundaries
01:14:59 <erisco> so the next line is the one that just exactly fits in the boundaries, and that is just the two points of the boundary and the point we have to clear
01:15:20 <erisco> so already we get the lighter orange line which has drastically reduced our FoV to the target
01:16:08 <erisco> if there is a LoS it has to originate somewhere on the purple S line between the orange and top red line
01:16:44 <davr0s> is there anything to compile a strict subset of haskell to C or c++ (i've heard of 'c--')  what i'm thinking is trying to make it as human readable as is possible
01:16:46 <erisco> not in the angle they form, I mean, but it has to pass through somewhere between those two intersection points on the purple line
01:17:30 <erisco> and we see the light orange line intersects another obstacle so now we wiggle it to clear that one, and so on
01:19:12 <EvanR> that would be interesting
01:19:30 <EvanR> haskell to idiomatic as possible C
01:19:36 <erisco> that idea sounds DOA :P
01:19:59 <EvanR> like, closures everywhere, all data is tagged structs
01:20:10 <EvanR> pointers everywhere
01:20:27 <erisco> companies already use strict subsets of C++ to keep it comprehensible
01:21:14 <EvanR> however i object to the notion that C is human readable and haskell isnt
01:21:38 <EvanR> GHC Core is human *and* machine readable hehe
01:21:41 <Axman6> GHC used to compile Haskell by compiling it to C
01:22:06 <Axman6> but human reasable it was not (it included a perl script to mangle the produced assembly)
01:22:29 <Axman6> davr0s: you might want to look into things like Copilot
01:22:33 <davr0s> EvanR the intention is to see how much it manages to monomorphise/inline
01:22:44 <EvanR> then you want to look at core
01:23:04 <EvanR> at various levels of optimization
01:23:08 <davr0s> think of how performance oriented users of C may sometimes examine assembly output,
01:23:16 <EvanR> thats exactly what core is for
01:23:42 <quick_dudley> Wouldn't tail recursion be really problematic to express in C? Or did it use inline assembly?
01:23:44 <EvanR> you can also examine assembly output but it wont look like anything
01:23:54 <davr0s> they might have a picture in mind of what asm they want ;   they use C as a metalanguage for generating asm. So imagine adding haskell as another layer.. thinking in 'strict haskell->C->asm'   
01:24:21 <davr0s> ditto when using C++ templates of course.. you have in mind 'this will sort of evaluate to this pattern that we understand in C..'
01:24:21 <EvanR> the exact use case youre talking about is where core comes in, you an idea of what you want the core to look like
01:24:38 <merijn> quick_dudley: That's why we had "the evil mangler"
01:24:39 <EvanR> final machine code will be completely incomprehensible
01:24:53 <davr0s> it will in the general case
01:24:55 <merijn> quick_dudley: An ugly perl script that fixed the assembly to eliminate tail recursion issues
01:24:56 <EvanR> (in haskell)
01:25:16 <davr0s> but imagine some specialized cases like 'ensuring it used vectorized SIMD well' .. looking for use of some key instructions
01:25:19 <quick_dudley> That's kind of horrifying
01:25:27 <davr0s> 'did I write it in such a way that it would vectorize'
01:25:32 <merijn> quick_dudley: Yes, why do you think it was called the "evil mangler"? ;)
01:25:42 <EvanR> yeah i think GHC doesnt do vectorizing
01:25:57 <merijn> EvanR: There's basic support for SIMD instructions but GHC doesn't do vectorisation
01:26:31 <davr0s> could you map 'float-4' to the 128bit simd registers ( i know modern simd is more SOA.. 8,16way etc..)
01:26:55 <davr0s> thinking of the console gamedev style of vector-maths libraries that do that in c++,
01:27:14 <EvanR> there are compiler primitives
01:27:17 <merijn> davr0s: If you like low level stuff like SIMD, the GHC.Prim module is very interesting to browse through sometime: https://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Prim.html
01:27:18 <davr0s> e.g. we'd have a layer of C++ classes with inline functions that map onto compiler intrinsics,
01:27:30 <EvanR> youd have to mess with all that manually 
01:27:32 <merijn> davr0s: That's a module containing all sorts of exposed low level primitives
01:27:35 <EvanR> or use RULES
01:28:00 <EvanR> and then youd look at core output to make sure it all worked
01:28:20 <davr0s> EvanR there are some cases where generated asm can be *smaller* than the high level code, when it's using SIMD well :)  (..in the cases where you've got the right instructions..)
01:28:31 <davr0s> although thats very, very rare..usually it is a mess 
01:28:55 <EvanR> yeah, but what i dont understand is you want a version of the code generation to look at that will not be actually used?
01:29:06 <EvanR> one that looks kind of like what a C compiler would output
01:29:17 <EvanR> but isnt reality
01:29:18 <davr0s> ok what you're telling me is 'haskell has it's own pipeline to get to asm'
01:29:35 <merijn> davr0s: GHC has two pipelines to asm
01:29:40 <davr0s> i would need to go through the process of developping an intuition about how that works,
01:29:41 <EvanR> yeah ghc programs look and work nothing like C compiler compiled programs
01:30:06 <EvanR> haskell -> core -> stg -> ???
01:30:06 <merijn> davr0s: "GHC -> Core -> STG -> Cmm -> asm
01:30:23 <merijn> davr0s: The asm part being either "LLVM ASM -> asm -> machine code" when using the llvm backend
01:30:34 <davr0s> what I'm thinking is a strict subset with the right monomorphization should be able to generate similar loops,     my original interest in FP started 8+years ago in console gamedev noting the 'map-like' mindset for getting things to work well on SIMD
01:30:37 <merijn> davr0s: Or just straight up generating machine code using GHCs custom backend
01:30:52 <davr0s> ok maybe 'inspecting the LLVM' is the way to go these days.
01:30:53 <EvanR> doesnt work like that because lazy evaluation 
01:31:23 <EvanR> it has a whole different compilation strategy
01:32:37 <davr0s> my overall sense is the lazy eval is a convenience for the general purpose code, but there should be the ability to generate more traditional loops (which might have ripped information from other places by virtue of laziness, but nonetheless ended up inlined)
01:32:59 <davr0s> i get the the majority of what haskell does is a million miles away from the C model
01:33:47 <merijn> davr0s: Incidentally, has someone brought up the STG paper yet?
01:33:54 <davr0s> nonetheless I also know that you can generate straightforward 'flat' C-like code from 'composable functional abstractions' in c++ .. i'm hoping haskell can do similar
01:34:09 <davr0s> i've heard that acronym, i haven't read it
01:34:32 <merijn> davr0s: STG = Spineless Tagless G-machine, the paper talks about "how do you turn lazy functional languages into asm"
01:34:43 <EvanR> your pieces of code that operate on unboxed data and use primitive ops should show some straight forward core output, im not sure how loops work though. what kind of recursion tricks you need to make that fast
01:35:08 <EvanR> somehow remove the recursion, make it explicit?
01:35:10 <merijn> davr0s: So if you're curious about code generation it's very interesting. Also a very easy/accessible paper, you only need *very* basic Haskell knowledge and a little asm/C/machine knowledge helps
01:35:32 <MarcelineVQ> erisco: interesting idea, thanks for sharing
01:35:56 <merijn> davr0s: https://pdfs.semanticscholar.org/5c70/ed80977204a5b84f1f02764d6c3b5d9b8185.pdf
01:35:59 <merijn> That one
01:36:54 <davr0s> i also recently watched a lecture by the haskell person where he explained things like 'systemF' (?) with the typeclass vtables being passed around and how it would do recursive specialization
01:37:34 <EvanR> also, ensuring a high level language is compiled to something like a idiomatic C loop doesnt directly assure you that its being compiled yet again to a fancy vectorized optimized piece of machine code
01:37:46 <EvanR> unless that part is being compiled with a fancy C compiler
01:37:56 <EvanR> so theres a lot of conceptual overhead going on
01:39:23 <EvanR> the same sort of "C doesnt matter" is going on in javascript these days
01:39:41 <davr0s> fair enough, but at the C level some of the SIMD stuff maps fairly directly through compiler intrinsics, e.g. checking that a 4x4 matrix multiply happens by the appropriate splats & vectorized multiply-add, or dot-products for row-major
01:40:04 <davr0s> javascript -> web assembly i guess ( i dont follow them in detail)
01:40:05 <EvanR> yeah youd hope the C compiler can do that for you
01:40:09 <merijn> davr0s: Right, but GHC is exposing those same intrinsics ;)
01:40:23 <EvanR> GHC cant, but you can use the instrinics yourself
01:41:40 <EvanR> i would hope a matrix library (as opposed to the language itself) could do all that for you
01:42:11 <EvanR> APLicative programming paper mentions the possibility
01:42:30 <davr0s> (i think you get what I'm talking about but for reference this is the sort of thing i mean .. https://github.com/erwincoumans/sce_vectormath/blob/master/include/vectormath/ppu/cpp/mat_aos.h  -  even if not literal assembly, c functions can map very closely )
01:43:23 <davr0s> what we basically did back then was more like using C as a fancy macro assembler (some would say C is usually like that :) but the use of intrinsics was lower level than traditional c/c++ code
01:43:24 <EvanR> yeah when you use primitives on unboxed values, you get close 
01:43:48 <EvanR> and use data with unpacked fields
01:44:02 <EvanR> array of unboxed foo
01:44:21 <merijn> Plus, if you really need SIMD you can just FFI to C quite easily :)
01:44:30 <davr0s> hah thats cheating
01:44:33 <MarcelineVQ> doesn't ghc have simds
01:44:40 <EvanR> yeah
01:44:44 <merijn> MarcelineVQ: Yes, but doesn't autogenerate them
01:44:50 <merijn> MarcelineVQ: And they're work in progress
01:45:09 <merijn> davr0s: Also, you might be interested in #numerical-haskell where all the numerical/high performance peeps hang out :)
01:45:45 <davr0s> i need a time machien to send this all back to 2006 aswell really
01:46:05 <ertes-w> helo
01:46:29 <davr0s> i'm probably overthinking some of this because you'd also use GPGPU today 
01:46:32 <merijn> People are always saying python is the ideal glue language for calling C code/libraries, etc. but I'm more and more convinced Haskell is the ideal glue language :)
01:46:51 <davr0s> i was just thinking that,
01:47:01 <MarcelineVQ> and if it's not: you can invent the ideal glue lanuage, inside of haskell? :>
01:47:23 <davr0s> snobbery prevents me from using conventient languages with GCs.. but haskells purity might get me over that and get me out of C/C++ where it isn't actually needed.
01:47:43 <EvanR> by this logic, haskell is god, since its good at new languages, just write the language that satisfies the problem in haskell first
01:48:17 <EvanR> heh, if you write tight loops in haskell that dont allocate... 
01:48:45 <EvanR> and there are no other threads, then the gc has no reason (or chance?) to run!
01:48:46 <merijn> davr0s: I do a lot of C and one of the things I love is that the Haskell FFI really requires almost no effort to interact with C (well, with one sidenote: mutating structs inside haskell is a PITA)
01:49:38 <merijn> davr0s: So if your C code doesn't require 1) passing structs by value or 2) mutating structs from within Haskell it's autmatically trivial. Mutating structs from within haskell is possible, but a bit annoying to set up
01:49:50 <merijn> Passing structs by value isn't possible, afaik
01:49:51 * ertes-w is waiting for the obligatory rust enthusiast to intervene
01:49:59 <EvanR> haha
01:50:02 <davr0s> can you generate structs that C can read, i presume
01:50:11 <merijn> davr0s: Sure
01:50:22 <merijn> davr0s: But you have to pass them by pointer
01:50:35 <EvanR> does rust have an SIMD story ?
01:51:09 <davr0s> i haven't looked in detail but there has been work on it, not stabilized 
01:51:12 <davr0s> they have been able to map some rust types to 'tuple-structs'
01:51:22 <merijn> davr0s: The annoying bit about structs is basically that you need to create a Storable instance for things and doing that portably is a bit of a hassle (there's like 10 billion tools for it, but getting it wroked out is kinda tedious the first time)
01:51:48 <EvanR> solution, FFI to the C code that mutates the struct for you
01:51:55 <merijn> EvanR: Yes :p
01:52:15 <davr0s> peek() poke() ? hehe
01:52:37 <ertes-w> i don't really get why Storable isn't derivable
01:52:52 <merijn> ertes-w: Because it supports non-obvious mappings too
01:52:52 <ertes-w> i feel like deriving portable instances mechanically should be possible
01:53:08 <cocreature> there are some packages that derive Storable via TH iirc
01:53:08 <EvanR> struct layout and portable   ?
01:53:15 <merijn> EvanR++
01:53:28 <cocreature> but tbh 95% of my Storable instances are for interacting with C code and at that point deriving is not what I want
01:53:30 <merijn> ertes-w: Struct layout is unspecified in the C standard
01:53:49 <ertes-w> yeah, good point
01:54:04 <EvanR> you can peek and poke wherever in the struct you want
01:54:05 <merijn> ertes-w: Also things like: Haskell argument and C fields not being in the same order, etc.
01:54:10 <EvanR> but where do you want
01:54:27 <davr0s> i haven't looked into haskells arrays but i'm aware it has them
01:54:31 <merijn> davr0s: I wrote a small library wrapping some pty operations that show how trivial interacting with C can be
01:54:43 <merijn> davr0s: We have more arrays than you can wave a stick at :p
01:54:53 <davr0s> i'm guessing there's such a thing as arrays that really will be blocks of memory that can be filled out 'strictly'
01:54:56 <ertes-w> davr0s: it has lots of arrays…  interestingly you need extra libraries for those =)
01:55:12 <EvanR> davr0s: thats one kind
01:55:23 <EvanR> the default is they dont have to filled out strictly!
01:55:29 <merijn> davr0s: It can be as simple as: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L283-L287 https://github.com/merijn/posix-pty/blob/master/cbits/pty_size.c
01:55:34 <davr0s> yeah i imagined there'd be both
01:56:16 <EvanR> the difference is, if you didnt fill it in somehow, its undefined and crashes, unlike C arrays
01:56:26 <ertes-w> davr0s: look into the 'vector' library, which is kind of the modern base on which all haskell arrays work
01:57:03 <EvanR> but you can get an unboxed array of uninitialized too
01:57:06 <ertes-w> davr0s: in most cases you can just use 'vector' directly…  it's usually when you want data parallelism that you use something built on top of it, like 'repa'
01:58:08 <EvanR> merijn: we have more <lots of stuff> than you can shake a stick at. this is actually sometimes a source of embarassment
01:58:23 <davr0s> something else i should look into, supposedly the 'wings3d' modeller uses erlang with some interesting functionally updated datastructure to handle it's undo stack;  i presume haskell could do similar..
01:58:39 <ertes-w> davr0s: Data.Sequence
01:58:52 <EvanR> a stack is a list!
01:59:09 <ertes-w> or even a list, if you only ever look at the head of the list
01:59:18 <EvanR> or pull out a maze zipper and dont get stuck in the undo stack mentality
01:59:34 <EvanR> keep all alternate histories
02:00:13 <EvanR> yeah the basic form of undo would be a zipper
02:00:17 <EvanR> so you can redo
02:01:07 <ertes-w> i tried hard to find a practical use for zippers, but i always had to look further than just the "current position"
02:01:42 <ertes-w> that's why i tend to prefer regular data structures, potentially with the help of lenses to "zoom in"
02:02:15 <EvanR> still part of the API would appear to be a zipper
02:02:23 <EvanR> doesnt need to be literally implemented that way
02:22:57 <jakub__> hi, would it be useful to allow type holes in signatures? e.g. ma :: Either _ String; ma = Right "yay!", making it a bit more explicit that the value is polymorphic ... it would probably be useful if you had too many unrelated free variables in your type, then you would not be forced to name them all
02:24:26 <quchen> jakub__: You can have typed holes in types
02:24:57 <quchen> jakub__: Haskell made the unfortunate choice of using »_« as a hole, and does not support a »meh, Compiler go fill it in«.
02:25:11 <MarcelineVQ> _meh
02:25:24 <quchen> jakub__: Agda has »?« for »hey I need to fill this out« and »_« for »Compiler, infer this for me, I can’t be bothered«
02:26:00 <quchen> There is no »this is fully polymorphic« placeholder though, you’ll have to add your own type variable for that.
02:26:05 <quchen> :t Left "hello"
02:26:07 <lambdabot> Either [Char] b
02:26:29 <jakub__> quchen: whenever i put "_" in my signature instead of a variable I got a compiler error :/
02:26:44 <merijn> You need -XPartialTypeSignatures, I think
02:26:52 <jakub__> merijn: I see, thanks
02:27:25 <quchen> Waitwaitwait.
02:27:37 <quchen> Partial type signatures mangle the _ in types to mean »hey compiler do this«.
02:27:58 <quchen> If you don’t enable PTSigs then _ behaves just like a hole in normal code.
02:35:44 <EvanR> a hole does cause a form of compile time error
02:35:51 <EvanR> its a feature!
02:42:28 <merijn> I forget, where is NonEmpty from?
02:46:25 <ertes-w> merijn: Data.List.NonEmpty
02:46:36 <ertes-w> it's in base now
02:47:00 <merijn> ertes-w: oh, neat
02:48:38 * hackagebot rot13 0.2.0.0 – Fast ROT13 cipher for Haskell. – https://hackage.haskell.org/package/rot13
02:48:38 * hackagebot plot-light 0.1.0.4 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
02:50:12 <ertes-w> the rot13 package feels like it should be named acme-rot13
02:50:29 <merijn> ertes-w: Why's that?
02:51:12 <ertes-w> because it feels a bit like this: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
02:52:16 <ertes-w> an utterly overengineered library for an utterly useless function =)
02:52:37 <merijn> ertes-w: Well, it's overengineerd in the sense that probably no one needs rot13 that fast
02:52:51 <merijn> But it doesn't seem overengineerd in the "not actually practical to use" sense
02:53:19 <merijn> And since I don't think there's a reasonable "more sensible" use for the rot13 library and it not being a joke I'm not sure making it an acme package is justified
02:53:30 <erisco> IntegerStringReturnerFactory, why didn't I think of that!
02:53:41 <ertes-w> i don't think you can make rot13 slow =)
02:53:49 <dysfun> sure you can
02:54:33 <dysfun> for a start you can rotate to an odd multiple of 13 and do it a character at a time
02:55:27 <dysfun> doing a few hundred thousand modular increments ought to make it a bit slower
02:56:27 * hackagebot simple-effects 0.9.0.1 – A simple effect system that integrates with MTL – https://hackage.haskell.org/package/simple-effects
02:57:18 <erisco> you just need to find an interesting bijection
02:58:22 <erisco> maybe encode letters as functions
02:59:11 <dysfun> and of course you can do it all as bitwise arithmetic
02:59:23 <erisco> letters to ordinals to church encoded Peano numbers
02:59:27 <dysfun> recreate module arithmetic in bits
02:59:45 <dysfun> modular*
02:59:59 <erisco> that ought to be convoluted enough for a chuckle
03:00:07 <ertes-w> dysfun: you have to do that deliberately though
03:00:26 <ertes-w> nobody implements rot13 by adding 39
03:00:29 <dysfun> you said you don't think you can make rot13 slow
03:00:36 <dysfun> i said sure you can
03:02:14 <erisco> can you find an exponential algorithm for it... hm...
03:03:04 <erisco> well, the rot13 of x is the letter after the rot13 of w
03:03:37 <erisco> that is just linear, if we're not acknowledging the constant of 26 letters... but some sort of recurrence like that is a start
03:03:40 <erisco> just have to get two terms in there
03:09:26 <erisco> what if you said the rot13 of x was the ordinal sum of rot13 w and rot13 y modulo 26, divided by 2
03:10:37 <dysfun> heh
03:14:28 <ertes-w> @let rot5 = traverse . letter ^~ 5
03:14:28 <lambdabot>  Parse failed: Ambiguous infix expression
03:14:47 <kuribas> is haskell programming on ios possible, if so painless?
03:14:56 <ertes-w> @let rot5 = traverse . letter %~ (^ 5)
03:14:56 <lambdabot>  Parse failed: Ambiguous infix expression
03:14:58 <ertes-w> what?
03:15:09 <ertes-w> :t (.)
03:15:11 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:17:43 <kuribas> :t (^)
03:17:45 <lambdabot> (Num a, Integral b) => a -> b -> a
03:17:48 <ertes-w> @let rot5 = over (traverse . letter) (^ 5)
03:17:50 <lambdabot>  Defined.
03:17:53 <ertes-w> lambdabot weirdness
03:18:12 <ertes-w> > rot5 "Hello World!"
03:18:14 <lambdabot>  "Lkhho Qoxhj!"
03:18:23 <ertes-w> > rot5 (rot5 "Hello World!")
03:18:26 <lambdabot>  "Hello World!"
03:18:26 <kuribas> it seems it shares my distaste for lens line noise :)
03:19:54 <kuribas> :t letter
03:19:56 <lambdabot> Applicative f => (Integer -> f Integer) -> Char -> f Char
03:21:13 <ertes-w> > "AbBxYz" ^.. traverse . letter
03:21:15 <lambdabot>  [0,1,1,23,24,25]
03:22:22 <ertes-w> > (traverse . letter +~ 13) "AbC!xYz!"
03:22:25 <lambdabot>  "NoP!kLm!"
03:23:03 <erisco> yeah, helps a lot here to edit a letter as an ordinal
03:23:11 <erisco> was defining helpers because I don't know lens :P
03:23:51 <kuribas> @hoogle letter
03:23:51 <lambdabot> Text.Parsec.Char letter :: (Stream s m Char) => ParsecT s u m Char
03:23:51 <lambdabot> Text.ParserCombinators.Parsec.Char letter :: (Stream s m Char) => ParsecT s u m Char
03:23:51 <lambdabot> Data.Attoparsec.Text letter :: Parser Char
03:26:40 <erisco> wheres the modulus such that -1 % 26 is 25
03:28:37 <kuribas> Is using haskell for ios development possible?
03:28:52 <ocramz> hullo!
03:29:42 <ertes-w> kuribas: i defined 'letter' secretly in lambdabot
03:30:05 <ocramz> can anyone suggest a template library, such as `ginger` but for plain text ?
03:30:38 <ertes-w> ocramz: functions?
03:30:50 <ertes-w> together with Text/ByteString Builder perhaps
03:31:21 <ocramz> ertes-w library called `functions` you mean?
03:31:53 <ocramz> or, I didn't understand
03:32:01 <ertes-w> ocramz: no, just functions
03:32:16 <ocramz> oh
03:32:17 <ertes-w> ocramz: a string template is a string that depends on other things, right?
03:32:35 <ocramz> yes
03:33:51 <ertes-w> so it's a function of those other things, right?
03:35:47 <ocramz> ertes-w yes I guess I wasn't clear enough; I do have a text format to follow ("Conf"), so there will be some parsing involved
03:37:19 <ertes-w> if ginger is anything like jinja2, it doesn't actually insist on SGML/XML
03:37:34 <ertes-w> ansible abuses it to the most unbelievable extent for regular strings
03:37:57 <ertes-w> (jinja2 that is)
03:38:22 <erisco> why is letter Applicative and not Functor?
03:38:46 <erisco> letter f = fmap chr . f . ord
03:39:27 <erisco> maybe it does some range conversion too, but that is the essence
03:41:43 <ertes-w> erisco:
03:41:51 <ertes-w> > 'a' ^.. letter
03:41:53 <lambdabot>  [0]
03:41:54 <ertes-w> > '.' ^.. letter
03:41:56 <lambdabot>  []
03:42:07 <ertes-w> it's not a lens, but a traversal
03:42:22 <ertes-w> so you can transparently map over all letters while leaving everything else alone
03:45:18 <erisco> okay
03:46:31 <ADG> why is this instantiation of tuple as an instance wrong: https://hastebin.com/ocilipoboy.lisp
03:48:37 <erisco> I am not quite sure what pattern I am looking for here... hrm
03:49:27 <srhb> :t (*)
03:49:28 <lambdabot> Num a => a -> a -> a
03:49:31 <srhb> ADG:  Same a on both sides
03:49:48 <quchen> ?tell merijn Good news everyone! It used to be quite outdated, missing over 2000 packages, but now we can install everything at once again with just one command!
03:49:48 <lambdabot> Consider it noted.
03:50:01 <srhb> quchen: Wonderful!
03:53:21 * hackagebot acme-everything 2017.7.10 – Install everything. – https://hackage.haskell.org/package/acme-everything
03:53:44 <srhb> I wonder if that package is explicitly banned in nixpkgs...
03:54:05 <quchen> I wouldn’t be surprised. Cabal, for all its strenghts, fails to find an install plan for it. :-(
03:54:13 <quchen> I think the reverse dependency search also banned it
03:54:21 <quchen> …finally, because acme-everything kind of broke it
03:54:38 <srhb> quchen: I think it might actually be hardcoded in hackage2nix :-P
03:54:41 * srhb goes digging
03:55:09 <ADG> then how about this... still no luck! https://hastebin.com/yejededopo.lisp
03:55:10 <srhb> quchen: https://github.com/NixOS/cabal2nix/blob/aa509294d45972582c63951698a68c65df654719/hackage2nix/Main.hs#L77
03:55:14 <srhb> You should be proud :-)
03:55:25 <quchen> Haha
03:55:32 <srhb> ADG: k must have the same type as (x,y)
03:55:44 <srhb> ADG: Because the type of (*) specifies that both arguments are the same type.
03:55:48 <ADG> so how can I define scalar multiplication
03:55:51 <quchen> It was just a joke package! I meant no harm. But really, a package should not be able to break any tools.
03:55:53 <srhb> ADG: Not using Num
03:56:07 <srhb> ADG: The type simply doesn't support it in any sane way.
03:56:11 <quchen> I’ve had multiple requests to take it down (or shrink it to an empty repo) because it broke stuff. But that’s a bug in the other software, really.
03:56:22 <srhb> ADG: You can make your own numeric type and then do some fiddly things to do that
03:56:42 <srhb> ADG: (ie data YourNum = Scalar Int | Vector Int Int)
03:56:47 <srhb> ADG: But it gets tedious very fast.
03:56:59 <ADG> thank you
03:57:01 <ADG> :)
03:57:27 <quchen> I must say I’m surprised by how well Git showed me the diff. I mean it was a list of 10000 packages with 2000 single-line changes and git diff was instantaneous.
03:57:31 <srhb> quchen: I'm going to stick with "Technically correct" on that one :-P
03:58:24 <srhb> quchen: Hah, github will not even render hackage-packages.nix
03:58:34 <quchen> ..?
03:58:37 <quchen> Why not?
03:58:39 <srhb> quchen: I suppose 7.9MiB is a bit too big :-P
03:58:43 <srhb> "(Sorry about that, but we can’t show files that are this big right now.)
03:58:51 <srhb> My browser would probably die anyway.
03:58:55 <quchen> Hmm, it renders my cabal file just fine https://github.com/quchen/acme-everything/blob/master/acme-everything.cabal
03:59:08 <quchen> Hackage has 12k packages right now I think
03:59:12 <srhb> quchen: Only 225KB :-)
03:59:24 <srhb> "only"
03:59:28 <quchen> Ah, cabal2nix includes the full derivations and everything?
03:59:35 <srhb> quchen: Yeah
03:59:37 <quchen> I see.
04:00:02 <quchen> One day I’ll bulid stackage-everything so we can finally install all of Stackage.
04:00:10 <quchen> (And have it build properly!)
04:00:12 <mpickering> I need to update my local copy of hackage if there are 12k packages now
04:00:23 <erisco> oh, my rot13 idea doesn't terminate, whoops
04:00:42 <quchen> mpickering: Graph size: 11505 nodes, 89313 edges
04:00:53 <quchen> That’s what my extremely dirty hacky graph program tells me
04:02:09 <mpickering> I tried to build all stackage packages once and it's harder than you would hope
04:02:45 <mpickering> you need quite a lot of c dependencies and cabal's solver doesn't like being passed 1000s of packages to install even with a cabal.config fixing all versions
04:03:41 <mpickering> I managed to do it with a nix expression eventually I think
04:04:12 <srhb> That's what hydra does anyway, isn't it?
04:10:10 <erisco> ah ha, I got it
04:19:37 * hackagebot ngx-export 0.5.0.0 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
04:29:57 <erisco> do we have an integral square root function?
04:36:12 <ps3> how would i sucessfully detect the host architecture on any distro even if the distro does not have uname or lscpu or lsb_release or perl or python
04:36:36 <Athas> cat /proc/cpuinfo?
04:36:47 <Athas> You might not have /proc, though.
04:36:56 <Athas> In a sufficiently restrictive sandbox I don't think you can.
04:37:05 <Athas> Except through side channel attacks.
04:37:40 <Ferdirand> have a copy of /bin/true for every possible architecture, and run them in order ? :)
04:38:17 <kuribas> :t floor . sqrt . fromIntegral -- erisco
04:38:18 <lambdabot> (Integral a, Integral c) => a -> c
04:38:39 <erisco> and do I not have to worry about FPE with that?
04:38:49 <kuribas> FPE?
04:38:52 <Ferdirand> ps3: jokes aside: it will have uname in the form of a syscall
04:38:57 <erisco> floating point error
04:39:26 <kuribas> erisco: it wouldn't work with large Integers.  And it's probably not very efficient too...
04:40:00 <erisco> wasn't interested in inefficiency... just wanted to know if there was a common lib with such a function
04:40:13 <Athas> erisco: you can go through Rational instead of a floating-point type.
04:40:20 <Athas> Rational is arbitrary-precision, so should have no problems.
04:40:25 <erisco> > let isqrt n = let Just y = find (\x -> x * x >= n) [0..] in y in isqrt 100
04:40:28 <lambdabot>  10
04:40:29 <erisco> not that hard to define
04:40:57 <kuribas> erisco: I think there isn't in the standard library
04:41:32 <erisco> Athas, what is the sqrt for rationals?
04:41:54 <Athas> Um.  I thought there was one.  Sorry.
04:42:13 <kuribas> erisco: you'd better use newton then...
04:42:30 <erisco> efficiency is completely unnecessary
04:42:42 <Athas> That's the FP spirit!
04:43:01 <erisco> I am purposefully being stupid...
04:44:01 * hackagebot ngx-export 0.5.0.1 – Helper module for Nginx haskell module – https://hackage.haskell.org/package/ngx-export
04:54:22 <erisco> @let isqrt n = let Just y = find (\x -> x * x >= n) [0..] in y
04:54:24 <lambdabot>  Defined.
04:54:35 <erisco> @let rot13 'a' = 'n'; rot13 z = let x = sum (fmap (ord . rot13) (init ['a'..z])) in chr ((1 + isqrt (8 * x + 47961)) `div` 2)
04:54:37 <lambdabot>  Defined.
04:54:42 <erisco> > rot13 'm'
04:54:45 <lambdabot>  'z'
04:54:49 <tdammers> in a way, yes - writing efficient code often involves allowing implementation details to bleed through, and that is something the FP spirit abhors
04:55:13 <erisco> that is my convoluted rot13, though it only works up to m... not sure how to be clever from here
04:55:43 <Athas> tdammers: I think it is something all principled languages abhor.  Pascal was like that, too.
04:55:50 <erisco> it is exponential though, so that is good
04:56:05 <Athas> A good language is one that makes it clear when such bleedthrough occurs, I think.
04:56:50 <erisco> to find rot13 'm' it must find all of rot13 'a' through rot13 'l'
04:57:12 <erisco> and when finding rot13 'l' must find all through rot13 'a' to rot13 'k', and so on
04:57:33 <erisco> or is that just quadratic =\
04:58:51 <erisco> > rot13 ['a'..'m']
04:58:53 <lambdabot>  error:
04:58:53 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
04:58:53 <lambdabot>      • In the first argument of ‘rot13’, namely ‘['a' .. 'm']’
04:58:58 <erisco> > map rot13 ['a'..'m']
04:59:00 <lambdabot>  "nopqrstuvwxyz"
05:02:17 <erisco> ah yes it is exponential, it doubles
05:02:45 <erisco> so if someone can figure out how to cleverly deal with the modulo we'll have the exponential rot13 algorithm
05:03:12 <erisco> > rot13 'n'
05:03:15 <lambdabot>  '{'
05:09:06 <erisco> there is ugly -97, % 26, +97 ... can bake -97 into the inverse function... not that fun though
05:09:36 <sepakorayl> I have a type family F z; type instance F a = ..; type instance F b= F a; why can't I use the two instances interchangeably ?
05:11:19 <kuribas> I thought the FP spirit is to have low level implementation at the bottom, and build abstractions on top of it?
05:12:42 <cocreature> the fp spirit is to write unreasonably slow code and defend that shitty code by calling it elegant
05:13:13 <kuribas> like functional qsort?
05:13:23 <cocreature> exactly
05:13:33 <Athas> That one was embarassing...
05:14:55 <kuribas> luckily haskell is a great imperative language :)
05:16:12 <Athas> Haskell is great for managing IO and concurrency and other such effects.
05:16:20 <Athas> Probably the best language for that purpose I've tried.
05:16:35 <Athas> It's a bit ironic.
05:16:51 <tdammers> cocreature: more like, write unreasonably slow code and leave a faster implementation as an exercise
05:17:35 <kuribas> tdammers: which then looks like C code
05:17:45 <kuribas> like everything on the benchmark game
05:18:49 <tdammers> or, alternatively, assume a reasonably smart compiler
05:18:49 <Athas> Some of those look OK; others not so much.
05:18:53 <hpc> Athas: haskell is my favorite imperative language :D
05:19:11 <Athas> Still, it's a useful property that you _can_ "cheat" in Haskell for those things that require low-level performance hacks.
05:19:24 <tdammers> haskell is my favorite language for building DSLs to model imperative languages
05:19:45 <tdammers> it also happens to come with a few really nice such DSLs included
05:20:12 <delYsid> Does diagrams have a ASCII art backend?
05:21:49 <delYsid> I need an (e)DSL for describing frontpanel layouts, for text only users.  I figure everything I'd invent would gravitate towards being a bad version of diagrams...
05:22:23 <Athas> Contrary to what people say, Haskell code also has predictive performance: it's slow. :-)
05:23:15 <tdammers> Athas: citation needed
05:24:43 <ventonegro> How can I apply mappend to a chain of calls to the reader applicative?
05:28:17 <cocreature> ventonegro: can you be a bit more specific?
05:28:39 <ventonegro> cocreature: heh, I guess that wasn't clear at all
05:29:17 <ventonegro> I want to use field accessors to compose a reader using <*>
05:29:17 <ertes-w> @tell erisco https://hackage.haskell.org/package/arithmoi-0.5.0.1/docs/Math-NumberTheory-Powers-Squares.html
05:29:18 <lambdabot> Consider it noted.
05:29:48 <ventonegro> And I would like to mappend all the returned field values
05:30:25 <ventonegro> I am trying to generate a Pandoc document, and the Pandoc types are monoids
05:30:31 <cocreature> just "fmap mconcat" over the list of field values?
05:31:35 <ventonegro> cocreature: It's more like `mconcat <$> field1Text <*> field2Text <*> ...`
05:31:57 <cocreature> I think I still have no idea what you are trying to do
05:32:02 <cocreature> what’s the type of field1Text?
05:32:37 <cocreature> "(MonadReader r m, Monoid a) => m a"?
05:33:25 <ventonegro> cocreature: record field accessors, the record is the reader environment
05:34:25 <cocreature> fmap mconcat . sequence [field1Text, field2Text]?
05:34:37 <cocreature> eh needs more parenthesis
05:34:39 <cocreature> but you get the idea
05:35:57 <ventonegro> cocreature: Indeed, I do, thanks :)
05:40:51 <cocreature> oO "Pattern match checker exceeded (2000000) iterations in"
05:40:55 <cocreature> ghc doesn’t like me today
05:43:17 <Athas> How'd you make that happen?
05:44:39 <cocreature> I’m not even sure
05:44:46 <cocreature> for some reason it doesn’t like my pattern match
05:45:17 <mnoonan> I've hit that with a pattern match on a very large sum type (> 1000 ctors), but I assume that's not your case?
05:45:52 <cocreature> nope, everything has < 50 constructors
05:46:03 <cocreature> I’ll digg into the cause some other time.
06:10:32 <mpickering> Anyone recognise this error, I've never seen it before https://www.irccloud.com/pastebin/XFUCCP8G/
06:11:16 <merijn> mpickering: Looks like that package was built using newer dependencies than you have visible or something like that?
06:12:24 <mpickering> That package being dlist?
06:12:47 <merijn> yeah
06:12:53 <merijn> Just a blind guess, though
06:19:57 <mpickering> This version of GHC I built is not standard, building with -j1 "fixes" the problem
06:20:54 <ps3_> see if this detects x86 on x86 https://bpaste.net/raw/d323a17d6fd4 (hopefully all downloads should be commented out of the script or removed) (writen in bash)
06:21:27 <cocreature> ps3_: was that intended for some other channel?
06:22:46 <ps3_> no
06:23:12 <cocreature> what does a large bashscript have to do with Haskell?
06:24:30 <ps3_> see if it detects x86 on x86
06:26:01 <srhb> Suspect.
06:26:11 <ps3_> ?
06:26:35 <srhb> Posting large shell blobs in #haskell that seem completely unrelated to Haskell and asking people to run it.
06:27:11 <merijn> srhb: That's why you have a few VMs lying around ;)
06:27:23 <cocreature> merijn: or just don’t run random bashscripts :)
06:27:32 <srhb> Yeah, I'm going with the latter :-P
06:27:34 <merijn> cocreature: You're no fun :)
06:28:00 <srhb> I think the fascist laws here might actually hold me accountable for just visiting some websites.
06:28:05 <srhb> :-)
06:28:17 <ps3_> lol
06:28:18 <cocreature> merijn: I’m too old for this stuff
06:28:55 <ps3_> how does haskell detect its host architecture
06:29:00 <mpickering> merijn: I actually had to pass -v1 to GHC and that sorted out the problem..
06:29:04 <merijn> ps3_: Why would it detect that?
06:29:05 <mpickering> seems unusual
06:29:42 <ps3_> why
06:31:14 <JuanDaugherty> false assumption of binary portability
06:32:04 <ps3_> what you mean
06:32:54 * Clint snores.
06:34:16 <quchen> Aaaanyway, we won’t run your bash script, and it has nothing to do with Haskell, so let’s just end this.
06:39:17 * hackagebot hsparql 0.3.4 – A SPARQL query generator and DSL, and a client to query a SPARQL server. – https://hackage.haskell.org/package/hsparql
06:45:31 <ertes-w> ps3_: could you rewrite that to haskell?
06:45:40 <ertes-w> bash is so difficult to read
06:46:28 <Benzi-Junior> does anyone here know of a nice library for Directed Acyclic Graphs which works nicely with incrementally building the graph ?
06:47:02 <ertes-w> i think i saw a semilattice library somewhere
06:48:12 <mikail_> Does anyone here have experience with developing commercial blockchain applications in Haskell?
06:48:42 <hoppfull> Hello, I'm trying to use Hackage as a reference for modules found there. This namespace (http://hackage.haskell.org/package/OpenGL-3.0.2.0/docs/Graphics-Rendering-OpenGL-GL.html) has loads of functions but they don't show on that page. If I check it out in GHCI I see all the functions (there are many) but it is unwieldy to work with GHCI in that way. Am I missing something about this hackage web site? Usually it lists module members
06:50:10 <ertes-w> hoppfull: see all the "module" lines there?
06:50:20 <ertes-w> it reexports stuff from other modules
06:50:21 <merijn> mikail_: I don't think many have experience developing commercial blockchain applications period :p
06:51:55 <ertes-w> hoppfull: for example it reexports Data.ObjectName, which means that definitions from Data.ObjectName will be accessible by importing this module
06:56:37 <hoppfull> ertes-w: Okay! Thanks, mate!
06:57:31 <mikail_> merijn, relatively speaking that's true. In the UK, I would say a significant number of Blockchain gigs ask for Haskell. I just wanted to know exactly how Haskell is being used. Is it to code the data structures behind Blockchain, the crypto stuff or just writing DSL for smart contracts etc.
06:58:13 <merijn> mikail_: I think it's just a combination of banks investing both in Haskell and blockchain stuff atm :)
06:58:32 <merijn> mikail_: My guess is "most if not all of it"
06:59:43 <mikail_> merijn, yeah I think so too. I'm going to give Haskell another try (4th time) and I wanted to see where I should be directing my efforts - I'm staying clear of Category Theory this time - What a rabbit hole that was!!
07:00:23 <merijn> mikail_: Yeah, category theory is interesting in a curiosity sense, but the persistent internet myth that Haskell is based on category theory is basically BS
07:00:56 <merijn> I'm amazed by how persistent that story is, considering how obviously false it is >.>
07:01:28 <tdammers> fsvo "based on"
07:01:34 <mikail_> merijn, I would say there is a connection but from a day to day coders perspective I don't think it has any value
07:01:39 <kuribas> How can I defer type errors in the editor (emacs)
07:01:42 <Athas> mikail_: I doubt anyone is writing the crypto in Haskell.  I know some who used Haskell to implement a compiler for a smart contract language that targeted the Ethereum VM.
07:01:58 <tdammers> the influence is undeniable; what is a total myth is that you'd need to know anything about CT in order to master Haskell
07:02:02 <merijn> mikail_: There is a connection in the sense that "we stole some jargon from CT", but most of Haskell isn't based on CT
07:02:15 <mikail_> I've got myself Chris Okasaki's book and Simon Marlow's book - hopefully I can get some good mileage out of them
07:02:36 <mikail_> Athas, interesting
07:02:38 <kuribas> https://www.reddit.com/r/haskell/comments/6lt1rc/zurihac_2017_stephen_diehl_on_modern_cryptography/
07:02:43 <merijn> tdammers: I disagree, except from a few tiny bits that Wadler stole from the CT martians, not a lot is based on CT
07:03:56 <mikail_> One thing I did find funny is that Monad Transformers have no CT basis whatsoever
07:04:12 <mikail_> They're just a hack but a damn useful one if you are using Monads everywhere
07:04:34 <merijn> Monad transformers can be generalised to the CT notion of natural transformations, iirc
07:07:18 <mikail_> merijn, yeah I can't recall where I go that from but it did stick in my mind - I think it was Edward Kmett
07:19:20 <petejohanson> I'm trying to map a State s m a -> State s' m a where s' is a type I can create using the current state value of s.
07:19:23 <petejohanson> StateT*
07:19:53 <petejohanson> mapStateT maps new types for the wrapped monad and return value... but requires preserving the type 's'.
07:20:27 <petejohanson> I can runStateT first and get back an m (a, s) but I'm not sure how to convert that to a StateT s' m a from there.
07:21:55 <quchen> petejohanson: Can you come up with a function :: Monad m => m (a,s) -> m (a,s')?
07:22:38 <jle`> note that to write such a function, you need both an (s -> s') AND an (s' -> s), somehow
07:22:56 <quchen> Huh?
07:22:58 <quchen> How so?
07:23:15 <jle`> s appears in both the positive and negative position for (s -> m (a, s))
07:23:34 <petejohanson> quchen: Yes, I can.
07:23:46 <jle`> so to turn an (s -> m (a, s)) into an (s' -> m (a, s')), you need a way to pre-map the input s (an s' -> s) and also a way to re-map the output s (an s -> s')
07:23:51 <petejohanson> There is extra "metadata" attached to s' that can be added/removed as necessary.
07:24:00 <quchen> jle`: Ah, right.
07:25:14 <jle`> petejohanson: but yeah, your "big picture" will be zoomState st = StateT $ \s -> ...
07:25:26 <ertes-w> CT and haskell are like vector spaces and quantum mechanics…  it just happens to be a good model
07:25:41 <petejohanson> I'm already fmap'ing the runStateT output so I've got m (a, s') but that didn't seem to help...
07:25:43 <jle`> the easiest way to create your resulting StateT is to just use the constructor directly here
07:26:27 <petejohanson> jle`: But how do I extract the (a,s') from the monad 'm' wrapper to use the StateT constructor?
07:26:32 <jle`> you don't need to
07:26:34 <jle`> just fmap it
07:26:39 <lambdamu> I sometimes use zoom from the lens package to operate on sub states FWIW
07:26:47 <jle`> well, i use the StateT constructor here directly
07:26:53 <quchen> :t state
07:26:55 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:26:56 <jle`> but yeah, you're basically re-impelemnting the functionality of 'zoom' from lens
07:27:08 <jle`> petejohanson: you can directly use the StateT constructor
07:27:18 <petejohanson> Yeah, I haven't dug into lenses enough to grok them fully yet
07:27:23 <petejohanson> <- haskell newbie.
07:27:35 <jle`> if you want to have something that you can use now, just use zoom from lens
07:27:47 * quchen recommends avoiding lenses until your goal is explicitly learning about them.
07:27:47 <jle`> if this is learning experience, then you're free to still think about it
07:28:04 <petejohanson> jle`: Yeah, thanks.
07:28:08 <quchen> Lenses are great to get shit *done* when you know them, and great for getting *shit* done when you don’t.
07:28:15 <jle`> hehe
07:28:22 <petejohanson> heh.
07:28:40 <lambdamu> petejohanson: The examples aren't too bad: https://www.stackage.org/haddock/lts-8.22/lens-4.15.1/Control-Lens-Zoom.html#v:zoom
07:28:42 <jle`> petejohanson: one way to achieve what you want ehre is to have both a "getter" and a "setter" from your original state type
07:28:59 <jle`> but yes, writing it from scratch is probably a lot less complicated than just using zoom from lens
07:29:21 <jle`> so if you have a `getter :: s -> s'`, and a `setter :: s' -> s -> s`
07:29:37 <edwardk> mikhail each monad transformer individually has a category theoretic justification, and in aggregate there is the existence of a monad homomorphism for lift
07:30:10 <lambdamu> quchen: I started using the strict subset view, set and modify and then gradually expanded that subset, I think that works quite well
07:30:14 <jle`> you can see how you can use them in `zoomState st = StateT $ \s -> _`
07:30:24 <jle`> by just following the types
07:32:02 <edwardk> quchen: tell us how you really feel. don't hold back ;)
07:32:55 <jle`> petejohanson: the type of 'zoom' that's relevant to you is zoom :: Lens' s t -> StateT t m a -> StateT s m a
07:33:17 <jle`> where you can imagine `Lens' s t` as an abstract data type that contains both the setter and getter you need to get the job done
07:33:56 <merijn> The problem with lens is that 80% of the time I think "this is problem lenses are suited too" I can't ever figure how to fit the pieces together to do what I actually want >.>
07:34:41 <jle`> petejohanson: but yes, for learning, it might be useful to write zoom yourself to see "why" you need both a getter and setter, and how they are used
07:34:41 <glguy> that sounds like a problem with merijn  not lens
07:35:03 <merijn> glguy: I program Haskell because I'm dumb, lens expects me to be smart >.<
07:35:04 <jle`> petejohanson: manualZoom :: (s -> t) -> (t -> s -> s) -> StateT t m a -> StateT s m a
07:35:25 <jle`> er, with a Monad m constraint of course
07:36:08 <jle`> manualZoom should have enough to get the job done; once you write it, then you might be more comfortable using 'zoom' from lens
07:36:28 <jle`> since it's essentially doing the same thing, but getting its (s -> t) and (t -> s -> s) from the `Lens' s t`
07:36:29 <petejohanson> Yeah, thanks. I will give that a shot.
07:37:06 <edwardk> the t -> s -> s function is the key insight you were missing. its how to put the t back into the s you started with
07:37:28 <jle`> manualZoom get set st = StateT $ \s0 -> do
07:37:30 <jle`>     ...
07:40:13 <jle`> i...believe you might actually only need a Functor constraint, and fmap.  but the do notation version might be a bit easier to hack out
07:42:34 <shapr> ezyang: did you draw the illustrations in http://blog.ezyang.com/2011/04/the-haskell-heap/ ? I really enjoy them, for whoever drew them.
07:43:15 <dolio> jle`: If you turn on ApplicativeDo, the do notation might just require functor.
07:43:27 <dolio> If you write it exactly right.
07:44:13 <lerax> Anyone experienced problems using haskell-mode @ emacs on Windows 10? I have multiple issues here :/. Crash on load files, don't start inferior-haskell (exits with error 66). Just a complete hell. I know probably this is not the right place to talk about that, but I'm just sad (whatever, no ones care anyway).
07:47:17 <ezyang> shapr: Yes I did :) 
07:47:58 <lambdamu> lerax: You might have more success using intero, but no promises
07:53:49 <whald> hmm, looking at the type and documentation of Control.Concurrent.Async.waitAnyCatchCancel i was living under the impression that it only takes care of the termination/interruption of the Asyncs that are passed to it, but does not handle exceptions for the thread calling waitAnyCatchCancel
07:55:03 <whald> i was wrong, doing a killthread with the thread calling waitAnyCatchCancel, to my surprise, also returns something of the form (_, Left _)
07:55:51 <lerax> lambdamu: thanks for the sugestion, i'll look into it.
07:56:01 <whald> can this be considered a bug?
07:58:32 <ertes-w> whald: yeah, that sounds like a bug
07:59:10 <Cale> wait what?
07:59:39 <Cale> How does the thread which is calling waitAnyCatchCancel throw an exception *while* executing that?
08:00:04 <Cale> Do you mean, it's asynchronously thrown an exception by another thread?
08:00:52 <whald> Cale, some other thread, which is neither one of the Asyncs passed to waitAnyCatchCancel nor the thread calling waitAnyCatchCancel throws an async exception to the thread calling waitAnyCatchCancel. wow, that sounds interesting...
08:01:40 <Cale> Well, it looks like it should cancel all the asyncs in that case
08:03:25 <lambdamu> Cale: Isn't that what withAsync would be for?
08:03:27 <whald> Cale, hmm, that seems reasonable. but then i'd argue it should also re-throw the original exception
08:03:32 <Cale> I think I'd consider that a documentation bug. It's probably smarter to cancel them all
08:03:45 <Cale> It will
08:04:17 <Cale> At least, that's what my reading of the code would suggest, maybe I'm missing something
08:04:57 <whald> o_O i'll investigate some more and maybe file a bug
08:07:22 <Cale> whald: You're saying it terminates with a Left in that case?
08:07:44 <whald> Cale, yes, that's what i see
08:12:17 <whald> Cale, scratch that, stupid me emits identical log messages for both cases and everything's fine with waitAnyCatchSTM. sorry. :-(
08:13:17 * hackagebot plot-light 0.1.0.5 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
08:13:57 <lerax> lambdamu: I installed intero, but unfortunelly it uses haskell-mode as backend for another functionalities (as repl handling). So I got my bugs back. The solution for now is use emacs+haskell only on linux... On windows I can use Sublime, but I just will missing the great REPL integration on emacs. 
08:16:37 <lambdamu> lerax: I don't think intero uses haskell-mode for anything critical, certainly not for repl handling
08:21:25 <Geraldus> cocreature: Your suggestion about .| was right
08:21:38 <Geraldus> cocreature: Thank you!
08:22:48 <Cale> whald: Oh, good to know
08:23:05 <Cale> whald: It's hard to tell with this stuff sometimes, async exceptions are kind of scary
08:28:29 <NemesisD> class Foo a; type Bar a; defaultBar :: Bar a results in "couldnt match expected type Bar a with actual type Bar a0". is there any way to disambiguate that a? the only way I've found so far is to change that type to a data
08:29:46 <jle`> you get the same issue with typeOf/ec.
08:29:55 <jle`> try defaultBar :: p a -> Bar a
08:30:20 <NemesisD> why doesn't it come up with a data though?
08:30:21 <jle`> or also leave it as it is, turn on AllowAmbiguousTypes, and do defaultBar @MyFooInstance
08:30:29 <jle`> becuase it's able to infer the type of 'a' from 'Bar a'
08:30:35 <jle`> data families are always injective
08:30:54 <jle`> in your case, two different types might have type Bar a = Int
08:31:11 <jle`> instance Foo Bool where type Bar Bool = Int
08:31:18 <jle`> instance Foo Double where type Bar DOuble = Int
08:31:27 <jle`> so what instanace would `defaultBar :: Int` use?
08:31:37 <jle`> the Bool instance, or the Double instance?
08:31:43 <NemesisD> oh ok, that makes sense. i guess i'll see how this plays out with data. maybe this path is wrong in the first place
08:31:52 <jle`> for data families, it's always unambiguous what typeclass instance is being used
08:32:19 <jle`> instance Foo Bool where data Bar Bool = FooBool Int
08:32:28 <jle`> instance Foo Double where data Bar Double = FooDouble Int
08:32:32 <NemesisD> so i'm working on a logging library that uses an elasticsearch client library. that library has 2 completely distinct modules and types for the 2 protocol versions it supports, i want my users to be able to select which protocol version in a config
08:32:45 <jle`> `defaultBar :: Bar Bool` will let you infer that yo're using the Bool instance
08:33:14 <jle`> you can have something similar to injective associated types by just using fundeps
08:33:26 <jle`> instance Foo fooconfig a | a -> fooconfig where
08:33:40 <jle`> er, maybe, to match the earlier language, `instance Foo bar a | a -> bar where`
08:33:42 <NemesisD> so right now i'm creating a typeclass for the subset of the API I use and associated data types for the types involved in those APIs, e.g. class ESVersion v where data IndexName v; indexExists :: IndexName v -> m Bool
08:35:19 <NemesisD> if this goes well, the user won't necessarily even need to be exposed to this typeclass, i'll just have empty data decls for V1, V5, and having a Config V1 will decide all the V1-specific types  they need to specify
08:40:50 <kuribas> Can you set defer typed holes as a pragma?
08:41:29 <kuribas> Or set it to be default?
08:42:24 <merijn> kuribas: option in cabal file?
08:42:31 <merijn> kuribas: Also, GHC_OPTIONS pragma
08:43:04 <kuribas> right
08:49:05 <kuribas> hm, it's OPTIONS_GHC actually
08:49:30 <merijn> That seems like an unwise options to set like that, though :)
08:49:42 <merijn> kuribas: Then you're basically back to using undefined as placeholder :p
08:50:16 <kuribas> yeah, I'd prefer to have it set in emacs
08:50:56 <glguy> I like using -fdefer-type-errors when loading a module in GHCi so that I can see the warnings for the holes but still have access to the types of things that are finished
08:51:02 <merijn> kuribas: With hdevtools/ghcmod you can specify extra GHC flags in vim config files, I can't imagine that not working in emacs somehow
08:51:18 <kuribas> I use flycheck...
08:52:08 <sproingie> intero should pick up cabal flags
08:52:16 <kuribas> hm, flycheck-ghc-args might work
08:53:34 <kuribas> great, it works :)
08:54:33 <Jackoe> \quit
08:54:36 <Jackoe> whoops, my bad
09:01:38 <stelleg> anyone know to have a sort of Num instance for a Kind? I prefer to work with peano nats at the type level but writing a conversion from GHC.TypeLits.Nat is kind of a pain
09:02:16 <stelleg> how to have*
09:13:28 <saurabhnanda> I'm trying to understand how the error/exception mechanism in Control.Exception works with Control.Monad.Except. What should be the output of ==> runExceptT $ (throw Overflow :: ExceptT e IO String) `catchError` (\ _ -> return "work") ==> and why?
09:15:04 <jle`> what happens when you try it?
09:15:23 <jle`> stelleg: do you mean a Num class?
09:15:28 <jle`> ah i see
09:15:39 <saurabhnanda> jle`: is that for me?
09:15:42 <jle`> yeah, you need to lift functions to type families
09:15:44 <jle`> saurabhnanda: yes
09:15:51 <jle`> stelleg: the singletons library offers such a "kind family"
09:16:01 <jle`> a typeclass with a bunch of type families for Num-like things
09:16:04 <jle`> Num-like kinds
09:16:07 <saurabhnanda> jle`: an uncaught exception is thrown in the REPL. I was expecting it to get caught.
09:17:27 <lyxia> `catchError` catches the e part of ExceptT e IO String. It's oblivious to IO having exceptions.
09:18:56 <lyxia> The relevant instance is   Monad m => MonadError e (ExceptT e m)
09:19:21 <saurabhnanda> lyxia: hmm, wait.... what?!
09:19:30 <lerax> lambdamu: I was wrong! Intero works very well on Windows and has integrated separated repl function as well. But I need to setup first the stack for build the haskell part from source. I was wondering how dificult was made a hybrid plugin with elisp and haskell. But, anyways, now my haskell enviroment on windows is great, really thank you! 
09:20:00 <jle`> saurabhnanda: `ExceptT e` is a way to add on error behavior wit an error of type 'e' to a monad
09:20:03 <saurabhnanda> lyxia: does that mean if I'm in ExceptT, I have to be careful of regular IO errors thrown via `error` or `throw` AND the ones via `throwError`?
09:20:14 <saurabhnanda> jle`: ^^
09:20:22 <jle`> it doesn't modify the error behavior of the monad it is modifying
09:20:33 <lyxia> saurabhnanda: yes
09:20:34 <saurabhnanda> is there anything which unifies these to error mechanisms?
09:20:34 <jle`> it adds on a new erroring pipeline
09:20:51 <saurabhnanda> aargh, what's the use in that case?
09:21:08 <jle`> one use case is to add an error pipline that doesn't have one
09:21:12 <jle`> like ExceptT e (State s)
09:21:18 <jle`> or ExceptT e []
09:21:28 <jle`> *add an error piplien to a monad that doesn't have one
09:21:29 <saurabhnanda> but one error pipeline always exists, right? just use throw or error?
09:21:49 <jle`> error is sort of throwing away all reason anyways
09:22:03 <jle`> yes you can always have bottom as any value
09:22:15 <saurabhnanda> jle`: "error is sort of throwing away all reason anyways" >> didn't understand this.
09:22:28 <jle`> it's basically giving a middle finger to the type system
09:22:45 <jle`> error isn't really meant to be used as a control flow mechanism
09:23:45 <saurabhnanda> but if we have a monad, it generally has a short-circuiting behaviour, eg. Maybe or Either. Why do we need another short-circuiting option?
09:23:53 <jle`> usually you don't
09:24:00 <jle`> which is why people don't use ExceptT with Maybe or Either
09:24:11 <jle`> like, not all functions are useful for all values
09:24:53 <saurabhnanda> so, in a wwebapp, what should the core domain libraries that have nothing to do with ServantErr, return?
09:25:01 <saurabhnanda> what's the design recommendation here?
09:25:47 <lyxia> saurabhnanda: there are no errors in State and Maybe's Nothing is not descriptive.
09:26:25 <jle`> btw, this is also why 'ExceptT e IO a' is considered an anti-pattern to some
09:26:47 <saurabhnanda> lyxia: is it essentially a sexier form of a goto or a longjmp in those cases?
09:27:07 <saurabhnanda> jle`: and right now my app is FULL of that anti-pattern, it seems
09:27:18 <saurabhnanda> type AppM = ExceptT AppError (ReaderT Env (LoggingT IO))
09:27:27 <saurabhnanda> which in some senses, is being forced downwards by Servant.
09:27:38 <lyxia> ExceptT makes it clear to the user that some errors are to be handled.
09:28:11 <jle`> then why not just use IO (Either e a)
09:28:32 <saurabhnanda> lyxia: only if it is used "in the small", right? If it is used "in the large" then you can continue lifting stuff into the master ExceptT monad without realising that you have to handle interim errors.
09:28:48 <lyxia> jle`: that works better, I guess
09:28:58 <lyxia> I mean, yours
09:29:33 <saurabhnanda> jle`: what is your suggestion for an AppM monad?
09:29:45 <jle`> it depends on what you want to do with it
09:29:59 <jle`> but why not just `ReaderT Env (LoggingT IO)`
09:30:19 <jle`> if you want to integrate the pipelines
09:30:21 <Jackoe> \quit
09:30:23 <saurabhnanda> the core app for domain libraries which needs a reader environment, primarily and which needs to finally integrate with servant handlers.
09:30:25 <jle`> you can just throwIO :: AppError -> IO a
09:30:36 <jle`> you can throw AppError's as IO exceptions
09:30:40 <saurabhnanda> throwIO? is that different from throw?
09:30:58 <jle`> yes don't use throw
09:30:58 <saurabhnanda> A variant of throw that can only be used within the IO monad.
09:31:09 <jle`> throwIO is an IO action
09:31:18 <jle`> whose action is to trigger the runtime exception system that ghc's IO has
09:31:23 <jle`> 'throw e' is bottom
09:31:33 <saurabhnanda> The throwIO variant should be used in preference to throw to raise an exception within the IO monad because it guarantees ordering with respect to other IO operations, whereas throw does not.
09:31:41 <saurabhnanda> yes, got it
09:31:43 <jle`> semantically they are different things to me
09:31:44 <saurabhnanda> so, throwIO it is
09:31:48 <jle`> throw is like undefined, basically
09:32:02 <jle`> throwIO is an IO action, like 'putStrLn "hello"' or 'getLine'
09:32:08 <stelleg> jle`: thanks, I'll check that out
09:32:29 <jle`> subz[m]: but in this way you'll sort of sink all mention of AppError from your type
09:32:31 <jle`> * saurabhnanda 
09:32:56 <jle`> so in a way it's not ideal either
09:33:09 <jle`> but it does allow you to integrate both error pipelines
09:33:31 <jle`> there are some 'checked IO exceptions' library that allow you to selectively require certain IO exception types to be checked
09:33:47 <saurabhnanda> jle`: I'm not sure if I need to use ExceptT "in the large"
09:33:49 <jle`> which is kind of cute
09:34:20 <saurabhnanda> as in, should most of my domain functions be "foo :: inp1 -> inp2 -> ExceptT e m a"
09:34:42 <jle`> sometimes it's convenient to use ExceptT internally
09:34:53 <jle`> if you have a bunch of IO (Either e a)'s and waht to chain them
09:34:55 <jle`> *want
09:35:07 <jle`> and you don't want a bunch of nested case statements and pattern matches
09:35:16 <saurabhnanda> jle`: yes, that's what I'm finally understanding. It makes it easier to merge an Either behaviour with another monad for a small part of your system, right?
09:35:25 <jle`> yes that's how i mostly use it
09:35:37 <jle`> but there are other opinions too i'd imagine
09:35:55 <saurabhnanda> where would said **design guidelines** be documented?
09:36:15 <jle`> well, there are a few general "best principles for error handling" guidelines out there
09:36:21 <jle`> most of them wouildn't involve ExceptT
09:36:26 <jle`> (i'd think)
09:37:07 <sproingie> lot of the guidelines out there are obsolete
09:37:58 <saurabhnanda> hmmm... this is a pretty important thing for me to get right for the core architecture. whatever is used now will be replicated throughout the codebase.
09:38:26 <sproingie> could do worse than ExceptT
09:39:19 <sphinxo> so I'm writing  an html layout engine and i'm trying to work out how best to do the part where you go from:
09:39:44 <sphinxo> <b> <p> some text </p> </b> 
09:39:48 <sphinxo> to
09:40:44 <sphinxo> a flat list of blocks, in this case it'd just be [Block {bold=true, text="some text"}]
09:40:58 <sphinxo> like flattening the tree
09:41:09 <saurabhnanda> sphinxo: interesting
09:41:15 <saurabhnanda> sphinxo: what are these "blocks" you speak of?
09:41:53 <sphinxo> to keep things simple, just blocks of text at the moment
09:42:16 <sproingie> sounds like you're looking for a parser
09:42:20 <sphinxo> like a paragraph
09:42:25 <koala_man> do you have the AST already, or just the string?
09:42:36 <sphinxo> I already have the ast
09:42:59 <sphinxo> but not with parent attributes applied ( or something like that )
09:44:09 <koala_man> I'm not sure that this is a good way to go. There's a lot about HTML that I don't think can be well represented as a flat list
09:46:31 * hackagebot ease 0.1.0.0 – Robert Penner's easing equations – https://hackage.haskell.org/package/ease
09:47:23 <sproingie> walk the tree, pass the current attributes as a map as you visit each node
09:47:59 <sphinxo> koala_man: in this case I just want to get something basic working, I'll have to deal with that stuff later 
09:48:24 <sproingie> said attributes should just be the ones you're interested in, since "bold" isn't any kind of CSS attribute, that's just a parent node
09:48:46 <sproingie> i.e. don't try to reinvent CSS, those attributes are private to your own scheme
09:49:10 <sphinxo> so passing down a state that gets updated
09:49:41 <sproingie> pretty much.  not necessarily using StateT or anything though, just pass it explicitly
09:49:46 <sphinxo> yeah
09:49:49 <sphinxo> ok thanks
09:50:42 <saurabhnanda> sphinxo: or look at something like html-blaze for a starting point
09:55:07 <stelleg> is there a way to hide type operators?
09:55:28 <crobbins> not import/export them?
09:55:39 <crobbins> define hide?
09:55:49 <stelleg> import GHC.TypeLits hiding ((^))
09:55:52 <stelleg> for example
09:55:56 <stelleg> doesn't seem to work
09:56:37 <glguy> Try  import GHC.TypeLits hiding (type (^))   with -XExplicitNamespaces
09:57:14 <stelleg> glguy: thanks, that did it
10:52:07 <mikail_> exit
10:58:24 <rockbmb> Hello #haskell; I have a question about `stack test --coverage`. I have a project with several subprojects (i.e. aside from `src/` there are other folders, say, `a/, b/` and `c/` each with their own cabal files) and only one test suite in `test/`. How can I include every module in the produced coverage report, not just from `src/`?
11:01:57 <codedmart> What is the best way to get the root path of a project in haskell?
11:02:43 <ReinH> codedmart: why?
11:04:41 <codedmart> ReinH: I have different stack projects that one is using the other. Say project a and project b. Project b is using project a. Project a reads a config file. Which works fine when stack runs project a from project a dir. But project b is in another dir and when stack runs project b an error happens because the config file is not in project b dir.
11:04:47 <codedmart> Does that make sense?
11:14:25 <ReinH> codedmart: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
11:14:31 <ReinH> Cabal has a thing for that.
11:36:30 <NemesisD> what's that extension where data constructors are automatically lifted to the type level?
11:36:38 <lyxia> DataKinds
11:36:48 <NemesisD> thanks
11:41:30 <kuribas> Why does ghc gives me just a typevariable for match1, but when I replace it by "_" it does infer the type?  http://lpaste.net/356842
11:43:53 <glguy> kuribas: where-bound definitions are generalized
11:44:48 <kuribas> glguy: isn't specializing more efficient?
11:45:19 <glguy> kuribas: That isn't relevant to type-checking, that's something that might occur later as an optimization pass
11:45:38 <kuribas> right
11:52:03 <orion> I have an API server based on Servant, Opaleye, and Opaleye-trans. Opaleye-trans defines a Transaction Monad within which queries are to be executed. I would like to use Control.Monad.Except.throwError in this Transaction Monad.
11:52:32 <orion> What's the proper way to go about this?
11:53:03 <orion> Specifically, the code surrounding the Transaction is in Servent's Handler Monad, which is why I can use throwError.
11:54:30 <orion> Do I need to use "lift" from Control.Monad.Trans.Class? If so, does that mean that the "transaction" function in opaleye-trans needs to have a class constraint on MonadTrans, just like it does for MonadIO?
11:59:32 <codedmart> ReinH: Any idea how that could work with files outside the src dir. Example: data-files: ../someFile.txt. Everything compiles with this, but doesn't actually include the files.
12:00:19 <ReinH> It's relative to the project root.
12:00:25 <ReinH> So that would just be someFile.txt
12:00:41 <ReinH> the src dir is just a convention, cabal doesn't assume that it exists
12:01:19 <codedmart> No I mean I need to reference files that are not in the same dir as the cabal file / project folder.
12:01:32 <ReinH> Oh, yeah, don't do that.
12:01:37 <petejohanson> jle`: Ugh. Hitting a snag w/ my zoom....
12:01:52 <ReinH> Cabal assumes that they're contained within the project root dir, since the project can be uploaded to hackage
12:02:06 <codedmart> But other projects/code use those files as well. So what are my options?
12:02:12 <petejohanson> jle`: I'm using existential types, and the 'decorated' state type is an existential type to wrap the inner type, including the extra metadata.
12:02:19 <ReinH> What do they use them for?
12:02:31 <ReinH> If they're the same, why are you duplicating them in the first place?
12:02:31 <petejohanson> jle`: But consuming the zoom, it complains that my rigid, skolem type is "escaping the scope".
12:02:54 <codedmart> Some is config stuff others are other data.
12:02:58 <ReinH> I would make one project the canonical owner of the files and make the other projects depend on it
12:03:14 <codedmart> This is haskell/js web app.
12:04:33 <codedmart> They both read files for initialization/setup/etc.
12:06:58 <codedmart> ReinH: OK thanks I know what I will do.
12:08:17 * hackagebot threepenny-editors 0.2.0.15 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
12:12:47 <orion> OpaleyeT uses ReaderT under the hood. I want to bolt OpaleyeT on to my current transformer, but I already use ReaderT. Am I screwed?
12:17:01 <EvanR> no, you can stack up as many ReaderTs as you want
12:17:39 <EvanR> :t lift
12:17:41 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
12:18:15 <EvanR> :t hoist
12:18:16 <lambdabot> error: Variable not in scope: hoist
12:21:05 <EvanR> look at the Control.Monad.Morph module
12:21:19 <cocreature> the functional dependency in MonadReader becomes annoying at that point
12:23:57 <EvanR> transfomer hell!
12:31:50 <`Guest00000> let `newtype Wrap a = Wrap a; class Unwrap a b where unwrap :: a -> b; instance Unwrap (Wrap a) a where unwrap (Wrap a) = a; instance Unwrap a b => Unwrap (Wrap a) b where unwrap (Wrap a) = unwrap a`. can all these unwraps be noops at runtime?
12:32:40 <geekosaur> I think the only edge case is when you do something like fmap?
12:33:29 <crobbins> `Guest00000: i think you can use coerce from Data.Coerce
12:33:42 <`Guest00000> thanks
12:34:04 <`Guest00000> but i still want to know this
12:34:10 <crobbins> use -ddump-simpl to see what it compiles to
12:34:17 <crobbins> to see if it's a noop or not
12:34:17 <geekosaur> ^ is the real answer
12:34:23 <`Guest00000> if this works, i won't use a stinky coerce
12:34:36 <geekosaur> but, newtypes get added to a special class Coercible which allows ghc to make most of them go away
12:34:44 <geekosaur> the corner case is something like fmap unwrap ...
12:34:48 <crobbins> coerce is fine since it's checked at compile time. unsafeCoerce is the one you should worry about
12:34:57 <geekosaur> which will turn into fmap id and possibly not go away
12:35:21 <geekosaur> (coerce is part of that Coercible typeclass; the compiler generates it for newtypes and as such it is guaranteed to be safe)
12:36:32 <`Guest00000> ~R#
12:38:01 <crobbins> speaking of, is there a way to unset -ddump-simpl in ghci?
12:38:16 <orion> cocreature: Could you go in to more detail about that?
12:40:15 <geekosaur> crobbins, I don't think so, the debug stuff doesn't come with 'no' options because it doesn't expect to be used in a situation where you'd want to reverse it
12:40:44 <geekosaur> might be worth a ghc enhancement request... if it's possible at all (i.e. they didn't do something silly in the implementation that makes it impossible to turn back off properly or fully)
12:40:46 <crobbins> makes sense, too bad :unset doesn't know how to undo it in ghci
12:41:30 <dfeuer> Is the following reformulation of Applicative interesting/useful in any way?  class Functor f => Capplicative f where unit :: Category c => f (c x x); comp :: Category c => f (c y z) -> f (c x y) -> f (c x z)
12:42:46 <cocreature> orion: the functional dependency on the MonadReader class enforces that the monad uniquely determines the environment you get from the reader. if you have two readers stacked on top of each other MonadReader can thereby only give you access to one of them. for the other you need to manually lift through the outer Reader layer so that you can then access the inner Reader
12:43:19 <cocreature> orion: I don’t know anything about opaleye or your code so I can’t say whether this is a problem in your case
12:44:37 <cocreature> if you have control over both parts of your code introducing a Reader it’s usually better to use a single Reader and have the environment be some product type
12:44:57 <geekosaur> the question was about opaleye using ReaderT internally
12:45:01 <orion> I don't. OpaleyeT is a Monad transformer from a 3rd party package.
12:45:28 <geekosaur> I *think* this is not a problem, the Opaleye parts should not see the outer ReaderT and your code will see the one you use, not the one buried inside of Opaleye
12:45:52 <orion> Well, doesn't it depend on how I structure my Servant Handler transformer?
12:46:08 <geekosaur> but I am not certain of that, it depends on how Opaleye uses your type that has an additional ReaderT on it. you may have to lift stuff to get rid of your outer ReaderT in some contexts
12:46:27 <orion> type AppHandler = OpaleyeT (ExceptT AppErr (ReaderT AppEnv IO))
12:46:46 <orion> Or I could do: type AppHandler = ExceptT AppErr (ReaderT AppEnv (OpaleyeT IO))
12:47:24 <cocreature> it looks like Opaleye writes everything in terms of OpaleyeT and not some MonadReader constraints so you are probably fine
12:47:24 <geekosaur> with the former I'd expect you to need to lift sometimes to reach your ReaderT
12:48:03 <geekosaur> probably TIAS and if I saw something complaining about the wrong MonadReader I'd use lift
12:48:22 <geekosaur> although sometimes one needs to go look at how types get nested to figure out how far to lift...
12:48:52 <cocreature> just insert more lifts until it typechecks :)
12:49:10 <orion> geekosaur: With the latter I get errors like: No instance for (exceptions-0.8.3:Control.Monad.Catch.MonadThrow (Opaleye.Trans.OpaleyeT IO))
12:49:41 <orion> This is after bolting OpaleyeT on code which type checks properly without it.
12:50:16 <geekosaur> orion, was going to continue that by saying you'd need to lift other things to get them to work with the other one but I decided cocreature's subsequent remark made it pointless
12:50:29 <geekosaur> this is one of those 'need to lift other things'
12:50:53 <cocreature> tbh OpaleyeT should just have a MonadThrow instance
12:51:02 <geekosaur> that said, I would interpret that error as meaning OpaleyeT is in the wrong place in the stack
12:51:10 <geekosaur> and switch to the other representation
12:51:15 <cocreature> I would just add an orphan instance in most case
12:51:16 <orion> geekosaur: No matter where I put it in the stack, there is always a problem.
12:51:36 <geekosaur> yes
12:51:46 <geekosaur> either way you need to lift *something* potentially
12:52:20 <orion> geekosaur: My transformer is currently a type synonym. Should I wrap it in a newtype and declare a bunch of instances?
12:53:13 <geekosaur> I don't think it will necessarily help
12:53:17 <orion> Oh, I see.
12:53:34 <cocreature> well it would probably solve the MonadThrow error
12:54:37 <orion> There is a third possibility: ExceptT AppErr (OpaleyeT (ReaderT AppEnv IO)) -- If I do this, I get a type mismatch on calling "ask": Database.PostgreSQL.Simple.Internal.Connection does not unify with AppEnv, which is exactly what I expect.
12:55:38 <cocreature> right that’s the issue with Monadreader I mentioned
12:55:39 <orion> cocreature: With the transformer I just mentioned, do you think an orphan instance would solve the "ask" problem?
12:56:02 <cocreature> if you do "(lift . lift) ask" it probably works
12:56:15 <cocreature> no the orphan instance won’t help with the functional dependencies in MonadReader
12:56:34 <cocreature> you can’t really do anything about that apart from lifting
12:56:59 <cocreature> but since your code probably never uses the MonadReader instance of OpaleyeT, putting it one the inside is probably better
12:57:04 <cocreature> then MonadReader will pick AppEnv
12:58:04 <orion> What do you mean by "putting it on the inside"?
12:58:31 <cocreature> ReaderT AppEnv (OpaleyeT IO) vs OpaleyeT (ReaderT AppEnv IO)
12:59:11 <orion> Oh, I see.
13:01:08 <cocreature> a different solution would be to use OpaleyeT only locally and not include it in your transformer stack at all. i.e. store the connection in AppEnv and the use a combination of liftIO and runOpaleyeT to embed it in your Handler monad
13:01:32 <orion> cocreature: Indeed, that's what I've been doing so far.
13:01:52 <orion> It works, but there's a limitation: I can't call throwError from within an OpaleyeT.
13:02:27 <cocreature> right
13:03:20 <orion> (Doing such a thing is important to me)
13:05:59 * hackagebot purescript 0.11.6 – PureScript Programming Language Compiler – https://hackage.haskell.org/package/purescript
13:12:44 <`Guest00000> so, i typed :set -ddump-simpl and entered code and got some mess, how do i interpret
13:14:51 <Pan_013> http://ads4btc.com/?r=talas405
13:15:55 <kareem> hello 
13:20:10 <geekosaur> `Guest00000, to be honest I'd not use ghci for that, I'd install the ghc-core package which makes the dump-simpl output a bit more comprehensible
13:20:41 <geekosaur> although you still need to know something about Core to know if it eliminated the conversions properly
13:20:57 <kareem> hello, i wonder what's the right steps to contribute in the 33 haskell report i have no clues except for that link https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126678.html and it doesn't explain how to submit 
13:20:58 <geekosaur> best bet might be to lpaste the result
13:21:39 <dmwit> kareem: email the guy who sent out the call
13:23:27 <AWizzArd> I want to call:    f (++)    and f is implemented so: f g = (g [10, 20] [30], g "Hello " "World")  and RankNTypes is activated. What is the correct type signature to let f (++) return ([10, 20, 30], "Hello World")?
13:24:04 <kareem> dmwit: ah i see thanks :)
13:24:32 <orion> Wow.
13:25:30 <orion> geekosaur / cocreature: That was a lot easier to fix than I expected. All I had to do was put OpaleyeT directly above IO and define a MonadThrow instance for MonadThrow m => (OpaleyeT m) where throwM = lift . throwM.
13:25:37 <orion> And it type checked.
13:26:11 <geekosaur> AWizzArd, not sure you can, the problem is that it needs to both allow g's parameter to be used at two different types *and* refer to those types in its own type
13:27:15 <dmwit> > let f :: (forall a. [a] -> [a] -> [a]) -> ([Int], String); f g = (g [10, 20] [30], g "Hello " "World") in f (++)
13:27:17 <lambdabot>  ([10,20,30],"Hello World")
13:27:45 <dmwit> There may be other types that will work, too.
13:28:34 <geekosaur> right, I was thinking general case where you don't know that
13:29:01 <geekosaur> the forall will work if you can use specific types in f's type signature
13:29:24 <dmwit> They don't have to be specific.
13:29:37 <dmwit> > let f :: Num b => (forall a. [a] -> [a] -> [a]) -> ([b], String); f g = (g [10, 20] [30], g "Hello " "World") in f (++)
13:29:39 <lambdabot>  ([10,20,30],"Hello World")
13:29:58 <AWizzArd> Hmm okay, I see.
13:30:30 <AWizzArd> I was not thinking about making the return type that specific. Tried it with type parameters instead.
13:31:56 <dmwit> :t (++)
13:31:58 <lambdabot> [a] -> [a] -> [a]
13:32:42 <dmwit> You cant write `f` to demand a more general type than that.
13:32:54 <dmwit> (Not if you want to pass `(++)` to `f`.)
13:32:54 <AWizzArd> Good okay.
13:33:06 <geekosaur> that was what I meant...
13:33:29 <dmwit> Therefore, since `g` is applied to `[10, 20]` and `"Hello "`, that determines the return type of `f` to be the one I wrote.
13:33:59 <AWizzArd> dmwit: so we could not replace the [10, 20], [30], "Hello " and "World" by parameters, so that f g a b x y = (g a b, g x y).
13:34:20 <dmwit> AWizzArd: Why not?
13:34:22 <AWizzArd> And then we would call   f (++) [10, 20] [30] "Hello " "World"
13:35:00 <dmwit> > let f :: (forall a. [a] -> [a] -> [a]) -> [a] -> [a] -> [b] -> [b] -> ([a], [b]); f g a b x y = (g a b, g x y) in f (++) [10, 20] [30] "Hello " "World"
13:35:02 <lambdabot>  ([10,20,30],"Hello World")
13:35:47 <AWizzArd> dmwit: the `a` in that type signature is always the same?
13:35:57 <dmwit> No, I did that to be extra confusing. =P
13:36:10 <dmwit> > let f :: (forall a. [a] -> [a] -> [a]) -> [b] -> [b] -> [c] -> [c] -> ([b], [c]); f g a b x y = (g a b, g x y) in f (++) [10, 20] [30] "Hello " "World"
13:36:12 <lambdabot>  ([10,20,30],"Hello World")
13:36:14 <dmwit> There's the less confusing version.
13:36:23 <dmwit> The `a` takes on types `b` and `c` in the body of `f`.
13:36:38 <AWizzArd> This is what I meant. The (forall …) block had its own `a`.
13:37:12 <dmwit> Correct, that is how quantification works.
13:37:19 <AWizzArd> si
13:37:36 <AWizzArd> Good, that helped, thx
13:50:49 <pikajude> what a beautiful type signature
13:52:46 <AWizzArd> Are there examples in production code of Rank-3 types? Or higher?
14:09:20 <MitchellSalad> how about 'mask'
14:10:29 <EvanR> mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b
14:10:51 <EvanR> yep
14:11:44 <EvanR> next question, why does it need the rank 3 type
14:13:55 <Pamelloes> I'm struggling with robustly reading the contents of a file. What do I need to do to detect a file not found error, and how can I specify the path with which to search for the specified file?
14:15:33 <EvanR> 1. use a strict file reading operation like Data.Text.IO.readFile if file is not found you will get an exception, and you can look for these with Control.Exception.try
14:16:08 <Pamelloes> Ok. That was the function I was using; I will look into Control.Exception.try.
14:19:50 <geekosaur> the key point with try is you need to force the result *before* exiting the try
14:20:09 <geekosaur> otherwise you just have a lazy thunk that will explode with no handler sometime later
14:20:42 <EvanR> eh... strict readFile operation wont return a thunk like unsafeInterleaveIO
14:21:08 <EvanR> i guess you mean, if you wanted to use hGetContents
14:21:36 <Pamelloes> strict readFile shouldn't have any issues, though, correct?
14:21:50 <jle`> petejohanson: should have told me earlier.  it's just now getting interesting :)
14:22:22 <jle`> petejohanson: it might be easiest to write it for your specific type
14:22:27 <jle`> than writing a general combinator
14:22:32 <EvanR> Pamelloes: i just tried it... yeah
14:22:43 <Pamelloes> Awesome :)
14:22:53 <EvanR> and i get an IOError, and then i can use isDoesNotExistError on it to get True
14:22:56 <jle`> writing general combinators for existential types isn't quite haskell's strong suit anyway
14:22:58 <EvanR> from System.IO.Error
14:23:01 <dolio> readFile doesn't delay opening the file.
14:23:06 <Pamelloes> EvanR: Ah, that's what I was just about to ask.
14:23:16 <jle`> but it'll be simple enough to write it for a specific type
14:23:32 <EvanR> ah right, you can use a lazy I/O and get file not found exceptions
14:23:58 <EvanR> but not exceptions while reading the content
14:25:19 <Pamelloes> Is there a way to specify where readFile searches for the file?
14:26:00 <EvanR> use an absolute path
14:28:24 <Pamelloes> In this case I have a filename like "config" and several candidate directories where it could be, like "~/" or "/etc/myapp/" or "/run/var/some_subdirectory/". How should I proceed to attempt to find the file?
14:29:02 <koala_man> readFile opens files based off the current working directory. it doesn't search a path in any way
14:29:04 <glguy> Pamelloes: You just try opening the possible locations in order
14:29:51 <Pamelloes> That makes sense.
14:30:00 <glguy> e.g. https://github.com/glguy/irc-core/blob/v2/src/Client/Configuration.hs#L172-L191
14:39:27 <Pamelloes> I see there is a Data.Text.replace function. If I want to do several replaces in a row, should I call the function several times or is there a more efficient way?
14:58:02 <vtomole> When would i ever use any other ghc backend besides the native code generator -fasm?
14:58:30 <exio4> llvm might optimize certain kind of loops better, I have heard, but I have no benchmarks to confirm this belief
14:59:05 <geekosaur> llvm also optimizes Double math better
14:59:22 <geekosaur> in particular, it can vectorise which ghc itself currently can't
14:59:25 <hpc> ghc doesn't have a native code generator for every cpu
14:59:47 <hpc> sometimes you're stuck with not using it
15:00:28 <vtomole> Any disadvantages for using llvm as a backend?
15:02:02 <lambdamu> vtomole: I have no benchmarks for it but I would assume that it is on average (whatever that is) slower
15:02:30 <lambdamu> vtomole: It sees less use than the NCG and therefore less maintenance optimization, etc.
15:03:06 <geekosaur> I believe there's a major revamp scheduled for 8.4.1 though
15:12:30 * hackagebot threepenny-editors 0.2.0.16 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
15:18:34 * hackagebot network-api-support 0.3.0 – Toolkit for building http client libraries over Network.Http.Conduit – https://hackage.haskell.org/package/network-api-support
15:40:51 * hackagebot network-api-support 0.2.3 – Toolkit for building http client libraries over Network.Http.Conduit – https://hackage.haskell.org/package/network-api-support
17:41:12 <tikhon> Can I document arguments to a GADT constructor with Haddock? Adding -- ^ comments like you would document normal function arguments doesn't seem to work.
17:42:42 <monochrom> Supposedly it should be just like that. But let me try.
17:43:37 <tikhon> Thanks. There could be some other problem—I'm getting a parse error: "parse error on input '-- ^ ...'"
17:44:13 <glguy> tikhon: You can if you use record syntax for your GADT
17:44:21 <tikhon> But not without that?
17:44:40 <glguy> It sounds like you already discovered that you can't with normal syntax
17:44:46 <tikhon> I haven't used record syntax on GADTs—how would it work with multiple constructors?
17:46:11 <tikhon> I'm trying to clean up our exisitng codebase to build HTML docs and fixing problems as I come across them.
17:47:52 <monochrom> Hmm yeah probably not supported.
17:47:52 <tikhon> Another problem I ran into: can you document parts of a type constructor that is *not* (->) separately? For example, the input/output of a Pipe or some kind of arrow?
17:48:16 <tikhon> I'm assuming you can't and I could see why it would be tricky to support, but it also seems pretty useful.
17:48:47 <tikhon> Record syntax for GADTs seems pretty reasonable, actually.
17:49:10 <monochrom> Oh do this:
17:49:18 <tikhon> Although I have no idea of what to call the record field for each constructor—this type has like 8 type variables and doesn't make much sense :/.
17:49:19 <monochrom> data D a where
17:49:23 <monochrom>     -- | Hey!
17:49:31 <monochrom>     D1 :: Int -> D Int
17:49:41 <monochrom> The "Hey!" will be attached to D1.
17:50:29 <monochrom> So basically it is "-- |" and before the constructor because it is analogous to giving "-- |" before a function's type sig.
17:50:45 <monochrom> Because "D1 :: Int -> D Int" looks really like a type sig decl.
17:50:50 <tikhon> yeah
17:51:01 <tikhon> apparently I can get what I want with record syntax though
17:51:01 <glguy> The issue is that you can't document the fields with:   MkCon :: Int {- ^ the int -} -> D a
17:51:05 <tikhon> I'm going to give it a try
17:51:17 <monochrom> Ah right.
17:51:33 <monochrom> Err wait what?!
17:52:04 <monochrom> Oh true. Darn.
17:52:07 <tikhon> Just like you can document each argument to a function
17:52:14 <tikhon> which is sorely necessary for this type
17:52:37 <monochrom> And I was thinking I just found the best analogy ever.
17:52:50 <tikhon> oh man, I have no idea what `Iso' s (Either Int sr, s')` is even supposed to mean
17:52:56 <monochrom> Why oh why did they do this?!
17:53:11 <glguy> You can document each argument of a function in type synonyms, but unfortunately while you can use type synonyms in GADT definitions, the fields must be separated by literal ->s https://github.com/glguy/irc-core/blob/v2/src/Client/CApi/Exports.hs#L130-L133
17:53:29 <monochrom> Went all the way to carry over "-- |" to the constructor, only to deny "-- ^" for the parameters?!
17:53:58 <tikhon> my impression is that Haddock syntax is a bit... ad hoc
17:54:28 <glguy> GADT constructors only recently got support for haddock documentation at all in GHC 8 iirc
17:54:57 <monochrom> Ah OK. Still...
17:55:48 <tikhon> okay, I've never used GADTs with record syntax before
17:55:58 <glguy> Once Haskell Symposium starts accepting papers about how people added features to haddock, maybe it will get more attention
17:56:29 <tikhon> :)
17:56:42 <tikhon> so, this GADT constructor also has some higher-rank types
17:56:54 <tikhon> and I don't understand where to shove the forall in the record syntax version
17:57:16 <monochrom> data D a where D1 :: {int :: Int, bool :: Bool} -> D Char
17:57:25 <tikhon> Foo :: forall a b. a -> b -> MyGADT a
17:57:33 <tikhon> how would you convert that to record syntax?
17:58:07 <glguy> tikhon: I imagine that's not your actual example
17:58:12 <tikhon> no
17:58:57 <glguy> tikhon: that example doesn't have a higher ranked type in it
17:59:06 <tikhon> doesn't it?
17:59:41 <tikhon> data MyGADT x where Foo :: forall a b. a -> b -> MyGADT a
17:59:44 <tikhon> would that even be legal?
18:00:05 <glguy> sure, as long as you enabled ExplicitForAll
18:00:14 <tikhon> ah
18:00:29 <tikhon> yeah, never mind, I can just take the forall out
18:00:42 <monochrom> It is the same as just saying "forall b. a -> b -> MyGADT a"
18:01:02 <ReinH> tikhon: o/
18:01:03 <monochrom> which in turn is just an existential quantification (on b)
18:01:10 <glguy> and the same as, Foo :: a -> b -> MyGADT a
18:01:10 <tikhon> right, that makes sense
18:01:31 <tikhon> I mean, the syntax is a bit confusing because I expect forall to introduce a new type variable scope
18:01:39 <monochrom> for a really rank-2 type you need (forall c. c -> c) -> MyGADT ()  or something
18:03:01 * monochrom grins with evil ideas!
18:03:58 <tikhon> oh, and I was looking at a really old GHC guide page on GADT record syntax
18:04:41 <monochrom> data X a where { Maybe :: (forall r. (a -> r) -> r -> r) -> X (Maybe a); List :: (forall r. (a -> r -> r) -> r -> r) -> X [a]; Nat :: (forall r. (r->r) -> r->r) -> X Natural }
18:05:04 <monochrom> Hmm does that even compile? I was typing it up cold. :)
18:05:44 <monochrom> Oh it compiles (modulo needing Natural in scope).
18:06:01 <monochrom> I have no idea whether it means what I want, but oh boy is it syntactically correct. :)
18:07:06 <monochrom> Hrm Natural is in Numeric.Natural not Data.Natural? Meh.
18:07:25 <tikhon> the whole Control.*/Data.*/etc hierarchy has always been pretty arbitrary
18:07:37 <tikhon> hierarchical for the sake of being hierarchical
18:07:38 <glguy> Numeric.Organic?
18:08:14 <monochrom> Alt.Haskell.Cont.Fetish :)
18:08:42 * monochrom still loves conflating Haskell module names with Usenet/Alt newsgroup names :)
18:09:01 <ReinH> Well, when we added . to the module identifier grammar, we had to do something with it
18:09:18 <tikhon> one really nice thing I found out recently: you can name files Foo.Bar.hs
18:09:25 <tikhon> if you don't want to nest directories too deeply
18:09:34 <tikhon> I think it's legitimately handy for things like Foo.hs and Foo.Internal.hs
18:09:39 <monochrom> OK, so my X example in record syntax goes like: Maybe :: {maybe :: forall r. (a->r) -> r->r} -> X (Maybe a)
18:09:57 <monochrom> Oh, they support that now?
18:10:10 <tikhon> apparently
18:10:19 <tikhon> I just tried it at some point and it seemed to work.
18:10:26 <pacak> Anybody got experience in both haskell and ocaml?
18:10:30 <tikhon> yeah
18:10:42 <tikhon> I did OCaml for a while
18:10:54 <pacak> Any significant differences from haskell?
18:10:55 <tikhon> I'm actually surprised that more Haskellers don't have OCaml experience and vice versa
18:10:58 <tikhon> yeah
18:11:06 <monochrom> Doesn't seem to work for me. But I'm going through cabal.
18:11:19 <tikhon> at first, programming OCaml felt really similar
18:11:41 <tikhon> but a lot of idiomatic Haskell things don't work either because it's strict or because there are no typeclasses
18:12:07 <tikhon> "advanced" OCaml style feels pretty different from "advanced" Haskell style, for some value of advanced
18:12:55 <tikhon> this crops up a lot in how libraries are designed and which ones are easier/harder to use—I seem to recall OCaml's QuickCheck equivalent was pretty awkward
18:13:13 <monochrom> OK, I have whee.hs "import B.D; main = print b" and B.D.hs "module B.D where b=True". ghci whee.hs cannot find B.D
18:13:24 <tikhon> hmm, I guess I was wrong
18:13:33 <pacak> Lack of typeclasses... How do they implement things like Monad/Applicative/Functor?
18:13:38 <monochrom> However, "ghci B.D.hs" is OK.
18:13:46 <tikhon> yeah, that's the only thing I tried, I think
18:13:49 <tikhon> shame it doesn't work more widely
18:14:03 <tikhon> pacak: awkwardly, via higher-order modules (what they call functors)
18:14:19 <tikhon> in practice, it means you rarely have code that mixes different monads
18:15:10 <tikhon> they also don't have higher-kinded types, so I remember needing different modules for monads with no additional type arguments (Maybe) vs ones that did (Either)
18:15:40 <tikhon> Option and Or_error in OCalm
18:16:01 <tikhon> or something like that
18:16:14 <tikhon> I haven't used OCaml in a while so I don't remember all the details, just that some things I was used to were a lot less convenient
18:16:24 <tikhon> in practice, it meant they just used slightly different idioms and designs
18:16:39 <pacak> I see. I guess it's better if I try to write something myself then.
18:16:50 <pacak> Thanks :)
18:16:55 <monochrom> OK, GADT with record syntax with field doc: D1 :: {int :: Int {-^ hey! -} } -> D Int
18:17:02 <tikhon> yeah, there was a difference between Monad.S: https://ocaml.janestreet.com/ocaml-core/109.12.00/doc/core/Monad.S.html
18:17:07 <tikhon> and Monad.S2: https://ocaml.janestreet.com/ocaml-core/109.12.00/doc/core/Monad.S2.html
18:17:36 <tikhon> "The same as S except the monad type has two arguments. The second is always just passed through."
18:17:42 <tikhon> also, all the types were called t
18:18:47 <simony> say i have a sum type in Haskell (or a typeclass w/ finally-tagless style), is there a good way of enumerating all the members?
18:19:14 <tikhon> pacak: If you want to do some OCaml, I highly recommend using one of the alternative standard libraries
18:19:21 <tikhon> Jane Street's Core is very well designed
18:19:32 <tikhon> that's what the OCaml book uses too
18:19:42 <tikhon> er, Real World OCaml
18:19:46 <monochrom> If "deriving (Bounded, Enum)" works, then [minBound .. maxBound] :: [YourType] enumerates.
18:20:03 <monochrom> But if not, write your own instances to make it work, I guess.
18:20:20 <pacak> tikhon: I've found about bucklescript - javascript backend for ocaml compiler. Just want to try to develop web stuff with proper types.
18:20:43 <pacak> I suspect I will be limited with whatever library it supports.
18:20:47 <tikhon> Yeah, it seems pretty cool. I did a couple of projects with js_of_ocaml and liked that too.
18:21:06 <tikhon> I remember they were devloping a subset of Core that worked with js_of_ocaml—Core.Kernel or something like that
18:21:38 <tikhon> Have you considered GHCJS with reflex though? It's still a bit on the early adopter scale, but I liked it more than js_of_ocaml.
18:22:07 <simony> monochrom: thanks
18:22:26 <pacak> I looked at ghcjs and I don't like what kind of mess it generates.
18:22:33 <tikhon> that is a downside, true
18:22:36 <tikhon> how about PureScript?
18:22:56 <tikhon> that said, there's some really exciting stuff in the pipeline for reflex on mobile
18:23:16 <pacak> Tried installing it once or twice, never managed to get it to work.
18:23:29 <pacak> Same about elm.
18:23:48 <tikhon> euh, shame
18:24:03 <tikhon> I've tried Elm but not the biggest fan—I'd go for OCaml over Elm for sure
18:24:27 <pacak> I suspect purescript took too much from javascript. Having Maybe in a separate package seems somewhat perverted design choice.
18:24:32 <tikhon> sigh: commenting out a couple of guards resulted in Haddock parse errors
18:24:40 <tikhon> not the best syntax design :/
18:25:20 <paf31> pacak: you could use an alternative prelude like purescript-base
18:25:28 <paf31> which bundles many of the things you'd expect from Haskell
18:28:01 <tikhon> man, some of our code has weird idioms
18:28:07 <tikhon> functions like a -> Maybe (b -> c)
18:28:14 <tikhon> it sort of makes sense, but is pretty awkward in practice
18:29:23 <pacak> paf31: I can try again, but I don't understand why they made it this way. In Haskell you might want to have an alternative prelude just because original one was designed long time ago and they didn't wanted to change it too much. And even then - I'm perfectly happy with that ancient Prelude. PureScript was created recently and they had a ton of examples to look at. If they made a strange design choice here - I wonder what else can be wrong.
18:30:04 <Axman6> tikhon: looks pretty Applicative to me
18:30:08 <paf31> Why do you say it's a strange choice?
18:30:23 <paf31> There are reasons why the Prelude is broken up that way
18:30:56 <paf31> Mainly because we want to use PureScript for  small projects and get very small output sometimes 
18:31:19 <pacak> But... You know... Optimizations, dead code removal....
18:31:27 <paf31> Yes, we have those too
18:32:00 <paf31> But that doesn't mean we don't still want a minimal standard library
18:32:11 <paf31> and no runtime dependencies
18:32:45 <paf31> I suggest joining #purescript or the Slack channel, there are more PS users there with experience of this sort of thing
18:33:23 <pacak> Yea. That's what they have in javascript as well. Minimal standard library, nanopackages and one unpublished leftpad results in major issues all over internets.
18:33:47 <paf31> Well we haven't had those issues so I can't comment
19:51:34 <tabemann> question
19:51:43 <tabemann> what's a good string formatting module to use?
19:51:55 <tabemann> rather than using show and string concatenation
19:52:16 <pacak> :t printf
19:52:18 <lambdabot> PrintfType r => String -> r
19:52:44 <pacak> > printf "%2i x %s" 2 "hello"
19:52:46 <lambdabot>  error:
19:52:46 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M363709816926...
19:52:46 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
19:53:30 <tabemann> > printf "%2i x %s" (2 :: Int) "hello"
19:53:33 <lambdabot>  error:
19:53:33 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M156809542170...
19:53:33 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
19:53:57 <pacak> > printf "%2i x %s" 2 "hello" :: String
19:53:59 <lambdabot>  " 2 x hello"
19:54:22 <pacak> It depends on magic of PrintfType to get all the arguments
19:54:32 <tabemann> > printf "%2i x %s" 2 "hello" :: Text.Text
19:54:34 <lambdabot>  error:
19:54:34 <lambdabot>      Not in scope: type constructor or class ‘Text.Text’
19:54:34 <lambdabot>      No module named ‘Text’ is imported.
19:54:40 <tabemann> > printf "%2i x %s" 2 "hello" :: Data.Text.Text
19:54:42 <lambdabot>  error:
19:54:42 <lambdabot>      Not in scope: type constructor or class ‘Data.Text.Text’
19:54:42 <lambdabot>      Perhaps you meant ‘Data.Set.Set’ (imported from Data.Set)
19:55:13 <pacak> What kind of formatting are you interested in?
19:55:51 <tabemann> just basic string formatting - I'm serializing treecode into a human-readable format, and need something to format individual instructions
19:59:27 <jared-w> printf is pretty terrible, isn't it?
20:22:00 <lerax> hey guys, i'm stuck looking into the docs about a built-in function to
20:22:00 <lerax>         sum two tuples element by element or a list of then. Is a greater way
20:22:03 <lerax>         to do it? f :: (a,b) -> (a,b) -> (a,b). Like this: f (a0,b0) (a1, b1)
20:22:06 <lerax>         = (a0+a1, b0+b1). 
20:22:31 <lerax> (ops, sorry for the bad format, a bug here on emacs)
20:23:07 <pacak> @pl \(a, b) (c, d) -> (a + c, b + d)
20:23:07 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
20:23:29 <pacak> Hmm... No.
20:24:19 <lerax> Thanks
20:24:52 <lerax> Is a greater way to do it instead the definition I wrote above?
20:25:52 * hackagebot extensible-effects 1.11.1.0 – An Alternative to Monad Transformers – https://hackage.haskell.org/package/extensible-effects
20:25:53 <lerax> Actually I'm trying sum a list of pairs, but each sum need to be done as a vector sum. 
20:27:20 <lerax> Most examples I found is about sum the pairs with itself (a,b) -> a + b. 
20:28:20 <Welkin> don't use pairs
20:28:25 <Welkin> pairs are for key-value pairs
20:28:30 <Welkin> make your own datatype V2
20:28:36 <Welkin> data V2 a = V2 a a
20:29:04 <Welkin> add (V2 a b) (V2 c d) = V2 (a + c) (b + d)
20:35:09 <lerax> Welkin: Thanks for the suggestion! I will try it.
20:39:54 <jared-w> Hmm... I wonder if micro data-type modules are worth creating?
20:42:35 <dfeuer> Why is cabal update taking so long?
20:43:12 <jle`> lerax: V2 also has a famous Num instance too
20:43:46 <jle`> so you could even write sum :: [V2 Int] -> V2 Int
20:43:50 <jared-w> jle`: is that the one where nobody can decide if it's a sin or if it's slightly useful?
20:44:09 <jle`> i think it's useful and not a sin
20:44:17 <jle`> sin is in Floating, anyway
20:44:24 <jared-w> (☞ﾟヮﾟ)☞
20:45:09 <jle`> at least it's not one of those weird partial instances
20:45:12 <jle`> like Natural
20:45:13 <jle`> gross
20:45:27 <glguy> >.<
20:45:42 <jle`> and those 'considered harmful' instances like for Word8
20:48:37 <lerax> jle`: this is really great. But I just solve using lists and sumPair as sumPair xs ys = zipWith (+) xs ys
20:51:56 * hackagebot miso 0.1.5.0 – A tasty Haskell front-end framework – https://hackage.haskell.org/package/miso
20:54:49 <jle`> lerax: that doesn't use pairs
20:55:05 <jle`> it probably doesn't typecheck
20:55:28 <jle`> it's definitely not a bad function, but it's a solution to a completely different problem :)
21:00:56 <samtay> any parsing experts in here? looking for the ability to parse something easy like text_to_match="PARSE-START>>>RETURN-THIS-CONTENT<<<PARSE-END". the problem is: text_to_match can occur zero or more times surrounded by ANY content, such as "asdfwuhw9gh29ghw9eugw9ug   w9ghw9h `text_to_match`sgwghw4g2g20g2ng"
21:01:39 <samtay> I can't figure out how to disregard ANYTHING, parse something important, then disregard ANYTHING.
21:02:43 <peddie> samtay: what about e.g. `many anyChar`?
21:02:57 <Axman6> isn't there a manyUntil kind of thing?
21:03:15 <Axman6> should be able to do manyUntil anyChar thingToParseContent
21:03:21 <samtay> working with attoparsec bytestring, I keep getting Partial _
21:04:40 <Axman6> I would look at the implementation of manyTill and change it to ignore the first argument's value and return the second's
21:08:27 <samtay> I believe the opposite of `manyTill anyChar parser` would be `skipMany anyChar >> parser`
21:08:46 <Axman6> no
21:09:02 <samtay> whats the difference?
21:09:07 <Axman6> because manyTill runs parser after each anyChar
21:09:41 <samtay> ah... and skipMany anyChar will just skip until EOF ??
21:09:51 <Axman6> yes
21:09:58 <samtay> that explains Partial _  :)
21:10:03 <Axman6> yep
21:10:19 <samtay> i'll take a look and see if that works. thanks!
21:13:10 <jared-w> it's funny because this is really trivial in a regular expression
21:13:41 <Axman6> nothing beyond the most basic tasks is trivial in a regular expression
21:13:56 <samtay> haha yep. should see how haskell regex packages handle "."
21:14:18 <samtay> although i think most dont use the typical parser monad packages but actually implement state machines... dunno though
21:14:32 <jared-w> right, but this particular example is probably the most trivial case of a regex, so it was a little funny to me to see the parser examples
21:16:35 <Axman6> the problem is the parsing of the actual content, not the skipping bit. doing that in a regex is a nightmare
21:17:13 <samtay> so alright. i've implemented skipTill:
21:17:14 <samtay> λ> skipTill end p = scan where scan = (end *> pure []) <|> liftA2 (:) p scan
21:17:26 <samtay> where skipTill :: Alternative f => f a -> f t -> f [t]
21:17:47 <Axman6> you don't actually want to store the results of p though right?
21:17:55 <Axman6> just use p *> scan
21:18:19 <Axman6> (assuming you've reversed the order of arguments from manyTill)
21:18:20 <samtay> yes
21:19:06 <samtay> i do want to keep track of the parsed content from p
21:19:11 <Axman6> ok
21:19:20 <samtay> but skip the (end :: f a)
21:19:23 <Axman6> don't you want the bit following p though?
21:19:38 <Axman6> oh, that's the opposite of what I thought you said
21:22:00 <jle`> why are there no Hashable instances for Map k v
21:22:05 <jle`> hm
21:24:12 <arctictern> anyone have a minute to help me derive the type of ((.) . (.))?
21:24:22 <arctictern> i've been noodling around for a while but can't seem to get the type ghci tells me
21:24:27 <Cale> arctictern: I find it helps to think of it as fmap . fmap
21:24:44 <Cale> and then re-specialise the type of the fmaps
21:25:11 <Cale> i.e. fmap :: (Functor f) => (a -> b) -> (f a -> f b)
21:25:23 <samtay> its essentially letting you apply two arguments to to 'g' in 'f . g'
21:25:36 <Cale> So  fmap . fmap :: (Functor f, Functor g) => (a -> b) -> (g (f a) -> g (f b))
21:25:52 <Cale> and then we can pick f t = e -> t, and g t = e' -> t
21:26:23 <Cale> So we get (a -> b) -> (e' -> e -> a) -> (e' -> e -> b)
21:27:08 <arctictern> ok i think that makes sense 
21:27:09 <Cale> Note that when f t = e -> t, we have on its own fmap :: (a -> b) -> (e -> a) -> (e -> b)
21:27:16 <Cale> which is exactly the type of (.)
21:27:28 <arctictern> need to stare at it for a bit 
21:29:27 <arctictern> hm so could you think of fmap as a more powerful function composer, since you can derive . from it? or is that going too far. 
21:32:10 <Cale> Well, function composition is a special case.
21:32:19 <kadoban> I don't think of it like that. It's more generic than just function composition, but I wouldn't really call it a generic function composer either, that's just what it is for ((->) e). For most others it has not much to do with function composition at all, if anything.
21:33:13 <Cale> There are at least a couple major ways to think about what fmap is doing: one is that fmap f x is the result of applying the function f to all the values inside some container x
21:33:35 <Cale> We can think of functions A -> B as being like containers indexed by values of type A, and which hold values of type B
21:35:36 <Cale> So there, when we have fmap f g, how do we form the container which at some index x, will have f applied to what g had at that index?
21:35:42 <Cale> fmap f g = \x -> f (g x)
21:35:46 <Cale> exactly composition
21:36:36 <Cale> Another way to think about fmap f x is that if we're thinking of x as some sort of "computation", then fmap f x is the computation which does the same thing as x, but where f is applied to the result at the end
21:36:55 <arctictern> what is the "container" for that functor 
21:37:07 <arctictern> thanks for the explanations btw 
21:37:08 <Cale> The function
21:38:00 <Cale> It's possible to think of a function A -> B as being a sort of "array" of sorts, with one position for each value of type A, and at each of those positions, it contains a value of type B
21:38:41 <Cale> To look up the value in the "array" at some position x :: A, we just apply the function, as f x
21:39:42 <Cale> To form a new "array", which has at some position x, a value determined by an expression e (which may depend on x), we can use the lambda \x -> e
21:39:45 <arctictern> so if the function is the container, we're mapping over that structure in the sense that fmap f g is still a function, but just with a different output
21:40:09 <Cale> Yeah, at each position, it has what the container g had, but with f having been applied.
21:40:21 <arctictern> so we're preserving the structure (a function) but changing the "value" inside, where the value is the return value?
21:40:28 <Cale> yeah
21:40:47 <arctictern> ok gotcha
21:40:49 <arctictern> thanks a bunch 
21:40:52 <Cale> > fmap (*10) [1,2,3]
21:40:54 <lambdabot>  [10,20,30]
21:40:57 <Cale> compare with that :)
21:41:14 <arctictern> (y)
21:45:21 <samtay> GOT IT! thanks for the parsing help
21:48:14 <samtay> also, does anybody know off hand, if I am parsing a giant hunk of HTML (but dont need to worry about structure, just a couple flat strings), would it be faster to use ByteString or Text ?
21:49:49 <samtay> keeping in mind that, AFAIK, I'll have to intially do a big pack/unpack from ByteString -> Text if I went with Text..
22:16:29 <fresheyeball> hey out there
22:16:34 <fresheyeball> if I have an `IO a`
22:16:42 <fresheyeball> is there a way I can make a new `IO a`
22:16:51 <fresheyeball> the runs the former at most once
22:17:00 <fresheyeball> and after that returns a cached value?
22:17:18 <glguy> Sure, you can build such a thing using an IORef
22:17:30 <fresheyeball> glguy: can you give me an example?
22:17:34 <fresheyeball> I am struggling to see how to do this
22:22:09 <fresheyeball> glguy: I don't think its possible
22:22:21 <fresheyeball> I would need to pass the IORef in
22:22:30 <fresheyeball> the IO can't refer to itself this way
22:22:32 <fresheyeball> or can it?
22:22:34 <dmj`> \m -> do { ref :: IORef a <- (m :: IO a) >>= newIORef; pure $ readIORef ref }
22:23:43 <dmj`> returns a function that retrieves the cached value
22:25:41 <dmj`> m gets evaluated initially though, but looked up subsequently
22:27:14 <dmj`> the type would probably look like: IO a -> IO (IO a)
22:28:39 <theme> According to this, Hoogle uses some kind of edit distance for type search http://ndmitchell.com/downloads/slides-hoogle_finding_functions_from_types-16_may_2011.pdf
22:28:44 <theme> How is this edit distance implemented?
22:28:50 <fresheyeball> dmj`: I'm not getting it
22:33:16 <dmj`> fresheyeball: so you have an `IO a`, and you need to evaluate it at most once. You can only evaluate IO inside of IO, so you  call bind on it to force evaluation, you then store it in an IORef, and return a value that is read from the cache. { do result <- action; cache <- newIORef result; pure (readIORef cache) } .
22:35:27 <hrumph> hi
22:35:56 <hrumph> are lenses harder to understand then monads?
22:36:16 <pacak> hrumph: Depends.
22:37:00 <pacak> Monad is just one structure with some actions. Lenses - a bunch of different abstractions with different implementations.
22:38:29 <fresheyeball> hrumph: yes
22:39:44 <nshepperd_> Lenses are 0.4 hardness units
22:40:21 <nshepperd_> Compared to monads, at 0.27
22:40:53 <pacak> :t confusing
22:40:55 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
22:41:36 <ddk> hello all
22:42:49 <ddk> can someone tell me how can I represent a network for performing XOR between two inputs using grenade network library
22:43:04 <iqubic> pacak: I am suprised that confsing is an actual function. 
22:43:12 <ddk> its urgent for me
22:43:26 <eklavya> :t surprise
22:43:28 <lambdabot> error: Variable not in scope: surprise
22:43:31 <eklavya> :(
22:44:12 <ddk> is someone here familiar with grenade 
22:45:07 <nshepperd_> confusing is actually one of the really simple lens functions, i guess that's kind of irony
22:45:30 <hrumph> are lenses useful?
22:45:37 <Axman6> extremely
22:45:39 <nshepperd_> For a lens x, confusing x = x, but faster
22:46:03 <nshepperd_> If x is made of a bunch of if compositions if lenses
22:46:17 <Axman6> hrumph: the basic concept is trivial, but their current encoding is extremely powerful, and as such can be confusing
22:46:40 <nshepperd_> Er, a composition of a bunch of lenses.
22:46:48 <hrumph> well i just added arrows to my bag of knowledge tonight
22:47:01 <hrumph> i'm wondering if i should learn about lenses or not but it seems intimidating
22:47:11 <Axman6> I find arrow much more confusing than lenses
22:47:33 <ddk>  is someone here familiar with grenade 
22:47:53 <nshepperd_> ddk: 
22:48:01 <Axman6> ddk: I think you're the only person who I've ever seen using it (your question was the first time I'd heard of it)
22:48:06 <kadoban> Arrow is the library of funny stuff you can do on pairs to me. I don't think I ever use it for its intended purpose.
22:48:25 <Axman6> also, isn't XOR one of the classical cannot-be-encoded-with-neural-networks problems?
22:48:27 <hrumph> Axman6, the description of arrow is not very long. i haven't seen a lens description that doesn't go on for pages and pages
22:48:35 <nshepperd_> I have no clue how grenade works, but i know an xor needs a three node hidden later
22:48:46 <Axman6> kadoban: yeah me too, first and second are the only functions I've ever used it for
22:48:54 <pacak> Axman6: It can't be encoded with a single layer network. Multi layer one - you can.
22:49:01 <kadoban> Axman6: I use &&& sometimes, for code golfy stuff
22:49:08 <Axman6> hrumph: a lens is a getter and setter for zero or more elements in a thing
22:49:25 <Axman6> kadoban: right, but that's just first . second to me anyway :P
22:49:26 <hrumph> the way i think of an arrow is that it's a way of taking the sort of commutative diagrams or digraphs that category theorists are fond of, and turning it into a structure for computation
22:49:27 <jared-w> Axman6: you can encode an xor with a neural netowk pretty easily...
22:49:59 <ddk> yes the problem is I can do it without grenade but i am bound to use grenade only
22:50:09 <Axman6> then y'all can give ddk a hand doing so then :P
22:50:29 <jared-w> https://martin-thoma.com/tf-xor-tutorial/ oh, I see you're talking about the XOR problem I'm guessing? 4 data points with 2 features?
22:51:00 <ddk> jared-w: yes but I have to use grenade
22:51:24 <jared-w> "have to."  Why?
22:52:10 <ddk> it is asked by my professor
22:52:14 <jared-w> hrumph: do you regularly work with records? If not, you probably don't need to care about lenses yet (if my understanding is correct)
22:52:26 <pacak> Homework? That would be $99.95
22:52:30 <Axman6> nah, lenses are generally useful
22:52:34 <hrumph> jared-w it's not my present focus
22:52:47 <Axman6> once you learn to use lenses, you will begin using them everywhere
22:52:55 <hrumph> jared-w it just seems that lens is like the next chapter and i've read all the chapters up until that point
22:52:57 <ddk> no not actually homework 
22:53:01 <jared-w> Axman6: They "solve" the generic problem of getting and setting values inside arbritrary data structures, right?
22:53:17 <Axman6> yes
22:53:22 <Axman6> but more than that too
22:53:27 <iqubic> I know about lenses. I still don't use them everywhere though.
22:53:34 <jared-w> hrumph: well in that case, why not? :p
22:53:58 <jared-w> Axman6: what else do they do? I've not seen any other real explanation other than the getter/setter one
22:54:53 <Axman6> it's important to not write that of as a simple thing though, when you have getters an setters for multiple things (ie, all the elements in a list) and these compose, data transformations become extremely powerful
22:55:10 <nshepperd_> Lenses also function as Functor, Foldable, and Traversable, but with racing stripes
22:55:17 <Axman6> yeah
22:55:31 <Axman6> easily composable traversals are so awesome
22:55:38 <jared-w> Axman6: oh for sure, I definitely see getting and setting as an incredibly powerful thing. I just wasn't aware that there was any other stuff you could do with 'em
22:56:00 <Axman6> they make excepts much more sane to work with, for one
22:56:02 <jared-w> Being able to compose traversals is definitely cool :p
22:56:02 <ackpacket> Thoughts on "Real World Haskell" Vs "Learn You a Haskell..." ?
22:56:29 <jared-w> ackpacket: I personally think they have major issues and dislike both of them infavor of much more superior (and not ridiculously obsolete) learning materials
22:56:33 <Disavowed> Hey all. Dumb question I'm sure: why won't this work in ghci? `foldl (+) [1..10]`
22:56:45 <ackpacket> jared-w, Hmm.  I'm interested.  What materials?
22:56:48 <jared-w> I long for the day people nuke those from the r/haskell sidebar learning recommendations
22:56:53 <Axman6> Disavowed: because you need some starting value
22:56:54 <kadoban> Disavowed: Because you have to give it an initial value
22:56:54 <dmj`> :t foldl'
22:56:55 <marvin2> Disavowed you are missing an argument
22:56:56 <Axman6> :t foldl
22:56:56 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
22:56:57 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
22:57:12 <Axman6> > foldl (+) 0 [1..10]
22:57:13 <dmj`> > foldl (+) 0 [1..10]
22:57:15 <lambdabot>  55
22:57:15 <lambdabot>  55
22:57:18 <dmj`> Axman6: JINX!
22:57:22 <Axman6> @quote stereo
22:57:22 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
22:57:22 <ackpacket> :t Foldable
22:57:24 <lambdabot> error: Data constructor not in scope: Foldable
22:59:02 <jared-w> 1. Haskell From First Principles; 2. Thinking Functionally with Haskell, by Richard Bird; 3. https://github.com/bitemyapp/learnhaskell
22:59:14 <nshepperd_> ackpacket: i think the cool kids like "Haskell programming from first principles" now
22:59:18 <Disavowed> Axman6: kadoban: dmj`: Thank you so much! 
22:59:36 <jared-w> 4. http://www.haskellcraft.com/craft3e/Home.html 
22:59:42 <dmj`> @typeclassopedia
22:59:42 <lambdabot> Unknown command, try @list
22:59:46 <jle`> how do i get the correct Alternative instance for Either
22:59:56 <dmj`> @google typeclassopedia
22:59:57 <jle`> transformers seems to export a weird one
22:59:57 <lambdabot> https://wiki.haskell.org/Typeclassopedia
23:00:02 <jle`> as an orphan
23:00:06 <jle`> and everything is ruined :'(
23:00:19 <jared-w> jle`: can you not derive it through some deriving method?
23:00:34 <Axman6> :t (Right 1 <|>)
23:00:36 <lambdabot> (Num a, Control.Monad.Trans.Error.Error a1) => Either a1 a -> Either a1 a
23:00:44 <Axman6> bleh, needs Error? :(
23:00:47 <jle`> any instance i use will overlap
23:00:53 <Axman6> instance Error MyE
23:01:20 <newhoggy> :t (<|>)
23:01:23 <lambdabot> Alternative f => f a -> f a -> f a
23:01:42 <newhoggy> How does that work?
23:01:53 <jle`> the hubris of transformers to hijack the ecosystem with an orphan instance of a class and type that are both in base :'(
23:02:03 <jle`> newhoggy: are you familiar with typeclasses?
23:02:14 <jle`> when you write an instance of a typeclass, you get to define all of its methods
23:02:27 <jle`> so every instance of the Altenrative typeclass gets to define its own (<|>)
23:02:36 <jle`> kind of like (==) for the Eq typeclass
23:03:02 <ddk> so no one seems here familiar with grenade
23:03:06 <jared-w> Pretty similar in concept to java's "implementing y"
23:03:12 <jared-w> ddk: nope, never heard about it before
23:03:32 <ddk> ok
23:03:43 <jle`> if you have a question, just ask it :)
23:03:46 <jared-w> https://github.com/HuwCampbell/grenade
23:03:56 <nshepperd_> ddk: shouldn't there be course materials or something you can read
23:03:59 <newhoggy> Oh: instance [safe] Control.Monad.Trans.Error.Error e => Alternative (Either e)
23:04:04 <nshepperd_> Or just the docs i guess
23:04:12 <newhoggy> Cool.  Thanks!
23:04:17 <jle`> the people who would know grenade aren't necessarily the ones that are going to commit tosaying "yes i know"
23:04:28 <ddk> docs I have read but not getting 
23:04:30 <jared-w> I mean this doesn't look very difficult. If you understand how neural networks work in theory, it's like plugging together all the wires ¯\_(ツ)_/¯
23:04:47 <ddk> I asked my question
23:06:26 <ackpacket> What is the advantage of having pattern matching like this: getIt :: Char -> Int \n getIt 'a' = 1 \n getIt 'b' \n ... getIt 'z' = 26, VS. just declaring getIt once, and inside of it using a case?
23:06:35 <nshepperd_> Surely the correct instance would be  Monoid e => Alternative (Either e)
23:06:49 <jared-w> Yeah, to be honest, the way you phrased your question makes it sound like you don't actually understand how neural networks function in general, ddk
23:06:51 <jle`> yes that is indeed the correct instance
23:07:10 <jle`> but now it's impossible because transformers has an orphan :'(
23:07:12 <nshepperd_> What's this Error madness then
23:07:36 <newhoggy> Hmmm, but Error is deprecated.
23:08:01 <jle`> well, ErrorT is deprecated
23:08:23 <jle`> hm not sure if Error is deprecated too
23:08:41 <jared-w> ackpacket: pattern matching can be faster than cases, I believe (anyone else know for sure?). Although if you're going to pattern match the entire alphabet you're probably not going about something the right way
23:08:41 <ddk> jared-w: yes I am new to ML also but have an idea how neural networks works in general ...thing is even after going through docs I can't understand the library building blocks
23:09:14 <newhoggy> This is flagged with a warning: newtype DecodeError = DecodeError String deriving Error
23:09:18 <nshepperd_> Maybe if we're lucky nobody uses the silly instance and we can just sneak in a patch to transformers
23:09:25 <ackpacket> jared-w, I'm not pattern matching the alphabet any more than folks in the world intend on naming all their symbols Foo and Bar =\
23:09:30 <newhoggy> Deprecated: "Use Control.Monad.Trans.Except instead"
23:10:08 <glguy> You can just turn off the deprecation message
23:10:15 <jared-w> ackpacket: that doesn't make sense to me
23:10:28 <ackpacket> jared-w, Then we should move on.
23:11:41 <ackpacket> jared-w, Circling back to the idea that pattern matching is faster... I don't have any reason to doubt it is, but am curious why that would be the case.  Something to do with delayed execution?
23:12:09 <jared-w> Well, I don't really get what you're coming from when you say people don't intend on naming all their symbols Foo and Bar. You gave an example of 26 cases of pattern matching the entire lower-case alphabet and I responded based on that example. Did I read something wrong?
23:12:20 <Axman6> if it were me, I would be using ord and a single guard :\
23:12:36 <newhoggy> Maybe it's just easier if I define my own result type instead of using Either
23:13:22 <jared-w> hmm. Pattern matching is preferable to equality checks due to boolean blindness. Otherwise it appears that almost everything compiles down to case under the hood
23:14:22 <ackpacket> Boolean blindness?  Sec while I look into that.
23:14:49 <jared-w> boolean blindness is the concept where you have no idea what a "x" vs a "not x" represents
23:15:03 <ackpacket> jared-w, re: the foo bar business, just a comment that missed the mark, not worth dissecting.
23:15:23 <nshepperd_> ackpacket: it's the same thing. A function with multiple patterns is translated to a case statement afaik
23:16:12 <jared-w> nshepperd_: I just looked at that and was pleasantly surprised that was the... case
23:16:37 <MarcelineVQ> yeaaahhhhh~~~
23:16:51 <nshepperd_> 😎
23:32:08 <newhoggy> Looks like defining my own result type rather than using Either helped.
23:32:17 <newhoggy> Thanks everyone for your help!
23:36:41 <zomg> TIL you need to use something called unbuffer to make haskell apps work correctly with tee
23:37:03 <zomg> or at least my app wouldn't output anything unless I prefixed stack exec my-binary with unbuffer
23:41:41 <srhb> zomg: What are you writing? LineBuffering is default on stdout in most cases, afaik.
23:42:18 <zomg> just outputting some info with putStrLn and print so I can keep track of what the app is doing
23:42:57 <zomg> it works just fine but when I tried to use tee to get it to also output into a file it just went totally quiet until I used unbuffer
23:43:05 <cocreature> srhb: I’m not sure if that’s still true if you’re redirecting stdout, e.g., piping it to tee
23:43:12 <srhb> cocreature: Oh
23:45:01 <srhb> I clearly know too little about how stdio even works
23:46:55 <cocreature> I just confirmed that it’s "BlockBuffering Nothing" when piping to tee
23:47:10 <srhb> cocreature: How did you confirm that?
23:47:17 <cocreature> hGetBuffering stdout
23:47:22 <srhb> OK :)
23:47:40 <srhb> I was completely unaware that it could change without me actually changing Haskell code, so that's good to know
23:49:39 <cocreature> zomg: in general tee should show output at some point, the buffer is probably just larger. you can either enable line buffering via hSetBuffering or you can manually flush via hFlush
23:51:12 <cocreature> it’s also not really specific to Haskell apps
23:51:17 <zomg> I somehow get the feeling I've had to use that for something before :)
23:56:02 <EvanR> list of things that could change without you changing haskell code, would be nice
23:56:45 <EvanR> there are some global "constants" that depend on the particular system (and what else?) that you compile on
23:58:05 <srhb> I would also like to understand what exactly makes the outputbuffering change (is that Haskell code itself?) so I can understand it :)
