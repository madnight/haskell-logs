00:06:51 <Axman6> that type doesn't guarantee that though
00:17:46 <Lokathor> so
00:17:47 <Lokathor> it works
00:17:51 <Lokathor> that is
00:17:54 <Lokathor> it turns on
00:18:10 <Lokathor> it calculates the correct answer
00:18:15 <Lokathor> ...inelegently, but it does
00:25:32 <Lokathor> https://www.dropbox.com/s/t1d0jph288qr6ez/Screenshot%202017-07-12%2001.24.59.png?dl=0
00:49:33 <Lokathor> hmm
00:49:42 <Lokathor> i don't need findIndex
00:49:49 <Lokathor> i need a dropWhile that counts how many it dropped
02:07:40 * hackagebot wai-middleware-auth 0.1.2.1 – Authentication middleware that secures WAI application – https://hackage.haskell.org/package/wai-middleware-auth
02:12:28 <jakub__> suppose i have a collection of functions (f :: a -> b -> c), (g :: a -> a -> c), (h :: a -> b -> b), (i :: Int -> b -> c); I would like to have a polymorphic value, that contains the largest sublist of these functions specialised accordingly, is anything like this: funs :: [k -> l -> m]; funs = filterApplicable (collectionOf f g h i) possible?
02:13:16 <jakub__> i mean with any amount of Typeable / Singletons / Constraints / whatever
02:15:04 <jakub__> so that (funs :: [Char -> Bool -> Bool]) is roughly the collection of `f` and `h` specialised to Char->Bool->Bool (g, i cannot be specialised)
02:15:06 <ertes-w> helo
02:15:24 <ahellwig> hello
02:17:01 <Axman6> jakub__: it might be possible to do that using hlists
02:18:24 <Axman6> data HList (xs :: '[*]) where HNil :: HList '[]; HCons :: a -> HList xs -> HList (a':xs), then it may be possible to see if each value in that lists unifies with type you want using type families
02:18:36 <Axman6> (... exercise left to the reader...)
02:19:03 <jakub__> Axman6: I am more puzzled about the families part
02:19:21 <jakub__> forming a heterogeneous list isn't really that difficult
02:20:22 * hackagebot testbench 0.2.0.0 – Create tests and benchmarks together – https://hackage.haskell.org/package/testbench
02:20:48 <ski> (wouldn't you need to put polymorphic values in the list ?)
02:21:13 <jakub__> ski: what do you mean?
02:21:16 <Axman6> yeah that's the difficult bit, trying to unify them with the needed type
02:23:45 <jakub__> ski: the point is to retain those functions that unify with a given type, so depending on the specialisation of `funs` that you use different lists would be obtained (at worst, the list would become empty)
02:24:26 <jakub__> the pool of functions would definitelly need to be heterogeneous, if that was what you were asking
02:25:49 <ski> i suspect you'd need something like `funs :: forall k l m. (Typeable k,Typeable l,Typeable m) => [k -> l -> m]'
02:26:13 <ski> (or perhaps some other constraints, if preferred)
02:26:56 <ski> otherwise i don't see how `length funs' could be different, depending on which `k',`l',`m' is used
02:27:41 <jakub__> lets say that I have a classes C and D, and I have two functions C a => a -> a and D a => a -> a, and I want to produce a function a -> a that applies both functions if they apply
02:28:36 <jakub__> but the point is to erase the constraints
02:29:12 <ski> jakub__ : i mean that it's not good enough to store `f :: a -> b -> c' for some particular choice of `a',`b',`c'. you somehow want to store `f :: forall a b c. a -> b -> c' (let's ignore that this particular type has no interesting inhabitants), i think
02:30:24 <jakub__> ski: you are right, that was just a bad example, sorry
02:34:01 <jakub__> the second description I gave was probably closer to what I need. I have a "family" of functions that are adhoc polymorphic (C a => a -> a, D a => a -> a, (C a, D a) => a -> a, (E a, F a) => a -> a) and I would be content with any value: funs :: Constraint c => [c a => a -> a] if that makes any sense :)
02:46:06 <ventonegro> I am using Chart which uses lens, so I'm like that dog meme which says "I have no idea what I'm doing"
02:47:55 <srhb> ventonegro: Fortunately one can do a lot of cool things without knowing what one is doing!
02:48:28 <ventonegro> Yeah, I'm basically just following the examples
02:55:10 <ski> @let funs :: forall a b. (Typeable a,Typeable b) => [[a] -> [b]]; funs = [const []] ++ [fun | Just Refl <- [eqT :: Maybe (a :~: b)],fun <- [id,reverse] ++ [map toUpper | Just Refl <- [eqT :: Maybe (a :~: Char)]]] ++ [(: []) . length | Just Refl <- [eqT :: Maybe (b :~: Int)]]
02:55:12 <lambdabot>  Defined.
02:55:58 <ski> > map ($ [False,True]) funs :: [String]
02:56:00 <lambdabot>  [""]
02:56:05 <ski> > map ($ [False,True]) funs :: [[Bool]]
02:56:07 <lambdabot>  [[],[False,True],[True,False]]
02:56:10 <ski> > map ($ "False,True") funs :: [String]
02:56:12 <lambdabot>  ["","False,True","eurT,eslaF","FALSE,TRUE"]
02:56:16 <ski> > map ($ "False,True") funs :: [[Int]]
02:56:18 <lambdabot>  [[],[10]]
02:56:21 <ski> > map ($ [2,3,5,7 :: Int]) funs :: [[Int]]
02:56:24 <lambdabot>  [[],[2,3,5,7],[7,5,3,2],[4]]
02:56:28 <ski> jakub__ ^
02:59:22 <ski> jakub__ : determining (as in deciding) whether a type is an instance of a type class sounds harder, because of OWA
03:00:14 <jakub__> ski: thanks
03:02:19 <kuribas> I am surprised there is no SIMD acceleration for vector.
03:02:45 <ski> that's just an example demonstrating what i had in mind. computing the implementation from the types alone (rather than hard-wiring it as i did) would be harder. perhaps possible with type families as Axman6 said (perhaps they had some vague notion of how it could be approached. i don't)
03:04:05 <Cale> kuribas: That you would be surprised about it kind of says something about how sophisticated our language implementation is getting :D
03:04:43 <ski> jakub__ : that example hard-wires `const [] :: forall a b. [a] -> [b]; id,reverse :: forall a. [a] -> [a]; map toUpper :: [Char] -> [Char]; (: []) . length :: forall a. [a] -> [Int]', btw
03:05:04 <kuribas> Cale: yeah, the ingredients are there, SIMD primitives (arithmetic only though), rewrite rules, ...
03:06:59 <jakub__> ski: thanks anyways :) I think I will just drop the idea after all :/
03:07:13 <ski> jakub__ : .. but it's essential to have the `Typeable' constraints on `a' and `b' in the signature of `funs', in order to be able, at run-time, to compare them to each other, and to other types
03:07:44 <jakub__> ski: right
03:08:20 <Cale> jakub__: I sort of feel awkward about that whole situation -- it feels like something which would be better made explicit, using records of methods rather than type classes at all.
03:08:59 <ski> jakub__ : but for type class constraints, even if a modulo doesn't know of an instance `C T', some later third-party module could add such an instance (Open World Assumption). so i don't see how your `funs' would be able to "reflect" on the currently known instances, at least not without some way of referencing a "knowledge context" (or whatever you want to call it)
03:10:28 * hackagebot testbench 0.2.0.1 – Create tests and benchmarks together – https://hackage.haskell.org/package/testbench
03:11:00 <Athas> kuribas: really?  Wasn't there a paper about generalised stream fusion to enable SIMD execution?  That looked like it was applied to vector.
03:11:25 <kuribas> Athas: a paper yes.  But no existing library.
03:11:38 <kuribas> That I am aware of at least.
03:14:21 <kuribas> Cale: sadly no shuffle, no sqrt, sin, ...
03:31:37 <cocreature> I think vector even has some kind of bundle fusion intended for simd. but it’s not actually compiled to simd instructions
03:32:44 * pacak uses SIMD shuffle and a bunch of other stuff in Haskell
03:36:33 <kuribas> pacak: how?
03:36:51 <pacak> kuribas: You can define your own primops
03:37:12 <kuribas> pacak: even SIMD sqrt, sin, etc... ?
03:37:17 <pacak> yep.
03:37:41 <Athas> Doesn't that require runtime hacking?
03:37:57 <pacak> Not really
03:38:33 <pacak> If you want to pass a vector value in register - yes, that will require some tweaks. If you pass it as a pointer - no need.
03:39:20 <kuribas> pacak: is there no overhead from going via the ffi?  Like pushing values on the stack, calling the C function, etc...
03:40:53 <pacak> You push values on the stack anyway, besides in my case they are in a ByteString. Calling c function - that's just one jump - again - you need to do those jumps if you call haskell stuff as well.
03:41:22 <pacak> Overall my code works about 3x faster compared to non-avx version.
03:41:29 <pacak> Good enough for me.
03:41:52 <kuribas> hm, how is that different from writing a SIMD c function and using the ffi?
03:43:29 <pacak> You can't return multiple values from C functions in ffi.
03:43:38 <pacak> via registers
03:44:05 <pacak> Because c calling convention. ghc uses c10 I think
03:44:20 <kuribas> pacak: so primops aren't c functions?
03:45:48 <pacak> They can be. In my case it's a bunch of intrinsics with inline asm
03:46:14 <kuribas> oh cool
03:47:43 <kuribas> pacak: what assembler does ghc use?
03:48:13 <jakub__> ski: you are right
03:48:26 <pacak> Not sure. I compile .c files with gcc and .cmm files with ghc
03:48:33 <pacak> and link stuff together.
03:49:02 <cocreature> ghc probably just calls gcc
03:49:28 <kuribas> pacak: do you have code that I can study?
03:51:57 <pacak> kuribas: http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel/ - you can check here, there are more links and code on github
03:52:18 <jakub__> Cale: maybe. the real context is the following, i have this library github.com/jakubdaniel/expressions for representing expressions in composite language using fixpoint of sum of functors, and I would like to introduce an expression simplifier, i want it to be generic (to pull in any simplification that is applicable based on what functors i mix together) and i want to avoid unnecessary adhoc 
03:52:25 <jakub__> polymorphism (introducing class for every possible simplification and making bunch of instances), I yet don't know how to model this :/
03:52:29 <kuribas> pacak: thanks
04:05:35 <Athas> Amazing, it looks like my code may actually work with GHC 8.2. (I was mostly concerned about the 68 dependencies.)
04:06:28 <Athas> Oops, too early.  Looks like hashable-1.2.6 doesn't work.
04:07:03 <Cale> jakub__: I would probably not attempt to get the instance resolver to figure out which simplifications apply to any given situation, though it's probably possible with enough Olegs of type hackery.
04:07:36 <Cale> jakub__: Instead, just worry about modelling which expression language any given simplifier applies to, and provide combinators for piecing them together.
04:09:06 <Cale> Less automatic, I suppose, but more flexible and expressive.
04:09:34 <exio4> Cale: is an Oleg a new unit for measuring type hackery? >:P
04:09:55 <Cale> exio4: That joke is quite old by now :)
04:09:59 <Cale> exio4: but yeah
04:10:21 <jakub__> Cale: i guess you are right, but my point was to apply simplifications upon construction of every expression, and the constructors are polymorphic
04:10:52 <jakub__> Cale: about the joke, where does it come from :)?
04:12:04 <Cale> Well, this guy http://okmij.org/ftp/ who has done quite a lot in explaining just how powerful the Haskell 98 type system is and what can be accomplished with various extensions as well.
04:12:18 <Cale> He does a lot of type-level-prolog-ish stuff.
04:13:23 <ski> @quote milliOleg
04:13:23 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
04:13:28 <ski> @quote milli-oleg
04:13:28 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
04:13:44 <ADG> how to check if an index is set in Data.Array?
04:14:01 <Cale> ADG: What do you mean by "is set"?
04:14:06 <ADG> like in `array (0,2) [(0,0),(2,2)]`
04:14:16 <ADG> and I access `myArray ! 1`
04:14:23 <cocreature> Athas: make sure you grab the newest release of hashable and that you are using rc3. there was some hickup since 8.2rc3 changed parts of the api in Typeable iirc
04:14:26 <Cale> Ah, don't do that ;)
04:14:27 <ski> "don't do that"
04:14:47 <Athas> cocreature: yes, I had to switch to hashable-1.2.6.1.
04:14:52 <Athas> It seems to work well now.
04:15:09 <Athas> Probably that will be part of the eventual stack snapshot.
04:15:48 <Cale> The "unset" indices will be set to expressions that throw an exception when evaluated, which can't be caught from the context of expression evaluation. (Could be caught in IO, but it's a real pain.)
04:16:04 <Cale> If you need some indices to be effectively "unset", use Maybe
04:16:28 <Athas> Or a data structure more suited for a sparse array.
04:16:42 <Cale> Yeah, Data.Map or Data.IntMap perhaps would be more appropriate
04:17:01 <ADG> I read they are set as _|_
04:17:31 <ADG> can't I do `case myArray ! id of undefined -> 0 v -> v`
04:17:35 <ADG> or something like that
04:17:38 <Athas> Only in the IO monad.
04:17:39 <thimoteus> haha no
04:17:57 <Athas> Bottom explodes whenever you go near it (or maybe it just diverges).
04:18:04 <ADG> so using Data.IntMap would be better
04:18:09 <Athas> Yes.
04:18:15 <Athas> Data.IntMap is pretty fast IME.
04:19:03 <Athas> But if your array is almost-dense that is read very intensely, then making it an array of 'Maybe's might be faster.
04:19:11 <Cale> ADG: _|_ refers to the value of any expression whose evaluation doesn't terminate (which includes both exceptions and infinite loops)
04:19:23 <Cale> ADG: So in a way you'd be asking for a solution to the halting problem
04:19:39 <ADG> quite interesting
04:21:19 <Cale> In general, we only use exceptions from evaluation when we're pretty certain that either the branch will never be evaluated, or at least that if it is, nobody will want to try to handle the exception.
04:21:39 <Cale> Exceptions thrown from the execution of IO actions (e.g. with throwIO) are another matter.
04:22:48 <Cale> But it's tricky enough to catch an exception thrown with the likes of 'error' or 'undefined' or 'throw' that generally it shouldn't be attempted except as a last resort. I would (and have) modified the libraries I depend on to avoid having to catch such an exception.
04:27:30 <Athas> Usually you only catch those at the top level to print a better error message, or prevent shutdown of the entire process.
04:28:24 <Athas> In my compiler, I catch those at the top level so I can print an error message containing a link to the Github issues page!
04:28:24 <monad_cat> in recursion-schemes, what's the need for Mu and Nu?
04:31:30 <ertes-w> monad_cat: those are algebraic (church-style) and coalgebraic encodings respectively…  they represent the data structure in terms of its fold and unfold *directly*
04:31:53 <pacak> monad_cat: Mu and Nu directly encode the idea of least and greatest fixed points  corresponding to initial algebras / final coalgebras respectively (ie.  Mu contains a fold,  and Nu contains an unfold).  However, since  greatest and least fixed points coincide, everything can have both  Foldable and Unfoldable instances.
04:32:03 <ertes-w> monad_cat: Nu in particular gives you an explicitly stateful encoding
04:32:24 <ertes-w> it gives you a state and an update function
04:33:29 <dramforever> What are some practical applications of those, though?
04:33:32 <monad_cat> I see the algebra/coalgebra part, but not sure about the stateful encoding business
04:33:41 <dramforever> :t unfoldr
04:33:43 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
04:33:56 <dramforever> I would not be surprised if they fuse better but I would doubt...
04:34:06 <ertes-w> monad_cat: Nu :: (a -> f a) -> a -> Nu f
04:34:37 <ertes-w> monad_cat: the value (Nu update s) gives you the "current state" s together with an update function to generate the next layer of information as well as new states
04:35:04 <monad_cat> makes sense ertes-w, thanks :)
04:35:53 <ertes-w> monad_cat: as for the utility of Mu i suggest that you look at the church encoding of Free and FreeT, respectively called F and FT and found in the .Church modules
04:39:04 <Athas> Hm, GHC 8.2 does seem slightly faster on my code.
04:39:11 <Athas> That's good.
04:39:39 <srhb> Athas: Know what changed? The join point stuff?
04:41:08 <Athas> I'd think join points actually slow down the compiler.
04:41:29 <srhb> Oh, GHC itself. Sorry, I misunderstood.
04:41:48 <Athas> I doubt there's anything GHC could do to make my own code faster!
04:42:14 <srhb> :-P
04:42:48 <monad_cat> ertes-w: where are the .Church modules? Can't find them in recursion-schemes
04:42:51 <Athas> Hard to do much when the whole thing's a bunch of map lookups.
04:43:38 <ertes-w> monad_cat: ah, no, i mean in the 'free' package
04:43:42 <edwardk> Axman6: you can't have them in general along with functions
04:43:49 <monad_cat> got it
04:44:26 <ertes-w> monad_cat: Fix and Mu for recursive structures correspond to Free and F for free monads
04:45:13 <edwardk> Axman6: if you add a functor that is 'left adjoint' to Either e, it becomes your "cofunction" more properly a coexponential. With it you get "cocurrying" and "coapplication"
04:45:56 <edwardk> But if you have arbitrary coexponentiald and arbitrary exponentials the pile of laws becomes so constraining that your entire category collapses to a loser
04:46:19 <edwardk> er poset (autocorrect)
04:51:09 <tabaqui> hmm
04:51:24 <tabaqui> there is no source code for  (Ord a, Ord b) => Ord (a, b) in hackage
04:51:32 <tabaqui> and for Ord a => Ord [a]
04:52:21 <tabaqui> there are compared in lexicographic order, right?
04:52:33 <Clint> tabaqui: check GHC.Classes
04:52:37 <tabaqui> *graphical
04:52:58 <Cale> tabaqui: "lexicographic" is fine, and yes.
04:53:27 <tabaqui> Clint: which package? I cannot see GHC.Classes in base
04:53:30 <tabaqui> Cale: thanks
04:53:31 <Cale> Those will probably have the derived instances, and that's how the derived instances work.
04:54:07 <Cale> i.e. first compare constructors (in the order that they occur in the data declaration), and then compare corresponding fields from left to right
04:54:26 <Clint> tabaqui: ghc-prim
04:54:54 <tabaqui> wow, didn't know that Ord can be derived
04:55:11 <Cale> It's... one of the only few classes that *can* be derived :)
04:55:18 * tabaqui is watching the full list
04:56:15 <tabaqui> Clint: there is no documentation for GHC.Classes in ghc-prim-0.5 on hackage
04:56:48 <Clint> tabaqui: i can't change that
05:31:31 <kuribas> Shouldn't runState, execState, etc... have their arguments reversed?
05:31:35 <kuribas> :t runState
05:31:36 <lambdabot> State s a -> s -> (a, s)
05:33:06 <kuribas> for example: flip runState s $ state $ \st -> ...
05:33:55 <kuribas> not that it ever will though...
05:36:12 <ski>   (`runState` s) $ do ...
05:36:29 <kuribas> thanks quite ugly
05:36:36 <kuribas> I prefer flip
06:11:55 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
06:11:55 --- topic: set by geekosaur on [Wed Apr 05 12:49:54 2017]
06:16:13 <lambdamu> Is GHC trac broken for anyone else: https://ghc.haskell.org/trac/ghc/ticket/13819
06:16:16 <lambdamu> ?
06:16:33 <mpickering> Is it possible to write template haskell which generates template haskell splices?
06:17:36 <merijn> mpickering: What do you want that for?
06:18:36 <mpickering> That's the correct question
06:18:40 <mpickering> I don't think I actually do
06:27:03 <AWizzArd> Which lib is recommended for reading/writing safe passwords? Some tool that lets me encrypt/decrypt passwords via (for example) PBKDF2, so I won’t have to store my DB connection password in clear text in source code.
06:27:41 <merijn> AWizzArd: PBKDF2 doesn't let you decrypt passwords
06:28:08 <merijn> AWizzArd: Your program should prompt for a DB connection password on startup
06:28:24 <merijn> AWizzArd: Or take the password as commandline argument
06:28:27 <cocreature> I tend to use env vars for that
06:28:33 <merijn> That also works
06:28:49 <AWizzArd> merijn: then I would need another program which will type it in an automated way, so apps can restart themselves on AWS.
06:29:18 <Liskni_si> commandline is often visible to other users on a system, not a good place for passwords
06:30:18 * hackagebot travis-pogodi 0.1.0 – A better travis_wait – https://hackage.haskell.org/package/travis-pogodi
06:30:18 * hackagebot ip 0.9.2 – Library for IP and MAC addresses – https://hackage.haskell.org/package/ip
06:41:41 * hackagebot debian 3.92 – Modules for working with the Debian package system – https://hackage.haskell.org/package/debian
07:01:56 <zwild> ure
07:03:42 <zwild> y
07:27:12 * hackagebot path-io 1.3.2 – Interface to ‘directory’ package for users of ‘path’ – https://hackage.haskell.org/package/path-io
07:29:13 <osa1> just to make sure I get it right, in the last line here http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-IORef.html does that mean if I swap writeIORefs in the original exapmle with atomicWriteIORefs I can't ever get "critical section" printed twice?
07:30:11 <merijn> osa1: Yes
07:30:19 <osa1> thanks merijn
07:30:46 <osa1> I think I just observed this reordering behavior although it's hard to make sure because I can't reproduce it
07:31:16 <merijn> osa1: Any specific reason you're using IORef over MVar/TVar?
07:31:58 <osa1> merijn: it's just that I don't need MVar operations, I'm just doing writes and one read after the thread's done/killed
07:32:19 <merijn> osa1: Well, with MVar you never have to worry about ordering, etc.
07:32:54 <osa1> merijn: you're right, maybe I should switch to MVars everywhere and reduce the mental overhead.
07:33:23 <merijn> osa1: I would only use IORef if there was some specific reason MVars would be to costly
07:33:28 <osa1> sometimes more limited APIs are better because you can't misuse them
07:35:29 <osa1> so what I really need is IORef + barriers
07:35:49 <merijn> MVar is already a barrier :)
07:35:55 <osa1> more specifically I need to make sure that writes in the thread will be visible after the thread is killed or done
07:35:58 <freeside> it's already more than enough rope for you to be hoist by your own can of worms.
07:35:58 <osa1> I know
07:38:47 <osa1> so what if I replaced every writeIORef with the atomic variant? I don't need MVar operations (take, modify in IO etc.). would an MVar be any better in that case?
07:39:20 <osa1> freeside: what's already more than enough?
07:39:47 <merijn> osa1: I have more confidence about me not messing up a multi-thread barrier with MVar then I do with IORef
07:51:28 <schmidt73> Does anyone know of any interesting open source haskell projects that I could help out with? I've been trying to look on github, but I haven't had much success
07:52:20 <mpickering> Is there a way to use "mkName" in template haskell with a data constructor? 
07:52:33 <Athas> schmidt73: what about one of the Haskell programs/libraries that you use yourself?
07:52:35 <mpickering> It seems that  it always expects the name to be in the variable name space
07:53:10 <schmidt73> Athas: I'm pretty new to haskell so I haven't really worked on many of my own projects.
07:53:37 <schmidt73> Athas: I've spent a lot of time just learning and toying around
07:54:38 * hackagebot gogol 0.3.0, gogol-adexchange-buyer 0.3.0, gogol-adexchange-seller 0.3.0, gogol-admin-datatransfer 0.3.0, … and 83 more
07:54:38 * hackagebot  → https://hackage.haskell.org/packages/recent
07:54:39 <merijn> schmidt73: GHC, cabal-install, and pandoc come to mind :)
07:55:16 <merijn> schmidt73: Especially cabal-install could use some more manpower
07:55:46 <schmidt73> merijn: Do you think they would be over my head or could I ease into them
07:56:00 <Athas> There is low-hanging fruit in most projects.
07:56:02 <schmidt73> merijn: And for cabal-install would I just start working on bugs?
07:56:30 <Athas> For cabal-install, I remember long ago being annoyed that there was no progress bar for 'cabal update', making it impossible to see whether it was hanging.  Maybe that's fixed now.
07:56:37 <merijn> schmidt73: cabal-install and GHC use rather simple Haskell, actually (as in, very few complicated extensions). But they're big projects, so that can make them confusing/intimidating
07:57:17 <schmidt73> merijn: Like I really don't even fully understand cabal too well
07:57:27 <schmidt73> merijn: I guess I would learn as I went
07:57:31 <merijn> schmidt73: There's certainly a lot of "low priority" low-hanging fruit in terms of improvements
07:58:13 <merijn> You could help fix ghc-mod to work with cabal new-build, that'd alone would make you a hero ;)
07:58:17 <Athas> You could also add/improve test suites of some of the well-known libraries.  That'd be good exercise, and fairly straightforward.
07:59:15 <lyxia> mpickering: $(conE (mkName "Nothing"))
07:59:19 <lyxia> seems to work
07:59:38 <Athas> For example, it looks like the test suite for 'unordered-containers' isn't quite complete.  You could probably adapt a lot of tests from 'containers'.
07:59:39 <schmidt73> ghc-mod is the one that checks for syntax stuff right?
07:59:47 <mpickering> lyxia: I was trying, '(:*:)
07:59:58 <mpickering> and [| R0 |]
08:00:26 <mpickering> ah I see
08:00:43 <Tuplanolla> We could always do with more symbolic algebra and computational geometry libraries too, schmidt73.
08:00:58 <mpickering> I guess the namespace is decided by whether you use "conE" or "varE" rathr than the name you are using
08:01:12 <schmidt73> Tuplanolla: We currently don't have many?
08:01:30 <mpickering> That doesn't sound like something very suitable for a beginner though.. 
08:01:30 <Tuplanolla> For some uses we don't have any, schmidt73.
08:02:08 <merijn> schmidt73: Yeah, ghc-mod does online syntax checking, but also things like "what is the type of this expression?" and "where is this function defined?" kinds of things :)
08:02:41 <schmidt73> And does cabal new-build not build it correctly?
08:02:47 <Tuplanolla> You won't find packages for higher-dimensional Delaunay triangulation, Voronoi cell generation or point set registration for example, schmidt73.
08:03:08 <grmp> hgeometry?
08:03:11 <schmidt73> Tuplanolla, I have no idea what any of those things are lol
08:03:15 <grmp> https://hackage.haskell.org/package/hgeometry
08:03:28 <merijn> schmidt73: Cabal new-build is a new feature in cabal-install 2.0, but ghc-mod can't correctly find what flags to use for typechecking when using ghc-mod on packages using new-build
08:03:36 <Tuplanolla> Isn't that planar only, grmp?
08:04:28 <grmp> not so sure, it seems to handle "n-dimensional space"
08:04:42 <GreySunshine> Hi! While installing ghc in windows what path variable an I supposed to set to make it work from any directory?
08:04:54 <schmidt73> Oh interesting
08:04:59 <mpickering> schmidt73: There are lots of open issues on both the cabal and stack issue tracker but most importantly, people will help you with your pull request on either of those projects as they are actively developed
08:05:01 <grmp> they have: Point d r, a d-dimensional point
08:05:15 <Tuplanolla> The type signatures say `NonEmpty (Point 2 r :+ p)` though, grmp.
08:05:23 <schmidt73> That's what is most important I think
08:05:30 <mpickering> otherwise you should just try writing something for your own use or find a library which you are interested in
08:05:30 <schmidt73> I can try to work on those
08:05:41 <merijn> schmidt73: Incidentally #ghc and #hackage have lots of ghc and hackage/cabal/cabal-install devs, respectively who can help you get started
08:05:42 <schmidt73> I need to understand stack and cabal better anyhow
08:06:42 * hackagebot b9 0.5.32, gogol-adsense 0.3.0, gogol-android-enterprise 0.3.0, gogol-apps-licensing 0.3.0, … and 18 more
08:06:42 * hackagebot  → https://hackage.haskell.org/packages/recent
08:07:08 <brynedwards> GreySunshine: Did you install Haskell Platform?
08:07:14 <kuribas> Is it possible to make an (unordered) Map (a, b) c, where the order of a and b doesn't matter?
08:08:02 <Tuplanolla> Is this supposed to be an undirected graph, kuribas?
08:08:11 <dolio> How can the order not matter in that case?
08:08:11 <GreySunshine> brynedwards, yes ghc 8.0.2
08:08:13 <kuribas> Tuplanolla: yeah
08:08:17 <c_wraith> kuribas: that seems painful if a and b are different types
08:08:20 <dolio> Do you mean (a, a)?
08:08:22 <glguy> kuribas: maybe you meant Map (a,a) b?
08:08:26 <Tuplanolla> How about using an actual graph, kuribas?
08:08:26 <kuribas> glguy: yeah
08:08:37 <kuribas> Tuplanolla: I am creating one using the map :-)
08:08:43 <Tuplanolla> @hackage fgl
08:08:44 <lambdabot> http://hackage.haskell.org/package/fgl
08:09:06 <grmp> https://github.com/snowleopard/alga
08:09:10 <kuribas> Tuplanolla: it's the dual graph from a triangulation.
08:09:26 <dolio> kuribas: If you defined an ordering on pairs where order didn't matter, that should work. It'd have to be a separate type of course.
08:09:31 <cocreature> kuribas: I have sometimes defined by own type which just stores two maps and takes care of preserving the invariants
08:09:44 <cocreature> oh wait nvm
08:09:46 <cocreature> I can’t read
08:10:00 <kuribas> dolio: right, I can make an Edge type, with a constructor that sorts the two points.
08:10:19 <kuribas> I like that solution :)
08:11:03 <brynedwards> GreySunshine: I think the installer added them for me but these are mine http://lpaste.net/356896
08:11:43 <Tuplanolla> @let newtype Sideways a = Sideways a deriving (Eq, Read, Show)
08:11:44 <lambdabot>  Defined.
08:12:53 <kuribas> Tuplanolla: Currently the graph is a vector, where an edge is simply an index into the vector.  It will make it easy to port to C++ later.
08:13:06 <Tuplanolla> @let instance Ord a => Ord (Sideways a) where comparing (Sideways x) (Sideways y) = case comparing x y of {GT -> LT; r -> r}
08:13:07 <lambdabot>  .L.hs:163:9: error:
08:13:07 <lambdabot>      ‘comparing’ is not a (visible) method of class ‘Ord’
08:13:23 <Tuplanolla> @let instance Ord a => Ord (Sideways a) where compare (Sideways x) (Sideways y) = case compare x y of {GT -> LT; r -> r}
08:13:25 <lambdabot>  Defined.
08:13:41 <GreySunshine> brynedwards, Thanks, I didn't install in on my machine. I 'm trying to do for AppVeyor-CI. Thanks for that.
08:13:46 <Tuplanolla> This play on `Down` could also work, kuribas.
08:13:58 <brynedwards> np
08:14:16 <kuribas> :i Down
08:14:30 <kuribas> @hoogle Down
08:14:30 <lambdabot> Data.Ord newtype Down a
08:14:31 <lambdabot> Data.Ord Down :: a -> Down a
08:14:31 <lambdabot> GHC.Exts newtype Down a
08:15:37 <kuribas> @hoogle Ord a => (a, a) -> (a, a)
08:15:37 <lambdabot> Data.Tuple.HT sortPair :: (Ord a) => (a, a) -> (a, a)
08:15:37 <lambdabot> Utility sortTuple :: (Ord a) => (a, a) -> (a, a)
08:15:37 <lambdabot> Music.Theory.Tuple t2_sort :: Ord t => (t, t) -> (t, t)
08:18:47 <Tuplanolla> Even funnier would be defining lenses for this.
08:19:58 <Tuplanolla> That is, `lesser, greater :: Lens' (a, a) a`.
08:22:34 <kuribas> > over partsOf sort (1, 1)
08:22:37 <lambdabot>  error:
08:22:37 <lambdabot>      • Couldn't match type ‘s0 -> f0 t0’ with ‘Identity t’
08:22:37 <lambdabot>        Expected type: ASetter
08:23:21 <kuribas> > over (partsOf each) sort (1, 2)
08:23:23 <lambdabot>  (1,2)
08:30:51 <kuribas> it's like hitting a mosquito with a sledgehammer...
08:31:20 <c_wraith> a swiss-army sledgehammer
08:32:16 <Tuplanolla> Anything to justify the sunk cost.
08:32:57 <Tuplanolla> You spent four hours installing `lens`, so you might as well use it.
08:33:45 <shapr> lens helps me focus
08:34:54 <orion> In opaleye one design pattern is to use a polymorphic type to convert between the Haskell and Postgres representations. What is the standard way of converting from one representation to the other? Opaleye does it behind the scenes, and I am still trying to figure it out.
08:37:24 <Cale> Tuplanolla: Why would it take 4 hours to install lens? What are you doing? :D
08:37:41 <jaj> Hi, I'm trying to create precise delays in haskell. I'd like to have some sort of clock running at 180 Hz to stream data at this frequency using pipes. Currently I use a dedicated thread doing nothing but threadDelay and setting an MVar but it's not precise enough
08:37:42 <Tuplanolla> Swapping for days, Cale.
08:37:48 <srhb> Cale: You've been pampered by Nix, too. :-P
08:38:56 <c_wraith> jaj: GC pauses can last multiple milliseconds.  You'll never hit that target with GHC.
08:42:52 <jaj> c_wraith: maybe if I inhibit GC? The program does not have a big memory footprint and needs constant memory space. Others ideas I have are implementing the timer in C and use some music library like Haskore to do the timing. I don't mind if the frequency is not constantly at 180 HZ, I would just like it to average at 180 Hz and not oscillate too much.
08:45:48 <Tuplanolla> What are you doing that cannot handle buffering, jaj?
08:49:52 <jaj> c_wraith: disabling GC as much as possible does not change the delays at all. I think the delay comes only from thread scheduling
08:50:33 <c_wraith> well, that's certainly also a factor.  Which runtime are you using?
08:50:47 <c_wraith> ie, are you compiling with -threaded?
08:50:55 <jaj> c_wraith: hmm no
08:51:19 <c_wraith> Then everything is running on a single OS thread being scheduled by GHC's non-threaded runtime
08:54:58 <jaj> Tuplanolla: I'm creating a framework to log data from medical devices in the operating theater. A lot of independent devices are connected to a patient measuring different things. Most devices can export data most of the time using some serial protocol. I'm writing small programs in haskell which parse the serial protocols and stream the data to a central logger using pipes, attoparsec and zeromq
08:55:48 <Tuplanolla> Why the time requirement, jaj?
08:57:17 <sproingie> hard real time in haskell is a tall order
08:57:33 <sproingie> heck it has a hard enough time hitting soft deadlines
08:58:07 <sproingie> a haskell DSL that compiles down to something RT-friendly might be the best bet
09:01:54 <jaj> Tuplanolla: It's important that the different signals are synchronized so we can analyze interactions of blood flow, pressure, etc. (the data is analyzed for clinical research). We decided that the logger at the other side of the socket should be the one taking care of setting the timestamps. So the logger will log the data the moment it receives it.
09:02:24 <jaj> So I cannot send chunks, otherwise it will create wrong time stamps.
09:03:18 <jaj> I have one particular device which outputs chunks of data. It actually has a sample rate of 180 Hz but outputs bytestring which correspond to more or less 1 second worth of data. So I have to resample it before sending it to the logger.
09:03:20 <Tuplanolla> Wouldn't it be easier to timestamp them at each point of the pipeline and statistically correct them at the end, jaj?
09:06:26 <jaj> sproingie: I'm not looking at hard real time. I want to send data approximately every 5ms which should leave plenty of time for the CPU to do other stuff.
09:08:56 <jaj> agreed maybe haskell is not the language of choice for this particular device. But I was very happy with my program design using pipes where the entire program consists of a single pipe handling serial port reading, attoparsec, serialization using msgpack and output to zeromq. I don't think I can do this in another language so reliably
09:10:36 <Tuplanolla> Regardless of language, if any part of your pipeline stalls (which I'd expect to happen eventually), you'll be in trouble without said timestamps, jaj.
09:11:29 <sproingie> you could tune the GC but it's not deterministic, so you'll never get a guarantee.  which may be no big deal if you can buffer and make it up later, but you'll need those timestamps then
09:12:03 <sproingie> since i don't imagine it's connected to the actual control of said devices, right?  (i would hope not)
09:13:00 <Lokathor> :t foldr
09:13:02 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:13:21 <jaj> sproingie: of course not, it's just logging
09:13:44 <Lokathor> @src foldr
09:13:44 <lambdabot> foldr f z []     = z
09:13:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:14:06 <sproingie> have sufficient buffering then, and plan to have a "Dropped" message just in case
09:15:34 <sproingie> you could also just consider a gap in timestamps to be dropped, but it's helpful to know when data was explicitly dropped
09:15:41 <jaj> Maybe I can write a small C program which create a more or less accurate timer and use the FFI to set an MVar each time the timer fires. The main thread will then wait on the MVar. If the GC kicks in from time to time I will get some delay which I don't mind
09:16:21 <sproingie> is there some extra requirement that requires this to be so synchronous?
09:16:33 <sproingie> since i'm also with everyone else saying "just timestamp all the things"
09:16:46 <Tuplanolla> Based on your description, I find your approach to be too naive, jaj.
09:17:26 <Tuplanolla> Your first mistake is trusting that computers actually work, jaj.
09:17:41 <jaj> sproingie: It's hard to keep the clocks in sync
09:17:46 <sproingie> you don't have to
09:17:59 <sproingie> if both ends timestamp, then you just subtract the difference
09:18:23 <sproingie> unless one end is in orbit and another on the ground, the clocks should run the same
09:19:27 <Tuplanolla> Even if they don't, you can do regression analysis at the end to make up for it, sproingie.
09:20:07 <sproingie> truth is there's more to it, statistical smoothing and all, which is all mathy math that some lib can do.  me, i just throw my telemetry into rrdb and let it handle it :)
09:20:32 <jaj> hmm or maybe I could send time deltas
09:20:36 <Tuplanolla> Some sort of local least squares isn't what I'd call "mathy math", but okay...
09:20:56 <sproingie> i barely remember high school math
09:21:32 <sproingie> product of an american education plus ADHD :-/
09:23:15 <mniip> is there a foldr (<|>) empty
09:23:17 <sproingie> keeping the clocks synchronous means you have to control for all the things, including network latency.  sure your switch is that precise?
09:23:18 <jaj> I don't want to do too much post processing. I will not be around all the time and some people will want to use the data without knowing all the hoops. They need csv files with one timestamp and columns with all the different signals
09:24:33 <sproingie> but if you're really wedded to the synchronous approach, i'd have a front-end in C that shuttled around the raw bits with the requisite delays, then hand it off to some haskell for processing
09:25:10 <jaj> sproingie: I'm pretty sure 5 ms is a whole epoch for a network switch. Again I don't mind if there is some processing overhead since it should be relatively constant and will just add a constant delay
09:25:12 <sproingie> i recommend shaving your head before doing this, since you'll be tearing your hair out otherwise
09:25:34 <sproingie> desynchronization happens a microsecond at a time
09:25:46 <sproingie> get enough of those and you're talking real lag
09:26:34 <Lokathor> i have an input list, two temporary value containers, and a call to make that gives back two new temporary values tupled up. My halt condition is when the input list is empty OR when a specific one of my two temporary values is empty
09:26:40 <jaj> no since the computer RTC will not lag and will tell the correct time. So the lag will not accumulate
09:26:54 <Lokathor> is there a way to contort this into one of haskell's many higher order library functions?
09:27:10 <jaj> if I get some lag, the next cycle will fire a bit sooner to make up for it
09:27:16 <sproingie> lag accumulates in every layer, from the OS to the networking hardware.  but anyhoo, i've said my piece .. peace :)
09:27:45 <Eduard_Munteanu> :t asum
09:27:47 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
09:27:57 <Eduard_Munteanu> mniip, ^ ?
09:28:05 <mniip> right, found it
09:31:29 <sproingie> Lokathor: sounds a bit like merging three streams.  maybe something in conduit?
09:32:27 <sproingie> i'd have a pat answer with RxJS, but conduit and company escape me still
09:35:47 <slack1256> @type callCC
09:35:48 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
09:37:36 <slack1256> One difficulty I got with this type, I got to define the outer arrow `using` ((a -> m b) -> m a). Yet I can define (a -> m b) to pass
09:38:06 <slack1256> it is like I am in a game, where outer arrows are my moves and arrows to the left are my oponent moves
09:38:18 <slack1256> mind bending
09:38:33 <sproingie> here i am stuck in the middle with you
09:38:37 <kuribas> Lokathor: a right fold?
09:38:46 <Lokathor> hmmmm
09:39:02 <Lokathor> well i made *a* right fold, but i did not make *the correct* right fold
09:40:02 <Lokathor> http://lpaste.net/356897
09:41:31 <Lokathor> this seems like it'd be kinda trivial as a foldl', but i really really need it to be able to terminate early when the [View] is empty
09:42:01 <MarcelineVQ> does checkSub terminate early?
09:42:39 <Cale> slack1256: Are you trying to define callCC, or trying to use it?
09:42:47 <Lokathor> the non-fold version teminates when the input list is empty OR when the list of views is empty, yes
09:43:06 <Cale> slack1256: If you're trying to use it, it's easy, you just pass it a lambda
09:43:23 <slack1256> trying to define it.
09:43:30 <Cale> ah, okay
09:43:43 <slack1256> Well no, I already defined it. Trying to do what I did lol
09:43:55 <slack1256> *to understand
09:44:56 * hackagebot copilot 2.2.1, debian 3.92.1, copilot-c99 2.2.1, copilot-cbmc 2.2.1, … and 5 more
09:44:56 * hackagebot  → https://hackage.haskell.org/packages/recent
09:45:09 <Cale> slack1256: One way I like to think about it is that it's common in imperative languages for various constructs to do something like callCC and then give you a limited way to use the continuation.
09:45:55 <Lokathor> MarcelineVQ, seems like the fold version only uses the input set :/
09:45:56 <Cale> slack1256: For example, every procedure definition in most imperative languages will implicitly be wrapped in callCC, and then when you write "return v", what it does is to apply the continuation it got from that to v
09:46:33 <Cale> (what it doesn't give you is a way to pass that continuation on as a value to something else)
09:47:02 <Cale> similarly with looping constructs and 'break'
09:47:02 <dmwit> With `data` and `newtype`, you can hold a type abstract by exporting its name but none of its constructors or fields. I wish an analogous thing were possible with `type`.
09:47:11 <Cale> dmwit: Yes
09:47:21 <Lokathor> dmwit, it is, but in haskell we call it "newtype" :3
09:47:35 <Cale> Lokathor: that's not really the same
09:47:47 <dmwit> Lokathor: The problem with newtype is that they eliminated the runtime overhead, but left in the programmer-time overhead. =/
09:47:52 <kuribas> Lokathor: the foldr has the order wrong.
09:47:59 <Lokathor> if you don't want the user to be able to construct their own values, what do you think they're doing with it?
09:48:04 <Cale> It would have made type synonyms much more useful if we had the option of neglecting to export the equality of the synonym and the original type from a module
09:48:17 <dmwit> Lokathor: Constructing and consuming them with the functions I'm providing in this module, of course.
09:48:18 <Lokathor> dmwit, ah, yeah :/
09:48:34 <Lokathor> kuribas, could you expand on that?
09:48:49 <Cale> Also, sometimes you have real runtime overhead due to things like having to map the newtype constructor over a data structure, and hence you end up needing things like coerce
09:48:56 <Cale> (before which, you just ate the runtime overhead)
09:49:07 <ski> in the MLs, you can export type synonyms abstractly
09:49:17 <ski> (also HuGS had this)
09:49:21 <Lokathor> Cale, doesn't that constructor get compiled away and thus no actual map and thus no actual overhead?
09:49:30 <Cale> Lokathor: no, the map is still there
09:49:32 <ski> Lokathor : in general, no
09:49:36 <Lokathor> ghaaa :(
09:49:37 <Cale> Lokathor: you're just mapping an identity function
09:49:48 <Lokathor> a billion curses
09:49:53 <dmwit> Lokathor: The constructor gets turned into `id`. But `map id` is still slower than `id`, even though they're denotationally equivalent.
09:49:58 <ski> you're traversing the structure, applying an O(0) operation. it's still `O(n)' in `n' the size of the structure
09:50:10 <Lokathor> doesn't ghc have a rewrite rule for that
09:50:12 <Lokathor> seems like it should
09:50:20 <Cale> For what exactly?
09:50:25 <mniip> it might have a rule for map id
09:50:31 <mniip> but the newtype con is *not* id
09:50:32 <Lokathor> map id foo ---> id foo, or even just foo
09:50:35 <mniip> it has a different type
09:50:37 <Lokathor> awh
09:50:39 <geekosaur> doesn't this happen too late for rewrite rules?
09:50:48 <dmwit> Lokathor: The elimination of the newtype constructor happens after rewrite rules have fired.
09:50:54 <Cale> yeah, rewrite rules will see the newtype
09:50:59 <Lokathor> all the curses in the universe
09:51:08 <ystael> also ncurses
09:51:11 <ADG> what does replicateM does do?
09:51:13 <dmwit> Lokathor: ...hence my wish. =)
09:51:16 <Cale> Lokathor: well, there's coerce
09:51:19 <dmwit> ?src replicateM
09:51:19 <lambdabot> replicateM n x = sequence (replicate n x)
09:51:23 <Lokathor> ADG it does the M action the number of times
09:51:25 <MarcelineVQ> Lokathor: where are sx sy qx qy coming from?
09:51:27 <Cale> That's why coerce exists
09:51:36 <Cale> :t coerce
09:51:38 <lambdabot> error:
09:51:38 <lambdabot>     • Variable not in scope: coerce
09:51:38 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
09:51:41 <ADG> ok so it print n times?
09:51:50 <Lokathor> MarcelineVQ, fixed values from an outer scope
09:51:51 <ADG> or any IO n times?
09:52:04 <Cale> :t Data.Coerce.coerce
09:52:05 <lambdabot> Coercible a b => a -> b
09:52:29 <Cale> and then you have all the crazy role shenanigans to get into
09:52:42 <MarcelineVQ> Lokathor: :X you tend to be a little monolithic
09:53:00 <Lokathor> MarcelineVQ, http://lpaste.net/356898 like this
09:53:02 <kuribas> Lokathor: if you want to turn a left fold into a right fold you need to use CPS.
09:53:23 <dmwit> Cale: I wonder how much an educated reader of your documentation could guess about your abstract type synonym's implementation just by looking at what classes it implements. =P
09:53:29 <Lokathor> kuribas, on the grounds that i don't know how to do that, i will simply live with a manual recursion
09:53:41 <kuribas> Lokathor: that's perfectly fine
09:53:54 <dmwit> ADG: You can repeat any monadic action n times, even if it isn't IO.
09:53:59 <dmwit> > replicateM 3 "abc"
09:54:02 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
09:54:11 <dmwit> > replicateM 3 (Just "hi")
09:54:13 <lambdabot>  Just ["hi","hi","hi"]
09:54:19 <ADG> oh!
09:54:45 <dmwit> > runState (replicateM 3 (modify (+1))) 3
09:54:47 <lambdabot>  ([(),(),()],6)
09:54:55 <Eduard_Munteanu> > forever Nothing
09:54:58 <lambdabot>  Nothing
09:55:10 <kuribas> Lokathor: the idea is that your accumulator is a function.
09:55:29 <Lokathor> people have mentioned it over and over
09:55:36 <Lokathor> some day i suppose i should learn what it does :3
09:55:54 <Cale> A cute thing I only discovered somewhat recently is that 'many' is actually quite useful in IO
09:55:57 <ADG> also can I use accumArray to accumulate values into a set?
09:56:09 <Lokathor> :t many
09:56:10 <lambdabot> Alternative f => f a -> f [a]
09:56:16 <Cale> You can run an IO action until it fails, collecting a list of the results
09:56:24 <dmwit> ADG: Try it and see!
09:56:31 <Cale> (fails meaning throws an exception)
09:56:39 <Lokathor> Cale, hmm, that's almost something i want on a regular basis
09:56:53 <Lokathor> but usually i want to use the intermediate values as they come in
09:57:01 <Eduard_Munteanu> Hm, I can't say I've used Alternative much for IO.
09:57:09 <ADG> how efficient then `accumArray (1,n) Set.unions . Array.amap Set.singleton` would be
09:57:22 <Cale> Lokathor: Well, in that case, you want pipes or something for real
09:57:39 <Lokathor> i just did it as a loop in my IRC bot
09:58:03 <Lokathor> maybeBytes <- recv socket ; case maybeBytes of ...
09:58:06 <Cale> Or that, you can just avoid abstracting
09:58:25 <Lokathor> conduit would be cool i gues
09:58:44 <Cale> I'm fairly sure I prefer pipes to conduit
09:58:56 <Lokathor> or pipes
09:59:16 <Cale> They're pretty similar, but conduit is just sort of weird in various places -- its implementations of things are less obvious
09:59:23 <Eduard_Munteanu> Cale, any particular reason why? The only reason I've used conduits so much is because it's popular and widely-implemented.
09:59:35 <Eduard_Munteanu> Hm.
10:00:34 <Eduard_Munteanu> One thing that kinda bugs me is why they didn't go with a MonadConduit cllass instead of all those types.
10:00:39 <kuribas> Lokathor: something like this: foldr (\elem cont acc -> ..) id
10:00:40 <vktec> Is there a way to find the qualified name of a function from inside ghci? I often find myself wanting to look at docs, but the function I'm interested in is in a module that's reexported so it's difficult to find
10:01:03 <Lokathor> kuribas, but.. the foldr func only accepts two arguments?
10:01:19 <kuribas> Lokathor: yes, and the second argument is a function
10:01:30 <Eduard_Munteanu> Although the types would look much more contrived with typeclasses.
10:01:36 <srhb> vktec: Like, given the unqualified name, find the qualified name?
10:01:53 <Lokathor> kuribas, i mean the lambda has to only accept two arguments i thought
10:01:53 <Cale> Oh, await
10:01:58 <Cale> await is weird in Conduit
10:01:59 <vktec> srhb: Yes, exactly
10:02:03 <Cale> and it makes everything else weird
10:02:12 <Cale> await :: Monad m => Consumer i m (Maybe i)
10:02:19 <Cale> It produces a Maybe result
10:02:21 <kuribas> Lokathor: it does.  You can rearrange it if you like: foldr (\elem cont -> \acc -> ..) id
10:02:40 <kuribas> Lokathor: it returns a continuation.
10:02:42 <srhb> vktec: I don't think so, sadly.
10:02:51 <Cale> await :: Monad m => Consumer' a m a -- in pipes
10:03:06 <kuribas> Lokathor: cont is a continuation which you call with the accumulator.
10:03:18 <Eduard_Munteanu> Cale, huh? How do you detect when upstream sources finished?
10:03:21 <Lokathor> ohhh, right
10:03:24 <Lokathor> cause they're nested
10:03:36 <sproingie> making a :hoogle command inside ghci is sometimes helpful.  be nice if :i could give that info tho
10:03:46 <vktec> srhb: That's a shame. How would you recommend searching for documentation on specific functions inside reexported modules? Hackage's documentation browser doesn't seem to have a search function
10:04:11 <sproingie> :def hoogle \s -> return $ ":! hoogle --count=15 \"" ++ s ++ "\""
10:04:16 <Lokathor> kuribas, http://lpaste.net/356898 so if you can look at this and then make a cps version i will have a look, but i'm not quite following how it works out i think
10:04:17 <sproingie> add that to ~/.ghc/ghci.conf
10:04:20 <Cale> Eduard_Munteanu: pipes doesn't build that sort of protocol in. You can make the upstream thing produce a Maybe for you
10:04:30 <vktec> Oh! I just discovered the index. That's handy
10:04:42 <EvanR> i heard people complaining about that aspect of pipes
10:04:43 <sproingie> one thing i wish hackage had built-in was reverse dependencies
10:04:49 <Cale> I think it's nice
10:04:50 <dmwit> vktec: There's also Hoogle, if your package is indexed by Hoogle.
10:04:54 <srhb> vktec: I just follow the links usually
10:05:05 <EvanR> but it makes sense if you want to separate as much out as possible and adhere to abstract nonsense
10:05:06 <Eduard_Munteanu> Cale, I don't see how you could write a conduit/pipe that keeps generating data after upstream finished.
10:05:13 <vktec> dmwit: Oh, good point
10:05:13 <dmwit> vktec: And I think :i will tell you where a thing was defined.
10:05:29 <Cale> Eduard_Munteanu: just keep yielding stuff?
10:05:39 <Cale> Eduard_Munteanu: I'm not sure what you mean
10:05:53 <vktec> dmwit: Yep, that works. Thanks
10:05:53 <Lokathor> vktec, if you open the haddock of a project, along the right side there's a "source" link in very faint lettering
10:05:59 <Eduard_Munteanu> Cale, yeah, but you have to refrain from await-ing, else the whole thing ends abruptly, no?
10:06:00 <Lokathor> which will take you to the right file, normally
10:06:01 <dmwit> vktec: (However this may sometimes be in an internal module not exposed in the documentation. =( )
10:06:29 <dmwit> vktec: (Even if there is a module that exposes it and has documentation for it.)
10:06:42 <Cale> Eduard_Munteanu: If the upstream stops yielding, then your await will wait forever.
10:06:54 <vktec> dmwit: That's... frustrating
10:07:07 <vktec> Well, I'll probably start using Hoogle or the Hackage index page more
10:07:16 <ADG> well replicateM is `Int -> m a -> m [a]` what if I want `Int -> m [a] -> m [a]`? 
10:07:22 <sproingie> definitely install a local hoogle, it's damn helpful
10:07:37 <sproingie> and it's pretty much idiotproof to set up
10:07:46 <vktec> I'll look into that
10:07:51 <ski> @type (liftM concat .) . replicateM
10:07:53 <lambdabot> Monad m => Int -> m [a] -> m [a]
10:08:05 <dmwit> vktec: Usually one of these three tricks (:i, Hoogle, index) gets you where you need to go pretty quickly.
10:08:26 <vktec> Cool. Thanks for the help!
10:08:41 <kuribas> Lokathor: this is the idea: http://lpaste.net/356897
10:08:55 <Eduard_Munteanu> Cale, what if upstream just terminates?
10:09:01 <kuribas> Lokathor: it's definitely wrong, but you can fill it in...
10:10:15 <kuribas> Lokathor: note that you explicitly tell it to continue by calling the continuation.
10:10:52 <kuribas> Lokathor: unlike the continuation monad, which does it implicitly (as part of bind)
10:10:56 <cocreature> vktec: if you just want name search, the new hoogle at http://hoogle.haskell.org/ is a lot better and indexes significantly more packages
10:11:02 <Eduard_Munteanu> Cale, for example, you might want to write a conduit which pads zeros forever at the end, so if you hook it to a source which gives 1, 2 and 3, you get 1, 2, 3, 0, 0, 0....
10:11:58 <vktec> cocreature: Good to know
10:12:04 <sproingie> what really kills me is i start typing "hoo" in my browser, hit tab, and ... it expands to haskell.org/hoogle >:(
10:12:05 <Cale> Eduard_Munteanu: Right, well, with pipes, you can't tell from downstream that a Producer is done for sure unless it somehow tells you.
10:13:10 <sproingie> mostly i just google thingie +hackage now
10:13:11 <cocreature> sproingie: I’ve been using the new hoogle long enough that I’ve now successfully trained my browser to suggest the new one :)
10:13:13 <Cale> (or a pipe in general)
10:13:20 <kuribas> Lokathor_: and alternative way of "bailing out" is to use foldM with Either.
10:13:36 <Lokathor_> hmm
10:13:39 <kuribas> Lokathor_: Then you can use Left to signify early exit, and Right to continue.
10:13:40 <Lokathor_> interesting idea
10:13:54 <Lokathor_> :t foldM
10:13:56 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
10:14:00 <sproingie> unless i need type search, i just use google and not hoogle
10:14:40 <Cale> Eduard_Munteanu: Oh, actually, I'm incorrect. If the upstream actually terminates while a downstream consumer was awaiting, the whole thing just ends.
10:14:48 <cocreature> I find hoogle more convenient if I want to see all possibilities where something could come from
10:14:52 <Cale> (which is reasonable)
10:14:55 <f-a> if I have 2 process modifying an mvar, I shouldn't really be using an mvar but a tvar rather, right?
10:14:59 <kuribas> Lokathor: but that's probably better if you like a different type for error or a result.
10:15:09 <Tuplanolla> Firefox stores its history into a database file that you can manipulate with SQLite, sproingie.
10:15:26 <Tuplanolla> You can do that if you want to get rid of some bad suggestions.
10:15:33 <cocreature> f-a: there is nothing wrong with modifying an mvar from two threads
10:15:41 <cocreature> f-a: in fact that’s pretty much what it’s intended for
10:15:48 <sproingie> eh i can just search for it in history and delete.  it's clicking google search results that puts it back i think
10:16:05 <MarcelineVQ> sproingie: or sometimes a forgotten bookmark
10:16:12 <ski> (now, modifying two `MVar's from two threads, ..)
10:16:17 <Lokathor> i'm not seeing how Either and foldM work together
10:16:18 <sproingie> if it really bugs me i can find that redirect plugin
10:16:36 <sproingie> i already have an existing redirect for amazon.com -> smile.amazon.com
10:16:39 <cocreature> f-a: TVar starts to make more sense if you want to modify multiple tvars atomically
10:16:44 <Cale> Eduard_Munteanu: You can still write something like  pad v x = x >> forever (yield v)
10:16:46 <Lokathor> oh right
10:16:47 <f-a> cocreature: thanks
10:16:49 <kuribas> Lokathor: In any case your explicit recursion is perfectly fine.
10:16:49 <Lokathor> the left is part of m
10:17:01 <Lokathor> i always forget that the left is part of the m
10:18:18 <cocreature> f-a: they also have different performance characteristics but if you care about that you need to benchmark to figure out which one is faster for your particular usecase
10:18:48 <Cale> Eduard_Munteanu: and of course, if your upstream thing is producing Maybe results, you can use Nothing to determine when to start producing 0's.
10:18:49 <ski> > fmap reverse (foldM (\cs c -> if isUpper c then Left c else return (c:cs)) [] "hello")
10:18:52 <lambdabot>  Right "hello"
10:18:53 <ski> > fmap reverse (foldM (\cs c -> if isUpper c then Left c else return (c:cs)) [] "helLo")
10:18:55 <lambdabot>  Left 'L'
10:20:38 <ski> > foldr (\c mcs -> if isUpper c then Left c else liftM (c:) mcs) (Right []) "hello"
10:20:40 <lambdabot>  Right "hello"
10:20:41 <ski> > foldr (\c mcs -> if isUpper c then Left c else liftM (c:) mcs) (Right []) "helLo"
10:20:43 <lambdabot>  Left 'L'
10:20:57 <MarcelineVQ> c:
10:23:39 <f-a> oh, I thought one was almost always slower, cocreature 
10:23:51 <kuribas> > let find x = foldr (\y r -> if x == y then Just x else r) Nothing in find even [1, 3, 2, 4]
10:23:53 <lambdabot>  error:
10:23:54 <lambdabot>      • No instance for (Typeable a0)
10:23:54 <lambdabot>          arising from a use of ‘show_M903048494806360448216151’
10:24:34 <ADG> how would I write something like this void function: https://hastebin.com/janolatiqi.vbs
10:25:20 <kuribas> > let find x = foldr (\y r -> if x == y then Just x else r) Nothing in find 3 [1, 3, 2, 4]
10:25:22 <lambdabot>  Just 3
10:25:27 <kuribas> > let find x = foldr (\y r -> if x == y then Just x else r) Nothing in find 5 [1, 3, 2, 4]
10:25:29 <lambdabot>  Nothing
10:25:38 <cocreature> f-a: TVar will probably be slower when you have high contention but I’ve also seen it be faster in some cases. there is also a significant difference between the threaded and the nonthreaded runtime
10:26:39 <sproingie> ADG: i can't parse the weird syntax.  what is it you're trying to do?
10:26:59 <ADG> I have an Array Int Data.IntSet, basically I am topological sorting
10:27:20 <ADG> first I remove the root from its child's neighbours and then recurse for each child
10:27:42 <dedgrant> ADG: It depends what effect you need to achieve. In a not-so-great case, it might be some sort of (ArrayThing -> Int -> IO ArrayThing) to return the new array and permit side effects during execution.
10:28:25 <dedgrant> ADG: You might want to express the tree as a parameter, and return the updated tree in the result.
10:28:31 <sproingie> doing it as in-place mutation would be very un-idiomatic
10:29:10 <ADG> that is good .. I think I should foldl over node's children and change the parameter?
10:30:29 <Tuplanolla> :t asum -- Looking for this, mniip?
10:30:31 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:30:38 <mniip> too late
10:39:18 <dedgrant> ADG: foldr if you can? Strict foldl' recommended if not.
10:51:02 * hackagebot pgdl 10.9 – browse directory listing webpages and download files from them. – https://hackage.haskell.org/package/pgdl
12:07:04 <jonge> hey there. i am currently using Control.Monad.Parallel.map to do some tasks in parallel. Works great. Now i would like to implement a ctrl-c handler, that counts how often it is invoked. On the 3rd time, it shall send exceptions to all the threads in order to "kill" them immediately. with what library would i start those threads in order to also get their id etc.?
12:07:40 <Tuplanolla> You don't need any, although `async` is nice, jonge.
12:08:14 <jonge> Tuplanolla: by "you don't need any" you mean "just use forkIO, store the thread ids somewhere and send them async exceptions"?
12:08:27 <Tuplanolla> Yes to all.
12:08:34 <jonge> ok, Tuplanolla, thx.
12:10:46 <orzo> Hey, if I see a straight forward way to do the job i'm doing with TVar with an MVar, is that cheaper?
12:11:03 <orzo> Is MVar cheaper than TVar?
12:12:17 <Tuplanolla> It should depend on contention, orzo. Someone was recently building benchmarks to explore that question, but I don't remember who it was.
12:13:28 <orzo> i'm using it to association inbound responses with outbound queries.  There's a map that associations a transaction id with an mvar/tvar in which to store the reply when it is available
12:13:35 <orzo> which would you use?
12:14:10 <Tuplanolla> Channels, orzo?
12:14:47 <orzo> i've a pending query waiting on a reply
12:14:56 <orzo> how would you use a channel
12:15:29 <orzo> this is a udp protocol, so it's not a disaster if i drop packets
12:15:40 <Tuplanolla> I don't know what you're doing exactly, but have a look inside `Control.Concurrent.Chan`.
12:16:06 <jonge> orzo on the TVAR vs. MVar thing i would guess that it really depends on the probability of concurrent access.
12:16:11 <jared-w> accidentally wrote a book on a r/haskell post. Oh well ¯\_(ツ)_/¯
12:16:12 <cocreature> if you care about the performance difference benchmark your code
12:17:05 <dogbitsman> Is there something like pyautogui for Haskell we need something that will allow us to attach a file to an email client for testing purposes
12:17:37 <orzo> i currently have a single writer that handles one packet at a time sequentially and a plethora of consumer threads that are waiting on mvar/tvars
12:18:07 <orzo> concurrent access to one of those vars seems unlikely
12:18:25 <jared-w> Hmm... is $ magic in haskell? I thought it was just a normal function but apparently it has some special magic when runST is involved?
12:18:43 <Tuplanolla> Sure is magic, jared-w.
12:19:18 <jared-w> I've seen quite a few things on the internet that were very clear that $ was "just a function." Ah well. How does the magic work?
12:19:21 <orzo> it's got magic to make point reduced and non point reduced have similar type inference properties
12:19:34 <cocreature> jared-w: it’s only typechecker magic
12:19:39 <geekosaur> it's a normal function. there's a typechecker hack which detects its specific type in a specific impredicative-type situation
12:19:50 <cocreature> jared-w: normally you can’t unify a type variable with a rank-n-type
12:20:05 <cocreature> that’s called impredicative polymorphism and while we have an extension for that it’s utterly broken
12:20:12 <cocreature> but for runST that would be really annoying
12:20:15 <cocreature> so there is a special hack
12:20:26 <cocreature> so you can write runST $ …
12:20:57 <jared-w> oooh gotcha
12:21:05 <cocreature> :t ($)
12:21:07 <lambdabot> (a -> b) -> a -> b
12:21:08 <cocreature> :t runST
12:21:09 <lambdabot> (forall s. ST s a) -> a
12:21:10 <Tuplanolla> If only you could also write `runST . create $ ...`.
12:21:27 <cocreature> "forall s. ST s a" is unified with a here
12:21:57 <orzo> jonge: low propability of concurrent access recommends MVar?
12:22:10 <cocreature> I still don’t quite know why impredicative polymorphism is so hard to implement
12:22:22 <jared-w> orzo: benchmarks are the absolute answer, honestly :p
12:22:36 <orzo> i just need a rule of thumb for dont-care situations
12:22:52 <jared-w> If you don't care, use whichever you like better
12:22:52 <jonge> orzo more in the sense that if you have a lot of readers, but seldom writes, then readers will not block each other. and when a rare write occurs, some readers will have to retry.
12:23:20 <orzo> there hsould be one reader and one writer for every var
12:23:45 <jared-w> cocreature: neat, thanks for the info. Time to waste a few hours of my life googling impredicative polymorphism
12:24:30 <jonge> orzo: ok then i would naively guess that mvar would be faster, but i would never be sure without measuring. do you have any possibility to simulate large inflow and measure the resulting throughput with both implementations?
12:25:21 <bbear> hello
12:26:10 <bbear> what are you up to ?
12:26:35 <jonge> bbear: coding nice haskell code. what else? 
12:27:02 <bbear> what about a little chat ?
12:27:31 <jonge> sure, lol
12:27:33 <bbear> (haskell related of course
12:27:38 <jonge> :-D
12:27:56 <dolio> cocreature: It's similar to the reason that adding lambda expressions makes things very difficult.
12:28:35 <bbear> I wanted to know things.
12:29:07 <jonge> bbear: what is it
12:29:21 <bbear> I am learning a little bit of category theory.
12:29:39 <dolio> You want to put your types into a canonical format for checking if they're the same, or if one subsumes the other, so that when you want to check (forall <x>. ...) = (forall <y>. ...), you can just check if <x> and <y> have the same length, or something along those lines.
12:29:44 <jonge> oh i am not sure i am the right person for that. but the channel should be full of experts.
12:30:43 <dolio> But, for instance, if you go to check: (forall a. a -> a) < (forall b. (forall b. b) -> b)
12:31:14 <dolio> The answer is yes, but you won't get there by first deciding to make 'a' on the left the same as 'b' on the right.
12:31:54 <dolio> And it's actually _because_ you've put the right hand side in a canonicalized form (pull all variables out as much as possible).
12:32:04 <bbear> CT conceptsare the same as Haskell Concept more or less, right ?
12:32:41 <Tuplanolla> Less, bbear.
12:33:19 <bbear> To me it seems quite ressemblant even if it's not obvious at first sight.
12:34:55 <bbear> I mean the concept of functor (i'm just reading about it) is quite ressemblant from a Haskell functor
12:35:25 <Tuplanolla> We have appropriated a few concepts for our purposes, but as a whole the theory is quite different.
12:35:44 <jared-w> Haskell doesn't have a lot of stuff that CT does. Haskell resembles CT in some of its features, libraries, etc., but you can't draw too many strong parallels otherwise :p
12:36:07 <bbear> Yes. But that was my point. 
12:36:32 <Tuplanolla> Our `class Functor` refers to a limited bunch of endofunctors for example.
12:36:46 <bbear> How does it come so useful to draw concepts from CT and apply them to a programming language ?
12:37:12 <cocreature> dolio: oh that seems to make sense, thanks a lot for the explanation!
12:37:25 <Tuplanolla> That's rather philosophical. What kind of answer are you looking for, bbear?
12:37:28 <bbear> Tuplanolla: it would be rather difficult to enforce a whole mathematical theory in a programming language. So far. But Haskell has gone far.
12:38:17 <bbear> Tuplanolla: I was simply wandering.
12:38:59 <dogbitsman> Are there any multiplatform mouse control libraries in Haskell
12:40:10 <karljs> Could someone give me a usage example of `fold` in bifunctor based datatype generic programming?  That is, suppose I have a list of ints defined `l` and want to sum it using fold, what can I pass to the fold function with type `(s a b -> b)`?
12:40:19 <jared-w> Category Theory can be thought of (somewhat) as the theory that studies the similarities between relationships and how things work together. Programming is very interested in making small parts which work together, so using the tools of CT gives you some very theoretically sound reasons for doing things a certain way. Normally, most programming languages have features because it "sounds like a good idea" but
12:40:22 <jared-w> with CT concepts there's more theoretical backing that the idea is a good one
12:41:16 <jared-w> To me, it's much like the difference between saying "I think steel is a good metal to build a shovel with" and a chemist saying "steel would be a good metal to build a shovel with because of the properties steel's molecular structure has"
12:45:05 <lyxia> karljs: do you have a reference on bifunctor based datatype generic programming
12:46:09 <lyxia> https://kseo.github.io/posts/2016-12-16-datatype-generic-programming-with-bifunctors.html this thing?
12:46:43 <karljs> lyxia: Yes, essentially, although I'm looking at Gibbons' summary paper 'Datatype-Generic Programming' which that is based on
12:47:05 <karljs> there's a usage of map there that is straightforward, but not one for fold
12:47:12 <benzrf> as someone who knows a lot of haskell and a lot of category theory (well, a lot for a haskeller), im not actually convinced that CT in and of itself is actually useful to haskell directly
12:47:21 <lyxia> karljs: with the notation there, fold (\x -> case x of Nil -> 0 ; Cons n m -> n + m)
12:47:26 <benzrf> there are a lot of good abstractions that have their origin in CT, but its really not clear to me *why* it works
12:47:32 <benzrf> it's kind of like the unreasonable effectiveness of math
12:48:47 <karljs> lyxia thanks, that's exactly what I needed
12:49:13 * alanz just looked at the source for Control.Zipper. My head nearly exploded
12:49:29 <benzrf> i think this isn't a very useful description "<jared-w> Category Theory can be thought of (somewhat) as the theory that studies the similarities between relationships and how things work together."
12:50:09 <jared-w> Yeah, it's not really a good description. It's just that CT is so vague and abstract that I struggle to put a concrete description to it
12:51:43 <dolio> It's abstract algebra, but better.
12:51:46 <benzrf> trying to explain category theory to someone who doesn't know a lot of math is like trying to explain functors to somebody who doesn't know any types that instantiate them
12:51:56 <benzrf> haskell functors, i mean
12:52:24 <cocreature> generalized abstract nonsense
12:52:25 <benzrf> dolio: no, it's homotopy theory, but better
12:52:26 <benzrf> ;-)
12:54:03 <jared-w> homotopy theory, it's so hott right now
12:54:58 <dolio> I don't see why it's surprising that it'd work well for Haskell, either.
12:55:42 <dolio> It's the discipline where people work on stuff that allows them to realize that dozens of seemingly unrelated areas of mathematics are kind of the same.
12:55:53 <benzrf> hmmmm,... actually when u put it like that i see what u mean
12:56:16 <dolio> And there are a few common ideas that everyone keeps reinventing in various ways.
12:56:30 <johnw> dolio: I like the description that understanding mathematical objects means understanding how they can be mapped to other objects.
12:56:31 <dolio> So it's not surprising that people also reinvented them in Haskell/programming/type theory.
12:56:39 <jared-w> https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf the opening paragraph here is amazing
12:56:45 <lyxia> is there a universal property of CT that explains why it works so well
12:56:58 <johnw> lyxia: was that an unintended pun?
12:57:03 <lyxia> yes
12:57:07 <johnw> universal properties are exactly why it works so well :)
12:57:31 <mnoonan> I think it isn't so wrong to call category theory "Function Theory"
12:57:42 <jared-w> lyxia: sure. CT is generalized abstract nonsense. The more general and abstract the nonsense, the more gibberish you can stick in haskell and have it work correctly ;)
12:57:43 <johnw> Awodey calls it the algebra of functions
12:57:58 <jonge> Tuplanolla: i ended up using async because there i can do a simple `forM_ threadIds wait` in the main thread to not exit the app prematurely. Is there a nice way to wait for `forkIO`d threads, too?
12:58:15 <johnw> what blew my mind the other day was learning that you don't need categories to define category theory, in the same way that you don't need objects to define a category.
12:58:39 <jared-w> johnw: where'd you read that? Sounds like a good read
12:59:13 <benzrf> mnoonan: yes it is
12:59:20 <benzrf> mnoonan: functions are only one kind of morphism
12:59:20 <lyxia> mnoonan: a lot of the power of CT comes from categories where morphisms are not functions
12:59:41 <johnw> jared-w: looking
13:00:03 <johnw> jared-w: https://arxiv.org/abs/1602.01759
13:00:11 <jared-w> sweet
13:00:23 <mnoonan> benzrf: no, that's exactly my point. the structure of a category *abstracts* the notion of functions and composition.
13:01:01 <mnoonan> just like how group theory generalizes the notion of sets of symmetries, or ring theory generalizes Z.
13:01:27 <benzrf> yes, and group theory is not symmetry theory, neither is ring theory number theory
13:01:42 <jared-w> johnw: you know a paper's gonna be good when the abstract itself blows your brains out
13:02:52 <johnw> it was a good read
13:02:59 <johnw> I wanted a punchier conclusion, but hey
13:05:58 <benzrf> well
13:06:08 <benzrf> does it hinge on the yoneda embedding
13:06:22 <benzrf> (i havent taken a look at it)
13:06:40 <johnw> benzrf: the paper I linked to?
13:07:00 <dolio> You're familiar of defining categories without objects, right?
13:07:19 <johnw> I am
13:07:25 <johnw> but I imagine you're asking benzrf
13:07:43 <benzrf> i've seen the single-sorted presentation of etcs, which i assume is what you're thinking of
13:08:08 <johnw> Mac Lane defines arrows-only categories quite succinctly
13:08:19 <benzrf> although it sounds like it hinges on being able to compare arbitrary morphisms regardless of type
13:08:22 <benzrf> which seems a bit barbaric
13:08:45 <johnw> ?
13:08:48 <johnw> why would it sound like that?
13:09:05 <benzrf> well, the thing i saw did
13:09:18 <benzrf> is it the thing where u use id as a proxy for objects?
13:09:32 <johnw> basically
13:09:44 <dolio> I don't think it's ETCS. But it's that you have a collection of arrows and a partial binary operation on them, and two unary operations.
13:10:03 <johnw> here's an arrows only metacategory: https://github.com/jwiegley/category-theory/blob/master/Theory/Metacategory/ArrowsOnly.v#L20
13:10:06 <benzrf> then the well-typedness of composition requires equality of the identity morphisms, which is eeeevil
13:10:10 <johnw> this is sufficient information to define a category
13:10:30 <dolio> Equality of morphisms isn't evil, though. Equality of objects is.
13:10:37 <johnw> the only data you really need to give is a correct mapping of composable pairs to arrows
13:11:04 <dolio> Anyhow, I don't like it.
13:11:11 <benzrf> dolio: but equality of morphisms is only non-evil when you know that they have the same type
13:11:25 <benzrf> which ends up being circular if you don't have types separate from the morphisms
13:12:08 <dolio> But you can do it.
13:12:14 <benzrf> :[
13:12:14 <dolio> If you want.
13:12:22 <dolio> Which I don't.
13:13:11 <dolio> Having an indexed operation seems much nicer than a partial operation that is required to work for certain things.
13:14:05 <dolio> Sometimes things work out a little nicer when you think of things in the way I don't like, though.
13:14:43 <dolio> Like thinking of families of types/sets in terms of display maps instead of functions from the index set.
13:22:34 <vktec> My program is outputting <<loop>> and then exiting. Why is it doing this and how can I stop it?
13:23:20 <dolio> You wrote a viciously circular loop.
13:23:29 <dolio> You need to find it and fix it.
13:23:51 <vktec> I guessed that was it, but I'm not sure why it's not liking it
13:24:03 <jared-w> Well, what code did you write?
13:24:11 <johnw> often it's let x = ... x ...
13:25:21 <vktec> This is the offending function: https://ptpb.pw/0SZm/haskell
13:26:32 <lyxia> there's nothing recursive here
13:26:50 <lyxia> oh mainLoop win is, but it looks pretty productive
13:27:01 <vktec> Exactly
13:27:09 <glguy> So then that's probably not he problem
13:27:26 <johnw> yes, how do you know this is the "offending function"?
13:27:31 <vktec> True
13:27:44 <johnw> likely it's just the place where 'win' is being forced
13:35:42 <vktec> Hmm... this is very puzzling
13:36:16 <jared-w> Do you have a larger context of code?
13:37:32 <vktec> Sure
13:37:34 <vktec> 1 sec
13:38:31 <vktec> https://ptpb.pw/-EJ8/haskell
13:39:29 <glguy> "let w = w :: GLsizei"
13:39:47 <vktec> Oh
13:39:48 <vktec> Oops
13:39:55 <dolio> :)
13:39:56 <glguy> :: doesn't cast things
13:41:03 <vktec> Hmm.. yeah I was just trying stuff out and that seemed to work (no compilation errors)
13:41:25 <vktec> How should I write that?
13:42:18 <jared-w> Do you have a way to make GLsizei from ints? (a constructor, that is)
13:42:24 <glguy> let wi = fromIntegral w
13:43:21 <jared-w> Also, why does the type of resize have `Int` in it anyway?
13:43:33 <vktec> glguy: Perfect! Thanks
13:44:54 <vktec> jared-w: Because setFramebufferSizeCallback needs a `Window -> Int -> Int -> IO ()`
13:49:30 <jared-w> That's unfortunate; makes sense I guess.
13:51:15 <vktec> It's slightly odd that GL and GLFW-b don't use the same type for it, but oh well
13:55:14 <saylu> I have an application with the backend and frontend in different directories, like this:    app/backend   app/frontend     Is there a way to serve static folders from the app/frontend directory with Servant, even though the backend application is running within app/backend? I get a 404 error trying something like `"../../frontend/static"` but I can easily serve the right page if I copy the static folder into my
13:55:14 <saylu> backend.
13:55:53 <f-a> I have a forkIO'd thread where I putStrLn to debug stuff. This is displayed when I use cabal repl but not when I compile the actual program. Why is that?
13:56:02 <saylu> In other words -- is it possible for Servant to reach into a directory above the one that the server runs in? Or, once the server is running in /backend/, is it impossible to navigate upwardL
13:58:14 <geekosaur> f-a, I think you will have to show a complete failing example program
13:59:05 <f-a> ok
13:59:39 <f-a> let me just weed out useless stuff
14:01:22 <XorSwap> is there an extension I can enable that would let me pattern match with different numbers of arguments
14:01:38 <geekosaur> no
14:01:42 <XorSwap> ok
14:04:03 <jared-w> XorSwap: why would you want that?
14:04:44 <geekosaur> f-a, for what it's worth I did a simple test locally and it worked. but I/O to the same Handle (stdout in this case) + concurrency can be tricky
14:04:53 <XorSwap> because I have a function with about 20 pattern matches, and I'm just as lazy as the runtime
14:05:10 <f-a> geekosaur: what are the caveats?
14:05:22 <geekosaur> mostly to do with interleaved output
14:05:57 <geekosaur> "you have a problem and you decide to use threads. nonw owy ou  yoauv e hatwvo e ptrowbo plerombsle imns teinrtleearlveeda.ed."
14:07:51 <geekosaur> (that is, you think some output is missing but it's just mixed into another line from a different thread)
14:14:21 <sm> programs run with ghci aren't -threaded, right ?
14:14:39 <f-a> geekosaur: do you mind if I send you a cabal folder, just to test you are experiencing the same (different) behaviour between cabal new-repl and cabal new-build?
14:14:50 <f-a> hello sm
14:14:58 <geekosaur> you might put it on gist
14:15:05 <geekosaur> sm, ghci forces -threaded
14:15:26 <geekosaur> this occasionally confuses people because threads continue to run after you get the prompt back
14:15:58 <EvanR> and theres no list of threads!
14:16:10 <f-a> geekosaur: the fact is that if I use ghc -Wall -odir comp -hidir comp to compile it doesn't show the weird behaviour
14:16:19 <f-a> while cabal new-build (or cabal build) do
14:16:57 <geekosaur> f-a, could you have C and Haskell source files with the same name? (or be using inline-c which can do that itself behind your back)
14:17:25 <f-a> geekosaur: I really don't think so
14:17:35 <geekosaur> this sometimes leads to object files getting overwritten, especially in the inline-c case because cabal doesn't know TH is compiling stuff also behind its back
14:18:08 <geekosaur> but if you think it's a cabal issue, put it in a gist and ask in #hackage
14:19:38 <f-a> how can I put a cabal folder in a gist? (I mean, I could put Main.hs but I am unsure then it would be reproducible)
14:19:39 <mniip> sm, no
14:19:49 <mniip> programs run with ghci are hardly compiler
14:19:51 <mniip> programs run with ghci are hardly compiled
14:20:56 <geekosaur> f-a, at least if you have a github account, a gist is just a git repo
14:21:11 <f-a> I see, thanks
14:21:12 <geekosaur> you can push to it, etc. like any other github repo
14:21:43 <geekosaur> especially nice because we can just clone it and potentially fork it with suggested changes
14:26:18 <f-a> geekosaur: if you are interested, it's the -O flag which messes things up
14:26:36 <geekosaur> I saw (I'm in #hackage too although I can't often help much)
14:29:42 <geekosaur> so that would imply something is being optimized out. although you could also try with -fno-omit-yields
14:35:06 <dmwit> So, this is fun. With arithmoi's Math.NumberTheory.Powers.General, `integerRoot 786 ((10^32)^786)` returns instantly, but `integerRoot 787 ((10^32)^787)` takes forever.
14:35:09 <dmwit> I wonder why?
14:36:15 <dmwit> Come to think of it, maybe SO would be a better forum for this question.
14:36:42 <jared-w> Hmm... My first hunch is that 786 is just under the limit of something
14:39:31 <joeyh> is there a way to use GADTs or something to make: data Cabal | Stack | Foo (Stack | Cabal) ? I could use two seprate data types for this, but would rather not
14:40:12 <dmwit> What do you want `Foo (Stack | Cabal)` to mean?
14:40:14 <joeyh> er, there's supposed to be a type name there
14:40:21 <EvanR> whats the type name
14:40:56 <EvanR> is Foo (Foo (Foo... also valid
14:40:59 <joeyh> I mean, data T = Cabal | Stack | Foo T, but I don't want Foo (Foo (Foo Cabal)) to be allowed
14:41:22 <EvanR> gotta use proper types then
14:41:39 <EvanR> data Team = Cabal | Stack
14:41:41 <joeyh> thought I'd seen GADTs used for similar situations
14:41:45 <EvanR> data T = Normal Team | Foo Team
14:42:09 <joeyh> sure, could do that, but it complicates the api. I suppose I could just use smart consctructors to export the API I want
14:42:21 <EvanR> definitely give priority to the API
14:42:36 <EvanR> though what you originally said sounds like its making the API make no sense
14:42:48 <joeyh> it also complicates code to need to handle cases that can never actually happen
14:43:11 <EvanR> with Team and T separate, they actually cant ever happen
14:43:20 <EvanR> unlike Foo (Foo (Foo Cabal))
14:43:30 <joeyh> true
14:43:48 <EvanR> wrong types ends up causing "code to handle stuff that cant happen"
14:44:56 <lambdamu> joeyh: I think you can do it with GADTs, not sure if that would be sane, but you can have a type level boolean as phantom type then have: Cabal :: T True / Stack :: T True / Foo :: T True -> T False
14:45:21 <lambdamu> joeyh: That allows for just one level of nesting
14:45:28 <joeyh> oh hmm
14:45:33 <joeyh> sure, I'll go there :)
14:46:31 <f-a> geekosaur: here's the minimal example https://hastebin.com/ugevimobiy.vbs
14:46:37 <lambdamu> joeyh: Doesn't have to be a boolean, though, something more descriptive would be nicer
14:46:38 <EvanR> isnt the presence of Foo basically a boolean?
14:46:48 <EvanR> (Bool, Team)
14:47:21 <EvanR> if we knew what Foo was... might help suggestions
14:48:09 <joeyh> there are actually a couple of constructors like Foo
14:48:11 <geekosaur> f-a, did you see my suggestion about -fno-omit-yields?
14:48:18 <joeyh> all mutually incompatible
14:48:30 <geekosaur> the problem with that code is that it doesn't give your thread the chance to run, because it doesn't allocate anything
14:48:45 <EvanR> so (Maybe ExclusiveFlagType, StackOrCabal)
14:48:57 <EvanR> or
14:49:09 <EvanR> ExclusiveFlagOrNoFlagType StackOrCabal
14:49:21 <geekosaur> (without optimization it probably does some ephemeral allocations into the nursery)
14:49:35 <EvanR> where the first thing is a functor
14:55:09 <geekosaur> f-a, and indeed -O -fno-omit-yields works here
14:55:20 <f-a> geekosaur: thanks for the explanation. That's a bit disheartening thou- yeah I was trying it now
14:56:17 <f-a> my loop cycle does something more then return (), is there a simple way to check whether I am trapping myself in this scenario?
14:56:35 <f-a> should I just slap -fno-omit-yields in .cabal and forget about it?
14:56:59 <geekosaur> you might be able to inspect the generated Core to see if it does things that allocate. I suspect if -fno-omit-yields makes it work then just do that though
14:57:29 <geekosaur> you can look up that option in the ghc manual for more information, and beyond that you're probably looking at #ghc and the ghc Commentary in trac
14:59:14 <f-a> I'll gladly live with -fno-omit-yields geekosaur , thanks for diagnosing
15:03:43 <unclechu> hey guys, about hackage, how to upload documentation for package candidate?
15:11:52 <glguy> unclechu: as far as I know it's the same process that you use to upload documentation for released packages
15:13:41 <unclechu> glguy: `cabal upload -u unclechu -d dist/*-docs.tar.gz` gets me `package not found` 404 error
15:13:52 <unclechu> but i've uploaded it on webform to candidates list
15:14:33 <unclechu> and i've generated documentation by this command `cabal haddock --for-hackage --hyperlink-source`
15:15:49 <glguy> OK, then I don't know. Incidentally --haddock-option=--hyperlinked-source does a better job at hyperlinked source
15:16:06 <glguy> or I didn't know about your flag
15:16:35 <unclechu> glguy: then i gets `cabal: '/usr/bin/haddock' exited with an error:` error and nothing after colon
15:16:36 <glguy> Right, the one you're using uses HsColour
15:16:42 <unclechu> that's why i don't use this flag this way
15:16:44 <glguy> What version of GHC?
15:16:57 <unclechu> 7.10.3
15:17:05 <glguy> ah, once you update it'll work
15:18:16 <unclechu> so, is there no way to do it with this version?
15:27:44 <glguy> unclechu: I don't know, GHC 8 came out about a year ago, so I haven't had to mess with it
15:29:17 <jared-w> hah, finally had to use my logic truth tables in the real world
15:49:30 * hackagebot filter-logger 0.3.0.0 – Filterable request logging wai middleware. Change how data is logged and when. – https://hackage.haskell.org/package/filter-logger
15:51:54 <bbear> how do you take a list and put the first and second elements into a tuple ?
15:51:59 <bbear> is there a function to do that ?
15:52:08 <bbear> I want to build tuples with `words`
15:52:14 <bbear> :t `words`
15:52:15 <lambdabot> error: parse error on input ‘`’
15:52:15 <glguy> you can use pattern matching
15:52:26 <bbear> :t words
15:52:28 <lambdabot> String -> [String]
15:54:33 <bbear> wordToTuple :: [t] -> (t, t)
15:54:39 <bbear> why is there a t ?
15:54:56 <glguy> what wouldn't there be one?
15:55:01 <glguy> why*
15:55:26 <bbear> it's 'a' usually
15:55:35 <glguy> a, b, t, it's all the same
15:55:36 <jared-w> The letter doesn't matter at all
15:55:42 <bbear> I did wordToTuple (x:[]) = ()
15:56:04 <jared-w> wordToTuple :: [whatAweirdTypeName] -> (whatAweirdTypeName, whatAweirdTypeName)  is also equivalent
15:56:06 <glguy> GHC picks t, t1, t2, etc  
15:56:37 <jared-w> sometimes it picks a1, a2, b1, b2, etc., as well. Just depends ¯\_(ツ)_/¯
15:57:28 <bbear> > readNlines N = (mapM (\_ -> getLine) [1..N])
15:57:31 <lambdabot>  <hint>:1:14: error:
15:57:31 <lambdabot>      parse error on input ‘=’
15:57:31 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
15:57:43 <bbear> what do you think of my function readNlines ?
15:57:55 <bbear> :t (mapM (\_ -> getLine) [1..])
15:57:57 <lambdabot> IO [String]
15:58:16 <glguy> you can use replicateM instead, or forever
15:58:25 <glguy> depending on which of those two things you're doing
15:58:38 <glguy> N is a constructor, n is a variable. You'll want to use n in your example above
15:59:05 <johnw> is anything like this possible: type Z3AST :: * -> * = AST
15:59:08 <bbear> ok
15:59:12 <johnw> I want a type synonym that eats a phantom type
15:59:55 <lambdamu> johnw: You can make it a type family
16:00:12 <glguy> johnw: I don't understand the example of what you're trying to do
16:00:31 <lambdamu> type family Z3AST t where Z3AST x = AST
16:00:57 <glguy> lambdamu: For that you'd just write:  type Z3AST t = AST
16:01:08 <glguy> You don't need to introduce a type family
16:01:20 <lambdamu> glguy: Huh yeah that's true, it's late :D
16:01:21 <johnw> but then I can't use it without teh 't'
16:02:01 <glguy> johnw: No, you can't do that, then
16:04:23 <bbear> how can I split a filename from the right in two parts :
16:04:35 <bbear> any.ext = ('any','ext')
16:04:42 <bbear> anyext = ('anyext',)
16:04:47 <bbear> anyext = ('anyext','') (sorry)
16:04:56 <bbear> anyext. = ('anyext','')
16:05:05 <glguy> bbear: see http://hackage.haskell.org/package/filepath-1.4.1.2/docs/System-FilePath-Posix.html
16:05:10 <bbear> .anyext=('','anyext')
16:07:52 <Darwin226> Can anyone tell me what this function is in core? ghc-prim-0.5.0.0:GHC.Classes.$p1(%,%)
16:08:32 <Darwin226> it seems to take two type arguments and one class dictionary
16:08:38 <Darwin226> afaict
16:09:02 <trigone> hi, best tutorial on lens? thanks
16:09:30 <c_wraith> Darwin226, that module isn't even documented on hackage, of course. 
16:10:07 <Darwin226> Yeah, but looking at the source of it, I don't even know which identifier to look for
16:10:14 <Darwin226> what does % even mean
16:13:09 <c_wraith> I think that's actually the crazy class definitions at the end of the file which don't really make any sense standalone. 
16:13:56 <c_wraith> I think it's likely to be the constraint tuples stuff. which seems like it should be an internal detail.. 
16:15:06 <c_wraith> trigone, what sort of level are you looking for? 
16:16:52 <trigone> c_wraith: i know nothing of it, but i want to learn of it
16:19:36 <c_wraith> trigone, if you don't mind video, I think https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation is the best beginner intro to what's going on. SPJ explains things so beautifully. though that site does want you to create an account to watch it. 
16:19:51 <c_wraith> at least it's a free account. 
16:19:57 <jared-w> Darn, any non video versions of things?
16:20:04 <c_wraith> if you want text instead... hmm, not sure. 
16:20:35 <trigone> c_wraith: thanks for the link imma see that
16:21:30 <bbear> how can you juggle with Monads ?
16:21:50 <bbear> Say I am in a IO () action, I use a function that returns a Maybe monad.
16:21:54 <c_wraith> http://r6.ca/blog/20120623T104901Z.html was an interesting post that sort of got things started. it may be of use, or totally useless. depends on your background. 
16:22:58 <c_wraith> bbear, I'm not completely sure what you are asking. 
16:23:31 <bbear> you see, in do notation, the <- means to take something from a Monadic context
16:23:44 <c_wraith> bbear, monads are never values. being monad ice is a property of some types, never values. 
16:23:51 <c_wraith> *monadic 
16:24:07 <trigone> bbear: you can have a value of type IO(Maybe a)
16:25:23 <gamegoblin> What are some common use cases for the Control.Monad `join` function? 
16:25:44 <trigone> c_wraith: actually it's typical to hear of monadic values when their types are constructed with a monad.
16:25:44 <dacto> I'm trying to use mapM_ in a monad stack rooted in IO and want to provide it with a function that returns the same type of stack instead of just `IO a`
16:25:48 <bbear> here is what i'm trying to do : :t (do x<-getLine;y<-(lookup 1 [(1,2)]); return())
16:25:54 <bbear> :t (do x<-getLine;y<-(lookup 1 [(1,2)]); return())
16:25:56 <lambdabot> error:
16:25:56 <lambdabot>     • Couldn't match type ‘Maybe’ with ‘IO’
16:25:56 <lambdabot>       Expected type: IO Integer
16:25:57 <jared-w> bbear: the way you are phrasing things sounds like you're more familiar with a programming language like php; am I wrong?
16:25:57 <dacto> Data.HashTable.IO (mapM_)
16:26:11 <bbear> i'm not a php man
16:26:11 <c_wraith> gamegoblin, when the type describes what you want to happen. it's a boring answer, I know. :) 
16:26:17 <bbear> sounds like an insult
16:26:44 <gamegoblin> c_wraith: just wanted an example of a way someone has actually used it
16:26:55 <trigone> bbear: your code snippet does nothing at all
16:27:03 <c_wraith> gamegoblin, but like.. for [], it's the same as concat
16:27:04 <gamegoblin> c_wraith: I found myself using it and something felt funny about it I guess
16:27:04 <bbear> yes I know
16:27:17 <trigone> gamegoblin: well say i have Maybe(Maybe Int)) and i want Maybe Int. i use join.
16:27:30 <jared-w> No, it's not intended to ben an insult at all; I have a friend of mine who describes things similarly to you and he does mostly php and javascript work so I was just curious if there was a simliarity there
16:27:31 <bbear> how do I deal with that Maybe value ?
16:27:40 <trigone> :t lookup
16:27:40 <c_wraith> gamegoblin, I mean.. if it type checks, it's probably right :) 
16:27:41 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
16:27:57 <trigone> bbear: well you can pattern match on "y" using case of
16:28:04 <gamegoblin> trigone: I guess the thing that weirded me out is I feel like maybe I shouldn’t be getting Maybe (Maybe Int)) in the first place, like I should be structuring the code better to avoid that somehow?
16:28:20 <gamegoblin> Not sure if that feeling is justified at all
16:28:44 <trigone> gamegoblin: given that (join, pure, fmap) is another way to represent the monad class, i doubt that to need the use of join is a code smell
16:28:49 <c_wraith> gamegoblin, you can often use >>= somewhere to avoid it. 
16:29:42 <c_wraith> gamegoblin, but that's kind of a cheat, since join + fmap can do everything >>= can
16:30:55 <c_wraith> @src join
16:30:55 <lambdabot> join x = x >>= id
16:30:55 <bbear> getFromMaybe x = case x of Nothing -> 'NotFound'; Just x -> x
16:31:34 <c_wraith> bbear, you need " instead of ' quotes for that. 
16:31:56 <trigone> c_wraith: i started reading the blogpost on lens. is it true that in haskell you can update a record and "change" of type in the process??
16:32:18 <c_wraith> trigone, yes, definitely. 
16:32:35 <bbear> c_wraith: ?
16:32:59 <bbear> never heard of that.
16:33:08 <trigone> c_wraith: intuitively it seems weird. i think it's because the implicit updating function should feel like having an output type like its input, but in the end there's no prerequisite i guess
16:33:09 <Gurkenglas> bbear, "getFromMaybe x = case x of Nothing -> "NotFound"; Just x -> x"
16:33:16 <c_wraith> bbear, ' quotes are used for single characters. you need " quotes for strings. 
16:33:20 <bbear> ha ok
16:33:46 <trigone> bbear: there's also the function maybe
16:33:50 <trigone> :t maybe
16:33:51 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:33:54 <Gurkenglas> :t fromMaybe
16:33:56 <lambdabot> a -> Maybe a -> a
16:33:59 <bbear> that's cool
16:34:17 <bbear> thanks a lot
16:34:22 <trigone> Gurkenglas: fromMaybe's first parameter is a default value?
16:34:49 <trigone> > fromMaybe 3 Nothing
16:34:51 <lambdabot>  3
16:34:52 <pacak> :t fromJust
16:34:53 <lambdabot> Maybe a -> a
16:35:03 <Gurkenglas> trigone, there's only one sensible implementation of "a -> Maybe a -> a".
16:35:13 <trigone> pacak: is fromJust a partial function?
16:35:23 <pacak> trigone: Yes.
16:35:27 <pacak> There's also safeFromJust
16:35:28 <trigone> Gurkenglas: and if you said yes that woulda been just as useful
16:35:40 <trigone> :t safeFromJust
16:35:41 <lambdabot> error: Variable not in scope: safeFromJust
16:35:44 <bbear> jared-w: sorry yes indeed i have imperative background but I do mostly python
16:35:51 <trigone> pacak: the safe module is so verbose
16:35:54 <pacak> https://hackage.haskell.org/package/acme-safe-0.1.0.0/docs/Acme-Safe.html
16:35:57 <bbear> :t fromJust
16:35:59 <lambdabot> Maybe a -> a
16:36:10 <pacak> safeFromJust ::  Maybe a -> Maybe a 
16:36:14 <trigone> bbear: fromJust will raise an error if its parameter is Nothing
16:36:30 <bbear> I don't want that. I always heard ppl saying that fromJust is not cool.
16:36:50 <trigone> pacak: lol safeFromJust would be identity with this signature, would it not?
16:36:59 <Gurkenglas> trigone, nah my answer has more uses than "yes"
16:37:00 <pacak> bbear: Yea, it's better to avoid partial functions if you can.
16:37:00 <c_wraith> > fromJust Nothing
16:37:02 <lambdabot>  *Exception: Maybe.fromJust: Nothing
16:37:09 <trigone> > safeFromJust Nothing
16:37:11 <lambdabot>  error:
16:37:11 <lambdabot>      Variable not in scope: safeFromJust :: Maybe a0 -> t
16:37:30 <trigone> > safeFromJust 7 Nothing
16:37:32 <lambdabot>  error:
16:37:32 <lambdabot>      Variable not in scope: safeFromJust :: Integer -> Maybe a0 -> t
16:37:55 <c_wraith> bbear, fromJust is definitely not what you want. but fromMaybe looks like it does the job. 
16:38:16 <pacak> trigone: stuff from acme packages is rarely useful.
16:38:18 <trigone> Gurkenglas: well since i asked for confirmation of my deduction, to push me back to re-deduce is a bit absurd
16:39:20 <trigone> pacak: unless you repack them in some personal prelude... most of the time if you use head you'll have to manually check for the length and so on, aka inlining safeHead or whatever it's called
16:39:43 <bbear> what is an empty tuple ?
16:39:54 <pacak> bbear: It's called unit.
16:39:55 <pacak> ()
16:40:03 <Gurkenglas> trigone, confirming the process of deduction rather than its product is safer since you could have arrived there by other means.
16:41:24 <trigone> Gurkenglas: you mean like using a bike? :P just kidding, you're correct in the global case
16:42:36 <trigone> bbear: it's the type you use when you want to have an "empty" functor, like IO (). i'm not sure if it's used in any other case
16:44:07 <jared-w> bbear: interesting. I suppose it's more of a language thing than a programming language history thing. Regardless, you have a similar writing style to my friend and I thought it was interesting
16:44:18 <jared-w> Sorry for wording my original question poorly :p
16:44:30 <c_wraith> trigone, it's part of the deepseq implementation stuff. 
16:44:35 <c_wraith> :t rnf
16:44:37 <lambdabot> error: Variable not in scope: rnf
16:44:41 <pacak> trigone: It's useful to have to do ADT algebra. Maybe () is the same as Bool
16:44:55 <pacak> trigone: Either () a is the same as Maybe a
16:45:11 <pacak> same as - isomorphic. Pretending there's no bottom.
16:45:32 <pacak> There's also Void. Either Void a is the same as a
16:45:35 <trigone> pacak: then it still is when you want to sorta "hide" some unimportant type.
16:45:50 <trigone> pacak: pretending there's no bottom?
16:46:03 <trigone> pacak: really, why is Void different from ()
16:46:14 <trigone> :t Const
16:46:16 <lambdabot> forall k (b :: k) a. a -> Const a b
16:46:24 <pacak> There is one constructor vor (), there's no constructors for Void.
16:46:38 <trigone> pacak: it's defined as "data Void" ?
16:46:46 <pacak> So if function takes (Either Void a) - the only thing you can pass it will be "Right a"
16:46:48 <pacak> trigone: yes
16:46:51 <trigone> pacak: or maybe the constructur is just not exported?
16:46:52 <jared-w> trigone: bottom exists everywhere in Haskell because you can always say `x = error "kaboom"`
16:47:00 <pacak> @src Void
16:47:00 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:47:19 <trigone> jared-w: yeah i heard of that, but it's in the context
16:47:21 <jared-w> Pretending bottom doesn't exist and infinite loops aren't allowed is "fast and loose reasoning which is morally correct"
16:47:37 <trigone> lol the lambdabot rebels
16:48:04 <trigone> jared-w: don't start again with your religion :P
16:48:22 <jared-w> Oh, the context. Newtype vs Data has an interesting distinction in bottoms. You have different bottoms there and they can show up in subtle ways
16:49:06 <trigone> c_wraith: deepseq? is it like seq, the eager thingy?
16:49:09 <jared-w> So saying Either () a is the same as Maybe a is true except for the fact that Either and Maybe have some different bottoms. If you pretend bottom doesn't exist, you can further pretend that they *are* isomorphic
16:50:03 <trigone> jared-w: does it practically show in any way that they have different bottoms?
16:50:08 <c_wraith> trigone, yes, but it digs into recursive data types to ensure the whole thing is evaluated. 
16:50:30 <trigone> c_wraith: that's useful. it's a typeclass, or it works for any ADT?
16:50:54 <bbear> hello
16:51:17 <trigone> bbear: hi, how are you today?
16:51:39 <c_wraith> trigone, https://hackage.haskell.org/package/deepseq-1.4.2.0/docs/Control-DeepSeq.html#v:rnf
16:51:41 <bbear> I want to do string comparison, case insensitive. It seems that I have two options : either I use the toLower/toUpper functions to do my job, or I define a new type and a new ordering on that type. What do you think is the best ?
16:51:49 <bbear> trigone: I am fine, thank you.
16:52:10 <trigone> c_wraith: i see the use for it
16:52:11 <jared-w> The differences between the bottoms does end up mattering in some subtle cases, which is why the compiler can't automatically rewrite some data declarations into newtypes
16:52:55 <trigone> jared-w: ok
16:53:14 <johnw> are type-level tuples defined in base?
16:53:32 <jared-w> trigone: https://www.reddit.com/r/haskell/comments/5z5bcy/newtype_vs_data/ If you want to go down a bit of a rabbit hole :)
16:53:58 <bbear> see ya
16:54:25 <glguy> johnw: You mean the ones you get from -XDataKinds ?
16:54:28 <trigone> jared-w: maybe another day, for now i'm trying to start lenses
16:55:00 <johnw> glguy: does that let me say :: '(*, *) -> *?
16:55:03 <trigone> what's the deal with the functor Const?
16:55:25 <johnw> trigone: how do you mean?
16:55:48 <glguy> johnw: What would that do?
16:55:57 <trigone> johnw: well, i can't exactly get how it works. it does seem like one of its types is mostly discarded, a bit like the function const
16:56:04 <johnw> glguy: it says that I want a type which is a product of two types?
16:56:27 <glguy> johnw: Is that just a normal tuple?
16:56:31 <johnw> trigone: Const maps any type to a type of your choosing
16:56:38 <johnw> glguy: but saying * -> * allows it to be non-tuples also
16:57:19 <glguy> Type level tuples woudld be things like: '( 'True, 'False) :: (Bool, Bool)
16:57:36 <glguy> where the lhs was a type and the rhs was a kind
16:57:46 <trigone> johnw: oh you want constraint on the parameter of the type constructor... maybe you do need some extension
16:58:21 <johnw> glguy: maybe then I want kind-level tuples (even though type/kind distinction should be gone by now?)
16:58:43 <trigone> johnw: wrt Const, can you give me an example because it's unclear when you don't know what it means
16:59:06 <johnw> Const Int a is a type that, for whatever a you pick, I'll ignore that and give you an Int
16:59:25 <johnw> it's useful for passing around a value as if it were a functor, without respect to what people try to do to that functor
16:59:39 <johnw> (excuse my loose terminology)
16:59:41 <trigone> johnw: and how do you construct values of that type?
16:59:48 <johnw> Const 10 :: Const Int Float
16:59:51 <Cale> johnw: btw, thanks for that pointer re. (F,G)-dialgebras -- clearly the right name for such a thing once you hear it :)
16:59:55 <trigone> johnw: you lost me after "without respect..."
16:59:58 <johnw> Cale: :)
17:00:14 <johnw> trigone: if you fmap over it, nothing happens to my Int
17:00:27 <trigone> johnw: oh cool... so fmap = id?
17:00:36 <johnw> > fmap (+1) (Const 10 :: Const Int Float)
17:00:38 <lambdabot>  Const 10
17:00:39 <trigone> sorry no i meant sth like const id
17:00:43 <johnw> yeah, sort of
17:01:04 <trigone> can i use @src to search for a typeclass instance?
17:01:11 <trigone> @src Functor Const
17:01:11 <lambdabot> Source not found. You speak an infinite deal of nothing.
17:01:27 <johnw> gotta go now, good luck trigone
17:01:27 <glguy> johnw: Are you looking for something like this? data MyTuple :: (*,*) -> * where MyTuple :: a -> b -> MyTuple '(a,b)
17:01:33 <trigone> johnw: thk
17:02:43 <trigone> glguy: would you really need the ' before the tuple? is it a way to make it un-pattern-matching-able?
17:03:29 <glguy> trigone: without the ' you'd have  data MyTuple :: * -> * where MyTuple :: a -> b -> MyTuple (a,b)
17:03:58 <glguy> which isn't the kind johnw asked for
17:04:08 <trigone> glguy: isn't that * -> * -> * instead?
17:04:12 <glguy> trigone: no
17:04:39 <trigone> glguy: hm ok...
17:04:48 <glguy> trigone: (a,b) has kind *
17:05:33 <trigone> glguy: yeah, i think i was mistaking the type of the data constructor with the kind of the typeconstructor
17:05:48 <trigone> anyway unrelated, i'm trying to understand this signature: (^.) :: a -> ((b -> Const b b') -> a -> Const b a') -> b
17:06:12 <glguy> trigone: better to reason about: (^.) :: s -> Getting a s a -> a
17:06:19 <trigone> i don't get the semantics of the second argument
17:06:26 <trigone> glguy: well that'd work if i knew of Getting
17:06:39 <glguy> trigone: since you don't, you should ignore ^. and focus on GEtting
17:07:58 <glguy> Since newtype Const a b = Const a, to make sense of what's going on you can replace the type 'Const a b' with a
17:08:06 <glguy> type Getting r s a = (a -> Const r a) -> s -> Const r s
17:08:16 <glguy> type Getting r s a = (a -> r) -> s -> r
17:08:46 <trigone> glguy: actually i should have studied the implementation first, i thought it'd be too hard to understand but actually it makes sense when (b -> Const b b') just represents Const itself
17:08:54 <glguy> If you know how to turn 'a' into 'r', this thing is going to allow you to turn an 's' into 'r'
17:10:16 <trigone> glguy: why do we not mark phantom-like types like b' and a' in a special way, given that obviously they don't interact with the rest. i'm thinking we could practically replace them with a wildcard
17:10:50 <glguy> In general they exist because we care about what they are
17:11:23 <trigone> glguy: hm maybe yes
17:29:20 <trigone> are functional references always defined in the following way: fstF x (a,b) = (,b) <$> x a
17:30:33 <trigone> edward kmett's lens vs van laarhoven?
17:33:33 <jared-w> Pretty sure edwardk's lenses /are/ van laarhoven. It's the profunctor ones that are weird af
17:33:51 <trigone> af?
17:33:57 <glguy> yes, that's the case for ed's
17:34:18 <trigone> what case?
17:34:26 <jared-w> "as fuck" -- my girlfriend got me saying 'af' now like a dirty millineal
17:34:54 <trigone> what's a millineal?
17:35:07 <MarcelineVQ> a person who uses the term millenial
17:35:08 <mniip> millenial, google it
17:35:46 <jared-w> Precisely, a person in a certain age range. More colloquially, a demographic of general behavior, linguistic, and socioeconomic patterns
17:36:47 <trigone> well that's clear as mud, even with google's help
17:37:06 <trigone> nevermind. apparently there's #haskell-lens, is it better if i ask there questions about lenses?
17:37:36 <ahihi> millennial with two n's, from mille + annus
17:37:41 <ahihi> "millenial" would be... something else
17:38:17 <jared-w> eh, there's a huge overlap between the two... Do people really frequent that place and not here?
17:38:27 <biglambda> This is a little off topic, but if I have a cabal project and I decide that about half the code makes more sense as a library than as part of my specific project, what is the best way to fork it off.
17:38:44 <jared-w> ahihi: thanks. I can never spell it right because I can't hear the difference between the i and the e and so it's always confusing to me.
17:39:08 <trigone> jared-w: in minute it's the same deal
17:39:09 <MarcelineVQ> biglambda: be the hero people need and make a lib that forks modules out of a package to another package :X
17:39:26 <biglambda> Hah/
17:39:30 <mud> trigone: I try to be clear
17:39:37 <biglambda> I don’t have the right cape.
17:39:45 <trigone> mud: lol
17:39:53 <mud> ;)
17:40:42 <biglambda> I guess my question is should I just fork it on github and delete code from either side, or start a new repository and transfer files into it.
17:40:51 <trigone> mud: i hope you don't frequent #gardening or #hiking-in-the-rain, otherwise you could be ping-ed every two sentences :P
17:41:02 <mud> Hah, thankfully I don't, no.
17:41:33 <jared-w> there's a person on here named clever too. I don't know how they keep from going nuts being pinged in all sorts of random stuff
17:42:17 <trigone> jared-w: is it really a word used that much here?
17:42:28 <ahihi> jared-w: it's just a funny thing to correct because of the implied meaning of the misspelling =P
17:42:41 <trigone> jared-w: still, i now understand why voldemort wanted to forbid his nickname so much :P
17:43:27 <jared-w> biglambda: I don't think there's any one true way to do this. My personal preference is to keep stuff in different packages but maybe not necessarily different github repos. Stack works with multiple projects in one directory quite nicely and I think cabal can do that too
17:43:52 <jared-w> Or you can just put everything in its own directory/git-repo if that's easier ¯\_(ツ)_/¯
17:44:19 <biglambda> I see, I want to make the library portion a dependancy of a new project.
17:44:29 <biglambda> Hence the desire to split it out.
17:44:39 <trigone> ¯\_(ツ)¯\_
17:45:31 <jared-w> biglambda: Well, it's up to you how you do that. I'd probably just stick the library part in its own repo and project, then include it in your projects and call it a day. Maybe put it on hackage if you think it doesn't suck a lot :p
17:45:45 <jared-w> (although that's certainly never stopped anyone)
17:46:24 <biglambda> Unfortunately you lose the commit history when you do that :(
17:46:45 <biglambda> That’s the only reason I was hesitant.
17:47:11 <bigdaddytank> Hey peeps, I'm a student who's wanting to use FP languages professionally and I was wondering if anyone here thinks it's worth learning category theory with Haskell.
17:47:17 <biglambda> Github doesn’t let me fork within my own account.
17:50:05 <jared-w> bigdaddytank: Well like most professional things. Theory is mostly useless when it comes to working "in the real world"
17:50:59 <jared-w> Category theory is a lot of fun and you'll probably become familiar with some parts of it while learning Haskell... But, definitely not required. Especially if you're using a "dirtier" FP like F# or Scala. Even Haskell only barely borrows some vague concepts from category theory
17:51:39 <bigdaddytank> thought so. I think somewhere I heard that category (or type) theory would help better understand Haskell's types better 
17:52:08 <bigdaddytank> Or it's more complex types
17:52:09 <jared-w> It's like saying understanding chemistry makes you a better blacksmith
17:52:32 <bigdaddytank> Yea I totally get it. 
17:53:15 <bigdaddytank> Eventually I'll have time to get all the way throught Learn You a Haskell
17:53:31 <jared-w> I probably wouldn't use that one. I've never found that book useful for me
17:54:17 <jared-w> I like the Haskell From First Principles book, or the Thinking Functionally book by Bird, or bitemyapp's github repo on how to learn haskell (which contains some good free online resources)
17:54:27 <bigdaddytank> it's a fairly simple guide. I am using Clojure at the moment, and it's really helped me understand more data-oriented programming
17:55:09 <bigdaddytank> which is the really biggest part of learning FP
17:55:28 <jared-w> It's not that it's simple, it's that the book is outdated, has few examples, and generally doesn't really do a good job at teaching. If you want to understand the mindset behind thinking funcctionally, you can't do much better than Bird's "thinking functionally with haskell"
17:56:36 <bigdaddytank> I'll definitely check it out. Using Clojure and Haskell professionally (say for like data science) would be a dream
17:56:38 <jared-w> Hutton's third edition of "the craft of functional programming" also doesn't suck. It's probably in between HFFP and Bird's book.
17:57:15 <jared-w> If you like Clojure, you might also want to check out Elm and Erlang. I've got a friend of mine who's into Clojure and also raves about Erlang
17:58:22 <bigdaddytank> Elm also looks cool for the transcompiling of JavaScript it does (plain JS sucks ass)
17:59:28 <bigdaddytank> Erlang is interesting, if anything I'd want to use Erlang for something besides telecommunication
17:59:35 <jared-w> Some people like to joke that Elm is "haskell on training wheels", so you might also look at PureScript (a haskell-like language that compiles to JS) or GHCJS (a JS backend for the GHC compiler)
18:00:01 <jared-w> Erlang really shines in making real-time high fault tolerant distributed systems
18:00:21 <bigdaddytank> It's just a matter of getting a job after I graduate honestly :P 
18:00:46 <bigdaddytank> That'll determine what I should learn and where to use it
18:01:46 * hackagebot testbench 0.2.1.0 – Create tests and benchmarks together – https://hackage.haskell.org/package/testbench
18:04:27 <jared-w> Any vague area of preference where you want to find a job? (USA, sillicon valley, home town, etc?)
18:05:54 * pacak likes Singapore
18:06:24 <bigdaddytank> USA
18:06:31 <bigdaddytank> I live in Texas
18:06:32 * jared-w likes anywhere I can get paid to do Haskell or PLT/TCS
18:06:39 <bigdaddytank> Yee-haw or whatever
18:06:49 <jared-w> ahh, okay. Austin is a pretty booming place for programming
18:07:08 * pacak gets paid to do Haskell
18:07:35 <jared-w> Anyway, you don't have a whole lot of chance doing a ton of FP in Austin... Better than a lot of places in the US, but mostly you're looking at web dev for internships and your first job or two :p
18:08:33 <bigdaddytank> Yea I've come to grips that web development is the easy low-barrier entry that'll probably where I'll have to start
18:09:10 <bigdaddytank> School luckily is going to help me find a paid internship this coming fall
18:09:35 <jared-w> Nice, that'll be good. Best to smash your starry eyes on the dreariness and pain of the real world as early as possible :p
18:10:37 <bigdaddytank> Hopefully with how much I already know the employer will pay me decently
18:11:42 * hackagebot cron 0.6.0 – Cron datatypes and Attoparsec parser – https://hackage.haskell.org/package/cron
18:11:45 <pacak> web development AKA javascript AKA that nobody uses anymore that framework that came out last month, new hot thing came  out yesterday?
18:12:23 <jared-w> pacak: the good stuff is interning with a finance company. It's like web dev but frozen in 2012
18:12:32 * jared-w cries slightly
18:13:32 <pacak> jared-w: You cannot use this feature because we must support IE7.0?
18:15:04 <jared-w> After 2 years of hassle, they finally got approved to use Node by the CTO who's a massive Microsoft diehard shill. So, not quite as bad as needing to use IE7, but it's a different flavor of hell :p
18:17:24 <bigdaddytank> Don't even get me started with Microsoft shills
18:17:54 <trigone> what's a shill?
18:17:59 <bigdaddytank> Ohhhhh boy
18:18:15 <slack1256> hpack -> cabal -> cabal2nix -> nix-shell -> stack projects
18:18:23 <slack1256> I got a hell of a setup ahead
18:18:41 <bigdaddytank> Vocab time
18:18:50 <slack1256> I wonder how else can I complicate my setup
18:18:56 <bigdaddytank> @trigone a person who publicly helps or gives credibility to a person or organization without disclosing that they have a close relationship with the person or organization. 
18:18:56 <lambdabot> Unknown command, try @list
18:19:09 <bigdaddytank> dammit, I'm an IRC scrub
18:19:26 <bigdaddytank> how do you direct message someone? xD
18:19:36 <slack1256> bigdaddytank: this works
18:19:44 <slack1256> is highlighted and public
18:19:54 <slack1256>  /msg on your client for private talk
18:20:11 <bigdaddytank> oh like so just the nick before the actual messgae?
18:20:18 <jared-w> or /query :p
18:20:32 <slack1256> yep, usually you can tab complete (at least glirc does)
18:20:43 <jared-w> bigdaddytank: the nick inside the actual message pings you but doesn't do anything to hide the message like a PM
18:20:58 <slack1256> yeah, it is public
18:20:59 <bigdaddytank> I'm on HexChat so maybe it has tab completion
18:21:10 <slack1256> what is the difference between /query and /msg ?
18:21:13 <jared-w> Anyway, the CTO isn't a shill in the /direct/ sense of the word; really they're more of a fanboy, but still
18:21:24 <jared-w> slack1256: no real difference that I know of ¯\_(ツ)_/¯
18:21:40 <bigdaddytank> There's also scripts and plugins for HexChat so that's a whole new world of learning
18:22:10 <slack1256> you guys should dabble in glirc, glguy did an awesome job on this client
18:22:13 <bigdaddytank> trigone: a person who publicly helps or gives credibility to a person or organization without disclosing that they have a close relationship with the person or organization. 
18:22:15 <slack1256> plus is written in haskell
18:22:20 <trigone> bigdaddytank: inside job-like?
18:22:24 <pacak> slack1256: /msg sends one message, /query opens a new chat.
18:23:15 <trigone> scrub is noob?
18:23:15 <bigdaddytank> trigone: no just a shmuck who's a fanboy with no real logic to their fanboy-ness
18:23:23 <slack1256> oh nice, it just setups a new windows
18:23:29 <bigdaddytank> trigone: yea :P
18:23:47 <jared-w> bigdaddytank: I find it amusing that every time you explain what a shill is, you use more and more american slang
18:23:51 <trigone> bigdaddytank: so by "close relationship" you just mean they like it very much? how can you hide it if you make the promotion of it?
18:24:20 <trigone> what's a shmuck? :P just kidding
18:24:21 <slack1256> you could pass of as a simple fanboy (who is somebodywho geniunely like something)
18:24:51 <trigone> pass off? by constrast with what then?
18:24:59 <slack1256> instead of recieving some kind of payment for you preferences (monetary)
18:25:11 <jared-w> Anyway, I misspoke, the CTO is not a shill, they're merely a fanboy. It's still annoying since they're also adament that Haskell is useless academic crap that's impractical in the real world
18:25:39 <bigdaddytank> trigone: well...sorry English is shit so it's hard explaining this stuff sometimes :P
18:25:46 <trigone> jared-w: that gotta suck indeed
18:25:49 <jared-w> trigone: Just out of simple curiosity, can I ask what your native language is?
18:26:22 <trigone> jared-w: could i not merely ignore the meaning of shill?
18:26:35 <bigdaddytank> trigone: might as well :P
18:26:41 <jared-w> sure, it wasn't relevant to what I was saying anyway
18:27:23 <trigone> jared-w: french, originally
18:29:48 <jared-w> Ahh, okay. http://www.wordreference.com/enfr/shill Does this help at all? :p
18:31:18 <bigdaddytank> what a chat service: we're explaining shill on a channel that could be taking about smart programming things
18:31:26 <trigone> jared-w: yeah, moderately. to me it does feel akin to inside job in spirit, like those celebrities who sell you shit but they're only doing it bc they're being paid
18:31:55 <jared-w> That's basically what it is. It's just that in english you would never say "inside job" because that has connotations to robbery and theft
18:32:27 <trigone> jared-w: yes, but that's theft by manipulation, and to me most advertisement falls squarely in this category
18:33:01 <trigone> it's just legal
18:33:03 <jared-w> The french have a much stronger definition of freedom than America does and it shows up in interesting ways. In America we have no concept of theft by manipulation because the capitalistic mindset of America does not consider the right of the worker or the right of the consumer
18:33:57 <trigone> jared-w: pretty sure that's not a genetic factor :P and by freedom you mean security? cuz capitalism would sing of the freedom to be advertized all day long
18:34:01 <jared-w> So "inside job" has connotations to illegal activity in america only and wouldn't be used in english as a synnonym to shill. However, in France, it appears that is a natural and intuitive synnonym due to cultural differences :p
18:34:47 <trigone> jared-w: you do know i'm not "the frenchman", as in, i'm hardly representative of my country's politics, of which i know nearly nothing
18:34:48 <jared-w> trigone: English does not differentiate between free and libre. I have a personal theory that this is influenced by our notions of capitalism and how we went through the industrial revolution differently than most of europe
18:35:24 <jared-w> trigone: True, but language shapes thought and culture shapes language. It's all connected at some deep level, to me
18:35:25 <slack1256> nah, english is just crippled by being a mashup of two languages
18:35:33 <jared-w> Only two? Pffh :p
18:35:50 <slack1256> more? damn
18:35:59 <trigone> jared-w: you say that as if france was communist or something ^^ as for terminology, well you have only one term for "freedom" and "liberty" (if that means anything)
18:36:57 <glguy> in can case, let's get back to the topic of Haskell
18:39:05 <jared-w> sorry, glguy 
18:57:26 <trigone> glguy: lol you killed that chatroom :P
18:57:33 <glguy> That's OK :)
18:58:08 <Clint> better than OK
19:00:07 <jared-w> Nah the chatroom needs a nice healthy dose of killing every now and then, otherwise it'd turn into #general_chat_for_haskell_nerds
19:00:20 <jared-w> *cough sorry cough*
19:03:35 <monochrom> We have only one word for "left adjoint of forgetful functor", yes.
19:03:59 <trigone> monochrom: what is that word?
19:04:03 <romildo> Is the function   \f x -> (x, f x)    defined in the standard library? If not, how can it be defined in point free style?
19:04:04 <monochrom> "free"
19:05:21 <glguy> :t ap (,)
19:05:22 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
19:06:17 <trigone> :t ap
19:06:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:06:26 <bigdaddytank> Not the channel to ask, but does anyone use neomutt as an e-mail client? I'm trying to figure out how to configure it :P
19:06:56 <monochrom> Oh w00t does this mean a modernized mutt? :)
19:07:23 <trigone> what's mutt? and what's a forgetful functor?
19:07:37 <monochrom> mutt is an older email client.
19:08:14 <romildo> glguy, trigone, thanks.
19:08:50 <monochrom> A forgetful functor is, for example, from monoids to sets such that it maps each monoid to its carrier set. So it forgets the monoid operators and constants. It's why we call it forgetful.
19:08:51 <bigdaddytank> neomutt is the new mutt
19:09:09 <jared-w> bigdaddytank: you're more likely to get useful answers if you go to https://www.reddit.com/r/unixporn/wiki/links/irc some of these
19:09:19 <bigdaddytank> monochrom: https://github.com/neomutt/neomutt
19:09:36 <jared-w> or... #neomutt ...
19:09:51 <monochrom> The left adjoint of this example maps each set (call it S) to the/a free monoid generated by S.
19:10:17 <bigdaddytank> jared-w: well I'm kind of waiting to here an answer from them. :P The guide is alright so far...just...slow
19:10:31 <monochrom> "A place to gather all the patches against Mutt."  Haha why do I think of Steam community mods? :)
19:10:43 <bigdaddytank> jared-w: the people on #neomutt that is
19:11:42 <jared-w> monochrom: there's an entire world out there of esoteric mutt patches. Maaan it's borderline ridiculous. Almost like email is obscenely complicated for being such a simple format invented 40 years ago
19:11:54 <trigone> monochrom: so it's like going through a function that loses data and trying to track back a "standard" point of origin?
19:12:20 <monochrom> Yes trigone.
19:13:12 <trigone> hm, and it's always from sets to monoids?
19:13:54 <trigone> and how can you choose which monoid is the right default?
19:14:13 <trigone> assuming there's more than one potential monoid
19:14:22 <monochrom> There is also a forgetful functor from groups to sets. And its left adjoints gives you free groups from sets.
19:14:57 <trigone> so a free functor would be what in this context?
19:15:09 <monochrom> Let set S be given. Then the free monoids generated by S are monoid-isomorphic. So we don't distinct them very much.
19:15:33 <monochrom> s/distinct/distinguish/
19:15:51 <monochrom> And it's why I wrote the weird "the/a". Unique up to isomorphism.
19:19:02 <trigone> hm i nearly understand what you mean :P anyway i went to ask Oz https://en.wikipedia.org/wiki/Monad_(functional_programming)#Free_monads
19:19:27 <monochrom> Yes that's another example.
19:19:39 <trigone> it looks like the Free data type is transforming function application into data construction
19:19:54 <monochrom> "free xxx" is "left adjoint of the forgetful functor from xxxs to sets"
19:20:22 <trigone> so, left adjoint of the forgetful functor from monads to sets
19:20:33 <trigone> mind you i'm not sure what's a monad in math terms
19:20:53 <trigone> at any rate the vocabulary is very amusing, it nearly reads like character from a story
19:21:20 <monochrom> I guess I need to replace "set" by something richer for "free monad".
19:21:29 <pacak> https://en.wikipedia.org/wiki/Monad_(category_theory)
19:22:12 <trigone> it looks like it replaces the polymorphism of the typeclass monad by arbitrary containers that represent bind and return without specifying what they mean. i suppose thereafter you can just execFree or something?
19:22:17 <monochrom> It's the best way to talk about the word "free" and still stay ObOnTopic
19:22:27 <trigone> ObOnTopic?
19:23:08 <trigone> pacak: lol your link point at some empty article begging to be written
19:23:18 <monochrom> I'll let you guess what that is. More examples: ObFibonacci, ObHaskell.
19:24:18 <trigone> Obiwan, Obviously, Obliterate, Oblong, Obrigado...
19:25:18 * hackagebot filter-logger 0.4.0.0 – Filterable request logging wai middleware. Change how data is logged and when. – https://hackage.haskell.org/package/filter-logger
19:26:44 <trigone> monochrom: am i right when i see the use of free monad as, sort of, allowing the polymorphism to be ... solidified into the value?
19:26:59 <trigone> i don't know how to describe it
19:29:08 <trigone> "A free Monad is one that does no work during the normalization step beyond simply grafting the two monadic values together."
19:29:51 <trigone> i think i'm getting the intuition of it. it does is very similar to how free monoid of any t is (according to wiki) [t] with (++, []) 
19:32:40 <trigone> here it'd be, for any monad m, the free monad is Free m a with (Return, Bind) concatenating monadic values without doing anything with it... 
19:38:48 <L4rmbr> hi, what is the difference between "Control.Monad.Identity" and "Data.Functor.Identity", I found for the former, the hackage page points to the latter, while for the latter the hackage page simply just doesn't exist.
19:43:46 <mnoonan_> trigone: you still have to worry about laws
19:51:43 <felixphew> thanks to everyone who helped answer all my silly questions, I've now finished my first haskell project!
19:51:51 <felixphew> https://github.com/felixphew/pokepaste-2
19:54:57 <glguy> L4rmbr: The difference is that one comes from base and one from mtl
19:56:04 <L4rmbr> glguy, mtl stands for "Monad Trans Library" ?
19:56:52 <glguy> ?hackage mtl
19:56:52 <lambdabot> http://hackage.haskell.org/package/mtl
19:57:29 <MarcelineVQ> felixphew: ehe neat, good job
19:59:04 <L4rmbr> glguy, thanks
20:08:47 <wespiser> what tutorial doesn't exist, that you wish existed? (in Haskell) ??
20:09:40 <jared-w> "the real, honest to goodness, ground up tutorial on how to write documentation that doesn't suck (looking at you 'types are docs' people) -- now with extra passive aggressiveness"
20:10:10 <wespiser> oh that's not a bad idea
20:15:34 <jared-w> Probably should write it without the passive aggressiveness if you actually do choose to write it :)
20:18:39 * hackagebot filter-logger 0.5.0.0 – Filterable request logging wai middleware. Change how data is logged and when. – https://hackage.haskell.org/package/filter-logger
20:22:18 <wespiser> jared-w, it will be soaked with smugness and pomp
20:23:31 <wespiser> in all honestly, I might sit on the topic until I get more experience 
20:24:23 <wespiser> but the article will write itself, since types are basically documentation 
20:46:30 <kupopo> @djinn (a -> (Either e r -> ()) -> ()) -> ((r -> ()) -> (e -> ()) -> p) -> (a -> p)
20:46:31 <lambdabot> f _ a _ = a (\ _ -> ()) (\ _ -> ())
20:48:23 <kupopo> @djinn (a -> (Either e r -> x) -> ()) -> ((r -> x) -> (e -> x) -> p) -> (a -> p)
20:48:23 <lambdabot> -- f cannot be realized.
20:48:51 <kupopo> @djinn (a -> (Either e r -> x) -> x) -> ((r -> x) -> (e -> x) -> p) -> (a -> p)
20:48:51 <lambdabot> -- f cannot be realized.
20:49:00 <MarcelineVQ> does anyone have exferencebot they can boot up?
20:50:05 <kupopo> @djinn (a -> (Either e r -> x) -> y) -> (y -> (r -> x) -> (e -> x) -> p) -> (a -> p)
20:50:06 <lambdabot> -- f cannot be realized.
20:51:56 <kupopo> @djinn (a -> Either b c) -> (b -> d) -> (c -> d) -> a -> d
20:51:56 <lambdabot> f a b c d =
20:51:56 <lambdabot>     case a d of
20:51:56 <lambdabot>     Left e -> b e
20:51:56 <lambdabot>     Right f -> c f
20:52:10 <glguy> kupopo: You can play with lambdabot using /msg
20:52:41 <pacak> or /query
21:02:48 <kupopo> @djinn (a -> (Either e r -> x) -> y) -> (((r -> x) -> (e -> x) -> y) -> p) -> (a -> p)
21:02:48 <lambdabot> f a b c =
21:02:48 <lambdabot>     b (\ d e ->
21:02:48 <lambdabot>        a c (\ f ->
21:02:48 <lambdabot>             case f of
21:02:48 <lambdabot>             Left g -> e g
21:02:50 <lambdabot>             Right h -> d h))
21:03:15 <kupopo> So long, and thanks for all the lambdafish!
21:51:11 <orzo> I'm implementing a networking protocol that requires encryption and I designed a polymorphic interface for it that assumed encrypting and decrypting would be a pure computation, which it is, but now it occurs to me that I need to cache some computations.  Should I redesign, or is this a good use of unsafePerformIO ?
21:51:49 <johnw> so your caching needs to write to disk?
21:51:54 <orzo> no
21:52:05 <orzo> just caching expensive computations in ram
21:52:05 <johnw> you can memoize purely
21:52:19 <orzo> without unsafePerformIO ?
21:52:21 <johnw> example: https://hackage.haskell.org/package/memoize-0.8.1/docs/Data-Function-Memoize.html
21:52:23 <johnw> sure
21:52:27 <johnw> lazy evaluation is the key
21:53:16 <peddie> orzo: something to keep in mind: if you cache the results of cryptographic operations, will you cause timing-related vulnerabilities?
21:55:39 <pacak> I'd FFI to some well tested C library for encryption.
21:57:18 <orzo> I don't think so.  I'm caching a symmetric key so that I don't have to redo the diffie-helman on each UDP query/response exchange between the same two nodes.
21:57:37 <peddie> orzo: that seems reasonable to me :)
22:01:56 <orzo> I don't understand the library, you linked, johnw?
22:02:11 <orzo> How do I specify the size of the cache?
22:02:22 <orzo> does it just keep consuming ram indefinitely?
22:02:25 <orzo> this is for a long-running server
22:02:30 <pacak> orzo: You don't.
22:02:43 <pacak> It will memoize all the computations 
22:02:54 <orzo> Well that sounds unsuitable
22:03:48 <pacak> You can memoize it on per connection level I think and release once connection is done.
22:04:17 <orzo> hm, this is a udp protocol without clear connection sessions
22:05:53 <orzo> does a finite cache require unsafePerformIO?
22:06:46 <pacak> Not really. You can implement your own cache in any way you like
22:07:09 <pacak> If  you are willing to manage your state manually
22:07:25 <orzo> Well, I don't know how to do it without unsafePerformIO
22:07:59 <pacak> have a separate Map Response Reply, pass it around. 
22:08:10 <johnw> you're wanting to manage internal state, without making that state visible in the type
22:08:26 <johnw> this would require circumventing the type system, yes
22:09:54 <johnw> I do know of ways to do this in a more principled manner, but that's a deep rabbit hole I doubt you want to go down
22:11:17 <orzo> Yeah, I'm either going to use unsafePerformIO or redesign to make the state explicit
22:11:33 <johnw> I'd recommend the latter, strongly
22:12:15 <johnw> you'll need to be careful of certain performance gotchas, if you need the highest speed possible
22:12:32 <pacak> unsafePerformIO is a big hammer.
22:12:52 <johnw> plus, it's unsafe :)
22:13:12 <johnw> you'll have to know that your program doesn't violate referential transparency, or that you never rely on it
22:13:18 <pacak> Big hammers usually are. Imagine you drop it by accident or hit your finger.
22:13:34 <cocreature> if this is about UDP requests, it seems like you are already in IO so just moving the caching there might be an easy solution
22:14:09 <orzo> well unsafePerformIO informs the reader on my intention as opposed to throwing IO in my type
22:14:36 <orzo> I could also try to more narrowly provide for the state, which I guess would bey type-system ideal
22:14:50 <orzo> but there's a balance in interface clutter
22:16:00 <johnw> once you open pandora's box, it's hard to close
22:19:18 <witten> how long did you guys take to feel comfortable with haskell? background: 1 yr of python
22:19:35 <pacak> witten: I'm still not comfortable with it :(
22:19:38 <johnw> witten: a couple of years
22:19:43 <pacak> :t confusing
22:19:45 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
22:20:21 <jle`> witten: to give some context, the more background you have in other languages, the longer it'll take for you to feel comfortable with haskell
22:20:34 <witten> a couple of years ?!!! i got here via page 1 of learnyouhaskell
22:20:35 <Hafydd> I don't think that's true.
22:20:51 <pacak> Haskell is a bit bigger than other languages.
22:21:24 <jle`> i was comfortable with writing real-world haskell apps after maybe a few months, half a year, and i'm not particularly good at programming :)
22:21:28 <johnw> witten: it's possible we have different definitions of comfortable :)
22:21:32 <cocreature> getting to the point where you can get things done in Haskell is not too bad
22:21:46 <cocreature> getting to the point where you feel like you know absolutely everything will take a long time
22:21:48 <johnw> my gauge was: the ability to talk with edwardk and not feel like he was speaking Thai
22:22:29 <jle`> after about one year in haskell i was probably as comfortable in it as i was in my previous languages
22:22:54 <edwardk> I have a book on how to speak Thai. I might have been.
22:22:59 <johnw> witten: I was able to make the computer do things after a couple months, but that's not the same as being comfortable enough to have things to say here
22:23:14 <johnw> edwardk: that explains so much!
22:23:34 <edwardk> I never did make it much past the alphabet, though.
22:23:52 <MarcelineVQ> in my experience you only need enough thai to place your order
22:24:32 <witten> i mean...practically speaking what advantage does it have over other languages?
22:25:22 <edwardk> I bought the book back when I was dating a Thai girl. Her dad taught Thai kickboxing and managed to express his disapproval of me dating his daughter very uh.. thoroughly.
22:25:22 <pacak> MarcelineVQ: Not really. You can place orders in language you don't understand at all.
22:25:33 <johnw> witten: it has a fantastic type system, which lets you know when your code isn't what you meant to say, and makes refactoring amazingly easy, even at large scales
22:25:49 <pacak> MarcelineVQ: Worst case scenario - you get surprise lunch.
22:26:10 <MarcelineVQ> "but now, I own his dojo"
22:26:23 <edwardk> It somehow survived 20 years since then on a bookshelf without getting kicked out for something more topical
22:29:55 <witten> clickbait question: does knowing haskell make one a better programmer
22:30:21 <Axman6> programming makes one a better programmer
22:30:25 <johnw> witten: in the sense that knowing computer science can have that effect, yes, since it often introduces you to many of the more fundamental concepts that are poorly represented in mainstream programming
22:30:48 <johnw> by itself, however, you get what you put in
22:31:07 <johnw> anyone can figure out how to use a language while learning the absolute minimum required
22:31:34 <pacak> witten: It helps you to think in more abstract terms.
22:32:59 <witten> i'm a neophyte so pardon my naivete, but could you give three examples of "fundamental concepts" in CS that are poorly understood by most working programmers/software engineers
22:33:31 <pacak> Functor, Applicative and Burrito.
22:34:18 * ongy doesn't understand Burrito after some time with haskell either
22:34:54 <pacak> witten: For example a huge number of null pointer exceptions can be avoided with those concepts.
22:35:05 <cocreature> ongy: you should read “burritos for the hungry mathematician”
22:35:17 <jle`> witten: learning haskell can help you be a better programmer, but learning a lot of other things can help too
22:35:42 <jle`> so "helping you be a better programmer" isn't a very high bar to surpass
22:36:03 <jle`> almost anything related to CS you learn will help you be a better programmer :)
22:36:10 <jared-w> cocreature: beat me to the punch :p
22:36:13 <ongy> cocreature: I have enough backlog for a few weeks, and porbably won't get to do any of it in the next 5 weeks :( But I'll try to remember :)
22:37:17 <jared-w> witten: you might as well ask "will learning algorithms, data structures, and recursion make me a better python programmer?" I mean, I don't know a lot of python code that /directly/ uses a lot of that, but it's pretty easy to see the difference in code quality between code monkeys and people who know those topics well.
22:37:53 <jle`> witten: to answer your previous question, i choose haskell over other languages for most of my projects because haskell lets me write more maintainable code, and helps me write code in a "simpler" way that requires me to keep track of less in my head
22:38:02 <pacak> It will make him a better programmer in general, but worse python programmer.
22:38:23 <jle`> it's usually true for most haskellers that they use haskell because it doesn't require them to be smart
22:38:31 <jle`> or well, that's one of the big reasons
22:38:40 <jle`> i use haskell because i'm not smart enough to use other languages
22:38:59 <pacak> s/smart/paying attention to tiny details/
22:39:05 <ongy> it's more that it allows me to be smart with enough help of the compiler that my stupidity doesn't mess things up
22:39:16 <pacak> In Soviet Haskell typechecker pays attention to you ☭
22:39:23 <jle`> well, most languages have some mechanism for helping you with tiny details
22:39:40 <witten> i taught myself python just for fun..i don't make a living off code..but are you guys really serious about programmers not really knowing CS? Then what's up with the "How to Crack the Coding Interview" questions
22:39:41 <jle`> but haskell catches you when you do stupid things
22:40:00 <pacak> jle`: Right. Like "undefined" in javascript or implicit conversions in PHP in case you forgot.
22:40:55 <jle`> and parametric polymorphism
22:41:11 <jle`> you can explicitly construct types to restrict all bad functions
22:41:52 <pacak> Yea, like safeFromJust.
22:42:01 <pacak> or safePerformIO
22:42:09 <ski> @quote please.talk
22:42:09 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
22:42:52 <ongy> I need to get some job teaching abstract things, so I'm forced to understand them better...
22:42:56 <mud> witten: It very much depends what you mean by a programmer and by CS. Programming is a part of CS, though there is much much more that. My by definitions, the usual programmer doesn't know a lot of CS.
22:42:57 <tefter> haskell makes you memory leaks in more interesting ways ;)
22:44:33 <witten> Can I read that as "The average software engineer doesn't know a lot of CS"
22:45:00 <pacak> There is A LOT of CS.
22:45:05 <jared-w> witten: "CtCI" is very much about how to do well in a super specific type of programming interview that you don't find in a whole lot of places. People study these things to hyper specialize for a rigged test; it's like studying for the SAT or ACT in america.
22:45:41 <jared-w> But yeah, there's a LOT of CS out there. You can spend your entire life in category theory and never even touch formal logic, programming language theory, <insert 50 other topics>, ...
22:46:26 <jared-w> I'd say that only about 1% of CS (if that) is really "immediately relevant" to programming
22:47:21 <tefter> haskell makes you write less code for more payload ;p (I think this is crucial)
22:47:32 <mud> Well, there are other reasons to study algorithms and data structures than to pass those tests.
22:48:41 <jared-w> mud: sure, but most programmers I know import some basic data structure library and use the 3-4 common data structures that actually come up in their day to day job and be done with it. Whenever that fails, just post to stack overflow about what data structure you should use and then follow that advice. It's not like you need to actually know what you're doing 99% of the time
22:48:56 <johnw> witten: Monoids, Graphs, Functors, were some of the major concepts Haskell introduced me to
22:49:27 <ongy> Graph? Knodes connected by edges, or am I missing out on something?
22:49:30 <johnw> yep
22:49:34 <mud> jared-w: Yes. Most don't really need to know more than that.
22:49:36 <johnw> believe or not, I'd never even heard of them before
22:49:55 <pacak> Parsing stuff with Burritos is so much easier.
22:49:58 <Axman6> I've never used graphs for anything :(
22:50:07 <jared-w> Since lambda calculus works by "reduction/evaluation" and haskell is nothing more than fancy lambda calculus, the entire compiler and its optimizations can be considered graph reduction :p
22:50:14 <jared-w> pretty neat, actually
22:50:25 <johnw> I'd built this really complicated function in C++ once, and a friend of mine (who was also studying Haskell), was like, "Dude, this is just Djikstra's shortest path search".  He then gave me his college textbook, opened the chapter on graphs, and said, "read this, you'll like it."
22:50:46 * johnw wasn't a CS student
22:50:48 <witten> so CtCI is a cheap but inaccurate filter to filter the talent pool..is that it
22:51:10 <johnw> I now use graphs pretty regularly
22:51:13 <jared-w> No, CtCI is the programming equivalent to "how to raise your SAT score for dummies"
22:51:44 <jared-w> You learn the problems, you get good at solving those kinds of problems, and the *hope* is that you learn to generalize the problem solving methods and the CS theory behind those problems into real world applications
22:51:45 <johnw> what is CtCI?
22:51:48 <mud> Any sane test wouldn't ask questions directly from that anyway, so by my measure you're better off doing a less crammy book. Though the interview advice and stuff in there might be good, I don't even know.
22:51:53 <jared-w> Cracking the Coding Interview, johnw
22:52:08 <ongy> johnw: really? Maybe I'm just more used to them because I tend to like networks
22:52:26 <ongy> but I didn't like to deal with graphs in haskell... Trees are pretty nice, but general graphs with loops get annoying to model
22:52:35 <zekt> I would say after learning haskell, I find implementing algorithms more tempting and chilling. I always produce tons of bugs when doing it in C++.
22:52:57 <tefter> i never head to deal with anything else besides trees and linked lists
22:53:41 <jared-w> No table structures or hash based structures? Key,value structures? List-like variants?
22:53:57 <tefter> these are not graphs
22:54:41 <jared-w> You can implement a graph using a key,value structure or a table if you do it right :p
22:54:45 <mud> ongy: I've only really done kind of sketchy adjacency list things that didn't really use types well. I'm not sure how you do anything more ... principled.
22:55:46 <jared-w> But still, I'm surprised you never went over graphs, tefter
22:57:13 <jared-w> They're one of the most basic data structures on which modern data structures build off of; you see them pretty much everywhere if you read any paper on storage or AI or most anything by Google in the last 10 years
22:57:15 <tefter> well i hadn't had such problem
22:58:16 <zekt> any suggestion reading for knowing more about type system in functional programming? I am now reading "Types and Programming Languages" by Pierce.
22:58:20 <tefter> I said trees and linked lists these are only two types of graphs I had to deal with
23:09:19 <johnw> zekt: great place to start
23:09:46 <johnw> zekt: at some point, implement the simply-typed lambda calculus, and then begin extending your toy language with more features
23:31:39 <ReinH> zekt: finish Ta
23:31:58 <ReinH> er, finish TaPL and then read TaPL 2: The Typening
23:32:20 <ReinH> Ok, it's actually called Advanced Topics in TaPL
23:32:58 <ReinH> Harper's Practical Foundations is also good
23:34:09 <johnw> accursedUnutterablePerformIO always makes me smile
23:35:27 <johnw> "If you think you know what you are doing, use 'unsafePerformIO'. If you are sure you know what you are doing, use 'unsafeDupablePerformIO'. If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'."
23:41:30 <zekt> johnw: thanks! does "implement" means to define it in like haskell? I've done a practice like that on a small language and find it inspiring, but sometimes I wonder if I am really learning it, since I am like using which someone has built for me to implement itself...?
23:42:03 <johnw> zekt: sure, Haskell is a good language to implement it in
23:42:17 <johnw> for example, take this project: https://github.com/sweirich/pi-forall
23:42:37 <johnw> it's didactic approach is to have you evolve from untyped lambda calculus all the way to a dependently-typed language
23:42:56 <johnw> (i think it started at untyped, it might be STLC)
23:43:00 <zekt> ReinH; save to my list, didn't know those books, thanks!
23:43:02 <koala_man> I have a  Maybe Foo. how do I turn it into a MaybeT m Foo? I have the latter and I want to include the former in the middle and fail if it fails
23:43:28 <johnw> koala_man: use "MaybeT $ return x"
23:43:52 <johnw> strangely, there's no lifting mechanism for MaybeT
23:44:12 <koala_man> ah nice, thanks
23:45:05 <rgrinberg> suppose I have some type X a b, is there a way to do derive (Functor) on it where a is the functor type variable rather than b?
23:45:32 <johnw> no
23:45:40 <johnw> but you can build a lens that has that effect
23:45:46 <johnw> or, make a newtype wrapper
23:46:10 <johnw> newtype Flip f a b = Flip  { getFlip :: f b a }
23:46:56 <rgrinberg> johnw: thanks, i'll just flip
23:47:05 <johnw> it gets annoying if it's deep down
23:47:15 <johnw> that's when lenses becomes clearly superior
23:49:46 <zekt> johnw: sounds great, would try to do it myself, thanks again
23:59:51 <neoncontrails> I need to write a text preprocessor for use with a Python-based machine learning prototype. It'd probably be easier to use Python, but I'm pretty eager for an excuse to write my first Haskell app (plus the preprocessor I want to write is essentially a finite state machine which seems to play well to Haskell's strengths.) Does Haskell have nice tools for parsing text documents?
