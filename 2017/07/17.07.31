00:00:16 <adelbertc> is there any practical difference between Data.Functor.Compose from base vs. transformers ?
00:01:26 * hackagebot focus 0.1.5.1 – A general abstraction for manipulating elements of container data structures – https://hackage.haskell.org/package/focus
00:01:26 * hackagebot yesod-bin 1.5.2.4 – The yesod helper executable. – https://hackage.haskell.org/package/yesod-bin
00:02:40 <adelbertc> guess not: https://ghc.haskell.org/trac/ghc/ticket/11135?cversion=0&cnum_hist=5
00:18:35 <cinimod> I have a function
00:18:38 <cinimod> S.withMatrix :: Matrix S.ℝ -> (forall (m :: Nat) (n :: Nat). (KnownNat m, KnownNat n) => S.L m n -> z) -> z
00:18:57 <cinimod> But I wish to do something like
00:18:59 <cinimod> S.withMatrix ((2><2) [2,0,0,2]) (\x -> S.size (x S.<> x))
00:19:14 <cinimod> error: Couldn't match type ‘m’ with ‘n’
00:19:27 <cinimod> Do I have to use unsafeCoerce?
00:24:48 * hackagebot focus 0.1.5.2 – A general abstraction for manipulating elements of container data structures – https://hackage.haskell.org/package/focus
00:25:29 <cinimod> Maybe even that doesn't help as I don't want to coerce types to be the same
00:26:09 <cinimod> I just want a general function to specialize
00:26:24 <Cale> cinimod: I'm not sure I understand
00:27:22 <cinimod> Cale: In simple terms how do I get rid of the error?
00:28:22 <Cale> cinimod: What's the type of S.<> ?
00:28:41 <cinimod> I knew you were going to ask :)
00:28:54 <cinimod> (S.<>) :: (KnownNat n, KnownNat k, KnownNat m) => S.L m k -> S.L k n -> S.L m n
00:29:17 <Cale> Right, so you can't necessarily multiply the matrix you get with itself.
00:29:29 <cinimod> I can if it's square
00:29:33 <cinimod> Ok
00:29:46 <Cale> So what do you want to produce if it's not square?
00:29:47 <cinimod> How do I say I know it's square
00:30:04 <cinimod> It makes no sense if it's not square
00:30:20 <Cale> The thing about this withMatrix is because it's consuming an arbitrary matrix, it doesn't statically know that the matrix is a square one
00:30:31 <cinimod> Agreed
00:30:43 <Cale> Perhaps you'd rather produce an S.L 2 2 directly
00:30:45 <cinimod> So I need my own withSqaureMatrix
00:30:51 <Cale> and then square it
00:30:52 <cinimod> ?
00:31:06 <Cale> Well, that can't really safely exist, can it?
00:32:06 * hackagebot rebase 1.1 – A more progressive alternative to the "base" package – https://hackage.haskell.org/package/rebase
00:32:11 <cinimod> Well withMatrix is unsafe
00:32:20 <cinimod> or perhaps not
00:32:41 <cinimod> I think I could lie about its dimensions
00:32:58 <Cale> Do you care that the matrix you're using as input is not a statically checked one?
00:33:19 <cinimod> No that's the whole point of withMatrix
00:33:30 <Cale> You don't care?
00:33:47 <cinimod> It takes a dynamic matrix and then calculates using static matrices
00:34:12 <Cale> Yeah, but because it gets a dynamic matrix, the thing it does has to work for *any* size of static matrix.
00:34:14 <cinimod> So e.g. you can read in the matrix as data
00:35:23 <cinimod> Ok thanks
00:36:19 <Cale> let x = matrix [2,0,0,2] :: L 2 2 in x <> x
00:36:23 <Cale> You could use something like that
00:36:34 <Cale> If you know the size of the matrix already
00:36:50 <cinimod> Yes it's easy if you know the size of the matrix
00:37:00 <cinimod> But typically you are reading in data
00:39:00 * hackagebot rerebase 1.1 – Reexports from "base" with a bunch of other standard libraries – https://hackage.haskell.org/package/rerebase
00:39:18 <cinimod> Anyhow it's now clear to me I can't use the example I gave
00:40:18 <cinimod> S.withMatrix ((2><2) [2,0,0,2]) (\x -> S.size x) works
00:40:29 <Cale> You could use sameNat to check if the matrix is square
00:40:47 <Cale> and then produce Nothing or something in the case when it's not
00:40:59 <cinimod> :)
00:41:49 <cinimod> Thank you very much - it was just an example to try out withMatrix
00:41:59 <cinimod> I now see it was nonsensical
00:42:06 <cinimod> But yes sameNat would work
00:42:16 <cinimod> I will now go back to my real problem
00:42:33 <cinimod> I am implementing a variational inference algorithm
00:43:04 <cinimod> And there are a sufficient number of dimensions that a static check is very helpful
00:43:42 <cinimod> dimension of observations, no. of observations, no. of centres (for a k-means problem)
00:49:07 * hackagebot system-extra 0.1.0 – A bunch of system utilities used by other projects – https://hackage.haskell.org/package/system-extra
00:49:07 * hackagebot list-t 1.0.0.1 – ListT done right – https://hackage.haskell.org/package/list-t
00:57:43 * hackagebot pagination 0.2.1 – Framework-agnostic pagination boilerplate – https://hackage.haskell.org/package/pagination
00:57:43 * hackagebot non-negative 0.1.1.1 – Non-negative numbers – https://hackage.haskell.org/package/non-negative
01:03:17 * hackagebot hasql 0.19.18.1 – An efficient PostgreSQL driver and a flexible mapping API – https://hackage.haskell.org/package/hasql
01:11:27 <SepakoRayl1> is anyone using spacemacs and managed to integrate stack ?
01:13:25 <hio> haskell is a toy language as far as I'm concerned. They purposefully over engineered it, haskell devs STILL dont have a good IDE. In 20 years nobody bothered to make a visual studio plugin. Why even bother?
01:13:47 <sbrg> okay cool
01:15:05 <jle`> i know right
01:15:29 <boj> we're masochists i guess
01:15:43 <mrkgnao> SepakoRayl1: sure, lots of people have
01:16:00 <Cale> hio: Actually, there has been a Visual Studio plugin
01:16:23 <mrkgnao> follow the instructions for the Haskell layer in the Spacemacs docs, ask around if you need help after that
01:16:25 <Cale> hio: I don't recall it ever being popular though, and it stopped being maintained
01:16:30 <hio> Cale, exactly
01:16:46 <mrkgnao> but the VSCode plugins are well-maintained and fairly popular
01:17:00 <mrkgnao> Haskelly and something else, I forget
01:17:04 <butterthebuddha> How does takeWhile work with infinite lists?
01:17:14 <Cale> Yeah, I don't know which text editor you like, but there's probably enough support for most things.
01:17:25 <Cale> @src takeWhile
01:17:25 <lambdabot> takeWhile _ []                 = []
01:17:25 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
01:17:25 <lambdabot>                    | otherwise = []
01:17:43 <butterthebuddha> So ... it returns an infinite list?
01:17:52 <Cale> If the condition keeps holding
01:17:58 <ertes-w> i need a widget GUI library that works on linux…  any recommendations?  the simpler the better
01:18:09 <butterthebuddha> I want to end the takeWhile after it reads in a one
01:18:16 <Cale> takeWhile (/= 1) ...
01:18:25 <butterthebuddha> Okay thanks!
01:19:01 <Cale> ertes-w: Reflex-dom ;)
01:19:17 <Cale> ertes-w: If not that, then probably the gtk binding?
01:19:44 <ertes-w> Cale: i will use reflex, but i'd prefer something native
01:19:50 <butterthebuddha> http://lpaste.net/357318
01:20:04 <butterthebuddha> I'm trying to reimplement fun2 entirely in terms of composition
01:20:08 <butterthebuddha> fun2' is that attempt
01:20:17 <ertes-w> Cale: i'm aware of gtk, but it's awfully complicated…  i have trouble finding my way around the API
01:20:18 <butterthebuddha> And I'm kinda stuck
01:21:28 * hackagebot haskell-tools-ast 0.8.1.0, haskell-tools-backend-ghc 0.8.1.0, haskell-tools-prettyprint 0.8.1.0
01:21:28 * hackagebot  → https://hackage.haskell.org/packages/recent
01:21:32 <ertes-w> perhaps it would be best to use a TUI library here…  all i really need is an edit-line and a scrolling text box for output
01:21:37 <Cale> ertes-w: If you compile with GHC, you'll get a native executable
01:21:51 <jle`> butterthebuddha: what do you think filter does?
01:22:08 <ertes-w> Cale: oh, right…  i should try that, thanks
01:22:52 <butterthebuddha> jle`: it filters out element that don't return true for the predicate?
01:23:09 <jle`> *elements
01:23:14 <jle`> :t filter
01:23:15 <lambdabot> (a -> Bool) -> [a] -> [a]
01:23:29 <butterthebuddha> I'm stuck because I need to recurse again
01:23:35 <butterthebuddha> After filtering
01:24:49 <jle`> if you're trying to implement fun2' to be the same as fun2, then you might have to step back a bit.  so far the two functions don't look anything like each other, heh
01:26:08 <jle`> you can factor out the recursive pattern by using a higher-order function, and iterate does work there yes
01:26:28 <jle`> you can iterate your fun2 logic
01:26:43 <butterthebuddha> Iterate needs to apply two functions though
01:26:46 <butterthebuddha> depending on the condition
01:27:53 <locallycompact> There's a thing in haskell that lets you deconstruct with like foo@Record bar baz etc what is it?
01:28:01 <jle`> locallycompact: as patterns
01:28:29 <locallycompact> thanks
01:28:33 <jle`> you might be thinking of foo@(Record bar baz)
01:29:00 <jle`> butterthebuddha: honestly writing fun2 in terms of function composition only is most likely going to be a huge mess
01:29:07 <jle`> just warning you before you continue down further
01:29:10 <locallycompact> jle`, yeah that one, thanks
01:29:40 <butterthebuddha> That's what the assignment is though :( https://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
01:30:24 <jle`> hm
01:31:19 <MarcelineVQ> it's not too messy, but it is an odd one to figure out
01:37:12 <jle`> butterthebuddha: you already handle your recursion using iterate
01:37:23 <jle`> but you need to be a bit smarter with how you iterate
01:37:38 <jle`> instead of just ((+ 1) . (3 *)) every time
01:37:43 <butterthebuddha> Can I just throw an if statement in there?
01:37:50 <jle`> yeah i think that should be ok
01:37:57 <jle`> i don't think *that* part has to be composition-only
01:40:02 <butterthebuddha> How about that - http://lpaste.net/357318
01:40:49 <butterthebuddha> And then just sum the result up
01:41:50 * hackagebot haskell-tools-daemon 0.8.1.0, tagged-binary 0.2.0.1, haskell-tools-debug 0.8.1.0, haskell-tools-refactor 0.8.1.0, … and 1 more
01:41:50 * hackagebot  → https://hackage.haskell.org/packages/recent
01:42:03 <jle`> what happens when you try
01:42:22 <butterthebuddha> That seems to work
01:42:44 <butterthebuddha> I couldn't prove to you how but it worked on 5 different inputs so i'm gonna assume it's correct
01:45:05 <jle`> yeah seeing how it works takes a bit of mahtmeatical thinking
01:45:19 <jle`> which makes it more of a math exercise than a haskell exercise to me
01:45:21 <jle`> but oh well
01:47:50 * hackagebot haskell-tools-demo 0.8.1.0 – A web-based demo for Haskell-tools Refactor. – https://hackage.haskell.org/package/haskell-tools-demo
01:49:29 <MarcelineVQ> gj butterthebuddha, not however that /= 1 isn't qite sufficient, inputs  <= 0  will cause a loop
01:49:36 <MarcelineVQ> *note
01:51:16 <MarcelineVQ> allthough, the original doesn't work on those inputs either probably :>
01:52:10 <MarcelineVQ> you're missing one last bit though, do you know which?
01:53:18 <MarcelineVQ> to clarify your fun2' from http://lpaste.net/357318 doesn't typecheck, did you solve that?
02:01:00 * hackagebot cast 0.1.0.0 – Abstact cast pattern – https://hackage.haskell.org/package/cast
02:07:05 * hackagebot references 0.3.2.2 – Selectors for reading and updating data. – https://hackage.haskell.org/package/references
02:07:05 * hackagebot cast 0.1.0.1 – Abstact cast pattern – https://hackage.haskell.org/package/cast
02:09:37 <Guest95003> hello, trying to run stack on OSX on a script file I created some time ago. getting some crap about "can't load .so/.DLL for longpathtomtl"
02:12:15 <SepakoRayl1> mrkgnao: Do the "cabal" commands like build work correctly with stack ?
02:13:28 <saurabhnanda> in TH can I cheat and use mkName "(PK UserTable)" instead of doing something like AppT (ConT $ mkName "PK") (ConT $ mkName "UserTable")
02:17:38 <cocreature> saurabhnanda: does it need to be a string or do you just want the simpler syntax?
02:17:52 <saurabhnanda> simpler syntax.
02:18:10 <mrkgnao> SepakoRayl1: there is `stack build`. I'm not sure about Cabal.
02:18:20 <saurabhnanda> two reasons: (a) simpler syntax and (b) UserTable is actually a type, and not a data constructor. So, I'm not sure what the right thing to do here is.
02:18:38 <saurabhnanda> ConT is supposed to represent a data constructor a type name?
02:19:01 <cocreature> saurabhnanda: [t|PK UserTable|]
02:19:22 <mrkgnao> saurabhnanda: what about [t|PK UserTable] (or whatever the QQ syntax is)?
02:19:42 <saurabhnanda> and this can be put in code which is doing complicated stuff with AppT, ConT, VarT, etc?
02:19:57 <mrkgnao> yes, look up TH quasiquoters
02:20:11 <saurabhnanda> for my understanding, please ==> ConT is supposed to represent a data constructor a type name?
02:20:28 <mrkgnao> [t| foo |] constructs a TH expression corresponding to a type
02:20:35 <saurabhnanda> also, why bother with all the ADT representation if one can generate verbatim code and use quasi-quoters?
02:20:54 <saurabhnanda> the AST representation is EXTREMELY hard to read 2 months down the line!
02:21:01 <cocreature> well then don’t use it ;)
02:21:18 <cocreature> there is a reason we have support for quasiquotation
02:21:20 <mrkgnao> because QQs are technically using TH (I think) so maybe it's compile time problems?
02:21:23 <saurabhnanda> is there a benefit of AST that I'm missing here? Something that I'll realise later?
02:21:55 <saurabhnanda> hang on... doesn't this become TH inside TH?
02:22:05 <mrkgnao> you can probably write TH expressions that generate code without using -XTemplateHaskell[Quotes]
02:22:14 <mrkgnao> it's TH *using* TH
02:22:35 <cocreature> quasiquotes only really work if you have some constant expression. if you use the actual AST you can more easily manipulate the different expressions
02:22:50 <cocreature> butu [t|…|] will just give you back the AST so if it works there is no downside afaik
02:23:17 <saurabhnanda> okay, let me try that.
02:23:36 <saurabhnanda> but in this case I need an AppT $ ConT $ ConT, right?
02:23:38 <mrkgnao> cocreature: there is antiquotation, though, afaik?
02:24:38 * hackagebot cast 0.1.0.2 – Abstact cast pattern – https://hackage.haskell.org/package/cast
02:24:38 * hackagebot storablevector 0.2.12.1 – Fast, packed, strict storable arrays with a list interface like ByteString – https://hackage.haskell.org/package/storablevector
02:25:00 <mrkgnao> so non-constant expressions are doable
02:25:01 <cocreature> mrkgnao: yes, so? if you want to manipulate the TH AST you will still have to write some functions that actually pattern match on that AST and not on some quasi quote
02:25:20 <cocreature> ah that’s what you’re referring to
02:25:24 <cocreature> yeah that should work I think
02:25:30 <mrkgnao> yep
02:25:48 <mrkgnao> saurabhnanda: use the REPL, Luke
02:26:08 <mrkgnao> GHCi is very helpful when trying to figure out how the AST works
02:26:45 <mrkgnao> :set -TemplateHaskellQuotes and enter QQ expressions, and it will Show them to you
02:28:31 <cocreature> actually it won’t
02:28:48 <saurabhnanda> hmmm, I don't think using [t|blah|] will work. 
02:28:49 <cocreature> you need something like $(stringE =<< show <$> [e|Left 1|])
02:29:11 <saurabhnanda> it seems like it evaluates the expression immediately. whereas I'm trying to define a cyclical type
02:30:35 <saurabhnanda> https://gist.github.com/saurabhnanda/15607c83954f2cdadc67390aaccd1d67
02:30:40 <saurabhnanda> ^^ that is the core problem.
02:30:43 <mrkgnao> cocreature: I meant things like runQ [t| [Int] ], when you're trying to figure out all the AppT/ConT stuff
02:31:23 <saurabhnanda> thanks mrkgnao
02:31:30 <saurabhnanda> that cleared it up -- it's AppT ConT ConT alright
02:31:43 <saurabhnanda> although I'm confused about *when* the QQ is going to get evaluated.
02:32:20 <saurabhnanda> it might get evaluated *before* the stuff that its referencing has been spliced it, right?
02:32:26 <mrkgnao> compile time? it's TH, so it gets evaluated like TH does
02:32:46 <mrkgnao> oh, well, I'm not sure if pervasive laziness extends to that 
02:33:20 <saurabhnanda> take a look at the gist, might give more context
02:34:20 * hackagebot non-negative 0.1.1.2 – Non-negative numbers – https://hackage.haskell.org/package/non-negative
02:37:30 <mrkgnao> saurabhnanda: try the dumb thing, I'm pretty sure there won't be evaluation order problems. figure out how to inject type synonyms with TH first.
02:38:23 <saurabhnanda> trying now...
02:38:31 <mrkgnao> you'll have the RHS of the tysyn = AppT (AppT (AppT (ConT TempModelPoly) (AppT (ConT PK) (ConT TempModelPoly))) (ConT Text)) (ConT Text), as GHCi will tell you
02:39:01 <mrkgnao> then it's just busywork
02:39:31 <tkeller> I have GHC 8.0.2 installed on Kubuntu 17.04 64. How would you upgrade this to Haskell Platform 8.2.1 most easily?
02:40:35 <phadej> tkeller: https://launchpad.net/~hvr/+archive/ubuntu/ghc
02:42:43 <tkeller> phadej: thx
02:46:00 <tkeller> phadej: I did "add-apt-repository ppa:hvr/ghc" and "apt-get update", but "apt-get upgrade" does nothing...
02:46:41 <phadej> tkeller: it won't, you'd need to apt-get install ghc-8.2.1 cabal-install-2.0
02:47:02 <phadej> tkeller: i.e. the packages in hvr ppa don't interact with system packages
02:47:22 <phadej> so you'll need to add /opt/ghc/8.2.1/bin and /opt/cabal/2.0/bin to your PATH
02:47:37 <phadej> (or something like that, I don't remember paths by heart :)
02:50:37 * hackagebot dlist-nonempty 0.1.1 – Non-empty difference lists – https://hackage.haskell.org/package/dlist-nonempty
02:50:37 * hackagebot html-entities 1.1.4.1 – A codec library for HTML-escaped text and HTML-entities – https://hackage.haskell.org/package/html-entities
02:52:12 <tkeller> phadej: Thanks, I will try this. Do I have to uninstall haskell-platform 8.0.2 in advance?
03:02:56 <phadej> tkeller: not necessarily
03:03:09 <danilo2> Hello guys! We can easily create Storable instance for custom data type and keep it in Storable Vector, however, Sotrable Vectors are slower than Unboxed ones, because they involve one additional indirection (pointer). Is it possible to create unboxed structures and keep them in unboxed vectors just like we do with sotrales?
03:03:48 <danilo2> The Data.Vector docuemnation shows something very similar for tuples, however it sotres them as **2** separate vectors. I want to store the elements as one vecotr element and not as set of vectors per component
03:09:22 <tsmish> Why do functions start with lowercase, and data constructors start with uppercase? I'm looking for motivation of that choice.
03:09:41 <MarcelineVQ> So you can tell what role the identifier has at a glance
03:10:05 <MarcelineVQ> Or at least, you can tell which level they're working at, type or term/value
03:10:05 <danilo2> tsmish: you have to discover in pattern matches what you mean. there is now difference between case x of a -> ...   and case x of A -> ... 
03:10:43 <cocreature> I wonder how DH will handle the currently distinct namespaces
03:10:45 <MarcelineVQ> Oop, that's wrong of me to say, ignore that last line
03:11:44 <tsmish> danilo2: I think you can't store boxed tuples in unboxed vectors.
03:11:59 <tsmish> danilo2: thanks
03:12:20 <danilo2> tsmish: I want everything to be unboxed, so this doesnt affect my question I think
03:12:27 <danilo2> tsmish: youre welcome :)
03:12:34 <cocreature> danilo2: what you can do is write a Prim instance https://hackage.haskell.org/package/primitive-0.6.2.0/docs/Data-Primitive-Types.html#t:Prim but that’s really annoying
03:13:11 <danilo2> cocreature: ah I was thinking about it just now! Hmm, are there any tools to automate this process? 
03:13:19 <cocreature> danilo2: not sure tbh
03:13:49 <danilo2> cocreature: I understand that Prim instance / Storable instance would just operate on "raw" C memory and would work in **the same** performance as accessing a field from C struct?
03:14:17 <danilo2> cocreature: I'm just looking for a way to use Haskell in a code that normally would require C, but I'd prefer to stick with HS
03:16:04 <cocreature> danilo2: at least somewhat comparable performance. the details depend on a lot of factors and only benchmarks will help you with that.
03:16:36 <cocreature> danilo2: note that a pair of vectors might not be so bad and in some cases even better (e.g. if you only access one part of the pair you get better cache locality)
03:17:02 <cocreature> so before you start trying to go through the mess that is writing Prim instances, check if you can’t get the required performance in an easier way
03:17:49 <danilo2> cocreature: Right, in such cases yes. I'm sorry I did not write full requirements here - I will always access every element, but I will often copy whole structures to new locations , so copying 20 vectors would be much worse than copying one
03:18:14 <cocreature> I’m not even entirely sure if you can write custom Prim instances without going through gross hacks. the existing ones seem to rely on primops provided by ghc
03:18:19 <danilo2> cocreature: I will do many benchmarks, thats for sure. Before I do it however, I like "feel" whats going on, thank you so much for explaining the things! :)
03:19:13 <danilo2> cocreature: one more thing - just theoretically. If we've got unboxed / storble vector - it contains many fields of a struct. If we need a special case and want to acces just onefiled - can we do it using some array magic ?
03:19:21 <danilo2> (just like in C)
03:20:20 <cocreature> danilo2: also I’m not sure I agree that copying 20 vectors is “much worse” than copying a single one. at the end of the day you are copying more or less the same amount of memory and if your vectors are sufficiently large cache locality shouldn’t be much worse (although that might not hold for the standard copy operations)
03:21:39 <cocreature> danilo2: if you have a Storable array you can use peekByteOff to read at an offset. not sure if there is something for unboxed (given that there are no Prim instances for composite types, probably not but that doesn’t mean you can’t write it in some terrible way)
03:21:51 <danilo2> cocreature: I didn't thought about cache locality, hmm I will benchmark it definitely, maybe it is the way to go then. In fact (if understand correctly), accessing struct fields from single vector would be as fast as accessign these fields from different vecotrs (if we've got no pointer indirection), right 
03:21:55 <danilo2> ? :)
03:23:23 <cocreature> danilo2: it depends™. accessing contiguous memory will usually be faster so a single vector will probably win if you access each full struct sequentially. how big the difference is is again something that only benchmarks can tell ;)
03:23:41 <danilo2> cocreature: cool to know that it would be possible if I really need it. I'll start with unboxed vectors then and check how it behaves. 
03:24:16 <danilo2> cocreature: thank you so much! I really appreciate it. I'm going to benchmark evrything now. Thanks again!
03:26:24 <cocreature> danilo2: a storable vector is definitely going to be more pleasant to use than writing custom Prim instances so I would probably try doing that if a pair of unboxed vectors doesn’t cut it
03:27:24 * hackagebot aeson-flowtyped 0.8.0 – Create Flow type definitions from Haskell data types. – https://hackage.haskell.org/package/aeson-flowtyped
03:27:29 <danilo2> cocreature: I would definitely follow this approach. I dont think one more indirection (this pointer) would make such difference to me. It is however goot to know that if I need it, I can make it closer to metal. 
03:28:25 <cocreature> danilo2: the problem is that at some point writing Haskell like you would write C is not significantly more pleasant or safer than writing C so just using the FFI for the parts where performance is critical might be a better alternative ;)
03:31:17 <danilo2> cocreature: sure, even if it would be as unsafe and as unpleasant I still prefer haskell's syntax ;)
03:32:01 <danilo2> cocreature: moreover I strongly belive in Haskell as a tool for both high level and low level stuff. I even prefer to write some automation tools / TH to generate stuff than fallback to C, becaus Haskell would be "better" in these fields then
03:32:33 <danilo2> cocreature: one improtant thing for me to know is only if I always will be possible to operate in Haskell on raw memory just like in C and it seems definitely possible
03:42:23 <ddk> hello all !!
03:43:46 <boj> greetings
03:44:17 <hexagoxel> danilo2: the cool kids fall back to rust :)
03:44:56 <danilo2> hexagoxel: I'd prefer not to ;)
03:46:35 <tsahyt> inline-rust would be awesome though
03:52:40 <Xion_> I wouldn't mind a Rust-Haskell FFI that automatically translates between analogous concepts, like traits and typeclasses.
03:53:18 <hexagoxel> both hs and rs have their own memory management, so you need marshalling on both sides. and rustc does not produce per-file object files that you could directly link from hs, afair.
03:54:03 <Xion_> You could make very very granular crates.
03:54:10 <tsahyt> rust doesn't so much have memory management as it has a strong concept of ownership
03:54:18 <tsahyt> but yes you'd need some marshalling I think
03:54:38 <tsahyt> although not more than you do when working with C FFI
03:55:27 <tsahyt> but on the upside you get a saner (safer) language to drop down to when you need to optimize something beyond what you can achieve in Haskell. without unreasonable amounts of pain that is.
03:59:24 * hexagoxel has written an ugly binding generator for haskell<->rust that includes marshalling of simple ADTs
04:00:54 <hexagoxel> not entirely sure if "binding generator" is the right name.. i generate stuff from a language-agnostic interface description.
04:23:50 * hackagebot chatwork 0.1.1.1 – The ChatWork API in Haskell – https://hackage.haskell.org/package/chatwork
04:33:21 <hexagoxel> danilo2: do storablevectors really have additional indirection? or do you mean the overhead of peeking?
04:33:55 <danilo2> hexagoxel: storablevectors have a pointer to the vector and not address to the memory, so yeah, you have to go via the pointer to access the elements
04:34:26 * frerich thinks using quasi quoters when pattern matching is a terribly underrated feature
04:34:40 <danilo2> frerich: why ?
04:36:07 <frerich> danilo2: I typically only see QQs for 'mundane' tasks like constructing an AST or so, but everytime I see them used to deconstruct a value I think "Hey, that's neat!" :-)
04:36:59 <danilo2> frerich: Yeah I understood that idea, however I never found them powerfull in pattern mathcing context. Do you have any example?
04:38:13 <cocreature> seems like pattern synonyms are a better choice for that in most cases
04:38:23 <frerich> danilo2: I think the peephole optimiser which rewrites assembler code is a nice example, it's in the early sections of the ' Why It's Nice to be Quoted: Quasiquoting for Haskell' paper. The eval' function in https://wiki.haskell.org/Quasiquotation#Examples is neat, too
04:39:23 <danilo2> frerich: hmm, when trying to open "Why It's Nice ... .pdf" I get permission denied fro mthe server
04:39:39 <frerich> danilo2: The latter example is not so convincing because the expressions are simple, I think the optimiser example in the pattern is a better example since constructing the AST manually (even when using some combinator functions) would be a lot more cumbersome.
04:39:41 <danilo2> frerich: just fyi. Ill find it somewhere
04:40:40 <danilo2> frerich: heh, just to explain, the https://wiki.haskell.org/Quasiquotation#Examples  has link to the paper, but the link is broken :) I've got the paper and reading it now, brb 
04:40:45 <frerich> danilo2: I also like the QQ-based examples since they let me 'think' in the EDSL.
04:41:17 <frerich> danilo2: Maybe a good moment to update the Wiki such that it links to a different location :-) 
04:41:29 <danilo2> yeah, definitely
04:41:33 <danilo2> ill do it
04:41:49 <danilo2> but firstly I need to understand QQ in the place of pattern matches
04:42:32 <frerich> For the record, I just had to search a bit myself but found a copy at http://www.cs.tufts.edu/comp/150PLD/Papers/QuasiQuotation.pdf
04:44:00 <danilo2> frerich: ok, I',m convinced, they are cool and even they are super usefull in one place in a code I've got here. They are much better thing than what we currently use
04:44:05 <danilo2> thank you!
04:45:23 <danilo2> frerich: oh I dont have wiki account
04:45:33 <danilo2> frerich: I will create one, but if youve got one could you change it ?
04:45:40 <danilo2> (to create one you have to send mail ...)
04:45:48 <frerich> danilo2: Sure, let me do it.
04:47:25 <frerich> danilo2: Done.
04:52:50 <danilo2> frerich: thanks! :)
05:14:03 <danilo2> hexagoxel: do my explanation of the indirection is clear? Im asking because I could be wrong here and I prefer to be clear about it :)
05:17:01 <petrus> hi, I am having problems with stack. I can build my program using cabal with no problems, but using stack it dies with immediately with ld error.
05:18:51 <petrus> I am on archlinux, resolver=lts-9.0, stack 1.5.0, cabal 1.24.0.2, ghc 8.02
05:20:49 <petrus> I want (need) to create a dynamically linked executable.
05:21:45 <merijn> petrus: I don't know how it affects stack, but arch broke GHC rather drastically in their setup
05:22:07 <petrus> the error message: ....stack/setup-exe-cache/x86_64-linux/tmp-Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2 ...
05:22:26 <petrus> /usr/bin/ld: cannot find -lHSCabal-1.24.2.0 ...
05:23:28 <petrus> merijn, well the arch haskell env is unusual in having shared libs only, still
05:23:46 <cocreature> disable system-ghc and stack should work or at least fail with a different error
05:23:58 <merijn> petrus: Thus requiring everything using haskell to install the entire compiler toolchain and breaking like half the things out there
05:24:02 <petrus> no reason, for example, not pass ghc flags to the process.
05:24:30 <merijn> petrus: I don't use arch or stack, but my advice would be "get rid of Arch' GHC and replace it with a sane version"
05:24:46 <merijn> Also, yell at the Arch GHC maintainer to stop doing stupid shit
05:25:24 <petrus> merijn, I am not convinced that the arch setup is stupid.
05:25:27 <cocreature> at this point, I have lost all hope that they’ll stop doing that
05:25:48 <cocreature> switching to dynamic linking without changing the default of GHC is definitely stupid
05:26:06 <petrus> also, currently it is impossible to build ghc with stack
05:26:12 <cocreature> you could argue that switching to dynamic linking itself is not but doing it halfway is stupid
05:26:30 <petrus> cocreature, what do you mean by "without changing the default"?
05:26:42 <petrus> cabal works fine, so the setup is workable
05:27:04 <cocreature> ghc by default will link statically even on arch which breaks things in weird situations
05:27:15 <merijn> petrus: Except it doesn't work fine, because I've seen 20 people come in here in the past 1.5 weeks going "huh, my haskell install is breaking with cryptic errors?!"
05:27:20 <cocreature> maybe they started patching cabal but two weeks ago or so it was completely broken by default
05:27:29 <merijn> petrus: And the answer is always "you're on Arch, huh?"
05:27:46 <cocreature> merijn: I’ve considered writing a bot for that
05:28:04 <merijn> petrus: If your OS is literally the only one prompting dozens of people to come here with confused errors, maybe the way you're doing things is dumb since it works literally everywhere else without issue
05:28:09 <hexagoxel> danilo2: no, i am not certain what you mean, everything seems to be UNPACKed.
05:28:26 <petrus> cocreature, you give the flag -dynamic, and cabal, stack should do what you are asking for, except stack does not.
05:28:48 <cocreature> petrus: that’s exactly my point, you need to add a flag because the default is broken
05:28:52 <cocreature> and breaking the default is just stupid
05:28:56 <yushyin> this is because people are using repo packages for dev stuff, which is stupid!
05:29:09 <cocreature> if you are going to switch dynamic linking at least enable -dynamic by default
05:29:24 <merijn> yushyin: Well, it's also dumb from an end-user perspective, since installing pandoc now requires installing like 100 dependencies
05:30:04 <yushyin> well yes, because ghc ecosystem is not meant to be dynamic, because it’s stupid
05:30:57 <petrus> guys, I'd would prefer to find a solution instead of bitching about arch, or why using shared libs is stupid.
05:31:30 <merijn> petrus: You have three options: 1) stop using Arch GHC, 2) stop using stack, 3) fix stack
05:31:42 <merijn> petrus: Or, I suppose, 4) pay someone else to fix stack for you
05:31:49 <cocreature> petrus: have you tried disabling system-ghc?
05:32:17 <yushyin> petrus: I let stack handle all dev stuff including ghc
05:32:28 <yushyin> does also work
05:32:38 <petrus> as I already said currently stack cannot build the recent ghc.
05:33:09 <cocreature> I’m not sure what you’re referring to. stack doesn’t build ghc it just downloads binaries
05:33:28 <petrus> that is a bug of stack/ghc/whatever theb bug number escapes me right now
05:34:22 <merijn> petrus: I'm not sure what you expect us to do about this?
05:35:15 <petrus> since the system tools working with cabal, it is reasonable that there is something wrong with how stack manages passe ghc flags
05:35:17 <merijn> "This combination of things doesn't work"
05:35:20 <merijn> "you're right"
05:35:35 <cocreature> petrus: you still haven’t answered my question. have you tried disabling system-ghc?
05:35:46 <merijn> petrus: If it was that easy, stack would've been patched already
05:36:21 <merijn> But I don't think there's a force on earth that can convince Arch users to just use a less bleeding edge version of something, so I'll get back to writing :)
05:43:40 <Enamex> Are the logs at the link delayed or have they stopped working?
05:44:05 <cocreature> Enamex: the tunes.org link should still be working. ircbrowse is dead
05:44:29 <merijn> cocreature: The death of ircbrowse makes me really sad, it was such a cool site :\
05:44:49 <mauke> if it's dead, why is it still in the topic?
05:45:00 <cocreature> because nobody has removed it?
05:45:17 <cocreature> merijn: the source is on github, so you just need to host and maintain it yourself :P
05:45:25 <merijn> cocreature: I don't know what broke, though
05:45:33 --- mode: ChanServ set +o mauke
05:45:33 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017' by mauke
05:45:39 <cocreature> thanks mauke
05:46:33 <Enamex> cocreature: the site itself is still up though so it's hosted :/ Sad
05:47:23 <cocreature> chris got busy with other stuff and I think he also said he’s reducing his open source activities due to rsi
05:47:33 --- mode: mauke set -o mauke
05:48:28 <hexagoxel> danilo2: I'd really have to look at core to test my understanding (the vector source code contains way too many .. indirections :), but i think the addr# in ForeignPtr is unpacked; so the only source of indirection could be at the outermost level, but that would be the same for Storable and Unboxed.
05:48:37 <Enamex> RSI?
05:48:48 <[exa]> typing too much
05:49:13 <merijn> [exa]: And/or insufficient workout or ergonomics
05:50:13 * hackagebot gi-atk 2.0.14, gi-cairo 1.0.14, gi-gdk 3.0.14, gi-gdkpixbuf 2.0.14, … and 25 more
05:50:13 * hackagebot  → https://hackage.haskell.org/packages/recent
05:50:53 <cocreature> I haven’t yet figured out when hackagebot tweets the link to the recent page
05:51:24 <mauke> I'd assume when there's too many uploads and the "and N more" text appears
05:51:27 <MarcelineVQ> when there's more than 2 items I think
05:51:42 <cocreature> ah makes sense
05:52:22 <merijn> cocreature: It's amazonka mitigation :p
05:53:13 <cocreature> merijn: I still have a filter in my irc client from back when hackagebot would just spam in that case ;)
05:53:24 <merijn> Because the main reason hackagebot was taken offline for a while was amazonka and similar packages triggering spam due to their maintainers updating versions on like 20 packages at the same time
06:00:19 <danilo2> hexagoxel: If I understand correctly Unboxed could not have this indirection, do they? They can just keep the memory address of the vector, or couldnt they?
06:05:41 <tabaqui> hey all
06:06:02 <tabaqui> I got a new archbug
06:06:14 <tabaqui> while building network package
06:06:32 <tabaqui> "configure: error: cannot run C compiled programs."
06:07:15 <tabaqui> dunno, I have updated full system recently, but I don't use any haskell packages from arch repos
06:08:28 <tabaqui> uhm, hello
06:08:37 <tabaqui> can anyone help, please?
06:08:47 <mauke> with what?
06:08:52 <cocreature> tabaqui: never seen anything like that, are you using cabal or stack?
06:09:00 <tabaqui> cocreature: stack only
06:09:23 <tabaqui> wait a sec, I'll paste the log
06:09:30 <cocreature> tabaqui: google suggests that you might not have glibc installed, can you check that?
06:09:42 <cocreature> how you end up without glibc is a mystery to me but well …
06:09:51 <tabaqui> yaourt -Qi glibc
06:09:52 <mauke> how would anything run then?
06:09:53 <tabaqui> Name            : glibc
06:09:55 <tabaqui> Version         : 2.25-7
06:10:16 <cocreature> tabaqui: maybe try reinstalling? maybe it’s somehow corrupted
06:10:24 <cocreature> reinstalling glibc that is, not everything
06:10:27 <mauke> wtf
06:10:35 <cocreature> mauke: well “cannot run C compiled programs” doesn’t sound like a lot is running :)
06:10:37 <tabaqui> https://pastebin.com/c7JgVqN3
06:10:40 <Ferdirand> i've seen that already. If i remember correctly, it can also happen if gcc is broken
06:10:41 <tabaqui> reinstall
06:10:49 <mauke> cocreature: yes, it does
06:10:51 <tabaqui> hmm, I just "stack update && stack upgrade"
06:10:55 <tabaqui> it worked well
06:10:56 <mauke> e.g. gcc itself is running
06:11:08 <tabaqui> I'll try reinstall gcc
06:11:25 <hexagoxel> danilo2: which indirection? lets take Vector Float. Unboxed allocates Vec<Float#> of length n, and Storable allocates Vec<u8> of length (n * sizeof Float), which is the same really.
06:11:38 <hexagoxel> sorry for mixing in rust syntax..
06:13:49 <danilo2> hexagoxel: rust syntax is ok here :) According to ddocs "Memory addresses are represented as values of type Ptr a", but I have to check it myself what it really means in comparison to unboxed vectors. Moreover I've read on github's Vector bucktracker some discussion about Storable vectors being lsower than unboxed
06:22:14 <hexagoxel> danilo2: i still don't see where _indirection_ would come from; and difference in performance could be caused by other things.
06:25:03 <tsmish> tabaqui: Have you, by any chance, installed libtinfo? I saw tinfo in stack output.
06:25:45 <tabaqui> yaourt -Qi libtinfo 
06:25:47 <tabaqui> Name            : libtinfo
06:25:49 <tabaqui> Version         : 6-24
06:26:02 <tabaqui> hmm, it was updated today
06:27:00 <bvad> tabaqui: do you have ncurses5-compat-libs installed?
06:27:24 <tabaqui> yaourt -Qi ncurses5-compat-libs 
06:27:26 <tabaqui> Name            : ncurses5-compat-libs
06:27:28 <tabaqui> Version         : 6.0-1
06:27:32 <tabaqui> It works just in friday
06:27:55 <cocreature> that reminds me, I need to bug them to merge my PR so that we can avoid having to mess with libtinfo and ncurses5-compat-libs
06:28:02 <tabaqui> I break my stack after each update, but reinstalling usually helps
06:28:22 <tabaqui> well
06:28:23 <bvad> cocreature: link?
06:28:27 <tabaqui> something happend
06:28:50 <tabaqui> I install libtinfo5 agains previous libtinfo
06:28:52 <tabaqui> and it helps
06:29:19 <cocreature> bvad: https://github.com/commercialhaskell/stack/issues/3268 is the issue about things being broken and https://github.com/fpco/stackage-content/pull/26 should hopefully fix it (by providing a GHC bindist build on arch)
06:29:25 <tabaqui> looks like libtinfo6 doesn't work with stack
06:30:11 <bvad> I guess that's a permanent fix, nice work
06:30:30 <bvad> Fighting arch maintainers is an uphill battle.. 
06:31:13 <tabaqui> ah, it is fine
06:31:24 <cocreature> in this case it’s really not the fault of the maintainers. they just updated some things and stack hasn’t updated their bindists
06:31:37 <tabaqui> I didn't install arch if was not ready for all such troubles
06:31:44 <tabaqui> anyway, thanks to all
06:32:01 <bvad> This is just stupid though.. 
06:33:34 * hackagebot singletons 2.3.1 – A framework for generating singleton types – https://hackage.haskell.org/package/singletons
06:36:31 <tabaqui> oh, you are working in llvm project
06:37:10 <tabaqui> I thought it was suspended
06:37:20 <cocreature> you mean llvm-hs?
06:37:25 <tabaqui> yes
06:37:41 <tabaqui> *brb
06:37:57 <cocreature> I let stephen diehl trick me into forking llvm-general and then I tricked him into becoming a maintainer
06:41:26 <quchen> cocreature: Teach me how to tame Stephen! Doesn’t have to be him specifically, I’d take a Herbert or Ben or Austin as well
06:42:03 <quchen> cocreature: BTW, Freiburg this weekend?
06:42:12 <cocreature> quchen: no I sadly don’t have time
06:42:33 <quchen> To tame Herbert for me? That’s okay. What about Freiburg though?
06:42:44 <cocreature> heh I was talking about Freiburg :)
06:43:05 <quchen> Too bad! (You now owe me one Herbert though.)
06:43:16 <quchen> Isn’t Karlsruhe just around the corner?
06:43:21 <quchen> You could stop by on your bicycle
06:43:51 <cocreature> it’s 7h by bicycle according to google maps :)
06:44:23 <raynold> ahh it's a wonderful day
06:44:39 <quchen> cocreature: My train ride is around 5 hours as well
06:44:44 <quchen> 7 hours isn’t so bad!
06:44:55 <quchen> You’re not easily convinced it seems like.
06:45:18 <cocreature> quchen: the trick with taming stephen is to just add him as a maintainer and hope that when he notices that he feels too bad to quit
06:45:51 <frerich> Flensb... oh.
06:48:58 <cocreature> quchen: although the next step seems to be that he tricks you into grabbing a beer with someone working at his startup who tries to trick you into working for them so I’m not sure I’ve really mastered the art of taming him
06:50:24 <merijn> cocreature: Well...are they paying for the beer?
06:50:52 <cocreature> merijn: yeah :)
06:51:08 <merijn> cocreature: Sounds like a win to me :p
06:52:06 <quchen> Does Stephen’s company exist already?
06:52:14 <cocreature> yeah http://adjoint.io/
06:52:16 <quchen> I thought he was just about to bootstrap something
06:52:24 <cocreature> it has existed for a year or so
06:52:39 <cocreature> and they just got funding
07:02:01 <quchen> Interesting.
07:06:58 * hackagebot fastparser 0.3.0.1 – A fast, but bare bones, bytestring parser combinators library. – https://hackage.haskell.org/package/fastparser
07:13:29 <Yuuri> Hello! Does anyone have a free place in a team for the upcoming ICFPC?
07:19:12 <phz_> hey peeps
07:19:21 <phz_> what is de factor package for XML reading and writing?
07:19:24 <phz_> xml?
07:19:38 <phz_> it hasn’t been updated for more than two years
07:19:56 <phz_> oh, xht maybe
07:20:59 <merijn> phz_: Depends on the kinda XML you're reading?
07:21:10 <merijn> phz_: Rigidly defined schema or messy scraped data
07:21:37 <phz_> merijn: is there a real difference? :–––’) :troll:
07:22:22 <merijn> phz_: There really is, because there's really fancy parsers that read in schema's and validate the XML you parse
07:22:43 <phz_> well, short answer is: I don’t have a schema
07:22:47 <phz_> I just want something like aeson
07:22:51 <phz_> a way to traverse an XML tree
07:22:55 <phz_> that should be sufficient
07:23:00 <merijn> phz_: Have a look at xml-conduit then
07:23:20 <phz_> why conduit?
07:24:10 <merijn> phz_: The interface isn't very conduity, it's mostly just abstract tree traversals, it just happens to be written for/by people using conduit, so it exports some tools for working with that
07:24:42 <merijn> phz_: The advantage is that it is really easy to do streaming parsing of huge XML files or to tie it to http-conduit for stuff you're grabbing from the web
07:25:03 <phz_> I see, interesting
07:25:04 <phz_> thanks
07:25:10 <phz_> and what about hxt, then?
07:25:22 <merijn> phz_: I've looked at it, but christ the API looks complicated
07:25:29 <phz_> ah
07:25:50 <merijn> phz_: For reference, here's a simple (by now bitrotted due to changes in async) scraper I wrote: https://gist.github.com/merijn/d8188ddd129718ffcfb0
07:26:16 <merijn> phz_: 4 lines to grab the source URL from a webcomic page
07:26:41 <merijn> phz_: (html-conduit is roughly the same as xml-conduit)
07:27:02 <phz_> yeah I know html-conduit :)
07:27:04 <phz_> we use it in production
07:27:12 <phz_> so I guess I can have a look at xml-conduit then
07:27:13 <phz_> thanks!
07:28:15 * hackagebot plot-light 0.2.5 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
07:33:50 <danilo2> hi! :) I'm trying to use Foreign.CStorable on datatypes with 2 constructors but it fails. Are there any tools allowing us to generate storable instances for multi constructor datatypes?
07:49:32 * hackagebot ekg-core 0.1.1.2, universum 0.5.1, ekg-json 0.1.0.6, ekg-statsd 0.2.1.1
07:49:32 * hackagebot  → https://hackage.haskell.org/packages/recent
07:54:36 * hackagebot ekg 0.4.0.14 – Remote monitoring of processes – https://hackage.haskell.org/package/ekg
08:01:42 <phz_> merijn: meh
08:01:46 <phz_> the readFile function is IO Document
08:01:52 <phz_> what happens if the document is misformed?
08:02:53 * hackagebot plot-light 0.2.6 – A lightweight plotting library, exporting to SVG – https://hackage.haskell.org/package/plot-light
08:04:09 <c_wraith> danilo2: the question doesn't make a lot of sense.  Storable is an interface for saying "this type is the Haskell representation of a C type".  C types don't have multiple constructors.
08:04:50 <merijn> c_wraith: I disagree
08:05:04 <merijn> c_wraith: Storable can just as easily be "this is the C represenstation of a Haskell type"
08:05:23 <merijn> c_wraith: For example, mapping it to a tagged union
08:05:48 <Cale> Yeah, and it's possible that on the C side of things you have a tagged union as well
08:06:06 <c_wraith> merijn: that's far from "just as easily".  I have used Storable.
08:06:52 <merijn> c_wraith: By just as easily I'm referring to the ease of interpretation, not ease of implementation
08:07:18 <merijn> c_wraith: There's no reason to privilege the "Haskell representation of C data" over the "C representation of Haskell" view
08:07:46 <merijn> c_wraith: Not to mention, even if you DID assume it was only the former, your C data might *still* be a tagged union that you want to map to a sum type in Haskell
08:08:07 <oo_miguel> can i somehow make sure that a process i started from haskell is terminated on exit of my main?
08:08:22 <JuanDaugherty> no
08:08:36 <merijn> oo_miguel: Well, depends on how sure you wanna be
08:08:40 <cocreature> oo_miguel: use async and waitAnyCancel
08:08:48 <DBHaskell> Hi guys... I am working on a codebase hosted at github.com/databrary/databrary .... It is cabal based. Our front end developer is trying to run it with LIVERELOAD... so when she makes front end changes to angular, they take place instantly... however, at this time, we have to stop the app, do the repacking, restart and even then it takes 5 minutes to show
08:08:48 <merijn> oo_miguel: Can you be "mostly sure"? Sure. 100% sure? no
08:08:58 <DBHaskell> any help would be greatly appreciated...
08:08:58 <oo_miguel> mostly sure
08:09:02 <merijn> oo_miguel: Consider what happens if your Haskell process gets SIGKILLed
08:09:47 <merijn> oo_miguel: Then you can use, e.g. waitAnyCancel from async like cocreature suggests, or, if that doesn't work maintain a collection of running process handles in an MVar and have main kill all of them before exiting
08:09:57 <DBHaskell> i hope its a simple thing
08:10:15 <oo_miguel> merijn: allright ill give it a try. thank you
08:10:28 <oo_miguel> cocreature: thank you too :)
08:10:38 <danilo2> c_wraith: ah right! However I want to keep my structures in Storable or Unboxed vectors for higher performance, so I need to create such Storable instances, right ?
08:10:46 <MarcelineVQ> is databrary part of some classroom project? it seems to be coming up a lot around here lately
08:11:10 <DBHaskell> its a live service being run for developmental scientists...
08:11:15 <DBHaskell> at NYU and beyong
08:11:21 <DBHaskell> nyu.databrary.org :)
08:11:44 <DBHaskell> unfortunately we lost the developer without alot of documentation...
08:11:44 <danilo2> merijn, c_wraith : I understand we can treat Storable also not as a C binding but asefficient haskell datatypes storing utility in Storable vectors, right ?
08:12:11 <merijn> danilo2: Storable is just a convenient wrapper to "peeking/poking pointers to opaque bytes in memory"
08:12:19 <c_wraith> danilo2: I'm not sure Storable vectors are efficient for use only from haskell.  You need to constantly peek and poke to use them.
08:13:06 <danilo2> c_wraith: hmm, so what should I use if I want to store in Storable / Unboxed  Vectors / Arrays my custom datatype with all fields unpacked but many constructors?
08:13:40 <DBHaskell> we have sort of a freeze on the back end development
08:13:49 <DBHaskell> but would love for the front end in angular to move forth...
08:13:59 <merijn> c_wraith: Actually, it works fairly well
08:14:13 <DBHaskell> however, the developer is unable to LIVERELOAD and that cycle has been very painstaking
08:14:20 <merijn> c_wraith: I'm doing exactly this because I need densely packed structs inside Haskell
08:14:27 <[exa]> Anyone knowledgeable in linear types? I'm searching for any research on composing the linearity with monads (esp. what should >>= do with linear values to behave sanely)
08:14:40 <c_wraith> merijn: and it benchmarks well?
08:15:02 <danilo2> merijn, c_wraith : is there any more performant way to keep in vectoers densly packed structs with all fields unpacked and make HS as close to metal as possible ?
08:15:18 <c_wraith> [exa]: there was just a blog post on that topic that got a bunch of traction.  Did you see it?
08:15:24 <merijn> c_wraith: So I have a ByteString which I convert to a Storable Vector that I have a tight loop over. It's slower than the straight C version, but not dramatically so
08:15:33 <DBHaskell> MarcelineVQ: would you know if this is a simple thing that we are doing wrong?
08:15:34 <[exa]> c_wraith: probably not, can you recall the name?
08:15:42 <merijn> c_wraith: Small enough that the overhead of my SQL loop reduces the overhead compared to C to noise
08:15:48 <MarcelineVQ> DBHaskell: Don't know a thing about it sorry
08:15:49 <shapr> DBHaskell: I remember you... you inherited what sounds like a depressing codebase
08:15:52 <c_wraith> merijn: oh.  for a primitive type, sure.  I was thinking about for compound types.
08:16:18 <DBHaskell> shapr: ha... that was my back end developer... it seems it was too depressing for him and so he moved on :)
08:16:33 <shapr> oh, in that case I remember that person.
08:16:42 <merijn> c_wraith: Ah, no. For me, it's a struct of 2 ints and 2 doubles. And I (ab)use the struct-ness in C to get better cache locality, I needed to do the same in Haskell
08:16:52 <c_wraith> [exa]: https://m0ar.github.io/safe-streaming/2017/07/20/homegrown-linear-monads.html
08:16:54 <shapr> I was curious how that was going to go
08:17:06 <DBHaskell> shapr: we are trying to make do in the mean time... but this one thing about how to repack without reloading has us stuck
08:17:06 <merijn> c_wraith: And there's no real way to get the same cache locality effect with native Haskell types/vectors
08:17:17 <DBHaskell> shapr: its still running if thats what you are asking :)
08:17:39 <shapr> Your former backend developer .. seemed to have ideological differences when it came to Haskell
08:17:57 <merijn> c_wraith: But if you have a better idea to accomplish that, I'm all ears :p
08:17:57 <shapr> but it also sounded like the codebase was not in the best shape.
08:18:11 <DBHaskell> shapr: human nature is to detest something we dont understand :)
08:18:15 <shapr> true that
08:18:21 <shapr> congnitive dissonance is hard
08:18:26 <DBHaskell> shapr: i'd say lack of documentation didnt help.. .despite the self documenting mantra
08:18:28 <merijn> c_wraith: Added benefit of this way is that I can simply store the vector as a bytestring in the database making it trivial to load :)
08:18:42 <danilo2> c_wraith, merijn : I've got here even funnier example. I've got a compound type C = CA !Int !Int | CB !Int. But I also have data A = A !Int !Int and data B = B !Int. Sometimes I know the type (if it is A or B) and then I want just to read it form Vector to this type. Sometimes I do not and then I want to read it to C. What would be the absolutely most performant way to store it in Hs Arraylike struct?
08:19:09 <shapr> I've seen self documenting code, but if someone *tells* me their code is self-documenting, I hear "I have no documentation because I already understand the code".
08:19:19 <[exa]> c_wraith: interesting practical read, thanks :]
08:19:35 <c_wraith> [exa]: doesn't answer your question really, but it's at least related.
08:19:41 <DBHaskell> shapr: ha true true... but can others? :)
08:19:52 <shapr> sometimes?
08:20:18 <DBHaskell> shapr: sigh I wish this was that sometime
08:20:20 <[exa]> c_wraith: in fact it seems that his approach is obsoleted by one last year's ICFP paper, but at least it's normal haskell
08:20:34 <[exa]> if "normal" allows lollipops
08:20:49 <shapr> DBHaskell: I understand that. I looked through databrary shortly when your previous backend dev visited, it looked challenging.
08:21:36 <c_wraith> [exa]: funny definition of "normal" you've got there. :)
08:21:53 <butterthebuddha> Trying to use foldr to fold a list into num of trues in a list of booleans
08:22:03 <shapr> DBHaskell: so why do you have to stop the app when the front end changes?
08:22:07 <DBHaskell> shapr: thanks for validating... hopefully a way out exists
08:23:00 <[exa]> butterthebuddha: why not foldl?
08:23:11 <butterthebuddha> I mean it doesn't matter?
08:23:17 <shapr> DBHaskell: have you considered checking the rates of the consultants at http://www.well-typed.com/ ? They're some of the best Haskell coders I've seen.
08:23:22 <DBHaskell> shapr: there is some manual webpacking that takes place... so the front end person in her development environment... when she makes the change... she wants to see it get reflected immediately... in her dev environment... however it doesnt... you have to stop the app... do a repacking... and restart it again... and even then it takes 5 minutes to show..
08:23:34 <[exa]> butterthebuddha: usually not, it matters for small things probably unrelated to your result :]
08:23:35 <DBHaskell> shapr: yeah i spoke with them recently...
08:23:40 <shapr> DBHaskell: how did that go?
08:24:01 <DBHaskell> shapr: good good... but we havent finalized anything... academic institutions as you know are slow to proceed
08:24:08 <DBHaskell> do you work for them ;)
08:24:09 <DBHaskell> ?
08:24:21 <shapr> I don't work for well-typed, but I know several of them personally.
08:24:31 <DBHaskell> they seem sharp
08:24:48 <shapr> Also, I escaped academia with a degree not too long ago, I remember the lack of agility.
08:25:03 <DBHaskell> you escaped well in time :)
08:25:13 <shapr> yeah, still paying off the mortgage on my brain
08:25:19 <DBHaskell> https://github.com/databrary/databrary/blob/master/dev there is a bash script that gets run... that is supposedly there to help
08:25:24 <DBHaskell> but its not doing it;
08:25:28 <DBHaskell> LOL
08:26:28 * hackagebot datasets 0.2.5 – Classical data sets for statistics and machine learning – https://hackage.haskell.org/package/datasets
08:26:28 * hackagebot cabal-rpm 0.11.2 – RPM packaging tool for Haskell Cabal-based packages – https://hackage.haskell.org/package/cabal-rpm
08:27:07 <shapr> DBHaskell: off the top of my head, if you want to quickly recompile Haskell to see changes,  I would 1. throw more hardware at the system  and 2. compile with -O0 (turn off optimizations)
08:27:32 <DBHaskell> ah... lets see if that works :)
08:27:55 <shapr> I still don't understand why changing the javascript frontend requires recompiling the Haskell code though.
08:29:06 <shapr> DBHaskell: My Haskell dev system went from a dual Intel i3 with 16gb of ram to a quad-core Xeon with 64gb of ram, and one of my big compiles went from 45 minutes to 4.5 minutes
08:29:06 <DBHaskell> its not recompiling... its restarting after repacking web assets :)
08:29:15 <DBHaskell> oh nice...
08:29:16 <shapr> it takes five minutes to restart?!
08:29:41 <DBHaskell> no... it starts immediately... but there is some sort of caching happening... that it takes effect after 5 min or so
08:29:47 <DBHaskell> we havent been able to figure it out
08:30:43 <c_wraith> DBHaskell: was the server built using snap, by any chance?
08:31:10 <DBHaskell> c_wraith ... I am not sure to be honest... but I doubt it
08:39:02 <butterthebuddha> http://lpaste.net/357323
08:39:18 <butterthebuddha> I'm rather proud of my map' implementation but is there anyway I can improve my xor implementation?
08:40:19 * hackagebot SSTG 0.1.1.2 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
08:41:34 <glguy> butterthebuddha: There are a couple things you could do differently, but what's the == doing for you in "x == True" ?
08:41:58 <butterthebuddha> I suppose it could just be if x
08:42:05 * butterthebuddha is stupid
08:42:47 <butterthebuddha> I was hoping to clean those if expressions out 
08:43:04 <glguy> butterthebuddha: xor will work better with a foldl' instead of foldr
08:43:27 <butterthebuddha> How does that make a difference though?
08:43:48 <butterthebuddha> Doesn't foldl just go through the list from the last element?
08:44:07 <glguy> No, both foldr and foldl work from the beginning of the list to the end
08:44:10 <c_wraith> both variants of fold start at the first element
08:44:33 <butterthebuddha> Ohh
08:44:38 <butterthebuddha> What's the difference then?
08:44:42 <butterthebuddha> :t foldr
08:44:44 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:44:47 <butterthebuddha> :t foldl
08:44:49 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
08:45:07 <butterthebuddha> Doesn't help very much :/
08:45:41 <sbrg> https://en.wikipedia.org/wiki/Fold_(higher-order_function) the diagrams here may help
08:46:07 <[exa]> butterthebuddha: what about using length and filter instead of fold?
08:46:21 <butterthebuddha> The exercise demands that I use fold
08:46:37 <sbrg> > foldr (+) 0 [1..10] :: Expr
08:46:39 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
08:46:42 <c_wraith> butterthebuddha: the big difference is that foldl is fold-with-an-accumulator.  foldr is "do some processing that involves every element of the list"
08:46:44 <sbrg> > foldl (+) 0 [1..10] :: Expr
08:46:47 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
08:47:22 <[exa]> butterthebuddha: oh so, exercises :D Otherwise you could write it as (length.filter id)
08:50:38 <[exa]> butterthebuddha: anyway, foldL is better for accumulating values -- it doesn't occupy memory with a call stack. FoldR is better if the computation can somehow finish in the middle of the list (the "tail" of the list might not be even touched)
08:51:39 * hackagebot sum-type-boilerplate 0.1.1 – Library for reducing the boilerplate involved with sum types – https://hackage.haskell.org/package/sum-type-boilerplate
08:51:56 <butterthebuddha> Wait why would you not touch the whole list using fold?
08:51:58 <butterthebuddha> Any examples?
08:52:00 <butterthebuddha> Super confused rn
08:52:54 <benzrf> butterthebuddha: for example:
08:53:01 <benzrf> > foldr const 0 [1..]
08:53:03 <lambdabot>  1
08:53:15 <benzrf> > foldl (flip const) 0 [1..]
08:53:23 <lambdabot>  mueval: ExitFailure 1
08:54:05 <benzrf> foldl is almost always the wrong choice anyway, you want foldl' most of the time if you don't want foldr
08:54:34 <butterthebuddha> Hold up, how is foldl different from foldl'?
08:54:38 <c_wraith> When's the proposal to replace foldl with foldl'?
08:54:44 <[exa]> butterthebuddha: foldl' is strict
08:54:53 <butterthebuddha> not lazy?
08:54:55 <[exa]> butterthebuddha: it doesn't build up unevaluated accumulator value
08:55:07 <benzrf> @src foldl
08:55:07 <lambdabot> foldl f z []     = z
08:55:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:55:07 <butterthebuddha> Okay and that matters because?
08:55:08 <benzrf> @src foldl'
08:55:09 <lambdabot> foldl' f a []     = a
08:55:09 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:55:23 <[exa]> ie. in your case, not unnecessarily holding 1+1+1+1+1 when it can reduce it to 5 right away
08:55:36 <[exa]> it saves memory
08:55:42 <butterthebuddha> Oh
08:55:51 <benzrf> well, besides that, it also prevents having a big call stack when you're done
08:55:57 <[exa]> also, foldl is tail-recursive, which also saves memory
08:56:18 <benzrf> tail recursion doesn't necessarily save memory
08:56:22 <benzrf> it depends on how you consume the result
08:57:14 <[exa]> yeah, I was kindof considering the simple case :]
09:00:01 <[exa]> butterthebuddha: anyway, good illustration of why foldr is good is for example elem, it can stop running through the list when it finds the target element
09:13:29 <benzrf> @src elem
09:13:29 <lambdabot> elem x = any (== x)
09:13:32 <benzrf> hmm
09:13:36 <benzrf> @src any
09:13:36 <lambdabot> any p = or . map p
09:13:41 <benzrf> @src or
09:13:42 <lambdabot> or = foldr (||) False
09:13:43 <benzrf> aha
09:13:44 <ab9rf> [exa]: haskell doesn't have a "call stack", so reasoning about efficiency based on arguments related to "call stacks" is likely suspect
09:14:11 <benzrf> ab9rf: first of all, call stacks are operational details, so of course "haskell" doesn't have them
09:14:20 <benzrf> second of all, i thought ghc does use call stacks when forcing
09:14:59 <ab9rf> benzrf: there are call stacks in the implementation, but they don't necessarily correspond in any simple way with source code
09:16:03 <benzrf> yes, it corresponds to forcing thunks
09:16:30 <butterthebuddha> https://www.seas.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
09:16:35 <benzrf> which is what the issue could be with foldr on strict functions
09:16:39 <butterthebuddha> For the last problem, how do I actually get the "n"?
09:16:41 <ab9rf> you get a stack when, in the course of forcing a thunk, it has to force another thunk
09:16:46 <benzrf> yes
09:16:53 <benzrf> and that happens when you use foldr with a strict function
09:16:58 <benzrf> that's what [exa] was talking about
09:17:54 <ab9rf> i'm still having trouble coming up with a good use for foldl :)
09:18:04 <ab9rf> foldl', sure, foldr, sure, not so much foldl
09:18:37 <benzrf> yup
09:19:13 <benzrf> > foldr (+) 0 [1..10000]
09:19:15 <lambdabot>  50005000
09:19:17 <benzrf> hmm
09:19:30 <srhb> Huh, I never knew, re. thunk: "The term originated as a jocular derivative of "think"."
09:19:56 <srhb> And here I thunk it was the sound a thunk made when it got thunk.
09:20:07 <mnoonan> srhb, seems like it should have a future tense instead of a past tense :)
09:20:14 <butterthebuddha> >
09:20:17 <butterthebuddha> >*
09:20:19 <butterthebuddha> ?*
09:20:19 <lambdabot> Maybe you meant: v @ ? .
09:21:20 <JuanDaugherty> who'd a
09:22:00 <moczens> Hey guys, do you know of any way to set a memory limit for GHC when compiling?
09:23:37 <srhb> moczens: you can try giving the RTS heap limiting options, or even using ulimit, but depending on what you're doing, you might just run out of heap and crash.
09:23:51 <srhb> moczens: (What are you actually trying to do?)
09:24:49 <moczens> srhb: I am trying to build a pretty big project (using stack) on a CI server and it imposes a 4GB ram limit
09:25:20 <moczens> and crashes with an OOM error
09:25:31 <srhb> moczens: GHC or the CI instance?
09:25:38 <srhb> (Or stack, I suppose)
09:27:01 <SepakoRayl> When are catamorphisms/f-algebras useful ?
09:27:34 <moczens> srhb: CI is the one that kills the process for exceeding 4GB, stack/ghc works fine locally (albeit indeed taking up more than 4GB of memory)
09:28:30 <butterthebuddha> Is there a function for n -> [1..n]?
09:28:40 <srhb> > [1..10] ?
09:28:42 <lambdabot>  <hint>:1:10: error:
09:28:42 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:28:47 <srhb> Derp
09:29:00 <srhb> butterthebuddha: Anyway, that's just short for enumFromTo 1 n
09:29:40 <butterthebuddha> hanks
09:29:42 <butterthebuddha> Thanks*
09:29:42 <srhb> moczens: Well, you can try either of those options, but it might just be the amount of heap that project eats. GHC is a hungry animal.
09:30:30 <moczens> srhb: yes it is :) thanks a lot, will try
09:31:10 <srhb> moczens: I don't know if stack tries to build in parallel by default, you may also want to disable that if it does.
09:32:09 <moczens> I think by default it doesn't, but let me make sure that is disabled
09:32:46 <srhb> moczens: I think it might if the build instance presents multiple cores.
09:33:50 <moczens> srhb: fair point; looking at the command it actually used, there's a "-with-rtsopts=-N4"
09:34:13 <the_2nd> Is it possible to use happstack and have a global state?
09:34:28 <the_2nd> where requests change that state instead of acting on their own
09:34:28 <srhb> moczens: Curious, I would expect it to be a -j flag
09:34:36 <srhb> the_2nd: Yeah, definitely.
09:34:45 <srhb> Been a while since I've seen Happstack mentioned.
09:35:26 <the_2nd> srhb, I'd use scotty but seems like Happstack has better user auth / cookie support
09:35:49 <the_2nd> Thinking about writing a game where the state & server is written in haskell, with a web API
09:36:03 <the_2nd> clients / players then communicate from the browser / an app
09:38:31 <the_2nd> srhb, what would you use?
09:38:59 <srhb> the_2nd: I don't think I'd have a particular preference. Any of the lightweight web app thingies can do this in principle.
09:40:38 <cocreature> the_2nd: create an mvar/ioref/… before starting your server and then read and write from that variable in your handlers
09:44:39 <SepakoRayl> has anyone managed to get spacemacs's haskell-layer to complete type signatures?
09:46:42 <laserpants> The DateTime library on Hackage that seems to be ranked highest on Google is Data.DateTime, but it has zero API docs. What do people use for Date/Time representations and conversions?
09:48:17 <glguy> The "time" package is the standard solution for dates and times
09:48:28 <byorgey> laserpants: http://hackage.haskell.org/package/time
09:48:36 <byorgey> laserpants: you may find https://github.com/evanrinehart/time-diagram  a useful reference
09:49:08 <laserpants> byorgey, glguy: Thanks!
09:50:57 <byorgey> laserpants: it is a complicated library, but that's not the fault of the library, it's just because measuring time is complicated.
09:52:28 <SepakoRayl> it seems not :o https://github.com/DanielG/ghc-mod/issues/628
09:53:26 <byorgey> yikes, major github outage
09:54:19 <srhb> Conversely, if you feel it's not complicated enough, there's thyme.
09:54:23 <srhb> (Which is great fun)
09:54:36 <srhb> byorgey: It's up and down for the last hour.
09:54:56 <c_wraith> time takes a different approach than I've seen other libraries in other languages take. but I like that the approach it takes is "if you ignore this complexity, it will bite you sometime. so just pay attention to it from the start." 
09:55:56 * hackagebot invariant 0.4.3 – Haskell98 invariant functors – https://hackage.haskell.org/package/invariant
09:55:56 * hackagebot cabal-bounds 1.2.0 – A command line program for managing the bounds/versions of the dependencies in a… – https://hackage.haskell.org/package/cabal-bounds
09:55:58 <byorgey> srhb: mostly down, according to https://status.github.com/graphs/past_day
09:56:22 <byorgey> c_wraith: indeed.
09:56:22 <srhb> byorgey: Refreshing a ton gets me what I need. :-)
09:56:44 <laserpants> ouch!
09:56:50 <byorgey> aha! now we know why github is down.  srhb is DOS'ing it.
09:57:07 <srhb> Fastest fingers in the, uh, "west"
09:59:02 <laserpants> Kazillions of people around the globe are opening https://status.github.com/graphs/past_day
10:03:20 <duncan^> sure anything you say
10:04:23 * hackagebot hsimport 0.8.4 – A command line program for extending the import list of a Haskell source file. – https://hackage.haskell.org/package/hsimport
10:04:23 * hackagebot confsolve 0.5.6 – A command line tool for resolving conflicts of file synchronizers. – https://hackage.haskell.org/package/confsolve
10:09:27 * hackagebot cabal-cargs 0.7.12 – A command line program for extracting compiler arguments from a cabal file. – https://hackage.haskell.org/package/cabal-cargs
10:13:25 <vimalloc> Is there a way to do function composition with '+'? Trying to do something like `Set.foldr (+ . toInt) 0`
10:14:31 * hackagebot Gamgine 0.5.2 – Some kind of game library or set of utilities. – https://hackage.haskell.org/package/Gamgine
10:14:38 <byorgey> vimalloc: use (+)
10:14:46 <byorgey> @type ((+) . toInt)
10:14:48 <lambdabot> error: Variable not in scope: toInt :: a1 -> a
10:14:59 <vimalloc> thx <3
10:15:10 <mnoonan> @hoogle (a -> a -> b) -> (c -> a) -> (c -> c -> b)
10:15:11 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:15:11 <lambdabot> Data.Function.HT compose2 :: (b -> b -> c) -> (a -> b) -> (a -> a -> c)
10:15:11 <lambdabot> CorePrelude on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:15:28 <byorgey> vimalloc: in general, surrounding an infix operator name in parentheses is how you turn it into a prefix function
10:15:34 <mnoonan> (assuming you wanted to toInt each input)
10:15:56 <vimalloc> byorgey: That is good to know, thanks. Works like a charm
10:25:00 <Tuplanolla> Do we have any tools for program synthesis? I'd like to see if one could solve a problem better than I can.
10:25:14 <mnoonan> I wrote a function that is supposed to tie the knot in a recursive map, but I am not sure how to tell if it worked. specifically, in this code: http://lpaste.net/1974910878499209216 will c contain a cyclic reference to itself? 
10:26:58 <mnoonan> I didn't have much luck with :sprint, fwiw
10:30:16 <Tuplanolla> This function in particular: http://lpaste.net/357326
10:31:42 <cocreature> Tuplanolla: does https://github.com/lspitzner/exference fit the bill?
10:32:02 <cocreature> oh you want to synthesize based on input/output pairs not based on types
10:32:12 <Tuplanolla> Indeed.
10:33:46 * hackagebot mikrokosmos 0.4.0 – Lambda calculus interpreter – https://hackage.haskell.org/package/mikrokosmos
10:33:46 * hackagebot groundhog-inspector 0.8.0.1 – Type-safe datatype-database mapping library. – https://hackage.haskell.org/package/groundhog-inspector
10:37:22 <Tuplanolla> There exist tools to do that with circuits and processor instructions, but not functional programs.
10:38:01 <cocreature> I thought I had seen some for functional programs but it’s been some time and I’ve never looked closely at them
10:38:33 <shapr> Tuplanolla: convert your program into a ciruit?
10:39:01 <Tuplanolla> I'd rather go the other way, shapr.
10:40:35 <shapr> Tuplanolla: convert a program to circuit and then optimizing is one way to get bitwise parallelism - http://parabix.costar.sfu.ca/wiki/ICgrep
10:40:47 <shapr> I heard about that a few months back from edwardk
10:41:20 * edwardk tunes in.
10:41:45 <shapr> edwardk: you got me (and several coworkers) reading about bitwise parallelism
10:41:49 <shapr> and writing code for it too
10:42:25 <Tuplanolla> Procrastination intensifies.
10:42:37 <edwardk> Tuplanolla: http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=10118B6DBF7BC305A362DBAD87030520?doi=10.1.1.533.4686&rep=rep1&type=pdf is an article on a program synthesis tool, igor 2, that i've used in the past. Not sure what your problem domain is.
10:42:39 <shapr> Tuplanolla: watch out, this yak has large surface area
10:44:07 <edwardk> Tuplanolla: re that circuit, circuit generation is Sigma^P_2 complete
10:44:20 <edwardk> its not that big of a circuit though, so you can just exhaustively compute it
10:44:25 <edwardk> given a set of base gates
10:45:11 <edwardk> and junk like quine-mckluskey will give you at least 'kinda minimal' sum of product reps
10:45:31 <edwardk> that at least have at most 2 gates worth of propagation delay
10:45:48 <Tuplanolla> What's this talk of circuits?
10:46:04 <Tuplanolla> That's what I wanted to avoid.
10:46:53 * edwardk shrugs.
10:46:57 <sqooq> I'm back folks
10:47:01 <sqooq> I'm back for trouble
10:47:49 <shapr> sqooq: bitwise data parallelism?
10:48:32 <sqooq> lmao what is that
10:48:33 <edwardk> igor 2 does toy program synthesis problems, useful for things like metabolomics or something where you just have a bunch of approximate state machines and want a functional model of the machine. not so good with a bunch of opaque gates like that thing you described. you're probably on your own with respect to functional synthesis though. the circuit folks have developed tools, there's less in this space without those foundations.
10:48:47 <shapr> sqooq: are you learning Haskell programming?
10:48:54 <sqooq> yes
10:49:01 <Tuplanolla> Thanks for the reference anyway, edwardk.
10:49:01 <sqooq> where's monochrom when I need them
10:49:10 <shapr> sqooq: are you reading haskellbook.com ?
10:49:20 <sqooq> no
10:49:40 <sqooq> Why, are you the author
10:49:43 <shapr> Are you using one of our free pamphlets we mail out on a regular basis?
10:49:46 <shapr> no, I am not.
10:49:51 <Tuplanolla> I could try converting a circuit into code and performing cse on it manually.
10:50:00 <shapr> sqooq: maybe you're using Programming in Haskell by Graham Hutton?
10:50:11 <mnoonan> I think I must be doing something dumb, afaict my knot-tying code isn't tying a knot. 'tie' is here: http://hackage.haskell.org/package/justified-containers-0.1.0.0/docs/src/Data-Map-Justified.html#tie
10:50:12 <sqooq> wat
10:50:25 <mnoonan> and a example is here: http://lpaste.net/1974910878499209216
10:51:08 <mnoonan> when I do "seq c ()" and then :sprint c, I get _ : _. If the knot was tied, I would have expected _ : (_ : (...
10:51:14 <shapr> sqooq: got any questions?
10:52:13 <sqooq> http://lpaste.net/357327
10:52:18 <sqooq> very bottom 'many'
10:52:29 <sqooq> so many type errors, I tried everything
10:52:40 <sqooq> original list comprehension version
10:52:41 <sqooq> many p = [x:xs | x <- p, xs <- many p] ++ [[]]
10:52:57 <sqooq> but this assumes that Parser is a type synonym not a newtype definition
10:53:07 <sqooq> so i need to do some wrapping and unwrapping somewhere
10:53:12 <sqooq> and that's where I'm getting scrooged
10:54:13 * hackagebot aeson-flowtyped 0.8.1, eventful-core 0.2.0, eventful-dynamodb 0.2.0, eventful-memory 0.2.0, … and 4 more
10:54:13 * hackagebot  → https://hackage.haskell.org/packages/recent
10:56:30 <Cale> sqooq: It can help to define many and many1 in a mutually recursive fashion:  many p = many1 p `plus` result []; many1 p = p `bind` \x -> many p `bind` \xs -> result (x:xs)
10:56:52 <Cale> sqooq: You're at the point where you shouldn't need to be digging down into the definition of Parser
10:58:05 <Cale> But also, if you have the instance of Monad already, you can use do-notation and the usual return
10:58:29 <Cale> You may want to add on an instance of Alternative, so you can use <|> instead of plus
10:58:40 <Cale> which incidentally, will get you many and some for free
10:58:59 <sqooq> I'm instance of Monad
10:59:12 <sqooq> I just used bind because I thought it would help me get my types straight 
10:59:34 <sqooq> what is this Alternative now
10:59:57 <Cale> https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:Alternative
11:00:15 <sqooq> It's already an instance of Applicative
11:00:23 <sqooq> does that mean it automatically gets Alternative too?
11:00:38 <Cale> no
11:01:20 <sqooq> ok
11:01:36 <Cale> But you already have the ingredients to write the Alternative instance
11:01:52 <sqooq> "One might legitimately wonder why the seemingly redundant MonadPlus class exists. Part of the reason is historical: just like Monad existed in Haskell long before Applicative was introduced, MonadPlus is much older than Alternative"
11:02:08 <sqooq> so should I just delete my monadPlus functions and use Alternative only
11:02:52 <Cale> Well, there's nothing wrong with MonadPlus -- it also has the consequence of giving you a Monad instance which is sometimes useful
11:03:01 <dolio> It sounds like that wasn't the whole statement.
11:03:04 <Cale> But Alternative is a bit nicer syntactically
11:03:29 <Cale> Just for being able to write <|> infix
11:04:11 <sqooq> is it defined the same
11:04:16 <sqooq> how do I define it
11:04:35 <[exa]> ab9rf: sorry, I was afk. It doesn't have an actual stack except for the run-time one, but I thought STG basically has to simulate the stack (using graphs)?
11:06:54 <sqooq> wait mplus is literally identical to <|>?
11:07:54 * hackagebot groundhog-inspector 0.8.0.2 – Type-safe datatype-database mapping library. – https://hackage.haskell.org/package/groundhog-inspector
11:07:54 * hackagebot th-to-exp 0.0.1.1 – Provides a way to persist data from compile-time to runtime. – https://hackage.haskell.org/package/th-to-exp
11:08:21 <sqooq> Class Alternative not in scope
11:08:25 <Cale> sqooq: Essentially, yes
11:08:33 <Cale> sqooq: import Control.Applicative
11:08:47 <sqooq> strange
11:09:01 <sqooq> why could I do an instance of Applicative without importing that?
11:09:07 <sqooq> but not Alternative?
11:09:13 <Cale> Because Applicative is now in the Prelude
11:09:19 <Cale> But Alternative didn't go along with it
11:09:23 <sqooq> aha
11:09:35 <sqooq> so you said I get many for free?
11:09:39 <sqooq> How does that work
11:09:39 <Cale> yeah
11:10:03 <Cale> Because the default instance defines some and many in a sensible recursive way
11:10:13 <Cale> in terms of <|>
11:10:16 <sqooq> o crap
11:10:17 <sqooq> it works
11:10:19 <sqooq> wow
11:10:42 <Cale> Rather, the default method implementations in the class definition do
11:11:39 <Cale> Of course, if the point of this is to implement stuff yourself, you might want to try getting them working on your own :)
11:11:39 <JX7P> prélude crenshaw
11:12:12 <sqooq> Cale: yeah
11:12:30 <sqooq> too bad I'm struggling to see what's wrong 
11:13:32 <Cale> sqooq: Define many and some together, so that one uses the other.
11:14:09 <Cale> many p = some p <|> return []; some p = do v <- p; vs <- many p; return (v:vs)
11:14:35 <Cale> That definition of some can also be written using Applicative:  some p = (:) <$> p <*> many p
11:16:01 <Cale> So many allows the zero case, and some requires parsing at least one p.
11:16:47 <sqooq> too much recursion
11:17:51 <sqooq> I think I give up
11:18:33 <Cale> So, some p says "in order to parse one or more occurrences of p, first parse p (obtaining some result v), and then parse zero or more occurrences of p (using many p), obtaining some result vs, and finally return (v:vs) as the result of the parser
11:18:36 <Cale> "
11:19:14 <Cale> and then many p says "in order to parse zero or more occurrences of p, either parse one or more occurrences of p, or return the empty list without consuming anything"
11:19:45 <Cale> Make sense?
11:19:47 <sqooq> <|> in this case just combines the items of both lists right
11:19:54 <sqooq> in my case I should say
11:20:02 <sqooq> `Parser p `plus` Parser q = Parser (\inp -> (p inp ++ q inp))`
11:20:06 <Cale> Yeah, it combines the lists of possible parses
11:20:11 <sqooq> so if the first fails
11:20:19 <sqooq> it gives zero
11:20:24 <sqooq> which is effectively []
11:20:30 <Cale> If the first parser fails, you only get results of the second parser
11:20:35 <sqooq> > [] ++ []
11:20:36 <Cale> [] ++ q inp
11:20:37 <lambdabot>  []
11:20:40 <sqooq> aha
11:20:41 <sqooq> ok
11:20:52 <sqooq> Wow your version is way cleaner than this paper
11:20:58 <sqooq> You know, I'm starting to think this paper is crap
11:21:03 <Cale> Which paper?
11:21:11 <sqooq> http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
11:21:25 <sqooq> It uses list comprehension which is the worst out of all the options imo
11:21:27 <Cale> Oh, that's a very important paper :)
11:21:30 <Cale> Note the date
11:21:30 <JuanDaugherty> not crap
11:21:40 <Cale> That paper was written in 1996
11:21:58 <sqooq> o
11:21:59 <Cale> before most of us had figured any of this out
11:22:05 <sqooq> o nice
11:22:07 <sqooq> so it's foundational
11:22:10 <Cale> yeah
11:22:21 <sqooq> pretty sure it was monochrom who told me to read it
11:22:26 <sqooq> because I told them I like detail
11:22:35 <sqooq> which is true, I learned a lot
11:22:41 <Xion_> Hey, list comprehensions are great
11:22:57 <Cale> Xion_: They're pretty good. Particularly when you have multiple <-'s
11:23:07 <Cale> Xion_: I also like the case of no <-'s
11:23:34 <Cale> [x | condition] is a nice way to write a list which has zero or one element depending on whether the condition succeeds
11:23:35 <sqooq> I like lambdas
11:23:46 <hexagoxel> Tuplanolla: MagicHaskeller does program synthesis from input/output pairs
11:23:46 <sqooq> list comprehensions are good in some cases
11:23:58 <sqooq> but I tend to prefer other ways
11:24:08 <Cale> When the list comprehensions get too complicated, you tend to switch to using do-notation instead
11:24:11 <sqooq> for example I converted their definition of bind to 
11:24:12 <sqooq> Parser p `bind` f = Parser (\inp -> concatMap (\(v,inp') -> fromParser (f v) inp') $ p inp)
11:24:20 <sqooq> which in my head is much clearer
11:24:20 <Cale> Just because it's less awkward to spread do-blocks across many lines
11:24:40 <Cale> I much prefer using do-notation for the list monad there
11:24:44 <hexagoxel> Tuplanolla: see hackage and http://nautilus.cs.miyazaki-u.ac.jp/~skata/MagicHaskeller.html
11:25:02 <Xion_> Cale: I actually tend to switch `map` with named function if the transformation gets too complicated :)
11:25:05 <sqooq> Btw the issue with the paper really isn't the paper
11:25:20 <Xion_> But if you need both map & filter, listcomps are definitely my first choice
11:25:29 * Xion_ may or may not be influenced by Python
11:25:31 <zaquest> what does ! do in data type definitions? at first i thought it forces evaluation of an annotated fields, but when? when i for example create `data A = A !Double` and then `let a = A (sum [1..10000000])` it doesnt even stop for a second to calculate the sum, and it doesnt stop to do it when i then deconstruct `a` with `let (A x) = a`, it does nothing until i actually try to use `x`. so what's the different ! makes?
11:25:38 <Tuplanolla> Neat, hexagoxel.
11:25:48 <sqooq> "We pause briefly here to address a couple of technical points concerning Gofer. First of all, type synonyms such as Parser must be supplied with all their arguments. Hence the instance declaration above is not actually valid Gofer code, since Parser is used in the first line without an argument. The problem is easy to solve (redefine Parser using data rather than type, or as a restricted type synonym), but for simplicity we prefer in t
11:25:51 <Cale> p `bind` f = Parser $ \s -> do (v, s') <- runParser p s; (w, s'') <- runParser (f v) s'; return (w, s'')
11:26:00 <Cale> or, to simplify that
11:26:07 <Cale> p `bind` f = Parser $ \s -> do (v, s') <- runParser p s; runParser (f v) s'
11:26:50 <sqooq> you can use do before you even define it?
11:26:55 <glguy> zaquest: the field is evaluated when the fully saturated constructor is evaluated
11:27:07 <Cale> zaquest: It causes occurrences of the data constructor to be replaced with lambdas that `seq` (some of) their arguments in the body
11:27:42 <glguy> zaquest: pattern matching in a let doesn't force evaluation
11:28:06 <Cale> (unless you use bang patterns)
11:28:10 <dmwit> sqooq: That `do` is in the [] monad, not the Parser monad.
11:28:12 <Cale> (sadly)
11:28:21 <Xion_> Yeah, the param of A may be strict but the `a` isn't.
11:28:29 <sqooq> dmwit: I see, thanks
11:28:29 <dmwit> sqooq: If it was in the Parser monad, it would indeed by a cyclical definition, which *probably* (but not definitely) would be a problem.
11:28:32 <Tuplanolla> Unfortunately it doesn't produce anything, hexagoxel.
11:28:34 <Cale> sqooq: Yeah, we're implementing do-notation for Parser using do-notation for lists :)
11:28:44 <sqooq> lmao
11:28:48 <sqooq> should I use that then
11:28:51 <Cale> sqooq: Also, note that there's nothing really special about String in the Monad definition here.
11:28:54 <sqooq> It's slightly cleaner
11:29:18 <Cale> and, moreover, if we're careful about the definition of return as well
11:29:23 <Cale> there's nothing special about lists either
11:29:32 <sqooq> Cale: Yeah the paper mentioned that
11:29:36 <Cale> If we abstract over those choices, we end up with StateT
11:29:48 <sqooq> O boy
11:29:54 <sqooq> This IRC is recursive teaching
11:29:58 <Cale> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
11:29:58 <sqooq> It never ends
11:30:16 <Cale> return v = StateT (\s -> return (v,s))
11:30:19 <sqooq> Cale: Ah, the Parsec parser definition looks very similar to that
11:30:30 <sqooq> What is state?
11:30:35 <sqooq> I see it being talked about all the time
11:30:40 <sqooq> but I have no clue what it is.
11:30:54 <Cale> Ah, maybe we should have started with introducing plain State :)
11:31:11 <sqooq> In haskell it's a monad right
11:31:14 <sqooq> that's as much as I know
11:31:22 <Cale> Well, yes
11:31:28 <Cale> That doesn't tell you much
11:32:04 <Cale> Okay, so the idea is to have some type State s a for "computations which manipulate a state of type s while producing a result of type a"
11:32:24 <Cale> i.e. they can read and write a single global mutable variable of type s
11:32:29 <dmwit> (An aside: you may also like this article, which talks about State in passing. http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html )
11:32:41 <dmwit> (It is my favorite monad tutorial.)
11:32:53 <sqooq> I've read it I'm pretty sure
11:32:58 <Cale> So, given that we're in a functional programming language, it's natural to encode such a computation as a function
11:33:05 <Cale> which is going to take the initial state as a parameter
11:33:12 <Cale> and produce a pair of the final state and the result
11:33:30 <Cale> newtype State s a = S (s -> (s,a))
11:33:48 <Unicorn_Princess> I have a module that defines some data that uses a Data.Map.Strict.Map. I import this module somewhere else, and want to apply the 'elems' function to the map - how do I make sure I use the right 'elems', i.e. not one for Data.Map.Lazy, or, if they happen to be the same, how would I solve this issue if they -weren't- the same?
11:34:16 <Cale> We'll wrap it up for the sake of abstraction: the goal is now to implement enough basic operations on the state so that we don't need to refer to this S data constructor
11:34:47 <Cale> and of course, we're going to make this a monad, as part of that
11:34:53 <glguy> Unicorn_Princess: There's no issue, the Map type from these two modules is the same
11:35:39 <Cale> Unicorn_Princess: The only difference between those modules is how far the functions exported evaluate the elements which are being added to the maps
11:35:49 <Cale> (the values of the key/value pairs)
11:36:31 <sqooq> Thanks Cale
11:36:35 <Cale> Also, note that even with the .Strict variants, it will only evaluate the values up to determining the top level data constructor, so if you want more evaluation than that, you need to make sure the expression is strict enough
11:36:40 <sqooq> I have to go now :(
11:36:43 <Cale> sqooq: ah
11:36:55 <Cale> sqooq: ping me at some point, and if I'm free I'll take you through it :)
11:37:01 <sqooq> ok
11:37:18 <Cale> I should really get back to work myself too ;)
11:37:31 <sqooq> My next step is trying to use my parser to parse trees in the form "[[][[][]]]"
11:37:54 <sqooq> I've been trying with what I have already, and it's been tough
11:38:02 <sqooq> but I don't want to just get spoonfed 
11:38:14 <sqooq> so I'm gonna spend another few days before I give up and ask in here lmao
11:38:23 <Cale> My goal at the moment is to write a compiler plugin for GHC which will tell us when not enough optimisation has occurred and dictionary passing for type classes is still occurring.
11:38:38 <sqooq> nice
11:38:48 <ongy> that would be cool
11:39:09 <ongy> Cale: can I subscribe to the progress of that somewhere? (Also will it be free, both versions of free)?
11:39:30 <Cale> I expect we'd have no trouble with releasing it.
11:40:25 <TDavis> haskell has gone horribly wrong
11:40:35 <sqooq> my ultimate goal is to parse text in roughly the form "[ 1 2 [ 3 5 6 ] ] [ 0 4 7 4 ]" and have it put into csound (using a csound library)
11:40:40 <sqooq> and generate music
11:40:40 <Cale> TDavis: ?
11:40:50 <shapr> TDavis: I do worry that Haskell has become too successful to keep changing
11:41:11 <sqooq> the brackets indicate rhythm
11:41:14 <sqooq> ok bye friends
11:41:16 <Cale> Yeah, I worry about that too, though I do want to see what dependent Haskell looks like.
11:41:19 <sqooq> Thanks for everything
11:41:23 <TDavis> the problem is this nonsense about homotopy type theory. you don't need to be a Christian to know that type theory is bullshit. 
11:41:32 <cocreature> what
11:41:35 <Cale> TDavis: huh?
11:41:48 <ongy> hahaha
11:41:49 <zaquest> glguy, what does it mean to evaluate fully saturated constructor?  i would think it's simply "apply constructor to all it's arguments", but i guess that's wrong, evaluating it to WHNF doesnt work either (which it already was in?), but if i have to evaluate it to NF what's the point of !
11:41:52 <Tuplanolla> That's a great quote.
11:41:59 --- mode: ChanServ set +o shapr
11:42:01 <Cale> TDavis: I think you need to work on that trolling.
11:42:02 <TDavis> i need the uniqueness of identity axiom. but the CIA nigger haskell gang decided to steer the entire type theory discipline down a wild goose chase of homotopy type theory, making their entire ethos about not being able to prove basic true equalities. rip coq, had so much potential before the homos took over.
11:42:11 --- kick: TDavis was kicked by shapr (Kicked by shapr)
11:42:21 <Tuplanolla> I wonder if that was the Terry Davis.
11:42:32 <shapr> don't know, don't care
11:42:41 <ongy> doubt it. Can't connect from templeOS to IRC, can you?
11:42:42 --- mode: ChanServ set +o glguy
11:42:42 --- mode: glguy set +b *!*@*/ip.88.97.47.162
11:42:48 <shapr> glguy: thank you!
11:43:35 <glguy> zaquest: The distinction matters in the case of: data T = C !A !B
11:43:49 <Cale> Also, the actual Terry Davis seems a lot more polite, even if he is crazy.
11:44:04 <glguy> where evaluating (C x) doesn't force x, but evaluating (C x y) does
11:44:43 <ongy> ohh that's good to know
11:46:15 <Cale> Er, maybe not, I dunno
11:46:28 <glguy> zaquest: and it's just evaluation to whnf that we're talking about with strict fields
11:47:33 <Cale> Google quickly turned up some things which made me question that politeness
11:47:35 <Cale> hah
11:47:58 <ongy> what exactly is uniqueness of identiy, and how is it broken in Haskell? 
11:48:07 <glguy> zaquest: Update your example to:   case A (sum [1..100000000]) of A x -> ....   -- and evaluating the case expression will evaluate the sum, regardless of what you do with x
11:49:54 <Cale> ongy: I don't know what's meant by "broken in Haskell" there, but that generally refers to the fact that in a category (or monoid), if you have some arrow which satisfies the same equations as id, then it must be equal to id
11:50:40 <ongy> I was asuming the troll at least did some research :)
11:51:01 <Cale> Oh, I missed that
11:51:08 * shapr shrugs
11:51:24 <Tuplanolla> It sounds meaningless to me.
11:51:27 <shapr> some people just want you to do the dance of anger with them.
11:51:28 <Cale> He was probably referring to UIP, the uniqueness of identity proofs, which is a different thing
11:51:53 <Cale> So, this is actually interesting
11:52:39 <Cale> In dependent type theories, you can define a type which encodes the property that two terms of another type are equal
11:52:51 <Cale> i.e. for every type A, and every x and y of type A, you have some type Id A x y
11:52:59 <zaquest> glguy, oh, so it's just let patterns are special somehow, ok. thank you.
11:53:14 <Cale> and it's defined to have a single data constructor  refl : Id A x x
11:53:43 <Cale> So the only guaranteed way to construct a term of type Id A x y is if x and y are actually equal
11:54:19 <Cale> Now, since there's only one data constructor, you might think that you'd be able to prove that if p and q are both terms of type Id A x y, then p = q
11:54:28 <Cale> i.e. that you have Id (Id A x y) p q
11:54:46 <Cale> But it turns out to be challenging to construct a term of this type in many type theories
11:55:16 <Cale> Especially for instance Martin-Löf's intensional type theory, and Coq
11:55:40 <Cale> and not only is it impossible, but there's an interesting reason for this
11:56:46 * hackagebot hpp 0.4.1, nvim-hs 0.2.3, stratosphere 0.8.0
11:56:46 * hackagebot  → https://hackage.haskell.org/packages/recent
11:56:49 <Cale> The uniqueness of identity proofs is just the axiom that you can introduce in such a theory which gives you for any such A, x, y, p, q, the appropriate Id (Id A x y) p q
11:58:14 <ongy> why is it impossible? shouldn't that just sort of "stack"?
11:58:38 <Cale> But yeah, if you don't do that, there's an interpretation for MLTT where types are interpreted as topological spaces up to homotopy equivalence
11:58:55 <Cale> and the type Id A x y is interpreted as the space of paths between the points x and y in the space A
11:59:32 <Cale> and since there might not be a way to continuously deform one path into the other (while holding the endpoints fixed), there might be distinct such paths
12:00:17 <Cale> refl just gets interpreted as the boring path which stays at x and doesn't go anywhere
12:00:20 <ongy> ok, I'd have to first wrap my head around MLTT and topological spaces to understand this :)
12:00:27 <ongy> thanks for the explanation though
12:01:02 <Cale> So basically, it's because there are models of the type theory where Id A x y is *not* uniquely inhabited
12:01:12 <Cale> and they turn out to be really interesting models in general
12:01:39 <Cale> That one (which is what homotopy type theory is all about) is actually not the only one, nor was it the first to be found
12:03:02 <Cale> The first one to be discovered was the "types are groupoids" model, where Id A x y would be interpreted as the set (regarded as a discrete groupoid) of arrows x -> y in the groupoid which was the interpretation for A.
12:03:30 <Cale> (This is sort of like the one-dimensional version of the topological thing)
12:07:12 <cocreature> I love how that troll managed to produce a very interesting monologue by Cale :)
12:07:28 <cobreadmonster> cocreature: rofl
12:08:12 <Cale> I try to make the best of the trolls
12:13:56 * JuanDaugherty scrolls back to see the epitet and lols
12:14:13 <lafrenierejm> I'm creating a type class instance where things are added to a list.  Why does `:` throw type mismatch errors when `++` doesn't?
12:14:59 <kadoban> lafrenierejm: What error? (probably need context too)
12:15:04 <glguy> lafrenierejm: (:) and (++) have different types
12:15:15 * ongy searches for epitet in a dictionary
12:15:18 <glguy> so you'll only really be able to use one or the other depending on what you're doing
12:15:51 <lafrenierejm> glguy: Indeed they do.  And looking at their types explains things.
12:16:32 <lafrenierejm> I had only been thinking of them as list prepend/append, not in terms what their types would be.
12:17:14 <ab9rf> lafrenierejm: (:) is the list constructor
12:20:00 <lafrenierejm> ab9rf: Right.  I understand now the difference between the two.
12:22:20 * hackagebot dynamic-state 0.3 – Optionally serializable dynamic state keyed by type – https://hackage.haskell.org/package/dynamic-state
12:26:01 <blobber> hey all, is anyone here able to successfully parse a github webhook JSON using the `github` package?
12:26:43 <blobber> I'm getting complaints about missing keys, and I wonder if the API has drifted or if I'm passing in the wrong object
12:28:29 <tsani> blobber: I've never tried to actually parse the webhook JSON before, but I've played with the webhooks in Haskell a fair bit. On Github you can see the requests sent by github; are the keys actually missing?
12:29:03 <blobber> tsani: yeah, it's complaining about no URL at (what I assume is) the top-level, and there is no such field
12:29:16 <blobber> it appears within some other objects
12:30:28 <tsani> Interesting. My guess would be API drift.
12:30:51 <tsani> blobber: are you using servant-github-webhook? :D
12:31:02 <blobber> I'm not currently, but I might be at some point
12:31:31 <blobber> although looking over it it looks like it requires compiling your repo(s) into your actual code, which wouldn't work for me :(
12:32:31 * hackagebot opaleye 0.5.4.0 – An SQL-generating DSL targeting PostgreSQL – https://hackage.haskell.org/package/opaleye
12:32:33 <blobber> tsani: if you've done stuff with webhooks in haskell how did you do it? I would assume that being able to parse the JSON (directly or indirectly) would be a step 1 in most use cases...
12:33:33 <tsani> blobber: my use case was to make a dead-simple CI that just fetches the repo upon it being pushed to and executes a Makefile in the repo root
12:33:49 <tsani> so I never needed to look inside the webhook data once servant-github-webhook validated the request
12:34:07 <tsani> I just left it as a raw aeson Object and ignored it
12:34:21 <blobber> I see... well I've only taken the most cursory look at servant-github-webhook, not clear if/how I would use it
12:34:58 <blobber> I'm writing a web server which can be triggered by github events, but which repo(s) etc would be configurable
12:35:56 <tsani> I tried to make the docs very comprehensive with included examples. But yeah, you can't really change the set of repos that get monitored. I've recently been thinking about how to support that though.
12:36:26 <blobber> it certainly would be cool :)
12:37:48 <blobber> also I've confirmed that copy/pasting the example JSON at https://developer.github.com/v3/activity/events/types/#pullrequestevent and trying to decode it with Aeson returns `Left "Error in $: key \"url\" not present"` :(
12:40:11 <blobber> I'll probably just have to write my own... and/or patch the current library
12:41:59 <tsani> the maintainer of the github repo is very welcoming of PRs
12:42:10 <petrus> xit
12:42:44 <blobber> that's good
12:42:50 <phadej> I'm!
12:43:07 <blobber> I was hoping that the haskell github library could teach me about webhooks... but I guess it's gonna be the other way around haha
12:44:20 <phadej> blobber: GitHub is not Amazon :/
12:44:56 <blobber> they change their API without warning?
12:45:07 <phadej> they don't have machine readable specification
12:45:32 <blobber> that's unfortunate
12:48:48 <tsani> alas the only solution I've thought of for dynamic repos would be to provide a combinator that combines GitHubSignedReqBody with servant's Capture; this way you can examine a part of the request path to decide which repo's key to use.
12:48:51 <phadej> blobber: they are Ruby shop, for them it's enough that hey return some dict :)
12:52:06 <blobber> hahaha... well looks like the webhooks code hasn't been changed in a year so it's due for a facelift anyway :)
13:00:58 <bbear> how's that ?
13:01:14 <bbear> #haskell is number 4 chan on freenode :)
13:01:24 <ab9rf> by what measure?
13:01:42 <bbear> I just sorted chans on freenode by user number
13:02:02 <bbear> it gives 1. python, 2. archlinux, 3. debian, 4. haskell
13:03:02 * hackagebot nvim-hs 0.2.4 – Haskell plugin backend for neovim – https://hackage.haskell.org/package/nvim-hs
13:03:02 * hackagebot haddock-library 1.4.5 – Library exposing some functionality of Haddock. – https://hackage.haskell.org/package/haddock-library
13:15:03 * hackagebot tls 1.4.0 – TLS/SSL protocol native implementation (Server and Client) – https://hackage.haskell.org/package/tls
13:24:48 <bbear> bright future ?
13:33:17 * hackagebot atomic-primops 0.8.1, x509 1.7.2, x509-store 1.6.4, x509-system 1.6.6, … and 2 more
13:33:17 * hackagebot  → https://hackage.haskell.org/packages/recent
14:13:23 <jle`> i like to hope so :)
14:14:46 <erisco> yeah, it is going to get really bright, like... too bright
14:16:03 <nek0> hi folks, has anyone of you ever cross-compiled some haskell code? I need to compile something for the armhf platform. Dies anyone have some kind of tutorial at hand?
14:16:57 <erisco> then a while later it will get really dark, and cold... forever
14:30:57 <monochrom> No. It will get really bright. Then it will get hot, too. Then way hotter than water's boiling point.
14:46:55 <jared-w> glguy: you going to the haskell meetup today?
14:59:17 <glguy> jared-w: considering it; hoping they have AC :)
15:00:05 <sqooq> ich bin zuruckgekehrt
15:00:32 <glguy> sqooq: This channel is English specific, there are other channels for other languages
15:00:48 <sqooq> lmao it's jokes, "I have returned"
15:00:51 <glguy> for reference for anyone else this is the particular meetup https://www.meetup.com/Beaverton-Haskell-Meetup/events/241822925/
15:01:04 <sqooq> Cale: I think I understand what state is used for
15:01:28 <sqooq> Idk if it's implementation is important to learn. It's up to you if you want to teach me more.
15:04:35 --- mode: glguy set -o glguy
15:10:24 <jared-w> glguy: you should go, I'm going too and it'll be nice to know someone :p plus I have a cute dog
15:11:11 <jle`> say no more
15:11:12 <jared-w> This is the kinda stuff that inspires 'haskell is gibberish' memes: http://www.cs.ox.ac.uk/research/pdt/ap/dgp/workshop2004/cunha.pdf
15:16:14 <[exa]> Hm guys. I have f :: a->b. Operation that produces f' :: m a -> m b is called lifting. How do I call operation that produces f'' :: a -> m b ?
15:16:50 <[exa]> it's basically `return f', but 'returning' or `puring' is probably not the right word
15:17:19 <jared-w> :t return
15:17:21 <lambdabot> Monad m => a -> m a
15:17:21 <[exa]> s/return f/\x->return f x/ sorry
15:17:29 <[exa]> yep. :D
15:17:44 <geekosaur> the term "lifting" is overloaded
15:18:15 <hpc> 18:17 < geekosaur> the term "lifting" is lifted
15:18:24 <byorgey> and coming up with names for every operation is overrated.
15:18:25 <jared-w> ahh got it, now I know what you're asking.
15:18:27 <geekosaur> heh
15:18:32 <[exa]> lol
15:18:50 <sqooq> return
15:19:24 <[exa]> well, I just want to avoid next thing that would be called lifting
15:19:38 <sqooq> f' is sequence
15:19:40 <sqooq> right?
15:19:43 <geekosaur> [exa], in all honesty, they and a few other things are all called lifting; the distinction is what they are lifted into
15:19:48 <nshepperd> that operation is also lifting, but into kliesli category, not codomain category of the functor ‾\(*_*)/‾
15:19:53 <sqooq> wait no
15:19:55 <[exa]> XXX f = return.f, fill in XXX
15:20:07 <sqooq> sequence is ma -> mb -> mb
15:20:20 <nshepperd> XXX = runKliesli . arr :)
15:20:54 <[exa]> sqooq: no, just lift. Or fmap probably (getting late here)
15:21:04 <[exa]> nshepperd: one identifier right? :D
15:21:51 <erisco> the only pattern that I recognise it with is Kleisli arrows
15:22:01 <nshepperd> liftKliesli? lol
15:22:11 <jared-w> I think one of the differences here is that people are used to naming things a specific identifier. That is, "this ONE thing is 'lift', that ONE thing is..." but in reality most of the names we're using for more abstract concepts are really just naming the similar behavior itself
15:22:16 <erisco> no, just Kliesli f
15:22:31 <erisco> http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Arrow.html#v:Kleisli
15:22:32 <jared-w> ap lifts, fmap lifts, >>= lifts, <=< lifts...
15:22:37 <geekosaur> yep
15:22:57 <geekosaur> we are lift of maths, you will be abstracted
15:23:16 <jared-w> 'lift' is not really a "name" and shouldn't be thought of as such; it's a concept. To say that something is called lift is like saying your dog is named 'dog'
15:23:43 <erisco> lift is a family of functions indexed by type
15:24:04 <[exa]> naming is hard.
15:24:33 <nshepperd> call it 'swim'
15:25:02 <erisco> you name for the purposes of 1) abbreviation, 2) readability, 3) mutability
15:25:03 <nshepperd> swim f >=> fish
15:25:10 * [exa] trying to antropomorphize the whole concept
15:25:19 <glguy> If it's heavy you could hoist or heave it
15:25:36 <erisco> if you have something which is short, straight-forward, and unlikely to change, then don't name it
15:25:43 <noexcept_> wow, the 'fold :: (Foldable t, Monoid m) => t m -> m' overload of fold is really strange (and unreadable): https://www.reddit.com/r/programming/comments/6qpwax/fizzbuzz_one_simple_interview_question/dkzftl8/
15:27:05 <noexcept_> how is evaluating each function from an array with the same element and then accumulating the results the same as using one function to accumulate an initial value with each element of an array?
15:28:09 <noexcept_> this is why I'm against overloading names..
15:30:16 <nshepperd> noexcept_: folding is just combining the contents of a container in order in some particular way
15:30:38 <nshepperd> if the contents are functions, you combine them together into one function
15:31:35 <noexcept_> nshepperd: my problem here is that the container is given as the first argument if the contents are functions and as the last argument otherwise
15:31:57 <sqooq> ⛛
15:32:25 <nshepperd> noexcept_: no, 'fold' always takes the container as its first argument
15:33:05 <nshepperd> > fold ["hello", " wor", "ld"]
15:33:07 <lambdabot>  "hello world"
15:33:37 <noexcept_> > fold (+) 0 [1, 2, 3]
15:33:40 <lambdabot>  error:
15:33:40 <lambdabot>      • Could not deduce (Num t0)
15:33:40 <lambdabot>        from the context: (Num ([t] -> t1),
15:33:45 <nshepperd> it assumes that the contents know how to combine themselves (which is the point of the Monoid constraint)
15:34:31 <nshepperd> there are other functions that let you provide custom combining functions
15:34:38 <nshepperd> > foldr (+) 0 [1, 2, 3]
15:34:40 <lambdabot>  6
15:35:14 <nshepperd> > fold [Sum 1, Sum 2, Sum 3]
15:35:16 <lambdabot>  Sum {getSum = 6}
15:35:40 <noexcept_> wait so fold doesn't let you give it a custom combining function?
15:35:52 <jle`> fold is mconcat
15:35:54 <nshepperd> right
15:35:57 <[exa]> noexcept_: they are defined by the monoid
15:36:00 <jle`> if you're familiar with the ye olden days
15:36:06 <erisco> mconcat but generalised
15:36:11 <noexcept_> I always thought the only difference was that fold is when you don't care about whether you want foldl or foldr. confusing names.
15:36:27 <erisco> generalised to all things you can conceive a Church list for...
15:36:35 <jle`> fold = foldr (<>) mempty, or foldl (<>) mempty
15:36:42 <noexcept_> I'm not a very functional programmer. I find all the overgeneralization very confusing.
15:36:56 <erisco> oh, *over* generalisation is it
15:37:00 <nshepperd> there is also foldMap, which lets you map the values into any monoid you like, which can be thought of as providing a combining function
15:37:08 <jle`> well overgeneralizaion is confusing by definition
15:37:11 <nshepperd> > foldMap Sum [4, 5, 6]
15:37:13 <lambdabot>  Sum {getSum = 15}
15:37:34 <jle`> noexcept_: that's like saying that you find bad abstractions to be bad
15:37:36 <jle`> and good abstractions to be good
15:37:39 <nshepperd> > foldMap Product [4, 5, 6]
15:37:41 <lambdabot>  Product {getProduct = 120}
15:37:56 <erisco> noexcept_, trust me, this stuff here is all straight-forward. You can learn it with some time
15:37:59 <noexcept_> jle`: true, what I said was a tautology
15:38:22 <jle`> but yeah, assuming that fold is the same as foldr/foldl is probably what was confusing here
15:38:28 <noexcept_> yup
15:39:30 <jle`> admittedly fold could be better named in relation to existing foldr/foldl
15:40:06 <erisco> actually I suspect everything you could know is straight-forward once known and otherwise difficult... so that may be a pointless statement :P
15:41:17 <jle`> i always liked mconcat
15:41:31 <sqooq> concatMap?
15:41:44 <nshepperd> i'm happy with the naming of fold in relation to foldMap though
15:41:56 <jle`> the only issue i see is that many useful monoid instances aren't representing any "concatentation"
15:41:59 <jle`> sqooq: no, mconcat
15:42:00 <nshepperd> very logical
15:42:18 <erisco> what are the properties of concatenation?
15:42:34 <jle`> it's an ill-defined term already
15:42:43 <sqooq> monoid concat?
15:43:02 <jle`> is that a question?
15:43:06 <sqooq> o that's actually required for monoid
15:43:08 <sqooq> kek
15:43:20 <erisco> I think you could define it just fine, but it probably needs more than Monoid to satisfy it
15:43:52 <nshepperd> > (Sum <> Sum <> Sum) 3
15:43:55 <lambdabot>  Sum {getSum = 9}
15:45:24 <erisco> it is Monoiception
15:45:27 <nshepperd> 'concatenation' tends to preserve its input in some specific manner
15:47:45 <noexcept_> so Monoid is a type which has an "empty" value (zero element) and an associative operation that combines two elements? So it's like a group?
15:48:21 <geekosaur> semigroup with an identity
15:48:36 <SepakoRayl> ogroups require inverses
15:50:00 <noexcept_> ah yeah I was about to ask about the inverse element, so Monoid is really the same as a Group without the requirement for there to be an inverse element?
15:50:11 <noexcept_> there is no difference other than that?
15:53:44 <nshepperd_> noexcept_: yep, that's right.
15:54:51 <jared-w> There's also a semigroup in Haskell that's just Moniod without mempty
15:55:31 <erisco> jle`, I think it might be defined on top of Monoid with some operation that takes the structure apart again
15:58:19 <dmwit> (Sum <> Sum <> Sum), the most reader-hostile version of (*3)
16:00:32 <geekosaur> I'm sure someone can come up with a more hostile version
16:00:37 <c_wraith> :t getSum . (Sum <> Sum <> Sum) 
16:00:38 <lambdabot> Num c => c -> c
16:00:51 <erisco> :t ((getSum .) . fold . flip replicate Sum) 3
16:00:51 <c_wraith> you forgot the getSum
16:00:52 <lambdabot> Num c => c -> c
16:00:57 <dmwit> I didn't forget.
16:03:01 <jared-w> Gotta make sure it's properly hostile, after all
16:04:05 <dmwit> :t liftA3
16:04:06 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
16:04:08 <dmwit> :t liftA2
16:04:09 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:04:12 <dmwit> :t liftA1
16:04:13 <lambdabot> error:
16:04:13 <lambdabot>     • Variable not in scope: liftA1
16:04:13 <lambdabot>     • Perhaps you meant one of these:
16:04:19 <dmwit> :t liftA
16:04:20 <lambdabot> Applicative f => (a -> b) -> f a -> f b
16:04:28 <dmwit> :t pure -- liftA0, please!
16:04:29 <lambdabot> Applicative f => a -> f a
16:04:53 <jared-w> :t lift
16:04:55 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
16:05:06 <jared-w> bah humbug, no liftA0? literally unusable
16:05:19 <Logio> erisco: I'd say it's the converse, concatenation is just the free monoid operation, each other monoid is just that + identification of elements
16:07:01 <erisco> maybe there are other things that feel like concatenation
16:07:48 <dmwit> Maybe all semigroup operations feel like concatenation. =)
16:08:06 <erisco> nah because you have Maybe, for example, which just feels awful
16:08:16 <jared-w> I'm guessing the concatenation issue comes from "3 concat 5" is either 35, 8, or 15 depending on what definition of concatenation you feel like using, so it feels very "non-uniform"
16:08:25 <dmwit> erisco: Which semigroup on Maybe feels awful?
16:08:41 <erisco> check out Monoid (Maybe a)
16:09:08 <erisco> concatenation feels like "stick stuff together", so the free monoid is bang on
16:09:10 <Logio> jared-w: well that's because concat is not just concatenating, but also doing the identification
16:09:12 <dmwit> I think it is sensible if you think of it as a sort of composition of concatenations.
16:09:26 <dmwit> First you concatenate an at-most-one-long container; if you get more than two elements, you concatenate them to turn them into one.
16:09:45 <erisco> > Just 3 <> Just 4
16:09:47 <lambdabot>  error:
16:09:47 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M394956717293...
16:09:47 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
16:09:54 <erisco> > Just (3 :: Int) <> Just 4
16:09:56 <lambdabot>  error:
16:09:56 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘<>’
16:09:56 <lambdabot>      • In the expression: Just (3 :: Int) <> Just 4
16:10:07 <erisco> really, okay... for some reason I thought it wasn't that
16:10:10 <dmwit> > Just (Sum 3) <> Just (Sum 4)
16:10:12 <lambdabot>  Just (Sum {getSum = 7})
16:10:25 <dmwit> Perhaps you are thinking of
16:10:31 <dmwit> > First (Just 3) <> First (Just 4)
16:10:33 <lambdabot>  First {getFirst = Just 3}
16:10:51 <erisco> yes I am, but I thought Maybe was already that for some reason... whatever
16:11:10 <dmwit> I can spin a yarn that makes that "feel" like concatenation, if you're interested.
16:11:11 <erisco> the fact that First is Monoid is what makes Monoid not fit the idea of concatenation
16:11:47 <dmwit> Think of `First a` as being a bounded-length container of `a`s. When you concatenate them, you only keep as many as your bound allows you to.
16:11:56 <dmwit> In this case the bound is 1, but you could imagine a longer bound, too.
16:12:11 <erisco> it is a nice story but I don't like bounds in my concatenation :P
16:12:15 <dmwit> ?let newtype AtMostThree a = AtMostThree [a] deriving Show
16:12:16 <lambdabot>  Defined.
16:12:35 <jle`> in other news, functors are containers
16:12:45 <dmwit> ?let instance Monoid (AtMostThree a) where mempty = AtMostThree []; mappend (AtMostThree ls) (AtMostThree rs) = AtMostThree (take 3 (ls `mappend` rs))
16:12:47 <lambdabot>  Defined.
16:12:47 <nshepperd> concatenation is the monoid operation of a foldable container such that foldMap f is a monoid morphism
16:12:50 <Logio> I remember actually being a bit miffed with the Monoid class not distinguishing between the concatenation and identification
16:12:53 <nshepperd> for any f
16:13:00 <dmwit> > AtMostThree [1,2] <> AtMostThree [3,4]
16:13:02 <lambdabot>  AtMostThree [1,2,3]
16:13:14 <dmwit> erisco: Why not?
16:13:29 <dmwit> erisco: Sometimes it is just what the doctor ordered. e.g. perhaps you are doing bounded-width beam search or similar.
16:14:06 <erisco> because that doesn't feel like concatenation to me... one man's concatenation is another's something else
16:14:40 <sqooq> God I'm so tempted to just keep asking y'all for your ultimate knowledge
16:14:55 <erisco> we shouldn't be losing information, thats a key quality
16:15:02 <jle`> the issue is of course that the word 'concatenation' can be re-defined to be exactly what you want it to mean
16:15:03 <dmwit> erisco: I wonder: does the `AtMostTen` operation "feel" like concatenation to you?
16:15:05 <Logio> I feel like it would make sense to have a Free monoid class with just (<>), and a class for Quotient sets with some function which returns the representative
16:15:08 <dmwit> It surely feels like it to me.
16:15:26 <jle`> Logio: free ... monoid ... class?
16:15:31 <jle`> like a typeclass?
16:15:32 <dmwit> erisco: How about the `AtMostMAX_INT` operation...? =)
16:15:33 <nshepperd> if forall (f :: a -> b), b such that Monoid b. foldMap f :: t a -> b is a monoid morphism, then the Monoid instance for t is concatenation
16:15:50 <erisco> dmwit, not even AtMostMAX_INT+1
16:16:00 <Logio> jle`: yeah, meaning a class with just the concatenation
16:16:15 <nshepperd> monoid homomorphism, I mean
16:16:15 <jle`> that's what Semigroup is, isn't it?
16:16:37 <dmwit> erisco: Wow! I'm impressed. The operation coincides with concatenation for any input and observation pair you will ever make, yet it still doesn't feel like concatenation to you?
16:16:51 <Logio> jle`: don't you still identify elements with semigroup?
16:16:59 <jle`> what do you mean by identify elements
16:17:22 <jle`> like, check them for equality?
16:17:32 <jle`> no, only if the type itself has an Eq instance, maybe
16:17:33 <dmwit> erisco: Not only that, even ignoring the practical considerations, it shares many of the same properties even in theory-land.
16:17:55 <Logio> jle`: meaning, giving a representative of the class, i.e. reducing the element to a unique one
16:18:00 <erisco> dmwit, yeah, it doesn't... how can I convince you?
16:18:06 <nshepperd> List concatenation is concatenation, because: foldMap f (xs ++ ys) = foldMap f xs <> foldMap f ys
16:18:15 <jle`> not sure what you mean by reducing the element to a unique one
16:18:17 <jle`> reducing what element?
16:18:34 <jle`> anyway, to answer what your question might be, class Semigroup a where (<>) :: a -> a -> a
16:18:35 <dmwit> erisco: I believe you. I don't need convincing. But I have a hard time "feeling" the way you feel.
16:18:39 <Logio> jle`: but okay, semigroup does have sconcat which seems to fit the bill
16:18:57 <Logio> I hadn't realized that it is separated in semigroup
16:18:59 <jle`> i'm not sure what your question is but opefully that answers it
16:19:01 <dmwit> erisco: Or rather: I have a hard time imagining feeling the way you feel and still believing there might be an operation other than concatenation that "feels" like concatenation.
16:19:15 <erisco> nshepperd, swap out ++ for <|> and it is a nice property of Foldable
16:19:16 <nshepperd> dmwit: ^^ your bounded concatenation doesn't satsify the above monoid morphism property
16:19:24 <jle`> Logio: sconcat isn't technically a part of the definition of a semigroup
16:19:32 <jle`> it's just in the Semigroup typeclass for optimization reasons
16:19:36 <erisco> nshepperd, I know Foldable aint Alternative but when they do come together that is a nice thing
16:19:43 <jle`> the only thing a semigroup has is an associative combining operator
16:19:54 <jle`> s/combining/binary
16:19:57 <erisco> Alternative is a bit weird... still haven't figured out why it is where it is in the class hierarchy
16:20:06 <jle`> there is no identity element, if that's what you mean?
16:20:11 <dmwit> nshepperd: Yes, it's true, my Semigroup is not the free Semigroup.
16:20:42 <jle`> Logio: also, it's not a free monoid
16:20:43 <Logio> jle`: I'm talking about the equality in quotient sets
16:20:45 <nshepperd> i suppose infinite lists don't satisfy that either though
16:20:54 <erisco> dmwit, well you either need to get more imagination or more stupid, one of the two :P
16:21:07 <Logio> jle`: and you're right, that is not the free monoid 
16:21:23 <nshepperd> but perhaps that is correct! because concatenating infinite lists sort of *is* impossible
16:21:24 <jle`> we actually have a free monoid class, roughly
16:21:55 <nshepperd> like, you can't really put something at the end of an infinite list
16:22:19 <erisco> just like you cannot smell the colour blue
16:22:34 <Logio> jle`: which class are you referring to?
16:22:34 <EvanR> no?
16:22:35 <erisco> unless you have synesthesia
16:22:36 <dmwit> nshepperd: You might enjoy https://hackage.haskell.org/package/fmlist-0.9/docs/Data-FMList.html if you haven't seen it already. =)
16:22:39 <EvanR> ok
16:23:28 <nshepperd> but for a strict container like Seq or an array, the property works
16:23:41 <nshepperd> in all cases
16:23:51 <jle`> Logio: if the free monoid on 'a' is [a], then Foldable essentially gives you a natural transformation from container of a's into a free monoid on a's
16:24:02 <jle`> and nothing more, nothing less
16:24:11 <nshepperd> and also I suppose this fmlist thing :)
16:25:11 * hackagebot concrete-haskell 0.1.0.13 – Library for the Concrete data format. – https://hackage.haskell.org/package/concrete-haskell
16:25:25 <nshepperd> erisco: it's not a law i would require for foldable, because there are certainly cases where different behaviour is useful. like <|> for Maybe
16:25:31 <dmwit> jle`: (It's actually a minor lie that [a] is the free monoid on a. See my previous link for some discussion.)
16:25:55 <jle`> i do agree that it's a lie, so i qualified it with a conditional hehe
16:26:25 <Logio> jle`: that does seem about right though
16:26:40 <jle`> also if you believe that the free monoid on 'a' is (forall m. Monoid m => (a -> m) -> m), then Foldable also gives you that, too
16:27:05 <jle`> with flip foldMap :: t a -> (forall m. Monoid m => (a -> m) -> m)
16:27:39 <jle`> toFreeMonoid = flip foldMap, apparently
16:27:42 <erisco> nshepperd, it requires  a <|> b = a <> b  and  empty = mempty
16:28:32 <Logio> jle`: isn't that actually fromFreeMonoid?
16:28:33 <jle`> erisco: from how i've internalized it, Alterantive is a * -> * Monoid typeclass, like Monoid1.  it just has n Applicative constraint because why not i guess
16:28:45 <jle`> Logio: no, because 't' might not be a free monoid
16:28:47 <erisco> nshepperd, though if that's true you just swap <|> and <> around willy nilly... so I must be misremembering what we came up with =\
16:29:14 <jle`> we should just rename Alternative to be Monoid1
16:29:49 <Logio> jle`: but you cannot make a free monoid out of a non-free one, since you cannot in general reverse the identification
16:30:06 <erisco> no, because of the Applicative super class ... I dunno if the inventors were into parser combinators or what
16:30:12 <nshepperd> erisco: 'foldMap f (xs <|> ys) = foldMap f xs <> foldMap f ys' is a good law for "containers" imo, but it wouldn't work for everything in the intersection of Foldable and Alternative
16:30:16 <jle`> erisco: they were
16:30:42 <jle`> Logio: it's not a conversion, it's a natural transformation
16:30:46 <erisco> nshepperd, maybe we were not working with <|> and <> together but just <|>
16:30:49 <Logio> jle`: I would actually say that t is a free monoid
16:31:01 <jle`> for Foldable t?
16:31:04 <erisco> fold (a <|> b) = fold a <|> fold b
16:31:07 <jle`> there are instances where it's clearly not
16:31:24 <Logio> such as?
16:31:30 <erisco> that above ^ may have been what we came up with
16:31:43 <nshepperd> erisco: that still wouldn't work. the problem is useful instances like Either e that just throw one of a or b away
16:32:32 <erisco> nshepperd, Either is not an Alternative...
16:32:50 <jle`> Logio: Maybe, Map k, Identity, etc.
16:32:59 <Tuplanolla> I thought I already made you read this, Logio: http://comonad.com/reader/2015/free-monoids-in-haskell/
16:32:59 <jle`> pretty much the vast majority of Foldable instances
16:33:04 <erisco> maybe they have an instance with a context
16:33:06 <nshepperd> > Left "hi" <|> Left " there"
16:33:08 <lambdabot>  Left " there"
16:33:21 <nshepperd> gross, that's not the instance i wanted
16:33:24 <nshepperd> oh well
16:33:25 <jle`> yes
16:33:27 <jle`> it's literally the worst
16:33:33 <jle`> it's defined as an orphan instance in containers, heh
16:33:36 <jle`> er, in transformers
16:33:55 <erisco> wasn't trying to say you can't get one with a context
16:34:02 <jared-w> The weird part for me is there's a valid Applicative instance of "Validation" (like Either but collects its errors together) but there's not a valid Monad... That really screwed with me
16:34:31 <jle`> jared-w: by default i assume that Applicatives don't have valid Monad instances
16:34:36 <jle`> the ones with Monad instances are the exception
16:34:51 <edwardk> Erisson: Maybe has a monoid completely disconnected from its <|>
16:34:56 <erisco> I don't know what to import for that instance
16:35:04 <jle`> erisco: it's in transformers
16:35:11 <edwardk> Er erisco (autocorrect)
16:35:22 <erisco> edwardk, yeah, I know
16:35:28 <Logio> jle`: hmm
16:36:03 <jle`> jared-w: a Monad instance would actually make Validation considerably less useful, since it's necessarily short-circuitng
16:36:39 <erisco> jle`, heard ya but it has a bunch of modules in it
16:36:42 <jle`> so Validation might be an example of a situation where you would deliberately want to avoid having your type be a Monoid
16:37:03 <jle`> erisco: fair enough...dealing with orphan instances in haskell is pretty bad
16:37:07 <jared-w> Right, that makes sense.
16:37:13 <jle`> it might be in http://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-Error.html
16:37:16 <edwardk> ZipList is another good example of an Applicative you can't extend to a Monad
16:37:54 <jle`> Validation might be one that's anti-monadic, by design
16:38:00 <jared-w> It was a bit of a mind bender to me because I'm used to going 'up' in the hierarchy to get more power (you can do more things with monad than monoid, etc) but in reality Monad is less general than Applicative
16:38:04 <edwardk> optparse-monad would lose a ton of power as well :)
16:38:07 <EvanR> anti-monads eh
16:38:12 <Logio> jle`: in Foldable, you are actually creating a quotient set of the free monoid each time you introduce a binary operation, no?
16:39:05 <jle`> jared-w: in a way, for the type to be "powerful enough" to support Monad, it has to give up much of its useful properties/API
16:39:37 <erisco> *maybe* we said  fold (x <> y) = fold x <> fold y
16:39:47 <geekosaur> jared-w, I think of it as to gain more power in one dimension, you must lose it in others
16:39:47 <Logio> any structure you are folding is still roughly equivalent to the free monoid (since you are essentially inserting the binary operations in between each element)
16:39:49 <jle`> Logio: not sure what that means
16:40:16 <Logio> jle`: you're not familiar with quotient sets?
16:40:19 <edwardk> Jared-w can do more with implies there are fewer things you can support. There are more Applicatives than Monads, but you can do more with an individual monad instance. The adjunction between syntax and semantics is contravariant.
16:40:22 <jared-w> geekosaur: that's a good way to think of it, thanks.
16:40:32 <jle`> i am familiar with quotient-sets, but not sure waht you mean by the introdution of a binary operation
16:40:35 <jle`> what is the type of this operation
16:40:37 <jle`> in relation to Foldable?
16:40:51 <jle`> what sort of binary operation are you talking about? etc.
16:40:51 <Logio> jle`: the function argument for foldr/foldl
16:41:09 <jle`> ok that is much needed context; we weren't talking about foldr or foldl at all, heh
16:42:00 <Logio> foldMap is just the same with the operation being given by the monoid instance
16:42:28 <Logio> or sorry, fold
16:42:43 <Logio> foldMap then has the extra step of selecting the monoid
16:44:30 <Logio> but I'm getting the feeling that if there should exist a class for free monoids, it's either a superclass of Foldable or equivalent to it
16:45:44 <Logio> (disregarding any issues of infinite structures)
16:46:40 <edwardk> > Data.Foldable.fold (S.fromList [Just [2], Just [1]])
16:46:42 <lambdabot>  Just [1,2]
16:47:04 <edwardk> Data.Foldable.fold (S.fromList [Just [2]]) `mappend ` Data.Foldable.fold (S.fromList [Just [1]])
16:47:18 <edwardk> > Data.Foldable.fold (S.fromList [Just [2]]) `mappend` Data.Foldable.fold (S.fromList [Just [1]])
16:47:21 <lambdabot>  Just [2,1]
16:47:30 <edwardk> ^- erisco
16:48:15 <edwardk> Foldable doesn't have a law that fold is a monoid homomorphism
16:48:24 <erisco> ... I ... I know
16:48:28 <erisco> I don't know how this got started :P
16:48:38 <edwardk> me neither. just trying to say why not
16:48:50 <jared-w> I love discussions like this though
16:48:56 <jared-w> "hey what's 2+2"
16:49:07 <erisco> I was just saying that I was having a conversation a while ago that was something involving Foldable, Alternative, and Monoid, and I was trying to recall the property we came up with and were happy with
16:49:16 <edwardk> jared-w: 2+2 is 300 pages of russell and whitehead ;)
16:49:16 <jared-w> haskell: "So what we have here is a simple monoid which is really a monad in the category of endomonoidfunctors..."
16:49:37 <erisco> it was not a law, it was just a property you *might* have that brought the two classes together in some way
16:49:52 <jared-w> edwardk: I don't care what anyone says, I enjoyed the existence of that book tremendously and I was sad their life's work got wrecked by Godel
16:51:26 <edwardk> erisco: yeah lots of folks have proposed various laws for Foldable like that that all fall apart under inspection
16:53:07 * hackagebot mixed-types-num 0.3 – Alternative Prelude with numeric and logic expressions typed bottom-up – https://hackage.haskell.org/package/mixed-types-num
16:53:10 <jared-w> I find that amusing. Like, so much of Haskell's typeclasses come from category theory and have laws and then there's things like foldable where it's basically "so we write this kinda recursion pattern all the time and we hate writing it, so let's abstract it out into something called a fold and bam, who cares how mathy-proof'd it is, it's useful"
16:53:45 <geekosaur> ob Num
16:53:48 <edwardk> jared-w: its basically Traversable needs all this stuff for mapM, but what does mapM_ really need? oh just the ability to smash stuff together with a monoid, it never needs to construct a new thing
16:53:59 <erisco> edwardk, what is troublesome is how clunky it is to extend classes with more laws in Haskell...
16:54:08 <Logio> edwardk: if you've been following my discussion with jle`, what's your take on Foldable being actually a free monoid?
16:54:29 <erisco> if you could imagine Foldable extended with that homomorphism as a law, then what do you have? an empty class with some docs, I guess
16:54:36 <edwardk> i kinda tuned in near the end of it when something tripped a keyword trigger of mine
16:54:55 <jle`> Logio: did you see the link that Tuplanolla sent you multiple times
16:55:33 <Logio> jle`: hm? when? :o
16:55:43 <Tuplanolla> Once here and once at your office, Logio.
16:55:44 <edwardk> i'm not sure what you mean by Foldable being a free monoid, it provides some tree structure worth of 'a's but no way to modify that shape it gives, except to extract it via some other monoid
16:55:53 <jared-w> edwardk: so does Traversable have laws and a formal-ish foundation in Math, then?
16:55:58 <jle`> oh huh sorry, i had thought it was written by edwardk
16:56:09 <jle`> so your question to edwardk would have been a little funny
16:56:21 <jle`> but actually it's just published on a blog that i thought edwardk was the main author of
16:56:23 <edwardk> a free monoid of as would be something like newtype Free p a = Free { runFree :: forall r. Monoid r => (a -> r) -> r } .   then Free Monoid is a real "free monoid" in haskell
16:56:38 <edwardk> jared-w: traversable has some pretty strong foundations
16:56:58 <edwardk> https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
16:57:12 <Logio> edwardk: well, flip foldMap ~ runFree
16:57:17 <edwardk> documents the traversable laws quite well, and all of the intermediate questions it raises about if the laws are enough were resolved later
16:57:32 <edwardk> Logio: yes, but the key is Free Monoid is a Monoid itself.
16:57:36 <edwardk> a Foldable f isn't
16:58:04 <jared-w> sweet, thanks.
16:58:05 <edwardk> I have no way to glue f's together so 'f a' isn't a monoid, and fold isn't necessarily a monoid homomorphism (and strong counter-examples exist)
16:58:30 <dolio> foldMap is Foldable f => f a -> Free Monoid a
16:58:51 <jared-w> But if traversable is "stronger" than foldable, why even have foldable? Was it purely to give mapM_ the most general applicability possible?
16:59:03 <dolio> Or, flip foldMap is.
16:59:06 <edwardk> [] are the usual free monoid in the math sense because you have only finite trees build out of the unit and binary operation, but in haskell you can build up infinite such trees, but can only reason about association a finite number of times.
16:59:25 <edwardk> Foldable f is basically that you have a 'toFreeMonoid' method, not that you _are_ a free monoid'
17:00:04 <edwardk> [] in haskell are too big to be the classic free monoid (they allow infinite right recursion)
17:00:26 <Logio> yeah I know, I did some thinking on that a while back when doing the Clif toy library
17:00:29 <edwardk> but they are too small to be the 'free monoid' for haskell, which could allow infinite recursion down any path
17:01:43 <Logio> btw, I'm still wondering how Coalgebra.Geometric in Numeric.Algebra actually works
17:02:10 <edwardk> hah
17:02:12 <Logio> I feel like it's a sort of masterpiece of Haskell clarity and obscurity
17:02:16 <edwardk> haven't thought about that in a long time
17:02:36 <edwardk> it made sense to me at the time
17:02:40 <Logio> I had to implement my own library before I could make some sense of it
17:03:02 <edwardk> interchange scattering with gathering in geometric algebra and you get that construction
17:03:10 <edwardk> you can actually do some of what you do with geometric algebra with it
17:03:13 <edwardk> but with a reduced cost
17:03:29 <Tuplanolla> Is that the one with the de Bruijn multiplication table?
17:03:45 <Logio> Tuplanolla: that's the one
17:03:57 <edwardk> hah
17:04:02 <edwardk> i was in rare form that day
17:05:34 <erisco> dmwit, my "don't throw stuff away" idea runs into trouble because mempty <> x = x ...
17:05:52 <Logio> edwardk: don'
17:05:56 <edwardk> i pretty much never use geometric (co)algebra for real work, i just use it to check other results
17:06:13 <Logio> *don't know what you are referring to with gathering and scattering
17:06:33 <erisco> dmwit, I was thinking something along the lines of  reappend f (a <> b) = f a b   plus whatever other laws... essentially stick an 'f' wherever a <> was
17:06:54 <edwardk> logio: look at the operation of multiplication vs. comultiplication
17:06:58 <erisco> dmwit, but, that isn't a sensible thing due to the identity =\
17:07:47 <Logio> edwardk: okay, that's exactly the rabbit hole I've not gone down far enough to understand
17:07:49 <edwardk> you get similar comparisons with the trigonometric coalgebra and the complex algebra
17:08:26 <erisco> goes to show you can't invent just anything
17:09:04 <Logio> I get coallergy at some point every time I dive too deep
17:09:19 <average> is Haskell used at NASA?
17:09:40 <erisco> is Haskell used at SpaceX?
17:09:50 <average> well.. is it?
17:10:17 <edwardk> average: yes
17:10:37 <average> for what
17:10:59 <average> for the actual code running on that spaceship?
17:11:04 <average> or .. other stuff?
17:11:10 <edwardk> http://cufp.org/2014/michael-oswald-haskell-in-the-misson-control-domain.html
17:11:13 <edwardk> mission control
17:11:23 <edwardk> http://cufp.org/2014/bjrn-buckwalter-haskell-tools-for-satellite-operations.html
17:11:26 <edwardk> satellite operations
17:12:22 <edwardk> satellites dont tend to run haskell themselves. rad hardened hardware tends to come with very little space to work with
17:12:58 <edwardk> on the other hand you can throw it in a microwave while it is running and just lose a few % performance ;)
17:14:15 <erisco> well that's good. I'll have something to do while I am tanning
17:15:20 <average> so am I understanding correctly, Haskell code is used at SpaceX but not for actual mission critical stuff?
17:15:42 <erisco> it surprises me something as modern as Haskell would be used by such an ancient organisation
17:15:53 <erisco> with their decades of legacy and practices
17:16:40 <average> SpaceX is not new afaik
17:16:50 <edwardk> average: haskell is not suited for low memory, or realtime applications
17:17:04 <average> oh, then what is it suited for?
17:17:05 <edwardk> average: there are frameworks in haskell for specifying such
17:17:37 <average> math code that should really have been written in C, right?
17:18:33 <edwardk> average: you are operationally indistinguishable from a troll at the moment
17:18:59 <average> ok here's a more honest assessment
17:19:13 <average> the only thing i've seen Haskell to shine it, like honestly, is building symbolic computation packages
17:19:17 <erisco> always state the equality you are using when identifying a troll
17:19:45 <boj> average: maybe a more productive conversation would be to explain your domain and see if haskell is a good match or not for you
17:19:48 <mnoonan_> erisco: type class instances have to be globally unique.
17:19:49 <average> for example if SymPy were written/ported in Haskell, I'd find that to be a very natural/good decision
17:20:06 <erisco> mnoonan_, sorta
17:20:20 <mnoonan_> erisco: come on, you can’t give it to me for a throwaway joke? :)
17:20:39 <erisco> I, uh, hrm... missed it
17:21:32 <edwardk> average: i've seen haskell used for everything form computer vision to robotic motion planning to financial risk assessment to flying quadrotors in formation to writing compilers to movie special effects to web servers and restful apis. you're welcome to your biases, i just think they are ill founded.
17:22:33 <jared-w> #rekt
17:22:51 <edwardk> whenever i need haskell to do something that the gc pauses would give me pause about handling i write an embedded domain specific language for whatever it is i want to work with define a deep embedding that compiles that down to LLVM or CUDA or OpenCL or whatever, and get on with my day.
17:23:20 <benzrf> nerd
17:23:53 <jared-w> How would you even write a deep embedding? Is that just a mini compiler?
17:24:02 <Cale> average: Where I work, we're using it to develop web and mobile applications. It's really nice to have Haskell on both your frontend and backend, so that you can share types and serialisation code between them, and never have to worry about JSON encoding mismatch bugs.
17:24:03 <edwardk> yes
17:24:17 <boj> Cale: amen
17:24:27 <erisco> Cale, really? wow, that's a complicated setup
17:24:29 <edwardk> a compiler where i can take full advantage of everything i know about the domain
17:24:30 <Cale> (which were like 90% of the bugs on some other web application projects I've worked on)
17:24:49 <average> aren't json schemas used to avoid those mismatches?
17:25:14 <average> how come one needs to just rewrite all their code in Haskell only to get those mismatches dealt with?
17:25:18 <Cale> average: If you're using Javascript on the frontend, nothing will really help you statically guarantee much
17:25:34 <Cale> It's not *only* for that reason that we use Haskell on the frontend
17:25:42 <dolio> Because all the linting and whatnot in all of the JS community is basically a joke.
17:25:52 <average> and about webdev, isn't PHP the most productive language for that? I imagine Haskell would cost a ton of money to develop in(a lot of time, and debugging)
17:25:53 <erisco> i.e. you compile your program and you don't know if it actually reads or writes the JSON correctly
17:25:56 <arahael> Cale: Apparently there is a technique used for Purescript on the frontend, basically a way of recompiling haskell backend types for the purescript frontend.
17:26:06 <robertkennedy> :t fmap fmap fmap fmap fmap fmap fmap
17:26:07 <lambdabot> (Functor f, Functor f1, Functor f2) => f2 (a -> b) -> f2 (f1 (f a) -> f1 (f b))
17:26:29 <jared-w> average: php is a joke when it comes to productivity
17:26:41 <erisco> average, so who sent you over here to cause a rabble? can't imagine you're laughing all by yourself
17:26:51 <benzrf> php is flaming garbage
17:26:59 <jared-w> There was a thread on r/haskell just a few days ago about how people saved *tons* of computing resources, time, pain and effort rewriting php infrastructure into Haskell
17:27:24 <Cale> We also use it because of reflex and reflex-dom, which makes GUI code a hell of a lot less painful to write
17:28:00 <arahael> Cale: I assume you use ghc-js for the frontend? What's that like, in practice?
17:28:12 <Cale> arahael: Yeah, for the web frontend
17:28:18 <benzrf> i want to know who Cale works for that uses ghcjs for a production frontend
17:28:20 <Cale> It's pretty good
17:28:27 <Cale> benzrf: Obsidian Systems
17:28:37 <Cale> benzrf: Didn't you know that? :)
17:28:46 <Cale> benzrf: I'm working for Ryan
17:28:48 <benzrf> im bad at remembering that kind of thing :V
17:28:51 <benzrf> "Cutting edge software solutions"
17:28:54 <benzrf> grooooaaaan
17:29:07 <jared-w> benzrf: but is it /webscale/?
17:29:10 <erisco> Cale, I can't imagine the headache for the mobile side
17:29:22 <benzrf> hey, isnt your page's background image the same images used on metalsmith's page
17:29:27 <boj> we too are using it for the frontend/backend code sharing and reflex/reflex-dom ease of use. the more interesting system is replacing a clunky telecom network provisioning service which needs to go out and touch a dozen different pieces of hardware via a handful of network protocols, and be configurable enough to add/change how the provisioning happens. type safety for the win there
17:29:29 <Cale> erisco: It's... surprisingly manageable. I mean, I'm not going to say it's not a headache
17:29:32 <erisco> Cale, how long did you guys spend writing and maintaining bindings?
17:29:39 <benzrf> hm, maybe its just similar kinds of parts
17:29:42 <Cale> erisco: But after the few weeks of pain
17:29:59 <arahael> Cale: Nice.  I've been an (unproductive) fanboy for purescript, but the npm hell really gets to me.  ghc-js + stack  is seriously attractive.
17:30:01 <Cale> erisco: Most of our codebase can be shared between the web and mobile application.
17:30:05 <crucify_me> hi obviously I need more guidance here. First, why does the (a -> a) part go with Fractional and not Num? https://ptpb.pw/bSK2
17:30:22 <crucify_me> referring to last two :t inquiries
17:30:24 <jared-w> arahael: hasn't yarn been helping with that?
17:30:43 <Cale> erisco: and the mobile version actually tends to run faster than the web version on a desktop machine, just because Javascript.
17:31:02 <crucify_me> I'm just playing around with identity to see what it does to the signature
17:31:08 <Cale> (Native ARM code on a phone beats Javascript running on a desktop)
17:31:23 <dmwit> crucify_me: I wonder: what type did you *expect* to get?
17:31:25 <dolio> crucify_me: The Num comes from the 5.
17:31:47 <erisco> Cale, I see companies like Xamarin trying to maintain bindings for C# and it seems a struggle to keep head above water
17:31:57 <jle`> crucify_me: check out the type for `xyl 4 id`
17:31:59 <Cale> arahael: Yeah, and it's *really* nice to just be able to pull stuff off of hackage and use it on the frontend
17:32:00 <dolio> The 'Fractional (a -> a)' comes from using id as one of the arguments to a function that requires something fractional.
17:32:04 <erisco> you've got things changing in Android every version, on top of whatever bugs you currently have
17:32:05 <arahael> jared-w: I haven't used yarn. Just the suggested 'bower'.  I plan to get acquanted with 'psc-package' next, and basically moving away from npm.
17:32:05 <geekosaur> crucify_me, you are using id as if it were a number
17:32:23 <geekosaur> as an argument to (/) ultimately, so Fractional constraint
17:32:27 <Cale> erisco: We do *very* little binding to the phone-specific APIs, just the stuff that we've needed thus far.
17:32:30 <jle`> crucify_me: xyl :: a -> a -> a, so if you give 'id' as an argument, it becomes xyl :: (a -> a) -> (a -> a) -> (a -> a)
17:32:38 <geekosaur> and the constrain ison the type of id, so Fractional (a -> a)
17:32:40 <arahael> Cale: "on the phone" - you mean, Android? Not iOS?
17:32:45 <erisco> Cale, you're using all the native UI stuff though, yes?
17:32:48 <Cale> Both Android and iOS
17:32:49 <edwardk> robertkennedy: flip flip flip = flip flip flip flip
17:32:53 <arahael> Cale: Haskell on iOS?
17:33:00 <Cale> arahael: mhm
17:33:02 <crucify_me> all interesting
17:33:04 <edwardk> fmap fmap fmap fmap fmap fmap = fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:33:16 <arahael> edwardk: Stop with the fmap'ing! 
17:33:21 <crucify_me> I can roll with that thanks All. next thing....
17:33:24 <jle`> crucify_me: a good first step is just to try to unify the types
17:33:26 <jle`> by hand
17:33:32 <Cale> erisco: Well, sort of. We're using a web view in both cases, but native code controls the contents of the DOM.
17:33:49 <jared-w> any multiple of 3 fmaps can be chained together iirc
17:33:54 <jared-w> :t fmap fmap fmap
17:33:56 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
17:34:03 <ab9rf> fmip fmap fmop
17:34:05 <edwardk> hey its a fixed point, i can add as many as i want as long as i do so in quantities of 4 after the initial 6
17:34:06 <erisco> Cale, ohhh like phone gap then
17:34:09 <arahael> Cale: I thought there were issues compiling Haskell to native iOS?
17:34:23 <dmwit> jared-w: Any number of fmaps can be chained together.
17:34:41 <erisco> Cale, that simplifies things a lot, but the opinion I encounter is that the native UIs are better
17:34:51 <jared-w> whoops, disregard what I said then; I was trying to allude to the fixpoint of fmap but said so poorly
17:34:54 <edwardk> jared-w: fmap `fmap` fmap      gives you nesting, but flat like i gave above, it hits a fixed point at 6
17:35:11 <edwardk> wrapping back around at 10
17:35:28 <noexcept_> "Furthermore, this will also happen if the order of output is" (http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf page 10)
17:35:31 <noexcept_> reversed, which is much more difficult to arrange in an impure language. Indeed,
17:35:32 <dmwit> :t fix fmap
17:35:33 <lambdabot> error:
17:35:33 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ f b
17:35:33 <lambdabot>       Expected type: (f a -> f b) -> f a -> f b
17:35:36 <Cale> arahael: Well... it's not trivial, but we have a bunch of nix stuff that does it reasonably well. The mobile stuff is in various stages of getting open sourced as part of reflex-platform... I forget what's actually on the appropriate branch on github
17:35:44 <noexcept_> woops, my irc client pasted multiple lines
17:35:44 <edwardk> > fix error
17:35:47 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:36:26 <noexcept_> anyway, that paper says if you use monads you can write an evaluator that outputs a trace in reverse order as the evaluation is being performed
17:36:41 <robertkennedy> :t flip flip flip
17:36:41 <jared-w> noexcept_: I set mine to allow multiple lines in the input box to prevent that. Then I can manually remove the newlines before entering
17:36:41 <arahael> Cale: Right, so you're primarily using ghc-js, then?  My hope with purescript, is that it becomes convenient to use as a multi-platform language. (Ie, via pure11)
17:36:42 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
17:36:49 <arahael> Cale: Which is a purescript -> actual C++.
17:36:59 <dmwit> > error (error "")
17:37:01 <lambdabot>  *Exception: *Exception:
17:37:03 <dmwit> > (error . error) ""
17:37:05 <lambdabot>  *Exception: *Exception:
17:37:15 <arahael> Cale: But I find I am just not productive in it. :(
17:37:20 <Cale> arahael: For the web, we're using GHCJS
17:37:27 <Cale> arahael: For mobile, we're using GHC
17:37:51 <Cale> and, well, we could also do desktop applications with the same infrastructure, for which we'd also use GHC
17:37:58 <noexcept_> that seems misleading, because the complete expression is evaluated and printed out, and only afterwards the parts of the expression which have been kept around as garbage (due to lazy evaluation reusing results) are printed out
17:37:58 <arahael> Cale: Does that mean you now have GHC compiling to iOS 64-bit as well as 32-bit binaries?
17:38:17 <arahael> Cale: And that Apple accepts it?  Do you have an article that writes this up?
17:38:19 <erisco> Cale, our other killer was deploy time (to the phone)... how long does it take you guys?
17:38:23 <Cale> arahael: I... think so? I'm not really the right person on our team to ask that
17:38:56 <Cale> arahael: Apple does accept it, but they dragged their feet for a good long while the first time we submitted, hah
17:39:02 <benzrf> Cale: i dont suppose obsidian is offering internships next summer :>
17:39:12 <arahael> Cale: That's a bit sucky.
17:39:18 <Cale> benzrf: Ask Ryan about it, we have an intern presently
17:39:24 <noexcept_> so it's not really outputting the trace in reverse as the evaluation is being performed, it's doing so after the evaluation is done
17:39:27 <benzrf> aight
17:39:50 <Cale> arahael: Now the turnaround time on a deployment is similar to other apps seem to get though.
17:39:50 <arahael> Cale: Please do consider getting  your team to do a writeup once they have time - there isn't much on using haskell on native ARM, and I actually thought it was basically not supported naymore.
17:40:11 <danilo2> Hi! :) I'm trying to understand the meaning of alignment in Storable instances. Ad far as I know proper alignment depends on the procesor is used, so what should I use here if I do not know what architecture hte program will be run on?
17:40:14 <arahael> Cale: (And by "native ARM", I meant, "native ARM on iOS")
17:40:15 <Cale> arahael: We're planning on releasing some stuff which should eventually make it reasonably easy
17:40:21 <robertkennedy> :t flip flip flip (\x f -> True) 5
17:40:23 <arahael> Cale: Sweet.
17:40:23 <lambdabot> Bool
17:40:34 <jared-w> I remember seeing a few posts sometime about cross-compiling... Cale I'd love to see those when you get 'em out :D
17:41:06 <crucify_me> ok so since the id function is ultimately* applied to (/) , in both cases (a -> a) is listed with Fractional. ?  
17:41:43 <robertkennedy> Is there any higher kinded `(.)`? Ie for the common `fmap f = fmap . fmap f`
17:41:48 <dmwit> crucify_me: Right. Also, as a terminology thing, I think most people use "applied to" in the other order: `(/)` is applied to `id`.
17:41:56 <jle`> crucify_me: you can always "expand out" function calls as their body
17:42:02 <jle`> crucify_me: so if you do xyl 5 id
17:42:03 <dmwit> robertkennedy: Compose does that
17:42:07 <jle`> you see that xyl x y = x / y
17:42:13 <jle`> crucify_me: so xyl 5 id = 5 / id
17:42:15 <dmwit> ?hoogle Compose
17:42:15 <lambdabot> module Data.Functor.Compose
17:42:15 <lambdabot> Data.Functor.Compose newtype Compose f g a
17:42:15 <lambdabot> Data.Functor.Compose Compose :: f (g a) -> Compose f g a
17:42:22 <crucify_me> yes got that dmwit always pondering on that. (dyslexia)
17:42:27 <crucify_me> thanks
17:42:37 <erisco> danilo2, well afaik it is actually a memory thing because they can't have so many wires as to address every bit
17:42:44 <dmwit> :t \f -> fmap . fmap f -- err, hm, perhaps this isn't Compose
17:42:46 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
17:42:55 <jle`> yeah compose would be (fmap . fmap)
17:42:59 <dmwit> :t \f -> fmap (fmap f) -- did you mean this instead?
17:43:00 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
17:43:11 <crucify_me> jle`, interesting thanks, good pointer
17:43:26 <erisco> danilo2, and so similarly not every offset either
17:43:55 <Cale> arahael: there's a bunch of stuff in here, but... you should probably talk with Ryan about it if you want to try it, I'm not sure exactly how to get things set up from scratch https://github.com/reflex-frp/reflex-platform/tree/mobile
17:43:57 <robertkennedy> Yeah sorry I meant `fmap (fmap f)`, good catch
17:44:03 <crucify_me> actually I'm glad I tried that because that is all informative.
17:44:13 <Cale> arahael: He hangs out in #reflex-frp
17:44:25 <dmwit> robertkennedy: So yeah, `Compose` should do the trick for you. It's even `Applicative` when the two arguments are.
17:44:37 <Cale> Not online right at the moment, but often
17:45:06 <mnoonan_> so I want to add the ability to insert keys into maps in my justified-containers library; would anybody mind giving some feedback about ‘inserting’ here? https://github.com/matt-noonan/justified-containers/blob/master/src/Data/Map/Justified.hs#L308
17:45:17 <mnoonan_> (also see example4 in the Tutorial module)
17:45:26 <crucify_me> from here, to category theory hehe
17:45:29 <danilo2> erisco: sure, I think the solution is both related to memory as well as modern processor optimization. However If I've got a structure with couple of Ints and for exmple Char, what aligment should I use? I see thah Haskell uses 8 for Int aligment and 4 for Char one
17:45:34 <robertkennedy> So maybe fmap wasn't the case I meant. The general case I'm looking at is probably more like `f = show . g` where I want g and f to differ only in output type
17:45:50 <jle`> why don't you show us a specific case
17:45:57 <jle`> and we can help you with that one?
17:46:15 <jle`> do you mean f = fmap show ?
17:46:39 <jle`> er, `show . g` should be sufficient, right?
17:46:51 <erisco> danilo2, there is a maximum alignment and this is what anything can be stored at
17:47:27 <erisco> danilo2, so if you maximum alignment is, say, 16, then your structure can start at a 16 boundary and then anything can follow
17:47:44 <erisco> if you have a 4 byte something followed by a 1 byte something, you probably want the 4 byte followed by the 1 byte
17:47:57 <erisco> likely because your 4 byte thing won't work at a 16+1 alignment
17:48:03 <robertkennedy> ... imagine you have some functions g and `f = show . g`, initially written so `g :: * -> *`. Now I want to make `g :: * -> * -> *`, and I want f to also now take two inputs
17:48:15 <erisco> that's all the insight I can give you though, sorry... haven't used Storeable in Haskell
17:48:33 <jle`> is g a type constructor here
17:48:44 <jle`> and is show some type variable ...?
17:48:56 <jle`> what (.) are you referring to?
17:49:09 <danilo2> erisco: so in fact if Ive got 3 ints and 1 byte then the aligment wshould be generally the same as ints one?
17:49:17 <robertkennedy> g is a function, show is a function
17:49:27 <jle`> oh
17:49:32 <jle`> you probably don't mean g :: * -> * then, do you?
17:49:45 <robertkennedy> Of course not, sorry
17:49:50 <erisco> danilo2, yeah, as long as your 1 byte thing is at correct alignment
17:49:57 <jle`> so, what do you mean?
17:49:58 <duncan_bayne> Hey, quick question - how can I report bugs on individual packages at https://hackage.haskell.org/ ?
17:50:09 <duncan_bayne> I've found the issues list for Hackage itself
17:50:18 <robertkennedy> ... is it not clear?
17:50:20 <jle`> duncan_bayne: each package should have a link to its bug tracker
17:50:48 <jle`> robertkennedy: there are some different possible interpretations
17:50:48 <danilo2> erisco: hm, ok, thank you, that clarifies a bit everything!
17:51:05 <robertkennedy> `g = (+1); f = show . g`. Refactor to `g = (+)` without breaking f
17:51:25 <duncan_bayne> jle`: Not that I can find on https://hackage.haskell.org/package/hXmixer
17:51:32 <jle`> and do you want to use the same operator in each case?
17:51:44 <jle`> or are you looking for an operator that isn't (.)
17:52:09 <danilo2> erisco: one more question - in fact the "core" question for me. I want to store and operate on custom haskell structures as fast as posdible (storing them in unboxed / storable) vector and accessing their fields as fast as possible
17:52:16 <jle`> you could do f x = show . g x
17:52:30 <danilo2> erisco: is using Storable Vectors the prefered approach or do you know about something more performant than this 
17:52:32 <boj> duncan_bayne: in that case you will have to email the author
17:52:32 <danilo2> ? :)
17:52:40 <jle`> robertkennedy: some people define an operator f .: g = \x y -> f (g x y)
17:52:41 <robertkennedy> Yeah I'm fine with not using `(.)` initially as long as I don't have to rewrite f later
17:52:44 <jle`> but it's not exactly a standard operator
17:52:50 <jle`> so you can do f = show .: g
17:53:11 <jle`> it's not really commonly used, but some people do it
17:53:14 <robertkennedy> jle': `f x = show . g x` is my current solution
17:53:19 <jle`> that's probably the most readable one
17:53:24 <jle`> or better yet, f x y = show (g x y), heh
17:53:43 <robkennedy> Yeah, I'm looking for an operator which is both (.) and (.:)
17:54:07 <jle`> duncan_bayne: huh yeah that package doesn't list it, you'd have to email the maintainer.
17:54:13 <duncan_bayne> boj: Will do.  Just wanted to make sure I wasn't missing anything :)
17:54:18 <erisco> danilo2, I don't use Haskell for performance... not sure... but I think what you would be comparing to is unboxed vectors
17:54:20 <jle`> robkennedy: hm, yeah, there isn't any way to unite those two types
17:54:31 <jle`> robkennedy: the types are not unifiable
17:54:33 <erisco> danilo2, I am not sure what kind of overhead, if any, Storable adds in
17:54:51 <danilo2> erisco: thank you! I just prefer to ask to know more upfront. Iwill benchamrrk it definitely. Thanks again!
17:54:58 <jle`> robkennedy: you're asking for the same operator to have two very different types
17:55:06 <jle`> the only way you can really do it is using some sort of typeclass hackery
17:55:22 <erisco> danilo2, if you have a vector of storable structs then you can alternatively consider a struct of unboxed vectors
17:55:35 <erisco> danilo2, that will also give you a different memory access pattern, though
17:56:24 <jle`> robkennedy: besides, show . (+) actually is a meaningful type in haskell
17:56:34 <arahael> Cale: Thanks for those links.
17:56:46 <jle`> robkennedy: so would your magic operator *really* mean show . g, or would it mean show .: g ?
17:57:01 <robkennedy> Yeah, definitely realize it's not trivial. But it seems like moving from `* -> *` to `k -> *` is an active research area
17:57:08 <erisco> proof that you will suffer overlapping instances
17:57:36 <jle`> surely you mean a -> b to a -> c -> b
17:57:37 <danilo2> erisco: I was thinking about it, but I also need to store the vector of structs (or the struct of vectors) to disc and load them back (resizing the vectors in memory). I'll have many fields in struct so the approach to have single vector seems more reasonable
17:57:53 <Cale> arahael: If you just want to try the web stuff, I would perhaps recommend going to the develop branch
17:58:16 <Cale> arahael: That repo is a really good way to get set up with ghcjs in general, even if you're not using reflex
17:58:21 <erisco> danilo2, it just depends on how you need to access the data... one excels at accessing one field at a time, the other at accessing the whole struct at a time
17:58:29 <crucify_me> one other thing about 'id' changing the type signature back there, is that when you put id on either the first or second argument, the order of (Num a, Fractional (a -> a)) doesn't change. this is something I still struggle with, with the signatures generally
17:58:47 <crucify_me> I anticipate that to chanage
17:58:49 <crucify_me> change
17:58:56 <arahael> Cale: Sadly, I don't have much opportunity to get stuck into it (Life, you know...k) but I am definitely attempting to stay on top of all the news in this area. :)
17:59:33 <danilo2> erisco: right, i need to benchmark 
17:59:39 <danilo2> erisco: thank you! :)
17:59:43 <erisco> danilo2, but I would be careful because I think your struct is going to be reboxed every time you look at one on the vector
17:59:50 <monochrom> crucify_me, the order of constraints doesn't matter. It really doesn't. The compiler may display it one way or another as an artifact of the way it is coded up, but it doesn't matter.
18:00:06 <erisco> and to put one on the vector you'll have to build a boxed one and then unbox it (or store it, I guess)
18:00:18 <jle`> crucify_me: you can think of , there as "and"
18:00:26 <jle`> crucify_me: P and Q is the same as Q and P
18:00:39 <robkennedy> jle': more likely here I don't understand the difference between moving from `* -> *` to `k -> *` and moving from from `a -> b` to `a -> c -> b`
18:00:58 <danilo2> erisco: hmm, im trying to use structs with only strict and unpacked fields, so I dont think they'll get reboxed
18:00:58 <crucify_me> ok excellent monochrom jle` Helpful !
18:01:11 <erisco> danilo2, there is a bunch of special GHC stuff with magic hash and... things... that may help, though... you'd have to talk to a person who can hash the hash
18:01:31 <erisco> danilo2, the whole struct gets boxed, not the fields
18:01:57 <danilo2> erisco: it will not If I will assign it to strict variable (as far as I know).
18:02:12 <danilo2> erisco: hopefully. If it will always get boxed it would be really bad
18:02:23 <erisco> there is GHC stuff so you can use -> with unboxed types in GHC, afaik, but I don't know if you can do that with custom data types
18:02:26 <jle`> robkennedy: * -> * is a kind
18:02:32 <jle`> you're takling about types
18:03:02 <jle`> the issue here is at the level of values and types
18:03:04 <jle`> not of kinds
18:03:15 <erisco> danilo2, strict doesn't mean it is going to unpack it, though, it can still be a pointer to your struct
18:03:33 <danilo2> erisco: hmm, you are right. I hope it is possible. hm. 
18:03:34 <erisco> that is why you have both ! for strict and {-# UNPACK #-} for unpacking
18:04:20 <erisco> jle`, robkennedy just {-# LANGUAGE TypeInType #-}
18:04:24 <jle`> ;)
18:04:29 <danilo2> Does anybody know if using Vector.Storable and keeping there custom data types (with Storable instances and all fields unpacked) makes it possible to access such structure but wiithout re-boxing it 
18:04:31 <danilo2> ? :)
18:05:06 <dmwit> robkennedy: The real problem here is that one *cannot* in general know ahead of time how many arguments a given term takes.
18:05:11 <dmwit> robkennedy: For example:
18:05:12 <dmwit> :t foldr
18:05:14 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:05:18 <robkennedy> jle': you're saying that the research I'm referencing is more about making `f Just` and `f 1` work, not `f True 1` and `f 1`
18:05:20 <dmwit> robkennedy: This may look to you as though it takes three arguments.
18:05:21 <robkennedy> ?
18:05:46 <dmwit> robkennedy: But `foldr (.) id [] 3` is perfectly well-typed, and `foldr` has been given *four* arguments.
18:06:00 <monochrom> :)
18:06:02 <dmwit> robkennedy: So if you can't know how many arguments a thing takes, you can't know when to "do the final `show` bit".
18:06:06 <jle`> robkennedy: f True 1 and f 1 is still an issue about types
18:06:08 <jle`> not about kinds
18:06:13 <jle`> "number of arguments a function has" is a part of its type
18:06:13 <monochrom> @quote monochrom 17-ary
18:06:13 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
18:06:16 <jle`> not its kind
18:06:43 <jle`> in one case, f :: Bool -> a -> b, and the other, f :: a -> b, but in both cases, the type of f has kind *
18:07:24 <erisco> lets just say if you write an instance for  a -> b  that b can be  p -> q
18:07:46 <erisco> you can't have, in Haskell, an instance for  a -> b  where b is not a particular type (or form of type)
18:07:52 <monochrom> And my quote is about the arity of id :)
18:08:21 * dmwit . o O ( "id am 17-ary, going on 18-ary..." )
18:08:35 <monochrom> Oh heh that's even better
18:08:56 <erisco> on the other hand, in closed type families you can figure that out
18:09:56 * hackagebot lmdb-simple 0.2.0.0 – Simple API for LMDB – https://hackage.haskell.org/package/lmdb-simple
18:10:44 <erisco> lets see what kind of mess we can cobble together...
18:11:31 <erisco> there is nothing more enjoyable than taking an unlikely idea and realising it in full glory
18:12:23 <monochrom> Such as Spiderman vs Minions? :)
18:12:49 <noexcept_> Haskell's notion of a type is confusing coming from a C++ background. What in C++ is a class template would be considered a type in Haskell. In C++, without specifying type parameters, it's just a template.
18:13:43 <monochrom> The sentiment is mutual.
18:13:52 <erisco> in C++ you can give something a template whether it makes sense or not
18:13:58 <erisco> you can't do that in Haskell
18:14:38 <erisco> this is why they've been trying to get "contracts" or whatever they're called into C++... was supposed to be in C++11, many expected ... not sure where it is at now
18:14:46 <monochrom> Also, semi-recent research (as in, circa 10 years) has revealed that it is C++ and Java etc that confuses types with classes.
18:14:49 <erisco> it is why you get "error novels"
18:15:19 <kadoban> erisco: concepts?
18:15:24 <erisco> yeah, that's the c word
18:15:46 <arahael> C++ has SFINAE.
18:15:57 <dmwit> robkennedy: http://lpaste.net/357330
18:16:00 <erisco> that's right, it is a feature, not an error
18:16:06 <noexcept_> erisco: I'm not trying to defend how templates are implemented in C++ :)
18:16:39 <monochrom> What you can reasonably claim to be confusing in Haskell is that whereas one should write "forall a. a -> a" the language insists on just "a -> a".
18:16:47 <dmwit> robkennedy: N.B. you need to specify all the base cases you care about. There is no way to write `instance "t is not a function type" => OnLast t where ...`.
18:16:50 <danilo2> Hi! I'm wondering if is there any way to tell GHC to unbox constructor arguments in such use case: `data Foo = Foo { x :: {-# UNBOX #-} !Int, y :: {-# UNBOX #-} !Int }` 
18:16:56 <erisco> noexcept_, I am just cautious about making analogies with C++ because templates are only a smidgen above macros
18:17:15 <danilo2> is it possible? I've been wathcing core, but it seems that Foo cosntructor uses boxed ints (even if I use it somewhere)
18:17:47 <noexcept_> monochrom: exactly. So why would "forall a. Maybe a" be considered a type and not a whole bunch of types?
18:17:57 <Welkin> {# UNBOX #} right?
18:18:00 <erisco> danilo2, are the ints you are sticking into it boxed? it may have to unbox them to put them in the struct
18:18:02 <noexcept_> monochrom: for me, "Maybe Int" is a type.
18:18:06 <Axman6> it's UNPACK
18:18:09 <Welkin> yeah
18:18:11 <Welkin> UNPACK
18:18:12 <Axman6> not UNBOX
18:18:26 <Axman6> and it's {-# UNPACK #-}
18:18:31 <Welkin> lol
18:18:44 <Welkin> you can tell I haven't written lately
18:18:55 <noexcept_> monochrom: "forall a. Maybe a" seems kind of like a "higher order type"
18:19:17 <monochrom> If you don't consider it a type, you get rank-1 polymorphism. If you consider it a type, you get rank-n polymorphism.
18:19:48 <robertkennedy> Idk, are you gals and guys contending there is no function which can take `quickCheck` as its argument? Sounds like a strong contention
18:20:13 <crucify_me> jle`,    geez your example has me perplexed now  >  :t xyl id 4        
18:20:36 <crucify_me> also :t xyl id 4 5
18:20:49 <noexcept_> monochrom: so it's just a matter of semantics? (not in the formal sense, as they would be identical)
18:21:28 <monochrom> "(forall a. (a,a) -> a) -> Int" is a thing in extended Haskell, and actually has values. I think there is analogous code in C++ too, in which you take a template as a parameter.
18:21:48 <robertkennedy> NVM jle' provided a good example of what I'm thinking
18:21:52 <monochrom> Or maybe not. I don't know. I forgot all my C++.
18:21:53 <c_wraith> noexcept_: well, not exactly.  It really does mean different things if you can instantiate a type to a polytype.
18:22:46 <monochrom> But last time I talked to a group of compiler grad students (ECE department, they hadn't seen Haskell or SML but very familiar with C++), that's how I explained rank-2 to them, a C++ function that takes a template parameter.
18:23:19 <noexcept_> c_wraith: can do that in C++ too: template <typename T> using ListMaybe = List<Maybe<T>>;
18:23:24 <monochrom> Whether it's legal or not I forgot, but they understood that narrative, even if hypothetical.
18:23:25 <noexcept_> c_wraith: is that what you meant?
18:23:54 <Welkin> NVMe?
18:23:54 <Welkin> :P
18:24:58 <monochrom> Oh I guess I know how to write conservative C++ code and still have it rank-2. Just hide the template function inside a class.
18:25:29 <c_wraith> noexcept_: actually, I meant things like the type ($) has to take in the expression "runST $ foo"
18:25:41 <noexcept_> It's really muddying the waters though when the most basic concepts are defined differently. The Haskell tutorials for C++ programmers don't really point out those differences afaik.
18:25:42 <danilo2> erisco: hmm, when providing literal number it gets unboxed, so yeah, that have to be it. I'm still trying to read core to know if the outer structure could be unboxed (hopefully just to unboxed tuple)
18:25:47 <monochrom> class X { template <T> T f(Pair<T>); }
18:25:58 <monochrom> err f is a bad name
18:26:08 <monochrom> class X { template <T> T gee(Pair<T>); }
18:26:16 <c_wraith> noexcept_: which only type-checks in GHC because the type checker has a special case for $.  Otherwise, it's really painful to try to make work.
18:26:22 <monochrom> Oh I need an ending semicolon.
18:26:30 <dmwit> robertkennedy: I don't think any of us are contending that there is no function which can take `quickCheck` as its argument.
18:26:34 <monochrom> int f(X);
18:26:36 <dmwit> robertkennedy: Why do you believe we are contending that?
18:27:19 <monochrom> That was the kind of legal code I showed to explain rank-2.
18:28:19 * hackagebot vinyl 0.6.0 – Extensible Records – https://hackage.haskell.org/package/vinyl
18:28:19 * hackagebot Frames 0.2.0 – Data frames For working with tabular data files – https://hackage.haskell.org/package/Frames
18:28:24 <monochrom> "haskell tutorial for c++ programmers" is a bad idea to begin with. But I'm an idealist.
18:28:55 <monochrom> I mean, if there are N languages, are we going to have N(N+1)/2 tutorials?
18:29:18 <monochrom> IT DOESN'T SCALE
18:29:49 <noexcept_> monochrom: I guess it doesn't have to be for C++ in particular. For systems programmers would be great too.
18:29:57 <monochrom> Even the compiler writers understood it 40 years ago.
18:30:02 <c_wraith> monochrom: no, we're going to have at least M*that, where M = the number of people who think they can write tutorials.
18:30:04 <noexcept_> Something that explains how Haskell maps to the machine.
18:30:14 <noexcept_> and doesn't start from the mathematics
18:30:46 <c_wraith> noexcept_: that's not a very useful POV for haskell until you understand what the code means.  Only then does the translation down to machine level make much sense.
18:31:07 <c_wraith> noexcept_: if you start with the translation, you get a lot of "why would you do that?"
18:31:18 <monochrom> https://github.com/takenobu-hs/haskell-ghc-illustrated exists.
18:31:24 <noexcept_> c_wraith: I understand the machine, but I'll never understand all of mathematics because people can keep inventing new concepts.
18:31:50 <monochrom> Oh and people don't invent new machines such as instruction re-ordering
18:31:58 <c_wraith> noexcept_: you don't need to understand all the math used in libraries.  Just in language semantics.  *Way* smaller set.
18:32:30 <monochrom> But I have already provided the machine URL. You don't have to argue with me.
18:32:37 <noexcept_> c_wraith: until you want to understand some code that uses the standard library
18:33:03 <c_wraith> If you know the language, you can just read the library code if you need to.
18:34:17 <noexcept_> c_wraith: That's like saying you can read Wikipedia math articles if you understand basic math notation. Usually they only become useful after you already understood them.
18:34:22 <Welkin> lol monochrom 
18:34:31 <c_wraith> noexcept_: actually, it's even better than that.  If you know the base language, type signatures are about 90% of what you need to use most libraries.
18:34:34 <Welkin> I have been writing a "purescript for javascropt developers" guide
18:34:41 <Welkin> but that one makes sense
18:34:51 <Clint> nothing about javascropt makes sense
18:35:03 <dmwit> noexcept_: You could try the Spineless Tagless G-machine paper.
18:35:16 <dmwit> noexcept_: I found it quite readable; and because SPJ was on it, everything is carefully motivated.
18:35:22 <Welkin> although that also requires a guide on es5 -> es6
18:36:03 * jared-w successfully arrived at the beaverton Haskell metup. Sweet. Time to see how deaf I am irl
18:36:05 <dmwit> noexcept_: https://www.microsoft.com/en-us/research/publication/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-g-machine/#
18:36:56 <noexcept_> dmwit: I kind of have a basic idea of how expressions get shared and the thunks get lazily evaluated by destructuring, but not much beyond that.
18:38:06 <dmwit> I'm not really sure how you're hoping I will consume that information. I am glad that you understand this much, and hope that the resources monochrom and I have suggested will get you a bit further in understanding.
18:38:40 <dmwit> Ah! Perhaps you were hoping this would help guide me in suggesting reading material.
18:38:54 <dmwit> I'm not sure there's anything better than the STG-machine paper even in light of this information.
18:39:26 <monochrom> I am skeptic of self-declaration of level of understanding.
18:39:48 <noexcept_> I'll read the paper
18:39:50 <c_wraith> there is also ezyang's series of blog posts on GHC's evaluation model
18:39:51 <monochrom> I'm a scientist. I don't read your essay. I put you to empirical test.
18:40:20 <dmwit> c_wraith: Ah, good suggestion!
18:40:33 <c_wraith> noexcept_: there is also a series of blog posts starting with http://blog.ezyang.com/2011/04/the-haskell-heap/ that you might like
18:40:56 <Welkin> bookmarked
18:40:56 <noexcept_> monochrom: Same reason I want to understand how the functional language is really implemented before blindly using it.
18:41:09 <monochrom> For example I give you 5 haskell programs and their respective 5 asm programs generated by GHC, and permute them, and ask you to match them back.
18:41:26 <Welkin> lol
18:41:27 <c_wraith> monochrom: I'd probably get 0/5 on that. :)
18:41:27 <noexcept_> c_wraith: cool, thanks
18:41:33 <Welkin> I already bookmarked that months ago
18:41:35 <Welkin> I forgot about it
18:41:40 <robertkennedy> dmwit: I had thought that before jle's example in which he wrote a very quickCheck'y example
18:41:41 <c_wraith> Welkin: nice. :)
18:42:13 <crucify_me> the last entry here puts me in the dark again :   https://ptpb.pw/qCd0
18:42:27 <crucify_me> repl* entry
18:42:36 <dolio> I'd probably get 0/5 on that, too.
18:42:38 <dmwit> crucify_me: Perhaps your link is wrong. No "repl" here.
18:43:38 <monochrom> Well, I can also test on easier, higher-level thing such as showing you code of the form "print (take 1 (some non-trivial but still toy code here))" and ask you to predict whether it terminates or not.
18:43:53 <crucify_me> dmwit not seeing this ? https://ptpb.pw/qCd0
18:44:07 <dmwit> crucify_me: What is "this"?
18:44:42 <dmwit> Perhaps I've misunderstood you.
18:45:06 <crucify_me> its just the code and a Prelude session pasted in
18:45:43 <dmwit> Okay. What is your question?
18:46:02 <noexcept_> monochrom: That would be an interesting quiz for sure, but honestly I don't consider myself really understanding Haskell at all, at least not deeply enough to use it properly.
18:47:32 <erisco> mkay, I am making progress on our universal compose operator http://lpaste.net/357331
18:47:57 <crucify_me> that last :t xyl id 4   I don't understand that signature. It drops the (Num a) part dmwit. why? 
18:48:10 <Welkin> erisco: "our"?
18:48:22 <Welkin> lol, DotDotDot?
18:48:23 <monochrom> Actually a better question is why the other ones have Num?
18:48:26 <Welkin> that;s the blackbird
18:48:41 <dmwit> crucify_me: Okay, I'm game. Convince me that it should demand `Num a`.
18:49:11 <dmwit> (I will help you identify where in your argument you have made a mistake. Hopefully this will be enlightening.)
18:49:16 <crucify_me> dmwit monochrom     hold on thanks
18:49:42 <dmwit> erisco: Did you see my lpaste?
18:49:47 <erisco> dmwit, nope
18:49:50 <dolio> Are you aware that Fractional implies Num?
18:50:10 <dmwit> erisco: http://lpaste.net/357330
18:50:14 <dolio> Or rather, `Fractional a` implies `Num a`.
18:50:32 <dmwit> dolio: I think not relevant here, as a matter of fact.
18:50:55 <dmwit> dolio: If the question was "why did it drop the `Num (a -> a)`?" then I think that would be relevant.
18:51:10 <erisco> dmwit, that is exactly what I first tried but the instances can't work
18:51:11 <crucify_me> dolio yes thanks but the explicitness of one and not the other is I think what confuses me
18:51:22 <dmwit> erisco: What do you mean by "can't work"?
18:51:29 <dmwit> WFM
18:52:29 <dolio> Okay, just checking.
18:53:04 <crucify_me> I find this quite confusing, sorry
18:53:21 <erisco> dmwit, are you intending to have an instance per type that is not -> ?
18:53:29 <dmwit> erisco: No other choice, I'm afraid.
18:53:37 <monochrom> Do not conflate "Num a" and "Num (a -> a)".
18:53:38 <erisco> dmwit, that is what I meant by "can't work"
18:53:45 <dmwit> crucify_me: That's understandable. Using a function in place of a number is a confusing thing to try to do.
18:53:49 <erisco> it is also what I said earlier about the instance problem
18:54:02 <erisco> you can figure out a type is not -> with a closed type family but not with class instances
18:54:51 <erisco> this is why I am using Compose
18:55:25 <dmwit> If you're okay with type wrappers and unwrappers, then nothing special is needed. `fmap` is already the right function.
18:55:39 <erisco> but I think what I should do is see if I can generalise to Category, otherwise I need an instance per arity =\
18:55:51 <erisco> dmwit, well the hope is that I can do something about the wrappers that I can't do otherwise
18:56:03 <dmwit> I'm not going to hold my breath.
18:56:14 <erisco> neither am I... I said this was an unlikely idea :P
18:57:19 * hackagebot mixed-types-num 0.3.0.1 – Alternative Prelude with numeric and logic expressions typed bottom-up – https://hackage.haskell.org/package/mixed-types-num
18:57:29 <crucify_me> so just step by step, xyl id 4    you're applying id to 4, and that is constrained to be Fractional (a -> a), then that's enough for that particular signature returned. dmwit 
18:58:08 <dmwit> crucify_me: Okay, there are many mistakes in there. The most important one is that `xyl id 4` does not apply `id` to `4`.
18:58:25 <dmwit> crucify_me: `xyl id 4` applies `xyl` to `id`; it then applies the result of that to `4`.
18:58:28 <dmwit> crucify_me: Compare:
18:58:30 <dmwit> :t (/) id 4
18:58:32 <lambdabot> Fractional (a -> a) => a -> a
18:58:36 <dmwit> :t (/) (id 4) -- applying id to 4
18:58:38 <lambdabot> Fractional a => a -> a
18:59:27 <DijonMustard> Hey could someone help me out with some Lenses? I made a gist: https://gist.github.com/Quinn95/2ccd016aa6de61896d5542a9296a790d
19:01:02 <crucify_me> ok dmwit thank you. the one above that one, you have it with :t xyl id 4 5  .  there are two num arguments there. So why does it need the explicit Num a part.
19:01:21 <dmwit> DijonMustard: Probably you want to take a lens from `GameState` to `Object` as an argument, and use it in place of `player.object` everywhere.
19:02:24 <dmwit> crucify_me: It needs `Num a` so that it can convert the literal `5` to an `a`.
19:02:59 <DijonMustard> Do you know what the type signature would be on that? I tried doing that but couldn't figure it out
19:03:15 <crucify_me> ok thanks kindly I'm going to work it out based on your help thus far.
19:03:19 <crucify_me> dmwit, 
19:03:34 <DijonMustard> Also, not sure what to put as argument in gameLoop
19:04:17 <dmwit> DijonMustard: I guess something like `updateState :: SLens GameState Object -> Command -> StateT GameState IO ()`.
19:04:27 <dmwit> oops
19:04:32 <dmwit> s/SLens/Lens'/
19:05:20 <DijonMustard> ok, I'll give it a try, thanks!
19:06:44 <dmwit> I'm not sure. You might want to take a traversal of some kind instead, but I have much less experience with traversals.
19:07:00 <dmwit> Depends what exactly you want to do with enemies, I think.
19:08:08 <dmwit> You probably want to do something like a "zip" with the commands and enemies. I don't know how to do that kind of thing with lens. Perhaps there's somebody else around who does.
19:08:16 <slack1256> on packages with a cabal.project file (for new-build on cabal), what is the standard setup to play nice with nix?
19:08:34 <slack1256> I usually just cabal2nix --shell . stuff and build from a nix-shell
19:09:16 <Welkin> cabal.project?
19:09:32 <Welkin> I've grown tired of nix sometimes working and sometimes not
19:09:33 <DijonMustard> dmwit: alright. I was planning on using a lambda to generate random commands on the fly with mapM, but we'll see :P
19:09:45 <dmwit> slack1256: You might want to ask in #hackage if you haven't already.
19:09:50 <dmwit> haunt of cabal devs
19:09:56 <Welkin> a haunt?
19:10:26 <Welkin> noun "a place frequented by a specified person or group of people"
19:10:31 <dmwit> DijonMustard: Okay. That does sound very much like a traversal to me.
19:10:32 <Welkin> lol
19:10:50 <slack1256> ok!
19:11:12 <DijonMustard> dmwit: I know, but I just started learrning lenses and I don't know how they work yet :( if it comes down to it I'll try to figure them out
19:12:05 <slack1256> Welkin: what kind of problem did you have with nix?
19:13:08 <Welkin> slack1256: things not being found and not compiling
19:14:04 <slack1256> right, looking how nixpkgs looks for things is not straigh forward
19:14:12 <slack1256> thank god for nix-repl, but still
19:16:39 <DijonMustard> dmwit: Hey I got it! updateState :: (HasObject a Object) => Lens' GameState a -> Command -> StateT GameState IO ()
19:16:42 <DijonMustard> Thanks!
19:20:33 <Gurkenglas__> DijonMustard, try zoom :: Lens' GameState Player -> StateT Player IO () -> StateT GameState IO ()
19:22:17 <DijonMustard> Gurkenglas__: the signature I have above works great, but thanks!
19:23:02 <qmmm> how would one easily print out all of the zeroes of 1.04e5 ?
19:23:38 <Gurkenglas__> DijonMustard, I mean zoom already exists and you can use it so you dont have to write "player" in updateState
19:24:38 * hackagebot binary-serialise-cbor 0.1.1.0, cbor-tool 0.1.0.0, cborg 0.1.1.0, serialise 0.1.0.0, … and 1 more
19:24:38 * hackagebot  → https://hackage.haskell.org/packages/recent
19:25:25 <DijonMustard> Gurkenglas__: Is there a reason to use that over updateState :: (HasObject a Object) => Lens' GameState a -> Command -> StateT GameState IO () ? That is polymorphic for all (HasObject a Object)
19:26:49 <qmmm> guess i can define a format function 
19:28:01 <Gurkenglas__> zoom's signature is more general than what I said, I just specialized it to what I thought you wanted
19:28:02 <DijonMustard> qmmm: Do you mean like? 104000.0? use show 1.04e5
19:30:39 <Gurkenglas__> The reason would be that it turns the multiple places where a lens would be passed around within updateState into one additional word at the call site
19:35:27 <mnoonan_> sorry to ask again, but since it quieted down a bit..
19:35:39 <erisco> dmwit, this is why I thought closed classes would be cool
19:36:22 <mnoonan_> would anybody mind commenting on ‘inserting’ in https://github.com/matt-noonan/justified-containers/blob/master/src/Data/Map/Justified.hs ?
19:37:01 <fr33domlover> Hello! I have a directory tree with files and I need to run some processing on them, but only if they changed since the last processing, much like `make` or GHC would recompile just the minimum necessary. I need this functionality in a library I'm writing. Is there existing code for this that is worth reusing? Maybe from ghc or shake etc. or some existing library even?
19:37:02 <mnoonan_> I’m about to pull a bunch of additional Data.Map functions into Data.Map.Justified following a similar pattern, but I’m open to other ideas.
19:47:09 <EvanR> is there are standard somewhere for rendering haskell code "the right way" like... \ is lambda, -> is a right arrow
19:47:16 <EvanR> like how to show certain things
19:52:16 <EvanR> <> ... probably a diamond not sure
19:52:23 <erisco> looks superb as-is
19:52:47 <EvanR> be that as it may... maybe papers use a stylzed look for haskell code
19:52:52 <EvanR> many papers*
19:53:03 <mnoonan_> EvanR: Fira Code ligatures and call it a day
19:53:55 <erisco> sure, but in some way it is frivolous... it is not actually valid Haskell anymore
19:55:17 <erisco> Int → Char → Int   is nicer to look at than   Int -> Char -> Int   sure, but where do you stop
19:55:57 <erisco> next you'll be writing Σ instead of sum
19:56:44 <erisco> and why not use conventional LC notation and change \x y -> m to λx.λy.m
19:58:14 <erisco> we just have to live with it... Haskell is no more beautiful than ASCII art
19:59:08 <monochrom> Can't. Σ is an uppercase letter. I'll be writing Σ for the data constructor for the mother of existential types. :)
20:13:51 <EvanR> erisco: because λx y → m, written using proportional font (longer arrow), pretty much looks like haskell only not limited to ascii
20:14:10 <EvanR> λx.λy. whatever is a different language
20:14:23 <EvanR> its like the difference between all the ways to write (by hand) a lower case z, its still z
20:15:36 <EvanR> like, we dont think of haskell code in terms of "space" "hyphen" "right angle bracket" "space", its an arrow
20:18:00 <erisco> idealistically, but there is a difference between -> and → and I am quite certain of it
20:20:36 <EvanR> there could be, theres also at least 20 kinds of right arrows
20:21:14 <EvanR> but since theres only one -> and we dont use any actual arrows... i am only seeing 1
20:21:53 <erisco> if you really only saw one then you would not be worried about having → instead of ->
20:22:13 <EvanR> i see the left one (in a proportional font) in my head, not ->
20:22:39 <erisco> well, I process all my seeing in my head, and I can distinguish them :P
20:22:49 <EvanR> when communicating haskell in slack or gchat, i cringe at typing -> which looks even worse in proportional, so i type nice right arrow
20:23:09 <EvanR> its the same code, easier to read
20:23:18 <ab9rf> my keyboard's arrows don't actually produce arrows
20:23:28 <EvanR> unfortunate :)
20:23:42 <erisco> an exercise of wishful thinking... well I am not going to stop you
20:23:44 <ab9rf> they just make the little thingy move around without actually making anything
20:23:50 <ab9rf> very sad
20:23:57 <EvanR> what if the power switch typed a ⏻
20:24:00 <EvanR> lol
20:24:17 <EvanR> hahaha
20:24:19 <ab9rf> EvanR: that character doesn't render in this display
20:24:49 <EvanR> http://i.imgur.com/z8IIAXM.png
20:25:02 <ab9rf> heh
20:25:04 <erisco> I see something that looks like a music note on a filmstrip
20:25:21 <EvanR> it only has 4 hex... cant be that unusual
20:25:25 <ab9rf> erisco: a filmstrip? people still know what a filmstrip looks like?
20:25:50 <EvanR> filmstrip is used as iconography in video editors and stuff
20:25:52 <EvanR> i think
20:26:00 <erisco> ab9rf, I can still hear the geneva drive!
20:27:06 <ab9rf> i clearly need to find a monospaced font with more supported glyphs
20:28:17 <ab9rf> or more alcohol, one or the other
20:39:13 <danilo2> Hi! Does unsafeCoerce affect performance / optimizations in any way ?
20:40:21 <jle`> it might prevent some rewrite rules from firing in some situations
20:40:41 <jle`> like `unsafeCoerce (.)` might behave differently than `(.)`
20:41:41 * hackagebot word8 0.1.3 – Word8 library – https://hackage.haskell.org/package/word8
20:42:00 <danilo2> jle`: hmm, I want to use unsafeCoerce to coerce between (Vector A) and (Vector B) so in fact rewrite rules should still work (assuming that they apply to (Vector B)), right ?
20:46:20 <Sebivor> I've identified a number of books written by university professors. Has anybody from here peer reviewed them all?
20:54:28 <Sebivor> s/them all/any of them/
20:55:53 <Sebivor> i PUT LINKS TO THEM IN THIS PASTE: <https://pastebin.com/8WaJRWtg>
20:56:01 <erisco> what does peer review mean in that case? they don't have to have them reviewed to be published
20:57:39 <Sebivor> Err, disregard the two Haskell report links at the end; I included them in my list of resources for personal use... I'm just interested in whether any of the books might be as valuable as SICP.
21:03:27 <jle`> by "peer reviewed", do you mean "reviewed"?
21:03:43 <jle`> or are you asking if any of us were actually on the reviewing committee when those books were being published?
21:09:56 <jle`> hi all
21:09:59 <jle`> what happened to :set prompt2 ?
21:10:01 <jle`> in ghc 8.2 ?
21:10:24 <jared-w> There's a prompt2?
21:11:30 <jle`> yeah, it's the prompt for multiline input
21:12:21 <jle`> oh i guess it's called prompt-cont now
21:14:01 <dmwit> So is it traditional to include stack.yaml in the tarball sent to Hackage? Or how are these distributed?
21:14:06 * dmwit stack newb
21:14:30 <jared-w> oh neat, didn't know that was a thing. I've never really ever used multiline input in GHCi so...
21:14:52 <dmwit> jared-w: :set +m
21:15:08 <dmwit> Or do it manually with :{ to start a multiline command and :} to end it.
21:15:31 <dmwit> (:set +m will look for block heralds and use them to guess when you want a multiline input.)
21:15:48 <jared-w> I mean, I know /how/ I've just never done it. I've only ever done it in a python repo because python doesn't really work otherwise :p
21:16:11 <jared-w> 90% of my ghci usage is :t and running a function with some inputs 'n stuff. Never needed more than one line
21:16:42 * dmwit nods
21:22:30 <Sebivor> Reviewed will do, but peer reviewing would be ideal. The first seems to have lacked any peer reviewing at all.
21:23:33 <erisco> if you have any way to search for citations (Google Scholar?) then that can inform you on how good the book is
21:23:38 <Sebivor> I already spotted an error: These are of course library-defined (hence the input CodeWorld) and not part of “the language”.  <--- He meant `import CodeWorld`
21:23:59 <Sebivor> Good idea!
21:25:24 <dmwit> I'm sitting here wrinkling my brow. "peer review" in my mind involves a pretty intense scrutiny for novelty and technical correctness. I don't really think the typical book is held to the same standard of novelty -- usually you don't cut a book until the material is well understood and you can put a sensible narrative on top.
21:26:28 <erisco> that and if it is coursework then it certainly will not be novel
21:27:16 <erisco> a typo does not mean the book is factually incorrect, but it does indicate how carefully it was proofread
21:27:38 <erisco> and so possibly they also failed to check some factual things they wrote, that could be
21:27:58 <erisco> classic is to publish code that does not work :P
21:28:30 <jared-w> I'm personally leaning towards disliking paper books on principle for things like programming
21:29:02 <jared-w> Programming is often a highly dynamic activity; the code might not work tomorrow, there's huge bit-rot, technical debt, etc., and constant improvement of ways to do things
21:29:52 <erisco> depends what the book is on... if it is telling you how to write a web server then maybe it becomes too dated
21:30:02 <jared-w> It just seems ridiculous to put stuff in a book that might survive for 900 years about a language that hasn't even been around for 60 involving a library that hasn't even been around for 20...
21:30:09 <erisco> using old libraries and language versions that do not reflect what people are using now
21:30:18 <erisco> but there is also timeless knowledge
21:30:23 <dmwit> jared-w: I don't really see how storing the writing in electronic form fixes that. Maybe it's easier to update electronic writing, but 99% of blog posts do not get updated.
21:30:25 <sgronblo> Any idea why I am getting a "can't load .so/.DLL" when running a haskell script with a stack #! line?
21:30:41 <sgronblo> "Reason: image not found"
21:30:47 <sgronblo> is my stack installation broken or something?
21:30:50 <erisco> you can go pick up Programming Pearls and learn a lot, even though no one uses tape drives anymore
21:31:05 <dmwit> jared-w: ..."lasting 900 years" is not the (only) point of binding the material into a book...
21:31:07 <jared-w> Yeah but timeless knowledge is often changed in how it's presented. It's often presented with code examples (that should change), with exercises that become dated, with analogies that fall out of use, etc.
21:31:16 * pacak reads a (pdf) book somewhat related to programming from 1992...
21:31:34 <kadoban> jared-w: But those won't be updated regardless.
21:31:35 <erisco> well, as I said, depends on what the book is about
21:31:37 <jared-w> dmwit: True, most blog posts don't get updated. It's impossible to update a book the way you can update a 'live document' on the computer, however.
21:31:51 <erisco> the books I find worth reading are those with the timeless knowledge in them
21:32:05 <erisco> I don't care at all to learn about the fad wizbang
21:32:19 <dmwit> sgronblo: Hm. I haven't seen that before. But your description of the problem is also pretty light on details.
21:32:23 <jared-w> same
21:32:34 <kadoban> Even old outdated books on language tend to be worth reading, if they were any good in the first place.
21:32:38 <jared-w> I suppose I just have a bit of a frustration with the linear limitations of 'print' formats
21:32:47 <pacak> I dont think lambda calculus changed a lot recently anyway.
21:33:34 <sgronblo> dmwit: yeah I can give the whole error message
21:33:40 <sgronblo> <command line>: can't load .so/.DLL for: /Users/samu/.stack/snapshots/x86_64-osx/lts-7.8/8.0.1/lib/x86_64-osx-ghc-8.0.1/mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM/libHSmtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM-ghc8.0.1.dylib (dlopen(/Users/samu/.stack/snapshots/x86_64-osx/lts-7.8/8.0.1/lib/x86_64-osx-ghc-8.0.1/mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM/libHSmtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM-ghc8.0.1.dylib, 5): Library not loaded: 
21:33:46 <sgronblo> /usr/local/opt/ghc/lib/ghc-8.0.1/transformers-0.5.2.0/libHStransformers-0.5.2.0-ghc8.0.1.dylib
21:33:49 <sgronblo>   Referenced from: /Users/samu/.stack/snapshots/x86_64-osx/lts-7.8/8.0.1/lib/x86_64-osx-ghc-8.0.1/mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM/libHSmtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM-ghc8.0.1.dylib
21:33:53 <sgronblo>   Reason: image not found)
21:34:21 <sgronblo> seems a little weird to me since my "stack comment" includes --resolver lts-7.9
21:34:42 <sgronblo> so i don't know what it's doing trying to look something up from a path containing lts-7.8
21:35:12 <sgronblo> anyway, this error is too vague for me to figure out what's wrong
21:35:52 <jared-w> sgronblo: what's your $PATH?
21:36:52 * hackagebot justified-containers 0.1.1.0 – Keyed container types with verified keys. – https://hackage.haskell.org/package/justified-containers
21:36:52 * hackagebot lmdb-simple 0.3.0.0 – Simple API for LMDB – https://hackage.haskell.org/package/lmdb-simple
21:36:58 <sgronblo> jared-w: there's a bunch of stuff in $PATH. Anything in particular to look out for?
21:37:49 <jared-w> Having a lts-7.8 thing in your path that might be loaded before your lts-7.9 stuff from stack
21:38:20 <Sebivor> The second link starts with an interesting interactivity-related feature at the start; it integrates with the browser console... I wonder if this is indicative of things to come?
21:39:55 <dmwit> So... nobody knows how stack.yaml's are distributed?
21:40:17 <kadoban> dmwit: What do you mean?
21:45:52 <sgronblo> jared-w: ok i noticed something. "Library not loaded: /usr/local/opt/ghc/lib/ghc-8.0.1/transformers-0.5.2.0/libHStransformers-0.5.2.0-ghc8.0.1.dylib" <- I don't even have this /usr/local/opt/ghc/lib/ghc-8.0.1 folder
21:46:14 <sgronblo> i thought my ghc installations would be managed by stack?
21:46:47 <Welkin> did you only install using stack?
21:47:38 <Welkin> or do you have a system-wide ghc (and/or cabal-install)?
21:48:10 <kadoban> sgronblo: Did you delete old snapshots because you weren't using them anymore perhaps?
21:48:32 <sgronblo> I didn't install anything. I am running it like this: https://haskell-lang.org/tutorial/stack-script Section "Script interpreter"
21:51:25 <sgronblo> I have this line though in my script: -- stack --resolver lts-7.9 --install-ghc runghc --package QuickCheck --package either --package parsec
21:51:45 <sgronblo> So to me it seems like stack is supposed to install ghc with this configuration
21:52:25 <kadoban> sgronblo: It is. It doesn't sounds like it's failing to find GHC though, that sounds like something else. Did you delete old snapshots at some point in the past?
21:53:13 <kadoban> Er wait, what is that path it's looking in. I'm not sure what that is.
21:53:50 <dmwit> kadoban: My question above was: are stack.yaml's typically included in the tarball uploaded to Hackage? Or how are they distributed?
21:56:48 <kadoban> dmwit: Ah. Yeah I think they are supposed to be for executables. For libraries, don't think you're supposed to.
21:58:01 <dmwit> Okay. Does it need to appear anywhere but in my repository?
21:58:18 <dmwit> Context: somebody sent me a pull request with one. I don't know how this has changed my responsibilities as a maintainer.
21:58:30 <dmwit> ...and I accepted the request before I thought about this question. =P
21:58:42 <dmwit> (It is a library-only package.)
22:00:20 <kadoban> Trying to find the official guidance. My impression is though that stack.yaml for library-only packages aren't at all useful. Or maybe rarely useful? Can't think of what they'd even do.
22:00:58 <jared-w> "This is Ed Kmett. He's written a zillion and one libraries. He also wrote lens and discovered that if he wrote documentation, he got a lot more users." Top banter, there, excellent stuff.
22:01:11 <jared-w> (Finally watching this https://www.youtube.com/watch?v=cefnmjtAolY)
22:01:30 <dmwit> kadoban: ￼
22:03:11 <dmwit> Hm. That didn't work. That was supposed to be a thumbs-up.
22:03:16 <edwardk> jared-w: hah =)
22:03:34 <dmwit> jared-w: ...and he's purposely avoided documentation ever since. ;-)
22:03:43 <kadoban> dmwit: :)
22:04:25 <jared-w> The truth is out...
22:05:07 <jared-w> Not enough hours in the day to write 500 libraries if people are actually /using/ more than 4 of them
22:06:07 * hackagebot justified-containers 0.1.1.1 – Keyed container types with type-checked proofs of key presence. – https://hackage.haskell.org/package/justified-containers
22:10:52 <vimalloc> Is there someting like 'pure' for applicative that returns the 'unboxed' value? Ex, if dealing with with a maybe, 'pure' would be Just a, is there something that would translate into 'Nothing' the same way 'pure' translates into 'Just'
22:11:11 <vimalloc> I think that sentence got away from me :)
22:11:43 <kadoban> Maybe you're looking for whatever that's called from Alternative or one of those?
22:11:45 <kadoban> :t empty
22:11:47 <lambdabot> Alternative f => f a
22:11:56 <kadoban> Maybe that one?
22:12:20 <vimalloc> looks promising, I'll play with that.
22:12:22 <vimalloc> Thx :)
22:12:31 <kadoban> Anytime
22:19:16 <sgronblo> which OSX distribution of haskell installs to /usr/local/opt/ghc ?
22:19:35 <sgronblo> why is my stack run digging around in there?
22:21:02 <kadoban> sgronblo: What version of stack are you using, out of curiosity? I didn't think stack even used system GHCs anymore without you telling it to.
22:31:24 <sgronblo> kadoban: I should be using the one installed through homebrew. "Version 1.5.0 x86_64 hpack-0.17.1". Installed in "/usr/local/bin/stack"
22:33:45 <sgronblo> well i'm not in a hurry to solve this so maybe I'll just put up a GH issue for it
22:34:45 * hackagebot th-abstraction 0.2.4.0 – Nicer interface for reified information about data types – https://hackage.haskell.org/package/th-abstraction
22:35:12 <pacak> ghc-mod vs hdevtools vs ghcid? Which one is more alive those days?
22:35:53 <pacak> What do you use and how do you integrate it with your editor?
22:36:03 <glguy> I've had the most luck with dante lately
22:36:43 <pacak> emacs....
22:39:20 <glguy> yeah, I don't like that aspect of it either
22:40:29 * hackagebot tls-debug 0.4.5 – Set of programs for TLS testing and debugging – https://hackage.haskell.org/package/tls-debug
22:42:52 <tdammers> I keep trying all sorts of vim plugins for all sorts of programming language, but in the end, I always tend to return to a fairly vanilla setup - just barebones vim plus an elaborate vimrc and a bunch of ftplugin scripts
22:44:14 <dmwit> Got it, "vanilla" = "elaborate vimrc" + "a bunch of scripts".
22:44:30 <jared-w> lol
22:44:31 <glguy> Yeah, just vanilla with some toppings and some sprinkles
22:44:35 <tdammers> small bunch
22:44:52 <glguy> and a banana and some strawberries :)
22:44:59 <tdammers> also, "scripts" are more like a series of :set commands
22:45:07 <tdammers> and a few keybinding
22:45:09 <tdammers> s
22:45:29 <tdammers> but none of those plugins that "turn vim into an IDE"
22:45:34 <tdammers> that's what I meant by "vanilla"
22:45:55 * Maxdamantus ' vimrc is 7 lines long, no plugins.
22:45:56 <jared-w> I like intero personally. The biggest problem I have with emacs currently is I don't have my symbol rewriting thing working for whatever reason (so \ shows up as a λ)
22:46:24 <jared-w> My vimrc is a very humble ~200 lines or so
22:47:08 <Maxdamantus> set go=; set nocompatible; colorscheme slate; syntax enable; set autoindent; set copyindent; set clipboard=;
22:47:14 * dmwit imagines Maxdamantus cackling in a corner with 7 1000-character lines with tons of |'s in
22:48:07 <jared-w> The vast majority of my plugins extend the "vim paradigm" of editing, rather than giving me IDE convenience features. So things like surround.vim, vim-commentary, etc. Then autocomplete, linting, and nice highlighting make up the majority of the "IDE features"
22:48:13 <pacak> intero = emacs + commercialhaskell
22:48:22 <pacak> Even worse than dante...
22:48:28 <jared-w> But, tbf, I actually use spacemacs for haskell right now.
22:48:40 <dmwit> Yes, tpope understands how to vim.
22:49:09 <jared-w> commercialhaskell, pacak?
22:49:22 <pacak> stack, etc.
22:49:29 <sgronblo> In case anyone knows stack well: https://stackoverflow.com/questions/45429761/cant-load-so-dll-for-reason-image-not-found-when-running-stack
22:49:35 <tdammers> autocomplete and linting are things I experimented with, but in the end, I've found dumb text-based completion more useful - it's faster and more predictable, and works exactly the same for any given language
22:50:18 <tdammers> linting, not something I want enabled all the time, but rather just when I ask for it, and then I can also just run a shell command directly
22:50:34 <jared-w> Weird, I've found that fairly not the case for me. I love that I get linting so I can immediately see any mistakes; it's a huge feedback loop decreaser for me
22:50:52 <sqooq> same
22:50:54 <pacak> jared-w: this most likely means it's integrated with ecosystem they want to provide/support.
22:51:03 * pacak wants  quick typechecker mostly
22:51:10 <dmwit> tdammers: Well, for sane languages, maybe. Finding word boundaries in an adversarial language might be hard.
22:51:13 <dmwit> =P
22:51:24 <dmwit> Gotta have those plugins if you want to write serious production whitespace programs.
22:51:26 <tdammers> dmwit: I tend to avoid insane languages
22:51:45 <tdammers> one of them almost cost me my mental health
22:51:55 <jared-w> Really? Which one?
22:52:03 <jared-w> Java hurt me pretty badly too
22:52:21 <pacak> :t (<<&&~)
22:52:23 <lambdabot> LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
22:52:34 <dmwit> I'm sorry to hear that. I hope you are doing better and taking care of yourself since then.
22:53:17 <glguy> << && ~; old value; boolean and; make simple function
22:53:56 <tdammers> jared-w: anyone who's been around me for more than a bit will know that I have a fairly strong opinion about php
22:54:14 <jared-w> ahh, gotcha. I hate php but it hasn't done any mental damage to me yet
22:54:34 <sqooq> php is a hell of a drug
22:54:39 * jared-w doesn't look forward to writing tests to ensure that pi is roughly 3
22:54:41 <sqooq> I don't recommend
22:54:50 <tdammers> yeah
22:55:04 <sqooq> wait, I'm thinking of pcp
22:55:47 <tdammers> with most languages, you get to the point where you've seen all the broken stuff, and know more or less how to mitigate it - but php just keeps giving, and for much of the breakage, there isn't a feasible mitigation strategy, other than "throw more manpower at it, and accept mediocrisy"
22:56:18 <tdammers> unless you're facebook, in which case "write your own compiler" is a valid option, apparently
22:57:41 <jared-w> I honestly don't know why they didn't just sit down and say "at some point, writing our own language is better than putting up with php"
22:57:52 <jared-w> or, idk, using Haskell instead of php entirely...
22:58:03 <kadoban> jared-w: Well, they probably had a billion lines in PHP already
22:58:07 <erisco> I forget the numbers, but they got some thousand PHP servers or whatever, and HHVM on average gives you a 50% drop in CPU use
22:58:30 <tdammers> jared-w: actually, they did both, to a degree
22:59:02 <jared-w> kadoban: Yeah but the php productivity slope is *so* slow that even with a billion lines in php there's /still/ got to be some point at which a complete rewrite is feasible from an economic and productive standpoint
22:59:06 <tdammers> they created Hack, and they are using Haskell for a few systems
22:59:34 <jared-w> tdammers: yeah I saw Hack, it looked really interesting. I still enjoy Haskell a lot more though
22:59:37 <tdammers> and no, a complete rewrite is never a smart move once you're past the early experimental stage of a project
22:59:52 <erisco> hi, I'm Netscape
23:00:14 <jared-w> lol fair enough. Incremental rewrite with the intension of becoming a complete rewrite, then?
23:00:26 <tdammers> the problem with a rewrite is that you now need two teams (one to keep the old version running, and one to write the new one), *plus* a way to manage communication between them
23:00:38 <tdammers> incremental, yes
23:00:55 <jared-w> True, and with how hard it is to manage communication between even just the one team...
23:00:59 <erisco> and you are also not moving forward as quickly, you're just standing in place doing the same thing differently
23:01:01 <tdammers> but then, if you're doing incremental, the first step is to modularize the existing code such that you can isolate modules for a rewrite
23:01:33 <jared-w> Like, I can't think of a single language I'd look at more than 10k of lines and say "obviously this needs a rewrite"--except for php
23:01:34 <dmwit> Heck, maybe if you do a good job at modularizing it you've managed to make it most of the way through a rewrite already!
23:01:36 <tdammers> erisco: yeah, same problem really - you need two teams in order to maintain velocity, and a lot of extra overhead to sync them
23:01:47 <erisco> but when you're burning millions keeping servers running, it can start to make financial sense to fix that...
23:02:07 <erisco> so that is why they have HHVM... only to improve performance so they can save money
23:02:21 <jared-w> Right, especially when Haskell is like 200-400x less power intensive than php (from what I read; is that about right?)
23:02:37 <tdammers> the point is, "modularize and rewrite only the important stuff" is almost always a better approach than "damn the torpedos"
23:02:50 <tdammers> jared-w: it's not, it depends how you use it
23:03:17 <tdammers> jared-w: you can't even compare the two like that, because the execution model and real-world deployment strategies are so radically different
23:03:55 <erisco> if you can show to a business that using language X will drop their costs by Y percent, and it will cost Z to do it, and thus it'll pay for itself quickly ...
23:04:09 <tdammers> jared-w: like, nobody in their right mind runs Haskell code as an apache module or a CGI script; you compile Warp in and call it a day, and that has a few dozen other consequences in the design space that can make a huge difference either way
23:04:22 <erisco> problem is where is the data to prove that ... and usually Y is small and Z is huge
23:05:07 <tdammers> the real problem is that both Y and Z are unknown, and that the larger the company, the more risk-averse they get
23:05:35 <sqooq> mfw I write something and it compiles just fine
23:05:45 <tdammers> also that developers often underestimate the cost of switching tech
23:05:47 <jared-w> And FB, while large, is still far less risk-averse code wise than Google. But, even then, not nearly risk-taking enough to just ditch all that php just 'cause
23:06:20 <erisco> if you conducted a study on dev costs across different languages ... could spark some changes
23:06:27 <erisco> I haven't actually seen any data of the sort
23:06:46 <erisco> I read that memory management was a 10% improvement
23:06:53 <sqooq> my code works O-O
23:06:56 <dmwit> I think the only data I've seen has basically said that "bugs per line" is constant across languages.
23:06:58 <sqooq> wow, that's a first
23:07:03 <tdammers> like, yes, sure, *I* could rewrite that thing in Haskell in two weeks and it'd outperform the Java mess we have right now, but then we'd also have to teach the rest of the team Haskell, and we'd have a much harder time hiring developers, because the "hire someone mildly incompetent" option no longer exists
23:07:13 <ongy> sqooq++ :) what did you write?
23:07:24 <jared-w> sqooq: that's one of my favorite parts of haskell; it never gets old :)
23:07:35 <sqooq> wait no, it worked in that one case, it doesn't work in this other case lmao
23:07:40 <sqooq> i'm getting there though
23:08:06 <tdammers> erisco: the problem with that is that there are many variables that are very hard to control here
23:08:22 <tdammers> erisco: particularly, developer proficiency
23:08:23 <sqooq> ouch
23:08:28 <jared-w> tdammers: then you get the other problem. Plenty of highly qualified Haskell coders you could hire but none of them ever want to touch the other shit ;)
23:08:28 <dmwit> (I don't know how Haskell gets this reputation for "if it compiles, it works". I've written plenty of bugs since I started doing Haskell.)
23:08:32 <sqooq> yeah what I wrote isn't going to help
23:08:43 <ongy> dmwit: compared to java or C...
23:08:43 <erisco> tdammers, I don't think it matters if you just collect enough data
23:08:49 <sqooq> i'm working on parsing a tree
23:08:56 <sqooq> made from []
23:09:06 <sqooq> [ [] [ [ ] ] ] etc.
23:09:09 <jared-w> sqooq: do you have a paste of your code we can look at?
23:09:21 <sqooq> it's so bad though I'm embarrassed
23:09:37 <tdammers> erisco: what if Haskell programmers are smarter on average, or better at programming, than PHP programmers?
23:09:40 <jared-w> lol you're fine, we all write bad code, it's part of being human
23:09:45 <tdammers> erisco: how do you quantify that?
23:09:48 <erisco> tdammers, there is a question of causality, no doubt
23:10:09 <ongy> dmwit: also kinda depends on what you do. I have done some low-ish IO bound stuff. And I usually don't have any mistakes going from idea to code. Sure there are bugs, but those are mostly because I don't understand what I'm interacting with
23:10:11 <kadoban> erisco: I don't think just collecting a bunch of data can account for biases in data and etc.
23:10:50 <tdammers> you would have to do something like take two large randomized programmer populations, and randomly assign them to one language or the other, then allow both groups some time to get proficient in the language, and then assign them both the same project and see who delivers fewer bugs
23:11:02 <dmwit> sqooq: If it will make you feel better, I'll promise to pre-judge you so harshly that no matter what code you show us it will be an improvement.
23:11:11 <sqooq> lolol
23:11:15 <kadoban> dmwit: Hah
23:11:19 <erisco> I think it is much simpler than you're thinking
23:11:20 <tdammers> even then you're still not at "double blind" levels of rigor
23:12:04 <sqooq> just know that I know that the way I defined "others" is very stupid, and not going in the direction that I want to be going in
23:12:08 <sqooq> http://lpaste.net/357334
23:12:19 <sqooq> newest at bottom
23:12:44 <jared-w> absolutely horrid code right there. I always put a blank line between my instances because it looks prettier... (jk)
23:12:51 <sqooq> kek
23:13:16 <sqooq> Btw my next step was to make a function that does bracket on the result of bracket recursively
23:13:20 <sqooq> but bracket doesn't even work
23:13:25 <sqooq> how do find outermost bracket
23:14:06 <erisco> you're either going to see nothing significant, in which case the language choice isn't the thing to worry about
23:14:26 <erisco> or you will see something significant, and that will point you to the relevant examples
23:14:27 <jared-w> Just for code style, but I would probably use 'where' inside the Monad instance. I don't like having global functions used in instance definitions; it feels weird to me.
23:15:08 <sqooq> i considered that
23:15:12 <jle`> i see it done a lot for teaching purposes
23:15:15 <sqooq> but didn't think it was a big deal
23:15:24 <jle`> also base does it a lot too
23:15:28 <jle`> so you're not exactly alone
23:15:30 <sqooq> but why where, why not just put the whole thing right there?
23:15:37 <jared-w> jle`: true, I didn't consider that :p
23:15:55 <erisco> it isn't something that is going to say that if you merely use the language you'll be a success... that is not the question to answer
23:16:10 <jared-w> sqooq: I like using where because it allows me to write my code in (for lack of a better word) a "Bird style"--very high level and declarative code that's immediately explained in more detail.
23:16:20 <jle`> base does it in situations where the function for that specific type is itself a nice thing
23:16:35 <jle`> worth giving its own name
23:17:07 <jle`> and for teaching purposes sometimes people like to introduce the useful function first, and explain why it's useful
23:17:15 <jle`> and then go "oh it's also usable as a method for this typeclass"
23:17:43 <jared-w> Right, I like that a lot for teaching. I'm a huge fan of seeing why something is useful and then "discovering" its use
23:17:59 <jle`> but yeah some examples of base doing it: instance Functor [] where fmap = map
23:18:41 <jle`> instance Functor ((->) r) where fmap = (.)
23:19:08 <jared-w> http://www.keithschwarz.com/darts-dice-coins/  this remains my /favorite/ tutorial and exploratory writeup I've ever seen for that reason
23:19:54 <sqooq> ok how about I find the next ] but keep checking and if I find another one use that one instead until I can't find anymore then return that
23:21:07 <jared-w> It's beautiful: It assumes a beautiful mathematical language, yet is aware of the limitations of machines. It starts from a very simple example and works up beautifully from there, solving each new 'obvious problem' with the next layer
23:21:47 <jared-w> sqooq: are the []s always balanced? That is, there's always the same number of [s as ]s?
23:21:57 <sqooq> yes
23:22:03 <sqooq> unless it's user error
23:22:53 <sqooq> crap I tried to do where block and broke things
23:23:15 <jared-w> So, you're attempting to parse a rose tree and turn it into a list of tuples?
23:24:28 <jared-w> I'm also not quite sure why your leaf has an 'a'; by necessity, that would make your Tree infinitely deep
23:25:20 <jared-w> oh whoops, nvm, I was wrong
23:26:02 <sqooq> I put a but chances are it will be the same type everytime, I just haven't decided how to implement the excess information which i'm leaving for later
23:26:12 <sqooq> maybe commas like "4,2,1
23:27:05 <sqooq> or sorry that's not really explaning the type, basically, do I create a new type that contains all that information, or do I use a tuple, I'm not sure yet
23:27:46 <sqooq> so I leave as a
23:39:39 <sqooq> hmm somehow trying to separate the where block (with a bunch of lambdas) into multiple lines caused parsing issues
23:39:43 <sqooq> but I couldn't figure out how to fix
23:39:52 <sqooq> it's pretty dense for one line
23:40:17 * frerich is paid to look at code like http://lpaste.net/9034818059117789184 and wishes for quasiquotations in Java :-/
23:41:01 <sqooq> nvm I just didn't indent enough I guess, weird
23:49:43 <jared-w> sqooq: did you update your paste with the new where block?
23:49:48 <jared-w> frerich: damn... that's painful
23:49:57 * jared-w has definitely written code like this before in Java
23:50:40 <sqooq> I tried to do return next and then that gave variable scope errors
23:50:47 <sqooq> so I was in the process of fiddling but here
23:50:47 <sqooq> http://lpaste.net/357336
23:50:53 <jared-w> Ahh, the beauty of having to drill down into nested structures without having "smart getters" and "smart setters"
23:52:52 <jared-w> I'd probably just write return v = Parser (\inp -> [(v, inp)])
23:53:27 <sqooq> yeah I just realized that
23:53:31 <sqooq> but why didn't this work
23:53:32 <sqooq>   return = result where                   result = (\v -> Parser (\inp -> [(v,inp)]))
23:54:25 <jared-w> Probably an indenting error somewhere? Maybe indent result v by 2-3 spaces and see what happens?
23:54:42 <sqooq> I already changed to the simpler version
23:54:50 <sqooq> actualyl
23:54:56 <sqooq> lmao the error is from line 80
23:55:03 <sqooq> I used result there
23:55:05 <sqooq> instead of return
23:55:08 <sqooq> got em
23:56:53 <tdammers> the very least I'd do with that Java code is write a bunch of utility functions for stuff like "find first child with identifier X", or whatever the first 3 nesting levels do
23:57:43 <treewilly> hh
23:58:15 <tdammers> also, it looks like most of these "if"s should really be asserts
