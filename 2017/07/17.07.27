00:18:37 <cocreature> osa1: I guess you are talking about automatically generated lenses? I would just write them manually in this case if it’s only 7 lenses
00:22:13 <osa1> I tried that but it's still too much boilerplate. reminded me of my java days where we wrote getters/setters for everything. too bad my editor can't generate my lenses like Java IDEs generate getters/setters :-)
00:23:32 <Lokathor> jle`, haskell is practically slacking off on the evangelion front compared to the rust strike forces
00:58:04 <quchen> The Rust strike forces give it quite a bit of negative publicity, I don’t think »slacking off« is so bad in this regard
01:00:26 <bvad> quchen: I agree, the whole 'rewrite it in Rust'-thing seems quite harmful 
01:00:56 <quchen> Haskell has had »if it typechecks it works« which was kind of the same kind of idiocy, but luckily we overcame this for the most part
01:01:10 <Cale> quchen: You mean that's not true? ;)
01:01:21 <srhb> quchen: Clearly you need stronger types. :-)
01:01:29 <quchen> Cale: Even if it were it comes across as quite smug
01:01:52 <Cale> It is true to an extent that I think is worth noting.
01:01:54 <bvad> Very much so, even if it has a hint of truth in it 
01:02:09 <quchen> srhb: I’m still stuck writing Mergesort in Agda, so I doubt that’s the case :-þ
01:02:13 <srhb> :-)
01:02:23 <srhb> Well, the whole intention of the type system is, more or less, to encode correctness
01:02:30 <srhb> Whether it's smug or not, it's partially the goal.
01:02:39 <quchen> Cale: »Worth« would be having concrete examples of what bugs the type system prevents, or what tests it makes unnecessary.
01:02:43 <bvad> srhb: Correctness at some level
01:03:17 <Cale> There are entire classes of bugs which we *have* eliminated pretty much entirely from real-world web applications, for instance JSON encoding bugs which accounted for >90% of the bugs on other web application projects I've worked on.
01:03:56 <bvad> Cale: That's a great example
01:04:10 <quchen> Cale: Counting the number of bugs I’ve had in Haskell programs, the statement is clearly false. Counting the number of bugs I’ve had in Java and PHP and C++ and Mathematica and what else have I written for food the »typechecker helps« is still something we should communicate, but better.
01:04:28 <quchen> I like to tell people about how I couldn’t write a test for bad behavior because it didn’t typecheck so I gave up.
01:04:45 <srhb> I think it's important to not be smug about "if it types, it works" but still make "if it types, it works" more and more true.
01:04:55 <Cale> Well, you end up with the same number of bugs, but those bugs are spaced farther apart in the virtual timeline of getting the project done
01:05:03 <quchen> Cale: JSON encoding bugs? How do those relate to the type system, Haskell’s in particular?
01:05:09 <Cale> You're just moving through that timeline faster
01:05:28 <quchen> I would imagine that Java is just as good as not having those errors (ignoring how clumsy the JSON facilities are to use)
01:05:46 <Cale> quchen: We have a bunch of types which are shared between the frontend and backend, and the library for serialising and deserialising them is TH-generated Aeson code, on both sides.
01:05:48 <thimoteus> i've heard people say that "if it typechecks it works" is more true for refactorings: i.e. if it worked, then you refactor, and it typechecks, it'll work
01:06:00 <srhb> thimoteus: That's often my experience, yes.
01:06:25 <quchen> Cale: I see, that’s a valid point. (Why TH and not Generic?)
01:06:37 <Cale> quchen: Apart from the one nasty thing about Just Nothing -> Nothing which I ran into about a year ago, there haven't been any problems with the faithfulness of this representation.
01:06:39 <srhb> quchen: Generic aeson stuff is pretty slow.
01:06:53 <Cale> quchen: Basically just because we have a bunch of custom TH for doing GADTs
01:07:07 <tsahyt> From what I can tell monadic parser combinators can be traced back to hutton and meijer's paper. what about applicative parsing?
01:07:09 <quchen> thimoteus: I’m agreeing with that much more
01:07:11 <bvad> srhb: Slow how? Very interested in this 
01:07:26 <srhb> bvad: It's actually stated in the aeson docs, iirc.
01:07:38 <bvad> srhb: Huh, I'll look that up!
01:08:05 <quchen> bvad: Generic gives you generic code that is executed at runtime. TH gives you actual Haskell code at compile time, specific to your problem.
01:08:24 <quchen> bvad: For the same reason, GHC writes its own Show instances generically, instead of using Generic to create them.
01:08:38 <bvad> quchen: Well when you state it like that I feel quite dumb.. 
01:08:45 <srhb> bvad: The wording is less strong than I remembered though: "The generated (TH) instance is optimized for your type so it will probably be more efficient than the following option (Generic)."
01:08:49 <Lokathor> main = unsafeCoerce $ unsafePerformIO $ ...
01:09:10 <Lokathor> there's your extra type safety for ya
01:09:15 <quchen> Lokathor: You can write unsafeCoerce with unsafePerformIO, so you can simplify that bit
01:09:35 <Lokathor> well sure, but you need an IO () at the end
01:09:49 <Lokathor> so even if you're coercing in terms of a second unsafeIO
01:10:49 * hackagebot bustle 0.6.1 – Draw sequence diagrams of D-Bus traffic – https://hackage.haskell.org/package/bustle
01:20:21 <lyxia> bvad, srhb: Here are benchmarks a few months old, TH is generally faster, up to x7. (there are two columns because that was a comparison between two versions of aeson) https://gist.github.com/Lysxia/7ea97543e1821ae7f73758e82d35b6a9
01:23:14 <srhb> lyxia: Thanks a lot!
01:27:06 <bvad> lyxia: That's.. Interesting 
01:28:44 <lyxia> I think it should be possible for Generic to be as fast as TH.
01:29:43 <srhb> I don't really understand the aversion to TH that some people seem to have though. I think it's quite convenient.
01:29:51 <srhb> Though when it sometimes stops being Haskell entirely, it does get a bit.. Messy :-P
01:30:04 <bvad> srhb: Isn't the main complaint compile times?
01:30:27 <hulufei> hello, i try to implement a funtion as following type, (*>) :: Applicative f => f a -> f b -> f b, I saw someone write like: (*>) = liftA2 (const id), i'm wondering if i can write directly like this: (*>) _ fb = fb
01:30:45 <quchen> hulufei: No!
01:30:46 <pacak> Given "type T m a = A (B m) a" - can I define a monad transformer instance without using a newtype?
01:30:59 <srhb> bvad: Could be. :)
01:31:10 <quchen> hulufei: The difference is important: *> does not ignore its first argument. It discards its value, but it still performs it.
01:31:34 <quchen> hulufei: Example: putStrLn "hello" *> putStrLn "world" will print "hello\nworld\n", and not just "world\n".
01:32:29 <bvad> quchen: "if it compiles.." ;)
01:32:44 <quchen> bvad: :-þ
01:32:45 <srhb> And consider the difference between `getLine <* getLine` and getLine *> getLine
01:32:50 <jle`> pacak: what monad transformer instance do you want
01:33:25 <jle`> a monad instance for what?
01:33:31 <jle`> *monad transformer instance
01:33:41 <jle`> what do you want the type of lift to be?
01:33:48 <hulufei> quchen thanks
01:33:49 <pacak> T m a to m a
01:33:51 <jle`> ... maybe give us the version you're imagining with the newtype
01:33:58 <pacak> Hmm.... The other way around
01:34:11 <quchen> hulufei: If you write *> in do-notation, it’s do { _ <- effect1; effect2 }
01:34:20 <pacak> With newtype it would be instance MonadTrans T ...
01:34:30 <quchen> hulufei: Your »simpler« implementation would be just do { effect2 }, completely ignoring effect1
01:34:43 <jle`> pacak: i mean, with the implementation too
01:34:47 <jle`> it's not exactly clear what you want
01:35:20 <pacak> jle`: A is operational monad,  B is some massive functor with extra state in it
01:35:22 <jle`> and what would the newtype be?
01:35:29 <jle`> pacak: like i said, just write it out
01:35:39 <lyxia> srhb: it also messes with documentation (can't add comments on generated declarations), and it makes implementations somewhat hard to read.
01:35:39 <jle`> that'll solve any ambiguity or uncertainty
01:35:47 <jle`> instead of guessing what you mean, we can just see it :)
01:36:08 <pacak> newtype T m a = T { runT :: A (B m) a } -- something like that for t
01:36:32 <jle`> and the instance?
01:37:08 <pacak> just a sec
01:39:06 <jle`> also i don't buy that B is a functor....
01:39:08 <jle`> *Functor
01:39:15 <jle`> if it is, your thing would be ill-kinded
01:39:35 <jle`> if B is a Functor, then that means m :: *, but if you want it to be a monad transformer, m has to be * -> *
01:40:17 <pacak> newtype Nom m a = Nom { runNom :: Program (PI m) a }
01:40:18 <pacak> instance MonadTrans Nom where lift act = Nom (singleton $ Lift act)
01:40:49 <pacak> Hmm... Right. B (PI) used to be a functor in some older version, but now it's just a datatype that gets handled by operational monad evaluator
01:41:29 <pacak> data PI s a where  Lift    :: s a -> PI s a -- relevant branch from PI
01:42:09 <pacak> It typechecks just fine, but newtype makes evaluator much more ugly
01:42:35 <jle`> you want `lift :: m a -> A (B m) a`, right?
01:42:45 <pacak> Right
01:42:58 <jle`> yeah, you can't really make this work as it is because the shape of the types don't fit
01:43:06 <jle`> :t lift
01:43:08 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
01:43:10 <toddWannaCode> Hey which file should I add to .gitignore while using stack?
01:43:21 <toddWannaCode> Ou sorry. I thought I was in beginners
01:43:38 <jle`> pacak: you can use a newtype wrapper to get a MonadTrans instance, but you can always just write your own lift
01:43:43 <jle`> liftT
01:43:47 <bvad> toddWannaCode: That kind of question is still very welcome here :)
01:43:51 <jle`> toddWannaCode: you probably just need /.stack-work :)
01:44:08 <toddWannaCode> Ou okay. Thanks. :D
01:44:09 <jle`> toddWannaCode: lucky for you, #haskell was made for beginner questions
01:44:20 <bvad> toddWannaCode: There's always https://www.gitignore.io/api/haskell ;) 
01:44:42 <toddWannaCode> Whoa that's nice. I never knew about it. Thanks.
01:44:52 <jle`> pacak: there really aren't that many monad-transformer-polymorphic functions out there
01:45:15 <jle`> so you wouldn't lose much by just writing a custom liftT :: m a -> A (B m) a
01:45:24 <jle`> besides api discoverability
01:45:31 <pacak> jle`: That would work, but I'd like to minimize amount of magical functions you need to know to work with it.
01:46:10 <bvad> toddWannaCode: there's a neat shell alias for it too, so you just end up writing `gi haskell >> .gitignore` in you shell  
01:46:13 <jle`> yeah, it's just impossible to write a monadtrans instance on the type as it is now because of the shapes
01:46:17 <pacak> Telling somebody that this forms a MonadPlus and a MonadTrans seems better than "use this oddly familiar looking function to do this".
01:46:38 <toddWannaCode> I just curled it, but a shell alias would be cooler.
01:46:54 <jle`> since `m a -> A (B m) a` can't unify with `m a -> t m a`
01:47:51 <pacak> Yea... I guess I'll try to twist evaluator a bit.
01:48:06 <pacak> to make it less ugly
01:48:32 <jle`> it's kind of an issue with classes like Functor, etc. in general
01:48:46 <jle`> since typeclass instances are matched on a rigid structure
01:49:14 <jle`> also we can't have the presence of a type synonym cause different behavior, because type synonyms are supposed to be invisible to the compiler
01:49:25 <pacak> Right. And partially applied type synonyms are not a thing.
01:50:02 <jle`> otherwise you could write something like type Sum = Int, instance Monoid Sum where mappend = (+); mempty = 0
01:50:29 <jle`> and type Product = Int; instance Monoid Product where mappend = (*); mempty = 1
01:50:42 <jle`> and now your program's behavior would magically change if you used the Sum type synonym instead of the Product type synonym
01:51:04 <jle`> but type synonyms aren't supposed to change anything so yeah :|
01:52:41 <Athas> Anyone got interesting use cases for scans with interesting operators (i.e. not just prefix sum)?
01:53:20 <jle`> i wrote an entire library about combinators to build scans
01:53:50 <jle`> it is ostensibly a scanl library, even though i didn't realize it until after i finished it heh
01:54:19 <jle`> @hackage auto
01:54:19 <lambdabot> http://hackage.haskell.org/package/auto
01:55:30 <pacak> Hmm... Actually I'm stupid. There is support for monad transformers in operational monad already.
01:57:39 <kuribas> merijn: I've been thinking about the cross compiling TH problem.  Wouldn't it be interesting to disallow IO, but allow pure code in TH for cross-compiling?  That would already include a lot of use cases (like lens).
01:58:10 <kuribas> merijn: it could then emulate word-size etc... for the target platform.
01:58:43 <kuribas> merijn: IO in TH seems like a bad idea anyway.
01:58:48 -frerich(~frerich@kde/raabe)- Is anybody aware of other languages (or tool chains) which provide Quasi Quotation functionality as in Haskell? E.g. maybe there are C++ preprocessors doing that?
01:59:03 <pacak> frerich: lisp?
01:59:20 <quchen> If you cripple Lisp macros enough you get TH
01:59:21 <merijn> kuribas: Disallowing IO in TH eliminates a HUGE class of useful uses of TH
01:59:35 <kuribas> merijn: like?
02:00:08 <merijn> kuribas: Anything that generates schemas from files (like persistent), includes file directly (like include-file) or otherwise precompute something from an external tool
02:00:27 <kuribas> oh right...
02:00:53 * pacak generates parsers from schema
02:09:16 <phz_> hey, is there a way to check which stackage resolver is the “latest” despite the nightlies?
02:11:12 <jle`> stackage.org lists the latest ones
02:11:36 <phz_> I mean, is there a way I could get a YAML giving the latest one?
02:11:39 <phz_> or do I need to curl and parse?
02:22:26 <merijn> Hah, with 8.2 using Cabal-2 everyone will have to switch to cabal-install-2.0 and maybe someone will fix my tools for me :p
02:22:56 <ongy> which tools break?
02:23:18 <merijn> ongy: ghc-mod/hdevtools, etc. I have a hacky workaround for ghc-mod, but a proper fix would be better
02:23:32 <merijn> ongy: Actually, I suppose they still work, as long as you don't use new-build...
02:23:35 <merijn> bugger
02:35:47 <lyxia> phz_: https://www.stackage.org/download/snapshots.json
02:37:30 <phz_> lyxia: great, thanks
02:49:08 * hackagebot megaparsec 6.0.0 – Monadic parser combinators – https://hackage.haskell.org/package/megaparsec
02:54:03 * hackagebot cabal2nix 2.4 – Convert Cabal files into Nix build instructions. – https://hackage.haskell.org/package/cabal2nix
03:13:31 <jgt> is there a flag I can pass to Stack that will tell it to use the system resolver, regardless of which directory I'm in?
03:26:06 <sm> jgt: try --stack-yaml=$HOME/.stack/global/stack.yaml
03:27:12 <jgt> sm: I'm not sure this is reliable, e.g., on my machine it's at $HOME/.stack/global-project/stack.yaml
03:27:12 <phadej> that's quite long for occasional stack install some-tool or stack ghci
03:27:40 <jgt> I'm fine with verbosity in this case; it's reliability I'm after
03:28:22 <sm> "stack path" will probably give the path
03:28:25 <jgt> and the Stack docs say the global config might exist at /etc/stack/config.yaml, but that's not the case on my machine
03:28:48 <sm> stack path --config-location
03:29:07 <jgt> sm: yeah, but running `stack path` in a dir with a stack.yaml in it will use that project's config, not the global one
03:29:18 <sm> ack
03:29:23 <jgt> so the resolver will be wrong :P 
03:30:01 <sm> this'll definitely work: alias stackg="stack --stack-yaml=$(cd; stack path --config-location)"
03:30:10 <jgt> I _maybe_ could run the thing in a subshell, and cd into $HOME first, but it feels hacky
03:30:22 <jgt> ah, I see we have essentially the same idea
03:31:35 <jgt> where this could potentially fail is if there's a $HOME/stack.yaml
03:31:36 <sm> I mean, that $() will probably evaluate at alias definition time, but just stay in the same directory..
03:31:58 <sm> problem solved!
03:32:27 <jgt> it doesn't seem 100% reliable, but it's probably good enough for now
03:32:31 <jgt> sm: thank you :)
03:32:37 <sm> 8-)
03:34:30 * hackagebot creatur 5.9.17 – Framework for artificial life experiments. – https://hackage.haskell.org/package/creatur
03:35:00 <sm> jgt: could you just (cd; ...the command...) ?
03:35:44 <sm> that worked for me recently
03:35:44 <jgt> yes, but I'm fairly sure that this is not exactly the same as specifying the global config
03:35:58 <jgt> in most cases, the result is the same
03:36:10 <sm> as long as there's not a ~/stack.yaml, I guess
03:36:20 <jgt> but the result would be different if some user — for whatever reason — placed a stack.yaml in their home dir
03:36:22 <jgt> yeah, exactly
03:36:26 * sm nods
03:36:58 <sm> it's funny how hard it can be to do simple things in a bulletproof way
03:38:08 <sm> here, I guess it's because stack is kind of slippery here, the right fix is probably a built in flag (yet another..)
03:39:23 <barrucadu> You could probably use `stack --system-ghc --skip-ghc-check`
03:40:53 <jgt> barrucadu: my understanding was that the system GHC is different from the isolated global GHC that Stack would install
03:41:01 <barrucadu> Ah, probably
03:46:58 <jgt> oh wow, I think I solved it
03:47:00 <jgt> stack path --stack-yaml "$(cd; stack path --config-location)"
03:47:22 <jgt> not sure if this is clever or terrible
03:47:26 <jgt> probably the latter
03:48:05 <jgt> also, sorry for pinging someone inadvertently 
03:48:08 <jgt> :P
03:49:21 <sm> this will definitely work. ship it!
03:56:21 <barrucadu> jgt: There's someone called e in this channel, worrying about pinging people is futile :p
03:56:40 <jgt> for context, I'm working on an Ansible role for setting up Keter
03:57:03 <jgt> I think it's great and people should use it, but it's not exactly painless to install
04:26:03 * hackagebot hledger-iadd 1.2.3 – A terminal UI as drop-in replacement for hledger add – https://hackage.haskell.org/package/hledger-iadd
04:54:32 <Franciman> Hi
04:54:41 <Franciman> Why isn't Data.Vector.Storable an instance of Foldable?
04:57:19 <cocreature> Franciman: it can’t be. Foldable requires that length has type "Vector a -> Int" but storable vectors only give you "Storable a => Vector a -> Int"
04:57:26 <cocreature> and the same holds for most other methods
04:57:40 <Franciman> ahh
04:57:46 <Franciman> it's because of the constraint on a
04:57:51 <Franciman> cool, thank you
04:57:51 <cocreature> exactl
04:59:29 <Franciman> cocreature, so, If I want to mapM_ over a container of things that contain a datatype I know
04:59:34 <Franciman> but I don't know the container?
05:01:18 <[exa]> Franciman: if you have the exact datatype, you can make a specific Foldable instance without (Storable a)
05:01:33 <Franciman> uhm
05:01:49 <Franciman> [exa], how?
05:01:58 <Franciman> I mean
05:02:09 <cocreature> I don’t think that’s true. Foldable enforces that your instance works for all types
05:02:09 <Franciman> isn't the instance independent from the element contained by the foldable?
05:02:24 <[exa]> oh so, I didnt read the "I dont know the container"
05:02:29 <[exa]> sorry
05:02:59 <phadej> data Weird a where Weird :: S.Vector Int -> Weird Int
05:03:04 <phadej> that can be Foldable
05:03:37 <Franciman> the baseline is this: I have a type A, sometimes I want to map over [A] and sometimes over Data.Vector.Storable.Vector A
05:04:10 <Franciman> I could use the IsList typeclass, maybe
05:04:14 <phadej> or data Weird a where Weird :: Storable a => S.Vector a -> Weird a -- but that has non-trivial price
05:05:08 <Franciman> ah phadej I can try, thanks
05:06:18 <phadej> are you using storable vectors to reduce memory usage?
05:06:34 <Franciman> no
05:06:38 <Franciman> for FFI
05:06:43 <phadej> I see
05:09:19 <phadej> fractalsea: can't you just toList your S.Vector before giving it back to haskell? after all that will be done lazily
05:09:47 <Franciman> phadej, you mean when coming from ffi?
05:09:51 <Franciman> or to call this function?
05:10:12 <phadej> Franciman: I assume you get vector back from ffi, and do some post-processing on it?
05:10:16 <Franciman> yes
05:10:31 <phadej> I'd convert it to list/normal vector before giving back to Haskell
05:10:43 <Franciman> Also, I'm using Data.Vector because I need take and drop O(1)
05:10:56 <Franciman> at least for what I came up for now 
05:11:23 <Franciman> I need to show a waveform from audio data. So I calculate the ratio PeaksPerPixel which is a Double
05:11:42 <Franciman> so I can't just group elements of the peaks array in groups of, say 5
05:11:42 <phadej> and keep it as Storable.Vector only when writing FFI glue
05:11:57 <phadej> (e.g. if you get it, and then pass right back to next ffi call)
05:12:13 <Franciman> because sometimes, because of rounding, I need to considere a peak 2 times
05:13:13 * hackagebot SSTG 0.1.0.8 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
05:14:30 <Franciman> and the easiest way I could think of doing this involves doing take peakPerPixelRounded . drop oldPeaks
05:27:05 <Myrl-saki> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Type-Equality.html#t:-61--61-
05:27:27 <Myrl-saki> What does `type (==) Bool a b` mean?
05:27:47 <Myrl-saki> Why is there Bool, a and b there when (==) only takes 2 inputs?
05:28:19 <phadej> Bool is the kind of arguments
05:28:37 <phadej> (==) :: forall k. k -> k -> Bool
05:28:38 <cocreature> we really need to make haddock better at rendering this kind of code
05:29:33 <phadej> cocreature: different color/styling for kinds? :)
05:29:35 <Myrl-saki> phadej: So you have to supply the k?
05:30:02 <phadej> Myrl-saki: no, afaik you cannot, even you want ot
05:30:12 <cocreature> phadej: yeah that would probably help. being able to display them in infix form if they’re written as such would also be nice
05:30:47 <Myrl-saki> phadej: I'm confused. Why is Bool specified then?
05:31:14 <phadej> Myrl-saki: read the note in the source: https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Type.Equality.html#%3D%3D
05:32:24 <phadej> or https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Data.Type.Equality.html#%3D%3D, which has the same note, but less broken higlights elsewhere :P
05:33:24 * hackagebot hspec-megaparsec 1.0.0 – Utility functions for testing Megaparsec parsers with Hspec – https://hackage.haskell.org/package/hspec-megaparsec
05:33:46 <Myrl-saki> phadej: I mean.
05:33:56 <phadej> My guess: if you need type-level (==) you will understand that note. And if you don't understand, then you probably want type-equality constraint a ~ b, or you overthink your problem
05:34:25 <Myrl-saki> phadej: I want to work with statically-known-length vectors.
05:34:29 <Myrl-saki> phadej: Just for the fun of it.
05:34:50 <Myrl-saki> phadej: I'm trying to read https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html right now.
05:35:01 <Myrl-saki> phadej: (That's how I got to (==))
05:35:17 <phadej> You don't need (==) for vectors
05:35:43 <phadej> you probably don't even need (~) until very late in the story
05:35:47 <Myrl-saki> phadej: Yeah, but I'm trying to understand the TypeLits declarations because of curiosity.
05:36:09 <Myrl-saki> phadej: I think I badly phrased my question. How is passing `Bool` as an argument not considered as supplying the kind?
05:36:28 <phadej> Myrl-saki: you cannot explicitly supply the kind
05:36:46 <phadej> you can explicitly supply a type:
05:36:49 <phadej> > id @Int 1
05:36:51 <lambdabot>  error:
05:36:52 <lambdabot>      Pattern syntax in expression context: id@Int
05:36:52 <lambdabot>      Did you mean to enable TypeApplications?
05:37:02 <phadej> in GHC-8
05:37:22 <phadej> (because id :: forall a. a -> a)
05:37:47 <phadej> but there isn't ExplicitKindApplication (yet?), kinds are always inferred for you
05:37:59 <Myrl-saki> phadej: I mean for type-level (==)
05:38:06 <phadej> but haddock shows them, otherwise all those instances of (==) would be simply (==) a b
05:38:11 <Myrl-saki> (Sorry if I'm not making that much sensseee)
05:38:22 <phadej> as I said: kinds are always inferred for you
05:38:31 <Myrl-saki> phadej: Ohhh. So it's just Haddock being Haddock?
05:38:56 <phadej> Myrl-saki: yes, OTOH in that case you really want to know for which kinds that type family is declared
05:39:01 <Myrl-saki> phadej: (On another note. Why is the Kind showing though?)
05:39:19 <phadej> >  you really want to know for which kinds that type family is declared
05:39:21 <lambdabot>  <hint>:1:46: error: parse error on input ‘type’
05:39:29 <Myrl-saki> phadej: Ah, thanks.
05:39:29 <phadej> otherwise it would be a long list of type (==) a b
05:40:59 <Myrl-saki> phadej: What library should I use for statically-known vectors? There at least 2.
05:41:32 <Myrl-saki> I think fixed-vector rolls their own Nat.
05:42:19 <phadej> Myrl-saki: that really depends
05:42:37 <phadej> I haven't used any, and haven't written my own either
05:42:43 <Myrl-saki> phadej: Ah.
05:42:50 <Myrl-saki> I'll just experiment with both.
05:43:15 <phadej> but I'd probably use `linear`
05:43:40 <phadej> http://hackage.haskell.org/package/linear-1.20.6/docs/Linear-V.html
05:44:44 <Myrl-saki> phadej: Thanks.
05:45:42 <phadej> but it cheats, as it doesn't have "nil | cons ..." :)
05:46:32 <Myrl-saki> phadej: You mean it uses an underlying type?
05:46:53 <Myrl-saki> (My mind does on GADT)
05:47:08 <Myrl-saki> And reflection.
05:47:59 <phadej> Myrl-saki: yes, the length-type-value is just a phantom variable
05:48:13 <phadej> So you can have V Vector.empty :: V 123
05:49:18 <Myrl-saki> Oh. Right.
05:49:35 <Myrl-saki> Thanks. I really appreciate the help.
05:49:48 <phadej> i.e. `linear` is practical, but not theoretically elegant
05:50:22 <Myrl-saki> phadej: Yeah. I'm making something practical anyway. C:
05:54:53 <akfp> is there some lens magic for sorting on a specific subfield?
05:55:25 <akfp> if I write over subfield (sortOn _subsubfield) data  then _subsubfield is a normal accessor, not a lens
05:59:40 <cmotoche> Hello everyone. Do you know how to concatenate tow `NonEmpty a` lists? Something like: `NonEmpty a -> NonEmpty a -> NonEmpty a`
05:59:53 <cmotoche> s/tow/two
05:59:58 <Boomerang> How about <> ?
06:00:12 <akfp> a <> b
06:00:39 <merijn> or mappend if you like prefix
06:01:05 <phadej> mappend won't work
06:01:12 <phadej> NonEmpty isn't a monoid
06:01:15 <merijn> oh, right
06:01:16 <cmotoche> Thanks
06:01:17 <merijn> duh
06:01:24 <cmotoche> But, it is a Semigroup
06:01:33 <phadej> it is
06:01:37 <cmotoche> :)
06:01:39 <phadej> so use the /right/ <>
06:01:39 <cmotoche> Thanks!
06:05:41 <quchen> Isn’t <> from Semigroup nowadays?
06:05:45 <quchen> Even the one exported from Monoid?
06:06:05 <merijn> quchen: Not yet
06:06:14 <merijn> quchen: Since Semigroup isn't a superclass of Monoid yet
06:06:14 <quchen> Oh.
06:06:18 <merijn> At least, not in 8.0
06:06:37 <quchen> Right.
06:07:46 <merijn> quchen: I think 8.4 is supposed to enable warnings for missing superclass and 8.6 flip the switch?
06:08:06 <quchen> Maybe.
06:08:15 <quchen> I think -WCompat already warns about this though
06:08:23 <quchen> Since 8.0
06:08:30 <quchen> I may have put that in. Or maybe it was Herbert.
06:30:19 * hackagebot propellor 4.6.1 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
06:42:02 <k0ral> :i Data.Map.Lazy.Map
06:42:14 <k0ral> lambdabot: help
06:42:35 <lyxia> lambdabot doesn't know :i
06:43:50 * hackagebot biohazard 0.6.15 – bioinformatics support library – https://hackage.haskell.org/package/biohazard
06:54:37 * hackagebot snowtify 0.1.0.2 – snowtify send your result of `stack build` (`stack test`) to notify-daemon… – https://hackage.haskell.org/package/snowtify
06:54:37 * hackagebot cassava-megaparsec 1.0.0 – Megaparsec parser of CSV files that plays nicely with Cassava – https://hackage.haskell.org/package/cassava-megaparsec
06:58:50 <fendor> hey, how can i capture in template haskell an exisitng function? for example, if i'd like to use mappend, how can i bind to that function?
06:59:51 <merijn> fendor: Usually you'd write a bunch of regular haskell, quasiquote it to turn it into a template expression and then use that
07:00:06 <fendor> yeah, i'm trying this
07:00:55 <fendor> merijn, i'm experimenting, and I'm not sure what I'm making wrong, can you give me some pointers? https://hastebin.com/ihuhahuneq.hs
07:01:48 <merijn> fendor: I've mostly only done simple things with TH, so without an error I honestly have no idea :)
07:02:09 <glguy> $first_
07:02:24 <fendor> merijn, https://hastebin.com/tabevupimu.vbs
07:03:06 <merijn> Well, have you tried us -ddump-splices? ;)
07:04:05 <fendor> i tried, I added to the ghc-opts -ddump-splices, but it did not show more results, how do I have to supply this option?
07:05:11 <lyxia> the splices are dumped into a separate file
07:05:47 <fendor> and i'm rather sure, that i did not use a newName without binding to it, and also the errors are shown with monoid and mappend, which I tried to capture via mkName
07:06:04 <glguy> fendor, did you mean to write Functor or Monoid?
07:06:43 <fendor> glguy, well, you are right, this is certainly wrong, i meant to write monoid, but was looking on the tutorial from practical template haskell tutorial
07:07:14 <fendor> however, the error persists
07:07:38 <fendor> where should the splices be dumped to?
07:08:51 <lyxia> usually in the same place as object files and other compilation artifacts
07:09:05 <glguy> you probably need to not use [d| quotes for the class methods
07:10:08 <fendor> glguy, these leads to a compiler error
07:10:44 <fendor> glguy, a parser error to be a little more precise
07:10:58 <glguy> or need to import Data.Monoid if this is an older GHC. the error message indicates you're defining a new mappend, not using the class method names
07:11:15 <glguy> what are these?
07:12:21 <merijn> Anyone here use Chart? Know if it's possible to texture bars plotted with it?
07:12:55 <fendor> glguy, I'm using Classy Prelude, which should import Data.Monoid by default
07:16:31 <fendor> maybe I need a clause?
07:20:04 <glguy> fendor: instead of using [d| , use funD and 'mempty
07:21:01 <fendor> glguy, what does 'mempty do? where is the difference to ''Monoid for example?
07:21:19 <glguy> ones a type the other a value
07:21:37 <glguy> name of a*
07:22:46 <fendor> ok, so this does a name capturing?
07:24:12 <quchen> I want to render SQL statements as string. What’s a simple function to do the necessary escaping so single quotes and friends don’t break my application?
07:24:42 <quchen> (There is no security required at all, all users are friendly, I just want to prevent mistakes)
07:31:00 <fendor> ok, i almost did it now :D
07:32:20 <fendor> i did it! thanks to your help!
07:33:08 <fendor> for anyone interested, i post the source code on hastepin: https://hastebin.com/etaxoyapig.hs
07:34:08 <fendor> it actually looks more concise now, but can still be improved, for example the Clause statement should rather return an Q Clause, but I did not find the appropiate function in the documentation yet
08:00:55 <Myrl-saki> class Modular s a | s → a where modulus :: s → a
08:01:07 <Myrl-saki> (I'm reading reflection rn)
08:02:09 <Myrl-saki> And it says that the fundep signifies that the type s represents a value of at most one type a
08:02:53 <Myrl-saki> Aaanndd I should read properly. I thought that it says "represents one value..."
08:04:59 <ReinH> | s -> a means that s uniquely determines a.
08:06:46 <Myrl-saki> ReinH: Yeah. I messed up. I thought it said that "s uniquely determines a value of a"
08:07:00 <Myrl-saki> ReinH: I should stop using IRC as a rubber duck.
08:07:18 <shapr> I certaintly do that
08:07:58 <Myrl-saki> shapr: It's effective too, because you feel pressured to reclaim yourself. :D
08:08:21 <shapr> yeah, that's why I give so many talks
08:08:55 <shapr> 1. I will give a fifteen minute talk on this subject 2. wait, do I really know enough? 3. many hours of research 4. give well-informed talk
08:09:22 <Myrl-saki> shapr: I don't believe you. There's no crippling depression part.
08:09:25 <shapr> I got that trick from edwardk, it's a great way to force some of the many thunks in my brain
08:09:50 <shapr> Myrl-saki: that only happens in the rare case where my talks fall apart and I have to cancel
08:10:01 <shapr> that's only happened a few times, but they were epic fails :-(((
08:10:13 <Myrl-saki> shapr: Oh wow.
08:10:25 <Myrl-saki> shapr: Can you give an instance? That seems... interesting?
08:10:43 <shapr> I'd rather not, they were ... let's just not talk about it.
08:10:51 <Myrl-saki> shapr: Ah shur. It's fine.
08:11:13 <shapr> I will say, give your talk a bunch of times before the 'real' talk, more times for a larger crowd
08:12:02 <Myrl-saki> shapr: Where do you find an audience for the practice-talk?
08:12:27 <shapr> my workplace does one hour of lightning talks every thursday at 4pm, so I give a talk there most weeks
08:12:43 <shapr> I also give longer talks at my local functional programming meetup
08:12:44 <Myrl-saki> shapr: Ah. Tru. The environment matters a lot.
08:13:10 <shapr> I did an hour long comparison of python/flask and haskell/spock a month or two ago
08:13:34 <shapr> and I did a "lessons learned from advent of code 2016" talk where I compared my day 1 solution to glguy's day 1 solution
08:14:00 <Myrl-saki> shapr: I searched "functional programming $STATE" and got GoLang. :(
08:14:16 <shapr> oh, my talks are at Atlanta Functional Programming in Georgia
08:14:45 <Myrl-saki> shapr: I should try making a group and see if I can find other people. Thanks!
08:14:50 <shapr> yes, try it!
08:15:07 <Myrl-saki> shapr: Also, Spock is some nice stuff. It's my preferred framework.
08:15:58 <shapr> yeah, I like spock, it's a good balance of sweeping some complication under the monad and leaving enough freedom to build something useful.
08:54:11 <infandum> I'm getting Numeric.SpecFunctions.incompleteBeta_: x out of [0,1] range. in one of my programs. I'm trying to track where it's happening but I have no idea. I think it's from hmatrix, but incompleteBeta_ isn't in there (stackage nightly-2017-04-07). How can I locate the problem?
08:56:58 * hackagebot versions 3.2.0 – Types and parsers for software version numbers. – https://hackage.haskell.org/package/versions
09:03:21 <NemesisD> intuition question. in something like conduit, if i'm doing something like Data.Conduit.List.map (\x -> (foo, x)), in the runtime is it only allocating foo once and basically just costing me a reference to foo for each item in the conduit?
09:03:30 <nshepperd> infandum: there should be some RTS options somewhere to enable a stack trace for these errors
09:03:40 <nshepperd> i don't remember exactly how you do it
09:04:16 <monochrom> Yes NemesisD.
09:04:50 <erisco> that's just a question of how tuples work, as far as I can tell
09:05:00 <nshepperd> infandum: https://wiki.haskell.org/Debugging "Recent versions of GHC allow a dump of a stack trace (of all cost centres) when an exception is raised. In order to enable this, compile with -prof, and run with +RTS -xc. (Since only the cost centre stack will be printed, you may want to add -fprof-auto -fprof-cafs[1] to the compilation step to include all definitions in the trace.)"
09:05:05 <NemesisD> yeah, i figured it didn't have much to do with conduit, but i wanted to provide full context
09:05:42 <erisco> if it was an inlined field then you'd have a copy per
09:05:53 <dolio> Is foo supposed to be a variable name whose definition is outside the lambda expression? Or a complex expression?
09:06:22 <infandum> nshepperd: Thanks!
09:08:09 <monochrom> NemesisD: I was wrong. I just tried "f xs = map (\x -> (sin 1 + cos 2, x)) xs" and looked at the core. No.
09:08:40 <erisco> I assumed it was a variable name
09:08:46 <monochrom> But yeah programmers should grow out of saying "foo" all the time.
09:09:14 <erisco> foo that
09:09:31 <monochrom> I recommend saying "smurfing" instead.
09:09:49 <NemesisD> for full context: i'm doing some CSV processing with conduit. i need to capture the header row first on the consumer side and preserve it to the sink side so i can maintain exact column order
09:10:10 <NemesisD> so one way to do that without introducing a state transformer is just to map it over each row in the conduit
09:10:44 <NemesisD> so foo in this case is headers, and it is the same value, parsed only once on the consumer side, but it is mapped over each item in the conduit. i realized i didn't have a good understanding of the cost of this
09:13:22 <infandum> nshepperd: Yes, that's perfect. I didn't realize that -xc worked with "error".
09:15:52 <nshepperd> NemesisD: as long as it is a variable bound with let or a function argument it should be shared
09:17:32 <dolio> Also if you write `(,) expr` it will be shared.
09:17:51 <NemesisD> dolio: does it work for tuple sections too?
09:17:54 <dolio> As long as that whole expression is shared.
09:18:06 <dolio> I doubt it.
09:18:17 <NemesisD> i find that kind of surprising
09:19:56 <NemesisD> aren't (expr,) and (,) expr equivalent?
09:21:37 <dolio> I don't know exactly how it desugars.
09:21:39 <MarcelineVQ> yep.     for some meaning of equivalent
09:21:52 <dolio> But, consider that `(,expr)` can't desugar like that.
09:22:16 <dolio> So it might have been easier to just always turn into lambda expressions.
09:23:26 <dolio> I mean, you could desugar like '(\y x, (x,y)) (expr)` and similar, I guess.
09:27:02 <SepakoRayl> Yo
09:27:40 <SepakoRayl> Has anyone worked with the llvm-hs or llvm-general bindings?
09:28:15 <SepakoRayl> I am trying to decide how to handle simple nested functions
09:28:53 <SepakoRayl> Do i have to implement lambda lifting?
09:29:53 * hackagebot creatur 5.9.18 – Framework for artificial life experiments. – https://hackage.haskell.org/package/creatur
09:39:28 * hackagebot rest-gen 0.20.0.1 – Documentation and client generation from rest definition. – https://hackage.haskell.org/package/rest-gen
10:05:35 <boxscape> If I want to import Data.Text.IO, is there a more idiomatic way to hide the standard functions than to just write "import Prelude hiding (<all IO functions>)"?
10:06:14 <cement_> try "import qualified Data.Text.IO as FOO"
10:06:33 <boxscape> but then I have to qualify all my calls :(
10:06:46 <cement_> afaik, it's idiomatic
10:06:49 <boxscape> ok, thanks
10:06:57 <lyxia> what about hiding the prelude altogether
10:07:15 <lyxia> and only import the bits you need
10:07:25 <eelster> lyxia Would you be able to import while hiding prelude?
10:07:37 <boxscape> sure, that would be an option. I'm not sure if it's shorter or longer than hiding the IO functions
10:08:25 <lyxia> at least with that you know where an identifier comes from, rather than where it does not come from...
10:08:34 <glguy> boxscape: it's common to import both Data.Text and Data.Text.IO into the same alias, import Data.Text as Text; import Data.Text.IO as Text
10:08:35 <boxscape> I was hoping I could just do something like "import System.IO ()", but that doesn't seem to work
10:08:39 <glguy> or instead of Text you can use T
10:08:40 <boxscape> glguy: I see
10:08:42 <boxscape> thanks
10:08:58 <glguy> Oh, and to use qualified imports
10:10:05 <glguy> https://github.com/glguy/irc-core/blob/v2/src/Client/Configuration.hs#L73-L75
10:10:32 <cement_> anyone ever used pseudoterminals for something? I'm needing to run commands on a limited operating system for a router, and it doesn't seem to accept commands without them going through a terminal
10:10:33 <boxscape> ok
10:10:51 <lyxia> eelster: I mean start with "import Prelude ()" and progressively add whatever you need.
10:11:18 <eelster> Ahh
10:11:35 <ReinH> Be aware that that still imports all of the instances
10:11:44 <glguy> hiding Prelude and then reusing those names in an unqualified way leads to confusing code to read later
10:48:29 <eelster> Why can't I do an eta reduction on this: toSortedAlphabet a = sort $ nub $ filter isLower $ map toLower a 
10:48:46 <glguy> eelster: First rewrite that expression without $
10:48:55 <glguy> to help make it more clear to you why you can't
10:49:51 <eelster> Well it won't work as sort(nub(filter isLower (map toLower a)))
10:50:02 <glguy> How come?
10:50:11 <eelster> I mean it would work but you can't do an eta reduction there.
10:50:25 <eelster> But i guess that using the $ doesn't allow for an eta reduction either.
10:50:27 <glguy> Yes, that's right
10:51:59 <glguy> If we leave the $ in we find:    toSortedAlphabet a = sort $ (nub $ ((filter isLower) $ ((map toLower) a)))
10:52:19 <glguy> doesn't fit the required pattern for eta-reduction, either
10:54:17 <eelster> But I can do: toSortedAlphabet = sort . nub . filter isLower . map toLower
10:54:31 <glguy> Yes
10:54:49 <eelster> Thank you
11:05:29 * hackagebot saltine 0.0.0.6 – Cryptography that's easy to digest (NaCl/libsodium bindings). – https://hackage.haskell.org/package/saltine
11:10:34 <byorgey> so many puns in that package description =D
11:11:11 <wz1000> > id (\_ -> callStack) 1
11:11:13 <lambdabot>  error: Variable not in scope: callStack
11:18:13 <fresheyeball> this lambda is ugly
11:18:18 <fresheyeball> (k,v) -> fmap (k,) <$> applyMember v
11:18:19 <monochrom> byorgey: But why is there only a Sodium library but no Chloride library to pair with it? :)
11:18:28 <fresheyeball> how can I make it less ugly?
11:21:50 <byorgey> monochrom: clearly someone needs to write it!
11:22:48 <byorgey> fresheyeball: that looks nice enough to me.  One good way to make it less ugly is to adjust your idea of ugliness.
11:23:12 <byorgey> otherwise you will have to say what it is about it that looks ugly to you.
11:24:08 <cement_> I don't know what applyMember does, but I also think it looks fine
11:25:03 <wz1000> (fmap . fmap) (k,) $ applyMember v
11:25:29 <danilo2> Hi! Would anybody agree to help me debug GHC Core? I've got 2 codes. One of them has slightly more complex core, but runs 10x faster and I cannot figure out why
11:27:21 <glguy> I think it might be: fmap sequence . traverse applyMember
11:28:37 <glguy> at least from looking at it in chat, hard to test
11:29:16 <fresheyeball> glguy: nailed it
11:29:19 <shapr> byorgey: is there something like code.world or ipython for diagrams?
11:30:39 <byorgey> shapr: there used to be, but it hasn't been maintained for a long time
11:30:57 <shapr> ah, too bad
11:31:06 <shapr> what's was the project ?
11:31:59 <byorgey> I forget.
11:32:18 <byorgey> there is also https://hackage.haskell.org/package/ihaskell-diagrams  but it looks like that hasn't been updated in a while
11:32:32 <byorgey> I don't know the status of the IHaskell project
11:32:42 <shapr> ah, too bad
11:32:55 <cocreature> danilo2: just posting the code in question is more likely to get you a good answer :)
11:33:21 <byorgey> oh, the latest commit to the IHaskell repo was 3 hours ago =)
11:33:40 <shapr> that sounds active
11:35:21 <byorgey> maybe the diagrams support still works.  the demo notebook at http://nbviewer.jupyter.org/github/gibiansky/IHaskell/blob/master/notebooks/IHaskell.ipynb  seems to indicate that it does.
11:35:25 <danilo2> cocreature: I was trying yesterday posting the code while asking for help :) Anyway, I've created very detialed descripton with code (it is a little longish because it defines strict Either and EitherT - just copy-paste from mtl): https://ghc.haskell.org/trac/ghc/ticket/14035
11:35:47 <shapr> byorgey: that's the kind of thing I wanted, thanks!
11:37:27 <danilo2> cocreature: however I'm now updating the description. The question is, why if I've got 2 fully evaluated, strict Bool's in the code and I do `b || b'` the code works fast, however if I just pass `b` as a result it works 10x slower. These bools are not used anywhere, they are just computed there
11:37:55 <byorgey> shapr: have fun, and let me know how it goes!
11:38:48 <shapr> byorgey: will do, thanks
11:41:31 <Cale> danilo2: I suspect -XStrict will generally destroy anyone's intuition regarding the performance of Haskell code, so the only way to answer your question will be to examine the intermediate output of the compiler carefully, and then figure out why it did whatever it was that it did.
11:42:34 <danilo2> Cale: why -XStrict would destroy the intuition? I just want this code to be "strict" and fully evaluated on each step. Using bang patterns everywhere would be better for any reason ? 
11:42:57 <Cale> Using bang patterns everywhere would also be really weird
11:43:01 <cocreature> danilo2: I can tell you one thing: ghc will only inline fully applied functions and when it considers a function to be fully applied depends on how it’s defined so that might explain why the two versions of evalStateT behave differently
11:43:15 <danilo2> Cale: I was inspecting the intermediate output (-ddump-simpl) and I see the differences, I understand them, but I do not understand why they were created
11:43:27 <cocreature> danilo2: try "evalStateT m = \a -> fmap fst $ runState m a" to make sure that’s the culprit
11:44:43 <cocreature> -fpedantic-holes might also be worth a try since ghc can sometimes float "seq" below lambdas without it
11:44:44 <danilo2> cocreature: I know it. This is a good point and in fact I was trying to use `evalStateT m = \a -> fmap fst $ runState m a` instead. In fact the problem with State appears to be exaclty this (I'm editing the bug now to include this observation as "non-bug"). However the bigger problem for me is the behavior with the bools
11:45:09 <danilo2> cocreature: by the way I completely dont understand why GHC cannot inline non-fully applied functions. Is there any reason for it ?
11:45:56 <cocreature> afaik the current behavior is chosen because it’s somewhat predictable
11:46:04 <danilo2> cocreature: another interesting thing is that if you look at the code, you will see that `evalStateT` is used in ONE NON-recursive place, so I dont get why non-inlining it makes the performance difference of 10x 
11:46:05 <cocreature> if you add more heuristics things get even more confusing
11:46:22 <monochrom> To a large extent, there is nothing to inline about unsaturated functions.
11:47:12 <cocreature> monochrom: well for the functions where rewriting them such that ghc considers their applications to be saturated results in performance improvements there obviously is something to inline :)
11:47:39 <monochrom> That falls under the small-extent cases.
11:47:47 <Cale> The question is: how do you discover this?
11:48:00 <danilo2> cocreature, Cale : hereis a shortned version of the code (I'm updating ghc ticket too) : http://lpaste.net/357240
11:48:29 <lyxia> byorgey: Hey, someone asked me whether the generic-random docs could link to your blogpost, I guess that would be fine, but since then I changed the names a bit (genericArbitraryFrequency was a bit unwieldly). Would you mind updating your blogpost for that?
11:48:38 <danilo2> cocreature, Cale : I do not understand why if you change the line 119 from "(b ||| b')" to "(b)" it slows down
11:48:57 <danilo2> both b and b' have to be evaluated there and are strict, so this behavior is contr-intuitive
12:01:00 <cocreature> danilo2: I can’t reproduce your behavior. if I change “return $! T (b ||| b') a'” to “return $! T b a'”, the runtime in the criterion benchmarks drops from 270ms to 13ms
12:04:37 <danilo2> cocreature: hmm,very interesting. If I could ask you, let's give it another shot. 
12:04:52 <danilo2> cocreature: here is yet a little shorter code and the last line provides ghc compilation options: http://lpaste.net/357241
12:05:13 <danilo2> cocreature: My results are (b||b') : 1ms, (b'): 1ms, (b): 13ms 
12:06:19 <cocreature> danilo2: btw you are missing 4 extensions to make this self contained
12:06:56 <danilo2> cocreature: I'm sory about it! I always forgot I'm enabling some extensions in project description file. I'll fix it
12:07:54 <danilo2> cocreature: do you get similar results with the provided flags?
12:08:45 <cocreature> with your flags I get results similar to yours
12:10:26 <danilo2> cocreature: ok, your original results could be caused too weak optimization flags. in fact using only -O2 shoudl give something very similar. The rest of the flags are overkill if we put INLINE everywhere
12:10:41 <cocreature> no, my results where with -O2
12:11:00 <dolio> Maybe your optimization flags aren't actually optimization flags.
12:11:22 <hololeap> looking for some seasoned advise: can extensible-effects completely replace monad transformers, or are MTs more fitting for certain applications?
12:11:39 <danilo2> dolio: "-threaded -funbox-strict-fields -O2 -funfolding-use-threshold=10000 -fexpose-all-unfoldings -fsimpl-tick-factor=1000 -flate-dmd-anal -fspecialise-aggressively
12:12:07 <cocreature> -funfolding-use-threshold is the one that makes a difference here
12:12:11 <danilo2> cocreature: hmm, I'll find out which flag does it
12:12:17 <danilo2> cocreature: oh, thanks for checking it out
12:12:28 <cocreature> the rest doesn’t make any signifcant difference
12:14:57 <danilo2> cocreature: thats super interesting why it gives such a performance boost here
12:15:11 <cocreature> I wonder if you are actually measuring what you think you are measuring
12:16:52 <danilo2> cocreature: this example was bigger and it was really parsing input text, so when I was getting results I got the same times, anyway, I'll expand it a little to be sure it measures what I think it does
12:17:37 <lyxia> hololeap: https://ro-che.info/articles/extensible-effects
12:18:15 <lyxia> hololeap: there are a bunch of related discussions on reddit too
12:20:17 <hololeap> thanks, lyxia 
12:20:21 * hackagebot saltine 0.0.1.0 – Cryptography that's easy to digest (NaCl/libsodium bindings). – https://hackage.haskell.org/package/saltine
12:25:40 <danilo2> cocreature: I've got even shorter code (removed some unused instances, like Applicative for Either) and the parser really parses 'a' characters, so it does what I think it does. Resutls are the same
12:25:42 <danilo2> cocreature: http://lpaste.net/357242
12:26:06 <danilo2> cocreature: using (b ||| b') is much faster than passing b as the output
12:28:32 <Xnuk> @hoogle Content
12:28:33 <lambdabot> Text.XML.Light.Types data Content
12:28:33 <lambdabot> Text.XML.HXT.DOM.TypeDefs CONTENT :: DTDElem
12:28:33 <lambdabot> Text.Blaze.Internal Content :: ChoiceString -> a -> MarkupM a
12:28:40 <Xnuk> @hoogle Clay Content
12:28:40 <lambdabot> No results found
12:29:32 <Xnuk> @hoogle content
12:29:32 <lambdabot> Text.Blaze.Html4.FrameSet.Attributes content :: AttributeValue -> Attribute
12:29:33 <lambdabot> Text.Blaze.Html4.Strict.Attributes content :: AttributeValue -> Attribute
12:29:33 <lambdabot> Text.Blaze.Html4.Transitional.Attributes content :: AttributeValue -> Attribute
12:29:39 <Xnuk> @hoogle Clay.Content
12:29:39 <lambdabot> Clay.Text data Content
12:29:40 <lambdabot> Clay.Attributes content :: Refinement
12:29:40 <lambdabot> Clay.Text content :: Content -> Css
12:29:50 <lyxia> Xnuk: did you know you can /query lambdabot
12:30:10 <Xnuk> oh sry
12:30:27 <lyxia> np
12:30:28 <Xnuk> \\\\
12:32:56 <Unicorn_Princess> how do you recommend learning reactive-banana? I found nice explanations on what events and behaviours are and how they work, but haven't had much luck with stuff like newAddHandler and setupNetwork. going through https://wiki.haskell.org/Reactive-banana/Examples atm, but they could be nicer
12:34:53 <vagrant-> hello friends
12:35:07 <shapr> hello vagrant- 
12:35:12 <vagrant-> does anyone know a good tutorial of how to use Julius outside of the Yesod framework?
12:35:25 <shapr> not I
12:35:35 <vagrant-> There's a whole lot of machinery around its monads that I don't really understand, or want to... I just want a good JS quasiquoter basically
12:35:55 <vagrant-> shapr: thanks, and hello :)
12:39:33 * hackagebot hslua 0.6.0 – A Lua language interpreter embedding in Haskell – https://hackage.haskell.org/package/hslua
12:40:14 <zomg> vagrant-: iirc you just use jsFile in TH expressions
12:40:21 <zomg> for example
12:41:06 <vagrant-> zomg: when I do `:t [julius|function () {}|]` it gives me back type `JavascriptUrl url`
12:41:18 <vagrant-> I don't know why it's not just type `Javascript`
12:45:35 <wz1000> with -XMultiParameterTypeClasses, ghc allows type classes with zero parameters. Is there any way to use these?
12:46:38 <wz1000> because supplying an instance makes them resolve everywhere.
12:47:41 <lyxia> I can't imagine a use case for these
12:49:44 <MarcelineVQ> https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Stack.html#t:CallStack is the only use I recall seeing
12:50:58 <wz1000> MarcelineVQ: but that is not a type class. I'm talking about class Something where
12:50:58 <geekosaur> I thought that was a type alias
12:50:59 <MarcelineVQ> woops I'm an idiooot, nvm me
12:51:09 <wz1000> not constraints
12:51:10 <geekosaur> for an implicit parameter constraint
12:59:11 <dolio> HasCallStack is the alias.
12:59:25 <dolio> CallStack is the type of the implicit parameter, I think.
13:43:41 <brisbin> does something like insertWithM :: (a -> a -> m a) -> k -> a -> Map k a -> m (Map k a) exit? (i did hoogle that sig before asking here)
13:43:51 <brisbin> exist*
13:47:45 <lyxia> I don't think so. You can implement it with alterF.
13:48:04 <hexagoxel> (presuming Functor m)
13:48:21 <brisbin> oh sorry, Monad m in my case. didn't realize i omitted that
13:48:34 <brisbin> but thanks, i doubt i'd've found alterF on my own
13:49:04 <glguy> That was added in 0.5.8, so depending on which containers version you're using it you might not have it
13:49:56 <lyxia> oh, lts-9.0 STILL doesn't have it
13:50:40 <glguy> It comes with GHC 8.2 now, but it didn't come with the containers bundled with GHC 8.0
13:50:42 <cocreature> lyxia: stackage can’t upgrade containers because ghc depends on containers
13:50:58 <lyxia> oh I see.
13:51:07 <lyxia> I always forget that
13:51:32 <glguy> (\f k v -> at k (fmap Just . maybe (pure v) (f v))) :: (Ord k, Applicative f) => (a -> a -> f a) -> k -> a -> Map k a -> f (Map k a)
13:51:38 <glguy> something like that, at least
13:53:10 <lyxia> is there no containers-compat to provide the same interface for those stuck with GHC <= 8.0?
13:54:04 <glguy> not that I know of
13:54:13 <glguy> better just to not tie yourself down
13:55:05 <lyxia> ah, the internals of containers < 0.5.8 are not exposed...
13:55:42 <cocreature> lyxia: being stuck with GHC <= 8.0 is not necessarily a problem. you can still upgrade containers as long as you don’t depend on the ghc package
13:57:31 <cocreature> but since the whole idea of stackage is to have one consistent snapshot and that obviously includes ghc, it’s never upgraded there
13:59:02 <Guest43> Sometimes I've wanted a function
13:59:10 <Guest43> Shoot wait
13:59:10 <glguy> I know how you feel
13:59:13 <Guest43> lol
14:00:05 <Guest43> Sometimes I've wanted a function :: Monad m => (a -> m (Maybe b)) -> Maybe a -> m (Maybe b)
14:00:17 <Guest43> This can be written a bit more generally as
14:00:28 <Guest43> @type \f -> fmap join . traverse f
14:00:30 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a)) -> m a1 -> f (m a)
14:00:56 <srpx> If one reduces a λ-term using string-based variables, but making sure *all* variables have different name, is it still possible to have name capture or is it ok?
14:01:16 <Guest43> Which seems to indicate that the important property is that Maybe is both Traversable and a Monad 
14:01:28 <monochrom> srpx: It is OK.
14:01:55 <Guest43> So my questions: Is this a useful pattern? And is there any theory and/or application for Traversable Monads? 
14:02:24 <srpx> monochrom: thanks!
14:02:47 <lyxia> srpx: say you have a term t where x occurs twice or more. t[λy.y/x] now has y being bound twice
14:02:51 <monochrom> It seems to be this is just flip fmap
14:03:26 <monochrom> Err no nevermind.
14:03:30 <glguy> flip fmap would leave you with a :    m (f (m a))
14:04:42 <Guest43> Examples of traversable monads: Maybe, [], Identity, (a,), Logic
14:04:46 <srpx> lyxia: hmm fair point, so it is not sufficient to make sure all initial variables have different names.
14:05:18 <monochrom> Oh you just re-uniquize after substitution :)
14:05:39 <Guest43> Traversable only: Either a, ZipList
14:06:24 <Guest43> Monad only: IO, (r ->), State s
14:07:52 <Tuplanolla> I don't see why switching between two isomorphic label types should change anything here, srpx.
14:08:50 <monochrom> Which two isomorphic label types?
14:09:39 <Tuplanolla> Strings or indices, I presume, monochrom.
14:10:16 <monochrom> String and de Bruijn indexing are not isomorphic.
14:10:44 <monochrom> In fact I don't even think "ismorphism" is well-defined for this.
14:11:34 <dmwit_> Guest43: Relevant SO writing: https://stackoverflow.com/q/42284879/791604 https://stackoverflow.com/q/7040844/791604
14:11:48 <Tuplanolla> Well, that would explain why I didn't see it, monochrom.
14:14:18 <dmwit> Guest43: But really you probably just want to use `MaybeT`.
14:15:41 <dmwit> :t \f x -> MaybeT (pure x) >>= f
14:15:43 <lambdabot> error:
14:15:43 <lambdabot>     • Data constructor not in scope: MaybeT :: f0 a -> m a1
14:15:43 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
14:16:07 <Tuplanolla> Hey, dmwit. Remember the `wrap` discussion we had two months ago?
14:16:31 <chokboy> Hello, is there any way to get type level tuples and be able to unpack them in the LHS of a type family? Every time I've tried, I end up with an error saying that my tuple kind actually has kind * when i define it as "data Pair a b" using DataKinds.
14:16:55 <phadej> chokboy: '(a, b)
14:16:59 <phadej> do you have the prime?
14:17:09 <phadej> @kind (Int, Chr)
14:17:10 <lambdabot> error:
14:17:10 <lambdabot>     • Expecting one more argument to ‘'Chr’
14:17:11 <lambdabot>       Expected a type, but ‘'Chr’ has kind ‘Char -> TextDetails’
14:17:13 <phadej> @kind (Int, Char)
14:17:14 <lambdabot> *
14:17:19 <phadej> @kind '(1, 2)
14:17:21 <lambdabot> (GHC.Types.Nat, GHC.Types.Nat)
14:17:51 <chokboy> OH! Thank you so much. so '(,) is the "kind constructor" for the tuple kind?
14:17:58 <chokboy> or type constructor, actually
14:18:11 <phadej> kind constructor
14:18:17 <phadej> ah, depends
14:18:22 <phadej> it's so overloaded
14:18:29 <phadej> a bit like
14:18:33 <phadej> @kind []
14:18:34 <lambdabot> * -> *
14:18:38 <phadej> @kind '[]
14:18:39 <lambdabot> [k]
14:18:44 <monochrom> Yeah, there are four []s
14:19:04 <chokboy> it seems that I can just use the plain (,) when specifying the kinds of the arguments to a type family.
14:19:04 <monochrom> Fantastic Four []
14:19:25 * geekosaur was contemplating a Picard joke...
14:22:04 <dolio> data Picard a = MakeItSo a | BelayThat
14:22:07 <dolio> That's an old one.
14:23:09 <monochrom> I thought BelayThat would be Jack Sparrow and Barbossa.
14:23:49 <dolio> This predates those movies.
14:24:02 <Tuplanolla> This is the first unpolished version that ended up working for all inputs, dmwit: http://lpaste.net/357245
14:26:13 <Tuplanolla> The acrobatics with `m` and `c` are required to avoid cases like `abs (-128 :: Int8)`.
14:26:33 <danilo2> Hello! I'm trying to understand weird performance results Im getting. A short description and the code is here: https://ghc.haskell.org/trac/ghc/ticket/14035 . If anyone could help me with it, I would be really thankful!
14:27:47 <Tuplanolla> It doesn't look constant-time, but actually the recursion at the end only ever goes two levels deep at most.
14:32:54 <dmwit> Tuplanolla: What's this?
14:34:36 <Tuplanolla> The binding `y = wrap a b x` defines such `y` that `a <= y < b` by shifting `x` by the appropriate number of multiples of `b - a`. If `b <= a`, the behavior is undefined. Overflows should be impossible regardless of the type.
14:39:31 <dmwit> Tuplanolla: Geez. I'd be tempted to write ```wrapInteger a b x = a + ((x-a) `mod` (b-a)); wrap a b x = fromInteger (wrapInteger (toInteger a) (toInteger b) (toInteger x))``` and be done with it.
14:39:50 <dmwit> Seems a hell of a lot more readable and maintainable.
14:39:55 <Tuplanolla> That certainly works, but this really started to bother me once I got it wrong so many times.
14:40:21 <Tuplanolla> Besides, Haskell is not the only language I use this with.
14:44:37 <dmwit> TIL about NegativeLiterals
14:45:07 <dmwit> It is sort of funny that `-128 :: Int8` works without it.
14:46:07 * hackagebot stratosphere 0.7.1 – EDSL for AWS CloudFormation – https://hackage.haskell.org/package/stratosphere
14:46:07 * hackagebot neural 0.3.0.1 – Neural Networks in native Haskell – https://hackage.haskell.org/package/neural
14:47:45 <phadej> > negate (-128 :: Int8)
14:47:47 <lambdabot>  -128
14:48:07 <phadej> -x == x => x == 0 ? :)
14:48:10 <dmwit> > negate (128 :: Int8) -- more importantly
14:48:12 <lambdabot>  -128
14:48:27 <dmwit> > 128 :: Int8
14:48:29 <lambdabot>  -128
14:48:35 <dmwit> All roads lead to MIN_INT
14:49:35 <Tuplanolla> I'll write a word or two about this function once I get my blog done.
14:49:46 <Tuplanolla> It was quite an adventure!
14:49:55 <dmwit> I look forward to it. =)
14:50:07 <dmwit> Don't forget to start the post with "here's why we want this function"...
14:50:38 <phadej> I remember a lecture about https://en.wikipedia.org/wiki/Two%27s_complement in uni
14:51:08 <phadej> I was, "damn, that's clever"
14:51:24 <dmwit> Yeah, it really is!
14:51:45 <Tuplanolla> I was considering the title Everything Is Difficult.
14:55:02 <Tuplanolla> Not a single week goes by without coming across something related to an open problem in a thing I took for granted.
15:01:06 * hackagebot arrowp-qq 0.1.1 – quasiquoter translating arrow notation into Haskell 98 – https://hackage.haskell.org/package/arrowp-qq
15:08:11 * hackagebot ansigraph 0.3.0.3 – Terminal-based graphing via ANSI and Unicode – https://hackage.haskell.org/package/ansigraph
15:25:40 <SepakoRayl> is anyone familiar with the llvm-hs bindings?
15:26:19 <SepakoRayl> or rather, is anyone aware of whether I need to implement lambda lifting?
15:26:42 <SepakoRayl> I am not sure if correct naming suffices
15:41:49 * hackagebot pinboard 0.9.12.5 – Access to the Pinboard API – https://hackage.haskell.org/package/pinboard
16:14:58 * hackagebot test-fixture 0.5.0.2 – Test monadic side-effects – https://hackage.haskell.org/package/test-fixture
16:33:30 <trigone> hi, i wanted to know if a type synonym for (a -> m b) has been defined somewhere.
16:33:54 <jle`> there's a few newtype wrappers for it
16:33:57 <jle`> here and there
16:34:01 <jle`> one in base, and another in transformers
16:34:06 <jle`> but i don't think there's a type synonym
16:34:29 <jle`> there's another newtype wrapper for it in profunctors
16:35:34 <jle`> hmmmmm
16:36:02 <trigone> jle`: i see... why's it called Star?
16:36:08 <nshepperd_> Kliesli?
16:36:34 <trigone> nshepperd_: Kleisli means star?
16:36:59 <jle`> the name probably comes from category theory
16:37:05 <trigone> is there a search motor for newtypes/types/data?
16:37:14 <trigone> i mean a browser
16:38:07 <jle`> anyway the three newtype wrappers i was thinking of were Kleisli, ReaderT, and Star
16:39:01 <trigone> jle`: where's Kleisli defined?
16:39:08 <jle`> Control.Category i believe
16:39:23 <jle`> oh huh i guess not
16:39:28 <jle`> must be in Control.Arrow, in base
16:39:40 <Tuplanolla> @index Kleisli
16:39:40 <lambdabot> Control.Arrow
16:39:53 <Welkin> http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Arrow.html#t:Kleisli
16:39:54 <trigone> jle`: yeah i just found it. thanks :)
16:40:02 <jle`> ReaderT is in transformers (Control.Monad.Trans.Reader) and also re-exported in mtl (Control.Monad.Reader)
16:40:08 <monochrom> To be fair, Control.Category would be a better home. Because >>> makes sense already.
16:40:21 <jle`> Control.Category is the only sensible home
16:40:54 <monochrom> But historical reason. Control.Category was a split from Control.Arrow.
16:41:49 <monochrom> Pay me cdn$100 to finish the move :)
16:42:26 <skiddieproof_> Anyidea how difficult it is to add lambdabot to an IRC channel on freenode?
16:42:53 <jle`> shouldn't be that hard
16:42:54 <geekosaur> skiddieproof_, I think just pm int-e?
16:42:56 <trigone> monochrom: why's it cdn instead of cnd?
16:42:58 <jle`> just message int-e
16:43:05 <jle`> oh sorry for the double-ping
16:43:06 <trigone> monochrom: nevermind
16:43:14 <jle`> i've done it multiple times
16:43:25 <skiddieproof_> geekosaur : how do I do that?
16:43:34 <jle`>  /q <username> <message>
16:43:46 <jle`> or you can just ask in this channel too
16:48:37 <lex> Is there any way to implement an "in place" algorithms in a purely functional way?
17:00:50 <glguy> dfeuer: Which part of making a package were you asking about?
17:00:54 <skiddieproof_> so if I have lambdabot installed, is there an easyway to boot it up to an irc channel?
17:02:00 <EvanR> lex: yes, by using an IntMap in place of a heap
17:03:24 <EvanR> if the algorithm would really benefit from that style, you could make a monad DSL for it
17:03:53 <pie_> idk where to ask, is there anything on debugging lexers/parsers in general?
17:04:23 <pie_> (im using a python library called slimit for parsing javascript and its broken somewhere because it chokes on a token thats not there....)
17:08:54 <texasmynsted> I see this page -->  https://wiki.haskell.org/Books
17:09:35 <texasmynsted> I am looking for a Haskell book that I can read while reading "agile web development with Rails 5" to compare the experience.
17:10:01 <texasmynsted> To build a haskell based e-com type site ...
17:10:49 <texasmynsted> On that page I see "Alejandro Serrano Mena: Beginning Haskell".
17:11:13 <texasmynsted> could somebody recommend what book they would use given what I am trying to do?
17:13:08 <erisco> pie_, maybe try #python
17:13:56 <pie_> erisco, not much help :P
17:14:30 <erisco> well if you can figure out how to relate your question to Haskell you can ask it here
17:14:31 <pie_> but yea re: not really looking for somehting specific for this parser because its not gonna happen...more like how to approach fixing parsers
17:15:02 <pie_> haskell people are smart right? ;PP
17:15:07 <jle`> lex: yes, there are libraries that allow you to specify in-place algorithms in a pure way
17:15:11 <wvvwvwvwvw> is there a haskell lib which makes it easy to get the table layouts from a sql database?
17:15:20 <jle`> the algorithm itself is not exactly going to be 'functional', of course
17:16:15 <monochrom> piethon
17:16:40 <erisco> pie_, parsers work in a variety of ways. without knowing how this slimit works we can't give any particular advice... is it parser combinators?
17:17:16 <monochrom> Use a lot of print statements to debug. This can be done to anything.
17:17:29 <texasmynsted> no suggestions?
17:18:21 <erisco> texasmynsted, I do not know any Haskell books which focus on web development, though maybe Yesod has a book, dunno
17:18:45 <jle`> i'm not sure if you're going to get a good book that teaches haskell and web dev at the same time
17:20:09 <dmj`> texasmynsted: the original happstack guide was great
17:20:26 <dmj`> texasmynsted: http://www.happstack.com/docs/crashcourse/index.html
17:20:32 <dmj`> might assume a lot if you’re new though
17:21:38 <dmj`> texasmynsted: but yea, there’s a yesod book too
17:22:07 <pie_> monochrom, :P
17:23:01 <texasmynsted> I saw the yesod book.  The reviews on Amazon make it sound like it is not well organized 
17:23:05 <pie_> apparently ##parsers is a thing
17:24:03 <texasmynsted> as a stack yesod sounds very good.
17:25:03 <texasmynsted> I suppose I should find a web stack/platform and then go from there?
17:26:06 <erisco> you can learn any of the Haskell web frameworks, or whatever they're called nowadays, but unlikely they'll teach you Haskell at the same time
17:28:24 <texasmynsted> I have "haskell programming from first principles" for learning haskell.  http://haskellbook.com
17:28:39 <erisco> that's the new hotness so I hear
17:28:49 <texasmynsted> I just want to balance with something very practical.
17:29:01 <texasmynsted> what is the new hotness?
17:29:09 <boj> texasmynsted: that book
17:29:13 <texasmynsted> oh heh
17:29:18 <texasmynsted> yeah I have had it about a year.
17:29:59 <texasmynsted> I like it.  It has some rough spots also (like any book I suppose)
17:30:50 <erisco> you mean you fear learning what a Functor is but not being sure how to use it for anything?
17:31:02 <sm> texasmynsted: the yesod book is fine
17:31:44 <sm> and the closest to what you're asking for
17:32:48 <texasmynsted> ok
17:33:16 <texasmynsted> I was just going to say that is looks like the best match and perhaps I should buy it and make up my own mind heeh.
17:34:29 * texasmynsted shrug
17:34:31 <skiddieproof_> Does this mean anything to any one ? 'Lambda_Robots:_100%_Loyal', it is the last arg to the 'irc-connect' call in this config file https://github.com/lambdabot/lambdabot/blob/master/lambdabot/scripts/online.rc
17:34:47 <texasmynsted> from TOC it looks like what I am wanting.
17:34:50 <texasmynsted> thank you
17:38:32 <erisco> skiddieproof_, if you start loading up a channel with bots you risk the singularity, so that is a safeguard
17:38:54 <skiddieproof_> erisco : lol
17:39:34 <skiddieproof_> erisco : please don't tell Kurzweil on me
17:43:18 <dmwit> skiddieproof_: Try /whois lambdabot
17:43:22 <dmwit> You'll see it in there. =)
17:43:52 <dmwit> (Compare /whois dmwit, e.g.)
17:46:00 <dmwit> IRC has nicks (which uniquely identify a user on a given network at a given time) and names (which are basically arbitrary text associated with a nick). The last argument to irc-connect is the name to use.
17:47:00 <`Guest00000> which networking library lets me make tcp programs easiest?
17:48:42 <EvanR> the websockets lib is pretty easy
17:48:49 <EvanR> and is technically using tcp
17:50:22 <dmwit> jle`: I like your observation about the close relationship between ReaderT and Kleisli. I had never noticed it before.
17:50:48 <`Guest00000> EvanR: will it let me use plain tcp?
17:51:30 <crucify_me> hi where do I put '\' symbols in this file to desugar the arguments? Just so I know what the textbook is suggesting.https://ptpb.pw/qYsc
17:51:46 <crucify_me> https://ptpb.pw/qYsc
17:52:18 <dmwit> Wow, the type Hoogle gives to `ReaderT` looks like a serious bug.
17:52:25 <crucify_me> I attempted to put them in the definitions so : \x \y 
17:52:33 <dmwit> ReaderT :: (r -> m a) -> ReaderT k r
17:52:45 <Axman6> crucify_me: subtractStuff = \x y -> x - y - 10
17:52:56 <Axman6> (or, \x -> \y -> ...)
17:53:21 <erisco> @hoogle ReaderT
17:53:21 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT k r
17:53:21 <lambdabot> Control.Monad.Trans.Reader newtype ReaderT r m a
17:53:22 <lambdabot> Control.Monad.Trans.Reader ReaderT :: (r -> m a) -> ReaderT r m a
17:54:40 <crucify_me> oh just one for all arguments , or is it that only the first argument is a function technically here , ie subtractStuff \x Axman6 
17:54:59 <EvanR> `Guest00000: no. if you want plain sockets, use Network.Socket and probably the async package to manage your threads
17:55:11 <erisco> the first one is from mtl, which afaik is old and nowadays people use transformers... but taking it a look, it seems to use polykinds and maybe Hoogle doesn't recognise that correctly
17:55:22 <dmwit> crucify_me: `\x y -> ...` is just syntax sugar for `\x -> \y -> ...`. The compiler treats the two identically.
17:56:11 <crucify_me> ok so that goes in the definition not the type declaration then. dmwit 
17:56:14 <Axman6> f x y = ... === f x = \y -> ... === f = \x -> \y -> ... === f = \x y -> ...   these are all the same
17:56:19 <dmwit> I still use mtl, and I really don't think I'm alone there.
17:56:58 <dmwit> Axman6: ...to a first approximation, anyway. There's some stupid oddities around the DMR.
17:57:12 <dmwit> crucify_me: Yes.
17:57:58 <crucify_me> thanks kindly dmwit Axman6 I'll check it out, the book mentions it in passing
17:58:43 <dmwit> (And I guess if the `...` contains a `where` clause there can be a pretty significant difference, too, even without the DMR.)
18:00:50 <erisco> and don't get too excited about it if you want to use other languages...
18:02:54 <crucify_me> Axman6, dmwit sorry could you paste the examples you have in mind, they won't work for me (not reading '...' properly I guess)
18:07:37 <jle`> dmwit: i remember thinking it was interesting too when i noticed it
18:07:55 <jle`> i think i realized it when i wondered why Kleisli has no Monad instance
18:08:07 <crucify_me> I mean, that is syntax that works, right?
18:08:37 <erisco> > let f x y = x + y; g = \x -> \y -> x + y in (f 1 2, g 1 2)
18:08:39 <lambdabot>  (3,3)
18:10:43 <crucify_me> erisco, oh the variables all go to the right?
18:10:54 <crucify_me> of the =
18:11:21 <erisco> I don't know what you mean... paste what you tried and we'll see what isn't working
18:12:58 <crucify_me> thanks
18:15:23 <crucify_me> erisco,  https://ptpb.pw/Di4_  I don't know I'm doing it in a file without a let statement
18:16:13 <erisco> subtractStuff = \x -> \y -> x - y - 10
18:16:48 <erisco> \x -> m  is an expression if m is an expression
18:17:23 <crucify_me> right ok so any expression requires assignment erisco 
18:17:54 <jle`> subtractStuff = \x -> (\y -> (x - y - 10))
18:18:17 <erisco> to the left of = you have a name followed by many patterns, and to the right of = you have an expression
18:18:30 <jle`> try expanding it out if you're confused, maybe
18:18:34 <jle`> (subtractStuff 5) 10
18:18:55 <jle`> is ((\x -> (\y -> x - y - 10)) 5) 10
18:19:02 <erisco> though you also have  let (x, y) = (1, 2)  so I dunno
18:19:04 <jle`> which is (\y -> 5 - y - 10) 10
18:19:13 <jle`> which is (5 - 10 - 10)
18:19:22 <jle`> which is -15
18:19:31 <erisco> as far as I can tell that kind of thing is rewritten to  let x = 1; y = 2
18:20:14 <crucify_me> thanks I'm working on it erisco jle` 
18:21:30 <erisco> I guess it could also be a case, i.e. case (1, 2) of (x, y) -> m
18:21:43 <erisco> not sure what the language report says on it
18:22:18 <crucify_me> erisco, when you said left of the equals I had name followed by many patterns, did you mean I had those incorrectly ?
18:22:39 <Axman6> that would be trivially turned into just m, since it's a case of a single constructor being immeditely evaluated, and the arguments are unused
18:22:51 <erisco> that is the grammar of a function clause, roughly speaking, crucify_me
18:23:10 <erisco> Axman6, m is an expression... I usually use m
18:23:14 <butterthebuddha> Hey peeps, I wanna "fold" over a list, each time filtering _some_ elements out while keeping others
18:23:22 <butterthebuddha> And I wanna do this over and over until the list has no elements left
18:23:27 <Axman6> case Foo x y of Foo a b -> m essentially (I can't remember what the name of the optimisation that would do that though)
18:23:52 <Axman6> butterthebuddha: how do you decide which elements to keep?
18:23:57 <Axman6> do you want it to be random?
18:24:02 <pacak> :t partition
18:24:03 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:24:04 <crucify_me> erisco, but the correct version only has the name to the left, so you meant my initial version was incorrect, right?
18:24:26 <butterthebuddha> Axman6: each element is a tuple
18:24:30 <jle`> butterthebuddha: it sounds kind of vague what you want
18:24:35 <butterthebuddha> the second element of the tuple is a counter
18:24:36 <erisco> crucify_me, that is not a way you can use a lambda, so yes it was incorrect
18:24:37 <jle`> if you really do repeat until there no elements left
18:24:43 <jle`> then your function is just myFunc _ = []
18:24:44 <butterthebuddha> I wanna decrement it on each pass - when the counter reches 0
18:24:56 <butterthebuddha> that's when I filter the element out
18:24:58 <crucify_me> thanks erisco jle`   pax
18:25:15 <jle`> if you want to filter the list repeatedly until it's empty, then it sounds like you just want 'const []' ...?
18:25:37 <jle`> what do you want to return?
18:25:39 <Axman6> iterate (map ((\x,y) -> (x,y-1)) . filter ((0==) . snd))
18:25:45 <Axman6> roughly
18:25:57 <butterthebuddha> I want to accumulate a string
18:25:59 <butterthebuddha> Based on the elements
18:26:08 <butterthebuddha> Well, I'm attempting problem 3 at https://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
18:26:10 <jle`> ok, this is a good step in making the problem less vague
18:26:16 <jle`> ok, that's probably the best step
18:26:19 <jle`> (giving the actual problem)
18:26:54 <erisco> according to Chrome I have already downloaded this file... you are in the same class as someone else who asked about that yesterday
18:27:03 <butterthebuddha> I've managed to morph the input list into tuples of element + num of times it appears in the list
18:27:11 <jle`> nice
18:27:13 <erisco> did your prof suggest #haskell?
18:27:32 <butterthebuddha> erisco: it's hw from the spring 13 version of cis194
18:27:40 <butterthebuddha> Not actually taking that class :)
18:27:43 <jle`> butterthebuddha: can you get it into a list of number of occurrences?
18:28:08 <butterthebuddha> jl': sure
18:28:10 <jle`> hm, i suppose you don't have to
18:28:42 <jle`> but one easy way would probably be to just make a list of the appropriate number of stars for each slot, and then transpose it
18:28:43 <pacak> :t transpose . map (\x -> take 10 $ replicate '*' x ++ repeat "*") . map length . group . sort
18:28:45 <lambdabot> error:
18:28:45 <lambdabot>     • Couldn't match expected type ‘Int’ with actual type ‘Char’
18:28:45 <lambdabot>     • In the first argument of ‘replicate’, namely ‘'*'’
18:29:03 <jle`> > transpose ["****","**","***","","****","*"]
18:29:05 <lambdabot>  ["*****","****","***","**"]
18:29:08 <pacak> :t transpose . map (\x -> take 10 $ replicate '*' x ++ repeat '*') . map length . group . sort
18:29:09 <lambdabot> error:
18:29:09 <lambdabot>     • Couldn't match expected type ‘Int’ with actual type ‘Char’
18:29:09 <lambdabot>     • In the first argument of ‘replicate’, namely ‘'*'’
18:29:14 <jle`> hm
18:29:18 <pacak> Hmmm
18:29:36 <erisco> well I think we could all come up with interesting ways to do this... better is to ask how butterthebuddha intends to solve the problem
18:29:38 <pacak> Something like that
18:29:51 <erisco> because removing elements from a list until none are left is not exactly what came to my mind
18:29:55 <butterthebuddha> Yeah I'd rather you guys not straight up give me the answer :P
18:30:06 <pacak> it's not because it's not working.
18:30:39 <jle`> butterthebuddha: you can use 'iterate' to do what you wanted originally
18:30:40 <Axman6> yeah what has happened to this channel? We used to be fantastic at helping people find ansswers when they're clearly trying to learn. the4 last few days have been really disappointing
18:30:45 <pacak> Let's use rubber duck debugging. Explain your solution in plain English. On every step explain why you think it's a best approach.
18:31:30 <butterthebuddha> I don't know if it's the best approach, but it's the first thing that came to my mind
18:31:41 <erisco> but I am not a rubber duck, just for the record
18:32:04 <jle`> butterthebuddha: your original plan might work...you can start implementing it by just using explicit recursion
18:32:05 <butterthebuddha> But for every pass through the list, I'd add a star to the string at the appropriate location
18:32:26 <butterthebuddha> And then build it up
18:32:47 <erisco> yeah that works, but why not just digest the list one number at a time?
18:32:47 <jle`> passThroughList :: [(Int, Int)] -> ([String], [(Int, Int)])
18:33:03 <butterthebuddha> erisco: Because that would make the string supe rweird
18:33:09 <butterthebuddha> I'd have a bunch of new lines and stuff
18:33:10 <jle`> or if you can get it into a positional list, [Int] -> ([String], [Int]) kind of does what you originally wanted
18:33:26 <erisco> butterthebuddha, well it is supposed to have new lines, isn't it?
18:34:01 <butterthebuddha> Yep, but I want to build them one by one
18:34:23 <butterthebuddha> If I have *           \n *                \n *                   \n stuff.
18:34:33 <butterthebuddha> It's gonna be hard to get a star into the second position of the third line
18:34:38 <pacak> :t intercalate
18:34:40 <lambdabot> [a] -> [[a]] -> [a]
18:34:44 <pacak> :t intersperse
18:34:45 <lambdabot> a -> [a] -> [a]
18:35:14 <jle`> butterthebuddha: i think the approach you were thinking of was to "emit" a new line, every time you pass through the list, and then update the list
18:35:18 <pacak> > intersperse "\n" ["hello", "world"]
18:35:20 <lambdabot>  ["hello","\n","world"]
18:35:31 <pacak> > intercalate "\n" ["hello", "world"]
18:35:33 <lambdabot>  "hello\nworld"
18:36:33 * hackagebot turtle 1.4.1 – Shell programming, Haskell-style – https://hackage.haskell.org/package/turtle
18:36:33 * hackagebot turtle 1.4.0 – Shell programming, Haskell-style – https://hackage.haskell.org/package/turtle
18:36:34 <jle`> butterthebuddha: so if you want to follow your original approach, write a function that takes a list and returns a line of your output histogram, and also returns the updated list.  then you can call it repeatedly using recursion
18:36:59 <jle`> (this recursion pattern is captured as a higher-order function, mapAccumL, but you can also just write it using explicit recursion to to plan it out)
18:37:07 <skiddieproof_> Anyone know what 'tag' references when connecting to an irc channel? the command is irc-connect : tag host portnum nickname userinfo
18:37:27 <Axman6> just a name for the server
18:37:39 <Axman6> like freenode instead of having to use irc.freenode.net
18:39:50 <skiddieproof_> Axman6 : what gets me is, this command 'irc-connect' dosen't have an arg for the channel
18:40:48 <erisco> butterthebuddha, it does seem awkward, yes, so I'll tell you what comes to my mind instead... forget the string :)
18:40:55 <Axman6> connect usually means connect to a server, join lets you join a channel on that server
18:41:08 <jle`> skiddieproof_: http://blog.initprogram.com/2010/10/14/a-quick-basic-primer-on-the-irc-protocol/
18:41:19 <skiddieproof_> thanks
18:41:20 <erisco> butterthebuddha, the first problem in my mind is to count how many of each number there are, and after we have that information we can figure out the histogram
18:42:06 <erisco> butterthebuddha, if you write any sort of visual application it is standard to separate an internal representation from the visual representation
18:42:28 <erisco> you want something convenient to work with in code and something else that is convenient to look at
18:43:17 <butterthebuddha> erisco: something like [(a, Int)]?
18:43:57 <erisco> look good to me, and if you want to show off you can use Map a Int, and if you want to go underground you can use IntMap Int
18:44:28 <erisco> or maybe it is a -> Int... you'd have to ask EvanR
18:44:47 <jle`> if your data is digits 0-9, it might make sense to just use a positional list
18:44:49 <jle`> an [Int]
18:45:10 <jle`> generating each line is super easy
18:45:21 <jle`> it's just a map :)
18:45:56 <jle`> [1,4,2,6,1,4,2,0,8,2] <- means 1 zero, 4 ones, 2 twos, 6 three's, etc.
18:46:21 <jle`> and to generate the "bottom line" of that, you just need to map over it and put a * on slots that aren't 0, and a space on slots that are
18:46:46 <erisco> that is one way... I have a different idea for that
19:00:53 * hackagebot pipes-group 1.0.7 – Group streams into substreams – https://hackage.haskell.org/package/pipes-group
19:07:13 <joe9> need some help, please? I want to check without blocking if the handle has more data available. program http://dpaste.com/0AWT3QW , test: http://bpaste.net/show/605b989b01e9
19:07:26 <erisco> butterthebuddha, did you figure out how to count the numbers?
19:12:23 <glguy> joe9: how about hReady :: Handle -> IO Bool ?
19:12:53 <joe9> glguy: That is what I tried initially. but, it tries to decode the byte and I am reading binary data too.
19:13:10 <joe9> glguy: hReady is a wrapper on hWaitForInput
19:13:45 <joe9> glguy: I tried to understand the code but got lost at this line   wantReadableHandle_ "hWaitForInput" h $ \ handle_@Handle__{..} -> do
19:13:46 <glguy> joe9: Where did you see that it tries to decode anything?
19:14:14 <joe9> glguy: it does. also, the docs say this: --  * a decoding error, if the input begins with an invalid byte sequence
19:14:14 <joe9> --    in this Handle's encoding.
19:14:53 <glguy> joe9: That wouldn't matter, you're using a binary encoding on the handle, so there won't be errors
19:15:57 <joe9> glguy: I did not set the binary encoding explicitly. Can I set such a setting?
19:16:22 <glguy> joe9: open the file with openBinaryFile
19:16:28 <glguy> or use hSetEncoding on the handle
19:16:37 <joe9> glguy: Thanks a lot.
19:17:00 <glguy> hSetBinaryMode :: Handle -> Bool -> IO ()
19:18:44 <joe9> glguy: got it.
19:19:10 <joe9> glguy: That worked like a charm. Thanks so much.
19:37:53 <mark__> Can someone help me understand the difference between ($) and (.) better?   The following works: checkIfSubstringInLs str ls = elem True $ map (isInfixOf str) ls
19:38:20 <mark__> but I expected it to work as checkIfSubstring str ls = elem True . map (isInfixOf str) ls
19:39:32 <erisco> mark__, one thing to do is look at their types, and another is to understand infix operator precedence and associativity
19:40:02 <erisco> :t ($)
19:40:03 <lambdabot> (a -> b) -> a -> b
19:40:05 <erisco> :t (.)
19:40:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:40:11 <erisco> do you understand those types?
19:40:29 <mark__> yeah, 1 function and input vs 2 functions and input
19:42:12 <erisco> so in both your examples, rewrite them so they use ($) and (.) rather than the infix notation
19:42:48 <geekosaur> you can also see those as (a -> b) -> (a -> b) and (b -> c) -> (a -> b) -> (a -> c)
19:45:03 <parsnip> can write mark__ you might like to replace `f $ g x` with `f . g $ x`, last time i wrote haskell, i found it to be the nicest aesthetically. 
19:46:58 <mark__> ok, writing it out with (.) and ($) helps.  So the issue is that map (isInfixOf str) ls is a [Bool], and not String -> [Bool].
19:47:29 <EvanR> f $ g x, yuck, f . g $ x, yuck, f (g x) :thumbsup:
19:47:31 <jle`> mark__: for what it's worth, you're not alone in your confusion
19:47:34 <mark__> parsnip, I think that's the issue I tend to have.  I too prefer f . g $ x, but I think sometimes I accidentally write f . g x and then get confused until I try f $ g x
19:47:40 <jle`> it's one of the top rated haskell stack overflow questions
19:47:42 <jle`> https://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
19:47:45 <EvanR> or (f . g) x if theres a change you might want to add more processor functions
19:48:00 <EvanR> or let h = f . g . ... in h x
19:48:26 <mark__> is there any significant difference in let/where bindings? I always find myself using where for some reason
19:48:36 <parsnip> mark__: for example, f $ g $ h x vs f . g $ h x vs f . g . h $ x
19:48:40 <EvanR> its only a syntactic difference
19:48:46 <EvanR> where desugars to let
19:48:47 <parsnip> i like the last
19:48:58 <erisco> or  case f . g . ... of h -> h x
19:49:01 <EvanR> where is pretty awesome
19:49:15 <mark__> ok, thanks!
19:49:57 <jle`> mark__: they're basically different syntactical structures
19:50:09 <jle`> where is used in declaration syntax
19:50:21 <jle`> let is used in expression syntax (or also in do blocks, in an unrelated way)
19:50:35 <jle`> mark__: to declare something, you can say `foo = ... where ...`
19:50:45 <jle`> mark__: basically you can attach where to any = definition
19:51:09 <jle`> let is used for expressions, not declarations.  'let foo = ... in ...' is an expression (not a declaration)
19:51:20 <erisco> > let x = y where y = 3 in x
19:51:22 <lambdabot>  3
19:51:43 <jle`> so anywhere you'd use any ol' expression (like True, 3 + 5, head [1,2,3]), you can use (let ... in ...)
19:51:56 <mark__> ok, cool
19:52:17 <EvanR> from the concrete syntax its hard to tell where 'where' is attaching
19:52:28 <erisco> > let x = x where x = 3 in x
19:52:30 <lambdabot>  3
19:53:00 <mark__> is one considered more idiomatic/better practice?
19:53:07 <jle`> well, they aren't interchangeable
19:53:18 <jle`> one is used when you want to give an expression
19:53:23 <jle`> and one is used to help with your declarations
19:53:42 <EvanR> i find myself doing let x = e1 in let y = e2 in let z = e3 in ... when it feels like a sequential thing
19:53:48 <mark__> are there situations where you can use where that you can't use let in though?
19:53:52 <EvanR> note you have to put extra lets
19:53:54 <erisco> but often you could choose between a let/in or a where, and the cool kids use where nowadays
19:54:06 <EvanR> im not cool? :(
19:54:25 <EvanR> mark__: no because where desugars to let
19:54:30 <erisco> maybe at the alumni club
19:54:31 <EvanR> so that would not make sense
19:54:57 <mark__> ok cool, that's what I thought.
19:55:20 <EvanR> > let xs = 0:ys; ys = 1:xs in xs
19:55:22 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
19:55:32 <EvanR> yinyang
19:56:38 <EvanR> > xs where xs = 0:ys; ys = 1:xs
19:56:40 <lambdabot>  <hint>:1:4: error: parse error on input ‘where’
19:56:46 <EvanR> heh
19:57:04 <EvanR> where does not attach to expressions :(
19:57:15 <EvanR> only declarations
19:57:35 <jle`> yeah, where is actually a "part" of declaration syntax
19:57:40 <jle`> like =
19:59:59 <erisco> EvanR, it is because let/in is the boring instructor that leads with all the definitions before you actually get to do anything
20:00:18 <erisco> EvanR, the where instructor, on the other hand, gets right to the good stuff and tells you how it works later
20:00:20 <jle`> declaration syntax is <name> <patterns> = <expression> where <declarations>
20:00:31 <jle`> so where is basically like '->'
20:00:39 <jle`> in case statement syntax
20:00:39 <EvanR> yes
20:01:07 <EvanR> good comparison
20:07:12 <hypoon> Hey guys. I have a simple expression, "find f [1..]", but the first value that satisfies f is very very large. How do I keep from running out of memory? There's no need to keep the beginning of the list in memory after it's already been excluded as a possible result.
20:08:00 <erisco> is the single element large enough to run you out of memory?
20:08:40 <hypoon> erisco: no. If you know where the element is, you can start the list a few thousand elements before it and it completes just fine.
20:08:42 <glguy> hypoon: Maybe there's something in your code that's holding onto the whole list, can you put the problem code on a pastebin?
20:09:07 <hypoon> glguy: there's no need. It's a one-liner.
20:09:17 <hypoon> find (\num -> ((num `mod` 10)*10^((digits num)-1) + (num `div` 10))==2*num) [1..]
20:09:22 <jle`> hypoon: yes, if there's 'find f xs', if you use xs somewhere else, ghc can't garbage collect the list
20:09:27 <joe9> glguy: do you know if there is a non-blocking hIsEOF?
20:09:29 <jle`> hm
20:09:45 <jle`> are you compiling with optimizations?
20:09:47 <hypoon> digits is a small function that literally just counts the digits in base-ten.
20:09:53 <hypoon> I'm running in ghci, at the moment.
20:10:03 <jle`> that might be a potential issue
20:10:25 <hypoon> let digits 0 = 0; digits x = 1 + digits (x `div` 10);
20:10:56 <hypoon> So I guess it's a two-liner, if we want to be pedantic.
20:11:19 <Welkin> it is 3 lines
20:11:46 <hypoon> Welkin: with a line-break at the semicolon, sure.
20:11:57 <Welkin> what is this function even doing?
20:12:00 <Welkin> it looks like a mess
20:12:39 <hypoon> Its finding the smallest integer n such that moving the rightmost digit of n to the left side of n results in 2*n.
20:13:03 <jle`> but yeah, try compiling it with optimizations and seeing if it works in constant-memory
20:13:26 <hypoon> *It's. The result is not practical to compute from this code, it would take an impractical amount of time, but it should still work in theory.
20:13:28 <jle`> technically you could still run out of memory, even of everything is GC's correctly, if the size of the Integer grows too big
20:13:31 <jle`> hehe
20:13:43 <Welkin> hypoon: so this is a project euler exercise?
20:13:54 <hypoon> I know the solution through other means, it has 18 digits.
20:14:00 <Welkin> or another one like it that is not supposed to be brute forced with code and instead solved using math
20:14:03 <jle`> hypoon: yeah, i suggest monitoring the memory using some external program to make sure it's constant
20:14:04 <hypoon> Welkin: perhaps, I wouldn't know. A coworker gave it to me.
20:14:14 <jle`> ah yeah if it's 18 digits, then you won't run out of memory in the Integer
20:14:33 <erisco> well there ought to be a smart way to do it... time to expand the positional notation...
20:14:56 <hypoon> jle`: I was using ":set +s"
20:16:26 <Welkin> compile it with -O2 and -rtsopts
20:16:45 <Welkin> then run the binary with +RTA -s
20:16:47 <hypoon> Welkin: should I really have to? ghci won't handle it?
20:16:54 <Welkin> just try it
20:17:01 <Welkin> ghci works a little differently
20:17:03 <jle`> ghci isn't really too aggressive with optimization, heh
20:17:04 <Welkin> which can cause issues
20:17:09 <jle`> i wouldn't expect to optimize...anything
20:17:39 <Welkin> ghc -O2 main.hs -rtsopts
20:17:41 <jle`> *expect it
20:17:51 <jle`> i wouldn't expect any optimizations from ghci
20:17:54 <Welkin> ./main +RTS -s
20:18:23 <erisco> hypoon, by moving the digit, do you mean a circular shift?
20:18:42 <hypoon> 10683 becomes 31068, which is not double, so it's not a solution
20:18:58 <erisco> so, yes
20:20:08 <hypoon> erisco: yeah, I just didn't want to make any assumption about what you meant by "circular".
20:20:28 <erisco> isn't that what the assembly people call it? I dunno
20:20:34 <Welkin> a rotation
20:21:05 <erisco> https://en.wikipedia.org/wiki/Circular_shift
20:21:29 <hypoon> Welkin: When compiling like you suggest and running, I get "450,843,216 bytes allocated in the heap" and "1 MB total memory in use (0 MB lost due to fragmentation)", among other lines.
20:21:52 <hypoon> Welkin: with the list bounded at [1..1000000], of course.
20:22:12 <Welkin> okay
20:22:19 <Welkin> so it only ever used 1 MB of memory at a time
20:22:30 <Welkin> so it processed your list in constant memory
20:22:32 <mnoonan_> hypoon: where is “digits” defined? I didn’t find it on hoogle.
20:22:53 <hypoon> And it reallocated that memory oodles of times, basically?
20:22:54 <c_wraith> hypoon: high allocation numbers aren't usually a problem when the max resident stays low.
20:23:03 <Welkin> hypoon: yes, the garbage collector is very aggressive
20:23:15 <jle`> hypoon: it actually was probably optimized to be a tight loop
20:23:18 <hypoon> mnoonan_: it's not, I defined it: let digits 0 = 0; digits x = 1 + digits (x `div` 10);
20:23:39 <jle`> so basically like an imperative for loop
20:23:53 <c_wraith> hypoon: GHC allocates *fast*, and it collects the nursery generation very fast.  It's when things start living past the nursery generation a lot that things often become a problem
20:24:03 <skiddieproof> Anyone know what file in the lambdadot source parses command-line inputs? Specifically, what function looks for a '>' before code?
20:25:26 <hypoon> So in any case, this really doesn't use a ton of memory, it was just a lack of optimizations in GHCI that was causing it to report large amounts of memory?
20:25:42 <Welkin> yes
20:27:41 <erisco> so, I dunno, we can get  sum from i = 0 to n of (2*d_i - d_(i + 1 % n))*10^i = 0   where n is the number of digits and d_x is the xth digit (from the right)
20:28:50 <erisco> finding integer solutions for stuff that adds to zero... not my expertise
20:29:07 <erisco> well, natural solutions
20:29:59 <hypoon> You're on the right track. You kinda have to reason about the value of the rightmost digit, and then the rest can be computed easily from that.
20:31:37 <hypoon> For example, if the rightmost digit was 1, then doubling the number results in a number with "1" as the leftmost digit. However, any number with 1 as the leftmost digit will have one-fewer digits total when divided by two, but clearly the number we're looking for will have the same number of digits when divided by 2.
20:31:51 <hypoon> That was extremely wordy, sorry.
20:33:14 <hypoon> If we call the number abcdefg where each letter represents a digit, then if g=1, then 2*abcdef1 = 1abcdef, but 1abcdef / 2 will only have 6 digits, and abcdef1 has 7, so there's a contradiction. The last digit cannot be 1.
20:34:03 <erisco> I would go the other way around and say the number doubled must have the same number of digits
20:34:37 <erisco> this puts some bounds on things but it isn't obvious to me that will be enough
20:34:59 <`Guest00000> how can i have a message queue for many threads at once?
20:36:21 <erisco> I know the most significant digit cannot be larger than 4, and that digit limits how large a carry can be
20:36:22 <pacak> `Guest00000: Chan ?
20:36:24 <hypoon> The smallest number that satisfies my condition will also have the smallest double. For this reason, the last digit must be as small as possible.
20:37:43 <`Guest00000> pacak: thanks
20:39:05 <erisco> n=1 is trivially impossible
20:40:30 * arahael wonders how many people would hate him if he created a ~. operator.
20:40:43 <erisco> guaranteed to be in lens already
20:41:03 <arahael> erisco: It is?  Interesting...  Because \n~. is the default "kill sequence" in ssh.
20:41:14 <glguy> Lens has .~, not ~. (don't be ridiculous :) )
20:41:34 <arahael> glguy: That'd still trigger it.
20:42:04 <jle`> @let (~.) = flip (.~)
20:42:05 <lambdabot>  Defined.
20:42:24 <c_wraith> I wonder if that monomorphized
20:42:29 <c_wraith> :t (~.)
20:42:31 <lambdabot> b -> ASetter s t a b -> s -> t
20:42:41 <jle`> looks like not
20:42:43 <c_wraith> Oh, no classes involved anyway
20:42:51 <c_wraith> Thanks to the use of ASetter instead of Setter
20:43:24 <hypoon> erisco: If you consider a four-digit number, ABCD. Then 2*ABCD = DABC. Or, written differently, 2*(1000A + 100B + 10C + D) = 1000D + 100A + 10B + C. Simplify the expression and you get 1900A + 190B + 19C = 998D, or 100A + 10B + C = 998D/19, or simpler still, ABC = (998/19) * D. There's no four-digit solution because 998 is not a multiple of 19.
20:43:26 <arahael> jle`: That definitely triggered my ssh disconnection just then!  Tried to start a response with '~.' (But luckily, I'm in tmux so just reconnected)
20:43:32 <c_wraith> arahael: technically, the kill sequence in ssh is <enter>~.
20:43:42 <jle`> > "hello" ~. _1 $ (True, 6)
20:43:44 <lambdabot>  ("hello",6)
20:43:52 <arahael> c_wraith: Indeed, but \n is easier to type on irc. :)
20:44:16 <hypoon> erisco: So just find out how many nines you need before that 8 to get a multiple of 19, and you have your solution.
20:44:27 <hypoon> erisco: That's how I solved it the first time.
20:45:10 <erisco> hypoon, I don't see why 998 has to be a multiple of 19
20:45:54 <erisco> say two digits, then  2*(x*10 + y) = y*10 + x ==> 20*x + y = 10*y + x ==> 19*x = 9*y ==> (19/9)*x = y
20:46:31 <erisco> it is a question of whether there are natural solutions for x and y such that x and y are in [0,9]
20:46:55 <arahael> Incidentially, a question about lambdabot: Does it require or use any network connections (beyond that to the chatroom?)  How does it do sandboxing?
20:47:16 <erisco> or you can stop at 19*x = 9*y and leave the rationals out of it :P
20:47:19 <hypoon> ABC is an integer. D is an integer between 0 and 9. Since 19 is prime, the only way you're going to get 998*D/19 to come out to an integer is if 998 is a multiple of 19.
20:48:10 <peddie> arahael: the sandboxing is from a separate package called mueval
20:48:27 <hypoon> 2*(x*10 + y) = y*10 + x ==> 20*x + 2*y = 10*y + x ==> 19*x = 8*y ==> (19/8)*x = y
20:48:29 <peddie> arahael: it's possible to run it without network connections on a local machine and send the same queries you do here
20:48:32 <geekosaur> arahael, the IRC connections you configure are the only network connections aside from incidentals (i.e. DNS/name service lookups)
20:48:43 <geekosaur> and yes, mueval is the sandbox
20:48:50 <erisco> well yeah, you can then show why there is no solution for D in 0 to 9 ... I was just stating the more basic reason
20:48:55 <arahael> peddie: Is that part of the package, or is it configured separately?
20:49:10 <geekosaur> @hackage mueval
20:49:10 <lambdabot> http://hackage.haskell.org/package/mueval
20:49:12 <peddie> arahael: mueval?  it's built in
20:49:16 <arahael> neat.
20:49:24 <arahael> I'll have to check it out!
20:49:30 <peddie> arahael: have fun
20:49:37 <erisco> but it is a bit boring going through all the lengths of numbers
20:49:58 <arahael> peddie: Thanks.  Hoping to add something to the work slack channel.  (lambdabot-slack)
20:50:07 <arahael> peddie: Well, slack-lambdabot, anyway.
20:50:41 <peddie> arahael: I once rigged this up.  the slack API is not well documented and changes frequently.  I hope you're more successful than I was :)
20:51:11 <erisco> hypoon, oh, thanks, arithmetic...
20:51:16 <arahael> peddie: I'll have to wait until I have a bit of time, then.  But yes, I have experienced that pain. It also depends on _which_ api it uses if Im allowed to use it. :(
20:51:40 <joe9> program http://dpaste.com/117PFRV error: http://bpaste.net/show/390a182f056d . Is it wrong to check for input on stdin?
20:51:43 <peddie> arahael: the easy way might be to just get your slack admin to turn on the IRC gateway
20:51:49 <joe9> it is core dumping
20:51:51 <arahael> peddie: Not Going To Happen. :(
20:52:42 <arahael> peddie: The slack devs documented that it would reduce security.
20:52:47 <arahael> peddie: And who wants that!?
20:53:17 <peddie> arahael: lol, because slack is _so_ secure . . . well, good luck doing it the hard way
20:53:36 <erisco> so now at 3 digits we have 100*x + 19*y = 98*z ... and we have to keep playing this game out to 18 digits? geez
20:53:43 <erisco> need more brains to solve this
20:53:50 <arahael> peddie: Totally besides teh point.  The point is to set it up in the most secure fashion that is possible.  And enabling irc (or jabber) will reduce that.
20:54:07 <peddie> arahael: ok
20:54:08 <arahael> peddie: Infact, they say that right at the admin page to scare the admin away.
20:54:20 <peddie> arahael: I know they say it . . .
20:54:29 <peddie> anyway this is probably off-topic :)
20:54:53 * arahael walks away, muttering to himself.
20:55:46 <erisco> no I mathed it wrong again... eyes are going cross
20:56:17 <erisco> 'tis 190*x + 19*y = 98*z
20:56:48 <erisco> 'tis 19*(10*x + y) = 98*z  and therefore we have hope... a pattern emerges
20:57:21 <hypoon> yep, or 19*(XY)=98Z, as I would write it.
20:57:32 <erisco> yeah well mathematicians are weird
20:57:47 <hypoon> 19*(WXY)=998Z, and 19*(VWXY)=9998Z, etc...
20:58:43 <erisco> right, so it is always a factor of 19 one the left and a factor of some 9's followed by an 8 on the right
20:59:24 <geekosaur> joe9, fwiw unix doesn't support nonblock on disk files, only sockets or terminals. (more precisely, they are always ready-to-read and it looks like the ghc runtime does not expect the resulting behavior)
20:59:59 <joe9> geekosaur: ok, Thanks. will switch back to using hReady
21:00:11 <geekosaur> hReady will have the same problem
21:00:14 <erisco> so now we can start looking at the integer multiples of 19 that look like 999...8, or something
21:00:35 <geekosaur> well, actually that's a pipe so maybe not.
21:00:49 <geekosaur> in any case you seem to be set up to discover all the lovely corner cases in POSIX
21:01:23 <geekosaur> and, really, the right way to do things like this is to use a reading thread that blocks, not trying to emulate single-threaded C code
21:01:48 <joe9> geekosaur: good idea. Thanks, will try to do that.
21:02:48 * hackagebot bench 1.0.6 – Command-line benchmark tool – https://hackage.haskell.org/package/bench
21:03:18 <erisco> hypoon, that's still a pretty stupid search though, hm
21:03:37 <hypoon> erisco: you can calculate it using modular arithmatic.
21:03:47 <hypoon> *arithmetic. Can't spell.
21:03:57 <erisco> and my modular arithmetic is poop
21:04:42 <erisco> so you want this brute force search just to verify your solution?
21:04:58 <erisco> if it is 18 digits you're in trouble
21:06:19 <arahael> If I want to use haskell (via ghci) for scripting - what I'd normally use bash or python for (shell scripting, that is), what package should I use?
21:06:24 <arahael> Is Shelly the best appraoch?
21:06:39 <pacak> turtle?
21:06:39 <erisco> 19 + 19 = 38 ... the next time the last digit is an 8 will be another 10 additions of 19 i.e. 228
21:06:41 <peddie> arahael: there's also Turtle
21:06:47 <geekosaur> shelly or turtle, I think. and runghc will probably be easier than ghci
21:07:09 <erisco> so there's a whopping factor of 10 improvement... zzz
21:07:10 <arahael> geekosaur: I intend to use 'stack ghci'
21:07:17 <geekosaur> then you want stack scripts
21:07:24 <arahael> stack scripts?
21:07:25 <geekosaur> ghci is interactive, not really scripts
21:07:51 <Axman6> stack has the ability to be used as a script these days
21:08:07 <Axman6> (you can use a shebang line at the top of your file)
21:08:30 <geekosaur> https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
21:08:47 <arahael> Thanks :)
21:09:05 <pacak> Depending on you tasks - bash or python might be more optimal.
21:09:51 <arahael> geekosaur: stack scripts looks ideal! :)
21:09:55 <vjs> why _ in a pattern match of list comprehension treated as a sink?
21:10:23 <Axman6> "a sink"?
21:10:28 <arahael> pacak: Well, yes...  :)
21:10:29 <geekosaur> it acts like _ in a pattern match, it matches anything without binding it
21:10:42 <geekosaur> what were you expecting it to do?
21:11:11 <erisco> could probably figure out how to predict if the second last digit is a 9...
21:11:17 <Axman6> _ <- xs says "for each element of xs, ignore it, but do everything that follows length xs times
21:12:33 <vjs> example add' [x:y:z:_] = x + y + z + sum _ reports error - Found hole. but if I replace _ it works
21:12:49 <c_wraith> vjs: because _ by itself isn't a valid identifier
21:13:24 <Axman6> _ is the "Ignore this argument so I don't have to give it a name" notation
21:13:30 <c_wraith> vjs: it's not a valid identifier specifically so that anything you bind to it cannot be accessed.
21:13:41 <vjs> in the context of a list?  fst' (a,_,_) = a seem to work though?
21:13:57 <c_wraith> vjs: those are patterns.  _ is a valid pattern
21:13:58 <vjs> ok got it.. so accessing it would cause an error
21:14:04 <geekosaur> vjs, you are using it as a pattern match there
21:14:34 <geekosaur> when you used it on the right of a =, it is illegal and current ghc treats it as a "hole", a placeholder that reports its type
21:14:34 <Axman6> vjs: your code says: add' is a function which takes a list, which contains a list, with at least three elements, calling those first three x, y and z, and ignoring the rest of that list
21:15:09 <Axman6> vjs: there's nothing to access, _ is _syntax_ that specifically "the thing here in the pattern does not need a name, because it is not used"
21:15:09 <hypoon> erisco: no, I wanted to benchmark the brute-force search just to prove that it's impractical to solve it using a brute-force search.
21:15:30 <erisco> hypoon, well come on, that can be proved easily without writing the program :P
21:15:33 <geekosaur> and if you disabled holes (not sure if you can currently, aside from using an older ghc) it would report that you used pattern syntax in an expression
21:16:11 <erisco> hypoon, just say the CPU can pass/fail one integer per tick, and then look at your clock rate, it is probably 3.5Ghz or something
21:16:15 <Axman6> _ on the right hand side of an = is a hole, it says "I don't know what type the thing in this location should be, please tell me and fail to compile"
21:16:44 <Axman6> > let f = foldr (+) _ in f
21:16:46 <lambdabot>  error:
21:16:47 <lambdabot>      • Found hole: _ :: b1
21:16:47 <lambdabot>        Where: ‘b1’ is a rigid type variable bound by
21:16:50 <erisco> hypoon, then you can figure out how many simultaneously working CPUs it would take to solve it in a fixed time
21:16:56 <vjs> thank you geekosaur and Axman6, i think i understand now. so _ is a placeholder for everything that would not be needed / accessed?
21:17:05 <erisco> or by fixing the CPUs to find how long it would take
21:17:13 <geekosaur> it's a way to match something and ignore it, yes
21:17:23 <Axman6> vjs: yes, if you gave a name to the end of the list and then didn't use it, you qould get a warning about an unused variable
21:17:32 <geekosaur> you have to have *somrthing* there structurally but you don't care what it is, so you use _
21:17:41 <Axman6> so we have syntax to say explicitly "I don't care what's here"
21:17:46 <hypoon> erisco: Work on two digits at a time. 38 is a starting point. Have to convert that to x98. Don't touch the last digit, so add 190s instead of 19, or as I think about it, add 19 to 3. Every time you add 19, you decrease the "ones" place by 1, and increase the "tens" place by 2, wrapping appropriately as necessary.
21:18:47 <erisco> hypoon, you do not always increase the tens place by 2 ... predicting the second least significant digit being a 9 is harder than predicting the lsd to be an 8
21:18:48 <vjs> Axman6, geekosaur - ok. makes sense. thank you so much.
21:18:52 <hypoon> erisco: decreasing 3 to 9 requires 4 additions of 19, so your next number is 798 (don't forget that you wrapped once)
21:19:57 <erisco> the number after 190 is 209, that isn't an increase by 2 in the tens
21:20:21 <hypoon> erisco: decreasing 7 to 9 requires 8 additions, so your next number is 15998
21:21:41 <vjs> Axman6++
21:21:53 <vjs> geekosaur++
21:22:02 <hypoon> erisco: When working with 38, ignore the 8, that's done. Working with just the 3, you need to add 19*4 in order to get something that ends in 9, which will be 79. Now you have "798" as your full number. The "98" part is done, so work just with the 7.
21:23:35 <`Guest00000> how do you order arguments in your functions?
21:24:11 <erisco> `Guest00000, if you can make an endofunctor on the end, do that, and otherwise put the big typed stuff first and the little typed stuff later
21:24:28 <erisco> I dunno, there is no actual rule, but something like that might fit a reasonable portion of the database...
21:24:46 <`Guest00000> what does "big typed stuff" mean?
21:25:03 <erisco> the larger types
21:25:13 <`Guest00000> larger textually?
21:25:33 <erisco> yes
21:26:33 <erisco> well sort of, I am saying Integer is smaller than [a]
21:26:56 <erisco> so, measure the expression size, rather
21:27:11 <erisco> :t replicate
21:27:12 <lambdabot> Int -> a -> [a]
21:27:28 <erisco> that is a bad example... anyways there will be lots of exceptions to my made up rule
21:27:57 <`Guest00000> so, not textually
21:28:00 <erisco> hypoon, there is something missing in my head to say that is okay
21:28:01 <`Guest00000> structurally, maybe
21:29:39 <Axman6> `Guest00000: Generally you need top think about how the function is going to be used. "config"
21:29:53 <Axman6> type parameters should go before the data they work on
21:30:37 <Axman6> like take's "config" is the number of items, and you get back a function which takes n elements - this is a more common thing to give a name to than the function which takes an int and returns up to n elements of a specific list
21:31:13 <Axman6> the endofunctor comment plays into this
21:32:18 <ReinH> `Guest00000: Try ordering them so that partial application is useful
21:32:37 <ReinH> look at map for example
21:34:59 <erisco> hypoon, it is the missing bit that convinces me there is not something ending in 98 less than 798
21:35:44 <erisco> there is 190, 399, and others where the second lsd is 9, obviously the lsd is not 8, but I am not obviously convinced to just ignore the 8 as you put it
21:38:21 <`Guest00000> is it bad if i kill already dead threads?
21:38:57 <erisco> it is a bit overkill
21:40:55 <Axman6> sounds like you should be using better abstractions, like the async package
21:41:02 <hypoon> erisco: Here's a different way of thinking about it. We need 99...98 to be a multiple of 19. So, 99...98 mod 19 = 0, or if we add 2 to both sides, 10^x mod 19 = 2. 10^1 mod 19 is 10. 10^2 mod 19 is 10*(10^1 mod 19) mod 19, or 100 mod 19, which is 5. 10^3 mod 19 is therefore 10*5 mod 19 = 12. 10^4 mod 19 is 10*12 mod 19 = 120 mod 19 = 6. If you keep going... you get to 10^17 mod 19 = 2. That's the first 2 we reach, and that is where w
21:42:38 <erisco> see, I have never learned modulus, so these things are not available to me
21:43:45 <`Guest00000> i don't like to use fancy things if it can be implemented simply enough with standard tools and is rare enough in my code
21:45:34 <hypoon> erisco: alright, back to the other method. You start with 38. You don't want to change the last digit, but you want to add multiples of 19, so you really have to add multiples of 190. Each time you add 190, you decrease the second-from-the-right digit by 1, so you have to do that four times to get to something that ends in 98. 4*190=760, so add 38 and you get 798.
21:45:41 <peddie> `Guest00000: I think if you implement it simply and correctly with standard tools, you'll end up pretty close to the async package
21:46:19 <`Guest00000> peddie: which is the reason not to depend on it anyway
21:46:21 <Axman6> async is how tot avoid all the pitfalls of asynchronous code. it absolutely makes your code simpler, clearer and more safe
21:46:36 <`Guest00000> i like less dependencies
21:46:48 <erisco> hypoon, oh, yeah, that makes sense... after figuring out I have to try in increments of 190 I don't know why I went back to thinking about increments of 19
21:47:04 <peddie> `Guest00000: the reason not to depend on it is that you can then implement your own less correct version that you have to maintain yourself?
21:47:12 <peddie> O__o
21:47:22 <Axman6> `Guest00000: then be prepared to incorrect code in the presence of exceptions (yes, your async code will likely have exceptions)
21:47:38 <erisco> hypoon, seems like a happy accident it is 190, or some number ending in zero
21:47:52 <Axman6> `Guest00000: this is a very poor preference IMO, when it comes to improving the safety of your app
21:48:24 <hypoon> erisco: Now you don't want to touch the 98, so you need to add a multiple of 19 that ends in double-zeros. The smallest one is 1900. The same logic says you have to add 8 multiples to turn the 7 in 798 into another 9, so 8*1900 = 15200, therefore you get 798+15200=15998.
21:48:36 <Axman6> async is written by the people who implemented all the concurrency primitives in GHC to begin with, and understand the complex interplay, which I am very sure you don't
21:49:07 <hypoon> It's sort of a happy accident. You want the first multiple that ends in a zero. Since 19 is prime, it's 10*19.
21:49:15 <Axman6> (not because it's you personally, but because it is very difficult to get right, and no one understands this better than people like Simon Marlow)
21:49:50 <erisco> hypoon, that isn't strong enough reasoning for my brain... the conclusion that now we have to use increments of 1900
21:50:20 <erisco> yeah, it doesn't change the 98, but I am not convinced this is the smallest
21:50:22 <hypoon> erisco: any smaller increments will disrupt the trailing "98" we have in "798".
21:50:39 <erisco> *shrug*
21:50:51 <hypoon> erisco: Is there a smaller multiple of 19 that ends in 00?
21:51:01 <`Guest00000> what i said is i don't want to depend on something for just one usage of one function
21:51:08 <erisco> I am not convinced that is necessary, that was the point I just made
21:51:44 <hypoon> erisco: ah, I see where you're stuck now.
21:52:52 <erisco> what I'd be doing now is adding 190 to 398 a bunch of times to see if I can see a new pattern
21:53:08 <erisco> and probably becomes evident our new magic number is 1900, but the general principle of why this is I don't see
21:53:40 <hypoon> erisco: you mean 798, right?
21:53:49 <erisco> yeah, that one
21:54:34 <hypoon> The increment that you need to add, are you not certain it needs to be a multiple of 19, or are you not certain it needs to end in 00?
21:55:24 <erisco> I am certain it needs to be a multiple of 190 because we've already established that much about the 8
21:56:00 <erisco> so now I have to look at how many times we need to add 190 to a number ending in 98 to get another number ending in 98
21:57:00 * hackagebot megaparsec 6.0.1 – Monadic parser combinators – https://hackage.haskell.org/package/megaparsec
21:57:19 <jle`> i love you megaparsec
21:57:19 <hypoon> We don't want to end in 98, we want to end in 998 now, actually.
21:58:00 <erisco> those are not mutually exclusive :)
21:58:49 <hypoon> No, but the first instances are not the same.
21:59:03 <hypoon> If you start adding 190s to 798, you'll get to 2698 first.
21:59:28 <hypoon> But we haven't gained anything yet. We want to get that next 9.
22:00:57 <hypoon> erisco: but that's not where you're confused, I think.
22:01:13 <erisco> we started with 38 and I observed that it required 10 additions of 19 to get to the next number ending in 8
22:01:30 <erisco> that is where 190 came from, it had nothing to do with ending with 98
22:01:45 <MarcelineVQ> jle`: the best part is megaparsec loves you too
22:01:47 <erisco> similarly I am going to do the same thing with 98
22:02:37 <hypoon> erisco: consider this: map (190*) [0..10] == [0,190,380,570,760,950,1140,1330,1520,1710,1900]
22:02:38 <`Guest00000> funny thing, "user loves package" and "package loves user" means roughly the same thing
22:02:40 <erisco> so if I start from 798 and then find 2698 and keep finding other numbers ending in 98, I am looking at how many times I had to add 19 to get there
22:03:04 <`Guest00000> maybe differing in intensity
22:03:21 <MarcelineVQ> if you asked megaparsec to marry you it'd probably say yes, not every package is willing to go that far for you
22:03:55 <hypoon> erisco: if we think about the fact that we're starting with 798, the last two digits will be 98+0, 98+90, 98+80, 98+70, etc... but the only one that will get you back to 98 will be 98+0 or 98+00.
22:04:09 <hypoon> (where the "00" corresponds to 1900)
22:04:45 <erisco> I don't know what you mean there, but anyways I am too tired to keep thinking about it :P
22:04:49 <erisco> interesting problem though
22:05:11 <hypoon> erisco: don't forget the ultimate goal is to figure out the lowest multiple of 19 that has the form 99...98
22:06:11 * hackagebot stache 1.0.0 – Mustache templates for Haskell – https://hackage.haskell.org/package/stache
22:06:11 * hackagebot hw-rankselect 0.8.0.2 – Rank-select – https://hackage.haskell.org/package/hw-rankselect
22:06:22 <hypoon> erisco: Once you have that 99...98 number, divide that by 19 and you get a messy number, call it "alpha". We now have AB...XY = alpha Z
22:06:57 <erisco> yeah, I know the rest
22:07:19 <hypoon> erisco: do you want the answer?
22:07:30 <erisco> no, it doesn't matter to me :P
22:08:00 <erisco> I would find 1900 by reaching 2698 by adding 190 to 768 10 times
22:08:57 <erisco> then I'd realise that it is always going to be a difference 1900 when I reach 98 again, because any number ending in 98 plus 1900 also ends in 98
22:09:15 <hypoon> That's right
22:09:23 <erisco> however, the general conclusion that we're going to find 190, then 1900, then 19000, then 190000 I do not see
22:09:28 <erisco> that is what I am saying I do not get
22:10:15 <hypoon> erisco: I guess it's hard to explain why, but it seems obvious to me that you have to add multiples of something that ends in X zeros, where X is the number of digits you don't want to change.
22:10:18 <jle`> MarcelineVQ: :3
22:10:53 <hypoon> erisco: I'm a Ph.D. student though, so obvious to me is not necessarily obvious in general.
22:11:24 <erisco> I didn't know phd's granted super powers
22:12:35 <erisco> I am even willingly overlooking the question of why just because I find the difference of 190 once, or 1900 once, that it is always this difference
22:12:55 <erisco> yes, if I add 190 or 1900 or whatever ending in zeros I will preserve the corresponding digits
22:13:05 <erisco> but there is still something missing to say there are not other numbers that do this
22:13:25 <erisco> only that I've found the difference between the first two and assume it also lies between the rest
22:13:27 <hypoon> The Ph.D. doesn't. The spending of (in my case) 8+ years staring at mathematics leads to the development of certain intuitions that I've only recently recognized as... odd.
22:14:01 <erisco> well, also develop an intuition for proof so you can share ;)
22:14:59 <hypoon> If there is another number that preserves the rightmost digits (call it X), then 798+X will result in a number that ends in 98.
22:15:56 <hypoon> so then that number, blahblahblah98, minus 798, equals [blahblahblah-7][00], using a terrible but hopefully transparent notation.
22:16:37 <hypoon> Now the question of "Is there another multiple of 19 that ends in 00 BEFORE we get to 1900?" is a bit trickier.
22:18:01 <hypoon> To prove that, we can look at the fact that any smaller number blah00 will be blah*100. We're looking for something smaller than 1900, so blah<19.
22:19:00 <hypoon> Actually, scratch that. That's more complicated than we need to be.
22:20:59 <hypoon> Any multiple of X is X*Y. For it to end in P zeros, X*Y must have P factors of 10 (502657000 can be written as 502657*10*10*10, so it has three factors of ten, etc...).
22:21:09 <texasmynsted> hmm can't determine between happstack, yesod, and snap.  The more I google and compare the more unclear it becomes.
22:21:28 <jle`> texasmynsted: have you done any web programming in the past?
22:21:31 <texasmynsted> It is clear all three are very solid
22:21:35 <texasmynsted> yes
22:21:40 <jle`> what have you worked with?
22:22:06 <hypoon> erisco: For X*Y to have P factors of 10, every factor of 10 is a factor of 5 and a factor of 2, so it must have P factors of 5 and P factors of 2.
22:22:21 <texasmynsted> everything from cgi, php, jsp, java servlets, markdown, you name it
22:22:41 <hypoon> erisco: If X is prime (like 19), then it brings no factors of 5 or 2 to the table, and all factors of 5 and 2 must be in Y.
22:22:48 <texasmynsted> If you are talking about the front end.
22:23:14 <texasmynsted> Java, and scala mostly for the bulk of things
22:23:54 <texasmynsted> I like the idea of hammlet or whatever it is called in yesod
22:24:10 <mark__> can you mix case expressions and where bindings?
22:24:18 <texasmynsted> I have moved most simple pages to be markdown, where possible.
22:25:02 <geekosaur> mark__, where scopes to definitons so that's something of a nonsense question
22:25:07 <glguy> > case "test" of x:xs -> ys where ys = x:x:xs
22:25:09 <lambdabot>  "ttest"
22:25:18 <texasmynsted>  I think I would like to have something modular, maintainable, and flexible enough to let me use hamlet or markdown as needed.
22:25:28 <mark__> thanks!
22:25:35 <geekosaur> where did that scope to?
22:25:39 <texasmynsted> maintainable being the most important 
22:25:49 <glguy> mark__: each branch of a case gets its own where
22:25:58 <geekosaur> the pattern match, ok
22:26:09 <geekosaur> I mean that was the "definition"
22:26:40 <hypoon> erisco: Therefore, all factors of 10 must be in Y. The smallest case, with no other factors, is the case where Y only has P factors of 10, or equivalently when Y=10^P.
22:28:49 <hypoon> erisco: If X were 18, it is not prime, and it brings a factor of 2 to the table. Now, to get something that ends in P zeros, you need P factors of 5, but only another P-1 factors of 2 (because you already had one). In this case, the smallest Y that leads to X*Y ending in P zeros would be 5*10^(P-1).
22:31:16 <hypoon> erisco: If X were 25, it is not prime, and it brings two factor of 5 to the table. Now, to get something that ends in P zeros, you need P-2 factors of 5 and  P factors of 2. In this case, the smallest Y that leads to X*Y ending in P zeros would be 2*10^(P-2).
22:31:45 <hypoon> erisco: OOPS: that should be 4*10^(P-2).
22:32:18 <erisco> hypoon, sorry I don't know what the blahblahblah proof answers
22:32:56 <erisco> hypoon, that X ends in two zeros?
22:33:35 <hypoon> erisco: that was showing that if you want to preserve the last P digits, you have to add something that ends in P zeros.
22:36:03 <hypoon> But it is generally possible for something to end in P zeros, while being a multiple of X, without being X*10^P. An example is if X=5, and you want a multiple ending in 1 zero. X*10^P gives you 50, but clearly 10 is a multiple of 5 that also ends in zero. This only happens because 5 shares a factor with 10 (in this case, that factor is 5, because 5*2=10). 19 shares no factors with 10.
22:36:37 <erisco> yes... there are some happy accidents going on
22:41:27 <hypoon> erisco: Basically, you always multiply by the minimum number of 2s and 5s in order to get the right number of zeros at the end. 19 shares no factors with 10, so that's easy and simple. 22 does, it shares a 2, so we can compensate for that by removing a factor of 2 from our 100 and multiplying by 50 instead to get something that ends in 00.
22:41:56 <hypoon> erisco: so yeah, there's a bit of a happy accident, but it's easy enough to compensate for it if we didn't have such a happy accident.
22:42:17 <jle`> texasmynsted: i mean, have you ever used a framework?
22:42:36 <jle`> i guess you haven't used something like rails, if those are the tech stacks you usually work with
22:44:27 <hypoon> erisco: If we did this whole problem in base-16 instead, we'd have the same happy accident, because our interval would be 2*16 - 1=31, which is also prime. If we did it in base-8, then our interval would be 2*8-1=15, which is not prime, and does share factors with 10! However, doing it in base 8, we multiply by 8 now to add a zero, not 10 anymore, and 15 does not share any factors with 8.
22:45:05 <hypoon> erisco: In fact, in whatever base X you do it in, the question is whether 2*X-1 shares any factors with X, and I think the answer is always "no".
22:45:36 <hypoon> erisco: 2*X-1 is certainly never a multiple of X. 
22:45:58 <hypoon> erisco: but I'd have to think more about whether 2*X-1 can share any factors with X.
22:49:00 <hypoon> erisco: No, it can't. Any factor F of a number X will also be a factor of 2*X. The next nearest multiples of F are 2*X+F and 2*X-F, so unless F=1 (which is not useful), 2*X-1 will not be a multiple of F, and therefore X and 2*X-1 share no factors.
22:50:03 <jle`> texasmynsted: yeah most frameworks will handle templating without any problems
22:50:08 <texasmynsted> jle`: I typically prefer libs to frameworks
22:50:26 <jle`> yesod is kind of more of a monolithic framework, i'd think
22:50:28 <texasmynsted> I have use Spring plenty
22:50:40 <jle`> i've heard it compared to rails
22:51:29 <hypoon> erisco: Unfortunately I have to sign off. Work in the morning. I'll message you my email address if you'd like to continue this when I'm not around.
22:51:42 <erisco> hypoon, I am going to bed too. night!
22:52:01 <texasmynsted> ok. I suppose I could compare yesod to rails and go from there.
22:52:08 <jle`> texasmynsted: the least frameworkey one i've seen is scotty, which is basically a hook-this-sort-of-response-on-this-request, where the response can be literally anything (markdown/hamlet integration up to you)
22:52:24 <hypoon> erisco: goodnight!
22:52:25 <jle`> any modularity in it is up to you and how oyu design your app
22:52:29 <texasmynsted> oh, I will take a look at scotty
22:52:52 <jle`> it's like sinatra (ruby) or flask (python), if those mean anything to you
22:53:02 <jle`> i'd imagine snap and happstack to be some sort of happy in-between
22:53:22 <jle`> (but i haven't used either myself)
22:53:54 <jle`> if you notice a large difference in the state of their ecosystem or number/quality of tutorials, i might suggest going by that
22:54:14 <jle`> if you've looked at them and found them (technically) both similar
22:55:54 <texasmynsted> I have a site running on octopress...  I think octopress is a bit like sinatra
22:56:54 <ReinH> octopress is a static site generator
22:56:59 <ReinH> it is not like sinatra
22:57:08 <ReinH> hakyll would be a better comparison
22:57:09 <texasmynsted> oh right, I guess sinatra is real-time
22:57:25 <jle`> yes, the main haskell static site generator is hakyll
22:57:29 <jle`> my blog actually is hakyll
22:57:33 <ReinH> sinatra is an HTTP server
22:57:43 <texasmynsted> yes, I played with kakyll a little.  I like it.
22:58:07 <jle`> hakyll is closer to jekyll, and it looks like octopress is a layer of abstraction over jekyll
22:58:49 <texasmynsted> one of these days I will convert my octopress site to hakyll
22:59:13 <texasmynsted> right now the UI is a bit integrated into octopress.
22:59:29 <jle`> yeah, that might be a big step
22:59:41 <jle`> converting your octopress into hakyll *might* be similar to converting your octopress into jekyll
22:59:41 <texasmynsted> jle`: what is your blog url?
22:59:46 <jle`> https://blog.jle.im
23:00:12 <jle`> the source code is on github
23:00:31 <jle`> to be fair the hakyll is a bit contrived, since i ported it from scotty and had to match up the site structure and url schemes
23:00:42 <jle`> but hakyll was flexible enough to accomodate me without much trouble
23:00:47 <glsubri> hi all
23:00:51 <texasmynsted> nice
23:01:49 <jle`> by the way, maintainability is a priority (like you mentioned), any haskell web framework or library is going to be way ahead of anything in other langugaes
23:02:03 <jle`> just because haskell
23:02:03 <jle`> glsubri: hi
23:02:05 <texasmynsted> :-)
23:02:39 <jle`> one of my first haskell projects was a web project and the stark difference in maintainability was one of the main reasons i stuck with haskell after that, heh
23:03:38 <texasmynsted> I really like the combination of FP and static typing
23:03:44 <jle`> i built my blog many years ago but i'm still comfortable going in and hacking on it as if i had just picked it up, without worrying about anything breaking
23:03:53 <jle`> </anecdote>
23:04:51 <texasmynsted> very nice
23:05:52 * hackagebot aeson-flowtyped 0.7.4 – Create Flow type definitions from Haskell data types. – https://hackage.haskell.org/package/aeson-flowtyped
23:06:15 <texasmynsted> I did some years of scala then took on some java again, and was shocked by the noise and disorder.
23:06:47 <jle`> heh, yeah, it can spoil you :)
23:07:11 <texasmynsted> so now I need to also check out scotty heh
23:07:31 <texasmynsted> and hakyll for static sites, of course 
23:08:27 <mniip> maintainability often conflicts with flexibility
23:08:40 <texasmynsted> But if I wanted to write a simple, light, url shortener, seems like I would want something a light and small as possible. 
23:08:44 <MarcelineVQ> hakyll is pretty nice and dead simple to get started with, customization might be less straight forward, but for serving markdown as html you're in pretty good shape right off the bat
23:09:09 <Axman6> texasmynsted: if no one has mentioned it yet, Servant is fantastic for writing REST type web applications, and getting a lot of nice stuff for free (automatic generation of haskell client code, as well as javascript API generation, swagger docs, etc)
23:09:29 <texasmynsted> I think that yesod can also be used to create a static site.  (thought I read something like that)
23:09:45 <texasmynsted> servant?
23:09:55 <Axman6> I don't believe yesod is well aimed at making static sites. it can certainly host static files
23:10:11 <Axman6> http://haskell-servant.github.io
23:10:33 <`Guest00000> i have a loop which spawns threads. i need to kill them all instantaneously on an arbitrary event. how do i do it better?
23:11:09 <Axman6> using async :\
23:11:49 <`Guest00000> i'm looking at Control.Concurrent.Async and not seeing a significantly better way than anything with standard functions
23:11:58 <`Guest00000> which is Control.Concurrent
23:11:58 <Axman6> texasmynsted: uh, actually, better docs are at http://haskell-servant.readthedocs.io/en/stable/
23:12:29 <texasmynsted> looks interesting.
23:12:47 <texasmynsted> I saw another REST lib... hmm
23:14:33 <Axman6> `Guest00000: cancel :: Async a -> IO () is the safe version of just throwing ThreadKilled at a thread. you can do forM asyncs cancel to kill all threads in a list (or arbitrary strcuture)
23:15:02 <Axman6> `Guest00000: what are you actually doing with these threads?
23:15:48 <`Guest00000> those are client threads
23:16:29 <glsubri> it's fun to see people doing async threads and stuff while I'm struggling with chapter 4 of real world haskell...
23:16:36 <Axman6> can you elaborate? under what circumstances do you need to kill them?
23:17:08 <`Guest00000> on an emergency command
23:19:54 <systemfault> glsubri: That book made me give up on Haskell the first time I tried learning it.
23:20:30 <glsubri> systemfault: how did you learn ?
23:21:02 <systemfault> glsubri: The Haskell book, it's not free.
23:21:09 * texasmynsted shrug
23:21:53 <systemfault> I don't personally think that anyone can learn Haskell from RWH... and now that it's so old, even less.
23:22:01 <texasmynsted> thanks guys.  I guess the thing to do is try a bunch of these and find what it a best fit
23:22:52 <glsubri> systemfault: what did you not like ?
23:24:31 <systemfault> glsubri: Exercises that expect you to know things you learn later in the book. The book goes too quickly... and to be honest, the content didn't interest me much. And now, I wouldn't be surprised if some of the code examples simply don't compile on modern GHC.
23:25:40 <glsubri> systemfault: do you remember at which chapter you dropped the book ?
23:26:03 <systemfault> I read it completely... trying to understand every chapter.
23:26:21 <systemfault> It's after I was done... felt I had not actually learned much from it.
23:26:35 <systemfault> Become frustrated and gave up.
23:26:39 <systemfault> *Became
23:27:41 <glsubri> Oh... Ok. Does anybody have another book/website/? that has good exercises to do to learn haskell ?
23:27:54 * pacak liked RWH
23:28:07 <`Guest00000> why is there no $>
23:28:22 <`Guest00000> which should be just flip (<$)
23:28:50 <pacak> :t (*>)
23:28:51 <lambdabot> Applicative f => f a -> f b -> f b
23:28:54 <pacak> :t (<*)
23:28:55 <lambdabot> Applicative f => f a -> f b -> f a
23:29:13 <texasmynsted> glsubri: http://haskellbook.com
23:29:33 <pacak> `Guest00000: They do slightly different things.
23:29:36 <systemfault> Second time I failed learning Haskell, I used LYAH
23:29:48 <`Guest00000> oh well
23:29:53 <pacak> flipped version would probably be <&
23:30:12 <`Guest00000> but there is no <&>
23:30:18 <systemfault> Ended up learning lots of Haskell ideas... but I still wasn't able to write an actual program with it.
23:30:32 <pacak> :t (<&>)
23:30:34 <lambdabot> Functor f => f a -> (a -> b) -> f b
23:30:38 <pacak> oh noes
23:30:43 <pacak> there's no <&>
23:31:00 <texasmynsted> I have not read a bunch of the haskell books... 
23:31:02 <`Guest00000> what
23:31:02 <texasmynsted> https://www.haskell.org/documentation
23:31:04 <jle`> `Guest00000: there is a ($>) ....
23:31:08 <`Guest00000> which package is that
23:31:08 <jle`> `Guest00000: it's in Data.Functor
23:31:11 <jle`> in base
23:31:19 <jle`> comes with ghc :)
23:31:25 <`Guest00000> ah
23:31:29 <texasmynsted> https://wiki.haskell.org/Books
23:31:30 <`Guest00000> blind again
23:31:39 <glsubri> this book seems fine
23:31:40 <jle`> > [1,2,3] &> 0
23:31:42 <lambdabot>  error:
23:31:42 <lambdabot>      • Variable not in scope: (&>) :: [Integer] -> Integer -> t
23:31:42 <lambdabot>      • Perhaps you meant one of these:
23:31:44 <jle`> > [1,2,3] $> 0
23:31:46 <lambdabot>  [0,0,0]
23:32:10 <glsubri> systemfault: I guess the question is now "Can you actually write a programm in haskell?"
23:32:12 <texasmynsted> systemfault: so what clicked for you?
23:32:20 <systemfault> glsubri: Yup.
23:32:45 <systemfault> glsubri: Working on a NES emulator 
23:32:58 <texasmynsted> systemfault: do you have a "process"?  Like write tests first or whatever?
23:33:07 <`Guest00000> systemfault: cool, any special features?
23:33:10 <glsubri> systemfault: nice!
23:33:25 <systemfault> texasmynsted: Nah, it's only for fun... I just code. Trying new extensions at the same time.
23:33:51 <systemfault> `Guest00000: No, I'm still at a point where I'm trying to make it work :)
23:33:59 <`Guest00000> are there planned?
23:34:02 <systemfault> Features will come later :p
23:34:05 <glsubri> I'd like to build a little caldav server
23:34:16 <texasmynsted> :-)
23:34:19 <texasmynsted> later
23:34:22 <systemfault> `Guest00000: No, I don't plan.. it's for fun.
23:34:35 <systemfault> (I don't plan very much at all IRL...)
23:36:28 <nshepperd_> Impulse driven development :)
23:37:19 <glsubri> systemfault: bought the book. Will begin reading ASAP!
23:40:15 * hackagebot aeson-flowtyped 0.7.5 – Create Flow type definitions from Haskell data types. – https://hackage.haskell.org/package/aeson-flowtyped
