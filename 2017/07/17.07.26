00:00:11 <wz1000> (lift $ runEitherT e1) >> e2
00:00:40 <wz1000> which is equivalent to do {_ <- lift $ runEitherT e1; e2}
00:00:52 <jle`> i don't think that typechecks either
00:01:05 <wz1000> why?
00:01:13 <jle`> :t lift
00:01:15 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
00:01:22 <jle`> :t runExceptT
00:01:23 <lambdabot> ExceptT e m a -> m (Either e a)
00:01:30 <jle`> :t lift . runExceptT
00:01:32 <lambdabot> (Monad m, MonadTrans t) => ExceptT e m a -> t m (Either e a)
00:01:39 <jle`> oh huh
00:01:41 <jle`> neat
00:01:54 <jle`> nvm :)
00:01:58 <wz1000> :t void . lift . runExceptT
00:02:00 <lambdabot> (Functor (t m), Monad m, MonadTrans t) => ExceptT e m a -> t m ()
00:02:45 <jle`> i am a fan of this
00:03:24 <jle`> originally i was going to suggest (e1 *> empty) <|> e2
00:04:06 <jle`> but that doesn't work for all e's
00:04:15 <jle`> and is admittedly kind of silly on hindsight
00:12:45 * hackagebot tcp-streams-openssl 1.0.1.0 – Tcp streams using openssl for tls support. – https://hackage.haskell.org/package/tcp-streams-openssl
00:12:45 * hackagebot tcp-streams 1.0.1.0 – One stop solution for tcp client and server with tls support. – https://hackage.haskell.org/package/tcp-streams
00:22:05 * slack1256 loves how easy is ghcjs to install on nixos
00:44:05 * hackagebot fast-mult 0.1.0.0 – Numeric type with asymptotically faster multiplications. – https://hackage.haskell.org/package/fast-mult
00:51:36 <rain1> helo
00:52:32 <Cale> Hello
00:54:48 <slack1256> hello
00:58:32 <rain1> If ound this partial evaluator for haskell
00:58:39 <rain1> http://www.cse.chalmers.se/~rjmh/PECourse/Exercises/PE.html
01:00:03 <rain1> http://imgur.com/a/Oa6U1 this whole idea seemed interesting but if we use haskell then wouldn't the compiler produce haskkell code? how do we make a proper compiler with peval or is that not possible (unless we write mix in x86 like pictured here.. which is not possible)
01:02:10 <ehubinette> Is there a way to use the default if-then-else syntax with -XRebindableSyntax active? 
01:02:50 <ehubinette> Workarounds I can do myself, but the mixfix is nice.
01:03:32 <merijn> ehubinette: Anyway, can you paste an example of that sorta thing in your code? I know plenty of tricks to make things cleaner, but it's hard to recommend one in general
01:03:54 <wz1000> ehubinette: define ifThenElse? ifThenElse = flip bool
01:04:17 <merijn> wz1000: Well, he mentioned the mixfix syntax, which sadly Haskell doesn't support
01:04:26 <lyxia> it takes more than flip bool
01:04:28 <merijn> I'd love mixfix in haskell
01:04:51 <lyxia> With RebindableSyntax, if/then/else is defined in terms of whatever ifThenElse is in scope
01:04:54 <wz1000> merijn: with -XRebindableSyntax, GHC calls ifThenElse whenever you use if .. then ..else
01:06:17 <ehubinette> Aah, is that so? So if I define my own ifThenElse (which might be possible to make linear as well which will be a huge plus), it'll automagically be called when I use the syntactic mixfix?
01:06:23 <wz1000> yes
01:06:26 <ehubinette> dang
01:07:02 <ehubinette> Thanks!
01:07:07 <wz1000> I think it is defined somewhere in base too, but can't remember where
01:07:17 <wz1000> hoogle doesn't turn up anything
01:08:01 <ehubinette> Yeah, I have looked for it as well but can't find it. 
01:09:06 <wz1000> but it is pretty easy to define
01:10:11 <ehubinette> yeh. Thanks a bunch wz1000 merijn lyxia :)
01:19:13 <[exa]> mixfix looks cool, it could be easily generalized to operators (on steroids)
01:19:43 <merijn> [exa]: mixfix IS operators on steroids
01:22:55 <wz1000> It becomes difficult disambiguate (a x b y c) between (a_b_c x y) and (((a x) b) y) c)
01:23:14 <merijn> wz1000: Sure, but it makes nice EDSLs super easy
01:23:21 <wz1000> you need smart tooling to do the syntax highlighting for you.
01:29:50 <[exa]> wz1000: not that it wouldn't already be hard with custom operators :D
01:30:44 <[exa]> I actually think about implementing that just for practice
01:30:46 <wz1000> operators can only be made up of symbols, not alpha nums, so it is pretty easy to disambiguate
01:33:44 <ertes-w> ehlo
01:39:09 <[exa]> Hm. Would n-ary operators (like ternary ?: from C) need left/right fixity declarations? (imho not)
01:39:36 <quchen> Agda has mixfix. It’s sometimes useful, but often very hard to read.
01:40:29 <[exa]> well I can see mixfix being abused for named arguments and so
01:40:46 <[exa]> like in python's kwargs** but wrong
01:43:28 <davr0s> GADTs, what can they do beyond a 'tagged-union' ,
01:44:05 <davr0s> i'm curious to see a use case, perhaps alongside equivalent-ish C-like use case
01:44:13 <rain1> tagged-union describes regular ADTs well
01:44:31 <rain1> GADTs add to this by letting you make the result type different, depending on th etag
01:44:36 <davr0s> (e.g. I can understand a 'tagged union' by knowing 'it's a cleanup of this pattern in C..'
01:45:14 <davr0s> i'm aware there's things that you can do in C that dont fit into it's own type system well, so I can certainly see 'why type systems are an ongoing area of expansion..'
01:46:39 <ertes-w> @let p --> x = if p then Just x else Nothing; mx ? y = maybe y id mx; infixr 1 ?; infix 2 -->
01:46:41 <lambdabot>  Defined.
01:46:59 <ertes-w> > even 3 --> "even" ? odd 3 --> "odd" ? "math is broken"
01:47:02 <lambdabot>  "odd"
01:47:22 <ertes-w> [exa]: i prefer doing mixfix in terms of infix operators, because it's a lot clearer how it's parsed and what it means
01:48:47 <ertes-w> and regarding python's **kwargs: that's really just passing dictionaries in disguise, but we can do better in haskell, because we can actually specify what keys we take, even if the key space is huge/infinite
01:51:18 <ertes-w> you might be interested in the dependent-sum and dependent-map libraries in this context
01:53:59 <merijn> davr0s: The difference between GADTs and ADTs is that GADTs can prevent some constructors from occurring for some type parameters
01:55:08 <merijn> davr0s: The classical example is a simple Expr datatype like "data Expr a = IntLiteral Int | BoolLiteral Bool | Compare (Expr a) (Expr a) | IfThenElse (Expr Bool) (Expr a) (Expr a)"
01:55:32 <merijn> davr0s: You would like "Expr Bool" to be an expression that computes a Bool so that IfThenElse makes sense
01:55:49 <ertes-w> @let data Key :: * -> * where IntKey :: Key Int; CharKey :: Key Char deriving (Eq, Ord, Show)
01:55:51 <lambdabot>  .L.hs:172:15: error:
01:55:51 <lambdabot>      • Can't make a derived instance of ‘Eq (Key a)’:
01:55:51 <lambdabot>          Constructor ‘IntKey’ has existentials or constraints in its type
01:56:03 <ertes-w> @let data Key :: * -> * where IntKey :: Key Int; CharKey :: Key Char
01:56:04 <lambdabot>  Defined.
01:56:07 <merijn> davr0s: But nothing can stop you from doing, e.g. "IntLiteral 5 :: Expr Int", since 'IntLiteral 5' has 'a' as phantom type
01:56:26 <merijn> davr0s: Eh "IntLiteral 5 :: Expr Bool", I mean
01:56:32 <merijn> davr0s: But that's clearly not what you wanted
01:57:20 <davr0s> is that a more elegant way to do something which could be emulated with multiple ADTs
01:57:27 <merijn> davr0s: With GADTs we can say "IntLiterall :: Int -> Expr Int", that is, despite 'a' being a phantom (not occuring in the IntLiteral constructor) we can specify that, nevertheless, 'a' MUST be Int for IntLiteral
01:57:46 <davr0s> like splitting term/ statement
01:57:58 <merijn> davr0s: No, for example with the GADT approach you can write "eval :: Expr a -> a"
01:58:05 <davr0s> i got the impresion there might be something more fancy going on
01:58:27 <davr0s> maybe something much more elaborate wiht the generation/interpretaion of the 'tag'
01:58:28 <merijn> davr0s: Without GADTs the best you could do "eval :: Expr a -> Either Error a", since the 'a' in Expr might not actually be "right"
01:58:58 <ertes-w> @def data PersonKey :: * -> * where Name :: PersonKey String; Location :: PersonKey String; Age :: PersonKey Integer
01:59:00 <lambdabot>  Defined.
01:59:18 <ertes-w> @let type Person = forall a. PersonKey a -> a
01:59:20 <lambdabot>  Defined.
01:59:40 <merijn> davr0s: The wikibook has a pretty decent step-by-step walkthrough of the Expr example: https://en.wikibooks.org/wiki/Haskell/GADT
02:01:16 <ertes-w> > let f :: Person -> String; f person = concat [person Name, " @ ", person Location, ", age ", show (person Age)] in f (\k -> case k of Name -> "ertes"; Location -> "somewhere"; Age -> -12)
02:01:19 <lambdabot>  "ertes @ somewhere, age -12"
02:02:56 <ertes-w> and of course you can now do:  type PersonT f = forall a. PersonKey a -> f a
02:03:07 <ertes-w> then Person ≃ PersonT Identity
02:03:18 <ertes-w> and python's **kwargs would be PersonT Maybe
02:04:48 <ertes-w> it even has O(1) lookup, if you just use 'case' like here =)
02:07:02 <kuribas> To compile for windows in linux, would it be easier to use wine than build a cross-compiler?
02:07:20 <merijn> kuribas: I'd just download a VM and install windows on it
02:07:25 <merijn> kuribas: I wouldn't trust wine, tbh
02:07:33 <kuribas> what's wrong with it?
02:08:29 <Logio> some things might not be implemented
02:08:40 <merijn> kuribas: Wine is not windows, there's bugs/incompatibilities, etc. I'd never be able to trust that a bug in my windows binary is actually a bug in my code or in wine's code
02:08:57 <merijn> kuribas: So much easier to just compile on windows directly and eliminate all those issues
02:09:06 <kuribas> merijn: I would only wine to compile though, not use any of the libraries.
02:09:10 <merijn> I don't understand why people seem to avoid VMs so much
02:09:26 <kuribas> I actually have a windows partition...
02:09:36 <kuribas> But I never use it for programming...
02:09:46 <merijn> kuribas: Well, that involves rebooting and I can understand why people don't wanna reboot in their workflow
02:09:54 <kuribas> yes, right
02:10:18 <merijn> I've used wine in the past, but it was super fiddly
02:10:54 <kuribas> isn't that for apps developped on windows though?  If I compile with mingw it should be fine?
02:11:15 <merijn> kuribas: Maybe, maybe not, feel free to find out for me and let me know :)
02:11:22 <kuribas> merijn: right, I will
02:11:39 <kuribas> I am trying to cross compile 8.0.2 now (8.2 was a failure)
02:11:57 <kuribas> I wonder how the cross compiler handles template haskell...
02:12:27 <merijn> kuribas: Basically, the reason not too (for me) is: I've never met anyone who's life *improved* after introducing cross-compilation. But I've seen plenty induce hair pulling stress :)
02:12:43 <[exa]> kuribas: ghc bootstraps itself when doing compilation?
02:12:44 <merijn> kuribas: Template Haskell and cross compilation is a WHOLE other can of worms
02:12:57 <merijn> Nobody even really knows what TH is *supposed* to do during cross-compilation
02:13:01 <kuribas> merijn: haha, you might be right :)
02:13:15 <merijn> Which makes it rather hard to argue whether what TH is doing is right or wrong
02:14:10 <cocreature> cross-compilation is useful if compiling on the target system is just not an option because it’s too slow, e.g., a raspberry pi
02:14:34 <cocreature> it’s not worth the trouble if compiling on the target system is a realistic option
02:14:48 <merijn> cocreature: Sure, but that doesn't invalidate the claim that cross-compilation never improves anyone's life :p
02:14:54 <merijn> cocreature: It just means sometimes you can't avoid it
02:15:20 <cocreature> sure
02:15:34 <kuribas> cross compilation with gcc seems much less painful.
02:15:58 <merijn> kuribas: Only because thousands have died to make it bearable :)
02:22:10 <Shockk> hello, I have a quick question, and it's not strictly related to Haskell, but I have a reason for asking it here
02:22:33 <rain1> gcc cross compilation is still suffering compared to golang
02:22:33 <rain1> they just made it completely trivial
02:22:33 <kuribas> I even managed to setup a cross-compiler for OSX
02:22:33 <kuribas> unfortunately template haskell is common for lenses, etc...
02:22:34 <Aruro> crosscompilation+emulator?
02:22:34 <Aruro> or even compiling in emulator, there is ghc for arm
02:22:34 <cocreature> emulators are slow
02:22:46 <Xe> Shockk: speak
02:23:29 <Shockk> from a previous question that I asked in here a while ago, I know that the way ghc handles parsing is that it does an initial parser pass, before operator precedences are known, and then it does some second stage after that, to fix up the syntax tree once precedences are known
02:23:43 <Shockk> does anyone know what that first parser stage might be called? as opposed to just "parser"
02:24:26 <ertes-w> Shockk: "stage 1"?
02:24:29 <ertes-w> "phase 1"?
02:25:00 <ertes-w> "figure-out-precedences-and-associativity-phase"?
02:25:49 <Shockk> lol
02:26:00 <Shockk> hmm
02:26:29 <Shockk> I was meaning at a higher level, in compiler theory, and ertes-w that's a bit of a mouthful unfortunately
02:26:56 <rain1> lexing and then parsing
02:27:36 <Shockk> rain1: but parsing is split into different stages, in order to handle the fact that operator precedences are unknown at first
02:27:47 <rain1> it's usually one stag
02:27:49 <rain1> stage
02:28:19 <rain1> i read that C++ uses multiple tages because it generates a parse DAG instead of a parse tree
02:28:25 <Shockk> not in ghc from what I heard after asking about it in here a while ago
02:28:53 <ertes-w> Shockk: stages are actually fairly common terminology, but i don't think there is a special name specifically for the way haskell is parsed…  you might call it a meta stage, because it's a parser run to figure out how to actually parse the code
02:29:10 <Shockk> ertes-w: ah I see
02:29:52 <ertes-w> Shockk: alternatively dive into the GHC source code and find the identifier name of the stage 1 parser, or perhaps look at the comments surrounding it
02:30:08 <Shockk> ertes-w: that's probably a good idea
02:30:12 <Aruro> Shockk: lexical analysis?
02:30:13 <ertes-w> i hear that GHC source is easy enough to read, if you don't mind SPJ's PHP style
02:30:27 <Shockk> zebrah: are you the zebrah that I know from elsewhere?
02:35:03 <kuribas> merijn: that's actually a good argument for me not to use microlens-th, or lens in my libraries.
02:35:22 <kuribas> merijn: And define the lenses by hand instead.
02:35:50 <Shockk> hm okay, thanks for the answers ertes-w 
02:36:06 <kuribas> PHP style?
02:36:20 <kuribas> :-O
02:37:56 <cocreature> I’m not sure I would call using semicolons in do notation PHP style
02:39:23 <kuribas> Is it possible to make ghc output C files, and compile those?
02:39:33 <merijn> kuribas: Not really
02:40:02 <merijn> kuribas: There's the unregisterised build of GHC which can enable the output of C, but it's not in the default build of GHC and only used to bootstrap new architectures
02:40:24 <merijn> kuribas: But that almost certainly involves a bunch of manual fixing of the generated C code and really shitty performance
02:40:40 <[exa]> kuribas: there's no tail call in C
02:40:42 <merijn> (Since it's main purpose is bootstrapping and you only have to do that once per architecture)
02:40:55 <kuribas> hm okay
02:43:28 <Aruro> there used to be option to output c code
02:43:41 <Aruro> around ghc 6 or smth
02:43:48 <merijn> Aruro: It's been gone for nearly a decade
02:52:46 <davr0s> is a gadt acheiveale as a combination of an ADT with a typeclass for node construction (instancing a constructor function for different nodes, instead of construting the nodes directly)
02:53:03 <merijn> davr0s: No
02:55:22 <phadej> you can "kind-of" have GADTs via ADTs, if you have away to encode type-equality
02:55:22 <phadej> http://futurice.com/blog/more-gadts-in-purescript
02:55:49 <phadej> e.g. purescript doesn't have GADTs, but you can fake them
02:56:00 <phadej> though it's quite inconvenient to work with them
02:56:10 <phadej> ... with the faked variant
02:56:12 <ertes-w> kuribas: class C a where { …; …; … }
02:56:36 <ertes-w> do { …; …; … }
02:56:45 <[exa]> davr0s: the extra expressive power is described here https://www.researchgate.net/publication/213886551_Translating_Generalized_Algebraic_Data_Types_to_System_F
02:56:57 <kuribas> ertes-w: that's not to bad
02:57:40 <ertes-w> kuribas: it's a matter of taste…  personally i don't like the redundant brackets, because they just decrease the signal/noise ratio
02:57:58 <Aruro> ertes-w: is it aimed at one liners?
02:59:06 <ertes-w> Aruro: you can write one-liners, but you find regular layout code with extra brackets and semicolons in GHC
02:59:29 <Aruro> hm, then strage.
03:00:28 <ertes-w> i guess some people find the extra redundancy helpful, but it's probably just a habit in this case
03:00:57 <ertes-w> some people find visual basic easy to read after all
03:01:06 <ertes-w> $or::$PHP
03:06:02 <Aruro> on hackage matrix OK (no-ip) means cabal failed to resolve dependencies?
03:11:28 <xormor> I made a weight index calculating program, first in C++ and then I wrote it in Haskell.
03:19:14 <lyxia> orzo: it seems you are not the only one with your issue, but there has been no response about it. https://github.com/jwiegley/async-pool/issues/2#issuecomment-217886750
03:20:26 <xormor> weightindex weightinkg heightinmeters = (weightinkg) / (heightinmeters * heightinmeters)
03:21:39 <Aruro> xormor: and?
03:22:58 <phadej> Aruro: yes, no-ip is "no install-plan"
03:25:48 <Aruro> would be nice if matrix could show all packages which are OK with ghc 8.2
03:27:54 <phadej> If you ask nicely, hvr might run magic SQL query :)
03:28:17 <phadej> Aruro: yet, behold: https://matrix.hackage.haskell.org/package/servant e.g. servant-0.2.2 (i.e. ancient version!) is accidentally compatible with GHC-8.2 too
03:28:50 <phadej> I'm quite sure there are other such packages where some very old (and simple) version accidentally compiles with GHC-8.2 :)
03:29:09 <Aruro> i enjoy looking at ansi-terminal results :)
03:30:21 <Aruro> and lens is blazing fast as always
03:30:46 <phadej> Aruro: but anyhow, hvr planed a feature "package rating", where some letter (I don't remember details) would essentially say "Have working build-plan for latest GHC"
03:31:16 <Aruro> useful
03:33:04 <phadej> ... but hvr has lot's of stuff to do
03:38:27 <phadej> Aruro: but anyhow, lens wasn't "blazing fast", it (and other edwardks' packages) were GHC-8.2 compatible for a while already. Thanks to Ryan
04:12:09 <black0range> Hello, I'm playing around a bit with pattern synonyms and I tried to make a test like this http://lpaste.net/357213 however I just get a "not in scope: data constructor ':|>'" Have I missunderstood something? 
04:13:41 <ertes-w> black0range: you're not actually using pattern synonyms there, are you?  and the way you use ViewPatterns is like this:  test (viewl -> EmptyL) = …#
04:14:55 <black0range> How do i use this (:|>) thingie then? 
04:15:59 <ertes-w> black0range: what is it supposed to be?  there are ViewL and ViewR constructors named (:<) and (:>) respectively
04:16:12 <ertes-w> test (viewl -> x :< xs) = …
04:17:02 <orion> Has anyone attmpted to build cabal-install 1.24.0.2 with GHC 8.2.1? I am having difficulty: https://gist.github.com/centromere/73af6d22bfa5e4d8694d2cfea01992bf
04:17:09 <ertes-w> but again: nothing to do with PatternSynonyms yet…  you could now define (pattern (:|>) = (:>)) at the top level, then (:|>) would be equivalent to (:>)
04:17:13 <black0range> ertes-w: http://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html
04:17:30 <ertes-w> oh
04:17:44 <ertes-w> what are "bundled patterns"?
04:17:57 <black0range> ertes-w: no idea :D 
04:18:07 <black0range> Trying to understand them right now :)
04:18:27 <mantasg> Hi guys. Is it possible to exclude a certain library when generating Haddock docs?
04:19:31 <cocreature> orion: have you tried allow-newer? I don’t think a whole lot changed in newer versions of process so that might be fine
04:19:49 <orion> cocreature: To bootstrap.sh?
04:20:02 <cocreature> oh bootstrap.sh, no idea about that. I never tried bootstrapping cabal
04:20:18 <cocreature> I got my first version from the package manager and have been copying them around ever since :)
04:20:26 <merijn> orion: What's the difficulty?
04:20:45 <orion> merijn: cabal-install 1.24.0.2 with GHC 8.2.1 does not bootstrap: https://gist.github.com/centromere/73af6d22bfa5e4d8694d2cfea01992bf
04:21:16 <merijn> orion: Have you installed Cabal already?
04:21:31 <merijn> oh, wait that is Cabal
04:21:45 <merijn> orion: Note Cabal and cabal-install aren't the same thing
04:22:16 <orion> merijn: cabal-install's bootstrap.sh script is attempting to configure Cabal.
04:22:32 <merijn> orion: I've always first installed Cabal by hand THEN installed cabal-install
04:23:03 <orion> merijn: Is that because the bootstrap script is fundamentally broken?
04:23:20 <merijn> orion: No, I've used bootstrap.sh to install all the other cabal-install dependencies
04:23:23 <merijn> orion: Which OS?
04:23:35 <orion> FreeBSD 11.0-RELEASE
04:24:18 <cocreature> is _Cabal_ 1.24 even supposed supposed to be installable using 8.2?
04:24:29 <cocreature> I thought Cabal was tied to GHC
04:24:47 <cocreature> and Cabal 2.0 is the one accompanying 8.2
04:24:51 <merijn> orion: There's a bug in bootstrap.sh that made it not work on an old CentOS for me, but that had a different error, afaik
04:25:38 <orion> cocreature: If that's the case, then 8.2.1 is not very useful yet.
04:26:16 <cocreature> orion: I think you are overestimating how many people run the bootstrap script :)
04:26:31 <merijn> cocreature: I do, every release >.<
04:26:40 <cocreature> merijn: honest question: why?
04:26:57 <cocreature> I’ve been compiling new cabal versions using old cabal versions for years
04:27:11 <merijn> cocreature: Because I usually just nuke .cabal and .ghc if I switch GHC versions
04:27:21 <orion> this ^
04:27:27 <merijn> cocreature: To get rid of outdated packages taking up disk space
04:27:57 <cocreature> merijn: ah fair enough. I tend to use multiple ghc versions side by side for some time after a new release
04:28:02 <cocreature> so nuking is not an option anyway
04:28:35 <merijn> cocreature: I use multiple versions too, but I generally have one "main" version as default first in my path and when I update that one I usually nuke everything since I only use the others incidentally to test things
04:31:09 <ertes-w> black0range: apparently what makes pattern synonyms "bundled" is the COMPLETE pragma in that you can say what constitutes an exhaustive pattern match
04:31:29 <ertes-w> black0range: along with the way they are exported, but that's probably just a documentation-related thing
04:32:00 <ertes-w> however, my GHC 8.0.2 does not recognise COMPLETE, so i get inexhaustiveness warnings
04:33:53 <black0range> ertes-w: So how do I use the pattern synonym thingie?
04:39:17 <ertes-w> black0range: just the way you wrote it
04:39:30 <ertes-w> black0range: if it doesn't work, make sure you have the right version of 'containers'
04:39:49 <ertes-w> i didn't know about those synonyms, so it must be rather new =)
04:40:42 <ertes-w> as far as i can tell you need at least containers 0.5.10.2
04:42:22 <black0range> ertes-w: Oh yeah I had a older one installed... Thanks! 
04:56:21 * hackagebot temporary 1.2.1.1 – Portable temporary file and directory support – https://hackage.haskell.org/package/temporary
05:12:14 <mantasg> Hi guys. Is it possible to exclude a certain library when generating Haddock docs? I'm struggling with the problem described here: https://www.reddit.com/r/haskellquestions/comments/6pnk6g/excluding_library_from_haddock_docs/
05:16:16 <Cale> How are you running Haddock?
05:19:49 <angerman> assuming I have f :: A -> B -> (A, B), and [B], and I want to obtain (A, [B]), (e.g. iterating over a list while threading a state) what combinator am I looking for?
05:19:51 <mantasg> Cale: stack haddock
05:19:58 <Cale> mantasg: If Stack is running haddock for you, I'm not sure... it's got some commandline flags to control a few things, but nothing that looks all that fine-grained
05:20:28 <mantasg> Well yes, that's true
05:20:39 <Cale> :t mapAccumL
05:20:40 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
05:20:47 <Cale> maybe?
05:22:05 <angerman> Cale: that looks quite right. Hmm now why didn't I find that with hoogle? must practice my hoogle-fu
05:22:53 <Cale> mantasg: haddock itself has a --hide=MODULE flag you can use
05:23:27 <mantasg> Cale, thanks I'll check it out. 
05:23:45 <mantasg> I believe there's a way to pass params to haddock from stack
05:30:38 <ertes-w> angerman: alternatively (State A) and 'traverse' (assuming that A is your state type)
05:31:02 <angerman> ertes-w: I'm always a bit weary of State :/
05:31:24 <EvanR> starve the beast
05:31:55 <ertes-w> angerman: personally i prefer State over mapAccum*
05:33:03 <angerman> ertes-w: hmm...
05:33:06 <EvanR> @src mapAccumL
05:33:06 <lambdabot> mapAccumL _ s []     = (s, [])
05:33:06 <lambdabot> mapAccumL f s (x:xs) = (s'',y:ys)
05:33:06 <lambdabot>    where (s', y ) = f s x
05:33:06 <lambdabot>          (s'',ys) = mapAccumL f s' xs
05:33:40 <f-a> is there a foldable which is not a traversable?
05:33:50 <f-a> on haddock the istances look the same!
05:34:04 <f-a> *the instances list
05:34:14 <ertes-w> f-a: Set, i think
05:35:01 <EvanR> is mapAccumL "sufficiently lazy" ?
05:35:01 <ertes-w> angerman: my reasoning is that i prefer generalised patterns over special-case combinators, particularly because the former tend to have easy to explain semantics, while combinators get harder to explain the more special they get
05:35:12 <f-a> thanks, ertes-w 
05:36:17 <EvanR> seems like it could gain from a foldl' style seq of the state
05:36:26 <Aruro> why ghc does not link agains /usr/lib/ but tries /usr/lib/gcc? problem with libtinfo.so
05:36:41 <ertes-w> f-a: almost everything that has element extraction can be made Foldable, because it barely has any meaningful laws
05:36:43 <bvad> Aruro: Using arch?
05:36:48 <Aruro> yeah :(
05:37:26 <f-a> ertes-w: yeah I realise now the "left to right" specification is more difficult to have 
05:37:30 <Aruro> im gonna make portable 3.5 floppy drive with all libs and ghc :D
05:38:23 <ertes-w> f-a: "left to right" doesn't really mean anything
05:38:41 <ertes-w> it's a list notion that doesn't generalise well
05:39:21 <f-a> still you can't have it in a Set, right? I mean, that's the reason why a set cannot be a Traversable, right?
05:40:01 <ertes-w> f-a: there is a technical reason: Set would require Ord for the elements, which Traversable does not allow
05:40:16 <ertes-w> while you can get a Set's elements without Ord, so Foldable works
05:40:34 <f-a> I was just going to ask, an ordered set should qualify for Traversable
05:40:35 <EvanR> Aruro: just make a special decompressor which is quite large!
05:40:35 <quchen> I still wonder why there is no traverseSet :: … => Set (t a) -> t (Set a)
05:40:37 <f-a> *?
05:40:47 <ertes-w> f-a: there is also a law that forbids Set to be Traversable, even if it could support constraints
05:41:01 <ertes-w> f-a: traversals must be structure-preserving, so you must never lose elements
05:41:03 <f-a> quchen: from which element would traverse start?
05:41:23 <f-a> *traverseSet
05:41:26 <quchen> f-a: Like toSet . traverse f . fromSet
05:41:32 <f-a> I see
05:41:58 <quchen> toList/fromList they’re called, I think.
05:42:03 <butterthebuddha> How do I print something in haskell?
05:42:13 <quchen> :t print
05:42:14 <lambdabot> Show a => a -> IO ()
05:42:25 <quchen> main = print 1234
05:42:55 <butterthebuddha> <no location info>: error:
05:42:55 <butterthebuddha>     output was redirected with -o, but no output will be generated
05:42:55 <butterthebuddha> because there is no Main module.
05:43:00 <butterthebuddha> Getting that error when compiling :/
05:43:02 <f-a> ertes-w: so an ordered bag *would* qualify?
05:43:11 <ertes-w> f-a: as what?
05:43:12 <Aruro> where exactly in gcc folder lg.gold expects a libtinfo to be found? 
05:43:33 <f-a> as traversable, ertes-w 
05:44:31 <f-a> butterthebuddha: you need to put a main in your module
05:44:45 <f-a> main = print 10
05:44:46 <butterthebuddha> I have a main =
05:44:56 <f-a> what's the name of the module?
05:45:00 <f-a> it should be module Main
05:45:02 <f-a> or nothing
05:45:07 <f-a> not module Something.Else
05:45:43 <ertes-w> f-a: not sure…  check the laws
05:46:35 <Aruro> is it possible to see exact command cabal sends to gcc during linking?
05:46:51 <ertes-w> f-a: i'm not sure to what extent the laws would even make sense under constraints
05:48:06 <ertes-w> f-a: intuitively i'd say: yes, could work
05:48:21 <f-a> thanks ertes-w 
05:56:41 <butterthebuddha> https://pastebin.com/wVZiQnm9
05:56:56 <butterthebuddha> Sorry for the horrible syntax highlighting but ghc refuses to compile print (skips [])
05:57:02 <butterthebuddha> non-empty lists work
05:57:49 <ongy> what's your compile error?
05:57:50 <f-a> butterthebuddha: you can paste in friendly http://lpaste.net/new/haskell
05:58:14 <f-a> butterthebuddha: you need a *where* before last line
05:58:20 <ongy> I'd guess you have some problem with GHC not deciding on a type.
05:58:28 <Cale> butterthebuddha: Is lpaste down?
05:58:56 <butterthebuddha> https://pastebin.com/4YFUgHyn
05:58:59 <butterthebuddha> that's the compile error
05:59:19 <butterthebuddha> Cale: it was for me a moment ago, but now it's seemingly working. I'll repost the code on lpaste
05:59:58 <ongy> butterthebuddha: ghc doesn't know what type to use, so if you did ([] :: (Int, String)) to give  it a hint, things should work (may need ScopedTypeVariables, not sure)
06:00:24 <butterthebuddha> For which declaration ongy?
06:00:31 <akfp> > fmap fold . sequenceA
06:00:32 <ongy> erm, [(Integer, String)]
06:00:33 <lambdabot>  error:
06:00:34 <lambdabot>      • No instance for (Typeable f0)
06:00:34 <lambdabot>          arising from a use of ‘show_M53048868751279673412215’
06:00:52 <butterthebuddha> Getting a 503 on lpaste
06:01:02 <ongy> butterthebuddha: you sayd `print (skips [])` doesn't compile. it's the [] there
06:01:21 <butterthebuddha> I need the type to be polymorphic tho
06:01:55 <ongy> it's fine for the function declaration. But when it's compiled, GHC want's to have a specific type (for the literal). Which it can't figure out
06:02:05 <butterthebuddha> But it's just []
06:02:10 <Tuplanolla> > show ([] :: [Int])
06:02:10 <Tuplanolla> > show ([] :: [Char])
06:02:12 <ongy> what's the type of []?
06:02:12 <lambdabot>  "[]"
06:02:12 <lambdabot>  "\"\""
06:02:16 <ongy> > show []
06:02:18 <lambdabot>  "[]"
06:02:34 <ongy> thanks lambdabot -.-
06:02:48 <Cale> lambdabot has ExtendedDefaultRules turned on
06:03:48 * hackagebot SSTG 0.1.0.5 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
06:04:14 <Cale> butterthebuddha: Basically the problem is that in order to have an instance Show [t], you need an instance Show t, and when t is ambiguous, the compiler gets stuck.
06:04:35 <Cale> butterthebuddha: There's an extension you can enable to make it more aggressive about defaulting ambiguous types to () or something.
06:04:55 <Cale> Or you can just write a type signature explicitly
06:05:18 <butterthebuddha> Cale: something like [] :: String?
06:05:28 <Cale> Yeah
06:06:11 <Cale> If you want String, you might just go with ""
06:06:21 <butterthebuddha> Yaay, that works!
06:06:56 <butterthebuddha> I like how ghc is smart enough to know that skips' will never actually get an empty string
06:07:00 <butterthebuddha> or empty list*
06:10:02 <ertes-w> butterthebuddha: BTW, 'sec' is predefined as 'snd'
06:13:36 <Aruro> what is best way to keep state in servant? like input history f.e.
06:15:06 <quchen> You could just use an IORef.
06:15:13 <Aruro> or maybe there is already a web terminal solution
06:15:16 <quchen> That is probably the simplest way.
06:15:16 <Aruro> i do like that now
06:15:37 <quchen> You can also introduce a StateT.
06:15:53 <quchen> But that’s more complicated, and doesn’t really improve anything.
06:16:05 <Cale> You could also introduce a database backend
06:16:14 <Aruro> yeah ok IORef it is :)
06:16:32 <Aruro> database dont want cause of deps, wanna make it simple run and forget
06:17:22 <Aruro> i have a form and my server remembers input of the user, kinda very crude web based terminal. im sure there are better ways
06:19:10 <bvad> Aruro: sqlite is also very easy to use if you want something a bit more involved at some point :) 
06:19:50 <Aruro> my firefox on mac os crashed because of sqlite problem :D, though i agree
06:20:35 <Aruro> does threepenny gui helps in task of making browser terminal?
06:26:52 <vktec> > ((+) 3 . (+)) 3 4
06:26:54 <lambdabot>  error:
06:26:55 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M250542070090...
06:26:55 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:27:24 <vktec> How can I get that to work? I know why it's not working, I just don't know how to fix it
06:29:08 <vktec> (That's just an example. I want (c -> d) -> (a -> b -> c) -> a -> b -> c)
06:30:14 <lyxia> vktec: How are that expression and type of yours related?
06:30:30 <butterthebuddha> How can I use filter but on 3 elements at a time?
06:30:51 <lyxia> vktec: did you mean "-> d" at the end rather than "-> c"
06:31:24 <lyxia> @djinn  (c -> d) -> (a -> b -> c) -> a -> b -> d
06:31:24 <lambdabot> f a b c d = a (b c d)
06:33:12 <Aruro> :t (+) 3 . (+)
06:33:14 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
06:35:12 <vktec> lyxia: Yes, I did
06:37:05 <vktec> Is providing the arguments explicitly the only way of doing it?
06:37:53 <merijn> butterthebuddha: Group into tuples of size 3 and filter that?
06:38:39 <phadej> vktec: yes, pointfree is pointless in that case
06:38:54 <mnoonan> butterthebuddha, that seems like kind of an odd request. what exactly do you want to do?
06:40:00 <mlehmk> :t (+).(3+)
06:40:02 <lambdabot> Num a => a -> a -> a
06:40:17 <mlehmk> kinda makes sense... somehow
06:40:52 <mlehmk> it is not the same
06:43:16 <vktec> phadej: Had to look up pointfree, hehe
06:43:42 <vktec> Thanks for the help! I'm still trying to get my head around FP, but it's enjoyable so far
06:43:53 <mlehmk> lambdabot can transform lambda to pointfree with @pl
06:44:17 <mlehmk> @pl \x y -> 3 + x + y
06:44:18 <lambdabot> (+) . (3 +)
06:44:25 <Aruro> vktec: you did not look close to the type of (.) it is there where stuff like (Num (a->a)) pops up
06:44:34 <Aruro> :t (.)
06:44:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:44:53 <mlehmk> :t ((3+).).(+)
06:44:54 <lambdabot> Num c => c -> c -> c
06:44:56 <butterthebuddha> mnoonan: https://imgur.com/a/79RgC
06:45:01 <butterthebuddha> Trying to do that exercise
06:45:01 <mlehmk> I just don't understand why
06:45:03 <Aruro> :t ((+3) . (+2)) 
06:45:04 <lambdabot> Num c => c -> c
06:45:18 <Aruro> problem is that one takes 2 args and other just 1
06:46:12 <Aruro> vktec: btw people dont use pointfree in haskell much
06:46:46 <vktec> Oh? Why not? It seems like a neat idea, if a little confusing at first
06:46:49 <Aruro> mlehmk: your examples are cool :)
06:47:07 <Aruro> vktec: its indeed good from start, but then gives more problems than wins
06:47:19 <bennofs> Well you use it when it makes things clearer
06:47:25 <bennofs> and you don't use it when it makes things harder to understabnd
06:47:43 <Aruro> bennofs: clearer usually self evident one argument cases :)
06:47:48 <bennofs> I often use a middle form, like map foo . sort . blala
06:47:58 <vktec> Fair enough
06:48:03 <mnoonan> butterthebuddha: maybe start like "localMaxima xs = case xs of x:etc@(y:z:_) -> [fill in]  _ -> [fill in]"
06:49:16 * hackagebot io-streams 1.4.1.0 – Simple, composable, and easy-to-use stream I/O – https://hackage.haskell.org/package/io-streams
06:49:52 <mlehmk> Aruro, it's by lambdabot using @pl mostly
06:50:24 <mlehmk> pointless is not always good, especially if complicated things happen like ((3+).).(+) which are harder to read than \x y -> 3 + x + y
06:50:33 <Aruro> vktec: probaly :t command is most useful in haskell :)
06:50:54 <vktec> Yeah, I've found that to be the case so far!
06:51:03 <mlehmk> or (+).(3+)
06:51:18 <Aruro> vktec: :t+:i can solve a lot :)
06:51:26 <vktec> Haskell type signatures are the most useful type signatures I've ever seen
06:51:44 <vktec> You can guess at what a function does just from them alone
06:52:35 <Aruro> im missing self documenting in ghci, like in emacs
06:52:39 <mlehmk> ((+).(3+)) x y becomes (+)((3+) x) y
06:52:57 <Aruro> funny enought there are docs in sources, just not used in ghci
06:53:42 <bvad> Aruro: Yeah I somewhat agree, though running your own hoogle server and using that isn't half bad
06:53:55 <mlehmk> because (f . g) x is f(g x)
06:53:55 <Aruro> yeah i do that
06:54:10 <c_wraith> at some point, there was a suggestion to include haddock sources in .hi files so that ghci could get at them
06:54:16 <mlehmk> functions in Haskell take a single argument only
06:54:19 <c_wraith> I wonder what happened to that idea
06:54:52 <Aruro> mlehmk: seems thats how scary constraint Num (a->a) comes to life
06:55:14 <mlehmk> I don't even know how to fulfill a Num (a->a)
06:55:53 <Aruro> "Emacs is a self documenting blahblah" we need it in haskell :) 
06:56:22 <mlehmk> although I could imagine placing like (1+) into the Num domain, so like (1+) + (1+) would be (2+)
06:56:24 <c_wraith> instance (Num b) => Num (a ->b)  is actually very cute
06:56:28 <Aruro> i dont like going to browsers to read docs, its nice, but switching windows is not pro :)
06:56:55 <mlehmk> but what would (2+) * (2+) be then?
06:57:27 <c_wraith> it would be exactly that.
06:57:33 <Aruro> :t (2+) * (2+)
06:57:34 <lambdabot> (Num (a -> a), Num a) => a -> a
06:57:38 <c_wraith> well
06:57:46 <mlehmk> not like that, uhm, what?
06:57:54 <c_wraith> It'd be \x y -> (2 + x) * (2 + y)
06:58:15 <c_wraith> err, no.  simpler.  \x -> (2 + x) * (2 + x)
06:58:16 <mlehmk> No, I don't mean it like that
06:58:24 <mlehmk> mmm... that's closer
06:58:30 <c_wraith> that is what it is when you use that instance
06:58:41 <c_wraith> You can find that instance in libraries on hackage if you want
06:58:54 <phadej> > liftA2 (*) (+2) (+3) 4
06:58:56 <lambdabot>  42
06:59:05 <c_wraith> It lets you do silly things like f = sin ^ 2 + cos ^ 2
06:59:06 <mlehmk> haha, cool
06:59:20 <mlehmk> we finally found the question to life, the univers and everything
06:59:29 <c_wraith> if you want f = almost-const-1
06:59:53 <mlehmk> it took long enough
07:03:37 <ertes-w> "… and then particles and all major forces can be explained in terms of vibrations of tiny high-dimensional strings that live in branes…  if we generalise further, even particles and forces can be unified into van laarhoven lenses and traversals, which proves that the universe is implemented in haskell"
07:04:17 <ertes-w> "i don't understand this chemical reaction" – "have you checked its core?"
07:05:49 <ertes-w> now i understand why GHC is so Glorious
07:06:11 <MarcelineVQ> ghc 9.3 bugfixes: Planck constant rounding error corrected, max now working as intended
07:06:22 <ertes-w> forget the big bang…  it all started in glasgow
07:10:41 <Aruro> > liftA2 (.) (+) (+) 2 2
07:10:43 <lambdabot>  6
07:20:06 <tsahyt> hm, I've been wondering. say I have a bar :: Map k [v], and I do something like map quux <$> M.lookup foo bar. The list gets used up in full somewhere else. would it be wrong to consider the operation to still be log(n) (in the size of the map) and amortizing the map over whatever happens to the list later?
07:21:57 <Cale> tsahyt: There should be no special interaction of any kind from the fact that your list came from a Map
07:22:24 <Cale> tsahyt: So you pay the cost to find the list in the Map, and then you pay for whatever operations you perform on that list separately
07:22:32 <tsahyt> hm okay
07:22:59 <tsahyt> so as long as what I do elsewhere with it is more than linear cost, I can indeed amortize that?
07:23:20 <tsahyt> since I'll have to look at every element in there at least once, and what I map over it here is constant time
07:23:48 <Cale> tsahyt: Well, be careful about what is meant by "linear" here. You have the number of elements in the Map, and then the number of elements in the list
07:23:56 <tsahyt> I mean linear in the length of the list of course
07:24:02 <tsahyt> which is typically much less than the size of the map
07:24:18 <tsahyt> but I can't guarantee that unfortunately
07:24:53 <Cale> So if the Map has k elements, and then the list has n elements and applying the function is constant time, and you evaluate the whole list, you'll have paid a total of O(log k + n) time
07:26:16 <andycandy_> what is the object of having immutable data structures?
07:26:50 <c_wraith> andycandy_: to prevent bugs
07:26:55 <tsahyt> Cale: hm, I suppose what is the "morally correct" way depends a lot on the question I'm asking. my map is essentially representing a graph, and I'm asking for the complexity of finding the successors. each map element is an adjacency list, [(label, node)], and I just map snd over it to get the nodes out.
07:27:33 <Cale> tsahyt: If you don't care about the order of the elements in those lists, perhaps using a Set would help
07:27:44 <c_wraith> andycandy_: I can assure you that "some method call mutated that value and I don't even know which" is a source of very annoying bugs
07:27:46 <Cale> Though if the lists are small enough, maybe a list is actually better than a Set
07:28:13 <Cale> andycandy_: Also, to improve the composability of programs
07:28:17 <tsahyt> Cale: oh I've already implemented this a long time ago, it works well. I'm just writing the implementation section of my thesis so I'm going over all this again
07:28:38 <tsahyt> but that gives rise to all sorts of theoretical questions that I haven't really considered much when I originally wrote the code
07:28:39 <Cale> Programs which have different, competing conventions about who is allowed to modify data end up not being able to work together.
07:28:45 <andycandy_> c_wraith: but it is a variable, and therefore it should be changeble.  
07:28:45 <andycandy_> I guess you are right though heh
07:29:02 <tsahyt> I'll just include both. mentioning that you can amortize the cost of the map over the consumption of the list isn't wrong at least.
07:29:02 <c_wraith> andycandy_: heck..  even things like strtok in C.  Have you ever used that?  oh my god, the pain if you expected the input to still be usable afterwards...
07:29:17 <andycandy_> c_wraith: how about giving a function read abilities to a variable though, making it able to atleast read and not write data. 
07:29:18 <Cale> and so you end up rewriting large swathes of independently working programs to make them work together
07:29:33 <andycandy_> ok
07:30:00 <Cale> Oh, and writing tests is much much easier
07:30:32 <c_wraith> andycandy_: immutability doesn't prevent reading values.  You can still read any value you have in scope (and know enough about to interpret properly)
07:30:33 <eelster> But strtok is dep'd in favor of strsep anyways.
07:31:03 <c_wraith> eelster: is that because mutating your input is bad? If so, it kind of proves my point. :)
07:31:16 <Cale> andycandy_: Really, the crucial thing which we want to have is that functions evaluated in isolation will behave the same way in your real program.
07:31:40 <Cale> andycandy_: This makes it much easier to think about what your program does, and makes it much easier to test.
07:31:47 <Cale> Mutability destroys it.
07:32:09 <andycandy_> I see.
07:32:23 <eelster> strsep handles empty fields better and such. They're both mutable to the best of my knowledge.
07:33:29 <c_wraith> eelster: ah.  didn't know about strsep. (It's been a long time since I've used C for anything substantial.)  thanks!
07:34:03 <eelster> c_wraith No worries. It's kinda controversial still because strtok is POSIX compliant whereas strsep isn't, but strtok is pretty widely dep'd.
07:35:54 <c_wraith> andycandy_: by the way, if you're interested in an argument from authority...  Even super-hardcore C programmers who care about performance first still see good reasons to use immutability!  http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/ (that's a piece from John Carmack about why he thinks there is a lot to learn from Haskell, even for game programmers)
07:36:44 <eelster> But yeah, I agree with c_wraith I program in C a lot and immutability is important. (I end up using rust now more than C because it's easier to keep w/ immutability)
07:36:47 <c_wraith> iirc, Cale has done some game programming in Haskell, by the way. :)
07:37:13 <vktec> Is there a function that runs a function on both value of a pair? I wrote this, but I'm wondering if there's something built in: mapPair f (a, b) = (f a, f b)
07:37:35 <Tuplanolla> :t join bimap
07:37:37 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
07:37:39 <c_wraith> vktec: if you don't mind crazy type signatures, (&&&) from Control.Arrow
07:38:10 <Tuplanolla> :t over each
07:38:11 <lambdabot> Each s t a b => (a -> b) -> s -> t
07:38:13 <eelster> Can f take both types a and b?
07:38:28 <Tuplanolla> I'd favor either of these two, vktec.
07:38:34 <Cale> c_wraith: yeah -- the game never got released, but we got far enough with it to learn a lot about FRP and prove to ourselves that this sort of thing is viable to do (though the time we spend cutting our way through the jungle to get there was a bit expensive)
07:38:50 <Cale> spent*
07:39:40 <andycandy_> i see.
07:41:07 <vktec> Tuplanolla: What module do I need for those? They don't appear to be in Prelude
07:41:18 <ongy> @index bimap
07:41:18 <lambdabot> Data.Bifunctor
07:42:12 <Cale> I actually think that if we were able to start now, making use of all the stuff that Ryan's done in Reflex (and which was informed by our earlier game project), we'd be in a much better place pretty quickly. Maybe someday we'll really have to write an ARPG game engine again :)
07:43:06 <ongy> make it a jrpg :) But I guess that's too easy
07:43:23 <vktec> c_wraith: I'm not sure that (&&&) does what I want, but maybe I'm missing something
07:44:42 <ongy> :t (&&&) -- iirc you'd have to do f &&& f
07:44:44 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:45:16 <ongy> ok no, that's not how that one works. is it?
07:45:50 <vktec> Tuplanolla: join bimap seems to work. Thanks!
07:47:28 <Cale> ongy: An oldschool JRPG on the web using reflex-dom seems like it might be fun :)
07:49:47 <ongy> you just need to get a good story writer and componist and artist. Sounds like it's easy :)
07:50:47 * hackagebot fsnotify 0.2.1.1 – Cross platform library for file change notification. – https://hackage.haskell.org/package/fsnotify
07:50:48 <ertes-w> if you look at the average JRPG, you don't strictless *need* any of those ;)
07:53:06 <ongy> if you look at the good ones, that's what makes the difference :)
07:54:40 <danilo2> Hello guys! For last 2 days I'm trying to figure out performance problems in a code looking very simple. However I got results that seem just like weird GHC optimization errors. Would anybody be so nice and help me with debugging it? I would be more htan thankful for any hints / help
07:55:22 <danilo2> I was trying inspecting core / running performance testing (with RTS -p), but I got to the point where I do not know what is happening with the performance and why is it happening
07:57:22 <danilo2> Here is the code. It looks long but it really isnt. It defines a State wrapper (which mysteriously works faster than pure State), strict Either and EitherT and just runs a simple loop: http://lpaste.net/2972166975704268800
07:57:54 <danilo2> there are comments in the code telling whats going on and why with a set of 3 performance related questions / observations on the end
07:58:21 <danilo2> If anyone could look at it, I would be more than thankful 
08:00:44 <delYsid> You guys know this.  If I want to split a list l into chunks of size n, what do I use/how is it called when I want to spread out length(l) `mod` length(chunk) evenly across all chunks, so that the last one isn't noticeably different in length?
08:01:44 * hackagebot SSTG 0.1.0.6 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
08:01:44 * hackagebot sdl2-cairo 0.1.0.3 – Render with Cairo on SDL textures. Includes optional convenience drawing API. – https://hackage.haskell.org/package/sdl2-cairo
08:02:03 <delYsid> s/chunks of size n/n chunks/
08:05:09 <crobbins_> delYsid: so i guess Data.List.Split.chunksOf is not what you want?
08:05:24 <crobbins> :t Data.List.Split.chunksOf
08:05:26 <lambdabot> Int -> [e] -> [[e]]
08:05:28 <c_wraith> andycandy_: oh, if that link didn't work (I had trouble resolving the domain), try https://web.archive.org/web/20130819160454/http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/
08:08:01 <davr0s> haskell - linear types retrofit - how far could that get in dodging garbage collection
08:08:19 <davr0s> haskell - linear types retrofit - how far could that get in dodging garbage collection?
08:09:57 <c_wraith> davr0s: depends on how libraries use it.
08:10:44 <davr0s> well lets say one can rewrite every single library if it comes down to it.. the question is really the theoretical capability of the language engine;
08:10:58 <davr0s> you could have a whole parallel 'linear haskell' world
08:11:14 <davr0s> IMO that would happen very quickly, if the engine was there
08:11:16 <c_wraith> You'd need to make some significant changes to the runtime, too.
08:11:58 <c_wraith> At the moment, it's all optimized to make allocation basically free, and collection of the nursery generation as fast as possible.
08:11:58 <davr0s> i realise with Rust they gave up trying to have a GC co-existing with single-ownership, but they still provided refcounted types as a fallback
08:12:16 <davr0s> i hear 'purity' also gives it some extra assumption-ability
08:12:27 <davr0s> i.e. older blocks do not need to be rescanned
08:12:40 <c_wraith> sort of, though that's weakened by laziness meaning things aren't pure in memory
08:12:47 <c_wraith> There are workarounds for that
08:13:14 <davr0s> oh ok, maybe they have the option of having 'really-pure' blocks with no remaining 'thunks'(is that the jargon?)
08:13:52 <c_wraith> thunk is the implementation strategy...  I'd call the language-level term "unevaluated expression"
08:14:20 <c_wraith> They are more or less used interchangeably when talking about GHC, though, so don't worry about the distinction much.
08:15:02 <davr0s> i still wonder if you could get far enough with a 'realtime loop hint' upfront,     'mainAnimationLoopStepWhichMustExecuteAtARegularInterval::WorldState->Inputs->WorldState'
08:15:37 <c_wraith> Anyway, the big thing trying to go GC-less with linear types would mean is that you would need an alternate strategy for allocation/collection of values that are used linearly
08:16:07 <davr0s> expect this to evaluate eager, and expect a full collection to elimate the intermediate temporaries , and the return value is 'the fully updated world
08:16:13 <c_wraith> Which would mean you need a big runtime change.  It can be done, and it might be worthwhile
08:16:22 <c_wraith> But it's a lot of work, and won't happen quickly.
08:16:25 <danilo2> Hi guys! :) Would anybody find few minutes to help me track a performance bottleneck? I'm stuck when trying find it by myself :(
08:17:09 <davr0s> i get the impression there is motivation for linear types beyond just that, and they talk about some generality e.g. our 'destructors' can't take arguments, but something that consumes a final value could
08:17:14 <c_wraith> GHC's allocation/collection strategy is already pretty fast in a lot of cases, and a lot of problems can be pushed into one of those cases.
08:18:10 <c_wraith> yeah, the big win for adding linear types is in correctness.
08:18:31 <c_wraith> You can create run-once APIs that actually are only run once. :)
08:19:21 <c_wraith> This can help with optimizations in some cases.  In other cases, it's just about interacting with a system resource in a sane manner.
08:20:21 * hackagebot camfort 0.904 – CamFort - Cambridge Fortran infrastructure – https://hackage.haskell.org/package/camfort
08:24:57 <davr0s> would it be an anotation on a type, or a function, .. the paper was showing some alternate notatino for functio declarations with the "->" arrow replaced with a "--o"
08:26:48 <c_wraith> davr0s: It's a property of how functions use their arguments.  But there is some ambiguity involved, and I haven't read the proposals closely.
08:38:56 <AWizzArd> I have csv data. A list of column names and a list of lists of data, in a tuple: (["a", "b", "c", "d"], [[10, 20, 30, 40], [50, 60, 70, 80]])
08:39:02 <AWizzArd> I now want to update the data, so that elements in certain columns (say, a and c) is negated: foo ["a", "c"] (["a", "b", "c", "d"], [[10, 20, 30, 40], [50, 60, 70, 80]]) => (["a", "b", "c", "d"], [[-10, 20, -30, 40], [-50, 60, -70, 80]]).
08:39:16 <AWizzArd> Is there some Haskell magic to implement foo efficiently, so that we traverse the list of headers only once (imagine there are hundreds instead of 4), and each data row also only once?
08:42:20 <Rembane> AWizzArd: First, put it in a Data.Vector, Vector. Then you can update things using the bulk update function in Data.Vector.
08:42:57 <AWizzArd> Rembane: yeah, I explicitly was thinking about doing this with lists.
08:42:58 <danilo2> AWizzArd: Repa could help too.
08:43:09 <AWizzArd> danilo2: what is Repa?
08:43:41 <byorgey> AWizzArd: there is no magic way to do it efficiently with lists.
08:43:46 <danilo2> AWizzArd: http://bfy.tw/D2u7 
08:44:20 <Rembane> AWizzArd: Why? :)
08:45:25 <AWizzArd> Rembane: because I was solving this in CL and wondered if there was a nice Haskell solution too.
08:45:41 <Rembane> AWizzArd: I see. :)
08:46:05 <Rembane> AWizzArd: Updating things in the middle of Haskell lists are always O(n)
08:47:05 <AWizzArd> Rembane: I want to compute a new output, not „update” existing entries.
08:48:54 <AWizzArd> In CL I was doing two matrix transpositions, because there I can (apply 'mapcar …). That is: map over n lists at the same time.
08:49:15 <Rembane> AWizzArd: You could use transpose in Data.List.
08:49:31 <phadej> Rembane: you overthink it
08:49:34 <AWizzArd> Something like `zipN`.
08:49:58 <AWizzArd> Still, my double transposition means I am iterating over the list twice.
08:50:16 <AWizzArd> I guess in both, CL and Haskell, we require to write a recursive algorithm by hand.
08:51:01 <phadej> it's not complicated to write makeModifier :: (Eq k) => (v -> v) -> [k] {- keys to modify -} -> [k] {- all keys -} -> [v] -> [v] 
08:51:50 <phadej> map (makeModifier ["a", "c"] (fst data_)) (snd data_)
08:52:04 <phadej> map (makeModifier negate ["a", "c"] (fst data_)) (snd data_)
09:10:21 <vimalloc> Is there a way to get terminal codes (bold, color, etc) to work with ghci? echo "\033[1mbold\033[0m" will print bold in bold, but putStrLn "\033[1mbold\033[0m" will print ![1mbold![0m
09:14:28 <geekosaur> vimalloc, use the appropriate Haskell escapes instead of the C escapes?
09:14:44 <geekosaur> in particular, \ESC or \27 instead of \033
09:15:14 <nshepperd_> Or \x1b
09:15:31 <vimalloc> Perfect! Thanks geekosaur :)
09:15:51 <nshepperd_> Does Haskell even support octal?
09:16:20 <geekosaur> I don't think DEC had anything to do with its creation, so probably not >.>
09:16:57 <nshepperd_> Ah, it starts with \o
09:17:10 <nshepperd_> Not \0
09:17:34 <geekosaur> or numeric literals with 0o...
09:18:03 <nshepperd_> > "\o33"
09:18:05 <lambdabot>  "\ESC"
09:32:59 <butterthebuddha> https://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
09:33:05 <butterthebuddha> Exercise 3 is blowing my mind
09:34:11 <Fuuzetsu> interesting, code golf for homework…
09:34:28 <glguy> butterthebuddha: this was my take a couple years ago http://lpaste.net/2122422419338559488
09:34:51 <cheater> hi
09:34:59 <butterthebuddha> glguy: I'd rather not look at a solution
09:35:08 <glguy> butterthebuddha: it won't give anything away
09:35:09 <butterthebuddha> I just need some pointers :)
09:35:48 <glguy> butterthebuddha: What are you stuggling with?
09:35:55 <butterthebuddha> Okay ... I don't understand your solution at all
09:36:09 <butterthebuddha> How do you git so gud P
09:36:28 <glguy> That code is a disaster, it's just trying to be "golf"
09:37:09 <AWizzArd> What does "nopie" mean, in the context of GHC?
09:37:41 <glguy> AWizzArd: It means that when calling out to GCC it's necessary to use the -nopie flag
09:37:48 <glguy> "position independent executable"
09:38:00 <geekosaur> AWizzArd, disabling position-independent executables which are the default on some newer Linux distributions, and which currently play badly with ghc's code generator
09:38:37 <AWizzArd> Okay thx.
09:55:02 <kzhang> What are the advantages of dynamic typing for writing LARGE software? The Nature is typed. Even though you do not explicitly write down the types, you still have "types" in your mind. 
09:56:14 * hackagebot matterhorn 40000.0.0, mattermost-api 40000.0.0, mattermost-api-qc 40000.0.0
09:56:14 * hackagebot  → https://hackage.haskell.org/packages/recent
09:56:32 <jle`> The Nature ?
09:56:55 <kzhang> jle` : the world we live
09:57:03 <kzhang> everything has a type
09:57:16 <kzhang> You can't think without types
09:57:21 <bitemyapp> didn't know I'd get strong ontological claims in IRC today
09:57:45 <jle`> i'd be careful of drawing arguments from 'natural' or 'intuitive' thinking
09:58:28 <jle`> not only is your idea of what is natural clouded by bias, but it's also potentially irrelevant in the design of useful things
09:58:40 <jle`> unnatural things can be useful tools in programming
09:58:48 <bitemyapp> Nothing at all natural about telefragging people in Unreal Tournament, but it's fun anyway.
09:59:14 <Fuuzetsu> unsure why you'd ask about advantages of dynamic typing in #haskell to begin with
09:59:22 <jle`> and "nature does it" isn't a particularly powerful argument for how useful something would be
09:59:49 <jle`> a wise man once told me that things like driving a car are not natural processes, but that doesn't mean we shouldn't drive cars
09:59:53 <cheater> until you understand the structure behind how nature does it
09:59:56 <cheater> then it's a good argument
10:00:59 <kzhang> OK. It was not my intension. 
10:01:18 <kzhang> But what are the advantages of dynamic typing
10:01:55 <cheater> for purposes within your paygrade, if you already have haskell at your disposal, there are no advantages
10:02:05 <kzhang> Maybe I should ask Python people.
10:05:36 <AWizzArd> Why do so many getters for (new)types start with run…?  runIdentity, runQuery, runWriter, runState, etc…
10:06:28 <Fuuzetsu> consistent and don't have to think about it
10:06:54 <Fuuzetsu> when you use those newtypes it often looks like you're "running" it
10:07:29 <Fuuzetsu> runReader (yourReader ReaderT () IO ()) () :: IO a -- you "ran" it
10:07:44 <Fuuzetsu> oops, dropped a :: but you get the idea
10:09:03 <vktec> Is there a way to have multiple possible values for something when pattern matching? For example, something like `f (1 | 3) = foo; f _ = bar` where f 1 and f 3 would return foo but f 2 and f 4 would return bar
10:10:23 <geekosaur> vktec, not in pattern matching but you could use a guard
10:10:31 <Fuuzetsu> no; here just use `f x | x == 1 || x == 3` or something; view patterns can help but it just pushes the pattern match elsewhere
10:10:56 <geekosaur> pattern matching is about structure although there's a hack to pretend numbers are "constructors"
10:13:18 <vktec> That's a shame
10:13:20 <guillaum1> Is there a way in STM to rollback the transaction and return something (instead of retrying it)?
10:13:22 <vimalloc> Why is `nub` in data.list O(n^2)? Couldn't you convert it to a set (Data.Set fromList, O(n*log n)) then convert it back to a list (Data.Set toList O(n)), which would end up as O(n*log n) (assuming I have that correct).
10:13:43 <vktec> I might try using a case
10:13:46 <Fuuzetsu> you need Ord for the ordNub way; nub is only Eq
10:13:48 <guillaum1> vimalloc: because nub does not assume anything about the items of the list.
10:13:59 <geekosaur> also because nub can produce results lazily
10:14:15 <vimalloc> does Data.Set assumine something about the items in the list either?
10:14:29 <vimalloc> oooh. It probably assumes Ord huh
10:14:31 <guillaum1> vimalloc: yes, Ord constraint
10:14:34 <geekosaur> Data.Set requires an Ord constraint
10:14:36 <vimalloc> got it. Thx.
10:14:44 <ertes-w> guillaum1: STM is an Alternative
10:14:45 <geekosaur> but I think the laziness is the real point
10:14:51 <Cale> You also wouldn't want to just convert to/from a Set
10:15:07 <Cale> That wouldn't handle infinite lists as well as nub does
10:15:08 <ertes-w> guillaum1: example: myXact <|> pure myFailureValue
10:15:13 <geekosaur> Set would have to traverse the whole list to make the Set before producing any result, nub as written can produce lazily
10:15:30 <guillaum1> ertes-w: and if I want to know "Why" it has failed ?
10:16:13 <vimalloc> If chances are the whole list will be eventually handled anyways, would it be better to use fromList . toList (assuming the list is ordered of course)
10:16:15 <Fuuzetsu> fromList was not the right suggestion there, you can still deal with infinte lists with ordNub
10:16:19 <ertes-w> guillaum1: in that case you shouldn't retry…  note that STM has an exception mechanism that falls through into IO unless caught within STM
10:16:24 <Fuuzetsu> just not with fromList
10:16:44 <Cale> > foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) (1:2:3:[1..]) S.empty
10:16:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:16:54 <Cale> ^^ something like that is probably better
10:16:54 <vimalloc> Assuming it is a non-infinite list?
10:17:01 <ertes-w> guillaum1: see throwSTM and catchSTM
10:17:20 <Cale> vimalloc: In that it gets you the first element sooner, even if the list is finite
10:17:37 <ertes-w> guillaum1: alternatively you can use any of the exception transformers that are available, e.g. ExceptT
10:17:39 <Fuuzetsu> > head . Set.toList $ Set.fromList [1..]
10:17:41 <lambdabot>  error:
10:17:41 <lambdabot>      Not in scope: ‘Set.toList’
10:17:41 <lambdabot>      Perhaps you meant one of these:
10:17:49 <Fuuzetsu> > head . S.toList $ S.fromList [1..]
10:17:54 <Cale> It's imported as S
10:17:56 <lambdabot>  mueval-core: Time limit exceeded
10:18:58 <guillaum1> ertes-w: I should think about it... Thank you.
10:19:44 <f-a> I am reading a library and found a signature like `type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t` <-- isn't the forall not needed when it is 'outermost'?
10:21:04 <geekosaur> f-a, in the case of a declaration (type or data), you either must use type variables from the left of the = or "forall" them to indicate that they are "hidden" from outside the declaration
10:22:03 <f-a> ohhh of course, silly me. thanks geekosaur 
10:22:04 <geekosaur> consider that use of that type expands to a *non* outer forall:  (Lens s t a b -> Lens s t a b) translates as ((forall f. Functor f => (a -> f b) -> s -> f t) -> (forall f. Functor f => (a -> f b) -> s -> f t))
10:22:20 <geekosaur> the two "f"s are independent, the s t a b unify
10:23:08 * f-a nods
10:25:56 <srpx> https://cstheory.stackexchange.com/questions/38697/wouldnt-the-calculus-of-constructions-with-linear-types-be-a-simple-functional
10:26:18 <monochrom> Oh neat dons reappears and reveals that he's at Facebook now.
10:27:55 <c_wraith> I is bos still there? 
10:27:59 <c_wraith> -I
10:29:07 <count_> Hi there I have a nested list [[Int]] that is pre-sorted-- aka [[1,1,1,1],[2],[3,3]
10:29:16 <Tuplanolla> Do you happen to know why point three is on the list, srpx?
10:29:20 <count_> I would like to simply know the length of the sublists
10:29:39 <phadej> monochrom: he didn't hide that fact: https://donsbot.wordpress.com/2017/04/15/spring-in-the-air/
10:29:51 <monochrom> Ah
10:29:53 <count_> Does anyone have an idea how I might do taht
10:30:00 <monochrom> Well I guess I don't read blogs.
10:30:15 <geekosaur> sorted doesn't even matter here.
10:30:17 <phadej> monochrom: you should read reddit r/haskell, it was posted there
10:30:21 <monochrom> > map length  [[1,1,1,1],[2],[3,3]]
10:30:23 <lambdabot>  [4,1,2]
10:30:28 <monochrom> Is that sufficient?
10:30:39 <c_wraith> count_, why does it matter that the lists are pre-sorted? 
10:30:43 <monochrom> I don't read reddit either.
10:31:04 <phadej> monochrom: consider, it aggregates stuff quite well
10:32:27 <count_> lambdabot, that is correct
10:32:57 <Tuplanolla> I disagree, phadej. The reason I really dislike Reddit is because it allows discussion-only threads.
10:33:39 <count_> but I take it that map length is not the right formatting?
10:33:47 <geekosaur> er?
10:33:58 <Tuplanolla> People ask questions that would be a better fit for Stack Exchange or want advice that would work better on more informal discussion channels.
10:34:07 <phadej> Tuplanolla: well, there isn't that many in r/haskell 
10:34:27 <count_> nvm I got it to work thank's yall
10:35:11 <phadej> at least in "top"
10:35:24 <phadej> or "hot"
10:36:07 <Cale> Tuplanolla: I would generally prefer to answer a question on reddit than on StackExchange
10:37:28 <monochrom> While I admit that r/haskell has a higher quality than most of reddit, it is still very low-priority for me.
10:37:45 * geekosaur seconds that
10:37:52 <monochrom> Basically I don't even have time for higher-priority things such as the Quanta Magazine.
10:38:09 <monochrom> And oh, IRC. :)
10:39:17 <monochrom> I wish I were a pushy person so that I push you to read Quanta and you don't dare to push me to read r/haskell.
10:39:34 <monochrom> The problem with being so easy-going.
10:39:57 <monochrom> Always on the defensive, passive side.
10:41:54 <monochrom> I do commend Reddit for bringing trees back. Long lost art since the decline of Usenet and rise of web forums.
10:42:21 <monochrom> Although, people still haven't discovered directed acyclic graphs.
10:42:50 <MarcelineVQ> they're all over cyclic graphs though
10:46:01 <jared-w> directed acyclic graphs?
10:48:30 <jared-w> monochrom: thanks for the quanta magazine plug. I haven't heard of it before for some reason
10:49:56 <monochrom> :)
10:50:34 <jared-w> It seems the CS articles are all pretty old :( but there's still a lot of good stuff in here
10:51:17 <venkat24> I'm trying to build ghcjs
10:51:21 <venkat24> But I get this error
10:51:23 <venkat24> cabal: internal error when reading package index: failed to parse .cabal fileThe package index or index cache is probably corrupt. Running cabal update might fix it.
10:51:43 <venkat24> I've tried completely removing .cabal folder too
10:53:13 <venkat24> I tried with different versions of ghcjs as well
10:54:15 <venkat24> Any clues?
11:00:55 * hackagebot th-orphans 0.13.4 – Orphan instances for TH datatypes – https://hackage.haskell.org/package/th-orphans
11:03:38 <Cale> venkat24: Is your intention to work on ghcjs, or just to use it?
11:09:03 <Cale> venkat24: The usual way that I like to obtain ghcjs is just to clone this repository:  https://github.com/reflex-frp/reflex-platform
11:09:32 <Cale> venkat24: and then from there, ./try-reflex will download a bunch of stuff and drop you into a shell which has ghcjs available
11:10:17 <Cale> venkat24: and  ./work-on ghcjs ./path/to/project   where the path contains a .cabal file, will put you in a shell with the required depedencies to build your project
11:10:55 <ReinH> ghcjs is pretty difficult to get working otherwise
11:11:44 <ReinH> I had a method that worked with stack like a year ago, but I haven't kept it up to date since reflex-platform works so well.
11:13:58 <venkat24> I'm working on codeworld, and GHCJs is a dependency
11:14:04 <venkat24> I've gotten it working before
11:14:22 <venkat24> I made a fresh VPS and ran into this error
11:19:37 <Cale> venkat24: Yeah, reflex-platform just handles the annoying dependency issues really nicely by using the nix package manager to make sure you have appropriate matching versions of everything.
11:22:57 <monochrom> Does GHC 8.2.1 include some Backpack features?
11:23:06 <dolio> Yes.
11:23:22 <monochrom> Which section in the User's Guide talks about it?
11:23:40 <dolio> I don't know. But the release notes said backpack stuff was finally included.
11:23:56 <shapr> ghc trac says it's in 8.2
11:24:03 <shapr> but I can't find anything else on google
11:25:47 <monochrom> Actually the way I found out is on haskell-cafe when someone brought up "can't find it in the release notes"
11:26:02 <parsnip> i'd like to be able to update hledger-web, and maybe even modify source and run, on a small machine. i know that `stack install` will need to get all the dependencies, can i package those in a gzip to get around the time and resources needed for `download\nconfigure\build`? 
11:26:39 <parsnip> i'm willing to use some recently learned docker "skills" to assist me in this process
11:26:52 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#thinning-and-renaming-modules
11:27:11 <geekosaur> "backpack" is not the formal name of the feature
11:27:28 <dolio> monochrom: I'm talking about the announcement e-mail, I guess.
11:27:50 <dolio> Maybe that isn't the official release notes.
11:28:03 <anhduy> hi guys, i wonder what is the best practice in Haskell when you want to make a type into json. My understanding is Aeson is the package to go when talk about JSON. But the problem is i want to serialize a type in 3rd party package, Request in WAI for example. If i provide the instance, ghc complain about orphan instance. So my question is what is the best way to solve this problem
11:28:20 <monochrom> Oh! In the package chapter. I was looking at the chapter 9.
11:28:26 <Cale> anhduy: Is your program an application or a library?
11:28:39 <geekosaur> it's a package management feature not a language feature...
11:28:40 <anhduy> @Cale it is a application
11:28:40 <lambdabot> Unknown command, try @list
11:29:02 <Cale> anhduy: Then ignore warnings about orphan instances, the downsides of orphan instances mostly don't apply to you
11:29:32 <anhduy> so we only care about orphan instances when writing library?
11:29:37 <Cale> anhduy: Right.
11:29:38 <geekosaur> anhduy, orphan instances are a problem when libraries "export" them
11:29:57 <geekosaur> in executables, there's nothing else that can get a nasty surprise when importing because executables can't be imported
11:29:59 <Cale> The reason that orphan instances are bad in libraries is that two libraries which define the same instance won't be possible to use together.
11:30:16 <anhduy> got it, thank you very much
11:30:48 <monochrom> Wait a second, I think I saw thinning and renaming in 8.0 as well.
11:31:07 <kuribas> https://www.reddit.com/r/programming/comments/6pnuu9/programming_as_if_the_domain_and_performance/
11:31:38 <kuribas> or why haskell code is slow hipster code...
11:31:55 <geekosaur> hm, it is in 8.0.2
11:32:29 <geekosaur> and actually that does seem to be a bit less than what backpack claims
11:33:07 <geekosaur> ... and now I am vaguely recalling it got put in "as is", so docs are likely missing :/
11:34:57 <monochrom> I am very eager to read about it!
11:35:26 <geekosaur> I don't think there's a way to speed up ezyang's thesis defense so we can get docs :p
11:35:32 <monochrom> haha
11:35:54 <monochrom> Maybe I should read the thesis draft.
11:36:33 <monochrom> Oh great he posted it in haskell-cafe back in February!
11:36:35 <ezyang> 8.0 had some minor features which weren't put together in any useful way 
11:36:48 <monochrom> Oh great it's on github.
11:36:52 <ezyang> the final copy of the tehsis is at https://github.com/ezyang/thesis/releases :) 
11:37:47 <monochrom> Neato. TTYL.
11:39:25 <geekosaur> "brb thesis-diving"
11:45:40 <Tuplanolla> Are these figures hand-drawn, ezyang?
11:46:12 <Tuplanolla> It's a dying art.
11:55:31 <Lokathor> @src ($)
11:55:31 <lambdabot> f $ x = f x
11:58:24 <paolino> glguy, how is pattern matching failure handled in localMaxima ?(http://lpaste.net/2122422419338559488)
12:00:43 <geekosaur> paolino, the only pattern match that could be a problem is irrefutable. the other one is in a list comprehension, so just drops the non-matching items
12:01:55 <paolino> > tails [1,2,3]
12:01:57 <lambdabot>  [[1,2,3],[2,3],[3],[]]
12:03:32 <paolino> so list comprehension is catching  a:b:c:_ = [2,3] ?
12:03:51 <geekosaur> [b|a:b:c:_<-tails x,b>a,b>c]
12:03:53 <geekosaur> yes
12:04:02 <paolino> how ?
12:04:09 <geekosaur> that's how list comprehensions work
12:04:26 <geekosaur> (but, take a look at the Monad instance for lists; fail in [] is []
12:04:29 <geekosaur> )
12:04:37 <Fuuzetsu> > [ x | Just x <- [ Nothing, Just True, Nothing, Just False ]
12:04:39 <lambdabot>  <hint>:1:60: error:
12:04:39 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:04:43 <Fuuzetsu> > [ x | Just x <- [ Nothing, Just True, Nothing, Just False ] ]
12:04:45 <lambdabot>  [True,False]
12:05:22 <paolino> is fail related to PatternMatching ?
12:05:47 <Fuuzetsu> it's invoked on failed pattern match
12:05:57 <geekosaur> you can read a list comprehension as a compact version of a do-expression in the list monad.
12:06:10 <geekosaur> do desugars pattern matches to invoke fail if the pattern doesn't match
12:07:50 <geekosaur> and fail in the list monad is [], so instead of an exception the non-matching value is simply dropped from the result, since it ends up contributing the empty list
12:07:58 <paolino> it sounds arbitrary
12:09:01 <kuribas> lol, I reduced this guys claim that haskell code is 200x slower to code that's only 2x slower (than his complicated code c# code).
12:09:08 <geekosaur> I don't understand your complaint
12:09:39 <Fuuzetsu> that wasn't really the point of his rambling
12:10:04 <paolino> geekosaur, I thought do notation has to do with >>=
12:10:11 <geekosaur> it does. and?
12:10:15 <kuribas> Fuuzetsu: who's rambling?
12:10:18 <paolino> but now I discover it needs fail
12:10:23 <geekosaur> it's not *just* >>=
12:10:55 <Fuuzetsu> the C# domain guy
12:11:12 <geekosaur> it is also >> and fail (which iirc was added to Monad specifically for this; I think the next ghc wants to force a MonadFail constraint in that case instead)
12:12:02 <geekosaur> the only part of Monad it doesn't do for you is return, and (a) arguably that is not Monad but Applicative (b) list comprehensions *do* do it for you, implicitly on the part before the |
12:12:26 <kuribas> Fuuzetsu: I am not sure what was his point really...
12:13:21 <paolino> ok, so catching pattern matching failure is something 
12:13:40 <kuribas> Fuuzetsu: I read that as, the haskell code is 200x slower, because it doesn't use the problem domain, which is simply wrong.
12:14:46 <paolino> is there any other construct to catch pattern matching failure ?
12:14:56 <geekosaur> paolino, the Report has a translation of list comprehensions that doesn't involve do
12:14:57 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
12:15:53 <geekosaur> in effect it translates `` pattern <- ... `` as `` let {someNewName pattern = ...; someNewName _ = [] } in ``
12:16:33 <geekosaur> and that in turn becomes a case ... of { pattern -> ... ; _ -> [] }
12:18:39 <paolino> thanks, this is cutting some code, very noce
12:18:42 <paolino> nice
12:24:28 <ezyang> Tuplanolla: yep! 
12:25:10 <paolino> > do 3 <- Just 2; return 4
12:25:12 <lambdabot>  Nothing
12:25:27 <delYsid> crobbins: Almost, but no.
12:26:33 <delYsid> When given 4, it splits a list of length 10 into 4,4,2.  I'd like it to do 4,3,3
12:28:56 <delYsid> I am trying to figure out how the "even spreading" might be called in the literature, so that I can find some hints.
12:31:15 <ongy> kuribas: that guy is funny. 30 pages on that? And in the middle the claim "surely you'll agree, print doesn't add much" without telling us where the IO went to?
12:31:30 <kuribas> haha, right
12:32:05 <dolio> delYsid: What happens with a list of length 9?
12:32:11 <geekosaur> delYsid, I'd start by looking for 'balanced' (along with other constrains because you'll get a _lot_ of hits for tree structures!)
12:33:32 <paolino> delYsid, https://en.wikipedia.org/wiki/D%27Hondt_method ?
12:35:04 <filip8192> Hi. Anybody can tell me what I did wrong if I wanted to make function counting amount of tuples with 2 expressions in list? :{ \n counttwotuples :: (Eq a) => [(a)] -> Integer \n counttwotuples (h:t) = if t==0 then 1 else counttwotuples t \n :}
12:35:18 <ReinH> Create a ring zipper of length n and deal the items from the list fairly into it.
12:36:29 <ReinH> filip8192: Well, (a) is not a tuple, for starters.
12:36:43 <ReinH> And I don't know what you mean by "amount of tuples with 2 expressions in list".
12:37:10 <Fuuzetsu> and ‘a’ is not a number either yet you're treating it as such (t == 0 implies t is a number but you say it's ‘a’)
12:38:44 <SepakoRayl>  /msg NickServ VERIFY REGISTER SepakoRayl nfqhvhppzniy
12:38:48 <SepakoRayl> woops
12:38:48 <geekosaur> "oops"
12:38:50 <ReinH> Oops.
12:38:52 <Fuuzetsu> :thinking:
12:39:08 <ReinH> This is why you /q NickServ.
12:39:22 <SepakoRayl> :(
12:39:25 <filip8192> I made error.This is my function definition. "counttwotuples :: (Eq (a,a)) => [(a,a)] -> Integer" I mean that this function gets [(a,a)] list of tuples with 2 arguments.
12:39:49 <ReinH> Ok, well... they're all two tuples. So I don't understand the rest of the question.
12:39:52 <Fuuzetsu> then isn't every element in the list a tuple with two "expressions"? they are all pairs
12:40:02 <Cement> I think he's looking for length
12:40:17 <Fuuzetsu> maybe
12:40:21 <Cement> or maybe length . filter (something)
12:40:28 <ReinH> That's a weird way to ask for the length of a list.
12:42:15 <filip8192> yes.I mean lenght of this list.
12:42:26 <Fuuzetsu> :t length
12:42:27 <lambdabot> Foldable t => t a -> Int
12:42:41 <Fuuzetsu> :t length [(a, a)] -> Int
12:42:42 <lambdabot> error: parse error on input ‘->’
12:42:44 <Fuuzetsu> :t length :: [(a, a)] -> Int
12:42:45 <lambdabot> [(a, a)] -> Int
12:42:45 <Fuuzetsu> I can't type today
12:42:55 <mizu_no_oto> > length [(1,1), (2,2), (3,3)]
12:42:58 <lambdabot>  3
12:43:58 <ReinH> :t fromIntegral . length :: [a] -> Integer
12:43:59 <lambdabot> [a] -> Integer
12:44:21 <ReinH> You should know that machine integers are Int, not Integer.
12:44:48 <ReinH> If you actually have a list whose length doesn't fit in a machine int, which I doubt, you can use genericLength.
12:45:04 <ReinH> > maxbound :: Int
12:45:06 <filip8192> Ok.Thank you.I know difference between Integer and Int.
12:45:07 <lambdabot>  error:
12:45:07 <lambdabot>      • Variable not in scope: maxbound :: Int
12:45:07 <lambdabot>      • Perhaps you meant ‘maxBound’ (imported from Prelude)
12:45:14 <ReinH> > maxBound :: Int
12:45:16 <lambdabot>  9223372036854775807
12:45:18 <ReinH> That would be a pretty large list.
12:45:21 <mizu_no_oto> filip8192: is there any reason you're restricting this length function to work on "(Eq (a,a)) => [(a,a)]"?
12:45:23 <davean> ReinH: I have distributed lists
12:45:36 <ReinH> davean: Then you are FUBAR.
12:45:50 <paolino> > (\n k -> (\(d,r) -> zipWith (+) (replicate r 1 ++ repeat 0) (replicate k d)) $ divMod n k ) 10 3
12:45:52 <lambdabot>  [4,3,3]
12:46:08 <ReinH> I don't understand what all the talk about tuples was for if you just wanted the length of a list.
12:46:15 <ReinH> So I feel like we must be missing something.
12:46:48 <geekosaur> we're prob ably seeing only part of the problem, and it is also possible that this part is about figuring out how to write length yourself
12:46:49 <filip8192> mizu_no_oto . No.My fault.
12:47:10 <paolino> delYsid, ^
12:47:44 <mizu_no_oto> filip8192: if you just want a function that gets the length of a list, you can give it the type "length :: forall a. [a] -> Integer", which is the same as "length :: [a] -> Integer"
12:48:29 <filip8192> Ok.Thanks for help.That is all.I will first read and understand this.
12:51:02 <SepakoRayl> "haskell-src-exts-1.19.1 failed during the building phase. The exception was:
12:51:02 <SepakoRayl> ExitFailure 1"
12:51:05 <SepakoRayl> hmm
12:51:50 <cocreature> SepakoRayl: try passing --verbose to cabal/stack/whatever you’re using
12:53:27 <ReinH> Also try installing that package directly.
12:53:37 <SepakoRayl> looks like a happy problem
12:54:22 <geekosaur> parconc-examples by any chance? a PR got filed against it for some missing config yesterday
12:59:24 <ReinH> Happy is an executable dependency and, as such, not managed by cabal. You need to install it yourself and ensure that the happy executable is in your path.
12:59:44 <ReinH> Alex is similar.
13:03:44 <SepakoRayl> yea I figured, it works now
13:04:42 <cheater> when using aeson, is there a simple way to say "ok, fields in json called a b c will be called x y z in the record"?
13:05:10 <cheater> otherwise the encoder and decoder instances are just a huge load of boiler plate
13:06:42 <lyxia> cheater: see fieldLabelModifier
13:07:28 <SepakoRayl> has anyone tried ghci on acid ?
13:09:13 <byorgey> SepakoRayl: it is very old and no longer maintained
13:10:23 <SepakoRayl> Is there anything similar ?
13:11:25 <thoughtpolice> ReinH: Actually, Cabal can totally handle that now! You can use build-tool-depends to track exe deps like happy, or arbitrary exes
13:11:38 <cheater> lyxia: i've looked at fieldLabelModifier before but it's not even really documented
13:12:54 <thoughtpolice> ReinH: e.g. something like 'build-tool-depends: happy:happy' should work. Constraints work too of course. I can't remember if build-tool-depends always requires the unambiguous '<pkg-name>:<exe-name>' format, I think it does.
13:13:05 <davean> ReinH: I told you!
13:13:10 <ReinH> thoughtpolice: oh cool
13:13:13 <ReinH> davean: You did.
13:13:18 <thoughtpolice> Since there can be multiple exes. And now cabal won't build the dependencies of the other executables, if you only need one of them.
13:13:28 <thoughtpolice> (If they have disjoint deps, I mean)
13:13:56 <cheater> @hoogle [(a, b)] -> a -> b
13:13:57 <lambdabot> Math.FFT.Base fzr :: b -> [a] -> [(a, b)]
13:13:57 <lambdabot> Music.Theory.List bracket :: (a, a) -> [a] -> [a]
13:13:57 <lambdabot> Music.Theory.List with_key :: k -> [v] -> [(k, v)]
13:14:29 <cheater> i would've sworn there's a function like this
13:14:29 <crobbins> whoa, haskell has a music theory library?
13:14:36 <Fuuzetsu> :t fromJust . Prelude.lookup
13:14:37 <lambdabot> error:
13:14:38 <lambdabot>     • Couldn't match type ‘[(a, b0)] -> Maybe b0’ with ‘Maybe c’
13:14:38 <lambdabot>       Expected type: a -> Maybe c
13:14:48 <crobbins> cheater: lookup?
13:14:50 <Fuuzetsu> :t \xs x -> fromJust . Prelude.lookup x xs
13:14:51 <lambdabot> error:
13:14:51 <lambdabot>     • Couldn't match expected type ‘a -> Maybe c’
13:14:51 <lambdabot>                   with actual type ‘Maybe b’
13:14:54 <crobbins> :t lookup
13:14:54 <Fuuzetsu> whatever, you get the idea
13:14:55 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
13:15:17 <cheater> fromJust . (flip lookup)
13:15:26 <davean> ReinH: The cabal docs on it aren't clear
13:15:41 <Fuuzetsu> cheater: still no good because there's 2 args so (.) won't work ;^)
13:15:46 <Fuuzetsu> but yeah details
13:16:05 <lyxia> cheater: yeah the documentation of Options sucks ever since the constructor was hidden
13:16:08 <thoughtpolice> davean: I think the cabal docs probably need a substantial re-reading/tuning since all these new features landed, including things like private libs, etc.
13:16:17 <crobbins> cheater: i mean, you really probably don't want fromJust
13:16:28 <cheater> or something
13:16:34 <cheater> crobbins: i want fromJust
13:16:55 <crobbins> well, maybe _later_ you won't want fromJust :D
13:16:57 <jared-w> Most of the time fromJust defeats the purpose of Maybe...
13:17:16 <cheater> jared-w: that's the point. i want Maybe to be defeated.
13:17:22 <crobbins> unsafePerformFromJust
13:17:33 <lyxia> cheater: set the option to be    defaultOptions{fieldLabelModifier=\case "a" -> "x"; "b" -> "y"; "c" -> "z"}
13:17:38 <davean> thoughtpolice: so unclear I was only willing to tell ReinH by PM because while I knew about the feature I completely failed to cite it
13:17:42 <crobbins> you're only cheating yourself
13:17:49 <cheater> let me call the pope first before i use fromJust so i know i can
13:17:55 <jared-w> Why do you want Maybe to be defeated? If you just want to pull out of maybe, you can use functions that work naturally with it. Things like applicative are great for that
13:18:03 <davean> thoughtpolice: and I've even used it
13:18:21 <thoughtpolice> davean: I can't even remember when I found out about it but yeah I used it too. I keep light track of cabal PRs so I think I found out that way.
13:18:28 <thoughtpolice> Or maybe Duncan told me
13:18:32 <crobbins> instead of fromJust, you should probably use the maybe function, throwing a detailed exception as to why things blew up
13:18:50 <crobbins> the thing is that fromJust doesn't give you much info when things do blow up
13:19:18 <crobbins> *** Exception: Maybe.fromJust: Nothing
13:19:58 <davean> crobbins: you can turn on traces
13:20:17 <crobbins> true, but it won't tell you the offending key in this case, which you'd probably want
13:20:59 <thoughtpolice> A place for something like `errorJust s m = maybe (error s) id m` would be nice.
13:21:11 <davean> crobbins: maybe use safe
13:21:23 <dolio> Will the stack trace you can turn on actually give you good information?
13:21:45 <davean> dolio: fairly
13:21:55 <davean> dolio: it'll tell you where it happened and mostly what wanted that result
13:21:57 <dolio> fromJust doesn't have the `CallStack =>` thing, I think.
13:22:06 <Fuuzetsu> just run with profiling ;^)
13:22:16 <davean> Yah, you need profiling compiled in
13:22:23 <davean> Sorry should have said that
13:22:40 <dolio> Does that give you the syntactic location or some kind of semantic 'forced the error from' location?
13:23:03 <thoughtpolice> It'll give you an actual file name and line no of the call site in the trace.
13:23:13 <Fuuzetsu> it gives you callstack
13:23:25 <SepakoRayl> wat's the best way to install global packages as in ghci plugins?
13:23:37 <dolio> My point is there are two call stacks.
13:23:43 <cheater> there are?
13:23:48 <crobbins> SepakoRayl: i usually use stack
13:24:09 <crobbins> use ~/.stack/global-project/stack.yaml to configure your "global" stack
13:24:09 <dolio> Yes. There's the call stack for when the error was built, and the call stack for when the error was forced.
13:24:19 <dolio> And they're not necessarily the same.
13:24:37 <dolio> Because of laziness.
13:24:48 <SepakoRayl> will try
13:25:25 <SepakoRayl> wasn't aware of global-project
13:25:48 <cheater> dolio, ok!
13:27:19 <vktec> Is there a lazy version of sequence?
13:27:37 <Fuuzetsu> would such a thing make sense?
13:28:37 * hackagebot th-reify-many 0.1.8 – Recurseively reify template haskell datatype info – https://hackage.haskell.org/package/th-reify-many
13:28:45 <dolio> > sequence (repeat id) 5
13:28:47 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
13:30:50 <thoughtpolice> dolio: It's where it was built. It reuses the profiling infrastructure, so it sees the question "where does this error come from" roughly as the same thing as "what should i attribute this cost center to?" CC profiles show where expensive terms were built in the call stack.
13:31:02 <dolio> Okay.
13:31:04 <thoughtpolice> The extremely quick difference can be seen here: https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
13:43:42 * hackagebot docker-build-cacher 1.0 – Builds a services with docker and caches all of its intermediate stages – https://hackage.haskell.org/package/docker-build-cacher
13:57:52 * hackagebot opaleye 0.5.3.1 – An SQL-generating DSL targeting PostgreSQL – https://hackage.haskell.org/package/opaleye
13:57:53 * hackagebot docker-build-cacher 1.1 – Builds a services with docker and caches all of its intermediate stages – https://hackage.haskell.org/package/docker-build-cacher
14:15:38 <MichaelBurge> Did they ever implement ImplicitMaybe? https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#ImplicitMaybe
14:17:17 <crucify_me> https://ptpb.pw/HgdA  hi the func def is wrong here, but could anyone give examples of how the type signature could be used here? (+) causes an error
14:18:12 <ReinH> :t \a b -> (+) (fromIntegral a) b
14:18:13 <lambdabot> (Num a, Integral a1) => a1 -> a -> a
14:18:16 <glguy> combine _ x = x+1
14:18:59 <ReinH> Oh, Num just has fromInteger, right.
14:19:09 <ReinH> So basically you can only use the a or the b, not both.
14:19:09 <glguy> Num is a dead-end class, that is knowing only that you have an instance of Num you can't get any other type out or combine it with anything other than itself and Integer
14:19:24 <ReinH> Oh wait, you have to use the b.
14:19:33 <glguy> every method in Num a ends with -> a
14:19:41 <ReinH> Since it gives a b. So you must ignore the a and may do Num-y things with the b.
14:20:00 <crucify_me> ReinH, I thought so ! hold on I'm tripping
14:20:09 <ReinH> The a is useless.
14:26:45 <ReinH> :t flip const
14:26:46 <lambdabot> b -> c -> c
14:28:27 <crucify_me> thoroughly confused. why would this be in a textbook with very little explanation?
14:29:01 <jared-w> crucify_me: did you read what I just wrote in #haskell_beginners ?
14:30:25 <jared-w> (for clarification to the rest, the actual problem in the haskell book is this: "If the type of h is (Num a, Num b) => a -> b -> b then the type of h 1.0 2 is..." and lists either Double, Integer, Integral b => b, or Num b => b as possible answers)
14:31:47 <crucify_me> sorry yeah I had to leave. I reposted to clarify the func was incorrect. https://ptpb.pw/iOYa
14:31:54 <crucify_me> jared-w, one sec thanks
14:32:04 <AWizzArd> In do notation, when assinging variables via `<-`: is pattern matching allowed on the lefthand side of that arrow?
14:32:39 <jle`> what happens when you try?
14:33:02 <AWizzArd> jle`: I saw an example here: http://haskell-distributed.github.io/tutorials/1ch.html
14:33:11 <AWizzArd> Right t <- createTransport "127.0.0.1" "10501" defaultTCPParameters
14:33:25 <jle`> mhm
14:33:30 <jle`> that's definitely a-ok
14:33:40 <jle`> > do { (x, y) <- Just (3, 5); return x }
14:33:42 <lambdabot>  Just 3
14:33:51 <jared-w> crucify_me: you're really getting caught up on actually making the function instead of just thinking abstractly about the types
14:34:04 <ReinH> As an aside, any odd number of consts is const. const const const const const const = const.
14:34:23 <jle`> AWizzArd: in fact i think in general, binding with <- is always pattern matchiful
14:34:28 <kadoban> AWizzArd: Sure, though you usually then want to be pretty careful that your patterns are never going to fail. Failed pattern matches call 'fail' which is a lot of the time pretty not great.
14:34:36 <jle`> the default `x <- ...` is just matching with the wildcard pattern
14:34:37 <SepakoRayl> stmt            →   exp ;                                                          |    pat <- exp ;                                                   |    let decls ;                                                     |    ;
14:34:48 <ReinH> I feel like that problem isn't a great problem tbqh
14:34:56 <AWizzArd> ok
14:35:00 <SepakoRayl> sorry for the bad formatting
14:35:05 <jle`> AWizzArd: you can see how pattern matches are desugared in te haskell report, but it's pretty straightforward
14:35:11 <ReinH> "What is the type of this type salad?"
14:35:57 <crucify_me> jared-w, ok thanks I'll forget about it for now, give my OCD a rest. so , simply put, what is the lesson behind that type signature with the tuple syntax?
14:36:03 <ReinH> It also depends on knowing that 2 :: Num a => a.
14:36:23 <jle`> AWizzArd: all bindings in haskell are on patterns, i believe
14:36:35 <jle`> AWizzArd: so if you do `foo x = x * 3`, that's binding a result to the wildcard pattern 'x'
14:36:44 <jle`> *binding an argument
14:37:35 <ReinH> crucify_me: (Num a, Num b) => ... just means that in the type to the right of the =>, a and b are constrainted to be instances of Num.
14:37:49 <ReinH> It's just a list of multiple constraints.
14:39:27 <ReinH> @undo do { p <- k; return p; }
14:39:28 <lambdabot> k >>= \ p -> return p
14:39:44 <ReinH> AWizzArd: <- is sugar for a bind and a lambda, and lambdas are sugar for case statements, and case statements do pattern matching.
14:39:53 <ReinH> Almost everything is sugar for case statements.
14:40:00 <ReinH> So almost everything does pattern matching.
14:40:05 <crucify_me> ReinH, ok thanks, so to the right of => that takes one a and one b, and returns a b. what sort of function would that look like ?
14:40:12 <ReinH> Pattern matching is the most fundamental concept in Haskell.
14:40:21 <crucify_me> *and returns a 'b'
14:40:51 <ReinH> crucify_me: glguy gave you an example.
14:41:17 <crucify_me> ReinH, ok thanks checking on glguy 's example
14:41:32 <ReinH> combine _ x = x + 1 is an example
14:41:44 <ReinH> There are an infinite number of examples, but they are restricted in two ways
14:41:57 <ReinH> combine x y can not use the x, and it can only use the members of the Num typeclass to interact with the y
14:42:15 <glguy> :t let combine a b = b+1 where _ = a+1 in combine
14:42:17 <lambdabot> (Num t, Num a) => t -> a -> a
14:42:34 <ReinH> FSV of "use", that does not use the x.
14:42:39 <ReinH> *FSVO
14:43:10 <ReinH> Ok, it can do Num-y things to the x, but it must then throw that away.
14:43:15 <crucify_me> glguy ReinH thanks ! let me work on that.
14:43:27 <EvanR> combine _ (x - 1) = x 
14:43:34 <EvanR> n minus k pattern
14:43:37 <ReinH> There's no way to combine the a with the b, so the function is at best poorly named.
14:43:55 <crucify_me> I tossed the name and called it func
14:43:57 <ReinH> EvanR: Desugars to Num-y things.
14:44:01 <crucify_me> https://ptpb.pw/i4Gg
14:44:07 <glguy> There aren't n minus k patterns
14:44:28 <ReinH> In my headcanon there are.
14:44:44 <crucify_me> headcanon !
14:44:53 <EvanR> haskell deleted n+k patterns
14:45:00 <glguy> and n+k didn't include n-k
14:45:10 <ReinH> Oh, right.
14:45:12 <ReinH> Also that.
14:45:17 <EvanR> elixir put them back.. x <> y pattern
14:45:18 <crucify_me> or that the Everlasting did not fix His cannon 'gainst self-slaughter (Hamlet)
14:45:46 <AWizzArd> foo :: Maybe (IO Int)   with the implementation:   foo = Just (return 22)         now we have   bar :: IO Int   with   do   Just x <- foo      print x     return 5     (please add the right indentation).
14:45:59 <ReinH> Wrong canon-homophone though.
14:46:29 <ReinH> AWizzArd: if you want to show us code, you can use lpaste or gist or some other pastebin.
14:46:35 <ReinH> @lpaste
14:46:35 <lambdabot> Haskell pastebin: http://lpaste.net/
14:46:38 <glguy> AWizzArd: That doesn't look right. It'll be better to format the code on a pastebin if we're going to discuss it
14:46:49 <AWizzArd> Okay, one sec.
14:46:55 <ReinH> Since Haskell is indentation-sensitive, "please add the right indentation" is risky business.
14:47:13 <jle`> AWizzArd: that doesn't work, foo has to be an IO action
14:47:21 <glguy> For your example to make sense you'll probably need to switch foo's type to IO (Maybe Int)
14:47:23 <jle`> it'd work if foo :: IO (Maybe Int)
14:47:23 <crucify_me> I forget the spelling, play on words cannon and canon, a violent implement of God opposed to suicide
14:48:00 <jle`> AWizzArd: `x <- return (Just 10)` would bind x to Just 10
14:48:11 <jle`> AWizzArd: `Just y <- return (Just 10)` wouild bind y to 10
14:48:14 <ReinH> crucify_me: I think it's actually canon in the text.
14:48:15 <AWizzArd> http://lpaste.net/4533673009851924480
14:48:23 <ReinH> And refers to, well, his canon against self-slaughter.
14:48:53 <jle`> AWizzArd: yes that doesn't work; foo has to be an IO action
14:49:14 <ReinH> This is Hamlet's first soliloquy, and also is first suicidal ideation, and the point is that God doesn't allow it so he feels trapped.
14:49:18 <jle`> AWizzArd: do you see how (x, y) <- return (10, 33) binds x and y to 10 and 33 ?
14:49:26 <ReinH> Anyway, that's slightly off topic for #haskell
14:49:35 <AWizzArd> jle`: yes
14:49:39 <jle`> so it's the same thing here
14:50:00 <AWizzArd> jle`: I agree.  But how did this example above work?    Right t <- createTransport "127.0.0.1" "10501" defaultTCPParameters
14:50:08 <jle`> the same way...
14:50:12 <AWizzArd> createTransport has to be an IO action too, it was in main.
14:50:14 <jle`> all patterns are just patterns
14:50:20 <AWizzArd> So how can one pattern match on Right?
14:50:28 <jle`> the same way one pattern matches on tuples
14:50:29 <ReinH> > do Right t <- return 1; return t;
14:50:31 <lambdabot>  error:
14:50:31 <lambdabot>      • Could not deduce (Num (Either t0 b))
14:50:31 <lambdabot>        from the context: (Num (Either t b), Monad m)
14:50:34 <crucify_me> exactly. but the interesting thing to me is that God is conveyed wielding a canon against an act of violence ReinH   yes sorry 
14:50:37 <ReinH> Woops.
14:50:46 <jle`> > let (x, y) = (10, 3) in x + y
14:50:48 <lambdabot>  13
14:50:51 <jle`> > let Right x = Right 10 in x * 2
14:50:53 <lambdabot>  20
14:50:59 <jle`> behold, patterns :)
14:51:14 <ReinH> crucify_me: No, not a cannon. Canon, which in this case refers to the books that comprise the 'word of god'.
14:51:15 <jle`> > let (x:y:_) = [1,2,3] in x + y
14:51:17 <lambdabot>  3
14:51:30 <AWizzArd> How would pattern matching on Just in an IO monad work?
14:51:33 <ReinH> i.e., 'biblical canon'.
14:51:45 <jle`> AWizzArd: the same as a pattern match on a tuple...
14:51:49 <ReinH> It is a clever play on words by Shakespeare, though.
14:52:12 <jle`> they're both patterns
14:52:16 <jle`> to haskell there isn't any difference
14:52:37 <AWizzArd> jle`: okay, then I understand it now.
14:52:41 <AWizzArd> Thx. Makes sense.
14:52:44 <ReinH> @undo do { Just x <- foo; return foo; }
14:52:44 <lambdabot> foo >>= \ a -> case a of { Just x -> return foo; _ -> fail ""}
14:53:00 <jle`> AWizzArd: no problelm :)
14:53:03 <ReinH> Note the fail on a failed pattern match, which makes everyone sad.
14:53:15 <AWizzArd> My foo was wrong. I first tried   foo :: Maybe (IO Int)   but it needs to be  foo :: IO (Maybe Int)
14:53:19 <jle`> yes it's easy to forget that all bindings are pattern bindings
14:53:21 <jle`> AWizzArd: yes
14:53:28 <AWizzArd> kk
14:53:29 <jle`> you could accomplish the same thing with x <- foo
14:53:31 <jle`> case x of
14:53:34 <jle`>   Just y -> ...
14:53:44 <jle`>   Nothing -> error "um i didn't think this could hapen"
14:53:59 <ReinH> jle`: This is where my "everything is case statements" mantra comes in handy.
14:54:06 <crucify_me> ReinH but one cannot ignore the pun, since He 'fixed it against' , it's like, to me, a standoff
14:54:08 <jle`> all is case
14:54:11 <jle`> case is all
14:54:17 <crucify_me> 'gainst *
14:54:19 <ReinH> Can do bindings have pattern matching on the LHS of the <-? Yes, because they are case statements.
14:54:27 <ReinH> crucify_me: Yeah, it is well done.
14:54:53 <ReinH> Can let bindings have patterns? Yes, because they are* case statements.
14:54:55 <jle`> AWizzArd: this also makes sense if you consider how you'd typically desugar do notation
14:55:19 <jle`> AWizzArd: do { x <- foo; bar x }
14:55:28 <jle`> AWizzArd: is foo >>= \x -> bar x
14:55:33 <jle`> AWizzArd: do { Just x <- foo; bar x }
14:55:48 <jle`> AWizzArd: is foo >>= \(Just x) -> bar x        ... kinda
14:55:52 <glguy> ReinH: Is that * hiding a 'not'?
14:55:54 <glguy> :-p
14:56:03 <ReinH> I believe it is technically foo >>= \x -> case x of { x -> bar x } ;)
14:56:07 <ReinH> glguy: It's hiding let generalization.
14:56:24 <ReinH> Well, maybe the x isn't shadowed.
14:56:54 <ReinH> glguy: It frustrates me that the report defines the semantics of let in terms of case statements and then at the end says, effectively, "lol jk".
14:57:22 <jle`> to be fair this let vs. case thing is not just a haskell thing but a hindley milner thing in general, i believe
14:57:42 <jle`> (i'm not sure what standard of fairness i'm referring to)
14:57:56 <glguy> fairness 2010?
14:57:58 <ReinH> A Martin-Lof thing, even.
14:58:33 * glguy hands ReinH a ö
14:59:01 <danilo2> Hello guys! For last 2 days I'm trying to figure out performance problems in a code looking very simple. However I got results that seem just like weird GHC optimization errors. Would anybody be so nice and help me with debugging it? I would be more htan thankful for any hints / help
14:59:05 <algebra> ReinH: Why is that case needed? does every function (\x -> _) ~ (\x -> case x of {t -> _})
14:59:15 <danilo2> I was trying inspecting core / running performance testing (with RTS -p), but I got to the point where I do not know what is happening with the performance and why is it happening
14:59:29 <danilo2> Here is the code. It looks long but it really isnt. It defines a State wrapper (which mysteriously works faster than pure State), strict Either and EitherT and just runs a simple loop: http://lpaste.net/2972166975704268800
14:59:42 <danilo2> there are comments in the code telling whats going on and why with a set of 3 performance related questions / observations on the end
15:00:01 <danilo2> If anyone could look at it, I would be more than thankful! :))
15:00:28 <crucify_me> your comment is helping this sink in. that's the jist of it, ReinH ? " combine x y can not use the x, and it can only use the members of the Num typeclass to interact with the y "
15:01:08 <ReinH> algebra: that's just the definition of desugaring for do
15:01:19 <ReinH> But yes, lambdas desugar to case statements too
15:01:28 <algebra> ReinH: ah I see, thanks!
15:01:42 <ReinH> Everything involving binding desugars to case statements.
15:01:58 <jared-w> Pretty much everything desugars to case statements because they're pretty easy to wire into a C-like language for assembly translation (I think)
15:02:24 <ReinH> Also because it's a convenient way to unify everything that can perform binding.
15:03:10 <ReinH> crucify_me: Consider a function f :: a -> b -> b
15:03:28 <ReinH> We know it either returns the b or it returns nonsense.
15:03:35 <ReinH> It has to ignore the a.
15:03:36 <crucify_me> got that
15:03:41 <crucify_me> ok
15:03:51 <ReinH> g :: (Num a, Num b) => a -> b -> b adds a few more things that can be done with the a and the b
15:03:54 <algebra> But it also has some other reasons? like (\x -> _). is semantically different from (\x -> case x of ..) right?
15:03:56 <ReinH> namely, the members of the Num typeclass
15:04:08 <ReinH> But the Num typeclass doesn't allow you to convert a Num a into a Num b
15:04:15 <ReinH> So in the end you can still only use the b
15:04:27 <ReinH> a Num a => a into a Num b => b, that is
15:05:04 <crucify_me> ok the book was very brief, I can roll with that thanks kindly ReinH 
15:05:24 <ReinH> crucify_me: Well, the book didn't ask you to implement the type, just to reason about the type.
15:05:50 <crucify_me> ok all well taken thanks for the Shakespeare too
15:07:59 <ReinH> algebra: I'll quote from the report.
15:08:05 <ReinH> "Patterns appear in lambda abstractions, function definitions, pattern bindings, list comprehensions, do expressions, and case expressions. However, the first five of these ultimately translate into case expressions, so defining the semantics of pattern matching for case expressions is sufficient."
15:08:29 <ReinH> That's section 3.17 of the 2010 report, but iirc it appears verbatim in the original report as well.
15:08:53 <algebra> Okay thanks. I was just trying look that up ;)
15:09:36 <ReinH> Then the sections describing the semantics of the other things describe their transformation into case statements.
15:09:56 <ReinH> And actually, let bindings are a form of binding that doesn't desugar into case statements, but it almost does.
15:10:43 <ReinH> case isn't polymorphic enough for let generalization, but syntactically there is a desugaring into case statements.
15:10:57 <ReinH> it just doesn't work semantically, i.e., it would work if case had different semantics.
15:12:17 <dolio> "Pattern bindings" are the let part, I believe.
15:12:31 <ReinH> Or the where part?
15:12:35 <dolio> Yeah.
15:12:46 <ReinH> Well, where might fall under function definitions
15:12:54 <ReinH> since they are just scoped function definitions
15:13:15 <dolio> You can define things that aren't functions in where.
15:13:16 <ReinH> How does GHC actually handle let generalization?
15:13:35 <ReinH> dolio: but do those things have pattern bindings?
15:13:55 <dolio> Pattern bindings are like 'let (x, y) = e in ...'
15:14:02 <ReinH> Right.
15:14:19 <ReinH> I meant non-function definitions in where bindings
15:14:40 <phadej> you can do (x, y) = (1,2) on top level too in module (which is where clause)
15:14:52 <ReinH> Oh, right, you can always do that.
15:14:54 <dolio> 'x = 5' is not a pattern binding, technically, I think.
15:15:54 * hackagebot cloud-seeder 0.1.0.0 – A tool for interacting with AWS CloudFormation – https://hackage.haskell.org/package/cloud-seeder
15:15:59 <dolio> Anyhow, 'bindings' per se don't get turned into case. All forms of matching get turned into case.
15:16:18 <dolio> `\x -> ...` binds x, but there's no translation to case to be done.
15:16:28 <ReinH> @undo do { x <- 4; return x; }
15:16:28 <lambdabot> 4 >>= \ x -> return x
15:16:43 <ReinH> Right.
15:16:56 <algebra> dolio: yeah that was my understanding as well
15:17:45 <dolio> Or, they don't even need to be 'turned into' case, I suppose, but their semantics is defined in terms of translation to case.
15:20:46 <jle`> dolio: if x = 5 is not a pattern binding, what about Just x = Just 5 ?
15:20:57 <dolio> That is a pattern binding.
15:21:07 <joehh> hi, how do I debug cabal not finding my profiling libraries?
15:21:28 <algebra> dolio: how do it figure out tho? which one is pattern binding and which one is not
15:21:39 <algebra> does*
15:21:48 <joehh> I can see the p_hi files in my pkgroot, but cabal does not seem to see them
15:22:18 <dolio> Pattern bindings are thing where the left hand side is a non-variable pattern.
15:22:19 <joehh> I get the error Failed to load interface for ‘Control.Monad.STM’ - Perhaps you haven't installed the profiling libraries for package ‘stm-2.4.4.1’
15:23:15 <algebra> okay that was obvious. Sorry :)
15:24:01 <danilo2> Hi! Is here anybody whou would like to tinker with GHC optimizations and think why something is slow ? :)
15:24:29 <danilo2> If so, I would love to talk with somebody about it, because I've got crazy results here 
15:34:01 * hackagebot SSTG 0.1.0.7 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
15:51:10 <jared-w> danilo2: what kind of results are you getting?
16:00:09 <lunon> What makes the `Behavior` in libraries like reactive-banana not meet the standard of continuous time? The discussion here https://www.reddit.com/r/haskell/comments/3z4nzi/defining_a_semantics_of_frp_without_continuous/ seems to draw a distinction between continuous time and dense time that isn't clear to me
16:02:22 <tom69> coming from c and some c++, how tough is haskell to get up to speed with?
16:06:16 <jared-w> A C/C++ background doesn't seem to matter much. Just treat it like an entirely separate paradigm and leave everything you ever knew about programming behind and you'll be fine
16:06:43 <tom69> ok, cool. is 'learn you a haskell' still an okay starting place?
16:07:04 <jared-w> What seems to be more important are people's ability to grasp lambda calculus, and mathematical/logical reasoning (but even then, that's only a rough indicator)
16:07:09 <jared-w> tom69: I personally dislike that one
16:07:18 <jared-w> @learnhaskell
16:07:18 <lambdabot> Unknown command, try @list
16:07:25 <jared-w> @wherehaskell
16:07:25 <lambdabot> Unknown command, try @list
16:07:58 <jared-w> https://github.com/bitemyapp/learnhaskell whatever
16:08:09 <jared-w> This link has some good free resources for learning haskell
16:08:54 <jared-w> For non-free resources, I like the haskellbook.com one and Richard Bird's "Thinking functionally with haskell"
16:12:06 <danilo2> jared-w: hi! I'm sorry I didnt notice your response! :)
16:12:38 <danilo2> jared-w: if you'll be so nice and take a look at this sample code, it would be super cool! :) http://lpaste.net/2972166975704268800
16:13:33 <danilo2> jared-w: I described in the code observations. In fact it looks long, but it isnt. It defines a Strict.State wrapper (which mysteriously works a lot faster than Stric.State itself) and defines strict either and eithert operations
16:15:06 <Welkin> the upenn course is good, but you need a book, too
16:15:32 <Welkin> the new book from Graham Hutton seems good. I just got a copy, but haven't read it other than skimming through it so far
16:15:56 <Welkin> some people like "Haskell from first principles", but it is pretty long at 1200+ pages
16:16:12 <jared-w> That one's also good. It's in between the Bird and the Haskell book in terms of how "pragmatic and practical" it is
16:16:46 <jared-w> Welkin: Well, it's 1200+ pages of good content. You learn about monads barely more than halfway through the book
16:17:53 <Welkin> learning about monads should not take that long
16:18:07 <Welkin> there is one essays that realy helped me understand them
16:18:07 <jared-w> Then there's foldable, traversable, Reader, State, you learn about parser combinators, monad transformers, in-depth laziness/thunks/observational stuff, practical things like the Map, Set, Sequence, Vector libraries, Criterion benchmarking...
16:18:15 <Welkin> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
16:18:36 <jared-w> There's an entire chapter on IO, and one for exceptions as well. Then lastly a small final project
16:19:02 <Welkin> there is a paper for IO that I like
16:19:08 <Welkin> "Lazy Functional State Threads"
16:19:17 <Welkin> there is really not book that can adequately cover haskell
16:19:24 <Welkin> not a single book*
16:19:28 <jared-w> The book is a bit verbose at first because it assumes no programming knowledge and it's /very/ complete in its introduction to the basics
16:19:47 <jeltsch> Is there a version of cabal-install that works with GHC 8.2.1 and Cabal 2.0.0.2?
16:20:06 <jared-w> I agree, but the haskell book makes a pretty solid covering of the pragmatics of it. I'm going over bird's book now to get some theory and 'functional thinking' skills
16:20:23 <jeltsch> cabal-install 1.24.0.2 requires a version of process that is older than the one delivered with GHC 8.2.1.
16:20:57 <jeltsch> And it also wants to use Cabal 1.24.2.0
16:23:14 <phadej> jeltsch: there isn't official one
16:23:25 <phadej> there is cabal-2.0 in hvr's ppa
16:23:29 <phadej> for Ubuntu
16:23:45 <jeltsch> phadej: I am not looking for a Ubuntu package, but for a source package.
16:24:03 <jeltsch> There is no newer cabal-install on Hackage.
16:24:15 <jeltsch> Only 1.24.0.2 and older.
16:24:16 <phadej> jeltsch: then the github.com/haskell/cabal and 2.0 branch is the best you can get atm
16:24:19 <Welkin> well considering ghc 8.2.1 just came out a couple days ago,
16:24:26 <Welkin> I wouldn't expect everything to work perfectly
16:24:47 <jeltsch> Welkin: I would expect Cabal and cabal-install to work with a newly released GHC.
16:24:48 <Welkin> you can always use 8.0.2
16:25:10 <jeltsch> Welkin: The point is that I want to try out GHC 8.2.1, in particular to see whether it still accepts my code.
16:25:10 <Welkin> jeltsch: it takes time to catch all the issues
16:25:32 <Welkin> I have gotten the bad luck of downloading a newly released cabal and having it be totally broken, only to have a new version with a fix released the same day
16:26:21 <phadej> Welkin: there is such bug atm too, https://github.com/haskell/cabal/issues/4624
16:26:43 <Welkin> I never upgrade right away
16:26:51 <Welkin> I usually wait a couple months at least
16:27:00 <Welkin> there will be bugs, it's just the nature of it
16:27:15 <Welkin> I can't imagine any libraries are using 8.2.1 features already
16:27:19 <Welkin> it's only been a few days
16:27:43 <jared-w> danilo2: I actually have no idea. You would probably have better luck asking in #ghc if it's indeed related to something the compiler is doing
16:27:44 <phadej> Welkin: http://hackage.haskell.org/package/singletons-2.3 :)
16:28:05 <jared-w> phadej: of course singletons is using 8.2.1 features already :p
16:28:19 <phadej> actually already for a month and a half
16:28:21 <danilo2> jared-w: I'm creating a well descibed bug report now. I do not thing we are able to explain the results im getting in any sensible way
16:28:53 <danilo2> jared-w: in fact it is a continuation of weird results I'm getting, here is the first part from 2 days ago: https://ghc.haskell.org/trac/ghc/ticket/14013
16:28:56 <jeltsch> Welkin: Again, my goal is to make my own libraries compatible with GHC 8.2.1, so that the problems that I have at the moment with cabal-install are avoided with my own code.
16:30:04 <phadej> jeltsch: you can compile cabal-install from github, or you can use precompiler hvr's builds
16:30:21 <phadej> jeltsch: I don't understand what's the problem with either approach?
16:30:37 <jeltsch> phadej: Are these precompiled builds only available as Ubuntu packages?
16:31:10 <phadej> jeltsch: there's also debian (and -head for osx: https://haskell.futurice.com/)
16:32:07 <phadej> http://downloads.haskell.org/debian/ <- debian, I'm not sure how recent these cabal-install builds 
16:32:12 <jeltsch> phadej: I do not want any distribution packages. I have just installed GHC 8.2.1 via the generic binary distribution.
16:32:12 <phadej> *are
16:32:30 <jeltsch> I mean I do not want any Linux distribution packages.
16:32:37 <jeltsch> I just want an executable.
16:32:44 <phadej> deb is tar.gz
16:32:48 <phadej> unpack it and extract the binary
16:33:16 <jeltsch> phadej: And this will work with any GHC 8.2.1 available via PATH?
16:33:17 <geekosaur> not exactly, the tar.gz (or tar.xz) is wrapped in an ar archive
16:33:32 <phadej> geekosaur: yeah, I always have to google how to unpack them
16:33:38 <phadej> jeltsch: it should
16:34:05 <phadej> dpkg -x cabal-install.deb /tmp/out
16:34:13 <jeltsch> phadej: Okay, but this is not cabal-install 2.0, because this does not exist yet, right?
16:34:33 <phadej> jeltsch: yes, but very close to what will be 2.0
16:34:46 <jeltsch> phadej: I will give it a try.
16:36:29 <phadej> jeltsch: hopefully it works!
16:36:38 <phadej> and you packages too
16:36:41 <phadej> your*
16:37:14 <srb> In CMM, can stores of different types alias?
16:37:18 <srb> *cmm
16:45:51 <parsnip> was there a way to build haskell packages faster by not ensuring it builds on every possible OS
16:46:23 <parsnip> i'm halfway through some build dependencies and at over an hour
16:48:12 <phadej> every possible OS? nothing does that
16:48:26 <phadej> rebuilding everything just takes a lot of time
16:48:51 <parsnip> sorry, thought i saw a blurp about how much time can be saved if you tell haskell not to build for as many platforms
16:50:03 <phadej> maybe different GHC versions on CIs (like travis)?
16:51:31 <phadej> cabal and stack only build for your platform (e.g. "linux x86_64"), cross compilation is something you have to ask for
16:57:43 <Welkin> lol
16:57:47 <Welkin> *every* OS?
16:58:00 <Welkin> or do you just mean linux, bsd, macos, and windows?
16:58:45 <parsnip> i remembered incorrectly, i thought someone here said that part of the reason builds are slow is cause the setting for being able to build on other OSes is on by default
16:59:09 <sm> parsnip: use --dry-run to see what it plans to (re)build, sometimes you can dramatically shorten the list by adjusting the stack.yaml to a resolver you already have installed
16:59:12 <parsnip> or that it can be a little faster. i think i'll just experiment next with building dependencies locally
17:00:05 <sm> oh, and if on CI be sure its caching is working
17:03:13 <sm> eg travis does not save any built deps in cache until the whole build succeeds, unless you change some setting
17:03:17 <parsnip> so checking `time stack build --only-dependencies hledger-web` on local vagrant
17:05:08 <parsnip> not really sure what travis and ci are enough to understand how i could use them in my goals. currently i sort of want to copy an executable around, but i also sort of want to copy around the dependencies so i can build on the fly, maybe at some point try editing some haskell on same server i use for budgeting #dreams
17:05:45 <sm> parsnip: I thought maybe you were talking about building on CI, ignore that part then
17:06:43 <parsnip> not sure if gzipping the haskell dependencies and copying around makes sense, i'm so in over my head i might get more out of "Try It And See^TM" then trying to articulate
17:07:41 <parsnip> in my made up imaginary world in my head, i wonder if i can have a docker build that i can pull into a machine that has a bundle of haskell dependencies. 
17:08:31 <sm> sure, in fact doesn't stack/fpcomplete provide something like that
17:08:42 <parsnip> oh?! 
17:09:47 <sm> but personally I think it's less work to just let stack do its thing for half hour or whatever it takes
17:10:51 * hackagebot propellor 4.6.0 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
17:10:58 <parsnip> more like 3 hours here, cheap VPS
17:11:27 <parsnip> i even have to attach a swap dealy to get `stack setup` to work
17:11:48 <sm> @quote FAQ memory
17:11:48 <lambdabot> FAQ says: To build/link on low memory machines: use -j1, +RTS -M500m -RTS, and/or build fewer dependencies at once. Avoid swap, it's too slow.
17:11:54 <parsnip> `sudo mkswap /dev/xvdb` etc
17:11:58 <parsnip> oho!
17:12:13 <borsec> Im fairly new to haskell and I was wondering if anyone knew somewhere with good exercises to help build experience using it
17:12:29 <sm> parsnip: I imagine it's much easier and quicker to temporarilty increase the vps ram 
17:13:14 <parsnip> iiuc, i have to stop the machine, change instance, start, build, stop, change instance, start, any time i want to build
17:13:31 <sm> true
17:13:35 <parsnip> with the web GUI is how i do at this point
17:13:52 <Welkin> borsec: the upenn course, cis 194 I think
17:13:58 <Welkin> @where learnhaskell
17:13:58 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:14:24 <borsec> welkin: thank you!
17:19:12 <parsnip> what is the `-j` in the memory FAQ? 
17:19:17 <parsnip> *`-j1`
17:19:30 <sm> parsnip: tells stack to build one thing at a time
17:20:03 <parsnip> thanks
17:20:19 <sm> here's an example of -j and "build fewer things at once": stack -j1 install hledger && stack -j1 install hledger-ui && stack -j1 install hledger-web
17:21:03 <sm> the +RTS trick requires that you build stack in a special way.. which you don't have the memory for, so ignore that :)
17:21:19 <parsnip> dang
17:23:16 <sm> but seriously, on linode at least, I would crank up to many G of ram, build for 10m, and reset it, and probably pay a few cents
17:24:35 <parsnip> i might consider having a separate instance for building the dependencies, so i could dedicate a mostly off larger VPS, then see if scp is not too slow
17:24:38 <sm> GHC and related tools' memory use is a bit of a problem
17:24:43 <sm> but getting better hopefully
17:25:23 <sm> some people recommend building on a larger local machine and copying binaries to the server
17:25:37 <parsnip> aha, you say binaries too! 
17:26:03 <parsnip> i was given a hard time for that, i don't when to say binaries, when to say executables, script, etc. 
17:26:09 <parsnip> *don't know when
17:26:10 <sm> ha
17:26:29 <tikhon> I'm perfectly happy calling scripts that happen to be in a text format "binaries"
17:26:30 <parsnip> maybe with haskell it _is_ a binary? 
17:26:36 <sm> executables = binaries + scripts
17:26:53 <parsnip> 5 syllables, yeesh
17:27:07 <sm> haskell also has non-compiled scripts
17:27:12 <sm> which are executable
17:27:31 <sm> but there's also a specific meaning for "executable" in cabal packages
17:31:09 <sm> parsnip: how much ram are you currently building in, if I may ask ?
17:32:33 <parsnip> .5 G on VPS, i think i have 4 G on macos, not sure what i have vagrant set to. i think i'm going to try using a VPS dedicated to being larger and being on for quick tasks only
17:33:46 <parsnip> once i get a time that i'm comfortable with, i'll experiment with copying the dependencies (or just the binaries?) around to slower machines
17:34:58 <parsnip> basically, i want to toy with the idea of quickly getting to different points on the spectrum between binaries and modifying the source of the binary that i'm using. 
17:36:00 <trigone> hi, i used hlint and got this weird tip: Found:  module Main where Why not:   module Main (module Main) where
17:36:17 <sm> to rebuild the binary, I think stack/cabal need a package db populated with all the deps, built for the local architecture
17:36:18 <trigone> i don't get the part where i put "module Main" inside the export list
17:37:04 <parsnip> sm: is copying .stack between two ubuntu-16.04s not going to work? 
17:37:06 <sm> you could try copying that package db between machines of same arch, but it sounds fragile
17:37:13 <sm> sure, try it
17:37:14 <parsnip> yeah
17:37:17 <parsnip> :)
17:38:06 <sm> trigone: that means "export everything defined in Main"
17:38:46 <trigone> sm: is that not implied when there is no export list?
17:39:07 <sm> I'd have thought so
17:39:51 <trigone> that's why it's weird. i don't really see the point, it's not more readable since there's only one interpretation of no export list...
17:40:16 <sm> maybe it affects the exporting of typeclass instances, which can be a bit obscure
17:40:49 <danilo2> Hi! I've just created a GHC bug report regarding a very strange performance results we're getting here. If anybody would be so nice and would try to help us understand what's going on under the hood and what workarounds exist, we would be very thankful
17:40:51 <trigone> sm: ... maybe
17:40:56 <danilo2> The bugreport is here: https://ghc.haskell.org/trac/ghc/ticket/14035
17:42:04 <glguy> there's no way to affect type class instance export with export lists
17:43:10 <glguy> the module exports all instances it defines and those the modules it imports export
17:43:14 <trigone> glguy: so what's the deal then with this tip?
17:43:17 <sm> ok
17:48:18 <sm> trigone - oh. https://github.com/ndmitchell/hlint/issues/350
17:55:13 <geekosaur> trigone, sm: 'module Main' will export only names defined in the module, not imported names
17:55:36 <geekosaur> whereas an empty export list exports everything including reimported names
17:55:42 <geekosaur> *imported
17:55:53 <geekosaur> iirc
18:04:46 <cheater> @hoogle (a -> a -> b) -> [a] -> b
18:04:46 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
18:04:46 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
18:04:46 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
18:05:32 <cheater> @hoogle (a -> a -> a) -> [a] -> a
18:05:32 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
18:05:32 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
18:05:32 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
18:05:38 <cheater> nah..
18:06:32 <cheater> if i have [a] and f :: a -> a -> a, and want a1 `f` a2 `f` ... an, then is there a better way to do this than to split off the head of [a] and run foldl on the tail?
18:09:12 <geekosaur> > foldr1 f [a,b,c,d]
18:09:15 <lambdabot>  f a (f b (f c d))
18:09:43 <geekosaur> > foldl1 f [a,b,c,d]
18:09:45 <lambdabot>  f (f (f a b) c) d
18:12:58 <parsnip> is something like this going to speed up setup on small VPS? https://github.com/commercialhaskell/stack/blob/master/etc/dockerfiles/stack-build/lts-8.0/Dockerfile
18:13:48 <jared-w> parsnip: Depends on what you mean by "speed up setup" and what you're wanting to do with the VPS
18:15:21 <parsnip> i'm imagining maybe i put some of the items i was considering putting in a gzip `stack setup` and  `stack build --only-dependencies hledger-web` and if i put it in a docker image it might clean up the workflow a little.
18:18:59 <parsnip> ugh, haskell makes a VPS 8 times more expensive :(
18:19:18 <Clint> through osmosis?
18:19:40 <cheater> :t foldl1
18:19:42 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
18:19:46 <cheater> oh right foldl1
18:19:50 <cheater> thanks geekosaur
18:20:03 <cheater> although i guess not worth the mental overhead of learning yet another function
18:21:46 <parsnip> cheater: foldl1 is more complicated than foldl
18:21:50 <parsnip> *not more
18:23:32 <parsnip> it's like foldl f z a is like foldl1 f (a:z) or something
18:23:54 <parsnip> wait, i forgot the symbols
18:24:09 <Axman6> I would say it is mor ecomplicated, but only because it can throw exceptions
18:24:35 <vktec> What's the most idiomatic way to process a continuous sequence of user input? I saw one person approach the issue by using getContents and map (since getContents is lazy), but my input comes from a different source which is more like getChar (ie. not continuous, and therefore also not lazy)
18:25:38 <jared-w> vktec: there's 'forever' and 'while'-like control flow constructs for do notation iirc
18:28:14 <vktec> jared-w: Got a source for that? I can't find anything
18:29:58 <sm> geekosaur: ah! that's it, thanks
18:30:54 <jared-w> :t forever
18:30:55 <lambdabot> Applicative f => f a -> f b
18:31:30 <EvanR> vktec: you could use async to fork a thread that does getChar or whatever, reacts (execute IO), and recurses to repeat
18:32:05 <EvanR> or use forkIO directly
18:32:14 <jared-w> > forever $ putStrLn "this will print forever"
18:32:16 <lambdabot>  error:
18:32:16 <lambdabot>      • No instance for (Typeable b0)
18:32:16 <lambdabot>          arising from a use of ‘show_M832020416425917781921014’
18:33:30 <vktec> jared-w: Thanks. Any way to break out of that on certain events? I'd like my program to exit at some point :D
18:34:09 <EvanR> if you use my suggestion, you can throw an exception to exit, which some other thread can react to
18:34:25 <EvanR> or if you use explicit recursion, just dont recurse
18:34:51 <EvanR> but we are strictly expanding from the original question about "process a continuous sequence of inputs"
18:35:10 <EvanR> and getting closer toward, arbitrary IO program
18:35:14 <Welkin> libraries like SDL handle it quite well
18:35:24 <vktec> I don't need to use threads. Nothing changes until user input is received, so it's fine to hang.
18:35:26 <Welkin> it has cross-platform input handling
18:35:38 <EvanR> then do everything but the forking
18:36:01 <EvanR> Welkin: this is sort of besides the point of the question i think, which was about control flow
18:36:07 <vktec> I'm using recursion at the moment, but it seems a little inelegant, since Haskell already has lazy evaluation and a slew of list wrangling functions
18:36:19 <vktec> Welkin: Thanks, but I've already got a source for my user input
18:36:29 <vktec> As EvanR says, this is more about control flow
18:36:34 <EvanR> using lazy list processing for this situation is "inelegant" in my opinion
18:36:40 <vktec> Okay
18:36:47 <EvanR> you dont actually have an infinite list of user inputs to foldr over
18:37:32 <EvanR> you presumably have an IO action to block, possibly eventually return a value, or possibly throw an IO exception
18:37:49 <vktec> Yeah
18:38:10 <vktec> So stick with recursion then?
18:38:11 <EvanR> so a recursive IO program would be right... and you can write a wrapper for this
18:38:51 <EvanR> solution getInput callback = forever (getInput >>= callback)
18:39:19 <EvanR> IO exception to exit
18:39:28 <EvanR> equivalently, exitSuccess from System.Exit
18:41:47 <vktec> I'll probably stick with explicit recursion. I don't like the idea of having to throw an exception to exit, and I'd prefer not to use exitSuccess since that means I can't put any cleanup code in main
18:42:29 <EvanR> well, a more complex wrapper can do more customized things to end
18:42:52 <EvanR> theres no less than 15 ways in this package https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
18:43:09 <EvanR> but i never use these, because i keep changing my mind about how to do the exiting, so i usually just do recursion
18:43:44 <EvanR> e.g. whileJust_ :: Monad m => m (Maybe a) -> (a -> m b) -> m ()
18:44:21 <EvanR> one action returns a valid next item, perhaps after pre-processing it, then use the callback, then repeat. until the first action returns Nothing
18:44:36 <EvanR> lets you exit if the item itself is the thing that tells you to end
18:44:42 <EvanR> clearly doesnt work in all situations
18:44:48 <EvanR> programmed with explicit recursion
18:45:38 <EvanR> if you abuse this in IO to check a sentry IORef or something, now i question to "elegance" :)
18:45:49 <EvanR> i question the elegance
18:46:35 <vktec> That package does look handy. I'd use it if I couldn't do the same thing myself with a couple more lines of code and one less dependency :)
18:47:23 <vktec> EvanR: Haha, don't worry. No mutable state to be found in this program so far
18:48:23 * hackagebot rtcm 0.2.1 – RTCM Library. – https://hackage.haskell.org/package/rtcm
18:49:15 <EvanR> vktec: i know... that package annoys me so much :)
18:50:37 <vktec> It's got some handy functions though. I'd definitely use it if it were part of the standard library
18:51:25 <vktec> Anyway, it's getting late here. I'm off to bed
18:52:27 <trigone> hi, i'd like your opinion on which version of a simple function is better? code and a bit more explanation -> https://pastebin.com/KGJsKpAN
18:53:21 <trigone> btw is there a way to update a pastebin
18:53:41 <Welkin> we use lpaste
18:53:45 <Welkin> @lpaste
18:53:45 <lambdabot> Haskell pastebin: http://lpaste.net/
18:53:55 <Welkin> you can edit them, add annotations, etc
18:54:07 <Welkin> and it has syntax highlighting
18:54:09 <MarcelineVQ> trigone: only clone afaik
18:54:16 <trigone> Welkin: hey thanks :)
18:54:36 <trigone> Welkin: do i transfer this specific paste?
18:55:04 <Welkin> sure
18:55:19 <trigone> also just to be sure: can i use interchangeably ("" and []) in pattern matching?
18:55:59 <geekosaur> trigone, "" will force type String (or IsString s => s if OverloadedStrings pragma enabled)
18:56:10 <geekosaur> s/pragma/extension/
18:56:44 <geekosaur> so you can always replace "" with [] but you can't necessarily go the other way
18:57:12 <trigone> geekosaur: yeah i meant in the case of String(-like) ofc
18:58:12 * hackagebot sbp 2.2.10 – SwiftNav's SBP Library – https://hackage.haskell.org/package/sbp
18:58:14 <trigone> thx :) it does make things much clearer
18:58:43 <trigone> so, i transfered the thing here: http://lpaste.net/357222
18:59:52 <trigone> > 't':"est":[]
18:59:54 <lambdabot>  error:
18:59:54 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
18:59:54 <lambdabot>        Expected type: [Char]
19:00:03 <trigone> > ('t':"est"):[]
19:00:05 <lambdabot>  ["test"]
19:02:29 <trigone> nobody for my question?
19:04:35 * hackagebot bioinformatics-toolkit 0.3.2 – A collection of bioinformatics tools – https://hackage.haskell.org/package/bioinformatics-toolkit
19:04:35 * hackagebot rtcm 0.2.2 – RTCM Library. – https://hackage.haskell.org/package/rtcm
19:06:41 <LordBrain> anyone have experience with JuicyPixels?
19:06:57 <LordBrain> I have a question about (Image Pixel8)
19:07:26 <LordBrain> i want to convert a jpg file to something like a one-bit-per-pixel tiff
19:08:22 <nshepperd> trigone: i prefer the first version. there's no performance advantage in keeping the head separate, btw, it costs just as much to unpack a tuple as a cons cell (ie. not much at all)
19:09:00 <LordBrain> at a glance,  Pixel8 looks like it is 1 bit per a byte, but i notice that the code to convert it to tiff uses TiffMonochrome as the TiffColorSpace
19:09:21 <LordBrain> does TiffMonochrome imply 1 bit per pixel?
19:12:16 <trigone> nshepperd: k thanks :) i also realized i was using a foldr on a list, which in theory is bad, but at the same time, a foldl with the same type of algorithm would require creating a list from the right, which is hardly efficient, unless i use a reverse on the mirror of the result. what would be best, foldr or foldl + reverse?
19:12:58 <butterthebuddha> Any times on going from [1, 1, 2, 3, 4, 5, 5, 6] -> [(1, 2), (2, 1), (3, 1), (4, 1), (5, 2), (6, 1)]
19:13:14 <butterthebuddha> Essentially a tuple -> (element, num of times elem appears in list)
19:13:38 <c_wraith> butterthebuddha: check out Data.List.group
19:14:28 <butterthebuddha> That's very helpful, thanks c_wraith 
19:14:44 <butterthebuddha> Does the list have to be sorted?
19:15:04 <nshepperd> trigone: foldr is best here
19:15:07 <c_wraith> group only looks at adjacent elements.  So for your case, if the input can be in any order, you should probably sort it
19:15:23 <trigone> nshepperd: how could i tell?
19:15:30 <c_wraith> trigone: foldr doesn't start from the tail of the list.  It starts at the head of the list, just like foldl
19:16:19 <butterthebuddha> Okay, thanks
19:17:19 <geekosaur> > map (head &&& length) . group . sort $ [1,1,1,2,2,3,4,4,4,5,5,6,6,3,7,7,1]
19:17:21 <lambdabot>  [(1,4),(2,2),(3,2),(4,3),(5,2),(6,2),(7,2)]
19:17:22 <nshepperd> trigone: foldr is ideal if the folding function is productive. that is, if it returns a constructor *before* looking at the accumulator
19:18:54 <nshepperd> (it's also ideal in other situations, but this one is relevant)
19:18:54 <jared-w> Why would foldr on a list be bad?
19:19:20 <glguy> > foldr (\x xs -> x) (error "z") ('a' : error "list")
19:19:22 <lambdabot>  'a'
19:19:39 <nshepperd> the r in foldr really means 'right associated' not 'starting from the right'
19:19:54 <trigone> nshepperd: i think i see what you mean
19:22:07 <trigone> nshepperd: so in short, it's efficient if there can be a kind of tail-recursive optimization (or if the folding function short-cuts in the middle of the fold)?
19:23:07 * hackagebot gnss-converters 0.3.2 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
19:24:31 <EvanR> that wouldnt necessarily make it efficient, but it could make it terminate at all
19:24:37 <nshepperd> trigone: more like, if you don't need to read the whole input to know how the output should start
19:25:06 <nshepperd> but shortcutting is a special case of that i guess, yes
19:26:03 <c_wraith> trigone: it's useful to think in terms of constructors and pattern-matching.
19:26:18 <c_wraith> trigone: evaluation is forced by the need to match a pattern.
19:26:28 <c_wraith> trigone: therefore, evaluation stops when it hits a constructor
19:26:43 <glguy> trigone: The two versions you pasted are not lazy enough to stream results
19:26:46 <c_wraith> trigone: (within the context of that single pattern match, at least)
19:27:26 <glguy> trigone: You'd need an irrefutable pattern for those to work out:  c `f` ~(w:ws)    or   c `f` ~(w,ws)
19:28:51 <trigone> glguy: what's an irrefutable pattern?
19:29:41 <glguy> trigone: Search for "irrefutable" in https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
19:30:09 <glguy> "It is sometimes helpful to distinguish two kinds of patterns. Matching an irrefutable pattern...
19:30:36 <trigone> glguy: i was looking up (at some other tutorial) and it was not very clear, but i'll look up your link thanks
19:31:01 <glguy> trigone: and then bring back whatever questions the reading leads to
19:32:41 <nshepperd> trigone: suppose your string starts with "abc", and you're splitting on '-'. then the split result *has* to be ("abc" ++ _) : _, for some values of _
19:32:49 <nshepperd> ie. the first group starts with "abc"
19:33:46 <trigone> glguy: if i get this right, an irrefutable pattern makes things more lax: there is no pattern-matching error reported unless the right side of the equation actually requires elements from the would-be deconstructed argument
19:34:12 <nshepperd> with foldr, your program can return that much of the answer before even reading past "abc"
19:34:33 <glguy> Yeah, so the other solution would be: f c ws | c == bomb = ("":ws); f c (w:ws) = (c:w):ws
19:34:38 <trigone> nshepperd: yeah but your wildcard is equivalent to a partial function, right?
19:34:57 <glguy> slightly different strictness
19:35:07 <glguy> can't return partially determined words
19:35:44 <trigone> nshepperd: you have (head `f` tail) transformed into (partialResult tail), right?
19:36:09 <trigone> glguy: you mean the other better solution?
19:36:13 <glguy> trigone: Yeah, matching against an irrefutable pattern always suceeds and the matching actually occurs when the variables in the pattern are evaluated
19:36:57 <glguy> trigone: I don't think that it's better, it's just worth understanding the differences
19:36:58 <nshepperd> trigone: huh?
19:37:16 <trigone> glguy: so it's only useful when you try to pattern match without purpose? is that not showing the code does not properly assess the cases?
19:37:37 <nshepperd> trigone: by _ i just mean some value that is unknown or hasn't been evaluated yet
19:37:39 <glguy> trigone: I don't know what you're asking
19:38:39 <trigone> glguy: oh i see, your melioration is about avoiding deconstruction when not needed, right?
19:39:49 <nshepperd> trigone: I annotated with productive versions http://lpaste.net/357222
19:40:00 <trigone> nshepperd: so... if i write x : y : rest, haskell will try writing x : y : [] and then use (++) to combine the two strings? that sounds terribly inefficient...
19:40:06 <glguy> trigone: Yeah, so with the combined solution we avoid a bit of destruction and have something that can stream results: f c ws | c == bomb = ("":ws); f c ~(w:ws) = ((c:w):ws)
19:40:45 <glguy> trigone: No, that's not what x : y : rest means
19:41:04 <trigone> glguy: hm, i'm not sure why you use the ~ on the second equation, is destructuration not inevitable here?
19:41:23 <glguy> trigone: No, it's not
19:41:23 <nshepperd> trigone: nah, it just magically knows not to evaluate 'rest' until you need it
19:41:24 <trigone> in f c ~(w:ws) = (c:w):ws
19:41:31 <orion> Is anyone else having trouble bootstrapping cabal-install 1.24.0.2 on GHC 8.2.1? I tried adding "--allow-newer" to the configure arguments and I'm getting compilation errors: https://gist.github.com/centromere/a558dcb1acd5c4636de90b88506197a5
19:41:56 <trigone> nshepperd: so it does not create "abc" until _ is defined, right?
19:42:51 <trigone> glguy: we have to append to w, how can we not need in every cases destructuration of (w:ws)?
19:42:57 <glguy> trigone: >>> head $ head $ split ' ' ('a':undefined)  ==evaluates to==> 'a'
19:43:12 <glguy> It's up to the consumer how much will actually be used
19:45:04 <trigone> glguy: hm right... laziness... it's pretty weird to have lists that should be hard to append to the right, yet when evaluating a thunk at the right end of one, you can add new elements that more or less weren't in the list... of course you already traversed the list anyway so i guess it's the same...
19:45:21 <nshepperd> trigone: let me rephrase. the split result has to be ('a':'b':'c':_) : _
19:45:47 <trigone> nshepperd: yeah, i got what you wanted to say, i had sorta forgotten laziness :
19:45:47 <EvanR> lists are easy to append to the right. just write the list from right to left
19:45:48 <trigone> :)
19:46:05 <EvanR> or turn your computer around 180 degrees
19:46:08 <trigone> EvanR: cheater
19:46:10 <nshepperd> lol
19:46:47 <EvanR> (the left/right isnt the critical characteristic involved)
19:46:57 <EvanR> (bonus... wtf is then)
19:47:19 <trigone> critical characteristic involved... in what?
19:47:36 <EvanR> list performance of certain things
19:48:31 <trigone> hm
19:48:32 <EvanR> > last ([1..9999] ++ [10000])
19:48:35 <lambdabot>  10000
19:48:52 <EvanR> its pretty easy to append heh...
19:50:44 <trigone> EvanR: that's laziness... on internal, i guess that ([a] ++ [b]) without further forcing evaluation mostly amounts to cutting your string in two and storing the two bits into a tuple/product. so obviously accessing the second bit won't be hard, but that's cheating too...
19:51:08 <EvanR> i forced it
19:51:24 <EvanR> i meant to call out that its easy to program it
19:51:46 <trigone> @src last
19:51:46 <lambdabot> last [x]    = x
19:51:46 <lambdabot> last (_:xs) = last xs
19:51:46 <lambdabot> last []     = error "Prelude.last: empty list"
19:51:59 <EvanR> so its about as easy as .push or similar
19:52:22 <EvanR> last traverses the list from beginning to end
19:52:38 <trigone> EvanR: well then the point maybe is speed more than possibility. it's not bc you can that it won't be more costy on big strings...
19:52:45 <nshepperd> @src (++)
19:52:45 <lambdabot> []     ++ ys = ys
19:52:45 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:52:45 <lambdabot> -- OR
19:52:45 <lambdabot> xs ++ ys = foldr (:) ys xs
19:53:16 <EvanR> yes
19:53:31 <EvanR> and theres things you can do that make it even more costly
19:53:40 <EvanR> like (++ [foo]) in a loop
19:54:17 <trigone> EvanR: in a loop?
19:54:49 <EvanR> 1 instance of [1..1000000] ++ [foo] is pretty good though because of what nsheppard conjured
19:55:05 <EvanR> last consumes the lazy result of ++
19:55:32 <nshepperd> xs ++ ys costs you one 'evaluation step' for each element of xs
19:56:07 <EvanR> and not ys
19:58:06 <nshepperd> you pay that cost the first time that you look at the first (length xs) elements of the result
19:59:14 <nshepperd> eg. you have "abc" ++ "xyz" and you want to know what the first element is. well you have to apply the second case of the (++) definition, which says that it is 'a' : ("bc" ++ "xyz")
20:00:06 <trigone> nshepperd: since last only goes through the list looking at its elements, not its structure, does (xs ++ ys) actually get allocated as one single list instead of a thunk after last has passed through it?
20:02:26 <trigone> i mean since last destructures the list as fast as it's built by (++), maybe (++) does not even build anything, and is merely used for equation reduction purposes?
20:02:53 <trigone> (not sure if i'm clear, arguably it's difficult to describe those things)
20:03:41 <nshepperd> 'normally' the resulting list parts will be garbage collected as fast as they are created
20:04:31 <nshepperd> sometimes it will be the case that (++) does not actually build anything, and the whole expression is compiled into some non-allocating loop
20:04:40 <nshepperd> that is called list fusion
20:04:46 <trigone> nshepperd: loop?
20:05:36 <nshepperd> trigone: as in, a loop in the actual assembly code, iterating over the input lists xs and ys
20:06:57 <jared-w> ReinH: I'm going over Bird's thinking functionally in haskell book right now. It's fascinating how thoroughly and frequently he treats 'undefined' in Haskell compared to other learning materials I've seen
20:07:02 <trigone> > [1..] ++ [3]
20:07:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:07:20 <trigone> > head $ [1..] ++ [3]
20:07:22 <lambdabot>  1
20:07:43 <nshepperd> btw, a great feature in ghci is the :print command
20:07:48 <trigone> jared-w: "treats undefined"?
20:08:02 <trigone> nshepperd: what does it do? prints the amount of things dethunked?
20:08:13 <jared-w> ReinH: also, /so/ much 'if then else'... 
20:08:37 <nshepperd> give it a variable and it will show you what it looks like right now, showing which parts haven't been evaluated yet
20:08:48 <nshepperd> trigone: yeah basically
20:08:52 <trigone> jared-w: i thought if then else was relatively discouraged
20:08:52 <jared-w> trigone: He goes to great pains to make sure people know it inhabits every type, even in the first few chapters. He also goes through a lot of pains to make sure people know how to account for it when counting inhabitants in types and functions and so on
20:09:30 <jared-w> trigone: It is, which amuses me because Bird is extremely liberal with its usage; he even uses nested if then else rather than guards in chapter 2 (or 3?) :p
20:10:24 <sm> parsnip: https://www.reddit.com/r/haskell/comments/6pr2ki/faster_redeploys_with_dockerbuildcacher_a_tool_we/ might be of interest
20:11:34 <trigone> jared-w: so... maybe he's got lasting scars from imperativism? unless he has not yet introduced the guards? and he's trying the method of "changing one thing at a time" to help those from imperative background into the functional cult?
20:13:01 <jared-w> nah he definitely doesn't have lasting scars, he's an excellent teacher
20:13:12 <jared-w> I'm leaning towards the 'changing one thing at a time'
20:13:50 <parsnip> i'm on a larger VPS where `stack setup` succeeds, but now in a dockerfile, it runs out of space :(
20:14:27 <trigone> jared-w: if you don't come from imperative background, all those tutorials must be really confusing. they could even make you distaste haskell before you even dived long. or, if you have no background, you'd have to first learn the imperative style in haskell just so they tell you later in fact you should not do it ^^
20:16:50 <trigone> i'm reading bits and pieces of real world haskell, and it's very weird to have to wait hundreds of pages before using monads properly, especially other monads beyond IO...
20:17:47 <sm> parsnip: sorry :(
20:18:13 <sm> it seems you could skip docker and remove one source of failure
20:20:09 <sm> bigmachine$ curl http://hledger.org/hledger-install.sh | bash  # <- should just work
20:20:18 <sm> bbl
20:21:22 <nshepperd> hm, hledger.org has wrong ssl certificate
20:21:24 <nshepperd> sad
20:22:25 * hackagebot sbp 2.2.11 – SwiftNav's SBP Library – https://hackage.haskell.org/package/sbp
20:23:36 <nshepperd> one day all these plain http bash install scripts are going to install nsa spyware on everyone's computers
20:23:56 <peddie> nshepperd: "are going to?"  :P
20:24:05 <nshepperd> already have :)
20:24:12 <ezyang> @tell guillaum1 It's not supported to import modules from bkp to ghci, unfortunately 
20:24:13 <lambdabot> Consider it noted.
20:24:26 <ezyang> @tell guillaum1 In fact, it's not really recommended to use bkp except for experimentation 
20:24:26 <lambdabot> Consider it noted.
20:37:01 <trigone> jared-w, what was the name of Bird's book you're reading?
20:37:25 <jared-w> "Thinking functionally with haskell", trigone 
20:37:42 <trigone> jared-w: thx :)
20:38:14 <jared-w> It's pretty basic
20:38:30 <jared-w> Not in a bad way, it /is/ an intro book
20:39:12 <trigone> jared-w: ends at what level? at any rate if you're right about his focus on bottom, it's still probably useful to me
20:39:37 <Axman6> I would be much happier with scripts that did FILE=$(mktemp); curl http://... -o $FILE; less $FILE; echo "Run sh $FILE" to execute"
20:41:19 <jared-w> trigone: I'm skimming through it right now for the emphasis on bottom and on laziness, mathematical reasoning about program behavior, and how to "think functionally"; I don't expect to learn much if anything
20:41:27 <jared-w> as far as "real haskell skills"
20:42:08 <jared-w> It ends with building an equational calculator, after making a parser with monads and learning how to use monads
20:45:18 <trigone> jared-w: hm kay thx
20:48:59 <trigone> i just read a weird thing i don't understand regarding lazy pattern matching at https://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
20:49:50 <trigone> there's this: (***) f g ~(x, y) = (f x, g y)    |||| and then apparently: (const 1 *** const 2) undefined == (1,2)
20:50:30 <trigone> i don't get how undefined can have been pattern-matched with ~(x,y) into basically, apparently, being (undefined,undefined)
20:50:40 <sm> nshepperd: thanks, I think my caddy lets encrypt certs are expiring (I don't know why they're not being auto-renewed..)
20:51:09 <trigone> i mean what i was reading was really not implying this behavior, and therefore does not actually tell what kind of rule all this follows...
20:51:43 <sm> and you're right, such scripts are bad. I recommend a more deliberate process on the download page
20:51:47 <trigone> unless... unless x and y are not even associated from the pattern-matching when f and g are called?
20:53:32 <trigone> > (***)
20:53:34 <lambdabot>  error:
20:53:35 <lambdabot>      • No instance for (Typeable a0)
20:53:35 <lambdabot>          arising from a use of ‘show_M221322144723630145324586’
20:53:51 <trigone> :t (***)
20:53:53 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
20:54:09 <trigone> @src (***)
20:54:09 <lambdabot> f *** g = first f >>> second g
20:54:20 <trigone> @src (>>>)
20:54:20 <lambdabot> Source not found. :(
20:55:13 <parsnip> :t (>>>)
20:55:15 <lambdabot> forall k (c :: k) (a :: k) (cat :: k -> k -> *) (b :: k). Category cat => cat a b -> cat b c -> cat a c
20:55:37 <monochrom> Oh wow, liblapack-dev depends on libblas-dev (OK), which depends on... a Fortran compiler!
20:55:44 <trigone> let (***) f g ~(x,y) = (f x, g y) in ((const 1 *** const 2) *** const 2) undefined
20:55:50 <trigone> > let (***) f g ~(x,y) = (f x, g y) in ((const 1 *** const 2) *** const 2) undefined
20:55:52 <lambdabot>  ((1,2),2)
20:58:30 <trigone> i'm not sure lazy patterns improve readability... and since bottom values are mostly hit when you encounter an error, is there not a risk to silence such errors? that makes sense since it's only silenced when it does not matter, but at the same time, it could still matter later, and therefore runtime errors could be more difficult to see... or not?
21:00:01 <trigone> > ((const 1 *** const 2) *** const 2) undefined
21:00:03 <lambdabot>  ((1,2),2)
21:01:03 * hackagebot gnss-converters 0.3.3 – GNSS Converters. – https://hackage.haskell.org/package/gnss-converters
21:16:16 <wespiser> hi folks, has anyone done statistics in Haskell, say t-tests or similar tests?
21:16:41 <peddie> @hackage statistics
21:16:41 <lambdabot> http://hackage.haskell.org/package/statistics
21:16:43 <wespiser> I'm looking at using the 'statistics' packages, particularly the 'cumulative' function, as well as 't-digest'
21:16:52 <wespiser> peddie: thanks!
21:17:02 <peddie> oops, sorry, should have waited :)
21:17:09 <Axman6> There's the statistics library (and also the foldl-statistics library which is more general, and slightly faster, but with less functionality)
21:17:35 <wespiser> yea, i want to look into Foldl, that looks really cool
21:18:11 <Axman6> I wrote the foldl-staistics library, but most of its implementation is cribbed wholesale from statistics
21:18:26 <Axman6> also my docs are pretty awful for thr package as a whole
21:18:39 <wespiser> Axman6: what was the itch it scratched?
21:18:42 <Axman6> (but individual folds are well documented)
21:18:50 <parsnip> error on docker build http://sprunge.us/WjfK
21:19:02 <wespiser> I basically need to integrate Z distributions many many many times
21:19:09 <Axman6> statistics insists on everything being a Vector Double, folds give much more flexibility
21:20:10 <wespiser> got it
21:20:19 <parsnip> oh, i should like bash into docker, reenact error, and read logs
21:21:02 <Axman6> I really want a version of foldl where the intermediate type inside folds is exposed - it'd be great to be able to serialise the state of a fold
21:21:04 <wespiser> by any chance, is there any support for bayesian statistics. In R I would use STAN/Bugs/Jags, I'm completely niave about haskell
21:21:55 <Axman6> probably best to start by searching hackage (and looking at how recently any packages yuo find have been updated)
21:22:00 <wespiser> Axman6: huh, serializing the intermediate state would have a large impact on my application, I would definitely benefit
21:24:19 <Axman6> I've wanted to have a system which stors data on disk in a large, flat tree, along with statistics about it, and being able to update those statistics when data is added would be fantastic
21:24:44 <Axman6> for most of my statistics stuff, I usually expose a fold which gives you the intermediate state
21:25:27 <wespiser> you should look at pipelinedb, which can store mean/variance and a couple other statistics for a 'STREAM' of incoming data
21:30:00 <ClaudiusMaximus> Axman6: sounds a bit like the zoom-cache package (iirc)
21:31:17 <mnoonan_> is there some clever way to have a forall scope over two different parameters, short of just tupling up the parameters?
21:31:44 <mnoonan_> e.g., an X t -> Y t -> Z version of (forall t. (X t, Y t)) -> Z
21:35:24 <Axman6> forall t. X t -> Y t -> Z?
21:37:08 <mnoonan_> Axman6: is it the same? am I just sleep deprived?
21:37:50 <mnoonan_> no, I don’t think it can be the same.. my type with the tuple is rank 2, but yours is rank 1, yeah?
21:39:04 <Axman6> ¯\_(ツ)_/¯
21:40:39 <nshepperd> (forall t r. (X t -> Y t -> r) -> r) -> Z
21:40:41 <nshepperd> :p
21:41:16 <nshepperd> basiclaly the same thing as tupling up though
21:42:08 <nshepperd> unfortunately 'exists t. X t -> Y t -> Z' doesn't real
21:42:53 <mnoonan_> nshepperd: you’re raining on my parade :)
21:43:30 <nshepperd> you could do (forall t. X t) -> (forall t. Y t) -> Z
21:44:53 <mnoonan_> nshepperd: I want to force the two ’t’s to be the same, though. tinkering with adding t ~ t’ contraints atm, but no luck yet..
21:45:39 <nshepperd> well, the callee can get values with different ts no matter what
21:46:15 <mnoonan_> not in the (forall t. (X t, Y t)) -> Z case, unless I’m missing something?
21:46:46 <nshepperd> foo :: (forall t. (X t, Y t)) -> Z; foo ex = let x1 = fst ex :: X String; y2 = snd ex :: Y Int in (x1, y2)
21:47:33 <nshepperd> just instantiate the universally quantified tuple twice and throw away the halves you don't need
21:48:09 <mnoonan_> ah, i see
21:48:53 <nshepperd> so I think (forall t. X t) -> (forall t. Y t) -> Z is basically the same thing
21:49:59 <nshepperd> but it might be slightly less efficient. or more efficient. depending on what's what
21:54:56 <xormor> > bmi body_mass_in_kg body_height_in_meters = (body_mass_in_kg) / (body_height_in_meters * body_height_in_meters)
21:54:58 <lambdabot>  <hint>:1:43: error:
21:54:58 <lambdabot>      parse error on input ‘=’
21:54:58 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
21:55:07 <xormor> > let bmi body_mass_in_kg body_height_in_meters = (body_mass_in_kg) / (body_height_in_meters * body_height_in_meters)
21:55:09 <lambdabot>  <no location info>: error:
21:55:09 <lambdabot>      not an expression: ‘let bmi body_mass_in_kg body_height_in_meters = (bod...
21:55:42 <Axman6> either > let ... in ... or @let ... if you want it to be saved for a random amount of time by lambdabot
21:55:44 <xormor> how should I make more "advanced" Haskell programs?
21:55:54 <nshepperd> xormor: it's @let with lambdabot. you can try things in private message also
21:56:02 <xormor> I want to learn functors.
21:56:11 <nshepperd> /msg lambdabot @let foo bar = baz
21:56:17 <Axman6> do you know what lists and Maybe are?
21:56:22 <xormor> > @let bmi body_mass_in_kg body_height_in_meters = (body_mass_in_kg) / (body_height_in_meters * body_height_in_meters)
21:56:25 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
21:56:29 <Axman6> no >
21:56:39 <xormor> @let bmi body_mass_in_kg body_height_in_meters = (body_mass_in_kg) / (body_height_in_meters * body_height_in_meters)
21:56:41 <lambdabot>  Defined.
21:56:51 <Axman6> > bmi 100 100
21:56:53 <lambdabot>  1.0e-2
21:57:09 <Axman6> > bmi 100 1
21:57:10 <xormor> > bmi 80 180
21:57:12 <lambdabot>  2.4691358024691358e-3
21:57:12 <lambdabot>  100.0
21:57:21 <xormor> > bmi 80 1.80
21:57:23 <lambdabot>  24.691358024691358
21:57:32 <nshepperd> fear the 100 meter tall pro wrestler
21:57:33 <xormor> > bmi 78.5 1.80
21:57:36 <lambdabot>  24.228395061728392
21:57:42 <xormor> > bmi 78 1.80
21:57:44 <lambdabot>  24.074074074074073
21:58:03 <xormor> Axman6, what are lists and Maybe?
21:58:04 <Axman6> mmm, satisfying decimals
21:58:15 <Axman6> > [1,2,3]
21:58:18 <lambdabot>  [1,2,3]
21:58:26 <Axman6> xormor: it sounds like you need to find a tutorial on Haskell
21:58:27 <mnoonan_> huh, I never realized the units for bmi were so weird
21:58:55 <Axman6> "weird"
21:59:03 <xormor> mnoonan_, SI system, European (French originally I think)
21:59:15 <nshepperd> SI units are normal; you're weird >:)
21:59:16 <Axman6> I think you mean, standard the world over except for three ass backwards nations
21:59:30 <mnoonan_> that’s fine, it’s more the “mass per unit area” notion that is odd
21:59:47 <Axman6> oh, yeah the result is weird
21:59:51 <mnoonan_> but thanks for the imperial unit dogpile anyway :)
21:59:58 <nshepperd> hahaha
22:00:09 <Axman6> anytime
22:00:39 <nshepperd> i don't think bmi really means anything, they just chose something that roughly correlates with health
22:00:56 <Axman6> MAtt Parker's video on the imperial system is amazing. I knew it was nonsense, but it's far more nonsense than I realised
22:01:32 <parsnip> maybe it was the closest fit to a graph
22:02:16 <parsnip> like how someone might go, "the graph of log(y) vs log(x) looks right!"
22:03:08 <nshepperd> yeah standard procedure is to plot x and y and then see if you can make a linear relationship appear by square something or taking a logarithm or reciprocal
22:05:04 <mnoonan_> apparently normal weights scale like height^2.5 in reality: https://people.maths.ox.ac.uk/trefethen/bmi.html
22:05:13 <nshepperd> but i guess your bmi is the pressure you would apply to the floor if you layed down and then were smeared into a square
22:09:54 <parsnip> that makes sense, should mass should lean to length squared
22:10:07 <parsnip> s/should mass should/mass should/
22:10:19 <parsnip> s/squared/cubed/
22:34:09 <Hafydd> unJust :: Maybe a -> a
22:38:22 <nshepperd> wrong :: (a -> b) -> Either a c -> Either b c
22:38:25 <nshepperd> :p
22:39:41 <mnoonan_> :t do not
22:39:43 <lambdabot> Bool -> Bool
22:41:42 <fearvier> Curious question, I've never seen people recommending haskell to other people
22:41:46 <fearvier> Anyone care to comment why?
22:41:59 <nshepperd> :t don't
22:42:00 <fearvier> just in general/reddit/forums/etc.
22:42:00 <lambdabot> Applicative m => m a -> m ()
22:42:20 <jle`> hm, that's funny, i feel like there's been a recommend-haskell fad in reddit and hacker news over the past few years that's only just recently dying out
22:42:35 <fearvier> jle` we must be following different subreddits :P
22:42:41 <jle`> maybe there is some selection or recall bias happening to us in different directions
22:43:01 <fearvier> Recently someone told me to learn haskell instead, so I got curious
22:43:06 <fearvier> Did some research
22:43:14 <fearvier> didn't find very many "learn haskell" thingies
22:43:16 <mnoonan_> fearvier: what field, generally?
22:43:38 <jle`> yeah in certain circles there is an overwhelming 'you have to try haskell or you're not cool' force that is undeniable
22:43:52 <jle`> like in the scala community for example
22:44:35 <jle`> but the influence of the hip-haskell factor probably fades when you go further from the cores
22:44:36 <fearvier> mnoonan_ just in general.
22:44:48 <fearvier> jle` I thought ruby was the hippie language
22:44:54 <jle`> not hippie, hip
22:44:56 <fearvier> ah
22:45:10 <jle`> i feel like there's a haskell-related article at the top of hacker news every week or so
22:45:19 <jle`> but yeah i am a human subject to recall bias
22:45:54 <jle`> anyway, to answer your question about why people might know or use haskell, and make the intentional choice not to recommend it
22:45:54 <fearvier> Don't go on HN very much.
22:46:31 <jle`> ah, i consider HN to be one of the big "general programming" zietgeists these days, for better or for worse
22:47:09 <jle`> but yeah, some reasons might be ecosystem issues.  in some particular areas, haskell's ecosystem lags behind languages that have more famous or mature ecosystems for that specific domain
22:47:38 <jle`> even though i feel there isn't any inherent reason for this, from haskell the language itself
22:48:05 <jle`> but ecosystems tend to build momentum in some areas or some languages/communities and people usually put everything behind a single horse or two
22:48:27 <jle`> but in other areas in haskell the ecosystem is very mature, so it depends on what domains you work in
22:49:45 <jle`> another reason someone who knows haskell might make the intentional choice to not recommend haskell might be because haskell has the reputation of having a high learning curve, so if your entire team is using one language, getting them all, together, to switch to haskell might not be practical
22:50:10 <boj> i am fighting with exactly that right now actually
22:50:31 <jle`> but another reason why you might not be hearing about haskell is that you aren't regularly talking to anyone who has used or uses haskell
22:51:09 <jle`> ...those are my main theories :)
22:51:17 <nshepperd> i don't tend to encounter a lot of people who are looking for language recommendations
22:53:11 <boj> unless someone is going full on polyglot, i'd agree. bump into more people that are firmly in their niche than those that want to change
22:53:14 <nshepperd> i guess i also tend not to recommend it to people because i don't feel qualified to justify the recommendation
22:54:14 <nshepperd> I imagine an exchange like <person> does haskell have good libraries for X <me> uh, no idea, I mostly do weird niche machine learning stuff
22:54:56 <MarcelineVQ> it's hard to convey the advatnages of a mostly different paradigm in a way a listener finds useful if they didn't come looking for that, one possible reason that reccomendations follow reqests rather than being offered first
22:55:04 <jle`> fwiw https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
22:55:18 <boj> MarcelineVQ: yeah
22:56:04 <MarcelineVQ> put another way, people tend to be more open to things they stumble upon themselves
22:58:18 <MarcelineVQ> it's actually really commendable that people here tend to have good answers for questions like "why should I​ learn haskell?" or "what's fp good for?" that tends to come from people who drop in, as though there's a sales pitch to make that people should be obliged to rise to
22:58:39 <fearvier> fair points, thanks guys
22:59:32 <jle`> MarcelineVQ: haskell seems to inspire some sort of...uniquely evangelistic fervor in its users, for some reason
22:59:44 <fearvier> MarcelineVQ My question wasn't really why I should earn haskell :P
23:00:03 <MarcelineVQ> fearvier: I'm speaking generally :>
23:00:09 <fearvier> Fair :P
23:01:09 * hackagebot monad-logger 0.3.25 – A class of monads which can log messages. – https://hackage.haskell.org/package/monad-logger
23:01:16 <boj> jle`: i think because some of us have experienced the horrors of other tools in production over the years. the refactoring story alone is enough for me to invest in a different paradigm
23:01:17 <MarcelineVQ> jle`: I think it's a lack of zealotry that gets questions like that good answers, it always seems to be more about helping people around here, idk :> Like it was a struggle to learn and you want to make it easier on the next guy
23:01:39 <parsnip> General Lee please let him finish
23:01:54 <MarcelineVQ> there's a real pay it forward kind of thing that seems to go on
23:17:36 * hackagebot aeson-flowtyped 0.7.2 – Create Flow type definitions from Haskell data types. – https://hackage.haskell.org/package/aeson-flowtyped
23:57:18 <osa1> I had a record with 10 fields, I moved 7 of the fields to a new record which is now a field of the original record. any easy way to preserve old lenses?
