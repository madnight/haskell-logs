00:00:02 <cocreature> mbrock: could be, I don’t know what exactly results in GHC not knowing what the type of something is
00:00:23 <jle`> Myrl-saki: you can emulate it with TH i suppose
00:00:31 <jared-w> DH == Dependent Haskell, trigone 
00:00:37 <jle`> Myrl-saki: or also FromNat :: Nat -> PeanoNat
00:00:39 <jle`> maybe
00:00:40 <cocreature> Myrl-saki: “For closures which have function type or unknown/polymorphic type, the string will represent an approximation to the actual type.” from the user guide
00:00:43 <jared-w> (the addition of dependent types into Haskell's type system)
00:00:44 <cocreature> so maybe it’s one of those?
00:00:52 <jle`> trigone: nonEmpty :: [a] -> Maybe (NonEmpty a)
00:00:55 <Myrl-saki> cocreature: mbrock*?
00:01:01 <trigone> i don't really see the connection bwn linear types and not needing "stupid-testing" every numerical input, but to be fair i barely gather what linear types imply from what you just said
00:01:01 <cocreature> eh right
00:01:02 <jle`> trigone: so you can just create a list and use nonEmpty to convert it to a NonEmpty
00:01:14 <cocreature> autocompletion is hard
00:01:36 <Myrl-saki> cocreature: At least this isn't Discord!
00:01:39 <trigone> jle`: yeah, better than nothing i guess :)
00:01:54 <cocreature> Myrl-saki: I’ve never used discord so I have no idea what you’re referring to ;)
00:01:56 <jle`> if you're comfortable with runtime errors, there's also fromList :: [a] -> NonEmpty a
00:02:10 <trigone> for numbers there's a simpler solution though for one very typical use: unsigned ints. do they exist?
00:02:19 <jle`> which you can probably comfortably use with literals
00:02:23 <jle`> there's Natural in base
00:02:37 <Myrl-saki> cocreature: For one, you can have unicode as a name. Another is that it has a drop-down menu for completion but it's chronological.
00:02:39 <jle`> but unsigned ints in haskell are kind of weird because of the Num typeclass
00:02:49 <jle`> Num ruins the day yet again
00:02:54 <trigone> jle`: it's like Integral if i remember?
00:03:01 <trigone> why is Num a problem?
00:03:07 <jle`> since if you want to implement + and *
00:03:09 <Myrl-saki> cocreature: Autocompletion is so much fun in Discord. It's a minigame of its own.
00:03:11 <jle`> you have to also implement -
00:03:12 <jle`> and negate
00:03:29 <cocreature> Myrl-saki: my irc client (weechat) also completes chronologically. most of the time that actually works surprisingly well
00:03:40 <trigone> jle`: ha, true i heard about it... yeah relatively absurd, mathematically
00:03:43 <cocreature> since you tend to respond to people who saids something recently
00:03:49 <jared-w> trigone: linear types and uniqueness types are similar but separate concepts. http://edsko.net/2017/01/08/linearity-in-haskell/ this is a great link on it, I think
00:03:54 <jle`> trigone: the main absurdity is from a usability standpoint
00:04:06 <trigone> jared-w: thx
00:04:06 <ongy> jle`: there's even funn stuff with bounded signed ints
00:04:10 <Myrl-saki> cocreature: Mhm. I also use WeeChat, but I dropdown menus IMO should be based on who you ping often.
00:04:15 <ongy> > negate (minBound :: Int)
00:04:17 <lambdabot>  -9223372036854775808
00:04:26 <jle`> Num doesn't really try to be anything mathematical, but from a usability standpoint, it's catastrophic
00:04:37 <trigone> jle`: hm
00:04:37 <Myrl-saki> ongy: Isn't that a problem with 2's complement though?
00:04:49 <ongy> Myrl-saki: that'
00:04:52 <Myrl-saki> > negate (minBount + 1 :: Int)
00:04:54 <jle`> i mean, the entire point of Natural is to make programs with only non-negative ints safe
00:04:54 <lambdabot>  error:
00:04:54 <lambdabot>      • Variable not in scope: minBount :: Int
00:04:55 <lambdabot>      • Perhaps you meant ‘minBound’ (imported from Prelude)
00:04:56 <Myrl-saki> Fhops
00:04:58 <Myrl-saki> Whoops
00:05:01 <Myrl-saki> > negate (minBound + 1 :: Int)
00:05:02 <jared-w> Honestly, I think the difficulty of numeric hierarchies really comes from the fact that no programming language has truly answered how to have very fine-grained and nuanced hierarchies and inheritance relationships without burdening the programmer
00:05:03 <lambdabot>  9223372036854775807
00:05:05 <Myrl-saki> It only happens in the case of minBound.
00:05:08 <jle`> but what you basically do instead is get an Int type that has positive numbers and where all negative numbers are 'error'/bottom
00:05:09 <ongy> Myrl-saki: that's where it comes from and why it happens exactly like that, but the problem exists in the Int (or smaller) signed types
00:05:40 <Myrl-saki> ongy: How would you feel if we change minBound by 1?
00:05:55 <jared-w> For example: Say you split Num up into a Field, Magma, and like 3-5 other types based on number theory. Very fine grained and accurate types but then... tons of boilerplate everywhere to get anything done perhaps? Or overly generic nonsense-looking type signatures
00:06:11 <Myrl-saki> ongy: That doesn't seem that bad, considering if you're already touching minBound, you probably already have a problem.
00:06:12 <jle`> if you literally mean an unsigned int (from c), there's those WordN types
00:06:31 <jle`> but they have the same problem as Natural here
00:06:36 <jared-w> Then you get into issues where you might have the same concept implemented 2-5 different "ways" by different classes and which way do you derive from, which one is used, how does the compiler generate appropriate uses of things, etc., all become much harder to solve.
00:07:04 <ongy> Myrl-saki: I don't actually care much. It's just an addity which makes Num on Int weird
00:07:15 <Myrl-saki> ongy: Ah. C:
00:07:17 <jared-w> Things get even *more* ridiculous with an enriched type system (especially with full on dependent types) and the compiler loses much of its ability to "write code" for you
00:07:26 <trigone> jle`: ok thx
00:07:43 <jle`> but yeah if you want to cons to a nonEmpty
00:07:52 <jle`> there's (<|) :: a -> NonEmpty a -> NonEmpty
00:07:53 <ongy> Myrl-saki: when/if we get something that can help prove invariants it may be relevant, but until then, I really don't care
00:08:04 <trigone> > (1 - 3) :: Natural
00:08:06 <lambdabot>  *Exception: Natural: (-)
00:08:32 <trigone> well that's quite vague for an exception message (even if implicitly it seems sufficient)
00:08:36 <jle`> trigone: oh alternatively, mono-traversable gives a list type that unites [] and nonempty
00:09:20 <jle`> it also does something kind of silly, creating a typeclass for all consable things
00:09:25 <Myrl-saki> ongy: LH? C:
00:09:26 <trigone> jle`: don't know what those are...
00:09:42 <jle`> which "fixes" having to use :| and <| seperately
00:09:53 <ongy> Myrl-saki: is that in GHC? I thought that's more like an external linter (mypy-ish)
00:10:02 <Myrl-saki> ongy: Yeah, it's an external linter.
00:10:26 <ongy> and I'd probably go with Isabelle/HOL since I know that a little and export to Haskell for anything like that
00:11:15 <trigone> ok, thanks for all those idea, i'm gonna check all that out :)
00:12:38 <ongy> Myrl-saki: have you used LiquidHaskell for something non-trivial?
00:13:22 <Myrl-saki> ongy: I haven't used it at all, actually.
00:13:32 <Myrl-saki> ongy: I was planning to use it but then decided to go with dependent types.
00:13:33 <cocreature> I hope we’ll figure out a way to combine LiquidHaskell and DH because I definitely can’t be bothered to prove some annoying arithmetic property using a typesystem-based prover
00:13:55 <nshepperd_> Num right now basically equals Ring, right? With abs and signum added for some reason
00:14:13 <jle`> can i just time travel to the future when we solve the numerical hierarchy problem
00:14:19 <jle`> and come back and tell you all
00:14:29 <jared-w> cocreature: LiquidHaskell is refinement types. I can't see any reason why we can't combine that and dependent types...
00:14:32 <nshepperd_> Sounds like a plan
00:14:34 <cocreature> nshepperd_: and fp instances are a lie :P
00:14:47 <Myrl-saki> jle`: Timeframe is a linear variable. :(
00:14:53 <MarcelineVQ> it turns out the solution was to use categories instead of numbers
00:15:01 <jared-w> jle`: Fixing the numeral hierarchy will require fixing the problem of deep hierarchy "programmer implementation debt"
00:15:32 <jle`> takeWhile hierarchyProblemNotSolved timeline
00:15:36 <nshepperd_> Oh yeah, well, we like to pretend that that floating points operations are associative because it helps us sleep at night
00:15:37 <Myrl-saki> MarcelineVQ: Waiting for "Category Theory for the Masses!"
00:16:19 <cocreature> jared-w: I know it’s possible in theory but the type-theory based verification community (DH) and the SMT-based verification community are sadly largely separate which always makes me sad since while they are both good for some things they are also terrible for things that the other is good at
00:16:19 <jared-w> nshepperd_: just like we /actually/ thought it was a good idea to implemnt a Num instance for the reals 
00:17:03 <jared-w> cocreature: that is quite sad... I didn't realize that SMT verification and type-theory verification were so separate; I've always felt they were natural friends and thought both communities would be well aware of each other
00:17:13 <ongy> jared-w: it's not a good idea?
00:17:31 <nshepperd_> From practical pov i think the biggest problem / annoyance is that splitting up the type classes means everyone has to rewrite their instances
00:17:37 <cocreature> isabelle is one of the better examples of combining the two
00:17:48 <jared-w> ongy: not at all. The set of real numbers are not even computable. To pretend otherwise is just ridiculous
00:18:01 <jle`> what about my constructive reals
00:18:14 <jared-w> \> constructivism
00:18:17 <ongy> jared-w: I would argue that the real type for any language is for computable reals either way
00:18:49 <nshepperd_> No need to worry about implementing Num for reals when you can't have reals in your computer anyway
00:18:51 <cocreature> an Haskell we define Reals to be the things that can be converted to Rationas so all hope is lost anyway
00:19:10 <jle`> sounds fine to me
00:19:25 <Myrl-saki> wtf
00:19:26 <jle`> "what is a real number?"
00:19:31 <jle`> ghci> :i Real
00:19:37 <jle`> class Real a where
00:19:41 <jle`>   toRational :: a -> Rational
00:19:44 <jle`> question solved
00:19:45 <Myrl-saki> lol
00:19:53 <ongy> sounds about right
00:20:04 <Myrl-saki> pi is not a real number, you heard it here first.
00:20:06 <nshepperd_> But uh aren't the Num instances for like CReal fine?
00:20:34 <marvin2> @hoogle Ratio Integer -> Integer
00:20:35 <lambdabot> Data.Ratio numerator :: Ratio a -> a
00:20:35 <lambdabot> Data.Ratio denominator :: Ratio a -> a
00:20:35 <lambdabot> Intro numerator :: Ratio a -> a
00:20:39 <jared-w> Well, there's a lot of issues mathematically speaking with Haskell's Num instance in the first place. That aside, sure, the CReal is 'fine'
00:20:54 <nshepperd_> The only problem i heard of is that Eq is semidecidable 
00:21:08 <cocreature> Num doesn’t imply Eq so that’s not really a problem
00:21:13 <jle`> CReal sounds like something i'd have for a full breakfast
00:21:20 <nshepperd_> Yeah, that was changed forever ago
00:21:30 <jared-w> jle`: BReal here
00:21:54 <nshepperd_> I heard that Num did imply Eq once, in the dark times
00:22:04 <jared-w> We don't talk about those times :p
00:22:29 <cocreature> luckily I got into Haskell sufficiently late to not have experienced those times
00:22:49 <kadoban> Isn't that time now, GHC just ignores that part of the report?
00:22:54 <jle`> luckily i got into haskell late enough to not feel the pain of getting rid of map = fmap
00:23:12 <jle`> to have had map = fmap and then lose it...
00:23:18 <jared-w> you mean map != fmap?
00:23:31 <jle`> better to have never loved at all
00:23:45 <jle`> jared-w: i mean we used to have class Functor f where map :: (a -> b) -> f a -> f b
00:23:50 <nshepperd_> Hoogle still shows "class (Eq a, Show a) => Num a". How embarrassing :/
00:24:16 <ongy> show is required for Num?
00:24:35 <cocreature> nshepperd_: use the new hoogle http://hoogle.haskell.org/?hoogle=Num ;)
00:24:54 <jared-w> jle`: oh right, gotcha. Then we changed that to fmap so we can keep the stupid version of map for "nice type errors" rather than making type errors better looknig
00:25:26 <jle`> the haskell community has sort of backpedaled on that philosophy
00:25:29 <jared-w> "Real implies Num and Ord" ಠ_ಠ
00:25:31 <jle`> with FTP and the BBP
00:25:57 <jle`> well
00:26:02 <jle`> maybe not backpedaled.  now, we have neither
00:26:04 <ongy> I liked the map/fmap difference as a beginner. These days I don't have a strong opinion
00:26:08 <jared-w> And rather than properly backpedaling with better error messages as a consolation prize, it's just worse in both respects :p
00:26:33 <nshepperd_> Anyway, the only mathematical issue with Num that i am aware of now is that abs and signum are in there for no good reason? (And that we sometimes wish we had semirings instead of rings, or additive groups)
00:27:05 <jared-w> ongy: I like it /only/ because of improved error messages. The simpler and more concrete the types, the less garbage GHC vomits out if I do something wrong. If Haskell could handle good and informative error messages for complicated type magic... that'd be great
00:27:07 <jle`> i suppose that's the only actual mathematical issue
00:27:20 <jared-w> nshepperd_: It depends on what you mean by "mathematical issue"
00:27:20 <nshepperd_> The other typeclasses, though, i mostly don't remember what they are each for
00:27:22 <jle`> most of my complaints are usability issues anyway
00:27:46 <jle`> > abs (-1 :+ 3)
00:27:48 <lambdabot>  error:
00:27:48 <lambdabot>      Precedence parsing error
00:27:48 <lambdabot>          cannot mix prefix `-' [infixl 6] and ‘:+’ [infix 6] in the same infi...
00:27:54 <jle`> > abs ((-1) :+ 3)
00:27:57 <lambdabot>  3.1622776601683795 :+ 0.0
00:28:29 <jle`> oh that's actually not too bad
00:29:01 <jared-w> https://prime.haskell.org/wiki/NumericClasses nshepperd_ this is one of the proposals for Haskell prime
00:32:26 <`Guest00000> ahhh
00:32:37 <`Guest00000> i want to modify how `show` shows just this one field...
00:33:23 <marvin2> what is the type of that field?
00:33:28 <`Guest00000> why?
00:34:37 <marvin2> if it is a type you created you can manually define its Show instance
00:34:59 <`Guest00000> ok, it's ByteString
00:35:29 <marvin2> then you have to manually define Show instance for your type that contains ByteString field
00:35:42 <`Guest00000> but everything else would be perfect
00:35:49 <`Guest00000> and if i do it, lot of work
00:36:10 <kadoban> Could also make a newtype for the ByteString and give that a custom Show instance
00:36:23 <`Guest00000> and newtyping is not acceptable..
00:36:33 <kadoban> Then you have some work to do.
00:36:57 <`Guest00000> dammmmnn
00:37:03 <marvin2> it is either all or nothing with `deriving Show'
00:37:07 <`Guest00000> why not have something
00:37:08 <`Guest00000> like
00:37:13 <`Guest00000> modifyDerive
00:37:53 <`Guest00000> where compiler gives you methods which it derived automatically
00:38:01 <`Guest00000> but lets you make your own instance
00:38:09 <`Guest00000> then you just cut in a little
00:38:13 <`Guest00000> replace a few cases
00:38:19 <`Guest00000> and it's solved
00:38:23 <MarcelineVQ> You can tell ghc to spit out the deriving code it wrote
00:38:39 <`Guest00000> not cool anyway
00:38:56 <Myrl-saki> FlexibleInstances are a Good Thing, right?
00:39:23 <jle`> yes
00:40:33 <jle`> it's one of my 'how haskell should have originally been anyway' extensions
00:40:40 <jle`> along with TupleSections
00:40:51 <jle`> er, 'how haskell was probably intended to have been in the first place'
00:41:51 * hackagebot bookkeeping 0.2.1.4 – A module for bookkeeping by double entry. – https://hackage.haskell.org/package/bookkeeping
00:41:57 <Myrl-saki> What does FlexibleInstances change?
00:42:07 <Myrl-saki> In English.
00:42:36 <jle`> it lets you write an instance for, say, `Maybe Int`
00:42:57 <jle`> without it you could only write an instance for `Maybe a`, polymorphic for a's
00:43:19 <Myrl-saki> jle`: Oh.
00:43:28 <Myrl-saki> Thanks.
00:43:34 <jle`> no problem
00:43:45 <jle`> i mean it's not a use case that comes up in basic haskell
00:44:01 <jle`> but it's one of those "did they really mean to do it that way" kind of things
00:44:34 <Myrl-saki> How about FlexibleContexts?
00:45:04 <jle`> same thing but for typeclass constraints
00:45:33 <Myrl-saki> Oh thanks. Exactly what I needed.
00:45:51 <jle`> it's kind of silly to use for single-parameter type classes which might be why you don't run into it very often in basic haskell either
00:46:11 <jle`> but you need it if you want something like MonadState Int m => m ..., where m is some MonadState whose state is Int
00:46:58 <jle`> otherwise you'd need (SomeUsefulConstraint s, MonadState s m) => ...
00:47:32 <jle`> i wonder if you can emulate it with (s ~ Int, MonadState s m) => ...
00:49:00 <jle`> oh nice you can do it, but you have to turn on TypeFamilies or GADTs, which is definitely more invasive of an extension than FlexibleContexts
00:52:00 <MichaelBurge> Anyone mind seeing if there's a way to simplify my 'minimize' function that uses Witherable? http://lpaste.net/357302
00:52:32 <MichaelBurge> I might ask them to add something similar to the library.
00:56:06 <jle`> MichaelBurge: not sure what it's supposed to bedoing exactly...how is it different than filter ?
00:56:36 <MichaelBurge> jle`: The original context is delta-debugging a syntax tree, reducing it to a minimal test case that still exhibits the bug
00:56:50 <jle`> can you give an example where it differs from filter ?
00:56:51 <MichaelBurge> jle`: filter is element-wise, while the bug only exists over the entire tree.
00:57:28 <MichaelBurge> jle`: hasError is a property of the list, not of any particular element. But you could change the example to be equivalent to an elementwise comparison.
00:58:15 <MichaelBurge> jle`: An example that can't be reduced elementwise, is a check that every goto has a corresponding label. The label or goto individually aren't a problem
00:58:27 <jle`> can you show one concretely
01:00:32 <MichaelBurge> jle`: main = putStrLn $ show $ minimize (even .sum) [200,-50,1,39,7,50,60,90,100]
01:01:00 <jle`> why not minimize :: (w a -> Bool) -> w a -> [w a]
01:01:29 <jle`> but yeah, i see what you mean now :)
01:02:16 <MichaelBurge> So you're thinking it might be useful to keep track of the entire set of reductions?
01:02:45 <jle`> just that it'd be nice to not arbitrary pick the first one
01:03:02 <jle`> but keeping all of them might not be implementable actually
01:03:17 <jle`> hm, it might be.
01:03:33 <MichaelBurge> Oh, you meant all possible reductions? It should be possible, assuming the original list is finite.
01:03:44 <jle`> yeah, i see now
01:14:55 <Myrl-saki> This is gonna be stupid.
01:14:55 <trigone> i'd like to use transformers (the usual triad State, Reader, Writer) but i'm a bit lost on what package i must make my program depend on: is mtl sufficient? 
01:15:39 <`Guest00000> which is simplest way to compare two Foldables as sets?
01:16:06 <xormor> > data NonEmpty a = a :| [a]
01:16:08 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
01:18:53 <lyxia> trigone: yes
01:19:06 <trigone> lyxia: ok thx :)
01:19:51 <Myrl-saki> :t WOrd
01:19:53 <lambdabot> error: Data constructor not in scope: WOrd
01:20:19 <Myrl-saki> Why is an unsigned integer type not in Prelude?
01:20:51 <trigone> @src Natural
01:20:51 <lambdabot> Source not found. Maybe you made a typo?
01:22:02 * arahael is just reflecting on Haskell this year, vs purescript, vs  haskell two years ago (before he discovered Haskell Stack) - all the while a very inexperienced haskell dev.
01:22:06 <Myrl-saki> @let import Numeric.Natural
01:22:07 <jle`> Myrl-saki: since its Num instance is partial so it's kind of tricky to use
01:22:07 <lambdabot>  Defined.
01:22:17 <Myrl-saki> :t Natural
01:22:19 <lambdabot> error: Data constructor not in scope: Natural
01:22:22 <Myrl-saki> Whoops lol
01:22:29 <arahael> Haskell + Stack makes for a very, very mature platform, it seems. (But you guys knew that).
01:22:33 <Myrl-saki> :t (2 :: Natural)
01:22:34 <lambdabot> error:
01:22:34 <lambdabot>     Ambiguous occurrence ‘Natural’
01:22:34 <lambdabot>     It could refer to either ‘Data.Number.Natural.Natural’,
01:22:42 <Myrl-saki> ....?
01:31:48 * hackagebot ihs 0.1.0.1 – Interpolated Haskell – https://hackage.haskell.org/package/ihs
01:35:18 <Myrl-saki> Well
01:35:34 <Myrl-saki> I need help lol
01:36:04 <Myrl-saki> http://ix.io/yMO
01:36:13 <Myrl-saki> Is there a way to make that typecheck?
01:37:13 * hackagebot tasty-stats 0.2.0.3 – Collect statistics of your Tasty testsuite in a CSV file – https://hackage.haskell.org/package/tasty-stats
01:39:13 <lyxia> Myrl-saki: You cane quantify n existentially with a wrapper datatype or by CPS.
01:39:47 <jle`> Myrl-saki: it doesn't work since 'n' is universally quantified
01:39:55 <jle`> the caller of intToFin can chose whatever n they want
01:40:24 <Myrl-saki> Oh.
01:40:32 <jle`> kind of like read :: Read a => String -> a
01:40:40 <jle`> the caller can chose to instantiate 'a' to any type they please
01:40:53 <Myrl-saki> lyxia: CPS, like reflection?
01:40:59 <Myrl-saki> Or nah?
01:41:05 <jle`> cps like a skolemized existential
01:41:09 <Myrl-saki> (I haven't really worked with CPS)
01:41:17 <jle`> intToFin :: Natural -> (forall n. Finite n -> r) -> r
01:41:29 <Myrl-saki> :t reifies
01:41:30 <lambdabot> error: Variable not in scope: reifies
01:41:44 <jle`> this is reification, yes :)
01:41:49 <Myrl-saki> jle`: :D
01:41:51 <Myrl-saki> jle`: Yaaay
01:41:57 <Myrl-saki> jle`: I feel like I'm learning.
01:42:20 <jle`> basically you have to "use" the `Finite n` in the closer that intToFin gives you, but you have to do it in a way polymorphic for all n's
01:42:28 <jle`> since you don't know ahead of time what 'n' is
01:42:56 <jle`> intToFin 4 $ \fn -> ... in here, fn :: Finite n for some n, but we have to treat it polymorphically since we don't know yet ...
01:42:58 <`Guest00000> i tried to read an explanation and didn't understand wtf is skolem anyway
01:43:10 <jle`> skolemization is a process
01:43:29 <jle`> like currying
01:43:45 <butterthebuddha> Can I define my own operator by wrapping it in parenthesis? Like (&)?
01:44:02 <jle`> sure
01:44:08 <jle`> you can define it without parentheses too.
01:44:17 <jle`> um, the better response should have been "what happens when you try"
01:45:14 <jle`> Myrl-saki: to start off, intToFin 0 f = f 0
01:45:20 <jle`> er, intToFin 0 f = f FZ
01:45:58 <Myrl-saki> http://ix.io/yMP
01:46:00 <Myrl-saki> YAY
01:46:15 <jle`> :D
01:46:17 <butterthebuddha> Wait so how does Haskell know if a function is infix or prefix?
01:46:39 <Myrl-saki> jle`: This also makes sure that Finite's "invariant" holds, right?
01:46:41 <jle`> non-operator variable names are prefix
01:46:52 <jle`> Myrl-saki: i'm not exactly sure what Finite type oyu're using is
01:47:01 <Myrl-saki> jle`: Just rolled my own one.
01:47:02 <jle`> butterthebuddha: and parenthesized operatrs are prefix
01:47:08 <jle`> Myrl-saki: but, what is it supposed to represent?
01:47:16 <jle`> the tradtional type called Finite/Fin ?
01:47:44 <Myrl-saki> jle`: http://ix.io/yMQ
01:47:48 <Myrl-saki> jle`: Not sure what to call those.
01:47:49 <jle`> if so, i'm not sure what intToFin/finToInt would be
01:47:56 <jle`> ah
01:48:10 <jle`> that's not what people usually call Finite
01:48:12 <Myrl-saki> Just ignore the AnyPeano. I was trying to make things work lol
01:48:32 <jle`> it's a Peano singleton
01:48:34 <Myrl-saki> jle`: Oh.
01:48:45 <jle`> there's a convention wher eyou'd call it SPeano
01:48:49 <jle`> oh wait
01:48:50 <jle`> i misread
01:48:51 <ab9rf> beano
01:48:57 <jle`> yes, that's right, that's Finite
01:48:59 <jle`> sorry :)
01:49:10 <Myrl-saki> jle`: You misread it as `FZ :: Finite Z` didn't you? :P
01:49:19 <jle`> yes heh
01:49:32 <jle`> well, finite's invariant holds no matter what
01:49:52 <jle`> the only thing is that you need to make sure that the Int/Natural you convert them to/from are the actual ones you expect
01:49:53 <Myrl-saki> jle`: Ah, right. Thanks.
01:50:18 <jle`> i'm also suspect by what you intend to use them for
01:50:26 <jle`> intToFin is not a typical operation for Finite
01:50:48 <Myrl-saki> jle`: True. Especially with how this is formed.
01:51:01 <Myrl-saki> jle`: I got sidetracked a bit lol.
01:51:07 <jle`> yeah
01:51:21 <jle`> the way you wrote them, the Natural you take doesn't really correspond well to the Finite you get
01:51:24 <Myrl-saki> jle`: I think the only thing I wanted was an "easy way to write a 0 finite", but if you think about it, that's just FZ.
01:52:37 <jle`> yeah, the function you probably want is intToFin :: IsPeano n => Natural -> Maybe (Finite n), or something similar
01:52:47 <jle`> SPeano n -> Natural -> Maybe (Finite n), if you have a peano singleton
01:53:12 <jle`> if you're going to be using the Finite as an index
01:53:17 <Myrl-saki> jle`: Right. I have singletons in my cabal, but I'm not sure when I need to use them.
01:53:34 <jle`> you can write your singletons from scratch if you want to and ignore the singletons library
01:53:46 <jle`> i might suggest you do that first, to help you appreciate what the library gives, heh
01:54:09 <Myrl-saki> jle`: Yeah, I probably should. I've read the paper, and only kind of understand how to use it.
01:54:11 <jle`> data SPeano where SZ :: SPeano 'Z; SS :: SPeano n -> SPeano ('S n)
01:54:27 <jle`> then packFinite :: SPeano n -> Natural -> Maybe (Finite n)
01:54:34 <jle`> "pack this index into Finite n, if possible"
01:55:21 <trigone> are those working the same way in practice? WriterT w (StateT s m) a   vs   StateT s (WriterT w m) a ?
01:55:33 <jle`> @unmtil WriterT w (State s) a
01:55:33 <lambdabot> s -> (a, w, s)
01:55:33 <Myrl-saki> jle`: I'm doing this more for syntactic convenience.
01:55:45 <jle`> @unmtl StateT s (Writer w) a
01:55:45 <lambdabot> s -> (a, s, w)
01:55:59 <jle`> yes they are isomorphic
01:56:27 <jle`> Myrl-saki: your intToFin is basically "lastIndex"
01:56:44 <jle`> er, or i guess, maxBound
01:56:52 <trigone> jle`: k thx
01:59:06 <Myrl-saki> jle`: I wonder if it'd be better to use SPeano and type-level <= rather than finite.
01:59:30 <jle`> it's the same thing basically
01:59:38 <jle`> "under the hood"
01:59:41 <Myrl-saki> jle`: Mhm, but it's one less declaration.
01:59:51 <jle`> you're going to have to declare <=, right?
02:00:06 <Myrl-saki> jle`: Right, but I could use it for other things.
02:00:21 <jle`> what i'm saying is that having the Finite type and having an <= type are equivalent
02:00:27 <jle`> you could use one for the other :)
02:00:31 <Myrl-saki> jle`: Ohhh, interesting.
02:00:33 <jle`> they give you the same power
02:00:51 <Myrl-saki> jle`: Finite x <-> <= x ?
02:00:54 <jle`> actually i haven't checked that
02:00:56 <Myrl-saki> Well
02:01:01 <Myrl-saki> jle`: Finite (S x) <-> <= x ?
02:01:54 <jle`> (n <= m) => (SPeano n, Speano m)
02:02:27 <jle`> vs. (Nat, Finite m)
02:02:33 <jle`> s/Nat/Peano
02:02:42 <Myrl-saki> Ah, I see.
02:03:21 <jle`> but don't let me stop you from trying both :)
02:03:43 <jle`> actually i should probably say `n <= m` as a data type/type family, not as a typeclass constraint
02:03:45 <Myrl-saki> jle`: I'll leave that as an exercise for whoever tries to use my library. :P
02:04:30 <Myrl-saki> jle`: Oh right. Is it confusing if I use a data declaration both as a type and as a kind?
02:05:17 <jle`> oh i meant that as in, i am not sure if having it as a typeclass has the same semantics/expressive power
02:05:30 <jle`> it probably does but i'm not certain enough to make confident statement
02:06:09 <Myrl-saki> jle`: Different question. :P I decided to just do away with native numbers and use `Peano` all the way.
02:06:35 <Myrl-saki> jle`: I'm already using Peano as a kind.
02:06:50 <jle`> oh, you mean, use both Peano the kind, and Peano the type?
02:06:50 <Myrl-saki> Would it be confusing for the reader if I also use it as a type?
02:06:53 <Myrl-saki> jle`: Mhm.
02:07:03 <Myrl-saki> jle`: I'm thinking of just using SPeano for the type-level.
02:07:21 <jle`> it's not that confusing, i think.  it's actually the convention in the singletons package
02:07:42 <jle`> that is, use both Bool the kind and Bool the type
02:07:51 <jle`> etc.
02:07:53 <Myrl-saki> jle`: Ah. True.
02:07:57 <`Guest00000> which typeclass could be symmetric with Foldable across toList / fromList?
02:07:59 <jle`> 'True
02:08:02 <Myrl-saki> jle`: Thanks so much.
02:08:10 <jle`> no problem :)
02:08:29 <jle`> `Guest00000: there aren't very many Foldable instances for which that would make sense
02:09:02 <`Guest00000> jle`: [], Seq, sets
02:09:45 <`Guest00000> length-homogeneous arrays
02:10:05 <jle`> ah, i guess types without any structure except for order
02:10:32 <`Guest00000> with linear structure
02:11:33 <jle`> `Guest00000: base has the IsList typeclass
02:11:36 <jle`> with fromList
02:11:56 <jle`> > (fromList . toList) [1,2,3] :: [Int]
02:11:58 <lambdabot>  error:
02:11:58 <lambdabot>      Ambiguous occurrence ‘toList’
02:11:58 <lambdabot>      It could refer to either ‘F.toList’,
02:12:03 <jle`> > (fromList . F.toList) [1,2,3] :: [Int]
02:12:05 <lambdabot>  [1,2,3]
02:12:35 <jle`> > (fromList . toList) [1,2,3] :: NonEmpty Int
02:12:37 <lambdabot>  error:
02:12:37 <lambdabot>      Ambiguous occurrence ‘toList’
02:12:37 <lambdabot>      It could refer to either ‘F.toList’,
02:12:42 <jle`> > (fromList . F.toList) [1,2,3] :: NonEmpty Int
02:12:44 <lambdabot>  error:
02:12:44 <lambdabot>      • Expected a type, but ‘'NonEmpty Int’ has kind ‘NonEmptyList a0’
02:12:44 <lambdabot>      • In an expression type signature: NonEmpty Int
02:13:25 <jle`> heh
02:13:32 <jle`> @let import qualified Data.List.NonEmpty as NE
02:13:33 <lambdabot>  Defined.
02:13:38 <jle`> > (fromList . F.toList) [1,2,3] :: NE.NonEmpty Int
02:13:40 <lambdabot>  1 :| [2,3]
02:13:49 <jle`> who left the NonEmptyList import in lambdabot
02:14:18 <`Guest00000> jle`: it's not fully symmetric with Foldable, because Foldable is a functor, and there's type family Item for IsList instead of functoriness
02:14:27 <MatthiasGoergens> Hi!  Does anyone know how to get access to profiling/coverage information about a program from within the pragram?
02:14:36 <jle`> indeed
02:15:04 <Myrl-saki> jle`: If you existentially qualify and pass it to a singleton, can you reclaim the type?
02:15:23 <jle`> cannot parse question
02:15:30 <Myrl-saki> jle`: http://ix.io/yMR
02:15:31 <jle`> are you using singleton to refer to a function?
02:16:04 <Myrl-saki> jle`: When using AnyBlack, can I reclaim the type information of n?
02:16:10 <jle`> Myrl-saki: yes
02:16:16 <jle`> by pattern matching on blanks
02:16:31 <Myrl-saki> jle`: Thanks.
02:16:56 <jle`> the more common pattern would actually be data Black n = Black T.Text, and data AnyBlack = forall n. AnyBlack (Black n) (SPeano n)
02:18:45 <jle`> and AnyBlack is what we'd call a 'dependent pair'
02:18:54 <`Guest00000> what if we declare class (Functor f, IsList f) => ListFunctor f and say that every instance should have Item (f a) = a, though
02:18:55 <Myrl-saki> Interesting.
02:19:28 <jle`> `Guest00000: you can do that within the constraints, (Functor f, IsList (f a), Item (f a) ~ a)) => ...
02:19:35 <`Guest00000> oh, cool
02:19:47 <`Guest00000> nice, then we're good
02:19:54 <`Guest00000> with some code, though
02:20:05 <`Guest00000> so
02:21:13 <`Guest00000> i want to solve a task of representing a container for flags with (f Flag) for needed Flag types, and have instance ??? f => Binary (f Flag)
02:21:34 <jle`> probably not a good idea because of overlapping instances
02:21:36 <`Guest00000> to `put`, Foldable f is enough
02:22:01 <`Guest00000> uh, i forgot, there's actually a newtype
02:22:05 <`Guest00000> over (F Flag)
02:22:28 <`Guest00000> i like how SDL.Init.initialize does it
02:22:43 <MatthiasGoergens> Somebody recently posted a really nice way to encode Red-Black invariants of the RB trees in the type system using zippers.  (The main complication comes from how to do inserts.)
02:23:16 <`Guest00000> it accepts flag set in the form of a polymorphic Foldable
02:23:32 <`Guest00000> so you can give lists or sets or anything
02:24:04 <`Guest00000> or Identity or Const
02:24:14 <jle`> Myrl-saki: one reason for Black n not containing SPeano n is that the SPeano n can be shared over multiple values
02:24:32 <jle`> Myrl-saki: for example for a [Blacks n], you shouldn't really need to duplicate the SPeano n over every item in the list
02:24:46 <jle`> since the same one will do for all
02:28:46 <Athas> It's impressive that Accelerate can render a Mandelbrot fractal in real time.
02:28:53 <Athas> (On the CPU, that is.)
02:28:53 <Myrl-saki> jle`: Wow.
02:29:48 <Myrl-saki> jle`: That's actually very interesting.
02:31:38 <jle`> i haven't actually tested if this overhead actually matters, but it's a bit...philosophically more ideal
02:31:57 <jle`> Athas: nice that the CPU performance is great too
02:32:57 * hackagebot irc-client 0.4.4.3 – An IRC client library. – https://hackage.haskell.org/package/irc-client
02:41:03 <MatthiasGoergens> Athas, FractInt could render Mandelbrot on 386 really fast.
02:43:00 <bbear> hello, friends. I would like to know how to have a single line to do "123 456\n789 102" -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=123,456],[789,102
02:43:13 <bbear> hello, friends. I would like to know how to have a single line to do "123 456\n789 102" -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=123,456],[789,102
02:43:23 <bbear> hello, friends. I would like to know how to have a single line to do "123 456\n789 102" -> [ [123,456], [789,102] ]
02:44:21 <bbear> I would like to chain function on this
02:44:40 <jle`> you can use unlines to split it by lines
02:44:45 <jle`> and unwords to split each line into words
02:45:24 <bbear> something like that ? (map read) <$> words <$> lines <$> x
02:45:50 <jle`> er yeah, sorry, lines and words
02:45:54 <jle`> try less <$>'s
02:46:06 <jle`> work it out step by step
02:46:16 <jle`> > lines "123 456\n789 102"
02:46:18 <lambdabot>  ["123 456","789 102"]
02:46:32 <jle`> > map words . lines $ "123 456\n789 102"
02:46:34 <lambdabot>  [["123","456"],["789","102"]]
02:46:43 <Tuplanolla> > bbear "123 456\n789 102"
02:46:45 <lambdabot>  "http://en.wikipedia.org/wiki/Special:Search?go=Go&search=[[123,456],[789,10...
02:47:34 <`Guest00000> ((read <$>) . words <$>) . lines
02:47:39 <`Guest00000> :t ((read <$>) . words <$>) . lines
02:47:41 <lambdabot> Read b => String -> [[b]]
02:47:56 <`Guest00000> :t bbear
02:47:58 <lambdabot> String -> [Char]
02:48:07 <bbear> why
02:50:01 <bbear> > (((read <$>) .  words <$>). lines) x
02:50:03 <lambdabot>  error:
02:50:03 <lambdabot>      • Couldn't match type ‘Expr’ with ‘[Char]’
02:50:03 <lambdabot>        Expected type: String
02:50:17 <bbear> > (((read <$>) .  words <$>). lines) "123 48\n90 120"
02:50:19 <lambdabot>  [[*Exception: Prelude.read: no parse
02:50:52 <`Guest00000> > ((read <$>) . words <$>) . lines $ "123 456\n789 012" :: [[Int]]
02:50:54 <lambdabot>  [[123,456],[789,12]]
02:51:02 <MarcelineVQ> you don't need any <$> here
02:51:07 <jle`> now try to make it even more unreadable :)
02:51:50 <cocreature> > ((read <$>) <$> words <$>) <$> lines $ "123 456\n789 012" :: [[Int]] -- jle` do I win?
02:51:52 <lambdabot>  [[123,456],[789,12]]
02:53:02 <jle`> > ((((read <$>) <$> words <$>) <$> lines) <$>) $ "123 456\n789 012" :: [[Int]]
02:53:04 <lambdabot>  error:
02:53:05 <lambdabot>      • Couldn't match type ‘[b0]’ with ‘Int’
02:53:05 <lambdabot>        Expected type: Char -> [Int]
02:53:19 <jle`> welp time for me to go to bed
02:59:46 <Athas> MatthiasGoergens: with real-time scrolling?
03:00:05 <Athas> I'm not even sure 386 video cards had enough colours to imitate Accelerate's rendering.
03:07:56 <Maxdamantus> Doesn't have much to do with Haskell, but does anyone know if there's a name for an ability to unify type variables based on reference equality?
03:08:14 <Maxdamantus> ie, where you might be able to write something like: f :: (exists t. (Foo t, t -> Int)) -> (exists u. (Foo u, u)) -> Maybe Int; f (ft, ti) (fu, u) = if ft `refEq` fu then Just (ti u) else Nothing
03:09:08 <Maxdamantus> The language would know that inside the true branch of that `if`, `u` and `t` are the same so would allow the application that occurs inside.
03:09:29 <bbear> when I do a function to read a file and return its content as an IO String, is the file read each time I call the function again ?
03:09:37 <bbear> (not really a function rather an IO String constant)
03:10:59 <Maxdamantus> bbear: if the `IO String` is defined as opening and reading the file, sure.
03:11:10 <MatthiasGoergens> Athas: FractInt was pretty impressive: they could render fractals like the Mandelbrot on a 386 in integer arithmetic (no floating point involved in the early versions, hence the name) in about 2s.
03:11:26 <bbear> I just write content <- readFile "stuff"; return content
03:11:33 <MatthiasGoergens> Just running the same algorithms on modern hardware should give you enough frames to do everything in smooth animation.
03:11:49 <cocreature> bbear: that’s a bit reduntant. readFile "stuff" is equivalent to that
03:12:22 <bbear> well except I do a bunch of manipulation before returning the content but I basically start like that.
03:12:48 <MatthiasGoergens> Athas: the graphics cards back then probably didn't have enough colours, but that's not very important: the fractint fractal calculation code was the important bit.  Rendering the numbers generated into colours is relatively simple.
03:13:37 <Maxdamantus> bbear: yes. If you've written something like `readStuff = readFile "stuff" >>= (...)`, `readStuff` will be an operation that, when run, whill first read that file.
03:13:38 <Athas> MatthiasGoergens: actually, from porting the Accelerate implementation of Mandelbrot (which uses a rather fancy colourisation algorithm), it seems that colouring is almost half the runtime.
03:13:52 <Athas> (Depending on which part of the set you are looking - divergent parts are very expensive to compute.)
03:13:55 <MatthiasGoergens> bbear: be aware that lazy-IO can cause you all kinds of trouble.
03:14:26 <Maxdamantus> bbear: note that when you write `do{ content <- readFile "stuff"; return content }`, it's basically the same as `readFile "stuff" >>= (\content -> return content)`
03:14:28 <MatthiasGoergens> Athas: sure, I mostly meant that widening the range of colours should be relatively easy to do?
03:14:47 <MatthiasGoergens> FractInt is still around, I just haven't used it in ages.  So it probably has a wider range of colours now.
03:15:20 <Athas> Nowadays, fractals are all about GPUs!
03:15:28 <MatthiasGoergens> (And I don't know how they adapted to modern architectures.  Their early claim to fame was being really fast on 386 without floating point coprocessor.  These days you probably want to get your speed by using SSE or graphics cards etc.)
03:16:32 <MatthiasGoergens> Fractint also had some special code for mandelbrot that made use of some theorems, eg for Mandelbrot set it's enough to trace the outline, you don't need to do calculations for every pixel.
03:17:09 <MatthiasGoergens> (Or rather, you only need to do expensive calculations around the outline---you can get the inside and outside of the mandelbrot set for much cheaper.)
03:17:36 <MatthiasGoergens> There's an interesting theorem that states that the mandelbrot set is connected and has no holes.
03:18:43 <MatthiasGoergens> But yeah, Accelerate is probably still impressive.  After all, they are not stupid and definitely looked at FractInt source and learned what they could from their tricks.
03:19:25 <Athas> I don't think so.  FractInt probably does all kinds of clever tricks.  The Mandelbrot implementation in Accelerate is very straightforward.  Pure brute force.
03:19:49 <Athas> With modern computer brawn, you don't much brains.  In fact, given the cost of control flow, brains can be detrimental to performance!
03:19:52 <`Guest00000> what's 'fold-map-able' but also can be taken slices of? for sorting and then processing only the stuff you're interested in
03:20:06 <`Guest00000> is there a typeclass
03:22:50 <ab9rf> i twiddled the source of a fractal generator plugin for the gimp back in the day
03:23:17 <ab9rf> never looked that closely at the actual fractal generation code, mostly mucked with the stuff that rendered the fractal into a gimp drawable 
03:24:30 <bbear> is it a good idea to do code on my spare time ?
03:24:50 <ab9rf> bbear: it's your spare time, do what you want with it
03:56:30 <Athas> It's really quite remarkable how much better the new Accelerate LLVM-PTX backend is than the old CUDA backend.  A shame it's so tricky to install.
03:57:23 <fendor> Athas, you managed to install Accelerate :O
03:57:45 <fendor> i tried it for a week...
03:58:07 <Athas> I had to wait until my distribution had the right version of LLVM available, and then I just added stuff to a stack.yaml until it worked.
03:58:24 <Athas> Try this one: https://github.com/AccelerateHS/accelerate/issues/391
03:59:01 <fendor> i copied the stack.yaml, but it said there was an unexpected flag and it did not compile :(
03:59:10 <AndreasK> I'm going over the imprecise exception paper from SPJ atm. Is there documentation what/how it is currently implemented?
04:00:10 * hackagebot activehs 0.3.2 – Haskell code presentation tool – https://hackage.haskell.org/package/activehs
04:00:43 <`Guest00000> why doesn't lambdabot have unified interface for :i, :t, let and import?
04:01:07 <fendor> Athas, thanks, gonna try this
04:02:00 <Athas> fendor: I put it in my global project stack.yaml, but that's likely not necessary.
04:02:47 <fendor> yes, a local package is sufficient for me. I just wanted to try it out and see, if can get a better performance than the llvm backend of GHC
04:04:00 <Athas> fendor: make sure you have LLVM 4.0 installed.
04:04:41 <fendor> Athas, i do, it is a lot of fun to install version 3.7 if your OS does not support different versions of a package
04:06:25 <fendor> cabal version above 1.8? 0.o I thought the neweset version is 1.24? 
04:06:31 <Athas> I would be surprised if it wasn't faster than GHC's LLVM backend.
04:07:27 <fendor> Athas, what a pity. The LLVM backend is already really fast in a lot of cases, so, I'm fine with that. But if i used the CUDA Backend, it might be faster?
04:08:12 <Athas> Accelerate with LLVM is faster than GHC with LLVM, I think.  But yes, the LLVM-PTX backend (for CUDA GPUs) is faster still.
04:08:33 <Athas> It's probably because LLVM forces you to do the work that will allow efficient execution, where GHC will silently let you write crap code.
04:09:40 <fendor> Athas, but GHC does a lot of rewrite to improve the bad code parts, doesn't it? But using the CUDA backend is complicated, my operating system does not have any packages for the cuda development kit
04:10:13 <Athas> fendor: yes, GHC is not bad at all, but there is only so much it can do if you have code heavy with pointer-chasing and lazy thunks.
04:11:12 <fendor> Athas, still better than most other compilers i've seen. Did you manage to compile a program with the CUDA backend??
04:11:20 <fendor> sorry, one question mark too many
04:11:32 <Athas> fendor: yes, I did.  It works fine.
04:11:46 <Athas> (Although I had my CUDA setup in order already, which is a nontrivial task in itself.)
04:12:31 <fendor> Athas, which operating system? Do you have one of the supported ones?
04:12:38 <fendor> *offically supported
04:13:31 <Athas> fendor: yes, Fedora.
04:13:39 <fendor> Athas, damn it :D 
04:14:19 <fendor> so, i either just try out the llvm backend, or install another OS ^^
04:15:02 <fendor> Athas, did you compile the examples with stack or cabal?
04:15:24 <Athas> fendor: stack.
04:15:28 <Athas> I just used 'stack ghc'.
04:15:32 <fendor> oh, ok
04:15:39 <Athas> Although, if you use the stack.yaml above, you can just do 'stack install accelerate-examples'.
04:16:45 <fendor> why stack install?
04:17:01 <Franciman> When are linear types going to be added to haskell?
04:17:01 <fendor> can't i just locally build it?
04:18:14 <Athas> fendor: sure.
04:18:58 <fendor> Athas, so, 'stack build accelerate-examples' should work?
04:19:09 <cocreature> and once you ared one setting up LLVM 4, LLVM 5 is released and you’ll have to update again ;)
04:19:51 <fendor> cocreature, hehe, probably right. sounds like you dislike llvm?
04:20:19 <cocreature> fendor: nah, I’m the maintainer of llvm-hs (which is what accelerate uses behind the scenes) :)
04:20:33 <cocreature> but LLVM breaking everything in each release is a bit annoying
04:22:56 <fendor> oh cool :) i've heard that, and i can imagine, breaking the api during almost every release is terrible. But i think, it still gives you a lot? except for increased compilation times :D 
04:23:12 <cocreature> sure LLVM is pretty neat
04:23:42 <Athas> fendor: you also need '--flag=llvm-hs:shared-llvm' on the command line, probably.
04:23:42 <cocreature> and most of the time they are actually changing things for the better. but that doesn’t make it less work to adapt to the changes
04:23:58 <cocreature> Athas: that’s the default since llvm-hs-4.something
04:24:00 <fendor> Athas, thanks!
04:25:04 <fendor> cocreature, so if i may ask the old question, do you think that accelerate is faster than the built in llvm backend?
04:25:38 <cocreature> yeah (assuming the one-time overhead of jiting doesn’t matter)
04:26:00 <cocreature> accelerate provides a lot more alias info to LLVM than GHC does
04:26:10 <cocreature> because they can basically say “nothing aliases” iirc
04:26:22 <cocreature> and alias info is really important for some optimizations
04:27:38 <fendor> cocreature, ok, because I'm currently writing my bachelor thesis on a performance comparison between straight forward c and straight forward haskell, and i was thinking if it is worth my time to implement the nbody simulation in accelerate
04:28:47 <cocreature> obviously is not some magic wand that you can use to make your code faster. it works well if your code fits its pattern. if it doesn’t you either just can’t express it or at least it won’t be faster
04:28:57 <cocreature> not sure if nbody simulations fit into that scheme
04:30:17 <fendor> cocreature, you're probably right, but since the problem is a rather simple one, it should be easy to implement it naively, once i am able to run accelerate
04:33:29 <fendor> cocreature, i'm sorry if i annoy you, but since youre the maintainer i'd like to ask you, why my build fails. When building llvm-hs-4.0.1.0, gcc complains about an unrecognized command line option ‘-Wstring-conversion’
04:34:40 <cocreature> fendor: you have to build LLVM using the same C compiler that you use to build llvm-hs
04:35:14 <Myrl-saki> Well
04:35:24 <Myrl-saki> Oh. Wait.
04:35:28 <Myrl-saki> Nothing. C:
04:35:34 <fendor> my llvm version was installed with the local package manager, do i really have to compile it from source?
04:36:02 <Myrl-saki> Actually, not nothing lol
04:36:29 <cocreature> fendor: you could try adding it -Wstring-conversion to https://github.com/llvm-hs/llvm-hs/blob/llvm-4/llvm-hs/Setup.hs#L116 and probably also to ignoredCFlags
04:36:46 <Myrl-saki> Maybe I should have just used modulo instead..
04:37:04 <cocreature> but in general using different compilers is fragile since we use llvm-config --cxxflags to figure out the right flags to pass to the C compiler
04:37:40 <fendor> ok, so, the best course of actions would be to build it from source?
04:37:55 <cocreature> fendor: either that or try the workaround that I just told you about ;)
04:38:50 <cocreature> did something change when it comes to overlapping instances in 7.10? I have some code which complains about an overlapping instance with 7.8 but works in newer GHCs and I don’t understand why
04:39:07 <`Guest00000> what is the length threshold for switching from strict to lazy ByteStrings? few Ks?
04:39:44 <fendor> cocreature, but how do i add the ignoredCFlags, i do not have the sources, should I fork llvm-hs, or is there a simpler way? 
04:40:00 <cocreature> fendor: you’ll have to modify the source
04:40:37 <Myrl-saki> Oh wow.
04:41:30 <fendor> cocreature, ok, another question, why is gcc used if we're using llvm as a backend, would clang be a better option?
04:41:38 <Myrl-saki> :t cast
04:41:39 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
04:41:49 <fendor> that's probably a n00b question :D 
04:42:16 <cocreature> fendor: because apparently ghc and cabal default to gcc on your platform
04:42:37 <fendor> cocreature, can i override this option? or is this pointless?
04:42:52 <cocreature> I doubt it’ll make a difference
04:43:27 <Myrl-saki> :i cast
04:50:15 <Myrl-saki> This is going to be stupid.
04:50:42 <Athas> fendor: are you comparing against well-optimised C?
04:50:57 <Athas> Because there is a rather large performance gulf from Haskell to the best C, I fear...
04:51:19 <Myrl-saki> I have no idea how modular arithmetic works.
04:51:39 <Myrl-saki> Well, no. I have an idea of how modular arithmetic works. I have no idea how to put that into types while preserving peano numbers.
04:51:43 <cocreature> Athas: the trick is to compare yourself to shitty C code and hope nobody notices ;)
04:52:47 <cocreature> Myrl-saki: you want typelevel modular arithmetic?
04:53:00 <fendor> Athas, yes, i'm aware, my work is based on the "Haskell Gap Paper" from Intel, but i did not manager to get the ninja code examples. Therefore i wrote my own libraries using openmp, but it is ok, since it is more like a survey. Because it is really hard to compare code, as you know of course, so, so my tutor told me, i should try to write straight forward c code and compare it to straight forward haskell code
04:53:12 <Myrl-saki> cocreature: Wait, brb. Also. If they do notice, you just claim that "it was the most optimal version I found" C:
04:53:39 <fendor> i'm trying to exploit some local-spatially, but most optimizations should be done by the compiler
04:54:10 <cocreature> when did we get OVERLAPPING and OVERLAPPABLE? did that come in in 7.10?
04:54:56 <fendor> so, as always, every result i obtain is of course not objective. In fact, the current implementations are not comparable... but also, this is ok for a bachelor thesis
04:56:43 <cocreature> depends on whether you want to turn that thesis into a paper and get it published somewhere :)
04:56:51 <Athas> fendor: I have the same problem in my research.  What I do is pick (published) references that I did not write myself.  Supposedly these are at least representative of the code that actually gets written.
04:58:46 * hackagebot SSTG 0.1.1.1 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
04:58:56 <fendor> cocreature, as long as i don't claim that the results have been obtained perfectly, i think that should be ok. It is close to impossible to compare some things. For example, what would be a good library for 2d-convolution in c? i did not found a real library yet. Haskell, on the other hand, has repa, which uses template haskell and optimizes like it was crazy 
04:59:39 <fendor> Athas, as i said, i tried, but even if I get other representatives, it would be hard to compare them to the existing code base by Intel
05:00:10 <bbear> any advice for using regular expressions in Haskell ?
05:02:05 <hpc> only use them for very small things, if at all
05:02:14 <hpc> parser combinators compose better
05:02:38 <hpc> and depending on the regex library you picked, are most likely faster
05:04:21 <bbear> parser combinators do you mean ?
05:04:24 <bbear> Which library is that ?
05:05:04 <bbear> I could actually write my parser for this instead of using a regexp, but it seems really suited here to do the classical regexp matching.
05:05:12 <cocreature> bbear: the most pleasant regex lib is probably https://hackage.haskell.org/package/regex-applicative
05:05:32 <cocreature> it also looks like a parser combinator lib which is pretty nice
05:05:48 <cocreature> I’ve never bothered comparing the performance of the different libs
05:06:42 <hpc> oh hey, that's actually pretty nice
05:07:19 <cocreature> yeah it’s basically parser combinators where you only get an applicative interface
05:07:42 <cocreature> the advantage over the standard parser combinator libs is that you don’t have to bother with left factoring and stuff like that
05:07:45 <hpc> "one" *> pure 1 <|> "two" *> pure 2 -- one of the haddock examples - matches /(one)|(two)/ and returns a sensible haskell value
05:08:21 <cocreature> and you can do search and grep style things a lot easier than using full-blown parser combinator libs
05:08:37 <bbear> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html seems totally outdated.
05:09:08 <lyxia> this regexp lib that Weirich showed at POPL seems nice but it isn't on hackage https://github.com/sweirich/dth/tree/master/popl17
05:09:11 <bbear> hpc: ok but what are (*>), (<|>), (*>) ?
05:09:26 <hpc> part of Applicative and Alternative
05:09:28 <bbear> (new operators I don't know yet)
05:09:29 <hpc> you'd use them with any parser
05:09:40 <hpc> @src (*>)
05:09:40 <lambdabot> (*>) = liftA2 (const id)
05:09:49 <bbear> :t liftA2
05:09:50 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:09:51 <hpc> (*>) is a pretty simple extension of (<*>)
05:09:58 <bbear> :t (const id)
05:09:59 <lambdabot> b -> a -> a
05:10:05 <bbear> :t const
05:10:06 <lambdabot> a -> b -> a
05:10:08 <bbear> :t id
05:10:10 <lambdabot> a -> a
05:10:21 <manek> ertes: 
05:10:31 <hpc> and (<|>) you should read up on yourself, there's a lot you can do with it
05:10:47 <manek> ertes: thank you for the example with C code! indeed it works with the same performance!
05:11:12 <bbear> not today but thanks, I'll take a look
05:12:12 * hackagebot language-c-inline 0.7.11.0 – Inline C & Objective-C code in Haskell for language interoperability – https://hackage.haskell.org/package/language-c-inline
05:13:13 <bbear> :t liftA3
05:13:14 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
05:13:24 <bbear> :t liftA6
05:13:26 <lambdabot> error:
05:13:26 <lambdabot>     • Variable not in scope: liftA6
05:13:26 <lambdabot>     • Perhaps you meant one of these:
05:13:31 <bbear> :t liftA4
05:13:33 <lambdabot> error:
05:13:33 <lambdabot>     • Variable not in scope: liftA4
05:13:33 <lambdabot>     • Perhaps you meant one of these:
05:14:38 <fendor> is there somewhere a recommended editor stack? atom and vscode are driving me crazy... and ghc-mod dies all the time
05:16:30 <hpc> i have found if you add hoogle as a browser search engine and give it a keyword, you can use whatever editor you want
05:18:23 <fendor> hpc, well, i like some feedback and code completion, too ^^
05:28:01 <SepakoRayl> has anyone worked with llvm-hs ?
05:30:36 <nick_h> Does anyone know of a neat way I can convert InputStream [a] -> InputStream a  ... with System.IO.Streams?
05:31:03 <nick_h> .. or maybe tell me if that does not make sense? :)
05:39:12 <lyxia> nick_h: http://hackage.haskell.org/package/io-streams-1.4.1.0/docs/System-IO-Streams-List.html#v:concatLists
05:43:13 <grokkingStuff> Hi there!
05:43:30 <grokkingStuff> i've got a pretty interesting question for you
05:43:53 <grokkingStuff> how would you design types that have "ancestors" 
05:44:29 <grokkingStuff> let's say I have a type Monkey
05:44:53 <grokkingStuff> Monkey is a descendant of Primate
05:45:17 <grokkingStuff> I'd like the type system to recognize Monkey as a Primate in its type system in runtime
05:45:31 <Tuplanolla> @google snoyman's rio monad
05:45:33 <lambdabot> https://www.fpcomplete.com/blog/2017/07/the-rio-monad
05:45:39 <Tuplanolla> Like this, grokkingStuff?
05:46:27 <grokkingStuff> so either signature Monkey -> Monkey and Primate -> Primate. If I pass Primate into Monkey -> Monkey, it should work
05:47:35 <grokkingStuff> Tuplanolla: I don't think so
05:48:12 <grokkingStuff> something in the type system that allows types to be more specific versions of other types
05:48:32 <Tuplanolla> We don't have subtyping.
05:48:47 <grokkingStuff> what's subtyping?
05:49:05 <Tuplanolla> What you just proposed.
05:49:18 <Eduard_Munteanu> You can use typeclasses to describe primate-like behavior.
05:49:43 <Tuplanolla> Types can't have is-a relationships, but type classes can.
05:50:09 <grokkingStuff> But if i want multiple levels of is-a relationships?
05:50:25 <grokkingStuff> say Primate is a Mammal
05:50:32 <Tuplanolla> Those would be type class constraints on other type classes.
05:50:48 <grokkingStuff> so the relationship would be Mammal -> Primate -> Monkey
05:50:58 <grokkingStuff> wait, could you give me an example of that?
05:51:16 <Tuplanolla> In your case that could be `class IsMammal a => IsPrimate a`.
05:51:25 <grokkingStuff> oh. hmmmm
05:51:29 <Tuplanolla> Then your monkeys would have type `IsPrimate a => a`.
05:51:40 <Eduard_Munteanu> class IsMammal a => IsPrimate a where scratchUnderarm :: a -> IO ();      class IsMammal a where feedBaby :: a -> IO ()
05:52:12 <grokkingStuff> could that be used in the type system?
05:52:33 <Eduard_Munteanu> What do you mean?
05:53:01 <grokkingStuff> a typeclass Primate and I use Primate in a type signature
05:53:22 <Eduard_Munteanu> Yes, that's how you use it.
05:53:43 <grokkingStuff> hmmmmm
05:53:47 <grokkingStuff> Thanks Eduard_Munteanu!
05:53:52 <grokkingStuff> I'll try it out
05:54:41 <danilo2> Hi! Could anybody explan to me the biggest mystery of GHC? Namely - why we inline functions only when they are fully applied? I onstantly have to transform `foo a b = ...` to `foo a = \b -> ...` to make it work faster, this is a little ridiculus
05:56:07 <lyxia> can you show your benchmarks
05:56:41 <danilo2> lyxia: are you asking about my benchmarks ?
05:56:47 <cocreature> nobody has come up with a better alternative that’s somewhat predictable
05:57:17 <danilo2> cocreature: but why we need "predictable" ? Maybe its better when we just inline greedy and get better performance ?
05:57:54 <danilo2> are there any downsides of inlining not saturated functions ?
05:58:04 <cocreature> yes inlining is not always benefitial
05:58:14 <lyxia> binaries can get too big
05:58:23 <hpc> or you lose locality on tight loops
05:58:24 <cocreature> it increases codesize which in turn can increase runtime due to cache effects
05:58:34 <zomg_> Anyone happen to know a way to have pandoc stop using smart quotes in ```code blocks```?
05:58:35 <danilo2> cocreature: sure thing, but if I tell that my function should be inlined (by using INLINE pragma) I would love to tell that it would always be beneficial
05:58:51 <zomg_> The only thing I've found about it is --no-tex-ligatures but it does absolutely nothing..
05:59:07 <bbear> ```python
05:59:11 <bbear> code
05:59:12 <bbear> ```
05:59:26 <bbear> usually this is not inline, for inline code you do `code`
06:00:36 <hpc> if you use two backticks, you don't have to escape single-backticks
06:01:40 <cocreature> danilo2: that might be benefitial in your code but maybe someone else has code that performs better if you don’t do that so you need at least two separate pragmas to express both things. I don’t know if adding a new pragma for that has ever been proposed
06:04:36 <danilo2> cocreature: I understand it completely and I think such separate pragma would be beneficial a lot. I have to think more aobut it and potential use cases though
06:14:57 <zomg_> ok figures, needed uptype.sty which was in texlive-latex-extra
06:15:09 <zomg_> erm upquote.sty even
06:19:02 <danilo2> cocreature: btw do you know how C compilers do inlining? Are there any "special" rules or they just inline functions marked to be inlined no matter if they are saturated or not ?
06:20:03 <cocreature> danilo2: they have quite complex heuristics based on the size of the function and whatever else
06:21:47 <danilo2> cocreature: sure, but I'm not exaclty talking about these heuristics. If you mark function to be inlined, c compiler almost surely will inline it. And I'm pretty sure it will do it in every call place, so why cannot we do exactly the same with some superinline pragma?
06:22:31 <danilo2> cocreature: im asking about it because in majority of places my code would benefit from it a lot and would be just nicer looking without all the manual transformations that are easily breakable by other developers
06:23:32 <cocreature> danilo2: well we also have the problem that GHC can sometimes blow up quite badly due to INLINE (e.g., https://mpickering.github.io/posts/2017-05-17-inlining-case-study.html) and disabling the “only inline saturated calls” will only make it worse
06:23:51 <cocreature> I think a “do what I tell you” pragma is probably reasonable but it shouldn’t replace the existing pragmas
06:26:05 <Cale> Yeah, we have a bunch of cases with regard to reflex where certain inlinings and specialisations are extremely important, and convincing GHC to apply them consistently is a bit troublesome in some cases.
06:26:46 <bbear> am I stupid ?
06:27:05 <Cale> ?
06:27:37 <bbear> I am reading this code and it seems quite hard to get an easy flowing understanding. That's why I am asking this question.
06:27:51 <Cale> What is "this code"?
06:27:51 <bbear> https://github.com/feuerbach/regex-applicative/wiki/Examples <- the concerned code
06:28:32 <cocreature> what specifically is confusing you?
06:28:45 <Cale> I guess if you've never seen any other parser combinator library, this would be confusing
06:29:05 <bbear> protocol = HTTP <$ string "http" <|> FTP <$ string "ftp"
06:29:21 <Cale> Would it help to add parens?
06:29:38 <Cale> protocol = (HTTP <$ string "http") <|> (FTP <$ string "ftp")
06:29:45 <bbear> protocol :: RE Char Protocol
06:29:53 <Cale> i.e. try to parse with  string "http", and if that succeeds, the result is HTTP
06:29:53 <bbear> the type is confusing me, not the lack of parenthesis.
06:30:05 <bbear> what the "Char" is doing here ?
06:30:12 <cocreature> RE Char Protocol is a regex that matches a string of Chars and the match result will be a Protocol
06:30:18 <Cale> Presumably that the type of symbols being parsed
06:30:23 <bbear> okay, you mean a list of Chars
06:30:30 <cocreature> a RE Int Protocol would match a list of Ints
06:30:36 <bbear> allright
06:32:19 <bbear> allright, it makes sense.
06:35:07 <bbear> does the ($>) operator exist ?
06:35:23 <cocreature> :t ($>)
06:35:26 <lambdabot> error:
06:35:26 <lambdabot>     • Variable not in scope: $>
06:35:26 <lambdabot>     • Perhaps you meant one of these:
06:35:33 <cocreature> gnah
06:35:39 <cocreature> https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Functor.html#v:-36--62-
06:36:47 <bbear> is this law true always ((<*) a b)==((*>) b a) as well ?
06:37:26 <danilo2> cocreature: hm very interesting (the case study youve linked)
06:44:22 <bbear> cocreature: regexp-applicative does not seem to be easy on the newcommer, neither does it support pattern-matching ?
06:44:27 <bbear> neither grouping ?
06:44:52 <nick_h> lyxia: thanks!!
06:46:39 <cocreature> bbear: what is pattern matching supposed to be?
06:47:08 <cocreature> bbear: you don’t need special support for grouping. just wrap things in parenthesis
06:47:18 <danilo2> Ok, I'm getting a little frustrated about how GHC inlining works :/ I've got a code `t_1R = \n -> runIdentity . sInt . sStr $ repeatM' incState n` it works slow. this one works fast `t_1R = runIdentity . sInt . sStr . repeatM' incState`. Why something like it could even happen? 
06:48:22 <danilo2> I do not see why it happens because these functions seem to be saturated the same way in both examples. Am I wrong? I'm using this function later as: `bench "1R trans (10e6)"     $ nf t_1R 100000000` (bench is criterion util). the first one runs 3times slower than the second
06:48:48 <cocreature> danilo2: if in doubt, try looking at the core
06:50:02 <danilo2> cocreature: I know, but look, if Im developing a really small code, I can constantly look into ccore. But I want to have some kind of guidline I can follow not to break performance in bigger applications. I cannot constantly cut application down to really small parts and inspect the core
06:50:45 <danilo2> cocreature: I just can't understandl ogically why `t_1R = \n -> runIdentity . sInt . sStr $ repeatM' incState n` works slow while `t_1R = \n -> runIdentity . sInt . sStr . repeatM' incState` performs 3times faster
06:50:52 <bbear> I mean doing stuff like (\d{3})-(\s.*) ..
06:51:08 <Myrl-saki> cocreature: I didn't want type-level modular arithmetic, but type-guaranteed modular arithmetic(Finite + overflow.).
06:58:07 <cocreature> bbear: `match (replicateM 3 (psym isDigit) <* (sym '-' *> many (psym isSpace))) "123-   "` will give you `Just "123"`. is that what you want?
06:58:35 <cocreature> Myrl-saki: sry, I have no idea what type-guaranteed modular arithmetic is supposed to be.
07:02:32 <Myrl-saki> cocreature: I guess an example would be the one used in the paper about reflection?
07:02:57 <cocreature> Myrl-saki: I haven’t read that paper :P
07:03:05 <Myrl-saki> cocreature: Oh. :(
07:03:25 <Myrl-saki> cocreature: I'm thinking of just not using Peano numbers.
07:03:34 <Myrl-saki> cocreature: And just use libraries.
07:03:37 <Myrl-saki> And TypeLits.
07:03:47 <cocreature> Myrl-saki: peano naturals are pretty terrible so I’m not sure why you would want them in the first place :)
07:04:46 <Myrl-saki> cocreature: A little aside: Is there a binary equivalent for church numerals?
07:06:15 <manek> Hmm, I'm still sitting on performance related issues and I cannot understand well why something like that could happen. I've got function `test = \a -> foo . bar $ a` and it works 3 times faster than `test = \a -> foo $ bar a`. Is there any explanation (Regarding inlining, etc) why it could happen ?
07:08:58 <cocreature> Myrl-saki: sure you can church-encode all adts so just write an adt for binary numerals and then look up the church encoding of adts
07:10:26 <jmcarthur> Peano numerals have their place.
07:11:44 <cocreature> they have a place in proof assistants. I’m not sure they have a place in actual programs
07:13:19 <jmcarthur> One arbitrary example: I can determine which of two foldable containers has more elements by converting to peano numerals and comparing those, without traversing the longer one all the way.
07:13:48 <jmcarthur> Assuming these are lazy peano numerals.
07:14:42 <jmcarthur> I guess if you're restricting yourself to strict peano numerals then it doesn't make as much sense to use them in real code, again other than writing proofs.
07:14:45 <cocreature> right lazy peano naturals can sometimes be useful but in most cases you’re probably better off writing a direct comparison on those containers instead of hoping that the overhead fuses away
07:15:05 <jmcarthur> I don't necessarily have access to the internals of those containers.
07:15:15 <jmcarthur> This is a more modular way to write it.
07:15:53 <cocreature> it is also a really slow way to write it if the compiler doesn’t manage to eliminate all the overhead
07:16:53 * hackagebot haskell-gi-overloading 1.0 – Overloading support for haskell-gi – https://hackage.haskell.org/package/haskell-gi-overloading
07:16:53 * hackagebot haskell-gi-overloading 0.0 – Overloading support for haskell-gi – https://hackage.haskell.org/package/haskell-gi-overloading
07:18:14 <jmcarthur> There's not much of better guarantee you can make if you are writing polymorphic code.
07:18:26 <jmcarthur> Or if you don't have access to the internals.
07:20:08 <AndreasK> manek: If there are rules defined that fire on one but not the other
07:22:12 <manek> AndreasK: there are no rules to my knowledge. `foo` is just `evalState` from Control.Monad.State, `bar` is just a loop function without any rules
07:30:30 <AndreasK> manek: If you can reproduce it reliably might be worth creating a bug report. I've hit a genuine compiler bug where syntactic difference caused a memory leak once before
07:31:30 * hackagebot hoogle 5.0.13 – Haskell API Search – https://hackage.haskell.org/package/hoogle
07:34:52 <manek> AndreasK: I'm already preparing bug report description here. Sadly it will be third this week (the earlier two seem to be confirmed and a little diagnosed on bugtracker)
07:36:41 <rembo10> Hey, what's the best way to turn a record type into a hashmap?
07:37:23 <rembo10> Should I be using Aeson?
07:41:00 * hackagebot haskell-gi 0.20.3 – Generate Haskell bindings for GObject Introspection capable libraries – https://hackage.haskell.org/package/haskell-gi
07:41:00 * hackagebot haskell-gi-base 0.20.4 – Foundation for libraries generated by haskell-gi – https://hackage.haskell.org/package/haskell-gi-base
07:41:45 <Cale> rembo10: I would only use Aeson if I was actually working with JSON.
07:42:03 <Cale> rembo10: You want an unordered-containers HashMap?
07:43:35 <grokkingStuff> Hi there! So I was looking at subtyping and I found this interesting article http://cs.unm.edu/%7Estelleg/subtypes/
07:44:36 <grokkingStuff> In essence, you define a subtype in terms of another type
07:44:48 <grokkingStuff> so True in terms of Bool
07:45:33 <grokkingStuff> the cool part is that this doesn't violate the subtype substitution rule
07:45:43 <grokkingStuff> what's your take?
07:45:47 <grokkingStuff> is it worth it?
07:46:18 <grokkingStuff> i've read that subtyping isn't usually done because type inference is a bit wonky. Would this have the same issue?
07:47:10 <bbear> https://github.com/elijahbal/advent-of-code/blob/master/hash-code.hs <- is my code ok ?
07:48:24 <Cale> grokkingStuff: Rank N types (let alone impredicative types) won't be inferred by GHC
07:48:40 <Cale> grokkingStuff: So you'll need a lot of type signatures where you might otherwise not.
07:48:51 <grokkingStuff> Cale: really? So i'd have to define everything on my own.
07:49:12 <grokkingStuff> a lil'bit of Template Haskell since i'm heading to hell anyways.
07:49:54 <Cale> This is sort of a cute technique, but it's not terribly practical, and I would argue against using it in a real world scenario
07:50:28 <grokkingStuff> Cale: thanks for the advice! got another question for you
07:50:45 <grokkingStuff> i can implement the whole subtype thing quite easily with normal data types
07:50:59 <grokkingStuff> (except i won't be able to use it in a type signature)
07:51:31 <grokkingStuff> could i write a plugin of sorts that implements those data types as actual types?
07:51:43 <Cale> Well, let's look at what types you have. Maybe you don't need subtyping at all?
07:52:47 <Cale> What are you trying to represent?
07:52:58 <grokkingStuff> Dimensional types
07:53:09 <grokkingStuff> like Length and Weight
07:53:18 <grokkingStuff> except i want partial dimensions
07:53:33 <grokkingStuff> so each dimension would be a subtype of another dimensino
07:53:43 <grokkingStuff> like Height would be a subtype of Length.
07:54:13 <Cale> Wait, what? Why would Height be a different type from Length?
07:54:57 <Cale> Is there any substantial difference there? That could just be a newtype wrapper
07:55:04 <bbear> Width, Height are subtypes of Length. I mean this is what he meant.
07:55:19 <bbear> But basically (from a physical point of view) they are the same thing.
07:55:24 <grokkingStuff> yeah i want to write functions that work on those derived types
07:55:27 <grokkingStuff> Like this
07:55:38 <bbear> In Haskell you would just write type Height = Length
07:55:48 <Cale> bbear: *Maybe*
07:55:49 <grokkingStuff> if i write a function Height -> Width -> Length
07:56:07 <Cale> bbear: You might use newtype
07:56:15 <grokkingStuff> I'd like the function to fail if I called it with function Width Height
07:56:18 <Cale> if you wanted Height and Length to not be interchangeable
07:56:40 <grokkingStuff> Cale: I want Height and Length to have an is-a relationship
07:56:51 <grokkingStuff> Height is a Length, not the other way round
07:56:58 <Cale> grokkingStuff: Yeah, that's not going to happen.
07:57:08 <Cale> But what you *can* do is use a newtype wrapper
07:57:12 <grokkingStuff> not with newtypes, anyway
07:57:24 <grokkingStuff> Cale: how?
07:57:31 <Cale> newtype Height = Height { getHeight :: Length }
07:58:17 <Cale> So now if you have  x :: Length  you have to explicitly apply the Height constructor  Height x :: Height
07:58:40 <grokkingStuff> What if I wrote an argument that accepted Height but I passed a Length instead
07:58:48 <Cale> Error
07:59:02 <grokkingStuff> that's the problem with newtypes
07:59:05 <Cale> You have to apply either Height or getHeight
07:59:12 <Cale> to wrap or unwrap it
07:59:22 <grokkingStuff> what i want is this -> https://en.wikipedia.org/wiki/Liskov_substitution_principle
07:59:29 <grokkingStuff> except with types
07:59:33 <Cale> I'd say just give up on that
07:59:39 <Cale> Not going to happen :)
07:59:52 <mnoonan_>  subtyping and HM type systems don’t play too nicely together
08:00:31 <grokkingStuff> noooooooo
08:00:38 <Cale> Types are not just arbitrary collections of terms.
08:01:05 <cheater> hi
08:01:28 <cheater> when using hmatrix, if i have 5 scalar values, how can i put them all into a 5><1 vector?
08:01:29 <rembo10> Cale: sorry, yeah, an unordered-containers hashmap
08:01:43 <Cale> rembo10: I'd just build it using fromList
08:02:01 <rembo10> that's what I'm doing now
08:02:09 <rembo10> I just thought maybe there was a more idiomatic way
08:02:25 <rembo10> But then to go from hashmap to record?
08:02:37 <rembo10> Do I have to do lookups and handle the maybes?
08:02:55 <monochrom> cheater: I need to confirm: What is the type of your "scalar values"?
08:03:01 <rembo10> There's 4 fields so not that big a deal but it seems like there'd be a better way :-)
08:03:04 <Cale> cheater: (5 >< 1) [a,b,c,d,e]
08:03:34 <grokkingStuff> Cale: what about the HasField implementation?
08:04:35 * hackagebot postgresql-simple-migration 0.1.10.1 – PostgreSQL Schema Migrations – https://hackage.haskell.org/package/postgresql-simple-migration
08:04:47 <monochrom> Also, the Vector type is not going to commit itself to either "row vector" or "column vector". It gets re-interpreted as you choose #> vs <# etc
08:04:58 <Cale> grokkingStuff: Well, you can introduce a type class like... class HasLength t where getLength :: t -> Length
08:05:10 <Cale> grokkingStuff: and then write instances of that for Width and Height
08:05:15 <monochrom> Only the Matrix type can be "5><1"
08:05:19 <cheater> Cale and monochrom: hmm, well i'm actually using hvx, so i get a list of types that hvx uses. [Expr 'Affine 'Nondec]. Each element of this list is created like this: x1 = EVar "x1" and so on.
08:05:31 <monochrom> OK I don't know hvx.
08:05:33 <grokkingStuff> Cale: So I'd be implementing subtypes via typeclasses?
08:05:38 <Cale> cheater: Wh... what?
08:05:48 <cheater> Cale: hvx is a library.
08:06:07 <Cale> Okay, I've never heard of that
08:06:15 <monochrom> I don't think there is such a thing on hackage.
08:06:17 <Cale> grokkingStuff: Not subtypes...
08:06:30 <cheater> hvx is a convex optimization library. it's not on hackage, only on github, and the docs suck slightly.
08:06:40 <Cale> grokkingStuff: A class is not a type, after all
08:06:47 <cheater> but i use it because it's so far the most useable convex optimization library i've come across.
08:06:49 <grokkingStuff> hmmmmm
08:07:00 <monochrom> grokkingStuff: A Haskell "class" is a collection of types, not a collection of values.
08:07:01 <grokkingStuff> i'll figure something out. Not ready to give up yet, Cale
08:07:04 <cheater> so EVar creates a variable that hvx will optimize over.
08:07:14 <grokkingStuff> monochrom & Cale: yeah i get it
08:07:27 <grokkingStuff> it's not really a subtype but it "works"
08:07:35 <grokkingStuff> not useful.
08:07:36 <Cale> grokkingStuff: But you can have similar sorts of polymorphism, where you have a function which is willing to work with any type of value for which there is an instance of a given type class.
08:07:46 <cheater> i guess it's a scalar, so maybe i should just do something like, [1,0,0,0,0]*~x1 +~ [0,1,0,0,0]*~x2, and so on
08:08:55 <cheater> (well actually it'll be like, ((5><1) [1,0,0,0,0]) *~ x1 +~ ...)
08:09:03 <monochrom> If you want to use subtyping, you use a language that actually has subtyping, OK? Not shoehorning it into C or Haskell.
08:09:37 <cheater> i'm glad i forgot what subtyping worked like in scala, all that stuff is too weird for me
08:35:10 <cheater> hey, why would i be getting this type error http://sprunge.us/jjOT in this code http://sprunge.us/Xibf ?
08:35:28 <cheater> it's quite bizarre
08:36:24 <cheater> why would a var suddenly turn from Int to something else? this is very funny
08:37:46 <cheater> here's more related code: http://sprunge.us/WgjT
08:38:41 <monochrom> What is the type of EConst?
08:42:31 <glguy> cheater:                 where v = EConst $ unitVectAtIndex (i :: Int)
08:42:35 <glguy> this is not inside the lambda
08:42:50 <cheater> EConst :: Mat -> Expr Affine Const
08:42:59 <cheater> type Mat = Matrix Double
08:43:20 <monochrom> Then probably what glguy said. Different i.
08:43:20 <cheater> so EConst is getting the right type as the argument
08:43:27 <cheater> there is no different i
08:43:57 <cheater> i indented the where more, and it didn't help
08:44:25 <cheater> like this http://sprunge.us/caNH
08:44:42 <cheater> this is the only i in the whole file.
08:45:16 <monochrom> Is there an "i" from the imports that is a shorthand for 0:+1 ?
08:45:53 <cheater> maybe
08:45:57 <cheater> let me try another name
08:45:58 <monochrom> Also, you should indent it less, not more, to remind yourself what Haskell thinks of this code.
08:46:19 <monochrom> f =
08:46:28 <monochrom>                 \x y -> x+y+x
08:46:28 <glguy> cheater: indenting the where isn't helping, the i inside the where is not the one you bound in the lambda \
08:46:34 <monochrom>   where z = whatever
08:46:50 <cheater> monochrom: i didn't understand what you meant
08:46:52 <monochrom> What I've just shown is honest indenting.
08:46:54 <cheater> with that last comment
08:47:23 <cheater> glguy: hmm, how do i use a where with a lambda then?
08:47:29 <glguy> you don't
08:47:32 <monochrom> Cannot.
08:47:32 <cheater> really?
08:47:35 <cheater> oh
08:47:40 <cheater> well that explains it then
08:47:51 <monochrom> "where" belongs to the "=" not to an expression.
08:48:25 <monochrom> Honest indenting will remind you of that. Misleading indenting will make things look like "where" is a synonym for "let".
08:48:46 <cheater> what is honest indenting?
08:49:09 <monochrom> There are a lot of misleading indenting on people's blogs you learned from.
08:49:18 <monochrom> Honest indenting is what I just showed.
08:49:52 <monochrom> "where z = whatever" is a child of "f =", not a child of "x+y+z"
08:50:10 <monochrom> Not even a child of "\x y ->"
08:51:04 <cheater> i don't understand how what you showed works
08:51:17 <cheater> why did you add like 10 spaces when f has 0 spaces indent?
08:51:44 <cheater> what is "honest" about that?
08:51:46 <monochrom> To show that "where z = whatever" is not a child of "\x y ->" or "x+y+z"
08:52:46 * hackagebot parser-combinators 0.2.0 – Lightweight package providing commonly useful parser combinators – https://hackage.haskell.org/package/parser-combinators
08:53:28 <cheater> oh, so you mean indent the lambda more than the where
08:53:48 <monochrom> Equivalently, the "where" less.
08:53:56 <cheater> yes, so it turns out there's an i from imports, and the where was not working with the lambda.
08:54:04 <cheater> that solved the mystery, thank you
08:55:41 <monochrom> Do not indent something more than it really is.
08:56:22 <monochrom> While Haskell grammar tolerates it, it is a trap for your reader.
08:57:03 <cheater> i normally indent 2 chars
08:57:09 <cheater> i just did this as a test here
09:01:17 <cheater> why does GHC allow this to be "fixed" in two different ways? http://sprunge.us/gNCN
09:01:44 <cheater> why does GADTs allow a thing that can be done with TypeFamilies too and vice versa?
09:01:48 <cheater> that's a bit confusing
09:02:21 <glguy> Which part is confusing?
09:02:23 <Cale> cheater: Because there's no specific extension for turning on type equalities, but both of those enable them.
09:03:44 <cheater> glguy: what Cale just mentioned
09:03:48 <cheater> Cale: gotcha
09:04:24 <cheater> ok, so the type error says that it's illegal to use type equalities, not that the type equality i'm using there is illegal
09:04:43 <cheater> gotcha
09:15:19 * hackagebot jsons-to-schema 0.1.0.0 – JSON to JSON Schema – https://hackage.haskell.org/package/jsons-to-schema
09:15:36 <anelson-> hello all, I'm unfamiliar with GHC Generics, but is there a way that I could use them (or something else) to make a function that would return the constructor name of an instance of a sum type?
09:16:04 <monochrom> I think yes. I forgot how.
09:16:19 <monochrom> Actually GHC.Generics probably can do this.
09:16:38 <cocreature> https://hackage.haskell.org/package/base-4.10.0.0/docs/GHC-Generics.html#g:23
09:17:00 <monochrom> Because for example aeson and cassava use GHC.Generics to rediscover constructor names too and output them to files.
09:17:28 <anelson-> yeah, I figure it's possible, I just am not sure how. The type signatures in the generics module are kind of confusing
09:17:30 <glguy> Probably easier to use SYB
09:17:34 <glguy> > toConstr (Left True :: Either Bool Int)
09:17:36 <lambdabot>  Left
09:17:46 <Myrl-saki> Well
09:17:56 <Myrl-saki> This is funny.
09:17:59 <anelson-> glguy: what's SYB?
09:18:07 <monochrom> Oh it did take me a while to learn my way around GHC.Generics, yes. And even then I've all forgotten what I learned. :)
09:18:36 <glguy> anelson-: http://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Data.html
09:18:57 <glguy> "Scrap your boilerplate", it's one of the datatype generic programming libraries available
09:19:32 <Myrl-saki> Oh right.
09:19:32 <anelson-> glguy: looks like dataTypeName might be what I'm after...
09:19:47 * monochrom invents "Generic genericity: One library that subsumes all of SYB, GHC.Generics, ..."
09:20:13 <anelson-> but I'm not sure how to produce a DataType
09:20:28 <monochrom> I think you say "deriving DataData"
09:20:56 <monochrom> deriving (Typeable, Data)
09:21:23 <monochrom> Also turn on {-# LANGUAGE DeriveDataTypeable, DeriveDataData #-}
09:21:26 <glguy> anelson-: How about writing up a hand-written version of what you wanted and putting that on lpaste.net ?
09:21:46 <glguy> and then we can worry about what it would look like implemented in a generics library
09:21:55 <anelson-> glguy: OK, gimme a sec :)
09:22:56 * hackagebot servant-ruby 0.3.0.0 – Generate a Ruby client from a Servant API with Net::HTTP. – https://hackage.haskell.org/package/servant-ruby
09:25:22 <anelson-> glguy: http://lpaste.net/357306
09:26:39 <glguy> anelson-: OK, you can build that with (constrRep . toConstr) and then casing on the resulting ConstrRep type to produce your String
09:27:14 <glguy> err, even just  showConstr . toConstr    should do it
09:28:01 <anelson-> glguy: nice, this looks promising
09:29:36 * hackagebot gi-atk 2.0.13, gi-cairo 1.0.13, gi-gdk 3.0.13, gi-gdkpixbuf 2.0.13, … and 25 more
09:29:36 * hackagebot  → https://hackage.haskell.org/packages/recent
09:31:36 <sm> nice, hackagebot 
09:33:47 <anelson-> glguy: the Data class requires some functions to be implemented, though... :|
09:33:59 <glguy> anelson-: You don't write your own Data instances
09:34:24 <anelson-> how do I get them then? just writing `instance Data MyType` gives me warnings about unimplemented functions
09:34:39 <anelson-> :r
09:34:45 <anelson-> lol whoops
09:34:55 <anelson-> also can't make a derived instance :(
09:35:49 <anelson-> ah, DeriveDataTypeable, there we go
09:40:35 <akr> Hello, I'm looking for a function that expands pathnames to an absolute path, including expanding the ~ on Linux
09:40:43 <akr> I have been unable to find this
09:41:02 <akr> I'm pretty sure someone must've implemented this before and stuck it in a library somewhere… right?
09:45:34 <anelson-> akr: probably not in base. You might be able to find a library that provides it but it might be easiest to just implement yourself
09:45:54 <akr> meh… this seems like really basic functionality :|
09:46:11 <ddk> Hello all !!
09:46:41 <anelson-> akr: coming from python (os.path.expanduser) I agree... however in this case it is pretty trivial to write
09:47:50 <ddk> First of all I would like to thank the community ....that ultimately I got a real Haskell Job  ....last time someone helped me like a miracle happend to me with grenade library..!!
09:49:05 <AndreasK> there is a filepath package on hackage but seems it only has makeRelative
09:50:08 <butterthebuddha> Anyone mind giving me a quick rundown of foldr?
09:50:39 <ddk> now I need to get started with tasty ....I have not done testing before ... can someone guide me a little for testing with Haskell
09:51:01 <ddk> butterthebuddha: do you know the type of foldr...
09:51:03 <akr> AndreasK: for bonus confusion, notice that makeAbsolute is in a different package
09:51:14 <butterthebuddha> ddk: Yeah but I don't quite understand how it work
09:51:16 <butterthebuddha> works*
09:51:42 <AndreasK> butterthebuddha: I found the entry on the haskell wiki aproachable when i started: https://wiki.haskell.org/Fold
09:51:43 <ddk> butterthebuddha: write it here I w'll explain it to you
09:52:31 <Myrl-saki> Couldn't match type ‘V.ToNat n + 1’ with ‘1 + V.ToNat n’
09:52:33 <Myrl-saki> Reeeeeeeeeeeeeeeee
09:53:20 <kzhang> What are the alternatives to "type-list"(https://hackage.haskell.org/package/type-list)? It says it is deprecated.
09:53:26 <Myrl-saki> I have no idea what I should even search.
09:53:44 <Myrl-saki> kzhang: HVect?
09:53:49 <Myrl-saki> Not sure though.
09:54:42 <ddk> I have to get started with tasty ....I have not done testing before ... can someone guide me a little for testing with Haskell .. or the flow 
09:57:04 <kzhang> Myrl-saki: HVect is more powerful and certainly can do what "type-list" does. But I don't need that much power.
09:58:00 <kzhang> I just need a type-level list to group my phantom types together 
09:58:20 <monochrom> Myrl-saki: I think "X + 1" vs "1 + X" just comes down to waiting for a future GHC version that does more type-level arithmetic.
09:59:01 <Myrl-saki> monochrom: To update or not to update..
09:59:06 <kzhang> Myrl-saki: Do you happen to know why is "type-list" deprecated?
09:59:19 <Myrl-saki> kzhang: Nope. I just learned about it from the convo.
10:00:11 <ddk> is my question is not concrete ...
10:00:12 <Myrl-saki> monochrom: Can I like... do something about this?
10:00:38 <Myrl-saki> monochrom: I guess I could have a Comm typeclass?
10:00:39 <monochrom> I don't know. I actively avoid type-level arithmetic.
10:01:39 * hackagebot Lazy-Pbkdf2 3.0.0 – Lazy PBKDF2 generator. – https://hackage.haskell.org/package/Lazy-Pbkdf2
10:03:31 <monochrom> I think current GHC knows "5+1 ~ 6" and "1+5 ~ 6" so "5+1 ~ 1+5" will work out, but as soon as you have variables, it's completely different, "x + 1" vs "1 + x" with x variable/unknown.
10:04:07 <akr> Hmm, there isn't a package for cloning / pulling git repositories?
10:05:33 <Myrl-saki> You know.
10:05:36 <Myrl-saki> This is really funny.
10:05:42 <monochrom> system "git clone xxx"
10:05:43 <Myrl-saki> Typechecking fails if I do the right thing.
10:05:45 <mniip> goldfire has a solution for this
10:05:51 <mniip> via dependent types ;p
10:06:41 <akr> monomon: yeah I was looking for something nicer :P but I guess this will have to do…
10:07:33 <Myrl-saki>  Could not deduce: (m + 1) ~ (1 + ((m + 1) - 1))
10:07:39 <Myrl-saki> This is just getting worse and worse lol
10:08:03 <monochrom> Afterall, I did that to call up curl, instead of using a curl library :)
10:08:20 <akr> heh
10:09:08 <anelson-> Myrl-saki: it's not surprising that it can't deduce that automatically. In a language like Coq you'd need to write a proof of such a thing. Although, SMT solvers and the like could figure it out.
10:09:18 <glguy> best is to not do typenat arithmetic, second best is to use a ghc plug-in to solve the constraints
10:10:10 <manek> Myrl-saki: Im not in this topic, however I saw your message. GHC cannot prove such thesis on typelevel, however if you tell him you promise it is true it will accept it
10:10:34 <manek> Myrl-saki: so you can always add as a premise (((m+1)-1) ~ m)
10:10:49 <manek> Myrl-saki: to my knowledge we cannot (yet) tell GHC that it is true for every `m`
10:10:57 <Myrl-saki> manek: Thanks.
10:11:21 <wz1000> Myrl-saki: look at https://github.com/wz1000/HMat/blob/master/src/Proofs.hs
10:11:53 <monochrom> GHC is at the same level as your childhood before you learned algebra.
10:12:01 <nshepperd_> Myrl-saki: ghc-typelits-natnormalise
10:12:15 <nshepperd_> Type checker plugin that adds that capability to ghc
10:12:21 <monochrom> So it could do 5+1 ~ 6 but it never thought about x+y because you didn't either.
10:12:52 <monochrom> And even then, to do 5+1 ~ 6 it actually counted fingers, because you did too.
10:13:04 <wz1000> The sad thing is that we get most of these proofs for free by lifting data Nat = Z | S Nat
10:13:19 <nshepperd_> You will also probably want ghc-typelits-knownnat if you plan to use these nats at runtime
10:13:27 <Myrl-saki> nshepperd_: Can this be done transparently with stack/cabal?
10:13:35 <Myrl-saki> nshepperd_: Well, not transparently.
10:13:44 <Myrl-saki> nshepperd_: Can I pass a cabal/stack file and have it work immediately?
10:13:47 <wz1000> so ghc can do it in principle - just the implimentation of typelits is screwed up
10:13:56 <Myrl-saki> (I haven't used a ghc plugin at all.)
10:14:41 <manek> by the way, is it planned to add such support to GHC that I could write a constraint (forall m. (((m+1)-1) ~ m) ?
10:14:42 <nshepperd_> Myrl-saki: you just add the packages as a dependency and put a ghc options pragma at the top of the file you need it in
10:14:43 <wz1000> I think you can get pretty far by using unsafe coerce to prove the properties you want
10:15:38 <Myrl-saki> manek: A constraint with a forall?
10:15:55 <kzhang> I found this package (http://hackage.haskell.org/package/singletons-2.3) has the promoted functions that I need.
10:15:58 <Myrl-saki> (This is my first time doing type-level calculations lol)
10:17:32 <nshepperd_> https://hackage.haskell.org/package/ghc-typelits-natnormalise explains how to use it
10:17:41 <manek> Myrl-saki: yes, contraints with forall are called impredicative if im not wrong
10:17:48 <kzhang> and a interesting paper: http://cs.brynmawr.edu/~rae/papers/2014/promotion/promotion.pdf
10:19:18 <wz1000> type lits should just be syntactic sugar for the lifted Peano nats
10:19:33 <nshepperd_> wz1000: peano nats are slow though
10:19:55 <nshepperd_> And the proofs may be even slower if you actually run them :s
10:20:11 <wz1000> does it matter that much at the type level?
10:21:18 <wz1000> you aren't going to do complicated numerical processing with types
10:22:35 <wz1000> Peano nats make it easy(or at least *possible*) to write proofs - which is what you really care about when dealing with types
10:22:50 <nshepperd_> I have used Nats up to the tens of millions. I don't fancy waiting for ghc to count up to ten million for every nat calculation
10:23:34 <wz1000> why?
10:23:44 <monochrom> wz1000's spirit is right. If the Peano ADT is too slow, you can always use a binary ADT instead. The proofs are harder but faster.
10:23:56 <nshepperd_> And if you write proofs that aren't just unsafeCoerce Refl they will have to be run at runtime
10:24:04 <`Guest00000> so
10:24:17 <Myrl-saki> I should just go to sleep lo
10:24:17 <`Guest00000> `zlib` package can decompress purely
10:24:19 <Myrl-saki> l
10:24:24 <`Guest00000> but it can't signal errors purely
10:24:34 <monochrom> Really?!
10:24:52 <nshepperd_> Yes, binary adt is better
10:25:50 <monochrom> Ah, it's true of Codec.Compression.GZip
10:25:57 <`Guest00000> is there a package which is better? which can signal errors through Left s instead of *** Exception: ?
10:26:05 <wz1000> or we can just have the equivalent of fromInteger at the type level
10:26:16 <wz1000> so you can use any underlying representation you want
10:26:34 <`Guest00000> why are libraries so flawy?
10:26:49 <`Guest00000> why is there at least one thing which i'm upset about for any lib i see?
10:27:33 <monochrom> OK you have just entered ranting mode, and it is best to direct you to a tree hole.
10:28:01 <`Guest00000> monochrom: what does this mean
10:28:06 <Myrl-saki> Lmao
10:28:22 <`Guest00000> well, i found pure-zlib, but it can *only* decompress
10:28:22 <Myrl-saki> So, I half-created an infinite type, I guess.
10:28:43 <nshepperd_> It would be nice if the type level numeric literals were polymorphic
10:28:49 <manek> `Guest00000: why do you need to compress something? it is obsolete
10:28:53 <manek> `Guest00000: just joking
10:28:55 <manek> :D
10:28:59 <nshepperd_> Is that even possible
10:29:16 <`Guest00000> manek: sorry, I don't get the meaning
10:29:19 <nshepperd_> Lifted Num typeclass
10:29:20 <wz1000> nshepperd_: I would really like to see the usecase where you have type level lits in the order of a million
10:29:30 <`Guest00000> it's a joke about high level?
10:29:34 <wz1000> -XKindClasses :p
10:30:26 <nshepperd_> wz1000: machine learning. My nats describe the size of a neural network, including the number of parents
10:30:41 <nshepperd_> Er, parameters
10:31:04 <monochrom> HOL4 uses a binary ADT for its natural number type.
10:31:28 <bbear> or so
10:31:36 <Myrl-saki> Maybe.
10:31:38 <Myrl-saki> Just maybe.
10:31:43 <Myrl-saki> I should just use the library's peano numbers.
10:31:58 <nshepperd_> A million parameters is pretty normal in deep learning
10:32:05 <Myrl-saki> The problem is that I don't know how to (safely) implement modular arithmetic for finite types.
10:32:32 <monochrom> My sentence is an oversimplification. It is not an ADT in the Haskell or SML sense. But it is something equivalent to ADT.
10:34:47 <monochrom> Yeah mod is going to be our current story lifted to a whole new level.
10:35:04 <monochrom> Because basically you have to define division first.
10:35:35 <monochrom> And not just give an algorithm for division, but also basic theorems satisfied by the answers of division.
10:35:38 <wz1000> you don't need a concept of division for modular arithmetic
10:35:56 <monochrom> Because the whole point is those basic theorems rather than the division algorithm itself.
10:45:20 <bbear> nobodythought of a replace function for the stdlib ? something like replace :: (a -> Bool) -> a -> [a] -> [a] ?
10:46:03 <monochrom> No. But they thought of map (\x -> if x =='c' then 'b' else x)
10:46:23 <bbear> ok...
10:48:01 <bbear> let's try with the map
10:48:08 <geekosaur> consider that if you need that, there's a significant chance you should be using a better structure than a linked list
10:48:25 <mniip> bool 'b' <*> (== 'c')
10:49:13 <bbear> geekosaur: how's that ?
10:49:26 <bbear> find and replace has alway been O(n) algorithm ?
10:49:32 <monochrom> Have you also thought of conditional_transformation :: (a -> Bool) -> (a -> b) -> b -> [a] -> [c]?
10:49:55 <monochrom> err, s/c/b/
10:49:58 <bbear> doing it with a linked list is the total good data structure for tihs kind of stuff ?
10:50:57 <bbear> ha no
10:51:00 <bbear> you're right
10:51:11 <bbear> because I have to store my result somewhere, i cannot do inplace replacement.
10:51:31 <bbear> because cons.
10:51:35 <bbear> So I would have to use reverse.
10:52:05 <bbear> The map is much better then.
10:56:44 <mniip> Map can't do inplace replacement either...
10:56:50 <mniip> this is haskell
10:57:08 <mniip> anything defined as an ADT cannot do inplace replacement
10:57:10 <bbear> yes I know it build a new list but this is still O(n) in time.
10:57:23 <mniip> it builds a new map juts as well
10:57:42 <monochrom> It is efficient or inefficient depending on the rest of the program.
10:58:09 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
10:59:52 <bbear> how can you shift letters in a cyclic manner ?
11:00:31 <bbear> 'a'->'e', 'z'->'d', etc.
11:00:45 <bbear> Ascii code is probably the most direct answer
11:01:46 <mniip> ord -> modulo arithmetic -> chr
11:01:52 <mniip> or fromEnum/toEnum
11:03:13 <sqooq> is there some way to uninstall something that I installed with stack
11:03:39 <MarcelineVQ> delete it from .local/bin
11:03:54 <MarcelineVQ> if you mean an executable
11:04:19 <sqooq> I'm on windows
11:05:14 <sqooq> I kind of want to just start fresh
11:05:26 <sqooq> all this stack, cabal nonsense is driving me nuts
11:05:51 <MarcelineVQ> you can ask stack where the install dir is with   stack path --local-bin
11:06:23 <MarcelineVQ> but I'm not sure if that's what you're after exactly, start fresh in what way?
11:06:55 <sqooq> Idk, uninstall, reinstall
11:07:38 <MarcelineVQ> are you wanting to wipe your stack setup or executables you've installed via stack install?
11:09:12 <sqooq> idk, I found the location
11:09:32 <sqooq> but that's just the exe no? I also see some sr/sandbox/... thing being used for the exe
11:10:14 <MarcelineVQ> which exe?
11:10:20 <sqooq> ghc-mod
11:11:08 <sqooq> "C:\sr\snapshots\62cfb14b\pkgdb\package.cache" in particular
11:11:47 <MarcelineVQ> stack install for ghc-mod should create 3 executables in your   stack path --local-bin  folder.  ghc-mod, ghc-modi, and hlint you can delete these to uninstall ghc-mod
11:11:58 <sqooq> ok
11:12:09 <MarcelineVQ> snapshots is where stack stores built libraries it shares between projects
11:12:19 <sqooq> I have 2
11:12:23 <sqooq> snapshots
11:12:35 <MarcelineVQ> well, usually, I don't actually recognise that directory format, so that may be something else
11:13:19 <bbear> is there a pattern matching algorithm in haskell widely usable ?
11:13:25 <sqooq> C:\sr\snapshots\2af6cf35\share\x86_64-windows-ghc-8.0.1\ghc-mod-5.6.0.0
11:13:35 <bbear> I mean similar to 'foo' in "bar baz foo" of python ?
11:14:03 <sqooq> also "\AppData\Roaming\ghc-mod"
11:15:10 <sqooq> is it bad to use stack install?
11:15:13 <MarcelineVQ> I'm not sure where all things might get stuck in windows. stack path --snapshot-pkg-db  will tell you if that's the folder stack uses for storing built libraries it shares between projects, in which case you can leave the ghc-mod folder or delete it, it won't harm things either way
11:15:51 <sqooq> ok, when I use stack install it just copies ghc-mod from the \sr\snapshot\... location
11:15:57 <MarcelineVQ> all stack install does is build a thing, and copy any executables from that thing to  stack path --local-bin
11:15:57 <sqooq> so I just get the same one everytime
11:16:13 <sqooq> so how do I start fresh
11:17:12 <sqooq> ok I'm gonna try removing it from the snapshot
11:17:13 <MarcelineVQ> a virgin stack?  delete the dir  stack path --stack-root  reports and run  stack setup
11:17:41 <MarcelineVQ> If you just want ghc-mod gone you can delete its folder from snapshot
11:17:52 <sqooq> but it's also in \bin
11:17:54 <sqooq> the exe
11:18:00 <sqooq> either way I deleted sr which was the stackroot
11:18:22 <sqooq> we'll see how that goes
11:18:22 <sqooq> thanks
11:18:59 <MarcelineVQ> what problem were you having that prompted you to want to delete things?
11:19:40 <sqooq> ghc-mod wouldn't work
11:19:51 <sqooq> and was somehow installed with an old ghc version
11:21:49 <MarcelineVQ> oh, this won't fix that.   ghc-mod is tied to the version ghc and of libraries you use, which means any change in resolver is likely to break it. the way around that problem is to run  stack build ghc-mod  in the root of each project you want to use ghc-mod for, and use an editor that is aware of stack so that it searches the project's .stack-work/ for the ghc-mod version you built
11:22:07 <MarcelineVQ> Well, it might fix that for the moment, but it'll crop up again
11:22:29 <sqooq> well I tried that
11:22:43 <sqooq> I'm trying to use ghc-mod with the Atom text editor
11:22:52 <sqooq> I tried doing it locally but it still gave errors
11:23:27 <sqooq> Is there a way to execute the project local ghc-mod from my terminal?
11:23:38 <sqooq> to test what's going on
11:26:25 <MarcelineVQ> sure,  if you've ran stack build ghc-mod from the proejct root you can run stack exec -- ghc-mod
11:26:45 <sqooq> ok
11:26:58 <MarcelineVQ> also a good option is  stack exec -- which ghc-mod  to see if it's finding the right one
11:27:13 <sqooq> ok
11:27:15 <aphorisme> Would you rather make the state explicit when using Kleisli-Arrows (which would result in arrows like `Kleisli m (State, a) (State, b)` or stack a state transformer on top of m?
11:28:03 <MarcelineVQ> it's not a solution but these days I reccomend using  ghcid  instead of ghc-mod, because it tends to 'just work'
11:28:37 <MarcelineVQ> they don't do quite the same job which is why it's not a solution
11:29:46 <sqooq> Well I just wanted to have error checking and stuff in my text editor
11:29:53 <sqooq> and I like atom because it's a e s t h e t i c
11:30:15 <sqooq> I don't think there's a ghcid package
11:30:17 <sqooq> for atom
11:30:51 <monochrom> aphorisme: I think I would start from StateT on top of m first. But it depends on the rest of the program.
11:30:58 <MarcelineVQ> it's not an atom plugin, it's a program you run yourself
11:31:58 <monochrom> MarcelineVQ: What is ghcid? If I just google for "ghcid" will I find it?
11:32:18 <MarcelineVQ> https://hackage.haskell.org/package/ghcid
11:32:25 <monochrom> Ah thanks.
11:33:06 <sqooq> hmm I think reinstalling ghc-mod fixed it
11:33:12 <MarcelineVQ> for the moment :>
11:33:21 <sqooq> lmao
11:33:34 <monochrom> Ah this should be fun.
11:34:48 <MarcelineVQ> sqooq: I use atom myself but on linux and don't know how much it differs, I've pretty much resolved ghc-mod issues for projects that use stack with the above method, but it's a real hassle for projects that don't use stack and you get awful red-box spam
11:35:22 <sqooq> I mean it's working now
11:35:27 <sqooq> no red-box spam
11:35:33 <sqooq> but idk if it's actually doing anything
11:35:53 <sqooq> Aren't types supposed to show up when you highlight functions?
11:36:04 <MarcelineVQ> on mouseover
11:36:18 <sqooq> that's not happening lmao
11:36:36 <MarcelineVQ> but it's not lightning fast so mouseover something inside a function body and wait a sec and see
11:37:00 <MarcelineVQ>     "foo = map ..."  mouseover map for example I think, haven't used it in awhile
11:37:25 <monochrom> "Unfortunately GHC 8.0 suffers from bug 10600 which means -fno-code also disables pattern matching warnings" :(
11:37:48 <MarcelineVQ> to clarify, ghc-mod is fast, it's just not fast through stack, which when you need stack to make it behave, it's just a kick in the buttstuff
11:38:27 <sqooq> Nothings working i don't think
11:38:30 <sqooq> I should be getting more errors
11:38:35 <sqooq> Mouseover not working
11:38:38 <sqooq> fml
11:38:40 <sqooq> I'm sick of this
11:38:41 <sqooq> I give up
11:40:40 <sqooq> autocomplete works, which works off ghc-mod
11:40:43 <sqooq> hmm
11:41:03 <sqooq> whatever this is wasting time, I'm just gonna work with barebones text
11:41:11 <MarcelineVQ> good plan
11:41:18 <MarcelineVQ> use ghci alongside and you'll be fine
11:41:25 <MarcelineVQ> and/or ghcid
11:41:33 <MarcelineVQ> actually not or, and!
11:41:52 <sqooq> i'm installing it now
11:42:59 <MarcelineVQ> be sure to run it through stack if you've a stack project,  stack exec ghcid
11:43:24 <sqooq> I did stack install lmao
11:43:39 <sm> ghcid++
11:43:43 <MarcelineVQ> yes you'll need stack build ghcid or stack install ghci before you can exec anyway
11:43:52 <MarcelineVQ> *install ghcid
11:43:53 <geekosaur> then just remove the installed executables from the bin dir shown by 'stack path'
11:43:57 <sqooq> how does this work,
11:44:12 <sm> ghcid -c "stack ghci"
11:44:52 <MarcelineVQ> I've not tried it how sm has written there, but you should in case it's the right way :>
11:45:05 <sm> it's *a* way that I use :)
11:45:46 <MarcelineVQ> sqooq: it typechecks code you write when you save
11:45:49 <[exa]> Q: Is there some good alternative for WebApi ( https://byteally.github.io/webapi/ ) I should be aware off before starting the project in WebApi?
11:45:53 <[exa]> *of
11:46:03 <sqooq> But it just says "All good 2 modules"
11:46:25 <MarcelineVQ> congratulations, the 2 modules it knows about are all good
11:46:28 * sm . o O ( actually a simplification of the rather complicated real command )
11:46:44 <sqooq> yeah it's not loading my file
11:46:49 <cocreature> [exa]: I’ve only taken a quick look at it but `servant` seems related (and is significantly more popular in the Haskell community)
11:46:55 <MarcelineVQ> If you were expecting more than that, you'll need to add them to your .cabal file
11:47:06 <cocreature> I’ve only take a quick look at webapi that is, I’ve actually worked with servant
11:47:10 <MarcelineVQ> at least, that's the most likely issue
11:47:12 <[exa]> cocreature: ok, thanks
11:47:37 <MarcelineVQ> *to your project's *.cabal file
11:47:44 <sqooq> what
11:47:49 <sqooq> i thought I was supposed to use stack
11:47:54 <cocreature> [exa]: it doesn’t have the console stuff whatever that is supposed to be
11:48:00 <sqooq> right now I just have a single file
11:48:02 <sqooq> in a folder
11:48:10 <cocreature> [exa]: but it fits the other points in the description
11:48:12 <sqooq> Parser.hs
11:48:17 <[exa]> :]
11:48:24 <MarcelineVQ> I see, mostly that's not how you use stack
11:48:30 <sm> sqooq: just "ghcid Parser.hs" should handle that
11:48:34 <sqooq> I don't want to use stack
11:48:48 <sqooq> sm: ok I'll try it
11:48:59 <sm> nobody's gonna force you to use stack here
11:49:10 <sqooq> lmao
11:49:14 * sm hopes
11:49:25 <MarcelineVQ> You asked about using stack, so I assumed you intended to use it :>
11:49:37 <MarcelineVQ> *.cabal files aren't specific to a tool, cabal-install and stack both use them to manage a project
11:49:52 <sqooq> " panic! (the 'impossible' happened)"
11:50:21 <sm> lol.. oops look at the time
11:50:23 <MarcelineVQ> you are having a rough time :(
11:50:37 <sqooq> realized I renamed something and missed a spot in my file
11:50:40 <sqooq> now I get "parser.hs:1:1: error:     The IO action `main' is not defined in module `Main'"
11:51:02 <sm> perfect
11:51:38 <sm> now add "module Parser where" at the top, or add a main function
11:52:13 <sqooq> sweet it works
11:53:03 <sm> that's ghcid's big feature
11:53:14 <sm> it's great.. leave that running in a side window all the time
11:53:28 <sm> you can tell it to run tests too
11:53:31 <sqooq> Now I just have to figure out
11:53:35 <sqooq> how to actually fix my file lmao
11:53:53 <sqooq> which was the purpose of all this in the first place, to make that easier
11:54:13 <sm> yup. With this fast feedback, you can iterate small edits quickly
11:55:10 <sqooq> is monochrom here
11:55:17 <monochrom> Why me.
11:55:27 <sm> why yes, yes he is!
11:55:27 <sqooq> you were helping me yesterday
11:55:45 <cocreature> if nothing else helps, get yourself a monochrom and all problems will go away
11:55:59 <sqooq> I can't figure out how to make this Monad instance thing work for my parser
11:56:12 <monochrom> Oh, that.
11:56:18 <sqooq> I literally just started throwing Parser wrappings all over
11:56:21 <sqooq> trying to fix things
11:56:22 <monochrom> Show current code.
11:57:06 <sqooq> http://lpaste.net/357309
11:57:39 <sqooq> I'm focused on 'bind' right now
11:57:54 <monochrom> Parser p `bind` f = ...
11:58:09 <sqooq> Parser (p `bind` f) ?
11:58:10 <monochrom> which means, use pattern matching to unwrap
11:58:20 <monochrom> No. I have no typo there.
11:58:33 <sqooq> well I know it's left associative
11:58:36 <sqooq> but I never understand
11:58:54 <monochrom> OK, it is equvalent to: bind (Parser p) f = ...
11:59:02 <sqooq> hmm
11:59:06 <sqooq> ok
11:59:41 <monochrom> The RHS has mistakes too.
12:00:34 <cocreature> sqooq: can you be a bit more specific? what code do you currently have and what is causing problems?
12:01:02 <monochrom> bind (Parser p) f = Parser (\inp -> concat [deParser (f v) inp' | (v,inp') <- p inp])
12:01:17 <cocreature> oh sry I wasn’t scrolled down
12:01:36 <sqooq> why deParser there ?
12:01:47 <monochrom> cocreature: Yesterday sqooq started with type alias. Everything was fine, except couldn't make a Monad instance because type alias.
12:02:26 <monochrom> So currently the only thing that makes or breaks is how to do newtype wrapping and still stay sane.
12:02:50 <monochrom> Use manual type inference to see why deParser there.
12:03:28 <monochrom> Do not use "intuition" such as "Parser a is 'equivalent' to String->[(a,String)]".
12:03:29 <sqooq> as in remove my type signature?
12:03:35 <monochrom> No.
12:04:16 <monochrom> manual type inference means you work out types by your own brain on a piece of paper.
12:04:22 <sqooq> o
12:04:34 <sqooq> well maybe i don't understand what deParser is then
12:04:35 <monochrom> Do not use intuition.
12:04:46 <sqooq> I thought Parser deParser was equivalent to something like Just Int
12:04:51 <monochrom> Ask ghci "@type deParser" for help.
12:05:07 <sqooq> or Maybe Int rather
12:05:46 <monochrom> You need help learning newtype and possibly ADT altogether.
12:06:18 <monochrom> Use types. Don't use intuition.
12:06:19 <sqooq> probably
12:07:32 <MarcelineVQ> sqooq: what monochrom said in ghci is   :t deParser   or     :type deParser
12:07:55 <monochrom> Oh, I mixed up lambabot and ghci again.
12:07:57 <MarcelineVQ> @type map -- it's lambdabot that accepts @type :>
12:07:58 <lambdabot> (a -> b) -> [a] -> [b]
12:08:58 * hackagebot data-diverse 0.9.0.0 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
12:10:11 <monochrom> The questions you need to answer are:
12:10:20 <monochrom> 1. f v has what type?
12:10:30 <monochrom> 2. deParser (f v) has what type?
12:11:12 <monochrom> 3. So why is f v inp' illegal and why is deParser (f v) inp' legal
12:13:23 <monochrom> Actually these days, if you have legal code, the ghci can tell you the types of subexpressions too.
12:13:44 <sqooq> thanks
12:13:53 <sqooq> i don't know the answer to any of those questions
12:14:03 <sqooq> I'm not sure I even know what deParser actually is
12:14:07 <monochrom> Look for ":set +c" in the GHC user's guide.
12:14:28 <monochrom> Why does it matter what it "is"? What does "is" mean anyway?
12:14:34 <sqooq> Meaning
12:14:35 <monochrom> At present you only need types.
12:14:41 <monochrom> What does "meaning" mean?
12:14:45 <monochrom> At present you only need types.
12:14:46 <sqooq> Yeah I don't know what's a type anymore
12:14:48 <sqooq> what's a constructor
12:14:56 <sqooq> newtype Parser a = Parser { deParser :: String -> [(a,String)] }
12:14:59 <sqooq> what is anything there
12:15:08 <sqooq> the Parser on the left is a type yes?
12:15:15 <monochrom> OK, how hard is it to enter ":type deParser" into ghci?
12:15:21 <sqooq> It gives errors
12:15:38 <sqooq> interactive>:1:1: error: Variable not in scope: deParser
12:15:57 <sqooq> Because my file won't even load
12:16:05 <sqooq> unless, ok give me a se c
12:16:15 <monochrom> OK, comment out error-causing code and load again?
12:16:36 <sqooq> deParser :: Parser a -> String -> [(a, String)]
12:16:46 <sqooq> O I forgot record syntax
12:16:52 <sqooq> automatically makes functions
12:17:14 <monochrom> Also, I gave you legal code for bind, you could have used it and have no error loading.
12:17:33 <benzrf> monochrom: learning experience to write your own :3
12:18:04 <monochrom> benzrf, the "write your own" stage has had 24 hours already.
12:18:08 <sqooq> monochrom: well some of the other functions are broken
12:19:03 <sqooq> monochrom :(
12:19:06 <sqooq> I still don't understand
12:19:20 <sqooq> f is supposed to have type (a -> Parser b)
12:19:26 <monochrom> Yes.
12:20:09 <sqooq> then I'm taking that result and turning it into String -> [(a, String)]
12:20:19 <sqooq> then it takes v as String and does it's thing?
12:20:26 <sqooq> or sorry inp' rather
12:20:30 <monochrom> You are using intuition again.
12:20:57 <monochrom> What is the type of f? What is the type of v? Therefore what is the type of f v?
12:21:19 <monochrom> This is basic logic, not advanced rocket science conceptual deep insight.
12:21:27 <sqooq> v :: a no?
12:21:31 <monochrom> Yes.
12:21:53 <sqooq> f :: (a -> Parser b)
12:23:28 <sqooq> f v :: Parser b
12:23:51 <monochrom> Yes.
12:24:04 <sqooq> deParser (f v) :: String -> [(a, String)]
12:24:08 <monochrom> Yes.
12:24:14 <sqooq> what that's what I said earlier
12:24:31 <sqooq> ok but then how does inp' come into this
12:25:06 <sqooq> call g = deParser (f v)
12:25:11 <sqooq> g :: String -> [(a, String)]
12:25:23 <monochrom> What is the type of inp' ?
12:25:24 <sqooq> g inp' :: [(a,String)]
12:25:31 <monochrom> Yes.
12:25:31 <sqooq> inp' :: String
12:25:54 <sqooq> my intuition was right, you probably just didn't understand me, or I said something wrong
12:26:19 <sqooq> I wasn't trying to use intuition per se, I just like to see what is input to what in a chain
12:26:54 <sqooq> ok
12:26:59 <sqooq> That was enlightening
12:27:14 <sqooq> Btw, is there a way to do the newtype definition without deParser?
12:27:18 <monochrom> I have a very simple criterion.
12:27:34 <monochrom> If your code fails, then it doesn't matter what you think and what you say.
12:27:51 <monochrom> Of course people hate me because they're so obsessed with "partial credit".
12:27:59 <sqooq> lmao
12:28:19 <monochrom> But I need only look at the history of science and the history of unscientific people.
12:28:38 <sqooq> Tbf, I wasn't trying to get partial credit
12:28:41 <sqooq> just full credit
12:28:55 <sqooq> my code failed but in that moment, I did in fact understand what deParser was doing
12:29:02 <monochrom> It usually turns out that there is no partial credit to give. The unscientific people are way off, not just off by an annoying technicality.
12:29:16 <sqooq> true
12:30:01 <sqooq> btw I could do newtype ' Parser a = Parser ( String -> [(a,String)] ) ' right?
12:30:12 <sqooq> oops put that quote in the wrong place
12:30:14 <monochrom> Yes.
12:30:42 <sqooq> Is that not cleaner since it's only one value anyway
12:30:48 <sqooq> or does that cause issues later on
12:31:19 <monochrom> So what do you use in place of deParser?
12:31:42 <sqooq> Pattern matching?
12:31:51 <monochrom> OK, you can do that.
12:32:01 <monochrom> Rewrite bind to not use deParser.
12:33:01 * hackagebot language-puppet 1.3.9 – Tools to parse and evaluate the Puppet DSL. – https://hackage.haskell.org/package/language-puppet
12:33:50 <hpc> oooh
12:35:35 <sqooq> I would still have to make a function that depacks the Parser ?
12:35:53 <sqooq> which is basically the same thing as the record syntax
12:35:59 <sqooq> otherwise, idk how to actually do it lmao
12:36:02 <monochrom> Or write the pattern matching inline.
12:36:58 <vimalloc> So due to the whole lazy nature of haskell, I could do something like generate a list (which might be expensive) and call find on it, and will only generate the list up until if 'finds' first element it is looking for?
12:37:21 <monochrom> Yes.
12:37:44 <vimalloc> That is super neat!
12:45:51 <rostero> how can I use :type in ghci to show the type of something in the context of a type.  for example, I want to see :t (<*>) in the context of (->)
12:46:13 <rostero> or in the context of Maybe
12:47:14 * hackagebot leapseconds-announced 2017.1.0.1 – Leap seconds announced at library release time. – https://hackage.haskell.org/package/leapseconds-announced
12:47:39 <jd823592> is there a way to insert an entry into a zipper (from zippers package by ekmett) at some position from within (avoiding explicit rezipping)?
12:47:50 <monochrom> I think you can figure out something based on type wildcards?
12:47:55 <Cale> rostero: I just mentally substitute the type variable for whatever it is that I want.
12:48:05 <rostero> yeah, simple enough.  was just wondering
12:48:34 <geekosaur> :t asTypeOf
12:48:35 <lambdabot> a -> a -> a
12:49:08 <geekosaur> hm, that;s the wrong oen
12:49:20 <sqooq> monochrom: I give up
12:49:52 <monochrom> You write your own deParser function. Or you write "case f v of Parser g -> g inp' "
12:50:59 <monochrom> Turn on TypeApplications and ask ":type (<*>) @ ((->) Int)"
12:52:05 <monochrom> But if you have existing legal code, you can ask local types by turning on :set +c and then load your code. See the GHC user's guide for :set +c
12:52:45 <monochrom> Does lambdabot have TypeApplications?
12:52:48 <dharmanard> hello
12:52:48 <MarcelineVQ> nop
12:52:50 <geekosaur> not yet
12:52:56 <monochrom> Ah
12:53:23 <sqooq> ah i had a feeling it would be embedded inside
12:53:31 <sqooq> but I was trying to do something with a where expression
12:54:02 <MarcelineVQ> I believe TypeApplications has syntax clashes that whoever manages lamdabot doesn't want to have to tiptoe around, hopefully that's correct, I don't want to be making stuff up
12:54:12 <MarcelineVQ> with patterns due to @
12:54:14 <dharmanard> discovered here while reading Learn You A Haskell - just being a fly on the wall
12:55:13 <monochrom> Oh I forgot I could use golbolt yesterday!
12:55:41 <EvanR> which legal code does haskell use?
12:56:26 <jared-w> legal code?
12:56:33 <sqooq> ugh this is painful
12:56:41 <jared-w> sqooq: what's painful?
12:56:56 <sqooq> learning
12:58:00 <monochrom> Haskell 2010's legal notice is "The authors and publisher intend this Report to belong to the entire Haskell community, and grant permission to copy and distribute it for any purpose, provided that it is reproduced in its entirety, including this Notice. Modified versions of this Report may also be copied and distributed for any purpose, provided that the modified version is clearly presented as such, and that it does not claim to be a definition of 
12:58:00 <monochrom> the language Haskell 2010."
12:58:14 <Tuplanolla> That suggests that you should change your approach, sqooq.
12:58:42 <sqooq> nah painful learning is good
12:58:46 <sqooq> you learn better that way
12:59:09 <sqooq> monochrom: That case of goes smack in the list comprehension like "[ case f v of Parser g -> g inp' | (v,inp') <- p inp]" right?
12:59:28 <monochrom> Yes.
12:59:33 <sqooq> and f :: a -> Parser b
12:59:48 <sqooq> so f is called on v (which comes from the such that part of the comprehension)
12:59:52 <sqooq> resulting in Parser b
12:59:57 <sqooq> which we pattern match as Parser g
13:00:05 <sqooq> and just return g inp'
13:00:22 <sqooq> which g :: String -> [a,string
13:00:36 <sqooq> sorry for typing this all out, maybe I should just do it in a notepad
13:01:02 <sqooq> wow
13:01:10 <sqooq> I think I've got it
13:01:25 <sqooq> I think I just levelled up. I'm a level 1.2 Curry now
13:01:34 * jared-w personally always dislikes list comprehensions
13:01:47 <sqooq> i dislike them too but the paper I followed used it
13:01:56 <jared-w> Which paper? Just curious
13:02:09 <sqooq> http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
13:02:13 <monochrom> Yes.
13:03:00 <sqooq> Yes.
13:03:15 <sqooq> It's all about types with haskell
13:04:32 <vimalloc> Is there a way to see what function an eception was raised in (in this case, a fromJust on a nothing)?
13:05:05 <sqooq> monochrom: Thanks for being patient with me
13:05:14 <vimalloc> Or I guess a stacktrace, I think I know which function, but not sure what function called this function.
13:05:16 <Cale> vimalloc: There are some things you can try if you're desperate, but I usually just grep -r fromJust
13:05:23 <monochrom> You're welcome.
13:05:52 <Cale> and then replace any occurrences I find with case expressions if it's not immediately obvious to me that they could never fail
13:06:24 <vimalloc> Not desperate yet, just refactored a bunch of stuff and broke something. I'll go down that route, thanks
13:06:28 <jared-w> Yeah, static code analysis is usally the way to go in Haskell, which is a shame (it's also somewhat of a blessing that Haskell is so useful despite having such useless runtime introspection tooling, I guess...)
13:07:02 <Cale> vimalloc: It's a bit tricky because there's not actually a call stack
13:07:14 <vimalloc> Yeah, that makes sense. 
13:07:35 <vimalloc> And you can't just throw print statements in there :P
13:07:49 <Cale> You can use Debug.Trace though
13:08:20 <Cale> If you turn on profiling, and run with +RTS -xc
13:08:29 <Cale> it'll sometimes tell you something useful
13:09:19 <Tuplanolla> We can't have call stacks, but could we have breadcrumbs?
13:10:16 <Cale> I actually really would like to be able to visualise the stack in these cases -- especially the entries corresponding to pattern matches
13:10:53 <Cale> having a bunch of source locations of case expressions would be about as good as a call stack
13:11:57 <rostero> monochrom: thanks for the TypeApplications tip
13:11:58 <geekosaur> in theory you can just drop a HasCallStack constraint on the thing you are trying to track...
13:12:46 <geekosaur> (in practice if the things aboveit have explicit type signatures then you end up having to add it to them too. wonder if partial type signatures would help there...
13:14:19 <Tuplanolla> That was not a joke. Is there a technical reason for it?
13:15:52 <jared-w> If you have breadcrumbs, you have information about execution order and you basically have a call stack with less information, if I'm understanding what you're saying correctly. At that point, there's not much difference between that and a full call stack because the underlying limitation in place now affects both
13:16:52 * hackagebot threepenny-editors 0.5.0 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
13:18:49 <Tuplanolla> Now that I think about it, making sense of it would probably be prohibitively difficult.
13:18:57 <geekosaur> that is more or less what HasCallStack is
13:19:10 <geekosaur> except, you have to add that everywhere along the call chain
13:19:50 <geekosaur> (well, it can be inferred if the type signature is inferred, but an explicit type signature would override and then you get compile errors)
13:34:37 <monochrom> I don't take "call stack" literally.
13:38:05 * hackagebot threepenny-editors 0.5.1 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
13:42:11 <ickabob> hi haskell, syntax question.  I've seen 'x,y,z :: Foo'  is there an equivilent comma seperated syntax for 'x = y = z = 1 :: Int'?
13:44:05 <Tuplanolla> Is not, ickabob, but `x, y, z = 1` would make sense.
13:44:59 <geekosaur> [x, y, z] = repeat 1
13:45:01 <tsani> ickabob: (x, y, z) = let a = 1 in (a, a, a)
13:45:18 <geekosaur> well no
13:45:24 <geekosaur> (x:y:z:_) = repeat 1
13:46:33 <tsani> ickabob: I don't see why you'd ever want to do this though in Haskell
13:46:48 <nachoba> Hi, I'm trying to build gtk-0.14 as needed by the Yi editor. However I don't quite get the error messages I'm getting. Both gtk+ and gtk+3 are installed. I'm on macOS. And here is the full ouput of the attempt http://lpaste.net/357312
13:46:51 <ickabob> both of those are clever.  I think I really am chasing after an editor macro to stubb functions here.
13:47:13 <ickabob> thanks for the answers though, it defintiely showd me its not what I was really after
13:47:40 <tsani> ickabob: do you know of the typed holes feature? You can leave _ in the place of any expression as a stub
13:48:09 <tsani> the compiler will error out on the hole and tell what type of value needs to go there, which can be very useful for interactively building a function
13:48:25 <geekosaur> nachoba, gtk+3's api is explicitly unstable, and it looks like whatever version you have installed is not compatible with what the haskell binding expects
13:51:55 <ickabob> tsani: yes i do and what a useful feature.  I'm building out some application events and corresponding parsers for a control interface to a websocket server.  No matter what I'll need some named identifiers so I was trying to make a parser per event each with an undefined value... :) Shows me I need to both work on my haskell and editor fu.
13:53:57 <ickabob> tsani: Actually between typed holes and ghcid I think those two things are my most valued haskell dev tools 
13:54:25 <tsani> I've heard a lot of good things about ghcid. Never had the opportunity to give it a try yet.
13:55:18 <jared-w> Same. Ghcid sounds fun though
13:55:41 <ickabob> its just quick
13:56:07 <ickabob> quicker than my previous ':reload' or 'stack ghci --options.."
14:00:13 <nachoba> geekosaur, thanks. Any suggestion?
14:01:45 <geekosaur> nachoba, not really. looking at exactly what failed, it's going to be a pain to track down what changed if you aren't already intimately familiar with both gtk+ itself and the gtk2hs suite
14:01:55 <geekosaur> and it's possible the fix needs to be in gtk2hsc2hs
14:02:19 <nachoba> ok thanks!
14:04:29 <geekosaur> hah
14:04:51 <geekosaur> if you're willing to build gtk2hs from git instead of hackage, your problem is https://github.com/gtk2hs/gtk2hs/issues/206
14:05:13 <geekosaur> oh, I see
14:05:44 <geekosaur> and your actual problem is your gtk is built for quartz (native macos) instead of x11. so you need: cabal install gtk -fhave-quartz-gtk
14:06:31 * geekosaur thoght it was a patch at first...
14:09:07 <geekosaur> (or the stack equivalent if that is what you are using)
14:13:02 <geekosaur> you may also end up being a beta tester because gtk on not-x11 often has weird bugs, like xchat/hexchat won't scroll. I could see that potentially affecting yi as well
14:56:26 <andreoss> which Data.Global implementation should I use? safe-global or global variables?
15:38:06 * hackagebot vector-space 0.11 – Vector & affine spaces, linear maps, and derivatives – https://hackage.haskell.org/package/vector-space
16:16:36 <slack1256> that is some big netsplit
16:17:12 <geekosaur> that's a small netpolit by this channel's standards :)
16:17:34 <Clint> especially with matrix being involved
16:17:36 <geekosaur> oh no, I missed the scrollback
16:17:51 <geekosaur> but yeh, itkinda doesn't count since that's basically matrix.org getting split off
16:18:32 <slack1256> anyways, a question. Where are documented the cases when { } blocks are allowed in haskell?
16:19:13 <slack1256> I know of two cases: do { stmt1 ; stmt2 } and case expr of { branch1 -> etc ; branch2 -> etc2 }
16:19:38 <c_wraith> slack1256: let {decls} in ...
16:19:57 <slack1256> Mmmm right! nice!
16:20:12 <c_wraith> slack1256: case { pattern -> expr ; ... }
16:20:23 <c_wraith> err. case ... of the rest
16:20:47 <slack1256> \case { pattern -> expr ; } wiith LambdaCase
16:20:49 <geekosaur> and where
16:21:05 <c_wraith> I'm pretty sure you can use braces for multiple guards on a binding
16:21:52 <slack1256> rule of a thumb then: anywhere a newline has significance, a version with blocks and semiconlons should exists
16:22:13 <c_wraith> actually, whitespace desugaring is written in terms of conversion to {;}
16:22:32 <slack1256> !! Cool
16:22:51 <geekosaur> and guards don't use newline
16:23:04 <geekosaur> foo | bar = fbar | baz = fbaz
16:23:13 <c_wraith> ah, yes.  the | is syntactically unique
16:23:15 <geekosaur> perfectly valid presuming those names are in scope
16:23:30 <slack1256> Mmmmm
16:24:15 <slack1256> then , foo | { bar = fbar ; | baz = fbaz } is not valid?
16:24:27 * slack1256 checking out
16:25:04 <geekosaur> don't think so
16:25:55 <slack1256> I confirm it, is not valid
16:28:25 <geekosaur> there's no reason for it, the | itself is enough syntactic guidance
16:29:41 <andreoss> is there a way to compose two 'a -> IO ()' so 'a' will be passed only once to it?
16:30:02 <andreoss> return (1,2) >>= product >> return (1,2) >>= sum
16:31:33 <jmcarthur> What is the type of the function you want? Something like this?   (a -> IO ()) -> (a -> IO ()) -> a -> IO ()
16:31:50 <andreoss> a -> IO (), the same type
16:32:03 <jmcarthur> I don't understand.
16:32:20 <jmcarthur> What the type I guessed wrong?
16:32:23 <jmcarthur> *was
16:32:26 <andreoss> i.e I want to run several action with the same parameter
16:33:00 <andreoss> jmcarthur: i guess it's correct
16:33:12 <jmcarthur> :t liftA2 mappend :: (a -> IO ()) -> (a -> IO ()) -> a -> IO ()
16:33:13 <lambdabot> (a -> IO ()) -> (a -> IO ()) -> a -> IO ()
16:33:37 <jmcarthur> Alternatively, there's the reader monad.
16:33:42 <jmcarthur> Well, ReaderT, at least.
16:35:05 <glguy> While it's not what you wanted, this would have typechecked :) (>>) :: (a -> IO ()) -> (a -> IO ()) -> a -> IO ()
16:35:29 <jmcarthur> :t map . flip id :: a -> [a -> IO ()] -> IO ()   -- if you have a list
16:35:31 <lambdabot> error:
16:35:31 <lambdabot>     • Couldn't match type ‘[IO ()]’ with ‘IO ()’
16:35:31 <lambdabot>       Expected type: a1 -> [a1 -> IO ()] -> IO ()
16:35:37 <andreoss> can ReaderT wrap a function? i.e a -> b -> c -> IO d would became something ReaderT a (b -> c -> IO d)?
16:35:51 <jmcarthur> :t mapM_ . flip id :: a -> [a -> IO ()] -> IO ()   -- my bad
16:35:53 <lambdabot> a -> [a -> IO ()] -> IO ()
16:36:50 <jle`> andreoss: yes
16:36:59 <jle`> but
16:37:04 <jle`> what you gave doesn't kind-check
16:37:53 <andreoss> would be the signature than?
16:38:02 <andreoss> what*
16:39:27 <jmcarthur> andreoss: I was thinking that instead of (a -> IO ()), you might want (ReaderT a IO ())
16:39:52 <jmcarthur> andreoss: Then the function you are looking for really would just be (>>) on ReaderT a IO.
16:40:21 <jmcarthur> :t \a b -> runReaderT (a >> b)
16:40:22 <lambdabot> Monad m => ReaderT r m a1 -> ReaderT r m a -> r -> m a
16:40:33 <jmcarthur> :t \a b -> runReaderT (ReaderT a >> ReaderT b)
16:40:34 <lambdabot> Monad m => (r -> m a1) -> (r -> m a) -> r -> m a
16:41:32 <jmcarthur> For a small expression this would be overengineering, but for a concept that pervades a program it might not be.
16:43:51 <jle`> andreoss: i'm not even sure what you intended it to be
16:44:15 <jle`> it could have been Reader a (b -> c -> IO d) ?
16:45:40 <danilo2> Hi! Does anybody know what is the state of the art when comes to Arrays in Haskell (I want pure Array, not a Vector). We've got 2 options Data.Array and Data.Primitive.Array. Which one to choose?
16:48:24 <geekosaur> I don't think that's about state of the art
16:49:02 <lyxia> It's odd to consider Data.Primitive.Array but not Vector.
16:50:59 <andreoss> a -> IO b transforms into 'ReaderT a IO b'. What 'a -> b -> IO c' would become?
16:51:01 <geekosaur> Data.Primitive.Array is just direct access to the underlying GHC primitives, as opposed to the higher level interface in Data.Array. it will be faster but essentially all operations are unsafe
16:51:28 <kadoban> danilo2: I've quite enjoyed Data.Array
16:51:37 <slack1256> andreoss: a -> ReaderT b IO c
16:51:57 <slack1256> checkout STArray also
16:52:20 <Axman6> danilo2: what do you mean by "pure Array not Vector"?
16:52:21 <andreoss> slack1256: i want to get 'a' by asks 
16:52:54 <slack1256> andreoss: a -> b -> IO c is equivalent to ReaderT (a,b) IO c
16:53:19 <slack1256> @type uncurry
16:53:20 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:53:26 <danilo2> kadoban: thanks :) If you've been using it, I would love to ask one more question. I've got custom datatypes and want to store them unboxed. I can create instances for it, but what does GHC when I access such structure in array? will it box it always (hopefuly not when using strict vars)? How fast would be accessing a field in such structure? Can we make it "really" fast?
16:54:11 <kadoban> Never tried to make my own unboxed types.
16:54:36 <danilo2> Axman6: I mean Array like container, not a Vector. I do not want vectors because 1) I want to measure performance between Array and Vectors 2) there are many open issues regarding Vectors and I've got a **very** specific code here and want the highest performance
16:54:44 <kadoban> I think that would mostly be about storing them more compactly in the actual array and wouldn't otherwise have any meaning.
16:55:25 <crucify_me>  hi on the last line, the output for :t adds a type in the tuple: Num t. what exactly happens there...why does it add the Num t type ?   https://ptpb.pw/i917
16:55:25 <manek> kadoban: thanks!
16:55:26 <lyxia> danilo2: what's the difference to you between Vector and Array
16:55:40 <Axman6> IIRC Data.Array is almost universally slower than Vector, because it doesn't have stream fusion and needs to work with any index type
16:55:43 <andreoss> slack1256: it doesn't seem to be usefull for my case
16:56:07 <andreoss> Data.Global appears to be what I want
16:56:17 <manek> However, I do not think that this is "the end" when it comes to unboxing. I would like to not only store my structures unboxed, but also be able to fastly access their elements. Is it somehow possible in unboxed arrays / vectors?
16:56:27 <andreoss> but I can't manage to compile it with stack
16:57:22 <crucify_me> because what that looks like to me is that the function goes from having 2 parameters, to having 3, but I guess thats not what happens
16:57:42 <manek> lyxia: as I have written above - I want to measure performance between them to decide which one to use. However I know that vectors have many issues opened (like iterating over vector elements is 30% slower than iterating over Data.Text elements). Arrays are closer to metal if I understand correclty
16:57:49 <andreoss> I try to move all "global" stuff somewhere in order to reduce function signatures
16:58:12 <geekosaur> crucify_me, you are still not understanding contexts
16:58:16 <Axman6> crucify_me: because you have used numeric literals, GHC has inferred their type to be Num t => t, ie, anything which implements the Num typeclass
16:58:28 <manek> lyxia: I work with danilo
16:58:35 <geekosaur> crucify_me, everything before a => in a type signature is not a parameter
16:59:10 <geekosaur> at least, not in the normal sense
16:59:21 <crucify_me> right, because the signature is describing more than one feature of the argument, correct?
17:00:19 <geekosaur> right. you used a number, numeric literals are polymorphic, so you got a Num context for them
17:00:21 <adelbertc> if there's a data type D in package foo and a type class TC in package bar and package foo doesn't want to incur a dependency on package bar and vice versa, but you yourself want an instance for TC D is the strategy then to just declare an orphan instance and #yolo?
17:00:21 <geekosaur> :t 5
17:00:23 <lambdabot> Num t => t
17:00:28 <slack1256> andreoss: I just declare read-only value on common data type Configuration. The pass around that as argument until I reach some event loop or something
17:01:07 <crucify_me> the interpreter needs to add the Num t because the argument I used is one step more specific. 
17:01:29 <geekosaur> actually it's because it's not specific
17:02:09 <geekosaur> a numeric literal 1 can be, among other things: Int, Integer, Word32, Float, Complex Double
17:02:25 <geekosaur> if you don't specify, this will be represented as a Num constraint on its type
17:03:37 <crucify_me> excellent I see yes that is also a constraint. thank you kindly geekosaur -- Axman6 also very helpful thanks
17:03:40 <geekosaur> then, because you didn't specify a type known to have an Eq instance, it inferred one because jackel uses (==)
17:04:08 <geekosaur> (note that this is actually not standard Haskell; standard Haskell requires any Num instance to also have an Eq instance.)
17:04:22 <crucify_me> right it inferred it at the least specific level of a numeral, which is Num t
17:05:56 <crucify_me> it doesn't add the type of array, the type of the container. but I guess in this case the container would need to be [] , is that correct?
17:06:18 <geekosaur> if you enabled the OverloadedLists extension, you would see an IsList constraint
17:06:43 <crucify_me> I see I haven't looked at that yet. thanks
17:07:50 <geekosaur> at present the only things that behave like that are numbers (always), strings with OverloadedStrings extension, lists with OverloadedLists extension
17:09:08 <geekosaur> and potential ambiguity if you turn on both of those extensions and use a literal String, because it could be interpreted as either IsList on [Char] or IsString
17:09:46 <jared-w> oooh we have OverloadedLists? What do people even use that for?
17:09:48 <monochrom> Wait, is that really true?
17:10:09 <crucify_me> beats me
17:10:20 <Axman6> [(1,"hello"0,(2,"world")] :: Map Int String
17:10:27 <Axman6> in, s/0/)
17:10:30 <crucify_me> <<>>>  beats me
17:10:59 <monochrom> Because as far as syntax of literals is concerned, "a" and ['a'] are distinguishable.
17:11:28 <monochrom> "a" would request OverloadedString (and only that), ['a'] would request OverloadedList (and only that). No ambiguity.
17:11:46 <monochrom> which is also what empirical observation says.
17:11:49 <Axman6> RIP Matrix -_-
17:12:08 <geekosaur> glitch in the matrix...
17:12:12 <crucify_me> what was htat?
17:12:27 <monochrom> No, it is not RIP Matrix, it's WB Matrix :)
17:12:35 <Axman6> urgh, so it is
17:12:57 <monochrom> Oh hi glguy[m] what are you doing on both sides of the fence :)
17:13:24 <Axman6> aka Guest49997
17:14:17 <slack1256> wasn't matrix a separated network much like slack?
17:14:37 <Axman6> apparently it supports IRC too
17:14:52 <jared-w> ahh neat, OverloadedLists allows for programmers to use list notation for construction of structures like Set, Map, IntMap, Vector, Text, and Array
17:15:08 <monochrom> Oh interesting IsList is has an associated type synonym for the item type so ['a', 'b'] could be made Text too
17:15:19 <jared-w> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
17:17:48 <danilo2> I'm sorry if this is very simple question, but I cannot find answer for it nowhere. If we use unboxed structures in Array or Vector, can we access their fields fast? I understand that defining how my custom structure should be unboxed is definition of the memory layout for it, so what happens if I access such struct and read its field?
17:20:09 <geekosaur> can that even be answered generically?
17:20:31 <jmcarthur> danilo2: Storable Vectors just use Storable, so that's easy provided you are happy to use Ptrs. Unboxed Vectors are typically represented in struct of arrays style rather than array of structs style, and when you define the type family for your type you could choose to leave that non-abstract so you can access the arrays for each field.
17:20:58 <jmcarthur> danilo2: I don't know what to say about unboxed Array, though.
17:24:59 <danilo2> jmcarthur: thank you! I understand that Storable requires us to use Ptrs so in fact if I need to be as closed to metal as possible here, I should prefer unboxed over storable?
17:25:54 <jmcarthur> Storable vectors don't require you to use pointers unless you want to (which it sounds like you do).
17:26:14 <danilo2> jmcarthur: moreover, If my structure would be stored as a "struct of arrays", reading the original struct from vector and accessing it field would require ghc to read all its fields or will it be optimized and only one memory jump will happen ?
17:26:28 <jmcarthur> danilo2: Your preference for unboxed or storable should depend on what memory layout you want and whether you need to share the vector with C.
17:27:23 <jmcarthur> danilo2: I don't actually know what GHC does and doesn't read when you read the entire data structure from an unboxed array.
17:27:23 <danilo2> jmcarthur: I care now only about performance of writes, index based reads etc, I do not care about C operopability
17:28:00 <Axman6> then unboxed STVectors seem like a good choice
17:28:41 <danilo2> jmcarthur: thank you so much for your help! :) Axman6 : thanks! :)
17:30:28 <danilo2> By the way, just to confirm this, I understand that Unboxed vectors are a little faster than storable, right ?
17:32:58 <Axman6> that's not necessarilly a universal statement, no
17:33:07 <Axman6> they have different uses
17:34:02 <Axman6> "faster" depends on what you actually want to do - if you have a ByteString of int64_t's, then getting a sotrable vector will be a lot easuer than an unvoxed one, because it requires no conversion of the data
17:34:19 <glguy> monochrom: That glguy[m] is a bug in the matrix/irc bridge
17:36:34 <danilo2> Axman6: let's consider that I will be using Vectors to store mainly Word64 values. I want to store them, access / update by index etc. 
17:37:39 <mnoonan_> I’m writing a Tutorial module for this library, and kind of the whole point is to mix documentation with the source of the defined functions. this seems like an ideal use case for literate Haskell, but does that play nicely with things like the hackage haddocks?
17:37:45 <danilo2> Axman6: will unboxed vectors require any conversions under the hood ?
17:39:50 <Axman6> no
17:40:41 <danilo2> Axman6: so in this use case will there be any performance difference between using Storable and Unboxed?
17:40:51 <nshepperd> danilo2: "struct of arrays" means that if you have a data type with multiple fields, it will do one memory access for each field that you actually evaluate
17:41:34 <nshepperd> eg. getField1 (array ! some_index) should only do one index into the first array
17:41:38 <Axman6> danilo2: if you really care this much, benchmark, swapping between unboxed vectors and storable vectors is trivial (it's literally changing an import)
17:41:59 <nshepperd> (as long as your data types fields aren't marked strict...)
17:42:20 <danilo2> Axman6: I will, thank you! I was jsut thinking that maybe I do not see some obvious difference and the answer would be also obvious! :)
17:44:19 <danilo2> nshepperd: I was just before asking this! :) Anyway, hmm, I'm thinking about a struct with many fields (let say 20). If I store it as 20 arrays, reading the struct and writing it to other index coudl take 20times more time than if we store "the struct" in array (memcpy would be faster then). Am I right ?
17:45:38 <crucify_me> thing about that jackel function, is that looking at the last type check, all 3 of those contexts are shown in the tuple... is that because its not clear to the interpreter whether to apply Eq a or Ord b to that argument, [1,2,3,4]   ? because in the second type check listed , True is given, so its clear that its type is Ord b => b -> Bool. I hope that question is clear.
17:45:46 <crucify_me> https://ptpb.pw/i917
17:46:03 <nshepperd> danilo2: you mean if you read the whole structure from index 1 and copy it to index 2? readArray arr i >>= writeArray arr j
17:46:17 <danilo2> nshepperd: yes
17:46:57 <nshepperd> then that could possibly be slower than the Storable (array of structs) way
17:47:31 <nshepperd> since it would access 20 different memory locations for the read and the write
17:47:42 <slack1256> Is my idea or just adding the carets to type errors made ghc 8x more helpful?
17:48:32 <nshepperd> benchmarking is the only way i guess
17:48:39 <geekosaur> crucify_me, it's there because at some point jackel uses (==) on something of type t
17:48:58 <geekosaur> it does not matter whether it would do so in a given call; it is solely determined by the types
17:49:38 <danilo2> nshepperd: I'm talking exactly about this. I think this is the answer to my questions originally. I was thinking if we are able to store "unboxed" structures efficiently in Haskell Vectors/Arrays. I feel that Storable Vectors could be the answer here
17:50:11 <danilo2> nshepperd: thank you very much1
17:51:10 <geekosaur> crucify_me, in the Bool case, it does not need the constraint because it knows the precise type (Bool) and can determine existence of an Eq instance at compile time. when the precise type is not known (Num t) then it has to also require proof of existence of an Eq instance for t
17:52:03 <crucify_me> excellent thanks I thought that intuitively but didn't have words for precisely what my hunch was. thanks 
17:52:10 <geekosaur> (in ghc, this proof takes the form of a record, transparently passed by the compiler, containing the actual Eq instance methods to use)
17:52:51 <crucify_me> ok, yeah, so perhaps my confusion is reasonable. but I do get that essentially
17:53:10 <crucify_me> its not a cake walk
17:53:23 <geekosaur> that detail is why I said "at least, not in the normal sense" earlier
17:53:36 <geekosaur> (about parameters vs. contexts)
17:54:11 <geekosaur> ghc does that under the hood, most of the time you don't care but there's at least one module that lets you create and inspect such records
17:54:46 <crucify_me> yes, :t jackel [1,2,3,4] has some inherent ambiguities, so the interpreter covers all its bases by spitting out a complex type signature.
17:54:47 <geekosaur> I dont recommend playing with iti unless you want to get cozy with ghc internal implementation details
17:55:11 <crucify_me> ^^ is my last comment valid geekosaur  ?
17:56:43 <geekosaur> more or less, yes. since a numeric literal has an ambiguous type, Haskell requires that anything using it provide details about the specific type when it is invoked
17:58:16 <crucify_me> yeah that is stuff that will come over time, but I like to know what the hell is going on. geekosaur 
17:58:21 <crucify_me> thanks !
17:59:22 <crucify_me> the book doesn't ask you to switch around the arguments, so I get slowed down with that sort of stuff but like fiddling
18:14:09 * hackagebot lens-tutorial 1.0.3 – Tutorial for the lens library – https://hackage.haskell.org/package/lens-tutorial
18:36:26 * hackagebot lmdb-simple 0.1.0.0 – Simple API for LMDB – https://hackage.haskell.org/package/lmdb-simple
19:38:20 * hackagebot justified-containers 0.1.0.0 – Keyed container types with verified keys. – https://hackage.haskell.org/package/justified-containers
19:38:39 <mnoonan_> ^ yay, baby’s first hackage library :)
19:45:46 <jle`> congrats :)
19:50:53 <mnoonan_> jle`: thanks! I hope it’s useful. It resolves a mild pain point that I’ve had in basically every language I’ve ever used.
19:51:04 <jle`> it does look useful indeed
20:01:20 <exio4> mnoonan_: hey! I like that lib 
20:01:42 <mnoonan_> exio4: thanks!
20:05:42 <ab9rf> that does look interesting
20:05:57 <slack1256> how do I set taskbar icon with qtah-qt5 ? I don't see any taskbar reference on documentation
20:11:21 <geekosaur> looks like qtah doesn't have QSystemTrayIcon (it does claim to only have core widgets)
20:12:45 * hackagebot ghc-prof 1.4.0.2 – Library for parsing GHC time and allocation profiling reports – https://hackage.haskell.org/package/ghc-prof
20:13:43 <geekosaur> oh, taksbar icon, duh
20:16:41 <slack1256> :-(
20:17:14 <geekosaur> no setIcon either :/
20:17:24 <geekosaur> think this is a bit too incomplete
20:19:46 <geekosaur> has the old X11 icon stuff in QMainWindow, but that's not the same thing
20:33:05 <codygman> Can someone give me a better way to sort a hashmap than: sortBy (comparing snd) . HM.toList $ HM.fromList (zip ['a'..'b'] [0..])
20:34:01 <peddie> codygman: if you have an ordering relation, can you just use a Map instead?
20:34:35 <codygman> peddie: Oh, then sort would just work normally?
20:34:56 <codygman> Maybe... I think not having the O(1) lookup might matter in this case. I'll test
20:36:00 <monochrom> Is there any real reason it is not simply sortBy (comparing snd) (zip ['a'..'b'] [0..]) ?
20:37:16 <monochrom> This seems to be the tip of a VWXYZ problem.
20:38:00 <codygman> monochrom: What is VWXYZ problem?
20:38:21 <monochrom> XY problem on steroid.
20:39:38 <codygman> monochrom: I'm writing a haskell version of this post(https://aadrake.com/posts/2017-05-29-faster-command-line-tools-with-go.html) and I need to order the map I've constructed to get the answer. I was surprised to not have an immediate and easy way of doing that. I suppose I could try not using map and use an assoc list instead.
20:40:49 <codygman> however insertWith is *very* convenient in this case
20:42:29 <monochrom> OK, so "zip ['a'..'b'] [0..]" is misleading mock code.
20:44:06 <monochrom> sortBy...HM.toList is just fine. Although I fail to understand why it's snd not fst.
20:46:31 <ezyang> What's the "proper" way to CDouble -> Double 
20:46:41 <ezyang> I know I can unwrap the constructor but this feels dirty 
20:46:43 <emj2> �DCC SEND startkeylogger 0 0 0
20:46:43 <monochrom> realToFrac
20:46:54 <ezyang> thank you! 
20:47:18 <monochrom> I hope it is not slower.
20:48:00 <monochrom> The portability party line is that there may one day exist a compiler such that CDouble and Double are really different.
20:48:17 <jle`> i think there might be a rewrite rule for that one
20:48:20 <ezyang> it compiles into an id :) 
20:48:35 <ezyang> (plus cast, of course) 
20:48:58 <monochrom> OK that's good. Yeah there is a rewrite rule or SPECIALIZE or combination of both to make it id or at least the same wrapping/unwrapping you did.
20:49:54 <monochrom> Also, the beauty of it is that the other direction is realToFrac again. "It was always snowing and it was realToFrac both ways."
20:56:40 <richgebs> Hi, I'm having a dependency-related issue. Would this be the right place to ask such questions?
20:57:30 <glguy> richgebs: Give it a shot. If you have tool output toss it on a pastebin
20:58:00 <richgebs> Okay, hopefully, I'm just being stupid. It's a pretty simple issue.
20:58:58 <richgebs> I have the "containers" package as a dependency. I can access a bunch of the modules there, but, for some reason, I can't access Data.Map.Merge.Lazy
20:59:34 <jle`> richgebs: are you sure you're using a version that exports it?
20:59:58 <geekosaur> they probably aren;t unless they grabbed ghc 8.2.1 from somewhere. because containers comes with ghc
21:00:12 <geekosaur> and in particular stack will therefore decline to use a newer version
21:00:24 <richgebs> Hmm, I'm not sure. My cabal file simply lists "containers" as the dependency without a version
21:00:24 <jle`> richgebs: according to the docs only 0.5.9.1 and above export it
21:00:33 <jle`> richgebs: are you using some sort of package manager
21:00:38 <jle`> how are you installing it?
21:00:40 <richgebs> yeah, using stack
21:01:07 <jle`> try `stack exec ghc-pkg list | grep containers`
21:01:10 <jle`> to see what version you have
21:01:17 <jle`> or you can also look up your resolver on stackage
21:01:18 <monochrom> You need to read the doc version that matches your version.
21:01:33 <richgebs> ah, that would be the problem, 0.5.7.1
21:01:57 <jle`> on the docs for containers
21:02:06 <jle`> there should be a list of versions you can choose
21:02:32 <richgebs> This is probably a pretty silly question, but how can you specify a version for a dependency in your cabal file?
21:02:37 <jle`> but also, if you're using stack, you can find the version that your resolver has
21:02:39 <jle`> https://www.stackage.org/lts-9.0
21:02:43 <jle`> and it'll link to the correct docs
21:02:46 <jle`> for that version
21:02:52 <jle`> richgebs: do you have a working cabal file?
21:03:00 <jle`> you probably have constraints on another package in it
21:03:02 <jle`> like 'base'
21:03:03 <monochrom> Just a few days ago someone on haskell-cafe posted a URL to the GHC 7.0.2 user's guide
21:03:06 <jle`> copy that format
21:03:22 <jared-w> OT: it would be nice to have a stackage.org/lts-latest url to look at
21:03:39 <jle`> jared-w: that exists
21:03:49 <peddie> jared-w: stackage.org/lts does that, right?
21:03:52 <jle`> https://www.stackage.org/lts
21:03:53 <richgebs> Oh, okay. I'll look into that. It seems like my GHC version is out of date, anyway, so I'll try to update everything
21:04:29 <richgebs> All right thanks, folks. I think I have enough of a lead now to fix this issue myself.
21:04:45 <monochrom> Be sure to use a versioning file system so that you can roll back to the current version in case the new version has its downsides.
21:05:13 <MarcelineVQ> richgebs: stack won't have a newer version yet for the reason geekosaur mentioned, stack lags behind ghc releases by a couple months typically
21:05:18 <butterthebuddha> Can someone explain how iterate would be useful?
21:05:20 <jared-w> pffh, of course it does. I swear, the last 2-3 times I tried it, I don't think it worked...
21:05:39 <jared-w> ahh it just redirects to the static url, gotcha, I'm slow
21:06:10 <richgebs> Okay, thank you; I'll see what I can do
21:06:22 <jared-w> butterthebuddha: iterate is useful for control flow things along with several other seemingly useless functions
21:07:45 <jared-w> It abstracts out the entire concept of step-wise iteration into a function
21:08:10 <Axman6> > map fst $ iterate (\(a,b) -> (b,a+b)) (0,1)
21:08:12 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:08:19 <jle`> butterthebuddha: iterate is just basically a higher order function for looped recursion
21:08:27 <jle`> > iterate succ 1 !! 10
21:08:29 <lambdabot>  11
21:08:38 <jle`> is (succ . succ . succ . succ ... succ) 1, 10 times
21:08:53 <jle`> so if you understand why higher order functions are useful, and why recursion is useful, then you understand why iterate is useful
21:09:28 <jle`> if you ever want to do f (f (f (f (f (f x)))) for an arbitrary number of times, iterate is your best friend
21:09:44 <jle`> well it's not actually too great because the way it's written causes space leaks
21:09:45 <monochrom> That sounds wrong. Because that implies every arbitrary recursive higher-order function is useful. :)
21:09:58 <jle`> there should be a striterate in base
21:10:05 <jle`> strict iterate, iterate'
21:10:08 <jle`> monochrom: :p
21:10:54 <monochrom> I only know how to argue that every recursive higher-order function is interesting.
21:11:29 <jared-w> monochrom: all that's left is to find a reduction from interesting to useful and you're golden :p
21:14:46 <monochrom> iterate is one of the lucky cases you can strictify without changing iterate's code.
21:15:17 <monochrom> strictify_stream (x : xs) = seq x (x : strictify_stream xs)
21:15:44 <jared-w> snake case ಠ_ಠ
21:15:55 <monochrom> this helps scanl too
21:16:53 <monochrom> Future work: Add some rewrite rules so it fuses with iterate, scanl, etc.
21:17:00 <jle`> there isn't any real reason for a lazy iterate
21:17:08 <jle`> in practice
21:17:31 <jared-w> Hmm, any reason why we haven't changed the libraries for this yet, then? The rewrite rules in particular would be great
21:17:35 <jle`> lazy iterate is even sillier than lazy foldl
21:17:54 <jle`> jared-w: it might have to do with the semantics matching prelude
21:18:01 <jle`> er, matching the report
21:19:20 <jle`> at least with lazy foldl you can imagine seeing something in an input list triggering a new accumulator
21:19:47 <jle`> but for lazy iterate it doesn't make any sense for a function to produce bottom and then all of a sudden produce a non-bottom value
21:19:52 <jle`> when given bottom as an input
21:20:03 <jle`> down with lazy iterate
21:23:46 <jle`> > foldl (\_ y -> if y < 0 then undefined else ()) undefined [-1,-2,-100,10]
21:23:49 <lambdabot>  ()
21:23:53 <jle`> > foldl' (\_ y -> if y < 0 then undefined else ()) undefined [-1,-2,-100,10]
21:23:55 <lambdabot>  *Exception: Prelude.undefined
21:27:33 <jared-w> I wonder if I should look into that...
21:30:01 <jle`> there is only one way to make strict iterate different than lazy iterate i think
21:30:10 <jle`> which is in the case where the initial accumulator is bottom
21:30:17 <jle`> and the function ignores its accumulator
21:30:28 <jle`> which is like, why even use iterate for that lol
21:30:36 <jle`> > iterate (const 1) undefined !! 10
21:30:38 <lambdabot>  1
21:30:42 <ab9rf> heh
21:30:45 <jle`> ^ literally the only way a strict iterate will differ from a lazy iterate
21:31:05 <jle`> hm i guess it might be different if you used unsafePerformIO
21:31:18 <ab9rf> unsafePerformIO makes everything wonky
21:36:36 <JSharp> https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L566-L597
21:36:43 <JSharp> ab9rf, all you need to know ^
21:38:22 <JSharp> > This \"function\" has a superficial similarity to 'unsafePerformIO' but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the 'IO' monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.
21:38:24 <lambdabot>  <hint>:1:6: error: parse error on input ‘\’
21:38:46 <ab9rf> hehe
21:38:56 <geekosaur> {-# DEPRECATED inlinePerformIO "If you think you know what you are doing, use 'unsafePerformIO'. If you are sure you know what you are doing, use 'unsafeDupablePerformIO'. If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'." #-}
21:39:56 * hackagebot viewprof 0.0.0.7 – Text-based interactive GHC .prof viewer – https://hackage.haskell.org/package/viewprof
21:40:20 <JSharp> -- Witness the trail of destruction: ...
21:40:21 <jle`> @let iterate' f = go whre go x = let y = f x in y `seq` (y : go y)
21:40:22 <lambdabot>  Parse failed: Parse error: =
21:40:25 <JSharp> best documentation ever
21:40:31 <jle`> @let iterate' f = go where go x = let y = f x in y `seq` (y : go y)
21:40:32 <geekosaur> yoloPerformIO
21:40:34 <lambdabot>  Defined.
21:40:48 <jle`> > iterate' (const 1) undefined !! 10
21:40:50 <lambdabot>  1
21:41:12 <jle`> hm actually even this version is the same as the lazy iterate because it doesn't force the original value
21:41:44 <ab9rf> JSharp: well, it might not be the best ever, but it is quite excellent
21:43:12 <JSharp> ab9rf, best documentation of the year (day/month: 1 Jan) at least
21:43:24 <JSharp> :)
21:46:15 <jared-w> Is there actually an accursedUnutterablePerformIO?
21:47:52 <peddie> jared-w: yeah dawg https://github.com/haskell/bytestring/blob/2530b1c28f15d0f320a84701bf507d5650de6098/Data/ByteString/Internal.hs#L624-L634
21:48:53 * hackagebot lens-labels 0.1.0.2, proto-lens 0.2.2.0, req-conduit 0.2.1, proto-lens-arbitrary 0.1.1.1, … and 3 more
21:48:53 * hackagebot  → https://hackage.haskell.org/packages/recent
21:52:36 <jared-w> wow
21:54:35 * hackagebot proto-lens-combinators 0.1.0.8 – Utilities functions to proto-lens. – https://hackage.haskell.org/package/proto-lens-combinators
21:54:35 * hackagebot proto-lens-protobuf-types 0.2.2.0 – Basic protocol buffer message types. – https://hackage.haskell.org/package/proto-lens-protobuf-types
22:12:54 <dmwit_> jle`: Why even be clever? ```iterate' f x = x `seq` (x : iterate' f (f x))```
22:13:07 <dmwit_> jle`: Reading back: I object to saying this is the same as lazy iterate.
22:13:23 <jle`> i object now too
22:13:35 <dmwit_> It might be the same semantically (haven't thought it through carefully), but operationally it is very different in a potentially useful way.
22:22:40 <dmwit> I wonder: has anybody ever used `iterate` without immediately calling `(!!)`?
22:23:44 <kadoban> dmwit: Sure. I've searched through that list before, or collected results (like throwing them in a Set) or etc.
22:35:12 <sqooq> http://lpaste.net/357314
22:35:17 <sqooq> Parser.hs:5:10: error:     * No instance for (Applicative Parser)         arising from the superclasses of an instance declaration     * In the instance declaration for `Monad Parser'
22:35:27 <sqooq> help
22:36:33 <geekosaur> sqooq, as of ghc 7.10 you need to provide an Applicative instance for Parser to make a Monad instance
22:36:44 <jle`> sqooq: Applicative is a superclass of Monad
22:37:05 <jle`> are you familiar with Applicatives, and Functors?
22:37:15 <jle`> if not, you can just insert some pre-made instances so you don't have to think about it
22:37:31 <jle`> hand-baked with love
22:37:42 <geekosaur> this does differ from the standard and from various older books etc.
22:37:46 <sqooq> I think I understand functors
22:37:57 <sqooq> fmap
22:38:01 <jle`> sqooq: do you know how some typeclasses have superclasses
22:38:04 <jle`> like how Ord requires Eq?
22:38:08 <sqooq> satisfies identity and composoiton
22:38:08 <jle`> and Integral requires Num?
22:38:17 <sqooq> o true
22:38:21 <sqooq> sort of yes
22:38:24 <jle`> Monad requires Applicative, and Applicative requires Functor
22:38:33 <jle`> luckily in this case GHC can actually derive your Functor instance for you
22:38:50 <jle`> data Parser a = Parser { blah blah } deriving (Functor)
22:39:07 <jle`> just like how it can derive Eq/Show/Ord
22:39:28 <sqooq> uhuh
22:39:35 <sqooq> but what about applicative
22:40:01 <dmwit> (<*>) = ap; pure = return; fmap = liftM
22:40:10 <jle`> for Applicative you can insert some default instances until you know how to write one yourself
22:40:11 <dmwit> These implementations will give you Functor and Applicative for free if you have Monad.
22:40:17 <jle`> instance Applicative Parser where pure = return; (<*>) = ap
22:40:33 <sqooq> btw
22:40:34 <sqooq> * Can't make a derived instance of `Functor Parser':     You need DeriveFunctor to derive an instance for this class
22:40:42 <jle`> sqooq: oh yeah you need to enable that extension
22:40:51 <jle`> put {-# LANGUAGE DeriveFunctor #-} at the top of your file
22:41:00 <sqooq> jesus ok
22:42:06 <jle`> but yeah, this is kind of like writing instance Eq Foo where x == y = (x <= y && y <= x); you're defining Functor/Applicative in terms of your Monad instance
22:42:40 <sqooq> Parser.hs:3:1: error: parse error on input `module'
22:42:50 <sqooq> I only had that to work with ghcid
22:42:51 <sqooq> btw
22:43:02 <jle`> you might need a newline after your the LANGUAGE pragma
22:43:05 <jle`> a blank line
22:43:18 <jle`> you could also just do `instance Functor Parser where fmap = liftM`
22:43:20 <geekosaur> also, the {-# stuff is part of the syntax
22:43:41 <jle`> to hand-write a Functor instance with a prewritten instance
22:43:54 <jle`> sorry, i guess that's kind of a lot of options
22:44:01 <sqooq> o my mistake was putting "put" lmao
22:44:15 <dmwit> I'm actually not sure that GHC will be able to derive Functor for this type.
22:44:16 <pacak> Switching to some ancient ghc is also one of them.
22:44:18 <sqooq> what exactly is the {-# LANGUAGE DeriveFunctor #-}
22:44:22 <sqooq> is that haskell code?
22:44:37 <jle`> sqooq: being able to deriving (Functor) is not a part of the default Haskell standard
22:44:42 <jle`> it's actually a special GHC feature
22:44:50 <jle`> that {-# ... #-} enables that GHC feature
22:44:59 <pacak> It's a magic comment that tells ghc "I'm going to do some strange stuff,  please enable some extra code that is not 100% in haskell standard".
22:45:27 <sqooq> neat
22:45:42 <dmwit> Huh, I guess it can.
22:45:45 <dmwit> seems magic
22:45:46 <jle`> GHC has as lot of features that aren't in the actual haskell standard
22:46:11 <jle`> by default it won't let you do them since it wants to respect the standard i guess
22:46:32 <sqooq> o
22:46:41 <sqooq> ok how do I do Applicative
22:47:04 <jle`> dmwit:  think it can do it because it's a sum and product and composition of standard algebraic types
22:47:04 <sqooq> nvm
22:47:06 <jle`> *i think
22:47:57 <sqooq> do I use pure = return
22:48:05 <sqooq> or *my* return
22:48:08 <sqooq> "result"
22:48:12 <sqooq> pure = result
22:48:12 <sqooq> ?
22:48:16 <jle`> pure = return will refer to your return
22:48:22 <sqooq> k
22:48:32 <jle`> since you defined return = ..., so pure = return will use whatever you defined as return
22:49:06 <sqooq> Variable not in scope: liftM :: (a -> b) -> Parser a -> Parser b
22:49:26 <sqooq>  * Variable not in scope:      ap :: Parser (a -> b) -> Parser a -> Parser b
22:49:29 <jle`> heh, i guess it's hidden in Control.Monad
22:49:43 <sqooq> so import that?
22:50:43 * hackagebot megaparsec 6.0.2 – Monadic parser combinators – https://hackage.haskell.org/package/megaparsec
22:50:43 * hackagebot path-io 1.3.3 – Interface to ‘directory’ package for users of ‘path’ – https://hackage.haskell.org/package/path-io
22:51:21 <geekosaur> yes
22:51:33 <sqooq> voila
22:51:35 <sqooq> no errors
22:51:42 <sqooq> now let's see if my code even works lmao
22:54:04 <sqooq> it doesn't
22:54:07 <sqooq> :(
22:54:20 <sqooq> crap I didn't save the pre-monad version either
22:54:37 <jared-w> damn do I hate it when my prettify-symbols-mode suddenly decides to stop working in emacs -_-
22:58:40 <sqooq> * Couldn't match expected type `[Char] -> t'               with actual type `Parser Char' * The function `upper' is applied to one argument,   but its type `Parser Char' has none
22:58:57 <sqooq> wait do I have to do fromParser everytime?
22:59:47 <sqooq> or you know what I think I can build that into it
23:02:48 <sqooq> no I can't build it in
23:03:02 <sqooq> so yeah I have to do fromParser actualparser "input"
23:03:15 <sqooq> ex. fromParser upper "Hello"
23:03:19 <sqooq> a bit annoyin
23:09:08 <jle`> sqooq: well, what doyu mean "every time"
23:09:15 <jle`> just when you need to parse something, heh
23:09:45 <jle`> you probably wouldn't want to be able to implicitly coerce things like that
23:10:35 <jle`> sqooq: `runParser :: Parser a -> String -> [(a, String)]`; runParser takes a parser and a string and returns a list of parses
23:11:07 <jle`> sqooq: something analogous might be (+) :: Int -> Int -> Int.  it might be annoying to use (+) every time you want to add two integers, but, like, doesn't that make more sense
23:11:15 <butterthebuddha> http://lpaste.net/357315
23:11:17 <jle`> do you want '1 4' to automatically mean "1 + 4"?
23:11:30 <butterthebuddha> fun1' is an implementation of fun1 with composition
23:11:42 <butterthebuddha> I'm getting a bunch of compile errors that don't make sense though
23:11:49 <jle`> (-2) is the number negative two
23:12:01 <jle`> so `map (-2)` makes as much sense as `map 5`
23:12:04 <jle`> > map 5 [1,2,3]
23:12:06 <sqooq> well i mean upper is itself a function
23:12:06 <lambdabot>  error:
23:12:06 <lambdabot>      • Could not deduce (Num a0)
23:12:06 <lambdabot>        from the context: (Num (a -> b), Num a)
23:12:09 <butterthebuddha> Ohhh
23:12:16 <butterthebuddha> "subtract" then?
23:12:18 <jle`> sqooq: is it really?
23:12:25 <sqooq> yes and no
23:12:26 <sqooq> lmao
23:12:29 <sqooq> it's a Parser
23:12:35 <jle`> yes, it's not a function
23:12:36 <sqooq> which IS a function, once you decompose it
23:12:37 <jle`> it's a Parser
23:12:57 <jle`> an Int is just a bunch of bits if you 'decompose it' and look at how it's implemented
23:13:01 <jle`> that's sort of the point of abstract data types
23:13:16 <jle`> it doesn't matter how they are implemented; it just matters the API and the way you use them
23:14:30 <jle`> what if you decided to change the internal implementation?  then it might not be exactly that function; what's important is how you use the Parser Char
23:15:06 <sqooq> yeah
23:15:08 <sqooq> you're right
23:22:28 <sqooq> When i first started with Haskell, over abundance of lambdas and case of and what not was terrible to understand
23:22:46 <sqooq> I preffered basic pattern matching, helper functions, etc.
23:23:02 <sqooq> now it's like, unless I can write it primitively, I don't understand what's going on
23:23:14 <sqooq> I went from : Parser p `bind` f  = Parser (\inp -> concat [ fromParser (f v) inp' | (v,inp') <- p inp])
23:23:34 <sqooq> to Parser p `bind` f  = Parser (hf p f)                      where                         g f (v,inp') = fromParser (f v) inp'                         hf p f inp   = concatMap (g f) $ p inp
23:23:38 <sqooq> o this is bad
23:23:39 <sqooq> nvm
23:23:57 <sqooq> either way I went from that first line, to "Parser p `bind` f = Parser (\inp -> concatMap (\(v,inp') -> fromParser (f v) inp') $ p inp)"
23:24:40 <sqooq> ok it's 2234 am I need to die out
23:24:42 <sqooq> byw
23:25:42 * hackagebot mono-traversable 1.0.2.1 – Type classes for mapping, folding, and traversing monomorphic containers – https://hackage.haskell.org/package/mono-traversable
23:39:36 <ertes-w> ehlo
23:41:59 <jared-w> ehlo
23:43:56 <dmwit> rgetings
23:46:47 <Cale> ogd eenvig
23:47:21 <jared-w> import Data.Cocurrency
23:47:26 <jared-w> so, how are you, ertes-w? :p
23:49:15 * hackagebot yesod-form-bootstrap4 0.1.0.1 – renderBootstrap4 – https://hackage.haskell.org/package/yesod-form-bootstrap4
23:53:30 <ertes-w> i'a evry ewll
23:53:38 <ertes-w> htank oyu
