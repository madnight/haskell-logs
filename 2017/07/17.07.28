00:18:57 <amx> just how expensive is an FFI call? I must call an init function in a C library before using it, which will return immediately if already initialized. Ideally I would always call this init function before any other function, thus effectively doubling the number of FFI calls. Is it possible to say in general whether this is a good/bad idea or do I need to benchmark?
00:20:50 <merijn> amx: unsafe FFI calls are basically as fast as a function call in C would be
00:20:55 <merijn> amx: But they come with caveats :)
00:21:14 <amx> cool, I believe an unsafe call if OK here
00:21:15 <merijn> amx: http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
00:21:17 <amx> is*
00:22:29 <Axman6> there are also hacks you could use to ensure it's only ever called once, but I wouldn't explore them unless calling this init function is causing real slowdown
00:22:52 <merijn> Yeah
00:23:08 <merijn> I believe network has a hack like that, but honestly just always calling init is probably fine if it's indeed fast
00:23:14 <merijn> Hell, even a safe FFI call might be fast enough
00:23:37 <merijn> amx: ^^ you should probably benchmark whether just using safe FFI calls is fast enough first
00:24:07 <amx> the C function is quite literally: if (initialized) { return 1; }
00:24:55 <merijn> amx: Sure, but the it's not like FFI calls are crazy expensive. I mean, they are if you're thinking straight C. But if you compare to say, function calls in python and JS those are also horribly slow and no one seems to notice/care :)
00:25:17 <ab9rf> most modern software is hideously inefficient
00:25:21 <ab9rf> people don't seem to give a damn
00:25:52 <amx> ok, I will benchmark both. Thanks for the help.
00:28:02 * hackagebot snowtify 0.1.0.3 – snowtify send your result of `stack build` (`stack test`) to notify-daemon… – https://hackage.haskell.org/package/snowtify
00:28:02 * hackagebot benchpress 0.2.2.10 – Micro-benchmarking with detailed statistics. – https://hackage.haskell.org/package/benchpress
00:51:08 <merijn> hmm, so is Chart the only Haskell plotting library or are there others I've missed?
00:53:14 <Axman6> there's another... plots maybe?
00:53:50 <merijn> And mostly unrelated question: Anyone have an example where they bundle C programs (not built by Cabal) with their package, specifically how to get cabal to build dump it in the "libexec" path for your package
00:57:54 <merijn> ugh, the types in the API of Chart and plots is making me appreciate people's complaints about "types aren't documentation" :/
00:58:40 <arahael> merijn: I know of at least one collegue who doesn't like types either.  WHich is why he likes Javascript.  Javascript doesn't have types, you see...
00:59:07 <zomg_> arahael: I used to be like that
00:59:16 <zomg_> because I had only used languages where types were annoying and that's about it
00:59:17 <zomg_> :P
00:59:21 <merijn> I love types, I just don't like how Chart and plots use them
01:00:02 <zomg_> I do remember thinking that python was nicer than php because it didn't let you do stupid things like concatenate strings and numbers
01:00:03 <arahael> zomg_: The point was that Javascript _does_ have types, and javascript programs do have types.
01:00:24 <zomg_> correct but you don't really need to think about it
01:00:37 <arahael> zomg_: Perhaps that's the salient point.
01:00:39 <merijn> I mean: "barPlot :: (MonadState (Axis b V2 n) m, Plotable (BarPlot n) b, Foldable f) => f n -> State (Plot (BarPlot n) b) () -> m ()"
01:00:43 <merijn> wut
01:00:53 <merijn> Who the hell decided *that* was a nice API to use?
01:00:54 <jle`> well, you see
01:01:07 <jle`> MonadFactoryBean would have been a namespace collision
01:01:17 <zomg_> arahael: well, for me it was like I had used C and Java and such where it was always a pain in the ass to figure out how to go from type A to type B and every damn function wanted different types etc....
01:01:38 <zomg_> so I was basically of the opinion that dynamic typing is the way to go until I used Haskell where it actually was quite nice
01:02:22 <jle`> not sure why i am slightly disappointed that MonadFactoryBean doesn't show up on google at all
01:02:23 <arahael> zomg_: It helps that Haskell has a very nice, and quite mature library that is designed towards Haskell's type system, rather than quite crudely dropping you into the FFI.
01:02:26 <merijn> jle`: I mean, this basically gives me as much useful information as the disaster that is matplotlib...
01:02:35 <merijn> Maybe I should just go back to gnuplot...
01:02:38 <`Guest00000> suddenly, with this concurrency and networking, haskell became more difficult
01:02:54 <Axman6> eh? both those things are fantastic in Haskell
01:02:59 <jle`> well...usually, everything becomes more difficult when you add concurrency and networking
01:03:00 <Athas> `Guest00000: s/haskell/programming/ and it would still be correct.
01:03:17 <merijn> Athas: So, what do you use for plotting?
01:03:24 <jle`> the important thing is that `haskell + concurrency + networking` is easier than any `other language + concurrency + networking`
01:03:25 <`Guest00000> no, i still could hack something in another language, but haskell needs purity
01:03:53 <Athas> merijn: Python plus Matplotlib.  Mostly by copy/pasting older plotting programs of mine and modifying them as necessary (I write LaTeX the same way).
01:04:01 <jle`> ah, you didn't mean "haskell became more difficant than it was before i added this".... you meant "haskell became more difficult than other languages" ?
01:04:23 <Athas> Concurrency is _definitely_ not easier without purity.
01:04:26 <`Guest00000> no, i meant first phrase
01:04:32 <jle`> ah
01:04:34 <merijn> Athas: :\
01:04:53 * [exa] mentions erlang
01:04:53 <jle`> well, did you expect haskell to become easier with concurrecny + networking? :p
01:05:03 <jle`> but, yes, concurrency without purity is literally the worst
01:05:04 <merijn> Athas: I was hoping to banish matplotlib from my code. Maybe the easiest thing is to rip out the data processing into Haskell code and then call a minimal matplotlib script from that
01:05:19 <`Guest00000> well, there's correctness and there's hackability, and haskell forces high correctness
01:05:35 <merijn> WTB plotting library without lens >.<
01:05:38 <Athas> merijn: yes, I only plot data that is already mostly processed (maybe except a few final filtering tasks).
01:06:01 <Axman6> so, what would be the XML equivalent of Aeson in Haskell? I want to define datatypes and have them serialised to XML
01:06:10 <`Guest00000> with easy hackability
01:06:16 <Athas> I'd love to use a statically typed plotting library, because Matplotlib always seems so bloody mushy.  It feels like it works by accident.
01:06:28 <`Guest00000> relatively to other values in the graph
01:06:51 <Axman6> `Guest00000: you're making a bunch of concurrent HTTP requests right? this is trivial, it takes nearly no code at all
01:06:59 <merijn> Athas: You know what was great? When I implemented an algorithm to generate colours dynamically and it worked with line/dot plots, but NOT bar charts, despite all of them taking "colours" as argument
01:07:01 <`Guest00000> no, i'm a server
01:07:07 <`Guest00000> heh
01:07:19 <merijn> Athas: It would just magically produce an error during PDF generation for the barchart
01:07:28 <jle`> well, however difficult concurrency is in haskell, it might be of comfort to remember that it's harder in almost everything else, heh
01:07:48 <Axman6> `Guest00000: are they HTTP requests?
01:07:49 <jle`> (reading that again, it didn't feel very comfortable)
01:07:58 <Athas> merijn: that's not due to types, I think.  You can have bugs in Haskell code, too.
01:08:03 <`Guest00000> Axman6: no
01:08:08 <arahael> Incidentially, I quite like Snap for this.
01:08:17 <merijn> Athas: Chart's API seems to be somewhat usable, but it's way to limited to be actually useful
01:08:26 <`Guest00000> let's say it's a multiplayer game
01:08:50 <Axman6> merijn: how so? I found Charts extremely powerful
01:08:57 <jle`> i've struggled with mutliple haskell plotting libraries over the years and i've never found soemthing pleasant enough to make me excited to come back
01:08:57 <arahael> And wreq for the client.
01:09:00 <merijn> Athas: No, it wasn't a bug, just functions taking two different things as "colour" which wasn't documented well (or typechecked) and the ducktyping conversion failing
01:09:12 <merijn> Axman6: Can't even specify textures/hatching for bar charts
01:09:17 <Athas> `Guest00000: if you just want to hack, then keep some global state in an MVar, and have every connection thread just modify its contents.
01:09:19 <arahael> jle`: For plotting, I'm increasonly of hte opinion that SVG is probably about right.
01:09:37 <merijn> Axman6: That basically means it unusable if you want to produce colour-blind/grayscale friendly plots
01:09:44 <jle`> arahael: the graphics format?
01:09:50 <arahael> jle`: Yes. :(
01:09:53 <jle`> i was talking about libraries, heh
01:10:14 <arahael> jle`: Pretty simple to display them, too, these days.
01:10:21 <Axman6> merijn: you have full control over the colours used
01:11:07 <Axman6> but textures would be good. submit a ticket!
01:11:10 <merijn> Axman6: That merely alleviates (not solves) the colour-blind issue and has literally 0 impact on grayscale friendliness
01:11:13 <merijn> Axman6: I did
01:11:30 <arahael> merijn: greyscale isn't a sufficient check, I think.
01:11:51 <arahael> merijn: The brightness is percieved differently by differentpeople.
01:11:56 <merijn> arahael: Greyscale isn't to help colourblind people. It's because academics always print black and white
01:12:02 <arahael> merijn: Oh, of course!
01:12:10 <arahael> Still, textures would be where it's at, I think.
01:12:11 <`Guest00000> arahael: but will that be reliable enough
01:12:21 <arahael> `Guest00000: Greyscale?
01:12:31 <merijn> arahael: I want textures so that it is readable in grayscale, yes
01:12:35 <`Guest00000> arahael: what you replied to me
01:12:52 <`Guest00000> no, you didn't reply anything
01:12:54 <`Guest00000> sorry
01:12:56 <arahael> `Guest00000: Just to clarify, what did I reply?
01:12:59 <arahael> Indeed.
01:13:18 <M2tias_> !hype
01:13:23 <M2tias_> oops
01:13:27 <M2tias_> wrong channel :|
01:13:32 <merijn> Axman6: But an open ticket doesn't help me with my current "I really wanna get rid of this python plotting code" issue :p
01:13:40 * arahael boos M2tias
01:13:41 <`Guest00000> chat must have scrolled too fast when i clicked
01:13:46 <M2tias> arahael: :'(
01:14:09 <`Guest00000> Athas: but will that be reliable enough?
01:14:21 <Athas> `Guest00000: did you want correctness or easy hacking?
01:14:32 <arahael> merijn: There's MissingPy. ;)
01:14:36 * arahael hasn't used it.
01:14:39 <Athas> Anyway, using a single global MVar will be reliable (if you use atomic access functions), but it will not scale well.
01:14:59 <Athas> If your design calls for shared mutable state in a concurrent system, no language will save you.
01:15:53 <arahael> Athas: There's still SQL. :)
01:15:55 <merijn> arahael: Meh, easier to just use IPC
01:16:03 <arahael> merijn: Probably. :(
01:16:09 <`Guest00000> i want enough reliability
01:16:13 <arahael> merijn: Which IPC do you use, incidentially? (I want to play with zmq)
01:16:18 <merijn> arahael: I already to that to pass data to/from my python modeling library
01:16:26 <merijn> arahael: eh...I just use pipes? :p
01:16:50 <arahael> merijn: Fair enough - unixy. :)  A bit of a pita in windows, I find, though.
01:16:54 <merijn> arahael: CreateProcess calling a python script from haskell, pass in data to pipe :p
01:17:27 <merijn> arahael: How so? The process library is both windows and *nix, afaik and supports replacing stdin/stdout easily
01:18:07 <arahael> merijn: I keep finding things are annoyingly different.  Then again, I do scripting, on windows.
01:18:23 <arahael> merijn: The other day one program, which does have stdout, apparently doesn't use the *standard* stdout.
01:18:45 <merijn> There is only 1 standard out, by definition. It just doesn't have to be the terminal
01:19:09 <arahael> merijn: It was sent to the terminal, but... Let me find hte program...
01:19:25 <merijn> arahael: Could be stderr?
01:19:32 <arahael> merijn: Nope.
01:19:54 <arahael> merijn: The program is regsvr32
01:20:22 <arahael> merijn: I needed to script it, and wanted to capture it's output.
01:54:31 <osa1> read-only lens definitions that use Getter generates "redundant Contravariant constraint" warnings. defining using standard lens type with `f = Const s` is too verbose. anyone know a better alternative?
01:56:11 <lyxia> just turn off the warning
01:56:51 <lyxia> that is, if your intent is precisely to only make a Getter and not a full Lens
01:57:05 <osa1> of course that's the intention, but I have no intention of turning off warnings module-wise
01:58:47 <osa1> what if I define a type synonym for the verbose type? I think that type is somewhat more specific, would that cause any trouble when using read-only lenses/operator from the library?
02:02:06 <merijn> osa1: You can use a pragma to specify options for a single file
02:03:30 <osa1> like I said I don't want to turn off warnings module-wise, that's why I'm looking for alternatives. what about Const type synonym idea?
02:04:30 * hackagebot compactmap 0.1.4.2.1 – A read-only memory-efficient key-value store. – https://hackage.haskell.org/package/compactmap
02:11:21 <lyxia> I guess it works. But if it's just a getter, why not make a simple function?
02:15:18 <osa1> lyxia: only reason is because I want it to work well with lenses and I don't know if a simple function will
02:15:29 <osa1> so if I just write `s -> a` will that work with e.g. (^.) ?
02:16:17 <lyxia> ^. to myFunction
02:16:34 <osa1> hmmmm
02:17:06 <osa1> lyxia: that's great, thanks
02:17:39 <lyxia> yw
02:26:20 <jle`> > view (to fst) (1,2)   -- osa1 
02:26:22 <lambdabot>  1
02:37:08 * hackagebot withdependencies 0.2.4.1 – Run computations that depend on one or more elements in a stream. – https://hackage.haskell.org/package/withdependencies
02:47:15 * hackagebot pcre-utils 0.1.8.1.1, stateWriter 0.2.8.2
02:47:15 * hackagebot  → https://hackage.haskell.org/packages/recent
02:55:00 <phz_> is there a servant IRC channel?
02:55:18 <phz_> oh, just servant
03:03:20 <`Guest00000> omg i thought whileM was going to be m (Maybe a) -> m [a] // m Bool -> m (), but someone already implemented them with wronger types...
03:03:43 <ongy> wronger types?
03:03:44 <ongy> :t whileM
03:03:46 <lambdabot> error: Variable not in scope: whileM
03:04:51 <`Guest00000> whileM :: Monad m => m Bool -> m a -> m [a]
03:04:56 <`Guest00000> whileM_ :: Monad m => m Bool -> m a -> m ()
03:05:12 <`Guest00000> you don't need m a
03:06:18 <ongy> it's the equivalent of imperative while construccts. I would expect them to work like that
03:06:27 <`Guest00000> but...
03:12:17 <orion> Has anyone else noticed that "--allow-newer" is conspicuously absent from the latest Cabal?
03:14:09 <ertes> `Guest00000: i agree that the existing ones are worse than necessary, but honestly i can't bring myself to depend on libraries like monad-loops at all
03:15:13 <ertes> in my view of the universe and everything there should be a data structure corresponding to every recursion pattern
03:16:16 <merijn> orion: 1) you probably mean cabal-install and 2) no, it's still there
03:16:31 <ongy> hehe, so forever act = mapM_ (\_ -> act) [0..]
03:16:40 <merijn> orion: As in, my cabal-install is from github master from 1.5 days ago and it has --allow-newer
03:16:45 <`Guest00000> ertes: okay. i need to wait till an MVar is True. how would you do it with data structures?
03:17:23 <ertes> `Guest00000: readTVar v >>= check
03:17:24 <ertes> =)
03:18:14 <ertes> `Guest00000: alternatively use MVar () instead of MVar Bool
03:18:30 <ertes> takeMVar v  -- waits for it to become "true" (full)
03:19:32 <ertes> (also resets it to False…  use readMVar, if you don't want that)
03:22:00 <orion> merijn: When I run ./Setup configure --allow-newer I get: unrecognized 'configure' option `--allow-newer'
03:23:30 <merijn> orion: Well, I see --allow-newer in the output of "cabal configure --help", so...
03:24:15 <merijn> orion: How did you built ./Setup? And why are you using ./Setup, rather than cabal-install?
03:24:21 <orion> merijn: I don't see it in the output of "./Setup configure --help"
03:24:35 <orion> merijn: I'm running the bootstrap.sh script provided by cabal-install.
03:24:43 <merijn> hmmm
03:24:49 <merijn> Did you already install Cabal?
03:25:03 <orion> merijn: It was installed with GHC 8.2.1.
03:25:17 <orion> Cabal-2.0.0.2
03:25:36 <merijn> orion: hmm, I've always manually installed Cabal first, before installing cabal-install. But I also haven't tried installing ghc-8.2 yet
03:26:04 <orion> I don't see why I would manually build Cabal since it ships with 8.2.
03:27:04 * hackagebot SSTG 0.1.0.9 – STG Symbolic Execution – https://hackage.haskell.org/package/SSTG
03:27:11 <merijn> orion: That's what I remember from instructions when I started installing GHC/cabal-install by hand and never checked since whether it was necessary or not
03:35:10 <`Guest00000> Control.Monad.STM.check on hackage doesn't even give description
03:42:41 <slack1256> I am worried about total allocation on haskell
03:43:19 <slack1256> by default we allocate too much. Doesn't that put much pressure of the cpu-memory channel that already is a bottle neck?
03:43:38 <merijn> slack1256: What do you mean "by default we allocate too much"?
03:44:01 <slack1256> think of any recrsive function, say fib
03:44:46 <merijn> Yes?
03:45:21 <slack1256> each recursive step allocates a new thunk on the heap plus the modified int. this works but allocates a lot
03:45:58 <slack1256> playing with the weight package shows for fib 10 it allocates around 1000 bytes
03:46:15 <slack1256> when the impertive version doesn't use more than 60
03:46:21 <merijn> slack1256: That's because the naive recursive fib implementation is quadratic
03:46:30 <slack1256> oh sorry
03:46:35 <slack1256> I was thinking of fac
03:46:36 <slack1256> not fib
03:46:56 <slack1256> my fingers didn't do what my mind was asking :-)
03:47:10 <merijn> slack1256: The naive recursive version of factorial is linear in space, rather than constant, so the solution would be to not implement factorial the naive recursive way :p
03:48:43 <slack1256> yeah, not the point. The point ts that because we cannot cheat with mutation we have to allocate new values. This shows when you run +RTS -s as the total allocation value is in the order of terabytes for simple programs
03:48:50 <slack1256> the amount is not the problem
03:49:02 <slack1256> as most of it dies in gen 0 collections
03:49:09 <merijn> slack1256: I think you're looking at the wrong numbers
03:49:23 <merijn> slack1256: Also, GHC is not other languages, allocation is actually super cheap
03:49:47 <merijn> slack1256: Can you show the example profiling output of your factorial example?
03:50:35 <slack1256> not really. We got cheap allocation because the nursery by default is usually no larger than the L2 cache
03:50:43 <tabaqui> funny
03:50:59 <slack1256> is not as if ghc can do magic on hardware
03:51:00 <tabaqui> I thought that list comprehension is just a syntax sugar
03:51:03 <merijn> slack1256: No, we have cheap allocation because haskell's allocation is a pointer bump
03:51:13 <tabaqui> but Monad instance for List is defined via LC
03:51:21 <merijn> slack1256: As opposed to malloc, which usually involves taking locks and complex logic
03:53:45 <slack1256> https://stackoverflow.com/questions/21814165/avoiding-allocations-in-haskell 
03:53:57 <slack1256> I worry about the total alloc number
03:55:07 <merijn> slack1256: Why?
03:56:34 <slack1256> I got the idea that memory access has higher latency that register and cache.
03:57:04 <slack1256> with this amount of allocation, I guess we are hitting main memory a lot innecesarily right?
03:58:20 <merijn> slack1256: memory allocation and cache missing are not directly related in any way
03:58:34 <merijn> slack1256: that has way more to do with memory access patterns than total memory usage
04:00:02 * hackagebot hw-hedgehog 0.1.0.0 – Extra hedgehog functionality – https://hackage.haskell.org/package/hw-hedgehog
04:01:52 <ertes> `Guest00000: check = guard
04:07:05 * hackagebot bank-holidays-england 0.1.0.6 – Calculation of bank holidays in England and Wales – https://hackage.haskell.org/package/bank-holidays-england
04:07:06 * hackagebot bank-holidays-england 0.1.0.4 – Calculation of bank holidays in England and Wales – https://hackage.haskell.org/package/bank-holidays-england
04:14:41 <`Guest00000> ertes: well now i need to wait for the false condition of that same variable
04:15:51 <ertes> `Guest00000: readTVar v >>= check . not
04:17:25 <ertes> alternatively:  mask_ (putMVar v () >> takeMVar v)  -- if you want to keep the "false" value
04:17:45 <ertes> alternatively:  putMVar v ()  -- if you want to reset it to "true" as soon as it becomes "false"
04:18:51 <merijn> ertes: "putMVar v () >> takeMVar v" will wake up everyone if they block with readMVar, though
04:19:16 <ertes> yeah, i'd go with STM here
04:20:13 <ertes> you can't really *wait* for a value with MVar, you can only really *poll* periodically, unless you use a second MVar to signal changes
04:20:52 <ertes> and then it's surprisingly difficult to synchronise two MVars
04:21:52 * hackagebot alarmclock 0.4.0.3 – Wake up and perform an action at a certain time. – https://hackage.haskell.org/package/alarmclock
04:22:09 <merijn> ertes: What do you mean by "you can't wait for a value"?
04:22:53 <merijn> ertes: If the goal is that everyone should be woken up by the value then readMVar would work fine
04:23:05 <merijn> Although, I suppose slightly tricky to implement right
04:24:19 <butterthebuddha> Hey peeps
04:24:24 <butterthebuddha> So I'm still struggling with problem 3 at https://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
04:24:49 <butterthebuddha> I have a list which has the number of stars I need to add at the correct indexes
04:25:20 <butterthebuddha> I'm struggling with turning that into the histogram
04:25:57 <arpl> Hello! Haskell beginner. I have a question about 'code as comments'.
04:26:18 <arpl> Comments in source are of course completely ignored, but I was wondering about making code more readable (YMMV : ) by using 'no-ops'.
04:26:35 <arpl> 2 Examples of what I mean follow. Do these things 'fall out' at compile time or do they still incur a runtime cost?
04:26:50 <arpl> 1) In the Game of Life you have a grid of cells and behavior depends on number of neighbors. I find it clear to use "grid" "cell" "behavior" and "neighbor".
04:27:05 <arpl>    But in longer expressions typing those 'long names' each time is cumbersome. So I define them 'long' and then something like: b = behavior; n = neighbor;
04:27:22 <arpl>    and use those in subsequent expressions. Does the 'intermediate redirection' get eliminated during compilation?
04:27:34 <arpl> 2) When writing guarded patterns there is often a trivial case. Say I want to determine if a number is negative, zero or positive. Distribution is uniform
04:27:48 <arpl>    so I pick off the negatives first, positives second, with zero last because it is the 'smallest subset' ... it is also the trivial case because there is
04:28:01 <arpl>    no other possibility left. Still it would be clear to write the guard (x == 0) there too ... but there is no need to generate code for it.
04:28:14 <arpl>    In a similar vein to "otherwise = True" I defined "trivially = const True". So I can write "| trivially (x == 0)" ... which will always evaluate to True
04:28:29 <arpl>    regardless of the predicate. Will that fall out during compilation and not generate any actual machine code?
04:28:29 <lyxia> 1) yes
04:29:43 <lyxia> 2) I would write "case compare x 0 of LT -> ... ; GT -> ... ; EQ -> ..."
04:30:33 <lyxia> and yes this is trivially dead code that the compiler will optimize away
04:31:41 <slack1256> I would say that 2) would compile to the same as inlining const seems a basic optimization and results in the same code.
04:32:17 <merijn> I *strongly* dislike the whole "trivially = const True"
04:32:19 <slack1256> yet I would ask if writing like that (with code expected to not execute but be informaitive) is actually helpful
04:32:57 <slack1256> a `on-line` comment is enough 
04:33:17 <arpl> lyxia: Thank you.      I know there are other ways to write it, it was just a simple example that I came up with.          It is perhaps an odd concern to have but I come originally from an assembly background and so things like that are still in my mind.
04:33:25 <slack1256> | otherwise = 0 -- only other case to check
04:34:35 <lyxia> I think "trivially ..." could be like an assertion, that is checked during development and disabled in production.
04:34:49 <arpl> merijn: Understand that too.       I see now that my question is about dead code elimination.        So it will be better if I look up how I can get the generated code (in various forms) from GHC.
04:34:56 <slack1256> IIRC we do have a `assert` function somewhere
04:35:49 <arpl> Since I come from a low level background, I am exploring the ´ultra high level landscape´ that Haskell provides.
04:35:50 <`Guest00000> :i assert
04:36:06 <`Guest00000> :t assert
04:36:07 <lambdabot> Bool -> a -> a
04:36:18 <`Guest00000> it's in Control.Exception
04:36:41 <slack1256> Nice, also the docs says that is ignored with -O or -fignore-asserts
04:37:08 <slack1256> and the implementation is like the const shown above
04:38:27 <`Guest00000> ertes: guard calls fail if its argument is False
04:39:20 <`Guest00000> what's fail in STM? it's unusable if it throws error, it's unusual if it doesn't
04:39:39 <`Guest00000> unusable because of your examples
04:42:14 <arpl> slack1256: That is a good question! And one I was exploring : )         The reason I came up with the ¨trivially¨ idea was because the predicates would line up ... and then I didn´t want to execute code that was not necessary ; )
04:42:35 <`Guest00000> (i just checked) check isn't guard
04:48:27 <lyxia> how is it not guard
04:50:14 <lyxia> http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Monad.html#v:guard "guard b is pure () if b is True, and empty if b is False."
04:50:33 * hackagebot flow 1.0.8 – Write more understandable Haskell. – https://hackage.haskell.org/package/flow
04:53:57 <ertes> `Guest00000: it's equivalent to 'guard'…  (fail _), 'mzero' and 'empty' are all 'retry' in STM
04:54:40 <ertes> `Guest00000: check b = if b then pure () else retry
05:00:19 <`Guest00000> omg
05:00:26 <`Guest00000> stupid again..
05:01:32 <arpl> Haskell/functional programming is a completely new ´design space´ for me. And I am exploring that space. I did wonder why if ... then ... else was a ´language construct´ and not simply a function? It was easy to come up with a function ¨if¨. When I searched on that it was clear both why the commitee put it in ... and that I was not the first to wonder that. : )
05:03:19 <dibblego> arpl: most languages have if/then/else, sometimes spelled differently e.g. ? :
05:03:50 <lyxia> well why not spell it "if"
05:04:00 <merijn> :t bool
05:04:01 <lambdabot> a -> a -> Bool -> a
05:04:10 <dibblego> bool is if/then/else with the arguments in the correct order
05:05:47 <boj> comes from bool-extras though, right? you'd have to be aware that it even exists to use it
05:05:58 <dibblego> Data.Bool
05:06:03 <merijn> boj: No, it's in base
05:06:14 <lyxia> dibblego: what's correct about this
05:06:15 <merijn> boj: Has been for several GHC releases
05:06:16 <boj> hmm, my hoogle-fu sucks then
05:06:22 <merijn> lyxia: Bool argument last
05:06:24 <boj> disregard
05:06:39 <merijn> lyxia: And proper order for "Bool-elimination" if you're theoretically inclined
05:06:42 <dibblego> lyxia: foldr (:) [] = id; either Left Right = id; maybe Nothing Just = id; ? False True = id 
05:09:37 <boj> is bool actively used over if/then/else anywhere?
05:09:43 <lyxia> Okay it's more uniform in that sense. But in terms of usage the "if" ordering is often convenient.
05:10:27 <merijn> boj: honestly, if/then/else is rarely used to begin with
05:10:30 <boj> and what does "correct order" mean?
05:10:48 <petercommand> the Bool is the last argument so you can create a function that eliminates Bool for any given type a
05:10:57 <boj> ah, ok
05:11:46 <boj> i get that guards are preferable over if/then/else, but i can't say that i've randomly come across people using 'bool'. maybe i just glossed over it
05:12:31 <MarcelineVQ> bool reduces your golf score
05:12:45 <arpl> dibblego: One of the reasons why I was wondering about it was because it added extra reserved words that seemed unnecessary (since a ´terse´ if function could easily be defined).         Also because an if-function seemed more functional : )
05:12:49 <lyxia> I think it's subjective, rather than a matter of correctness.
05:12:54 <boj> MarcelineVQ: :>
05:13:59 <boj> lyxia: doesn't if/then/else require some hackery to implement? maybe bool is just more functional in general?
05:14:47 <lyxia> boj: Sorry I was talking about the order of arguments of "bool" vs a hypothetical "if"
05:15:06 <hpc> > bool "first" "second" False
05:15:08 <lambdabot>  "first"
05:15:21 <lyxia> "if" function
05:15:44 <lyxia> boj: but you are right that the language would be simpler without if/then/else
05:15:53 <MagneticDuck> One thing I'm not comfortable doing in Haskell is running very long computations. For example, running a fold through a sequence of ~10^10 elements.
05:16:54 * hackagebot hailgun 0.4.1.5 – Mailgun REST api interface for Haskell. – https://hackage.haskell.org/package/hailgun
05:17:21 <merijn> MagneticDuck: Why not?
05:17:25 <`Guest00000> i'm getting nested expressions like fff (async (...)) where fff is from Control.Concurrency.Async, is it ok?
05:18:29 <MagneticDuck> merijn: The last time I did something similar, I couldn't run even a part of my program in ghci -- there was some strictness problem that didn't appear when compiled. Weird stuff.
05:19:15 <merijn> I'm not really sure why that'd make long computations problematic?
05:19:16 <MagneticDuck> I'm also worrying that I'm not doing things in an efficient way. Dealing with efficient inner loops in Haskell is still a bit of a mystery to me.
05:19:48 <merijn> MagneticDuck: Well, step one in assessing the efficiency is to never use ghci to see how long something takes, because ghci performs terribly
05:19:57 <`Guest00000> why does this even happen, Async could have functions which return Async instead of IO, or have a typeclass for this
05:20:19 <MagneticDuck> merijn: Lack of strictness can make long computations very problematic :p
05:20:40 <MagneticDuck> When debugging my code, I had to hard-cycle my computer a few dozen times.
05:20:53 <merijn> eh...wut?
05:21:13 <merijn> That sounds unlikely to be a haskell problem, tbh
05:21:29 <MagneticDuck> Huh? I mean it used all my memory!
05:21:58 <merijn> I'm not sure why that would require powercycling the machine? It's not like memory can only be used once?
05:22:16 <MagneticDuck> It froze up completely.
05:22:33 <MagneticDuck> Anyway I can solve that by containerizing the process.
05:22:45 <merijn> Like I said, that doesn't sound like Haskell issue. That sounds like a "my OS is awful" issue
05:22:53 <MarcelineVQ> MagneticDuck: have a look at this if you've not seen it yet https://wiki.haskell.org/Foldr_Foldl_Foldl'
05:23:40 <MagneticDuck> MarcelineVQ: I have. I know how foldl' works and why it's better. I also use BangPatterns to great effect... but laziness seems to find ways to bite me when I don't expect.
05:24:00 <MagneticDuck> merijn: Well, yeah.
05:24:43 <MagneticDuck> The question I wanted to ask is -- are there any libraries or abstractions that could help me reason about computations? Maybe even help parallelize them?
05:25:11 <merijn> MagneticDuck: That depends on the kind of computation
05:25:42 <`Guest00000> are there any remote alternatives to async?
05:26:48 <ertes> arpl: one issue i might have with an 'if' *function* is that the argument order would be obscure…  if you look at the 'bool' function, which is basically a functional 'if', the only way you can deduce the argument order is by looking at its definition
05:27:03 <ertes> > map (bool "false" "true") [False, True]
05:27:05 <lambdabot>  ["false","true"]
05:29:11 <MagneticDuck> merijn: Okay, well... My current problem is just to "mconcat" a great big indexed set of values.
05:30:09 <Myrl-saki> ertes: Clearly, the way should be `map (? "true" : "false") [False, True]` C: 
05:31:09 * hackagebot forward-chan 0.0.0.0 – Concurrent channels with a forwarding primitive – https://hackage.haskell.org/package/forward-chan
05:31:20 <ertes> @let mx ? y = maybe y id . mx; infixr 1 ?; onTrue x = bool Nothing (Just x); onFalse x = bool (Just x) Nothing
05:31:21 <lambdabot>  .L.hs:166:10: error:
05:31:21 <lambdabot>      Multiple fixity declarations for ‘?’
05:31:21 <lambdabot>      also at  .L.hs:186:1-10
05:31:26 <ertes> @undef
05:31:26 <lambdabot> Undefined.
05:31:27 <ertes> @let mx ? y = maybe y id . mx; infixr 1 ?; onTrue x = bool Nothing (Just x); onFalse x = bool (Just x) Nothing
05:31:29 <lambdabot>  Defined.
05:31:45 <Myrl-saki> Sweet jesus
05:31:53 <ertes> > map (onTrue "yes" ? "no") [False, True]
05:31:55 <lambdabot>  ["no","yes"]
05:32:05 <ertes> > map (onFalse "no" ? "ye") [False, True]
05:32:07 <lambdabot>  ["no","ye"]
05:33:09 <MagneticDuck> I could sit down and write a function `(Enum i, Monoid m) => (i -> m) -> IO m` that computes this with all the fancy tricks and writes a progress indicator and everything, but as I've said I'm not comfortable with optimization in Haskell and I need this to be fast.
05:33:19 <Cale> `Guest00000: I'm not sure I understand what situation you're describing there
05:33:28 <MagneticDuck> I'd like to know how this sort of problem is solved. Maybe it's something simpler than I'm expecting.
05:34:14 <Myrl-saki> @let (??) p t f = if p then t else f; infixl 1 ?; (:::) = ($); infixl 1 :::;
05:34:15 <lambdabot>  .L.hs:160:10: error:
05:34:15 <lambdabot>      Multiple fixity declarations for ‘?’
05:34:15 <lambdabot>      also at  .L.hs:162:1-10
05:34:23 <Myrl-saki> @undef
05:34:23 <lambdabot> Undefined.
05:34:30 <ertes> awww =/
05:34:31 <MagneticDuck> Oh right -- and I need something to replace `Enum` that doesn't expect my index to be constrained to a puny 32 bit integer ;)
05:34:34 <Myrl-saki> @let (??) p t f = if p then t else f; infixl 1 ??; (:::) = ($); infixl 1 :::;
05:34:35 <lambdabot>  .L.hs:160:1: error: Not in scope: data constructor ‘:::’
05:34:35 <lambdabot>  
05:34:35 <lambdabot>  .L.hs:162:10: error:
05:34:43 <Myrl-saki> Wait, what?
05:34:57 <ertes> Myrl-saki: first symbol shouldn't be ':'
05:35:02 <Myrl-saki> Awww. :(
05:35:12 <ertes> it's an "upper-case" symbol, so it's reserved for data constructors
05:35:42 <Myrl-saki> Lmao
05:35:48 <Myrl-saki> That's actually scary :C
05:36:22 <ertes> MagneticDuck: BTW, for the progress bar bit i have written a concurrent progress bar library that might be useful to you
05:36:36 <ertes> @hackage progress-meter
05:36:36 <lambdabot> http://hackage.haskell.org/package/progress-meter
05:36:55 <Cale> Myrl-saki: It's the only symbol which is regarded as "uppercase" for that purpose
05:41:22 <ertes> MagneticDuck: it's designed in a way that you don't need to worry too much about it…  for example it has a built-in debouncer and only ever wakes up if it needs to
05:43:20 <MagneticDuck> ertes: Hmm, looks nice. I'll be using that for sure. I want to worry about as little as possible :(
05:48:17 <ertes> MagneticDuck: then here is your template: main = withProgress 100000 (\prog -> withAppendMeter prog (\m -> … setMeter m "my current status" … putMsgLn prog "some diagnostics output that should scroll by" …))
05:48:46 <ertes> displays a progress bar that is at most updated every 0.1 seconds
05:49:39 <ertes> the API is completely thread-safe, so you can use 'withAppendMeter' from within your separate thread…  if you have multiple separate threads that way, the individual meters are displayed side-by-side
05:50:15 <ertes> (separated by " | " by default, see 'setProgressSep')
06:07:15 <arpl> ertes: Yes. But these are just questions that come up when you come into new territory. I have read http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf and choices made become more clear and understandable.          I had the same problem you just described when I looked at continuation passing style where you also have to keep the failure and success continuation in your head.
06:20:28 <ertes> arpl: there is one difference though: continuations for different purposes usually have different types
06:20:43 <ertes> type EitherC e a = forall r. (e -> r) -> (a -> r) -> r
06:20:58 <ertes> you can clearly tell which continuation denotes what
06:21:28 <ertes> type BoolC = forall r. r -> r -> r
06:21:32 <ertes> in this case not so much
06:22:57 <ertes> conventions can be helpful here: for example the constructors are often given in Enum order, but you can never be certain
06:23:27 <ertes> or rather in Ord order
06:30:43 * hackagebot websockets 0.12.2.0 – A sensible and clean way to write WebSocket-capable servers in Haskell. – https://hackage.haskell.org/package/websockets
06:31:44 <angerman> cocreature: can build ghc (HEAD) with llvm5 (opt, llc) ;-)
06:33:23 <arpl> ertes: True. And when things are new to you there is no ´automatic parsing´ yet, so more room for confusion.      So doing these things/thinking about it is also a way for me to get a more intuitive feel for things.         Was certainly needed at the start, Haskell did feel more ´alien´ to me than I expected it to be. The fundamental concepts (functions and also lambda calculus) were not, but the various implications certainly were
06:33:23 <arpl> .
06:33:23 <cocreature> angerman: nice!
06:33:54 <angerman> cocreature: on the downside I had to learn that my LLVM patch (https://reviews.llvm.org/D30770) was insufficient.
06:34:07 <angerman> cocreature: I hope to get a fix still in for LLVM5 though, let's see.
06:37:57 <srhb> What's the magical incantation to take the difference of two TimeOfDays in thyme?
06:41:53 <lyxia> srhb: use the timeOfDay iso perhaps
06:44:08 <JazzyEagle> Hello...  I'm trying to figure out how to create a full URL for one of our static files, so we can send that URL to an external site, but I'm having a hard time figuring it out.  Currently, we use "defaultUrl <- getUrlRender <*> pure defaultRoute", which gets us everything but the approot.  I'm having a hard time figuring out how to add the approot in to create the full URL.
06:44:15 <JazzyEagle> Does anyone know how to do that?
06:45:58 <JazzyEagle> If it helps, defaultRoute is defined elsewhere in code as (StaticR default_image_png)
06:47:19 <JazzyEagle> Sorry, wrong channel.  That was meant for #yesod
07:04:38 <srhb> lyxia: Yes, thank you.
07:11:10 * hackagebot dbcleaner 0.1.2 – Clean database tables automatically around hspec tests – https://hackage.haskell.org/package/dbcleaner
07:46:34 * hackagebot cue-sheet 1.0.0 – Support for construction, rendering, and parsing of CUE sheets – https://hackage.haskell.org/package/cue-sheet
08:06:14 <[exa]> Hm guys. So I heard Haskell can be compiled to javascript. Q: Is there some functional work-alike of the JS frameworks, like react/angular? Or is it a generally bad idea?
08:07:15 <sm> reflex and miso are two, I'm guessing
08:08:02 <jackhill> yes, I would recommend reflex too. https://www.reddit.com/r/haskell/comments/5aksxa/ghcjs_framework_similar_to_elm_or_reactredux/ seems to be a simlar discussion
08:08:21 <jackhill> I didn't know about miso before, cool!
08:08:27 <[exa]> miso seems supercool
08:08:32 <[exa]> thanks guys!
08:09:15 <[exa]> it seems that reflex is more general in the purpose? it seems to be oriented more to FRP than DOM problems
08:09:47 <sm> reflex-dom is the "FRP" package
08:10:12 <[exa]> oic
08:10:32 <[exa]> good, thanks a lot, gonna dive to it
08:10:35 <sm> reflex has users who speak highly of it. miso is newer
08:10:54 <sm> let us know how you get on
08:11:54 * hackagebot hsexif 0.6.1.2 – EXIF handling library in pure Haskell – https://hackage.haskell.org/package/hsexif
08:13:13 <Cale> sm: Well, "reflex" is the FRP package, "reflex-dom" is a layer on top of that which controls the contents of the DOM.
08:13:44 <sm> oops, right you are
08:14:38 <Cale> Also, I can very much vouch for reflex and reflex-dom being really top notch. However, not all of the tutorials we'd like to write are written yet, so do ask for help on #reflex-frp :)
08:15:36 <Cale> Oh, and if you want to try it out, or really, if you want to try anything related to ghcjs, I would highly recommend using reflex-platform
08:15:45 <Cale> https://github.com/reflex-frp/reflex-platform
08:16:26 <Cale> You can clone this repo and run ./try-reflex and it will download a bunch of stuff and drop you into a shell with ghc and ghcjs, reflex and reflex-dom installed
08:17:36 <Cale> see also https://github.com/reflex-frp/reflex-platform/blob/develop/HACKING.md
08:19:14 <[exa]> Cale: that seems superuseful, thanks
08:19:22 <Cale> (that discusses the ./work-on script which you can use to automatically get a shell with the dependencies for your project)
08:31:02 * hackagebot serokell-util 0.2.0.0 – General-purpose functions by Serokell – https://hackage.haskell.org/package/serokell-util
08:36:39 <hansel_gretel> I have a type
08:36:42 <hansel_gretel> Data Foo = ...
08:36:49 <hansel_gretel> and I have another type
08:37:06 <hansel_gretel> Data Bar = Foo Foo | Number Integer
08:37:38 <hansel_gretel> Is there a way to automatically "lift" Foos into Bar?
08:38:22 <hansel_gretel> Currently I have a long literal of type [Bar], like so:
08:38:25 <glguy> You could make a typeclass for things that can be "lifted" to Bar
08:38:36 <glguy> but Haskell doesn't have subtyping for datatypes
08:39:03 <hansel_gretel> [Number 2, Number 4, Foo <Foo 1>, Foo <Foo 2>, Foo <Foo 3>, ...]
08:39:32 <hansel_gretel> constantly having to prefix every Foo with a Foo constructor to turn it into a Bar creates a lot of clutter and is cumbersome
08:40:04 <hansel_gretel> I would like to somehow tell the compiler: When you see a Foo in a context where a Bar is needed, simply apply Bar's Foo constructor to turn the Foo into a Bar
08:40:12 <hansel_gretel> Is there a way to do this?
08:40:38 <geekosaur> Haskell only provides that for literals, and even then only in limited circumstances (by default only numbers)
08:40:58 <glguy> hansel_gretel: No, you can't do that
08:41:43 <Boarders> you could just make a shorter named function like f that turns a foo into a bar, then you only have to type f
08:41:51 <glguy> Instead of writing:    Foo (MkFoo x y z)  you could write   foo x y z
08:42:13 <hansel_gretel> glguy: yeah, but it's still kind of ugly ;)
08:42:36 <hansel_gretel> glguy: What would the typeclass approach look like?
08:42:48 <geekosaur> strict typing kinda precludes this kind of thing
08:43:56 <glguy> hansel_gretel: class FromFoo a where foo :: Field1 -> Field2 -> a; with instance FromFoo Foo and instance FromFoo Bar
08:44:08 <glguy> so you could use the same method for making values with type Bar and Foo
08:44:43 <ahihi> geekosaur: it's not impossible, e.g. scala lets you define implicit conversions
08:44:49 <ahihi> whether it's a good idea is another matter ;)
08:46:55 <hansel_gretel> So is the consensus that I should just suck it up and keep prefixing my Foos with Foo?
08:48:54 <ahihi> I think I'd go for glguy's first suggestion
09:00:38 <nshepperd_> MagneticDuck: if you're on linux, install https://github.com/rfjakob/earlyoom so that your memory devouring program will be killed before breaking the machine
09:02:31 <nshepperd_> I don't understand why desktop Linux still defaults to "thrash the hdd until you reset the machine" but there you go
09:02:57 <Athas> Even Windows is not that crap, is it?
09:03:35 <Athas> Actually, I don't mind that the OOM killer is a last resort, but why on Earth does Linux start swapping out my X server, Emacs, and other things instead of the program that uses memory?
09:04:13 <geekosaur> ever run windows in a tiny vm? it very much does do that
09:04:28 <ongy> probably because the application using that memory has more hot memory than X
09:05:07 <geekosaur> ^ it pages out least recently used pages, your program is likely to have all the recently used pages
09:05:48 <ongy> hm, does nice influence swapping?
09:14:09 <Athas> geekosaur: that is a poor strategy for at desktop system.
09:15:05 <geekosaur> it's actually a good strategy most of the time; programs very often have a significant amount of code that runs only at startup and never again, and that code gets flushed from memory
09:15:07 <Athas> It pretty much guarantees that a program in a space-consuming will trash the system.
09:15:42 <Athas> Sure, I'm arguing that a process that uses a disproportionate amount of memory should swap out *itself* before things related to system responsivity.
09:15:44 <nshepperd_> It's a poor strategy for any system, if the least recently used page was actually used very recently
09:15:58 <geekosaur> the problem is that the demand paging subsystem generally can't associate pages with programs over time to determine that some particular program has suddenly started bloating
09:16:05 <Athas> There is likely nothing more important for a desktop/single-user system than responsivity.
09:16:20 <geekosaur> and adding the metadata to make that fast has both performance and memory costs
09:18:29 <Athas> Doesn't macOS handle this?
09:18:44 <Athas> I can't imagine systems designed primarily for desktop usage would exhibit this behaviour.
09:18:53 <lyxia> hansel_gretel: what about (Number <$> [2, 4]) ++ (Foo <$> [<Foo1>, ...])
09:18:57 <Athas> It seems like a throughput-optimised logic.
09:19:28 <lyxia> hansel_gretel: or is there a lot of interleaving in your actual lists
09:20:11 <geekosaur> Athas, memory pages have MMU assistance in the normal direction. To detect this, you need to keep an *inverse* page table as well, and update it --- manually, the MMU will not help you --- every time you move a page
09:22:23 <Athas> geekosaur: you have an ASID for every page, right?  That could be used to prefer swapping out pages from the same address space that is being allocated a page for.
09:22:33 <Athas> At least, that's how I'd do it in the Unix-style kernels I've written.
09:22:54 <geekosaur> sure, and now programs that allocate moderately thrash against themselves
09:23:06 <Athas> A nicer way would probably be to have a notion of whether a process is a "systems process" or an "interactive process", and built that into the heuristics.
09:23:12 <geekosaur> and iirc an early linux tried this and found (a) the inverse table took up a fair chunk of non-swappable kernel memory (b) keeping it up to date made allocation 3-4x slower
09:23:16 <Athas> Surely they'll only thrash if you actually run out of free memory?
09:23:33 <geekosaur> er, tried the inverse page table
09:24:26 <nshepperd> i'm not sure that the problem is that X gets swapped out so much as that it gets repeatedly swapped out and in again in every context switch
09:24:36 <nshepperd> that kills throughput as well as responsivity
09:24:44 <Athas> I am pretty sure Windows used to behave reasonably under swapping conditions, because they used to be pretty common.  (But I haven't used Windows for ten years.)  I know that on my current Linux, Xorg becomes almost entirely unresponsive as soon as GHC runs out of physical memory.
09:24:47 <geekosaur> except there's a balance between pages that are file cache, pages that are program data, etc. and Linux is notorious for being unable to find a decent balance, so it tends to thrash sooner than e.g. freebsd or os x
09:24:54 <Athas> The system console still generally works fine, though.
09:25:57 <AndreasK> If you have more hot pages than available memory whatever you do sucks in one way or another. Probably happens rarely enough for the average user that "do the easiest thing" is a ok choice.
09:26:32 <jonreeve> So I'm super new to haskell, and want to try making a website with Hakyll. I ran `stack install hakyll` successfully, but when I try to install `hakyll-sass`, I'm told: 
09:26:34 <Athas> I just tend to turn off swap when doing Haskell hacking.
09:26:36 <jonreeve> In the dependencies for hakyll-sass-0.2.3:
09:26:38 <jonreeve>     aeson-pretty-0.7.2 must match >=0.8 (latest applicable is 0.8.5)
09:26:40 <jonreeve> needed for unknown reason - stack invariant violated.
09:27:07 <jonreeve> Does anyone know how I can get these dependencies sorted out so I can install both of these packages? 
09:27:12 <geekosaur> anyway I suspect a bigger part of the answer is the linux memory folks finding their butts and writing memory management on a par with non-linux
09:27:46 <nshepperd> turning off swap doesn't help, it can still drop code pages because they are on disk
09:27:54 <geekosaur> freebsd solved this some time back, albeit with occasional glitches (like 6-current iirc...)
09:28:02 <nshepperd> like i said, install earlyoom :)
09:29:12 <nshepperd> AndreasK: i think you should immediately call the oom killer in that case
09:29:17 <geekosaur> jonreeve, usually that error means it needs a newer resolver
09:29:28 <nshepperd> no-one wants to run 1000x slower, not even on a server...
09:29:56 <geekosaur> although "stack invariant violated" sounds like you may have also triggered a bug in stack
09:30:34 <geekosaur> ...or, your version of stack is ancient (some distribution-installed versions are way too old)
09:30:44 <AndreasK> nshepperd: The issue with that from the OS perspective is that you don't really now if a page is still hot. You can only guess and I will just assume if that were easy it would already be done
09:32:41 * mbrock finds after profiling his refactoring on a benchmark that it's caused the Gen 0 GC elapsed time to go from 2s to 7s, and Gen 1 from 7s to 10s...
09:32:49 <geekosaur> oh, it's easy enough. force a page fault on every page access.
09:32:54 <geekosaur> your performance will TANK
09:33:29 <jonreeve> geekosaur: I'm using stack 1.5.0, is that old? 
09:33:39 <jonreeve> Maybe I can just remove my whole .stack folder and try to start from scratch
09:34:26 <AndreasK> If you guess low on the number of hot pages you still thrash, if you guess too high you kill them too early. Maybe an option to invoke the oom killer if trashing itself is detected could work
09:35:16 <geekosaur> jonreeve, looks very recent (like, 3 days). so I have to guess a newly introduced bug
09:38:52 <nshepperd> AndreasK: i feel like it should be easy with some statistic analysis of how recently each page was used (and you should have such info given that you are paging out the "least recently used", right?)
09:40:22 <nshepperd> also, killing too early isn't that much of a problem. I use earlyoom which is waaay more eager to kill programs than something like this would be, and in practice the user experience with it running is great
09:40:25 <geekosaur> unfortunately not, see my snark above about page faulting on every access
09:40:42 <nshepperd> 0 false positives
09:41:12 <geekosaur> LRU actually means "least recently loaded into memory" and the metadata is just some pointers forming a queue
09:44:49 * hackagebot composite-aeson 0.5.0.0, composite-aeson-refined 0.5.0.0, composite-base 0.5.0.0, composite-ekg 0.5.0.0, … and 1 more
09:44:49 * hackagebot  → https://hackage.haskell.org/packages/recent
09:45:16 <geekosaur> jonreeve, anyway if that "needed for unknown reason - stack invariant violated." was actually output from stack, it sounds like a bug --- https://github.com/commercialhaskell/stack/issues
09:52:43 <joeyh> anyone know of a way to get the major number of a block device in haskell? It's there in FileStatus, but I don't see a way to get it out
09:53:13 <tabaqui> :t traverse (\x -> (x, 2)) $ Just 1
09:53:14 <lambdabot> (Num t, Num b, Monoid t) => (t, Maybe b)
09:53:21 <tabaqui> why Monoid is here?
09:53:22 <[exa]> Cale: best thing about reflex-platform is that it prints out the simple hello-world usage right after getting installed, all platforms should have this
09:53:25 * joeyh checks and finds ont other time I worked around there not being a good way to do this. Meh
09:53:44 <tabaqui> I cannot see the word "Monoid" in Applicative and Traversable definition
09:54:03 <tabaqui> Applicative implies Functor, but it doesn't requere the one
09:54:56 <tabaqui> traverse returns Applicative combined with Traversable
09:55:07 <lyxia> tabaqui: instance Monoid t => Applicative ((,) t)
09:55:11 <AndreasK> nshepperd: Even IF you know recently used pages + times you can't guarantee they will be used again. It's still just a guess (even if a reasonably good one). If you know you won't get close to your memory limit something like earlyoom seems like a reasonable approach.
09:55:36 <tabaqui> lyxia: base-4.10.0: class Functor f => Applicative f where
09:55:50 <lyxia> tabaqui: I mean the instance for the pair type
09:55:57 <lyxia> tabaqui: not the class definition
09:56:10 <nshepperd> AndreasK: guesses are fine. a thousand guesses added up makes one good estimate
09:56:15 <tabaqui> lyxia: ah, yes, I'm blind
09:56:17 <tabaqui> thanks
09:56:30 <AndreasK> nshepperd: But to me trashing seems to be a safer approach for a default config. (And even when I got into thrashing it never was bad enough that I couldn't kill the offending process from the console/taskmanger depending on os
09:56:46 <nshepperd> you don't need to know whether this page is hot, just whether the aggregate sum of hot pages is more than you can deal with
09:56:46 <tabaqui> oh, it's not much intuitive though
09:57:04 <tabaqui> mappend by first element and <*> by second
09:57:04 <lyxia> tabaqui: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-338
09:57:06 <tabaqui> brr
09:57:12 <lyxia> it's the Writer monad
09:58:07 <tabaqui> *note for my future self: do not use Applicative tuples
09:58:59 <nshepperd> thrashing, then killing the program from console seems like a strictly worse user experience than just killing the program first :p
09:59:31 <geekosaur> joeyh, https://downloads.haskell.org/~ghc/latest/docs/html/libraries/unix-2.7.2.2/System-Posix-Files.html#v:specialDeviceID and you apparently have to know how the OS defines major vs. minor
10:01:45 <geekosaur> it does seem kinda silly this doesn't include some equivalent of the C macros to deconstruct a dev_t
10:02:00 <joeyh> yeah, IIRC unix won't take PR's for features not in POSIX
10:02:18 <joeyh> unsure where to put such a thing.. A whole library for 3 C marcos seems silly
10:02:31 <WarzoneCommand> question, suppose I have a closed type family Not, is there a way to convince GHC that Not (Not a) ~ a ? 
10:03:25 <geekosaur> WarzoneCommand, not normally, I think people use ghc plugins for similar things (basically inserting that as a constraint where needed)
10:05:51 <tabaqui> WarzoneCommand: look at FunctionalDependencies extension
10:06:27 <tabaqui> you can try to convience type system that instance Correct (Not (Not a)) a
10:07:09 <tabaqui> and you need UndecidableInstances too
10:07:53 <WarzoneCommand> ah, you mean s.t. like: class Correct nna a | nna -> a where convert :: nna -> a = id with the above instance? 
10:08:03 <nshepperd> I wonder if GHC should have some feature to add constraints like that generally. Like you define a top level variable of type 'Not (Not a) :~: a' and it magically brings Not (Not a) ~ a into the global context
10:08:10 <tabaqui> you don't need to define convert
10:08:14 <nshepperd> i bet you could do that with a type checker plugin
10:08:24 <tabaqui> just describe the class and instance without details
10:08:46 <tabaqui> but you've got the idea
10:09:35 <AndreasK> nshepperd: Just as killing a process that wasn't actually trashing or would have stopped to do so after a few sec is worse than just letting them run their course. No strategy will be better for all cases. But avoiding unneccesary data loss seems like a good default and when you know the use case earlyoom can be better certainly.
10:09:44 <nshepperd> (like a lazy pattern match, presumably you would get a runtime exception when needed if the proof term was undefined :: Not (Not a) :~: a)
10:09:47 <WarzoneCommand> hmm let's see if I can get that to wrok :) 
10:10:29 <tsani> I'm getting a bunch of errors such as `/usr/bin/ld: cannot find -lHStime-1.6.0.1` despite the package being installed. Running cabal install with -v and then the GHC command it executes with -v, I found that in the directory in which gcc is searching for libraries, there is libHStime-1.6.0.1-ghc8.0.2.so. Symlinking to libHStime-1.6.0.1.so resolves the "cannot find" error.
10:10:39 <tabaqui> it's High Magic, I never used it by myself
10:10:40 <tsani> Has anyone else experienced this? Is this a GHC bug?
10:10:51 <cocreature> tsani: archlinux?
10:10:54 <tsani> yes
10:10:56 <tabaqui> lol
10:10:57 <nshepperd> tsani: are you using arch linux? welcome to the grim dark future
10:11:03 <tabaqui> hello there
10:11:06 <tsani> oh dear
10:11:20 <cocreature> at some point I’m going to make the maintainer pay me for all the time I’m wasting explaining to people how they can fix their setup
10:11:39 <tabaqui> don't worry, just install stack from the site and use it to build cabal and all libs
10:12:15 <WarzoneCommand> Hmm apparently that is not allowed
10:12:16 <WarzoneCommand>     Illegal type synonym family application in instance: Not (Not b)
10:12:17 <WarzoneCommand>     In the instance declaration for ‘Convert (Not (Not b)) b’
10:12:19 <cocreature> yeah you need a statically linked cabal from somewhere
10:12:34 <cocreature> and then nuke everything Haskell related that you installed via pacman except for ghc and ghc-static
10:12:41 <cocreature> then everything should be working as it did before
10:13:00 <tsani> good god
10:13:04 <tsani> what happened?
10:13:31 <jle`> WarzoneCommand: you could probably write a singletons-based proof for every individual instance b
10:13:45 <jle`> well, it could be any proof, without singletons
10:13:46 <nshepperd> the maintainer switched to dynamic linking, and didn't think about the consequences
10:13:52 <tabaqui> WarzoneCommand: dunnot
10:13:57 <tabaqui> class Correct a b | a -> b
10:14:00 <jle`> WarzoneCommand: it depends on what Not is
10:14:01 <cocreature> the maintainer decided that only shipping dynamic libs is a good idea but GHC links statically by default
10:14:03 <tabaqui> data Not a = Not a
10:14:11 <tabaqui> instance Correct (Not (Not a)) a
10:14:14 <tabaqui> that's all
10:14:18 * tsani sighs
10:14:28 <jle`> tsani: doesn't work if Not is a type family
10:14:42 <tsani> Thanks for the advice folks. I'll try this out.
10:15:02 <jle`> WarzoneCommand: depending on what Not is, you can write a proof of equality that you can pattern match on
10:15:16 <jle`> you'd just have to use it locally every time you need it
10:15:52 <jle`> you can also go the typechecker plugin route too, which is probably the more sane way to do it
10:16:02 <jle`> extend the typechecker to automatically unify Not (Not a) with a
10:16:09 <WarzoneCommand> well, Not is the thing that you would expect it to be. But maybe I can instead use a data type instead like tabaqui suggested 
10:16:46 <jle`> what thing is that?
10:16:58 <WarzoneCommand> type family Not (b :: Bool) where Not True = False Not False = True
10:17:11 <jle`> ah that's definitely Not what I was expecting
10:17:22 <cocreature> tsani: fwiw I can upload a statically linked version of cabal for archlinux 64bit if you don’t want to figure out how to get one yourself. (obviously that would entail “running binaries that a stranger on the internet sends you” so I can understand if you want to avoid that :))
10:17:28 <jle`> typically when you see Not a at the type evel it's a -> Void
10:18:09 <jle`> WarzoneCommand: if that's your type family then you can just write the proof yourself
10:18:16 <jle`> and bring it into scope
10:18:19 <cocreature> I guess you could also use the bootstrap script provided by cabal
10:18:27 <jle`> using 'gcast' from Data.Reflection
10:18:34 <jle`> er sorry
10:18:36 <jle`> Data.Type.Equality
10:19:36 * hackagebot matterhorn 40000.0.1, mattermost-api 40000.0.1, mattermost-api-qc 40000.0.1
10:19:36 * hackagebot  → https://hackage.haskell.org/packages/recent
10:19:50 <jle`> nice that hackagebot squashes updates like that
10:20:12 <tabaqui> cocreature: btw, which libraries are statically included exactly?
10:20:30 <cocreature> tabaqui: included in what?
10:20:31 <tabaqui> my ldd `which cabal` return about ten different system libs
10:20:41 <tabaqui> in cabal
10:20:41 <WarzoneCommand> hmm ok, let me try that :) 
10:20:48 <cocreature> tabaqui: the haskell libraries
10:20:53 <tsani> cocreature: I managed to get stack installed from their script, and now it's chugging away installing cabal with system GHC after I installed ghc-static as well
10:20:54 <tabaqui> ah, ok
10:21:08 <tabaqui> my cabal is statically linked too then
10:21:08 <cocreature> tsani: alright, looks like you’re all set :)
10:21:28 <tabaqui> pacman -Rscn cabal ghc
10:21:31 <tabaqui> all of them
10:21:43 <tabaqui> use only one stack
10:21:51 <tabaqui> stack install cabal-install ghc
10:22:10 <nshepperd> http://lpaste.net/1897527804187115520 for future reference
10:22:18 <tabaqui> *ghc-mod neco-ghc fast-tags and other
10:22:23 <nshepperd> what happened to that lpastebot?
10:23:04 <nshepperd> the above is a PKGBUILD for cabal built with bootstrap.sh
10:23:22 <nshepperd> i've got a ton of such things i should probably put in the aur at some point
10:23:49 <tsani> cocreature: looks like I spoke too soon. It's failing to link due to third-party libs like random and network-uri. The arch packages for these don't include only the dynamic libraries -_-
10:24:56 <cocreature> tsani: stack is failing? can you provide the exact error message?
10:25:36 <lyxia> WarzoneCommand: unfortunately it's not possible to safely get   forall a. Not (Not a) :~: a
10:26:56 <tsani> cocreature: http://lpaste.net/7171480711457669120
10:27:00 <jakehehrlich> It is possible to get forall a. Not (Not a) :~: a if you have built in call/cc
10:27:08 <nshepperd> unsafeCoerce Refl :)
10:27:44 <WarzoneCommand> jakehehrlich: what do you mean with if you have built in call/cc ? 
10:27:56 <jle`> jakehehrlich is referring to a different Not
10:27:56 <nshepperd> tsani: did you remove all of the other haskell related arch packages?
10:28:01 <tsani> cocreature: and `stack setup` says it can't find an installation URL for OS key "linux64-ncurses6-nopie"
10:28:07 <cocreature> tsani: have you modified the stack config? by default it shouldn’t use the system ghc
10:28:16 <lyxia> jakehehrlich: :~: means type equality, rather than equivalence, and it's another Not.
10:28:17 <jakehehrlich> Oh whoops, what Not are we referring to?
10:28:18 <tsani> cocreature: yes I used --system-ghc
10:28:19 <tabaqui> I hate this message "linux64..."
10:28:36 <cocreature> tsani: install ncurses5-compat-libs from the AUR and then use stack setup
10:28:38 <jle`> jakehehrlich: not True = False; not False = True
10:28:41 <tabaqui> you cannot build cross-compile x64->x86 because of it
10:29:08 <jle`> WarzoneCommand: here's an example of doing it with a case-by-case proof http://lpaste.net/357256
10:29:10 <jakehehrlich> Oh. hmm that's an interesting type. Is that a type family? I thought we were referring to a -> Void
10:29:23 <jle`> yeah, it's a type family (Not 'True = 'False, sorry)
10:29:27 <jle`> and yes, i thought so too at first :)
10:30:01 <jle`> WarzoneCommand: in this case you basically enumerate through all possible Bool's and show that Not (Not a) for every possible bool 'a' is a
10:30:14 <jle`> it's kind of unsatisfying because it'd be nice if we can prove it without enumering through the universe of Bools
10:30:15 <ongy> nshepperd: you probably should put it on the aur :) I put way to much time into the weird hack that's currently on there...
10:31:00 <jakehehrlich> jle`: is there a way to specify the kind that contains exactly True and False?
10:31:21 <jakehehrlich> Oh wait nvm were lifting True and False to types not defining new ones
10:31:22 <jle`> yes, Bool is that kind
10:31:23 <WarzoneCommand> jle`: thanks :). 
10:31:32 <jle`> :)
10:31:55 <jakehehrlich> forall a :: Bool. Not (Not a) :~: a *does* exists...Got ya
10:32:28 <jle`> WarzoneCommand: no problem, hope it works in your situation
10:32:29 <lyxia> does it
10:32:29 <jakehehrlich> Does Not have kind Bool -> *? If so that's the most general thing you could have hopped for
10:32:38 <jle`> Not :: Bool -> Bool
10:32:54 * shapr hops for Haskell
10:32:56 <jle`> since it returns 'False for Not 'True
10:33:05 <jle`> and 'False :: Bool
10:33:34 <jakehehrlich> Right, makes sense. So forall a :: Bool. Not (Not a) :~: a was the most general thing that made sense in the first place anyway
10:33:43 <jle`> that's the thing that makes sense
10:33:51 <jle`> but unfortunately it's not the thing i was able to give
10:34:04 <WarzoneCommand> jle`: hmm yeah me to. Trying to figure out if that is the case now :) 
10:34:54 <machinedgod> Hi everyone. Could you please suggest me a nice HTML parsing library? I spent time trying to get Taggy to work, only to realize 5 minutes ago it fails on html void elements
10:35:16 <machinedgod> Too bad, I really liked Taggy, but someone reported this on github back in 2015 and still not resolved
10:37:06 <lyxia> I've used tagsoup but it doesn't give you a tree
10:38:58 <lyxia> xmlhtml seems to be the most promising
10:40:11 <kmc_> Hi, I have gotten through most of the Miran Lipovaca book, and kinda put away Haskell for a moment. Now I'm taking a linear algebra refresher course, and have to implement a (basic) linear algebra library. I can't remember, but how does one make a N length vector? I feel like I want something like (Vec a = Vec (Tuple a)) but im not sure how to do that
10:41:29 <machinedgod> lyxia: thanks for the tip, I'll give it a go! I can probably make things work without a tree, as long as the html gets parsed out right
10:41:50 <machinedgod> piratebay's html is (excluding error's) quite simple and readable (:-D)
10:44:37 <lyxia> kmc_: is N supposed to be part of the type?
10:45:28 <nshepperd> normally you would prove 'forall a :: Bool. Not (Not a) :~: a' by case analysis
10:45:48 <nshepperd> Not (Not True) is True and Not (Not False) is False
10:46:22 <nshepperd> can't do that in haskell though, because that forall is an 'irrelevant quantifier
10:46:57 <kmc_> I'm sure it could be, like you could make a 3d vector by doing Vector 3 Float. It's kind of a course where you get to decide. I was thinking that it would be easier to do something like Vector 1 2 3 4 5 and it deals with N behind the scenes
10:47:22 <jle`> kmc_: there are some n length vector libraries out there
10:47:38 <jle`> WarzoneCommand: oh you can probably get `forall a. Not (Not a) :~: a` by using unsafeCoerce
10:47:43 <jle`> which should technically be "ok"
10:47:49 <jle`> since you prove it by hand that it's true
10:47:49 <kmc_> I mentioned in my earlier comment that I'm trying to implement it for a linear algebra refresher course
10:47:58 <lyxia> kmc_: https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015
10:48:00 <nshepperd> you can define a singleton GADT like data SBool a where { STrue :: SBool True; SFalse SBool False} and then write 'forall a :: Bool. KnownBool a => Not (Not a) :~: a'
10:48:11 <nshepperd> that lets you do case analysis
10:48:16 <lyxia> jle`: heh that's your blog!
10:48:20 <jle`> yeah that's what i did in my paste above more or less
10:48:27 <nshepperd> or... simply write unsafeCoerce Refl and make the compiler trust you
10:48:44 <jle`> oh that post is kind of outdated, i'm a bit embarassed by it heh.  thanks for reminding me to update it
10:49:10 <jle`> kmc_: you can implement your linear algebra library on top of an n-length-vector type
10:49:14 <jle`> like in the 'vector-sized' library
10:49:30 <kmc_> oh good point
10:50:00 <jle`> they have `Vector 3 Double`, which is a vector of 3 doubles
10:50:23 <WarzoneCommand> jle`: yeah ok, but I think its nicer to do it properly 
10:50:40 <jle`> it basically implements it by using unsized vectors (from the venerable vector package) and adding smart constructors
10:51:36 <WarzoneCommand> maybe one last question. Should I be able to construct a 'Sing a' instance if I'm given a Proxy a ?
10:51:45 <kmc_> Nice, just out of curiosity, is it possible to implement syntactic sugar for your data types? Like can I make something where <1, 2, 3> would create a Vector 3 Int?
10:52:29 <jle`> WarzoneCommand: no
10:52:29 <WarzoneCommand> I started out all of this because I didn't want to have (Not (Not a) ~ a) as a constraint in my type sig. Having (SingI a) in it is not much better 
10:52:38 <kmc_> I remember being able to make your own operators, I'm assuming you have to do something similar
10:52:48 <geekosaur> kmc, not as such
10:53:07 <jle`> WarzoneCommand: `Sing a` is basically a run-time representation of the Bool that 'a' is
10:53:18 <geekosaur> kmc_, you may be interested in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-lists
10:53:21 <nshepperd> in practice i would use unsafeCoerce Refl, or write a type checker plugin
10:53:22 <jle`> WarzoneCommand: `Proxy a`, at runtime, doesn't have anything attached to it
10:53:28 <nshepperd> to avoid all this verbose proof carrying
10:53:43 <geekosaur> alternately there's quasiquoters, but that has its own overhead and issues.
10:53:49 <kmc_> thanks I'll check it out geekosaur!
10:53:52 <kmc_> brb
10:53:55 <WarzoneCommand> hmm
10:53:56 <WarzoneCommand> :(
10:54:21 <jle`> basically `SingI a => Not (Not a) :~: a` is a reference for a *given* 'a'
10:54:29 <jle`> *a proof
10:55:17 <jle`> kmc_: there are some neat ways to do that though
10:55:21 <jle`> just not with that exact syntax
10:55:41 <WarzoneCommand> hmm I guess I'll go for the unsafeCoerce option then :( 
10:55:58 <jle`> WarzoneCommand: for what it's worth, it's basically like using `head [1,2,3]`
10:56:01 <jle`> or `fromJust (Just 10)`
10:56:22 <jle`> you already know the 'answer' so you know nothing will happen
10:56:41 <jle`> but GHC just can't take advantage of that fact for you, you provide the assurance yourself
10:56:45 <jle`> (in your head)
10:57:08 <WarzoneCommand> yeah I know. Still, it would have been nice to convince GHC of it 
10:57:22 <jle`> unsafeCoerce is your way of convincing ghc ;)
10:58:59 <WarzoneCommand> hehe
11:04:06 <Hafydd> unsafeCoerce Rofl
11:04:59 * geekosaur wants to turn that into a Refl joke...
11:05:59 * hackagebot haskell-conll 0.1.0.1 – Core Types for NLP – https://hackage.haskell.org/package/haskell-conll
11:05:59 * hackagebot haskell-conll 0.1.0.0 – Core Types for NLP – https://hackage.haskell.org/package/haskell-conll
11:07:11 <byorgey> what does a type theorist say when they realize that a joke is the same as another very funny joke they have heard before?
11:07:57 <byorgey> that was my best try.  I don't think it's actually very funny =)
11:09:16 <dogui> is there a way to have "deriving Show" ignore certain fields of my constructor (which are not printable)?
11:10:13 <ongy> you could make a pseudo show instance that just prints "{}" or "XXX" for that and derive like normal (maybe there's a better way, but I don't know one)
11:10:34 <Hafydd> I prefer _, myself.
11:11:01 <jle`> be careful not to create any orphans
11:11:11 <byorgey> dogui: not that I know of, unfortunately.  I have dealt with that in the past by wrapping the unprintable fields in newtypes for which I make Show instances, then deriving Show for the rest
11:11:40 <dogui> ongy: thing is these are functions, so ny declaration would be illegal
11:11:52 <byorgey> it's definitely a hack.  but pattern synonyms can help.
11:11:59 <dogui> ongy: Ah, or maybe you're suggesting to wrap them as byorgey is saying :)
11:12:04 <dogui> thanks, I think I'll do that
11:12:12 <Hafydd> Why would the fact that they are functions make the declaration illegal?
11:12:25 <Hafydd> (If you use FlexibleInstances.)
11:12:58 <dogui> I usually try to not turn on extensions, but I guess they're pretty standard
11:13:12 <jle`> FlexibleInstances is as standard as it gets
11:13:15 <ongy> there's some I would avoid not turning on :)
11:13:16 <Hafydd> Anyway, it's certainly undesirable to do that.
11:13:23 <Hafydd> If not Illegal.
11:13:27 <byorgey> whether it's illegal or not, making a Show instance for an actual function type would still make me feel icky
11:13:33 <jle`> but yes don't write orphan instances
11:13:46 <byorgey> which is why I wrap in a newtype.
11:13:59 <Hafydd> I wrote a Show instance for Show a => Show (() -> a) earlier, which I thought quite reasonable.
11:14:15 <jle`> hopefully it was for an application
11:14:17 <jle`> and not a library?
11:14:20 <dogui> right, this all makes sense. thanks guys!
11:14:23 <Hafydd> Yes, it was for an application.
11:14:24 <glguy> I've you're going to have a show isntance for functions, import http://hackage.haskell.org/package/base-4.10.0.0/docs/Text-Show-Functions.html
11:14:40 <Hafydd> For a test, in fact.
11:14:53 <jle`> dogui: but yes for what it's worth, FlexibleINstances and FlexibleConstraints is very standard and probably should have been a part of the original haskell spec anyway
11:15:11 <jle`> they are as "why wasn't this in haskell" as TupleSections
11:15:56 <jle`> (unrelated to your problem at the moment though, sorry)
11:16:06 <Hafydd> Those will probably be in Haskell2020, thankfully.
11:16:23 <dogui> jle`: haha, no worries, this is much appreciated
11:16:30 <Hafydd> (TupleSections, not FlexibleInstances AFAIK.)
11:18:38 <dmwit> Hafydd: That `Show` instance is also available from `universe`, if you like.
11:18:53 * hackagebot syntaxnet-haskell 0.1.1.0 – Working with Google's SyntaxNet output files - CoNLL, Tree – https://hackage.haskell.org/package/syntaxnet-haskell
11:19:33 <dmwit> Hafydd: http://hackage.haskell.org/package/universe-reverse-instances-1.0/docs/Data-Universe-Instances-Show.html for just that instance, or http://hackage.haskell.org/package/universe-1.0/docs/Data-Universe-Instances-Reverse.html for all of Eq, Ord, Show, Read, Traversable.
11:23:24 <jle`> cute
11:23:50 <jle`> especially that Traversable instance
11:27:34 <Hafydd> Nice.
11:28:01 <Hafydd> I always wanted a data type for representing the Universe.
11:55:50 <hololeap> i notice that a lot of functors have three different states: holding multiple values, holding a single value, and holding no value. is there a class that represents this?
11:57:51 <c_wraith> hololeap, you missed a very important class: producing values without holding them. 
11:58:18 <c_wraith> hololeap, that describes things like Reader, State, IO, etc 
12:01:04 <mizu_no_oto> c_wraith: you can think of Reader r a as holding as many values as there are distinct 'r's - it's a (really, really) lazy Map from r to a.  
12:01:56 <Hafydd> It's no lazier than any other map :: r -> a/
12:02:22 <c_wraith> mizu_no_oto, but at the implementation level, there is no requirement that a value of type a was ever present in the construction. 
12:07:33 <mizu_no_oto> c_wraith: sure, but it has to be able to produce them on demand.
12:09:01 <c_wraith> yes, that's where I started. it produces them, not stores them. 
12:09:20 <c_wraith> who is running lambdabot these days, anyway? 
12:12:33 <hololeap> i'm not saying that all functors have this property, but quite a few do, and i was wondering if this idea was captured in a class.
12:13:15 <c_wraith> what use would such a class be? 
12:13:33 <c_wraith> how could you abstract over that distinction? 
12:13:37 <srhb> Ostensibly it would be "more specific" / "less general" than Functor, but I'm not sure what that would mean.
12:13:51 <srhb> (or if it would be of any use whatsoever)
12:14:39 <hololeap> like, instance MultiStated [] where (toMulti [] = Empty) (toMulti [x] = Single x) (toMulti xs = Multi xs)
12:15:16 <c_wraith> you're sort of describing a weird version of Foldable 
12:16:26 <c_wraith> as a transformation like that is pretty easy with foldMap
12:17:14 <hololeap> hmm, ok i can sort of see that. the reason why i wanted to know is because i was working on a function that compresses parts of a tree that have a single branch with more tree attached, and i thought the idea could be generalized
12:17:53 <hololeap> but it could be done with toList instead of toMulti
12:18:53 * hackagebot data-accessor-template 0.2.1.14 – Utilities for accessing and manipulating fields of records – https://hackage.haskell.org/package/data-accessor-template
12:20:53 <hololeap> something like this: https://gist.github.com/anonymous/ce06d99fbc67a023ba5eb5c657683119
12:21:06 <hololeap> i just felt like it was too simple of an idea for it to not already have a name
12:22:04 <crucify_me> hi please explain what's happening here https://ptpb.pw/ZA4z
12:23:33 <c_wraith> crucify_me, where are you getting lost? 
12:24:15 <crucify_me> c_wraith, curry :: ((t1, t2) -> t) -> t1 -> t2 -> t 
12:24:55 <lyxia> hololeap: I don't think it has a name. You can simplify toMulti to tell you only whether f is a singleton though.
12:24:58 <crucify_me> what does curry do in the definition? (lost on first line
12:25:02 <c_wraith> are you having trouble with what that means, or how it decides that is the type? (or both could be the case, I suppose) 
12:25:03 <crucify_me> )
12:25:16 <crucify_me> yeah thanks both
12:25:44 <statusbot> Maintenance update: Restarting hackage daemon... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/597b8ccdd537a2a70500036a
12:25:53 <crucify_me> curry is taking any func that has two args I assume c_wraith 
12:26:31 <hololeap> sorry that first link was screwed up: https://gist.github.com/hololeap/87e7313a65e0e9e2e7cf149df1022611
12:26:48 <hololeap> basically, the idea is removing extraneous structure
12:26:51 <c_wraith> crucify_me, you see how when it uses f in the definition, it creates a pair to pass to it? 
12:28:01 <c_wraith> crucify_me, or should I be backing up further to haskell syntax for function calls? (parens and commas are not part of the syntax for haskell function calls) 
12:28:18 <lyxia> hololeap: my previous suggestion still stands
12:29:08 <nek0> hi folks. I need some help.
12:29:18 <crucify_me> yes it creates a pair , a tuple right of the = c_wraith  ?
12:29:33 <c_wraith> crucify_me, yes, that's correct 
12:30:03 <nek0> after rebuilding the sandbox of a project, cabal fails with the message "internal error: could not construct a valid install plan.".
12:30:09 <crucify_me> so it's creating a tuple, explicitly for some reason
12:30:22 <nek0> is this a Problem on my side or is it a cabal bug?
12:30:57 <crucify_me> so what part of the type declaration describes the tuple part c_wraith 
12:30:59 <crucify_me> ?
12:31:06 <statusbot> Maintenance update: Hackage up & operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/597b8ccdd537a2a70500036a
12:31:37 <c_wraith> crucify_me, look for the only comma in the type of curry. that's where the tuple fits in. 
12:32:27 <crucify_me> ok, got that
12:33:08 <hexagoxel> nek0: did you clean/configure/build? which command fails?
12:33:42 <c_wraith> crucify_me, you can think of curry as a function that transforms another function. it takes a function that requires a pair, and returns the equivalent function that takes two arguments instead. 
12:33:49 <nek0> hexagoxel: "cabal install --only dependencies" fails after i deleted the sandbox and reinitialized it.
12:33:54 <c_wraith> crucify_me, does that make any sense at all? 
12:34:37 <lyxia> nek0: is it not spelt --only-dependencies
12:34:42 <crucify_me> btw I'm at a stage where the two character names still throw me off  .. c_wraith  oh please hold on thanks
12:34:59 <crucify_me> like t1 
12:35:05 <c_wraith> crucify_me, ah, yes. t and t1 are not great names. :) 
12:35:07 <nek0> lyxia: yes. sry. typo here in chat.
12:35:19 <c_wraith> crucify_me, that's what ghc picks when you let it choose. :) 
12:35:31 <c_wraith> :t curry
12:35:32 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:35:44 <c_wraith> crucify_me, do those type names make more sense? 
12:36:03 <lyxia> nek0: when was the last time you built your project successfully
12:36:28 <crucify_me> c_wraith, yes, but if you have time, I'd really appreciate if we could look at this with some meat, like a simple math example
12:36:33 <hexagoxel> nek0: "internal error" makes it at least a cabal bug
12:36:35 <nek0> lyxia: some time ago. could be some weeks.
12:37:26 <crucify_me> the textbook forces me to always think with single letters, instead of programs that return values
12:37:35 <c_wraith> crucify_me, I don't have time to really dig in now, but someone else probably does. ask a follow up question. someone will probably answer. :) 
12:37:45 <crucify_me> thanks !
12:38:45 * hackagebot fltkhs 0.5.3.5 – FLTK bindings – https://hackage.haskell.org/package/fltkhs
12:38:45 * hackagebot youtube 0.2.1.1 – Upload video to YouTube via YouTube API – https://hackage.haskell.org/package/youtube
12:39:56 <nek0> hexagoxel: should I file an issue on top of that over 800 other issues on github?
12:40:40 <lyxia> nek0: can you paste the rest of the message
12:40:50 <hexagoxel> nek0: is the code public? also, the next thing to look at would be the verbose cabal output
12:42:35 <nek0> lyxia: the complete error mesage -> http://lpaste.net/357261
12:43:21 <nek0> hexagoxel: You can grab my code from here -> https://github.com/nek0/eidolon
12:46:06 <trigone> hi, are kleisli arrows forming a category in haskell? in which case, can (.) be used instead of (>=>)?
12:46:23 <R0b0t1`> Hi
12:46:29 <R0b0t1`> I am trying to bootstrap GHC
12:46:32 <R0b0t1`> It tells me I need GHC
12:46:45 <R0b0t1`> Where can I download only GHC?
12:47:14 <srhb> R0b0t1` https://www.haskell.org/ghc
12:48:56 <lyxia> trigone: Kleisli is an instance of Category, but you need to wrap arrows.
12:49:19 <R0b0t1`> srhb: Thanks
12:49:39 <R0b0t1`> In general I am kind of annoyed that most Haskell projects are very circular and do not expect users to build it themselves
12:49:44 <R0b0t1`> That's at no one in particular
12:49:48 <byorgey> > runKleisli (Kleisli (\x -> [x,x+1]) . (Kleisli (\x -> [10*x,20*x]))) 4
12:49:51 <lambdabot>  error:
12:49:51 <lambdabot>      • Couldn't match expected type ‘b0 -> c0’
12:49:51 <lambdabot>                    with actual type ‘Kleisli [] Integer Integer’
12:50:51 <byorgey> oh! it's using the (.) from Prelude
12:51:13 <byorgey> > runKleisli (Kleisli (\x -> [x,x+1]) Control.Category.. (Kleisli (\x -> [10*x,20*x]))) 4   -- ugh
12:51:15 <lambdabot>  [40,41,80,81]
12:51:22 <byorgey> trigone: ^^^
12:51:28 <trigone> let (.) = Control.Category.(.) in runKleisli (Kleisli (\x -> [x,x+1]) . (Kleisli (\x -> [10*x,20*x]))) 4
12:51:41 <trigone> > let (.) = Control.Category.(.) in runKleisli (Kleisli (\x -> [x,x+1]) . (Kleisli (\x -> [10*x,20*x]))) 4
12:51:43 <lambdabot>  error:
12:51:43 <lambdabot>      Not in scope: data constructor ‘Control.Category’
12:51:43 <lambdabot>      Perhaps you meant variable ‘Control.Category.id’ (imported from Control....
12:51:57 <trigone> oh no parentheses
12:51:57 <geekosaur> (Control.Category..)
12:51:59 <byorgey> trigone: the syntax is  (Control.Category..)
12:52:07 <trigone> weird syntax :P
12:52:09 <byorgey> agreed
12:52:51 <byorgey> most likely if you were using this, you would  import Prelude hiding ((.)) and then import Control.Category.   (.) continues to work for function composition.
12:55:01 <lyxia> nek0: sorry I don't know how tto troubleshoot this cabal problem
12:55:11 <trigone> well... all this wrapping does not really help though... not for usual monadic code...
12:55:29 <nek0> lyxia: no problem. Thanks for trying anyway.
12:55:34 <hexagoxel> nek0: cannot reproduce, assuming some ghc-8.0.* - on a wild guess, could you paste your `ghc-pkg list` output?
12:57:03 <trigone> is there no special class for kleisli arrows, something like category, but the expected type function would include a parameter for a functor or something?
12:57:03 <nek0> hexagoxel: here -> http://lpaste.net/357262
12:57:20 <hexagoxel> nek0: ah, and `cabal update` perhaps..
12:58:14 <trigone> class Kleisli k where (.) :: k m a b -> k m b c -> k m a c
12:58:23 <trigone> maybe it's the class arrow?
12:58:27 <nek0> hexagoxel: THat was my first guess, too. didn't work
12:59:27 * hackagebot gnuplot 0.5.4.2 – 2D and 3D plots using gnuplot – https://hackage.haskell.org/package/gnuplot
12:59:27 * hackagebot propellor 4.6.2 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
13:00:16 <dolio> What would the point of that class be?
13:00:31 <lyxia> nek0: shouldn't cabal *not* see those packages in a sandbox?
13:01:37 <trigone> dolio: hm maybe none...
13:01:51 <hexagoxel> lyxia: right; but ghc-pkg does not see the sandbox.
13:02:37 <lyxia> hexagoxel: His error messages suggest cabal also sees these packages
13:02:38 <hexagoxel> i wonder if the user db confuses cabal, still.. it is at least one thing that differs from over here (my user db is empty)
13:03:40 <skiddieproof> Do irc query 'channels' have a channel ident like #<something> that I could use to remotely connect to one
13:03:54 <hexagoxel> lyxia: to be it seems the error only indicates that the boot libs are seen, and that is necessary/desired, even for sandboxes.
13:04:11 <lyxia> ah ok.
13:05:32 <hexagoxel> nek0: you could try asking in #hackage, too.
13:05:51 <geekosaur> skiddieproof, it'd be the nickname
13:06:42 <geekosaur> skiddieproof, IRC is not as structured as you think; things like channel windows/tabs and query windows/tabs are all in the mind of the client
13:07:07 <geekosaur> a public message to a channel is 100% identical to a /msg to that channel, as far as the protocol is concerned
13:07:09 <Xe> IRC is really just pub/sub with funny rules
13:07:18 <Xe> and a weird framing format
13:07:33 <geekosaur> (or from that channel, incoming)
13:08:03 <skiddieproof> So if I wanted to connect to a lambdabot query chat, your saying I can just use #lambdabot?
13:08:09 <geekosaur> without the #
13:08:24 <skiddieproof> ooh
13:08:29 <skiddieproof> ok ill try it out, thanks!
13:08:39 <geekosaur> again there is NO difference between a message to a channel and a message to a user
13:08:56 <geekosaur> like this
13:09:07 <geekosaur> ...where I typed: /msg #haskell like this
13:09:36 <geekosaur> (most channels will block using /msg like that with a channel you have not /join-ed, as an antispam measure)
13:09:46 <monochrom> If you look at the protocol itself, message "to channel" is "PRIVMSG #haskell xxx yyy" using the very same PRIVMSG command as "private" message.
13:09:53 <geekosaur> yep
13:10:18 <monochrom> And the server chooses whether to honour it or not, of course. But you send that message.
13:10:55 <monochrom> The structure is all in the mind of the server. It decides whom to receive it, how much to broadcast, etc.
13:11:56 * hexagoxel tests whether /ignore #haskell and /part #haskell are the same too.. negative.
13:12:58 <monochrom> /ignore is purely in the mind of the client. The server does nothing.
13:13:12 <monochrom> OTOH, /part is in the mind of the server.
13:14:01 <monochrom> /join requests the server to spam you. /part requests the server to stop spamming you.
13:14:27 <monochrom> So yeah that aspect is a subscribe-then-push-then-unsubscribe thing.
13:23:03 <lamefun> How can I check if GHC optimizes eg. this: http://lpaste.net/1036359519577309184 - into something sane?
13:24:07 <monochrom> I would read the core code (and even asm code if necessary), and/or I would benchmark.
13:25:23 <monochrom> I would also keep in mind that, since this code uses a type class, how this code is compiled in isolation is going to be possibly very different from how this code is compiled in the context of the caller.
13:25:31 <Tuplanolla> Looks like Godbolt's Compiler Explorer has Haskell support now.
13:26:25 <monochrom> To a medium extent, if you don't have the whole program, then you can't draw any conclusion.
13:27:25 * hackagebot synthesizer-core 0.8.1.1 – Audio signal processing coded in Haskell: Low level part – https://hackage.haskell.org/package/synthesizer-core
13:27:25 * hackagebot sox 0.2.2.7 – Play, write, read, convert audio signals using Sox – https://hackage.haskell.org/package/sox
13:29:42 <monochrom> Heh, 8GB of compilers on the compiler explorer.
13:30:56 <Tuplanolla> GHC puts out enough assembly to drown in.
13:31:02 <monochrom> Yeah!
13:31:43 <int-e> just go with the flow?
13:31:45 <monochrom> My secret is to request core code, cmm code, and asm code at the same time. Then use core to guide my way through cmm, then cmm to guide my way through asm.
13:32:24 <monochrom> Because whenever you see "sat_SUV" you really need core to remind you what thunk it is representing.
13:32:30 <AWizzArd> How typical is the use of RWS(T) in realworld code? Is it really used regularily? Or is there something IO-ish which is better suited for practical purposes?
13:32:33 <bbear> Is there some challenge I could try to solve with Haskell ?
13:32:33 <int-e> does the ghc-core program still work? it's unmaintained, it seems :/
13:32:51 <monochrom> And you keep forgetting which register is the heap pointer so you need cmm to remind you that, too.
13:33:37 <monochrom> I don't know. I don't care either. Because there are times even -ddump-simpl is not enough, you have to go -ddump-prep, which no one on hackage does.
13:33:44 <sm> bbear: the advent of code
13:34:21 <monochrom> Speaking of which, even emacs haskell-mode doesn't know to give colouring to *.dump-prep, it only knows *.dump-simpl.
13:34:52 <monochrom> I should file a request. It should be an easy patch. Just add one more filename suffix I guess? It's the same colouring algorithm anyway.
13:36:08 <monochrom> (The difference: -prep is in Launchbury Normal Form, i.e., you won't have "f (g x)", you have "let tmp = g x in f tmp".)
13:36:39 <monochrom> (And it is important because it spells out all allocations of thunks, e.g., "tmp = g x" there.)
13:38:44 <R0b0t1`> Hello, I am trying to build cabal from a checkout of the repository
13:38:48 <R0b0t1`> I have previously installed ghc
13:39:25 <R0b0t1`> It is in my path, and I can run it in my shell - however the ./bootstrap.sh script in cabal/cabal-install reports that ghc is not installed
13:41:27 <R0b0t1`> The line is line 27, and is GHC=${$GHC:-ghc} so I am not sure what is happening
13:44:03 <parazyd> hi. i'm trying to compile a couple of packages but i'm stuck (using gentoo/portage)
13:44:20 <parazyd> what am i supposed to do in case of  Ambiguous interface for ‘Data.Functor.Product’: it was found in multiple package
13:44:50 <joe9> need some ideas, please? I am reading data from stdin and processing it realtime. The initial set of data is large and I want to finish it before doing the realtime loop. I have the stdin reader in a separate thread and it reads stdin, parses and writes to the Q from where it is read by the processing thread.
13:44:56 <parazyd> trying to patch this stuff, but i've been unsuccessful. any thoughts?
13:45:09 <joe9> I want the reader to finish processing all the initial data before heading to the realtime loop.
13:45:25 <joe9> I tried yield; yield; yield and also threadDelay for 1 second.
13:45:40 <joe9> but, all the initial data is still not being read.
13:46:04 <joe9> Is there any way to slurp all the contents on stdin initially and then read it realtime.
13:47:24 <joe9> readerThread: http://bpaste.net/show/0cc9d200ac3b
13:47:41 <joe9> http://bpaste.net/show/89ed6ab30829 initial loop
13:48:08 <joe9> this is how I am starting the reader Thread, http://bpaste.net/show/5246576dff54
13:49:00 <geekosaur> at least one of the terms you have used does not have the meaning I would expect it to have
13:49:26 <joe9> geekosaur: which term, please?
13:49:41 <geekosaur> I *think* "realtime" but I can;t be sure
13:50:01 <joe9> I am reading using tail --follow=name <file> | haskell-process
13:50:22 <geekosaur> because I do not see how "realtime" fits with "read it first"
13:50:26 <joe9> and the <file> that tail is reading from is appended to by another process.
13:50:42 <lyxia> parazyd: which package shows this error
13:50:53 <parazyd> lyxia: distributive-0.4.4
13:51:39 <lyxia> it's very old
13:52:01 <joe9> I have realtime data that is being appended to a file continuously. The haskell process reads a line from the file and outputs it to a display program. This is what it currently does. It takes a lot of time for the display program to catch up when I keep writing updates line-by-line.
13:52:33 <joe9> Instead, at startup, I am trying to read as much data as is available in the file, process it and write it once to the display program.
13:52:48 <joe9> then for each new line, write out only the update.
13:53:16 <parazyd> lyxia: i can try keywording, it would pull 0.5.2 then
13:54:00 <joe9> the display program is a gui that I wrote. and it reads updates, generates image and dislays it. As you know, the image generation and writing to the display device is slow.
13:54:24 <lyxia> parazyd: maybe. Do you also have the versions of the conflicting packages that provide Data.Functor.Product
13:54:30 <joe9> If i can batch my updates, the display program can generate 1 image and show it very quickly.
13:54:43 <joe9> geekosaur: Does that make sense?
13:55:12 <parazyd> lyxia: i've transformers-0.4.3.0 and the conflict is 'base' (which i dunno where it comes from)
13:56:41 <geekosaur> hm, I also have a question continued from your earlier questions about this
13:56:58 <geekosaur> which is, what exactly do you think hIsEOF does?
13:57:28 <lyxia> parazyd: base is the standard library, its version is tied to the compiler. What version is ghc?
13:57:43 <parazyd> lyxia: 8.0.2
13:58:21 <geekosaur> (the only way you know you are at EOF on a handle is if a read returned 0 bytes. it's not something you can check *before* a read)
13:58:31 <joe9> geekosaur: The data coming in is binary. Sometimes I am reading the data from a file and sometimes I am reading from stdin. For example, yesterday's data is already in 1 file, I do not have to read it from a pipe.
13:59:21 <joe9> geekosaur: but, for today's data, it is getting appended continuously and I am reading it in using the tail --follow=name <file> | haskell-process
14:00:01 <joe9> and, I am using the same loop when reading from a file or stdin.
14:00:17 <joe9> the hIsEOF is relevant when I am reading from the file.
14:01:32 <lyxia> parazyd: okay it seems these versions of distributive and ghc are incompatible
14:01:55 <geekosaur> I am wondering if I should bother repeating what I just said, or try to expand on what it means about reading, or just give up and go to bed because this is like the third time today that I point something out and get to watch it soar high over the other person's head
14:02:10 <geekosaur> you are reading from a file
14:02:21 <parazyd> lyxia: i'll see if i can upgrade some things
14:02:43 <geekosaur> hIsEof will be true in one circumstance: after your readTick has read nothing.
14:03:08 <lyxia> parazyd: yeah that seems like the best solution
14:03:11 <geekosaur> if it's not capable of reading nothing then presumably it throws an exception.
14:03:19 <parazyd> lyxia: alright
14:03:20 <geekosaur> in which case hIsEof will never be done
14:03:24 <parazyd> i'll report back :)
14:05:50 <R0b0t1`> Are there instructions for installing cabal to ~/.cabal (I would prefer to install it to ~/.local but there seems to be no option for this) from source?
14:06:37 <R0b0t1`> My current problem is I run ./bootstrap in cabal/cabal-install but it complains there are missing dependencies. I am confused because it seems to refer to Haskell package dependencies. I see nowhere that details which development libraries need to be installed if that is actually the problem.
14:09:29 <R0b0t1`> Here is the error from ./bootstrap.sh: https://paste.pound-python.org/show/wg07ryrJljMWw0HNJumU/
14:09:35 <R0b0t1`> Ah, bother
14:09:43 <geekosaur> joe9, I take it my attempt to explain still did not make sense to you?
14:10:00 <joe9> geekosaur: http://bpaste.net/show/1743098b6ba4 is my readTick function as an fyi. I do not understand what you are saying about hISEOF. I am still trying to read and re-read.
14:10:06 <joe9> geekosaur: sorry for the frustration.
14:10:09 <R0b0t1`> https://paste.pound-python.org/show/wgO7ryrJljMWw0HNJumU/
14:10:21 <geekosaur> I am saying your use of hIsEof is likely the problem
14:10:29 <geekosaur> because you think it detects EOF before EOF has been detected
14:10:33 <joe9> geekosaur: I am reading the hIsEOF docs and I understand that it looks ahead to figure out if there is a next character.
14:10:42 <geekosaur> the thiong that *actually* discovers you are at EOF is not hIsEof
14:11:42 * hackagebot semigroupoids 5.2.1 – Semigroupoids: Category sans id – https://hackage.haskell.org/package/semigroupoids
14:11:47 <monochrom> Wait, hIsEOF actually predicts? Let me check again.
14:12:23 <monochrom> Ah, it says it does.
14:12:28 <geekosaur> urgh
14:12:29 <monochrom> (But I wouldn't count on it.)
14:12:38 <geekosaur> that does not help, if the file is changing
14:12:55 <monochrom> Right, I would rather go ahead and read and catch exception.
14:13:14 <geekosaur> it's basically only safe if the filoe is guaranteed not to be changing while you are reading it. but that is exactly the case you want to use it in
14:13:17 <monochrom> Works uniformly over all languages and their standard libraries.
14:13:35 <geekosaur> and what you will see is it will likely always produce False, then readTick *throws an exception* at EOF
14:13:35 <monochrom> Boolean blindness lifted to the effectful level :)
14:13:46 <joe9> when using hIsEOF I do not even have to catch the exception.
14:14:00 <geekosaur> sigh
14:14:04 <joe9> geekosaur:  but, my issue is not failing with EOF.
14:14:10 <geekosaur> yes, we just said nothing at all
14:14:18 <geekosaur> joe9, please read what we just said
14:14:24 <monochrom> Wow that sounds nice. But let me put my way in sweet wording too.
14:14:39 <geekosaur> the case you are using hIsEof in is the case in which IT IS NOT RELIABLE
14:14:39 <monochrom> When catching exceptions I do not even have to ask hIsEOF!
14:15:04 <monochrom> This is totally half-empty half-full glass of water thing. :)
14:15:44 <monochrom> Anywya, the fun of abusing natural language to support any stance at all.
14:15:45 <joe9> I can change the readTick to catch the isEOFError exception.
14:16:00 <joe9> instead of using hIsEOF.
14:16:02 <geekosaur> never mind, I am incapable of saying anything that anyone else can understand today, apparently. Gone,.
14:16:58 <monochrom> No no, come back! I understand you!
14:17:12 <monochrom> (Although, I suppose "preaching to the choir"...)
14:18:54 <joe9> monochrom: geekosaur: sorry for being so thick. my issue is that I want to figure out if all the data from the handle has been read before moving onto the realtime loop.
14:19:44 <joe9> the EOF stuff seems to work. I am just using it when reading from a file to figure out when to stop the program.
14:19:59 <cht> [([],[])]
14:20:14 <cht> A value of type [([a],[b])] which looks like an owl
14:20:25 <cht> an owl shocked at how readable haskell is
14:20:29 <joe9> I understand that it would not work when reading from stdin.
14:38:55 <SrPx> I'm looking at bruijn levels right now and they look somewhat easier and more elegant than bruijn indexes. Is there any hidden drawback on them that made indexes so much more popular?
14:43:03 <schmidt73> I'm wondering how I should represent an array of 128 word8's safely?
14:43:22 <dmwit> R0b0t1`: Did you get help?
14:43:44 <schmidt73> I have a function that takes an array of 128 word8s as a parameter. But how do I ensure that the long is correct type in a type safe way?
14:43:44 <dmwit> schmidt73: Safe against what problem?
14:44:36 <schmidt73> I wouldn't want someone to call my function with an array of length 127 or 129.
14:44:47 <schmidt73> Then it would be a partial function
14:45:09 <dmwit> I strongly recommend returning a `Maybe`.
14:45:25 <dmwit> However, if you're dead set on avoiding that, there are a few ways forward.
14:45:50 <schmidt73> I know I could return Maybe, but I'd rather not.
14:45:51 <dmwit> You can do the usual type-level arithmetic trickery, and use a length-indexed vector.
14:46:04 <schmidt73> Interesting
14:46:13 <dmwit> Or you can `data Word1024 = Word1024 Word8 Word8 Word8 Word8 ... Word8`.
14:46:32 <schmidt73> Okay thanks.
14:46:37 <parazyd> lyxia: going through somewhat. keyworded a lot of packages
14:46:39 <schmidt73> what do you reccomend?
14:46:54 <schmidt73> I could do data Word128 = Word128 Word64 Word64 or a 2 length indexed vector?
14:46:59 <dmwit> `data Word1024 = Word1024 Word512 Word512; data Word512 = Word512 Word256 Word256; Word256 = Word256 Word128 Word128; ...` is probably more ergonomic.
14:47:16 <schmidt73> Which one is preferred?
14:47:32 <jared-w> With the second approach, you can hide any possible way to make Word1024 except 'valid' ways, then you can accept only Word1024 in your function.
14:48:04 <jared-w> Neither are universally "preferred". I'd say that the data approach is a bit more verbose but definitely easier for people to understand until they get to type-wizard status
14:48:05 <dmwit> schmidt73: Preferences are per-person, per-situation.
14:48:37 <schmidt73> Yeah I'm definitely not at type wizard status
14:48:51 <schmidt73> Thanks for the suggestions.
14:49:22 <dmwit> I think my preferred thing would be to accept arrays of any length; ignore some if it's too long, and use some default value (say 0) if it's too short.
14:50:22 * hackagebot stripe-haskell 2.2.2 – Stripe API for Haskell – https://hackage.haskell.org/package/stripe-haskell
14:50:22 * hackagebot stripe-core 2.2.2 – Stripe API for Haskell - Pure Core – https://hackage.haskell.org/package/stripe-core
14:51:22 <dmwit> data DoubleWord a = DoubleWord a a
14:51:30 <hololeap> are there any security issues intrinsic to haskell that one needs to watch out for, other than blowing your stack?
14:51:54 <dmwit> type Word1024 = DoubleWord (DoubleWord (DoubleWord (DoubleWord (DoubleWord (DoubleWord (DoubleWord Word8)))))) -- ;-)
14:51:58 <monochrom> Be evil! If too short, call up unsafePerformIO for random fillers!
14:52:47 <dmwit> oooo
14:52:50 <dmwit> I have a cunning plan.
14:53:08 <dmwit> Word7 -> Word8
14:54:12 <geekosaur> anyone else just have a flashback to utf7?
14:55:31 * hackagebot stripe-http-streams 2.2.2 – Stripe API for Haskell - http-streams backend – https://hackage.haskell.org/package/stripe-http-streams
14:56:14 <monochrom> No, but I have a flashback to ASCII.
14:56:33 <monochrom> plus using the other 1 bit for "parity check" :)
14:57:08 <dmwit> Right. If the bit is 1, it fails the check.
14:57:22 <dmwit> Nice and simple. Those ASCII guys were thinking ahead.
14:58:30 <geekosaur> stty 50 cs6 cstopb parenb # all set up for baudot
14:58:51 <jared-w> hololeap: you "can't" blow a stack in Haskell
14:59:10 <geekosaur> not in the C way at least
14:59:40 <monochrom> How is blowing the stack a security vulnerability?
14:59:57 <monochrom> I mean, DoS sure. But apart from that?
15:00:57 * hackagebot stripe-tests 2.2.2 – Tests for Stripe API bindings for Haskell – https://hackage.haskell.org/package/stripe-tests
15:01:02 <geekosaur> I think the reference is to overwriting stack variables to change the return address
15:01:29 <geekosaur> which is a time-honored C security hole, usually involving non-length-checked, stack-allocated strings
15:01:46 <slack1256> monochrom: In C, the call stack records where to jump when you finish a call. But also, it grown downwards on statically know sized data types
15:02:00 <slack1256> so in C, naive stack impl can pose security risks
15:02:19 <slack1256> in haskell no, because our stack only exists when evaluating thunks, it doesn't involve a call stack
15:02:24 <geekosaur> and doubly not-defined in Haskell, because (a) all strings are length managed (b) there is no *call* stack to overwrite the retyrn address of
15:02:25 <monochrom> OK so GHC performs index bound checks when pushing to the stack.
15:02:47 <monochrom> Especially since it actually has to tell you "stack overflow".
15:03:30 <hololeap> DoS is part "security," broadly speaking... but i just mean there aren't any security related "gotchas" at the core of the language and how it is implemented in GHC, right?
15:04:04 <hololeap> no null-pointer or buffer-overflow nonsense to worry about? :)
15:04:15 <geekosaur> not in the core.
15:04:28 <geekosaur> if you use the FFI, you get all the lovely C behaviors that come with it
15:04:42 <monochrom> The compiler generates code to do many many array bound checks. (Here "array" means its heap, its stack, ...)
15:04:55 <monochrom> It also simply doesn't have null pointers.
15:05:12 <monochrom> It's either heap overflow or allocation success.
15:05:34 <monochrom> And it needs to know heap overflow because it has to decide to either call up GC or abort.
15:05:45 <monochrom> (Well it attempts GC first before it gives up.)
15:06:07 <hololeap> ok, that's all i needed to kow
15:06:10 <hololeap> *know
15:06:38 <monochrom> But if you use the vector library, you can add your own out-of-bound bugs.
15:07:20 <monochrom> Because unsafeIndex exists and it's exactly the average C's a[i] without checking i.
15:07:33 <hololeap> but unsafe is in the name :)
15:07:56 <slack1256> is there any post explaining the (tentative) relationship between typeclases and backpack modules ?
15:08:13 <slack1256> I remember ezyang saying something about a post, but I can find it in his page
15:10:15 <slack1256> *can't
15:10:50 <monochrom> I plan to read the thesis draft itself.
15:11:14 <monochrom> have been disappointed at all the past talks.
15:11:34 <slack1256> you mean the talks about backpack?
15:11:49 <monochrom> But that's normal. That's how conference talks work. They're 20-minute advertisement to invite you to read the paper or thesis.
15:11:56 <monochrom> Yeah.
15:12:48 <slack1256> Mmm I remember reading some of the papers yet they explicitly avoided such interaction
15:13:12 <slack1256> (I wanna know if we can pass Foldable from a class to a module and still have it as a constrain on Traversable which is a bona finde class)
15:39:39 <trigone> hi, i was wondering if monads were universal in functional languages. if not, how do other languages do to express the things that haskell would express with monads (Maybe, Either, State, Writer, IO...)?
15:40:33 <Tuplanolla> The same way Haskell did before it had monads, for example, trigone.
15:41:12 <Tuplanolla> @google io is not a monad
15:41:13 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
15:42:06 <slack1256> trigone: various alternatives
15:42:23 <trigone> oh i didn't know haskell didn't use monads from the start
15:42:23 <slack1256> you could implement all of the via continuations (a la scheme)
15:43:03 <slack1256> you could introduce a notion of linearity (this resource is used at most once) for IO. That is what the clean language did
15:43:24 <geekosaur> main :: [Response] -> [Request]
15:43:31 <slack1256> Fun fact: during a time, the main way to interact with the outside world was the `interact` function
15:43:35 <slack1256> @type interact
15:43:36 <lambdabot> (String -> String) -> IO ()
15:43:44 <geekosaur> ^ original Haskell I/O. lazy lists. the first Response is argv.
15:45:25 <EvanR> [Response] -> [Request] seems... 
15:45:33 <EvanR> so silly
15:45:40 <bbear> is there a reason why the standard data type in Haskell is the singly linked list ?
15:46:16 <EvanR> its easy to process such a structure lazily
15:46:19 <geekosaur> lisp influence
15:46:31 <slack1256>  has really good sharing propierties, plus is the standard generator :-)
15:47:14 <EvanR> is there a reason why the standard data type in haskell is Int, is the question
15:47:18 <bbear> no special reason like « you can virtually solve anything with singly linked list » ?
15:47:28 <trigone> slack1256: the link is somewhat confusing. i thought nowadays the IO type cons was a wrapper around some sort of state monad?
15:47:48 <EvanR> theres no actual state in IO
15:47:51 <bbear> EvanR: I don't think you can virtually solve anything with just Int but ..
15:47:54 <slack1256> no, in fact you can't solve anything with just lists. That would solve programming once of all
15:48:27 <schmidt73> Can you convert from a mutable vector to a vector outside of the ST monad?
15:48:32 <bbear> EvanR: you think Int are isomorphic to linked lists ?
15:48:34 <slack1256> EvanR: There is a state monad, it just passes a Token for the ordering and not holding state
15:48:41 <EvanR> bbear: standard data type = can virtually solve anything with ?
15:48:56 <trigone> EvanR: from GHC.Types newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:48:57 <bbear> EvanR: at least try to make it easier 
15:49:21 <EvanR> "the" standard data type in haskell is a few types... list, Int, Bool, Data.Map, Maybe, Either
15:49:28 <trigone> don't know what the hashes mean though yet
15:50:04 <EvanR> trigone: its not really a state though... its a hack to get core programs to evaluate in a sane order
15:50:07 <geekosaur> trigone, it's fake state actually. a typechecker hack that vanishes after the typechecker's done, and all it does is ensure I/O effects happen in the specified order
15:50:21 <trigone> ok...
15:50:29 <exio4> it's a GHC-specific hack
15:50:33 <EvanR> you should probably understand IO in terms of a free monad-like thing
15:50:33 <geekosaur> this could be done other ways but ghc's way is simple and effective and goes away by itself
15:50:53 <EvanR> in case you have to implement your own IO one day :)
15:50:54 <geekosaur> the # things represent ghc internals/primitives. often, but not always, it's a primitive unboxed type
15:50:57 <bbear> can we have doubly linked lists ?
15:51:13 <slack1256> bbear: list are popular in haskell for 4 reasons. Lisp influence that showed is good having a single overpowed data type somewhere. List are the simples DAG, thus their sharing is really good. Serves a good generators, and laziness has a motivation of introducing modularity for generators and consumers. and there is no 4th :-)
15:51:17 <ezyang> slack1256: Go ahead and read the introduction of my thesis :) 
15:51:19 <geekosaur> not easily in a functional language. you'd have to figure out how to tie the knot
15:51:34 <EvanR> if you dont need to modify the doubly linked list, its easy
15:51:37 <monochrom> bbear, I contest that. Our list is not the standard data type. It is, to be sure, the go-to data type for many lazy people. However, I would agree that it is our standard control type, e.g., we use "mapM_ (\x -> print (x + 5)) [1..10]" all the time where a C programmer would write a for-loop all the time.
15:51:48 <EvanR> (x, reverse x)
15:51:49 <geekosaur> ^
15:52:11 <monochrom> Our standard data type is you always define your own ADT.
15:52:15 <geekosaur> we are good at making custom data types when we need them. Lists are loops.
15:52:37 <bbear> for lazy people. 
15:52:56 <bbear> you know that I come from python where you are literally encouraged to be lazy.
15:53:11 <EvanR> lists are not great as data structure, for many purposes
15:53:11 <slack1256> IO is a state monad that doesn't pass state
15:53:12 <monochrom> And of course, we also define your own ADT for non-linear control types too, for example lazy trees if you want to do depth-first search.
15:53:27 <slack1256> as if haskell weren't obtuse already :-)
15:53:31 <nshepperd_> A good programmer is both lazy and productive, just like her programs
15:53:45 <bbear> I don't think I would be able  to define doubly linked lists in Haskell so easily.
15:53:58 <EvanR> bbear: i argue you should also be "lazy" (take the easy way) in haskell to get something done quick, optimize later
15:54:00 <geekosaur> like I said, you need to figure out how to tie the knot
15:54:13 <geekosaur> that is, make references between two list nodes so they can point to each other
15:54:26 <bbear> EvanR: problem with linked list is they are O(1) if you do it right, O(n²) if you do it wrong
15:54:28 <geekosaur> ....and then you get to figure out how to garbage collect list nodes when you're done with them
15:54:41 <EvanR> n^2 doesnt mean fatal 
15:54:47 <EvanR> depends on circumstances
15:54:54 <EvanR> not every programming problem is "implement google"
15:55:11 <EvanR> but this is just the essence of taking the easy way
15:55:21 <monochrom> Also, I am under the impression that this is the 3rd time bbear asks this question again.
15:55:34 <bbear> yes because I wander a lot here.
15:55:35 <EvanR> if so, egg on my face
15:55:40 * geekosaur reminded of O(n) with a huge constant overhead can be far worse than O(n²) with 1 cpu cycle overhead
15:55:55 <bbear> never asked this before.
15:56:07 <monochrom> bbear takes Ω(n) time to understand the answer :)
15:56:09 <slack1256> bbear: a doubly linked as in C where you store the pointers is not possible. But you could store in a ADT two lists and a current element. That is kind of a zipper of a double linked list
15:56:15 <geekosaur> I think like every other newcomer asks it :)
15:56:42 <slack1256> the problem comes when you put the tail pointing to the head of such linked list 
15:56:43 <EvanR> if you want a C style doubly linked list, you can do it
15:56:48 <EvanR> itll be about as tricky as in C
15:56:54 <EvanR> not recommended for real life
15:57:06 <slack1256> Mmmm doubly linked list are not tricky in C...
15:57:12 <slack1256> naively though
15:57:15 <EvanR> for me they are
15:57:39 <bbear> I should probably restate my problem
15:57:41 <EvanR> despite the fact that, thanks to C, you probably will be implementing it from scratch every time
15:57:46 <EvanR> i still mess up
15:57:51 <slack1256> glib FTW
15:58:03 <bbear> How can you work in a cyclic manner on a list ?
15:58:07 <Tuplanolla> If you want to do ahead-of-time allocation or branch avoidance, it gets very tricky very quickly, slack1256.
15:58:19 <EvanR> oh then you want to learn zippers
15:58:26 <bbear> without killing performances
15:58:40 <slack1256> Tuplanolla: naively though :-) lol
15:58:41 <monochrom> I also want to point out that C people abuses arrays inefficiently as much as Haskell people abuses lists inefficiently.
15:58:45 <Tuplanolla> If you intend to call `malloc` per element, you might as well use another language, slack1256.
15:58:57 <bbear> IDK doing (++) is kind of evil I think if you want perf (already thought that) 
15:59:08 <EvanR> bbear: are you sure you dont want a ring buffer instead... if youre worried about performance ?
15:59:55 <trigone> so what about the other monads? if they don't have monads, is it bc they didn't think of adding it, or bc they can't or bc they have something equally efficient and practical?
16:00:16 <monochrom> I saw code from world-class, winning programming contest contestants (namely ACM ICPC, and namely U of Waterloo students) that uses a plain array for priority queue, storing things in unsorted order, and every time an extract-min happens it is an exhaustive search. Simply because arrays are the go-to data "structure" in C.
16:00:36 <geekosaur> haskell's type system makes monads work much better than they do in most other languages, including functional languages
16:00:53 <geekosaur> actually. not just the type system. the way the type system and expressions fit together
16:00:55 <monochrom> But meh, Dijkstra did that too in the original version of his shortest-path algorithm.
16:01:58 <bbear> youn know n^2 algorithms
16:02:00 <geekosaur> monads in most other languages including other ML-family languages are clumsy, not very flexible, and often have shortcomings where type checking is insufficient
16:02:04 <bbear> they basically dont scale
16:02:13 <monochrom> Anyway, do not conflate "standard" with "popular". I mean, if you said "de facto standard" I would be fine.
16:03:19 <monochrom> But since "popular" is usually the anti-thesis to "premium quality" you should simply not care why something is popular.
16:03:58 <trigone> geekosaur: so what do they do to, say, replace the Maybe monad? ofc that depends on what counts as minimal usability of a monad: without typeclasses, you'd have to demultiply every function working on any monad... (i guess)
16:04:04 <bbear> From what I learnt, the choice of a good data structure is what makes the difference between a program that will run at a human time scale vs age of teh universe time scale
16:04:07 <monochrom> In Tcl, people use strings for everything. I mean, even bash tries to have numbers and arrays.
16:04:12 <bbear> that's kind of critical.
16:04:56 <bbear> monochrom: I agree with you. Python is quite popular, not necessarily the best language in the world
16:06:55 <geekosaur> trigone, if something is not easy, it's generally just not done
16:07:32 <geekosaur> I think the closest I've seen to a replacement for the Maybe monad is Swift's ? stuff --- which is a wired-in operator
16:08:24 <geekosaur> almost nobody bothers with the list monad (then again, it's rare to see actual use of the list monad in Haskell, either, aside from the degenerate form which is list comprehensions)
16:09:59 <trigone> geekosaur: hi'm trying to find answers but everytime i read something about monads in other functional languages, it's automatically only about IO... unless unique types also allow the same stuff than monads, like error/failure handling, logging, etc... i can't imagine a functional language with tons of explicit checking of validity, etc...
16:10:26 <geekosaur> again, if something is not easy, it's generally just not done
16:10:38 <geekosaur> they don't use monads, they use effectively procedural code
16:10:53 <trigone> geekosaur: effectively?
16:11:02 <trigone> is that technical term?e
16:11:21 <aisqwe> i dont understand how "(MonadState Int m,MonadWriter [String] m) => m Int" is equal to "StateT (Writer [String]) Int Int" where should i read about it?
16:12:05 <slack1256> trigone: those other languages have have some kind of explicit ordering of evaluation, thus can get away by using the order of evaluation for the order of execution
16:12:24 <slack1256> maybe not explicitly in the form of "statements"
16:12:56 <geekosaur> aisqwe, it's not "equal to".
16:13:10 <slack1256> but if you know something will be evaluated before some other them, then the ordering of those evaluations helps you to write procedural code
16:14:10 * hackagebot linear 1.20.7 – Linear Algebra – https://hackage.haskell.org/package/linear
16:14:10 * hackagebot profunctors 5.2.1 – Profunctors – https://hackage.haskell.org/package/profunctors
16:14:17 <aisqwe> geekosaur: what are the keywords i need to know to be able to search and learn about the concept?
16:14:17 <slack1256> in haskell we couldn't do that (by design), so we had to ideate a way to bind execution to the only ordering we had available (which wasn't evaluation because of laziness), that is data dependency order
16:15:11 <geekosaur> aisqwe, StateT (Writer [String]) Int Int is a concrete type. (MonadState Int m, MonadWriter [String] m) => m Int describes an abstract type, of which the concrete type is one (the simplest, I think) possible implementation
16:15:29 <slack1256> if you semiclose you eyes a little, you will see that the Monad class is just a continuation class (indeed, the second arg of >>= is a continuation), that helps you make the data ordering explicit and thus you can bind (heh) to some execution orders (if you want)
16:16:02 <trigone> slack1256: i don't really get what you mean. yes monads help ordering stuff but they also hide crucial components, otherwise you can just use if/then/else or whatever equivalent (it can just be a function), and it'll give you execution order but won't make your code lighter
16:17:07 <trigone> slack1256: the crux of monads is to have something happening at the position of the metaphorical semicolon. procedural order does not give you that at all, does it?
16:17:09 <geekosaur> aisqwe, the point of using the abstract type is that it is still valid if you later add other transformers to the concrete monad stack, provided they do not conceal the required typeclasses (that is, (MonadState Int m) and (MonadWriter [String] m))
16:18:05 <aisqwe> geekosaur: I understand how monad transformers work but i have no idea how this abstract thingy works under the hood
16:18:51 <geekosaur> you are describing what functionality you need, not the specific type that implements it
16:19:11 <geekosaur> which allows you to change the specific type later to accommodate new functionality
16:19:23 <trigone> geekosaur: speaking to whom?
16:19:34 <geekosaur> the person who just spoke to me?
16:20:07 <trigone> geekosaur: right
16:20:17 <trigone> slack1256: so, you say they use continuations, but if they do, and as you said indee it's more or less what monads are about, then how are they not using monads, even if it's not encoded the same way than in haskell?
16:20:30 <geekosaur> aisqwe, you are describing what functionality you need, not the specific type that implements it. which allows you to change the specific type later to accommodate new functionality, because you have described the functionality you need instead of a specific type that can provide it
16:20:43 <slack1256> trigone that crucial component that abstracts is the nesting of the continuations plus being able to express different orderings (by different instances)
16:20:59 <geekosaur> feeeh, so I get interrupted and repeat myself myself...
16:21:24 <slack1256> about the metaphorical semicolon is just a byproduct of the do-notation transformation, that it comes from expressing the continuation (and the execution) explicitly
16:22:10 <trigone> slack1256: well... even using explicit operators, you can see the metaphorical semicolon. but i'm not particularly attached to that metaphor, i just misread when you said "semiclose" actually ^^
16:22:33 <slack1256> trigone: there is not a clear separation of what effect you are trying to encode with pure continuations. You can do all of the them at the same time, which is confusing
16:23:14 <geekosaur> aisqwe, also I realized why that type was bothering me, sure that first Int isn't Identity?
16:23:16 <geekosaur> or IO
16:23:18 <trigone> slack1256: not sure to get what you mean at all... for a while not...
16:23:27 <trigone> s/not/now/
16:24:31 <geekosaur> oh, also missing the state type in StateT
16:24:42 <slack1256> with continuations you can express the monad instance for MaybeT, StateT, ExceptT on the same code block. Yet you lose the separation of concert you had enforced early with the monadic approach
16:24:49 <slack1256> *concerns
16:24:53 <geekosaur> aisqwe, or something, that type seems a bit confused
16:25:25 <geekosaur> aisqwe, so if later on you need to add a ReaderT Int to that StateT, or you need to swap a base monad Identity for IO or ST or etc., you don't have to rewrite the existing functions; they just work
16:26:21 <geekosaur> aisqwe, ... that said, one doesn't generally do that very often; it smacks of not thinking out your problem domain and designing the solution types first
16:26:30 <trigone> slack1256: ok, so what's your conclusion, what are you trying to tell me?
16:26:54 <geekosaur> (although in the real world, it's often your customer that didn't and you're caught in the middle when they "but wait...!")
16:27:12 <slack1256> weren't you asking why we chose monads for IO instead of continuation around haskell 1.4 ?
16:27:58 <aisqwe> what is this weird "|" in this class definition ? class (Monoid w, Monad m) => MonadWriter w m | m -> w where
16:28:07 <geekosaur> functional dependency
16:28:31 <geekosaur> "the type determined for m determines the type for w"
16:29:10 <geekosaur> without it, pretty much every use of a typeclass function would require explicit types, because you can't really infer them
16:29:11 <`Guest00000> can i stop listening on a socket and not drop existing connections?
16:29:36 <geekosaur> close the listen socket
16:29:45 <geekosaur> when you accept(), you get a new independent socket
16:29:45 <slack1256> ^ that
16:29:55 <`Guest00000> existing connection won't be dropped, right?
16:30:01 <trigone> slack1256: well, half an hour ago... in the meantime i started asking about the other monads, because the alternatives to the IO monad are quite well referenced, but not the alternatives for other monads
16:30:12 <geekosaur> correct, the socket returned by accept is not affected by closing the listen socket
16:30:17 <`Guest00000> thanks
16:30:31 <aisqwe> each accepted connection is different
16:31:14 <`Guest00000> what if i just stop accepting?
16:31:26 <trigone> aisqwe: functional dependency amounts to forbidding two instances with the same m but a different w.
16:31:57 <geekosaur> eventually the kernel's listen queue for that socket will fill up, you'll get messages in syslog / event log, and further connection attempts will be rejected with an ICMP flow control response
16:32:19 <slack1256> oh, well for state you could pass the parameter around, same for reader and writer. Threading manually
16:32:28 <slack1256> in a pure language you can't do much else
16:32:40 <geekosaur> depending on OS defaults and program config, the listen queue can be anywhere between 5 and 127, or maybe more
16:33:09 <geekosaur> meanwhile programs typing to connect, until the listen queue fills up, will just hang
16:33:28 <trigone> aisqwe: aka, only one allowed instance per value of the parameter m.
16:34:28 * hackagebot shakers 0.0.28, structs 0.1.1, trifecta 1.7.1, zippers 0.2.4
16:34:28 * hackagebot  → https://hackage.haskell.org/packages/recent
16:34:35 <trigone> slack1256: ok...
16:34:55 <koala_man> monochrom: I just benchmarked it and, on my system, array wins over priority queue for N < 24. 
16:34:56 <`Guest00000> geekosaur: thank you
16:34:57 <geekosaur> (and with large listen queues and multiple instances of programs that "just stop listening", you can run the system out of network resources.)
16:35:09 <koala_man> which was lower than I would have thought
16:40:47 * hackagebot lens-aeson 1.0.2, parsers 0.12.6, preamble 0.0.48, rcu 0.2.1
16:40:47 * hackagebot  → https://hackage.haskell.org/packages/recent
16:41:58 <Welkin> hackagebot spam?
16:42:33 <geekosaur> edwardk mass update spam :p
16:43:36 <trigone> incase anyone is knowledgeable in that, is there a way to combine the concatenative paradigm with currying/multiparameter functions? point-free style is kinda unreadable as soon as you have more than a simple composition of 1-argument functions...
16:43:50 <edwardk> To be fair this was almost entirely done by ryanglscott
16:44:25 <Welkin> trigone: point-free has its uses
16:45:00 <Welkin> trigone: watch this great (36 minute) talk on the topic https://www.youtube.com/watch?v=seVSlKazsNk
16:45:08 <Welkin> "Point-Free or Die: Tacit Programming in Haskell and Beyond" by Amar Shah
16:45:12 <Welkin> it's entertaining too
16:45:55 <Welkin> (.) . (.) is actually quite useful, especially once you alias it as ...
16:46:50 <jared-w> I thought most people aliased it as .:
16:46:57 * geekosaur just drops pointfree when it starts going dotty
16:46:57 <trigone> Welkin: i guess maybe one can literally get literate into even the worst point-free style (not that your example is too bad, even if i couldn't tell you its type)
16:46:58 <Welkin> yeah
16:47:05 <Welkin> that's true
16:47:06 <geekosaur> or flippy
16:47:08 <Welkin> in this talk he uses ...
16:47:18 <trigone> :t (.) . (.)
16:47:19 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
16:48:05 <erisco> trigone, the readability is dependent on the combinators being used. If you limit yourself to (.) then yes, it can become hairy
16:48:09 <trigone> hm ok, combind with a 1ary function after 2ary function...
16:48:10 * jared-w quite enjoys the use of a1 and a in that
16:48:50 <trigone> erisco: i suppose... but concatenative paradigm more or less tries to start with (f g) as notation for (f . g). at that stage, i really don't know how you can add multiparameter stuff...
16:49:04 <trigone> jared-w: why do you enjoy a1 and a?
16:49:21 <monochrom> koala_man: Oh heh. Even when the array version is slow, it seems from practical experience that the whole thing is fast enough. I guess it's because the number of decrease-priority's is more than the number of extract-min's, very often it's tolerable.
16:49:33 <erisco> well I don't know about concatenative paradigm... never heard of it
16:49:38 <trigone> Welkin: thanks for the source btw :)
16:50:17 <Welkin> I used to think point-free was mostly useless and often avoided it, until I found this talk which changed my mind about it
16:50:47 <Welkin> I just used (.) before, but if you add (.) . (.) it makes a lot more sense
16:50:52 <erisco> I should steal their talking points then...
16:50:52 <trigone> erisco: basically, you write programs in point free style by default, so that (foo bar baz) in haskell would mean (foo >>> bar >>> baz) with (>>>) = flip (.)
16:51:22 <trigone> Welkin: so now you can "read" (.) . (.) ?
16:51:43 <trigone> erisco: aka baz . bar . foo
16:51:53 <erisco> trigone, but that isn't pointfree style... pointfree style is merely the absence of variables
16:52:12 <trigone> erisco: well do you see a variable in foo >>> bar >>> baz? all three names are functions
16:52:24 <Welkin> trigone: read?
16:52:31 <wespiser> Welkin: do you have a link to that talk?
16:52:38 <Welkin> wespiser: I linked it above
16:52:40 <erisco> if  foo bar baz   means  foo >>> bar >>> baz  then where did function application go?
16:52:42 <wespiser> i want to improve my point free
16:52:49 <wespiser> Welkin, apologies
16:52:50 <monochrom> Readability does not depend on the suite of combinators. Here is a law-of-excluded-middle argument. If your suite is big, you get unreadability due to people not learning the whole suite. If your suite is small, you get unreadability due to you needing weird combinations. :)
16:53:27 <trigone> Welkin: i mean, do you remember what it does by rote or can you actually find back what it means easily just by looking at it?
16:53:46 <Welkin> trigone: after evaluating the type, it makes sense
16:53:57 <erisco> monochrom, except there is a middle... when you have just the right combinators to address a particular domain
16:54:13 <monochrom> Yes, ideally.
16:54:16 <trigone> erisco: that's the point, no more function application, only function composition, defined in a way as "concatenation" since you just stack them one after the other.
16:54:27 <monochrom> In practice, people then go on to complain about your choice of names or symbols. :)
16:54:34 <monochrom> In fact, it's worse than that.
16:54:36 <trigone> Welkin: obviously, but can you find back the type alone and easily
16:54:45 <nshepperd> is 'concatenative' programming really worth it
16:54:45 <erisco> trigone, okay, maybe that is the concatenative paradigm, but that is more restrictive than pointfree generally
16:55:00 <nshepperd> doesn't seem like it really grants any powers, just constricts you
16:55:07 <trigone> erisco: well that was more or less my question...
16:55:27 <monochrom> If you choose to name a thing "xxx", people will complain that they want "(%%%)". If you choose to name it "(%%%)", people will complain that they want "xxx".
16:56:18 <Welkin> trigone: yes, you can, as long as you know the type of (.) you can work it out on paper easily
16:56:34 * monochrom 's greatest invention today is the Principle of Included-Excluded-Middle
16:56:35 <Welkin> trigone: reducing types by hand helps to understand a lot of things in haskell
16:56:45 <jared-w> Or, otherwise phrased as "lenses look like ascii vomit!" vs "lens names make the code look too verbose and obfuscated!"
16:57:00 <erisco> you need not look further than the wisdom of Moskowitz who proved there is no such thing as a perfect pasta sauce, monochrom
16:57:17 <geekosaur> @remember monochrom * monochrom 's greatest invention today is the Principle of Included-Excluded-Middle
16:57:17 <lambdabot> Good to know.
16:57:31 <monochrom> w00t pasta sauce. Lasagna. It's lasagna all the way down!
16:57:46 <hpc> lasagna is where all the middle went
16:58:00 <jared-w> "... is an American market researcher. He is best known for the detailed study he made of the types of spaghetti sauce and horizontal segmentation"
16:58:02 <jared-w> what a legend
16:58:03 <Welkin> the fat orange cat did it
16:58:42 <Welkin> is anyone going to Strange Loop?
16:58:42 <trigone> 1995 - At a neighborhood Italian restaurant Rasmus Lerdorf realizes that his plate of spaghetti is an excellent model for understanding the World Wide Web and that web applications should mimic their medium. On the back of his napkin he designs Programmable Hyperlinked Pasta (PHP). PHP documentation remains on that napkin to this day.
16:58:49 <Welkin> I'm looking at tickets right now
16:58:56 <Welkin> is it worth going? fun?
16:59:05 <Welkin> I know the talks are good, but they are posted online anyway o.o
17:00:02 <erisco> maybe the design ethos does, but really one of PHP's best achievements is its online documentation
17:00:19 <hpc> it's true
17:00:34 <koala_man> huh, I remember the docs being awful. they only documented the happy cases
17:00:39 <hpc> php is the only language with documentation of such quality that it could only be written by online randos
17:00:55 <monochrom> Oh! So is Moskowitz the reason why there are so many slightly different video cards to choose from? :)
17:01:28 <wespiser> just think, in 50 years they will look back at Haskell and say a lot of the things we say about PHP now...
17:01:46 <monochrom> such as getting designed on a napkin? :)
17:01:48 <koala_man> people hate on PHP, but don't consider that at the time, the state of the art was writing CGI scripts in Perl
17:02:18 <erisco> if you go 10 or 15 years back and compare language websites and you will find PHP has the exceptionally accessible and complete one
17:02:23 * dibblego throws a servlet at koala_man 
17:02:37 <koala_man> dibblego!!
17:03:15 <slack1256> hating on php is standard practice to delimit group on PL channels
17:03:37 <erisco> in other places you were happy to have some generated APIs with a smattering of comments (not even any hyperlinks, just a dump on a web page)
17:03:42 <wespiser> yea, it certainly seems like it, as long as we stay away from perl
17:03:50 <wespiser> perl6 is going to make a comeback
17:04:01 <Welkin> no one uses perl6
17:04:02 <erisco> generated API docs, I mean... and possibly not even that so instead you'd have to buy a book
17:04:05 <Welkin> they all use perl5
17:04:32 <erisco> today we have friggin search engines like Hoogle and Hayoo and so life is much easier
17:05:16 <erisco> heck, just consider C or C++... how long did it take them to get decent online docs for that
17:05:24 <wespiser> its too bad, perl6 is a well built language, which is what 15 years of development will get you
17:06:04 <koala_man> PHP introduced the model of embedding code in html rather than vice versa, and now everyone's doing it and taking it for granted
17:06:14 <Welkin> o.o
17:06:18 <Welkin> no one is doing that
17:06:27 <Welkin> we generate the html these days
17:06:39 <Welkin> either through special template languages or combinators
17:06:40 <erisco> with HTML embedded in the host language now, sometimes
17:07:03 <monochrom> There is some Inception joke in this. :)
17:07:52 <monochrom> Or this: https://ro-che.info/ccc/9
17:08:53 * hackagebot intervals 0.8.1, log-domain 0.11.2, machines 0.6.3, wolf 0.3.25
17:08:53 * hackagebot  → https://hackage.haskell.org/packages/recent
17:09:20 <monochrom> Oh new version of machines. This recompiles everything. Again.
17:11:00 <Welkin> what do you use machines for?
17:11:08 <monochrom> Learning.
17:11:47 <monochrom> Why does everyone ask me what I use machines for?
17:11:56 <monochrom> Is it because everyone wants to talk me out of it?
17:12:11 <Welkin> this is the first time I have ever asked
17:14:29 <slack1256> monochrom: because is really... bare, by default
17:14:43 <slack1256> does it have a standard Prelude somewhere?
17:14:48 <Welkin> I only asked out of curiosity
17:15:15 <trigone> what's "machines"?
17:15:30 <monochrom> the "machines 0.6.3" up there
17:15:48 <trigone> monochrom: oh right
17:16:10 <trigone> monochrom: so what's that in practice?
17:16:26 <trigone> monochrom: nevermind i found it
17:16:30 <monochrom> I can't tell you that. I'm still learning.
17:19:15 <glguy> https://github.com/glguy/TwosGame/blob/master/Main.hs is my example of machines
17:20:44 <trigone> is there somewhere a version of haskell syntax with postfix notation instead of infix?
17:20:44 <Welkin> glguy: what's with the PackageImports pragma? What does it do? And why are there strings before your imports?
17:20:52 <trigone> s/infix/prefix/
17:21:01 <glguy> Welkin: I did that so that the reader would know what package each module came from
17:21:02 <parazyd>  can anyone help me with compiling dev-haskell/adjunctions? http://sprunge.us/FMHG
17:21:10 <parazyd> i've made progress but now really stuck here.
17:21:16 <trigone> aka writing (a b f) instead of (f a b)?
17:21:20 <glguy> Welkin: The actual purpose is for disambiguation where two packages provide the same module
17:21:26 <parazyd> not sure how to resolve this. any thoughts please?
17:22:10 <Welkin> trigone: not sure why you want postfix. Like Reverse Polish Notation, or a stack-based language
17:22:53 <glguy> There's an exercise on codewars where you are supposed to build a postfix function application language in Haskell
17:23:00 <trigone> Welkin: reverse polish notation (if that means writing a b f instead of f a b. i don't exactly know what a stack-based language entails.
17:23:11 <Welkin> it's the same as RPN
17:23:18 <Welkin> you push the variables onto a stack
17:23:28 <Welkin> then when you get a function, you pop off from the stack and evaluate
17:23:30 <glguy> https://www.codewars.com/kata/a-simple-postfix-language
17:23:43 <glguy> Our own mpickering added that one :)
17:24:55 <trigone> Welkin: look, without going into details of implementation, pre/post/infix is before all potentially just cosmetic since you can seamlessly go from one version to the other without losing anything. in haskell, the standard is prefix, so i wondered if a postfix func application language extension or whatever existed
17:26:05 <trigone> glguy: yeah it's nice but it's hardly syntactically usable...
17:26:24 <glguy> Sure, the whole postfix notion is a bad idea, but the exercise is interesting
17:27:24 * hackagebot loup 0.0.14 – Amazon Simple Workflow Service Wrapper for Work Pools. – https://hackage.haskell.org/package/loup
17:38:05 <user7000> i wrote some lines of code using Async, sockets and TVars. is this right usage? please review it: http://lpaste.net/357265
17:40:31 * hackagebot distributive 0.5.3, folds 0.7.4, gc 0.0.2, heaps 0.3.5
17:40:31 * hackagebot  → https://hackage.haskell.org/packages/recent
17:43:36 <xcmw> Has anyone written a GCompare instance for Proxy? SomeSymbol is Ord so it seems like it should be possible for Proxy a if a is a KnownSymbol.
17:44:18 <R0B_ROD> I want to solve a problem out of curiosity
17:44:43 <R0B_ROD> All the possible ways to sum to 25
17:45:04 <R0B_ROD> like 1+1+1... and 24+1 and so on
17:45:12 <R0B_ROD> all the combinations possible
17:45:19 <wespiser> infinit
17:45:26 <MarcelineVQ> wespiser: infinite?
17:45:35 <xcmw> R0B_ROD: I assume the number have to be greater or equal to 1
17:45:42 <wespiser> sure, you have to restrict
17:45:56 <geekosaur> if you allow negative numbers
17:45:57 <MarcelineVQ> ah yeah I guess that makes sense with negativbe numbers :X
17:46:23 <boj> seems kind of obvious though
17:46:33 <R0B_ROD> no negative numbers
17:46:46 <R0B_ROD> just all the positive sum cases
17:46:52 <jle`> only integers?
17:46:55 <R0B_ROD> yes
17:46:56 <jle`> or can you use any real?
17:46:58 <R0B_ROD> whole
17:47:02 <R0B_ROD> just basic 
17:47:15 <c_wraith> Isn't that like..  the catalan numbers?
17:47:42 <nshepperd> it's the partition function!
17:47:49 <jle`> stars and bars
17:47:57 <R0B_ROD> each line shows a way that adds to 25
17:48:31 <c_wraith> except the number of partitions can vary from 0 to 24
17:48:36 <R0B_ROD> maybe i need to define it better i am wondering as think
17:48:46 <glguy> > ways 5
17:48:48 <lambdabot>  [[1,1,1,1,1],[1,1,1,2],[1,1,2,1],[1,1,3],[1,2,1,1],[1,2,2],[1,3,1],[1,4],[2,...
17:48:56 <R0B_ROD> yes
17:48:58 <jared-w> oooh that's a neat function
17:49:04 <R0B_ROD> oh wow
17:49:08 <R0B_ROD> haha that was fast
17:49:17 <nshepperd> this is called 'partitioning an integer' in number theory
17:49:25 <nshepperd> https://en.wikipedia.org/wiki/Partition_(number_theory)
17:49:26 <R0B_ROD> interesting
17:49:31 <R0B_ROD> so awesome
17:49:46 <c_wraith> https://oeis.org/A000108
17:50:32 <c_wraith> Hmm.  No, not quite the catalan numbers after all.
17:50:59 <R0B_ROD> glguy: is it in ghci ? 
17:51:48 <c_wraith> R0B_ROD: high odds glguy just input it to lambdabot in private messages
17:51:49 <jle`> @let takeTil n = \x -> map (\y -> (y, n - y)) [x..n]
17:51:49 <nshepperd> https://oeis.org/A000041
17:51:50 <lambdabot>  Defined.
17:52:47 <R0B_ROD> no thats not what i want
17:52:59 <nshepperd> looks like partitions have a lot of applications
17:53:01 <R0B_ROD> unless the output is incomplete
17:53:33 <c_wraith> oeis is so great
17:53:36 <nshepperd> > ways 3
17:53:38 <lambdabot>  [[1,1,1],[1,2],[2,1],[3]]
17:54:17 <R0B_ROD> > ways 15
17:54:19 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,...
17:54:33 <nshepperd> ah, this should be order independent
17:55:05 <R0B_ROD> from greatest amount of integers to least
17:55:11 <R0B_ROD> is how i would want it
17:56:44 * hackagebot propellor 4.7.0 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
17:58:20 <nshepperd> > partitions 3
17:58:22 <lambdabot>  *Exception: not an integer: i
17:58:31 <nshepperd> wat
17:58:34 <R0B_ROD> ok say i have 25 columns and 25 rows
17:59:21 <nshepperd> > parts 3
17:59:24 <lambdabot>  error:
17:59:24 <lambdabot>      Ambiguous occurrence ‘parts’
17:59:24 <lambdabot>      It could refer to either ‘Lens.parts’,
18:00:20 <nshepperd> > partitions 5
18:00:22 <lambdabot>  [[1,1,1,1,1],[1,1,1,2],[1,1,3],[1,2,2],[1,4],[2,3],[5]]
18:01:55 <glguy> I just did the one where order mattered because one of the example solutions was 24+1
18:05:51 <nshepperd> R0B_ROD: anyway, you can solve this by trying all the possibilities!
18:06:06 <nshepperd> throw a list monad at it
18:06:44 <`Guest00000> omg, there's no consensus in libraries on whether we should call (\(_, _, x) -> x) trd or thd
18:08:31 <dolio> thrd
18:09:13 <MarcelineVQ> hehe trd
18:09:19 <nshepperd> neither, because the type isn't compatible with fst and snd anyway?
18:09:20 <c_wraith> > (1,2,3) ^. _3
18:09:22 <lambdabot>  3
18:09:40 <`Guest00000> nshepperd: well, surely the name trd3 / thd3 is implied
18:09:48 <c_wraith> sometimes I just give up and use the names provided by lens.
18:10:05 <`Guest00000> ^. _3 is too bid
18:10:08 <`Guest00000> big *
18:10:34 <c_wraith> Well, it's just named _3
18:10:46 <c_wraith> ^. is what you get for using lens in the first place. :)
18:11:03 <`Guest00000> what are solutions for command-line help, commands help, etc?
18:11:18 <c_wraith> optparse-applicative is popular.  There are a couple other popular ones
18:11:31 <nshepperd> take inspiration from java. thirdElementOfTheTriple
18:11:32 <`Guest00000> i want to have a structure with commands which self-references when the command 'help' is called
18:13:06 <dolio> _3 has the advantage of doing a bunch of other cool stuff, too.
18:13:45 <dolio> So it's kind of better than adding stuff like thd.
18:14:31 <xcmw> Has anyone written a GCompare instance for Proxy? SomeSymbol is Ord so it seems like it should be possible for Proxy a if a is a KnownSymbol.
18:16:10 <nshepperd> that seems like a rather specific thing to attach to Proxy, which is used for many things
18:28:07 * hackagebot comonad 5.0.2 – Comonads – https://hackage.haskell.org/package/comonad
18:41:19 * hackagebot google-translate 0.4.1 – Google Translate API bindings – https://hackage.haskell.org/package/google-translate
18:49:23 <unknownln> Need some help with what I presume is some sort of weird buffering issue: http://lpaste.net/1804206729009823744
18:49:51 <unknownln> I'm processing data from stdin in real time, it's coming from an infinite input source
18:49:52 <unknownln> and I want it to output to terminal as it processes of course
18:50:08 <unknownln> anyways, if I dont print that message to stderr, I dont get any input unless my input source is finite
18:50:21 <unknownln> dont get any output*
18:50:30 <unknownln> but if I do print that message to stderr, I get output as I'd expect
18:50:33 <unknownln> what gives?
18:50:48 <edwardk> Xcmw: why Symbol?
18:52:32 <xcmw> edwardk: Because I don't think it is possible in the general case
18:52:57 <geekosaur> unknownln, are you capturing output in any way?
18:53:07 <geekosaur> from yoru program, not the input source
18:53:30 <unknownln> It's just going to terminal output
18:54:30 * hackagebot ad 4.3.4 – Automatic Differentiation – https://hackage.haskell.org/package/ad
18:54:30 * hackagebot approximate 0.3.1 – Approximate discrete values and numbers – https://hackage.haskell.org/package/approximate
18:54:58 <unknownln> geekosaur: if I redirect output to a file, same problem
18:55:38 <geekosaur> actually I was wondering about puping output to something because then you also have to worry about that something buffering
18:56:23 <unknownln> makes sense. No, this is strictly an issue with my haskell program
18:59:55 <unknownln> also if I write some constant string to stdout for every chunk, that string never gets written
19:00:03 <`Guest00000> y no notNull
19:00:12 <unknownln> (and it does if I use a finite input source)
19:01:03 <unknownln> and when I say finite vs infinite input, the finite input is exactly the same data as the infinite (tail -f -c +0 vs cat)
19:10:55 <`Guest00000> when main finishes, what happens to other threads?
19:16:17 <geekosaur> they go away with the process
19:22:52 <monochrom> In more ugly detail, they disappear without being told. So for example, no thread-killed exception to them.
19:23:06 <edwardk> Xcmw: as a general rule when you have a type with a poly kind, instances that monomorphize that kind and block a potentially more powerful and general instance are hard sells
19:24:01 <monochrom> This is the opposite of Java. Java keeps your program running when there are non-daemon threads.
19:24:05 <xcmw> edwardk: Is a more general instance possible?
19:25:02 <edwardk> Can you define it for pairs of symbols? For the unit type that inhabits the unit kind?
19:26:43 <edwardk> I'm on a plane about to take off, but from what little I looked my guess is yes
19:31:01 * hackagebot propellor 4.7.1 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
19:49:16 * hackagebot shakers 0.0.29 – Shake helpers. – https://hackage.haskell.org/package/shakers
19:59:25 * hackagebot shakers 0.0.30 – Shake helpers. – https://hackage.haskell.org/package/shakers
19:59:25 * hackagebot email-validate 2.3.1 – Email address validation – https://hackage.haskell.org/package/email-validate
20:01:41 <Welkin> what is the best library to use for xml parsing?
20:01:47 <Welkin> hxt? tagsoup?
20:01:57 <Welkin> I mostly just want to translate xml into json
20:08:32 * hackagebot staversion 0.2.1.1 – What version is the package X in stackage lts-Y.ZZ? – https://hackage.haskell.org/package/staversion
20:14:28 <c_wraith> Welkin: the only library I've really used for much of anything was xml-light.  It's hardly full-featured, but I like that it's as simple to use as it claims.
20:17:00 <Welkin> I found this http://hackage.haskell.org/package/xml-to-json
20:18:16 <c_wraith> if it works for your documents, perfect
20:18:23 <c_wraith> Just...  test it out, eh? :)
20:18:46 <mnoonan_> Is there a way to test properties of the form “this expression should *not* type-check”?
20:19:15 <c_wraith> mnoonan_: there is, but it's kind of a hack
20:19:18 <mnoonan_> I feel like I saw an article about it once, but can’t figure out where..
20:19:24 <c_wraith> mnoonan_: it involves compiling with deferred type errors
20:19:35 <c_wraith> then ensuring you get the right exception
20:19:43 <c_wraith> there was an article about it
20:19:45 <mnoonan_> ah, interesting idea
20:19:48 <c_wraith> Must be the one you saw
20:19:58 <mnoonan_> thanks
20:20:13 <c_wraith> mnoonan_: https://hackage.haskell.org/package/should-not-typecheck ?
20:20:38 <mnoonan_> awesome!
20:21:38 * hackagebot hyperloglog 0.4.2 – An approximate streaming (constant space) unique object counter – https://hackage.haskell.org/package/hyperloglog
20:21:38 * hackagebot bound 2.0.1 – Making de Bruijn Succ Less – https://hackage.haskell.org/package/bound
20:22:04 <mnoonan_> I’m working on a library that uses a ST sort of approach to give you a map type with a lookup operation that can’t fail, and I want to have some tests to that effect
20:22:39 <c_wraith> ah, yes. ST-like properties are a good case for that.
20:35:57 * hackagebot compensated 0.7.2 – Compensated floating-point arithmetic – https://hackage.haskell.org/package/compensated
20:36:32 <crucify_me> sorry if I want to get the type signature to reflect the variables in my function myUncurry f (aa, bb) = f aa bb   ,   how would I do that? so when I do Prelude> :t myUncurry I see those variables
20:37:09 <geekosaur> you don't. pattern bindins are value level not type level
20:42:23 <n_blownapart> sorry geekosaur . so I thought people earlier were suggesting that.
20:43:06 <geekosaur> if you provide a type signature, ghc will try to retain type variables named in it
20:43:23 <geekosaur> value level bindings are not part of this
20:44:13 <n_blownapart> geekosaur,  oh thanks ok so that would be ..... :
20:45:13 * hackagebot lens-action 0.2.2 – Monadic Getters and Folds – https://hackage.haskell.org/package/lens-action
20:45:16 <geekosaur> myUncurry :: (aa -> bb -> cc) -> (aa, bb) -> cc; myUncurry f (aaa,bbb) = f aaa bbb
20:46:06 <geekosaur> the typechecker will try to use aa, bb, cc as appropriate when working with the type of a value involving myUncurry
20:47:10 <geekosaur> (if one or more of them is already in use, it will generally append a digit; so if you have some expression that uses myUncurry twice at different types, one of them will introduce aa0, bb0, cc0 type variables)
20:47:50 <`Guest00000> n_blownapart: you also can use type synonyms like: type ABC a = a
20:48:09 <n_blownapart> cool thanks !! I was attempting something close to that ! gotta go thank you !
20:48:21 <n_blownapart> geekosaur,  ^
20:50:04 <n_blownapart> thanks `Guest00000 I'll check it out 
20:54:32 <n_blownapart> geekosaur, thanks again that's working and clearing the fog !
20:57:17 * hackagebot ersatz 0.4.1 – A monad for expressing SAT or QSAT problems using observable sharing. – https://hackage.haskell.org/package/ersatz
21:02:56 <sleon> hi
21:03:20 <lambdabot> Hello.
21:03:47 <c_wraith> wait, what?
21:04:31 <geekosaur> heh
21:04:34 <sleon> can you guys help me, i am doing cabal install vty and i am getting linker errors, i am on arch
21:04:39 <geekosaur> too many people with the keys :p
21:04:41 <sleon> will paste pastbin in a second
21:04:58 <glguy> Always with Arch linux breaking
21:04:59 <geekosaur> sleon, use ghc from archhaskell not from the main arch
21:05:19 <geekosaur> or install a ghc that is otherwise not from arch, because currently arch's ghc is fubar
21:05:21 <sleon> https://pastebin.com/sErnfT3F
21:05:24 <c_wraith> right.  can some lambdabot admin enable explicit type applications? :)
21:05:34 <sleon> geekosaur: how to do it?
21:05:39 <geekosaur> you can partially rescue it with the ghc-static package but you must not install any haskell libraries from arch (unless, again, from archhaskell)
21:05:59 <sleon> geekosaur: how to switch to archhaskell
21:06:06 <sleon> geekosaur: thank you, i will google
21:06:20 <geekosaur> https://wiki.archlinux.org/index.php/ArchHaskell
21:07:00 <c_wraith> debian sort of mangles ghc, too.  What's with distros abusing the way ghc is packaged?
21:07:16 <sleon> geekosaur: thank you!
21:07:44 <geekosaur> c_wraith, I believe you want to talk to int-e
21:07:56 <geekosaur> (about adding extensions to lambdabot)
21:08:00 <glguy> c_wraith: There's some contention between making a good development environment and just using tools that happen to be written in Haskell
21:11:13 <sleon> another question: cabal seems to be a way to install dependeces of a programm. it is building them from source. is there a haskell package manager, which is installing binaries and which is distribution indepdendent? something like pip for python
21:11:48 <c_wraith> sleon: to be super-pedantic, pip pulls down source too. :)
21:12:07 <geekosaur> no, because ghc does things in the name of performance that makes binary archives extremely non-portable
21:12:08 <sleon> c_wraith: scikit?
21:12:32 <sleon> c_wraith: python scikit has a lot of binaries, they are installed as is
21:12:39 <sleon> c_wraith: or for example tensorflow module
21:12:54 <sleon> c_wraith: but you are right in a way :)
21:12:56 <geekosaur> (specifically, cross-module inlining, including from the "base" package which means it's baking part of the runtime of the specific ghc you have installed into them)
21:13:23 <sleon> geekosaur: ohh, i see
21:13:38 <c_wraith> sleon: geekosaur has conveniently answered your question usefully. :)
21:13:54 <sleon> c_wraith: yea :) thanks to you both
21:14:19 <geekosaur> it's annoying but it really does speed things up a lot, so we put up with it and install from source
21:15:09 <geekosaur> stack and cabal new-build try to cache binaries when they can be reused, but will also rebuild when they can't be, so it doesn't help as much as one could hope.
21:15:44 <c_wraith> I look forward to someday have ten different builds of the same version of a package installed with cabal new-build.
21:16:19 <c_wraith> Seriously.  That sounds totally awesome. :)
21:17:07 <sleon> geekosaur: my cabal does not have new-build command
21:17:16 <sleon> geekosaur: which cabal do you have?
21:17:18 <sleon> :)
21:17:25 <c_wraith> sleon: it's ok.  new-build is still experimental.
21:17:44 <c_wraith> sleon: that's why it's still called new-build, instead of just replacing build
21:17:46 <sleon> what is stack
21:17:54 <sleon> c_wraith: i see
21:18:18 <c_wraith> stack is an alternate tool for building haskell applications.  It is based on the idea of frozen sets of packages that are tested against each other.
21:18:27 <geekosaur> sleon, I think you need cabal-install 2.x for it. still experimental, I think it may be available in a hidden way in 1.24 but 1.24's version has known bugs
21:18:49 <geekosaur> (or maybe it got ripped back out because the bugs were bad enough to cause problems for people)
21:18:50 <glguy> Depending on what architecture and channel you're on, Nix offers binaries of Haskell packages
21:19:13 <Clint> and so do debian and ubuntu
21:19:26 <sleon> geekosaur, c_wraith: thanks 
21:20:02 <glguy> debian and ubuntu are usually far enough behind that no time is saved
21:20:13 <glguy> no use waiting a couple of years to get a binary instead of building from source
21:20:24 <geekosaur> hvr's ppa is nice on ubuntu
21:21:05 <c_wraith> isn't that only ghc (and the things that come with it) though?
21:21:36 <geekosaur> yes, but it's still ghc8 instead of ghc7.6.3 :)
21:21:53 <geekosaur> (ubuntu may actually have a later one now)
21:22:30 <Clint> it does
21:22:46 * geekosaur is moderately cross at constantly having to send xmonad PRs back for revision because we have to maintain compat with 7.6.3 for debian (old)stable...
21:23:51 <geekosaur> so people write perfectly good code that requires AMP and the 7.6.3 ci build promptly barfs
21:24:12 <Clint> stable has 8.0.1 and why are you supporting oldstable
21:24:18 <c_wraith> Are you saying people want to use fmap with only Monad in the context?
21:24:41 <c_wraith> (that was, by far, the biggest win I experienced from AMP)
21:24:50 <geekosaur> no, tey assume parts of Applicative in Prelude mostly
21:25:13 <c_wraith> (Applicative m, Monad m) => aaargh
21:25:56 <geekosaur> (on 7.6.3 you need to import Control.Applicative to get pure and <*>)
21:27:25 <geekosaur> and we continue to maintain support for oldstable because people look for it. not every debian user moves straight to the latest stable
21:28:25 * hackagebot linear-accelerate 0.4.1 – Lifting linear vector spaces into Accelerate – https://hackage.haskell.org/package/linear-accelerate
21:28:44 <geekosaur> and people who install xmonad are not necessarily looking for a haskell ecosystem, so largely don't care what ghc version is involved
21:29:42 <c_wraith> I wonder how many xmonad users just think it has a really wonky config file.
21:30:11 <geekosaur> a fair number of xmonad users who stick with it *do* get into haskell at some point... but they don;t care when they first install it
21:30:47 <geekosaur> and a fair number of those who install it get configs from other people --- I suspect most of our "advertising" is word of mouth (+ here's my config) from other users
21:30:52 <c_wraith> because if you expect just a config file, haskell source can be a lot more complex than expected.  Turing-comple configuration!
21:32:30 <sleon> thanks for the advices again, afeter switching to archhaskell everything builds, installs and runns as expected
21:34:15 <shlevy> Is there any way to create subkinds based on some constraint? E.g. could I make a type family that only kindchecks for types that are Showable?
21:35:47 <c_wraith> maybe TypeInType can get you something like that, since it will let you promote a GADT
21:37:15 <shlevy> Hmm... so something like data Showable t where Showable :: (Show a) => Showable a ?
21:39:02 <c_wraith> That was my thought, but I really have no idea if it can be worked into what you need.
21:39:17 <shlevy> Ultimately I want some Foo such that I can say Int :: Foo and String :: Foo for example... I don't think that will get there :/
21:39:20 <shlevy> Damn
21:40:40 <JSharp> general thoughts on uses of the DataKinds extension?
21:46:15 <`Guest00000> i'm amused at how one error message can take up 1.5 screenfuls
21:46:46 <JSharp> 1.5 screens of data about what blew up is better than 0/SIGSEGV...
21:46:55 <JSharp> usually.
21:46:59 <`Guest00000> for pointing to error origin
21:47:08 <`Guest00000> in the compiler
21:47:53 <mnoonan_> `Guest00000: if you like that, you’re gonna love template metaprogramming in C++..
21:48:55 <cocreature> “If you like 1.5 screens of error messages, choose C++ today and you’ll get 10 screens of error messages for free!”
21:50:38 <mnoonan_> I would kill for a mere 15 screens of C++ errors some days :)
21:50:50 <cocreature> heh I know that feeling ;)
21:52:25 <mnoonan_> at my work, we have a transpiler from a pure functional language to C++ templates. the error messages when things go wrong can give you vertigo.
21:54:22 <`Guest00000> mnoonan_: in which sense? size?
21:54:31 <`Guest00000> or meaning
21:55:22 <mnoonan_> both.. it’s hard to even scan, because the type names alone can be 5+ lines long
21:56:46 <JSharp> oof... errors mapped to the 'desugared' source are usually suboptimal
21:57:05 <JSharp> well... I say suboptimal... I really mean @#$%
21:59:58 <shlevy> suppose I have data Foo where Foo :: (Bar s) => s -> Foo. When pattern matching on a Foo, is there a way to bring 's' into the type variable scope (e.g. for future type application)?
22:00:05 <Hafydd> mnoonan_: might I ask where you work? 
22:00:58 <mnoonan_> GrammaTech. we do static analysis work, mostly.
22:03:28 <JSharp> shlevy, ScopedTypeVariables?
22:03:46 <shlevy> JSharp: Right, but how do I actually bind it?
22:04:01 <shlevy> Current solution is to call a helper function with an appropriately constrainted type
22:06:26 <JSharp> Foo :: forall s. Bar s => s -> Foo; and iiuc it would be bound into the type scope. I'm still quite green at this. You might also have to use TypeApplications and the @ syntax to reference the binding but I'm not sure
22:10:34 <orion> GHC and NodeJS are currently on the same version: 8.2.1
22:11:41 * JSharp instantly thinks of the awkward seal...
22:11:59 <JSharp> "I see you have the same version number too..."
22:18:15 <Lokathor_> uggggh
22:18:26 <Lokathor> i think my program would end up a lot better as a monad
22:18:29 <Lokathor> but i dunnnnnwanna
22:18:40 <JSharp> shlevy: let me know what you find out?
22:18:55 <JSharp> if it's not too much trouble
22:20:36 <shlevy> JSharp: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-type-signatures
22:20:56 <JSharp> cheers *takes a look*
22:30:52 <ab9rf> moonad
22:35:10 <Lokathor> Just/Nothing and Some/None are gonna be the death of me
22:39:58 <Lokathor> ab9rf, i got it
22:40:15 <Lokathor> don't need State support, i just need to be smarter about my use of Maybe
22:40:20 <MarcelineVQ> Just wait until Here/There
22:40:36 <Lokathor> http://lpaste.net/357267
22:42:15 <geekosaur> Hence, Thence
22:43:16 <Lokathor> ĉi tien, tien?
23:17:05 <`Guest00000> i'm running (((w `race` accept s) >>= cont) `concurrently_` a), where w waits for a flag and cont writes to console if this flag is set. there are no connections. a is thread which reads command from console and sets the flag. a is responsive, but w isn't
23:17:43 <`Guest00000> why so and how do i get it to work?
23:19:42 <`Guest00000> replacing (accept s) with dummy makes w responsive
23:47:02 <`Guest00000> do things like x in top-level decl "f = ... where x = ..." get executed only once?
23:47:10 <`Guest00000> evaluated
23:48:49 <Cale> Unless they're type class polymorphic, yes
23:55:59 * hackagebot staversion 0.2.1.2 – What version is the package X in stackage lts-Y.ZZ? – https://hackage.haskell.org/package/staversion
23:58:38 <Lokathor> > tail []
23:58:41 <lambdabot>  *Exception: Prelude.tail: empty list
23:58:45 <Lokathor> whop
23:58:56 <cocreature> > drop 1 []
23:58:58 <lambdabot>  []
23:59:38 <Lokathor> right
