00:30:02 <dramforever> yeah I can totally see the pain of not having these as drop-in
00:30:26 <dramforever> Could be why hlint has always been telling us to <> not ++
00:33:20 <ertes-w> helo
00:34:51 <Cale> 250 mail.cale
00:43:43 <RusAlex> Im looking for a simplet Haskell tutorial close to my task. I need to parse stdin line with haskel. There are regexp work required.
00:44:04 <RusAlex> maybe something where to start I can find in the internet
00:46:50 <peddie> RusAlex: I think a lot of Haskell engineers tend to shy away from regular expressions in favor of using the various excellent parsing libraries like megaparsec and trifecta
00:47:23 <dramforever> that doesn't sound like too well suited for Haskell
00:47:43 <RusAlex> oh peddie thank you for your answer, I never heard about another ways ;-) need to read about it it's new for me
00:47:49 <dramforever> RusAlex: Why did you choose Haskell
00:48:04 <RusAlex> dramforever: I want to start the code without unit tests
00:48:05 <peddie> RusAlex:  you can try `System.IO.getLine` to read a line from stdin
00:48:14 <peddie> :t getLine
00:48:15 <lambdabot> IO String
00:48:19 <dramforever> Well
00:48:38 <RusAlex> dramforever: and I want to write code that works and that has own built-in features to keep itself in a good shap
00:48:40 <RusAlex> shape
00:49:00 <dramforever> oh that makes some sense
00:49:13 <dramforever> You know, parse stdin line, regexp, Perl, and it won't go well
00:49:23 <peddie> RusAlex: there are lots of tutorials available on the web for parsing with haskell
00:50:31 <peddie> see e.g. the readme for parsec, the canonical parsing library: https://hackage.haskell.org/package/parsec
00:50:47 <peddie> RusAlex: https://hackage.haskell.org/package/parsec#readme
00:50:48 <Axman6> RusAlex: we run a course where which includes a part on parsing combinators, which we've subtitled "Or, why you'll never use regexes again"
00:50:59 <peddie> or e.g. https://jakewheat.github.io/intro_to_parsing/
00:50:59 <dramforever> I wonder what's a good 'Haskell tutorial' for that, though
00:51:16 <dramforever> RusAlex: So you're new to Haskell?
00:51:48 <RusAlex> dramforever: yes. Im new . But Im keen in this new way of writing programs. With no sideeffects and strong typing
00:52:48 <dramforever> Hmm... non native English here, what does 'keen in' mean? 'love' or 'good at' or something?
00:53:01 <Axman6> RusAlex: Rus = russian? I think there's a somewhat active #haskell.ru (or #haskell-ru) channel on freenode if I remember rightly. Not saying you shouldn't be here, but if I'm right, that will be a useful resource too :)
00:53:01 <RusAlex> interested in
00:53:08 <dramforever> hmm
00:53:58 <peddie> RusAlex: judging by your nick, you may also want to visit https://gitter.im/ruHaskell/home
00:53:59 <RusAlex> Axman6: yes RUS - means Russian . 
00:54:10 <dramforever> RusAlex: turtle sounds like a good choice for 'scripting'
00:54:11 <dramforever> http://hackage.haskell.org/package/turtle
00:54:18 <RusAlex> thank you very much all. you already gave me good starting points here. 
00:54:27 <Axman6> RusAlex: but don't leave here! We're more than happy to help too :)
00:54:40 <peddie> RusAlex: I think that Russian gitter community is more active than the IRC channels at the moment
00:54:42 <Axman6> some concepts may be better explained in your native tongue though
00:54:55 <dramforever> It even has its own tutorial
00:54:58 <dramforever> https://hackage.haskell.org/package/turtle-1.3.6/docs/Turtle-Tutorial.html
00:55:05 <dramforever> RusAlex: This doesn't even require Haskell knowledge
00:55:26 <Axman6> RusAlex: so what sort of parsing do tyou need to do? what format is the text in?
00:55:31 <dramforever> You will miss a lot if you don't get a 'proper' Haskell tutorial at some time though
00:56:47 <RusAlex> Axman6: it's hledger output. 
00:57:29 <RusAlex> I have simple haskell  script to read hledger postings. And I think I will modify it with parsing libs offered here
00:58:53 <dramforever> Oh
00:59:04 <dramforever> That's not very 'new to Haskell'
00:59:46 <Axman6> well, you don't need to know haskell to use hledger
01:00:33 <Axman6> RusAlex: any reason you need to parse its output? Could you use it's code as a library instead? that would be less error prone
01:01:29 <dramforever> This one? https://hackage.haskell.org/package/hledger
01:01:42 <dramforever> Could be a nice parsing exercise though
01:02:04 <Axman6> sure, but easy to get wrong too
01:02:25 <Axman6> particularly since the source of truth is available
01:03:23 <RusAlex> yes 
01:03:32 <RusAlex> Yes the script I have already uses hledger
01:03:46 <RusAlex> but I also will need some. hm... yes I do not need parsing it then
01:03:59 <RusAlex> but then now =)
01:04:20 <RusAlex> sorry confusing you. the goal of my script is to form a ledger-cli posting from STDIN line
01:04:33 <RusAlex> I gave you wrong direction first =)
01:05:07 <dramforever> :)
01:06:57 <RusAlex> so task is originally parse JSON to ledger posting . But I can do some pre-parsing JSON with command line tool like `jq`
01:07:43 <RusAlex> then I would like to have hledger prepare ledger posting. And using hledger lib also can help here. But parsing will be needed though
01:08:05 <RusAlex> some data I only can derive from pure text in line
01:10:04 <Axman6> we also have really good JSON parsing libraries :)
01:15:35 <RusAlex> Axman6: let me start from simple task. I have goog cli tools to parse json 
01:15:52 <RusAlex> need to build new good tool to parse line
01:16:18 <RusAlex> as bash is not good here. Completely do not like it for this bit of task
01:17:12 <RusAlex> btw this channel is crowded 
01:17:43 <RusAlex> can I rely on measuring haskell popularity on this number or I can measure ability to write a irc bot with  haskell ?
01:19:37 <peddie> RusAlex: probably both
01:19:48 <Axman6> it's mostly people here. this channel has an excellent reputation for helping people, so lots of people hang out here
01:21:41 <RusAlex> great 
01:21:52 <RusAlex> stick with it too then
01:25:27 <ertes-w> i didn't find turtle that useful for scripting, because it is highly opinionated in how shell scripts work
01:25:57 <ertes-w> ultimately i just combined 'machines' and 'process'
01:27:53 <slack1256> I didn't find it useful for my reluctance to use runghc for serious scripts. If I already had to write a .cabal file then it is kind of wasted
01:30:23 <Cale> slack1256: What's wasted?
01:33:03 <slack1256> my scripts had a .cabal file with turtles on it (I didn't want to install turtle on my env on nixos)
01:34:35 <slack1256> but having a .cabal file made them a pain to change
01:35:59 <cocreature> stack is kind of nice in that regard since you can pass it packages to install via cli arguments. so you can have something like "stack --resolver whatever --package turtle" as your shebang
01:36:52 <slack1256> nix-shell -i also does that
01:37:04 <cocreature> ah right
01:37:13 <ertes-w> slack1256: i just compile my scripts
01:37:36 <merijn> I just compile my scripts via cabal too
01:37:38 <ertes-w> slack1256: i have a really simple nix expression for that
01:37:41 <merijn> Well "scripts" :p
01:37:55 <merijn> At some point they become to complex to still really be scripts :p
01:39:31 <ertes-w> to me a script is a project that doesn't have a cabal file =)
01:40:28 <merijn> I use cabal even for simple limited use things
01:40:45 <merijn> Or if it's a single file with only base dependencies I'll just use GHC
01:40:46 <srhb> I want a shebang that lazy-compiles my haskell scripts in the nix store
01:40:49 <ertes-w> slack1256: create a directory containing these two files: <https://github.com/esoeylemez/config/blob/master/scripts/Makefile>, <https://github.com/esoeylemez/config/blob/master/scripts/default.nix>
01:40:56 <srhb> Actually, that should be possible, hm
01:41:06 <ertes-w> slack1256: change the default.nix to reflect your dependencies, then just type 'nix-build'
01:41:27 <merijn> ertes-w: What's the added value of nix there?
01:41:36 <ertes-w> merijn: not much
01:41:41 <ertes-w> uniformity, i guess
01:42:08 <ertes-w> i think it's better than a cabal sandbox, because you don't need run-time files, but just a declarative configuration
01:42:19 <ertes-w> sandboxes are more stateful
01:43:37 <merijn> ertes-w: You could use new-build :)
01:43:53 <merijn> ertes-w: No longer have to deal with the sandbox
01:44:04 <ertes-w> merijn: sure, but i'd need to learn it first, and it doesn't seem to provide much of a payoff if you're already using nix =)
01:44:49 <merijn> ertes-w: Well, to be fair there's not much to learn beyond "make two line file" and "run 'cabal new-build'". Actually if you have a cabal file even the two line file is optional :p
01:46:01 <ertes-w> i don't seem to have new-build yet
01:49:23 <slack1256> how is machines different from pipes? as in philosophy
01:49:26 <merijn> ertes-w: I think it first appears in cabal-install 1.24, but the real thing is in cabal HEAD
01:49:41 <merijn> ertes-w: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
01:49:44 <slack1256> pipes are just really clever co-routines. Machines seems to have a different problem that solves
01:50:26 <ertes-w> slack1256: they are equivalent, except that machines allows branching
01:51:00 <ertes-w> slack1256: i prefer the API of machines though
01:51:03 <merijn> ertes-w: My main gripe is that tools like ghc-mod/hdevtools don't work with new-build yet, but after trying for a week I don't have more time to fix them, so I figure if I sell more people on new-build, maybe someone will fix it for me ;)
01:51:53 <ertes-w> merijn: hmm, the only tools i use are hasktags and haskell-mode
01:52:10 <ertes-w> and i don't really *use* hasktags
01:52:18 <slack1256> ertes-w: what is the standard machines-prelude package?
01:52:26 <ertes-w> haskell-mode uses it as a fallback, but that fallback is pretty much never triggered for me
01:52:35 <slack1256> machines-io?
01:52:40 <ertes-w> slack1256: no, machines
01:52:55 <slack1256> it doesn't define any sources though
01:53:02 <merijn> ertes-w: Ah, yeah, but I don't use emacs :)
01:53:04 <ertes-w> the module structure is a bit weird, but
01:53:04 <slack1256> well apart from Foldable types with source
01:53:12 <merijn> ertes-w: Also, haskell-mode presumably needs to be fixed too
01:53:28 <ertes-w> slack1256: yes, machines is kinda barebones
01:53:51 <ertes-w> merijn: probably…  in any case, i don't think as a nix user i will benefit from new-build
01:54:03 <ertes-w> it's easier to sell it to cabal and stack users =)
01:54:35 <merijn> ertes-w: Well, it simplifies certain workflows, such as having multiple inter-dependent packages in the same (or different repos) and working with them without having to setup a sandbox and add-source on everything
01:55:13 <ertes-w> merijn: that works for me with nix…  all i need is a one-line entry to "register" a package =)
01:55:43 <slack1256> that makes me sad :-(
01:56:57 <ertes-w> slack1256: practically speaking you should probably use pipes, unless you're prepared to reinvent some stuff =)
01:57:19 <slack1256> yeah, that is what I use
01:57:30 <ertes-w> i thought about collecting all my Text-based machines into a library machines-text or something, but so far i didn't have the time to do that and write tests and …
01:58:37 <slack1256> machines api has something to rescue. They explain (on the pdfs) how the types should fit together. That is awesome to maintain a high level overview
02:09:47 <mbuf> @quote
02:09:48 <lambdabot> nocotigo says: if you can't tell what encoding the code is in, I'd say you've gone too far
02:11:07 <DollyDuplex> any good way to pass a "large" number of type parameters to a data type? like in C++, where you can go template<typename T> struct { typename T::Foo foo; typename T::Bar bar; };?
02:12:59 <cocreature> DollyDuplex: you could use a single type parameter and type families
02:14:07 <DollyDuplex> i suspected that, but when i just looked it up, it seemed like that's not what type families are for... guess i'll look again
02:14:27 <cocreature> type families are for determining types from other types
02:14:44 <cocreature> so in your case make a Foo type family which maps T to something else
02:15:58 <DollyDuplex> using types as keys, basically?
02:16:38 <merijn> DollyDuplex: What are you actually trying to do?
02:18:09 <DollyDuplex> i have multiple related data types what depend on many parameters and i'm trying to avoid passing an endless list of parameters around all the time
02:18:41 <DollyDuplex> data Foo a b c d e f = One (X a b c d e f) | Two (Y a b c d e f)
02:19:21 <DollyDuplex> kinda trying to roll the "a b c d e f" part into one
02:19:26 <wz1000> DollyDuplex: that is only one data type
02:19:50 <jle`> ( that's some interesting definition of 'endless' you got there :) )
02:20:02 <DollyDuplex> X and Y are the others, they go similarly...
02:20:16 <liste> DollyDuplex: do "data XY = XY a b c d e f" and "data X = X XY" and "data Y = Y XY" ?
02:21:19 <DollyDuplex> wait whaaaaaaat? kind inference actually carries that to the left of the '='?
02:21:37 <jle`> you'd still need the type parameters that way
02:21:50 <jle`> `data XY = XY a b c d e f` is a compiler error
02:24:17 <jle`> but yes if all your constructors are the same, you can factor out the differences
02:24:32 <jle`> data OneOrTwo = One | Two
02:24:40 <ziman> I had a similar problem with my AST type that can have many different flavours (given by different values of different type parameters), as it progresses through the compiler; are there any idioms for that? I just gave up and stopped distinguishing them statically because the noise in the types was not worth it
02:24:46 <jle`> er, hm, they'r enot the same here
02:25:03 <ziman> type families sound like they would work, mapping the stage to the various type parameters
02:25:40 <Cale> DollyDuplex: Are the type arguments related to one another in any way
02:25:41 <Cale> ?
02:26:00 <Cale> DollyDuplex: This might be a good place to use type or data families, depending on the setting.
02:26:26 <ertes-w> DollyDuplex: also check out the dependent-map and dependent-sum libraries
02:26:41 <ertes-w> they cover some uses cases for lots of type arguments
02:27:46 <DollyDuplex> huh, that dependent-map thing sounds interesting
02:29:47 <mbuf> @run map (+1) [1..5]
02:29:49 <lambdabot>  [2,3,4,5,6]
02:30:22 <Cale> > map (+1) [1..5]
02:30:26 <lambdabot>  [2,3,4,5,6]
02:49:27 <DollyDuplex> ok, that *seems* to go in the right direction: https://pastebin.com/sC7mDa02
03:01:11 <DollyDuplex> alright, after fiddling around with it for a while, i'm thinking that type families do what i want (albeit with some wrapping and unwrapping). thanks for pointing me back at what i thought was the wrong approach ^^
03:04:03 <ertes-w> DollyDuplex: you can use DataKinds and a closed type family
03:04:58 <ertes-w> data PersonField = Name | Age
03:05:49 <ertes-w> type family PersonType (a :: PersonField) where PersonType Name = String; PersonType Age = Integer
03:06:26 <ertes-w> data Person (p :: PersonField -> *) = Person { name :: p Name, age :: p Age }
03:06:26 <erisco> I must have missed the part of the conversation where data Struct a b c was ruled out
03:06:30 <ertes-w> DollyDuplex: ^
03:09:31 <DollyDuplex> oooh, that's pretty neat... does away with all the wrapping and unwrapping
03:10:06 <DollyDuplex> erisco: that was pretty much the start of the conversation... if it has much more than three parameters, this quickly becomes cumbersome
03:10:27 <DollyDuplex> and error-prone
03:10:34 <erisco> why? what about a type alias? though I am guessing this was all covered
03:11:05 <erisco> instead of MyParams just have type MyStruct = Struct Int String [Int]
03:11:45 <DollyDuplex> for startes, Struct will pass the whole list to various other types, which will pass it on...
03:12:24 <erisco> okay, so you want a struct of types, fair enough
03:12:34 <DollyDuplex> pretty much
03:13:43 <erisco> would be nice to have that... hm...
03:14:26 <DollyDuplex> if it's any consolation, the language whose compiler i'm implementing has that xD
03:14:47 <erisco> if it isn't already in singletons then you could make a solution in TH
03:15:24 <DollyDuplex> hmmm, i suppose that might be possible
03:16:16 <DollyDuplex> is TH... is there a term for that? "meta turing complete"?
03:16:41 <erisco> TH stands for Template Haskell. I am not sure what else you are asking
03:17:16 <DollyDuplex> i'm aware. basically, i'm asking whether there are things that cannot be done in it
03:17:48 <erisco> sure, lots of things, but in a theoretical computational sense, no, it can do anything
03:18:22 <merijn> erisco: Eh, what can't it do in a practical sense, according to you?
03:18:30 <erisco> you write a Haskell program that outputs Haskell code, and that is essentially what TH is
03:18:54 <erisco> merijn, you can't define and use quasi quoters in the same module, for example
03:19:07 <erisco> not sure if you can do IO either
03:19:20 <Cale> You can do IO, it happens at compile time.
03:19:26 <erisco> okay
03:19:46 <DollyDuplex> oh right, shakespeare-i18n does that, right?
03:20:32 <Cale> A major thing TH is missing in my opinion is a way to get a fresh name that is guaranteed not to conflict with anything from outside TH at all.
03:20:43 <erisco> you can come up with a long list of things TH doesn't do... software cannot have every possible feature
03:21:21 <ventonegro> So TH is not hygienic yet...
03:21:21 <erisco> I was just campaigning a distinction between the theoretical meaning of Turing complete and a practical one
03:21:39 <DollyDuplex> true, but it can still provide ways to "do anything", even if it might be cumbersome due to "lack of features"
03:21:43 <erisco> C++ templates are Turing complete but there is lots you cannot do with them
03:21:58 <erisco> there are things you cannot reflect on at compile time with C++ templates, for example
03:22:08 <Cale> (newName will generate a name which can't be captured, but it can capture other names)
03:22:46 <erisco> a Turing complete program can still be deprived of the information and effects you want it to
03:22:59 <erisco> programming language
03:23:38 <DollyDuplex> that's what i'm saying; save for I/O, you *can* do anything with C++ templates, but many things will make you want to pull your hair out. reflection could be made happen if the client provides the required information
03:23:53 <Cale> TH also randomly lacks support for various language extensions. I couldn't tell you which, but I have bumped into situations where I couldn't construct the syntax tree I wanted.
03:24:09 <Cale> It's usually not too bad there though
03:24:15 <erisco> not requiring the client to provide additional information is something it cannot do
03:24:31 <DollyDuplex> that's something no program can do, "meta" or not
03:25:28 <DollyDuplex> hence the old saying "no input, no output"
03:25:29 <erisco> you cannot, for example, get a list of all defined classes
03:25:49 <erisco> you can define a list of classes, but this isn't the same as having a list of all defined classes
03:25:56 <erisco> whereas you can do this in PHP, for example
03:26:01 <erisco> one of its proudest features
03:26:39 <DollyDuplex> true, but you can still do something that *requires* that list (i.e. work with it); you just need the caller to provide it
03:27:05 <erisco> yes, that is the distinction I am talking about
03:27:13 <erisco> you can do anything yet be deprived of the information or effects you desire
03:28:31 <DollyDuplex> like i said, that's true for any and all programming, so again it's not really template-specific
03:31:34 <DollyDuplex> ah well, so i guess the bottom line is that somebody should write a "type structs" library for haskell :P
03:32:29 <Cale> DollyDuplex: What was your actual application?
03:33:05 <DollyDuplex> same as ziman's: gradually enriching an AST (and other structures) in a compiler
03:34:02 <DollyDuplex> though i supposed the "poor man's solution" might be to just put each enrichment in a seperate Map :P
03:35:07 <Cale> Or just have a single type parameter which gets filled in with a type that perhaps has another type parameter...
03:36:40 <DollyDuplex> but then how to extract that other parameter for purposes of passing it on?
03:37:10 <Cale> Or... work on it from the other direction: which code actually needs to be polymorphic on these annotations, and which cases do you really have?
03:38:31 <DollyDuplex> i'm actually not that far in; i'm just trying to make the whole thing agnostic to the enrichments, so i don't have to redo the whole parser later
03:39:45 <Cale> The worst thing you end up having to write is a function which turns a plainer type into a different, enriched type, but you were sort of going to do that anyway
03:40:42 <Cale> You shouldn't have to worry much about rewriting the parser -- though if you decide you want something different later, perhaps a quick refactor might be needed.
03:40:42 <DollyDuplex> yeh, but if the type is fairly complex, having to define a "slightly different, but mostly the same" type for each and every type involved would be a right pain
03:42:59 <Cale> Sure, but do you really have 6 completely different kinds of unrelated annotations which vary independently?
03:44:08 <DollyDuplex> well... yeah, pretty much
03:46:31 <Cale> So, like, modules, declarations, expressions... some other things?
03:52:43 <mbuf> where do I place the quotes file when setting up lambdabot? Using it in ~/.cabal/share/x86_64.../lambdabot-version/State/ does not seem to pick it up
03:54:49 <DollyDuplex> yeah, many other things... going over it, i can spot Expression, ImportSpec, HintObject, HintValue, Definition, TypeDefinition, MixinDefinition, FunctionDefinition, SupertypeClause, MethodDefinition, MethodSpecification, FunctionParameter, ParameterTypeConstraint, ClassOrMixinMember, TemplateDefinition, CategoricDomainParameter, IfBranch, MatchExpression
03:55:59 <AWizzArd> fmap/liftM liftM2 & Co – they lift functions. But the transformer’s `lift` function – this one lifts values into a certain transformer monad? Is that correct?  (Yeah I know, functions are also just ordinary values)
03:56:43 <ertes-w> AWizzArd: 'lift' is the actual monad morphism:  lift :: (Monad m) => m a -> T m a
04:07:32 <Cale> DollyDuplex: So yeah, if you really need different annotations for all those different things, having a single annotation type family per "stage" is probably the way to go
04:08:27 <DollyDuplex> yep, imagine the nightmare of having to pass all those annotation types around, seeing as those types can reference each other
04:08:42 <Cale> DollyDuplex: and it'll take a type parameter of some kind... I suppose you could use DataKinds here, and just define an enumeration type with nullary constructors for each of those different syntactic classes
04:09:25 <DollyDuplex> that's what i'm going with right now
04:31:54 * hackagebot forma 0.2.0 – Parse and validate forms in JSON format – https://hackage.haskell.org/package/forma
05:16:50 <DollyDuplex> ertes-w: In your example, how would you pass PersonType to Person? just putting Person PersonType doesn't seem to work
05:17:09 <ertes-w> DollyDuplex: oh, right
05:17:23 <ertes-w> there was a trick to make it work, but i don't remember it
05:26:53 <matheus23> hi has anyone experience with GHCJS?
05:27:24 <srhb> matheus23: Some, but only via reflex
05:27:38 <matheus23> i want to use ghcjs-dom. And i successfully got the ghcjs-dom-hello example working. I just dont know how to continue now
05:27:38 <matheus23> https://hackage.haskell.org/package/ghcjs-dom
05:27:47 <matheus23> the page for ghcjs-dom doesnt have any docs
05:28:06 <matheus23> I just care about the modules and types. Where can i find them? :( Can i generate them myself? if so, how?
05:29:35 <matheus23> I cant look at the source code either, because it's.. empty? https://github.com/ghcjs/ghcjs-dom/tree/master/ghcjs-dom i guess it's generated
05:30:21 <ertes-w> matheus23: one option is to build it locally with docs enabled
05:30:21 <srhb> matheus23: The actual functions are in jsaddle or ffi
05:30:48 <ertes-w> matheus23: the other option is to load it into GHCi and use :bro(wse) and :t
05:30:54 <matheus23> hm
05:31:17 <ertes-w> matheus23: GHCJS' interactive mode worked for me last time i checked:  ghcjs --interactive
05:31:29 <matheus23> well it's not in ghcjs-dom-jsffi, cause I use functions from GHCJS.DOM.Document in the example, but there is no such module in ghcjs-dom-jsffi
05:31:37 <matheus23> okay. I'll try
05:32:25 <matheus23> ertes-w: ah shoot. I use ghcjs for ghc-8.0.1, and it hasnt got support for --interactive yet ... :(
05:32:48 <matheus23> ghcjs-0.2.1.9007019-8.0.1.bin: --interactive is not yet supported.
05:34:58 <matheus23> how do i build hackage docs locally?
05:37:43 <ertes-w> matheus23: depends on your build system (cabal-install/nix/setup.hs/stack/…)
05:38:48 <Athas> 'stack haddock' works really well.
05:43:21 <matheus23> ertes-w: so I clone ghcjs-dom, try to build it with stack and do "stack haddock"?
05:44:10 <nickhs> Hi there - I'm trying to use setters for the first time alongside wreq. I have a list of key, value pairs (as tuples) that I'd like to set on wreq's request object. I think I need to use `over` in lenses but I'm not sure how?
05:44:31 <nickhs> alternatively I can make a list of partially applied setters, but I'm not sure how to apply them to wreq's default object?
05:45:05 <ertes-w> matheus23: if you use stack, then yeah…  there is probably also a way to enable documentation building in general
05:45:13 <nickhs> (to be clearer, I'm trying to modify the requests headers)
05:46:41 <ertes-w> :t foldl' (\r (k, x) -> (k .~ x) r)
05:46:43 <lambdabot> Foldable t => s -> t (ASetter s s a b, b) -> s
05:46:49 <ertes-w> nickhs: ^
05:52:53 <nickhs> ertes-w: apologies for being thick, where can I find that function? I don't see it in https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Setter.html?
05:53:21 <BernhardPosselt> :t pure
05:53:23 <lambdabot> Applicative f => a -> f a
05:53:44 <ertes-w> nickhs: hmm?  foldl' is from Data.Foldable
05:53:52 <BernhardPosselt> is there a way to get a quick glance at pure for List with a command?
05:54:29 <nickhs> ertes-w: oh I'm with you, you're saying I should take my list of partially applied setters and reduce them with fold?
05:54:40 <nickhs> (against defaults)
05:55:45 <ertes-w> nickhs: maybe i misunderstood your question
05:55:52 <BernhardPosselt> > pure 3 :: List Int
05:55:54 <lambdabot>  error:
05:55:54 <lambdabot>      • Pattern synonym ‘List’ used as a type
05:55:54 <lambdabot>      • In an expression type signature: List Int
05:56:05 <BernhardPosselt> > pure 3 :: [Int]
05:56:07 <lambdabot>  [3]
05:56:23 <BernhardPosselt> i suppose pure just takes one parameter for a list right?
05:56:32 <ertes-w> > foldl' (\r (k, x) -> (k .~ y) r) (1, 2) [(_1, 5), (_2, 6)]
05:56:34 <lambdabot>  (y,y)
05:56:38 <ertes-w> err
05:56:40 <ertes-w> > foldl' (\r (k, x) -> (k .~ x) r) (1, 2) [(_1, 5), (_2, 6)]
05:56:43 <lambdabot>  (5,6)
05:56:46 <ertes-w> nickhs: ^
06:01:18 <BernhardPosselt> whats a common (as in: used very often in your work) usecase for <*>
06:01:46 <BernhardPosselt> i know how it works but i cant think of a good example to explain it
06:02:14 <Athas> Applying a monadic function to the subcomponents of a constructor.
06:02:27 <Athas> F <$> h x <*> h y <*> h z
06:03:07 <BernhardPosselt> Athas: you mean building the type partially?
06:03:31 <Athas> No, it is fully constructed.
06:03:44 <BernhardPosselt> i dont get the term subcomponents
06:04:18 <Athas> data F = F Int Int Int
06:04:27 <BernhardPosselt> each Int is a subcomponent?
06:04:46 <Athas> Yes.  I think 'field' is more common terminology.
06:04:53 <Athas> But I'm not sure I like that when they are not named.
06:06:01 <BernhardPosselt> F (h x) (h y) (h z) would work as well right?
06:06:34 <BernhardPosselt> ah right, monadic
06:10:20 <cocreature> BernhardPosselt: Functor allows you to lift a function of one argument. Applicative allows you to lift functions that take multiple arguments. because in Haskell we curry all definitions you end up with that slightly weird signature so things work out and you can do "f <$> x <*> y" instead of "liftA2 f x y"
06:11:58 <BernhardPosselt> right, im kinda thinking of a function that returns something like Just (+1)
06:12:08 <BernhardPosselt> then im wondering why I'd ever return such a type
06:12:10 <nickhs> ertes-w: that worked, thanks!
06:12:52 <BernhardPosselt> only usecase would be something like matching a value to a function and return Nothing if no value can be matched
06:13:00 <BernhardPosselt> cant think of a common scenario
06:13:39 <cocreature> I don’t think there really is a common scenario. sometimes it’s useful but 95% of the time you use <*> on the result of "f <$> x" for some f and x
06:14:45 <BernhardPosselt> ok, so its more of a style thing
06:15:19 <BernhardPosselt> as in: i just want to pipe this stuff instead of using parenthesis
06:19:32 <merijn> BernhardPosselt: Well, imagine a datatype "data User = User { address :: Address, phone :: PhoneNumber }" and having "checkAddress :: String -> Maybe Address" and "checkPhone :: String -> Maybe PhoneNumber"
06:20:03 <merijn> BernhardPosselt: Now you can "User <$> checkAddress addrString <*> checkPhone phoneString" and get "Maybe User" as a result
06:22:52 <Gurkenglas> > ((+) <$> Just 1, (+) <$> Just 1 <*> Just 2) -- BernhardPosselt
06:22:54 <lambdabot>  (Just <Integer -> Integer>,Just 3)
06:35:32 <BernhardPosselt> thanks!
06:35:43 <BernhardPosselt> the address stuff made sense :)
06:41:21 <DollyDuplex> ertes-w: ok, after much googling around, i found it: you have to wrap the use of PersonType into a newtype, because the type family cannot be partially applied (and neither can type synonyms), but the newtype can
07:38:28 <bbear> hello 
07:38:30 <bbear> (w, h)  <- tuplify2 <$> words <$> getLine
07:39:35 <bbear> The fact that I have to use <$> is because I am in the IO monad, right ?
07:40:06 <bbear> The equivalent of this function for a basic String would be (tuplify2.words) ?
07:41:41 <srhb> bbear: Yes.
07:41:41 <matheus23> exit
07:44:47 <kuribas> Something I miss from C is variable update.  In C when updating a variable, you cannot accidentaly use the old value.
07:45:00 <kuribas> Which is something that bites me often in haskell.
07:45:30 <kuribas> like let c2 = update c in using c -- instead of c2
07:45:46 <ertes-w> DollyDuplex: no, someone found a way to do it without the wrapping
07:46:31 <ClaudiusMaximus> kuribas: do-notation and shadowing in  Identity a  might help?   do{  ... ; c <- return $ update c ; ... }
07:47:00 <Cale> kuribas: You can use State if you're doing a lot of that kind of thing and it's getting hard to ensure that you're using the correct last value.
07:47:02 <kuribas> ClaudiusMaximus: perhaps, though I'll get warnings about shadowing
07:47:31 <Cale> Alternately, you can start a new function, passing the updated value along to it, so that the old thing is no longer in scope
07:49:05 <Cale> In fact, that's a pretty decent way to translate imperative style to functional: points of control become separate functions, mutable variables in scope become function parameters
07:52:17 <bbear> kuribas: there is no « variable » in haskell
07:52:54 <kuribas> bbear: I am refering to C variables
07:53:32 <bbear> your complaint was about the code you write in Haskell or the process to code in Haskell ?
07:53:57 <kuribas> it's an idiom I sometimes miss in haskell.
07:56:37 <bbear> :t (=<<) (do;return;)
07:56:38 <lambdabot> Monad m => m b -> m b
07:56:50 <bbear> :t Nothing
07:56:51 <lambdabot> Maybe a
07:57:04 <bbear> :t (>>=) Nothing
07:57:06 <lambdabot> (a -> Maybe b) -> Maybe b
07:57:11 <ventonegro> kuribas: I heard linear types are coming
07:57:18 <kuribas> great :)
08:02:38 <bbear> how would you build a path-tree in Haskell
08:04:06 <bbear> I mean -- I see this is easy -- but I have a problem because I don't want to get back to an already visited node
08:04:22 <bbear> should I keep a list of visited nodes separately from the tree ?
08:06:07 <Cale> bbear: Perhaps use a Data.Set of visited nodes
08:06:52 <bbear> fine
08:10:14 <bbear> do we have 2D vectors in Haskell ?
08:10:47 <ertes-w> bbear: see the 'linear' library
08:12:38 <ertes-w> kuribas: use a state monad
08:13:11 <ertes-w> > execState (do modify (1 +); modify (^2); modify (2*)) 5
08:13:13 <lambdabot>  72
08:13:43 <kuribas> bbear: I have a library with 2D vectors...
08:13:59 <ertes-w> kuribas: if you really must have the same syntax, you can use lenses
08:14:12 <kuribas> hm okay
08:14:32 <ertes-w> > let c = id in execState (do c += 1; c ^= 2; c *= 2) 5
08:14:34 <lambdabot>  72
08:14:41 <ertes-w> kuribas: ^
08:15:25 <kuribas> And two variables?
08:15:50 <ertes-w> > let c = _1; d = _2 in execState (do c += 1; d ^= 2; c *= 2) (5, 6)
08:15:52 <lambdabot>  (12,36)
08:15:56 <ertes-w> kuribas: ^
08:16:35 <ertes-w> you can even have infinitely many variables =)
08:17:45 <kuribas> let c = _1; d = _2; e = _3 in execState (do c+= 1; d *= 2; e = view c+view d) (5, 6, 7)
08:17:49 <kuribas> > let c = _1; d = _2; e = _3 in execState (do c+= 1; d *= 2; e = view c+view d) (5, 6, 7)
08:17:51 <lambdabot>  <hint>:1:62: error:
08:17:51 <lambdabot>      parse error on input ‘=’
08:17:51 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:18:08 <ertes-w> > execState (do ix 0 += 1; ix 1 ^= 2; ix 5 *= 2) (repeat 10)
08:18:11 <lambdabot>  [11,100,10,10,10,20,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
08:18:22 <ertes-w> kuribas: ^ infinitely many variables =)
08:18:32 <kuribas> right
08:18:39 <ertes-w> the syntax for assignment is (.=)
08:18:43 <ertes-w> s/syntax/function/
08:18:49 <ertes-w> all those operators are regular functions in reality
08:19:11 <ertes-w> also you can't refer to old values the way you could in C
08:19:43 <bbear> is that possible to have arrays in strict haskell ?
08:19:54 <bbear> I mean what I plan to do is to make in-place modification to the array.
08:19:57 <ertes-w> > execState (do _1 *= 2; use c >>= (_2 +=)) (1, 1)
08:20:00 <lambdabot>  error:
08:20:00 <lambdabot>      • Couldn't match type ‘Expr’
08:20:00 <lambdabot>                       with ‘(t -> Const t t) -> (t1, t) -> Const t (t1, t)’
08:20:01 <ertes-w> err
08:20:05 <ertes-w> > execState (do _1 *= 2; use _1 >>= (_2 +=)) (1, 1)
08:20:08 <lambdabot>  (2,3)
08:20:47 <ertes-w> kuribas: the lenses (the "lvalues") aren't actually the state *values*, but rather represent a kind of "pointer" into the current state
08:20:56 <ertes-w> 'use' reads the current state
08:21:05 <ertes-w> > evalState (use _1) (1, 2)
08:21:07 <lambdabot>  1
08:21:10 <ertes-w> > evalState (use _2) (1, 2)
08:21:11 <kuribas> > let c = _1; d = _2; e = _3 in execState (do c += 1; d *= 2; set e =<< (+) <*> use c <$> use d) (5, 6, 7)
08:21:12 <lambdabot>  2
08:21:14 <lambdabot>  error:
08:21:14 <lambdabot>      • Couldn't match type ‘s1 -> t0’
08:21:14 <lambdabot>                       with ‘StateT (t2, t1, t) Identity a1’
08:21:27 <ertes-w> kuribas: i suggest that you take a lens tutorial
08:22:14 <ertes-w> kuribas: although your mistake there is really minor
08:22:20 <matheus23> quick question: How do i create my own ReaderT instance based on another monad? (In my example JSM) I tried this: type Canvas a = ReaderT Type CanvasRenderingContext2D JSM a
08:22:26 <ertes-w> kuribas: you confused (<*>) and (<$>)
08:22:48 <bbear> what exactly is a « non-strict array » ?
08:23:00 <kuribas> > let c = _1; d = _2; e = _3 in execState (do c += 1; d *= 2; set e =<< (+) <$> use c <*> use d) (5, 6, 7)
08:23:02 <lambdabot>  error:
08:23:02 <lambdabot>      • Couldn't match type ‘s0 -> t0’
08:23:02 <lambdabot>                       with ‘StateT (t1, t1, t) Identity a1’
08:23:02 <ertes-w> bbear: an array of boxes
08:23:19 <ertes-w> :t set
08:23:21 <lambdabot> ASetter s t a b -> b -> s -> t
08:23:32 <ertes-w> kuribas: try:  (e .=) instead of (set e)
08:23:56 <kuribas> right, set doesn't work with State...
08:24:00 <kuribas> > let c = _1; d = _2; e = _3 in execState (do c += 1; d *= 2; (e .=) =<< (+) <$> use c <*> use d) (5, 6, 7)
08:24:02 <lambdabot>  (6,12,18)
08:24:17 <matheus23> bbear: non-strict means that it's elements are evaluated "lazily": Only once you access array elements, its values get evaluated
08:26:30 <kuribas> ertes-w: lenses are quite newbee unfriendly, especially the line-noise versions...
08:26:46 <bbear> cool
08:28:16 <kuribas> bbear: strict means the value itself is used, which means it must be evaluated when the datatype is created, because haskell has no way to signal it's not evaluated yet.
08:28:40 <matheus23> okay nevermind, I've solved my problem. Somehow the "Type" parameter is not needed. so the type alias should be: type Canvas = ReaderT CanvasRenderingContext2D JSM a
08:28:45 <matheus23> type Canvas a =*
08:29:27 <ertes-w> kuribas: i would consider lenses to be an advanced feature…  but you get a really powerful feature in return that extends far beyond what you can do in imperative languages
08:30:00 <mnoonan> so I heard a new category theory joke..
08:30:11 <mnoonan> what do you call somebody who reads a category theory article?
08:30:21 <ertes-w> > execState (do filtered even ^= 2; filtered odd += 100) [1..]
08:30:21 <kuribas> ertes-w: they are like xml on steroids
08:30:26 <lambdabot>  error:
08:30:26 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M277753934934...
08:30:26 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
08:30:34 <mnoonan> "a co-author"
08:30:57 <ertes-w> > execState (do filtered even ^= 2; filtered odd += 100) [1..] :: [Integer]
08:31:00 <lambdabot>  error:
08:31:00 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘^=’
08:31:00 <lambdabot>      • In a stmt of a 'do' block: filtered even ^= 2
08:31:07 <ertes-w> err
08:31:15 <ertes-w> > execState (do traverse . filtered even ^= 2; traverse . filtered odd += 100) [1..] :: [Integer]
08:31:17 <lambdabot>  [101,4,103,16,105,36,107,64,109,100,111,144,113,196,115,256,117,324,119,400,...
08:31:21 <ertes-w> kuribas: ^
08:31:36 <ertes-w> this is a *basic* example of what they can do =)
08:32:04 <ertes-w> > execState (zoom traverse (do filtered even ^= 2; filtered odd += 100)) [1..] :: [Integer]
08:32:07 <lambdabot>  *Exception: stack overflow
08:32:14 <ertes-w> oh, that looks like a bug
08:32:16 <kuribas> ertes-w: isn't filtered an illegal lens?
08:32:23 <ertes-w> kuribas: it's not a lens at all
08:32:26 <ertes-w> it's a traversal
08:32:33 <kuribas> an illegal traversal then?
08:32:42 <ertes-w> why?
08:33:26 <kuribas> because the documentation says so?
08:33:36 <kuribas> "Note: This is not a legal Traversal, unless you are very careful not to invalidate the predicate on the target."
08:33:48 <ertes-w> ah, indeed
08:34:18 <ertes-w> you must only ever map a true value to another true value
08:34:26 <ertes-w> filtered even += 1  -- this one would be illegal
08:34:41 <ertes-w> kinda picked an unfortunate one there =)
08:36:20 <kuribas> just like partsOf, which is pretty cool otherwise
08:37:03 <ertes-w> there is even a whole study into improper optics
08:37:09 <kuribas> > over (partsOf each) reverse (1, 2, 3)
08:37:11 <lambdabot>  (3,2,1)
08:37:21 <ertes-w> tekmo has used them heavily in pipes-group
08:37:31 <ertes-w> deliberately improper lenses that is
08:46:42 <dmwit> What am I doing wrong in this short snap snippet? http://lpaste.net/356934
08:46:58 <dmwit> I thought I defined a route for localhost:8000/top, but when I try visiting that in my browser it 404s.
08:47:56 <glguy> dmwit: Use a leading / ?
08:49:27 <dmwit> no change
08:50:28 * hackagebot codec-rpm 0.1.2 – A library for manipulating RPM files – https://hackage.haskell.org/package/codec-rpm
08:51:06 <glguy> dmwit: Does it change anything to rearrange ln4 as route [("top", method GET (writeBS "OK"))] ?
08:51:14 <dmwit> Yes, that works.
08:51:41 <dmwit> Oops, sorry, I spoke too soon.
08:51:45 <dmwit> That does not work.
08:51:54 <dmwit> (I have to *also* delete the following line.)
08:52:39 <c_wraith> dmwit: you have to compose your route alternatives with <|>
08:52:49 <c_wraith> dmwit: otherwise, it just uses the last one provided.
08:53:07 <c_wraith> dmwit: so in your original, it was throwing away the GET routes
08:53:07 <dmwit> ...that makes sense.
08:53:21 <bbear> lazy
08:54:08 <dmwit> c_wraith: Perfect. Using asum now, and very happy.
08:54:58 <c_wraith> actually, it didn't throw them away.  It was actually worse than that.
08:55:08 <c_wraith> the routing combinators cause the handler to fail if they don't match.
08:55:11 <bbear> I am faced with a dilemna. I want to code a path lookup algorithm in a 2D labyrinth.
08:55:18 <c_wraith> You had two routing combinators that were mutually exclusive
08:55:21 <bbear> I need to get all the output from the labyrinth
08:55:28 <c_wraith> So no request could succeed.
08:56:15 <c_wraith> Anyway, yeah.  Alternative.  "if that last handler didn't work, try this one"
08:57:08 <bbear> I could 1) build the graph corresponding to the connected region on which to make the search, then use a standard algorithm from the Haskell library or 2) build a tree myself, discarding visited nodes and null outcomes, but it means to keep a data structure as an accumulator to keep track of the already visited nodes.
08:57:16 <tabaqui> I just started to understand gadt
08:57:32 <bbear> 1) sounds like i will go in the Haskell std lib and 2) sounds like I am going to code more. What would I do ?
08:57:37 <tabaqui> and it seems to me useless in compilation
08:58:13 <tabaqui> many examples start with "lets construct lists, in which 'head empty' is illegal"
08:58:24 <c_wraith> tabaqui: conceptually, the interesting thing about a GADT is that matching on a particular constructor makes additional type information available in that case.
08:58:27 <tabaqui> but we cannot even build one of them in runtime
08:58:47 <dmwit> bbear: That seems like a good excuse to learn fgl!
08:59:07 <c_wraith> tabaqui: So you can have branches with different types (in one way or another) that still unify correctly.
08:59:16 <glguy> tabaqui: That sounds incorrect, GADT values can be constructed at runtime
08:59:28 <tabaqui> c_wraith: this is handy, but doesn't get any safety to us
08:59:42 <tabaqui> glguy: well, I have different Number types
08:59:50 <tabaqui> Zero type, Succ Zero and other
09:00:02 <tabaqui> how can I convert then into usual Int?
09:00:06 <tabaqui> *them
09:00:17 <glguy> tabaqui: It sounds like you just have more to learn. Do you have some code you're working on to go along with your questions about the topic?
09:00:40 <tabaqui> Typing the technical interview
09:00:50 <tabaqui> from Aphyr
09:01:03 <dmwit> I don't think that series of posts from Aphyr is intended to be taken 100% seriously.
09:01:04 <tabaqui> but in comments I don't get any answer for my questions
09:01:16 <glguy> tabaqui: That's a pretty terrible example, actually
09:01:29 <tabaqui> en.wikibooks.../gadt
09:01:54 <glguy> tabaqui: I don't think that that blog post even has any GADTs in it
09:01:59 <tabaqui> first google page by "gadt haskell", actually
09:02:15 <tabaqui> glguy: why not?
09:02:23 <glguy> tabaqui: Because the author didn't use any
09:02:36 <tabaqui> she solves a problem, just asking for the type of solution
09:02:53 <glguy> tabaqui: Sure, that's just not related to GADT
09:03:08 <tabaqui> glguy: ah, I didn't notice that)
09:03:17 <tabaqui> she doesn't use gadt syntax, yes
09:03:44 <glguy> tabaqui: Right, neither defines nor uses any GADT
09:03:46 <tabaqui> fine, from what can I start?
09:04:14 <tabaqui> *where
09:04:17 <erisco> first define Nat, then define the Lte relation on them
09:04:48 <cocreature> richard eisenberg has a great talk on gadts
09:04:59 <erisco> or make an eDSL... say a calculator
09:05:45 <tabaqui> I don't know what the "thing" you just said little kid
09:05:51 <monochrom> I learned GADTs from the GHC user's guide.
09:06:08 <cocreature> https://www.youtube.com/watch?v=6snteFntvjM that’s the one
09:06:28 <erisco> tabaqui, me?
09:07:07 <tabaqui> erisco: https://www.youtube.com/watch?v=7Dt5Nf7ct5c
09:07:17 <monochrom> P.S. You can simply look at what extensions are not turned on in «Typing the technical interview» to see that it doesn't do GADTs. Please don't use Google as evidence.
09:07:20 <tabaqui> cocreature: that is something, thanks
09:08:01 <tabaqui> monochrom: but GADTs was turned on
09:08:30 <tabaqui> ah, oh
09:08:31 <tabaqui> wait
09:08:38 <tabaqui> I was sure...
09:09:05 <monochrom> FWIW just last night I was Googling for Rutger Dijkstra and it returned tons of Rutger Dijkstra's not in my mind.
09:09:35 <erisco> tabaqui, have you worked with DataKinds?
09:10:05 <monochrom> And then I also wanted to Google for my highschool classmate, and I entered his Chinese name, and Google returned a famous revolutionary from the 1900's.
09:10:24 <bbear> how can you print the list of imported function in ghci ?
09:10:35 <bbear> (and eventually interactive documentation)
09:10:57 <tabaqui> erisco: nope
09:11:52 <monochrom> Here is a puzzle for you. If you Google for "flat earth", will you get more pro-flat-earth hits, or will you get more con-flat-earth hits?
09:12:23 <erisco> have you made a language of some sort? an interpreter?
09:12:33 <cocreature> bbear: :browse does that but it won’t show you docs
09:12:59 <monochrom> Here is a more on-topic puzzle. If you Google for "haskell existential type", will the 1st hit be one that teaches you haskell existential type, or one that teaches you not to use haskell existential type?
09:13:14 <monochrom> What is the semantics of "1st hit" anyway?
09:13:37 <bbear> https://wiki.haskell.org/Existential_type#Introduction_to_existential_types
09:14:02 <tabaqui> erisco: me? I think I didn't
09:15:02 * hackagebot pdfname 0.1.3 – Name a PDF file using information from the pdfinfo command – https://hackage.haskell.org/package/pdfname
09:16:21 <erisco> tabaqui, do you see how Maybe constructs a family of types?
09:17:21 <tabaqui> maybe, I'm not sure, we're speaking on the same language
09:17:34 <erisco> it gives you types such as Maybe String, Maybe Int, and so on
09:17:37 <tabaqui> anyway, I didn't think in this sort
09:17:59 <tabaqui> it's basic haskell types
09:18:13 <tabaqui> *haskell type system
09:18:19 <tabaqui> of course
09:18:58 <erisco> now suppose we have some type Maybe A. what are the ways you can construct this?
09:19:04 <erisco> (speaking of terms now)
09:19:13 <tabaqui> Nothing, Just a
09:19:15 <tabaqui> a :: A
09:19:38 <tabaqui> Nothing :: Maybe a, Just :: a -> Maybe a
09:19:46 <tabaqui> I've read GADTs on wikibooks
09:20:19 <erisco> correct, so here is what GADTs change: we can have a type constructor like Maybe, lets call ours Foo, where we have know more about A to know how to construct Foo A!
09:20:27 <erisco> (I am letting "A" be a variable for some concrete type here)
09:21:05 <erisco> we can have data constructors that only construct some Foo's
09:21:15 <erisco> whereas, for example, Nothing and Just construct all the Maybe's
09:21:55 <tabaqui> ...
09:21:56 <erisco> data IntOrString a where AnInt :: Int -> IntOrString Int; AString :: String -> IntOrString String;
09:22:04 <erisco> consider that example
09:22:18 <tabaqui> yes, I'm still fine with it
09:22:30 <erisco> AnInt only constructs the IntOrString Int and AString only constructs the IntOrString String
09:22:37 <erisco> and all the other IntOrString A's are not constructible
09:22:39 <tabaqui> for now, I've seen one thing, that was impossible to me before
09:22:52 <tabaqui> "type incapsulation" inside GADT
09:22:58 <erisco> so there are two ways this helps us
09:23:11 <tabaqui> and I still cannot write signature function to f.e. print different types
09:23:40 <erisco> one way is I am given a term of a type, say x :: IntOrString Int, and because I know this type I know that x must be constructed by AnInt
09:23:57 <erisco> so when I do case analysis I only have to consider that case, and Haskell actually knows this
09:25:13 <erisco> the other way is that I have an x :: IntOrString a, so it can be AnInt or AString, and once I match on one of those constructors I then have determined the type
09:25:52 <tabaqui> how this construction could be valud?
09:25:55 <erisco> so in other words,  case x of AnInt i -> {- we have determined x :: IntOrString Int -}; AString s -> {- we have determined x :: IntOrString String -}
09:25:57 <tabaqui> data Foo where Foo :: a -> Foo
09:26:13 <tabaqui> and "Foo 1", "Foo 'a'" have the same type
09:26:15 <erisco> and Haskell will actually refine the type in that way
09:27:02 <tabaqui> not much complicated
09:27:03 <erisco> tabaqui, yes, they do. What do you mean by how it can be valued?
09:27:11 <tabaqui> *valid
09:27:14 <tabaqui> sorry
09:27:35 <erisco> well I don't see the problem
09:27:39 <tabaqui> we have different data with the same type
09:27:47 <erisco> where?
09:27:52 <tabaqui> Foo 1, Foo 'a'
09:27:58 <erisco> both those have type Foo
09:28:05 <tabaqui> hmm
09:28:09 <tabaqui> contrintuitive
09:28:09 <erisco> I don't really get the question
09:28:49 <erisco> okay, well, it is maybe simpler than you think
09:29:00 <erisco> Foo takes something of any type and makes a Foo
09:29:02 <monochrom> "data Foo where Foo :: a -> Foo" is not a very illustrative example. It doesn't use what's extra in GADTs. Use erisco's example. (Why not?)
09:29:22 <erisco> so when we pattern match on Foo we get a value of some type, but we know not what type
09:29:34 <erisco> if I give you a value that has an unknown type, what can you do with it?
09:29:37 <erisco> answer: nothing :P
09:30:24 <Xion__> Hah, I was about to ask a question about how I can do   fooField foo   on data Foo = Empty | WithField { fooField :: a }  but the backscroll answered me :)
09:31:09 <monochrom> Suppose you have a function "gee :: IntOrString Int -> Whatever" which insists on wanting IntOrString Int not IntOrString AnythingElse. Then "case x of AnInt i -> gee x; ..." is legal.
09:31:37 <monochrom> which was erisco's point about "refine the type of x after pattern matching".
09:31:47 <monochrom> With your Foo you won't see this.
09:32:01 <erisco> I have explained ADTs before but  not GADTs... trial run :P
09:32:08 <tabaqui> now I think that GADTs give us just much polymorphism
09:32:49 <tabaqui> I'll look at the papers above, but it seems, I wrote the wrong answer
09:32:50 <Xion__> monochrom: Yeah but I got an error about incomplete patterns since a function taking Foo didn't cover the Empty case. And then I looked up another function taking Foo and saw that it doesn't cover it either and was confused.
09:33:03 <Xion__> (Turns out the other one *does* covert it, via a clause w/ a pattern guard)
09:33:08 <monochrom> Xion__: Ah I mean tabaqui's Foo.
09:33:15 <Xion__> Oh, k.
09:33:29 <monochrom> This is what goes wrong when every programmer says "foo".
09:33:40 <cocreature> yeah why don’t we use Bar
09:33:55 <monochrom> I have even seen the same person using "foo" for two unrelated things within 5 minutes.
09:34:06 <monochrom> WHAT'S WRONG WITH YOU PEOPLE?!
09:34:09 <tabaqui> baz it the third and last word
09:34:20 <tabaqui> *"baz" is the
09:34:29 <crobbins_> quux
09:34:36 <tabaqui> we have no any other variables here
09:34:36 <erisco> defining Nat and Lte is to create a type Lte :: Nat -> Nat -> * where the only constructible Lte x y are those such that x <= y
09:35:30 <erisco> and the eDSL example is to show how you can hijack the Haskell type system for your own language
09:36:46 <erisco> you see a lot of stringly typed embedded languages... a classic being SQL strings
09:36:56 <crobbins_> class Foo { def foo = Foo.FOO } ; object Foo { def FOO = new Foo.foo }
09:37:17 <cocreature> one of the things that I really like about richards talk is that it shows you how you can convert the non-GADT representation to the GADT or an error. he builds up an stlc interpreter iirc and then his typechecker spits out the GADT version
09:37:17 <erisco> well, with GADTs you can instead give types to your language that make sense... certainly better than just String :)
09:37:56 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg84162.html
09:38:48 <orzo> I'm looking for the type-level naturals in base.  I see GHC.TypeLits, but it is a GHC.* package and the doc implies there's some other interface.
09:40:40 <cocreature> orzo: I think the docs are a bit misleading. afaik it’s the only interface in base. there are some other packages that help, e.g., ghc-typelits-natnormalise but they’re not part of base
09:41:43 <orzo> thanks
09:43:08 <monochrom> I think the doc just implies "maybe another module name in the future"
09:43:38 <orzo> well it was enough to send me searching
09:43:46 <monochrom> Case in point: For a little while in the past, "Constraint" was in a GHC.* module too.
09:44:40 <monochrom> Now it's also in Data.Kind
09:45:21 <cocreature> huh I didn’t know that. I still import it from GHC.Exts
09:45:36 <monochrom> Expect API changes to be like generational garbage collection. GHC.* is the nursery.
09:46:21 <orzo> can you imagine monochrome trying to communicate outside of #haskell?
09:46:34 <monochrom> Yes, I can.
09:46:42 <cocreature> I don’t think monochrom exists out of #haskell
09:46:47 <monochrom> haha
09:46:52 <cocreature> he’s trapped here
09:47:40 <monochrom> But generational garbage collection is supposed to be common programming knowledge. Even the #php people would understand.
09:48:13 <monochrom> I mean I wouldn't bring it up in #physics... (But there I would bring up complex numbers.)
09:48:29 <cocreature> you’re vastly overestimating the knowledge of programmers
09:48:57 <c_wraith> monochrom: from my experience, "booleans are normal values" isn't common programming knowledge.
09:49:04 <tabaqui> grep monochrom weechat.irc.freenode.#haskell.weechatlog | grep joined
09:49:19 <tabaqui> ez
09:49:20 <c_wraith> The amount of times I see if (a) then b = true; else b = false; ...
09:49:44 <monochrom> c_wraith: Oh isn't that interesting? Because the converse "all values can be regarded as booleans" is common religious belief.
09:50:05 <erisco> no monochrom, it is 1's and 0's, everything is just 1's and 0's
09:50:24 <tabaqui> but boolean has third value
09:50:25 <erisco> no one knows what a "boolean" is unless they've been taught about BOOLEAN searching
09:50:28 <tabaqui> FileNotFound
09:50:43 <tabaqui> http://thedailywtf.com/articles/What_Is_Truth_0x3f_
09:51:27 <cocreature> true, false, null :)
09:51:33 <monochrom> > chr 0x3f
09:51:35 <lambdabot>  '?'
09:52:06 <erisco> true, false, NaB
09:52:15 <orzo> I think Data.Kind is unfortunate.  Everything i "Data".  We have "Data.Function".  It'd probalby have been better to have a Type.Kind, and then Type.Nat could be the landing spot for the type-level naturals
09:52:31 <pikajude> idea: remove the Data. prefix from all modules
09:52:34 <monochrom> No, Kind.Kind :)
09:52:39 <APic> 😎
09:52:48 <pikajude> import Text
09:52:51 <pikajude> import Attoparsec
09:52:53 <cocreature> pikajude: and while we’re at it also remove Control
09:52:54 <pikajude> i like how this sounds
09:53:01 <pikajude> cocreature: i'm open to this
09:53:14 <monochrom> Also it should be Data.* and Lore.*
09:53:31 <cocreature> I’ve been programming Haskell for several years and I still don’t know why it’s Data.Functor but Control.Applicative
09:53:41 <monochrom> If only for making both the same length
09:53:55 <pikajude> Data.Applicative, Control.Functor 🤔
09:54:21 <monochrom> Control.List and Data.Monad.Free
09:54:30 <monochrom> Or rather, Lore.List and Data.Monad.Free
09:54:32 <zomg> cocreature: I always thought it was because it was more control-structure like :P
09:54:40 <zomg> eg foo <$> bar <*> baz
09:55:00 <monochrom> Yeah zomg but now Control.List makes more sense than Data.List
09:55:08 <zomg> Does it?
09:55:13 <cocreature> zomg: even in that example you are mixing Functor and Applicative suggesting that putting them in different hierarchies is silly
09:55:16 <erisco> yeah, the foo <$> bar is very data-y and the (foo <$> bar) <*> baz part is very controll-y
09:55:34 <monochrom> We use lazy lists like pythoners use for-loops.
09:56:09 <erisco> zomg, you should check how <$> is defined
09:56:19 <zomg> erisco: I know it's fmap :)
09:56:37 <erisco> I had vertical dyslexia for a moment
09:56:47 <zomg> but coming from other langs and looking at other operators and such like chaining, the applicative style stuff looks more like a control structure in that sense
09:56:50 <cocreature> Generalized.Abstract.Nonsense.Functor is a module hierarchy that I could get behind
09:57:02 <zomg> I don't know if it makes sense in the theoretical way or not :)
09:57:23 <erisco> haha, there's a thought... a theory for Data and Control
09:58:24 * hackagebot superrecord 0.3.0.0 – Supercharged anonymous records – https://hackage.haskell.org/package/superrecord
09:58:26 <monochrom> With Haskell the boundary is crossed all the time. You usually don't do this in other languages.
09:59:01 <monochrom> You write some data structures that are really for control-flow, e.g., lazy lists, EDSLs, free monads.
09:59:19 <monochrom> Meanwhile you also do some Church encoding and use functions to encode data.
09:59:24 <erisco> I'll title the social study paper "Data and Control: why functional programmers still can't get over dichotomies"
09:59:51 <maerwald> and then you build huge monad stacks and hide half of your data and control flow
10:00:45 <cocreature> Hide.Control.Monad
10:01:26 <monochrom> Functor, Applicative, Arrow, Monad are really better off under Abstraction.*
10:01:30 <maerwald> can someone please port error_chain to haskell?
10:01:41 <monochrom> Or Utility.*, just look at java.util
10:02:20 <maerwald> I bet it should be possible with TH hackery
10:02:47 <erisco> what is the qualifier for Abstraction? you define no types?
10:03:08 <erisco> no data types?
10:03:17 <monochrom> Err, I don't understand. I just mean rename Data.Functor to Abstraction.Functor
10:03:33 <monochrom> Control.Applicative to Abstraction.Applicative
10:03:44 <erisco> okay, the problem is that no one knows what Data and Control are supposed to be
10:03:56 <monochrom> Oh I see, you're asking how do I decide.
10:04:00 <erisco> yes
10:04:13 <teurastaja> how can one write fmap in C? im trying to strip down the SK combinators
10:04:27 <monochrom> Well it's the same subjective judgment, but Functor and Applicative introduces abstractions rather than data structures or control structures.
10:04:40 <cocreature> that’s easy, we let monochrom be the benevolent dictator and he decides for everybody
10:04:59 <erisco> dictatorships are efficient, I approve
10:05:20 <monochrom> Or you can do something as simple as "if enough people vote Data and also enough other people vote Control, then it's Abstraction" :)
10:05:29 <orzo> Abstraction is too inviting, I say Theory or Generalized.Abstract.Nonsense, to emphasize this is only for very general and abstract abstractions
10:05:41 <teurastaja> i know fmap is defined as a simple composition, but how is that done in C? surely, function pointers arent enough
10:05:58 <erisco> vote for a dichotomy but close ties result in the third option... interesting
10:06:10 <monochrom> :)
10:08:23 <orzo> for do-dads that don't seem abstract enough to make the cut but don't have any obvious specific domain to tag them with, we'll have Util
10:08:40 <orzo> hhe
10:09:14 <erisco> teurastaja, you know C does not have type classes, nor does it have polymorphic types, so you will have to clarify what you mean by writing fmap in C
10:10:45 <erisco> teurastaja, fmap is a family of functions indexed by type
10:10:51 <teurastaja> erisco: im trying to make a stack machine that defines SK combinators
10:10:52 <edwardk> teurastaja: in c you'd have to define some kind of object for representing a function to be apllied (usually as a pair of a function pointer and a void * for data/context for that function) in c++ you'd use a 'callable' object which they amusingly tend to call a 'functor'
10:11:08 <orzo> probably fmap in c would look similar to OO in c.  A Functor pointer would have a standard spot ot access an fmap function
10:11:51 <teurastaja> say you have: typedef GenericType type;
10:12:03 <edwardk> then you can make a function that takes such a callable object as an argument and gives you one back or which takes one and a given f of a and gives you one back. the problem is you don't have sufficiently polymorphic types to make that rigorous. in c++ you can almost get there
10:12:18 <edwardk> but you don't have the purity needed to pass the fmap f . fmap g = fmap (f . g) law
10:12:19 <erisco> are you sure you require that kind of genericity?
10:13:10 <erisco> if you just have a few types it is no sweat to define separate functions for them
10:13:18 <edwardk> teurastaja: so in general, c doesn't have enough goodies in it to really think the thought of 'fmap' sensibly
10:13:25 <erisco> the only necessity of fmap is to have further definitions general on fmap
10:13:27 <orzo> it'd be funny if teurastaja is just asking how to interface to a haskell function from c
10:13:29 <teurastaja> I can define all SKI and BWCK combinators using a stack machine.
10:14:12 <teurastaja> the only thing thats hard to implement is the fmap equivalent (S)
10:15:17 <erisco> I am not familiar with the relationship of stack machines and combinators, or fmap and S
10:15:25 <teurastaja> if writing fmap is so hard, maybe i could start from monoids and build up?
10:15:44 <teurastaja> erisco: look at the type signature of <$>
10:15:56 <erisco> :t (<$>)
10:15:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:16:36 <teurastaja> so \xyz.((x z) (y z))
10:16:47 <teurastaja> that is S
10:17:10 <erisco> :t (<*>) :: (a -> b -> c) -> (a -> b) -> (a -> c)
10:17:12 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
10:17:17 <erisco> were you thinking of that, rather?
10:17:23 <teurastaja> yes sorry
10:17:32 <teurastaja> but you can build one from another
10:17:41 <erisco> you cannot build <*> from <$>
10:17:52 <teurastaja> join . fmap?
10:18:00 <erisco> do you know where join comes from?
10:18:55 <teurastaja> join is just: POP A      PUSH A      PUSH A     in assembly
10:19:03 <erisco> join comes from Monad. all Monads are Applicative (thank-you), all Applicatives are Functors
10:19:25 <teurastaja> it replicates the topmost item on the stack
10:19:46 <erisco> Functor gives you <$>, Applicative gives you pure and <*>, Monad gives you >>=, and join is defined on >>=
10:19:51 <erisco> or you can define >>= with join and fmap
10:20:21 <teurastaja> join is easy to define in assembly but bind and fmap are not
10:20:31 <teurastaja> if i had fmap bind would be easy
10:20:52 <teurastaja> is fmap definable using monoids?
10:21:00 <erisco> no
10:21:13 <erisco> not Monoid specifically, but theoretically I don't know
10:21:42 <erisco> there is a mapping going on between the theoretical objects and the Haskell classes... one which seems to be disputed from time to time but that is someone else's debate
10:22:46 <teurastaja> how do you build an applicative functor using only mappend and mempty?
10:22:51 <erisco> from the perspective of abstract algebra a Monoid is a closed associative binary operation and left/right identity
10:23:36 <erisco> so you can figure that to be many things if you try hard enough ;) the obvious translation which Haskell uses is mempty and mappend
10:24:50 <erisco> teurastaja, you don't, you can't
10:25:13 <tabaqui> leet programmers always make DSL
10:25:17 <teurastaja> im trying to implement combinatory logic from sequential logic. is there anything on translating a turing machine to a lambda calculus?
10:25:29 <tabaqui> I gonna write first-order login for training
10:25:47 <tabaqui> *logic
10:26:32 <teurastaja> like really i want my own lambda from the ground up
10:26:53 <erisco> okay, I just want to get a few things straight here
10:27:20 <erisco> if we're talking about lambda calculus then we're talking about a conception of functions, yes? and in Haskell that is ->
10:27:41 <erisco> so then if we talk about implementing fmap in this context then it is specifically for (->)a
10:28:03 <teurastaja> i dont know much about arrows
10:28:22 <erisco> no, this is not arrows, this is just the type constructor for functions in Haskell
10:28:27 <teurastaja> ok
10:28:32 <erisco> which, yes, is an Arrow, but that isn't relevant here
10:28:39 <erisco> :t (->)
10:28:40 <lambdabot> error: parse error on input ‘->’
10:28:52 <erisco> someone will figure that out for me
10:29:13 <erisco> :k (->)
10:29:14 <lambdabot> * -> * -> *
10:29:26 <teurastaja> god.....
10:29:26 <erisco> :t fmap
10:29:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:29:40 <teurastaja> please explain
10:29:44 <erisco> but we don't care about this type of fmap, we only care for f = (->)z
10:29:56 <erisco> (a -> b) -> (z -> a) -> (z -> b)
10:30:02 <erisco> we are just mapping the return type
10:30:05 <iqubic> erisco: That's just .
10:30:09 <iqubic> :t (.)
10:30:10 <erisco> :t (.) -- yes it is
10:30:10 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:30:11 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:30:33 <erisco> so in context of lambda calculus, implementing fmap is just implementing function composition
10:30:39 <teurastaja> so i have to define binary composition in C
10:30:43 <teurastaja> how?
10:30:54 <teurastaja> i have to simulate unix pipes?
10:31:10 <erisco> λf.λg.λx.f(g x))
10:32:06 <teurastaja> how do you simulate lambda composition using a stack machine?
10:32:24 <erisco> I don't know, you were the one telling me you had LC working on a stack machine
10:32:33 <erisco> I personally don't know the relationship between the two...
10:33:21 <teurastaja> erisco: i want to simplify function composition to make it trivial to write as a stack machine
10:34:21 * hackagebot matterhorn 31000.0.0, mattermost-api 31000.0.0, twilio 0.1.3.2, mattermost-api-qc 31000.0.0
10:34:22 * hackagebot  → https://hackage.haskell.org/packages/recent
10:34:51 <erisco> teurastaja, have you implemented LC on your stack machine?
10:35:05 <teurastaja> erisco: only on paper
10:35:18 <teurastaja> and not lambda calculnus
10:35:25 <teurastaja> just SK combinators
10:35:29 <erisco> that is equivalent
10:36:02 <erisco> if you have S and K implemented on your stack machine then you're set
10:36:15 <erisco> so your question only is how to write function composition using S and K, correct?
10:37:36 <erisco> because if you knew that then you'd just write it out on your stack machine in form of S and K
10:38:07 <erisco> so if you are having problems with that then I recommend reading on how to construct SK from lambda expressions https://en.wikipedia.org/wiki/Combinatory_logic#Conversion_of_a_lambda_term_to_an_equivalent_combinatorial_term
10:41:06 <erisco> :t ap(pure ap)pure :: (b -> c) -> (a -> b) -> (a -> c) -- ap = S, pure = K
10:41:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:41:46 <erisco> I had that one laying around, so there you are :)
10:45:50 <teurastaja> erisco: https://drive.google.com/open?id=1bQrrZRmSg2mRR_RaDI42uPUY_UR72bAG5yZesU8Yq1c
10:47:05 <glguy> erisco: You can knock out that last bit of whitespace with a $
10:48:26 <erisco> now you're an accessory to my crime
10:49:49 <teurastaja> so youre saying fmap is not trivially synthesizable from C?
10:49:55 <erisco> teurastaja, I do not know what the objectives are with this, i.e. what this state machine is supposed to do
10:50:13 <erisco> other than lambda calculus is somehow involved
10:50:28 <erisco> or even how C fits into the picture
10:50:52 <teurastaja> erisco: my first idea was to embed SK combinators in buffer overflow exploits on embedded microcontrollers
10:51:00 <erisco> fmap for functions specifically you can do
10:51:25 <erisco> though I am not completely sure how you'd do this in C
10:52:04 <erisco> obviously the parameter and return sizes matter, so that has to be communicated
10:52:18 <teurastaja> creating a turing complete (preferably functional) language reusing commonly available code inside existing programs
10:52:52 <erisco> and do you have to go through the calling convention yourself because of that? maybe... not a C wizard but I'd think so
10:53:16 <teurastaja> so you find a way to overflow a buffer, hijack control and eventually jump to a tiny functional interpreter in an attacker controlled buffer
10:53:23 <cocreature> you can’t write a typesafe function composition in C since you can’t be generic in the function arguments
10:53:34 <cocreature> you need a separate one for each combination of types
10:53:46 <teurastaja> but if theres just the integer type?
10:53:51 <erisco> type safe? hell no, but if you were given the appropriate size information...
10:54:03 <erisco> it doesn't sound like it is worth doing though
10:54:06 <teurastaja> the integer type that can be pushed/popped to/from the stack?
10:54:18 <erisco> complicated and likely to fail, and certainly not convenient to use
10:54:38 <dolio> The reason you have failed to implement the SK calculus is that values are not just integers.
10:54:45 <dolio> Functions must be values as well.
10:54:56 <dolio> That is the fundamental problem (if I guess correctly).
10:55:05 <erisco> well, all you need are functions
10:55:08 <teurastaja> erisco: i know its not the ideal way to exploit a computer, but theoretically, could be doable with at least 1kB buffer
10:55:34 <erisco> but if you're working with S and K then I'd just manipulate those symbols directly
10:55:42 <Tuplanolla> We have Brainfuck that compiles into GNU `printf` format strings. Is that functional enough for you, teurastaja?
10:56:01 <teurastaja> erisco: thats what my code is supposed to be doing
10:56:05 <dolio> You can implement a bunch of combinators that do things that don't care what the values are, like duplicating something that is already a value.
10:56:16 <teurastaja> i already wrote brainfuck in C
10:56:29 <dolio> But if functions are not values, then it's not going to be possible to implement all the combinators.
10:56:31 <teurastaja> not satisfying enough
10:56:36 <teurastaja> i want something more powerful
10:57:29 <erisco> teurastaja, so now we're trying to hijack processes via code injection in a buffer overflow?
10:57:30 <teurastaja> dolio: i just jump to loadable procedure locations. is that enough?
10:57:41 <erisco> teurastaja, honestly your project here seems to be moving all over the map
10:58:04 <teurastaja> erisco: its quite out of topic but it involved creating an intermediary language
10:58:20 <erisco> we have C, a stack machine, lambda calculus, now we're writing a virus... and somehow this is #haskell
10:58:23 <teurastaja> it doesnt even stop there. its only the beginning of the project ;)
10:58:36 <dolio> No, it is not enough.
10:59:26 <teurastaja> if you really want to know, im writing a machine that can learn how to hack. its not a virus. its a proof of concept
10:59:27 <monochrom> This is mad scientist level.
10:59:57 <dolio> Unless you have somehow generated all possible procedures that your program could ever construct, and a scheme for mapping combinations of those procedures to the correct other procedure.
11:00:13 <maerwald> teurastaja: like you make it prove interference properties and then apply them in varying combinations?
11:00:21 <teurastaja> im embedding a neural network once i get everything sorted out
11:00:35 <erisco> now it is machine learning?!?
11:00:45 <teurastaja> id like to prove inference properties
11:00:50 <xylospongium> hey is this a good place for haskell beginner questions?
11:00:57 <glguy> xylospongium: Yes.
11:01:05 <xylospongium> ah
11:01:12 <erisco> can it be a video game too?
11:01:15 <maerwald> inference properties?
11:01:21 <monochrom> You were confused by teurastaja's conversation? :)
11:01:34 <teurastaja> erisco: no its not a video game but its got a simulator
11:01:48 <teurastaja> im currently writing it on top of the disassembler i wrote
11:02:40 <teurastaja> very vast project but the relevant part is how to embed a small language (preferably functional) inside small computers
11:03:11 <erisco> teurastaja, I recommend make a drastic and severe cut to the scope of your project. succeed at one simple thing first and then worry about adding more
11:03:30 <teurastaja> erisco: i already made the disassembler in 3 weeks
11:03:43 <teurastaja> im writing the emulator
11:03:45 <erisco> well great, and my advice still stands ;)
11:04:13 <maerwald> well, some people don't need that advice, but they are very few :P
11:04:19 <teurastaja> once the emulator is up, i want to embed a small language
11:04:56 <glguy> teurastaja: Do you have a question about Haskell?
11:05:20 <teurastaja> glguy: yes: how to define fmap low-level
11:05:39 <erisco> the concerning thing is that I don't think you're quite sure on what fmap is
11:05:58 <erisco> why is it even relevant?
11:06:10 <maerwald> I could write map in C to some extent, but fmap, no
11:06:21 <erisco> is your small language a functional language that includes fmap?
11:06:45 <teurastaja> erisco: if i can figure out how to write it simply using a stack machine, ill have a turing complete functional language i can use to train my AI on
11:07:42 <teurastaja> i could then tell it to perform simple tasks, differentiate the bytecode, weigh and multiply the weights
11:08:01 <erisco> okay, so you are looking for a minimalistic language that you can train your AI to read and write... do I understand correctly?
11:08:04 <teurastaja> it would learn to write code
11:08:11 <teurastaja> yes
11:08:21 <erisco> why do you think you need fmap?
11:08:28 <teurastaja> attempts have been succesfully made on brainfuck to do the same thing
11:08:46 <teurastaja> the only drawback was it couldnt learn to abstract properly
11:08:52 <teurastaja> name things
11:09:10 <teurastaja> so lambda calculus is an interesting avenue i think
11:09:35 <erisco> teurastaja, lets continue on #haskell-blah because this is off topic for #haskell. I am already there
11:09:39 <teurastaja> ill emphasize pointless notation
11:09:41 <tabaqui> hmm, can I derive default classes with GADT?
11:09:52 <tabaqui> because "data Foo a where { Foo :: Foo Bool } deriving Show" is failing
11:10:05 <cocreature> tabaqui: try standalone deriving
11:10:11 <teurastaja> erisco: synthesizing fmap is not haskell?
11:10:25 <cocreature> I don’t think you really mean fmap when you say fmap
11:10:42 <cocreature> you seem to be interested in one specific instance of Functor and that instance’s implementation of fmap
11:10:43 <tabaqui> cocreature: -XStandaloneDeiving
11:10:46 <cocreature> not in fmap in general
11:10:47 <tabaqui> same thing
11:11:05 <teurastaja> well... fmap or functor application, one or the other
11:11:18 <AWizzArd> What is the definition of „effect”?
11:11:21 <cocreature> tabaqui: just enabling the extension is not sufficient, you need to use "deriving instance Show (Foo a)"
11:11:54 <tabaqui> cocreature: it works, thanks
11:12:03 <AWizzArd> In the context of monads.
11:12:09 <xylospongium> Hi, Haskell newb here. So I need to know how to check whether an integer is a power of two. There is a very simple way to do this:
11:12:12 <erisco> teurastaja, what you are doing is maybe 1% related to Haskell and 99% not, so it isn't on topic
11:12:27 <xylospongium> Just look at the binary representation and check if the first digit is 1 and the remaining ones are all zeroes.
11:12:30 <teurastaja> erisco: all the brains are here though
11:12:35 <monochrom> AWizzArd: Great question, eh? I find that I do the tautological thing of "an effect is a monad".
11:12:52 <monochrom> Actually these days just Applicative.
11:12:54 <tabaqui> xylospongium: x & x-1
11:12:57 <xylospongium> However speed is important here and I'm not sure what the best data types/ methods etc I should use to do this as efficiently as possible
11:13:00 <erisco> teurastaja, and they are here to talk about Haskell specifically... you can join my brain on #haskell-blah
11:13:06 <monochrom> (I can also be talked into "just Functor")
11:13:07 <Tuplanolla> We should have a function for checking the "population count", xylospongium.
11:13:19 <tabaqui> precisely not (x & (x - 1))
11:13:34 <xylospongium> ah and what type is x? Just an integer?
11:13:41 <monochrom> Here is the thing. Do you know how to answer "what is computation?"? It is analogous.
11:13:46 <tabaqui> func :: Int -> Bool
11:13:51 <xylospongium> thanks
11:13:55 <tabaqui> func x = not (x `bitand` (x - 1))
11:13:55 <cocreature> xylospongium: the Data.Bits module is probably what you’re looking for
11:14:00 <AWizzArd> monochrom: I often see it in that context, typically with monads.
11:14:02 <Tuplanolla> > fmap ((1 ==) . popCount) [0 .. 16] -- Like this, xylospongium.
11:14:04 <lambdabot>  [False,True,True,False,True,False,False,False,True,False,False,False,False,F...
11:14:06 <tabaqui> not sure how bitand function calls, look in Data.Bits
11:14:17 <AWizzArd> monochrom: ertes earlier told me that „Nothing” is an effect of the Maybe monad.
11:14:42 <monochrom> You probably will have to settle for an answer of the same quality as how most people answer "what is a car?"
11:15:02 <xylospongium> Thanks everyone
11:15:28 <monochrom> I can give you many examples of cars. I can also give you an intentionally imperfect criterion. But that's it, I can't give you a better answer.
11:15:43 <monochrom> There will always be cases I haven't thought of.
11:15:47 <dysfigured> vim users, what are you doing to make the experience nice in your editor? i'm currently using ghcmod-vim and neco-ghc with deoplete and ale.vim but i'm wondering what else i can look into
11:15:50 <AWizzArd> monochrom: can you give some examples of „effects”?
11:16:09 <AWizzArd> So I get a better feeling for this blurry (natural language) term.
11:16:16 <erisco> I think the intuition of "effect" requires externality
11:16:31 <monochrom> Similarly, I can tell you that performing I/O is an effect, nondeterminism is an effect, the possibility of failure is an effect (this is Maybe).
11:16:40 <Tuplanolla> > fmap (boolToInt . (1 ==) . popCount) [0 .. 32] -- This should show the result better.
11:16:42 <lambdabot>  [0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
11:16:51 <erisco> so there is some boundary to the system we are considering and an effect is some change this inner system has on the outer system containing it
11:16:53 <monochrom> The pair of a put command and a get command is an effect.
11:17:06 <AWizzArd> monochrom: what is the effect of ExceptT? Is it also the effect of the possibility of failure, like Maybe?
11:17:15 <erisco> the problem with this is where we decide to put the boundary
11:17:40 <monochrom> Yes. But ExceptT allows you to carry information in the failure case.
11:18:09 <AWizzArd> erisco: can you give an example about this externality?
11:18:17 <xylospongium> Ah thanks tuplanolla
11:19:17 * hackagebot swagger2 2.1.4.1 – Swagger 2.0 data model – https://hackage.haskell.org/package/swagger2
11:19:18 <pikajude> is there a hackage package for a Map inside an MVar
11:19:39 <pikajude> i know that sounds like a dumb question, but it would be nice to have stateful version of all the Map operations
11:19:51 <erisco> AWizzArd, say we put the boundary between you and I and I instruct you to go buy milk, then I am having an effect on you
11:20:18 <monochrom> erisco: Ah yes. S->(a,S) is or is not effectful depending on whether I close my eyes and have an abstract "X a" (X = State S) or I open my eyes and see a vanilla function.
11:20:38 <artem> What's the good package for hashmaps? Data.HashMap is deprecated
11:20:53 <erisco> AWizzArd, the tricky thing is that we quickly and subtly shift the boundaries depending on the effect we're talking about
11:21:37 <erisco> AWizzArd, so I could suddenly be putting the boundary around a function and saying that modifying global variables from the function is an effect
11:21:42 <qmk-24> hey all, quick question: what are valid package names in cabal? i assume that whitespace is banned, but what else?
11:22:02 <cocreature> artem: unordered-containers
11:22:08 <erisco> AWizzArd, even though this isn't IO in the sense of writing to disk or network or some such thing
11:22:10 <monochrom> How do you know that it is deprecated? Citation needed. (This is a guiding question.)
11:23:11 <erisco> AWizzArd, another tricky thing is how we talk about effects on systems we have no formal description of... this comes up when talking about general IO in our program
11:23:40 <artem> monochrom, If you want to tell me about Data.Map, it is treemap
11:23:48 <monochrom> No.
11:24:04 <monochrom> Do you understand "citation needed"?
11:24:37 <erisco> AWizzArd, for example, if you are working with a file system and you want to talk about what your program does (i.e. what effect it has on this file system) then you need a formal description of it
11:25:03 <erisco> so that is a difficult thing as you might imagine... large world out there!
11:25:23 <erisco> imo it is more practical to focus on the interface between the two systems
11:25:43 <erisco> the inner system represents some state to the outer system which it may then interpret to commit some action
11:26:08 <AWizzArd> Okay, I think this helped a bit. Thanks monochrom and erisco.
11:26:20 <erisco> i.e. our program doesn't write to the disk per se, it rather makes a request, like writing it on paper, and the rest of the computer system does something with it
11:26:59 <erisco> so instead we can talk about the forms these requests may come in... it is devoid of any description of what *happens* but it is at least something
11:27:09 <ahri> i'm using Aeson and its great generic derivation of encoders/decoders, but i've come across a problem and the only way to get around it is to not use the default options for Aeson, and instead tweak the options a little. does this mean i can't use the automatic generic derivations or can i reconfigure the default somehow?
11:28:23 <artem> monochrom: if it is about IntMap: "An efficient implementation of maps from integer keys to values (dictionaries).". integer keys
11:28:35 <monochrom> No. Do you understand "citation needed"?
11:28:56 <monochrom> Nevermind. You don't.
11:29:02 <erisco> if everyone describes there own interfaces then ideally you can figure out if two systems stuck together are going to work in the way you want
11:29:11 <koala_man> artem: you're misinterpreting the comment. Data.HashMap.HashMap has been deprecated in favor of Data.HashMap.Map (it's just been renamed in the package). Data.Map is not related. 
11:29:15 <erisco> their* own
11:29:41 <artem> Deprecated: HashMap is deprecated. Please use Map instead. The HashMap is a type synonym for Map for backward compatibility. It is deprecated and will be removed in furture releases.
11:29:43 <monochrom> My point is, where Data.Hashmap says that itself is deprecated, it must have also said the replacement(s). You do read that.
11:29:58 <monochrom> But I see that you have 0 reading comprehension score.
11:30:25 <artem> An efficient implementation of ordered maps
11:30:52 <artem> Ordered maps, as I said already. I need hashmaps
11:31:43 <koala_man> artem: again, Data.HashMap isn't deprected. you're reading it wrong. they just renamed the name of the map type and are asking you to use another name from the same package
11:32:34 <cocreature> artem: so what’s wrong with the hashmap in unordered-containers?
11:33:01 <artem> Ok, I get it know. I'm just new to the haskell package system
11:33:10 <monochrom> This is clearly a case of "I always talk to myself. It adds spice to my conversations."
11:34:27 <artem> You told me to add a citation. It said "hashmap deprecated use map". I couldn't guess it was about data.hashmap.hashmap, not just data.hashmap
11:34:55 <monochrom> URL?
11:35:09 <artem> cocreature: nothing. I never said it's wrong
11:35:12 <koala_man> well, here's an interesting twist: the author's github project https://github.com/foxik/hashmap says it /is/ deprecated in favor of unordered-containers
11:36:27 <artem> what's "url" in this case?
11:36:56 <srhb> artem: Monochrom wanted a link to the Hackage page with the confusing wording. It's here: https://hackage.haskell.org/package/hashmap-1.3.2/docs/Data-HashMap.html#t:HashMap
11:37:36 <mauke> artem: uniform resource locator
11:37:49 <artem> thanks for answers anyway
11:37:54 <monochrom> I support mauke's answer.
11:38:28 <erisco> phft, what is this? the year 2000? they're called URI's i.e. uniform resource indicators now
11:38:31 <monochrom> Also https://hackage.haskell.org/package/hashmap-1.3.2 has the same "Deprecated. in favor of unordered-containers" as on github
11:38:53 <erisco> and by uniform I think I mean universal
11:39:42 <erisco> or is it uniform resource indentifier ... hang on I have to dislodge this foot
11:39:43 <Clint> erisco: you don't
11:43:43 <erisco> it used to be "universal" but was changed in 1998
11:44:33 <erisco> I was thinking of IRI's as the hip new URI's
11:44:40 <Tuplanolla> That's still too optimistic. Ubiquitous resource suggestion would be more descriptive.
11:44:59 <erisco> internationalized resource identifier
11:47:08 <erisco> phising sites are crazy for it
11:49:14 <monochrom> Why do people keep doing this? If I ask just "calculate 1+1", people are not going to just answer "2" and be done with it. They have to write a 10-page essay on category theory and the history of mathematics and Decartes's philosophy vs Leibniz's philosophy.
11:50:42 <Tuplanolla> I tend to have the opposite problem, monochrom.
11:50:47 <monochrom> Is my "calculate 1+1" really that hard to answer? Is it really so much easier to do a literature search and write a 10-page essay?
11:50:50 <erisco> well how much space on the page are you leaving to answer the question? I was trained to fill it
11:51:24 <monochrom> It looks like people really pursue the path of maximum resistance.
11:51:29 <srhb> monochrom: Maybe you need a break from IRC
11:51:58 <monochrom> erisco: I don't know, because I'm telling an analogy. I'm saying that people do that on IRC. I guess it means 12GB space because that's the RAM they have?
11:54:14 <erisco> could be deceptively simple i.e. a trick question, or trivial to answer directly so instead I'll move on to the next thing to signal that I know the answer
11:54:55 <mauke> monochrom: I know that feel
11:55:04 <amx> showing they are smart and make an effort (and other things that are not always useful)
11:55:11 <mauke> it's why I often try to answer the question literally first
11:57:05 <monochrom> erisco: OK, so suppose you said "are existential types a bad idea?" and I responded "where did your read that? citation needed". Is that a trick question?
11:58:14 <WarmCookie> Hi. I have the semantics down for my research language (actor-based model), but I'm stuck on picking a viable syntax to represent something akind to "pattern matching lambdas", without introducing keywords.
11:58:27 <erisco> no, it is clear and because I either didn't really read that or I am not totally sure what I read really supports that conclusion I am going to skip over your request and get to my points
11:58:30 <monochrom> I guess from your point of view it could be. Because humans tend to believe the telepathic principle: If you saw it on a web page, then "clearly" everyone in the world has also seen the same web page. Therefore, if I bother to ask where, it's a trick question, I guess.
11:59:48 <mauke> source: internet
12:00:40 <monochrom> Well, if you didn't read it anywhere and it's just your idea, you could directly say "no I didn't read it somewhere, it's my idea", and then you can go on with your other points.
12:00:45 <Tuplanolla> That's still a better answer than (Johnson, 1971).
12:01:06 <vektorweg1> is there a imperative-like while function, that looks like: IO Bool -> IO a -> IO [a]
12:01:07 <monochrom> If you are unsure what you're reading, you can still cite the URL.
12:01:59 <EvanR> vektorweg1: maybe in monad-loops
12:02:06 <cocreature> vektorweg1: whileM
12:02:09 <mauke> :t whileM
12:02:11 <lambdabot> error: Variable not in scope: whileM
12:02:18 <cocreature> https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:whileM
12:02:46 <vektorweg1> thank you.
12:02:59 <EvanR> that exact one comes up so much... and you "need" a whole package to get it...
12:03:15 <monochrom> "whole" package.
12:03:21 <vektorweg1> should be merged to base. 
12:03:38 <erisco> monochrom, well there is going to be no need for you to want a citation if I just get my points across
12:03:54 <EvanR> single 1 line functions from a big package makes me feel wasteful
12:03:56 <monochrom> Yeah OK, bad example.
12:04:03 <vektorweg1> and i only need it once, so i probably just copy it instead of adding a dependency. 
12:04:10 <EvanR> like they should all be in 1 package
12:04:12 <EvanR> just for me
12:04:21 <monochrom> But suppose it's "module XXX is deprecated" instead.
12:04:39 <Tuplanolla> This is the kind of thing that makes me doubt packages as a distribution model, EvanR.
12:04:51 <monochrom> You don't actually have any further point to make this time. You are stuck. That's the whole point.
12:04:55 <EvanR> i would like to subscribe to your newsletter
12:05:30 <EvanR> vektorweg1: i would (and have) wrote that function into the project, its fairly trivial
12:05:49 <EvanR> if you copy the one from monad loops youll also need to deal with MonadIO, transformers
12:05:55 <vektorweg1> i hoped to find it in base, in which case it would have been cleaner to take that instead
12:06:11 <EvanR> you could use an alternative prelude :)
12:06:11 <monochrom> Or suppose it is "my code gets a syntax error" and I ask "what's the exact message and where can I read your code"
12:06:30 <cocreature> tbh monad-loops is not a particularly big dependency, it changes basically never and you probably already depend on it transitively anyway so depending on it is not that painful
12:06:44 <erisco> monochrom, haha, well I only just read the conversation
12:07:06 <vektorweg1> cocreature: hmm. probably. 
12:07:54 <erisco> I know what you're trying to say to me so I am just going to cut to the chase
12:08:32 <EvanR> the size of a particular useful functions in haskell is so ridiculously low, its like... how can you justify libraries for reusing them
12:08:34 <erisco> that isn't unreasonable, it just requires you to feel confident that you've anticipated the intent
12:09:03 <erisco> and when successful abbreviates the conversation, and when unsuccessful makes it longer
12:09:16 <EvanR> library1 of 1000 such functions, library2 of 1000 such other functions, with some overlap, library 3 ...
12:09:37 <EvanR> like the one that deals with conversion between Either and Maybe in 100 ways
12:10:31 <erisco> when you call tech support you feel a desire to skip past the "is it on" stage of questioning and just get to what you know the problem is
12:11:03 <monochrom> Well at least tech support receives a salary. I don't.
12:12:51 <EvanR> your current conversation must have started as a pi heptamino
12:12:58 <erisco> if you do figure out how to get $haskell let me know too
12:13:01 <monochrom> There is also this aspect of basic respect that, even if you ask me "is your computer on?", I actually have to answer it directly, out of respect, before I try to convince you why it's tangential.
12:14:13 <erisco> ah well people are wrapped up in the problem and their mind is hurried to try and solve it
12:14:35 <EvanR> apparently spelled heptomino for some reason
12:15:11 <blackdog> g'day all - wrote a post on webscraping in haskell ( http://www.shimweasel.com/2017/07/13/a-modest-scraping-proposal ) - if you're interested in the topic, would appreciate feedback.
12:16:09 <Tuplanolla> Good job getting the page to load in less than a second, blackdog.
12:16:48 <johnw> blackdog: when I think of a web scraper, I think what I'd like is a generalized engine that would take a list of stateful page transformers: where the state is the details I'm scraping, and the transformation is changes I might make to the page as a result, for the sake of downstream scrapers.  If you can abstract the logic of setting it all up for me, that's great, then I can focus just on the scraping task.
12:18:45 <blackdog> johnw: hm, that's an interesting thought. I hadn't considered the idea of transforming the page in pieces. what value do you think that has?
12:19:21 <blackdog> my major goal's just to get all the awful bits hidden in the machinery - it's so tedious to do it properly that almost nobody bothers.
12:19:32 <johnw> maybe something like: scrape :: Monoid m => [HtmlDoc -> State m HtmlDoc] -> Url -> IO m
12:19:55 <johnw> not Writer, so that I can inspect the results of previous steps
12:20:21 <blackdog> i'm still foggy on the reason you want to transform HTML in the first place
12:20:27 <EvanR> IO m ?
12:20:33 <johnw> because some "scraping" steps might be simplifying steps instead
12:20:48 <blackdog> in my experience you're usually doing something more like XPath or XQuery
12:20:50 <EvanR> oh monoid
12:21:02 <blackdog> but concretely? i've never wanted to do that, so it'd be interesting to see a use case.
12:21:09 <johnw> blackdog: it might be an unnecessary complication; for the first version, just HtmlDoc -> m then
12:21:58 <johnw> or, HtmlDoc -> m -> m, if I want to be able to see what I'd scraped earlier
12:25:35 <blackdog> Tuplanolla: can't tell if you're being sarcastic ... ? i use a static website generator from markdown and host at github because i know i'm bad at HTML and sysops :)
12:26:00 <Tuplanolla> Most people are much worse, it appears, blackdog.
12:26:37 <monochrom> blackdog: https://danluu.com/web-bloat/  It is really that bad.
12:26:49 <blackdog> johnw: the other problem with that approach is that it doesn't account for a common pattern where fetching one page will lead you to fetch other pages - you need that recursion structure
12:27:23 <johnw> blackdog: you could have the scraping step return a set of "next actions"; and then make scrape recursive
12:27:39 <blackdog> Tuplanolla: ah right. yeah, i'm just trying to limit damage. I managed to break the CSS for a while and bitemyapp was trying to convince me to leave it that way
12:27:40 <johnw> scrape :: Monoid m => [HtmlDoc -> (m, [Url])] -> Url -> IO m
12:28:09 <blackdog> which needs to be generalised to be over JSON/XML/CSV as well, of course
12:28:34 <blackdog> i'm still missing what the monoidal structure is bringing
12:28:40 <johnw> or maybe: scrape :: Monoid m => (m -> [Url]) -> [HtmlDoc -> m] -> Url -> IO m, this way you can examine the list of URLs at any point
12:28:48 <johnw> the monoidal structure is a way to aggregate the scraped data
12:29:11 <johnw> it could always just be a list of details, for example
12:29:24 <EvanR> or a Bag
12:29:28 <johnw> yeah
12:29:40 <johnw> it leaves the choice of how to accumulate up to the caller
12:29:48 <johnw> First could be used to get the first relevant result
12:30:08 <monochrom> Yeah, most of the time the output of scraping forms a monoid. "map reduce".
12:30:15 <zoey> when u tease a nerd is it beta reduction
12:30:22 <fresheyeball> Anyone out there a Dante user?
12:30:49 <monochrom> zoey: Why?
12:31:23 <zoey> it's a joke
12:31:33 <zoey> beta reduction is a lambda calc thing
12:31:34 <monochrom> Ah yeah. I don't get the joke though.
12:31:40 <blackdog> johnw: righto. i'll give it some thought - what i'm trying to get to is making a particular workflow in which you want to process it to a fairly structured row-like form easy. if i can generalise without losing that i'm keen.
12:32:05 <zoey> because beta, like a dweeby guy, and reduction as in like cutting someone down
12:32:17 <monochrom> I guess.
12:32:26 <zoey> Then you'd be right
12:32:31 <zoey> if you guessed that monochrom 
12:32:44 <zoey> u r a winner ~( )~
12:32:45 <monochrom> No, I just mean I guess it makes sense.
12:32:50 * EvanR throws vegetables at zoey 
12:33:06 <zoey> monochrom, yeah u guessed right
12:33:08 <blackdog> zoey: i got it. maybe i'm just attuned to being made fun of :)
12:33:19 <zoey> hey i'm a nerd too
12:34:07 <bbear> hey
12:34:23 <bbear> say I have a list [(Int,Int)]
12:34:24 * hackagebot optparse-generic 1.2.2 – Auto-generate a command-line parser for your datatype – https://hackage.haskell.org/package/optparse-generic
12:34:24 <blackdog> zoey: i don't doubt it. i just liked your joke :)
12:34:55 <bbear> how do you print each tuple on a separate line, like this "1 2\n3 3\n4 5" etc ?
12:35:00 <bbear> (reduce ?)
12:35:00 <zoey> if two bros can bench the same weight is that alpha equivalence
12:35:17 <monochrom> heh
12:35:23 <bbear> I wanted to use mapM_ : mapM_ putStrLn (show x) ++ " " ++ (show y) where
12:35:37 <bbear> but I am stuck as I don't know how to bind x, y to the list of tuple.
12:35:47 <zoey> hi i just started reading "Haskell Programming" and i don't know shit about haskell, i'll be here all night. except i gotta go
12:36:00 <adamCS> Hello.  Profiling question:  I re-wrote some code to simplify a monad transformer stack.  The new version is slower and one conspicuous detail is that ">>" now shows up as a much bigger % of the profile.  The new stack is just a newtype wrapper around "Stack StateType (Either ErrType a)" and I'm trying to figure out if the bind time is in the StateT bind or somehow in the wrapping and unwrapping of the newtype.  I'd assume
12:36:00 <adamCS>  the former, the StateT bind, but I'm not sure how to confirm that.  Control.Monad.State.Class ">>" doesn't show up in the profile at all.  
12:36:37 <monochrom> zoey: Who's the author of that book again?
12:36:58 <zoey> Christopher Allen and Julie Moronuki
12:37:03 <monochrom> Ah OK.
12:37:08 <zoey> this famous internet cat girl trap gave me it
12:37:28 <adamCS> Sorry.  The question:  How do I figure out where bind is spending the time?
12:37:38 <EvanR> Haskell Programming from First Principles
12:38:00 <monochrom> The internet incarnation of fairies.
12:39:29 <bbear> mapM_ putStrLn (Prelude.map (\(x, y)->(show x) ++ " " ++ (show y)) outcomes)
12:39:39 <bbear> I did the above but seems a little bit ugly imho
12:39:59 <monochrom> adamCS: What is the old version?
12:40:10 <alhariel> is there any prominent proposal to add dependent types to haskell
12:40:31 <johnw> blackdog: the main idea is to separate the action of scraping from that of setting up the scraping activity
12:40:33 <Athas> alhariel: yes, there is active work.
12:40:41 <Athas> https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell
12:40:46 <alhariel> yay :)
12:40:51 <Athas> I can't claim to understand the details, or why it's a good idea...
12:41:33 <adamCS> monochrom: The old version was a newtype wrapper around "StateT s (ReaderT e (Either ErrType a))" where the new StateType is just a product of s and e.  In the old version, there was a lot of zooming and magnifying and the new version replaces all that with HasXXX classes.
12:42:29 <monochrom> Hrm, the new version is slower!
12:42:43 <adamCS> Yeah.  That surprised me too.
12:43:23 <adamCS> But in the old version, a lot happens in just the Reader.  
12:44:13 <monochrom> I would be surprised, but also logical, if the reason is "(s,e) -> (a, (s,e))" is slower than "s -> e -> (a, s)"
12:44:54 <monochrom> Actually, you know what, maybe it is natural.
12:45:13 <adamCS> Hwo do you mean?
12:45:14 <adamCS> How
12:46:03 <erisco> alhariel, have you already seen singletons?
12:46:20 <monochrom> I am still not sure how true my hypothesis is.
12:46:50 <cocreature> the other option is that GHC is not able to specialize the code and ends up passing typeclass dictionaries around
12:47:01 <alhariel> nope, looking into it right now
12:47:57 <adamCS> I guess it would surprise me since s and e are already product types so, while things are one level more nested in the product, it doesn't seem like it would cause what I see.  Which is, more or less, a factor of 2 difference in runtime.
12:48:26 <erisco> alhariel, well to spare you having to read a lot to get the basic summary: you can achieve some things you would use dependent typing for in Haskell already
12:48:35 <alhariel> i guess being 'standard haskell' isnt as important as in the c++ world given the ubiquitousness of ghc
12:48:42 <cocreature> adamCS: are you using the newest version of transformers somewhat recently (although I guess by now it’s been a year or so) they added a bunch of inline pragmas and things got a lot faster in some cases
12:49:31 <adamCS> cocreature:  I think so.  I'm using a pretty recent stackage lts, 8.21.  GHC 8.02
12:50:28 <erisco> alhariel, Haskell has GADTs, and you can promote them with DataKinds, and we have type families (limited type functions)
12:50:47 <adamCS> mtl-2.2.1
12:51:17 <cocreature> it’s transformes that matters not mtl, but lts 8.21 is fine
12:51:41 <adamCS> Both versions, old and new use the same versions of all the other libs, they use the same snapshot
12:51:58 <alhariel> well it seems ill have a lot to read on either ways :)
12:52:14 <erisco> alhariel, of course there isn't the dependent type, and so singletons gets around that by having one term per type
12:52:24 <erisco> i.e. knowing the value determines the type and vice versa
12:54:36 <adamCS> cocreature:  Does the mtl version (Control.Monad.State.Strict) use the transformers version (Control.Monad.Trans.State.Strict) underneath?
12:54:48 <cocreature> adamCS: going back to your original question, GHC is probably inlining things so you don’t see them in the profile. you might be able to insert some manual cost centres and selectively disable inlining but that changes the performance so it kind of destroys the purpose of benchmarking
12:55:08 <cocreature> adamCS: yes, mtl reexports the types from transformers and adds a bunch of type classes
12:55:14 <cocreature> but the underlying transformers are the same
12:55:21 <erisco> I ran into some practical problems with constraint promotion, which DataKinds just doesn't do
12:55:21 <adamCS> That makes sense.
12:55:56 <erisco> it isn't that I really want promoted constraints, though that'd be interesting, it is that I want the unpromoted data to have constraints
12:55:57 <adamCS> And yeah, disabling the inlining in the binds seems like it would confuse things.
12:56:02 <erisco> particularly the SingI one!
12:56:16 <erisco> so then I have to duplicate my definitions and that is kinda lame
12:57:10 <cocreature> adamCS: what kind of code are we talking about here and how much slower does it get? in particular do you do so little work apart from monadic binds that it is reasonable that they make a difference or should they not matter at all because your code is doing a ton of stuff but for some reason they still seem to
12:57:18 <bbear> what's the difference between (a++b) and (map (:) (reverse a) b) ?
12:57:48 <erisco> :t \a b -> map (:) (reverse a) b
12:57:49 <lambdabot> error:
12:57:49 <lambdabot>     • Couldn't match expected type ‘t1 -> t’
12:57:49 <lambdabot>                   with actual type ‘[[a] -> [a]]’
12:57:59 <erisco> :t \a b -> (a++b)
12:58:00 <lambdabot> [a] -> [a] -> [a]
12:58:37 <vectorspacealien> I'm reading the links people posted in this StackOverflow question I posted:
12:58:38 <vectorspacealien> https://stackoverflow.com/questions/45089655/break-haskell-function-down-into-subtasks-without-additional-list-traversals
12:59:00 <erisco> bbear, does that answer your question?
12:59:04 <vectorspacealien> the top one defines a Fold type and shows how to combine them so you can do multiple folds in one pass on the same list
12:59:06 <vectorspacealien> it's really cool
13:00:12 <adamCS> cocreature: It's a Monte Carlo sim.  The StateType is for each path.  Each path does n steps (50 in my profile case) and there are m paths (100 in my profiling case).  Each step involves a bunch of small bits each of which does do a lot of looking things up in the state (the part that used to be the reader) and some of which update the state.  That's the same across both versions but in the old version I was often working in
13:00:12 <adamCS>  a much smaller environment and then zooming/magnifying to connect to the larger one.
13:00:37 <bbear> erisco: I wanted to know something about the ++ operator
13:00:42 <bbear> how is it constructed for lists
13:01:03 <erisco> are you asking how it is defined?
13:01:10 <adamCS> It gets about 100% slower, that is runtime more or less doubles.  And that holds when I use criterion to bench single paths or even sub-parts of the computation.
13:01:27 <cocreature> huh 100% slower definitely seems like more than I would expect
13:02:05 <adamCS> yeah.  Me too.  And I would have expected the opposite.  That it might get a little faster since the stack is simpler and all the zooming/magnifying is gone.
13:02:20 <erisco> (++) [] ys = ys; (++) (x:xs) ys = x : xs ++ ys
13:02:48 <bbear> ok
13:02:53 <bbear> can you do this with fmap ?
13:03:00 <erisco> no
13:03:03 <bbear> why ?
13:03:05 <cocreature> zooming means that your binds become less complicated, so it makes sense that things get slower if you always have to do the binds for your full stack
13:03:14 <erisco> can you seat soup with a fork?
13:03:26 <bbear> not really
13:03:27 <cocreature> adamCS: is your code public somewhere?
13:03:33 <bbear> i saw a way i lyah
13:04:20 <adamCS> cocreature:  No.  Though I wouldn't making it public.  But it's somewhat...sprawling.  And I don't even know where it's worth looking.
13:04:23 <erisco> okay, lets look at the type of fmap for lists, it is (a -> b) -> [a] -> [b]
13:04:29 <adamCS> sorry, wouldn't mind making it public
13:04:58 <erisco> can you think of how you might stick two lists together with that?
13:06:21 <erisco> well I'll prove to you it is impossible
13:06:36 <bbear> ok
13:06:39 <adamCS> cocreature:  Just made it public: https://github.com/adamConnerSax/FinancialMC
13:06:54 <bbear> if you do fmap (:) myList
13:07:03 <adamCS> But like I said, it's big.  And I don't want anyone to waste time wading through.  
13:07:04 <bbear> you have a bunch of functions
13:07:32 <cocreature> adamCS: it’s getting late over here so I won’t be able to take a look today but maybe I need an excuse to procrastinate tomorrow :)
13:08:50 <erisco> xs :: [a], ys :: [a], and fmap :: (a -> b) -> [a] -> [b], so we have to choose one of xs or ys to be the second argument to fmap
13:09:09 <adamCS> cocreature:  Okay.  The old/fast version is the last commit on the "ClassyPrismErrors" branch and the new, slower, version is at https://github.com/adamConnerSax/FinancialMC/commit/c87625e4485e8b614997127caad3996f5624f69d (that's just the tip of another branch but I might change it by tomorrow...)
13:09:19 <adamCS> cocreature:  Thanks either way!
13:09:23 <erisco> lets say it is ys, so say we have some f :: a -> b then fmap f ys :: [b]
13:09:56 <erisco> well we know this is equal to [f y1, f y2, f y3, ... f yn] where y1 to yn are elements of ys
13:10:35 <erisco> suppose ys is the empty list and xs is not the empty list, then fmap f ys = [], but xs ++ ys is not [], therefore it is impossible
13:10:52 <sveit> i am wondering if there is a more concise/combinator way to write the following function: "srep :: (a -> (b, a)) -> a -> [b]; srep f a = let (b, a') = f a in b : srep f a' ". Using Control.Monad.Trans.State.Lazy, i can write "srep = evalState . sequence . repeat . state", but that doesn't seem much better.
13:14:25 <Tuplanolla> :t unfoldr -- It looks like this, sveit.
13:14:26 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
13:15:44 <erisco> bbear, do you see that? when you say "implement with fmap" I have to take a fairly restrained view on what counts, yes, but if we added a bunch of other stuff it wouldn't principally be fmap anymore
13:16:13 <erisco> bbear, fmap on lists is to apply a function to each element and get a new list
13:16:32 <Tuplanolla> If you had `data Stream a = a :. Stream a`, its `unfoldr` would be your function, sveit.
13:16:54 <lumo_e_> Hello, somebody knows how to do exact string matching in alex? I'm using @stuff = ("string1" | "string2" | ...) but it doesn't match anything at all
13:17:26 <sveit> Tuplanolla: good find, i can also write "srep = unfoldr . (.) Just"
13:18:07 <erisco> bbear, also simply you have  length (xs ++ ys) = length xs + length ys  whereas  length ys = length (fmap f ys)
13:18:37 <erisco> bbear, so that is a second reason you cannot do it with fmap... the length isn't right
13:19:08 <erisco> regardless of what you put in for f, is the point
13:19:36 <erisco> so you can be sneaky and capture xs in f but you can't succeed
13:22:36 * hackagebot urn-random 0.1.0.0 – A package for updatable discrete distributions – https://hackage.haskell.org/package/urn-random
13:28:25 <bbear> http://vpaste.net/6JWxF <- what do you think of my program ?
13:29:41 * hackagebot brick 0.20.1 – A declarative terminal user interface library – https://hackage.haskell.org/package/brick
13:29:44 <Tuplanolla> It has many characters in it and some of them are very nice, bbear.
13:30:27 <erisco> well there goes my answer... so the first actual critique is you need type annotations for top-level definitions
13:30:50 <bbear> yes I forgot to go full with type annotations
13:31:00 <Tuplanolla> More seriously, `[[Char]]` and `!!` are warning signs for bad design.
13:31:02 <cocreature> bbear: overall it looks pretty good. I would use newtypes instead of type synonyms and you might want to reconsider using a list of lists as the datastructure for your labyrinth since you seem to be doing indexed based access
13:31:22 <cocreature> bbear: if you compile with -Wall GHC will tell you when you don’t have type annotations for top-level definitions
13:31:45 <bbear> cocreature: ha yeah you mean that
13:31:56 <Tuplanolla> You really shouldn't say `Char` when you mean `Tile`.
13:32:10 <cocreature> it might also be nice to use a guard in getOutcomes
13:32:12 <bbear> I avoid to put type annotations too early because it is tedious to change
13:32:40 <Tuplanolla> Other less serious warning signs are `length` and `head`.
13:32:46 <cocreature> I usually start with only type annotations and when I have figured out how things should be structured, I start writing the implementations
13:33:22 <bbear> ok Tuplanolla. I thought I'd go with the ugly way since I didn't want to use the Data.Array module, I wished to keep the thing reasonably straight forward
13:33:44 <bbear> cocreature: this is a good plan also 
13:34:05 <Tuplanolla> Better options include `Map (Int, Int) Tile` and `Vector Tile`, bbear.
13:34:06 <erisco> bbear, your whitespace is good, though I like keeping to maximum line lengths myself
13:34:07 <bbear> I suppose using Array all through the program would have made it much cleaner ?
13:34:17 <bbear> Tile isn't a predefined type, is it ?
13:34:23 <Tuplanolla> Nope.
13:34:26 <bbear> ok
13:37:48 <bbear> Vector are dynamic arrays (similar to python lists ?)
13:38:42 <xunta1> can one  help me to find ouparticle.cls?
13:38:47 <bbear> ok thanks 
13:43:47 <erisco> bbear, some parens you can drop http://lpaste.net/356939
13:44:18 <bbear> 656,472 bytes <- my program really used 650kB ?
13:44:24 <bbear> that seems to be quite a lot
13:44:57 <Tuplanolla> Oxford University Press Article, xunta1? Try #latex instead.
13:45:30 <erisco> (-) (length lab) 1 ==> length lab - 1   also   (-) (length $ head lab) 1 ==> length (head lab) - 1
13:46:27 <EvanR> bbear: it probably "use" much more but GC collects most things quickly
13:47:55 <erisco> and I recommend weening yourself off using $ but maybe some people like it, I dunno... haven't seen a pool
13:47:59 <erisco> poll*
13:48:15 <ed__> hello friends, how come my ghci prompt changes when i load a module? (from Prelude> to *Main>)
13:48:28 <EvanR> a long string of $ is provably unergonomic to refactoring
13:48:38 <erisco> that's just how she works ed__. you can change it if you want to
13:49:12 <ed__> okay thanks, good enough for me
13:50:03 <erisco> in fact I find it unreasonable not to change it because it just keeps getting longer the more modules you load in
13:50:22 <EvanR> its like a MUD, your prompt gets more and more informative
13:50:42 <EvanR> instead of HP you can put memory usage or thread count
13:51:27 <Tuplanolla> I'd really like a monotonic mistake counter in the prompt.
13:51:46 <Tuplanolla> It should only ever go up.
13:54:59 <EvanR> Tuplanolla: is this like an uptime bragging source or
13:55:51 <Tuplanolla> It's like recalling embarrassing high-school memories, except with relentless assistance.
13:57:21 <ed__> neat
14:30:01 <EvanR> in sequent calculus what the heck is the meaning of ⊢ with nothing to the left or to the right
14:30:24 <EvanR> nothing to the left and nothing to the right
14:34:43 <maerwald> why did I find Frege just today and not 2 years earlier?
14:34:49 <maerwald> never heard anyone talking about it here
14:35:00 <EvanR> i learned about frege here
14:35:06 <maerwald> hmm
14:35:09 <EvanR> probably more than 2 years ago
14:35:28 <maerwald> I find the idea amazing, especially because it transpiles directly to java code
14:35:34 <EvanR> consequently i also learned about frege the guy here
14:36:03 <maerwald> the perfect way to sneak your haskell skills into a boring java web company?!
14:36:06 <maerwald> they won't even know!
14:36:12 <EvanR> true
14:37:46 <maerwald> "hey, what's that 'frege' branch in your git repository?"
14:37:53 <maerwald> - "uh, nothing, ignore it"
14:38:05 <EvanR> just dont decompile it
14:38:12 <EvanR> or theyll suspect
14:43:22 <tikhon> Can I have a few paragraphs of Haddock documentation after a section header not attached to any specific definition?
14:43:43 <tikhon> I think I've seen this in certain packages, but I'm having trouble doing it myself.
14:44:00 <tikhon> I tried doing
14:44:02 <tikhon> -- * Header
14:44:13 <tikhon> -- ^ Section documentation ...
14:44:39 <tikhon> but that just swallowed the section after the -- ^
14:45:04 <tikhon> I tried using -- | instead, but that attached the pargraphs to the next definition, even though it had its own -- | section
14:48:14 <monochrom> Yes there is a way. Let me recall what I did.
14:50:33 <monochrom> Ah under a section heading. I think I haven't tried that. But I can try now.
14:51:44 <tikhon> Thanks!
14:52:23 <tikhon> I just found an example in the Pipes documentation—very well-documented library, that—and it's doing something tricky with named documentation sections. I don't know if you *need* to do that, or if I'm missing something else.
14:52:55 <monochrom> I think it does come down to named sections. (Or generally named chunk of doc.)
14:53:31 <monochrom> IIRC there are a few tricks that can only be done by naming chunks.
14:53:34 <tikhon> :/
14:55:19 <tikhon> okay, it worked
14:55:24 <tikhon> thanks for trying it out for me
14:58:05 <monochrom> OK, I think this one doesn't need named chunks.
14:58:52 <monochrom> module Dummy(
14:59:00 <monochrom>   -- * Section 1
14:59:09 <monochrom>   -- | Hey!
14:59:12 <monochrom>   -- 
14:59:17 <monochrom>   -- You
14:59:21 <monochrom>   f,
14:59:24 <monochrom> (etc)
14:59:30 <tikhon> on the one hand it's nicer to not use named chunks
14:59:47 <tikhon> on the other, I want the documentation to be located next to the definitions in the code
14:59:53 <houli> @maerwald also look at Eta
14:59:53 <lambdabot> Unknown command, try @list
14:59:54 <monochrom> This will have two paragraphs, one for Hey, one for You.
14:59:58 <houli> oops
15:00:01 <houli> maerwald:
15:00:34 <monochrom> Sure, they will appear before f's type sig, but it doesn't mean they belong to f. f's doc will come from the body of the module.
15:01:27 <tikhon> okay
15:01:32 <tikhon> I'm not sure if this is intended behavior
15:01:41 <tikhon> but it also works if you use -- $ with no named chunks business
15:01:46 <tikhon> -- * I am a header
15:01:57 <tikhon> -- $ I am a bunch of paragraphs under the header
15:02:05 <monochrom> Oh interesting
15:02:21 <zqvt8> what would be a way to filter a list for some condition but only return the first n elements that satisfy the condition?
15:02:54 <tikhon> zqvt8: do it with two functions: filter first, take n results afterwards
15:02:57 <koala_man> zqvt8: since haskell is lazy, you can just take n $ filter ..
15:03:08 <marvin2> :t take 4 . filter f
15:03:10 <lambdabot> error:
15:03:10 <lambdabot>     • Could not deduce (FromExpr Bool) arising from a use of ‘f’
15:03:10 <lambdabot>       from the context: Show a
15:03:17 <tikhon> ...
15:03:31 <monochrom> Hrm, if I use $ I lose the paragraphs altogether. They simply don't appear.
15:03:46 <zqvt8> thanks! still beginning and a little confused about the lazy parts
15:03:54 <tikhon> monochrom: odd
15:03:57 <tikhon> it's working for me
15:04:09 <tikhon> -- ** Typeclasses
15:04:09 <tikhon>  
15:04:09 <tikhon> -- $ We have two classes:
15:04:33 <tikhon> (with multiple paragraphs and code examples in the entire section.)
15:04:49 <monochrom> Oh, a blank line, let me try that.
15:04:54 <tikhon> could be
15:05:02 <tikhon> Haddock syntax feels a bit tempermental at times.
15:05:10 <marvin2> zqvt8 because of laziness this will work even on an infinte list
15:05:15 <marvin2> > (take 5 . filter odd) [1..]
15:05:17 <lambdabot>  [1,3,5,7,9]
15:05:40 <monochrom> No, blank line doesn't help me. I'm ready to sign it off as "different versions".
15:05:44 <tikhon> huh
15:05:51 <tikhon> monochrom: which version do you have?
15:06:08 <tikhon> Haddock version 2.17.3, (c) Simon Marlow 2006
15:06:08 <tikhon> Ported to use the GHC API by David Waern 2006-2008
15:06:34 <monochrom> Oh that's strange, identical.
15:07:03 <tikhon> >.<
15:07:44 <monochrom> I will sign it off as "we are actually in distinct parallel universes respectively but somehow a wormhole links us"
15:08:04 <monochrom> ghc 8.0.2 right? if it matters.
15:08:29 <tikhon> I believe so, yes
15:09:37 <maerwald> houli: which one is better?
15:10:57 <houli> maerwald: above my pay grade unfortunately. I haven't used either so don't have an opinion. I see eta is moving forward with good compatibility with hackage libs
15:11:15 <maerwald> oh, you can use hackage libs in there?
15:11:25 <maerwald> you can only use java libs with Frege
15:11:32 <houli> It's a fork of GHC yeah
15:12:57 <monochrom> 2.17.3 is not on hackage?! Only 2.17.2 then boom 2.17.4
15:13:09 <monochrom> We are being hax0red!
15:13:12 <johnw> monochrom: NO WAY
15:13:19 <johnw> it's like time skipped a beat
15:13:41 <monochrom> Of course, github has 2.17.3. But not on hackage.
15:13:42 <tikhon> it's shoring up the parallel universes theory
15:13:48 <monochrom> :)
15:13:51 <johnw> tikhon!!!
15:13:59 <tikhon> I'm on a pretty recent version of nixpkgs-unstable, by the way
15:14:08 <tikhon> johnw: hey
15:14:13 <johnw> hey man, good to see you here
15:14:27 <tikhon> johnw: I'm in the middle of a fun Haddock-debugging session :)
15:14:39 <monochrom> Oh nix is like Kripke structures, the worst multiverse nightmare possible (or bliss? I suppose Kripke would enjoy it)
15:14:42 * johnw reads scrollback
15:16:02 * hackagebot servant-swagger 1.1.3.1 – Generate Swagger specification for your servant API. – https://hackage.haskell.org/package/servant-swagger
15:23:32 <tikhon> are there any alternative Haddock stylesheets floating around?
15:24:57 <pikajude> i think haddock only has like 6 classes to worry about
15:25:50 <EvanR> maerwald: theres also two different java bridges for haskell
15:25:53 <EvanR> at least
15:26:00 <EvanR> and one of them has 3 styles
15:26:17 <maerwald> well, if I could choose "pick the java or haskell ecosystem", I'd probably choose java :P
15:26:43 <EvanR> with java bridges you get both
15:26:56 <EvanR> its kind of the point of java bridges, to get java libs
15:26:57 <maerwald> (given that I can still write in a non-annoying language)
15:27:50 <EvanR> java is non-annoying?
15:28:00 <maerwald> well, I'd write e.g. Frege, not java
15:28:14 <maerwald> but interface with those libs in ST etc
15:28:21 <maerwald> that's acceptable
15:28:27 <EvanR> i brought this up because i thought we were lamenting not being able to use haskell libs
15:28:39 <maerwald> well, can one have both?
15:29:06 <srhb> inline java?
15:29:09 <maerwald> a) language compiles to java, b) you can interface with java libs, c) you can interface with haskell libs
15:29:24 <EvanR> as i understand it, javabridges summon their own JVM
15:29:25 <maerwald> that would be quite insane
15:29:35 <srhb> maerwald: It works pretty well..
15:29:45 <srhb> EvanR: Yeah..
15:29:54 <maerwald> srhb: where?!
15:30:01 <srhb> maerwald: Uh, not abc
15:30:07 <maerwald> haha
15:30:08 <srhb> maerwald: I meant, we do have inline java
15:30:12 <srhb> :-P
15:30:19 <maerwald> you almost had me sold
15:30:23 <srhb> maerwald: Sorry!
15:30:31 <maerwald> I would have followed you anywhere!
15:30:47 <srhb> It would be cool for sure.
15:31:34 <maerwald> I think the only place where you can hope for such a thing is e.g. the C#/F#/F* ecosystem, but even there they have serious trouble with back and forth, depending on the direction
15:31:39 <EvanR> https://github.com/tweag/inline-java#readme
15:32:06 <EvanR> tweagio
15:33:30 <monochrom> Oh God Haddock's own manual has been coded to say "version 1.0" even in the 2.17.3 source tree.
15:34:15 <EvanR> twas a good version
15:34:18 <hpc> still better than npm packaging
15:34:31 <monochrom> What happened to npm packaging? :)
15:34:51 <hpc> an npm package is basically nothing but a url
15:35:08 <monochrom> The manual content is up-to-date (or at least cannot possibly be really 1.0) because it actually mentions "type families"
15:35:13 <hpc> it could be to npmjs itself, github, some random aws node, or nigerianprince.ru
15:35:36 <monochrom> haha
15:35:53 <monochrom> sounds like stack
15:37:35 <nshepperd_> They call it a package, but it's really nothing more than the incantation to summon a demon from the underworld that codes up the library for you on the fly
15:37:53 <xeno> hi, I'm struggling a bit with Spivak's book on Category Theory... ##math doesn't seem like the best place to get help, anyone here got it and can help me with something? if not, any suggestion on the right place to ask? 
15:38:26 <johnw> xeno: there's ##categorytheory
15:38:28 <Tuplanolla> ##categorytheory, xeno?
15:38:33 <johnw> xeno: I'd be happy to talk with you there
15:39:33 * hackagebot madlang 2.4.0.1 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
15:39:33 * hackagebot madlang 2.4.0.0 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
15:39:38 <monochrom> Spivak has a category theory book too?!
15:40:07 <johnw> yep
15:40:09 <xeno> monochrom: different spivak 
15:40:12 <tikhon> monochrom: might be a different Spivak than you're thinking?
15:40:13 <EvanR> poor ##math :(
15:40:24 <johnw> I don't know which one he's thinking of
15:40:25 <monochrom> Ah that's better.
15:40:30 <johnw> David is the one we mean
15:40:33 <monochrom> The calculus one.
15:40:42 <johnw> ah, Michael
15:40:46 <monochrom> yeah
15:40:52 <johnw> funny that his middle name is David
15:41:06 <Tuplanolla> Is ##math as bad as ##physics by the way?
15:41:13 <EvanR> no
15:41:40 <EvanR> there are no math crackpots
15:42:09 <EvanR> (in that channel)
15:42:10 <Tuplanolla> http://web.mst.edu/%7Elmhall/WhatToDoWhenTrisectorComes.pdf
15:42:19 <Tuplanolla> I'll have to pay a visit then.
15:43:08 <xeno> johnw: I just assumed David was his son, but I dunno...
15:47:01 <EvanR> i remember a student in my 5th grade math class who was obsessed with trisection
15:47:10 <EvanR> the teacher said it was impossible, he did not care
15:47:17 <EvanR> or rather thats why he cared
16:07:48 <EvanR> the solution of what to do when the trisector shows up is great
16:08:08 <EvanR> also looking for "The Science of Programming" thanks to this ad at the end
16:14:05 <xeno> EvanR: you're the opposite of me (or rather I'm the opposite of almost anyone) - if I see an add for something, I do my best not to notice it, and if I do, I do my best not to buy it 
16:15:23 <Tuplanolla> Where do you even find ads if you don't watch tv, listen to radio or browse the Internet unfiltered?
16:15:51 <xeno> they throw it on my doormat :/
16:16:03 <xeno> and plaster it up everywhere 
16:20:05 <Tuplanolla> Yes, now that you mention it...
16:26:05 <EvanR> right if you do your best to avoid all ads, like me, when you see one in a random PDF you probably read it :)
16:26:43 <EvanR> thanks to how terrible ads are now, i forgot what it was like to genuinely be interested in good ads
16:48:28 <monochrom> EvanR: Ah yes I'm also very surprise-happy to see the ad for Science of Programming.
16:49:22 <monochrom> P.S. I hate an ad iff it takes up CPU time and memory.
16:50:10 <EvanR> interesting
16:50:40 <EvanR> im working on yet another gui environment, ill have to make sure it supports very efficient ads
16:51:23 <EvanR> can show you 10000 ads with almost no overhead, similar to GHC threads
17:07:13 <bbear> http://vpaste.net/eSRqf
17:45:28 <cheshircat> Hello, I have been programming haskell for a while, and I think it's time to give back. Are there any libraries that are in need of documentation/tutorials?
17:49:08 <bbear> http://www.randomhacks.net/2007/03/12/monads-in-15-minutes/
17:49:15 <wespiser> cheshircat: yea, data haskell needs a ton of work
17:49:33 <wespiser> http://www.datahaskell.org/
17:51:00 <sveit> speaking of documentation, how do people manage documentation for locally installed packages?
17:51:23 <wespiser> i usually use the web, hackage or hoogle
17:51:49 <sveit> on this note, is there a way to make "--haddock" a default flag for stack?
17:51:56 <sveit> wespiser: the problem is i often work offline
17:52:19 <cheshircat> huh, that's a good thing because I am taking an algorithms class in the fall and I'm planning to do my projects in haskell
17:52:50 <edwardk> cheshircat: i have a few that could stand a bit of polish on that front. ;)
17:53:07 <edwardk> i mostly focus on making sure that the code gets maintained but documentation binges come few and far between
17:58:41 <wespiser> sveit: $ cat ~/.cabal/where-is-my-stuff.txt 
17:59:13 <iqubic> Can one use standard OOP algorithms in Haskell?
18:00:05 <iqubic> What is DataHaskell?
18:01:25 <wespiser> DataHaskell is a group of people interested in developing Haskell's capabilities in data science, statistics, model, data visualization, etc
18:09:38 <pacak> o/
18:09:38 <pacak> Suppose I have a something that can be represented as a MonadPlus computation (basically I'm doing a bunch of lookups in Map using different names trying to support different representations of the same data - names, formats, etc). I need to run this computation several times on a whole bunch of datasets. Dataset shapes are all identical, but not known on compile time so on runtime I'll know in advance what branches will fail and what I'm trying to do is to s
18:10:43 <pacak> At the moment I'm looking at FreeT f []
18:12:25 <pacak> Are there any better approaches?
18:13:06 <iqubic> :k Functor
18:13:07 <lambdabot> (* -> *) -> Constraint
18:13:21 <iqubic> What the heck is a constraint?
18:13:27 <iqubic> :k Applicative
18:13:29 <lambdabot> (* -> *) -> Constraint
18:13:34 <iqubic> :k Monad
18:13:35 <lambdabot> (* -> *) -> Constraint
18:13:49 <EvanR> its a kind
18:14:11 <iqubic> :k Constraint
18:14:13 <lambdabot> *
18:14:17 <iqubic> So it is.
18:14:26 <EvanR> erm
18:14:35 <EvanR> that proves that its a type
18:14:46 <iqubic> Oh. Is it a type or a kind?
18:14:56 <geekosaur> constraints are the things that come before a => in a type
18:15:02 <iqubic> Ah. I see
18:15:17 <EvanR> yes Functor Maybe is a constraint, it goes to the left of =>
18:15:18 <iqubic> So of course functor needs to be a constraint.
18:15:26 <EvanR> Functor is not a constraint
18:15:28 <geekosaur> Constraint is a kind; the thing you did that resulted in * is a hack inside of ghc
18:15:38 <iqubic> Oh. I see.
18:15:41 <geekosaur> with an open bug that has gotten a fair amount of commentary and work
18:16:00 <EvanR> Functor is a constraint "factory"
18:16:15 <EvanR> you give it a type constructor and it gives you a constraint
18:17:20 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/11715 fwiw
18:21:21 <electron42> is there a durable memory map for haskell?
18:22:08 <EvanR> there is acid state + indexed set
18:22:43 <electron42> oh cool
18:23:24 <electron42> indexed set is named Data.ixSet?
18:23:52 <EvanR> yeah ixset
18:24:25 <EvanR> theres also ixset-typed 
18:24:43 <electron42> what's the preferred haskell serialization/deserialization library?
18:25:07 <EvanR> probably Binary
18:25:49 <EvanR> until (?) CBOR is ready
18:27:05 <electron42> interesting
18:29:33 <electron42> "acid-state still aims to beat traditional SQL in terms of development and maintenance effort."
18:29:48 <EvanR> ... yeah ....
18:30:00 <electron42> is there a good comparison somewhere?
18:30:29 <EvanR> i cant see acid-state being a replacment for SQL applications
18:30:34 <electron42> i'm down on SQL these days,... i feel like redundantly specifying schema and my application native types is pointless
18:30:50 <EvanR> it could replace particular use cases of SQL
18:31:07 <EvanR> but as a backend for an agile website... dunno
18:31:09 <electron42> what are the major differentiators?
18:31:27 <EvanR> acid state has no massive tooling suite to let you inspect and modify stuff on the fly
18:31:39 <electron42> like via a ui?
18:31:46 <EvanR> or a console
18:31:51 <electron42> sql uis are crap
18:31:54 <EvanR> its not an RDMS, its not even necessarily relational
18:32:02 <EvanR> its just "acid"
18:32:25 <electron42> bindings between sql and applications suck
18:32:33 <EvanR> pretty much
18:32:41 <pacak> electron42: You don't have to specify schema  in SQL, it can be derived from your application native types with generics/TH.
18:33:00 <electron42> whats TH?
18:33:09 <electron42> i just read over opaleye and wasn't optimistic
18:33:11 <pacak> TemplateHaskell
18:33:56 <EvanR> acid-state gives you access to a single value that will be persisted. you can update it and view it concurrently, and the latest version is always in memory so is fast
18:34:07 <electron42> opaleye docs i read said that it couldn't build tables for me and googling "foreign key opaleye" only gave me results which made me squirm
18:34:17 <EvanR> the type of this value is up to you, for instance an entire SQL database data structure
18:34:24 <EvanR> or a single number
18:35:14 <EvanR> modifying this type after the fact requires a migration strategy involving safecopy
18:36:03 <EvanR> its a lot of work, but when you think about it, its a miracle SQL can tolerate itself
18:36:13 <electron42> tolerate itself?
18:36:28 <electron42> handle schema changes?
18:36:34 <EvanR> modifying your database's schema without everything going kablooey
18:36:44 <EvanR> online
18:36:49 <electron42> well i guess the table abstraction makes that pretty simple :P
18:37:04 <EvanR> and you could set this up in acid state, in so much work
18:37:22 <EvanR> and it would probably end up safer than "the table abstraction" and a guy in front of the sql console
18:37:33 <EvanR> it will also be faster
18:38:49 <electron42> plus you have all this unnecessary overhead of serializing your data structures to something that sql supports
18:38:58 <electron42> back and forth, talking over a socket
18:39:19 <electron42> often times any nontrivial query will require code which is particular to the sql database code you are using
18:39:31 <EvanR> if you use acid state as a server for data, youd also have to do this
18:39:49 <electron42> the sql database itself often is a huge number of LOC which you have no idea what its underlying reliability/security is
18:39:57 <EvanR> and yeah, "querys" you do not have a query language with acid state, unless you come up with one
18:40:29 <electron42> the problem with the queries is maintaining an index?
18:40:43 <EvanR> queries are usually pretty complex
18:41:15 <EvanR> SQL has a system to plan out how to look things up, which indexes to use, and compile the results
18:41:32 <EvanR> you can do all this manually with acid state! :)
18:42:41 <EvanR> if your state is a Data.Map, well then, this simplifies a bit
18:43:11 <EvanR> the query language consists of... Data.Map module
18:46:43 <electron42> can you give me an example of a simple query which the SQL engine would compute quickly which i wouldn't be able to perform in haskell without lots of custom programming?
18:49:02 <EvanR> select * from foo join bar using fieldA where fieldB = baz
18:50:17 <electron42> so joins, basically?
18:51:44 <EvanR> that operation is going to involve 3 indexes, some maps, a filter, and then a zipWith to get all fields
18:51:57 <EvanR> assuming you have the indexes already set up
18:52:20 <EvanR> you need to think carefully to get it to do it the most efficient way
18:52:50 <electron42> well you need to build an index to make a query fast anyway
18:53:11 <EvanR> in a proper database, everything is some sort of indexes
18:53:24 <electron42> automatically?
18:53:33 <EvanR> a main table is an index from primary key to entity
18:53:48 <electron42> right
18:54:48 <electron42> "MySQL can create composite indexes (that is, indexes on multiple columns). An index may consist of up to 16 columns."
18:55:10 <EvanR> MySQL might not be the best example
18:55:50 <electron42> are you saying other db engines automatically create column indexes?
18:55:56 <EvanR> anyway, you will be implementing an RDBMS
18:57:41 <EvanR> they create indexes based on your schema specification
18:58:17 <electron42> ok,... is it infeasible to build this functionality into a haskell lib?
18:58:27 <EvanR> nope
18:58:38 <electron42> no meaning it's possible to do?
18:58:48 <EvanR> its possible
18:59:19 <wespiser> electron42: I'm working on a problem now where I just offload all the db logic and storage from Haskell to Postgres
18:59:28 <EvanR> projects aiming for an RDMS-like situation seem to go a different route, to use something like postgres or whatever as the backend
19:00:05 <EvanR> and the library controls the database with the DSL, rather than be a DSL and a db engine too
19:00:05 <electron42> right,... i get that impression as the typical case
19:00:06 <wespiser> a llvm JIT data frame would be really cool 
19:00:18 <wespiser> similar to R's data table
19:02:08 <EvanR> thats another thing, regardless of the title of acid-state, postgres sqlite and friends have put a few more years into the reliability
19:02:16 <EvanR> of its storage 
19:02:39 <electron42> right,... a friend of mine said that filesystems basically don't work
19:03:04 <electron42> and SQL takes all the guarantees that filesystems should offer and makes them legit
19:05:10 <wespiser> SQL is a language for querying data, the guarantees are made by the database, and vary quite a bit between implementations that all use SQL
19:06:05 <electron42> plus somehow i'm supposed to verify that the queries are valid at the type level in my application before issuing them to the database?
19:06:25 <EvanR> would be cool
19:06:33 <EvanR> check out haskelldb
19:06:35 <electron42> it might not be possible to do this, especially if there are interrelationships 
19:07:03 <EvanR> the idea is not to use SQL the language, but use it as a target
19:07:45 <EvanR> treat it as assembly language
19:08:42 <wespiser> thats really good advice, embedding SQL is Haskell is often made more complex than need be
19:13:16 <EvanR> plenty of technologies elsewhere do that, but haskell is cool for potentially letting you put a type system on it
19:15:28 <electron42> i remember seeing a while back a haskell database which made a big deal out of how it allowed you to reverse (and i think leave out, ala source control) arbitrary queries... can't remember the name of it
19:15:42 <electron42> (i know postgres allows you to do something like this, minus the leave out part i think)
19:56:02 <electron42> https://www.postgresql.org/docs/9.2/static/runtime-config-query.html https://www.postgresql.org/docs/9.2/static/geqo-intro.html "Among all relational operators the most difficult one to process and optimize is the join. The number of possible query plans grows exponentially with the number of joins in the query. Further optimization effort is caused by the support of a variety of join methods (e.g., nested loop, hash join, mer
19:56:20 <electron42> "The normal PostgreSQL query optimizer performs a near-exhaustive search over the space of alternative strategies."
19:56:40 <electron42> so um, so much for magical query engines...?
19:58:38 <wespiser> postgresql is great, I have used postgresql-simple to great effect
19:58:50 <EvanR> postgres is my preferred sql
19:59:02 <EvanR> unless situation calls for sqlite
19:59:05 <wespiser> there is also PipelineDb, which I'm using for a new project, and is based on postgres
19:59:57 <wespiser> yea, i want to look into Redis, I know there is a good Haskell interface
20:00:05 <electron42> redis isn't durable
20:00:17 <electron42> (unless you go with the commercial version)
20:00:49 <EvanR> i looked into redis before and am not sure what the benefit is
20:01:08 <electron42> it's good if you have an apple watch
20:01:18 <electron42> makes your apple watch tell the time more accurately
20:02:14 <Welkin> redis on your apple watch?
20:03:13 <wespiser> EvanR: for a better performant store
20:03:46 <EvanR> is it?
20:04:05 <wespiser> yes, I looked into it for storing session tokens
20:05:47 <Welkin> just store them in your cpu register
20:06:10 <EvanR> ill tell you where you can store them
20:06:26 <electron42> my ipad?
20:07:23 <wespiser> yes, I'll put them in my cpu registers, then when that fills up users will just have to wait for a token to expire and space to open up
20:07:57 <EvanR> would be cool
20:08:47 <wespiser> there's a really good book that was just published, Designing Data Intensive Applications, that covers a lot of what we are talking about
20:09:22 <electron42> postgresql-simple is pretty cool
20:09:45 <EvanR> yeah that seems like the most straightforward way to get started
20:10:08 <Welkin> I just use persistent with postgres
20:10:10 <EvanR> skips the schemata and type system
20:10:35 <Welkin> it still allows you to use the postgresql-simple interface if you need any raw sql
20:11:45 <electron42> right...
20:13:56 <electron42> lol "object-relational mapping is the vietnam of computer science"
20:14:11 <Welkin> said who?
20:15:16 <electron42> some guy
20:15:53 <EvanR> about as inflamatory as i can imagine at this point
20:16:06 <EvanR> pun not intended
20:16:28 <Welkin> then is vim vs emacs like world war 2?
20:16:46 <EvanR> if text editors were hitler
20:17:03 <EvanR> it means you lost the argument
20:17:23 <electron42> haha
20:17:29 <geekosaur> more of a tempest in a teapot, sound and fury signifying nothing
20:20:35 <electron42> fancy
20:28:09 <electron42> so Text is the preferred type for strings in haskell?
20:28:18 <Clint> sometimes
20:58:15 <lordcirth> String lets you map, filter, etc handily, but linked lists aren't that fast.
21:02:06 <cheshircat> edwardk: I didn't see your response before, do you want to tell me particular ones you want documented? I've used linear before, that might be a good start.
21:02:34 <EvanR> linked lists arent that fast when used improperly
21:02:45 <EvanR> like, not lazily
21:03:18 <EvanR> map and filter work lazily
21:05:55 <EvanR> im writing a parser and the language is describable with json.org choo-choo train diagrams... jealous that i cant just feed one of these into the computer
21:13:55 <Maxdamantus> Doesn't that just mean it's context-free?
21:15:08 <EvanR> not sure
21:18:28 <Cale> EvanR: write an arrow-based parsing library :)
21:18:47 <EvanR> i just changed my mind!
21:20:23 <EvanR> actually those diagrams only tell you how to recognize the language and not how to extract data from it
21:24:02 <EvanR> hmm actually...
21:42:12 <Lokathor> :t maybe
21:42:13 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:42:38 <Welkin> :t contramap
21:42:40 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
21:50:51 <Kinaesthetician> Hi
21:51:23 <Kinaesthetician> Someone had given me a url of a list of a bunch of papers, and a paper on parsing in particular, but I lost it :(
21:52:05 <lordcirth> Kinaesthetician, http://tunes.org/~nef/logs/haskell/?C=M;O=D
21:53:25 <sebastianrkg> I ran `stack setup` in the Windows Subsystem for Linux version of Bash, and it's still installing after ~3 hours... does this ever complete? Anyone else ever done this?
21:54:04 <sebastianrkg>  not sure if it's really slow or blocked on something
21:55:25 <lordcirth> Kinaesthetician, were you using the same username?
21:55:47 <Kinaesthetician> yes, I found it thanks
21:55:49 <edwardk> cheshircat: linear would be an awesome starting point. Amusingly it was what motivated the design of lens, but then I never really did a Doc pass on linear
21:55:57 <Kinaesthetician> http://www.cs.nott.ac.uk/~pszgmh/bib.html#monparsing
21:56:00 <Kinaesthetician> if anyones curious
21:56:14 <sebastianrkg> I used to use the MinGW shell on Windows... thought this WSL stuff was the future though
21:56:17 <edwardk> Despite spending months on docs for lens
21:56:42 <lordcirth> sebastianrkg, WSL is pretty neat, if you need Windows for other reasons
21:57:26 <sebastianrkg> lordcirth: yeah, but I'm wondering if it doesn't get along with `stack` too well
21:57:33 <sebastianrkg> lordcirth: https://news.ycombinator.com/item?id=14094964
21:59:00 <sebastianrkg> back to Virtualbox for me... sad times
21:59:40 <lordcirth> sebastianrkg, interesting
22:02:32 <cocreature> sebastianrkg: is there a specific reason why you are using it in wsl? ghc runs natively on windows
22:03:43 <sebastianrkg> cocreature: I'm trying to use `hoppy`, which needs unix
22:03:53 <cocreature> ah ok
22:04:32 <sebastianrkg> cocreature: I usually just directly use Windows, but I'm trying to wrap the LiquidFun/Box2D C++ library, and Hoppy seems nice for that
22:05:44 <cocreature> ime automatically generating ffi bindings doesn’t work very well in most cases since you end up with an API that you really don’t want to use in Haskell
22:06:02 <cocreature> so I tend to just write them manually using hsc2hs and c2hs
22:11:23 <EvanR> pop quiz, does aeson round trip json
22:11:32 <EvanR> ignoring whitespace
22:12:28 <cocreature> EvanR: json -> haskell -> json or haskell -> json -> haskell?
22:12:39 <cocreature> EvanR: also the right answer is “it depends on the instances” :)
22:12:45 <EvanR> Value
22:12:52 <EvanR> json -> haskell -> json
22:13:29 <kadoban> I don't recall there being any laws on the instances, so probably not a good assumption that it does.
22:13:34 <cocreature> for Value I would have expected that it does roundtrip (minus unicode escapes or silly things like that)
22:13:50 <EvanR> hrmrmmrmmrmm
22:14:17 <EvanR> minus which silly things is the question
22:14:20 <cocreature> it definitely does not roundtrip in general since the generic FromJSON instances ignore unused keys in objects
22:14:20 <EvanR> (now)
22:14:45 <EvanR> well in general its clear you can do whatever
22:15:04 <EvanR> but you probably dont want to write a custom Value
22:15:09 <cocreature> right but you could still expect the generic instances to roundtrip
22:15:17 <EvanR> of Generic
22:15:29 <EvanR> er... OH Generic!
22:15:57 <EvanR> ok, i will reveal the gotcha i was thinking of
22:16:19 <EvanR> the json ... [-0]
22:16:39 <EvanR> does Scientific preserve this minus?
22:16:50 <cocreature> try it out? :)
22:16:58 <EvanR> > -0 :: Scientific
22:17:00 <lambdabot>  error:
22:17:00 <lambdabot>      Not in scope: type constructor or class ‘Scientific’
22:17:25 <EvanR> it seems the answer is no
22:18:41 <EvanR> ...
22:19:15 <EvanR> well im a little disgusted at the behavior of the edge case
22:19:25 <EvanR> in a variety of languages!
22:20:44 <EvanR> JSON.parse "[-0.0]" gives [-0.0] in ruby
22:21:07 <EvanR> is there no way for haskell to reproduce it?
22:23:22 <mauke> > -0.0
22:23:24 <lambdabot>  -0.0
22:25:18 <EvanR> it gives 0.0 :: Scientific
22:25:54 <eckyp> Hi people, question: How do you do redirects in haskell-servant? My use case is something like: one endpoint may show some HTML page or redirect to other page based on data in DB
22:28:09 <cocreature> eckyp: something like throwError err303 { errHeaders = … }
22:30:04 <eckyp> cocreature: Thanks.
22:30:24 <EvanR> - as a prefix is insane
22:30:40 <EvanR> it causes no end of trouble
22:31:58 <sebastianrkg> cocreature: I want these ffi bindings to be internal to another library, so it's all good. I can handle the bindings looking a bit weird
22:33:02 <sebastianrkg> cocreature: these aren't really automatically generated anyway, they're generated from a Haskell file that defines the API
22:37:04 <dmj`> eckyp: redirects aren’t supported server-side afaik
22:56:46 <mniip> hmm
22:56:53 <mniip> I'm fairly sure I've seen this somewhere
22:57:23 <mniip> a thing where you implement a catamorphism for an ADT with many variants
22:57:42 <mniip> so instead of passing the fold functions for each constructor in sequence you aggregate them into a record
22:57:51 <mniip> does this thing have a name?
22:58:06 <johnw> cofree?
22:58:24 <mniip> no it was a dedicated datum
22:58:49 <mniip> like data ListFold a b = ListFold { cons :: a -> b -> b; nil :: b }
22:58:55 <johnw> I was thinking of this: http://dlaing.org/cofun/posts/free_and_cofree.html
22:58:58 <johnw> oh, I see what you mean
22:59:00 <mniip> foldr_ :: ListFold a b -> [a] -> b
22:59:07 <johnw> beautiful folds
22:59:36 <johnw> i hadn't seen it generalized, though
22:59:42 <johnw> recursors?
23:01:29 <wz1000> when I try to run stack setup on Arch, I get "Unable to find installation URLs for OS key: linux64-ncurses6-nopie"
23:02:44 <mniip> hmm, RtClosureInspect.TermFold
23:03:06 <mniip> https://github.com/ghc/ghc/blob/master/compiler/ghci/RtClosureInspect.hs#L245
23:03:53 <EvanR> interesting
23:04:15 <EvanR> if you check console on hackage docs youll see a warning about mathJAX's CDN
23:04:33 <EvanR> which was discontinued
23:04:46 <EvanR> didnt even know haddocks used mathjax
23:04:59 <orzo> What happens when you pattern match on OverloadedStrings ByteString arguments?  Is it an efficent search?
23:05:06 <cocreature> wz1000: install libtinfo from the aur
23:05:25 <mniip> hm
23:05:34 <mniip> I wanna implement system FC
23:05:39 <mniip> or, at least, outsidein
23:06:02 <mniip> cause even after reading the papers I feel like I know jack shit about constraints
23:06:30 <wz1000> cocreature: ok. Which stack are you using? I was using stack-static from the aur.
23:06:51 <cocreature> wz1000: I built stack myself but that doesn’t matter here
23:08:19 <wz1000> cocreature: thanks, that worked.
23:14:48 <EvanR> orzo: i didnt even know you could do that
23:15:10 <EvanR> to the Core mobile
23:18:34 <cocreature> orzo: afaik ghc doesn’t do anything particularly clever here. it just tries to match the string against each of the constants one by one
23:18:51 <EvanR> orzo: http://lpaste.net/356948
23:19:27 <EvanR> without optimizations
23:20:22 <EvanR> comparing using bytestring equality against ... an unpackCString...
23:24:23 <EvanR> lots of cast noise
23:26:37 <cocreature> -O2 still looks like it’s comparing them one by one although it seems to first compare the addresses, then the lengths and only then start to take a look at the actual bytes
23:27:19 <EvanR> so it inlined the equality test
23:27:53 <cocreature> yeah
23:28:02 <cocreature> and it floated the constants to the toplevel
23:29:38 <EvanR> a
23:29:50 <EvanR> if you change it from ByteString to IsString a => a
23:30:03 <EvanR> complains about missing Eq constraint, so thats how that works
23:30:23 <EvanR> probably no room for a clever test
23:30:32 <wz1000> Now I'm getting a linker error while building clock
23:30:37 <wz1000> http://lpaste.net/356949
23:31:57 <orzo> Does it do better on something like Integer?
23:31:58 <EvanR> 1
23:32:21 <EvanR> on Integer, its even worse since its potentially a GMP object
23:32:40 <EvanR> and potentially an machine Int
23:37:35 <EvanR> -O2 doesnt seem to be inlining anything for me either
23:37:40 <EvanR> for Integer
23:37:44 <ongy> wz1000: looks like you have a newer hsc2hs than the package intends hsc_alignment gets redefined, but afaik that exists for newer hsc2hs
23:38:42 <cocreature> I don’t think that’s the issue here
23:38:42 <wz1000> ongy: that is just a warning. I think the rodata thing is the real error
23:40:37 <cocreature> wz1000: https://github.com/commercialhaskell/stack/issues/3268 suggests that we need ncurses5-compat-libs instead of libtinfo (or in addition to?). I haven’t build a lot since I’ve run into this so maybe I’ve been lucky enough to avoid the problem so far
