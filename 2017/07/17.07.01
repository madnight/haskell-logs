00:00:07 <cocreature> codygman: that’s a little too vague to tell if you can solve it using pipes-group but it might very well be doable :)
00:00:46 <penguin359> However, after a few attempts at trying to start it, I'm realizing that my program is going to be quite I/O heavy and might not be the best fit for trying out a functional language.
00:01:08 <cocreature> penguin359: Haskell is great for I/O heavy programs!
00:01:18 <kadoban> penguin359: Haskell is a pretty decent imperative language actually.
00:01:28 <sternmull> cocreature: I was sure that it will never be used in another context. So it was my intuition that it would be good to couple it to the constraints that apply in other parts of my functions for that data.
00:01:33 <penguin359> Just a quick program to scan files and folders summing up the total size of a folder recursively of all it's contents.
00:02:40 <cocreature> sternmull: it might be a good idea in theory but it doesn’t really work in Haskell and I often find myself to be quite happy that I can reuse types for things the library author did not plan for
00:02:48 <penguin359> I'm finding the tutorials I was using focused quite a bit on the functional aspect and lacking in explaining this IO Monad.
00:03:37 <penguin359> Just trying to start by getting a list of files in the current folder and then running a filter to remove "." and "..", but I can't get it into a list of Strings it seems.
00:03:54 <cocreature> :t listDirectory
00:03:55 <lambdabot> error: Variable not in scope: listDirectory
00:03:59 <sternmull> cocreature: That makes sense.
00:04:03 <cocreature> :t System.directory.listDirectory
00:04:04 <lambdabot> error:
00:04:04 <lambdabot>     Not in scope: ‘System.directory’
00:04:04 <lambdabot>     No module named ‘System’ is imported.
00:04:09 <cocreature> :t System.Directory.listDirectory
00:04:10 <lambdabot> FilePath -> IO [FilePath]
00:04:21 <cocreature> ^ penguin359 that ’s probably what you’re looking for
00:05:31 <penguin359> I was using getDirectoryContents, but it looks like listDirectory doesn't include . and ..
00:05:50 <cocreature> penguin359: even easier, then you don’t need to remove them :)
00:06:30 <codygman> cocreature: So fixed width being like you are provided with indexes of where content starts [0,3,6] for a string "foobarbaz", I think if I could figure out how to loop over the producer created by Group.chunksOf and give it that list of indexes I could consume 0-3 (foo), append a delimiter, and then repeat for the rest of the line
00:06:39 <penguin359> OK, step two it to sort out by file type directory.
00:08:51 <cocreature> codygman: I’m still not following. so you are giving a text file and a list of indices representing character positions in that file or positions in each line? now what’s the result that you want to get out of this?
00:10:43 <penguin359> I see isSymbolicLink, but not isDirectory
00:11:17 <penguin359> Oh, there's doesDirectoryExist
00:12:35 <penguin359> Trying a filter with doesDirectoryExist reports that it expects FilePath, but got IO FilePath.
00:12:42 <cocreature> :t filterM
00:12:44 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
00:12:48 <cocreature> try that
00:17:15 <penguin359> found by import Control.Monad  Using :t it reports it works with Applicative m, but the documentation on haskell.org says it's (Monad m)
00:18:06 <Cale> penguin359: Yeah, it was recently generalised
00:18:38 <Cale> penguin359: You might be looking at documentation for the old one
00:19:17 <Lokathor> GHC can't timeout an IO action on windows
00:19:29 <Lokathor> I've known this for a few months, but it's sad every time i'm reminded of it
00:19:29 <Cale> Lokathor: hm? Using what method?
00:19:43 <Cale> Lokathor: this is with the threaded runtime?
00:19:54 <Lokathor> https://hackage.haskell.org/package/base-4.9.1.0/docs/System-Timeout.html that one
00:20:20 <Lokathor> I asked and they told me, "oh, sorry, the windows runtime just isn't capable of doing that, though progress has been made in recent years"
00:20:24 <Lokathor> and i was like "oh noooo"
00:20:31 <codygman> cocreature: indexes=[0,3,6]; inp= "foobarbaz"; delim="|" => "foo|bar|baz|"
00:20:40 <Cale> Lokathor: That seems to have special code for Windows
00:20:53 <cocreature> codygman: and you want to do that for each line using the same list of indices?
00:21:00 <codygman> cocreature: correct
00:21:27 <Cale> oh, or rather, it eliminates some of the code which uses bound threads when on windows...
00:21:54 <Cale> Lokathor: Have you tried just using async?
00:22:08 <Lokathor> well, i want getLine to timeout
00:22:12 <Lokathor> so... async can't do that :P
00:22:38 <Cale> hm
00:23:48 <Cale> uh, that seems to work for me on linux
00:23:59 <Cale> race (threadDelay 1000000) getLine
00:24:03 <cocreature> codygman: alright, so step 1: write something like "[Int] -> Producer Text m r -> Producer Text m r" where the producer corresponds to a single line and you insert the delimiters. Pipes.Text.splitAt is probably going to be very helpful for this
00:24:24 <Cale> will give you one second to type something and press enter, or else it'll kill it and give you Left ()
00:24:30 <cocreature> codygman: step 2: use Pipes.Text.lines and "maps" from Pipes.group to apply that function to each line
00:24:48 <Cale> Lokathor: give that a try on windows and see if it works
00:25:12 <cocreature> codygman: step 3: use "concats" from pipes-group to concatenate the lines back together
00:25:12 <Cale> (you can increase the delay to make it easier to test :P)
00:25:14 <cocreature> codygman: step 4: profit
00:26:05 <Lokathor> Cale, wow guess what
00:26:06 <cocreature> codygman: you might need to replace step 4 by: blame cocreature because he forgot something
00:26:08 <Lokathor> you'll never guess
00:26:12 <Cale> what?
00:26:29 <Lokathor> timeout works just not within ghci
00:26:38 <Cale> cool
00:26:42 <codygman> cocreature: Haha I noted down your suggestions (including blame cocreature :D) and will have to try that :)
00:26:58 <cocreature> Lokathor: didn’t we already have that exact conversation where you got to the same conclusion a while back? :)
00:27:24 <EvanR> its because -threaded doesnt work in ghci ?
00:27:25 <Lokathor> rather, the timeout result is what it should be (Just or Nothing) but the fact that it times out doesn't cancel the getLine, so the timeout hangs there until you do press enter eventually, then gives you the Nothing
00:27:51 <Lokathor> cocreature, i recall getting to the part where the windows runtime didn't do it right, not the part where it works as long as you're not in ghci
00:28:02 <Cale> Lokathor: and the version with race?
00:28:04 <cocreature> hm maybe I’m missremembering
00:28:08 <Cale> Lokathor: does that work in ghci?
00:28:13 <Lokathor> ah hmm
00:28:37 <cocreature> afaik proper IO support for windows is planned for 8.4 so hopefully things will improve at that point
00:28:42 <codygman> cocreature: Just to clarify, this would only apply fixedWidthLine to a single line right: Text.runSafeT $ runEffect $ Text.readFileLn "test1024.fixedwidth" >-> P.map (fixedWidthLine [682,682]) >-> Text.writeFileLn "test1024.delimited"
00:28:58 <penguin359> Trying this, but it's still not getting the IO Monad in the type:
00:28:59 <penguin359> filterM doesDirectoryExist (listDirectory ".")
00:29:18 <Lokathor> flip
00:29:21 <Lokathor> where is threadDelay again
00:29:26 <cocreature> codygman: no P.map is like map for lists. it applies it to every element you get from the producer which in this case are the lines from your file
00:29:39 <Lokathor> EvanR, the compiled demo didn't use -threaded anyway
00:29:46 <Cale> penguin359: filterM still wants a list to iterate over, not an action which when executed will produce one
00:30:07 <Cale> penguin359: So, just run listDirectory "." first, and pass its result to filterM instead
00:30:49 <Cale> penguin359: do xs <- listDirectory "."; filterM doesDirectoryExist xs
00:30:57 <penguin359> ok, that works
00:31:03 <Lokathor> Cale, the race version does not work in ghci. Seems to be a fundamental flaw in how GHCi interacts with things
00:31:14 <Cale> Yeah
00:32:38 <Cale> penguin359: The difference between a value of type IO String and a value of type String is like the difference between /bin/ls and a list of files in your home directory :)
00:33:09 <penguin359> Oh, filterM is for handling the Monad of doesDirectoryExist, not listDirectory.
00:33:13 <Cale> yeah
00:33:25 <penguin359> That was part of my confusion.
00:33:32 <geekosaur> Lokathor, Control.Concurrent
00:33:43 <Lokathor> i found it eventually
00:33:45 <Lokathor> so many modules
00:33:46 <penguin359> As I have to use filter if I'm instead working with isPrefixOf
00:33:49 <Lokathor> ghci should just know what i mean
00:33:53 <geekosaur> The "thread" part is a hint :)
00:34:15 <Cale> penguin359: It's that your condition for keeping or throwing away each element depends on doing some I/O here
00:34:22 <EvanR> threadDelay is in <your favorite alternative prelude>
00:35:02 <cocreature> Lokathor: http://hoogle.haskell.org/?hoogle=threadDelay%20is%3Aexact helps for figuring out the module something is from
00:35:15 <Cale> penguin359: Another cute example of filterM is to use it with the list monad -- the list monad lets you implicitly make decisions between many options. So we could write
00:35:15 <penguin359> Yep, OK, then I take it that means I'll find a mapM for later when I map each file with getFileSize?
00:35:22 <Lokathor> threadDelayInMilisecondsYouInsaneGHCDevsWhyDidYouPickMicrosecondsBeforeThis
00:35:28 <Cale> > filterM (const [False, True]) [1,2,3]
00:35:30 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
00:35:39 <Cale> "For each element of the list, throw it away, or keep it"
00:35:56 <Cale> and it'll try all possibilities
00:36:18 <Cale> penguin359: yeah
00:36:55 <Cale> penguin359: If you're doing a lot of stuff to each of the items in the list, it may be more convenient to use forM, which is mapM with the arguments flipped
00:36:58 <Cale> So you can write
00:37:04 <Cale> forM xs $ \x -> do
00:37:08 <Cale>   some stuff here
00:37:34 <Cale> i.e. "for each x in xs, do this stuff"
00:38:46 <Lokathor> cocreature, hey this is the ticket i was talking about https://ghc.haskell.org/trac/ghc/ticket/7353
00:38:55 <Lokathor> maybe someone else talked about the same ticket with you?
00:39:30 <codygman> Any better way to write my recursive fixedWidth function or my appendAt function (maybe appendAt already exists?): http://lpaste.net/356598
00:39:36 <cocreature> Lokathor: maybe, I guess I’m getting old and my memory is getting shitty :)
00:39:46 <cocreature> although I’m really not that old so that’s kind of sad
00:39:48 <Lokathor> you don't look a day over 1,000
00:40:26 <Lokathor> codygman, why a list of line lengths?
00:40:53 <codygman> Lokathor: that's how I've typically gotten it for fixed width file descriptions
00:41:18 <Lokathor> oh, this isn't for like printing to a terminal?
00:42:53 <penguin359> OK, making real progress finally. Now I've folded the map of file sizes down to a single sum for the folder. Next up, recursively apply for all directories found.
00:42:58 <penguin359> Thanks!
00:43:50 <geekosaur> next up, discovering the existence of sparse files :p
00:46:06 <penguin359> Actually, I was a little more concerned about those hard links I've been using. Might end up double counting them unless I start tracking inode numbers.
00:51:33 <cocreature> the unix package can give you the inodes if you really need it
00:52:24 <penguin359> I think I'll save hard links for version 2.0
00:52:33 <cocreature> :)
00:52:55 <codygman> Lokathor: Nah, just a some random bytes given meaning by a file containing field names and offsets ;)
00:53:00 <geekosaur> didn't think anyone but us greybeards (ok, figuratively in my case) used hard links any more
00:53:33 <penguin359> It also adds some non-deterministic behavior. As I'm picturing it in my mind, the basic algorithm can scan files in any order, but once I start rejecting duplicate links, the order begins to matter.
02:07:57 <kirosai> Hello, world>.<
02:17:02 <Myrl-saki> What's the advantage of using a class over using a type when it comes to an API? `class Handler a` vs `:: a -> Handler`
02:18:19 <c_wraith> Often what you really want is data Handler a ...
02:19:09 <Myrl-saki> Oh right. I forgot in what sense. Extensibility.
02:19:46 <c_wraith> There's really no difference there.
02:20:19 <Myrl-saki> c_wraith: Why does XMonad do the former?
02:20:27 <c_wraith> Here's the important metric - if you find yourself creating new types just to have a different instance to use an API, the shouldn't be using a class.
02:22:04 <Myrl-saki> c_wraith: Right.
02:23:01 <c_wraith> as far as XMonad - it's pretty old.  It's certainly one of the first haskell programs to get widespread use
02:23:14 <Myrl-saki> c_wraith: Just a little question because I think in https://hackage.haskell.org/package/req-0.2.0/docs/Network-HTTP-Req.html Expandable refers to using class-as-types(I'll refer to it as that.).
02:29:34 <c_wraith> Myrl-saki: what's a specific class in there that you are curious about?
02:31:08 <c_wraith> also, when did haddock start showing instance documentation in instance lists? That's really nice, compared to what it used to do?
02:35:15 <Myrl-saki> c_wraith: HttpMethod is an easy one.
02:35:52 <Myrl-saki> https://hackage.haskell.org/package/req-0.2.0/docs/Network-HTTP-Req.html#t:HttpMethod
02:37:14 <c_wraith> that one's not simple at all :)
02:37:57 <c_wraith> That one is a class almost entirely to enforce that a type instance is created.
02:38:24 <c_wraith> if you notice, the type instance is not part of only member of the class
02:38:52 <c_wraith> that alone should tell you something really weird is going on
02:46:41 <c_wraith> Myrl-saki: let me guess, you missed most of that while you were timing out?
02:57:28 <kaol> I find myself writing code like maybe (throwE ...) return =<< either (throwE ...) return =<< doStuff. Does this remind someone of some pattern?
03:00:38 <zomg> how do you usually keep a threaded process going? I find myself just adding a void $ getLine to the end of main because I couldn't think of anything better :D
03:01:49 <LiaoTao> zomg: Wait for you threads to finish?
03:01:51 <LiaoTao> your*
03:04:12 <zomg> as far as I can tell Control.Concurrent.Timer has no indicators for what you can wait
03:04:31 <zomg> but yeah if it did then that would certainly make sense :P
03:06:46 <cocreature> zomg: use async to spawn the threads and waitAnyCancel to wait for the threads to finish
03:07:15 <cocreature> (or wait for all threads to terminate instead depending on what you want)
03:08:22 <zomg> yeah I'm actually using async and waits within the timer I kick off with repeatedStart and all of that works well :)
03:08:34 <cocreature> then I don’t understand your question
03:08:42 <zomg> I guess it might just be a peculiarity of Control.Concurrent.Timer that it doesn't give you an MVar or whateever to wait on
03:08:45 <Myrl-saki> c_wraith: Sadly
03:09:01 <cocreature> ah
03:09:12 <Myrl-saki> c_wraith: If you're still there, can you resend it? Or PM so that it won't be too spammy.
03:10:10 <cocreature> zomg: isn’t "stopTimer" meant for waiting?
03:10:29 <cocreature> hm no I guess you don’t want to stop your timer
03:11:23 <zomg> yeah
03:11:28 <cocreature> yeah looks like the api is kind of bad in that regard
03:11:42 <cocreature> depending on what you need it might be easier to just roll your own timers or search for a different package
03:11:55 <cocreature> it doesn’t look like it’s maintained either
03:11:57 <zomg> it works, just thought it was odd that it didn't seem to have any indicators :)
03:12:31 <zomg> my program pretty much just runs within the timer so it doesn't matter if it has no indicators on when it stops
03:16:39 <zomg> hm actually I guess an easy solution would be to pass an MVar into the function that you run in the timer and just have a stopTimer with the MVar afterwards
03:17:06 <zomg> this way the function could signal an exit and the program can block
03:35:13 <zomg> well, annoyingly that seems to lead to a thread blocked indefinitely error :P
03:35:29 <zomg> meh, don't really need it so sticking to using getLine I guess
03:39:33 <zomg> oh, fixed it with BangPatterns purely on a hunch ¯\_(ツ)_/¯
03:46:19 <sternmull> I have a case expression where every case (except the default one) return True. Is there a more elegant way than writing all the "| 123 -> True" lines?
03:52:04 <zomg> sternmull: wouldn't doing defaultValue -> False and then _ -> True work?
03:52:10 <zomg> because _ will match anything
03:53:05 <sternmull> zomg: No there are a few values (not just one) that should result in True and all others should return False.
03:54:00 <sternmull> i can live with it as it is now, but i wondered if there is a better solution because it looks like a common pattern
03:55:48 <ADG> My pc crashes after running this program: https://hastebin.com/raw/umuhedayum, what could be possible cause?
03:56:11 <sternmull> zomg: Something like this https://wiki.haskell.org/MultiCase would be nice in such cases
03:57:38 <zomg> you could probably do something like x `elem` [truthyValue1, truthyValue2, ...]
03:57:40 <sternmull> ADG: i would guess it is eating up all your memory and then the "out of memory killer" kicks in and terminates arbitrary processes.
03:57:42 <zomg> but yeah not sure if there's any other way :)
03:58:27 <ADG> keyboard mouse nothing works :P
03:58:38 <sternmull> zomg: Ah, no. For my taste pattern-lines are nicer than "elem".
03:58:45 <ADG> sometimes laziness is evil
03:58:54 <sternmull> ADG: Are you on linux?
03:58:57 <ADG> yes
03:59:47 <Myrl-saki> Is it good practice to put all your types under Types.hs?
04:00:11 <sternmull> then the memory could really be the problem. You can pass runtime options to your haskell program to limit the amount of memory that the heap can take. You should try this. Then its only your program that crashes... not the whole system.
04:00:29 <zomg> Myrl-saki: I seem to do that as well :P Generic dump module for types I can't think of any better place for
04:00:48 <zomg> but I find once I actually have a type and maybe some functions for the type, I might put them into their own module
04:00:59 <Myrl-saki> zomg: So. Language
04:01:01 <Myrl-saki> Whoops
04:01:11 <Myrl-saki> zomg: So, module-specific types should be set in their own types?
04:01:13 <Myrl-saki> Ffs
04:01:32 <Myrl-saki> k and m are beside each other, so kill-line becomes send.
04:01:38 <zomg> heh
04:01:48 <Myrl-saki> zomg: So, module-specific types should be set in their own modules?
04:01:56 <Myrl-saki> set/declared
04:02:04 <zomg> I'm just an advanced beginner (or something) in Haskell so I don't really know the standard practices :)
04:02:20 <zomg> but at least from experience in other langs, I tend to keep things simple and avoid extra fluff
04:02:34 <zomg> if I have a module which needs some types and those types aren't needed anywhere else, I just stick 'em into that module
04:02:49 <Myrl-saki> zomg: Ah. I need them needed elsewhere though.
04:02:52 <zomg> but if they need to be shared, then it might make sense to extract into their own module
04:02:55 <Myrl-saki> zomg: Probably some mutual dependence too.
04:03:20 <zomg> yeah seems like they probably should be in their own module then, to avoid a circular dependency
04:03:37 <zomg> I don't actually know if circular deps are a problem for haskell but I tend to try and avoid them anyway :P
04:04:10 <sternmull> ADG: Adding something like "+RTS -H32m -S -RTS" to your commandline would limit the heap size of your program to 32MiB.
04:04:41 <ADG> H is for hrap size? -S? -RTS?
04:05:16 <sternmull> The -S was an accident (but does not hurt). See here https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/runtime-control.html
04:06:23 <ADG> thanks very much
04:07:29 <ADG> what are some of the common/useful options out of these?
04:10:25 <sternmull> depends on what you are interested in just skim the list: https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/runtime_control.html (link to current version of GHC docs, my previous link was to an older one)
04:13:13 <ADG> rtsopts does not compile? https://hastebin.com/raw/fenonadiqa
04:13:24 <ADG> oops spelling mistake
04:23:02 <sternmull> ADG: Oops, I told you the wrong options. -M and -K should allow you to limit the memory use.
04:48:30 <cocreature> is there a reason why something like foldrM1 is not in base? I want it for NonEmpty so the fact that it’s partial for [] is not applicable here
05:03:24 * hackagebot haskell-tools-ast 0.8.0.0, haskell-tools-backend-ghc 0.8.0.0, haskell-tools-cli 0.8.0.0, haskell-tools-daemon 0.8.0.0, … and 5 more
05:03:24 * hackagebot  → https://hackage.haskell.org/packages/recent
05:13:31 * hackagebot superrecord 0.2.0.0 – Supercharged anonymous records – https://hackage.haskell.org/package/superrecord
05:14:05 <Athas> Does anyone know which tech was used to write the book 'Parallel and Concurrent Programming in Haskell'?  I really like that it has both a nice web version and a printed version.
05:14:28 <pranjal> Hello, need a little help. I'm trying to write test Suite based on HUnit and there in order to compile code i've written a function using `createProcess`, and while compiling the entire thing using ghci I'm getting this error message "ghcjs: createProcess: runInteractiveProcess: exec: does not exist (No such file or directory)". I tried to look for it but unable to find any solution. Thanks in advance!! :)  
05:18:01 <cocreature> pranjal: that error message usually means that the executable you’re trying to run does not exist.
05:18:17 <cocreature> pranjal: using createProcess with ghcjs seems a bit weird, what are you trying to do
05:19:11 <pranjal> What I am trying to is write a compiler wrapper over ghcjs such that it takes an input of a haskell source file and compile and returns the output.
05:19:29 <cocreature> ah ok
05:20:33 <cocreature> pranjal: are you sure the "ghcjs" binary is in your PATH?
05:21:12 <pranjal> cocreature: How can I make sure that?
05:21:25 <cocreature> pranjal: which os are you on?
05:21:58 <pranjal> Ubuntu16.04
05:21:59 <piyush-kurur>  quick question, how do you link to a class in a haddock document. I tried `Storable`, it does not seem to work
05:22:12 <cocreature> pranjal: try ":! which ghcjs" from inside ghci
05:22:20 <cocreature> piyush-kurur: 'Storable' should work
05:22:28 <cocreature> piyush-kurur: references are never in backticks in haddock
05:22:54 <pranjal> cocreature: got nothing!
05:23:10 <cocreature> pranjal: nothing as in no output? that should at least show an error message
05:23:32 <pranjal> Nah, No output!
05:23:45 <cocreature> oO
05:24:08 <Tuplanolla> Try `:!which which` then, pranjal.
05:24:42 <pranjal> got some filepath `/usr/bin/which`
05:24:49 <piyush-kurur> cocreature: thanks, it worked
05:24:53 <felixgb> hola, I was wondering if there was a good library for parsing XML using Text, with some good examples?
05:25:12 <Tuplanolla> So `which` is there, but not working correctly.
05:25:27 <cocreature> is which a shell builtin?
05:26:05 <piyush-kurur> I noticed that my cabal haddock is not able to link to the standard type classes, even the Storables in the constraints were not linking. So it was not a problem of the mark up but haddock not being able to find the docs of Storable
05:26:07 <Tuplanolla> Ah, indeed; `/usr/bin/which ghcjs` quietly exits with `1` for me.
05:26:15 <Tuplanolla> (Since I don't have it.)
05:26:31 <cocreature> hm I get an error message with sh, zsh and bash
05:26:44 <piyush-kurur> cocreature: the back ticks also work
05:26:46 <cocreature> pranjal: alright so where did you install ghcjs to?
05:27:16 <cocreature> piyush-kurur: huh, maybe that’s somewhat “new”. I’m pretty sure that they didn’t work at some point
05:27:37 <pranjal> Ah! got the problem, there is some issue with ghcjs only
05:27:51 <cocreature> ah yeah
05:27:57 <pranjal> Thank you :) 
05:27:58 * piyush-kurur feels haddock has AI and some times has its on way to sulk
05:28:19 <piyush-kurur> s/on/own/
05:29:09 <ha> German speaking haskell expert here?
05:30:06 <piyush-kurur> nein
05:30:14 <piyush-kurur> :-)
05:32:32 <piyush-kurur> ha: you may ask the question in any case
05:37:38 <padre_angolano> but do it in frisian instead
05:40:04 <bbear> hello
05:40:27 <bbear> how is  the community effort to spread haskell use at the moment 
05:41:25 <hpc> we tried as hard as we could but it became popular anyway
05:45:24 <bbear> how do you debug in haskell ?
05:47:55 <bbear> what is the '|' operator ?
05:48:03 <kirillow> :^D
05:48:34 <cocreature> there is no | operator
05:48:54 <bbear> Prelude Debug.Trace> f x y = x+y
05:48:56 <bbear> Prelude Debug.Trace> f x y | trace (show x++"+"++y++"=") (f x y)=undefined
05:49:08 <cocreature> that’s not an operator. it’s called a guard
05:49:15 <bbear> ho yeas
05:49:27 <bbear> so it's a redefinition of f ?
05:49:42 <cocreature> f x y | b = x means that the pattern will match if x and y matches and b evaluates to True
05:50:03 <cocreature> it’s not a redefinition. it’s just the normal definition
05:50:23 <bbear> basically what is the purpose of trace ?
05:51:13 <cocreature> it’s for printing things to stdout during debugging even if you’re outside of IO
05:52:01 <bbear> ok, how can you do it to stderr ?
05:52:09 <kirillow> this is golden
05:52:13 <cocreature> hm I guess it is stderr not stdout
05:52:41 <cocreature> bbear: it’s _only_ for debugging so there is not a lot of customization options available
05:53:35 <bbear> ok I see
05:54:11 <cocreature> but trace is implemented in Haskell. it’s not some primop so you can take a look at the source and implement your own version
05:54:24 <bbear> so what is the pattern ?
05:54:28 <bbear> you define your functions ?
05:54:42 <bbear> then you define modified functions with trace ?
05:54:45 <bbear> :t trace
05:54:46 <lambdabot> error: Variable not in scope: trace
05:55:26 <bbear> that doesnt really make sense to me
05:56:05 <bbear> when you write : "myfun a b | trace ("myfun " ++ show a ++ " " ++ show b) False = undefined" it looks like you are pattern matching the 'False' value
05:56:36 <bbear> since trace anyString anyThing is anyThing
05:58:23 <bbear> what does that even mean ?
05:59:28 <geekosaur> do you understand how guards work?
05:59:35 <bbear> yes
05:59:57 <geekosaur> I'm tempted to say you do not, since "what does that even mean?"
06:00:33 <geekosaur> what it means is it evaluates the guard to False and evaluates the trace as a side effect, then goes on to the next equation which is your actual function
06:00:55 <bbear> let f x | x==1=3 | x==2=4 | otherwise=5
06:00:56 <bbear> ha yes
06:01:03 <bbear> a guard takes boolean
06:01:15 <bbear> ok I got it
06:01:19 <geekosaur> @src otherwise
06:01:19 <lambdabot> otherwise = True
06:05:01 <bbear> mg
06:05:07 <bbear> haskell nearly broke my system
06:08:28 <bbear> lazy evaluation makes it painful to debug
06:08:32 <bbear> I just saw that.
06:17:02 <bbear> do not use 'cycle' in real apps
06:19:04 <kirillow> thanks
06:25:20 <Gurkenglas> Why not use cycle?
06:26:43 <bbear> I believe I have been careless but it seems to eat all the memory very fast
06:26:54 <bbear> I am not sure of 
06:27:43 <bbear> thinking in Haskell is tough, lazy evaluation is hard to grasp. It seems that to program, you have to be conscious on the limitations of the machine (size and space complexity) and Haskell makes it different to reason about this things.
06:28:06 <bbear> potentially cycle holds an infinite list. 
06:29:04 <cocreature> that’s the whole point of cycle
06:30:13 <bbear> you know cycle(cycle [1..])
06:32:21 <bbear> it could go forever
06:32:33 <bbear> not to mention cycle(cycle(cycle [1..]))
06:32:33 <glguy> that's the point of cycle
06:33:04 <zomg> I once used iterate successfully
06:33:13 <glguy> what are you trying to show by stacking up cycle?
06:33:16 <zomg> at that point I felt like I understood *something* about how infinite lists work
06:33:19 <zomg> :P
06:33:27 <bbear> you know
06:33:41 <bbear> let me demonstrate what i am trying to do
06:35:05 <bbear> say you have a function takeFirstFive (x:xs) acc = if acc < 5 then x:(takeFirstFive (xs) (acc+1)) else []
06:38:05 <kirillow> if what youre trying to do is invent a less helpful version of take, you succeeded - what seems to be the problem?
06:38:38 <bbear> now imagine you want to keep the position in the cycle
06:38:50 <bbear> then you write something like that : 
06:38:52 <bbear> takeFirstFive (x:xs) acc = if acc < 5 then (x:fst (takeFirstFive (xs) (acc+1)),xs) else ([],(x:xs))
06:40:01 <bbear> at some point if you evaluate this, you are forced to evaluate an infinite list
06:40:08 <bbear> that's bad
06:42:11 <bbear> try doing takeFirstFive (cycle [1..100]) 0
06:43:33 <bbear> you'd have to call fst (takeFirstFive (cycle[1..100]) 0) and if you want to call takeFirstFive on the remaining list, you have to be careful to not evaluate explicitely the rest of the argument.
06:44:00 <bbear> that's a little complex as a construct I'm not sure I am doing it right but hopefully I gave you an glimpse of the problem.
06:49:56 <sepakorayl> the <*> non-lazy on it's secon argument seems useful for MaybeT
06:50:53 <sepakorayl> is there a Maybe that is not lazy on the second argument of >>= ?
06:51:24 <sepakorayl> ignore that
06:59:08 <kirillow> bbear: then just dont evaluate an infinite list. same as with cycle.
06:59:18 <Gurkenglas> bbear, takeFirstFive [1..] == ([1..5],[2..]) btw
07:00:37 <Gurkenglas> (umm, "takeFirstFive [1..] 0", of course.)
07:02:56 <Gurkenglas> bbear, what exactly do you mean by evaluate? Pattern matching only evaluates to weak head normal form, ie doesn't hang by going through the infinite list. Hanging that way is hard to do accidentally, you have to do something like sum or last.
07:08:06 <kirillow> pretty sure they are trying to print `drop 5 [1..]` :^D
07:11:27 <clamchowder> hello, my `cabal install aeson-pretty` results in `gcc' failed in phase `Linker'. Anyone knows a fix?
07:13:49 <glguy> clamchowder: the best way to get help with an error message is to make the error message available via a paste bin along with the question
07:13:56 <glguy> we can't see your screen
07:19:01 <clamchowder> glguy: OK thanks
07:21:58 <clamchowder> here is the paste: http://lpaste.net/3185533580805668864
07:22:14 <bbear> another fishy point is that evaluation
07:26:08 <hjulle> Is it possible to use template haskell declarations in GHCi? In other words, I want to evaluate something of type Q [Dec] and have ghci use those declarations.
07:26:57 <glguy> clamchowder: looks like someone deleted all your libraries
07:27:34 <glguy> clamchowder: did you wipe out your .cabal directory lately?
07:28:06 <glguy> hjulle: yeah, that works
07:28:13 <clamchowder> glguy: no, but i just did `cabal update` first time in the past 47 days..
07:28:32 <glguy> that's probably not relevant
07:28:36 <clamchowder> glguy: perhaps I should update all the packages?
07:29:14 <hjulle> glguy: How do I do that?
07:30:21 <hjulle> glguy: I just get the error "No instance of Show (Q [Dec])" when I try it.
07:30:53 <glguy> clamchowder: you're missing libraries that come with ghc. you probably need to reinstall ghc. how did you install your current ghc?
07:31:02 <clamchowder> glguy: I can see some of the `cannot find ` packages installed in /usr/lib/ghc-8.0.2/
07:31:14 <clamchowder> glguy: but not in ~/.cabal
07:31:54 <glguy> hjulle: ghci needs to think it's handling declarations, write one before your TH splice separated with a ;
07:32:09 <clamchowder> glguy: I installed from official repo of Arch Linux using pacman
07:32:12 <glguy> data Example; mySpliceHere
07:32:55 <glguy> clamchowder: ok, then either you need to install the libraries separately/manually in Arch Linux
07:33:22 <glguy> or you need to ask in a channel about Arch Linux what they've done to their ghc package
07:33:42 <glguy> I saw a Reddit post that they changed something recently
07:35:09 <clamchowder> glguy: ah I found something in arch wiki
07:35:21 <clamchowder> "GHC uses static linking by default and the -dynamic flag is used to select dynamic linking. Starting with package version 8.0.2-1, the Arch ghc package no longer contains static versions of the GHC platform libraries. Installing the ghc-static package is now necessary for the default compilation flags to work. "
07:36:44 <clamchowder> glguy: I guess that is the problem? Which one is better, dynamic linking or static linking?
07:36:56 <glguy> no
07:37:05 <yushyin> clamchowder: that’s up to you
07:37:08 <glguy> neither is better
07:37:09 <hjulle> glguy: Thanks. Just putting a ; at the end of the line was enough.
07:37:21 <Clint> all linking is bad
07:37:27 <glguy> hjulle: ah, good to know
07:38:49 <clamchowder> can I use dynamic linking in cabal install?
07:41:38 <clamchowder> glguy: OK I used --enable-executable-dynamic flag in cabal install and the error is gone. Thanks for the help.
07:48:23 <pavolzetor> good morning, I need to deinterleave bytestring into two and then append them at the end. Should I convert first to Vector and do it in ST?
07:48:39 <pavolzetor> https://github.com/openexr/openexr/blob/develop/OpenEXR/IlmImf/ImfZip.cpp
07:48:49 <herm> Heya. I have a question! I have a fun and simple little open source Haskell project that I'm using to help myself learn Haskell, and I want to open it up to other contributors to do the same. How do I tell people about it?
07:49:01 <herm> I just tried making a post to /r/haskell, but the mods removed it without explanation
07:49:07 <pavolzetor> this is the algorithm (compress method, reorder and predictor stages)
07:52:53 <zomg> herm: reddit is a bit of a pain in the ass :P
07:53:49 <herm> zomg:  Hah, sometimes yeah. The mods in /r/haskell specifically seem to play it kinda fast and loose. They don't even have any posted rules
07:53:59 <Tuplanolla> Considering all the garbage that gets through, I didn't even know they remove posts there, herm.
07:54:33 <herm> Tuplanolla: Savage.
07:54:44 <piyush-kurur> herm: my first post got into their (i.e. reddit's) spam checker 
07:54:55 <pavolzetor> I probably try list first and hope lazyness takes care of it
07:55:06 <piyush-kurur> the moderators had nothing to do with it
07:55:21 <piyush-kurur> try contacting one of them and they will fix it
07:55:24 <herm> piyush-kurur: Ohh, that would make sense.
07:55:32 <herm> Thank you!
07:56:33 <piyush-kurur> The UI of /r/haskell is a pain actually
07:56:59 <piyush-kurur> somehow my name got into the suggested title and that was enough to trigger the spam checker
07:57:00 <herm> Anyways, if anyone wanted to check out the project in question, here it is: https://github.com/JackKiefer/herms It's currently less useful than a pen and stack of cards, but its been fun to program anyway :)
07:57:06 <zomg> fwiw, if you want to link something when you're not active in some subreddit, post it as a text post
07:57:22 <angryMonk> Hey there!
07:57:30 <zomg> little explanatory description and a link can work better than just a direct link post
07:57:43 <herm> zomg: Yeah, that's what I did. I'll contact the mods.
07:58:04 <herm> zomg: I think it may have been flagged because I used a throwaway to post it since my personal info is on my github
07:58:12 <zomg> probably :)
07:58:34 <herm> Well, thank you everyone! What a lovely community :)
08:05:16 <angryMonk> Hi there!
08:05:22 <angryMonk> how's everyone doing?
08:07:31 <clamchowder> hello, i'm trying to cabal install pandoc from source. I can see there are two directories with haskell packages installed. One is /usr/lib/x86-64-linux-ghc-8.0.2, and the other one is ~/.cabal/lib/x86-64-linux-ghc-8.0.1. After successfully cabal install pandoc, when I try to run pandoc, it complains not finding a library libHSold-time-1.1.0.3-EZzkBJ4NQxX4hHavrKxgaT-ghc8.0.2.so. I can see this file 
08:07:37 <clamchowder> in the /usr/lib/.... directory but not the ~/.cabal/.... directory. How can I fix it?
08:08:40 <clamchowder> There is a libHSold-time-1.1.0.3-IcvdkJUsE9M8t3io8peAEp-ghc8.0.1.so in the ~/.cabal/.... directory.
08:09:20 <eacameron> clamchowder: Try using stack: stack install pandoc
08:10:06 <clamchowder> My guess is that when I cabal install pandoc, cabal made a pandoc binary which record the file in /usr/lib/, but when running pandoc it looks for the file in ~/.cabal/
08:10:32 <cocreature> clamchowder: did you run "cabal install pandoc" as root?
08:10:44 <clamchowder> cocreature: no
08:10:46 <cocreature> clamchowder: where is the pandoc binary that you’re running?
08:11:00 <clamchowder> cocreature: it's from ~/.cabal
08:11:29 <cocreature> clamchowder: ~/.cabal or ~/.cabal/bin?
08:11:34 <yushyin> clamchowder: for non system packages it may be better to do static linking
08:11:50 <clamchowder> cocreature: ~/.cabal/bin
08:12:36 <clamchowder> yushyin: why would this be a static / dynamic linking issue?
08:13:14 <yushyin> clamchowder: also why not just install pandoc from the repository of your distribution?
08:13:41 <clamchowder> yushyin: because I'm editing the pandoc source
08:14:29 <monochrom> What is the verbatim unabridged uninterpreted error message?
08:14:44 <yushyin> clamchowder: if you had linked it statically, pandoc would not need to search for the dynamic lib
08:15:17 <clamchowder> I also feel like it's a bit redundant to have two directories of ghc libs..
08:16:19 <monochrom> That can be explained later. But what is the error message verbatim unabridged now?
08:17:35 <clamchowder> yushyin: but if I try to link it statically I would get an error, because of the arch linux thing. I can install the ghc-static in arch linux but I suspect the problem won't be solved: cabal would simply look at /usr/lib when compiling and the pandoc binary would still look into ~/.cabal/ when running
08:18:32 <yushyin> if you link all this stuff statically, no.
08:18:37 <monochrom> No, that's the difference between static linking and dynamic linking.
08:18:50 <monochrom> With static linking the libraries are already in the exe.
08:19:13 <monochrom> This is actually the default for the rest of us so we never ran into this.
08:19:14 <cocreature> clamchowder: did you explicitely enable dynamic linking? otherwise the ghc in archlinux still links statically by default but doesn’t bring static libraries which can weird problems
08:20:18 <monochrom> Sure we have our share of cabal hell and stack hell too but it's just build-time problems for us. If we get past building, we're done.
08:20:49 <clamchowder> cocreature: i explicit told cabal install to do dynamic linking because I didn't have ghc-static.
08:21:06 <Tuplanolla> Then we put the executable on a system with the wrong `libgmp.so`.
08:21:13 <cocreature> clamchowder: so please show us the exact command and you ran and the full output you got
08:21:16 <yushyin> clamchowder: '... static linking is often the preferred option for local development outside of the package system.' says the arch linux wiki. here 'package system' means packages from the arch repository
08:21:19 <monochrom> OTOH even with dynamic linking, the file doesn't just disappear.
08:21:43 <monochrom> So I'm wondering if you're misinterpreting the error message to us.
08:22:11 <clamchowder> yushyin: I see...
08:22:42 <monochrom> Isn't it great? Just yesterday we had another person who asked about performance issues but successfully defied posting actual code for 3 hours.
08:25:24 <clamchowder> I installed ghc-static and got the same error when cabal install pandoc (without the dynamic linking flag). One moment while I post the error output.
08:27:08 <clamchowder> monochrom: I am simply compiling the pandoc from the official github repo.
08:27:34 <monochrom> I am talking about the error output.
08:31:07 <clamchowder> This is the error message I got when running the dynamically compiled pandoc: http://lpaste.net/528788131441278976
08:31:48 <clamchowder> This is the error message when I `cabal install` pandoc after installing the ghc-static package: http://lpaste.net/2368144344520589312
08:33:08 <Tuplanolla> If only there was a type system at the operating system level that prevented these kinds of things...
08:33:25 <cocreature> clamchowder: are all of the packages shown in that error message you get when linking statically, packages that you installed via pacman and not via cabal?
08:35:48 <clamchowder> cocreature: I just randomly selected 3 of them and looked for them and they are in /usr/lib not ~/.cabal so I think the answer is yes.
08:36:12 <cocreature> gnah, I hate that arch fucked up static linking
08:36:26 <monochrom> What did arch do?
08:36:29 <cocreature> clamchowder: does setting LD_LIBRARY_PATH help with running pandoc?
08:36:43 <cocreature> monochrom: they decided to only ship dynamic libs by default while still having a ghc that defaults to static linking
08:37:10 <cocreature> monochrom: and apparently cabal considers packages installed if dynamic libs are present even when linking statically
08:37:13 <cocreature> so you get these weird error messages
08:37:42 <monochrom> Ah OK so GHC (or ld called by GHC) says "I can't find the *.a files", is that right?
08:37:48 <cocreature> the only solution is to nuke everything haskell related that you installed via pacman except for ghc and ghc-static
08:37:49 <yushyin> can one built a ghc which favors dynamic linking by default?
08:37:57 <cocreature> afaik you can
08:37:58 <clamchowder> cocreature: let me google ld_library_path to find out how to do it
08:38:16 <cocreature> clamchowder: LD_LIBRARY_PATH=/usr/lib/ghc/whatever mypandoc
08:38:18 <yushyin> arch should at least to that
08:38:28 <yushyin> do that
08:38:42 <monochrom> I was thinking of LD_LIBRARY_PATH too but the paths are normally coded into the exe already.
08:38:53 <cocreature> monochrom: yeah but it’s worth a try
08:39:20 <cocreature> I love how the arch maintainers managed to make things worse for haskell devs and people who just want to use things written in pandoc at the same time
08:39:25 <clamchowder> cocreature: do that in bash? OK.
08:39:56 <cocreature> clamchowder: obviously you need to replace whatever with the path to the directory containing the shared libs
08:40:24 <clamchowder> cocreature: yeah I know:)
08:43:32 <clamchowder> cocreature: just to make sure: say I have /usr/lib/x86_64-linux-ghc-8.0.2/libHSlifted-base-0.2.3.11-797F0GSRM4GHiCBSQ3AJmQ-ghc8.0.2.so should I do LD_LIBRARY_PATH=/usr/lib/x86_64-linux-ghc-8.0.2 ?
08:44:09 <yushyin> cocreature: I for one prefer dynamic linking for repository binaries and circumvent the static problems with stack and sandboxes
08:44:25 <monochrom> Speaking of which, the output of "readelf --dynamic $HOME/.cabal/bin/pandoc" will be enlightening.
08:45:16 <monochrom> Because it shows what paths are stored in the exe. (And other stuff unrelated.)
08:45:26 <yushyin> rpath? yes
08:45:35 <monochrom> Yeah the rpaths.
08:45:53 <cocreature> clamchowder: yep
08:46:00 <monochrom> Normally one of the stored rpaths should already locate the old-time library but let's see.
08:47:01 <yushyin> but with a different name (hash at the end differs)
08:48:07 <clamchowder> cocreature: I did that, now pandoc is complaining about missing some library which I think is located in ~/.cabal ...
08:49:11 <clamchowder> I'm posting the error message, hold on.
08:51:17 <clamchowder> http://lpaste.net/528788131441278976
08:53:41 <cocreature> you can add multiple directories to ld_library_path but at this point monochrom’s suggestion is probably a better idea because there is clearly something wrong here
08:55:55 <clamchowder> I updated the pastebin with results of adding multiple directories to ld_library_path. OK let me try monochrom's suggestion.
09:00:09 <clamchowder> I have added output of readelf in the pastebin: http://lpaste.net/528788131441278976
09:02:27 <monochrom> /usr/lib/ghc-8.0.2/site-local/old-time-1.1.0.3  Do you still have this? What's inside? Need exact filenames for matching.
09:03:45 <clamchowder> monochrom: nope, no subdir called site-local in /usr/lib/ghc-8.0.2
09:04:14 <monochrom> Did you have it once upon a time? Installed something then uninstalled?
09:04:24 <clamchowder> I did a arch upgrade yesterday, which may have caused this saga
09:04:44 <monochrom> Because it means during build-time it was built against /usr/lib/ghc-8.0.2/site-local/old-time-1.1.0.3
09:04:46 <cocreature> did you rebuild pandoc after that?
09:05:31 <clamchowder> cocreature: I think so because I executed cabal install in the pandoc source dir today
09:05:44 <monochrom> Basically this humongous rpath is telling you what was the state of the libraries at build time. We usually hope that they are still present at run time.
09:05:46 <clamchowder> all the error messages I posted happened today
09:05:56 <cocreature> clamchowder: try a cabal clean first
09:06:17 <monochrom> Naw, "cabal install" already begins with "clean".
09:06:32 <monochrom> Actually no, begins with "configure".
09:06:32 <cocreature> monochrom: I don’t think it does that if you run it inside a project?
09:06:55 <monochrom> Even inside a project.
09:06:57 <cocreature> hm ok
09:07:02 <clamchowder> OK i did cabal clean. shall I cabal install now
09:07:06 <cocreature> yep
09:07:14 <monochrom> So if you do "cabal configure --xxx" and then "cabal install" your --xxx is lost.
09:08:41 <yushyin> I don’t see where this binary has a NEEDED entry in the dynamic section for old-time oO
09:08:52 <clamchowder> it's building... it normally takes up to 10 minutes to build pandoc on my system...
09:10:29 <yushyin> maybe we should also look at the dynamic section of the libHSpandoc-2.0-Rrs0Ccb25kJSnPvZBvUWY-ghc8.0.2.so?
09:14:35 <clamchowder> It failed again with similar error messages but I have to go now... Thanks very much for the help. I really appreciate it.
09:17:41 <clamchowder> I have updated the pastebin in case you are interested: http://lpaste.net/2368144344520589312
09:17:52 <clamchowder> byebye
09:24:20 <trampolin> hello, quick poll: how much can i blindly trust haskell's standard libraries to create, modify, and destroy files and folders? i'd like to use haskell for shell-like scripts as it seems way more maintainable than bash
09:25:34 <mud> trampolin: Not entirely sure what you're asking, if the APIs for dealing with files work?
09:26:33 <trampolin> yeah, if there's no single risk of, well, the functions not doing what they're supposed to. i don't want to risk my files on libraries i can't trust
09:26:57 <mud> I've never had any problem with them at all
09:27:38 <trampolin> mud: and you used them a lot for a long time? it's not rhetorical, i'm just checking
09:27:49 <Tuplanolla> I'd be wary since there are so many strange situations you can get into, such as moving hard-linked files across different file systems, trampolin.
09:28:16 <trampolin> Tuplanolla: yeah i have several hard links so i'll take care of it... unless haskell has no tool to manage them?
09:28:18 <mud> A decent amount over a longish time, sure.
09:29:27 <Tuplanolla> I'm not saying Haskell can't handle them, but usually the safest bet is to use the tools where someone else has already solved the tricky corner cases, trampolin.
09:30:10 <trampolin> mud: ok thanks
09:30:37 <trampolin> Tuplanolla: meaning? you recommend bash or something similarly more used for this sort of operations?
09:31:00 <mud> I should probably rephrase to I haven't had any more problems with them than I've had with any other file API. Files are weird things in practice, so many corner cases. But they do what you tell them to do in every case I've known.
09:31:26 <trampolin> i'm afraid it'll be harder to not make mistakes in bash and be sure it really does what i want. and i'd need to learn several stuff since i'm only dabbling in it for now
09:32:22 <trampolin> mud: overall then the only problem will be if i use them incorrectly, then, right?
09:32:51 <cocreature> trampolin: you might be interested in https://hackage.haskell.org/package/turtle
09:32:52 <Tuplanolla> Yes, trampolin. More users means more bugs are discovered.
09:33:58 <Tuplanolla> This has nothing to do with safe usability, however.
09:34:45 <trampolin> Tuplanolla: safe usability? i don't really get it then, why does it not have to do with it?
09:35:53 <trampolin> cocreature: thanks, i'll look into it! however, is it meant to make the job easier inherently, or is it mostly simpler only if you're very good at bash?
09:36:13 <Tuplanolla> Using popular tools is only safer as long as you never make mistakes yourself, trampolin.
09:36:41 <trampolin> Tuplanolla: i get it :) 
09:36:48 <cocreature> trampolin: the former, it doesn’t have a lot to do with bash. it just provides some nice utilities that you might want to use in shell scripting
09:36:57 <trampolin> is there any way to hide everything here besides actual messages?
09:37:12 <trampolin> cocreature: thanks!
09:37:19 <srhb> trampolin: Depends on the client software.
09:37:20 <cocreature> trampolin: the tutorial module is a nice intro https://hackage.haskell.org/package/turtle-1.3.6/docs/Turtle-Tutorial.html
09:37:28 <srhb> trampolin: Most IRC clients can hide joins and parts.
09:37:29 <happyMongoose> Hi there! I have this weird thing happening with a bit of code I wrote using template haskell - http://lpaste.net/356601
09:37:57 <trampolin> srhb:  i'm on the website, i don't use a client since i have not yet learned how to use it
09:38:42 <srhb> happyMongoose: Doesn't look like it has anything to do with template haskell.
09:38:55 <srhb> trampolin: I don't know which website you're on, but probably not then.
09:39:08 <trampolin> srhb: i meant "webchat.freenode.net"
09:39:59 <srhb> happyMongoose: `data Foo = id` would cause the same error, for the same reason.
09:40:11 <bbear> what are the advantage of Haskell ?
09:40:27 <srhb> bbear: A nice type system, for one.
09:40:34 <happyMongoose> huh
09:40:49 <happyMongoose> thanks srhb
09:40:56 <bbear> why is it so hard to write haskell ?
09:40:57 <happyMongoose> I'll fix that
09:41:02 <srhb> bbear: I don't think it is.
09:41:18 <happyMongoose> bbear, it's not hard. It's just a different way of thinking
09:41:54 <bbear> http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries <-- see that ; it look like an academic paper on CS mathematics.
09:41:55 <monochrom> I think I saw bbear asking the same questions before.
09:42:11 <bbear> see that : http://www.python-course.eu/python3_memoization.php <- it looks readable
09:42:30 <srhb> bbear: Why are you asking these questions? Are you starting to learn Haskell?
09:43:01 <bbear> Yes
09:43:28 <srhb> bbear: It's probably not a productive then. It will be much easier to understand why it looks like it looks and why it used to feel hard once you've learned some actual Haskell.
09:44:21 <monochrom> I know how to play this game too.
09:44:55 <monochrom> https://wiki.haskell.org/Dynamic_programming_example  <-- see that; it looks like a typical helpful wiki article.
09:45:52 <skiddieproof> Is there a way to add compiler options to a .hs file? Specifically can I call --hide-package in a {-# #-} statement?
09:46:11 <srhb> skiddieproof: I don't think so, use your cabal file instead.
09:46:20 <cocreature> skiddieproof: {-# OPTIONS_GHC opt #-}
09:46:28 <srhb> I stand corrected. :-)
09:46:37 <monochrom> https://docs.python.org/3/tutorial/introduction.html#first-steps-towards-programming  <-- see that; python is all about fibonacci.
09:46:56 <skiddieproof> Ide love to use the .cabal file, but cant figure out how. I need to hide all but a single module in a package to avoid name conflicts.
09:47:29 <bbear> I dunno ; I spent hours trying to solve a problem with Haskell 
09:47:51 <trampolin> it's weird, name conflicts arise even with qualified import? or do you mean module name conflicts?
09:48:57 <ADG> This program crashes/freezes my whole system even at -H32m : https://hastebin.com/raw/evotopiloy
09:49:07 <skiddieproof> "Ambiguous Interface for 'Data.blah'" type errors.
09:49:19 <monochrom> skiddieproof: In a *.cabal file, you list the packages you use, and what you don't list are hidden.
09:49:57 <cocreature> skiddieproof: you can use package imports to resolve the ambiguity https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#package-qualified-imports
09:50:00 <monochrom> cabal actually calls GHC with "-hide-all-packages" and then "OK now expose this one" for each in your list.
09:50:43 <skiddieproof> great link, thanks
09:55:47 <ADG> anyone have any ideas?
10:09:21 <ocharles> Does anyone know what causes a StableName to change?
10:09:36 <ocharles> I think you get different StableName's if it's a thunk or in weak head normal form, but is there any other reason?
10:09:54 <ocharles> If it's a record and field's are forced, will that change the record's StableName? That is, the record itself is already in WHNF
10:10:39 <monochrom> Wait, it changes?
10:11:36 <ocharles> I think so
10:11:54 <ocharles> "Note in particular that mkStableName may return a different StableName after an object is evaluated." from the documentation
10:12:10 <monochrom> Ah I see.
10:13:03 <monochrom> No, it only refers to a second call to mkStableName on "the same" thing.
10:13:38 <ocharles> Yea, that's what I mean though
10:14:02 <ocharles> Is there anything else I can do to a "thing" such that makeStableName gives different StableNames. e.g., `seq`
10:14:09 <monochrom> Alright, I don't know.
10:14:39 <ocharles> thanks for helping me get the right question out :)
10:15:25 <ClaudiusMaximus> ADG: -H<size> Sets the minimum heap size   maybe you want   -M<size> Sets the maximum heap size
10:17:38 <ADG> I wrote it in java and cpp, only java version working... cpp and haskell never return an answer: https://hastebin.com/raw/omeweceraz
10:18:49 <ClaudiusMaximus> ADG: a2 <- map (^2) [1..a1-1]  i think that a1 is larger than you expect here
10:19:38 <ADG> so that means... a1 is quite large... hence?
10:20:16 <cocreature> the c++ code seems to do something completely different from the java code
10:21:09 <ADG> I wrote the java code long ago... 
10:21:37 <ClaudiusMaximus> let y = (a2 - a1) `div` 2  -- the order here is swapped from what i'd expect, too
10:22:05 <ADG> oh I see
10:25:28 <haskellPatriot> ADG: oh say can you see
10:25:37 <haskellPatriot> how the order was swapped
10:25:49 <ADG> yes
10:26:14 <haskellPatriot> what was proudly written in java
10:26:20 <haskellPatriot> and then converted to haskell.
10:27:01 <glguy> clamchowder: those two directories were for different versions of ghc
10:27:34 <Welkin> proudly?
10:27:57 <ADG> still not luck
10:28:02 <haskellPatriot> it's a bit of a joke
10:28:03 <ADG> *no
10:28:54 <haskellPatriot> Welkin: fitting his dilemma into "Oh say can you see"
10:29:05 <ADG> that java one runs in 200ms (limit=1000) but the hs version for limit=400 runs forever
10:35:23 <ADG> Got it, the problem was with not caching squares
10:36:51 <rntz> hey, is there a channel I should go to if I need help with stack?
10:37:06 <cocreature> rntz: there is #haskell-stack
10:37:14 <cocreature> but you can also try asking here
10:37:25 <rntz> ok, I will ask here then
10:38:55 <rntz> I have stack 0.1.10.0, installed on ubuntu via apt-get; I just tried making a new project via `stack new myproject` and ran `stack setup`, which seemed to complete successfully after installing a version of GHC. however, when I run `stack ghci` or `stack build`, I get an error:
10:39:05 <rntz> 'Invalid package ID: "array-0.5.1.1 base-4.9.1.0 binary-0.8.3.0 bytestring-0.10.8.1"'
10:39:16 <mud> rntz: That version is tragically out of date.
10:39:39 <cocreature> "stack upgrade" will give you the newest version
10:39:53 <rntz> ah, ok. I will try that.
10:40:21 <MarcelineVQ> note that you need to add ~/.local/bin to your path if you use stack upgrade since that's where it'll put the new executable
10:40:35 <rntz> ah, thanks
10:41:58 <se-11-fish> hey, is it just me or is this implementation of reader mostly wrong: http://gettingsharper.de/2015/03/10/dependency-injection-a-functional-way/ (this is in F#)?
10:44:15 <Welkin> se-11-fish: I have seen the most horrific mistakes in so-called "functional programming" tutorials in non-fp languages that, for example, try to implement currying, but end up writing `compose`, or some other nonsense
10:45:51 <se-11-fish> Welkin, I am a newb so really not sure if this link is ok or not but something doesn't fit 
10:46:21 <Welkin> I am not familiar with F# so I cannot comment
10:47:02 <monochrom> Reader is a case where you're so much better off just using vanilla parameter passing than develop a full-blown Reader monad. Especially outside Haskell.
10:47:20 <Welkin> Nor am I familiar with "dependency injection", but as far as I am aware, it is just passing a callback to another function
10:47:42 <se-11-fish> f.e shouldn't types in this signature be different: let lift2 (f : 'd -> 'a -> 'b -> 'out) : 'a -> 'b -> ReaderM<'d, 'out> =
10:47:42 <se-11-fish>  fun a b dep -> f dep a b
10:47:49 <mud> As far as I remember it was the world's most overblown term for accepting a function as an argument.
10:48:36 <se-11-fish> I think lift2 should be equivalent to f <!> x <*> y and this args are not monadic 
10:56:09 <rntz> <!>?
10:56:15 <rntz> do you mean <$>?
10:56:27 <se-11-fish> sorry in haskell that will be <$> yes
10:56:31 <se-11-fish> map
10:56:42 <rntz> oh, right, convo is about F#
10:56:43 <davr0s> the approaches to gl/windowing bindings seem to end up with global variables, 
10:56:44 * rntz missing context
10:56:49 <se-11-fish> fun is just a lambda
10:56:57 <davr0s> is there a way of doing something like mutable locals
10:57:22 <se-11-fish> I figured ml syntax is close enough for you folks :)
10:57:31 <c_wraith> I don't like F#'s "we use conventions instead of interfaces" story.  Sure, you get things to magically work sometimes, but you lose the ability to abstract over implementations of the interface.
10:57:34 <davr0s> at the minute what i have in mind is some sort of global app state 
11:12:55 <se-11-fish> in this lift2 first parameter is: (f : 'd -> 'a -> 'b -> 'out). And 'd here stands for dependency (environment in the reader monad)  
11:13:23 <se-11-fish> in normal implementation of lift2 you do not assume that the function which you are lifting is acting on the environment, right?
11:14:11 <c_wraith> If I understand you correctly..  In haskell the type system prevents it.
11:15:44 * hackagebot ginger 0.5.3.0 – An implementation of the Jinja2 template language in Haskell – https://hackage.haskell.org/package/ginger
11:16:34 <jcjf> I would have been tempted to call it Hinha
11:21:26 <srhb> jcjf: It's so much easier to name open source projects now you can just choose bad punny names of other projects. :-P
11:22:16 <jcjf> Yes, it's beautiful to be able to take inspiration from prior art
11:34:22 <Tuplanolla> Naming is easy. You just take a thematic word and replace one of its syllables with another one that starts with an h.
11:34:50 <Tuplanolla> The same works for Python, but you have to use p instead of h.
11:35:12 <Tuplanolla> For Java it's just j in place of h.
11:35:29 <ertes> i had the pleasure to work with jinja2 in the last few weeks (ansible), and with that experience in mind: why would anyone want to use jinja2 in haskell?
11:41:25 <sepakorayl> MaybeT's applicative instance: https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.Maybe.html#line-130
11:41:55 <sepakorayl> Would it be a valid applcative if we always pattern matched on the second argument when the first is Nothing?
11:42:52 <sepakorayl> basicaly make it run all computations instead of skipping on first failure
11:43:19 <Gurkenglas> sepakorayl, you want Compose m Maybe instead of MaybeT m
11:45:05 * hackagebot hledger-irr 0.1.1.11 – computes the internal rate of return of an investment – https://hackage.haskell.org/package/hledger-irr
11:45:05 * hackagebot gen-passwd 1.0.0.0 – Create wordlist-based passwords easily – https://hackage.haskell.org/package/gen-passwd
11:45:47 <sepakorayl> I will look into it, it solves my problems but it seemed hacky to introduce a new operator for that
11:45:57 <sepakorayl> I wasn't even aware of Compose
11:47:05 <Gurkenglas> If the usecase is simple there may be another way to write it, can I look at the code?
11:54:51 <trigone> hi, any idea how i could write the following without reinventing the wheel: f (ma, mb) = ma >> mb
11:55:16 <trigone> i know you can write it as f = uncurry (>>) but i'd be more satisfied with a way to use sequence?
11:55:17 <ReinH> :t uncurry (>>)
11:55:19 <lambdabot> Monad m => (m a, m b) -> m b
11:55:40 <ReinH> why?
11:55:46 <ReinH> There's no obvious way to use sequence
11:55:50 <geekosaur> tuples can't be iterated
11:55:57 <trigone> well that's a shame...
11:56:00 <geekosaur> (directly)
11:56:15 <trigone> geekosaur: you mean unless i build a list out of the tuple?
11:56:34 <geekosaur> or do various generics/lens tricks, yeh
11:56:36 <Tuplanolla> Do we have `instance Monad m => Monoid (m ())` yet?
11:56:53 <trigone> ReinH: the "why" is just a question to find a more general function instead of a special case that only works for tuples.
11:57:26 <ReinH> A tuple is a special case.
11:59:49 <geekosaur> a tuple is an anonymous ADT in the same sense that a lambda is an anonymous function. would you expect to be able to sequence data Foo a = Foo a a a a ?
12:00:33 <ReinH> (,) :: * -> * -> *
12:00:45 <ReinH> It isn't the right shape for any of those generic functions.
12:01:50 <cocreature> geekosaur: well you can actually sequence that since you can make it an instance of Traversable :)
12:02:51 * hackagebot file-templates 1.0.0.0 – Use templates for files and directories – https://hackage.haskell.org/package/file-templates
12:03:36 <trigone> cocreature: actually the tuple instance for traversable only maps over the right parameter (or something). i believe that since traversable is related to the notion of functor, i'd need the equivalent of traversable for bifunctors...
12:04:07 <cocreature> trigone: I know, I was talking about the instance of the Foo type geekosaur mentioned
12:05:17 <trigone> cocreature: oh right ^^
12:05:26 <cocreature> trigone: the equivalent of Traversable for Bifunctors is called Bitraversable
12:05:32 <cocreature> it’s in the bifunctors package
12:05:49 <cocreature> so that’s slightly more general than uncurry but it won’t work for 3-tuples
12:06:25 <trigone> cocreature: yeah, there aren't that many bifunctors around either
12:06:27 <Tuplanolla> > view each ("42", "13", "20")
12:06:28 <lambdabot>  "421320"
12:06:49 <Tuplanolla> This works if we already have the instance I mentioned.
12:07:11 <trigone> > each
12:07:13 <lambdabot>  error:
12:07:13 <lambdabot>      • No instance for (Typeable f0)
12:07:14 <lambdabot>          arising from a use of ‘show_M72293325075337920842225’
12:07:37 <trigone> how do you ask the type of something to lambdabot?
12:07:41 <cocreature> :t each
12:07:42 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
12:08:31 <cocreature> > (Just 1, Just 2, Just 3) & each %%~ id
12:08:33 <lambdabot>  Just (1,2,3)
12:09:20 <ertes> :t sequenceOf both
12:09:21 <trigone> well i don't get much of that function
12:09:22 <lambdabot> (Monad m, Data.Bitraversable.Bitraversable r) => r (m b) (m b) -> m (r b b)
12:09:33 <geekosaur> trigone, it's from lens, which I mentioned earlier
12:09:40 <cocreature> ah I couldn’t remember the name of sequenceOf
12:09:42 <geekosaur> you can think of lens as a generics library
12:09:52 <trigone> geekosaur: ah, well i'm not knowledgeable yet in them
12:10:02 <ertes> :t sequenceOf_ both  -- or rather that
12:10:04 <lambdabot> (Data.Bitraversable.Bitraversable r, Monad m) => r (m a) (m a) -> m ()
12:11:04 * hackagebot file-templates 1.1.0.0, gen-passwd 1.1.0.0, shine 0.2.0.2
12:11:04 * hackagebot  → https://hackage.haskell.org/packages/recent
12:12:21 <trigone> i think the main issue is that traversable needs all types to be identical, so the structure can be fully abstracted. but in the case of trying to use uncurry (>>), it is clear that the only thing that matters is for both items in the tuple to be wrapped in the same monad. is there no way to put that in a class that would allow basically to see values wrapped with the same functor/monad as if they were the same type?
12:13:21 <trigone> provided we only use whatever equivalent to traversable onto functions polymorphic at the level of the values wrapped in the monad? (i doubt i'm clear, am i?)
12:13:23 <ertes> trigone: this is about (>>), which is really just a monoid
12:13:51 <ertes> just store (M ()) everywhere, there is no need for your combinator to support polymorphic actions
12:14:44 <trigone> ertes: i'll admit i'm lost, but then i don't even know what i'm seeking, although it seems more probable it's impossible
12:15:32 <Tuplanolla> It's most likely not impossible, but requires some impressive contortions, trigone.
12:16:24 <ertes> trigone: try to explain the problem, not the solution
12:16:43 <trigone> ertes: actually, i have no current problem, this is merely for the sake of curiosity, sorry!
12:16:49 <cocreature> you could use something like vinyl’s Rec and implement sequence for that but it’s most likely not worth the trouble
12:21:11 <trigone> > :t bisequence
12:21:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:21:18 <trigone> :t bisequence
12:21:19 <lambdabot> error:
12:21:19 <lambdabot>     • Variable not in scope: bisequence
12:21:19 <lambdabot>     • Perhaps you meant one of these:
12:22:59 <trigone> bah i'll leave this for later, when i know more about haskell. thanks for the discussion anyway!
12:39:23 <Gurkenglas> I remember there was a library someone wrote that does something like wrapping each field of a record in the same f so you can do what trigone wanted
12:41:50 <Gurkenglas> SELECT reddit_post WHERE age <= 1 year, announces_package SORTBY popularity
12:45:54 <se-11-fish> say you have some context value that you are currently passing into many functions (tier A functions)
12:46:00 <se-11-fish> then there are functions (tier B functions) that do not need context by themselves but call tier A functions so the context needs to be passed to them too
12:46:06 <se-11-fish> would it be fair to say that the reader monad is mostly useful in the situation when there are a lot of tier B functions?
12:46:13 <se-11-fish> or in other words, reader monad does not bring much benefit for working with tier A functions themselves?
12:47:36 <mud> I think the only place I've ever actually used Reader was as ReaderT.
12:47:57 <mud> I've used ((->) r) for stupid applicative/monad tricks, but I'm not sure that counts.
12:51:10 <ertes> forever (query_ "UPDATE reddit_post SET age = age + 1;" >> threadDelay 1000000)
13:03:15 <Gurkenglas> Or age is a macro for current_time-timestamp
13:20:38 <ReinH> I’ve never used Reader. I use ((->) r) frequently, especially the Applicative instance.
13:39:07 <lamefun> Can I replace documentation of a type my module re-exports from another?
13:39:16 <lamefun> Without wrapping it I mean.
13:46:26 * hackagebot threepenny-editors 0.2.0.14 – Composable algebraic editors – https://hackage.haskell.org/package/threepenny-editors
13:53:31 * hackagebot fileplow 0.1.0.0 – Library to process and search large files or a collection of files – https://hackage.haskell.org/package/fileplow
13:54:18 <lyxia> lamefun: nope
14:00:05 <athan_> I am disappointed systemd's module namespace isn't `System.D` :(
14:01:04 <athan_> joking aside, does anyone know of a systemd config file parser / printer / data-oriented representation?
14:05:38 <felixgb> \clear
14:06:38 <felixgb> yo yo, what's the good library for making http requests? specifically one that can follow redirects
14:07:05 <TristanBKildaire> Yoyo, is haskell worth learning?
14:07:27 <felixgb> yeah it's cool and good
14:08:58 <TristanBKildaire> Is it fin and different too?
14:09:11 <TristanBKildaire> How far does immutability go?
14:09:17 <TristanBKildaire> * fin = fun
14:10:39 <athan_> felixgb: http-client should do it
14:10:40 <srhb> TristanBKildaire: Yes, to what and what do you mean how far?
14:10:50 <athan_> you'll need http-client-tls for https stuff
14:10:57 <felixgb> yeah it's fun and different, programming in haskell is kinda like playing with lego
14:11:10 <felixgb> sweet, thanks, looking at that now
14:11:19 <athan_> TristanBKildaire: It's the highway to the holy grail :)
14:11:31 <TristanBKildaire> Well would I be able to say now move items around in a list
14:11:41 <TristanBKildaire> And change the elements at a given index
14:11:43 <athan_> TristanBKildaire: You create a new list
14:11:52 <TristanBKildaire> Oh that's a good point
14:11:58 <athan_> everything is a matter of creating value, or witnessing it
14:11:59 <TristanBKildaire> Why did I not think of that
14:12:30 <TristanBKildaire> Ah. Thanks. Now I will definately put Haskell on my todo list. I can't believe I didn't think of that.
14:12:37 <athan_> where "value" is really cool too :)
14:12:41 <TristanBKildaire> And for scalars like integers.
14:12:55 <athan_> It's like training wheels, except they're actually rockets
14:13:21 <TristanBKildaire> Wow
14:13:29 <athan_> yeah like vector spaces are generalized as an abstract generic library iirc
14:13:30 <c_wraith> TristanBKildaire: Haskell is the programming language that annoys me least, of ones I've used.  Not to say it doesn't have its own issues, but at least they're smaller issues. :)
14:13:52 <c_wraith> TristanBKildaire: I highly recommend learning it.  There's a lot of good stuff, whether you end up using the language or not.
14:13:53 <athan_> s.t. anything that satisfies those algebraic laws can be considered "a vector/scalar" :)
14:14:14 <TristanBKildaire> Is it natively compiled? Or not?
14:14:31 <athan_> TristanBKildaire: It is, there's a cool compilation path that the primary compiler takes
14:14:32 <c_wraith> depends on the compiler, but usually
14:14:45 <mud> It's typically compiled, yes. There is a good REPL though and interpreted options.
14:14:47 <c_wraith> I mean, we've got multiple compilers that go to javascript,t oo. :)
14:15:02 <TristanBKildaire> oh okay. That's good to hear. Thanks for the info then.
14:15:04 <athan_> c_wraith: multiple? What's the ghcjs competitor?
14:15:08 <c_wraith> athan_: haste
14:15:19 <athan_> I just saw simplexhc
14:15:21 <athan_> ahh derp
14:16:00 <c_wraith> I prefer ghcjs for the feature set, but I don't develop software intended for mobile sites.  haste's smaller output size has its value
14:16:04 <TristanBKildaire> Also the community seems cool already :)
14:16:42 <athan_> TristanBKildaire: That's the only thing in haskell where its value is difficult to measure :)
14:16:56 * athan_ thank you everyone ;-;
14:17:32 <c_wraith> TristanBKildaire: by the way, if it seems intimidating at the start..  that doesn't mean anything is going wrong.  I had more trouble learning Haskell than anything in 30 years.  I'd become too used to all languages being basically the same. :)
14:17:36 <Athas> I hate Haskell less than I hate other languages.
14:17:41 <c_wraith> Athas: me too!
14:19:22 <TristanBKildaire> Thanks for the info. I will try to learn it.
14:22:01 <felixgb> So i'm looking at http-client and it looks like there's no way to get a response as Text. there's httpLBS, is is 'ok' to use byte strings for text? i though that's what Text was for
14:23:00 <c_wraith> felixgb: You should really just convert the bytestring to Text.  http-client is low-level, and acknowledges that the things actually sent over the wire are bytes.
14:23:21 <felixgb> sweet, thanks
14:36:44 <fragamus> howdy hi what is the best way to parse JSON in these parts
14:36:46 <lamefun> How slow are MVars used by just 1 thread compared to IORefs?
14:37:29 <mud> fragamus: aeson is popular
14:37:35 <geekosaur> um? isn't an MVar used by just 1 thread a guaranteed deadlock?
14:38:58 <lyxia> Putting something in an empty MVar is nonblocking.
14:43:30 <lamefun> So a thread can't even read an MVar it just created?
14:43:43 <c_wraith> not if it's empty.
14:43:57 <c_wraith> But a single thread can easily use an MVar, so long as it alternates get and put
14:44:30 <lamefun> I know, but how slow is it compared to IORefs? I'm OK as long as it isn't obscenely slow.
14:44:40 <mud> That doesn't sound like a terribly useful pattern though, or am I missing something?
14:44:50 <c_wraith> It's not useful within a single thread
14:45:03 <c_wraith> It can be useful when a bunch of threads are doing it. :)
14:45:21 <c_wraith> lamefun: someone just did a bunch of benchmarks on this...  merijn, I think
14:45:41 <c_wraith> though he focused on concurrent use
14:45:57 <lamefun> I know it's not useful, but it's for sure it's PEOPLEONEtruthly.
14:46:27 <c_wraith> why not use an IORef?
14:46:44 <c_wraith> heck, why not use State?
14:46:56 <c_wraith> If it's single-threaded, State works just as well
14:49:31 <lamefun> I know all that. But if I understood the docs correctly, even atomically modified IORefs can be re-ordered by the CPU if more than one is used.
14:50:08 <c_wraith> yes, atomicModifyIORef only applies to a single Ref
14:50:16 <c_wraith> If you care about multiples, maybe you want STM?
14:55:23 <lamefun> Can I implement IORefs and MVars in terms of STM and then use only that without having it dog-slow?
14:58:15 <lyxia> That seems easy enough to benchmark...
15:09:32 <lyxia> http://lpaste.net/356610 lamefun 
15:11:08 <monochrom> Wait, shouldn't you use TVar instead of TMVar?
15:14:39 <lyxia> I actually have no idea what lamefun is looking for but they asked about MVar
15:21:46 <lamefun> Just want to know if implemeting all vars with MVars or STM would make stuff worse than Python.
15:22:34 <lamefun> Thanks for letting me know about the benchmark library, seems great.
15:23:04 <EvanR> hard to say since python has the overhead of reference counting and dynamic type checking
15:23:29 <EvanR> MVars and STM and IORefs have the overhead of extra gc bookkeeping
15:23:52 <EvanR> and in the case of STM, STM
15:26:36 <lamefun> I want to see how an anti-intellectual version of the base library would look like.
15:26:59 <lamefun> Because: thinking sucks, learning sucks, abstraction sucks.
15:27:28 <lamefun> This would mean no platform differences, no UB and safest primitives.
15:28:52 <geekosaur> you may have come to the wrong language
15:29:14 <EvanR> corporate language not to be named is that way
15:29:44 <Rembane> Maybe BF is a better fit.
15:29:59 <EvanR> esolangs require more thinking than anything!
15:30:18 <Rembane> But they are not always intellectual.
15:30:28 <Rembane> Especially if they belong to the BF school of thought.
15:30:51 <EvanR> the answer must be, that haskell requires thinking of a different sort in a different location
15:30:54 <Tuplanolla> I don't think finding out how hard you need to abuse Haskell for it to become worse than Python is a bad project.
15:31:00 <Tuplanolla> I've seen worse anyway.
15:31:26 <Tuplanolla> It's at least funny.
15:31:49 <Rembane> I've heard that you can have dynamic typing in Haskell in a quite nice way.
15:32:17 <EvanR> dynamic typing in haskell? sounds like a lot of thinking required
15:33:53 <bryce_macinnis> ls
15:33:55 <systemfault> Is dynamic typing that Typeable thing? (I don't know anything about it)
15:33:59 <systemfault> bryce_macinnis: Wrong terminal
15:34:07 <bryce_macinnis> Sorry, forgot where I was at ; )
15:35:03 <hpc> Typeable is more like undoing type erasure
15:35:14 <colonelj> anyone got any tips for figuring out how to eradicate space leaks tonight?
15:35:18 <hpc> for dynamic typing, see Dynamic
15:35:23 <lamefun> Why have I come to wrong language? Why do people even equate Haskell/functional programming with intellectualism?
15:35:28 <Tuplanolla> The usual, colonelj.
15:35:45 <systemfault> lamefun: Who does that?
15:35:57 <bryce_macinnis> I'm curious too lamefun.
15:35:59 <colonelj> Tuplanolla: I've tried adding a lot of strictness with evaluate $ force and $!!
15:36:09 <bryce_macinnis> I've read a lot on functional programming and Haskell and I'm very interested
15:36:10 <colonelj> didn't seem to make any difference
15:36:14 <systemfault> People learn Haskell because it's great.
15:36:32 <systemfault> Or are simply curious
15:36:34 <bryce_macinnis> But I don't see it being used a lot professionally so I'm wondering where this huge community comes from
15:36:56 <EvanR> people who like programming as opposed to people who are forced to program due to wage slavery
15:36:57 <systemfault> bryce_macinnis: Freenode is a bit of a reality distortion field..
15:37:23 <colonelj> I'm working on haskell professionally now :P
15:37:46 <colonelj> and I went to the London Haskell meetup on Wednesday
15:37:52 <systemfault> colonelj: Congratulations :)
15:38:03 <bryce_macinnis> I mean I love programming because I love making things
15:38:19 <bryce_macinnis> It's just confusing when I can't find anything but the language itself written in Haskell
15:38:27 <systemfault> Living the American^wFP dream!
15:38:30 <Rembane> bryce_macinnis: Pandoc!
15:38:41 <colonelj> I'm in the UK though
15:38:42 <bryce_macinnis> I'm trying to find the language that's the best at writing things fast and I love how terse this language is
15:38:42 <EvanR> the bot in ##c++
15:39:11 <systemfault> geordi is awesome
15:39:30 <colonelj> I don't think being able to write short code makes it faster except in that it's less typing
15:39:45 <colonelj> but you spend 10x as long trying to figure out what to write :P
15:39:46 <EvanR> theres debate on how much that matters
15:40:13 <bryce_macinnis> I'm just trying to figure out where Haskell solves the problem
15:40:15 <EvanR> because you could be typing (mostly backspacing) the whole time youre figuring out the solution
15:40:37 <Tuplanolla> How much template metavomit would `lens` require if it was written in C++?
15:40:40 <bryce_macinnis> I'm really interested in how Haskell differs from imperative languages
15:40:50 <bryce_macinnis> But really is this like the calligraphy of programming?
15:41:03 <wespiser> bryce_macinnis: no, there are a lot of very practical projects in Haskell
15:41:15 <EvanR> are you theorizing that writing in other languages is like bad handwriting?
15:41:18 <wespiser> look at Scotty, or Servant especially for web programming, ie, writing servers
15:41:38 <bryce_macinnis> Some code can definitely be bad handwriting lol
15:41:46 <EvanR> whatever you learn form haskell you can take with you back to language X
15:41:58 <EvanR> it really helps, ime
15:42:04 <wespiser> Haskell is extrememly good at prog lang development, which is at least what I'm largely interested in
15:42:13 <bryce_macinnis> I think I'm going to learn this more in depth just so I know what I'm talking about.
15:42:15 <systemfault> Example... Learning Haskell magically makes you a C++ template metaprogramming god.
15:42:30 <bryce_macinnis> Yeah I see that functional programming is being used more and more in languages
15:42:42 <wespiser> the other major point to Haskell that I find really cool, is the type system, which gives amazing safety without having to rely on a bajillion tests
15:42:55 <wespiser> yea, but this isn't just functional programming, its fp + types
15:43:06 <felixgb> i think learning haskell made me a much better javascript programmer
15:43:24 <wespiser> yea, javascript can't get enough fp influence right now, it seems
15:43:36 <EvanR> there are a lot of features in haskell that sometimes get umbrellad by "FP"
15:43:42 <felixgb> it becomes much nicer that way
15:43:43 <systemfault> The language (JS) is so sloppy... it helps a lot
15:43:45 <lamefun> What does it mean "calligraphy of programming"?
15:43:57 <Tuplanolla> It's surprising how many Haskell techniques you can even use in C.
15:44:06 <bryce_macinnis> Writing really nice code that efficiently solves a problem is the calligraphy problem
15:44:21 <bryce_macinnis> But most programming is getting the solution and a product out asap in my mind.
15:44:24 <EvanR> yes my C has improved about 1000 fold after learning haskell
15:44:41 <colonelj> really?
15:44:44 <colonelj> C is so simple
15:44:44 <wespiser> lol, my R got way better
15:45:06 <colonelj> I don't get how haskell can help you write your C macros
15:45:11 <bryce_macinnis> I've done a fair amount of programming in C++ and Java
15:45:28 <EvanR> whther its simple, and whatever that would mean, getting it to do what you want it to do seems to be alot easier now
15:45:30 <bryce_macinnis> I've always found it kind of messy and how spaghetti it can get with references
15:45:31 <EvanR> and to be sure its right
15:45:39 <bryce_macinnis> It seems like Haskell has that clarity figured out.
15:45:45 <bryce_macinnis> That's why I'm so interested
15:46:00 <felixgb> scala in the streets, haskell in the sheets
15:46:04 <EvanR> writing a bunch of code is easy, look at the PHP universe. knowing its right and at least not wrong, hard
15:46:34 <wespiser> bryce_macinnis: this is a scheme evaluator in Haskell:  https://github.com/write-you-a-scheme-v2/scheme/blob/master/src/Eval.hs#L132
15:46:38 <bryce_macinnis> I'm interested in Scala because of the use of packages but I'm afraid that I'm just going to try to use Scala like Java instead of it's own thing.
15:46:45 <bryce_macinnis> Would I be best starting off with Haskell?
15:46:46 <wespiser> IMO its super clear
15:46:47 <Tuplanolla> I recently realized how to do loop fusion to elide temporaries in C. That wouldn't have happened without some Haskell influences.
15:47:00 <wespiser> bryce_macinnis: learn you a haskell, for great good
15:47:26 <felixgb> idk, the later chapters of LYAH lost be a bit
15:47:43 <felixgb> i just didn't understand *why* you would want that stuff
15:47:44 <lamefun> Is STM even commonly used?
15:47:47 <bryce_macinnis> thanks guys, I'm going to try to dig my way into this and maybe take down some euler problems after.
15:48:55 <systemfault> felixgb: Had the exact same problem...
15:48:58 <colonelj> I don't even think euler porblems help with programming much
15:49:02 <wespiser> bryce_macinnis: yea, that's how I started, with project euler. Haskell is a little daunting. 
15:49:31 <felixgb> i think making and writing little projects helps
15:49:54 <EvanR> some people use haskell instead of shell scripting
15:50:14 <colonelj> python is better suited for that
15:50:23 <bryce_macinnis> I'm interested in making things the average person uses everyday. I see merit in Haskell at least learning what it represents
15:50:23 <felixgb> i use it for certain scripting tasks but I don't know sh very well
15:50:33 <felixgb> i agree python is better suited
15:50:35 <systemfault> No matter what people say about it... 2 things helped me learn Haskell, 1) The Haskellbook 2) Typeclassopedia
15:50:40 <EvanR> <my favorite language> is better suited to that
15:50:50 <bryce_macinnis> why is python better suited?
15:51:08 <EvanR> but im just saying haskell is interesting in that people use it for these kinds of projects, and youd think it wouldnt be a good idea
15:51:11 <wespiser> well, <feature Y> in <my favorite language> makes it better
15:51:16 <felixgb> mostly there's a library that does exactly what you want
15:51:16 <dolio> Python doesn't seem like it'd be a ton better than Haskell.
15:51:17 <lamefun> Are Python and other dynamic languages even for humans? I think they came from space.
15:51:20 <lamefun> https://www.youtube.com/watch?v=REy0k1Bdv-g
15:51:32 <wespiser> EvanR: yea, I agree, its a good comment to make
15:51:37 <dolio> Compared to shell scripting languages that are actually built for it.
15:52:24 <wespiser> https://hackage.haskell.org/package/turtle
15:55:06 <jmcarthur> lamefun: Yes.
15:55:23 <lamefun> Yes for humans or yes came from space?
15:55:26 <jmcarthur> lamefun: (In response to your question about STM.)
15:55:38 <jmcarthur> Sorry, I hadn't realized you asked more questions since then.
15:59:00 <wespiser> https://hackage.haskell.org/package/turtle
16:03:12 <pvdk> Hi
16:04:56 <lyxia> pvdk: hello
16:06:11 <pvdk> What's this haskell all about 
16:06:35 <pvdk> Is it worth the effort 
16:06:41 <pvdk> Will it get me laid
16:08:21 <bryce_macinnis> Is it possible to have something happen in Haskell 5 seconds from now?
16:08:48 <EvanR> threadDelay 5000000 will wake up in 5 seconds or more
16:08:49 <srhb> bryce_macinnis: Look at threadDelay
16:09:01 <bryce_macinnis> thank you
16:09:39 <EvanR> -threaded runtime makes the wakeup more accurate
16:09:54 <srhb> EvanR: Really, how come?
16:10:14 <srhb> I've always slept for shorter durations and measured the next sleep if I needed something semi-accurate.
16:10:17 <EvanR> why does non-threaded even exist
16:10:33 <EvanR> because by switching context less you can hypothetically get more throughput
16:10:40 <srhb> Hm.
16:12:47 <EvanR> how you use threadDelay and if its correct for that purpose is another story. but you should only rely on "wakes up in >= 5 seconds", and probably == is a stretch
16:26:42 <bluebaron> Why is it that `let mymap = fmap traceShowId $ Map.fromList $ zip [1..5] [6..10]; lookup 3 mymap; lookup 3 mymap' will print an extra 3 both times it's looked up in a REPL?
16:29:42 <unknownln> bluebaron: It prints 8 for me, and only prints it once
16:29:48 <unknownln> I'm using the REPL
16:30:15 <unknownln> well specifically it prints `Just 8` followed by `8`. the Just 8 being the return value of Map.lookup, and the 8 coming from traceShowId
16:31:18 <bluebaron> unknownln: Oh hm. Are you using containers-0.5.10.2? I believe that's what I'm using
16:31:52 <bluebaron> I'm also using interactive-haskell mode within emacs but I'd be surprised if that's the problem
16:32:06 <unknownln> 0.5.7.1 I believe; I'm using packages from the current stackage LTS
16:32:42 <bluebaron> unknownln: Let me look at the command to inspect my current version of the libraries in a project, I might not be using that version I just spouted off
16:33:45 <bluebaron> Nope I'm on 0.5.7.1 as well, hm
16:35:09 <unknownln> bluebaron: and just to be safe, here's a direct paste of the output
16:35:11 <unknownln> http://lpaste.net/356611
16:35:46 <bluebaron> Oh sorry, that's what I meant to ask about, why it's printing the extra 8 in both invocations
16:37:01 <unknownln> I think GHCI is substituting the full definition in both times maybe?
16:37:04 <unknownln> I did an experiment:
16:37:08 <mauke> :t mymap
16:37:10 <lambdabot> error: Variable not in scope: mymap
16:37:21 <unknownln> `>>> (\m -> (Map.lookup 3 m, Map.lookup 3 m)) mymap`
16:37:28 <unknownln> and this only prints it once
16:37:37 <bluebaron> Oh cool! I'll try that
16:38:19 <srhb> bluebaron: Try specializing to Map Int Int
16:38:35 <bluebaron> I'm fairly new to haskell though, so just to confirm, my intuition that a function mapped over the values in a map should only be evaluated once is sound, right? I'm just trying to use some very basic memoization
16:38:42 <srhb> Correct.
16:38:50 <bluebaron> Oh awesome, that's a relife
16:38:51 <bluebaron> relief
16:38:52 <unknownln> bluebaron: srhb's solution works here
16:39:00 <unknownln> just tested that
16:39:07 <lamefun> Are there any glaring flaws in this benchmark? http://lpaste.net/356610
16:40:08 <unknownln> bluebaron: by default, your mymap definition has this type: `(Enum b, Enum k, Num b, Num k, Ord k, Show b) => Map.Map k b` so since the types aren't fully known, it has to re-evaluate it each time you use it is my guess.
16:40:11 <lamefun> So TVar doesn't seem too much slower than IORef, and even TMVar is not horrible.
16:40:32 <bluebaron> unknownln: Oh that totally makes sense
16:40:35 <bluebaron> thank you for the help, srhb unknownln!
16:40:40 <srhb> unknownln, bluebaron: Think of every constraint types as waiting for a dictionary argument with the definition
16:40:54 <srhb> (of that instance)
16:41:26 <bluebaron> srhb: sure thing, good tip
16:46:11 <EvanR> lamefun: the differences start to appear under heavy contention
16:47:48 <unknownln> lamefun: you may also be interested in this post and thread https://www.reddit.com/r/haskell/comments/6irosh/the_haskell_concurrency_primitive_shootout/
16:52:40 * hackagebot shakers 0.0.25 – Shake helpers. – https://hackage.haskell.org/package/shakers
16:59:46 * hackagebot preamble 0.0.41 – Yet another prelude. – https://hackage.haskell.org/package/preamble
17:00:27 <EvanR> unknownln: funny that strict IORef is slightly slower
17:01:38 <wespiser> EvanR: yea, "just in: new evidence supports IORef!"
17:02:11 <EvanR> another thing about this benchmark, they went up to 8 threads of contention
17:02:38 <EvanR> if you look at TVar vs MVar with much more contention, you might see MVar win
17:07:53 * hackagebot preamble 0.0.42 – Yet another prelude. – https://hackage.haskell.org/package/preamble
17:29:31 <davr0s> could anyone comment on the feasibilty of compiling a subset of haskell with borrowing,move-semantics, and eager-eval
17:30:04 <davr0s> (e.g. for reference see 'lively linear lisp')
17:30:11 <c_wraith> You're better off starting from a language like disciple if you're going for that
17:30:36 <davr0s> let me google..
17:31:17 <davr0s> can't find anything
17:31:34 <c_wraith> It's http://disciple.ouroborus.net/
17:31:59 <c_wraith> looks abandoned, though.
17:32:59 * hackagebot unicode-transforms 0.3.1 – Unicode normalization – https://hackage.haskell.org/package/unicode-transforms
17:33:24 <davr0s> k a
17:33:33 <Tuplanolla> It seems to have a garbage collector instead of borrow-and-move semantics.
17:33:53 <davr0s> ok thats the important bit for a 'one true language'
18:07:13 <Lokathor> i seem to recall that Ptr is a little faster than IORef, but i can't recall where I saw that
18:11:19 <tempeh> I'm frustrated with the way that type classes work with type parameters. For example, is it true that in order to write a traversable instance, the type being traversed need to be in the last position? I feel like I'm losing valid instances because of this. I'm trying to write something like: instance (Functor f, Has (f a) b) => Traversable (Fix f), but there doesn't seem to be a way
18:12:01 <tempeh> (where that traversable instance would traverse over values of 'b')
18:13:48 <lambdamu> tempeh: newtypes are the workaround for that
18:15:27 <tempeh> lambdamu: yeah, they solve part of the problem (heavily), but they wouldn't solve the problem if the type I'm trying to traverse over doesn't appear on the LHS
18:17:02 <tempeh> right? you can't use class constraints in newtype definitions?
18:18:30 <tempeh> eh, need to go think, i'm just missing something
18:20:48 <lambdamu> tempeh: I'm not sure I understand what you are trying to do, do you have simple example?
18:21:59 <tempeh> i think i've figured out a workaround. thanks :)
18:32:57 * hackagebot data-diverse 0.4.0.0 – Extensible records and polymorphic variants. – https://hackage.haskell.org/package/data-diverse
18:44:04 * hackagebot preamble 0.0.43 – Yet another prelude. – https://hackage.haskell.org/package/preamble
19:29:54 <Lokathor> do array and vector have similar performance profiles?
19:47:46 <Shockk> can I bounce some weird theoretical idea I'm working with right now?
19:47:59 <Shockk> working on*
19:48:38 <Shockk> I'm considering how to define -> in terms of itself, theoretically
19:49:03 <Shockk> i.e. the operator used to represent a mapping from one thing to another thing
19:50:05 <Shockk> I may be going out of my mind but I wanted to check, does the following theoretical type signature make sense to anyone, in a dependent types-ish kind of way?
19:50:10 <Shockk> (->) : a -> b
19:50:55 <Shockk> i.e. at the value-level, 
19:51:58 <Shockk> x -> f would represent some expression f, parameterized by x;  where -> is of type b parameterized by type a
20:01:23 <mnoonan> Does anybody know what became of the GSOC project to make a SWIG module for Haskell?
20:17:20 * slack1256 likes how clear the rts tries to be
20:18:25 <slack1256> I've been thinking on a collaborative effort (kind of like a wiki) where extended discussion of code can be carried out. Any references?
20:30:28 <Xandaros> https://hastebin.com/uxodusujob.txt - what am do? :(
20:31:51 <systemfault> How did you install ghc? What OS?
20:32:26 <Xandaros> Arch Linux, installed via package manager
20:32:49 <Xandaros> This was also working fine a week or so ago
20:33:31 <systemfault> I also use Arch but used slack... If a recent update mess up ghc, that's going to suck for me since I use XMonad.
20:33:37 <systemfault> s/slack/stack
20:34:30 <Xandaros> I'll try updating my system again and see if it helps. No ghc update, but a kernel update. Doubt it'll help
20:34:38 <Xandaros> After that, I'll try rolling back ghc
20:35:12 <geekosaur> known issue with arch''s packaged ghc
20:36:10 <geekosaur> (8.0.2 they decided to unbundle the static libraries and have packaged libs not install them at all. but they didn't change their ghc to use dynamic haskell libs by default, so you get that when you try to build anything.)
20:36:41 <geekosaur> there's a ghc-static package that installs the static libs for the base libraries, but afaict there are still no static libs for other arch-packaged haskell libs
20:38:08 <Xandaros> ok, so... rollback is my only option atm? (Apart from installing ghc myself)
20:38:40 <systemfault> Do the same as me... use stack :)
20:38:58 <systemfault> It downloads and uses its own version of GHC
20:39:00 <geekosaur> rollbck, stack, or install a ghc bindist
20:39:16 <systemfault> Xandaros: And it won't mess up with your system.
20:39:51 <Xandaros> installing ghc bindist sounds like a pain and I don't like stack, so rollback it is
20:40:08 <systemfault> The only reason why I use the system's ghc is because xmonad depends on it
20:40:09 <systemfault> Ah ok
20:41:38 <tefter> somebody should notice arch ghc package maintaner as ghc now can't compile hello world ;p
20:42:40 <geekosaur> there's already several open bugs (against it and their xmonad package, at least)
20:43:36 <systemfault> Eventually, I'll try to make xmonad works with stack's ghc... it would probably be better
20:44:12 <geekosaur> look around for xmonad build scripts for stack
20:44:43 <systemfault> Thanks, will definitely do
20:50:49 <Xandaros> Is deleting .cabal not enough? It seems to still have a lot of packages and is now complaining about missing files...
20:51:23 <monochrom> No, look into ~/.ghc and be very afraid.
20:51:29 <Xandaros> Ahh
20:52:03 <monochrom> In fact do a "ghc-pkg list" some day and --- important --- nevermind the packages themselves, look at the two directory names.
20:52:31 <geekosaur> Xandaros, .cabal has the library files, .ghc has the package database
20:52:42 <Xandaros> Yeah, makes sense
20:52:46 <geekosaur> so if you nuke only .cabal you break everything because ghc thinks the packages are still there
20:53:03 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#ident
20:53:31 <Xandaros> Not to count my chickens before they hatched, but shelly seems to install again \o/
20:54:22 <Xandaros> And my scripts work again! Thank you very much :D
20:54:33 <Xandaros> (I should probably compile them to prevent this happening again...)
20:55:53 <monochrom> An exe with the haskell libraries statically linked is very stable and portable.
20:56:26 <monochrom> OTOH it does discourage updating to new library APIs because now you have no incentive to.
20:59:28 <monochrom> I now have a 5-year-old exe I don't want to change because it uses an old HXT and I have no confidence my code is compatible with current HXT.
21:00:17 <Clint> that seems like a suboptimal situation
21:01:59 <monochrom> It is probably like voting systems.
21:05:51 * hackagebot preamble 0.0.44 – Yet another prelude. – https://hackage.haskell.org/package/preamble
21:05:58 <Clint> except your old binary works?
21:12:56 * hackagebot wolf 0.3.20 – Amazon Simple Workflow Service Wrapper. – https://hackage.haskell.org/package/wolf
21:29:02 <The_Kinaesthetic> Hi
21:30:00 <The_Kinaesthetic> quick question: When pattern matching on a list (e.g. map f (x:xs)) , the parenthesis is just for associativity purposes right?
21:31:50 <The_Kinaesthetic> Ah nvm I think I proved it to myself that that's the case by using ":" as a prefix
21:32:01 <The_Kinaesthetic> Thanks bye.
21:49:32 <davr0s> whats the ballpark performance of haskell vs c or c++, and vs  C# 
21:49:38 <davr0s> whats the ballpark performance of haskell vs c or c++, and vs  C# 
21:49:56 <davr0s> not for fibonacci series
21:51:04 <davr0s> second question, does the purity translate into greater parallelization in practice , e.g. on your quadcore machine suddenly 'half the speed of c, single threaded' becomes 'double the speed in most cases, because you can trivially use all cores'
21:52:43 <LiaoTao> davr0s: In response to your second question: If you have a function without side-effects you can trivially parallelize mapping over a list, for example
21:53:00 <LiaoTao> I changed 'map' to 'parallelMap' and got a linear speed up wrt. number of cores
21:53:10 <LiaoTao> Depends on your workload, of course
21:53:50 <davr0s> my background is gamedev.   I have a strong negative reaction to the word 'garbage collector';  but i also know plenty of useful code (even in games) doesn't need performance (there are offline tools to condition data .. there's game scripting too)
21:55:23 <davr0s> LiaoTao yes, 'parallelMap' is the sort of thing i had in mind, (and knowing about unrolling , SIMD, GPGPU makes me thing of the mentality of map )  but i wonder if beyond that haskell creates parallel opportunities that you might not even directly see, e.g. via the way the whole thing works with lazy eval
21:55:54 <LiaoTao> I had that question too, but I suppose the answer isn't so clear cut
21:55:58 <LiaoTao> Mostly, it's 'no'
21:56:00 <davr0s> i suppose it might just be 'purity forces you to write lots of code you can use parallel Map on...'
21:56:21 <LiaoTao> But the functional code allows explicit parallelization to a greater degree
21:56:28 <LiaoTao> Without a lot of synchronizing etc.
21:56:58 <davr0s> i note there's Folds... which are implicitely serial. but then there's "tree like folds" . In some cases, I know the fold is of a commutative function, and it could be done tree-like..
21:57:57 <davr0s> so i guess we wont just have a completely general lazy eval dependancy graph with N cores randomly working their way through it
21:58:18 <LiaoTao> davr0s: There's https://wiki.haskell.org/Numeric_Haskell:_A_Repa_Tutorial
21:58:34 <LiaoTao> davr0s: As of now, I don't think so
21:58:48 <LiaoTao> But maybe some guru can chime in
21:59:02 <davr0s> something else that worries me is haskell sounds very heavy on pointer-chasing internally
21:59:33 <LiaoTao> Haskell runtime behaviour is generally hard to predict
22:00:20 <LiaoTao> You can be explicit about the expression evaluation strictness whenever you want, though
22:00:27 <LiaoTao> Which is a good optimization strategy sometimes
22:00:56 <LiaoTao> However, since it rules out laziness optimizations, it's not always obvious which one is better without doing some kind of profiling
22:02:35 <davr0s> i wonder if they have some heuristics themselves, "if these nodes are sufficiently simple, it's probably better to eager-eval them rather than leave pointers lying around.."
22:03:13 <LiaoTao> IMO Whatever GHC does under the hood is pure black magic and pixie voodoo
22:05:00 <LiaoTao> davr0s: The general upside to Haskell is that it's incredibly terse and you can do more with less boilerplate than most languages
22:05:05 <LiaoTao> It's not a silver bullet
22:05:18 <davr0s> yes thats what i'm seeing , it is awesomely elegant
22:05:38 <davr0s> although sometimes the mental effort to get something working can still seem similar.. it's just your fingers are less busy
22:05:51 <LiaoTao> davr0s: It gets better with time
22:06:01 <davr0s> of course a compact definition has the advantage that it's probably more versatile
22:06:03 <LiaoTao> One downside you might find sore is that many libraries are poorly documented if at all
22:06:26 <davr0s> more compact i.e. more patterns exploited
22:07:06 <LiaoTao> Also note that I've got less than a year's experience with Haskell - there are wizards with like 10 years and more in here
22:07:10 <LiaoTao> You can wait for them to chime in
22:08:02 <Lokathor> is there a way to go over a functor while knowing what "index" you're at?
22:08:36 <davr0s> i tried haskell a while back, got as far as spinning asteroids in gl.. but dropped it on trying to do other things (e.g. "building datastuctures from fileformats -> I concluded the record naming restrictions made it awkward") . but i've picked it up again (after rust) and it's making much more sense now
22:08:38 <Lokathor> I can write enumerate :: [a] -> (Int -> a -> b) -> [b], that's obvious, but for all functors seems trickier
22:09:04 <davr0s> do functors even know they have an index?
22:09:32 <davr0s> is there another concept, 'traversible' or something that does imply ordering
22:09:49 <Lokathor> I'm not fully clear
22:10:09 <davr0s> maybe 'Sequence'? (i'm nowhere near fully clear)
22:10:10 <Lokathor> in the case of enumerate (name picked because that's what rust calls it), you just zip the list you're mapping over with [0..]
22:11:44 <LiaoTao> Lokathor: That's what I usually do
22:12:31 <LiaoTao> There was a suggestion on the mailing list to make (,) an instance of Functor, but I think it was down voted because no one could say what should be done with n-tuples with n>2
22:12:50 * Lokathor assumes that zip is written in terms of map or foldr or something so that the lists fuse properly
22:13:04 <davr0s> would that need it to be (t,t)  rather than (a,b)
22:13:23 <Lokathor> it would need to be, yes
22:13:34 <Lokathor> ((,) a) already has a Functor instance
22:13:44 <Lokathor> but (a,b) is crazier
22:14:10 <Lokathor> > length (0,0)
22:14:12 <lambdabot>  1
22:14:15 <Lokathor> oh Haskell, so silly
22:14:21 <davr0s> wtf
22:14:30 <LiaoTao> instance Functor (,) where
22:14:31 <davr0s> >length [1,2]
22:14:31 <LiaoTao>   fmap (f,g) (a,b) = (f a, g b)
22:14:35 <LiaoTao> That was the proposal
22:14:40 <davr0s> > length [1,2]
22:14:42 <lambdabot>  2
22:14:57 <Lokathor> :t length
22:14:58 <lambdabot> Foldable t => t a -> Int
22:15:15 <Lokathor> a tuple is a Foldable with one element in it, the second value
22:15:19 <Lokathor> so the length of it is always 1
22:15:24 <davr0s> LiaoTao oh i've wanted to do something similar, 
22:16:00 <Lokathor> LiaoTao, that doesn't... seem to match the type signature that fmap needs :/
22:16:22 <LiaoTao> :t fmap
22:16:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:17:24 * hackagebot wolf 0.3.21 – Amazon Simple Workflow Service Wrapper. – https://hackage.haskell.org/package/wolf
22:17:24 * hackagebot loup 0.0.10 – Amazon Simple Workflow Service Wrapper for Work Pools. – https://hackage.haskell.org/package/loup
22:18:23 <davr0s> i was doing folds or something where i was getting 'a list of tuples' and i wanted to say 'apply this function to a, and another to b'
22:19:22 <LiaoTao> Writing an anonymous function is easy enough I suppose
22:19:45 <davr0s> yeah now i typed that it sounded stupidly easy but there was more to it.. i've deleted that codepath and simplified it, subsequently
22:20:20 <davr0s> there was several places where something similar was happening.. i probably had something *like* the fmap example you just posted aswell, and might have made a helper for that
22:20:56 <LiaoTao> It's still a comparatively small amount of boiler plate, so I see how their decision is justified
22:21:02 <Lokathor> https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
22:21:09 <Lokathor> bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
22:21:10 <LiaoTao> Avoiding runtime errors is a good motivation
22:22:14 <LiaoTao> https://mail.haskell.org/pipermail/libraries/2016-January/026609.html
22:22:18 <davr0s> woudl this be for something like "parallel arrays" ,
22:23:06 <Lokathor> > map (bimap (+1) (*8)) [(0,0),(1,1),(2,2)]
22:23:08 <lambdabot>  [(1,0),(2,8),(3,16)]
22:23:13 <davr0s> e.g. C++ example   ...  t..<T,Y> struct Foo { int size;  T* data1; Y* data2; // combined vector where data1, data2 have the same length
22:23:37 <davr0s> like you could implement 'bimap' for [(a,b)]   or ([a],[b]) 
22:23:53 <davr0s> and have the same logic applied to interleaved or planar data
22:24:07 <davr0s> like SOA vs AOS
22:24:11 <LiaoTao> Seems to me that's what zip and unzip is for, no?
22:24:46 <davr0s> well, imagine making a pattern that abstracts whether something is AOS or SOA
22:25:24 <davr0s> ' i know i have a sequence of pairs or a and b, but i dont mind how they are stored..'
22:25:53 <davr0s> https://en.wikipedia.org/wiki/Parallel_array
22:26:04 <Lokathor> that's actually how Vectors actually do it in Haskell already
22:26:10 <davr0s> https://en.wikipedia.org/wiki/AOS_and_SOA
22:26:17 <Lokathor> but it's not generalized across other things
22:28:35 <davr0s> another interesting possiblity is 'AoSoA' ,e.g.  arrays of batches of 4 elements 
22:28:54 <LiaoTao> davr0s: Something tells me this is already present somewhere
22:29:00 <LiaoTao> It generally is
22:29:15 <davr0s> twiddled /swizzled arrays perhaps
22:29:51 <davr0s> that would be something similar for 2d data, but this is the case of somethign 'semantically equivalent to an array of records'
22:30:23 <davr0s> anyway one could implement 'bifunctor' for 'records that are 2 elements',   maybe gneralize that to 3,4 ..
22:31:10 <davr0s> oh i suppose a regular functor instance owuld be needed most of the time ie. 'apply a function to the whole element'
22:31:40 <davr0s> and maybe all the laziness would make that equivalent in the case of soa vs aos storage
22:43:12 <Lokathor> https://lokathor.gitbooks.io/using-haskell/content/roguelike/week-2-graphics-and-dungeon-basics.html okay folks, week 2 of the roguelike tutorial seems good to go
22:43:42 <Lokathor> as always, call me out if i've got any factual errors/ typos/ etc.
22:43:45 <davr0s> r.e. parallelization, would there be the possibility of marking  a 'parallelMap' whose behaviour can depend on the nesting level, e.g. to implemetn 2 levels of parallelism ( threads X SIMD) or for control on many-core machines /clusters
22:44:42 <Lokathor> maybe? http://chimera.labs.oreilly.com/books/1230000000929/index.html read that book I forget if it covers it exactly
22:44:47 <Lokathor> :P
22:53:38 <wwizww> so haskell has a (parallel) GC which occasionally stops the world
22:53:57 <Lokathor> it stops the world any time it runs, and it might run occasionally, yes
22:54:33 <wwizww> does this mean that if you try to execute a task in parallel, the speedup gained from parallelism suffers from an amdahls law sort of limitation
22:55:02 <wwizww> e.g. parallelization benefits are limited by percent of application time spent doing GC
22:55:17 <Lokathor> clearly I know what that law is, but you should remind everyone else to be polite :3c
22:57:35 <cocreature> wwizww: well the GC is parallel so I don’t think amdahl’s law is really the right way to look at this. the problem is the overhead of synchronizing the different threads so parallel gc can start
22:58:59 <wwizww> sure, amdahl's law isn't complicated -- in simple terms it says that if a certain fraction of your computation must be performed in serial, then even as you throw more parallel processors at a task, that initial fractional limitation limits the benefit you gain from increasing the number of parallel executing threads you throw at the problem,... for instance if 25% of your computation needs to be executed in serial, then even with
22:59:39 <Lokathor> The "erlang limit" as some might call it :D
23:00:10 <ReinH> @google parallel and concurrent programming in haskell
23:00:11 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
23:00:11 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
23:00:29 <Lokathor> ReinH, I already linked that
23:00:44 <ReinH> Ah yes. I just got here.
23:01:21 <Lokathor> oh, well, ReinH have you ever wanted to know how to program a roguelike in Haskell?
23:01:54 <ReinH> Yes.
23:01:57 <cocreature> dump the nethack source code in a Haskell program via inline-c and you’re done :)
23:02:32 <Lokathor> hmmmm
23:02:39 <Lokathor> NetHack source is very hard to read
23:02:53 <cocreature> I wasn’t being serious in case this wasn’t completely obvious :)
23:02:56 <wwizww> check out the dwarf fortress bug tweets, they are hilarious
23:03:17 <wwizww> https://twitter.com/dwarffortbugs?lang=en
23:03:26 <Lokathor> oh no but I already had a 10,000 line Main.hs file half compiled :P
23:03:43 <Lokathor> ReinH, https://lokathor.gitbooks.io/using-haskell/content/roguelike/week-2-graphics-and-dungeon-basics.html :3c
23:04:45 <wwizww> 8185: Limbless Opponents Re-equip items after rest
23:04:58 <Lokathor> wwizww, my favorite bug was when the melting point of dwarf flesh was way low but the trigger for it didn't check at all times, so dwarves were fine until they stepped between two differently temp'd areas
23:05:09 <Lokathor> then they melted into a skeleton
23:05:13 <wwizww> haha
23:05:26 <ReinH> An IORef for the position? :(
23:06:03 <wwizww> so anyway what's this about parallel GC thread synchronization?
23:06:10 <MarcelineVQ> Urist McDwarf is carving a legendary mural of two dwarves melting. One dwarf is laughing, the other is making a plaintiff gesture.
23:06:18 <wwizww> is this something that takes a microsecond so it doesn't affect anthing?
23:06:31 <cocreature> you should probably also be strict when modifying the ioref in the key callback
23:06:47 <Lokathor> ReinH, due to how GLFW works, which is what Hexes is based on, input is processed via callbacks
23:07:14 <ReinH> Yeah, I hate that they force an imperative style.
23:07:22 <cocreature> and maybe you also need it to be atomic
23:08:08 <ReinH> I'd love to see a roguelike written with some sort of FRP. Especially one that supports ASCII animation, sort of like cogmind.
23:08:26 <ReinH> Maybe even using conal's FRP animation model.
23:08:37 <Lokathor> cocreature, because of (again) GLFW, your input processing and graphical usage have to both be in main at all times. So... I don't think I'd bother with multi-threaded at all
23:09:09 <Lokathor> I might, but it'd be tricky and far more complex than I'd want to present as a tutorial of how to do it
23:10:00 <cocreature> Lokathor: I don’t think that matters. the callback could still be interrupted by the Haskell runtime in the middle of modifyIORef and you’ll run into trouble
23:10:14 <Lokathor> dag
23:10:38 <The_Kinaesthetic> Does "case of" boil down to lambda?
23:10:44 <Lokathor> the callbacks run "in" the pollEvents call, so at the moment it's all serial code
23:10:57 <Lokathor> The_Kinaesthetic, no case boils down to case :3
23:11:22 <ReinH> The_Kinaesthetic: pattern matching is the basis of pretty much everything.
23:11:25 <cocreature> ah ok, i thought setKeyCallback would result in the glfw C-code calling back into Haskell
23:11:49 <Lokathor> cocreature, yeah GLFW is all kinds of messed up :/
23:11:53 <The_Kinaesthetic> So statements like "Everything pretty much desugars to lambda statements"
23:12:05 <The_Kinaesthetic> is more like "desugards to lambda and case of"
23:12:11 <ReinH> everything pretty much desugars to case.
23:12:21 <The_Kinaesthetic> Damn so why so much emphasis on lambda
23:12:24 <Lokathor> function applications are lambdas, but function evaluations depend on cases
23:12:35 <ReinH> emphasis on lambda by whom?
23:13:40 <The_Kinaesthetic> Idk seemingly everyone
23:13:47 <The_Kinaesthetic> Even the Language Report
23:13:56 <ReinH> What does the report say?
23:14:29 <LiaoTao> Lokathor: Nice book
23:14:55 <The_Kinaesthetic> "Although the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda calculus with a straightforward denotational semantics"
23:15:00 <wwizww> does haskell have a dwarf fortress monad
23:15:01 <LiaoTao> Too bad there are no functioning higher level OpenGL bindings :(
23:15:11 <ReinH> The_Kinaesthetic: "lambda calculus"
23:15:31 <Lokathor> LiaoTao, that's what my Hexes library is, wrapping GLFW and opengl in a way that's roguelike oriented
23:15:35 <ReinH> Is not referring to the \p -> e construction in Haskell syntax.
23:15:41 <ReinH> It is referring to the lambda calculus.
23:15:55 <The_Kinaesthetic> does lambda calculus have pattern matching or something?
23:16:07 <cocreature> although tbf “a lambda calculus” might be a better choice of words. there are a lot of different flavors of lambda calculi
23:16:09 <The_Kinaesthetic> \p -> e is like exactly what I learned lambda calculus was
23:16:18 <The_Kinaesthetic> just written as \p.e instead
23:16:44 <The_Kinaesthetic> so when I see lambda calculus that's immediately what i think of
23:16:58 <The_Kinaesthetic> hmm maybe i should look into the simply typed lambda calculus or somethign
23:17:01 <ReinH> No, although lambda calculus can be extended with pattern matching.
23:17:13 <LiaoTao> Is the high-level OpenGL package receptive of patches?
23:17:19 <LiaoTao> Might add some uniform uploading functions
23:17:27 <ReinH> LiaoTao: which package?
23:17:36 <ReinH> I'd suggest using gl unless you have a good reason not to
23:18:03 <LiaoTao> ReinH: Graphics.Rendering.OpenGL
23:18:06 <LiaoTao> I am using it right now
23:18:12 <LiaoTao> But it's disconcertingly imperative
23:18:20 <LiaoTao> gl, that is
23:19:32 <ReinH> It's a low-level OpenGL binding. It's going to look a lot like the OpenGL API.
23:20:13 <dibblego> https://hackage.haskell.org/package/gl
23:20:17 <LiaoTao> ReinH: Which is why I wanted to patch the other one with missing features :)
23:20:40 <wwizww> opengl is really stateful
23:20:53 <The_Kinaesthetic> ew
23:21:30 <ReinH> You can build higher-level things on top that are less imperative.
23:22:04 <ongy> it's just hard when you don't want to slow down
23:22:42 <ReinH>  His quine is a pretty good example https://github.com/ekmett/quine
23:26:09 <LiaoTao> Lokathor: By the way, if you're doing a step-by-step simulation you might consider waitEvents
23:26:18 <LiaoTao> Might save some idle CPU cycles
23:26:22 <wwizww> https://vimeo.com/216330850
23:26:50 <LiaoTao> Instead of pollEvents, that is
23:26:59 <Lokathor> LiaoTao, true. Also, i'm not sure if it's all systems, but on my system at least GLFW's refresh seems to wait for vsync automatically
23:27:15 <LiaoTao> It's system dependent :)
23:28:30 <Lokathor> i think you can set, uh
23:28:37 <Lokathor> one of those things to always have vsync
23:28:46 <Lokathor> frame delay set to 1? 
23:28:48 <Lokathor> i think
23:28:53 <LiaoTao> You can probably set window options, yes
23:28:57 <LiaoTao> But there's also a system default
23:29:01 <LiaoTao> Even system overrides
23:29:16 <LiaoTao> Just saying it might be good to not run at a million fps doing nothing :D
23:29:30 <Lokathor> i remember now, they don't set it by default because on some systems it starts at 0 but it can't be set back to 0 once it acquires a non-0 value
23:29:40 <Lokathor> oh boy i love running at a million fps
23:30:31 <Lokathor> i'll look into always enforcing vsync, but in the future i want to toy around with having some thing color based on time and other minimal animation effects
23:30:42 <LiaoTao> Right
23:30:44 <Lokathor> like "torchlight" that flickers
23:31:06 <Lokathor> Brogue does that, and it's way slick
23:31:11 <LiaoTao> You can probably also do a set x fps
23:31:15 <LiaoTao> Not relying on vsync to slow you down
23:31:33 <LiaoTao> It is, it's very gool
23:31:35 <LiaoTao> cool*
23:32:45 * hackagebot openexr-write 0.1.0.0 – Library to write images in OpenEXR HDR file format. – https://hackage.haskell.org/package/openexr-write
23:38:13 <Lokathor> glfwSwapInterval
23:38:14 <Lokathor> that's it
23:39:06 <Lokathor> my lib should set (swapInterval 1) at some point
23:48:10 <Lokathor> https://twitter.com/antiselfdual/status/863008810595631105
