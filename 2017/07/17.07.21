00:05:00 <qqwy> Good day!
00:15:58 <frerich> Hmm, I seem to recall that I saw a function '(a -> Bool) -> a -> Maybe a' somewhere which applies the given predicate to a value and then yields a 'Just' value in case the predicate yields True, Nothing otherwise. Does anybody recall if/where that function is defined? I thought it was a fairly standard helper, but Hoogle doesn't seem to give me anything for that type.
00:16:21 <tikhon> I tend to use monad comprehensions for that
00:16:27 <frerich> I thought it was 'fromBool p x = if p x then Just x else Nothing' or so, but it's not in Data.Maybe (where I thought I saw it).
00:16:28 <tikhon> [a | foo a]
00:16:48 <tikhon> which, I believe, is the same as using guard
00:16:52 <tikhon> something like
00:16:56 <tikhon> a <$ guard (foo a)
00:17:49 <EvanR> :t [a | foo a]
00:17:51 <lambdabot> error:
00:17:51 <lambdabot>     • Variable not in scope: foo :: Expr -> Bool
00:17:51 <lambdabot>     • Perhaps you meant one of these:
00:17:57 <EvanR> :t \a -> [a | foo a]
00:17:58 <lambdabot> error:
00:17:59 <lambdabot>     • Variable not in scope: foo :: t -> Bool
00:17:59 <lambdabot>     • Perhaps you meant one of these:
00:18:23 <tikhon> Haskell has not yet learned to understand metasyntactic variables :P
00:18:23 <EvanR> i need sleep
00:18:30 <tikhon> :t \ a -> [a | even a]
00:18:31 <lambdabot> Integral t => t -> [t]
00:18:45 <tikhon> and lambdabot probably doesn't have MonadComprehensions enabled
00:20:48 <tikhon> with the extension enabled, you get a mildly hideous type for that function:
00:20:52 <tikhon> \ a -> [a | even a]
00:20:52 <tikhon>   :: (Integral b, GHC.Base.Alternative m, Monad m) => b -> m b
00:21:43 <tikhon> I wonder if there's some analogue of ApplicativeDo for monad comprehensions
00:21:47 <frerich> tikhon: That's nifty, but I thin  '[a | foo a]' is too clever for my own good. :-) I also experimented a bit with the Maybe monad (I sensed that maybe something made of 'return' and 'guard' could work), alas without success so far.
00:22:08 <tikhon> frerich: personally, I find it to be the most readable option
00:22:31 <tikhon> it's a natural idiom
00:22:50 <tikhon> building an intuition for how guard works is really helpful
00:22:58 <frerich> tikhon: To me, '\p x -> if p x then Just x else Nothing' is about as readable as it gets, I just thought that I saw this function defined somewhere already.
00:24:48 <tikhon> I would probably prefer the explicit if-then-else over the version using guard, but I think it's a bit too long and hard to read at a glance.
00:24:55 <tikhon> That said, it is still *really* worth understanding how/why the guard version works.
00:25:07 <tikhon> Not just for Maybe, but for all the other monads that support it.
00:25:09 <tikhon> :t guard
00:25:10 <lambdabot> Alternative f => Bool -> f ()
00:25:37 <frerich> Ah, 'mfilter' could work I think. I.e. '\p -> mfilter p . Just'
00:26:14 <tikhon> Really not a fan of that one, honestly.
00:26:21 <frerich> Neither am I :-}
00:27:16 <tikhon> I do think there should be a clearly named function for this in Data.Maybe.
00:27:55 <tikhon> There are a few super-useful patterns it enables.
00:28:23 <tikhon> For example, it's really easy to specify a bunch of different rules with different conditions and just take the first one that's satisfied.
00:28:51 <EvanR> theres probably one in the package that converts maybe to either and back
00:29:01 <EvanR> "1001 functions to convert between maybe either etc"
00:29:36 <tikhon> I don't know that package specifically, but I've seen other packages that supply functionality missing in Prelude but go really overboard.
00:29:50 <tikhon> Data.List.Split comes to mind
00:30:00 <EvanR> i think missingH has gone the way of the dodo
00:30:16 <tikhon> it never had much of an identity
00:30:30 <tikhon> personally, I'm abstractly in favor of alternative preludes
00:30:41 <tikhon> although I've never used on in Haskell
00:30:58 <EvanR> every time i see 1 function in a package i want... exactly 1... it goes in my hypothetical personal prelue
00:31:01 <tikhon> I did some OCaml with Jane Street's Core library, and it was way better than OCaml's normal standard library
00:31:28 <EvanR> yeah a lot can be said for a sane default lib
00:31:29 <tikhon> especially standardizing lightweight serialization/deserialzation on an s-expression-based format
00:31:36 <tikhon> so much better than JSON
00:31:52 <tikhon> whereas Haskell's Show and Read are a complete mess in practice
00:32:22 <EvanR> i pretend Read doesnt exist
00:32:43 <tikhon> I think I only use it for parsing numbers.
00:32:55 <tikhon> There's also the weird Numeric module, I suppose
00:32:59 <EvanR> which doesnt help you when youre using a parser
00:33:39 <tikhon> I am honestly pretty tempted to write a version of sexplib for Haskell.
00:36:25 <EvanR> plenty of sexp stuff for haskell already
00:37:00 <EvanR> for some reason people are into json instead
00:37:54 <tikhon> Worse is better :/
00:39:22 <EvanR> arguably, sexp is the ultimate "worse is better" :)
00:44:44 <orzo> Would it cause any problem to make Bits/Ord instances for a type such that bit number 0 is the *most* significant bit?
00:45:40 <orzo> And if i did do that, should i also reverse what is "leading" and "trailing" zeros?
00:46:47 <orzo> hm, the documentation stipulates that 0 is the least significant bit
00:47:35 <EvanR> make sense
00:47:45 <orzo> kademlia ids are better numbered from the high bit
00:49:51 <orzo> "Bits are numbered from 0 with bit 0 being the least significant bit." -- that only makes sense with respect to an Ord instance, right?
00:50:29 <EvanR> sounds like a lawyering stretch
00:51:04 <EvanR> significance is assuming your Bits object has some numeric value
00:51:37 <EvanR> a finite array of bits, with two ends, doesnt necessarily have one
00:52:27 <EvanR> in which case a bit numbering scheme that goes backwards is no different from looking at the array from the other side of the dinner table...
00:53:08 <orzo> well my Ord will essentially treat it as numeric
00:53:22 <orzo> with the most significant bit being Bits number 0
00:53:55 <Athas> orzo: that sounds counter-intuitive.
00:53:57 <EvanR> if you had a numeric value, most significant bit change would change it "by the most"... in terms of value
00:54:12 <orzo> yeah, bit 0 would change it by the most
00:54:13 <EvanR> im not sure what that means for Ord
00:54:26 <EvanR> Ord isnt the same as metric/diff
00:54:33 <Athas> So this would be little-endian bit sequences?
00:55:07 <Athas> It would be easier if everything (including natural language) was just little-endian.
00:55:12 <EvanR> exactly what does putting bit 0 on the wrong side simplify?
00:55:55 <Athas> EvanR: it is more logical for bit streams, isn't it?
00:56:05 <Athas> Most streams are left-to-right.
00:56:13 <EvanR> ... that makes no sense
00:56:44 <EvanR> you can write a bit stream going down and to the left if you want
00:56:54 <orzo> different kademlia networks have differently sized ids, bittorrent uses 20 bytes, tor uses 32 bytes.  It is common to perform an xor and compare, and only the highest bytes are normally relevant.  It is also common to have a list of "buckets" numbered from 0 to 20 (or more), that corespond to the highest bit on downward
00:56:58 <Athas> Okay, a stream is ordered.
00:57:01 <EvanR> "significance" is talk about something else
00:57:14 <EvanR> a stream has no finite value
00:57:21 <Athas> What does the Ord instance for lists do?
00:57:37 <EvanR> freeze up sometimes
00:57:38 <Athas> I think it is best to just stick to whatever "standard" already exists for sequences.
00:57:39 <orzo> if i number the low bit as 0, then it will be obnoxious detail to refer to the higest bit as either 159 or 255
00:58:15 <EvanR> man, why did they do it that way...
00:58:42 <EvanR> wait
00:59:01 <EvanR> orzo: so are you treating these IDs are binary numbers sometimes? 
00:59:08 <EvanR> or is that an accident
00:59:25 <orzo> the kademlia metrix is to perform an xor on the ids and then treat the results as big numbers
00:59:25 <EvanR> if not, its just arrays of bits, doesnt matter how you do it
00:59:28 <orzo> metric
00:59:45 <EvanR> so they just did it all backwards for the hell of it
00:59:50 <EvanR> neat
01:00:00 <orzo> i'm not sure why you say they did something backwards
01:00:14 <orzo> numbering the buckets?
01:00:21 <EvanR> because they aligned the least significant at different places in different situations
01:00:32 <orzo> the number of buckets you need depends on the size of your network, and it makes sense to start numbering from 0
01:00:35 <EvanR> its like using different metric units for no reason
01:01:01 <EvanR> here are a bunch of integers, some are giga, some are centi
01:01:06 <EvanR> convert accordingly
01:01:21 <EvanR> they aligned the wrong end
01:02:13 <orzo> it's normal for the high bits to matter more in comparisons, they did that the normal way
01:03:00 <EvanR> then it seems like they should all logically be 256 bits long
01:03:09 <EvanR> the short version is scaled up
01:03:16 <orzo> oh
01:03:18 <EvanR> (when doing comparisons)
01:03:24 <orzo> well kademlia didn't specify the number of bits
01:03:47 <orzo> most early versions used 160 bits because that's the size of sha1
01:04:00 <orzo> now sha256 is popular and newer networks are using 256
01:04:14 <orzo> the id space should corespond to a crypto hash
01:04:17 <orzo> in size
01:04:33 <EvanR> and if someone uses 512, all numbers in site must be shifted?
01:04:38 <EvanR> sight
01:05:31 <orzo> hmm, yes, i think it makes sense that if i want to put a sha1 into a sha256 kademlia, that I should pad the right side and make the high sha1 bits the ones that determine which computer stores it
01:05:40 <orzo> so yeah, we'd pad the numbers at the low end
01:06:39 <ertes-w> helo
01:06:39 <EvanR> based on nothing whatsoever, i would think Bits is a way to view your values as an array of bits, and significance might not apply
01:06:53 <Athas> Significance still matters for Ord instances.
01:06:59 <EvanR> if your view comes with an arbitrary padding on the right, so be it
01:07:11 <EvanR> Athas: im still not sure how
01:07:30 <Athas> For lexicographic ordering.
01:07:46 <Athas> Well, I guess you could come up with some other Ord instance.
01:08:01 <EvanR> (by on the right, i mean... .&. 1 would be 0)
01:08:12 <ertes-w> orzo: i bet a lot of code also makes the assumption that bit 0 is the LSB, and really that's the only assumption that makes sense to me, and i know i've certainly made it
01:08:17 <orzo> is there a difference between lexicographic and ordinary big-endian for bit strings that are the same length?
01:08:35 <ertes-w> orzo: otherwise the distinction between Bits and FiniteBits would be pointless and Integer would not have a Bits instance
01:08:36 <EvanR> Athas: i dont understand what you mean... lexicographic ordering of the array of bits?
01:09:13 <Athas> EvanR: when comparing two such arrays, yes.
01:09:15 <EvanR> what is FiniteBits
01:09:18 <orzo> ertes-w: ah, but what if you want infinite bits with lexicographic ordering?  Then shouldn't bit 0 be the most significant bit?
01:09:29 <ertes-w> > finiteBitSize (0 :: Word32)
01:09:31 <lambdabot>  32
01:09:35 <ertes-w> EvanR: ^
01:09:38 <merijn> EvanR: Bits for types that are finite? :p
01:09:53 <EvanR> how does this differ...
01:10:04 <merijn> EvanR: Well, what'd the bit size of Integer be?
01:10:19 <ertes-w> EvanR: the Bits API had a flaw
01:10:24 <ertes-w> > bitSize (0 :: Integer)
01:10:26 <EvanR> depends on the integer? i think youre answering a question i didnt ask
01:10:27 <lambdabot>  *Exception: Data.Bits.bitSize(Integer)
01:10:28 <EvanR> fill me in
01:10:44 <merijn> EvanR: Bit size should be constant
01:10:52 <ertes-w> EvanR: ^ for that reason FiniteBits made it into base at some point somewhere around 7.6 or 7.8 i think
01:10:54 <EvanR> so its specifically answering a bit size
01:11:12 <merijn> EvanR: Integer conceptually infinitely many 0 bits prefixing whatever amount of non-zero bits it has
01:11:29 <ertes-w> orzo: infinite bits and "most significant bit"?
01:11:38 <ertes-w> orzo: what is the most significant bit of an Integer?
01:11:47 <EvanR> isnt Word32 the same way? and left shifting deletes whatever goes too far
01:11:49 <merijn> EvanR: Well, FiniteBits would conceptually have different shift semantics
01:11:52 <EvanR> delete / 0-out
01:12:20 <EvanR> i guess rotation requires a window
01:12:24 <orzo> i'm not talking about an integer, i'm talking about an infinite list of Bool, I compare from the front which has index 0.  It's most natural to number it as Bits 0 also.
01:12:48 <ertes-w> EvanR: not necessarily…  consider 2-adics
01:12:52 <merijn> orzo: Depends if you're doing big endian or little endian :p
01:13:09 <ertes-w> orzo: [Bit] ≃ Natural
01:13:18 <ertes-w> well, not quite
01:13:47 <EvanR> if significance is about magnitude, then it doesnt make sense for an infinite list of bool
01:13:51 <ertes-w> well, quite…  they *are* isomorphic, but that wasn't my point…  you're basically doing Natural stuff
01:14:18 <orzo> i wasn't meaning to use the word natural in a technical sense
01:14:19 <EvanR> i am very skeptical about this theory that significance is about ordering
01:14:39 <ertes-w> > rotateL 15 1 :: Integer
01:14:42 <lambdabot>  30
01:14:48 <ertes-w> > rotateL (-15) 1 :: Integer
01:14:50 <lambdabot>  -30
01:15:04 <ertes-w> hmm, ok, i expected a different result
01:15:08 <EvanR> flipping the LSB has the least effect on the values mass so to speak
01:16:05 <orzo> Evan, and so it would move it the least amount in it's relative ordering
01:16:10 <orzo> to other masses
01:16:27 <EvanR> this doesnt sound right at all
01:16:34 <orzo> why not
01:16:48 <EvanR> thats mixing up metric spaces and orderings
01:17:01 <ertes-w> i would have expected: rotateL (-15) 1 = -31
01:17:06 <ertes-w> for Integer
01:17:18 <EvanR> does what you want work for infinite streams
01:17:22 <EvanR> what you say*
01:17:41 <EvanR> (and whether it does or not, how does it help anyone)
01:18:36 <EvanR> take the real numbers, and take floats as a subset which uses finite number of bits
01:18:37 <ertes-w> orzo: consider this question: what does it mean to *set* the MSB?
01:18:54 <ertes-w> orzo: or this:  what's the value of (bit 0)?
01:19:07 <EvanR> if you flip the LSB, exactly how far is this moving it in the "relative ordering of all possible reals"
01:19:21 <EvanR> and why bring ordering in at all whatsoever
01:19:49 <orzo> in kademlia, if the msb of the distance is set, then you are in bucket 0
01:20:18 <orzo> if it is clear and there is more than one bucket, you are in bucket 1
01:20:21 <ertes-w> orzo: here is another question: should flipping the MSB twice be the identity function?
01:20:22 <EvanR> where is the MSB?
01:20:32 <EvanR> 256?
01:20:45 <orzo> ertes-w: as opposed to what?
01:21:06 <ertes-w> orzo: well, consider (15 :: Integer)
01:21:16 <ertes-w> orzo: flipping the MSB would result in 7, right?
01:21:27 <EvanR> haha
01:21:30 <orzo> there is no MSB, Integer is arbitrary precision
01:21:38 <EvanR> 15 -> 7 -> 3
01:21:49 <orzo> the MSB is infinitely to the right
01:21:54 <ertes-w> orzo: then are you suggesting that bit numbering is really a FiniteBits notion?
01:22:03 <orzo> no, there is an LSB
01:22:09 <orzo> integer has an LSB 0
01:22:12 <orzo> and it has 1 and so on
01:22:21 <EvanR> 0 :: Integer might be the empty bit string!
01:22:24 <EvanR> no LSB
01:22:24 <orzo> it just odes not have MSB which, yes, *that* is a finite bits thing
01:22:27 <ertes-w> orzo: would you agree that if we establish a bit ordering, it should always be the same?
01:22:59 <ertes-w> for Bits that is
01:23:00 <orzo> shrug
01:23:25 <orzo> it'd make my code more elegant to number the MSB from 0
01:23:30 <orzo> less noisy math
01:23:38 <orzo> finiteBitSize - 1
01:23:45 <ertes-w> orzo: why don't you just write wrapper functions?
01:24:20 <ertes-w> msb n = finiteBitSize (undefined :: MyIntegerType) - n - 1
01:24:29 <EvanR> i think you just need to pad "on the right" your smaller values to match the largest values?
01:24:34 <EvanR> in size
01:24:52 <orzo> well i'm trying to remove the "size" detail as irrelevent
01:25:20 <orzo> after all, i could just as well do this metric on infinite bitstrings
01:25:30 <EvanR> when you xor, wont you need that size to know when to stop
01:25:39 <orzo> the the first being the most significant for Ord, but with their not having any particular finiteBitsize
01:26:01 <EvanR> how do you measure significance with Ord
01:26:07 <EvanR> (only)
01:27:15 <EvanR> we are making up laws in order to break them !
01:27:29 <ertes-w> orzo: the size is relevant
01:27:33 <ertes-w> it's not a detail
01:28:25 <orzo> how do you figure
01:28:56 <orzo> i could represent my ids as [Word64] and do an xor that zips over them and then an ord that compares from the front
01:29:40 <orzo> the most signicant bit fo the first Word64 is the most significant bit for the whole stream, but it has no bit number
01:29:50 <orzo> unless that number is 0
01:29:58 <orzo> and i'm counting reverse the usual way
01:31:06 <orzo> kademlia metric is d(x,y) = (x `xor` y) considered as a number
01:31:07 <EvanR> im arguing that it doesnt matter what bit 0 is, and this is an artifact of thinking the direction we writing on paper is somehow in these data types
01:31:43 <EvanR> unless we have some formulas that make use of Ord somehow, and some laws that are breaking
01:32:34 <EvanR> orzo: sufficiently padded first?
01:33:08 <orzo> EvanR: it's assumed that x and y are some fixed number of bits
01:33:58 <EvanR> ok, then the only question is which of 2 standard ways you consider the result a number
01:35:31 <orzo> Well two byte streams that start with the same first byte are considered closer together than two byte streams that have differeing first bytes, regardlessof the rest of the bytes
01:35:52 <orzo> so the first byte in the stream is most significant
01:35:54 <ertes-w> orzo: because the index of the MSB is relevant
01:36:06 <ertes-w> @let msb = finiteBitSize - 1
01:36:08 <lambdabot>  Defined.
01:36:14 <EvanR> bytes also matter? :(
01:36:16 <ertes-w> what's the value of (bit msb)?
01:36:29 <EvanR> now theres more than 2 ways to consider the result a number
01:36:34 <orzo> and nothing would break in the algorithm if instead of saying "treat as a number" as the kademlia authors do, instead treated as a lexicographic ordering of bits
01:37:33 <EvanR> nonstandard bit numbering or nonstandard ordering by bits... pick your poison?
01:37:35 <ertes-w> BTW, the way we write numbers is rather stupid =)
01:37:53 <ertes-w> least-significant-first makes a lot more sense
01:38:45 <EvanR> thats how it is, i look at papers from the other side
01:39:09 <orzo> I thikn it'd be nice to use [Word64] to represent ids because then I could xor and compare, and laziness would save me from xoring the irrelvent bytes
01:39:38 <EvanR> so youre working on the level of bits bytes and Word64 all at once ... geez
01:40:27 <EvanR> i would say make a choice that helps future readers of your code (you)
01:41:05 <EvanR> even if it does take more characters to type now
01:41:29 <EvanR> indefinitely having to remember this non standard way to do it...
01:41:35 <EvanR> or they way someone did it
01:42:20 <orzo> probably jsut putting some prominent documentation in the code is suficcient
01:42:30 <EvanR> sure
01:43:07 <orzo> i currently already have a testBit-alike function that numbers the bits reversed
01:44:08 * hackagebot json-tracer 0.0.2.0 – A polymorphic, type-safe, json-structured tracing library – https://hackage.haskell.org/package/json-tracer
01:46:18 <EvanR> oh yeah, MSB first for infinite stream, makes sense if youre doing reals between 0 and 1
01:46:19 <orzo> so msb would be 0, but "leading" and "trailing" would be?
01:47:24 <orzo> yes, reals between 0 and 1 is a good way to think of it
01:47:25 <EvanR> thats literally how its written heh
01:47:47 <orzo> my metric maps two points to a real between 0 and 1
01:48:03 <orzo> 1 is infinitely far away
01:48:14 <orzo> 0 implies it's the same value
01:48:31 <EvanR> doesnt sound right
01:48:41 <orzo> d(x,y)=0 implies x=y
01:48:43 <EvanR> 1 = 11111111...
01:48:58 <EvanR> whatever xor that is the complement
01:49:08 <EvanR> which is some finite distance away
01:50:29 <orzo> er, 111111111... would have been the result of the xor
01:50:49 <EvanR> so two complements xored
01:51:02 <EvanR> finite distance apart but disagree in infinite places
01:51:10 <orzo> complements are as far away as you can get
01:51:36 <pimlu> so, I found a memory leak earlier through profiling
01:52:00 <EvanR> bucket number is "count the 1 bits" or something?
01:52:06 <pimlu> it was a classic situation of foldl' where reducing to WHNF didn't help since it was a tuple and the slots were full of huge thunks instead
01:52:35 <orzo> count the leading zeors, 0 leading zeros is 1..., and that's bucket 0
01:52:48 <orzo> bucket 0 contains the nodes farthest away
01:53:01 <EvanR> pimlu: an easy way to use a tuple but have it act strict is to bang pattern the contents before putting them in the tuple
01:53:19 <orzo> bucket 20 contains nodes that are very close by and their node ids start with the same bits as yours
01:53:25 <pimlu> yeah I basically did something like that
01:53:39 <pimlu> I was only able to find the bug kind of incidentally though - is there a way to see "your program heap is full of thunks containing values named x" right now?
01:53:47 <pimlu> because it seems like all the graphs are really vague
01:54:28 <EvanR> variable names dont survive
01:54:45 <EvanR> but theres who created the thunk, who is holding the thunk
01:54:59 <pimlu> yeah, that's how I found it
01:55:06 <pimlu> makes sense then
01:55:15 <pimlu> guess I have to get good at using that
01:55:35 <EvanR> ghcvis can show heap objects graphically...
01:55:49 <EvanR> but there would be a lot of data in your real life problem
01:57:32 <EvanR> an easy way to debug these things is to get good at not getting into the situation. if you know the contents are small, like numbers, and you will definitely need them, then bang pattern before any construction, use strict fields
01:58:54 <pimlu> I see, thanks
01:59:30 <EvanR> especially in a foldl' situation... i mean... doing a fold that cannot give any useful results until its fully done with
01:59:46 <pimlu> so is it common in real world haskell programs to be cautiously and potentially overly strict in your data logic, and then lazy as usual in control flow?
02:00:10 <EvanR> i think the main dichotomy is consumer vs producer
02:00:20 <EvanR> foldl'ing is consuming
02:00:40 <EvanR> whatever its consuming was produced somewhere, hopefully lazy
02:00:58 <pimlu> I see
02:01:23 <EvanR> its all data and all control flow in some sense
02:01:37 <merijn> ongy: epoll is "edge triggered", kqueue register tickets. The classic example is "scaling a network server with HIGH connection rate"
02:01:55 <merijn> ongy: Single-threaded "accept" loop is to slow. So you wanna call accept on the same socket in many threads/processes
02:02:08 <merijn> ongy: epoll wakes up *all* threads/processes whenever a connection arrives
02:02:12 <merijn> ongy: kqueue wakes up 1
02:02:24 <merijn> ongy: (Newer linux kernels let you kludge around that)
02:03:04 <MarcelineVQ> that's for a bsd convo in #haskell-offtopic if anyone's interested :>
02:03:14 <merijn> eh...
02:03:22 <merijn> I blame irssi :)
02:05:48 <EvanR> pimlu: so... overly cautious strict constructions would be a consumer thing, but you definitely want lazy production of source data if possible. too bad i dont have more specific generic model of this, its just a hunch
02:06:35 <EvanR> enough graphviz should be able to prove anything
02:07:52 <pimlu> yeah, that makes sense
02:08:23 <pimlu> thanks a bunch
02:28:02 <merijn> hmmm, unfortunate that Chart uses a list for their point plotting interface...
02:29:11 <merijn> Turns out, large lists are very effective at running machines out of RAM :)
02:30:03 <merijn> Does GHC have like a "don't bother GCing until you're literally running out of physical RAM" toggle?
02:33:04 <merijn> Actually...would it make sense to enable parallel GC for a single threaded program if my live set is huge?
02:45:09 <heebo> where can i find how Data.Map implements Eq? I have a map that contains another map and I want to test the contents for equality in a TVAR
02:47:04 <merijn> heebo: Well, you can pretty much guess from the instance definition )
02:47:25 <merijn> heebo: "instance (Eq k, Eq v) => Eq (Map k v)", so it seems like it just compares all key/value pairs
02:48:11 <heebo> thanks , didnt think of that , 
02:48:28 <heebo> i need to get more used to infering from the instance def.... although i guess it can be dangerous at times
02:50:06 <merijn> heebo: Well, that's why people are so pedantic about instances obeying laws. Gives you something to reason with :)
02:51:17 <merijn> heebo: Also, Hackage (for more recent packages) has source links for instances :)
02:51:56 <merijn> heebo: So if you go to https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Lazy.html#t:Map and click the "source" link behind the Eq instance it jumps to the definition
02:52:26 <merijn> heebo: But, in general, Eq is interpreted to be "value" equality in Haskell, so anything else would be bad anyway :)
02:57:10 * hackagebot yaml-combinators 1.1 – YAML parsing combinators for improved validation and error reporting – https://hackage.haskell.org/package/yaml-combinators
02:59:05 <merijn> hmmm, how much slowdown should I expect from profiling?
03:01:19 <pimlu> for me it was like 10x slower or so
03:05:22 <heebo> merijn: thanks thats really usefull
03:06:05 <heebo> perhaps you filled up your heap and the app started swapping or doing more GC
03:06:48 <heebo> real world haskell has a chapter on profiling , in it they suggest that you may need to increase heap (with -K ghc flag ... I think) in some circumstance
03:10:21 * hackagebot language-puppet 1.3.8.1 – Tools to parse and evaluate the Puppet DSL. – https://hackage.haskell.org/package/language-puppet
03:11:42 <heebo> obviously profiling makes the code perform worse - which is why you may not be so efficient and use increased memory
03:26:47 <bollu> can I use nix as a build system?
03:26:53 <bollu> I can't sanely manage shell scripts anymore
03:28:09 <MarcelineVQ> there's some pretty comprehensive nix scripts in the try-reflex repo you could have a look at
03:29:07 <MarcelineVQ> There's a nix channel if you need more specific help
03:30:29 <AWizzArd> What is the max length of elements in a tuple?
03:32:08 <bollu> I see, ty
03:32:19 <ealthout> is there a max length?
03:32:21 <MarcelineVQ> slots in the tuple? something like 63 I thiiiink, havent' checked in awhile
03:32:25 <bollu> #nix ?
03:32:36 <MarcelineVQ> idk, #nix or #nixos
03:32:56 <ealthout> I'd argue if someone has a code base with 63-value tuples, something needs to be done
03:33:20 <Iceland_jack> You should be able to check GHC.Exts.maxTupleSize
03:33:55 <MarcelineVQ> ah mm, 62 appearantly
03:39:55 <AWizzArd> MarcelineVQ: thx
03:40:41 <quchen> Mark says: more than 62 segfaults.
03:44:28 <heebo> just launched a bucket load of threads and the runtime is scheduling them unfairly , how can i fix scheduling of forkIO
03:51:03 <merijn> heebo: Are you sure you're using the threaded runtime?
03:51:52 <merijn> hmm...surprisingly there's not actually much GC going on
03:52:06 <merijn> Maybe my code's just slow and I have to life with it :\
03:59:20 <ertes-w> bollu: i use nix exclusively for everything from development over building to deployment
03:59:49 <bollu> ertes-w neat
03:59:50 <ertes-w> bollu: it has replaced cabal-install for me (along with CI and deployment tools)
03:59:54 <bollu> ertes-w any place to start?
03:59:55 <int-index> Let's say I have an expensive function 'a -> b'. I want to turn it into a function 'Diff a -> Diff b', where Diff is some type of patches. This way if small changes are made to 'a', I can get small changes to 'b' quickly.
04:00:05 <bollu> ertes-w I'm looking at it as more a 'make' / `shell script` replacement
04:00:16 <int-index> There was a paper on deriving this using metaprogramming (maybe TemplateHaskell). I can't find it.
04:00:36 <int-index> Does anyone know of something similar?
04:00:45 <ertes-w> bollu: in that case all you need is:  cabal2nix . > shell.nix && nix-build shell.nix
04:01:37 <merijn> bollu: new-build from cabal HEAD works in a nix-style, btw
04:01:46 <ertes-w> bollu: that produces (by default) a symlink called 'result' in the current directory that points to the resulting derivation (nix slang for the resulting installation in the nix store, which on the level of nix is viewed as a "value")
04:02:07 <ertes-w> bollu: cabal2nix you only need when your cabal file changes
04:03:07 <bollu> ertes-w no, they're shell scripts that build LLVM stuff / tie a bunch of random tools together
04:03:19 <MarcelineVQ> int-index: can you provide more info?
04:03:24 <bollu> ertes-w I was hoping to have incremental builds in this context
04:03:26 <bollu> :)
04:03:35 <ertes-w> bollu: "incremental"?
04:04:45 <bollu> ertes-w in the sense of ninja. don't rebuild if you don't need to 
04:04:52 <bollu> perhaps incremental is the wrong word.
04:05:04 <pacak> int-index: I don't think it's possible in general.
04:05:09 <ertes-w> bollu: you can do that on the derivation level
04:05:20 <ertes-w> bollu: nix will do that by itself
04:05:58 <pacak> suppose my expensive function takes a graph and produces solution for TSP.
04:07:16 <pacak> Now imagine we add one more point to the graph (Diff a). To get exact solution you'll have to solve a full problem.
04:08:22 <ertes-w> bollu: which means: if you change a source file, the entirety of the derivation will be rebuilt, and so will any derivation that depends on it (it's really wrong to call this "rebuilding"…  it's really just a new derivation, because it's a different expression…  you're building something new that just happens to be similar to something you have already built, and nix will never rebuild something that is already there, unless told to do so)
04:12:35 <bollu> ertes-w that is super neat
04:17:15 <int-index> MarcelineVQ, it's just a paper I remember
04:17:23 <ealthout> ertes-w: do you use nix for things not-haskell also?
04:17:36 <int-index> pacak, it didn't work on any function, it was a metaprogramming transformation on a subset of functions it could handle
04:20:16 <ertes-w> ealthout: yeah
04:20:28 <ealthout> cool, I might try that
04:20:38 <ealthout> I was trying to get into nix a while back but didn't
04:20:45 <ealthout> I like the idea overall
04:21:01 <ertes-w> ealthout: i use it for python environments (the less i have to learn py-specific things the happier i am), and for building docker images
04:22:02 <ealthout> ertes-w: so I currently have a project that's mainly lua, but it's got some C and C++ parts, some of which are libraries I depend on and some that is my own code. And there are a few lua library dependencies that I currently just install with luarocks. Would you use nix to manage building/running a project like that?
04:23:17 <ertes-w> ealthout: yes, and i'm happy to discuss this in #haskell-offtopic =)
04:23:38 <ealthout> good point
05:31:43 <mpickering> quchen: Thanks, it was easy to write a custom renderer which does what I need 
05:32:09 <mpickering> Now to work out how to build the branch of ghc which uses prettyprinter
05:33:59 <quchen> mpickering: bollu did some work on this I believe
05:34:13 <mpickering> yes, that's the branch I am talking about
05:34:24 <quchen> I see
05:36:07 <quchen> mpickering: What did you need the »output position count« for if I may ask?
05:37:10 <bollu> mpickering are you trying to understand the ARM diff?
05:37:14 <bollu> mpickering the asm diff*
05:37:44 <mpickering> Because I want to output kythe so I need to know the position of where everything is printed so the cross linking works properly
05:37:54 <bollu> what's kythe?
05:38:06 <mpickering> and once I have this I can also use the SourceNotes to cross link source haskell with it's core
05:39:52 <mpickering> bollu: kythe is  a "language-agnostic ecosystem for building tools that work with code"
05:40:30 <mpickering> The bit I am interested in is the generic cross-linker. You emit the edges which say what refers to what and it visualises it nicely for you. 
05:41:08 <mpickering> I guess you could also do the same with STG
05:41:49 <quchen> Interesting use case. I never considered investigating the output much.
05:42:54 <quchen> Glad I added the crazy monadic backend support.
05:43:01 <quchen> I was never sure what it was good for, really :-)
05:43:15 <quchen> (Other than rendering to IO directly)
05:44:25 <mpickering> I had to program it directly rather than use any of the helpers but it was still easy 
05:44:41 <mpickering> but the helpers were definitely useful to read from 
05:44:51 <quchen> Yeah since you had to track newlines differently for example
05:44:58 <bollu> interesting
05:44:59 <quchen> The helpers are really just for the most common cases
05:45:06 <bollu> mpickering link?
05:45:27 <bollu> https://kythe.io/
05:45:29 <bollu> this?
05:45:43 <mpickering> What is the l parameter in STText for?
05:45:44 <mpickering> Yes that
05:45:58 <mpickering> If you search "haskell-indexer" on the ghc-devs list then there is an example there
05:45:58 <quchen> mpickering: length of the contained text
05:46:06 <mpickering> oh right that's useful
05:46:27 <quchen> mpickering: Length for Text is O(n), and I had to calculate it for the layouting anyway, so I figured I might as well keep it in the SimpleDoc
05:46:53 <quchen> Does the STText doc not mention this? If so, ticket please and I’ll fix it!
05:47:33 <bollu> mpickering does kythe also include language server?
05:47:58 <mpickering> I don't know what language server is
05:48:09 <bollu> https://github.com/Microsoft/language-server-protocol
05:48:30 <quchen> That language agnostic editor plugin interface thing that sounds really cool?
05:48:56 <mpickering> I don't know sorry, seems they could be related
05:49:30 <mpickering> bollu: What is the status of your branch btw, it doesn't build for me currently but how integrated is it?
05:50:30 * hackagebot hruby 0.3.4.4 – Embed a Ruby intepreter in your Haskell program ! – https://hackage.haskell.org/package/hruby
05:54:34 <qqwy> Hello, everyone!
05:54:41 <qqwy>  I am trying to get Yesod up and running
05:54:58 <qqwy> I've been following http://www.yesodweb.com/page/quickstart to the letter (using Haskell 8.0.2)
05:55:06 <qqwy>  But after running `stack exec -- yesod devel` and visiting localhost:3000, I get the message "The application isn't built"
05:55:13 <qqwy> And in the terminal it says: The following target packages were not found: devel-signal
05:55:26 <qqwy> What is happening? What can I do to fix this problem?
05:55:46 <qqwy> Probably related, when running `stack ghci` I get the following failures: https://pastebin.com/1vuYTTAZ
06:06:54 <bollu> mpickering really? weird, it used to build for me
06:07:02 <bollu> mpickering it builds till stage1, to be precise
06:07:09 <bollu> mpickering stage2 gets fucked up because of package.db
06:09:03 <mpickering> https://www.irccloud.com/pastebin/WZ9m4HnL/
06:09:13 <mpickering> These errors
06:10:59 <bollu> mpickering no, not those errors
06:11:06 <bollu> mpickering perhaps I rebased correctly
06:11:24 <mpickering> those are the ones I was getting after applying the patch so I just commented out those functions for now
06:11:37 <mpickering> Why does it break the package db?
06:11:40 <bollu> mpickering I'm sorry, I think I pushed a half baked thing or something. However, there was a correct version of the revision
06:12:03 <bollu> mpickering me and bgamari suspect that it's because the code that's generated is wrong. Even the package.db magic numbers were generated incorrectly IIRC
06:12:03 <mpickering> Can you perhaps update the diff or push a branch which I can use?
06:12:07 <bollu> sure
06:12:34 <mpickering> as in, you integrated it and it then broke the package db or even without any integration it broke?
06:13:01 <mpickering> I just want to rewrite the core pprinter using this so if it's easy to undo the integration to fix it that would be great
06:13:14 <osa1> anyone here use dbmigrations package? I'm wondering what is "test" command exactly doing. is it comparing the updated+reverted version of the DB with the original DB?
06:13:27 <bollu> mpickering stage2 never built
06:13:40 <bollu> it would break at something related to packagedb that I don't understand fully
06:13:49 <bollu> mpickering stage1 would build fine, though
06:14:45 <mpickering> There was also another problem with submodules I had to fix btw
06:14:49 <bollu> mpickering https://github.com/bollu/ghc/commit/3ac9f52c5380bf3cf59e1875de6773135a56b1b6
06:14:54 <mpickering> They were named incorrectly
06:14:55 <bollu> mpickering I believe this commit builds
06:14:56 <bollu> I see
06:15:08 <bollu> mpickering but I have not checked
06:15:13 <bollu> mpickering I'll get off from work in a couple hours
06:15:22 <bollu> mpickering I could update the diff with the version that "worked" to some degree then
06:15:28 <bollu> I'm sorry for breaking the phab diff :)
06:17:22 <bollu> mpickering : https://phabricator.haskell.org/differential/diff/12899/
06:17:30 <bollu> mpickering that diff was the farthest I have gotten
06:17:34 <bollu> in terms of a correct build.
06:18:14 <mpickering> So is prettyprinter used at all to output anything? 
06:18:54 <bollu> mpickering yes, it was used to output the ASM code
06:18:59 <bollu> which was why I had to change the handle stuff
06:19:06 <bollu> mpickering but, well. That breaks codegen :) 
06:19:18 <mpickering> Can I revert that by changing one import line?
06:19:26 <bollu> possibly, yes.
06:19:35 <bollu> which import line are you referring to, exactly?
06:19:48 <bollu> mpickering I had replaced all uses of pretty at that point with prettyprinter
06:20:13 <bollu> mpickering I tried reintroducing pretty once it became clear that it was prettyprinter which was causing the problem
06:20:22 <bollu> but it looks like I uploaded a half-implemented diff or something, unfortunately.
06:20:39 <mpickering> import OutputablePrettyprinter -> import Outputable
06:21:29 <lyxia> qqwy: the executable depends on foreign-store, even the header in DevelMain mentions this, yet for some reason it's not in the .cabal file.
06:22:30 <mpickering> Or is there a commit I can go back to which definitely works?
06:22:32 <bollu> mpickering at the diff that I showed you, there is no "OutputablePrettyprinter", I had replaced Outputable's internals.
06:22:40 <bollu> mpickering no commit "works" because codegen is broken
06:23:04 <mpickering> by "works" I mean everything uses "Outputable" but there is a "OutputablePrettyprinter" module
06:23:47 <bollu> ah
06:24:14 <bollu> no, I do not believe such a commit exists, sorry
06:24:15 <bollu> :(
06:35:34 <pavolzetor> hello, I have spent couple days trying to improve productivity of my haskell program and I can't get it more than 60% (1 thread) and 20 % multiple threads
06:36:05 <pavolzetor> I tried using unboxed vectors and that just made thing marginally slower (but less memory, so win)
06:36:12 <pavolzetor> what should I try to do?
06:36:40 <pavolzetor> the program recursively subdivides catmull-clark patches
06:37:00 <pavolzetor> so each subdivision is four 4x4 patches 
06:37:34 <pavolzetor> most allocations is reported to be in linear V3
06:39:27 <mpickering> quchen: Does the cabal.project file work for you in prettyprinter?
06:41:32 <quchen> mpickering: I have to confess that’s not tested at all, Herbert told me »put that there it’ll work« half a year ago and that’s it
06:41:38 <quchen> mpickering: Is it broken?
06:41:56 <mpickering> yes, I will patch that as well
06:43:00 <pavolzetor> on related note, is it possible to modify 2 vectors with modify call?
06:43:47 <pavolzetor> because I suspect doing V.unstablePartition is not in place
06:45:03 <mpickering> quchen: Please forgive the single PR
06:47:53 <briian> hi
06:48:05 <briian> what do you guys use haskell for?
06:48:21 <pavolzetor> I am going to try put everything in ST monad
06:48:43 <pavolzetor> briian, server, ray tracing (although this is not good idea)
06:49:12 <briian> sounds complex
06:49:57 <hk_> hello everyone
06:50:15 <pavolzetor> not really, the main problem is you produce ton of data on the traversal and that is really slow
06:50:55 <briian> pavolzetor:  i mean the task itself sounds complex. i have a computer science degree but all i have ever done is work with basic data structures in web development
06:51:09 <briian> i want to spice up my abilities and learn something more ..useful
06:51:17 <briian> but im not sure what, because im not sure what im interested in
06:52:47 <brynedwards> I use haskell for web stuff, mainly API backends and clients
06:53:16 <cocreature> pavolzetor: you’re going to need to show at least parts of your code if you expect useful tips on how to make your program faster
06:55:11 <pavolzetor> briian, haskell is wonderful for learning new concepts; there is category theory for programmers tutorial too
06:55:17 <sphinxo> say I have some type data A = B Int | C Float
06:55:21 <pavolzetor> web will degrade your mind
06:55:49 <pavolzetor> do something more interesting, compiler, game, ray tracer
06:56:07 <sphinxo> how can I write an Abitrary generator that'll generate either  (B <Int>, B <Int>) or (C <Float>, C <Float>)
06:56:27 <pavolzetor> cocreature: sorry, https://github.com/pavolzetor/currypath/blob/master/src/Geometry.hs
06:56:37 <pavolzetor> traceBVH and traceBunchM
06:56:40 <pavolzetor> those take most time
06:56:45 <pavolzetor> and make most allocations
06:57:04 <pacak> :t arbitrary
06:57:05 <lambdabot> Arbitrary a => Gen a
06:57:37 <pavolzetor> though mainly traceBunchM
06:57:40 <pacak> :t arbitrary :: Either (Int, Int) (Float, Float)
06:57:42 <lambdabot> error:
06:57:42 <lambdabot>     • Couldn't match expected type ‘Either (Int, Int) (Float, Float)’
06:57:42 <lambdabot>                   with actual type ‘Gen a0’
06:57:44 <pavolzetor> the BVH is just traversal
06:57:49 <pacak> :t arbitrary :: Gen (Either (Int, Int) (Float, Float))
06:57:50 <lambdabot> Gen (Either (Int, Int) (Float, Float))
06:58:07 <pacak> sphinxo: You don't need to.
06:58:18 <sphinxo> ?
06:58:30 <pavolzetor> traceBunchM works by splitting primitive until is tiny and then intersecting (similar to REYES)
06:58:49 <sphinxo> oh yeah how do I nicely create the actual structures from that
06:59:24 <pacak> either (A *** A) (B *** B) or something like that.
06:59:37 <pacak> Alternatively you can write Arbitrary instance for A
06:59:44 <ertes-w> briian: if you're the kind of person haskell appeals to, simply learning it might already give you quite a few things you might be interested in
06:59:46 <pacak> Or use Arbitrary's applicative instance
06:59:55 <pavolzetor> I used ST to write the intersection results, and a permutation vector to reorder rays during traversal
07:00:29 <pacak> :t (***)
07:00:31 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:03:19 <pavolzetor> since it is depth first traversal, only a single stack should be necessary so it should not be that slow and make so many allocations
07:03:38 <ertes-w> briian: for example a lot of haskellers (myself included) love how you can take abstract, algebraic concepts and turn them into practical software engineering tools…  the appreciation for that can either come from a sense for mathematical beauty/elegance, or from a purely pragmatic standpoint of "this approach actually works, unlike (e.g.) OOP"
07:03:59 <pavolzetor> for example, I would expect GHC to preallocate a stack of some size and you push and pop from it doing no allocations
07:04:10 <pavolzetor> just one at the start of traversal
07:05:18 <yoneda> ertes-w: +1
07:05:41 <hk_> Do you know some haskell project to learn ?
07:06:25 <pacak> hk_: in what way?
07:06:36 <hk_> I have learned haskell 3 months.
07:07:25 <pacak> What do want to learn about?
07:08:26 <cocreature> pavolzetor: well you are allocating new vectors in each step of go
07:08:39 <pavolzetor> I have to run, if anybody has time to look at that code and has insight please email me at pavol@klacansky.com or open an issue
07:08:57 <pavolzetor> cocreature, you mean in V.unstablePartition?
07:09:11 <hk_> web server or 3d games
07:09:16 <cocreature> pavolzetor: yes
07:09:37 <pavolzetor> that's true, I may try put it in mutable vector
07:09:53 <pavolzetor> there are also allocations in subdivision steps (1 patch into 4 patches)
07:09:54 <cocreature> I’m not sure how you want to do that
07:10:00 <cocreature> you need the same "todo" in both calls to "go"
07:10:06 <cocreature> so you can’t just mutate it
07:10:11 <pavolzetor> I can
07:10:19 <pavolzetor> those are disjoint in memory
07:10:35 <pavolzetor> similar to quicksort
07:10:52 <pavolzetor> hk_, do games!
07:11:10 <cocreature> I’m not following. how can it be disjoint if it’s literally the same "todo" you are passing to the left and right calls
07:11:17 <cocreature> if you end up mutating it in one of them, things break
07:11:51 <angerman> cocreature: any word on how much llvm ir has chanced?
07:12:08 <angerman> guess I should just kick off a llvm5 build and see?
07:12:18 <cocreature> angerman: I’m not yet at the IR part. I haven’t yet managed to get my code to compile using the new version :)
07:12:24 <cocreature> the API changes are pretty bad this time
07:12:32 <cocreature> but that doesn’t need to affect IR
07:12:44 <angerman> yea ;-)
07:13:40 <cocreature> also binding to LLVM from C (which is needed for Haskell bindings) is becoming more and more painful
07:14:24 <pavolzetor> cocreature, but those are not done in parallel right?
07:15:12 <cocreature> pavolzetor: right but you need to know the old value of "todo" once you go to the other branch. so you still can’t overwrite it
07:15:16 <pavolzetor> so even if one branch shuffles todos, it will do so in place so when it returns up and go into the second go call it will be same size but order may changed (which is fine)
07:15:50 <pavolzetor> I can change todo to start, end pair
07:16:08 <pavolzetor> as optimization
07:16:12 <angerman> cocreature: will you bestow upon us ffi++?
07:16:23 <pavolzetor> but it should work without that, as rays === todo
07:16:38 <pavolzetor> it is just a map, and i am permuting domain
07:17:17 <cocreature> angerman: nah, I’m not even sure how that could work with templates on a conceptual level and templates are where it is painful so solving the part without templates is boring
07:18:07 <angerman> sad
07:18:53 <fromMaybe> does anyone know of function/operator that will allow me to filter values under a certain value 
07:19:12 <mnoonan> .. filter (< certainValue) ?
07:19:17 <angerman> cocreature: what's wrong with generating llvm bitcode ir again as the llvm interop gateway? ;-)
07:19:34 <fromMaybe> let's say I have a list [1,2,4,2,4]
07:19:47 <cocreature> angerman: that doesn’t help if you want to build a jit
07:19:48 <fromMaybe> And I want to return a list that only has values over 2
07:20:03 <mnoonan> > filter (>= 2) [1,2,4,2,4]
07:20:05 <lambdabot>  [2,4,2,4]
07:20:16 <qqwy> lyxia: Thank you very much for your answer
07:20:25 <angerman> cocreature: well, you just need to encode the jit in llvm ir.
07:20:31 <qqwy> I'll try adding foreign-store to the .cabal file
07:20:48 <cocreature> angerman: no I’m talking about jitting the IR you’re generating
07:21:24 <fromMaybe> lol @ me being a n00b
07:21:26 <angerman> cocreature: yea, the JIT will have to be written in the IR ;-)
07:21:29 <fromMaybe> let me try to implement and come back
07:23:17 <cocreature> angerman: I’m not sure how that helps. then I need to JIT written in IR so that it can JIT the actual IR I’m interested in but I still don’t have anything to start with
07:24:39 <angerman> cocreature: I obviously don't know enough about llvm and jiting.
07:25:24 <cocreature> angerman: e.g. accelerate generates IR from Haskell code, JITs that and can then call the compiled functions without ever writing anything to disk
07:25:37 <cocreature> angerman: any you can even do that lazily, i.e, compile the functions only when they’re called
07:26:12 <angerman> so that IR -> function logic is some LLVM library?
07:26:55 <cocreature> yes, you can pass a module to the JIT in LLVM and then ask it for a function and it will give you back a function pointer to the compiled function
07:27:29 <Athas> cocreature: Accelerate used to write code to disk for compilation.
07:27:36 <Athas> At least the CUDA backend did.  Not sure how the LLVM backend does it.
07:27:52 <cocreature> Athas: I’m pretty sure the LLVM backend doesn’t but maybe I’m missremembering
07:27:55 <fromMaybe> what about if the list is in the form [isJust .04, isJust .5, isJust .65] and I want to filter out any isJust <.5
07:28:28 <cocreature> fromMaybe: what is "isJust" supposed to be?
07:28:37 <Athas> I don't think there is any reason for the LLVM backend to do it, except for an on-disk cache.  But it's not really important whether Accelerate touches the disk, I think.
07:28:42 <fromMaybe> sorry sorry, I mean Just
07:29:13 <lyxia> qqwy: in the meantime I did the steps and everything actually compiled, ignoring that file.
07:29:24 <merijn> > [x | Just x <- [Just 0.04, Just 0.5, Just 0.65], x < 0.5]
07:29:27 <lambdabot>  [4.0e-2]
07:29:29 <lyxia> qqwy: so foreign-store seems necessary only for the repl.
07:29:40 <merijn> > [x | Just x <- [Just 0.04, Just 0.5, Just 0.65], 0.5 < x]
07:29:42 <lambdabot>  [0.65]
07:29:55 <qqwy> Interestingly, it seems the repl indeed works now with foreign-store installed
07:29:57 <cocreature> yeah maybe it doesn’t matter for accelerate. but once you start JITing individual functions lazily you don’t want to compile them to some object file, write that to disk only to then load it again
07:30:06 <bollu> " It is best not to change the Nix store from its default, since doing so makes it impossible to use pre-built binaries from the standard Nixpkgs channels" wow that's a bummer
07:30:10 <qqwy> But the page itself `(stack exec -- yesod devel)` does not
07:30:15 <bollu> I'm on a hevily restricted machine
07:30:38 <angerman> cocreature: I set off a clang-50 build. let's see if that finishes by tomorrow :)
07:30:39 <shapr> that's my brain too!
07:31:18 <lyxia> qqwy: are you sure "stack build" succeeds? Is there an error message when you run yesod devel?
07:31:30 <cocreature> angerman: is your machine that slow or is tomorrow not that far away in your timezone? :)
07:31:48 <angerman> cocreature: it's 10:30pm, and I'm getting tired :)
07:31:57 <qqwy> Yes, `stack build` succeeds without errors 'Completed 2 actions'
07:32:04 <qqwy> (and running it again shows no output)
07:32:12 <ventonegro> > [x | Just x <- [Just 0.04, Just 0.5, Nothing], 0.5 < x]
07:32:14 <lambdabot>  []
07:32:30 <qqwy> Now running yesod devel shows 'The following target packages were not found: devel-signal'
07:32:38 <qqwy> (as it did before)
07:32:43 <ventonegro> > [x | Just x <- [Just 0.04, Just 0.5, Nothing], 0.1 < x]
07:32:46 <lambdabot>  [0.5]
07:33:12 <qqwy> And localhost:3000 says 'The application isn't built' and it refreshes once per second.
07:36:07 <fromMaybe> so once I define x in the just x function, how could I use that function, to apply to a new list
07:36:28 <lyxia> qqwy: what is the version of yesod?
07:39:08 <cocreature> angerman: sleep tight! :)
07:39:34 <angerman> cocreature: the horrors that await me ;-)
07:59:13 <merijn> Am I missing some obvious to specify a list of acceptable values for an option with optparse-applicative?
08:03:21 <briian> sorry got distracted
08:03:26 <briian> pavolzetor: lol at itll degrade your mind
08:03:28 <briian> probably not wrong..
08:03:42 <briian> its decent money but i really wanna make something that matters eventually
08:21:08 <qqwy> lyxia: yesod 1.4.5
08:34:34 <lyxia> qqwy: that's an odd error because devel-signal is not a package
08:34:49 <lyxia> qqwy: what about your stack version?
08:35:03 <qqwy> Version 1.4.0, Git revision e714f1dd3fade19496d91bd6a017e435a96a6bcd (4640 commits) x86_64 hpack-0.17.0
08:40:04 <lyxia> qqwy: can you paste the output of "yesod devel -v"
08:42:16 <qqwy> https://pastebin.com/qhFcC4Kd
08:49:02 <sphinxo> floatRadix: a constant function, returning the radix of the representation (often 2)
08:49:10 <sphinxo> When/why might it not be 2?
08:49:23 <lyxia> qqwy: what shell are you using? it seems not to be interpreting these double quotes correctly.
08:51:26 <qqwy> I am using Bash, so that would be very strange
08:52:00 <lyxia> I don't know if that's the shell's job here actually
08:52:20 <lyxia> but if I remove these quotes I get the same error as you do
08:53:04 <lyxia> qqwy: can you try running that command yourself
08:53:07 <qqwy> If I run the raw command directly (with the quotes), I get the exact same error
08:53:35 <qqwy> except that output is colored (the 'devel-signal' message is in red) 
09:03:51 <lyxia> qqwy:   for i in "a b" ; do echo $i ; done     does this print "a b" on one line?
09:04:11 <qqwy> When run directly in Bash?
09:04:16 <lyxia> yeah
09:04:39 <monochrom> I think so.
09:04:40 <qqwy> Yes, it prints "a b" (without the quotes) on one line
09:08:11 <lyxia> so that seems to be stack not interpreting that argument correctly...?
09:11:07 <qqwy> Very strange
09:15:20 <monochrom> Ah, that could happen, stack may re-tokenize it.
09:15:57 <monochrom> Some cabal-install parameters are re-tokenized too (but well-documented and common expectation)
09:17:09 <mnoonan> sphinxo: https://en.wikipedia.org/wiki/Decimal32_floating-point_format
09:19:26 <lyxia> qqwy: can you try the    "/.../yesod devel-signal"   command?
09:19:39 <qqwy> On its own?
09:20:08 <lyxia> yeah
09:20:21 <qqwy> It quits instantly without doing anything
09:20:34 <qqwy> let me check the exit code...
09:21:28 <qqwy> Exit code `0`, so without failures. Still, wouldn't this be the thing that should keep running in the background?
09:22:37 <lyxia> I was trying to see whether stack actually parsed it correctly and the error came from that command which would somehow call stack again with "devel-signal", but that's not the case.
09:37:50 <quchen> phadej: ping
09:38:29 <quchen> phadej: Is there a specific lib using Bernardy’s algorithm that you use?
09:39:25 <phadej> the one o linked
09:39:35 <quchen> Prettiest?
09:40:13 <phadej> yes, though the package name is pretty-compact
09:40:39 <Hafydd> It could be more compact, IMO. http://i.imgur.com/MDCBTVL.jpg  
09:41:50 <quchen> Thanks
09:42:36 <monochrom> Indeed, "http://i.imgur.com/MDCBTVL.jpg" could be more compactly conveyed by a simple string "LOL".
09:42:50 <monochrom> And this is not an opinion. This is provable fact.
09:44:16 <quchen> monochrom: That would lose the compression artifacts of the original, so it’s lossily compactly conveyed.
09:44:38 <phadej> (and it's GPL and I use HEAD version)
09:44:46 <quchen> And since the original is lossily compacted, it would be lossily compactly conveying something lossily compacted.
09:44:48 <monochrom> heh
09:49:17 <mpickering> What does the stack command --no-nix do?
09:51:41 <qqwy> lets see...
09:52:08 <qqwy> It tells me 'Missing COMMAND|FILE', followed by the usage instructions
10:00:00 <Fuuzetsu> mpickering: it just disables nix; there's a nix section you can set up in your stack.yaml
10:00:12 <Fuuzetsu> https://github.com/commercialhaskell/stack/blob/master/doc/nix_integration.md
10:12:46 <codedmart> Anyone familiar with Persistent/Esqueleto? I have some json data in Postgres, and I started trying to add some of the json functions. Is it possible to cast a `Text` -> `Double`?
10:16:57 <zomg> one easy way to do that would be to `read` it, but frankly not sure if there's some better method of going from string to numeric values :)
10:18:11 <zomg> possibly better with stuff in Data.Text.Read
10:21:04 * hackagebot happstack-server 7.5.0 – Web related tools and services. – https://hackage.haskell.org/package/happstack-server
10:22:16 <codedmart> zomg: Would that work with Esqueleto?
10:22:38 <zomg> I'm not sure what that would have to do with it
10:25:03 <brisbin> i have an old package that for some reason i versioned "0.4", back before i really knew what i was doing. is that interpreted as 0.4.0 or 0.0.4? i would like to get onto an A.B.C version when releasing next, which is non-breaking, should i release as 0.4.1 or 0.0.5?
10:25:37 <Cale> brisbin: 0.4.0, I'm fairly sure
10:26:19 <brisbin> Cale: great thanks. that'd be my guess too
10:30:11 * hackagebot x509 1.7.0, x509-store 1.6.3, x509-system 1.6.5, x509-util 1.6.2, … and 1 more
10:30:12 * hackagebot  → https://hackage.haskell.org/packages/recent
10:31:00 <cocreature> mpickering: --no-nix is just the opposite of --nix. it can be useful if you have nix integration enabled via your stack.yaml but want to temporarely disable it
10:31:23 <mpickering> I see
10:35:15 * hackagebot friendly-time 0.4.1 – Print time information in friendly ways – https://hackage.haskell.org/package/friendly-time
10:37:54 <glguy> "I like you, the time is 10:20 A.M."
10:38:19 <qqwy> lyxia: Thank you for your help. I'll inquire about this issue on Yesod's repository
10:40:49 <cocreature> I’m disappointed that there is not unfriendly-time package
10:40:55 <cocreature> I guess I should be happy about that :)
10:42:17 <dolio> It's just called time.
10:42:36 <dedgrant_> sljackson-time
10:43:30 <cheater> hi
10:47:16 <cheater> i'm having trouble installing limp-cbc. i am using the git version (the hackage version has curiously a different, tighter dep on vector that messes up my build). when i do cabal install on my package (that depends on limp-cbc and refers to the git clone via cabal sandbox add-source) it complains about: "Missing C library: stdc++". however according to apt i have libstdc++-4.8-dev installed. i also ...
10:47:23 <cheater> ... tried doing cabal install --extra-include-dirs=/usr/include/c++/4.8/ but that hasn't worked either. how can i make this build work?
10:47:42 <WhereIsMySpoon> Hello, I'm trying to make a simple example of discord-hs work here https://github.com/Jarob22/discord-bot but I'm getting     Not in scope: type constructor or class `DiscordM'  when I run cabal build
10:49:40 <zomg> WhereIsMySpoon: did you import the correct module which exports DiscordM?
10:49:55 <WhereIsMySpoon> DiscordM is inside Types.hs
10:50:02 <WhereIsMySpoon> which is in Network/Discord
10:50:10 <WhereIsMySpoon> so i thought import Network.Discord.Types would work
10:50:28 <WhereIsMySpoon> https://github.com/jano017/Discord.hs
10:50:46 <zomg> if this is the package you're referring to, it doesn't seem to export it https://hackage.haskell.org/package/discord-types-0.2.2/docs/Network-Discord-Types.html
10:51:26 <WhereIsMySpoon> that and https://hackage.haskell.org/package/discord-hs
10:52:14 <WhereIsMySpoon> how am i supposed to get this example working then, zomg?
10:52:32 <WhereIsMySpoon> its the one on the front page of that github link
10:54:08 <zomg> there's an issue suggesting both the master and hackage versions are broken
10:54:24 <zomg> so hard to say what the intention was with the usage
10:54:39 <WhereIsMySpoon> oh
10:55:19 <zomg> if you check the examples dir, there are some other samples which don't use DiscordM
10:55:23 <zomg> perhaps one of those would work
10:55:45 <WhereIsMySpoon> ok, thanks
10:55:55 <WhereIsMySpoon> zomg: im quite new to haskell, what arethese things at the top of files in {}?
10:55:58 <WhereIsMySpoon> like this {-# LANGUAGE OverloadedStrings #-}
10:56:04 <zomg> language extensions
10:56:09 <cheater> according to this, cabal perhaps tries to create a small C program that depends on stdc++ and the C compiler complains about some other thing missing, but cabal thinks the compiler is complaining about stdc++. where can i find the program that cabal creates? https://mail.haskell.org/pipermail/cabal-devel/2010-March/006194.html
10:56:44 <WhereIsMySpoon> zomg: what's their equivalent in other langs?
10:57:10 <zomg> hard to say because the extensions are haskell specific :)
10:57:14 <exio4> WhereIsMySpoon: they change the language you are working with, can vary from changing the syntax to adding completely new capabilities 
10:57:17 <WhereIsMySpoon> i mean extensions in general
10:57:26 <geekosaur> gcc puts its extensions in special keywords wrapped in __ (e.g. __attribute__(pure) )
10:57:27 <Tuplanolla> Pragmas in C are close, WhereIsMySpoon.
10:57:37 <WhereIsMySpoon> i see
10:57:45 <exio4> WhereIsMySpoon: for example, strings "ABCD" in Haskell, by default, are of type String
10:58:20 <exio4> WhereIsMySpoon: with OverloadedStrings, they become polymorphic can be of type String, Text, ByteString, YourCoolStringType, etc (given they implement a typeclass/"interface")
10:59:10 <geekosaur> and python does the "from __future__ import ..." thing
10:59:23 <geekosaur> every language has its own weird way of specifying extensions
11:02:20 <monochrom> haha future
11:03:25 <monochrom> Although, the ByteString instance is a source of a lot of grief.
11:03:26 <cheater> if i do cabal install --extra-include-dirs, but actually it's a package my package depends on that requires those dirs, will that package be able to see those additional include dirs?
11:03:53 <exio4> monochrom: OverloadedStrings'? indeed, but it's still an example :p
11:05:02 <monochrom> Drawing inspiration from Monoid, Int, Sum, Product, maybe naked ByteString should not be an instance of OverloadedString to begin with.
11:06:00 <cocreature> I’d be fine with a partial instance which only accepts ascii because it’s just really convenient for specifying ascii constants
11:06:19 <exio4> monochrom: well, if naked ByteString isn't an instance, I would go as far as saying you shouldn't even have it - it loses the convenience
11:06:52 <monochrom> No, my https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html will save it. :)
11:07:40 <monochrom> Err wait, can't plug a proxy type near string literals, I guess.
11:07:55 <monochrom> Yeah, partial instance.
11:08:55 * hackagebot happstack-hsp 7.3.7.3, reform-happstack 0.2.5.2, web-routes-happstack 0.23.11, happstack-jmacro 7.0.12
11:08:56 * hackagebot  → https://hackage.haskell.org/packages/recent
11:15:51 * hackagebot consumers 2.0.0.1 – Concurrent PostgreSQL data consumers – https://hackage.haskell.org/package/consumers
11:16:02 <__monty__> I'm defining a bunch of predicates in where clauses, one of these predicates is used by two top-level functions. Is there a way to have this predicate shared between these functions without defining it in the top-level?
11:16:29 <monochrom> Unfortunately no.
11:16:51 <WhereIsMySpoon> import Pipes.Core ((+>>))
11:16:53 <WhereIsMySpoon> what does this mean
11:16:56 <WhereIsMySpoon> the ((+>>))
11:17:14 <dacto> WhereIsMySpoon: it is an operator
11:17:17 <Cale> That you're importing (+>>) and nothing else from that module
11:17:34 <monochrom> Actually yes, but you won't like it.  (f, g) = (\x -> h x + 1, \x -> h x - 1) where h x = x*x+2
11:17:48 <WhereIsMySpoon> I see
11:18:03 <Lokathor> do the three haskell backends have particuarly different speed benefits?
11:18:07 <Lokathor> or memory benefits?
11:18:32 <dacto> with hpack, how does one conditionally include a source module?
11:19:07 <cocreature> Lokathor: which backends are you referring to?
11:19:22 <Lokathor> the C--, LLVM, and native code gen backends
11:20:06 <cocreature> I’m not sure what the difference between C-- and the native code gen backend is supposed to be
11:20:12 <monochrom> SML has a syntax for multiple top-level things sharing local things. You would love it.
11:20:25 <cocreature> LLVM tends to be particularly good for numerics heavy code
11:20:41 <__monty__> monochrom: Would such a tuple definition be idiomatic haskell for somewhat complicated functions? I'm guessing no.
11:20:43 <monochrom> local  h x = x*x+2  in  f x = h x + 1; g x = h x - 1  end
11:20:47 <cocreature> but apart from only benchmarks can really tell
11:21:04 <monochrom> Right, not really common.
11:21:29 <monochrom> It gets even better, because local imports are allowed too.
11:21:46 <monochrom> local  open MyModule; h x = x*x+2  in  ...  end
11:21:57 <monochrom> (SML "open" = Haskell "import")
11:22:30 <__monty__> monochrom: Ok, thanks. Agda's solution is fairly similar, you could define the three functions in a module (files can contain nested modules) and then open the module to get the functions you want at top level.
11:23:30 * hackagebot happstack-server-tls 7.1.6.3, hpqtypes-extras 1.3.1.1, log-utils 0.2.2.1
11:23:30 * hackagebot  → https://hackage.haskell.org/packages/recent
11:23:58 <monochrom> Yeah, we need "one file multiple modules" in Haskell too.
11:24:36 <monochrom> Haskell 2010 already allows that. (Just no nesting.)
11:24:56 <monochrom> Or rather, "implementation-defined behaviour"
11:25:23 <monochrom> Haskell 2010 does not allow nesting. But it leaves open "how files and modules correspond is up to the compiler"
11:26:10 <monochrom> Probably doesn't even strictly require files. Could do the Smalltalk thing.
11:26:48 <monochrom> Yeah, wouldn't that be nice?
11:27:00 <Athas> A proper ML-style module system!
11:27:20 <__monty__> Backpack's a step in the right direction though, right?
11:27:26 <Athas> In many ways, it would be better if ML had won.  If only it were pure.  And was actually as nice to use as Haskell.
11:27:38 <Athas> Backpack is far more heavyweight.
11:27:47 <Athas> It solves some Haskell infrastructural issues, but that's more or less it.
11:27:59 <monochrom> I am beginning more and more skeptic about backpack. Every time I read it, it becomes less and less comprehensible.
11:28:42 <monochrom> It is a lot of steps towards a high-sophistication PhD thesis for sure.
11:29:24 <Athas> I don't intend to use Backpack directly, but if it means I can get a few more libraries, that's fine with me.
11:29:34 <Athas> (And also, if I don't have to maintain its implementation.  Looks complicated.)
11:29:58 <__monty__> Athas: I was thinking of ML Functors, backpack brings that to haskell, no?
11:30:18 <Athas> __monty__: yeah, but only at the package level, as far as I can see.
11:30:27 <cheater> can i force cabal and c2hs to keep build artefacts? (i mean the .c files written to /tmp)
11:30:31 <Athas> With a proper ML-style module system you use functors in a far more ad-hoc and localised way.
11:30:46 <ezyang> monochrom: What do you think the complicated bits are? 
11:30:54 <monochrom> ML would not be pure in the first place. ML was invented for coding up a proof assistant. The only idea of "need a pervasive database of known theorems" plays against purity.
11:31:15 <monochrom> (And Jim Moore's decades of experience supports it.)
11:31:35 <Athas> Oh sure, but you can make pure ML-like languages.
11:31:45 <__monty__> Like Agda : )
11:31:53 <monochrom> s/only/whole/
11:31:59 <cheater> mere
11:32:03 <Athas> Is Agda particularly ML-like?
11:32:48 <Athas> I'd say Agda is one of the relatively few functional languages derived from Haskell rather than ML (mostly based on how it "feels").
11:32:50 <monochrom> ezyang: I can't put my finger on it. But I'll just describe my feeling.
11:33:32 <__monty__> I'd agree, ML syntax looks somewhat clunkier. (No experience past reading a compiler book that used ML though.)
11:33:56 <monochrom> When I read about backpack, it's like I read darcs a while ago. A lot of theory without connection to the concrete instantiation of importing things or tracking versions.
11:34:56 * hackagebot happstack-authenticate 2.3.4.8 – Happstack Authentication Library – https://hackage.haskell.org/package/happstack-authenticate
11:35:19 <Athas> monochrom: that's interesting.  I get the opposite feeling: a pragmatic reduction of a fairly general and beautiful theory to solve some concrete and nasty infrastructural problems in Haskell.
11:35:30 <ezyang> So... not the blog posts you're referring to, then? :) 
11:35:55 <monochrom> I saw a few talk slides.
11:38:46 <ezyang> I think I've definitely been guilty of emphasizing theory in the Backpack talks I give 
11:39:04 <monochrom> Athas, if someone explicates the connection between theory and problem, that's great. This is an exposition issue, not an "is it right?" issue.
11:40:08 <Athas> The difference is possibly that I've implemented an ML-style module system myself, so I don't need any convincing about its inherent rightness!
11:40:40 <monochrom> For example I have no problem with QED because Feynman, for example, actually illustrates how to apply it to obtain the conclusion "mirror bounces back light at the same angle".
11:44:16 <monochrom> Actually when I said "a lot of theory" I did not mean that I saw a lot of theory.
11:44:36 <monochrom> I don't think I read the theory. I don't think I even saw it.
11:44:53 <monochrom> I saw assurance of "there is an interesting theory behind".
11:46:18 <monochrom> So, basically, a typical backpack talk is like: a vague glimpse of the theory behind, some actual code examples and a vague description of what it achieves and how/why Haskell 2010 can't achieve it.
11:46:42 <Athas> Actually, can't you make most of it with type classes?
11:47:23 <monochrom> At this point my difference from most programmers kicks in. I'm a scientist, I ask myself "how much predictive power do I have after this talk?" (Answer: 0.)
11:47:52 <monochrom> Most programmers are cookbookists. They are impressed because they now have those few slides of code to adapt from.
11:48:15 <monochrom> (When they can finally download an implementation of Backpack.)
11:49:07 <monochrom> Whereas Feynman's New Zealand QED talks actually give me predictive power.
11:49:59 <__monty__> monochrom: Are you applying haskell to QED?
11:50:18 <monochrom> Haha. But no.
11:52:20 <lyxia> what do you want to predict with backpack
11:52:49 <monochrom> First of all, what is legal syntax and what is illegal syntax?
11:53:18 <monochrom> If you show me candidate code, can I even predict whether it is legal backpack syntax or not?
11:53:55 <monochrom> Prediction is a prerequisite for problem solving.
11:54:34 <monochrom> (You are, at the very least, predicting that your candidation solution is a solution. Nevermind even how you came up with the candidate.)
11:56:04 <monochrom> Similarly, the way I articulate the problem with most monad blogs is that they give you 0 predictive power.
11:56:40 <Athas> I've never before heard this line of criticism for a language feature.
11:57:09 <lyxia> I see what you mean.
11:57:55 <monochrom> A typical monad blog rambles on about "monad models computation". It still gives you 0 predictive power because you can write a non-monad parser combinator library, then ask an average reader of that blog to guess whether your type is a monad, and they will likely erroneously say "yes".
11:58:18 <monochrom> So that shows you the blog gives the reader 0 predicative power.
11:58:54 <monochrom> If the reader can't even judge an existing piece of code correctly, nevermind writing their own code correctly.
11:59:21 <monochrom> Athas, I think it's criticism of exposition rather than language feature.
11:59:45 <monochrom> I am sure there exists an algorithm for parsing backpack syntax. I just haven't seen it.
12:00:21 <Athas> You think the exposition should have mentioned the grammar explicitly?
12:00:38 <monochrom> No, syntax is an example of what I mean by predictive power.
12:00:48 <Athas> I'm not sure we use the same notion of what "predictive power" is.  To me, what you want is more like "power of classification".
12:00:51 <monochrom> Syntax is also too easy. I want predictive power of semantics.
12:01:14 <monochrom> Oh, boolean classification is also just an example.
12:02:06 <monochrom> The computer scientist's diseases of "let's reduce all problems to decision problems for simplicity" I guess.
12:02:58 <monochrom> Look, if I can't even solve a few "simple" decision problems, nevermind synthesis or optimization.
12:03:49 <WhereIsMySpoon> is getAuth in Client in https://github.com/jano017/Discord.hs/blob/dev/src/Network/Discord/Types.hs not usable?
12:04:02 <Athas> Can you give an example of a piece of computer science literature that contains what you call "predictive power"?
12:04:07 <monochrom> I think the exposition should be like Feynman's talks. That's what I think.
12:05:08 <dacto> Anyone know how to exclude a source module from the build with hpack?
12:06:08 * hackagebot clckwrks 0.24.0.4, clckwrks-plugin-ircbot 0.6.17.3, clckwrks-plugin-mailinglist 0.3.0.2, clckwrks-plugin-media 0.6.16.4, … and 1 more
12:06:08 * hackagebot  → https://hackage.haskell.org/packages/recent
12:06:30 <monochrom> My own lecture slides when I teach a data structure course?
12:06:39 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCB63-2017-Summer/
12:07:39 <lyxia> WhereIsMySpoon: it looks like the active branch is rework, not dev
12:07:46 <ezyang> so, would it be accurate to say, that it is not a talk (30min advert for some work) you are looking for, but a lecture (1hr, perhaps in a series) 
12:08:19 <lyxia> WhereIsMySpoon: but in the version you were looking at, it is exported by that module
12:08:20 <WhereIsMySpoon> lyxia: ive just been installing it via cabal
12:08:31 <monochrom> I think yes.
12:08:39 <ezyang> yes, I have not written any Backpack lectures yet 
12:09:35 <lyxia> WhereIsMySpoon: which version did it install
12:09:41 <WhereIsMySpoon> lyxia: how do I know?
12:10:27 <WhereIsMySpoon> lyxia: as in how can I find out I mean
12:11:33 <WhereIsMySpoon> i assumed it was using https://hackage.haskell.org/package/discord-hs
12:12:44 <infandum> I know there are some alternative preludes. However, I'm always importing: import qualified Data.Vector as V; import qualified Data.Text as T; import qualified Data.Csv as CSV; etc. Is there a prelude which has these already exported, or is there a way I can "import MyPrelude" and have it so I can just do "V.take 3" without any other imports?
12:13:14 <geekosaur> no, there's no way for an import to use multiple namespaces
12:13:18 <cocreature> infandum: no the fact that you can’t reexport things under a qualified name is one of the annoyances with Haskell’s module system
12:14:14 <Athas> Does Backpack fix that?
12:14:18 <infandum> geekosaur, cocreature: So there is basically no way to have a prelude automatically brings in, say Data.List and Data.Vector?
12:14:20 <lyxia> WhereIsMySpoon: try "ghc-pkg list"
12:14:31 <infandum> drat
12:14:41 <WhereIsMySpoon> lyxia: discord-hs-0.4.2
12:14:44 <geekosaur> infandum, it cam bring in and re-export them, but they will be under whatever name you imported Prelude as
12:14:56 <geekosaur> it can't re-export as V.whatever
12:14:59 <cocreature> and it can’t bring in both since there are name collisions
12:15:02 <geekosaur> it would be Prelude.whatever
12:15:13 <ezyang> Athas: Nope :( 
12:15:25 <infandum> geekosaur: Man, that's the one thing holding it back from being a super easy language for quick calculations.
12:15:32 <infandum> for me at least
12:15:39 <lyxia> WhereIsMySpoon: https://github.com/jano017/Discord.hs/blob/dev/discord-hs.cabal here you see that the version on that branch is still 0.3.2
12:15:43 <infandum> I have more import lines than actual lines of code
12:16:07 <WhereIsMySpoon> rework is on 0.2.2
12:16:12 <WhereIsMySpoon> where did 0.4.2 come from
12:16:24 <geekosaur> you could then level up to edwardk and have more extension pragmas than imports :p
12:16:31 <lyxia> uhhh
12:16:33 <infandum> Like, parsing a csv is a one liner that involves Data.Csv, Data.Vector, Data.ByteString.Lazy, Data.Map (for me), and Data.Text. It's a bit much.
12:17:01 <WhereIsMySpoon> lyxia: so if I limited discord-hs to 0.2.2 id get the rework branch?
12:17:06 <cocreature> sometimes you can get away with just the unqualified types and use some kind of typeclass abstraction
12:17:27 <cocreature> especially for things like Text where at least for me I import it 95% just to use the type somewhere
12:17:34 <cocreature> and in that case custom preludes help
12:18:03 <monochrom> My current understand of backpack is at the level of: It's a generalization of how Data.ByteString and Data.List use the same names so I change "import Data.List" to "import Data.ByteString". (To be sure, I am not even sure I am right. See? Zero predictive power.)
12:18:04 <infandum> cocreature: Yeah, I noticed in the Turtle library you can at least just import Turtle and get Text as a type for free.
12:18:28 <cocreature> infandum: I use protolude which reexports Map, Text and a bunch of other things
12:18:52 <lyxia> WhereIsMySpoon: not sure what happened in this repo, but everything else in the rework branch is more recent than 2.2
12:19:01 <cocreature> and it has a handy typeclass for converting between strict and lazy string types which can often also remove one or two imports
12:19:23 <jackhill> l
12:20:21 <WhereIsMySpoon> lyxia: im not really sure what to do here..im quite new to haskell and i just wanted to get this base working and then add on some simple things myself
12:21:08 <lyxia> WhereIsMySpoon: I think the safest option is to install 0.3.2
12:21:14 <infandum> cocreature: As separate function names, right? I assume there is some overlap.
12:21:24 <monochrom> Oh! You can do this.
12:21:46 <cocreature> infandum: there is just a "toS" and a "toL" and then you get typeclass instances for Text, ByteString and String
12:21:52 <lyxia> WhereIsMySpoon: hmm actually it looks as if something was broken even then...
12:21:52 <infandum> cocreature: I also saw foundation which seems pretty popular, but it's so different that I would need to study it a whole bunch.
12:22:01 <cocreature> you can also use it to convert it between the two but I’m not too fond of that
12:22:04 <monochrom> import qualified MyPrelude(id, negate) as P
12:22:04 <WhereIsMySpoon> oh shit
12:22:11 <WhereIsMySpoon> i had discord-hs-0.2.1 in my stack.yaml
12:22:21 <monochrom> import qualified MyPrelude(not, maybe) as Q
12:22:33 <cocreature> foundation looked too much like a kitchen sink library that tries to solve everything the last time I looked at it
12:22:43 <Tuplanolla> How many members does the family of functions like `quotRem` and `divMod` actually have? It's somewhere in the vicinity of 3 and 16.
12:22:51 <infandum> monochrom: Then you would be back to importing everything again...
12:23:05 <monochrom> Yeah, true.
12:23:15 <infandum> cocreature: Yeah, so I have no idea how compatible it would be with other libraries.
12:23:16 <monochrom> Just in case someone finds it useful.
12:24:46 <infandum> cocreature: I know this isn't related whatsoever, but "hawk" has a custom prelude you can add to that takes everything, even "L.whatever" into account. However, that's a bit different as it's parsing haskell text...
12:24:47 <lyxia> WhereIsMySpoon: if you're using cabal the stack.yaml does nothing
12:24:58 <infandum> cocreature: but it's a taste of paradise
12:25:04 <WhereIsMySpoon> i have also been running stack commands
12:25:27 <WhereIsMySpoon> stack solver --update-config
12:25:28 <WhereIsMySpoon> this one
12:25:56 <cocreature> infandum: tbh since I’ve started using protolude it has become that much less of a pain that I don’t really care about it anymore
12:26:48 <infandum> cocreature: I was always too scared to use another prelude because I was worried about dependencies and compatibility
12:26:52 <lyxia> WhereIsMySpoon: that only fixes the stack.yaml file, which still does nothing if you're not using stack to build and install packages
12:26:55 <WhereIsMySpoon> holy fuck why does installing a cabal package take so long
12:27:09 <merijn> infandum: Alternative preludes are only really useful for applications
12:27:09 <WhereIsMySpoon> i dont have that many dependencies =/
12:27:19 <merijn> WhereIsMySpoon: Are you using -j?
12:27:25 <WhereIsMySpoon> whats that
12:27:34 <cocreature> merijn: as long as your custom prelude is mostly reexports it doesn’t really matter if you use it in libraries
12:27:35 <merijn> WhereIsMySpoon: Install stuff in parallel :)
12:27:39 <WhereIsMySpoon> nope
12:27:44 <cocreature> because there is literally no difference for users
12:27:50 <merijn> WhereIsMySpoon: That can help if you have enough processing power
12:27:57 <WhereIsMySpoon> i have lots of processing power
12:28:02 <WhereIsMySpoon> but its too late now
12:28:03 <WhereIsMySpoon> :P
12:28:04 <merijn> WhereIsMySpoon: Also, which packages are you depending on?
12:28:12 <WhereIsMySpoon> base >= 4.7 && < 5, discord-hs==0.3.2, text, pipes==4.3.*, discord-types, discord-gateway, url, discord-rest
12:29:31 <WhereIsMySpoon> ive been 'Building skylighting-0.1.1.5' for a while now o.O
12:29:39 <lyxia> WhereIsMySpoon: you only need discord-hs, which exports the other discord-*
12:29:58 <WhereIsMySpoon> lyxia: it told me the others were in private packages
12:30:31 <WhereIsMySpoon> and that i needed to include them
12:30:39 <lyxia> WhereIsMySpoon: discord-hs-0.4.2 exports the other discord-*. discord-0.3.2 didn't have those at all.
12:30:47 <WhereIsMySpoon> ah i see
12:30:48 <lyxia> it was all in one package
12:31:04 <WhereIsMySpoon> so i literally need base >= 4.7 && < 5, discord-hs==0.4.2
12:31:05 <WhereIsMySpoon> and thats it?
12:31:12 <WhereIsMySpoon> and text and url i guess
12:31:23 <WhereIsMySpoon> and pipes
12:31:30 <lyxia> and you don't need to run stack solver if that's all you do with stack.
12:32:27 <lyxia> The problem I'm seeing is that 0.4.2 hardly has any documentation compared to previous versions.
12:33:25 <WhereIsMySpoon> lyxia: hm, nope, if i dont put the other modules to import in there it says theyre in hidden packages
12:33:32 <WhereIsMySpoon> even with 0.4.2
12:33:54 <WhereIsMySpoon> i have   build-depends:       base >= 4.7 && < 5, discord-hs==0.4.2, text, pipes==4.3.*, url
12:34:17 <lyxia> WhereIsMySpoon: are you importing any module other than Network.Discord?
12:34:51 <WhereIsMySpoon> ah!
12:34:53 <WhereIsMySpoon> of course
12:34:57 <WhereIsMySpoon> lol
12:35:06 <WhereIsMySpoon> lyxia: ok now im back to the original problem of getAuth being private
12:38:48 <lyxia> WhereIsMySpoon: https://github.com/jano017/Discord.hs/blob/rework/discord-types/src/Network/Discord/Types.hs there is no getAuth in the new module, seems to have been replaced with auth.
12:39:57 <lyxia> WhereIsMySpoon: the big mess is that on hackage the rendered docs don't match the source http://hackage.haskell.org/package/discord-types-0.2.2/docs/Network-Discord-Types.html
12:40:23 <WhereIsMySpoon> should i try and find a different discord lib? :P
12:41:02 <WhereIsMySpoon> this one seems to have a lot of features..its just kinda broken
12:41:08 <WhereIsMySpoon> auth doesnt work either
12:41:16 <WhereIsMySpoon> i really wonder what 0.4.2 contains
12:42:55 <lyxia> What do you mean "doesn't work"? Does the identifier not exist?
12:43:11 <WhereIsMySpoon> same error
12:43:20 <WhereIsMySpoon> auth is not a (visible) member of class Client
12:44:35 <lyxia> the class is no longer called Client but DiscordAuth
12:44:50 <WhereIsMySpoon> gah
12:45:56 <lyxia> https://github.com/jano017/Discord.hs/tree/fafc054efa45b6fb76256292bc2880bb93803ab2/examples examples updated 1 month ago (probably up to date) use DiscordAuth, 5 months ago use Client.
12:48:14 <monochrom> I think -j is the default.
12:48:22 <monochrom> (cabal-install)
12:53:15 <WhereIsMySpoon> woo i got it running
12:53:18 <WhereIsMySpoon> thank you lyxia
12:53:22 <WhereIsMySpoon> you're the best
12:54:48 <lyxia> yay
13:02:37 <k0ral> Hello, would you know of code examples using the zippers package ? Right now I'm rolling my own implementation of a tree zipper and I'm wondering whether I should switch to this package instead
13:07:32 <lyxia> k0ral: the github repo has one
13:07:43 <xenog> I have a function of type ((msg -> Bool) -> m msg). I would like to pass as a function something that will only be true if the structure of a thing matches certain pattern, but without having to create a helper function for it.
13:08:10 <glguy> The zipper package is quite challenging to use on recursive types (like a tree structure) for anything very interesting
13:08:33 <xenog> Something like (\x -> case x of Something _ -> True; _ -> False), but shorter.
13:08:54 <ReinH> Shorter? Well, there's LambdaCase.
13:08:57 <xenog> Is there some magic that I can enable in GHC for that?
13:09:15 <xenog> ReinH, that may be just what I need.
13:09:21 <ReinH> That's about it.
13:09:45 <xenog> That's a step in the right direction.
13:09:51 <k0ral> I should have specified "and that isn't written by ekmett" at the end of my question :)
13:10:05 <glguy> k0ral: You should delay playing with the zipper package until you consider yourself an expert with lenses, and they possibly delay anyway
13:10:12 <xenog> (\case { Something _ -> True; _ -> False) is an improvement.
13:10:51 <xenog> Can that particular expression be made even shorter? is there something I could use with a case expression that would take a non-matching element as False when expecting a boolean?
13:11:04 <lyxia> k0ral: https://github.com/search?utf8=✓&q="Control.Zipper"+language%3Ahaskell&type=Code there are a few users of that package here.
13:11:23 <lyxia> (ignore the Control.Zipper.Simple ones)
13:12:16 <xenog> Ideally it would look like (Something x) with minimal syntax around.
13:14:32 <ReinH> xenog: I can't think of anything. You can write a combinator something (Something _) t f = t; something _ = f and use something True False, but that just moves the pattern matching around.
13:14:47 <ReinH> Pattern matching is the fundamental thing here. It has to be done somewhere.
13:15:11 <ReinH> er, something t f (Something _) and something t f _
13:15:29 <lyxia> is _Something   if you have a prism lying around.
13:15:52 <ReinH> True.
13:15:53 <glguy> You'd need to import Control.Lens.Extras to get 'is', but 'has' will work the same and is in Control.Lens
13:15:54 <xenog> Exactly. taht's the problem that I have. I am passing a pure matcher to a function that will return a monadic value that depends on the match being successful inside a computation with side effects.
13:16:04 <lyxia> but it's a lot of overhead compared to simply defining a isSomething function
13:16:26 <xenog> Hmm. Kmett's library.
13:16:34 <ReinH> I don't see why you're trying to hard to avoid pattern matching.
13:16:39 <ReinH> Pattern matching is normal.
13:16:44 <k0ral> glguy: your suggestion is pretty vague and unhelpful, how am I to know when I reach the "expert" rank ? (is that a you'll-know-it-when-it-happens thing ?) Could you provide specific topics (and associated material) I should dig into first ?
13:16:51 <xenog> I'm not trying to avoid pattern matching, I'm trying to make it shorter.
13:17:19 <lyxia> Define a custom isSomething once and for all.
13:17:24 <glguy> k0ral: If you have to ask how to use it you aren't ready, is the idea. It should be pretty obvious how to use zippers if you understand lenses well enough
13:17:24 <ReinH> That's as short as you can get with pattern matching.
13:17:30 <ReinH> There are no other available pattern matching syntaxes.
13:17:37 <glguy> k0ral: and the package itself is not generally useful
13:17:44 <xenog> Yeah, that's what I do. Whenever I need to match I have an isSomething function defined that I can pass.
13:17:50 <ReinH> You can give your pattern matching function a name and then use the name.
13:17:54 <ReinH> like isSomething.
13:18:12 <xenog> I would love a language extension that would make these tests against the structure of something to be easier to make.
13:18:52 <xenog> Specifically for boolean tests. I give it a pattern and it spits True only if the pattern matches, False otherwise.
13:18:53 <lyxia> With Generics you could match on the constructor by writing it at the type level.
13:19:07 <lyxia> matches @"Something"
13:19:48 <xenog> I should look at Generics then.
13:19:50 <lyxia> Is there a Generics package with all these tricks
13:20:24 <lyxia> I often say "with Generics you could" but it's still a lot of work to actually do it
13:20:37 <glguy> xenog: You should learn Generics because it's useful in general. You should not use Generics to solve this particular problem, even if you eventually could
13:21:11 <xenog> Yeah, I guess it is not going to get any better than lambda cases.
13:21:25 <xenog> \case Something _ -> True; _ -> False
13:21:27 <xenog> It is ugly though.
13:22:11 <xenog> Especially since I have to use the constructor again during destructuring of the resulting monadic action.
13:22:39 <glguy> xenog: Then don't construct the Bool at all, just use the value and use it
13:22:43 <xenog> Just x <- operation (\case Just _ -> True; Nothing -> False)
13:23:17 <MarcelineVQ> :t isJust
13:23:19 <lambdabot> Maybe a -> Bool
13:23:27 <xenog> That's the thing, in this case `operation` would have a signature like `operation :: (a -> Bool) -> m a`.
13:23:33 <ReinH> Using generics so you don't have to write \case Something _ -> True; _ -> False is cutting off your nose to spite your face.
13:23:44 <glguy> xenog: If you find yourself writing that, then change the definition off 'operation' not to need that
13:23:46 <xenog> My use of a Maybe in that particular example is just illustrative.
13:24:07 <glguy> xenog: for example change it to,  operation :: (a -> Maybe b) -> m b
13:24:55 <xenog> glguy, `operation` really needs to act on any `a` and return that `a` if it passes a pure arbitrary matching function.
13:25:27 <glguy> xenog: It sounds like you know what constructor the result will use if the predicate matches
13:25:46 <xenog> It can be either a test on the specific value of `a`, which is easy: (==value), or on the structure of `a`, which is hard: `\case Something _ -> True; _ -> False`.
13:25:47 <glguy> so encode that information in the argument of operation
13:25:49 <ReinH> You could define a combinator something (Something a) = Just a; something _ = Nothing, which carries with it a witness of what a was, rather than forgetting about it. You could also write a more final combinator like withSomething something nothing (Something a) = something a; withSomething _ = nothing. I would just write a case statement though.
13:26:02 <glguy> xenog: What I wrote will handle that
13:26:48 <glguy> xenog: opertion (\x -> if x == Value then Just x else Nothing); -- or -- operation (\x -> case x of Something y -> Just y; _ -> Nothing)
13:26:49 <xenog> glguy, yeah, sometimes I will know the constructor.
13:26:57 <ReinH> Those two combinators are isomorphic, but one is more initial and one is more final. None of this helps answer your questino, but it is vaguely interesting (to me).
13:27:00 <ReinH> question*
13:27:17 <glguy> xenog: See how this new version of operation handles both cases?
13:27:45 <xenog> glguy, I should probably do that, yes.
13:28:05 <xenog> That will at least allow me to deconstruct during the match, and not having to repeat the deconstruction later.
13:28:07 <xenog> Great idea.
13:28:22 <xenog> I'll do it.
13:28:40 <xenog> And with lambda case to avoid that `\x -> case x of` chunk.
13:29:04 <xenog> I'm never disappointed when I come to look for answers here.
13:29:26 <xenog> Thanks!
13:29:35 <trigone> what's lambda case?
13:30:15 <ReinH> @google haskell lambda case
13:30:16 <lambdabot> https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/syntax-extns.html
13:30:29 <glguy> ReinH: Don't give away the secret!
13:30:33 <xenog> trigone, kind of cool, I just learned about it: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lambda-case
13:30:57 <ReinH> glguy: teach a man to fish eh
13:31:12 <xenog> trigone, essentially shorten `\x -> case x of` to `\case`.
13:31:14 <trigone> xenog: thx that's quite nice!
13:33:30 <trigone> you can put guards after case branches in vanilla haskell?
13:34:07 <trigone> case x of { a | test -> b ; ... } ?
13:34:22 <lyxia> yes
13:34:34 <trigone> i didn't know, that's nice
13:35:00 <lyxia> > case False of b | not b -> b
13:35:02 <lambdabot>  False
13:35:16 <xenog> I didn't know that either.
13:35:24 <xenog> Time to code.
13:35:57 <trigone> lyxia: thx
13:36:18 <lyxia> trigone: yw
13:36:30 <trigone> how can i factorize something like (g <$> f a <*> f b <*> f c ...), so i don't have to repeat f every time?
13:39:03 <trigone> :t liftA3
13:39:04 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
13:39:09 <lyxia> what's the type of these things
13:39:18 <ReinH> Lift fmap and ap again.
13:39:42 <lyxia> do a,b,c,... have the same type
13:40:05 <trigone> lyxia: yes
13:40:09 <trigone> ReinH: i don't get what you mean
13:40:45 <ReinH> :t liftA3 . LiftA3
13:40:46 <lambdabot> error:
13:40:46 <lambdabot>     • Data constructor not in scope: LiftA3 :: a1 -> a -> b -> c -> d
13:40:46 <lambdabot>     • Perhaps you meant one of these:
13:40:47 <lyxia> do [a,b,c,d] <- mapM f [a,b,c,d] ; return (g a b c d)   ?
13:41:00 <ReinH> Thanks autocorrect
13:41:23 <ReinH> :t liftA3 . liftA3
13:41:25 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c -> d) -> f1 (f a) -> f1 (f b) -> f1 (f c) -> f1 (f d)
13:41:37 <ReinH> One of those can be ((->) r)
13:42:55 <trigone> lyxia: it's a bit verbose...
13:43:13 <trigone> ReinH: can i not use <$>/<*> instead of lift?
13:43:16 <lyxia> trigone: right it's not as good as I thought
13:43:47 <ReinH> You need to lift <$> and <*>.
13:44:05 <ReinH> Which you can do, but liftA3 is more convenient to demonstrate.
13:44:20 <ReinH> You can also use Compose.
13:44:59 <lamefun> What's the best solution to this module dilemma? http://lpaste.net/2546856129820884992
13:47:17 <trigone> ReinH: hm... it's a bit complicated...
13:47:19 <trigone> :t Compose
13:47:21 <lambdabot> error:
13:47:21 <lambdabot>     • Data constructor not in scope: Compose
13:47:21 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
13:47:44 <trigone> :t Data.Functor.Compose.Compose
13:47:45 <lambdabot> forall k k1 (a :: k) (g :: k -> k1) (f :: k1 -> *). f (g a) -> Data.Functor.Compose.Compose f g a
13:48:45 * hackagebot propellor 4.5.0 – property-based host configuration management in haskell – https://hackage.haskell.org/package/propellor
13:49:18 <trigone> :t liftA2 . liftA2
13:49:20 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f1 (f a) -> f1 (f b) -> f1 (f c)
13:49:45 <pavonia> lamefun: I prefer variant 1
13:51:44 <trigone> :t (liftA2 . liftA2) (:) 
13:51:46 <lambdabot> (Applicative f, Applicative f1) => f1 (f a) -> f1 (f [a]) -> f1 (f [a])
13:54:02 <merijn> Anyone aware of a globbing library? Preferably one with minimal dependencies
13:58:12 <lamefun> pavonia: I don't know... Stack apparently chose Variant 2 and it's made by experienced developers... so variant 1 could possibly get really really annoying as more modules are added.
13:58:47 <lyxia> :t \g f a b c -> (liftA2 . liftA2) g ($ a) ($ b) ($ c) f
13:58:48 <lambdabot> (a1 -> a1 -> t1) -> t -> (a -> t -> a1) -> (a -> t -> a1) -> a -> t1
13:59:11 <lyxia> :t \g f a b c -> (liftA3 . liftA3) g ($ a) ($ b) ($ c) f
13:59:13 <lambdabot> Applicative f => (a1 -> a1 -> a1 -> d) -> (a -> f a1) -> a -> a -> a -> f d
14:00:08 <trigone> lyxia: hey thanks, i was scratching my head on this one :)
14:01:26 <trigone> in the end though i'm not really sure we gain in terseness ^^ is there a bot command to find if a specific function already exist?
14:01:32 <lyxia> I guess it's shorter if f is actually a long name
14:02:05 <lyxia> but you might as well write   let f = longName in ...
14:02:06 <trigone> lyxia: i could always use an alias, even if it's a bit confusing
14:02:12 <lyxia> heh
14:02:33 <trigone> :t \g f a b c = liftA3 g (f a) (f b) (f c)
14:02:35 <lambdabot> error:
14:02:35 <lambdabot>     parse error on input ‘=’
14:02:35 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
14:02:42 <trigone> :t \g f a b c -> liftA3 g (f a) (f b) (f c)
14:02:44 <lambdabot> Applicative f => (c -> c -> c -> d) -> (t -> f c) -> t -> t -> t -> f d
14:04:18 <trigone> where can if find all the commands of the lambdabot?
14:05:02 <trigone> :t \g f a b c -> (liftA2 . liftA2) g a b c (f $)
14:05:03 <lambdabot> (a1 -> b1 -> t1) -> (a -> b) -> (t -> (a -> b) -> a1) -> (t -> (a -> b) -> b1) -> t -> t1
14:05:25 <trigone> :t \g f a b c -> (liftA3 . liftA3) g a b c (f $)
14:05:27 <lambdabot> Applicative f => (a1 -> b1 -> c -> d) -> (a -> b) -> ((a -> b) -> f a1) -> ((a -> b) -> f b1) -> ((a -> b) -> f c) -> f d
14:05:43 <geekosaur> @list
14:05:43 <lambdabot> What module?  Try @listmodules for some ideas.
14:05:43 <MarcelineVQ> you can import Control.Applicative in ghci if you want to play with the liftA's
14:05:55 <trigone> @listmodules
14:05:55 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
14:05:55 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
14:06:01 <geekosaur> right, lambdabot's own help is kinda useless :/
14:06:11 <MarcelineVQ> @bot
14:06:11 <lambdabot> :)
14:06:26 <trigone> lol
14:06:31 <trigone> @bot 3
14:06:31 <lambdabot> :)
14:06:58 <trigone> @unlambda \g f a b c -> liftA3 g (f a) (f b) (f c)
14:06:58 <lambdabot>   unlambda: Unknown operator '\\'
14:06:58 <lambdabot>   CallStack (from HasCallStack):
14:06:58 <lambdabot>     error, called at Main.hs:45:38 in main:Main
14:07:03 <trigone> @unlambda g f a b c -> liftA3 g (f a) (f b) (f c)
14:07:04 <lambdabot>   unlambda: Unknown operator 'g'
14:07:04 <lambdabot>   CallStack (from HasCallStack):
14:07:04 <lambdabot>     error, called at Main.hs:45:38 in main:Main
14:07:17 <trigone> @help unlambda
14:07:17 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
14:08:03 <trigone> is there a command that gives an implementation of a lambda in terms of pre-existing functions?
14:08:35 <hexagoxel> pointfree perhaps
14:09:05 <hexagoxel> @pl \g f a b c -> liftA3 g (f a) (f b) (f c)
14:09:05 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.) . liftA3
14:09:49 <c_wraith> hmm. 
14:10:06 <c_wraith> @pl f g = g f
14:10:06 <lambdabot> f = fix (flip id)
14:10:37 <c_wraith> that would be correct if the expression type checked in the first place.. 
14:10:47 <MarcelineVQ> exferencebot can do this, it's not online atm
14:11:00 <millew> I am trying to import a module, where exactly do I need to save the file?
14:11:25 <c_wraith> still, it's amusing that @pl can be tricked into deriving hyperfunctions by just pretending they type check. 
14:11:35 <hexagoxel> eh yeah sorry about exferencebot. the server it was running on currently .. does not boot (oops)
14:12:50 <monochrom> millew: There are many options (non-defaults require command-line arguments). The simplest default is "the same directory".
14:12:56 <trigone> > let x = (\g f a b c -> (liftA3 . liftA3) g a b c (f $)) (,,) (+1) 3 4 5 in (x :: Maybe (Int, Int, Int))
14:12:58 <lambdabot>  error:
14:12:58 <lambdabot>      • Could not deduce (Num b0)
14:12:58 <lambdabot>        from the context: (Num ((b -> b) -> f c),
14:13:15 <c_wraith> millew, it's important that the filename match the module name, though. 
14:13:26 <trigone> MarcelineVQ: when is it online?
14:13:40 <monochrom> Yeah, if something doesn't work, tell us everything.
14:13:41 <trigone> :t (,,)
14:13:42 <lambdabot> a -> b -> c -> (a, b, c)
14:13:54 <millew> monochrom, c_wraith, the filename does match, I am just unsure of where to find the directoy
14:14:34 <trigone> > let x = (\g f a b c -> (liftA3 . liftA3) g a b c (f $)) (,,) (+1) 3 4 5 in x
14:14:36 <lambdabot>  error:
14:14:36 <lambdabot>      • Could not deduce (Num b0)
14:14:36 <lambdabot>        from the context: (Num ((b -> b) -> f c),
14:16:17 <geekosaur> hexagonel, around?
14:16:38 <geekosaur> oh, soory, found it in log
14:16:40 <geekosaur> 2017 Jul 21 21:11:14 <hexagoxel>	eh yeah sorry about exferencebot. the server it was running on currently .. does not boot (oops)
14:16:57 <geekosaur> so it may be a while before it comes back
14:17:46 <geekosaur> but you can install it locally: https://github.com/lspitzner/exference/
14:17:57 <geekosaur> trigone ^
14:18:57 <trigone> geekosaur: ok, thx, maybe i'll do that.. anyway the lambda doesn't seem to work as i thought
14:21:23 <trigone> @pl \g f a b c -> (liftA3 . liftA3) g ($ a) ($ b) ($ c) f
14:21:24 <lambdabot> flip . ((flip . (flip .)) .) . flip flip (flip id) . ((flip . ((.) .)) .) . flip flip (flip id) . ((.) .) . (. flip id) . liftA3 . liftA3
14:22:59 <trigone> poinfree's purity echoes brainf*ck admirably
14:24:34 <geekosaur> well, part of it is @pl implementation predates applicative
14:24:49 <trigone> :t \g f a b c -> g (f a) (f b) (f c)
14:24:50 <lambdabot> (t2 -> t2 -> t2 -> t1) -> (t -> t2) -> t -> t -> t -> t1
14:25:08 <trigone> @hoogle (t2 -> t2 -> t2 -> t1) -> (t -> t2) -> t -> t -> t -> t1
14:25:08 <lambdabot> Data.Composition (.:.) :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
14:25:09 <lambdabot> Data.Composition (.**) :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
14:25:09 <lambdabot> Data.Composition compose3 :: (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
14:25:16 <geekosaur> it can "do" Applicative but it has to go through Monad to do it (fmap and `ap`)
14:26:41 <trigone> geekosaur: but... ap is applicative before being monad, right? or you mean ap is first defined in terms of bind/return?
14:27:04 <MarcelineVQ> ap isn't quite <*>
14:27:06 <trigone> geekosaur: and i thought it always found the most compact way regardless of the substitution order...
14:27:16 <trigone> :t ap
14:27:18 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:27:23 <trigone> :t (<*>)
14:27:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:27:41 <trigone> MarcelineVQ: aside from the constraints, what's different?
14:27:42 <geekosaur> it doesn't alweays find the most compact way. it uses substitution rules that don't cover all cases (and occasionally are incorrect when using them at particular types)
14:27:49 <trigone> geekosaur: ok...
14:27:59 <geekosaur> and more to the point, it does not *recognize* when it can use Applicative, only when it can use Monad
14:28:25 <geekosaur> so it misses quite a few possible simplifications
14:28:27 <trigone> geekosaur: k, that's the story of Applicative's life
14:29:28 <trigone> why is there three functions with the same signature and probably the same implementation in Data.Composition?
14:29:41 <trigone> @src Data.Composition.(.:.)
14:29:41 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:29:52 <trigone> @src Data.Composition.compose3
14:29:52 <lambdabot> Source not found. Abort, Retry, Panic?
14:29:56 <trigone> Panic
14:30:07 <trigone> @src Data.Composition compose3
14:30:08 <lambdabot> Source not found. You speak an infinite deal of nothing.
14:30:37 <geekosaur> the @src database is static text of a subset of Prelude-related things, not a general facility
14:30:46 <MarcelineVQ> ask lambdabot privately if it's not working out :>  in this case though src is just a file someone put together so it's not comprehensive or updated much
14:31:02 <trigone> geekosaur: is there something better?
14:31:10 <geekosaur> @where hayoo
14:31:10 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
14:31:13 <trigone> MarcelineVQ: what do you mean ask privately lambdabot?
14:31:33 <geekosaur> /query lambdabot
14:31:39 <MarcelineVQ> trigone: should google how to use your irc client, /msg lambdabot  or  /query lambdabot
14:32:04 <geekosaur> usually you'll get a new tab which is in direct communication with lambdabot instead of being public in the channel
14:32:05 <MarcelineVQ> Should get a client actually, webchat is rough
14:32:11 <millew> When you import a homemade module can you import it along with prelude, or do you need to import it from inside another file(.hs)
14:32:58 <millew> I had the same problem as https://stackoverflow.com/questions/31732605/how-can-i-import-a-haskell-module-in-ghci and it works if I do import foo in another script
14:33:01 <trigone> MarcelineVQ: yeah it's in my todo list :)
14:33:07 <MarcelineVQ> :D
14:33:56 <trigone> actually, /query lambdabot works well
14:34:14 <geekosaur> yeh, freenode webchat is one of the more minimal ones but it does handle /query
14:34:40 <trigone> thx all for eth :)
14:35:19 <MarcelineVQ> geekosaur: though it will, for some reason in <current year>, truncate messages that are too long without (I think) telling you
14:36:13 <geekosaur> yeh. not the greatest of interfaces. might want to use irccloud.com instead
14:36:37 <geekosaur> or one of the other services that has an irc gateway, e.g. matrix.org
14:36:53 <trigone> what's irc gateway?
14:37:38 <geekosaur> matrix.org is not an irc client, but it can communicate with specific channels on specific irc networks
14:38:19 <geekosaur> if you have a list of the users in here, you'll notice a number of them have "[m]" at the end of their nicks --- they're actually on matrix.org
14:40:39 <trigone> geekosaur: ok...
14:41:42 <trigone> i'm looking at some results from hoogle, am i right to think that the following signatures match completely different functions?
14:42:07 <trigone> (a -> a -> a -> b) -> (t -> a) -> t -> t -> t -> b
14:42:17 <trigone> and (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e
14:42:55 <boj> well, the argument list order is different, so sure
14:43:50 <trigone> boj: no, i mean the former transforms 3x t into a then returns the result of (a a a -> b), the latter applies (a b c -> d) then the result to (d -> e) and return
14:45:07 <trigone> :t \f g a b c = f (g a b c)
14:45:08 <lambdabot> error:
14:45:08 <lambdabot>     parse error on input ‘=’
14:45:08 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
14:45:13 <trigone> :t \f g a b c =q-> f (g a b c)
14:45:14 <lambdabot> error:
14:45:14 <lambdabot>     parse error on input ‘=’
14:45:14 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
14:45:17 <trigone> :t \f g a b c -> f (g a b c)
14:45:19 <lambdabot> (t4 -> t3) -> (t2 -> t1 -> t -> t4) -> t2 -> t1 -> t -> t3
14:46:04 <trigone> why the choice of numbering type variables when there's less than 26 of them?
14:46:23 <trigone> s/when/even when/
14:46:38 <boj> because in the case of (a -> b -> c) they can be different types, but (a -> a -> a) must be the same type
14:47:11 <trigone> boj: what? i meant using t2, t3 instead of u, v ...
14:47:33 <boj> i was trying to answer your previous question
14:47:36 <Peaker> trigone, I think it's because ghc is trying to preserve the original choice as a prefix
14:47:53 <Peaker> trigone, so if it was "a" in a user-provided signature, it'll be "a1", "a2", "a3" in instantiations
14:48:15 <trigone> Peaker: that's a bit hard to read though, but i see the idea...
14:48:50 <trigone> :t \f g a b c = f (g a) (g b) (g c)
14:48:52 <lambdabot> error:
14:48:52 <lambdabot>     parse error on input ‘=’
14:48:52 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
14:48:57 <trigone> :t \f g a b c -> f (g a) (g b) (g c)
14:48:59 <lambdabot> (t2 -> t2 -> t2 -> t1) -> (t -> t2) -> t -> t -> t -> t1
14:49:09 <Peaker> and "t" is for ghc-invented type vars
14:49:15 <trigone> :t \f g a b c -> f (g a b c)
14:49:16 <lambdabot> (t4 -> t3) -> (t2 -> t1 -> t -> t4) -> t2 -> t1 -> t -> t3
14:49:46 <trigone> Peaker: yeah i gathered :) still is harder to read than following the alphabet...
14:50:16 <Peaker> perhaps. nicer than greek letters tho :)
14:50:59 <trigone> Peaker: why? it'd be cool. hard to use in case of copy pasting, but otherwise i find it esthetical
14:51:19 <boj> trigone: you rarely care about this except when ghc dumps errors
14:51:30 <trigone> boj: yeah, cuz that never happens :P
14:52:01 <boj> hmm, i suppose this is what people mean about haskell errors being hard to parse then :p
14:53:13 <trigone> boj: no, but i don't think it helps. the one thing that should be broadcast is "read the errors from bottom to top". at least in my case, nearly always, the original error is at the end...
14:53:35 <Peaker> trigone, just more to learn for miniscule benefit. We can compose letters to get exponential space but instead we memorize dozens more symbols for linearly more space?
14:53:49 <trigone> but maybe it's related to how i organize my code
14:53:52 <Peaker> trigone, for me reading greek letters is much much harder
14:53:55 <boj> i think i saw a trick the other day to swap the error output order
14:54:03 <trigone> Peaker: what?
14:54:17 <trigone> boj: so it's not just me, it's usually how it works?
14:54:23 <Peaker> reading anything about Type Theory is a chore because of all the greek letters :(
14:54:37 <trigone> boj: mind you it's not big of a deal, you just need to know it
14:54:57 <boj> trigone: yeah, you just need to know it
14:55:06 <trigone> Peaker: hm... well it depends how familiar you are to the symbols...
14:55:49 <Peaker> trigone, yes. and adding increasingly unfamiliar symbols to the alphabet increases expressiveness by very little compared to allowing compositions of letters
14:56:01 <Peaker> "env" instead of the letter "gamma", for example
14:56:13 <Peaker> and makes everything less familiar/readable to many
14:56:45 <monochrom> Not to mention that in Haskell Γ doesn't fly very well. (Constructor/Type name, not var name.)
14:56:50 <Peaker> I guess composition is expensive when you usually do it on paper - and I guess people actually do type theory on paper
14:56:50 <trigone> Peaker: hm, yeah but sometimes i get confused because abbreviations don't mean what i expect, and are harder to read if there are several very similar like env, exp, erp, etc
14:57:11 <monochrom> Oh heh
14:57:15 <trigone> monochrom: fly?
14:57:17 <boj> i've seen some libraries control those names using constraints. i.e. Num number => number -> number -> number - this tends to make the errors more readable
14:57:36 <Tuplanolla> To answer my own question from a few hours ago: there is an infinite number of members, but only five of them are sensible.
14:57:59 <Tuplanolla> I wonder why Haskell as only two: `quotRem` and `divMod`.
14:58:01 <trigone> boj: yeah... but unless you explicitly put types everywhere i think you'll end up with at least some non-custom variables
14:58:22 <monochrom> Sometimes "fly" means "work".
14:58:33 <trigone> monochrom: well, yeah, in the case of planes
14:58:37 <trigone> monochrom: or superman
14:58:49 <monochrom> "Your proposal is not going to fly."
14:58:56 <trigone> monochrom: and why not use little gamma?
14:59:29 <monochrom> No one expects γ to stand for the environment :)
14:59:29 <trigone> monochrom: "your crepe is not going to fly."
15:00:05 <monochrom> People probably expects it to be a type variable actually.
15:00:13 <trigone> monochrom: well i don't expect big gamma to stand for it either! plus i bet there are some "lower case tiny uppercase" characters which would work somewhere in the unicode jungle
15:00:22 <trigone> monochrom: but i won't use it tho
15:00:32 <monochrom> Well, I mean the majority of academic papers.
15:01:14 <monochrom> I respect that Bayesianly speaking, if you haven't seen them, all possibilities have equal probability.
15:01:24 <trigone> monochrom: ok :) yeah, haskell is not 100% flexible but there are great advantages in lower/uppercase differences
15:01:52 <trigone> monochrom: and you could just add a dummy letter before the uppercase, like eΓ
15:02:04 <monochrom> Ah yes
15:02:34 <trigone> monochrom:  your respect is greatly appreciated :)
15:04:50 <trigone> gottago thanks for the musing and funning
15:10:22 <sepakorayl> hello everyone. I have a function that returns a Maybe value inside a Writer monad (but which does not require exception capabilities). Now depending on some conditions I want to be able to return a wrapped Nothing while skipping the rest of the computations. Does this sound as a good usecase for ContT ?
15:13:39 <monochrom> No. This sounds like you require exception capabilities afterall.
15:14:04 <sepakorayl> I don't want the exception to propagate however
15:14:37 <sepakorayl> i just want an explicit Maybe value.
15:26:36 <hexagoxel> monochrom: you'd say that MaybeT has exception capabilities?
15:27:10 <monochrom> Yes.
15:28:05 <jakehehrlich> Nothing is basically "throw an exception with no extra information"
15:29:01 <hexagoxel> (sounds like a easy source of misunderstanding, not that we can resolve it now that they are gone..)
15:29:32 <monochrom> I don't think they misunderstood that part.
15:30:11 <monochrom> Instead, they refused to acknowledge that "skip the rest" is equivalent to "propagate the exception/Nothing"
15:30:44 <hexagoxel> did they `throw` Nothing?
15:31:10 <monochrom> When a boolean condition is satisfied, they will.
15:31:27 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml
15:32:27 * hackagebot websockets-snap 0.10.2.3 – Snap integration for the websockets library – https://hackage.haskell.org/package/websockets-snap
15:36:26 <trigone> is the free monad used to represent arbitrary monadic code that can be folded later with the appropriate monadic functions (bind, return)?
15:36:52 <trigone> and is there a use of it as an applicative functor?
15:48:12 * hackagebot threepenny-gui 0.8.0.1 – GUI framework that uses the web browser as a display. – https://hackage.haskell.org/package/threepenny-gui
16:12:35 <prooftechnique> So I'm trying to write a record type for a JSON response from this API, but the top level object contains members called "data" and "type", which I can't use in field names. Is there a way to work around this so I can just get automatic To/FromJSON instances, or does this leave me writing them by hand?
16:13:10 <prooftechnique> *API endpoint
16:14:13 <prooftechnique> Working with Aeson, to be clear
16:18:27 <MarcelineVQ> deriveJSON lets you specify an Options type to preprocess the datatype doesn't it?  seems like the place to check that sort of thing out https://hackage.haskell.org/package/aeson-1.2.1.0/docs/Data-Aeson-TH.html#v:defaultOptions  especially fieldLabelModifier
16:18:50 <geekosaur> and there's even a predefined config to prepend underscores on the haskell side iirc
16:20:09 <prooftechnique> Ah, that might be just the thing. Thanks :D
16:45:46 <vimalloc> Is there a mapA in haskell? I made a generalized function like this "mapListApplicative :: Applicative f => (a -> f b) -> [a] -> f [b]" (the fact that I got that working was very exciting by itself!). Hoogle informed me that this is basically mapM, but I'm not seeing any applicative version of that?
16:46:13 <hpc> :t traverse
16:46:15 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:46:47 <hpc> with bonus generality on []!
16:46:49 <vimalloc> ah. I saw thtat in hoogle, but was confused by the Traversable t. Why is that needed?
16:46:51 <vimalloc> ooooh
16:46:54 <vimalloc> Sweet. Thanks! :)
16:48:49 <vimalloc> The fact that you can have no idea what something is called, but be able to search for it just based on a function declaration is super neat!
16:51:30 <hpc> yeah, it's one of the most convenient things i have ever seen a language do
16:51:39 <hpc> (or well, language community)
16:53:26 <whoman> =)
17:05:10 <TylerCurtisJower> *Icebreaker*
17:07:22 <TylerCurtisJower> Can someone send something so I know this is working
17:09:03 <geekosaur> hi
17:09:24 <hpc> TylerCurtisJower: did you say something?
17:09:42 <hpc> ;)
17:10:24 <TylerCurtisJower> Awesome possum
17:15:43 <sveit> is there a concensus in the Haskell community as regards parsing, whether it is better to have two phases, lexer->parser, or just a parser on its own?
17:16:17 <sveit> it seems parser combinators promote the latter style. btw, i'm talking about DSLs, not parsing some network data for example
17:27:07 <geekosaur> most people use parser combinators
17:27:48 <geekosaur> ghc itself is an exception, largely because it predates them and retrofitting would be painful at this point
17:27:49 <whoman> most people eat mcdonalds and watch tv
17:28:38 <n_blownapart> ever happen where ghci just goes haywire? It won't backspace/delete the first 12 characters (i.e. the last characters while backspacing.) It is also doing other bizarre behaviors like the cursor skipping off to the line above the prelude line
17:28:49 <n_blownapart> this happened suddenly
17:29:39 <whoman> sounds like readline or something ?
17:29:40 <n_blownapart> this is in stack ghci
17:30:11 <n_blownapart> should I just reinstall ?
17:30:28 <MarcelineVQ> something like that is most commonly some issue with the terminal or OS locale setting, I get that when resizing a terminal sometimes
17:31:04 <n_blownapart> really MarcelineVQ yeah I was resizing the term. any fix?
17:31:38 <MarcelineVQ> dunno, never bothered me enough to find out
17:31:46 <n_blownapart> its essentially unusable
17:32:32 <n_blownapart> the history is also messed up
17:32:51 <MarcelineVQ> the ghci history file?
17:32:58 <whoman> cant just reload ghci ?
17:33:41 <n_blownapart> if I hit the up arrow key I get all sorts of weird behavior
17:34:00 <n_blownapart> I tried reloading a few times. same behavior
17:34:33 <whoman> try a different terminal ? or a ghci option ?
17:34:43 <MarcelineVQ> if you hit the up key and get weird symbols during a readLine or something that's not strange, if it's just during normal ghci use that's not good
17:35:34 <n_blownapart> yeah also it won't backspace delete after a point. that is not acceptable. will try to reinstall thanks
17:37:20 <trigone> hi, is it possible to write a pattern like (fun x (x:xs)), using two times the label x and implying thus way that both values are identical?
17:37:23 <vimalloc> Have you done a 'reset' in your terminal?
17:37:44 <vimalloc> A ctrl-l might fix it too. I don't think you need to reinstall...
17:38:00 <n_blownapart> vimalloc, that is a single command ?
17:38:27 <trigone> it would be equivalent in theory to (fun x (y:ys) | x == y)
17:39:00 <trigone> :t (\x x -> True) 3 3
17:39:01 <lambdabot> error:
17:39:01 <lambdabot>     • Conflicting definitions for ‘x’
17:39:01 <lambdabot>       Bound at: <interactive>:1:3
17:39:15 <trigone> hm... does not seem to be possible?
17:39:25 <buglebudabey> are there any packages that are particularly good for drawing graphs? not plot graphs, like the combinatorial kind
17:39:44 <vimalloc> Two separate commands. Reset is outside of ghci (just a terminal command), Ctrl-l can be run in or out of ghci
17:40:26 <Profpatsch> Is there an easy way to test with HUnit whether a datatype matches some sum types constructor?
17:40:34 <Profpatsch> *type’s
17:41:10 <Profpatsch> Or to get a predicate for constructors without the boilerplate of defining a function for each?
17:41:40 <Profpatsch> I already have TemplateHaskell in Scope (testing module), but not lens.
17:41:52 <Profpatsch> So mkPrisms is a bit overkill.
17:42:19 <n_blownapart> vimalloc, thanks, I have problems here. somethings wrong when the first 12 characters on a line won't delete, where 13..n delete fine
17:42:53 <n_blownapart> I tried the reset command and it seemed to reset
17:50:29 <n_blownapart> dang going at a snails pace again
17:59:54 <n_blownapart> further assistance if you have time. apparently stack uses the /tmp directory in linux. I have two directories there at the top: ghci2045 and ghci2693. these both contain ghci-script files that each contain only ':module +'
18:01:44 <n_blownapart> should there not be 2 directories beginning with ghci there?
18:02:32 <MarcelineVQ> shouldn't matter, especially if that's all that's in it
18:03:28 <n_blownapart> thanks I'm reinstalling what a pain
18:23:59 <mclark1129> Anyone else have issues trying to get ghc-mod working with Vim?
18:31:09 <pimlu> so, because idris is strict by default, does that mean that sum [1..n] uses O(n) memory, or is that something you trust to get optimized?
18:31:35 <pimlu> I tried to dodge it with a Stream using sum $ take 100 [1..] but it turns out take just returns a List too
18:31:59 <n_blownapart> oh boy still have the same problem after fresh install. the cursor jumps up to the line above prelude and cannot delete with backspace
18:32:08 <pimlu> (although, in the REPL the second one is significantly faster for some reason...)
18:32:52 <boj> n_blownapart: when you say reinstall you mean the OS? terminal? haskell platform?
18:33:35 <n_blownapart> boj stack thanks for responding !
18:33:53 <boj> n_blownapart: the problem is more than likely with your terminal, not stack/ghci
18:33:59 <geekosaur> this sounds like a terminfo issue, yeh
18:34:02 <geekosaur> echo $TERM
18:34:11 <n_blownapart> dang how to troubleshoot
18:34:11 <geekosaur> and, what terminal are you running?
18:34:49 <n_blownapart> I'm using debian jessie 9 32bit. what is that xterm?
18:34:57 <n_blownapart> jessie 8 sorry
18:35:09 <geekosaur> depends on what is installed, thanks to the alternatives system :/
18:35:28 <geekosaur> do you get a menu if you control-left click in the terminal?
18:36:18 <n_blownapart> its xterm, no no menu with control left click
18:36:42 <geekosaur> um, xterm would show you a menu in that case
18:37:11 <geekosaur> what happens if you right click? (no modifiers)
18:37:19 <n_blownapart> echo $TERM gives me xterm
18:38:09 <n_blownapart> I get a pulldown menu 'open terminal' is first selection
18:38:26 <geekosaur> ok, it;s something VTE-based, not xterm
18:38:38 <n_blownapart> VTE ?
18:38:40 <geekosaur> what does the command "echo $TERM" report?
18:38:45 <geekosaur> the gtk terminal widget
18:39:07 <geekosaur> gnome-terminal, mate-terminal, xfce4-terminal, and a bunch of other things not all of which are tied to desktop environments
18:39:19 <n_blownapart> lowercase xterm
18:39:22 <n_blownapart> yeah this is gnome
18:39:57 <n_blownapart> any pointers appreciated I'm trying to learn type signatures
18:40:21 <geekosaur> ok, that sounds right (sometimes it will be xterm-256color or etc.; most terminal emulators use the xterm escapes though)
18:40:51 <n_blownapart> yeah I didn't install alternative terms
18:41:14 <geekosaur> but jessie installs gnome by default so gnome-terminal is likely to be the default terminal
18:41:35 <geekosaur> hm, do you have a ~/.ghci ?
18:42:18 <n_blownapart> yeah, but all that has in it is a custom line for a colorized lambda prompt. its empty otherwise
18:42:30 <vimalloc> Just to verify, you have tried exiting that terminal and opening a new terminal right?
18:42:59 <geekosaur> n_blownapart, actually that was exactly what I feared
18:43:00 <c_wraith> n_blownapart: colorization uses escape codes of the same sort that move the cursor around.  that could be relevant
18:43:14 <geekosaur> one or more of your color escapes is incorrect and moving the cursor
18:43:18 <n_blownapart> dang you people are great
18:43:23 <c_wraith> n_blownapart: especially if the terminal is not interpreting the escape codes in the same way as you meant them when you wrote them
18:43:52 <boj> sounds like you should clear your ~/.ghci and give it a shot
18:44:05 <n_blownapart> excellent thanks hold on
18:44:08 <geekosaur> you could try putting it on lpaste and I can see if I can figure out what's wrong
18:44:19 <n_blownapart> excellent will do
18:44:22 <geekosaur> althygh if it has literal escape characters that won't work very well
18:44:57 <n_blownapart> https://ptpb.pw/5OUC
18:45:32 <geekosaur> also if it's long enough, I don't think haskeline has a way to "hide" the escapes and it might think the line wrapped. overly fancy prompts can be a bad idea
18:46:14 <geekosaur> (like, bash lets you wrap escape sequences in \[ \] to indicate that that sequence takes up zero space and shouldn't be counted against the line length)
18:46:36 <n_blownapart> that prompt is rather benign I thought
18:46:38 <geekosaur> ah. the newline is confusing it
18:46:54 <geekosaur> haskeline doesn't expect the prompt to be 2 lines
18:48:35 <n_blownapart> ok so I'll just forgo the package name on a second line. so should I take out just \n and keep one slash ? 
18:48:35 <mclark1129> This is probably a noob question, but is it possible to define a data type that is a subset of another type?
18:48:47 <mclark1129> like if I wanted to define a type that was only the numbers 1 - 10
18:48:55 <geekosaur> mclark1129, no
18:49:24 <mclark1129> thx
18:49:27 <geekosaur> n_blownapart, probably yes to that. haskeline is portable, but not as smart as e.g. gnu readline (whichc auses problems on both windows and os x, which is why it's used instead of readline).
18:49:46 <nilof> quick question: mempty from monoid is always assumed to be a two-sided identity right?
18:49:47 <geekosaur> you can't do fancy stuff, it gets confused easily. and even multiple lines is "fancy" for haskeline.
18:50:05 <geekosaur> nilof, it's one of the monoid laws
18:50:34 <blair__> Hey guys, anyone know how to construct a TimeLocale with a different timezone than the default? I'm a bit confused as to how to do this
18:51:31 <n_blownapart> geekosaur, so this won't screw up my game? https://ptpb.pw/Jc4X
18:51:48 <geekosaur> it shouldn't
18:52:24 <c_wraith> blair__: the constructor is exposed...
18:53:00 <geekosaur> n_blownapart, you might just get rid of the %s and use ":show imports" if you need to chekc it. how often do you really care that it's in the prompt?
18:53:48 <n_blownapart> YOU RULE ...  the bit with the m%s , that's required right geekosaur ?
18:53:49 <c_wraith> blair__: but if you mean a standardized one - they change a lot, so you need a library that specializes in getting them via IO
18:54:01 <n_blownapart> oh hold on sorry
18:54:24 <geekosaur> n_blownapart, the 'm' is part of an escape sequence. the %s is not necessary, it's just a way to invoke the default behavior of showing the modules in scope
18:54:53 <c_wraith> blair__: https://hackage.haskell.org/package/timezone-olson is a common approach to loading timezone data
18:55:07 <n_blownapart> so get rid of %s and forgo the module in scope ?
18:55:38 <geekosaur> many people don't bother with it and set the prompt to "λ > " or something
18:55:57 <c_wraith> I just use "> " when I set it manually.
18:55:58 <geekosaur> and you can see the list of modules with ":show imports" when you do need it
18:56:03 <nilof> but it does mean that >> and pure x doesn't satisfy the monoid laws, despite >> being associative and pure x for any x being a left identity?
18:56:23 <n_blownapart> ok I'll get rid of it . the colors shouldn't bother it though? It seems to help my vision
18:56:29 <geekosaur> they shouldn't
18:56:37 <c_wraith> nilof: the monoid in applicatives is in the effects, not the "results"
18:56:46 <n_blownapart> thanks so much geekosaur c_wraith boj et al
18:56:56 <boj> n_blownapart: glad you got it worked out ^^
18:57:10 <c_wraith> nilof: x >> pure ()  has the exact same effects as x
18:57:26 <c_wraith> nilof: which satisfies that identity law
18:59:47 <nilof> well, for monads x >> y  is defined as  x >>= (const y) , and we have the law  (pure x) >>= f  =  f x  , so pure x >> y = y
19:00:12 <c_wraith> nilof: that's true
19:01:31 <c_wraith> nilof: but that's a stronger statement than is actually necessary to say that Applicative has monoidal structure in its effects
19:02:11 <nilof> right, I see what you meant
19:03:53 <c_wraith> nilof: it's important to remember that category theory terminology is significantly broader than classes named after them in Haskell. :)
19:04:33 <c_wraith> nilof: you can describe something as monoidal that can't be captured by the Monoid class in many ways.
19:04:57 <nilof> right, Haskell mixes in the notion of type constructors
19:05:14 <nilof> which have to be generic over the argument, so that you get free theorems
19:05:43 <c_wraith> Plus type constructors are curried, classes tend to have fixed kinds..  lots of restrictions
19:06:38 <nilof> while in Category theory monads are just a functor and two natural transformations
19:06:52 <EvanR> "just a ..."
19:07:12 <EvanR> is used so often i wish it was mathematically significant!
19:07:26 <geekosaur> just three things that each need a book to explain >.>
19:07:47 <nilof> well, in maths its often not even named, and the expanded definition is used instead
19:08:06 <nilof> when it comes up
19:08:07 <EvanR> a monoid in category of monoids is just a commutative monoid
19:08:11 <c_wraith> Once I finally understood "Just a monoid in the category of endofunctors" I had to laugh.
19:08:25 <c_wraith> It's a restatement of the definition.  Nothing more, nothing less.
19:09:27 <c_wraith> For what it's worth, let's use newtypes to shoehorn Applicatives into the Monoid class!
19:09:28 <EvanR> surely you just
19:09:45 <mclark1129> I tried watching the series of lectures of Category Theory for Programmers
19:10:00 <mclark1129> Needless to say I am still thoroughly confused.
19:10:42 <exio4> c_wraith: it's beautiful 
19:10:56 <exio4> it's so simple and complicated at the same tim
19:10:58 <nilof> but right, most of the natural examples of functors in math or physics are not as generic as Haskell functors
19:10:58 <exio4> +e
19:11:11 <mclark1129> I do have a category theory question, maybe you guys/gals can shed some light
19:11:29 <c_wraith> newtype ApplicativeMonoid f = AM (f ()) ; instance Applicative f => Monoid (ApplicativeMonoid f) where mempty = AM () ; mappend (AM x) (AM y) = AM (x *> y)
19:11:50 <nilof> and would just have a signature (a -> b) -> (c -> d) for some fixed types (not generic) abcd
19:12:06 <c_wraith> There.  Now there's a Monoid on the Applicative effects. :)
19:13:39 <mclark1129> Within the category of types, is it fair to say that all morphisms that go from Type to Type are the identity function?
19:14:22 <mclark1129> e.g. Any function with the signature Int -> Int could be considered the identity function, when you're zoomed out to the type level?
19:14:29 <EvanR> i would like to see your definition of category of types
19:14:47 <mclark1129> A category where the objects are Types
19:14:54 <EvanR> this is the category theory airport security checkpoint
19:15:18 <mclark1129> Luckily my knowledge of category theory can fit within a 1 oz shampoo bottle.
19:15:41 <mclark1129> But of the little I was picking up from the cat theory lectures
19:16:06 <mclark1129> I could think of a category of types where the objects are the types
19:16:16 <mclark1129> so in that sense any morphism would be a function between two types
19:16:18 <mclark1129> Int -> Bool
19:16:50 <mclark1129> At the same time, I could think of the category of a specific type to have objects that represent each value within the type
19:17:10 <mclark1129> so the morphisms would be the functions that go from Int -> Int for example
19:17:23 <mclark1129> since every object in the Int category would be an Int
19:18:24 <EvanR> andrej bauer posted a scathing review of Hask on his blog, criticizing "categories" such as these
19:18:41 <nilof> well, it would automatically become a groupoid otoh
19:19:15 <EvanR> for not being categories is one thing, but more so that people go along with it without questioning the criteria for being a category
19:19:52 <EvanR> haskells types and functions between haskell types dont form a category
19:20:04 <EvanR> unfortunately
19:20:12 <mclark1129> EvanR: Objects, morphisms, identity, associativity?
19:20:22 <EvanR> correct
19:20:49 <mclark1129> Then what about types don't qualify?  
19:21:01 <EvanR> what about *haskell types and functions* dont qualify
19:21:20 <mclark1129> Sure, what about haskell types and functions don't qualify?
19:21:22 <EvanR> https://wiki.haskell.org/Hask
19:22:58 <EvanR> an acceptable category related to haskell is apparently the category of omega complete partial orders
19:23:14 <EvanR> which supports the idea of improving values, and bottom
19:23:36 <mclark1129> so maybe then not specifically haskell
19:23:47 <mclark1129> if a type is defined as a set of possible values
19:23:51 <EvanR> sure... specifically something though? :)
19:24:03 <EvanR> category of sets
19:24:32 <mclark1129> yep category of sets, or even category of categories right?
19:24:33 <nilof> I thought that what mcclark meant was basically just the free category on just the types with no notion of whether they were inhabited?
19:24:49 <nilof> or was it something closer to hask?
19:25:28 <EvanR> category of sets probably doesnt contain something like Type
19:25:43 <EvanR> by default
19:25:45 <mclark1129> nilof: I'm really just trying to somehow connect the dots from category theory to programming.  And to see if one minor insight I thought I might have would be valuable to me at all.
19:26:03 <EvanR> (the original question was about Type, a type universe)
19:26:11 <mclark1129> EvanR: yes
19:26:21 <mclark1129> so just that alone, the type universe
19:26:24 <mclark1129> that is a category correct?
19:26:33 <EvanR> not if it contains itself no
19:27:00 <mclark1129> so as long as type is not a type?
19:27:08 <mclark1129> (I am incredibly out of my depth :))
19:27:22 <EvanR> but has endomorphisms?
19:27:50 <mclark1129> morphisms that point back to the same object?
19:28:09 <EvanR> wait i know... Type -> Type does have non trivial things in haskell, such as Maybe
19:28:25 <EvanR> so an answer might be "no"
19:30:02 <mclark1129> So... the universe of types would have endomorphisms right?
19:30:06 <mclark1129> Int -> Int?
19:30:30 <EvanR> no, that sounds confused
19:30:39 <mclark1129> Perfect, because that's what I ame.
19:30:40 <mclark1129> am*
19:30:50 <EvanR> mclark1129: connecting the dots from CT to programming... heres one, simply typed lambda calculus is the internal logic of cartesian closed categories
19:31:30 <EvanR> (refraining from putting "just a" in there :)
19:31:30 <cheater> hi
19:31:47 <cheater> can someone suggest a good solver for solving a lot of simultaneous linear equations?
19:33:20 <mclark1129> EvanR: So endomorphisms are another thing I didn't quite grasp
19:33:31 <mclark1129> Like I get it's just a morphism from an object back to itself
19:33:33 <EvanR> i just meant morphisms that have the same source and target
19:33:51 <mclark1129> sure, but why is that not always the identity morphism?
19:33:56 <Axman6> morphisms "within"  category?
19:33:58 <EvanR> like (+1) ?
19:34:08 <EvanR> > (+1) 1
19:34:10 <lambdabot>  2
19:34:13 <EvanR> not the identity
19:34:34 <mclark1129> hmm
19:34:44 <mclark1129> I guess i always thought of the target being the result
19:34:49 <Axman6> an haskell, endomrhpisms are just functions with type a -> a (for certain a's though)
19:34:53 <Axman6> in*
19:34:54 <EvanR> +1, +2, negate, are all different morphisms
19:34:56 <mclark1129> like (+1) would be a morphism and applied to 1, the target is 2
19:35:04 <EvanR> no
19:35:10 <EvanR> the source is Int target is Int
19:35:15 <Axman6> 1 and 2 are both objects in the same cateogry though
19:35:33 <mclark1129> Axman6 Yeah that much I get
19:35:47 <mclark1129> but an endomorphism is only from 1 to 1?
19:35:48 <EvanR> how many different categories are we talking about 
19:35:56 <mclark1129> lol, stick with a category of integers
19:35:57 <EvanR> thats why i asked to defined it
19:36:03 <EvanR> which category of integers
19:36:14 <mclark1129> 32 bit integers
19:36:20 <EvanR> objects are integers, morphisms are ?
19:36:35 <mclark1129> functions that take in an integer and return an integer
19:36:45 <EvanR> doesnt make sense to me
19:36:50 <mclark1129> gd it all
19:36:53 <EvanR> what is the source of (+1)
19:36:53 <mclark1129> :)
19:37:02 <mclark1129> an integer?
19:37:06 <EvanR> which one
19:37:16 <Axman6> well, functions which take integers and return integers are endomorphisms
19:37:29 <EvanR> ... on a category where objects are types
19:37:35 <mclark1129> Axman6: In a category of types right?!
19:37:44 <EvanR> or sets
19:37:49 <EvanR> not numbers
19:37:54 <mclark1129> which is what is leading me down this rabbit hole, which I'm assuming EvanR is purposely trying to break my brain.
19:38:06 <EvanR> mclark1129: heres one where integers are objects, there is a morphism from x to y (integers) if x < y
19:38:17 <EvanR> er., ... if x <= y
19:38:44 <EvanR> so you have one with type 3 -> 4, and 3 -> 3, but not 4 -> 3
19:39:04 <mclark1129> because (-1) wouldn't have associativity?
19:39:11 <EvanR> -1 ?
19:39:17 <mclark1129> (-1) 4
19:39:41 <EvanR> theres a basic misunderstanding going on
19:39:50 <mclark1129> absolutely, and for that I apologize.
19:40:02 <EvanR> have you studied groups, monoids?
19:40:06 <mclark1129> no
19:40:21 <EvanR> damn son check those out
19:41:05 <mnoonan_> mclark1129: it seems like you’re thinking one level of abstraction down from where you need to be. like with your endomorphism question.. the target of a function X -> Y isn’t any particular result in Y, it’s *all* of Y, as a set
19:41:13 <mnoonan_> (or whatever, foundational issues etc etc)
19:41:27 <EvanR> the presentation of groups is a lot like categories, but a little simpler
19:42:03 <EvanR> you have a carrier set of things, and operations on the set
19:42:33 <EvanR> the group multiply operation, and inverse operation
19:42:58 <EvanR> and a distinguished *thing* that acts like an identity
19:43:22 <mclark1129> mnoonan_ And that's where I was trying to zoom out a bit
19:43:34 <EvanR> categories are similar, but the operation (morphism composition) involves a type system, that is what the objects are for
19:44:01 <EvanR> you cant combine any two morphisms you want, they have to agree
19:44:08 <EvanR> :t (.)
19:44:10 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:44:19 <mclark1129> right, the source of f has to be the target of g?
19:44:26 <EvanR> yeah
19:45:17 <EvanR> and the morphisms are *just things*, not necessarily a function
19:45:31 <mclark1129> well I say function, but a path from one object to another?
19:45:56 <EvanR> i dont know what youre thinking when you say path
19:46:11 <EvanR> they are just things that have a signature consisting of 2 objects
19:46:28 <EvanR> like the two ends have a shape
19:46:30 <mclark1129> I'm just thinking visually of a line that starts at one dot and points to another dot
19:46:45 <mclark1129> the line is a morphism, the dots are the objects
19:46:57 <EvanR> well, youre thinking of a graph
19:47:17 <EvanR> and some graphs satisfy the criteria for a category
19:47:18 <mclark1129> what if I put a little arrow on the side of the line that has the target?
19:47:25 <EvanR> a directed graph
19:47:30 <mclark1129> that is totally ordered??!
19:47:38 <EvanR> what?
19:47:57 <EvanR> theres also a dedicated channel for category theory
19:48:30 <EvanR> ##categorytheory
19:48:31 <mclark1129> fair enough, I'll stop wasting time.  But thanks for at least attempting.
19:49:00 <EvanR> a sort of revelation i had was, the objects are like types
19:49:18 <mclark1129> which was the opposite of the revelation I thought I had
19:49:25 <EvanR> but if you havent done a lot of typed functional programming, that might not mean much
19:50:01 <EvanR> they are just symbols to tell you when stuff is allowed to fit together
19:50:34 <mnoonan_> if you want to think about graphs, there are two easy ways to get a category out of a directed graph:
19:51:14 <mnoonan_> (1) objects are the nodes, and every *path* from x to y is a distinct arrow
19:51:35 <mclark1129> I think that much I grasp
19:51:46 <mnoonan_> or (2) objects are the nodes again, and there is an arrow from x to y if y is reachable from x
19:51:52 <EvanR> you could prove that that satisfies the criteria for a category
19:52:04 <EvanR> and that
19:52:10 <EvanR> s/you could/you should/
19:53:27 <EvanR> and also, make specific what the morphism composition is in each case
19:56:28 <mclark1129> mnoonan_: ok (and I promise I'll drop it after this) but if I wanted to think each node was a single number
19:56:38 <mclark1129> one node is 3 and the other is 4
19:57:53 <mclark1129> a possible morphism would be 3 + 1 = 4?
19:57:56 <mclark1129> so (+1) 3?
19:58:07 <EvanR> that has nothing to do with graphs
19:58:28 <mnoonan_> what are your edges? are you thinking of this graph?  1 -> 2 -> 3 -> 4 -> ...
19:58:45 <mclark1129> sure
19:59:03 <mnoonan_> and are you thinking of “easy way” (1) or (2) above?
19:59:19 <EvanR> are you stuck thinking morphisms are functions?
19:59:25 <mclark1129> EvanR: yes
19:59:30 <EvanR> in this case, they are paths in a graph
19:59:32 <EvanR> not functions at all
19:59:33 <mnoonan_> EvanR: we’ll get there :)
20:00:08 <mclark1129> I may just be trying to make too concrete something that is meant to be abstract
20:00:22 <EvanR> no youre just being concrete in the wrong way
20:00:34 <EvanR> mixing up several concrete examples together
20:01:25 <mclark1129> ok, so if I was thinking of numbers as a category, and at the same time trying to visually in my brain think of them as a graph with nodes
20:01:37 <EvanR> start with, what category
20:01:44 <EvanR> numbers as objects, what as morphisms
20:01:55 <EvanR> and how do they combine
20:02:10 <mclark1129> k so numbers as objects
20:02:20 <mclark1129> the morphisms are just one way to get from one object to another..
20:02:27 <mclark1129> (don't say function, don't say function)
20:02:29 <mnoonan_> no, make it more concrete
20:02:38 <EvanR> exactly what is a morphism
20:02:41 <EvanR> here
20:03:00 <EvanR> if source is 3 and target is 6 what if any morphism is there with type 3 -> 6
20:03:06 <mnoonan_> literally the morphisms are a path through one, concrete graph (so you still need to decide what edges you’re talking about)
20:05:18 <mclark1129> mnoonan_ So I think I definitely see the morphisms as the edges between the objects...
20:05:26 <mclark1129> and on the way from 3 -> 6
20:05:32 <mclark1129> I could go 3 -> 4 -> 5 -> 6
20:05:39 <mclark1129> I could go 3 -> 5 -> 6
20:05:57 <mnoonan_> mclark1129: closer, but still not quite. in this example, the morphism from 3 to 6 is literally the path “3 -> 4 -> 5 -> 6”
20:05:59 <mclark1129> I could compose 3 -> 4 with 4 -> 5 and that would equal 3 -> 5
20:06:15 <EvanR> nice
20:06:22 <mnoonan_> and composing “3 -> 4” with “4 -> 5” is “3 -> 4 -> 5"
20:06:32 <EvanR> errr no
20:06:44 <mnoonan_> maybe it would be better if I used a different notation for the paths besides -> :)
20:07:16 <mnoonan_> let’s name a path by the list of nodes it visits, so the unique morphism 3 -> 6 in this category is [3,4,5,6]
20:07:35 <EvanR> unique?
20:07:48 <mclark1129> well a unique morphism right?  I could have both a morphism from 3 right to 6
20:07:52 <mnoonan_> evanr: i guess it could stall..
20:07:53 <EvanR> [3,2,3,4,5,6,7,6]
20:07:56 <mclark1129> and one that travels from 3,4,5,6?
20:08:28 <EvanR> or, you didnt give any backwards arrows
20:08:33 <EvanR> backwards edges
20:08:36 <mnoonan_> EvanR: right
20:08:43 <mclark1129> ok backwards edges are out!
20:08:46 <mclark1129> only forward
20:08:57 <EvanR> you do need the paths that stand still
20:09:02 <mnoonan_> mclark1129: no, remember I said that the morphism is the path in this one, concrete graph 1 -> 2 -> 3 -> 4 -> …
20:09:38 <mnoonan_> so you can’t go right from 3 to 6
20:10:30 <mclark1129> ok so we have a specific graph that is essentially a single line through these objects
20:10:40 <mnoonan_> so you can compose [3,4,5] (a morphism 3 -> 5) with [5,6] (a morphism 5 -> 6) to get [3,4,5,6] (a morphism 3 -> 6)
20:10:45 <mnoonan_> right
20:11:25 <mclark1129> ok
20:11:43 <mclark1129> [3,4,5] also composed of [3,4] and [4,5]?
20:11:50 <EvanR> [3,4,5,6] : 3 -> 6
20:12:07 <mnoonan_> yes, exactly, and it [3,4,5] is a morphism 3 -> 5
20:12:26 <EvanR> [3,4] . [4,5] = [3,4,5]
20:12:44 <mclark1129> ok
20:13:12 <mclark1129> and if this graph also had [3,6]
20:13:25 <mclark1129> then [3,4,5] . [5,6] = [3,6
20:13:26 <mclark1129> ]
20:13:28 <EvanR> it would like a mario warp zone :)
20:13:33 <EvanR> no
20:14:00 <EvanR> [3,4,5] . [5,6] = [3,4,5,6]
20:14:00 <mnoonan_> no, but they would both be arrows 3 -> 6
20:14:17 <EvanR> [3,6] . [6,7,8] = [3,6,7,8]
20:14:40 <mnoonan_> in fact, there would be exactly two possible arrows 3 -> 6 in that case
20:15:05 <mclark1129> but knowing that they are both 3 -> 6
20:15:17 <mclark1129> is significant in that yes they do not == each other by identity
20:15:25 <mclark1129> but that I could use them interchangebly?
20:15:39 <EvanR> they have the same type, thats it
20:15:43 <EvanR> they arent the same arrow
20:16:12 <mclark1129> ok, and I think I can understand that part
20:16:17 <mnoonan_> well, you can’t use them interchangably in all senses; they mean different things, but you could always swap one out for the other in part of a bigger composition
20:16:19 <EvanR> if you replace one with the other, you would get different results
20:17:00 <mclark1129> ok, and that might be another thing I don't grasp.  at least as far as how to connect this back to composing functions or applying this in my haskell.
20:17:07 <mnoonan_> just like you could always replace (+1) with (*100) in a computation, since they are both Int -> Int, but you surely won’t get the same result :)
20:17:08 <EvanR> if you drew the graph with the oddball [3,6] path in there, it would be obvious
20:17:25 <mclark1129> yeah so two different arrows, absolutely for sure
20:18:40 <mclark1129> so it's more that they just have the same shape like a puzzle piece
20:18:46 <mnoonan_> yes, exactly
20:18:48 <mclark1129> so I can plug them into some slot that has that shape
20:18:54 <EvanR> yes
20:18:57 <mclark1129> but, plugging in each piece might yield a different picture
20:19:18 <mnoonan_> right
20:19:22 <EvanR> types = puzzle piece shapes
20:19:32 <EvanR> objects = types
20:19:43 <mnoonan_> you might have heard the term “type tetris” for exactly this reason
20:19:47 <mclark1129> yep
20:19:57 <EvanR> hahaha
20:20:06 <EvanR> i haven
20:21:35 <mclark1129> so then how does it play in when I hear the term "program correctness"
20:22:07 <mclark1129> it always seems like "typechecking helps enforce program correctness"
20:22:35 <EvanR> at one extreme, you could encode the entire specification into the types
20:22:53 <EvanR> then you would only run it if you manage to satisfy all the requirements
20:23:33 <mclark1129> so like addItemToCart :: EmptyShoppingCart -> Item -> NonEmptyShoppingCart?
20:23:52 <EvanR> less extreme, you stop your program from running when you do things that make no sense
20:23:59 <mnoonan_> a really simple example is something like looking up a key in a map, so you have some function with a type like “lookup :: Map -> Key -> Maybe Value”, where you’re explicitly representing the possibility of failure in the result type
20:24:21 <mnoonan_> so you force the user of “lookup” to have to handle that case
20:24:55 <mnoonan_> and if the user doesn’t handle that case, then the program won’t compile
20:25:17 <mnoonan_> (partial functions ruin everything, though)
20:25:25 <EvanR> thats more like a guidance role of types, guiding you into doing things you have to do
20:25:38 * mnoonan_ nods
20:25:46 <mclark1129> really just limiting the scope of failure once I can typecheck it I guess?
20:25:55 <EvanR> which is a great counter to people who see types as mainly restrictive
20:26:12 <mnoonan_> ensuring that failure is accounted for, and also documenting that failure is possible
20:26:27 <mclark1129> so in your example of the lookup
20:26:44 <mclark1129> there's nothing really preventing me from just returning the wrong item though
20:27:01 <jle`> mclark1129: there's also the benefit of parametric polymorphism, where polymorphic types help enforce correctness
20:27:20 <jle`> mclark1129: in that case, yes, those types are not strong enough to prevent returning the wrong value
20:27:28 <jle`> strength and expressivity of types is a spectrum
20:27:42 <EvanR> the types are also not strong enough to ensure something is there that you know to be there
20:28:00 <mnoonan_> true. if you have properties like “If I insert a value x at key k and then lookup k, I should get Just x back” then you can’t enforce them in the types
20:28:05 <mnoonan_> (as far as I can think of)
20:28:05 <EvanR> like, its definitely there because you just put it there
20:28:11 <jle`> well, you can enforce them in types if your types are strong enough
20:28:17 <jle`> but making your types stronger is a trade-off too
20:28:20 <mnoonan_> but we do have things like quickcheck for helping close that gap a bit
20:28:30 <mclark1129> right, stronger types == less composability?
20:28:45 <jle`> not quite composability, but it's a shift in the burden of proof
20:28:52 <EvanR> more complex types means ... 
20:29:08 <mnoonan_> you start to turn your type system into something that feels more like a formal proof system
20:29:23 <jle`> yeah, there's a spectrum of usability vs. security
20:29:27 <jle`> *safety
20:29:52 <mnoonan_> you also start to lose type inference with more sophisticated systems
20:30:09 <EvanR> well, a theory of complex types with no code at all can be its own work of art :)
20:30:17 <jle`> besides Maybe stuff, parametric polymorphism is one way haskell's type system enforces correctness
20:30:19 <mclark1129> so theoretically, I could enforce 100% of my logic within types, such that a program could not even compile if it had any bugs
20:30:37 <jle`> in theory, i suppose
20:30:46 <mclark1129> but that would be pretty much brutal to work with
20:30:57 <EvanR> yes, i imagine comic book scientists doing that
20:31:04 <EvanR> or batman
20:31:07 <jle`> most systems like Haskell, Idris, etc. that seek to give you types to aid your logic don't actually aim for complete 100% bug reduction/correctness
20:31:15 <jle`> their goal is to let types help you where they can
20:31:24 <jle`> and wehre you want them
20:31:29 <mclark1129> yeah, so really just limit the rope I can hang myself with
20:31:38 <jle`> yeah, they give you the tools *if you want them*
20:31:48 <jle`> whereas for other languages, even if you want the tools, you can't get them
20:31:56 <mclark1129> constrasted with OOP which is basically standing at the edge of a cliff going "It's not that far, you should try jumping"
20:32:14 <EvanR> no ones ever made the first jump
20:32:16 <mnoonan_> mclark1129: here’s a cool example where they use types with a red-black tree implementation to guarantee that the resulting trees are balanced: https://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html
20:32:21 <c_wraith> OOP isn't *that* bad, it's just...  overused, and often poorly used. :)
20:32:45 <mclark1129> Hey, OOP pays my bills.
20:32:59 <mnoonan_> mclark1129: mine too, sorry to say :)
20:33:13 <EvanR> in the sense of window maker throwing bricks around town to drum up business!
20:33:29 <mclark1129> EvanR: lol
20:34:07 <mclark1129> And this is what draws me to FP, even though I have a long way to go before I can apply it practically
20:34:53 <jle`> it's probably not as long a way as you think :)
20:34:56 <mclark1129> That i can express things considerably more concisely and with effective use of types just limit the scope of logic I have to keep in my brain at once.
20:35:06 <EvanR> haskell is like a gateway drug
20:35:10 <c_wraith> I was fortunate enough to learn Haskell on the job.  Sadly, I no longer have a job that uses it.  It makes me cry every time some long-standing bug is eventually traced to a simple type error.  (Which probably happens once every other week)
20:35:22 <mclark1129> jle`: Probably not, but I'm still waiting on that big breakthrough
20:35:27 <c_wraith> well. It makes me *want* to cry
20:35:50 <jle`> for me i just gradually started chosing haskell for things i would normally program in other languages
20:35:51 <EvanR> its ok to cry c_wraith...
20:35:58 <jle`> even though i didn't know that much haskell
20:36:10 <jle`> and eventually i realized that i used haskell for everything
20:36:10 <mclark1129> ATM, I've decided that I am only going to use FP for any programming outside of work.
20:36:11 <c_wraith> EvanR: just takes too long.  I have too many other things to fix
20:36:45 <jle`> mclark1129: good start :)
20:36:46 <EvanR> mclark1129: i even find ways to use FP at work
20:36:58 <mnoonan_> c_wraith: I find template-heavy C++ build times give me plenty of crying space. you might want to look into it.
20:37:06 <jle`> there was Tekmo who started working at twitter and tried to get his coworkers to write shell scripts in haskell
20:37:23 <mclark1129> EvanR: That is my next goal, but I'm in an environment where FP is misunderstood, unknown, or just completely shunned
20:37:37 <EvanR> yeah you need to fit in it right or people will revolt
20:37:42 <EvanR> for good reasons
20:37:45 <mclark1129> Absolutely
20:38:00 <mclark1129> And one of those reasons is "Some guy who really doesn't understand FP just made this code 100% harder to read"
20:38:11 <EvanR> ... yeah
20:38:17 <mclark1129> I'd like to get it down to "Some guy just made this code 100% harder to read"
20:38:23 <EvanR> lol
20:39:08 <mclark1129> I'm in a .NET shop, so my chance at functional at work will likely be F#
20:39:08 <EvanR> well after years of practice , i still cant read production ruby gems
20:39:19 <EvanR> so think of it as payback
20:39:20 <mclark1129> but a lot of the guys I read on F# really base their teaching from haskell
20:39:26 <mclark1129> which is how i ended up here
20:39:32 <mclark1129> so I keep going farther and farther back
20:39:54 <mclark1129> "Knowing F# will help me write better C#" "Knowing Haskell will help me write better F#" "Knowing Category Theory will help me write better Haskell"
20:40:07 <EvanR> the last one is skeptical
20:40:23 <mclark1129> Yeah
20:40:27 <mnoonan_> as many as three faulty inferences in one go :)
20:40:27 <EvanR> you pass the point of no return and it bcomes
20:40:37 <mclark1129> mnoonan_ but I can compose them!
20:40:45 <mclark1129> So knowing CT will improve my C#!
20:40:47 <mnoonan_> hahaha
20:40:51 <EvanR> "knowing haskell gets me interested in CT" "CT leads to topology" "topology leads to weird analysis"
20:40:54 <EvanR> and so on
20:41:06 <mclark1129> leads to "Don't talk to that guy over there..."
20:41:58 <monochrom> Topology leads to fear. Fear leads to anger. Anger leads to using Haskell in anger. :)
20:42:58 * hackagebot req 0.3.1 – Easy-to-use, type-safe, expandable, high-level HTTP library – https://hackage.haskell.org/package/req
20:45:25 <mclark1129> Well that's about all I can take for now.  Thanks for walking me through some of the basics.
20:45:43 <EvanR> will haskell skills really help with C# ? inquiring minds want to know
20:45:54 <mclark1129> I'll keep you posted
20:46:06 <mnoonan_> so here’s a types-and-common-usage question.. I was thinking about putting together a little module to solve the “problem” of “Hey, I know that this key is already in the map, I don’t want to get a Maybe back from lookup”
20:46:41 <EvanR> you could side step the issue by using a total map
20:46:50 <EvanR> all lookups return *something*
20:47:08 <mnoonan_> but some grepping through hackage didn’t turn up very many cases of the form “Nothing -> error”, which is kind of what I was expecting people to do if they really believe the key must be there
20:47:29 <mnoonan_> EvanR: hm, that’s true
20:47:31 <monochrom> You can slap on a "fromJust".
20:47:33 <c_wraith> > fromJust Nothing
20:47:35 <lambdabot>  *Exception: Maybe.fromJust: Nothing
20:47:43 <mnoonan_> yeah, maybe I should have grepped for fromJust
20:47:55 <monochrom> Or if you have a default value, you can slap on a "maybe"
20:48:11 <c_wraith> if you have a default value, you're more in the fromMaybe case
20:48:49 <EvanR> the same minute you write Nothing -> error ... that minute your program will runtime error on you
20:49:26 <EvanR> out of cosmic spite, murphy's law, ...
20:49:36 <mnoonan_> well anyway, my idea was to have the Map and Key types carry a common phantom type parameter, kind of like Map ph (Key ph k) v
20:50:01 <mnoonan_> and provide a function like “getKey :: Map ph (Key ph k) v -> k -> Maybe (Key ph k)”
20:50:18 <mnoonan_> then lookup could be Map ph (Key ph k) v -> Key ph k -> v
20:50:47 <mnoonan_> the user would discharge the proof that the key is in the map up front, once, with getKey, instead of at every lookup
20:51:01 <EvanR> you can put a type level list of keys in the map type
20:51:13 <EvanR> listing keys that were used to insert up to this point
20:51:22 <EvanR> lookup requires you provide a key "somewhere in" the list
20:51:30 <c_wraith> You could also do LiquidHaskell stuff
20:52:01 <c_wraith> I really like the idea of liquid haskell.  I just want the details to work better.
20:53:43 <deceract> How do type-level lists affect performance? Are they optimized out during compilation?
20:55:03 <c_wraith> they exist only at compile time
20:55:14 <c_wraith> They can slow compilation down!
20:55:19 <EvanR> but to do what i said, there will need to be some interaction with the value level at runtime
20:55:41 <c_wraith> They also can get really awkward to use
20:56:25 <EvanR> i think dependent haskell will not be able to fully avoid certain cases of a proof "running" at runtime
20:56:44 <c_wraith> that is correct, but we're not there yt
20:56:47 <c_wraith> *yet
20:57:42 <c_wraith> I mean, one of the main difference Dependent Haskell will introduce is that types do exist at runtime. :)
20:59:14 <deceract> I see the list data structure used at the type level in fairly many haskell projects. Are other data structures used as well? Any examles of projects that use trees of types for example?
21:05:51 <EvanR> a heterotyped tree will need a tree of types
21:08:39 <EvanR> depending on what data structure means, strings, numbers, and datakinds expressing system states are used a lot
21:10:51 <deceract> I guess I'm wondering whether when there is interaction between the term- and type-levels, more efficient data structures are possible?
21:11:32 <deceract> I'm not sure how witnesses of type-level lists affect performance with dependent haskell. Perhaps witness of other type-level structures could have an effect on performance?
21:14:35 <EvanR> at the expense of programmer sanity :)
21:16:06 <EvanR> https://mail.haskell.org/pipermail/haskell-cafe/2011-August/094531.html "[Haskell-cafe] Type level Roman numerals and skew binary random access lists"
21:16:12 <EvanR> xD
21:17:33 <jared-w> deceract: it depends on how dependent types are implemented. GHC, specifically, is going to implement them with an "unsound type system" (the implications of that being that some proofs will have to be ran at runtime)
21:18:30 <deceract> EvanR: I'll take a look at that link and the papers it references. Thanks.
21:18:51 <jared-w> So that will impact performance somewhat. However, GHC will also come with a "trust me bro, I got dis" pragma that tells the compiler to just blankly assume the proof exists and is correct, so that will incur no runtime performance penalty if invoked. It will, however, necessairly remove any potential correctness guarantees that can be made by the compiler...
21:19:31 <jared-w> EvanR: that link is slightly frightening :p
21:19:57 <EvanR> agreed
21:20:54 <deceract> jared-w: Interesting. Are there any authoritative papers, links, ... that describe the GCH dependent-type implementation or the pragma?
21:21:38 <jared-w> Yup, you can read the massive PhD thesis of the guy who's strapping on that rocket ship into GHC itself. His blog is also similarly illuminating, if not quite a bit shorter :p (one sec I'll grab the link)
21:22:30 <deceract> Richard Eisenberg?
21:22:35 <jared-w> deceract: https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/  <-- a fairly brief and nice blog post
21:22:42 <jared-w> yeah, Richard. I always blank on the name for some reason
21:23:15 <deceract> Cool. Thx. I'll definitely have to check out his blog.
21:24:21 <deceract> He'll probably say, but will there be significant differences from Idris's implementation? I can't remember if Idris's types and kinds are fused too.
21:24:39 <c_wraith> very different
21:24:58 <c_wraith> among other things, haskell will remain lazy
21:25:24 <c_wraith> Which is why some proofs will still have to be done at runtime
21:25:39 <deceract> Laziness affects the type level? I wouldn't have thought that'd be the case.
21:26:26 <jared-w> Laziness means you can't guarantee the execution order of pretty much anything. Combine that with a non total(?) type system and you have basically no way to avoid runtime proofs
21:26:26 <deceract> Aside from the additional units strewn about.
21:26:50 <c_wraith> laziness also means you can say "this is true, unless it doesn't terminate"
21:27:10 <c_wraith> You can't just take that as a proof of the assertion, though
21:27:18 <c_wraith> You have to actually check for termination at runtime
21:27:38 <jared-w> Which is where the "trust me bro" annotation comes in, I think?
21:27:40 <c_wraith> this is why most dependently-typed languages are total
21:27:53 <c_wraith> when they're total, they don't have that issue
21:29:17 <EvanR> essentially, are these proofs of the type () or _|_
21:30:08 <EvanR> is there a way to optimize a computation so it fails to terminate faster? :)
21:31:09 <jared-w> Sure, just create a turing machine that can detect infinite loops and run the TM on the computation. If the TM rejects the computation, don't bother to run it. Not sure why anyone hasn't gotten around to doing that yet, it's pretty simple /s
21:31:20 <EvanR> actually in that case it would be better to fail slower hehe
21:31:44 <EvanR> use less resources in the process of freezing up
21:31:47 <deceract> Laziness lifts types to include bottom, and so non-termination is accounted for. But how does laziness affect a dependent-type system? (Perhaps your statements speak to that, but I'm not sure how.)
21:32:12 <deceract> Idris isn't total, is it? Unlike Agda, Coq, etc.
21:32:28 <EvanR> it has a totality checker that can be disabled
21:32:35 <EvanR> on a case by case basis
21:32:42 <jared-w> Pretty sure the totality checker is off by default
21:33:00 <EvanR> theres a few levels of defaults and configurations
21:33:10 <jared-w> gotcha, that makes sense
21:34:55 <EvanR> no matter what the settings are, you can do :total foo to check totality status
21:35:04 <jared-w> deceract: In dependent types, types can depend on values
21:35:34 <jared-w> In Haskell, you can have weird semantics involving bottom because of laziness. I'd imagine that has something to do with it
21:35:54 <jared-w> > const 1 undefined -- won't compile in a strict language
21:35:56 <lambdabot>  1
21:36:19 <EvanR> will compile, will crash ?
21:36:45 <jared-w> compile was a bad word. It won't work the same as a lazy language :p
21:38:16 <deceract> So 'undefined' is a tractable value in a lazy language, but that doesn't seem especially relevant (aside for its being the essential difference between strict and nonstrict languages). Does laziness cause other implementation or type-theoretical effects?
21:39:11 <EvanR> are we talking about something to the effect of asking for the `last` element in a list of types, somewhere in a type level expression ?
21:39:18 <EvanR> and the list being infinite?
21:40:21 <EvanR> presumably causing the type checker to freeze up
21:41:09 <deceract> Sorry. Laziness also makes final fixed points too. I guess what's thrown me is the connection laziness has with implementation of dependent-type systems.
21:41:38 <oelcle> I have a very simple function on an hlist which correctly fails to typecheck. When I lift that function to the type level, that type family does kind check. The latter seems wrong to me. What's going on? http://lpaste.net/357098
21:41:39 <deceract> (Though, again, you guys may have already spoken to that.)
21:41:41 <EvanR> in so far as you can do value-like computation at the type level...
21:42:47 <EvanR> seems connected
21:43:18 <EvanR> i didnt even think of this complication until just now :)
21:44:00 <deceract> EvanR: Ok, cool. I'll just have to mull it over a bit more. Thanks.
21:48:07 <trigone> hi, i've seen the where keyword indented the same way than the clause it follows. is that legal?
21:48:18 <glguy> oelcle: foo :: a -> HList (b ': cs) -> HList (a ': b ': cs) is the correct type
21:48:56 <oelcle> glguy: Right. So why does GHC permit the incorrect kind in the type family?
21:49:06 <oelcle> Is it just a bug? Or am I missing something?
21:49:25 <jared-w> trigone: That sounds fine to me. If it compiles, it works :p
21:49:59 <geekosaur> trigone, not per the standard but recent ghc has the NondecreasingIndentation extension enabled by default
21:50:36 <geekosaur> (I kinda wish it didn't, you're the third one to ask this week and one of the askers had a bug caused by it (!) )
21:51:14 <trigone> geekosaur: Really, what sort of bug?
21:52:39 <trigone> What else does this extension permit that was not permitted before? Just by curiosity, personally I prefer a decreased indentation too.
21:52:40 <geekosaur> you can't decrease indentation past the left side of the line, so the compiler got confused about a definition following a do block that wasn't indented. the resulting error message is rather confusing unless you know about the NondecreasingIndentation extension
21:53:42 <glguy> oelcle: I don't know what that's doing. It relies on TypeInType
21:53:45 <trigone> geekosaur: I don't follow. Someone wrote a do block directly on floor level?
21:54:10 <geekosaur> yes, and ghc let them because of NondecreasingIndentation
21:54:27 <geekosaur> but any following definitions are illegal because you can't decrease indentation to get out of the do block
21:54:34 <glguy> oelcle: I think that it has noticed that a and b must both be *, so it doesn't matter a : b : cs, or b : a : cs or a : a : cs
21:54:43 <trigone> geekosaur: I see! Indeed that's absurd syntax.
21:54:59 <zoey> is haskell lazy because it didn't have a strong parental figure
21:55:42 <jared-w> That's actually a common misconception
21:56:28 <jared-w> In reality, Haskell very much follows the "stern paternal figure" style of parenting in which it lovingly smashes your face against the desk with obscure type errors in an attempt to guide you towards enlightenment. If you don't grok Haskell, it is seen as a failure on your part rather than a failure of the family
21:56:54 <trigone> zoey: I think haskell grew up around very strict and very stressed siblings, and decided to avoid such a sad life.
21:57:08 <jared-w> Contrast this with Rust which takes a very much nuturing family approach to compiler errors, owing to its creation by liberal hippies in Mozilla, and it becomes quite obvious
21:57:41 <trigone> jared-w: I disagree. It's more like the lonely kid who invented their own language, so they talk to you their own way, you just gotta adapt.
21:58:02 <zoey> python is that kid that always says "uh huh" to whatever you're saying
21:58:05 <jared-w> No that's php
21:58:13 <zoey> what's python
21:58:26 <jared-w> I meant php in response to trigone :p
21:58:27 <trigone> zoey: Python tells you "try and catch me if you can"
21:58:35 <jared-w> I'd say JS is more a language that says "uh huh" to whatever you're saying
21:58:37 <zoey> that kid that pretends to be your friend but really that one thing you did had a side effect of changing their state to enemy
21:59:04 <jared-w> 1 + "1" in JS compiles just fine and breaks in Python3
21:59:38 <jared-w> Hmm... Python feels like that one weird family who's completely normal
21:59:53 <trigone> jared-w: JS is high and drunk and starts computing using chairs and windows and people as numbers.
21:59:54 <jared-w> except for the fact that whenever you walk into their house, you're struck by the profound sense that literally everything they own they bought at Target
21:59:54 <mnoonan_> instance Num String where...
22:00:00 <zoey> i use python for many years now... i see shortcomings so i am learning hasskelll
22:01:08 <EvanR> if programming languages were dysfunctional suburbian families?
22:01:10 <deceract> What shortcomings do you see?
22:01:13 <jared-w> zoey: proceed at your peril. Haskell may ruin your ability to enjoy programming in inferior languages ;)
22:02:24 <trigone> jared-w: That's about the truest thing to tell to a beginner!
22:03:43 <deceract> SPJ has said that a sign of a good programming-language design is an almost existential/logical/aesthetic entailment of certain sytactic features. But that seems less and less the case as new sytactic idioms are glued onto the haskell standard. Has haskell lost its footing somewhat?
22:04:15 <trigone> EvanR: perl is this paranoid family that speaks in hash code so much they can't decrypt their own conversations (but at least nobody else can either)
22:04:24 <jared-w> Haksell lost its footing when they made the stupid-ass decision to change : from being the type operator to being `list cons`
22:04:38 <jared-w> It's never truly recovered from that, but being 94.3% perfect isn't bad
22:04:48 <deceract> Yep, that's an obvious face-plant.
22:04:54 <EvanR> in the beginning perhaps many people thought type sigs would be uncommon, like in other inferred langauges
22:04:56 <trigone> jared-w: type operator you mean :: ?
22:05:18 <jared-w> Yeah. In type theory, mathematics, etc., you use : for types not ::
22:05:23 <EvanR> originally you could get by with no annotations at all
22:05:27 <deceract> But what about stuff like "type family"...? It seems quite arbitrary to mine eyes at least.
22:05:47 <EvanR> well, look at declaration syntax in e.g. coq
22:05:59 <EvanR> the name "type families" for the feature is a little weird
22:06:02 <jared-w> Haskell had 100% type inference in the beginning so actually writing the types seemed useless, so they chose : for types and : to prefix all symbolic constructors (with the empty string being the special case for lists)
22:06:04 <trigone> jared-w: Well you can't always write in Math especially when limited (for the most part) to ascii...
22:06:16 <jared-w> trigone: don't tell that to the Agda people :p
22:06:16 <deceract> I've never checked out Coq. I'll make it a point to do so.
22:06:19 <EvanR> but besides that, its trying to appeal to declarations
22:06:39 <EvanR> and not clobber too many keywords unnecessarily
22:06:43 <EvanR> why we have only forall and not exists
22:07:08 <jared-w> Aside from the point that we don't actually have existential types yet, right? (Or do we and I totally missed that)
22:07:10 <trigone> jared-w: Personally :: is much easier to read than a more discreet :
22:07:22 <EvanR> for existential quantification
22:07:34 <EvanR> youd perhaps expect to say "there exists"
22:07:42 <jared-w> trigone: that's probably just because you're used to it. I find both the same and prefer : because it's closer to math and it's more "correct"
22:08:06 <jared-w> EvanR: true, I suppose 'exists' makes enough sense to me because in LaTeX I would type \exists and \forall ¯\_(ツ)_/¯
22:09:20 <trigone> jared-w: Maybe. Personally I find the poor documentation Haskell's #1 issue way before some annoying syntactic stuff.
22:09:22 <EvanR> currently, i see the data syntax as shorthand for GADT syntax, and now that we actually have GADT syntax, it seems goofy
22:09:30 <EvanR> and thats why forall works for existential quantification
22:09:37 <EvanR> proof by goofyness
22:09:51 <jared-w> I can see that :p
22:09:54 <EvanR> poor documentation of haskell?
22:09:59 <EvanR> or of certain libraries
22:10:02 <jle`> data syntax and gadt syntax offer diferent perspectives though
22:10:24 <jared-w> trigone: Doncha know? The types are all you need bro. Just find your center and let the types guide you to the 7th chakra of enlightenment
22:10:28 <jle`> GADT syntax makes sense when talking about constructors
22:10:28 <EvanR> i dont know
22:10:35 <jle`> but it doesn't make sense at all when talking about deconstructors/patterns
22:10:36 <trigone> EvanR: no, the libraries. but in haskell, you can't really put the libraries aside...
22:10:48 <EvanR> data Foo = Bar Int | Baz Bool
22:10:55 <EvanR> that doesnt look like anything else
22:11:00 <EvanR> constructor or destruction
22:11:13 <EvanR> you cant apply Bar to a type
22:11:45 <jle`> yeah, data syntax doesn't really match anything with respect to construction
22:11:47 <jared-w> tbf Data Const a b = Const { getConst :: a } -- Still don't really get how this syntax works
22:12:25 <EvanR> its a shorthand accomplishing like 5 things that are all separate in GADT syntax (with kind signatures)
22:12:26 <trigone> jared-w: I'd argue that in the most important (and complex) cases, types are just not enough to understand how the functions/classes are meant to be used.
22:12:27 <jle`> but you can pattern match on `Bar x`...and while data syntax isn't perfect, it's a lot more literal than GADT syntax
22:12:27 <jared-w> like, people write out getConst and then I never see it defined anywhere?
22:12:36 * geekosaur just reported the NondecreasingIndentation issue, having forgotten to do so earlier
22:13:10 <EvanR> jared-w: its defined by that data declaration
22:13:11 <geekosaur> (https://ghc.haskell.org/trac/ghc/ticket/14008#ticket includes the example that revealed it)
22:13:14 <trigone> jared-w: yeah i do hate this syntax too. Extremely hard to read to me.
22:13:25 <jared-w> trigone: that's the difference between API documentation and usage documentation. Haskell's API documentation is, in general, world class
22:13:47 <jared-w> Haskell's usage documentation or other softer forms of documentation are generally lacking for many libraries...
22:13:47 <trigone> jared-w: Oh you mean the phantom b type?
22:13:58 <geekosaur> jared-w, it's defining a record with named fields. in this case one field, named getConst
22:14:34 <jared-w> No, not the phantom b type, I've just never seen records /really/ spelled out in a way that I get yet. Idk if I haven't found the right tutorial, or if I somehow skipped the part in the HaskellBook where that was supposed to make sense... ¯\_(ツ)_/¯
22:14:50 <geekosaur> and the syntax is not so far removed from C: struct const_s { const_t getConst; };
22:14:56 <trigone> geekosaur: it's still rather confusing to write getConst :: a when getConst will have type (Const  a b -> a) in reality!
22:14:58 <jared-w> I'm not too worried, I'll grok it at some point. It makes more sense every time I stare at it :p
22:15:01 <EvanR> records are explained pretty well in "Types and Programming Languages" :)
22:15:24 <EvanR> too bad more programming language inventors didnt read that section :(
22:15:28 <jared-w> EvanR: sweet. It's on my list of stuff to read. I'll bump it up :p
22:15:35 <geekosaur> and when you do that in C, you do not have a thing called getConst, you have a label that is only valid after . or ->
22:15:55 <deceract> Should (or can) the | in algebraic data types be syntactic sugar for 'Either'? Compiling down to tagged constructors would improve performance, but does distinguishing between | and Either have any type-theoretical necessity?
22:15:58 <jared-w> EvanR: you think that's bad. Apparently the people who invented half the modern languages out there didn't read anything useful in the last 50 years of PL development ;-;
22:16:03 <marvin3> jared-w, make a simpler example. do you understand how this works? data Person = Person { name :: String, int age }
22:16:14 <EvanR> deceract: | is 'or'
22:16:19 <trigone> geekosaur: yeaaah but C was never meant to be read *cough* consistent so it's just #342 weird thing to remember.
22:16:20 <deceract> It seems at this point, 'run{...}' has become the norm, right? Despite some of the un's, get's, etc.
22:16:34 <geekosaur> deceract, depends on the context
22:16:53 <geekosaur> run* is generally used when defining a type intended to be used as a monadic action.
22:17:25 <marvin3> data Person = Person { name :: String, age :: Int }, even!
22:17:40 <geekosaur> un* when it's just a type-discriminating wrapper. get* is not so popular but enshrined in the standard library because of the Monoid newtypes that use it
22:18:04 <EvanR> Roll { unroll :: ...
22:18:12 <jared-w> marvin3: that one makes sense to me I think. The equivalent in data syntax is just data Person = Person String Int, right?
22:18:47 <marvin3> jared-w, yes except that it also creates age :: Person -> Int and name :: Person -> String functions
22:18:59 <geekosaur> along with functions name :: Person -> String; name (Person n _) = n; age :: Person -> Int; age (Person _ n) = n
22:19:05 <jared-w> ahh right, knew there was a reason we named these things useful things
22:19:24 <EvanR> i kind of dont want those functions to be called that :(
22:19:39 <EvanR> just the fields
22:20:00 <geekosaur> and about half the time I consider that brilliant and the other half wish someone had considered that namespacing of structure members is useful (see: *all* the lens/fclabels/etc. packages)
22:20:00 <trigone> I still don't think it's a smart thing to write run :: a when run is Not of type a at all. It's totally inconsistent.
22:20:43 <EvanR> if we had records, then { field1 :: Int, field2 :: String } would be consistent
22:20:52 <EvanR> as a record type. those fields are those types
22:21:00 <jared-w> geekosaur: agreed. I'm a large fan of namespaced structs in general. It just... makes way more sense to me? Perhaps it's still a holdover from instinctively wanting struct.member like in C
22:21:03 <EvanR> but field1 and field2 would not be projections
22:21:16 <geekosaur> trigone, K&R C is actually fairly consistent especially if you know that it evolved from BCPL. it's just not a consistency that makes much sense to people. :p
22:21:42 <EvanR> jared-w: thats not a namespace... the fields in C work on any struct with that label
22:21:45 <trigone> geekosaur: yeah, i admit C is hardly bad on consistency.
22:21:48 <EvanR> without being qualified
22:21:52 <geekosaur> and then ANSI came along and added stuff that doesn't really quite fit into the K&R framework
22:21:59 <EvanR> which is damn nice 
22:22:27 <geekosaur> (let alone what C++ did to it...)
22:22:28 <jared-w> EvanR: right, I get that, it's just that namespaces for structs seem to serve somewhat similar purposes, so my brain just kinda makes that correlation
22:22:45 <jared-w> show me on the doll where the C++ touched you, geekosaur
22:23:03 <EvanR> idris namespaces its accessors
22:24:39 <trigone> EvanR: and the syntax is consistent? no weird projection thingy?
22:25:11 <oelcle> glguy: What makes you say that both a and b must be * ?
22:26:21 <jared-w> trigone: https://deque.blog/2017/06/14/10-things-idris-improved-over-haskell/ #3 on the list
22:27:13 <EvanR> trigone: its not that revolutionary, it just creates the equivalent of a import ... as MyRecordTypeName with the accessors in it
22:27:26 <EvanR> you can use them unqualified if they dont collide
22:28:09 <EvanR> it still doesnt really settle my gripe though
22:28:26 <trigone> EvanR: actually, it's as absurd on the level of creating projections homonymous to members and therefore "sortof" declared with the wrong type.
22:29:17 <jared-w> EvanR: what is your grip, then? Did I miss it?
22:29:21 <trigone> EvanR: It's the worst when the member's name is clearly named to be a projection because you won't use the attribute name at all, eg when the Data type is a simple wrapper, like runState
22:29:21 <jared-w> gripe*
22:29:35 <EvanR> the field names that appear inside the record def are not variables, or functions, or anything so its not clear anything has the wrong type
22:29:45 <trigone> @src State
22:29:45 <lambdabot> type State s = StateT s Identity
22:29:45 <lambdabot> --OR
22:29:45 <lambdabot> data State s a = State { runState :: s -> (a, s) }
22:30:06 <EvanR> read that as "the runState field has a value of the type s -> (a, s)"
22:30:17 <EvanR> and then we abuse that as a runState function
22:30:23 <EvanR> with some other type
22:30:49 <EvanR> Friday night is haskell bashing night at #haskell downtown!
22:30:58 <jared-w> lol
22:31:01 <trigone> EvanR: yes but obviously the name runState corresponds to the projection function, not to the field name. it makes no sense and therefore to me is very hard to read
22:31:18 <EvanR> it corresponds to both
22:31:26 <EvanR> foo { runState = bar }
22:31:33 <trigone> EvanR: i mean the *choice of the name*
22:31:52 <EvanR> State { runState = bar }
22:31:57 <deceract> EvanR: Could an extension be written to address your gripe? What would be your own preference? Anyway, fields and records in haskell seem to be a gripe of many.
22:33:08 <trigone> EvanR: nobody would ever write State { runState = foo }, because you don't need record syntax. runState is the name of the projection, and it creates a field whose name is not consistent with its content.
22:33:13 <trigone> nor its type
22:33:27 <EvanR> i believe the suggestion was, if foo is a field, then #foo is the accessor
22:33:46 <EvanR> and that could these days be a lens
22:34:10 <EvanR> trigone: er, so youre only talking about the specific case of State's newtype
22:34:28 <EvanR> more generally that word there refers to projects and fields at the same time
22:35:24 <EvanR> another suggestion is to make record updates first class, which.......
22:36:14 <EvanR> idris did
22:36:17 <trigone> EvanR: Actually the most used libraries are the most abstract, and most times it's monadic wrapping with unimportant fields whose types are right beside the projection names and that's very confusing
22:36:42 <EvanR> sure, transformers are another season of gripes
22:37:20 <jared-w> I think algebraic effect systems are going to be the new thing on the block to replace transformer stacks?
22:37:39 <glguy> I wouldn't expect that to happen
22:37:59 <deceract> Some notable personae seem to (kinda) oppose effect systems, though.
22:38:11 <jared-w> Hmm, perhaps they're just the new trendy thing to blog about then :p
22:38:17 <trigone> EvanR: If i write Data Person = Person { getName :: name }, does that not feel confusing when trying to understand what's inside Person? is that a name or an accessor for name? what's the type of getName?
22:38:45 <EvanR> you arent suppose to call it getName, by convention, thats where you write the field name
22:38:48 <EvanR> not the accessor name
22:38:55 <EvanR> my gripe is that... that is what the accessor gets called
22:38:59 <trigone> EvanR: well, tell precisely that to runState
22:39:10 <EvanR> you really want { name :: String }, that is the standard notation for records
22:39:22 <EvanR> i agreed with you way back
22:39:25 <EvanR> on that
22:39:51 <trigone> lol ok then that's settled
22:39:59 <EvanR> jared-w: ive been getting shot down over algebraic effects since a few years ago :)
22:40:17 <jared-w> EvanR: before it was cool? lol
22:40:23 <EvanR> its cool?
22:40:28 <glguy> just before
22:40:45 <jared-w> I've seen a lot more posts about it in the last few months ¯\_(ツ)_/¯ 
22:40:55 <deceract> Very. The scala and purescript have already started to incorporate effect systems to some extent, I think.
22:41:03 <deceract> *communities
22:41:06 <jared-w> of course that doesn't mean much since I've been reading a lot more Haskell stuff in general in the last few months :p
22:41:12 <EvanR> i heard theres an advanced type which allows you to use any effect that ever existed, it promises to make your life much more convenient
22:41:18 <trigone> EvanR: i think the definition of state should have been State { state :: ... }, and then if they wanted they could have added a runState alias to add more meaning to the projection automatically made... so yeah in a way it's rather the fault of those writing the libraries :P
22:41:44 <trigone> EvanR: Yeah it's the NirvanaIO
22:41:50 <glguy> It would be kind of silly to name the field "state" since the thing that goes there isn't the state
22:42:14 <glguy> unless you're not talking about State from transformers
22:42:18 <EvanR> how about dont use record syntax there
22:42:40 <jared-w> EvanR: that makes too much sense though
22:42:43 <deceract> Can an extension be written to emulate some of Idris's namespaces?
22:42:49 <trigone> glguy: well yeah it's not really needed there, the guys were too lazy to write state (State a) = a
22:42:56 <jared-w> We need record syntax because it's nifty
22:43:01 <trigone> i mean runState (State a) = a
22:43:05 <jared-w> It makes you look like you know what you're doing
22:43:10 <trigone> jared-w: lol
22:43:19 <EvanR> funny aside, the function actually called state also "isnt the state" :)
22:43:26 <EvanR> :t state
22:43:27 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
22:43:38 <jared-w> deceract: wasn't that the motivation behind the template haskell "I solve the record problem" library?
22:44:08 <trigone> EvanR: from what i saw functions rarely have an actually appropriate name, mostly for terseness reasons...
22:44:27 <jared-w> https://nikita-volkov.github.io/record/
22:44:37 <trigone> though i don't know at all what this state does
22:44:45 <jared-w> oh no that was just first class records, not necessairly namespacing
22:44:46 <deceract> That and everything else. A bit kitchen-sinky.
22:45:43 <EvanR> trigone: this is where the type signature should indicate something...
22:46:09 <EvanR> all else fails read the 1 sentence doc
22:46:28 <trigone> EvanR: indicate something, yeah, that i need to read what MonadState means...
22:46:40 <deceract> Ok, guys. Thanks for letting me listen in. Later.
22:46:57 <EvanR> "Updating nested records is exponentially tedious" not sure if this usage of exponentially is correct, or auto disqualifies the library :)
22:47:53 <EvanR> trigone: MonadState is a class for monads that provide the traditional methods of the State monad
22:48:02 <EvanR> get put modify etc
22:48:53 <EvanR> including State now
22:49:12 <trigone> EvanR: kay... so it transforms a function into a monadstate monad (polymorphically). in a way it's a polymorphic State (the data constructor, not the type cons)
22:49:31 <EvanR> not into a monad, an action in that monad
22:49:55 <trigone> EvanR: ok, i mean monadic value of a monadstate monad, sorry
22:50:06 <EvanR> monadic value hugrmrmhmm
22:50:20 <trigone> EvanR: cuz your lousy action metaphor is better? :P
22:50:22 <EvanR> anyway, the s is not used in the result, so you know its discarded
22:50:38 <EvanR> the a is used, so you know it MUST be returned
22:50:57 <EvanR> and where the hell would it get an s, you could infer it comes from your state
22:51:39 <EvanR> im totally wrong... the returned s could indeed be used in your state monad
22:51:45 <EvanR> like, saved
22:51:48 <EvanR> now i need to read the docs
22:51:55 <trigone> EvanR: well yeah i think the m would be short for (State s)
22:52:01 <jared-w> lol and on that note I'm gonna head to bed too. See y'all
22:52:04 <trigone> i mean not short, but you know
22:52:04 <EvanR> it could be
22:53:16 <trigone> EvanR: i think there's a connection of dependency or sth between s and m in MonadState which allows for an implicit s or something... I'm not really good in these yet
22:53:21 <EvanR> so it promotes a poor-man's-stateful-function into an m a
22:53:22 <trigone> @src MonadState
22:53:22 <lambdabot> Source not found. Abort, Retry, Panic?
22:54:02 <EvanR> no implicit s
22:54:17 <trigone> EvanR: yeah sort of. it's like State itself, but polymorphic. it's vaguely fitting, if you consider State/state as implicitly meaning "State Handler" or something
22:54:29 <trigone> EvanR: yeah i don't spell it right
22:56:05 <EvanR> State/state embed an s -> (a,s) as State s a / m a
22:56:54 <trigone> EvanR: yeah, so?
22:57:24 <trigone> i'm wondering what's the pure of state btw...
22:57:59 <trigone> nah it's more like pure a = \s -> (a, s) or sth
22:58:07 <jle`> of State, you mean?
22:58:10 <trigone> i mean pure a = State $ ...
22:58:40 <EvanR> right
22:58:40 <trigone> jle`: yeah, i'm lazy on my shift keys, don't wanna have to replace them too much
22:58:46 <EvanR> pure = return
22:58:50 <jle`> trigone: no worries
22:58:59 <jle`> just wasn't sure which one you were talking about
22:59:03 <trigone> EvanR: i know but i don't like return
22:59:14 <EvanR> nonetheless it answers the question 
22:59:23 <trigone> EvanR: what answers the question?
22:59:26 <EvanR> return
22:59:40 <trigone> you mean return = 42?
22:59:46 <EvanR> pure = return
23:00:06 <trigone> EvanR: yeah, we already addressed that... i still don't get your question
23:00:12 <trigone> i mean the question answered
23:02:33 <trigone> nevermind :P see y'all, i'll be pure later!
23:05:48 <EvanR> i was totally on board https://nikita-volkov.github.io/record/ until i saw "behind the scenes its as simple as a collection of tuple-like records of various arity... up to 24"
23:06:11 <EvanR> "which should be enough for anybody"
23:08:39 <arahael> heh.  still, if you want more, why not use a record?
23:09:35 <EvanR> they are records, with fancy features for sharing field names and summoning lenses
23:10:03 <EvanR> according the the remark, all of which wheels fall off if you have 25 fields
23:10:32 <EvanR> youd have to the such records differently
23:12:22 <arahael> Sharing field names?
23:14:04 <EvanR> yes Type1 has name :: String, Type2 has name :: String too, and it "just works"
23:14:24 <arahael> I think in C#, the largest tuple is about 8 items. I don't think there's any limit in C++, but...  The whole point of a tuple is to have a structure with position-sensitive values?
23:14:34 <arahael> It's not something that should be used as a list or generic container.
23:14:35 <EvanR> its not a tuple, its a record
23:14:58 <arahael> Ah...  I misinterpreted the term "tuple-like records". :)
23:14:59 <EvanR> and records in the wild tend to go over 24
23:15:07 <EvanR> i meant to say tuple-like types
23:15:19 <EvanR> there is some nonsense bhind the scenes to get the fields to work out
23:15:32 <arahael> In my naivette, I had interpreted it to be: "Approximating/emulating tuples using records".
23:16:37 <cocreature> I wonder why it’s limited to that. since it uses TH anyway, generating it up to 63 or whatever the limit is that we have in Haskell should be pretty easy
23:18:25 <EvanR> theres a limit of 63 components?
23:18:37 <EvanR> in an ADT?
23:18:47 <cocreature> no for tuples
23:19:25 <EvanR> data Record2 (n1 :: Symbol) v1 (n2 :: Symbol) v2 = Record2 v1 v2  
23:19:32 <glguy> Haskell promises up to size 15 tuples, GHC provides up to 63
23:19:40 <EvanR> so no need for a limit, just generate all of them !
23:20:38 <EvanR> RecordAckermann99
23:23:12 <ongy> but they don't have any instances after a certain point
23:23:44 <EvanR> yeah thats a funny bit
23:23:57 <EvanR> it might go up to 7
23:24:53 <ongy> Generic op to 7, Eq and Ord a bit forther (what's o - a?)
23:25:11 <ongy> I wonder if they encountered some crashes with generic deriving on the larger tuples
23:25:13 <nshepperd_> Is there a limit to the fields of an adt though
23:25:53 <nshepperd_> Can i write a constructor with 2048 fields
23:26:00 <Lokathor> @pl (\c -> _cLocation c == loc)
23:26:00 <lambdabot> (line 1, column 8):
23:26:00 <lambdabot> unexpected "_"
23:26:00 <lambdabot> expecting lambda abstraction or expression
23:26:12 <Lokathor> @pl (\c -> cLocation c == loc)
23:26:12 <lambdabot> (loc ==) . cLocation
23:26:44 <EvanR> i hope you can
23:27:06 <Lokathor> nothing's stopping you but your RAM
23:40:23 <geekosaur> and compile times iirc
23:41:40 <geekosaur> there *is* an implementation limit on number of constructors: (maxBound :: Int)   (or maybe the corresponding Word; I don't know if anyone has ever checked for signedness issues in the constructor tag...)
23:42:18 <EvanR> haha
23:42:40 <geekosaur> ...but as the compile may run until the sun goes off the main sequence, I doubt anyone cares about the runtime behavior :p
23:43:31 <EvanR> i hope that rule of thumb is used on purpose and not by accident
23:51:09 <EvanR> types to verify the sun dies before this plan utterly fails
23:59:25 * hackagebot chart-unit 0.4.0 – Native haskell charts. – https://hackage.haskell.org/package/chart-unit
23:59:58 <kuribas> Ugh, the worse (quadratic) implementation gets the most (15) upvotes: https://www.reddit.com/r/haskell/comments/6oc40f/programming_problem_interview_solution_in_haskell/
